Program Repair Guided byDatalog-DefinedStatic Analysis
Yu Liu
NationalUniversity ofSingapore
Singapore
liuyu@comp.nus.edu.sgSergeyMechtaev∗
University CollegeLondon
UnitedKingdom
s.mechtaev@ucl.ac.uk
Pavle Subotić
Microsoft
Serbia
pavlesubotic@microsoft.comAbhikRoychoudhury
NationalUniversity ofSingapore
Singapore
abhik@comp.nus.edu.sg
ABSTRACT
Automated program repair relying on static analysis complements
test-driven repair,since it doesnot require failingteststo repaira
bug, and it avoids test-over/f_itting by considering program proper-
ties.Duetotherichvarietyandcomplexityofprogramanalyses,
existingstaticprogramrepairtechniquesaretiedtospeci/f_icanal-
ysers, and thus repair only narrow classes of defects. To develop
ageneral-purposestaticprogramrepairframeworkthattargetsa
wide range of properties and programming languages, we propose
tointegrateprogramrepairwithDatalog-basedanalysis. Datalog
solversareprogrammable/f_ixedpointengineswhichcanbeusedto
encodemanyprogramanalysisproblemsinamodularfashion.The
programunderanalysisisencodedasDatalogfacts,whilethe/f_ixed
point equations of the program analysis are expressed as recursive
Datalog rules. In this context, we view repairing the program as
modifyingthecorrespondingDatalogfacts.Thisisaccomplished
by a novel technique, symbolic execution of Datalog, that evalu-
atesDatalogqueriesoverasymbolicdatabaseoffacts,insteadof
a concrete set of facts. The result of symbolic query evaluation
allows us to infer what changes to a given set of Datalog facts
repairtheprogramso thatitmeetsthedesiredanalysisgoals.We
developedasymbolicexecutorforDatalogcalledSymlog,ontop
ofwhichwebuiltarepairtoolSymlogRepair.Weshowtheversatil-
ityofourapproachonseveralanalysisproblems—repairingnull
pointerexceptionsinJavaprograms,repairingdataleaksinPython
notebooks,andrepairingfourtypesofsecurityvulnerabilitiesin
Solidity smart contracts.
CCSCONCEPTS
•Softwareanditsengineering →Automaticprogramming ;
Automatedstatic analysis ;•Theory ofcomputation →Con-
straint and logic programming ;•Information systems →
Query languages .
∗Corresponding author
ESEC/FSE ’23,December 3–9, 2023, SanFrancisco, CA, USA
©2023 Copyright held bytheowner/author(s).
ACM ISBN979-8-4007-0327-0/23/12.
https://doi.org/10.1145/3611643.3616363KEYWORDS
programrepair,static analysis,Datalog,symbolic execution
ACM ReferenceFormat:
Yu Liu, Sergey Mechtaev, Pavle Subotić, and Abhik Roychoudhury. 2023.
ProgramRepairGuidedbyDatalog-De/f_inedStaticAnalysis.In Proceedingsof
the31stACMJointEuropeanSoftwareEngineeringConferenceandSymposium
on the Foundations of Software Engineering (ESEC/FSE ’23), December 3–9,
2023, San Francisco, CA, USA. ACM, New York, NY, USA, 13pages.https:
//doi.org/10.1145/3611643.3616363
1 INTRODUCTION
Programanalysisdeterminesifthebehaviourofagivenprogram
satis/f_iesacertainproperty.Programrepairbasedonstaticprogram
analysis is an attractive technique, since, in contrast to test-driven
programrepair[ 22],itdoesnotrequireexecutingtheprogram,thus
signi/f_icantly simplifyingdeployment, and it avoids test-over/f_itting
by taking program properties into account. A plethora of static
analysis techniques exist, each characterised by a unique set of
underlyingmechanisms,targetprogramminglanguages,andtarget
programproperties. These characteristics signi/f_icantlyimpact the
implementation and optimisation of each analysis. Existing pro-
gram repair methods based on static analysis do not accommodate
this diversity, and are inherently tied to speci/f_ic analysers. This
restricts theircapacity torectify awide class ofdefects.
Thegoalofthisworkistodesignamodularstaticprogramrepair
systemthat/f_ixesbugsviolatingawiderangeofprogramproperties
acrossmultipleprogramminglanguages.Themodularityimplies
that the conceptual components, the modeling of programming
languagesemantics,analysisalgorithms,searchspaceconstruction,
and patch generation, are independent and reusable. Such a design
radicallyreducesthecomplexityofcreatingastaticprogramrepair
systemcapableofeﬃcientlyaddressingawidespectrumofdefects.
Our proposed architecture leverages the modular static analysis
frameworkbasedonDatalog.Inthissetup,Datalogactsasadomain
speci/f_iclanguage(DSL)forde/f_iningprogramanalyses.Aprogramis
encodedintoadatabasei.e.,asetofinputrelations,andtheprogram
analysisconstraintsarede/f_inedasaDatalogquery.ADatalogsolver
acts as a programmable /f_ixed point engine that computes a least
/f_ixedpointsolutiontotheprogramanalysisconstraints.Datalog
enables both a succinct and modular encoding of the program
analysis, while providinghigh eﬃciency and interoperability [ 33].
Tointroduceprogramrepairtothissetup,weproposeanovel
approachcalledsymbolicexecutionofDatalog(SEDL). Wede/f_ine
therepairsearchspacebyinjectingsymbolsintotheinputrelations
Thiswork islicensedunderaCreativeCommonsAttribution4.0Interna-
tional License.
1216
ESEC/FSE ’23, December3ś9, 2023,San Francisco, CA, USA YuLiu, Sergey Mechtaev, Pavle Subotić, andAbhik Roychoudhury
Buggy
PL’s semanticsModeling
constructionSearch space
execution
of querySymbolic
solvingConstraintmappingSource codeSymbolic
SymlogViolationDatalog
AnalysisasChange ofProgram
Program
Facts
DatalogQueryFactsPatch
DatalogFacts
Inference
Conditions
Figure 1: SymlogRepair, a program repair system using sym-
bolicexecution ofDatalog(SEDL) implemented inSymlog.
representing the buggy program. These symbols denote unknown
constants, unknown predicates, and unknown truthfulness of facts
inthedatabase.Theresultingsymbolicdatabaserepresentsaset
of changes to the original database. SEDL executes the Datalog
analysisqueryonthesymbolicdatabase,andtheoutcomeofthis
execution summarises how values from various subdomains, when
substituted in place of symbols, impact the inference of various
output facts. These subdomains, expressed as logical constraints
over the symbols, capture the dependencies between the input and
outputofthequery;inanalogywithpathconditionsinconventional
symbolicexecution,wecalltheminferenceconditions. Givenan
inferenceconditionforanoutputfact,anysatisfyingassignment
of symbols enables the inference of this fact, and any falsifying
assignmentdisablesitsinference.Torepairtheprogram,weusean
SMTsolverto/f_indavaluationofsymbolsthatproducesthedesired
query output,such as the absenceofproperty violations.
We implemented SEDL in a tool called Symlog, which utilises
thestate-of-the-artDatalogengineSouﬄé[ 19].Symlogtransforms
agivensymbolic databaseandqueryintoameta-program,which,
whenexecutedusingaconventionalDatalogevaluator,produces
the result of symbolically executing the original query on the orig-
inal database. To mitigate state explosion, we implemented two
optimisationtechniquesforthemeta-program.First,wegrouppos-
sible valuations of symbols into equivalent classes to eliminate
redundant exploration of identical proof trees during symbolic
Datalogevaluation. Second,we apply delta-debugging[ 46]toeﬃ-
ciently identify dependencies between input and output facts. The
key advantage of the meta-programming approach is that it allows
ustoleveragetheoptimisationsprovidedbyexistingDatalogen-
gines [36] without modifying the engines. Lastly, we implemented
SymlogRepairthatgeneratescandidatepatchesbysolvingSymlog’s
inference conditions for program analysis outputs with Z3 [ 10] to
avoid property violations, and then ranks the candidates based on
minimality. The architecture of SymlogRepair is shown in Figure 1.
To demonstrate the modularity of the proposed architecture, we
specialisedSymlogRepairforsixtypesofdefectsacrossthreepro-
gramminglanguages.First,werealised SymlogRepair [NPE,Java],
whichusesSEDLtorepairnullpointerexception(NPE)bugsinJava
programs[ 12].WeuseDoop[ 8]tomodelthesemanticsofJava,and
Digger [34] to de/f_ine the analysed property. Second, we realised
SymlogRepair [Leak,Python], the /f_irst approach for repairing data
leaksinPythonnotebooks[ 37].WeusetherulesbyYang et al.[44]to model the semantics of Python, and to de/f_ine the analysed prop-
erty.Finally,werealised SymlogRepair [Securify2 ,Solidity]forre-
pairing four classes of security vulnerabilities in Solidity smart
contracts: access control, unhandled exception, reentrancy, and
locked ether. We use Securify2 [ 2,40] to model the semantics of
smart contracts, andto de/f_inethe analysedproperties.
Inourevaluation, SymlogRepair [NPE,Java]correctlyrepaired8
outof10NPEbugsdetectedbyDigger,outperformingNPEX[ 24]by
1 correct patch, and AlphaRepair [ 43] and InCoder [ 15] by 6 and 8
correctpatchesrespectfully. SymlogRepair [Leak,Python]correctly
repaired 6 out of 11 notebook preprocessing leakage bugs detected
bytheanalyser,whileAlphaRepairandInCoderfailedtorepairany.
SymlogRepair [Securify2 ,Solidity]correctly repaired 63 out of 64
vulnerabilitiesinsmartcontracts,outperformingElysium[ 14]by
47 correct patches. Our optimisations played a key role in enabling
the generation of patches, as our tool without optimisations repair
fewer bugsdueto running outof memory.
The contributionsofour work are summarisedas follows:
•AstaticprogramrepairarchitecturebasedonDatalog,where
repair is formulated as the problem of modifying a given
databaserepresentingthebuggyprogramtomakethequery
representing the analysisdetectzeroproperty violations;
•Symbolic execution of Datalog (SEDL), the enabling compo-
nent of our architecture, which identi/f_ies how changes to
the databaseimpact the result of aquery;
•AneﬃcientimplementationofSEDLinatoolcalledSymlog1;
andits applicationto program repair,SymlogRepair.
•SymlogRepair instances: SymlogRepair [NPE,Java]for /f_ix-
ingNPEbugsinJavaprograms, SymlogRepair [Leak,Python]
for repairing data leak defects in Python notebooks, and
SymlogRepair [Securify2 ,Solidity]for repairing four classes
ofsecurityvulnerabilitiesinSoliditysmartcontracts,aswell
as an evaluation of theseinstancesonrealistic bugs.
2 OVERVIEW
In this section, we give an overview of our approach. We /f_irst
explain how Datalog is used to de/f_ine a program analysis. Then,
we demonstrate how SEDL, the key technical novelty of this work,
symbolicallyexecutesthisanalysis.Finally,weshowSymlogRepair
/f_ixes anull pointer exception (NPE)defect.
Sincethede/f_initionsofpracticalanalysesrequirehundredsof
lines of code, and the semantics of real-world programming lan-
guagesisextremelycomplex,fortheillustrativepurpose,weuse
simpli/f_iedlanguageandanalysis.Thelanguagecontainselemen-
tarystatements(variableinitialisations,assignmentsandmethod
calls), and call statement guards that check if a variable is not null.
The formalgrammarofthis languageisgiven in Figure 4.
Consider the following program written in our simple language:
x = null
y = x
y.call()
ThisprogramtriggersanNPEas ywillbenullwhen y.call() is
performed. The remainder of this section will describe how this
bugcan be detectedand/f_ixedwithDatalog.
1Implementation of Symlogand SymlogRepair: https://github.com/symlog/symlog
1217Program RepairGuidedby Datalog-DefinedStatic Analysis ESEC/FSE ’23, December3ś9, 2023,San Francisco, CA, USA
x = null
y = x
y.call()
1
2
3
flow(1, 2).
flow(2, 3).
assign_null("x", 1).
assign("y", "x", 2).
call("y", 3).
(a) A program’s CFG and its EDB
representation.npe(V, L) :-
call(V, L),
null(V, L),
!guard(V, L).
null(V, L) :-
flow(L1, L),
assign_null(V, L1).
null(V, L) :-
flow(L1, L),
null(V, L1),
!assign(V, _, L1),
!assign_obj(V, L1).
null(V, L) :-
flow(L1, L),
assign(V, V1, L1),
null(V1, L1).
(b) NPE analysis expressed as a Dat-
alog query.
x = null
y = x
if (y!=null) y.call()
1
2
3
+ guard("x", 3).
(c)Repairwithguardandthecor-
responding EDB change.
x = null
y = x
y.call()
1
2
x = new obj()4
3
- flow(1, 2).
+ flow(1, 4).
+ flow(4, 2).
+ assign_obj("x", 4).
(d) Repair with assignment and
thecorresponding EDB change.
flow(1,2) assign_null("x",1)
null("x",2) flow(2,3) assign("y","x",2)
null("y",3) call("y",3) !guard("y",3)
npe("y",3)
(e)Aproof treeof theoutput of NPE analysisquery demonstratingthepresence of an NPE bug.
Figure 2:A program witha null pointer exception(NPE) bug, an analysisthat detects this bug, its prooftree, andtwo repairs.
/u1D7093flow(/u1D6FC1,/u1D6FC2) assign_null("x",1)/u1D7091∧/u1D6FC1=1null("x", /u1D6FC2) /u1D7094flow(/u1D6FC2,/u1D6FC3) !assign("x",_, /u1D6FC2)/u1D7096assign_obj( /u1D6FC5,/u1D6FC6)/u1D7094∧/u1D6FC3=3∧¬(/u1D7096∧/u1D6FC5=“/u1D465”∧/u1D6FC6=/u1D6FC2)null("x", /u1D6FC2)
null("x", /u1D6FC2)/u1D7092flow(2, 3) assign("y","x",2)/u1D7092null("y",3) call("y",3) /u1D7095guard(/u1D6FC4, 3)¬(/u1D7095∧/u1D6FC4=“/u1D466.alt”)npe("y",3)
Figure 3:Asymbolicprooftree (in twoparts)ofan NPEafter inserting astatementbetween the nodes 1 and 2.
⟨stmt⟩::=⟨var⟩= new obj() | ⟨var⟩= null|
⟨var⟩=⟨var⟩ | ⟨call⟩
⟨guard⟩::=⟨var⟩!= null
⟨call⟩::=⟨var⟩.call() |if (⟨guard⟩)⟨var⟩.call()
Figure 4:Example programming language.
2.1 ProgramAnalysis with Datalog
Datalogisaquerylanguagebasedonlogicprogramming.ADat-
alog query is a set of Horn clauses comprising of a set of body
predicates (left part) and a head predicate (right part). The symbol
:-showsthattheleftpartislogicallyimpliedfromtherightpart.
A Datalog query is executed against a database of facts referred to
as the extensional database (EDB) and produces a set of derived
facts,referredtoastheintensionaldatabase(IDB).SinceDatalog
implements the semantics of /f_ix point computation, and many pro-
gram analysis algorithms are instances of /f_ix point computation,
Datalog is often used asa language for de/f_ining program analyses.
To analyse a program with Datalog, the program is represented
asanEDB.Forinstance,wecanconstructaprogram’scontrol-/f_lowgraph(CFG)asasetoffactsasshownin Figure2a.InthisEDB,the
predicate flowencodes arcs of the CFG, e.g.flow(1,2) states that
thereisanarcbetweenthenodes1and2.Thefact assign_null
("x",1)states that the variable xis assigned to null in the node
1;assign("y","x",2) states that the value of xis assigned to y
in the node 2, and call("y",3) states that a method of the object
storedin yiscalledinthe node 3.
Figure2b showsanexampleanalysisfordetectingNPEs.This
analysisde/f_inestwopredicates.Thepredicate npe(V,L) statesthat
there may be a dereferencing of null stored in the variable Vin
thenodeL.Thepredicate null(V,L) statesthatthevariable Vmay
storenullattheentryofthenode L.Thepredicatesarede/f_inedusing
four rules. The /f_irst rule states an NPE happens when a method of
anullobjectiscalledwithoutaguard.Thesecondrulestatesthat
a variablemay be nullatthe entry ofa nodeifitis assignedto null
inaparentnode.Thethirdrulestatesthatavariablemaybenull
attheentryofanodeifitisnotassignedattheentryofaparent
node, and may be null at the entry of that parent node. The fourth
rulestatethatavariablemaybenullattheentryofanodeifitis
assignedto avariable that maybe null inaparentnode.
WhenaqueryisexecutedonanEDB,aDatalogenginecomputes
allfactsthatcanbeinferredfromthedatabaseusingtherulesofthe
1218ESEC/FSE ’23, December3ś9, 2023,San Francisco, CA, USA YuLiu, Sergey Mechtaev, Pavle Subotić, andAbhik Roychoudhury
query.Forexample,fortheaboveprogramandanalysis,Datalog
infersthefact npe("y",3) statingthattheremaybeanNPEinthe
node 3. In Figure 2e, a proof tree visualises how this fact is derived.
2.2 Symbolic Execution ofDatalog
The key technical novelty of this work is SEDL that determines
how a change to the EDB aﬀects the output of a given query. A set
of changes to the database is encoded using symbols, and then the
queryisexecutedsymbolically.Theresultofsymbolicexecutionof
aDatalog querycompactlysummarisesthe relationsbetweenthe
inputsymbolsandthe outputofthe query.
Consider the following symbolic EDB obtained from the EDB in
Figure2a byinjectingsymbolicconstants /u1D6FC/u1D456representingunknown
constantsandsymbolicsigns /u1D709/u1D456representingunknowntruthfulness
(ifthe associatedfactsare true offalse):
/u1D7091flow(1, 2). assign("y", "x", 2).
/u1D7092flow(2, 3). call("y", 3).
/u1D7093flow(/u1D6FC1,/u1D6FC2). /u1D7095guard(/u1D6FC4, 3).
/u1D7094flow(/u1D6FC2,/u1D6FC3). /u1D7096assign_obj( /u1D6FC5,/u1D6FC6).
assign_null("x", 1).
AnyvaluationofthesesymbolscorrespondstoaconcreteEDB.For
example, the original EDB corresponds to the following valuation:
{/u1D7091↦→/u1D447,/u1D7092↦→/u1D447,/u1D7093↦→/u1D439,/u1D7094↦→/u1D439,/u1D7095↦→/u1D439,/u1D7096↦→/u1D439,...}.
Executingtheanalysisin Figure2b onthissymbolicEDBwith
SEDL yields the fact npe("y",3) and the inferencecondition /u1D719for
this fact de/f_inedas a/f_initesetofdisjuncts:
/u1D719≜/u1D7091∧/u1D7092∧¬(/u1D7095∧/u1D6FC4=“/u1D466.alt”)
∨(/u1D7092∧/u1D7093∧/u1D6FC1=1∧/u1D7094∧/u1D6FC3=2
∧¬(/u1D7096∧/u1D6FC5=“/u1D465”∧/u1D6FC6=/u1D6FC2) ∧¬(/u1D7095∧/u1D6FC4=“/u1D466.alt”))
∨...
Each disjunct represents a subset of programs encoded in the sym-
bolicEDBwherethedefect npe("y",3) isdetectedusingthesame
proof. The /f_irst disjunct corresponds to the original program. The
seconddisjunctcorrespondstobuggyprogramswithastatement
insertedbetween the nodes 1and2, for example,
x = null
y = new obj()
y = x
y.call()
A symbolic proof tree corresponding to the second disjunct is
giveninFigure3.Inthisprooftree,thelabelsateachproduction
capture the conditions under which the rule can be applied. The
disjunct iscomputedas aconjunction ofalltheselabels.
2.3 Fixing anNPEwith SymlogRepair
WenowdemonstratehowtoapplySEDLforprogramrepair.Given
abuggyprogramandaDatalog-de/f_inedanalyserthatdetectsthe
bug, SymlogRepair de/f_ines the patch search space by injecting
symbolsintoanEDBrepresentationoftheprogram.Themethodof
search space construction is determined by a domain expert based
ontheanalysedpropertyandthemodellingoftheprogramming
languagesemanticsintheEDB. Section5 showshowtogenerate
searchspacesforrealisticanalyses.Hereweassumethatthesearch
spaceisde/f_inedbythe symbolic EDB in Section 2.2 .Since not all assignments of symbols may correspond to syntac-
tically valid programs, we restrict them with structural constraints
/u1D713. For the example above, the structural constraints capture that
theflowrelationdoesnotformbranchesorcycles,andthateach
node contains asinglestatement.
To generate a patch for the program, we construct and solve
a repair condition. A repair condition is a formula over symbols
injected into the EDB representation of the program, such that any
satisfying assignment of this formula corresponds to a program for
which the analysis does not infer property violations. We obtain
this condition by symbolically executing the analysis using our
implementationofSEDL,Symlog.Fortheexampleabove,therepair
conditionis ¬/u1D719∧/u1D713,sinceitensuresthefact npe("y",3) willnot
be inferred,andthe program issyntactically valid.
Sincerepairconstraintsacceptmultiplesolutions,weonly con-
sider minimal solutions, such thatall other satisfying assignments
change a superset of values corresponding to the original program.
A minimal solution for the above example is
{/u1D7091↦→/u1D447,/u1D7092↦→/u1D447,/u1D7093↦→/u1D439,/u1D7094↦→/u1D439,/u1D7095↦→/u1D447,/u1D6FC4↦→“/u1D466.alt”,...}.
Itcorrespondsto the CFG andEDB presentedin Figure 2c.
Anotherminimal solution shownin Figure 2d is
{/u1D7091↦→/u1D439,/u1D7092↦→/u1D447,/u1D7093↦→/u1D447,/u1D7094↦→/u1D447,/u1D7095↦→/u1D439,/u1D7096↦→/u1D447,
/u1D6FC1↦→1,/u1D6FC2↦→4,/u1D6FC3↦→2,/u1D6FC5↦→“/u1D465”,/u1D6FC6↦→4,...}.
Thesecond solutionshows theability ofour approachto“invent”
newvaluesthat do not exist inthe originaldatabase.
3 SYMBOLIC EXECUTION OFDATALOG
In this section, we introduce relevant background on Datalog, and
de/f_ineour key technical novelty,symbolic executionof Datalog.
3.1 Background
Datalog is a query language based on Horn clauses in the form
L0:-L1,...,L/u1D45B, where each L/u1D456is aliteralp(t1,...,t/u1D45B)such that p
is apredicate andt/u1D456areterms. A term is either a constant or a
variable. Factsare ground literals, i.e.literals without variables.
Aground substitution /u1D703≜{/u1D4651//u1D4501,...,/u1D465/u1D45B//u1D450/u1D45B}is a mapping from
variablestoconstants.Wedenoteanapplicationofthesubstitution
/u1D703to the term tast/u1D703, and to the literal LasL/u1D703. EDB,extensional
database, is a set of input facts. IDB, intensional database , is a set
of output facts determined by the query. The Herbrand Base HB
is the set of all expressible facts. EHBdenotes the set of all HB
factswherethepredicateappearsinEDB; IHBdenotesthesetof
allHBfacts where the predicate appears in IDB, but not EDB. The
semantics of a Datalog program /u1D443can be represented as a function
/u1D510/u1D443: 2EHB→2IHBthat foreach existential database computesall
IDB-factsthatlogicallyfollowfromthatdatabase.Datalogallows
specifyingagoaltoselectasubsetofitsoutputsthataresubsumed
bythegoal. Forexample,the fact f(1,1)issubsumedbythegoal
f(X,X),butf(1,2)isnot.
Consider the Datalog query /u1D443inFigure 2b that speci/f_ies an NPE
analysis for a simple programming language de/f_ined in Figure 4.
Let the CFG of an analysed program be represented via an EDB
consistingofnodes,arcs,suchas flow(1,2) ,andinformationabout
statements such as the fact assign("y","x",2) stating that the
1219Program RepairGuidedby Datalog-DefinedStatic Analysis ESEC/FSE ’23, December3ś9, 2023,San Francisco, CA, USA
value ofxis assigned to yin the node 2. The semantics of such
program, /u1D510/u1D443, is a function that for an CFG represented as a set of
factsreturns the setofIDB facts npeandnullas follows:
/u1D510/u1D443/parenlefttpA/parenleftexA/parenleftexA/parenleftexA/parenleftexA/parenleftexA
/parenleftbtA 
flow(1,2),
flow(2,3),
assign_null(“/u1D465”,1),
assign(“/u1D466.alt”,“/u1D465”,2),
call(“/u1D466.alt”,3) 
/parenrighttpA/parenrightexA/parenrightexA/parenrightexA/parenrightexA/parenrightexA
/parenrightbtA= 
npe(“/u1D466.alt”,3)
null(“/u1D465”,2)
null(“/u1D466.alt”,3) 

Tode/f_ine /u1D510/u1D443, we use theproof-theoreticinterpretation ofData-
loginwhichthemeaningofaprogramisde/f_inedasthesetofall
facts that can be inferred from the program. For a given rule L0:-
L1,...,L/u1D45Band a set of ground facts F1,...,F/u1D45B, the output fact F0
can be inferred in one step from F1,...,F/u1D45Bif there is a substitution
/u1D703such that for any /u1D456∈0../u1D45B,F/u1D456=L/u1D456/u1D703. This procedure is referred
tointheDatalogliteratureasthe elementaryproductionprinciple
(EPP).Agroundfact /u1D439canbeinferredfromaprogram /u1D443ifeither
/u1D439∈/u1D443or/u1D439canbeinferredbyapplyingEPPa/f_initenumberoftimes.
ThesequenceofapplicationsofEPPusedtoinferafact /u1D439from/u1D443
forms aproofof /u1D439from/u1D443.
Aproofcanberepresentedusinga prooftree.ForagivenDatalog
query/u1D444,anEDB /u1D438,andagroundfact /u1D439,aprooftreeof /u1D439from/u1D438
is the tree (/u1D439,/u1D445,/u1D703,{/u1D4611,...,/u1D461/u1D45B})such that /u1D45B=0iﬀ/u1D439∈/u1D438, otherwise
/u1D445≜L0:-L1,...,L/u1D45Bis a rule from /u1D444,/u1D439=L0/u1D703, and/u1D461/u1D456are proof trees
ofL/u1D456/u1D703.FortheNPEanalysisdescribedabove,theprooftreeofthe
factnpe("y",3) isvisualisedin Figure 2e .
3.2 Semantics ofSEDL
The goal of symbolic execution of Datalog (SEDL) is to identify how
varyingvaluesinadatabaseimpactstheresultofexecutingaquery
onthisdatabase.Toachievethis,SEDLexecutesaDatalogqueryon
anabstracteddatabasewhichrepresentsasetofconcretedatabases.
The result of symbolic execution is a set of pair of output facts and
logicalconstraintsthatenabletheinferencethatfacts.Throughthis
process,SEDLsuccinctlysummarisestheoutcomeofexecutingthe
query onallofthe encodedconcrete databases.
By analogywith symbolicexecution ofconventional programs,
we abstract a given database by injecting symbolsthat represent
unknowninformation.SEDLusesthreecategoriesofsymbols:sym-
bolicconstants,symbolicpredicatesandsymbolicsigns.Wedenote
symbolic constants as/u1D6FC,/u1D6FD,/u1D6FEthat range over /f_inite domains of num-
bers, strings, etc. We use them to represent facts with unknown
constants, e.g. flow(/u1D6FC,/u1D6FD). We denote symbolic predicates as/u1D70Cthat
rangeoverallpredicates.Weusethemtorepresentfactswithun-
known predicates, e.g. /u1D70C(1,2). We denote symbolic signs as/u1D709that
range over booleans. We associate a symbolic sign with a fact to
control if the fact is positive or negative. Collectively, we refer
to such symbols as Σ≜{/u1D70E1,...,/u1D70E/u1D45B}over domains /u1D4371,...,/u1D437/u1D45B. All
thesesymbolscanbeusedsimultaneouslytorepresentfactswith
unknownpredicates, constants andtruthfulness.
We consider the set of constraints Φover the symbols Σthat
include the standard logical connectives and equalities between
symbols and constants from the corresponding domains. For exam-
ple,thefollowingisavalidconstraint: (/u1D7091∨¬/u1D7092)∧(/u1D6FC=/u1D6FE)∧(/u1D6FD/uni22605).
Wedenotetheevaluationoftheformula /u1D719valueundertheinter-
pretation {/u1D463/u1D456∈/u1D437/u1D456}/u1D456∈[1../u1D45B]as/u1D719[/u1D70E1↦→/u1D4631,...,/u1D70E/u1D45B↦→/u1D463/u1D45B].We call the set of all facts expressible using given predicates,
constants,andsymbolsthe symbolicHerbrandbase ,denotedas SHB.
We similarly de/f_ine SEHBandSIHB. Given a symbolic fact /u1D453∈
SHB,we de/f_ineits concretisation withthevalues {/u1D463/u1D456∈/u1D437/u1D456}/u1D456∈[1../u1D45B],
denotedas /u1D453[/u1D70E1↦→/u1D4631,...,/u1D70E/u1D45B↦→/u1D463/u1D45B],asthefactobtainedbyreplacing
all symbols with their concrete counterparts. Given a symbolic
EDBE ⊂SEHB, we de/f_ine its concretisation with the values {/u1D463/u1D456∈
/u1D437/u1D456}/u1D456∈[1../u1D45B],denotedas E[/u1D70E1↦→/u1D4631,...,/u1D70E/u1D45B↦→/u1D463/u1D45B],astheEDBobtained
fromEby concretising all symbolic facts, and removing all facts
corresponding to symbolic signswiththe negative interpretation.
Wede/f_inethe semanticsofsymbolicexecution ofaDatalogpro-
gram/u1D443as a function /u1D516/u1D443: 2SEHB→2SIHB×Φ. Given a symbolic
EDBE, this function returns a set of pairs of symbolic facts and
logicalconstraints.Werefertothesepairsasthesetof symbolicout-
putsandthecorresponding inferenceconditions .Thelatterresemble
path conditions in conventional symbolic execution in that they
specify under which condition the outputis generated. Speci/f_ically,
for each concretisation of Ewith{/u1D463/u1D456∈/u1D437/u1D456}/u1D456∈[1../u1D45B], the output of
the query is identical to the set of all concretisations of the outputs
ofSEDL on Ecorresponding to the positive inference conditions:
∀/u1D4631∈/u1D4371,...,/u1D463/u1D45B∈/u1D437/u1D45B./u1D510/u1D443(E[/u1D70E1↦→/u1D4631,...,/u1D70E/u1D45B↦→/u1D463/u1D45B])
={/u1D453[/u1D70E1↦→/u1D4631,...,/u1D70E/u1D45B↦→/u1D463/u1D45B]
| (/u1D453,/u1D719) ∈/u1D516/u1D443(E) ∧/u1D719[/u1D70E1↦→/u1D4631,...,/u1D70E/u1D45B↦→/u1D463/u1D45B] }
The inference of a symbolic fact from a symbolic EDB can be
visualised using a symbolic proof tree , a proof tree in which pro-
ductions are annotated with logical constraints that enable that
productions. Formally, for a given Datalog query /u1D444, a symbolic
EDBE, and a symbolic fact /u1D439, a symbolic proof tree of /u1D439fromE
is the tree (/u1D439,/u1D445,/u1D719,{/u1D7030,...,/u1D703/u1D45B},{/u1D4611,...,/u1D461/u1D45B})such that /u1D45B=0iﬀ/u1D439∈ E,
otherwise /u1D445≜L0:- L1,...,L/u1D45Bis a rule from /u1D444,/u1D439=L0/u1D7030,/u1D461/u1D456are
symbolicprooftrees of L/u1D456/u1D703/u1D456,and thesubstitutions {/u1D7030,...,/u1D703/u1D45B}are
identicalundereachsatisfyingassignmentof /u1D719.Apartfromthat,we
areonlyinterestedinfeasiblesymbolicprooftrees,thatissymbolic
prooftreeswherealllogicalannotationsareconsistentwitheach
other,sinceinthiscasethesymbolicprooftreecorrespondstoat
leastone concrete prooftree for aconcrete database.
To illustrate SEDL, consider the Datalog query in Figure 2b , and
thesymbolicdatabasein Section2.2 .Asymbolicprooftreeofthe
factnpe("y",3) inferred by SEDL from this database is given in
Figure 3. The inference condition for this fact is formed as the
conjunction ofallconstraintsinthe symbolic proof tree:
/u1D7092∧/u1D7093∧/u1D6FC1=1∧/u1D7094∧/u1D6FC3=2
∧¬(/u1D7096∧/u1D6FC5=“/u1D465”∧/u1D6FC6=/u1D6FC2) ∧¬(/u1D7095∧/u1D6FC4=“/u1D466.alt”)
3.3 Encoding a NeighbourhoodofaDatabase
Although SEDL can execute an abstracted database that is fully
symbolic,practicalapplicationssuchasprogramrepairdescribed
inSection 5 bene/f_it from injecting symbols into an existing con-
cretedatabase, thus considering aneighbourhood of thisconcrete
database. Let /u1D438be an EDB; its /u1D458-neighbourhood N(/u1D438,/u1D458)represents
thesetofdatabasesdiﬀeredfromtheoriginaloneinatmost /u1D458facts:
N(/u1D438,/u1D458)≜{/u1D438′|/u1D438′⊆EHB∧ |/u1D438′△/u1D438|</u1D458}
where△is symmetric diﬀerence and /u1D458is a user-de/f_ined parameter.
1220ESEC/FSE ’23, December3ś9, 2023,San Francisco, CA, USA YuLiu, Sergey Mechtaev, Pavle Subotić, andAbhik Roychoudhury
Torepresentaneighbourhoodofconcretedatabaseusingsym-
bols, we augment the symbolic EDB with structural constraints.
Forexample,thesymbolicencodingof /u1D458-neighbourhood N(/u1D438,/u1D458)
foranEDB /u1D438canbede/f_inedthroughapairofasymbolicEDB E
andconstraints /u1D713such that
N(/u1D438,/u1D458)={E[/u1D70E1↦→/u1D4631,...,/u1D70E/u1D45B↦→/u1D463/u1D45B]
|/u1D713[/u1D70E1↦→/u1D4631,...,/u1D70E/u1D45B↦→/u1D463/u1D45B] ∧/u1D463/u1D456∈/u1D437/u1D456}
Toillustrate such encoding, considerthe EDB
node(1). flow(1, 2).
node(2).
Its1-neighbourhoodcan be encodedas the symbolic EDB
node(1). assoc.with/u1D7091flow(1, 2). assoc.with/u1D7094
node(2). assoc.with/u1D7092flow(/u1D6FD,/u1D6FE).assoc.with/u1D7095
node(/u1D6FC).assoc.with/u1D7093
andthe structuralconstraints
/u1D7093∧/u1D7095∧atLeast(2,/u1D7091,/u1D7092,/u1D7094)
∨/u1D7091∧/u1D7092∧/u1D7094∧atMost(1,/u1D7093,/u1D7095)
whereatLeastandatMostarecardinalityconstraints.Inthecontext
ofprogramrepairdrivenbyDataloganalysis, Section5 showshow
to encode an analysis speci/f_ic neighbourhood consisting of only
syntactically valid programs.
4 REALISATION OFSEDL INSYMLOG
Symlogemploysameta-programmingapproachtoimplementing
SEDL. Speci/f_ically, a given Datalog query and a symbolic EDB are
transformed into a meta-query and ameta-EDB in such a way that
executingthemeta-queryonthemeta-EDBwiththestandardData-
logsemanticsyieldstheoutputofsymbolicexecutionoftheoriginal
queryontheoriginalsymbolicdatabase.Wecollectivelyreferto
themeta-queryandthemeta-EDBasthe meta-program .Theadvan-
tage of this approach is that it enables us to reuse existing eﬃcient
implementationsofDatalog,andmakesSymlogindependentofthe
Datalogevaluation strategy.
4.1 NaïveEncoding ofSEDL
We /f_irst describe a naïve implementation of SEDL. It explicitly
enumeratesallvaluesfromthedomainsofsymbolsinsidethemeta-
program,andcomputeshoweachofthemrelates tothe outputof
thequery.Toachievethis,weaugmentallpredicatesusedinthe
querywithauxiliaryvariablesthatstoretheassignmentofsymbolic
constantstoconcretevalues,whichwerefertoas symbolicbindings .
To ensure that assignments of symbolic constants are consistent
within a derivation of each output fact, as per the de/f_inition of
symbolic proof trees in Section 3.2 , we propagate the values of
symbolic bindings acrosseachrule.
AssumethatagivensymbolicEDBcontainsthesymboliccon-
stants/u1D6FC1,...,/u1D6FC/u1D45B.WeintroduceauxiliaryDatalogvariables /u1D4361,...,/u1D436/u1D45B
forsymbolicbindings.Foreachrule,themeta-queryadds /u1D4361,...,/u1D436/u1D45B
tothe headand eachliteralofthebody.Forinstance, wetransform
the /f_irstrulede/f_ining nullinFigure 2b into
null(V, L, /u1D4361, ..., /u1D436/u1D45B) :-
flow(L1, L, /u1D4361, ..., /u1D436/u1D45B),
assign_null(V, L1, /u1D4361, ..., /u1D436/u1D45B).To transform the EDB into a meta-EDB, the naïve approach
enumeratesallinstantiationsofsymbolicconstantswiththevalues
from the corresponding domains. For example, given the EDB fact
flow(/u1D6FC1, 2),we transform itintothe rule
flow(/u1D4361, 2,/u1D4361, ..., /u1D436/u1D45B) :-
domain_alpha_1( /u1D4361), ...,
domain_alpha_n( /u1D436/u1D45B).
whereeachpredicate domain_alpha_ /u1D456,calledsymbolicdomainpred-
icate,is truefor allvaluesfrom the domain of /u1D6FC/u1D456.After the meta-
program is executed, the resulting values of symbolic bindings
capture the assignment of symbolic constants that enable the gen-
eration ofcorresponding outputfacts.
To support symbolicpredicates,thenaïve approach introduces
auxiliary integer variables /u1D443/u1D456calledpredicate selectors for each
symbolic predicate to identify which of the concrete predicates
from the corresponding domain is enabled. For each rule, the meta-
query adds these variables to the head and each literal of the body.
Inthemeta-EDB,wetransformeachfactwithasymbolicpredicate,
say,/u1D70C(1,2)where the domainof /u1D70Cis{p1,p2},intothe rules
p1(1, 2, /u1D443) :- P = 1.
p2(1, 2, /u1D443) :- P = 2.
Afterthemeta-programisexecuted,theresultingvaluesofpredi-
cate selectors indicate if output facts can be inferred by relying on
variousinstantiationsofthe symbolic predicates.
To support symbolic signs, the naïve approach introduces auxil-
iary boolean variables /u1D446/u1D456calledsign selectors for each fact with a
symbolicsign.Togenerateameta-EDB,wetransformeachfactwith
a symbolic sign, say, /u1D439de/f_ined as /u1D709p(1, 2), into the fact p(1, 2,
True), and each other fact with the same or a diﬀerent predicate,
say,q(3, 4),intoq(3, 4, False) .Togenerateameta-query,we
transform each ruleby addingsign selectors to the head andeach
literal of the body, and also additional constraints that state that
the head depends on /u1D439if at least one of the literals of the body de-
pendson /u1D439.Forexample,giventherule t(X, Y):- v(X), r(Y) ,
we transform itintothe rule
t(X, Y, /u1D446) :- v(X, /u1D4461), r(Y, /u1D4462),/u1D446=/u1D4461∨/u1D4462.
After the meta-program is executed, the resulting values of sign
selectors indicate if output facts can be inferred with or without
relying onthe fact withasymbolic sign.
Bycomputingthevaluesofauxiliaryvariables(symbolicbind-
ings,predicateselectorsandsignselectors),itispossibletorecon-
struct inference conditions for each output fact. However, since
the domains of symbolic constants and the number of facts with
symbolicsignscanbehuge,thisapproachdoesnotscaletorealistic
databases, which motivated us to design optimisations to avoid
explicit enumerationfor thesetwocategoriesof symbols.
4.2 Optimisation forSymbolic Constants
Toaddressthesearchspaceexplosionofthenaïveapproach,instead
of enumerating all possible values of symbolic constants in the
de/f_inition of symbolic domain predicates, we explicitly maintain
abstractsymbolsduringevaluation.Foreachsymbolicconstant /u1D6FC
with the domain /u1D437de/f_ined by the symbolic domain predicate in
themeta-programdescribedin Section 4.1 ,we optimisethemeta-
programbycompressing /u1D437inawaythatdoesnotchangetheoutput
ofthequery.Weseparatelyhandletwocategoriesofconstantsin
1221Program RepairGuidedby Datalog-DefinedStatic Analysis ESEC/FSE ’23, December3ś9, 2023,San Francisco, CA, USA
/u1D45D(...,/u1D450/u1D456,...) ∈ E ⇒ depend(/u1D45D,/u1D456,/u1D450/u1D456)
/u1D43F:−...,/u1D45D(...,/u1D450/u1D456,...),....∈/u1D444⇒depend(/u1D45D,/u1D456,/u1D450/u1D456)
/u1D43F:−...,/u1D45D1(...,/u1D44B/u1D456,...),...,/u1D45D2(...,/u1D44B/u1D457,...),....∈/u1D444,/u1D44B/u1D456≡/u1D44B/u1D457⇒
∀/u1D450.depend(/u1D45D1,/u1D456,/u1D450) ⇔depend(/u1D45D2, /u1D457,/u1D450)
Figure 5: Constraints de/f_ining the relation depend:/u1D444is the
query,EisthesymbolicEDB, /u1D450/u1D456//u1D44B/u1D456isaconstant(symbolicor
concrete)/avariable appearing as the i-thpredicateparame-
ter,/u1D44B/u1D456≡/u1D44B/u1D457denotes that /u1D44B/u1D456and/u1D44B/u1D457are identical variables.
thedomain:thoseconstantsthatalreadyexistsomewhereelsein
the program, andpreviously unseen constants.
To handle constants that already exist somewhere in the pro-
gram,weconsiderallsuchconstants /u1D450from/u1D437,whichwerefertoas
uni/f_iableconstants of/u1D6FC,appearingeitherintheEDBorthequery
thatthereexistsasymbolicprooftreewhoseproductionrulean-
notations contain a dependency between /u1D6FCand/u1D450,e.g.a constraint
/u1D6FC=/u1D450. If such dependency does not exist in any of the symbolic
trees,weprunetheseconstantsfromthesymbolicdomainpredicate,
sincethelackofinteractionswithexistingconstantsimpliesthat
theseelementsofthedomaincanbehandledinthesamewayas
previously unseen constants. However, identifying the exact set of
uni/f_iable constants is impractical, because that would require com-
puting all symbolic proof trees in advance. Instead, we compute an
overapproximationofthissetbyusingtherelation depend(/u1D45D,/u1D456,/u1D450)
thatstatesthatthei-thparameterofthepredicate /u1D45Dmaydependon
the symbolic orconcrete constant /u1D450. This relationcan becomputed
using constraints de/f_ined in Figure 5via a /f_ixed point computation
algorithm.Forthesymbolicconstant /u1D6FC,weselectallpairs {(/u1D45D/u1D457,/u1D456/u1D457)}
suchthat depend(/u1D45D/u1D457,/u1D456/u1D457,/u1D6FC)forall/u1D457.Then,anoverapproximationof
the setofuni/f_iableconstants for /u1D6FCcan be de/f_inedas
uni/f_iable(/u1D6FC)≜/u1D437∩/uniondisplay.1
/u1D457{/u1D450|depend(/u1D45D/u1D457,/u1D456/u1D457,/u1D450)}.
To handle the elements of /u1D437that do not exist anywhere else
in the program, which we refer to /u1D437new≜/u1D437\uni/f_iable(/u1D6FC), we
introduceextraconstantsthatserveasabstractrepresentationof
/u1D437new. We also consider interactions between multiple symbolic
constants. For example, assume that the symbolic EDB contains
symbolicconstants /u1D6FCand/u1D6FD.Weintroduceextraconstants /u1D45B1and
/u1D45B2toencodeallpartitioningsof /u1D6FCand/u1D6FDintoequivalenceclasses.
Given the EDB fact flow(/u1D6FC, 2),we transform itintothe rules
flow(/u1D4361, 2,/u1D4361,/u1D4362) :- domain( /u1D4361,/u1D4362).
domain(X, Y) :-
domain_alpha_unifiable(X),
domain_beta_unifiable(Y).
domain( /u1D45B1, Y) :- domain_beta_unifiable(Y).
domain(X, /u1D45B1) :- domain_alpha_unifiable(X).
domain( /u1D45B1,/u1D45B1).
domain( /u1D45B1,/u1D45B2).
wheredomain_alpha_unifiable isthesetofuni/f_iableconstants
for/u1D6FC(thesamefor /u1D6FD),anddomainistheoptimisedsymbolicdomain
predicate. The /f_irst rule de/f_ining this predicate states that symbolic
constants may take any of the values of corresponding uni/f_iable
constants.Thesecondandthethirdrulesstatethatoneofthemmay
takeanew,previouslyunseenvalue.Thelasttworulesstatethatboth symbolic constants can take previously unseen values, either
equal(rulefour)ordiﬀerent(rule/f_ive).Aftersuchmeta-program
is executed, /u1D45B1and/u1D45B2can be replaced with /u1D6FCand/u1D6FDby adding
constraints imposed by the corresponding equivalence classes. For
example,themeta-programoutputfact null("v", /u1D45B1,/u1D45B1,/u1D45B2)
wouldcorrespondto null("v", /u1D6FC)underthe condition
/u1D6FC/uni2209uni/f_iable(/u1D6FC) ∧/u1D6FD/uni2209uni/f_iable(/u1D6FD) ∧/u1D6FC/uni2260/u1D6FD
4.3 Optimisation forSymbolic Signs
Supporting symbolic signs is challenging because there are 2|EDB|
ways to negate facts in the database. To avoid a search space explo-
sion, we generate inference conditions for only /u1D458selected outputs
undertheassumptionthatatmost /u1D45Bofthesymbolicfactsarenega-
tive.Thisassumption holds inourapplicationto program repair,
since we only explore a neighbourhood of a given database, and
program repairconstraints only dependonthe inferenceof a small
numberofoutputfacts.Forbrevity,weonlyexplainhowtosupport
symbolic signsfor /u1D458=/u1D45B=1.
Foragivenfactwithasymbolicsign /u1D43C,theencodingin Section4.1
enables us to determine if an output fact /u1D442depends on that fact (if
it can be inferred with and without the presence that fact in the
database). We say that /u1D43Cis a hard dependency of /u1D442, if/u1D442is only
inferred when the sign of /u1D43Cis true. We formulate the problem of
computing the inference condition of /u1D442in terms of symbolic signs
as the problem of /f_inding all hard dependencies of /u1D442among all
inputs withsymbolicsigns,sinceremoving anyhard dependency
from the databasedisablesthe generationof the outputfact.
To identify all hard dependencies of a given output fact, we
rely on Zeller’s delta debugging algorithm [ 46] that operates by
iterativelysplittingthespaceofsolutionsandinvestigatingeach
half individually. To apply delta-debugging, we de/f_ine the function
interesting/u1D442thatforagiven setofinputfactsreturnstrueifthis
set contains all hard dependencies of /u1D442. We also extend the en-
coding of symbolic signs in Section 4.1 so that sign selectors are
appliednot toindividualfacts, buttosetsof facts, toidentifyif an
outputfactcanbeinferredwithoutusinganyelementfromthatset.
Suchanextendedencodingenablesustoimplementthefunction
interesting/u1D442,andthus apply the delta-debugging algorithm.
5 SYMLOGREPAIRAND ITS INSTANCES
In this section, we describe how SymlogRepair uses Symlog and
an SMT solver to generate patches, and describe SymlogRepair in-
stances: SymlogRepair [NPE,Java],SymlogRepair [Leak,Python],
andSymlogRepair [Securify2 ,Solidity].
5.1 ArchitectureofSymlogRepair
ThearchitectureofSymlogRepairisshownin Figure1.Itaccepts
two inputs: the source code of the buggy program, and an analysis
de/f_inedinDatalog.Itthen executesthe following steps:
(1)convertstheprogramintoaDatalogEDB,injectssymbols
intothisEDB,andproducesstructuralconstraints /u1D713overthe
symbolsthatcaptures asetofsyntactically validprograms;
(2)executes the analysis symbolically obtaining inference con-
ditions/u1D719for the analysisoutputs manifesting violations.;
(3) constructsthe repaircondition ¬/u1D719∧/u1D713;
1222ESEC/FSE ’23, December3ś9, 2023,San Francisco, CA, USA YuLiu, Sergey Mechtaev, Pavle Subotić, andAbhik Roychoudhury
(4)solves the repair condition to produce minimal repairs, that
is, repairs that minimally modify original values in the EDB;
(5)mapstheobtainedvaluationofsymbolsbackintothesource
code to generateapatch.
Ourapproachgeneratesminimalrepairs,becausesuchrepairs
arelesslikelytobreakunspeci/f_iedfunctionalityoftheprogram[ 29].
The /f_irst step, generating a repair search space, is analysis and pro-
gramming language speci/f_ic. Below, we describe how it is realised
for the three analysisproblems we considerinthis work.
5.2 SymlogRepairforJava NPE
Digger’s NPE analysis is built on top of a points-to analysis, which
approximatestheheapmemorycon/f_igurationatprogrampoints.
Amongotheruses,thisinformationcanbeusedtodetectifapointer
variable pointsto NULLwhen itisdereferenced.
The search space for /f_ixing NPEs is de/f_ined through generic
templatesthatcheckifdereferencedprogramvariablesequalNULL,
andifso,performvariousactions,suchasnotexecutingafragment
of code, returning a default value, such as the call to the default
constructorofagiventype,orperformanearlyexit.Weselectfacts
relatedtotheabovetemplatestosymboliseandaddsymbolicsigns
to the factsthat represent the functionwiththe detectedbug.
5.3 SymlogRepairforPython Notebook
Dataleakanalysisassessesthedependencebetweentrainingand
test data, which can lead to arti/f_icially optimistic results. Prepro-
cessingdataleakagehappenswhentrainingandtestdataaretrans-
formed together by a function that may impute results based on
bothdatasets,likenormalizationusingbothdatasets’distributions.
Torepairthebug,preprocessingshouldberemovedfromsource
dataandappliedseparatelytotrainingandtestdata.Forexample,
inFigure 6, the correct version uses fit_transform for training
data andtransform for testing data. We de/f_ine the search space of
repair by a generic template that moves preprocessing from source
to training data and add corresponding preprocessing for test data.
Symbolicconstantsandsymbolicsignsareaddedforpreprocessing
APIs andcontrol/f_lowgraph components,respectively.
5.4 SymlogRepairforSmartContracts
We address four smart contract vulnerabilities detected by Secu-
rify2 [2,40]: access control, reentrancy, unhandled exceptions, and
lockedEther.
There are four types of access control bugs. Transaction ori-
gin bugs emerge from using the outdated tx.origin for caller
veri/f_ication.The/f_ixistoreplaceitwith msg.sender .Wesymbol-
isetx.origin related facts. Suicidal bugs result from unchecked
selfdestruct() calls. The /f_ix is to ensure the caller is the con-
tract’sowner.Wesymbolisethefactsofownervariableandcontrol
/f_low graph. Leaking and delegate call bugs are addressed similarly
as the suicidalbug.
Reentrancy bugs occur when external contract can make new
callstothecallingcontractbeforethe/f_irstinvocationis/f_inished.
Therepairis/f_inalisingallinternalstatechangesbeforethecallis
executed.Wesymbolisecontrol/f_lowfactsforsuchbugs.Unhandled
exceptionbugsarecausedbyuncheckedlow-levelcallreturns.The
/f_ix is to add a check for the returned value of the low level call.Table 1:NPE10 dataset ofNPEbugsfromJavaprojects.
Program Bugs kLoC Project description
jfreechart 1 132 A 2D chart libraryfor Java
spoon 1 155 A libraryfor Javacodetransformation
jackson-databind 1 142 A data-binding package for Jackson
jeveassets 1 101 Anassetmanager for Eve-Online
fastjson 1 186 A JSONprocessing library
karaf 1 128 A modulithruntime
acs-aem-commons 2 111 Componentsof AEM consulting practice
camel 1 1156 Anintegration framework
thirdeye 1 126 A toolfor time seriesanalysis
Lockedetherbugsresultfromcontractswithpayablefunctionsbut
no withdrawal functions. One can /f_ix the bugs by removing the
payable attribute, adding a withdraw function or adding a function
withselfdestruct .We symbolisefacts for selfdestruct .
6 EVALUATION
In this section, we evaluate SymlogRepair by investigating the
following researchquestions(RQs).
RQ-I: Ability to Repair aDiverseClassofBugs. CanSym-
logRepair/f_ixadiversebugsandhowitcomparestoexisting
toolsthat target the same bugs?
RQ-II: ImpactofOptimisations. How much doour optimi-
sations improve the result compared to the naïve implemen-
tation ofSEDL inSymlog?
6.1 ExperimentalSetup
Our experiments were performed on an Intel®Core™Intel(R)
Xeon(R) Gold 6258R CPU at 2.70GHz with 256GB of physical RAM
running Ubuntu20.04.1LTS.We settimeoutto 1hour.
Datasets. Weconstructedthreedatasets.The/f_irstis NPE10,a
dataset consisting of 10 NPE bugs in Java projects: /f_ive of them are
from NPEX dataset [ 24]; two from BugSwarm [ 38], and three bugs
that we systematically mined on GitHub; the criterion of including
thebugsintoNPE10isthattheyaredetectedbyDigger[ 34],the
underlyingcomponentof SymlogRepair [NPE,Java].Thesummary
of this dataset is given in Table 1. The second is PL11, a dataset
consistingof11preprocessing leakagebugs inPythonnotebooks
collected by Yang et al.[44], which excludes bugs not detectable
by the used analyser and false positives. Finally, SC63is a dataset
composedof63bugsinSoliditysmartcontracts.Itincludes22bugs
fromSmartbugs[ 13]and41bugsfromScrawlID[ 45].SC63excludes
bugsfromSmartbugsandfromScrawlIDthatSecurify2[ 40]cannot
detect.AsScrawlIDdoesnotprovidegroundtruth,wemanually
annotatedthe selectedbugswithcorrectrepairs.
Tools.WhenrepairingJavaNPEbugs,weconsideredtwocon/f_ig-
urationsof SymlogRepair [NPE,Java]:(1)SRNJNusingthenaïve
algorithmde/f_inedin Section4.1 and(2)SRNJOusingtheoptimi-
sations described in Section 4.2 andSection 4.3 . We considered
three baselines for NPE bugs: NPEX [ 24] that is speci/f_ically de-
signedforNPEbugs,andageneralmachinelearningbasedtoolAl-
phaRepair [ 43], and InCoder [ 15], a code model that demonstrated
state-of-the-art results for program repair [ 18]. When repairing
Python notebook data leaks, we considered two con/f_igurations
1223Program RepairGuidedby Datalog-DefinedStatic Analysis ESEC/FSE ’23, December3ś9, 2023,San Francisco, CA, USA
Table 2: Patches generated by SymlogRepair [NPE,Java], NPEX, AlphaRepair and InCoder for NPE10: /CIRCLEindicates correct
patch,/LEFTCIRCLE /Circle— property-over/f_itting patch, /Circle— no patch found, OOM — out of memory, “Symbols” show the num. of symbolic
constants + the num. of symbolic signs. The optimised SymlogRepair /f_ixed more bugs than NPEX, AlphaRepair and InCoder,
andoutperformed thenon-optimised versionby avoidingOOMs.
Project Version SymbolsPatch Time Memory(GB)
NPEX AlphaRepair InCoder SRNJN SRNJO SRNJN SRNJO SRNJN SRNJO
jfreechart 2182 5+8303 /CIRCLE /CIRCLE /Circle /CIRCLE /CIRCLE 3m 53s 2m 54s 6.245 1.322
spoon b3f568d 5+8024 /Circle /CIRCLE /Circle /CIRCLE /CIRCLE 3m 6s 2m 7s 6.547 1.330
jackson-databind 974ccdd 8+531 /CIRCLE /LEFTCIRCLE /Circle /Circle /CIRCLE /CIRCLE 2m 44s 2m 36s 3.587 2.643
jeveassets f35ccd9 5+2198 /CIRCLE /Circle /Circle /CIRCLE /CIRCLE 2m 16s 2m 11s 10.099 10.098
camel 597883f 5+40768 /CIRCLE /Circle /Circle /CIRCLE /CIRCLE 11m29s 8m 30s 23.688 6.173
thirdeye e286991 5+54 /CIRCLE /Circle /Circle /CIRCLE /CIRCLE 1m 20s 1m 21s 2.203 2.197
fastjson 7c05c6f 8+5739 /Circle /Circle /Circle /Circle /LEFTCIRCLE /Circle - 2m 43s OOM 2.643
karaf 5965290 8+573 /LEFTCIRCLE /Circle /LEFTCIRCLE /Circle /Circle /LEFTCIRCLE /Circle /LEFTCIRCLE /Circle 10m32s 4m 28s 21.881 22.047
acs-aem-commons 374231978 13+14277 /CIRCLE /Circle /Circle /Circle /CIRCLE - 5m 47s OOM 6.344
acs-aem-commons 374231969 13+14206 /CIRCLE /Circle /Circle /Circle /CIRCLE - 5m 46s OOM 6.408
Overall 7.5+5737.3 7+1 2+2 0+0 6+1 8+2 >3m 50s 3m 50s >9.788 6.121
SymlogRepair [Leak,Python]:(1)SRPLNusingthenaïvealgorithm
and (2)SRPLOusing the optimisations. We also selected AlphaRe-
pair andInCoder as baselines for Python bugs. For repairing bugs
in Solidity smart contracts, we considered two con/f_igurations of
SymlogRepair [Securify2 ,Solidity]:(1)SRSSNusingthenaïvealgo-
rithmand(2) SRSSOusing theoptimisations.Asthe baseline, we
selectedthestate-of-the-artsmartcontractrepairtoolElysium[ 14].
Correctnesscriteria. Patchesthatsatisfytheanalysispropertywe
classify as plausible (contrary to test-driven repair, where plausible
patches refer to patches that pass given tests). A patch is correctif
itissemanticallyequivalenttothedeveloperpatch.Wemanually
investigated generated patches to check their correctness. In the
manual analysis, we conservatively assumed that the correct patch
must be syntactically identical to the developer patch subject to
trivialrefactorings.Thosepatchesthatareplausible,butnotcorrect,
inanalogywithtest-over/f_itting [ 35], we call property-over/f_itting .
6.2 Ability to Repair aDiverse Class ofBugs
To investigate the ability to handle a diverse class of bugs, we
evaluated SymlogRepair [NPE,Java]on NPE10 dataset of Java NPE
bugs,SymlogRepair [Leak,Python]onPL11datasetofPythondata
leaks, and SymlogRepair [Securify2 ,Solidity]on SC63 dataset of
Soliditysmart contracts bugs.
Table 2summarises the results of our experiments on NPE10.
In this table, the columns “Patch” show the number of correct
and property-over/f_itting patchesfor each con/f_iguration.SRNJO is
thedefault(optimised)con/f_igurationof SymlogRepair [NPE,Java].
SRNJO generated patches for all 10 bugs, and 8 of them were re-
paired correctly, and for 2 the tool generated over/f_itting patches.
WecomparedSRNJOwithNPEX,AlphaRepairandInCoder.ForAl-
phaRepairandInCoderweusedtheDataloganalyserforvalidating
candidate patches. The experiments demonstrated that SRNJO cor-
rectlyrepairedone more bugsthan NPEX,6 more bugscompared
withAlphaRepair,and8more thanInCoder.
Table3summarisestheresultsofourexperimentsonPL11.As
in the previous experiment, the columns “Patch” show the number
of correct and property-over/f_itting patches generated by each con-
/f_iguration. For PL11, developer patches are not available, thereforeweclassifygeneratedpatchesintocorrectorplausibleviaamanual
inspection and cross-checking. SRPLO is the default (optimised)
con/f_igurationofthe SymlogRepair [Leak,Python].SRPLOrepaired
6 out of 11 bugs correctly. Among the remaining 5 bugs, for 4 bugs
it generated patches that over/f_it the property, and one was not re-
paired due to timeout. AlphaRepair and InCoder failed to generate
any patchesthat satisfy the analysisproperty.
Table 4summarises the results of our experiments on SC63. The
columns “Fixed” show the numbers of /f_ixed bugs by the state-of-
the-art smart contract repair tool Elysium [ 14] and the default
con/f_igurationof SymlogRepair [Securify2 ,Solidity],SRSCO.“Time”
shows the average time taken by SymlogRepair for generating
patches. The experiments demonstrated that our tool generated
47 more correct patches than Elysium. The non-optimised version,
SRSSN,failedto generateany patchesbecause of OOMerrors.
RQ-I:SymlogRepairdemonstrateditsabilitytostaticallyre-
pair a diverse class of realistic bugs acrossmultiple program-
ming languages, where it demonstrated results close to or
betterthanthe state-of-the-art.
6.3 ImpactofOptimisations
SymbolicexecutionofDatalogrequiresadditionalmemory,because
it has to explore a large space of possible relations, which poses
a scalability challenge. To improve scalability, we introduced op-
timisations. To investigate the impact of these optimisations, we
comparedtheperformanceofthenaïve(cf.Section 4.1)andopti-
mised(cf.Section 4.2)con/f_igurationsofSymlogRepairintermsof
time andmemory usage.
Table2andTable3providedetailedstatisticsofexecutingSRNJN,
SRNJO, SRPLN and SRPLO on the corresponding datasets. The
columns “Symbols”showhowmanysymbols (symbolicconstants
+ symbolic signs) were automatically injected into the EDB to gen-
eratearepairsearchspace.Thecolumns“Time”showtotalelapsed
time,and“Memory”showthepeakmemoryusageorOOMifan
out of memory error occurred. The results in Table 2show that
80% of the time our optimisation exhibits speedups of up to 2.5 ×
(ignoring un/f_inishedbenchmarks). In terms of memory usage,our
1224ESEC/FSE ’23, December3ś9, 2023,San Francisco, CA, USA YuLiu, Sergey Mechtaev, Pavle Subotić, andAbhik Roychoudhury
Table3:Patchesgeneratedby SymlogRepair [Leak,Python]forPL11.Thenotationisidenticalto Table2.Theoptimisations
enabled SymlogRepair to repairmultiple bugsby avoidingOOMs.
Notebook SymbolsPatch Time Memory(MB)
AlphaRepair InCoder SRPLN SRPLO SRPLN SRPLO SRPLN SRPLO
nb_2528 6+22584 /Circle /Circle /Circle /CIRCLE - 23m50s OOM 91.049
nb_2816 6+11975 /Circle /Circle /Circle /CIRCLE - 30m46s OOM 81.211
nb_1417 6+17659 /Circle /Circle /Circle /CIRCLE - 10m58s OOM 70.569
nb_949 6+95652 /Circle /Circle /Circle /CIRCLE - 47m24s OOM 393.623
nb_2760 6+14941 /Circle /Circle /Circle /LEFTCIRCLE /Circle - 18m51s OOM 121.021
nb_3144 6+247561 /Circle /Circle /Circle /Circle - Timeout OOM 181.112
nb_318 6+49748 /Circle /Circle /Circle /LEFTCIRCLE /Circle - 27m59s OOM 191.175
nb_296 6+493152 /Circle /Circle /Circle /LEFTCIRCLE /Circle - 25m35s OOM 494.718
nb_2646 6+5196 /Circle /Circle /Circle /LEFTCIRCLE /Circle - 35m20s OOM 60.447
nb_195 6+79617 /Circle /Circle /Circle /CIRCLE - 12m44s OOM 429.864
nb_3594 6+21238 /Circle /Circle /Circle /CIRCLE - 13m36s OOM 80.828
Overall 6+96610.5 0+0 0+0 0+0 6+4 - >24m7s - 199.328
Table 4: Patches generated by Elysium and
SymlogRepair [Securify2 ,Solidity]for SC63. The nota-
tion isidentical to Table 2.
BugType BugsFixed (Correct+Over/f_itting)Time
Elysium SRSSO
Access control 5 3+0 4+1 3m 39s
Unhandled exception 13 4+0 13+0 4.32s
Reentrancy 8 8+0 8+0 1m 47s
Locked ether 41 0+0 41+0 1m 34s
Overall 63 15+0 62+1 <4m
optimisation exhibits a reduction 80% of the time of up to a 5 ×
(ignoring cases that ran out of memory). In the case of results in
Table3,thenaïveversionrunsoutofmemoryonallbenchmarks.
On the other hand, the optimised version was able to repair all but
a single benchmark. Programs in Table 2are signi/f_icantly larger,
buttheirrepairsearchspace,asshowninthe“Symbols”column,is
smaller due to localisation described in Section 5.2 , which explains
the diﬀerence in time and memory usage across these benchmarks.
In the experiments on SC63, the non-optimised version of Sym-
logRepair failed to generate any patches because of OOM errors,
while the optimised version /f_ixed 62 bugs correctly, while using
less than16GB of memory onaverage, and less than4 minutes on
average.
RQ-IIOur optimisations play a crucial role in ensuring the
scalability of SymlogRepair, as they on average reduce the
repair time and memory usage while enabling the generation
ofmore patchesbypreventingOOMexceptions.
7 DISCUSSION
Theuseofprogrampropertiesde/f_inedinDatalogenablesourap-
proach to avoid test-over/f_itting intrinsic to test-driven program re-
pair[21,35],butourapproachmayover/f_ittheproperty.First,static
analysis properties are designed to avoid undesirable behaviour
but notto specifythe intendedbehaviour.Second, staticanalysis is
subjecttofalsepositives.Third,someanalysismaynotbeableto
recognise a patch as correct due to the use of over-approximations.from sklearn.preprocessing import MinMaxScaler
dataset = load_data()
scaler = MinMaxScaler(feature_range=(0, 1))
- scale_data=scaler.fit_transform(dataset)
- train_data, test_data = split_data(scale_data)
+ train_data, test_data = split_data(dataset)
x_train, y_train = split_train_data(train_data)
x_test, y_test = split_test_data(test_data)
model = LSTM_model()
+ x_train_new = scaler.fit_transform(x_train)
+ x_test_new = scaler.transform(x_test)
- model.fit(x_train, y_train)
+ model.fit(x_train_new, y_train)
- predictions = model.predict(x_test)
+ predictions = model.predict(x_test_new)
Figure 6:Patch forpreprocessing leakage buginnb_2528.
Thus, patches generated by our approach still need to be reviewed
by developers and/or prioritised by AI. We will investigate the
problem of prioritising statically generated patches in future work.
OurmethodofsymbolicallyexecutingstandardDatalog,how-
evermanypracticalapplicationsofDatalogrelyonextensionssuch
as strati/f_iednegation andextra-logical operations.In futurework,
we plantoinvestigate howtosupportvariousDatalogextensions.
To support a newclass of bugs in SymlogRepair, itis necessary
toprovideaDatalogprogramfordetecting thisclassofbugs,and
de/f_inesymbolicsearchspacefor/f_ixingthebugs.Inthiswork,we
usedexistingresearchanalysersforJava,PythonandSolidity.Com-
mercial Datalog-based analyserslike Semmle[ 1]provideanalyses
for more programming languages.
We manuallywrote three groundtruthpatches fromNPE10, as
well as all the patches from PL11 and SC63. Due to the nuances of
domain-speci/f_icknowledge,theprovidedsolutionsmaynotcapture
allpossible intricacies orbe optimal.
In this work, we only investigate the application of SEDL to
program repair. However, we believe SEDL can be applied to many
domains,soasconventionalsymbolicexecution.Infuturework,we
1225Program RepairGuidedby Datalog-DefinedStatic Analysis ESEC/FSE ’23, December3ś9, 2023,San Francisco, CA, USA
willinvestigateotherapplicationsofSEDL:dataintegration[ 25],
repairing networks [ 27], anddatabasetesting.
8 RELATED WORK
Our workcontributestoautomated program repair[ 16]; itis rele-
vanttostaticprogramrepairandrepairbasedonsymbolicexecu-
tion.SEDLisrelevanttoDatalogextensionsandDatalogdebugging.
StaticProgramRepair. Programrepairsystemsbasedonstatic
analysis /f_ix speci/f_ic types of bugs, such as memory leaks, null
pointer exceptions (NPEs), data races, or locking errors. Mem-
Fix[23]addressesthememoryleakproblembyreducingittoan
exact cover problem and using a SAT solver to /f_ind a solution.
Saver [17] uses object /f_low graphs to patch memory errors in C
programs. NPEX [ 24] applies a custom symbolic execution tech-
nique to repair NPEs in Java programs, but relies on stack traces
to detect bugs. Footpatch [ 41] uses separation logic to /f_ix mem-
ory leaks and NPEs. Hippodrome [ ?] repairs data races in Java
programswiththeaid ofRacerD’sstaticanalysis[ 7].Crayons [ 9]
synthesisespatchesforlocking APImisusesusinggraphcoloring
and ranking, and estimates the criticality of code in static analyser
error traces. We did not compare SymlogRepair with techniques
other than NPEX, because they handle diﬀerent defect classes and
use an ad-hoc integration of static analysis and repair. Rather than
developingnewDatalog-basedanalyzersforthesedefects,which
isoutside thiswork’sscope,we showedourmethod’sgenerality
byintegratingexistingDatalog-basedanalyzersforvariousbugs
acrossmultiple languages.
Several work employs static analysers to discover repair pat-
terns.Phoenix[ 5]minesrepairpatternsfromexamplesofbug/f_ixes
reported by static analysers and abstracts patterns by clustering
similareditexamplesthroughtheuseofadomain-speci/f_iclanguage.
Avatar [4] infers /f_ix patterns from the static analysis violations de-
tectedbyFindBugs.Ourapproachdoesnotlearnrepairpatterns,
butinsteadprovidesrepairstrategiesthroughtheuseofDatalog,
whichenables itto addressawider range ofbugs.
ProgramRepairwithSymbolicExecution. Ourworkisrelevant
tosemantic program repairsuch asSemFix[ 31], Angelix[ 30]and
symbolic executionwithexistentialsecond-order constraints (SE-
ESOC) [28]. These approaches also abstract a given program by
injectingsymbols,andexecutetheprogramsymbolicallytoinfer
repairconstraints.Thekeydiﬀerenceofourworkisthatinstead
of inferring constraints from test, we infer them from a Datalog
analyser,thus taking the analysedproperty intoaccount.
ProgramRepairBenchmarks. Weconstructeddatasetsspeci/f_ically
for the defectclasses handled by the Datalog analysers, instead of
relyingonDefects4J[ 20]andQuixBugs[ 26]oftenusedforevaluat-
ing test-driven repair. The new datasets better re/f_lect the intended
usagescenarioofourapproach, i.e.repairingbugsdetectedbystatic
analysis,asoppositetorepairingbugsfoundbytesting.Bugsfound
bystaticanalysistouniversalprogramproperties, e.g.thelackof
crashes and security vulnerabilities, rather than project-speci/f_ic
requirements,andsuch bugsare not accompaniedwithtests.ML-based Program Repair. ML-based program repair recently
demonstrated promising results [ 18,42]. We used two state-of-the-
art tools, AlphaRepair [ 43] and InCoder [ 15], as baselines in our
evaluation.Infuturework,wewillinvestigatehowtoaugmentML-
basedrepairwithsemanticinformationfromSymlogtoimprove
theireﬀectiveness inrepairing staticanalysisbugs.
Datalog Input Repair. Databaseinputrepair has been studiedin
the context of integrity constraints violations that are limited to
fragments of /f_irst order logic [ 3]. Theoretical solutions for positive
Datalog using abductionare proposed[ 32].However,traditional
databasemethodsoftendon’tscalewellforlargerstaticanalysis
rulesets [ 50]. Zhao et al.’s technique [ 50] uses proof annotations
inDatalogforenhancedscalability,butitmainlyrestrictstonon-
symbolic domains and doesn’t execute repairs. Elastic incremen-
talisation extends this by incorporating provenance annotations
forinputadjustmentsinincrementalDatalog[ 48,49].Xinetal.’s
method[ 47]usescounter-exampleabstractre/f_inementtochoose
theoptimalEDBsubsetmodelinganabstractioninprogramanal-
ysis.SynNet[ 11]generatescandidateinputsforrulesinnetwork
synthesis. To our knowledge, our work is the /f_irst repair technique
thatscalestolargerulesetsandinputsinDatalog-basedprogram
analyses.
Symbolic Datalog. Standard Datalog is limited to the domain
of powersets. Recently, Datalog engines have integrated symbolic
reasoning. Formulog [ 6] is a Datalog engine that uses SMT solving
in the presence of symbolic variables in the ruleset. Modus [ 39]
isanon-recursiveDatalogenginethatallowsnon-groundedvari-
ablestosolvethecontainerpackagedependencyproblem.Unlike
these approaches, Symlog executes symbolic variables by encod-
ing them in the standard Datalog setup thus existing optimised
Datalogenginescanbeused.BasedontheinferredconstraintsSim-
logRepair can provide a patch that transforms the EDB to a correct
version basedoninferredconstraints andanSMTsolver. Thus,our
techniquecanseamlesslyplugintostandardDatalog-basedstatic
analysissetups.
9 CONCLUSION
We introduced a new static program repair architecture that, by re-
lyingonDatalog,isabletorepairawiderangeofdefectsforvarious
programminglanguages.Itscoreenabling componentissymbolic
executionofDatalog,whichcomputesdependenciesbetweenthe
input and the output of a query, and repairs the database based on
the desiredoutputspeci/f_ication. We implementedthistechniquein
an eﬃcient tool Symlog, and applied to program repair based on
Datalog-de/f_ined program analysis in the tool SymlogRepair. Our
experiments demonstrated that SymlogRepair scales to real-world
programs, and repairs a wide range of defects, including NPE bugs
inJava programs, anddata leaksinPythonnotebooks.
ACKNOWLEDGEMENTS
Wethanktheanonymousreviewersfortheirfeedbackwhichhelped
improve this paper. This work was partially supported by a Singa-
poreMinistryofEducation(MoE)Tier3grant“AutomatedProgram
Repair”,MOE-MOET32021-0001.
1226ESEC/FSE ’23, December3ś9, 2023,San Francisco, CA, USA YuLiu, Sergey Mechtaev, Pavle Subotić, andAbhik Roychoudhury
REFERENCES
[1]2023. CodeQL (formely Semmle). https://codeql.github.com/ . Accessed: 2023-06-
29.
[2]2023. Securify 2.0 security scanner for Ethereum smart contracts. https://github.
com/eth-sri/securify2 . Accessed:2023-06-29.
[3]MarceloArenas,LeopoldoBertossi,andJanChomicki.1999. ConsistentQuery
AnswersinInconsistentDatabases.In ProceedingsoftheEighteenthACMSIGMOD-
SIGACT-SIGART Symposium on Principles of Database Systems (Philadelphia,
Pennsylvania, USA) (PODS ’99) . Association for Computing Machinery, New
York, NY, USA,68–79. https://doi.org/10.1145/303976.303983
[4]Nathaniel Ayewah, William Pugh, David Hovemeyer, J David Morgenthaler, and
JohnPenix.2008. Usingstaticanalysisto/f_indbugs. IEEEsoftware 25,5(2008),
22–29.https://doi.org/10.1109/MS.2008.130
[5]Rohan Bavishi, Hiroaki Yoshida, and Mukul R Prasad. 2019. Phoenix: Automated
data-drivensynthesisofrepairsforstaticanalysisviolations.In Proceedingsof
the201927thACMJointMeetingonEuropeanSoftwareEngineeringConference
and Symposium on the Foundations of Software Engineering . 613–624. https:
//doi.org/10.1145/3338906.3338952
[6]Aaron Bembenek, Michael Greenberg, and Stephen Chong. 2020. Formulog:
DatalogforSMT-BasedStaticAnalysis. Proc.ACMProgram.Lang. 4,OOPSLA,
Article141(nov2020),31pages. https://doi.org/10.1145/3428209
[7]SamBlackshear,NikosGorogiannis,PeterWO’Hearn,andIlyaSergey.2018. Rac-
erD:compositionalstaticracedetection. ProceedingsoftheACMonProgramming
Languages 2,OOPSLA (2018), 1–28. https://doi.org/10.1145/3276514
[8]Martin Bravenboer and Yannis Smaragdakis. 2009. Strictly declarative speci/f_ica-
tionofsophisticatedpoints-toanalyses.In Proceedingsofthe24thACMSIGPLAN
conferenceonObjectorientedprogrammingsystemslanguagesandapplications .
243–262. https://doi.org/10.1145/1639949.1640108
[9]AlfredoCruz,MahsaVarshosaz,Claire LeGoues,andAndrzejWasowski.2022.
PatchingLocking BugsStaticallywithCrayons. ACMTransactionsonSoftware
Engineering and Methodology (2022).https://doi.org/10.1145/3548684
[10]LeonardoDeMouraandNikolajBjørner.2008. Z3:AnEﬃcientSMTSolver.In
ProceedingsoftheTheoryandPracticeofSoftware,14thInternationalConference
onToolsandAlgorithmsfortheConstructionandAnalysisofSystems (Budapest,
Hungary) (TACAS’08/ETAPS’08) . Springer-Verlag, Berlin, Heidelberg, 337–340.
https://doi.org/10.1007/978-3-540-78800-3_24
[11]AhmedEl-Hassany,PetarTsankov,LaurentVanbever,andMartinT.Vechev.2017.
Network-Wide Con/f_iguration Synthesis.In Computer AidedVeri/f_ication -29th
InternationalConference,CAV2017,Heidelberg,Germany,July24-28,2017,Pro-
ceedings, Part II (Lecture Notes in Computer Science, Vol. 10427) , Rupak Majumdar
and Viktor Kuncak (Eds.). Springer, 261–281. https://doi.org/10.1007/978-3-319-
63390-9_14
[12]David Evans. 1996. Static Detection of Dynamic Memory Errors. In Proceedings
of the ACM SIGPLAN 1996 Conference on Programming Language Design and
Implementation (Philadelphia, Pennsylvania, USA) (PLDI ’96) . Association for
Computing Machinery, New York, NY, USA, 44–53. https://doi.org/10.1145/
231379.231389
[13]João FFerreira,PedroCruz, ThomasDurieux,and RuiAbreu. 2020. Smartbugs:
A framework to analyze solidity smart contracts. In Proceedings of the 35th
IEEE/ACM International Conference on Automated Software Engineering . 1349–
1352.https://doi.org/10.1145/3324884.3415298
[14]ChristofFerreiraTorres,HugoJonker,andRaduState.2022. Elysium:Context-
AwareBytecode-LevelPatchingtoAutomaticallyHealVulnerableSmartCon-
tracts. In Proceedings of the 25th International Symposium on Research in Attacks,
Intrusionsand Defenses . 115–128. https://doi.org/10.1145/3545948.3545975
[15]Daniel Fried, Armen Aghajanyan, Jessy Lin, Sida Wang, Eric Wallace, Freda Shi,
Ruiqi Zhong, Wen-tau Yih, Luke Zettlemoyer, and Mike Lewis. 2022. Incoder: A
generativemodelforcodein/f_illingandsynthesis. arXivpreprintarXiv:2204.05999
(2022).
[16]Claire Le Goues, Michael Pradel, and Abhik Roychoudhury. 2019. Automated
program repair. Commun. ACM 62, 12 (2019), 56–65. https://doi.org/10.1145/
3318162
[17]Seongjoon Hong, Junhee Lee, Jeongsoo Lee, and Hakjoo Oh. 2020. SAVER:
scalable, precise, and safe memory-error repair. In Proceedings ofthe ACM/IEEE
42nd International Conference on Software Engineering . 271–283. https://doi.org/
10.1145/3377811.3380323
[18]Nan Jiang, Kevin Liu, Thibaud Lutellier, and Lin Tan. 2023. Impact of code
languagemodelsonautomatedprogramrepair. arXivpreprintarXiv:2302.05020
(2023).
[19]HerbertJordan,BernhardScholz,andPavleSubotic.2016.Souﬄé:OnSynthesisof
ProgramAnalyzers.In ComputerAidedVeri/f_ication-28thInternationalConference,
CAV2016,Toronto,ON,Canada,July17-23,2016,Proceedings,PartII (LectureNotes
in Computer Science, Vol. 9780) , Swarat Chaudhuri and Azadeh Farzan (Eds.).
Springer, 422–430. https://doi.org/10.1007/978-3-319-41540-6_23
[20]RenéJust,DarioushJalali,andMichaelDErnst.2014. Defects4J:Adatabaseof
existing faults to enable controlled testing studies for Java programs. In Proceed-
ingsofthe2014internationalsymposiumonsoftwaretestingandanalysis .437–440.https://doi.org/10.1145/2610384.2628055
[21]Xuan-Bach D Le, Ferdian Thung, David Lo, and Claire Le Goues. 2018. Over-
/f_itting in semantics-basedautomatedprogram repair. In Proceedingsof the 40th
International Conference on Software Engineering . 163–163. https://doi.org/10.
1145/3180155.3182536
[22]ClaireLeGoues,ThanhVuNguyen,StephanieForrest,andWestleyWeimer.2011.
Genprog:Agenericmethodforautomaticsoftwarerepair. Ieeetransactionson
softwareengineering 38,1 (2011), 54–72. https://doi.org/10.1109/TSE.2011.104
[23]JunheeLee,SeongjoonHong,andHakjooOh.2018. Mem/f_ix:staticanalysis-based
repairof memory deallocation errorsforc. In Proceedings of the 2018 26thACM
JointMeetingonEuropeanSoftwareEngineeringConferenceandSymposiumon
theFoundationsofSoftwareEngineering .95–106. https://doi.org/10.1145/3236024.
3236079
[24]Junhee Lee, Seongjoon Hong, and Hakjoo Oh. 2022. NPEX: Repairing Java
Null Pointer Exceptions withoutTests. (2022). https://doi.org/10.1145/3510003.
3510186
[25]Maurizio Lenzerini. 2002. Data integration: A theoretical perspective. In Proceed-
ingsofthetwenty-/f_irstACMSIGMOD-SIGACT-SIGARTsymposiumonPrinciples
ofdatabase systems . 233–246. https://doi.org/10.1145/543613.543644
[26]Derrick Lin, James Koppel, Angela Chen, and Armando Solar-Lezama. 2017.
QuixBugs:Amulti-lingualprogram repairbenchmarksetbasedontheQuixey
Challenge. In Proceedings Companion of the 2017 ACM SIGPLAN international
conference on systems, programming, languages, and applications: software for
humanity . 55–56.https://doi.org/10.1145/3135932.3135941
[27]BoonThauLoo,TysonCondie,MinosGarofalakis,DavidEGay,JosephMHeller-
stein, Petros Maniatis, Raghu Ramakrishnan, Timothy Roscoe, and Ion Stoica.
2006. Declarative networking: language, execution and optimization. In Proceed-
ingsofthe2006ACMSIGMODinternationalconferenceonManagementofdata .
97–108.https://doi.org/10.1145/1142473.1142485
[28]SergeyMechtaev,AlbertoGriggio,AlessandroCimatti,andAbhikRoychoudhury.
2018.Symbolicexecutionwithexistentialsecond-orderconstraints.In Proceedings
of the 2018 26th ACM Joint Meeting on European Software Engineering Conference
and Symposium on the Foundations of Software Engineering . 389–399. https:
//doi.org/10.1145/3236024.3236049
[29]SergeyMechtaev,JooyongYi,andAbhikRoychoudhury.2015. Direct/f_ix:Looking
for simple program repairs. In 2015 IEEE/ACM 37th IEEE International Conference
onSoftwareEngineering ,Vol.1.IEEE,448–458. https://doi.org/10.1109/ICSE.2015.
63
[30]Sergey Mechtaev, Jooyong Yi, and Abhik Roychoudhury. 2016. Angelix: Scalable
multiline program patch synthesisvia symbolic analysis. In Proceedingsofthe
38thinternationalconferenceonsoftwareengineering .691–701. https://doi.org/
10.1145/2884781.2884807
[31]Hoang Duong Thien Nguyen, Dawei Qi, Abhik Roychoudhury, and Satish Chan-
dra. 2013. Sem/f_ix: Program repair via semantic analysis. In 2013 35th Inter-
national Conference on Software Engineering (ICSE) . IEEE, 772–781. https:
//doi.org/10.1109/ICSE.2013.6606623
[32]BabakSalimiandLeopoldoE.Bertossi.2016. CausesforQueryAnswersfrom
Databases, Datalog Abduction and View-Updates: The Presence of Integrity
Constraints.In TheFloridaAIResearchSociety .https://doi.org/10.1016/j.ijar.2017.
07.010
[33]BernhardScholz,HerbertJordan,PavleSubotić,andTillWestmann.2016. Onfast
large-scaleprogramanalysis indatalog.In Proceedingsofthe25thInternational
ConferenceonCompilerConstruction .196–206. https://doi.org/10.1145/2892208.
2892226
[34]JixiangShen,XiWu,NevilleGrech,BernhardScholz,andYannisSmaragdakis.
2020. Explaining bug provenance with trace witnesses. In Proceedings of the 9th
ACMSIGPLANInternationalWorkshopontheStateOftheArtinProgramAnalysis,
SOAP@PLDI 2020, London, UK, June 15, 2020 , Paddy Krishnan and Christoph
Reichenbach (Eds.).ACM,14–19. https://doi.org/10.1145/3394451.3397206
[35]Edward K Smith, Earl T Barr, Claire Le Goues, and Yuriy Brun. 2015. Is the cure
worse than the disease? over/f_itting in automated program repair. In Proceedings
ofthe201510thJointMeetingonFoundationsofSoftwareEngineering .532–543.
https://doi.org/10.1145/2786805.2786825
[36]PavleSubotic,HerbertJordan,LijunChang,AlanD.Fekete,andBernhardScholz.
2018. Automatic Index Selection for Large-Scale Datalog Computation. Proc.
VLDBEndow. 12,2 (2018), 141–153. https://doi.org/10.14778/3282495.3282500
[37]Pavle Subotic, Lazar Milikic, and Milan Stojic. 2022. A Static Analysis Frame-
work for Data Science Notebooks. In 44th IEEE/ACM International Conference
on Software Engineering: Software Engineering in Practice, ICSE (SEIP) 2022, Pitts-
burgh, PA, USA, May 22-24, 2022 . IEEE, 13–22. https://doi.org/10.1109/ICSE-
SEIP55303.2022.9794067
[38]David A Tomassi, Naji Dmeiri, Yichen Wang, Antara Bhowmick, Yen-Chuan
Liu, Premkumar T Devanbu, Bogdan Vasilescu, and Cindy Rubio-González. 2019.
Bugswarm:Mining and continuously growing adataset of reproduciblefailures
and/f_ixes.In 2019IEEE/ACM41stInternationalConferenceonSoftwareEngineering
(ICSE). IEEE,339–349. https://doi.org/10.1109/ICSE.2019.00048
[39]Chris Tomy, Tingmao Wang, Earl T. Barr, and Sergey Mechtaev. 2022. Modus: a
Datalogdialectforbuildingcontainerimages.In Proceedingsofthe30thACMJoint
1227Program RepairGuidedby Datalog-DefinedStatic Analysis ESEC/FSE ’23, December3ś9, 2023,San Francisco, CA, USA
EuropeanSoftware Engineering Conference and Symposium onthe Foundations of
Software Engineering, ESEC/FSE 2022, Singapore, Singapore, November 14-18, 2022 ,
AbhikRoychoudhury,CristianCadar,andMiryungKim(Eds.).ACM,595–606.
https://doi.org/10.1145/3540250.3549133
[40]Petar Tsankov, Andrei Dan, Dana Drachsler-Cohen, Arthur Gervais, Florian
Buenzli, andMartinVechev.2018. Securify:Practical securityanalysisofsmart
contracts.In Proceedingsofthe2018ACMSIGSACConferenceonComputerand
Communications Security . 67–82.https://doi.org/10.1145/3243734.3243780
[41]Rijnard van Tonder and Claire Le Goues. 2018. Static automated program repair
forheapproperties.In Proceedingsofthe40thInternationalConferenceonSoftware
Engineering . 151–162. https://doi.org/10.1145/3180155.3180250
[42]Chunqiu Steven Xia, Yuxiang Wei, and Lingming Zhang. 2023. Automated
program repair in the era of large pre-trained language models. In Proceedings of
the 45th International Conference on Software Engineering (ICSE 2023). Association
for ComputingMachinery .https://doi.org/10.1109/ICSE48619.2023.00129
[43]ChunqiuStevenXiaandLingmingZhang.2022. Lesstraining,morerepairing
please:revisitingautomatedprogramrepairviazero-shotlearning.In Proceedings
of the 30th ACM Joint European Software Engineering Conference and Symposium
on the Foundations of Software Engineering . 959–971. https://doi.org/10.1145/
3540250.3549101
[44]ChenyangYang,RachelABrower-Sinning,GraceALewis,andChristianKäst-
ner.2022. Dataleakageinnotebooks:Staticdetectionandbetterprocesses.In
Proceedings of the 2022 37th IEEE/ACM International Conference on Automated
SoftwareEngineering .https://doi.org/10.1145/3551349.3556918
[45]ChavhanSujeetYashavant,SaurabhKumar,andAmeyKarkare.2022. Scrawld:
Adatasetofrealworldethereumsmartcontractslabelledwithvulnerabilities.arXiv preprint arXiv:2202.11409 (2022).
[46] Andreas Zeller. 1999. Yesterday, myprogram worked.Today, it doesnot. Why?
ACM SIGSOFT Software engineering notes 24, 6 (1999), 253–267. https://doi.org/
10.1145/318774.318946
[47]Xin Zhang, Ravi Mangal, Radu Grigore, Mayur Naik, and Hongseok Yang. 2014.
OnAbstractionRe/f_inementforProgramAnalysesinDatalog.In Proceedingsofthe
35th ACM SIGPLAN Conference on Programming Language Design and Implemen-
tation(Edinburgh,UnitedKingdom) (PLDI’14) .AssociationforComputingMa-
chinery, New York, NY, USA, 239–248. https://doi.org/10.1145/2594291.2594327
[48]DavidZhao,PavleSubotic,MukundRaghothaman,andBernhardScholz.2021.
Towards Elastic Incrementalization for Datalog. In PPDP 2021: 23rd International
SymposiumonPrinciplesandPracticeofDeclarativeProgramming,Tallinn,Estonia,
September6-8,2021 ,NiccolòVeltri,NickBenton,andSilviaGhilezan(Eds.).ACM,
20:1–20:16. https://doi.org/10.1145/3479394.3479415
[49]DavidZhao,PavleSubotic,MukundRaghothaman,andBernhardScholz.2023.
Automatic Rollback Suggestions for Incremental Datalog Evaluation. In Practical
Aspects of Declarative Languages - 25th International Symposium, PADL 2023,
Boston, MA, USA, January 16-17, 2023, Proceedings (Lecture Notes in Computer
Science,Vol.13880) ,MichaelHanusandDanielaInclezan(Eds.).Springer,295–312.
https://doi.org/10.1007/978-3-031-24841-2_19
[50]DavidZhao,PavleSubotic,andBernhardScholz.2020. DebuggingLarge-scale
Datalog: A Scalable Provenance Evaluation Strategy. ACM Trans. Program. Lang.
Syst.42,2 (2020), 7:1–7:35. https://doi.org/10.1145/3379446
Received 2023-02-02; accepted 2023-07-27
1228