Speedingup SMTSolvingvia Compiler Optimization
BenjaminMikek
bmikek@gatech.edu
Georgia InstituteofTechnology
USAQirun Zhang
qrzhang@gatech.edu
Georgia InstituteofTechnology
USA
ABSTRACT
SMT solvers are fundamental tools for reasoning about constraints
in practical problems like symbolic execution and program synthe-
sis. Faster SMT solving can improve the performance and preci-
sion of those analysis tools. Existing approaches typically speed
up SMT solving by developing new heuristics inside particular
solvers,whichrequiresnontrivialengineeringeﬀorts.Thispaper
presentsanewperspectiveonspeedingupSMTsolving.Wepro-
pose SMT-LLVM Optimizing Translation (SLOT), a solver-agnostic
pre-processingapproachthatutilizesexistingcompileroptimiza-
tions to simplify SMT problem instances. We implement SLOT
forthe two mostapplication-critical SMT theories,bitvectors,and
ﬂoating-point numbers. Our extensive evaluation based on the
standard SMT-LIB benchmarksshows that SLOT cansubstantially
increasethenumberofsolvableSMTformulasgivenﬁxedtimeouts
andachieve mean speedups ofnearly 3×for large benchmarks.
CCSCONCEPTS
•Softwareanditsengineering →Formalsoftwareveriﬁca-
tion.
KEYWORDS
SMTSolvers,simpliﬁcation,compileroptimization
ACM Reference Format:
BenjaminMikekandQirunZhang.2023.SpeedingupSMTSolvingviaCom-
pilerOptimization. In Proceedingsofthe31stACM JointEuropeanSoftware
Engineering Conference and Symposium on the Foundations of Software Engi-
neering(ESEC/FSE’23),December3–9,2023,SanFrancisco,CA,USA. ACM,
NewYork, NY, USA, 13pages.https://doi.org/10.1145/3611643.3616357
1 INTRODUCTION
Satisﬁability Modulo Theories (SMT) constraints are ﬁrst-order
logicalformulaswithfunctionsandvariablesfromvarioustheories,
suchasrealnumbers,integers,and,asrelevanttosoftwareengineer-
ing,bitvectors,andﬂoating-pointnumbers.State-of-the-artsolvers
like CVC5 [ 2] and Z3 [ 15] use a complex mix of heuristics, theory-
speciﬁc engines, and SAT solver calls to eﬃciently reason about
SMTconstraints.Yetmanyconstraintsstilltakeaprohibitivelylong
timetosolve.Improvingsolverperformancecanimproveresults
for real-world applications. For example, in symbolic execution,
lowersolvingtime equates togreatercode coverage[ 12].
ESEC/FSE ’23, December 3–9, 2023, San Francisco, CA,USA
©2023 Copyright heldby theowner/author(s).
ACM ISBN 979-8-4007-0327-0/23/12.
https://doi.org/10.1145/3611643.3616357ThemostpopularapproachtospeedingupSMTsolvingisde-
veloping more powerful solving strategies. These have sometimes
takentheformofnewsolverslikeBoolector[ 36],orofnewalgo-
rithms in existing solvers. For example, Berzish et al.[6] introduce
new heuristics for string constraints involving regular expressions
while Bjørner et al.[7] improve Z3’s performance for custom theo-
ries.FastSMT[ 1]speedsupsolvingbyusingmachinelearningto
choose the best solverheuristics.
This paper proposes a new perspective on improving SMT solv-
ing:insteadofdevelopingmoreadvancedsolvingtactics,ourkey
insightistorepurposeexistingcompileroptimizationtechniques
to theSMT problem.In particular, we propose a translation-based
pre-processingstep, SMT-LLVMOptimizing Translation( SLOT),
whichcandirectlyoptimizeinputSMT-LIBformulas.Conceptually,
ourapproach has three main advantages:
•Simplicity: End-usersofSMTsolverscanbeneﬁtfromcom-
pileroptimizationsasablackbox,withoutdetailedknowl-
edge ofSMT-speciﬁc optimizations.
•Solver-independence: Becauseitisapre-processingstep
on SMT constraints, semantics-preserving optimization can
be usedin applications that use any solver(s).
•Extensibility: New compiler optimizations can be directly
applied to further improve SMT solving without the need to
make complex changes to solvers.
SLOTbypassestheneedtore-implementcompileroptimizations
inSMTsolversbytranslatingtheconstraints,ratherthantheop-
timizations. While not all compiler optimizations are useful for
the SMT context, the combination of semantics-preserving opti-
mization with existing solvers creates a sieve: some constraints
arecaughtquicklybyexistingsolverheuristics,whileothersare
handledbetterby SLOT.
We have implemented SLOTfor the SMT theories of bitvectors
andﬂoating-pointnumbers.Constraintsinthesetheoriesarethe
most relevant to software engineering because they model ma-
chinearithmetic;forexample,theyareusedinpracticaltoolsfor
symbolicexecution[ 12],translationvalidation[ 26],andprogram
synthesis[ 8].InSection 4,weshowthatthesemanticsofthesetwo
theories can be exactly represented in LLVM IR. The key challenge
forSLOTisbridgingthesemanticgapbetweenSMTconstraintsand
LLVMIRwhichexistsbecausethelanguages,onedeclarativeand
the other imperative, were designed for entirely diﬀerent purposes.
Figure1illustrates the three components of SLOT. Thefrontend
translatesSMTconstraintstoLLVMIR.Thisstepensuresthatevery
SMT function is converted to an equivalent sequence of LLVM
instructions. Optimization uses the LLVM optimizer to simplify
thetranslatedconstraintalmostforfree.Finally, SLOT’Sbackend
translatestheoptimizedLLVMIRbackintoanSMTconstraint.The
complex structures created by the optimizer must be translated
back withoutsemantic gaps.
ThisworkislicensedunderaCreativeCommonsAttribution-ShareAlike4.0
InternationalLicense.
1177
ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA Benjamin MikekandQirun Zhang
SMTLLVMIR LLVMIR’
SMT’FrontendLLVMopt
Backend
Solver Solversat⇐⇒sat
Figure1:Overviewof SLOT’stranslationandoptimization
process. The output constraint (SMT’) is satisﬁable if and
onlyif theoriginalconstraint(SMT) issatisﬁable.
We have applied SLOTto the quantiﬁer-free benchmarks for
bitvectors, ﬂoating-point numbers, and their combination included
in the SMT-LIB speciﬁcation [ 3]. Our extensive evaluation demon-
stratesthat SLOTcansubstantiallyspeedupSMTsolving,especially
forcomplexconstraintswhichwouldotherwisetakealongtimeto
solve.Ourapproachincreasesthenumberofsolvableconstraints
byupto20%forbitvector,15%forﬂoating-point,and80%formixed
benchmarks.Moreover, SLOTismoreeﬀectivethanexistingsolvers
combined: it can solve constraints for which all tested solvers time
out. We also observe mean speedups above 2×for bitvector and
ﬂoating-point, and as high as 3×for mixed constraints. By measur-
ing which optimization passes contribute most to the speedup, we
ﬁndthatsimplepeepholeoptimizationsandglobalvaluenumbering
are suﬃcient to improve solver performance.
In summary,we make the following primary contributions:
•We present an easy-to-use, solver-agnostic framework for
speeding up SMT solving by translating constraints to a
compilerIR andback.
•We deﬁne, prove, and implement SLOT, and show that it im-
proves the performance of solvers on standard benchmarks.
•We measure which LLVM optimization passes contribute
most to speeding up SMT formulas, giving users access to
well-testedsimpliﬁcationsandsolverdevelopersinsightinto
possible solver improvements.
The rest of the paper is structured as follows. Section 2moti-
vatesSLOTwith an example SMT constraint. Section 3presents
backgroundonconstraintsinSMT-LIB,whileSection 4describes
SLOT’stranslationandprovesitsﬁdelity.Section 5describesthe
evaluation results, and Section 6puts the results incontext.Finally,
Section7surveys relatedwork, andSection 8concludes.
2 MOTIVATING EXAMPLE
This section presents a concrete example (Figure 2) to motivate
SLOT. Speciﬁcally, it takes Z3 390 seconds to solve the original
formula(Figure 2a).Afterapplying SLOT,theoptimizedformula
(Figure2d) can be solvedalmostinstantly.
InputSMTConstraint. Figure2agivesanSMTformulafromthe
SMT-LIB QF_BVbenchmarkset.1Itcheckswhethermultiplication
can overﬂow (lines 3-7) when the inputs /u1D44Eand/u1D44Fare subject to a
divisionconstraint(line 8).Theformulais unsatbecauseanyvalue
of/u1D44Ewhichsatisﬁesthe secondassertioncauses the multiplication
/u1D44E×/u1D44Ftooverﬂow.Eventhoughthisconstraintisconciseandsimple,
Z3takes 390secondsto return the unsatresult.
1QF_BV/challenge/multiplyOverﬂow.smt21(declare-fun a () (_ BitVec 32))
2(declare-fun b () (_ BitVec 32))
3(assert (not (=
4 ((_ extract 63 32)
5 (bvmul ((_ zero_extend 32) a)
6 ((_ zero_extend 32) b)))
7 #x00000000)))
8(assert (bvuge (bvudiv #xffffffff a) b))
9(check-sat)
(a)Original SMT-LIB constraint.
1define i1 @SMT(i32 %a, i32 %b) {
2%0 = zext i32 %b to i64
3%1 = zext i32 %a to i64
4%2 = mul i64 %1, %0
5%3 = lshr i64 %2, 32
6%4 = trunc i64 %3 to i32
7%5 = icmp eq i32 %4, 0
8%6 = xor i1 %5, true
9%7 = udiv i32 -1, %a
10%8 = icmp eq i32 %a, 0
11%9 = select i1 %8, i32 -1, i32 %7
12%10 = icmp uge i32 %9, %b
13%11 = and i1 %6, %10
14ret i1 %11
15}
(b) Resultof SLOTfrontendtranslation.
1define i1 @SMT(i32 %a, i32 %b) {
2ret i1 false
3}
(c) Resultof SLOToptimization.
1(assert false)
2(check-sat)
(d)Finalformulaafter SLOTbackendtranslation.
Figure 2: SLOTtranslation and optimization process.
Frontend. Figure2bgivestheresultof SLOT’sfrontend:anLLVM
functionthatissemanticallyequivalenttotheSMTconstraintin
Figure2a. This function returns true onan input (/u1D44E,/u1D44F)if and only
if(/u1D44E,/u1D44F)satisﬁes the originalconstraint. Itsinstructions mirror the
function applications in Figure 2a. For example, zextis equivalent
to the SMT zero_extend operation and mulisequivalentto bvmul.
Optimization. Figure2cgivestheresultofLLVMoptimization
on the function in Figure 2busing all available optimization passes.
In this example, only three passes aﬀect the function’s instruc-
tions:instcombine ,reassociate , anddce. These simplify away all
substantive code, producing the function that always returns false.
Backend. Finally, Figure 2dshows the result of translating Fig-
ure2cback to an SMT constraint. Since the LLVM function always
returns false, the corresponding SMT constraintsimply asserts fal-
sity.Z3can nowtrivially produce the unsatresult in0.02seconds.
Challenges. From Figure 2, we can see that SLOTallows an SMT
solver to leverage the power of existing LLVMoptimizations. The
keytechnicalchallengeof SLOTisbridgingthesemanticgapbe-
tweenSMTconstraintsandLLVMIR, i.e.,ensuringtheinputand
outputSMTconstraintsareequivalent.Whilemultiplicationand
bitextensionareequivalentinthetwolanguages,SMTfunctions
cannotalwaysbedirectlymappedtoLLVMIR.Forexample,line 10
ofFigure 2baddsachecktoensurethedivisiononline 8ofFigure 2a
does not introduce division by zero, because this has undeﬁned
behaviorinLLVM.
1178SpeedingupSMTSolvingviaCompilerOptimization ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA
3 PRELIMINARIES
This section gives background on the SMT problem [ 4] and de-
scribes the bitvector and ﬂoating-point theories of the SMT-LIB
standard[ 3].
Definition 1 (SMT formula). Given atheory/u1D447with signature
Σand interpretations /u1D43C, an SMT formula /u1D719is an expression made up
ofsymbols(functionapplicationsor variables) from Σ./u1D43Cis theset of
mapsfromvariablesin Σtosort-appropriatevalues. /u1D719issatisﬁableif
thereexistsaninterpretationin /u1D43Cthat satisﬁes /u1D719.
Intuitively, a theory /u1D447provides deﬁnitions of sorts(i.e., types)
andfunctions,andanSMTformulaisasetofvariablesandacon-
straint on those variables using functions from /u1D447. If there exists an
assignmentofthevariableswhichfulﬁllstheconstraint,wecallthe
formula sat;otherwise,itis unsat.TheSMT-LIBstandarddeﬁnes
eight theories and from these 29 logics, combinationsof functions
from one or more theories, possibly with extensions. All logics
rely on the Coretheory, which deﬁnes basic boolean operations
like logic and, logic or, and equality. We restrict our discussion
totheCoretheoryandthequantiﬁer-freelogicsofbitvectorsand
ﬂoating-pointnumbers.
SMT-LIB has a sort for each width of bitvector ( (_ BitVec /u1D45B)),
severalunaryandbinaryoperationsonbitvectorslike bvnegand
bvadd,andbitvectorcomparisonslike bvuge.Thetheoryofﬂoating-
pointnumbersdeﬁnesthesorts (_ FloatingPoint /u1D452 /u1D460)forintegers
/u1D452,/u1D460>1. Operations on ﬂoating-point values follow standard IEEE-
754semantics[ 35],thoughthesizesoftheexponentandsigniﬁcand
are not limited to those deﬁned in IEEE-754. As with the bitvec-
torlogic,thereare unaryandbinaryoperationson ﬂoating-point
values (many of these require the speciﬁcation of one of the ﬁve
roundingmodes)andcomparisonsthatyieldbooleans.Thereare
also conversions from ﬂoating-point to bitvectors, from bitvectors
toﬂoating-pointvalues,andbetweendiﬀerent-sizeﬂoating-point
values.Table 1gives afull listof QF_BVandQF_FPfunctions.
FollowingtheworkofKroeningandStrichman[ 21],wesumma-
rizeTable 1usingthegrammarshowninFigure 3.Thegrammar
consistsofformulas( /u1D439),bitvectorcomparisons( /u1D435),ﬂoating-point
comparisons( /u1D436),bitvectorvalues( /u1D449),andﬂoating-pointvalues( /u1D44A).
Intuitively,formulasareexpressionswithbooleansort;bitvector
and ﬂoating-point comparisons are expressions of boolean sort
which take bitvector or ﬂoating-point expressions, respectively;
andvaluesare expressionsofbitvector orﬂoating-pointsort.
4 SLOT: SMT-LLVM OPTIMIZING
TRANSLATION
ThissectionformalizesthetranslationdescribedinSection 2and
presentsproofsofsemanticspreservationforbitvectorsandﬂoating-
pointvalues.
4.1 Overview
GivenanSMTconstraint /u1D436,SLOTtranslateseachoperationtoan
LLVM equivalent, creating an LLVM function /u1D43F. It then invokes
theLLVMoptimizer,producinganoptimizedfunction /u1D43F′.Finally,it
translates back into an SMT constraint /u1D436′. Intuitively, equivalence
between/u1D436and/u1D436′meansthattheirsetsofsatisfyingassignments
areequal.EquivalencebetweenaconstraintandanLLVMfunctionTable1: List offunctionsinthe bitvectorand ﬂoating-point
theories by type. We abbreviate bitvectors BV, ﬂoating-point
valuesFP, and rounding modes RM./u1D434represents any type. “*”
indicatesafunction parameterized by integerconstants, “ †”
indicates afunction that changesbitwidths.
Function sort QF_BVandQF_BVFP functions
Bool→Bool not
Bool×Bool→Bool ⇒,and,or,xor
/u1D434×/u1D434→Bool =,distinct
Bool×/u1D434×/u1D434→/u1D434 ite
BV×BV→Bool bvule,bvsle,bvuge,bvsge,bvult,bvslt,bvugt,
bvsgt
BV→BV bvnot,bvneg,extract∗†,repeat∗†,zero_extend∗†,
sign_extend∗†,rotate_left∗,rotate_right∗
BV×BV→BV concat†,bvadd,bvsub,bvmul,bvsdiv,bvudiv,
bvsrem,bvurem,bvsmod,bvand,bvor,bvnot,bvxor,
bvnand,bvnor,bvxnor,bvshl,bvlshr,bvashr,
bvcomp
FP→Bool fp.isNaN ,fp.isInfinite ,fp.isZero ,fp.isNormal ,
fp.isSubnormal ,fp.isNegative ,fp.isPositive
FP×FP→Bool fp.eq,fp.lt,fp.gt,fp.leq,fp.geq
FP→FP fp.neg,fp.abs
RM×FP→FP fp.sqrt,to_fp∗†,fp.roundToIntegral
FP×FP→FP fp.rem,fp.min,fp.max
RM×FP×FP→FP fp.add,fp.sub,fp.mul,fp.div
RM×FP×FP×FP→FP fp.fma
BV→FP to_fp∗
BV×BV×BV→FP fp∗
RM×BV→FP to_fp∗†,to_fp_unsigned∗†
RM×FP→BV fp.to_ubv∗†,fp.to_sbv∗†
/u1D439:=true|false|/u1D436|(not/u1D439)|(⇒/u1D439 /u1D439)|
(and/u1D439 /u1D439)|(or/u1D439 /u1D439)|(xor/u1D439 /u1D439)|(=/u1D439 /u1D439)|
(distinct /u1D439 /u1D439)|(ite/u1D439 /u1D439 /u1D439)
/u1D435:=(=/u1D449 /u1D449)|(distinct /u1D449 /u1D449)|(bvc/u1D449 /u1D449)
/u1D436:=(=/u1D44A /u1D44A)|(distinct /u1D44A /u1D44A)|(fpc/u1D449 /u1D449)|
(fp.isclass /u1D44A)
/u1D449:=Constant|Symbol|(ite/u1D439 /u1D449 /u1D449)|(bvop1/u1D449)|
(bvop2/u1D449 /u1D449)|(fp.to_ubv /u1D44A)|(fp.to_sbv /u1D44A)
/u1D44A:=Constant|Symbol|(fp.fma/u1D44A /u1D44A /u1D44A)|
(fpop1/u1D44A)|(fpop2/u1D44A /u1D44A)|(to_fp/u1D449)|
(to_fp_unsigned /u1D449)|(fp/u1D449 /u1D449 /u1D449)
Figure3:Thegrammarofconstraintsinthe QF_BVandQF_BVFP
logics.bvcisanyofthebitvectorcomparisonsfromTable 1.
fpcmeansanyoftheﬂoating-pointcomparisons,and class
meansanyoftheﬂoating-pointclassoperations. bvop1and
bvop2meananyoftheunaryandbinarybitvectoroperations,
respectively,andthesamefor fpop1andfpop2.
means that, given a variable assignment, evaluating the constraint
produces the same result as executingthe LLVMfunction.
Algorithm 1performs the translation from an SMT-LIB con-
straint/u1D436intoanLLVMfunction /u1D43F.Eachfunctionrecursivelybuilds
the LLVM statements corresponding to an SMT expression. The
GetLLOpfunction represents fetching an LLVM instruction or in-
structions which have the same eﬀect as the input SMT operation
/u1D436op.The variables of /u1D436are convertedto arguments of /u1D43F.
Optimization from /u1D43Fto/u1D43F′is performed by the LLVM optimizer.
Forblack-boxstyleprocessingofSMTconstraints, SLOTusesall
the passes included in LLVM’s O3optimization level. However, not
1179ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA Benjamin MikekandQirun Zhang
Algorithm1: SLOTfrontendtranslation.
Data:C,aconstraintwithfunction /u1D436op, children /u1D4360,/u1D4361,...
Result:L, an LLVMfunction
Function BuildLLVM( C):
ifCis an FP comparison then
returnBuildComparison( FP,C);
else ifCis a BVcomparison then
returnBuildComparison( BV,C);
else ifCis a leaf then
returnCas booleanconstant;
else return GetLLOp( /u1D436op,BuildLLVM( /u1D4360),BuildLLVM( /u1D4361));
Function BuildComparison( T,C):
returnGetLLOp( /u1D436op,BuildVal( T,/u1D4360),BuildVal( T,/u1D4361));
Function BuildVal( T,C):
ifCis a leaf then
returnCas aT constant;
else ifCis an FP conversion then
returnGetLLOp( /u1D436op,BuildVal( BV,/u1D4360))
else ifCis a BVconversion then
returnGetLLOp( /u1D436op,BuildVal( FP,/u1D4360))
else ifCisitethen
returnSelect(BuildVal( Bool,/u1D4360),BuildVal( T,/u1D4361),
BuildVal( T,/u1D4362));
else return GetLLOp( /u1D436op,BuildVal( T,/u1D4360),BuildVal( T,
/u1D4361));
alloptimizationpassesarerelevantto SLOT’stranslation(forin-
stance,SLOTdoesnotintroduceanymemoryoperations).Section 5
discussesindetailwhichLLVMpassesaremostimportantfor SLOT.
Finally, we translate /u1D43F′back into an SMT constraint /u1D436′with
Algorithm 2. This translation is straightforward; we proceed along
the/u1D43F′syntax tree and convert each instruction to its equivalent
SMT-LIB function as in Algorithm 2. Because frontend translation,
optimization,and backendtranslationallpreservethe semanticsof
the constraint, we can then use the satisﬁability of /u1D436′as a proxy
for the satisﬁability of /u1D436—this property is formalized in Theorem 1.
The key challenge of translation is deﬁning GetLLOpwithout in-
troducing undeﬁned behavior. Some functions can be translated
one-to-one,butbitvectordivision,shifts,andﬂoating-pointcom-
parisons have subtly diﬀerent semantics in LLVM and SMT-LIB. In
addition, some SMT operations have no direct LLVM equivalent
and viceversa, requiringtheirsemanticstobebuilt fromexisting
operations ineachlanguage.
4.2 Frontend Translation
Types.Let/u1D436beanSMTconstraintovervariables /u1D4501,/u1D4502,...,/u1D450/u1D45B.The
possiblesortsofavariable /u1D450/u1D456areboolean,bitvector,andﬂoating-
point.An SMT-LIB booleanisequivalentto the LLVM i1type.An
/u1D45B-widebitvector isequivalenttotheLLVMtype i/u1D45B.TheSMT-LIB
ﬂoating-pointsorts (_ FloatingPoint 5 11),(_ FloatingPoint 8 24),
(_ FloatingPoint 11 53),and(_ FloatingPoint 15 113)arerespec-
tivelyequivalentto LLVM’s half,float,double,andfp128types.
SMT-LIB supports ﬂoating-point values of arbitrary width (and
even of arbitrary exponent and signiﬁcand widths), but LLVM sup-
portsonlyafewﬁxedﬂoating-pointwidths.We,therefore,limitour
translationtothestandard16-,32-,64-, and128-bitﬂoating-point
types withexponentandsigniﬁcand sizeslistedabove.Algorithm2: SLOTbackend translation.
Data:L, an LLVMfunction
Result:C,an SMT constraint
Function BuildSMT( L):
/u1D449←/u1D43F./u1D44E/u1D45F/u1D454/u1D462/u1D45A/u1D452/u1D45B/u1D461/u1D460 ;
returnConvertVal( V,L.return );
Function ConvertVal( Vars, Value ):
ifValueinVars then
returnGetSMTVar( Value);
else ifValueis a constant then
returnGetSMTConst( Value);
else ifValueisicmpthen
returnGetSMTBvComp(ConvertVal( Vars, Value.op(0) ),
ConvertVal( Vars, Value.op(1) ));
else ifValueisfcmpthen
returnGetSMTFloatComp(ConvertVal( Vars, Value.op(0) ),
ConvertVal( Vars, Value.op(1) ));
else ifValueis an intrinsiccall then
returnGetSMTIntrinsic(ConvertVal( Vars, Value.op(0) ),
...);
else
returnGetSMTOp(ConvertVal( Vars, Value.op(0) ),
ConvertVal( Vars, Value.op(1) ));
Example1. An SMT constraint /u1D436withvariables
(declare-fun a () Bool)
(declare-fun b () (_ BitVec 64))
(declare-fun c () (_ FloatingPoint 8 24))
is translated to anLLVMfunctionwiththe followingsignature:
define i1 @C(i1 %a, i64 %b, float %c).
VariablesandConstants. Duringfrontendtranslation,wegive
variables the same names in /u1D43Fas in/u1D436. It is also straightforward
to translate boolean and bitvectorconstants, which have the same
representationinLLVMasinSMT-LIB.Theﬂoating-pointvalues
±0,±∞,andNaNaretranslatedtotheirLLVMrepresentations;all
otherﬂoating-pointvaluesare constructedfrom bitvectors.
SimpleOperations. Manyoperationshavethesamesemantics
inLLVMandSMT-LIB;welisttheseherewithoutdetailedproof.
SLOTtranslatestheseoperationsbysimplyapplyingtheequivalent
LLVMoperation to the same arguments.
•Thebooleanfunctions and,or,andxorhavethesamenames
andsemanticsinLLVMandSMT-LIB. (⇒/u1D44E/u1D44F)isreduced
to(or(not/u1D44E)/u1D44F).
•Bitvector and ﬂoating-point comparisons (including =for
bitvectors and fp.eqfor ﬂoating-point) are equivalent to
theLLVM icmpandfcmpinstructionswiththeappropriate
condition codes ( orderedfor ﬂoating-point).
•The SMT-LIB function iteisequivalentto LLVM select.
•ZeroextensionandsignextensionareequivalentinSMT-LIB
andLLVM.
•Thebitvectormathoperations bvadd,bvsub,andbvmuland
foatingpointmathoperations fp.neg,fp.add,fp.sub,fp.mul,
fp.div, andfp.remhave the same semantics as the similarly
namedLLVMinstructions.
•The SMT-LIB notandbvnotoperations are equivalent to the
LLVMxorinstruction with the second argument having all
bits set(i.e.,−1).
1180SpeedingupSMTSolvingviaCompilerOptimization ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA
1%zero = icmp eq i /u1D45B%b, 0
2%div = udiv i /u1D45B%a, %b
3%out = select i1 %zero, i /u1D45B-1, i/u1D45B%div
(a)LLVM equivalentof (bvudiv/u1D44E/u1D44F).
1%zero = icmp eq i /u1D45B%b, 0
2%neg = icmp slt i /u1D45B%a, 0
3%const = select i1 %neg, i /u1D45B1, i/u1D45B-1
4%div = sdiv i /u1D45B%a, %b
5%out = select i1 %zero, i /u1D45B%const, i /u1D45B%div
(b) LLVM equivalentof (bvsdiv/u1D44E/u1D44F).
1%zero = icmp eq i /u1D45B%b, 0
2%rem ={u,s}rem i/u1D45B%a, %b
3%out = select i1 %zero, i /u1D45B%a, i/u1D45B%rem
(c) LLVM equivalentof (bv{u,s}rem /u1D44E/u1D44F).
Figure 4: LLVM equivalents of SMT-LIB division and remain-
der.
•to_fpon a single bitvector argument is equivalent to the
LLVMbitcastinstruction. to_fpon a ﬂoating-point argu-
ment is equivalent to either fpextorfptrunc, depending on
the relative widths. to_fpon a rounding mode and a bitvec-
tor(i.e.,signednumericconversiontoﬂoating-point)hasthe
samesemanticsas sitofpinLLVM.Similarly, to_fp_unsigned
isequivalentto uitofp.
•TheSMT-LIBconversions fp.to_ubv andfp.to_sbv areequiv-
lent to the LLVM instructions fptouiandfptosi, respec-
tively.
In addition to functions with equivalent LLVM instructions , we
express several SMT-LIB functions using LLVM intrinsics. These
are commonLLVMfunctionsinvokedusing the call⟨intrinsic⟩
syntax. In the context of SLOT, there is no cost to using intrinsics
insteadofinstructions,aswedonotusetheLLVMIRtogeneratea
binary.
•SMT-LIB bit rotation is equivalent to LLVM’s funnel shift
intrinsics.Forexample, ((_ rotate_left /u1D456)/u1D44E)becomes call
i/u1D45B@llvm.fshl.i /u1D45B(i/u1D45B%a, i/u1D45B%a, i/u1D45B /u1D456).
•Floating-point fusedmultiply-add (FMA),squareroot,and
absolute value have thesamenames andsemantics inSMT-
LIBandLLVM(as intrinsics).
•fp.minandfp.maxare equivalent to the llvm.minnum and
llvm.maxnum intrinsics,respectively.ThesematchtheSMT-
LIB semantics in that if one argument is NaN, the other argu-
mentisreturned.
•The SMT-LIB ﬂoating-point class predicates like fp.isNaN,
fp.isInfinite , etc. are equivalent to the llvm.is.fpclass
intrinsic. Thisintrinsic takesa bitmaskrepresenting which
classestocheckfor–eachoftheSMT-LIBpredicatescanbe
representedwiththe ﬂags.
Division and Bit Shifting. There are several functions whose
SMT-LIBandLLVMversionsdiﬀerinsubtlewaysbecauseofun-
deﬁned behavior. In SMT-LIB, bitvector division by 0is deﬁned
asaﬁxedvaluedependingonthedividend.InLLVM,itproduces
apoisonvalue,whichispropagatedbytheoptimizerthroughall
subsequentoperations.TobuildanequivalentseriesofLLVMin-
structions, we mustadd acheckfor this case.1%wide = icmp uge i /u1D45B%b,/u1D45B
2%shift = shl i /u1D45B%a, %b
3%out = select i1 %wide, i /u1D45B0, i/u1D45B%shift
(a)LLVM equivalentof (bvshl/u1D44E/u1D44F).
1%wide = icmp uge i /u1D45B%b,/u1D45B
2%shift = lshr i /u1D45B%a, %b
3%out = select i1 %wide, i64 0, i /u1D45B%shift
(b) LLVM equivalentof (bvlshr/u1D44E/u1D44F).
1%wide = icmp uge i /u1D45B%b,/u1D45B
2%neg = icmp slt i /u1D45B%a, 0
3%const = select i1 %neg, i /u1D45B-1, i/u1D45B0
4%shift = ashr i /u1D45B%a, %b
5%out = select i1 %wide, i /u1D45B%const, i /u1D45B%shift
(c) LLVM equivalentof (bvashr/u1D44E/u1D44F).
Figure 5:LLVM equivalentsofSMT-LIBshift.
1%bca = bitcast float %a to i /u1D45B
2%bcb = bitcast float %b to i /u1D45B
3%nana = call i1 @llvm.is.fpclass.f /u1D45B(fp %a, i32 3)
4%nanb = call i1 @llvm.is.fpclass.f /u1D45B(fp %b, i32 3)
5%both = and i1 %nana, %nanb
6%eq = icmp eq i /u1D45B%bca, %bcb
7%out = or i1 %both, %eq
Figure 6: LLVM equivalent of (=/u1D44E /u1D44F)for ﬂoating-point val-
ues.fpindicates half,float,double,orfp128withwidth /u1D45B.The
constant i32 3indicates acheckfor NaN.
Figure4shows the frontend translation of the four SMT-LIB
bitvector division and remainder operations. In each case, SLOT
addsacheckcomparingthedivisortozero,andthenchooseseither
theresultofanLLVMmathoperationoraconstantasdeﬁnedin
the SMT-LIB standard. Signed division (Figure 4b) may produce
either1or−1depending on the signs of the inputs. The bvsmod
operation istranslatedto acomputationinterms of urem.
In addition to diﬀerent handling of division by 0, LLVM and
SMT-LIB have diﬀerent semantics for bitvector shift operations. In
LLVM, shifts by the bit width or more have undeﬁned behavior. In
SMT-LIB, they always result in a bitvector of all 0s or all1s (in the
case of arithmetic shift right of anegative value). The translations
ofthesethree shift operations are showninFigure 5.
Floating-point Equality. LLVM ﬂoating-point math does not
haveundeﬁnedbehaviorasintheintegercase,butwemusthandle
two distinct notions of equality: fp.eqand “=”. The function fp.eq
checks for ﬂoating-point equality in the IEEE sense; it has the
same semantics as LLVM’s fcmp oeq. SMT-LIB “ =”, on the other
hand, is a core theory operation that checks for the equality of two
SMTexpressions.UnlikeIEEE-754,everyvaluemustbeuniquely
represented in SMT-LIB, so there is one NaN“object” which is equal
to any other NaN. In all other cases, “ =” means bitwise equality–this
translation isshowninFigure 6.
Changing Bit Widths. There are three bitvector operations that
changethebitwidthsoftheirarguments:concatenation(combining
multiple bitvectors), repeat (repeating a single bitvector a constant
number of times), and bit extraction. Each of these operations is
translatedtoasequenceofLLVMinstructionsthatsimulatetheir
semantics. Suppose we have a bitvector /u1D44Eof length /u1D45Band want
1181ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA Benjamin MikekandQirun Zhang
1%zsg = zext i1 %sign to i /u1D45B
2%zex = zext i /u1D452%exp to i /u1D45B
3%zsi = zext i /u1D460%sig to i /u1D45B
4%ssg = shl i /u1D45B%zsg,/u1D45B−1
5%sex = shl i /u1D45B%zex,/u1D452
6%right = or i /u1D45B%sex, %zsi
7%all = or i /u1D45B%ssg, %right
8%out= bitcast i /u1D45B%all to fptype
Figure7:LLVMequivalentof (fpsignexpsig)./u1D45Bisthewidth
oftheﬂoating-pointvalues, /u1D452isthewidthoftheexponent,
and/u1D460is the width of the signiﬁcand. fptypemay be any of
half,float,ordouble.
to extract the bits from /u1D456down to /u1D457(both inclusive in SMT-LIB).
Intuitively, to extract this portion of /u1D44E, we move the bits of interest
to the right end of the bitvector (a shift by /u1D457), and then truncate to
the appropriate size ( /u1D456−/u1D457+1).
Concatenationinvolvesextendingbothargumentstothenew
width,shiftingoneintothenewly-addedall-zerobitsoftheother,
andthencombiningwithbitwise or.TheSMT-LIB(( _repeat/u1D45B)a)
operationistranslatedbychainingmultipleconcatenations.The
number of repetitions is a constant parameter, and is therefore
known statically. The translations of concatenation and repetition
mayaddredundantoverheadforsomeinputs,butanysuchover-
head iseliminatedduringthe optimization phase.
Floating-point Construction. The SMT-LIB ﬂoating-point con-
structor fptakes a bitvector each for the sign, exponent, and sig-
niﬁcandandreturnsaﬂoating-pointvalue.InLLVM,weneedto
concatenate(shiftandbitmask)thethreepartsandinterpret( i.e.,
bitcast) the result as a ﬂoating-point value. This translation is
showninFigure 7.
RoundingModes. SMT-LIBdeﬁnesﬁveseparateﬂoating-point
roundingmodes :roundNearestTiesToEven ,roundNearestTiesToAway ,
roundTowardPositive ,roundTowardNegative , androundTowardZero .
These modes specify the semantics of ﬂoating-point operations
likeadditionandsubtractionwhenroundingisrequired.Bydefault,
LLVM ﬂoating-point instructions follow round to nearest with ties
to even, so SLOTtranslates SMT function applications with this
rounding mode directly to LLVM instructions. For other round-
ing modes, the tool must generate an LLVM call to a constrained
ﬂoating-point intrinsic in LLVM, which in most cases allows the
speciﬁcation ofroundingmode.
Example2. TheSMToperationwith32-bitﬂoating-pointvariables
/u1D44Eand/u1D44F
(fp.add roundTowardPositive a b)
is translated to thefollowing:
call float @llvm.experimental.constrained.fadd.f32(
float %a, float %b, metadata !"round.upward",
metadata !"fpexcept.ignore")
However,constrainedﬂoating-pointintrinsicsdonotexistfor
allSMT-LIBoperations;inthesecases, SLOTchoosesthecorrectin-
trinsic based on rounding mode. For example, SMT-LIB conversion
from ﬂoating-point to signed bitvector ( fp.to_sbv ) becomes one of
constrained.roundeven ,constrained.lround ,llvm.ceil ,llvm.floor ,
orfptosi,dependingontherounding mode.Analogousmeasures
are requiredfor fp.to_ubv andfp.roundToIntegral .4.3 Backend Translation
Simple Operations, Variables, and Types. During backend
translation, the straightforward operations listed in Section 4.2
canbetranslatedjustasduringfrontendtranslation.Functionargu-
mentsof /u1D43F′areconvertedtovariablesin /u1D436′withthesamenames
and types. LLVM’s optimizer may add or remove intermediate SSA
variables in /u1D43F, but only the function arguments are converted to
variables in /u1D436. The optimizer may render one of the function ar-
guments dead; in this case, it is not translated back into a variable.
Therefore,thesetofvariablesin /u1D436′isasubsetofthevariablesin
/u1D436.Bitvectorandﬂoating-pointtypesarealsotranslatedasduring
frontendtranslation.However,LLVMdoesnotdistinguishbetween
booleansand1-widebitvectors,whileSMT-LIBdoes.Inmostcases,
this distinction is immaterial, and we treat i1as a boolean, but
wheretheoptimizerintroducesbitvectoroperationsonan i1(for
instance,signextension),weconverttheargumenttoabitvector,
ratherthanaboolean.
Undeﬁned Behavior. During frontend translation, great care
mustbetakennottointroduceundeﬁnedbehaviorinto /u1D43F.Thisis
becausetheSMTversionsofoperationsaremorestrictlydeﬁned
thanthoseinLLVM;inotherwords,theSMTbitvectordivision,for
instance,matchestheoutputsofLLVMdivisiononallinputs,but
notthereverse.LLVMoptimizationdoesnotintroduceanyunde-
ﬁned behavior,so, during backendtranslation, we need not insert
anychecksaroundoperationslikedivisionandshifting.Thereis
one LLVM operation that is undeﬁned in SMT-LIB: bitcast conver-
sions from ﬂoating-point values to integers. SLOThandles these
conversionsbyintroducinganextraintegervariableandconstrain-
ingthe result ofconverting itto aﬂoating-point.
Bit Operation Intrinsics Frontend translation produces only
thoseintrinsicslistedinSection 4.2.However,theoptimizermay
introduceotherintrinsicswhichmustbehandledbybackendtrans-
lation.The llvm.bswap intrinsicswapsthe lowestandhighest bytes
of its input, and is translated to a sequence of extract and con-
catenate operations representing these semantics. Similarly, the
llvm.bitreverse intrinsicreversesallofthebits;thisisalsoachieved
bycomposingextractionandconcatenation.Finally,the llvm.ctpop
intrinsic counts how many bits are set (have value 1) in a bitvec-
tor; this is also achieved through several extractions followed by
addition.
Math Intrinsics. LLVM includes the intrinsics umin,umax,smin,
andsmaxto take the signed minimum, unsigned maximum, signed
minimum, and signed maximum, respectively, of two bitvector
arguments. These intrinsics are translated into an SMT-LIB ite
operation with the appropriate comparison. For example, a umin
call on bitvector arguments /u1D44Eand/u1D44Fis translated to the SMT-LIB
expression( ite(bvultab)ab).
In addition, LLVM includes “saturated” math operations like
llvm.usub.sat . These instructions prevent over- and underﬂow by
clampingthereturnvalueto 0ifunderﬂowwouldhaveoccurred.
Liketheminimumandmaximumoperations,theseintrinsicsare
translated to a iteexpression. Rounding mode intrinsics produced
byfrontendtranslationmustalsobeconvertedbacktothecorre-
sponding SMT function with the correct rounding mode argument.
1182SpeedingupSMTSolvingviaCompilerOptimization ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA
4.4 PreservationofSatisﬁability
We show that, for bitvector and ﬂoating-point constraints, the sat-
isﬁability of the original SMT constraint is preserved through fron-
tend translation (Lemma 1), optimization, and backend translation
(Lemma2).
Property 1 (Optimizer semantics preservation). Given an
inputLLVMfunction /u1D43Fwhichdoesnotcontainanyundeﬁnedbehavior,
theresultofoptimizing /u1D43F,callit/u1D43F′,hasthesamesemanticsas /u1D43F.That
is,forall inputs /u1D4591,/u1D4592,...,/u1D459/u1D45B,/u1D43F(/u1D4591,/u1D4592,...,/u1D459/u1D45B)=/u1D43F′(/u1D4591,/u1D4592,...,/u1D459/u1D45B).
This property of the optimizer may not always hold because the
optimizer may contain bugs. But in our work, we take it as ground
truth that the input and output of the optimizer are equivalent.
Because we focus on relatively simple optimizations ( e.g.,we do
not deal with memory operations), compiler bugs changing our
results are likely to be rare. In our testing of more than 100,000
SMTbenchmarks,wehaveencounterednocompilerbugs.Wenow
prove that SLOTissemantics-preserving.
Lemma 1 (Frontend translation). Let/u1D436be an SMT constraint
with variables /u1D4501,/u1D4502,...,/u1D450/u1D45B, and/u1D43Fbe the function produced by the
frontend translation of /u1D436. Then/u1D436is satisﬁable if and only if there
existsaninputto /u1D43Fforwhich /u1D43Freturnstrue.
Proof.(⇒)Assume/u1D436is satisﬁable. Then there exists an as-
signment of the variables of /u1D436,/u1D44B={/u1D4651,/u1D4652,...,/u1D465/u1D45B}for which /u1D436
evaluatestotrue.Let /u1D43FdenotetheLLVMfunctionresultingfrom
frontend translation. From Section 4.2, at each instruction /u1D456in/u1D43F,
thevalueproducedby /u1D456isthesameasthevalueproducedbythe
corresponding function application in /u1D436. In particular, with the
assignment /u1D44B,/u1D436’soutermostfunctionapplicationshouldproduce
true.This means that the last instructionin /u1D43Fmustreturn true.
(⇐)Assumethatthereisaninput /u1D44B={/u1D4651,/u1D4652,...,/u1D465/u1D45B}suchthat
/u1D43F(/u1D44B)istrue, and consider whether the assignment of the values /u1D44B
tothevariablesof /u1D436satisﬁes/u1D436.BythetranslationsinSection 4.2,for
eachinstruction /u1D456,theequivalentfunctionapplicationin /u1D436yields
thesamevalue.Inparticular,weassumethatthelastinstructionin
/u1D43Freturnstrue; this corresponds to theﬁnal result ofevaluating /u1D436,
sothe assignment /u1D44Bmustsatisfy the constraint /u1D436.□
Lemma2(Backendtranslation). Let/u1D43FbeanLLVMfunction
over integer (bitvector) types with /u1D45Barguments, and let /u1D436be the SMT
constraint resulting from performing backend translation on /u1D43F. Then,
/u1D436is satisﬁable if and only if there exists a set of inputs /u1D4591,/u1D4592,...,/u1D459/u1D45B
suchthat /u1D43F(/u1D4591,/u1D4592,...,/u1D459/u1D45B)returnstrue.
Proof.(⇒)Assume that there exists an input /u1D4591,/u1D4592,...,/u1D459/u1D45Bon
which/u1D43Freturns true. Let the set of values of the internal SSA
variables of /u1D43Funder the given input be /u1D4631,/u1D4632,...,/u1D463/u1D459, and call /u1D44C=
{/u1D4591,/u1D4592,...,/u1D459/u1D45B,/u1D4631,/u1D4632,...,/u1D463/u1D459}the set of all variables from /u1D43F. At each
instruction /u1D456in/u1D43F,thecorrespondingfunctionapplicationin /u1D436gives
thesamevalueas /u1D456.Inparticular,because /u1D43Freturnstrue,thelast
instruction, and so the result of evaluating /u1D436, must be true, which
means that the assignment /u1D44Csatisﬁesthe constraint /u1D436.
(⇐)Assume that /u1D436is satisﬁable. This means that there exists
a set of variables /u1D44C={/u1D466.alt1,/u1D466.alt2,...,/u1D466.alt/u1D458}for which /u1D436produces true.
Nowtakethesubsetof /u1D44C,whichcorrespondstotheinputvariables
of/u1D43F.Ateachinstructionin /u1D43F,weknowthevaluemustbethesameasthecorrespondingSMTfunctionapplication.Inparticular,the
outermostfunctionof /u1D436correspondsto /u1D43F’sreturninstruction,so
since the assignment /u1D44Ccaused/u1D436to evaluate to true,/u1D43Fmust also
returntrue. □
Theorem1(Preservationofsatisfiability). GivenanSMT
constraint /u1D436on ﬂoating-points and bitvectors,the newconstraint /u1D436′
produced by SLOTis satisﬁable ifand only if /u1D436is satisﬁable.
Proof.(⇒)Let/u1D43Fbe the LLVM function produced by frontend
translationof /u1D436,/u1D43F′betheresultofoptimizing /u1D43F,and/u1D436′betheresult
of conducting abackendtranslationof /u1D43F′. Assume /u1D436is satisﬁable.
Then by Lemma 1, there exists an input onwhich /u1D43Freturnstrue.
Moreover, from Section 4.2, we know that /u1D43Fcontains no undeﬁned
behavior.Therefore,byProperty 1,thereisaninputto /u1D43F′suchthat
/u1D43F′alsoreturns true.Butthen, byLemma 2,/u1D436′issatisﬁable.
(⇐)Assumethat /u1D436′issatisﬁable.ThenbyLemma 2,thereexists
aninputonwhich /u1D43F′returnstrue.Again,weknowthat /u1D43Fhasno
undeﬁned behavior by the lemmas in Section 4.2, so by Property 1,
thereisaninputto /u1D43Fforwhich /u1D43Freturnstrue.Butthen,byLemma 1,
/u1D436issatisﬁable. □
Theorem 1meansthatthesequenceoftranslation,optimization,
and translation described in this section produces a new constraint
thathasthesamesatisﬁabilityastheoriginal.Moreover,because
of the construction of the translation, SLOTalso preserves models
between/u1D436and/u1D436′. That is, if /u1D436is satisﬁable, an assignment that
satisﬁes/u1D436′directlygivesanassignmentthatsatisﬁestheoriginal
constraint—we just ignore the extra variables introduced by the
translation and optimization process. The theoretical guarantee
of Theorem 1gives us a practical, solver-agnostic tool for pre-
processing andoptimizing SMTconstraints.
5 EVALUATION
We evaluate SLOTby applying it to the SMT-LIB benchmark suites
forthesubjecttheories[ 3].Wehighlightourmostimportantresults
as follows.
•SLOTincreases the number of solvable formulas at speci-
ﬁedtimeoutsbyupto24%forbitvector-onlybenchmarks,
14% forﬂoating-point-only benchmarks, and 80%for mixed
benchmarks, allowing the solving of all but one QF_BVFP
benchmarkwithin 600seconds.
•On average, SLOTslows down the smallest benchmarks but
speedsupthelargestbenchmarks.Geometricmeanspeedups
are up to 2.8×for bitvector-only benchmarks and over 3×
for ﬂoating-pointbenchmarks.
•Most ofSLOT’s speedup is the result of just a few simple
LLVMoptimizationpasseslike instcombine .Ourapproach
shows which optimizations are “missing” from SMT solvers
and allows the eﬀort involved in developing these passes to
be instantlyavailable inthe SMTcontext.
5.1 ExperimentalSetup
Givenasolver,abenchmark,andatimeout /u1D447∗,wefollowathree-
stepprocesstotesttheeﬀectivenessof SLOT.First,wemeasurehow
longittakesforthesolvertoconcludeeither satorunsatforthe
benchmark; call this /u1D447pre. Then, we apply SLOTto the benchmark,
1183ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA Benjamin MikekandQirun Zhang
Table 2:Timeoutimprovementresultsproducedby SLOT.Eachcolumndenotesadiﬀerenttimelimit withthetotalnumber
oforiginalunknownformulas(“Total”),thenumberimproved(“Imp.”),andthepercentage(“%”).The“All”rowsdenotethe
number of formulas for which all solvers timed out, but at least one of the solvers produced a solution after SLOTwas applied.
600 300 120 60 30
Benchmark Solver TotalImp. %TotalImp. %TotalImp. %TotalImp. %TotalImp. %
QF_FPZ3 129118.5146128.2161106.2189105.3199 63.0
CVC5 58813.8 7479.59077.8110 87.3124 64.8
All 5559.17479.59077.8109 76.4123 54.1
QF_BVFPZ3 19631.6 281139.3 39718.0 58712.1 952021.0
CVC5 6466.7 6466.7 8337.5 14321.4 351337.1
All 5480.0 5360.0 7228.6 13215.4 28932.1
QF_BVZ3 277150318.2324748514.9399267516.9454570615.5529763912.1
CVC5 214928313.2239734814.5292244115.1395080820.4472189819.0
Boolector 172326415.3205733516.3258035813.9315051316.338952 55013.9
All 77611715.190812814.1114113712.1150925316.8217752524.1
producing a new SMT constraint; we call the time it takes to do
this/u1D447SLOT. Finally, we measure howlong the solvertakesto solve
the optimized benchmark, /u1D447post. For a fair comparison, we must
oﬀset the overhead of running SLOTagainst the speedup achieved.
Thus,aformulahasbeenimprovedif /u1D447SLOT+/u1D447post</u1D447pre.Thisis
theSLOT-onlyresult. In addition, we adopt the portfolio methodol-
ogy[44];byrunning SLOToptimizationinparallelwithasolver,
a user can simply take whichever result is produced ﬁrst. When
discussing speedups, we report this ( i.e.,min{/u1D447pre,/u1D447SLOT+/u1D447post})
astheportfolioresult.We reportall proportionalspeedupsas geo-
metricmeans,reducingtheimpactoflargeoutliers.Weanswerthe
following researchquestions:
•RQ1:Howmanymoreformulascanbesolved? Given
atimelimit,howmanyformulasfrombenchmarksetscan
SLOTconvertfrom unknownto either satorunsat?
•RQ2:Howmuchfastercanformulasbesolved? Whatis
the proportional speedup produced by SLOTfor constraints
withlowandhigh originalsolving times?
•RQ3: Which LLVM optimization passes contribute?
WhichoptimizationstrategiesinLLVMaremosteﬀectiveat
simplifyingSMTformulasbeyondthecapabilitiesofexisting
solvers?
Implementation. We have implemented SLOTin about 2,500
linesofC++andmadeitpubliclyavailableonGithub.2WeuseZ3’s
built-inparserfortheSMT-LIBlanguageandthestandardLLVM
C++ API, but provide input and output in the standard SMT-LIB
formatforusewithsolversotherthanZ3.Frontendandbackend
translation is carried out as described in Section 4.SLOThas been
testedwithLLVMversion16.0.0.
Benchmarks. Weuseastestcasesthestandardsolverbenchmarks
provided by the SMT-LIB developers for ﬂoating-point numbers
(QF_FP,/u1D45B=40,407), bitvectors ( QF_BV,/u1D45B=46,191), and mixed
ﬂoating-point and bitvector constraints ( QF_BVFP,/u1D45B=17,249) [3].
As discussed in Section 4, we restrict ﬂoating-point variables to
the standard 16-, 32-, 64-, and 128-bit widths and exclude any con-
straintswhichcontainvariableroundingmodes.Theselimitsare
2https://github.com/mikekben/SLOT .minimal: only 26 benchmarks from QF_FP(all for variable rounding
mode), and 128 QF_BVFPbenchmarks (89 for unsupported widths
and 39 for variable rounding modes) are excluded, amounting to
just0.2%ofallmixedandﬂoating-pointbenchmarks.
Solvers. We test with the state-of-the-art general SMT solvers Z3
andCVC5usedinpriorliterature[ 43,46].Forthebitvector-only
benchmarks,we alsotest with Boolector[ 36], a solverspeciﬁcally
optimizedforbitvectors[ 45].SLOThasbeentestedwithZ3version
4.12.1, CVC5version1.0.5, andBoolector version3.2.2.
TestingEnvironment. Allexperimentsareperformedonaserver
withtwoAMDEPYC7402CPUsand512GBRAM,runningUbuntu
20.04.Wetestwithtimeoutsbetween30and600seconds,inline
with those used in applications for translation validation [ 26] (zero
to ﬁve minutes) and symbolic execution (between ﬁve and 129
solvercallswithinonehour)[ 12].Finally,whenmeasuringspeedups,
we count solver and SLOTtimeoutsas 600-secondcontributions.
5.2 RQ1: HowManyMoreFormulasCan be
Solved?
Table2shows the number of constraints that are changed from
unknown to solved by SLOTfor each of thethree benchmark sets.
The total column denotes the number of unknown benchmarks at
eachtimeout,andtheimprovedcolumn(“Imp.”)givesthenumberof
constraints, from those, which can be solved after SLOTis applied.
Theresultsinclude SLOT’srunningtime, i.e.,wereportabenchmark
asimprovedonlyif /u1D447post+/u1D447SLOT</u1D447∗.Sincesolversaretypically
run with a ﬁxed timeout, e.g., during symbolic execution [ 12], the
proportionofconstraintsthatmovefromtimeouttosolvedatﬁxed
valuesof /u1D447∗represents an improvement for users.
SLOTis most eﬀective at speeding up constraints with a mix of
ﬂoating-pointandbitvectorvariables.Itallowsallbutonemixed
benchmarktobesolvedwithin600secondsandreducesthenumber
ofunsolvableconstraintsbyaboutone-thirdatalltimelimits. SLOT
renders solvable roughly 10% of timeout ﬂoating-point constraints,
and 15%-20% of bitvector benchmarks. The results are comparable
for each of the tested solvers, showing that SLOT’s speedup is not
solver-speciﬁc.
1184SpeedingupSMTSolvingviaCompilerOptimization ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA
Most importantly, SLOTnot only improves each solver’s per-
formancebut alsodoesbetter thanallsolvers combined.The“All”
rowsinTable 2showthenumberofbenchmarksforwhichallofthe
solvers timed out and the number which became possible to solve
withatleastoneofthesolvers.Theimprovementsintheserows
showthat SLOToutperformsevenaportfolioofexistingsolvers,
decreasing the number of unknown constraints by as much as 24%
for small bitvector benchmarks.
5.3 RQ2: HowMuch Faster Can Formulasbe
Solved?
Figure8showsthemeanspeedupsobservedforeachbenchmark
set. Values below one indicate a slowdown. For the smallest bench-
marks,SLOTslows down solving, often substantially. However,
whiletheproportionalslowdownislarge,theabsoluteslowdownis
typicallysmall,andoccursbecausetheoverheadoftranslatingout-
weighsthecostofsimplysolvingthebenchmark( i.e.,/u1D447SLOT>/u1D447pre).
Forexample,onebenchmark3withZ3isspedupfrom0.06seconds
to 0.02 seconds (a 3×speedup), but SLOTtakes 0.24 seconds to
translate and optimize it, creating an overall proportional slow-
down.
Theeﬀectreversesformorecomplexconstraints:forconstraints
that takelonger than 300seconds, we improve mean solving time
bymorethan 1.25×forﬂoating-point,about 1.6×formixed,andbe-
tween1.6×and2×forbitvectorbenchmarks.Theportfoliomethod-
ologyyieldsevengreaterrunningtimeimprovements,intherange
of3×forQF_BVFPand2×forQF_BV. Even small constraints below
60 seconds of initial running time see appreciable speedups un-
derallsolverswiththeportfoliomethod.Thediﬀerencebetween
theSLOT-only and portfolio results exists because the dramatic
speedup of some constraints is oﬀset by a slowing down of others.
5.4 RQ3: Which LLVM Optimization Passes
Contribute?
To understand why SLOTproduces performance improvements,
weinvestigatewhichLLVMpassescontributemosttotheunder-
lying results. The structure of SMT constraints means that most
LLVM optimization passes are irrelevant to SLOT. Translated SMT
constraintsdiﬀerfrom mostprograms inthat:
•They perform no memory operations–SMT variables are
directlytranslatedintoLLVMfunction arguments.
•Theyhaveonlyonefunction;thismaintainstheequivalence
deﬁnitionsdescribedinSection 4.
•The single function has only one basic block ( i.e., there is
nobranching).ThisisaconsequenceofthenatureofSMT
constraints;theonly branch–likeoperationis ite, whichis
translatedto an LLVM selectinstruction.
ThemajorityofLLVM’s58optimizationpassesaﬀectonlymemory
operations (7), are interprocedural (10), or optimize branching (17).
An additional 16 passes do not apply to translated SMT constraints
foravarietyofotherreasons(theyarearchitecture-speciﬁc,they
optimize debug information, etc.). We also exclude bb-vectorize
becausevectorizationintroducessubstantialtranslationoverhead
while providing no beneﬁt in the SMT context. This leaves eight
3QF_BV/Sage2/bench_7588.smt20-30 30-60 60-120 120-300 300-600012
0.350.53 0.60 0.711.27
1.002.05
1.111.30
1.27
0.280.851.14
1.001.25
1.00 1.111.62
1.28
1.27
Original solving time (s)SpeedupZ3Z3 Ptf.
CVC5CVC5 Ptf.
(a)QF_FP
0-30 30-60 60-120 120-300 300-60001234
0.481.68
1.02 1.211.60
1.022.04
1.42 1.61
1.60
0.592.68
1.253.08
2.93
1.042.89
1.273.08
2.93
Original solving time (s)SpeedupZ3
Z3 Ptf.
CVC5
CVC5 Ptf.
(b)QF_BVFP
0-30 30-60 60-120 120-300 300-6000123
0.030.420.981.71
1.59
1.031.421.792.60
1.66
0.060.341.35
1.271.77
1.121.522.87
2.44
1.87
0.030.780.92
0.772.02
1.031.521.66
1.422.12
Original solving time (s)SpeedupZ3Z3 Ptf.
CVC5CVC5 Ptf.
Bltr.Bltr. Ptf.
(c)QF_BV
Figure 8: Geometric mean speedup from original constraint
to optimized constraint produced by SLOTfor each bench-
mark set under Z3, CVC5, and Boolector (for QF_BV). Con-
straints are grouped into ranges of original solving time
along thex-axis.All measurementsinclude /u1D447SLOT.
1185ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA Benjamin MikekandQirun Zhang
Table3:Percentageofbenchmarksaﬀectedbyeachoptimiza-
tion pass.
Pass QF_FP QF_BVFP QF_BV
instcombine 99% 100% 78%
reassociate 78% 57%26%
gvn <1% <1%43%
sccp 0%<1%17%
dce 0%<1%17%
instsimplify 0%<1%16%
aggressive-instcombine 0% 0%<1%
adce 0% 0%0%
passesthatare relevant to SLOT:instcombine (regularandaggres-
sive),instsimplify ,deadcodeelimination(regularandaggressive),
globalvaluenumbering, reassociate ,andsparseconditionalcon-
stantpropagation(SCCP). SLOTrunsthesepassesinthesameorder
inwhichthey are performedduringLLVM O3optimization.
Table3shows how many benchmarks each optimization pass
aﬀects; a benchmark is counted for a pass if the pass applica-
tioncausedanychangetotheLLVMIRfunction.Agressivedead
code elimination did not change any constraints, and aggressive
instcombine only changed a few; this may be because, for the SMT
context,theirfeaturesareusuallyhandledbythenon-aggressive
versions.Themosteﬀectivepassesare instcombine ,whichchanges
almost every constraint, reassociate , and global value numbering
(forQF_BV). Notably, many more passes change bitvector bench-
marks than ﬂoating-point; this is a combined result of lower struc-
tural complexity in the QF_FPandQF_BVFPbenchmark sets and
greater diﬃcultyinoptimizing ﬂoating-pointoperations.
Table4showsthemeanspeedupobservedforbenchmarkswhich
wereandwerenotaﬀectedbyeachoptimizationpassfor QF_BVwith
initial timeouts above 30 seconds; the results for ﬂoating-point and
mixed benchmarks are comparable, but have small sample size.
Even passes with negative spread, like dce, are beneﬁcial under
portfoliomethodology.Theresultsconﬁrmthat reassociate and
instcombine speed up benchmarks the most, followed by global
valuenumberingand instsimplify .
Theinstcombine pass consists mostly of simple peephole opti-
mizations,whichshowsthatsolverperformancecouldbeneﬁtfrom
simple theory-speciﬁc reasoning, which is already implemented
incompilers.Globalvaluenumberingandreassociationalsocon-
tributesubstantially;whilesomesolverheuristicsalreadyeliminate
common subexpressions, more advanced implementations of these
algorithms in LLVM provide further beneﬁts. Our results show
that the extensive eﬀort expended to perfect compiler optimiza-
tionsindeedprovidesbeneﬁtsbeyondthoseavailableinexisting
SMT solvers. Using SLOT, solver users can beneﬁt from that eﬀort
withoutdeepknowledge ofsolver implementation.
6 DISCUSSION
CompilerOptimizationvs.SMTSimpliﬁcation. Becausethe
purpose of compiler optimizations is to reduce the number of pro-
cessor instructions, some operations which are “simpler” in LLVM
may not provide any advantage in SMT. For example, bitvector
multiplication by 2/u1D45Bis equivalent to shifting left by /u1D45B; however,Table4:Meanspeedupsforbenchmarkswhichareandare
not aﬀected by each pass from the QF_BVbenchmark set with
initialsolvingtimeabove30secondsunderZ3.Thespreadis
the diﬀerence in mean speedup between benchmarks which
are aﬀected by thepassand those which are not.
Pass CountSpeedup
withoutSpeedup
withSpread
reassociate 2,1681.58×2.02×0.44
instcombine 4,0311.49×1.83×0.34
gvn 3,8161.51×1.85×0.34
instsimplify 1,5621.74×1.75×0.22
sccp 1,3601.71×1.86×0.15
dce 1,7051.78×1.68×−0.10
agg-instcombine 81.75×1.22×−0.53
Z3 takes much longer to solve constraints involving shifts. On one
benchmark4for example, Z3 takes less than a second if doubling is
expressed as /u1D44E+/u1D44Eor2×/u1D44E, but does not ﬁnish within 24 hours if it
isexpressedas shift left byone.
In our implementation of SLOT, we provide a ﬂag to force back-
end translation to generate multiplication, rather than shift, where
possible. However, there may be more complex analogous exam-
ples arising from the fundamentally diﬀerent purpose of LLVM. So
whilecompileroptimizationunlockslogicnotpresentinexisting
SMTsolvers,itactsmoreasasievethanasamagicbullet.Running
SLOTand a solver as a portfolio allows solver heuristics and SLOT
each to shine where they perform best, each doing well on some
benchmarks butslowingdown onothers. Onlythosebenchmarks
that neither can handle slip throughthe sieve.
SLOTOverhead. The main driver of the proportional slowdown
forsmallconstraintsisthecostofrunning SLOT.Incontrasttoa
solver, whichjust needs to parse the constraint, SLOTmust parse,
translate,optimize,translateagain,andthenwrite. SLOT’sruntime
isroughlylinearinthesizeoftheASToftheoriginalconstraint,
whileSMT solvinghasunpredictable,possiblyexponential perfor-
mance.Thismeansthattheproportionof /u1D447SLOT+/u1D447postcontributed
bySLOTgenerally decreases as /u1D447preincreases, as shown in Table 5.
The moderateincreasefor QF_BVbenchmarks above 300seconds
isaresultof SLOTtimeouts;thesearecountedas100%contribution
inTable5.Frontendtranslationmakesupabout60%oftherunning
time ofSLOTfor bitvectors, and about one-third for mixed and
ﬂoating-point constraints while optimization contributes between
7% and 10%. Backend translation takes longer for constraints in-
cluding ﬂoating-point numbers (about 60%) because ﬂoating-point
intrinsicsrequireadditionalstepstobetranslatedbacktoSMT-LIB.
Other SMT Theories. Program analysis tools make use of just
afewSMTtheories:bitvectors[ 26],ﬂoating-point[ 25],andmore
recently, strings [ 6].SLOTimproves the performance of solvers on
thetheoriesrelevanttotheseapplications,andweleavetofuture
worktheextensionof SLOT’sgeneralmethodtoothertheorieslike
realnumbersofuseoutsidesoftwareengineering[ 22].Whilethe
optimization process usedin SLOTmayprovidebeneﬁtsoutside
bitvectors and ﬂoating-point numbers, applying translation and
4QF_BV/20190311-bv-term-small-rw-Noetzli/bv-term-small-rw_1244.smt2
1186SpeedingupSMTSolvingviaCompilerOptimization ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA
Table 5:/u1D447SLOT//parenleftbig/u1D447SLOT+/u1D447post/parenrightbig(as a percentage) for bitvector and
ﬂoating-point benchmarks.
Time interval( /u1D447preusing Z3) QF_FP QF_BV QF_BV
0-30 32.21% 22.17% 48.24%
30-60 0.02% 0.16% 3.96%
60-120 0.01% 0.20% 1.67%
120-300 0.01% 0.09% 2.01%
300-600 0.02% 0.01% 2.84%
optimization toother theories would require either a newconcep-
tion of semantics preservation or substantial under-approximation,
since compiler IRs are not expressive enough to model unbounded
computation. The limitations imposed by under-approximating
mayalsonegate any beneﬁtprovidedbycompileroptimizations.
7 RELATED WORK
SMTConstraintTransformation. Existingworkpresentsanum-
berofstrategiesforsimplifyingSMTconstraints.Dillig etal.[17]
introduce a solver-internal constraint simpliﬁcation algorithm that
preservessatisﬁability.Reynolds etal.[38,39]introducesimplifying
transformationsforunboundedstringconstraints.Transformations
ofSMTformulasarealsoemployedtotestsolvers.StringFuzz[ 9]
focuses on generating well-formed formulas, but also provides
some transformations on string constraints. STORM [ 28] trans-
formsbooleanformulastoperformblack-boxtesting.Bugariu et
al.[11] introduce constant assignment and term synthesis as trans-
formationsforstringconstraints.Sparrow[ 46]andYinYang[ 43]
expand transformations to real numbers and integers. The trans-
formationsperformedbythesetoolsaredesignedtotestsolvers;
our approach uses arelatedmethodto speedupsolving instead.
SpeedingupSMTSolving. MostworkonimprovingSMTsolver
performance focuses on algorithms to be implemented within a
solver.InadditiontoZ3,CVC5,andBoolector,suchworkhastaken
the form of new solvers like MathSAT [ 14], Bitwuzla [ 32], and
Yices [19]. Early work on improving solver performance used sym-
metry to reduce the constraint-solving search space [ 16]. More
recently, Niemetz et al.introduced syntax-guided quantiﬁer instan-
tiation to speed up solving for quantiﬁed constraints [ 33]. For par-
ticulartheories,Z3str3 speeds upsolving ofstringconstraints [ 5],
andBerzish etal.introducenewmethodsforsolvingconstraints
involvingregularexpressions[ 6].Sadhak[ 30]combinesCVC4with
fuzzingtechniquesfor uninterpretedfunctionstoimprove perfor-
mance.FastSMT[ 1]usesaneuralnetworktoﬁndbetterwaysto
combine existing solver heuristics, thereby speeding up solving.
MBA-Solver[ 45]departsfromsolver-speciﬁcapproachesbypre-
processing bitvector constraints involving alternating bitwise and
arithmeticoperations.OurapproachismostsimilartoMBA-Solver,
asSLOTusespre-processing ratherthansolver-internal improve-
ments. However, it diﬀers in that we apply the broad range of
optimizations performed by LLVM, including ﬂoating-point trans-
formations. We harness an existing source of optimizations as a
blackbox ratherthanhand-crafting one for the SMTproblem.The Constraint–Code Nexus. Work on symbolic execution and
translationvalidationhasusedSMTconstraintstorepresentthese-
manticsofLLVMprograms.KLEE[ 12]convertsLLVMIRprograms
into SMT formulas that encode symbolic execution constraints;
many symbolic execution tools are built on the LLVM-SMT core
providedbyKLEE[ 37].Aliveanditsprogeny[ 26,27]generateSMT
constraintsfromLLVMinstructionstoverifytheoptimizationsper-
formed by the LLVM optimizer, which Lee et al.[23] expands to
LLVM’s memory model. LifeJacket [ 34] and Alive-FP [ 29] use SMT
formulastoverifyﬂoating-pointcomputation.VeRA[ 10]alsotrans-
lates C++ code to SMT constraints for program veriﬁcation, and
faces some engineering challenges analogous to SLOT. Constraints
intheformalreﬁnement-basedB-methodhavealsobeentranslated
toSMT-LIB[ 20,40].TheseapproachesuseSMTsolverstoreason
about programs and compilers. SLOTdoes the opposite, using a
compilerforreasoningaboutSMTproblemsandexactlypreserving
constraintsemantics instead of solving analysisconstraints.
Optimizations Outside Compilers. Donget al.[18] apply com-
pileroptimizationsdirectlyto programswhichserve as inputsfor
KLEE. They ﬁnd that those optimizations can slow down symbolic
execution becausethe optimizercomplicates branching structure.
LEO[13]attemptstoremedythislimitationbyusingmachinelearn-
ingtochoosewhichoptimizationpassestoapply. SLOT’sresults
diﬀerbecauseitoperatesat the levelof constraints, notprograms.
This allows SLOTto work incontexts outsidesymbolic execution,
andalsoto avoid analysis-frustratingbranching optimizations.
DeclarativeandImperativeCode. Existingworkhasexplored
conversion from declarative to imperative languages to allow plat-
formﬂexibility[ 41]orgiveaccesstogreateroptimizationoppor-
tunities [ 42]. More recently, Li and Slind [ 24] convert functions
in higher-order logic to a simpliﬁed intermediate representation.
Steno [31] translates declarative queries into imperative code to
speed up operations over collections. SLOT, on the other hand,
goes beyond translation to an imperative language by adding back-
end translation and achieves a simpliﬁcation of the declarative
constraints, ratherthantransforming themintoexecutablecode.
8 CONCLUSION
This paper has presented a general pre-processing tool, SLOT,
which allows solverusers to apply compiler optimizations to SMT
constraints as a black box. SLOTpractically improves solvers’ per-
formance on standard benchmarks and increases the number of
solvable constraints at ﬁxed time limits. Furthermore, the speedup
isachievedusingonlythesimplestcompileroptimizationpasses,
giving solver developers insight into possible improvements to
solver tactics.
ACKNOWLEDGMENTS
The authors thank the anonymous reviewers for their feedback on
earlier drafts of this paper. This work was supported, in part, by
the United States National Science Foundation (NSF) under grants
No.1917924,No.2114627,andNo.2237440;andbytheDefenseAd-
vancedResearchProjectsAgency(DARPA)undergrantN66001-21-
C-4024.Anyopinions,ﬁndings,conclusions,orrecommendations
expressed in this publication are those of the authors and do not
necessarily reﬂectthe viewsof the above sponsoring entities.
1187ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA Benjamin MikekandQirun Zhang
REFERENCES
[1]MislavBalunovic,PavolBielik, andMartin T. Vechev. 2018. Learning toSolve
SMT Formulas. In Advances in Neural Information Processing Systems 31: Annual
ConferenceonNeuralInformationProcessingSystems2018,NeurIPS2018,December
3-8,2018, Montréal, Canada . 10338–10349.
[2]Haniel Barbosa, Clark W. Barrett, Martin Brain, Gereon Kremer, Hanna Lachnitt,
MakaiMann,AbdalrhmanMohamed,MudathirMohamed,AinaNiemetz,Andres
Nötzli, Alex Ozdemir, Mathias Preiner, Andrew Reynolds, Ying Sheng, Cesare
Tinelli, and Yoni Zohar. 2022. cvc5: A Versatile and Industrial-Strength SMT
Solver. In Tools and Algorithms for the Construction and Analysis of Systems -
28th International Conference, TACAS 2022, Munich, Germany, April 2-7, 2022,
Proceedings, Part I (Lecture Notes in Computer Science, Vol. 13243) . Springer, 415–
442.https://doi.org/10.1007/978-3-030-99524-9_24
[3]ClarkBarrett,PascalFontaine,andCesareTinelli.2017. TheSMT-LIBStandard:
Version 2.6 . Technical Report. Department of Computer Science, The University
of Iowa. Available at www.SMT-LIB.org .
[4]Clark Barrettand Cesare Tinelli. 2018. SatisﬁabilityModulo Theories. In Hand-
bookofModelChecking .Vol.31.Chapter11,305–343. https://doi.org/10.1007/
s00165-019-00486-z
[5]Murphy Berzish, Vijay Ganesh, and Yunhui Zheng. 2017. Z3str3: A string solver
with theory-aware heuristics. In 2017 Formal Methods in Computer Aided Design,
FMCAD 2017, Vienna, Austria, October 2-6, 2017 . IEEE, 55–59. https://doi.org/10.
23919/FMCAD.2017.8102241
[6]Murphy Berzish, Mitja Kulczynski, Federico Mora, Florin Manea, Joel D. Day,
Dirk Nowotka, and Vijay Ganesh. 2021. An SMT Solver for Regular Expressions
andLinear Arithmetic over StringLength. In ComputerAidedVeriﬁcation -33rd
InternationalConference,CAV2021,VirtualEvent,July20-23,2021,Proceedings,
PartII (LectureNotesinComputerScience,Vol.12760) .Springer,289–312. https:
//doi.org/10.1007/978-3-030-81688-9_14
[7]Nikolaj S. Bjørner, Clemens Eisenhofer, and Laura Kovács. 2023. Satisﬁability
Modulo Custom Theories in Z3. In Veriﬁcation, Model Checking, and Abstract
Interpretation - 24th International Conference, VMCAI 2023, Boston, MA, USA,
January16-17,2023,Proceedings (LectureNotesinComputerScience,Vol.13881) .
Springer, 91–105. https://doi.org/10.1007/978-3-031-24950-1_5
[8]Tim Blazytko,Moritz Contag,Cornelius Aschermann,and Thorsten Holz. 2017.
Syntia: Synthesizing the Semantics of Obfuscated Code. In 26th USENIX Security
Symposium, USENIX Security 2017, Vancouver, BC, Canada, August 16-18, 2017 .
USENIXAssociation, 643–659.
[9]Dmitry Blotsky, Federico Mora, Murphy Berzish, Yunhui Zheng, Ifaz Kabir, and
VijayGanesh.2018. StringFuzz:AFuzzerforStringSolvers.In ComputerAided
Veriﬁcation - 30th International Conference, CAV 2018, Oxford, UK, July 14-17,
2018, Proceedings, Part II (Lecture Notes in Computer Science, Vol. 10982) . Springer,
45–51.https://doi.org/10.1007/978-3-319-96142-2_6
[10]FraserBrown,JohnRenner,AndresNötzli,SorinLerner,HovavShacham,and
Deian Stefan. 2020. Towards a veriﬁed range analysis for JavaScript JITs. In
Proceedingsofthe41stACM SIGPLANInternationalConference onProgramming
LanguageDesignandImplementation,PLDI2020,London,UK,June15-20,2020 .
ACM,135–150. https://doi.org/10.1145/3385412.3385968
[11]AlexandraBugariuandPeterMüller.2020. Automaticallytestingstringsolvers.In
ICSE’20:42ndInternationalConferenceonSoftwareEngineering,Seoul,SouthKorea,
27June-19July,2020 .ACM,1459–1470. https://doi.org/10.1145/3377811.3380398
[12]CristianCadar,DanielDunbar,andDawsonR.Engler.2008.KLEE:Unassistedand
Automatic Generation ofHigh-Coverage Tests for ComplexSystems Programs.
In8th USENIX Symposium on Operating Systems Design and Implementation,
OSDI 2008, December 8-10, 2008, San Diego, California, USA, Proceedings . USENIX
Association, 209–224.
[13]JunjieChen,WenxiangHu,LingmingZhang,DanHao,SarfrazKhurshid,andLu
Zhang. 2018. Learning to Accelerate SymbolicExecution via Code Transforma-
tion. In32nd European Conference on Object-Oriented Programming, ECOOP 2018,
July 16-21, 2018, Amsterdam, The Netherlands (LIPIcs, Vol. 109) . Schloss Dagstuhl -
Leibniz-ZentrumfürInformatik,6:1–6:27. https://doi.org/10.4230/LIPIcs.ECOOP.
2018.6
[14]Alessandro Cimatti, Alberto Griggio, Bastiaan Joost Schaafsma, and Roberto
Sebastiani. 2013. The MathSAT5 SMT Solver. In Tools and Algorithms for the
Construction and Analysis of Systems - 19th International Conference, TACAS 2013,
Rome, Italy, March 16-24, 2013. Proceedings (Lecture Notes in Computer Science,
Vol.7795) . Springer, 93–107. https://doi.org/10.1007/978-3-642-36742-7_7
[15]Leonardo Mendonça de Moura and Nikolaj S. Bjørner. 2008. Z3: An Eﬃcient
SMT Solver. In Tools and Algorithms for the Construction and Analysis of Systems,
14th International Conference, TACAS 2008, Budapest, Hungary, March 29-April 6,
2008.Proceedings (LectureNotesinComputerScience,Vol.4963) .Springer,337–340.
https://doi.org/10.1007/978-3-540-78800-3_24
[16]DavidDéharbe,PascalFontaine,StephanMerz,andBrunoWoltzenlogelPaleo.
2011. ExploitingSymmetryinSMTProblems.In AutomatedDeduction-CADE-23
-23rdInternationalConferenceonAutomatedDeduction,Wroclaw,Poland,July
31 - August 5, 2011. Proceedings (Lecture Notes in Computer Science, Vol. 6803) .
Springer, 222–236. https://doi.org/10.1007/978-3-642-22438-6_18[17]Isil Dillig, Thomas Dillig, and Alex Aiken. 2010. Small Formulas for Large
Programs:On-LineConstraintSimpliﬁcationinScalableStaticAnalysis.In Static
Analysis - 17th International Symposium, SAS 2010, Perpignan, France, September
14-16,2010.Proceedings (LectureNotesinComputerScience,Vol.6337) .Springer,
236–252. https://doi.org/10.1007/978-3-642-15769-1_15
[18]ShiyuDong,OswaldoOlivo,LingmingZhang,andSarfrazKhurshid.2015. Study-
ingtheinﬂuenceofstandardcompileroptimizationsonsymbolicexecution.In
26thIEEEInternationalSymposiumonSoftwareReliabilityEngineering,ISSRE2015,
Gaithersbury, MD, USA, November 2-5, 2015 . IEEE Computer Society, 205–215.
https://doi.org/10.1109/ISSRE.2015.7381814
[19]BrunoDutertre.2014. Yices2.2.In ComputerAidedVeriﬁcation-26thInternational
Conference,CAV2014,Vienna,Austria,July18-22,2014.Proceedings (LectureNotes
in Computer Science, Vol. 8559) . Springer, 737–744. https://doi.org/10.1007/978-3-
319-08867-9_49
[20]SebastianKringsandMichaelLeuschel.2016. SMTSolversforValidationofBand
Event-BModels.In IntegratedFormalMethods-12thInternationalConference,IFM
2016,Reykjavik,Iceland,June1-5,2016,Proceedings (LectureNotesinComputer
Science,Vol.9681) .Springer,361–375. https://doi.org/10.1007/978-3-319-33693-
0_23
[21]Daniel Kroening and Ofer Strichman. 2008. Decision Procedures - An Algorithmic
PointofView . Springer. https://doi.org/10.1007/978-3-540-74105-3
[22]Daniel Larraz, Kaustubh Nimkar, Albert Oliveras, Enric Rodríguez-Carbonell,
and Albert Rubio. 2014. Proving Non-termination Using Max-SMT. In Computer
Aided Veriﬁcation - 26th International Conference, CAV 2014, Vienna, Austria, July
18-22,2014.Proceedings (LectureNotesinComputerScience,Vol.8559) .Springer,
779–796. https://doi.org/10.1007/978-3-319-08867-9_52
[23]Juneyoung Lee, Dongjoo Kim, Chung-Kil Hur, and Nuno P. Lopes. 2021. An
SMTEncodingofLLVM’sMemoryModelforBoundedTranslationValidation.
InComputer Aided Veriﬁcation - 33rd International Conference, CAV 2021, Virtual
Event, July 20-23, 2021, Proceedings, Part II (Lecture Notes in Computer Science,
Vol.12760) . Springer, 752–776. https://doi.org/10.1007/978-3-030-81688-9_35
[24]Guodong Li and Konrad Slind. 2008. Trusted Source Translation of a Total
Function Language. In Tools and Algorithms for the Construction and Analysis of
Systems,14thInternationalConference,TACAS2008,Budapest,Hungary,March29-
April 6, 2008. Proceedings (Lecture Notes in Computer Science, Vol. 4963) . Springer,
471–485. https://doi.org/10.1007/978-3-540-78800-3_37
[25]Daniel Liew, Daniel Schemmel, Cristian Cadar, Alastair F. Donaldson, Rafael
Zähl,andKlausWehrle.2017. Floating-pointsymbolicexecution:acasestudy
in n-version programming. In Proceedings of the 32nd IEEE/ACM International
ConferenceonAutomatedSoftwareEngineering,ASE2017,Urbana,IL,USA,October
30-November03,2017 .IEEEComputerSociety,601–612. https://doi.org/10.1109/
ASE.2017.8115670
[26]Nuno P. Lopes, Juneyoung Lee, Chung-Kil Hur, Zhengyang Liu, and John
Regehr. 2021. Alive2: bounded translation validation for LLVM. In PLDI ’21:
42nd ACM SIGPLAN International Conference on Programming Language De-
signandImplementation,VirtualEvent,Canada,June20-25,2021 .ACM,65–79.
https://doi.org/10.1145/3453483.3454030
[27]NunoP.Lopes,DavidMenendez,SantoshNagarakatte,andJohnRegehr.2015.
Provably correct peephole optimizations with alive. In Proceedings of the 36th
ACMSIGPLANConferenceonProgrammingLanguageDesignandImplementation,
Portland,OR,USA,June15-17,2015 .ACM,22–32. https://doi.org/10.1145/2737924.
2737965
[28] Muhammad NumairMansur, Maria Christakis, Valentin Wüstholz, and Fuyuan
Zhang. 2020. Detecting critical bugs in SMTsolvers usingblackbox mutational
fuzzing. In ESEC/FSE ’20: 28th ACM Joint European Software Engineering Confer-
enceandSymposiumontheFoundationsofSoftwareEngineering,VirtualEvent,
USA, November 8-13, 2020 . ACM, 701–712. https://doi.org/10.1145/3368089.
3409763
[29]DavidMenendez,SantoshNagarakatte,andAartiGupta.2016. Alive-FP:Auto-
mated Veriﬁcation of Floating Point Based Peephole Optimizations in LLVM. In
Static Analysis - 23rd International Symposium, SAS 2016, Edinburgh, UK, Septem-
ber8-10,2016,Proceedings (LectureNotesinComputerScience,Vol.9837) .Springer,
317–337. https://doi.org/10.1007/978-3-662-53413-7_16
[30]Sujit Kumar Muduli and Subhajit Roy. 2022. Satisﬁability modulo fuzzing: a
synergistic combination of SMT solving and fuzzing. Proc. ACM Program. Lang.
6,OOPSLA2 (2022), 1236–1263. https://doi.org/10.1145/3563332
[31]Derek Gordon Murray, Michael Isard, and Yuan Yu. 2011. Steno: automatic
optimization of declarative queries. In Proceedings of the 32nd ACM SIGPLAN
ConferenceonProgrammingLanguageDesignandImplementation,PLDI2011,San
Jose,CA,USA,June4-8,2011 .ACM,121–131. https://doi.org/10.1145/1993498.
1993513
[32]AinaNiemetzandMathiasPreiner.2020. BitwuzlaattheSMT-COMP2020. CoRR
abs/2006.01621 (2020). arXiv: 2006.01621
[33]Aina Niemetz, Mathias Preiner, Andrew Reynolds, Clark W. Barrett, and Cesare
Tinelli.2021. Syntax-GuidedQuantiﬁerInstantiation.In ToolsandAlgorithmsfor
theConstructionand Analysis ofSystems-27thInternationalConference,TACAS
2021,LuxembourgCity,Luxembourg,March27-April1,2021,Proceedings,Part
II (Lecture Notes in Computer Science, Vol. 12652) . Springer, 145–163. https:
1188SpeedingupSMTSolvingviaCompilerOptimization ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA
//doi.org/10.1007/978-3-030-72013-1_8
[34]AndresNötzliandFraserBrown.2016. LifeJacket:verifyingpreciseﬂoating-point
optimizations in LLVM. (2016), 24–29. https://doi.org/10.1145/2931021.2931024
[35]InstituteofElectricalandElectronicsEngineers.2019. IEEEStandardforFloating-
PointArithmetic. IEEE Std754-2019(Revision ofIEEE 754-2008) (2019), 1–84.
[36]Mathias Preiner, Aina Niemetz, and Armin Biere. 2017. Counterexample-Guided
Model Synthesis. In Tools and Algorithms for the Construction and Analysis of
Systems-23rdInternationalConference,TACAS2017,Uppsala,Sweden,April22-29,
2017, Proceedings, PartI (Lecture Notes in Computer Science, Vol. 10205) .264–280.
https://doi.org/10.1007/978-3-662-54577-5_15
[37]David A. Ramos and Dawson R. Engler. 2015. Under-Constrained Symbolic
Execution: Correctness Checking for Real Code. In 24th USENIX Security Sympo-
sium, USENIX Security 15, Washington, D.C., USA, August 12-14, 2015 . USENIX
Association, 49–64.
[38]Andrew Reynolds, Andres Nötzli, Clark W. Barrett, and Cesare Tinelli. 2019.
High-Level Abstractions for Simplifying Extended String Constraints in SMT. In
ComputerAidedVeriﬁcation-31stInternationalConference,CAV2019,NewYork
City, NY, USA, July 15-18, 2019, Proceedings, Part II (Lecture Notes in Computer
Science,Vol.11562) .Springer,23–42. https://doi.org/10.1007/978-3-030-25543-5_2
[39]AndrewReynolds,MaverickWoo,ClarkW.Barrett,DavidBrumley,TianyiLiang,
and Cesare Tinelli. 2017. Scaling Up DPLL(T) String Solvers Using Context-
Dependent Simpliﬁcation. In Computer Aided Veriﬁcation - 29th International
Conference, CAV 2017, Heidelberg, Germany, July 24-28, 2017, Proceedings, Part
II (Lecture Notes in Computer Science, Vol. 10427) . Springer, 453–474. https:
//doi.org/10.1007/978-3-319-63390-9_24
[40]Joshua Schmidt and Michael Leuschel. 2022. SMT solving for the validation of B
andEvent-Bmodels. Int.J.Softw.ToolsTechnol.Transf. 24,6(2022),1043–1077.
https://doi.org/10.1007/s10009-022-00682-y[41]David Tarditi, Peter Lee, and Anurag Acharya. 1992. No Assembly Required:
CompilingStandardMLtoC. LOPLAS1,2(1992),161–177. https://doi.org/10.
1145/151333.151343
[42]David A. Terei and Manuel M. T. Chakravarty. 2010. An llVM backend for GHC.
InProceedings of the 3rd ACM SIGPLAN Symposium on Haskell, Haskell 2010,
Baltimore, MD, USA, 30September 2010 . ACM, 109–120. https://doi.org/10.1145/
1863523.1863538
[43]Dominik Winterer, Chengyu Zhang, and Zhendong Su. 2020. Validating SMT
solversviasemanticfusion.In Proceedingsofthe41stACMSIGPLANInternational
Conference on Programming Language Design and Implementation, PLDI 2020,
London,UK,June15-20,2020 .ACM,718–730. https://doi.org/10.1145/3385412.
3385985
[44]ChristophM.Wintersteiger,YoussefHamadi,andLeonardoMendonçadeMoura.
2009. A Concurrent Portfolio Approach to SMT Solving. In Computer Aided
Veriﬁcation,21stInternationalConference,CAV2009,Grenoble,France,June26-
July 2,2009. Proceedings (LectureNotes inComputerScience,Vol.5643) .Springer,
715–720. https://doi.org/10.1007/978-3-642-02658-4_60
[45]DongpengXu,BinbinLiu,WeijieFeng,JiangMing,QilongZheng,JingLi,and
QiaoyanYu.2021.BoostingSMTsolverperformanceonmixed-bitwise-arithmetic
expressions. In PLDI ’21: 42nd ACM SIGPLAN International Conference on Pro-
gramming Language Design and Implementation, Virtual Event, Canada, June
20-25, 2021 . ACM,651–664. https://doi.org/10.1145/3453483.3454068
[46]Peisen Yao, Heqing Huang, Wensheng Tang, Qingkai Shi, Rongxin Wu, and
CharlesZhang.2021. SkeletalapproximationenumerationforSMTsolvertesting.
InESEC/FSE’21:29thACMJointEuropeanSoftwareEngineeringConference and
SymposiumontheFoundationsofSoftwareEngineering,Athens,Greece,August
23-28, 2021 . ACM,1141–1153. https://doi.org/10.1145/3468264.3468540
Received 2023-02-02; accepted 2023-07-27
1189