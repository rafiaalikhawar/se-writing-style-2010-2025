DeepLocalize: Fault Localization for Deep Neural
Networks
Mohammad Wardat
Department of Computer Science
Iowa State University
2434 Osborn Dr
Ames, IA, 50011, USA
wardat@iastate.eduWei Le
Department of Computer Science
Iowa State University
2434 Osborn Dr
Ames, IA, 50011, USA
weile@iastate.eduHridesh Rajan
Department of Computer Science
Iowa State University
2434 Osborn Dr
Ames, IA, 50011, USA
hridesh@iastate.edu
Abstract ‚Äî Deep neural networks (DNNs) are becoming an
integral part of most software systems. Previous work has
shown that DNNs have bugs. Unfortunately, existing debugging
techniques don‚Äôt support localizing DNN bugs because of the
lack of understanding of model behaviors. The entire DNN model
appears as a black box. To address these problems, we propose
an approach and a tool that automatically determines whether
the model is buggy or not, and identiÔ¨Åes the root causes for
DNN errors. Our key insight is that historic trends in values
propagated between layers can be analyzed to identify faults,
and also localize faults. To that end, we Ô¨Årst enable dynamic
analysis of deep learning applications: by converting it into
an imperative representation and alternatively using a callback
mechanism. Both mechanisms allows us to insert probes that
enable dynamic analysis over the traces produced by the DNN
while it is being trained on the training data. We then conduct
dynamic analysis over the traces to identify the faulty layer or
hyperparameter that causes the error. We propose an algorithm
for identifying root causes by capturing any numerical error and
monitoring the model during training and Ô¨Ånding the relevance of
every layer/parameter on the DNN outcome. We have collected a
benchmark containing 40 buggy models and patches that contain
real errors in deep learning applications from Stack OverÔ¨Çow
and GitHub . Our benchmark can be used to evaluate automated
debugging tools and repair techniques. We have evaluated our
approach using this DNN bug-and-patch benchmark, and the
results showed that our approach is much more effective than
the existing debugging approach used in the state-of-the-practice
Keras library. For 34/40 cases, our approach was able to detect
faults whereas the best debugging approach provided by Keras
detected 32/40 faults. Our approach was able to localize 21/40
bugs whereas Keras did not localize any faults.
Index Terms ‚ÄîDeep Neural Networks, Fault Location, Debug-
ging, Program Analysis, Deep learning bugs
I. I NTRODUCTION
Deep neural networks are a class of machine learning
algorithms that have gained signiÔ¨Åcant popularity in recent
years due to their remarkable success in tasks that defy
traditional algorithm techniques. A deep neural network can
be thought of as a graph where nodes, called neurons , are
functions with adjustable weights. The neurons of a DNN are
organized in layers and edges feed output from a neuron to
neurons in the next layer, and eventually to the last layer called
the output layer. During the training step, each training input
is passed through the network to produce output. This outputis compared to the expected output. The difference between
the actual output and the expected output, measured using a
function called the loss function , is then used to adjust the
weights of the neurons in the layers using a process called back
propagation . DNNs are utilized in various software systems
to make decisions. Thus, software engineering for DNNs has
become essential.
To aid integration of the DNN in software systems, a num-
ber of developers have produced industrial-strength libraries
and frameworks such as TensorFlow [1], Cafe [2], MXNet
[3], PyTorch [4], Theano [5] and Keras [6] to assist the
programmers in designing reliable deep learning applications.
Recent work has shown that applications that use DNN have
bugs [7]‚Äì[9]. Same group of researchers have also studied
repair strategies for DNN [10]. Zhang et al. [8] describe the
challenges and limitations in detecting and localizing the bugs
in the DNN model, and indicate that current approaches are not
effective to examine the state of the model at some point, like
the regular programs. Islam et al. observe that DNN bug Ô¨Åx
patterns are distinctive compared to traditional bug Ô¨Åx patterns,
and that DNN bug localization is among the major challenges
faced by developers when Ô¨Åxing bugs [10].
Despite the growing number of software debugging tech-
niques such as automated bug repair [11], [12], fault localiza-
tion [13], [14], delta debugging [15], and slicing [16], these
techniques are still not applicable to identify the bugs in the
DNN models and identify the faulty statements that cause the
problem at a particular layer in the model. Regular software
programs and the DNN models are fundamentally different
with respect to fault and fault detection. For example, regular
software programs are tested by comparing the actual output
and the expected output. If actual output doesn‚Äôt match the
expected output, then we consider the program has a bug.
On the other hand, the DNN-based software has a complex
structure, and it is learning from a training dataset. If the DNN
produces incorrect classiÔ¨Åcation during training, we call it fail-
ure case, it is not necessarily that DNN contains a bug, because
a DNN model cannot guarantee 100% correct classiÔ¨Åcations.
Furthermore, the logic of a regular program is represented
in terms of control Ô¨Çow, while DNN programs use weights
between neurons and different kinds of activation functions
2512021 IEEE/ACM 43rd International Conference on Software Engineering (ICSE)
1558-1225/21/$31.00 ¬©2021 IEEE
DOI 10.1109/ICSE43902.2021.00034
for similar purposes. These differences make debugging and
testing of software that deploys DNNs challenging.
Traditional practices for debugging uses aides such as print
statements, breakpoints, and tracing the failing test case. These
manual debugging processes take a long time and effort from
developers [17]. Researchers have proposed several automated
fault localization techniques [13], [18], [19]. These techniques
are used to locate the root causes and understand the faulty
states. Unfortunately, current automated fault localization tech-
niques cannot be applied directly to DNN since existing
techniques are not able to identify plausible and distinct root
causes for unexpected behavior (known as failure) in DNNs.
To overcome these challenges, this work introduces a white
box based fault localization technique for DNNs. Our approach
requires the source code of the DNN model and the training
data. Given the source code, our approach enables dynamic
trace collection for DNN. We propose two techniques. The
Ô¨Årst technique, inspired by [20], translates the code into an
intermediate form which we call imperative representation
of the DNN . The purpose of the imperative representation is
to make certain (ensure) that internal states of the DNN are
observable, thus our method uses a white box approach . This
conversion to an imperative representation allows us to insert
probes that enable dynamic analysis over the traces produced
by the DNN while it is being trained on the training data. The
second technique uses a novel callback mechanism to insert
probes that also achieve the same purpose. We then conduct
dynamic analysis over the traces to identify the faulty layer
or hyperparameter that causes the error. We also propose an
algorithm to identify root causes by capturing any numerical
error and monitoring the model during training and Ô¨Ånding the
relevance of every layer/parameter on the DNN outcome.
We have implemented our approach as an extension of the
widely used Keras library for deep learning. To evaluate, we
have collected a benchmark containing 40 buggy models and
patches that contain real errors in deep learning application
from Stack OverÔ¨Çow , and GitHub . Our benchmark can be used
to evaluate automated debugging tools and repair techniques.
We compare our approach with three built-in mechanisms
for debugging in the Keras library, the state-of-the-art in
DNN libraries. These mechanisms were TerminateOnNaN() ,
EarlyStopping (‚Äôloss‚Äô) , and EarlyStopping (‚Äôaccuracy‚Äô) . We
have evaluated our approach using this DNN bug-and-patch
benchmark, and the result shows that our approach is much
more effective than the existing debugging approach used
in the state-of-the-practice Keras library. For 34/40 cases,
our approach was able to detect faults whereas the best
debugging approach provided by Keras detected 32/40 faults.
Our approach was able to localize 21/40 bugs whereas Keras
did not localize any faults. In summary, this paper makes the
following contributions:
We propose the Ô¨Årst fault localization approach for
DNNs including callback and translation mechanisms for
collecting dynamic traces and a localization algorithm .
We have built a DNN bug-and-patch benchmark with 40
different types of buggy models from Stack OverÔ¨Çow andGitHub . This benchmark serves as the ground truth to
evaluate our approach. We also hope it can serve other
researchers to validate their debugging and repair tools.
This benchmark is available from GitHub [21].
Our results show that our approach can effectively and
efÔ¨Åciently identify 34 out of 40 buggy model and deter-
mine the root causes for 21 out of 40 buggy model.
Outline: ¬ßII motivates our approach. ¬ßIII presents our
dynamic trace collection, faulty detection and localization
algorithms. ¬ßIV presents evaluation. ¬ßV discusses the threats
to validity, ¬ßVI discusses related works and ¬ßVII concludes.
II. A M OTIVATING EXAMPLE
Listing 1 shows a simple example from Stack OverÔ¨Çow [22]
to motivate our work. In this example, the developer is
constructing a sequential model at line 1, adding a dense input
layer at lines 2-3, adding a dense hidden layer at lines 4-5,
compiling the model to convert it to a graphical form on line
6, and training this model on line 7. A dense layer is a layer
in a DNN where each neuron is connected to neurons in the
next layer. This DNN did not learn during training and in
the post, the developer asked why the model achieved low
accuracy. This DNN has a two problems. First, it handles a
classiÔ¨Åcation problem, and thus categorical_crossen-
tropy should be used as a loss function at line 6 instead
ofmean_squared_error . Second, the user has not added
activation functions for the Ô¨Årst two layers at lines 2 and 4.
Listing 1: DNN is not learning [22]
1model =Sequential ()
2layer1 =Dense (30, input_shape =input_shape ,
kernel_initializer =RandomNormal (stddev =1)
,bias_initializer =RandomNormal (stddev =1)
)
3model .add(layer1 )
4layer2 =Dense (10, kernel_initializer =
RandomNormal (stddev =1), bias_initializer =
RandomNormal (stddev =1))
5model .add(layer2 )
6model .compile (optimizer =SGD(lr=3.0), loss =‚Äô
mean_squared_error‚Äô ,metrics =[‚Äôaccuracy‚Äô
])
7model .fit(x_train ,y_train ,batch_size =10,
epochs =30, verbose =2)
Keras provides a set of callback methods [23] to give the
developers information about internal status of the training
process. SpeciÔ¨Åcally, we can use TerminateOnNaN() to
monitor the loss and terminate the training when the loss
becomes NaN. We can use EarlyStopping() to moni-
tor the loss or accuracy and stop if there is no improve-
ment. We can pass a callback method as a parameter to
thefit() method. For Listing 1, when using Termina-
teOnNaN() ,EarlyStopping(‚Äôloss‚Äô) ,EarlyStop-
ping(‚Äôaccuracy‚Äô) , and the union of the three Keras
methods, the training was terminated after 1.20, 12.21, 34.90
and 1.16 seconds respectively. Once the training is stopped,
Keras prints the epoch and the iteration number. Unfortunately,
such information cannot answer the developer‚Äôs question and
252Model Preparation Dynamic Analysis 
Numerical 
Error 
Yes Check 
No
Update No
Model 
Stop 
Learning 
Deep Learning 
Application Feed-Forward  
BackPropagation 
  Weight Œî Weight Loss 
Accuracy Before 
Activation After 
Activation Statistical Analysis 
Mean 
Std Dev 
YesInstrumentation 
Imperative 
Program 
Callback 
APITranslate 
AddFig. 1: An Overview of DeepLocalize. Left component shows two alternatives (callback and translation) for preparing models
to collect dynamic traces. Middle component collects and analyzes these traces. Right component detects/localizes bugs.
indicate which layer or hyperparameter prevented the model
from learning.
Our approach reports that the program has a bug after 0.14
seconds using our tool and 2.14 seconds using our callback
function. In addition, we report that the bug is located in the
back propagation stage of layer 2 at line 4. Therefore, the
message gives the developer hint that the issue in the parameter
of layer 2, since the description of the message indicates the
stage of the problem, the developer can quickly determine
previous calculation that causes the problem, which is the loss
function in our example. Compared to the existing methods
inKeras , our fault localization uses less time and provides a
report stating the layer that the bug is located at.
III. A PPROACH
A. An Overview
Figure 1 provides an overview of our work. In the Ô¨Årst step,
we prepare the DNN model to collect dynamic traces. We
propose two mechanism for this. Our Ô¨Årst approach translates
the deep learning program into an imperative program [20],
[24]. Probes are inserted in this imperative program to capture
and save model variables such as weights, learning rate gra-
dients during training. Our second approach uses a callback
mechanism, and passes a specialized callback method as a
parameter during model training (to the fit() method). This
custom callback function allows the developers to capture and
save model variables. We record the key values during both
the feed-forward and backward propagation phases. During the
training, an online statistical analysis is performed to compare
the status of the program with the error conditions we deÔ¨Åned.
Finally, we report if the program contains a bug, and in which
layer and phases the bug exists that prevented learning.
B. Model Preparation
Directly analyzing a deep learning program, e.g. one shown
in Listing 1 is hard, as the DNN libraries provide blackbox
APIs and it is hard to trace important values during training.To use our approach, the developer either write extra code to
instrument DNN training inside fit() function or rewrite
their code into an imperative form. For our second approach,
we identiÔ¨Åed a list of the Keras library APIs that are important
for training and implemented models/simpliÔ¨Åed versions of
these API calls, following the machine learning literature [25]‚Äì
[27] and the Keras documentation [28]. We inserted the probes
to these library models so that the analysis can observe the
internal behaviors of DNNs during training.
The callback-based approach of dynamic trace
collection is implemented by overriding the
keras.callbacks.Callback class. Since our work is
focusing on monitoring during the training phase, we override
the method called ( on_train_batch_end(self,
batch, logs=None) ). This overridden method invokes
Algorithm 1 after each batch of training. To use this method,
the developer needs to pass this custom callback function as
a parameter to the fit() function.
Second imperative approach, as shown in Table I on the left,
to build a training model, a DNN program typically starts with
creating a sequential model (line 4), then add all layers (lines
5‚Äì11) and optimizations (line 13), and Ô¨Ånally call compile
andfit at lines 14‚Äì15. On the right, we show the imperative
programs using our library models. First, lines 1, 2, 7 and
10 are not changed. Second, lines 5, 8, and 11 show the
conversions for the Dense layer. In our code, we added a name
for the layers, e.g., see name = ‚ÄùFC1‚Äù so that we can report in
which layer the fault is located. We inserted instrumentation
in the Ô¨Åt function (line 15) to observe the model variables.
Currently, our translation tool supports the Dense ,
Dropout ,Maxpooling ,Convolution ,BatchNor-
malization , and Padding layers. Also, it supports popu-
lar optimization methods, losses, and activation functions. The
translation from a DNN program to the program that uses our
library models is currently done manually. The Keras library
is being rapidly evolved resulting in a large number of releases
[10]. Due to the library versioning and the frequently changing
API signatures, it is hard for our tool to remain compatible
253TABLE I: Translation from Keras Code to an Imperative program
No Keras Code Imperati ve Program
1batch size= 1 batch size= 1
2nbepoch = 3 nbepoch = 3
3 +lr = 0.001
4model = Sequential() myModel = mySequential()
5-model.add(Dense(units=50, activation=‚Äôrelu‚Äô, input dim=128)) +myModel.insert(myDense(num inputs=128, num outputs=50, lrrate=lr , name=‚ÄôFC1‚Äô))
6 +myModel.insert(ReLu())
7model.add(Dropout(0.2)) myModel.insert(myDropout(0.2))
8-model.add(Dense(units=50, activation=‚Äôrelu‚Äô)) +myModel.insert(myDense(num inputs=50, num outputs=50, lrrate=lr , name=‚ÄôFC2‚Äô))
9 +myModel.insert(ReLu())
10 model.add(Dropout(0.2)) myModel.insert(myDropout(0.2))
11 -model.add(Dense(1,activation =‚Äôsoftmax‚Äô)) +myModel.insert(myDense(num inputs =50, num outputs =1, lr rate=lr, name=‚ÄôFC3‚Äô))
12 +myModel.insert(Softmax())
13 -Adam = optimizers.Adam()
14 -model.compile(loss =‚Äôbinary crossentrop y‚Äô, optimizer =Adam, metrics=[‚Äôacc‚Äô]) +myModel.myCompile(loss=‚Äôbinary crossentrop y‚Äô, optimizer=‚ÄôAdam‚Äô, metrics=[‚Äôacc‚Äô])
15 -model.Ô¨Åt(X train, Ytrain, batch size=batch size, nbepoch=3, verbose=1, validation data=(X -
test, Ytest))+myModel.Ô¨Åt instrument(X train, Ytrain, batch size=batch size, epoch=3)
16 -model.evaluate(X test, Ytest, verbose =1) +myModel.myEvaluate(X test, Ytest, 200)
This table is showing all of the changes to translate from Keras code to Our tool code. The color in each row indicates the change
type: Green + added a new line, Red - removed an existing line.
with the Keras library.
C. Instrumentation
The training of DNN has two phases: feedforward and
backpropagation. In the feedforward stage, we observe and
monitor: (1) the training data including both input and label;
(2) the results after applying forward function; (3) the results
after applying the activation function; (4) the loss value and (5)
the accuracy. All values are collected in each iteration during
training.
The second stage is the backpropagation, and it is used
to adjust the weight based on the errors obtained from the
feedforward stage. Backpropagation uses the gradient descent
method to update the weights and minimize the errors. It is
started from the output layer, and the result of the output
layer is reused to compute the gradient for the previous layer
until it reaches the input layer. Different optimizations can be
applied during backpropagation. In the backpropagation stage,
we can observe and monitor: (1) the update of weights, (2)
the update of bias values, and weights from applying the
gradient descent for each layer.
The instrumentation is inserted in the fit() function we
implemented for modeling the Keras fit() function. It is
executed automatically when the DNN program runs during
training.
D. Statistical Analysis to Detect Suspect Behavior
Next, we discuss our approach for statistical analysis to
detect suspect behavior of the DNN during training. We
analyze three variables: the learning rate, the input data, and
activation/loss functions.
1) Incorrect learning rate: Backpropagation is important
to Ô¨Åne-tune the weights based on the loss value obtained
from the loss function. The learning rate has an effect on the
weight updates during the backpropagation process. During
the backpropagation process, the learning library computes
gradient descent iteratively. Our key insight is that the mean
and standard deviation of the weights in the correct model are
continuously changing during the training process. In contrast,the mean and standard deviation of the weights in the buggy
model are constant. If there is a problem in the learning
rate, we can detect it from the output of the gradient for the
output layer. Figure 2 and Figure 3 show an example of this
behavior. In Figure 2 the weight varies as it should in a correct
model, whereas in Figure 3 the weight is constant indicating
a potential bug. To utilize this insight, we compute the mean
and the standard deviation for the output of the gradient as
well as the weight parameter at each layer.
2) Incorrect input data: In some cases, the training data are
not properly normalized. For example, in the MNIST model,
the pixel should be in the range [-1, 1] and not [0, 255]. Also,
training data may have NaN value, and developers forget to
invoke the assert function to check if there is an NaN or not. In
the forward stage, we retrieve the output before/after applying
the activation function for each year. We then compute the
mean and standard deviation for the output at each layer. We
will check if the output of the Ô¨Årst layer after/before applying
activation has numerical error such as NaN orInf. Our second
approach for detecting this kind of error is to calculate how
frequent the mean of the output for the Ô¨Årst layer is equal
to zero. Once we observe abnormal values, we will report in
which layer and whether it is before or after activation function
that the error occurs.
3) Incorrect activation/loss functions: After Ô¨Ånishing the
forward stage, we compute loss and accuracy. There are two
indicators that the model has a problem. First, if one of the two
metrics has a numerical error like inf orNaN. Second, the
loss starts increasing instead, or the accuracy starts decreasing
after certain iterations.
E. DNN Fault Localization Algorithm
Algorithm 1 presents our DNN fault localization algorithm.
At its core, it augments the DNN learning algorithm with anal-
ysis and error checking inserted during learning. It serves three
purposes: (1) determining whether the deep learning program
contains a bug; (2) reporting the fault location, in which layer
and which phases (feed forward and backward propagation),
the deep learning program has a bug; (3) reporting failure
254-0.05-0.04-0.03-0.02-0.0100.010.020.03
0 50 100 150 200 250 300 350 400 450 500Value
IterationWeights of Layer 2
MEAN STDFig. 2: Weight of correct model
-1.4-1.2-1-0.8-0.6-0.4-0.200.20.40.6
0 50 100150 200250300350400450500Value
IterationWeights of Layer 2
MEAN STD
Fig. 3: Weight of buggy model
information, in which iteration, the learning is stopped. It takes
as input the training data set (including input and labeling), the
translated imperative program, as well as the DNN parameters
(the batch size and the epoch). If the bug is found, the output is
a message including the fault location and failure information
for the bug.
At line 1, we deÔ¨Åne two lists to store the values of
loss and accuracy in each iteration. Line 2 represents how
many iterations we make through the whole training dataset.
During the training process, the training dataset is divided into
several smaller batches. For example, if the model has 2000
training examples divided into 500 batches, then the model
needs 4 iterations to complete one epoch. Line 3 shows the
division of the batch size. Lines 4-29 run for each batch in
the training dataset. At lines 5‚Äì11, the algorithm performs
dynamic analysis on the forward stage, and at lines 24‚Äì29, it
performs analysis on the backward stage. In our callback func-
tion, the override method on_train_batch_end(self,
batch, logs=None) will execute at the end of each batch,
and performs dynamic analysis on the forward/backward stage,
after retrieving the value of each layer before/after activation
function, loss, accuracy, updating weight and gradients.
1) Feedforward phase: At line 6, the algorithm computes
the output of a feed-forward layer before applying the activa-
tion function. At line 8, we compute the output after applying
the activation function. Then, we invoke ANA() procedure to
determine if the output contains a numerical error. As shown in
Table II, the message EBA indicates Error Before Activation,
EAA indicates Error After Activation, and L represents the
faulty layer number. At line 12, we compute the loss, andTABLE II: Abbreviation of Crash Statements
No Statement Abbreviation
1 Error Before Activation EBA
2 Error After Activation EAA
3 Error in Loss Function, ELF
4 Error in Accuracy Function EAF
5 Error Backward in Weight EBW
6 Error Backward in Weight EBDW
7 Model Does not Learn MDL
8 Correct Model CM
determine if there is any numerical error at line 13. As shown
int Table II, the ELF indicates Error in Loss Function. If the
error is not detected here, we save the loss value for each
iteration at line 14. At line 15, we compute the accuracy and
check if there is a numerical error from accuracy at Lines
16-18. If the error is not detected here, we save the accuracy
value during training at Line 19. At lines 20-22, the algorithm
checks if loss is not decreasing and accuracy is not increasing
value for a long time. In both cases, The algorithm computes
the slope to compare the loss/accuracy for current step with
the loss/accuracy at a step which is at least num steps behind
the current step. In this case, the algorithm reports a message
MDL to indicate that the model does not learn. Otherwise, the
training continues.
2) Backpropagation phase: During this stage, the algorithm
collects the weight and weight for each layer in each
iteration. At line 25, the Weight and Weight are the output
of a back-propagation. At line 26, the algorithm invokes the
ANA() procedure and pass weight to check if there is any
numerical error. The algorithm will print error message if there
is any error in the weight and determines which layer causes
this issue (Line 26). In the same way, at line 27, the algorithm
can determine if there is an issue in the weight in each layer
by invoke the ANA() procedure. If the procedure decide that
there is an issue in the weight, then the algorithm will return
message to indicate there is bug.
Finally, if there are no issues in the model, the algorithm
will terminate after Ô¨Ånishing training at line 32 and print this
message Correct Model (CM).
ANA() is invoked at lines 7, 9, 26 and 27 to determine if
the error occurs based on the current values obtained from the
instrumentation. When the DNN does not learn, there can be
the following symptoms: (1) the update for weight, weight
are incorrect, (2) the loss or accuracy is not measured on
the correct scale, and (3) the loss does not decease, and the
accuracy does not increase after the number of iterations. The
check is conducted in ANA() .
This procedure takes three parameters: input value, layer
number and location. Since ANA() is called at different
locations in the code, the location tracks whether the value
comes from feed-forward (FW), backward (BW) propagation,
or weight (WT). Line 2 deÔ¨Ånes a set of lists to store the mean
value from each location for each layer. Line 3 computes the
mean value for the input. At line 4, the procedure will check if
the mean reports NaN orinf. Also, the procedure will check
if the mean equal to zero at line 5; if yes, then we compute
255how frequent zero occurs for all values for each layer. If the
number of zeroes is greater than a threshold (line 7), the error
is detected and the procedure will return true.
At line 11, we store the mean value in the list. Finally, the
procedure will return the last N element from the list as slice to
check if the mean value for last N iterations is changed or not.
From Figure 2 and Figure 3, we observe the model continues
to learn if the mean value is changing in each iteration. This
procedure returns true if there is a numerical error; otherwise,
it return false.
Algorithm 1: DNN Fault Localization
input : Training data (input, label), batchsize, epochs,
imperative program
output: A message regarding fault location and failure
information
1LossList [];AccuList []
2fore 0toepoches do
3 fori 0toLength (input )Stepbatchsize do
4 X input [i];Y label[i]
5 forL 0toLength (Layers )do
6 V1 Layer [L]:Forward (X)
7 ifANA (V1; L; FW )then return EBA, L
8 V2=Layer [L]:Activation (V1)
9 ifANA (V2; L; AF )then return EAA, L
10 X V2
11 end
12 Loss ComputeLoss (V2; Y)
13 ifLoss is equal to NaN OR inf then return
ELF
14 LossList:append (Loss)
15 Accuracy ComputeAccuracy (V2; Y)
16 ifAccuracy is equal to NaN OR inf OR 0then
17 return EAF
18 end
19 AccuList:append (Accuracy )
20 ifNOTDecreasing (AccuList )&&
NOTIncreasing (LossList )then
21 return MDL
22 end
23 dy Y
24 forL Length (Layers )to0do
25 V3; W[L] Layer [L]:Backward (dy)
26 ifANA (V3; L; BW )then return EBDW, L
27 ifANA (W[L]; L; WT )then return EBW,
L
28 dy V3
29 end
30 end
31end
32return CM
IV. E VALUATION
In this section, we aim to answer the following research
questions:
RQ1 (Validation): Can our technique Ô¨Ånd bugs in deep
learning programs effectively?
RQ2 (Comparison): How effectively and how fast can
our technique localize the faults compared to existing
methodology in the Keras library?1Function ANA( input ,LayerNo ,Location ):
2 meanList [LayerNo; Location ] []
3 meanV alue math:mean (input )
4 ifmeanV alue is equal NaN OR inf then return
True
5 ifmeanV alue ==0then
6 FreqZero [LayerNo; Location ] + = 1
7 ifFreqZero [LayerNo; Location ]
threshold then
8 return True
9 end
10 end
11 meanList [LayerNo; Location ]:append (meanV alue )
12 slicing meanList [LayerNo; Location ][ N:]
13 ifAll(elem ==slicing [0]for elem in slicing )
then
14 return True
15 end
16 return False
TABLE III: Keras result VS Imperative result
Post # Epoch IterationKeras Our Tool
Runtime Result Runtime Result
[sec] Loss Accuracy [sec] Loss Accuracy
48385830 30 60000 489.67 NaN 0.10 1429.60 NaN 0.10
31556268 1000 1 5.58 0.50 0.50 20.99 0.50 0.50
50306988 5 200 1.41 0.71 0.50 0.17 0.69 0.50
48251943 17 500 5.40 0.37 ‚Äì 2.10 0.30 ‚Äì
38648195 20 48000 123.21 0.23 0.75 385.40 NaN 0.65
33969059 20 10000 129.85 349713063.30 ‚Äì 1272.30 260179130.95 ‚Äì
55328966 10 49999 104.95 2.30 0.10 8025.54 2.29 0.11
34311586 20 6 1.23 0.67 ‚Äì 0.11 0.50 ‚Äì
31880720 3 20000 181.30 7.67 0.50 529.29 16.12 0.50
39525358 150 13 3.15 0.67 0.62 5.16 0.67 0.61
48934338 1000 50 10.17 1358.22 0.00 28.58 787.75 0.00
47724077 50 32561 39.26 49.70 0.68 93.46 3.38 0.70
59278771 200 135 18.91 1.10 0.35 14.86 1.06 0.34
41372874 20 239 3.19 0.15 1.00 6.12 0.00 1.00
44066044 100 21 3.86 9.55 0.38 0.89 9.55 0.00
51930566 50 75 4.04 0.51 0.67 1.87 0.48 0.64
45442843 100 200 2.74 0.50 0.50 23.34 0.51 0.50
31627380 10 712 5.75 1.29 0.59 8.31 1.46 0.63
58609115 10 442 2.63 26169.69 0.09 13.10 4.05 0.02
50481178 50 200 11.82 0.02 0.99 6.13 0.01 0.98
RQ3 (Limitation): In which cases does our technique fail
to report the bug and localize the faults?
A. Experimental setup
1) Implementation: To perform our experiments and evalu-
ation, we implemented our techniques using Python and Keras .
Our translation-based tool supports the Dense ,Dropout ,
Maxpooling ,Convolution ,BatchNormalization ,
andPadding layers. Also, it supports popular optimization
methods, losses, and activation functions. We followed the
machine learning references [25]‚Äì[27] and used the Keras
documentation to implement simpliÔ¨Åed and instrumented ver-
sions of compile() ,sequential() andfit() func-
tion. Our callback-based tool supports all of the layers and
optimization methods supported by Keras .
We set threshold = 1/4 * No. Iteration and N= 50 at line 6
and 12 in ANA() function respectively for both our tool and
callback function. Based on our empirical experience, these
settings helped best in detecting bugs during training.
2562) Benchmark construction: We collected buggy models
from Stack OverÔ¨Çow posts and GitHub commits to construct
the benchmark. In Stack OverÔ¨Çow , we select the posts that
have a score5 and contains the buggy Keras code. We
used keywords "error" ,"bug" and synonyms to search for
posts. In the second step, we manually reviewed the retrieved
posts and removed all the posts that have partial code. In
the third step, we applied a second Ô¨Ålter by checking if the
post provided the training data or used the existing known
training data. In the last step, we studied all the answers
corresponding to the post ids in the Stack OverÔ¨Çow , using
the methodology in a prior work [10] that studied the bug Ô¨Åx
patterns for deep learning model. We take into consideration
the acceptable quality metric and choose the answer that has
the highest score. We analyzed each Q&A and derived for each
post the fault location and a patch to Ô¨Åx the bug. In total, we
obtained 30 posts.
We also mine the GitHub commits to collect buggy models.
The process consists of three steps. First, we search for all
Keras repository. After that, we mine all the commits whose
title contains keywords used in the Stack OverÔ¨Çow mining
process described above. Then, we take only the last version
Ô¨Åx, and manually check if the commits are related to structure
bug or not, from these commits, we derived the fault location
and a patch to Ô¨Åx the bug. In the last step, we checked if
the repository provided the training data. As a result, we
randomly select 11 executable programs with training dataset.
For instance, Figure 4 shows the patch we derived for the
Stack OverÔ¨Çow post # [22]. Table IV and V present our
benchmark together with total number of parameters, the line
of code, its loss and accuracy before and after Ô¨Åx. Our tool
and benchmarks are available for download [21].
Table III shows a comparison between the original Keras
code and our imperative code in terms of accuracy, losses
and runtime. Over all benchmarks, our imperative code has
comparable accuracies and losseses compared to Keras . The
small deviation is due to additional optimizations applied in
Keras code. In terms of runtime, our imperative code takes
around 5 times more execution time compared to Keras during
training and testing phases. The reason behind that is the extra
work done by our imperative code to identify bugs and their
root causes. Our code is also able to terminate early when a
bug is found and later in our results, we show that we can
detect bugs faster than Keras callback methods.
All the experiments are run on a computer with Intel(R)
Core (TM) i7-6500U, 2.5 GHz processor, and 16 GB of RAM
running the 64-bit Windows 8.1 operating system.
B. Results and Analysis
In Table VI and VII, the Ô¨Årst column reports the Stack
OverÔ¨Çow post # with the corresponding link, and GitHub
repository reference respectively. To compare our results with
the results generated from the Keras methods, we listed the
columns of Time, Epoch, Iteration, IB, and FL, representing
how long the approach takes to Ô¨Ånd the bug, at which
epoch and at which iteration the bug is reported, whether the
Fig. 4: (Patch/Fix) the changing to Ô¨Åx a DNN bug [22]
TABLE IV: The Benchmark, we show (Post #) post id from
Stack OverÔ¨Çow , parameters #, line of code, (Result Before Fix)
the loss and accuracy before applying patch, and (Result After
Fix) the loss and accuracy value after applying patch
Post # Total params LOCResult Before Fix Result After Fix
Loss Accuracy Loss Accuracy
48385830 23,860 60 NaN 0.10 0.15 0.96
44164749 6,931,610 49 0.38 0.89 0.20 0.92
31556268 17 39 0.25 0.50 0.00 1.00
50306988 12 45 0.70 0.50 0.67 1.00
48251943 17 30 0.37 ‚Äì 0.63 ‚Äì
38648195 903 36 0.22 0.41 1.3 0.65
33969059 23 63 72181941.16 ‚Äì 9766327.81 ‚Äì
55328966 655,200 52 2.30 0.10 0.85 0.80
34311586 19 29 0.67 ‚Äì 0.17 ‚Äì
31880720 9,051 46 7.67 0.50 0.00 1.00
39525358 91 34 0.67 0.62 0.31 1.00
39217567 216 43 0.25 0.50 0.08 0.97
48934338 1,661 37 1335.72 ‚Äì 341.09 ‚Äì
47724077 359 46 29.97 0.69 0.55 0.76
59325381 221,226 38 11023.33 0.10 0.03 0.99
59278771 35 43 1.10 0.35 0.39 0.83
52800582 2,701 41 11112.00 ‚Äì 0.00 ‚Äì
41372874 15 39 0.15 1.00 0.15 1.00
34673164 5,378 50 0.13 0.78 0.43 0.89
48221692 16 28 2311.60 ‚Äì 121.94 ‚Äì
50079585 1,212,513 75 9297.00 0.33 0.94 0.55
45337371 3,221 31 7.85 ‚Äì 0.69 ‚Äì
44066044 313 38 9.55 0.38 0.01 1.00
51930566 35 52 0.77 0.64 0.30 0.91
47352366 3,274,634 50 NaN 0.06 0.10 0.98
45442843 4 41 0.50 0.50 0.65 0.83
48594888 4,873,738 60 1.45 0.48 0.86 0.70
31627380 6,658 64 1.24 0.58 0.83 0.63
58609115 9,798 43 44539.79 0.10 0.07 0.99
50481178 4,241 43 0.02 0.99 0.02 1.00
TABLE V: The Benchmark, we show (GH jRef) the GitHub
repository reference the number of parameters, line of code
(LOC), (Result Before Fix) the loss and accuracy value before
applying patch, and (Result After Fix) the loss and accuracy
after applying patch
GH jRef Total params LOCResult Before Fix Result After Fix
Loss Accuracy Loss Accuracy
1j[29] 18989 79 0.39 0.90 0.38 0.90
2j[30] 367107 39 0.82 0.76 0.83 0.75
3j[31] 468980 72 0.72 0.16 0.00 0.75
4j[32] 34438 107 0.65 0.61 0.80 0.71
5j[33] 169431 73 0.30 0.91 0.46 0.86
6j[34] 221 16 0.48 0.78 0.29 0.88
7j[35] 1941 915 44.85 ‚Äì 44.75 ‚Äì
8j[36] 341 183 0.02 0.99 0.00 1.00
9j[37] 160305 40 0.28 0.92 0.18 0.94
10 j[38] 110627418 67 0.65 0.63 0.43 0.79
11 j[39] 9 30 1E-05 ‚Äì 1E-05 ‚Äì
257approach identiÔ¨Åes the bug correctly, and whether the approach
successfully reports the fault location of the bug, respectively.
Under IBandFL,Xmeans that the approach is successful, X
means it fails, and ‚Äì is not able to identify or fault the bug.
The results show that our tool is able to identify bugs
for 23 out of 29 buggy programs, and our callback func-
tion is able to identify bugs for 34 out of 40 buggy pro-
grams. In contrast, TerminateOnNaN() ,EarlyStop-
ping(‚Äôloss‚Äô) ,EarlyStopping(‚Äôaccuracy‚Äô) , and
the three Keras methods together are able to identify 2, 24,
28, and 32 out of 40 bugs respectively. This is mainly because
our technique used a wider spectrum of important runtime
values for analysis compared to the other three methods,
which only used one metric such as the loss, or accu-
racy. Also, EarlyStopping(‚Äôloss‚Äô) andEarlyStop-
ping(‚Äôaccuracy‚Äô) sometimes do not give a good indi-
cation that the model has a problem. For example, the deep
neural network may be stuck at a local minimum at some point
that has values that are close to the global minimum [40].
We failed to detect bugs for 7 out of 30 models using our
tool. Our tool is not able to identify the buggy model that
predicts a wrong label. In the program [41], the training data
are in the range [ 1;+1]. This model has an issue that
all the negative values are predicted to zeros, because the
developer used the ReLU activation function in the last layer
instead of activation functions that produce output in the same
range of output labels such as TanH.
In the program [42], fit_generator() instead of
fit() is used, which our technique has not yet supported.
fit_generator() is used to train the model on data
generated batch-by-batch [28]. This API is not yet supported
by our technique, we plan to cover and investigate other APIs
in our future work.
In the Stack OverÔ¨Çow post [43], the user asked about
the differences between two models, each one has different
input dimensions, both models are training correctly, but the
differences are in the performance. In this case, our tool will
not Ô¨Ånd any numerical error or misbehavior to detect the bug.
In our tool, we did not target problems such as: (1) lack of
dataset, (2) training dataset with distribution problems and (3)
incorrect number of epochs, batch sizes, the number of hidden
layers, and neural nodes in the layers. An example of these
problems can be found in programs [44], [45], these problems
make the model terminates training at an early stage, and our
tool will not detect the issue in the model.
We also compared our approach against three Keras meth-
ods in terms of fault localization, We found that none of
the three Keras approaches are able to determine the root
causes. Our tool is able to determine root causes for 19 out 29
programs, and our callback is able to determine root causes
for 21 out of 40 programs. We compared the results from our
tool and our callback method with the ground truth we built
for the benchmark. Our tool can precisely determine the layer
or the parameter that causes the error for 19 out 29 cases
and our callback method can precisely determine for 21 out
40 cases. In the rest of the models, the tool and the callbackmethod reported the root cause in another layer because the
training process is a cycle; the operation in one layer can
affect the adjacent layer. For example, the program [46],
mean_absolute_error is used as a loss function instead
ofmean_squared_error , and the SGD optimizer is used
instead of Adam optimizer. Our tool reports that the bug is
EBW (error in weight in backward propagation) at layer. No
= 1. In the program [47], the user assigned the learning rate
= 0.1 instead of learning rate = 0.001. Our tool reported EBA
(Error before activation function), layer. No = 2.
ApproachAverage TIme (sec)0300600900120015001800210024002700
TerminateOnNaN
EarlyStopping('loss')
EarlyStopping('accuracy')Union
DeepLocalize Tool Debugger CallbacKGH SOF GH+SOFComparison between Keras VS DeepLocalize Tool VS Debugger Callback 
Fig. 5: Comparison between Keras and Our Technique
We measured the analysis time for the three Keras methods,
our tool, and our callback function using Stack OverÔ¨Çow
(SOF) and GitHub (GH) benchmarks. Using SOF benchmarks,
TerminateOnNaN(), EarlyStopping(‚Äôloss‚Äô),
EarlyStopping(‚Äôaccuracy‚Äô) , the three Keras
methods together, our callback method and our tool
take an average of 93.01, 78.98, 93.04, 73.55, 421.39,
and 107.99 seconds respectively overall all Stack
OverÔ¨Çow (SOF) benchmarks. While in GH benchmarks,
TerminateOnNaN(), EarlyStopping(‚Äôloss‚Äô),
EarlyStopping(‚Äôaccuracy‚Äô) , the three Keras methods
together, and our callback take an average of 451.52, 310.57,
171.22, 172.02, and 2613.6 seconds respectively. The
average time for all Stack OverÔ¨Çow (SOF) and GitHub
(GH) benchmarks is 191.6, 142.67, 114.54, 100.63, and
1024.25 seconds respectively for the four corresponding
tools. In Figure 5, we plot the average time, and shown that,
TerminateOnNaN() terminates the program when there
is a NaN in the loss value; in other cases, the training will
continue. This is why it takes longer than other methods.
Our callback function needs more value than the three Keras
methods, such as update weight and gradient to perform
dynamic analysis. This leads to an overhead if the model has
a large number of parameters, but the overhead is usually
insigniÔ¨Åcant compared to the amount of time that takes other
callback functions. However, we anticipate that the time
needed to manually debug and fault localization would be
much more than the time required to execute our callback
function.
During building the benchmark from Stack OverÔ¨Çow and
258GitHub and identifying the bugs using our technique, we
observed that the most frequent bugs that the developer made
are (1) choosing the activation, and loss function, as there are
many combinations to choose the activation and loss depend
on the type of the problem, (2) selecting the hyperparameters,
such as the learning rate, the number of neural nodes in the
layer, number of layers in the model and (3) preprocessing
the training dataset, for example, the MNIST model needs to
normalize the training dataset from the range [-256, + 256] to
[-1, 1]. Without fault localization information, the developers
will face the problem of determining the layers or parameters
that induce the bug in the model.
C. Summary
1) RQ1 (Validation): We provide the empirical evidence
(Table III) that training a DNN using our imperative program
is consistent with using the Keras library. For RQ1, we show
that our tool is able to identify 23 out of 29 faulty models,
and our callback function is able to identify 34 out of 40
faulty models. Also our technique is able to determine the
fault localization precisely for 19 out 29 using our tool, and
21 out 40 using our callback while Keras is not able to localize
bug.
2) RQ2 (Comparison): Our technique is able to identify
34 out of 40 faulty models using our callback functions, and
23 out of 29 using our tool. On the other hand, the Keras
library reported bugs for 2, 24, and 28 out of 40 models,
respectively. Also, if we take the union of three methods,
theKeras library reported bugs for 32 out of 40 models.
We also show that our technique can effectively locate the
root causes for 21 out of 40 programs using our callback
and 19 out 29 using our tool while Keras methods does
not support this feature. As it can be seen in Figure 5, our
tool using dynamic analysis is practical and faster than Keras
by identifying the bug. Three methods using Keras take on
average 191.6, 142.67, and 114.54 seconds respectively, while
our tool takes on average 107.99 seconds. On the other hand,
our callback needs more time to make dynamic analysis for
additional parameters than loss and accuracy. This overhead
is usually insigniÔ¨Åcant compared to the amount of time taken
byTerminateOnNaN() .
3) RQ3 (Limitation): We failed to detect bugs for 7 out
of 30 programs and failed to localize faults for 11 out of 30
programs using our tool, and our callback failed to localize
fault for 20 out of 41. These programs either predicted wrong
labels or have problems in the training dataset, the settings
of epoches, batch sizes, the number hidden layers, and the
number of neural nodes. In such cases, the training stopped
before the model Ô¨Ånished learning. Thus our tool was not able
to handle these cases. Also, our prototype does not support all
theKeras APIs. As an example, one of the buggy program
inStack OverÔ¨Çow [42] used fit_generator() instead of
fit() function. fit_generator() is used to train the
model on data generated batch-by-batch [28]. We plan to cover
and investigate other APIs in our future work.V. T HREATS TO VALIDITY
We were mainly concerned with the implementation of our
tool that may affect the evaluation and result. To minimize this
threat, we followed Keras code [70] and carefully reviewed our
implementation between the authors to reduce the chances that
major errors were compared to our tool against Keras , as we
have shown in Table III.
Our tool currently handles the frequent layers/APIs in
theKeras library, including: Dense ,Dropout ,MaxPool-
ing2D ,Conv2D , and BatchNormalization . We may
not yet able to handle deep learning programs whose bugs
are related to other APIs e.g., ConvLSTM2D() ,Conv3D() .
We validated the output of our tool using the benchmarks
we created. The trustworthy of manually created benchmarks
could be a threat to the validity of our results. To alleviate this
threat, we follow the same methodology in prior works [13].
Also, we have evaluated the benchmark before/after Ô¨Åxing the
issue in the model.
VI. R ELATED WORK
The closest related work in terms of technical ideas is by
Gopinath et al. [20], [24]. Gopinath et al. proposed a new
approach (DeepCheck) inspired from program analysis to test
a Deep Neural Network (DNN) using symbolic execution.
DeepCheck also uses a white box technique to enable symbolic
execution to Ô¨Ånd the important pixels, and Ô¨Ånd the attack
pixels by translating DNN to an imperative program that
has the same behavior as DNN. The experimental results
conducted using MNIST data set shows that their approach
is able to create 1-pixel and 2-pixel attacks by Ô¨Ånding the
most important pixels that DNN fails to classify correctly. Our
imperative representation is inspired by this work. While this
work focuses on identifying adversarial attack, our work aims
to identify faults in DNNs and localize their fault.
A. Testing Deep Neural Networks
DeepTest [71] and follow-up work aim to automatically
generate test cases to examine corner cases corresponding
to real world inputs. These works have focused on test
case generation, whereas our work uses an existing training
dataset and focuses on localizing the root cause of a bug
by observing the runtime behavior of a deep neural network.
Zhang et al. [72] present a comprehensive survey of work
in this area. Eniser et al. [73] proposed a new white box
analysis technique (DeepFault) inspired from spectrum-based
fault localization. DeepFault tests DNN models to achieve two
objectives: (i) detect suspicious neurons, i.e., neurons likely to
be more responsible for inadequate DNN performance; and (ii)
synthesis of new inputs, using correctly classiÔ¨Åed inputs, that
exercise the identiÔ¨Åed suspicious neurons. The experimental
results conducted on MNIST and CIFAR-10 datasets show
that DeepFault is effectively identifying suspicious neurons.
DeepFault does not focus on structure bugs, instead they
focus on training bug, and pre-trained DNNs analysis, given
a speciÔ¨Åc test set. While our tool identiÔ¨Åes the buggy model
and faults the root causes of structure bug in DNN.
259TABLE VI: Comparisons Between the Keras Methods and Our Tool, and Our Callback Using Stack OverÔ¨Çow Post
Post # jRefTerminateOnNaN EarlyStopping(monitor=‚Äôloss‚Äô) EarlyStopping(monitor=‚Äôaccuracy‚Äô) Our Tool Our CallBack
Time Epoch Iteration IB FL Time Epoch Iteration IB FL Time Epoch Iteration IB FL Time Epoch Iteration IB FL Time Epoch Iteration IB FL
48385830 j[22] 1.20 1 10X ‚Äì 12.21 1 60000 X ‚Äì 34.90 3 60000 X ‚Äì 0.14 1 4XX 2.14 1 20XX
44164749 j[48] 175.23 5 60000 X ‚Äì 175.23 5 60000 X ‚Äì 175.23 5 60000 X ‚Äì 22.93 1 50XX 111.56 1 2000 XX
31556268 j[46] 5.69 1000 4 X ‚Äì 5.69 1000 4 X ‚Äì 0.91 2 4X ‚Äì 4.57 98 394 X X 1.20 1 4X X
50306988 j[49] 1.44 5 200 X ‚Äì 1.44 5 200 X ‚Äì 1.30 2 200 X ‚Äì 1.03 1 100 XX 3.57 1 64XX
48251943 j[41] 5.22 100 17 X ‚Äì 0.93 27 17X ‚Äì 5.22 100 17 X ‚Äì 20.45 100 17 X X 706.83 100 17 X X
38648195 j[50] 120.52 20 48000 X ‚Äì 120.52 20 48000 X ‚Äì 120.00 20 48000 X ‚Äì 2.49 1 95X X 25.92 1 100 XX
33969059 j[51] 130.66 20 10000 X ‚Äì 14.03 2 10000 X ‚Äì 14.14 2 10000 X ‚Äì 0.95 1 50XX 1.52 1 32XX
55328966 j[52] 98.84 10 49999 X ‚Äì 98.84 10 49999 X ‚Äì 98.84 10 49999 X ‚Äì 272.70 1 737 XX 9092.93 10 49999 X X
34311586 j[53] 1.01 20 6 X ‚Äì 0.87 2 6X ‚Äì 0.97 20 6 X ‚Äì 0.73 8 50XX 1.02 1 32XX
31880720 j[54] 176.02 3 20000 X ‚Äì 110.25 2 20000 X ‚Äì 113.28 2 20000 X ‚Äì 1.11 1 50XX 2.12 1 1XX
39525358 j[44] 3.15 150 13 X ‚Äì 3.15 150 13 X ‚Äì 1.68 2 13X ‚Äì 28.36 150 13 X X 14.29 2 10XX
39217567 j[55] 16.97 1000 256 X ‚Äì 1.31 11 256 X ‚Äì 1.18 2 256 X ‚Äì 329.46 100 256 X X 188.71 5 50X X
48934338 j[47] 11.03 1000 50 X ‚Äì 0.91 10 50X ‚Äì 0.85 2 50X ‚Äì 0.33 1 13X X 3.01 1 32X X
47724077 j[56] 31.07 50 32561 X ‚Äì 2.92 3 32561 X ‚Äì 3.46 4 32561 X ‚Äì 0.66 1 50XX 1.42 1 100 XX
59325381 j[57] 758.04 10 60000 X ‚Äì 260.06 3 60000 X ‚Äì 239.52 3 60000 X ‚Äì 125.52 1 1750 X X 24.66 1 160 XX
59278771 j[58] 1.94 200 135 X ‚Äì 5.24 62 135 X ‚Äì 1.94 200 135 X ‚Äì 0.52 1 50XX 60.64 1 75X X
52800582 j[59] 10.04 1000 400 X ‚Äì 1.79 2 400 X ‚Äì 10.04 1000 400 X ‚Äì 0.14 1 7XX 12.79 4 400 X X
41372874 j[60] 6.86 20 239 X ‚Äì 6.86 20 239 X ‚Äì 2.40 3 239 X ‚Äì 66.65 20 239 X X 1.42 1 2XX
34673164 j[61] 1.93 9 20 X ‚Äì 2.00 2 20X ‚Äì 2.09 6 20X ‚Äì 2.04 11 100 XX 26.00 5 9XX
48221692 j[62] 7.16 1000 150 X ‚Äì 2.61 280 150 X ‚Äì 0.95 2 150 X ‚Äì 24.24 13 150 XX 8.02 4 150 X X
50079585 j[42] 171.69 10 61 X ‚Äì 172.00 10 61 X ‚Äì 54.38 3 61X ‚Äì ‚Äì ‚Äì ‚Äì ‚Äì ‚Äì ‚Äì ‚Äì ‚Äì ‚Äì
45337371 j[63] 12.52 5 1000 X ‚Äì 6.79 2 1000 X ‚Äì 7.02 2 1000 X ‚Äì 1.17 1 50XX 2.43 1 1XX
44066044 j[64] 3.87 100 21 X ‚Äì 2.07 4 21X ‚Äì 1.97 2 21X ‚Äì 1.07 2 50XX 1.41 1 5XX
51930566 j[43] 4.07 50 75 X ‚Äì 4.07 50 75 X ‚Äì 1.66 2 75X ‚Äì 38.65 50 75 X X 22.40 1 40X X
47352366 j[65] 32.75 1 4950 X ‚Äì 381.31 1 60000 X ‚Äì 793.64 2 60000 X ‚Äì 75.46 1 50XX 1177.03 1 1050 X X
45442843 j[66] 2.57 100 200 X ‚Äì 1.17 3 200 X ‚Äì 1.15 2 200 X ‚Äì 0.48 1 50XX 0.97 1 200 XX
48594888 j[67] 1055.29 5 50000 X ‚Äì 1055.29 5 50000 X ‚Äì 1055.29 5 50000 X ‚Äì 116.38 1 51XX 4.24 1 32XX
31627380 j[68] 6.28 10 712 X ‚Äì 6.12 10 712 X ‚Äì 3.09 3 712 X ‚Äì 1.28 1 50XX 1.76 1 4XX
58609115 j[69] 3.12 10 1767 X ‚Äì 2.61 8 1767 X ‚Äì 1.94 3 1767 X ‚Äì 29.06 1 1350 XX 343.78 1 1250 X X
50481178 j[45] 12.66 50 200 X ‚Äì 4.12 6 200 X ‚Äì 3.58 3 200 X ‚Äì 1963.13 50 200 X X 376.44 1 150 X X
TABLE VII: Comparisons Between the Keras Methods and Our Callback Using GitHub Repository
GH jRefTerminateOnNaN EarlyStopping(monitor=‚Äôloss‚Äô) EarlyStopping(monitor=‚Äôaccuracy‚Äô) Union Our CallBack
Time Epoch Iteration IB FL Time Epoch Iteration IB FL Time Epoch Iteration IB FL Time Epoch Iteration IB FL Time Epoch Iteration IB FL
1j[29] 356.14 2 1944601 X ‚Äì 345.82 2 1944601 X ‚Äì 351.46 2 1944601 X ‚Äì 343.17 2 1944601 X ‚Äì 11.80 1 96X X
2j[30] 3427.71 50 100 X ‚Äì 2602.44 36 100 X ‚Äì 1082.78 15 100 X ‚Äì 1073.39 15 100 X ‚Äì 8432.06 50 100 X X
3j[31] 101.78 100 100 X ‚Äì 9.01 8 2140 X ‚Äì 4.39 3 2140 X ‚Äì 7.20 5 2140 X ‚Äì 31.69 1 96XX
4j[32] 256.76 20 1999 X ‚Äì 52.46 4 1999 X ‚Äì 54.10 4 1999 X ‚Äì 52.88 20 1999 X ‚Äì 102.44 1 300 X X
5j[33] 168.86 10 27839 X ‚Äì 169.24 10 27839 X ‚Äì 171.04 10 27839 X ‚Äì 191.71 10 27839 X ‚Äì 164.70 1 2560 XX
6j[34] 19.92 25 768 X ‚Äì 2.44 10 768 X ‚Äì 1.54 2 768 X ‚Äì 1.52 2 768 X ‚Äì 9568.09 25 768 X X
7j[35] 19.33 10 1166 X ‚Äì 19.75 10 1166 X ‚Äì 4.90 3 1166 X ‚Äì 4.95 3 1166 X ‚Äì 1.90 2 1XX
8j[36] 2.66 2 125 X ‚Äì 2.51 2 125 X ‚Äì 2.74 2 125 X ‚Äì 2.58 2 125 X ‚Äì 1022.32 2 125 X X
9j[37] 13.30 4 15000 X ‚Äì 12.67 4 15000 X ‚Äì 13.55 4 15000 X ‚Äì 13.38 4 15000 X ‚Äì 9381.21 4 15000 X X
10 j[38] 587.26 15 1440 X ‚Äì 194.23 5 1440 X ‚Äì 193.74 5 1440 X ‚Äì 198.24 5 1440 X ‚Äì 28.04 1 64XX
11 j[39] 12.97 10 10000 X ‚Äì 5.73 4 10000 X ‚Äì 3.20 2 10000 X ‚Äì 3.23 2 10000 X ‚Äì 5.38 1 30X X
B. Empirical Study on Deep Learning Bugs
There have been several empirical studies that have analyzed
different kind of bugs in deep learning networks. These studies
have been conducted on real code and examples from the
Stack OverÔ¨Çow posts and GitHub issues. They have focused
on symptoms and root causes of bugs to have a better
understanding of deep learning bugs.
Zhang et al. [8] utilized Stack OverÔ¨Çow posts and GitHub
commits to investigate bugs in deep learning applications built
on top of TensorFlow. They focused on symptoms and root
causes of TensorFlow bugs to have a better understanding of
deep learning bugs. Islam et al. [9] also studied deep learning
bugs using Stack OverÔ¨Çow questions and GitHub commits.
They also adapted a taxonomy of bug type, root cause, and
bug impacts for deep learning software for Ô¨Åve popular deep
learning libraries.
Another study has been conducted to understand the bug Ô¨Åx
pattern and how the developer can develop a tool to Ô¨Åx the
bugs automatically by Islam et al. [10]. They have conducted a
comprehensive study on 415 posts from Stack OverÔ¨Çow , and
555 from GitHub commits for Ô¨Åve popular DNN packages
to understand the bug Ô¨Åx patterns, and how the bugs can be
Ô¨Åxed in DNN software. The main goal of this study to help the
developers to understand the characteristics of bug and how
they can design an automated repair tool.
C. Bugs Repairing in Deep Learning
In recent years, there are several proposals for debugging
deep neural networks. These techniques are often inspiredfrom software debugging and testing techniques.
Maet al. [74] proposed and developed a technique called
MODE inspired by software debugging. MODE performs state
differential analysis to solve two types of problems: overÔ¨Åtting
problems and under-Ô¨Åtting problems. MODE can solve these
problems by identify the buggy features (or neurons) that
are responsible for the misclassiÔ¨Åcation in the model, then
it constructs the degree of importance of features to retrain
the faulty neurons with new input samples selection. MODE
provides effective and efÔ¨Åcient method to Ô¨Åx the buggy models
without introducing new bugs, and compromise on accuracy
and training time cost.
Zhang et al. [75] introduced an automatic approach to Ô¨Åxing
deep learning models called Apricot. Apricot is able to adjust
the ill-trained weights without using additional training data or
any artiÔ¨Åcial parameters, Apricot using a set of reduced models
from the original model, and compare the differences between
the original model and correct/incorrect of reduced models
iteratively, to Ô¨Ånd these failing test case that are responsible for
the misclassiÔ¨Åcation in the original model. The approach uses
three strategies to adjust the weight and achieve a higher test
accuracy. The experimental results using CIFAR-10 dataset
and Ô¨Åve state-of-the-art of deep learning models have shown
that the approach can increase the test and training accuracy.
In recent years, several researchers are supporting automated
debugging and repair approaches for deep neural networks,
and recent research is summarized in [72]. This topic is still
at the early stages [74], [75]. To the best of our knowledge, all
previous works are focused on the training bugs. Our technique
260is the Ô¨Årst approach that automatically identiÔ¨Åes the buggy
model and localizes the root causes of structure bug in DNNs
by applying the DNN Bug Detection algorithm.
VII. C ONCLUSIONS AND FUTURE WORK
As deep neural networks are becoming integrated with soft-
ware systems from different domains, developing debugging
techniques to localize the root cause of the bug has become
urgent. Thus, recent work has developed techniques to inspect
the entire model and Ô¨Ånd faults. Inspired by program analysis
and software debugging techniques, we have presented an
automated approach powered by a dynamic analysis and
statistical analysis. It can help identify the buggy model and
the root causes of DNN error. An experimental evaluation
using 40 real deep learning applications shows the usefulness
of our technique. For 34/40 cases, our approach was able to
detect faults whereas the best debugging approach provided by
Keras detected 32/40 faults. Our approach was able to localize
21/40 bugs whereas Keras did not localize any faults.
Future work includes developing techniques to repair deep
neural network bugs, and exploring cases that our work was
unable to detect faults (6/40) and localize errors (19/40).
Recent work has also used analysis of the DNN structure
to decompose it into modules [76]. It would be interesting
to explore whether a similar mechanism can be utilized for
better localization. It would also be interesting to go beyond
accuracy bugs to detect and localize more non-functional bugs,
e.g. fairness bugs [77].
VIII. A CKNOWLEDGMENT
This work was supported in part by the US National Science
Foundation (NSF) under grants CNS-15-13263, and CCF-19-
34884. All opinions are of the authors and do not reÔ¨Çect the
view of sponsors. This work beneÔ¨Åted from discussions with
Hamid Bagheri and Johirul Islam.
REFERENCES
[1] Martin Abadi et al, ‚ÄúTensorFlow: large-scale machine learning on
heterogeneous systems,‚Äù 2015, https://www.tensorÔ¨Çow.org/.
[2] Y . Jia, E. Shelhamer, J. Donahue, S. Karayev, J. Long, R. Girshick,
S. Guadarrama, and T. Darrell, ‚ÄúCaffe: convolutional architecture for
fast feature embedding,‚Äù in Proceedings of the 22nd ACM international
conference on Multimedia , 2014, pp. 675‚Äì678.
[3] T. Chen, M. Li, Y . Li, M. Lin, N. Wang, M. Wang, T. Xiao, B. Xu,
C. Zhang, and Z. Zhang, ‚ÄúMxnet: a Ô¨Çexible and efÔ¨Åcient machine
learning library for heterogeneous distributed systems,‚Äù arXiv preprint
arXiv:1512.01274 , 2015.
[4] A. Paszke, S. Gross, S. Chintala, G. Chanan, E. Yang, Z. DeVito, Z. Lin,
A. Desmaison, L. Antiga, and A. Lerer, ‚ÄúAutomatic differentiation in
PyTorch,‚Äù 2017.
[5] R. Al-Rfou, G. Alain, A. Almahairi, C. Angermueller, D. Bahdanau,
N. Ballas, F. Bastien, J. Bayer, A. Belikov, A. Belopolsky et al. ,
‚ÄúTheano: a Python framework for fast computation of mathematical
expressions,‚Äù arXiv e-prints , pp. arXiv‚Äì1605, 2016.
[6] Francois Chollet, ‚ÄúKeras: the Python deep learning library,‚Äù 2015, https:
//keras.io/.
[7] T. Zhang, C. Gao, L. Ma, M. R. Lyu, and M. Kim, ‚ÄúAn empirical study
of common challenges in developing deep learning applications,‚Äù in The
30th IEEE International Symposium on Software Reliability Engineering
(ISSRE) , 2019.
[8] Y . Zhang, Y . Chen, S.-C. Cheung, Y . Xiong, and L. Zhang, ‚ÄúAn empirical
study on TensorFlow program bugs,‚Äù in Proceedings of the 27th ACM
SIGSOFT International Symposium on Software Testing and Analysis ,
2018, pp. 129‚Äì140.[9] M. J. Islam, G. Nguyen, R. Pan, and H. Rajan, ‚ÄúA comprehensive study
on deep learning bug characteristics,‚Äù in Proceedings of the 2019 27th
ACM Joint Meeting on European Software Engineering Conference and
Symposium on the Foundations of Software Engineering , 2019, pp. 510‚Äì
520.
[10] M. J. Islam, R. Pan, G. Nguyen, and H. Rajan, ‚ÄúRepairing deep
neural networks: Ô¨Åx patterns and challenges,‚Äù in ICSE‚Äô20: The 42nd
International Conference on Software Engineering , May 23-May 29,
2020 2020.
[11] C. Le Goues, T. Nguyen, S. Forrest, and W. Weimer, ‚ÄúGenprog: a generic
method for automatic software repair,‚Äù IEEE Transactions on Software
Engineering , vol. 38, no. 1, pp. 54‚Äì72, 2011.
[12] H. D. T. Nguyen, D. Qi, A. Roychoudhury, and S. Chandra, ‚ÄúSemÔ¨Åx:
program repair via semantic analysis,‚Äù in 2013 35th International
Conference on Software Engineering (ICSE) . IEEE, 2013, pp. 772‚Äì
781.
[13] J. A. Jones, M. J. Harrold, and J. Stasko, ‚ÄúVisualization of test informa-
tion to assist fault localization,‚Äù in Proceedings of the 24th International
Conference on Software Engineering. ICSE 2002 . IEEE, 2002, pp. 467‚Äì
477.
[14] B. Baudry, F. Fleurey, and Y . Le Traon, ‚ÄúImproving test suites for
efÔ¨Åcient fault localization,‚Äù in Proceedings of the 28th International
Conference on Software Engineering , 2006, pp. 82‚Äì91.
[15] A. Zeller, ‚ÄúYesterday, my program worked. today, it does not. why?‚Äù
ACM SIGSOFT Software Engineering Notes , vol. 24, no. 6, pp. 253‚Äì267,
1999.
[16] X. Zhang, N. Gupta, and R. Gupta, ‚ÄúLocating faults through automated
predicate switching,‚Äù in Proceedings of the 28th International Confer-
ence on Software Engineering , 2006, pp. 272‚Äì281.
[17] I. Vessey, ‚ÄúExpertise in debugging computer programs: a process anal-
ysis,‚Äù International Journal of Man-Machine Studies , vol. 23, no. 5, pp.
459‚Äì494, 1985.
[18] M. Renieres and S. P. Reiss, ‚ÄúFault localization with nearest neighbor
queries,‚Äù in 18th IEEE International Conference on Automated Software
Engineering, 2003. Proceedings. IEEE, 2003, pp. 30‚Äì39.
[19] A. Zeller, ‚ÄúIsolating cause-effect chains from computer programs,‚Äù ACM
SIGSOFT Software Engineering Notes , vol. 27, no. 6, pp. 1‚Äì10, 2002.
[20] D. Gopinath, M. Zhang, K. Wang, I. B. Kadron, C. S. Pasareanu, and
S. Khurshid, ‚ÄúSymbolic execution for importance analysis and adver-
sarial generation in neural networks,‚Äù in 2019 IEEE 30th International
Symposium on Software Reliability Engineering (ISSRE). IEEE , 2019.
[21] https://github.com/Wardat-ISU/DeepLocalize, 2021, [Online; accessed
12-Feb-2021].
[22] ‚ÄúSimple Keras neural network isn‚Äôt learning,‚Äù 2018,
https://stackoverÔ¨Çow.com/questions/48385830/.
[23] Francois Chollet, ‚ÄúUsage of callbacks,‚Äù 2015, https://keras.io/callbacks/.
[24] D. Gopinath, C. S. Pasareanu, K. Wang, M. Zhang, and S. Khurshid,
‚ÄúSymbolic execution for attribution and attack synthesis in neural net-
works,‚Äù in 2019 IEEE/ACM 41st International Conference on Software
Engineering: Companion Proceedings (ICSE-Companion) . IEEE, 2019,
pp. 282‚Äì283.
[25] K. C. Sim, A. Narayanan, T. Bagby, T. N. Sainath, and M. Bacchiani,
‚ÄúImproving the efÔ¨Åciency of forward-backward algorithm using batched
computation in TensorFlow,‚Äù in 2017 IEEE Automatic Speech Recogni-
tion and Understanding Workshop (ASRU) . IEEE, 2017, pp. 258‚Äì264.
[26] J. A. Hertz, Introduction to the theory of neural computation . CRC
Press, 2018.
[27] S. Ruder, ‚ÄúAn overview of gradient descent optimization algorithms,‚Äù
arXiv preprint arXiv:1609.04747 , 2016.
[28] Francois Chollet, ‚ÄúKeras documentation,‚Äù 2015, https://keras.io/.
[29] https://github.com/Jacobvs/DDOS-ML-Detection, 2017, [Online; ac-
cessed 20-Aug-2020].
[30] https://github.com/kcct-fujimotolab/keras-super-resolution, 2017, [On-
line; accessed 20-Aug-2020].
[31] https://github.com/ShyamPoovaiah/FacialKeypointsDetection, 2018,
[Online; accessed 20-Aug-2020].
[32] https://github.com/ronnyworm/keras catsdogs, 2017, [Online; accessed
20-Aug-2020].
[33] https://github.com/ulmefors/TrafÔ¨Åc-Sign-ClassiÔ¨Åer, 2017, [Online; ac-
cessed 20-Aug-2020].
[34] https://github.com/eangelou/kerasma, 2017, [Online; accessed 20-Aug-
2020].
261[35] https://github.com/yetanotherdeveloper/kaggle-melbourne properties,
2018, [Online; accessed 20-Aug-2020].
[36] https://github.com/alexander-travov/gol nn, 2019, [Online; accessed 20-
Aug-2020].
[37] https://github.com/tautvydasversockas/MovieReviews Keras, 2019,
[Online; accessed 20-Aug-2020].
[38] https://github.com/sammyhaq/hotdog-sandwich, 2019, [Online; accessed
20-Aug-2020].
[39] https://github.com/vincenty2022/Averaging Neural Networks, 2016,
[Online; accessed 20-Aug-2020].
[40] K. Kawaguchi, ‚ÄúDeep learning without poor local minima,‚Äù in Advances
in neural information processing systems , 2016, pp. 586‚Äì594.
[41] ‚Äúmy Keras model does not predict negative values,‚Äù https://
stackoverÔ¨Çow.com/questions/48251943/, 2018, [Online; accessed 19-
Feb-2020].
[42] ‚ÄúCNN with keras, accuracy not improving,‚Äù https://stackoverÔ¨Çow.com/
questions/50079585/, 2019, [Online; accessed 19-Feb-2020].
[43] ‚ÄúInput nodes in Keras NN,‚Äù https://stackoverÔ¨Çow.com/questions/
51930566/, 2019, [Online; accessed 19-Feb-2020].
[44] ‚ÄúNeural network accuracy optimization,‚Äù https://stackoverÔ¨Çow.com/
questions/39525358/, 2017, [Online; accessed 19-Feb-2020].
[45] ‚Äúkeras MLP accuracy zero,‚Äù https://stackoverÔ¨Çow.com/questions/
50481178/, 2019, [Online; accessed 19-Feb-2020].
[46] ‚ÄúHow to use keras for XOR,‚Äù https://stackoverÔ¨Çow.com/questions/
31556268/, 2016, [Online; accessed 19-Feb-2020].
[47] ‚ÄúNon linear Regression: Why isn‚Äôt the model learning?‚Äù https://
stackoverÔ¨Çow.com/questions/48934338/, 2018, [Online; accessed 19-
Feb-2020].
[48] ‚ÄúHow does Keras handle multilabel classiÔ¨Åcation?‚Äù https:
//stackoverÔ¨Çow.com/questions/44164749/, 2018, [Online; accessed
19-Feb-2020].
[49] ‚ÄúNeural net fails on toy dataset,‚Äù https://stackoverÔ¨Çow.com/questions/
50306988/, 2019, [Online; accessed 19-Feb-2020].
[50] ‚ÄúKeras low accuracy classiÔ¨Åcation task,‚Äù https://stackoverÔ¨Çow.com/
questions/38648195/, 2017, [Online; accessed 19-Feb-2020].
[51] ‚ÄúTrying to get simple Keras neural net example to work,‚Äù https:
//stackoverÔ¨Çow.com/questions/33969059/, 2016, [Online; accessed 19-
Feb-2020].
[52] ‚Äútf.keras loss becomes NaN,‚Äù https://stackoverÔ¨Çow.com/questions/
55328966/, 2019, [Online; accessed 19-Feb-2020].
[53] ‚ÄúCannot train a neural network solving XOR mapping,‚Äù https://
stackoverÔ¨Çow.com/questions/34311586/, 2016, [Online; accessed 19-
Feb-2020].
[54] ‚ÄúHow to prepare a dataset for Keras?‚Äù https://stackoverÔ¨Çow.com/
questions/31880720/, 2016, [Online; accessed 19-Feb-2020].
[55] ‚ÄúKeras neural network outputs same result for every input,‚Äù https:
//stackoverÔ¨Çow.com/questions/39217567/, 2017, [Online; accessed 19-
Feb-2020].
[56] ‚ÄúKeras: could not broadcast input array from shape (14,1) into shape
(14),‚Äù https://stackoverÔ¨Çow.com/questions/47724077/, 2018, [Online; ac-
cessed 19-Feb-2020].
[57] ‚ÄúLow accuracy after training a CNN,‚Äù https://stackoverÔ¨Çow.com/
questions/59325381/, 2018, [Online; accessed 19-Feb-2020].
[58] ‚ÄúSuper low accuracy for neural network model,‚Äù https://stackoverÔ¨Çow.
com/questions/59278771/, 2017, [Online; accessed 19-Feb-2020].
[59] ‚ÄúWhy do I fail to predict y=x**4 with Keras? (y=x**3 works),‚Äù https:
//stackoverÔ¨Çow.com/questions/52800582/, 2019, [Online; accessed 19-
Feb-2020].[60] ‚ÄúBinary classiÔ¨Åcation with Keras: poor performance,‚Äù
https://stackoverÔ¨Çow.com/questions/41372874/, 2017, [Online; accessed
19-Feb-2020].
[61] ‚ÄúHow to train and tune an artiÔ¨Åcial multilayer perceptron neural
network using Keras?‚Äù https://stackoverÔ¨Çow.com/questions/34673164/,
2016, [Online; accessed 19-Feb-2020].
[62] ‚ÄúCreate a square function estimator with Keras,‚Äù https://stackoverÔ¨Çow.
com/questions/48221692/, 2018, [Online; accessed 19-Feb-2020].
[63] ‚ÄúTaking derivative of Keras model wrt to inputs is returning all zeros,‚Äù
https://stackoverÔ¨Çow.com/questions/45337371/, 2018, [Online; accessed
19-Feb-2020].
[64] ‚ÄúKeras accuracy is not increasing over 50%,‚Äù https://stackoverÔ¨Çow.com/
questions/44066044/, 2018, [Online; accessed 19-Feb-2020].
[65] ‚ÄúKeras unreasonnably slower than TensorFlow,‚Äù https://stackoverÔ¨Çow.
com/questions/47352366/, 2018, [Online; accessed 19-Feb-2020].
[66] ‚ÄúSigmoid layer in Keras,‚Äù https://stackoverÔ¨Çow.com/questions/
45442843/, 2018, [Online; accessed 19-Feb-2020].
[67] ‚ÄúCNN train accuracy gets better during training, but test accu-
racy stays around 40%,‚Äù https://stackoverÔ¨Çow.com/questions/48594888/,
2018, [Online; accessed 19-Feb-2020].
[68] ‚ÄúTrying Kaggle Titanic with keras,‚Äù https://stackoverÔ¨Çow.com/questions/
31627380/, 2016, [Online; accessed 19-Feb-2020].
[69] ‚ÄúManual predictions of neural net go wrong,‚Äù https://stackoverÔ¨Çow.com/
questions/58609115/, 2016, [Online; accessed 19-Feb-2020].
[70] Francois Chollet, ‚ÄúKeras: deep learning for humans,‚Äù 2015, https:
//github.com/keras-team/keras.
[71] Y . Tian, K. Pei, S. Jana, and B. Ray, ‚ÄúDeepTest: automated testing
of deep-neural-network-driven autonomous cars,‚Äù in Proceedings of the
40th International Conference on Software Engineering , ser. ICSE ‚Äô18.
New York, NY , USA: Association for Computing Machinery, 2018, p.
303‚Äì314. [Online]. Available: https://doi.org/10.1145/3180155.3180220
[72] J. M. Zhang, M. Harman, L. Ma, and Y . Liu, ‚ÄúMachine learning test-
ing: survey, landscapes and horizons,‚Äù IEEE Transactions on Software
Engineering , pp. 1‚Äì1, 2020.
[73] H. F. Eniser, S. Gerasimou, and A. Sen, ‚ÄúDeepFault: fault localization
for deep neural networks,‚Äù in Fundamental Approaches to Software
Engineering , R. H ¬®ahnle and W. van der Aalst, Eds. Cham: Springer
International Publishing, 2019, pp. 171‚Äì191.
[74] S. Ma, Y . Liu, W.-C. Lee, X. Zhang, and A. Grama, ‚ÄúMode: automated
neural network model debugging via state differential analysis and
input selection,‚Äù in Proceedings of the 2018 26th ACM Joint Meeting
on European Software Engineering Conference and Symposium on the
Foundations of Software Engineering , 2018, pp. 175‚Äì186.
[75] H. Zhang and W. Chan, ‚ÄúApricot: a weight-adaptation approach to
Ô¨Åxing deep learning models,‚Äù in 2019 34th IEEE/ACM International
Conference on Automated Software Engineering (ASE) . IEEE, 2019,
pp. 376‚Äì387.
[76] R. Pan and H. Rajan, ‚ÄúOn decomposing a deep neural network into
modules,‚Äù in ESEC/FSE‚Äô2020: The 28th ACM Joint European Software
Engineering Conference and Symposium on the Foundations of Software
Engineering , November 8-November 13, 2020 2020.
[77] S. Biswas and H. Rajan, ‚ÄúDo the machine learning models on a crowd
sourced platform exhibit bias? an empirical study on model fairness,‚Äù in
ESEC/FSE‚Äô2020: The 28th ACM Joint European Software Engineering
Conference and Symposium on the Foundations of Software Engineering ,
November 8-November 13, 2020 2020.
262