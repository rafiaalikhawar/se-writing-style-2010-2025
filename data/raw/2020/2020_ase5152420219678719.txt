Efficient SMT-Based Model Checking
for Signal Temporal Logic
Jia Lee
POSTECH
Pohang, South Korea
cee5539@postech.ac.krGeunyeol Yu
POSTECH
Pohang, South Korea
rgyen@postech.ac.krKyungmin Bae
POSTECH
Pohang, South Korea
kmbae@postech.ac.kr
Abstract —Signal temporal logic (STL) is widely used to specify
and analyze properties of cyber-physical systems with continuous
behaviors. However, STL model checking is still quite limited,
as existing STL model checking methods are either incomplete
or very inefficient. This paper presents a new SMT-based model
checking algorithm for verifying STL properties of cyber-physical
systems. We propose a novel translation technique to reduce the
STL bounded model checking problem to the satisfiability of a
first-order logic formula over reals, which can be solved using
state-of-the-art SMT solvers. Our algorithm is based on a new
theoretical result, presented in this paper, to build a small but
complete discretization of continuous signals, which preserves
the bounded satisfiability of STL. Our translation method allows
an efficient STL model checking algorithm that is refutationally
complete for bounded signals, and that is much more scalable
than the previous refutationally complete algorithm.
Index Terms—Signal temporal logic, model checking, SMT
I. I NTRODUCTION
Many safety-critical systems, such as cars and airplanes,
interact with physical entities, and therefore are hybrid systems
exhibiting both discrete and continuous behaviors. The safety
requirements of such cyber-physical systems (CPSs) often
involve continuously changing states of physical environments.
Signal temporal logic (STL) is a temporal logic formalism
to specify linear-time properties of continuous signals [1].
STL is widely used for specifying and analyzing (safety)
requirements of safety-critical CPSs, including automotive,
avionics, robotics, and medical systems [2]–[8].
There are many approaches for analyzing STL properties.
STL monitoring [9]–[12] checks whether a signal satisfies an
STL property, and STL falsification [13], [14] tries to find a
counterexample of an STL property by (randomly) generating
signals. These methods are based on concrete sampling of
signals and cannot be used to guarantee correctness. On the
other hand, the reachability analysis of hybrid automata, such
as [15]–[19], can guarantee the correctness of invariants, and
some STL formulas can be encoded using reachability [20].
However, model checking of general STL properties is still
very limited, as existing STL model checking algorithms are
incomplete or inefficient. Recently, two STL model checking
techniques have been proposed. The method proposed in [21]
This work was partially supported by the National Research Foundation
of Korea (NRF) grants funded by the Korea government (MSIT) (No.
2021R1A5A1021944 and No. 2019R1C1C1002386).samples a finite number of concrete time points to perform
the reachability analysis over those points, and therefore the
correctness cannot be guaranteed. The work [22] provides a
refutationally complete model checking procedure for STL,
but the algorithm is not scalable in practice.
A common challenge in existing approaches is to discretize
continuous signals to reason about temporal operators. Since
model checking of hybrid systems involves an infinite number
of states that continuously change over an uncountable time
domain, signal discretization has been studied for effectively
analyzing temporal logic properties (e.g, LTL [23], [24]) of
hybrid systems. The important problem is obtaining complete
discretization of a signal to preserve the correctness of model
checking, while maintaining the size of discretization as small
as possible for the performance of the analysis.
This paper proposes a new SMT-based model checking
algorithm for verifying STL properties of hybrid systems that
is refutationally complete with respect to bounded signals. Our
algorithm is based on a new theoretical result to build small but
complete discretized signals for the bounded satisfiability of
STL. Our algorithm combines the advantages of the previous
methods [21], [22]: it considers a finite number of sampled
time points, but which is complete for STL model checking
without any loss of information.
We consider bounded signals with finite variable points
(excluding Zeno behaviors), which is typically assumed when
analyzing real-time and hybrid systems [1], [23]–[26]. For a
signal with finite variable points, the satisfaction of a temporal
logic formula must depend on a finite number of sampled time
points. There exist signal discretization methods proposed for
different temporal logics [23], [24], [27], but they cannot be
directly applicable to STL. The main difficulty comes from
the timed until operator UI, which often results in too “fine”
discretized signals that prevent efficient model checking. This
paper presents a novel technique to build a complete but
reasonably coarse discretized signals for STL (Sec. IV).
A complete discretization of signals allows reducing the
bounded satisfaction problem of STL into the satisfiability of
a first-order formula. It is well known that temporal logics for
discrete systems, such as LTL and MITL, can be analyzed for
each subformula in a modular way [28]. However, an effective
translation of STL is nontrivial, because temporal operators
in STL involves arbitrary nonnegative intervals of the real
3432021 36th IEEE/ACM International Conference on Automated Software Engineering (ASE)
DOI 10.1109/ASE51524.2021.000392021 36th IEEE/ACM International Conference on Automated Software Engineering (ASE) | 978-1-6654-0337-5/21/$31.00 ©2021 IEEE | DOI: 10.1109/ASE51524.2021.9678719
978-1-6654-0337-5/21/$31.00  ©2021  IEEE
numbers. We leverage syntactic separation of STL [22] to
translate the bounded satisfaction of STL into a quantifier-free
first-order formula in linear real arithmetic (Sec. V).
Based on our translation method, we present a new bounded
STL model checking algorithm (Sec. VI). Our algorithm builds
a first-order formula that is satisfiable if and only if there exists
a counterexample signal up to a bound Non the size of a
discretized signal. To encode the existence of signals with
finite variable points, we apply SMT-based approaches for
the reachability of hybrid automata [18], [29]. The algorithm
is refutationally complete for bounded signals with finite
number of variable points. The experimental results show that
the proposed algorithm can greatly outperform the previous
refutationally complete algorithm [22] (Sec. VII).
Our main contributions can be summarized as follows:
(1) We present an efficient technique to obtain small but
complete discretization of continuous signals; (2) We present
a modular method to encode the bounded STL satisfiability in
SMT; (3) We present a new SMT-based STL model checking
algorithm that is refutationally complete for bounded signal
but much more scalable than the previous algorithm [22]. Due
to space limitations, we sometimes include only proof sketches
for some lemmas; the complete proofs of the lemmas in the
paper can be found in the supplementary material [30].
II. P RELIMINARIES ON SIGNAL TEMPORAL LOGIC
A. Hybrid Automata
Hybrid automata [31] are state machines with continuous
variables. Many verification techniques and tools for hybrid
systems use hybrid automata as their modeling formalisms
[15]–[19], and CPS models can often be translated into hybrid
automata for verification [32]–[34]. Therefore, we also use
hybrid automata as the modeling formalism in this paper.
In a hybrid automaton H, discrete states are given by a set
ofmodes Q, and continuous states are specified by a finite
set of real-valued variables X. A state of His a pair ⟨q,⃗ v⟩
of a mode q∈Qand a vector ⃗ v∈Rl, where |X|=l.
Aninitial condition init(q,⃗ v)defines a set of initial states.
Aninvariant condition inv(q,⃗ v)defines a set of valid states.
Ajump condition jump (⟨q,⃗ v⟩,⟨q′,⃗v′⟩)defines a “discrete”
transition between states ⟨q,⃗ v⟩ → ⟨q′,⃗v′⟩. A flow condition
⟨q, ⃗ vt⟩=flow(⟨q, ⃗ v 0⟩, t)defines a continuous evolution of X’s
values from ⃗ v0to⃗ vtover time tin mode q. Consequently, a
hybrid automaton isH= (Q, X, init,inv,flow,jump ).
Asignal σrepresents a continuous execution of a hybrid
automaton H, given by a function σ: [0, τ )→Q×Rlover
time domain dom(σ ) = [0 , τ),τ >0. The value σ(t)denotes
the state of Hat time t. A signal σisbounded if its domain is
bounded (i.e., τ <∞). A signal σis atrajectory ofH, written
σ∈H, ifσdescribes a valid behavior of H: i.e, as depicted in
Fig. 1, there exists a sequence of times 0 =t0< t1< t2<···
such that: (i) σ(t0)is an initial state; (ii) for each time interval
[ti, ti+1),H’s state evolves from σ(ti)according to the flow
condition, satisfying the invariant condition but not changing
the mode; and (iii) at each time point ti,i >0, a discrete
transition takes places by the jump condition.t0 t1 t2 t3σ(t0)q0σ(t1) q1
σ(t2)q2σ(t3)q3
Fig.
1. A trajectory σof a hybrid automaton
φ
θ
(x,y)v
L Fig. 2. A simple car
Fig. 3. A hybrid automaton for a simple car
Example 1. Figure 3 shows a hybrid automaton for a simple
autonomous car [22], [35]. The position (x, y)and direction
θdepend on its speed vand steering angle ϕ(see Fig. 2). The
car dynamics is modeled as the ordinary differential equations:
˙x=vcosθ, ˙y=vsinθ, ˙θ=v/L·tanϕ,
where Lis the distance between the front and rear axles [36].
There are three modes (left, straight, and right) of assigning
different control values to vandϕ. Initially, the car can be
in any of the three modes. When the difference between θand
a goal direction gis greater than some threshold c >0, the
car turns left or right at low speed vlowwith steering angle
α. Otherwise, the car goes straight at high speed vhigh.
B. Signal Temporal Logic
Properties of hybrid automata trajectories can be specified
in signal temporal logic (STL) [1]. The syntax of STL over a
set of state propositions Πis defined by:
φ::=p| ¬φ|φ∧φ|φUIφ
where p∈Π, and I⊆R≥0is an interval of nonnegative real
numbers. Other operators can be derived by equivalences: e.g.,
♢Iφ≡ ⊤UIφ, □Iφ≡ ¬♢I¬φ.
The set of all subformulas of φis denoted by sub(φ), and the
set of propositions occurring in φis denoted by prop(φ).
The meaning of a proposition pis specified as a function
p:Q×Rl→Bassigning to each state ⟨q,⃗ v⟩ofHa Boolean
value in B. Examples of state propositions include relational
expressions of the form f(⃗ x)>0over variables X, where
f:Rl→Ris a real-valued function. We assume that state
propositions are definable in first-order real arithmetic.
Example 2. For the hybrid automaton in Example 1, consider
the following STL formulas:
•♢[0,30](v > 100∧□[0,20]v > 100): at some time in the
first30seconds, vwill go over 100 km/h and stay above
100 km/h for20seconds [6].
•□[0,∞)(θ > 15→(θ < 20)U[2,3)toLeft ): whenever θis
greater than 15◦, the mode will be leftafter sometime within
[2,3); until then θis less than 20◦.
344ty
1
0 10 1 3 5 9
Fig. 4. Signal y= cos(πt/2) + 1tφ′ φ
t+I
Fig. 5. Satisfaction of φUIφ′
The complement of an interval Iis denoted by I∁(that is,
I∁=R\I). For two intervals IandJ, the Minkowski sum
{i+j|i∈I, j∈J}is denoted by I+J, and the Minkowski
difference {i−j|i∈I, j∈J}is denoted by I−J. (E.g.,
[a, b]+[c, d ] = [a +c, b+d], and (a, b)−(c, d) = (a −d, b−c).)
For a singular interval {t}, the sets {t}+Iand{t} − Iare
often written as t+Iandt−I, respectively. The following
property for interval operations is particularly useful for STL.
Lemma 1. [22] For two intervals I, K⊆R≥0,t∈K−Iiff
there exists t′≥tsuch that t′∈Kandt′∈t+I.
The semantics of STL is defined as the satisfaction relation
of a formula φwith respect to a signal σand a time t. To
properly deal with bounded signals, a bound τis explicitly
considered. When τ=∞, our definition is exactly the same
as the standard (unbounded) semantics of STL in [1].
Definition 1. Thesatisfaction of an STL formula φat time t
over a signal σup to a bound τ, denoted by σ, t|=τφ, where
dom(σ )⊆[0, τ), is defined by:
•σ, t|=τp ifft < τ andp(σ(t)) = ⊤
•σ, t|=τ¬φ iffσ, t̸|=τφ
•σ, t|=τφ∧φ′iffσ, t|=τφandσ, t|=τφ′
•σ, t|=τφUIφ′iff(∃t′≥t)t′< τ, t′∈t+I, σ, t′|=τφ′,
and(∀t′′∈[t, t′])σ, t′′|=τφ
C. Variable Points and Stability
The value of a signal σchanges continuously over time,
but the truth of a proposition pchanges discontinuously on
the signal σ. A time point tis called a variable point for pif
the truth value of pchanges at time t. For example, consider
a signal y= cos( πt/2) + 1 over[0,10)in Fig. 4. There are
four variable points {1,3,5,9}for proposition y >1.
An STL formula φisstable for a signal σin an interval J,
written stableσ
J(φ), if the truth of φdoes not change over J
(i.e., for any u, u′∈J,σ, u|=τφiffσ, u′|=τφ).
Definition 2. A time tis avariable point of a signal σforφ, if
φis not stable for σin each open interval J⊆dom(σ )with
t∈J. A time tis a variable point of σfor a set of formulas
Γ, iftis a variable point of σforsome formula φ∈Γ.
The behavior of real-time and hybrid systems is associated
with sequences of disjoint time intervals [22]–[24], [27]. Let
[N]denote the set {1, . . . , N }for a positive integer N.
Definition 3. Apartition of an interval Dis a family of
nonempty disjoint intervals P={Ji}i∈[N ], where |P|=N,
such that (i) each interval Jiis either open or singular,
(ii)SN
i=1Ji=D, and (iii) sup(Ji)≤inf(J k)for any i < k .Consider two partitions P={Ji}i∈[N ]andQ={Kj}j∈[M]
of the same interval. Qis called finer thanP, written Q ⊑ P ,
if each interval Kj∈ Q is a subset of some interval Ji∈ P.
A finer partition Qis called a refinement of a coarser partition
P[23], [24]. The coarsest partition that is finer than both P
andQis denoted by P ⊓ Q , which always exists [22].
Example 3. Consider three partitions of the interval [0,5):
P={{0}, (0,4),{4},(4,5)},Q={{0}, (0,1),{1},(1,5)},
andR={{0}, (0,1),{1},(1,4),{4},(4,5)}. Notice that
e(P) ={0,4,5},e(Q) = {0,1,5}, and e(R) ={0,1,4,5}.
Then,Ris finer than both of PandQ, and R=P ⊓ Q . But
neither P ⊑ Q norQ ⊑ P holds.
A formula φis called stable for a signal σinP={Ji}i∈[N ]
(or,Pis stable for φwith respect to σ), written stableσ
P(φ), if
φis stable for σin each interval Ji∈ P. When stableσ
P(φ),
σ, Ji|=τφindicates that φis true in Ji, and σ, Ji̸|=τφ
indicates that φis false in Ji. A formula that is stable in Pis
stable in a finer partition Q ⊑ P [23], [24].
Lete(I)denote the set of endpoints of an interval I; e.g.,
e([1,2)) = {1,2}ande((1,∞)) = {1}. Let e(P)denote the
set of all endpoints of the intervals in a partition P. Variable
points are then related to stable partitions as follows.
Proposition 1. [23] For a signal σand a partition Pof an
interval D⊆dom(σ ),stableσ
P(φ)iff every variable point t
ofσinDforφis an endpoint in P(i.e.,t∈e(P)).
In many real-time temporal logics, the stability of a formula
is related to the stability of its subformulas [23], [24]. The
cases for negation and conjunction are stated as follows.
Proposition 2. [23] For a signal σand a partition Pof an
interval D⊆dom(σ ): (1) stableσ
P(φ)iffstableσ
P(¬φ). (2) If
stableσ
P(φ)andstableσ
P(φ′), then stableσ
P(φ∧φ′).
The case of φUIφ′is not straightforward. Even if φand
φ′are stable for a signal σinP,φUIφ′need not be stable
inP. As depicted in Fig. 5, the satisfaction of φUIφ′at time
tdepends on the satisfaction of φ′int+Iand the satisfaction
ofφin[t,inf(t+I)]. There are several methods to build a
refinement of Pby taking Iinto account [22], [27].
Suppose that there is a finite number of variable points of
a signal σfor the set of propositions in an STL formula φ.
By the above results [22]–[24], there exists a partition Psuch
that every subformula of φis stable for σinP. In this case,
we call φfully stable forσinP. There is also a finite number
of variable points of σfor the set of subformulas sub(φ).
III. O VERVIEW OF BOUNDED STL M ODEL CHECKING
A. Problem Statement
The STL model checking problem is to check whether every
trajectory of a hybrid automaton Hsatisfies an STL formula
φ. This problem is in general undecidable; the reachability
problem of hybrid automata—a special case of STL model
checking—is already undecidable [37]. An appropriate notion
of bounds is needed to cope with this undecidability.
345UNSATSMT encoding of 
discrete signals
SMT encoding of 
matching trajectories φ 
n, τ 
H∧ SMT 
SolvingCounterexample 
found
No counterexample 
up to boundsSATFig. 6. An SMT-based bounded STL model checking framework
Bounded STL model checking restricts the search for a
counterexample of a formula φtobounded trajectories with
finite variable points [22]. There are two bound parameters: τ
for the time domain, and nfor the number of variable points
for the set of subformulas sub(φ). That is, the truth of each
ϕ∈sub(φ)can change at most ntimes in [0, τ).
Definition 4 (Bounded STL Model Checking Problem). An
STL formula φis satisfied at time tin a hybrid automaton H
up to bounds τ >0andn∈N, denoted by H, t|=n
τφ,iff
σ, t|=τφfor every trajectory σ∈Hwith at most nvariable
points with respect to sub(φ), where dom(σ ) = [0, τ ).
B. SMT-Based Bounded STL Model Checking
The bounded STL model checking problem can be solved
by discretizing signals with full stability [22]. When an STL
formula φis fully stable for a signal σin a partition P(i.e.,
stableσ
P(ϕ)for each ϕ∈sub(φ)),σcan be discretized as the
truth values of the subformulas sub(φ)in each interval in P.
This observation leads to the concept of discrete signals.
Definition 5. Adiscrete signal for a formula φisζφ= (P, θ),
where Pis a partition and θ: sub( φ)× |P| → Bassigns a
truth value to subformula ϕ∈sub(φ)and interval Ji∈ P.
Intuitively, a discrete signal ζφinvolves an infinite number
of “matching” continuous signals. A continuous signal σ
matches a discrete signal ζφ= (P, θ), written σ≺ζφ, if:
(i)Pis a partition of dom(σ ), (ii) φis fully stable for σin
P, and (iii) θ(ϕ, i) =⊤iffσ, Ji|=ϕ, for each subformula
ϕ∈sub(φ)and interval Ji∈ P.
The bounded STL model checking problem H, t|=n
τφis
equivalent to finding a bounded trajectory σ∈Hthat satisfies
the negated formula ¬φ(i.e.,σ, t|=n
τ¬φ). This problem can
be decomposed into the problems of finding a discrete signal
ζ¬φ= (P, θ), where θ(¬φ, i ) =⊤andt∈Ji, and finding a
bounded trajectory σ∈Hthat matches ζ¬φ[22].
An SMT-based bounded STL model checking framework,
proposed in [22], is shown in Fig. 6. The existence of discrete
signals and matching trajectories is encoded in SMT, provided
the reachability of Hcan be encoded in SMT. This procedure
is refutationally complete; if a bounded counterexample to φ
exists, then it is guaranteed to be found for some bounds.
C. Key Challenge and Our Approach
One of the major challenges in SMT-based bounded STL
model checking is to find efficient SMT encodings. Indeed,
the previous technique [22] often produces very complex and
huge SMT encodings that conventional SMT solvers cannot
solve within a reasonable time. The contribution of this paper
is to propose much more efficient SMT encodings.0 τ t1 t3 t5 t7 0 τ t1t2t3t4t5t6t7
Fig. 7. Two partitions P1(left) and P2(right), where P1⊒ P2
J1 J2 J3 J4 J5J6J7J8J9inf
(J2)inf
(J6)−sup(I )sup(J 8)−inf
(I)
(S8
m=6Jm)−Iinf
(J6)sup(J 8)
S8
m=6Jm
φ′⊥ ⊥ ⊥ ⊥ ⊥⊤⊤⊤⊥·
··
φ⊥ ⊤ ⊤ ⊤ ⊤⊤⊤⊤⊤···
Fig. 8. An STL formula φUIφ′, and a stable partition Pforφandφ′
The inefficiency is due to redundant endpoints in discrete
signals. E.g., suppose both P1andP2are fully stable for φ
in Fig. 7. The corresponding discrete signals are equivalent
in terms of the satisfaction of φ, but P2contains redundant
endpoints (t 2,t4, and t6). A fully stable partition built for φ
in [22] usually has many redundant endpoints.
Another problem is that a bound parameter of the previous
algorithm [22] is the number of variable points for the set of
propositions prop(φ). A signal σwith kvariable points for
prop(φ) can have O(k·2d(φ))variable points for sub(φ)[9],
where d(φ)is the nesting depth of UI. Therefore, the previous
algorithm [22] may generate unnecessarily large encodings.
We address this challenge in a twofold way. (1) We develop
an efficient technique to build fully stable partitions for STL
that are much smaller than those produced by the previous
approaches [22], [27]. (2) We develop a flexible technique to
encode discrete signals; its bound parameter is the number of
variable points for the set of subformulas sub(φ), and the size
of the resulting encoding is linear in the size of φ.
IV. P ARTITION CONSTRUCTION FOR STL
This section presents a simple method to build a partition
that is fully stable for an STL formula φ. As mentioned, there
are a couple of methods that can be adapted to build fully
stable partitions for STL formulas [22], [27], but they result in
too fine refinements in general. Section IV-A presents a precise
condition for the stability of φUIφ′. Using this condition,
Section IV-B explains how to construct a reasonably coarse
partition for φUIφ′. Finally, Section IV-C explains how to
build fully stable refinements for general STL formulas.
A. Stability Conditions for φUIφ′
Figure 8 illustrates the main intuition behind our method.
Consider a partition P={Ji}i∈[N ], where both φandφ′are
stable in P. Suppose φis true in J2, . . . , J 9, and φ′is true
inJ6, . . . , J 8. By definition, φUIφ′is true at time t, if there
exists t′≥tsuch that t′∈t+Iandt′∈S8
m=6Jm. By
Lemma 1, this condition is equivalent to t∈(S8
m=6Jm)−I.
That is, φUIφ′is stably true in (S8
m=6Jm)−I.
346The important observation from Fig. 8 is that the satisfaction
ofφUIφ′can be expressed using a partition Pfor the
subformulas φandφ′. IfφUIφ′is true at time t∈Jn,
there exists a subsequent interval Jm,m≥n, such that
φ′is true in Jm, and φis true in all intermediate intervals
Jn, Jn+1, . . . , J m. The relation between such indices nand
mis denoted by Uφ,φ′
σ,P(in short, UP). The following lemma
then follows from Lemma 1 and the definition of UP.
Lemma 2. Suppose φandφ′are stable for a signal σin a
partition P={Ji}i∈[N ]. Let (n, m) ∈Uφ,φ′
σ,Piff
σ, Jm|=τφ′and σ, Ji|=τφfor any n≤i≤m.
Fort∈Jn,σ, t|=τφUIφ′iff∃(n, m) ∈UP. t∈Jm−I.
The above lemma exactly characterizes the set of time points
in which φUIφ′is true. This gives a necessary and sufficient
condition for φUIφ′to be stable in a refinement interval K
below, denoted by nscdφUIφ′
σ,P(K, n) (in short, nscdP(K, n)).
LetUP(n)denote the image set of nunder the relation UP
(i.e.,UP(n) = {m|(n, m) ∈UP}).
Lemma 3. Suppose φandφ′are stable for a signal σin
P={Ji}i∈[N ]. Let nscdφUIφ′
σ,P(K, n) denote the condition
K⊆S
m∈UP(n)Jm−IorK⊆(S
m∈UP(n)Jm−I)∁.
For an interval K⊆Jn,stableσ
K(φUIφ′)iffnscdP(K, n).
Proof. (⇐) Let t, t′∈K. Suppose σ, t|=τφUIφ′. By
Lemma 2, t∈Jm1−Ifor some (n, m 1)∈UP. This implies
K⊆S
m∈UP(n)Jm−I. Since t′∈K,t′∈Jm2−Ifor some
m2∈UP(n). By Lemma 2, σ, t′|=τφUIφ′.
(⇒) Let t∈S
m∈UP(n)Jm−Iandt′∈(S
m∈UP(n)Jm−I)∁
fort, t′∈K. Then, t∈Jm1−Ifor some m1∈UP(n), but
t′/∈Jm2−Ifor any m2∈UP(n). By Lemma 2, we have
σ, t|=τφUIφ′andσ, t′̸|=τφUIφ′.
Example 4. LetP={{0}, (0,3),{3},(3,6),{6},(6,8)}.
Consider a formula pU(1,3)q, and a signal σsuch that:
i 1 2 3 4 5 6
Ji{0} (0,3){3} (3,6){6} (6,8)
p ⊥ ⊤ ⊤ ⊤ ⊤ ⊤
q ⊤ ⊤ ⊤ ⊥ ⊥ ⊤
ForJ2, observeS
m∈UP(2)(Jm−I) = (−3,2)∪(3,7), where
UP(2) = {2,3,6}. Therefore, pU(1,3)qis stably true in the
subinterval (0,2)⊆J2, and stably false in [2,3]⊆J2.
B. Stable Refinements for φUIφ′
Variable points in a stable partition Pinvolve the rising and
falling edges of a Boolean truth signal for φ[28]. An interval
Ji∈ P has a rising edge, written i∈ ↑Pφ, if φis true in Ji
but false in Ji−1(or there is no previous interval). Similarly,
Ji∈ P has a falling edge, written i∈ ↓Pφ, if φis true in Ji
but false in Ji+1(or there is no next interval).
Definition 6. Given a partition P={Ji}i∈[N ]andi∈[N]:
(1)i∈ ↑Pφiffσ, Ji|=τφ, and i= 1 orσ, Ji−1̸|=τφ; and
(2)i∈ ↓Pφiffσ, Ji|=τφ, and i=Norσ, Ji+1̸|=τφ.Consider Fig. 8. Since {6,7,8} ⊆ UP(n),2≤n≤4, by
Lemma 2, if 6≤m≤8andt∈Jn, then t∈Jm−Iimplies
σ, t|=τφUIφ′. Hence, (S8
m=6Jm)−Idoes not contain
variable points. ForS8
m=6Jm, its endpoints are variable points
for{φ, φ′}, the left endpoint inf(J 6)is a rising edge for
φ′, and the right endpoint sup(J8)is a falling edge for φ′.
Accordingly, the left and right endpoints of (S
6≤m≤8 Jm)−I
are, respectively, inf(J 6)−sup(I)andsup(J8)−inf(I). This
suggests the definition of variable point candidates.
Definition 7. For a formula φUIφ′, a partition P, and a
signal σ, where φandφ′are stable for σinP, the set of
variable point candidates CφUIφ′
σ,P⊆R≥0(in short, CU
P) is:
{v|m∈ ↑Pφ∪ ↑Pφ′, v= inf(J m)−sup(I),cd(m, v )}
∪ {v|m∈ ↓Pφ∪ ↓Pφ′, v= sup( Jm)−inf(I),cd(m, v )},
where cd(m, v )≡ ∃n.(n, m) ∈UP∧inf(Jn)≤v.The
until-refinement of a partition PforφUIφ′, denoted by
Rσ
φUIφ′[P](in short, RU[P]), isRU[P] =P ⊓ Q , where
Qis the partition with the endpoints CU
P∪ {0, τ }.
Not all endpoints of Pare considered for finding variable
point candidates in CU
P; only variable points for {φ, φ′}are
needed. E.g., in the above example, neither inf(J 7)−sup(I)
norsup(J7)−inf(I)is a candidate in CU
P. Ife(CU
P)⊆e(P),
thenP’s until-refinement is just P. This motivates the concept
of maximally stable partitions with respect to a signal σ.
Definition 8. A partition Pismaximally stable forφ, if any
partition that is strictly coarser than Pis not stable for φ.
It follows from Proposition 1 that for a stable partition P,
there exists a unique maximally stable partition, denoted by
maxσ
φ(P), that is coarser than P. Simply put, maxσ
φ(P)is the
partition with variable points as the only endpoints.
Lemma 4. Suppose φis stable for a signal σin a partition
of domain D. LetObe the partition such that e(O)\e(D)is
the set of variable points for φinD. Then, maxσ
φ(P) =O.
A variable point for {φ, φ′}inPis either an endpoint
ofmaxσ
φ(P)or an endpoint of maxσ
φ′(P). The partition
maxσ
φ(P)⊓maxσ
φ′(P)is the coarsest partition that contains
all these variable points. Indeed, variable point candidates CU
P
can be obtained using maxσ
φ(P)⊓maxσ
φ′(P)as follows.
Lemma 5. Given φUIφ′, suppose φandφ′are stable for
σin a partition Pof[0, τ). letObemaxσ
φ(P)⊓maxσ
φ′(P),
where O={Li}i∈[N ]. For any (n, m) ∈UO, we have:
inf(Ln)≤inf(L m)−sup(I) =⇒inf(L m)−sup(I)∈CU
P
inf(Ln)≤sup(Lm)−inf(I) =⇒sup(Lm)−inf(I)∈CU
P
Example 5. In Fig. 8, O= maxσ
φ(P)⊓maxσ
φ′(P)contains
intervals L1=J1,L2=S5
m=2Jm, and L3=S8
m=6Jm. The
left endpoint of L2isinf(J2), and the endpoints of L3−Iare
inf(J6)−sup(I)andsup(J8)−inf(I). Since (2,3)∈UOand
inf(J2)<inf(J6)−sup(I),sup(J8)−inf(I), by Lemma 5,
inf(J6)−sup(I)andsup(J8)−inf(I)∈e(RU[P]).
347The stability of a formula φUIφ′in the until-refinement
RU[P]follows from Lemma 3 and the lemma below.
Lemma 6. LetO= maxσ
φ(P)⊓maxσ
φ′(P), where φandφ′
are stable for σinP. For any intervals Kj∈ RU[P]and
Lk∈ O,Kj⊆Lkimplies nscdO(Kj, k).
Proof Sketch. LetO={Lk}k∈[N]. It follows from Lemma 5
that for each Kj∈ RU[P], ifKj⊆Lnand(n, m) ∈UO,
then either Kj⊆Lm−IorKj⊆(Lm−I)∁holds. Then,
forKj∈ RU[P]andLk∈ O, where Kj⊆Lk, by the above
claim, we can easily see that nscdO(Kj, n)holds.
C. Fully Stable Refinements for STL
We present how to obtain a fully stable refinement for a
formula φ, given a partition that is stable for each proposition
inprop(φ). We inductively build a fully stable refinement for
each subformula. For the negation and conjunction cases, we
apply the existing methods [23], [24] (Proposition 2), and for
theUIcase, we apply the until-refinement in Def. 7.
Definition 9. For an STL formula φ, a signal σ, and a
partition P, where each proposition p∈prop(φ) is stable
forσinP, the φ-refinement Rσ
P(φ)is defined by:
Rσ
P(p) =P Rσ
P(ϕ∧ϕ′) =Rσ
P(ϕ)⊓ Rσ
P(ϕ′)
Rσ
P(¬ϕ) = Rσ
P(ϕ)Rσ
P(ϕUIϕ′) =RU[Rσ
P(ϕ)⊓ Rσ
P(ϕ′)]
Theorem 1. An STL formula φis fully stable for a signal σ
inRσ
P(φ), where each p∈prop(φ) is stable for σinP.
Proof. We proceed by structural induction on φ. The cases of
φ=pandφ=¬ϕimmediately follow from the definitions,
induction hypothesis, and Proposition 2.
•(φ=ϕ∧ϕ′): Let Q=Rσ
P(ϕ)andQ′=Rσ
P(ϕ′). By
induction hypothesis, stableσ
Q(ϕ)andstableσ
Q′(ϕ′)hold. By
the monotonicity of stability with respect to ⊒,stableσ
Q⊓Q′(ϕ)
andstableσ
Q⊓Q′(ϕ′). By Proposition 2, stableσ
Q⊓Q′(ϕ∧ϕ′).
•(φ=ϕUIϕ′): Let Q=Rσ
P(ϕ)⊓ Rσ
P(ϕ′). As shown in
the above case, ϕandϕ′are fully stable for σinQ. Since
RU[Q]⊑ Q ,ϕandϕ′are also fully stable for σinRU[Q].
LetO= maxσ
φ(Q)⊓maxσ
φ′(Q). Consider any interval Kjin
RU[Q]. Since RU[Q]⊑ O , there exists an interval LkinO
such that Kj⊆Lk. By Lemma 6, nscdO(Kj, k)holds. Thus,
by Lemma 3, φUIφ′is stable for σinKj. As a consequence,
φUIφ′is fully stable for σinRU[Q].
Example 6. LetP={{0}, (0,6),{6},(6,8)}. Consider an
STL formula φ=♢[1,∞)(pU(1,3)q)and a signal σsuch that:
P {0} (0,6) {6} (6,8)
p ⊤ ⊤ ⊤ ⊤
q ⊥ ⊥ ⊤ ⊤
Since{6} ∈ P has a rising edge and (6,8)∈ P has a falling
edge, CpU(1,3)q
σ,P is{3,7}. Thus, Rσ
pU(1,3)q[P] =Q, where,
Q={{0}, (0,3),{3},(3,6),{6},(6,7),{7},(7,8)}. Then:
Q {0} (0,3){3}(3,6){6}(6,7){7}(7,8)
pU(1,3)q⊥⊥⊥⊤⊤⊤⊥⊥
φ ⊤⊤⊤⊤⊥⊥⊥⊥Similarly, since (3,6)∈ Q has a rising edge and (6,7)∈ Q
has a falling edge, Cσ,Q
φ={6}, and therefore Rσ
φ[Q] = Q.
Consequently, Rσ
P(φ), the φ-refinement of P, isQ.
The size of the until-refinement Rσ
ϕUIϕ′[P]is at most 3N
for a partition P={Ji}i∈[N ], because each interval Ji−Ican
introduce two fresh endpoints. Example 7 below exhibits the
worst case. As a result, the size of the φ-refinement Rσ
P(φ)
is at most O(k·t(φ)·2d(φ)), where t(φ) is the number of
UIandd(φ)is the nesting depth of UI, given kthe size of
a base partition for propositions.
Example 7. Consider φU(0.1,0 .2)φ′andP={Ji}i∈[2n] . Let
J2k−1={k−1},J2k= (k−1, k), and for 1≤k≤n:
σ, J2k−1∪J2k|=τφ,σ, J2k−1̸|=τφ′, and σ, J2k|=τφ′.
Each time point k,1≤k≤n, is then a variable point, and
(2k−1,2k)∈UP. Therefore, CU
P=Sn
k=1{k−0.1, k−
0.2}, where all endpoints of Pcontributes to the size of CU
P.
Because CU
P∩e(P) =∅,|e(RU[P])|= 3n.
The work [9] gave an example of an STL formula φwhere a
signal has O(2d(φ))variable points for the set of subformulas
sub(φ). The worst-case exponential size of Rσ
P(φ) is not
avoidable. The refinement construction in [22] also has the
same upper bound O(k·t(φ)·2d(φ)). But our φ-refinement
minimizes “redundant” variable points to reduce the partition
size, as mentioned in Sec. III-C, whereas the existing methods
[22], [27] do not apply such a reduction.
V. E NCODING OF BOUNDED SATISFIABILITY FOR STL
The bounded STL satisfiability problem is to check whether
there exists a bounded signal that satisfies φand has a finite
number of variable points. This section presents a symbolic
method to encode the bounded satisfaction of STL in a
decidable fragment of first-order logic using Theorem 1. We
symbolically represent discrete signals using logical variables
(Sec. V-A), and identify constraints on those variables imposed
by the STL semantics for a discrete signal (Sec. V-B) and by
the full stability of a partition (Sec. V-C).
A. Symbolic Representation with Full Stability
For an STL formula φ, we consider the problem of finding a
discrete signal ζφ= (P , θ)with at least one matching signal
(see Sec. III-B). We symbolically encode this problem as a
first-order formula so that there exists such a discrete signal ζφ
iff the encoding is satisfiable. Discrete signals are symbolically
represented using first-order variables as follows.
Definition 10. For an STL formula φandn∈N, a symbolic
discrete signal isςφ,n= ({γj}j∈[n−1] ,{χi
ϕ}i∈[2n] ,ϕ∈sub(φ) ),
where each γjis a real variable and χi
ϕis a Boolean variable.
Intuitively, ςφ,ninvolves a symbolic partition {Ji}i∈[2n]
such that J2j−1={γj−1}andJ2j= (γ j−1, γj)for each
j∈[n], where γ0= 0 andγn=τ. The variables for the
left and right endpoints of Jiare denoted by l(Ji)andr(Ji),
respectively. Each Boolean variable χi
ϕ, represents the truth
value of subformula ϕin symbolic interval Ji.
348J10
J2 J3γ1
J4J5γ2
J6 J7γ3
J8τ= 8
pχ1
pχ2
pχ3
pχ4
pχ5
p χ6
p χ7
pχ8
p
qχ1
qχ2
qχ3
qχ4
qχ5
q χ6
q χ7
qχ8
q
pUIqχ1
ψχ2
ψχ3
ψχ4
ψχ5
ψχ6
ψχ7
ψχ8
ψ
φχ1
φχ2
φχ3
φχ4
φχ5
φ χ6
φ χ7
φχ8
φ
Fig. 9. A symbolic discrete signal ςφ,4forφ=♢J(pUIq)
An assignment αof the variables in a symbolic discrete
signal ςφ,ngives a concrete discrete signal α(ςφ,n) = (P , θ),
called an instance ofςφ,n, where P={α(Ji)}i∈[2n] is a
concrete partition, and θis a concrete truth mapping with
θ(ϕ, i) =α(χi
ϕ)for each ϕ∈sub(φ)andi∈[2n].
Example 8. Figure 9 illustrates a symbolic discrete signal ςφ,4
forφ=♢J(pUIq)andn= 4. The truth of each subformula
ϕin the i-th symbolic interval Ji,1≤i≤8, is represented
as Boolean variable χi
ϕ. For an assignment αwithγ17→1
andγ27→3,α(J3) ={1}andα(J4) = (1, 3).
B. Encoding of Discrete Signals for STL
In STL, the truth of a non-atomic formula φis determined
by the truth values of φ’s subformulas. For a symbolic discrete
signal ςφ,n, variable χi
φforφand variables for its subformulas
must satisfy certain constraints imposed by the semantics of
STL. We can easily see the constraints χi
¬φ=¬χi
φfor
negation and χi
φ∧φ′=χi
φ∧χi
φ′for conjunction.
To identify constraints for φUIφ′, we need to obtain an
equivalent formula, where the satisfaction of each subformula
depends only on a single interval in a partition P. For this
purpose, we consider a “global-time” temporal operator UK
I
with an extra global time interval K. The satisfaction of
φUK
Iφ′is bounded by the global interval Kas follows.
Definition 11. [22] For a signal σand a time point t, the
satisfaction of φUK
Iφ′is defined by:
σ, t|=τφUK
Iφ′⇐⇒ (∃t′≥t)t′∈[0, τ)∩K, t′∈t+I,
σ, t′|=τφ′,(∀t′′∈[t, t′]∩K)σ, t′′|=τφ
Using global time constraints, we can apply the syntactic
separation method [22] to syntactically decompose a formula
φUK
Iφ′into a Boolean combination of the subformulas φ
andφ′that depend only on disjoint segments of the global
interval Kas follows. We can repeatedly apply this procedure
to obtain a formula separated at multiple time points.
Proposition 3. [22] For two successive intervals K1andK2,
φUK1∪K 2
I φ′≡φUK1
Iφ′∨(□K1
[0,∞)φ∧φUK2
Iφ′), where
K1∪K2is an interval, K1∩K2=∅, and sup(K1) = inf(K 2).
Now consider a partition P={Ji}i∈[N ]of domain [0, τ),
where φandφ′are stable for a signal σinP. Let vi∈Ji,
for each i∈[N], be a time sample from the i-th interval Ji,
andLn=S
n≤j≤NJn, for each n∈[N], be the n-th suffix
interval. We then have the following separation law.Lemma 7. For any indices i, n∈[N]with1≤i≤n≤N:
σ, vi|=τφULn
Iφ′iff (v i∈Jn−Iandσ, vn|=τφ∧φ′) or
(σ, v n|=τφandσ, vi|=τφULn+1
Iφ′).
Proof Sketch. By Proposition 3, φULn
Iφ′is equivalent to
φUJn
Iφ′∨(□Jn
[0,∞)φ∧φULn+1
Iφ′). By Lemma 1 and the
stability of Jn, (1) σ, vi|=τφUJn
Iφ′iffvi∈Jn−Iand
σ, vn|=τφ∧φ′, and (2) σ, vi|=τ□Jn
[0,∞)φiffσ, vn|=τφ.
The truth values of φandφ′at a time sample vi∈Ji
represent the truth values of φandφ′in the entire interval
Ji, provided φandφ′are stable for a signal σinJi. Since
sup(Li) =τ,σ, vi|=τφUIφ′iffσ, vi|=τφULi
Iφ′. By
repeatedly applying the above separation law, the satisfaction
ofφULi
Iφ′atvi∈Jican be expressed using the satisfaction
ofφandφ′at time samples vi, vi+1, . . . , v N.
This allows us to define the constraints between a variable
χi
φUIφ′and variables χn
φandχn
φ′,1≤i≤n≤N. Let a
termuirepresent a time sample from symbolic interval Ji. A
constraint ρi
ϕUIϕ′(n)—which corresponds to the satisfaction
ofϕULn
Iϕ′at time sample ui—is then inductively defined
as follows. As explained above, ρi
ϕUIϕ′(i)corresponds to the
satisfaction of φUIφ′at time sample ui.
Definition 12. For1≤i≤n≤N,ui= (l(Ji) +r(Ji))/2,
ρi
ϕUIϕ′(N+1) = ⊥, and ρi
ϕUIϕ′(n)is the first-order formula
(ui∈Jn−I∧χn
ϕ∧χn
ϕ′)∨(χn
ϕ∧ρi
ϕUIϕ′(n+ 1)).
The resulting constraint for a symbolic discrete signal ςφ,n
is a quantifier-free first-order formula ΨSTL[ςφ,n]below. We
denote by α(ΨSTL[ςφ,n]), for an assignment α, the formula
obtained by replacing each variable xbyα(x).
Definition 13. Forςφ,n= ({γj}j∈[n−1] ,{χi
ϕ}i∈[2n],ϕ∈sub(φ) ),
ΨSTL[ςφ,n]is the conjunction of the following equalities:
χi
¬ϕ=¬χi
ϕ, χi
ϕ∧ϕ′=χi
ϕ∧χi
ϕ′, χi
ϕUIϕ′=ρi
ϕUIϕ′(i)
Example 9. Consider ςφ,3with J4= (γ1, γ2),J5={γ2},
andJ6= (γ2, τ). Then, χ4
pUIq=ρ4
pUIq(4),ρ4
pUIq(7) =⊥,
andρ4
pUIq(n), for 4≤n <7, is the quantifier-free formula
((γ1+γ2)/2∈Jn−I∧χn
p∧χn
q)∨(χn
p∧ρ4
pUIq(n+ 1)) .
Consider an assignment αfor a symbolic discrete signal
ςφ,n. Suppose that the STL formula φis fully stable for a
signal σin the corresponding partition {α(Ji)}i∈[2n] , where
the signal σ“matches” the assignment αfor each proposition
p∈prop(φ) (i.e., p(σ(t)) = α(χi
p)for any t∈α(Ji)in
each interval α(Ji)). Then, ΨSTL[ςφ,n]exactly captures the
constraints by the semantics of STL as follows.
Lemma 8. Suppose that φis fully stable for a signal σin
{α(Ji)}i∈[2n] , and (∀t∈α(Ji))p(σ(t)) = α(χi
p)for each
p∈prop(φ). The following are equivalent: (i) α(ΨSTL[ςφ,n])
is true. (ii) α(χi
ϕ) =⊤iffσ, α(Ji)|=τϕfor each ϕ∈sub(φ).
Proof Sketch. The proof is by structural induction on φ. The
cases of p,¬ϕ, and ϕ∧ϕ′follow from the definitions,
conditions χi
¬ϕ=¬χi
ϕandχi
ϕ∧ϕ′=χi
ϕ∧χi
ϕ′, and induction
349cand ϕUIϕ′≡2n^
m=1[(↑m
ϕ∨ ↑m
ϕ′)→cdm
ϕ,ϕ′(l(Jm)−sup(I ))]
∧[(↓m
ϕ∨ ↓m
ϕ′)→cdm
ϕ,ϕ′(r(Jm)−inf(I))]
cdm
ϕ,ϕ′(v)≡Vm
n=1((Un,m
ϕ,ϕ′∧l(Jn)≤v)→endpv
n,m)
Un,m
ϕ,ϕ′≡χn
ϕ∧Un+1,m
ϕ,ϕ′ ↑m
ϕ≡χm
ϕ∧ ¬χm−1
ϕ
Um,m
ϕ,ϕ′≡χm
ϕ∧χm
ϕ′ ↑1
ϕ≡χ1
ϕ
endpv
n,m≡endpv
n,n∨endpv
n+1,m ↓m
ϕ≡χm
ϕ∧ ¬χm+1
ϕ
endpv
m,m≡v=l(Jm)∨v=r(Jm)↓2n
ϕ≡χ2n
ϕ
Fig. 10. Auxiliary predicates for ΨPAR[ςφ,n]
hypothesis. The case of ϕUIϕ′follows from the full stability
of{α(Ji)}i∈[2n] , induction hypothesis, and Lemma 7.
C. Encoding of Fully Stable Partitions
Figure 10 shows several auxiliary predicates to encode the
“building blocks” of the until-refinement condition in Def. 7.
The predicates Un,m
ϕ,ϕ′,↑m
ϕ, and↓m
ϕrepresent (n, m) ∈UP,
m∈ ↑Pϕ, and m∈ ↓Pϕ, respectively (cf. Lemma 2 and
Def. 6). The predicate endpv
n,mrepresents that vis an endpoint
of one of Ji,n≤i≤m, and cand ϕUIϕ′represents that all
candidates in CU
Pare endpoints in {Ji}i∈[2n] .
Theφ-refinement condition in Def. 9 can then be encoded
as a quantifier-free formula using those auxiliary predicates:
Definition 14. For an STL formula φand a symbolic discrete
signal ςφ,n,ΨPAR[ςφ,n]is the conjunction of the conditions
cand ϕUIϕ′for each subformula ϕUIϕ′∈sub(φ).
Example 10. Consider ςpU(1,3)q,1= (∅,{χi
p, χi
q, χi
pUIq}i∈2)
forpU(1,3)q. Then, cand pU(1,3)qis the first-order formula:
((↑1
p∨ ↑1
q)→cd1
p,q(−3)) ∧((↓1
p∨ ↓1
q)→cd1
p,q(−1))
∧((↑2
p∨ ↑2
q)→cd2
p,q(−3)) ∧((↓2
p∨ ↓2
q)→cd2
p,q(τ−1))
because γ0= 0,γ1=τ,J1={0}, and J2= (0, τ). We show
below the encodings for some auxiliary predicates:
cd1
p,q(−3)≡((U1,1
p,q∧0≤ −3)→endp−3
1,1)
cd2
p,q(−3)≡V2
n=1((Un,2
p,q∧l(Jn)≤ −3)→endp−3
n,2)
cd2
p,q(τ−1)≡((U1,2
p,q∧0≤τ−1)→endpτ−1
1,2)
∧((U2,2
p,q∧0≤τ−1)→endpτ−1
2,2)
endpτ−1
1,2≡endpτ−1
1,1∨endpτ−1
2,2
endpτ−1
2,2≡(τ−1 = 0∨τ−1 =τ)
↑1
p≡χ1
p ↓1
p≡χ1
p∧ ¬χ2
pU1,2
p,q≡χ1
p∧U2,2
p,q
↑2
p≡χ2
p∧ ¬χ1
p↓2
p≡χ2
p U2,2
p,q≡χ2
p∧χ2
q
Consider an assignment αfor a symbolic discrete signal
ςφ,n.ΨPAR[ςφ,n]asserts that P={α(Ji)}i∈[2n] includes
all variable point candidates for all subformulas ϕUIϕ′.
Therefore, the φ-refinement of PisPitself, and Theorem 1
implies that φis fully stable for a signal σinP, provided the
signal σmatches αfor each proposition in φ.
Lemma 9. Suppose (∀t∈α(Ji))p(σ(t)) = α(χi
p)for each
p∈prop(φ). The following are equivalent: (i) Rσ
P(φ) = PforP={α(Ji)}i∈[2n] , and α(χi
ϕ) =⊤iffσ, α(Ji)|=τϕfor
each ϕ∈sub(φ). (ii) α(ΨPAR[ςφ,n]∧ΨSTL[ςφ,n])is true.
Proof Sketch. ΨPAR[ςφ,n]enforces Rσ
P(ϕ) = Pfor each
subformula ϕ∈sub(φ), where P={α(Ji)}i∈[2n] . The
lemma then easily follows by structural induction on φfrom
the correctness of ΨPAR[ςφ,n], Lemma 8, and Theorem 1.
The remaining question is how to encode the existence of
matching signals. For bounded satisfiability, we only need to
consider piecewise-constant signals, which can be represented
as a sequence of variables ⃗ ν1, ⃗ ν2, . . . , ⃗ ν 2n. Let
ΦSIG[ςφ,n]≡(∃⃗ ν1, . . . , ⃗ ν 2n)V
p∈prop(φ)V2n
i=1(χi
p=p(⃗ νi))
∧0≤γ1≤ ··· ≤ γn−1< τ,
where χi
p=p(⃗ νi)asserts that pholds in the i-th interval. The
bounded satisfiability of φcan be reduced to the satisfiability
of a first-order encoding as follows.
Theorem 2. An STL formula φis satisfiable by a bounded
signal with a finite set of variable points iff for some number
n∈N,χ1
φ∧ΨPAR[ςφ,n]∧ΨSTL[ςφ,n]∧ΦSIG[ςφ,n]is satisfiable.
Proof. (⇒) Suppose σ,0|=τφfor a signal σwith a finite
setTof variable points for sub(φ). For the partition Pwith
e(P) =T∪ {0, τ }, consider the φ-refinement Rσ
P(φ), where
|Rσ
P(φ)|= 2n. Let vibe an element of each i-th interval of
Rσ
P(φ), and αbe an assignment with {α(Ji)}i∈[2n] =Rσ
P(φ),
α(⃗ νi) =σ(vi), and α(χi
ϕ) =⊤iffσ, vi|=τϕ, for i∈[2n]
andϕ∈sub(φ). By Lemma 9, αsatisfies the encoding. (⇐)
Suppose the encoding is satisfiable by an assignment α. Let σ
be a piecewise-constant signal with ∀t∈α(Ji). σ(t) = α(⃗ νi).
Then, for each p∈prop(φ), (∀t∈α(Ji))α(χi
p) =p(σ(t)).
It follows from Lemma 9 that α(χ1
φ) =⊤iffσ,0|=τφ.
VI. SMT-B ASED MODEL CHECKING ALGORITHM
We now consider the bounded model checking problem of
an STL formula φfor a hybrid automaton H, stated in Def. 4.
This problem is equivalent to finding a bounded trajectory σof
Hthat satisfies the negated formula ¬φ. Thanks to Lemma 9,
the only remaining challenge is to encode the existence of
matching bounded trajectories of H.
A. Encoding of Matching Bounded Trajectories
We follow an SMT-based approach for the reachability of
hybrid automata [18], [29] to encode boundary trajectories of
H. The reachability of Hcan be reduced to the satisfiability
of an SMT formula, provided init,inv,flow, and jump
conditions can be encoded in SMT [18]. Finding a bounded
trajectory σofHwith at most kvariable points for prop(φ)
can be considered as a special case of reachability [22].
Figure 11 shows the first-order encoding ΦH
TRJ[ςφ,n]for a
matching trajectory σ∈H. An initial state s0
0satisfies the init
condition, and there are n−1time points γj,1≤j≤n−1,
at which discrete jumps canoccur from state st
j−1tos0
j. The
value of σevolves from state s0
jtost
jaccording to the flow
condition, satisfying inv(indicated by cnt(s0
j, st
j)). The truth
of each proposition pis stably χi
pin each interval Ji(indicated
350ΦH
TRJ[ςφ,n]≡(∃s0
0, . . . , st
n−1) 0 = γ0≤ ··· ≤ γn−1< γn=τ
∧init(s0
0)∧Vn−1
j=1(jump (st
j−1, s0
j)∨st
j−1=s0
j)
∧Vn−1
j=0cnt(s0
j, st
j)∧V
p∈prop(φ)V2n
i=1matchi
p
cnt(s0
j, st
j)≡st
j=flow(s0
j, γj+1−γj)
∧ ∀u∈[0, γj+1−γj).inv(flow (s0
j, u))
match2j+1
p≡(p(s0
j) =χ2j+1
p)
match2j+2
p≡((∀u∈(0, γ j+1−γj). p(flow (s0
j, u)))∧χ2j+2
p)
∨((∀u∈(0, γ j+1−γj).¬p(flow (s0
j, u)))∧ ¬χ2j+2
p)
Fig. 11. Encoding ΦH
TRJ[ςφ,n]of matching trajectories (adapted from [22])
bymatchi
p). The equality st
j−1=s0
jallows the truth of a
proposition to change without jumps. By construction:
Lemma 10. ΦH
TRJ[ςφ,n]is satisfiable by an assignment αiff
there exists a trajectory σ∈H, with at most n−1jumps,
where (∀t∈α(Ji))p(σ(t)) = α(χi
p)for each p∈prop(φ).
Finally, in a similar way to the case of bounded satisfiability
(Theorem 2), the bounded model checking problem of an STL
formula φfor a hybrid automaton Hcan be reduced to the
satisfiability of a first-order encoding as follows.
Theorem 3. H,0̸|=n
τφholds iff for some number N≥n,
¬χ1
φ∧ΨPAR[ςφ,N]∧ΨSTL[ςφ,N]∧ΦH
TRJ[ςφ,N]is satisfiable.
B. Algorithm
Our model checking algorithm is shown in Alg. 1. ΨPARand
ΨSTLare in linear arithmetic. For polynomial flow conditions,
ΦH
TRJis in nonlinear real arithmetic, supported by SMT solvers
[38]–[40]. For flow conditions with transcendental functions,
the satisfiability of ΦH
TRJcan be undecidable, but there are
approximate solvers [41], [42]. Our algorithm is refutationally
complete for bounded trajectories with finite variable points,
assuming an oracle for the satisfiability of the encoding.
Algorithm 1: Bounded STL Model Checking
Input: Hybrid automaton H,formula φ,bounds τandN
1forn= 1 toNdo
2 ΦH
TRJ←− encoding of H’s trajectories (Fig. 11);
3 foreach ϕ∈sub(φ) do
4 ΨSTL←− add conditions for χi
ϕ,i∈[2n] (Def. 13);
5 ΨPAR←− add full stability conditions for ϕ(Def. 14);
6 ifcheckSat(¬χ1
φ∧ΨPAR∧ΨSTL∧ΦH
TRJ)isSatthen
7 return counterexample(result.satAssignment );
8return True;
For a bound n, the entire encoding size is O(n|H|+n2|φ|).
The size of ΦH
TRJisO(n|H|). The size of ΨSTLisO(n2|φ|),
as there is a condition for each subformula and each i-th step,
i∈[2n], where the size of the condition for ϕUIϕ′isO(i).
ForΨPAR, all predicates in Fig. 10 can be encoded as formulas
of size O(n2|φ|), using a typical encoding method to introduce
extra Boolean variables for predicate instances [43].
As mentioned in Sec. III-C, a bound parameter kof the
previous algorithm [22] denotes the number of variable pointsforprop(φ), and the size of the encoding is O(k·t(φ)·2d(φ)),
with t(φ) the number of UIandd(φ)the nesting depth of
UI. Because the size of a φ-refinement is O(k·t(φ)·2d(φ)), in
principle, our algorithm needs a larger bound than the previous
algorithm. However, in practice, the size of a φ-refinement can
be much smaller than in the worst case (see Sec. VII).
C. Handling Universal Quantification
The encoding ΦH
TRJincludes universal quantification over
time (e.g., cnt(s0
j, st
j)andmatchi
p), as in typical SMT-based
methods for the reachability of hybrid automata [18], [29].
Several SMT solvers, including Z3 [38] and Yices2 [39],
provide limited support for these ∃∀-formulas, but require high
computational complexity. Our algorithm can be combined
with two methods to remove universal quantification.
1) Quantifier-Free Encoding [44]: For polynomial hybrid
automata, such ∃∀-conditions can be encoded as quantifier-free
formulas. When a polynomial fis monotonic on an interval
[a, b] and a predicate pis convex, ∀t∈[a, b]. p(f (t)) can be
reduced to p(f(a))∧p(f(b)). Since the monotonicity of fcan
be expressed as a convex invariant of the derivative ˙f, we can
obtain a quantifier-free formula by applying this repeatedly.
2) Invariant Simplification: For invariant STL properties of
the form p→□Iq, the model checking problem is equivalent
to the reachability. Finding a counterexample of p→□Iqcan
be reduced to checking whether there exists a state satisfying
¬qthat is reachable within the time interval Ifrom an initial
state satisfying p. Therefore, universal quantifiers in matchi
p
can be safely replaced by existential quantifiers.
VII. E XPERIMENTAL EVALUATION
We have implemented our algorithm of Alg. 1, along with
simplification methods in Sec. VI-C, using Yices2 [39] as the
underlying SMT solver. This section experimentally evaluates
our technique by addressing the following research questions:
RQ1 How effective is our algorithm compared to the previous
algorithm [22] for bounded STL model checking?
RQ2 How effective is our encoding compared to the previous
encoding [22] for bounded STL satisfiability checking?
RQ3 How effective is our approach compared to reachability
analysis techniques for invariant STL properties?
We have run all experiments on Intel Xeon 2.8GHz with
256 GB memory. More details on the benchmark models and
experiments can be found in the supplementary material [30].
A. RQ1: STL Model Checking of Hybrid Automata
We consider the following hybrid automata models (adapted
from [22], [35], [45], [46]): autonomous cars (Car), thermostat
(The) and water tank (Wat) systems, load management of
batteries (Bat), and railroad gate controllers (Rai). We use
two variants of continuous dynamics: linear dynamics, and
polynomial dynamics of degree 2. For each model, we use
four STL formulas: φd
⊤holds, and φd
⊥has a counterexample
ford= 1,2; and φb
1contains one temporal operator, and φb
2
contains two nested temporal operators for b=⊤,⊥[30].
351TABLE I
BOUNDED MODEL CHECKING OF STL ( TIME IS IN SECONDS ,AND ‘-’DENOTES A TIMEOUT )Dynamics
Model
MethodNo
counterexample Counterexample found at n
φ1
⊤φ2
⊤φ1
⊥φ2
⊥
|Enc|
|ς|Time |Enc| |ς |Time |Enc| | ς|Time n |Enc| | ς|Time nLinear
(N = 50)CarNew 8.1
50 112 14.7 50 1,455 1.7 9 1.4 9 3.2 14 9.15 14
[22] 67.2 154 - 604 466 - 5.5 48 2.23 8 - - - -
TheNew 8.1
50 3,391 14.7 50 5,734 1.9 10 1.9 10 1.2 4 1.2 4
[22] 67.2 154 - 604 466 - 7.7 58 1.7 10 9.6 64 11.2 4
W
atNew 8.5 50 326 15.2 50 779 2.2 11 6.9 11 2.9 12 36.4 12
[22] 67.6 154 - 316 366 - 7.7 58 92.4 10 - - - -
BatNew 12.8
50 140 18.6 50 242 1.6 6 0.7 6 2.5 8 70.5 8
[22] 72.3 154 395 608 466 1,135 2.4 19 0.8 5 13.6 80 249 4
RaiNew 6.5
50 74.7 13.2 50 152 1.0 6 0.1 6 0.9 5 0.1 5
[22] 65.6 154 54.8 1,086 678 419 2.8 33 0.1 5 5.7 44 1.6 4Polynomial
(N = 20)CarNew 5.7
20 56.8 7.2 20 4.5 2.3 7 2.3 7 2.8 8 7.5 8
[22] 16.2 64 - 113 196 15.2 5.5 43 5.2 7 - - - -
TheNew 3.3
20 4.4 4.8 20 23.1 0.9 4 0.5 4 0.9 4 0.9 4
[22] 13.8 64 - 110 196 - 1.6 16 1.2 4 9.0 52 1,087 4
W
atNew 3.5 20 28.4 5.0 20 4.8 0.8 4 0.2 4 1.2 5 2.4 5
[22] 14.0 64 - 111 196 15.0 1.5 16 0.5 4 - - - -
BatNew 5.1
20 14.1 6.2 20 6.4 2.1 5 1.7 5 1.5 5 0.6 5
[22] 15.7 64 73.0 112 196 232 3.0 16 1.1 4 13.6 80 197 4
RaiNew 3.0
20 26.7 4.5 20 78.0 1.1 6 0.5 6 1.0 5 0.6 5
[22] 13.6 64 199 201 288 - 2.9 33 0.7 5 - - - -Encoding
Size
102103104105106
 1  2  3  4  5
 1  2  3  4  5
Ex
ecution Time
10-210-1100102103
 1  2  3  4  5
 1  2  3  4  5T/O:
d4, d5
Fig.
12. Bounded Satisfiability of STL (New:
filled boxes, [22]: empty boxes)
We have performed bounded model checking of these STL
properties, up to bound N= 50 for linear models, and N= 20
for polynomial models. We assign different time bounds τ
to different models [30], since τdepends on different model
parameters. We measure the size of the SMT encoding, the size
of the symbolic discrete signal, and the cumulative execution
times to run STL model checking, including SMT solving by
the underlying solver. We set a timeout of 120minutes.
The experimental results are summarized in Table I. |Enc|
denotes encoding sizes (in thousands), given by the number of
connectives in the encoding. |ς|denotes the size of symbolic
discrete signal ς, given by the number of real variables. For the
cases with counterexamples, the table also shows the smallest
bound n≤Nfor which a counterexample is found.
As discussed in Sec. VI-B, bounds have different meanings
in our algorithm and the previous algorithm [22]. For our
algorithm, a bound corresponds to the size of a fully stable
φ-refinement, and therefore |ς|is the same as the bound. For
[22], a bound denotes the number of variable points for the set
of propositions, and thus |ς|is usually larger than the bound.
This can result in huge differences in the encoding size.
As shown in Table I, our algorithm significantly outperforms
the previous algorithm [22] in most cases. In particular, our
algorithm shows much better performance for complex STL
formulas with nested temporal operators (φ2
⊤andφ2
⊥). The
performance improvement is due to the much compact size of
the encoding by our method. E.g., for φ2
⊤and linear cases,
our algorithm produces 20–80 times smaller encodings.Since different notions of bound nare used, the previous
algorithm often found counterexamples of φ1
⊥andφ2
⊥at a
smaller bound. Thanks to our partition construction method,
the differences are often very minor (0 or1). The only
exceptional case is Bat with linear dynamics for φ2
⊥: a
counterexample was found at k= 4by the previous algorithm
but at k= 8by our algorithm. Even in this case, our algorithm
performed much better than the previous one.
B. RQ2: Bounded STL Satisfiability Checking
To evaluate the effectiveness of our encoding for ΨPARand
ΨSTL, We have performed bounded STL satisfiability checking
using Theorem 2. We randomly generate 250 STL formulas
of different sizes and complexity [30]: specifically, there are
50formulas for each nesting depth 1≤d≤5. We measure
the execution time and the size of generated SMT formulas,
up to bound N= 20 with a timeout of 30minutes.
Figure 12 summarizes the experimental results in box plots.
The x-axis shows nesting depth d, and the y-axis shows
encoding sizes and execution times (seconds), accordingly, in
a log scale. Filled boxes indicated our encoding method, and
empty boxes indicates the previous method [22]. Outliers are
plotted as individual points in the box plots.
As seen, our method produced much smaller encodings that
can be solved in a much shorter time. This improvement tends
to be more apparent for more complex formulas: for example,
ford= 5, the previous method mostly timed out, whereas our
method only needed less than 3seconds on average.
352TABLE II
ANALYZING INVARIANT PROPERTIES
ModelLinear (N = 50) Polynomial (N = 10)
ONew New HC SE FS ONew New SE FS
CarI⊤17.1 133 0.57 3.62 16.4 1.93 2.21 825 75.1
I⊥0.01 0.02 0.02 3.72 1.41 1.53 2.92 803 9.23
ThermI⊤4.52 37.1 4.21 2.23 18.2 1.44 2.92 3.12 5.82
I⊥0.01 0.02 0.03 2.24 1.41 0.02 0.21 3.01 1.42
WaterI⊤3.75 27.1 8.72 1.72 56.1 8.51 5.92 0.01 0.08
I⊥0.01 0.02 0.04 1.71 1.91 0.42 114 0.01 0.14
BattryI⊤4.41 24.0 1.82 0.07 43.1 1.33 1.41 0.01 20.1
I⊥0.23 0.52 0.02 0.06 6.42 0.21 6.91 0.01 4.53
RailI⊤1.91 32.0 0.69 0.64 2.01 0.82 1.52 0.23 2.81
I⊥0.01 0.02 0.02 0.63 5.11 0.03 0.41 0.24 2.31
C. RQ3: Comparison with Reachability Analysis Methods
We compare our approach with three reachability analysis
tools for hybrid automata: HyComp [18] (HC), SpaceEx [15]
(SE), and Flow* [16] (FS). We consider two versions of
our algorithm: one with invariant simplification (ONew) in
Sec. VI-C, and one without invariant simplification (New). For
each model, we consider two invariant properties that can be
handled by those tools: I⊤holds, and I⊥does not hold.
We measure the execution times for analyzing the invariant
properties with a timeout of 15minutes. Since each tool has
a different notion of bounds, we use the number of jumps
Nand the maximum time horizon τas the common bound
parameters (which are “encoded” in the models). For SpaceEx,
we use PHA Ver for linear models, and STC for polynomial
models. For Flow*, we use adaptive steps and TM orders 1
(for linear) and 2 (for polynomial). We use BMC for HyComp.
The experimental results are summarized in Table II, with
execution times in seconds. The results for polynomial models
do not include HyComp, which does not support nonlinear
polynomial dynamics. For I⊤, the table shows the time taken
to prove the absence of counterexamples. For I⊥, the table
shows the time taken to find a counterexample.
We observe that our algorithm with invariant simplification
(ONew) has comparable performance to the other tools for
both invariant properties I⊤andI⊥. The implementation
without invariant simplification (New) often shows slower
performance, especially for I⊤. This problem is caused by
stability conditions matchi
pinΦH
TRJ, which can be avoided in
ONew when analyzing simple invariant properties.
D. Threats to Validity
Two major threats to internal validity are (1) whether the
performance improvements are due to the proposed partition
construction and encoding methods, and (2) whether different
notions of bounds have unintended effects on the evaluation
of the performance. To address these threats, we applied
exactly the same simplification methods in Sec. VI-C for the
experiments in Sec. VII-A and Sec. VII-B, and evaluated
the performance based on the smallest bound for which a
counterexample is found for the experiment in Sec. VII-A.One threat to external validity is the possible bias of the
benchmark models and formulas used in the experiments. We
tried to reduce this threat by using various linear/polynomial
hybrid automata models, and using a variety of STL properties
with different sizes, complexity, truth values, etc. Another
threat is that our algorithm is compared only to the most
related previous work for general STL formulas; comparing
with the other STL model checking algorithm [21] is difficult,
because there is no implementation available.
VIII. R ELATED WORK
The most closely related work is the paper [22] which
proposes the refutationally complete bounded STL model
checking algorithm. As discussed in Sec. III-C, the algorithm
[22] does not take into account reducing the size of discrete
signals, and thus often produces a very complex encoding. In
contrast, our method uses a precise condition for discretizing
signals and produces a much simpler encoding.
Another STL model checking method [21] uses reachable
set computation, instead of SMT solving. Unlike our method,
the algorithm [21] is incomplete, since only finite concrete
sampled time points are considered, and thus the correctness
cannot be guaranteed. In contrast, our method symbolically
encodes discrete signals without any loss of information.
There are a couple of methods for verifying LTL properties
of hybrid systems using signal discretization: [23] proposes a
deductive system for LTL, and [24] presents a requirement
validation method for an extension of LTL. Only untimed
temporal operators are considered in [23], [24]. We address
the challenge of optimally discretizing signals involving UI.
A discretization of signals with UIhas been studied for
MITL in the context of real-time systems. A refinement for
φUIφ′can be built using multiples of I’s endpoints [27]. A
signal is further discretized using a unit duration based on a
relative interval width [28]. These methods produce very fine
refinements, which are not scalable for hybrid systems.
Our work is related to reachability analysis techniques for
hybrid automata. They can guarantee the correctness, but only
deal with invariant properties. There are roughly two kinds of
methods: reachable-set computation [15], [16], [47]–[50], and
SMT-based techniques [18], [29], [42], [51]–[53].
IX. C ONCLUDING REMARKS
We have presented a new SMT-based model checking
algorithm for STL properties of hybrid systems. Our algorithm
is based on a new theoretical result to build small but complete
discretized signals for the bounded satisfiability of STL. We
have developed a modular translation method to encode the
bounded satisfiability of STL in SMT. We have leveraged our
translation technique to obtain an efficient SMT-based STL
model checking algorithm that is still refutationally complete
for bounded signals, but that produces much simpler encodings
and results in much better performance.
Currently, our method can only be applied to SMT-based
approaches. We should therefore investigate refutationally
complete STL model checking algorithms that can be inte-
grated with reachable-set computation methods.
353REFERENCES
[1] O. Maler and D. Nickovic, “Monitoring temporal properties of contin-
uous signals,” in Proc. FORMATS, ser. LNCS, vol. 3253. Springer,
2004, pp. 152–166.
[2] X. Jin, J. V . Deshmukh, J. Kapinski, K. Ueda, and K. Butts, “Powertrain
control verification benchmark,” in Proc. HSCC. ACM, 2014.
[3] R. P. Goldman, D. Bryce, M. J. Pelican, D. J. Musliner, and K. Bae,
“A hybrid architecture for correct-by-construction hybrid planning and
control,” in Proc. NFM, ser. LNCS, vol. 9690. Springer, 2016.
[4] V . Raman, A. Donz ´e, D. Sadigh, R. M. Murray, and S. A. Seshia,
“Reactive synthesis from signal temporal logic specifications,” in Proc.
HSCC. ACM, 2015, pp. 239–248.
[5] N. Roohi, R. Kaur, J. Weimer, O. Sokolsky, and I. Lee, “Parameter
invariant monitoring for signal temporal logic,” in Proc. HSCC . ACM,
2018, pp. 187–196.
[6] A. Dokhanchi, B. Hoxha, and G. Fainekos, “Metric interval temporal
logic specification elicitation and debugging,” in Proc. MEMOCODE.
IEEE, 2015, pp. 70–79.
[7] H. Roehm, T. Heinz, and E. C. Mayer, “STLInspector: STL validation
with guarantees,” in Proc. CAV, ser. LNCS, vol. 10426. Springer, 2017,
pp. 225–232.
[8] Z. Xu, C. Belta, and A. Julius, “Temporal logic inference with
prior information: An application to robot arm movements,” IFAC-
PapersOnLine, vol. 48, no. 27, pp. 141–146, 2015.
[9] A. Donz ´e, T. Ferr `ere, and O. Maler, “Efficient robust monitoring for
STL,” in Proc. CAV, ser. LNCS, vol. 8044. Springer, 2013.
[10] J. V . Deshmukh, A. Donz ´e, S. Ghosh, X. Jin, G. Juniwal, and S. A.
Seshia, “Robust online monitoring of signal temporal logic,” Form.
Methods Syst. Des., vol. 51, no. 1, pp. 5–30, 2017.
[11] S. Jak ˇsi´c, E. Bartocci, R. Grosu, and D. Ni ˇckovi ´c, “Quantitative mon-
itoring of STL with edit distance,” Form. Methods Syst. Des., vol. 53,
no. 1, pp. 83–112, 2018.
[12] D. Ni ˇckovi ´c, O. Lebeltel, O. Maler, T. Ferr `ere, and D. Ulus, “Amt 2.0:
qualitative and quantitative trace analysis with extended signal temporal
logic,” in Proc. TACAS, vol. 10806. Springer, 2018, pp. 303–319.
[13] Y . Annpureddy, C. Liu, G. Fainekos, and S. Sankaranarayanan, “S-taliro:
A tool for temporal logic falsification for hybrid systems,” in Proc.
TACAS, ser. LNCS, vol. 6605. Springer, 2011, pp. 254–257.
[14] Z. Zhang, D. Lyu, P. Arcaini, L. Ma, I. Hasuo, and J. Zhao, “Effective
hybrid system falsification using monte carlo tree search guided by qb-
robustness,” in Proc. CAV, ser. LNCS, vol. 12759. Springer, 2021, pp.
595–618.
[15] G. Frehse, C. Le Guernic, A. Donz ´e, S. Cotton, R. Ray, O. Lebeltel,
R. Ripado, A. Girard, T. Dang, and O. Maler, “SpaceEx: Scalable
verification of hybrid systems,” in Proc. CAV, ser. LNCS, vol. 6806.
Springer, 2011, pp. 379–395.
[16] X. Chen, E. ´Abrah ´am, and S. Sankaranarayanan, “Flow*: An analyzer
for non-linear hybrid systems,” in Proc. CAV, ser. LNCS, vol. 8044.
Springer, 2013, pp. 258–263.
[17] S. Bak and P. S. Duggirala, “Hylaa: A tool for computing simulation-
equivalent reachability for linear systems,” in Proc. HSCC. ACM, 2017,
pp. 173–178.
[18] A. Cimatti, A. Griggio, S. Mover, and S. Tonetta, “HyComp: an SMT-
based model checker for hybrid systems,” in Proc. TACAS, ser. LNCS,
vol. 9035. Springer, 2015, pp. 52–67.
[19] S. Kong, S. Gao, W. Chen, and E. M. Clarke, “dReach: δ-reachability
analysis for hybrid systems,” in Proc. TACAS, ser. LNCS, vol. 7898.
Springer, 2015, pp. 200–205.
[20] P. S. Duggirala, C. Fan, S. Mitra, and M. Viswanathan, “Meeting a
powertrain verification challenge,” in Proc. CAV , ser. LNCS, vol. 9206.
Springer, 2015, pp. 536–543.
[21] H. Roehm, J. Oehlerking, T. Heinz, and M. Althoff, “STL model
checking of continuous and hybrid systems,” in Proc. ATVA, ser. LNCS,
vol. 9938. Springer, 2016, pp. 412–427.
[22] K. Bae and J. Lee, “Bounded model checking of signal temporal logic
properties using syntactic separation,” Proc. ACM Program. Lang., vol.
3, POPL, no. 51, pp. 1–30, 2019.
[23] L. De Alfaro and Z. Manna, “Verification in continuous time by discrete
reasoning,” in Proc. AMAST, ser. LNCS, vol. 936. Springer, 1995, pp.
292–306.
[24] A. Cimatti, M. Roveri, and S. Tonetta, “Requirements validation for
hybrid systems,” in Proc. CAV, ser. LNCS, vol. 5643. Springer, 2009,
pp. 188–203.[25] J. Ouaknine and J. Worrell, “Some recent results in metric temporal
logic,” in Proc. FORMATS, ser. LNCS, vol. 5215. Springer, 2008.
[26] H.-M. Ho, J. Ouaknine, and J. Worrell, “Online monitoring of metric
temporal logic,” in Proc. RV, ser. LNCS, vol. 8734. Springer, 2014,
pp. 178–192.
[27] R. Alur, T. Feder, and T. A. Henzinger, “The benefits of relaxing
punctuality,” JACM, vol. 43, no. 1, pp. 116–146, 1996.
[28] T. Ferr `ere, O. Maler, D. Ni ˇckovi ´c, and A. Pnueli, “From real-time logic
to timed automata,” JACM, vol. 66, no. 3, pp. 1–31, 2019.
[29] S. Gao, S. Kong, and E. M. Clarke, “Satisfiability modulo ODEs,” in
Proc. FMCAD. IEEE, 2013, pp. 105–112.
[30] J. Lee, G. Yu, and K. Bae, “Supplementary material: proofs of lemmas
and benchmarks,” https://github.com/stlmc/stlmc/tree/ase2021.
[31] T. Henzinger, “The theory of hybrid automata,” in Verification of Digital
and Hybrid Systems, ser. NATO ASI Series. Springer, 2000, vol. 170,
pp. 265–292.
[32] S. Minopoli and G. Frehse, “SL2SX translator: from simulink to spaceex
models,” in Proc. HSCC. ACM, 2016, pp. 93–98.
[33] S. Bak, O. A. Beg, S. Bogomolov, T. T. Johnson, L. V . Nguyen, and
C. Schilling, “Hybrid automata: from verification to implementation,”
STTT, vol. 21, no. 1, pp. 87–104, 2019.
[34] S. Ran, J. Lin, Y . Wu, J. Zhang, and Y . Xu, “Converting Ptolemy
II models to SpaceEx for applied verification,” in Proc. ICA3PP, ser.
LNCS, vol. 8630. Springer, 2014, pp. 669–683.
[35] R. Alur, Principles of cyber-physical systems. The MIT Press, 2015.
[36] S. M. LaValle, Planning algorithms. Cambridge university press, 2006.
[37] T. A. Henzinger, P. W. Kopke, A. Puri, and P. Varaiya, “What’s decidable
about hybrid automata?” Journal of computer and system sciences,
vol. 57, no. 1, pp. 94–124, 1998.
[38] L. De Moura and N. Bjørner, “Z3: an efficient SMT solver,” in Proc.
TACAS, ser. LNCS, vol. 4963. Springer, 2008, pp. 337–340.
[39] B. Dutertre, “Yices 2.2,” in Proc. CAV, ser. LNCS, A. Biere and
R. Bloem, Eds., vol. 8559. Springer, 2014, pp. 737–744.
[40] C. Barrett, C. L. Conway, M. Deters, L. Hadarean, D. Jovanovi ´c, T. King,
A. Reynolds, and C. Tinelli, “CVC4,” in Proc. CAV, ser. LNCS, vol.
6806. Springer, 2011, pp. 171–177.
[41] S. Gao, S. Kong, and E. M. Clarke, “dReal: An SMT solver for nonlinear
theories over the reals,” in Proc. CADE, ser. LNCS, vol. 7898. Springer,
2013, pp. 208–214.
[42] A. Eggers, N. Ramdani, N. S. Nedialkov, and M. Fr ¨anzle, “Improving
the SAT modulo ODE approach to hybrid systems analysis by combining
different enclosure methods,” SoSyM, vol. 14, no. 1, pp. 121–148, 2015.
[43] S. D. Prestwich, “CNF encodings.” Handbook of satisfiability, vol. 185,
pp. 75–97, 2009.
[44] A. Cimatti, S. Mover, and S. Tonetta, “Quantifier-free encoding of
invariants for hybrid systems,” Form. Methods Syst. Des., vol. 45, no. 2,
pp. 165–188, 2014.
[45] J. Raisch, E. Klein, C. Meder, A. Itigin, and S. O’Young, “Approxi-
mating automata and discrete control for continuous systems — two
examples from process control,” in Hybrid systems V, ser. LNCS, vol.
1567. Springer, 1999, pp. 279–303.
[46] M. Fox, D. Long, and D. Magazzeni, “Plan-based policies for efficient
multiple battery load management,” JAIR, vol. 44, pp. 335–382, 2012.
[47] M. Althoff, “Reachability analysis of nonlinear systems using conser-
vative polynomialization and non-convex sets,” in Proc. HSCC. ACM,
2013, pp. 173–182.
[48] T. Dang and R. Testylier, “Reachability analysis for polynomial dynami-
cal systems using the bernstein expansion,” Reliable Computing, vol. 17,
no. 2, pp. 128–152, 2012.
[49] S. Bak and P. S. Duggirala, “Simulation-equivalent reachability of large
linear systems with inputs,” in Proc. CAV, ser. LNCS, vol. 10426.
Springer, 2017, pp. 401–420.
[50] C. Fan, B. Qi, S. Mitra, M. Viswanathan, and P. S. Duggirala, “Automatic
reachability analysis for nonlinear hybrid models with C2E2,” in Proc.
CAV, ser. LNCS, vol. 9779. Springer, 2016, pp. 531–538.
[51] K. Bae and S. Gao, “Modular SMT-based analysis of nonlinear hybrid
systems,” in Proc. FMCAD. IEEE, 2017, pp. 180–187.
[52] D. Ishii, K. Ueda, and H. Hosobe, “An interval-based SAT modulo ODE
solver for model checking nonlinear hybrid systems,” STTT, vol. 13,
no. 5, pp. 449–461, 2011.
[53] A. Tiwari, “Time-aware abstractions in HybridSal,” in Proc. CAV, ser.
LNCS, vol. 9206. Springer, 2015, pp. 504–510.
354