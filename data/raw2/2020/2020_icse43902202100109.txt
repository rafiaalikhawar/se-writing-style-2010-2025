InferCode: Self-Supervised Learning of Code Representations
by Predicting Subtrees
Nghi D. Q. Bui, Yijun Yuy, Lingxiao Jiang,
School of Computing & Information Systems, Singapore Management Univerity
fdqnbui.2016, lxjiang g@smu.edu.sg
ySchool of Computing & Communications, The Open University, UK
fy.yug@open.ac.uk
Abstract ‚ÄîLearning code representations has found many uses
in software engineering, such as code classiÔ¨Åcation, code search,
comment generation, and bug prediction, etc. Although repre-
sentations of code in tokens, syntax trees, dependency graphs,
paths in trees, or the combinations of their variants have been
proposed, existing learning techniques have a major limitation
that these models are often trained on datasets labeled for speciÔ¨Åc
downstream tasks, and as such the code representations may
not be suitable for other tasks. Even though some techniques
generate representations from unlabeled code, they are far from
being satisfactory when applied to the downstream tasks. To
overcome the limitation, this paper proposes InferCode , which
adapts the self-supervised learning idea from natural language
processing to the abstract syntax trees (ASTs) of code. The
novelty lies in the training of code representations by predicting
subtrees automatically identiÔ¨Åed from the contexts of ASTs. With
InferCode, subtrees in ASTs are treated as the labels for training
the code representations without any human labelling effort or
the overhead of expensive graph construction, and the trained
representations are no longer tied to any speciÔ¨Åc downstream
tasks or code units.
We have trained an instance of InferCode model using Tree-
Based Convolutional Neural Network (TBCNN) as the encoder
of a large set of Java code. This pre-trained model can then
be applied to downstream unsupervised tasks such as code
clustering, code clone detection, cross-language code search, or be
reused under a transfer learning scheme to continue training the
model weights for supervised tasks such as code classiÔ¨Åcation and
method name prediction. Compared to prior techniques applied
to the same downstream tasks, such as code2vec, code2seq,
ASTNN, using our pre-trained InferCode model higher perfor-
mance is achieved with a signiÔ¨Åcant margin for most of the tasks,
including those involving different programming languages. The
implementation of InferCode and the trained embeddings are
available at the link: https://github.com/bdqnghi/infercode.
I. I NTRODUCTION
Learning code representations (a.k.a. embeddings) and
building a prediction model for programs have been found
useful in many software engineering tasks, such as classifying
program functionality [1, 2], code search [3, 4, 5], code com-
ment generation [6, 7, 8], predicting bugs [9, 10], translating
programs [11, 12], etc. While offering promising performance
for the tasks, the prior learning techniques have two major
limitations that hinder their performance and generalizability.
Most code representation models are trained through (semi-
)supervised learning. Humans need to manually label the
data for a speciÔ¨Åc downstream task, then engineer featuresof intermediate representations, and train the models specif-
ically for the task. Such labelling, feature engineering, and
training efforts are speciÔ¨Åc to one particular task and may
not be easily transferred to other tasks.
Even though there are techniques [8, 13] aiming to produce
code representations that are transferable to different tasks,
their trained code representations are only for some Ô¨Åxed
units of code, such as tokens, statements, and functions,
and are not Ô¨Çexible to produce embeddings for varying code
units. Such techniques may miss useful information across
different kinds of code units, and the trained representations
may not perform well for various downstream tasks either.
Some other techniques based on graph embeddings [14, 15]
share a similar drawback and in addition need the overheads
of graph construction which may introduce inaccurate infor-
mation in the graphs.
Such limitations have been illustrated in a recent study:
Kang et al. [16] show that the pre-trained code2vec [8]
representation does not perform well for other tasks when it
was trained speciÔ¨Åcally for the method-name prediction task.
Towards addressing the limitations, the aim of this paper is
to develop a new technique for learning code representations,
and it should be: (1) trainable without any manual human
labeling, (2) Ô¨Çexible in producing embeddings for any code
unit that can be parsed into syntax trees, and (3) general
enough so that its trained representations for code can perform
well for various downstream tasks.
We have two pillars that support the realization of our aim.
One is the large amount of source code available on public
code hosting platforms, such as Github, Bitbucket, Gitlab.
Although the code often lacks accurate labels for downstream
tasks, the syntax of the code itself can be checked relatively
easily by parsers. It is desirable to leverage such unlabeled
data to pretrain the code representations reusable for building
various program prediction models for downstream tasks.
The second pillar is supported by the advances of self-
supervised learning in machine learning [17, 18, 19, 20, 21].
Such techniques enable the training of neural networks without
the need for human labels. Usually, a self-supervised learning
technique reformulates an unsupervised learning problem as a
supervised one by automatically generating virtual labels from
existing (unlabeled) data . The self-supervised task, also known
as a pretext task , guides us to a supervised loss function.
11862021 IEEE/ACM 43rd International Conference on Software Engineering (ICSE)
1558-1225/21/$31.00 ¬©2021 IEEE
DOI 10.1109/ICSE43902.2021.00109
While minimizing the loss function for the pretext task, the
technique also produces intermediate representations for the
data corresponding to the virtual labels. Because the pretext
task can be trained using any data, it is expected that such
representations can carry good information about the diverse
data and be beneÔ¨Åcial to a variety of downstream tasks. This
notion of self-supervised learning is very suitable for our
aim. Little effort has been invested in the literature to exploit
the uses of self-supervised learning for code representation
learning. Although some recent work, such as [19], presents
a self-supervised learning paradigm for program repair, it is
designed speciÔ¨Åcally for this speciÔ¨Åc task.
Our key idea is thus to train a pretext task suitable for
any source code. Unlike self-supervised learning in natural
language processing and visual learning areas that use words
or object regions as labels, we utilize the fact that it is
relatively easy to obtain the abstract syntax tree (AST) of
any syntactically valid code snippets via parsers and it is also
easy to identify all the subtrees in ASTs, and automatically
use each subtree as the label for the pretext task to predict
the probability of that subtree appearing in a particular AST1.
Fig. 1 illustrates this intuition with an example. The two code
snippets implement the same functionality, i.e. bubble sort. If
we view these two code snippets as two ASTs, there are many
similar subtrees between them. For example, the subtree that
represents the conditional expression arr[j] > arr[j+1]
of the left snippets is similar to arr[i] > arr[i+1]
although the textual information is quite different. This means
that if one can exploit such information, there is no longer
the need for labels to build a representation learning model
for source code. Unlike the recent uses of neural document
embedding models (e.g., doc2vec [22, 23]) for source code
(e.g., [24, 25, 26, 27]), our technique learns subtrees in ASTs
without the overheads and losses of accuracy in constructing
customized graphs from code tokens and node types, although
we are also inspired by the same idea of doc2vec. We also
provide an alternative to graph-based [28, 29] or execution
traces-based [30] embedding techniques as we believe ASTs
are more readily available for all kinds of programming
languages and may have contained all the code information
(although some are hidden).
Based on the key idea, we propose InferCode , a self-
supervised learning technique for source code by predicting
syntax subtrees. As far as we know, we are the Ô¨Årst to apply
the notation of self-supervised learning to syntax subtrees and
can produce code representations for any syntactically valid
code snippet without the need of human labelling:
InferCode can serve as an encoder that maps any parsable
code snippet into a vector representation (embedding), and
1An underlying assumption is that, for such trained representations to
capture code meanings, code snippets with the same semantics should involve
some syntactically similar code elements. Even though two pieces of code
implementing the same functionality can be syntactically different, there could
still be some Ô¨Åne-grained elements in the code or other pieces of code that
use these two that are syntactically similar, especially when the code base is
large.
Fig. 1. Example of two code snippets that implement bubble sort in Java that
share similar Ô¨Åne-grained code elements.
this vector can be used for various downstream tasks, such
as code clustering, clone detection, and code search.
InferCode can serve as a pre-trained model and its weights
can be reused in downstream training of the models for
supervised learning tasks, which can speed up the training
and alleviate the issue of lacking data for a particular task.
We implement InferCode on top of the ASTs produced
by SrcML [31] and efÔ¨Åcient parsers such as fAST [32].
It provides a combined vocabulary of AST node types for
multiple programming languages (e.g., Java, C, C++, C#,
Objective C), which implies that our InferCode can be
polyglot, producing code representations suitable for tasks
involving different languages, such as cross-language code
search, as long as the ASTs for a code snippet can be
recognized by the parser.
We have trained an instance of InferCode based on a large
set of Java code and evaluated the usefulness of the pretrained
code representations in Ô¨Åve downstream tasks, three of which
are unsupervised (code clustering, code clone detection via
similarity measurement, cross-language code search, two are
supervised (code classiÔ¨Åcation and method name prediction).
For the three unsupervised tasks, we utilize the vectors produce
by InferCode and different vector similarity metrics to achieve
the goal of each task: For code clustering , our results using
InferCode outperform the best baseline (Code2vec) by 12% in
term of Adjusted Rand Index; For code clone detection , our
results outperform the best baseline (Code2vec) by 15% in
term of F1 score; For cross-language code search , our results
outperform the best baseline (CLIR) on 13% (on average for
multiple languages setting) in term of Mean Reciprocal Rank.
For the two supervised tasks, we utilize the weights of the
pre-trained model from InferCode to Ô¨Åne-tune the speciÔ¨Åc
prediction model for each task: our results using the Ô¨Åne-
tuning process increases the performance of TBCNN for code
classiÔ¨Åcation by 4% in term of accuracy, which is comparable
to ASTNN, the state-of-the-art model for code classiÔ¨Åcation,
and increase the performance TBCNN for method name pre-
diction by 8%, which is comparable to code2seq, a state-of-
the-art model for method name prediction.
II. R ELATED WORK
Self-Supervised Learning has made great progress recently
for visual data [33, 34, 35, 36, 37, 38]: Gidaris et al. [34]
proposed a method to generate different viewpoints of an
image by a number of rotations on certain degrees at random
and formulate the learning part as a multi-class classiÔ¨Åcation
problem over the rotations. This pretext task drives the model
1187to learn semantic concepts of objects as the parameters of
the CNN image encoder; Zhang et al. [35] proposed to use
colorization as the pretext task by giving colours to a grayscale
input image in order to map this image to a distribution over
quantized color value outputs.
There has been tremendous effort in exploring self-
supervised learning in Natural Language Processing (NLP) re-
search [22, 23, 39, 40, 41, 42]. Word2vec [22] is a form of self-
supervised learning, which aims to learn good representation
of words by taking a small chunk of the text of certain window
size. Doc2vec [23] shares the same principle with word2vec,
which aims to use a document to predict the words inside it
so that similar documents will have similar embeddings; Skip-
thought vectors [39] builds a statistical language model by
predicting the neighbouring sentences of a centering sentence;
BERT [40] advances the language models by masking the
words in a text randomly in order to predict them.
Deep Code Learning Models : There has been a huge inter-
est in applying deep learning techniques to software engineer-
ing tasks such as program functionality classiÔ¨Åcation [43, 44],
bug localization [45, 46], function name prediction [47], code
clone detection [44], program refactoring [6], program transla-
tion [11], and code synthesis [48]. Allamanis et al. [49] extend
ASTs to graphs by adding a variety of code dependencies as
edges among the tree nodes, intended to represent code seman-
tics, and apply Gated Graph Neural Networks (GGNN) [50] to
learn the graphs from code; Code2vec [8], Code2seq [13], and
ASTNN [44] are designed based on splitting ASTs into smaller
ones, either as a bag of path-contexts or as Ô¨Çattened subtrees
representing individual statements. They use various kinds
of Recurrent Neural Networks (RNNs) to learn such code
representations. Unfortunately, there is little effort in designing
the source code model with unlabelled data. Yasunaga and
Liang [19] presents a self-supervised learning paradigm for
program repair; surveys on code embeddings [25, 27] present
evidence to show that there is a strong need to alleviate the
demands of labelled data and encourage the community to
invest more into the methods for learning source code with
unlabelled data.
Our approach differs from existing ways to reuse the pre-
trained code learning model: Kang et al. [16] reuse the token
embeddings from Code2vec for downstream tasks only to Ô¨Ånd
lower performance than simpler word embedding methods like
Word2vec. In contrast, we use the weights of the pretrained
model and the code vector ~ vproduced by the encoder instead
of the token embeddings.
III. P RELIMINARIES
A. Source Code Representation Learning
Source code representation learning usually contains the
following two phases: (1) representing a code snippet into an
intermediate representation (IR), such as token streams, ASTs,
AST paths or graphs; and (2) designing a neural network
suitable to process such intermediate representations. Such a
neural network can also be called an encoder , which receives
the code IR and maps it into a code vector embedding ~ v(usually a combination of various kinds of code elements),
then~ vcan be fed into the next layer(s) of a learning system
and trained for an objective function of the speciÔ¨Åc task of the
learning system. For example, in Code2vec [8], ~ vis a combina-
tion of different AST paths. In GGNN [49] or TBCNN [43],
~ vis a combination of AST nodes. A trained model, either
on supervised learning or self-supervised learning task, can
produce~ v. In our work, we will evaluate how the ~ vtrained on
a self-supervised learning objective function over a large set of
unlabelled data can be made useful for different downstream
SE tasks.
B. Neural Document Embedding Models
Doc2vec [23] is an extension to word2vec [22]. Doc2vec
uses an instance of the skip-gram model called paragraph
vector, which is a distributed bag of words (interchangeably
referred as doc2vec skip-gram) that is capable of learning the
representations of a sequence words of arbitrary lengths, such
as sentences, paragraphs and even whole documents. More
speciÔ¨Åcally, given a set of documents fd1;d2;:::dngand a
sequence of words f:::;w ij;:::gsampled from the document
di, skip-gram learns a D-dimensional embeddings of the
documentdiand each word wijsampled, i.e., ~ vi;~ vij2RD,
respectively. The model works by considering a word wijto be
occurring in the context of document diand tries to maximize
the following log likelihood function:P
jlog Pr (wijjdi),
where the probability Pr(wijjdi)is deÔ¨Åned asexp(~ vi~ vij)P
w2Vexp(~ vi~ w),
whereVis the vocabulary of all the words across all docu-
ments.
In this paper, we consider ASTs analogous to documents
and subtrees in the ASTs analogous to words in the documents,
and adapt the idea of document embedding to learn the
embeddings of ASTs of any size by using an encoder for the
AST of any parsable code snippets.
C. Self-supervised Learning Formulation
The goal of self-supervised learning is to train an encoder
Esuch thatEcan map an object into a vector representation
(embedding). In our case, the embedding ~ vis for the AST
representation Tof a code snippet C. Training the encoder
Eis to learn its parameters (or weights) so that Eis able to
produce the embeddings for the code snippets such that the
vectors for the snippets having similar syntactical and semantic
information will be close in the vector space. In visual
learning, Convolutional Neural Networks (CNNs) are usually
chosen as the encoder for images. In NLP, Recurrent Neural
Networks, or recently, BERT, is typically used as the encoder
for text sequences. In our case, we choose Tree-based CNN
as the source code encoder as it has been successfully used
before [43, 51, 52, 53] and justiÔ¨Åed further in Section VIII.
Given a dataset X, for each data Xiin X, there is a
corresponding pseudo label Piautomatically generated for a
predeÔ¨Åned pretext task without involving any human annota-
tion. Given a set of ntraining data D=fPign
i=1, the aim is to
minimize the loss function: loss(D) =1
nPn
i=1loss(Xi;Pi):
We can easily identify subtrees in ASTs as the pseudo labels P
1188Fig. 2. a) Doc2vec‚Äôs skipgram model - Given a document d, it samples cwords and considers them as co-occurring in the same context of dto learn d‚Äôs
representation; (b) InferCode - Given an AST T, it samples ssubtrees from Tand uses them as the context to learn T‚Äôs representation.
automatically without human annotations so that our learning
technique can be self-supervised.
IV. A PPROACH DETAILS
A. Overview
Figure 2 presents a high-level view of our InferCode ap-
proach as an analogy to Doc2vec by treating an entire AST as
a document and treating its subtrees as words in the document.
Given a set of ASTs fT1;T2;:::T ng;and a set of all subtrees
f:::;T ij;:::gofTi, we represent Ti;TijbyD-dimensional
embedding vectors ~ vi;~ vij2RD, respectively. By considering
a subtreeTij2Tito be occurring in the context of the AST
Ti, we aim to maximize the following logarithmic likelihood:P
jlog Pr (TijjTi).
Unlike doc2vec, InferCode does not query the embedding
vectors directly from an embedding matrix for the whole
documents; instead, we Ô¨Årst encode the entire AST to obtain
the~ vi, then use it to predict the subtrees. The steps of our
technique are as follows:
For each AST in our dataset, we identify a set of subtrees,
and all of the subtrees are accumulated into a vocabulary of
subtrees (Section IV-B);
We feed an AST into a Tree-Based CNN (TBCNN) encoder
to produce a code vector ~ vi. Then~ viis used to predict the
subtrees identiÔ¨Åed in the previous step;
After the encoder has been trained, we can use it as the
pretrained model for downstream tasks.
B. Process to Identify Subtrees
Fig. 3. Example to generate subtrees from a code snippet
By traversing an AST, every visited node satisfying a certain
condition, e.g., of the type expr , leads to a subtree rooted
at the visited node. In our experiments, we chose to select
the subtrees whose root node is of the types fexpr_stmt ,
decl_stmt ,expr ,conditiong, We consider these rel-
atively Ô¨Åne-grained code elements because they are usually
meaningful yet small enough to be considered as frequent‚Äúwords‚Äù in the vocabulary of subtrees from a large code
base. Such small code elements often have similar meaning
when their syntactical structure is similar even though their
textual appearance may be different (due to different identiÔ¨Åer
names, such as int n = arr.length versus int m =
x.length ). In addition, we also consider the nodes that
represent for a single keyword, such as if, for, while .
Noted that these nodes can be seen as the subtrees with size
= 1.
We do not consider coarse-grained subtrees such as the
whole if, while, for statements, as those subtrees are
often too big so that (1) each of them, as an individual
vocabulary word, may appear too infrequent in the code base
for the encoder to learn a meaningful representation for it
directly; (2) syntactical differences among the big subtrees
do not necessarily mean the corresponding code has different
meanings, while the encoder may have harder time to recog-
nize the semantic similarity among them.
Figure 3 shows a sample bubble sort code snippet written
in Java and the identiÔ¨Åed subtrees on the right hand side.
This snippet is parsed into an AST, and certain subtrees are
identiÔ¨Åed automatically. For example, the statement int n
= arr.length contains an expression arr.length . Both
int n = arr.length andarr.length are identiÔ¨Åed.
C. Learning Source Code Representation
Once we have the subtrees, we can use them to learn the
source code encoder under a self-supervision mechanism. Here
we choose TBCNN [43] as the source code encoder. There
are two major differences between our implementation of
TBCNN and the original design in [43]: we include the textual
information into the node initialization embedding instead of
using only the type information, and we replace the dynamic
max pooling with an attention mechanism to combine node
embeddings. Figure 4 shows an overview of the workÔ¨Çow of
the TBCNN with the modiÔ¨Åcations we made. There are three
steps to learn the weights of the encoder, which are described
as follows:
Learning Nodes Representation : This step is to learn
the representation of the node of the input AST T. The
information of the tree will propagate from bottom to top,
i.e., a parent node will accumulate the information of its
descendant in the AST. After the accumulation step, each
node will contain the information of its descendants.
Aggregating Nodes Information : Since we want to rep-
resent the AST representation of the code snippet into a
1189Fig. 4. WorkÔ¨Çow of Tree-based Convolutional Neural Network [43] with 2
modiÔ¨Åcations: (1) including the token information to initialize the node vector;
and (2) using the attention mechanism to aggregate node‚Äôs information
Ô¨Åxed dimension vector ~ v, we need to combine all the node
embeddings into one Ô¨Åxed single embedding. We use the
attention layer for this purpose.
Predicting Subtrees : Once having the vC, we use it to pre-
dict the subtrees extracted from T. Intuitively, this process
is similar to Eq. (III-B), where the task is to predict the
probability of a subtree given the embedding vC.
1) Learning Nodes Representation with TBCNN: We
brieÔ¨Çy introduce the Tree-based Convolutional Neural Net-
works (TBCNN, [43]) for processing AST inputs.
A treeT= (V;E;X )consists of a set of nodes V, a
set of node features X, and a set of edges E. An edge in
a tree connects a node and its children. Each node in an
AST also contains its corresponding texts (or tokens) and its
type (e.g., operator types, statement types, function types, etc.)
from the underlying code. Initially, we annotate each node
v2Vwith aD-dimensional real-valued vector ~ xv2RD
representing the features of the node. We associate every node
vwith a hidden state vector ~hv, initialized from the feature
embedding ~ xv. In [43], the node is initialized only with the
type embedding. In our case, we initialize the node with a
fusion of the embeddings of its texts and through a linear layer.
The embedding matrices for the texts and types are learn-
able in the whole model training pipeline, formally deÔ¨Åned as
WtypeandWtoken, respectively.
In TBCNN, a convolution window over an AST is emulated
via a binary tree, where the weight matrix for each node is a
weighted sum of three Ô¨Åxed matrices Wt,Wl,Wr2RDD
(each of which is the weight for the ‚Äútop‚Äù, ‚Äúleft‚Äù, and ‚Äúright‚Äù
node respectively) and a bias term b2RDHence, for a
convolutional window of depth din the original AST with
K= 2d 1nodes (including the parent nodes) belong to
that window with vectors [x1;:::;xK], where xi2RD, the
convolutional output yof that window can be deÔ¨Åned as:
y=tanh(PK
i=1[t
iWt+l
iWl+r
iWr]xi+b), where
t
i;l
i;r
iare weights calculated corresponding to the depth
and the position of the nodes.
2) Attention Mechanism to Aggregate Nodes: After the
nodes representation has been learned, we need an aggregation
method to combine all the nodes in to one Ô¨Åxed embeddingthat represent for the code snippet. Mou et al. [43] use max
pooling to combine the nodes. However, max pooling may
discard a lot of important information, so we replace it with the
attention mechanism to aggregate nodes. Formally, an attention
vector~ a2RDis initialised randomly and learned simultane-
ously with updates of the networks. Given nnode state vectors:
f~h1;:::;~hng, the attention weight iof each~hiis computed
as the normalised inner product between the node state vector
and the global attention vector: i=exp(~hiT~ a)Pn
j=1exp(~hjT~ a). The
exponents in this equation are used to make the attention
weights positive, and they are divided by their sum to have a
max value of 1, as done by a standard softmax function.
The aggregated code vector ~ v2RDrepresents the whole
code snippet. It is a linear combination of the node state
vectorsf~h1;:::;~hngweighted by their attention scores:
~ v=nX
i=1i~hi (1)
3) Predicting Subtrees: From the process to extract the
subtrees, we have a vocabulary of all subtrees from our training
dataset. The embeddings of subtrees are learn-able parameters,
formally deÔ¨Åned as Wsubtrees2RjLjD, whereLis the set of
subtrees extracted from the training corpus. The embedding of
subtrees iis rowiofWsubtrees. The predicted distribution
of the model q(l)is computed as the (softmax-normalized)
dot product between the code vector ~ vand each of the subtree
embeddings:
for l i2L:q(li) =exp(~ vTWsubtrees
i )P
lj2Lexp(~ vTWsubtrees
i )(2)
whereq(li)is the normalized dot product between the vector
ofliand the code vector ~ v, i.e., the probability that a subtrees
liappears in a given code snippet C. This is aligned with
Eq. (III-B) in Doc2vec to predict the likelihood of a word
given a document.
Finally, we need to learn these parameters of Infer-
Code: Wtype,Wtoken,Wt,Wl,Wr2RDD;a2
RD;Wsubtrees2RjLjD.
D. Usage of the Model after Training
We have presented the pipeline to train InferCode by
predicting subtrees as the labels. Note that in self-supervised
learning, one does not usually care about the performance
of the pretext task. Instead, we care about the weights that
have been learned and the ability of the model to generate the
embeddings. The trained TBCNN encoder of InferCode can be
used to produce an embedding vector ~ vfor any parsable code
snippet by (1) parsing the code into an AST and (2) feeding the
AST through the encoding step presented in Figure 4 to get the
vector. The weights in the trained model can also be used for
the prediction models in downstream supervised learning tasks
to save training costs and potentially improve their prediction
accuracy. We illustrate the usages in next sections.
1190V. U SECASES
In this section, we brieÔ¨Çy describe how InferCode can be
adapted into 5 different downstream tasks.
A. Code Embedding Vectors for Unsupervised Tasks
1) Code Clustering: The task is to put similar code snippets
automatically into the same groups without any supervision.
Given the code vectors ~ vproduced by the pre-trained Infer-
Code for any code snippets, we can realize the task by deÔ¨Åning
a similarity metric based on Euclidean distance and applying
a clustering algorithm such as K-means[54].
2) Code Clone Detection: There are supervised and un-
supervised approaches to detect clones. While deep learning
methods are applied to detect code clones, they require labelled
data to train a supervised learning model [14, 44, 55]. As such,
one needs human annotators to mark the pairs of snippets as
clones, limiting the ability to detect clones by large amount
of the data one can collect.
To alleviate the need of labelled pairwise data to train
supervised clone detectors, we opt to use the unsupervised
approach based on a good similarity measurement: For a
pair of code snippets, we measure the similarity of between
the two vectors by using the cosine similarity; when the
cosine similarity between the vectors are higher than a certain
threshold, we treat the pair as clones. In this work, we choose
0.8 as the threshold.
3) Cross Language Code-to-Code Search: Code-to-code
search is useful for developers to Ô¨Ånd other code in a large
code base that is similar to a given code query. For example,
a developer working on a task to migrate a sorting algorithm
implemented in Java to another language (e.g., C#) might
want to see if there exists an implementation of the same
sorting algorithm in C#, instead of rewriting the code in C#
from scratch. Existing code-to-code search engine such as
Krugle, Facoy [4], Aroma [56], only consider the searching
problem within one programming language. Considering the
more challenging cross-language search use case, our pre-
trained InferCode model can be more useful. The backbone
of InferCode is ASTs, and we used the ASTs from an
efÔ¨Åcient parser for SrcML representations [32] because it is
a combined vocabulary for the AST node types in Ô¨Åve main-
stream languages (Java, C, C++, C# and Objective C). Our pre-
trained model can receive SrcML AST structure of any code
snippets within these 5 languages. Given a code snippet in one
language as a query, we aim to retrieve other code snippets
that are functionally similar to the given code snippet in
other programming languages. Since all code snippets can be
represented in the form of vector representations, this problem
can be formalized as the nearest-neighbor query in the vector
space.
B. Fine-Tuning for Supervised Learning Tasks
A paradigm to make use of large amount of unlabelled data
isself-supervised pretraining followed by a supervised Ô¨Åne-
tuning [17, 18], which reuses parts (or all) of a trained neural
network on a certain task and continue to train it or simply
Fig. 5. Code features are learned through the training process of TBCNN
encoder to solve a predeÔ¨Åned pretext task. After Ô¨Ånishing the training, the
learned parameters serve as a pre-trained model and can be transferred to
other downstream tasks by Ô¨Åne-tuning. The performance on these downstream
tasks is used to evaluate the quality of the learned features.
using the embedding output for other tasks. Such Ô¨Åne-tuning
processes usually have the beneÔ¨Åts of (1) speeding up the
training as one does not need to train the model from randomly
initialized weights and (2) improving the generalizability of
the downstream model even when only small datasets have
labels.
As shown in Figure 5, the TBCNN encoder of InferCode
serves as a pretrained model, in which the weights resulted
from the self-supervised learning are transferred to initialize
the model of the downstream supervised learning task.
1) Code classiÔ¨Åcation: Here we use code classiÔ¨Åcation [43]
as a downstream task to demonstrate the usefulness of the Ô¨Åne-
tuning process. This task is to, given a piece of code, classify
the functionality class it belongs to.
2) Method name prediction: We use Method name pre-
diction [8] as the second downstream task. This task is to,
given a piece of code (without its function header), predict a
meaningful name that reÔ¨Çects the functionality of the code.
VI. E MPIRICAL EVALUATION
In this section, we evaluate InferCode on the Ô¨Åve use cases
presented in Section V. We want to see to what degree the pre-
trained model is applicable to different use cases even when
the cases involve multiple programming languages.
For the training phase, we reuse the Java-Large dataset that
has been used in Code2vec [8] and Code2seq [13]. This dataset
contains a large number of Java projects collected from Github
(4 million Ô¨Åles). For the testing phase, we use different datasets
for each of the task as the test data .
We parse all the Ô¨Åles into ASTs using fast [32]. Then we
identify all the subtrees to form a vocabulary of subtrees.
Having the ASTs, and the subtrees as the pseudo labels, we
train the InferCode model by using the softmax cross-entropy
as the objective loss function and choose Adam [57] as the
optimizer with an initial learning rate of 0:001 on an Nvidia
Tesla P100 GPU.
A. Code Clustering
1) Datasets, Metrics, and Baselines: We use two datasets
for this task. The Ô¨Årst is the OJ dataset that contains 52,000
C code snippets known to belong to 104 classes [43]. The
second is the Sorting Algorithm (SA) dataset used in [58],
which consists of 10 classes of sorting algorithm written in
1191Java, each algorithm has approximately 1000 code snippets.
Our clustering task here is to cluster all the code snippets
(without class labels) according to the similarity among the
code vectors: For the OJ dataset, we use K-means (K=104)
to cluster the code into 104 clusters; For the SA dataset, we
use K-means (K=10) to cluster the code. Then we use the
class labels in the datasets to check if the clusters are formed
appropriately.
We use the Adjusted Rand Index [59] as the metric to
evaluate the clustering results. Here we present the deÔ¨Ånition
of Rand Index. Let Cbe the ground truth class assignment,
andKbe the number of clusters assigned by a clustering
algorithm. Let abe the number of pairs of elements that are in
the same set in Cand the same set in K; andbas the number
of pairs of elements that are in different sets in Cand different
sets inK. Rand Index for two datasets can be deÔ¨Åned as:
RI=a+b
(nsamples
2), where the combinatorial number nsamples
2
is the total number of possible pairs in the dataset (without
ordering). However, the RIscore does not guarantee that
random label assignments will get a value close to zero (esp. if
the number of clusters is in the same order of magnitude as
the number of samples). To counter this effect, Adjusted Rand
Index is deÔ¨Åned by discounting the expected RIof random
labelling as followed: ARI =RI E[RI]
max(RI) E[RI]:
For the baselines, if we treat source code as text, the self-
supervised learning techniques in NLP can also be applied for
code. As such, we include two well-known baselines from
NLP, Word2vec [22], and Doc2vec [23]. We also include
another baseline from [60], a state-of-the-art method to learn
sentence representation. This method uses a Sequential De-
noising Auto Encoder (SAE) method to encode the text into
an embedding, and reconstruct the text from such embedding.
We also compare with two baselines for code modeling,
Code2vec [8] and Code2seq [13]. Code2vec works by training
a path encoder on bag-of-paths extracted from the AST. The
path encoder will encode the paths into an embedding ~ v, then
use~ vto predict the method name. Code2seq shares a similar
principle, but ~ vis used to generate a textual summary of code.
In either case, we use the path encoders of Code2vec and
Code2seq to produce the code vectors and also perform the
same clustering process as InferCode.
2) Results: Table I shows the results of code clustering
using different models. InferCode performs the best for both
datasets. The NLP methods, however, underperform other code
learning methods. This is reasonable because both Code2vec
and Code2seq capture structural information from code, while
NLP methods treat code as text sequences. We will provide a
deeper analysis of the clusters by providing visualizations of
the vectors produced by different methods (see Section VII-A).
B. Code Clone Detection
1) Datasets, Metrics and Baselines: We use two datasets
in two languages. One is the OJ Dataset again that contains
52,000 C/C++ programs. The other is the BigCloneBench, a
Java dataset that has been widely used to benchmark codeTABLE I
RESULTS OF CODE CLUSTERING IN ADJUSTED RAND INDEX (ARI)
ModelPerformance (ARI)
OJ Dataset (C) SA Dataset (Java)
Word2vec 0.28 0.24
Doc2vec 0.42 0.29
SAE 0.41 0.31
Code2vec 0.58 0.51
Code2seq 0.53 049
InferCode 0.70 0.62
clone detection techniques, which consists of projects from
25,000 projects, covering 10 functionalities and including
6,000,000 true clone pairs and 260,000 false clone pairs. For
the OJ Dataset, we followed the process in Zhang et al. [44] to
construct a set of code pairs for clone detection based on pair-
wise similarity measurement, so-called OJClone: We choose
500 programs from each of the Ô¨Årst 15 programming problems
in OJ. It would produce a total of 1.8 million clone pairs
and 26.2 million non-clone pairs, which are extremely time-
consuming for comparison. So that we randomly select 50000
samples clone pairs and 50000 non-clone pairs for measuring
the performance of various clone detectors.
We use the well-known Precision, Recall, and F1 scores.
Since the task is unsupervised, in this paper we compare
InferCode only with unsupervised clone detectors that do not
require labeled data (although the pretrained InferCode can
also be applied to supervised clone detection). The baselines
include Deckard [61], SourcererCC [62], DLC [63], and a de-
tector using the code vectors extracted from Code2vec [8, 16]
and the same cosine similarity threshold used for InferCode.
2) Results: Table II shows the overall precision, recall and
F1 for InferCode and other baselines. The detector based
on InferCode has the highest recall (except for SourcererCC
whose precision is relatively low). Overall in terms of F1, it
outperforms other unsupervised clone detectors.
Note that we do not compare with techniques such as
Oreo [55], CCD [14], ASTNN [44] because they use super-
vised learning techniques to build clone classiÔ¨Åers . We believe
that the code embeddings or the weights from the pretrained
InferCode can be used for training supervised clone classiÔ¨Åers
too, and with further improvement on self-supervised learning
techniques such as improving the encoder, the auto-identiÔ¨Åed
labels, and the loss function, the performance of unsupervised
code clone detection may also get close to supervised ones.
We leave these evaluations for future work.
TABLE II
RESULTS OF CODE CLONE DETECTION IN PRECISION , RECALL AND F1
MethodsBigCloneBench (Java) OJClone (C)
P R F1 P R F1
Deckard 0.93 0.02 0.03 0.99 0.05 0.10
DLC 0.95 0.01 0.01 0.71 0.00 0.00
SourcererCC 0.88 0.02 0.03 0.07 0.74 0.14
Code2vec 0.82 0.40 0.60 0.56 0.69 0.61
InferCode 0.90 0.56 0.75 0.61 0.70 0.64
1192C. Cross Language Code-to-Code Search
1) Datasets, Metrics, and Baselines: Given the implemen-
tation of an algorithm in one language, this task is to search
for other implementations of the same algorithm written in
other languages. So we need a dataset that contains multiple
implementations of algorithms in different languages. We
construct such a codebase by searching from the Rosetta Code2
and other code from GitHub: We collect code in Java, C, C++,
C# from Rosetta Code which results in around 3000 samples,
then we collect 5000 random program Ô¨Åles from Github for
each of the languages and mix them with the samples.
For instance, for Java, we collect a large set of Java projects
from Github that have at least 10 stars. There is a possibility
that the collected GitHub projects contain implementations
of the algorithms in the Rosetta Code. So we perform a
simple text Ô¨Åltering to exclude all the Ô¨Åles that contain a
token of any of the algorithm name. Let us take 3 algorithms
as examples (Bubble-sort, Singly-linked-list-Traversal, Yin-
yang3): We exclude any Ô¨Åle that contains any of these tokens:
fbubble, sort, singly, linked, list, traversal, yin, yang g. Then
for the remaining Java Ô¨Åles, we sample a subset of 5000 Ô¨Åles
and mix them with the Java implementations of the algorithms
from the Rosetta dataset. We do the same for C#, C++, C, and
obtain in total about 23,000 Ô¨Åles in our search code base.
With the constructed code base, we perform the evaluation
for cross-language search as follows: For each of the 3000
code Ô¨Åles from Rosetta Code, say a bubble sort implementation
written in Java, we use it as the query to retrieve other Ô¨Åles
containing top-K similar code. Here we choose K = 10 in this
evaluation. The ideal query results should only return a list of
code snippets that are from Rosetta Code but implement the
same bubble sort algorithm in C++, C#, and C; other results
would be considered as false positives. Since our assumption
is that there is only one relevant result for the query, we
use the well-known Mean Reciprocal Rank (MRR) as the
metric to evaluate the actual query results. This task can be
formulated as the information retrieval (IR) problem and the
neural IR techniques are widely applied recently for textual
data [64, 65, 66], we include Word2vec, Doc2vec, CLIR [66],
a cross-lingual information retrieval system for text. We also
follow Sachdev et al. [5] to include ElasticSearch, a fuzzy text
search baseline. Although there are recent methods designed
speciÔ¨Åcally for code-to-code search, such as Facoy [4] and
Aroma [56], they are designed only for monolingual code
search, thus we do not compare with them directly.
2) Results: Table III shows the results for InferCode and
other baselines. The performance of InferCode is the best
among all the models. ElasticSearch, on the other hand,
performs the worst; this is expected because ElasticSearch is
a simple fuzz text search technique not designed to capture
structural information of code.
2http://www.rosettacode.org, https://github.com/acmeism/RosettaCodeData
3These are taken from the names of the algorithms at https://github.com/
acmeism/RosettaCodeData/tree/master/TaskTABLE III
RESULTS OF CROSS -LANGUAGE CODE -TO-CODE SEARCH IN MEAN
RECIPROCAL RANK (MRR)
ApproachPerformance (MRR)
Java C# C++ C
ElasticSearch 0.13 0.18 0.22 0.21
Word2vec 0.33 0.36 0.30 0.32
Doc2vec 0.32 0.34 0.38 0.30
CLIR 0.29 0.32 0.34 0.39
InferCode 0.57 0.45 0.51 0.54
D. Fine-Tuning for Supervised Learning Tasks
1) Datasets, Metrics, and Baselines:
a) Code ClassiÔ¨Åcation: We again use the OJ Dataset for
this task. We split this dataset into three parts for training,
testing, and validation by the ratio of 70:20:10. Out of the
training data, we feed X% to the neural model, where X = 1,
10, 100. We then initialize the neural model either randomly
or with the weights from the pre-trained InferCode. Therefore,
we have four settings for training the supervised model for
comparison: Ô¨Åne-tuning the TBCNN encoder with 1%, 10%,
or 100% of the labeled training data respectively, and the
randomly initialized model. Using only 1% or 10% is to
demonstrate that given a pre-trained model, one only needs
a small amount of labeled data to achieve reasonably good
performance for the downstream task.
We use the accuracy metric widely used for classiÔ¨Åcation
tasks. As the baselines, we include the ASTNN [44] trained
from scratch, which is a state-of-the-art model for code
classiÔ¨Åcation on the OJ dataset, and TextCNN [67] and Bi-
LSTM [68] trained with 100% of the training data, which are
widely used for text classiÔ¨Åcation.
b) Method Name Prediction: We use the Java-Small
dataset widely used as a benchmark for method name predic-
tion and has been used in Code2vec [8] and Code2seq [13].
This dataset has already been split into three parts, namely
training, testing, and validation. We perform the same eval-
uation protocol as the code classiÔ¨Åcation task by Ô¨Åne-tuning
the model with 1%, 10%, and 100% of the labeled training
data, in contrast to random initialization of the model without
Ô¨Åne-tuning. To predict the method name, we follow Code2vec
to use the code vector ~ vto predict the embedding of a method
name from a lookup table (see Section 4.2 in Code2vec [8]).
We measure prediction performance using precision (P), recall
(R), and F1 scores over the sub-words in generated names,
following the metrics used by Alon et al. [8]. For example,
a predicted name result_compute is considered as an
exact match of the ground-truth name computeResult ;
predicted compute has full precision but only 50% recall;
and predicted compute_model_result has full recall but
only 67% precision.
2) Results: Table IV shows the results for code classiÔ¨Åca-
tion. Fine-tuning on 10% of the training data gets comparable
results with the NLP baselines. Fine-tuning on 100% of the
training data gets comparable with ASTNN, a state-of-the-art
model for code classiÔ¨Åcation on the OJ dataset.
1193TABLE IV
RESULTS OF CODE CLASSIFICATION IN ACCURACY WITH FINE-TUNING
(FT) ON THE OJDATASET
Approach FT (1%) FT (10%) FT (100%) Supervised
InferCode 70.4% 87.6% 98.0% 94%
TextCNN - - - 88.7%
Bi-LSTM - - - 88.0%
ASTNN - - - 97.8%
TABLE V
RESULT OF METHOD NAME PREDICTION IN F1WITH FINE-TUNING (FT)
ON THE JAVA-SMALL DATASET
Approach FT (1%) FT (10%) FT (100%) Supervised
InferCode 20.31% 30.54% 43.33% 35.67%
Code2vec - - - 18.62%
Code2seq - - - 43.02%
Table V shows the results for method name prediction. We
get a comparable result with Code2seq when Ô¨Åne-tuning with
100% labeled data.
E. Summary
InferCode outperforms most of the baselines across Ô¨Åve
tasks, including three unsupervised ones (code clustering, code
clone detection via similarity measurement), cross-language
code-to-code search), and two supervised ones (code classiÔ¨Å-
cation and method name prediction).
Note that this does not mean that the TBCNN encoder in
InferCode is better than ASTNN, Code2vec, or Code2seq, as
those neural models can be used as the encoder in InferCode
too. It only means that pre-training a model on large unla-
beled data using self-supervised learning to predict subtrees
can produce more transferable models while maintaining the
performance of such models for various code learning tasks.
The performance of the self-supervised learning models
may be improved further with different encoders. We leave
those explorations for future work.
VII. A NALYSIS
This section analyses the effects of various parameters on
the performance of different tasks.
A. Cluster Visualization
To help understand why the vectors produced by InferCode
are better than the vectors produced by others, we visualize
the vectors of the programs from the OJ dataset that have
been used for the code clustering. We choose the embeddings
produced by Doc2vec, Code2vec, and InferCode for the Ô¨Årst
9 classes of the OJ dataset, then we use T-SNE [69] to
reduce the dimension of the vectors into two-dimensional
space and visualize. As shown in Figure 6, (1) the vectors
produced by InferCode group similar code snippets into the
same cluster with clearer boundaries, and (2) The boundaries
among clusters produced by Doc2vec and Code2vec are less
clear, which makes it more difÔ¨Åcult for the K-means algorithm
to cluster the snippets correctly. This is aligned with the
performance of the code clustering task (Table I). Also, we
observe that some points marked in the same color (e.g., red)are somewhat far away from each other even in the vectors
from InferCode, while they are supposed to be close according
to the ground truth. This could indicate further improvement
to Infercode can be made in future work.
B. Effect of Textual Information in TBCNN
The original TBCNN in Mou et al. [43] does not include
textual information in AST nodes to initialize the node em-
bedding. In our implementation, we include the textual infor-
mation by fusing it with the node type information through
a linear layer. To help understand the effect of such a fusion
process, we perform an ablation study by training InferCode
with different initialization information on the Java-Large
dataset and perform the evaluations on the three unsupervised
tasks: code clustering (CC), code clone detection (CCD), and
cross-language code-to-code search (CLCS) with the same
settings for each of the tasks in Section VI. Table VI shows
the results of this study. Using only type or token information
will result in worse performance for all three tasks.
TABLE VI
EFFECTS OF DIFFERENT INITIALIZATION METHODS
Task Dataset MetricInitial Information
Type Token Combine
CC OJ ARI 0.57 0.28 0.70
CCD BigCloneBench P 0.45 0.49 0.90
CLCS Rosetta Stone MRR 0.18 0.39 0.57
C. Alternative Choices to the Pretext Task Labels
There are a few alternatives when we use subtrees as the
pseudo labels for the pretext task in InferCode. One can easily
replace the subtrees with tokens so that the code vector ~ vcan
predict the tokens of the code snippets (similar to Doc2vec),
or one can use all the method names as the pseudo labels and
train the~ vto predict the names, similar to Code2vec [8]. In
this section, we perform an ablation study to measure how
different types of labels can affect performance. As shown in
Table VII, the performance using the subtrees as the labels is
the best while using tokens as the labels result in the worst
performance. Although using the method name can result
in reasonable performance, it is still worse than using the
subtrees. An explanation for this is that by predicting method
names, the model is forced to learn some incorrect patterns
due to similar names in the code base that actually refer to
different code. For example, Jiang et al. [70] found that a
large number code snippets contain similar method names but
the actual implementations of the method bodies are different,
but their code vectors would be forced to predict the similar
method names, thus these vectors will be close in the vector
space despite that they should not be. This is a potential reason
to make the model trained by predicting method names a worse
choice for pretext task than using subtrees.
VIII. D ISCUSSION
A. Choice of Encoder
In this section, we want to discuss our choice on the decoder.
We choose TBCNN because of its ability to capture structural
1194Fig. 6. Visualization of the Code Vectors of the Programs from 9 classes in the OJ Dataset produced by InferCode, Code2vec and Doc2vec
TABLE VII
EFFECTS OF DIFFERENT WAYS TO SET UP LABELS OF THE PRETEXT TASK
Task Dataset MetricLabel
Token Method Name Subtree
CC OJ ARI 0.23 0.58 0.70
CCD BigCloneBench P 0.45 0.81 0.90
CLCS Rosetta Stone MRR 0.32 0.41 0.57
features of code that lie in ASTs and the modiÔ¨Åcation we
made to TBCNN can also capture textual information into
the model. There are many neural network designs that can
be used as a replacement of the TBCNN encoder, such as
ASTNN [44], Code2vec [8] or GGNN [49]; however, most
of them, especially the graph-based models, are unable to
scale and generalize for different programming languages. For
example, we can use the path encoder of Code2vec to encode
the AST paths into the code vector ~ vand infer the subtrees.
GGNN is similar, one can pre-train the GGNN over a self-
supervised learning task. Although the graph representation
proposed by Narayanan et al. [28], Allamanis et al. [49] has
been shown to work well on tasks such as supervised clone
detection, code summarization, variable name prediction, etc.,
choosing the suitable edges to be included in the graph
representations for such tasks can be time-consuming and not
generalizable. LambdaNet [71] is another graph-based model
that also contains semantic edges designed speciÔ¨Åcally for
the type prediction task. As such, it is not straightforward to
transfer a pre-trained graph learning model through different
code learning tasks and it is not easy to scale the graph
representation of code into multiple languages. Similar reasons
can also be applied for path-based models, such as Code2vec
and Code2seq, or execution trace-based models [30]. On the
other hand, TBCNN is designed to receive the AST directly
with minimal engineering effort to process it. AST is relatively
easy to produce accurately for most programming languages
given their grammars, thus building a tree-based learning
model on top of ASTs implies that we can have a model that is
easier to generalize across languages, which is the advantage
to choose tree-based models over others. Note that this is not to
say that other models do not perform well on the code learning
tasks; they can still perform well when training data and time
are specially utilized, and they may be used together with each
other as the encoder in the self-supervised learning framework
to improve the performance for various tasks further. We leave
all the exciting explorations for future work.B. Assumption on Predicting Similar Subtrees with Opposite
Meaning
InferCode works on the basis of the key assumption that
code snippets containing similar subtrees have the same mean-
ings. There are instances where code snippets can have the
opposite meaning even if they have the same subtree, e.g.,
‚ÄùA<B ‚Äù vs. ‚ÄùB <A .‚Äù This issue is addressed by modifying
the TBCNN to encode the information of the tokens. Note
that the original TBCNN Mou et al. [43] only encodes the
node type information. With this change, the TBCNN can
distinguish both syntactic and semantic information better
than the original version, as implied by the results shown in
Table VI.
IX. C ONCLUSIONS
We have proposed InferCode, a self-supervised learning
technique for source code learning on unlabeled data. Along
with the document embedding principle that similar documents
contain similar words, our working intuition is that similar
ASTs should have similar subtrees to predict using a code
embedding learnt from the ASTs. We Ô¨Årst train a tree-based
CNN on large scale datasets, then reuse it as a pre-trained
model for the InferCode encoder to map any AST into an
embedding vector for downstream tasks, such as code cluster-
ing, code clone detection, or code-to-code search. Evaluation
of these tasks shows that the embeddings produced by the
InferCode encoder outperform the other baselines with signif-
icant margins. Furthermore, the weights of the self-supervised
pretrained model can be used for subsequent supervised Ô¨Åne-
tuning, which outperforms the supervised models trained from
a scratch. In the future, we will explore other choices of the
encoder and adapt InferCode to other SE tasks such as bug
localization, defect prediction, variable name prediction, etc.
ACKNOWLEDGEMENTS
This research is supported by the Singapore Ministry of Ed-
ucation (MOE) Academic Research Fund (AcRF) Tier 1 grant
and RISE Lab Operational Fund from SIS at SMU, Singapore
MOE AcRF Tier 2 Award No. MOE2019-T2-1-193, Royal
Society projects (IES/R1/191138, IES/R3/193175), EPSRC
STRIDE project (EP/T017465/1), and Huawei Trustworthy
Software Engineering Lab. We also thank the anonymous
reviewers for their insightful comments and suggestions, and
thank the authors of related work for sharing data.
1195REFERENCES
[1] R. Nix and J. Zhang, ‚ÄúClassiÔ¨Åcation of android apps and
malware using deep neural networks,‚Äù in International
Joint Conference on Neural Networks , May 2017, pp.
1871‚Äì1878.
[2] G. E. Dahl, J. W. Stokes, L. Deng, and D. Yu, ‚ÄúLarge-
scale malware classiÔ¨Åcation using random projections
and neural networks,‚Äù in IEEE International Conference
on Acoustics, Speech and Signal Processing , 2013, pp.
3422‚Äì3426.
[3] X. Gu, H. Zhang, and S. Kim, ‚ÄúDeep code search,‚Äù in
40th ICSE , 2018, pp. 933‚Äì944.
[4] K. Kim, D. Kim, T. F. Bissyand ¬¥e, E. Choi, L. Li, J. Klein,
and Y . L. Traon, ‚ÄúFaCoY: a code-to-code search engine,‚Äù
inICSE , 2018, pp. 946‚Äì957.
[5] S. Sachdev, H. Li, S. Luan, S. Kim, K. Sen, and S. Chan-
dra, ‚ÄúRetrieval on source code: A neural code search,‚Äù in
2nd ACM SIGPLAN International Workshop on Machine
Learning and Programming Languages , 2018, p. 3141.
[6] X. Hu, G. Li, X. Xia, D. Lo, and Z. Jin, ‚ÄúDeep code
comment generation,‚Äù in ICPC , 2018, pp. 200‚Äì210.
[7] Y . Wan, Z. Zhao, M. Yang, G. Xu, H. Ying, J. Wu, and
P. S. Yu, ‚ÄúImproving automatic source code summariza-
tion via deep reinforcement learning,‚Äù in 33rd ASE , New
York, NY , USA, 2018, p. 397407.
[8] U. Alon, M. Zilberstein, O. Levy, and E. Ya-
hav, ‚ÄúCode2vec: Learning distributed representations of
code,‚Äù in POPL , 2019, pp. 40:1‚Äì40:29.
[9] J. Li, P. He, J. Zhu, and M. R. Lyu, ‚ÄúSoftware defect
prediction via convolutional neural network,‚Äù in IEEE
QRS, 2017, pp. 318‚Äì328.
[10] Y . Zhou, S. Liu, J. K. Siow, X. Du, and Y . Liu, ‚ÄúDevign:
Effective vulnerability identiÔ¨Åcation by learning compre-
hensive program semantics via graph neural networks,‚Äù
inNeurIPS , 2019, pp. 10 197‚Äì10 207.
[11] X. Chen, C. Liu, and D. Song, ‚ÄúTree-to-tree neural
networks for program translation,‚Äù in NeurIPS , 2018, pp.
2547‚Äì2557.
[12] X. Gu, H. Zhang, D. Zhang, and S. Kim, ‚ÄúDeepAM:
Migrate apis with multi-modal sequence to sequence
learning,‚Äù in IJCAI , 2017, pp. 3675‚Äì3681.
[13] U. Alon, S. Brody, O. Levy, and E. Yahav, ‚Äúcode2seq:
Generating sequences from structured representations of
code,‚Äù in ICLR , 2019.
[14] C. Fang, Z. Liu, Y . Shi, J. Huang, and Q. Shi, ‚ÄúFunctional
code clone detection with syntax and semantics fusion
learning,‚Äù in 29th ISSTA , 2020, pp. 516‚Äì527.
[15] W. Wang, G. Li, B. Ma, X. Xia, and Z. Jin, ‚ÄúDetect-
ing code clones with graph neural network and Ô¨Çow-
augmented abstract syntax tree,‚Äù in 27th SANER , 2020,
pp. 261‚Äì271.
[16] H. J. Kang, T. F. Bissyand ¬¥e, and D. Lo, ‚ÄúAssessing the
generalizability of code2vec token embeddings,‚Äù in 34th
ASE, 2019, pp. 1‚Äì12.
[17] G. E. Hinton, S. Osindero, and Y .-W. Teh, ‚ÄúA fast learn-ing algorithm for deep belief nets,‚Äù Neural computation ,
vol. 18, no. 7, pp. 1527‚Äì1554, 2006.
[18] T. Chen, S. Kornblith, M. Norouzi, and G. Hinton,
‚ÄúA simple framework for contrastive learning of visual
representations,‚Äù ICML‚Äô20 , pp. 1597‚Äì1607.
[19] M. Yasunaga and P. Liang, ‚ÄúGraph-based, self-supervised
program repair from diagnostic feedback,‚Äù ICML‚Äô20 , pp.
10 799‚Äì10 808.
[20] C. Doersch and A. Zisserman, ‚ÄúMulti-task self-
supervised visual learning,‚Äù in ICCV , 2017, pp. 2051‚Äì
2060.
[21] A. Kolesnikov, X. Zhai, and L. Beyer, ‚ÄúRevisiting self-
supervised visual representation learning,‚Äù in CVPR ,
2019, pp. 1920‚Äì1929.
[22] T. Mikolov, I. Sutskever, K. Chen, G. S. Corrado,
and J. Dean, ‚ÄúDistributed representations of words and
phrases and their compositionality,‚Äù in NeurIPS , 2013,
pp. 3111‚Äì3119.
[23] Q. Le and T. Mikolov, ‚ÄúDistributed representations of
sentences and documents,‚Äù in ICML , 2014, pp. 1188‚Äì
1196.
[24] H. Wei and M. Li, ‚ÄúSupervised deep features for soft-
ware functional clone detection by exploiting lexical and
syntactical information in source code,‚Äù in IJCAI , 2017,
pp. 3034‚Äì3040.
[25] B. Ingram. (2018) A comparative study of various
code embeddings in software semantic matching. https:
//github.com/waingram/code-embeddings.
[26] H. Aman, S. Amasaki, T. Yokogawa, and M. Kawahara,
‚ÄúA doc2vec-based assessment of comments and its appli-
cation to change-prone method analysis,‚Äù in 25th APSEC ,
2018, pp. 643‚Äì647.
[27] Z. Chen and M. Monperrus, ‚ÄúA literature study of embed-
dings on source code,‚Äù arXiv preprint arXiv:1904.03061 ,
2019.
[28] A. Narayanan, M. Chandramohan, R. Venkatesan,
L. Chen, Y . Liu, and S. Jaiswal, ‚Äúgraph2vec: Learn-
ing distributed representations of graphs,‚Äù CoRR , vol.
abs/1707.05005, 2017.
[29] M. Tufano, C. Watson, G. Bavota, M. Di Penta,
M. White, and D. Poshyvanyk, ‚ÄúDeep learning similar-
ities from different representations of source code,‚Äù in
15th MSR , 2018, pp. 542‚Äì553.
[30] K. Wang and Z. Su, ‚ÄúBlended, precise semantic program
embeddings,‚Äù in PLDI‚Äô20 , p. 121134.
[31] M. L. Collard, M. J. Decker, and J. I. Maletic, ‚Äúsrcml: An
infrastructure for the exploration, analysis, and manipu-
lation of source code: A tool demonstration,‚Äù in ICSM ,
2013, pp. 516‚Äì519.
[32] Y . Yu, ‚Äúfast: Ô¨Çattening abstract syntax trees for efÔ¨Å-
ciency,‚Äù in ICSE‚Äô19 , pp. 278‚Äì279.
[33] A. Mahendran, J. Thewlis, and A. Vedaldi, ‚ÄúCross pixel
optical-Ô¨Çow similarity for self-supervised learning,‚Äù in
Asian Conference on Computer Vision , 2018, pp. 99‚Äì116.
[34] S. Gidaris, P. Singh, and N. Komodakis, ‚ÄúUnsupervised
representation learning by predicting image rotations,‚Äù in
1196ICLR‚Äô18 .
[35] R. Zhang, P. Isola, and A. A. Efros, ‚ÄúColorful image
colorization,‚Äù in ECCV , 2016, pp. 649‚Äì666.
[36] B. Korbar, D. Tran, and L. Torresani, ‚ÄúCooperative
learning of audio and video models from self-supervised
synchronization,‚Äù in NeurIPS , 2018, pp. 7763‚Äì7774.
[37] D. Kim, D. Cho, and I. S. Kweon, ‚ÄúSelf-supervised video
representation learning with space-time cubic puzzles,‚Äù in
AAAI , vol. 33, 2019, pp. 8545‚Äì8552.
[38] B. Fernando, H. Bilen, E. Gavves, and S. Gould, ‚ÄúSelf-
supervised video representation learning with odd-one-
out networks,‚Äù in CVPR , 2017, pp. 3636‚Äì3645.
[39] R. Kiros, Y . Zhu, R. R. Salakhutdinov, R. Zemel, R. Ur-
tasun, A. Torralba, and S. Fidler, ‚ÄúSkip-thought vectors,‚Äù
inNeurIPS , 2015, pp. 3294‚Äì3302.
[40] J. Devlin, M.-W. Chang, K. Lee, and K. Toutanova,
‚ÄúBERT: Pre-training of deep bidirectional transformers
for language understanding,‚Äù in NAACL‚Äô18 , p. 41714186.
[41] L. Logeswaran and H. Lee, ‚ÄúAn efÔ¨Åcient framework for
learning sentence representations,‚Äù in ICLR‚Äô18 , pp. 1‚Äì16.
[42] T. Kenter, A. Borisov, and M. de Rijke, ‚ÄúSiamese CBOW:
optimizing word embeddings for sentence representa-
tions,‚Äù in ACL‚Äô16 , p. 941951.
[43] L. Mou, G. Li, L. Zhang, T. Wang, and Z. Jin, ‚ÄúCon-
volutional neural networks over tree structures for pro-
gramming language processing,‚Äù in AAAI , 2016.
[44] J. Zhang, X. Wang, H. Zhang, H. Sun, K. Wang, and
X. Liu, ‚ÄúA novel neural source code representation based
on abstract syntax tree,‚Äù in 41st ICSE , 2019, pp. 783‚Äì794.
[45] M. Pradel and K. Sen, ‚ÄúDeepbugs: A learning approach
to name-based bug detection,‚Äù ACM on Programming
Languages , vol. 2, no. OOPSLA, p. 147, 2018.
[46] R. Gupta, A. Kanade, and S. Shevade, ‚ÄúNeural attribution
for semantic bug-localization in student programs,‚Äù in
NeurIPS , 2019, pp. 11 861‚Äì11 871.
[47] P. Fernandes, M. Allamanis, and M. Brockschmidt,
‚ÄúStructured neural summarization,‚Äù in 7th ICLR , 2019.
[48] M. Brockschmidt, M. Allamanis, A. L. Gaunt, and
O. Polozov, ‚ÄúGenerative code modeling with graphs,‚Äù in
7th ICLR , 2019.
[49] M. Allamanis, M. Brockschmidt, and M. Khademi,
‚ÄúLearning to represent programs with graphs,‚Äù in ICLR ,
2018.
[50] Y . Li, D. Tarlow, M. Brockschmidt, and R. Zemel, ‚ÄúGated
graph sequence neural networks,‚Äù in ICLR , Nov. 2016.
[51] L. Mou, H. Peng, G. Li, Y . Xu, L. Zhang, and Z. Jin,
‚ÄúDiscriminative neural sentence modeling by tree-based
convolution,‚Äù in EMNLP , 2015, pp. 2315‚Äì2325.
[52] N. D. Bui, L. Jiang, and Y . Yu, ‚ÄúCross-language learning
for program classiÔ¨Åcation using bilateral tree-based con-
volutional neural networks,‚Äù in NL4SE@AAAI‚Äô18 , 2018.
[53] H. Yu, W. Lam, L. Chen, G. Li, T. Xie, and Q. Wang,
‚ÄúNeural detection of semantic code clones via tree-based
convolution,‚Äù in 27th ICPC , 2019, pp. 70‚Äì80.
[54] T. Kanungo, D. M. Mount, N. S. Netanyahu, C. D.
Piatko, R. Silverman, and A. Y . Wu, ‚ÄúAn efÔ¨Åcient k-means clustering algorithm: Analysis and implementa-
tion,‚Äù IEEE Trans. Pattern Anal. Mach. Intell. , vol. 24,
no. 7, pp. 881‚Äì892, 2002.
[55] V . Saini, F. Farmahinifarahani, Y . Lu, P. Baldi, and C. V .
Lopes, ‚ÄúOreo: Detection of clones in the twilight zone,‚Äù
in26th ESEC/FSE , 2018, pp. 354‚Äì365.
[56] S. Luan, D. Yang, C. Barnaby, K. Sen, and S. Chan-
dra, ‚ÄúAroma: Code recommendation via structural code
search,‚Äù ACM on Programming Languages , vol. 3, no.
OOPSLA, pp. 1‚Äì28, 2019.
[57] D. P. Kingma and J. Ba, ‚ÄúAdam: A method for stochastic
optimization,‚Äù in ICLR‚Äô15 .
[58] B. D. Q. Nghi, Y . Yu, and L. Jiang, ‚ÄúBilateral dependency
neural networks for cross-language algorithm classiÔ¨Åca-
tion,‚Äù in SANER‚Äô19 , pp. 422‚Äì433.
[59] J. M. Santos and M. Embrechts, ‚ÄúOn the use of the
adjusted rand index as a metric for evaluating supervised
classiÔ¨Åcation,‚Äù in International conference on artiÔ¨Åcial
neural networks , 2009, pp. 175‚Äì184.
[60] F. Hill, K. Cho, and A. Korhonen, ‚ÄúLearning distributed
representations of sentences from unlabelled data,‚Äù in
NAACL‚Äô16 , p. 13671377.
[61] L. Jiang, G. Misherghi, Z. Su, and S. Glondu, ‚ÄúDeckard:
Scalable and accurate tree-based detection of code
clones,‚Äù in 29th ICSE , 2007, pp. 96‚Äì105.
[62] H. Sajnani, V . Saini, J. Svajlenko, C. K. Roy, and C. V .
Lopes, ‚ÄúSourcererCC: Scaling code clone detection to
big-code,‚Äù in 38th ICSE , 2016, pp. 1157‚Äì1168.
[63] M. White, M. Tufano, C. Vendome, and D. Poshyvanyk,
‚ÄúDeep learning code fragments for code clone detection,‚Äù
in31st ASE , 2016, pp. 87‚Äì98.
[64] L. Wang, J. Lin, and D. Metzler, ‚ÄúA cascade ranking
model for efÔ¨Åcient ranked retrieval,‚Äù in 34th SIGIR , 2011,
pp. 105‚Äì114.
[65] S. Wan, Y . Lan, J. Guo, J. Xu, L. Pang, and X. Cheng,
‚ÄúA deep architecture for semantic matching with multiple
positional sentence representations.‚Äù in AAAI , vol. 16,
2016, pp. 2835‚Äì2841.
[66] I. Vuli ¬¥c and M.-F. Moens, ‚ÄúMonolingual and cross-
lingual information retrieval models based on (bilingual)
word embeddings,‚Äù in 38th SIGIR , 2015, pp. 363‚Äì372.
[67] Y . Kim, ‚ÄúConvolutional neural networks for sentence
classiÔ¨Åcation,‚Äù p. 17461751.
[68] M. Schuster and K. K. Paliwal, ‚ÄúBidirectional recurrent
neural networks,‚Äù IEEE Trans. Signal Process. , vol. 45,
no. 11, pp. 2673‚Äì2681, 1997.
[69] L. v. d. Maaten and G. Hinton, ‚ÄúVisualizing data using t-
sne,‚Äù Journal of Machine Learning Research , vol. 9, no.
Nov, pp. 2579‚Äì2605, 2008.
[70] L. Jiang, H. Liu, and H. Jiang, ‚ÄúMachine learning based
recommendation of method names: how far are we,‚Äù in
34th ASE , 2019, pp. 602‚Äì614.
[71] J. Wei, M. Goyal, G. Durrett, and I. Dillig, ‚ÄúLamb-
danet: Probabilistic type inference using graph neural
networks,‚Äù in ICLR‚Äô20 .
1197