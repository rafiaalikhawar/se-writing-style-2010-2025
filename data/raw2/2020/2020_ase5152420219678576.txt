APIzation: Generating Reusable APIs from
StackOverﬂow Code Snippets
V alerio Terragni
University of Auckland
Auckland, New Zealand
v.terragni@auckland.ac.nzPasquale Salza
University of Zurich
Zurich, Switzerland
salza@iﬁ.uzh.ch
Abstract —Developer forums like StackOverﬂow have become es-
sential resources to modern software development practices. How-
ever, many code snippets lack a well-deﬁned method declaration,
and thus they are often incomplete for immediate reuse. Developers
must adapt the retrieved code snippets by parameterizing the
variables involved and identifying the return value. This activity,
which we call APIzation of a code snippet, can be tedious and
time-consuming. In this paper, we present API ZATOR to perform
APIzations of J AVA code snippets automatically. API ZATOR is
grounded by four common patterns that we extracted by studying
real APIzations in GitHub. API ZATOR presents a static analysis
algorithm that automatically extracts the method parameters
and return statements. We evaluated API ZATOR with a ground-
truth of 200 APIzations collected from 20developers. For 113
(56.50 % ) and 115 (57.50 % ) APIzations, API ZATOR and the
developers extracted identical parameters and return statements,
respectively. For 163 (81.50 % ) APIzations, either the parameters
or the return statements were identical.
Index T erms—APIs, software reuse, code snippets, StackOver-
ﬂow, GitHub, program analysis, program synthesis
I. I NTRODUCTION
Developers’ Q&A websites, such as StackOverﬂow (SO),
have gained a lot of popularity. These websites contain millions
of crowd-curated code snippets that represent solutions to
various programming tasks. These code snippets are extremely
useful to both developers and researchers. Developers often
search for them to draw inspiration or simply reuse them [ 1],
[2], [3]. Researchers often rely on SO to accomplish various
software engineering goals [4].
When reusing SO code snippets, developers and researchers
face a major obstacle: most SO code snippets do not com-
pile [ 5], [6], [7]. It mainly occurs because they are written
for illustrative purposes, to convey solutions at a high level,
without implementation details [ 8]. Terragni et al. have shown
that≈92 % of491,906 analyzed SO code snippets are un-
compilable [ 5]. A common missing implementation detail
is the type declaration [ 5], [ 6]. For instance, the J AVA SO
code snippet in Fig. 1 (left side) misses the declaration oftype
Calendar and Date . Researchers have tackled this issue
by proposing techniques to identify the import declarations
required to compile SO code snippets [5], [9].
Another common missing detail in SO code snippets is a
well-formed method declaration that deﬁnes the parameters
(input) and return statements (output) [ 10], [5]. Terragni et al.
have shown that ≈56 % of J AVA SO code snippets constitutedangling statements, which are not embedded in any classor method declarations [
5]. The SO code snippet in Fig. 1
(left side) is an example of dangling statements. One could
automatically wrap the code snippet inside a generic method
declaration [ 5], [6] (e.g., the main function). It would resolve
compilation errors but would not recover the proper method
declaration that exposes the intended input and output of the
code snippet. The absence of a proper interface prevents the
direct reuse of SO code snippets. Thus, some manual effort is
required to identify the inputs and outputs of the code snippets.
We use the term “APIzation” to indicate the activity of
creating an Application Program Interface (API) for those SO
code snippets without a well-formed method declaration. Fig. 1
(center) shows a manual APIzation of a SO code snippet.
In this paper, we study the automatic APIzation of J AVA
SO code snippets, which would bring important beneﬁts.Developers would reduce the effort of integrating SO code
snippets into their codebases, which is known to be a tedious
and time-consuming activity [ 11]. Given an automatically
generated API of a SO code snippet, developers can either copy
and paste the API in the codebase or incorporate the method
body of the API inside an existing method. The presence of
an API facilitates the latter option. Indeed, an API explicitly
shows the input and output of the code snippet, which helps
to both understand and incorporate the SO code. Moreover,
the automatic APIzation SO code snippets can lead to a large
catalog of code samples with well-deﬁned interfaces, providing
value for both developers and researchers.
Towards these goals, we conducted an investigatory study to
understand how developers perform APIzations from SO code
snippets to J AVA methods found in GitHub (GH). The insights
gained from this study led to four common APIzation patterns
to extract method parameters and return statements. Grounded
by these patterns, we propose a technique called API ZA TOR
for the automated APIzation of SO code snippets. To the best
of our knowledge, API ZA TOR is the ﬁrst technique of its kind.
API ZA TOR statically analyzes a given code snippet to ﬁnd
matches for the four patterns. If it ﬁnds matches, API ZA TOR
extracts the parameters and return statements and outputs a
compilable API. For completeness, API ZA TOR uses a Part-of-
Speech (POS) Tagger to generate a method name from the SO
question title, and creates a J AVA DOC containing the title and
link of the corresponding SO page.
5422021 36th IEEE/ACM International Conference on Automated Software Engineering (ASE)
DOI 10.1109/ASE51524.2021.000552021 36th IEEE/ACM International Conference on Automated Software Engineering (ASE) | 978-1-6654-0337-5/21/$31.00 ©2021 IEEE | DOI: 10.1109/ASE51524.2021.9678576
978-1-6654-0337-5/21/$31.00  ©2021  IEEE
Human
1
23456789
101112
Fig. 1. APIzation of a SO code snippet. API ZA TOR and the human produced identical APIs (except for the method name and J AVA DOC).
We evaluated API ZA TOR with a ground truth of 200
APIzations performed by 20 human participants, obtaining
200 pairs of human- and tool-produced APIs. We compared
each pair to assess the effectiveness of API ZA TOR .F o r 113
(56.50 % ) and 115 (57.50 % ) API pairs the parameter list and
return statements are identical, respectively. For 163 (81.50 % )
APIs generated by API ZA TOR either the return statements or
the method parameters are identical to those produced by the
developers. For instance, Fig. 1 (right side) shows the API
produced by API ZA TOR , which is identical to the one created
by the developer (excluding the method name and J AVA DOC).
To demonstrate one of the possible usage scenarios of
API ZA TOR , we release a search engine at the address https:
//apization.netlify.app/search/ and as part of our replication
package [ 12]. The users can search for SO code snippets with
a natural language query as they would do with a standard
search engine. The search results show the SO page as well
as its API automatically generated by API ZA TOR .
To summarize, the main contributions of this paper are:
•studying the problem of automatically transforming SO
code snippets into APIs;
•analyzing real APIzations across SO and GH projects,
extracting four common APIzation patterns;
•proposing a technique called API ZA TOR to transform SO
code snippets into well-formed J AVA method declarations;
•evaluating API ZA TOR against a ground truth of 200
APIzations performed by 20 JAVA developers;
•releasing at the address https://apization.netlify.app all the
experimental data;
•releasing 109,930 APIs automatically extracted from SO
code snippets, which could power SO-centric research.
II. P RELIMINARIES AND PROBLEM DEFINITION
In this paper, we target J AVA code snippets found in
StackOverﬂow (SO), the most popular Q&A website fordevelopers [
13]. The process of APIzation takes in input a
SO code snippet and generates a J AVA method declaration. We
now describe in detail the input and output of such a process.
Input: A J AVA code snippet from SO. A SO page is composed
of a question post and a series of answer posts. Each questionpost contains a title, a series of tags, and a description. A postcan contain one or more code snippets. A Code Snippet (CS)
is an ordered sequence of source code lines.Output: A compilable and well-formed J AVA method
declaration that deﬁnes the code snippet in input. Amethod
declaration, which we call Application Program Interface (API),consists of the following six attributes: (i) modiﬁers, which set
the access level (e.g.,
public), or achieve speciﬁc functionalities
(e.g., static ); (ii) return type, which indicates the type of value
that the method returns ( void if none); (iii) method name, which
describes the behavior of the method; (iv) parameter list , which
speciﬁes the types and identiﬁers of the method arguments;
(v)throws clause, which declares any checked exception classes
that the method body can throw; (vi) method body, which
contains the statements that implement the method.
The method body of a well-formed API references each of
the parameters and contains, if the return type is not void , one
or more return statements. To make an API compilable, it has
to be declared inside a class (e.g., Human2109186 in Fig. 1) that
contains the required import declarations (imports in short)
(e.g., java.util.Calendar and java.util.Date in Fig. 1). At
each class is associated a classpath to the library JAR Sthat
declare the types in imports (e.g., JDK in Fig. 1).
Most J AVA code snippets from SO are composed of dangling
statements not enclosed in any method declaration [ 5], [14],
[6] (see Fig. 1). The process of APIzation aims at generating
well-formed method declarations for such code snippets. It
achieves this by performing six actions:
1)choose a method name, e.g., getFirst DayOfWeek in Fig. 1;
2)recover missing declarations of variables or types from
the code snippet, e.g., Calendar and Date in Fig. 1;
3)identify which variables in the snippet are the intended
input parameters, e.g., variables week and year in Fig. 1;
4)remove the declarations of such variable from the code
snippet, e.g., int week =3;in Fig. 1;
5)infer the output of the snippet, if any, and add a return
statement for it, e.g., return calendar.getTime() in Fig. 1;
6)enclose the resulting statements in a method declaration
with proper parameters and return type, e.g., public static
Date (int week, int year) in Fig. 1.
Problem deﬁnition: Given a J AVA code snippet, the
process of APIzation generates a compilable and well-
formed method declaration for the given code snippet.
543III. U NDERST ANDING REAL WORLD API ZA TIONS
This section presents an investigatory study to understand
how developers perform APIzations. The insights gained from
this study led to four common APIzation patterns that establish
the foundations of our proposed technique. To collect manual
APIzations of StackOverﬂow (SO) code snippets, we relied on
GitHub (GH). Our goal is to ﬁnd code reuses across SO code
snippets and GH projects that represent APIzations. Fig. 2
gives two examples of such manual APIzations. We release
the data of our investigatory study in our replication package,
published at https://apization.netlify.app/study/.
A. Data Collection
Researchers have experimented two main approaches to
identify code reuses across SO and GH [15], [16], [17], [18],
[19], [20], [19]: (i) search for explicit SO web links in GH code
comments or J A V ADOC ; (ii) search for code clones between
SO code snippets and GH code.
Both of these approaches have pros and cons. Relying only
on explicit SO web links likely misses many code reuses.
In fact, GH developers often do not give proper credit when
reusing SO code snippets [ 18], [20]. It can also lead to spurious
code reuses as GH developers may cite a SO post because
it discusses a particular issue, which is unrelated to codereuse [
20]. Relying only on code clones has the advantage
to identify code reuses even without (rare) explicit SO links.
However, code clones cannot guarantee that the GH developers
performed the APIzation from SO [20], [15].
Because of the complementarity of these two approaches,
we decided to consider those code reuses that are identiﬁed
by both approaches. We will probably miss many code reuses,but we are more conﬁdent that the identiﬁed ones are genuine.
Thus, our goal is to identify pairs /angbracketleftCS, API/angbracketright (where CS is a
SO code snippet and API a GH method) that satisfy all of
these three criteria: (i) the comments or J AVA D O C of API have
an explicit link to the SO page containing CS; (ii) API and
CS are code clones; (iii) API is an APIzation of CS. We now
describe in more detail how we identiﬁed such pairs.
Find candidate pairs. We queried the latest snapshot of GH on
GOOGLE BIGQUERY [21], which contains ≈1million projects
with the tag J AVA . We identiﬁed 29,035 unique J AVA ﬁles
containing explicit links to SO pages. From the retrieved Java
ﬁles, we identiﬁed all the GH methods (API) containing the
explicit SO link as a code comment or in the JavaDoc. For eachSO link, we extracted the corresponding SO code snippet(s) byquerying the latest SO dump. We then pruned all those pairs in
which CS already contains a well-formed method declaration,
orCS has less than six lines.
Code clone detection. For each candidate pairs /angbracketleftCS, API/angbracketright ,w e
searched for TYPE 3 code clones [ 22], i.e., syntactically similar
code with inserted, deleted, or updated statements. We chose
TYPE 3 clones because both TYPE 2 and TYPE 4 are inadequate
for our purposes. TYPE 2 clones require syntactically equivalent
code (the only allowed variations are in identiﬁers, types,
whitespace, layout, and comments). This is too restrictivebecause the APIzations often create APIs with fewer or more
statements than the SO code snippets. For example, the human
APIzation of Fig. 1 deletes the SO lines 2 and 3 and updates
line 12. TYPE 4 clones allow semantically equivalent but
syntactically different code. This is too permissive because we
are only interested in explicit code reuses.
To detect TYPE 3 clones, we automatically perform alpha-
renaming of the variables (e.g., int a=5becomes int int0 =
5). If there are multiple variables with the same type, we use
a progressive id as a sufﬁx. For example, int a=5;int b
=10becomes int int0 =5;int int1 =10. We also removed
comments, new lines, and formatting characters. We treateda pair
/angbracketleftCS, API/angbracketright as a TYPE 3 code clone if at least 70 % of
CS source code lines are contained in API (we opted for 70 %
following Zhang et al. [ 19]). This resulted in 330 code clone
pairs, referring to 199 unique SO answer posts.
Note that TYPE 3 code clone detection excludes by default
TYPE 1 and TYPE 2 clones as they require a 100 % similar
code. This is impossible in our case since APIs always containa method signature, while the considered code snippets do not.
Manual check. We manually checked each of the 330 code
clone pairs to prune those in which the APIs do not represent the
APIzation of CS. We pruned the pairs that were spurious code
clones (the matched lines were mostly common lines of code
such as try{ and catch( ). We pruned the pairs that were valid
clones, but CS was incorporated inside the GH method. These
pairs are not APIzations because the GH method declaration
does not strictly relate to the SO code snippet.
B. Analysis of the Results
We manually analyzed the retained 135 pairs to study the
variables in the SO code snippet that became method parameters
or return statements in the GH method. We followed a coding
process inspired by grounded theory [23], which derives new
theories and concepts by analyzing the data.
We distributed between the two of us the 135 pairs of the
SO snippet and matching GH method. For convenience, we
used a diff tool to generate a visual representation of thecode differences between the snippet and method. Such arepresentation helped us to quickly identify the APIzation
activity performed by the developers. During the open coding
stage, we analyzed each of the assigned pairs to give a distinct
code for each of the observed phenomena, i.e., APIzations. In
particular, the question that drove the open coding was: “What
are the characteristics of the variables in the SO snippet that
became parameters and return statements in the GH method?”
Examples of produced codes are: “undeclared variable”, “the
variable has a constant value”, and “the variable is used as an
argument in a System.out.println invocation.”
Then, we reﬁned the codes by grouping similar concepts
and ﬁnding connections between them, i.e., axial coding. Then,
we concluded the patterns’ identiﬁcation with selective coding.
Each of the authors independently analyzed the pairs and
eventually discussed the results to reach a consensus. Finally,
we identiﬁed four common patterns ( PATT-notdecl ,PATT-
5441
23456789
10PATT–notdecl  and PATT–latest PATT–const  and PATT–syso
123456789
10111213
14
Fig. 2. Examples of APIzation patterns found in APIzations from StackOverﬂow to GitHub.
const ,PATT-latest , and PATT-syso ) that characterize and
deﬁne general APIzation activities.
1) Method Parameters: The 135 SO code snippets reference
509 variables with an average of 3.77variables per code snippet.
Among these 509 variables, 45became method parameters in
the corresponding GH method. Among these 45variables, 32
(71.11 % ) match PATT-notdecl and9(20.00 % ) match PATT-
const . For the remaining four variables, we were not able to
generalize any pattern.
PATT-notdecl .A variable vthat is referenced in CS is
extracted as a parameter if CS lacks the declaration of v.
Fig. 2 (top) shows one of the analyzed pairs that exhibits
such a pattern (the SO code snippet (CS) is on the left and the
GH method (API ) on the right). The line 4 of the CS references
an undeclared variable tag_ xml, and the GH developer extracted
tag_ xml as a method parameter at line 7 (renaming it to s). A
possible rationale for this pattern is that undeclared variables
in SO code snippets are commonly intended as the (implicit)
inputs of a programming task.
PATT-const .A variable vdeclared in CS is extracted as a
parameter if (i) CS initializes vwith a hard-coded value; and
(ii) CS does not have loops that modify the value of v.
Fig. 2 (bottom) shows a pair that manifests such a pattern.
The SO code snippet declares four variables: str,find Str,
lastIn dex, and count . It initializes them with hard-coded values
that embed data directly into the source code. These four
variables match criterion (i), but only str and find Str match
also criterion (ii). In fact, only str and find Str became method
parameters in the GH method. The variables lastIn dex and
count are excluded because the SO while loop can modify their
values. Extracting such variables would change the semanticsof the while loop. For example, if count is extracted as a
parameter, a user can invoke the API with a count value
different from zero, making the API return a meaningless value.
A possible rationale for this pattern is that SO code snippets
often exemplify programming tasks, and thus the hard-coded
values represent a particular instance of the inputs.
2) Return Statements: Among the 135 GH methods, 63
(46.67 % ) lack return statement(s) (the return type is void )
and72 (53.33 % ) have return statement(s). Among such 72
GH methods, 31(43.06 % ) match PATT-latest , and 6(8.33 % )
match PATT-syso . For the remaining methods, we could not
generalize any pattern or the SO code snippet already contained
return statement(s).
PATT-latest .The assignment of a variable in CS becomes
the return statement if it is the last statement in CS.
For example, the SO snippet in Fig. 2 (top) ends with the
assignment of the hash variable (we ignored exception handling
as last statements because they are unrelated to the semantics
of the code snippet), and the GH method returns hash of type
String . Intuitively, the last statement of a SO snippet often
characterizes its output. Indeed, it is unlikely that developers
end the snippet with a value irrelevant to the ﬁnal intent of
the programming task.
PATT-syso .If the last statement in CS is a System.out.println
call, its argument becomes the return statement.
An example of such a pattern is the SO snippet in Fig. 2 (bot-
tom). The code snippet ends with System.out.println(count) ,
and the GH method returns count of type int. Because SO
users write code snippets for illustration purposes, they often
add a print of the output value to show the result when the
snippet is being executed.
5453) Manual Application of the Patterns: After identifying the
four patterns, we applied them to the whole dataset to evaluate
if they lead to spurious parameters and return statements.
Among the 464 SO variables that did not become parameters
in the corresponding GH methods, 14(3.02 % ) and 8(1.72 % )
variables match PATT-notdecl andPATT-const , respectively.
Among the 93GH methods in which we did not identify any
pattern or lack return statements (i.e., return type is void ), the
patterns PATT-latest andPATT-syso match 4(4.30 % ) and 1
(1.08 %) variables, respectively.
This indicates that the four patterns lead to a few spurious
parameters and return statements. Thus, ﬁnding matches of
these patterns in SO code snippets is a viable solution for
automating the APIzation process.
IV . API ZA TOR
This paper presents API ZA TOR to automatically transform
JAVA SO code snippets into reusable and compilable APIs.
Algorithm 1 describes the process of API ZA TOR in detail.
Input and output. API ZA TOR takes as an input: (i) CS,aS O
code snippet; (ii) SO-page, the SO page of the snippet, which
API ZA TOR uses to generate the method name; (iii) JARs,a
set of common J AVA libraries to recover the missing import
and variable declarations [ 5]. API ZA TOR outputs (i) API, the
method declaration of CS; (ii) imports, the import declarations
of the non-primitive types that API references; (iii) classpath,
the libraries in JARs that declare the types in imports.
Preliminary check (Lines 1 to 3). Algorithm 1 starts by check-
ing if CS already contains import declarations (Line 1). If yes,
it extracts them and searches in JARs for the corresponding
libraries, which it adds to the classpath. If not (the common
case), it creates an empty imports list and an initial classpath
with only the JDK JAR library. Next, it checks if CS already
deﬁnes a well-formed and compilable API. If so, it returns CS,
imports, and classpath (Lines 2 to 3), otherwise it starts the
“APIzation” process.
Initialization of the API (Line 4). The “APIzation” process
begins by initializing API, the method declaration for CS.
By default, the modiﬁers ofAPI are public (because APIs
must be accessible by any other class) and static (to avoid
instantiating objects for invoking the API). The throws-clause of
API is the generic java.lang.Exception . API ZA TOR initializes
the method-body ofAPI with CS, the return type with void
and the parameter list with the empty list.
Method name generation (Line 5). For completeness, API ZA-
TOR generates a method name for the API from the title of the
SO page associated with the code snippet [ 24]. Indeed, the title
of the SO page often summarizes the intent of the programmingtask. API
ZA TOR relies on a Part-of-Speech (POS) Tagger [ 25]
to assign parts of speech (e.g., nouns, verbs, and adjectives)
to each word in the title. Then, API ZA TOR creates the method
name by combining the main “verb” of the sentence and the
corresponding “direct object” (i.e., noun). We consider these
two parts of speech because method names are typically verbs
or verb phrases. We do not claim this to be a contribution toAlgorithm 1: API ZA TOR
input : CS=/angbracketlefts1,...,sn/angbracketright,aSO code snippet
SO-page, the SO page of CS
JARs, a set of external libraries
output : API, a method declaration for CS
imports, the import declarations for API
classpath, the classpath for API
1/angbracketleftimports, classpath/angbracketright← GETORDEFAUL T (CS, JARs )
2ifCS is a well-formed method declaration (CS ≡API )then
3 return/angbracketleftAPI, imports, classpath/angbracketright
4API← CREA TE INITIAL METHOD DECLARA TION (imports, CS )
5API.method-name ← CREA TE METHOD NAME (SO-page )
6while COMPILE (API, imports, classpath )→errors/negationslash=∅do
7 iferrors⊆missing-type-decl then
8 /angbracketleftimports, classpath/angbracketright← CS NIPP EX(errors, JARs, imports,
classpath )
/* PATT-notdecl */
9 else if errors⊆missing-variable-decl then
10 forv∈(errors∩missing-variable-decl) do
11 /angbracketleftτ,imports, classpath/angbracketright← RECOVER VARTYPE (v, API,
JARs, imports, classpath )
12 T[v]←τ
13 add/angbracketleftτ,v/angbracketrighttoAPI.parameter-list
14 else return ∅
/* PATT-const */
15LP-VARS ← GETLOOP CHANGING VARS (API.method-body )
16forsi∈API.method-body do
17 casesi:τv=/epsilon1do // Variable decl. and init.
18 T[v]←τ
19 addvtoALREADY-INIT-VARS
20 ifISHARD CODED (τ,/epsilon1)∧v/notsubseteqlLP-VARS then
21 add/angbracketleftτ,v/angbracketrighttoAPI.parameter-list
22 removesifrom API.method-body
23 casesi:τv do // Variable declaration
24 /angbracketleftT[v],S[v]/angbracketright←/angbracketleftτ,si/angbracketright
25 casesi:v=/epsilon1do // Variable assignment
26 ifv/negationslash∈ALREADY-INIT-VARS then
27 addvtoALREADY-INIT-VARS
28 ifISHARD CODED (τ,/epsilon1)∧v/negationslash∈LP-VARS then
29 add/angbracketleftT[τ],v/angbracketrighttoAPI.parameter-list
30 removesifrom API.method-body
31 removeS[v]from API.method-body
/* PATT-latest */
32casesn:τv=/epsilon1do // Variable decl. and init.
33 API.return-type ←τ
34 replacesninAPI.method-body withreturn /epsilon1;
35casesn:v=/epsilon1do // Variable assignment
36 API.return-type ←T [v]
37 replacesninAPI.method-body withreturn /epsilon1;
/* PATT-syso */
38casesn:System.out.println(string-literal + /epsilon1)∨
System.out.println(/epsilon1) do
39 API.return-type ← GETTYPE OFEXP(/epsilon1, imports, classpath )
40 replacesninAPI.method-body withreturn /epsilon1;
41otherwise do
42 API.return-type ←void
43return/angbracketleftAPI, imports, classpath/angbracketright
this work. In the future, we plan to investigate state-of-the-art
approaches for generating method names [26].
For a statically-typed programming language such as J AVA ,
type inference is precise and unambiguous only with compilable
code [ 27]. API ZA TOR requires complete type information to
546know the type of the method parameters and return statements.
However, assuming only compilable code is infeasible because
most SO code snippets do not compile [ 5], [6], [9]. Line 6 of
Algorithm 1 tries to compile the API (wrapping it in a synthetic
JAVA class) with the current imports and classpath.I fa n y
compilation errors arise, API ZA TOR attempts to ﬁx them. Note
that, API ZA TOR needs to re-compile API iteratively because
ﬁxing a compilation error may reveal others [ 5]. API ZA TOR
supports two types of compilation errors: (i) missing typedeclarations (Line 7) and (ii) missing variable declarations
(Line 9). For other error types API ZA TOR terminates (Line 14).
Recover missing type declarations (Lines 7 to 8). API ZA TOR
relies on CS NIPP EX[5] to ﬁx missing type declarations.
CS NIPP EXrecovers the import declarations that ﬁx such errors
by querying the fully-qualiﬁed names of the classes declared
inJARs. This is challenging because there are often many
fully qualiﬁed names with the same simple name. CS NIPP EX
addresses the challenge with a greedy algorithm based on the
clustering hypothesis: “the referred library classes in a JAVA
source ﬁle often come from the same libraries, and hence their
import declarations tend to form clusters that share common
package names” [5]. For example, the code snippet in Fig. 2
(top) leads to two missing type declarations: MessageDi gest and
NoSuchAl gorith mException .C S NIPP EXidentiﬁes the correct
import declarations because they share the same package
name java.security .C S NIPP EXadds the corresponding J AVA
libraries in the classpath and leverages the feedback of the
compiler to check if the errors are ﬁxed.
Recover missing variable declarations ( PATT-notdecl ,
Lines 9 to 13). API ZA TOR recovers missing variable dec-
larations to ﬁx the compilation errors and to ﬁnd matchesof
PATT-notdecl , which considers undeclared variables as
method parameters. To recover missing variable declarations,
API ZA TOR relies on the R ECOVER VARTYPE function (Line 11).
Given an API with an undeclared variable v, this function
identiﬁes the most plausible type of vby leveraging the usages
ofvin the API, which follows the B AKER approach [28].
For example, the SO code snippet in Fig. 2 (top) lacks the
declaration of variable tag_ xml. API ZA TOR correctly infers
that the type of tag_ xml isjava.lang.String because (i) the
code snippet invokes the method public byte[] getBytes()
using tag_ xml as the object receiver, and (ii) java.lang.String
declares a method with the same name and return type.
When there are multiple plausible types, API ZA TOR uses a
successful compilation as a proxy for correctness. In fact,
API compiles without errors if the declaration of tag_ xml has
type java.lang.String . Line 11 of Algorithm 1 also updates
imports and classpath accordingly, which remain unchanged
in our example (the package java.lang is imported by default).
Next, API ZA TOR updates the map T, which stores for each
declared variable in CS its type. Line 13 of Algorithm 1 adds
tag_ xml as a parameter. This is the correct parameter, as it
was also used by the GH developer that performed the manual
APIzation ( tag_ xml is renamed to s).Recognize hard-coded initializations ( PATT-const , Lines 15
to 31). Function G ETLOOP CHANGING VARS returns the vari-
ables LP-VARS in the method body that have at least one
assignment inside a loop (Line 15 of Algorithm 1). PATT-
const needs to identify such variables because they will not
be considered as parameters. Line 16 of Algorithm 1 scansthe statements in API.method-body to search for variable
initializations that meet the conditions of
PATT-const . The
scan considers the following three statements types:
1) V ariable declaration and initialization τv =/epsilon1.For
example, String find String ="hello" in Fig. 2 ( τ=String ,v
=find String , and/epsilon1="hello" ). When API ZA TOR encounters
such statements, it maps τtov, and it adds vtoALREADY-
INIT-VARS, which is a set that maintains the variables that are
already initialized. The function I SHARD CODED takes in input
the typeτand the expression /epsilon1and it returns true if/epsilon1is a
hard-coded value, false otherwise.
Ifτis primitive or String , the function returns true if/epsilon1
does not contain identiﬁers (i.e., variable, class, method names),
false otherwise. Identiﬁers characterize data dependencies.
For example, I SHARD CODED (String ,"hello" ) returns true
because "hello" does not contain identiﬁers.
As another example, consider the following code snippet.
String a = "world";
String b = "hello" + a;
ISHARD CODED (String ,"hello" +a) returns false be-
cause/epsilon1="hello" +ais data dependent to the variable a.
Ifτis non-primitive, /epsilon1must always contain at least one
identiﬁer ( null is also an identiﬁer). For example the /epsilon1of
the statement Calendar calendar =Calendar.getInstance(); in
Fig. 1 has Calendar and getInstance as identiﬁers. As such,
for non-primitive types, I SHARD CODED returns true ifτis
a subclass of java.util.Collection and after the statement si
follown> 1statements that add elements to the collection
(e.g., invoke add methods for java.util.List , and put methods
forjava.util.Map ). API ZA TOR makes a similar consideration
for matrices and arrays.
Line 20 Algorithm 1 checks if the variable vmeets both
PATT-const criteria (vis initialized with a hard coded value
and is not a loop variable). If yes, it adds vof typeτto the
parameter list and removes the declaration statement sifrom
the method body. For example, the statement String find Str =
"hello" at Line 2 in Fig. 2 (bottom) meets both requirements,
and thus API ZA TOR makes find Str a method parameter and
removes the statement.
2) V ariable declaration τv.These statements are only decla-
rations without initializations. For such statements, API ZA TOR
saves the type τofvand statement si. API ZA TOR needs this
information if later it encounters the initialization of v.
3) V ariable assignment v=/epsilon1.At Line 26, Algorithm 1
checks if vbelongs to ALREADY-INIT-VARS. If yes, API ZA-
TOR skips the statement because it already encountered the
initialization of v. If not, API ZA TOR has found the initialization
ofv. Then, it updates ALREADY-INIT-VARS and checks if the
PATT-const criteria are met. If yes, it recovers the type of v
547fromTand adds the vto the parameter list. Then, it removes
from the method body both the statement that declares v(S[v])
and the statement that initializes v(si).
Check the last statement ( PATT-latest , and PATT-syso ,
Lines 32 to 43). At Lines 32 to 43, Algorithm 1 analyzes the
last statement ( sn) to decide whether it should be considered
as the return statement.
Ifsnis a variable declaration or an assignment, then sn
matches PATT-latest , and thus API ZA TOR replacessnwith
a statement that returns the expression /epsilon1. API ZA TOR recovers
the type of /epsilon1directly from sn(ifsnis a declaration) or from
T(ifsnis an assignment).
Ifsnis an invocation to System.out.println , thensn
matches PATT-syso . Algorithm 1 extracts the argument /epsilon1
of the invocation by removing the ﬁrst string-literal (if
it exists), which is likely to represent a placeholder (e.g.,
System.out.println("result :"+s)). Given /epsilon1, Algorithm 1
recovers τ, the type of /epsilon1, which will be the return type of
API. Although System.out.println handles String objects, τ
is not necessarily String . In fact, System.out.println(object)
invokes that object’s toString() method to convert the object to
aString representation. For example, given the last statement
System.out.println(count) in Fig. 2 (bottom), the return type
should be int and not String . The function G ETTYPE OFEXP
analyses /epsilon1and classpath to recover τ.I f/epsilon1is a variable v,
the function recovers τfrom the map T[v].I f/epsilon1is a method
invocation m, the function consults the declaration of min
classpath to get its return type.
V. E V ALUA TION
This section discusses a series of experiments that we
conducted to evaluate API ZA TOR . In the context of our study,
we formulated the following three research questions:
RQ1 Does API ZA TOR generate APIs that are identical to
the ones that a human would produce?
RQ2 How effective the API ZA TOR algorithm is in identifying
the method parameters?
RQ3 How effective the API ZA TOR algorithm is in identifying
the return statements?
To answer these research questions, we collected a ground
truth of human-produced APIs. We decided not to rely on the
GitHub (GH) dataset used in Section III to avoid overﬁtting
(API ZA TOR is based on the insights extracted from the GH
dataset). Instead, we asked 20human participants to build
a ground-truth of 200 APIs by manually performing the
APIzation of 200 SO code snippets. All the evaluation data
is available in our replication package [ 12] and published at
https://apization.netlify.app/evaluation/.
A. Evaluation Setup
1) Creating a Collection of APIs from StackOverﬂow: We
considered the SO data dump of May 2019 [ 29], which contains
1,014,980 SO pages with the tag J AVA . From these SO pages,
we selected all the 1,730,251 SO answer posts with at least
one code snippet.Identifying the compilable SO code snippets. We ﬁrst ran
CS NIPP EXon each of the 1,730,251 SO answer posts, to
identify those code snippets for which CS NIPP EXis able to
recover the missing type declarations. CS NIPP EXrequires a set
of common J AVA libraries JARs as an input [ 5]. We obtained
such a set by downloading the latest JAR of the top three
libraries of each category in the M A VEN REPOSITORY [30].
We then used the dependency resolver of M A VEN to identify
the additional JARs that belong to the runtime dependencies
of the selected libraries. In total, we obtained 748 JAR ﬁles.
Running CS NIPP EXwith a time-budget of 5seconds for each
post, it returned compilable J AVA ﬁles for 141,064 SO posts.
Creating the SO APIs. We ran API ZA TOR on these 141,064
SO answer posts with a time budget of 10 seconds each,
obtaining 109,930 APIs. API ZA TOR skipped 31,134 out of
the141,064 posts because the APIzation is either impossible
or ambiguous. It is impossible for abstract methods and for
JAVA ﬁles with only ﬁeld or class declarations. It is ambiguous
for ﬁles that have more than one public method or that declare
more than one class. In such cases, API ZA TOR cannot infer
which public method is the intended API.
It is worth noting that, for each of the produced APIs,
API ZA TOR generates a J AVA DOC containing the link to the
original SO post from which the code was taken (see Fig. 1).
This is compliant with the SO Terms of Service, which,
at present, states that user contributions are licensed under
Creative Commons Attribution-ShareAlike1. The speciﬁc license
terms depend on the date of publication of the SO post, butall of them require appropriate credit to the authors of thecontent, i.e., a link to the SO post. In fact, the CC BY-SA
license allows re-distribution and re-use of a licensed work
(even for commercial use) on the condition that the creator
is appropriately credited. However, it is the responsibility of
the end user to keep the link of the SO post associated with
the API ZA TOR -generated APIs. Similarly, manually copying
and adapting a SO snippet should require appropriate credit
by including a link to the SO post [18].
2) Selecting the APIs for the Evaluation: From the 109,930
APIs we selected those that satisfy ﬁve properties:
I.The SO page of the API is a “how to” question. Following
previous SO studies, we assume that the most useful code
snippets are in answers to “how to” questions [ 31], [10]. We
identiﬁed such questions by the presence of the word “how”
in the SO page title [31].
II.The SO post associated with the API is the accepted answer
or has a score of at least two (two is the average score in SO).
This is to select high-quality code snippets.
III. The SO post associated with the API contains exactly
one code snippet. This is to avoid ambiguity, as multiple codesnippets in the same SO post often refer to alternative solutions
of the same programming task. Having only one code snippet,
the human participant does not need to decide which one to
consider.
1https://stackoverﬂow.com/legal/terms-of-service/public#licensing
548T ABLE I
RQ2 ANAL YSIS AND COMPARISON OF THE HUMAN -(PH)AND API ZA TOR -PRODUCED (PA)P ARAMETER LISTS
Param.
|PH|Human
APIsPH≡PA |PH\PA|| PH∩PA|| PA\PH| Jaccard Distance (JD)
Count % Mean Min Mdn Max Mean Min Mdn Max Mean Min Mdn Max Mean Min Mdn Max
0 58 45 77.59 – – – – – – – – 0.36 0.00 0.00 5.00 0.22 0.00 0.00 1.00
19 3 6 0 6 4 .52 0.32 0.00 0.00 1.00 0.68 0.00 1.00 1.00 0.13 0.00 0.00 2.00 0.34 0.00 0.00 1.00
2 35 7 20.00 1.14 0.00 1.00 2.00 0.86 0.00 1.00 2.00 0.29 0.00 0.00 2.00 0.58 0.00 0.50 1.00
≥31 4 1 7 .14 2.86 0.00 3.00 6.00 0.64 0.00 0.00 4.00 0.21 0.00 0.00 1.00 0.82 0.00 1.00 1.00
Total (≥ 0) 200 113 56.50 0.77 0.00 0.50 6.00 0.72 0.00 1.00 4.00 0.23 0.00 0.00 5.00 0.38 0.00 0.00 1.00
IV . The import declarations of the API do not refer to any
external libraries other than the JDK. Participants might produce
incorrect APIzations, for instance, if they are unfamiliar with
a particular library.
V.The SO code snippet associated with the API does not
contain a well-formed method declaration. In such cases, the
code snippet is already an API, and Algorithm 1 has no effect.
A total of 9,901 APIs satisfy all of these properties. We
sorted them by the view count of the corresponding SO post
and selected the ﬁrst 200 APIs. It is worth noting that we
had to manually discard some of the APIs in which the
APIzation is not a reasonable operation (even though the above-
mentioned properties were satisﬁed). For example, when the
SO code snippet is not a programming task (e.g., it shows usage
examples of JDK classes), or it is semantically incomplete (e.g.,
it contains placeholders for missing functionality). The 200
APIs have 11.45lines of code on average. The corresponding
SO posts have an average number of views of ≈66,000 , and
an average score of 46.62.
3) Ground-Truth of Human APIzations: We partitioned the 200
code snippets in 200 disjoint sets and sent them to 20expert
JAVA developers in the authors’ circle of acquaintances. Each
participant had assigned ten SO posts. The 20participants come
from seven different countries and constitute a heterogeneous
group of ten Ph.D. students majoring in software engineering,
ﬁve senior software engineering researchers, and ﬁve profes-
sional J AVA developers. The participants have several years of
experience in J AVA programming: 9.8years on average (min
1, median 9.5, and max 15). None of the 20participants knew
that API ZA TOR exists and how it generates APIs. Thus, they
performed the manual APIzation without biases.
Experiment description. Each participant received a script that
interacts via the command line. The script gives the instructions
and monitors the APIzation time. It was an uncontrolledexperiment, thus they ran the script at their convenient time.
We decided to avoid guidelines to let the participants decide
what APIzation means to them. Instead, the script exempliﬁes
the concept with an example. After showing the example, the
script shows the SO page of the ﬁrst assigned code snippet. Itthen asks the participant to read the SO page to understand thesemantics of the code snippet, and to write in the IDE a method
declaration for it. This process repeats until the participant
completes the ten assigned code snippets. This led to 200 pairs
/angbracketleftAPI H,API A/angbracketrightof human- (API H) and API ZA TOR -produced
(API A) APIs from the same SO code snippet. We releaseFig. 3. Distribution of the number of AST differences.
the instructions of the script in our replication package [ 12]
and published at https://apization.netlify.app/evaluation/script/.
Pre-processing the human APIs. Before comparing the
pairs, we inspected the 200 human-produced APIs to ﬁx
any compilation errors and to check whether the participants
renamed any parameters. We corrected one compilation error,
and we renamed the parameters of 27human APIs to match the
ones automatically generated by API ZA TOR . We also removed,
from 15human-produced APIs, variable declarations for return
statements that API ZA TOR avoids by construction. For example,
int a=b+c;return a;becomes return b+c;.
B. RQ1: Identical APIs
To check for identical APIs, we compared each pair
/angbracketleftAPI H,API A/angbracketrightwith the state-of-the-art source code differencing
tool GUMTREE [ 32]. When comparing the pairs, we excluded
differences in method names. GUMTREE implements an
Abstract Syntax Tree (AST) differencing algorithm that takes
into account ﬁne-grained AST differences while ignoring
irrelevant differences in the source code, i.e., new lines, white
spaces, and comments.
Fig. 3 shows the distribution of the number of AST
differences of the 200 pairs, which ranges from 0to99
(average 9.85and median 7). Interestingly, 63(31.50 % ) APIs
generated by API ZA TOR are identical to the human-produced
ones (/angbracketleftAPI H,API A/angbracketrighthas zero AST differences). The pair in
Fig. 1 is one of such identical APIzations in our experiments.
Achieving identical APIzations is an unrealistic expectation,
as in some cases, the participants modiﬁed the method body
of the API by removing System.out.println statements or
unnecessary variables. RQ2 and RQ3 give more insights aboutthe dissimilar pairs by studying the API
ZA TOR effectiveness in
extracting the parameters and return statements while ignoring
superﬁcial differences in the method bodies.
RQ1 – In summary: API ZA TOR generated 63(31.50 % )
APIs identical (including the method-body and import
declarations) to the human-produced ones.
549C. RQ2: Method Parameters
To answer RQ2, we extracted and compared the parameter
lists of the 200 pairs. Given a pair /angbracketleftAPI H,API A/angbracketright,w eu s eP Hand
PAto denote the parameter lists of API Hand API A, respectively.
Note that the order of elements in the parameter list is irrelevant,
thus we considered PHand PAas unordered sets. For example,
for the API pair of Fig. 1, PH=PA={int week,int year}.
Table I breaks down the human-produced APIs (API H) by the
number of parameters (the cardinality of PH). The participants
produced 58APIs without parameters, and 142 APIs with one
or more parameters (Column “Human APIs ” of Table I). The
rest of Table I compares PHwith the corresponding PA.
Column “ PH≡PA” of Table I indicates the number and
percentage of APIs pairs with equivalent PHand PA.PHand
PAare equivalent if they are both empty, or contain identical
parameters. Two parameters ph∈PHandpa∈PAare identical
if and only if they (i) have the same type; (ii) have the same
identiﬁer, i.e., variable name; (iii) refer to the same variablein the method body. For example, in the pair of Fig. 1, the
parameters int week PHand int week inPAare identical. They
have the same type and identiﬁer, and the two bodies refer
to them in the same way. API ZA TOR generates 113 (56.50 % )
APIs with equivalent parameter lists to the human-produced
ones ( PH≡PA). When the human-produced APIs have two
or more parameters, the number of equivalent pairs decreases.
This is an expected result. Intuitively, the more parameters
the manually-crafted ground truth API has, the harder it isfor API
ZA TOR to extract an identical parameters list. It is
worth mentioning that, in principle, there is no difference if an
API has one or more parameters. This is because Algorithm 1
considers each variable in the code snippet individually. Inpractice, we observed that the majority of human-produced
APIzations have at most one parameter. We observed this
situation both in the 135 APIs used for extracting the patterns
and the 200 APIs used to evaluate API ZA TOR (Table I). In
fact, the average number of parameters of the 135 APIs is 0.33.
The reason for that could be that code snippets often target
atomic operations that require one input only.
Column “ |PH\PA|” of Table I shows descriptive statistics
(mean, min, median, and max) of the number of missing
parameters for each API pair (when |PH|≥1 ). Intuitively,
|PH\PA|indicates the number of parameters in PHmissing
from the corresponding PA. The value ranges from 0to6with
an average of 0.77 and a median of 0.50. Among the 142
APIs with |PH|≥1,68of them ( 47.88 % ) have zero missing
parameters (| PH\PA|=0 ).
Column “ |PH∩PA|” of Table I indicates the number of
parameters in common between each API pair (when |PH|≥1).
The value ranges from 0to4with an average of 0.72 and
a median of 1.00. Among the 142 APIs with |PH|≥1,91
of them ( 64.08 % ) have at least one parameter in common
(|PH∩PA|≥1). This indicates that API ZA TOR often identiﬁes
the same parameters that a human would identify.
Column “ |PA\PH|” of Table I shows the number of spurious
parameters for each API pair (those extracted by API ZA TOR ,T ABLE II
RQ3 RETURN ST A TEMENTS COMP ARISON
Return TypeEquivalent Return Type
and Statements
API H API A Count % Count %
void void 63 31.50 63 100.00
void notvoid 2 1.00 – –
notvoid void 72 36.00 ––
notvoid notvoid 63 31.50 52 82.54
Total 200 115
but not by the human participants). The value ranges from 0
to5with an average of 0.23and a median of 0.00. Among
the200 APIs, 166 of them ( 83.00 % ) do not have spurious
parameters ( |PA\PH|=0 ). This demonstrates that API ZA TOR
seldom extracts parameters that a human would not extract.
Column “Jaccard Distance (JD)” of Table I reports the
Jaccard Distance [33] between PHand PA, and it is deﬁned
asJD (P H,PA)=|PH∩PA|
|PH∪PA|from 0to1. The lower the value
is, the more similar the two sets are. If PHand PAare both
empty, JD (P H,PA)returns 0.0. The values range from 0.00
to1.00with an average of 0.38and a median of 0.00. These
results conﬁrm that in most cases, humans and API ZA TOR
extracted identical parameter lists. Notably, for nine parameters
API ZA TOR and the humans extracted the same variables
but inferred compatible albeit different types. For example,
java.util.Collection and java.util.List ,double and int.I n
such cases we consider the parameters to be different.
RQ2 – In summary: API ZA TOR generated 113 (56.50 % )
APIs with identical parameter lists to the human-produced
ones.
D. RQ3: Return Statements
Table II breaks down the 200 APIs pairs by return types
(void and not void ). Column “Equivalent Return Type and
Statements” counts the number and percentage of APIs with
equivalent return statements. A pair of APIs /angbracketleftAPI H,API A/angbracketrighthas
equivalent return statements if (i) both APIs have void as return
type; or (ii) both APIs return the same type and have identicalreturn statements in the method body.
115 (57.50 % )o ft h e 200
APIs pairs have equivalent return statements. This indicates
that API ZA TOR can effectively identify the return type and
statements that a human would identify.
When both the human and API ZA TOR added a return
statement (row not void , not void in Table II), 82.54 % of
times they used the same type and return statements. This
indicates that the conservative nature of our algorithm leads to
few spurious return statements.
RQ3 – In summary: API ZA TOR generated 115 (57.50 % )
APIs with identical return statements to the human-
produced ones.
550E. Discussion
Our experimental results are both promising and encouraging.
Indeed, for 163 (81.50 % ) APIs generated by API ZA TOR , either
the return statements or method parameters were the same as
those produced by the developers. Note that a SO code snippet
could have more than one plausible API. Some of the APIs
obtained by API ZA TOR could be plausible albeit different from
the manually-produced ones. Thus, our experimental setup only
under-approximates the effectiveness of API ZA TOR .
Comparing APIzation efforts. The average APIzation time
for the participants ranges from 17 s to15 min and58 s , with
an average of 4m i n and22 s , and a median of 3m i n and22 s .
Note that the participants performed the task ofﬂine without
our supervision. As such, we cannot tell if a participant was
distracted during the experiment. However, these values give
an idea of the order of magnitude of the manual effort required.
Regarding the 200 code snippets of this experiment, the average
execution time of Algorithm 1 was ≈8s for each code snippet.
This shows the potential usefulness of API ZA TOR in reducing
software development costs. Considering that developers re-use
code from SO several times in one day [ 2], API ZA TOR could
help speed up the software development process.
False negatives due to literals as parameters. We investigated
why some pairs of APIs were different, identifying one main
reason ( 39 cases): literals-as-parameters ,when strings and
number literals in the arguments of method calls become
parameters.
For example, consider the APIzation in https://apization.
netlify.app/evaluation/comparison/8192887/. Both the hu-man and API
ZA TOR extracted list as parameter, but
the human also extracted the String literal bea from
string.matches("(?i)(bea). *").
API ZA TOR adopts a conservative approach that tolerates
missing parameters but minimizes spurious ones, as the results
of RQ2 demonstrate. We could have designed API ZA TOR to
extract all strings and number literals in the method body.
Although this would yield fewer false negatives, it would
also lead to more spurious parameters since not all string and
number literals should become parameters.
We believe that it is better to have false negatives rather than
false positives when extracting parameters. This is because
extracting literals from the method body “removes” information,
which has to be recovered from the SO code snippet. For
example, consider the code snippet in Fig. 2 (top). API ZA TOR
does not extract the string-literal MD5 as a parameter. Indeed,
any random string yields incorrect code. If MD5 was extracted,
the user would need to recover the missing value MD5 from
the SO code snippet. Correctly recognizing and handling the
literal-as-parameter issue is an important future work as it will
drastically reduce the false negatives of API ZA TOR .
Maintainability of the APIs. Currently, API ZA TOR returns
a dedicated class for each generated APIs. The end users are
free to import the class as it is or copy and paste the method
and import declarations inside their codebases. Indeed, having
many one-method classes results in less cohesive softwareand ultimately negatively impacts the system’s quality. Anessential future work would be to propose a technique to
group semantically related API ZA TOR -generated APIs into the
same J AVA class. For instance, one could group APIs that
import the same classes and take as input the same type of
parameters (e.g., strings, lists, arrays). This will lead to a library
of API ZA TOR -generated APIs more similar to a manually-
written API, facilitating the search, use, and maintainability of
APIs automatically extracted from SO.
F . Threats to V alidity
Threats to internal validity. A possible threat to internal
validity is the choice of the 200 code snippets for the evaluation.
They might not be a representative sample of code snippets.
We tried to mitigate such a risk by selecting a reasonably
large number of snippets for an evaluation involving human
participants. Furthermore, by selecting popular code snippets,
i.e., based on the views count, we ensured that we selected arelevant sample.
Threats to external validity. A possible threat to external
validity is that the four patterns are speciﬁc to J AVA , and
might not generalize well for other programming languages.
For instance, in the case of dynamically-typed languages like
PYTHON , the APIzation is easier for some aspects but harder
for others. On the one hand, it is difﬁcult to identify possible
parameters and return statements by relying on the types ofliterals. On the other hand, the ﬂexibility of dynamic typesallows extracting parameters easier than a statically-typed
language like J AVA . Repeating our study for dynamically-typed
languages is an important future work.
Another threat to the external validity is that currently
API ZA TOR only handles two types of compilation errors:
missing type declarations and missing variable declarations.
API ZA TOR cannot produce APIs for those code snippets that
have other types of compilation errors. However, these two
types are among the most common compilation errors in SO
code snippets [ 5]. API ZA TOR relies on previous techniques
(CS NIPP EX[5] and B AKER [28]) to ﬁx compilation errors.
In the future, API ZA TOR could rely on other techniques to
handle additional types of compilation error. For instance,a common compilation error in SO code snippets is
com-
piler.err.expected [5], which means the code does not comply
with the syntax rules of the J AVA language. Examples of such
rules are: “a semicolon should be at the end of every statement,or there should be a matching sequence of opening and closing
brackets.” API ZA TOR could rely on a parser that recognizes
and ﬁxes such errors.
Threats to construct validity. A possible threat to construct
validity relates to the metrics that we used to evaluate
API ZA TOR . We measured the effectiveness of API ZA TOR by
counting how many times API ZA TOR and the humans made
the same APIzation choices. However, a SO code snippetcould have more than one plausible API. Additional human
evaluators could help recognize when API ZA TOR generated a
plausible API, albeit different from the human-produced one.
551Nevertheless, we preferred to rely on a objective method, even
if it might have resulted in a disadvantage for API ZA TOR ,b u t
is not biased by a subjective evaluation.
VI. R ELA TED WORK
StackOverﬂow (SO) provides an important source of crowd-
generated data that inspired and powered many techniquesand tools. In a recent systematic mapping study, Meldrumet al. identiﬁed
266 research papers that rely on SO data to
accomplish various software engineering taks [ 4]. It includes
topics like program repair [ 34], mobile development issues [ 35],
[36], [37], [38], APIs misuses and issues [ 19], [39], [40], [41],
and technology landscape discovery [ 42], [43]. In this paper,
we propose API ZA TOR to facilitate the reuse and analysis of
SO code snippets by transforming them into compilable and
reusable APIs. To the best of our knowledge, it is the ﬁrstattempt to accomplish this. In the following, we discuss the
most related work in code snippet analysis, search, and reuse.
Code snippet analysis. Recently, Terragni et al. proposed
CS NIPP EXto resolve compilation errors of SO code snip-
pets [ 5]. API ZA TOR leverages this tool to resolve type declara-
tion errors. Subramanian and Holmes studied the compilability
of SO code snippets [ 6]. However, in the case of missing
method declarations, these approaches simply wrap the code
snippets in a synthetic method. Differently from API ZA TOR ,
they do not aim at identifying the method parameters and return
statements of code snippets.
Researchers have proposed to mine intent-snippet pairs for
code summarization or search [ 44], [45], [46], [7], [47], [24].
The intent of the snippet is often characterized by the SO
question title [ 24]. These techniques analyze the code snippets
to identify which lines of code are related to the SO title whileﬁltering out all the implementation details. API
ZA TOR has the
opposite goal of generating the missing implementation detailsto make the code snippet easy to invoke. All of these techniques
aim at identifying the lines of code associated with the intent
and do not aim to generate a proper method declaration for
the extracted lines of code. API ZA TOR could work in synergy
with these techniques by creating an API for the code extracted
by these techniques.
Code snippet search. There is also a large body of work on
improving code search in on-line resources (such as SO) [ 27],
[48], [49]. A popular approach to facilitate search of SO code
is to reduce the context switching from IDE S(e.g., I NTELLI J
IDEA and E CLIPSE ) to web browsers by incorporating SO
code search into IDE S.P ROMPTER [50] and S EAHAWK [51]
recommend SO posts into the IDE based on source codecontext found in the IDE. T2API [
52], NLP2C ODE [53],
and RACK [ 54] recommend code snippets extracted from SO
based on natural language text describing the programming task.
RACK leverages crowd-source knowledge taken from both SO
and G ITHUB.S TAC K INTHEFLOW [55] improves the previous
approaches by monitoring the behavior of the developers topersonalize the retrieved posts. All of these techniques aimto improve the code search or reduce the context switchingfrom IDE Sto browsers. Differently from API ZA TOR , they do
not help developers to integrate the SO code snippet into their
code base. API ZA TOR complements such approaches, as it
could extract, compile and create APIs for the code snippets
that are retrieved by these techniques.
Code snippet reuse. Zhang et al. [ 19] proposed E XAM -
PLE STACK ,aG OOGLE CHROME extension that highlights
in a SO page the statements that were changed when a GHdeveloper previously reused the same code snippet. Suchhighlights help developers to adapt the code snippet in their
code bases. To know which statements should be highlighted,
EXAMPLE STAC K queries an archive of SO code reuses in GH
projects. Zhang et al. built such an archive by analyzing 200
code reuses across SO code snippets and GH projects. Simi-
larly to API ZA TOR ,E XAMPLE STAC K aims at facilitating the
adaptation of code snippets, but with completely different goals.
First, E XAMPLE STACK suggests general code changes [ 19].
Differently from API ZA TOR , it does not automatically extract
method parameters and return statements, and it does notaim to generate compilable APIs. Second, E
XAMPLE STACK
can suggest changes for only those code snippets present inthe precomputed archive. Conversely, API
ZA TOR does not
require any prior knowledge on the code snippet under analysis.
Third, the input of E XAMPLE STACK and API ZA TOR differs
substantially. E XAMPLE STAC K analyzes parsable code snippets
with a well-deﬁned method declaration [ 19], or by wrapping the
snippets with synthetic method headers [ 6]. Instead, API ZA TOR
analyzes incomplete code snippets.
VII. C ONCLUSION AND FUTURE WORK
Online developers forums like StackOverﬂow (SO) have
drastically changed how developers write code [ 13], [56], [57],
[1], [2], [3]. Developers constantly visit SO for ﬁnding solutions
to programming tasks. The SO revolution has been recognizedby the software engineering community and several techniques
have been proposed to facilitate the reuse and analysis of SO
code snippets [27], [48], [49].
In this paper, we presented API ZA TOR , an approach that
transforms SO code snippets into compilable and reusable APIs.
To the best of our knowledge, this is new to SO code snippet
analysis. Our empirical results demonstrate the usefulness of
API ZA TOR in reducing the developers’ effort and enabling the
creation of a large dataset of APIs from SO.
There are several possible future works, and we highlight
the three most promising ones. First, address the literal-as-
parameter issue by employing machine learning to recognize
which literal should become a parameter. Second, investigate
state-of-the-art approaches [ 58], [59], [60], [26] to generate
semantically meaningful method names. In particular, in our
case, one could generate method names by relying on both thenatural language free text in the SO posts (e.g., the discussionsand comments) and the code snippet itself. Third, explore text
summarization and code comment generation approaches [ 61],
[46], [62], [63] to generate the J AVA DOC.
552REFERENCES
[1] J. Brandt, M. Dontcheva, M. Weskamp, and S. R. Klemmer, “Example-
Centric Programming: Integrating Web Search into the Development
Environment,” in SIGCHI Conference on Human Factors in Computing
Systems (CHI), 2010, pp. 513–522.
[2] M.-A. Storey, L. Singer, B. Cleary, F. Figueira Filho, and A. Zagalsky,
“The (R)Evolution of Social Media in Software Engineering,” in Future
of Software Engineering (F oSE), 2014.
[3] K. Mao, L. Capra, M. Harman, and Y . Jia, “A Survey of the Use
of Crowdsourcing in Software Engineering,” Journal of Systems and
Software (JSS), vol. 126, pp. 57–84, 2017.
[4] S. Meldrum, S. A. Licorish, and B. T. R. Savarimuthu, “Crowdsourced
Knowledge on Stack Overﬂow: A Systematic Mapping Study,” in
International Conference on Evaluation and Assessment in Software
Engineering (EASE), 2017, pp. 180–185.
[5] V . Terragni, Y . Liu, and S.-C. Cheung, “CSNIPPEX: Automated Synthesis
of Compilable Code Snippets from Q&A Sites,” in ACM SIGSOFT
International Symposium on Software Testing and Analysis (ISSTA),
2016, pp. 118–129.
[6] S. Subramanian and R. Holmes, “Making Sense of Online Code Snippets,”
inIEEE Working Conference on Mining Software Repositories (MSR) ,
2013, pp. 85–88.
[7] D. Y ang, A. Hussain, and C. V . Lopes, “From Query to Usable Code: An
Analysis of Stack Overﬂow Code Snippets,” in IEEE Working Conference
on Mining Software Repositories (MSR), 2016, pp. 391–402.
[8] S. M. Nasehi, J. Sillito, F. Maurer, and C. Burns, “What Makes a Good
Code Example?: A Study of Programming Q&A in StackOverﬂow,” in
IEEE International Conference on Software Maintenance (ICSM), 2012,
pp. 25–34.
[9] H. Phan, H. A. Nguyen, N. M. Tran, L. H. Truong, A. T. Nguyen, and
T. N. Nguyen, “Statistical Learning of API Fully Qualiﬁed Names in Code
Snippets of Online Forums,” in IEEE/ACM International Conference on
Software Engineering (ICSE), 2018, pp. 632–642.
[10] C. Treude and M. P . Robillard, “Understanding Stack Overﬂow Code
Fragments,” in IEEE International Conference on Software Maintenance
and Evolution (ICSME), 2017, pp. 509–513.
[11] R. Holmes and R. J. Walker, “Systematizing Pragmatic Software Reuse,”
ACM Transactions on Software Engineering and Methodology (TOSEM),
2012.
[12] V . Terragni and P . Salza. (2021) APIzation: Generating Reusable APIs
from StackOverﬂow Code Snippets - Replication Package. [Online].
Available: https://doi.org/10.5281/zenodo.5236305
[13] B. V asilescu, A. Serebrenik, P . T. Devanbu, and V . Filkov, “How Social
Q&A Sites Are Changing Knowledge Sharing in Open Source Software
Communities,” in ACM Conference on Computer Supported Cooperative
Work & Social Computing (CSCW), 2014, pp. 342–354.
[14] L. Ponzanelli, A. Mocci, A. Bacchelli, M. Lanza, and D. Fullerton,
“Improving Low Quality Stack Overﬂow Post Detection,” in IEEE
International Conference on Software Maintenance and Evolution
(ICSME), 2014, pp. 541–544.
[15] M. Gharehyazie, B. Ray, and V . Filkov, “Some from Here, Somefrom There: Cross-Project Code Reuse in GitHub,” in IEEE Working
Conference on Mining Software Repositories (MSR), 2017, pp. 291–301.
[16] B. V asilescu, V . Filkov, and A. Serebrenik, “Stackoverﬂow and GitHub:
Associations Between Software Development and Crowdsourced Knowl-
edge,” in International Conference on Social Computing (SocialCom),
2013, pp. 188–195.
[17] A. S. Badashian, A. Esteki, A. Gholipour, A. Hindle, and E. Stroulia,
“Involvement, Contribution and Inﬂuence in GitHub and Stack Overﬂow,”
inConference of the Center for Advanced Studies on Collaborative
Research (CASCON), 2014, pp. 19–33.
[18] S. Baltes, R. Kiefer, and S. Diehl, “Attribution Required: Stack Over-ﬂow Code Snippets in GitHub Projects,” in IEEE/ACM International
Conference on Software Engineering (ICSE), 2017, pp. 161–163.
[19] T. Zhang, G. Upadhyaya, A. Reinhardt, H. Rajan, and M. Kim, “AreCode Examples on an Online Q&A Forum Reliable? A Study of API
Misuse on Stack Overﬂow,” in IEEE/ACM International Conference on
Software Engineering (ICSE), 2018, pp. 886–896.
[20] S. Baltes and S. Diehl, “Usage and Attribution of Stack Overﬂow Code
Snippets in GitHub Projects,” Empirical Software Engineering (EMSE),
vol. 24, no. 3, pp. 1259–1295, 2019.
[21] Google. (2020) Google BigQuery. [Online]. Available: https://cloud.
google.com/bigquery[22] T. Kamiya, S. Kusumoto, and K. Inoue, “CCFinder: A Multilinguistic
Token-Based Code Clone Detection System for Large Scale Source Code,”
IEEE Transactions on Software Engineering (TSE), vol. 28, no. 7, pp.
654–670, 2002.
[23] J. M. Corbin and A. Strauss, “Grounded Theory Research: Procedures,
Canons, and Evaluative Criteria,” Qualitative Sociology, vol. 13, no. 1,
pp. 3–21, 1990.
[24] P . Yin, B. Deng, E. Chen, B. V asilescu, and G. Neubig, “Learning to
Mine Aligned Code and Natural Language Pairs from Stack Overﬂow,”
inIEEE Working Conference on Mining Software Repositories (MSR) ,
2018, pp. 476–486.
[25] Explosion. (2020) spaCy. [Online]. Available: https://spacy.io
[26] S. Gao, C. Chen, Z. Xing, Y . Ma, W. Song, and S.-W. Lin, “A Neural
Model for Method Name Generation from Functional Description,” in
IEEE International Conference on Software Analysis, Evolution and
Reengineering (SANER). IEEE, Feb. 2019, pp. 414–421.
[27] A. Mishne, S. Shoham, and E. Y ahav, “Typestate-Based Semantic Code
Search Over Partial Programs,” in ACM International Conference on
Object Oriented Programming Systems Languages and Applications
(OOPSLA), 2012, pp. 997–1016.
[28] S. Subramanian, L. Inozemtseva, and R. Holmes, “Live API Documenta-
tion,” in IEEE/ACM International Conference on Software Engineering
(ICSE), 2014, pp. 643–652.
[29] T. I. Archive. (2019) StackOverﬂow 2019 Dump. [Online]. Available:
https://archive.org/details/stackexchange
[30] F. Rodriguez. (2020) Maven Repository. [Online]. Available: https:
//mvnrepository.com
[31] C. Treude, O. Barzilay, and M.-A. Storey, “How Do Programmers Ask
and Answer Questions on the Web?” in International Conference on
Software Engineering, New Ideas and Emerging Results (ICSE-NIER),
2011, pp. 804–807.
[32] J.-R. Falleri, F. Morandat, X. Blanc, M. Martinez, and M. Monperrus,
“Fine-Grained and Accurate Source Code Differencing,” in IEEE/ACM
International Conference on Automated Software Engineering (ASE) ,
2014, pp. 313–324.
[33] H. Small, “Co-Citation in the Scientiﬁc Literature: A New Measure of
the Relationship Between Two Documents,” Journal of the American
Society for information Science, vol. 24, no. 4, pp. 264–269, 1973.
[34] X. Liu and H. Zhong, “Mining StackOverﬂow for Program Repair,” in
IEEE International Conference on Software Analysis, Evolution and
Reengineering (SANER), 2018, pp. 118–129.
[35] M. L. Vásquez, B. Dit, and D. Poshyvanyk, “An Exploratory Analysis
of Mobile Development Issues Using Stack Overﬂow,” in IEEE Working
Conference on Mining Software Repositories (MSR), 2013, pp. 93–96.
[36] C. Rosen and E. Shihab, “What Are Mobile Developers Asking About?
A Large Scale Study Using Stack Overﬂow,” Empirical Software
Engineering (EMSE), vol. 21, no. 3, pp. 1192–1223, 2016.
[37] S. Beyer and M. Pinzger, “A Manual Categorization of Android
App Development Issues on Stack Overﬂow,” in IEEE International
Conference on Software Maintenance and Evolution (ICSME), 2014, pp.
531–535.
[38] D. Kavaler, D. Posnett, C. Gibler, H. Chen, P . T. Devanbu, and V . Filkov,
“Using and Asking: APIs Used in the Android Market and Asked About
in StackOverﬂow,” in International Conference on Social Informatics
(SocInfo), 2013, pp. 405–418.
[39] W. Wang, H. Malik, and M. W. Godfrey, “Recommending Posts
Concerning API Issues in Developer Q&A Sites,” in IEEE Working
Conference on Mining Software Repositories (MSR) , 2015, pp. 224–234.
[40] M. Ahasanuzzaman, M. Asaduzzaman, C. K. Roy, and K. A. Schneider,
“Classifying Stack Overﬂow Posts on API Issues,” in IEEE International
Conference on Software Analysis, Evolution and Reengineering (SANER),
2018, pp. 244–254.
[41] M. L. Vásquez, G. Bavota, M. D. Penta, R. Oliveto, and D. Poshyvanyk,
“How Do API Changes Trigger Stack Overﬂow Discussions? A Study on
the Android SDK,” in IEEE/ACM International Conference on Program
Comprehension (ICPC), 2014, pp. 83–94.
[42] C. Chen, Z. Xing, and L. Han, “TechLand: Assisting Technology Land-
scape Inquiries with Insights from Stack Overﬂow,” in IEEE International
Conference on Software Maintenance and Evolution (ICSME), 2016, pp.
356–366.
[43] C. Chen and Z. Xing, “Mining Technology Landscape from Stack
Overﬂow,” in ACM/IEEE International Symposium on Empirical Software
Engineering and Measurement (ESEM), 2016, pp. 14:1–14:10.
553[44] Z. Y ao, D. S. Weld, W .-P . Chen, and H. Sun, “StaQC: A Systematically
Mined Question-Code Dataset from Stack Overﬂow,” in World Wide Web
Conference (WWW), 2018, pp. 1693–1703.
[45] S. Iyer, I. Konstas, A. Cheung, and L. Zettlemoyer, “Summarizing
Source Code Using a Neural Attention Model,” in Annual Meeting
of the Association for Computational Linguistics, 2016, pp. 2073–2083.
[46] E. Wong, J. Y ang, and L. Tan, “AutoComment: Mining Question and
Answer Sites for Automatic Comment Generation,” in IEEE/ACM
International Conference on Automated Software Engineering (ASE),
2013, pp. 562–567.
[47] A. Zagalsky, O. Barzilay, and A. Y ehudai, “Example Overﬂow: Using
Social Media for Code Recommendation,” in International Workshop on
Recommendation Systems for Software Engineering (RSSE) , 2012, pp.
38–42.
[48] C. McMillan, M. Grechanik, D. Poshyvanyk, C. Fu, and Q. Xie,
“Exemplar: A Source Code Search Engine for Finding Highly Relevant
Applications,” IEEE Transactions on Software Engineering (TSE), vol. 38,
no. 5, pp. 1069–1087, 2012.
[49] C. McMillan, D. Poshyvanyk, M. Grechanik, Q. Xie, and C. Fu,
“Portfolio: Searching for Relevant Functions and Their Usages in Millions
of Lines of Code,” ACM Transactions on Software Engineering and
Methodology (TOSEM), vol. 22, no. 4, pp. 37:1–37:30, 2013.
[50] L. Ponzanelli, G. Bavota, M. Di Penta, R. Oliveto, and M. Lanza, “Mining
Stackoverﬂow to Turn the IDE into a Self-Conﬁdent Programming
Prompter,” in IEEE Working Conference on Mining Software Repositories
(MSR), 2014, pp. 102–111.
[51] L. Ponzanelli, A. Bacchelli, and M. Lanza, “Seahawk: Stack Overﬂow
in the IDE,” in IEEE/ACM International Conference on Software
Engineering (ICSE), 2013, pp. 1295–1298.
[52] T. V . Nguyen, P . C. Rigby, A. T. Nguyen, M. Karanﬁl, and T. N. Nguyen,
“T2API: Synthesizing API Code Usage Templates from English Texts with
Statistical Translation,” in ACM Joint European Software Engineering
Conference and Symposium on the F oundations of Software Engineering
(ESEC/FSE), 2016, pp. 1013–1017.
[53] B. A. Campbell and C. Treude, “NLP2Code: Code Snippet ContentAssist Via Natural Language Tasks,” in IEEE International Conference
on Software Maintenance and Evolution (ICSME), 2017, pp. 628–632.
[54] M. M. Rahman, C. K. Roy, and D. Lo, “RACK: Code Search in theIDE Using Crowdsourced Knowledge,” in IEEE/ACM International
Conference on Software Engineering (ICSE), 2017, pp. 51–54.
[55] C. Greco, T. Haden, and K. Damevski, “StackInTheFlow: Behavior-
Driven Recommendation System for Stack Overﬂow Posts,” in IEEE/ACM
International Conference on Software Engineering (ICSE), 2018, pp. 5–8.
[56] R. Abdalkareem, E. Shihab, and J. Rilling, “What Do Developers Use
the Crowd for? A Study Using Stack Overﬂow,” IEEE Software, vol. 34,
no. 2, pp. 53–60, 2017.
[57] D. Y e, Z. Xing, and N. Kapre, “The Structure and Dynamics ofKnowledge Network in Domain-Speciﬁc Q&A Sites: A Case Study
of Stack Overﬂow,” Empirical Software Engineering (EMSE), vol. 22,
no. 1, pp. 375–406, 2017.
[58] S. Nguyen, H. Phan, T. Le, and T. N. Nguyen, “Suggesting Natural
Method Names to Check Name Consistencies,” in IEEE/ACM Interna-
tional Conference on Software Engineering (ICSE), 2020, pp. 1372–1384.
[59] K. Liu, D. Kim, T. F. Bissyandé, T. Kim, K. Kim, A. Koyuncu, S. Kim,
and Y . Le Traon, “Learning to Spot and Refactor Inconsistent Method
Names,” in IEEE/ACM International Conference on Software Engineering
(ICSE), 2019, pp. 1–12.
[60] Z. Gao, X. Xia, J. Grundy, D. Lo, and Y .-F. Li, “Generating Question
Titles for Stack Overﬂow from Mined Code Snippets,” ACM Transactions
on Software Engineering and Methodology (TOSEM), vol. 29, no. 4, pp.
1–37, 2020.
[61] J. Kim, S. Lee, S.-W. Hwang, and S. Kim, “Enriching Documents
with Examples: A Corpus Mining Approach,” ACM Transactions on
Information Systems (TSE), vol. 31, no. 1, pp. 1:1–1:27, Jan. 2013.
[62] C. Treude and M. P . Robillard, “Augmenting API Documentation with
Insights from Stack Overﬂow,” in IEEE/ACM International Conference
on Software Engineering (ICSE), 2016, pp. 392–403.
[63] C. Parnin and C. Treude, “Measuring API Documentation on the Web,” in
International Workshop on Web 2.0 for Software Engineering (Web2SE),
2011.
554