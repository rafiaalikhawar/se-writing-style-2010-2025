Seamless Variability Management
With the Virtual Platform
Wardah Mahmood, Daniel Str√ºbery, Thorsten Bergerz, Ralf L√§mmelx, and Mukelabai Mukelabai
Chalmers | University of Gothenburg, Sweden
yRadboud University, Netherlands
zRuhr University Bochum, Germany
xUniversity of Koblenz-Landau, Germany
Abstract ‚ÄîCustomization is a general trend in software engi-
neering, demanding systems that support variable stakeholder
requirements. Two opposing strategies are commonly used to
create variants: software clone&own and software conÔ¨Åguration
with an integrated platform. Organizations often start with the
former, which is cheap, agile, and supports quick innovation, but
does not scale. The latter scales by establishing an integrated
platform that shares software assets between variants, but re-
quires high up-front investments or risky migration processes. So,
could we have a method that allows an easy transition or even
combine the beneÔ¨Åts of both strategies? We propose a method and
tool that supports a truly incremental development of variant-
rich systems, exploiting a spectrum between both opposing
strategies. We design, formalize, and prototype the variability-
management framework virtual platform . It bridges clone&own
and platform-oriented development. Relying on programming-
language-independent conceptual structures representing soft-
ware assets, it offers operators for engineering and evolving a sys-
tem, comprising: traditional, asset-oriented operators and novel,
feature-oriented operators for incrementally adopting concepts
of an integrated platform. The operators record meta-data that
is exploited by other operators to support the transition. Among
others, they eliminate expensive feature-location effort or the
need to trace clones. Our evaluation simulates the evolution of a
real-world, clone-based system, measuring its costs and beneÔ¨Åts.
Index Terms ‚Äîsoftware product lines, variability management,
clone management, re-engineering, framework
I. I NTRODUCTION
Software systems often need to exist in many different variants.
Organizations create variants to adapt systems to varying
stakeholder requirements‚Äîfor instance, to address a variety of
market segments, runtime environments or different hardware.
Creating variants allows organizations to experiment with new
ideas and to test them on the market, which easily leads to
a portfolio of system variants that needs to be maintained.
Two opposing strategies exist for engineering variants. A
convenient and frequent strategy is clone&own [1], [2], [3],
[4], [5], where developers create one system and then clone
and adapt it to the new requirements. This strategy is well-
supported by current version-control systems and tools, such
as GIT, relying on their forking, branching, merging, and pull
request facilities. The frequent adoption of clone&own [ 6],
[1], [4] is usually attributed to its inexpensiveness, Ô¨Çexibility,
and provided developer independence. However, clone&own
does not scale with the number of variants and then imposes
substantial maintenance overheads. A scalable strategy is tointegrate the cloned variants into a conÔ¨Ågurable and integrated
platform , by adopting platform-oriented engineering methods,
such as software product line engineering (SPLE) [ 7], [8], [9],
[10], [11]. Individual variants are then derived by conÔ¨Åguring
the platform. This strategy is typically advocated for systems
with many variants, such as software product lines (e.g.,
automotive/avionics control systems and industrial automation
systems) or highly conÔ¨Ågurable systems (e.g., the Linux kernel).
This strategy scales, but is often difÔ¨Åcult to adopt and requires
substantial up-front investments, since variability concepts (e.g.,
a feature model [ 12], [13], feature-to-asset traceability [ 14],
[15], a conÔ¨Åguration tool [ 16]) need to be introduced and assets
made reusable or conÔ¨Ågurable. In practice, organizations often
start with clone&own and later face the need to migrate to a
platform in a risky and costly process [ 17], [18], [6], [19], re-
covering meta-data that was never recorded during clone&own,
such as features and their locations in software assets [ 20], [13].
Over the last decades, researchers focused on heuristic
techniques to recover information from legacy codebases,
including feature identiÔ¨Åcation [ 21], [22], [23], feature
location [ 24], [25], [26], variability mining [ 27], [28], and
clone-detection techniques [ 29], [30]. Unfortunately, such
techniques are usually not accurate enough to be applicable in
practice, and also require substantial effort to set them up and
provide with manual input (e.g., speciÔ¨Åc program entry points
for feature location techniques [ 31]).As we will show, existing
platform migration techniques either heavily rely on such
heuristics or have only been formulated as abstract frameworks
so far. Moreover, they tend to prescribe non-iterative,
waterfall-like migrations, making it risky and expensive.
We take a different route and present a method to
continuously record the relevant meta-data already during
clone&own, and to incrementally transition towards a more
scalable platform-oriented strategy, exploiting the meta-data
recorded. We design, formalize, and prototype a lightweight
method called virtual platform , generalizing clone-management
and product-line migration frameworks. We exploit a spectrum
between the two extremes of ad hoc clone&own and fully
integrated platform, supporting both kinds of development.
As such, the virtual platform bridges clone&own and
platform-oriented development (SPLE). Based on the number
of variants, organizations can decide to use only a subset of
all the variability-implementation concepts that are typically
16582021 IEEE/ACM 43rd International Conference on Software Engineering (ICSE)
1558-1225/21/$31.00 ¬©2021 IEEE
DOI 10.1109/ICSE43902.2021.00147
required for an integrated platform. This allows organizations
to be Ô¨Çexible and innovative by starting with clone&own and
then incrementally adopting the variability-implementation
concepts necessary to scale the development, as indicated by
industrial practices for product-line adoption [ 32], [11], [33],
[34].This realizes an incremental adoption of platforms with
incremental beneÔ¨Åts for incremental investment. Furthermore,
it also allows to use clone&own even when a platform is
already established, to support a more agile development with
cloning and quickly prototyping new variants. The framework
is lightweight, since it avoids upfront investments and can be
easily integrated with version-control systems or IDEs, where
its operators can be mapped to existing activities, avoiding
extra effort. This way, our new (feature-oriented) operators
are cheap to invoke during development, when the feature
knowledge is still fresh in the developer‚Äôs mind, allowing to
record meta-data in a lightweight way.
The term ‚Äúvirtual platform‚Äù was introduced earlier in a short
paper [ 35] discussing an incremental migration of clone-based
variants into a platform. It introduced governance levels reÔ¨Çect-
ing a spectrum between the two extremes ad hoc clone&own
and fully integrated platform. Higher levels involve a super-set
of the variability concepts of lower levels. Advancing a
level‚Äîe.g., when the number of variants increases‚Äîsupports
an incremental adoption of variability concepts, avoiding
the costly and risky ‚Äúbig bang‚Äù migration [ 17] often leading
to re-engineering efforts over years [ 18], [36]. This early,
high-level description of a strategy to incrementally scale
the management of variants paved the way for this paper.
One of our core contributions are conceptual structures and
formalized operators for the virtual platform, which are related
to ordinary code editing, but also record and exploit meta-data.
While we prototypically implemented the virtual platform on
top of an ordinary Ô¨Åle system, our work gives rise to realize it
upon a database (to enhance scalability), within an integrated
development environment (IDE), or as a command-line
tool. The meta-data could also easily be saved directly in
the software-assets using lightweight embedded annotations
(as our prototype does). We evaluated our prototype on a
reasonably sized system (57.4k lines of text, 4 variants), where
we simulated evolution activities that are typical of practical
software systems. Our prototype was able to fully simulate and
manage all considered activities. From a cost-beneÔ¨Åt analysis,
we conclude that the virtual platform offers signiÔ¨Åcant cost
savings during inevitable evolution and maintenance activities.
In summary, we contribute:
a mechanization of the so-far abstract idea of operators
mediating between clone&own and an integrated platform,
deÔ¨Åned upon conceptual, language-independent structures,
a prototype of the virtual platform [ 37]in Scala,
a comparative evaluation of the virtual platform
against Ô¨Åve related frameworks, based on their ability
to support common evolution scenarios,
a cost-and-beneÔ¨Åt evaluation of the virtual platform ,
based on a simulation study featuring the revision history
of a real variant-rich open-source system, andan online appendix [ 38]with a technical report about
our operators, additional examples, and evaluation data.
II. M OTIVATION AND OVERVIEW
We provide a core scenario of seamless variability management
as a running example and an overview of the virtual platform.
While rooted in a deliberately simple application domain, the
example is inspired by documented real product-line migration
scenarios [ 19], [39]. It includes tasks that are tedious and error-
prone in practice (e.g., bugÔ¨Åx propagation along branches).
A. Motivating Running Example
We now discuss relevant problems of managing variants
inspired by actual industrial practices, also presenting our
solution in the virtual platform and how a developer would
use the virtual platform. SpeciÔ¨Åcally, developers interact
with the virtual platform by invoking its provided operators,
either via the command-line or an integration with an IDE or
version-control system provided by a tool vendor (see Sec. II-B
for details). While the traditional, asset-oriented operators can
run transparently in the background, only the feature-oriented
operators require an extra user interaction for invoking the
operators. The operator are described in detail in Sec. V.
Consider the scenario of an organization developing and
evolving variants of a calculator tool. Our organization starts
creating a project of a simple calculator called BasicCalculator
(BC) that supports basic arithmetics: addition ,subtraction ,
multiplication , and division . Soon, based on customer requests,
the organization needs to create variants of BC, which have
substantial commonalities, but also differ in functional aspects.
Figure 1illustrates the two opposing strategies (cf. Sec. I)
for realizing the variants. SpeciÔ¨Åcally, it shows two alternate
realizations of a variant of BasicCalculator with a small display,
requiring the rounding of results (feature SmallDisplay ). To
the left, the code is cloned and adapted (one line changed in
the branch BC+SmallDisplay); to the right, a conÔ¨Åguration
option represents the change in a common codebase (integrated
platform). The changes are usually more complex (e.g., features
can be highly scattered [ 40], [41]), as well as the representation
of variability in the integrated platform. We also need more vari-
ability concepts, among others, features [ 42], [43], [44], code-
level conÔ¨Åguration [ 10], feature-to-asset traceability [ 14], [15],
[45], a feature model (a hierarchical structure with features and
their dependencies) [ 12], [13], a conÔ¨Ågurable build system [ 10],
and a conÔ¨Ågurator tool [ 16], [46], [47]. This example shows
that, when it becomes necessary to migrate from clone&own to
an integrated platform, important information needs to be recov-
ered, speciÔ¨Åcally: that a feature SmallDisplay was implemented
and where its code is located. Recovering such information in
systems with many features and sizable codebases is laborious,
time-consuming, and inaccurate at best. Also, migration can
be invasive, risky, and costly, especially hard to achieve under
market pressure [ 48], [18], [36], [20], [17], [49].
The virtual platform exploits a spectrum between the two
extremes and supports an incremental transition as shown in
1659function¬†divide(a,¬†b){
var¬†result¬†=¬†0
result¬†=¬†a/b
return¬†result.toFixed(2)
}function¬†divide(a,b){
var¬†result¬†=¬†0
result¬†=¬†a/b
return¬†result
}function¬†divide(a,b){ ¬†
var¬†result¬†=¬†0
result¬†=¬†a/b
#ifdef¬†SmallDisplay
return¬†result.toFixed(2)
#else
return¬†result;
#endif
}main¬†branch
BC+SmallDisplay branchbasic
advanced
^
ad¬†hoc¬†clone¬†&¬†own fully¬†integrated ¬†platformmain¬†branch
feature
model
SmallDisplayFig. 1. Ad hoc clone&own vs. fully integrated platform illustrated for two
variants: the BasicCalculator and a variant with only a small display
Fig.2. It adapts the governance levels from prior work [ 35],
which also explains the beneÔ¨Åts of each transition step in detail.
Let us further discuss the evolution of our calculator using
ad hoc clone&own . After the BasicCalculator and a variant of
it for small displays (BC+SmallDisplay) is created, customers
request a ScientiÔ¨ÅcCalculator , which should solve complex
inputs, such as expressions ,factorials , and logarithms . Our
organization decides to copy and adapt the codebase from Basic-
Calculator , since there is no need for a ScientiÔ¨ÅcCalculator with
small display support; otherwise we would already have four
cloned variants. As such, cloning provides a baseline minimiz-
ing the duplication of efforts. Soon after, the organization needs
to create another variant called GraphingCalculator , for which
it selects the most similar variant, ScientiÔ¨ÅcCalculator , and
clones and adapts it. It also notices that some functionality in
BasicCalculator had in the meantime received a bug Ô¨Åx, which
the organization also applies to GraphingCalculator , now real-
izing that also ScientiÔ¨ÅcCalculator needs to receive the bug Ô¨Åx.
Problem 1: Where are my clones? With many more variants
developed using ad hoc clone&own, developers lose overview.
If a change (e.g., a bug Ô¨Åx) is to be replicated, developers
need to recover which project was cloned from which, in the
worst case requiring a clone-detection technique. Also, the
added effort in synchronizing cloned implementations is likely
to surpass the initial beneÔ¨Åt of reuse via cloning.
Solution 1: Clone&own with provenance (Fig. 2, 1st level).
Our solution is to record traceability information about the
cloned variants‚Äô provenance, which eases tracking and synchro-
nizing clones. It also bypasses the inaccuracies associated with
clone detection, making tasks such as change propagation more
effective. The virtual platform records clone traces among assets
in the background, without requiring extra effort from the devel-
oper, but who can query it for obtaining the clones of an asset.
To this end, the developer invokes the CloneAsset
operator provided by the virtual platform. As a result, a trace
between the original asset and its clone is stored in a trace
database, which can be queried at any time by the developer
to retrieve clones of an asset quickly and accurately. The
developer can later propagate changes between the original
asset and its clone ( PropagateToAsset ) or integrate
changes between the assets (either manually or using a tool)
by exploiting the continuously recorded meta-data.
Problem 2: What is in my cloned variants? With more
variants, despite provenance information, the problem arises
that developers lose overview. To understand what is in thevariants, we need a more abstract representation of assets.
For cloning, this is also necessary to select an existing variant
closest to the desired one in terms of the desired features.
Furthermore, our organization Ô¨Ånds the feature exponent
developed in ScientiÔ¨ÅcCalculator to be useful for other cloned
variants. To clone it, the developer needs to know which
implementation assets belong to the feature.
Solution 2: Clone&own with features (Fig. 2, 2nd level).
Adding feature meta-data adds perspective and allows func-
tional decomposition. It also allows representing assets in terms
of features, to reuse and clone features across projects. Lastly,
including feature-related information allows going past the
efforts and inaccuracies of feature location (recovering where a
feature is implemented), making feature reuse and maintenance
more effective. The virtual platform offers operators to add
features conveniently (at the same time annotating assets).
The developer maps assets to features by using the operator
MapAssetToFeature . She can later query the virtual
platform to Ô¨Ånd the location of the features using the operator
getMappedAssets , and also to clone assets along with
feature mappings ( CloneAsset ).
Problem 3: How to reduce redundancy? Despite features,
which help maintaining variants, substantial redundancy exists.
Solution 3: Clone&own with conÔ¨Åguration (Fig. 2, 3rd level).
To reduce it, our organization starts to incorporate conÔ¨Åguration
mechanisms. These allow to enable or disable features, such
asSmallDisplay , which control variation points. This reduces
redundancy and maximizes reuse. So, the organization
maintains a list of features and uses a conÔ¨Ågurator tool. The
virtual platform supports this solution with a simple operator.
Over time, the developer adds features by invoking the
operator AddFeature . She can map the assets to fea-
tures using MapAssetToFeature and clone features using
CloneFeature . She can also make features optional by
invoking MakeFeatureOptional . Variants can be conÔ¨Åg-
ured by cloning the repository ( CloneAsset ) with assets
mapped to only the selected features ( getMappedAssets ).
Problem 4: How to keep an overview over the features?
The more features and variation points the organization
incorporates, the more it loses overview over the features and
their relationships, including feature dependencies (accidentally
ignoring those can lead to invalid variants). Maintaining such
information would also help scoping variants.
Solution 4: Clone&own with a feature model (Fig. 2,
4th level). Our organization introduces a feature model,
which captures features and their constraints, also as input
to the conÔ¨Ågurator. Feature models are very intuitive and
simple models, which provide deep insights without much
additional tool support. They also foster communication
among stakeholders and validate feature conÔ¨Ågurations. With
this solution, consistency between features and clones is high,
since developers can also exploit the clone traces and use the
virtual platform for feature-based change propagation.
The developer adds a feature model to the repository
with the operator AddFeatureModelToAsset . She can
change the feature model to add and remove features at any
1660BC SC
GCtraceability
features
configuration
feature¬†model
integrated ¬†
platform
FC^
clone&own ¬†with
provenanceclone&own ¬†with
features
BC
c l o n e & o w nw i t hc o n f i ‚Äê
guration (optional ¬†features)clone&own ¬†with
a¬†feature¬†modelSC BC SCBC SC
integrated ¬†platform
with¬†clone&own^
Fig. 2. Spectrum between the extremes ad hoc clone&own and a fully integrated platform (see Fig. 1for both), illustrated with cloned variants: BasicCalculator
(BC), ScientiÔ¨ÅcCalculator (SC), GraphingCalculator (GC), and FinancialCalculator (FC). The virtual platform provides operators to transition along this
spectrum (e.g., to incrementally adopt a platform).
time. She can map assets to features from the feature model
(MapAssetToFeature ), clone features across projects
(CloneFeature ), and propagate changes in features to their
clones ( PropagateToFeature ).
Problem 5: How to keep consistency, improve quality,
and further reduce redundancy? Our organization needs to
further scale the development with an ever-increasing number
of variants (due to rapidly changing market needs), while
it has problems maintaining consistency and propagating
changes, despite some redundancy already being reduced with
Solution 3. It is also likely that eventually, there will be some
projects with a conÔ¨Åguration mechanism and some without.
Solution 5: Integrated platform with clone&own (Fig. 2,
5th level). Our organization integrates the projects into a
consolidated platform. Luckily it can exploit meta-data about
clone traceability ( provenance ) and features with their locations
in assets. The virtual platform provides support for this kind of
information, easing the integration of cloned variants into a plat-
form. Of course, developers might have forgotten to record all
that information, then it is natural to recover it. As long as some
information is recorded, a beneÔ¨Åt arises in terms of saved fea-
ture identiÔ¨Åcation, feature location and clone-detection effort.
B. Virtual Platform Overview
Our goal is to combine the beneÔ¨Åts of the two opposing
strategies clone&own and integrated platform, exploiting a
spectrum between both and allowing incremental transition as
in our running example (Sec. II-A). To this end, we designed
a framework called virtual platform comprising conceptual
structures upon which operators modifying the structures are
executed by developers. The conceptual structures abstractly
represent software assets at various levels of granularity‚Äîfrom
whole repositories to blocks of code‚Äîand can be adapted
to speciÔ¨Åc asset languages (explained shortly in Sec. IV).
In addition, they maintain information about variability,
speciÔ¨Åcally feature information, feature-to-asset mappings, and
clone traces. The virtual platform extends other development
tools, speciÔ¨Åcally, IDEs and version control systems. On top of
these, which are concerned with the management of assets , the
virtual platform provides dedicated functionality for managing
features . Operators can be either traditional, meaning they are
concerned with asset management, or feature-oriented, meaningthey are devoted to features and their locations in assets. In con-
trast to traditional development workÔ¨Çows, the use of dedicated
feature-oriented operators incurs a certain cost, but promises
beneÔ¨Åts to developers. In Sec. VI, we study this trade-off.
Figure 3illustrates interactions and internal workings of the
virtual platform. Developers can interact with it directly or
indirectly. The former is enabled via extensions and hooks
of existing tools. SpeciÔ¨Åcally, traditional IDE commands such
as‚ÄúCreate File‚Äù and version-control commands such as ‚ÄúAdd
File‚Äù are linked to the traditional, asset-oriented operators of
the virtual platform (e.g., ‚ÄúCreate Asset‚Äù ) and do not impose
additional effort for developers. Feature-oriented operators
can be implemented by new, feature-oriented IDE commands
(e.g., ‚ÄúCreate Feature‚Äù ). Direct interaction is enabled
via a command-line interface, where developers can call
feature-oriented operations such as ‚ÄúCreate Feature‚Äù directly.
III. M ETHODOLOGY
We followed a design-science-like strategy to iteratively deÔ¨Åne
the conceptual structures, the operators, and to evaluate them
using unit tests representing common scenarios. SpeciÔ¨Åcally,
for the structures and operators, we aimed at maximizing
the support for different scenarios from the literature and
our own professional experience. The main challenge was to
deÔ¨Åne adequate structures that, while programming-language-
independent, can be mapped to many of the different asset
types of real-world software projects, as well as to design the
operators to be able to operate on the structures.
Initial Design. We started by analyzing clone-management
and platform-migration frameworks proposed in the literature,
from which we extracted development activities that should
be supported by the virtual platform. We also had a series of
Virtual PlatformIDEDeveloper
Asset treeTraditional
operatorsFeature -
oriented
commands
Feature -
oriented
operatorsVersion
controlsystem
usesuse
modifymodifyOperators
Traditional
commandsFilesystemWorking copy
are
synchronized
usearesynchronizeduses
usesoperate
on 
Fig. 3. Overview (dashed boxes represent optional parts)
1661discussions among the authors, one from industry and four
from academia. Two authors have over ten years of research
experience in variability management and SPLE. We also
created ad hoc examples in the discussion meetings. From
these sources, we identiÔ¨Åed an initial set of data structures
and operators, and implemented them in Scala.
SpeciÔ¨Åcally, from the literature, we identiÔ¨Åed Ô¨Åve relevant
works on clone management and product-line migration using
our expert knowledge. Rubin et al.‚Äôs product-line migration
framework [ 50], [51] offers operators that support the narrative
that a mechanization‚Äîi.e., an operator-based perspective‚Äî
leads to more efÔ¨Åcient implementation and support. Fischer et
al.‚Äôs [ 52] framework and tool ECCO relies on heuristics to iden-
tify commonalities and allows composing new product variants
using reusable assets. Martinez et al.‚Äôs tool BUT4Reuse [ 53]
is an extraction-based technique for product-line migration,
including support for feature-model synthesis. Pfofe et al.‚Äôs
tool VariantSync [ 54] supports clone-management by easing the
synchronization of assets among cloned variants. Montalvillo et
al.‚Äôs operators and branching models for clone management in
version-control systems [ 55] allow isolated variant development
with change propagation, but without using the notion of
features, as opposed to the other frameworks. For brevity, we
will present the identiÔ¨Åed activities only at the end in Sec. VI-A .
Detailed descriptions are in our online appendix [ 38].
Continuous Evaluation. Once every operator was
implemented, we tested it with unit tests based on scenarios
from the literature and our own experiences. We ensured that
the operators assured the well-formedness of the conceptual
structures by prohibiting illegal actions, e.g., limiting asset
addition to scopes that can host an asset of the given type.
Final Qualitative and Quantitative Evaluation. We evalu-
ated the virtual platform qualitatively by comparing it against
the existing frameworks discussed above, from which we had
extracted activities supported by techniques for supporting
clone&own or the migration of cloned variants to an integrated
platform. We evaluated the virtual platform quantitatively in
a cost-beneÔ¨Åt calculation based on simulating the development
of a real open-source system developed using clone&own.
IV. C ONCEPTUAL STRUCTURES
The virtual platform‚Äôs conceptual structures form the basis for
its operators, which we formulated as functions with side effects
(in-place transformations) that modify the structures. Figure 4
illustrates the main structures and their relationships. We deÔ¨Åne
them abstractly, but also provide a concrete implementation
for handling assets within a Ô¨Åle system and special support
for textual Ô¨Åles that follow a hierarchical structure (e.g., with
nested classes, methods or code blocks; cf. Sec. VI).
Asset Tree ( AT)is our main conceptual structure and abstractly
represents a hierarchy of assets, such as the folder hierarchy, but
also the hierarchy within source Ô¨Åles. In Fig. 4, the AT is repre-
sented implicitly in the form of assets with their sub-asset rela-
tionships. The idea of ATis inspired by feature structure trees
(FSTs, [ 56]), which represent source Ô¨Åles. In our case, we deÔ¨Åne
theATas a hierarchical, non-cyclic tree structure of nodes. It
Asset
name : String
type: AssetTypeversion: IntFeature
name : Stringoptional: Booleanincomplete:Boolean
Details
startingLine: IntendingLine: Int<<enum>>
AssetType
VPRootTypeRepositoryTypeFolderTypeFileTypeClassTypeMethodTypeBlockType
AssetTrace
versionAt: IntFeatureModel
version: Int
FeatureTrace
versionAt: Intparent
Sub- assetIs mapped to
parent Sub- feature
Depends on
1 11
1
0..11 1
sourceclone11
0..*0..1
0..111 1*
*
1 11 1
source clone1 0..1
0..*1**
11
UnAssignedrootfeatureFig. 4. Conceptual structures: asset tree, features, mappings, and clone traces
has a synthetic root node ( root) and then represents a hierarchy
that can start with repositories as the top-level nodes, followed
by folders and Ô¨Åles, and can then go into the nesting structure
of elements of hierarchical Ô¨Åles. Every node represents an asset
related to the project, such as a folder, a Ô¨Åle (e.g., image, source
Ô¨Åle, model or requirements document), or text. Every asset has
aname , a type ( AssetType ), and a version (a simple means to
identify changes). An asset can have any number of sub-assets .
It also owns a parent pointer p, which should deÔ¨Åne a tree, with
a virtual root node ( asset of type VPRootType ) denoted as root.
TheAssetType is used to capture the role of the asset in the
project, and can be one of the following: VPRootType ,Reposi-
toryType ,FolderType ,FileType ,ClassType ,MethodType , and
BlockType . The type VPRootType is only used once in the AT,
to specify the synthetic root node. The main purpose of this root
node is to carry a global version (we explain versioning shortly).
Traditional SPLE architectures have a feature model per
project, which can be difÔ¨Åcult to maintain and evolve in large
systems (e.g., Linux kernel [ 57]). We provide a more Ô¨Çexible
structure by including an optional feature model as part of every
asset (see composition of feature model inasset in Fig. 4).
Well-Formedness Criteria We deÔ¨Åne a partial order of valid
containment over the types of assets in a check function
containable :assetasset!Bthat validates the containment
based on the asset types. For instance, VPRootType can
only be at the root, and a MethodType can be contained
in a FileType , but not the other way around. Operators are
implemented with consideration of well-formedness criteria,
to ensure that the tree structure of ATis retained.
Features and Feature Models Afeature has a name and
twoBoolean parameters: optional andincomplete . The Ô¨Åeld
optional speciÔ¨Åes whether the feature is mandatory or optional;
incomplete captures information about the completeness of
thefeature‚Äôs implementation. If the feature was cloned from
another feature model scope, it is true if the new scope
containing the feature also contains all the assets to which
thefeature is mapped; otherwise it is always false . Every
feature has an optional parent , and any number of sub-features .
Features can have dependencies to each other. A feature model
has a root feature and a mandatory feature called Unassigned ,
which contains all features that are added to the model as
a result of asset cloning. That is, if any feature mapped to
theasset is not present in the target feature model already,
it is mounted under Unassigned (and requires developer
intervention to move it to the desired location in the model).
Asset-To-Feature Mappings , in practice, can have two seman-
1662tics. They can be simple mapping relationships, indicating that
asset realizes a feature [58]. They can also indicate variability
[59], where the asset is included in a concrete variant if the
feature is selected (interestingly, if an asset is optional based
on a feature , then the asset also realizes it, but not necessarily
all assets realizing a feature are optional). The SPLE
community usually focused on the variability relationship,
and the feature-location community on traceability. For the
virtual platform, we uniÔ¨Åed the mechanism with which assets
are mapped to features. SpeciÔ¨Åcally, an asset has a presence
condition (PC)‚Äîa propositional formula over features. A PC
allows conveniently mapping assets of different granularity
levels ( AssetType ) to entire feature expressions. Whether this
relationship to the feature represents variability or traceability
is solely determined by the feature‚Äôs optional parameter.
Versioning of Assets. Assets (and features) have a version ‚Äî
an integer used to recognize changes in the AT(andFM),
especially among cloned assets. The version of the VPRootType
node has a special role, which we call ‚Äú GlobalVersion ‚Äù and
which carries the most up-to-date version , to recognize any
change in the whole AT. For simplicity, we assume that any
asset outside the tree has a version of 0. After addition,
it takes the version of the global root (initialized with 1
and incremented after any update in the AT). Versions are
incremented after every modiÔ¨Åcation and addition or removal
ofsub-assets . This simple versioning strategy is a sweet spot
between two other alternatives: First, after every change in an
asset , increment the version of the asset and continue updating
the ancestors up to the root. This would make the tracking of the
changes easy, but change propagation expensive and redundant.
Second, keep two separate numbers, one global version, and one
local version for every asset. This solution would ease change
propagation, but yield a hard-to-understand versioning model.
Clone Traceability. To maintain trace links between source
assets and their clones, we deÔ¨Åne an AssetTraceDatabase ‚Äî
essentially a list of AssetTraces (Fig. 4). An AssetTrace is a
triplet of the source asset , its clone, and a version at which
the source asset was cloned. Similarly, feature traces are
used to keep track of the feature clones, and they are stored
in a FeatureTraceDatabase . AFeatureTrace is also a triplet
pointing to the source feature , its clone, and version at the
time of cloning. These traces are a core component of our
contribution, and have special relevance in cloning and change
propagation for both assets and features. For brevity, we refer
to both AssetTraceDatabase and FeatureTraceDatabase as
TraceDatabase in the remainder of the paper.
V. V IRTUAL PLATFORM OPERATORS
We now present the traditional, asset-oriented and the feature-
oriented operators. Their underlying algorithms and further
illustrations (supplementary to the illustrations used here)
are provided in our online appendix [ 38]. The appendix also
presents a number of additional convenience operators ‚Äîutility
methods that efÔ¨Åciently traverse the trees ( AT andfeature
model ) to return data that needs to be frequently accessed
(such as assets mapped to a feature and clones of an asset etc).A. Traditional/Asset-Oriented Operators
We represent conventional activities performed by developers
using asset-oriented operators. These operators allow to
keep the ATin sync with the working directory. Also, the
assets act as mappable components to the features, and allow
cloning and change propagation. In what follows, we introduce
the asset-oriented operators with their parameter types, a
brief description, and sample scenarios, inspired from our
calculator running example (cf. Sec. II-A). The notation used
for visualizing various scenarios is shown in Fig. 5.
AddAsset :assetasset!B
Description: When a source asset (S) is added in any target
asset (T) to a repository (e.g., a Ô¨Åle to a folder), AddAsset
creates an asset forSand adds it to the preexisting asset T
in the AT. Additionally, it increments the GlobalVersion , and
assigns it to SandT. This implies that the most recently
changed assets are SandT. Also, it adds any feature mapped
toSin T‚Äôs feature model (typically repository feature model ).
Example: Consider the BasicCalculator (BC) example. The
developer adds the implementation for the divide method
in the Ô¨Åle Operators.js , with an annotation for the feature
DIV. Consequently, the virtual platform creates and adds the
asset divide (S) of MethodType to the asset Operators.js (T)
ofFileType , and DIV to the feature model ofT. The
GlobalVersion (previously 3) is incremented and assigned to
divide andOperators.js . Figure 6illustrates the scenario.
ChangeAsset :asset!B
Description: Upon a change in an asset Sin the repository,
ChangeAsset increments the GlobalVersion of the ATand
assigns it to S. Versionable changes include renaming, addition,
mapping to a feature and modiÔ¨Åcation or removal of lines.
RemoveAsset :asset!B
Description: If an asset is deleted from a parent asset T,
RemoveAsset removes its corresponding asset Sin the AT,
along with all its sub-assets. It increments the GlobalVersion
and assigns it to T. Additionally, any feature mapped to S
is also removed from the feature model ofSifStheonly
asset mapped to it. This enforces that if all assets mapped to
afeature are deleted, the feature is also deleted.
MoveAsset :assetasset!B
Description: If an asset is moved from one location to another,
MoveAsset clones the corresponding asset Sto the new
target asset T(using CloneAsset ), and removes it from the
sub-assets of its previous parent (using RemoveAsset ).
Thus far, the operators we presented serve two purposes:
keeping the ATsynchronized with the project, and keeping
Name: Type: Version Asset
Asset -to-feature 
mapping Name: Type: VersionWith 
GlobalVersion
FeatureTrace link
Name: Type: Version Added asset
Name: Type: Version Modified asset
Name: Type: Version Cloned assetname name namename name
Added Modified ClonedWith 
GlobalVersion
Fig. 5. Notations used in operator illustrations
1663Feature ModelRoot:Root:4
BC:Repository:3
Operators.js:File : 4
divide:Method:4AT (after)
BC
DIVFig. 6. Illustration of AddAsset (divide ,Operators.js )
track of changes through versioning. Following, the operators
serve two additional purposes: storing feature-oriented data,
and recording traceability among clones. The exploitation of
these meta-data are the essence of our framework.
MapAssetToFeature :assetfeature!B
Description: Upon addition of a feature mapping by a developer,
MapAssetToFeature checks if the feature exists in the
feature model of the asset . If not, it creates a feature F(with
the name used by the developer), maps it to S(corresponding
asset in the AT), and adds Fto the Unassigned feature in the
feature model ofS. IfFalready exists, it simply maps Fto
S. For mapping, it adds Fto the presencecondition ofSwith
a logical disjunction. To track this change, the GlobalVersion
is incremented and assigned to S.
Example: Assume that the developer adds a method multiply
toBC, with a feature annotation for the feature MULT .
MapAssetToFeature creates this mapping in the AT. The
presencecondition of the method becomes ‚Äú MULTjtrue ‚Äù.
CloneAsset :assetasset!B
Description: CloneAsset imitates the actual clone&own
strategy; when an asset is cloned to another location by a
developer, CloneAsset creates a deep clone of the source
asset and adds it to the target asset in the AT, provided it
iscontainable . Additionally, if the cloned asset (or its sub-
assets) is mapped to any features, they are also cloned, added
to the target feature model , and mapped to the asset clone.
The clone retains the version of the original asset, however,
since the target asset is modiÔ¨Åed (addition of sub-asset), the
GlobalVersion is incremented and assigned to the target. For
storing trace links, it creates traces for both asset andfeature
clones and adds them to the TraceDatabase .
Example: Starting from Fig. 6, the developer copies the method
divide inArithmetic.js ; a Ô¨Åle in another project, ScientiÔ¨ÅcCal-
culator (SC) .CloneAsset clones divide toArithmetic.js , an
asset ofFileType inSC, as well as the mapped feature DIV in
thefeature model ofSC. Traces for both divide andDIV are
added to the TraceDatabase . Figure 7illustrates the scenario.
PropagateToAsset :assetasset!B
Feature 
ModelRoot:Root:7
BC:Repository:3
Operators.js:File : 4
divide:Method:4AT (after)
SC:Repository:5
Arithmetic.js:File : 7
divide:Method:4Feature Model
seq source clone versionAt
t1 divide divide 4
t2 div div 1Trace Databaset1BC
DIVSC
DIV
t2
Fig. 7. Illustration of CloneAsset (divide ,Arithmetic.js )
Root:Root:9
BC:Repository:3
Operators.js:File : 4
divide:Method:8AT (after)
SC:Repository:5
Arithmetic.js:File : 7
divide:Method:9
seq source clone versionAt
t3 divide divide 8Trace 
Databaset3Fig. 8. Illustration of PropagateToAsset (divide ,divide )
Description: PropagateToAsset takes two assets, checks
if one is a clone of the other, and propagates changes in source,
after cloning, to its clone. To determine if source was changed,
it compares the version of source to its version when it was
cloned ( versionAt from the TraceDatabase ). If it is ahead
of the version it was cloned at, the changes are propagated
to the clone. Changes performed in the clone are retained.
Propagation, like cloning, includes added and modiÔ¨Åed sub-
assets, added mappings, and renaming. After propagation, a
trace with source and clone is added to the TraceDatabase ,
theversionAt of which is the version of the source. The
GlobalVersion is incremented and assigned to the clone.
Example: Assume that the divide method during cloning did not
include the check for division by zero. After adding the check
(ChangeAsset ), the divide method in source ( Operators.js ) is
ahead ( version =8) of the divide method in target ( Arithmetic.js ),
with version =4. By invoking PropagateToAsset , the
changes are propagated automatically. Figure 8demonstrates
the scenario; for simplicity, feature mappings are omitted.
B. Feature-Oriented Operators
The feature-oriented operators incorporate feature-related infor-
mation to the ATand enable feature reuse and maintenance.
AddFeature :featurefeature!B
Description: When a developer adds a feature (e.g., in a text
Ô¨Åle or a database), or an asset mapping to a feature which does
not exist in the feature model ,AddFeature creates a new
feature and adds it to the feature model . It also adds any assets
mapped to the feature using AddAsset . Similar to versioning
ofAddAsset inAT,AddFeature increments the GlobalVer-
sion (version ofrootfeature ) and assigns it to the added feature .
Example: Assume that the feature model forBCis a textual Ô¨Åle,
where features are written as individual lines, and indentation is
used to represent hierarchy (Clafer syntax [ 60]). The developer
adds a line ‚ÄúEXP‚Äù (exponent), below the line ‚ÄúBC‚Äù ( root
feature, BC).AddFeature creates a corresponding feature
EXP, and adds it to the feature BC. The version ofrootfeature
is incremented (previously 1 after adding feature DIV) and
assigned to feature EXP. Figure 9demonstrates the scenario,
with the resulting versions in a table on the right.
AddFeatureModelToAsset :assetfeature model!B
Description: Developers can add a feature model to an asset
in different ways, e.g., as a Ô¨Åle or a database. The virtual
platform, upon recognizing that a feature model is added to
an asset in the repository, invokes AddFeatureModelTo-
Asset . The operator then locates the asset in the AT, creates
afeature model FM, and sets the asset‚Äôs parameter feature
1664Feature Model
BC
DIVBC
DIV
EXPfeaturemodel.txt
EXPfeature version
BC 2
DIV 1
EXP 2Fig. 9. Illustration of AddFeature (EXP,BC)
model toFM. The GlobalVersion of the ATis incremented
and assigned to the asset which contains FM.
Example: Consider that the feature model ofBCis a separate
text Ô¨Åle, which resides in the root folder of BC. As a result
ofAddFeatureModelToAsset , the feature model (FM)
will be loaded from the Ô¨Åle and assigned to BC. All sub-assets
ofBCcan now be mapped to features from FM.
RemoveFeature :feature!B
Description: When a feature is removed by a developer from a
repository, RemoveFeature locates the feature in the feature
model , un-maps it from all assets it maps to, and removes the
feature along with all its sub-features. Additionally, any asset
mapped to only the removed feature is also removed by the
operator. The operator increments the GlobalVersion of the
FM and assigns it to the parent feature (before removal).
MoveFeature :featurefeature!B
Description: Features can be moved in the same project as a
result of refactoring, and also across projects, when developers
incorporate it into another project. MoveFeature combines
two operators; CloneFeature (explained below) to clone
thefeature (and its mapped assets) to its new location, and
RemoveFeature to remove it from its previous location.
MakeFeatureOptional :feature!B
Description: Often, developers want to keep a feature‚Äôs
implementation in the AT, and decide whether to include
it or not at compile time, instead of deleting it altogether.
MakeFeatureOptional sets a feature ‚Äôsboolean prop-
ertyoptional totrue . By default, every feature is mandatory
when added to the feature model . This operator allows to
keep the feature‚Äôs implementation in the ATwhile allowing
developers to activate or deactivate the feature.
CloneFeature :featurefeature!B
Description: Cloning a feature manually requires developers
to recollect its location in software assets. These assets can
be of different types (directory, document, code artifact, text
etc). Features can be scattered and therefore harder to locate.
This is where the stored (and maintained) meta-data pays
off.CloneFeature simply invokes a convenience operator;
getMappedAssets , to retrieve all assets mapped to the
feature. It then clones the feature and all its mapped assets
in the target AT andFM. The operator also stores traces
for the asset andfeature clones in the TraceDatabase . The
GlobalVersion of the FM is incremented and assigned to the
target feature (parent of the feature clone).
Example: After adding the feature EXP (using AddFeature ),
the developer added two assets in feature BC, and later
mapped them to feature EXP. The assets are a method
‚Äúexponent ‚Äù and a textual Ô¨Åle ‚Äú exp.txt ‚Äù with documentation
ofexponent . The developer now wants to reuse feature EXP
Feature 
Model
BC
EXPRoot:Root:8
BC:Repository:5
Operators.js:File : 4
exponent:Method:4AT (after)
Exp.txt:File:4SC:Repository:8
Operators.js:File : 4
exponent:Method:4Exp.txt:File:5 Operators.js:File : 4 Exp.txt:File:5Feature 
Model
SC
EXP
t2
t3t4 t1(versionAt = 1)Fig. 10. Illustration of CloneFeature (EXP,SC)
inSC. To clone the feature, she invokes CloneFeature ,
which clones the feature EXP and its mapped assets to SC.
Additionally, traces for the feature and asset clones are added
to the TraceDatabase . This example is illustrated in Figure 10.
Note that even though Operators.js was not cloned, the virtual
platform created a clone, as the method exponent could not
be added directly to the repository. This is referred to as tree
slicing , which the virtual platform adopts to ensure that the
well-formedness of the ATis maintained.
PropagateToFeature :featurefeature!B
Description: PropagateToFeature replicates the changes
in the feature (e.g., renaming, adding or removing sub-
features) to either selected, or all of its clones. For checking
if propagation is valid and necessary, it checks two conditions,
based on the TraceDatabase . First, if one of the features
provided is a clone of the other. Second, if the feature was
modiÔ¨Åed after cloning (current version >versionAt ). After
propagating changes, it creates new traces between the source
and newly modiÔ¨Åed targets (both feature andasset ), and adds
them to the TraceDatabase .
VI. P ROTOTYPING AND EVALUATION
We prototyped and evaluated the virtual platform qualitatively
and quantitatively: (i) in a comparative assessment against the
frameworks presented in Sec. III, (ii) using a simulation study
based on revision histories from clone&own-based system.
Details of our implementation and evaluation are available
in the online appendix [ 38]. The prototype, implemented in
Scala, provides an API as the main interface to execute the
operators. In the production-ready tool, this API would be
usable as a command line interface or a set of IDE commands.
We used a strategic programming library (kiama) for efÔ¨Åcient
tree traversal and rewriting. After implementing all operators,
we created test scenarios to verify the correctness. These test
scenarios were developed using domain knowledge acquired
by experience, and also inspired by observing scenarios from
the case study of Clafer Web Tools. We checked correctness
by comparing the result state (AT, trace, and mappings) after
operator invocations to the expected one. We also simulated
the illustrative example presented in Sec. II-A by automatically
realizing all the discussed scenarios.
A. Comparative Evaluation
For comparison, we extracted activities supported by techniques
for supporting clone&own (a.k.a., clone management), or the
migration of cloned variants to an integrated platform (a.k.a.,
product-line migration). In total, we extracted 12 activities
which we found to be common across most, if not all, existing
1665TABLE I
COMPARISON OF THE VIRTUAL PLATFORM WITH ACTIVITIES SUPPORTED
BY CLONE -MANAGEMENT AND PRODUCT -LINE MIGRATION FRAMEWORKS
Feature identiÔ¨Åcation !abstract operator [ 51], speciÔ¨Åed in the begin-
ning [ 52], [54], [53], speciÔ¨Åed any time in virtual platform
Feature location!abstract operator [ 51], extracted [ 52], [53], internal
tagging [ 54], also internal tagging in virtual platform
Feature dependency management !abstract operator [ 51], statically
mined [ 53], speciÔ¨Åed in beginning [ 54], speciÔ¨Åed any time in virtual platform
Feature model creation !multiple abstract operators [ 51], activity [ 53],
speciÔ¨Åed in the beginning [ 54], dynamically grows in virtual platform
Feature-to-asset mapping !abstract operator [ 51], extracted [ 52], [53],
speciÔ¨Åed any time [ 54], speciÔ¨Åed any time in virtual platform
Clone detection!textual diff tools [ 51], feature expression compari-
son [ 54], git clone points to source [ 55], not needed in virtual platform
Feature cloning!supported by virtual platform
Change propagation !multiple abstract operators [ 51], variant synchro-
nization [ 54], using Git merge [ 55], automated in virtual platform
Reusable assets creation !abstract & incremental [ 51], reuse existing
variants [ 52], reusable core assets[ 53], [55] and features in virtual platform
Product derivation !abstract [ 51], customizing after cherry-picking [ 55],
composition [ 52], [53], preprocessor-like in virtual platform
Integration!abstract operator using meta-data [ 51], third party tool [ 54],
Git merge [ 55],manual or tool-based, guided by meta-data in the virtual
platform
Variant synchronization !Git dif [ 55], code comparison [ 52], [53], not
needed in virtual platform
techniques. We evaluated the virtual platform‚Äôs ability to
support the scenario from Sec. IIand the 12 activities of
related frameworks. Details are in the appendix [ 38].
Table Ishows whether and how an activity related to either
clone management or product-line migration is supported by an
existing framework, as well as virtual platform. The activities
are: feature identiÔ¨Åcation (features deÔ¨Åned in a variant),
feature location (recovering traceability between features and
assets), feature dependency management (managing constraints
among features), feature model creation (creating and evolving
a feature model), storing feature-to-asset mappings, clone
detection (identifying assets which are clones of one another),
feature cloning (ability to clone features), change propagation
(replicating changes made in an asset to its clone), creation of
reusable assets (which can be used to derive variants), product
derivation (ability to derive a partial or complete product given
a conÔ¨Åguration), variant integration (merging assets/variants
by taking variability into account), and variant comparison
(comparison of assets to Ô¨Ånd commonalities and varaibilities).
In summary, among all frameworks, the virtual platform is
the Ô¨Årst one fully committed to recording traceability, instead
of recovering it later. It automatically maintains traces between
cloned assets, and encourages developers to map features to
assets of all types and all granularity levels (not just code
blocks). This traceability has a cost to developers; however, at
the same time, it can signiÔ¨Åcantly reduce cost when complex
evolution activities are performed, as detailed below.
The other frameworks deÔ¨Åne their involved activities either
abstractly or using heuristics (e.g., feature location). The virtual
platform includes exact speciÔ¨Åcations and implementations of
operators‚Äîpossible since we address a broad range of evolution
scenarios, rather than just the ‚Äúbig bang‚Äù scenario of platform
migration. The existing methods have not been applied to
real project revision histories as part of their evaluation, ratherexplain that they support migration scenarios described before.
B. Simulation Study
We used an open-source system called Clafer Web Tools
(CWT, [ 61]) that was evolved using clone&own in three cloned
variants ( ClaferMooVisualizer ,ClaferConÔ¨Ågurator ,ClaferIDE )
towards an integrated platform ( ClaferUICommonPlatform ),
including many feature clonings across the variants. We
evaluated the virtual platform‚Äôs efÔ¨Åciency by simulating the
evolution of CWT, retroÔ¨Åtting our operators to achieve the
original evolution, and studying the costs and beneÔ¨Åts.
We used a dataset by Ji et al. [ 58] that augments the
original codebase with feature information, as if it had been
developed in a feature-oriented way. It comprises a full revision
history for the four sub-systems, with source code from the
original developers, and feature information manually added
by researchers. Feature information is contained in three types
of artifacts: feature models, feature-to-asset mapping Ô¨Åles, and
embedded feature annotations in code. We provide details
about the dataset in our appendix [ 38].
Performing the Simulation. We retroÔ¨Åtted CWT‚Äôs full
revision history to our operators to extract a sequence of
(high-level) operator applications that accurately capture the
changes previously expressed by the history of (low-level)
Ô¨Åle-based commits. We analyzed each pair of successive
commits to extract a set of operator applications that produces
the delta between the commits. Replaying the operator
applications in the given order creates and updates the AT.
Cost & BeneÔ¨Åt. As costs, we measure the additional effort
imposed on developers by our platform. Our traditional, asset-
oriented operators (left-hand column of Table II) do not lead to
additional cost, because these tasks are performed in traditional
development as well. Cost arises from two components,
both related to our feature-oriented operators (right-hand
column of Table II): one called Cfeatfor maintaining features,
one called Cmiss for dealing with omissions during feature
maintenance. The latter arises if the developer forgets to
invoke a feature-oriented operator and then later the feature
information is missing for a relevant feature-oriented activity.
As beneÔ¨Åts, we consider the saved cost in two dimensions:
feature location and clone detection. Feature location cost
Clocis saved on invocations of certain operators that rely on
previously speciÔ¨Åed mappings. Clone detection cost Cclone is
saved on invocations of one certain operator for propagating
changes along clones from our clone database.
We study these costs and beneÔ¨Åts in four dedicated research
questions. RQ1 and RQ2 are devoted to costs, while RQ3 and
RQ4 are devoted to beneÔ¨Åts. We Ô¨Årst discuss these research
questions, before weighing off the observed costs and beneÔ¨Åts.
RQ1. What are the costs of maintaining features using
feature-oriented operators? The overall cost Cfeat arises
from accumulating the cost of applying feature-oriented
operators. Each feature-oriented operator ophas a cost
Cfeat(op) = # invoc (op)cost abs(op), which depends on the
number of invocations of op, and the absolute cost of each
invocation of op. Based on Table II, there are 724 invocations of
1666TABLE II
OPERATOR INVOCATIONS IN SIMULATION STUDY :ASSET -ORIENTED AND
FEATURE -ORIENTED OPERATORS
operator freq. operator freq.
AddAsset 3,527 AddFeature 229
ChangeAsset 1,191 AddFeatureModelToAsset 4
RemoveAsset 1,060 MapAssetToFeature 368
MoveAsset 303 RemoveFeature 40
CloneAsset 48 MoveFeature 22
PropagateToAsset 8 CloneFeature 54
PropagateToFeature 7
feature-oriented operators in total. Two operators contribute the
bulk to this number, namely MapAssetToFeature (368)
andAddFeature (229). The absolute cost per invocation
can be assumed to be low (in the order of seconds) because it
mostly amounts to picking the feature name, when it is fresh
in the developer‚Äôs mind. An exception are situations where
the developer has to deal with earlier omissions (see RQ2).
RQ2. What percentage of feature maintenance operations
required additional feature location effort? The omission-
related cost Cmiss arises from the number of late invocations
ofMapAssetToFeature , representing situations where the
developer missed to specify an asset-to-feature mapping when
the asset was added. This number is to be multiplied by the
absolute cost for these invocations, which is generally higher
than a regular invocation. Our operators CloneFeature , and
PropagateToFeature rely on a complete mapping from a
feature to its assets. A third relevant operator is AddFeature
which adds feature information to source code added earlier.
In absence of a recorded mapping, each operator requires an
expensive manual feature location step, which is not required in
our approach (see RQ3). We counted the number mappings that
were added before or after one of these operators was invoked,
which indicates that the researcher preparing the original dataset
noticed an omission. We determined 14 relevant mappings
forCloneFeature (2 relevant invocations, 3.7% of all
invocations), and 25 relevant mappings for AddFeature
(12 relevant invocations, 4.0% of all invocations). We did not
discover any relevant mappings for PropagateToFeature ,
yielding 39 late invocations in total.
RQ3. To what extent can feature location costs be avoided
when using feature-oriented operators? The operators
CloneFeature and PropagateFeature rely on
previously speciÔ¨Åed mappings. Conversely to RQ2, we can
assume that each invocation of one of these operators avoided
manual feature location when it did not require any Ô¨Åxing of
omitted annotations. So, we deÔ¨Åne Clocto rely on the number
of feature location steps saved by an invocation of one of our
operators. We count 54 invocations of CloneFeature , and
7 relevant invocations of PropagateToFeature , leading
to a Ô¨Ånal value of 61. This number is to be multiplied with
the absolute cost of feature location, which can be assumed to
be high (earlier work [ 58] gives an estimate of 15 minutes per
feature), based a strong reliance on the developers‚Äô memory, and
an understanding of how cross-cutting features are scattered.
RQ4. To what extent can clone detection costs be avoidedwhen using feature-oriented operators? Since the propagation
of changes along clones requires a complete speciÔ¨Åcation of
the clones at hand, we can assume that every application
ofPropagateToFeature saves one application of clone
detection (either manual or using a tool). In our subject system,
we identiÔ¨Åed 7 invocations of PropagateToFeature . To
obtain the value of Cclone , this number of is to be multiple with
the absolute cost for clone detection. Manual clone detection is
a tedious and error-prone task, and known to be infeasible for
larger systems [ 62]. Tool-based clone detection requires manual
veriÔ¨Åcation and postprocessing, since even the most advanced
clone detection tools have imperfect precision and recall [ 63].
C. Discussion
Break-Even Point. We can now weigh off the costs observed
in RQ1+2 against the beneÔ¨Åts from RQ3+4. Consider the
following formula, which speciÔ¨Åes the total beneÔ¨Åt of using the
virtual platform: Btotal = -(Cfeat+Cmiss) + (Cloc+Cclone ).
If this formula yields a positive value, the virtual platform
surpasses the break-even point and leads to a net beneÔ¨Åt.
The value of Btotal depends on the absolute costs for opera-
tor invocations, feature location, and clone detection, which are
unavailable. However, we can perform an approximation based
on plausible estimates: (1.) For the cost of feature location,
we rely on the earlier literature estimate [ 58] of 15 minutes
per instance. (2.) We assume clone detection to have the same
cost as feature location. (3.) We assume the cost for adding an
omitted annotation to be 10 times as high as a regular operator
invocation. Based on these three assumptions, we break even
ifinvoking a feature-oriented operator takes 54 seconds or
lesson average. In practice, the beneÔ¨Åt can be assumed to be
larger, since invoking a feature-oriented operator mostly entails
picking a feature name (while the feature is still fresh in the
developer‚Äôs mind), a matter of a few seconds.
This calculation shows promising results in terms of saved
effort and time. By simulating the development of the case study
with feature-oriented information, we can reuse as much as 20
features from one project ( ClaferMooVisualizer ) by cloning
them. We envision greater accuracy and efÔ¨Åciency levels when
the virtual platform is used alongside development.
Representativeness. Our case is representative for systems
of comparable size (547k lines, four variants). Many reported
product-line migrations are of similar size [ 64]. We argue for
representativeness for larger systems qualitatively. Our case
has all evolution activities observable in industrial systems,
supported by other frameworks. Still, the virtual platform is
evaluated more extensively than any of these.
Threats to Validity. A threat to external validity is that our
operators do not completely capture the real-world scenarios
developers encounter when dealing with variant-rich systems.
We mitigate this threat with our evaluation based on the
simulation of a real system. There is a general lack of available
systems for benchmarking on realistic revision histories with
available feature information, a problem that we aim to address
as part of our ongoing benchmarking initiative [ 65], [66].
1667There are two main threats to internal validity. First, our
calculation of Cmiss could be incomplete: there might be
potential omissions not Ô¨Åxed by a later commit. This situation
is comparable to other research that relies on potentially
imperfect datasets (e.g., in software defect prediction [ 67],
[68]). While our analysis focuses on omissions that later
required Ô¨Åxing, these omissions are arguably the most relevant
ones in practice. Second, there could be implementation
errors; after retroÔ¨Åtting our operations to the development
process given by the commit revision, the ATmight be in an
incorrect state. To mitigate this threat, one author, not involved
in the simulation, manually inspected a random sample of
25 commits by comparing the gitdiffwith the ATresulting
from operator invocations. The ATwas always consistent.
VII. R ELATED WORK
The Ô¨Åve most closely related works are the clone-management
and product-line-migration frameworks that we used to inform
the virtual platform‚Äôs design ([ 51], [52], [53], [54], [55],
cf. Sec. III). In Sec. VI-A and our online appendix [ 38], we
provide a detailed comparison, highlighting unique beneÔ¨Åts
of the virtual platform: support for early traceability recording,
operators for the full spectrum between the extremes ad hoc
clone&own and integrated platform, and an evaluation on a real
project revision history. We now discuss further related work
on product-line migration and integrated-platform evolution.
The idea of automatically handling variation points, as the vir-
tual platform does, is not new. In fact, going back to the 1970s,
researchers have built so-called variation-control systems [ 69],
[70], which never made it into the practice of software
engineering. These systems have been realized upon different
back- and frontends (e.g., version-control systems [ 71], [72] or a
text editor [ 73]), but before effective and scalable concepts from
SPLE research for managing variability have been established.
The virtual platform can be seen as a variation control system.
The large majority of product-line migration techniques
focuses on detecting and analyzing commonalities and
variabilities of the cloned variants, together with feature
identiÔ¨Åcation and location, as shown in Assuncao et al.‚Äôs
recent mapping study based on 119 papers [ 74]. Case studies
of manual migration [ 48], [18], [20], [75], [76], [17] also exist.
These illustrate the difÔ¨Åculties and huge efforts of recovering
important information (features and clone relationships) that
was never recorded during clone&own, supporting our approach
of recording such information early. Finally, many works focus
on migrating a single system into a conÔ¨Ågurable, product-line
platform [ 77], [76], [75], [78], typically proposing refactoring
techniques. Wille et al. [ 79] use variability mining to generate
transformational rules for creating delta-oriented product lines.
Others focus on evolving software platforms. Liebig et
al. [80] present variability-aware sound refactorings (rename
identiÔ¨Åer, extract function, inline function) for evolving a
platform by preserving the variants. Rabiser et al. [ 81] present
an approach for managing clones at product, component, and
feature, and deÔ¨Åne 5 consistency levels to monitor co-evolving
clones. Ignaim et al. [ 82] present an extractive approach toengineer cloned variants into systematic reuse. Neves et al. [ 83]
propose a set of operators for safe platform evolution. In
contrast to our operationally deÔ¨Åned operators, these operators
are deÔ¨Åned on an abstract level, based on their pre- and post-
conditions; implementing them is left to the user. Incorporating
safe evolution or Morpheus‚Äô refacting in the virtual platform
is a valuable future work.
VIII. C ONCLUSION
We designed, formalized, and prototyped the virtual platform‚Äî
a framework that exploits a spectrum between the two
extremes ad hoc clone&own and fully integrated platform,
supporting both kinds of development. Based on the number
of variants, organizations can decide to use only a subset of
all the variability concepts typically required for an integrated
platform, fostering Ô¨Çexibility and innovation, starting with
clone&own and incrementally scaling the development. This
realizes incremental beneÔ¨Åts for incremental investments and
even allows to use clone&own when a platform is already
established, to support a more agile development. Another core
novelty is that, instead of trying to expensively recover relevant
meta-data (e.g., features, feature locations, and clone traces),
the virtual platform fosters recording it early. For instance,
developers typically know the feature they are implementing,
but usually do not record it. The virtual platform records such
meta-data and exploits it for the transition, providing operators
that developers can use to handle variability. Our evaluation
shows that the additional costs are low compared to the beneÔ¨Åts.
We see several promising directions of future work. By
allowing developers to continuously record feature meta-data,
the virtual platform paves the way for software analyses that
rely on this data. One example is support for the safe evolution
of product line platforms [ 83], which could be extended
to support systems in our intermediate governance levels.
Specifying our operators in the framework of software product
line transformations [ 84], [85], [86] would make them amenable
to conÔ¨Çict and dependency analysis [ 87], a versatile formal
analysis with applications in the coordination of evolution
processes. Many of the virtual platform‚Äôs operators (e.g., those
related to change propagation) lead to non-trivial changes of the
codebase. To increase developer trust and optimize accuracy, an
important challenge is to keep the ‚Äúhuman in the loop‚Äù, which
we aim to address by exploring dedicated user interfaces. By
integrating the virtual platform with available annotation sys-
tems [ 88], we could facilitate inspection of the available feature
mappings. Offering a ‚Äúpreview mode‚Äù would allow to inspect
and interact with the changes arising from a planned operator
invocation. Providing a dedicated operator to integrate cloned
features is another future direction. Other directions are to
support conÔ¨Åguration of variants by selecting features, offering
views [ 89], and providing visualizations (e.g., dashboards [ 90],
[91]). Finally, recommender systems that learn from the meta-
data and support developers handling features and assets could
further encourage using features in software engineering [ 92].
Acknowledgment. Swedish Research Council (257822902),
Vinnova Sweden (2016-02804), and the Wallenberg Academy.
1668REFERENCES
[1]Y . Dubinsky, J. Rubin, T. Berger, S. Duszynski, M. Becker, and
K. Czarnecki, ‚ÄúAn exploratory study of cloning in industrial software
product lines,‚Äù in CSMR , 2013.
[2] ¬∏ S. St Àòanciulescu, S. Schulze, and A. W Àõ asowski, ‚ÄúForked and integrated
variants in an open-source Ô¨Årmware project,‚Äù in ICSME , 2015.
[3]J. Businge, O. Moses, S. Nadi, E. Bainomugisha, and T. Berger, ‚ÄúClone-
based variability management in the android ecosystem,‚Äù in ICSME ,
2018.
[4]J. Krueger and T. Berger, ‚ÄúAn empirical analysis of the costs of clone-
and platform-oriented software reuse,‚Äù in FSE, 2020.
[5]N. Lodewijks, ‚ÄúAnalysis of a clone-and-own industrial automation system:
An exploratory study,‚Äù in SATToSE , 2017.
[6]T. Berger, R. Rublack, D. Nair, J. M. Atlee, M. Becker, K. Czarnecki, and
A. Wasowski, ‚ÄúA survey of variability modeling in industrial practice,‚Äù
inVaMoS , 2013.
[7]P. Clements and L. Northrop, Software Product Lines: Practices and
Patterns , 2001.
[8]K. Czarnecki and U. W. Eisenecker, Generative Programming: Methods,
Tools, and Applications , 2000.
[9]F. J. van der Linden, K. Schmid, and E. Rommes, Software Product Lines
in Action: The Best Industrial Practice in Product Line Engineering ,
2007.
[10] S. Apel, D. Batory, C. K√§stner, and G. Saake, in Feature-Oriented
Software Product Lines . Springer, 2013.
[11] T. Berger, J.-P. Stegh√∂fer, T. Ziadi, J. Robin, and J. Martinez, ‚ÄúThe state
of adoption and the challenges of systematic variability management in
industry,‚Äù Empirical Software Engineering , vol. 25, no. 3, pp. 1755‚Äì1797,
2020.
[12] K. Kang, S. Cohen, J. Hess, W. Nowak, and S. Peterson, ‚ÄúFeature-
oriented domain analysis (FODA) feasibility study,‚Äù Carnegie-Mellon
University, Pittsburgh, PA, USA, Tech. Rep., 1990.
[13] D. Nesic, J. Krueger, S. Stanciulescu, and T. Berger, ‚ÄúPrinciples of
feature modeling,‚Äù in FSE, 2019.
[14] T. Berger, S. She, R. Lotufo, K. Czarnecki, and A. Wasowski, ‚ÄúFeature-
to-code mapping in two large product lines,‚Äù in SPLC , 2010, extended
Abstract.
[15] L. Linsbauer, E. R. Lopez-Herrejon, and A. Egyed, ‚ÄúRecovering
traceability between features and code in product variants,‚Äù in SPLC ,
2013.
[16] R. Bashroush, M. Garba, R. Rabiser, I. Groher, and G. Botterweck, ‚ÄúCase
tool support for variability management in software product lines,‚Äù ACM
Computing Surveys (CSUR) , vol. 50, no. 1, pp. 1‚Äì45, 2017.
[17] F. Stallinger, R. Neumann, R. Schossleitner, and S. Kriener, ‚ÄúMigrating
towards evolving software product lines: Challenges of an SME in a core
customer-driven industrial systems engineering context,‚Äù in PLEASE ,
2011.
[18] H. P. Jepsen, J. G. Dall, and D. Beuche, ‚ÄúMinimally invasive migration
to software product lines,‚Äù in SPLC , 2007.
[19] W. K. G. Assun√ß√£o, R. E. Lopez-Herrejon, L. Linsbauer, S. R. Vergilio,
and A. Egyed, ‚ÄúReengineering legacy applications into software product
lines: a systematic mapping,‚Äù Empirical Software Engineering , vol. 22,
no. 6, pp. 2972‚Äì3016, 2017.
[20] J. Krueger and T. Berger, ‚ÄúActivities and costs of re-engineering cloned
variants into an integrated platform,‚Äù in VaMoS , 2020.
[21] J. Martinez, T. Ziadi, T. F. Bissyand√©, J. Klein, and Y . L. Traon, ‚ÄúName
suggestions during feature identiÔ¨Åcation: The variclouds approach,‚Äù in
SPLC , 2016.
[22] S. Zhou, S. St Àòanciulescu, O. Le√üenich, Y . Xiong, A. Wasowski, and
C. K√§stner, ‚ÄúIdentifying features in forks,‚Äù in ICSE , 2018.
[23] S. B. Nasr, G. B√©can, M. Acher, J. B. F. Filho, N. Sannier, B. Baudry,
and J. Davril, ‚ÄúAutomated extraction of product comparison matrices
from informal product descriptions,‚Äù Journal of Systems and Software ,
vol. 124, pp. 82‚Äì103, 2017.
[24] J. Rubin and M. Chechik, ‚ÄúA Survey of Feature Location Techniques,‚Äù
inDomain Engineering , 2013, pp. 29‚Äì58.
[25] B. Dit, M. Revelle, M. Gethers, and D. Poshyvanyk, ‚ÄúFeature location
in source code: a taxonomy and survey,‚Äù Journal of software: Evolution
and Process , vol. 25, no. 1, pp. 53‚Äì95, 2013.
[26] G. K. Michelon, L. Linsbauer, W. K. Assun√ß√£o, S. Fischer, and A. Egyed,
‚ÄúA hybrid feature location technique for re-engineering single systems
into software product lines,‚Äù in VaMoS , 2021.[27] C. K√§stner, A. Dreiling, and K. Ostermann, ‚ÄúVariability mining with
leadt,‚Äù Tec. Rep., Philipps Univ. Marburg , 2011.
[28] C. K√§stner, A. Dreiling, and K. Ostermann, ‚ÄúVariability mining: Consis-
tent semi-automatic detection of product-line features,‚Äù IEEE Transactions
on Software Engineering , vol. 40, no. 1, pp. 67‚Äì82, 2013.
[29] C. K. Roy and J. R. Cordy, ‚ÄúA survey on software clone detection
research,‚Äù Queen‚Äôs School of Computing TR , vol. 541, no. 115, pp.
64‚Äì68, 2007.
[30] D. Rattan, R. Bhatia, and M. Singh, ‚ÄúSoftware clone detection: A
systematic review,‚Äù Information and Software Technology , vol. 55, no. 7,
pp. 1165‚Äì1199, 2013.
[31] J. Wang, X. Peng, Z. Xing, and W. Zhao, ‚ÄúHow developers perform
feature location tasks: a human-centric and process-oriented exploratory
study,‚Äù Journal of Software: Evolution and Process , vol. 25, no. 11, pp.
1193‚Äì1224, 2013.
[32] S. Gr√ºner, A. Burger, T. Kantonen, and J. R√ºckert, ‚ÄúIncremental migration
to software product line engineering,‚Äù in SPLC , 2020.
[33] J. Kr√ºger, W. Mahmood, and T. Berger, ‚ÄúPromote-pl: a round-trip
engineering process model for adopting and evolving product lines,‚Äù
inSPLC , 2020.
[34] B. Zhang, M. Becker, T. Patzke, K. Sierszecki, and J. E. Savolainen,
‚ÄúVariability evolution and erosion in industrial product lines: a case study,‚Äù
inSPLC , 2013.
[35] M. Antkiewicz, W. Ji, T. Berger, K. Czarnecki, T. Schmorleiz, R. L√§mmel,
t. StÀòanciulescu, A. Wasowski, and I. Schaefer, ‚ÄúFlexible product line
engineering with a virtual platform,‚Äù in ICSE-NIER , 2014.
[36] T. Fogdal, H. Scherrebeck, J. Kuusela, M. Becker, and B. Zhang, ‚ÄúTen
years of product line engineering at danfoss: lessons learned and way
ahead,‚Äù in SPLC , 2016.
[37] ‚ÄúVirtual platform prototype,‚Äù https://bitbucket.org/easelab/workspace/
projects/VP .
[38]‚ÄúAppendix,‚Äù https://bitbucket.org/easelab/2021-icse-vponlineappendix .
[39] M. A. Laguna and Y . Crespo, ‚ÄúA systematic mapping study on software
product line evolution: From legacy system reengineering to product
line refactoring,‚Äù Science of Computer Programming , vol. 78, no. 8, pp.
1010‚Äì1034, 2013.
[40] L. Passos, R. Queiroz, M. Mukelabai, T. Berger, S. Apel, K. Czarnecki,
and J. Padilla, ‚ÄúA study of feature scattering in the linux kernel,‚Äù IEEE
Transactions on Software Engineering , vol. 47, pp. 146‚Äì164, 2021.
[41] L. Passos, J. Padilla, T. Berger, S. Apel, K. Czarnecki, and M. T. Valente,
‚ÄúFeature scattering in the large: A longitudinal study of Linux kernel
device drivers,‚Äù in MODULARITY , 2015.
[42] T. Berger, D. Lettner, J. Rubin, P. Gr√ºnbacher, A. Silva, M. Becker,
M. Chechik, and K. Czarnecki, ‚ÄúWhat is a feature? a qualitative study
of features in industrial software product lines,‚Äù in SPLC , 2015.
[43] J. Kr√ºger, W. Gu, H. Shen, M. Mukelabai, R. Hebig, and T. Berger, ‚ÄúTo-
wards a better understanding of software features and their characteristics:
a case study of marlin,‚Äù in VaMoS , 2018.
[44] J. Kr√ºger, M. Mukelabai, W. Gu, H. Shen, R. Hebig, and T. Berger,
‚ÄúWhere is my feature and what is it about? a case study on recovering
feature facets,‚Äù Journal of Systems and Software , vol. 152, pp. 239‚Äì253,
2019.
[45] J. Kr√ºger, L. Nell, W. Fenske, G. Saake, and T. Leich, ‚ÄúFinding Lost
Features in Cloned Systems,‚Äù in SPLC , 2017.
[46] T. Berger, S. She, R. Lotufo, A. Wasowski, and K. Czarnecki, ‚ÄúA study of
variability models and languages in the systems software domain,‚Äù IEEE
Transactions on Software Engineering , vol. 39, no. 12, pp. 1611‚Äì1640,
2013.
[47] J. Sincero, H. Schirmeier, W. Schr√∂der-Preikschat, and O. Spinczyk, ‚ÄúIs
The Linux Kernel a Software Product Line?‚Äù in SPLC-OSSPL , 2007.
[48] W. A. Hetrick, C. W. Krueger, and J. G. Moore, ‚ÄúIncremental return
on incremental investment: Engenio‚Äôs transition to software product line
practice,‚Äù in OOPSLA , 2006.
[49]D. Bilic, D. Sundmark, W. Afzal, P. Wallin, A. Causevic, C. Amlinger,
and D. Barkah, ‚ÄúTowards a model-driven product line engineering process:
An industrial case study,‚Äù in ISEC , 2020.
[50] J. Rubin, K. Czarnecki, and M. Chechik, ‚ÄúManaging cloned variants: A
framework and experience,‚Äù in SPLC , 2013.
[51] ‚Äî‚Äî, ‚ÄúCloned product variants: from ad-hoc to managed software product
lines,‚Äù International Journal on Software Tools for Technology Transfer ,
vol. 5, no. 17, pp. 627‚Äì646, 2015.
[52] S. Fischer, L. Linsbauer, R. E. Lopez-Herrejon, and A. Egyed, ‚ÄúEnhancing
clone-and-own with systematic reuse for developing software variants,‚Äù
inICSME , 2014.
1669[53] J. Martinez, T. Ziadi, T. F. Bissyand√©, J. Klein, and Y . L. Traon, ‚ÄúBottom-
up technologies for reuse: Automated extractive adoption of software
product lines,‚Äù in ICSE-C , 2017.
[54] T. Pfofe, T. Th√ºm, S. Schulze, W. Fenske, and I. Schaefer, ‚ÄúSynchronizing
software variants with variantsync,‚Äù in SPLC , 2016.
[55] L. Montalvillo and O. D√≠az, ‚ÄúTuning github for spl development:
branching models & repository operations for product engineers,‚Äù in
SPLC , 2015.
[56] S. Apel, C. K√§stner, and C. Lengauer, ‚ÄúFeaturehouse: Language-
independent, automated software composition,‚Äù in ICSE , 2009.
[57] S. She, R. Lotufo, T. Berger, A. Wasowski, and K. Czarnecki, ‚ÄúThe
variability model of the linux kernel.‚Äù VaMoS , 2010.
[58] W. Ji, T. Berger, M. Antkiewicz, and K. Czarnecki, ‚ÄúMaintaining feature
traceability with embedded annotations,‚Äù in SPLC , 2015.
[59] D. Str√ºber, A. Anjorin, and T. Berger, ‚ÄúVariability representations in
class models: An empirical assessment,‚Äù in MODELS , 2020.
[60] K. B Àõ ak, Z. Diskin, M. Antkiewicz, K. Czarnecki, and A. W Àõ asowski,
‚ÄúClafer: unifying class and feature modeling,‚Äù Software & Systems
Modeling , vol. 15, no. 3, pp. 811‚Äì845, 2016.
[61] M. Antkiewicz, K. Bak, A. Murashkin, R. Olaechea, J. Hui, and
K. Czarnecki, ‚ÄúClafer tools for product line engineering.‚Äù in SPLC
Workshops , 2013.
[62] R. Koschke, ‚ÄúSurvey of research on software clones,‚Äù in Dagstuhl Seminar
Proceedings . Schloss Dagstuhl-Leibniz-Zentrum f√ºr Informatik, 2007.
[63] H. Sajnani, V . Saini, J. Svajlenko, C. K. Roy, and C. V . Lopes,
‚ÄúSourcerercc: Scaling code clone detection to big-code,‚Äù in ICSE , 2016.
[64] J. Martinez, W. K. G. Assun√ß√£o, and T. Ziadi, ‚ÄúEspla: A catalog of
extractive spl adoption case studies,‚Äù in SPLC , 2017.
[65] D. Str√ºber, M. Mukelabai, J. Kr√ºger, S. Fischer, L. Linsbauer, J. Martinez,
and T. Berger, ‚ÄúFacing the truth: benchmarking the techniques for the
evolution of variant-rich systems,‚Äù in SPLC , 2019.
[66] T. Berger, M. Chechik, T. Kehrer, and M. Wimmer, ‚ÄúSoftware evolution
in time and space: Unifying version and variability management (dagstuhl
seminar 19191),‚Äù in Dagstuhl Reports . Schloss Dagstuhl ‚Äì Leibniz-
Zentrum fuer Informatik, 2019.
[67] C. Catal and B. Diri, ‚ÄúA systematic review of software fault prediction
studies,‚Äù Expert systems with applications , vol. 36, no. 4, pp. 7346‚Äì7354,
2009.
[68] S. Str√ºder, M. Mukelabai, D. Str√ºber, and T. Berger, ‚ÄúFeature-oriented
defect prediction,‚Äù in SPLC , 2020.
[69] L. Linsbauer, T. Berger, and P. Gr√ºnbacher, ‚ÄúA classiÔ¨Åcation of variation
control systems,‚Äù in GPCE , 2017.
[70]L. Linsbauer, F. Schwaegerl, T. Berger, and P. Gruenbacher, ‚ÄúConcepts
of variation control systems,‚Äù Journal of Systems and Software , vol. 171,
p. 110796, 2021.
[71] B. P. Munch, J.-O. Larsen, B. Gulla, R. Conradi, and E.-A. Karlsson,
‚ÄúUniform versioning: The change-oriented model,‚Äù in SCM , 1993.
[72] A. Lie, R. Conradi, T. Didriksen, and E. Karlsson, ‚ÄúChange oriented
versioning in a software engineering database,‚Äù in SCM , 1989, pp. 56‚Äì65.
[81] D. Rabiser, P. Gr√ºnbacher, H. Pr√§hofer, and F. Angerer, ‚ÄúA prototype-
based approach for managing clones in clone-and-own product lines,‚Äù
inProceedings of the 20th International Systems and Software Product
Line Conference , 2016, pp. 35‚Äì44.[73] V . J. Kruskal, ‚ÄúManaging multi-version programs with an editor,‚Äù IBM
Journal of Research and Development , vol. 28, no. 1, pp. 74‚Äì81, 1984.
[74] W. K. G. Assun√ß√£o, R. E. Lopez-Herrejon, L. Linsbauer, S. R. Vergilio,
and A. Egyed, ‚ÄúReengineering legacy applications into software product
lines: A systematic mapping,‚Äù Empirical Software Engineering , vol. 22,
no. 6, pp. 2972‚Äì3016, 2017.
[75] C. K√§stner, S. Apel, and D. S. Batory, ‚ÄúA case study implementing
features using aspectj,‚Äù in SPLC , 2007.
[76] R. Kolb, D. Muthig, T. Patzke, and K. Yamauchi, ‚ÄúRefactoring a legacy
component for reuse in a software product line: a case study,‚Äù Journal
of Software Maintenance , vol. 18, no. 2, pp. 109‚Äì132, 2006.
[77] S. Schulze, T. Th√ºm, M. Kuhlemann, and G. Saake, ‚ÄúVariant-preserving
refactoring in feature-oriented software product lines,‚Äù in VaMoS , 2012.
[78] J. Cleland-Huang, A. Agrawal, M. N. A. Islam, E. Tsai, M. Van Spey-
broeck, and M. Vierhauser, ‚ÄúRequirements-driven conÔ¨Åguration of
emergency response missions with small aerial vehicles,‚Äù in SPLC , 2020.
[79] D. Wille, T. Runge, C. Seidl, and S. Schulze, ‚ÄúExtractive software product
line engineering using model-based delta module generation,‚Äù in VaMoS ,
2017.
[80] J. Liebig, A. Janker, F. Garbe, S. Apel, and C. Lengauer, ‚ÄúMorpheus:
Variability-aware refactoring in the wild,‚Äù in ICSE , 2015.
[82] K. Ignaim, J. M. Fernandes, A. L. Ferreira, and J. Seidel, ‚ÄúA systematic
reuse-based approach for customized cloned variants,‚Äù in QUATIC , 2018.
[83] L. Neves, P. Borba, V . Alves, L. Turnes, L. Teixeira, D. Sena, and
U. Kulesza, ‚ÄúSafe evolution templates for software product lines,‚Äù Journal
of Systems and Software , vol. 106, pp. 42‚Äì58, 2015.
[84] G. Taentzer, R. Salay, D. Str√ºber, and M. Chechik, ‚ÄúTransformations
of software product lines: A generalizing framework based on category
theory,‚Äù in MODELS , 2017.
[85] D. Str√ºber, S. Peldszus, and J. J√ºrjens, ‚ÄúTaming multi-variability of
software product line transformations,‚Äù in FASE , 2018.
[86] M. Chechik, M. Famelis, R. Salay, and D. Str√ºber, ‚ÄúPerspectives of
model transformation reuse,‚Äù in IFM, 2016.
[87] L. Lambers, D. Str√ºber, G. Taentzer, K. Born, and J. Huebert, ‚ÄúMulti-
granular conÔ¨Çict and dependency analysis in software engineering based
on graph transformation,‚Äù in ICSE , 2018.
[88] T. Schwarz, W. Mahmood, and T. Berger, ‚ÄúA common notation and tool
support for embedded feature annotations,‚Äù in SPLC , 2020.
[89] S. Stanciulescu, T. Berger, E. Walkingshaw, and A. W Àõ asowski, ‚ÄúConcepts,
operations, and feasibility of a projection-based variation control system,‚Äù
inICSME , 2016.
[90] B. Andam, A. Burger, T. Berger, and M. R. V . Chaudron, ‚ÄúFlorida:
Feature location dashboard for extracting and visualizing feature traces,‚Äù
inVaMoS , 2017.
[91] S. Entekhabi, A. Solback, J.-P. Stegh√∂fer, and T. Berger, ‚ÄúVisualization
of feature locations with the tool featuredashboard,‚Äù in SPLC, Tools
Track , 2019.
[92] H. Abukwaik, A. Burger, B. Andam, and T. Berger, ‚ÄúSemi-automated
feature traceability with embedded annotations,‚Äù in ICSME , 2018.
1670