CCGraph: a PDG-based code clone detector with approximate
graph matching
Yue Zouâˆ—
SchoolofComputerScienceandTechnology,Universityof
Science and Technology of China
Hefei, China
zy1996@mail.ustc.edu.cnBihuan Banâˆ—
School of Data Science, University of Science and
Technology of China
Hefei, China
banbihua@mail.ustc.edu.cn
Yinxing Xueâ€ 
SchoolofComputerScienceandTechnology,Universityof
Science and Technology of China
Hefei, China
yxxue@ustc.edu.cnYun Xuâ€ â€¡
SchoolofComputerScienceandTechnology,Universityof
Science and Technology of China
Hefei, China
xuyun@ustc.edu.cn
ABSTRACT
Softwareclonedetectionisanactiveresearcharea,whichisvery
importantforsoftwaremaintenance,bugdetection,etc.Thetwo
pieces of cloned code reflect some similarities or equivalents in the
syntaxorstructureofthecoderepresentations.Therearemanyrep-
resentations of code like AST, token, PDG, etc. The PDG (Program
Dependency Graph) of source code can contain both syntactic and
structuralinformation.However,mostexistingPDG-basedtoolsare
quitetime-consumingandmissmanyclonesbecausetheydetect
code clones with exact graph matching by using subgraph isomor-
phism. In this paper, we propose a novel PDG-based code clone
detector,CCGraph,thatusesgraphkernels.Firstly,wenormalize
the structure of PDGs and design a two-stage filtering strategy by
measuring the characteristicvectors of codes. Then we detectthe
code clones by using an approximate graph matching algorithm
based on the reforming WL (Weisfeiler-Lehman) graph kernel. Ex-
perimentresultsshowthatCCGraphretainsahighaccuracy,has
both better recall and F1-score values, and detects more seman-
tic clones than other two related state-of-the-art tools. Besides,
CCGraphismuchmoreefficientthantheexistingPDG-basedtools.
CCS CONCEPTS
â€¢Softwareanditsengineering â†’Softwaremaintenancetools .
KEYWORDS
Clone detection, Program dependence graph, WL graph kernel
âˆ—Also with Key Laboratory on High Performance Computing, Anhui Province.
â€ Yinxing Xue and Yun Xu are the corresponding authors.
â€¡Also with Key Laboratory on High Performance Computing, Anhui Province.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACM
mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ASE â€™20, September 21â€“25, 2020, Virtual Event, Australia
Â© 2020 Association for Computing Machinery.
ACM ISBN 978-1-4503-6768-4/20/09...$15.00
https://doi.org/10.1145/3324884.3416541ACM Reference Format:
Yue Zou, Bihuan Ban, Yinxing Xue, and Yun Xu. 2020. CCGraph: a PDG-
basedcodeclonedetectorwithapproximategraphmatching.In 35thIEEE/ACM
International Conference on Automated Software Engineering (ASE â€™20), Sep-
tember 21â€“25, 2020, Virtual Event, Australia. ACM, New York, NY, USA,
12 pages. https://doi.org/10.1145/3324884.3416541
1 INTRODUCTION
Softwaredevelopmentoftenhasthephenomenonofcopyingsim-
ilar or identical code fragments from the existing source codes,
called ğ‘ğ‘œğ‘‘ğ‘’ ğ‘ğ‘™ğ‘œğ‘›ğ‘’ğ‘  . Existing research shows that code cloning is
veryimportantinthesoftwaredevelopmentandmaintenance[1,
2],likesoftwarerefactoring[3],bugdetection[4],copyrightpla-
giarism detection [5], code evolution analysis. In the various kinds
of code clone detection approaches, PDG (Program Dependency
Graph)-basedapproachescanfindthecodeclonesbothinsyntac-
tic similarity and semantic similarity. As Bellon et al. [6] noted,
PDG-based approaches can also report non-contiguous clones that
cannot be perceived by other techniques. However, most PDG-based approaches consume too much time because they matchgraphs exactly by using subgraph isomorphism since this is an
NP-hardproblem[7].Besides,inexistingPDG-basedapproaches,
manyofthecodeclonesaremissedduetousingexactorveryclose
subgraphisomorphism.Therefore,notonlythePDG-basedcodeclone detector with approximate graph matching can find more
codeclones,butalsomaketheprocessingtimefaster.Inaddition,
there are some deep learning s, such as Oreo [15], which encode
softwaremetricsincludingPDGmetricsintovectorsandachieve
good results. However, these methods are dependent on the initial
training data and lack the interpretability of output results.
AmongthesePDG-basedapproaches,Liuetal.[5]proposeda
classicPDG-basedclonedetectionbyusingtheVFsubgraphisomor-phismalgorithm.Andtheydidnotperformanyfilteringoperations
onPDGcandidatesets.SincetheVFsubgraphisomorphismalgo-
rithm belongs to the method of exact graphs match, this resultsin the expensive time cost. For the issue of the high complexityof subgraph isomorphism, Gabel et al. [8] proposed a method ofmapping PDG to AST and used the similarity of AST to replace
the similarity of PDGs. Although this metho dspeedsu p the clone
detection,itlosesalotofsemanticinformationandresultsinmany
9312020 35th IEEE/ACM International Conference on Automated Software Engineering (ASE)
ASE â€™20, September 21â€“25, 2020, Virtual Event, Australia Yue Zou, Bihuan Ban, Yinxing Xue, and Yun Xu
1: public static void loop1(int maxsize){ 
2:     int index=0;
3:     while(index<maxsize){4:          System.out.println(index);
5:          index++; 
6:      }
7:   }
(a) The Source Code of loop11: public static void loop2(int count){ 
2:     int loopsize=count;
3:     for(int i=0;i<loopsize;++i){4:          count=i;
5:          System.out.println(i); 
6:      }
7:   }
(b) The Source Code of loop2
Figure 1: The PDG-based Clone Pair for Loop Printing.
index++; <5>
System.out.println(index); <4>
int maxsize; <1>
index < maxsize <3>
int index=0; <2>
(a) PDG for loop1
int i=0; <4>
++i; <4>
 System.out.println(i); <6>
int count; <1>
i < loopsize  <4>
int loopsize=count; <3>
count = i; <5>
(b) PDG for loop2
Figure 2: Two PDGs for Loops in Figure 1.
missingclones.Furthermore,for theissueoflargePDGcandidate
sets,bothLietal.[4]andWangetal.[9]adoptedsomestrategies
to modify the PDG and reduce the size of PDG candidate sets, like
removing irrelevant nodes and edges. However, they still do not
avoid solving the issue of subgraph isomorphism directly.
Besidestheprocessingtime,therearemanyclonesmissedfor
existingPDG-basedapproaches.Forexample,thePDGsoftheorigi-
nalandtheclonecodearegiveninFigure1.Bothofthecodepieces
implementthesamefunctionofloopprinting.However,oneuses
ağ‘¤â„ğ‘–ğ‘™ğ‘’loop and the other one uses a ğ‘“ğ‘œğ‘Ÿloop, and there are some
otherdifferentstatements.FromthePDGsshowninFigure2,there
isnoexactsubgraphisomorphismbetweenthetwoPDGs,butthere
are some local similarities. As we can see, the diamond nodes in
two graphs have similar outgoing and inbound edges. Moreover,
they have similar neighbor nodes which are assignment or declara-
tionstatements,andtheyhavesimilarcontroldependencieswith
their neighbors. Also, there are some other local similarities in the
two PDGs, which are not described in detail here. However, the
existing PDG-based methods cannot detect these local similarities.
Therefore, we adopt the approximate graph matching algorithm
to detect these local similarities which are a kind of approximated
PDG-based code clones.
The approximate graph matching algorithms are mainly divided
into two classes, graph embedding, and graph kernel methods [10].
Graph embedding methods embed a graph into a low-dimensional
vectorbasedonthecharacteristicsofthegraph,whichcanquantita-
tivelymeasurethesimilaritybetweennodesandismoreconvenienttoapply.However,thisdimensionalityreductionprocesslosesalotofgraphstructuralinformationandseverelyaffectstheaccuracy
of the graph matching. The graph kernel methods [11] divide a
graph into several sub-structures as kernels and then calculate the
similarity of the two graphs through their sub-structures. Different
decomposition methods and substructures correspond to different
types of graph kernel methods. For example, the WL (Weisfeiler-
Lehman) [11] graph kernel collects the labels of the adjacent nodes
of each node in two graphs and measures the similarity of twonodes according to the similarity of the labels. The more similarnodes in two graphs, the closer the two graphs are. This kind of
methodnotonlyretainstheadvantagesofthelowcomputational
costofthekernelfunctionbutalsocontainsvarioustypesofgraph
informationsuchasdirectededgesandlabels.Therefore,theWL
graph kernel is very suitable for calculating the similarity between
PDG pairs. Besides, the approximate graph matching based ongraph kernels has been successfully applied in the fields of hu-
manfacerecognition[12],networkanalysis[13],andcompound
classification [14].
Inthispaper,weproposeanovelPDG-basedcodeclonedetector,
calledCCGraph,whichcanfindmorePDG-basedclonesthanothertoolsandismuchfasterthanthosePDG-basedtools.Thisapproach
reducesthesizeoftheoriginalPDGsatfirstandthenfiltersPDG
pairsbyatwo-stagestrategywithcharacteristicsimilarities.Finally,
CCGraph identifies clone pairs by an approximate graph matching
algorithm based on WL (Weisfeiler-Lehman) [11] graph kernel
algorithm.Tosumup,ourstudymakesthefollowingcontributions:
1)Weadoptanapproximategraphmatchingalgorithmbasedon
theWLgraphkernel.WLgraphkernelsortsandcompressesthe
932CCGraph: a PDG-based code clone detector with approximate graph matching ASE â€™20, September 21â€“25, 2020, Virtual Event, Australia
labels of all adjacent vertices of each node in each iteration [11],
andwecancalculatethesimilarityoftwographsbycomparingthe
numberofsimilarnodesingraphs.Wedesigntheiterationtimes
accordingtothegraphdiameterandaddtheweightofeachiteration
consideringthedistanceofthenodes.Ourtoolcanacceleratethe
comparison ofgraph similarityand detect moreclones thanstate-
of-the-art tools.
2) In the preprocessing stage, we design a two-stage filtering
algorithm.First,wecountsomenumericalcharacteristicsofPDG
forroughfilterings,suchasthesizeofPDG,andclassifythesimilar
PDGsintothesamecategory.Then,foreachcategory,wecalculate
the similarity of string characteristics like function names based
onğ½ğ‘ğ‘Ÿğ‘œğ‘Šğ‘–ğ‘›ğ‘˜ğ‘™ğ‘’ğ‘Ÿ distance[20].Besides,weoptimizethestructure
of PDGsby eliminating andmerging some irrelativenodes. These
strategies can reduce the size of candidate clone pairs greatly.
3) We present the whole PDG-based clone detector called CC-
Graph, reduce the candidate clone pairs scale in the preprocessing
stage, and adopt the approximate graph matching algorithm. It can
detect more PDG-based clones than the latest clone detector Oreo
[15]basedondeeplearningforJavaandbemuchfasterthanthe
latest PDG-based clone detector CCsharp [9] for C code.
The rest of this paper is structured as follows. Section 2 intro-
ducessomeconceptsanddefinitionsusedinourresearch.Section3describesthedetailsofthemethodsproposedinourclonedetectionprocess.Section4showstheimplementationandexperimentofour
toolagainstsomeotherstate-of-the-arttoolsonsomecodebases.
Section 5 and 6 summarize the related work and discuss the lim-
itationsofourapproach.Finally,Section7concludesthepresent
work with a discussion of future work of CCGraph.
2 PRELIMINARIES AND DEFINITIONS
In this section, we give the definitions of some important concepts
andnotationsused inthedetectionwork, likePDG,subgraphiso-
morphism,andtheWLgraphkernelwhichisusedinourproposed
method. We also give the definitions of PDG-based clones we need
to detect.
2.1 Program Dependency Graph
Aprogramdependencygraph(PDG)isalabeledanddirectedgraph
ofthesourcecodetoshowsomedependencieslikeFigure2.The
nodesinPDGcanbeclassifiedintothesystemandstatementnodes.
ThesystemnodesaregeneratedfromPDGgenerationtools,like
function entrance or exit nodes, which is not the specific code
statement.Thestatementnodesincludeeachstatementanditstype
for them.
Theedgesshowsomedependenciesbetweenstatementnodes,
suchasthedataandcontroldependencies.Thecontroldependencyedge is from a control node to a next node if the condition controls
thatthenextnodewillbeexecuted.Thedatadependencyedgeis
between two nodes that they all use the same variable or one of
themassignsthevariableandthenothersuseiteitherdirectlyor
indirectly like pointers. There is one more dependency edge called
executiondependency,whichisbetweentwonodesifoneofthe
nodes may only be executed after the other one.Definition2.1. ProgramDependencyGraph:ThePDGforacoding
program is represented as ğº=(ğ‘‰,ğ¸,ğœ‡,ğ›¿), whereVis the set of
nodes in the graph, Eis the set of edges in the graph, ğœ‡:ğ‘‰â†’ğ‘†
isafunctionassigningtypestonodesinthegraph, ğ›¿:ğ¸â†’ğ‘†isa
function assigning dependency types to edges.
2.2 Subgraph Isomorphism
Recently,manyPDG-basedclonedetectionsdefinetheclonepair
ofprogram ğ‘andğ‘/primeifandonlyifthereisasubgraphisomorphism
relationship amongtheir PDGs. Themathematic definition ofsub-
graph isomorphism is defined as below.
Definition2.2. GraphIsomorphism: ğº1(ğ‘‰1,ğ¸1,ğœ‡1,ğ›¿1)isagraph
isomorphismto ğº2(ğ‘‰2,ğ¸2,ğœ‡2,ğ›¿2)ifandonlyifthereisabijective
function ğ‘“:ğ‘‰1â†’ğ‘‰2andğ‘“âˆ’1:ğ‘‰2â†’ğ‘‰1satisfying:
â€¢ğœ‡1(ğ‘£)=ğœ‡2(ğ‘“(ğ‘£))for any ğ‘£âˆˆğ‘‰1.
â€¢âˆ€ğ‘’=(ğ‘£1,ğ‘£2)âˆˆğ¸1,âˆƒğ‘’/prime=(ğ‘“(ğ‘£1),ğ‘“(ğ‘£2)) âˆˆ ğ¸2such that
ğ›¿(ğ‘’)=ğ›¿(ğ‘’/prime).
â€¢âˆ€ğ‘’=(ğ‘£1,ğ‘£2)âˆˆğ¸2,âˆƒğ‘’/prime=(ğ‘“âˆ’1(ğ‘£1),ğ‘“âˆ’1(ğ‘£2)) âˆˆğ¸1such that
ğ›¿(ğ‘’/prime)=ğ›¿(ğ‘’).
Definition 2.3. Subgraph Isomorphism: ğº1(ğ‘‰1,ğ¸1,ğœ‡1,ğ›¿1)is a sub-
graph isomorphism to ğº2(ğ‘‰2,ğ¸2,ğœ‡2,ğ›¿2)if and only if there is an
injectivefunction ğ‘“:ğ‘‰1â†’ğ‘‰2thatthereisasubgraph ğ‘†âŠ†ğº2such
thatfis a graph isomorphism from ğº1toğ‘†.
2.3 Weisfeiler-Lehman Graph Kernel
Mathematically, the method of graph kernels maps graphs to a
vector feature space and calculates the graph similarity by their
innerproductinthevectorfeaturespace.Intheprocessofcalculat-
ing,itdividesagraphintosubstructures,andanycombinationof
graph decomposition and substructure isomorphism judgment can
be defined as a new graph kernel.
Definition 2.4. Graph Kernel: Gis a finite set of graphs, ğ‘…is a
pointproductspaceandthefunction ğ‘˜:(GÃ—G) â†’ ğ‘…isagraph
kernel, then there is a Hilbert space Fand a mapping function
ğ›¾:Gâ†’ ğ¹, for all ğº1,ğº2âˆˆG,ğ‘˜(ğº1,ğº2)=<ğ›¾(ğº1),ğ›¾(ğº2)>,
where < Â·,Â·>means the inner product in Hilbert space.
Generally, given two graphs ğº1,ğº2, and the substructures se-
quences{ğ‘†1,1,ğ‘†1,2,...,ğ‘†1,ğ‘›1}ofğº1and{ğ‘†2,1,ğ‘†2,2,...,ğ‘†2,ğ‘›2}ofğº2,
where ğ‘†1,ğ‘–is the ğ‘–ğ‘¡â„substructure of ğº1andğ‘†2,ğ‘—is the ğ‘—ğ‘¡â„substruc-
ture of ğº2, the graph kernel of ğº1andğº2can be expressed as
ğ‘˜ğ‘Ÿ(ğº1,ğº2)=ğ‘›1/summationdisplay.1
ğ‘–=1ğ‘›2/summationdisplay.1
ğ‘—=1ğœ(ğ‘†1,ğ‘–,ğ‘†2,ğ‘—)
where ğœ(ğ‘†1,ğ‘–,ğ‘†2,ğ‘—)=1 when ğ‘†1,ğ‘–andğ‘†2,ğ‘—are isomorphism else
ğœ(ğ‘†1,ğ‘–,ğ‘†2,ğ‘—)=0.
Definition2.5. Weisfeiler-LehmanGraphKernel:Giventwographs
ğº1(ğ‘‰1,ğ¸1,ğœ‡1,ğ›¿1)andğº2(ğ‘‰2,ğ¸2,ğœ‡2,ğ›¿2)anditerationnumber h,af-
ter the â„ğ‘¡â„timeâ€™s iteration of WL subtree isomorphism algorithm,
we get the structures of two graphs as ğº1(â„)=(ğº1,ğ‘™â„(ğº1))and
ğº2(â„)=(ğº2,ğ‘™â„(ğº2)).And ğ‘™â„(ğº1)isthesetofnodelabelsfor ğº1in
933ASE â€™20, September 21â€“25, 2020, Virtual Event, Australia Yue Zou, Bihuan Ban, Yinxing Xue, and Yun Xu
5
 2
4
 3
1
1
2
 5
4
 3
2
 1
(a) Given PDG G and Gâ€™
5,234
 2,35
4,1135
 3,245
1,4
1,4
2,45
 5,234
4,1235
 3,245
2,3
 1,4
(b) Multiple set label sorting
1,4
2,3
2,35
2,456
7
893, 245
4, 1135
4, 1235
5, 23410
11
1213
(c) Lable compression
13
 8
11
 10
6
6
9
 13
12
 10
7
 6
(d) Reassignment of node labels
Figure 3: Computation of the WL graph kernel for one iteration
the iteration h, the WL graph kernel is expressed as
ğ‘˜(â„)
ğ‘Šğ¿(ğº1,ğº2)=ğ‘˜(ğº1(0),ğº2(0))+...+ğ‘˜(ğº1(â„),ğº2(â„))
ğ‘˜(ğº1(â„),ğº2(â„))is the base kernel function of ğº1andğº2, which
calculates the number of same label pairs in node label sets ğ‘™â„(ğº1)
andğ‘™â„(ğº2).
Weisfeiler-Lehman(WL)graphkernel[11]isanadvancedgraph
kernel in recent years. As shown in Figure 3, the WL graph kernel
sorts the labels of all adjacent vertices of each node, compresses
these labels into a new shorter label based on a hash algorithm,and then counts the same original and compressed labels in two
graphs.Afteroneiterationofcomputation,thecompressedlabels
denotesubtreepatternsorsub-structuresinthegraph.Forinstance,
in Figure 3 (a), the node (denoted as ğ‘£) with label 5 in G and the
same label node (denoted as ğ‘£/prime) in Gâ€™ have same neighbor nodes
with label 2, 3, and 4. After collecting the neighbor node labels,
bothofthelabelsequencesof ğ‘£andğ‘£/primeare2,345,whichisshown
inFigure3(b).ThenafterthelabelcompressionshowninFigure
3(c), thenewlabel of ğ‘£andğ‘£/primeis13. Afteroneiteration oftheWL
graphkernelcalculating,inFigure3(d),the ğ‘£andğ‘£/primehavethesame
label, which means that the local graph structures around ğ‘£and
ğ‘£/primeare the same. When most of the nodes of the two graphs have
thiskindofsimilarity,wethinkthatthetwographsareverysimilar.
2.4 Similarity of Graphs Based on WL Graph
Kernel
After the approximate graph matching, we need to distinguish
whether the original code fragments are clones according to the
kernel value we calculated. Hence, we need to define a measure ofsimilarity based on the WL graph kernel value after normalizing.
Definition 2.6. The similarity of PDG pairs : Given two program
dependencygraphs ğº1(ğ‘‰1,ğ¸1,ğœ‡1,ğ›¿1)andğº2(ğ‘‰2,ğ¸2,ğœ‡2,ğ›¿2),wemea-
sure the similarity of PDG pairs by the â„timeâ€™s iterations of WL
graph kernel value as
ğ‘ ğ‘–ğ‘šğ‘–ğ‘™ğ‘ğ‘Ÿğ‘–ğ‘¡ğ‘¦ (ğº1,ğº2)=ğ‘˜(â„)
ğ‘Šğ¿(ğº1,ğº2)
|ğ‘‰1âˆªğ‘‰2|
, the similarity value is between 0 and 1, and the code fragments
ofğº1ğ‘ğ‘›ğ‘‘ğº2areğ‘ğ‘œğ‘‘ğ‘’ ğ‘ğ‘™ğ‘œğ‘›ğ‘’ whenthe ğ‘ ğ‘–ğ‘šğ‘–ğ‘™ğ‘ğ‘Ÿğ‘–ğ‘¡ğ‘¦ (ğº1,ğº2)isbigger
than the predefined threshold ğ‘‡.
3 PROPOSED METHOD
In this section, we introduce the overview of the proposed method
ofclonedetectionfirstlyandthendescribethedesignofthesimpli-
fication of PDG structures, the characteristic vector extraction, the
filtering strategies, and the approximate graph matching algorithm
based on the WL graph kernel in details.
3.1 Overview
The overview of our proposed method is shown in Figure 4. It con-
sistsoftwoprocessphases,codepreprocessingandclonedetection.
Codepreprocessinganalyzesthesourcecodefiles,extractsPDGsin
functionlevel,simplifiesthePDGstructures,andfiltersthecandi-
date PDG pairs by characteristic vectors. Clone detection measures
the similarity by calculating the WL graph kernel values of PDG
pairsandidentifiesthecodecloneifPDGpairssatisfythethreshold
condition.
934CCGraph: a PDG-based code clone detector with approximate graph matching ASE â€™20, September 21â€“25, 2020, Virtual Event, Australia
PDG pairs
Source program 
filesPDG 
generationSimplification and 
filtering
Clone candidatesApproximate 
graph matching 
based on WL 
graph kernel
Clone pairsVerifying
Preprocessing Clone detectionProgram 
Dependency 
graphs
Figure 4: The overview of the proposed method.
3.2 Simplification of PDG Structures
In the PDG generation, we observed that there are a large number
of system nodes and edges which are not related to code semantic
information. Also, there are some sub-PDGs which link to other
functionsbecauseoffunctioncallsinsourcecode.Therefore,we
proposed two strategies to simplify the structure of PDGs, elimi-
nating meaningless nodes, and merging function call sub-PDGs.
3.2.1 Eliminate meaningless nodes. In the process of PDG genera-
tion,systemnodesandsomeassistantparameternodesaregener-
atedautomaticallybythePDGgenerationtools.Thesenodesdonot
affecttheoriginallogicalstructureofthesourcecode.Therefore,
we simply remove these nodes and the edges connected to them to
reduce the size of PDGs.
3.2.2 Mergefunctioncallsub-PDGs. InthePDGsofsourcecode,
the calls to other functions are plotted as a sub-PDGs. Considering
that the codes corresponding to these sub-PDGs are not in the cur-
rent file, we simplify to merge the sub-PDG part to one function
callnode.Thismergingoperationdoesnotloseanystructurein-
formationoftheoriginalPDGbutgreatlyreducesthesizeofPDGs.
We name the new node type ğ¹ğ‘¢ğ‘›_ğ¶ğ‘ğ‘™ğ‘™to represent the function
call sub-PDGs in original PDGs.
3.3 Filtering of PDG Pairs
ClonedetectionmakesPDGpair-wisecomparison,andthescaleof PDG pairs increases exponentially with the number of PDGs.
Therefore,it isnecessaryto filterPDG pairsforreducing thetime
consuming of clone detection.
We mainly filter PDG pairs from two aspects. On the one hand,
we consider the size of PDG directly, such as the number of nodes
and edges in PDGs. And for the case that the scale ratio of the two
graphs is too big, we filter these PDG pairs as other cloning detec-
tionmethods.Ontheother hand,weadoptthefilteringstrategies
accordingtosomeimportantinformationinPDGs,suchasthedata
type of input and output. The overall PDGâ€™s characteristics are
listed in Table 1 and the filtering process is structured as following
subsections, which is also shown in algorithm 1.
3.3.1 Numericalsimilarityfiltering. Forthenumericalpartofthe
characteristic vector, we filter PDG pairs by the size of PDG and
scale ratio firstly, then calculate the cosine similarity between two
numerical vectors. PDG pairs are divided into categories according
to their numerical similarity.Algorithm 1 Characteristic Vectors Filtering
Input: ğ‘ƒis a character vector of code PDG ğº.ğ‘ƒ/primeis a character
vector of code PDG ğº/prime.ğ¿is the threshold of node number
in PDG characteristic. ğ‘‡is the threshold of PDG pairâ€™s scale
radio. ğºğ‘†is the threshold of the string similarity and ğºğ‘is
thethresholdofthenumericalsimilarityofthecharacteristic
vectors.
Output: ğ‘…is the candidate PDG pairs for the clone detection
1:function Filter( ğº,ğº/prime,ğ‘ƒ,ğ‘ƒ/prime,ğ¿ ,ğ‘‡,ğºğ‘†,ğºğ‘)
2:foreach code PDG ğºandğ‘ƒin clone codes do
3: foreach code PDG ğº/primeandğ‘ƒ/primein clone codes do
4: ifğ‘ ğ‘–ğ‘§ğ‘’ğ‘œğ‘“(ğº)<ğ¿orğ‘ ğ‘–ğ‘§ğ‘’ğ‘œğ‘“(ğº/prime)<ğ¿then
5: PDG pair (ğº,ğº/prime)is filtered
6: else if ğ‘šğ‘–ğ‘›(ğº,ğº/prime)/ğ‘šğ‘ğ‘¥(ğº,ğº/prime)<ğ‘‡then
7: PDG pair (ğº,ğº/prime)is filtered
8: else ifnumber similarity of (ğ‘ƒ,ğ‘ƒ/prime)>ğºğ‘†then
9: ğ‘…â†ğ‘…âˆª(ğº,ğº/prime)
10: CONTINUE
11: else ifstring similarity of (ğ‘ƒ,ğ‘ƒ/prime)>ğºğ‘then
12: ğ‘…â†ğ‘…âˆª(ğº,ğº/prime)
13: end if
14: end for
15:end for
16:end function
Table 1: The Characteristic Vector of PDG
Numerical characteristics Description
NumOfCtrlEdges The control dependency edges.NumOfExcEdges The excute dependency edges.NumOfDataEdges The data dependency edges.
NumOfDeclNodes The variable declaration nodes.
NumOfAssignNodes The assignment nodes.NumOfCtrlNodes The control nodes.NumOfStateNodes The function state nodes.NumOfOtherNodes other types nodes.NumOfReference The number of reference variables.
String characteristics Description
ReturnPara The return parameters.
IntroPara The incoming parameters.
Name The function name.
935ASE â€™20, September 21â€“25, 2020, Virtual Event, Australia Yue Zou, Bihuan Ban, Yinxing Xue, and Yun Xu
â€¢Sizefiltering:Intherealcodedataset,manyfunctionsonly
have a return statement. This kind of clones has no refer-
ence value for practical application. So, we focus on those
PDG pairs which have meaningful size. And in the detailed
implementation, we set the sizethresholdas 6 lines, which
is also a common filter standard of other clone detections
like CCAligner [17].
â€¢Scale ratio filtering: We need to match PDGs in pairwise,
andthepairhavenopointinthereal-worldifthescaleratio
of two PDGs is too big like one PDG size is 10 times than
the other one. We filter the pairs if the scale ratio of the two
PDGs is bigger than the specific threshold.
â€¢Numerical similarity filtering: We extract the numerical vec-
torsaccordingtothecharacteristicsofPDGslikethenumber
ofdifferentkindsofnodesandedges.Nodetypesaredivided
into a variable declaration, assignment, control statement,
function call, and other kinds of statements. Connecting
edges are classified as control dependency edge, data depen-
dencyedge,andexecutiondependencyedgeaccordingtothe
dependencyrelationship. Thenwe filterthose PDGpairs if
thecosinesimilarityoftwovectorsdoesnotmeetthethresh-oldweset.Accordingtotheresultsofrepeatedexperiments,
we set a threshold of 0.9 for numerical similarity filtering.
3.3.2 String similarity filtering. In the characteristic vectors of
PDGs,somedimensionsarestringvariables,likethefunctionname,
input parameters, output variables. For each category classified
bynumericalsimilarity,weneedtocalculatethestringsimilarity
between these string part of vector to filter some PDG pairs. Since
thestringpartsofvectorsareshortstringsandthe ğ½ğ‘ğ‘Ÿğ‘œğ‘Šğ‘–ğ‘›ğ‘˜ğ‘™ğ‘’ğ‘Ÿ
algorithmhasagreateffectonshorttextsimilaritycalculations[14,
15],wechoosethe ğ½ğ‘ğ‘Ÿğ‘œğ‘Šğ‘–ğ‘›ğ‘˜ğ‘™ğ‘’ğ‘Ÿ distanceratio[20]tomeasurethe
stringsimilarity.TheJaro-Winkleralgorithmgivesthestartingpart
a higher score for the same string, which defines a prefix range
ğ‘.Forthetwostringstobematched,theprefixparthasthesame
lengthasthepartialstringoflength ğ¿.Consideringthediversity
of string variables, in reality, we only filter those PDG pairs which
ğ½ğ‘ğ‘Ÿğ‘œğ‘Šğ‘–ğ‘›ğ‘˜ğ‘™ğ‘’ğ‘Ÿ distance ratio less than 0.5.
â€¢Jaro Distance: Jaro distance ğ‘‘ğ‘—of given strings ğ‘,ğ‘isğ‘‘ğ‘—=
1
3(ğ‘š
|ğ‘|+ğ‘š
|ğ‘|+(ğ‘šâˆ’ğ‘¡)
ğ‘š),theğ‘šisthenumberofmatchingchar-
acters, and ğ‘¡is half the number of transpositions, |ğ‘|and|ğ‘|
is the length of string ğ‘andğ‘.
â€¢JaroWinklerDistance:JaroWinklerdistance ğ‘‘ğ‘¤ofgiving
strings ğ‘,ğ‘isğ‘‘ğ‘¤=ğ‘‘ğ‘—+ğ¿âˆ—ğ‘ƒ(1âˆ’ğ‘‘ğ‘—),ğ‘‘ğ‘—istheJarodistance
of givenstrings ğ‘andğ‘,ğ¿is thelength of the prefixpartial
match, ğ‘ƒisarangefactorconstantusedtoadjusttheweight
of the prefix match, but the value of ğ‘ƒcannot exceed 0.25,
because the final score may exceed 1 point. The standard
default setting of ğ½ğ‘ğ‘Ÿğ‘œğ‘Šğ‘–ğ‘›ğ‘˜ğ‘™ğ‘’ğ‘Ÿ isğ‘ƒ=0.1.
3.4 ApproximateGraphMatchingBasedonWL
Graph Kernel
After the simplification of PDG structures and the filtering of PDG
pairs, we adopt the approximate graph matching algorithm to mea-
sure the similarity between the PDG pairs.Considering the specialty of PDGs, we choose to implement the
approximate graph matching algorithm based on the WL graphkernel. In all kinds of graph kernels, the WL graph kernel canbe applied to directed and labeled graphs, and it can process the
attributesofnodesingraphs.WLgraphkernelhasabettertime-
consuming performance than the traditional kernels like Random-
WalkorShortest-Pathgraphkernel[11].Also,thereareopensource
implementations of WL1graph kernel used in bioinformatics to
compare protein structure and we can easily apply it to our tool
withasecondarydevelopment.SincetheWLgraphkernelhasgreat
classificationperformanceanditisoneofthebestgraphkernels
at present, we choose to adopt our approximate graph matching
algorithm based on WL graph kernel.
Algorithm 2 CloneDetectionWithWLGraphKernelTestingof
Two Graphs
Input:thePDGpair (ğº,ğº/prime),allnodes ğ‘£andlabels ğ‘™(ğ‘£)ofğ‘£inğº
andğº/prime;ğ‘(ğ‘£)isthesetof ğ‘£/primeğ‘ neighbornodes; ğ‘šisthenumberof
iterationsofWLalgorithm; ğ‘‡isthethresholdofPDGsimilarity
ofğºandğº/prime.
Output: ğ‘…is the result set of PDG pairs after the clone detection
1:function Clone( ğº,ğº/prime,ğ‘£,ğ‘™(ğ‘£),ğ‘(ğ‘£),ğ‘š,ğ‘‡)
2:foreach pair (ğº,ğº/prime)in candidate pairs do
3: forğ‘–ğ‘¡â„iteration in ğ‘štimesdo
4: foreach node ğ‘£inğºandğº/primedo
5: ğ‘€(ğ‘£)â†/summationtext.1
(ğ‘™(ğ‘¢)|ğ‘¢âˆƒğ‘(ğ‘£))
6: ğ‘ (ğ‘£)â†ğ‘€(ğ‘£)sorted by ascending order
7: ğ‘ (ğ‘£)â†ğ‘™(ğ‘£)+ğ‘ (ğ‘£)
8: ğ‘™(ğ‘£)â†ğ‘“(ğ‘ (ğ‘£))
9: WHEN ğ‘“:/summationtext.1
(âˆ—) â†’/summationtext.1
10: STATISFY ğ‘“(ğ‘ (ğ‘£))=ğ‘“(ğ‘ (ğ‘¤))
11: if and only if ğ‘ (ğ‘£)=ğ‘ (ğ‘¤)
12: end for
13: ğ‘¤ğ‘–â†(ğ‘šâˆ’ğ‘–+1)/ğ‘š
14: ğ‘˜ğ‘–=ğ‘ ğ‘–ğ‘§ğ‘’ğ‘œğ‘“(ğ‘ ğ‘ğ‘šğ‘’ğ‘™ğ‘ğ‘ğ‘’ğ‘™ (ğ‘£))/ğ‘ ğ‘–ğ‘§ğ‘’ğ‘œğ‘“(ğ‘¡ğ‘œğ‘¡ğ‘ğ‘™(ğ‘£))
15: end for
16: ğ‘˜â†/summationtext.1
(ğ‘˜ğ‘–âˆ—ğ‘¤ğ‘–)
17: ifğ‘˜>ğ‘‡then
18: ğ‘…â†ğ‘…âˆª(ğº,ğº/prime)
19: end if
20:end for
21:end function
Thestepsofourproposedalgorithmaredescribedindetailas
following and shown in Algorithm 2:
â€¢Hash the label of each node in the PDG according to the
grammar category as the initial label of the node.
â€¢Set the â„iterations for the WL algorithm. In the â„iterations,
each iteration collects the labels of the current nodeâ€™s neigh-bors as a sequence and compresses the label sequence into a
new label by using a local sensitive hashing algorithm.
â€¢Ifthelabelsofthetwonodesarethesameaftertheiteration,
it is considered that the subtrees with the two nodes as the
root node and the height of â„are isomorphic.
1https://github.com/BorgwardtLab/GraphKernels.
936CCGraph: a PDG-based code clone detector with approximate graph matching ASE â€™20, September 21â€“25, 2020, Virtual Event, Australia
â€¢CalculatethenumberofsamenodepairsbetweentwoPDGs,
which is also the graph kernel value. If the graph kernel
values of the two PDGs satisfy the threshold range, the two
PDGs are considered as PDG-based code clone candidates.
Furthermore, considering the different diameters of different
clonePDGs,wedynamicallysettheiterationsnumberaccording
tothediameterofthesmallerPDG,andcountthenumberofnodes
with the same label between PDGs after each iteration. Besides,
weaddthe weightfactor (â„âˆ’ğ‘›+1)/â„tothe ğ‘›ğ‘¡â„iterationtogive
higher weight to the lower iterations because each node in source
code is more affected by its neighbors than the nodes far away.
3.5 Verifying
After the approximate graph matching based on the WL graph
kernel, we get the kernel value of PDG pairs. This step is to verify
whether the candidates are code clones.
For each PDG pair, we calculate the WL graph kernel value
ğ‘˜(â„)
ğ‘Šğ¿(ğº1,ğº2)in the approximate graph matching, and we measure
thesimilaritybytheratioofthekernelvaluetothetotalnumberof
nodesintwoPDGsshownin ğ‘†ğ‘’ğ‘ğ‘¡ğ‘–ğ‘œğ‘›2.Whenthesimilarityexceeds
the threshold we set before, we consider the code fragments of the
PDGpairare ğ‘ğ‘œğ‘‘ğ‘’ ğ‘ğ‘™ğ‘œğ‘›ğ‘’ .TofurtherverifywhethertwoPDGsare
cloned or not, we use the asymmetric coefficient ofğ·ğ‘–ğ‘ğ‘’ ğ‘ ğ‘–ğ‘šğ‘–ğ‘™ğ‘ğ‘Ÿğ‘–ğ‘¡ğ‘¦
[21] from another point of view, which is defined as follows:
ğ‘ ğ‘–ğ‘š(ğº1,ğº2)=ğ‘˜(â„)
ğ‘Šğ¿(ğº1,ğº2)
ğ‘šğ‘–ğ‘›(|ğ‘‰1|,|ğ‘‰2|).
where ğ‘‰1andğ‘‰2arethenodesetsofPDG ğº1andğº2.Thesimilarity
threshold is chosen with the best results among plenty of repeated
experiments. Therefore, we verify the two PDGs are code clones
when their similarity is greater than or equal to 0.9.
4 EVALUATION
In this section, we design and implement the experiments of ourclonedetectionCCGraphandempiricalevaluationagainstotherstate-of-the-art clone detectors. Firstly, we begin by introducing
theenvironmentconfigurationofourexperiments.Weintroduce
the datasets used in experiments in detail and explain the reasons
for choosing these datasets.
4.1 Experimental Configuration
Since most current PDG-based clone detectors are commercial thatisnotopensource,wechoosetheopensourceandexecutabletoolstobecomparedwithourapproach.ForCcode,wechoosethelatest
PDG-based clone detector CCSharp [9] for comparison both on
artificialdatasetsandreal-worlddatasets.However,CCSharpcan
notbeimplementedinJavacode.ForJavacode,thereisnotargetedPDG-basedclonedetector.ThereisaclonedetectorOreo[15]based
on deep learning to be regarded as the candidate. In the process of
model training, Oreo uses some information of PDG as a part of
featureinput,soitcanfindsomePDG-basedcodeclones.Therefore,
we choose Oreo for comparison on Java datasets. We also compare
CCGraph with other baselines such as token-based (SourcererCC,
TofindoutmoreType-3clones,weseta80%threshold),AST-based
(Deckard, also with an 80% threshold) on Java datasets. Besides,
thereisnostandardPDGtestedbenchmarktomeasuretheaccuracyandrecallrateofclonedetectionmethods.Forthis,wemanually
check the experiment results on the tested datasets.
ForthePDGgeneration,weuseFrama-C2[23]togeneratePDGs
ofCcode.ForJavaprograms,wechoosetheJavaPDGgenerator
TinyPDG3[24] based on an open source library. All PDGs of C
and Java code are unified to .ğ‘‘ğ‘œğ‘¡file format. After the PDG gen-
eration, we used Python scripts to parse .ğ‘‘ğ‘œğ‘¡files and transform
thesefilesintothespecifiedformatforsubsequentgraphmatching.
In the implementation of approximate graph matching, we usedPythonand C++tocalculate similaritybasedonsome relativeli-braries. All experiments are executed on the same machine with
Ubuntu14.04LTSoperationsystem withaquad-coreCPUand8GB
of memory.
4.2 Experimental Datasets
WeperformedexperimentsonCCGraphagainsttheCCSharp[9]
on C code and Oreo [15] on Java code on several code datasets.
Thesedatasetsincludereal-worldandartificialcodedatasets.Since
the PDG generation can only be applied to compilable code, wechoose some high-quality real-world code datasets and developsome artificial code datasets from the real-world codes by kinds
of disguises to simulate the generation of code clones in daily pro-
gramming [21, 22]. The details of these code datasets are shown in
Table2,includingtheirLoC(LineofCode),numberoffunctions,
and description.
Table 2: The Details of Datasets
Datasets LoC Functions Description
BCB-5 4374 186 Decompress zip archive.
BCB-11 8384 338 Initialize Java Eclipse projects.BCB-15 9895 478 Load custom font.BCB-38 9572 481 Get MAC address string.
Less 19233 286 Linux text viewer.
PostgreSQL 86096 1134 dataset server.
Artificial-1 1658 100 Generated artificial dataset.Artificial-2 20157 384 Generated artificial dataset.
ForCcode,wechoosethe ğ‘™ğ‘’ğ‘ ğ‘ andseveralmodulesof ğ‘ƒğ‘œğ‘ ğ‘¡ğ‘”ğ‘Ÿğ‘’ğ‘†ğ‘„ğ¿
datasets.The ğ‘™ğ‘’ğ‘ ğ‘ datasetis usedin CCSharp [9],GPLAG [5],and
theğ‘ƒğ‘œğ‘ ğ‘¡ğ‘”ğ‘Ÿğ‘’ğ‘†ğ‘„ğ¿ programisalsocommonlyusedinkindsofclone
detector.Andwealsogeneratetwoartificialdatasetsbasedonsomereal-worlddatasetlikeleetcodeorcJSONbyusingamixtureoffourtypesdisguises[25]:formatchanging(i.e.changespaces,comments,
and layouts), renaming/type changing (i.e. rename variables, func-
tions),reorderingstatements,andcontrolsubstitution(i.e.replacing
ğ‘¤â„ğ‘–ğ‘™ğ‘’loopswith ğ‘“ğ‘œğ‘Ÿ).Thesedisguisesdonotaffecttheoverallsyn-
tactic structure and PDG dependencies in original code, but may
not be detected by those tools using subgraph isomorphism.
ForJavacode,wechooseBigCloneBench,whichiscommonly
usedinallkindsofclonedetectors.BigCloneBench[27]isalarge
benchmark of manually validated clones by mining the big real-
worlddatasetIJaDataset-2.0[28](25,000Javasystems).Thecurrent
publicrelease versionof BigCloneBenchcontains 8million clones
2http://frama-c.com/index.html.
3https://github.com/YoshikiHigo/TinyPDG
937ASE â€™20, September 21â€“25, 2020, Virtual Event, Australia Yue Zou, Bihuan Ban, Yinxing Xue, and Yun Xu
of43 distinctfunctionalities[29].Considering theBigCloneBench
is too big for us to calculate the accuracy and recall of our method,
we randomly select several small functionalities.
4.3 Experimental Results
4.3.1 Efficiency of PDG Structure Simplification. We have tested
theeffectofPDGstructuresimplificationonseveraltypicaldatasets.
These strategies effectively simplify PDGs and do not damage the
original semantic information and the results of efficiency are
shown in Table 3. According to the research [16], the time costby graph matching grows exponentially with the growth of the
numbers of nodes and edges in the graph. Therefore, the reductionof PDG size by removing meaningless nodes and merging function
call sub-PDGs is very beneficial to the following processes of clone
detection.
Table 3: Efficiency of PDG Structure Simplification
Datasets LanguageSize of Size of Ratio of
original files simplification simplification
(A) files (B) (B/A)
Less C 871KB 732KB 0.84
PostgreSQL C 19.7MB 9.6MB 0.49Artificial-1 C 436KB 408KB 0.94
Aritificial-2 C 1.1M 891KB 0.79
Datasets LanguageSize of Size of Ratio of
original files simplification simplification
(A) files (B) (B/A)
BCB-5 Java 559KB 482KB 0.86
BCB-11 Java 955KB 799KB 0.84
BCB-15 Java 1.3MB 1.1MB 0.85
BCB-38 Java 1.2MB 998KB 0.81
4.3.2 EfficiencyofFilteringStrategies. Thefilteringphaseisvery
important in the whole clone detection. We have implemented the
heuristic filtering strategies and the results of filtering efficiencyare shown in Table 4. The filtering ratio refers to the number of
PDG pairs after filtering divided by the number of total PDG pairs.
It can exclude the majority of candidate PDG pairs and helps to
accelerate the graph matching process later.
To ensure the accuracy of our filtering strategies, we conducted
a sample check on the filtered PDG pairs. We randomly selected20 PDG pairs for three times from the filtered PDG pairs of each
dataset, and determine the number of clone pairs misfiltered in the
20PDGpairs.AccordingtotheresultsshowninTable5,thenumber
of ourmisfiltered clone pairsis verysmall, which alsoverifies the
effectiveness of our filtering strategies.
4.3.3 ResultsofCodeCloneDetection. WeevaluateCCGraphwith
the total clone quantity, clone quality, time cost, and scalability.
The total clone quantity is the total number of clone pairs detected
by tools, which is shown in Table 6. The clone quality includes
the precision,recall rate,and the F1-scorewe calculated,which is
shown in Table 7 and Table 8. The total clone result used in the
recallrateistheunionoftheresultsgeneratedbyalltools.Also,we
comparethe timecostofthewholeclone detection processwithTable 4: Efficiency of Filtering Strategies on Datasets
Datasets LanguageTheoretical PDG pairs Ration of
PDG pairs after filtering filtering
(A) (B) (B/A)
Less C 81796 1316 1.61%
PostgreSQL C 1285956 22247 1.73%
Artificial-1 C 10000 562 5.62%
Aritificial-2 C 147456 2708 1.84%
Datasets LanguageTheoretical PDG pairs Ration of
PDG pairs after filtering filtering
(A) (B) (B/A)
BCB-5 Java 34596 596 1.72%
BCB-11 Java 114244 1805 1.58%
BCB-15 Java 228484 3309 1.45%BCB-38 Java 231361 3424 1.48%
Table 5: The Number of Misfiltered Clone Pairs of 3 Sam-
pling Examinations
Datasets Language1st 2nd 3rd
experiment experiment experiment
Less C 0/20 0/20 0/20
PostgreSQL C 0/20 1/20 0/20
Artificial-1 C 0/20 0/20 0/20
Aritificial-2 C 0/20 0/20 0/20
Datasets Language1st 2nd 3rd
experiment experiment experiment
BCB-5 Java 0/20 0/20 0/20
BCB-11 Java 0/20 1/20 0/20
BCB-15 Java 0/20 0/20 0/20
BCB-38 Java 0/20 0/20 1/20
CCSharpandmeasurethescalabilityondatasetsofdifferentscales,
which results are shown in Figure 5 and Table 9.
The total number of clones. We generate PDGs and detect clones
in function granularity. We measure the total number of clones by
the number of clone pairs against other tools. In the PDG filtering
stage, we exclude those codes in which the number of lines is less
than 6. And from the clone results shown in Table 6, we know that
CCGraphhasobviousadvantagesinthenumberofclonepairsthan
CCSharp [9] in all ğ¶datasets and Oreo [15] in all ğ½ğ‘ğ‘£ğ‘datasets.
As shown in Table 6, our approach can find more than twice as
many PDG-based clone pairs on Artificial-2 dataset as CCSharp.
Andevenintheworstcase,wecanfind30percentmorePDG-based
clonepairsthanOreo.Thereasonisthatweadopttheapproximate
graph matching, reduce the requirement of clone matching, and
find some clone pairs missed by other tools.
Clonequality. Clonequality includesprecision,recallrate, and
F1-scorevalue.Andwechoosethosesmallcodedatasetstomake
it easier to calculate the precision and recall rate. For precision, we
manuallycheckandevaluateallthedetectedclonepairstojudgeif
they are real clones, and calculate the ratio of all true positive code
938CCGraph: a PDG-based code clone detector with approximate graph matching ASE â€™20, September 21â€“25, 2020, Virtual Event, Australia
05101520253035
Less PostgreSQL Artificial-1 Artificial-2
CCSharp CCGraph
(a) In preprocessing stage(min)0246810121416
Less PostgreSQL Artificial-1 Artificial-2
CCSharp CCGraph
(b) In graph matching stage(s)
Figure 5: Time cost comparison between CCSharp and CCGraph
Table 6: The Number of Clones Detected by CCGraph
Against Other Tools
Dataset Language CCSharp CCGraph
Less C 12 23
PostgreSQL C 149 297
Artificial-1 C 105 183
Artificial-2 C 74 162
Dataset Language Oreo CCGraph
BCB-5 Java 47 76
BCB-11 Java 129 161
BCB-15 Java 75 138
BCB-38 Java 102 131
clones to all clones we detected.
ğ‘ƒğ‘Ÿğ‘’ğ‘ğ‘–ğ‘ ğ‘–ğ‘œğ‘› =ğ‘‡ğ‘ƒ
ğ‘‡ğ‘ƒ+ğ¹ğ‘ƒ
where ğ‘‡ğ‘ƒisthetruepositivePDG-basedcodeclonesreportedby
the tool, and ğ¹ğ‘ƒrefers to the wrong clone pairs we detected. For
recall rate, we define
ğ‘…ğ‘’ğ‘ğ‘ğ‘™ğ‘™ =ğ‘‡ğ‘ƒ
ğ‘‡ğ‘ƒ+ğ¹ğ‘
where ğ‘‡ğ‘ƒis the same as precision definition, ğ¹ğ‘refers to the
true clone pairs we missed, and the denominator ğ‘‡ğ‘ƒ+ğ¹ğ‘is the
union result of the two tools as the total detected clones (removing
duplicate and ğ¹ğ‘ƒelements). We also define
ğ¹1âˆ’ğ‘ ğ‘ğ‘œğ‘Ÿğ‘’ =2âˆ—ğ‘ƒğ‘Ÿğ‘’ğ‘ğ‘–ğ‘ ğ‘–ğ‘œğ‘› âˆ—ğ‘…ğ‘’ğ‘ğ‘ğ‘™ğ‘™
ğ‘ƒğ‘Ÿğ‘’ğ‘ğ‘–ğ‘ ğ‘–ğ‘œğ‘› +ğ‘…ğ‘’ğ‘ğ‘ğ‘™ğ‘™
From the results shown in table 7 and 8, we find that our results
are slightly less than CCSharp and Oreo in accuracy when we also
maintain a high level of accuracy which is acceptable in reality.
ThelittlelossofaccuracyisbecauseoftheexamplesthatthetwoPDGssharealmostthesamedataandcontroldependenciesintheir
structurebutthe functionoftheirprograms isobviouslydifferent.
ButourrecallrateissignificantlyhigherthanCCShrapandOreo.
In the best case, our recall rate is almost 40% higher than CCsharp
andOreo.Besides,wecalculatetheF1-scorevalue,andCCGraphis
at least 10% better than CCSharp and Oreo on each dataset.
Table 7: Clone Results on C Code Dataset
Datasets Tools Accuracy Recall F1-score
LessCCSharp 0.92 0.52 0.64
CCGraph 0.89 0.81 0.85
PostgreSQLCCSharp 0.99 0.56 0.72
CCGraph 0.91 0.85 0.83
Artificial-1CCSharp 0.94 0.63 0.75
CCGraph 0.90 0.80 0.85
Artificial-2CCSharp 0.99 0.42 0.59
CCGraph 0.92 0.81 0.86
Timecostandscalability. ConsideringthePDG-basedclonede-
tectionismoretime-consumingthanothertypesofclonedetection
tools and the time of training datasets in Oreo [15] is hard to mea-
sure,weonly comparethetimecostwithCCSharp[9]. Wedivide
the overall time cost into preprocessing and graph matching time
cost.AndthetimecostresultsareshowninFigure5.Theprepro-
cessingstageincludesPDGgeneration,structureoptimization,and
filtering. From the results shown in Figure 5, CCGraph reduces the
time cost both on preprocessing and graph matching stages and
accelerates the graph matching greatly than CCSharp [9].
Also, to ensure that CCGraph can be extended to larger code
datasetsthanCCSharp,wecomparetheruntimeofthetwotools
on datasets of different sizes. From the results shown in Table
9, CCGraph is much slower than the token-based detector Oreo
939ASE â€™20, September 21â€“25, 2020, Virtual Event, Australia Yue Zou, Bihuan Ban, Yinxing Xue, and Yun Xu
Table 8: Clone Results on Java Code Dataset
Datasets Tools Accuracy Recall F1-score
BCB-5SourcererCC 10.02 0.03
Deckard 0.22 0.35 0.27
Oreo 0.94 0.63 0.75
CCGraph 0.87 0.94 0.90
BCB-11SourcererCC 0.88 0.08 0.14Deckard 0.19 0.32 0.24
Oreo 0.96 0.73 0.80
CCGraph 0.96 0.91 0.93
BCB-15SourcererCC 0.75 0.03 0.05
Deckard 0.24 0.22 0.23Oreo 0.96 0.56 0.71
CCGraph 0.86 0.92 0.89
BCB-38SourcererCC 10.09 0.16
Deckard 0.29 0.30 0.29Oreo 0.98 0.66 0.79CCGraph 0.95 0.83 0.89
becauseofthehightime-consumingofgraphalgorithms.However,
CCGraph is faster than CCSharp, the PDG-based detector on all
datasets,anditcanalsorunnormallyonlarge-scaledatasets,while
CCSharp can not be extended to large-scale datasets at the levelof 50
ğ‘€lines of code. This also shows that CCGraph has better
scalability than CCSharp at least.
Table9:TimeCostofCCGraphandCCSharponDatasetsof
Different Sizes
LoC 10K 1M 10M 30M 50M
CCSharp 14s 1h12m3s 8h1m18s â€“ â€“
Oreo 2s 4m22s 24m12s 2h11m30s 4h36m12s
CCGraph 4s 15m10s 2h21m10s 7h22m12s 17h48m21s
5 RELATED WORK
Therehavebeenmanykindsofcodeclonedetectionmethodsinthe
literature, Rattan et al. [30] summarized many tools in his research.
Thesemethodscanbedividedintotext-based[31,32,33,34],token-
based[16,35,36,37],AST-based[38,39],PDG-based[5,9,41,42,
43], metric-based [44, 45, 46] and others like deep learning [22, 47,
48, 49].
Among the text-based code clone detections, the representative
work compared the code fragments in the form of text. Baker [31]
proposed a parametric matching algorithm, regarded the code line
asa longstring, andusedthe stringmatching algorithmtodetect
completelyconsistentcodeclones.NiCad[33]detectedthepoten-
tial code clones using the longest common string subsequencescomparison. Johnson [34] developed clone detection by a finger-
pringting technique. However, these clone detections based on the
textcanonlydetectthoseexactlythesamecodeclonesorclones
withhightextsimilarity.Consideringthevariouspracticalclonedetectionscenarios,theindustrypaysmoreattentiontoPDG-based
clone detections recently [30].
Amongthetoken-basedcodeclonedetections,theyextractedthe
tokensofsourcecodebylexicalanalysistoolsfirstlyandthencom-
paredthosetokensinsteadofkeywordssincetokenscantolerate
moredifferentidentifiers.CCFinder[35]isapopularclonedetector
based on token, but it does not support detecting the structural
similarityofcodefragments.CCAligner[17]isgoodatthoseclones
with relatively concentrated changes but it will miss many PDG-
basedclonesthatCCGraphcandetect.SourcererCC[38]performed
great in detecting format transformation and renaming changes,
butonlylimitedtothetokensimilarity.Thisalsomeansthatthey
are not suitable for the detection of PDG-based clones.
Among the AST-based code clone detections, CloneDR [39] and
Deckard [40] transformed the code into an abstract syntax tree
(AST)anddetectedthesimilarsubtreestofindcodeclones.Butthe
transformation lost much structure information of code and this
may lead to the missing of many code clones.
AmongthePDG-basedclonedetections.Duplix[41]andPDG-
DUP[42]bothdetectedPDG-basedclonesusingprogramslicing
andsubgraphisomorphismmatching.Andthesemethodsallsuf-
feredfromhightimeconsumingandmissedmanyclones,which
cannotbeappliedtolargescalecodedatasets.To improvethetime
performance,Sargsyanetal.[43]modifiedPDGgeneratedbyLLVM
through removing isolated nodes, GPLAG [5] used a lossy filter to
reduce the plagiarism scale by characteristic vectors, CCSharp [9]
proposedsomenewPDGmodificationandfilteringstrategie.How-
ever, these PDG-based clone methods only applied some simple
filteringstrategieandusedtheexactgraphmatchingalgorithmlikesubgraphisomorphismtodetectPDG-basedclones.Thesemethodsstillhaveunacceptabletimeconsumptionandpoorscalability.Also,
they have a big loss of code clones.
Among the metric-based clone detections, they extracted the
characteristicvectorsofsourcecodeandcalculatedthevectorsimi-larities to detect code clones. Patenaude et al. [44] divided the code
into different categories using the metrics. Balazinska et al. [45]and Mayrand et al. [46] both extracted the vectors from the ASTof source code. These methods based on metrics are very fast on
detectingclonesbuttheyhaveahighfalse-positiverateandmiss
many clones because of the rough comparison.
There also exist some other techniques for clone detection, such
asdetectionsbasedondeeplearningtechniquesandcodebehaviors.
Weietal.[47]proposedanapproachtolearntherepresentations
and Hamming distance of source code and detected code clones.
Whiteetal.[48]proposedamodeltodetectcodeclonesbylearning
the discriminating features of sourcecode. Yu [50] used a new tree-
based convolution to detect semantic clones, by capturing boththe structural information of a code fragment from its AST and
lexical information from code tokens. Oreo [15] and DeepSim [22]
used the clones that are almost identical or very similar to train
the deep learning model, the ability to detecting clones with large
differenceislimited.Thedeeplearningmethodsalwayshavetoo
much dependency on the training data and lack interpretability,
whichmaynotsuitableforsomespecialscenarios.Theexperiments
in Section 4 show that CCGraph can find more PDG-based code
clones than Oreo.
940CCGraph: a PDG-based code clone detector with approximate graph matching ASE â€™20, September 21â€“25, 2020, Virtual Event, Australia
6 LIMITATIONS
Therearealsosomelimitationstoourresearchwork.Onelimitation
isthattherearenoanyopenedandstandardbenchmarkdatasets
forPDG-based clonedetection methods.We cannot compareour
approachwithotherclonedetectorsonanyunifieddatasets.There-
fore, we need to perform our experiments on the code datasets
to manually verify the accuracy and recall rate of clone results.
Another limitationis that the existingPDG generators need tobe
improved. Now both of the PDG generations of C code and Java
code can only be suited to the compliable programs. This requires
thatthe testdatasets mustbe acomplete compilable programand
also limitsthe scopeof PDG-basedclone detection.Therefore, we
needtodevelopaPDGgeneratorforcodesegments.Inthisway,
our approach can be more widely processed.
7 CONCLUSION AND FUTURE WORK
In this paper, we propose a PDG-based clone detection work with
an approximate graph matching algorithm called CCGraph. We
introducethepreprocessingstagetooptimizethestructureofPDGs
and filter the scale of candidate clone pairs by a two-stage strategy.
Moreover,wedesigntheapproximategraphmatchingalgorithm
based on the WL graph kernel to detect the clone pairs. Finally, we
evaluateCCGraphwithclonequantity,clonequalityandscalability
againstOreo [15],andCCSharp[9].The experimentresultsshow
that our method performs better recall rate and F1-score value
while maintaining high accuracy.
Infuturework,weplantofurtherimprovetheperformanceof
CCGraph. And we will consider investigating the PDG generation
of more types of programming languages. Besides, we want tointegrate the CCGraph into code development and managementsystems. Meanwhile, we can develop some downstream applica-
tionsbasedonCCGraph,suchassoftwarestructureanalysis,bug
detection, and other software analysis applications.
ACKNOWLEDGMENTS
ThisworkissupportedbytheNationalNaturalScienceFoundation
ofChina(GrantNo.61672480andNo.61972373)andtheProgramfor
Excellent Graduate Students in Collaborative Innovation Center of
HighPerformanceComputing.TheresearchofDr.Xueissupported
by CAS Pioneer Hundred Talents Program.
REFERENCES
[1]Audris Mockus. 2007. Large-scale code reuse in open source software. In First
InternationalWorkshop onEmergingTrends inFLOSS ResearchandDevelopment.
IEEE, 7-7.
[2]Suresh Thummalapenta, Luigi Cerulo, Lerina Aversano, and Massimiliano
Di Penta. 2010. An empirical study on the maintenance of source code
clones.Empirical Software Engineering 15, 1 (2010), 1â€“34.
[3]Yun Lin, Zhenchang Xing, Xin Peng, Yang Liu, Jun Sun, Wenyun Zhao and
Jinsong Dong. 2014. Clonepedia: Summarizing code clones by common syntactic
contextforsoftwaremaintenance.In IEEEInternationalConferenceonSoftware
Maintenance and Evolution. IEEE, 341-350.
[4]Jingyue Li and Michael D. Ernst. 2012. CBCD: Cloned buggy code detector. InProceedings of the 34th International Conference on Software Engineering. IEEE
Press, 310-320.
[5]ChaoLiu,ChenChen,JiaweiHan,andPhilipSYu.2006.GPLAG:detectionofsoftware plagiarism by program dependence graph analysis. In Proceedings of
the 12th ACM SIGKDD international conference on Knowledge discovery and data
mining. ACM, 872â€“881.[6]StefanBellon,RainerKoschke,GiulioAntoniol,JensKrinke,andEttoreMerlo.
2007.Comparisonandevaluationofclonedetectiontools.IEEETransactionson
software engineering, 33(9), 577-591.
[7]DavidSJohnson.1987.TheNP-completenesscolumn:Anongoingguide. Journal
of algorithms, 8(2), 285-303.
[8]MarkGabel,LingxiaoJiangandZhendongSu.2008.Scalabledetectionofsemantic
clones. In Proceedings of the 30th international conference on Software engineering.
ACM, 321-330.
[9]MinWang,PengchengWang,YunXu.2017.CCSharp:Anefficientthree-phase
code clone detector using modified PDGs. In 24th Asia-Pacific Software Engineer-
ing Conference (APSEC). IEEE, 100-109.
[10]NavarinN,SperdutiA.2017.ApproximatedNeighboursMinHashGraphNode
Kernel.European Symposium on Artificial Neural Networks Computational Intelli-
gence and Machine Learning, ESANN, 281-286.
[11]Nino Shervashidze, Pascal Schweitzer, Erik Jan van Leeuwen, Kurt Mehlhornand Karsten M. Borgwardt. 2011. Weisfeiler-lehman graph kernels. Journal of
Machine Learning Research, 12(Sep), 2539-2561.
[12]Foggia Pasquale, Percannella G, Vento M. 2014. Graph matching and learning in
patternrecognitioninthelast10years. InternationalJournalofPatternRecognition
and Artificial Intelligence, 28(01), 1450001.
[13]Ya Jun, Liu Z S, Chang, Q. 2016. The network attack graph analysis based on
graph kernel. Journal of Military Communications Technology, Vol.37: 20-25.
[14]GaÃ¼zÃ¨re B, Brun L, Villemin D. 2011. Two New Graph Kernels and Applications
toChemoinformatics.In InternationalConferenceonGraph-basedRepresentations
in Pattern Recognition.
[15]Vaibhav Saini, Farima Farmahinifarahani, Yadong Lu, Pierre Baldi, and Cristina
Lopes. 2018. Oreo: Detection of Clones in the Twilight Zone. In Proceedings
of the 26th ACM Joint Meeting on European Software Engineering Conference
and Symposium on the Foundations of Software Engineering (ESEC/FSEâ€™18). ACM,
354â€“365.
[16]Krinke Jens. 2001. Identifying similar code with program dependence graphs. In
Proceedings Eighth Working Conference on Reverse Engineering. IEEE, 301-309.
[17]PengchengWang,JeffreySvajlenko,YanzhaoWu,YunXu,ChanchalKRoy.2018.
CCAligner: a token based large-gap clone detector. In Proceedings of the 40th
International Conference on Software Engineering. ACM, 1066-1077.
[18]WilliamWCohen,PradeepRavikumar,andStephenEFienberg.2003.ACom-
parison of String Distance Metrics for Name-Matching Tasks. IIWeb,Vol. 73-78.
[19]VanderLooandMarkPJ.2014.Thestringdistpackageforapproximatestring
matching.The R Journal 6.1, 111-122.
[20]Feigenbaum James. 2016. JAROWINKLER: Stata module to calculate the Jaro-
Winkler distance between strings.
[21]Ricardo Baeza-Yates and Berthier Ribeiro-Neto. 1999. Modern information re-
trieval.ACM press New York,Vol. 463..
[22]GangZhaoandJeffHuang.2018.Deepsim:deeplearningcodefunctionalsimi-
larity.InProceedingsofthe201826thACMJointMeetingonEuropeanSoftware
EngineeringConferenceandSymposiumontheFoundationsofSoftwareEngineering.
ACM, 141-151.
[23]Cuoq P., Kirchner F., Kosmatov N., Prevosto V., Signoles J. and Yakobowski B.
2012.Frama-c.In InternationalConferenceonSoftwareEngineeringandFormal
Methods. Springer,233-247.
[24]HigoYoshiki,andShinjiKusumoto.2011.CodeclonedetectiononspecializedPDGs with heuristics. In European Conference on Software Maintenance and
Reengineering. IEEE, 75-84.
[25]Gang Zhang, Xin Peng, Zhenchang Xing, and Wenyun Zhao. 2012. Cloning
practices: Why developers clone and what can be changed. In IEEE International
Conference on Software Maintenance (ICSM). IEEE, 285-294.
[26]Yun Lin, Zhenchang Xing, Yinxing Xue, Yang Liu, Xin Peng, Jun Sun. 2014.
Detecting differencesacross multipleinstances ofcode clones.In Proceedings of
the 36th International Conference on Software Engineering. ACM, 164-174.
[27]Jeffrey Svajlenko and Chanchal K. Roy. 2015. Evaluating Clone Detection Tools
withBigCloneBench.In Proceedingsofthe31stInternationalConferenceonSoft-
ware Maintenance and Evolution (ICSME 2015). IEEE, 131-140.
[28]Ambient Software Evoluton Group. (2013). IJaDataset 2.0. http://secold.org/
projects/seclone.
[29]SvajlenkoJeffreyandChanchalK.Roy.2016.Bigcloneeval:Aclonedetectiontool
evaluation framework with bigclonebench. In 2016 IEEE International Conference
on Software Maintenance and Evolution (ICSME). IEEE, 596-600.
[30]Rattan Dhavleesh, Rajesh Bhatia, and Maninder Singh. 2013. Software clone
detection: A systematic review. Information and Software Technology 55.7 (2013),
1165-1199.
[31]BakerBrendaS.1997.Parameterizedduplicationinstrings:Algorithmsandan
application to software maintenance. SIAM Journal on Computing 26.5 (1997),
1343-1362.
[32]Baker Brenda S. 1995. On finding duplication and near-duplication in large
softwaresystems.In Proceedingsof2ndWorkingConferenceonReverseEngineering.
IEEE, 86-95.
[33]Cordy James R. and Chanchal K Roy. 2011. The NiCad clone detector. In 2011
IEEE 19th International Conference on Program Comprehension. IEEE, 219-220.
941ASE â€™20, September 21â€“25, 2020, Virtual Event, Australia Yue Zou, Bihuan Ban, Yinxing Xue, and Yun Xu
[34]JohnsonJHoward.1994.SubstringMatchingforCloneDetectionandChange
Tracking.ICSM. Vol. 94, 120-126.
[35]Kamiya Toshihiro, Shinji Kusumoto, and Katsuro Inoue. 2002. CCFinder: a
multilinguistictoken-basedcodeclonedetectionsystemforlargescalesource
code.IEEE Transactions on Software Engineering 28.7 (2002), 654-670.
[36]ZhenminLi,ShanLu,SuvdaMyagmarandYuanyuanZhou.2004.CP-Miner:A
ToolforFindingCopy-pasteandRelatedBugsinOperatingSystemCode.OSdi.
Vol. 4. No. 19, 289-302.
[37]GÃ¶deNilsandRainerKoschke.2009.Incrementalclonedetection.In 200913th
European Conference on Software Maintenance and Reengineering. IEEE,219-228.
[38]HiteshSajnani,VaibhavSaini,JeffreySvajlenko,ChanchalK.RoyandCristina
V Lopes. 2016. Sourcerercc: Scaling code clone detection to big-code. In 2016
IEEE/ACM38thInternationalConferenceonSoftwareEngineering(ICSE). IEEE,1157-
1168.
[39]Ira D Baxter, Andrew Yahin, Leonardo Moura, Marcelo Sant Anna and Lorraine
Bier. 1998. Clone detection using abstract syntax trees. In Proceedings of the
International Conference on Software Maintenance. IEEE, 368â€“377.
[40]LingxiaoJiang,GhassanMisherghi,ZhendongSuandStephaneGlondu.2007.
Deckard:Scalableandaccuratetree-baseddetectionofcodeclones.In Proceedings
of the 29th International Conference on Software Engineering. IEEE Computer
Society, 96â€“105.
[41]Jens Krinke. 2001. Identifying similar code with program dependence graphs. In
Proceedings of Eighth Working Conference on Reverse Engineering. IEEE, 301â€“309.
[42]Raghavan Komondoor and Susan Horwitz. 2001. Using slicing to identify du-
plication in source code. In International Static Analysis Symposium. Springer,
40â€“56.[43]Sargsyan,Sevak,KurmangaleevS,BelevantsevAandAvetisyanA.2016.Scalable
and accurate detection of code clones. Programming and Computer Software 42.1
(2016), 27-33.
[44]J-FPatenaude,EttoreMerlo,MichelDagenais,andBrunoLaguÃ«.1999.Extending
software quality assessment techniques to java systems. In Proceedings of the 7th
International Workshop on Program Comprehension. IEEE, 49â€“56.
[45]Magdalena Balazinska, Ettore Merlo, Michel Dagenais, Bruno Lague, and Kostas
Kontogiannis. 1999. Measuring clone based reengineering opportunities. In Pro-
ceedings of the 6th International Software Metrics Symposium. IEEE, 292â€“303.
[46]ManishankarMondal,ChanchalKRoy,andKevinASchneider.2015.Acompara-
tivestudyonthebug-pronenessofdifferenttypesofcodeclones.In Proceedingsof
the IEEE International Conference on Software Maintenance and Evolution (ICSME
15).IEEE, 91â€“100.
[47]HuihuiWeiandMingLi.2017.SupervisedDeepFeaturesforSoftwareFunctionalCloneDetectionbyExploitingLexicalandSyntacticalInformationinSourceCode.
InProceedingsof the26thInternationalJoint ConferenceonArtificial Intelligence
(IJCAI 17). 3034â€“3040.
[48]MartinWhite,MicheleTufano,ChristopherVendome,andDenysPoshyvanyk.
2016.Deeplearningcodefragmentsforcodeclonedetection.In Proceedingsof
the31stIEEE/ACMInternationalConferenceonAutomatedSoftwareEngineering.
ACM, 87â€“98.
[49]Heejung Kim, Yungbum Jung, Sunghun Kim, and Kwankeun Yi. 2011.
MeCC:memory comparison-based clone detector. In Proceedings of the 33rd Inter-
national on Software Engineering. ACM, 301â€“310.
[50]HaoYu,WingLam,LongChen,GeLi,TaoXieandQianxiangWang.2019.Neural
detection of semantic code clones via tree-based convolution. In IEEE/ACM 27th
International Conference on Program Comprehension (ICPC). IEEE, 2019: 70-80.
942