The Impact of Generic Data Structures: Decoding the Role of
Lists in the Linux Kernel
Nic Volanschi
Inria Bordeaux - Sud-Ouest
Talence, France
eugene.volanschi@inria.frJulia Lawall
Inria Paris
Paris, France
julia.lawall@inria.fr
ABSTRACT
The increasing adoption of the Linux kernel has been sustained by
a large and constant maintenance effort, performed by a wide and
heterogeneousbaseofcontributors.Oneimportantproblemthat
maintainersfaceinanycodebaseistherapidunderstandingofcom-
plex data structures. The Linux kernel is written in the C language,
whichenablesthedefinitionofarbitrarilyuninformativedatatypes,
via the use of casts and pointer arithmetic, of which doubly linked
lists are a prominent example. In this paper, we explore the ad-
vantages and disadvantages of such lists, for expressivity, for code
understanding, and for code reliability. Based on our observations,
wehave developeda toolsetthat includesinference of descriptive
listtypesandatoolforlistvisualization.Ourtoolsidentifymore
than 10,000 list fields and variables in recent Linux kernel releases
andsucceedsintyping90%.Weshowhowthesetoolscouldhave
been used to detect previously fixed bugs and identify 6 new ones.
CCS CONCEPTS
•Software and its engineering →Automated static analysis ;
Data types and structures ;Software maintenance tools ;Soft-
ware reverse engineering ;Maintaining software .
KEYWORDS
Linux kernel, data types, genericity
ACM Reference Format:
NicVolanschiandJuliaLawall.2020.TheImpactofGenericDataStructures:
DecodingtheRoleofListsintheLinuxKernel.In 35th IEEE/ACM Interna-
tional Conference on Automated Software Engineering (ASE ’20), September
21–25, 2020, Virtual Event, Australia. ACM,NewYork,NY,USA,12pages.
https://doi.org/10.1145/3324884.3416635
1 INTRODUCTION
The Linux kernel is today a form of critical infrastructure, support-
ingbillionsofAndroidsmartphones,allofthetop500supercom-
puters,andmanycomputingdomainsinbetween.TheLinuxkernel
alsohasaverylargedeveloperbase,withover1000commitauthorscontributingtotherecentreleaseLinuxv5.6(March2020).Thesede-
velopershaveawiderangeofexperience,withfullyaquarter(285)
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACMmustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ASE ’20, September 21–25, 2020, Virtual Event, Australia
© 2020 Association for Computing Machinery.
ACM ISBN 978-1-4503-6768-4/20/09...$15.00
https://doi.org/10.1145/3324884.3416635having no previouscommit to the Linux kernel. Atthe same time,
the Linux kernel is self-contained, relying on no external libraries,
meaning that developers cannot apply their previous experience
to understanding its abstractions and data types. Indeed, the Linux
kerneldefinesits ownlibrariesofdatatypesthat meettheunique
needs of an OS kernel in terms of efficiency (e.g., cache locality),
flexibility, synchronization, and ease of use in typical OS-kernel
usage contexts.
One Linux kernel data type is that of a doubly-linked list. Such
lists are used for collecting all kinds of information: waiting pro-
cesses,availabledevices,messages,andsoon.TheyareverywidelyusedintheLinuxkernel,appearinginover6400files,andalsoserveasabasisformorecomplexdatastructuressuchastrees.Linuxlistsfurthermorehavesomefeaturesthatobscuretheirpurposeandmay
surprisedevelopers.Theyareimplementedbyasingledatatype,
list_head ,thatisusedtorepresentboththeheadofthelistandto
connectallofthelistelements.This list_head typefurthermore
offersonly prevandnextfields,forreferringtothepreviousand
next list_head s, respectively, but no field pointing to the element
value. Instead, the element must be implemented as a structure
that embeds a list_head structure, which serves as a connector
totherestofthelist.Asaconsequence,a list_head structureis
associated with no type information about the list elements.
The features of Linux lists provide conciseness, efficiency and
flexibility.Thereisonlyonelistdatatypeandonlyonesetoflistop-erators, regardless of the number of types of elements. Some of the
operatorsarefurthermorecarefullydesignedtoprovideatomicity
guarantees,thus potentiallypreventingsome hard-to-understand
concurrency bugs. The fact that the list_head structures are em-
bedded in list elements may allow the connector to be in the same
cachelineassomeelementvalues,improvingperformance.Interms
of flexibility, any list_head structure can be placed at the head of
orasanelementconnectorinanylist.Asingle list_head variable
can be used to store lists of different element types at different
placesinthecode.A list_head structurecanchangerole,frombe-
ingalistheadtoconnectinglistelements.Still,whilethesefeatures
maybeveryconvenientforexperiencedLinuxkerneldevelopers,
theymaymakeitverydifficultfordevelopershavinglessexperi-encewiththeLinuxkernelcodetounderstandtherole(listhead
or list-element connector) of list_head -typed variables and struc-
turefields,orfromalistheadtoknowwhattypeofelementsthe
referenced list contains.
In this paper, we propose a type system and a toolset, LiLiput
(Linux Lists program understanding toolset), to automatically infer
the role and element type associated with Linux kernel list_head
structures. Our approach relies on examination of how a given
list_head structure is used by the various operators of the Linux
1032020 35th IEEE/ACM International Conference on Automated Software Engineering (ASE)
listAPIthatdifferentiatebetweenlistheadsandlistelementconnec-
tors, and imply relationships between them. We have used LiLiput
to identify the roles (list head or list element connector) and list
element types of 90% of the list_head type variables and struc-
turesinLinuxkernelversionsv3.0(July21,2011)tov5.6(March29,
2020), demonstrating the versatility of the approach. The collected
information furthermore permits detecting bugs where list_head
structuresareusedaccordingtothewrongrole,whichcanresult
inlossofdata.Specifically,LiLiputwouldhaveenableddetecting
8 previous bugs in Linux list usage, and detects 6 new ones. Ourpatches for the latter have mostly been approved by the Linux
kernel maintainers.
Our main contributions are:
•WeshedlightontheproblemofunderstandingLinuxlists,
whichmayconstituteanobstacletosmoothmaintenance;in-
deed,weshowthatLinuxlistsarewidelyusedandpowerful,
but poorly documented.
•As a solution to this problem, we propose a toolset called
LiLiput for inferring the types of Linux lists and for quickly
achieving a global view of the involved data structures, thus
facilitating maintenance.
•We validate our solution by demonstrating its effectiveness
(roughly 90%), and further illustrating several possible uses
of these types, including discovering list programming tech-
niques and bugs.
Therestofthispaperisstructuredasfollows.Section2briefly
introducestherichworldofLinuxlists,andquantifiesthelackof
documentationabouttheiruses.Section3presentsoursolutionfor
facilitatingtheunderstandingoflistusesandSection4describes
its prototype implementation. Section 5 presents the validation of
our solution,by showing itsresults onseveral Linux versionsand
severalpossibleusesoftheresults.Section6situatesthisworkwith
respect to other approaches, and Section 7 concludes and discusses
future work.
2 LINUX LISTS
In this section, we first give an overview of the Linux list API,
then present the history of this API in the Linux kernel, and finally
highlight some advantages and disadvantages of its design.
2.1 API
TheLinuxlistAPIcomprisesthe list_head structuretypeanda
large set of list-related operators. The list_head type is defined
ininclude/linux/types.h and is shown in Figure 1.1It contains
prevandnextfields,pointingtothepreviousandnextlistelements,
thus implementing adoubly linked list. It containsno field for the
list element. Instead, an element is also represented as a structure,
of sometype, andembeds a list_head structure amongits fields.
The list operators are defined in include/linux/list.h .Ar e p -
resentative subset of these operators is shown in Table 1. These
operatorsallowtraversinglists(lines1-4),accessinglistelements
(lines 5-7), testing list elements (line 8), adding elements to lists
(lines9-11),andnumerousotherfunctionalitiesthatarenotshown.
1All code examples are taken from Linux v5.6 unless stated otherwise, and can be
obtained from https://www.kernel.org/.1struct list_head {
2 struct list_head *next , *prev;
3};
Figure 1: list_head structure type
1struct hiddev {
2 int minor;
3 ...
4 struct list_head list;
5 spinlock_t list_lock;
6 ...
7};
8
9struct hiddev_list {
10 struct hiddev_usage_ref b uffer[HI DDEV_BUFFER_SIZE];
11 ...
12 struct list_head node;
13 ...
14};
Figure 2: hiddevstructure type
A typical use of the Linux list API is found in the hiddevdevice
library.ThisdevicelibraryprovidesanAPIfordescribinghuman
interface devices, a category of USB devices.2The list involves two
kindsofstructures,definedinFigure2.Theheadofthelist i.e.,a
list_head structurepointingtothelist’sfirstandlastelements,is
embedded in a hiddevstructure (lines 1-7) in the listfield. The
elementsofthelistarerepresentedbystructuresofanothertype,
hiddev_list (lines9-14).Thelattertypealsoembedsa list_head
structure, in the nodefield, connecting the element to the previous
and subsequent ones. We say that hiddev.list is the list head,
hiddev_list isthetypeofthe list element,and hiddev_list.node
isthe list connector.Notethatwhileinthisexample,theheadofthe
list isalso embedded ina structure, that isnot the onlypossibility.
A list head can also be a simple variable of type list_head . For
instance, the file system infrastructure ( fsdirectory) maintains
a list of block devices in the global variable all_bdevs of type
list_head, declared in fs/block_dev.c.
Inpractice,itischallengingtounderstandtherelationshipbe-
tweenthevariousstructuretypesinvolvedinalist.Inthecaseof
thehiddevlist, the structure types are defined in different files,
i.e.,include/linux/hiddev.h forhiddevanddrivers/hid/usb-
hid/hiddev.c forhiddev_list .Therearenocommentsinornear
these definitions indicating which structure type represents the
list head or the list elements, or connecting the one structure type
to the other. Some information can, however, be inferred fromthe use of the various standard list operators on the
list_head
typed fields, hiddev.list andhiddev_list.node . For instance,
thelist_add_tail operatorisusedtoadda hiddev_list.node
elementtoa hiddev.list head.The hiddev_list elementsinthis
list are traversed using a list_for_each_entry , and so on. Based
on the information obtained from this manual inspection of the
2https://en.wikipedia.org/wiki/USB_human_interface_device_class
104Table 1: A representative subset of standard list operators, defined in the C header file <include/linux/list.h >.
Operator Meaning
list_for_each_entry(c, l, f) traverses a list headed at lcontaining elements of structure type s, linked via their field s.fof type list_head ; the traversal
uses a cursor c(of type s) as the current list element
list_for_each_entry_safe(c, c’, l, f) like list_for_each_entry(), but allows modifying the list (e.g., by removing elements), without losing the cursor c, by using an
extra cursor variable c/prime
list_for_each(c, l) traverses a list headed at lcontaining elements of any type of structures; the traversal uses a generic cursor c(of type
list_head); offers an untyped traversal, with respect to the operators above
list_for_each_safe(c, c’, l) like list_for_each(), but allows modifying the list, by using an extra cursor variable c/prime
list_first_entry(l, s, f)returns the first/last element of a list headed at lcontaining elements of type s, linked using the field s.fof type list_headlist_last_entry(l, s, f)
list_entry(p, s, f) returns the list element or head of type s, given a pointer pto its field s.fof type list_head
list_is_first(e, l), list_is_last(e, l) tests whether e(a pointer to a list_head) is the first/last element of the list headed at l
list_add(e, l’), list_add_tail(l, l’) adds a new first/last element eto the list headed at l
list_splice(l, l’) splices the list headed at lat the beginning/end of the list headed at l/prime; this consists in adding all the elements in l, but not the
head list_splice_tail(l,l’)
code, we can infer that Figure 3 illustrates an example of a typi-
calhiddevlist. Nevertheless, the relevant information is widely
dispersed in the source code.
next
prevhiddev
list_head
list
nextprevhiddev_list
list_head
node
nextprevhiddev_list
list_head
node
Figure 3: A typical list, headed at hidlist.list and containing
hiddev_list elements connected by their node field.
2.2 History
The current Linux list API was first introduced into the Linux
kernelinLinux2.1.45,releasedinJuly1997.TheAPIwasoriginally
onlyusedinthreefilesrelatedtofilesystems.Itreplacedanother
implementationofdoublylinkedlistsbasedentirelyonmacrosthat
generatedlistoperationsforspecificdatatypes,accordingtothe
types and field names mentioned in the macro arguments. The APIintroducedinLinux2.1.45includedthe
list_head type,macrosfor
declaringandinitializing list_head variables,andthefunctions
or macros list_add ,list_del ,list_empty ,list_splice , and
list_entry.
Figure 4 illustrates the use of lists over time, from their intro-
ductionuptothecurrentreleaseatthetimeofwriting(v5.6).We
have focused on the number of calls to the two operators for list
insertion, list_add andlist_add_tail ,astomakealistitisnec-
essary to add elements to it. Over time, many of the new uses of
theselistoperatorshavebeenincodethataddsnewfunctionalities,
but there are also instances where uses of other ad hoc forms of
lists have been converted to use the standard API.3As can be seen,
3Examples:68a2d76cea423,cdcdbe0b179a,df0933dcb027,5b1a960d180e,availableat
git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git
1998
19992000
2001
200220032004
2005
200620072008
2009
201020112012
2013
201420152016
2017
20182019202002,0004,000callslist_add_tail
list_add
Figure 4: List usage in Linux versions v2.1.45-v5.6
therehasbeenasteadyincreaseintheuseofthestandardLinux
list API, and this is likely to continue in the future. Therefore, a
techniqueforhelpingmaintainerstounderstandlistsmayprove
more and more useful.
2.3 Documentation of list_head structures
Asillustratedbythe hidddevstructureconsideredinSection2.1,
fields of type list_head are frequently not documented by appro-
priatecomments,makingitnecessarytocollectinformationfrom
the code to understand what kinds of data structures they repre-
sent. To gain a more precise estimate of how often documentation
is missing, we have builta code search tool finding all list_head
structure fields and their associated comments. The search tool
has been implemented with Coccinelle [ 8,14] (more details about
Coccinelle will be given in Section 4). It searches for comments on
a field before, after, and in the middle of the field declaration, as
well as summary “kerneldoc” comments before the entire structure
declaration.
ByapplyingthistooltothewholeLinuxkernel,wefoundatotal
of 8837 list_head fields in Linux v5.6, among which 3237 have
at least one comment, amounting to 36%. This number has heldsteady since Linux v3.0 (July 2011), remaining between 35% and
39%, despite the number of such fields almost doubling in this time
period. Moreover, by manually inspecting a small sample of the
commentsfoundadjacenttostructurefielddeclarations,4wefound
that less than 15% of these comments provide the complete list
information, while the other 85% provide only partial information,
lackingeithertheroleofthefield(listheadorlistelement)orthe
related list_head field in the other structure. Consequently, we
4Included in the supplementary material, file ManualInspectionComments.xlsx.
105estimate that less than 10% of the list-related fields are thoroughly
documented by comments at the point where they are declared.
Thislackofdocumentationhasseveralconsequencesforcode
maintenance.Firstly,itmakesithardtogainaglobalviewofthe
data structures used, when these structures are involved in lists.
This difficulty is exacerbated in structures or sets of structures that
heavily use lists, such as a task descriptor ( task_struct ), contain-
ing 15 list_head -typed fields. In Linux v5.6, there are indeed 5
structure types that contain more than 12 list_head -typed fields.
Secondly, missing documentation increases the risks of errors dur-
ing development, and increases the difficulty of spotting the corre-
spondingbugsduringmaintenance.Wehypothesizethatvarious
errors related to the list API may be favoured by missing or incom-
plete list information, including, for instance, using a list head as a
listelement,orviceversa,andextracting,accessing,orinsertingthe
wrongtypeofelementsfrom/intoalist.OurevaluationinSection5
will test this hypothesis.
3 INFERRING LIST TYPES
Giventhe challengesinunderstandingthe usesofLinux lists,our
aimistoassistthisunderstandingwithanautomatedtool,inorder
to simplify the development and maintenance of code using this
data structure.
When maintainers examine a non-documented structure field
declaredtohavetype list_head ,theyfacetwoquestionsattwo
different levels:
roleis this field used as the head of a list or as a list element?
typingdepending on the role of the field:
•for a list head: this list contains what type(s) of elements?
•for a list element: from what list heads is it reachable?
Similarquestionsariseforvariablesoftype list_head .While
variablestypicallyserveinthelistheadrole,astheydonotcontain
anyotherdatatorepresentalistelement,wewillseethatthereare
caseswheretheyareinsertedaselementsintootherlists.Moreover,
even when the role of a variable is clearly a list head, the question
aboutthetypeofitselementsremains.Therefore,wewillusethe
generic term of list name to describe either a structure field or
a variable of type list_head . Moreover, list names also include
structurefieldsoftypepointerto list_head andstructurefieldsor
variablesoftypearrayof list_head .Inthelattercase,weattribute
the same type to all the elements in the array.
Wenowintroducethefollowingnotations.Weusetheletter sfor
astructuretype(thenameofa structtype),theletter fforastruc-
ture field name, the letter vfor a local or global variable name, the
letterxfor any C expression, and the letter lfor a list name of any
kind, including a structure field name of the form s.for a variable
namevof type list_head . Using these conventions, we will note
l:l/primethe statement “list name lis the head of a list whose elements
are list names l/prime”. For example, s.f:s/prime.f/primemeans that structure
scontains, via its list_head fields.f, a list of structures s/prime, con-
nected via their own list_head fields/prime.f/prime. Thus, the type of the
list in Figure 2 can be noted as hiddev.list :hiddev_list.node .
3.1 Typing rules
Ourtypingrulesarebasedonthesemanticsofhowthestandardlistoperators use
list_head s and related values. Note that developers
v3.0
v4.0v5.0
v5.605,00010,000list_headsall typed used but untyped unused
Figure 5: Overview of typing results
cancircumventthestandardlistoperators,byaccessingthe prev
andnextfields of a list_head structure directly. We choose to
build our typing rules by only taking into account standard list
operators, because they constitute a finite set of code patterns, and
are thus amenable to automation. They are also very frequently
used. Still, this limitation may result in failing to type some list
names.Section5(specifically,Figure5)willexaminetowhatextent
this strategy is an issue in practice.
Table 2 shows the typing rules corresponding to some uses of
standard list operators. The first column defines code patterns rep-
resenting specific uses. Some patterns may impose a condition on
the pattern variables, specified in a ‘where’ clause. The second col-
umn (“Strict typing”) shows the typing information that can beinferred based on the use pattern. The third column will be de-
scribed in Section 3.3. Note that the table is defined in terms of the
notation defined above. For example, a reference to s.fmeans a
reference to the ffield of an sstructure, regardless of how that
referenceisexpressedinthesourcecode.Suchinformationcould
beobtainedbysomecombinationoftypeinferenceanddataflow
analysis, but our typing rules are independent of the means by
which this information is obtained.
ThefirstfoursectionsinTable2concernvariouslisttraversalop-
erators. Traversals use a cursor variable pointing either to a whole
elementstructure(sections 1-2)ortoonly the list_head connec-
torembeddedinthatstructure(sections3-4).Theformerstyleof
traversal givescomplete typeinformation aboutthe traversedlist,
including its head, the type of its elements, and the specific field
within those elements that connects them together. For instance,
thetraversal list_for_each_entry(s, l, f) ,indicatesnotonly
thatlisalisthead,butalsothatthislistcontainselementsoftype s
(the type of structure pointed to by the cursor variable), connected
throughtheirfield s.f(thefieldnamespecifiedasthethirdargu-
ment).Thelatterstyleoftraversaloperators(sections3-4)doesnot
independentlybringanyusefultypinginformation,astheopera-
torsuseonlyageneric list_head cursor.However,eveninsuch
generic traversals it is common to access the element, via a call to
list_entry ontheloopcursor,inthebodyoftheloop.Inthiscase,
we can recover the same information as in the first two sections.
Sections 5-6 in the table concern access operators on list el-
ements: from the list head and from the list connector, respec-tively. An access from the list head, such as via
list_first_en-
try, offers complete type information. An access from a list con-
nector to the surrounding list element, via list_entry ,o nt h e
other hand, provides no type information, since it does not involve
both the list head and the list element. However, a call of the form
list_entry(s’.f’.next, s, f) revealsthetypesoftwoneigh-
bourelements.Iftheaccessedfieldsaredifferent(hencethe where
106Table 2: Typing rules based on list operator usage patterns.
Code pattern Strict typing Permissive typing
1. list_for_each_entry(s, l, f)
l : s.f l:Lwhere s.f∈Llist_for_each_entry_continue(s, l, f)
list_for_each_entry_reverse(s, l, f)
list_for_each_entry_continue_reverse(s, l, f)
list_for_each_entry_from(s, l, f)
list_for_each_entry_from_reverse(s, l, f)
2. list_for_each_entry_safe(s, s, l, f)
l : s.f l:Lwhere s.f∈Llist_for_each_entry_safe_from(s, s, l, f)
list_for_each_entry_safe_continue(s, s, l, f)
list_for_each_entry_safe_reverse(s, s, l, f)
3. list_for_each(v, l) { ... list_entry(v, s, f) ... }l : s.f l:Lwhere s.f∈Llist_for_each_prev(v, l) { ... list_entry(v, s, f) ... }
4. list_for_each_safe(v, v’, l) { ... list_entry(v, s, f) ... }l : s.f l:Lwhere s.f∈Llist_for_each_prev_safe(v, v’, l) { ... list_entry(v, s, f) ... }
5. list_first_entry(l, s, f)
l : s.f l:Lwhere s.f∈L list_first_entry_or_null(l, s, f)
list_last_entry(l, s, f)
6. list_entry(s’.f’.next, s, f)wheres’.f’/nequals.f s’.f’ : s.f s’.f’ : L’wheres.f∈Llist_entry(s’.f’.prev, s, f)
7. list_is_first(s.f, l), list_is_last(s.f, l) l : s.f l:Lwhere s.f∈L
8. list_add(l, l’), list_add_tail(l, l’)
l ’:l l ’:L ’where s.f∈L’ list_move(l, l’), list_move_tail(l, l’)
list_add_rcu(l, l’), list_add_tail_rcu(l, l’)
9. list_splice(l, l’), list_splice_tail(l,l’)l=l ’ l:L ,l ’:L ’where L/prime⊇Llist_splice_init(l,l’), list_splice_tail_init(l,l’)
condition), we have a list head and a list element, providing a com-
plete list type. On the other hand, when s’.f’ is the same as s.f,
the developer may simply be getting the next list element starting
from its predecessor element. Therefore, we cannot infer any type
information in this case.
Section 7 in the table concerns functions where one argument is
a list connector and another is a list head. In this case, we can infer
typeinformationifthelistconnectorcanbedescribedas s.f,based
on any available type and dataflow analyses. If the list connector isjustdescribedasanarbitraryexpressionofthe
list_head ,thenno
information can be inferred. Note that the operators of this section
are different from those in section 5, where the structure type s
and the field name fare separate arguments to the operator, thus
always providing typing information.
Sections 8-9 in Table 2 handle operators inserting elements into
a list. Section 8 concerns operators inserting individual list con-
nectors,eitherexternaltothelistormovedwithinthelist.These
operators involve both a list connector and a list head, so if the list
connector and the list head can be described as a list name, they
providecompletetypeinformation.Section9concernsoperators
splicing a whole list headed at linto a list headed at l/prime. This opera-
tordoesnotprovideinformationaboutthetypesoftheelements
in either list. However, the lists should normally have the same
elementtypes,becausethe list_head traversaloperatorsdonot
supportpolymorphiclists.Therefore,weaddanequality constraint
between the two types. As soon as some other operator uses allow
typing one of the lists, the other list will become typed, too.
3.2 Experience with the strict typing rules
When we applied the above typing rules to the whole Linux kernel
(Linux v5.6), we obtained 57 typing errors, where different types
wererequiredtobeunifiedtorepresentalistelementtype.Most
oftheseerrors,ho wever,are notprogrammingerrors,butratherfit
into one of the following categories.First,thereare(ab)usesofsomeoperatorsthatdonotcorrespond
totheirdocumentation,butthatworkfine.Forinstance,theoper-
ator list_first_entry(l, s, f) ,thatisdocumentedtoreturn
the first element of a list, is actually just a macro that expands
tolist_entry(l.next, s, f) . Consequently, this operator may
alsobeappliedtoalistelementtogetthefollowingelement.When
used this way, our type inference rule will wrongly try to type s.f
bothasalistheadandasalistelement.Anotherexampleistheuseof
list_add_tail ,whosesecondargumentisnormallyalisthead,
butthatcanalsobeusedtoinsertanelementbeforeanotherone,
e.g., to maintain a sorted list. In fact, most of the list operators can
be used in non-standard ways by inspecting their implementation.
Secondly, many functions define local list variables lthat are
used to collect e.g.a list of elements of some type s, that are con-
sumed in a loop, and then the same list variable is reused for alist containing another type of elements
s/prime. This is the case, for
instance,offunction _scsih_remove_unresponding_devices() ,
whichfillsalocalvariable headwith _sas_device structures,then
deletesthemall,andthendoesthesamewith _pcie_device struc-
tures. This kind of situation results in a type conflict between two
possible types l:s.fandl:s/prime.f/prime.
Thirdly, there are cases where the elements of the list may
be different structures depending on the actual managed device,firmware, that is used, etc. For example, this is the case in the
QualcommAtherosdriverforwirelessconnectivitydefinedindi-
rectory driver/net/wireless/ath/ath10k .Here,dependingon
whether the device version is greater than 10.4 or not, the struc-
ture ath10k_fw_stats contains in its field vdevsa list of either
ath10k_fw_stats_vdev orath10k_fw_stats_vdev_extd struc-
tures(linkedbytheirfield list).Thechoiceisdonedynamically
based on flags such as WMI_10_4_STAT_PEER_EXTD.
Finally, for a list stored in a structure field, there may be several
instances of this structure, where each instance contains the same
type of elements, but different instances contain different types
107of elements. The different instances are sometimes managed by
different functions in the code, specific to device version numbers.
All of these situations manifest as errors in our type system.
3.3 Permissive typing rules
Asthestricttypingrulesproducetoomanytypeerrorsthatturn
out to be false positives, we redesigned the typing rules so as to
infertypesthatcoveralltheexistingusesoflistsinthecode.For
instance, when encountering a list operator adding some structure
oftypestoalisthead lwithelementsthatarestructuresoftype
s/prime, we relax the type of lto allow elements of both types sands/prime.
We model the cases where a list name is used for containing
different types of list names using a disjunctive type l/prime:l1|...|ln.
Wewillnotewithletter Lsuchadisjunction.Thecorresponding
relaxed typing rules are given in last column of Table 2. Each strict
rule inferring type information of the form l/prime:lhas a relaxed
counterpartthatinfers l/prime:Lwherel∈L.Similarly,aruleinferring
a type equality constraint l=l/prime, such as the rules at the bottom
of the table, has a relaxed counterpart inferring a type inclusion
constraint l:L,l/prime:L/primewhereL/prime⊇L.
Asopposedtothestricttyping,therelaxedtypingrulesnever
leadtotypingerrors.Indeed,anyfinitesetoftypeinclusioncon-
straintshasatleastonesolution,forexample,typingeachlistname
toadisjunctionofalllistnames,includingitself.Moreover,ithas
a leastsolution, withrespect tothe type inclusionrelation, which
can be computed as a fixed point. Thus, the relaxed typing rules
compute for each list the least type permitting all of its uses.
The fact of never generating type errors is compatible with our
primary goal, that is, understanding the role and type of lists. The
only risk is that of resulting in types that are too general to be
useful. In the evaluation section, we find that computing the least
permissivetypesdoesnotpreventoursystemfrombeingusefulfor
indicating potential programming errors. Indeed, a developer may
have the intuition that a certain list head should refer to lists with
only one type of element, in which case, inferring a disjunctive
type for it might help spot a potential problem.
4 IMPLEMENTATION
We have implemented the permissive typing rules presented above
inaprogram-understandingtoolsetforLinuxlistscalledLiLiput.
LiLiput consists in two main tools, whose goals are, respectively:
List detection Afirsttoolfindsusesoflists:declarations(struc-
ture fields and scalar variables) and operations (standard list
functions and user-defined list functions). This tool outputs
a list usage report.
Type inference A secondtool inferstypes forthe listsbased
on their usage, starting from the list usage report. It outputs
a typing report.
Each tool provides a textual report that can be easily read, in-
spected, and amended if necessary, by developers. Moreover, we
show that these reports may also be exploited automatically by
other program understanding tools, for data structure visualisation
or interactive list usage inspection.
The list usage report containsasectionforeachlistname,con-
taining the list name followed by information about each use ofan operator that has an expression represented by the list nameamong its arguments. Arguments not related to lists, or whose list
name could not be uniquely determined, are abbreviated as ‘?’. For
instance,thefollowingsectiondescribestheusesofalocalvariable
deadof type list_head declared in the function exit_notify:
dead@exit_notify:
forget_original_parent(?, dead@exit_notify): kernel/exit.c:708
list_add(task_struct.ptrace_entry, dead@exit_notify):
kernel/exit.c:728
list_for_each_entry_safe(task_struct, ?, dead@exit_notify,
ptrace_entry): kernel/exit.c:735
Thefirstcallistoauser-definedlistoperator,andthenexttwocalls
are to standard list operators.
Thetyping report containsthetypeforeachlistnamewhosetype
could be inferred, as a disjunctive type of the form: l:l1|l2|...ln.
Forinstance,thefollowingexcerptgivesthetypeinferredforthe
local variable above:
dead@exit_notify: task_struct.ptrace_entry
Thefollowingexcerptgivesthetypeofthelocalvariablealready
mentioned in Section 3.2, used to contain first _sas_device struc-
tures, and then _pcie_device structures.
head@_scsih_remove_unresponding_devices:
_pcie_device.list | _sas_device.list
Wepresentthetwomaintoolsbelow,andthenbrieflypresent
two other program understanding tools that we have developed
based on the collected information.
4.1 List detection
Wecollectinformationaboutthedeclarationandusageoflistsusing
thetoolCoccinelle[ 8,14].Coccinelleisaprogrammatchingand
transformationtoolforCcodethathasbeenextensivelyusedon
the Linux kernel.Coccinelle allowssearching forpatterns ofcodeexpressedasfragmentsofCcodeparameterizedby metavariables.
Itdoesnotrequiremacroexpansion,butinsteadreliesonheuristics
to parse the C code in the presence of macros and ifdefs. It isthus independent of the chosen configuration options (ifdefs), of
whichtherearemanyintheLinuxkernel[ 23].Thisfeatureenables
covering over 99%of the 18.5 million linesof C source code found
in Linux v5.6. The use of Coccinelle also allows rapid prototyping
of complex code search rules. Nevertheless, there is a risk of some
omissions, either because the rule set is not complete or because
the parsing heuristics failed on some code. Nevertheless, for Linux
v5.6, the list detection tool finds information about 8,562 list-typed
structurefields,2,545list-typedvariables,and68,541functionoriterator calls having list-typed arguments, and thus we believe
that our Coccinelle scripts cover a very large percentage of the list
structures and operations found in the Linux kernel.
Collectionoftheinformationproceedsintwophases.Thefirst
phasecollectsinformationaboutstructurefieldsoftype list_head ,
pointerto list_head ,orarrayof list_head ,aswellasglobalvari-
ablesof anyof thesetypes,and localvariablesof type list_head
and array of list_head . We omit local variables of type pointer to
list_head ,becausethesetypicallycorrespondtotemporarypoint-
ers to elements of an existing list. The Linux kernel may declare
multiplestructuretypeswiththesamename,whichmayhavesomefieldsofthesamename.Asaheuristic,wekeepsuchfieldswhenalldefinitions of the structure have the same set of list-typed fields, as
108this often corresponds to different variants of a structure for differ-
ent variants of a device or different hardware architectures. On the
other hand, when two definitions of the same structure name have
a list-typed field that appears in both definitions, but the complete
set of list-typed fields defined by the two structures is different,
we discard the common list-typed field as being ambiguous, on
theassumption thatthefieldmay havedifferent rolesinthe two
structures. For Linux v5.6, we discard information about 20 vari-
ables andstructurefields, dueto ambiguity.The secondphase thencollectsinformationabouttheargumentsoffunctionsanditerators
that refer to the fields that were identified in the first phase. The
collection is implemented in 1250 lines of Coccinelle code. Most of
the code is due to the many variations in nested unions, structures,
etc., and is not challenging to write.
Thecollectionoffunctionsanditeratorsthathavelistarguments
does no dataflow analysis, neither across function calls nor within
functiondefinitions.Thisreducestheinformationavailableabout
lessthan2%offunctioncallsanditerators(Linuxv5.6).Itshould
be possible to reimplement the information collection phase ina dedicated program analysis framework such as LLVM to takesuchinformationintoaccount,althoughwiththeinconvenience
that such tools are sensitive to preprocessor configuration options.
For this work, we favored the rapid prototyping and high coverageadvantagesofCoccinelle,asLinuxkernelcodemoretypicallyrefers
to lists explicitly.
Our list detection tool misses 1) nameless struct declarations in
typedefs,2)namelessstructdeclarationsinvariabledeclarations,
and3)somestructurefieldsthataredeeplynestedinotherstruc-
tures and unions. 50 list_head structure fields out of 8837 are
overlooked in Linux v5.6 due to these limitations. Our tool runs on
Linux v5.6 in around 2 hours on a 44 core machine with Intel Xeon2.20GHzCPUsand251GBmemory,withthekernelsourcecodein
a memory-backed file system to eliminate the cost of disk accesses.
4.2 Type inference
The type inference tool takes as input the list usage report and out-
puts the typing report. As both these reports are textual, we chose
tocodethistoolinascriptinglanguageofferingrichpossibilities
of text processing, namely Perl. The implementation consists of
300linesofPerl,andisstraightforward.Itmaintainsamapfrom
list names to sets of list names, representing disjunctive types. The
map is computed as the fixed point of the constraints generatedby each permissive typing rule in Table 2. As a complement to
the typing report, it prints statistics about list usage, including the
total number of list names, the number of list heads, list elements,untyped list names, etc.
4.3 Other tools
The information computed in our reports can be exploited beyond
retro-documentingthelistdeclarations.Toillustratethisfact,we
have prototyped two extra tools in our toolset.
Firstly,avisualisationtooltakesthelisttypingreportasinput
and produces graphs of all the list data structures. This allows
maintainerstohaveaglobalviewoflistusageinagivenmodule
where lists are used extensively or to form particular patterns.
Indeed, we identified many instances of complex data structuresimplementedwithseverallists,suchassimplyanddoublylinked
trees of fixed or variable height. We also found header files and/or
structurescontainingmanylistfields.Forinstance,theheavilyused
header file include/net/devlink.h , included in 50 C and header
files, contains 16 list fields, among which 10 are defined in a single,
central structure called devlink.
Secondly, a list usage exploration tool takes the list usage report
asinput,andbuildsahypertext-basedlistingcontainingasubsetof
thedetectedlistusagescorrespondingtoafilteringcriterion.For
instance,onefilterthatprovedtobeusefulduringthedevelopmentofthelistusagereporttoolselectedallthelistoperatoruseswheresomelistargumentscouldnotbeuniquelydeterminedaslistnames
(abbreviated as ‘?’ in the report). This helped us to manually in-
spect complex list usage patterns, and discover some stereotypical
programmingtechniquesthatcouldberecognizedandleveraged
forimprovingthelistusagereports.Onesuchtechniquewasthe
complexpatternforgenericlisttraversalusing list_for_each ,de-
scribedinthethirdsectionofTable2,wherethetypinginformation
could be reconstituted from several related sub-patterns.
Moreover, this exploration tool could be extended to take as
additional input the typing report. This would allow performing
more complex searches, such as selecting all the list initializations
(using operator INIT_LIST_HEAD) acting on a list element instead
of a list head. Beyond our own use for tuning our analyses, the list
usageexplorationtoolmightbeusefulformaintainers,forexample
after fixing one bug to search for similar list misuses to fix.
5 EVALUATION
The primary goal of our evaluation is exploratory, to see what we
canlearnaboutlistusagefromtheinformationinferredbyourtype
system.Wealsoassesstheaccuracyoftheproducedinformation.
To meet these goals, we consider the following research questions:
RQ1:To what extent is our type inference system effective: are
the identified types the correct ones, and do all lists receive types?
RQ2:To what extent does our type inference system provide
added value, going beyond the information already available in the
comments and source code?
RQ3:What programming techniques for the use of lists are
revealed by the inferred type information?
RQ4:Whatkindsofbugscanbedetectedusingtheinferredtype
information,andhowhelpfularethetoolsprovidedwithLiLiput
in finding such bugs?
5.1 Effectiveness
To obtain a broad view of the effectiveness of LiLiput ( RQ1), we
applied it to all of the Linux kernel releases from v3.0 (March 2011)
tov5.6(March2020).Figure5presentsanoverviewoftheresults.
LiLiputfound5747listnamesinv3.0,andtheirnumberincreasedtoover10,000inv5.6.LiLiputcouldtypebetween87% and91%of
these list names in each kernel version.
Therearetwocasesinwhichalistnamedoesnotreceiveatype.
OnecaseiswhereLiLiputfindsalistdeclarationbutfindsnolist
operator,whetherstandardorspecial-purpose,thatisappliedtothe
list name. In this case, LiLiput reports that the list name is unused.
This is the case for 200-500 list names depending on the version,
109Table 3: Inferred list types
Experiment Typed Head Element Head &
(total) only only element
v4.19 86014797 (55.8%) 3600 (41.9%) 204 (2.4%)
v5.6 91255078 (55.6%) 3823 (41.9%) 224 (2.5%)
and2.9%ofthelistnamesfoundinLinuxv5.6.However,LiLiput
could wrongly flag a list name as unused if the list name is used
outsideoffunctioncalls.Wemanuallyinspectedasmallsample5
of cases involving list variables local to a file (which cover roughly
one third of the cases in v5.6), because it is easy to find all uses for
such cases. In this sample, we found a few false positives where
thelistsaremanipulatedwithoutusinganylistoperator,suchas
assigning them from, or comparing them to, other list variables.
In thesample, 87%of the listnames reportedas unusedwere true
positives, that is, the lists are indeed never used. This information
about unusedlists canbe usefulfor kernel developersin cleaning
up the code base.
Therearealsobetween6.4%and9.7%oflistnames(7.2%inLinux
v5.6) that are used with list operators but could not be typed, as
theydonotsatisfyanyofthelistoperatorpatternsinourtyping
rules (Table 2). This can occur when the list name is used by list
operatorswherenolistnamecanbeidentifiedforsomeoftheotherargumentsusedbythetypingrule, e.g.,whentheseotherarguments
are represented by local variables or function parameters. The
kerneldevelopermayneverthelessbenefitfromhavinginformation
about the uses of the list name summarized in the list usage report.
On this basis, some relationships not taken into account by thetype inference system, but known to the developer of a specificsubsystem,mayhelpthedeveloperidentifythepropertiesofthe
list structure.
Wefocusnowontworecentversions,Linuxv4.19(October2018)
and Linux v5.6 (March 2020), to give more detailed results.
Table3detailsthetypedlistnamesfoundinv4.19andv5.6by
presentingthedifferentkindsoftypesthathavebeeninferredfor
them.Ascanbeseen,abitlessthan60%oftheselistnamesplay
the role of list head, while a bit more than 40% play the role of list
elements.Thus,whilethereisalotofvariationinpractice,onaver-
age, a given type of list element is found in several lists (about 1.5).
Thistypicallycorrespondstothelocalvariablesthattemporarily
store elements, which are permanently stored elsewhere: either in
a heap data structure or in a global variable.
Apart from these simple cases where a list name is either a head
or an element, around 2.5% of the list names are both used as alist head and as an element in one or more lists. Table 4 further
subdivides this special case (by reproducing the “Head & element”
columninTable3),isolatingtwofrequentsub-patternsofsuchlists:
self-lists and mutual pairs. Self-lists are list names containing only
themselves: l:l. Mutual pairs are pairs of lists containing each
other, and nothing else: l:l/prime∧l/prime:l. These particular cases are
worth investigating, and are described later. The few remaining
cases (under 20) are more complex typing patterns, in which a list
name is used as a head but also as an element in several lists.
5Included in the supplementary material, file ManualInspectionUnused.xlsx.Table4:Usesoflistnamesthatservebothasalistheadand
as list elements
Experiment Hd & elm Self- Mutual Other
(total) lists pairs cases
v4.19 204 164 (80.4%) 11 (10.8%) 18 (8.8%)
v5.6 224 179 (79.9%) 13 (11.6%) 19 (8.5%)
5.2 Added value
Inthe absenceofour typesystem,developers canobtaininforma-
tion about lists from the documentation, typically comments in
the code, and from any naming conventions used in the code itself.
We thus next consider the degree to which our approach provides
added value ( RQ2), i.e., information that is not easily accessible to
the developer already.
In Section 2.3, we have already shown that lists are rarely docu-
mented.Basedonasampleof22Linuxv5.6 list_head structures6
thatareassociatedwithsomecomments,wehavealsofoundthat
whentheyaredocumented,thedocumentationisoftenincomplete.
Foronedocumentedfield(5%),LiLiputinferrednoinformation,andforanotherfield(5%)theamountofinformationinferredbyLiLiputisthesameastheamountofinformationintheassociatedcomment.
In all of the remaining cases, i.e., 20 out of 22 (91%), the informa-
tioninferredbyLiLiputwasconsistentwiththeexistingcomments
andwasmorecomplete.Forexample, struct vpe definedinfile
arch/mips/include/asm/vpe.h containsafieldnamed tcoftype
list_head , whose comment is “tc’s associated with this vpe”. This
suggests that vpe.tcis a list head, containing structures of type
tc, but does not indicate which is the connector field within tc.
Asstruct tc contains two list_head fields, the information in
thecommentisincomplete;itcouldberepresentedas vpe.tc : tc.?.
LiLiput infers the complete type information vpe.tc : tc.tc.
Based on the information inferred by LiLiput, we can further-
more check the correspondence between list names and the in-
ferred types. We studied the most frequent names of list fields and
found that the name ‘list’ is by far the most common one, covering
roughly 25% of the list fields. Our typing results show that struc-
ture fields named ‘list’ usually serve as list connectors (85%). This
leaves however a non-negligible fraction (15%) that are used as list
heads.Overall,thenamingconventionisnotfullyreliablefordistin-
guishing the role of list fields. On the other hand, the second most
frequent list field name is ‘node’ (5% of the list fields). Our types
show that this name is always used for identifying list connectors.
However,asonly5%ofthelistconnectorsfollowthisconvention,
the information inferred by LiLiput is overall still useful.
These results show that our type inference provides informa-
tionnotalreadyeasilyavailabletokerneldevelopers.Ourtyping
results can be used to improve the documentation about specificlist-typed variables and structure fields, and to retro-document
naming conventions.
5.3 Programming techniques
Studyingthecollectedtypeinformationrevealssomeinteresting
programming techniques used in manipulating lists ( RQ3). We
6Included in the supplementary material, file ManualInspectionComments.xlsx
110have seen in Section 3.2 that some list heads are associated with
more than one list element type (57 out of 5078 list heads (1.1%)
inLinuxv5.6),andinTable3thatsomelistheadsarealsousedas
listelements(2.5%ofalltyped list_head structuresinv5.6).Allof
these cases result in LiLiput inferring disjunctive types. These type
smells(analogous to code smells [ 4]) do not necessarily indicate
bugs. However, their uncommon nature may convey specific infor-
mation,whichmightbeworthinvestigating.Indeed,bystudying
samplesofeachofthesetypesmells,wewereabletouncoversome
list programming techniques.
A number of the disjunctive types (6 out of 57 in v5.6) contain a
local variableamong theelements. Thereare several listprogram-
ming techniques that involve adding a local list_head variable
to a list located in a structure field. A first technique, motivated
byconcurrency,consists inatomicallymovingalltheelementsin
the list towards a local list variable in bounded time while holding
a lock, and then liberating this lock and processing the elementsoutside of the critical section. This technique is illustrated in the
function gfs2_jindex_free ,whoselocalvariable listisinvolved
in the following disjunctive type:
gfs2_sbd.sd_jindex_list: list@gfs2_jindex_free | gfs2_jdesc.jd_list
This function clears all the journal index information contained
in the gfs2_jdesc elements, by first adding variable listin the
originallist,andthenremovingandemptyingtheoriginallisthead
using the operator list_del_init (this operator is normally used
forremovinglistelements,notlistheads).Thesequenceofthese
two operators is protected by a lock. After the lock is released, the
elements in the local variable listare consumed.
A secondtechnique involving localvariables is relatedto a par-
ticularkindoflists.Whilemostlistscompriseadistinctlistheadfol-lowedbyaseriesoflistelements,insomelists,allofthe
list_head
structuresareembeddedinstructuresofthesametypeandareused
in the same way. This results in a list type of the form s.f:s.f,
wherethelistheadandtheelementconnectorarethesamestruc-
ture field, amounting to a self-loop. We refer to such a list as aring. As the list traversal operators assume the existence of a list
head,whichshouldnotbetraversed,theseoperatorscannotbeused
with rings. To enable traversing a ring, a common programming
technique is to temporarily add a local variable of type list_head
withinthering.Thisvariable,usuallycalled‘head’,isusedtotra-
versealltheelementsinthering,andisthenremoved.Thistech-
nique results in a disjunctive list type such as the following, which
results from applying the technique in two different functions,
lpfc_bsg_ct_unsol_event andlpfc_ct_unsol_event , both of
which use a local variable named head.
lpfc_iocbq.list: head@lpfc_bsg_ct_unsol_event |
head@lpfc_ct_unsol_event | lpfc_iocbq.list
head@lpfc_bsg_ct_unsol_event: lpfc_iocbq.list
head@lpfc_ct_unsol_event: lpfc_iocbq.list
A ring can also be used to implement a doubly linked tree of
height one, which we refer to as an umbrella. An example of an
umbrellaisthewidelyusedkernelrepresentationofaperformanceevent,implementedinstructure
perf_event ,whosecomputedtype
is circular (a self-list):
perf_event.child_list: perf_event.child_listThis structure contains a list of other performance events that
are considered its children. For implementing this list, the samefield
child_list is used in the parent as a list head, and in the
childrenasaconnector.Unlikeinasimplering,eachchildinthe
umbrella points back to its parent using a different field ( parent
inperf_event ), while the parent points to itself. We found 20
umbrellas in Linux v5.6 by inspecting instances of self-loop types.
Listsarealsousedtoimplementtreesofarbitrarydepthofsome
structure s.Suchtreesusetwodifferentfieldsof s,onealwaysbeing
alisthead,andtheotherbeingtheconnectorbetweenthechildren.
An example of a tree is found, for instance, in a central data struc-
ture of the file system infrastructure, called dentry, representing a
directory entry, whose computed type is:
dentry.d_subdirs: dentry.d_child
Thus,any dentrycontainsinfield d_subdirs apossiblyemptylist
of children, and is part itself of a list via the distinct field d_child.
Thereare47such tree(s)typesinLinuxv5.6,i.e.,typesoftheform
s.f:s.f/primewheref/prime/nequalf. Theirnumber hasvaried between33 (in
v3.0) and 60 (in v4.14).
Finally, by studying several examples of mutual pairs, we found
another list programming technique. For example, the Marvell
Wireless LAN device driver contains two mutual pairs:
mwifiex_ra_list_tbl.list: mwifiex_tid_tbl.ra_list
mwifiex_tid_tbl.ra_list: mwifiex_ra_list_tbl.list
mwifiex_bss_prio_node.list: mwifiex_bss_prio_tbl.bss_prio_head
mwifiex_bss_prio_tbl.bss_prio_head: mwifiex_bss_prio_node.list
In fact, it is the second type of each pair that gives the correcttype: in both cases, the
listfield is used as a connector. The re-
verse type is due to a list programming technique used in function
mwifiex_rotate_priolists() that implements a round robin al-
gorithm. Namely, after a packet is successfully transmitted, both
listsarerotatedsothepacketnexttotheonetransmittedwillcome
first in the list. This is done by moving the list head right after the
transmittedpacket,usingoperator list_move .Basedonthisusage
notconformingtothedocumentation,ourtypingtoolinfersthat
the list head is an element of the list headed by its (real) element.
5.4 Bugs in list usage
While we have seen that some disjunctive types correspond to use-
ful programming techniques, others do correspondto bugs ( RQ4).
Forinstance,wemanuallyinspectedthecodecausingthefollowing
type:
spu_gang.aff_list_head: spu.aff_list | spu_context.aff_list
Theinspectionrevealedthattheonlycorrectelementtypeisthe
second one. The first element type (spu.aff_list) is only due to a
traversalofthelistheadwithacursorvariablethatisincorrectly
declaredtohavethetype‘spu’insteadof‘spu_context’.Incidentally,
thetraversalisonlycountingtheelements,sothisbugcurrently
hasnoconsequences,butitisalatentsourceoferrorsifsomeother
processing is added within the traversal body.
A common source of mutual pairs is a call to ‘list_add’ or ‘list_-
add_tail’withtheargumentsinthewrongorder.Indeed,bothargu-
mentstothesefunctionshavetype list_head andthedeveloper
has to remember that the first argument should be a list connector
and the second argument should be a list head. Not respecting this
111ordercanleadtoinformationlossandmemoryleaks,iftheargu-
ment provided as a list connector is actually a list head pointing to
a non empty list. One such case is the following mutual pair, in the
driver for the Phyter precision time protocol transceiver:
dp83640_clock.list : phyter_clocks
phyter_clocks : dp83640_clock.list
Here, the correct type is the second one: ‘phyter_clocks’ is a global
variablecontainingstructuresoftype‘dp83640_clock’.Theother
typeisduetoauseofthe‘list_add’operatorinwhichthearguments
arereversed,introducingtheglobalvariableasanelementinthelist
headed within thestructure, while the intention wasthe opposite.
Overall, we identified 6 bugs in Linux v5.6 based on type smells.
We have submitted patches for 5 of them. Four of these patches
have been approved by the Linux kernel maintainers. The fifth has
received no response so far. Indeed, the code contained two errors,
and the patch was incomplete, as it was not clear how to fix one
oftheerrors.Intheremainingcase,wehaveinformedthekernel
developersoftheissue,butwedonotknowhowtofixitandarethusunabletoproposeapatch.Nevertheless,allofourapprovedpatches
received quick responses, suggesting that inconsistencies in the
useoflistsisanissuethatLinuxkerneldevelopersareconcerned
about.
To further evaluate the potential utility of our type information,
we searched for past patches to the Linux kernel that changed the
arguments ofthe ‘list_add’and ‘list_add_tail’operators. Thegoal
was both to see whether this is a recurring bug pattern, thereby
potentially benefitting from a tooled approach, and whether ourtype information could have helped to find them. We found 11
such patches using the patch query tool Prequel [ 9]. This seems to
confirmthatsuchbugsarerecurrent.10ofthe11patchesswaptheargumentsandtheremainingonechangesthetargetlisthead.For8patchesoutofthe11,wehavecheckedthetypesinferredforthere-leaseoftheLinuxkernelpriortothepatchandfoundthatthetypescontainamutualpair,asillustratedinthePhyterexamplediscussed
above.Thus,thetypeinformationcouldbehelpfulinthesecases.
For 2 other patches, we do not have any type information becausethe relevant code was not present in the release prior to the patch,
andwehaveonlyrunLiLiputonkernelreleases.For1patch,we
werenotabletoobtaintherelevantversionusing git describe ,
andthusitwasnotpossibletofindtheassociatedtypeinformation.
Summarizing, we have evidence that a large majority (8/11) of the
previous bug fixes of argument inversion for list insertion could
have been spotted by our typing tool.
By putting together the previously fixed bugs and the new bugs
we identified, we can validate the hypothesis formulated in Sec-
tion 2.3 (that missing or incomplete list information may favourerrors such as confusing heads and elements, or inserting/using
wrongtypeofelements).Indeed,bugsinvertingtheargumentsof
alist_add operatorare instancesofthehead/element confusion,
and have the effect of inserting a wrong kind of element into a list;
andusingacursorvariableofawrongtypemaycauseerroneous
element extractions and accesses.
5.5 Visualisation example
WeconcludebyconsideringhowthetoolsprovidedwithLiLiput
canhelpunderstandlistsandfindlistusagebugs( RQ4).Figure6dp83640_private@dp83640.crxts@dp83640.c
dp83640_clock@dp83640.c var@dp83640.crxts rxpoollist
list
phylist list phyter_clocks
Figure 6: Visualization of the structures involved in thePhyter precision time protocol transceiver example
shows the result of the visualization for the structures involvedin the Phyter precision time protocol transceiver bug. Each box
representsavariableorastructuretype.Ovalsintheboxrepresent
thevariableorthestructurefields,respectively.Blueovalsareat
leastlistheads,possiblyalsolistelementconnectors,whileblack
ovalsareonlylistelementconnectors.Inthiscase,wecaneasily
see the mutual pair related to the bug discussed above.
Tofacilitatestudyingsuchuncommoncases,thevisualization
toolcanbeconfiguredtogenerateonlygraphsthatcontainself-lists
and only graphs where a list head has another list head as a list
element, as is the case of a mutual pair. It is also possible to specify
thenameofastructureorfieldthatmustappearinthegraph,to
focus on a single example.
6 RELATED WORK
TemplatesinC++[ 19]andJavaGenerics,whichwereintroduced
in 2004, enable defining an API that is parameterized over some
types. These features make it possible to define a list type that can
beusedwithdifferenttypesofelements,suchthattypechecking
ensuresthatallelementshavethesametype.InthecontextofJava,
anautomaticrefectoringwasmadeavailabletousesuchtypesin
Eclipse3.1,releasedinJune2005[ 5].Still,astudyof20widelyused
Java projects in 2011 [ 16] showed that the adoption of generics
intheseprojectswasspotty,oftenrelyingonthemotivationofa
single developer and often addressing a limited set of types, e.g.,
listsofstrings.Asubsequentstudyin2014[ 1]considering31KJava
projects from SourceForge found that 57% of the projects instan-tiated existing generic types, but less than 10% of the total set of
files from the 31K projects did so, again suggesting some reticence
in using these features. The Linux developers have aggressively
adoptedalistimplementationthatdoesnotincorporatetheelement
type. However, Linux lists also include the notion of a list head,
which brings some extra expressivity, as noted in Section 5.3, as
compared to simply parametrizing a list by a type.
As a large and critical code base, the Linux kernel has been the
subject of numerous efforts to mineproperties of the source code.
Engleretal.[ 2]initiatedthefieldof protocol mining intheLinux
kernel, by finding commonly occurring sequences of function calls,
and thenidentifyingas bugssequences offunction callsthat only
partiallymatchedthesepatterns.Subsequentworkimprovedthe
112accuracy of the approach [ 7] and extended it beyond function calls
[11]. Saha et al. [ 17] eliminated the requirement that identified
sequences of function calls occur commonly, enabling finding bugs
in subsystem-specific function protocols. Lu et al. [ 12] mine corre-
latedvariables,suchasavariablecontainingastringandanother
variable storing its length, and detect bugs where the variables are
notupdatedconsistently,andraceconditionswhenthevariables
areupdatedwithoutholdinglocks.LawallandLo[ 10]mineuses
ofnamesdeclaredwith #define,useclusteringtogrouptheminto
types and then use the types to identify names used in invalid
contexts. We are not aware of any mining-based type inference
approaches that have been applied on the Linux kernel to generic
structures such as lists.
Our type inference system complements the C type list_head
withadditionalannotations,describingtheiruseaslistelementsor
heads. This is similar to the approach of type qualifier inference.
Type qualifiers [ 3] complement programming-language types with
extra attributes, typically from a finite set. They were initially il-
lustrated by inferring constannotations in the C language. Other
applications concerned ownership [ 6] or security [ 18,24] prop-
erties,amongothers.Fromstandalonetypingtools,theyevolved
into compiler plugins, through the notion of pluggable types, as in
the Checker Framework for the Java language [ 15]. More recently,
thesebatch-orientedtoolswerecriticizedasbeinginflexible,bynot
allowing the user to modify the code to fix qualifier conflicts; an
interactivetoolwasproposedasasolution[ 20].Inourproposal,the
complementary typing information is not derived from a fixed set,
butratherinthenamespaceofCtypes,orsubsetsthereof.Ourtool
isimplementedasabatchtool,buttheaccesstotheintermediate
reports enables maintainers to actively participate in the typing
process, for instance by filtering or modifying the computed types
accordingtotheirdomainexpertise.Intheimplementation,weuse
a combination of typing rules, dataflow analyses, and heuristicsto reverse engineer the complementary typing information. It isan interesting question whether the implementation of our anal-
ysescouldbesimplifiedbyleveraginganexistingframeworkfor
pluggable types.
A different approach to type inference for program understand-
ingwas pioneered bythetoolLackwit [ 13],also targetingCcode.
Lackwitinferstypesthatdescribehowvaluesflowbetweenvari-
ables:i.e.,itgivestwovariablesthesametypeifvaluescanbepassed
betweenthem.LiLiputfocusesonlyonlistvariables,concerning
theirroleinlistdatastructures.Itrevealsconnectionsbetweendata
structures rather than how values flow.
7 CONCLUSION AND PERSPECTIVES
We have presented a toolset for retro-documenting Linux kernel
listswithtypeannotations.Annotationsaresuccessfullyinferred
for 90% of the total list structures defined. The information pro-
vided by the inferred types can help understanding data structures
and build graphical representations of complex data structures. By
studying uncommon typing patterns (type smells), the provided
informationcanalsohelpspotpossiblebugsoridentifycomplex
programming techniques involving lists.
Oneperspectiveforcontinuingthisapproachwouldbetouse
ourstricttypingrulestoenforceamoredisciplineduseoflists.Thiswouldrequiredeveloperstoduplicatesomelocallistheadvariables,
to account for list elements of different types at different times,
and create some dummy structures around local list head variables
temporarily used as list elements. A necessary pre-requisite would
be to investigate whether kernel developers would be interestedin a solution requiring more typing discipline but offering more
runtime guarantees.
On the other hand, there are several possible generalizations of
our type inference technique and its applications.
Onedirectextensionofourtypeinferencesystemwouldbeto
useourtypingresultsasabaseforinferringhigher-leveltypes,that
wouldconveyricherinformationformaintainers.Suchhigher-level
types could include rinд(s),tree(s), andumbrella (s), respectively
for rings, doubly-linked trees, and umbrellas of some structure s,
as defined in Section 5.3. Recognizing such types would need some
new inference rules e.g., for identifying the up-links in trees or
umbrellas.
Another direct extension of this work would be to consider
other kinds of lists defined in the kernel libraries, covering morespecialized needs. Examples include LRU lists for implementingcaches (defined in file
list_lru.h ), and BL lists used in scalable
hash tables (defined in list_bl.h).
Furthermore, data structures other than lists could be consid-
ered,suchasred-blacktrees(definedin rb_tree.h ).7LikeLinux
lists,red-blacktreesareformedbyembeddingaconnectorstruc-
ture called rb_nodewithin someother datastructures forming a
sorted, balanced tree. Unlike Linux lists, however, there is a second
connector data structure called rb_rootthat represents the tree
root.Red-blacktreeconnectorsareembeddedin70differentdata
structuresinthekernel.Inferencerulescouldsupplementlacking
documentation (indicating which type of elements correspond to a
rootandviceversa),andenablecheckingwhetheronlytheright
kind of structures are inserted or searched for in a given tree.
One way of going further with the generalization is to focus on
the idea of generic structure embedded in various other structures,
whichabstractsthenotionofconnectorsinLinuxlists.Apromising
indicatorforsuchpatternsistheuseofthe container_of macro,
if used for retrieving different container structures starting froma generic structure. Examples of such generic structures include
callback_head ,kobject,kref,rcu_head ,etc.Usingsomesimple
rulesinCoccinelle,wefound454 genericstructuresthatareused
withtheoperator container_of forretrievingatleasttwodifferent
containertypes.Thisseemstoindicateagreatpotentialforcases
where type inference techniques could be useful.
Finally, the approach could be explored for other OS kernels.
For example, the use of connectors embedded in data structures
for improving the cache locality of linked structures is a recurring
design pattern in highly optimized system software.
Availability. The supplementary material, available both as an
evolving Git repository [ 21] and as a specific version for repro-
ducibility purposes on Software Heritage [ 22], contains: the list
detectionandtypeinferencetools,thetypeinferenceresults,the
manually inspected samples,and the visualization of selflists andof list names that are both list heads and list elements (v5.6).
7https://www.kernel.org/doc/html/latest/core-api/rbtree.html
113REFERENCES
[1]Robert Dyer, Hridesh Rajan, Hoan Anh Nguyen, and Tien N. Nguyen. 2014.
MiningbillionsofASTnodestostudyactualandpotentialusageofJavalanguage
features. In ICSE. 779–790.
[2]Dawson R. Engler, David Yu Chen, and Andy Chou. 2001. Bugs as deviant
behavior:Ageneralapproachtoinferringerrorsinsystemscode.In SOSP.57–
72.
[3]Jeffrey S Foster, Manuel Fähndrich, and Alexander Aiken. 1999. A theory of type
qualifiers.In ACM SIGPLAN Conference on Programming Language Design and
Implementation. 192–203.
[4]M. Fowler. 1999. Refactoring-Improving the Design of Existing Code. Addison-
Wesley.
[5]Robert M. Fuhrer, Frank Tip, Adam Kiezun, Julian Dolby, and Markus Keller.
2005. Efficiently refactoring Java applications to use generic libraries. In ECOOP.
71–96.
[6]WeiHuang,WernerDietl,AnaMilanova,andMichaelDErnst.2012. Inference
and checking of object ownership. In European Conference on Object-Oriented
Programming. Springer, 181–206.
[7]TedKremenek,PaulTwohey,GodmarBack,AndrewY.Ng,andDawsonR.Engler.
2006. Fromuncertaintytobelief:Inferringthespecificationwithin.In OSDI.161–
176.
[8]Julia Lawall and Gilles Muller. 2018. Coccinelle: 10 years of automated evolution
in the Linux kernel. In USENIX ATC. 601–614.
[9]Julia Lawall, Derek Palinski, Lukas Gnirke, and Gilles Muller. 2017. Fast and
preciseretrievalofforwardandbackportinginformationforLinuxdevicedrivers.
InUSENIX ATC. 15–26.
[10]Julia L. Lawall and David Lo. 2010. An automated approach for finding variable-
constant pairing bugs. In ASE. 103–112.
[11]Zhenmin Li and Yuanyuan Zhou. 2013. PR-Miner: automatically extracting
implicitprogrammingrulesanddetectingviolationsinlargesoftwarecode.In
ESEC/FSE. 306–315.
[12]Shan Lu, Soyeon Park, Chongfeng Hu, Xiao Ma, Weihang Jiang, Zhenmin Li,
RalucaA.Popa,andYuanyuanZhou.2007. MUVI:Automaticallyinferringmulti-
variableaccesscorrelationsanddetectingrelatedsemanticandconcurrencybugs.
InSOSP. 103–116.[13]RobertO’CallahanandDanielJackson.1997. Lackwit:Aprogramunderstanding
tool based on type inference. In Proceedings of the (19th) International Conference
on Software Engineering. IEEE Computer Society, 338–348.
[14]YoannPadioleau,JuliaL.Lawall,RenéRydhofHansen,andGillesMuller.2008.
DocumentingandautomatingcollateralevolutionsinLinuxdevicedrivers.In
EuroSys. 247–260.
[15]Matthew M Papi, Mahmood Ali, Telmo Luis Correa Jr, Jeff H Perkins, andMichael D Ernst. 2008. Practical pluggable types for Java. In Proceedings of
the 2008 international symposium on Software testing and analysis. 201–212.
[16]ChrisParnin, ChristianBird, andEmersonR. Murphy-Hill.2011. Javagenerics
adoption: how new features are introduced, championed, or ignored. In MSR.
3–12.
[17]SumanSaha,Jean-PierreLozi,GaëlThomas,JuliaL.Lawall,andGillesMuller.
2013. Hector: Detecting resource-release omission faults in error-handling code
for systems software. In DSN. 1–12.
[18]UmeshShankar,KunalTalwar,JeffreySFoster,andDavidAWagner.2001. De-
tecting format string vulnerabilities with type qualifiers.. In USENIX Security
Symposium. 201–220.
[19]BjarneStroustrup.1989. ParameterizedTypesforC++. J. Object Oriented Program.
1, 5 (Jan. 1989), 5–16.
[20]Mohsen Vakilian, Amarin Phaosawasdi, Michael D Ernst, and Ralph E Johnson.
2015. Cascade: A universal programmer-assisted type qualifier inference tool. In
2015 IEEE/ACM 37th IEEE International Conference on Software Engineering,Vol.1.
IEEE, 234–245.
[21]Nic Volanschi and Julia Lawall. 2020. Supplementary material as Git repository.
https://gitlab.inria.fr/lawall/liliput/. [Online; accessed 28-August-2020].
[22]NicVolanschiandJuliaLawall.2020. SupplementarymaterialasSoftwareHer-
itagepermalink(specificversionforreproducibilitypurposes). https://archive.
softwareheritage.org/swh:1:rev:a303a19397a995a2bc4d8a2a2156f7409c39afef;
origin=https://gitlab.inria.fr/lawall/liliput.git. [Online;accessed28-August-2020].
[23]AlexandervonRhein,JörgLiebig,AndreasJanker,ChristianKästner,andSven
Apel. 2018. Variability-Aware Static Analysis at Scale: An Empirical Study. ACM
Transactions on Software Engineering and Methodology 27,4(2018),ArticleNo.
18.
[24]KonstantinWeitz,GeneKim,SiwakornSrisakaokul,andMichaelDErnst.2014. Atypesystemforformatstrings.In Proceedings of the 2014 International Symposium
on Software Testing and Analysis. 127–137.
114