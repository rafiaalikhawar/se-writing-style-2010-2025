JShrink:In-Depth Investigationinto Debloating ModernJava
Applications
Bobby
R. Bruce‚àó
Universityof California,Davis
U.S.A
bbruce@ucdavis.eduTianyiZhang‚àó
HarvardUniversity
U.S.A
tianyi@seas.harvard.eduJaspreet Arora
Universityof California,Los Angeles
U.S.A
jasa92@g.ucla.edu
Guoqing HarryXu
Universityof California,LosAngeles
U.S.A
harryxu@cs.ucla.eduMiryungKim
Universityof California,LosAngeles
U.S.A
miryung@cs.ucla.edu
ABSTRACT
Modern software is bloated. Demand for new functionality has
leddeveloperstoincludemoreandmorefeatures,manyofwhich
becomeunneededorunusedassoftwareevolves.Thisphenome-
non, known as software bloat, results in software consuming more
resources thanitotherwiseneedsto. How toeffectively and auto-
maticallydebloatsoftwareisalong-standingprobleminsoftware
engineering. Various debloating techniques have been proposed
sincethelate1990s.However,manyofthesetechniquesarebuilt
uponpurestaticanalysisandhaveyettobeextendedandevaluated
inthecontextofmodernJavaapplicationswheredynamiclanguage
features are prevalent.
Tothisend,wedevelopanend-to-endbytecodedebloatingframe-
work called JShrink. It augments traditional static reachability
analysis with dynamic profiling and type dependency analysis and
renovates existing bytecode transformations to account for new
language features inmodernJava. We highlightseveralnuanced
technicalchallengesthatmustbehandledproperlyandexamine
behavior preservation of debloated software via regression test-
ing. We find that (1) JShrinkis able to debloat our real-world Java
benchmark suite by up to 47% (14% on average); (2) accounting
for dynamic language features is indeed crucial to ensure behavior
preservation√êreducing 98% of test failures incurred by a purely
static equivalent, Jax, and 84% for ProGuard; and (3) compared
withpurelydynamicapproaches,integratingstaticanalysiswith
dynamicprofilingmakesthedebloatedsoftwaremorerobusttoun-
seentestexecutions√êin22outof26projects,thedebloatedsoftware
ransuccessfully under newtests.
CCS CONCEPTS
¬∑Software and its engineering ‚ÜíAutomatic programming ;
Objectoriented languages .
‚àóBobbyR. Bruceand TianyiZhang contributed equally to thispaper.
ESEC/FSE ‚Äô20, November 8≈õ13, 2020, Virtual Event, USA
¬© 2020 Copyright held by the owner/author(s).
ACM ISBN 978-1-4503-7043-1/20/11.
https://doi.org/10.1145/3368089.3409738KEYWORDS
Java
bytecode,size reduction, reachabilityanalysis,debloating
ACMReference Format:
Bobby R. Bruce, Tianyi Zhang, Jaspreet Arora, Guoqing Harry Xu,
and Miryung Kim. 2020. JShrink: In-Depth Investigation into Debloating
ModernJavaApplications.In Proceedingsofthe28thACMJointEuropean
Software Engineering Conference and Symposium on the Foundations of Soft-
wareEngineering(ESEC/FSE‚Äô20),November8≈õ13,2020,VirtualEvent,USA.
ACM,NewYork,NY,USA, 12pages.https://doi.org/10.1145/3368089.3409738
1 INTRODUCTION
The size and complexity of software has grown tremendously in
recentdecades.Thoughlargelybeneficial,thishasledtounchecked
bloatissuesthatareespeciallysevereformodernobject-oriented
applicationsduetotheirexcessiveuseofindirection,abstraction,
andeaseofextensibility.Thisproblemofcustomizingandtailoring
modern applications to only used components, in an automated
fashion,isalongstandingproblem[ 27,34,45,46,52,59,61,63,67].
PriorworkoncodesizereductionfocusesprimarilyonC/C++
binaries [ 27,34,45,46,52,68], motivated by the long-held belief
that C/C++ programs are easier to attack and are often choices
for developing embedded systems. However, with the rise of cloud
computing,Android-basedsmart-phones,andsmart-homeinternet-
of-the-things, a managed, object-oriented language such as Java
ismakingitswayintoallimportantdomains.Althoughreducing
thesizeofJavabytecodemaynotultimatelyleadtoasignificant
improvement in a traditional stand-alone machine setting, itsbene-
fit becomes orders of magnitude more significant in many modern
small andlarge-scalecomputing scenarios√êsmallerbytecode size
directly translates to reduced download size and loading time in
smartphones and reduced closure serialization time in big data sys-
tems suchasApache Spark;theseare allimportant performance
metrics for which companies are willing to spend significant re-
sourcesin optimizing.
However, past work has not given much attention to Java, es-
pecially modern Java applications. Of particular interest to us is
Tip et al.‚Äôs work [ 61] in the late 1990s that proposes various de-
bloatingtransformations,whichhavesincebeenutilizedbyother
researchers[ 6,15,30].Insurveyingtheliterature,wefindthattheir
effectivenesshasyettobesystematicallyevaluatedonareal-world
benchmark of modern Java applications. All previous implemen-
tations of those bytecode transformations relied on pure static
135This work is licensed under a Creative Commons Attribution International 4.0 License.
ESEC/FSE ‚Äô20, November8‚Äì13,2020,VirtualEvent, USA BobbyR. Bruce,Tianyi Zhang,Jaspreet Arora,Guoqing Harry Xu,andMiryungKim
analysistoidentifyreachablecode,herebyignoringcodereachable
through reflection, dynamic proxy, callbacks from native code, etc.
Recent studies find that dynamic language features are prevalent
and they pose direct challenges in the soundness of static analy-
sis [33,39]. This unsoundness makes debloating unsafe√êremoving
dynamically invoked code and inducing subsequent test failures.
Furthermore, evaluations in prior work focus mostly on size reduc-
tion rather than behavior preservation, which raises a big safety
concernfor adoptingdebloating techniques inpractice.
Therefore,weundertaketheambitiouseffortofmodernizingand
evaluating Java bytecode debloating transformations and quantify
the tradeoff between size reduction and debloating safety. We aug-
ment static reachability analysis with dynamic profiling to handle
newlanguagefeatures, e.g.,dynamicproxy, pluggable annotation,
lambda expression, etc. We incorporate a new type dependency
analysis to account for various ways to reference types, like an-
notationsandclassliterals,toensuretypesafety.Weextendfour
kindsofdebloatingtransformations√ê methodremoval,fieldremoval,
method inlining , andclass hierarchy collapsing into a fully auto-
mated,end-to-enddebloating framework called JShrink.
To effectively evaluate those bytecode transformations, we built
anautomatedinfrastructuretoconstructabenchmarkofreal-world,
popular Java applications. We applied a rigorous set of filtering cri-
teria:(1)reputationscorebasedontheGitHubStarratingsystem,
(2)executabletests,(3)aMavenbuildscript[ 42],whichprovides
a standardized interface for obtaining library dependencies and
regressiontesting,and(4)compatibilitywiththeunderlyingbyte-
code analysis framework, Soot [ 64]. The availability of runnable
testcasesenablesustoexaminetowhatextentthebehavioroforig-
inal software is preserved after debloating via regression testing.
Currently,theresultingbenchmarkincludes22projectswithSLOC
ranging from 328 to 99,779 and with up to 69 library dependencies.
Wethenapply JShrinktothisbenchmarktoquantifysizereduc-
tion, the degree to which test behavior could be preserved, and the
impact ofJava dynamiclanguagefeatures.
RQ1How much Java byte code reduction is achievable when
applyingdifferentkindsoftransformations?
RQ2To what extent, does JShrinkpreserve program correctness
when debloating software?
RQ3What are the trade-offs in terms of debloating potential and
semantic preservation?
RQ4Howrobustisthedebloatedsoftwaretounseentestexecu-
tionssuch as newtest cases?
JShrinkreducesaproject‚Äôssize(applicationandincludedlibrary
dependencies) by up to 46.8% (14.2% on average). The method re-
movalcomponent reduces the application by the most (11.0% on
average)followedby methodinliner (2.1%onaverage), fieldremoval
(1.0%onaverage),and classhierarchycollapser (0.1%onaverage).
A hybrid static anddynamic reachabilityanalysis is necessary for
improvingbehaviorpreservationofdebloatedsoftware. JShrink
doesnotbreakanyexistingtestsfor22outof26Javaprojectsafter
debloating,whilethreeexistingtechniques,Jax[ 61],JRed[30],and
ProGuard [ 6] that rely on pure static analysis preserve behavior
for only 9, 11, and 15 projects respectively. While this compari-
sonintermsofthenumberofprojectsmaylookmarginal,98%of
test failures encountered in Jax (83% for ProGuard) can be actuallyremoved by JShrink‚Äôs enhancements. This result implies the ef-
fort of handling new language features is absolutely necessary and
worthwhileforimprovingbehaviorpreservation,whichjustifies
the need to address the long-standing debloating problem in the
modern context. We find that size reduction potential is minimally
impacted by this incorporation of dynamic reachability analysis.
Weonlysacrificesizereductionby2.7%onaverage,whileprovid-
ingmuchstrongerbehaviorpreservationguarantees.Toachieve
100% behavior transformation, we enable checkpointing √êa feature
ofJShrinkwhere transformations are reverted if they are found to
breakthesemanticsofatargetprogram.Thoughthisstrategyin-
cursmarginallossesinsizereduction(0.9%onaverage),webelieve
checkpointing to be a practical solution for balancing semantic
preservationandcode size reduction benefits.
Our work makesthe following contributions:
‚Ä¢Wepresent JShrink,anend-to-endJavadebloatingframe-
workthatmodernizesfourdistinctbytecodetransformations.
It includes significant andnovelextensions to make debloat-
ingmuch safer inamodern context.
‚Ä¢Wefindbytecodereductionofupto46.8%ispossible,where
reachability-based method removal plays a dominant role in
size reduction. JShrinkensures that debloated software still
passes98%ofexisting tests.
‚Ä¢We demonstrate the necessity of handling dynamic features
and ensuring type safety. JShrinkremoves 98% and 83% of
test casefailures incurredbyJax[ 61]andProGuard[ 6].
‚Ä¢Weputforwardanautomatedinfrastructureofconstructing
real-world Java applications with test cases, a build script,
andlibrary dependenciesforassessing debloating potential
andchecking behaviorpreservationusing tests.
Themainresearchcontributionofthispaperis onsystematiza-
tionofthecommunity‚ÄôsknowledgeofJavadebloating inthemodern
era. As a reference point, several top conferences [ 14,20,50] have
alreadystartedtohavea≈Çsystematizationofknowledge≈ætrack,with
the goal to address the concern that ≈Çthe community seems to lose
memoryofthingsthathavebeendoneinthepast.≈æWiththispaper,
we hope to bring existing debloating techniques into a contem-
porarycontextwheredynamicfeaturesare prevalentand where
behaviorpreservationmustbeensuredandcheckedusingtests.By
conducting rigorousevaluation using real-worldbenchmarks, we
provide evidence that prior debloating work indeed suffers from
poor behavior preservation. We then demonstrate that behavior
can be preserved to a significantly greater extent by incorporating
newcomponentstoexplicitlyaddressdynamiclanguagefeatures
and type safety. We make publicly available the JShrinksource
code and additional resources necessary to replicate our results at
https://doi.org/10.6084/m9.figshare.12435542 .Asacompanionpiece
to this work, we have prototyped JShrinkas an entirely online
SaaS,whichwecall WebJShrink [41].WebJShrink providesarich
graphicaluserinterfaceforthefunctionalitydescribedinthispaper.
Additionally, it can offload debloating analysis and transformation
tothecloudandpresentuserswithabreakdownofwherethebloat
existswithin atarget project.
2 BACKGROUND
Scope: Java Bytecode. The problem of software bloat has been a
center of research studies for more than a decade in the area of
136JShrink: In-DepthInvestigation intoDebloating ModernJava Applications ESEC/FSE ‚Äô20, November8‚Äì13,2020,VirtualEvent, USA
performancetuning andoptimization. Recently,there isarevived
interest√êpartlyduetotheneedofcyberdefense(e.g.,USNavy‚Äôs
TotalPlatformCyberProtection(TPCP)program[ 4])√êinextending
traditional debloating techniques to reduce code size, improve run-
time performance, and remove attack surfaces for a wide spectrum
ofsoftwareapplications,includingJavaScriptprograms[ 67],native
applications[ 46], andDocker containers[ 47].
In this paper, we focus on code size reduction as opposed to run-
time memory bloat that was the target of a large body of prior
work [43,70,72≈õ74]. While code bloat exists commonly in a broad
rangeofapplications,wefocusonobject-orientedprograms(specif-
icallyJava bytecode) as our scope for tworeasons.
First, the culture of object orientation encourages developers to
useframeworks,patterns,andlibrariesevenforextremelysimple
tasks,resultinginalargenumberofclassesandmethods,which,
thoughnotused atallduringexecution, stillneedtobeloaded by
JVMduetotype-induceddependencies.Theseclassesandmethods
consume extra space and memory, thereby negatively impacting
the performance of resource-constrained systems such as smart
phonesorIoTdevices.Furthermore,theycanpotentiallycontain
securityvulnerabilities(e.g.,gadgetsinreturn-orientedprogram-
ming [13]),whichcanbe exploitedby remoteattackers to execute
code segments that could not have been reachedotherwise.
Second, many recent techniques [ 27,45,46,52] on code bloat
target native x86 programs, aiming to reduce the size of executable
binaries. Native programs are significantly different from object-
orientedprogramsintermsofcompilationandexecution.Native
programs are statically compiled and linked, with most libraries
statically loaded. In many cases, a compiler can already remove
much of dead code. On the contrary, object-oriented programs
areoften dynamicallycompiledandloaded ;theubiquitoususeof
dynamic features such as dynamic class loading and reflection
dictatesthatacompilerwouldnotknowwhichclassestoloaduntil
the moment they are needed.
History:StaticBytecodeDebloating. Inthelate1990s,Tipetal.de-
veloped Jax, which included, so far, the most comprehensive set of
transformationstoreduceJavabytecode,including methodremoval ,
fieldremoval ,methodinlining ,classhierarchytransformation ,and
namecompression [61].Theylaterintroducedtwomoretransforma-
tions,class attribute removal andconstant pool compression in their
2002journalpaper[ 62].Recenttechniquesarebasedonasubset
of thesetransformations to debloat new typesof applications,e.g.,
Android [ 29] and Maven libraries in continuous integration [ 15].
JRed [30] and RedDroid [ 29] only support the method removal and
classremoval transformations,whileMolly[ 15]supports fieldre-
movalaswell.Theseabovementionedtechniquesare outdatedor
not publicly available . Furthermore, their evaluations did not quan-
tifythedegreetowhichdebloatedsoftwarepreservessemanticsby
running existing tests. Behavior preservation is crucial for these
techniques to be adoptedinpractice.
MotivationforModernizingSoftwareDebloatingandAssessingBe-
haviorPreservation. Javaoffersanumberofdynamicfeatureswidely
usedinreal-worldprograms[ 33]√êreflection,dynamicclassloading,
dynamicproxy,etc.,whicharehighlychallengingtomodelthrough
pure static analysis. Livshits et al. first investigated this problem in
2005 using points-to-analysis to statically resolve dynamic methodinvocation targets [ 40]. Other attempts focused on a specific scope
ofdynamicfeaturessuchasreflection[ 38,54],dynamicproxy[ 22],
etc. Most static analysis tools tolerate and encourage some level of
unsoundness to keep the analysis usable and scalable [ 39]. Land-
man et al. conduct a systematic literature review and an empirical
study to assess the effectiveness of 24 different static analysis tools
inthepresenceof real-worldJavareflectionusage[ 33].Theyfind
that staticanalysis is inherently incomplete andreflection cannot
be ignored for 78% of projects. This finding motivates our effort
to evaluate the safety of debloating techniques in the context of
dynamic language features. In Section 5.3, we quantify this benefit
ofhandlingdynamicfeatures√êdebloatedsoftwarebasedonpure
staticanalysiswouldfail 3327 more tests in26 projects.
Profile-Augmented Static Debloating and Checking of Behavior
Preservation. Existingdebloatingtechniquesonlyassessthecodere-
duction and performance improvement achieved by different kinds
of bytecode transformations [ 6,29,30,62]. None of them assess
the correctness of reduced programs by running existing test cases .
Furthermore, these techniques only perform static call graph anal-
ysis to approximate used code, and are incomplete in the presence
of various dynamic language featuresdiscussedin Section 3. Ergo,
testfailuresareinevitable,asdynamicallyinvokedcodecouldbe
removedbydebloating.In thispaper,wetakea profile-augmented
staticdebloating approach√êweaugmentstatic reachabilityanalysis
with dynamic reachability analysis using existing tests; we remove
codethroughstaticbytecodetransformations;andwecheckbehav-
ior preservationbyrunning existing tests after debloating.
3 JSHRINK
We build an end-to-end bytecode debloating framework called
JShrink. Given the bytecode of a Java program and a set of test
cases,JShrinktakesthreephasestodebloatbytecodeandverifyits
correctness. In Phase I, JShrinkperforms profile-augmented static
analysistodetermineusedandunusedcode.InPhaseII, JShrink
appliesfourkindsofdebloatingtransformations.Finally, JShrink
rerunsthegiventestcasestocheckbehaviorpreservationbetween
the originalandthe debloatedversion.
3.1 Profile AugmentedStatic Analysis
Weapplythreetypesofanalyses√êstaticreachabilityanalysis,dy-
namic profiling, and type dependency analysis√êto capture method
invocation, field access, and class reference relationships between
class entities. This is essential to determine unused code in the
presenceofdynamiclanguagefeaturesandensuretypesafetyof
debloatedbytecode,especiallyinclass hierarchymerging.
Static Reachability Analysis. Static call graph analysis is a
standard method used by previous bytecode debloating tech-
niques[29,30,62]todecideunusedmethods.Givenasetofmethods
(e.g.,mainmethods, testcases, etc.) as entry points, it analyzes the
bodyofeachmethodandidentifiescallsitesinthemethodbody.
Call graph analysis then constructs a directed graph for each entry
methodandaddsedgesfromtheentrymethodtoitscalleemethods.
Those callee methods are then treated as new entry points and the
processcontinuesuntilnonewmethodsarefound,reachingafix
point.
137ESEC/FSE ‚Äô20, November8‚Äì13,2020,VirtualEvent, USA BobbyR. Bruce,Tianyi Zhang,Jaspreet Arora,Guoqing Harry Xu,andMiryungKim
Due to polymorphism in object-oriented languages, multiple
call targets could be invoked from a call site via dynamic dispatch-
ing, depending on the runtime type of the receiver object. Various
techniques have been proposed to approximate possible targets
of a dynamic dispatch, e.g., class hierarchy analysis (CHA) [ 17],
0-CFA [26,53], rapid type analysis (RTA) [ 9], points-to analy-
sis[37,51],etc.Specifically, JShrinkleveragesCHAtoconstruct
callgraphs,whichidentifiesallcorrespondingmethodimplementa-
tionsofacalleeinthesubclassesofthedeclaredreceiverobjecttype
andconsidersthemaspotentialcalltargets.Weperformawhole-
program analysis, including application code, imported third-party
libraries,andJRE,tobuildcallgraphs.Inaddition,weuseASM[ 12]
toanalyzefieldaccessesineachmethodandextendthecallgraphs
withfield access information.
DynamicReachabilityAnalysis. Weinitiallyconsideredusinga
lightweightdynamicanalysisapproachcalledTamiFlex[ 11],asitis
awellknowntechniqueforaddressingunsoundnesscausedbyJava
reflection. Tamiflex instruments Java reflection call sites to capture
methodcalls and fieldaccesses via reflectionat runtime.However,
TamiFlex is designed for reflection APIs only and lacks support for
other dynamic features, leading to many test failures (Section 5.4).
Tosystematicallyaccountfordynamicfeatures,wedefineacom-
prehensive list of dynamic features based on Sui et al. [ 58]. All the
followingdynamicfeaturesexceptserializedclassloadingappear
inourbenchmark of26modernJavaapplications, indicatingthe
necessity ofhandling themproperly to ensure debloating safety.
(1)Reflection is a dynamic feature that enables users to dynami-
callyinstantiateclasses,accessfields,andinvokemethods.It
is widely used in modern Java context and is the foundation
for manyframeworks such as Spring andJUnit[ 33].
(2)Reflectionwithambiguousresolution referstoaspecialcase
wheremultiplepotentialtargetsexist(e.g.,overloadingmeth-
ods with different return types) for a dynamic invocation
via reflection. Such bytecode is often generated by bytecode
manipulationinstead ofbystandardcompilers.
(3)Dynamicclassloading involvesclassesloadedthroughcustom
class loaders.
(4)Dynamic proxy refers to the proxy feature that dynamically
creates invocation handlers for aclass andits methods.
(5)Invokedynamic is a new bytecode instruction introduced in
Java 7 that enables dynamic method invocation via method
handlers. Itisoften usedto support lambda expressions .
(6)Serialization refers to dynamically loaded classes via class
deserialization.
(7)Java Native Interface (JNI) is a framework that enables Java
tocallandbecalledbynativecode.Thisbenchmarkincludes
twoprograms that have callbacks from native code viaJNI.
(8)sun.misc.Unsafe isalow-levelJavaAPIthatcanbeusedtodi-
rectlymanipulateJVMmemoryatruntime,e.g.,dynamically
loading classes, throwing exceptions, swapping instances,
allocating newinstances,etc.
Wedevelopourownnativeprofilingagentcalled Jmtrace,which
instruments method invocations using JVM TI APIs [ 3] to inject
logging statements at the entry and exit ofeach method in aclass
duringclassloading.Table 1comparesthecapabilityofhandlingdif-
ferent kinds of dynamic features between static call graph analysis,Table1:CapabilityofHandlingDifferentDynamicFeatures
Static Tamiflex Jmtrace
Reflection /Circle /CIRCLE /CIRCLE
Reflection-ambiguous /Circle /LEFTCIRCLE /Circle /CIRCLE
Dynamic classloading /Circle /CIRCLE /CIRCLE
Dynamic proxy /Circle /Circle /CIRCLE
Invokedynamic /LEFTCIRCLE /Circle /LEFTCIRCLE /Circle /CIRCLE
JNI /Circle /Circle /CIRCLE
Serialization /Circle /CIRCLE /CIRCLE
Unsafe /Circle /LEFTCIRCLE /Circle /CIRCLE
TamiFlex,and Jmtrace.JShrinkrunsgiventestcasesandidentifies
dynamic method calls that do not exist in static call graphs but
are invoked during test execution. Then JShrinkinitiates another
round of static reachability analysis using those dynamically in-
voked methods as entry points. Note that we only use dynamic
profilingtoaugmentstaticanalysis,insteadofreplacingstaticanaly-
siswithdynamicanalysis.Incaseoflowtestcoveragefromexisting
tests, this augmentation lets JShrinkretain functionality statically
reachablefromuser-specifiedentrypoints,suchaspublicmethods,
mainmethods,andmethodentriesfromexistingtestcases.Itshould
be noted that while Jmtraceimproves our reachability analysis, its
effectiveness is entirely dependent on the coverage of the tests
provided. A test suite with low code-coverage will have a lower
chance ofuncovering dynamic features, which may utilized by an
end-user,thanatest suite withhigher code-coverage.
JVM TI APIs only permit instrumentation of method bodies.
As suchJmtraceis not capable of identifying fields dynamically
accessed via reflection. Therefore, we customize TamiFlex to in-
strument only reflection calls related to field accesses and use it
togetherwith Jmtrace.Instrumentationtootherreflectioncallsis
disabledto avoid redundant profiling.
TypeDependencyAnalysis. Traditionalreachabilityanalysisonly
keeps track of invoked methods and accessed fields, which is suffi-
cientformethodandfieldremoval.Previousdebloatingtechniques
consideraclassunusedifnoneofitsmethodsorfieldsarereach-
ablefromentrypoints[ 29,30,61].However,wefindthisdefinition
of unused classes is problematic in practice. Modern Java allows
developers to reference classes in various ways, not just limited to
variableandmethoddeclaration orclassinheritance,butthrough
pluggableannotations,classliterals, throwsclauses,etc.Aprogram
can thereby reference a class without instantiating it, or directly
accessanyofitsmethodsoffieldmembers.Insuchacase,removing
reference-onlyclassesthatdonothaveanymethodorfieldusage
willcauseabytecodeverificationfailureduringclassloadinginthe
JVMorleadtoa ClassNotFoundException atruntime.Itiscrucialto
ensuretypesafetyduringclassremovalandclasshierarchycollaps-
ing.Therefore, JShrinkbuildstypedependencygraphsbyscanning
through Java bytecode using ASM. If a class Ais referenced by a
classB,we add an edge from BtoAinthe graph.
Based on static analysis, profiling of dynamic features, and type-
dependencyanalysis, JShrinkdeterminesunusedcodeatfourgran-
ularities,listedbelow.Weuse≈Çclass≈æasageneraltermforconcrete
classes,abstract classes,andinterfacesinJava.
138JShrink: In-DepthInvestigation intoDebloating ModernJava Applications ESEC/FSE ‚Äô20, November8‚Äì13,2020,VirtualEvent, USA
‚Ä¢Unused Method : A method is unused if it is not reachable
from any given entry pointinthe callgraphs.
‚Ä¢Unused Field : A field is unused if it is not accessed by a
used method in a call graph or dynamically accessed via
reflection.
‚Ä¢UnusedClass :Aclassisconsideredunusedifnoneofthe
following three conditions are satisfied: (1) A method in the
class is reachablefrom given entry points; (2) A field in the
class is reachable from given entry points; (3) A descendant
ofthis class inthe class hierarchyisused.
‚Ä¢Reference-only Class : A class is not used but referenced
by another used or reference-only class based on given type
dependency graphs. This is a special category of classes not
handledsafelybyexistingdebloatingtechniques[ 29,30,61].
Inpriorwork,unusedclassesarecompletelyremovedifnone
of their class members are reachable. However, we find that
this is an unsafe choice, causing many ClassNotFoundError s
at runtime. Therefore, JShrinkpartiallydebloats reference-
only classes to ensure type safety, as explained in class hier-
archycollapsing.
3.2 BytecodeDebloating Transformations
InspiredbyTipetal.[ 61],JShrinkprovidesthefollowingbytecode
debloating transformations.
Unused Method Removal. JShrink provides three method re-
moval options√ê(1) completely remove the definition of an unused
method,(2)onlyremovethebodyofanunusedmethodbutkeep
themethodheader,and(3)replacethemethodbodywith awarn-
ing statement indicating the method is removed. To safely wipe
a method body, JShrinkinjects bytecode instructions to return
dummy values if the return type is not void. The first option could
achieve maximum code size reduction at the cost of safety, as it
may lead to NoSuchMethodError if a removed method is triggered
in future usages. With the second and the third options, unused
methodsarestilldefinedinbytecodeandthusprogramswillfail
gracefully without catastrophic program crashes. The third option
is the most informative, as it lets a user know which method is
invokedatruntimebutnotcapturedbystaticanalysisorgiventest
cases. Our results in Section 5uses the first option as default, but a
usermaychoose the othertwooptionsin JShrink.
Unused Field Removal. Given an unused field, JShrink com-
pletely removes its definition. Note that this transformation should
be used in pair with method removal. If those unused meth-
ods accessing an unused field are not removed, JVM will report
FieldNotFoundError thatcrashesthedebloatedsoftware.Enabling
this transformation alone requires fine-grained transformation
withinamethodbody,e.g.,removingallfieldaccessinstructions
andsubsequent instructionswithdata dependencies to the field.
MethodInlining. JShrinkinlinesamethodifthemethodhasonly
one call site in the call graph and the method is the only call target
the callsite. The former ensures that JShrinkdoes not introduce
code duplication during inlining, while the latter is crucial for
semantic preservationincaseofpolymorphism.
Typesafetyofmethodinliningiswidelydiscussedinthecom-
pilerliterature[ 24,25].Toensuretypesafety, JShrinkappliesthreeconstraints.First, JShrinkdoesnotinlineclassconstructors.Sec-
ond,JShrinkdoes not inline native methods, abstract methods,
andinterfacemethodsastheydonothavemethodbodies.Third,
JShrinkdoes not inline a method if it accesses other class mem-
bers that become invisible after inlining (detailed in Section 3.3).
JShrinkalsodoes not inline synchronized methods.
Class HierarchyCollapsing. JShrinkperformstwobasictrans-
formationstocollapseclasshierarchy.Thefirst,moresophisticated,
transformation is to merge a base class ùëãand a subclass ùëå, ifùëå
is the only used subclass of ùëã.JShrink checks if, for any over-
ridden method ùëö‚Ä≤inùëå, and the corresponding original method
ùëö,onlyone ofeither ùëöandùëö‚Ä≤isused.If bothare used, JShrink
does not collapse the classes. If this rule was not enforced, JVM
wouldnotdelegateaninvocationon ùëötoitsoverriddenmethod, ùëö‚Ä≤,
basedontherealtypeofthereceiverobjectatruntime.Thesecond
transformationistoremoveunusedclasses.Forareference-only
class,JShrinkremovesitsclassmembersandonlyretainstheclass
header to avoid ClassNotFoundError . If a reference-only class is a
concrete class, JShrinkinjects a default constructor as enforced by
JVM. Ifa reference-only class isan interface, JShrinkkeeps those
methoddeclarationswhoseimplementationsinasubclassareused.
Toimplementthefirsttransformationofmergingasubclass ùëå
intoabaseclass ùëã,JShrinktakesthreesteps.First,itmovesallused
methodandfieldmembersof ùëãintoùëåwhileremovingunusedclass
members in ùëå. Secondly, it updates all references to the merged
subclasses, their method and field members, to their new locations
after merging. During the merging and updating process, name
conflictsmayoccurduetomethodoverloadingrulesenforcedby
Java. For instance, class Bmay have overloaded methods void m(A
a)andvoid m(SubA a) . After merging SubAtoAand updating the
parameter type of the second method in B, the signatures of the
twomethodsbecomeidentical.Therefore,tohandlenameconflicts,
JShrinkrenames methods and further updates references to those
renamed methods as needed. Since class constructors cannot be
renamed, in instances where naming conflicts with them, JShrink
adds a new dummy integer parameter to ≈Çrename≈æ a constructor
and update allcall sitesof the renamedconstructor by pushing an
integervalue, 0,onthe stack.
Checkpointing. While experimenting with real-world Java
projects,wenotethattestfailuresmaystilloccurduetorarebut
challenging corner cases caused by known limitations of JVMTI
and Soot (Section 5.3). Therefore, JShrink implements an addi-
tional strategy of checkpointing to ensure safety. It checkpoints
each type of debloating transformation, runs tests, and reverses
failure-inducingtransformations.
3.3 Implementation andNuancedExtensions
We implement those bytecode debloating transformations using
Soot[64].WeusetheCHAimplementationinSootforstaticanaly-
sis,andASM[ 12]togatherfieldaccesses.Weimplement Jmtrace
usingJVM TIAPIs. Wehighlightseveralnuancedextensions that
we designedto ensure type safetyandbehaviorpreservation.
(1)Co-variantreturntype. FromJava5onward,JVMsupportsco-
variantreturntypes, whichallow an overridden methodto
haveareturntypedifferenttotheoriginal.Therefore,instead
of simply comparing whether two method signatures are
139ESEC/FSE ‚Äô20, November8‚Äì13,2020,VirtualEvent, USA BobbyR. Bruce,Tianyi Zhang,Jaspreet Arora,Guoqing Harry Xu,andMiryungKim
the same, JShrinkaccounts for co-variant return types to
determineoverriddenmethodswhenmergingtwoclasses.
Otherwise,JVMwillthrowaverification error.
(2)Class member visibility. When inlining a method or merg-
ing a class, it is important not to break access controls. If
methodùëöfrom class ùê¥is to be inlined into class ùêµ,JShrink
enforces that ùëödoes not call other private methods in ùê¥.
Otherwise, JVM will raise IllegalAccessError since those
private methods are not visible to ùêµ. Similarly, if subclass
ùê¥is in a different package compared with its superclass ùêµ
andùê¥contains a protected method that is called by another
classùê∂in the same package as ùê¥, merging ùê¥intoùêµwill
causeIllegalAccessError sinceùê¥.ùëöbecomes invisible to ùê∂
aftermovingtoadifferent package. Before merging aclass
to a different package, JShrinkchecks whether a protected
methodorfield willbecome invisible after merging.
(3)Lambda expression. Lambda expressions are introduced in
Java 8. They are anonymous functions that can be passed as
parameters to method calls. For example, in v.forEach(x ->
A.foo()),thelambda x -> A.foo() ispassedtothe forEach
method and could be executed at runtime. Therefore, the
methodcall foomustbecapturedbycallgraphanalysis.This
expressioncanberewrittento v.forEach(A::foo(x)) using
the new methodreference operator ≈Ç::≈æ. JShrinkchecks for
both cases and adds missing edges between the caller and
methodcalls inalambdaexpressionto callgraphs.
(4)Classliterals. Classliteralssuchas X.classarecompiledto
stringconstantsinJavabytecode.Itiscriticaltoidentifyclass
referencesviaclassliteralsandaddthemtotypedependency
graphstoavoid ClassNotFoundError .JShrinkidentifiesclass
literalsbymatching ≈Ç*.class≈æagainststringconstantsused
in a class. JShrinkalso updates the class literal of a merged
class to its superclass to avoid ClassNotFoundError .
(5)Method inheritance. Merging classes in presence of both
method overriding and inheritance could be problematic.
Suppose a base class Ainherits a method mfrom its super
classBanditssubclass Coverrides m.IfA.misreachablefrom
anentrypoint,itishardtodecidewhether A.misactuallyin-
vokedon Aobjectsor Bobjectsduetopolymorphism.If A.mis
onlyinvokedon Aobjects,wecansafelymergeclass CintoB
evenwhentheoverriddenmethod C.misalsoused.However,
ifA.misinvokedon Bobjects,moving C.mintoBwillalterthe
dynamic patching behavior. In such a case, JShrinkmake
aconservativechoiceofnotmergingasubclasstoitsbase
class, if (1) the base class inherits a used method from its
superclass or an ancestor, (2) the subclass also overrides the
same method,and(3) the overriddenmethodisalsoused.
In summary, compared with prior work, JShrinkmakes the fol-
lowing major extensions to handle modern Java: (1) augmenting
staticreachabilityanalysiswithJVMTIbaseddynamicprofiling,
(2)incorporatingtypedependencyanalysis,(3) extendingmethod
inliningandclasshierarchycollapsingtransformationstoensure
type safety, and (4) all nuanced extensions in Section 3.3to handle
newlanguagefeatures properly.4 BENCHMARK
We build an automated infrastructure to construct a benchmark. It
uses the Google BigQuery API [ 2] to query GitHub projects and
automaticallyappliesarigoroussetoffilteringcriterialistedbelow
to include real-world, popular Java projectsonGitHub.
‚Ä¢Popular Java projects. To obtain popular Java projects, our
infrastructurechoosesprojectswithatleast100GitHubstars.
‚Ä¢Automatedbuildsystem. Ourinfrastructurerequiresastan-
dardized API to automatically resolve library dependencies,
compiletargetprojects,andruntestcases.Thecurrentim-
plementationsupportsMaven[ 42],apopularbuild system
usedinJava,butcouldbeeasilyextendedtosupportother
buildsystemssuch as Gradle.
‚Ä¢Compilable. Afterdownloadingthoseprojects,weexclude
thosethatinducebuildfailuresinourenvironment(anAma-
zonr5.xlarge instancewithUbuntu18.04andJDK1.8.0),
dueto specific hardware orlibrary configurations.
‚Ä¢Executable tests. We rely on test cases to evaluate to what
extent debloated software preserves its original behavior.
Therefore, after compiling a project, our infrastructure runs
the Maven test command andparses generated test reports
toidentifythenumberoftestcasesandtestfailures.Projects
withnotest orany test failure are excluded.
‚Ä¢No JVM verification errors. Note that, when Soot writes code
from its intermediate language, Jimple, back to bytecode, it
automaticallyappliesseveraloptimizationssuchasconstant
pool compression. Therefore, we first pre-process all Java
bytecode using Soot to fairly measure code size reduction
achieved by JShrink. In this pre-processing step, fatalJVM
verification errors could occur in some Java projects. We
discardthoseprojectsdueto JVMverification errors.
‚Ä¢NoTimeout. Ourinfrastructureenforcesatimeoutconstraint
on the profile-augmented static analysis, since generating
callgraphsforsomeprojectsmaytakeanexcessivelylong
time.We setthis timeoutto 10 hours.
Table 2:Project statistics
StarsTestsLibsSLOC(AppOnly) Size (KB:App+Libs)1
Max 16,2091,08169 99,779 114,312
Min 18810 328 30
Mean 3,13523715 14,729 15,734
Median 2,000 609 5,863 3,193
Total 691895213332 324,035 346,160
SD 3,59537017 22,288 30,766
The finalbenchmark inTable 3coversa wide spectrumof Java
programs,includingpopularlibraries,webapplications,develop-
mentframeworks,anddesktopapplications.Table 2summarizes
the statistics for those 26 benchmark programs. All are popular
GitHub projects with a median of 2,000 stars. The average num-
ber of test cases and external library dependencies are 237 and
15respectively.Thetotalsizeoftheprojects(inclusiveoflibrary
dependencies)rangefrom30KBto112MBwithamedianof3MB.
1The totalsize isthat of project and librarydependencies in theircompiled states.
140JShrink: In-DepthInvestigation intoDebloating ModernJava Applications ESEC/FSE ‚Äô20, November8‚Äì13,2020,VirtualEvent, USA
Cobertura[ 1]reports34.1%statementcoveragebytheirexisting
tests, which we use for assessing behavior preservation after de-
bloating.Inselectingourbenchmark,wedeliberatelychooseawide
variety of domains with varying size. We are aware of no language
construct unique to specific domains that would make JShrinkan
unworkablesolution elsewhere.
5 EXPERIMENTS
WerunJShrinkonthebenchmarkof26Javaprojectsandcompare
itwiththreeexistingtechniquestoanswerthefollowingquestions:
RQ1How much Java byte code reduction is achievable when
applyingdifferentkindsoftransformations?
RQ2To what extent program semantics is preserved when de-
bloatingsoftware?
RQ3What are the trade-offs between debloating potential and
preservationofsoftware semantics?
RQ4How robust is the debloated software to unseen executions
such as newtest cases?
5.1 Experiment Setup andBaselines
Our experiments run on an Amazon r5.xlarge instance (3.1 GHz
4-core Intel Xeon Platinum processor, 32GB Memory) with Ubuntu
18.04 and JDK 1.8.0 installed. We choose this standard cloud-based
setuptoeasethereplicationeffortforotherresearchers.Wecom-
pareJShrinkwithJax[ 61],JRed[30],andProGuard[ 6].Sinceboth
Jax and JRed are not available, we faithfully re-implement them
basedontheirpaper descriptions.
Jaxincludesthemostcomprehensivesetofbytecodetransforma-
tions. To replicate Jax, we adapt JShrinkto use static call graph
analysisonlyanddisableSection 3.3‚Äôsextensions.Jaximposesan
additionalconstraintthatrequiresunused,to-be-removedclasses
not to have any derived classes. So we modify the class collapsing
transformation accordingly.
JRedonly supports method removal and class removal. Like Jax,
JRed relies on static call graph analysis only. To replicate JRed, we
adaptJShrinkto use static call graph analysis exclusively, only
enable unused method removal and unused class removal, and
disableallextensionsfrom Section 3.3.
ProGuard is a public software that shrinks and obfuscates Java
bytecode. It has been integrated into Android SDK and is widely
usedtooptimizeAndroidapplications.SimilartoJaxandJRed,Pro-
Guardperformsstaticanalysisonly.Itdoesnotconstructcallgraphs
but instead traverses bytecode instructions in a given method to
calculateatransitiveclosureofallreferencedclasses,methods,and
fields.ProGuardhassomestaticanalysissupportforJavareflection
but is not accurate, since it only analyzes hardcoded strings passed
into a pre-defined set of reflection APIs. As ProGuard is publicly
available,we evaluate itdirectly.We use version6.3.
5.2 RQ1: CodeSizeReduction
ToanswerRQ1,weapplythefourtransformationsin JShrinkon
eachprojectindividuallyanden-masse.TheevaluationsofJax[ 61]
and JRed [ 30] in their original papers only use mainmethodsas the
entry points. However, we find that many projects (such as gson
andjava-apns inourbenchmark)arelibraryprojectswhosepublic
classes and methods are potentially invoked by downstream clientprojects. Therefore, in our experiments, we make a conservative
choiceofsettingallpublicmethods, mainmethods,andtestmethods
as entry pointsto maximally approximate possible usage.
Wereportthesizereductionofbytecodeonly,excludingresource
files. Column Transformations in Table3shows the size reduction
ratioachievedbyeachtransformation.Comparedwiththeother
threetransformations, methodremoval (Column MR)isthemost
effective in size reduction, achieving an average of 11.0% reduction
(upto 42.2%). Methodinlining (Column MI) andfieldremoval (Col-
umnFR)reducebytecodeby2.1%and1.0%respectivelyonaverage.
Class hierarchy collapsing (Column CC) only achieves a minimal
reduction of0.1%onaverage(upto 0.6%).
ColumnCode Size Reduction in Table3shows the size reduc-
tion achieved by all transformations, compared with Jax, JRed, and
ProGuard. Specifically, Column JShrink-C shows the size reduc-
tionwhenenablingthecheckpointfeaturetoautomaticallyreverse
failure-inducingtransformations.Whenapplyingalltransforma-
tions together, JShrinkcan reduce a project by up to 46.8% (14.2%
onaverage).Checkpointingonlyhasaminimalimpactonsizere-
duction(0.9%lessreduction)whileachieving100%semanticpreser-
vation.JRedhasthesmallestsizereduction(13%onaverage).Thisis
because JRed only supports two kinds of transformations, method
removal and class removal. Though both Jax and JShrinksupport
the same set of transformations, Jax achieves a larger size reduc-
tion,17.0%incomparisonto14.2%in JShrinkfortworeasons.First,
JShrinkretainsdynamicallycalledmethodsandloadedmethods.
Second,JShrinkpartially debloats reference-only classes, while
Jaxcompletely removes them.
ProGuardcrashesontwoprojectsduetoaknownbugwhileper-
forming partial evaluation on strings [ 5]. Compared with JShrink,
ProGuard reduces code more aggressively (33.8% on average). A
main reason is that it performs static reference-based analysis, pro-
ducingasmallersetofreachablemethods.Indeed,forsomeprojects
(e.g., jvm-tools and gwt-cal), ProGuard achieves significantly more
code reduction than JShrinkwithout breaking any tests. However,
ingeneral,ProGuard causes6X more test failures thanJShrink,as
elaboratedinthe nextsection.
5.3 RQ2: Semantic Preservation
Codesize reduction, however, is onlymeaningful if thesemantics
of the targetprogram ispreserved. Toassesshowclosely JShrink
preservesprogramsemantics,werunexistingtestcasesbeforeand
afterdebloating.Aprogramisconsideredtohavebrokensemantics
ifthereexistanytestfailuresafterdebloating.Column TestFailures
showsthesemanticpreservationcapabilityof JShrink,Jax,JRed,
and ProGuard. ≈Ç‚úì≈æ denotes a project with no test failure after
debloating,while≈Ç √ó≈ædenotesthattestfailuresexistafterdebloating.
The numbers inbracketsshowthe numbers of failingtests.
Whencheckpointing is enabled, JShrinkachieves 100% behav-
ior preservation as expected. Disabling checkpointing leads to test
failures in 4 projects only. Checkpointing does not cause signifi-
cant loss in size reduction, because a single kind of transformation,
classhierarchycollapsing ,leadstomosttestfailures(75of81)while
contributing the least in size reduction (0.1% on average). The root
causeisduetoexistingbugsinSoot.Sootthrowsruntimeexcep-
tionswhenrewritingsomeclassfiles,whichinterferesourability
141ESEC/FSE ‚Äô20, November8‚Äì13,2020,VirtualEvent, USA BobbyR. Bruce,Tianyi Zhang,Jaspreet Arora,Guoqing Harry Xu,andMiryungKim
Table 3:Results ofdebloatingthebenchmarkprojects.
Application TestsTransformations CodeSizeReduction TestFailures
MRFRCCMIJRedJaxProGuard TamiFlex JShrink JShrink-C JRed JaxProGuard TamiFlex JShrink JShrink-C
jvm-tools 1021.7%0.6%0.0%2.0%2.2%5.2% 12.2% 4.2% 4.2% 4.2%‚úì(0)√ó(102)‚úì(0)‚úì(0)‚úì(0)‚úì(0)
bukkit 90615.4% 1.2%0.2%1.9%19.8%24.0% 72.7% 18.5% 18.5% 18.5% √ó(906)√ó(906) √ó(3)√ó(39)‚úì(0)‚úì(0)
qart4j 142.2% 3.7%0.2%0.9%58.0%64.2% 84.8% 46.8% 46.8% 46.8%‚úì(0)‚úì(0)‚úì(0)‚úì(0)‚úì(0)‚úì(0)
dubbokeeper 113.8% 1.5%0.2%1.9%17.2%20.9% 73.1% 17.3% 17.3% 17.3% √ó(1)√ó(1)‚úì(0)‚úì(0)‚úì(0)‚úì(0)
frontend-maven-plugin 618.7% 1.6%0.2%2.0%24.3%28.2% 65.8% 22.4% 22.4% 22.4%‚úì(0)‚úì(0)‚úì(0)‚úì(0)‚úì(0)‚úì(0)
gson 10500.3%0.8%0.0%4.4%0.4%5.8% 2.3% 5.5% 5.5% 5.5% √ó(1)√ó(1) √ó(58)‚úì(0)‚úì(0)‚úì(0)
disklrucache 610.1%1.3%0.0%0.2%0.1%1.9% 0% 1.7% 1.7% 1.7%‚úì(0)‚úì(0)‚úì(0)‚úì(0)‚úì(0)‚úì(0)
retrofit1-okhttp3-client 98.4%0.9%0.0%2.2%11.0%14.5% 22.7% 12.3% 11.5% 11.5% √ó(9)√ó(9) √ó(3) √ó(3)‚úì(0)‚úì(0)
rxrelay 5815.7% 1.1%0.0%0.7%17.5%19.3% 63.5% 17.5% 17.5% 17.5% √ó(28)√ó(58)‚úì(0)‚úì(0)‚úì(0)‚úì(0)
rxreplayingshare 2020.1% 0.9%0.2%0.9%24.1%27.5% 91.9% 22.1% 22.1% 22.1% √ó(20)√ó(20)‚úì(0)‚úì(0)‚úì(0)‚úì(0)
junit4 10811.7%0.5%0.1%4.8%2.3%8.0% 9.0% 6.5% 6.8% 1.4%√ó(1081)√ó(1081) √ó(43) √ó(17)√ó(13)‚úì(0)
http-request 1630.2%2.6%0.0%3.8%0.3%6.7% 0.1% 6.6% 6.6% 6.6%‚úì(0)‚úì(0) √ó(15)‚úì(0)‚úì(0)‚úì(0)
lanterna 340.2%0.8%0.6%1.9%0.2%2.4% 0% 1.9% 2.0% 2.0%‚úì(0)√ó(34)‚úì(0)‚úì(0)‚úì(0)‚úì(0)
java-apns 11113.8% 1.3%0.3%3.4%16.0%21.9% 34.4% 18.9% 18.9% 18.9% √ó(9)√ó(107) √ó(18)‚úì(0)‚úì(0)‚úì(0)
mybatis-pagehelper 10620.1% 1.4%0.1%2.3%25.5%28.6% 65.0% 24.7% 23.9% 21.6% √ó(106)√ó(106) √ó(83)√ó(100)√ó(55)‚úì(0)
algorithms 4930.0%0.3%0.0%5.1%0.0%5.6% 3.8% 5.5% 5.5% 5.5%‚úì(0)‚úì(0)‚úì(0)‚úì(0)‚úì(0)‚úì(0)
fragmentargs 158.9%2.7%0.0%0.1%11.0%14.7% 16.8% 11.6% 11.6% 0.0% √ó(4)√ó(4) √ó(4) √ó(4)√ó(4)‚úì(0)
moshi 8350.2%0.0%0.0%0.0%0.2%0.3% 58.2% 0.2% 0.2% 0.2%√ó(835)√ó(835) √ó(52)‚úì(0)‚úì(0)‚úì(0)
tomighty 2616.5% 1.5%0.1%2.2%20.7%24.7% 56.4% 20.2% 20.1% 20.1%‚úì(0)‚úì(0)‚úì(0)‚úì(0)‚úì(0)‚úì(0)
zt-zip 1215.4%2.4%0.6%2.9%6.4%13.3% 16.4% 11.3% 11.3% 11.3% √ó(110)√ó(110) √ó(115)‚úì(0)‚úì(0)‚úì(0)
gwt-cal 9216.5% 0.7%0.1%0.3%19.4%20.8% 31.6% 17.5% 17.5% 17.5% √ó(3)√ó(3)‚úì(0)‚úì(0)‚úì(0)‚úì(0)
Java-Chronicle 80.0%1.1%1.0%1.4%0.0%3.5% 0.0% 3.5% 3.5% 3.5%‚úì(0)‚úì(0)‚úì(0) √ó(8)‚úì(0)‚úì(0)
maven-config-processor-plugin 7725.4% 3.2%0.3%1.0%31.5%35.3% 82.0% 29.8% 29.8% 29.8% √ó(21)√ó(21) √ó(20)‚úì(0)‚úì(0)‚úì(0)
jboss-logmanager 4211.1% 0.5%0.04%1.9%11.7%14.3% 17.0% 26.2% 13.6% 13.6%‚úì(0)‚úì(0) √ó(24)‚úì(0)‚úì(0)‚úì(0)
autoLoadCache 1116.5% 1.5%0.3%1.9%18.2%21.9% Crash 20.2% 20.2% 16.5% √ó(10)√ó(10) Crash √ó(7)√ó(9)‚úì(0)
tprofiler 34.7%4.1%0.0%1.4%6.5%13.5% Crash 10.2% 10.2% 10.2%‚úì(0)‚úì(0) Crash‚úì(0)‚úì(0)‚úì(0)
Total 5432 √ê√ê√ê√ê√ê√ê √ê √ê √ê √ê3174 3408 496 170 81 0
Mean 20911.0% 1.0%0.1%2.1%13.0%17.0% 33.8% 15.0% 14.2% 13.3% √ê √ê √ê √ê √ê √ê
Median 609.9%1.23% 0.1%1.9%11.4%14.6% 19.8% 14.8% 12.6% 12.5% √ê √ê √ê √ê √ê √ê
toupdateall classfilesthat referenceamerged class whencollaps-
ing class hierarchies. By simply reverting failure-inducing class
collapsingtransformations, JShrinkavoids mosttest failures.
By contrast, JRed, Jax, and ProGuard cause test failures in 15,
17, and 11 projects. Without checkpointing, only 81 of 5432 test
cases fail after debloating using JShrink. This gives JShrink a
test pass rate of 98.5%, in comparison to 41.6%, 37.3%, and 91%
byJRed,Jax,andProGuardrespectively.Thisindicatesthatincor-
poratingdynamicprofiling,type-dependencyanalysis,andthose
nuanced extensions are crucial to semantics preservation. The ma-
jorityoftestfailurescausedbyJRedandJaxareduetofatalJVM
NoClassDefFoundError andClassNotFoundException verifica-
tion errors that crash the entire test execution √ê for JRed, 10 of 26
projectsfailwiththesefatalexceptions,whileusingJaxresultsin13
projectsfailing fatally. For ProGuard,most test failuresare caused
by imprecise static analysis. Though ProGuard strives to handle
Java reflection by statically analyzing string arguments passed into
a predefined set of reflection APIs, such static analysis is neither
accurate nor complete, which justifies our choice of augmenting
staticanalysiswithprofiling for dynamiclanguagefeatures.
5.4 RQ3: Trade-offs
Tounderstandthetrade-offsbetweendebloatingpotentialandse-
mantic preservation, we vary entry points for JShrink‚Äôs reachabil-
ityanalysisandcomparewithanalternativeprofilerTamiFlex[ 11].
Entrypointanalysis. AsdiscussedinSection 3,JShrinkfunctions
by running call-graph analysis on entry points. These entry points
areaunionoftwosets:thesetofdynamicallyaccessedmethods
determined via runtime profiling, and the set of all public, main,
and test methods, determined via static analysis. While the former
isdependentonthetestsuiteofeachproject,thelattercanbesetmanually.E.g.,auserof JShrinkmaydeterminethatonlythe main
entry point needs to be processed as it is the only known entry
point to the application. Such decisions may result in a smaller
call-graph and thus increase the debloating potential of a target
project. On the other hand, selectingfewer entrypoints can make
the debloated software less robust without complete knowledge
ofusedmethods.Forexample,amethodmayberemoveddespite
being usedbythe projectviasomeunexploredentry point.
To understand this trade-off, we run JShrinkon all our projects
using the mainmethod as an entry point, the public methods, and
just the test methods alone as entry points. Table 4shows the
experiment results with the baseline where all such methods are
consideredasentrypoints.Thesizereductionisconsistentlylarger
whenweselectasubsetofentrypointstothereachabilityanalysis.
When targeting the test entry points, projects can be debloated
by 36.6% more than our conservative baseline. Though, in every
case where a subset of entry points are chosen, the number of test
failuresincreases.Whileonly1.5%ofalltestsfailwhentargeting
allentrypoints,thisfigurejumpsto3.4%,a70%increaseintestcase
failures, when selecting a subset.We therefore conclude thatthe
size reduction and robustness depend on what we choose as entry
points. If preserving program semantics is a hard constraint, we
suggest the conservative choice of setting all possible entry points.
Table 4:Entry PointAnalysis.
EntryPoint SizeReduction Test Failures
Main, Test,&Public 14.2% 81 (1.5%)
MainOnly 18.6% 186(3.4%)
AppPublic Only 18.3% 157(2.9%)
Test Only 19.4% 187(3.4%)
142JShrink: In-DepthInvestigation intoDebloating ModernJava Applications ESEC/FSE ‚Äô20, November8‚Äì13,2020,VirtualEvent, USA
Jmtracevs.TamiFlex. AsdiscussedinSection 3.1,ournativeprofiler,
Jmtrace, uses JVMTI to instrument method bodies in any classes
loaded in a JVM. Therefore, it can capture all dynamically invoked
methods. By contrast, TamiFlex [ 11] only instruments a predefined
setofreflectionAPIsandthusisconsideredmorelight-weight.The
twoTamiF.columns in Table 3show the size reduction and test
failures caused by the TamiFlex variant of JShrink. TamiFlex only
identifies a subset of dynamic method calls captured by Jmtrace
andthusshouldtrimmoreunreachablemethods.However,thesize
reduction improvement achieved by TamiFlex is trivial, only 0.06%
onaverage.Ontheotherhand, JShrinkwithTamiFlexbreaks52
more test casesincomparison to JShrinkwithJmtrace.
An in-depth inspection. To investigate which extension aid in im-
provingbehaviorpreservation,wechooseoneproject, java-apns
forathoroughinvestigationintoeachfailure.Thisisbecausethere
are a total of 3174 and 3408 test failures for JRed and Jax respec-
tively;thus,itwouldbeprohibitivelytimeconsumingtoexamine
alltestfailuresindividuallyforallprojects. Java-apns produces107
testfailuresafterJaxbutwaserror-freewhenprocessedby JShrink.
Wemanuallyexamineanddeterminewhatextensionwasresponsi-
ble for rectifying the failure. Incorporation of Jmtracereduced test
failuresby59%.The restoftheenhancements suchastypedepen-
dencyanalysisallcontributetoimprovingatestpassrate,butnone
was the dominant contributor. This result indicates that handling
dynamic language features is absolutely necessary, while each of the
remaining enhancementscontributesto behaviorpreservation.
5.5 RQ4: Robustness
Finally, we assess the robustness of debloated software by running
new tests not seen during dynamic profiling. We use 80% of the
originaltestsuiteineachprojectforprofilinganddebloating.Then
weusetheremaining20%asa hold-outtestset forexaminingthe
robustnessofeachdebloatedproject.Webuildthis20%hold-out
setbyselectingclasseswiththeleastnumberoftestsinorder.This
leaves fewer classes for dynamic profiling and thus we conserva-
tivelyestimate the number of test successes. For the three projects
withonetestcase,weonlyusetheirtests,asis.Thehold-outtest
setcontains 42 test casesonaverage.
JShrinkdoes not cause any test failures in 22 out of 26 projects
whenrunningthedebloatedprojectonitshold-outtestset. JShrink
causes 3, 5, 45, and 1 test failures in the remaining four projects
respectively√ê retrofit1-okhttps3-client ,junit,java-apns ,
andautoLoadCache . This implies that, though there is a chance
that unseen executions may cause runtime exceptions in debloated
software, the chance isrelatively low √ê only4 outof26 projects
(15%) in our benchmark. This should be attributed to the design
choiceofusingbothstaticreachabilityanalysisanddynamicpro-
filing inJShrink. While dynamic profiling precisely captures all
invoked methods in previous executions and handles dynamic fea-
tures,staticreachabilityanalysisover-approximatesotherpotential
reachable code fromgivenentry points,improvingthe robustness
of debloated software compared to purely dynamic profiling alone.
6 DISCUSSION
Whilewedonotclaimthatdebloatingtransformationsdiscussed
inthispaperare100%ourowncreations,wemadesignificantex-
tensions to make debloating much safer and evaluate them in amodern context. In previous work, behavior preservation of de-
bloated programs is never evaluated. Our contribution is to give
the software engineering community better understanding of how
these debloating transformations perform, especially in terms of
behaviorpreservation,inreal-worldapplicationswithdynamiclan-
guagefeatures.Weprovidedevidencethatexistingtransformations
sufferedfrompoorbehaviorpreservation.Byfurtherincorporat-
ingnewcomponentstoensuretypesafety,wedemonstratedthat
behaviorcanbepreservedtoasignificantlygreaterextent.While
ourtechniqueslackanexoticflair,theyundeniablyworkandwe
are the firstto demonstratethis withrigorous evaluation.
Attack Surface Removal. Software debloating could also poten-
tiallyremovesecurityvulnerabilitiesinaprogram.Todemonstrate
the benefit of attack surface removal, we conduct a case study of a
gadget-chain deserialization vulnerability in Java [ 7]. This vulnera-
bilityallows remote attackers to execute arbitrary commands by
carefully crafting a payload of serialized Java classes (i.e., gadget
chains).Agadgetchainincludesa≈Çkick-off≈ægadgetthatisexecuted
duringorafterdeserialization,a≈Çsink≈ægadgetthatexecutesarbi-
trary commands during instantiation, and other auxiliary gadgets
thatcreateachainfromthestartgadgetexecutiontoendgadget.
Frohoff et al. discovered a collection of 31 distinct gadget chains
inJDKandpopularJavalibrariesandpresentaproof-of-concept
tool called ysoserial that automatically generates payloads of
thesegadgetchains[ 8].Basedontheseknowngadgetchains,we
automatically scan libraries and classes and detect the presence of
gadgetchainsthatcanbepotentiallyexploitedbyremoteattackers.
If a method or a class in a gadget chain is successfully removed,
the gadget chain will be effectively removed and the attack surface
shallceasetobeathreat.Runningourgadget-chainanalysis,we
detect two gadget chains in one project, dubbokeeper in our bench-
mark. Both gadget chains involve unsafe classes and methods in
imported libraries from Spring Framework, awidely used web ap-
plicationframeworkinJava.Thesegadgetchainshavealsobeen
reported multipletimes assecurityvulnerabilities, e.g.,CVE-2017-
8045,CVE-2017-3203,CVE-2016-2173.Afterapplying JShrink,both
gadgetsin dubbokeeper areremoved.Henceexploitingthesamegad-
get chain in dubbokeeper will only lead to ClassNotFoundException ,
rather than arbitrary code execution after debloating. Jax and JRed
removed both gadget chains but at the cost of test failures, and
ProGuardremovedonlyoneofthetwo.Thisbringsanimportant
insight that JShrinkis more successful than existing techniques in
terms ofboth behaviorpreservationandgadget chain removal.
Threatstovalidity. Whilereplicatingbytecodetransformations
described in Jax [ 61], our implementation is different from [ 61]
is two aspects. First, when merging two classes, the original Jax
algorithm requires that the number of reachable field members in
thenewclassaftermergingdoesnotincrease,inordertoensurethat
thenewclassdidnotconsumemorememorywheninstantiated.We
ignorethisconstraintin JShrink,becauseourmaingoalistoreduce
code size not memory consumption. Second, method inlining in
Jax is originally implemented by simply adding a finalmodifier
to an inlinable method so that the just-in-time (JIT) compiler in
JVMcaninlinethemethod.However,thisistrickyasJITcompilers
alsoapplytheirownheuristicstodecidewhetheramethod,though
declared as final, could be inlined. So we implement our own
143ESEC/FSE ‚Äô20, November8‚Äì13,2020,VirtualEvent, USA BobbyR. Bruce,Tianyi Zhang,Jaspreet Arora,Guoqing Harry Xu,andMiryungKim
inliningtransformationusingSoot‚ÄôsAPIs.Thispotentiallyproduces
betterresults thanthe originalimplementationin[ 61].
In Section 5, we reimplement Jax and JRed by adapting JShrink
basedontheirpapers.Thesizereductionnumbersreportedfrom
their original Jax and JRed papers are higher, at 48.7% and 44.5% re-
spectively.Thisisbecauseweconservativelychooseallpublic, main,
andtestmethodsasentrypoints,whiletheiroriginalexperiment
usedmainmethodsas the entry pointsonly.
Limitation. Ourgoalistoassesssizereductionpotentialbasedon
bothstaticanalysisanddynamicprofilingusing developer-written
tests.Weacknowledgethatdeveloper-writtentestsmaysufferfrom
low-coverageissues and thus cannotrepresent possibleexecution
scenarios that may be encountered in the future. To investigate
this issue, we examine how robust a debloated project is to unseen
executions in a hold-out test set in Section 5.5. The result shows
thatthoughunseenexecutionsindeedcauseruntimeexceptions,
the chance of running into such issues is relatively low (15%). This
isbecausestaticreachabilityanalysisanddynamicprofilingsyn-
ergisticallyworktogethertohandleunseenexecutions≈õ dynamic
profiling already provides good hints of dynamically invoked method
even with an incomplete set of test cases, and static reachability anal-
ysis over-approximates reachable code from all possible entry points.
The solution toreducing thisrateof failure isto increasetest case
coverage by either by manually adding tests, or via automated
regressiontest generationtools,such as EvoSuite [ 23].
7 RELATED WORK
CodeBloat. Codesizereductionisanimportantdevelopmentac-
tivity in areas such as networking and embedded systems. A large
body of work exists on code compression [ 16,19,32,35,36] and
codecompaction[ 18,65,66]toreducethesizeofbinarycodefor
efficientexecutionsonembeddedhardwarewithlimitedmemory.
We refer interested readers to Besz√©des et al. [ 10] for a detailed
survey.Programslicing[ 28,49,56,57,60]isadataflow-basedstatic
technique that computes, from a given seed, a subset of statements
that can still form a valid and executable program. Slicing reduces
codesizebycomputingadependencegraphandpreservingonly
the statementsthataredirectly ortransitivelyreachablefromthe
seed on the graph. Fine-grained static slicing is known to have
limitationsduetoimprecisionofheapmodelingandpointerhan-
dling and thus does not work well for large-scale applications with
pointers,reflection,anddynamicclassloading.Soto-Valeroetal.in-
vestigatedlibrarydependencydebloatinmavenprojects.Compared
withJShrink, theiranalysisis coarse-grainedatthe librarydepen-
dency level [ 55]. Therefore, their debloating technique can only
remove unused libraries,rather thanunused codewithina library.
Furthermore, their analysis is purely static and does not account
for dynamic features, which GitHub developers reported as an
importantconcernintheirqualitative study.
The past two years have seen a proliferation of debloating
techniques [ 21,27,46,47,52,67] designed for various domains,
including JavaScript programs [ 67], application containers (e.g.,
docker)[21],ornativeCprograms[ 46,47].Theserangefromstatic
analysis[ 21,52]toload/runtimetechniques[ 46]andmachinelearn-
ing[27].However,nonetargetmodernJava,notoriouslydifferent
fromnativeprogramsintermsofmemorymanagementordynamicmethodinvocation.Thispaperrevisitsandextendsexistingbyte-
code transformation techniques, quantifies debloating potential,
andchecksbehaviorpreservationwithreal world tests.
DeltaDebugging. Given a test oracle, delta-debugging based tech-
niques can repeatedly split the original program into different
sub-programsandre-checkthetestoracletoproduceadebloated
program[ 31,48,59,76].Forexample,JReduce[ 31]partitionsthe
originalprogramintotransitiveclosuresbasedonclass-leveldepen-
denciesandisolatesadebloatedprogramthatstillpassesthetest.
Chisel [27] uses reinforcement learning to reduce the number of
search iterationsduring deltadebugging. Whilethese approaches
ensurebehaviorpreservationofdebloatedsoftwarebyrepeatedly
runningexistingtestsoneachintermediateprogram,theysuffer
from two limitations√ê(1) the resulting debloated software may not
retain any functionality beyond test-exercised code, simply reflect-
ingtestcoverage,and(2)thedebloatedsoftwarecannotbeeasily
configuredtoretaincodestaticallyreachablefrompublicAPIsor
main method entries, since designing such oracle would be exactly
the same taskwe undertook in JShrink.
Runtime Bloat. Researchers have proposed a range of dynamic
techniquesthatlookforinefficienciesindatastructureusage[ 44,69,
70], object lifetime patterns [ 71], or reference copy chains [ 72,75].
Suchruntimebloatworkisorthogonaltothisworkthatremoves
code bloat viastaticbytecode transformations.
8 CONCLUSION
Software debloating is a long standing problem. Some even con-
sider this problem to have been solved 20 years ago through static
reachability-analysis based code transformation. We therefore set
out to extend and rigorously evaluate software debloating transfor-
mationsinthecontextofmodernJava.Unlikepreviousresearch,
we handled dynamic language features, ensured type safety, and
tookmeasurestopasstheJVMsbytecodeverificationchecks.We
found that prior work falls short of behavior preservation , meaning
debloated software no longer passes the same tests, with a test fail-
urerateofupto62.7%.Suchlackofbehaviorpreservationwould
makeitimpossibletoadoptdebloatingtechniquesinpractice,as
no one would like to remove unused code at the cost of breaking a
majority ofexisting tests.
To the best of our knowledge, we are the first that systemati-
callyquantifysizereduction,behaviorpreservation,andthebenefit
of dynamic profiling in software debloating. Our results should
be transferable to a wide range of software such as mobile appli-
cations, which typically run on resource-constrained hardware.
Resourceintensivecloud-basedservicesmayalsobenefitfromsoft-
ware optimized to occupy less space, or to be downloaded in a
smallerpackage,ergoconsuminglessbandwidth.Tosupportthe
open-sciencepolicy,we presentoursourcecodeanda replication
package at https://doi.org/10.6084/m9.figshare.12435542 .
ACKNOWLEDGMENTS
Wethanktheanonymousreviewersfortheircomments.Thepartic-
ipants of this research are in part supported by ONR grant N00014-
18-1-2037;NSFgrantsCCF-1764077,CCF-1527923,CCF-1723773;
an Intel CAPA grant; a Samsung grant; and the Alexander von
HumboldtFoundation.
144JShrink: In-DepthInvestigation intoDebloating ModernJava Applications ESEC/FSE ‚Äô20, November8‚Äì13,2020,VirtualEvent, USA
REFERENCES
[1][n.d.]. Cobertura:AcodecoverageutilityforJava. https://cobertura.github.io/
cobertura . Accessed:2020-02-16.
[2][n.d.]. Google BigQuery API and GitHub Dataset. https://cloud.google.com/
bigquery/public-data/ . Accessed:2020-04-04.
[3][n.d.]. JVM TI APIs. https://docs.oracle.com/javase/8/docs/technotes/guides/
jvmti/. Accessed:2020-04-04.
[4][n.d.]. ONR BAA Announcement # N00014-17-S-B010. https://www.onr.
navy.mil/-/media/Files/Funding-Announcements/BAA/2017/N00014-17-S-
B010.ashx . Accessed:2019-05-13.
[5][n.d.]. ProGuardBug#767:Amisjudgementexceptionoccurswhilepreverifying.
https://sourceforge.net/p/proguard/bugs/767 . Accessed:2020-04-04.
[6][n.d.]. ProGuard:JavaandAndroidAppsOptimizer. https://www.guardsquare.
com/en/products/proguard . Accessed:2019-12-13.
[7][n.d.]. Why The Java Deserialization Bug Is A Big Deal. Available from
www.darkreading.com. https://www.darkreading.com/informationweek-home/
why-the-java-deserialization-bug-is-a-big-deal/d/d-id/1323237
[8][n.d.]. ysoserial: a proof-of-concept tool for generating payloads that exploit
unsafeJavaobjectdeserialization. https://github.com/frohoff/ysoserial . Accessed:
2019-05-10.
[9]David F Bacon and Peter F Sweeney. 1996. Fast static analysis of C++ virtual
function calls. ACM Sigplan Notices 31, 10 (1996), 324≈õ341. https://doi.org/10.
1145/236338.236371
[10]√Årp√°d Besz√©des, Rudolf Ferenc, Tibor Gyim√≥thy, Andr√© Dolenc, and Konsta
Karsisto. 2003. Survey of Code-size Reduction Methods. ACM Computer Survey
35,3 (2003), 223≈õ267. https://doi.org/10.1145/937503.937504
[11]Eric Bodden, Andreas Sewe, Jan Sinschek, Hela Oueslati, and Mira Mezini. 2011.
Taming Reflection: Aiding Static Analysis in the Presence of Reflection and
Custom Class Loaders. In Proceedings of the 2011 International Conference on
SoftwareEngineering√êICSE‚Äô11 .ACM,241≈õ250. https://doi.org/10.1145/1985793.
1985827
[12]EricBruneton,RomainLenglet,andThierryCoupaye.2002. ASM:Acodema-
nipulation tool to implement adaptable systems. In Adaptable and extensible
component systems .
[13]ErikBuchanan,RyanRoemer,HovavShacham,andStefanSavage.2008. When
goodinstructionsgobad:Generalizingreturn-orientedprogrammingtoRISC.
InProceedings of the 2008 ACM conference on Computer and Communications
Security√êCCS‚Äô08 . ACM,27≈õ38. https://doi.org/10.1145/1455770.1455776
[14]Jeffrey C. Carver, Natalia Juristo, Maria Teresa Baldassarre, and Sira Vegas. 2014.
ReplicationsofSoftwareEngineeringExperiments. EmpiricalSoftw.Engg. 19,2
(April2014),267≈õ276. https://doi.org/10.1007/s10664-013-9290-8
[15]Ahmet Celik, Alex Knaust, Aleksandar Milicevic, and Milos Gligoric. 2016. Build
systemwithlazyretrievalforJavaprojects.In Proceedingsofthe2016SIGSOFT
International Symposium on Foundations of Software Engineering √ê FSE ‚Äô16 . ACM,
643≈õ654. https://doi.org/10.1145/2950290.2950358
[16]KeithD.CooperandNathanielMcIntosh.1999. EnhancedCodeCompressionfor
EmbeddedRISCProcessors.In Proceedingsofthe1999ConferenceonProgramming
LanguageDesignandImplementation√êPLDI‚Äô99 .ACM,139≈õ149. https://doi.org/
10.1145/301631.301655
[17]JeffreyDean,DavidGrove,andCraigChambers.1995. Optimizationofobject-
oriented programs using static class hierarchy analysis. In Proceedings of the
1995 European Conference onObject-Oriented Programming √ê ECOOP ‚Äô95 .https:
//doi.org/10.1007/3-540-49538-X_5
[18]SaumyaK.Debray,WilliamEvans,RobertMuth,andBjornDeSutter.2000. Com-
piler Techniques for Code Compaction. Transactions on Programming Languages
and Systems 22,2 (2000), 378≈õ415. https://doi.org/10.1145/349214.349233
[19]JensErnst,WilliamEvans,ChristopherW.Fraser,ToddA.Proebsting,andSteven
Lucco. 1997. Code Compression. In Proceedings of the 1997 Conference on Pro-
gramming Language Design and Implementation √ê PLDI ‚Äô97 . ACM, 358≈õ365.
https://doi.org/10.1145/258916.258947
[20]Robert Feldt, Tim Menzies, and Thomas Zimmermann. 2018. The 26th
ACM Joint European Software Engineering Conference and Symposium on
the Foundations of Software Engineering (ESEC/FSE 2018), ROSE Festival
2018 Recognizing and Rewarding Open Science in Software Engineering.
https://2018.fseconference.org/track/rosefest-2018.
[21]Kostas Ferles, Valentin W√ºstholz, Maria Christakis, and Isil Dillig. 2017. Failure-
directedProgramTrimming.In Proceedingsofthe2017SymposiumontheFounda-
tions of Software Engineering √ê FSE ‚Äô17 . ACM, 174≈õ185. https://doi.org/10.1145/
3106237.3106249
[22]GeorgeFourtounis,GeorgeKastrinis,andYannisSmaragdakis.2018. StaticAnaly-
sisofJavaDynamicProxies.In Proceedingsofthe27thACMSIGSOFTInternational
SymposiumonSoftwareTestingandAnalysis (Amsterdam,Netherlands) (ISSTA
2018). ACM, New York, NY, USA, 209≈õ220. https://doi.org/10.1145/3213846.
3213864
[23]GordonFraserandAndreaArcuri.2011. EvoSuite:automatictestsuitegeneration
forobject-orientedsoftware.In Proceedingsofthe2011ConferenceonFoundations
ofSoftwareEngineering√êFSE‚Äô11 .ACM,416≈õ419. https://doi.org/10.1145/2025113.
2025179[24]Neal Glew and Jens Palsberg. 2002. Type-safe method inlining. In Proceedings of
theEuropeanConferenceonObject-OrientedProgramming√êECOOP‚Äô02 .Springer,
525≈õ544. https://doi.org/10.1007/3-540-47993-7_22
[25]Neal Glew and Jens Palsberg. 2005. Method Inlining, Dynamic Class Loading,
and TypeSoundness. Journal ofObject Technology 4,8 (2005), 33≈õ53.
[26]David Grove, Greg DeFouw, Jeffrey Dean, and Craig Chambers. 1997. Call graph
constructioninobject-orientedlanguages. ACMSIGPLANNotices 32,10(1997),
108≈õ124. https://doi.org/10.1145/263698.264352
[27]KihongHeo,WoosukLee,PardisPashakhanloo,andMayurNaik.2018. Effective
Program DebloatingviaReinforcement Learning.In Proceedings ofthe2018 ACM
SIGSAC Conference onComputerand CommunicationsSecurity (Toronto, Canada)
(CCS ‚Äô18). ACM, New York, NY, USA, 380≈õ394. https://doi.org/10.1145/3243734.
3243838
[28]S.Horwitz,T.Reps,andD.Binkley.1988. InterproceduralSlicingUsingDepen-
dence Graphs. In Proceedings of the Conference on Programming Language Design
andImplementation√êPLDI‚Äô88 .ACM,35≈õ46. https://doi.org/10.1145/77606.77608
[29]YufeiJiang,QinkunBao,ShuaiWang,XiaoLiu,andDinghaoWu.2018. RedDroid:
Android application redundancy customization based on static analysis. In 2018
IEEE 29th International Symposium on Software Reliability Engineering (ISSRE) .
IEEE,189≈õ199. https://doi.org/10.1109/ISSRE.2018.00029
[30]Yufei Jiang, Dinghao Wu, and Peng Liu. 2016. JRed: Program customization
and bloatware mitigation based on static analysis. In Proceedings of the 2016
Computer Software and Applications Conference √ê COMPSAC ‚Äô16 . IEEE, 12≈õ21.
https://doi.org/10.1109/COMPSAC.2016.146
[31]ChristianGramKalhaugeandJensPalsberg.2019. BinaryReductionofDepen-
dency Graphs. In Proceedings of the 2019 27th ACM Joint Meeting on European
SoftwareEngineeringConferenceandSymposiumontheFoundationsofSoftware
Engineering (Tallinn, Estonia) (ESEC/FSE 2019) . ACM,New York, NY, USA, 556≈õ
566.https://doi.org/10.1145/3338906.3338956
[32]Darko Kirovski, Johnson Kin, and William H. Mangione-Smith. 1997. Procedure
Based Program Compression. In Proceedings of the 1997 International Symposium
on Microarchitecture √ê Micro ‚Äô97 . ACM, 204≈õ213. https://doi.org/10.1023/A:
1018728216668
[33]Davy Landman, Alexander Serebrenik, and Jurgen J. Vinju. 2017. Challenges
for Static Analysis of Java Reflection: Literature Review and Empirical Study. In
Proceedings of the 39th International Conference on Software Engineering (Buenos
Aires,Argentina) (ICSE‚Äô17) .IEEEPress,Piscataway,NJ,USA,507≈õ518. https:
//doi.org/10.1109/ICSE.2017.53
[34]JasonLandsborough,StephenHarding,andSunnyFugate.2015. Removingthe
kitchensinkfromsoftware.In Proceedingsofthe2015GeneticandEvolutionary
ComputationConferenceCompanion√êGECCOCompanion‚Äô15 .ACM,833≈õ838.
https://doi.org/10.1145/2739482.2768424
[35] CharlesLefurgy,EvaPiccininni,andTrevorMudge.1999. Evaluationof aHigh
Performance Code Compression Method. In Proceedings of the 1999 International
Symposium on Microarchitecture √ê Micro ‚Äô99 . 93≈õ102. https://doi.org/10.1109/
MICRO.1999.809447
[36]Haris Lekatsas, J√∂rg Henkel, and Wayne Wolf. 2000. Code Compression for
LowPowerEmbeddedSystemDesign.In Proceedingsofthe2000AnnualDesign
Automation Conference √ê DAC ‚Äô00 . 294≈õ299. https://doi.org/10.1145/337292.
337423
[37]Ondrej Lhot√°k. 2002. Spark: A flexible points-to analysis framework for Java.
(2002).
[38]YueLi,TianTan,YuleiSui,andJinglingXue.2014. Self-inferencingReflection
Resolution for Java. In ECOOP 2014 ≈õ Object-Oriented Programming , Richard
Jones(Ed.).SpringerBerlinHeidelberg,Berlin,Heidelberg,27≈õ53. https://doi.
org/10.1007/978-3-662-44202-9_2
[39]Benjamin Livshits, Dimitrios Vardoulakis, Manu Sridharan, Yannis Smaragdakis,
Ond≈ôejLhot√°k,Jos√©Amaral,Bor-YuhEvanChang,SamuelGuyer,UdayKhedker,
andAndersM√πller.2015. InDefenseofSoundiness:AManifesto. Commun.ACM
58(01 2015),44≈õ46. https://doi.org/10.1145/2644805
[40]BenjaminLivshits,John Whaley,andMonica S.Lam.2005. ReflectionAnalysis
for Java. In Proceedings of the Third Asian Conference on Programming Languages
andSystems (Tsukuba,Japan) (APLAS‚Äô05) .Springer-Verlag,Berlin,Heidelberg,
139≈õ160. https://doi.org/10.1007/11575467_11
[41]Konner Macias, Mihir Mathur, Bobby R. Bruce, Tianyi Zhang, and Miryung Kim.
2020. WebJShrink:AWebServiceforDebloatingJavaBytecode.In Proceedings
of the 28th ACM Joint European Software Engineering Conference and Symposium
on the Foundations of Software Engineering √ê ESEC/FSE ‚Äô20 . ACM.https://doi.
org/10.1145/3368089.3417934
[42]FredericP.Miller,AgnesF.Vandome,andJohnMcBrewster.2010. ApacheMaven .
Alpha Press.
[43]Nick Mitchell, Edith Schonberg, and Gary Sevitsky. [n.d.]. Four Trends Leading
to Java Runtime Bloat. IEEE Software 27, 1 ([n.d.]), 56≈õ63. https://doi.org/10.
1109/MS.2010.7
[44]Nick Mitchell and Gary Sevitsky. 2007. The Causes of Bloat, the Limits of
Health. Proceedings of the 2007 Conference on Object-Oriented Programming
Systems, Languages, and Applications √ê OOPSLA ‚Äô07 (2007), 245≈õ260. https:
//doi.org/10.1145/1297027.1297046
145ESEC/FSE ‚Äô20, November8‚Äì13,2020,VirtualEvent, USA BobbyR. Bruce,Tianyi Zhang,Jaspreet Arora,Guoqing Harry Xu,andMiryungKim
[45]Chenxiong Qian, Hong Hu, Mansour Alharthi, Pak Ho Chung, Taesoo Kim,
andWenkeLee.2019. {RAZOR}:AFrameworkforPost-deploymentSoftware
Debloating.In 28th{USENIX}SecuritySymposium( {USENIX}Security19) .1733≈õ
1750.
[46]AnhQuach,Aravind Prakash, and LokYan. 2018. Debloatingsoftwarethrough
piece-wisecompilationandloading.In Proceedingsofthe2018USENIXSecurity
Symposium√êUSENIXSecurity‚Äô18 . 869≈õ886.
[47]Vaibhav Rastogi, Drew Davidson, Lorenzo De Carli, Somesh Jha, and Patrick
McDaniel.2017. Cimplifier:AutomaticallyDebloatingContainers.In Proceedings
ofthe2017SymposiumontheFoundationsofSoftwareEngineering√êFSE‚Äô17 .ACM,
476≈õ486. https://doi.org/10.1145/3106237.3106271
[48]John Regehr, Yang Chen, Pascal Cuoq, Eric Eide, Chucky Ellison, and Xuejun
Yang.2012. Test-casereductionforCcompilerbugs.In ACMSIGPLANNotices ,
Vol. 47.ACM,335≈õ346. https://doi.org/10.1145/2254064.2254104
[49]ThomasReps,SusanHorwitz,MoolySagiv,andGenevieveRosay.1994. Speeding
Up Slicing. In Proceedings of the 1994 Symposium on Foundations of Software
Engineering √êFSE ‚Äô94 . ACM,11≈õ20. https://doi.org/10.1145/195274.195287
[50]IEEE Security and Privacy. 2019. A list of CS conferences with ≈ÇSoK≈æ tracks.
https://oaklandsok.github.io/others/.
[51]MarcShapiroandSusanHorwitz.1997. Fastandaccurateflow-insensitivepoints-
to analysis. In Proceedings of the 24th ACM SIGPLAN-SIGACT symposium on
Principlesofprogramminglanguages .ACM,1≈õ14. https://doi.org/10.1145/263699.
263703
[52]HashimSharif,MuhammadAbubakar,AshishGehani,andFareedZaffar.2018.
TRIMMER: Application Specialization for Code Debloating. In Proceedings of
the2018InternationalConferenceonAutomated SoftwareEngineering√ê ASE‚Äô18 .
ACM,329≈õ339. https://doi.org/10.1145/3238147.3238160
[53]Olin Shivers. 1991. Control-flow analysis of higher-order languages . Ph.D. Disser-
tation. Citeseer.
[54]YannisSmaragdakis,GeorgeBalatsouras,GeorgeKastrinis,andMartinBraven-
boer. 2015. More Sound Static Handling of Java Reflection. In APLAS.https:
//doi.org/10.1007/978-3-319-26529-2_26
[55]C√©sarSoto-Valero,NicolasHarrand,MartinMonperrus,andBenoitBaudry.2020.
AComprehensiveStudyofBloatedDependenciesintheMavenEcosystem. arXiv
preprint arXiv:2001.07808 (2020).
[56]Manu Sridharan, Stephen J. Fink, and Rastislav Bodik. 2007. Thin Slicing. In Pro-
ceedings of the Conference on Programming Language Design and Implementation
√êPLDI‚Äô07 . ACM,112≈õ122. https://doi.org/10.1145/1250734.1250748
[57]VenkateshSrinivasanandThomasReps.2016. AnImprovedAlgorithmforSlicing
Machine Code. In Proceedings of the Conference on Object-Oriented Programming,
Systems, Languages, and Applications √ê OOPSLA ‚Äô16 . ACM, 378≈õ393. https:
//doi.org/10.1145/3022671.2984003
[58]LiSui,JensDietrich,MichaelEmery,ShawnRasheed,andAmjedTahir.2018. On
theSoundnessofCallGraphConstructioninthePresenceofDynamicLanguage
Features-ABenchmarkandToolEvaluation.In AsianSymposiumonProgramming
Languages and Systems . Springer, 69≈õ88. https://doi.org/10.1007/978-3-030-
02768-1_4
[59]Chengnian Sun, Yuanbo Li, Qirun Zhang, Tianxiao Gu, and Zhendong Su. 2018.
Perses: syntax-guided program reduction. In Proceedings of the 40th International
Conference on Software Engineering . ACM, 361≈õ371. https://doi.org/10.1145/
3180155.3180236
[60]Frank Tip. 1994. A Survey of Program Slicing Techniques. Technical Report.
Amsterdam,The Netherlands, The Netherlands.
[61]Frank Tip, Chris Laffra, Peter F. Sweeney, and David Streeter. 1999. Practical
Experience with an Application Extractor for Java. In Proceedings of the 1999
ConferenceonObject-orientedProgramming,Systems,Languages,andApplications√êOOPSLA‚Äô99 . ACM,292≈õ305. https://doi.org/10.1145/320384.320414
[62]FrankTip,PeterFSweeney,ChrisLaffra,AldoEisma,andDavidStreeter.2002.
Practical extraction techniques for Java. ACM Transactions on Programming
LanguagesandSystems√êTOPLAS‚Äô02 24,6(2002),625≈õ666. https://doi.org/10.
1145/586088.586090
[63]Mohsen Vakilian, Raluca Sauciuc, J David Morgenthaler, and Vahab Mirrokni.
2015. Automated decomposition of build targets. In Proceedings of the 2015
InternationalConferenceonSoftware Engineering√êICSE‚Äô15 .IEEEPress,123≈õ133.
https://doi.org/10.1109/ICSE.2015.34
[64]RajaVall√©e-Rai,PhongCo,EtienneGagnon,Laurie Hendren,PatrickLam,and
VijaySundaresan.1999. Soot√êAJavaBytecodeOptimizationFramework.In
Proceedingsofthe1999ConferenceoftheCentreforAdvancedStudiesonCollabora-
tive Research √ê CASCON ‚Äô99 . IBM Press, 13≈õ23. https://doi.org/10.1145/1925805.
1925818
[65]R.vandeWiel,L.Augusteijn,A.Bink,andP.Hoogendijk.2001. Codecompaction:
Reducing memorycostof embedded software. Philips WhitePaper.
[66]R. van de Wiel and P. Hoogendijk. 2001. Belt-tightening in software. Philips Res.
Passw. Mag.., 16≈õ19pages.
[67]H.C. Vazquez, A. Bergel, S. Vidal, J.A. Diaz Pace, and C. Marcos. 2019. Slim-
ming Javascript applications:Anapproach for removing unused functions from
Javascript libraries. Information and Software Technology 107 (2019), 18≈õ29.
https://doi.org/10.1016/j.infsof.2018.10.009
[68]Dongpeng Xu, Jiang Ming, Yu Fu, and Dinghao Wu. 2018. VMHunt: A verifiable
approach to partially-virtualized binary code simplification. In Proceedings of the
2018 ACM SIGSAC Conference on Computer and Communications Security . ACM,
442≈õ458. https://doi.org/10.1145/3243734.3243827
[69]GuoqingXu.2012. FindingReusableDataStructures.In Proceedingsofthe 2012
ConferenceonObject-OrientedProgrammingSystems,Languages,andApplications
√êOOPSLA‚Äô12 . ACM,1017≈õ1034. https://doi.org/10.1145/2398857.2384690
[70]Guoqing Xu. 2013. CoCo: Sound and Adaptive Replacement of Java Collections.
InProceedings of the 2013 European Conference on Object-Oriented Programming
√êECOOP‚Äô13 . Springer, 1≈õ26. https://doi.org/10.1007/978-3-642-39038-8_1
[71]GuoqingXu.2013. Resurrector:ATunableObjectLifetimeProfilingTechnique
for Optimizing Real-world Programs. In Proceedings of the 2013 Conference on
Object Oriented Programming Systems Languages and Applications √ê OOPSLA ‚Äô13 .
ACM,111≈õ130. https://doi.org/10.1145/2509136.2509512
[72]GuoqingXu,MatthewArnold,NickMitchell,andAtanasRounteva√±dGarySevit-
sky.2009. Gowiththeflow:Profilingcopiestofindruntimebloat.In Proceedings
ofthe2009ConferenceonProgrammingLanguageDesignandImplementation√ê
PLDI‚Äô09. ACM,419≈õ430. https://doi.org/10.1145/1542476.1542523
[73]Guoqing Xu, Matthew Arnold, Nick Mitchell, Atanas Rountev, Edith Schonberg,
and Gary S evitsky. 2010. Finding Low-Utility Data Structures. In Proceedings
ofthe2010ConferenceonProgrammingLanguageDesignandImplementation√ê
PLDI‚Äô10. ACM,174≈õ186. https://doi.org/10.1145/1806596.1806617
[74]GuoqingXu,NickMitchell,MatthewArnold,AtanasRountev,andGarySevitsky.
2010. Softwarebloatanalysis:finding,removing,andpreventingperformance
problemsinmodernlarge-scaleobject-orientedapplications.In Proceedingsof
the 2010 workshop on Future of Software Engineering Research √ê FoSER ‚Äô10 . ACM,
421≈õ426. https://doi.org/10.1145/1882362.1882448
[75]DacongYan,GuoqingXu,andAtanasRountev.2012. UncoveringPerformance
Problems in Java Applications with Reference Propagation Profiling. In Proceed-
ings of the International Conference on Software Engineering √ê ICSE ‚Äô12 . IEEE,
134≈õ144. https://doi.org/10.1109/ICSE.2012.6227199
[76]Andreas Zeller and Ralf Hildebrandt. 2002. Simplifying and Isolating Failure-
InducingInput. IEEETrans.Softw.Eng. 28,2(Feb.2002),183≈õ200. https://doi.
org/10.1109/32.988498
146