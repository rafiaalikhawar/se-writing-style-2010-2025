Unrealizable Cores for
Reactive Systems Speciﬁcations
Shahar Maoz
Tel Aviv University
Tel Aviv, IsraelRaﬁ Shalom
Tel Aviv University
Tel Aviv, Israel
Abstract —One of the main challenges of reactive synthesis, an
automated procedure to obtain a correct-by-construction reactive
system, is to deal with unrealizable speciﬁcations. One means to
deal with unrealizability, in the context of GR(1), an expressive
assume-guarantee fragment of LTL that enables efﬁcient syn-
thesis, is the computation of an unrealizable core, which can
be viewed as a fault-localization approach. Existing solutions,
however, are computationally costly, are limited to computing
a single core, and do not correctly support speciﬁcations with
constructs beyond pure GR(1) elements.
In this work we address these limitations. First, we present
QuickCore, a novel algorithm that accelerates unrealizable core
computations by relying on the monotonicity of unrealizability,
on an incremental computation, and on additional properties of
GR(1) speciﬁcations. Second, we present Punch, a novel algorithm
to efﬁciently compute all unrealizable cores of a speciﬁcation.
Finally, we present means to correctly handle speciﬁcations that
include higher-level constructs beyond pure GR(1) elements.
We implemented our ideas on top of Spectra, an open-
source language and synthesis environment. Our evaluation over
benchmarks from the literature shows that QuickCore is in
most cases faster than previous algorithms, and that its relative
advantage grows with scale. Moreover, we found that most
speciﬁcations include more than one core, and that Punch ﬁnds
all the cores signiﬁcantly faster than a competing naive algorithm.
I. I NTRODUCTION
Reactive synthesis is an automated procedure to obtain a
correct-by-construction reactive system from its temporal logic
speciﬁcation [26]. GR(1) is an assume-guarantee fragment
of Linear Temporal Logic (LTL) that has an efﬁcient sym-
bolic synthesis algorithm [7]. GR(1) speciﬁcations include
assumptions and guarantees that specify what should hold in
all initial states, in all states and transitions (safeties), and
inﬁnitely often on every computation (justices). The expressive
power of GR(1) covers many well-known LTL speciﬁcation
patterns [12], [19], and it has been recently applied in several
domains, including robotics (see, e.g., [18]).
One of the main challenges of reactive synthesis in general
and of GR(1) synthesis in particular is to deal with unrealizable
speciﬁcations [2], [8], [11], [15], [16], [21]. To help engi-
neers debug unrealizable speciﬁcations, several works have
suggested the computation and use of an unrealizable core,
a locally minimal subset of guarantees that is sufﬁcient for
unrealizability. Computing the core may be viewed as a fault-
localization approach to unrealizability.
However, existing solutions to computing an unrealizable
core suffer from three main limitations. First, core computationin existing solutions is costly, as it requires many invocations
of realizability checking. Second, existing solutions are limited
to ﬁnding a single core and thus provide only partial infor-
mation about the realizability problems in the speciﬁcation
at hand. Third, existing solutions are limited to pure GR(1)
speciﬁcations, and do not correctly handle speciﬁcations with
richer language constructs. All these limit the applicability
of core computations as an effective means to dealing with
unrealizability.
In this work we address these three limitations. Our ﬁrst
contribution is QuickCore, a novel algorithm that accel-
erates unrealizable core computations. The effectiveness and
correctness of QuickCore are based on four observations.
First, that unrealizability is monotonic. Second, that core
computations can be incremental. Third, that checking the
realizability of speciﬁcations with fewer justices is typically
signiﬁcantly faster than of those with more justices. And
fourth, that minimizing initial guarantees requires only one
ﬁxed-point computation.
Our second contribution is Punch, an algorithm to ef-
ﬁciently compute all unrealizable cores of a speciﬁcation.
Moreover, Punch computes the intersection of all cores
without having to compute all of them. In particular, Punch
is able to quickly check whether a core that was found is the
only one that may be found.
Finally, our third contribution is the extension of core
computations to correctly handle speciﬁcations that include,
beyond pure GR(1) elements, higher-level constructs such
as patterns, past LTL operators, monitors, and counters, as
supported, e.g., in Spectra [20]. This is important in order to
correctly apply core computations to these more compact and
readable speciﬁcations, and to present the results not at the
level of the internal representation but at the abstraction level
used by the engineer who wrote the speciﬁcation.
It is important to note that while QuickCore is speciﬁc
to GR(1) unrealizability, Punch is in fact a generic algorithm
for computing all cores. Indeed, the deﬁnition and correctness
ofPunch in Alg. 3 is independent of realizability checking
or GR(1). Thus, Punch can be used, e.g., to compute all
vacuity cores [23], all realizable cores (subsets of assumptions
that sufﬁce for realizability), and more generally, all locally
minimal subsets for any monotonic criterion (e.g., unsatisﬁa-
bility). Similarly, our third contribution on correctly dealing
with higher-level constructs beyond pure GR(1) applies not
252021 IEEE/ACM 43rd International Conference on Software Engineering (ICSE)
1558-1225/21/$31.00 ©2021 IEEE
DOI 10.1109/ICSE43902.2021.00016
1env boolean b1;
2env boolean b2;
3env boolean b3;
4
5sys Int(1..3) f;
6
7// No buttons are initially pressed
8asm !b1 and !b2 and !b3;
9
10// Request is removed when satisfied
11asm G( (b1 and f=1) -> next(!b1));
12asm G( (b2 and f=2) -> next(!b2));
13asm G( (b3 and f=3) -> next(!b3));
14
15// Request must remain while unsatisfied
16asm G( (b1 and f!=1) -> next(b1));
17asm G( (b2 and f!=2) -> next(b2));
18asm G( (b3 and f!=3) -> next(b3));
19
20// Lift is initially at lowest floor
21gar f=1;
22
23// Always stay at same floor or move to adjacent floor
24gar G(f>=next(f)-1 and f<=next(f)+1);
25
26// Do not move up when there are no requests
27gar G(f<next(f)) ->(b1 or b2 or b3);
28
29// Eventually grant each request
30gar GF(b1 -> f=1);
31gar GF(b2 -> f=2);
32gar GF(b3 -> f=3);
33
34// Visit every floor infinitely often
35gar GFf=1;
36gar GFf=2;
37gar GFf=3;
Listing 1
LIFT CONTROLLER SPECIFICATION ,ADOPTED FROM [23]
only to unrealizable cores, but, in principle, to any similar
analysis of speciﬁcations with higher-level constructs that are
reduced to GR(1). We consider this generality a nice advantage
of our work, with possible future applications beyond the focus
of the present paper.
We implemented our ideas on top of Spectra, a rich
speciﬁcation language and open source tool set for reactive
synthesis [20]. All our algorithms are implemented on top of,
and compared to, recently suggested heuristics for realizability
and core computations for GR(1) [13]. We validated and
evaluated our work on benchmarks from the literature. The
evaluation shows that QuickCore is in almost all cases faster
than previous algorithms and that many speciﬁcations indeed
include more than one core. It further shows that Punch
is much faster than a competing naive algorithm, and that
it is able to compute almost all cores for the SYNTECH
benchmarks in reasonable times.
Means to deal with unrealizability of temporal speciﬁca-
tions have been studied in the literature. Beyond unrealizable
cores [15], these also include different approaches to counter-
strategy generation [16], [22] and assumption reﬁnement or
repair [2], [8], [21]. We discuss related work in Sect. IX.
II. R UNNING EXAMPLE
As a running example, we use a lift speciﬁcation (see
Lst. 1), taken from [23], which has appeared in several variants
in previous GR(1)-related papers [2], [7], [8], [25]. The
speciﬁcation is written in Spectra format [20], [28]. It is smalland simple, to ﬁt the paper presentation. In our evaluation we
have used larger and more complex speciﬁcations, taken from
benchmarks.
The speciﬁcation models a controller for a three ﬂoors
lift. The lift has three request buttons, one on each ﬂoor.
Requests are represented by environment variables b1,b2,
andb3, which may be independently true or false. The current
ﬂoor of the lift is represented by the system variable f. The
environment is required to initially have no requests (l. 8),
turn off any granted request at the next step (ll. 11-13), and
keep ungranted requests (ll. 16-18). The system is required to
start the lift on the ﬁrst ﬂoor (l. 21), and to disallow the lift to
move more than one ﬂoor at a time (l. 24). The system is also
required not to move up when there are no requests (l. 27),
to eventually grant every request (ll. 30-32), and to make sure
every ﬂoor is visited inﬁnitely often (ll. 35-37).
The speciﬁcation is unrealizable but it is not easy to see why
and debug it. So, the engineer may want to employ a fault-
localization approach and ﬁnd an unrealizable core, a locally
minimal subset of guarantees that is sufﬁcient for unrealiz-
ability. A modiﬁed speciﬁcation with only these guarantees is
already unrealizable; removing any one guarantee from that
speciﬁcation, will render it realizable.
By running our new algorithm QuickCore the engineer
ﬁnds that the set of guarantees in lines f21,27,36g is a core.
However, an unrealizable core is not necessarily unique, i.e.,
the speciﬁcation may induce additional unrealizable cores. Our
new algorithm Punch, ﬁrst ﬁnds the above core, then ﬁnds
that the guarantee in line 27 is the intersection of all the cores,
and ﬁnally reports all ﬁve remaining cores, namely f21,27,37g,
f27,35,36g,f27,35,37g,f27,36,37g, andf24,27,30,37g. As
our evaluation shows, having more than one core is indeed
rather common.
Note that the early detection of the intersection of all
the cores indicates whether additional cores exist. Moreover,
the intersection is of interest, since making the speciﬁcation
realizable by removing or weakening only one guarantee is
only possible with the guarantees in the intersection. Finally,
the size of the intersection serves as a lower bound on the size
of any of the cores induced by the speciﬁcation.
III. P RELIMINARIES
A. LTL, GR(1), and Realizability
We use a standard deﬁnition of linear temporal logic (LTL),
e.g., as found in [7], over present-future temporal operators
X(next), U(until), F(ﬁnally), and G(globally), and past
temporal operator H(historically), for a ﬁnite set of Boolean
variablesV. LTL formulas can be used as speciﬁcations of
reactive systems, where atomic propositions are interpreted
as environment (input) and system (output) variables. An
assignment to all variables is called a state.
GR(1) is a fragment of LTL. A GR(1) speciﬁcation contains
initial assumptions and guarantees over initial states, safety
assumptions and guarantees relating the current and next
state, and justice assumptions and guarantees requiring that an
assertion holds inﬁnitely many times during a computation.
26We use the following abstract syntax deﬁnition of a GR(1)
speciﬁcation taken from [23].
Deﬁnition 1 (Abstract syntax of a speciﬁcation). A GR(1)
speciﬁcation is a tuple Spec =hVe;Vs;D;M e;Msi, whereVe
andVsare sets of environment and system variables respec-
tively,D:Ve[Vs!Doms assigns a ﬁnite domain to each
variable1, andMeandMsare the environment and system
modules. A module is a triplet M=hI;T;Jithat contains
sets of initial assertions I=fIngi
n=1, safety assertions T=
fTngt
n=1, and justice assertions J=fJngj
n=1 of the module,
wherei=jIj;t=jTjandj=jJj. The set of elements of
moduleM=hI;T;JiisBM=I[fGTigt
i=1[fGFJigj
i=1.
Given a setZof variables,Z0=fXvjv2Zg contains a
copy of its variables at the next state. Let Me=hIe;Te;Jei,
Ms=hIs;Ts;Jsi, andV=Ve[Vs. Then, the elements
ofIe;Te;Je;Is;TsandJsare propositional logic expressions
overVe;V[V0
e;V;V;V[V0andVrespectively.
GR(1) has efﬁcient symbolic algorithms for realizability
checking and controller synthesis, presented in [7], [25].
For this a game structure of a two-player game G=
hV;X;Y;e;s;e;s;'i is deﬁned. The GR(1) game has a
set of variablesV=Ve[Vs, environment and system variables
(X=VeandY=Vsresp.), environment and system initial
states ( e=^d2Iedands=^d2Isdresp.), environment and
system transitions ( e=^t2Tetands=^t2Tstresp.), and
a winning condition '=V
j2JeGFj!V
j2JsGFj.
A GR(1) speciﬁcation is realizable, i.e., allows an imple-
mentation, iff the system wins the game. Roughly, this means
that if the environment keeps all initial assumptions then
the system should keep all initial guarantees, as long as the
environment keeps all safety assumptions the system should
keep all safety guarantees, and in all inﬁnite plays, if the
environment keeps all justice assumptions the system should
keep all justice guarantees.
For this the algorithm of [7], [25] computes a winning
region which is a set of winning states from which the system
has a winning strategy. A winning strategy prescribes the
outputs of a system for all possible environment choices that
allows the system to win. The winning region is computed
according to a ﬁxed-point computation over transitions and
justices alone. GR(1) realizability checks if for all initial
environment choices the system can enter a winning state.
GR(1) synthesis computes a winning strategy, if one exists.
B. Monotonic Criteria and Cores
Given a setE, and a monotonic criterion on subsets of E, a
core is a local minimum that satisﬁes the criterion. Formally:
Deﬁnition 2 (Monotonic criterion). A Boolean criterion over
subsets ofEis monotonic iff for any two sets A;B such that
ABE, ifAsatisﬁes the criterion then Bsatisﬁes the
criterion.
1The use of any ﬁnite domain rather than only Boolean variables is
straightforward and supported by many tools, including Spectra.Deﬁnition 3 (Core). Given a setEand a monotonic criterion
over its subsets, a set CEis a core of EiffCsatisﬁes the
criterion, and all its proper subsets C0Cdo not satisfy the
criterion.
Unrealizability is monotonic w.r.t. subsets of guarantees,
i.e., adding guarantees to an unrealizable speciﬁcation keeps it
unrealizable. Intuitively, this is so because adding guarantees
strengthens the constraints on the system, and does not change
the constraints on the environment. Formally:
Proposition 1 (Unrealizability is monotonic). Given two
speciﬁcations, Spec 1=hVe;Vs;D;M e;M1
si, andSpec 2=
hVe;Vs;D;M e;M2
si, such that BM1
sBM2
s. Then, ifSpec 1
is unrealizable, Spec 2is also unrealizable.
C. Existing Domain-Agnostic Minimization Algorithms
We recall three existing domain-agnostic minimization al-
gorithms from the literature, namely delta debugging [29]
(DDMin), QuickXplain [14], [24], and linear minimization,
which we denote by LinearMin. All three algorithms ﬁnd
a core of a set E, given a monotonic criterion check.
Algorithm 1 The delta debugging algorithm DDMin from [29]
as a recursive method that minimizes a set of elements Eby
partitioning it into nparts (initial value n= 2)
1:forpart2partition (E; n) do
2: if check(part )then
3: return ddmin(part , 2)
4: end if
5:end for
6:forpart2partition (E; n) do
7: if check(Enpart )then
8: return ddmin(Enpart ,max(n 1;2))
9: end if
10: end for
11: ifnjEjthen
12: returnE
13: end if
14: return ddmin(E ,min(jEj;2n))
We show a pseudo-code for DDMin in Alg. 1. The inputs
for the algorithm are a set Eand the number nof parts of
Eto check. The algorithm starts with n= 2 and reﬁnes E
andnin recursive calls according to different cases (ll. 3, 8,
and 14). The computation starts by partitioning Einton
subsets and evaluating check on each subset part and its
complement. If check holds (l. 2 or l. 7), the search is
continued recursively on the subset part or on its complement
respectively. If check holds neither on any subset part nor
on the complements, the algorithm increases the granularity of
the partitioning to 2n(l. 14) and recurs, or terminates when
the granularity is not smaller than the size of E(l. 12). DDMin
has quadratic worst-case complexity and logarithmic best-case
complexity in terms of jEj.
QuickXplain is a recursive divide and conquer algorithm
that minimizes each half, one after the other, in an incremental
way (see Sect. III-D). It has a worst-case complexity of O(k+
klog (jEj
k)), wherekis the size of the largest core. To the
best of our knowledge, QuickXplain was never previously
27applied to computing unrealizable cores for reactive systems
speciﬁcations.
Finally, LinearMin was originally suggested in [11],
and compared with DDMin in [15]. LinearMin goes over
elements of the input set one by one, and removes an element
iff the criterion holds for the set without the element. An
example of LinearMin can be found in ll. 11-16 of Alg. 2.
The complexity of LinearMin is linear injEj.
D. Minimization With a Base and Incremental Core Compu-
tation
We deﬁne a notion of minimization with a base as follows.
Deﬁnition 4 (Minimization with a base). Assume a set
Eof elements, two disjoint subsets Base;AE,
and a minimization algorithm Alg that detects cores ac-
cording to a monotonic criterion check. Assume also
that the set Base[Asatisﬁes the criterion. We denote
byMinWBase(Alg;E;Base;A;check )an algorithm that
computes a locally minimal A0As.t.Base[A0satisﬁes
the criterion, by applying Alg toA, and replacing every
check(X )operation with check(Base[X).
Monotonicity is ensured for minimization with a base
becauseA1A2impliesBase[A1Base[A2.
Note thatBase does not have to be a subset of a core
ofE, and it may contain a core. Base only has to satisfy
A\Base =;, and thatBase[Asatisﬁes the criterion. The
following holds trivially.
Proposition 2. Given the notations of Deﬁnition 4,
(i) IfBase is a subset of all cores of E, thenBase[A0is
a core ofE.
(ii) IfBase contains a core of E, thenA0=;.
Finally, we use the idea of incremental minimization in
some of our algorithms. Lemma 1 states that incrementally
minimizing two subsets that partition a set produces a core.
Lemma 1 (Incremental Core Computation). LetAandB
be disjoint sets such that E=A[Bsatisﬁes a monotonic
criterion. Let A0be a locally minimal subset of Asuch that
A0[Bsatisﬁes the criterion, and B0be a locally minimal
subset ofBsuch thatA0[B0satisﬁes the criterion. Then
A0[B0is a core of E.
Proof. By deﬁnition A0[B0satisﬁes the criterion. A0exists
becauseEsatisﬁes the criterion, and B0exists because A0[B
satisﬁes the criterion.
To prove that A0[B0Eis locally minimal, let x2
A0[B0. Ifx2A0then by deﬁnition of A0,(A0nfxg)[Bdoes
not satisfy the criterion, thus by monotonicity (A0nfxg)[B0
does not satisfy the criterion either. Otherwise x2B0, and by
deﬁnition of B0,A0[(B0nfxg) does not satisfy the criterion.
IV.QU I C K CO R E
We are now ready to present our ﬁrst contribution, the
QuickCore algorithm, which aims to accelerate unrealiz-
able core computations. The correctness and efﬁciency ofQuickCore rely on the following observations. First, that
unrealizability is monotonic (see Prop. 1). Second, that it is
possible to compute a core incrementally (see Lemma 1).
Third, that checking the realizability of speciﬁcations with
fewer justices is typically much faster. Fourth, that removing
justice assumptions from an unrealizable speciﬁcation that has
no justice guarantees preserves unrealizability and preserves
winning regions. And ﬁnally, that minimizing the initial as-
sertions requires only a single computation of the winning
region of the system, plus a small constant number of symbolic
operations.
A.QuickCore Algorithm Overview
Roughly, QuickCore begins by trying to remove as many
justices as possible. Therefore, if no justice guarantees are
required for a core it removes all of them, and all justice
assumptions. Otherwise, it minimizes justice guarantees alone
using DDMin with a base. Later, QuickCore minimizes
safety guarantees using DDMin with a base. Finally, Quick-
Core minimizes all initial guarantees using LinearMin.
Algorithm 2 presents QuickCore in pseudo-code.
QuickCore minimizes guarantees, group by group, accord-
ing to their type; ﬁrst justices, then safeties, and ending with
initial assertions. It begins with a realizability check of the
speciﬁcation without justice guarantees in line 1. If the spec-
iﬁcation without these is realizable, at least one such justice
guarantee is required for unrealizability, and so it minimizes
justice guarantees alone (i.e., keeping all initial assertions and
safeties) using DDMin with a base in line 2. Otherwise, it
determines that the core it computes has no justice guarantees
(line 4) and removes all environment justices in line 5 before
it continues to look for system safeties and initial assertions.
With a speciﬁcation that has a minimized set of justice
guarantees and maybe no environment justices, QuickCore
usesDDMin with a base in order to minimize the set of safeties
alone (line 7). It keeps initial assertions and the minimized
justice guarantees unchanged.
At the last stage of QuickCore, it computes the winning
region of the system in line 8 for the speciﬁcation with the
minimized set of justices and safeties. It now uses linear mini-
mization in the loop in lines 11-16, going over initial assertions
one by one, and checking if the system wins without each. If
so, we keep this initial assertion because we want to maintain
unrealizability. Checking this is done with SysWin (e;s;w),
which determines if for every possible environment choice
satisfyinge, there is a choice for the system from sthat is
inside the winning region w. This is computed with a small,
constant number of symbolic operations.
Remark 1. Realizability checks in our implementation use the
performance heuristics suggested in [13]. QuickCore must
disable two of these heuristics, namely, ﬁxed-point recycling
and early detection of unrealizability, before line 8, in order to
avoid an incomplete winning region computation. For example,
the latter heuristics may over-approximate the winning region
by halting the outer greatest ﬁxed-point when the winning
28region becomes small enough to ensure that the system loses.
This is good enough for realizability checks, so we use it safely
before line 8, yet using it from that line on may wrongly keep
some initial guarantees.
Example 1. For the speciﬁcation in Lst. 1 (see Sect. II),
QuickCore ﬁnds that at least one justice is required for
a core in line 1, and detects the justice in line 36 of the
speciﬁcation with the minimization in line 2. Given this justice,
the safety in line 27 of the speciﬁcation is detected in line 7.
Lines 11-16 decide that given the above two guarantees, the
only initial guarantee of the speciﬁcation (line 21) is required
for the core. The resulting core is thus the set of guarantees
in linesf21,27,36g.
Algorithm 2 QuickCore Given an unrealizable speciﬁcation ﬁnd
a locally minimal subset of guarantees that keeps it unrealizable
Require: An unrealizable speciﬁcation S=hVe; Vs; D; M e; Msi, where
Me=hIe; Te; JeiandMs=hIs; Ts; Jsi
Ensure: An unrealizability core of S
.Begin by minimizing only justice guarantees
1:if Realizable(hV e; Vs; D; M e;hIs; Ts;;ii) then
2: Jc MinWBase(DDMin; B Ms; Is[Ts; Js;:Realizable(S ))
3:else
4: Jc ;
5: Me hI e; Te;;i
6:end if
.Continue with minimizing only safety guarantees
7:Tc MinWBase(DDMin; B Ms; Is[Jc; Ts;:Realizable(S ))
.End with minimizing only initial guarantees
8:w ComputeWinRegion(hV e; Vs; D; M e;hIs; Tc; Jcii)
9:Ic Is
10:envIni ^d2Ied
11: fori2Icdo .Use linear minimization for initial guarantees
12: Ic Icnfig
13: if SysWin(envIni; ^d2Icd; w)then
14: Ic Ic[fig
15: end if
16: end for
17: return Ic[Tc[Jc
B. Correctness of QuickCore
QuickCore is correct in the sense that it detects an
unrealizable core of the guarantees. To prove correctness we
will show that (1) Finding cores of subsets of guarantees
one by one yields a valid core; (2) Removing all justice
assumptions from a speciﬁcation with no justice guarantees
impact neither the realizability of any subset of guarantees,
nor the winning region of the system; and (3) It is enough
to compute the winning region of the system once when
minimizing initial guarantees.
(1) A core can be computed in a compositional manner,
by minimizing pairwise disjoint subsets one by one, using an
extension by induction of Lemma 1 to any number of ﬁnite
pairwise disjoint sets. Speciﬁcally, QuickCore partitions the
set of guarantees into three sets, and minimizes each set with
established algorithms for local minimum, namely, DDMin and
LinearMin.
(2) Removing all justice assumptions when no justice
guarantees are needed for a core does not affect the overallcorrectness of QuickCore, because realizability checks and
computation of winning regions of the system are unchanged.
Intuitively, in an unrealizable speciﬁcation with no justice
guarantees, the environment can (and must) win with ﬁnite
plays of the game. Thus, even though generally removing
assumptions may turn a realizable speciﬁcation into an unre-
alizable one, this does not happen when removing justice as-
sumptions from a speciﬁcation with no justice guarantees. For
such speciﬁcations, when the system does not lose ﬁnitely, it
wins the inﬁnite games, regardless of any justice assumptions.
Accordingly, all environment justices in this case are unhelpful
in the sense deﬁned in [11], i.e., assumptions whose removal
does not change the realizability induced by any subset of
the guarantees. Note that having several assumptions, each
unhelpful alone, does not mean that they are unhelpful as a
set, yet justice assumptions in this case are unhelpful as a set.
Formally, the game structure of the GR(1) game [7] for
both speciﬁcations is the same, because in GR(1) games,
justices appear only in the winning conditionV
j2JeGFj!V
j2JsGFj. When there are no justice guarantees, this con-
dition isV
j2JeGFj! > , which is an LTL tautology
regardless of the justice assumptions. This ensures both the
equirealizability, which is needed for the correctness of the
minimization of safeties in line 7, and the correctness of the
winning region computation in line 8.
(3) Finally, the correctness of the minimization of initial
guarantees follows from the fact that checking realizability
has two parts. We ﬁrst compute the winning region of the
system in the GR(1) game, and then check if the system can
reach it given all possible environment initial choices. Since
the winning region depends only on safeties and justices, and
we keep them unchanged at this phase of QuickCore, it is
enough to compute the winning region only once.
C. Complexity of QuickCore
Consider a speciﬁcation with nguarantees. The worst-case
complexity of DDMin isO(n2)realizability checks [29]. The
same holds for QuickCore.
V.PU N C H
We now present our second contribution, the Punch algo-
rithm for computing all cores.
Punch ﬁnds all cores of a set Eaccording to a monotonic
criterion. The algorithm is generic in the sense that it requires
acheck that evaluates the monotonic criterion, and a com-
puteCore(E0;B)that provides a core in E0E, givenE0
that satisﬁes the criterion, and a set BE0that is a subset of
all the cores in E0. In particular, Punch detects all minimal
size cores. As a byproduct, Punch provides an efﬁcient way to
ﬁnd the intersection of all the cores, without having to compute
all of them. This intersection provides an early estimate of the
size of the smallest cores, and, in particular, an early verdict
on the existence of additional cores.
Algorithm 3 presents Punch in pseudo-code, as a recursive
algorithm that takes two parameters as input, a set Ethat has
at least one core, and a set Kthat is a subset of all the cores
29Algorithm 3 Punch Find all cores according to a monotonic check
Require: A set Eof elements such that check(E)=>
Require: A set KEthat is a subset of all cores in E
Ensure: All cores in E
1:C0 computeCore(E; K )
2:AllCores fC 0g
3:CI ;
4:Cont ;
5:forx2C0nKdo
6: if check(Enfxg)then
7: add xtoCont
8: else
9: add xtoCI
10: end if
11: end for
12: forx2Cont do
13: AllCores AllCores[Punch(Enfxg; K[CI)
14: end for
15: return AllCores
inE. The recursive algorithm ﬁnds all the cores in E. Thus,
Punch (E;;)returns all the cores in E.
The algorithm ﬁnds its ﬁrst core C0Eby applying
computeCore in line 1. Later, in lines 5-11, it splits all the
elementsx2C0nKinto two sets according to whether Enfxg
satisﬁes the criterion. Cont gets all positives and CIgets all
negatives. Finally, in lines 12-14, for all elements x2Cont , it
considers the punched sets Enfxg (hence the name Punch),
and recursively looks for all cores inside them, while adding
CItoK. By collecting all such cores into AllCores the
computation ends.
Example 2. Applying Punch to the example in Lst. 1 ﬁnds
the six cores of the run described in Sect. II. Speciﬁcally, that
run is of PQC(B Ms;;) (see Sect. V-C).
Two cores consist of the guarantees in lines 21, 27, and one
of the guarantees in lines 36 and 37. Indeed, if the lift starts
at the ﬁrst ﬂoor, and moves up only when there are requests, it
may never be able to reach the other two ﬂoors. Three other
cores consist of the guarantee in line 27, and pairs of the
guarantees in lines 35-37, which require the elevator to visit
two different ﬂoors inﬁnitely. Indeed, the system can be forced
to visit the lower of the two ﬂoors, and not to go up (line
27). Finally, the guarantees in lines 24, 27, 30, and 37 allow
the environment to force the lift to the ﬁrst ﬂoor (line 30), the
system then may or may not move up to the second ﬂoor (line
24), which allows the environment to keep the lift bellow the
third ﬂoor (line 27), and thus fail the guarantee to visit that
ﬂoor (line 37).
A. Correctness of Punch
First we prove the following Lemma.
Lemma 2. In running Punch (E;;), after the loop in lines
5-11, the set CIcontains the intersection of all cores in E.
Proof.K=;, thusCI=fx2C0jcheck (Enfxg) =?g.
Moreover,check (Enfxg) =>iffEnfxgcontains a core
iffxdoes not belong to all the cores in E.
We now show that the preconditions hold in all recursive
calls, and that Punch is sound and complete.The Preconditions of Punch are Met in All Recursive Calls:
Punch requires that Esatisﬁes the criterion, and that Kis a
subset of all the cores in E. The two preconditions must hold
for the recursive calls in line 13.
According to line 6, 8x2Cont check(Enfxg) =>,
which satisﬁes the ﬁrst precondition. According to lines 5
and 9, for all x2Cont ,K[CIEnfxg. Now, by
assumption, Kis a subset of all the cores in E, and by similar
reasoning to that of Lemma 2, CIis also a subset of all the
cores inE. In particular, for all x2Cont ,K[CImust be
a subset of all the cores in Enfxg. This satisﬁes the second
precondition.
Punch is Sound: A set is added to our list of cores when
it is detected by computeCore in recursive calls at line 1 of
Punch. The preconditions of computeCore are met because
they match the preconditions of Punch.
Punch is Complete: This follows from Thm.1 below.
Theorem 1. LetCbe a core of a set E. In running
Punch (E;K )such thatKis a subset of all the cores in
E, we will have C2AllCores in line 15 of Alg. 3.
Proof. By induction on n=jEj, notice that for n= 1 there
must be exactly one core of size 1, and the algorithm is correct
for both possible choices of K.
Assume by induction that the claim is correct for all sets
strictly smaller than n, and ﬁx a setjEj=nwithCEa
core ofE. IfCis detected in line 1, C=C0and we are done.
Otherwise,C6=C0. SinceCis a core, and C0satisﬁes the
criterion, we know that C06C, thus there is an x2C0such
thatx =2C. Moreover, x =2KbecauseKC, sox2C0nK.
SinceCis a core of Eandx =2C,Cis a core of Enfxg.
This means (1) that Enfxgsatisﬁes the criterion, which in
turn means that x2Cont ; and (2) sincejEnfxgj< n, by
inductionCis found as a core by the call to Punch in line 13,
when thexof the loop coincides with the xin the proof. This
completes the proof.
B. Complexity of Punch
In general, the number of cores of a set according to a
monotonic criterion may be exponential in the size of the
set [4]. Thus, the worst-case complexity of Punch and of any
other algorithm that would enumerate all cores, is exponential.
Lemma 2 shows that obtaining the intersection of all the
cores requires only one core computation plus a number of
realizability checks the size of the core that we found.
C. Employing Punch to Unrealizable Cores
Employing Punch to compute all unrealizable cores re-
quires an implementation of check to check for un-
realizability. We created two implementations of Punch,
which we label PUD andPQC. In PUD, we implemented
computeCore using DDMin with a base. Speciﬁcally,
computeCore (E;K )in line 1 of Punch is implemented
withK[MinWBase(DDMin;E;K;E nK;check ). InPQC,
we implemented computeCore with an extended version
30ofQuickCore that supports minimization with a base.
The version of QuickCore minimizes justices, safeties, and
initial assertions that do not belong to a given base set.
Prop. 2(i) ensures the correctness of both implementations of
computeCore.
VI. M EMOIZATION
We implemented memoization for our algorithms, which
allows us to avoid checking the criterion whenever the check is
redundant, based on the results of prior checks of the criterion
and on the criterion’s monotonicity.
Basically, we keep a set of prior positive checks and a set of
prior negative checks of the criterion. Whenever a check for
a set is about to occur, if we already have a positive criterion
subset, then we know the set is positive and we avoid actually
checking it. Similarly, if we already have a negative superset
then we know the set is negative. Only if memoization fails
we perform an actual check of the criterion and store the result
as positive or negative accordingly.
Two additional features accelerate the required subset
checks. First, we keep each memoized set sorted, which
enables linear time subset checks. Second, we keep the collec-
tions of positive and negative results sorted according to the
size of the memoized sets, and look for subsets and supersets
of relevant size only (this is correct because a larger set cannot
be a subset of a smaller set, i.e., if jBj>jAjthenB6A).
A. Memoization in QuickCore
Realizability checks are the most computationally expensive
parts of QuickCore. Almost all these checks occur as a part
ofDDMin runs within it. We use the DDMin implementation
in Spectra. In this generic implementation of DDMin, sets for
which the criterion failed are recorded, and we avoid checking
them and their subsets because monotonicity ensures that
they must fail as well. This heuristics was already mentioned
in [29], and implemented in [15] and in [13] for unrealizable
cores. On top of it, we use the memoization mechanism we
described at the beginning of this section.
B. Memoization in Punch
We seek to avoid as many as possible calls to check and
tocomputeCore.
Forcheck, we use the memoization mechanism we de-
scribed in the beginning of this section, and add all cores
found by computeCore to the set of positive sets. In PQC
andPUD (see Sect. V-C) all check operations share the same
memoization, whether the ones invoked at line 6 of Punch
or at their particular implementations of computeCore.
ForcomputeCore, when we look for a core of a set E
(see line 1 of Punch), we use the ﬁrst core that is a subset of
Ein previously found cores, if one exists. This is important
because, for example, having two disjoint cores means that
without memoization, we would run a core computation to
unnecessarily seek the second core for every element of the
ﬁrst core. Memoization ensures that the number of times we
run an actual core computation in Punch is equal to the
number of cores in E.1sys boolean b;
2
3monitor boolean a {
4 !a; // initially false
5 Ga->next(a); // once true, remain true forever
6}
7
8gar b;
9gar Gbiff a;
Listing 2
AN UNREALIZABLE SPECIFICATION WITH A MONITOR
VII. B EYOND PURE GR(1) S PECIFICATIONS
We now present our third contribution, correct and efﬁcient
core computations for speciﬁcations that are reducible to
GR(1), yet include language constructs beyond pure GR(1),
such as patterns, monitors, and past LTL formulas.
A. Reducing Higher-Level Constructs into Pure GR(1)
Recall that many higher-level language constructs can be
reduced to pure GR(1) form by replacing them with additional
auxiliary variables as well as new guarantees or assumptions.
See, e.g., [19], [20].
A pattern (e.g., the response pattern G(p!Fq), which is
not in pure GR(1) form) is reduced according to a deterministic
Buchi automaton that represents it. The states of the automaton
are encoded using new auxiliary variables, its initial state is
encoded using an auxiliary assertion about the initial values
of the auxiliary variables, its transitions are encoded using an
auxiliary safety, and its acceptance condition is encoded into
a justice (assumption or guarantee).
Monitors and counters are constructs that track a certain
value. They are reduced by adding auxiliary variables that
encode that value, and optional auxiliary elements that are
assertions about its initial value, and its current and next values
(safeties). For example, the monitor in Lst. 2 adds one Boolean
auxiliary variable a, one auxiliary initial assertion (line 4), and
one auxiliary safety (line 5).
The reduction is completed by considering auxiliary vari-
ables and elements as system variables and guarantees respec-
tively. This allows one to apply GR(1) realizability checks and
synthesis.
B. A Simple but Incorrect Approach
One may suggest that core computations would minimize
the GR(1) system module elements, and then trace back to
the elements that induced them in the original speciﬁcation.
This approach, however, is incorrect. As an example, for the
unrealizable speciﬁcation in Lst. 2, the (incorrect) core com-
puted by this approach contains only lines 8 and 9. The reason
is that only system elements are minimized. The incorrect
computation ignores the auxiliary monitor initial assertion at
line 4 although without this assertion, the speciﬁcation is real-
izable! If unrealizability is a result of auxiliary elements alone,
we may even incorrectly get an empty core (see Prop. 2(ii)).
This means that we must also consider auxiliary elements for
minimization, and at the same time avoid redundant ones that
unnecessarily complicate the reduced speciﬁcation and inﬂate
the state space.
31C. Our Approach
We have implemented a framework to correctly handle spec-
iﬁcations that include high-level constructs. The framework
relies on two-way traceability between the high-level language
construct and the GR(1) elements it reduces to.
Speciﬁcally, each distinguishable speciﬁcation construct, as
written by the engineer, is assigned an ID that represents all of
the GR(1) elements it reduces to. Thus, all elements induced
from patterns and past LTL operators are assigned the ID of
the high-level element they belong to, while each assertion
inside monitors and counters has its own ID.
Our implementation builds system and environment mod-
ules according to subsets of IDs. Core computation begins with
a set of all environment IDs for the assumptions, and a set of
auxiliary and system IDs for the guarantees. It performs realiz-
ability checks given subsets of IDs. For example, QuickCore
may eliminate all justice assumptions (line 5). If any of these
justice assumptions were induced by patterns, the produced
environment module avoids not only these justices but also
their matching pattern-induced initial and safety assertions, as
well as the pattern-induced auxiliary variables that encoded
the states of this pattern’s automaton. These are the exact sets
of elements and variables that match the subset of high-level
assumptions.
In Lst. 2, the correct core we compute in this way includes
lines 4, 8, and 9. Together, they are sufﬁcient for unrealizabil-
ity, and each of them is necessary.
VIII. E VALUATION
We have implemented our ideas on top of Spectra [20],
[28], with the performance heuristics from [13]. Our im-
plementation includes QuickCore andPunch. For the
purpose of evaluation, it also includes an instance of the
DDMin algorithm implemented in Spectra, an implementation
ofQuickXplain [14], [24], and a naive top down algorithm
for computing all cores we label TD(see below). All the above
implementations take advantage of the memoization described
in Sect. VI.
Means to run our implementation, all speciﬁcations used in
our evaluation, and all data we report on below, are available
in supporting materials for inspection and reproduction [1].
We encourage the interested reader to try them out.
The following research questions guide our evaluation.
R0Which existing domain-agnostic minimization algorithm
is the most efﬁcient in our setup?
R1IsQuickCore efﬁcient, in terms of the number of real-
izability checks and running time, in comparison to previous
algorithms?
R2IsQuickCore effective, in terms of the size of the core
it ﬁnds, in comparison to previous algorithms?
R3Are speciﬁcations with multiple unrealizable cores com-
mon and how many such cores do most speciﬁcations have?
R4IsPunch efﬁcient in detecting all cores?
Below we report on the experiments we have conducted in
order to answer the above questions.Table I
EFFICIENCY OF DDM I NVS.QU I C K XP L A I N Spec set 0:1s 0.1-1s 1-10s 10-100s 100s
SYN15U 0.10 0.48 - - -
SYN17U 0.08 0.28 0.41 0.52 0.84
AM+GN 0.10 0.40 0.42 0.80 0.99
A. Corpus of Speciﬁcations
We use the benchmarks SYNTECH15 and
SYNTECH17 [13], [20], [28], which include a total of
227 speciﬁcations of 10 autonomous Lego robots, written
by 3rd year undergraduate computer science students in
a project class taught by the authors of [13]. We use all
the unrealizable GR(1) speciﬁcations from these, i.e., 14
unrealizable speciﬁcations from SYNTECH15 (which we
label SYN15U) and 26 unrealizable speciﬁcations from
SYNTECH17 (which we label SYN17U).
In addition, we used 5 different sizes of AMBA [5] and of
GENBUF [6] (1 to 5 masters, 5 to 40 senders resp.), from
each of the 3 variants of unrealizability described in [11].
We label these 30 speciﬁcations by AM+GN. Note that these
speciﬁcations are structurally synthetic and artiﬁcially inﬂated.
We therefore report on their performance (in R0, R1, and R4)
but not on their more qualitative aspects (R2 and R3). Still,
the supporting materials [1] include all the data we collected.
B. Validation
We have implemented an automatic test that checks that
every core that we found is indeed a locally minimal subset of
the guarantees that maintains unrealizability. We run this check
over logs of cores produced by our algorithms, independent
of their original detection. We also veriﬁed that the different
algorithms that compute all the cores of a speciﬁcation (i.e.,
ones that terminated before the timeout was reached) found
the same number of cores.
C. Experiments Setup
We ran all experiments on an ordinary PC, Intel Xeon W-
2133 CPU 3.6GHz, 32GB RAM with Windows 10 64-bit OS,
Java 8 64Bit, and CUDD 3 compiled for 64Bit, using only a
single core of the CPU.
Times we report are average values of 10 runs, measured
by Java in milliseconds. Although the algorithms we deal
with are deterministic, we performed 10 runs since JVM
garbage collection and BDD dynamic-reordering add variance
to running times.
We used a timeout of 10 minutes for the algorithms that
compute all cores, and no timeout for the algorithms that ﬁnd
a single core.
D. Results: Existing Domain-Agnostic Algorithms in Our
Setup
In Sect. III-C we discussed three existing domain-agnostic
algorithms for ﬁnding a local minimum given a monotonic
criterion. We also noted that DDMin was compared and found
superior to LinearMin in [15].
32Table II
EFFICIENCY OF QU I C K CO R E VS.DDM I N
Spec set 0:1s 0.1-1s 1-10s 10-100s 100s
SYN15U 0.79 0.51 - - -
SYN17U 1.38 0.37 0.54 0.06 0.015
AM+GN 1.53 0.63 0.71 0.30 0.20
Table I presents the performance of DDMin versus Quick-
Xplain. The columns show the geometric mean of the ratio
of the running times (namely, the running time of DDMin
divided by that of QuickXplain), dissected by the running
time range obtained for DDMin. We use ‘-’ to mark cases
in which no speciﬁcations had DDMin running time within
the corresponding range. For example, the number 0.28 in the
second row means that for SYN17U speciﬁcations for which
a core was found by DDMin in between 0.1 and 1 seconds,
the geometric mean indicates that DDMin was more than three
times faster than QuickXplain.
The results show that DDMin is more efﬁcient than Quick-
Xplain on all our corpus (although the gap lessens with
scale). This justiﬁes our choice of DDMin as the domain-
agnostic minimization algorithm inside QuickCore and
PUD. It also justiﬁes our choice to use DDMin as the baseline
algorithm for examining the efﬁciency of QuickCore (see
R1 below).
To answer R0: DDMin is the most efﬁcient domain-agnostic
single core computation algorithm in our setup.
E. Results: Efﬁciency of QuickCore versus DDMin
Table II presents the performance of QuickCore versus
DDMin. We chose to compare QuickCore with DDMin
because DDMin is a well known and widely used algorithm
for core computation over a monotonic criteria, and because
it was previously used in the context of unrealizable cores
for GR(1) speciﬁcations. Moreover, in R0 above we showed
thatDDMin is the most efﬁcient domain-agnostic single core
algorithm on our corpus.
The columns show the geometric mean of the ratio of
the running times (namely, the running time of QuickCore
divided by that of DDMin), dissected by the running time
range obtained for DDMin, for all speciﬁcations in each set.
We use ‘-’ to mark cases in which no speciﬁcations had
DDMin running time within the corresponding range. For
example, the number 0.30 in the third row means that for
AM+GN speciﬁcations for which a core was found by DDMin
in between 10 and 100 seconds, the geometric mean indicates
thatQuickCore was more than three times faster than
DDMin.
The results show that QuickCore is in most cases much
faster than DDMin. This improvement gets better with scale,
i.e., almost consistently, the slower DDMin, the faster Quick-
Core becomes relative to it. The acceleration is most notice-
able for SYN17U speciﬁcations for which DDMin require over
10 seconds. For those speciﬁcations QuickCore was faster
thanDDMin by well over an order of magnitude.Table III
CORE SIZES
Spec set Core Size QC DDMin QX Global
SYN15U 19% 5.14 5.07 5.21 5.07
SYN17U 18% 4.5 4.38 4.5 3.92
Table IV
NUMBER OF CORES
Spec set S M51050100
SYN15U 6 8 5 2 1 0
SYN17U 6 20 9 7 4 4
The only two categories in which the running time of
QuickCore is worse than that of DDMin is for SYN17U
andAM+GN speciﬁcations whose DDMin running time is at
most 100 milliseconds. Since for this range running times are
very small, we do not consider it to be a major weakness of
QuickCore.
We also computed the actual number of realizability checks
(i.e., without realizability checks avoided by memoization, see
Sect. VI) of QuickCore andDDMin (not shown in the
table). We found that the median reduction in the number
of actual realizability checks of QuickCore overDDMin
was 11.3%, 19.5%, and 15.4%, and over QuickXplain was
3.3%, 10.2%, and 27.6%, for SYN15U, SYN17U, and AM+GN,
respectively.
To answer R1: QuickCore typically performs fewer real-
izability checks than DDMin andQuickXplain, it is in
most cases much faster than DDMin, and the running time
improvement seems to become better with scale.
F . Results: Effectiveness of QuickCore
Table III presents core size results. Column Core size
shows the median ratio between the size of cores found
byQuickCore and the total number of guarantees in the
speciﬁcation. Columns QC,DDMin, QX, and Global show
the average absolute size of the cores found by QuickCore,
DDMin, QuickXplain, and the size of the smallest core
found until the timeout by Punch, respectively.
The results show that in the SYNTECH speciﬁcations, most
of the cores found by QuickCore are over ﬁve times smaller
than the total number of guarantees in the speciﬁcation. They
further show that the cores found by QuickCore have a
slightly different size than the cores found by the other
algorithms, and that all algorithms output cores that are close
in size to the size of the globally minimal core.
To answer R2: QuickCore, DDMin, and QuickXplain
are all effective in localizing unrealizability.
G. Results: Number of Cores in Speciﬁcations
Table IV presents the number of cores in the SYNTECH
speciﬁcations. Columns ‘S’ and‘M’ show how many spec-
iﬁcations have a single core and multiple cores, resp. The
remaining four columns show how many of these speciﬁca-
tions have at least 5, 10, 50, and 100 cores. For example, the
33051015202530
SYN15U
TDSYN15U
PUDSYN15U
PQCSYN17U
TDSYN17U
PUDSYN17U
PQCAM+GN
TDAM+GN
PUDAM+GN
PQC#Specifications
0.1s1s10s100s600sTOFigure 1. Running times to compute all cores using TD(left columns)
PUD (center columns), and PQC (right columns), for the SYNTECH
and the AM+GN sets, divided by increasing ranges, in seconds.
number 1 in the ﬁrst row under ‘ 50’ means that exactly
one speciﬁcation of SYN15U has at least 50 cores.
To answer R3: Most SYNTECH speciﬁcations have multiple
cores. Speciﬁcations with over 50 cores exist in each set of
speciﬁcations. These results motivate the need to compute
more than one core per speciﬁcation.
H. Results: Running Times of All Cores Algorithms
In order to evaluate the performance of Punch for com-
puting all unrealizable cores, we use PQC andPUD (see
Sect. V-C).
Since Punch is the ﬁrst algorithm employed to compute
all unrealizable cores for temporal speciﬁcations reducible to
GR(1), as a comparison, we use a rather naive baseline we
label TD(we discuss alternative algorithms in Sect. IX).
TDis a naive top down search for all cores. For a given
subset of guarantees, if check fails, TDknows that the
subset and all its subsets are not cores. Otherwise, it continues
recursively to all subsets that exclude exactly one element. It
detects the set as a core iff all of these subsets fail check.
It memoizes subsets we already ﬁnished computing all cores
for, to avoid unnecessary recursive calls (in addition to the
memoization described in Sect. VI). To detect unrealizable
cores, check is implemented as an unrealizability check.
Figure 1 shows the running times for SYN15U, SYN17U,
andAM+GN speciﬁcations. Each speciﬁcation set has three
columns, one for TD, one for PUD, and one for PQC. Each
column shows a breakdown of how many speciﬁcations com-
pleted running within 0.1, 1, 10, 100, and 600 seconds. Finally,
we mark the number of speciﬁcations that timed out (did not
complete all 10 runs within 10 minutes) with TO.
The results show that the differences between the perfor-
mance of PUD andPQC are minor, with mostly a slight
advantage to PQC. Regardless of their minor differences, the
two instances of Punch perform signiﬁcantly better than TD.
The two instances of Punch were able to ﬁnd all cores of
SYN15U speciﬁcations within 100 seconds, and 22 out of
the 26 of the SYN17U speciﬁcations before the timeout wasreached. This is much better than TD, which was able to
ﬁnd all cores within the timeout for less than half of the
speciﬁcations. On AM+GN speciﬁcations, PUD andPQC found
all cores for 5 and 6 speciﬁcations respectively, but TDdid
not complete the computation on any of the speciﬁcations.
To answer R4: Both instances of Punch are signiﬁcantly
faster than TDin ﬁnding all the cores of a speciﬁcation.
PQC seems slightly better than PUD.
I. Additional Results
Recall that Punch provides early detection of the intersec-
tion of all the cores (see Sect. V-B). The size of the intersection
is a lower bound on the size of the global minimum. In
practice, it provides a good early estimate of the size of
the global minimum for SYNTECH speciﬁcations. The results
show that the core intersection size is on average 76.8% and
52.5% of the smallest core found by Punch within the timeout
forSYN15U andSYN17U respectively.
J. Threats to Validity
We discuss threats to the validity of our results. First,
symbolic computations are not trivial and our implementation
ofQuickCore, DDMin, QuickXplain, and Punch may
contain bugs. To mitigate, we performed a thorough validation
using all speciﬁcations available to us, see Sect. VIII-B. Sec-
ond, we have based most of our evaluation on the SYNTECH
speciﬁcations, which were created by 3rd year undergraduate
CS students with no prior experience in writing LTL speciﬁ-
cations (collected by the authors of [20] in classes they have
taught). We further examined speciﬁcations from the AM+GN
set. We do not know if these are representative of speciﬁcations
engineers would write in practice. Third, although we have
found that cores are typically much smaller than the complete
set of guarantees (see Tbl. III, roughly 5 guarantees instead
of 25), we did not perform a user-study, with engineers, to
examine whether users will ﬁnd the reported cores useful
for understanding the reasons for the unrealizability of their
speciﬁcations.
IX. R ELATED WORK
A. A Single Unrealizable Core for GR(1)
Previous works have considered the computation of an unre-
alizable core for GR(1) speciﬁcations. Cimatti et al. [11] have
used LinearMin (see Sect. III-C). Konighofer et al. [15]
have used DDMin and implemented it in the RATSY synthe-
sizer. Their comparison of DDMin withLinearMin shows
thatDDMin is almost always much faster than LinearMin,
with a greater advantage on larger speciﬁcations. Firman et
al. [13] have used DDMin with several performance heuristics,
including memoization, and implemented it in the Spectra
synthesizer. All these were limited to computing a single core
and did not correctly handle speciﬁcations with constructs
beyond pure GR(1). We present QuickCore to be used
instead of DDMin. We further show how to correctly handle
speciﬁcations with constructs beyond pure GR(1). We compare
34QuickCore to Spectra’s implementation of DDMin, i.e., with
the heuristics from [13], and our evaluation provides evidence
thatQuickCore is faster and scales better than DDMin.
Our choice of DDMin for both the algorithm we compare to,
and the algorithm used within QuickCore for the incremen-
tal minimization, is based both on DDMin being a well known
and widely used domain-agnostic minimization algorithm, and
on the fact that it was the choice in previous work on GR(1)
unrealizability.
There are other domain-agnostic minimization algorithms
over monotonic criteria for single cores, e.g., QuickX-
plain [14], [24]. Compared to DDMin, QuickXplain has
a better asymptotic complexity in terms of the number of
checks (see Sect. III-C). Nevertheless, as we show in our
evaluation (Sect. VIII-D), QuickXplain performs worse on
our corpus.
For temporal speciﬁcations, Schuppan [27] presented LTL
unsatisﬁability cores by weakening LTL formulas in a way
that ignores sub-formulas not required for unsatisﬁability. He
further presented a similar approach for GR(1) unrealizability
cores. To the best of our knowledge, these ideas have only been
explored theoretically. Moreover, the work neither handles all
cores nor deals with extensions of GR(1).
B. All Unrealizable Cores for GR(1)
We present Punch as the ﬁrst efﬁcient algorithm to
compute all unrealizable cores of speciﬁcations reducible to
GR(1). However, Punch is a domain-agnostic algorithm.
Other domain-agnostic algorithms for all cores computations
over monotonic criteria appear in the literature, see, e.g., [17].
In [3] there is a comparison of several such algorithms, which
concludes that none of the known algorithms is better than the
others in all domains. Recently, MUST [4] was proposed as
an algorithm and tool that outperforms previous ones.
Punch is intended as a ﬁrst algorithm for the computation
of all cores of unrealizable GR(1) speciﬁcations. We consider
its comparison against domain-agnostic algorithms, as well as
its specialization for GR(1) as future work, see Sect. X.
C. Other Approaches to Dealing with GR(1) Unrealizability
Beyond core computations, other approaches have been
suggested to dealing with unrealizability of GR(1) speciﬁca-
tions. Maoz and Sa’ar [22] have presented the computation
of counter-strategies, which show how the environment can
prevent any system from satisfying the speciﬁcation. Kuvent
et al. [16] have presented the JVTS, a symbolic, more succinct
and simple representation of a GR(1) counter-strategy.
Other works have considered means to repair unrealizable
speciﬁcations by automatically suggesting additional assump-
tions that will make the speciﬁcation realizable, see, e.g., [2],
[8], [9], [10], [21]. It may be possible to combine the com-
putation of a core or of all cores with a repair approach. See
our discussion of future work in Sect. X.
X. C ONCLUSION AND FUTURE WORK
We presented three contributions related to the computation
of unrealizable cores of GR(1) speciﬁcations, including fasteralgorithms for computing an unrealizable core and for comput-
ing all cores. We further presented means to correctly compute
the core when speciﬁcations include high-level constructs.
We implemented our work, validated its correctness, and
evaluated it on benchmarks from the literature. The evaluation
shows that QuickCore is usually faster than previous algo-
rithms, with a relative advantage that improves with scale.
Moreover, we found that most speciﬁcations have multiple
cores, and that Punch ﬁnds all the cores signiﬁcantly faster
than a competing naive algorithm.
Our work has important implications to anyone using GR(1)
speciﬁcations and their extensions for synthesis and related
analyses. First, core computations are now faster, and comput-
ing more than one core promotes a more comprehensive view
of unrealizability. Moreover, we handle higher-level constructs
correctly and efﬁciently, and our algorithm for ﬁnding all cores
extends to cores for any monotonic criterion.
We consider the following concrete future work directions.
First, as Punch in its raw form is domain-agnostic, it is
important to compare its performance with recent domain-
agnostic all cores minimization algorithms over monotonic
criteria such as MUST [4].
We have already presented a variant of Punch, namely
PQC, which employs a domain-speciﬁc algorithm (a variant
ofQuickCore) to compute a single core, and compared
it with another variant, namely PUD, which uses DDMin, a
domain-agnostic algorithm for a single core computation. The
results showed that PQC performs slightly better than PUD.
It may be possible to improve the performance of detecting
all unrealizable cores by taking advantage of GR(1) speciﬁc
properties in other ways.
Second, we consider means to combine the computation of
a core or of all cores with a repair approach. For example, a
repair of unrealizability that is based on weakening a small as
possible subset of the guarantees could rely on the fact that it
cannot succeed without weakening at least one guarantee from
every core, or in particular weakening one guarantee from a
non-empty intersection of all cores.
Finally, the ability to compute all cores raises questions
as to their presentation to the engineer. Should all cores be
computed and presented? Perhaps an on demand approach
should be used? In which order should we present the cores?
These questions call for further investigation and evaluation.
ACKNOWLEDGEMENTS
We thank the anonymous reviewers for their helpful com-
ments. We thank Roee Sinai for implementing the Quick-
Xplain algorithm in the Spectra environment. We thank
Inbar Shulman for comments about an earlier draft of the
paper. This project has received funding from the European
Research Council (ERC) under the European Union’s Horizon
2020 research and innovation programme (grant agreement No
638049, SYNTECH).
35REFERENCES
[1] Supporting materials website. http://smlab.cs.tau.ac.il/syntech/
unrealcores/.
[2] R. Alur, S. Moarref, and U. Topcu. Counter-strategy guided reﬁnement
of GR(1) temporal logic speciﬁcations. In FMCAD, pages 26–33. IEEE,
2013.
[3] J. Bend ´ık and I. Cerna. Evaluation of domain agnostic approaches for
enumeration of minimal unsatisﬁable subsets. In LPAR, volume 57 of
EPiC Series in Computing, pages 131–142, 2018.
[4] J. Bend ´ık and I. Cern ´a. MUST: minimal unsatisﬁable subsets enumera-
tion tool. In A. Biere and D. Parker, editors, TACAS, volume 12078 of
LNCS, pages 135–152. Springer, 2020.
[5] R. Bloem, S. J. Galler, B. Jobstmann, N. Piterman, A. Pnueli, and
M. Weiglhofer. Interactive presentation: Automatic hardware synthesis
from speciﬁcations: a case study. pages 1188–1193. EDA Consortium,
San Jose, CA, USA, 2007.
[6] R. Bloem, S. J. Galler, B. Jobstmann, N. Piterman, A. Pnueli, and
M. Weiglhofer. Specify, compile, run: Hardware from PSL. Electr.
Notes Theor. Comput. Sci., 190(4):3–16, 2007.
[7] R. Bloem, B. Jobstmann, N. Piterman, A. Pnueli, and Y . Sa’ar. Synthesis
of Reactive(1) Designs. J. Comput. Syst. Sci., 78(3):911–938, 2012.
[8] D. G. Cavezza and D. Alrajeh. Interpolation-based GR(1) assumptions
reﬁnement. In TACAS, volume 10205 of LNCS, pages 281–297, 2017.
[9] D. G. Cavezza, D. Alrajeh, and A. Gy ¨orgy. A weakness measure for
GR(1) formulae. In FM, volume 10951 of LNCS, pages 110–128.
Springer, 2018.
[10] D. G. Cavezza, D. Alrajeh, and A. Gy ¨orgy. Minimal assumptions
reﬁnement for realizable speciﬁcations. In FormaliSE@ICSE 2020: 8th
Int. Conf. on Formal Methods in Software Engineering, pages 66–76.
ACM, 2020.
[11] A. Cimatti, M. Roveri, V . Schuppan, and A. Tchaltsev. Diagnostic
information for realizability. In VMCAI, volume 4905 of LNCS, pages
52–67. Springer, 2008.
[12] M. B. Dwyer, G. S. Avrunin, and J. C. Corbett. Patterns in property
speciﬁcations for ﬁnite-state veriﬁcation. In ICSE, pages 411–420.
ACM, 1999.
[13] E. Firman, S. Maoz, and J. O. Ringert. Performance heuristics for GR(1)
synthesis and related algorithms. Acta Inf., 57(1-2):37–79, 2020.
[14] U. Junker. QUICKXPLAIN: preferred explanations and relaxations for
over-constrained problems. In D. L. McGuinness and G. Ferguson,
editors, AAAI, pages 167–172. AAAI Press / The MIT Press, 2004.
[15] R. K ¨onighofer, G. Hofferek, and R. Bloem. Debugging formal speciﬁ-
cations: a practical approach using model-based diagnosis and counter-
strategies. STTT, 15(5-6):563–583, 2013.
[16] A. Kuvent, S. Maoz, and J. O. Ringert. A symbolic justice violations
transition system for unrealizable GR(1) speciﬁcations. In ESEC/FSE,
pages 362–372, 2017.
[17] M. H. Lifﬁton, A. Previti, A. Malik, and J. Marques-Silva. Fast, ﬂexible
MUS enumeration. Constraints An Int. J., 21(2):223–250, 2016.
[18] S. Maniatopoulos, P. Schillinger, V . Pong, D. C. Conner, and H. Kress-
Gazit. Reactive high-level behavior synthesis for an atlas humanoid
robot. In ICRA, pages 4192–4199, 2016.
[19] S. Maoz and J. O. Ringert. GR(1) synthesis for LTL speciﬁcation
patterns. In ESEC/FSE, pages 96–106. ACM, 2015.
[20] S. Maoz and J. O. Ringert. Spectra: A speciﬁcation language for reactive
systems. Software and Systems Modeling, 2021. To appear.
[21] S. Maoz, J. O. Ringert, and R. Shalom. Symbolic repairs for GR(1)
speciﬁcations. In ICSE, pages 1016–1026, 2019.
[22] S. Maoz and Y . Sa’ar. Counter play-out: executing unrealizable scenario-
based speciﬁcations. In ICSE, pages 242–251, 2013.
[23] S. Maoz and R. Shalom. Inherent vacuity for GR(1) speciﬁcations. In
ESEC/FSE, pages 99–110. ACM, 2020.
[24] J. Marques-Silva, M. Janota, and A. Belov. Minimal sets over monotone
predicates in boolean formulae. In CAV, pages 592–607. Springer, 2013.
[25] N. Piterman, A. Pnueli, and Y . Sa’ar. Synthesis of reactive(1) designs.
InVMCAI, volume 3855 of LNCS, pages 364–380. Springer, 2006.
[26] A. Pnueli and R. Rosner. On the Synthesis of a Reactive Module. In
POPL, pages 179–190. ACM Press, 1989.
[27] V . Schuppan. Towards a notion of unsatisﬁable and unrealizable cores
for LTL. Sci. Comput. Program., 77(7-8):908–939, 2012.
[28] Spectra Website. http://smlab.cs.tau.ac.il/syntech/spectra/.
[29] A. Zeller and R. Hildebrandt. Simplifying and isolating failure-inducing
input. IEEE Trans. Software Eng., 28(2):183–200, 2002.
36