SADT: Syntax-Aware Differential Testing of Certificate
Validation in SSL/TLS Implementations
Lili Quan
College of Intelligence and
Computing, Tianjin University
ChinaQianyu Guoâˆ—
College of Intelligence and
Computing, Tianjin University
ChinaHongxu Chen
School of Computer Science and
Engineering, Nanyang Technological
University, Singapore
Xiaofei Xieâ€ 
School of Computer Science and
Engineering, Nanyang Technological
University, SingaporeXiaohong Li
College of Intelligence and
Computing, Tianjin University
ChinaYang Liu
School of Computer Science and
Engineering, Nanyang Technological
University, Singapore
Jing Huâ€ 
College of Intelligence and
Computing, Tianjin University
China
ABSTRACT
ThesecurityassuranceofSSL/TLScriticallydependsonthecorrect
validationofX.509certificates. Therefore,itisimportanttocheck
whetheracertificateiscorrectlyvalidatedbytheSSL/TLSimple-
mentations. Although differential testing has been proven to be
effectiveinfindingsemanticbugs,itstillsuffersfromthefollowing
limitations: (1) The syntax of test cases cannot be correctly guaran-
teed.(2)Currenttestcasesarenotdiverseenoughtocovermore
implementationbehaviours.Thispapertacklestheseproblemsby
introducing SADT, a novel syntax-aware differential testing frame-
work forevaluating thecertificate validationprocessin SSL/TLS
implementations. We first propose a tree-based mutation strategy
toensurethatthegeneratedcertificatesaresyntacticallycorrect,
and then diversify the certificates by sharing interesting test cases
among all target SSL/TLS implementations. Such generated cer-tificates are more likely to trigger discrepancies among SSL/TLS
implementations, which may indicate some potential bugs.
To evaluate the effectiveness of our approach, we applied SADT
on testing 6 widely used SSL/TLS implementations, compared withthestate-of-the-artfuzzingtechnique(i.e.,AFL)andtwodifferentialtestingtechniques(i.e.,NEZHAandRFCcert).Theresultsshowthat
SADToutperformsothertechniquesingeneratingdiscrepancies.
In total, 64 unique discrepancies were discovered by SADT, and 13
of them have been confirmed as bugs or fixed by the developers.
âˆ—QianyuGuocontributesequallywithLiliQuantothispaperandistheco-firstauthor.
â€ Xiaofei Xie (xfxie@ntu.edu.sg) and Jing Hu (mavis_huhu@tju.edu.cn) are the corre-
sponding authors.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACMmustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ASE â€™20, September 21â€“25, 2020, Virtual Event, Australia
Â© 2020 Association for Computing Machinery.
ACM ISBN 978-1-4503-6768-4/20/09...$15.00
https://doi.org/10.1145/3324884.3416552CCS CONCEPTS
â€¢Software and its engineering â†’Software testing and de-
bugging.
KEYWORDS
Differentialtesting,Certificatevalidation,SSL/TLSImplementation
ACM Reference Format:
Lili Quan, Qianyu Guo, Hongxu Chen, Xiaofei Xie, Xiaohong Li, Yang Liu,
and JingHu. 2020.SADT: Syntax-Aware DifferentialTesting ofCertificate
Validation in SSL/TLS Implementations. In 35th IEEE/ACM International
ConferenceonAutomatedSoftwareEngineering(ASEâ€™20),September21â€“25,
2020, Virtual Event, Australia. ACM, New York, NY, USA, 12 pages. https:
//doi.org/10.1145/3324884.3416552
1 INTRODUCTION
TheSecureSocketsLayer(SSL)[ 4]anditsdescendantTransport
Layer Security (TLS) [ 44] protocols are the foundations of internet
security.Forexample,HypertextTransferProtocolSecure(HTTPS)
[45]usesthemtoprovidetrustedauthenticationandsecurecom-
munication. SSL/TLS authenticates a server or client by validating
the X.509 certificate during the handshake phase to ensure a se-
cure connection. The authentication on a server means that the
client validates the certificate presented by the server to determine
whether it is a genuine communication server. The authentication
on a client is also the similar way. After the server/client is authen-
ticated, subsequent communications can be launched. Therefore,it is critically important to ensure the correctness of certificate
validation by SSL/TLS implementations.
Acommunicationmaybedangerousifaninvalidcertificatesent
bymaliciousserver/clientisfalselyaccepted.Similarly,anormal
communication requirement may be denied if a valid certificate
sentbybenignserver/clientisfalsely rejected.Ho wever,thecertifi-
cate validation is a complex process involving many aspects, such
as checking multiple fields (e.g., validity,public key, extensions )
inacertificateandverifyingeachcertificatealongthecertificatechain. Existing SSL/TLS implementations conduct the validation
5242020 35th IEEE/ACM International Conference on Automated Software Engineering (ASE)
conforming to the specifications in Request For Comments (RFCs)
(i.e., RFC 2527 [ 13], RFC 5246 [ 46], RFC 5878 [ 5], RFC 5280 [ 14],
RFC 6101 [ 16], RFC 6818 [ 58], and RFC 6125 [ 47]). However, the
developersmayhavedifferentunderstandingsonthesespecifica-
tions, which may further lead to the incorrect implementations.
Thismakesthecertificatevalidationremainasaweakpartinthe
whole network ecosystem. Therefore, a systematic testing tech-
nique is still in urgent need for evaluating the quality of certificate
validation of SSL/TLS implementations.
Recently,someapproacheshavebeenproposedtoevaluatethe
SSL/TLS certificate validation process [ 6â€“8,42] based on the dif-
ferential testing technique [ 31]. The basic idea is to cross-check
thebehavioursamongmultipleSSL/TLSimplementations.Ifone
implementationacceptsaninputwhileanotherrejectsit,thedis-
crepancy occurs, which can be considered as a potential bug. How-
ever, existing differential testing based techniques still suffer from
the following three limitations: 1) Existing techniques are ineffi-
cientbecausetheyheavilyrelyonalargenumberofcertificatesfor
constructing a well-behaved corpus to discover semantic bugs. For
example, Frankencert [ 6] finds only 9 unique discrepancies among
15SSL/TLSimplementationsusing243,246seedcertificatesasin-
puts.2)Thediversityofgeneratedcertificatesisnotenoughtocover
all validation behaviours in SSL/TLS implementations, which may
miss some corner cases. A typical example is RFCcert [ 8], which
aimsatgeneratingcertificatesthatviolatetheextractedrules.How-
ever,therulesmaybeincomplete,andmanycertificatesthatsatisfy
the rules but may rev eal bugs are missed. 3) Some mutation-based
differential testing techniques cannot guarantee that the generated
certificates are syntactically correct. Such invalid certificates aremore likely to be filtered, making the testing ineffective. For in-
stance,NEZHA[ 42]directlymutatesthecertificatefiles,regardless
of the structured X.509 syntax, and generates enormous amount of
test cases that are syntactically incorrect (e.g., 97.52% syntactically
incorrect certificates after 100,000 mutations in our experiments).
To tackle these problems, we propose SADT, a novel syntax-
aware differential testing based framework for detecting bugs in
the certificate validation process of SSL/TLS implementations. The
maindifferencebetweenourapproachandpreviousworkisthatthecertificatesgeneratedbySADTaremorelikelytotriggerdiscrepan-
cies, meanwhile the syntax is ensured to be correct. Specifically, a
tree-based mutation strategy is first proposed to guarantee the syn-
taxcorrectnessofgeneratedcertificates.Thenaglobalcoverageonalltargetedimplementationsisintroducedtoguidetheselectionofthe certificate. Finally, such generated certificates are employed forthe cross validation in different implementations. In order to evalu-atetheperformanceofSADT,wedesignexperimentson6SSL/TLS
implementations to answer the following research questions:
RQ1: How effective is SADT in discovering discrepancies?
RQ2: How does SADT perform compared to the state-of-the-art
differential testing frameworks?
RQ3: How does SADT perform compared to the state-of-the-art
fuzzing technique (i.e., AFL)?
In summary, this paper makes the following main contributions:
â€¢Tree-basedmutation. Weintroduceanovel tree-basedmutation
strategy which parses the certificate into a tree according to the! !!
)*!&%
)!#,$)
!%+,)
**,)


#!!+/
,"+	
,"+,#!/%&
**,)%!(,
,"+%!(,	.+%*!&%*
*!&%*+)!%+*
!+

!"!!""
 
 	! !!
)*!&%
)!#,$)!%+,)**,)	
#!!+/
,"+
,"+,#!/%&
**,)%!(,
,"+%!(,	.+%*!&%*
*!&%*+)!%+*
!+

!"!!""! !!
)*!&%
)!#,$)!%+,)**,)


#!!+/
,"+


,"+,#!/%&**,)%!(,,"+%!(,	.+%*!&%*
*!&%*+)!%+*
!+

!"!
!""			
Figure 1: General structure of a certificate chain.
X.509syntaxandmutatesthenodesonittoobtainnewcertifi-
cates. This method can guarantee syntactical correctness of the
generated certificates and it may be applicable in the generation
of other syntactically complex inputs.
â€¢The global coverage guidance. We propose the global coverage
guidance by sharing interesting test cases across all tested imple-
mentationstodiversifythecertificategenerationthataremore
likely to trigger discrepancies.
â€¢Implementation and evaluation. We implement SADT by extend-
ingAFLandcompareagainstthestate-of-the-artdifferentialtest-
ing techniques (i.e., NEZHA and RFCcert) on 6 popular SSL/TLS
implementations.TheresultsshowthatSADTimprovestheca-
pability of bug detection in these SSL/TLS implementations.
â€¢Communityfeedback. WehavereportedthebugsfoundbySADT.
To date, 13 bugs have been confirmed or fixed by developers.
The remainder of this paper is organized as follows. Section 2
brieflyintroducesX.509certificateandcertificatevalidation.Sec-
tion 3presentsthe technicaldetails ofour approachincluding the
certificate generation and cross validation. Section 4 shows the
effectiveness and performance of SADT. Related work is discussed
in Section 5 and this paper is concluded in Section 6.
2 BACKGROUND
2.1 X.509 Certificate
TheX.509certificateisasigneddatastructurethatbindsapublic
keytoaperson,computer,ororganizationanditisusedinmanyIn-
ternet protocols, including SSL/TLS. However, it is also complex in
structureandsyntax.AsshowninFigure1,eachcertificateconsists
ofasequenceofthreerequiredfields:(1) tbsCertificate,(2) Signa-
tureAlgorithm,and(3) SignatureValue.Thefirstpart tbsCertificate
containsasubject,anissuerandotherbasicinformation.Compared
withtheversion-1certificate,theversion-2certificateaddsthe Sub-
jectUniqueID (SubjectUniqueIdentifiers)and IssuerUniqueID (Issuer
UniqueIdentifiers)fields.Inaddition, Extensions areaddedtothe
version-3 certificate. The second part SignatureAlgorithm contains
theidentifierofthesignaturealgorithmusedbyCertificateAuthor-
ity (CA) to sign this certificate. As the third part, SignatureValue
records the digital signature computed upon tbsCertificate.
InPublicKeyInfrastructure(PKI),acertificateisusuallyorga-
nized into a certificate chain together with itâ€™s issuers. Figure 1
shows the general structure of a certificate chain. In general, each
525"#%$$ 


"$$"$  " ##$ %$$ (
	



$)*(+#$*
(%(#)
"" "#
%


 
 &"
%
 

  	

"$  "!%#
	

$)*(+#$** %$
%+""$
"#"  # 	
	

    
 

 
 

	#"!' ! "$
Figure 2: Overview of SADT
certificate chain starts with a leaf certificate followed by all the
issuersandeachcertificateinitissignedbythenextcertificateand
the last certificate (i.e., the root certificate) is a trusted self-signed
CAcertificate.Moreover,the Issuerofacertificateisequaltothe
Subjectof the next certificate. More details about X.509 certificate
can be found in RFC 5280 [14].
The X.509 certificate is encoded by the Distinguished Encoding
Rules (DER) [ 32]. The transfer syntax used by DER always follows
theformat /angbracketleftğ‘‡ğ‘ğ‘”,ğ¿ğ‘’ğ‘›ğ‘”ğ‘¡â„,ğ‘‰ğ‘ğ‘™ğ‘¢ğ‘’ /angbracketrightthatisusuallyreferredtoasaTLV
tripletinwhicheachfield(T,L,orV)containsoneormorebytes.
TheTagspecifiesthetypeofthedatastructure.Forexample,the
Tag0x02represents the current data type is Integer, and the Tag
0x06representsthecurrentdatatypeis ObjectIdentifier.The Length
specifies the number of bytes of Valuefield, and the Valuestores
data content. According to DER transfer syntax, basic and string
types are encoded by using primitive forms, while constructed
types are encoded in a constructed form. Note that the Valuefield
is triplet if the data type is constructed form as shown in Figure 3.

Figure 3: The DER data structure
2.2 Certificate Validation
Certificate validation is the key of authentication since it checks
the genuineness and validity of certificates. It usually requires two
inputs: the trusted CA certificates and a certificate chain to be val-
idated. During the validation process, SSL/TLS implementationsfirst check whether the content of the leaf certificate is valid at
the current time, including checking the validity periodand basic
constraints of other fields. Then they check whether the certificate
is issued by a valid CA through checking the validity of the next
certificate (issuer certificate) in the certificate chain, and validating
thesignature value by the signature algorithm. This process con-
tinues along the certificate chain until the certificate be checked
appears in the trusted certificate set. A certificate will be accepted
if and only if all of checks mentioned above are passed. Otherwise
it is rejected. More information about certificate validation can be
found in RFC 5246 [46] and RFC 6125 [47].3 APPROACH
This section presents the technical details of our approach. We
introducetheoverviewofSADT,andthendiscussthealgorithms
of certificate generation and cross validation.
3.1 Overview
Figure 2 presents the overview of SADT, which consists of two
phases: the certificate generation (Section 3.2) and the cross valida-
tion (Section 3.3). In the phase of certificate generation, new testcases (i.e., certificates) are generated with the help of tree-based
mutation andglobal coverage guidance. Specifically, before start-
ing to generate certificates, all of the target SSL/TLS programs are
instrumentedbytheinstrumentationmodule(see 1),sothatthe
code coverage information can be obtained in execution (see 2).
Next, SADT randomly selects a seed certificate from the certificate
corpus (see 3), which will be first parsed from a nested TLV-based
DER format (Section 2.1) into a tree-based structure by the cert
parser(Section3.2.1,see 4and5).Suchtree-basedstructureisalso
known as Generic Certificate Tree (GCT) in this paper. Then SADT
conductsthetree-basedmutationbyrandomlychangingtheleaf
nodes and recursively updating the tree (Section 3.2.2, see 6). The
mutatedtreeisthenparsedbacktoaDER-formatcertificate(see
7). Afterwards, we run the generated certificate on those instru-
mented programs in parallel, with the support of a global guidance
engine (Section 3.2.3, see 8). Note that, the guidance engine is
designed here to cover the code paths of all SSL/TLS tools as many
as possible. It determines whether the mutated certificate is able to
triggernewcodecoverageinanyofthetargetedSSL/TLStools(see
9). If yes, SADT adds the mutated certificate into the certificate
corpusforfurtheriteration;Otherwise,SADTdiscardsit(see 10).
Werepeatedlyconducttheaforementionedstepsformultipletimes
(i.e., a time budget) to obtain an extensive certificate corpus.
Thecertificatecorpusisfurtherdeployedforcrossvalidation(Sec-
tion3.3)whenthecertificategenerationphaseiscompleted.Inthis
phase, each certificate in the corpus is fed to all SSL/TLS toolsin parallel (see
11), and the output vector for each certificate is
recorded (see 12). As shown in Figure 2b, an output vector consists
of a certificate name ( ğ¶ğ‘) and the validation results on each imple-
mentation,where0meansâ€œaccept"thecertificateandthenon-zero
number means â€œreject" it with different return values. We get alarge number of validation vectors, corresponding to individual
526	
	
    
(a) DER code snippet
	




(b) The initial GCT


	



(c) The mutated GCT
Figure 4: The examples of data structure for DER and GCT.
testcases.SADTchecksthesevectorstoidentifywhetherthereare
discrepancies.Adiscrepancyisfoundwhenthereareatleasttwo
implementationsexhibitdifferentoutputs.Finally,wesummarize
the discrepancy report for further bug confirmation (see 13).
3.2 Certificate Generation
Theperformanceofsoftwaretestinglargelydependsonthequality
oftestcases,especiallywhenthetargetprogramrequireshighly-
structuredinputs.SpecifictoSSL/TLSvalidation,weneedalarge
numberofrepresentativecertificatesastestcases.However,asmen-
tioned earlier, the certificates generated by previous work suffer
fromvariouslimitationssuchasthesyntacticalincorrectnessand
high redundancy. SADT aims to address such problems by intro-
ducingtwonovelsolutions:1)atree-basedmutationstrategyfor
ensuring the syntactical correctness during certificate generation,
and2) aglobalcoverageguidance fordiversifiedtest caseselection.
3.2.1 Certificate Parsing. Toobtainhigh-qualitycertificatesthat
conformtothestrictsyntaxrequirementsinmutation,weneeda
deep understanding on the certificate composition. In other words,
given a certificate, we need to address the following two concerns:
howtopreciselylocateeachfieldandhowtoextractthefieldvalue.
As described in Section 2.1, the certificate is composed of a nested
/angbracketleftğ‘‡ğ‘ğ‘”,ğ¿ğ‘’ğ‘›ğ‘”ğ‘¡â„,ğ‘‰ğ‘ğ‘™ğ‘¢ğ‘’ /angbracketrighttriplet,a.k.a.TLVtriplet,encodedbytheDER.
Thestructureis nestedinthatwhenwegetafield valueinaTLV
triplet,thevalueitselfmaybeanothernestedstructure,whichneeds
toberecursivelyobtained.Thisissimilartotraversingvalueson
thetree.Therefore,thecertificatecanberepresentedasatree-based
structure so as to facilitate the field location and value acquisition.
TheCert Parser is introduced for parsing the DER format certifi-
cateintoatree-basedstructure,whichwecallthe GenericCertificate
Tree(GCT) inthispaper.Specifically,theGCTisatreewithmul-
tipletypednodes,whereeachnodeisaTLVtriplet,representing
a particular certificate component. It should be noted that, each
subsequent node next to the root node represents a certificate field,
whose value is recursively determined by its sub-tree. As to the
bottomoftree,theleafnoderepresentsanatomiccontentwhich
can be directly translated by DER (e.g., an integer number).
Figure 4 shows an example converting DER to GCT. Consider
the DER snippet in Figure 4a, it is a nested TLV triplet, where
theroottag,intermediatetagsandendtagaremarkedasthered
box (i.e., 30), blue boxes (i.e., 30and02), and green box (i.e., 02),
respectively. Specifically, for the root triplet, the tag 30means it
is aSEQUENCE. The length 0a(a hexadecimal number) indicatesthatthevaluesofthis SEQUENCE occupythefollowing10bytes,
ranging from the index 2to index11. Similarly, we can identify the
twointermediatetriplets(i.e.,theindices 2-6and7-11,respectively)
and the end triplet (i.e., the indices 4-6). Note that, the value of end
triplet is a one-byte integer number 02which cannot be further
split.Basedonaboveobservations,wecanbuildtheGCTbylinking
the containment relationship between each triplet. As shown in
Figure4b,node aandnode ccorrespondtotheroottripletandend
tripletinFigure4a,whilenode bandnode dcorrespondtothetwo
intermediate triplets, respectively.
Algorithm1presentsourcertificateparsingmethod,whichtakes
aDER-formatcertificate(i.e., ğ·)asinput,andoutputsaGCT(i.e., T)
corresponding to ğ·. Since the certificate is a nested TLV structure,
wecanfirstextracttheroot tag(i.e.,ğ‘‡),length(i.e.,ğ¿),andvalue(i.e.,
ğ‘‰)fromğ·(Lines2to4).ThenweconstructaninitialnodeforGCT
(Line 5), which also consists of three parts, corresponding to the
tag,length,and valueintheTLVtriplet,respectively(seeFigure4b).
Wedirectlyassigntheobtainedtagandlengthtothisnode(Line6).
Whenitcomestothenodevalue,weadoptsdifferentassignment
solutionsdependingonthestructuretype(i.e.,nodetag).According
totheDERencodingspecification,ifthetagbelongstotheprimitivetypes (Line 7), such as the Bit String (i.e.,03) andInteger(i.e.,02), it
means we get an atomic TLV triplet. Thus we consider the current
nodeasaleafnode,anddirectlyassigntheextracted valueğ‘‰tothe
valuepartofthisnode(Line8).Otherwise,itmeanswegetanested
TLVtriplet,wherethe valueğ‘‰canbefurthersplit.Therefore,we
considerthecurrentnodeasanrootorintermediatenode,which
needstorecursivelyconductthesameprocedureforbuildingthe
childnodesunderitsvaluepart(Line13).Notethat,fortheobtained
valueğ‘‰,itmaybeawrapperofmultiplesubsequentTLVtriplets,
thus we need to traverse all sub-TLV triplets on ğ‘‰(Lines 10 to 16).
Asaresult,wewillbuildmultiplesub-treesunderthecurrentnode.
Finally,afterrecursivelyassigningorlinkingnodesbasedonthe
DER triplet, we can build a hierarchical structure, a.k.a., the GCT.
3.2.2 Tree-based Mutation. Weperformcertificatemutationbased
onthetransformedGCT.Toensurethegeneratedcertificatesare
syntacticallycorrect,weapplyabottom-upmutationstrategyon
GCT, which can be divided into two phases: 1) the leaf selection,
and 2) the backtracking repair.
LeafSelection.Atthebeginning,wefirstneedtoselectatarget
componentincertificateastheentryformutation.Withthehelp
ofGCT,wecaneasilyobtainanycomponentbytraversingalong
thetree.Theoretically,eachcomponentcanbeconsideredasthe
candidate for mutation. However, as mentioned earlier, for some
componentTLVtripletsinacertificate,thevaluepartitselfmaybe
another sub-TLV triplet. As a result, a direct mutation on the value
partofsuchtripletswillinevitablydestroythecertificatesyntax,
generating a large number of low-quality certificates. With respect
to GCT, such triplets can be mapped to the intermediate nodes. By
contrast, the leaf node on GCT is the atomic triplet that cannot be
further split, making it syntax-free to change the value. Therefore,
we select the leaf nodes as the mutation entry. Specifically, we
recursively apply the Breadth-First Search (BFS) strategy on the
GCT for randomly localizing a leaf node to conduct the mutation.
BacktrackingRepair.GivenaleafnodeonGCT,wethenapply
thebuilt-inmutationstrategies(e.g.,bitflip)ofAFL tochangeits
527Algorithm 1: Certificate Parsing
Input :ğ·=/angbracketleftğ‘‡,ğ¿,ğ‘‰/angbracketright: An DER certificate
Output:T: A GCT corresponding to ğ·
1Function certParse( ğ·)
2ğ‘‡:=ğ‘”ğ‘’ğ‘¡ğ‘‡ğ‘ğ‘”(ğ·);
3ğ¿:=ğ‘”ğ‘’ğ‘¡ğ¿ğ‘’ğ‘›ğ‘”ğ‘¡â„ (ğ·);
4ğ‘‰:=ğ‘”ğ‘’ğ‘¡ğ‘‰ğ‘ğ‘™ğ‘¢ğ‘’ (ğ·);
5T:=ğ‘–ğ‘›ğ‘–ğ‘¡ğ‘ğ‘œğ‘‘ğ‘’ ();
6Tâ†’ğ‘¡,Tâ†’ğ‘™:=ğ‘ğ‘ ğ‘ ğ‘–ğ‘”ğ‘›ğ‘ğ‘œğ‘‘ğ‘’ (ğ‘‡,ğ¿);
7ifisAtomic(ğ‘‡)then
8 Tâ†’ğ‘£:=ğ‘‰; âŠ²Leaf node assignment
9else
10 ğ‘ƒ:=ğ‘“ğ‘–ğ‘Ÿğ‘ ğ‘¡ğ‘‡ğ¿ğ‘‰ (ğ‘‰);
11ğ‘–:=0;
12 repeat
13 Tâ†’ğ‘‰ğ‘–:=ğ‘ğ‘’ğ‘Ÿğ‘¡ğ‘ƒğ‘ğ‘Ÿğ‘ ğ‘’ (ğ‘ƒ);âŠ²Assign recursively
14 ğ‘ƒ:=ğ‘›ğ‘’ğ‘¥ğ‘¡ğ‘‡ğ¿ğ‘‰ (ğ‘‰);
15 ğ‘–:=ğ‘–+1;
16 untilğ‘ƒ=âˆ…;
17returnT;
valuepart (i.e., not the tagpart orlengthpart). Suppose the data
value before and after mutation on the valuepart areğ‘‰ğ‘œandğ‘‰ğ‘š,
respectively. It is very likely that ğ‘‰ğ‘šdiffers from ğ‘‰ğ‘œin both data
value and data length, due to the randomness in mutation. Since
thecertificateiscomposedofaseriesofnestedtriplets,anychange
in the data length of the underlying triplet will inevitably affect
the data length of the upper one. Therefore, we need to recursively
â€œrepairâ€ the node lengthpart along the GCT from bottom to top. In
this way, we ensure that the generated certificates always conform
to the syntax requirement.
Figure 4b and Figure 4c give an example on how the syntax-
awaremutationisconductedalongtheGCT.Considertheleafnode
ğ‘ininitialGCT(Figure4b),wemutatethevaluefrom 02to01,03,
andget anewleaf node ğ‘/prime,with thelengthof2 bytes(Figure4c).
Sincethelengthofthenodechangesfrom1to2duringmutation,
whichviolatesthesyntaxrestrictionofDER,weneedtorecursively
â€œrepairâ€ the length of upper nodes to ensure the correctness of the
syntax of the certificate. Consider the intermediate nodes (i.e., ğ‘
andğ‘/prime) in two figures, the node length is updated from 03to04.
Thelengthoftherootnode ğ‘isfurtherupdatedfrom 0ato0b,as
shown by the node ğ‘/primein Figure 4c.
Algorithm2detailsthecertificatemutationprocess,whichtakes
a GCTTas input and outputs a updated GCT (i.e., T/prime) after muta-
tiononT.Ourobjectiveistofindaleafnodeasquicklyaspossible,
sothatwecanstartthemutation.Forthispurpose,weconducta
Breadth-First Search (BFS) from the root node on, and randomly
selectasub-tree Tğ‘ ğ‘¢ğ‘(Lines2to3).If Tğ‘ ğ‘¢ğ‘isaleafnodeasexpected,
wemutateitsvaluepart(Line5).Notethat,thechangeofdatavalue
(i.e.,Tğ‘ ğ‘¢ğ‘â†’ğ‘£toğ‘‰/prime) may also result in a change on the number
of bytes occupied by this value, which may further affect the num-
ber of bytes occupied by the length part of the node. Consider the
mutation example in Figure 4b and Figure 4c, we mutate the valueAlgorithm 2: Tree-based Mutation
Input :T: A GCT for mutation
Output:T/prime: A new GCT after mutation
1Function mutateAndRepair( T)
2ğ‘›:=ğ‘Ÿğ‘ğ‘›ğ‘‘ğ‘œğ‘š(10);
3Tğ‘ ğ‘¢ğ‘:=ğ‘Ÿğ‘ğ‘›ğ‘‘ğ‘œğ‘šğµğ¹ğ‘† (T,ğ‘›);
4ifğ‘–ğ‘ ğ¿ğ‘’ğ‘ğ‘“(Tğ‘ ğ‘¢ğ‘)then
5ğ‘‰/prime:=ğ‘šğ‘¢ğ‘¡ğ‘ğ‘¡ğ‘’(Tğ‘ ğ‘¢ğ‘â†’ğ‘£);
6ğ¿/prime:=ğ‘™ğ‘’ğ‘›(ğ‘‰/prime);
7ğ¿:=Tğ‘ ğ‘¢ğ‘â†’ğ‘™;
8 Î”1:=ğ¿/primeâˆ’Tğ‘ ğ‘¢ğ‘â†’ğ‘™;
9 Î”2:=ğ‘™ğ‘’ğ‘›(ğ¿/prime)âˆ’ğ‘™ğ‘’ğ‘›(ğ¿);
10 Tğ‘ ğ‘¢ğ‘â†’ğ‘£:=ğ‘‰/prime; âŠ²Update value
11 Tğ‘ ğ‘¢ğ‘â†’ğ‘™:=ğ¿/prime; âŠ²Repair length
12 returnTğ‘ ğ‘¢ğ‘,Î”1+Î”2;
13else
14 Î”1:=ğ‘šğ‘¢ğ‘¡ğ‘ğ‘¡ğ‘’ğ´ğ‘›ğ‘‘ğ‘…ğ‘’ğ‘ğ‘ğ‘–ğ‘Ÿ (Tğ‘ ğ‘¢ğ‘);
15 ğ¿:=Tâ†’ğ‘™;
16 Tâ†’ğ‘™:=Tâ†’ğ‘™+Î”1; âŠ²Repair length
17 Î”2:=ğ‘™ğ‘’ğ‘›(T â†’ğ‘™)âˆ’ğ‘™ğ‘’ğ‘›(ğ¿);
18 returnT,Î”1+Î”2
19T/prime,_:=ğ‘šğ‘¢ğ‘¡ğ‘ğ‘¡ğ‘’ğ´ğ‘›ğ‘‘ğ‘…ğ‘’ğ‘ğ‘ğ‘–ğ‘Ÿ (T);
20returnT/prime
partofleafnode ğ‘from02to01,03,resultingalengthadditionby1.
Thecurrent1-bytelengthpartinnodesufficestostoretheupdated
length.However,ifthevalueof ğ‘ismutatedtoalongvalue(e.g.,
a 17-byte number), then the current allocated space for the node
lengthpartisnotenoughtorepresentsuchanumber,andneeds
onemorebyteforaccommodation.Therefore,weneedrecordthese
twolengthchanges(Lines6to9)andthenupdatethevaluepart
(i.e.,Tğ‘ ğ‘¢ğ‘â†’ğ‘£)andlengthpart(i.e., Tğ‘ ğ‘¢ğ‘â†’ğ‘™)inthecurrentnode
(Lines 10 to 11). The updated node and the total length change are
returned(Line12).Forthecasesthattheselected Tğ‘ ğ‘¢ğ‘isaninterme-
diate node, we need to recursively apply the random BFS strategy
on the GCT, until a leaf node is found (Line 14). Similarly, for each
recursion,weâ€œrepairâ€thelengthpartinthecurrentnodecausedby
its child node (Line 16) and calculate the changes in the number of
bytes the node length part takes, which is raised by the repair just
now (Line 17). Then the total change in byte count( Î”1+Î”2) and
thecurrentsub-tree(i.e., T)arereturnedtouppernode(Line18).
When backtracking to the root node, we get the updated GCT T/prime.
It should be noted that, the subsequent nodes next to the root of
treerepresenttheroottripletofeachcertificatefield.Thuswhen
applying BFS on the root node, we can identify the field name
according to the random number, which facilitates the further dis-
crepancy localization.
3.2.3 Global Coverage Guidance. Thebuilt-incoverageguidance
engine in AFL is not suitable for differential testing, because it
only maximizes the coverage of a single program during the input
generation, leaving more coverage information on other programs
unused, which may help to trigger discrepancies. In this work,
528%$ *%($'
(("&'%(!"'
## &



#)%
"'%&'"
(''
%'

Figure 5: The workflow of global coverage guidance.
we extend the guidance engine of AFL by using global coverage
information of all tested programs. Our objective is to generate the
inputsthatcancoverasmanydifferentialbehavioursaspossible
amongmultipleprograms.Intuitively,atestinputthatisinteresting
forsomeprograms,maybenotinterestingforotherprograms.The
â€œinterestingâ€inputherereferstoaninputthatcancovernewedges
orachieveanewhitcountforanalready-exercisededge.Therefore,
sharinginterestinginputscanimprovethediversityoftestcases,
whicharemorelikelytotriggerdiscrepanciesamongdifferenttools.
The motivation can be illustrated in the following example.
SupposeAandBare two programs used for differential testing.
ğ¼1andğ¼2standfortwoinputs.Wealsosupposethatonly Aisfuzzed
by AFL to generate test inputs, and the generated test inputs arefurtherusedfordifferentialtestingbetween AandB.Asaresult,
the input
ğ¼1covers the edges { ğ´1,ğ´2}o nAand the edges { ğµ1,ğµ2}
onB, respectively. The other input ğ¼2covers the edge { ğ´1}o nA
andtheedges{ ğµ2,ğµ3}onB,respectively.However,despitecovering
new edge on B(i.e., {ğµ3}),ğ¼2still cannot be selected for further
mutation under the built-in guidance engine of AFL, because only
the new coverage of Acan be captured by AFL. Such situation can
beaddressedwhenweusetheglobalcoverageofbothprograms.
Then, the input ğ¼2would be included for further mutation. It is
similar to the case that only Bis fuzzed to generate the test inputs.
Theglobalcoverageguidanceengineisimplementedbysharing
interestinginputsamongallprogramsinvolvedinthedifferential
testing.ThegeneralworkflowofglobalcoverageguidanceinSADTispresentedinFigure5.Whenamutationiscompleted,allSSL/TLS
tools are executed in parallel with respect to the mutated certifi-cate. These tools have been instrumented in advance to captureedge coverage and edge hit counts at runtime. Subsequently, theedge coverage of each program is obtained and then it is used to
guide the selection of the interesting input from different SSL/TLS
tools.Finally,thoseinterestinginputsaresharedamongdifferent
programsby maintainingthesame queuefortest cases.Different
SSL/TLS programs can be implemented differently and these differ-encescanbecapturedbytestinputs.Therefore,sharinginterestinginputscanimprovethediversityoftestcases,whicharemorelikely
to trigger discrepancies among different tools.
Algorithm 3 presents the details about the global coverage guid-
ance in SADT. Given an initial certificate corpus (i.e., ğ‘„), and a
series of instrumented SSL/TLS tools (i.e., ğ´), we aim to extend
the corpus with a lot of mutated certificates, which expand the
overall coverage whenrunning these tools in parallel.Specifically,
weinitializeacoveragesetofallSSL/TLStoolsfortest,a.k.a,the
globalcoveragecoverage(i.e., C)inLine1.Wealsorecordthelatest
time that the global coverage is no longer updated (Line 2). Next, aAlgorithm 3: Global Coverage Guidance
Input :ğ´=/angbracketleftğ›¼1,...,ğ›¼ ğ‘›/angbracketright: Instrumented SSL/TLS tools
ğ‘„: The certificate corpus
Output:ğ‘„: The extended certificate corpus
Const :ğ‘¡: A timeout threshold
1C:=âˆ…;
2ğ‘‡ğ‘™ğ‘ğ‘¡ğ‘’ğ‘ ğ‘¡:=ğ‘ğ‘¢ğ‘Ÿğ‘Ÿğ‘’ğ‘›ğ‘¡ğ‘‡ğ‘–ğ‘šğ‘’ ();
3repeat
4ğ·:=ğ‘Ÿğ‘ğ‘›ğ‘‘ğ‘œğ‘šğ‘†ğ‘’ğ‘™ğ‘’ğ‘ğ‘¡ (ğ‘„);
5ğ·/prime:=ğ‘šğ‘¢ğ‘¡ğ‘ğ‘¡ğ‘’(ğ·);
6forğ›¼âˆˆğ´do
7ğ‘=ğ‘’ğ‘¥ğ‘’ğ‘ğ‘¢ğ‘¡ğ‘’(ğ›¼,ğ·/prime); âŠ²Single coverage
8 C:=C/uniontext.1{ğ‘}; âŠ²Global coverage
9ğ‘‡ğ‘ğ‘¢ğ‘Ÿ:=ğ‘ğ‘¢ğ‘Ÿğ‘Ÿğ‘’ğ‘›ğ‘¡ğ‘‡ğ‘–ğ‘šğ‘’ ();
10ifğ‘›ğ‘’ğ‘¤ğ¶ğ‘œğ‘£(C)then
11ğ‘„:=ğ‘„/uniontext.1{ğ·/prime}; âŠ²Add interesting cert
12ğ‘‡ğ‘™ğ‘ğ‘¡ğ‘’ğ‘ ğ‘¡:=ğ‘‡ğ‘ğ‘¢ğ‘Ÿ;
13ğ‘‡:=ğ‘‡ğ‘ğ‘¢ğ‘Ÿâˆ’ğ‘‡ğ‘™ğ‘ğ‘¡ğ‘’ğ‘ ğ‘¡;
14untilğ‘‡>ğ‘¡;
15returnğ‘„;
new certificate ğ·/primeis generated by mutation on a seed certificate
ğ·,whichisrandomlyselectedfromthecorpus(Lines4to5).We
runğ·/primesimultaneously on all tools and capture the global coverage
bymergingthecoverageundereachtool(Lines6to8).Acritical
checking is thenperformed on ğ·/primeto seewhether it produces new
coverageonatleastoneofthetools(Line10).Ifyes,weconsider
ğ·/primeas an interesting input , and add it into the corpus (Line 11).
Meanwhile,weupdatethetimewhenthenewcoveragewaslast
generated (Line 12). We repeatedly conduct above procedures until
the global coverage isno longerupdatedwithin agiven periodof
time (Line 14). Finally, we obtain an extended corpus, with a lot of
interesting certificates added.
3.3 Cross Validation
Differential testing [ 31] is a popular software testing technique
that aims to detect semantic bugs, by providing the same input
toaseriesofsimilarapplicationsordifferentimplementationsof
the same application, and observing discrepant behaviours in their
executions. Any discrepancy in outputs of targeted applications
indicatesapotentialbugbecausethespecificationsoftheseapplica-
tions are theoretically identical. We propose a novel syntax-aware
differentialtestingframeworkbasedonthecertificategeneration
described in Section 3.2. In order to facilitate statistics and analysis
ofdiscrepancy,wedefinean(m+1)-dimensionalvalidationvector
âˆ’ âˆ’ â†’ğ‘ğ‘’ğ‘Ÿğ‘¡for each tested certificate:
âˆ’ âˆ’ â†’ğ‘ğ‘’ğ‘Ÿğ‘¡=<ğ¶ğ‘,ğ‘Ÿğ‘’ğ‘ ğ‘¢ğ‘™ğ‘¡1,ğ‘Ÿğ‘’ğ‘ ğ‘¢ğ‘™ğ‘¡2,...,ğ‘Ÿğ‘’ğ‘ ğ‘¢ğ‘™ğ‘¡ ğ‘š>,
whereğ‘šis the number of tested implementations, ğ¶ğ‘is the cer-
tificatename,andthe ğ‘Ÿğ‘’ğ‘ ğ‘¢ğ‘™ğ‘¡ ğ‘–(1â‰¤ğ‘–â‰¤ğ‘š)indicatesthevalidation
result returned by the ğ‘–ğ‘¡â„implementation. ğ‘Ÿğ‘’ğ‘ ğ‘¢ğ‘™ğ‘¡ ğ‘–is 0 if the certifi-
cate is accepted. Otherwise, it is the returned code of the rejection.
These vectors are used as metrics in the following ways.
529(1) Ifğ‘Ÿğ‘’ğ‘ ğ‘¢ğ‘™ğ‘¡ ğ‘–=0 andğ‘Ÿğ‘’ğ‘ ğ‘¢ğ‘™ğ‘¡ ğ‘—â‰ 0(1â‰¤ğ‘–,ğ‘—â‰¤ğ‘šâˆ§ğ‘–â‰ ğ‘—), the
vector is considered as a discrepancy.
(2) For a vector <ğ‘Ÿğ‘’ğ‘ ğ‘¢ğ‘™ğ‘¡1,...,ğ‘Ÿğ‘’ğ‘ ğ‘¢ğ‘™ğ‘¡ ğ‘š>ğ‘¥, if it is not equivalent
to any<ğ‘Ÿğ‘’ğ‘ ğ‘¢ğ‘™ğ‘¡1,...,ğ‘Ÿğ‘’ğ‘ ğ‘¢ğ‘™ğ‘¡ ğ‘š>ğ‘¦amongğ‘˜discrepancies found (1â‰¤
ğ‘¥,ğ‘¦â‰¤ğ‘˜âˆ§ğ‘¥â‰ ğ‘¦), the vector is considered as a unique discrepancy.
Furthermore, in orderto measure the diversityof certificates in
aCert Corpus, we define the metric [12]:
ğ·ğ‘–ğ‘£ğ‘’ğ‘Ÿğ‘ ğ‘–ğ‘¡ğ‘¦ =|ğ‘ˆğ·ğ¶ğ‘’ğ‘Ÿğ‘¡|
|ğ¶ğ‘’ğ‘Ÿğ‘¡|Ã—100%,
where|ğ‘ˆğ·ğ¶ğ‘’ğ‘Ÿğ‘¡|indicates the number of unique discrepancies trig-
gered by Cert Corpus and the|ğ¶ğ‘’ğ‘Ÿğ‘¡|indicates the number of cer-
tificates in Cert Corpus. It is clear that, given certain number of
certificates,whentherearemoreuniquediscrepancies,thecertifi-
cates in the Cert Corpus are more diverse.
In addition, it is non-trivial to localize the root cause of each
unique discrepancy due to the large number of reported discrep-
ancies and targeted implementations. To mitigate this problem,
SADTstoreseachmutatedcertificatealongwithitsoriginalseed
certificate and recordsthe mutated field namefor each certificate,
as described in Section 3.2.2. Then the root cause of a detected dis-
crepancycanbeimmediatelypinpointedbycomparingthecontent
of mutated field in thediscrepancy-revealing certificate with the
seed certificate it originates from.
4 EVALUATION
We implement SADT based on the state-of-the-art tool AFL [ 37]
using C and Python. To evaluate the effectiveness of SADT and
understand theroot causeof thediscrepancies andbugs, weaim to
answer the research questions as mentioned in Section 1.
4.1 Experimental Setup
ToevaluateSADT,thefollowing6popularSSL/TLSimplementa-
tions are selected: OpenSSL (v1.1.1d) [ 41], GnuTLS (v3.6.11) [ 1],
MbedTLS(v2.16.3)[ 3],NSS(v3.48)[ 36],WolfSSL(v4.2.0)[ 57]and
LibreSSL (v3.0.2) [38].
To capture discrepancies, we need to run different implemen-
tationswiththesamecertificateandcomparetheoutputs.Hence,
we modify these implementations such that the outputs are re-
turned,respectively.Specifically,ifthecertificateisaccepted,the
outputvalue0isreturned.Otherwise,wereturnthespecificcode
oftherejection.Werandomlydownload61realcertificatesfrom
theexistingwebsites,whichareusedastheinitialcertcorpusof
SADT.Notethat,allcertificatesinthecertcorpusdonotcauseany
discrepancies among these implementations.
Allexperimentsare conductedonahigh performanceworksta-
tion,equippedwitha64-bitUbuntu16.04LTSsystem,a32GBRAM,
and two 18-core 2.3GHz Intel Xeon E5-2699 CPUs.
4.2 RQ1: How effective is SADT in discovering
discrepancies?
To detect the discrepancies between the 6 popular SSL/TLS imple-
mentations, we apply SADT to continuously generate test cases
until there is no interesting testcase generated within 30 minutes.
Finally,SADTranfor3hoursandgenerated2305interestingcertifi-cates(inCertCorpus ).Thenwecomparetheresultsfrom6differentTable1:Numberofuniquediscrepancybetweeneachpairof
SSL/TLS implementations
OpenSSL GnuTLS MbedTLS NSSWolfSSL LibreSSL
OpenSSL - 5 378 1
GnuTLS - - 469 6
MbedTLS - - -55 4
NSS - - --11 8
WolfSSL - - --- 9
LibreSSL - - --- -
implementations.Wesayacertificatecouldtriggerthediscrepan-
ciesifthereareatleasttwoimplementationsreturnthedifferent
results. Finally, 64unique discrepanciesare generated andthe Di-
versityis2.78%.TheresultsshowthatSADTcouldgeneratediverse
certificates that are more likely to trigger unique discrepancies.
Thetotalnumberofuniquediscrepanciesdependsonthenumber
oftestedimplementations.Intuitively,themoreimplementations
tested,themoreuniquediscrepancies.Then,wefurthershowthe
uniquediscrepancies foreach pairimplementations. Forexample,
supposetwooutputvectors <0,1,3,3,3,3 >and<0,1,3,2,1,3 >are
returned from two inputs, which are regarded as the same discrep-
ancyforthe( ğ‘ƒ1,ğ‘ƒ2)pair.Itisbecausetheoutputdifferenceisthe
same, i.e., (0, 1). Table 1 shows the number of unique discrepancies
ineachpairofimplementations.Overall,thereareanaverageof
6.06 unique discrepancies between each pair of SSL/TLS implemen-
tations.Specifically,wecanobservethatSADTdetectedthemost
unique discrepancies between NSS and WolfSSL (i.e., 11). More-over, SADT detected one unique discrepancy between OpenSSL
and LibreSSLalthough theyfork thesamecode base.Such results
demonstrate that SADT can effectively detect unique discrepancies
between any two SSL/TLS implementations.
Wefurtherinvestigatetherootcauseofeachdiscrepancybycom-
paring the content of fields, by mutating which (during fuzzing)the discrepancy is generated. Thus, based on checking the mu-
tated field, the 64 unique discrepancies are classified into different
categories that show the root causes. Table 2 lists the results of
classification. The first column shows different fields, where SPKI,
AKI, EKU, and AIA indicates the Subject Public Key Info, Authority
KeyIdentifier, ExtendedKeyUsage andAuthorityInformationAccess,
respectively.TheresultsshowthatSADTcoulddetectmorediversediscrepanciesbetweenthe6SSL/TLSimplementations.Specifically,thedetecteddiscrepanciesarefrom11fieldsincludingsomecritical
fields (e.g., Validity, Key Usage, AKI, et al.). In addition, most of the
discrepancies are caused by the Extensions.
WehavereportthedetectedbugsfoundbySADTtothedevel-
opers.To date,13bugshavebeenfixed orconfirmedasdescribed
below. More detailed case studies are shown in Section 4.5
â€¢OpenSSLhasconfirmed2bugs: (1)OpenSSLacceptsa Version1
certificatewith Extension [39].(2)OpenSSLacceptscertificates
including two instance of a particular extension [40].
â€¢GnuTLS has confirmed and fixed 5 bugs: (1) GnuTLS accepts a
certificate whose notbefore field is a non-digits string [ 18]. (2)
GnuTLScannotcheck ObjectIdentifier correctly[ 21].(3)GnuTLS
acceptscertificatesincludingtwoinstanceofa particularexten-
sion [19]. (4) GnuTLS can not check Issuercorrectly [ 20]. (5)
GnuTLS accepts notbefore with length 11 [22].
530Table 2: The distribution of unique discrepancies found by SADT in terms of infected fields
Field Name Version SerialNumber Subject IssuerValidity Signature SPKIExtensionsTotalKeyUsage AKIEKUAIA
Number 5 4 66 9 311 586164
â€¢MbedTLShasconfirmed1bug: MbedTLSacceptsinvalidcertifi-
cateswhose keyidentifier oftheAuthorityKeyIdentifier isnot
the same as Subject Key Identifier of issuer certificate [30].
â€¢NSShas confirmed2bugs: (1)NSS acceptsa Version1certificate
withExtension [34].(2)NSSaccepts notbefore withlength11[ 35].
â€¢WolfSSLhasfixed3bugs: (1)WolfSSLacceptsacertificatewith
AuthorityKeyIdentifier thatdoesnotmatchissuercertificate[ 55].
(2)WolfSSLacceptsacertificatewithaninvalidtimeformat[ 54].
(3)WolfSSLacceptsacertificatewhose Issuerdoesnotmatchthe
Subjectof issuer certificate [56].
Answer to RQ1: SADT is effective in finding unique discrepan-
cies.Specifically,SADTfinds64uniquediscrepancies(including
13confirmedbugs)across6SSL/TLSimplementationsandfinds
average6.06uniquediscrepanciesbetweeneachpairofimplemen-
tations.Moreover,thediscrepanciesarediverseandcouldcover
most of fields in the certificate.
4.3 RQ2: How does SADT perform compared to
state-of-the-art differential testing
frameworks?
We select two state-of-the-art techniques as the baselines, i.e., RFC-
cert [8] and NEZHA [ 42], which have been shown effective in
detecting discrepancies between SSL/TLS implementations. We do
not select Mucert [ 12] and Frankencert [ 6] due to that RFCcert [ 8]
has been demonstrated to be the more effective one than them.
SincethesourcecodeofRFCcertisnotapplicable,were-implement
it according to the algorithm described in [8].
Note that, unlike SADT and NEZHA, RFCcert is a rule-based
framework,whichonlygeneratescertificateswiththeexistingrules
extractedfromRFCs.Tomakeafaircomparison,SADTisrestricted
to only mutate the certificate fields involved in the rules used byRFCcert. The same Cert Corpus are also provided for SADT and
NEZHA.Furthermore,NEZHAhastwokindsofguidance:gray-box
guidanceand black-boxguidance. SinceSADTis gray-boxframe-
workguidedbyglobalcoverageguidance,thegray-boxguidanceof
NEZHAisusedinallcomparison.Inourexperiment,11rulesare
extractedfromRFC5280[ 14]andtheserulesinvolve10common
fields of X.509 certificate.Werun each frameworks five times and
calculatetheaverageresultsforcomparison.Theperformanceof
SADT, NEZHA and RFCcert are compared in terms of the number
of unique discrepancies and the diversity of certificates.
4.3.1 The number of unique discrepancies. Figure 6a shows the av-
eragenumberofuniquediscrepanciesdiscoveredbySADT,NEZHAandRFCcertunderdifferentiterations.WecouldobservethatSADT
finds moreunique discrepanciesthan NEZHAand RFCcertunder
the same iterations. For example, SADT finds about 1.4 timesand4
timesunique discrepancies than NEZHA and RFCcert respectively(a) The number of unique discrep-
anciesfoundbySADT,NEZHAand
RFCcert under different iterations(b) The distribution of unique dis-
crepanciesfoundbySADT,NEZHA
andRFCcertunder100,000iterations
Figure 6: The performances of SADT, NEZHA and RFCcert
under100,000iterations.Furthermore,thenumberofuniquedis-
crepancies found by SADT keeps increasing in different iterations
while NEZHA and RFCcert stop detecting new discrepancies after
60,000 iterations. The results demonstrate that SADT outperforms
NEZHA and RFCcert in finding unique discrepancies. The mainreason is that NEZHA mutates the inputs without knowing the
structureinformationoftheinput.RFCcertconsidersthesyntaxin-
formation and ensures the syntactical correctness of the generated
certificates,butitlacksthecoveragefeedback.Differently,SADT
considers both of the two perspectives, i.e., generating interest-
ingtestcasesbasedonthesyntacticalstructureandthecoverage
guidance, making SADT more effective.
Figure 6b shows the distribution of the unique discrepancies
foundbyeachtoolunder100,000iterations.AsseeninFigure6b,
thenumber ofunique discrepanciesfound bySADT, NEZHAand
RFCcert are 41, 31 and 15, respectively. The results show that these
toolscouldgeneratedifferentdiscrepancies.Forexamples,25,20
and6uniquediscrepancies areonlyfoundbySADT,NEZHAand
RFCcert, respectively, i.e., the discrepancies cannot be found by
other two tools. This is due to differences in their respective meth-
odswithregardstothecertificategeneration.NEZHArandomly
mutates certificates at the granularity of the entire certificate, thus
many test cases generated by NEZHA violate the syntax of thecertificate. In other words, NEZHA may find more discrepancies
at the syntax parsing stage. For example, in our experiment, 97522
certificates(97.52%)generatedbyNEZHAaresyntacticallyincor-
rect after 100,000 mutations. However, certificates generated byRFCcert have correct syntax but are not diverse enough, i.e., all
ofthegeneratedcertificatesviolateRFCspecifications.However,
the tree-based mutation and global coverage guidance make SADT
address the above two problems, making SADT more effective.
In addition, NEZHA and RFCcert miss 73.17% and 78.05% of the
discrepancies found by SADT, respectively. We also found that
some of discrepancies detected by RFCcert and NEZHA are missed
by SADT. This is because the current mutation strategies of SADT
mightbeincomplete.Inordertoensurethatthegeneratedcertifi-
cate have the valid syntax, SADT focuses on changing the value of
531Table 3: The discrepancy diversity of SADT, NEZHA, and
RFCcert under different mutation iterations.
IterationsSADT NEZHA RFCcert
60,00080,000100,000 60,000 60,000
Uniq. 3536 41 31 15
Certificates 10191125 1172 6638 60,000
Diversity(%) 3.433.20 3.50 0.47 0.03
the certificate field but does not change the structure of the certifi-
cate,suchasaddingordeletingcertificatefields.Despitethefact
that the mutation operators of SADT may be limited, SADT still
detectsmorebugsthanNEZHAandRFCcertduetothecombina-
tionofsyntax-guidedandcoverage-guidedmutation.Weplanto
extend more mutation operators on SADT in the future.
4.3.2 The diversity of certificates. AsshowninFigure6a,nonew
unique discrepancies are discovered by NEZHA and RFCcert af-
ter60,000iterations,whilenewuniquediscrepanciescontinueto
befoundbySADT.Hence,the Diversity ofcertificatesgenerated
byNEZHAandRFCcertdecreasesasiterationsincreases.Table3
shows that the Diversity of certificates generated by each frame-
work and Row Uniq.indicates the number of unique discrepancies.
AsshowninTable3,after60,000iterations,1019,6638and60,000
certificatesaregeneratedbySADT,NEZHA,andRFCcert,respec-
tively, and each of them find 35, 31, and 15 unique discrepancies,
respectively. Therefore, the diversity of certificates generated bySADT, NEZHA and RFCcert are 3.43% (35/1019), 0.47% (31/6638)
and0.03%(15/60000),respectively.Itisobviousthatthediversity
of certificates generated by SADT is much greater than that of
NEZHAandRFCcert.Notethat,thediversityofSADTunder80,000
and 100,000 iterations are also close to that under 60,000 iterations
andtheyarestillmuchgreaterthanthatofNEZHAandRFCcert
under 60,000 iterations. These results demonstrate the certificates
generated by SADT are more diverse than NEZHA and RFCcert.
Answerto RQ2: Compared with state-of-the-art differential test-
ing techniques, SADT is more effective to generate diverse certifi-
cates that could detect more unique discrepancies.
4.4 RQ3: How does SADT perform compared to
the state-of-the-art fuzzing technique (i.e.,
AFL)?
SADT is implemented by extending the built-in mutation and guid-
ance engine of AFL. Therefore, we compare the performance ofSADT with the general-purpose AFL in terms of the number of
uniquediscrepanciestofurtherillustratetheeffectivenessofour
approach.SinceAFLdoesnotsupportdifferentialtesting,weadapt
AFLfordifferentialtestingasfollows:usingAFLtogeneratecertifi-
catesbasedonasingleSSL/TLSimplementation(i.e.,OpenSSL)and
then invoking the validation routines from 6 different implementa-
tionswiththesegeneratedcertificates.Moreover,toevaluatethe
contribution of components in SADT (i.e., the tree-based mutation
and theglobal coverageguidance), weconduct anothervariant of
SADT, named S-SADT, which performs the tree-based mutationFigure 7: The number of unique discrepancies found bySADT, S-SADT and AFL under different iterations
butthedefaultcoverageguidanceofAFL.Thenwefeedthesame
initialCert Corpus (61 certificates) to SADT, S-SADT and AFL, and
obtain theresults. Toreduce the randomness,each tool isrun five
times and the average results are compared.
The number of unique discrepancies discovered by SADT, S-
SADT and AFL under different iterations are presented in Figure 7.
It can beobserved that AFL only finds 2unique discrepancies and
the number of unique discrepancies remains the same as iterations
increase.Whereas,SADTandS-SADTfindmoreuniquediscrep-
anciesthanAFLundersameiterationsandthenumberofunique
discrepancieskeepsincreasingduringtheiterations.Thenumber
of unique discrepancies discovered by SADT is about 20 timesthan
that of AFL under 100,000 iterations. Consider the results between
S-SADTandAFL,wefoundthatS-SADTfinds 9timesmoreunique
discrepancies than AFL under 100,000 iterations, which demon-
stratesthatthetree-basedmutationiseffectiveindetectingdiscrep-
ancies. Consider the results between SADT and S-SADT, we found
thatSADTcoulddetectmuchmorediscrepancies(e.g.,morethan2times)thanS-SADTunderthesameiterations,whichdemonstrates
the effectiveness of the global coverage guidance in improving the
performanceofSADT.Ingeneral,SADTimprovesthecapabilityof
AFL to find bugs in SSL/TLS implementations.
Answer to RQ3: SADT finds about 2 timesmore unique discrep-
anciesthanS-SADT.S-SADTfinds 9timesmoreuniquediscrepan-
ciesthan AFLunder100,000 iterations.Itis clearlythatSADT and
S-SADT outperform AFL in finding unique discrepancies. The re-
sults demonstrate that both of tree-based mutation and the global
coverage guidance are effective in detecting unique discrepancies.
4.5 Case Studies of Bugs
To understand the root cause of the bugs reported by SADT, we
manually analyze the detailed implementation and summarize the
root causes of these bugs into two categories: (1) Lack of checking
ofcornercase.TheSSL/TLSimplementationdevelopersmayignoresomecasesthatmaynotbeclearlystatedintheRFCs.Forexample,
GnuTLS lacks some checks on whether the Validityvalue is digital
stringasshowninListing1.(2)IncorrectimplementationofrulesinRFCs.Thedeveloperâ€™swrongunderstandingofrulesmayleadtothe
rules not being implemented correctly. The code for finding issuer
on WolfSSL was implemented incorrectly as shown in Listing 2,
5321statictime_t utcTime2gtime(const char âˆ—ttime){
2charxx[3];
3 intyear;
4 if( strlen (ttime)<10){
5 gnutls_assert () ;
6 return(time_t)âˆ’1;
7 }
8xx[2]=0;
9memcpy(xx,ttime,2);
10 /âˆ— year is 0 if xx is non âˆ’digits âˆ—/
11 year=atoi(xx);
12 ttime +=2;
13 if(year>49)
14 year+=1900;
15 else
16 year+=2000;
17 returntime2gtime(ttime,year);
18}
Listing 1: GnuTLS cannot parse validity field correctly
whichisatypicalexample.Inthissection,werespectivelyintroduce
the two typical bug cases in detail.
4.5.1 GnuTLS-Incorrect validation of validity. TheValidity(includ-
ingnotBefore andnotAfter)oftheX.509certificatehastworepre-
sentations: UTCTime(YYMMDDHHMMSSZ)andGeneralizedTime
(YYYYMMDDHHMMSSZ),whichcontain13and15characters,re-
spectively. It is obvious that the value of notBefore andnotAfter
cannot be a non-digital string. However, we find that GnuTLS erro-
neouslyacceptsamalformedcertificatewhose notBefore ornotAfter
contain non-digital characters while other SSL/TLS implementa-
tions reject it. After manually debugging the implementation from
thediscrepancy,wefoundthatGnuTLSlacksthecheckonwhethertheValidityvalueisdigitalstringasshowninListing1.Forexample,
while other implementations reject a certificate whose notBefore
field is UTCTime #01010101000Z since it is a incorrect time for-
mat. However, GnuTLS incorrectly interprets the time as Otc 10
10:10:001900GMT .Thisisbecausethefunction ğ‘ğ‘¡ğ‘œğ‘–(ğ‘¥ğ‘¥)returns
0 whenğ‘¥ğ‘¥is non-digits (Line 11 in Listing 1). We have reported
thisbugtothecorrespondingdevelopersandcommittedaMerge
Request to fix it. The GnuTLS team has confirmed this bug and has
fixed it in GnuTLS v3.6.12 [18].
There are no such rules like â€œvalidity MUST be digital stringâ€ in
RFCs, which makes RFCcert unable to generate such certificates.
ThereforethisbugcannotbediscoveredbyRFCcert.Theresultalso
demonstrates that SADT could be a supplement to RFCcert.
4.5.2 WolfSSL-Incorrect validation of issuer. Asdescribedinsection
4.2.1.2 of RFC5280, the Subject KeyIdentifier of a CA certificate
MUSTmatchthe Authority Key Identifier ofcertificatesissued
bytheCA.However,ourexperimentsshowthatWolfSSLacceptsa
certificatethatviolatesthisrulewhileotherSSL/TLSimplementa-
tions rejectsuch certificatebecause theycould not findthe issuer.
Through debugging, we find that the code for finding issuers in
WolfSSL are not implemented correctly. As shown in Listing 2,
WolfSSLwilllookuptheissuercertificatebymatchingthevalueof
Issuerwhenitcouldnotfindthecorrespondingissuercertificateby
matching AuthorityKeyIdentifier (Lines7to12inListing2).Inthis
case, WolfSSL will accept the certificate if the Issuermatches the1intParseCertRelative (DecodedCertâˆ— cert, inttype,intverify ,void
âˆ— cm){
2 ...
3if(verify != NO_VERIFY && type != CA_TYPE && type !=
TRUSTED_PEER_TYPE) {
4 certâˆ’>ca = NULL;
5#ifndef NO_SKID
6 /âˆ—CA certificate is found if one field matches the certâˆ—/
7if (cert->extAuthKeyIdSet)
8 cert->ca = GetCA(cm, cert->extAuthKeyId);
9if (cert->ca == NULL && cert->extSubjKeyIdSet)
10 cert->ca = GetCA(cm, cert->extSubjKeyId);
11 if (cert->ca == NULL)
12 cert->ca = GetCAByName(cm, cert->issuerHash);
13 ...
14}
Listing 2: WolfSSL cannot find issuer correctly
Subjectoftheissuercertificate.WolfSSLhasconfirmedandfixed
this bug [55], and MbedTLS has also confirmed it [30].
4.6 Threats to Validity
The selected versions of SSL/TLS implementations in our study
couldbeathreattovalidity.Thisworkmainlyfocusesonthedif-
ferentSSL/TLSimplementations.Thethreatcouldbereducedby
selectingmore differentversions ofthe SSL/TLSimplementations.
Theinitialcertcorpusmaybeathreat.Wemitigatethisissueby
randomlyselectingdiversecertificationsfromtheexistingwebsites.
Another threat would be the randomness when comparing discrep-
ancies detection between SADT and the baselines. To mitigate this
issue,weruneachtoolfivetimesandcalculatetheaverageresults.
5 RELATED WORK
We summarize the related work in following two aspects: the secu-
rity of SSL/TLS implementations and the mutation-based testing.
5.1 Security of SSL/TLS implementations
Recently,manyresearcheshavebeenproposedtoevaluatethesecu-rityofSSL/TLSimplementations.Marlinspike[
29,33]foundseveral
vulnerabilitiesinthecertificatevalidationprocessofSSL/TLSim-
plementations.Kaminskyetal.[ 23]demonstratedtwonewtypesof
collisionattacksagainsttheX.509certificate.Georgievetal.[ 17]an-
alyzedseveralvulnerabilitiesthatarecausedbybadlydesignedAPIs
ofSSLimplementations(i.e.,OpenSSL).Theirresultsrevealedthe
security risks in SSL/TLS implementations. These results motivate
ustodetectbugsofcertificatevalidationinSSL/TLSimplementa-
tions through automated methods.
Frankencert[ 6]isproposedforthefirsttimetotestcertificateval-
idationlogic inSSL/TLSimplementations. Chenetal. [12]further
appliedaguidedtechniquetoimproveFrankencert(i.e.,Mucert).
Different from our work, Frankencert is unguided and Mucertguides certificate generation based on a single implementation
instead of multiple targeted implementations. DRLgencert [ 7] first
applied deep reinforcement learning to the automated testing of
SSL/TLS implementations. It needs to extract features from a large
number of certificates, which is not required in our work. TLS-
Attacker [ 50] evaluated the security of TLS libraries by two-step
fuzzingapproach.Sivakornetal.presentedHVLearn[ 49]tofind
533bugs in hostname verification. They are orthogonal to our work as
they mainly focus on protocol level or hostname verification while
SADT focuses on certificate validation process.
The most relevant work to SADT are NEZHA [ 42] and RFC-
cert[8].Ourworkdistinguishesfromtheminthefollowingaspects:
1) RFCcert assembles certificates depending on the rules extracted
from RFCs while we generate certificates in a rule-independent
way,guidedbytheglobalcoverageofallSSL/TLSimplementations;
2) NEZHA directly mutates the certificate files regardless of the
certificate syntax, while SADT leverages a tree-based mutation to
generatesyntacticallycorrectcertificates;and3)weproposeamore
fine-grained bug localization than NEZHA.
5.2 Mutation-based Testing
In the recent years, there are many mutation-based techniques
proposed for software testing, e.g., AFL [ 37], libFuzzer [ 28], Fair-
Fuzz [25], Steelix [ 26], Cerebro [ 27], Hawkeye [ 10], MUZZ [ 9], and
UAFL[51],whichmutatetestcaseswiththeguidanceofcustomized
domain-specific code coverage. Their guidance is ill-suitable for
differentialtestingbecauseitguidesmutationbasedonasingleim-
plementationinsteadofmultiple implementations.SlowFuzz[ 43]
and PerfFuzz [24] generate test cases based on the resource usage.
Vuzzer [48] and Angora [ 11] use taint analysis to identify which
bytesshouldbemutated.Theymutatetestcaseregardlessofthe
syntax of test case while SADT leverages a tree-based mutation to
ensuremutatedtestcaseissyntacticallycorrect.However,therearesometechniquesareproposedtogeneratesyntacticallycorrecttest
case.ğœ‡4SQLi [2] generates executableSQLs by applying mutation
operatorsonvalidSQLs.Superion[ 53]leveragesgrammar-aware
trimming strategy and two grammar-aware mutation strategies to
ensurethemutatedtestcaseissyntacticallycorrect.Domato[ 15]
generatestest casesby specifyingthe syntaxof HTML/CSSstruc-
ture and JavaScript objects. Skyfire [ 52] generates well-distributed
testcasesbyleveragingtheknowledgeofmanyexistingsamples.It
should be noted that, above techniques are orthogonal to our work
as they mainly focus on generating highly-structured inputs (such
as JavaScript) instead of X.509 certificate.
6 CONCLUSION
Inthispaper,wedesign,implementandevaluateasyntax-aware
differential testing framework, i.e. SADT, for testing certificate val-
idation in SSL/TLS implementations. Specifically, the tree-basedmutationandtheglobalcoverageguidanceareextendedonAFL
to effectively mutate and diversify X.509 certificates while keeping
thecertificatesyntacticallycorrect.Thesegeneratedcertificatesare
leveraged to identify the discrepancies between different SSL/TLS
implementations.OurexperimentalresultsdemonstratethatSADTis more effective thanthe state-of-the-artdifferential testingframe-
works (i.e., NEZHA and RFCcert) in detecting discrepancies and
thegeneral-purposefuzzingtechniqueAFL.Overall,SADTfinds
64 unique certificate validation discrepancies on 6 widely usedSSL/TLS implementations. In particular, 13 bugs have been con-
firmed or fixed by the developers.ACKNOWLEDGMENTS
We thank the anonymous reviewers for their comprehensive feed-
back.ThisworkwaspartlysupportedbytheNationalScienceFoun-
dation of China (No. 61872262, 61572349). It was also sponsored bythe Singapore Ministry of Education Academic Research Fund Tier
1 (Award No. 2018-T1-002-069), the National Research Foundation,
Prime Ministers Office, Singapore under its National Cybersecurity
R&D Program (Award No. NRF2018NCR-NCR005-0001), the Sin-
gaporeNationalResearchFoundationunderNCRAwardNumber
NSOE003-0001 and NRF Investigatorship NRFI06-2020-0022.
REFERENCES
[1]TimRÃ¼hsen,Daiki Ueno,DmitryBaryshkov. 2020. TheGnuTLS TransportLayer
Security Library. https://www.gnutls.org
[2]Dennis Appelt,Cu Duy Nguyen,Lionel C. Briand,and Nadia Alshahwan.2014.
Automated Testing for SQL Injection Vulnerabilities: An Input Mutation Ap-
proach.In Proceedingsofthe2014InternationalSymposiumonSoftwareTesting
andAnalysis (SanJose,CA,USA) (ISSTA2014).AssociationforComputingMa-
chinery, New York, NY, USA, 259â€“269. https://doi.org/10.1145/2610384.2610403
[3] ARM Limited. 2020. armMBED. https://tls.mbed.org
[4]Richard Barnes, Martin Thomson, Alfredo Pironti, and Adam Langley. 2015.
Deprecating Secure Sockets Layer Version 3.0. RFC 7568. https://doi.org/10.
17487/RFC7568
[5]Mark Brown and Russ Housley. 2010. Transport Layer Security (TLS) Authoriza-
tion Extensions. RFC 5878. https://doi.org/10.17487/RFC5878
[6]Chad Brubaker, Suman Jana, Baishakhi Ray, Sarfraz Khurshid, and Vitaly
Shmatikov. 2014. Using frankencerts for automated adversarial testing of certifi-
cate validation in SSL/TLS implementations. In 2014 IEEE Symposium on Security
and Privacy. IEEE, 114â€“129.
[7]ChaoChen, WenruiDiao,YingpeiZeng, ShanqingGuo,and ChengyuHu.2018.
DRLGENCERT: Deep Learning-based Automated Testing of Certificate Verifi-cation in SSL/TLS Implementations. In 2018 IEEE International Conference on
Software Maintenance and Evolution (ICSME). IEEE, 48â€“58.
[8]Chu Chen, Cong Tian, Zhenhua Duan, and Liang Zhao. 2018. RFC-directed
differential testing of certificate validation in SSL/TLS implementations. In 2018
IEEE/ACM 40th International Conference on Software Engineering (ICSE). IEEE,
859â€“870.
[9]Hongxu Chen, Shengjian Guo, Yinxing Xue, Yulei Sui, Cen Zhang, Yuekang
Li,HaijunWang,andYangLiu.2020. MUZZ:Thread-awareGrey-boxFuzzing
forEffectiveBugHuntinginMultithreadedPrograms.In 29thUSENIXSecurity
Symposium(USENIXSecurity20).USENIXAssociation,2325â€“2342. https://www.
usenix.org/conference/usenixsecurity20/presentation/chen-hongxu
[10]HongxuChen,YinxingXue,YuekangLi,BihuanChen,XiaofeiXie,XiuhengWu,
and Yang Liu. 2018. Hawkeye: Towards a desired directed grey-box fuzzer. In
Proceedingsofthe2018ACMSIGSACConferenceonComputerandCommunications
Security. 2095â€“2108.
[11]P.ChenandH.Chen.2018. Angora:EfficientFuzzingbyPrincipledSearch.In
2018 IEEE Symposium on Security and Privacy (SP). 711â€“725.
[12]Yuting Chen and Zhendong Su. 2015. Guided differential testing of certificate
validation in SSL/TLS implementations. In Proceedings of the 2015 10th Joint
Meeting on Foundations of Software Engineering. ACM, 793â€“804.
[13]SantoshChokhani,WarwickFord,RandySabett,CharlesMerrill,andStephen
Wu.1999. RFC2527:Internet X.509public keyinfrastructurecertificate policy
andcertificationpracticesframework. InternetEngineeringTaskForce(IETF),RFC
(1999).
[14]DavidCooper,StefanSantesson,SFarrell,SharonBoeyen,RusellHousley,and
W Polk. 2008. RFC 5280: Internet X. 509 public key infrastructure certificate and
certificate revocation list (CRL) profile. IETF, May (2008).
[15]Fratric. 2017. The great dom fuzz-off of 2017. https://googleprojectzero.blogspot.
sg/2017/09/the-great-dom-fuzz-off-of-2017.html.
[16]Alan Freier, Philip Karlton, and Paul Kocher. 2011. Rfc 6101: The secure sockets
layer(SSL)protocolversion3.0. TheInternetEngineeringTaskForce(IETF) (2011).
[17]MartinGeorgiev,SubodhIyengar,SumanJana,RishitaAnubhai,DanBoneh,and
VitalyShmatikov.2012. Themostdangerouscodeintheworld:validatingSSL
certificatesinnon-browsersoftware.In Proceedingsofthe2012ACMconference
on Computer and communications security. ACM, 38â€“49.
[18]gnutls.2019. Gnutlsacceptsacertificatewhosenotbeforefieldisanon-digitsstring
whileopensslrejectssuchcertificates. https://gitlab.com/gnutls/gnutls/-/issues/870
[19]gnutls. 2019. gnutls accepts certificates including two instance of a particular
extension. https://gitlab.com/gnutls/gnutls/-/issues/887
[20]gnutls.2019. gnutlscanâ€™tcheckcertificateissuercorrectlyaccordingtoRFC5280.
https://gitlab.com/gnutls/gnutls/-/issues/885
534[21]gnutls. 2019. gnutls canâ€™t check object identifier value correctly. https://gitlab.
com/gnutls/gnutls/-/issues/886
[22]gnutls. 2019. GnuTLS3.6.7.1 cannot process validity field according to RFC5280.
https://gitlab.com/gnutls/gnutls/-/issues/864
[23]DanKaminsky,MeredithLPatterson,andLenSassaman.2010. PKIlayercake:
New collision attacks against the global X. 509 infrastructure. In International
Conference on Financial Cryptography and Data Security. Springer, 289â€“303.
[24]Caroline Lemieux, Rohan Padhye, Koushik Sen, and Dawn Song. 2018. PerfFuzz:
AutomaticallyGeneratingPathologicalInputs.In Proceedingsofthe27thACM
SIGSOFT International Symposium on Software Testing and Analysis (Amsterdam,
Netherlands) (ISSTA2018).AssociationforComputingMachinery,NewYork,NY,
USA, 254â€“265. https://doi.org/10.1145/3213846.3213874
[25]Caroline Lemieux and Koushik Sen. 2018. FairFuzz: a targeted mutation strategy
forincreasinggreyboxfuzztestingcoverage.In Proceedingsofthe33rdACM/IEEE
International Conference on Automated Software Engineering - ASE 2018 .A C M
Press. https://doi.org/10.1145/3238147.3238176
[26]Yuekang Li, Bihuan Chen, Mahinthan Chandramohan, Shang-Wei Lin, Yang Liu,
andAlwenTiu.2017. Steelix:Program-StateBasedBinaryFuzzing.In Proceedings
of the 2017 11th Joint Meeting on Foundations of Software Engineering (Paderborn,
Germany) (ESEC/FSE 2017). Association for Computing Machinery, New York,
NY, USA, 627â€“637. https://doi.org/10.1145/3106237.3106295
[27]YuekangLi,YinxingXue,HongxuChen,XiuhengWu,CenZhang,XiaofeiXie,
Haijun Wang, and Yang Liu. 2019. Cerebro: context-aware adaptive fuzzing
for effective vulnerability detection. In Proceedings of the 2019 27th ACM Joint
Meeting on European Software Engineering Conference and Symposium on the
Foundations of Software Engineering. 533â€“544.
[28]LLVM. 2020. libFuzzer-a library for coverage-guided fuzz testing - LLVM 3.9
documentation. http://llvm.org/docs/LibFuzzer.html
[29]Moxie Marlinspike. 2009. More tricks for defeating SSL in practice. Black Hat
USA(2009).
[30]mbedtls.2019. mbedtls2.16.3acceptsinvalidcertificatewhosekeyidentifierfield
of the authority key identifier extension is not the same as subject key identifier in
issuer. https://github.com/ARMmbed/mbedtls/issues/2954
[31]William M McKeeman. 1998. Differential testing for software. Digital Technical
Journal10, 1 (1998), 100â€“107.
[32]Microsoft.2020. DistinguishedEncodingRules. https://docs.microsoft.com/en-
us/windows/win32/seccertenroll/distinguished-encoding-rules
[33]MarlingspikeMoixe.2009. Newtricksfordefeatingsslinpractice.In BlackHat
Conference, USA.
[34]mozilla. 2019. NSS accepts a version-1 certificate with extension fields. https:
//bugzilla.mozilla.org/show_bug.cgi?id=1603034
[35]mozilla. 2019. NSS UTCTime parser should reject short fields. https://bugzilla.
mozilla.org/show_bug.cgi?id=1599331
[36]Mozilla.2020. NetworkSecurityServices. https://developer.mozilla.org/en-US/
docs/Mozilla/Projects/NSS
[37] M.Zalewski. 2020. american fuzzy lop. http://lcamtuf.coredump.cx/afl/
[38] OpenBSD. 2020. LibreSSL. https://www.libressl.org/
[39]OpenSSL. 2019. openssl accepts a certificate with version 1 and extension fields.
https://github.com/openssl/openssl/issues/10599
[40]OpenSSL.2019. opensslacceptscertificatesincludingtwoinstanceofaparticular
extension. https://github.com/openssl/openssl/issues/10686[41] OpenSSL Software Foundation. 2020. OpenSSL. https://www.openssl.org
[42]Theofilos Petsios, Adrian Tang, Salvatore Stolfo, Angelos D Keromytis, and
SumanJana.2017. Nezha:Efficientdomain-independentdifferentialtesting.In
2017 IEEE Symposium on Security and Privacy (SP). IEEE, 615â€“632.
[43]Theofilos Petsios, Jason Zhao, Angelos D. Keromytis, and Suman Jana. 2017.
SlowFuzz:AutomatedDomain-IndependentDetectionofAlgorithmicComplexity
Vulnerabilities. In Proceedings of the 2017 ACM SIGSAC Conference on Computer
and Communications Security (Dallas, Texas, USA) (CCS â€™17). Association for
ComputingMachinery,NewYork,NY,USA,2155â€“2168. https://doi.org/10.1145/
3133956.3134073
[44]MarshRay,AlfredoPironti,AdamLangley,KarthikeyanBhargavan,andAntoineDelignat-Lavaud.2015.TransportLayerSecurity(TLS)sessionhashandextended
master secret extension. Transport (2015).
[45]EricRescorla.2000.HTTPOverTLS.RFC2818. https://doi.org/10.17487/RFC2818
[46]EricRescorlaandTimDierks.2008. TheTransportLayerSecurity(TLS)Protocol
Version 1.2. RFC 5246. https://doi.org/10.17487/RFC5246
[47]Peter Saint-Andre and Jeff Hodges. 2011. Representation and Verification ofDomain-Based Application Service Identity within Internet Public Key Infras-tructure Using X. 509 (PKIX) Certificates in the Context of Transport Layer
Security (TLS). RFC6125 (2011), 1â€“57.
[48]VivekJainSanjayRawat,LucianCojocarAshishKumar,andHerbertBosCris-
tiano Giuffrida. 2017. VUzzer: Application-aware Evolutionary Fuzzing. In NDSS
Symposium 2017.
[49]Suphannee Sivakorn, George Argyros, Kexin Pei, Angelos D Keromytis, andSuman Jana. 2017. HVLearn: Automated black-box analysis of hostname veri-
ficationinSSL/TLSimplementations.In 2017IEEESymposiumonSecurityand
Privacy (SP). IEEE, 521â€“538.
[50]Juraj Somorovsky. 2016. Systematic Fuzzing and Testing of TLS Libraries. In
Proceedingsofthe2016ACMSIGSACConferenceonComputerandCommunicationsSecurity(Vienna,Austria) (CCSâ€™16).AssociationforComputingMachinery,New
York, NY, USA, 1492â€“1504. https://doi.org/10.1145/2976749.2978411
[51]HaijunWang,Xiaofei Xie,YiLi,ChengWen,YuekangLi,YangLiu,Shengchao
Qin,HongxuChen,andYuleiSui.2020. Typestate-GuidedFuzzerforDiscover-
ingUse-after-FreeVulnerabilities.In 42ndInternationalConferenceonSoftware
Engineering. ACM.
[52]J. Wang, B. Chen, L. Wei, and Y. Liu. 2017. Skyfire: Data-Driven Seed Generation
for Fuzzing. In 2017 IEEE Symposium on Security and Privacy (SP). 579â€“594.
[53]Junjie Wang, Bihuan Chen, Lei Wei, and Yang Liu. 2018. Superion: Grammar-
Aware Greybox Fuzzing. CoRRabs/1812.01197 (2018). arXiv:1812.01197 http:
//arxiv.org/abs/1812.01197
[54]wolfssl. 2019. wolfssl 4.0.0 accepts a certificate with an invalid time format. https:
//github.com/wolfSSL/wolfssl/issues/2657
[55]wolfssl. 2019. wolfssl-4.0.0 accepts a certificate with authority key identifier exten-
sionfieldthatdonotmatchissuer . https://github.com/wolfSSL/wolfssl/issues/
2659
[56]wolfssl.2019. wolfssl4.2.0acceptsacertificatewhoseissuernotmatchingthesubject
of CA certificate. https://github.com/wolfSSL/wolfssl/issues/2680
[57] wolfSSL. 2020. wolfSSL. https://www.wolfssl.com/
[58]Peter E. Yee. 2013. Updates to the Internet X.509 Public Key InfrastructureCertificate and Certificate Revocation List (CRL) Profile. RFC 6818. https:
//doi.org/10.17487/RFC6818
535