Predicting Code Context Models for Software Development
Tasks
Zhiyuan Wan‚àó
Zhejiang University
Hangzhou, China
wanzhiyuan@zju.edu.cnGail C. Murphy
University of British Columbia
Vancouver, Canada
murphy@cs.ubc.caXin Xia
Monash University
Melbourne, Australia
xin.xia@monash.edu
ABSTRACT
Code context models consist of source code elements and their re-
lations relevant to a development task. Prior research showed that
making code context models explicitin software tools can benefit
softwaredevelopmentpractices,e.g.,codenavigationandsearching.
However,littlefocushasbeenputonhowtoproactivelyformcode
contextmodels.Inthispaper,weexploretheproactiveformation
ofcodecontextmodelsbasedonthetopologicalpatternsofcodeel-ementsfrominteractionhistoriesforaproject.Specifically,wefirst
learn abstract topological patterns based on the stereotype rolesofcodeelements,ratherthanonspecificcodeelements;wethenleverage the learned patterns to predict the code context models
for a given task by graph pattern matching. To determine the effec-
tivenessofthisapproach,weappliedtheapproachtointeraction
historiesstoredfortheEclipseMylynopensourceproject.Wefound
that our approach achieves maximum F-measures of 0.67, 0.33 and
0.21 for1-step,2-stepand3-steppredictions, respectively. The most
similar approach to ours is Suade, which supports 1-stepprediction
only. In comparison to this existing work, our approach predicts
codecontextmodelswithsignificantlyhigherF-measure(0.57over
0.23 on average). The results demonstrate the value of integrating
historical and structural approaches to form more accurate code
context models.
CCS CONCEPTS
‚Ä¢Softwareanditsengineering Developmentframeworks
and environments ;‚Ä¢Human-centered computing Human
computer interaction (HCI) .
KEYWORDS
Context Models, Task, Developer, Interaction, Context Prediction
ACM Reference Format:
Zhiyuan Wan, Gail C. Murphy, and Xin Xia. 2020. Predicting Code Context
ModelsforSoftwareDevelopmentTasks.In 35thIEEE/ACMInternational
ConferenceonAutomatedSoftwareEngineering(ASE‚Äô20),September21‚Äì25,
‚àóTheworkwasdonewhenthefirstauthorwasaffiliatedwiththeUniversityofBritish
Columbia.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACMmustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ASE ‚Äô20, September 21‚Äì25, 2020, Virtual Event, Australia
¬© 2020 Association for Computing Machinery.
ACM ISBN 978-1-4503-6768-4/20/09...$15.00
https://doi.org/10.1145/3324884.34165442020, Virtual Event, Australia. ACM, New York, NY, USA, 12 pages. https:
//doi.org/10.1145/3324884.3416544
1 INTRODUCTION
Asasoftwaredeveloperperformsadevelopmenttask,shespends
substantialtimesearchingandnavigatingthroughcodetounder-
stand relevant parts in a software system for that task. Meanwhile,
she forms, in her mind, an implicit code context model consisting of
source code elements and relations between those elements rele-
vant to the task [ 12]. When even a portion of such a model can be
madeexplicit,theinformationinthemodelcanbeusedinsoftware
tools to benefit software developers and the software development
project.Forexample,approachestomakeaspectsofcodecontext
models explicit have shown promise to support searching activi-
ties[19],toimprovecoderecommendations[ 13,29]andtoimprove
the quality of changes made to a system [7].
Despitethepromiseofimprovingsoftwaretoolsusingexplicit
codecontextmodels,therehasbeenlittlefocusonhowtoproac-
tively form these models to benefit a software developer as he
works. At present, there are three approaches that have been used
to capture and represent code context models.
First,acodecontextmodelforataskcanbeexplicitlycreatedby
the developer performing the task. For example, the CodeBasket
tool enables a developer to capture explicitly her mental model as
sheworkswithcode;thisrepresentationcansupportsubsequent
navigation of the code [ 4]. This approach requires the developer to
expendextraefforttocreatethemodel.Inanexploratorystudycon-
ductedabout theCodeBaskettool,participants requestedsupport
to automatically create or complete the representation.
Second, a code context model can be formed by utilizing in-
formationaboutthestructureofthecode.Forexample,Robillard
describes analgorithm, called Suade, thatleverages topologicalfea-
tures of the code structure to suggest a fuzzy set of potential code
elements of interest for a code context model given elements al-
ready identified as interesting (seed code elements) [ 30]. This class
ofapproachesdecreasestheeffortrequiredtocreateacodecontext
model, but still requires either additional effort on the part of a
developer,oraccesstootherinformation,suchasdocumentation,
which can be difficult to obtain.
Third, a code context model can be formed based on the history
of the software development project. The history may describe
which files were changed as part of a task as found in a source
code repository or may contain information about both viewed
andchangedfilesasfoundininteractionhistories[ 13]orchange
historydata[ 29].Techniqueslikeassociationruleminingcanbe
used against historical information to suggest what other code
elements have been associated with given seed code element(s) in
8092020 35th IEEE/ACM International Conference on Automated Software Engineering (ASE)
thepast(e.g.,[ 39]).Theseapproachestendtotreatcodeelements
involved in past changes as isolated with no relations, rather than
ones that have structural, or other relations, to other elements that
comprisethesystem.Thistreatmentofelementslimitstheability
to form sufficiently complete code context models for tasks.
We believe the benefits of code context models can be increased
by improving the proactive automatic formation of code context
models as a developer works. In effect, the proactive formation
wouldrepresentacollectionofothercodeelementsandrelation-
ships the developer is likely to need to draw on to complete the
task,beyondarecommendationofwhatisthenextcodeelement
forthedevelopertoconsider(e.g.,[ 10]).Theproactiveformationof
codecontextmodelscanenable toolstodrawuponthecontextof
the workbeingperformed toimprove theaccuracy ofrecommen-
dations, whether for navigation, searching or other reasons, and to
better speculate on, and prefetch answers to, questions a developer
is likely to pose (e.g., [ 33]), amongst other potential applications.
Byautomaticallyformingcodecontextmodels,toolscanprovide
these benefits at lower cost to the developer.
In this paper, we explore how we can improve the proactive au-
tomaticformationofcodecontextmodelsbyinvestigatingwhether
we can: 1) learn abstract patterns of how developers typically in-
vestigatestructurallyconnectedcodeelementswhenperforming
tasksonasystem,andthen2)usethelearnedpatternstopredict
codecontextmodelsbasedonadeveloper‚Äôsnewinteractionwith
the code for a system. Specifically, we use interaction histories col-
lectedasadeveloperworkstoformcodecontextmodelsatdifferent
points of time in the development of a system. We assign stereo-
types to code elements in these code context models that representthebehavioralaspectsanddesignintentsoftheelements[
22],such
aswhetheramethodisa getterorasetter.Thestereotypesallow
us to abstract away from specific code elements. We then mine
patterns across these abstracted code context models; as each code
contextmodelisagraph,weuseagraphpatternmatchingapproach
to support prediction. Our approach enables a ùëë-step prediction
where the known code context model is expanded to include likely
code elements of interest up to ùëësteps away in the structure from
known code elements. When presented with code element seedsas a developer works on a new task on the system, we can apply
the learned patterns to predict the future code context model. The
approach applies equally well at the start or middle of a task.
We applied this novel approach to interaction histories created
and stored as part of the Eclipse Mylyn open source project. Wefound that our approach achieves maximum F-measures of 0.67,
0.33and0.21for 1-step,2-stepand3-steppredictions,respectively.
The most similar approach to ours is Suade, which supports 1-step
prediction only. In comparison to this existing work, our approach
predictscodecontextmodelswithsignificantlyhigherF-measure
(0.57 over 0.23 on average). The results demonstrate the value of
integratinghistoricalandstructuralapproachestoformingmore
accurate code context models.
This paper makes three contributions:
‚Ä¢We introduce a novel approach to forming code context
modelsthatlearnsabstractpatternsofhowdeveloperswork
with code as part of performing change tasks to a system.‚Ä¢We demonstrate that our approach can predict code con-
textmodels effectively, achievingmaximum F-measuresof
0.67, 0.33 and 0.21 for 1-step,2-stepand3-steppredictions,
respectively.
‚Ä¢Weprovideadatasetthatincludes1,887codecontextmodels
to enable future investigations by others1.
Webeginbydescribingexistingworkintheareaofcodecontext
models(Section2).Next,wedescribeourapproachforforminga
datasetusinginteractionhistories(Section3)andhelpingtoform
code context models from interaction histories (Section 4). We
thenevaluatetheabilityoftheapproachtopredicttheevolution
of code context models (Section 5). We discuss the implicationsof results (Section 6) and limitations of the approach (Section 7),
before concluding (Section 8).
2 RELATED WORK
Many empirical methods in a variety of settings have been used to
explore how developers understand code, from investigating the
comprehensionapproachestakenbydevelopers(e.g.,[ 36])tostudy-
inghowtheyinteractwithcodeandtools(e.g.,[ 20])astheyperform
changetaskstoasystem.Anumberofthestudiesperformedabout
these phenomena find that developers spend a substantial amount
oftimesearchingandnavigatingsourcecodetounderstandandlo-
cate the relevant parts for a task. To help developers perform these
activities, researchers have investigated several ways to capture
andrepresentthecodecontextmodelsdevelopersmentallyform
as they perform their work.
Some of these efforts focus on saving code context models af-
ter the relevant code elements have been identified or navigated
forworkbeingperformed.Concerngraphs[ 32]helpadeveloper
manually capture and represent the relevant elements and rela-tionships between them. Code Bubbles [
5] propose a novel IDE
editor interface that allows a developer to create views of codefragments relative to work being performed. CodeBasket [
4] en-
ablesdeveloperstoexternalizetheirmentalmodelsbyproviding
a canvas on which developers can arrange code elements. These
approachesspecializein savingthecodecontextmodels afterthe
relevant code elements have been identified or navigated for work
being performed. We are interested in this paper in proactively
formingacodecontextmodelsothatthemodelisavailablefora
developerandtoolsto makeuseoftheinformation.Moregeneral
benefits possible from increasing the capture and use of contextin
software development are provided elsewhere [24].
Other efforts focus on automating the creation, or otherwise
lessening,themanualburdenonadevelopertocapturecodecon-
textmodels.Mylyn[ 13]automaticallycreatesataskcontext,which
containsinformationrelevanttoacodecontextmodel,fromade-
veloper‚Äôsinteractionswithcode.Suade[ 31]analyzesthestructural
dependenciesofcodeelementsthathavealreadybeennavigated,
andidentifiesadditionalrelevantcodeelementsasthecontextforatask.OurapproachismostsimilartoSuadeintheproactivegenera-tionofcodecontextinformation.IncontrasttoSuade,ourapproach
uses information learned from historical information about how a
developer has worked to predict potential code context elements.
1https://github.com/zhiyuan-wan/ASE_2020_predicting_code_context
810Closely related to the formation of code context models are var-
ious recommendation approaches. These approaches build on a
variety of information to try to predict code that might be relevant
toadeveloper‚Äôs work.Forexample,DeLine etal.useinformation
abouthowdevelopersnavigateacodebasetorecommendwhere
adevelopershouldnavigatenext[ 10].Otherapproachesusepro-
gramstructuralinformation[ 3,14],textualsimilaritybetweencode
elementsandtaskdescriptions[ 15]versionhistories[ 16,38,39],or
acombinationofmultiplesources[ 28].Ourapproachdiffersintwo
ways. First, instead of aiming to produce a direct recommendation
to the developer, we predict what code matters for a task to inform
and improve other tools, such as the display of code or filtering
of search results. Second, our approach can leverage additionalcontext when expanding what a code context model may be by
basing predictions on the graph structure of previous code context
models.
Ourapproachreliesontheuseofstereotyperoles[ 22]togeneral-
ize from specific code context models formed as a developer works
to abstract forms that facilitate pattern detection. We use these pat-ternsasabasisforcompletingcodecontextmodelsbasedondevel-oper‚Äôs partialworkon atask. Priorstudies haveutilized stereotype
roles for other purposes, including generating natural-language
summaries for code in Java [ 21,23] and C++ [ 1] programming lan-
guages, feature location [ 2], detecting code smells [ 9], categorizing
source code identifiers [ 27], generating commit messages [ 6,18],
categorizing methods in unit tests [ 17], and serving as an indicator
of system design [ 11]. We are the first to use stereotype roles to
summarize the behaviors of methods and classes in past code con-
textsandtothenusetheabstractedcodecontextmodelstosupport
prediction.
3 CODE CONTEXT MODEL DATASET
Toexperimentwiththeproactiveformationofcodecontextmodels,
we need a dataset of such models. We form such a dataset using
interactionhistories capturedasdevelopersworkwiththeEclipse
Mylyn open source project2. We describe the data we extract from
the project (Section 3.1) and how we transform this data into code
context models ready for experimentation (Section 3.2). Figure 1
provides an overview of the process used to create the dataset. The
resulting dataset formed from this process is available online3.
3.1 Data Extraction
ThetoppartofFigure1describestheextractionofdatafromthe
Mylynsystemdevelopment.TheEclipseMylyntoolrecordsinterac-tionhistoriesasadeveloperworksonacodebase.Eachinteraction
history includes a record of the code elements that are viewed and
edited by the developer. Mylyn enables one or more interaction
histories to be associated with each task performed by developers
on a system. For the development of the Mylyn tool, interaction
histories are stored with the tasks recorded in the Eclipse Bugzilla
system.WechosetousetheMylynprojectasthedatasourcefor
our investigations because the project has collected interaction
historiesforover15years,andtheseinteractionhistoriesrepresent
2https://www.eclipse.org/mylyn
3https://github.com/zhiyuan-wan/ASE_2020_predicting_code_contextthe work of over 117 developers. We consider the threat to validity
of our work from this choice in Section 7.
Bug Report Filtering. To gather interaction histories, we con-
sidered the 5,208 FIXEDandCLOSED bug reports of the Mylyn
projectfromtheEclipseBugzillabugtrackerbetweenApril2004
and December 2019. From this set of fixed bug reports, we filtered
all bug reports that did not have one or more interaction histories
associated with the report, leaving 1,246 bug reports to consider.
The 1,246 bug reports have an average of 1.72 interaction histories
attached (Min: 1, Max: 11, Median: 1, SD: 1.3).Interaction Trace Extraction.
We extracted and used the last
interactionhistoryassociatedwitheachofthesebugreports.We
onlyconsideredinteractionhistorieswitheventsdirectlyrecording
interaction with code elements (‚Äúselection‚Äù and ‚Äúedit‚Äù events about
class,method,andfieldcodeelements).Thefinaldatasetconsistsof
1,219 valid interaction traces with an average of 145.19 interaction
events (Min: 1, Max: 4,179, Median: 65, SD: 376.37).
3.2 Code Context Model Formation
The bottom part of Figure 1 describes the formation from the ex-
tracted data into code context models.Breaking Interaction Histories.
For code context models, we
areinterestedinrepresentingthemodelsthatdevelopersusually
keepintheir mindsastheyworkwith code foratask.Asa result,
weneedtobreakinteractionhistoriesintounitsthatmorelikely
representaperiodoftimeinwhichadeveloperisworkingwiththe
code and for which they may have formed a working mental code
context model. To capture such units, we define the concept of a
working period, consisting of the portion of the interaction history
consistingofeventswithintwohourtimeperiods.Wechosetwo
hours because an analysis of all of the interaction histories showed
twohourswasthemeantimebetweentwoconsecutiveinteraction
events in the histories. By applying this step, we formed 2,815
working periods.
ExtractingCodeElements. Weareonlyinterestedininteraction
histories4recording work with code elements, as opposed to docu-
mentation or xml files. Thus, we filtered for interaction histories
accessing or editing Java code elements as Mylyn is predominantly
written in Java. Of the 2,815 working periods we identified, de-
velopersconsideredJavacodeelementsin2,726workingperiods
(96.8%).
Structuraldependenciesbetweencodeelementsarenotavailable
in interaction histories. To capture structural information, we needtobeabletorelateeachinteractionhistorytoversion(s)ofthecode
activewhentheinteractionhistorywascollected.Thus,foreach
workingperiod,we1)resolvedthegitrepositoryforextractedcode
elements,2)extractedeventtimestampsfromtheinteractionhis-
tory, and 3) associated each working period with code snapshot(s).
Resolving Git Repository. Weresolvedgitrepository(reposito-
ries) of accessed code elements for each working period as the My-
lyncodeisstoredacrossseveralgitrepositories.Thisstepexcluded839workingperiodsthataccessonlycoarse-grainedcodeelements
4In the remaining of this section, unless otherwise mentioned, we use ‚Äúinteraction
history‚Äù to refer to a portion of an interaction history corresponding to a working
period.
811Data Extraction
Interaction Histories
Event Timestamps
First event 2010-02-21 11:35:53
Last event 2010-02-21 15:23:27
Bug Report 303431 
remove CommonColors.CONTEXT
_ACTIVE
Fixed
Interaction History 159708 
<InteractionHistory Version="1" 
Id="https://bugs.eclipse.org/bugs-303431">
‚Ä¶
<InteractionEvent CreationCount="9" 
NumEvents="4" StructureKind ="java" 
StructureHandle ="=org.eclipse.mylyn.comm
ons.ui/src&lt;org.eclipse.mylyn.internal.provisi
onal.commons.ui{CommonThemes.java[Com
monThemes^COLOR_TASK_ACTIVE" 
StartDate ="2010-02-21 11:36:05.55 CET"  
OriginId="org.eclipse.jdt.ui.PackageExplorer" 
Navigation="null" Kind ="selection" 
Interest="4.0" EndDate="2010-02-21 
15:21:48.606 CET" Delta="null"/>
‚Ä¶
</InteractionHistory >
Code Context Model
12 3
4
Git Repositories
mylyn.tasksmylyn.commons
Code Elements
org.eclipse.mylyn.internal.provisional.commons.ui.
CommonThemes^COLOR_TASK_ACTIVE
org.eclipse.mylyn.internal.provisional.commons.ui.
CommonThemesorg.eclipse.mylyn.tasks.ui.T askElementLabelProvider
org.eclipse.mylyn.tasks.ui.T askElementLabelProvider
[getForeground1
2
3
4StructureKind ="java"
 St t Ki d
 "j "
Extracting Code 
Elements 
Resolving Git
Repository
Extracting 
Event 
Timestamps
Associating with 
Commit 
Event StartDate
Working Period 
<InteractionEvent ‚Ä¶/>
‚Ä¶
Breaking into 
Working 
Periods
Event Interval > 2 hours
Repository Snapshots
mylyn.commons
Commit 3ead864c 2010-02-21 10:43:34
mylyn.tasks
Commit 78457484  2010-02-21 10:43:32
Running Doxygen
Structural 
Dependencies between Code 
Elements
Forming Code 
Context Modeldeclares declares
Eclipse 
Bugzilla
Mylyn Bug Reports
Bug Report 115179 
Fixed
Bug Report 303431 
Fixed...
...
Interaction History 159691
Interaction History 159
 691
 te act o s to y 59
69
Interaction History 159708 
Filtering Bug 
Reports
Extracting 
Interaction 
Histories
Interaction Histories
 Mylyn Bug Reports
Bug Report 201466 
Fixed
Bug Report 303431 
Fixed...
...
Interaction History 77185
Interaction History 159708 
Code Context Model Formation
Bug Report 201466 
Fixed
Interaction History 77185 ...
Final Interaction History
Figure 1: Process of collecting dataset.
Table 1: Characteristics of 1,887 code context models in dataset. In terms of node number, 51 code context models lie outside
the interval [ùëÑ1‚àí3ùêºùëÑùëÖ,ùëÑ3+3ùêºùëÑùëÖ]whereùëÑ1=3,ùëÑ3=14,ùêºùëÑùëÖ=11; 4 code context models lie above 200.
Code Context Model Connected Component (CC)
Node # Edge # CC # Node # Edge # Diameter
Min 101100
Max 944 421 572 152 210 16
Median 7 3 3100
Mean 12.32 8.48 4.61 2.67 1.84 0.90
SD 30.34 18.38 17.58 5.02 6.51 1.56
(directory orfile),whichlackstructuralrelations,orinvolvecode
elements from unavailable code repositories (e.g., dependency li-
braries),oraccessonlycodeelementsthatwerenotcommittedto
therepositorywhentheinteractionhistorywascollected.Forexam-
ple, for the working period in Figure 1, we resolved two related git
repositories: mlylyn.tasks andmylyn.commons . After this step,
we are left with 1,887 working periods from which to form code
context models.
Extracting Event Timestamps. We extracted the StartDate at-
tribute of each interaction event from an interaction history as the
timestampoftheevent,andidentifythetimestampsofthefirstandlast events. The timestamps help to locate the commits before and
duringtheworkingperiod.Intermsoftheexampleworkingperiod
in Figure 1, the timestamps of first and last events are ‚Äú2010-02-21
11:35:53‚Äù and ‚Äú2010-02-21 15:23:27‚Äù, respectively.
AssociatingwithCommits. Byusingthetimestampsoffirstand
lasteventsintheinteractionhistory,weassociatedeachinteraction
history with one or multiple commits in the related git reposito-
ries. Specifically, we retrieved the most recent commit in the gitrepository prior to the timestamp of the first event in the inter-action history. In addition, to capture the code changes during a
working period, we accessed any other commits that occur before
812the timestamp of the last event. With regard to the example work-
ingperiodinFigure1,weassociatedtheworkingperiodwiththe
commit 78457484 inmlylyn.tasks andthecommit 3ead864c in
mylyn.commons.
Running Doxygen. We usedDoxygen [ 35] toidentify structural
relations between code elements. Specifically, we run Doxygen for
each code snapshot of each commit associated with the working
period. In this paper, we consider four structural relations: declares,
calls,inherits, and implements. Figure 1 illustrates that using Doxy-
gen we identify two declaresrelations between the code elements.
Forming Code Context Model. For each working period, we
formed one code context model. The extracted code elements form
the nodes of the code context model for a working period, while
theidentifiedstructuraldependenciesformtheedgesofthecode
context model. Figure 1 presents the code context model for the
exampleworkingperiod,withfournodesandtwodirectionaledges
labeled by structural relations. This code context model, which
consists of two connected components, is thesole working period
associated with the Bug Report 303431.
Ourfinaldatasetofcodecontextmodelsconsistsof1,887models.
To give a sense of these models, Table 1 reports on statistics about
these models. This data shows that the size of code context models
varies, with an average of just over 12 nodes. The code context
models are typically comprised of multiple connected components,
with an average of 4.61, indicating that developers‚Äô worked with
multiple clusters of structurally connected code elements during a
working period. The right side of Table 1 reports statistics about
the range of size of the 8,696 connected components comprising
thecodecontextmodels.Thisdatashowsthattheaveragediameter
ofconnectedcomponentsis0.90,indicatingthatthedevelopersdid
notnavigatecodeelementsbyfollowingstructuraldependencies
in depth during a working period. The maximum number of nodes
in acode context modelis 944, leading usto question thenumber
of outliers. We found that 51 models lie outside the interval [ùëÑ1‚àí
3ùêºùëÑùëÖ,ùëÑ3+3ùêºùëÑ]where the upper bound is 47 ( ùëÑ1=3,ùëÑ3=14,
ùêºùëÑùëÖ=11)5.
4 CODE CONTEXT MODEL PREDICTION
Our goal is to predict the code context model for a task initiatedby a developer. We assume the developer has initiated the taskby identifying some code elements of interest for the task. For
example,adevelopermayhavejuststartedworkonataskandcould
benefit from a prediction of the code that will need to be consulted
to support the remaining work to be performed on the task. By
framingtheproblemasapredictionopportunity,weaimtoprovide
thecodecontextmodeltotoolsthatmayhelpadevelopersearch
orotherwiseworkwiththecoderatherthansimplyrecommend
the next step to a developer.
Specifically,intermsofataskonasystem ùëö,ourapproachtakes
asinputasetofseeds, ùëÜ,foreachconnectedcomponent ùëêùëêinthe
completecodecontextmodel ùëüforthetask.Eachseed ùë†‚ààùëÜcontains
aportionofaconnectedcomponent.Ourapproachsupportsa ùëë-
step prediction where the code elements predicted are structurally
5Q1isthe25thquartile;Q3isthe75thquartile;IQR(InterquartileRange)isdefinedas
thedifferencebetweenthe25thand75thquartileandservedasameasureofstatistical
dispersion.connectedwith,and ùëëstepsaway,fromthecodeelementsin ùë†.Our
approachreliesonabstracttopologicalpatternsofhistoricalcode
contextmodelstomakeaneffectiveprediction.Thesecodecontext
modelsareextractedfrompreviousinteractionhistoriescaptured
and stored for tasks on the system ùëö. The extracted topological
patterns are based on stereotype roles assigned automatically to
code elements in ùë†.
Wedescribetheassignmentofstereotyperolestocodeelements
(Section4.1)beforeexplainingourpredictionapproach(Section4.2).
4.1 Stereotype Role Assignment
Developers perform tasks on a software system to add new and fix
existing functionality. As a result, developers often work on differ-
ent parts of the code base. An analysis of the code context models
inourdataset,whichincludeJavacode,indicatesthatdevelopers
accessed each classelement an average of 4.76 times (Min: 1, Max
118,Median:3,SD:7.53),each methodelement1.91times(Min:1,
Max60,Median:1,SD:2.11),andeach fieldelement1.21times(Min:
1,Max 9,Median:1, SD:0.56). Theserelativelylow ratesofaccess
to code indicate that if we wish to build on patterns of access topredict code context models, we must abstract from the specificcode elements accessed. We hypothesize that the roles the code
elements play in the system are a good basis for this abstraction.
We use the method and class stereotype taxonomy proposed by
MorenoandMarcustoassignroles[ 22].Thetaxonomyprovides17
stereotyperolesformethodelementsdividedacrossfourcategories:
structural accessor, structural mutator, creational and collabora-
tional. An example of a specific stereotype within these categories
is a structural mutator called Command that indicates a method
performingacomplexchangetoanobject‚Äôsstate.Thetaxonomy
also provides 13 stereotype roles for class elements, including Data
Provider, which encapsulates data and consists mainly of accessor
methods,and PureController thatconsistsentirelyofcontrollerand
factory methods.
WeuseMorenoetal.‚Äôs JStereoCode tool[22]toassignstereotypes
to each code element on the fly as needed during the predictionprocess. Specifically, we run the tool on the snapshots of code
repositories associated with the context models. During the predic-
tion, we search for each code element in the output of JStereoCode
for the related snapshot to assign a stereotype. For instance, in
termsoftheexamplebugfixingtaskinFigure1,wesearchedfor
org.eclipse.mylyn.internal.provisional.commons.ui.Com-monThemes
(node2)inthe JStereoCode outputforthesnapshotright
afterthecommit 3ead864c .Asa result,weassigned PoolClassas
the stereotype of node 2. Theoretically, it is possible that a code
element could have multiple stereotypes across different snapshots
in a repository due to software evolution.
4.2 Prediction Approach
The prediction approach consists of two stages. The first stage
mines abstract topological patterns from historical code context
models.Basedontheabstracttopologicalpatterns,thesecondstagepredictsthefinalcodecontextmodelofatask,withasetofseeds
ùëÜ
for each connected component in the code context model as input.
8131:Input
2:S a seed set for a connected component ùëêùëê
3:ùëëprediction step
4:ùëÉa set of topological patterns
5:Output
6:ÀÜùê∫a set of matched subgraphs
7:ùë†ùëëexpanded seed
8:ÀÜùë†/primea predicted context model for the connected compo-
nentùëêùëê
9:forallùë†‚ààùëÜdo
10:ùëî=ùëíùë•ùëùùëéùëõùëë(ùë†,ùëë)
11:ùë†ùëë=ùëîùëüùëéùëù‚ÑéùëÄùëíùëüùëîùëí (ùëî,ùë†ùëë)
12:end for
13:ùëéùë†ùë†ùëñùëîùëõùëÜùë°ùëíùëüùëíùëúùë°ùë¶ùëùùëíùëÖùëúùëôùëí (ùë†ùëë)
14:forallùëù‚ààùëÉdo
15:ÀÜùê∫=ÀÜùê∫‚à™ùëùùëéùë°ùë°ùëíùëüùëõùëÄùëéùë°ùëê‚Ñé (ùëù,ùë†ùëë)
16:end for
17:forallùëî‚ààÀÜùê∫do
18:ÀÜùë†/prime=ùëîùëüùëéùëù‚ÑéùëÄùëíùëüùëîùëí (ùëî,ÀÜùë†/prime)
19:end for
20:forallùë£‚ààÀÜùë†/primedo
21:ùëúùë£=0
22:forallùëî‚ààÀÜùê∫do
23: ifùë£‚ààùëîthen
24: ùëúùë£=ùëúùë£+1
25: end if
26:end for
27:ùëêùëúùëõùëìùëñùëëùëíùëõùëêùëí ùë£=ùëúùë£/|ÀÜùê∫|
28:end for
Figure 2: Context model prediction algorithm.
Stage 1: Topological Pattern Mining. The stage takes as input
a system, ùëö, a threshold of pattern support, ùëÄùëñùëõùëÜùë¢ùëùùëù , and a repos-
itory of code context models, ùëÖ.ùëÖis formed from interaction histo-
riesforprevioustaskscompletedon ùëö.Eachcodeelementof ùëü‚ààùëÖ,
wherepossible,hasbeenassignedastereotype.Asetoftopological
patterns ùëÉis populated by mining frequent graph patterns in ùëÖ.
Specifically,werun gSpan[37]withùëÖasinputand ùëÄùëñùëõùëÜùë¢ùëùùëù asthe
parameter.
gSpanis an efficient algorithm for graph-based substructure
pattern mining. Given a dataset of graphs, ùê∑={ùê∫0,ùê∫1,...,ùê∫ ùëõ},
ùë†ùë¢ùëùùëùùëúùëüùë°(ùëî)denotes the number of graphs (in ùê∑) in which ùëîis a
subgraph. gSpanexplores depth-first search to find any connected
subgraph ùëîs.t.ùë†ùë¢ùëùùëùùëúùëüùë°(ùëî)‚â•ùëöùëñùëõùëÜùë¢ùëù(aminimumsupportthresh-
old). We use a Python implementation6ofgSpanand calculate the
threshold ùëöùëñùëõùëÜùë¢ùëùforgSpanbytakingintoaccountthesizeofgraph
dataset, i.e., ùëöùëñùëõùëÜùë¢ùëù =ùëÄùëñùëõùëÜùë¢ùëùùëù ‚àó|ùê∑|.
Stage2:ContextModelPrediction. Figure2illustratesthealgo-
rithm for this stage. The stage takes as input a set of seeds ùëÜfor
each connected component ùëêùëêin the code context model ùëüfor a
taskonùëö,thepredictionstep, ùëë,andasetoftopologicalpatterns
that are derived at stage 1, ùëÉ. The first step expands each ùë†‚ààùëÜtoùëî
by performing a depth-first search along the structural relations.
6gspan-mining v0.2.2, https://pypi.org/project/gspan-miningThe resulting code elements are structurally connected with the
nodesin ùë†toadepthof ùëë(line10).Aftertheexpansion,allofthe
expanded graphs ùëîare merged to form ùë†ùëë(line 11); all code ele-
ments in ùë†ùëëhave been assigned a stereotype (line 13). Then, for
each pattern ùëùinùëÉ, we locatesimilar structures in ùë†ùëëby applying
thepatternMatching function (line 15).
ThepatternMatching function searches for the pattern ùëùamong
particular subgraphs in ùë†ùëë. Note that ùëërepresents the prediction
stepandislimitedbythediameterofaconnectedcomponent.Thus,
thepatternMatching functionextractsasubsetofsubgraphsin ùë†ùëë
forpatternmatching.Thesesubgraphscontainatleast (ùëë+1)nodes
fromùë†ùëë,andareoftwotypes:1)subgraphswhosenodesexistin
anyùë†‚ààùëÜ;or2)subgraphsthathave ùëënodesthatdonotexistinany
ùë†‚ààùëÜ.Finally,the patternMatching functionreturnsthesubgraphs
that are matched with the pattern ùëù.
Finally, all matched subgraphs with ùëù‚ààùëÉare merged to form
thepredictedcontextmodel ÀÜùë†/primeforaconnectedcomponent(line18).
Theconfidence value of each node in ÀÜùë†/primeis calculated by evaluating
the frequency of occurrence across matched subgraphs (line 20 -
28).
Figure3illustratestheprocessof 1-stepcontextmodelprediction
with the example bug fixing task (bug ID: 303431) as shown in
Figure 1. The code context model has two connected components.
Wetaketheconnectedcomponent ùëêùëêwithnode1andnode2asthe
example. ùëêùëêhasaClassnode(labeled2)anda Fieldnode(labeled
1). Each node in ùëêùëêcan serve as a seed for 1-stepprediction and
belongs to the seed set ùëÜ(labeled seed 1 and seed 2). The 1-step
prediction approach then expands each seed to a depth of ùëë=1
and generates an expanded graph ùëîfor each seed. After expansion,
thetwoexpandedgraphsaremergedtoform ùë†1,whereallnodes
are assigned a stereotype. After running pattern matching with
eachùëù‚ààùëÉ,wefindthatthepattern Pool class declares Field
matches12subgraphsin ùë†1,whichformthesetofsubgraphs ÀÜùê∫.All
ofthesubgraphsin ÀÜùê∫aremergedtoformapredictedcontextmodel
ÀÜùë†/prime.Theconfidence valueforeachnodein ÀÜùë†/primeiscalculatedbasedon
its frequency of occurrence across subgraphs in ÀÜùê∫. For instance,
theconfidence value of node 2 equals to 12 /12=1 because node
2occurs inevery subgraph.Meanwhile,node 1occurs injustone
subgraph thus its confidence value equals to 1/12.
5 EVALUATION
Weexplaintheresultsofapplyingthepredictionapproachtothe
dataset described in Section 3. Specifically, we explore three re-
searchquestionstoinvestigatetheeffectivenessofourapproach
for code context model prediction:
‚Ä¢RQ1.Whatkindsofpatternscanbelearnedfrominteraction
histories?
‚Ä¢RQ2.Howdoestheperformanceofourapproachforcode
context model prediction differ over various values of ùëë, the
number of steps of prediction?
‚Ä¢RQ3.Howdoesourapproachcomparetothestate-of-the-
art?
814‡¢ç
‡¢â‡¢â 
Matched Patterns in ‡°º
Pool
ClassFielddeclares
12
‡°ø
1
2seed 1
seed 2
‡¢ô‡´ö
12 9 34567
8
10
11131214declares12
129 34567
8
10
11
13 1214
‡∑°‡°≥
8 2
9 2
2
2
2
21 2
3 2
4 2
5 2
6 2
7 210
11
12
1312 9 34567
8
10
11 1312
Node Stereotype Confidence
1org.eclipse.mylyn.internal.provisional.commons.ui.CommonThemes^ COLOR_TASK_ACTIVE Field 1/12
2org.eclipse.mylyn.internal.provisional.commons.ui.CommonThemes Pool Class 1
3org.eclipse.mylyn.internal.provisional.commons.ui.CommonThemes^ COLOR_CATEGORY Field 1/12
4org.eclipse.mylyn.internal.provisional.commons.ui.CommonThemes^ COLOR_CATEGORY_GRADIENT_END Field 1/12
5org.eclipse.mylyn.internal.provisional.commons.ui.CommonThemes^ COLOR_CATEGORY_GRADIENT_START Field 1/12
6org.eclipse.mylyn.internal.provisional.commons.ui.CommonThemes^ COLOR_COMPLETED Field 1/12
7org.eclipse.mylyn.internal.provisional.commons.ui.CommonThemes^ COLOR_COMPLETED_TODAY Field 1/12
8org.eclipse.mylyn.internal.provisional.commons.ui.CommonThemes^ COLOR_INCOMING_BACKGROUND Field 1/12
9org.eclipse.mylyn.internal.provisional.commons.ui.CommonThemes^ COLOR_OVERDUE Field 1/12
10org.eclipse.mylyn.internal.provisional.commons.ui.CommonThemes^ COLOR_SCHEDULED_PAST Field 1/12
11org.eclipse.mylyn.internal.provisional.commons.ui.CommonThemes^ COLOR_SCHEDULED_THIS_WEEK Field 1/12
12org.eclipse.mylyn.internal.provisional.commons.ui.CommonThemes^ COLOR_SCHEDULED_TODAY Field 1/12
13org.eclipse.mylyn.internal.provisional.commons.ui.CommonThemes^ FONT_EDITOR_COMMENT Field 1/12
14org.eclipse.mylyn.internal.provisional.commons.ui.CommonThemes[isCommonTheme Collaborator Method -‡∑°‡¢ô‘¢
Figure 3: Sample task to illustrate how our approach does 1-stepprediction.
5.1 Experiment Design
Toanswertheresearchquestions,theexperimentsimulatescode
contextmodelpredictionandappliesourpredictionapproachto
the dataset.
Experimental Setup. We choose a simulation-based method to
experimentwithourapproachandevaluateourapproachinausage
scenario where a developer starts code search and navigation from
the middle of a task. The experimental method involves a training
set,a testset, anda simulator.The trainingset, ùëÖùëáùëüùëé ùëñùëõ,is asubset
of our dataset, to mine the abstract topological patterns ùëÉ. The test
set,ùëÖùëáùëíùë†ùë°,istheremainingcodecontextmodelsfromourdataset
thatarenotin ùëÖùëáùëüùëé ùëñùëõ.Giventhesequentialnatureofourdataset,
weusethe1,254codecontextmodelsfromtheyear2007to2009
(84%) as the training set, and the 231 code context models from the
year 2010 to 2011 (16%) as the test set.
The simulator first creates multiple seed sets from the test set
ùëÖùëáùëíùë†ùë°, as illustrated in Figure 4. For each code context model ùëü‚àà
ùëÖùëáùëíùë†ùë°, the simulator creates a seed set ùëÜfor each connected com-
ponentùëêùëê‚ààùëüwith prediction step ùëëas input. Once the seed set
ùëÜis created from ùëÖùëáùëíùë†ùë°, the simulator mines abstract topological
patterns through ùëÖùëáùëüùëé ùëñùëõ. To select topological patterns, the sim-
ulator uses the minimum support ùëÄùëñùëõùëÜùë¢ùëùùëù as a threshold. Then,
the simulator iterates over each seed set ùëÜ‚ààÀÜùëÜand bootstraps a
prediction approach (i.e., our approach and the state-of-the-art)
withùëÜas input. Finally, the simulator aggregates prediction results
ofallconnectedcomponentsforeachcodecontextmodel ùëü‚ààùëÖùëáùëíùë†ùë°.
Experiment for RQ1. We investigate the numbers and kinds of
patterns extracted by considering the effect of ùëÄùëñùëõùëÜùë¢ùëùùëù on the
mined topological patterns. To make a tradeoff between the gener-
alizabilityandspecificityofminedpatterns,weexperimentwith
a range of 0.02 to 0.2 for ùëÄùëñùëõùëÜùë¢ùëùùëù . We compare the topological
patterns with various ùëÄùëñùëõùëÜùë¢ùëùùëù values in the range of 0.02 to 0.2
in increments of 0.02. We use the best result for ùëÄùëñùëõùëÜùë¢ùëùùëù in subse-
quent experiments.1:Input
2:ùëÖùëáùëíùë†ùë°test set
3:ùëëpredition step
4:Output
5:ÀÜùëÜseed sets
6:forallùëü‚ààùëÖùëáùëíùë†ùë°do
7:forallùëêùëê‚ààùëüdo
8: ùë†ùëñùëßùëí=ùëõùëúùëëùëíùëÅùë¢ùëöùëèùëíùëü (ùëêùëê)
9: ùëÜ=ùëíùë•ùë°ùëüùëéùëêùë°ùëÜùë¢ùëèùëîùëüùëéùëù‚Ñéùë† (ùëêùëê,ùë†ùëñùëßùëí‚àíùëë)
10: ÀÜùëÜ=ÀÜùëÜ‚à™{(ùëü,ùëêùëê,ùëÜ)}
11:end for
12:end for
Figure 4: Seed generation algorithm.
Experiment for RQ2. To understand the effect of prediction step
ùëë, we evaluate the performance of our prediction approach with ùëë
tobe1,2and3,representing 1-step,2-step,and 3-steppredictions,
respectively. Note that prediction step ùëëis limited by the diameter
ofaconnectedcomponent.Forinstance,aconnectedcomponentof
diameter2 cansupport 1-stepand2-steppredictions.The average
diameter of the connected components in the test set is 2.1 (Min: 1,
Max: 16, Median: 2, SD: 1.7). To consider adequate instances in the
testsetforeachpredictionstep,wechoose ùëëtobe1,2and3.We
further investigate the impact of confidence threshold ùëÄùëñùëõùê∂ùëúùëõùëì
ontheperformanceofprediction.The confidence valueofacode
element in prediction results varies between 0 and 1. Thus, we set
ùëÄùëñùëõùê∂ùëúùëõùëì to be in the range of 0.1 to 1.0 in increments of 0.1.
Experiment for RQ3. Suadeis the state-of-the-art approach for
codecontextmodelcompletion[ 31].Suadeleveragesheuristicchar-
acteristicsof thestructuraldependencies(i.e., specificityandrein-
forcement) to rank code elements connected with the seed. Given
8151:Input
2:ùêørelation types
3:ùë§selection window
4:ùëÜa seed set for a connected component ùëêùëê
5:Output
6:ÀÜùë†/primepredicted context model for the connected compo-
nentùëêùëê
7:forallùë†‚ààùëÜdo
8:ùêπ=ùë†ùë¢ùëéùëëùëí(ùë†,ùêø,ùë§)
9:ÀÜùë†/prime=ùëîùëüùëéùëù‚ÑéùëÄùëíùëüùëîùëí (ùêπ,ÀÜùë†/prime)
10:end for
Figure 5: Experimental setting of Suade.
that the original implementation of Suadeis not accessible, we
implement Suadein Python and make it available online7.
AsSuadesupportsonly 1-stepprediction,wecompareonlyfor
this prediction step. We have the simulator iterate over ùëÜ‚ààÀÜùëÜfor
thepredictionstep ùëë=1,andbootstraptheexperimentalsettingof
SuadeasdescribedinFigure5.Weusethesimulatortorun Suadefor
eachseed ùë†‚ààùëÜandmergepredictedresultstoformthepredicted
context model ÀÜùë†/prime(line 7 - 10).
We simulate Suadewith 1, 3 and 5 as the selection window ùë§,
respectively, where Suademakestop- ùë§recommendationfor each
connectedcomponent.Wheneverthereexistsatieforatopposition,
webreakthetiebyrandomlychoosingthetopelement(s)among
the equal-valued suggestions.
Toensureafaircomparison,weuse declares,callsandinherits
as the relation types ùêøforSuade. For each selection window ùë§
whenapplying Suade,wecalculatetheactualsizeof ÀÜùë†/primeasùëòforeach
connectedcomponentinacodecontextmodel.Forcomparison,we
choosetop- ùëòcodeelementswithgreatest confidence valuesforeach
connected component from the prediction results of our approach.
We used the same tie breaker as Suade.
5.2 Measurement
To measure the effectiveness of prediction, we use several com-
monly used metrics. For each context model ùëü‚ààùëÖùëáùëíùë†ùë°,w eu s e
actualcodeelements ùëâandpredictedcodeelements ùëâ/primetocompute
the metrics. ùëâare the code elements in the actual context model of
ùëü.ùëâ/primearethecodeelementsinthecontextmodelpredictedbased
on a portion of ùëâ. We calculate precision ùëÉand recall ùëÖmetrics as:
Precision ùëÉ=|ùëâ‚à©ùëâ/prime|
|ùëâ/prime|(1)
RecallùëÖ=|ùëâ‚à©ùëâ/prime|
|ùëâ|(2)
To capture the trade-off between precision and recall, we compute
theharmonicmean F-measure fromtheaveragedvaluesofprecision
and recall across code context models:
F-measure ùêπ=2‚àóùëÉ‚àóùëÖ
ùëÉ+ùëÖ(3)
7https://github.com/zhiyuan-wan/ASE_2020_predicting_code_context
020406080100120140160
0.02 0.04 0.06 0.08 0.10 0.12 0.14 0.16 0.18 0.20Pattern Number
MinSuppNode 2
Node 3
Node 4
Node 5
Figure 6: Number of patterns with MinSupp in the range of
0.02 to 0.20.
5.3 Results
We describe the results for each experimental question in turn.
5.3.1 RQ1. Abstract Topological Patterns. The first research ques-
tion considers the kinds of patterns that can be learned from inter-
actionhistories.Figure6summarizesthenumberofpatternsmined
fromùëÖùëáùëüùëé ùëñùëõwithvariousnumbersofnodesinthe pattern.Asthe
value of ùëÄùëñùëõùëÜùë¢ùëùùëù increases, the number of topological patterns
decreases sharply from 142 to 2. This result indicates that topologi-
calpatterns,evenintermsofstereotyperoles,arenotfrequently
occurring in the dataset.
Patterns with 2 nodes (node-2 pattern) account for more than
50% of the patterns across various ùëÄùëñùëõùëÜùë¢ùëùùëù values. Node-5 pat-
terns disappear when ùëÄùëñùëõùëÜùë¢ùëùùëù >=0.04, while Node-4 patterns
disappear when ùëÄùëñùëõùëÜùë¢ùëùùëù >=0.06. Note that our proposed predic-
tion approach leverages node- ùëõpatterns to make ùëë-stepprediction
whereùëõ>ùëë.Tocaptureadequatetopologicalpatternsforpredic-
tion, we use the topological patterns where ùëÄùëñùëõùëÜùë¢ùëùùëù = 0.02 in the
experiments hereafter. The topological patterns with ùëÄùëñùëõùëÜùë¢ùëùùëù =
0.02 are distributed across 94% of the code context models in the
training set.
Togiveasenseofthekindsofpatternsmined,Table2showsthe
distribution of stereotype roles of the nodes in topological patterns
whereùëÄùëñùëõùëÜùë¢ùëùùëù =0.02.The MethodandClassstereotypesinvolved
in the patterns account for 63% of Methodstereotypes and 38%
ofClassstereotypes that occur in the training set, respectively.
The distribution of stereotype roles involved in the patterns are
consistent with that in the training set.
5.3.2 RQ2. Prediction Performance. The second research question
considers the performance of our approach for code context model
prediction. Table 3 reports the numbers of code context models
(column 2) and connected components (column 3) in the test set
that can support 1-step, 2-step and 3-step predictions.
F-measure. Figure 7 presents the resulting F-measure forstep-1,
step-2andstep-3predictions. Each point represents the F-measure
of all the predictions across code context models with MinConf
ranging from 0.1 to 1.0.
TheF-measure values of step-1start from 0.34 and end with 0.26,
achievingthe highest value0.67at MinConf =0.3.The F-measure
values of step-2start from 0.25 and end with 0.23, achieving the
highestvalue0.33at MinConf =0.6.The F-measure valuesof step-3
816Table 2: Stereotype roles in the topological patterns with
MinSupp = 0.02.
Stereotype Count Percentage
Method
Collaborator 94 46.8%
Command-Collaborator 37 18.4%
Set-Collaborator 22 10.9%
Factory-Collaborator 13 6.5%
Set 10 5.0%
Constructor 7 3.5%
Non Void Command-Collaborator 5 2.5%Get 5 2.5%
Abstract 3 1.5%
Local Controller 3 1.5%
Command 1 0.5%
Factory 1 0.5%
ClassBoundary-Commander 45 34.4%
Boundary 34 26.0%
Other 31 23.7%
Entity 12 9.2%
Commander 3 2.3%
Interface 2 1.5%
Minimal Entity 2 1.5%
Factory 1 0.8%
Boundary-Data Provider 1 0.8%
Field 49 -
start from 0.21 and end with 0.08, achieving the highest value 0.21
atMinConf = 0.1.
The average F-measure of1-stepprediction is 1.7 times higher
than that of 2-stepprediction (0.48 vs. 0.28), and 3.4 times higher
thanthatof 3-stepprediction(0.48vs.0.14).The F-measure valuesof
2-steppredictionareslightlyhigherthanthoseof 3-steppredictions.
Thus,1-stepprediction significantly outperforms 2-stepand3-step
predictions.Precision and Recall.
Figure 8 presents the resulting precision
and recall graphs for 1-step,2-stepand3-steppredictions. Each
pointineachcurverepresentstheaverageprecisionandrecallof
predictionresultsbasedonpatternswith MinConf rangingfrom
0.1 to 1.0. The label for each point indicates the corresponding
MinConf.
1-steppredictionachievesamaximum precision averageof0.91
whererecall= 0.38 (MinConf = 0.6).2-stepprediction achieves a
maximum precision average of 0.82 where recall= 0.14 (MinConf
=0.9).3-steppredictionachievesamaximum precision averageof
0.58 where recall= 0.05 (MinConf = 0.9).
Figure 8 shows that the precisionaverages for step-dpredictions
consistentlyincreaseandachievethemaximumvaluesatthebe-ginning, and drops sharply as the recallaverages increase. The
recallaverages increase as MinConf values increase. Overall, we
observedthat 1-steppredictionsignificantlyoutperforms 2-stepandTable3:Testsetsizesfor step-1, step-2andstep-3predictions.
Code Context Model # Connected Component #
Step-1 231 527
Step-2 165 291
Step-3 92 112
Table 4: Comparison of performance with Suade.
Our Approach Suade
PR FPR F
k= 1 0.86 0.53 0.650.23 0.17 0.20
k= 3 0.50 0.69 0.580.20 0.32 0.25
k= 5 0.36 0.74 0.490.18 0.42 0.25
3-steppredictions; MinConf canbeusedtomakeatradeoffbetween
precision and recall for the predictions.
5.3.3 RQ3.Comparisonwith Suade.Thethirdresearchquestion
askshowourapproachcomparestostate-of-the-art,represented
by theSuadealgorithm. Table4 compares the precision, recall, and
F-measure values of our approach and Suade. Our approach shows
F-measure values of 0.65, 0.58. and 0.49 when ùëò=1 ,ùëò= 3 andùëò=5 ,
respectively,significantlyoutperforming Suade(0.20,0.25and0.25).
In addition, the performance metrics of our approach and Suade
show similar tendency: as the window size ùëòincreases, precision
values decrease, but recallvalues increase.
6 DISCUSSION
Wereflectontheperformanceofourapproach,delvingintowhythe
approachperformsasitdoesandopportunitiesforimprovement.
We also consider the limitations of roles as a generalization mecha-
nismanddiscusshowourapproachdiffersfromdeveloper-oriented
recommendation tools.
6.1 Analysis of Approach
We consider how our approach performs by delving into the types
of patterns we find in the system and how those patterns affect the
performance of the approach.
Prediction Accuracy vs. Confidence. In Figure 7(a), the 1-step
prediction yields significant higher prediction accuracy when Min-
Conf=0.4.Toexplorethereason,weanalyzedthe confidence values
oftrue positive andfalse positive code elements in the prediction
results. The true positive elements achieve an average confidence
of 0.44 (Min: 0.01, Max: 1, Median: 0.38, SD: 0.31), while the false
positiveelementsachieveanaverage confidence of0.16(Min:0.01,
Max: 1, Median: 0.12, SD: 0.16). A Mann-Whitney test showed that
the distributions of confidence values aresignificantly different be-
tweentruepositive andfalsepositive codeelementsintheprediction
resultswith p<0.001(U=9289927.5 ).MinConf =0.4helpstoexclude
52% code elements from the true positives, and 92% from the false
positives in prediction results.
To achieve an acceptable level of precision, the prediction ap-
proachshouldchoosea MinConf valuethathelpstodiscriminate
817(a)1-stepprediction (b)2-stepprediction (c)3-stepprediction
Figure 7: F-measure for1-step, 2-stepand 3-steppredictions.
(a)1-stepprediction (b)2-stepprediction


(c)3-stepprediction
Figure 8: Precision and recallgraphs for 1-step, 2-stepand 3-steppredictions. Labels represent MinConf values.
between relevant and irrelevant code elements in a code context
model.
PredictionAccuracyvs.PredictionStep. Asfoundinourstudy,
step-1predictionoutperformsstep-2andstep-3predictionsinterms
ofboth recallandprecision.Wefurtherinvestigate theresultsfor
step-2 and step-3 predictions.
Ontheonehand,theinadequacyoftopologicalpatternsinstep-2
and step-3 predictions leads to low recall. The number of topologi-
calpatternsdecreasessharplyasthenumberofnodesintopological
patterns increases. Amongst the 142 discovered patterns, we ob-
served 73 2-node patterns, 45 3-node patterns, 20 4-node patterns,
and four 5-node patterns. As prediction step ùëëincreases, the num-
berofapplicablepatternsdecreases(1-step :142,2-step:69,3-step:
24).The69applicablepatternsfor 2-steppredictioncovers59%of22
stereotype roles. The coverage of stereotype roles for 24 applicable
patterns for 3-stepprediction is 32%.
Ontheotherhand,longersteppredictioninvolvesfewercode
elements in the seed as for the identical topological pattern, which
leads to low precision. For instance, a 3-node pattern (as shown in
Figure9)matchesthesubgraphswithtwocodeelementsasseedfor
1-step prediction but matches the subgraph with one code element
as a seed for 2-step prediction. The precision of the pattern differs
significantly between 1-step and 2-step predictions (0.46 vs. 0.20).
Tosupporttheformationofcodecontextmodelswith ùëëùëñùëéùëöùëíùë°ùëíùëü >
2, future studies could explore whether applying multiple 1-step
predictions can achieve an applicable level of accuracy.
Collaborator
MethodBoundary
Class
Command-Collaborator
Methoddeclares declares
Figure9:3-nodepatternapplicablefor1-stepand2-steppre-
dictions.
6.2 Roles as a Generalization Mechanism
Our approach relies on the assignment of roles to code contextmodels formed from previous tasks on the system. A limitationof our experimentation is its application to one system, which
we discuss further in Section 7. Future work needs to consider
whetherthetopologicalpatternsweidentifyandtheirfrequencyare
uniquetoasystemoroccurinsimilardistributionstoothersystem
developments. If the patterns frequently occur across systems, it
maybepossibletominepatternsononesystemthatcanthenbe
used even in new developments that do not yet have a historyto learn from. Given that the stereotypes were developed for a
paradigmofprogramming‚Äîobject-orientedprogramming‚Äîandthepatternsminedarerelativelysmall(e.g.,with2.7nodesonaverage),thereisreasontobeoptimisticthattheuseofpatternsacrosssystem
developments is possible. Future experimentation is needed to test
818thishypothesis.Intermsof 1-stepprediction,ourapproachcaptures
‚Äúassociationrules‚Äùbetweenstructurallyconnectedstereotyperoles.
6.3 Developer-oriented Recommendations
Researchers have considered a variety of ways to make recom-
mendations related to navigation for developers. These recommen-
dation approaches suggest code often navigated to next from a
given location [ 10], pre-fetch information related to likely devel-
oper queries from a given point in the code [ 8], present other code
often changed with code currently being considered [ 39], amongst
otheraids.Therearemanychallengeswithprovidingrecommen-
dations directly to developers, including capturing the developer‚Äôs
attention to provide a recommendation, gaining the trust of the de-
veloperbyprovidinggoodrecommendations,andexplainingwhya
recommendation is being made [ 25]. Muslu et al. considered some
oftheseissues,suggestingthatspeculativeanalysis,whichprojects
a recommended action, could be used to help with developer ac-ceptance of recommendations by explaining the consequence of
recommendations [ 26]. In trying to predict forward, our approach
is similar to speculative analysis. Similar to speculative analysis,
wefocusonpredictinginformationaboutactionsyettobetakento
helpinformtoolsthatmightaiddevelopment,ratherthantrying
toprovidearecommendationdirectlytoadeveloper.Bypredictingforward,wecansuggestseveralpossiblealternatives,enablingtools
that might help a developer fast forward across a number of steps
atoncethatwouldotherwisebechosenone-by-oneandpotentially
eliminate paths that are not useful. In addition, the background of
developers (e.g., experience) may affect the interaction histories,and thus future work could investigate this aspect. Future work
could also consider temporal information in the prediction.
7 THREATS TO VALIDITY
To implement our approach, we used Doxygen8to statically de-
rive structural dependencies between code elements. Doxygen‚Äôs
static analysis may overestimate these dependencies, In particular,
calling relationships may be overestimated because static analy-
sisoverestimatesthenumberoftargetmethodsforeachcallsite.
The overestimation of dependencies could lead to the discovery
of potentially non-existent patterns in actual code contexts, and
further reduce the precision of prediction approach. We also relied
onJStereoCode [22]toassignstereotypestocodeelementsacross
code context models. However, 2% of the code elements we pro-
cessedcouldnotbeassignedastereotypeduetocompilationerrors
in the source code. The missing stereotype roles would prevent us
fromfindingpotentialpatternsandpredictingcodeelementsthat
are with no stereotype roles assigned. This would reduce the recall
of prediction approach. The use of a more precise static analysis
tool and the ability to extract from git compliable code would have
reduced these errors.
A significant limitation to our exploration is the reliance on one
systemdevelopment,Mylyn.Thestructureandinteractionhistories
storedforMylynmaynotberepresentativeofotherprojects.For
instance,thedistributionofstereotyperolesreliesonthesystem
design of a project, the topological patterns may vary across dif-
ferent software projects. Mylyn is unique in having a repository of
8https://www.doxygen.nlstoredinteractionhistoriesfrommanydevelopersovermanyyears.
However, no information is directly available about the experiencelevel or other background of the developers contributing to Mylyn.
To helpunderstandthegeneralizability oftheresults,itwouldbe
helpful to explore the interaction traces from other systems stored
by other tools, such as Blaze [34].
8 CONCLUSIONS
Inthiswork,wehaveexploredhowdeveloperinteractionhistoriescanimprovetheproactiveformationofcodecontextmodels.Specif-
ically, we first learned abstract topological patterns from the code
contextmodelsininteractionhistories.Basedonthepatterns,we
proposed an approach to predict the code context model for a new
task.Theaccessedcodeelementsofthetaskareusedastheseed
of the prediction. To evaluate our approach, we used a simulation-
basedmethodtocreateseeds,bootstrappredictionswithvarious
configurations, and collect prediction results. In this experiment,
wefoundthatourapproachcanpredictcodecontextmodeleffec-
tively, achieving maximum F-measures of 0.67, 0.33 and 0.21 for1-step,2-stepand3-steppredictions, respectively. In comparison
withSuade,ourapproachachievessignificantlyhigherF-measure
(0.57over0.23onaverage).Theresultsdemonstratethatintegrat-
ing interaction histories and structural information can benefit the
proactive formation of more accurate code context models.
9 ACKNOWLEDGEMENTS
ThisresearchwassupportedbyNSERC(RGPIN-2106-03758)andthe
Australian ResearchCouncil‚Äôs Discovery EarlyCareer Researcher
Award (DECRA) (DE200100021).
REFERENCES
[1]NahlaJAbid,NataliaDragan,MichaelLCollard,andJonathanIMaletic.2015.
Usingstereotypesintheautomaticgenerationofnaturallanguagesummaries
for C++ methods. In 2015 IEEE International Conference on Software Maintenance
and Evolution (ICSME). IEEE, 561‚Äì565.
[2]NouhAlhindawi,NataliaDragan,MichaelLCollard,andJonathanIMaletic.2013.
Improvingfeaturelocationbyenhancing sourcecodewithstereotypes.In 2013
IEEE International Conference on Software Maintenance (ICSM). IEEE, 300‚Äì309.
[3]Vinay Augustine, Patrick Francis, Xiao Qu, David Shepherd, Will Snipes,
ChristophBraunlich,andThomasFritz.2015. Afieldstudyonfosteringstructural
navigation with prodet. In 2015 IEEE/ACM 37th IEEE International Conference on
Software Engineering, Vol. 2. IEEE, 229‚Äì238.
[4]Benjamin Biegel, Sebastian Baltes, Ivan Scarpellini, and Stephan Diehl. 2015.
Code Basket: Making Developers‚Äô Mental Model Visible and Explorable. In 2015
IEEE/ACM2ndInternationalWorkshoponContextforSoftwareDevelopment.IEEE,
20‚Äì24.
[5]Andrew Bragdon, Robert Zeleznik, Steven P Reiss, Suman Karumuri, William
Cheung,JoshuaKaplan,ChristopherColeman,FerdiAdeputra,andJosephJLaVi-
ola Jr. 2010. Code bubbles: a working set-based interface for code understanding
andmaintenance.In ProceedingsoftheSIGCHIConferenceonHumanFactorsin
Computing Systems. 2503‚Äì2512.
[6]Luis Fernando Cort√©s-Coy, Mario Linares-V√°squez, Jairo Aponte, and Denys
Poshyvanyk. 2014. On automatically generating commit messages via sum-marization of source code changes. In 2014 IEEE 14th International Working
Conference on Source Code Analysis and Manipulation. IEEE, 275‚Äì284.
[7]Davor Cubranic and Gail C Murphy. 2003. Hipikat: Recommending pertinentsoftware development artifacts. In 25th International Conference on Software
Engineering. IEEE, 408‚Äì418.
[8]BriandeAlwisandGailC.Murphy.2008. Answeringconceptualquerieswith
Ferret.In 30thInternationalConferenceonSoftwareEngineering(ICSE2008).ACM,
21‚Äì30.
[9]Michael J Decker, Christian D Newman, Natalia Dragan, Michael L Collard,
Jonathan I Maletic, and Nicholas A Kraft. 2018. Which Method-Stereotype
Changes are Indicators of Code Smells?. In 2018 IEEE 18th International Working
Conference on Source Code Analysis and Manipulation (SCAM). IEEE, 82‚Äì91.
819[10]Robert DeLine, Amir Khella, Mary Czerwinski, and George Robertson. 2005.
Towardsunderstandingprogramsthroughwear-basedfiltering.In Proceedingsof
the 2005 ACM symposium on Software visualization. 183‚Äì192.
[11]Natalia Dragan, Michael L Collard, and Jonathan I Maletic. 2009. Using method
stereotype distribution as a signature descriptor for software systems. In 2009
IEEE International Conference on Software Maintenance. IEEE, 567‚Äì570.
[12]Thomas Fritz, David C. Shepherd, Katja Kevic, Will Snipes, and Christoph
Br√§unlich. 2014. Developers‚Äô Code Context Models for Change Tasks. In Pro-
ceedings of the 22Nd ACM SIGSOFT International Symposium on Foundationsof Software Engineering (FSE 2014). ACM, New York, NY, USA, 7‚Äì18. https:
//doi.org/10.1145/2635868.2635905
[13]Mik Kersten and Gail C. Murphy. 2006. Using Task Context to Improve Pro-grammer Productivity. In Proceedings of the 14th ACM SIGSOFT International
SymposiumonFoundationsofSoftwareEngineering (SIGSOFT‚Äô06/FSE-14).ACM,
New York, NY, USA, 1‚Äì11. https://doi.org/10.1145/1181775.1181777
[14]Thomas D LaToza and Brad A Myers. 2011. Visualizing call graphs. In 2011 IEEE
Symposium on Visual Languages and Human-Centric Computing (VL/HCC) . IEEE,
117‚Äì124.
[15]Joseph Lawrance, Rachel Bellamy, and Margaret Burnett. 2007. Scents in pro-grams: Does information foraging theory apply to program maintenance?. In
IEEESymposiumonVisualLanguagesandHuman-CentricComputing(VL/HCC
2007). IEEE, 15‚Äì22.
[16]S.Lee,S.Kang,S.Kim,andM.Staats.2015. TheImpactofViewHistoriesonEditRecommendations. IEEETransactionsonSoftwareEngineering 41,3(March2015),
314‚Äì330. https://doi.org/10.1109/TSE.2014.2362138
[17]Boyang Li, Christopher Vendome, Mario Linares-V√°squez, and Denys Poshy-
vanyk. 2018. Aiding comprehension of unit test cases and test suites with
stereotype-based tagging. In Proceedings of the 26th Conference on Program Com-
prehension. 52‚Äì63.
[18]Mario Linares-V√°squez, Luis Fernando Cort√©s-Coy, Jairo Aponte, and Denys
Poshyvanyk.2015. Changescribe:Atoolforautomaticallygeneratingcommit
messages. In 2015 IEEE/ACM 37th IEEE International Conference on Software
Engineering, Vol. 2. IEEE, 709‚Äì712.
[19]CollinMcmillan,DenysPoshyvanyk,MarkGrechanik,QingXie,andChenFu.
2013. Portfolio: Searching for relevant functions and their usages in millionsof lines of code. ACM Transactions on Software Engineering and Methodology
(TOSEM) 22, 4 (2013), 1‚Äì30.
[20]RobertoMinelli,AndreaMocci,andMicheleLanza.2015. Iknowwhatyoudid
lastsummer-aninvestigationofhowdevelopersspendtheirtime.In 2015IEEE
23rd International Conference on Program Comprehension. IEEE, 25‚Äì35.
[21]Laura Moreno, Jairo Aponte, Giriprasad Sridhara, Andrian Marcus, Lori Pollock,
andKVijay-Shanker.2013. Automaticgenerationofnaturallanguagesummaries
for java classes. In 2013 21st International Conference on Program Comprehension
(ICPC). IEEE, 23‚Äì32.
[22]LauraMorenoandAndrianMarcus.2012. JStereoCode:AutomaticallyIdentifying
Method and Class Stereotypes in Java Code. In Proceedings of the 27th IEEE/ACM
InternationalConferenceonAutomatedSoftwareEngineering (ASE2012).ACM,
New York, NY, USA, 358‚Äì361. https://doi.org/10.1145/2351676.2351747
[23]Laura Moreno, Andrian Marcus, Lori Pollock, and K Vijay-Shanker. 2013. Jsum-
marizer: An automatic generator of natural language summaries for java classes.
In2013 21st International Conference on Program Comprehension (ICPC). IEEE,
230‚Äì232.
[24]Gail C Murphy. 2019. Beyond integrated development environments: adding
contexttosoftwaredevelopment.In 2019IEEE/ACM41stInternationalConference
on Software Engineering: New Ideas and Emerging Results (ICSE-NIER). IEEE, 73‚Äì
76.
[25]Emerson Murphy-Hill and Gail C. Murphy. 2014. Recommendation delivery:
Getting the user interface just right. Springer, 223‚Äì242.
[26]Kivan√ßMuslu,YuriyBrun,ReidHolmes,MichaelD.Ernst,andDavidNotkin.2012.
Speculative analysis of integrated development environment recommendations.
InProceedingsofthe27thAnnualACMSIGPLANConferenceonObject-Oriented
Programming,Systems,Languages,andApplications,OOPSLA2012.ACM,669‚Äì
682.
[27]ChristianDNewman,ReemSAlSuhaibani,MichaelL Collard,andJonathanI
Maletic. 2017. Lexical categories for source code identifiers. In 2017 IEEE 24th In-
ternationalConferenceonSoftwareAnalysis,EvolutionandReengineering(SANER).
IEEE, 228‚Äì239.
[28]David Piorkowski, Scott Fleming, Christopher Scaffidi, Christopher Bogart, Mar-
garet Burnett, Bonnie John, Rachel Bellamy, and Calvin Swart. 2012. Reactive
information foraging: An empirical investigation of theory-based recommender
systems for programmers. In Proceedings of the SIGCHI Conference on Human
Factors in Computing Systems. 1471‚Äì1480.
[29]Romain Robbes and Michele Lanza. 2010. Improving code completion with
program history. Automated Software Engineering 17, 2 (2010), 181‚Äì212.
[30]Martin P Robillard. 2008. Topology analysis of software dependencies. ACM
Transactions on Software Engineering and Methodology (TOSEM) 17, 4 (2008),
1‚Äì36.[31]MartinP.Robillard.2008. TopologyAnalysisofSoftwareDependencies. ACM
Trans. Softw. Eng. Methodol. 17, 4, Article Article 18 (Aug. 2008), 36 pages. https:
//doi.org/10.1145/13487689.13487691
[32]Martin P Robillard and Gail C Murphy. 2002. Concern graphs: finding anddescribing concerns using structural program dependencies. In Proceedings of
the 24th International Conference on Software Engineering (ICSE). 406‚Äì416.
[33]JonathanSillito,GailC.Murphy,andKrisDeVolder.2006. QuestionsProgram-
mers Ask during Software Evolution Tasks. In Proceedings of the 14th ACM
SIGSOFTInternationalSymposiumonFoundationsofSoftwareEngineering (SIG-
SOFT ‚Äô06/FSE-14). Association for Computing Machinery, New York, NY, USA,
23‚Äì34. https://doi.org/10.1145/1181775.1181779
[34]WillSnipes,AnilRNair,andEmersonMurphy-Hill.2014. Experiencesgamifying
developer adoption of practices and tools. In Companion Proceedings of the 36th
International Conference on Software Engineering. 105‚Äì114.
[35]Dimitri Van Heesch. 2008. Doxygen: Source code documentation generator tool.
http://www.doxygen.org. Online; accessed April 2020.
[36]AnnelieseVonMayrhauserandAMarieVans.1995. Programcomprehension
during software maintenance and evolution. Computer 28, 8 (1995), 44‚Äì55.
[37]Xifeng Yan and Jiawei Han. 2002. gSpan: graph-based substructure pattern
mining. In 2002 IEEE International Conference on Data Mining, 2002. Proceedings.
721‚Äì724. https://doi.org/10.1109/ICDM.2002.1184038
[38]Annie TT Ying, Gail C Murphy, Raymond Ng, and Mark C Chu-Carroll. 2004.
Predicting source code changes by mining change history. IEEE transactions on
Software Engineering 30, 9 (2004), 574‚Äì586.
[39]Thomas Zimmermann, Andreas Zeller, Peter Weissgerber, and Stephan Diehl.
2005. Miningversionhistoriestoguidesoftwarechanges. IEEETransactionson
Software Engineering 31, 6 (2005), 429‚Äì445.
820