Soundand Efficient ConcurrencyBugPrediction
YanCaiâˆ—
StateKey Laboratory of Computer
Science,InstituteofSoftware,Chinese
Academy of Sciences, and University
of Chinese Academy of Sciences
Beijing, China
ycai.mail@gmail.comHao Yun
StateKey Laboratory of Computer
Science,InstituteofSoftware,Chinese
Academy of Sciences, and University
of Chinese Academy of Sciences
Beijing, China
yunhao@ios.ac.cnJinqiuWang
StateKey Laboratory of Computer
Science,InstituteofSoftware,Chinese
Academy of Sciences, and University
of Chinese Academy of Sciences
Beijing, China
wangjq@ios.ac.cn
Lei Qiao
Beijing Institute of Control
Engineering
Beijing, China
fly2mars@163.comJens Palsberg
Universityof California
LosAngeles (UCLA),USA
palsberg@ucla.edu
ABSTRACT
Concurrencybugsareextremelydifficulttodetect.Recently,several
dynamictechniquesachievesoundanalysis.M2isevencomplete
for two threads. It is designed to decide whether two events can
occur consecutively. However, real-world concurrency bugs can
involvemoreeventsandthreads.Somecanoccurwhentheorder
of two or more events can be exchanged even if they occur not
consecutively.We proposea newtechnique SeqCheck tosoundly
decide whether a sequence of events can occur in a specified order.
Theorderedsequencerepresentsapotentialconcurrencybug.And
several known forms of concurrency bugs can be easily encoded
intoeventsequenceswhereeachrepresentsawaythatthebugcan
occur.Toachieveit, SeqCheck explicitlyanalyzesbranchevents
and includes a set of efficient algorithms. We show that SeqCheck
issound; anditisalsocomplete ontraces oftwothreads.
Wehaveimplemented SeqCheck todetectthreetypesofconcur-
rencybugsandevaluatediton51Javabenchmarksproducingupto
billionsofevents.ComparedwithM2andotherthreerecentsound
racedetectors, SeqCheck detected 333racesin30minutes;while
othersdetectedfrom130to285racesin6to12hours. SeqCheck
detected 20 deadlocks in 6 seconds. This is only one less than Dirk;
but Dirk spent more than one hour. SeqCheck also detected 30
atomicityviolationsin20minutes.Theevaluationshows SeqCheck
can significantly outperform existing concurrency bugdetectors.
CCS CONCEPTS
Â·Softwareanditsengineering â†’Multithreading ;Scheduling ;
Software testinganddebugging .
âˆ—Corresponding author
Permissionto make digitalor hard copies of allorpart ofthis work for personalor
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
onthefirstpage.Copyrights forcomponentsofthisworkownedbyothersthanthe
author(s)mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,or
republish,topostonserversortoredistributetolists,requirespriorspecificpermission
and/or a fee. Request permissions from permissions@acm.org.
ESEC/FSE â€™21, August 23Å›28,2021, Athens,Greece
Â©2021 Copyright heldby the owner/author(s). Publicationrightslicensed to ACM.
ACM ISBN 978-1-4503-8562-6/21/08...$15.00
https://doi.org/10.1145/3468264.3468549KEYWORDS
Concurrency bugs,data races, deadlocks,atomicity violations
ACMReference Format:
YanCai,HaoYun,JinqiuWang,LeiQiao,andJensPalsberg.2021.Sound
andEfficientConcurrencyBugPrediction.In Proceedingsofthe29thACM
JointEuropeanSoftwareEngineeringConferenceandSymposiumontheFoun-
dationsof Software Engineering (ESEC/FSE â€™21), August 23Å›28,2021, Athens,
Greece.ACM,NewYork,NY,USA, 13pages.https://doi.org/10.1145/3468264.
3468549
1 INTRODUCTION
Concurrentprogramscanexhibitdifferentthreadinterleavingsdue
to non-determinism, bringing concurrency bugs [ 33]. They can
bringharmfulresults oreven disasters [ 25,32,44].
Todetectconcurrencybugs,onepromisingdirectionwouldbea
soundpredictiveanalysis[ 24,28,29,43,55].Theyrunaconcurrent
programtogeneratetracesconsistingofdifferenttypesofevents.
They then consider the dependencies of events and model such
relationseitherasconstraints[ 24,28]ordirectedgesingraphs[ 43]
or comparable vector clocks [ 29,31,55]. And a feasible solution or
a feasible topological order or a pair of conflicting vector clocks is
takenasaproofoftheexistenceofarealconcurrencybug.Different
modelsofferdifferentabilitiesandsufferfromdifferentweaknesses.
For example, constraint-solver-based ones are able to check values
inmemoryaccessevents,producingalargerconcurrencycoverage;
but they rely on heavy constraint solvers to guarantee their sound-
ness and completeness. To be efficient, these techniques usually
analyze a segmentation (e.g., every 10k consecutive events) of a
trace[24,28].Graphbased onescanbecomplete (givenatraceof
twothreads [ 43])overfull traces,but are usually inefficient.Vector
clockbasedapproachesare efficient but often incomplete.
Thispaperfocusesonefficient,sound,andcompleteapproaches.
To the best of our knowledge, M2 [ 43] is the state-of-the-art one.
However,M2islimitedtodataracepredictiononly;ormorepre-
cisely, it is limited to predict the kinds of concurrency bugs involv-
ing two events that should occur consecutively. Data races right
fall into this category because it is defined to be two conflicting
memory accessesoftwothreads [ 29,55]that occur consecutively.
255
ESEC/FSE â€™21, August 23Å›28, 2021,Athens,Greece YanCai,HaoYun, Jinqiu Wang,Lei Qiao,andJens Palsberg
Furthermore,othertypesofconcurrencybugssuchasdeadlocks
[6], atomicity violations [ 34], and order violations [ 33] are not
limitedtotwoeventsortwothreads.Theydonotrequirethatall
involved events occur at the same time. For example, two well-
protected events can form a concurrency bug if their orders are
reversed[ 8];however,itfitspoorlywiththedefinitionofdataraces.
It seems highly nontrivial to extend M2 to support the detection of
common concurrency bugs(see Section 2).
In this paper, we address the above challenge by presenting
SeqCheck , an efficient and sound tool to analyze full traces to
detectvarioustypesofconcurrencybugs. SeqCheck iscomplete
when there are two threads. The core of SeqCheck is an algorithm
to decide whether a sequence of two (or more) events is feasible
overa given trace. Such a sequencecanvaryfordifferenttypesof
concurrency bugs but can be easily designed; it can have events
from any number ofthreads.
SeqCheck firstly calculates an event set that is necessary for
determining the feasibility ofthe sequence. Secondly, SeqCheck
constructsagraphtoreordertheeventsintheset.Itappliesfour
types of orders as edges including program orders, observation
orders(onpairsofwriteandread),lockorders,andtheordersfrom
theinputsequence. Finally,itcomputesaclosurefortheseorders
onthegraph.Ifnocycleisfoundintheprocess, SeqCheck soundly
decides that the sequenceisfeasible indicating atrue bug.
SeqCheck isinspiredbyM2[ 43];however,theessentialdiffer-
encebetweenthemisthatM2targetsdecidingwhethertwoevents
can be reordered one after another; whereas SeqCheck targets
deciding whether a sequence of events in a specified order is feasi-
ble,nomatterwhethertheycanoccurconsecutively.Note,iftwo
events can occur consecutively, they are exchangeable; but two
exchangeable events may be unable to occur consecutively. As a
result, M2produces asubsetofthat of SeqCheck .
Toachievetheabovegoal, SeqCheck considersbranchevents.
Besides,forapotentialconcurrencybugwithmorethantwoevents
that have multiple ways to occur, SeqCheck natively supports
a "divide-and-conquer" manner to decide it. That is, SeqCheck
can decide a potential concurrency bug to be true if it decides
thatanysequence(correspondingtoauniquewayforthebugto
occur)isfeasibleinatrace.Instead,ifanytwoeventsofasequence
canoccurconsecutivelyindifferenttraces,M2cannotdecidethat
thesequencecanbefeasibleinthesametrace.Weshowthatthe
algorithm SeqCheck isğ‘‚(ğ‘›2Ã—ğ‘™ğ‘œğ‘”(ğ‘›))whereğ‘›is the number of
events.Andwe presentaproofto show that SeqCheck issound
andisalsocomplete when there are twothreads.
We have implemented SeqCheck for Java programs to detect
general concurrency bugs. We selected two sets of previously used
Java benchmarks with 31 from [ 3,37,43] and 20 from [ 27,28].
They produced traces up to millions or even billions of events.
On detecting data races and atomicity violations, we compared
SeqCheck with (1) M2 and other three sound algorithms SHB,
WCP, SyncP [ 37] and with AtomFuzzer [ 41] on the first set of
benchmarks, respectively. On detecting deadlocks, we compared
SeqCheck with (2) Dirk (a sound deadlock prediction tool) on the
secondsetofbenchmarks.
Theexperimentshowsthat SeqCheck significantlyoutperformed
othersonbotheffectivenessandefficiency.Onracedetection, Se-
qCheckdetected 333 races in 30 minutes; the others detected from130to285racesinatleast6hours.Thelatterfourreachedourtime
limit(1hour)onalmostalllarge-scalebenchmarks.Ondeadlock
detection, SeqCheck detected 20 ones in 6 seconds; this number
is only 1 less than that by the constraint-solver-based Dirk (that
are expected to detect more than ours). However, Dirk spent >1
hour.SeqCheck detected30 atomicity violations in the first set of
benchmarks whereas AtomFuzzer detectednone orcrashed.
In summary,we make the following contribution:
â€¢Weproposeadynamic approach SeqCheck thatmodelspro-
gram branchesand predictsthe feasibilityofeventsequences.
Thus,weturnthedetectionofconcurrencybugsintoaques-
tionoffeasibilityofaneventsequence.Andweproposehow
to detectthree types of concurrency bugs.
â€¢We present an analysis to show that SeqCheck is sound and
is also complete when thereareonlytwothreads, andfurther
showSeqCheck has atime complexityof ğ‘‚(ğ‘›2Ã—ğ‘™ğ‘œğ‘”(ğ‘›)).
â€¢Wehaveimplemented SeqCheck andcompareditwithseveral
recentsoundworks.Anexperimentconfirmsthat SeqCheck
issignificantly more efficient andeffective thanothers.
2 PRELIMINARIES AND MOTIVATIONS
2.1 Basic Definitions
Thissectiondescribesasetofdefinitionsandnotationsaboutse-
quentially consistency memory models [ 30] that are similar to
definitionsfoundinprevious papers [ 28,29,43].
Execution trace . An (execution) trace ğœrepresents a lineariza-
tionofamultithreadedprogramexecution.Itisatotallyordered
listofitsevents,forwhichtheorderisdenotedby â‰ºğœ.For atrace
ğœ,we useT(ğœ)todenote thenumberofthreadsintrace ğœ,and use
ğœğ‘¡to denote the projection of ğœon thread ğ‘¡âˆˆT(ğœ). Each event
ğ‘’âˆˆğœhas a thread ID and a event ID, which can be extracted by
tid(ğ‘’)/ğ‘’ğ‘–ğ‘‘(ğ‘’).tid(ğ‘’)denotes the thread which ğ‘’belongs.ğ‘’ğ‘–ğ‘‘(ğ‘’)
denotesthe index of ğ‘’inğœtid(ğ‘’).
There are three categories of events (other synchronization
eventscan be handledsimilarly[ 24,28,43]):
â€¢Memory event: write/read , denoted by ğ‘¤ğ‘Ÿ(ğ‘¡,ğ‘¥)/ğ‘Ÿğ‘‘(ğ‘¡,ğ‘¥,ğ‘¤),
indicates a thread ğ‘¡writes to a (memory) location ğ‘¥, or read
from a location ğ‘¥where the last write event to ğ‘¥isğ‘¤andğ‘¤
can beâˆ….
â€¢Lock event: acquire/release , denoted by ğ‘ğ‘ğ‘(ğ‘¡,ğ‘™)/ğ‘Ÿğ‘’ğ‘™(ğ‘¡,ğ‘™),
indicates a thread ğ‘¡acquires or releases a lock ğ‘™. Other implicit
synchronizationscan be treatedbasedonthis twoevents.
â€¢branch, denoted by ğ‘ğ‘Ÿ(ğ‘¡), indicates there isanother path that
isnotfollowedbythread ğ‘¡.Note,thisincludesboththeexplicit
conditionalbranchesandtheimplicitbranches(methodcalls,
memoryusage)inobject-orientedprogramminglanguages[ 28].
We denote the set of event types as {ğ‘¤ğ‘Ÿ,ğ‘Ÿğ‘‘,ğ‘ğ‘ğ‘,ğ‘Ÿğ‘’ğ‘™,ğ‘ğ‘Ÿ}and use
ğ‘œğ‘(ğ‘’)toextractthetypeofanevent ğ‘’.Wesupposethateachthread
startsandends withabranchevent âˆ…ğ‘†andâˆ…ğ¸,respectively.
Intherestofthispaper,wemayomitthethreadIDofaneventor
thewriteeventinareadeventifthereisnoambiguityinthecontext.
Weassumethatlock acquire/releaseeventsarewell-nested,i.e.,if
athreadhasacquiredmultiplelocksatatime,thecorresponding
lockrelease eventsmustbe inthe nestedmanner.
256SoundandEfficient Concurrency BugPrediction ESEC/FSE â€™21, August 23Å›28, 2021,Athens,Greece
We define a set of auxiliary functions. For a memory/lock event
ğ‘’, we useloc(ğ‘’)to get its location/lock. We denote the set of all
locations of a trace ğœasLğœ. For a read event ğ‘’, we useobsğœ(ğ‘’)and
obsğ‘‹(ğ‘’)to denote the involved write event in a trace ğœor a set
ofevents ğ‘‹.Foralockacquire/releaseevent ğ‘’,weusematchğœ(ğ‘’)
to denote the correspondingpaired lock release/acquire event. We
uselastğ‘œğ‘
ğ‘¥(ğ‘’)andnextğ‘œğ‘
ğ‘¥(ğ‘’)to denote the most recent event that
operates on ğ‘¥before and after ğ‘’in program order, respectively,
whereğ‘œğ‘âˆˆ{ğ‘¤ğ‘Ÿ,ğ‘Ÿğ‘‘,ğ‘ğ‘ğ‘,ğ‘Ÿğ‘’ğ‘™,ğ‘ğ‘Ÿ}, whereğ‘¥andğ‘œğ‘can be omitted
indicating any eventtype andany location, respectively.
We useEğœandEğ‘‹to denote all events in a trace ğœand all
events in a set ğ‘‹, respectively. And we use Eğ‘Ÿğ‘‘
ğ‘‹,Eğ‘¤ğ‘Ÿ
ğ‘‹,Eğ‘ğ‘ğ‘
ğ‘‹,Eğ‘Ÿğ‘’ğ‘™
ğ‘‹to
denotethesetofallreadevents,allwriteevents,alllockacquire
events, and all lock release events in ğ‘‹, respectively. We define
the[]operation on them as the projection on a location/lock, e.g.,
Eğ‘Ÿğ‘‘
ğ‘‹[ğ‘¥]={ğ‘’âˆˆEğ‘Ÿğ‘‘
ğ‘‹|loc(ğ‘’)=ğ‘¥}.
Two events ğ‘’1andğ‘’2from different threads are conflicting ,
denoted as ğ‘’1âˆğ‘’2if: (1) they are memory events on the same
location and at least one of them is a write event; or (2) they are
lock eventsand have the same lock. We use ğ¶ğ‘œğ‘›ğ‘“ğ‘†ğ‘’ğ‘¡(ğ‘‹,ğ‘’)to find
theconflictingeventof ğ‘’inaneventset ğ‘‹(Weonlyusethisfunction
when there isonly one conflicting eventin ğ‘‹).
Forsimplicity,weviewasequenceofevents ğœŒ=âŸ¨ğ‘’1,ğ‘’2,Â·Â·Â·ğ‘’ğ‘›âŸ©
asanarray(e.g., ğœŒ[1]referstoğ‘’1).Asequence ğœŒâ€²isareadvariant
of another sequence ğœŒ, denote as ğœŒâ‰ƒğœŒâ€²if|ğœŒ|=|ğœŒâ€²|and, for
1â‰¤ğ‘–â‰¤|ğœŒ|, we have either ğœŒ[ğ‘–]=ğœŒâ€²[ğ‘–]orğœŒ[ğ‘–]=ğ‘Ÿğ‘‘(ğ‘¡,ğ‘¥,ğ‘¤)âˆ§
ğœŒâ€²[ğ‘–]=ğ‘Ÿğ‘‘(ğ‘¡,ğ‘¥,ğ‘¤â€²).Asequence ğœŒisw-rconsistent if,foranyits
read event ğ‘’=ğ‘Ÿğ‘‘(ğ‘¡,ğ‘¥,ğ‘¤),ğ‘¤is identical to the most recent write
event onğ‘¥beforeğ‘’inğœŒ. That is, a read event always reads a value
fromthelatestwriteeventtothelocation.Aprefixofasequence
ğœŒ=âŸ¨ğ‘’1,ğ‘’2,Â·Â·Â·ğ‘’ğ‘›âŸ©isasequence ğœŒâ€²=âŸ¨ğ‘’1,ğ‘’2,Â·Â·Â·ğ‘’ğ‘–âŸ©where1â‰¤ğ‘–â‰¤ğ‘›
orğœŒâ€²=âˆ…. We denote the set of all prefixes of ğœŒasprefix(ğœŒ). Note
that atrace ğœisalsoregardas an eventsequence.
2.2 Orders
Given atrace ğœ,we definethree basic types oforders:
â€¢Programorderâ‰ºğ‘ƒğ‘‚.âˆ€ğ‘’1,ğ‘’2âˆˆEğœ:tid(ğ‘’1)=tid(ğ‘’2)âˆ§ğ‘’1â‰ºğœ
ğ‘’2â‡’ğ‘’1â‰ºğ‘ƒğ‘‚ğ‘’2(i.e.,among thread local events).
â€¢Observation order â‰ºğ‘‚ğ‘‚. Letğ‘‹=Eğœ,âˆ€ğ‘’âˆˆEğ‘Ÿğ‘‘
ğ‘‹:ğ‘’=ğ‘Ÿğ‘‘(ğ‘¡,ğ‘¥,
ğ‘¤)â‡’ğ‘¤â‰ºğ‘‚ğ‘‚ğ‘’.
â€¢Lock orderâ‰ºğ¿ğ‘‚. Letğ‘‹=Eğœ,âˆ€ğ‘’1,ğ‘’2âˆˆ Eğ‘ğ‘ğ‘
ğ‘‹:ğ‘’1âˆğ‘’2â‡’
matchğœ(ğ‘’1)â‰ºğ¿ğ‘‚ğ‘’2âˆ¨matchğœ(ğ‘’2)â‰ºğ¿ğ‘‚ğ‘’1.
2.3 Motivations
M2 [43] is a sound predictive technique for race detection and is
alsocompletewhenthereareonlytwothreads.Forapairofconflict
events(ğ‘’1,ğ‘’2), M2 firstly builds a graph where vertexes are events
that may affect the execution of ğ‘’1andğ‘’2and edges are defined
as three types of orders. M2 then applies a closure algorithm on
thegraph.Afterthat,ifthereisnocycleformed,M2decidesthat
the two events can occur at the same time and they form a race.
Otherwise,itmakesnodecision(unlessthe tracehastwothreads
and,inthiscase,M2decidesthatthetwoeventsdonotformarace).
M2decideswhethertwoeventscanoccurconsecutivelytodetect
races. Even if it can be extended to further check whether more
events from different threads can occur consecutively, detectingt1t2
1 acq(l)
2 rd(y)
3 wr(x)
4 rel(l)
5acq(l)
6rd(x)
7wr(x)
8rel(l)
9wr(y)t1t2
sync(l)
{x++;}
y=0;sync(l)
{x=y;}
Figure 1:Atrace (right)oftwothreads(left).
commonconcurrencybugsrequirestodeterminewhetheranorder
of two or more events can be reordered. This cannot be resolved
byM2.Letâ€™s discuss this point.
Figure1showstwothreadsandonetracewherethread ğ‘¡1exe-
cutesafterthread ğ‘¡2.Letâ€™sdenoteeacheventinthetracebytheir
line numbers. M2â€™s purpose is to check whether ğ‘’2andğ‘’9is a race.
M2 firstly computes a set of dominating orders. For ğ‘’2, the set
is empty as no event before it can affect the execution of ğ‘’2. For
ğ‘’9, eventğ‘’6dominates it where ğ‘’6reads a value on ğ‘¥written by
ğ‘’3. Similarly, we have that ğ‘’3is dominated by ğ‘’2. As a result, the
setdominating ğ‘’9containsğ‘’2.Thisindicatesthatthetwocannot
execute consecutively. M2 decides that they do not form a race.
Obviously,thisconclusionisfalsegiventhatthetracestemsfrom
the code onthe left.
Next,supposethatM2isextended todeterminetheorders,say
whethertheexecutionorderfrom ğ‘’2toğ‘’9canbereversedintothat
fromğ‘’9toğ‘’2inanalternativeexecution.Obviously,thistargeted
order and the concluded dominating order (i.e., ğ‘’2dominates ğ‘’9)
together form a cycle. As a result, M2 decides that the target order
cannot be reversed. However, it is obvious again that the target
(fromğ‘’9toğ‘’2) order isfeasible inadifferenttrace.
ThereasonfailingM2ontheabovetwoexamplesisatitsexecu-
tionmodel.M2followsthemodel[ 29,36,55]thatrequires:every
read event in an inferred (partial) execution should read a value
written by the same write event as the original trace; any other
inferred (partial) execution violating it is unsound (i.e., not guar-
anteed to be feasible). That is, the model implicitly assumes that
any read event is followed by a branch; and reading a value from a
differentwriteeventmayproduce executiondivergence.
TomakeM2workableintheaboveexample, branches mustbe
explicitly considered. Actually, some constraint-based approaches
alreadyconsiderbranches[ 24,28]wheretheyrequire:areadevent
shouldreadthesamevalue(thatcanbefromdifferentevents)as
that in the original execution, and any violation to it may produce
an infeasible trace. This results in a huge search space for large-
scaleprogramsandconstraint-solverscanbeinefficientonthem
[24,28].Besides,itisdifficulttoconsiderconstraints(e.g.,thelogic
operations like "OR") for graph-basedapproacheslike M2.
SupposeM2isadaptedtorecognizebrancheventsandcheckthe
aboveorderreversingproblem.Then,therearefourbranches(right
before andright after eachof thetwo events) tobe analyzed. One
adaptionforM2istoinferracesfortwoeventsthroughdeciding
whether any two branches can be executed consecutively. This
requires an analysis on the four pairs of branches. However, the
twoareinconsistent,i.e.,whetherthetwobranchescanbeexecuted
consecutivelyandwhether the twoeventscan form arace.
257ESEC/FSE â€™21, August 23Å›28, 2021,Athens,Greece YanCai,HaoYun, Jinqiu Wang,Lei Qiao,andJens Palsberg
Forexample,Figure 2showsatrace ğ›¿includingbranchevents.
For the two events ğ‘’12andğ‘’6, the adapted M2 can decidethat two
branchesbeforethem(i.e., ğ‘’11andâˆ…ğ‘†)cannotexecuteconsecutively
duetothewrite-readorderfrom ğ‘’7toğ‘’10;moreover,thetwoevents
cannotformaraceforthesamereason.Now,suppose ğ›¿â€²isanother
tracewhichisthesameas ğ›¿exceptthatweswap ğ‘’6andğ‘’7,namely
ğ‘’â€²
6=ğ‘¤ğ‘Ÿ(ğ‘¥)andğ‘’â€²
7=ğ‘¤ğ‘Ÿ(ğ‘)inğ›¿â€². Now, considering the two events
ğ‘’12andğ‘’â€²
7.TheadaptedM2candecidethatthetwobranchesbefore
them(i.e., ğ‘’11andâˆ…ğ‘†)cannotexecuteconsecutivelyduetowrite-
readorderfrom ğ‘’â€²
6toğ‘’10;but,thistime,thetwoeventsindeedform
a race. We can see from these two cases that there is no consistent
conclusion on whether a race can be decided by deciding whether
the involved branches can be executed consecutively. We can also
drawthesameconclusiononothercases(e.g.,thebranchbefore
one eventandthe branchafter the secondevent).
Anotherlimitation isthatM2isnot designedforcheckingmul-
tipleeventsfromtwoormorethreads.Saythatwewanttocheck
whetherthethreeevents ğ‘’6,ğ‘’12,ğ‘’18inFigure 2canexecuteinthe
order:ğ‘’6,ğ‘’18,ğ‘’12(this pattern can be a concurrency null pointer
exception[ 8]).IfM2isadaptedtodecidewhethereachtwoofthem
canform arace,itwillbechallengingto provethe correctnessbe-
cause each isolated conclusion is drawn under different conditions
(e.g.,write-read orders).
3 OURAPPROACH
Wefirstpresentasetofdefinitionsandthenpresentouralgorithms
to check the feasibility of an event sequence. We use the trace ğ›¿
andthe sequence ğœŒ=âŸ¨ğ‘’6,ğ‘’18,ğ‘’12âŸ©inFigure 2to illustrate them.
3.1 Feasible Sets
Open lock set. Given a set ğ‘‹âŠ‚Eğœof a trace ğœand an event
ğ‘’âˆˆEğ‘ğ‘ğ‘
ğ‘‹, ifmatchğœ(ğ‘’)âˆ‰ğ‘‹, we sayğ‘’an open lock event. We use
ğ‘‚ğ‘ğ‘’ğ‘›(ğ‘‹)todenotethesetofallopenlockeventsin ğ‘‹.Forexample,
letğ‘‹={ğ‘’15âˆ’20}ontraceğ›¿; we have ğ‘‚ğ‘ğ‘’ğ‘›(ğ‘‹)={ğ‘’15,ğ‘’19}.
Producible set (PSet). Given an event set ğ‘‹âŠ‚Eğœof a trace
ğœand a set ğ‘ŒâŠ†ğ‘‹, we define a Producible set (orPSetfor short)
PSet(ğ‘‹|ğ‘Œ)=ğ‘ƒ1âˆªğ‘ƒ2,where:
â€¢ğ‘ƒ1=ğ‘‹\Eğ‘Ÿğ‘‘
ğ‘Œ,and
â€¢ğ‘ƒ2={ğ‘’â€²|ğ‘’â€²=ğ‘Ÿğ‘‘(ğ‘¡,ğ‘¥,ğ‘¤â€²)âˆ§ğ‘Ÿğ‘‘(ğ‘¡,ğ‘¥,ğ‘¤)âˆˆEğ‘Ÿğ‘‘
ğ‘Œâˆ§ğ‘¤â€²âˆˆEğ‘¤ğ‘Ÿ
ğ‘‹[ğ‘¥]}
Intuitively, PSet(ğ‘‹|ğ‘Œ)haveexactlythesamesetofeventswith
ğ‘‹except that some of its read events have different but valid write
events(note,in ğ‘ƒ2,ğ‘¤â€²canbethesameasthatin ğ‘’).Inparticular,if
ğ‘Œ=âˆ…,we have PSet(ğ‘‹|ğ‘Œ)=ğ‘‹=ğ‘ƒ1andğ‘ƒ2=âˆ….
For the running example, let ğ‘‹={ğ‘’1âˆ’17,ğ‘’18=ğ‘Ÿğ‘‘(ğ‘,ğ‘’12)}and
ğ‘Œ={ğ‘’18=ğ‘Ÿğ‘‘(ğ‘,ğ‘’12)}inğ›¿; the setğ‘‹1={ğ‘’1âˆ’17,ğ‘’â€²
18=ğ‘Ÿğ‘‘(ğ‘,ğ‘’6)}is
aPSetofğ‘‹buttheset ğ‘‹2={ğ‘’1âˆ’17,ğ‘’â€²
18=ğ‘Ÿğ‘‘(ğ‘,ğ‘’4)}isnotaPSetof
ğ‘‹as the event ğ‘’6isinEğ‘¤ğ‘Ÿ
ğ‘‹[ğ‘]={ğ‘’6,ğ‘’12}but the event ğ‘’4isnot.
The reason for introducing the set ğ‘ŒâŠ†ğ‘‹is that we consider
branch events explicitly. Hence, there should be a cut over a set
ofeventssuchthat(1)allreadeventsinonepartshouldreadthe
samevaluesasthatintheoriginaltracebut(2)somereadevents
in another part can read different values as long as they do not
produce executiondivergence.We willdefinesuch a ğ‘Œlater.
To correlate events in the two sets ğ‘‹andPSet(ğ‘‹|ğ‘Œ), we use
ğ‘ (ğ‘’â€²),foranyevent ğ‘’â€²âˆˆPSet(ğ‘‹|ğ‘Œ),todenoteitsoriginalevent ğ‘’in
ğ‘‹.Notice that, for an event ğ‘’âˆˆPSet(ğ‘‹|ğ‘Œ),ifğ‘’âˆˆğ‘ƒ1,thenğ‘ (ğ‘’)=ğ‘’.t1t2t3
1 acq(l2)
2 wr(x)
3 rel(l2)
4 wr(y)
5 acq(l2)
6 wr(p)
7 wr(x)
8 rel(l2)
9acq(l1)
10rd(x)
11br
12wr(p)
13wr(y)
14rel(l1)
15 acq(l1)
16 rd(x)
17 br
18 rd(p)
19 acq(l2)
20 rd(y)
21 rel(l2)
22 rel(l1)
Figure 2: A trace ğ›¿and a sequence of events ğœŒ=âŸ¨ğ‘’6,ğ‘’18,ğ‘’12âŸ©.
Givenğ‘‹âŠ‚Eğœin a trace ğœ, letğ‘ŒâŠ†ğ‘‹andğ‘‹â€²=PSet(ğ‘‹|ğ‘Œ), we
say thatğ‘‹â€²isaFeasible Set (orFSetfor short)if itsatisfies:
â€¢Program orderclosed (orprefix closed ):âˆ€ğ‘’â€²
1âˆˆğ‘‹â€²,âˆ€ğ‘’2âˆˆğ‘‹,
ifğ‘’2â‰ºğ‘ƒğ‘‚ğ‘ (ğ‘’â€²
1),thenâˆƒğ‘’â€²
2âˆˆğ‘‹â€²âˆ§ğ‘ (ğ‘’â€²
2)=ğ‘’2.
â€¢Observation feasible :âˆ€ğ‘’â€²=ğ‘Ÿğ‘‘(ğ‘¡,ğ‘¥,ğ‘¤â€²)âˆˆEğ‘Ÿğ‘‘
ğ‘‹â€², we have ğ‘¤â€²âˆˆ
ğ‘‹â€².
â€¢Lock feasible : (1)âˆ€ğ‘’âˆˆEğ‘Ÿğ‘’ğ‘™
ğ‘‹â€², we have matchğœ(ğ‘’)âˆˆğ‘‹â€²and
(2)âˆ€ğ‘’ğ‘ğ‘ğ‘1,ğ‘’ğ‘ğ‘ğ‘2âˆˆ Eğ‘ğ‘ğ‘
ğ‘‹â€²âˆ§ğ‘’ğ‘ğ‘ğ‘1â‰ ğ‘’ğ‘ğ‘ğ‘2, ifmatchğœ(ğ‘’ğ‘ğ‘ğ‘1)âˆ‰
ğ‘‹â€²âˆ§matchğœ(ğ‘’ğ‘ğ‘ğ‘2)âˆ‰ğ‘‹â€²,thenloc(ğ‘’ğ‘ğ‘ğ‘1)â‰ loc(ğ‘’ğ‘ğ‘ğ‘2).
ThedefinitionofFSetrestrictsasettobefeasiblebyconsider-
ing program orders, observation orders, and lock orders. For the
running example, let ğ‘‹=Eğ›¿andğ‘Œ={ğ‘’4âˆ’8,ğ‘’12âˆ’14,ğ‘’18âˆ’22}, then
we haveğ‘‹â€²={ğ‘’1âˆ’17,ğ‘Ÿğ‘‘(ğ‘,ğ‘’6),ğ‘’19,ğ‘Ÿğ‘‘(ğ‘¦,ğ‘’4),ğ‘’21âˆ’22}isaFSet of ğ‘‹.
3.2 Feasible Traces
Givenanexecutiontrace ğœ,wesaythataneventsequenceover Eğœ,
denotedas ğœâ€²,isafeasible trace if :
(1)ğœâ€²âˆˆprefix(ğœ),or,
(2)ğœâ€²=ğœâ€²â€²Â·ğ‘’whereğœâ€²â€²isfeasibleand ğœâ€²isw-rconsistent,and
the following three conditions are satisfied:
(a)letğ‘¡=tid(ğ‘’),ğ‘ğ‘Ÿ=lastğ‘ğ‘Ÿ(ğ‘’)âˆˆEğœâ€²
ğ‘¡,andğœâ€²â€²=ğœâ€²â€²â€²Â·ğ‘ğ‘ŸÂ·ğœƒâ€²â€²â€²,
thenâˆƒğœƒsuch that ğœâ€²â€²â€²
ğ‘¡Â·ğ‘ğ‘ŸÂ·ğœƒâˆˆprefix(ğœğ‘¡)âˆ§ğœƒâ€²â€²â€²
ğ‘¡Â·ğ‘’â‰ƒğœƒ.
(b)ğ‘œğ‘(ğ‘’)=ğ‘ğ‘ğ‘,thenâˆ\exâŸ©stsğ‘’â€²âˆˆğ‘‚ğ‘ğ‘’ğ‘›(Eğœâ€²â€²)âˆ§loc(ğ‘’â€²)=loc(ğ‘’).
(c)ğ‘œğ‘(ğ‘’)=ğ‘Ÿğ‘’ğ‘™,thenâˆƒğ‘’â€²âˆˆğ‘‚ğ‘ğ‘’ğ‘›(Eğœâ€²â€²
ğ‘¡)âˆ§loc(ğ‘’â€²)=loc(ğ‘’).
The condition 2arequires that the appended event ğ‘’must be
exactlythenexteventof ğ‘¡except,ifitisareadeventandthereis
nobrancheventafter it,itcan read differentbut valid values.
3.3 Feasible PartialOrders
AFSetcanbelinearizedintoaneventsequence.However,sucha
sequence is not guaranteed to be a feasible trace defined in the last
subsection. This section defines a set of necessary partial orders
such that, if a sequence is linearized from a FSet by reserving all
partialorders over the set,then itisafeasible trace.
Givenatrace ğœandapartialorder ğ‘ƒoveraFSet ğ‘‹â€²=PSet(ğ‘‹|ğ‘Œ)
whereğ‘‹âŠ‚Eğœandğ‘ŒâŠ†ğ‘‹, we sayğ‘ƒis atrace-respecting partial
orderoverğ‘‹â€²if:(1)ğ‘ƒrefinestheprogramorderin ğœwhenrestricted
258SoundandEfficient Concurrency BugPrediction ESEC/FSE â€™21, August 23Å›28, 2021,Athens,Greece
e1
raw
e2
(a)w'
w'w
r
e1 e2
(b)acq1
rel2rel1acq2
e1e2
(c)
ğ’‚ğ’„ğ’’ğ’ğŸ
ğ’‚ğ’„ğ’’ ğ’ğŸ
ğ’‚ğ’„ğ’’ ğ’ğŸ
ğ’‚ğ’„ğ’’ğ’ğŸbrbr
Figure 3:Anillustrationon theobservation closure.
toeventsin ğ‘‹â€²,(2)foreveryreadevent ğ‘Ÿâˆˆğ‘‹â€²,ifğ‘Ÿâˆˆğ‘‹\ğ‘Œwehave
obsğ‘‹â€²(ğ‘Ÿ)â‰ºğ‘ƒğ‘Ÿ,and(3)foreverylockacquireevent ğ‘’ğ‘ğ‘ğ‘âˆˆEğ‘‹â€²such
thatmatchğœ(ğ‘’ğ‘ğ‘ğ‘)âˆ‰ğ‘‹â€²and for every lock release event ğ‘’ğ‘Ÿğ‘’ğ‘™âˆˆğ‘‹â€²,
ifğ‘’ğ‘Ÿğ‘’ğ‘™âˆğ‘’ğ‘ğ‘ğ‘,thenğ‘’ğ‘Ÿğ‘’ğ‘™â‰ºğ‘ƒğ‘’ğ‘ğ‘ğ‘.We writethat ğ‘ƒrespectsğ‘‹â€².
Trace-closedPartialOrders. Givenatrace ğœandasetofevents
ğ‘‹âŠ‚Eğœ,letğ‘Œ={ğ‘’âˆˆğ‘‹|nextğ‘ğ‘Ÿ(ğ‘’)âˆ‰ğ‘‹}andğ‘ƒbeatrace-respecting
partialorderoverafeasiblesetofevents ğ‘‹â€²=PSet(ğ‘‹|ğ‘Œ).Wesay
thatğ‘ƒistrace-closed if itsatisfiesthe following:
â€¢Observation-closed .(1)Foreveryreadevent ğ‘Ÿ=ğ‘Ÿğ‘‘(ğ‘¡,ğ‘¥,ğ‘¤â€²)âˆˆ
Eğ‘Ÿğ‘‘
ğ‘‹â€²such that ğ‘ (ğ‘Ÿ) âˆˆğ‘Œ,âˆƒğ‘¤â€²âˆˆEğ‘¤ğ‘Ÿ
ğ‘‹â€²[loc(ğ‘Ÿ)]âˆ§ğ‘¤â€²â‰ºğ‘ƒğ‘Ÿ. (2)
For every read event ğ‘Ÿâˆˆ Eğ‘Ÿğ‘‘
ğ‘‹â€²such that ğ‘ (ğ‘Ÿ)âˆ‰ğ‘Œ, letğ‘¤=
obsğ‘‹â€²(ğ‘Ÿ)beingconflictingwith ğ‘Ÿ.Foreverywriteevent ğ‘¤â€²âˆˆ
Eğ‘¤ğ‘Ÿ
ğ‘‹â€²[loc(ğ‘Ÿ)]\{ğ‘¤},(a)ifğ‘¤â€²â‰ºğ‘ƒğ‘Ÿthenğ‘¤â€²â‰ºğ‘ƒğ‘¤;(b)ifğ‘¤â‰ºğ‘ƒğ‘¤â€²
thenğ‘Ÿâ‰ºğ‘ƒğ‘¤â€².
â€¢Lock-closed . For eventsâˆ€ğ‘’ğ‘Ÿğ‘’ğ‘™1,ğ‘’ğ‘Ÿğ‘’ğ‘™2âˆˆEğ‘Ÿğ‘’ğ‘™
ğ‘‹â€²and their matched
acquireevents ğ‘’ğ‘ğ‘ğ‘1=matchğœ(ğ‘’ğ‘Ÿğ‘’ğ‘™1)andğ‘’ğ‘ğ‘ğ‘2=matchğœ(ğ‘’ğ‘Ÿğ‘’ğ‘™2),
ifğ‘’ğ‘Ÿğ‘’ğ‘™1âˆğ‘’ğ‘ğ‘ğ‘2,thenğ‘’ğ‘Ÿğ‘’ğ‘™1â‰ºğ‘ƒğ‘’ğ‘ğ‘ğ‘2âˆ¨ğ‘’ğ‘Ÿğ‘’ğ‘™2â‰ºğ‘ƒğ‘’ğ‘ğ‘ğ‘1.
In the definition, if there is no branch event after the read event
ğ‘Ÿ, the observation-closed property requires that ğ‘Ÿcan happen after
any write event. In other case, it requires that any write should
occur either before or after both events from a pair in observation
orderâŸ¨obsğ‘‹â€²(ğ‘Ÿ),ğ‘ŸâŸ©on the same location, as shown in Figure 3(a)
and(b).ThisisdifferentfromthatofM2thatappliessameruletoall
readevents.Figure 3(a)illustratesthatanywrite ğ‘¤â€²shouldoccur
beforeğ‘¤=obsğ‘‹â€²(ğ‘Ÿ)as it alreadyoccurs before ğ‘Ÿ(due to the order
âŸ¨ğ‘’1,ğ‘’2âŸ©). Figure 3(b) illustrates the second case. The lock-closed
property requires two conflicting critical sections not overlapping.
The order of the two sections can be obtained when the order of
two events in them ( âŸ¨ğ‘’1,ğ‘’2âŸ©) is known, as illustrated in Figure 3(c).
Then, we can infer that ğ‘’ğ‘Ÿğ‘’ğ‘™1occurs before ğ‘’ğ‘ğ‘ğ‘2. Other cases ( ğ‘’1
occurs after ğ‘’ğ‘Ÿğ‘’ğ‘™1,ğ‘’2occurs before ğ‘’ğ‘ğ‘ğ‘2) have similar results.
Given a feasible set of events ğ‘‹âŠ‚Eğœfrom a trace ğœ, its FSetğ‘‹â€²
may have zero to multiple trace-closed partial orders. If it has one,
wecallthesmallesttrace-closedpartialorder ğ‘ƒastheclosureof
ğ‘‹â€²andalsosaythat ğ‘ƒisafeasiblepartialorder overğ‘‹â€².There
exists at most one smallest trace-closed partial order, which can be
provedbycontradiction[ 43].
3.4 The SeqCheck Algorithm
This section presents the detailed algorithm of SeqCheck and also
compareitwithM2. SeqCheck decidesthefeasibilityofanevent
sequence that encodes a potential concurrency bug. We allow two
kinds of ordering to be specified by an input: (1) the orders be-
tweentwoeventsinagivensequenceand(2)whetheraneventnot
fromthesequencecanoccurinbetweenanytwoeventsfromthe
sequence.The secondisreferredto as Adjacency set.
Formally, given a trace ğœ, an event sequence ğœŒ=âŸ¨ğ‘’1,ğ‘’2,...ğ‘’ğ‘›âŸ©
overaPSet,andasetofpairs A={(ğ‘’ğ‘–,ğ‘’ğ‘—)|ğ‘’ğ‘–,ğ‘’ğ‘—âˆˆEğœŒ},SeqCheckAlgorithm1: ComputePotentialFSet( ğœ,ğœŒ)
1ğ¹â†âˆ… /*Tohold aFSet candidate. */
2ğ‘€â†âˆ… /*Tomapbranch events to write events.*/
3ğ¿â†âˆ… /*Tohold aset ofopen locks.*/
4ğ‘„â†âˆ… /*Atemp queue to keep intermediate events.*/
5foreachğ‘’âˆˆEğœŒdoğ‘„.ğ‘ğ‘¢ğ‘ â„(ğ‘’)
6forğ‘–â†|EğœŒ|to1do
7ğ¿â€²â†ğ‘‚ğ‘ğ‘’ğ‘›({ğ‘’âˆˆEğœ|ğ‘’âª¯ğ‘ƒğ‘‚ğœŒ[ğ‘–]})
8foreachğ‘’ğ‘—âˆˆğ¿â€²|ğ¶ğ‘œğ‘›ğ‘“ğ‘†ğ‘’ğ‘¡(ğ¿,ğ‘’ğ‘—)âˆ‰{âˆ…,ğ‘’ğ‘—}do
9 ğ‘„.ğ‘ğ‘¢ğ‘ â„(matchğœ(ğ‘’ğ‘—))
10 ğ¿â€²â†ğ¿â€²\{ğ‘’ğ‘—}
11ğ¿â†ğ¿âˆªğ¿â€²
12whileÂ¬ğ‘„.ğ‘’ğ‘šğ‘ğ‘¡ğ‘¦()do
13ğµâ†âˆ…
14ğ‘’ğ‘ğ‘¢ğ‘Ÿâ†ğ‘„.ğ‘ğ‘œğ‘()
15forğ‘’âˆˆEğœ\ğ¹|ğ‘’âª¯ğ‘ƒğ‘‚ğ‘’ğ‘ğ‘¢ğ‘Ÿdo
16 ifğ‘œğ‘(ğ‘’)=ğ‘ğ‘Ÿthenğµâ†ğµâˆª{ğ‘’}
17 else ifğ‘œğ‘(ğ‘’)=ğ‘Ÿğ‘‘âˆ§nextğ‘ğ‘Ÿ(ğ‘’)â‰ âˆ…then
18 ğ‘’ğ‘â†nextğ‘ğ‘Ÿ(ğ‘’)
19 ğ‘€[ğ‘’ğ‘].ğ‘–ğ‘›ğ‘ ğ‘’ğ‘Ÿğ‘¡(obsğœ(ğ‘’))
20 else ifğ‘œğ‘(ğ‘’)=ğ‘ğ‘ğ‘then
21 Letğ‘’â€²âˆˆEğœŒ|âˆ€ğ‘’â€²â€²âˆˆEğœŒâˆ§ğ‘’â€²â€²âª¯ğ‘ƒğ‘‚ğ‘’â€²âˆ§tid(ğ‘’)=
tid(ğ‘’â€²)âˆ§tid(ğ‘’)=tid(ğ‘’â€²â€²)
22 ifğ‘’â€²=âˆ…thenğ‘„.ğ‘ğ‘¢ğ‘ â„(matchğœ(ğ‘’))
23 else ifğ‘’â€²â‰ºğ‘ƒğ‘‚ğ‘’then
24 ğ‘¥â†the index of ğ‘’â€²inğœŒ
25 foreachğ‘–â†ğ‘¥âˆ’1to1do
26 ğ¿â€²â†ğ‘‚ğ‘ğ‘’ğ‘›({ğ‘’ğ‘—âˆˆEğœ|ğ‘’ğ‘—âª¯ğ‘ƒğ‘‚ğœŒ[ğ‘–]})
27 ğ‘’ğ‘â†ğ¶ğ‘œğ‘›ğ‘“ğ‘†ğ‘’ğ‘¡(ğ¿â€²,ğ‘’)
28 ğ‘„.ğ‘ğ‘¢ğ‘ â„(matchğœ(ğ‘’ğ‘))
29 ğ‘„.ğ‘ğ‘¢ğ‘ â„(matchğœ(ğ‘’))
30 ğ¹â†ğ¹âˆª{ğ‘’}
31foreachğ‘’ğ‘–âˆˆğµdo
32 ğ‘„.ğ‘ğ‘¢ğ‘ â„(ğ‘€[ğ‘’ğ‘–])/*Push allevents mapped from ğ‘’ğ‘–. */
33 Removekey ğ‘’ğ‘–fromğ‘€
34foreachğ‘’ğ‘ŸâˆˆEğ‘Ÿğ‘‘
ğ¹|nextğ‘ğ‘Ÿ(ğ‘’ğ‘Ÿ)âˆ‰ğ¹do
35 ifnowriteeventcan be observedby ğ‘’ğ‘Ÿthen
36 ğ‘’ğ‘¤â†the first conflicting eventof ğ‘’ğ‘Ÿin thread
tid(obsğœ(ğ‘’ğ‘Ÿ))
37 ğ‘„.ğ‘ğ‘¢ğ‘ â„(ğ‘’ğ‘¤)
38returnğ¹
answerswhetherthereisafeasibletrace ğœâ€²thatsatisfies ğœŒandA,
that is: (1) for 1â‰¤ğ‘–<ğ‘—â‰¤ğ‘›, we have ğ‘’ğ‘–â‰ºğœâ€²ğ‘’ğ‘—and (2) for a pair
(ğ‘’1,ğ‘’2)âˆˆA,we haveâˆ\exâŸ©stsğ‘’âˆˆEğœâ€²such that ğ‘’1â‰ºğœâ€²ğ‘’âˆ§ğ‘’â‰ºğœâ€²ğ‘’2.
Overall,SeqCheck computes a set of events as a candidate of
FSet(Algorithm 1)andthencheckswhetherthereisasetoffeasible
partial orders over the candidate (Algorithms 2,3, and4); if so, the
eventscan be reorderedto obey the given sequenceof events.
(1) Generate a Candidate FSet. Algorithm 1computes a set
of events ğ¹as a candidate FSet. It starts from an initial set of all
events in ğœŒand iteratively includes additional events according to
the three requirements in the definition of FSet. In the iteration, ğ‘€
maps a branch event to a set of write events. That is, the key of
themapisabrancheventandthevalueisasetof write events.It
indicates that any read event before a branch event (in program
order) read a value from one of the mapped write events. Hence, if
abranchisincluded,allmappedwriteeventswillbe included.
Additionally, for any open lock event ğ‘’not from threads in ğœŒ,
the algorithm includes the release event matchğœ(ğ‘’)and all other
eventsbefore itbyprogram order.
259ESEC/FSE â€™21, August 23Å›28, 2021,Athens,Greece YanCai,HaoYun, Jinqiu Wang,Lei Qiao,andJens Palsberg
Algorithm2: ComputeLockOrders( ğœ,ğœŒ,ğ¹)
1ğ¶ğ¿ğ‘‚â†âˆ… /*Tohold ainitial setoflocksemantic orders. */
2ğ¿â†âˆ…/*Tokeep asetofintermediate open lockacquisitions.*/
3foreachğ‘–â†|EğœŒ|to1do
4ğ¿â€²â†ğ‘‚ğ‘ğ‘’ğ‘›({ğ‘’ğ‘—âˆˆEğœ|ğ‘’ğ‘—âª¯ğ‘ƒğ‘‚ğœŒ[ğ‘–]})
5ğ‘’ğ‘ğ‘¢ğ‘Ÿâ†next(ğœŒ[ğ‘–])
6whileğ‘’ğ‘ğ‘¢ğ‘Ÿâˆˆğ¹âˆ§ğ¿â€²â‰ âˆ…do
7 ifğ‘œğ‘(ğ‘’ğ‘ğ‘¢ğ‘Ÿ)=ğ‘Ÿğ‘’ğ‘™âˆ§matchğœ(ğ‘’ğ‘ğ‘¢ğ‘Ÿ)âª¯ğ‘ƒğ‘‚ğœŒ[ğ‘–]then
8 ğ‘’ğ‘â†matchğœ(ğ‘’ğ‘ğ‘¢ğ‘Ÿ)
9 ğ‘’ğ‘â†ğ¶ğ‘œğ‘›ğ‘“ğ‘†ğ‘’ğ‘¡(ğ¿,ğ‘’ğ‘)
10 ifğ‘’ğ‘â‰ âˆ…then
11 ğ¶ğ¿ğ‘‚â†ğ¶ğ¿ğ‘‚âˆª{âŸ¨ğ‘’ğ‘ğ‘¢ğ‘Ÿ,ğ‘’ğ‘âŸ©}
12 ğ¿â€²â†ğ¿â€²\{ğ‘’ğ‘}
13 else ifğ‘œğ‘(ğ‘’ğ‘ğ‘¢ğ‘Ÿ)=ğ‘ğ‘ğ‘âˆ§ğ¶ğ‘œğ‘›ğ‘“ğ‘†ğ‘’ğ‘¡(ğ¿,ğ‘’ğ‘ğ‘¢ğ‘Ÿ)=âˆ…then
14 ğ¿â€²â†ğ¿â€²âˆª{ğ‘’ğ‘ğ‘¢ğ‘Ÿ}
15 ğ‘’ğ‘ğ‘¢ğ‘Ÿâ†next(ğ‘’ğ‘ğ‘¢ğ‘Ÿ)
16ğ¿â†ğ¿âˆªğ¿â€²
17ğ¿â†ğ‘‚ğ‘ğ‘’ğ‘›(ğ¹)
18foreachğ‘’ğ‘âˆˆEğ‘Ÿğ‘’ğ‘™
ğ¹do
19ğ‘’ğ‘=ğ¶ğ‘œğ‘›ğ‘“ğ‘†ğ‘’ğ‘¡(ğ¿,ğ‘’ğ‘)
20ğ¶ğ¿ğ‘‚â†ğ¶ğ¿ğ‘‚âˆª{âŸ¨ğ‘’ğ‘,ğ‘’ğ‘âŸ©}
21returnğ¶ğ¿ğ‘‚
Table 1:State changesofAlgorithm 1on trace ğ›¿.
Line5 ğ‘„={ğ‘’6,ğ‘’18,ğ‘’12},ğ¿={},ğ¹={},ğ‘€={}
Line6Å› 11 ğ‘„={ğ‘’6,ğ‘’18,ğ‘’12,ğ‘’22},ğ¿={ğ‘’9,ğ‘’5},ğ¹={},ğ‘€={}
Line12Å› 37 ğ‘„={},ğ¿={},ğ¹={ğ‘’1âˆ’12,ğ‘’15âˆ’22},ğ‘€={(âˆ…ğ¸,{ğ‘’12âˆ’13})}
Note,inourdefinitionofFSet,therearetwoparts: ğ‘‹andğ‘Œ.The
resultğ¹is actually the ğ‘‹â€²in definition; and for any remaining key
ğ‘’ğ‘(that is not removed in line 33), all read events in between ğ‘’ğ‘
andits previous branchofthe same threads belong to ğ‘Œ.
Compared to M2 that has a RConealgorithm to find a set of
potential events starting from two given events, our algorithm
focusesonasequenceofevents.Thisbringsthefollowingmajor
differences: (1) we include all events in ğœŒ(line5) to be part of ğ¹
whereas M2 excludes the two events of a potential race; (2) we
process alleventsin ğœŒinthereverse orderasthat are expectedto
occur (line 6) whereas M2 can start from any of two events; (3) we
consider read events in two categories. For read which is followed
by branch event in ğ¹, we include the corresponding write event.
For the other case, we heuristically include some write, so that the
readeventhaveatleastonewritetoobserve.However,M2treats
readeventsthesameandincludesallwriteeventsifthereadevents
are included. The three points distinguish our algorithm from that
of M2. They allow us to model how branch events can affect trace
feasibilityandhowan eventsequencecan be considered.
On the running example, Algorithm 1runs as follows and we
show how ğ‘„,ğ¿,ğ¹, andğ‘€changes in Table 1. Recall that each
thread in ğ›¿starts and ends with a branch. The âˆ…ğ¸in Table1is the
end branch in thread ğ‘¡2. Line 5 initializes ğ‘„to include all events
inğœŒ; next, the loop at line 6 appends ğ‘’9intoğ¿in first iteration.
When processing ğ‘’18in the second iteration, ğ‘’9âˆˆğ¿is a conflicting
event ofğ‘’15andmatchğ›¿(ğ‘’15)=ğ‘’22is appended into ğ‘„; in the third
iteration, ğ‘’5isappendedinto ğ¿={ğ‘’9,ğ‘’5}.Theiterationatline12
pops all events in ğ‘„as well as other events that occurred before
theminprogramorder;theyareincludedinto ğ¹.Finally,wehave
ğ¹={ğ‘’1âˆ’12,ğ‘’15âˆ’22}.Table 2:State changesofAlgorithm 2on trace ğ›¿.
ğ¶ğ‘ƒğ‘‚={Â·Â·Â·},ğ¶ğ‘‚ğ‘‚={âŸ¨ğ‘’7,ğ‘’10âŸ©,âŸ¨ğ‘’7,ğ‘’16âŸ©},
ğ¶ğ‘†ğ‘‚={âŸ¨ğ‘’6,ğ‘’18âŸ©,âŸ¨ğ‘’18,ğ‘’12âŸ©}
Line3Å› 16 ğ¶ğ¿ğ‘‚={âŸ¨ğ‘’22,ğ‘’9âŸ©,âŸ¨ğ‘’8,ğ‘’19âŸ©},ğ¿={ğ‘’9,ğ‘’19}
Line17Å› 20 ğ¶ğ¿ğ‘‚={âŸ¨ğ‘’22,ğ‘’9âŸ©,âŸ¨ğ‘’8,ğ‘’19âŸ©},ğ¿={ğ‘’9}
(2)InitializeaSetofPartialOrders. SeqCheck nextchecks
whethertheset ğ¹canbeaFSet.Itfirstconstructsthreesetsofpartial
orders on ğ¹according to the definition of the trace-respecting
partialorders:(1)programorder ğ¶ğ‘ƒğ‘‚,(2)observationorder ğ¶ğ‘‚ğ‘‚,
(3) lock semantic order ğ¶ğ¿ğ‘‚. The program order ğ¶ğ‘ƒğ‘‚can be easily
constructedaccordingtotheoccurrenceorderofeventsfromthe
same threads in ğ¹. The observation order ğ¶ğ‘‚ğ‘‚is defined to be
{âŸ¨obsğ¹(ğ‘’),ğ‘’âŸ©|âˆ€ğ‘’âˆˆEğ‘Ÿğ‘‘
ğ¹,nextğ‘ğ‘Ÿ(ğ‘’)âˆˆğ¹}.
Thelockorder ğ¶ğ¿ğ‘‚isconstructedbyAlgorithm 2.UnlikeM2,
the lock orders consist of (1) the intra-thread lock orders among
(open) lock events for events in ğœŒ(lines of the first for-loop at line
3) and (2) the lock orders between the (open) lock event for the
eventsin ğœŒandforallothersin ğ¹(thefor-loopatline 18).Theintra
lock orders must be constructed by considering the sequence order.
Finally,SeqCheck includes the set of input orders ğ¶ğ‘†ğ‘‚inğœŒ,
whereğ¶ğ‘†ğ‘‚={âŸ¨ğ‘’ğ‘–,ğ‘’ğ‘–+1âŸ©|âˆ€ğ‘–âˆˆ{1,Â·Â·Â·,|EğœŒ|âˆ’1}}.
Table2showsthefour sets oforders (initsfirstrow)giventhe
setğ¹.Note,although ğ¹includestheevent ğ‘’20=ğ‘Ÿğ‘‘(ğ‘¦),thereisno
observation order from obsğ›¿(ğ‘’20)(i.e.,ğ‘’13) to it; this is because, by
ourdefinition,wehave nextğ‘ğ‘Ÿ(ğ‘’20)âˆ‰ğ¹.ThesecondrowinTable 2
shows thestate changesofAlgorithm 2.Fortheexample.By the
algorithm, during its second iteration (the for loop at line 3), as the
eventğ‘’15and its matching event ğ‘’22are both included in ğ¹, the
algorithm inserts a intra-thread lock order âŸ¨ğ‘’22,ğ‘’9âŸ©. In the third
iteration,theintra-threadlockorder âŸ¨ğ‘’8,ğ‘’19âŸ©isincludedduetothat
ğ‘’18ishappenedafter ğ‘’6inğœŒandaconflictpair onlock ğ‘™2exists.
(3)ComputeaClosure. Giventhefoursetsofpartialorders,
SeqCheck computes a closure according to the definition of the
trace-closed partial order as shown in Algorithm 3. Before intro-
ducingthealgorithm,wefirstintroduceagraphdatastructure[ 43].
Allpartialorders willbe representedas edges onsuch agraph.
Letğºbeadirectedacyclicgraphand ğ‘‹beasetofevents.The
vertexes of ğºconsist of all events Eğ‘‹and the edges are defined to
be asubsetofEğ‘‹Ã—Eğ‘‹.We defineasetof operations over ğº:
â€¢ğº.ğ‘–ğ‘›ğ‘ ğ‘’ğ‘Ÿğ‘¡(ğ‘’1,ğ‘’2)inserts an edgeâŸ¨ğ‘’1,ğ‘’2âŸ©intoğº.
â€¢ğº.ğ‘Ÿğ‘’ğ‘ğ‘â„(ğ‘’1,ğ‘’2)returns Trueif there isapathfrom ğ‘’1toğ‘’2.
â€¢ğº.ğ‘ ğ‘¢ğ‘ğ‘(ğ‘’,ğ‘¡)returns the earliest successor ğ‘’â€²ofğ‘’in thread ğ‘¡
whereğº.ğ‘Ÿğ‘’ğ‘ğ‘â„(ğ‘’,ğ‘’â€²)returns True.
â€¢ğº.ğ‘ğ‘Ÿğ‘’ğ‘‘(ğ‘’,ğ‘¡)returns the latest predecessor ğ‘’â€²ofğ‘’in thread ğ‘¡
whereğº.ğ‘Ÿğ‘’ğ‘ğ‘â„(ğ‘’â€²,ğ‘’)returns True.
Thesefouroperationsover ğºcanbedonewithan ğ‘‚(ğ‘›Ã—ğ‘™ğ‘œğ‘”(ğ‘›))
algorithm throughFenwick Tree [ 18], whereğ‘›=|Eğ‘‹|.
Given a trace ğœ, a graphğº, an initial set of orders ğ¶, and a adja-
cencysetA,Algorithm 3iterativelyexamineseachpartialorder
inğ¶, inserts it into ğº, and closes it according the definition of
trace-closedpartialorders.Theseareshownasfunctions InsertAnd-
Close,ObsClosure , andLockClosure . For observation-closed rule,
Algorithm 3only close the rule (2). Rule (1) will be consider in
Algorithm 4.Besides,itfurtherclosesanyadjacencyorders(lines
22Å›26). That is, for any pair of events (ğ‘’1,ğ‘’2)âˆˆA, if an event ğ‘’
260SoundandEfficient Concurrency BugPrediction ESEC/FSE â€™21, August 23Å›28, 2021,Athens,Greece
Algorithm3: CloseOrders( ğœ,ğº,ğ¶,A)
1Letğ¹â†ğº.ğ¹
2foreachğ‘¥=âŸ¨ğ‘’1,ğ‘’2âŸ©âˆˆğ¶doğ‘„ğ‘.ğ‘ğ‘¢ğ‘ â„(ğ‘¥)
3whileÂ¬ğ‘„ğ‘.ğ‘’ğ‘šğ‘ğ‘¡ğ‘¦()do
4âŸ¨ğ‘’ğ‘¥,ğ‘’ğ‘¦âŸ©â†ğ‘„ğ‘.ğ‘ğ‘œğ‘()
5ifğº.ğ‘Ÿğ‘’ğ‘ğ‘â„(ğ‘’ğ‘¦,ğ‘’ğ‘¥)then return False
6else ifÂ¬ğº.ğ‘Ÿğ‘’ğ‘ğ‘â„(ğ‘’ğ‘¥,ğ‘’ğ‘¦)thenInsertAndClose( ğ‘’ğ‘¥,ğ‘’ğ‘¦)
7returnTrue
8Function ObsClosure( ğ‘’1,ğ‘’2):
9foreachğ‘¥âˆˆ{loc(ğ‘’)|ğ‘’âˆˆEğ‘Ÿğ‘‘
ğ¹âˆªEğ‘¤ğ‘Ÿ
ğ¹}do
10 ğ‘’ğ‘¤â†lastğ‘¤ğ‘Ÿ
ğ‘¥(ğ‘’1)
11 ğ‘’ğ‘Ÿâ†nextğ‘Ÿğ‘‘ğ‘¥(ğ‘’2)
12 ifğ‘’ğ‘¤â‰ obsğœ(ğ‘’ğ‘Ÿ)âˆ§nextğ‘ğ‘Ÿ(ğ‘’ğ‘Ÿ)âˆˆğ¹then
13 ğ‘„ğ‘.ğ‘ğ‘¢ğ‘ â„(âŸ¨ğ‘’ğ‘¤,obsğœ(ğ‘’ğ‘Ÿ)âŸ©)
14 ğ‘’â€²ğ‘¤â†nextğ‘¤ğ‘Ÿğ‘¥(ğ‘’2)
15 foreachğ‘’ğ‘–âˆˆEğ‘Ÿğ‘‘
ğ¹|obsğœ(ğ‘’ğ‘–)=ğ‘’ğ‘¤âˆ§nextğ‘ğ‘Ÿ(ğ‘’ğ‘–)âˆˆğ¹do
16 ğ‘„ğ‘.ğ‘ğ‘¢ğ‘ â„(âŸ¨ğ‘’ğ‘–,ğ‘’â€²ğ‘¤âŸ©)
17Function LockClosure( ğ‘’1,ğ‘’2):
18foreachğ‘™âˆˆ{loc(ğ‘’)|ğ‘’âˆˆEğ‘ğ‘ğ‘
ğ¹âˆªEğ‘Ÿğ‘’ğ‘™
ğ¹}do
19 ğ‘’ğ‘ğ‘ğ‘â†lastğ‘ğ‘ğ‘
ğ‘™(ğ‘’1)
20 ğ‘’ğ‘Ÿğ‘’ğ‘™â†nextğ‘Ÿğ‘’ğ‘™
ğ‘™(ğ‘’2)
21 ğ‘„ğ‘.ğ‘ğ‘¢ğ‘ â„(âŸ¨matchğœ(ğ‘’ğ‘ğ‘ğ‘),matchğœ(ğ‘’ğ‘Ÿğ‘’ğ‘™)âŸ©)
22Function AdjacencyClosure( A):
23foreach(ğ‘’1,ğ‘’2)âˆˆAdo
24 foreachğ‘¡â†1ğ‘¡ğ‘œT(ğœ)do
25 ğ‘„ğ‘.ğ‘ğ‘¢ğ‘ â„(âŸ¨ğº.ğ‘ğ‘Ÿğ‘’ğ‘‘(ğ‘’1,ğ‘¡),ğ‘’2âŸ©),ğ‘„ğ‘.ğ‘ğ‘¢ğ‘ â„(âŸ¨ğ‘’1,ğº.ğ‘ ğ‘¢ğ‘ğ‘(ğ‘’2,ğ‘¡)âŸ©)
26 ğ‘„ğ‘.ğ‘ğ‘¢ğ‘ â„(âŸ¨ğº.ğ‘ğ‘Ÿğ‘’ğ‘‘(ğ‘’2,ğ‘¡),ğ‘’1âŸ©),ğ‘„ğ‘.ğ‘ğ‘¢ğ‘ â„(âŸ¨ğ‘’2,ğº.ğ‘ ğ‘¢ğ‘ğ‘(ğ‘’1,ğ‘¡)âŸ©)
27Function InsertAndClose( ğ‘’1,ğ‘’2):
28ğº.ğ‘–ğ‘›ğ‘ ğ‘’ğ‘Ÿğ‘¡(ğ‘’1,ğ‘’2)
29ObsClosure( ğ‘’1,ğ‘’2)
30LockClosure( ğ‘’1,ğ‘’2)
31forğ‘–, ğ‘—â†1toT(ğœ)|ğ‘–â‰ tid(ğ‘’1)âˆ¨ğ‘—â‰ tid(ğ‘’2)do
32(ğ‘’ğ‘ğ‘Ÿğ‘’ğ‘‘,ğ‘’ğ‘ ğ‘¢ğ‘ğ‘)â†(ğº.ğ‘ğ‘Ÿğ‘’ğ‘‘(ğ‘’1,ğ‘–),ğº.ğ‘ ğ‘¢ğ‘ğ‘(ğ‘’2, ğ‘—))
33 ğº.ğ‘–ğ‘›ğ‘ ğ‘’ğ‘Ÿğ‘¡(ğ‘’ğ‘ğ‘Ÿğ‘’ğ‘‘,ğ‘’ğ‘ ğ‘¢ğ‘ğ‘)
34 ObsClosure( ğ‘’ğ‘ğ‘Ÿğ‘’ğ‘‘,ğ‘’ğ‘ ğ‘¢ğ‘ğ‘)
35 LockClosure( ğ‘’ğ‘ğ‘Ÿğ‘’ğ‘‘,ğ‘’ğ‘ ğ‘¢ğ‘ğ‘)
36AdjacencyClosure( A)
occurs before or after one of the two event, it also occurs before or
after anotherone.Algorithm 3fails whenever itfinds acycle.
Fortherunningexample,thegiveninitialsetofordersareshown
in Figure 4(a) except the two from events of ğ‘¡2(where we do not
explicit show the program orders). The two orders are produced
by Algorithm 3. Considering that obsğ›¿(ğ‘’16)isğ‘’7and the event
ğ‘’2occurredbefore ğ‘’16byprogramorder,Algorithm 3reordersğ‘’2
beforeobsğ›¿(ğ‘’16),resultinganorder âŸ¨ğ‘’2,ğ‘’7âŸ©.Whencomputingthe
lockclosure ofthis order,an order âŸ¨ğ‘’3,ğ‘’5âŸ©isinserted.
(4) The Complete SeqCheck Algorithm. Algorithm 4de-
scribesthecomplete SeqCheck .Givenatrace ğœ,aneventsequence
ğœŒ,andanadjacencyset A,itdrivesAlgorithms 1,2,and3tofinda
closure. The order specified by the input sequence of events ğœŒis
denoted as ğ¶ğ‘†ğ‘‚. Then, Algorithm 4check if the read event (which
arenotfollowedbybrancheventin ğ¹)hasawriteeventtoobserve.
If not, it heuristically let ğ‘’ğ‘Ÿobserve the first conflicting write in
threadtid(obsğœ(ğ‘’ğ‘Ÿ))andcalculatestheclosure.Theseoperations
are according to the observation-closed rule (2). If it succeeds, it
additionallyconsidersallotherconflictingbutunorderedpairsof
events (line 9). Such pairs are inserted into ğºaccording to their
occurrence orders in ğœ. AfterSeqCheck finishes, if there is a cycle,
itreturnsâˆ…; otherwise,itreturns alinearizationofthe graph ğº.t1t2t3
1 acq(l2)
2 wr(x)
3 rel(l2)
4 wr(y)
5 acq(l2)
6 wr(p)
7 wr(x)
8 rel(l2)
9 acq(l1)
10 rd(x)
11 br
12 rd(p)
13 acq(l2)
14 rd(y)
15 rel(l2)
16 rel(l1)
17acq(l1)
18rd(x)
19br
20wr(p)t1t2t3
acq(l2)
wr(x)
rel(l2)
acq(l1) wr(y)
rd(x) acq(l2)
br wr(p)
wr(p) wr(x)
wr(y)acq(l1)rel(l2)
rel(l1)rd(x)
br
rd(p)
acq(l2)
rd(y)
rel(l2)
rel(l1)
(a) (b)
Figure 4: The closure for trace ğ›¿in (a) and one of its corre-
sponding execution in(b).
For the running example, SeqCheck produces a set of orders as
shown in Figure 4(a). As there is no cycle found and no additional
eventtobeordered,theseordersindicatethattheset ğ¹produced
byAlgorithm 2isa FSet. And itdecides that the inputsequence ğœŒ
isfeasible andFigure 4(b)showsatrace that satisfies ğœŒ.
In summary,as reflectedin Algorithms 1,2,and3,M2canonly
handleadjacencyrelations,while SeqCheck canhandlebothad-
jacencyrelationsandorderrelations.Thatis,M2canonlydetect
that events happen consecutively, while SeqCheck can detect that
eventshappeninaparticularorder,aswellasconsecutively.And
SeqCheck has anovel definitionof feasible sets.
3.5 AlgorithmAnalyses
AlgorithmTimeComplexity. SeqCheck consistsoffouralgo-
rithms. Let ğ‘›be the size of trace ğœ, the total number of events
inğœ. Algorithms 1has two major loops. In the first major loop,
theğ‘‚ğ‘ğ‘’ğ‘›()map can be initializedin ğ‘‚(ğ‘›)by scanning allevents
once.Thefunction ğ¶ğ‘œğ‘›ğ‘“ğ‘†ğ‘’ğ‘¡(ğ¿,ğ‘’)canbeimplementedin ğ‘‚(ğ‘™ğ‘œğ‘”(ğ‘›)).
The second majorloop (the ğ‘¤â„ğ‘–ğ‘™ğ‘’part) pushes eacheventatmost
onceinto ğ‘„,and allthe operationsinloop canbeimplemented in
ğ‘‚(ğ‘™ğ‘œğ‘”(ğ‘›)).So,both parts have an ğ‘‚(ğ‘›Ã—ğ‘™ğ‘œğ‘”(ğ‘›))time complexity.
InAlgorithm 2,eachfor/while-loopprocessesatmost ğ‘›events.
For each event, there is at most a call to ğ¶ğ‘œğ‘›ğ‘“ğ‘†ğ‘’ğ‘¡(ğ¿,ğ‘’). That is
ğ‘‚(ğ‘›Ã—ğ‘™ğ‘œğ‘”(ğ‘›))in time complexity. Algorithm 3computes a closure
fortheedges.Thereareatmost ğ‘›2edgesandeachisinsertedinto ğº
once.Thatis(ğ‘›2Ã—ğ‘™ğ‘œğ‘”(ğ‘›))intimecomplexity.Algorithm 4hastwo
loop,processingatmost ğ‘›2eventpairs.Foreachpair,itinsertsat
mostoneedge.Hence, SeqCheck has(ğ‘›2Ã—ğ‘™ğ‘œğ‘”(ğ‘›))timecomplexity.
Next,wegiveananalysisonthesoundnessandthecompleteness
ofSeqCheck .
Theorem 1. Soundness . Given a trace ğœ, an event sequence ğœŒ,
andanadjacencyset AoverEğœŒ,ifAlgorithm 4returnsalinearization
ğœâ€²,thenğœâ€²is afeasible tracethat satisfies ğœŒandA.
ProofSketch. Weshowthat ğœâ€²isafeasibletracebyinduction.
Letğœâ€²â€²=ğœâ€²â€²â€²Â·ğ‘’âˆˆprefix(ğœâ€²), such that ğœâ€²â€²â€²is feasible (i.e.,âˆ…in
thebasestep).Whenappending ğ‘’toğœâ€²â€²â€²,weshowbelowthatno
condition ofthe definitionof feasible traces isviolated.
261ESEC/FSE â€™21, August 23Å›28, 2021,Athens,Greece YanCai,HaoYun, Jinqiu Wang,Lei Qiao,andJens Palsberg
Algorithm4: ğ‘†ğ‘’ğ‘ğ¶â„ğ‘’ğ‘ğ‘˜ (ğœ,ğœŒ,A)
1ğ¹â†ğ¶ğ‘œğ‘šğ‘ğ‘¢ğ‘¡ğ‘’ğ‘ƒğ‘œğ‘¡ğ‘’ğ‘›ğ‘¡ğ‘–ğ‘ğ‘™ğ¹ğ‘†ğ‘’ğ‘¡ (ğœ,ğœŒ)
2ğ¶â†ğ¶ğ‘ƒğ‘‚âˆªğ¶ğ‘‚ğ‘‚âˆªğ¶ğ¿ğ‘‚âˆªğ¶ğ‘†ğ‘‚/*ğ¶ğ‘†ğ‘‚is a set of orders over ğœŒ. */
3ğºâ†(ğ¹,âˆ…)
4ifÂ¬ğ¶ğ‘™ğ‘œğ‘ ğ‘’ğ‘‚ğ‘Ÿğ‘‘ğ‘’ğ‘Ÿğ‘ (ğœ,ğº,ğ¶,A)then returnâˆ…
5foreachğ‘’ğ‘ŸâˆˆEğ‘Ÿğ‘‘
ğ¹|nextğ‘ğ‘Ÿ(ğ‘’ğ‘Ÿ)âˆ‰ğ¹do
6ifâˆ\exâŸ©stsğ‘’ğ‘¤âˆˆEğ‘¤ğ‘Ÿ
ğ¹[loc(ğ‘’ğ‘Ÿ)]âˆ§ğº.ğ‘Ÿğ‘’ğ‘ğ‘â„(ğ‘’ğ‘¤,ğ‘’ğ‘Ÿ)then
7 ğ‘’â€²ğ‘¤â†the first conflicting eventof ğ‘’ğ‘Ÿin thread
tid(obsğœ(ğ‘’ğ‘Ÿ))
8 ifÂ¬ğ¼ğ‘›ğ‘ ğ‘’ğ‘Ÿğ‘¡ğ´ğ‘›ğ‘‘ğ¶ğ‘™ğ‘œğ‘ ğ‘’(ğ‘’â€²ğ‘¤,ğ‘’ğ‘Ÿ)then returnâˆ…
9foreachunorderedpairâŸ¨ğ‘’1,ğ‘’2âŸ©âˆˆğº|ğ‘’1âˆğ‘’2âˆ§ğ‘’1â‰ºğœğ‘’2do
10ifÂ¬ğ¼ğ‘›ğ‘ ğ‘’ğ‘Ÿğ‘¡ğ´ğ‘›ğ‘‘ğ¶ğ‘™ğ‘œğ‘ ğ‘’(ğ‘’1,ğ‘’2)then returnâˆ…
11ğœâ€²â†atopological orderof ğº /*Alinearization of ğº*/
12returnğœâ€²
First, ifğ‘’is a read event, Algorithm 4initially sets an order
âŸ¨obsğœâ€²(ğ‘’),ğ‘’âŸ©,resultinginanedgefrom obsğœâ€²(ğ‘’)toğ‘’inğº;Algorithm
3ensures that any other conflicting write events are ordered either
beforeobsğœâ€²(ğ‘’)or afterğ‘’. Therefore, no other conflicting write
eventappearsinbetween obsğœâ€²(ğ‘’)andğ‘’inğœâ€².Hence,thesequence
ğœâ€²â€²â€²Â·ğ‘’isw-rconsistent.
Second, if ğ‘’is a lock acquire event, Algorithm 1ensures that
therearenotwoopenlockeventson loc(ğ‘’);Algorithm 2,3ensures
thatallotherconflictinglockreleaseoracquireeventsarebefore
ğ‘’or aftermatchğœ(ğ‘’). Ifğ‘’is not closed, they before ğ‘’. The similar
analysisapplieswhen ğ‘’isalockreleaseevent.Hence,theconditions
2band2cindefinitionoffeasible trace are not violated.
Third, Algorithm 4keeps program orders; according to Algo-
rithm1, when an event ğ‘’â€²is included, all other events occur before
ğ‘’â€²by program orderare included. Hence, we have Eğœâ€²â€²
ğ‘¡âŠ‚Eğœğ‘¡and,
the sequence ğœâ€²â€²
ğ‘¡=ğœâ€²â€²â€²
ğ‘¡Â·ğ‘’âˆˆprefix(ğœğ‘¡). And we can rewrite ğœâ€²â€²
ğ‘¡to
beğœâ€²â€²â€²
ğ‘¡Â·ğ‘ğ‘ŸÂ·ğœƒ(form in definition) that is also in prefix(ğœğ‘¡). Thus,
the condition 2aisnot violated.
Inductively, we show that ğœâ€²is a feasible trace when we have
|ğœâ€²â€²|=|ğœâ€²|.
Finally, as Algorithm 4includes the order by ğœŒand Algorithm 3
closes adjacencyorders according to A,ğœâ€²satisfiesğœŒandA.â–¡
Theorem 2. Completeness. Given a trace ğœof two threads, an
eventsequence ğœŒ,andanadjacencyset AoverEğœŒ,ifthereisafeasible
traceğœâ€²thatsatisfies ğœŒandA,Algorithm 4returnsaneventsequence.
ProofSketch. When there are two threads, the initial sets
ğ¶ğ‘ƒğ‘‚âˆªğ¶ğ‘‚ğ‘‚âˆªğ¶ğ¿ğ‘‚âˆªğ¶ğ‘†ğ‘‚,theirclosurebyAlgorithm 3,theclosure
onAare necessary orders to witness ğœŒ.
If no cycle forms after Algorithm 4in line 4, SeqCheck will
check the read events which are not followed by branch event one
byone.Becausethereareonlytwothreadsin ğœ,areadeventcan
onlyobservethewriteevent(1)beforeitinprogramorder,or(2)
intheotherthreads.Whentheline8needtobeexecuted,itmust
meet the second case. In other words, there must be no relative
writeeventbeforeitinthesamethread.So,itâ€™sadefinitecaseto
add the order, from the first conflicting write event of the other
thread to the read event.Itâ€™s anecessary order.
Then,SeqCheck checksothersunorderedpairs.Inthisproce-
dure,onlysomecriticalsectionsareunordered.Thisprocedurewill
notformcycle,asanyunorderedcriticalsectionindicatesthatthereAlgorithm5: DetectConcurrencyBugs( ğœ)
/*Detectdataraces */
1foreachpair of conflictingmemory events (ğ‘’1,ğ‘’2)do
2ğœŒâ†âŸ¨last(ğ‘’1),ğ‘’2,ğ‘’1,next(ğ‘’2))âŸ©
3Aâ†{(ğ‘’1,ğ‘’2)}
4ifğ‘†ğ‘’ğ‘ğ¶â„ğ‘’ğ‘ğ‘˜(ğœ,ğœŒ,A)â‰ âˆ…then
5 print"Adataracedetected"
/*Detectdeadlocksoftwothreads */
6foreachpotentialdeadlock(âŸ¨ğ‘ğ‘ğ‘1
ğ‘™,ğ‘ğ‘ğ‘1ğ‘šâŸ©,âŸ¨ğ‘ğ‘ğ‘2ğ‘š,ğ‘ğ‘ğ‘2
ğ‘™âŸ©)do
7ğœŒ1â†âŸ¨ğ‘ğ‘ğ‘2ğ‘š,ğ‘ğ‘ğ‘1ğ‘š,ğ‘ğ‘ğ‘2
ğ‘™âŸ©
8ğœŒ2â†âŸ¨ğ‘ğ‘ğ‘1
ğ‘™,ğ‘ğ‘ğ‘2
ğ‘™,ğ‘ğ‘ğ‘1ğ‘šâŸ©
9ifğ‘†ğ‘’ğ‘ğ¶â„ğ‘’ğ‘ğ‘˜(ğœ,ğœŒ1,âˆ…)â‰ âˆ…âˆ¨ğ‘†ğ‘’ğ‘ğ¶â„ğ‘’ğ‘ğ‘˜(ğœ,ğœŒ2,âˆ…)â‰ âˆ…then
10 print"Adeadlockdetected"
/*Detectatomicityviolationsofthe pattern Å‚w Å› wÅ› r" */
11foreachpotentialatomicity violation: (ğ‘¤1,ğ‘¤2,ğ‘Ÿ)do
12ğœŒâ†âŸ¨ğ‘¤2,ğ‘¤1,ğ‘ŸâŸ©
13ifğ‘†ğ‘’ğ‘ğ¶â„ğ‘’ğ‘ğ‘˜(ğœ,ğœŒ,âˆ…)â‰ âˆ…then
14 print"An atomicityviolation detected"
are no conflicting event pair to dominate two section. (Actually,
orderingthemisuseful for linearization.)
Finally, Algorithm 4returns a linearization of ğº, i.e., an event
sequence. â–¡
Note, if there are additional threads, there may have conflicting
criticalsectionsthatwillbeincludedbyAlgorithm 1.Ordersamong
these events may not be necessary to witness a sequence and a
cyclemaybe introduced.
4 IMPROVE PERFORMANCE
SeqCheck cansufferfromanoverheadthatstemsfromhandling
a large number of orders and event pairs in searching for any
unordered events (that are part of potential bugs). M2 adopts an
optimization to only consider pairs of conflicting events that are
neitherprotectedbycommonlocksnororderedbytrace-respecting
partial orders. The optimization is in a pre-process phase under an
ğ‘‚(ğ‘›2Ã—ğ‘™ğ‘œğ‘”(ğ‘›))(whereğ‘›isthe number of events) algorithm.
Wealsoincludeapre-processphase.However,weconstructa
graphğºâ€²to have aninitial setof program orders andobservation
orders andthen tocomputeatransitive closure(withconsidering
branches)on ğºâ€².Thenfrom ğºâ€²,wecaneasilyidentifypairsofal-
ready ordered events; and the remaining pairs are undecided. The
algorithmtoconstructthegraphis ğ‘‚(ğ‘˜2Ã—ğ‘›Ã—ğ‘™ğ‘œğ‘”(ğ‘›))intimecom-
plexity,where ğ‘˜andğ‘›arethenumberofthreadsandthenumberof
events,respectively.Moreover,pre-storingthe observationorders
andperformingan de-duplication are alsoan acceleration.
5 DETECT GENERALCONCURRENCYBUGS
ThissectionpresentsAlgorithm 5thatdrivesAlgorithm 4todetect
three types of concurrency bugs by encoding theminto sequences
ofevents.Othertypes can be implementedsimilarly.
Detect Races. A race occurs when two conflicting events oc-
curconsecutively.Ourworkdecidessequenceofeventsandcan-
not be directly used to detect races. Algorithm 5introduces two
moreevents lastğœ(ğ‘’1)andnextğœ(ğ‘’2).(Note,thesetwoeventscan
be dummy ones as long as they are right before and right after
ğ‘’1/2by program order.) Besides, there is an adjacency ordering
262SoundandEfficient Concurrency BugPrediction ESEC/FSE â€™21, August 23Å›28, 2021,Athens,Greece
e1Last(e1)
e2
Next(e2)w1w2
rğ’‚ğ’„ğ’’ğ’ğŸ
ğ’‚ğ’„ğ’’ ğ’ğŸ
ğ’‚ğ’„ğ’’ ğ’ğŸ
ğ’‚ğ’„ğ’’ğ’ğŸ
(c) (b) (a)w1w2
r
Figure 5: An illustration of part of sequence for three con-
currency bugs.
requirement:noothereventshouldbebetween ğ‘’1andğ‘’2.Itthen
produces a target sequence ğœŒ. Obviously, the two events form a
raceiffğ‘†ğ‘’ğ‘ğ¶â„ğ‘’ğ‘ğ‘˜(ğœ,ğœŒ,A)returns an eventsequence.
Detect Deadlocks. Unlike data race, any deadlock occurs by
following a sequence of events. Hence, we only need to check
whether a feasible sequence (over lock acquisition events only)
exists. For deadlocks of two threads, Algorithm 5generates all two
sequences where ğœŒ1is shown in Figure 5(b). Obviously, the four
eventsformadeadlockiffeitherofthecallto ğ‘†ğ‘’ğ‘ğ¶â„ğ‘’ğ‘ğ‘˜()returns
aneventsequence.Fordeadlocksofmorethreads,onecaneasily
implementanalgorithmtogeneratepossibleoccurrencesequences
andto checktheirfeasibilityaccordingly.
DetectAtomicityViolations. DetectionofAtomicityviolation
isevenmorestraightforward.Itisknownthattherearemultiple
patterns [ 34,42,56].Algorithm 5shows how to detect the pattern
whereawriteevent ğ‘¤1intrudesintoawrite-readpair (ğ‘¤2,ğ‘Ÿ).Given
three events ğ‘¤1,ğ‘¤2, andğ‘Ÿ(suppose that they occur in this order
inğœ), the algorithm straightforward generates a sequence ğœŒ=
âŸ¨ğ‘¤2,ğ‘¤1,ğ‘ŸâŸ©andcheckswhetheritisfeasible,asillustratedinFigure
5(c). Note, Figure 5(c) shows two cases where the read event ğ‘Ÿcan
be from athirdthread orfrom the thread tid(ğ‘¤2).
6 EVALUATION
6.1 BenchmarksandTraces
WecollectedasetofpreviouslyusedJavabenchmarks[ 3,28,37]
where31programswereusedfordataracedetectionandatomicity
violations detection. This set is almost the same set as evaluated
before[29,36,37,43]except4werenotfound.Onlysomeofbench-
marks in the AtomFuzzer paper are available, among which we
includedfour,includingthelargestone.Weused20benchmarks
inJavafrom[ 26,27]fordeadlockdetection.WerunthetoolDirk
[28]to generatetraces.
ThefirstsixcolumnsofTable 3showthestatisticsofalltraces
includingthenumbersofthreads,events,locations("Mems"),locks,
andbranches.Forwell-readablepurpose,weoptimizedthetable,
upper case "K" and "M" indicates thousand and million magnitude,
respectively.Weclassifyalltracesintofourcategoriesaccording
tothenumberofevents(" ğ‘›"intimecomplexity): S-Bench (<1M
events),M-Bench (from1M to100M),L-Bench (from100M to
1,000M),andXL-Bench (>1,000M events).
6.2 ExperimentalSetup
We implemented SeqCheck in Java and compared it with M2 [ 43],
WCP [29], SHB [36], and SyncP [ 37] on data race detection. The
four race detectors are published in recent years and SyncP is
the-state-of-art.Section 7hasmorediscussiononthem.Theyare
available from the release package [ 37] . We compared SeqCheckwith the sound deadlock detector Dirk [ 28] , which is also the
state-of-the-art on sound deadlock detection except that Dirk is
a constraint-solver-based one. For atomicity violation detection,
weonlyfoundanavailabletoolAtomFuzzer[ 41]forcomparison.
AtomFuzzer detects potential atomicity violations and then, for
eachofthem,schedulesanewexecutionwithaim to trigger it.
All experiments were conducted on a Linux server with two
Intel(R) Xeon(R) Gold-6148CPUs and 256GiB RAM. Following the
work[37],we setupa timelimitofonehour,fairlylimitthemaxi-
mum usage of memory (80GiB) for each tools, run each tool one
by one withguaranteeing no CPU/IO-dense processes runningsi-
multaneously.Weconductedallexperimentfivetimesandtookthe
average values. Different scheduling may produce different traces;
we run the benchmarks onceto collectedthe same setof traces.
ResultsonDataRaceDetection .Table3showstheresulton
racedetection,includingthenumberofraces,thetimecost,andthe
max/meandistancesofarace(i.e.,thenumberofeventsbetween
the two events). The symbols " âˆ’" and "ğ‘‡ğ‘‚" indicate the cases with
noracedetectedandthecaseswherethetimelimitwasreached,re-
spectively.Note,foreachapproach,wecollectedandde-duplicated
all reported races before it finished or run out of time. We use
SeqCtodenote SeqCheck inresulttablesfromthissubsection.For
well-readable purpose, we use lower case "s", "m", "h" to indicate
seconds,minutes,hoursrespectively.
From Table 3, we see that SeqCheck performed significantly
betterthanothers.Oneffectiveness, SeqCheck detectedthelargest
set of races on each (group of) benchmark. We have manually
confirmedthat SeqCheck detectedallracesdetectedbyothersand
nofalsepositiveswerereportedby SeqCheck onS-Bench.Overall,
itdetected48moreracesthantheotherfour.Someoftheseraces
have adistance ofmore than200M.
This shows the advantage of SeqCheck by analyzing branch
events . Both SyncP and M2 detected a similar set of races (285 and
269). This is consistent with the previous result [ 37]. Both WCP
andSHB detectedasimilar setof races(130 and144).
Onefficiency, SeqCheck spent30minutesonallbenchmarks;
whileothersspentfrom6hoursto11.5hours.Oneachlargebench-
mark(except S-Bench),SeqCheck isalsothefastestoneexcepton
montecarlo andseries.Overall, SeqCheck isnearly 12timesfaster
thanallotherapproaches.Amongtheotherfour,M2spentthemost
time (11.5 hours) and SyncP, WCP, and SHB spent from 6 hours to
7hours. This result isalsoconsistent withthat of [ 37].
Anotherobservationisthat,except SeqCheck ,allothersreached
2 to 10 TO. And on the XL-Bench group, all run up to nearly or
more than 1 hour except M2 on â„2. But M2 has many more TO
on all benchmarks. This result is consistent with the features of
these four algorithms: the three (SyncP, WCP, SHB) are streaming
algorithmsandhavealmostalineartimecomplexity[ 37];butM2
as well as SeqCheck is a full-trace algorithm where optimizations
can be conductedfor it.
Results On Deadlock Detection .Table4shows the results on
deadlock detection by Dirk (with window size 10K) and SeqCheck .
Italsoincludes the number of threads andevents.
On effectiveness, Dirk detected one more deadlock than Se-
qCheck. In detail, SeqCheck detected one additional deadlock
(onVector) missed by Dirk. All these are true positives based on
263ESEC/FSE â€™21, August 23Å›28, 2021,Athens,Greece YanCai,HaoYun, Jinqiu Wang,Lei Qiao,andJens Palsberg
Table 3:Results on detection ofdata races.
Benchmarks Threads EventsMemsLocks Branchs#Races Time Distance
SyncPM2WCPSHBSeqC SyncP M2 WCP SHB SeqC Max MeanS-Bencharray 3 47 4 1 9 - - - - - 0.03s 0.15s 0.03s 0.02s 0.10s - -
critical 4 76 9 0 15 3 3 1 3 3 0.03s 0.09s 0.03s 0.02s 0.10s 29 17
pingpong 8 189 16 0 57 1 1 1 1 1 0.03s 0.09s 0.03s 0.02s 0.07s 92 91
airlinetickets 11 249 20 0 51 6 6 5 6 6 0.03s 0.14s 0.03s 0.02s 0.11s 161 127
account 5 284 22 0 67 3 3 3 3 5 0.03s 0.10s 0.04s 0.02s 0.11s 152 109
clean 12 505 41 2 130 1 3 1 1 3 0.08s 0.16s 0.05s 0.03s 0.11s 226 123
bubblesort 12 2.3K 74 2 581 3 3 3 3 3 0.15s 0.71s 0.08s 0.05s 0.12s 1.2K 1.1K
boundedbuffer 4 2.5K 39 4 871 8 8 6 8 10 0.07s 0.16s 0.08s 0.05s 0.08s 2.1K 1.1K
mergesort 7 5.9K 594 6 2.2K 2 2 2 2 2 0.08s 0.17s 0.10s 0.07s 0.11s 2.4K 909
raytracer 2 24.7K 3.9K 3 4.9K 4 4 4 4 5 0.23s 0.25s 0.29s 0.23s 0.09s 4.7K 2.1K
bufwriter 5 27.9K 75 1 3.6K 4 4 4 4 4 0.63s 1.38s 0.46s 0.24s 0.18s 26.9K 6.8K
ftpserver 5 99.8K 3.8K 71 56.9K 30 30 15 15 31 0.81s 5.17s 0.57s 0.41s 0.19s 36.2K 4.6K
readerswriters 8 307.0K 27 1 121.4K 1 1 1 1 1 11.52s 1m33s 3.09s 1.07s 1.42s 1.2K 1.2K
moldyn 5 555.0K 2.7K 1 148.0K 3 3 3 3 3 2.46s 20m54s 4.05s 2.07s 0.34s 57.0K 30.3K M-Benchjigsaw 13 2.8M 63.2K 104 930.0K 11 12 8 9 12 10.58s 17.92s 10.64s 10.09s 0.54s 44.3K 5.7K
montecarlo 3 10.1M850.1K 1 2.1M 2 2 1 2 2 38.38s TO 47.15s 37.58s 40.97s 8.5M 4.2M
sunflow 15 34.9M 2.0M 10 13.4M 7 7 5 6 7 1m13s 9m21s 2m18s 1m44s 5.33s 20.0M 3.0M
crypt 17 79.0M 6.3M 1 6.8M - - - - 8 5m06s TO 6m38s 5m07s 21.61s 56.8M 56.8M L-Bencheclipse 15 126.3M 10.4M 4.7K 62.1M 17 17 13 14 17 12m05s 18m32s 8m36s 6m24s 36.14s 18.3M 3.4M
xalan 7 164.2M 2.8M 812 65.8M 128 135 9 9 138 TO TO 9m51s 7m08s 1m56s 20.2M 13.1M
lufact 5 179.6M 1.0M 1 48.7M 6 - 5 6 6 11m09s TO 15m37s 10m37s 1m25s 5.1M 2.5M
batik 7 279.9M 5.1M 1.9K 106.3M - - - - - 11m41s 6m01s 15m23s 12m41s 22.59s - -
lusearch 7 322.0M 4.7M 148 115.9M 16 - 16 16 19 14m21s TO 17m51s 13m46s 31.16s200.6M 12.8M
pmd 9 382.6M 12.1M 221 168.9M 23 23 13 16 24 16m07s TO 20m28s 16m20s 35.91s224.4M 33.6M
tsp 5 487.1M180.9K 2 167.3M 4 - 4 4 4 18m36s TO 22m25s 17m15s 2m20s 86.7M 53.0M
series 18 574.2M286.4K 1 573.1M - - - - - 10.12s 14.65s 11.00s 10.19s 37.17s - -
luindex 3 775.0M 2.5M 65 304.6M 1 1 1 1 1 27m48s 14m35s 35m56s 27m36s 1m02s 1.9K 1.9K XL-Benchsparsematmult 6 1,286.9M 16.0M 1 150.3M - - - - - TO TO TO TO 5m07s - -
sor 5 1,357.3M 4.0M 1 187.3M - - - - 10 TO TO TO TO 4m08s 40.1M 17.6M
avrora 7 1,636.3M864.5K 6 638.4M - - 6 6 7 TO TO TO 58m03s 4m52s 896.8K364.4K
h2 2 2,088.7M 27.1M 15 1,126.0M 1 1 - 1 1 TO 25m19s TO 59m31s 5m16s 2 2
Total -9,787.9M96.4M 8.1K3,738.2M 285269 130 144 333 >6h59m>11h36m>6h36m>5h57m30m03s - -
our code inspection. On Vector, the distance of the deadlock (i.e.,
the two acquire events) is 2.7M which is very large window and
constraint-solver-based approaches [ 24] are probably unable to de-
tect. On all other benchmarks, the distance is at most 1.6K. Hence,
Dirk was able to detect two deadlocks on Deadlock andTransfer
missed by SeqCheck . On these two deadlocks, there are data flows
that can be handled by Dirk but not SeqCheck . It is challenging
to extend SeqCheck to handle these cases; we leave it as a further
work.Note,somebenchmarkshavedeadlocksbuttheirtracesdo
nothaveone[ 28];andbothtoolsdidnotdetectdeadlocksonthem.
On efficiency, SeqCheck is significantly better than Dirk. Se-
qCheckspentlessthan6secondsintotalandlessthan2.5seconds
oneachbenchmark.However,DirkreachedoneTOandtookmuch
more time,especiallyonbenchmarks with>500K events.
ResultsOnAtomicityViolationsDetection .Weconfigured
SeqCheck todetecttheatomicityviolationpattern âŸ¨ğ‘¤1,ğ‘¤2,ğ‘ŸâŸ©as
thatshowninAlgorithm 5andwesetthedistancebetween ğ‘¤2and
ğ‘Ÿto be at most 100. The result is shown in Table 5, including the
numberofatomicityviolations,thetimecost,andthemax/mean
distance.We use "âŠ—"to indicateacrash intesting.Theresultshowsthat SeqCheck finishedinlessthan20minutes
and30uniqueonesweredetected.Someoftheseatomicityviola-
tions have a distance up to 18.7M andSeqCheck finished in about
20 seconds. This shows that SeqCheck is efficient on detecting
atomicity violations. The results on S-Bench are also manually
confirmedandthey matchthe pattern âŸ¨ğ‘¤1,ğ‘¤2,ğ‘ŸâŸ©.
AtomFuzzer (i.e., " AtomF") detected none on all benchmarks
anditfrequentlycrashedonmanybenchmarks.Wehavealready
tried our best to avoid crashes as much as possible. But, it seems
noavail.ThemainreasonofcrashesisthatAtomFuzzerdoesnot
support Java reflection.
7 RELATED WORKS
TraditionalUnsoundApproaches. Twoearliestworksondata
racedetectionarebasedonthehappens-beforerelation[ 31]and
thelocksetdiscipline[ 51].Theformerdefineapartialorderover
synchronizationsandiswidelyadoptedinmanydataracedetectors
[1,2,4,10,12,13,15,20,45,52Å›54,57].Thelatterdefinesadatarace
iftwoaccessesarenotprotectedbyacommonlock[ 9,39,47,51,60].
Hybrid analyses combine the two approaches to improve accuracy
264SoundandEfficient Concurrency BugPrediction ESEC/FSE â€™21, August 23Å›28, 2021,Athens,Greece
Table 4:Results on detection ofdeadlocks.
Benchmarks Threads Events#Deadlocks Time Distance
Dirk SeqC Dirk SeqC Max Mean
Deadlock 3 50 1 - 0.02s 0.07s - -
NotADlk 3 62 - - 0.02s 0.10s - -
Picklock 3 68 1 1 0.02s 0.07s 25 25
HashTable 3 70 2 2 0.03s 0.10s 41 36
Bensalem 4 80 1 1 0.06s 0.07s 29 29
Transfer 3 81 1 - 0.02s 0.10s - -
Test 3 83 2 2 0.06s 0.07s 34 27
StringBuffer 3 116 2 2 0.03s 0.07s 34 19
DiningPhi 3 166 1 1 0.05s 0.10s 105 105
DirkAccount 6 867 - - 0.15s 0.10s - -
Log4j2 4 2.5K 1 1 0.80s 0.10s 295 295
Dbcp1 3 2.9K 2 2 0.23s 0.10s 210 191
Derby2 3 3.0K 1 1 0.31s 0.12s 61 61
Dbcp2 3 4.1K - - 0.55s 0.10s - -
JDBC1 3 674.5K 2 2 44.92s 0.19s 424 240
JDBC2 3 674.6K 1 1 4.33s 0.19s 168 168
JDBC3 3 675.8K 1 1 43.48s 0.16s 148 148
JDBC4 3 675.9K 2 2 10.44s 0.20s 1.6K 1.6K
Vector 3 5.4M - 1 TO 1.34s 2.7M 2.7M
TestPerf 10 11.9M - - 48.63s 2.47s - -
Total - 20.0M 21 20 >1h02m 5.95s - -
[11,40]. Others include scheduling [ 5] and sampling approaches
[4,7,22]. Unfortunately,the above can report false positives.
Sound Offline Analysis. Sound dynamic ones, as discussed
in Section 1, include three types. M2 is a graph based one that
hasbeen extensivelydiscussed.Dirk[ 28]andRVPredict[ 24]are
representativesofconstraintsolverbasedones.Theycaninferalter-
native executions by considering branches and concrete read/write
values; hence, they have the potential to cover many races, as well
as deadlocks [ 28] and other concurrency bugs (like concurrency
Use-after-freeandconcurrencyNull-pointer-dereference[ 16,23]).
However,theyrelyon(e.g.,SMT)solvers.Thispreventsthemfrom
analyzing a full execution trace. They can miss a race with much a
larger distance.
SoundOnlineAnalysis. Inrecentyears,moreandmoresound
dynamic online approaches have been proposed like CP [ 55], WCP
[29],SHB[36],DC[50],SDP/WDP[ 21],andSyncP[ 29].Theseap-
proachestrack dependencyamongmemoryevents and guarantee
thatthepredicted(partial)traceisfeasibleviavectorclocks[ 31].HB
and SHB both miss simple races because they cannot swap the crit-
ical sections. The other approaches based on HB construct weaker
partial orders in order to reduce the degree of incompleteness. CP
andWCP aresoundbutincompleteevenfortwothreads. DCand
SDP are unsound weakenings of WCP; and WDP is an unsound
weakening of DC. The DC/WDP-races filtered by a vindication
algorithmbecomesoundbutincomplete[ 21,50].Therecentlyin-
troducedSyncPisthestateoftheartindetectingracesusingonline
techniques.Alloftheseonlineapproachesarecomputableinlinear
time andhave been comparedinour experiments.
Other approaches such as static race analysis [ 14,38,46,48,
58,61] are unsound, reporting false races. Techniques such as
[17,49,59] implement efficient dynamic race detectors. Tools such
asRoadRunner[ 19]andRapid[ 35]providedynamicanalysisframe-
works to facilitate experimentation for concurrentprograms.Table 5:Full Results on Detection ofAtomicityViolation.
Benchmarks#Atom Time Distance
AtomFSeqC AtomF SeqC Max MeanS-Bencharray - - 0.17s 0.07s - -
critical - 1 0.07s 0.10s 20 13
pingpong - - 0.76s 0.07s - -
airlinetickets - 1 0.07s 0.10s 159 159
account - 1 0.56s 0.10s 118 118
clean - - 0.07s 0.07s - -
bubblesort - - 0.08s 0.11s - -
boundedbuffer - 2 0.17s 0.08s 812 761
mergesort - - 0.07s 0.11s - -
raytracer - 1 0.12s 0.08s 1.1K 1.1K
bufwriter - - 0.08s 0.15s - -
ftpserver âŠ—1âŠ—0.17s 1.8K 1.8K
readerswriters - - 0.40s 0.73s - -
moldyn - - 0.19s 0.30s - - M-Benchjigsaw âŠ—1âŠ—0.37s 111 111
montecarlo âŠ—-âŠ—48.72s - -
sunflow âŠ—-âŠ—4.22s - -
crypt - - 0.59s 20.32s - - L-Bencheclipse âŠ—-âŠ—13.62s - -
xalan âŠ—20âŠ—20.86s 18.7M 12.8M
lufact - - 5.72s 48.31s - -
batik âŠ—-âŠ—25.10s - -
lusearch âŠ—-âŠ—28.09s - -
pmd âŠ—-âŠ—35.94s - -
tsp âŠ—-âŠ—46.30s - -
series - - 26m27s 38.07s - -
luindex âŠ—-âŠ—54.61s - -XL-Benchsparsematmult - - 23.27s 3m16s - -
sor - - 9.01s 3m21s - -
avrora âŠ—2âŠ—2m54s 141.0K 130.4K
h2 âŠ—-âŠ—3m07s - -
Total -30 27m08s 19m07s 18.9M 12.9M
8 CONCLUSION
Wehavepresentedanefficient,sounddynamicapproach SeqCheck
for detection of general concurrency bugs. It advanced M2 by mod-
eling branch events and supporting decisions on whether an event
sequenceisfeasible.With SeqCheck ,onecaneasilyencodeapo-
tential concurrency bug into one or more sequences of events.
SeqCheck hasbuiltinthesequencegenerationfordataraces,dead-
locks,andatomicityviolations.Theexperimentalresultsshowthat
SeqCheck achievedsignificantlybetterresultsthanrecentsound
dataraceanddeadlockdetectorsinbotheffectivenessandefficiency.
ACKNOWLEDGEMENTS
Wesincerelythanktheanonymousreviewersforhelpfulsugges-
tionsandinsightsforimprovingthispaper.Thisworkissupported
in part by National Natural Science Foundation of China (NSFC)
(Grant No. 61932012), the Key Research Program of Frontier Sci-
ences,CAS(GrantNo.ZDBS-LY-7006),theYouthInnovationPro-
motionAssociationoftheChineseAcademyofSciences(YICAS)
(Grant No. 2017151), and the National Key Research and Devel-
opment Program of China (No. 2018YFB1403400). And National
ScienceFoundationaward1815496 supportedJensPalsberg.
265ESEC/FSE â€™21, August 23Å›28, 2021,Athens,Greece YanCai,HaoYun, Jinqiu Wang,Lei Qiao,andJens Palsberg
REFERENCES
[1]SwarnenduBiswas,ManCao,MinjiaZhang,MichaelD.Bond,andBenjaminP.
Wood. 2017. Lightweight data race detection for production runs. In Proceedings
ofthe26thInternationalConferenceonCompilerConstruction (Austin,TX,USA)
(CCâ€™17).AssociationforComputingMachinery,ustin,TX,USA,11Å›21. https:
//doi.org/10.1145/3033019.3033020
[2]Swarnendu Biswas, Minjia Zhang, Michael D. Bond, and Brandon Lucia. 2015.
Valor: efficient, software-only region conflict exceptions. ACM SIGPLAN Notices
50,10(Oct.2015),241Å›259. https://doi.org/10.1145/2858965.2814292
[3]S. M. Blackburn, R. Garner, C. Hoffman, A. M. Khan, K. S. McKinley, R. Bentzur,
A.Diwan,D.Feinberg,D.Frampton,S.Z.Guyer,M.Hirzel,A.Hosking,M.Jump,
H. Lee, J. E. B. Moss, A.Phansalkar, D. StefanoviÄ‡, T. VanDrunen, D.von Dinck-
lage, and B.Wiedermann.2006. TheDaCapoBenchmarks:JavaBenchmarking
DevelopmentandAnalysis.In OOPSLAâ€™06:Proceedingsofthe21stannualACM
SIGPLAN conference on Object-Oriented Programing, Systems, Languages, and
Applications (Portland, OR, USA). ACM Press, New York, NY, USA, 169Å›190.
https://doi.org/10.1145/1167473.1167488
[4]MichaelD.Bond,KatherineE.Coons,andKathrynS.McKinley.2010. PACER:
ProportionalDetectionofDataRaces.In Proceedingsofthe31stACMSIGPLAN
Conference on Programming Language Designand Implementation (Toronto, On-
tario, Canada) (PLDI â€™10) . Association for Computing Machinery, New York, NY,
USA,255Å›268. https://doi.org/10.1145/1806596.1806626
[5]Yan Cai and Lingwei Cao. 2015. Effective and Precise Dynamic Detection of
HiddenRacesforJavaPrograms (ESEC/FSE2015) .AssociationforComputingMa-
chinery, New York, NY, USA, 450Å›461. https://doi.org/10.1145/2786805.2786839
[6]Yan Cai and W. K. Chan. 2012. MagicFuzzer: Scalable Deadlock Detection for
Large-scaleApplications.In Proceedingsofthe34thInternationalConferenceon
SoftwareEngineering (Zurich,Switzerland) (ICSEâ€™12) .IEEEPress,Piscataway,NJ,
USA,606Å›616. http://dl.acm.org/citation.cfm?id=2337223.2337294
[7]YanCai,JianZhang,LingweiCao,andJianLiu.2016. ADeployableSampling
StrategyforDataRaceDetection.In Proceedingsofthe201624thACMSIGSOFT
International Symposium on Foundations of Software Engineering (Seattle, WA,
USA)(FSE 2016) . Association for Computing Machinery, New York, NY, USA,
810Å›821. https://doi.org/10.1145/2950290.2950310
[8]YanCai,BiyunZhu,RuijieMeng,HaoYun,LiangHe,PuruiSu,andBinLiang.
2019. DetectingConcurrencyMemoryCorruptionVulnerabilities.In Proceedings
of the 2019 27th ACM Joint Meeting on European Software Engineering Conference
and Symposium on the Foundations of Software Engineering (Tallinn, Estonia)
(ESEC/FSE 2019) . Association for Computing Machinery, New York, NY, USA,
706Å›717. https://doi.org/10.1145/3338906.3338927
[9]Jong-Deok Choi, Keunwoo Lee, and AlexeyLoginov. 2002. Efficient andprecise
datarace detection for multithreaded object-oriented programs. ACM Sigplan
Notices37,5 (June2002),258Å›269. https://doi.org/10.1145/543552.512560
[10]Intel Corporation. 2016. Intel Inspector. https://software.intel.com/en-us/intel-
inspector-xe
[11]Anne Dinning and Edith Schonberg. 1991. Detecting access anomalies in pro-
grams with critical sections. ACM SIGPLAN Notices 26, 12 (Dec. 1991), 85Å›96.
https://doi.org/10.1145/127695.122767
[12]LauraEffinger-Dean,Brandonlucia,luisCeze,DanGrossman,andHans-JBoehm.
2012. IFRit:interference-freeregionsfordynamicdata-racedetection.In Acm
International Conference on Object Oriented Programming Systems Languages
&Applications (Tucson,Arizona,USA) (OOPSLAâ€™12) .https://doi.org/10.1145/
2398857.2384650
[13]Tayfun Elmas, Shaz Qadeer, and Serdar Tasiran. 2007. Goldilocks: a race and
transaction-aware java runtime. AcmSigplanNotices 42,6(June 2007), 245Å›255.
https://doi.org/10.1145/1273442.1250762
[14]Dawson Engler and Ken Ashcraft. 2003. RacerX : Effective, static detection of
raceconditionsanddeadlocks. ACMSIGOPSOperatingSystemsReview 37,5(Oct.
2003),237Å›252. https://doi.org/10.1145/945445.945468
[15]John Erickson, Madanlal Musuvathi, Sebastian Burckhardt, and Kirk Olynyk.
2010. Effectivedata-racedetectionforthekernel.In Proceedingsofthe9thUSENIX
conferenceonOperatingsystemsdesignandimplementation (OSDIâ€™10) .151Å›162.
https://doi.org/10.5555/1924943.1924954
[16]Azadeh Farzan, P. Madhusudan, Niloofar Razavi, and Francesco Sorrentino. 2012.
Predicting Null-Pointer Dereferences in Concurrent Programs. In Proceedings of
theACMSIGSOFT20thInternationalSymposiumontheFoundationsofSoftwareEn-
gineering (Cary,NorthCarolina) (FSEâ€™12).AssociationforComputingMachinery,
NewYork,NY,USA,Article47,11pages. https://doi.org/10.1145/2393596.2393651
[17]MingdongFengandCharlesE.Leiserson.1997. Efficientdetectionofdeterminacy
racesinCilkprograms.In ProceedingsoftheninthannualACMsymposiumon
Parallelalgorithmsand architectures (SPAAâ€™97) . 1Å›11.
[18]PeterM.Fenwick.1994. ANewDataStructureforCumulativeFrequencyTables.
Softw. Pract. Exper. 24, 3 (March 1994), 327Å›336. https://doi.org/10.1002/spe.
4380240306
[19]CormacFlanaganandStephenFreund.2010. TheRoadRunnerDynamicAnalysis
FrameworkforConcurrentPrograms.In Proceedingsofthe9thACMSIGPLAN-
SIGSOFT workshop on Program analysis for software tools and engineering (PASTEâ€™10). 1Å›8.
[20]Cormac Flanagan and Stephen N. Freund. 2009. FastTrack: Efficient and Precise
Dynamic Race Detection. In Proceedings of the 30th ACM SIGPLAN Conference on
ProgrammingLanguageDesignandImplementation (Dublin,Ireland) (PLDIâ€™09) .
ACM,NewYork, NY, USA,121Å›133. https://doi.org/10.1145/1542476.1542490
[21]Kaan GenÃ§, Jake Roemer, Yufan Xu, and Michael D. Bond. 2019. Dependence-
Aware, Unbounded Sound Predictive Race Detection. Proc. ACM Program. Lang.
3,OOPSLA, Article179(Oct.2019),30pages. https://doi.org/10.1145/3360605
[22]YuGuo,YanCai,andZijiangYang.2017. AtexRace:AcrossThreadandExecution
Sampling for in-House Race Detection. In Proceedings of the 2017 11th Joint
MeetingonFoundationsofSoftwareEngineering (Paderborn,Germany) (ESEC/FSE
2017). Association for Computing Machinery, New York, NY, USA, 315Å›325.
https://doi.org/10.1145/3106237.3106242
[23]Jeff Huang. 2018. UFO: Predictive Concurrency Use-after-Free Detection. In
Proceedings of the 40th International Conference on Software Engineering (Gothen-
burg, Sweden) (ICSE â€™18) . Association for Computing Machinery, New York, NY,
USA,609Å›619. https://doi.org/10.1145/3180155.3180225
[24]JeffHuang,PatrickOâ€™NeilMeredith,andGrigoreRosu.2014. MaximalSoundPre-
dictive Race Detection with Control Flow Abstraction. In Proceedings of the 35th
ACMSIGPLANConferenceonProgrammingLanguageDesignandImplementation
(Edinburgh, United Kingdom) (PLDI â€™14) . Association for Computing Machinery,
NewYork, NY, USA,337Å›348. https://doi.org/10.1145/2594291.2594315
[25]JoabJackson. 2012. Nasdaqâ€™s Facebookglitchcame from â€˜race conditionsâ€™. http:
//www.computerworld.com/s/article/9227350 .
[26]PallaviJoshi,Chang-SeoPark,KoushikSen,andMayurNaik.2009.ARandomized
Dynamic Program Analysis Technique for Detecting Real Deadlocks. In Proceed-
ings of the 30th ACM SIGPLAN Conference on Programming Language Design and
Implementation (Dublin, Ireland) (PLDI â€™09) . Association for Computing Machin-
ery, NewYork, NY, USA,110Å›120. https://doi.org/10.1145/1542476.1542489
[27]HoratiuJula,DanielTralamazza,CristianZamfir,andGeorgeCandea.2008. Dead-
lock Immunity: Enabling Systems to Defend against Deadlocks. In Proceedings of
the 8th USENIX Conference on Operating Systems Design and Implementation (San
Diego, California) (OSDIâ€™08) . USENIXAssociation, USA,295Å›308.
[28]ChristianGramKalhaugeandJensPalsberg.2018. SoundDeadlockPrediction.
Proc.ACMProgram.Lang. 2,OOPSLA,Article146(Oct.2018),29pages. https:
//doi.org/10.1145/3276516
[29]Dileep Kini, Umang Mathur, and Mahesh Viswanathan. 2017. Dynamic Race
PredictioninLinearTime (PLDI2017) . Associationfor ComputingMachinery,
NewYork, NY, USA,157Å›170. https://doi.org/10.1145/3062341.3062374
[30]Lamport.1979.HowtoMakeaMultiprocessorComputerThatCorrectlyExecutes
Multiprocess Programs. IEEE Trans. Comput. C-28, 9 (1979), 690Å›691. https:
//doi.org/10.1109/TC.1979.1675439
[31]Leslie Lamport. 1978. Time, Clocks, and the Ordering of Events in a Distributed
System. Commun. ACM 21, 7 (July 1978), 558Å›565. https://doi.org/10.1145/
359545.359563
[32]N.G.LevesonandC.S.Turner.1993. AninvestigationoftheTherac-25accidents.
Computer 26,7 (1993), 18Å›41. https://doi.org/10.1109/MC.1993.274940
[33]ShanLu,SoyeonPark,EunsooSeo,andYuanyuanZhou.2008. Learningfrom
Mistakes: A Comprehensive Study on Real World Concurrency Bug Characteris-
tics.InProceedingsofthe13thInternationalConferenceonArchitecturalSupport
for Programming Languages and Operating Systems (Seattle, WA, USA) (ASP-
LOS XIII). Association for Computing Machinery, New York, NY, USA,329Å›339.
https://doi.org/10.1145/1346281.1346323
[34]BrandonLucia,JosephDevietti,KarinStrauss,andLuisCeze.2008. Atom-Aid:
Detecting and Surviving Atomicity Violations. In Proceedings of the 35th Annual
InternationalSymposiumonComputerArchitecture (ISCAâ€™08) .IEEEComputer
Society, USA,277Å›288. https://doi.org/10.1109/ISCA.2008.4
[35]Umang Mathur. 2020. RAPID : Dynamic Analysis for Concurrent Programs.
https://github.com/umangm/rapid
[36]Umang Mathur, Dileep Kini, and Mahesh Viswanathan. 2018. What Happens-
aftertheFirstRace?EnhancingthePredictivePowerofHappens-beforeBased
DynamicRaceDetection. 2,OOPSLA,Article145(Oct.2018),29pages. https:
//doi.org/10.1145/3276515
[37]Umang Mathur, Andreas Pavlogiannis, and Mahesh Viswanathan. 2021. Optimal
Prediction of Synchronization-Preserving Races. Proc. ACM Program. Lang. 5,
POPL, Article36(Jan. 2021),29pages. https://doi.org/10.1145/3434317
[38]MayurNaik, AlexAiken, and JohnWhaley. 2006. Effectivestatic racedetection
forJava. ACMSIGPLANNotices 41,6(June2006),308Å›319. https://doi.org/10.
1145/1133255.1134018
[39]HiroyasuNishiyama.2004. DetectingDataRacesUsingDynamicEscapeAnalysis
Based on Read Barrier. In Proceedings of the 3rd conference on Virtual Machine
Research And Technology Symposium (VM â€™04) . New York, NY, USA, 127Å›138.
https://doi.org/10.5555/1267242.1267252
[40]RobertOâ€™CallahanandJong-DeokChoi.2003.Hybriddynamicdataracedetection.
InProceedingsoftheninthACMSIGPLANsymposiumonPrinciplesandpractice
of parallel programming (San Diego, California, USA) (PPoPPâ€™03) . New York, NY,
USA,167Å›178. https://doi.org/10.1145/966049.781528
266SoundandEfficient Concurrency BugPrediction ESEC/FSE â€™21, August 23Å›28, 2021,Athens,Greece
[41]Chang-SeoParkandKoushikSen.2008. RandomizedActiveAtomicityViolation
Detection in Concurrent Programs.In Proceedingsofthe 16th ACM SIGSOFTIn-
ternational Symposium on Foundations of Software Engineering (Atlanta, Georgia)
(SIGSOFTâ€™08/FSE-16) .AssociationforComputingMachinery,NewYork,NY,USA,
135Å›145. https://doi.org/10.1145/1453101.1453121
[42]Chang-SeoParkandKoushikSen.2008. RandomizedActiveAtomicityViolation
Detection in Concurrent Programs.In Proceedingsofthe 16th ACM SIGSOFTIn-
ternational Symposium on Foundations of Software Engineering (Atlanta, Georgia)
(SIGSOFTâ€™08/FSE-16) .AssociationforComputingMachinery,NewYork,NY,USA,
135Å›145. https://doi.org/10.1145/1453101.1453121
[43]Andreas Pavlogiannis. 2020. Fast, sound, and effectively complete dynamic
race prediction. Proc. ACM Program. Lang. 4, POPL (2020), 17:1Å›17:29. https:
//doi.org/10.1145/3371085
[44]Kevin Poulsen. 2012. Software bug contributed to blackout. Security Focus.
http://www.securityfocus.com/news/8016 .
[45]Eli Pozniansky and Assaf Schuster. 2007. Multirace: Efficient On-the-fly Data
Race Detection In Multithreaded C++ Programs. ACM Trans. Comput. Syst. 19, 3
(Nov. 2007),327Å›340. https://doi.org/10.1002/cpe.1064
[46]Polyvios Pratikakis, Jeffrey S. Foster, and Michael Hicks. 2011. LOCKSMITH:
PracticalstaticracedetectionforC. ACMTransactionsonProgrammingLanguages
and Systems 33,1 (Jan. 2011). https://doi.org/10.1145/1889997.1890000
[47]ChristophvonPraunandThomasR.Gross.2001. ObjectRaceDetection. ACM
Sigplan Notices 36, 11 (Nov. 2001), 70Å›82. https://doi.org/10.1145/504311.504288
[48]Cosmin Radoi and Danny Dig. 2013. Practical static race detection for Java
parallel loops. In Proceedings of the 2013 International Symposium on Software
Testingand Analysis (ISSTA2013) . 178Å›190.
[49]RaghavanRaman,JishengZhao,VivekSarkar,MartinVechev,andEranYahav.
2012. Scalable and precise dynamic datarace detection for structured parallelism.
ACMSIGPLANNotices 47,6(June2012),531Å›542. https://doi.org/10.1145/2345156.
2254127
[50]JakeRoemer,KaanGenc,andMichaelD.Bond.2018. High-Coverage,Unbounded
SoundPredictiveRaceDetection (PLDI2018) .374Å›389. https://doi.org/10.1145/
3192366.3192385
[51]StefanSavage,MichaelBurrows,GregNelson,PatrickSobalvarro,andThomas
Anderson. 1997. Eraser: A Dynamic Data Race Detector for Multithreaded
Programs. ACM Trans. Comput. Syst. 15, 4 (Nov. 1997), 391Å›411. https://doi.org/
10.1145/265924.265927
[52]Koushik Sen. 2008. Race directed random testing of concurrent programs. In
ACM SIGPLAN Notices (Tucson, Arizona, USA) (PLDI â€™08) . 11Å›21. https://doi.org/10.1145/1379022.1375584
[53]KonstantinSerebryanyandTimurIskhodzhanov.2009.ThreadSanitizer:datarace
detectioninpractice.In ProceedingsoftheWorkshoponBinaryInstrumentation
and Applications (New York, NY, USA) (WBIA â€™09) . 62Å›71. https://doi.org/10.
1145/1791194.1791203
[54]KonstantinSerebryany,AlexanderPotapenko,TimurIskhodzhanov,andDmitriy
Vyukov. 2012. Dynamic Race Detection with LLVM Compiler. In Runtime Verifi-
cation (RV 2011) . 110Å›114. https://doi.org/10.1007/978-3-642-29860-8_9
[55]Yannis Smaragdakis, Jacob Evans, Caitlin Sadowski, Jaeheon Yi, and Cormac
Flanagan. 2012. Sound Predictive Race Detection in Polynomial Time. In Pro-
ceedings of the 39th Annual ACM SIGPLAN-SIGACT Symposium on Principles
ofProgrammingLanguages (Philadelphia,PA,USA) (POPLâ€™12) .Associationfor
ComputingMachinery,NewYork,NY,USA,387Å›400. https://doi.org/10.1145/
2103656.2103702
[56]Francesco Sorrentino, Azadeh Farzan, and P. Madhusudan. 2010. PENELOPE:
WeavingThreadstoExposeAtomicityViolations.In ProceedingsoftheEighteenth
ACMSIGSOFTInternationalSymposiumonFoundationsofSoftwareEngineering
(SantaFe,NewMexico,USA) (FSEâ€™10).AssociationforComputingMachinery,
NewYork, NY, USA,37Å›46. https://doi.org/10.1145/1882291.1882300
[57]KaushikVeeraraghavan,PeterM.Chen,JasonFlinn,andSatishNarayanasamy.
2011. Detecting and surviving data races using complementary schedules. In
Proceedings of the Twenty-Third ACM Symposium on Operating Systems Principles
(SOSPâ€™11) . 369Å›384. https://doi.org/10.1145/2043556.2043590
[58]JanWenVoung,RanjitJhala,andSorinLerner.2007. RELAY:staticracedetection
on millions of lines of code. In Proceedings of the the 6th joint meeting of the
EuropeansoftwareengineeringconferenceandtheACMSIGSOFTsymposiumon
The foundations ofsoftwareengineering (ESEC-FSE â€™07) . 205Å›214.
[59]Adarsh Yoga, Santosh Nagarakatte, and Aarti Gupta. 2016. Parallel data race
detectionfortaskparallelprogramswithlocks.In Proceedingsofthe201624th
ACMSIGSOFTInternationalSymposiumonFoundationsofSoftwareEngineering
(FSE 2016) . 833Å›845.
[60]YuanYu,TomRodeheffer,andWeiChen.2005. RaceTrack:EfficientDetection
ofDataRaceConditionsvia AdaptiveTracking.In Proceedingsof theTwentieth
ACM Symposium on Operating Systems Principles (Brighton, United Kingdom)
(SOSP â€™05) . Association for Computing Machinery, New York, NY, USA, 221Å›234.
https://doi.org/10.1145/1095810.1095832
[61]Sheng Zhan and Jeff Huang. 2016. ECHO: instantaneous in situ race detection in
theIDE.In Proceedingsofthe201624thACMSIGSOFTInternationalSymposium
on Foundations ofSoftware Engineering (Seattle,WA, USA) (FSE2016) .775Å›786.
267