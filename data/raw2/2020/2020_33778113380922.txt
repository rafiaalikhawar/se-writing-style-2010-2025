An Empirical Study on API Parameter Rules
Hao Zhong1, Na Meng2, Zexuan Li1, and Li Jia1
1Departmentof Computer Science and Engineering, Shanghai Jiao Tong University, China
2VirginiaPolytechnic Instituteand StateUniversity, USA
zhonghao@sjtu.edu.cn,nm8247@cs.vt.edu,lizx_17@sjtu.edu.cn,insanelung@sjtu.edu.cn
ABSTRACT
Developersbuildprogramsbasedonsoftwarelibrariestoreduce
codingeffort.IfaprograminappropriatelysetsanAPIparameter,
theprogrammayexhibitunexpectedruntimebehaviors.Tohelp
developerscorrectlyuselibraryAPIs,researchersbuilttoolstomine
API parameter rules. However, it is still unknown (1) what types of
parameter rules there are, and (2) how these rules distribute inside
documentsandsourcefiles.Inthispaper,weconductedanempirical
study to investigate the above-mentioned questions. To analyze
as many parameter rules as possible, we took a hybrid approach
that combines automatic localization of constrained parameters
withmanualinspection.Ourautomaticapproach‚ÄîPaRu‚Äîlocates
parametersthathaveconstraintseitherdocumentedinJavadoc(i.e.,
document rules) or implied by source code (i.e., code rules). Our
manualinspection(1)identifiesandcategorizesrulesforthelocated
parameters, and (2) establishes mapping between document and
code rules. By applying PaRu to 9 widely used libraries, we located
5,334 parameters with either document or code rules. Interestingly,
there are only 187 parameters that have both types of rules, and 79
pairsoftheseparameterrulesareunmatched.Additionally,PaRu
extracted1,688rulesentencesfromJavadocandcode.Wemanually
classified these sentences into six categories, two of which are
overlookedbypriorapproaches.Wefoundthat86.2%ofparameters
have only code rules; 10.3% of parameters have only document
rules;andonly3.5%ofparametershavebothdocumentandcode
rules.Ourresearchrevealsthechallengesforautomatingparameter
rule extraction. Based on our findings, we discuss the potentials of
priorapproachesand present our insights for future tool design.
ACM Reference Format:
Hao Zhong1, Na Meng2, Zexuan Li1, and Li Jia1. 2020. An Empirical Study
onAPIParameterRules.In 42ndInternationalConferenceonSoftwareEn-
gineering(ICSE‚Äô20),May23‚Äì29,2020,Seoul,RepublicofKorea. ACM,New
York, NY, USA, 13 pages. https://doi.org/10.1145/3377811.3380922
1 INTRODUCTION
Software libraries ( e.g., J2SE [ 4]) are widely used, because they
provide thousands of reusable APIs. Incorrectly using APIs can
cause programming errors, slow down code development, or even
introduce security vulnerabilities to software [ 20,44]. Since cor-
rectly using APIs is important for programmer productivity and
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACM
mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,
topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ICSE ‚Äô20, May23‚Äì29, 2020, Seoul, Republic of Korea
¬© 2020 Association for Computing Machinery.
ACM ISBN 978-1-4503-7121-6/20/05...$15.00
https://doi.org/10.1145/3377811.3380922software quality, researchers have built various approaches that
detect or check API usage rules by analyzing code or documen-tation [
27,46,54]. For instance, Engler et al.[27] mined frequent
callingsequencesofmethodAPIsfromthecodeofoperatingsys-
tems,andrevealedabnormalAPIusage.Asanotherexample,Zhong
et al.[54]inferred API specifications from library documentation.
Although the above approaches mainly focus on API invocation
sequences, the careful selection of legal parameter values is alsoimportant for developers to ensure the correctness of API usage.
In the literature, researchers [
28,80] have proposed approaches
to mine API parameter rules. For instance, Ernst et al.[28] built
Daikontoinferinvariantsofvariables‚Äôvaluesfromdynamicpro-
filing of program executions. Zhou et al.[80] detected defects in
API documents using techniques of program analysis and natu-
ral language processing. Both approaches extract rules based on
predefined templates.
Althoughpriorstudies(e.g.,Polikarpova etal.[56])showthatthe
aboveapproachesinferredusefulparameterrules,manyresearch
questions in this research line are still open. For instance, what
types of parameter rules are there, and how do those parameter
rulesdistributeamongdocumentsandsourcefiles?Thesequestions
areimportantbecausewithoutanoverviewoftheAPIparameter
rules existing in libraries, it is hard to tell how far we are from
the fully automatic approaches that (i) detect constraints on API
parameters,(ii)documenttheparameterrulesreflectedbycode,and
(iii)reveal any constraint violation in the client code of libraries.
To explore these questions, in this paper, we conducted an ex-
tensiveempiricalstudyonparameterrules.Specifically,toreveal
as many parameter rules as possible, we took a hybrid approach
bycombiningautomaticfactrevealingandmanualinspection.In
particular, given a library, it can be very time-consuming for usto manually read all code and Javadoc comments to identify and
summarize theparameter rules.Therefore, webuilt anapproach‚Äî
PaRu (ParameterRules)‚Äîto locate (1) rule descriptions in Javadoc,
and (2) method APIs whose source code has parameter-related ex-
ceptiondeclarationsorassertstatements.AlthoughPaRucannot
comprehendorinterpretanydescribedorimpliedrule,itcanlocate
the parameters with candidate rules for further manual inspection.
Here, acandidate rule is a rule sentence or a parameter-related
exception/assertion located by PaRu.
Inthesecondstep,foreachparameterlocatedbyPaRu,weman-
ually examined the rule description in Javadoc or inspected the
codewith relatedexceptionorassertion. Inthisway, wecancom-
prehendthemeaningofeachlocatedcandidaterule,andexplore
the followingresearch questions:
‚Ä¢RQ1:WhatisthecategorizationofAPIparameterrules? Prior
workshowsthatthereareconstraintsonthevalues,value
ranges,ordatatypesofAPIparameters[ 80]. However, we
were curious whether there is any parameter rule that does
8992020 IEEE/ACM 42nd International Conference on Software Engineering (ICSE)
ICSE ‚Äô20, May 23‚Äì29, 2020, Seoul, Republic of Korea Hao Zhong1, Na Meng2, Zexuan Li1, and Li Jia1
notfallintotheknowncategories.Thisquestionisimportant
because by revealing new types of rules, we may shed light
on future rule extraction tools.
‚Ä¢RQ2:How do rules distribute in Javadoc and code implemen-
tation?Ourinvestigationforthisquestionservesmultiple
purposes.Forinstance,ifmostrulesonlyexistincode,we
need newapproaches thatgenerate Javadoc commentsfrom
codetoautomateruledocumentation.IftherulesinJavadocandsourcecodeoftenconflictwitheachother,weneednew
tools to detect and resolve the contradiction.
ByapplyingPaRuto9widelyusedsoftwarelibrariesthatcon-
tainintotal14,392sourcefiles,welocated5,334parameterswith
candidaterules.Basedontheseparametersandtheirrules,wemade
the followingmajorobservations.
‚Ä¢There are five major categories of parameter rules, with the
sixthcategory(i.e.,‚Äúother‚Äù)coveringmiscellaneousrules. We
analyzed1,688rule-relatedsentences,whicharelocatedin
either Javadoc comments or the exception messages of code.
In addition to the known categories such as null-value, con-
stant values, and value ranges, we found that 18.5% of the
studied rules constrain parameters‚Äô formats ( e.g.,‚ÄúcsvKey-
ValueDelimiter must be exactly 1 character‚Äù) ; while 5.3% of
rulesdescribetherelationbetweendifferentparameters( e.g.,
‚ÄúpolyLats and polyLons must be equal length‚Äù ). The miscella-
neous rules count for 7.0% of the inspected data. In total, we
identified three new rule categories that were unknown.
‚Ä¢ThemajorityofstudiedrulesareimplicitlyindicatedbyAPI
code.Specifically, 86.2% of parameters have rules defined in
code,while10.3%ofparameters‚ÄôrulesaredefinedinJavadoc.
Theresultsimplythatdevelopersseldomdescribeparameter
usage explicitly, which can cause significant confusion on
usersoftheAPIs.Weonlyfound2.0%oftheparametersto
have consistent rules that are reflected in both Javadoc and
code.Even fewerparameters(1.5%) haveinconsistent rules,
i.e., mismatches between the document rules and code rules
forthesameparameters.Suchinconsistenciesareusuallynot
bugs.Instead,therulesdescribedifferentandcomplementary
constraintson the same parameters.
The rest of this paper is organized as follows. Section 2 intro-
ducesthebackground.Section3presentsoursupporttool.Section4
presents our empirical study. Section 5 interprets our findings. Sec-
tion6discussthepotentialsofrelatedtools.Section8introduces
the related work. Section 9 concludes this paper.
2 BACKGROUND
This section defines terms related to API parameter rules (Sec-
tion2.1),andoverviews rule-mining techniques (Section 2.2).
2.1 Terminologies
API parameter rules describe or reflect the constraints on pa-
rametersofAPImethods.Suchconstraintsareimposedbyeither
software library implementation or application domains, and may
limit the value or format of any parameter. Rule violations can
cause coding errors and jeopardize developers‚Äô productivity. In our1/‚àó‚àó ...
2‚àó @param searcher IndexSearcher to find nearest points
from.
3‚àó @param field field name. must not be null.
4‚àó @param latitude latitude at the center: must be
within standard +/ ‚àí90 coordinate bounds.
5‚àó @param longitude longitude at the center: must be
within standard +/ ‚àí180 coordinate bounds.
6‚àó @param n the number of nearest ne ighbors to ret rieve
7‚àó/
8public static TopFieldDocs nearest( IndexSearcher
searcher , St ring field , double latitude , double
longitude , intn){
9GeoUtils.checkLatitude( latitude);
10GeoUtils.ch eckLongitude( longitude);
11if(n < 1) {
12throw new IllegalArgumentException("n‚ê£must‚ê£be‚ê£at‚ê£
least‚ê£1;‚ê£got‚ê£" + n);
13}
14if(field == null){
15throw new IllegalArgumentException("field‚ê£must‚ê£not‚ê£
be‚ê£null");
16}
17if(searcher == null){
18throw new IllegalArgumentException("searcher‚ê£must‚ê£
not‚ê£be‚ê£null");
19}. . . }
20/‚àó‚àó validates latitude value is within standard +/ ‚àí90
coordinate bounds ‚àó/
21public static void checkLatitude( double latitude) {
22if(Double.isNaN( latitude) || latitude < MIN_LAT_INCL
|| latitude > MAX_LAT_INCL) {
23throw new IllegalArgumentException("invalid‚ê£
latitude‚ê£" + latitude + ";‚ê£must‚ê£be‚ê£ between‚ê£"
+ MIN_LAT_INCL + " ‚ê£and‚ê£ " + MAX_LAT_INCL) ;
24}}
(a) A piece of API code with rules defined in Javadoc
Parameters:
searcher - IndexSearcher to find nearest points from.
field - field name. must not be null.latitude - latitude at the center: must be within standard
+/-90 coordinate bounds.
longitude - longitude at the center: must be within
standard +/-180 coordinate bounds.
n - the number of nearest neighbors to retrieve.
(b)TheJavadocofthe nearestmethod,whichisgeneratedfromits
code comments with the @paramtags
Figure 1: Example parameter rules
research, we focus on the parameter rules of public APIs, as these
APIsarevisibletolibraryusersandtherulescanaffectthoseusers.
AsshowninFigure1a,thereisamethodAPI nearest(...) de-
fined in the Lucene library [ 1]. Among the five parameters de-
fined for the API, one parameter is field. According to the API
implementation, fieldmustnotbe null,becausethecodethrows
anIllegalArgumentException if the parameter is null. Correspond-
ingly, the library developers described this rule in the Javadoc
comment enclosed by ‚Äú/**‚Äù and ‚Äú*/‚Äù. In particular, when the tag
@paramis used in the comment to declare a parameter and describe
the related rule(s) (see Figure 1a), a document on the parameter us-
age can be automatically generated when the method is publicized
as a library method interface [9] (see Figure 1b).
Since parameter rules can be either explicitly mentioned in
Javadoc comments or implicitly indicated by exceptions/assertions
in code, we defined two terms to reflect the data sources of rules.
900An Empirical Study on API Parameter Rules ICSE ‚Äô20, May 23‚Äì29, 2020, Seoul, Republic of Korea
Definition 2.1. Adocument rule is an API parameter rule ob-
served in API Javadoc, tagged with @param.
Definition 2.2. Acode rule is an API parameter rule inferred
from API source code.
InFigure1a, fieldhasbothadocumentruleandacoderule.Itis
also possible that a parameter has only one kind of rule or no rule
at all. For instance, the parameter searcher in Figure 1a has a code
rule butno document rule.
Definition 2.3. Arule sentence is a sentence that explicitly de-
scribes constraints on a parameter.
In Javadoc, a document rule always corresponds to a rule sentence.
In API implementation, a code rule may or may not correspond
to a rule sentence. As shown in Figure 1a, an exception message
explicitlymentionsaparameterrule‚Äî‚Äú field must not be null ‚Äù, so
weconsiderthemessagestringasarulesentence.Therearealso
scenarioswhereaninvalidparametercantriggeranexceptionin
API implementation, but the exception message does not explicitly
describeanyrule.Forsuchcases,therearecoderulesimpliedby
the exceptions but there is no rule sentence in the code.
Definition2.4. Rulelocalization istheprocesstoidentifyrules
(i.e., document and code rules) in library implementation.
Definition2.5. Rulecomprehension istheprocesstointerpret
the meaningof a localized rule.
Definition2.6. Rule extraction/mining involvesbothrulelo-
calizationand rulecomprehension.
Inourresearch,wetreatruleextractionasatwo-stepprocedure.
Toextractaparameterrule,wefirstlocalizerulesnomatterwhether
theyareintheformatofrulesentencesorexception-throwing/assertioncodechunks.Next,foreachlocalizedrule,wesummarizethemean-
ing or semantics.
2.2 Existing Rule Extraction Techniques
Researchers explored varioustechniquesto extract API parameter
rulesfrom client code, API documents, and/or API code.
MiningClientCode. Clientcodeisthesourcecodethatinvokes
APIs. Given a software library, many approaches identify client
code of the library in open source projects [ 23,28,49,70]. Some of
theapproachesthencompileandexecuteclientprojects[ 23,28,70].
They leverage dynamic analysis to collect the execution traces,
gather run-time values of variables, and further infer invariants on
theexact value or value ranges of parameters. Nguyen et al.usea
light-weight, intra-procedural, static analysis technique to analyze
theguardconditionsinclientcodebeforeanAPIisinvoked[ 49].
This approach is limited by the API parameter rules sensed by
developers of client code.
Mining Library Documents. Librarydocumentsdescribethe
functionalities and usage of APIs in natural languages. Existing ap-
proaches typically analyze such documents with natural language
processing techniques [ 54,80]. These approaches usually define
parsing semantic templates to locate specific natural language sen-
tences,andconvertthosesentencestomethodspecifications.ForTable 1: Subject projects.
Names FilesMethods Ex.Para. Doc.
commons-io 246 1,534 4131,936 1,590
pdfbox 1,295 6,392 4846,375 3,949
shiro 711 2,090 2371,960 854
itext 1,503 8,9301,11011,089 5,784
poi 3,493 16,599 2,31517,792 5,218
jfreechart 987 6,847 4508,728 8,672
lucene 4,124 12,204 3,16316,022 3,454
asm 269 1,925 2742,614 1,015
jmonkey 1,764 10,867 1,31214,470 4,679
total 14,392 67,388 9,75880,986 35,215
instance,oneofthetemplatesdefinedbyPandita etal.[54]is‚Äú(sub-
ject) (verb) (object) ‚Äù, which can locate rule sentences like ‚ÄúThe path
cannotbe null‚Äù.
MiningLibraryCode. Libraryorframeworkcodeistheimple-
mentation of class,method, or field APIs.Existing approaches use
staticanalysistoinferparameterrulesfromAPIsourcecode[ 17,80].
Specifically, the state-of-the-art approach of parameter rule extrac-
tionwasintroducedbyZhou etal.[80],whocombineddocument
analysis with code analysis. For document analysis, Zhou et al.de-
fined four parsing semantictemplates (e.g.,‚Äú (subject) equal tonull ‚Äù)
tolocatedocumentrules.Meanwhile,forcodeanalysis,theylocated
exception throwing declarations in the body of any method API
m. Then they related the declarations with any formal parameter
defined by either mor other methods invoked by m. If a parameter p
cantriggerathrownexceptioninanyprogramexecutionpath,they
generated coderules bysynthesizingallconstraintsonthepath(s)
forp‚Äôsvalue.Bycomparingthedocumentrulesandcoderulesof
the same API parameters, they reported defective document rules.
Theapproach‚Äôseffectivenessislimitedby(1)therepresentativeness
of defined rule templates, and (2) the precision of static analysis.
All above-mentionedtechniques can automaticallylocalize and
comprehendcertainrules.Forthispaper,weintendedtoidentify
asmanyparameterrulesaspossibleinpopularlibraries,andassess
(1) what types of parameter rules there are, and (2) how parameter
rules distributeamong documents and source files.
3 PARU
In this section, we first present our dataset (Section3.1), and then
introduce how PaRu extracts document rules (Section 3.2) andcode rules (Section 3.3) from source files. Section 3.4 shows the
f-scores of PaRu. PaRu focuses on rule localization instead of rule
comprehension.PaRuborrowsideasfromcurrentruleminingtools,
but can locate more diverse parameter rules in a scalable way.
3.1 Dataset
Table 1 shows the nine subject libraries. Column ‚Äú Names‚Äù lists
the names of libraries. In particular, asm[2] is an analysis library
for Java bytecode, and jmonkey[5] is a game engine framework.
Except jfreechart , all the other libraries were collected from the
Apachefoundation [ 8]; these libraries were designed for purposes
likeassistingIOfunctionalities,manipulatingdifferenttypesoffiles,
and performing security managements. We selected these subjects
because they are widely used in various programming contexts.
901ICSE ‚Äô20, May 23‚Äì29, 2020, Seoul, Republic of Korea Hao Zhong1, Na Meng2, Zexuan Li1, and Li Jia1
∆å≈Ω≈Ω∆ö ƒû∆êƒê≈öƒû∆å ƒê≈Ω≈∂∆öƒÇ≈ù≈∂ƒû∆å ƒ®∆å≈Ω≈µ «Å≈ö≈ùƒê≈ö ƒû∆êƒê≈öƒû∆å ∆åƒûƒê≈Ω∆åƒö∆ê ≈µ∆µ∆ê∆ö ƒèƒû ∆öƒÇ≈¨ƒû≈∂
s EE EE /E td EE EE^ D s sEƒö≈Ωƒè≈©ƒÇƒö«Äƒê≈Øƒê≈Ω≈µ∆â≈Ω∆µ≈∂ƒö
ƒÇ∆µ«ÜƒÇ∆µ«Ü∆âƒÇ∆ê∆ê
ƒê≈Ω≈µ∆â≈Ω∆µ≈∂ƒö≈µƒÇ∆å≈¨ƒö≈Ωƒè≈©≈∂∆ê∆µƒè≈©∆âƒÇ∆ê∆ê
(a) A sentence without rules
d ≈ö ƒûƒè ƒÇ ∆ê ƒûh Z >≈µ ∆µ ∆ê ∆ö≈∂ ≈Ω ∆öƒê ≈Ω ≈∂ ∆ö ƒÇ ≈ù ≈∂∆â ƒÇ ∆å ƒÇ ≈µ ƒû ∆ö ƒû ∆å ∆ê
d EE EE D Z s EE^ƒöƒû∆öƒê≈Ω≈µ∆â≈Ω∆µ≈∂ƒö≈∂∆ê∆µƒè≈©
ƒÇ∆µ«Ü≈∂ƒû≈êƒö≈Ωƒè≈©
(b) A rule sentence
Figure 2: The dependency tree
For instance, a search of the keyword, lucene, returns more than
3,000projects.Someoftheseprojects( e.g., itext),havebeenusedin
theevaluationsofthepriorrule-miningapproaches[ 79].Column
‚ÄúFiles‚Äù lists the number of Java source files. Column ‚Äú Methods ‚Äù
liststhenumberofsuspiciousmethods.Asuspiciousmethodisa
public method that has either an assert/throwstatement or a pa-
rameter document. Column ‚Äú Ex.‚Äù lists the number of assert/throw
statementsinsidethesuspiciousmethods.Column‚Äú Para.‚Äùliststhe
numberofparametersofthesuspiciousmethods.Column‚Äú Doc.‚Äù
liststhenumber of parameters that have documents.
3.2 Step 1. Identifying Document Rules
Our extraction focuses on the parameter documentation labeled
with @paramtags. PaRu uses the Stanford parser [ 66] to build part-
of-speech (POS) tags and dependencies among words of sentences.
Figure 2 shows the parsing results of two sentences. The grey
annotations under words denote their POS tags ( e.g., NN for noun).
Thearrowsbetweenwordsdenotetheirdependencies.Forexample,
thedobjarrow in Figure 2 implies that the direct object of contain
isparameters. The nsubjarrow shows that the subject of contain
isURL.Moredefinitionsofsuchdependenciesareavailableinthe
Stanfordparsermanual[ 7].AlthoughthesentenceinFigure2ahas
a modal verb (i.e., must), it does not define any rule. This sentence
describes what a root escher container is and its relation to escher
records, but the sentence does not define any constraint on the
containerusage.PaRudeterminesthatasentenceisa document
rule,onlyif(1)thesentenceusesatleastonemodalverb,and(2)
the modal verb does not appear in sub-clauses.PaRu relies on the
tagMDtoidentifyanymodalverbwithin {must,shall,should,can,
may},becauseaccordingtoourobservation,documentrulesusually
containsuchwords.
Some rule-mining approaches [ 54,80] define NLP templates
to mine rules, while some other approaches (e.g., a variable can
benullas defined in Zhou et al.[80]) include canandmayas
keywordswhenminingparameterrules.Thegoalofourstudyis
not to reveal the implementation flaws in existing approaches, but
to provide insights for follow-up researchers. To achieve this goal,
wetriedtorevealasmanyparameterrulesaspossible.Thus,wehad
toconsiderwhatexistingapproacheshavedonewhendesigning
PaRu. When the NLP-based approaches [ 54,80] rely on parsing
semantictemplatestominerules,theymaymissrulesentencesthat
do not match any predefined template. Thus, we designed PaRu
tousemodalverbsinsteadoftemplatestolocaterules.Although
canandmayarelesscompulsorythantheothermodalverbswe1public Quaternion fromAxes( Vector3f[] axis) {
2if(axis.length != 3) {
3throw new IllegalArgumentException("Axis‚ê£a rray‚ê£
must‚ê£have‚ê£three‚ê£elements");
4}
5return fromAxes(axis[0], axis[1], axis [2]);
6}
(a) The code of the fromAxes method
∆âƒÇ∆åƒÇ«ÄœÆ
œ∞—ÅƒÇ∆å∆åƒÇ«á≈Øƒû≈∂≈ê∆ö≈ö
ƒê≈Ω≈∂ƒö≈ù∆ö≈ù≈Ω≈∂ƒÇ≈Øƒè∆åƒÇ≈∂ƒê≈öÕæƒû∆ãÕï∆ö≈Ω≈ù≈ù≈∂ƒöƒû«Ü—ÅœµÕø
œ≠œ∞—Å≈∂ƒû«Å/≈Ø≈Øƒû≈êƒÇ≈Ø∆å≈ê∆µ≈µƒû≈∂∆ö«Üƒêƒû∆â∆ö≈ù≈Ω≈∂
≈ù≈∂«Ä≈Ω≈¨ƒû∆ê∆âƒûƒê≈ùƒÇ≈Ø≈ù≈∂≈ù∆öÕæ^∆ö∆å≈ù≈∂≈êÕø
∆ö≈ö∆å≈Ω«Åœ≥—ÅƒÇ∆å∆åƒÇ«á≈Ø≈ΩƒÇƒöœÆŒÄœ≤ŒÅ
œµ—ÅƒÇ∆å∆åƒÇ«á≈Ø≈ΩƒÇƒöœÆŒÄœ¥ŒÅ
Õô Õô ∆ö≈ö∆å≈Ω«Å≈∂ƒû«Å/≈Ø≈Øƒû≈êƒÇ≈Ø∆å≈ê∆µ≈µƒû≈∂∆ö«Üƒêƒû∆â∆ö≈ù≈Ω≈∂ÕæÕôÕøƒöƒÇ∆öƒÇƒöƒû∆âƒû≈∂ƒöƒû≈∂ƒê«á
ƒê≈Ω≈∂∆ö∆å≈Ω≈Øƒöƒû∆âƒû≈∂ƒöƒû≈∂ƒê«áœ≠
œÆ
œØ
œ∞
œ±
œ≤œ≥
œ¥
(b) The SDG of the fromAxes method
∆âƒÇ∆åƒÇ≈µƒû∆öƒû∆å ƒê≈Ω≈∂ƒö≈ù∆ö≈ù≈Ω≈∂ƒÇ≈Øƒè∆åƒÇ≈∂ƒê≈ö ƒû«Üƒêƒû∆â∆ö≈ù≈Ω≈∂ƒê≈Ø≈ù∆ã∆µƒû≈∂—Öœ¨ ≈∂—Åœ≠
(c) A path template that indicates parameter rules
Figure 3: Our analysis on SDGs
use,becausethetwowordswerementionedbypriorwork[ 80],we
simplyincluded them in our modal verb set for completeness.
3.3 Step 2. Extracting Code Rules
Thebasicprocessofidentifyingparametercoderules. PaRu
is built upon WALA [ 12]. PaRu first scans the Abstract Syntax
Trees(AST)ofsourcecodetolocate throwand assertstatements.
IfamethodAPIimplementationincludessuchastatement,PaRu
further buildsa system dependency graph (SDG) for the API:
Definition 3.1. An SDG is a graph –¥=/angbracketleftV,E/angbracketright, where V is a set
of nodes corresponding to code instructions, and E‚äÜV√óVis a
set of directed edges. Any edge, e.g.,/angbracketlefts1,s2/angbracketright‚ààE, denotes a data or
control dependency from s1tos2.
Definition3.2. Anexception clique isanSDGsubgraph,that
correspondsto an exception-throwing statement or assertion.
ToconstructanSDGthatvisualizesanycontrolordatadepen-
dencieswithinJavacode,WALAfirsttranslatessourcecodeinto
its intermediate representation called IR [ 10] by converting each
sourcelinetooneormoreIRinstructions.Next,WALAcreatesa
node for each instruction, and connects nodes with directed edges
based on the control or data dependencies between instructions.
FortheexampleshowninFigure3,anexception-throwingstate-
ment (see Line 3 in Figure 3a) is converted to three instructions,
corresponding to three nodes in an SDG (see nodes 4/circlecopyrt,5/circlecopyrt, and6/circlecopyrt
in Figure 3b). We use exception clique to refer to the subgraph
that consists of these three nodes and any edges in between (see
dashed region in Figure 3b). Similarly, WALA translates each as-
sert statement into three IR instructions, whose nodes compose an
exception clique similar to the one shown in Figure 3b. The onlydifferenceisthatanassertstatementreplaces
4/circlecopyrtwithanodefor
theAssertionError creationinstruction.Todetectcoderules,PaRu
locates both types of exception cliques in SDGs.
902An Empirical Study on API Parameter Rules ICSE ‚Äô20, May 23‚Äì29, 2020, Seoul, Republic of Korea
Algorithm1: findAllPaths Algorithm
Require:
snis a source node
tnis a target node
Ensure:
pathsdenotes all the paths from sntotn
1:nextNodes ‚Üêsn.successors
2:fornextNode ‚àànextNodes do
3:ifnextNode .equal(tn)andpath .isValid()then
4: stack‚Üênew Stack
5:fornode‚ààpathdo
6: stack .add(node)
7:end for
8: paths .add(stack)
9:else if nextNode /nelementpathandpath .isPartialValid ()then
10: path .push(nextNode )
11: fi n d A l lPa t h s (nextNode ,to)
12: path .pop()
13:end if
14:end for
Given the method implementation of a public API, PaRu first
identifiesthedeclaredparametersinthemethodheaderandlocates
all exception cliques in the body. For each located exception clique
in SDG, PaRu checks whether the clique is reachable from any pa-
rameter,i.e.,whetherthereisanypaththatstartsfromaparameter
declaration and goes through the exception clique. When such a
pathisfound,PaRuconcludesthattheexceptioncliquedependson
the parameter and there is an implicit constraint on the parameter
value.Figure3cshowsanexemplarpaththatPaRucanfind.The
path starts with the declaration of parameter n, goes through an
if-condition that checks the parameter value range, and ends with
an exception clique that prints ‚Äú n=1‚Äù in the error message.
Algorithm1showsthedetailsofsearchingforallthevalidpaths
from a given source node to a target node. Before adding a path to
thesetofvalidpaths,PaRuchecksthepathatLine3.However,ifit
only checks the path at Line 3, it has to search many invalid paths
betweenLine10andLine12.Aseachstatementissplitintomultiple
nodes in an SDG, SDGs can become quite large if a method is long.
Toreducethesearcheffort,weaddanotherchecktoLine9.Atthis
line,itisinfeasibletofullydeterminewhetherapathisvalid,but
we can remove many invalid paths. For example, if we find that an
if-conditionhasnodatadependencyonanyparameter,wecanstop
the exploration of its successors. As a path is incomplete at Line 9,
atthispoint,PaRuconcludesthatapathisinvalidiftheincomplete
path is not a prefix of a valid path. As shown in Figure 1a, code
rules can have rule sentences. After a valid path is extracted, PaRu
further extracts rule sentences from the thrown message, and such
sentencesare later manually analyzed (Sections 4.1.1 and 4.2.1).
Slicing.Algorithm 1 is less effective to find valid paths, if a
graphisquite large. Forexample, when searchingfor all thevalid
paths from 1/circlecopyrtto4,5,6in Figure 3b, Algorithm 1 will explore the
paths such as 1/circlecopyrt‚àí‚Üí7/circlecopyrtand1/circlecopyrt‚àí‚Üí8/circlecopyrt. When an SDG is large, the
explorationistime-consuming.Weiser[ 72]proposedtheconcept
ofprogramslicing.Givenaprogramlocation landavariable v,the
backward slicing intends to find all the statements of the programTable 2: The precision, recall, and f-score of PaRu.
Name Precision Recall F-score
commons-io 98.0% 94.2% 96.1%
pdfbox 92.9% 88.1% 90.4%
shiro 95.5% 96.9% 96.2%
itext 89.9% 94.7% 92.2%
poi 98.8% 96.4% 95.2%
jfreechart 95.3% 83.6% 89.1%
lucene 85.2%100.0% 92.0%
asm 98.9% 96.9% 97.9%
jmonkey 93.8% 88.4% 91.0%
thatcanaffectthevalueof vatl.Foreachexceptionclique,PaRu
locatesthebackward slicebeforeitsearchesforall validpaths,in
order to save the search effort. In particular, WALA has a program
slicer[11].Givenastatementand anSDG,theslicerfindsallthe
statements that appear in the backward slice of the statement. For
eachslice,PaRubuildsasmallerSDGthatcontainsonlynodesof
theslice.AfterSDGsaresliced,forFigure3b,Algorithm1doesnot
explore7/circlecopyrtor8/circlecopyrt, since they do not appear in the sliced SDG.
3.4 The F-scores of PaRu
We werecurious how effectivelyPaRucan locate parameter rules,
so we constructed a ground truth data set of parameter rules for
some Java files, and applied PaRu to those files to automatically
locaterules.BycomparingPaRu‚Äôsreportsagainstourgroundtruth,
we assessed the precision, recall, and f-score of PaRu.
Thesetting. The third and the fourth authors are two PhD stu-
dentsinComputerScience,whohavemorethanthreeyearsofJavacoding experience. To construct the ground truth data set for PaRu
evaluation,thetwostudentsread sourcefilesinTable1,andtried
their best to manually recognize parameter rules in those files. As
thesestudentsdidnotreadorwriteanysourcecodeforPaRu,so
theyhavenobiastowardsPaRuwhenbuildingthedataset.Such
settingensures the objectiveness of PaRuevaluation.
Although some prior approaches [ 28,54] mine parameter rules
fromdatasourcesotherthansourcefiles(e.g.,executionprofiles),
we believe our ground truth of parameter rules is reasonably good
for two reasons. First, as illustrated in Figure 1, API documents are
automaticallygeneratedfromtheJavadoccommentsincode,sothe
rulesdescribedorimpliedbysourcefilescanalwayscoverthose
rules inAPI documentation.Second, inhigh-quality software,the
source files usually define or validate constraints on parameters
before using those parameters. It is meaningful to rely on software
implementation to distill parameter rules. Thus, we decided to
manuallyinspectsourcecodeonly,insteadofalsoexaminingother
informationresources simultaneously.
Specifically, the two students manually analyzed 20 randomly
selectedsourcefilesineachproject.Foreachparameter pofmethod
APIm,thestudentsreadthedocumentandimplementationof mto
decide whether phas any document or code rule. Since the value p
may be tested by code inside mor any method called by or calling
m, the students examined mtogetherwith methods that have any
caller-callee relationship with mto infer code rules. After the man-
ualinspection,inourgroupmeeting,thestudentsdiscussedtheir
results to reach a consensus. In total, the two students manually
903ICSE ‚Äô20, May 23‚Äì29, 2020, Seoul, Republic of Korea Hao Zhong1, Na Meng2, Zexuan Li1, and Li Jia1
Table 3: Top ten verbs.
commons-io pdfbox shiro itext poi jfreechart lucene asm jmonkey
be (153) be (35) be (82) be (95) be (157) be (68) be (368) be (102) be (218)
compared (6) include (10) contain (2) retrieved (4) exceed (5) used(36) >=(55) have (6) have (29)
>=(5)enforced (6) used/use (3) have (3) react (4) >=(22)have (21) used (3) loaded (9)
match (2) have (5) represented (1) reuse (3) supplied (4) >(8) <=(14)delegate (3) >(5)
contain (2) use/used (5) create (1) registered (2) aligned (4) contain (5) >(11)updated (1) add (4)
called (1) compressed (4) retained (1) contain (2) belong (3) have (3) change (10) store (1) filled (4)
failed (1) defined (3) null (1) submitted (2) >=(3) <=(2)contain (9) create (1) match (4)
write (1) point (2) examined (1) fit (2) used (3) supplied (2) use (6) contain(1) fall (3)
-support (1) queried (1) opened (1) havel (3) add(2) process (6) updated (1) assigned (3)
-contain (1) retained (1) use (1) override (2) match(1) match (3) sorted(1) contain (2)
identified 135 documented rules and 539 code rules, which were
used as the gold standard. For the 180=20 √ó9 source files, we ap-
pliedPaRutolocateanydocumentorcoderule.Wethencompared
thelocated rulesagainst thegold standardto calculateprecisions,
recalls, and f-scores forPaRu.
Results.Table 2 shows the evaluation results. For 8 out of the 9
projects,PaRuacquiredf-scoreshigherthan90%.Bothprecision
andrecallratesaregenerallyhigh(i.e.,85.2%-98.9%precisionand
83.6%-100%recall).Therecallsof PaRuarenot100%,becausesome
rules can only be manually identified in nonstandard ways, but are
very challenging to be located by any automated tool. For instance,
aparameterruleissometimesdescribedbycommentsofthewhole
method, but not by the Javadoc comment of that parameter. As
Apache projects follow strict regulations, based on our evaluation
resultsshowninTable3,thenonstandardscenariosarerare,and
PaRuhasdetectedmostparameterrules.Ourresultsimplythattherules reported by PaRu are very likely to be representative, and we
can rely on these rules to build a taxonomy of parameter rules.
4 EMPIRICAL STUDY
With PaRu, we conducted an empirical study to explore our re-
search questions listed in Section 1. We used PaRu to extract pa-
rameter rules from the dataset in Section 3.1. In the 14,392 files
from 9 real projects, PaRu identified in total 5,334 parameters to
haverules.Fromtheseparameterswithrules,PaRuextracted1,688
rule sentences that are described in either Javadoc comments or
exception/assertionmessages. Thereare only187 parametersthat
have both document rules and code rules.
Wemanuallyexaminedthe1,688rulesentencesandrulesrelated
to the above-mentioned 187 parameters. The manual inspectionprocedure took several weeks. This section presents our manual
analysisprotocolsandinvestigationfindings.Moredetailsofour
results and the gold standards are listed on our project website:
https://github.com/drzhonghao/parameterstudy.
4.1 RQ1. Rule Categorization
4.1.1 Protocol. ToexploreRQ1,wemanuallyclassifiedallthe1,688
rulesentences.Here,ifaparameterruleisextractedwithnorule
sentence identified (e.g., an exception thrown with the empty mes-
sagebody),we do not inspectthe rule, becauseit is tooexpensive
to understand a parameter solely based on source code. We first
classified rule sentences by the verbs which follow the extractedmodalverbs.Althoughtheresultrevealshowprogrammerswrite
rulesentences,werealizedthattheverbsdonotpresentanaccu-
rate classification. To handle the problem, we manually read all
rule sentences, and classified them based on the semantics. During
the manual inspection, the first and the third authors prepared the
initial inspection results. The other authors checked the results,
until they came to an agreement on all the results.
4.1.2 Result. Table 3 shows the top ten verbs. Our result shows
that developers use limited verbs to define parameter rules. The
commons-io projectevendoesnothavetenverbs.Inthistable,we
highlightverbsthatappearinmorethanhalfoftheprojects.Ac-
cording to this definition, only four verbs are commonly used: ‚Äúbe‚Äù,
‚Äúcontain‚Äù, ‚Äúhave‚Äù, and ‚Äúuse‚Äù. It seems that library developers ex-
ploited certain verbs much more frequently than other verbs when
definingparameterrules,soitisinfeasibletodistinguishparame-
ter rules only based on verbs. Instead, Table 4 shows the results of
manualinspection.Intotal,weidentifiedsixtypesofrulesentences:
C1.Null. Thiscategoryisaboutwhetheraparameterisallowedor
disallowedtobe null.Forinstance,thecodeinFigure1ashowsthat
anexceptionisthrownifthe fieldparameteris null;therelated
rulesentenceis‚Äúmustnotbenull.‚ÄùAdditionally,the formatCellValue
method of poihas a document rule: ‚ÄúThe cell (can be null)‚Äù. C1
correspondstotwocategoriesdefinedbyZhou etal.[80],including
‚ÄúNullnessallowed‚Äù and ‚ÄúNullness not allowed‚Äù.
C2. Range .Thiscategoryfocusesonthelegalrangesofparame-
tervalues. Whendefiningranges,a rulesentence candefineboth
maximum and minimum values, such as ‚Äú latitude value: must
be within standard +/-90 coordinate bounds.‚Äù Meanwhile, a rule
sentence can alsodefineonly the minimumor maximum, such as
‚ÄúmaxMergeCount should be at least 1.‚Äù. C2 corresponds to the ‚Äúrange
limitation‚Äùcategory of Zhou et al.[80].
C3. Value. This category is about legal values of parameters. For
example, a rule sentence goes ‚ÄúFor STRING type, missingvalue
must be either STRING_FIRST or STRING_LAST.‚Äù The existing ap-
proach Daikon [ 28] monitors program execution status at runtime,
collects values of variables, and infers value invariants accordingly.
Therefore, it is likely that Daikon can identify rules of C1-C3.
C4. Format. Thiscategoryfocusesontheformatsofparameters.
An exemplar rule sentence is ‚Äú csvKeyValueDelimiter must be ex-
actly 1 character.‚Äù Zhou et al.[80] defined a ‚Äútype restriction‚Äù cate-
gorytodescribetyperequirementsonparameters,suchas‚Äúvalue
904An Empirical Study on API Parameter Rules ICSE ‚Äô20, May 23‚Äì29, 2020, Seoul, Republic of Korea
Table 4: Rule sentences
Name NullRange ValueFormat Relation Others
commons-io 141 22 0 3 4 0
pdfbox 13 6836 0 3
shiro 78 2011 0 1
itext 52 828 8 011
poi 54 5213 62 13 13
jfreechart 677 516 1 4
lucene 87274 29 55 30 45
asm 14 557 18 620
jmonkey 54 6814103 36 22
total 499 514154 312 90119
% 29.6% 30.5% 9.1%18.5% 5.3% 7.0%
ofkeymustbeanboolean.‚ÄùGenerallyspeaking,typerestrictions
are about formats of parameters, so we map this ‚Äútype restriction‚Äù
category to C4. However, the scope of C4 is broader. More samples
are as below.
(1)xmpshould end witha processing instruction.
(2)Sheetnamesmustnot begin or end with (‚Äô).
(3)uidmust be byte[16].
(4) The moveFrom must be a valid array index.
(5) Value data sourcemustbe numeric.
(6)Thelengthofthedatafora ExObjListAtom mustbeatleast4
bytes.
Since format-related rule sentences have diversified descriptions, it
seems to be very challenging to define one or more templates to
matchall thosesentencesforautomaticrulecomprehension.
C5.Relation. Thiscategoryisaboutrelationsbetweenparameters.
For example, a rule sentence defines the lengths of two parameters
as ‚ÄúpolyLats and polyLons must be equal length. ‚Äù More samples
are shown below:
(1)originand regionmustboth be arrays of length 3.
(2)UserEditAtom and PersistPtrHolder mustexistandtheiroff-
setneed to match.
(3)Index of last row (inclusive), must be equal to or larger than
firstRow.
(4)maxItemsInBlock must be at least 2*( minItemsInBlock -1).
(5)upper value‚Äôs type should be the same as numericConfig
type.
(6) the number of values of ablock, must be equal to theblock
size of the BlockPackedWriter which has been used to write
the stream.
C6. Other. This category includes miscellaneous rules that do not
belongtoanyoftheabove-mentionedcategories. Forexample,arule
sentence defines the synonyms of parameters: ‚ÄúSynonyms must be
across the samefield.‚Äù More samples are as follows:
(1)Afilename toviewmustbesuppliedasthefirstargument,
but nonewasgiven.
(2)RC4must notbe used with agile encryption.
(3) SplineStartmustbe preceded by another type.
(4) features must be present for TextLogitStream .
(5)This must be well-formed unicode text, with no unpaired
surrogates.Table 5: Rule sentences from thrown messages.
Name NullRange ValueFormat Relation Other
commons-io 43 16 0 1 00
pdfbox 4 4810 01
shiro 76 20 8 01
itext 8 80 0 07
poi 31 46 343 11 5
jfreechart 327 410 04
lucene 78198 18 32 2718
asm 11 52 5 12
jmonkey 51 53 369 3421
total 305 359 38178 7359
% 30.1% 35.5% 3.8%17.6% 7.2%5.8%
(6) input automaton mustbe deterministic.
Amongtheabovecategories,C5andC6aresolelydetectedby
PaRu. It is more challenging to define templates of C5 and C6 than
thoseofotherrules.Thetemplatesoftheothercategoriestypically
define usages of single variables, but the templates of C5 defineusages of multiple variables. The prior approaches (e.g., Ernst et
al.[
28]) reply on frequencies to mine parameter rules, but the
supports of C6 are too low to be mined.
Table 4 presents the distribution of rule sentences among our
six categories. These sentences are from either Javadoc or code.
The rule categories in our taxonomy are mutually exclusive. If a
parameterhasmultiplerulesentences,eachsentenceisanalyzed
andclassifiedindependently.Accordingtothistable,C1(Null)is
thedominantrulecategoryinprojects commons-io ,shiro,and itext.
C3 (Value) is the dominant category in project asm. C4 (Format)
dominates the sentences in projects pdfbox,poi, and jmonkey.I n
total, the three categories ‚ÄúNull‚Äù, ‚ÄúRange‚Äù, and ‚ÄúValue‚Äù account for
69.1% of rule sentences.
Finding 1. In total, 69.1% of rule sentences define simple rules
suchas nullvalues,rangelimits, and legal values.
We were also curious what types of parameter rules are usually
enforced in code, so we reorganized our manual analysis resultsand constructed Table 5 to illustrate the rule distribution among
code of different projects. Overall, the rule distributions shown in
Table 5 are similar to those shown in Table 4. For instance, the top
threecategoriesinTable5includeC1,C2,andC4,whichcategories
separately count for 30.1%, 35.5%, and 17.6% of the rules in thrown
messages.Meanwhile,thetopthreecategoriesinTable4arealsoC1,C2,andC4,buttheirpercentagesareslightlydifferent:29.6%,30.5%,
and 18.5%. Interestingly, C3 takes up only 3.8% of the sentences in
thrownmessages,butcountsfor9.1%ofallinspectedrulesentences.
This discrepancy indicates that developers usually document more
ValuerulesbutenforcefewerValuerulesincode,probablybecause
itistediousanderror-pronefordeveloperstoenumerateall(il)legal
values of a parameter for checking.
Inbothtables,C3,C5,andC6havemuchfewerrulesthanthe
other three categories. It is tedious and time-consuming for devel-
operstowritecodeandenforcecertainrules(e.g.,C6).Forinstance,asshowninFigure6a,‚ÄúTheStringsmustbeorderedastheyappear
inthedirectoryhierarchyofthedocument...‚Äù.Thisrulesentence
belongs to C6 and it specifies a particular ordering of strings in the
905ICSE ‚Äô20, May 23‚Äì29, 2020, Seoul, Republic of Korea Hao Zhong1, Na Meng2, Zexuan Li1, and Li Jia1
1/‚àó‚àó...
2‚àó @param firstSheetIndex the scope, must be ‚àí2f o ra d d
‚àíin references ...
3‚àó/
4public int addRef( intextBookIndex , int
firstSheetIndex , intlastSheetIndex) {
5_list.add( newRefSubRecord(extBookIndex ,
firstSheetIndex , lastSheetIndex));
6return _list.size() ‚àí1;
7}
8/‚àó‚àó a Constructor for making new sub record‚àó/
9public RefSubRecord( intextBookIndex , int
firstSheetIndex , intlastSheetIndex) {
10_extBookIndex = extBookIndex;
11_firstSheetIndex = firstSheetIndex;
12_lastSheetIndex = lastSheetIndex;
13}
(a) Only document rules
1/‚àó‚àó
2‚àó replaces the internal child list with the contents
of the supplied <tt>childRecords</tt>
3‚àó/
4public void setChildRecords(List< EscherRecord>
childRecords) {
5if(childRecords == _childRecords) {
6 throw new IllegalStateException("Child‚ê£records‚ê£
private‚ê£data‚ê£m ember‚ê£has‚ê£ es caped");
7}...}
(b) Only code rules
Figure 4: Unmatched parameters rules
parameterarray components .Althoughthedescriptionmakessense,
it is difficult to implement the parameter validation logic.
Finding 2. Thetopthreecategoriesofparameterrulesinclude
‚ÄúNull‚Äù, ‚ÄúRange‚Äù, and ‚ÄúFormat‚Äù; the other three categories contain
a lot fewer rules, probably because those rules are harder to
document and implement.
4.2 RQ2. Rule Distribution
4.2.1 Protocol. ToexploreRQ2,wefirstinvestigatedhowthe5,334
parameter rules localized by PaRu distribute among the subject
projects. Next, for the 187 parameters with both document andcoderules,wefurtherexaminedhowwellthetwokindsofrules
for each parameter match each other. As we did in RQ1, the first
and the third authors prepared the initial inspection results. The
other authors checked the results, until they came to an agreement
on all results.
4.2.2 Result. Amongthe5,334parameterruleslocatedbyPaRu,
550parametersonlyhavedocumentrules;4,597parametersonly
have code rules; 108 parameters have document rules matchingcode rules; and 79 parameters have unmatched rules. Figure 5 il-lustrates the rule distributions among projects. In the figure, thehorizontal axis represents the breakdown of parameters in each
project,dependingon(1)whetheraparameterhasoneortwokindsofrulesand(2)whetherthetwokindsofrulesmatchifaparameter
hasboth.Withmoredetails,‚Äúonlydoc‚Äùdenotesparameterswith
only document rules; ‚Äúonly code‚Äù denotes parameters with only
code rules; ‚Äúmatched‚Äù denotes parameters with matched rules; and
‚Äúunmatched‚Äù denotes parameters with unmatched rules.FRPPRQVLR
SGIER[
VKLUR
LWH[W
SRL
MIUHHFKDUW
OXFHQH
DVP
MPRQNH\
     RQO\GRF
PDWFK
QRWPDWFK
RQO\FRGH
Figure 5: The distribution of detected conflicts
We found that most parameters have only one kind of rules.
Figure 4 shows method samples from poi. Specifically, Figure 4a
containsdocumentrulesonly,whichrulesarenotenforcedincode.
The addRefmethodhasthreeparameters,anditsdocumentdefines
a rule for the firstSheetIndex parameter. The rules define that
the parameters must be -2, for add-in references. However, the
codeofthemethoddoesnotcheckthetwoparameterrules.The
methodcallsthe RefSubRecord method.InFigure4a,wepresentthe
calledcode.Thismethoddoesnotcheckitsparameterseither.In
contrast, Figure 4b shows a parameter rule that is not documented
but implemented in the code. The setChildRecords method throws
an exception, when an input is identical to its stored record, but its
document does not define the parameter rule.
Finding 3. In total, 86.2% of parameters have only code rules,
and 10.3%of parameters have only document rules.
Researchershaveproposedvariousapproachestorecommend
APIdocuments[ 24]andtominespecificationsfromdocuments[ 79].
Our results reveal a practical problem for these approaches, which
is that API parameter rules are usually not documented. Novick
and Ward [ 52] complained that programmers are reluctant to read
documentsormanuals.Probablyduetothisfact,insteadofwriting
documents,APIdevelopersoftenimplementparameter-checking
logic in code, and warn client developers of any invalid API param-
eter viaexceptions or assertions.
Although exceptions and assertions can potentially assist client
developers, they may fail to warn programmers due to various
issues.First,programmerscannotseeanythrownmessageoras-
sertion failure, if exceptions/assertions are hidden or screened. For
example,DERBY-5396[ 3]reportsthatanexceptionisswallowed.
Second,clientdevelopersmayfinditdifficulttounderstandwhy
exceptions are thrown. Among the examined code rules shown
inFigure5,only19%ofruleshaverulesentencestoexplicitlyex-
plain why exceptions are thrown. Finally, developers need to have
high-quality test cases with good test coverage, in order to trigger
exceptions/assertions related to API parameter usage. However, it
isveryunlikelythatclientdeveloperscanalwaysdevelopgoodtest
suitesto satisfy the need.
Figure5showsthatexcept commons-io ,lessthan4%ofparameters
have both document rules and code rules (i.e., either matched or
unmatched). In addition, we found that unmatched rules do not
necessarilyimplybugs;theywereintroducedwhenAPIdevelopers
specifiedonesetofrulesincommentsbutimplementedadistinct
setofrulesincode.Forexample,Figure6ashowsamethodfrom
poi. The method description defines three document rules ( e.g.,
theinputlistmustbeordered),butthecodechecksnoneofthese
rules. Instead, the code checks whether the input list contains null
906An Empirical Study on API Parameter Rules ICSE ‚Äô20, May 23‚Äì29, 2020, Seoul, Republic of Korea
1/‚àó‚àó...
2‚àó@param components the Strings making up the path to a
3‚àódocument. The Strings must be ordered as they appear
4‚àóin the directory h ierarchy of the the document ‚àí‚àíthe
5‚àófirst string must be the name of a directory in the
6‚àóroot of the POIFSFileSystem , and every Nth (for N>1)
7‚àóstring thereafter must be the name of a d irectory in
8‚àóthe directory identified by the (N ‚àí1)th string ...
9‚àó/
10public POIFSDocumentPath( finalString [] components)
throws IllegalArgumentException{ ...
11for(intj = 0; j < components.length; j++){
12if((components[j]== null) ||(components[j].length()
==0)){
13 throw new IllegalArgumentException("components‚ê£
cannot‚ê£contain‚ê£ null‚ê£or‚ê£ empty‚ê£ strings") ;
14}...}}
(a) Document rules are more detailed
1/‚àó‚àó...
2‚àó @param file ... , must not be null
3‚àó/
4public ... openInputStream( finalFile file) ...{
5if(file.exists()){
6if(file.isDirectory()){
7 throw new IOException("File‚ê£ ... ‚ê£is‚ê£a‚ê£ directory");
8}
9if( file .canRead()== false){
10 throw new IOException("File‚ê£ ... ‚ê£cannot‚ê£be‚ê£read");
11}
12}else{
13throw new FileNotFoundException("File‚ê£ ... ‚ê£does‚ê£not‚ê£
exist");
14}...}
(b) Code rules are more detailed
Figure 6: Conflicts are not always bugs
values, which rule is not mentioned in Javadoc. Figure 6b shows
anotherexample,whichisfromtheproject commons-io .Themethod
description defines only one document rule, but the code checks
three other rules.
Finding4. Intotal,3.5%ofparametershavebothdocumentrules
and code rules. Only 1.5% of parameters have inconsistent rules,
and suchinconsistenciesare often not bugs.
Zhouetal.[80]complainedthatitisofteninfeasibletoextractac-
curate method calls when they appear in the branches of condition
statements. As a result, they skip all constraints that are related to
suchmethodcalls,andthusignoretheconflictsbetweendocuments
andcodeimplementationsofcorrespondingparameters.Thedistri-butionofparameterrulesrevealsthatevenifanapproachcaninfer
allcorrectruleconditions,theapproachstillcannotdetectmany
rule conflicts because the two types of rules have little overlap.
Meanwhile,ourresultsalsohighlighttheimportanceofconflictde-tectiontools,suchastheonebuiltbyZhou etal.[
80].Programmers
seemreluctanttohaveconsistentrulesbetweenJavadoccomments
and source code, probably because it is challenging for them tomaintain the rule consistency. Conflict detection tools can assist
developerstomaintaintheconsistency.Therefore,suchtoolsare
likely to (1) encourage programmers to document more parameter
rules,and(2)reducethetechnicalbarriersforlibraryAPIadoption.
We found that some methods have document rules but no code
rules,mainlybecausethereareflawsinsourcecode.Namely,pro-
grammersdescribethoserulesinJavadoc,andwaitfortheflawstobefixedbeforeimplementingthoserulesincode.Suchscenarios
indeed introduce technical debts. It will be interesting to further
explore these scenarios in the future.
5 THE INTERPRETATION OF OUR FINDINGS
In this section, we interpret our findings:
Datasources. ResearchersminedAPI rulesfromvariousdata
sourcessuchasclientcode[ 28],documents[ 79],andAPIcode[ 80].
Ourempiricalstudyfocusesonasingledatasource‚Äîsourcefiles,
becausewebelievethissourcetobesufficienttocovermostAPIparameter rules extractable from other data sources. There aretwo reasons to explain our insight. First, lots of API documentsabout parameter usage are automatically generated from source
files (i.e., from Javadoc comments). Second, when client developers
invoke APIs, they usually refer to library documentation and/or
API code for correct API usage. Additionally, Finding 4 shows that
the extracted document rules and code rules have little overlap.
This observation justifies our study approach that analyzes both
codeandcommentsofAPImethods,insteadofonlyinspectingone
type of data in source files.
Miningtechniques. As introduced in Section 2.2, existing ap-
proaches typically use predefined parsing semantic templates to
mineparameterrules,whilewetookahybridapproach(i.e.,refined
keyword-based search + manual inspection) to mine rules. Finding
1showsthatthetemplatesofexistingtoolscanhandleatmost69.1%
of parameter rules. Unfortunately, adding more templates does not
necessarilyhelpcurrenttoolstoretrievemorerules,becausethe
remaining rules seldom present common sentence structures. If
toolbuilderswouldliketodefinespecializedtemplatestocapture
remaining rules, it is quite like that (1) many complicated tem-
plateshavetobedefined,and(2)manyirrelevantsentencesmay
be wrongly extracted. As mentioned by Legunsen et al.[36], rules
mined based on templates can be superficial or even false.
Hiddenandchangingrules. Formorethanhalfofthestudied
source files, PaRu did not localize any parameter rule. However,it is unsafe to claim that all these source files have no rule at all.
Shietal.[
64]showthatevenAPIdevelopersmaybeunawareof
parameter rules sometimes; once developers realize any missing
rules,theyhavetorewritethedocumentationand/orcodetoappend
rules.Insuchscenarios,wemaymissparameterrulesbymining
source files.
6 DISCUSSION ON RELATED TOOLS
Motivation. To assess the effectiveness of existing rule mining
tools,wechosenottoapplytoolstoourdataset,becausedirectcom-
parisonsrevealproblemsofspecifictoolsbutsuchproblemsmay
be not worth further investigation by future research. Instead of
determiningtheeffectivenessofaspecifictool,researchers[ 76,77]
have estimated the potential of the tool by comparing its techni-
calassumptionswiththenatureofdata.Forinstance,Zhongand
Su [77] compared manual fixes with the methodology design of
automatic program repair [ 29] to estimate the potentials of the
state-of-the-arttools.In ourresearch, wealso conducteda similar
theoreticalcomparisonbetweenexistingparameterrulesandthe
907ICSE ‚Äô20, May 23‚Äì29, 2020, Seoul, Republic of Korea Hao Zhong1, Na Meng2, Zexuan Li1, and Li Jia1
potentialsofcurrentruleminingtools.Aslongasthemethodde-
sign of a tool can reveal some rules in one category, we considered
the tool to be able to handle the whole category given comprehen-
sive extensions. The theoretical comparison puts higher bars for
ustoclaimourresearchnovelties,butcaneffectivelyrevealnew
research directions and inspire new tool design.
Comparison between PaRu and current rule mining tools.
Although PaRu is similar to current tools in certain aspects, it is
different in terms of the research objectives, methodologies, and
someapproachdesign choices.
As for research objectives, prior work reveals parameter rules
for(1)dynamicrulechecking[ 23,28,49,70],(2)consistencycheck-
ing[80],or(3)automaticdocumentcomprehension[ 54].Researchers
focused on certain types of rules, but never explored the gap be-
tweenthe rulesinthe wildandthose extractablebycurrent tools.
We designed PaRu to localize as many candidate rules as possible,
in order to identify any rule category overlooked by prior research.
As for methodologies, existing tools automate both rule localiza-
tion andrule comprehension, while PaRu automates rule localiza-
tiononly.BecausePaRudoesnotneedtoautomaticallycomprehend
rules,itsapproachbasedonmodalverbsismoreflexiblethanprior
work [49,80]. Consequently, PaRu can locate more candidate rules
thanpriorwork,many of which rules maynot match any parsing
semantictemplatedefined before.
As for design choices, Nguyen et al.extracted the if-conditions
beforeAPImethodinvocationsinclientcode,andthenleveraged
thosefrequentlycheckedconditionstoinferparameterrules[ 49].
We designed PaRu to scan library implementation instead of the
client code of library APIs, because there can be APIs that have
notbeeninvokedbyanyclientbutstillhaveparameterrules.Ad-
ditionally, Zhou et al.[80] analyzed code statically to reveal the
intra-proceduralcontrol/datadependencyrelationship,whilePaRu
conductsinter-proceduralprogramdepenencyanalysistogather
more context information and ensure higher analysis accuracy.
Theoretical assessment of the effectiveness by current rule
miningtools. JML[19]includeswrittenparameterrulessuchas
pre-andpostconditions.Tocalculatehowmanyrulescanbemined,thepriorapproaches(e.g.,Nguyen etal.[
49])typicallyconsiderJML
as the golden standard of their evaluations. Due to the heavy man-
ualefforts,JMLdefinesparameterrulesofonlylimitedJ2SEclasses.
In addition, as writing JML specifications is too time-consuming
anderror-prone,theauthorsofJML[ 19]mentionedthattheywrote
JML specifications based on what were inferred by Daikon. As a
result,JMLcan bebiasedandincomplete. Althoughouridentified
rules are not fully correct, Table 2 shows that their f-scores are
reasonablyhigh.Wehavereleasedouridentifiedparameterrules
on our website. If researchers remove all wrong parameter rules,the remaining rules can enrich the gold standard of JML, and re-
searchers can evaluate their tools on the enriched gold standard to
explore the limitations of such tools.
Daikon [28] is the state-of-the-art tool for mining invariants.
Section 5.5 of its manual [ 6] lists the templates of its supported in-
variants.Accordingtothismanual,Daikonhasthepotentialtomine
theparameterrulesinthe‚ÄúRange‚Äùcategory(e.g.,the EltUpperBound
template),the‚ÄúValue‚Äùcategory(e.g.,the EltOneOf template),andthe‚ÄúRelation‚Äù category ( e.g., the Equality template). For the ‚ÄúNull‚Äù cat-
egory,Daikonhasarelated EltNonZero templatetodefine‚Äú x/nequal0‚Äù.
It may be feasible to extend this template to detect parameter rules
inthe‚ÄúNull‚Äùcategory.Basedontheabovetemplates,weestimate
that Daikon has the potential to mine 74.5% of parameter rules.However, adding more templates may be sufficient to make only
minor improvements, sincethe remainingrules arefractional. For
example,weinspectedrulesentencesofthe‚ÄúFormat‚Äùcategory,and
wefoundthatitisinfeasibletosummarizethemintolimitedrule
templates. Polikarpova et al.[56] found that Daikon inferred about
half of theirmanually written rules. Their analyzed rulesare loop
invariants,preconditions,postconditions,andclassinvariants.Typi-cally,theserulesfallintothe‚ÄúNull‚Äù,‚ÄúValue‚Äù,and‚ÄúRange‚Äùcategories.
Consideringtheirresults,inpractice,Daikoncanmineabout30%
of parameter rules, which leaves adequate space for improvement.
Zhouetal.[80]definedfourtemplatestolocateparameterrules,
i.e., nullness not allowed, nullness allowed, type restriction, and
range limitation. In Table 4, ‚ÄúNull‚Äù and ‚ÄúRange‚Äù categories account
for 60% of parameter rules. We consider type restrictions to belong
to the ‚ÄúFormat‚Äù category, and this category accounts for additional
18.5%ofparameterrules.AsshowninSection4.1,‚ÄúFormat‚Äùcontains
more types of parameter rules than type restrictions. As a result,
the approach by Zhou et al.has the potential of mining about 70%
of parameter rules.
Nguyenetal.[49]extractedpreconditionsAPImethodinvoca-
tions in client code. Similar to PaRu, the technique can locate a
parameterruleiftheparameterischeckedinclientcode.Afterapa-
rameter rule is located, Nguyen et al.propose techniques to merge
conditions and to infer non-strict inequality preconditions. These
techniques are limited to ‚ÄúNull‚Äù, ‚ÄúRange‚Äù, and ‚ÄúValue‚Äù in Table 4,
sinceothertypesofparameterrules(e.g.,formats)aredifficultto
bemerged.Intotal,theapproachbyNguyen etal.canpotentially
identify69.1% of parameter rules.
7 THREATS TO VALIDITY
Threatstointernalvalidity. Ourmanualinspectionofparam-
eter rules may be subject to human bias. As introduced in Sec-
tion4.2.1,ifaparameterhasbothdocumentrulesandcoderules,
we have to manually determine whether they are identical, which
can introduce errors. As Finding 4 shows that less than 3.5% of
parameters can have unmatched rules, although we need more ad-
vanced techniques to eliminate the threat, the impact of this threat
is low. Additionally, some identified document rules and code rules
may be incorrect due to random errors. To reduce the threat, we
released all found parameter rules on our website. Researchers can
inspect the results and help us further reduce the threat.
Threatstoexternalvalidity. Althoughweanalyzedthousands
of files of nine popular libraries, the subjects are limited and all in
Java. In addition, eight out of the nine projects are from Apache,
which has a more strict coding convention than other open source
communities.Wecanmitigatethethreatbyincludingmoresubject
projects [ 48], and exploiting more sources to extract parameter
rules [55]. However, our major findings may not change much,
since we select different types of projects. Another threat is con-
cerning code rules without any rule sentence. In our study, we did
not manually inspect such rules. Although the limitation has no
908An Empirical Study on API Parameter Rules ICSE ‚Äô20, May 23‚Äì29, 2020, Seoul, Republic of Korea
impactonFinding3,itcaninfluencethegeneralizabilityofFind-
ings1 and2.Zhou etal.[80]showed thatevenrecent approaches
cannotformalizeaccuratecoderulesfromAPIcode.Weneedmore
advanced techniques or nontrivial manual efforts to reduce the
threat.Welistedallthecoderuleswithoutrulesentencesonour
website, so other researchers can help further reduce the threat.
8 RELATED WORK
Empiricalstudies on APIs. Researchers conducted empirical
studies to understand various issues about API usages such as the
knowledgeonconcurrencyAPIs[ 53]ordeprecatedAPIs[ 60],rules
in API documents [ 45], the evolution of APIs [ 34,64,73], the ob-
staclestolearnAPIs[ 62],thelinksbetweensoftwarequalityand
APIs [39], the impact of API changes on forum discussions [ 40],
thepracticeonspecificAPIs[ 47],themappingsofAPIs[ 78],the
adoption of trivial APIs [ 13], and the impact of the type system
and API documents on API usability [ 26]. Like ours, most of the
above studies focus on the taxonomies of software engineering
data.Usman etal.[68]andRalph[ 58]presentedguidelinesforsuch
studies. Amann et al.[15] and Legunsen et al.[36] compared the
effectivenessoftoolsthatdetectAPI-relatedbugs.Thesestudiesex-
ploreotheranglesthanourresearchquestions.ZhongandMei[ 75]
conducted an empirical study to answer open questions in mining
APIcallsequences, but our study focuses on parameter rules.
Mining parameter rules. Client code is a major data source
forinvariantmining.Withtestcases,Ernst etal.[28]andHangal
andLammine[ 31]minedinvariantsfromprogramexecutiontraces.
In particular, Henkel and Diwan [ 32] mined invariants in algebraic
specifications,and proposedatool [ 33]for writingsuch specifica-
tions.Csallner etal.[21]introduceddynamicsymbolicexecution
tomineinvariants.Wei etal.[70,71]inferredpostconditionsbased
on Eiffel contracts. Smith et al.[65] inferred relations between
inputsand outputs.API codeis alsoa majordatasource ofinvari-
ant mining. Dillig et al.[25] inferred invariants through abductive
inference.Gulwani etal.[30]encodedprogramsintobooleanfor-
mulae,andinferredpreconditions.APIdocumentisanotherdata
source of mining invariants. Zhou et al.[80] inferred four types
ofinvariantsfromdocuments.Pandita etal.[54]combineddocu-
mentsandAPIcodetoinferinvariants.Zhou etal.[80]complained
thatitischallengingtoextractaccurateruleconditionsfromAPI
code. Partially due to the challenges, researchers [ 74] conducted
large-scaleevaluations only on client code or documents. For API
libraries, invariants typically define parameter rules. Although this
research topic is intensively studied, researchers [ 56,67] argued
that some underlying questions are still open. Our study explores
suchquestions,andourfindingsare useful to further improve the
stateof the art.
Miningsequentialrules. Ammons etal.[16]minedautomata
for APIs. Follow-up researchers [ 41,54] refined this approach, and
others[50,51]minedsimilarformatssuchasgraphs.Robillard et
al.[61] showed that automata and graphs are equivalent in the
scenario of specification mining. The research in this line can be
reducedtothegrammarinferenceproblem,andcanbesolvedby
corresponding techniques (e.g., the k-tail algorithm [ 18]). Li and
Zhou[38]minedmethodpairs,andotherresearchers[ 63]improvedtheirapproachesinmorecomplicatedcontexts.Engler etal.[27]
extracted frequent call sequences, and other researchers [ 59,69]
improved their approach with more advanced techniques. Further-
more,researchers[ 37,42]encodedminedsequencesastemporal
logic. The research in this line can be reduced to sequence min-
ing[14].Furthermore,Le etal.[35]combinedsequencesandinvari-
antsformoreinformativespecifications,andresearchers[ 22,57]
used test cases to enrich mined specifications. Mei and Zhang [ 43]
advocateapplyingbigdataanalysisforsoftwareautomation,and
mining sequential rules is one of the key techniques to extractknowledge from software engineering data. Our empirical study
focuses on parameter rules, but its findings may be useful to these
approaches.Forexample,thedistributionofdocumentrulesandcode rules can apply to sequential rules. It is worthy exploring
whetherourresults are still valid for sequential rules.
9 CONCLUSION AND FUTURE WORK
API libraries have been widely used, but are often poorly docu-
mented. When programmers do not fully understand API usage,
they can introduce API-related bugs into their code. To handle this
issue,researchershaveproposedvariousapproachestofacilitate
betterAPIusage.Inparticular,apopularresearchareaistomine
parameter rules for APIs. Although some industrial tools are al-
ready implemented, we still do not know (1) how many categories
ofAPIparameterrulesthereare,and(2)whatistheruledistribu-
tionamongJavadoccommentsandsourcecode.Theexplorationof
both questions is meaningful and important, because the acquired
knowledge can guide our future tool design for rule mining and
rule enforcement.
To explore both questions, we developed PaRu that localizes
document rules and code rules in library source files. Based on
the localized rules, our study identifies six categories of parameter
rules, and reveals that most parameter rules are defined only in
code,butnotindocumentation.Basedonourresults,wesumma-
rized four findings, and provided our insights on three topics such
as data sources, mining techniques, and hidden rules. With our
insights, in the future, we plan to work towards better mining and
recommendation techniques for parameter rules.
ACKNOWLEDGMENTS
We thank the anonymous reviewers for their insightful comments.
ThisworkissponsoredbytheNationalKeyR&DProgramofChina
No. 2018YFC083050, NSF-1845446, and ONR N00014-17-1-2498.
REFERENCES
[1] 2018. Apache Lucene. https://github.com/apache/lucene-solr.
[2] 2018. ASM. https://asm.ow2.io.[3] 2018. DERBY-5396. https://issues.apache.org/jira/browse/DERBY-5396.
[4]
2018. The documentation of J2SE. https://docs.oracle.com/javase/8/docs/api/
index.html.
[5] 2018. jMonkeyEngine. http://jmonkeyengine.org.
[6]2018. ThemanualofDaikon. http://plse.cs.washington.edu/daikon/download/
doc/daikon.pdf.
[7]2018. The manual of the Stanford parser. https://nlp.stanford.edu/software/
dependencies_manual.pdf.
[8] 2018. The Apachefoundation. http://www.apache.org/.
[9]2018. The documentation of Javadoc. https://docs.oracle.com/javase/7/docs/
technotes/tools/windows/javadoc.html.
[10]2018. The WALA IR. http://wala.sourceforge.net/wiki/index.php/UserGuide:IR.
909ICSE ‚Äô20, May 23‚Äì29, 2020, Seoul, Republic of Korea Hao Zhong1, Na Meng2, Zexuan Li1, and Li Jia1
[11]2018. TheWALASlicer. http://wala.sourceforge.net/wiki/index.php/UserGuide:
Slicer.
[12] 2018. WALA. https://wala.sf.net.
[13]Rabe Abdalkareem, Olivier Nourry, Sultan Wehaibi, Suhaib Mujahid, and EmadShihab. 2017. Why do developers use trivial packages? An empirical case study
on Npm. In Proc. ESEC/FSE. 385‚Äì395.
[14]RakeshAgrawalandRamakrishnanSrikant.1995. Miningsequentialpatterns.
InProc. ICDE. 3‚Äì14.
[15]Sven Amann, Hoan Anh Nguyen, Sarah Nadi, Tien N Nguyen, and Mira Mezini.
2019. A systematic evaluation of static API-misuse detectors. IEEE Transactions
on Software Engineering (2019).
[16]GlennAmmons,RastislavBod√≠k,andJamesR.Larus.2002. Miningspecifications.
InProc. 29th POPL. 4‚Äì16.
[17]FlorenceBenoyandAndyKing.1996. Inferringargumentsizerelationshipswith
CLP(R). In Proc. LOPSTR. 204‚Äì223.
[18]Alan W Biermann and Jerome A Feldman. 1972. On the synthesis of finite-state
machines from samples of their behavior. IEEE Trans. Comput. 100, 6 (1972),
592‚Äì597.
[19]LilianBurdy,YoonsikCheon,DavidR.Cok,MichaelD.Ernst,JosephR.Kiniry,
GaryT.Leavens,K.RustanM.Leino,andErikPoll.2005. AnoverviewofJML
tools and applications. International Journal on Software Tools for Technology
Transfer7, 3 (2005), 212‚Äì232.
[20]M.Chen,F.Fischer,N.Meng,X.Wang,andJ.Grossklags.2019. HowReliableis the Crowdsourced Knowledge of Security Implementation?. In Proc. ICSE.
536‚Äì547.
[21]C. Csallner, N. Tillmann, and Y. Smaragdakis. 2008. DySy: Dynamic symbolic
execution for invariant inference. In Proc. ICSE. 281‚Äì290.
[22]ValentinDallmeier,NikolaiKnopp,ChristophMallon,SebastianHack,andAn-
dreas Zeller. 2010. Generating test cases for specification mining. In Proc. ISSTA.
85‚Äì96.
[23]Valentin Dallmeier, Christian Lindig, and Andreas Zeller. 2005. Lightweight
defect localization for Java. In Proc. 23rd ECOOP. 528‚Äì550.
[24]Uri Dekel and James D. Herbsleb. 2009. Improving API documentation usability
with knowledge pushing. In Proc. ICSE. 320‚Äì330.
[25]IsilDillig,ThomasDillig,BoyangLi,andKenMcMillan.2013. Inductiveinvariant
generation via abductive inference. In Proc. OOPSLA. 443‚Äì456.
[26]Stefan Endrikat, Stefan Hanenberg, Romain Robbes, and Andreas Stefik. 2014.
How do API documentation and static typing affect API usability?. In Proc. 36th
ICSE. 632‚Äì642.
[27]Dawson Engler, David Yu Chen, Seth Hallem, Andy Chou, and Benjamin Chelf.
2001. Bugsasinconsistentbehavior:Ageneralapproachtoinferringerrorsin
systems code. In Proc. 18th SOSP. 57‚Äì72.
[28]Michael D. Ernst, Jeff H. Perkins, Philip J. Guo, Stephen McCamant, CarlosPacheco, Matthew S. Tschantz, and Chen Xiao. 2007. The Daikon system for
dynamic detection of likely invariants. Science of Computer Programming 69, 1-3
(2007), 35‚Äì45.
[29]LucaGazzola,DanielaMicucci,andLeonardoMariani.2017. Automaticsoftware
repair: A survey. IEEE Transactions on Software Engineering 45, 1 (2017), 34‚Äì67.
[30]Sumit Gulwani, Saurabh Srivastava, and Ramarathnam Venkatesan. 2009.
Constraint-based invariant inference over predicate abstraction. In Proc. VMCAI.
120‚Äì135.
[31]S. Hangal and M.S. Lam. 2002. Tracking down software bugs using automatic
anomaly detection. Proc. ICSE (2002), 291‚Äì301.
[32]JohannesHenkelandAmerDiwan.2003. DiscoveringAlgebraicSpecifications
from Java Classes. In Proc. ECOOP. 431‚Äì456.
[33]Johannes Henkel and Amer Diwan. 2004. A Tool for Writing and Debugging
Algebraic Specifications. In Proc. ICSE. 449‚Äì458.
[34]Andr√©Hora,RomainRobbes,NicolasAnquetil,AnneEtien,St√©phaneDucasse,
andMarcoTulioValente.2015. HowDoDevelopersReacttoAPIEvolution?The
Pharo Ecosystem Case. In Proc. 31st ICSME. 1‚Äì9.
[35]TienDuy Le, XuanBach Le, David Lo, and Ivan Beschastnikh. 2015. Synergizing
specification miners through model fissions and fusions. In Proc. ASE. 115‚Äì125.
[36]Owolabi Legunsen, Wajih Ul Hassan, Xinyue Xu, Grigore Ro≈üu, and Darko
Marinov.2016. Howgoodarethespecs?Astudyofthebug-findingeffectiveness
of existing Java API specifications. In Proc. ASE. 602‚Äì613.
[37]Caroline Lemieux, Dennis Park, and Ivan Beschastnikh. 2015. General LTL
specification mining. In Proc. ASE. 81‚Äì92.
[38]Zhenmin Li and Yuanyuan Zhou. 2005. PR-Miner: Automatically extracting
implicitprogrammingrulesanddetectingviolationsinlargesoftwarecode.In
Proc. ESEC/FSE. 306‚Äì315.
[39]Mario Linares-V√°squez, Gabriele Bavota, Carlos Bernal-C√°rdenas, Massimiliano
Di Penta, Rocco Oliveto, and Denys Poshyvanyk. 2013. API change and fault
proneness: a threat to the success of Android apps. In Proc. FSE. 477‚Äì487.
[40]Mario Linares-V√°squez, Gabriele Bavota, Massimiliano Di Penta, Rocco Oliveto,
and Denys Poshyvanyk. 2014. How do API changes trigger Stack Overflow
discussions? a study on the Android SDK. In Proc. 22nd ICPC. 83‚Äì94.
[41]David Lo, Leonardo Mariani, and Mauro Pezz√®. 2009. Automatic steering of
behavioral model inference. In Proc. ESEC/FSE. 345‚Äì354.[42]ShaharMaozandJanOliverRingert.2015. GR(1)SynthesisforLTLSpecification
Patterns. In Proc. ESEC/FSE. 96‚Äì106.
[43]HongMei and Lu Zhang. 2018. Can big data bring a breakthrough for software
automation? Science China Information Sciences 61, 5 (2018), 056101.
[44]NaMeng,StefanNagy,DaphneYao,WenjieZhuang,andGustavoArangoArgoty.
2018. Secure Coding Practices in Java: Challenges and Vulnerabilities. In ICSE.
[45]MartinMonperrus,MichaelEichberg,ElifTekes,andMiraMezini.2012. What
should developers be aware of? An empirical study on the directives of API
documentation. Empirical Software Engineering 17,6 (2012), 703‚Äì737.
[46]Laura Moreno, Gabriele Bavota, Massimiliano Di Penta, Rocco Oliveto, and
Andrian Marcus. 2015. How can I use this method?. In Proc. 37th ICSE. 880‚Äì890.
[47]SarahNadi,StefanKr√ºger,MiraMezini,andEricBodden.2016.‚ÄúJumpingThroughHoops‚Äù:WhydoJavadevelopersstrugglewithcryptographyAPIs?.In Proc.ICSE.
935‚Äì946.
[48]MeiyappanNagappan,ThomasZimmermann,andChristianBird.2013. Diversity
in software engineering research. In Proc. ESEC/FSE. 466‚Äì476.
[49]HoanAnhNguyen,RobertDyer,TienNNguyen,andHrideshRajan.2014.Mining
preconditions of APIs in large-scale code corpus. In Proc. 22nd FSE. 166‚Äì177.
[50]Hung Viet Nguyen, Hoan Anh Nguyen, Anh Tuan Nguyen, and Tien N Nguyen.
2014. Mining interprocedural, data-oriented usage patterns in JavaScript web
applications. In Proc. 36th ICSE. 791‚Äì802.
[51]Tung Thanh Nguyen, Hoan Anh Nguyen, Nam H Pham, Jafar M Al-Kofahi, and
Tien N Nguyen. 2009. Graph-based mining of multiple object usage patterns. In
Proc. ESEC/FSE. 383‚Äì392.
[52]David Novick and Karen Ward. 2006. Why don‚Äôt people read the manual?. In
Proc. SIGDOC. 11‚Äì18.
[53]Semih Okur and Danny Dig. 2012. How do developers use parallel libraries?. In
Proc. 20th FSE. 54‚Äì65.
[54]Rahul Pandita, Xusheng Xiao, Hao Zhong, Tao Xie, Stephen Oney, and AmitParadkar. 2012. Inferring method specifications from natural language API
descriptions. In Proc. ICSE. 815‚Äì825.
[55]GayanePetrosyan,MartinPRobillard,andRenatoDeMori.2015. Discovering
informationexplainingAPItypesusingtextclassification.In Proc.ICSE .869‚Äì879.
[56]NadiaPolikarpova,IlincaCiupa,andBertrandMeyer.2009. Acomparativestudy
of programmer-written and automatically inferred contracts. In Proc. ISSTA .
93‚Äì104.
[57]Michael Pradel and Thomas R. Gross. 2012. Leveraging test generation and
specificationminingforautomatedbugdetectionwithoutfalsepositives.In Proc.
ICSE. 288‚Äì298.
[58]Paul Ralph. 2018. Toward methodological guidelines for process theories and
taxonomies in software engineering. IEEE Transactions on Software Engineering
(2018).
[59]MuraliKrishnaRamanathan,AnanthGrama,andSureshJagannathan.2007. Path-
sensitive inference of function precedence protocols. In Proc. ICSE. 240‚Äì250.
[60]RomainRobbes,MirceaLungu,andDavidR√∂thlisberger.2012.Howdodevelopers
react to API deprecation?: the case of a smalltalk ecosystem. In Proc. 20th FSE.
76‚Äì87.
[61]Martin P Robillard, Eric Bodden, David Kawrykow, Mira Mezini, and Tristan
Ratchford.2013.AutomatedAPIpropertyinferencetechniques. IEEETransactions
on Software Engineering 39, 5 (2013), 613‚Äì637.
[62]Martin P. Robillard and Robert DeLine. 2011. A field study of API learning
obstacles. Empirical Software Engineering 16, 6 (2011), 703‚Äì732.
[63]Aymen Saied, Omar Benomar, Hani Abdeen, and Houari Sahraoui. 2015. Mining
multi-level API usage patterns. In Proc. SANER. 23‚Äì32.
[64]Lin Shi, Hao Zhong, Tao Xie, and Mingshu Li. 2011. An empirical study on
evolution of API documentation. In Proc. FASE. 416‚Äì431.
[65]CalvinSmith,GabrielFerns,andAwsAlbarghouthi.2017. Discoveringrelational
specifications. In Proc. ESEC/FSE. 616‚Äì626.
[66]RichardSocher,JohnBauer,ChristopherDManning,etal .2013. Parsingwith
compositional vector grammars. In Proc. ACL. 455‚Äì465.
[67]Matt Staats, Shin Hong, Moonzoo Kim, and Gregg Rothermel. 2012. Under-standing user understanding: determining correctness of generated program
invariants. In Proc. ISSTA. 188‚Äì198.
[68]Muhammad Usman, Ricardo Britto, J√ºrgen B√∂rstler, and Emilia Mendes. 2017.
Taxonomies in software engineering: A systematic mapping study and a revised
taxonomy development method. Information and Software Technology 85 (2017),
43‚Äì59.
[69]Andrzej Wasylkowski, Andreas Zeller, and Christian Lindig. 2007. Detecting
Object Usage Anomalies. 35‚Äì44.
[70]Y. Wei, C.A. Furia,N. Kazmin,and B. Meyer. 2011. Inferring bettercontracts. In
Proc. 33rd ICSE. 191‚Äì200.
[71]YiWei,HannesRoth,CarloAFuria,YuPei,AlexanderHorton,MichaelStein-
dorfer, Martin Nordio, and Bertrand Meyer. 2011. Stateful testing: Finding more
errorsin code and contracts. In Proc. ASE. 440‚Äì443.
[72] MarkWeiser. 1981. Program slicing. In Proce. ICSE. 439‚Äì449.
[73]Wei Wu, Adrien Serveaux, Yann-Ga√´l Gu√©h√©neuc, and Giuliano Antoniol. 2014.
TheimpactofimperfectchangerulesonframeworkAPIevolutionidentification:
an empirical study. Empirical Software Engineering 20,4 (2014), 1126‚Äì1158.
910An Empirical Study on API Parameter Rules ICSE ‚Äô20, May 23‚Äì29, 2020, Seoul, Republic of Korea
[74]Tao Xie and David Notkin. 2003. Tool-assisted unit test selection based on
operational violations. In Proc. ASE. 40‚Äì48.
[75]Hao Zhong and Hong Mei. 2018. An empirical study on API usages. IEEE
Transaction on software engineering (2018).
[76]Hao Zhong and Na Meng. 2018. Towards reusing hints from past fixes -An
exploratory study on thousands of real samples. Empirical Software Engineering
23, 5 (2018), 2521‚Äì2549.
[77]HaoZhongandZhendongSu.2015. Anempiricalstudyonrealbugfixes.In Proc.
ICSE. 913‚Äì923.[78]Hao Zhong, Suresh Thummalapenta, and Tao Xie. 2013. Exposing behavioral
differences in cross-language API mapping relations. In Proc. ETAPS/FASE. 130‚Äì
145.
[79]Hao Zhong, Lu Zhang, Tao Xie, and Hong Mei. 2009. Inferring resource specifi-
cationsfrom natural language API documentation. In Proc. ASE. 307‚Äì318.
[80]YuZhou,RuihangGu,TaolueChen,ZhiqiuHuang,SebastianoPanichella,and
HaraldGall.2017. AnalyzingAPIsdocumentationandcodetodetectdirective
defects.In Proc. ICSE. 27‚Äì37.
911