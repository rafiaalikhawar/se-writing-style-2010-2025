Broadening Horizons of Multilingual Static Analysis: Semantic
Summary Extraction from C Code for JNI Program Analysis
Sungho Lee
eshaj@cnu.ac.kr
Chungnam National University
South KoreaHyogun Lee
aasr4r4@kaist.ac.kr
KAIST
South KoreaSukyoung Ryu
sryu.cs@kaist.ac.kr
KAIST
South Korea
ABSTRACT
Most programming languages support foreign language interoper-
ation that allows developers to integrate multiple modules imple-
mented in different languages into a single multilingual program.
While utilizing various features from multiple languages expands
expressivity, differences in language semantics require developers
to understand the semantics of multiple languages and their inter-
operation. Because current compilers do not support compile-time
checking for interoperation, they do not help developers avoid in-
teroperation bugs. Similarly, active research on static analysis and
bug detection has been focusing on programs written in a single
language.
In this paper, we propose a novel approach to analyze multilin-
gual programs statically. Unlike existing approaches that extend a
static analyzer for a host language to support analysis of foreign
function calls, our approach extracts semantic summaries from
programs written in guest languages using a modular analysis tech-
nique, and performs a whole-program analysis with the extracted
semantic summaries. To show practicality of our approach, we de-
sign and implement a static analyzer for multilingual programs,
which analyzes JNI interoperation between Java and C. Our em-
pirical evaluation shows that the analyzer is scalable in that it can
construct call graphs for large programs that use JNI interopera-
tion, and useful in that it found 74 genuine interoperation bugs in
real-world Android JNI applications.
CCS CONCEPTS
•Software and its engineering →Automated static analysis ;
Operational analysis.
KEYWORDS
Multilingual Program Analysis; Language Interoperability; Java
Native Interface
ACM Reference Format:
Sungho Lee, Hyogun Lee, and Sukyoung Ryu. 2020. Broadening Horizons
of Multilingual Static Analysis: Semantic Summary Extraction from C Code
for JNI Program Analysis. In 35th IEEE/ACM International Conference on
Automated Software Engineering (ASE ’20), September 21–25, 2020, Virtual
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior specific permission and/or a
fee. Request permissions from permissions@acm.org.
ASE ’20, September 21–25, 2020, Virtual Event, Australia
©2020 Association for Computing Machinery.
ACM ISBN 978-1-4503-6768-4/20/09. . .$15.00
https://doi.org/10.1145/3324884.3416558Event, Australia. ACM, New York, NY, USA, 11 pages. https://doi.org/10.
1145/3324884.3416558
1 INTRODUCTION
From desktop to mobile, developing multilingual programs has be-
come one of the dominant options to implement software systems.
Multilingual programs are implemented in a host language and one
or more guest languages, and the implementation languages inter-
operate with each other via a foreign function interface (FFI). FFIs
enable programs written in one language to call functions and ex-
change data written in different languages. Different programming
languages provide FFIs in different ways. Python, Rust, and Julia
provide language-level FFIs [ 13,14,21], Java and JavaScript support
runtime environment-specific FFIs such as Java Native Interface
(JNI) [ 11] and Node.js C++ addons [ 12], and Go uses an external
tool, Cgo [10], to support interaction with C.
Multilingual programs take advantage of various features pro-
vided by multiple languages using cross-language interoperation.
Because different languages support different features, their inter-
operation expands the expressivity of developers. Developers can
implement specific modules in the most appropriate languages for
the modules, and compose them together via seamless interoper-
ation between the languages. One of the popular approaches to
develop multilingual programs is to use both high-level and low-
level languages, which improves not only programmability but also
performance. In addition, cross-language interoperation enables a
program to reuse existing modules implemented in different lan-
guages. For example, game programs often reuse existing C or C++
modules to surmount restrictions of host languages. Also, hybrid
mobile applications use both JavaScript to handle user interaction
and native languages to access device resources.
However, developing reliable multilingual programs is a challeng-
ing task. Because programming with multiple languages requires
programmers to understand the semantics of different languages
and the complex interoperation semantics between them. For ex-
ample, to call a foreign function, a developer should understand the
FFI calling convention and compatible argument values between
the languages. If the developer fails to satisfy the FFI requirements,
programs may behave unexpectedly or crash at run time. Even
though compilers can detect such problems for programs in a sin-
gle language, they cannot for multilingual programs.
Static analysis for multilingual programs is a challenging task as
well. Since most static analyzers can analyze programs in one lan-
guage, they often ignore foreign function calls during analysis and
produce partial and unreliable analysis results. Some static analyz-
ers support multiple languages like WALA [ 18], which can analyze
Java programs and JavaScript programs but not programs written
1272020 35th IEEE/ACM International Conference on Automated Software Engineering (ASE)
ASE ’20, September 21–25, 2020, Virtual Event, Australia Sungho Lee, Hyogun Lee, and Sukyoung Ryu
in both. By using WALA, previous work [ 6,19] could analyze one
kind of multilingual programs, Android hybrid applications in both
Android Java and JavaScript. While the analyses worked well for
Android hybrid applications, because precise analysis requires com-
plex, language-specific models, extending an existing analyzer for
one language to support different languages is not trivial.
In this paper, we propose a novel approach to analyze multilin-
gual programs statically. Our approach utilizes two static analyzers,
one for a host language and another for a guest language. First, using
the guest language static analyzer, we perform a modular analysis
that extracts semantic summaries from program modules written
in the guest language. A semantic summary looks like a simplified
function representing the semantics of a guest language function.
It captures interoperation between program modules written in
the host and guest languages, but does not contain the semantics
unrelated to the interoperation. Then, the host language static ana-
lyzer performs a whole-program analysis for the program written
in the host language. When it encounters foreign function calls
during analysis, it analyzes semantic summaries corresponding to
the callee guest language functions. While ignoring foreign func-
tion calls during analysis would produce unsound and imprecise
analysis results, our approach can analyze more control flows with
more data flows by analyzing program flows between modules writ-
ten in different languages. Moreover, an analyzer for one language
does not need to consider the semantics of the other language. For
interoperation semantics, we only need to build models for the FFI
semantics in the host static analyzer.
To evaluate the practicality of the approach, we design and im-
plement a multilingual analysis model for JNI programs, written in
both Java and C. JNI programs are widely used not only as desktop
programs but also as mobile applications [ 25]. We first define a
C-like guest language and describe a formal abstract semantics for
semantic summary extraction from the language. Then, we imple-
ment a semantic summary extractor on top of Infer, a modular static
analysis framework for C, developed by Facebook [ 16]. Because C
is the most frequently used guest language, our abstract semantics
for summary extraction and the analyzer can be used to analyze
other multilingual programs that use C code. For the Java side, we
build analysis models on top of FlowDroid, a static analyzer for
Java and Android applications [ 3]. We support both native function
calls where Java invokes C functions, and JNI function calls where
C gets (sets) values from (to) Java fields and invokes Java methods.
Our formal abstract semantics and tools are publicly available1.
The contributions of this paper include the following:
•We propose a novel approach to statically analyze mul-
tilingual programs using automatically extracted semantic
summaries from modules written in a guest language. Our
approach utilizes both static analyzers of a host and a guest
languages separately.
•We describe a formal abstract semantics of semantic sum-
mary extraction for a C-like language. Since C is the most
used guest language, it provides a formal ground to an-
alyze various multilingual programs that use C code.
1https://github.com/SunghoLee/c-summary
Host 
LanguageGuest 
LanguageHost 
LanguageGuest 
Language
Host 
LanguageGuest 
LanguageHost 
LanguageGuest 
Languagef
Host 
LanguageGuest 
Languagef
fBidirectional Interoperation Explicit/Implicit Interoperation Static/Dynamic BindingFigure 1: Three properties of cross-language interoperation
•We design and implement an open-source JNI program
analyzer , which broadens the analysis scope of Java static
analyzers to JNI programs.
•We show feasibility and usefulness of the JNI program ana-
lyzer with real-world Android JNI applications. In the em-
pirical experiments, our tool detected 74 genuine JNI in-
teroperation bugs in real-world applications.
2 CROSS-LANGUAGE INTEROPERATION
This section describes properties of multilingual programs as shown
in Figure 1. For a given multilingual program, we call the language
that provides an FFI a host language, and the others guest languages.
For JNI programs, Java is a host language and C is a guest language.
Bidirectional Interoperation. While each host language provides
its own FFI, most FFIs support bidirectional interoperation that
enables a host language to call the functions of a guest language
and vice versa. A host language makes foreign function calls by its
external function call feature. For example, Java calls C functions via
native function calls that invoke methods declared with the native
keyword. OCaml first imports C functions as external functions
and then calls them. Python and Go import C code as an external
module and call functions available from the module. Finally, Julia
uses a special keyword ccall to call C functions. As for the other
direction, C calls Java, Python, and OCaml functions indirectly via
C functions defined in libraries that each language provides. On
the contrary, in Julia, C uses function pointers that refer to Julia
functions propagated from Julia. Lastly, Go provides both ways:
C can define external functions for Go functions and call them as
external functions, or it can use function pointers as in Julia.
Explicit and Implicit Language Boundary. Foreign function calls
are syntactically distinguishable from normal function calls in some
multilingual programs, which expose the language boundaries ex-
plicitly. Since Java and OCaml denote foreign functions using spe-
cial keywords, native andexternal , respectively, one can easily
identify language boundaries by syntactic checks. Because Go uses
a fixed module named Cto denote the bridge module to C code,
and Julia uses a special keyword ccall to call C functions, they
also expose language boundaries. However, Python does not show
language boundaries since it imports C code in the same way as
it imports an external Python module. When C initiates interop-
eration, it has explicit language boundaries for Java, Python, and
OCaml because C calls predefined library functions for them. How-
ever, for Julia and Go, because C uses function pointers as the same
way as calls for C functions, the language boundary is implicit.
128Broadening Horizons of Multilingual Static Analysis ASE ’20, September 21–25, 2020, Virtual Event, Australia
void 
Java_com_example_App_callJava(JNIE
nv *env, jobject 
app){ 
  jclass klass = (*env)-
>GetObjectClass(e
nv, app); .c
void 
Java_com_example
_App_callJava(JNIE
nv *env, jobject 
app){ 
  jclass klass = 
(*env)-
>GetObjectClass(env, app); .c
void 
Java_com_example
_App_callJava(JNIEnv *env, jobject 
app){ 
  jclass klass = (*env)->GetObjectClass(e
nv, app); 
.g
class App { 
  
static{ System.loadLibrary("example"); 
} 
  void exec()
{ callJava(); }   void foo(){ /* do something... */ } .java
class App { 
  static{ System.load
Library("example"); 
} 
  void exec(){ callJava(); } 
  void foo(){ /* do 
something... */ } .java
class App { 
  
static{ System.load
Library("example"); 
} 
  void exec()
{ callJava(); } 
  void foo(){ /* do something... */ } 
.hSummary
ExtractionSummary to 
Host Lang.
Host Static 
Analyzer
…
CallGraphCode Injection
class App { 
  
static{ System.loadLibrary("example"); 
} 
  void exec(){ callJava(); }   void foo(){ /* do 
something... */ } .java
class App { 
  static{ System.load
Library("example"); 
} 
  void exec()
{ callJava(); } 
  void foo(){ /* do something... */ } .java
class App { 
  
static{ System.loadLibrary("example"); 
} 
  void exec()
{ callJava(); }   void foo(){ /* do something... */ } 
.hGuest Lang.
Code
Host Lang.
CodeModiﬁed Host Lang. CodeSemantic Summaries
class App { 
  
static{ System.load
Library("example"); 
} 
  void exec(){ callJava(); } 
  void foo(){ /* do 
something... */ } .java
class App { 
  
static{ System.load
Library("example"); 
} 
  void exec()
{ callJava(); } 
  void foo(){ /* do something... */ } .java
class App { 
  
static{ System.loadLibrary("example"); 
} 
  void exec(){ callJava(); }   void foo(){ /* do 
something... */ } 
.h
Summaries in Host Lang.
Figure 2: Multilingual program analysis with summaries
Static and Dynamic Function Binding. In most cross-language
interoperations, function bindings between a host and a guest lan-
guages are determined at linking time, and the bindings do not
change at run time. Thus, the same foreign function call from a host
language always invokes the same C function. However, JNI sup-
ports such static function bindings by default, and it also supports
dynamic function bindings. In JNI programs, C code can modify ex-
isting bindings via a JNI function call of RegisterNatives , which
makes Java methods declared with the native keyword be bound
to C functions. Thus, after calling it, the same native function call
in Java may invoke a different C function at run time.
3 OVERVIEW OF OUR APPROACH
We propose a new approach to statically analyze multilingual pro-
grams. Our approach supports bidirectional interaction, explicit
language boundaries, and static function binding with partial sup-
port for dynamic function binding.
The overall structure of the approach is illustrated in Figure 2. We
split a given multilingual program into Guest Lang. Code andHost
Lang. Code depending on the implementation languages. Then,
Summary Extraction takes Guest Lang. Code as an input, performs
an interprocedural modular static analysis, and extracts semantic
summaries for all the guest language functions in the code. The
modular analysis abstracts the behavior of a function as a relation
between an input state and an output state of the function; in
general, the input and output states are abstract heaps such as
memory states. To support bidirectional interoperation, we modify
the output state of a function so that it captures not only the final
abstract heap at the end of the function but also the sequence
of foreign function calls with their argument values at language
boundaries in the function. For each function callable from the host
language, Summary Extraction converts its input and output states
to a semantic summary. A semantic summary consists of three
parts: 1) parameters for inputs from the host language, 2) function
call statements for foreign function calls to the host language, and
3) return statements for the return value to the host language. Then,
Summary to Host Lang. transforms the summaries to host language
functions, and Code Injection integrates the functions with the host
language program Host Lang. Code so that the input multilingual
program gets converted to a new program implemented in the
host language only. Finally, Host Static Analyzer analyzes the new
program and produces analysis results.p ::= sdfd
sd ::= struct A{k:τ}
fd ::=τf(x:τ)=s
s ::= x=∗e| ∗e=e|@ix=f(e)|@ix=δF(e)
|return e
e ::= x|&x|x.k|[A]| c
τ ::=∗τ|A|ι
Figure 3: Language syntax
Note that even though Host Static Analyzer does not need to
analyze the guest language semantics, it should provide analysis
models for the FFI semantics because FFIs have their own seman-
tics and restrictions like value conversion between languages. In
addition, when a host language cannot support some features that a
guest language uses via foreign function calls, Code Injection does
not encode the features in the host language but lets Host Static
Analyzer provide analysis models for them.
In the following sections, we describe how we extract a semantic
summary from a C-like language (Section 4), and how to perform
JNI program analysis with handling of dynamic function bindings
(Section 5) in detail.
4 SEMANTIC SUMMARY EXTRACTION
4.1 Target Guest Language
Figure 3 shows the syntax of a C-like language that we use as a
guest language.
A program pis a sequence of struct declarations sdfollowed by
a sequence of function declarations fd. A struct declaration sdhas a
struct name Aand a sequence of fields and their types k:τ. A func-
tion declaration fdhas a return type τ, a function name f, a sequence
of parameters and their types x:τ, and a sequence of statements s.
A statement sis one of five kinds: a load statement x=∗e, a store
statement∗e=e, a function call statement @ix=f(e)where @i
denotes the call site, a foreign function call statement @ix=δF(e),
and a return statement return e. An expression eis also one of
five kinds: a variable x, a variable reference & x, a field access x.k,
a struct creation[A], and a constant c. For simplicity, we assume
that a field access expression returns the address of a field kof a
struct referred by x. In other words, a load statement x1=∗x2.k
assigns a value of the field kofx2to a variable x1. We also assume
that a string is a constant value c. A type τis a pointer type∗τ, a
struct type A, or a primitive type ι.
4.2 Modular Analysis for Semantic Summary
Extraction
Figure 4 shows an overview of the semantic summary extraction
mechanism. For a given function f, it aims to generate a semantic
summary f′as an abstraction of f’s semantics. After constructing
a control flow graph (CFG) for f, it performs a modular analysis to
extract f′in four steps.
First, during the Initialization stage, it takes a function fand
generates a parameter environment Dand the initial heap HIat
the function entry. We define the parameter environment and the
129ASE ’20, September 21–25, 2020, Virtual Event, Australia Sungho Lee, Hyogun Lee, and Sukyoung Ryu
Initialization fCFG 
Construction
Intra-procedural 
AnalysisHI⇥LI Heap & Log 
Composition
HO⇥LO
 Summary 
GenerationD0⇥H0
O⇥L0
O
Semantic  
Summaryf0Section 4.2.1 Section 4.2.2 Section 4.2.3
Section 4.2.4Semantic Summary 
Extraction
D⇥HO⇥LOCFG
H⇥L
H0⇥L0
D
Figure 4: Overview of semantic summary extraction
1 void set( thiz : hobj , x: *hobj , y: * hobj ) =
2 x_o = GetField (thiz , "f")
3 *x = x_o
4 y_o = GetField (thiz , "g")
5 *y = y_o
6
7 void call ( thiz : hobj , arg: hobj ) =
8 Invoke (thiz , "foo" , arg)
9
10 void f1( obj1 : hobj ) =
11 set(obj1 , &a, &b)
12 call (a, b)
13
14 void f2( obj2 : hobj ) =
15 set(obj2 , &c, &c)
16 call (c, c)
(a) Example code in the target guest language
In f1 , arg : obj1
1: loc:s6 <- FFI: GetField (arg:obj1 , const :"f")
2: loc:s7 <- FFI: GetField (arg:obj1 , const :"g")
3: loc:s9 <- FFI: Invoke ( loc :s6 , const :" foo ", loc:s7)
In f2 , arg : obj2
1: loc:s6 <- FFI: GetField (arg:obj2 , const :"f")
2: loc:s7 <- FFI: GetField (arg:obj2 , const :"g")
3: loc:s9 <- FFI: Invoke ( loc :s7 , const :" foo ", loc:s7)
(b) Semantic summaries for f1andf2
Figure 5: Example for semantic summary extraction
initial heap differently due to heap decomposition as we describe in
Section 4.2.1.
Second, with the initial heap HI, it performs Intra-procedural
Analysis based on abstract interpretation [ 7]. It analyzes statements
offand produces an output state HO×LO, where HOandLO
denote a final heap and a foreign function call log containing foreign
function call information, respectively. Then, it stores the analysis
result D×HO×LOto a storage, so that it can reuse the result at
call sites of the function while analyzing other functions.
Third, Heap & Log Composition enables the modular analysis
to handle interprocedural semantics. It composes the current state
H×Lwith f’s analysis result D′×H′
O×L′
Oat a function call site,
and generates a new state H′×L′as an abstract state right after
execution of the function call.
Finally, it transforms the output state of each function faccessi-
ble from the host language to its semantic summary f′.We formally define a whole abstract semantics of the semantic
summary extraction. Figure 5 shows a running example for this
section. Figure 5(a) presents a simple program implemented in the
guest language we defined. The guest language interoperates with
a host language via a JNI-like foreign function interface. The type
hobj is a primitive type denoting a host object value. Functions
f1andf2are callable from the host language, and GetField and
Invoke are the interface functions that get the value of a host ob-
ject’s field and call a host object’s method, respectively. For simplic-
ity, we omit return value assignments when they are unnecessary.
Semantic summaries in Figure 5(b) look similar to the original
program, but capture only foreign function call information by an-
alyzing the complex language semantics. In the following sections,
we describe each step of the semantic summary extraction.
4.2.1 Initialization. Theinitialization stage constructs a parameter
environment Dand an initial heap HIof a function fusing the
function’s parameters and their types. The initial heap represents
an abstract memory at the function entry. Because the modular anal-
ysis analyzes a function without any call site information, the initial
heap contains symbolic locations denoting arbitrary argument val-
ues. The Intra-procedural analysis handles symbolic locations like
normal values, but they are substituted with argument values at
call sites during Heap&Log Composition.
A heap Hmaps an abstract address αto an abstract value set θ
of (abstract value, constraint) pairs, which we design in a way to
support heap decomposition [9]:
θ ::= 2(v,ϕ)
v ::=α|<k:α>|c
α ::= l|s
ϕ ::= true|false|ϕ∧ϕ|ϕ∨ϕ|α=α|α,α
where < k:α> is a struct value, cis a constant, lis a normal loca-
tion, and sis a symbolic location. The constraint operators have
the same meaning with their corresponding boolean operators ex-
cept for equality. The equality operator does not evaluates if any
of its operands is a symbolic location, because a symbolic loca-
tion represents an arbitrary value. When a constraint becomes
false, a pair of an abstract value and the constraint is removed
from an abstract value set. While pointer alias relations among
parameters make multiple ways to construct an initial heap, heap
decomposition allows a single heap to represent multiple heaps.
For example, if two pointer parameters xandypoint to the same
location, the initial heap maps their locations, lxandly, to one
symbolic location s. Otherwise, it maps lxandlytosxandsy, re-
spectively. Using heap decomposition, we can unify the two heaps
to[lx7→{( sx,true)},ly7→{( sx,sx=sy),(sy,sx,sy)}], and decom-
pose it by resolving the constraints.
A parameter environment Dis a points-to map from locations to
locations. Heap&Log Composition instantiates symbolic locations
in a final heap of a callee using the parameter environment as we
describe in Section 4.2.3.
The initial heap and the parameter environment of setfunction
in Figure 5(a) are as follows:
130Broadening Horizons of Multilingual Static Analysis ASE ’20, September 21–25, 2020, Virtual Event, Australia
lx
lyS2
S4S3
S5true
S2 ≠ S 4S2 = S4
S2 ≠ S 4true
3 ltmp lx
lyS1
S2 S5true
S1 ≠ S 2 S1 ≠ S 2true
S1 = S2S1 = S 2
S1 ≠ S2HO
S1D
lx
lyS2
S4S3
S5HI
lthiz S1 S1true
lthiz
where lthiz,lx, and lyare locations of thiz ,x, and y, respectively,
circles denote symbolic locations, and labeled directed edges denote
points-to relations with constraints. Since lxandlypossibly point
to the same location due to the method call on line 15, lypoints to
s2under the constraint s2=s4meaning the two arguments are the
same, or points to s4, otherwise. The parameter environment Dis
constructed from parameter types. For each pair of a parameter
location lpand the type of the parameter τ, we allocate a new
symbolic location stolp. If the type τis∗τ′, we recursively allocate
a new symbolic location to a pair of sandτ′.
Theinit rule defines how to construct input states:
(a)H0=[]∀1≤i≤n.B,Hi−1,D⊢initp( E(xi):τi,true)⇒Hi
E,B,D⊢init(x 1:τ1, ...xn:τn)⇒Hn
(b)D(α)=s
B,H,D⊢initp(α :ι,ϕ)⇒H[α7→{( s,ϕ)}]
(c)D(α)=s B(s)={α1, ...,αn}
H1=H[α7→Ð
1≤i≤n.{(αi,(Ó
j<i.s,αj)∧s=αi∧ϕ)}
ϕ1=(Ó
1≤i≤n.s,αi)∧ϕH2=H1[α7→(H1(α)∪{( s,ϕ1)})]
B,H2,D⊢initp( s:τ,ϕ1)⇒H3
B,H,D⊢initp(α :∗τ,ϕ)⇒H3
where Eis an environment map from variables to their locations and
Bis an alias map from symbolic locations to sets of peer locations
that are possibly referred by alias pointers. While one can construct
alias maps using heuristics [ 9], because an imprecise alias map
may increase analysis overhead dramatically, we construct it using
Steensgaard’s points-to-analysis [23] as a pre-analysis.
Theinit rule (a) is the entry of input state construction. Starting
from an empty heap H0, it subsequently updates heap for each triple
of a parameter location, a parameter type, and the trueconstraint.
Theinitp rule (b) handles a location of a primitive type ιsuch
aslthiz,s2, and s4inHIofset. It obtains a symbolic location sof
the address αfrom the parameter environment Dand simply maps
the location αto a pair of sand the current constraint ϕinH.
Theinitp rule (c) is for a location of a pointer type ∗τsuch as
lxandly. It first obtains a symbolic location sof the address αfrom
the parameter environment D. Then, for each peer location αiofs,
it allocates αitoαunder the constraint (Ó
j<i.s,αj)∧s=αi∧ϕ,
which denotes that αpoints to αiifsis equal to only αiandαexists.
It also allocates stoαunder the constraint (Ó
1≤i≤n.s,αi)∧ϕ
meaning that sis not equal to any other locations and αexists.
Finally, it recursively updates heap for s:τunder the existence
constraint of s.
4.2.2 Intra-procedural Analysis. Intra-procedural Analysis abstracts
the semantics of a function fas an output state HO×LOby apply-
ing abstract transfer functions through control flows. The analysis
captures foreign function call information on line 2 as follows:H@3 HO
lx
lyS2
S4S3
S5true
S2 ≠ S 4S2 = S4
falsefalselthiz S1true
S6
S7S2 = S
4
S2 ≠ S4HO
LO(@2,s6,GetFieldV,l 1::l2,[l17!{(s1,t r u e )},l27!{(“f”,t r u e )}])
(@4,s7,GetFieldV,l 3::l4,[l37!{(s1,t r u e )},l47!{(“g”,t r u e )}])S2 ≠ S
4lx
lyS2
S4S3
S5true
S2 ≠ S 4S2 = S4falselthiz S1true
S6HO
true
S2 ≠ S 4
lx
lyS2
S4S3
S5true
S2 ≠ S 4S2 = S4
falsefalselthiz S1true
S6
S7S2 = S
4
S2 ≠ S4HO
LO(@2,s6,GetFieldV,l 1::l2,[l17!{(s1,t r u e )},l27!{(“f”,t r u e )}])
(@4,s7,GetFieldV,l 3::l4,[l37!{(s1,t r u e )},l47!{(“g”,t r u e )}])S2 ≠ S
4lx
lyS2
S4S3
S5true
S2 ≠ S 4S2 = S4falselthiz S1true
S6HO
true
S2 ≠ S 4
LO
{
(@2,s6,GetField ,l1::l2,[l17→{( s1,true)},l27→{(“f” ,true)}]),
(@4,s7,GetField ,l3::l4,[l37→{( s1,true)},l47→{(“g” ,true)}])}
Figure 6: Heap after line 3 and the output state of set
(@2,s6,GetField ,l1::l2,[l17→{( s1,true)},l27→{(“f” ,true)}])
where the first component is a list of call sites, the second is a sym-
bolic location representing a return value, the third is the name of
a foreign function, the fourth is a list of normal locations that point
to argument values, and the last is a heap snapshot. The following
rule specifies how to capture foreign function call information:
s=symbolic_loc() l=normal_loc() E,H⊢e⇒θ
H1=slice(θ,H)H2=H1[l7→θ]L1=L∪
{(@i,s,δF,l,H2)
}
E,H,L⊢@ix=δF(e)⇒H[E(x)
7→{( s,true)}],L1
where symbolic_loc() creates a new symbolic location, normal_loc()
creates a new normal location, and slice (θ,H)creates a new heap
that includes only reachable locations from θinH. This rule eval-
uates all the argument expressions eto abstract value sets θand
captures the foreign function call information with H2that contains
mappings from argument locations ltoθ. By this rule, the analysis
also updates the initial heap to H@2=HI[lx_o7→{( s6,true)}]for
capturing the return value assignment.
Figure 6 presents the heap after line 3 and the output state of
the function set. On line 3, the analysis maps s2pointed by lxto
s6pointed by lx_ovia the following abstract transfer function:
E,H⊢e1⇒{(α,ϕ)
}E,H⊢e2⇒θ
H1=H[α7→
(θ⊗ϕ)∪(H(α)⊗¬ϕ)]
E,H,L⊢
∗e1=e2⇒H1,L
The
operator⊗is defined as follows:
{(v1,ϕ1), ...,(vn,ϕn)}⊗ ϕ=Ð
1≤i≤n.{(vi,ϕi∧ϕ)}
which means that when storing θto an address αthat exists under a
constraint ϕ, it allocates θtoαonly if ϕis satisfied. In other words,
it preserves the previous value of αifϕis not satisfied. Thus, the
mapping from s2tos3becomes infeasible by negating the constraint,
and a new mapping from s2tos6is created.
On line 4, a new foreign function call is captured and added to
the log in a similar way. On line 5, the analysis maps both s2ands4
pointed by lytos7pointed by ly_o. It first changes the constraint
of a mapping from s2tos6tos2,s4, because s2points to s7under
131ASE ’20, September 21–25, 2020, Virtual Event, Australia Sungho Lee, Hyogun Lee, and Sukyoung Ryu
s2=s4; then, it creates a new mapping from s2tos7. Similarly, it
changes a mapping from s4tos5and maps s4tos7.
4.2.3 Heap & Log Composition. Our analysis handles interprocedu-
ral semantics by composing a callee’s analysis result with the state
at a call site. It first constructs an instantiation environment Iby
structurally mapping symbolic locations in Dof a callee to argument
values. On line 11 in Figure 5, the first argument is {(sobj1 ,true)}, the
second is{(la,true)}, and the third is{(lb,true)}. By structurally
mapping symbolic locations in Dofsetto the arguments, we can
construct Ias follows:
I@11=[s17→{( sobj1,true)},s27→{( la,true)},s47→{( lb,true})},
s37→{} ,s57→{}]
where s3ands5map to the empty set denoting the bottom value,
since both laandlbdo not point to any values at the call site.
Using the instantiation environment, the analysis instantiates
the output state of a callee and composes it with the current state:
Hr,I⊢inst_heap( He)⇒[α7→θ]H1=Hr[α7→θ]
I⊢compose_heap( Hr,He)⇒H1
Le={(@ 1,s1,δF1,l1,H1), ...,(@n,sn,δFn,ln,Hn)}
∀1≤i≤n.Hr,I⊢inst_heap( Hi)⇒H′
i
L1=Lr∪(Ð
1≤i≤n.{(@r:: @i,si,δFi,li,H′
i)})
Hr,I⊢compose_log(@ r,Lr,Le)⇒L1
where HrandLrare caller’s heap and log, HeandLeare callee’s,
and@ris the call site. Using HrandI,inst_heap substitutes sym-
bolic locations in callee’s heap with the argument locations, and
compose_heap composes callee’s heap with caller’s heap. Similarly,
compose_log instantiates all the heap snapshots of foreign function
calls in callee’s log and composes it with caller’s log.
The composition results on lines 11 and 15 are as follows:
H@11=[lobj17→{( sobj1,true)},la7→{( s6,true)},lb7→{( s7,true)}
L@11={(@ 11:: @ 2,s6,GetField ,l1::l2,[l17→{( sobj1,true)},
l27→{(“f” ,true)}]),
(@11:: @ 4,s7,GetField ,l3::l4,[l37→{( sobj1,true)},
l47→{(“g” ,true)}])}
H@15=[lobj27→{( sobj2,true)},lc7→{( s7,true)}]
L@15={(@ 15:: @ 2,s6,GetField ,l1::l2,[l17→{( sobj2,true)},
l27→{(“f” ,true)}]),
(@15:: @ 4,s7,GetField ,l3::l4,[l37→{( sobj2,true)},
l47→{(“g” ,true)}])}
Note that on line 11, s2,s4istrueands2=s4isfalse because the
constraints are instantiated to la,lbandla=lb, respectively. On
the contrary, on line 15, s2,s4isfalse ands2=s4istruebecause
both s2ands4are instantiated to lc.
Finally, by composition on lines 12 and 16, the analysis produces
final logs of f1andf2as shown in Figure 7.
4.2.4 Semantic Summary Generation. As shown in Figure 5(b), a
semantic summary is a function-like structure that consists of pa-
rameters, a sequence of statements, and a return value. A statement
is one of a foreign function call, a conditional branch, and a phiLf1
O={(@ 11:: @ 2,s6,GetField ,l1::l2,[l17→{( sobj1,true)},
l27→{(“f” ,true)}]),
(@11:: @ 4,s7,GetField ,l3::l4,[l37→{( sobj1,true)},
l47→{(“g” ,true)}]),
(@12:: @ 8,s9,Invoke ,l5::l6::l7,[l57→{( s6,true)},
l67→{(“foo” ,true),l77→{( s7,true)}])}
Lf2
O={(@ 15:: @ 2,s6,GetField ,l1::l2,[l17→{( sobj2,true)},
l27→{(“f” ,true)}]),
(@15:: @ 4,s7,GetField ,l3::l4,[l37→{( sobj2,true)},
l47→{(“g” ,true)}]),
(@16:: @ 8,s9,Invoke ,l5::l6::l7,[l57→{( s7,true)},
l67→{(“foo” ,true),l77→{( s7,true)}])}
Figure 7: Final foreign function call logs of f1and f2
1package com. example ;
2public class App {
3 static { System . loadLibrary ( " example " ); }
4 Obj foo () { /* ... */ }
5 Obj bar(Obj arg ) { /* ... */ }
6 Obj exec () { return callC (); }
7 native Obj callC ();
8}
(a) Java code
10 jobject Java_com_example_App_callC
11 ( JNIEnv *env , jobject thiz ) {
12 jclass cls = (* env) -> GetObjectClass (env , thiz );
13 jmethodID mid =
14 (* env ) -> GetMethodID (env , cls , "foo" ,"() LObj ;" );
15 jobject res =
16 (* env ) -> CallObjectMethod (env , thiz , mid);
17 return res;
18 }
(b) C code in example.c
Figure 8: Java and C interoperation
statement. Conditional branches represent control flows among
foreign function calls, which are useful for client analyses, and Phi
statements represent join points.
The summary generator converts the output state of each func-
tion callable from the host language to a semantic summary. It
obtains a return value from a final heap and extracts a sequence of
foreign function call statements from a log. Then, it constructs con-
trol flows among foreign function calls, and converts each foreign
function call to a foreign function call statement by substituting
each argument location and symbolic location with its mapped
value in a heap snapshot and a variable, respectively. When the
heap snapshot maps a location to a set of multiple values, the sum-
mary generator inserts a phi statement to join the set of values, and
substitutes the location with the return variable of the phi state-
ment. When a parameter location points to a symbolic location, the
summary generator converts the symbolic location to the parameter
variable. For example, it converts the first foreign function call of
Lf1
Oin Figure 7 to loc:s6 <- FFI:GetField(arg:obj1, const:"f").
132Broadening Horizons of Multilingual Static Analysis ASE ’20, September 21–25, 2020, Virtual Event, Australia
5 JNI PROGRAM ANALYSIS
5.1 JNI Interoperation
JNI is an FFI supported by JVM, which supports interoperation
between Java and C. Using JNI, Java code can call C functions, and
C code can call Java methods and get or set values of Java objects.
Figure 8 shows a simple example of Java and C interoperation.
The Java method callC of class Appon line 7 is a native method de-
clared with the native keyword, which does not have any method
body. When JVM loads a C library named example on line 3, it binds
the native method callC with a C function in the example library.
The target C function to bind is usually determined by JNI naming
convention: the name begins with the prefix Java_ , the mangled
fully-qualified class name and the mangled method name of the
native method where the names are separated by one underscore
“_”, and optionally followed by parameter signatures with two un-
derscores “ __” for overloaded native methods. Therefore, the native
function callC is bound to the Java_com_example_App_callC
function. When invoking the native method, the bound C func-
tion is called.
On the other hand, C code invokes a Java method via JNI func-
tions pre-defined in the jni.h file. The example C code has three
JNI function calls: 1) GetObjectClass that returns a class identi-
fier of a Java object passed as its argument, 2) GetMethodID that
returns a method identifier using a given class identifier, and a
method name and a signature, and 3) CallObjectMethod that
calls a Java method denoted by the class identifier and method
identifier, which returns a value of type Object . On line 16, the
Java_com_example_App_callC function calls the fooJava method
and returns a value that fooreturns.
Note that JNI supports bidirectional and explicit interoperation,
and static binding using its naming convention by default. In addi-
tion, it also supports the dynamic binding feature, which enables C
code to create and change bindings at run time. When calling the
RegisterNatives JNI function with a class identifier, a method
name and signature, and a C function pointer in C, JVM creates a
new binding between the Java method denoted by the class and
method information and the C function.
5.2 JNI Program Analysis using C Summaries
Now, we explain how we implemented the multilingual program
analysis illustrated in Figure 2 for JNI programs. We implement
Summary Extraction on top of Infer [ 16], a modular static analysis
framework for C and C++ developed by Facebook. It analyzes the
C code in a given JNI program and extracts semantic summaries for
the C functions accessible from the Java code in the JNI program.
Then, Summary to Host Lang. transforms the extracted summaries
to Java code, and Code Injection injects the transformed Java code
to the JNI program by substituting a Java native method body with
its corresponding Java code.
ForHost Static Analyzer , we use FlowDroid [ 3], a static ana-
lyzer for Java and Android Java programs built on top of Soot.
The transformed JNI program still contains some opaque method
calls for JNI function calls like GetObjectClass ,GetMethodID , and
CallObjectMethod in Figure 8. To handle them, we extended Flow-
Droid by building models for the JNI function semantics accordingto the JNI specification [ 11]. Using the models, FlowDroid ana-
lyzes transformed JNI programs and produces their call graphs as
analysis results. For the example in Figure 8, FlowDroid analyzes
the transformed Java method corresponding to the native method
callC , and infers the reachable method fooon line 4 from exec on
line 6, and the return value of exec as the return value of foo.
We also partially support the dynamic binding feature of JNI.
Since RegisterNatives takes arrays containing strings and func-
tion pointers as an input, precise analysis of the argument value
is challenging. Moreover, because it changes bindings between a
Java native method and C function at run time, our analysis cannot
substitute the body of a native method with a C function summary.
Thus, we reflect the dynamic binding semantics only under two
conditions: 1) the arguments are analyzed precisely in the summary
extraction phase, and 2) the dynamic binding occurs in the OnLoad
C function executed right after loading the C library, which is a
common programming pattern in Android JNI programming [ 8]. If
the two conditions are satisfied, we bind a Java native method and
a C function using the argument information instead of the static
binding based-on its naming convention.
Note that the code injection is performed in bytecode level by
FlowDroid rather than source-code level in the current implemen-
tation, because of the practical reason that the front-end of Soot
for Java source code analysis is outdated [ 22]. Thus, our analysis
takes both a compiled JNI program and its source code, injects the
bytecode of extracted C semantic summaries from the source code,
and analyzes the JNI program.
5.3 Client Analyses for Bug Detection
We implemented a client analyzer that detects two kinds of JNI
interoperation bugs.
The first kind of JNI interoperation bugs is wrong foreign function
calls. As described in Section 5.1, the JNI specification defines how
Java code calls C functions and C code calls Java methods. When
executing a foreign function call in a wrong way, either a runtime
error occurs or an unexpected behavior happens because such
cases are unspecified in the specification. We implemented a client
analyzer on top of FlowDroid; it inspects wrong static bindings
between Java native methods and their corresponding C functions,
and wrong Java method calls from C code.
The second one is mishandling of Java exceptions. When a Java
exception is pending, C code should handle the exception explicitly
or return to Java immediately to handle the exception in the Java
side [ 11]. Otherwise, the behaviors of subsequent JNI function calls
are unspecified. Our analyzer tracks exception flows in a similar way
to Li and Tan [20], but analyzes more program flows by tracking
exception flows over the language boundaries between Java and C.
6 EVALUATION
To show effectiveness of the proposed approach, we evaluated our
JNI program analysis in two perspectives: feasibility and practical
usefulness. For feasibility, we analyzed a benchmark set of Android
JNI applications, NativeFlowBench [ 2,25], which contains 23 An-
droid applications that use various interoperation features such
as uni- and bidirectional interoperation, native method overload-
ing, dynamic binding, and so on. We use 19 out of 23 benchmarks
133ASE ’20, September 21–25, 2020, Virtual Event, Australia Sungho Lee, Hyogun Lee, and Sukyoung Ryu
Table 2: Analysis results of 14 real-world Android JNI applications
Call C→J GetField C→J SetField C→J Time (sec.)
Name #LoC C #Precise #Resolved Total #Precise #Resolved Total #Precise #Resolved Total C Java
Graph 89 449027 1 1 1 0 0 0 0 0 0 2149.27 5.26
APV PDF Viewer 312429 3 3 7 4 4 4 4 4 4 1620.19 3.85
Lumicall 277763 27 27 27 15 15 31 4 4 4 121.19 28.22
Timidity AE 214052 3 3 3 0 0 0 0 0 0 119.21 5.08
Plumble 150190 1 1 2 20 20 52 2 2 6 84.45 19.78
CommonsLab 122508 10 10 10 0 0 0 0 0 0 58.17 9.59
CrossWords 72786 81 108 131 15 95 119 19 81 106 1553.19 15.14
Sipdroid 70288 0 0 0 49 49 69 4 4 4 66.08 16.21
Xmp Mod Player 69157 0 0 0 0 0 0 2 2 2 51.92 3.79
DroidZebra 38084 126 126 184 0 0 0 0 0 0 514.16 6.90
Fwknop2 16458 0 0 0 13 13 13 0 0 0 50.46 6.41
Taps of Fire 11357 0 0 0 0 0 9 0 0 4 92.72 4.23
agram 1550 0 0 0 0 0 0 3 3 3 3.76 3.39
VotAR 869 7 7 7 2 2 2 1 1 1 2.21 3.49
Total 259 286 372 118 198 299 39 101 134
Table 1: Analysis results of NativeFlowBench benchmarks
Benchmark Result Benchmark Result
native_complexdata ⃝ icc_nativetojava ⃝
native_compexdata_stringop × native_heap_modify ⃝
native_dynamic_register_multiple ⃝ native_leak ⃝
native_leak_dynamic_register ⃝ native_leak_array ⃝
native_method_overloading ⃝ native_noleak ⃝
native_multiple_interaction ⃝ native_noleak_array ⃝
native_multiple_libraries ⃝ native_nosource ⃝
native_set_field_from_arg ⃝ native_source ⃝
native_set_field_from_arg_field ⃝ native_source_clean ⃝
native_set_field_from_native ⃝
because four applications are inappropriate for evaluating the pro-
posed JNI program analysis: three benchmarks do not use interoper-
ation and the remaining one has a sole entry point in C code, which
FlowDroid cannot analyze. For practical usefulness, we analyzed
50 real-world Android JNI applications available from F-Droid [ 15],
which is an open-source repository collecting Android applications.
Finally, we report 74 genuine interoperation bugs detected from
ten Android JNI applications.
6.1 Feasibility
Table 1 shows the analysis results of 19 benchmarks in NativeFlow-
Bench. The first and third columns denote benchmark names, and
the second and fourth columns show whether the analysis results
succeeded (⃝) or failed (×). An analysis result succeeds if all foreign
function call sites are resolved precisely, and it fails otherwise. A
foreign function call site may perform one of four kinds of interop-
eration: Java-to-C function call ( Call J→C), C-to-Java method call
(Call C→J), C-to-Java field access ( GetField C→J), and C-to-Java field
update ( SetField C→J). Because C accesses and updates the values
of Java object fields via JNI function calls in the same way as Java
method calls, a foreign function call site may perform GetField C→J
and SetField C→Jas well. For Call J→Cand Call C→J, we counted
the number of outgoing edges at call sites in a call graph and con-
sidered them as precise if the number is one. For GetField C→Jand
SetField C→J, we checked the number of field accesses at call sites in-
stead of value propagation, because FlowDroid does not propagate
constant values.Table 3: JNI interoperation bug detection results
Name Wrong FF Call(#) Exception Mishandling(#)
Graph 89WrongDesc (1)-TypeMismatching (3)
APV PDF ViewerMissingFun (2)-TypeMismatching (2)
Lumicall MissingFun (1) UnsafeSubsequentCall (23)
Sipdroid MissingFun (1) UnsafeSubsequentCall (25)
VotAR WrongDesc (1) -
Taps of Fire WrongDesc (1) -
Xmp Mod Player WrongDesc (3) -
CrossWords MissingFun (3) -
DroidZebra - MissingHandling (4)
NetGuard - InappositeHandling (4)
Our JNI program analysis successfully analyzed 18 out of 19
benchmarks, which use bidirectional interoperation, dynamic func-
tion binding, and native method overloading as well as complex
data structures in C code. It failed to analyze one benchmark that
concatenates two string values via the strcat built-in C function
and uses it to obtain an identifier of a Java method. Because our
analysis does not handle such kinds of built-in C functions, it could
not analyze native_compexdata_stringop.
6.2 Practical Usefulness
We experimentally evaluated call graph construction of our JNI
analyzer with 50 real-world Android JNI applications. Table 2 sum-
marizes the analysis results of 14 out of 50 applications, which
have accesses of Java fields and methods in C. The first column
shows package names of the applications, the second column shows
the size of C code in the application, the third to fifth columns de-
note the numbers of resolved C-to-Java method calls, C-to-Java
field accesses, and C-to-Java field updates, respectively. The last
column shows the analysis time of semantic summary extraction
(C) and whole-program analysis (Java). The sub-columns #Precise ,
#Resolved , and Total denote the numbers of precisely resolved call
sites, resolved call sites, and total call sites, respectively. We consid-
ered a resolved foreign function call as precise, when the analysis
134Broadening Horizons of Multilingual Static Analysis ASE ’20, September 21–25, 2020, Virtual Event, Australia
produces a single target method or field for the call. Because no ap-
plications use dynamic binding and because Java-to-C method calls
are resolved by syntactic naming convention, we omit Call J→C.
Our JNI program analysis resolved 286 out of 372 (77%) C-to-Java
method calls, 198 out of 299 (66%) C-to-Java field accesses, and 101
out of 134 (75%) C-to-Java field updates. In addition, 416 out of 585
resolved foreign function calls (71%) are precise. As the analysis
time shows, the analysis is scalable enough to analyze large size JNI
programs. The most time-consuming process is extracting semantic
summaries. The extraction time is almost linear to the size of C code,
but it took only about 35 minutes at most to analyze over 400,000
lines of C code. Note that once we extract a semantic summary
for a C function, we can reuse the summary multiple times in a
whole-program analysis until the C function code changes.
The analysis failed to resolve 220 out of 805 (27%) foreign func-
tion calls in total due to two reasons. First, since our semantic
extractor does not handle opaque functions like built-in libraries,
the analysis may miss them and the analysis results could be un-
sound. Second, because the semantic extractor does not precisely
handle all complex C features like pointer arithmetic operations, the
analysis results may be imprecise. For such complex features, the
analysis over-approximates unknown locations as the top location,
and ignores store operations on the top location to avoid too much
imprecision while making analysis results unsound.
We also analyzed the 14 apps using JN-SAF [ 25], a state-of-the-
art Android JNI app analyzer that analyzes both Java and binary
code. It constructs call graphs of JNI apps and performs data flow
analysis through call flows to identify sensitive data leakage. In
our experiment, JN-SAF failed for all 14 apps: it exceeded its inter-
nal time limit for six apps, produced errors for two apps, did not
analyze binary code at all for four apps, and did not analyze JNI
function calls for two apps. This experiment shows that our JNI
analysis is more effective than the state-of-the-art analyzer when
JNI programs’ source code is available.
6.3 JNI Interoperation Bug Detection
We detected 18 wrong foreign function call bugs in eight and 56 Java
exception mishandling bugs in four out of 50 Android JNI applica-
tions. We categorized the detected bugs into six types: MissingFun,
TypeMismatching, and WrongDesc for wrong foreign function call
bugs, and UnsafeSubsequentCall, MissingHandling, and Inapposite-
Handling for Java exception mishandling bugs. Table 3 presents the
bug detection results: for each application, it shows the name and
the number of each bug type.
6.3.1 Wrong Foreign Function Call Bugs. Figure 9 presents example
wrong foreign function call bugs in real-world JNI applications.
Figure 9(a) shows a code snippet with the MissingFun bug in Sip-
droid. While a native method inheritedChannelImpl is declared
in Java, the corresponding C function is commented out. When
Java code calls such a native Java method that is not bound to any
C function, it results in throwing RuntimeException . Note that
because the bug exists in a library module that is publicly avail-
able, it may make other applications vulnerable as well. Indeed, we
observed that our tool detected the same bug in Lumicall, which
integrates the library module.// OSNetworkSystem . java
native Channel inheritedChannelImpl
// OSNetworkSystem .cpp
/*
jobject Java_org_sipdroid_net_impl_OSNetworkSystem
_inheritedChannelImpl
*/
(a) MissingFun
// PDF. java
synchronized private native int parseFile
// pdfview2 .c
void Java_cx_hell_android_lib_pdf_PDF_parseFile
(b) TypeMismatching
// dbus .c
jmethodID method =
(* DbusJNIenv ) -> GetStaticMethodID ( DbusJNIenv ,
class , " ReceiveFile " ,
"( Ljava / lang / String ; Ljava / lang / String ;)V" );
(* DbusJNIenv ) -> CallStaticIntMethod ( DbusJNIenv ,
class , method , jSrc , jDst );
(c) WrongDesc
Figure 9: Three types of wrong foreign function call bugs
Figure 9(b) shows a code fragment with the TypeMismatching bug
in APV PDF Viewer, where the native method that returns intis
bound to a C function that returns void . Figure 9(c) shows a C code
snippet with the WrongDesc bug in Graph 89. Even though the code
receives an identifier of a Java method that returns void , it calls
the method as it returns intviaCallStaticIntMethod . These two
bugs may not lead to errors if the return values are not used by their
subsequent instructions. However, because the JNI specification
does not specify how the JNI interoperation works in such cases,
they may have different behaviors on different JVMs. Actually, the
third case introduces a runtime error on Android Runtime even
when the return value is not used, but not on the Oracle JVM.
6.3.2 Java Exception Mishandling Bugs. Figure 10 presents simpli-
fied examples of Java exception mishandling bugs we detected.
Figure 10(a) shows a code snippet with the UnsafeSubsequent-
Callbug in Sipdroid. If GetStaticMethodID on line 10 returns NULL ,
it implies that an exception is thrown in Java and it is pending. The
JNI specification describes that when an exception is pending, subse-
quent JNI function calls except for a small number of JNI functions
are unsafe [ 11]. In this example, the call of jniThrowException on
line 12 invokes FindClass on line 3 and ThrowNew on line 5, which
are JNI functions, leading to unsafe behaviors in JNI interoperation.
Figure 10(b) shows a code fragment with the MissingHandling bug
in DroidZebra. The droidzebra_json_get_int function calls the
getInt method of the JSONObject class via a sequence of JNI func-
tion calls on lines 6 to 8, and returns -1on line 9 if the method
throws JSONException . Unfortunately, it checks only the existence
of an exception without handling it, and the Java side does not han-
dle the exception either. Thus, because the exception is not handled
appropriately, the application may terminate abnormally.
Figure 10(c) shows a code snippet with the InappositeHandling bug
in NetGuard. The jniNewObject function prints a log on line 4
135ASE ’20, September 21–25, 2020, Virtual Event, Australia Sungho Lee, Hyogun Lee, and Sukyoung Ryu
1// C
2int jniThrowException (...) {
3 jclass ec = env -> FindClass ( className );
4 if(ec == NULL ) return -1;
5 if(env -> ThrowNew (ec , msg) != JNI_OK )
6 assert (!" failed to throw " );
7 return 0;
8}
9void oneTimeInitializationImpl (...) {
10 jmethodID m = env -> GetStaticMethodID (...) ;
11 if(m == NULL ) {
12 jniThrowException (...) ;
13 return ;
14 } ...
15 }
(a) UnsafeSubsequentCall
1// Java
2public void run () { zePlay (0, null ); }
4// C
5jint droidzebra_json_get_int ( jobject json ) {
6 jclass cls = env -> GetObjectClass ( json );
7 jmethodID mid = env -> GetMethodID (cls , " getInt " ,
...) ;
8 value = env -> CallIntMethod (json , mid , ...) ;
9 if(env -> ExceptionCheck ()) return -1;
10 return value ;
11 }
12 void JNIFn ( droidzebra , ZebraEngine , zePlay ) (...) { ...
13 evt. type = droidzebra_json_get_int ( json );
14 if( evt. type == UI_EVENT_EXIT ) {
15 force_exit = 1;
16 break ;
17 } ...
18 }
(b) MissingHandling
1// C
2jobject jniNewObject (...) {
3 jobject obj = env -> NewObject (...) ;
4 if( object == NULL ) log_android (...) ;
5 else jniCheckException (env);
6 return object ;
7}
(c) InappositeHandling
Figure 10: Three types of Java exception mishandling bugs
when NewObject returns NULL . Otherwise, it handles a pending
exception via jniCheckException . However, a Java exception is
pending during NewObject execution if and only if it returns NULL .
Thus, the exception handling is unreachable and the pending excep-
tion may cause unexpected behaviors in subsequent instructions.
6.4 Remaining Challenges
Complex Language Semantics. While our semantic summary ex-
traction generated precise summaries for our target guest language,
the actual C language has more complex syntax and semantics than
the target language like global variables, arrays, and arithmetic
operations. Because it is challenging to analyze such language con-
structs statically, we over- and under-approximate their semantics,
which leads to the semantic summary extraction missing someinteroperation behaviors as shown in the evaluation. Our future
work includes extending the target guest language close to C.
Implicit Language Boundary. Because semantic summary extrac-
tion collects the information of foreign function calls at language
boundaries, explicit language boundaries are essential to apply our
approach. However, some languages like Java and JavaScript inter-
operate with each other over implicit language boundaries, which
make our approach inapplicable [ 4]. It may be able to support im-
plicit language boundaries by making the boundaries explicit first
via a pre-analysis before extracting summaries.
Client Analysis. In addition to two interoperation bugs we de-
tected, more buggy cases in JNI programs may originate from dif-
ferences between Java and C. For example, their different memory
management models can cause reference bugs [ 5]. We plan to ex-
tend our analysis to detect various kinds of JNI interoperation bugs.
7 RELATED WORK
Static Analysis for JNI Programs. Researchers have proposed
compilation-based approaches that transform one language to an-
other to statically analyze JNI programs. DroidNative [ 1] transforms
Java bytecode to binary code and performs signature-based mali-
cious pattern matching for both transformed binary and Android
native code. ILEA [ 24] compiles C code to Extended Java Virtual
Machine Language (JVML) and detects a null-related bug using
modified jlint. Since Java and C have different expressiveness, the
approach requires extension in JVML as well as modification in
Java static analyzers. In addition, it extremely over-approximates C
pointer operations like load andstore via pointers, because the
Extended JVML cannot simulate the C memory model. Unlike ILEA,
our approach properly handles C pointer operations even without
modifications in host languages and host language static analyzers.
JN-SAF [ 25] performs a modular analysis for Java bytecode and
symbolic execution for binary code separately, and composes their
data flows to detect malicious behaviors. Unlike JN-SAF, we propose
a general-purpose multilingual analysis and bug finding mecha-
nism. Our approach is scalable to analyze large real-world Android
applications while JN-SAF has the scalability issue due to the path
explosion problem of symbolic execution.
Hybrid Analysis for JNI Programs. Hirzel et al . [17] proposed a
hybrid approach that executes JNI programs during static analysis
to utilize run-time values propagated between Java and native code
using an instrumented JVM. While the approach is acceptable when
only native code is available, they always over-approximate return
values at all locations. On the other hand, our semantic summaries
capture the bidirectional interoperation semantics including foreign
function calls and return values, if source code is available.
Static Analysis for Other Multilingual Programs. Recent researchers
have proposed static analysis techniques for Android hybrid appli-
cations implemented in Java and JavaScript. Brucker and Herzberg
[6]construct call graphs for Java and JavaScript separately, and
compose the call graphs using several heuristics. HybriDroid [ 19]
performs a pointer analysis over language boundaries using inter-
operation semantic models and produces unified call graphs. Bae
136Broadening Horizons of Multilingual Static Analysis ASE ’20, September 21–25, 2020, Virtual Event, Australia
et al. [4] have devised a bug detection technique for hybrid applica-
tions using a JavaScript type checker with pre-analysis results for
Java. Because all of them focus on a specific application domain,
they are not applicable to other multilingual program analysis like
JNI programs.
8 CONCLUSION
Multilingual programs take advantage of various features provided
by multiple languages expanding expressivity. However, existing
static analysis techniques do not help developers implement re-
liable multilingual programs. In this paper, we propose a novel
static analysis approach for multilingual programs. Our approach
extracts semantic summaries from programs written in guest lan-
guages. With the extracted semantic summaries, a static analyzer
for a host language performs a whole-program analysis. To evaluate
the practicality of our approach, we developed a static analyzer
that analyzes JNI interoperation between Java and C. We showed
that our analyzer can analyze large-scale real-world JNI programs
that use various kinds of interoperation precisely and efficiently.
Moreover, we detected 74 genuine JNI interoperation bugs caused
by developer mistakes in real-world Android applications. We be-
lieve that our approach can broaden the analysis scope of static
analyzers for multilingual programs, and our open-source JNI pro-
gram analyzer can help developers find interoperation bugs in their
programs.
ACKNOWLEDGEMENTS
This work was supported by National Research Foundation of Korea
(NRF) (Grants NRF-2017R1A2B3012020 and 2017M3C4A7068177).
REFERENCES
[1]Shahid Alam, Zhengyang Qu, Ryan Riley, Yan Chen, and Vaibhav Rastogi. 2017.
DroidNative: Automating and optimizing detection of Android native code mal-
ware variants. computers & security 65 (2017), 230–246.
[2]arguslab. 2019. NativeFlowBench. https://github.com/arguslab/
NativeFlowBench.
[3]Steven Arzt, Siegfried Rasthofer, Christian Fritz, Eric Bodden, Alexandre Bar-
tel, Jacques Klein, Yves Le Traon, Damien Octeau, and Patrick McDaniel. 2014.
Flowdroid: Precise context, flow, field, object-sensitive and lifecycle-aware taint
analysis for android apps. In Acm Sigplan Notices, Vol. 49. ACM, 259–269.
[4]Sora Bae, Sungho Lee, and Sukyoung Ryu. 2019. Towards understanding and
reasoning about Android interoperations. In Proceedings of the 41st International
Conference on Software Engineering. IEEE Press, 223–233.
[5]Android Developers Blog. 2011. JNI Local Reference Changes in
ICS. https://android-developers.googleblog.com/2011/11/jni-local-reference-
changes-in-ics.html.
[6]Achim D Brucker and Michael Herzberg. 2016. On the static analysis of hybrid
mobile apps. In International Symposium on Engineering Secure Software and
Systems. Springer, 72–88.
[7]Patrick Cousot and Radhia Cousot. 1977. Abstract Interpretation: A Unified
Lattice Model for Static Analysis of Programs by Construction or Approximation
of Fixpoints. In Proceedings of the 4th ACM SIGACT-SIGPLAN Symposium on
Principles of Programming Languages.
[8]Google Developers. 2019. JNI tips: Native libraries. https://developer.android.
com/training/articles/perf-jni#native-libraries.
[9]Isil Dillig, Thomas Dillig, Alex Aiken, and Mooly Sagiv. 2011. Precise and compact
modular procedure summaries for heap manipulating programs. In ACM SIGPLAN
Notices, Vol. 46. ACM, 567–577.
[10] Go Documentation. 2019. Command Cgo. https://golang.org/cmd/cgo/.
[11] Java SE Documentation. 2019. Java Native Interface Specification. https://docs.
oracle.com/javase/7/docs/technotes/guides/jni/spec/jniTOC.html.
[12] Node.js Documentation. 2019. C++ Addons. https://nodejs.org/dist/latest-v10.x/
docs/api/addons.html.
[13] Python Documentation. 2019. Extending and Embedding the Python Interpreter.
https://docs.python.org/3/extending/extending.html.[14] Rust Documentation. 2019. Foreign Function Interface. https://doc.rust-lang.org/
1.9.0/book/ffi.html.
[15] F-Droid. 2019. F-Droid - Free and Open Source Android App Repository. https:
//f-droid.org.
[16] Facebook. 2019. Infer. https://fbinfer.com.
[17] Martin Hirzel, Daniel Von Dincklage, Amer Diwan, and Michael Hind. 2007.
Fast online pointer analysis. ACM Transactions on Programming Languages and
Systems (TOPLAS) 29, 2 (2007), 11.
[18] IBM. 2006. T.J. Watson Libraries for Analysis. http://wala.sourceforge.net/wiki/
index.php/Main_Page.
[19] Sungho Lee, Julian Dolby, and Sukyoung Ryu. 2016. HybriDroid: static analysis
framework for Android hybrid applications. In 2016 31st IEEE/ACM International
Conference on Automated Software Engineering (ASE). IEEE, 250–261.
[20] Siliang Li and Gang Tan. 2014. Exception analysis in the java native interface.
Science of Computer Programming 89 (2014), 273–297.
[21] Julia Manual. 2019. Calling C and Fortran Code. https://docs.julialang.org/en/v1/
manual/calling-c-and-fortran-code/index.html.
[22] Soot. 2016. Legacy-Free Soot. https://github.com/Sable/soot/issues/654.
[23] Bjarne Steensgaard. 1996. Points-to analysis in almost linear time. In Proceedings
of the 23rd ACM SIGPLAN-SIGACT symposium on Principles of programming
languages. ACM, 32–41.
[24] Gang Tan and Greg Morrisett. 2007. ILEA: Inter-language analysis across Java
and C. In ACM SIGPLAN Notices, Vol. 42. ACM, 39–56.
[25] Fengguo Wei, Xingwei Lin, Xinming Ou, Ting Chen, and Xiaosong Zhang. 2018.
JN-SAF: Precise and Efficient NDK/JNI-aware Inter-language Static Analysis
Framework for Security Vetting of Android Applications with Native Code. In
Proceedings of the 2018 ACM SIGSAC Conference on Computer and Communications
Security. ACM, 1137–1150.
137