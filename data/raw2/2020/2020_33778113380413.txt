IsRustUsed SafelybySo/f_twareDevelopers?
Ana NoraEvans
AnaNEvans@virginia.edu
Universityof VirginiaBradford Campbell
bradjc@virginia.edu
Universityof VirginiaMary LouSoﬀa
soﬀa@virginia.edu
Universityof Virginia
Abstract
Rust,anemergingprogramminglanguagewithexplosivegrowth,
providesarobusttypesystemthatenablesprogrammerstowrite
memory-safeanddata-racefreecode.Toallowaccesstoamachine’s
hardwareandtosupportlow-levelperformanceoptimizations,a
second language, Unsafe Rust , is embedded in Rust. It contains
support for operations that are diﬃcult to statically check, such
as C-style pointers for access to arbitrary memory locations and
mutable global variables. When a program uses these features, the
compiler is unable to statically guarantee the safety properties
Rust promotes. In this work, we perform a large-scale empirical
study to explore how software developers are using Unsafe Rust in
real-world Rust libraries and applications. Our results indicate that
softwareengineersusethekeyword unsafeinlessthan30%ofRust
libraries,butmorethanhalfcannotbeentirelystaticallychecked
by the Rust compiler because of Unsafe Rust hidden somewhere
inalibrary’scallchain.Weconcludethatalthoughtheuseofthe
keyword unsafeis limited, the propagation of unsafeness oﬀers
a challenge to the claim of Rust as a memory-safe language. Fur-
thermore, we recommend changes to the Rust compiler and to the
centralRustrepository’sinterfacetohelpRustsoftwaredevelopers
be aware of when theirRust code is unsafe.
ACMReference Format:
Ana Nora Evans, Bradford Campbell, and Mary Lou Soﬀa. 2020. Is Rust
UsedSafelybySoftwareDevelopers?.In 42ndInternationalConferenceon
SoftwareEngineering(ICSE’20),May23–29,2020,Seoul,RepublicofKorea.
ACM, NewYork, NY, USA,12 pages.
1 Introduction
Programming languages directly impact the reliability, safety, and
correctnessofsoftware,andtheirfeaturesimpacttheprevalenceof
bugsinactualsoftware.Arelativelynewprogramminglanguage,
Rust, is explicitly designed to help programmers write more reli-
able software by using the compiler to help reduce memory and
data race errors. Rust is referred to as a “safe” systems program-
minglanguage,indicatingthatitstypesystem,ownershipmodel,
automaticmemorymanagementwithoutgarbagecollection,and
staticcompilermakeitwellsuitedforwritinglower-levelorcore
softwarewithoutthecommonbugsthatcanplaguecodewritten
in C andC++[15,29, 30].
Permission to make digital or hard copies of all or part of this work for personal or 
classroom use is granted without fee provided that copies are not made or distributed 
for proﬁt or commercial advantage and that copies bear this notice and the full citation 
on the ﬁrst page. Copyrights for components of this work owned by others than ACM 
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish, 
to post on servers or to redistribute to lists, requires prior speciﬁc permission and/or a 
fee. Request permissions from permissions@acm.org.
ICSE ’20, May 23–29, 2020, Seoul, Republic of Korea
© 2020 Association for Computing Machinery.
ACM ISBN 978-1-4503-7121-6/20/05…$15.00
https://doi.org/10.1145/3377811.3380413The design aspects that make Rust safe, such as no arbitrary
pointers or arbitrary type casting, however, would also make writ-
ingmostoralllow-levelcodeimpossible.Operationssuchasconﬁg-
uring hardware or reading a network socket involve manipulating
memory in ways that the compiler cannot guarantee to be safe.
Therefore, Rust includes an “escape hatch” with the unsafekey-
word1that allows programmers to deactivate some (but not all) of
theRustcompiler’schecksforcertainregionsofcode.Thisfunction-
alitywasoriginallydescribedas“pragmaticsafety”[ 14]whenRust
was ﬁrstintroduced, and allowsdevelopers to use their own discre-
tion when writing Rust code. Part of the justiﬁcationfor allowing
UnsafeRust codeisthatusesof unsafewouldbeeasytolocateand
audit,andthatdeveloperscandecidehowmuchuncheckedcode
they are willing to acceptin their software.
Modern software development leverages and builds upon li-
braries,whichoftenuseyetotherlibraries.Auditingsoftwarefor
usesofunsaferequires auditing alldependent libraries, a poten-
tially cumbersome task. This overhead is mitigated, however, if
usageofunsafeisscarceandeasytolocateintheRustsoftware
ecosystem,orifmakingadeterminationaboutthevalidityofthe
unsafeusage is typically straightforward. Therefore, understand-
ing how developers are actually using unsafeis necessary to eval-
uate whether “pragmatic safety” is valid and if Rust provides a safe
programming environment in practice.
Our study is further motivated by recent interest in Rust as a
safealternativetoCforsystemssoftware[ 3,6,8,20,21,24,33]and
by the development of formal deﬁnitions for Rust’s type system
(including Unsafe Rust ). For example, the Rust Belt project [ 18]
proposes formal tools for verifying Unsafe Rust , and Oxide [ 39]
presents a formalization of a language very similar to Rust. The
Rust open source community recently formed a new Rust working
group to create a “Unsafe Code Guideline Reference” to help guide
developers[ 36].Theseareencouragingsteps,andunderstanding
howUnsafe Rust is being used by developers will help guide the
successfulformationof thesestrategies.
Toacquirethisunderstanding,weperformalarge-scalestudy
and an analysis of publicly available Rust libraries and application
code. We ﬁrst determine how frequently the unsafekeyword is
used. Then we analyze the call graph of every function in our data
set to identify if at any point the function may use code that is
not safe and not checked by the compiler. This analysis enables us
to ﬁnd code that lookssafe, but is actually Unsafe Rust . To better
understand how developers are using unsafe, we also identify the
underlyingcodebehaviorthatnecessitatestheuseof UnsafeRust
toanalyzethefrequencyofthevarious unsafeoperations.Further,
we observe the use of Unsafe Rust over time to see if there are
evolving changes in the community.
1Rustkeywordsaregreenandboldedwhilethesafeandunsafeconditionsareitalicized.
2462020 IEEE/ACM 42nd International Conference on Software Engineering (ICSE)
ICSE ’20,May23–29,2020, Seoul, Republic of Korea Ana Nora Evans, Bradford Campbell,and MaryLou Soﬀa
To perform this analysis, we developed and implemented an
algorithmforconstructinganextendedcallgraphofRustfunctions
that uses the type information to increase the call graph precision.
Building a call graph for Rust is diﬃcult, however, as Rust’s run-
timepolymorphismandhigherorderfunctionscomplicatestatically
buildingacallgraphwithoutmissingedgesoraddingextraedges.In
ourapproach,weidentifytheseambiguities,andbuildtwoversions
ofthecallgraphbyapplyingbothaconservative(assumethecall
will be to unsafe code) and an optimistic (assume the call we be
to code statically checked to be safe) analysis to help bound the
useofUnsafeRust inRustlibraries.Wethentraverseandanalyze
the resulting extended call graph to determine how unsafeness
propagatesin real-world Rust code.
After analyzing over 85% of the valid Rust libraries available
at the start of our study, we ﬁnd that 29% contain at least one
explicit use of unsafe. When considering the dependency tree,
however, that number increases to around 50%, meaning half of
Rust libraries use Unsafe Rust or rely on other libraries that use
UnsafeRust .Narrowingdowntojustthemostusedanddownloaded
libraries increases the use of Unsafe Rust , as around 60% of popular
crates include Unsafe Rust . The majority of unsafeuses in the
Rust ecosystem are to call other Rust functions that are marked
unsafe. We ﬁnd that only 22% of these unsafefunctions are to
external libraries implemented in C, suggesting that a majority
oftheUnsafeRust isactuallyfromRustcodewherethesoftware
developerdecidedtodisablethecompilerchecks.Finally,wesee
negligible increases in the frequency of unsafeused over the past
tenmonths.
Basedontheseﬁndings,weproposeseveralrecommendations
to help realize the original vision of “pragmatic safety” in Rust, in-
cluding programmer-assisted automated checks, additional tooling
tohelpdevelopersidentifyusesof unsafe,andmorevisiblecode
reviews to audit uses of unsafe. These changes would allow devel-
opers to better exploit the beneﬁts of Unsafe Rust while managing
its risksto overallsoftware reliability.
The contributionsof this paper are:
•Alarge-scalestudyandanalysisof unsafeuseintheRust
software ecosystem.
•A callgraph constructionalgorithm whichhandles generic
polymorphism.
•Findings that indicate that a majority of crates are not guar-
anteed bythe compilerbe memory-safeanddata-race free.
•Highlightsofourﬁndingsindicatethatunsafefunctioncalls
are the most common use of unsafeness, which is caused
through library dependencies rather than the use of the
unsafekeyword,andthemostdownloadedcrateshavemore
unsafecode thanotherothercrates;
•Recommendations to enhance the Rust compiler and its
ecosystem to help developers understand when they are
usingUnsafe Rust in their software.
Section 2 contains abrief introduction to Rust, Unsafe Rust (see
Section 2.3), the Rust software ecosystem (see Section 2.6), and the
terms we deﬁne to facilitate discussion throughout of paper (see
Section 2.5). In Section 3 we present the research questions that
guidedour experimentandthe selection criteriafor the Rust code
that comprises our data set. Section 4 contains the approach toansweringtheresearch questions.In Section5 wedeﬁnethedata
set we used in the experiments, and the answers to the research
questions based on the experimental results. We conclude with our
recommendations (see Section 6), threats to validity (see Section 7),
relatedwork (see Section 8)andconclusions (see Section 9).
2 Background
First,weprovideaworkingexamplethatwillbereferencedthrough-
outthepaper.Wethendescribethekeyfeaturesof SafeRust and
UnsafeRust thatarerelevanttoourstudy.Next,wedeﬁneterms
that we use to categorize Rust code. Finally, we provide some back-
ground information aboutthe generalRust software ecosystem.
2.1 WorkingExample
Figure 1(a) shows a set of functions in pseudocode from several
librariesselectedtoillustratehowunsafetycanpropagateinacode-
base.Wewillusethesefunctionstoexplainconceptsthroughout
the paper.
The functions are organized in ﬁve diﬀerent libraries. The start-
ing point is function foo()in Library1, which calls the function
bar()in Library2. The symbol ::separates the library name from
the function called from that library. In function bar()from Li-
brary2, the call to my_object.baz() is a run-time polymorphic
calltothemethod baz()ofaninstanceimplementingtheinterface
HasBaz.Theinterface HasBazhastwoimplementationsinLibrary3
andLibrary5.
Figure1(b)showstheresultinglibrarydependencygraphfrom
the example functions. A library depends on other libraries if it
usesfunctionsfromthoselibraries,andthereforerequirestheother
libraries to completely compileabinary.
For functions with run-time polymorphism we generate two
callgraphs:conservativeandoptimistic(seeFigure1(b)).Wewill
explainthis further in Section 4.
2.2 Safe Rust
Rustincludesafewbasicconceptsthatenablethecompilertoen-
force safety guarantees. The ownership mechanism in Safe Rust
requiresthata uniquevariableistheownerforeverymemorylo-
cation. Memory locations are immutable unless explicitly declared
otherwise. Variable assignment results in a copy or a transfer of
ownership,andoncethevariablelosesownershipofthememory
location, that variable becomes unusable. To enable sharing, the
borrowmechanismallowscreatingmemoryaliaseswhichpermit
anynumberofread-only referencesandexactlyonemutableone.
Thefoo()function inFigure 1(a) shows an example borrow oper-
ation.Together,the ownership andborrowmechanismspreventa
large class ofmemory-safetyerrorsanddata races.
Thedeﬁnitionofmemory-safetyusedbyRustissimilartothe
oneproposedbySzekeres etal.[30].ARustprogramismemory-
safe if it isfree of anymemoryerrors such as dereferencing a null
or dangling pointer, reading or writing unaligned pointers, and
reading uninitialized memory [ 34]. Memory leaks are explicitly
considered deﬁnedbehavior,andthus not memory errors.
247Is RustUsed Safely by So/f_tware Developers? ICSE ’20,May23–29,2020, Seoul, Republic of Korea
fnfoo() {
x = MyObject::new() // x owns the object
y = x               // Borrow occurs here
…
library2::bar()
}
fnbar() {
// my_obj implements
// “HasBaz”
HasBaz my_obj
my_obj.baz()
}!"#$%$&'
!"#$%$&(
Impl HasBaz {
fnbaz() {
a += 1
}
}!"#$%$&)Impl HasBaz {
fnbaz() {
unsafe {
my_global = 4
qux()
}
}
}!"#$%$&*unsafefnqux(b) {
my_obj = (Obj) b
return my_obj
}!"#$%$&+
,%-./.0!%$./123,%-.
45,,"#!&123,%-.
(a)Working examplefunctions.!"#$%$&'
!"#$%$&(
!"#$%$&) !"#$%$&*
!"#$%$&+
(b) Library1 dependency
graph.!""
#$%&'&()**%'&
+',-'.**%'./0'!12345$6$,5$7
!""
#$%&'&()**%'&
+',-'.**%'./89,'!12:"9,1&;'5$;1
(c)foo()extended call
graph.
Figure 1:Workingexample of Rust functions inmultiple libraries that are either safe,unsafe,oronly appear safe.
For instances where program operation requires violating these
constraints, Unsafe Rust allows developers to assert to the com-
piler that they are manually implementing the necessary checks to
preserve memory-safetyanddata-race freedom.
2.3 Unsafe Rust
UnsafeRust providesthenecessaryoperationsforlow-levelsystems
programming, such as arbitrary memory accesses with C-style
pointers,invokingsystemcalls,callingforeignfunctions(usuallyC
functions),executinginlineassemblyinstructions,elidingbounds
checks for performance, and accessing global static memory. To
use anyof these features, developersmust mark the codewith the
unsafekeyword.InListing1, unsafeisnecessaryforcastingan
address to a Rust struct for memory-mapped IO, and to use global
variables to reference unique resources(e.g.,COM1port).
1implSerialPort {
2pub unsafe fn new(base: usize)
3 ->&/quotesingle.Varstatic mutSerialPort {
4 &mut*(baseas*mutSelf)
5}
6}
7pub static COM1:Mutex<SerialPort> =
8Mutex::new(SerialPort::new(0x3F8));
9pub unsafe fn init() {
10COM1.lock().init();
11}
Listing 1:Transmute
Withinan unsafe region, the compiler stillchecksthe SafeRust
types, but the operations listed above are permitted as well. Unsafe
Rustdoes not grant the programmer complete freedom, but sub-
verting overall system safety is certainly possible. Programmers
usingUnsafe Rust are responsible for writing code free of safety
violationsandundeﬁnedbehavior;however,whatconstitutesun-
deﬁned behavior is currently not well speciﬁed and can change
with diﬀerent versions of the compiler. This situation makes safely
usingUnsafe Rust diﬃcult.2.4 Sourcesof Unsafe Rust
Thereareseveralsourcesof UnsafeRust ,includingunsafeopera-
tions,unsafefunctions, andunsafetraits.
2.4.1 Unsafe Operations Adevelopermaydirectlyuse Unsafe
Rustby creating a code block labeled with the keyword unsafe,
whichis requiredfor the following operations:
(1)Callingafunctionmarked unsafe,non-Rustexternalfunc-
tion,oracompilerintrinsic(afunctionwhoseimplementa-
tionishandled speciallyby the compiler).
(2) Dereferencing aC-stylepointer.
(3) Accessingamutable globalvariable.
(4) Using inline assembly instructions.
(5) Accessingaﬁeld of aunion type.
Function baz()in Library5 contains an example of Unsafe Rust
operation: an assignment to a global variable my_global , enclosed
in anunsafeblock.
An example of a possibly dangerous unsafefunction call is the
mem::transmute() functionusedtocoercethecontentsofanar-
bitrarymemorylocationintoaspeciﬁcRusttype.Thisisnecessary
when raw data (such as from a network socket), but can easily vio-
latetype-safetyifusedimproperly.Further,the mem::transmute
function also makes use-after-free memory errors possible when it
isusedtoextendthecompilercalculatedcodeboundswherethe
variable islive.
1let mut hello=String::new();
2lethello_ref: &mutString=
3{letr:*mutString= &muthello;
4unsafe{&mut*r }};//Undefined Behavior! A second mutable reference
5hello.push_str(/quotedbl.VarHello /quotedbl.Var);
6hello_ref.push_str( /quotedbl.Varworld!/quotedbl.Var);
7println!(/quotedbl.Var{:?}/quotedbl.Var, hello);
Listing 2:Multiple MutableReferences
Usingunsafealso makes mutable reference aliasing possible,
leadingtoundeﬁnedbehavior.IntheRustListing2,usingsimpliﬁed
Rust syntax, two mutable references ( helloandref1) are created
to the same memory location using an unsafeblock. Diﬀerent
Rust versions are free to handle this diﬀerently, and do, as the
248249Is RustUsed Safely by So/f_tware Developers? ICSE ’20,May23–29,2020, Seoul, Republic of Korea
unsafeblocks and declared unsafe functionsseparately. The moti-
vation for RQ3 is to understand if interactions with C are the main
sourceof UnsafeRust .Ifyes,thenmost UnsafeRust canbeelimi-
nated by implementing the libraries in Rust. If not, then the reason
forUnsafeRust lieswithinRustcodeitself,andmaybenecessary
for achieving the desired performance or for implementing low-
level libraries that interact with the operating system or directly
withhardware.
RQ4:What abstract binary interfaces (programming languages)
are usedin the declared unsafe functions?
The motivation for RQ4 is to understand if most called unsafe
functions are from external libraries implemented in C or from
otherRust libraries.
RQ5:Does the use of Unsafe Rust changeover time?
The motivation for RQ5 is to understand if the increasedattention
in the past year from the research community and the eﬀorts by
Rust language team to deﬁne and develop guidelines for use of
unsafechangedthe habitsof the Rust developers.
RQ6:Whydo Rust developers use unsafe?
We surveyed Rust developers to understand their reasons for using
unsafe.
3.2 Data Selection
To understand unsafety in Rust, we analyze real-world, publicly
available Rust code. As the Rust tool chain provides robust sup-
port for libraries, Rust software extensivelyleverages community-
provided libraries to create larger projects. As such, we target
our analysis towards the libraries that comprise the Rust software
ecosystem.
Toprovideaswideofananalysisaspossible,weincludeasmany
libraries(Rustcrates)inourstudyaspossible.However,aswithany
open ecosystem, there exists a “long-tail” of crates in Rust that are
small,largelyunusedprojects,andthesemaynotberepresentative
of the ecosystem at large. Therefore, we also perform our analysis
on only the “popular” crates in our data set as deﬁned as having
the most downloads from the central Rust repository to identify
anydiﬀerencesbetweentheentiredatasetandthesubsetthatis
more frequently used.
Additionally,tocomparecratescontributedbythelargerRust
community with those developed by members of the core Rust
developmentteamandMozillaResearch[ 32],weanalyzetheappli-
cationServo[ 3],awebbrowserenginefromMozilla.Servo,endemic
ofthelargerRustecosystem,itselfisimplementedasacollection
ofaboutﬁftydiscretecrates,andtogetherwithallitsdependencies,
compilingServoinvolves compilingalmost400diﬀerentcrates.
WeincludeallServocratesandtheirexternaldependenciesin
ouranalysisofServobecausetheyareimplicitlyvettedbytheServo
team to be includedinone of the ﬂagship Rust applications.
4 Approach
Our approach to answer the research questions is to identify all oc-
currencesof unsafeinRustcodebases,andthendeterminehowthe
unsafenesspropagatestocallerfunctions.First,weparseRustcode
from libraries to identify the keyword unsafein blocks, functions,
traits,andtraitimplementationsinasinglecrate,whichcanbeana-
lyzedindependentlyofothercrates.Next,wedeveloptwoversionsof an extended call graph for each library; one that is optimistic
and one that is conservative in terms of whether a polymorphic
functionissafeorunsafe.Finally,wedevelopanalgorithmtoan-
alyze the extended call graph to propagate the unsafe condition
through the call graph to determine if a function is safe or possibly
unsafe.Inthisway,wecanidentifylibrariesthatappearsafebut
actuallyhavepotentiallyunsafeconditionsthathavepropagated
up the call chain. Sources of imprecision in our analysis include
potential inclusionof deadcode.
4.1 Extended Call Graph
In general, a program call graph [ 28] is a directed graph with a
node for each program function and an edge (f,/afii10069.ital)for one or more
potentialcallsof /afii10069.italfromthefunction f.Thissimpleconstruction
needstobeexpandedif thelanguagehaspolymorphismandhigh
orderfunctions,asRustdoes.Severalalgorithmsforcallgraphcon-
struction for other languages which have these features have been
proposedwith diﬀerenttrade-oﬀsbetweenprecisionandrunning
time [5,11,25]. Our approach is similar to the one by Petrashko et
al.[25] in using the type information available at call site of not
onlytheSelftype,butalsoofthestatictypesoftheparameters.
Eachnodeofthecallgraphis extendedtocontainnotonlythefunc-
tion, but a list of generic type parameters and type substitutions
for thosewhen available.
To generate a call graph, we use the Rust compiler to compile
thecratetoanintermediate representationofRustknownasMIR
(MiddleIntermediateRepresentation).Wethenusethe"controlﬂow
graphs" of functionsobtaineddirectly from the MIRrepresentation
to run a context-sensitive analysis which uses type inference to
ﬁnd the precise functions that can be called. This analysis starts at
the leaf terminal nodes of the control ﬂow graph of a function. For
each terminal leaf node of the type “function call” we use the type
inferencetodeterminethefunctioncall,giventhetypesubstitutions
in the calling context. If the method has no Selftype or has a
Self(this) type that it is statically known, then only one edge is
introducedinthecallgraphintheactualimplementation.Ifanode
with the calculated substitutions for generics of the called function
does not exist in the call graph, then we apply the substitutions
recursively and introduce new nodes in the call graph as needed. If
theSelftype (i.e., this) is still unknown, then an edge to a node
parameterizedbythe Selftypeisintroduced.Inbuildingthecall
graph,whenweencounterfunctionswithgenerictypeparameters,
weparameterizethecallgraphbasedonthegenerictypeparameters
andinstantiateacallwithactualtypesavailableatthecallsite.The
nodes in our call graph are functions together with a set of type
substitutionsofthegenerictypeparameterswhenstaticallyknown.
Iftheprecisefunctionsofthecallgraphcannotberesolvedat
compile-time (due to virtual dispatch and higher order functions),
we split into two approximations, and create two versions of the
call graph. We create a call graph of a conservative approximation
assumingthattheunknownfunctionisunsafe,andanoptimistic
approximationofacallgraphthatassumesthepotentialfunction
is safe.
Foreﬃciency,ourcallgraphconstructionforafunctiontermi-
nates when any unsafeusage is found, as the original function
must now be marked possibly unsafe and further calls will have no
250ICSE ’20,May23–29,2020, Seoul, Republic of Korea Ana Nora Evans, Bradford Campbell,and MaryLou Soﬀa
impact.Similarly,westopwhenwereachavirtualcallorafunction
pointer as our twoapproximations cover the twopossible cases.
We generate extended call graphs for every function in every
crate,enablingthisapproachtoworkevenforlibrarieswhichdo
not contain a main function. These extended call graphs are for
individuallibraries,andfunctioncallstootherlibrariesareexplicitly
marked. In our analysis, we can then combine the extended call
graphsasneededwithouthavingtogeneratethecallgraphmultiple
times. Note, we stop our call graph construction at calls into the
Rust standard library. If the functions are declared unsafe we mark
them asunsafe; however, we consider the standard library trusted
and consider all other functions safe, even if their implementations
contain uses of unsafe.
Toaidfuturereproducibilitystudiesandextensionsofourwork,
wepublishallthecodeusedforthispaperat h/t_tps://github.com/
ananevans/icse2020,includingthecallgraphconstructionavailable
in theunsafe-analysis/src/implicit_unsafe/rta.rs folder.
4.2 Analysis on the Call Graph
Data:callgraph
Result:listof possiblyunsafefunctions
forall function deﬁnitions do
iffunction has unsafein body then
add function to possiblyunsafelist;
add function’s callgraph node to worklist
end
end
reversethe callgraph;
whileworklist not empty do
current_func =popthe ﬁrst element ofthe worklist for
each neighborofcurrent_func do
ifneighbornot in possiblyunsafelist then
add function to possiblyunsafelist;
add neighborto worklist
end
end
end
Algorithm 1: AnalysisonCallGraph
After the extended call graphs are constructed, we use them
to identify potentially unsafe functions in the Rust libraries. Our
approachstartsatthebottomofthecallgraphwithallfunctions
thatcontain unsafeblocks.Wethenworkbackupthecallgraph
to identify functions that may call any of these initial functions.
Our goal is to mark every function as either safeorpossibly unsafe.
Westartwithaworklistinitializedwithallfunctionsthatcon-
tain anunsafeblock in their body. Note that we do not need to
considerthe declaredunsafe functionsbecausetheywillnecessarily
becalledfromwithinan unsafeblockinanotherfunction.Weiter-
atively remove a function from the worklist, and perform a reverse
propagation on the extended call graph to mark all of its callers as
possiblyunsafe,andthenadd themtotheworklist.Thealgorithm
completes when the worklist isempty, and all functions that have
not been marked possiblyunsafe are deemed safe.4.3 Example
ConsiderourworkingexamplefromFigure1andassumeweare
analyzing the safety of Library1. The library dependency graph
is given in Figure 1(b) and shows the order of compilation and
analysis in building the extended call graph. Function foo()in
Library1 calls a function bar()in Library2 and thus an edge is
placed between Library1 and Library2. Library2 speciﬁeslibraries
3and5asdependencies,makingthecalltopolymorphicfunction
baz()ambiguous. Finally, Library5 contains a call to qux()and
therefore Library4is adependency of Library5.
Theextendedcallgraphwithexternallibrariesmergedisshown
inFigure1(c).Because bar()callsthepolymorphicfunction baz(),
wecannotpreciselydeterminetheexactcallgraphandsplitintoan
optimisticcallgraphthatassumestheunknownimplementationof
HasBaz::baz() is in fact safe, and a conservative call graph that
assumes it is unsafe. To determine unsafety in the conservative
case,westartwiththeunknownfunction HasBaz::bar() inour
worklistsinceitismarked possiblyunsafe.Wethenﬁndallcallers,in
thiscaselibrary2::bar() ,markthemas possiblyunsafe,andadd
them to the worklist. Iterating, we determine foo()callsbar()
and mark foo()possibly unsafe. This tells us that even though
foo()appearssafe, in a conservative analysis it may in fact call
code whichis not staticallycheckedby the compiler.
5 Experimentsand Results
We start with describing the experimental setup in Section 5.1
and continue with the detailed description of the data sets used
inourexperiments(Section5.2).Weconcludewiththeresultsin
Section 5.3.
5.1 ExperimentalSetup
We execute the experiments using version “nightly-2018-09-11” of
theRustcompileronUbuntu18.04.The2019versionofthemost
downloadeddatasetiscompiledwithversion“nightly-2019-07-01”.
5.2 Data Sets
Our data selection criteria are presented in Section 3.2. Here we
present the libraries actually included in our study and describe
reasons why we are unable to include all Rust crates in our data
set.
At thestart ofourstudy, September, 2018,therewere a totalof
18,478cratesregisteredwiththecentralRustsoftwarerepository.
We eliminated all of the crates that could not compile or was no
longeravailable.NotethatRustisunderactivedevelopment,and
a particular crate may compile with one version of the compiler
but not another. Afterwards, our data set contains 13,096 crates,
whichrepresent70%ofthetotalregisteredcrates,and85%ofthe
registered crates that contain some Rust code and are syntactically
correct.
Toobtain a“popular”subset, we fetch the per-cratedownloads
numbersfrom crates.ioandselectthemostdownloadedcratesthat
account for ninety percent of the downloads from crates.io. These
500 or so crates form a group we call most downloaded. From these
mostdownloaded crates we were able to compile462crates.
To create a group of perhaps “higher quality” crates, we use the
cratesthatcomprisetheapplicationServo,awebbrowserengine
251Is RustUsed Safely by So/f_tware Developers? ICSE ’20,May23–29,2020, Seoul, Republic of Korea
Abstractioncrates.io
(%)Most
Downloaded (%)Servo
(%)
Any 29.4 52.5 54
Blocks 28.2 49.4 51.7
Declared Unsafe
Functions15.1 15.1 39.7
Traits 1.2 4 4.4
Trait
Implementations6.0 13.0 18.2
Table 1: Percentage of Rust crates with Unsafe Rust based
on abstractiontype.
fromMozilla,asanothergroup.Servoisimplementedasacollection
ofapproximatelyﬁftycratesandtogetherwithallitsdependencies,
it comprises almost four hundred crates. As Servo is created by
manyofthesamedevelopersactivelydevelopingtheRustlanguage
itself,wepositthatitrepresentsamoreexpertlydevelopedpieceof
Rustsoftware.Notethatthecratesinthisgroupdooverlappartially
withthe mostdownloaded andcomplete groups.
Finally,ourfourthgroupcontainsthesamecratesasinthemost
downloaded group, but with the crate’s contents as it existed in
June 2019 on crates.io, approximately ten months after the ﬁrst
analysis.
5.3 Results
We provide answers the research questions from Section 3.1 based
onthe results of our experiments.
5.3.1 RQ1: How much do developers use Unsafe Rust ?Ta-
ble1showsthepercentagesofthecratesuse unsafe,brokendown
bythetypeofabstraction.Overall,29%ofcratesdirectlyinclude
some sort of Unsafe Rust in them. More popular crates are more
likelytouse unsafeas52.5%ofthemostdownloadedcratescontain
Unsafe Rust . Of these, only a few crates (about 15-17%) explicitly
mark functions as unsafe(which then propagate the unsafeto
otherportionsofcode).The unsafetraitandtraitimplementations
are usedbyonly a relativelysmall numberof crates.Comparedto
thelargerecosystem,thecratesthatcomprisetheServoprojectare
more likely to use Unsafe Rust .
Blocks:Figure 3 shows the cumulative distribution of unsafe blocks
percrate,with crates.iosetinblackandthemostdownloadedcrates
ingrey,andthemaximumvaluecappedat99.5%ofthecratesfor
clarity.ThelongtailoftheCDF(CumulativeDistributionFunction)
exists primarily because of autogenerated code, either from C to
Rusttranslators,hardwaredescriptionﬁles,or“safe”Rustwrappers
around C library functions.
The number of unsafeblocks per crate is small for the majority
of the crates, more than 90% of the crates have fewer than ten
unsafeblocks.Themostdownloadedcratesuse unsafemoreoften
than all crates.This occurs because these crates are more likely to
useunsafetoextractperformanceoptimizations,andtheyoften
exist to help interfacewithexisting C libraries.
Functions: Figure4showsthecumulativedistributionof declared
unsafefunctionspercrateforthe crates.ioset(inblack)andmost
downloaded crates (in dark grey), capped at 99%. A very small
numberofcrateshavethousandsof declaredunsafe functions.These
✻   ✁   ✂
✻
✄✁   ✂
✼  ✁   ✂
✼ ✄✁   ✂
✽  ✁   ✂
✽ ✄✁   ✂
✾  ✁   ✂
✾ ✄✁   ✂
✶     ✁   ✂✵✺
✵☎✵
✵☎✺
✵✷
✵
✵✷
✺
✵✸
☎
✷❯ ✆ ✝ ✞ ✟ ❡ ✠ ✡ ☛ ☞ ✌ ✝
P
✍
✎
✏
✍
✑✒
✓
✔✕
✎
❛
✒
✍
✖
Figure 3:RQ1: Cumulative Distribution of Unsafe Blocks✗ ✘ ✙ ✘ ✚
✛ ✜ ✙ ✜ ✚
✛✢
✙ ✜ ✚
✣ ✜ ✙ ✜ ✚✣✢
✙ ✜ ✚
✤ ✜ ✜ ✙ ✜ ✚✥✦
✥✧
✥★
✥✹✥✩
✥✪
✥✫✥✬✥✭
✥✦✥✥✦✦✥✦
✧
✥✦
★
✥✦✹✦❉ ✮ ✯ ✰ ✱ ✲ ✮ ✳ ✴ ✿ ❀ ✱ ❁ ✮ ❂ ❃ ✿ ✯ ❄ ❅ ❆ ✿ ❀
❇
❈
❊
❋
❈
●
❍
■
❏
❑
❊
▲
❍
❈
▼
Figure 4: RQ1: Cumulative Distribution of Declared Unsafe
Functions
cratesare typically low-level supportcratesfor embedded devices
orC library bindings.
Asinthe unsafeblockscase,theper-cratenumberof declared
unsafefunctionsissmallwith90%ofthecratescontainingfewer
thantwo declared unsafe functions.
Whilethereisacompilerwarningifablockisunsafewithout
using any unsafe operation, no such warning is generated for func-
tions. One use of an unsafe function is to warn the library user
thatpreconditionsmustbesatisﬁed,otherwisememorycorruption
oradata-racemayoccur. We performedanadditionalanalysison
the declared unsafefunctions to determine if the function uses an
unsafe operation. From all the crates with at least one declared
unsafefunction,69%ofallcrates.ioand53%ofmostdownloaded
crates,allthedeclaredunsafefunctionsareentirely SafeRust.We
identity two possible reasons for which a declared unsafe function
executes no unsafe operations: (1) the library developer performed
a careful analysis and determined that preconditions are necessary
to prevent memory corruption and data races; or (2) the unsafe
attribute wasincorrectlyplaced.
252ICSE ’20,May23–29,2020, Seoul, Republic of Korea Ana Nora Evans, Bradford Campbell,and MaryLou Soﬀa
Analysiscrates.io
(%)Most
Downloaded (%)
Conservative 44.8 38.9
Optimistic 53.8 43.9
Table 2: Percentageof CratesWithOnly Safe Functions
Traits:Declaringan unsafetraitisrareintheRustecosystem,with
only alittle over one percent of crates makinguse the feature.
Implementations: As seeninTable 1,onlysix percentofallcrates
provideanimplementationofan unsafetrait.Almost40%ofthose
are of two traits from the Rust standard library: Send(30%) and
Sync(13%). These traits are fundamental for Rust’s concurrency.
They do not have any declared methods, and they are used as a
declarationbytheprogrammerthattheobjectsimplementingthem
are safe to change ownership to another thread ( Send) or can be
sharedbetween threads (Sync).
Summary: Unsafe Rust is used in a little more than a quarter of
all crates, but the number of explicit unsafeuses per crate is small
formostcrates.Despitethepotentialissueswithusing unsafe,the
most downloaded crates are morelikely to use unsafethan the
average crate. In general, developers tend to avoid exposing the
unsafety to othercode by rarely marking functions as unsafeand
typically avoiding unsafetraits. However, the crates for Servo use
unsafefunctionsand unsafetraitstwoorthreetimesasfrequently
as general crates, which is consistent with the growing preference
in the Rust community that unsafeis encapsulated at a higher
level than individual functions. That is, exposing unsafefunctions
is acceptable as long they are eventually enclosed within a safe
interface.
5.3.2 RQ2:HowmuchoftheRustcodeis SafeRust ?Table2
presents the percentage of crates containing only safefunctions,
whentheunsafegeneratedbycompilerisignoredandthestandard
Rust library isconsidered entirely safe.
Figure5showsthecumulativedistributionofthe possiblyunsafe
functions for all crates, capped at 95%. The optimistic analysis is
showninlightgreyandtheconservativeanalysisisshowninblack.
Thediﬀerencebetweentheresultsofthetwoanalysesisabout10%
forcrateswithasmallnumberof possiblyunsafe functions,andgets
smallerthan1% for crates withtensof possiblyunsafe functions.
Tobetterunderstandthediﬀerencebetweentheperceivedsafety
(more than two thirds of the crates do not contain an unsafeab-
straction,Table1)andthestaticsafetyguarantees(lessonethirdof
crates are entirely Safe Rust) of Rust, we inspected crate dependen-
cies.Onaverage,acrossallcratesinourdataset,acratedependson
twelveothercrates.AsshowninTable3,only27%oftotalcrates
containno UnsafeRust andonlyusedependencieswhichcontain
noUnsafe Rust . Importantly, 38% of crates include no unsafein
their own implementation, but rely on dependencies which do use
unsafe.
Summary: While only less then one third of crates directly use
unsafe,overhalfofcratesinclude UnsafeRust somewhereinthe
aggregatesourcecodeoncedependenciesareconsidered.Thisillus-
tratesthediﬀerencebetweenRust’sperceivedsafetyandwhatis
actually statically guaranteed. This also burdens developers trying
✹ ✹   ✁ ✂
✺ ✄  ✁ ✂
✻ ☎   ☎ ✂
✼ ☎   ☎ ✂
✁ ☎   ☎ ✂
✾ ☎   ☎ ✂
✶ ☎ ☎   ☎ ✂✵✆
✵✷
✵✸✵✝
✵✞✵✟✟P ♦ ✠ ✠ ✡ ☛ ❧ ☞ ✌ ✍ ✠ ✎ ✏ ❡ ✑ ✒ ✍ ✓ ✔ ✡ ♦ ✍ ✠
✕
✖
✗
✘
✖
✙
✚
✛
✜
✢
✗
❛
✚
✖
✣
Figure5:RQ2:DeclaredSafeandPossiblyUnsafeFunctions
Distribution
Dependencies
WithUnsafe (%)No Unsafe in
Dependencies (%)
Crate With
Unsafe 23 12
No Unsafe
in Crate 38 27
Table 3: Unsafe inCrate and Dependencies
crates.io
(%)Most
Downloaded (%)Servo
(%)
Unsafe
Function Call79.2 66.3 74.9
Dereference
C-Style Pointer16 19.8 21.5
Global Variable 4 11.4 0.21
Table 4: Unsafe OperationsinUnsafe Blocks
crates.io
(%)Most
Downloaded (%)Servo
(%)
Unsafe
Function Call88.8 64.1 78.2
Dereference
C-Style Pointer6.38 25.9 19.1
Global Variable 3.9 8.0 1.1
Table 5: Unsafe OperationsinUnsafe Functions
tounderstandtheirsoftware’sexposureto UnsafeRust as38%of
crates appear to avoid unsafe, yet contain it in their dependencies.
5.3.3 RQ3: What Unsafe Rust operations are used? Table 4
and Table 5 present the most frequent Unsafe Rust operations in
unsafeblocks and declared unsafe functions, respectively. Only
theUnsafe Rust operations present inmore than 1%ofcrates are
displayed.
253Is RustUsed Safely by So/f_tware Developers? ICSE ’20,May23–29,2020, Seoul, Republic of Korea✸   ✁ ✂
✷ ✷
 ✄
✂
✹✷
  ☎ ✂
✻ ✄
 ✻
✂✄
✹  ✷
✂✁   ✹ ✂❈❘
✆
✝
✞❘
✆
✝
✞
✟
✠
✞
✡
✐
✠
✝
✐
☛❆ ☞ ✌ ✍ ✎ ❛ ✏ ✍ ✑ ✒ ✓ ❛ ✎ ② ✔ ✓ ✍ ✕ ✎ ✖ ❛ ✏ ✕
P
❡
✗
✘
❡
✙
✚
✛
✜❡
✢ ✣ ✣ ▼ ✤ ✥ ✦ ✧ ✤ ✇ ★ ✣ ✤ ✩ ✪ ✫ ✪
Figure 6:RQ4: Calls ofDeclared Unsafe Functions
Primarily, a function may be declared unsafe because it contains
Unsafe Rust operations that are not enclosed in an unsafeblock.
Other reasons for declaring a function unsafeare: it is imposed by
atrait, it has a precondition that must be satisﬁed, and it has a
C-Stylepointerargumentthatcanbeinvalid.Thesecasesarenot
directly using any Unsafe Rust operations, and thus were excluded
from the analysis.
We observe that calls to declared unsafe functions are a majority
oftheUnsafe Rust operations used.The mostdownloaded crates
andServouseC-stylepointerswithgreaterfrequency.Onepossible
explanation is that these applications interface with C libraries for
speedorbecause thoselibraries are not yetavailable in Rust.
Summary: Callstounsafefunctionsarethemajorityofthe Unsafe
Rustoperations.Weneedtounderstandifthefunctionsare unsafe
becausetheyareimplementedinCortheyareRustfunctions.This
is investigatedin the nextresearch question.
5.3.4 RQ4: What type of unsafe functions are called? Fig-
ure 6 presents the distribution of the abstract binary interface of
thedeclaredunsafefunctionscalledfromboth declaredunsafe func-
tionsand unsafeblocks.
Among all crates from crates.io the most frequent calls are to
Rustunsafefunctions(65%),followedbycallstoCfunctions(22.5%)
and Rust intrinsics (special functions made available by the Rust
compiler). Among the Rust unsafe calls, 47.6% are calls to the Rust
Core Library. Of these unsafefunctions in Core, 36.4% are of func-
tionsinthe ptrmoduleusedtomanuallymanagememorythrough
C-style(raw)pointersand40%arecallsoffunctionsthatare unsafe
wrappers to SIMD instructions and architecture-speciﬁc intrinsics.
Thus, a signiﬁcant source of Unsafe Rust is caused by the deﬁni-
tionanduseofC-stylepointers,eitherbydirectdereferencingor
by calling unsafefunctions from the core::ptrmodule that allow
pointer arithmetic and access to the values stored at the pointer
location.
The most downloaded crates use the Rust intrinsics much more
frequentlybecauseintrisicsprovideoperationsusedforI/Omem-
ory access and common atomic operations. The most downloaded
crates includemore librariesthat extendRust withI/O accessand
concurrency primitives. The very small number of C-style callsAbstractionSame
(%)Increase
(%)Decrease
(%)
Blocks 82 10 8
Functions 87 7 6
Table 6: Unsafe Use inMost Downloaded Crates
inmostdownloadedcratesisexplainedbythefactthatthemost
downloaded crates are more likely to contain crates that are wrap-
pers for commonly used libraries. From all the calls to Rust unsafe
functions,47.2%aretofunctionfromthe RustCoreLibrary ofwhich
27%areto core::ptrfunctions.ThewrapperstoSIMDinstructions
aresigniﬁcantlyused,asthecallstoRustintrinsicsaremuchhigher.
Summary: Calls to C functions are not the majority of the calls
tounsafefunctions.ImplementingsomeClibrariesinRust,will
removesome UnsafeRust operations,butthemajorityof unsafe
functioncallsaretoRustfunctionsandRustintrinsics.Weconclude
thattheunsafecodeisnotencapsulatedbehindthepublicinterface
andthe developers use the unsafefunction when available.
5.3.5 RQ5: Does the use of Unsafe Rust change over time?
ToanswerRQ5,wecountthenumberof unsafeblocksandfunc-
tions in the same set of most downloaded crates at two diﬀerent
timepoints:September2018andJune2019.SincetheRustcompiler
API changesfrequently, we modiﬁed theRust plugin tobe able to
compileupdatedcrates.However, unsafeiscountedinthesame
way,despiteusing twodiﬀerentversionsof the tool.
Amajorityofcrates(over80%)containedthesamenumberof
unsafeblocks and functions in both versions. Of the crates that
did change their unsafeusage, approximately halfincreased while
the otherhalfdecreased.
Summary: We conclude that there are no signiﬁcant trends in
theuseof unsafeoveraperiodoftenmonths,withonlyasmall
increasein the use of unsafe.
5.4 RQ6: Why doRust developers use unsafe?
To answer the RQ6 research question, we created a survey and
posted it on the Rust Subreddit [ 1], and collected data from twenty
respondents.Thesurveyaskedwhytheyuse unsafeandhowthey
ensure correctness when using unsafe.
TheﬁrstquestionaskedRustdeveloperstoselectoneormore
reasonsforwhytheyuse unsafeintheircode.Amajority(55%)in-
dicated the use Unsafe Rust for higher performance, with Safe Rust
beingtoorestrictiveasthenextmostcommonreason(40%).The
other reasons selectedinclude: the Safe Rust alternative istoo ver-
bose or complicated (25%), needed to make the code compile (10%),
andfastertowritecodewith UnsafeRust (5%).Further,respondents
provideotherreasons,including:implementingfundamentaldata
structures,custom concurrencyprimitives andsystem calls,inter-
actionwithspecialized hardware,and integrationwithCorother
languages.
Toexpandonthegeneralreasonsforusing UnsafeRust ,thenext
questionaskedwhatoperationsthedevelopersusethatrequirethe
unsafekeyword.Oftherespondents,45%reportusing unsafeto
call a non-syscall external C function, 25% to call an unsafe Rust
function,25%toworkwithC-stylepointers,and5%toworkwith
254ICSE ’20,May23–29,2020, Seoul, Republic of Korea Ana Nora Evans, Bradford Campbell,and MaryLou Soﬀa
SIMDintrinsics.Norespondentsselectedto performasystemcall
orto access astaticvariable.
TheﬁnalquestionaskedtheRustdevelopersforthestepsthey
take to increase their conﬁdence that their Unsafe Rust code is
correct. Most respondents (65%) indicated they read the code very
carefully,untiltheyconvincethemselvesthatthecodeiscorrect.
Another frequently used technique (55% selected this option) is
adding runtime checkstopreventmemorycorruption.Half of the
respondents writemore unit tests for the function ormethodthat
usesunsafeRust.Otherstepsdeveloperstaketoincreaseconﬁdence
inthecorrectnessoftheir unsafecodeinclude:havingdiscussions
withexperiencedRustdevelopersinpersonoronline, readingthe
documentationandRustbooks,creatingtheoreticalproofs,using
availabletestgeneration,runningfuzzingandanalysistools,and
using Miri [17].
Summary: We conclude thattheRustdevelopers use UnsafeRust
mostlybecause SafeRust istoorestrictiveandtoachievebetterper-
formance,buttheyareawareofthepotentialchallengeswhenusing
unsafeandtheyusemorecare,testmore thoroughly,anddeploy
toolsandanalysistoincreaseconﬁdenceintheircodecorrectness.
6 TowardsaSafer Rust
OuranalysisshowsthatwhilepubliclyavailableRustlibrariesrarely
usetheunsafekeyword(evenverypopularlibraries),mostofthem
are stillnot SafeRust,because of unsafeuse independencies.
For Rust users that require more robust and reliable checking
of their code, future improvements to the Rust compiler or the
associatedtoolinfrastructurearerequired.Aparticularlyambitious
mechanism would be to require an automatic correctness proof (in
thestyleofVeriﬁableC[ 4])foreveryuseof unsafe.Jungetal.[18]
usedthisapproachtoformallyprovethecorrectnessofahandful
of Rust functions. The Rust functions were manually translated
to a simpliﬁed version of the language, called λRustand using
the Iris framework [ 19] the authors provided machine-checked
proofsofcorrectnessofseverallibrariesanduncoveredapreviously
unknownsoundnessbuginRust.Thisapproachisunlikelytoscale
toallRustcode,butmaybefeasibleforthestandardlibraryorother
commonly used libraries to help minimize the amount of code that
is not checkedfor safety.
Another more feasible short-term approach is to address only
unsafefunction calls, which is the most common use of unsafe.
Here, programmers could annotate function calls with suitable pre-
and post-conditions they expect to hold when calling the func-
tion. Various static and dynamic checks then check the code to
ensuretheconditionsaresatisﬁed.Thisannotationwouldenable
programmerstosafelyusefunctionsthatareintrinsicallyunsafe
(i.e.,conﬁguringahardwareperipheral)oroptimizeperformance
withunsafe.However,thisapproachdoesaddanadditionalburden
for programmers and, possibly,run time overhead.
Another approach is to aid programmers in reasoning about
the safety of any external code they use. Rust already includes a
compiler directive that generates an error if unsafeis used, yet
we discovered a library that included the directive but still used
unsafebyoverridingitatthefunction-level.Strengtheningtools
soprogrammershaveautomatedchecksonunsafecodeindepen-
dencieswouldsigniﬁcantlyhelpprogrammersmanuallyaudittheircodebasetobetterenable“pragmaticsafety”.Forexample,theRust
compilershouldbeabletoidentifyfunctionsinagivenlibrarythat
areimplicitsafe,andprintapossiblecallchainthatincludescalls
toUnsafe Rust . Implementing this in the compiler would make this
tool easy to use, and it would remain up to date as the internal
compiler API changes.
Thedevelopmentoftheabovementionedtoolsrequiresadeﬁni-
tionofwhat UnsafeRust actuallymeansandwhichbehaviorsare
undeﬁned. Despite Rust 1.0 being around for four years, the guide-
linesonhowtowrite unsafeRustcodearestillpreliminary[ 35].
As this eﬀort progresses, developing tools around Unsafe Rust will
be more manageableandmaintainable.
The Rust library ecosystem tool, crates.io, should also help alert
developers to uses of unsafe. Anecdotally, over 100 unsound uses
ofunsafein a popular Rust web framework, Actix [ 31], were only
discovered and partially ﬁxed by the Rust community after an
online post by a concerned user [ 37]. Even a year later, the library
stillcontainsusesof unsafe,withsoundnessconcernsstillpresent.
Motivatedbythisexample,weproposethefollowingchangesto
thecrates.iointerface: i) a new tag or badge for crates that include
UnsafeRust ;ii)a dependencytree foreach librarywith thecrates
that useUnsafe Rust clearly marked; and iii) a list of code reviews
foranyUnsafeRust .Previousresearchestablishedthatcodereview
in open source software communities is common and successful in
eliminatingalargenumberoferrors[ 7,26,27].Alamietal.[2]ﬁnd
that open source software developers develop a mature attitude
to negative feedback and improve their code through a cycle of
review,rejection, andimprovement.
Theimplementationofourproposalswillhelpthecommunity
inspectlibrariesandhelpguidenewRustdevelopersonwhat Unsafe
Rustcode to trust.
7 Threats To Validity
Theinternalvaliditythreatsweidentifyareconfoundingfactors
andsamplingbias.The UnsafeRust segmentsweidentifymaybe
in unreachable or dead code that may not ever be executed for a
particular library. Future work can use additional static analysis
tools to identify uses of unsafethat reside in unreachable code.
Samplingbiasisalsoapossibility.Weintendedtobeinclusiveinthe
libraries we analyze,andwe believe the way we segmented crates
ismakesour analysisrepresentativeofthe largerRustecosystem.
Thecratesincludedinourstudyaretheonesthatcouldbecompiled
on an Ubuntu operating system, and doe not include crates that
needWindowsandMacOS libraries.
Rustisunderactivedevelopmentanditispossiblethatprogram-
mingstyleanduseof UnsafeRust changesintime.Weidentifythis
as an external validity threat.The percentage of safelibraries may
changewhen considering only “newer” libraries.
8 RelatedWork
We present throughout the paper related work relevant to the mo-
tivationandtechniquesused.Inthissection,wefocusonrelated
workthatinvestigateshowsoftwareengineersusevariousfeatures
in otherprogramming languages.
255Is RustUsed Safely by So/f_tware Developers? ICSE ’20,May23–29,2020, Seoul, Republic of Korea
C/C++ language features: Eyolfson et al.analyze the use of
constannotations in seven medium and large open source C++
projects and ﬁnd that software developers use correct annotations
inmostcases,missingimmutabilitylabelsinonly6%oftheunanno-
tated methods [ 13]. In Rust, the variables are immutable by default,
andtheprogrammersopt-inbylabelingavariableasmutable.This
study suggests that C++ programmers are using language features
towritesoftwarewithfewererrors.Inourstudy,weobservethe
same tendency as the majority ofcrates are free ofdirect uses of
Unsafe Rust .
Casalnuovo etal.[9]studiedmanyC/C++projectstomeasure
theprogrammers’useof assert.Theyﬁndthatamajorityofthe
projects use more than a minimal number of assertstatements.
The useincreases withthe length of time the developerisdirectly
involved with that function. If Rust developers behave similarly,
then over time the number of assertion statements in Rust code
shouldincrease,helpingtoprotect UnsafeRust operations.However,
developers mayinstead view assertions as not neededin Rust.
Undeﬁnedbehaviorcanbeparticularlyproblematicincodeasthe
compiler can correctly generate machine code that does not match
theprogrammer’sexpectations.Aswiththecaseofusingundeﬁned
integeroverﬂowtocheckabuﬀer’slength[ 12],undeﬁnedbehavior
canleadtosecurityvulnerabilities.Wang etal.[38]implementa
tool to detect undeﬁned behavior based on diﬀerences resulting
from the compiler optimization level used. They ﬁnd that 40% of
the8,575DebianWheezypackagesthatcontainC/C++codeexhibit
this behavior, and identify 160 real bugs in production open source
code.
Further, understanding undeﬁned behavior can be diﬃcult, as
Memarian etal.[23]demonstratebysurveyingover200experienced
C developers and asking 85 diﬃcult questions about the semantics
ofC.Theresearchersconcludethatinmanyinstancestherewas
no agreementamongtheparticipantson theactual codebehavior.
AsUnsafeRust caneasilyintroduceundeﬁnedbehaviorintoRust
code, these case studies suggest Unsafe Rust should be used very
cautiously.
Java:Javaisasafelanguage,buttheruntimeprovidesa“back-
door”thatpermitsthecircumventionofJava’ssafetyguaranteesto
enablehigh-performancesystems-levelcode.Mastrangelo etal.[22]
performalarge-scaleanalysisofJavabytecodetodeterminehow
these unsafe capabilities are used in real world. The authors deter-
mine that 25% of the Java code analyzed depends on unsafe Java
code.Oneexplanationforwhythe25%oftheanalyzedJavacode
lackssafetybecauseofuseofunsafeAPImaybethatitisnotan
integral part of the language, like in Rust, andit is not exposed by
the java standard libraries. Huang et al.[16] study unsafe crash
patterns and implement a bytecode-level transformation that intro-
duces runtime checks to help diagnose and prevent some memory
errorscausedby the use of the unsafeAPI.
Swift:Swift,introducedbyApple,isintendedtoreplaceObjective-
C,introducedanewerrorhandlingmechanismusingexceptions
thatisnotpresentinObjective-C.Cassee etal.[10]executealarge-
scale study to identify if Swift developers switched to the new
mechanism. They ﬁnd that about half of the projects do not use
thenewerrorhandlingmechanism.Oftheprojectsthatdo,some
followsomeguidelines,butmostdo notfollowthemorecomplex
error-handling recommendations. This fallback to known patternsmayalsoexistinRustsystemscode,asmanyRustsystemsdevelop-
ers likely have experience writing C. That is, Rust developers may
useUnsafe Rust to enable using the C-style code patterns they are
familiarwith.Furtherstudiesarerequiredtounderstandifthisis
the case.
9 Conclusions
In this research, we explore whether Rust is, infact, beingused to
ensure memory safety and avoid concurrency bugs. To answer a
number of research questions, we develop a technique to construct
an extended call graph for Rust and an analysis that determines
whether functions possibly include Unsafe Rust or not, depending
ontheirdependencies.WeconductanumberofexperimentsonRust
code,usingtheresultstoanswerourresearchquestions.Acrossour
dataset,weﬁndthatamajorityofcratesincludefunctionswhich
are possibly unsafe. We also ﬁnd that unsafe function calls are the
most common use of unsafeness, and the unsafeness is through
librarydependenciesratherthanthroughtheuseofthekeyword
unsafe. Perhaps nonintuitively, we ﬁnd that the most downloaded
crates have more unsafe code than other crates. From these results,
it is diﬃcult for users to know if their code is safe, and thus we
present recommendations for helping users understand when they
are using UnsafeRust in their software.
256ICSE ’20,May23–29,2020, Seoul, Republic of Korea Ana Nora Evans, Bradford Campbell,and MaryLou Soﬀa
References
[1] 2020. Rust Subreddit. h/t_tps://www.reddit.com/r/rust/. (2020).
[2]Adam Alami, Marisa Leavitt Cohn, and Andrzej Wasowski. 2019. Why Does
CodeReviewWorkforOpenSourceSoftwareCommunities?.In Proceedingsof
the41stInternationalConferenceonSoftwareEngineering(ICSE’19).IEEEPress,
Piscataway, NJ, USA,1073–1083.
[3]BrianAnderson,LarsBergstrom,ManishGoregaokar,JoshMatthews,Keegan
McAllister, Jack Moﬃtt, and Simon Sapin. 2016. Engineering the Servo Web
BrowserEngineUsingRust.In Proceedingsofthe38thInternationalConferenceon
SoftwareEngineering Companion (ICSE’16).ACM,NewYork, NY, USA,81–89.
[4]Andrew W. Appel, Robert Dockins, Aquinas Hobor, Lennart Beringer, Josiah
Dodds, Gordon Stewart, Sandrine Blazy, and Xavier Leroy. 2014. Program Logics
for CertiﬁedCompilers. Cambridge UniversityPress,NewYork, NY, USA.
[5]DavidF.BaconandPeterF.Sweeney.1996. FastStaticAnalysisofC++Virtual
FunctionCalls.In Proceedingsofthe11thACMSIGPLANConferenceonObject-
oriented Programming, Systems, Languages, and Applications (OOPSLA ’96). ACM,
NewYork, NY, USA,324–341.
[6]Abhiram Balasubramanian, Marek S. Baranowski, Anton Burtsev, Aurojit Panda,
ZvonimirRakamarić,andLeonidRyzhyk.2017. SystemProgramminginRust:
Beyond Safety. In Proceedings of the 16th Workshop on Hot Topics in Operating
Systems(HotOS’17). ACM,NewYork, NY, USA,156–161.
[7]Moritz Beller, Alberto Bacchelli, Andy Zaidman, and Elmar Juergens. 2014. Mod-
ernCodeReviewsinOpen-sourceProjects:WhichProblemsDoTheyFix?.In
Proceedings of the 11th Working Conference on Mining Software Repositories (MSR
2014). ACM,NewYork, NY, USA,202–211.
[8]KevinBoosandLinZhong. 2017. Theseus: A State Spill-free OperatingSystem.
InProceedings of the 9th Workshop on Programming Languages and Operating
Systems(PLOS’17). ACM,NewYork, NY, USA,29–35.
[9]CaseyCasalnuovo,PremDevanbu,AbilioOliveira,VladimirFilkov,andBaishakhi
Ray. 2015. Assert Use in GitHub Projects. In Proceedings of the 37th International
Conference on Software Engineering - Volume 1 (ICSE ’15). IEEE Press, Piscataway,
NJ, USA,755–766.
[10]NathanCassee,GustavoPinto,FernandoCastor,andAlexanderSerebrenik.2018.
How Swift Developers Handle Errors. In Proceedings of the 15th International
Conference on Mining Software Repositories (MSR ’18). ACM, New York, NY, USA,
292–302. h/t_tps://doi.org/10.1145/3196398.3196428
[11]JeﬀreyDean,DavidGrove,andCraigChambers.1995. OptimizationofObject-
OrientedProgramsUsingStaticClassHierarchyAnalysis.In ECOOP’95—Object-
Oriented Programming, 9th European Conference, Åarhus, Denmark, August 7–11,
1995,MarioTokoroandRemoPareschi(Eds.).SpringerBerlinHeidelberg,Berlin,
Heidelberg, 77–101.
[12]C. R. Dougherty and R. C. Seacord. C. 2008. C compilers may silently discard
some wraparound checks. h/t_tps://www.kb.cert.org/vuls/id/162289/. (2008).
[13]Jonathan Eyolfson and Patrick Lam. 2019. How C++ Developers Use Immutabil-
ity Declarations: An Empirical Study. In Proceedings of the 41st International
Conference onSoftwareEngineering(ICSE ’19). IEEE Press,Piscataway,NJ, USA,
362–372.
[14]Patrick Gaydon. 2010. Project Servo, Technology from the past come to save the
futurefrom itself. h/t_tp://venge.net/graydon/talks/intro-talk-2.pdf . (2010).
[15]David Gens, Simon Schmitt, Lucas Davi, and Ahmad-Reza Sadeghi. 2018. K-
Miner:UncoveringMemoryCorruptioninLinux.In 25thAnnualNetworkand
DistributedSystemSecuritySymposium,NDSS2018,SanDiego,California,USA,
February18-21, 2018.
[16]ShiyouHuang,JianmeiGuo,SanhongLi,XiangLi,YuminQi,KingsumChow,
and Jeﬀ Huang. 2019. SafeCheck: Safety Enhancement of Java Unsafe API. In
Proceedingsofthe41stInternationalConferenceonSoftwareEngineering(ICSE’19) .
IEEE Press,Piscataway, NJ, USA,889–899.
[17]Ralf Jung, Hoang-Hai Dang, Jeehoon Kang, and Derek Dreyer. 2019. Stacked
Borrows:AnAliasingModelforRust. Proc.ACMProgram.Lang. 4,POPL,Article
Article41(Dec.2019),32pages. h/t_tps://doi.org/10.1145/3371109
[18]Ralf Jung, Jacques-Henri Jourdan, Robbert Krebbers, and Derek Dreyer. 2017.
RustBelt: Securing the Foundations of the Rust Programming Language. Proc.
ACMProgram. Lang. 2,POPL, Article66(Dec. 2017),34pages.
[19]RalfJung,RobbertKrebbers,Jacques-HenriJourdan,AlesBizjak,LarsBirkedal,
and Derek Dreyer. 2018. Iris from the ground up: A modular foundation for
higher-orderconcurrentseparationlogic. J.Funct. Program. 28(2018), e20.
[20]AmitLevy,BradfordCampbell,BrandenGhena,DanielB.Giﬃn,PatPannuto,
Prabal Dutta, and Philip Levis. 2017. Multiprogramming a 64kB Computer
SafelyandEﬃciently.In Proceedingsofthe26thSymposiumonOperatingSystems
Principles (SOSP ’17). ACM,NewYork, NY, USA,234–251.
[21]Yi Lin, Stephen M. Blackburn, Antony L. Hosking, and Michael Norrish. 2016.
Rust As a Language for High Performance GC Implementation. In Proceedings of
the2016ACMSIGPLANInternationalSymposiumonMemoryManagement(ISMM
2016). ACM,NewYork, NY, USA,89–98.
[22]Luis Mastrangelo, Luca Ponzanelli, Andrea Mocci, Michele Lanza, Matthias
Hauswirth, and Nathaniel Nystrom. 2015. Use at Your Own Risk: The Java
UnsafeAPIintheWild.In Proceedingsofthe2015ACMSIGPLANInternationalConferenceonObject-OrientedProgramming,Systems,Languages,andApplications
(OOPSLA2015). ACM,NewYork, NY, USA,695–710.
[23]Kayvan Memarian, Justus Matthiesen, James Lingard, Kyndylan Nienhuis, David
Chisnall, Robert N. M. Watson, and Peter Sewell. 2016. Into the Depths of
C: Elaborating the De Facto Standards. SIGPLAN Not. 51, 6 (June 2016), 1–15.
h/t_tps://doi.org/10.1145/2980983.2908081
[24]Aurojit Panda, Sangjin Han, Keon Jang, Melvin Walls, Sylvia Ratnasamy, and
ScottShenker.2016. NetBricks:TakingtheVoutofNFV.In Proceedingsofthe12th
USENIXConferenceonOperatingSystemsDesignandImplementation(OSDI’16).
USENIXAssociation, Berkeley, CA, USA, 203–216.
[25]Dmitry Petrashko, Vlad Ureche, Ondřej Lhoták, and Martin Odersky. 2016. Call
Graphs for Languages with Parametric Polymorphism. In Proceedings of the 2016
ACMSIGPLANInternationalConferenceonObject-OrientedProgramming,Systems,
Languages,andApplications(OOPSLA2016).ACM,NewYork,NY,USA,394–409.
[26]P.Rigby,B.Cleary,F.Painchaud,M.Storey,andD.German.2012. Contemporary
Peer Review in Action: Lessons from Open Source Development. IEEE Software
29,6 (Nov2012),56–61.
[27]P. Rigby, D. German, and M. Storey. 2008. Open source software peer review
practices.In 2008ACM/IEEE30thInternationalConferenceonSoftwareEngineering.
541–550.
[28]B. G. Ryder.1979. Constructing the CallGraphof a Program. IEEE Trans.Softw.
Eng.5,3 (May1979),216–226.
[29]Dokyung Song, Julian Lettner, Prabhu Rajasekaran, Yeoul Na, Stijn Volckaert,
Per Larsen, and Michael Franz. 2018. SoK: Sanitizing for Security. CoRR
abs/1806.04355 (2018). arXiv:1806.04355 h/t_tp://arxiv.org/abs/1806.04355
[30]L.Szekeres,M.Payer,T.Wei,andD.Song.2013. SoK:EternalWarinMemory.In
2013IEEE SymposiumonSecurityand Privacy. 48–62.
[31] The Actix Team. 2018. Actix. h/t_tps://github.com/actix/actix. (2018).
[32]TheMozillaResearchTeam.2020. MozillaResearch. h/t_tps://research.mozilla.org/.
(2020).
[33] The RedoxTeam. 2018. Redox. h/t_tps://www.redox-os.org/ . (2018).
[34]TheRustTeam.2018. TheRustLanguageReference. h/t_tps://doc.rust-lang.org/
reference/index.html. (2018).
[35]TheRustTeam.2018. UnsafeCodeGuidelinesReference. h/t_tps://rust-lang.github.
io/unsafe-code-guidelines/. (2018).
[36]The Rust Team. 2019. Unsafe Code Guidelines. h/t_tps://github.com/rust-lang/
unsafe-code-guidelines. (2019).
[37]tx4414. 2018. Unsafe Rust in actix-web, other libraries. h/t_tps://www.reddit.com/
r/rust/comments/8s7gei/unsafe_rust_in_actixweb_other_libraries/. (2018).
[38]XiWang,NickolaiZeldovich,M.FransKaashoek,andArmandoSolar-Lezama.
2013. TowardsOptimization-safeSystems:AnalyzingtheImpactofUndeﬁned
Behavior. In Proceedings of the Twenty-Fourth ACM Symposium on Operating
Systems Principles (SOSP ’13). ACM, New York, NY, USA, 260–275. h/t_tps://doi.
org/10.1145/2517349.2522728
[39]Aaron Weiss, Daniel Patterson, Nicholas D. Matsakis, and Amal Ahmed. 2019.
Oxide: The Essence of Rust. CoRRabs/1903.00982 (2019). arXiv:1903.00982
h/t_tp://arxiv.org/abs/1903.00982
257