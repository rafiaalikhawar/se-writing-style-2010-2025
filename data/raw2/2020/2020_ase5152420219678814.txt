Race Detection for Event-Driven Node.js
Applications
Xiaoning Chang‚Ä†‚Ä°, Wensheng Dou‚Ä†‚Ä°*¬∂, Jun Wei‚Ä†‚Ä°, Tao Huang‚Ä†‚Ä°¬∂, Jinhui Xie¬ß, Y uetang Deng¬ß,
Jianbo Y ang¬ß, Jiaheng Y ang¬ß
‚Ä†State Key Lab of Computer Sciences, Institute of Software, Chinese Academy of Sciences, Beijing, China
‚Ä°University of Chinese Academy of Sciences, Beijing, China
*Nanjing Institute of Software Technology, Nanjing, China
¬ßTencent, Inc., Guangzhou, China
‚Ä†{changxiaoning17, wsdou, wj, tao}@otcaix.iscas.ac.cn,¬ß{hugoxie, yuetangdeng, xiaotuoyang, jiahengyang}@tencent.com
Abstract ‚ÄîNode.js has become a widely-used event-driven
architecture for server-side and desktop applications. Node.js
provides an effective asynchronous event-driven programmingmodel, and supports asynchronous tasks and multi-priorityevent queues. Unexpected races among events and asynchronoustasks can cause severe consequences. Existing race detectionapproaches in Node.js applications mainly adopt random fuzzingtechnique, and can miss races due to large schedule space.
In this paper, we propose a dynamic race detection approach
NRace for Node.js applications. In NRace, we build precise
happens-before relations among events and asynchronous tasks inNode.js applications, which also take multi-priority event queuesinto consideration. We further develop a predictive race detectiontechnique based on these relations. We evaluate NRace on 10 real-world Node.js applications. The experimental result shows thatNRace can precisely detect 6 races, and 5 of them have beenconÔ¨Årmed by developers.
Index T erms‚ÄîNode.js, event-driven architecture, race detec-
tion
I. I NTRODUCTION
Node.js is an increasingly popular event-driven architecture,
and widely used in server-side and desktop applications. The
ofÔ¨Åcial Node.js package manager npm [1] has become the
largest package registry and consists of more than 1,500,000building blocks in April 2021. Nowadays, 50% professionaldevelopers use Node.js to develop their frameworks, librariesand tools [2]. Industrial giants, such as PayPal [3], Uber [4]and Y ahoo [5], also widely adopt Node.js in their systems.
Node.js adopts an event-driven architecture, and provides
an effective asynchronous programming model. In Node.js,time-consuming IO operations, e.g., Ô¨Åle access operations, canbe delegated as asynchronous tasks, running in the dedicatedthreads in libuv [6]. Thus, Node.js applications are not blockedby these time-consuming IO operations. Once an asynchronoustask completes, a completion event is put into certain eventqueue. Different from other event-driven architectures, e.g.,client-side JavaScript [7] and Android [8], [9], Node.js pro-vides multiple event queues, which have different priorities.These events in different event queues are scheduled by thelooper thread, i.e., the main thread in Node.js, based on their
¬∂Wensheng Dou and Tao Huang are the corresponding authors.priorities. Note that, asynchronous tasks are concurrently exe-cuted in the dedicated underlying threads, which are differentfrom the looper thread.
The above asynchronous programming model in Node.js
can introduce races. First, since asynchronous tasks and theircorresponding events are executed asynchronously, unorderedexecutions among events can cause unexpected interleavingsby developers, thus taking the application into faulty states.Second, unordered asynchronous tasks and events can accessto the same external resource e.g., Ô¨Åles, thus introducing races.Races in Node.js applications can cause severe consequences,e.g., unexpected application states, and even worse systemcrashes [10], [11]. As server-side applications, races in Node.jsapplications may affect many end users. Thus, it is importantfor Node.js developers to automatically detect races in Node.jsapplications.
Existing approaches on race detection in event-driven archi-
tectures mainly focus on client-side JavaScript applications [7],[12]‚Äì[17] and Android applications [8], [9], [18]‚Äì[20]. Racedetection approaches in client-side JavaScript applications [7],[12]‚Äì[17] mainly concern programming model features inbrowsers, e.g., DOM and AJAX. Race detection approachesin Android applications [8], [9], [18]‚Äì[20] mainly concernAndroid GUI model and the multi-thread programming model.Note that, all these approaches only consider one event queue
while Node.js supports multiple event queues and schedules
events with different priorities. Therefore, it is challenging
to apply these approaches to Node.js applications, althoughprogramming models of browsers, Android and Node.js areconceptually similar. Recently, a few race detection approacheshave been proposed for Node.js applications. Node.fz [11]adopts the fuzzing technique to randomly perturb event sched-ules. NodeRacer [21] further utilizes happens-before relationsto eliminate infeasible event schedules. However, they onlyexpose limited schedule space, and miss races. NodeA V [22]only detects atomicity violations in Node.js, and ignores otherkinds of races.
In this paper, we propose NRace, a predictive race de-
tector for Node.js applications. Given a Node.js application,NRace records its execution trace, and builds precise happens-before relations among asynchronous tasks and events. Further,
4802021 36th IEEE/ACM International Conference on Automated Software Engineering (ASE)
DOI 10.1109/ASE51524.2021.000502021 36th IEEE/ACM International Conference on Automated Software Engineering (ASE) | 978-1-6654-0337-5/21/$31.00 ¬©2021 IEEE | DOI: 10.1109/ASE51524.2021.9678814
978-1-6654-0337-5/21/$31.00  ¬©2021  IEEE

* . 


"
&

&'(

* .	
* 


."



&
&
'(
 
"&#	$	
' 
	)'"
&-+-+' 

)' 

	
&'(

."
	"

 
."
	"
 
"

&#"$
 &'(


* . 
)' 
	)




&&'(
 ."
	
&#"$' 
&
*' 
),+++' 

	
"

&(

!#$
!
)' 
"

&(

!#$
!
)' 




 !"$
"&!#)"*(

 !##' !#	 !#
 !#"#!$

 !##' !#	 !#
 !#""

 !"$"&!#)"*(
	
	


	
	



 !##' !#	$# !#!#"!%!

	

#	"!')"* "
 !## !##' !#
 %%
%%
Fig. 1. A simpliÔ¨Åed Node.js application. (a) shows a simple web server and two requests. (b) shows its execution process, in which edata iandewrt irepresents
the events for request reqi(i‚àà{1,2}). We present actual Ô¨Åle operations in capital letters, i.e., WRITEFILE andREADF ILE , and distinguish them
from related API invocations, e.g., fs.writeF ile .
NRace predicts races in alternative executions that satisfyhappens-before relations. NRace takes asynchronous tasks andmulti-priority event queues into consideration, and proposes anefÔ¨Åcient algorithm to build and query happens-before relationsin real-world Node.js applications. To reduce benign races,we further propose a few commutative race patterns based onfrequently observed benign races.
To demonstrate the effectiveness of NRace, we evaluate
NRace on real-world Node.js applications from two aspects.First, we evaluate NRace for bug detection on 10 known racesin real-world Node.js applications. The experimental resultshows that NRace is able to effectively detect all 10 knownraces while the state-of-the-art fuzzing technique NodeRaceronly detects 6 races in three hours. Second, we further applyNRace on 10 open-source Node.js applications, and detect 6previously unknown races, 5 of which have been conÔ¨Årmed bydevelopers. NRace and its experimental subjects are availableat https://github.com/tcse-iscas/nrace.
We summarize our main contributions as follows:
‚Ä¢We propose a predictive race detector for Node.js appli-cations, and build precise happens-before relations thatcan handle asynchronous tasks and multi-priority eventqueues in Node.js applications.
‚Ä¢We implement our approach as NRace and evaluate it onreal-world Node.js applications. The experimental resultsshow that NRace can effectively detect races in real-worldNode.js applications.
II. M
OTIV A TION
In this section, we present an illustrative example to explain
the Node.js event-driven programming model and races risingin Node.js applications.
A. Motivating Example
Figure 1(a) shows a simpliÔ¨Åed Node.js web server applica-
tion (Line 1-22) and two requests for it (Line 23-24).
In this web server application, it Ô¨Årst uses API
process.nextTick ()to register event e
create of type NextTick
(Line 3). Then, it registers event etimeout of type Timeout to
execute after 5000 milliseconds (Line 19). When processing
ecreate , the looper thread executes its callback create() to
write the default setting to variable prettyprint (Line 4)
and to create a server (Line 5). The server registers evente
data to process user requests (Line 6). Once a request
arrives, event edata is triggered. The looper thread processes
edata and executes its callback updateLog ()with parameter
chunk , which represents the received data of request. Callback
481updateLog ()parseschunk (Line 11-12) and logs username
into log Ô¨Åle log.json (Line 13).
In order not to block the looper thread, callback
updateLog ()delegates the time-consuming Ô¨Åle writing oper-
ation as an asynchronous task asyncTask to the thread pool
and registers event ewrt to execute after the completion of
asyncTask (Line 13). While the looper thread proceeds, a
thread in the thread pool asynchronously writes Ô¨Åle log.json .
On the completion of asynchronous task asyncTask , event
ewrt is triggered. The looper thread executes its callback wrt()
to update the variable prettyprint according to the request
(Line 15).
For each request, two events edata andewrt, and an
asynchronous task asyncTask are executed. Let‚Äôs assume
that two requests req1andreq2with different pretty-print
conÔ¨Ågurations simultaneously arrive (Line 23-24). Event edata
andewrt and asynchronous task asyncTask will be executed
twice, once per request. For simplicity, we denote edata i,ewrt i
andasyncTask ifor each request reqi(i‚àà{1,2}).
Once 5000 milliseconds elapse, event etimeout is trig-
gered. The looper thread executes its callback show () to
synchronously read log Ô¨Åle log.json (Line 20) and print
contentcont with the pretty-print setting prettyprint (Line
21).
Note that, in Node.js, once an event is generated, it is put
into an event queue. Node.js maintains several event queues
to hold different types of events, i.e., NextTick, Promise,
Immediate, Timeout and IO [23]. Events in the same event
queue are scheduled in the order that they are enqueued.
The looper thread processes Immediate, Timeout and IO
event queues in a round-robin manner. When an event queueis exhausted or the number of processed events reaches athreshold, the looper thread switches to process the next eventqueue. However, if there are events of NextTick type, these
NextTick events will be processed Ô¨Årst before the loop thread
processes any event [23]. Therefore, in Figure 1(a), e
create is
processed before etimeout .
B. Races in Node.js Applications
For each request in Figure 1(a), two events edata andewrt,
and an asynchronous task asyncTask are executed in order
edata‚ÜíasyncTask ‚Üíewrt. However, two executions of
req1andreq2can interleave and thus cause races. Figure 1(b)
shows an execution of races for two requests. We can see threeraces in Figure 1(b).
(1) Event e
timeout can be triggered before asyncTask 1‚Äôs
completion event ewrt 1. Consequently, event etimeout pretty
prints the content of log.json . Compared with the execution
shown in Figure 1(b), this is a race between event etimeout
andewrt 1on variable prettyprint, causing the print format
to be non-deterministic.
(2) Asynchronous task asyncTask 1andasyncTask 2are
concurrently executed in the thread pool and their processingorder in the Ô¨Åle system is unknown. Thus, the content ofÔ¨Ålelog.json is non-deterministic. This is a race between
asyncTask
1andasyncTask 2on Ô¨Ålelog.json .(3) Event etimeout and asynchronous task asyncTask 1can
run concurrently. Their execution order in the Ô¨Åle system isuncertain. Therefore, this is a race between event e
timeout and
asynchronous task asyncTask 1on Ô¨Ålelog.json .
C. Approach Overview
In order to detect races in Node.js applications, we need to
address two technical challenges. First, in addition to memorylocations, how can we model accesses on external resources,e.g., Ô¨Åle log.json in Figure 1(a)? As shown in the above
example, external resources are contended by events and asyn-chronous tasks. In Node.js, external resources are managedby underlying system and opaque to developers. Second,Node.js has its special execution mechanism for events andasynchronous tasks, e.g., the execution order between e
create
andetimeout caused by the multi-priority event queues. How
can we design precise happens-before relations among eventsand asynchronous tasks?
For the Ô¨Årst challenge, we study the Ô¨Åle system APIs in
Node.js and model them into several basic Ô¨Åle access opera-tions with various types, e.g., Crate, Read, Write and Delete.
Then, we further model these Ô¨Åle access operations accordingto whether they are synchronous. Finally, we build preciseconÔ¨Çicting patterns on these Ô¨Åle access operations. Therefore,we can detect races among events and asynchronous tasks onexternal resources. Second, we build precise happens-beforerelations among events and asynchronous tasks. Specially, wedesign an efÔ¨Åcient algorithm to build happens-before relationscaused by multi-priority event queues.
III. A
PPROACH
Figure 2 presents the overview of NRace. Given a Node.js
application with its test cases, NRace can predictively de-tect potential races. First, we run the Node.js application toproÔ¨Åle its execution trace (Section III-A). Then, we designhappens-before relations for Node.js applications, which canreÔ¨Çect the partial order among events and asynchronous tasks(Section III-B). We further design an efÔ¨Åcient algorithm tobuild the happens-before graph for the collect execution trace.(Section III-C). Finally, we detect potential races on conÔ¨Çictingoperations that are not ordered by the happens-before graph(Section III-D) and Ô¨Ålter out benign races using predeÔ¨Ånedcommutative race patterns (Section III-E).
A. Trace Collection
An execution trace of a Node.js application is a sequence
of operations, which are performed by events or asynchronous
tasks. In the following paper, we uniformly call events andasynchronous tasks as actions for simplicity, when we need to
unify events and asynchronous tasks.
Lifecycle related operations. Lifecycle related operations
are used to control the generation and execution of events andasynchronous tasks. We summarize them as follows.
‚Ä¢start(a ): start executing action a, i.e., an event or an
asynchronous task.
482Node.js 
application
& Test caseBug
report
Trace collectionHappens-before graph 
constructionRace detection Pruning races
Fig. 2. The overview of NRace.
‚Ä¢end(a): end executing action a, i.e., an event or an
asynchronous task.
‚Ä¢delegate( e,t) : eventedelegates asynchronous task tto
the thread pool.
‚Ä¢register (ei,ej): eventeiregisters event ej. There are
two cases for event registration. First, event eiregisters
eventejto execute after the completion of an asyn-
chronous task. For example, edata 1registers ewrt 1for
asyncTask 1in Figure 1. Second, Node.js allows devel-
opers to schedule events with several built-in APIs, e.g.,
process.nextTick (),setImmediate(), setInterval ()
andsetTimeout(). That said, event ejis registered
by event eiand will be executed after a period of
time. Events registered by API process.nextTick (),
setImmediate (),setInterval ()andsetTimeout() are
of type of NextTick, Immediate and Timeout1, respec-
tively.
‚Ä¢trigger (t,e) : eventeis triggered by the completion of
asynchronous task tand put into the corresponding event
queue.
‚Ä¢trigger (ei,ej): eventejis triggered by event eiand put
into the corresponding event queue.
‚Ä¢resolve (e,p): When promise pis created, a resolved
eventp.resolved is registered to be executed once the
promisepis resolved (fullÔ¨Ålled) [24]. resolve (e,p)de-
notes that event eresolves promise p.
‚Ä¢pall=Promise.all ([p1,p2,...,pn]): APIPromise.all ()
returns promise pall, which will be resolved after all
promises p1,p2,...,pnare resolved, or rejected after one
of promises p1,p2,...,pnis rejected.
‚Ä¢prace =Promise.race ([p1,p2,...,pn]): API
Promise.race ()returns promise prace , which will be
resolved or rejected after one of promises p1,p2,...,pn
is resolved or rejected.
Resource access operations. Resource access operations
include memory access operations and external resource accessoperations. We summarize them as follows.
‚Ä¢read(v,val,e ): eventereads memory location vand
obtains value val . We consider both reading variables
and getting Ô¨Åelds of objects as read operations.
‚Ä¢write (v,val,e ): eventewrites value val to memory lo-
cationv. Similarly, we consider writing variables, putting
Ô¨Åelds and deleting Ô¨Åelds of objects as write operations.
‚Ä¢fileAccess( f,type,a) : actona, i.e., an event or an
asynchronous task, accesses Ô¨Åle fwith access type
type. To model external resource accesses, we map
1Events registered by setInterval () and setT imeout() are of type
Timeout.each Ô¨Åle system API into one or multiple operations.In particular, we support seven access types on Ô¨Åles,i.e., Create, Open, Read, Write Close, Delete, and
Stat. For example, fs.readFileSync(bar.txt) invoked
by event eis modeled as fileAccess( bar.txt,Read,e) .
We model an asynchronous Ô¨Åle access into a sequenceof lifecycle related operations and Ô¨Åle access opera-tions. For example, fs.readFile (bar.txt,cb) invoked
by event eis modeled as a sequence of operations:
delegate( e,t) ,start (t),fileAccess( bar.txt,Read,t) ,
end(t)andstart(cb ), wheretis the asynchronous task
that performs the Ô¨Åle access operation and cb is the
completion event of asynchronous task t.
Other operations. In addition to above operations, we also
track following operations, which are used to Ô¨Ålter benignraces in Section III-E.
‚Ä¢conditional (val,e ): eventeperforms a if‚àícheck and
the checking result is val .
‚Ä¢binary (opt,left,right,val,e ): eventeperforms a bi-
nary operation, whose left and right operands are left
andright , respectively. The operator and result of binary
operation is opt andval , respectively.
In NRace, we utilize async hooks [25] to track lifecycle
related operations. async hooks provides several functions
to record lifecycle related operations, e.g., init(),before(),
after (),promiseResolve (). For example, every time an
eventeis registered, function init() is called to track the type
of event eand the event that registers e. We further utilize
Jalangi [26] to track the remaining operations. For example,Jalangi records the names of variables and the values writteninto the variables for write operations so that it can track
information for resource access operations.
B. Happens-Before Relation
Given an execution trace œÑ, happens-before relation ‚â∫is
a partial relation among actions in trace œÑ, i.e., events and
asynchronous tasks. For action act
iandactj, we denote acti
happens before actjasacti‚â∫actj.
In addition, we also build happens-before relations over
operations performed by actions. For operation opiandopj,
we denote opihappens before opjasopi‚â∫opj. We overload
happens-before operator ‚â∫for both actions and operations.
Rule 1 (Transitivity): The happens-before relation ‚â∫is
transitive, i.e., for action acti,actjandactk,i facti‚â∫actk
andactk‚â∫actj, thenacti‚â∫actj.
Rule 2 (Program-Order): Operations performed by the
same action are deterministically executed in the program
order. If operation opiandopjare executed by the same action
andopioccurs before opjin traceœÑ, thenopi‚â∫opj.
483Rule 3 (Event-Atomicity): Each event is executed without
interruption. That said, for operation opiandopjperformed by
eventeiandejrespectively, if opi‚â∫opj, then any operation
ineihappens before any operation in ej.
Rule 4 (Event-Registration): Each event needs to be
registered before it is processed. That said, if event ejis
registered by event ei, thenei‚â∫ej.
Rule 5 (SetInterval): If events e1,e2,...,enare registered
in order via API setInterval (), then these events are executed
in the registration order, i.e., ei‚â∫ei+1 for1‚â§i‚â§n‚àí1.
Rule 6 (Promise-Resolve): If eventeiresolves promise p
and event ejis the resolved event associated with promise p,
thenei‚â∫ej.
Rule 7 (Promise-All): If promises p1,p2,...,pnare argu-
ments passed to API Promise.all ()and promise piis resolved
by event ei, thenpall is resolved after e1,e2,...,en. In other
words, the resolved event eallassociated with pallis executed
aftere1,e2,...,en. Therefore, we build happens-before relation
ei‚â∫eall, where 1‚â§i‚â§n.
Rule 8 (Promise-Race): If promises p1,p2,...,pnare ar-
guments passed to API Promise.race ()and promise piis
resolved by event ei, thenprace is resolved after one of
e1,e2,...,en. In other words, the resolved event erace asso-
ciated with prace is executed after one of e1,e2,...,en.
We build the happens-before relation among e1,e2,...,en
anderace in an alternative manner. We Ô¨Årst check happens-
before relations among e1,e2,...,en. If there exists two events
eiandejsuch that ei‚â∫ej, then we remove the corresponding
promisepjfrom arguments of API Promise.race (), where
1‚â§i,j‚â§n. If there is only one remaining promise pkas the
argument of API Promise.race (), we build happens-before
relationek‚â∫erace .
Rule 9 (AsyncTask-Delegation): If eventedelegates an
asynchronous task t, thendelegate (e,t)‚â∫start(t) .
Rule 10 (AsyncTask-Completion): If the completion of
asynchronous task ttriggers event e, thent‚â∫e.
Rule 11 (FIFO): Events of the same type are put into the
same event queue. The looper thread processes events in the
same event queue in FIFO order. For event eiandejwith
the same type, i.e., NextTick ,Immediate andPromise ,
ifeiis registered before ejis registered, then ei‚â∫ej.I n
particular, for IO eventeiandej,i feiis triggered before ej,
thenei‚â∫ej.
Rule 12 (FIFO-Timeout): Events of Timeout type are also
processed in the FIFO manner. For event eiandejofTimeout
type, ifeiis registered before ejis registered and the delay
time ofeiis no more than that of ej, thenei‚â∫ej.
Rule 13 (NextTick): Events of NextTick type hold the
highest priority to be executed. For event eiandej, whereei
is of NextTick type while ejis other types, if eiis registered
beforeejis executed, then ei‚â∫ej.
Discussion. Some existing works, e.g., NodeRacer [21],
NodeA V [22], and AsyncG [27], also propose some happens-before relations for Node.js applications. NodeRacer [22] andAsyncG [27] only focus on happens-before relations amongevents, and ignore happens-before relations between eventsand asynchronous tasks. They also ignore happens-before re-lations among operations. Thus, they do not contain happens-before rule 2, 3, 9 and 10. NodeA V [22] treats asynchronous IOtasks as synchronous operations, and cannot reÔ¨Çect happens-before rule 9 and 10. Further, NodeA V does not supporthappens-before rule 6, 7, 8, and ignores the delay time inrule 12.
Therefore, these existing works lack some key happens-
before rules for detecting races in Node.js applications. Ourhappens-before relations can reÔ¨Çect the relations among eventsand asynchronous tasks, and relations among operations. Thus,our happens-before relations are more complete and precisethan existing works. We believe that our happens-beforerelations can also beneÔ¨Åt existing works.
C. Happens-Before Graph Construction
Based on an execution trace œÑ, we build a happens-before
graphG(V,E), in which node v‚ààVis an action and edge
e‚ààErepresents the happens-before relation among actions.
NodeRacer [21] and NodeA V [22] adopts the following
algorithm to construct the happen-before graph. (a) The al-
gorithm Ô¨Årst adds all actions into the graph. (b) Then, itbuilds happens-before relations for simple rule 4-7 and rule9-10, which do not depend on any other relations. (c) Next, itbuilds happens-before relations introduced by complex rules,i.e., Promise-Race, FIFO, FIFO-Timeout and NextTick, whichdepend on other relations. The algorithm checks whether eachpair of actions satisÔ¨Åes one of complex rules. If yes, thecorresponding relation is added into the graph.
Note that, in step (c), the newly added relations may
introduce other happens-before relations on actions that wehave evaluated through complex rules. Therefore, if step (c)Ô¨Ånds a new relation, the graph needs to be reprocessed again.In other words, the graph is processed until no more relationis found. The above recursive process is time-consuming ifthere are many actions that can be applied for Promise-Race,FIFO, FIFO-Timeout and NextTick rules in trace œÑ.
In order to efÔ¨Åciently build the happens-before graph, we
design an algorithm scalable to real-world Node.js applica-tions, as shown in Algorithm 1. Our algorithm reduces theoverhead of happens-before graph construction from followingaspects:
‚Ä¢Incremental graph construction: Our algorithm starts withempty set of nodes and edges (Line 1-2), and incremen-tally builds the happens-before graph in the trace order(Line 3). After action act is added into graph (Line 5), we
only need to build happens-before relations on a limited
number of actions in the graph (Line 6-7), instead of all
of actions in NodeRacer [21] and NodeA V [22].
‚Ä¢EfÔ¨Åcient rule matching: Given an action act,w ee f Ô¨Å -
ciently Ô¨Ånd action act/primethat happens before act for both
simple and complex rules (Line 6-7). In particular, itoptimizes the happens-before relation construction forcomplex rules so that it does not perform the recursiveprocess and reduces the overhead, which is done viafunctionbuildComplexHB ()(Line 7).
484Algorithm 1: Happens-before graph construction
Input:œÑ(Execution trace)
Output: G(V,E)(Happens-before graph)
1V‚Üê‚àÖ ;
2E‚Üê‚àÖ ;
3fori‚Üê1;i‚â§œÑ.length ;i++ do
4act‚ÜêœÑ[i];
5V‚ÜêV‚à™{act};
6buildSimpleHB (V,E,act );
7buildComplexHB (V,E,act );
8end
9Function buildComplexHB (V,E,act )
10applyRaceRule( act);
11U‚ÜêselectUnorderedAction(act );
12U/prime‚ÜêsortUnorderedAction (U);
13 forj‚Üê1;j‚â§U/prime.length;j++ do
14 act/prime‚ÜêU/prime[j];
15 forrule‚ààcomplexRules do
16 ifisMatch( act/prime,act,rule )then
17 E‚ÜêE‚à™{(act/prime,act)};
18 end
19 end
20end
‚Ä¢EfÔ¨Åcient reachability query: Since there is a large num-
ber of actions in the happens-before graph, it is time-consuming to perform the breadth-Ô¨Årst graph search toquery reachability. We improve the breadth-Ô¨Årst searchby stopping exploring impossible paths in advance.
We illustrate the above three ingredients as follows.
Incremental graph construction. We observe that, given
an action act to be added into the graph, only actions that
occur before act in traceœÑmay happen before act. Otherwise,
traceœÑwill be infeasible. Based on this observation, we
incrementally build the happens-before graph, by adding one
actionact into the graph according to the trace order (Line
3). For each added action act (Line 5), we only need to build
happens-before relations between action act and other actions
in the graph.
Note that, event e
race involved in Promise-Race rule is
processed differently because the relation caused by Promise-Race rule on e
race is determined after e1,e2,...,enthat are
related to arguments of API Promise.race ()are added into
the graph. Therefore, after all of e1,e2,...,enare added into
graph, we add erace into the graph and build happens-before
relations for it.
EfÔ¨Åcient rule matching. Given action act and rule rule ,
we Ô¨Ånd action act/primethat happens before action act and build
happens-before relation between act/primeandact.
For simple rules, we directly Ô¨Ånd action act/primeand
build happens-before relation between act/primeandact in a
constant time. For example, when processing operationregister (e
1,e2), we store registrar information e1ine2. When
evaluating registration rule for e2, we Ô¨Ånd e1and obtaine1‚â∫e2directly.
We build happens-before relations for AsyncTask-
Delegation rule in a special manner. For this rule, wecannot obtain delegate( e,a)‚â∫start(a ), because there
are only actions but not operations in the happens-beforegraph. In order to build relations between eanda,w e
make a compromise: NRace builds the edge from etoain
the happens-before graph. We will handle this case whenquerying happens-before relations among operations, and itcauses no false happens-before relation among operations.Thus, our race detection cannot be compromised.
For complex rules, we Ô¨Årst evaluate Promise-Race rule for
act (Line 10), since the Promise-Race rule only depends on
the relation on the set of events corresponding to argumentsof APIPromise.race (), which has been determined.
Then, we evaluate the remaining complex rules, i.e., FIFO,
FIFO-Timeout and NextTick rule for act (Line 11-19). In
order to avoid the recursive process, our algorithm performsfollowing optimizations.
Optimization 1: Find unordered actions. As discussed ear-
lier, NodeRacer attempts to build relations for complex ruleson each pair of actions in step (c), and wastes time onevaluating pairs of actions that have already been ordered byhappens-before relations. This motivates us to avoid applyingcomplex rules on ordered actions.
We adopt chain decomposition [9], [13] to Ô¨Ånd unordered
actions. The idea of chain decomposition is to assign actionsto chains so that actions on the same chain are ordered byhappens-before relations, and actions on the different chainsmay be unordered. We use a‚äøc to denote that action ais on
chainc.
Our chain decomposition algorithm is described as follows.
When we add action act into the happens-before graph by
simple rules, we greedily assign action act to a chain. (i) We
Ô¨Årst Ô¨Ånd the set of actions A, where actions in Ahave happens-
before edges with act. (ii) If there exists an action act
/prime‚ààA,
after adding act intoact/prime‚Äôs chainc/prime, chainc/primedoes not diverge,
then we assign act to chainc/prime. (iii) If such an action does not
exist, we create a new chain and assign act to it. For example,
in Figure 3, before adding e7into the graph, e1,e2,...,e 6are
assigned to two chains c1andc2. When adding e7into the
graph, we Ô¨Ånd e6‚â∫e7, and assigning e7to chainc2does not
makec2diverge. Therefore, e7is added into chain c2.
Given a newly added action act, function
selectUnorderedAction() (Line 11) Ô¨Ånds actions, which
are unordered with act. Letcact denote the chain that
act belongs to, i.e., act ‚äø c act. For each chain cthat is
different from cact, we identify its unordered actions with act
through the following process. We Ô¨Ånd the last action acti
inc, which satisÔ¨Åes the following condition: ‚àÉactj‚äøcact,
acti‚â∫actj&(actj‚â∫act||actj=act). Actions that happen
afteractiin chain care unordered with act. For example,
in Figure 3, when action e7is added into the graph, we Ô¨Ånd
thate6happens before e7on chain c2, ande2on chain c1
happens before e6. Therefore, e3ande4on chain c1are
unordered with e7.
485‹ø‡¨µ
‹ø‡¨∂›Å‡¨µ ›Å‡¨∂ ›Å‡¨∑ ›Å‡¨∏
›Å‡¨π ›Å‡¨∫ ›Å‡¨ª
Fig. 3. A happens-before graph example with chain decomposition. Two
chains c1andc2are denoted by light grey and dark grey, respectively.
Optimization 2: Determine action evaluation order . As
discussed earlier, NodeRacer recursively applies complex rules
until the graph reaches a Ô¨Åxpoint. In order to avoid the recur-sive process, we determine an evaluation order for unorderedactions via function sortUnorderedAction ()(Line 12). For
actionact
a,actb‚ààU,i fact ahappens before actbon the
same chain, actais sorted before actbinU/prime. Then, we apply
complex rules between action act/prime‚ààU/primeandact (Line 13-19).
Note that, the newly added relation on act/primeandact only
introduces relations on actions that are registered by act/prime.F o r
example, in Figure 3, if we add the relation from e3toe7,
denoted as (e3,e7), which is not present in the graph, relation
(e3,e7)only introduces relations on actions registered by e3,
e.g.,e4. These successor actions happen after act/primeand are
not evaluated. Therefore, if we evaluate actions following thechain order, we do not need to recursively evaluate complexrules on the graph.
EfÔ¨Åcient reachability query. The reachability among nodes
in the happens-before graph GreÔ¨Çects happens-before rela-
tions among events and asynchronous tasks. For node uand
v, iff there is a path from utovinG,u‚â∫v.
We adopt breadth-Ô¨Årst graph search to query reachability
in the happens-before graph G. The breadth-Ô¨Årst graph search
has a maximum time complexity of O(E). However, since
Node.js applications generates a large number of actions in ashort time, there is a large number of nodes along with edgesin the happens-before graph. The breadth-Ô¨Årst graph searchdoes not scale to real-world Node.js applications.
We observe that, if node n
kdoes not occur before node nj
in the trace œÑ, denoted as nk‚äÄœÑnj, thennk‚äÄnjand there is
no path from nitonjthroughnk. Based on this observation,
to speed up querying reachability from node nito nodenj,
we stop traversing to node nk, wherenk‚äÄœÑnj. The beneÔ¨Åt
is that, we stop exploring impossible paths in advance, thusimproving efÔ¨Åciency.
Based on happens-before relations among actions, we can
determine happens-before relations among operations. Foroperation op
iandopj,opi‚â∫opjif:
‚Ä¢opiandopjare performed by the same action and opi‚â∫œÑ
opjor
‚Ä¢opiandopjare performed by different actions and
action (opi)‚â∫action (opj), whereaction (op) denotes
the action that performs operation op.
When querying reachability, we deal with the compro-
mise case introduced by AsyncTask-Delegation rule whenbuilding the happens-before graph. If action (op
i)delegatesT ABLE I
FILE ACCESS CONFLICTING P A TTERNS
Create Delete Read Write Open Close Stat
Create /diamondmath/diamondmath /diamondmath /diamondmath /diamondmath /diamondmath /diamondmath
Delete /diamondmath/diamondmath /diamondmath /diamondmath /diamondmath /diamondmath /diamondmath
Read /diamondmath/diamondmath /diamondmath /diamondmath /diamondmath
Write /diamondmath/diamondmath /diamondmath /diamondmath /diamondmath /diamondmath
Open /diamondmath/diamondmath /diamondmath /diamondmath /diamondmath
Close /diamondmath/diamondmath /diamondmath /diamondmath /diamondmath /diamondmath
Stat /diamondmath/diamondmath
If two types intersect at /diamondmath, they form a conÔ¨Çicting pattern.
action (opj)and the delegation operation occurs before opiin
action (opi), thenopi‚äÄopj.
We deÔ¨Åne concurrency relation as Con(opi,opj)=op i‚äÄ
opj‚àßopj‚äÄopi. That said, if neither opihappens before opj
noropjhappens before opi,opihas the concurrency relation
withopj. We can further reÔ¨Åne the above concurrency relation
asCon(opi,opj)=op i‚â∫œÑopj‚àßopi‚äÄopj‚à®opj‚â∫œÑopi‚àß
opj‚äÄopi, to reduce the number of reachability queries.
D. Race Detection
In Node.js applications, conÔ¨Çicting operations can be oper-
ations that access to memory locations and external resources,e.g., Ô¨Åles. We explain them as follows.
‚Ä¢ConÔ¨Çicting memory access operations. Two memoryaccess operations conÔ¨Çict when they access the samememory location and at least one of them is write
operation.
‚Ä¢ConÔ¨Çicting Ô¨Åle access operations. We deÔ¨Åne Ô¨Åle con-Ô¨Çicting patterns based on the equivalent inÔ¨Çuence ofaccess type on Ô¨Åle system. The Ô¨Åle conÔ¨Çicting patternsare shown in Table I. Two Ô¨Åle access operations conÔ¨Çictwhen they access the same Ô¨Åle and their access typematch one of our predeÔ¨Åned conÔ¨Çicting patterns. Notethat, our pattern is more powerful than NodeA V [22],in which Ô¨Åle access operations are only modeled as Read
and Write. For example, fs.statSync() is modeled as an
operation of Read, and fs.writeFileSync() is modeled
as an operation of Write. However, they do not conÔ¨Çict in
fact. Our Ô¨Åle conÔ¨Çicting patterns can precisely describethis un-conÔ¨Çicting case.
Consider two operations op
iandopj, a race exists be-
tweenopiandopj, denoted as Race (opi,opj), if (1) they
conÔ¨Çict and (2) opihave concurrency relation with opj, i.e.,
Con(opi,opj)=true.
We Ô¨Årst process the observed trace œÑto obtain the set
of operations that access the same resource x:Op(x)=
{opi|opiaccesses resource x}. For each pair of operations
(opi,opj)inOp(x), we check whether they have concurrency
relation, i.e., Con(opi,opj)=true.
E. Pruning Races
We observe that the above detection approach by Ô¨Ånding
unordered conÔ¨Çicting operations leads to many benign races.We Ô¨Ånd that some commutative operations do not need to beordered by happens-before relations to ensure correctness. To
486	#



	
 


" 
  
	 
 	#

	 

  

 	#

 !
!
!
Fig. 4. Commutative pattern summarized from ad-hoc synchronization, where
eirepresents event e1ande2.
address this issue, we summarize three commutative patterns
to automatically Ô¨Ålter benign races.
Sequentialize actions. Node.js developers often utilize ad-
hoc synchronization to force multiple actions to execute insequence. For instance, in Figure 4, event e
1ande2is
registered by API setImmediate ()andsetTimeout(), re-
spectively (Line 2-3). Event e1ande2delegates asynchronous
Ô¨Åle writing task asyncTask 1andasyncTask 2, respectively
(Line 7). If one event (e.g., e1) launches an asynchronous task
(e.g.,asyncTask 1), variable doing is set totrue. If another
event (e.g., e2) is executed before the previous asynchronous
task (e.g., asyncTask 1) completes, it does not launch its
asynchronous task (e.g., asyncTask 2). In this way, developers
prevent multiple asynchronous tasks from being concurrentlyexecuted. Therefore, although event e
1has a race with event
e2on variable doing , there is no harmful impact on the
application.
To detect this benign race, we analyze conditional and write
operations to identify the variable that sequentializes actions. Ifa variable vis read in the conditional operation and two write
operations on variable vhappen before and after an action,
respectively, then variable vprotects actions from races. Any
race on this variable is regarded as a benign race.
In our approach, we utilize Jalangi [26] to record
conditional operations. Since Jalangi only records
values but not variables for conditional operations, we
utilizeread(x
r,valr,e) operation that occurs before
conditional (valc,e)to infer the variable accessed by the
conditional operation. If valr=valc, then variable vr
accessed by read operation is regarded as the variable
accessed by conditional operation.
Use counters. Node.js applications often utilize counters.
One case is that multiple events increase a counter. Nomatter which order these events are executed in, the counteris correctly increased. Another case is that, after a Node.jsapplications increases a counter, it checks whether the valueof the counter equals to a given threshold. If true, the programwill execute some functions. These read andwrite operations
on the counter have no harmful impact on the application,since the counter does not reach the threshold.
A variable vis a counter variable if it satisÔ¨Åes the following
conditions. (a) V ariable vis used by three operations insequence, i.e., read,binary andwrite . (b) V ariable vis read
by aread operation, and written by a write operation. (c)
binary operation‚Äôs operator is addition or subtraction (i.e., +
or‚àí), and its two operands are of type Number . (d)binary
operation‚Äôs left operand (or right operand) uses variable v, and
its return result uses variable v.
Similar to conditional operations, Jalangi only records
values but not variables for binary operations. We utilize
read(x
r,valr,e)andwrite (xw,valw,e)operation that occur
before and after binary (op,left,right,val b,e)to infer the
variable accessed by binary operation. If varr=left (or
varr=right ), we treat variable vris used as left (or right)
operand of binary operation. If varb=valwwe treat variable
xwis used as return result of binary operation.
Write shared resource with the same value. Some
operations are commutative because they write the sharedresource with the same value. The shared resource holdsthe same value no matter in which order two events areexecuted. Therefore, for two operations write
1(x,val 1,e1)
andwrite 2(x,val 2,e2), if they are unordered and val1equals
toval2, we regard them as commutative operations.
Note that, the commutative patterns we design are not
sound. Without mining developer intention and semantics ofoperations, we cannot ensure the commutativity between ac-tions and operations. For example, counter variables identiÔ¨Åedby our patterns are only self-increasing counters and actualcounters are missed. However, we manually inspect benignraces reported in our evaluation and Ô¨Ånd our patterns canidentify more than half of benign races.
IV . E
V ALUA TION
Our evaluation answers the following research questions:
‚Ä¢RQ1: Can NRace detect known races in real-worldNode.js applications? How does NRace compare with thestate-of-the-art fuzzer NodeRacer [21]?
‚Ä¢RQ2: Can NRace detect previously-unknown races inreal-world Node.js applications?
‚Ä¢RQ3: What is the runtime overhead of NRace, comparedwith NodeRacer [21]?
A. Experimental Setup
Dataset-1: Known races. To evaluate whether NRace can
detect known races in real-world Node.js applications, wecollect 10 known races from NodeRacer [21]. NodeRacerprovides 11 known races in Node.js applications along withtheir test cases. Since one of these 11 Node.js applications,linter-stylint, cannot be proÔ¨Åled via async
hooks module, we
only perform the evaluation on 10 Node.js applications, asshown in Table II. Column Project refers to applications, col-
umn Description gives a brief description of each application,
column Issue ID shows the issue report ID in GitHub, and
column Category denotes locations where races happen. Event
and Async denotes races happen on events and asynchronous
tasks, respectively.
Dataset-2: Unknown races. To evaluate whether NRace
can detect previously-unknown races in real-world Node.js
487T ABLE II
DA T ASET -1: K NOWN RACES IN REAL -W ORLD NODE .JSAPPLICA TIONS
ID Project Description Issue ID Category
1 agentkeepalive Support keepalive http agent 23 Event
2 Ô¨Åware-pep-steelskin TID‚Äôs implementation of FIW ARE PEP GE 269 Event
3 ghost The headless CMS for publication 1,834 Event
4 node-mkdirp Like mkdir-p, but in Node.js 2 Async
5 nes A webSocket adapter plugin 18 Event
6 node-logger-Ô¨Åle File endpoint for cinovo-logger 1 Async
7 socket.io Real-time application framework 1,862 Event
8 del Delete Ô¨Åles and directories 43 Async
9 simplecrawler Flexible event driven crawler for Node.js 298 Event
10 xlsx-extract Extract data from XLSX Ô¨Åles 7 Async
T ABLE III
DA T ASET -2: R EAL -W ORLD NODE .JSAPPLICA TIONS
ID Project Description #Star LoC
1 nedb A JavaScript Database 12,200 1,531
2 node-http-proxy A full-featured http proxy 11,800 502
3 baobab JavaScript persistent data tree 3,100 198
4 simplecrawler Flexible event driven crawler for Node.js 2,100 1,6065 serve-static Serve static Ô¨Åles 1,200 159
6 nodejs-websocket A websocket server and client module 646 689
7 ncp Asynchronous recursive Ô¨Åle copying 601 231
8 line-reader Asynchronous line-by-line Ô¨Åle reader 427 256
9 json-Ô¨Åle-store A simple JSON store 184 1,192
10 Ô¨Åware-pep-steelskin TID‚Äôs implementation of FIW ARE PEP GE 11 1,735
applications, we collect 10 Node.js applications from GitHub
that satisfy following conditions: (1) The application is able torun on Node.js 8.6 or above, which supports the async
hooks
module to track events. (2) The application offers available testcases so that we can use them to drive the application to collectexecution trace. Finally, we collect 10 Node.js applications, asshown in Table III. Column Project refers to the application,
column Description gives a brief description of the application,
column #Star shows the number of stargazers on GitHub,
and column LoC presents lines of JavaScript code, computed
by tool cloc [28]. We can see that most of experimental
applications are popular.
We conduct our experiments in following steps. First, we
utilize NRace to instrument the source code of the targetapplication and utilize the test case to drive the application tocollect execution trace. Second, we run NRace to analyze theobserved trace. To answer RQ1, we use NRace and NodeRacerto detect known races on the dataset-1. To answer RQ2, weperform NRace on dataset-2 to detect previously-unknownraces. For both RQ1 and RQ2, we manually inspect the codeto validate whether each detected race is real. To answer RQ3,we measure the runtime overhead of NRace and NodeRacer. Inparticular, in order to compare the overhead of happens-beforegraph construction between NRace and NodeRacer [21], weimplemented the happens-before graph construction algorithmadopted by NodeRacer, because the data structure of traceand happens-before graph of NodeRacer is different fromours and cannot be integrated into NRace. We compare theruntime overhead of our proposed happens-before constructionT ABLE IV
DETECTION RESUL T ON DA T ASET -1
IDNRace NodeRacer
Detected #Total #HR #BR #FP Detected
1 Y es 4 2 2 (2) 0 No
2 Y es 13 2 10 (7) 1 Ye s
3 Y es 1 1 0 (0) 0 Ye s
4 Y es 1 1 0 (0) 0 Ye s
5 Y es 2 1 1 (1) 0 Ye s
6 Y es 9 8 1 (0) 0 No
7 Y es 1 1 0 (0) 0 No
8 Y es 7 3 4 (4) 0 Ye s
9 Y es 11 1 7 (4) 3 Ye s
10 Y es 3 1 0 (0) 2 No
Total 10 52 21 25 (18) 6 6
algorithm and NodeRacer‚Äôs algorithm. All experiments wereconducted on 4-core 2.4GHz with 16GB memory, runningmacOS Catalina release 10.15.6.
B. Detect Known Races
We run NRace on dataset-1 to measure the NRace‚Äôs ability
to detect known races. The result is shown in Table IV.
Columns 2-6 present the result of NRace, where columnDetected indicates whether the known race is detected by
NRace. Column #Total presents the total number of races
that NRace reports, calculated by #HR +#BR +#FP,
where #HR, #BR and #FP represents the number of harmful
races, benign races and false positives reported by NRace,respectively. Note that the known race is included in #HR and
the number of benign races automatically identiÔ¨Åed by NRaceis shown in the bracket in column #BR.
488As shown in Table IV, NRace detects all 10 known races.
We further report 42 new races from 7 Node.js applications.
After manual inspection, we Ô¨Ånd these new races can beclassiÔ¨Åed into three categories: harmful races, benign racesand false positives.
All of newly detected harmful races are side-effect races
of the known races. For example, in project Ô¨Åware-pep-
steelskin, once a request req returns, event e
req writes variable
currentToken with returned data. However, if there are two
requests req1andreq2, the execution order between event
ereq1andereq2is non-deterministic. If event ereq2is executed
before event ereq1,ereq1overwrites variable currentToken
with returned data of req1, making request req2hangs. One
of side-effect races is that, if event ereq1throws an error after
ereq2, it also overwrites currentToken withnull , making
req2hangs.
As shown in Table IV, 25 out of newly detected races are
benign races, which is consistent with the fact that there isa large number of benign races in Node.js applications. Mostof these benign races (18/25) are automatically identiÔ¨Åed byNRace.
False positives are determined by manual reproduction or
related code review. As shown in Table IV, NRace reports6 false positives. These false positives are caused by ad-hocsynchronization. For example, in project simplecrawler, event
e
add caches a URL for crawling in future and event ereq
invokes a request to crawl a given URL. If event ereq is
executed before eadd, eventereq will Ô¨Ånd that there is no URL
under crawling. Thus, it will invoke stop() method to end up
crawling. As a result, event eadd will not occur any more.
Note that, although we have detected all known races in our
experiment, as a dynamic approach, we can still miss races ifthe provided test cases do not cover race-related events.
Comparison with NodeRacer. In order to compare NRace
with the state-of-the-art fuzzer NodeRacer, we utilize NodeR-acer to detect races in 100 runs and set one hour as timeoutfor it. If NodeRacer does not detect a known race in one hour,we regard that NodeRacer does not detect the race.
Column 7 of Table IV indicates whether the known race
is detected by NodeRacer. As shown in Table IV, NodeRacercan only detect 6 out of 10 within the given timeout.
We investigate why NodeRacer fails to Ô¨Ånd four bugs in our
experiment and Ô¨Ånd three reasons. First, although NodeRacereliminates the schedule space with the help of happens-beforerelations, it can still miss races because of the large schedulespace. For example, there are 277 events in project socket.io.
Under the guidance of happens-before relations, the number ofpossible event schedules is 24,640. So, 100 runs only explores0.4% of the schedule space. Second, NodeRacer only fuzzesthe execution of events but does not perturb the execution of
asynchronous tasks, which further reduces the possibility toexpose races on external resources, e.g., the missing races inproject node-logger -Ô¨Åle and xlsx-extract. Further, NodeRacer
can miss races if it runs out of time, e.g., the missing race inproject agentkeepalive. This result demonstrates that NRace isT ABLE V
DETECTION RESUL T ON DA T ASET -2
ID Project #Total #HRace #BRace #FP
1 nedb 2 0 1 (0) 1
2 node-http-proxy 0 0 0 (0) 0
3 baobab 0 0 0 (0) 0
4 simplecrawler 5 0 4 (2) 1
5 serve-static 0 0 0 (0) 0
6 nodejs-websocket 2 0 2 (1) 07 ncp 2 0 2 (2) 0
8 line-reader 2 0 2 (1) 0
9 json-Ô¨Åle-store 1 1 0 (0) 0
10 Ô¨Åware-pep-steelskin 13 5 6 (3) 2
Total 27 6 17 (9) 4
more effective than NodeRacer to detect races in real-world
Node.js applications.
C. Detect Unknown Races
We run NRace on dataset-2 to measure the NRace‚Äôs ability
to detect previously unknown races. Column #Total in Table V
shows the number of detected races. As shown in Table V,
NRace detects 27 races on dataset-2 in total. After manualinspection, we classify detected races into three categories:harmful races, benign races and false positives, the numberof which is shown in column #HRace, #BRace and #FP, re-
spectively. Similarly, the number of benign races automaticallyidentiÔ¨Åed by NRace is shown in bracket in column #BRace.
NRace detects 6 harmful races in project json-Ô¨Åle-store and
Ô¨Åware-pep-steelskin. For example, in json-Ô¨Åle-store, event e
sv
saves data with id myId into the JSON Ô¨Åle and event erm
deletes data with the same id. The unordered event esvand
erm make the content of the JSON Ô¨Åle non-deterministic. We
have submitted these detected races to developers. Five racesin project Ô¨Åware-pep-steelskin is acknowledged by developers.
Table V shows that NRace reports 4 false positives, which
are also caused by ad-hoc synchronization, as discussed indataset-1.
NRace detects 17 benign races. For example, in project
nodejs-websocket, event e
beg asks the connection to begin
transmitting data and event ecls closes the connection. Con-
sider event ecls is executed before ebeg to set variable state
toCLOSING . When event ebeg is executed, it reads variable
state and Ô¨Ånds variable state does not equal to OPEN ,i t
does not send data. Therefore, the race between event ebeg and
eclshas no harmful impact on the application. NRace automat-
ically identiÔ¨Åes 9 out of 17 benign races. More commutativepatterns could be designed to enhance our approach.
D. Overhead
In Table VI, columns 2-5 report the performance of NRace,
where column TC, HBC, DP and Tdenotes the time for
trace collection, happens-before graph construction, ofÔ¨Çine
race detection along with pruning, and the total time calculatedbyTC+HBC +DP , respectively.
As shown in Table VI, NRace detects races within a few
seconds. The overhead in NRace is introduced by trace collec-tion and happens-before graph construction, For example, in
489T ABLE VI
RUNTIME OVERHEAD ON DA T ASET -1
IDNRace (s) NodeRacer (s) Speedup
TC HBC DP T HBC T HBC T
1 1.0 0.2 0.1 1.3 2.0 3,600.0 10 2,769
2 1.0 7.0 1.0 9.0 104.5 1,665.5 15 185
3 0.5 0.1 0.1 0.7 0.4 1,279.8 4 1,828
4 0.5 0.1 0.1 0.7 0.1 351.2 1 502
5 1.3 0.2 0.1 1.6 1.0 743.6 5 465
6 6.6 1.3 0.5 8.4 7.8 87.5 6 10
7 0.5 0.4 0.1 1.0 35.5 945.3 89 945
8 0.6 0.1 0.1 0.8 0.1 282.6 1 353
9 5.5 0.7 0.7 6.9 5.7 1,203.6 8 174
10 1.2 14.3 0.3 15.8 215.5 465.5 15 29
Total 18.7 24.4 3.1 46.2 372.6 10,624.6 15 230
T: Trace collection; B: Happens-before graph construction; DP: Race
detection and pruning; T: Total time.
project xlsx-extract, which consumes the most time on happen-
before graph construction, there are 675 events, 290 of which
are Immediate events. As discussed before, FIFO and NextTick
rules need to be applied to Immediate events. It takes much
time to repeatedly evaluate these two rules.
We compare the performance of NRace with NodeRacer on
dataset-1. In Table VI, columns 6-7 present the overhead ofNodeRacer, where column HBC and Tdenotes the overhead of
the happens-before graph construction algorithm and the totalruntime, respectively. Columns 8-9 show NRace‚Äôs speedupcompared with NodeRacer, where column HBC and Tdenotes
the speedup in happens-before graph construction and the totalruntime, respectively.
On the one hand, our proposed happens-before graph con-
struction algorithm performs much faster than the algorithm ofNodeRacer (from 1X to 89X). Since project node-mkdirp and
project del have a small number of events, there is little dif-
ference between the overhead of our proposed algorithm andNodeRacer‚Äôs algorithm in these two projects. Our proposedalgorithm is efÔ¨Åcient in happens-before graph construction forNode.js applications.
One the other hand, since NodeRacer repeatedly executes
the application, it has large overhead. As shown Table VI,it spends nearly three hours to detect 6 races. As shown incolumn 9, NRace performs much faster than NodeRacer (from10X to 2,769X). These results demonstrate that NRace is moreefÔ¨Åcient in detecting races in real-world Node.js applications.
E. Threats to V alidity
The threat to validity is the representativeness of experi-
mental projects. First, races selected in the evaluation come
from real-world Node.js applications and have been studied byprevious work NodeCB [10] and NodeRacer [21]. We believethese races represent real-world bugs. Second, since most ofour selected Node.js applications have an amount of stars, webelieve they are popular and representative.
V. R
ELA TED WORK
In this section, we discuss related works close to ours.
Event race detection. CAFA [8] and DroidRacer [18] build
happens-before relations among events, which account foronly one event queue. EventTrack [29] maintains a subset
of happens-before relations to optimize happens-before graphconstruction. SIERRA [19] reiÔ¨Åes threads, events and useractions as actions and statically builds happens-before relationsto improve precision. These existing approaches on Androidapplications cannot deal with multi-priority event queues.
WebRacer [7] formalizes the happens-before relations with
web features. EventRacer [13] proposes race coverage toreduce the number of false positives and takes advantage ofchain decomposition to decrease the overhead of reachabilityquery. W A VE [14] records a sequence of operations andcontrols the target program to execute the observed operationsto detect event races. ARROW [30] further statically detectsevent races and automatically repairs them. These approachesmainly focus on programming model features of browsers,such as DOM and AJAX. Therefore, they cannot be appliedon Node.js applications.
Concurrency bug detection on Node.js applications.
NodeCB [10] presents an empirical study on 57 concurrencybugs on real-world Node.js applications, and shows light onconcurrency bugs in Node.js applications. [31] proposes aparallel programming abstraction GEMs. [27] proposes AsyncGraph to reason about event behaviors. NodeA V [22] candetect atomicity violations and does not consider other kinds ofraces. Node.fz [11] and NodeRacer [21] fuzzes the executionorder of events to expose races. Due to randomness, theycannot deterministically Ô¨Ånd bugs. In contrast, our approachcan systematically explore all the scheduling space of eventsand asynchronous tasks.
VI. C
ONCLUSION
Node.js applications are increasingly popular and are widely
used by many developers and industrial giants. These ap-plications are written in an asynchronous event-driven ar-chitecture, and suffer from races. In this paper, we proposeNRace to detect races based on an observed execution trace.We build precise happens-before relations among events andasynchronous tasks in Node.js applications, which supportsmulti-priority event queues. We further develop a predictiverace detection technique based on happens-before relations.We evaluate NRace on real-world Node.js applications andexperimental results show it can detect known races as wellas unknown races.
VII. A
CKNOWLEDGE
We thank Y ushan Zhang and Y u Gao for providing insightful
comments about this work. This work was partially supportedby National Key R&D Program of China (2017YFB1001804),National Natural Science Foundation of China (61732019,62072444), Foundation of Science and Technology on Paral-lel and Distributed Processing Laboratory (61421102000402),Frontier Science Project of Chinese Academy of Sciences(QYZDJ-SSW-JSC036), and Y outh Innovation Promotion As-sociation at Chinese Academy of Sciences (2018142).
490REFERENCES
[1] The npm repository. [Online]. Available: https://www.npmjs.com/
[2] 64 Node.js stats that prove its awesomeness in 2021. [Online].
Available: https://hostingtribunal.com/blog/node-js-stats/
[3] Node.js at PayPal. [Online]. Available: https://www.paypal-engineering.
com/2013/11/22/node-js-at-paypal/
[4] Node.js at Uber. [Online]. Available: https://foundation.nodejs.org/
wp-content/uploads/sites/50/2017/09/Nodejs-at-Uber.pdf
[5] Node.js at Y ahoo. [Online]. Available: https://www.joyent.com/blog/
node-js-on-the-road-boston-node-js-at-yahoo
[6] Libuv. [Online]. Available: https://github.com/libuv/libuv[7] B. Petrov, M. T. V echev, M. Sridharan, and J. Dolby, ‚ÄúRace detection
for web applications,‚Äù in Proceedings of ACM SIGPLAN Conference on
Programming Language Design and Implementation (PLDI), 2012, pp.251‚Äì262.
[8] C. Hsiao, C. Pereira, J. Y u, G. Pokam, S. Narayanasamy, P . M. Chen,
Z. Kong, and J. Flinn, ‚ÄúRace detection for event-driven mobile applica-tions,‚Äù in Proceedings of ACM SIGPLAN Conference on Programming
Language Design and Implementation (PLDI), 2014, pp. 326‚Äì336.
[9] P . Bielik, V . Raychev, and M. T. V echev, ‚ÄúScalable race detection for
Android applications,‚Äù in Proceedings of ACM SIGPLAN International
Conference on Object-Oriented Programming, Systems, Languages, andApplications (OOPSLA), 2015, pp. 332‚Äì348.
[10] J. Wang, W . Dou, Y . Gao, C. Gao, F. Qin, K. Yin, and J. Wei,
‚ÄúA comprehensive study on real world concurrency bugs in Node.js,‚ÄùinProceedings of IEEE/ACM International Conference on Automated
Software Engineering (ASE), 2017, pp. 520‚Äì531.
[11] J. C. Davis, A. Thekumparampil, and D. Lee, ‚ÄúNode.fz: Fuzzing
the server-side event-driven architecture,‚Äù in Proceedings of European
Conference on Computer Systems (EuroSys), 2017, pp. 145‚Äì160.
[12] Y . Zheng, T. Bao, and X. Zhang, ‚ÄúStatically locating web application
bugs caused by asynchronous calls,‚Äù in Proceedings of the International
Conference on World Wide Web (WWW), 2011, pp. 805‚Äì814.
[13] V . Raychev, M. V echev, and M. Sridharan, ‚ÄúEffective race detection for
event-driven programs,‚Äù in Proceedings of ACM SIGPLAN International
Conference on Object-Oriented Programming, Systems, Languages, andApplications (OOPSLA), 2013, pp. 151‚Äì166.
[14] S. Hong, Y . Park, and M. Kim, ‚ÄúDetecting concurrency errors in
client-side JavaScript web applications,‚Äù in Proceedings of International
Conference on Software Testing, V alidation and V eriÔ¨Åcation (ICST),2014, pp. 61‚Äì70.
[15] E. Mutlu, S. Tasiran, and B. Livshits, ‚ÄúDetecting JavaScript races that
matter,‚Äù in Proceedings of Joint Meeting of European Software Engi-
neering Conference and ACM SIGSOFT Symposium on the F oundationsof Software Engineering (ESEC/FSE), 2015, pp. 381‚Äì392.
[16] C. Q. Adamsen, A. M√∏ller, and F. Tip, ‚ÄúPractical initialization race de-
tection for JavaScript web applications,‚Äù Proceedings of ACM SIGPLAN
International Conference on Object-Oriented Programming, Systems,Languages, and Applications (OOPSLA), vol. 1, pp. 66:1‚Äì66:22, 2017.
[17] C. Q. Adamsen, A. M√∏ller, S. Alimadadi, and F. Tip, ‚ÄúPractical
AJAX race detection for JavaScript web applications,‚Äù in Proceedingsof Joint Meeting of European Software Engineering Conference andACM SIGSOFT Symposium on the F oundations of Software Engineering(ESEC/FSE), 2018, pp. 38‚Äì48.
[18] P . Maiya, A. Kanade, and R. Majumdar, ‚ÄúRace detection for Android
applications,‚Äù in Proceedings of ACM SIGPLAN Conference on Pro-
gramming Language Design and Implementation (PLDI) , 2014, pp. 316‚Äì
325.
[19] Y . Hu and I. Neamtiu, ‚ÄúStatic detection of event-based races in Android
apps,‚Äù in Proceedings of International Conference on Architectural
Support for Programming Languages and Operating Systems (ASPLOS),2018, pp. 257‚Äì270.
[20] Y . Hu, I. Neamtiu, and A. Alavi, ‚ÄúAutomatically verifying and reproduc-
ing event-based races in Android apps,‚Äù in Proceedings of International
Symposium on Software Testing and Analysis (ISSTA), 2016, pp. 377‚Äì388.
[21] A. T. Endo and A. M√∏ller, ‚ÄúNodeRacer: Event race detection for Node.js
applications,‚Äù in Proceedings of International Conference on Software
Testing, V alidation and V eriÔ¨Åcation (ICST), 2020, pp. 120‚Äì130.
[22] X. Chang, W . Dou, Y . Gao, J. Wang, J. Wei, and T. Huang, ‚ÄúDetecting
atomicity violations for event-driven Node.js applications,‚Äù in Proceed-
ings of International Conference on Software Engineering (ICSE), 2019,
pp. 631‚Äì642.
[23] M. C. Loring, M. Marron, and D. Leijen, ‚ÄúSemantics of asynchronous
JavaScript,‚Äù in Proceedings of ACM SIGPLAN International Symposium
on on Dynamic Languages (DLS), 2017, pp. 51‚Äì62.
[24] Promise. [Online]. Available: https://developer.mozilla.org/en-US/docs/
Web/JavaScript/Reference/Global
Objects/Promise
[25] Node.js documentation about async hooks. [Online]. Available:
https://nodejs.org/api/async hooks.html
[26] K. Sen, S. Kalasapur, T. Brutch, and S. Gibbs, ‚ÄúJalangi: A selec-
tive record-replay and dynamic analysis framework for JavaScript,‚ÄùinProceedings of Joint Meeting of European Software Engineering
Conference and ACM SIGSOFT Symposium on the F oundations ofSoftware Engineering (ESEC/FSE), 2013, pp. 488‚Äì498.
[27] H. Sun, D. Bonetta, F. Schiavio, and W . Binder, ‚ÄúReasoning about the
Node.js event loop using async graphs,‚Äù in Proceedings of International
Symposium on Code Generation and Optimization (CGO), 2019, pp.61‚Äì72.
[28] Cloc: Count lines of code. [Online]. Available: https://github.com/
AlDanial/cloc
[29] P . Maiya and A. Kanade, ‚ÄúEfÔ¨Åcient computation of happens-before
relation for event-driven programs,‚Äù in Proceedings of ACM SIGSOFT
International Symposium on Software Testing and Analysis (ISSTA),2017, pp. 102‚Äì112.
[30] W . Wang, Y . Zheng, P . Liu, L. Xu, X. Zhang, and P . Eugster, ‚ÄúARROW:
Automated repair of races on client-side web pages,‚Äù in Proceedings
of International Symposium on Software Testing and Analysis (ISSTA),2016, pp. 201‚Äì212.
[31] D. Bonetta, L. Salucci, S. Marr, and W . Binder, ‚ÄúGems: Shared-memory
parallel programming for Node.js,‚Äù in Proceedings of ACM SIGPLAN
International Conference on Object-Oriented Programming, Systems,Languages, and Applications (OOPSLA), 2016, pp. 531‚Äì547.
491