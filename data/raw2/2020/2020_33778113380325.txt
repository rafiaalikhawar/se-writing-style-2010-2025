Securing UnSafe Rust Programs with XRust
PeimingLiu
peiming@tamu.edu
Texas A&M University
CollegeStation,Texas, U.S.AGang Zhao
zhaogang92@tamu.edu
Texas A&M University
CollegeStation,Texas, U.S.AJeff Huang
jeff@cse.tamu.edu
Texas A&M University
CollegeStation,Texas, U.S.A
ABSTRACT
Rust is a promising systems programming language that embraces
bothhigh-levelmemorysafetyandlow-levelresourcemanipulation.
However, the dark side of Rust, unsafe Rust, leaves a large security
hole as it bypasses the Rust type system in order to support low-
leveloperations.Recently,severalreal-worldmemorycorruption
vulnerabilitieshave been discovered in Rust‚Äôs standard libraries.
Wepresent XRust,anewtechniquethatmitigatesthesecurity
threat of unsafe Rust by ensuring the integrity of data flow from
unsafe Rust code to safe Rust code. The cornerstone of XRustis
a novel heap allocator that isolates the memory of unsafe Rust
fromthataccessedonlyinsafeRust,andpreventsanycross-region
memory corruption. Our design of XRustsupports both single-
and multi-threaded Rust programs. Our extensive experiments on
real-worldRustapplicationsandstandardlibrariesshowthat XRust
is both highly efficient and effective in practice.
1 INTRODUCTION
Long-existing system programming languages such as C/C++ offer
programmers the ability to manipulate low-level resources but
inerror-proneways.Countlessseverebugshavebeenfounddue
to the unsafe nature of these languages [ 8,17,32]. Rust [23]i sa
risinglanguagethattriestobridgethegapbetweenmemorysafety
andlow-levelsystemprogramming.Withnewlanguagefeatures
such as ownership, borrowing, and lifetime, Rust guarantees a
program to be memory safe if it could be compiled (at the absence
ofunsafeRust).ThetypesystemofRustanditsencapsulationon
low-level operations have been formally proved to ensure memory
safety[22,33].
However,thestaticrestrictionsofRustcanbetoostricttoadmit
many valid programs due to reasons including (1) by nature, static
analysis is conservative and (2) the underlying computer hardware
is inherently unsafe and certain operations could not be done with
safe Rust [ 10]. This problem is addressed by unsafe Rust, which
escapes from the static checks [ 36]. With unsafe Rust, program-
mers are able to manipulate raw pointers, perform unprotected
type casting and other dangerous operations just like in C/C++.
Therefore, a Rustprogram is free of memory errors only when its
unsafe code is correctly implemented and does not violate mem-
orysafetyproperties[ 22].However,requiringalltheunsafeRust
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACM
mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ICSE‚Äô20,May23‚Äì29,2020,Seoul, Republic of Korea
¬©2020Association for Computing Machinery.
ACM ISBN 978-1-4503-7121-6/20/05...$15.00
https://doi.org/10.1145/3377811.3380325Table1:UnsafeRustcodeinpractice(Rust-langcontainsthe
code for Rust compiler and all the Rust standard libraries).
LoC LoC(unsafe) unsafe%
collected crates 2,480,761 18,490 0.75%
Rust-lang 327,792 3,163 0.96%
codetobecorrectlyimplementedisdifficult.BugsinunsafeRust
codemayresultinseverevulnerabilities,aswitnessedbyseveral
memoryerrorsdiscoveredrecently[ 5,37,38].Whatisworseisthat
amemoryerrorinunsafeRustmaycorruptarbitrarydatainthe
whole address space, i.e.,bugs in unsafe Rust can be exploited to
hijackfunctionpointers or steal sensitive data in safe Rust.
To understand how the unsafe portion of Rust is used in real-
world applications, we randomly selected 500 crates from crates.io
and counted the number of lines of unsafe code (shown in Table 1).
Theresultindicatesthatmostreal-worldRustprogramsonlyrely
onaverysmallfractionofunsafecode( <1%)onaverage.Although
in practice most memory objects in Rust are statically protected
by Rust‚Äôs type system, a bug residing in unsafe Rust code could
simply ruin the entire effort and put the whole program at the risk
of being attacked!
In this paper, we present XRust, a novel approach to mitigate
the security threat brought by unsafe Rust while imposing min-imal overhead to Rust programs. While there exist several prior
attempts[ 7,21,28‚Äì30]onC/C++toretrofitfullmemorysafetyof
the language (which is often expensive), our goal is not to bring
memorysafetytounsafeRust,buttoensuretheintegrityofdata
insafeRust(atthepresenceofmemoryerrorsinunsafeRustcode).
InXRust, the heap is logically divided into two mutually exclusive
regions:anunsaferegionandasaferegion.Memoryobjectscreated
and/or accessed by unsafe Rust (referred to as unsafe objects)a r e
placed in the unsafe region and can be corrupted. All other safe
objectsare stored in the safe region and can never be corrupted.
The separation between safe and unsafe objects can be enforced
by in-process memory isolation techniques [ 9,48]. In this work,
weexploretwomethodsusinginstrumentationandmemoryguard
pagesto achieve in-process isolation.
As depicted in Figure 1, XRustworks as follows:
(1)Intheoriginalcode,thetwoobjects bufandpassword are
treated equally and are placed in the same heap region. A
heap-based attack exploiting a memory corruption of buf
inunsafeRustcodecancausearbitrarywritetothewhole
address space, including corrupting password;
(2)In the XRust-protected code, bufis placed in the unsafe
region separated from password , because bufis used in
unsafeRust.Whenusinginstrumentation,runtimechecks
are inserted to prevent cross-region data flows from the
*&&&"$.OE*OUFSOBUJPOBM$POGFSFODFPO4PGUXBSF&OHJOFFSJOH	*$4&
1pub fnmain() {
2 letbuf =Vec::new_in_unsafe();
3 letpassword = String::new();
4
5 unsafe{
6// offset is out of bound
7 letptr= buf.as_ptr().offset(NUM);
8 if(!in_unsafe_region(ptr))
9 raise error;
10 letv=*ptr;
11}
12}Address SpaceOriginal Program Protected Program
Heap
Stack
Globalbuf
password
Address Space
Heap
Stack
Globalunsafe region
safe regionbuf
password
(a) (b)


Identify objects that 
are processedby unsafe Rust codeAcquire heap memory in a separate regionRuntime checks to prevent cross-region memory references1pub fnmain() {
2 letbuf =Vec::new_in_unsafe();
3 letpassword = String::new();
4
5 unsafe{
6// offset is out of bound
7 letptr= buf.as_ptr().offset(NUM);
8// out-of-bound read
9 letv=*ptr;
10}
11}
Instrument onunsafe objects
Figure 1: A technical overview of XRust(usinginstrumentation-based memory isolation).
unsaferegiontothesaferegion.Whenusingguardpages,
isolationis enforced by placing inaccessible memory pages
between the two regions.
We note that XRustdoes not attempt to guarantee full memory
safetyofunsafeRust,butthesafetyofmemoryobjectsinsafeRust.
The main goal of XRustis to provide effective protection while
imposing negligible overhead. Also, XRustonly targets memory
corruption on heap objects. Stack protection techniques such as
stackcanaries[ 14]andSafeStack[ 24]havebeendeployedwidely
inrealsystems.Proposals[ 20,35]tosupportSafeStackinRusthave
alsobeen implemented.
Toourknowledge, XRustisthefirstattempttoisolatetheside
effectofunsafeRustautomaticallyanditachievesbotheffectiveness
and efficiency by leveraging unique language features of Rust. The
designofanewtypeofmulti-regionheapallocatorisseamlessly
incorporated into the Rust framework while achieving backwards
compatibility. To support a separate memory region in XRustis
also challengingandwemade extensivemodifications inthe Rust
compiler ranging from high-level language features to the low-
levelheapallocator.Insummary,wehighlightourcontributionsas
follows:
‚Ä¢XRustisthefirstapproachtoautomaticallyprotectsafeRust
from memory corruption errors in unsafe Rust. A recent
work, Fidelius Charm [ 2], shares a similar goal but it re-
quires programmers to mark and restore unsafe data before
and after unsafe code blocks at memory page level. Moreimportantly, FC is limited usability when handling shared
unsafeobjectsinsafeRustcodeasdiscussedinSection5.1.1.
‚Ä¢We design and implement a novel heap allocator that sup-
portssafeandunsafememoryregions,andefficientlychecks
cross-regionreferencesusinginstrumentationorguardpages.
‚Ä¢Weevaluate XRustextensivelyonreal-worldRustapplica-
tionsandmemoryerrors.Ourresultshowsthat XRustincurs0.15%medianoverheadontestedcrates(2.8%onRuststan-
dard libraries) and it effectively defends against attacks that
exploit known real-world memory vulnerabilities in Rust.
2 OVERVIEW
In this section, we first discuss the rationale behind the design
ofXRust. We then illustrate how XRustworks on a motivating
example based on a real vulnerability in Rust.
2.1 Why XRust?
The clear separation between safe and unsafe Rust naturally di-
videsobjects intotwo mutuallyexclusive sets:The setsof safeand
unsafeobjects,basedonwhethertheyareusedinunsafeRust.At
a high-level view, since only unsafe objects are under the risk of
being corrupted in Rust programs, the isolation enabled by XRust
between memory regions used by safe and unsafe objects ensures
that potential memory corruptions can only impact the unsafe
region and can never cross the boundary to corrupt safe objects.
In this subsection, we first discuss how unsafe Rust is used in
practice, and then discuss the protection strength of XRustwith
respect to both spatialandtemporal memory safety.
2.1.1 Unsafe Rust in practice. We studied several popular open-
sourceRustprojectsaswellastheRuststandardlibrarytounder-
standtheusageof unsafe Rust in the real world.
Assummarized inTable 1,Rust programs onlycontain lessthan
1%unsafecode on average,and unsafeRust istypically usedonly
forlow-leveloperationsandoptimizations.Thestatisticsprovide
strong evidence thatmost objects are only processedby safe Rust
and by isolating the side-effect of unsafe Rust, XRustis able to
protect all of them. Apart from this, we also conducted in-depth
inspectionsofthesourcecodeontheusageofunsafeRust(relatedto
memory safety).Wesummarize ourfindings into threecategories:
Unbounded MemoryAccesses. Insteadofusingobjectrefer-
ences,programmerssometimesuserawpointersandunchecked
pointer arithmetic to access a piece of consecutive memory. E.g.,
inbase64, instead of using a vector, the developers access the
encoding buffer directly through a raw pointer and iterate overthe memory by adding offsets to the pointer. This pattern is nor-
mallyusedtoaccessaninternalbufferandtoskipdefaultbound
checkings(in image,base64,vec, etc)
UncheckedConversions. Thisincludesboth typeconversion
as well as data format conversion (e.g., utf-8 toutf-16). This is
mainly used for developing low-level functionalities such as decod-
ing/encodingbinarydataandserializationasin string,byteorder ,
bytes, etc.
InternalStatesOverride. When using well-encapsulated safe
APIsfromRustlibraries,theinternalstatesofanobjectisnormally
maintained internally by Rust (e.g., , pushing an element into a
vector increases the size of the vector). However, when developers
access an object in unexpected ways, the internal states need to
bemanuallyadjusted. E.g.,afterinitializingthebufferofavector
using raw pointers, the size of the vector needs to be overridden
accordingly. The operation is unsafe as programmers are responsi-
ble to provide the correct value and unmatched internal states may
lead to undefined behaviors. This is typically used for the purpose
of low-level optimizations as in vecdeque, vec, etc.
2.1.2 Observations behind XRust. Basedontheempiricalstudies
above, we make two observations:
Observation#1: BeingawarethattheunsafeRustcodeisnot
checked by the compiler, Rust programmers tend to avoid heavy
usageofunsafeRustinpracticeandonlyrelyonunsafefeatures
to perform necessary low-level operations [ 41]. This indicates that
in reality, it is likely that most objects in a Rust application aresafe objects, and critical data such as
password (with high-level
semantics)is unlikely to be processed in unsafe Rust.
Apartfromthis,wemakethesecondobservationbasedonRust‚Äôs
object memory model that indicates how indirect calls, which is
essentialto control flow integrity, is handled by Rust.
Observation#2: UnlikeC++whichstoresthe virtualfunctionta-
ble(vtable) pointers of an object adjacent to its data members [ 26],
Rust stores them separately. Internally, Rust achieves polymor-
phism and dynamic dispatching by transforming objects into trait
objects[34]. As illustrated in Figure 2, the reference to a trait ob-
ject is afat pointer consisting of two pointers: one points to the
data members of the object and the other points to the vtable. This
implicitly puts theheap data and vtable pointers into two regions.
Forunsafeobjects,onlyitsdatamembersareallocatedintheun-
safe heap region. Thus, overflow to corrupt vtable pointers is a
cross-region reference and will be prevented by XRust.
2.1.3 Protection Strength of XRust. The two observations above
leadto the following properties of XRust:
Spatial Memory Safety The observations imply that by pre-
ventingcross-regionreferences, XRustcanefficientlydefendRust
programs against:
(1)Non-control data attacks in unsafe Rust code that corrupt
objectsoutsidetheunsaferegion;data *
vptr *
fngetX()-> int
fngetY()-> int
‚Ä¶structPoint{
intx;
inty;
}ptr *
intgetX()
intgetY()
‚Ä¶structPoint{
intx;
inty;
}
vptr *
C++ Rust
Figure 2: Memory layout of objects in C++ vs Rust.
(2)Control-oriented attacks in unsafe Rust code that corrupt
the vtable pointer of a trait object or raw function point-
ersoutsidetheunsaferegion, e.g.,tohijackcontrolflowto
maliciouscode.
These protections are valuable in practice because (1) there is
a high chance that most sensitive data in Rust user applicationsare safe objects (observation #1), and (2) vtable pointers of trait
objects are the major source of indirect jumps in Rust and they are
protected by XRust(observation #2).
Temporal Memory Safety .XRustis able to prevent temporal
memoryerrorsfromcorruptingsafeobjectsaswell.InRust,tempo-ralerrorscanonlyhappenonunsafeobjectsbecausesafeRustcode
staticallyeliminatesalltemporalerrorsbyanalyzingthe lifetimeof
referencesandthe ownerships ofobjects.So,whenatemporalerror
(e.g.,useafterfree)occurs,thepointerusedtoaccessmemorymust
point to an unsafe object. Since our multi-region allocator will not
reuse memory previously used for unsafe objects to allocate any
safe object (Section 4.2), the freed memory of an unsafe object will
only be used to hold another unsafe object. When temporal errors
occur, memory accesses on the freed pointer will still be within
unsafeheap regionsothat thetemporalerrors cannotescape the
unsaferegion to corrupt safe objects.
2.2 A Motivating Example
Listing 1 shows a code fragment simplified from the rust-base64
library. For versions before 0.5.1, the library contains an integer
overflow bug that eventually leads to a heap buffer overflow. On
line 4, the vulnerable function first tries to reserve a buffer on
theheapandthesizeofthebufferiscalculatedbythevulnerable
functionencoded_size thatcontainsa integeroverflow error.1A
heap overflow can happen when the integer overflow leads to a
smallerbuffer andthis vulnerabilitycan beexploitedto overwrite
datainsafeRust.ForRustapplicationsdependingonthislibrary,
the unsafe code may only account for a small fraction of the entire
code.However,thisbugcanstillresultinmemorycorruptionsin
theentire address space.
XRustsignificantly mitigates this vulnerability. It first identifies
bufas an unsafe object because it is used in unsafe Rust (line 9),
by analyzing the data flow from the safe Rust to unsafe Rust. Then
instead of reserving heap memory for the objects normally (line 4),
itreservesthememoryfor bufintheunsaferegion,byrewriting
1Note that Rust does check integer overflows for the debugging build by default, but
notin the optimized release build.
1pub fnencode_config_buf<T>(buf: &T, ..) {
2// reserve a large enough buffer to
3// store the encoded string
4buf.reserve(encoded_size(len));
5// using unsafe operation to store encoded
6// string to buffer
7 unsafe{
8// buf object is used in unsafe code!
9 let mut output_ptr = buf.as_mut_ptr();
10 whilecondition {
11 // do pointer arithmetic and accessing
12 // memory directly
13 ptr::write(output_ptr.offset(..), ...);
14 ...
15}
16}
17}
Listing 1: A real buffer overflow in rust-base64 due to
unsafeRustcode (CVE-2017-1000430).
thefunctiontocallanextendedAPI.Finally,accessesto buf,which
is anunsafe object,are restrictedto bewithin theunsafe memory
region.Whenusinginstrumentation,thememoryreferenceonline
13 will be instrumented as follows:
1letptr= output_ptr.offset(..);
2if(!in_unsafe_region(ptr))
3raise error;
4
5write(ptr, ...);
Atruntime,attemptstoaccessaddressesoutsidetheunsafeheap
region are detected by XRust, thus the vulnerability cannot be
exploited to perform attacks on safe objects.
Weobservethat,evenwithinstrumentationwhichoftenimposes
high overhead for other languages such as C/C++ by other tech-
niques, XRustisstillfast(3 .6%overheadonmedian).Thisisbecause
XRustonly checks memory references on unsafe objects, which
avoidsheavyinstrumentationtopropagatethemetainformation
asrequiredbytechniquessuchasSoftBound[ 28],anditavoidsthe
expensive whole-program reaching definition analysis as required
byDFI[7]todeterminevaliddataflows.Moreover, XRustchecks
only cross-region data flow (rather than object bounds), which can
be achieved in constant time with the help of our allocator (Sec-
tion4.2.1).Inourdesign,wealsoleverageguardpagestoprotect
cross-regionreferences(Section5.2),whichisevenmoreefficient
thanusinginstrumentation.
Figure 3 shows the technical design of XRust, which consists
of three key components: 1) extensions made to Rust and the Rust
compiler to provide high-level APIs for allocating objects in the
unsaferegions;2)anewheapallocatorthatsupportsanunsafeheap
region;and3)runtimeprotectionstopreventcross-regionmemory
references.Inthenextthreesections,wepresentthedetailsofeach
component.&&YUFOEFE-BOHVBHF"1*T
ƒÖƒÖƒÜƒëƒëƒîƒàƒÖƒéƒìƒÖƒöƒìƒòƒÜƒãƒä√é√èƒÖƒÖƒÜƒëƒëƒîƒàƒÖƒéƒìƒÖƒòƒÜƒãƒä√é√è
‡æüJOTUSVNFOUBUJPO.VMUJ3FHJPO)FBQ"MMPDBUPS
RU
‡Ω∑HVBSEQBHFT
3VOUJNF1SPUFDUJPOT4BGF
3FHJPO
6OTBGF3FHJPO
NBJOST&URVV5HJLRQ5HIHUHQFH
·íê
J
Figure 3: Three key components of XRust.
3 LANGUAGE EXTENSIONS
In this section, we first introduce necessary background on how
Rustencapsulatesitsheapallocationinterfacesandthenpresent
ourextensions.
3.1 Heap Allocation in Rust
Insteadofallowingprogrammerstoacquireandreleaseheapmem-
ory directly through mallocandfree, Rust provides high-level
abstractionsonheapmemorythroughencapsulationonheapop-
erations.Thereleaseofaheapobjectisautomaticallyinsertedby
Rustcompilerandprogrammersarenotallowedtofreethememory
manually to avoid errors like double frees. It also gives Rust the
flexibilityofchangingtheallocatorglobally(evenforpre-compiled
libraries) without recompiling the code by defining a global alloca-
tor2[15]. These encapsulations and the loose connection between
the language and the allocator implementation require extra ab-
stractionlayers between these two components.
There are two ways to acquire a piece of heap memory in Rust3.
Inmostcases,thiscanbeachievedbycreatinga Box<T>object.For
low-levellibrarydevelopers,itcouldbedonebydirectlyinteracting
withtheAlloctrait(traitissimilartoJava‚Äôs interface).The Box<T>
objects are wrapped pointers that can only point to heap objects
andareinternallycreatedusing boxexpressions4.Forexample,the
expression box 42allocatesfour-byteheapmemorythatstoresa
32bitintegerofvalue42,anditreturnsa Box<i32> objectpointing
totheallocatedheapobjectastheresult.Those Box<T>objectswill
be dropped later by the compiler-inserted code when their owners
gooutthescope, i.e.,theownerfunctionreturnsortheownerblock
terminates. In Rust‚Äôs standard libraries, neither boxexpressions
northedefaultimplementationofthe Alloctraitisboundedtoa
specific allocator. They both rely on the Rust compiler to generate
gluecodetobindtheprogramtoaspecificallocatorduringcode
generationphase.
Forheap allocationthroughthe Alloctrait,the defaultimple-
mentation delegates all its tasks to a set of functions with the
__rustprefix. Specifically, __rust_alloc() for heap allocation,
__rust_dealloc() for heap deallocation, and __rust_realloc()
2Thefeatureofswitchingallocatorsgloballyisnotinastablestateyet.Thedescription
in this paper is based on the latest Rust (version 1.32) by the time of writing.
3Callingmalloc-likefunctionthroughFFIis out of the scope.
4box expression is an unstable feature as well.
fnmain() {
letb: Box<i32> = box42;
} fnmain() {
letb= exchange_malloc(4);
*b= 42;
}
#[lang = "exchange_malloc"]
unsafe fn exchange_malloc(size) {
return__rust_alloc(size);
}link to lang item
__rdl_alloc
__rde_alloc
__rg_allocptmalloc2
jemalloc
global 
allocatorgenerated
codeOriginal codeCompiler-expanded code
Figure 4: Rust workflow for linking heap allocations.
forheapreallocation,etc.Thesefunctionsdonothaveactualimple-
mentations, but are treated as special internal symbols by the Rust
compilerandimplementedbycompilergeneratedcodetoinvoke
different allocators, e.g.,the allocator for static libraries and for
executable binaries.
For heap allocation through boxexpressions, it requires two
langitems:‚Äú exchange_malloc ‚Äùforallocationand‚Äú box_free ‚Äùfor
deallocation. Lang items [ 45] are pluggable features in Rust whose
functionalities are not hard-coded into the language but are im-
plemented in libraries, using a special marker ( #[lang = "..."] )
to indicate their existence. Figure 4 illustrates the workflow. At
compile time, for each boxexpression, the Rustcompiler searches
allthedependentlibrariestofindfunctionsmarkedbythesetwo
langitems.Thecompilerthengeneratescodebycallingthefunc-
tion marked as exchange_malloc to allocate heap memory, and
inserts calls to the function marked as box_free to dropBox<T>
objects. In Rust‚Äôs standard libraries, the default implementation of
exchange_malloc delegatesheapallocationto __rust_alloc().
3.2 Language Support for Unsafe Region
Tosupportadifferentheapregion,weaddcorresponding‚Äú unsafe‚Äù
interfaces for each of the allocation functions. For example, we
add__rust_unsafe_alloc astheentrypointforallocatingheap
memory in the unsafe region. The compiler is also extended to
generate code to invoke these extended functions for handling the
unsafeheapregion.
We then build high-level APIs for the extended interfaces by
extending Rust‚Äôs standard library. Additional methods are added
to theAllocandGlobalAlloc traits to deal with the unsafe heap
region. For example, the function unsafe_alloc() is added to the
Alloctraittoprovideinterfacesforallocatingmemoryintheunsafe
region.Basedonthis,high-levelclassesinthestandardlibrariescan
beextendedaswell.Forexample, Vec::unsafe_with_capacity()
isaddedtothe Vecstructuretocreateavectorthatputstheinternal
memorybufferintheunsafeheapregion,whichallowsprogrammer
to interact with unsafe allocation interfaces on their own demands.
The newly added interfaces are backward compatible with exist-
ing Rust programs. By default, calls to the extended interfaces (e.g.,
unsafe_alloc() ) are delegated to the pre-existing functions (e.g.,
alloc()).Thecompiler-generatedcodealsodelegatestherequests
from__rust_unsafe_alloc to the standard API if the underlying
allocator does not support a separate unsafe region. In this way,allexistingRustprogramscanbecompiledwithoutmodification.
Whenprogrammersusetheextendedinterfacesbutwithanallo-
cator that does not support the unsafe region, the allocation can
stillbe completed, but the allocated heap chunks will not be placed
in a separate unsafe heap region. The default implementation is
thenoverriddenbyourextendedallocatorandlinkedproperlyby
the compiler. Invocations on them are passed to the proper API to
allocateandfree heap memory in the unsafe region.
Forboxexpressions, we add a new operator unsafe_box to
create aBoxobject in the unsafe heap region. The grammar of
unsafe_box expressions is identical to boxexpressions, and the
result of unsafe_box expressions has the same type ( Box<T>)a s
the result of boxexpressions. Generating the same type ensures
that theunsafe_box operator can fit into the existing Rust type
system.Theonlydifferencebetween Boxobjectscreatedby boxand
unsafe_box expressionsisthatinternallytheyareputintodiffer-
entheapregions,butallotheroperations(dereference,typecasting,
pattern matching, etc.) are identical. Similarly, unsafe_box will be
linked to a new lang item unsafe_exchange_malloc at compile
time, which handles the allocation of unsafe objects.
4 MULTI-REGION HEAP ALLOCATOR
Our allocator implementation is based on ptmalloc2 [18] and
supports multi-threading. We first introduce the architecture of
ptmalloc2 andthenpresent our extensions.
4.1 Architecture of ptmalloc2
ptmalloc2 wasforkedfrom dlmalloc [25]andlatermergedinto
glibcwiththreadingsupport. ptmalloc2 maintainsseparateheap
segments and freelist data structures using multiple per-thread are-
nas, such that threads can rely on different arenas to perform heap
allocation/deallocationsimultaneouslywithoutsynchronization.
Inptmalloc2 , each arena can manage a list of heap segments
(exceptforthemainarena,whichonlyhasoneheapsegment).A
heap segment is a large piece of mmapped memory from where
freechunksareretrievedandreturnedtousers.Arenasalsokeep
thefreelistdatastructuresoftheirheapsegments( i.e.,bins)usedto
holdfreechunks.Binsaredividedintofourdifferenttypesbased
on chunk sizes: fast,unsorted, small, and large, and each is handled
differently. To handle a heap allocation, ptmalloc2 chooses the
appropriatebinsbasedontherequestedsize.Moredetailscanbe
foundin [42].
4.2 XRustExtensions on ptmalloc2
Inourdesigntoextend ptmalloc2 forhandlingheap(de)allocation
intheunsaferegion,wefollowedmostofitscurrentdesign.The
interactions with the unsafe heap region are achieved through ex-
tendedAPIssuchas unsafe_malloc() .TheseAPIsaremergedinto
Rust and linked with extended language APIs. The data structures
usedbytheunsaferegionarelazilyinitializeduponthefirstrequest
forallocatingmemoryintheunsaferegion.Forapplicationsthat
do not use the unsafe region, the extended allocator acts the same
as unmodified ptmalloc2 andno overhead is imposed.
4.2.1 Unsafe Region in Heap. Inourheapallocator,thesetof arenas
for handling allocations in unsafe region and those for allocations
in safe region are disjoint, i.e.,the unsafe arenas will not be reused
forallocatingobjectsinsaferegionand viceversa.Thisensuresthat
foreveryinternalheapsegmentmanagedbytheallocator,itonly
contains the objects in the same region so that overflow originated
from unsafe objects will not corrupt safe objects.
Weextendthearchitectureof ptmalloc2 toenablefastchecks
oncross-regionerrors.Intuitively,cross-regionreferencescanbe
checked by determining whether the pointer is within the range
of any unsafe heap segment. This could lead to huge runtime over-
head since the number of unsafe heap segments is unbounded
(especiallyformulti-threadprograms).Toaddresstheissue,weuse
a pre-allocated bitmap to record the type of heap segments (safe
orunsafe), which can be quickly indexed by the start addresses of
heap segments. This introduces negligible memory overhead since
theheapsegmentsin ptmalloc2 is1megabytesalignedbydefault,
thusthememoryoverheadis1bit permegabyte.Thebitmapispro-
tected by PROT_READ and can only be accessed inside the allocator
upon the creation of an unsafe heap segment. Under this design,
checking an memory reference takes only constant time regardless
how many unsafe heap segments have been allocated.
4.2.2 Multi-thread Support. Tomaximizetheperformanceofmulti-
threadprograms,weadoptthe per-threadarena mechanismtoallow
accessing the free lists for unsafe heap region concurrently. For
multi-threadprograms,threadsareassignedwithdifferentarenas
to allocate heap memory. Since every arena manages a disjoint
setofheapsegments,theycanbeaccessedconcurrentlywithout
synchronization.
Our design of the multi-region heap allocator also renders time-
of-check-to-time-of-use (TOCTTOU) attacks almost impossible. To
trigger such an attack, an unsafe pointer needs to be verified to
be within unsafe region first (time of check) and later be used to
corrupt a safe object (time of use) because the unsafe object is
first freed and the same address is reused for a safe object by other
threadsbeforethetimeofuse .However, sinceunsafeheapsegments
are maintained separately by different arenas in our allocator, a
freed unsafe chunk will only be reused to hold another unsafe
object, which makes the attack difficult. Besides, Rust prohibits
programmer from calling dropmanually to deallocate objects to
avoid errors, which makes it even harder to launch the attack.
4.2.3 Cross-Region References inside Allocator. To fully prevent
cross-region memory references, the allocator need to be free of
cross-region errors as well. For example, memory errors can be ex-
ploitedtocorruptthemetadataofheapchunksbecause ptmalloc2
stores the metadata adjacent to user data [3].
To address this problem, we insert runtime checks to ensure
thattheunsaferegioninsidetheallocatorwouldneverbeableto
referencedataoutsidetheregion.Forexample,thefreechunksin
theunsaferegionwouldonlybelinkedtootherfreechunkswithin
theunsaferegion.Whenevertheallocatorattemptstoaccessthe
metadataofchunksintheunsaferegion,checksareaddedtoensure
that the allocator can never perform cross-region references based
on corrupted data.
5 CROSS-REGION REFERENCE PREVENTION
Cross-regionmemoryreferencescanbepreventedbyin-process
memory isolation techniques, which have already been widelystudied. It has been shown that isolation can be enforced with neg-
ligible overhead through hardware-based protection, e.g.,by using
IntelMPK[ 48]orARMmemorydomain[ 9,16].Inourprototype
implementation,weexploredtwoschemestodetectcross-region
references. The first one is to instrument memory references on
unsafe objects; the second is to utilize memory protection pages
(i.e.,guard pages) to detect overflows
We explain how cross-region references are prevented by in-
strumentation as well as by memory guard page in Section 5.1 and
Section 5.2, respectively.
5.1 Code Instrumentation
We first perform an inter-procedural data flow analysis to identify
the allocation sites of unsafe objects in Rust programs, based on a
recent data flow framework [ 31]. Any allocated object that is later
accessed by unsafe code is considered as an unsafe object. Every
allocation site is a taint source, and every unsafe instruction is a
taintsink.Werecordeveryobjectthatflowsfromasourcetoasink.
Based on the results, we rewrite the program to allocate objects in
theunsafe memory region.
5.1.1 Shared Unsafe Objects in Safe Rust. Wealsorevealedacru-
cial technical caveat during the process of developing XRust:T o
completely isolate the side effect of unsafe Rust code, the instru-
mentationshouldbeappliednotonlyonunsafeRustcodebut all
unsafeobjects,which meansthatnotonly thedatadirectlytouched
by unsafe code, but also everything transitively reachable from
suchdataneed to be instrumented.
Consider the following code that creates a vector of length 3 on
line1andcallsanunsafefunction set_len() online3tosetthe
lengthof the vector to 10 manually (without resizing the buffer).
1letv=vec![1,2,3];
2unsafe{
3v.set_len(10);
4}
5letelem = v[9];
Thememoryreferenceonline5isanout-of-boundreadbecause
thevectorhasonlyallocatedthememoryspaceforstoringthree
integers. The code above passes the Rust compiler because the
vectorlengthischangedbyunsafecode.Moreover,noexception
willbethrownatruntimebytheassertioninsertedforthememory
reference on line 5, which only checks if the vector index is less
thanthevector length.
ThisisanexampleofhowunsafeRustcanbeusedtooverridethe
internal states of an object, and it can lead to a memory corruption
outsideunsafeRust(but onunsafeobjects). Therefore,to providecompleteprotection,allmemoryreferencesonunsafeobjects(in-
side or outside unsafe Rust) need to be checked. In fact, one of the
real vulnerabilities in Rust ( VecDeque , see Section 6.4.1) belongs
tothiscategory.Thisalsoindicatesthatoneoftherelatedworks,
FC [2], fails to provide a complete isolation from unsafe Rust code
as it only protects unsafe Rust code.
Forinstrumentation,weapplyacontext-insensitivepointeranal-
ysis(usingSVF[ 43]) to identifymemory references on unsafe ob-
jects.Sincestaticpointeranalysisisconservative,thepoints-toset
ofapointercancontainsbothsafeandunsafeobjects.Toaddress
1let mut ptr;
2if(condition) {
3ptr= __rust_alloc();
4shadow[ptr] = SAFE;
5}else{
6ptr= __rust_unsafe_alloc();
7shadow[ptr] = UNSAFE;
8}
9if(shadow[ptr] == UNSAFE) {
10 if(!in_unsafe_region(ptr))
11raise error;
12}
13letv=*ptr;
Listing 2: An example for distinguishing between safe
andunsafeobjects.
this issue, we use shadow memory to mark the types of pointers
and only perform checks on pointers of unsafe objects at runtime.
TaketheprograminListing2asanexample,thepoints-tosetof
ptrcontainsbothsafeandunsafeobjects.Tocheckonlyreferences
onunsafeobjects,ashadowmemoryisallocatedandindexedby
thepointer‚Äôsaddress.ThismethodisinspiredbySoftBound[ 28],
but instead of storing bound information of a pointer in shadow
memory, we only use 1 bit to store whether a pointer points to
an unsafe object at runtime. More detail on how the metadata is
propagatedandpassedintofunctioncanfoundintheSoftBound
paper [28]. Compared to SoftBound, this has much lower space
overhead: As heap objects managed by ptmalloc2 are 16 bytes
aligned, XRustimposesatmost1bitoverheadfor16bytesmemory,
thus the memory overhead is <1%. The protection on shadow
memory can be done by using approaches discussed in CPI [ 24]
withnegligibleoverhead.
5.2 Guard Page
A more efficient approach can be implemented by imposing two
guard pages below and above each heap segment. Since the guard
papecannotbeaccessed,cross-regionreferencescanbedetected
when it touch the guard page. To bypass this protection, cross-
region references must stride across an entire guard page to avoid
being detected.
Thisapproachis often more efficient than code instrumentation,
though in theory guard page is incomplete (e.g., a direct long jump
from the unsafe region to the safe region without touching the
guardpage).TherearereportsonhowtheLinux‚Äôsstackguardpagecanbebypassedtolaunchattacks[
13],anditcouldbemitigatedby
enlarging the size of guard pages [ 12]. Nevertheless, complete and
efficienthardware-basedtechniquessuchasIntelMPKandARM
memory domains can also be integrated into XRust, as explored in
recent work [9, 48].
Usingguardpagesalsoavoidspointeranalysisneededbyinstru-
mentation.Unlikeinstrumentation,whichrequirespointeranalysis
tolocateunsafeobjectstoinsertassertionsbeforememoryaccesses
onthem,guardpageenforcesisolationautomaticallyaftertheob-
jects are allocated into different regions. If a cross-region data flowoccursonanunsafeobject,theguardpagewillbeaccessedanda
segment fault will be issued automatically by the operating system.
6 EVALUATION
We have conducted extensive experiments to evaluate the effec-
tiveness and efficiency of XRust. To evaluate the efficiency, we
deployed XRuston six widely-used real-world applications. We
also studied five core components of Rust‚Äôs standard library where
unsafeRustisusedubiquitouslytoexamine XRustinextremecases.
Wemeasuredtheoverheadof XRustundertwoprotectionschemes:
guard page and instrumentation. Our experimental results show
thatXRustincurs0.15%overheadonmedian(2%onaverage)when
applying guard pages to detect cross-region references, and 3.6%
overheadonmedian(21%onaverage)whenusinginstrumentation.
We alsocompared XRustwith DFI [ 7] to understandthe overhead
that could be introduced by imposing a full protection of data-flow
integrity.
Toevaluatetheeffectiveness,westudiedallthethreepublicly
reported memory corruption errors that we could find in real Rust
programs [ 5,37,38]. We designed attacks to exploit these errors
andapplied XRustto defend against them.
TheexperimentsranonanAMDRyzen2600Xwith6cores@3.6GHz
processor in 64 bit mode with 32GB RAM. All experiments were
doneon Ubuntu Bionic Beaver (18.04 LTS).
6.1 Efficiency
All the real-world Rust applications are popular projects (with
more than one million downloads) collected from crates.io, the
official package central repository of Rust, and they all contain
unsafe Rust code. We use their built-in benchmarks to measure the
performanceof XRustforfairness.AlltheRuststandardlibraries
aremeasuredusingthebenchmarksfromtheRustcompiler.The
results are reported in Table 2 (averaged over 50 runs).
Whenusingguardpage, theoverheadcomesfromtheinserted
checksperformedintheheapallocatortoavoiderrorscausedby
corruptedmetadataintheunsaferegion(discussedinSection4.2.3).
Most cross-region references outside the heap allocator are au-
tomatically detected and reported by the operating system upon
illegalaccessesonguardpages.Thisapproachalsointroduces8KB
(two pages) memory overhead for each unsafe heap segment to
placeguard pages right below and above every unsafe segment.
AsreportedinTable2,theoverheadisnegligibleformostreal-
world applications (less than 0.5% for base64,byteorder ,image
andregex).Oneimportantfactorthataffectstheperformanceis
the frequency of heap allocations performed in the unsafe heap
region. The highest overhead (9.6%) is reported on bytes, which
heavily relieson unsafeheap allocation.We discussthe allocation
statisticsin Section 6.2.
When using instrumentation, the overhead is higher than
usingguardpages,becauseitrequiresaregioncheckbeforeeach
memory reference on unsafe objects. Nevertheless, the overhead is
still low in most cases (less than 5% for base64,byteorder ,image
andregex, and 16% for bytes). The highest overhead (103%) is
reported on base64(different from that of using guard pages).By
analyzingtheinstrumentedprogram,wefoundthereasonisthatin
Table 2: Performance of XRustandDFIon real-world Rust applications and standard Rust libraries (grayed rows).
App Ver.LoC#Dow-
nloadNative
(ms/iter)XRust DFI
g-page overhead inst.overhead exec.overhead
base64 0.5.1 2K2.32M 3527.72 3529.59 0.06%7167.63 103.15% 9721.60 175.58%
byteorder 1.2.72.3K4.70M 25.91 26.01 0.03% 26.76 3.28% 64.53 149.05%
json 0.11.13 4.3K0.39M 2213.17 2260.96 2.16%2298.91 3.87%12985.72 486.75%
bytes 0.4.10 7.9K1.80M 6.24 6.84 9.62% 7.25 16.19% 33.471 436.39%
image 0.20.113.3K 0.54M 2151.26 2152.87 0.07%2189.92 1.77%13426.83 524.14%
regex 1.0.648.1K 6.03M 2157.80 2162.48 0.22%2187.68 1.17%15251.78 606.82%
Median -- -2154.53 2157.68 0.15%2188.80 3.6%11353.66 461.57%
Average -- -1680.35 1689.79 2.03%2313.03 21.57% 8580.66 396.46%
vec 1.30.0 - - 0.40 0.42 4.08% 0.90123.08% 4.32555.00%
string 1.30.0 - - 2.00 2.03 1.52% 4.16108.30% 5.57178.50%
linked-list 1.30.0 - - 0.16 0.17 6.76% 0.20 13.70% 0.52225.00%
vec-deque 1.30.0 - - 0.71 0.71 1.13% 0.72 2.26% 4.01464.79%
btree 1.30.0 - -21.97 22.58 2.80% 23.88 8.69% 114.81 422.58%
Median -- - 0.71 0.71 2.80% 0.90 13.70% 4.32422.58%
Avg. -- - 5.05 5.18 3.26% 5.92 51.21% 25.85 369.17%
base64thechecksareinsertedintoaperformance-criticalfunction,
whichoccupies over 98% execution time of the program.
FortheRuststandardlibraries, theoverheadisslightlyhigher
thantherealRustapplications,withapproximately3%forguard
pages and 50% for instrumentation. The reason is that to bridge
between unsafe low-level operations and high-level Rust language
features, Rust‚Äôs standard library typically uses more unsafe Rust
code,whichincreasesthenumberofinsertedruntimechecks.Also,
the performance overhead is highly-related to the tests performed
onthebenchmarks.Sinceweusedtheoriginaltestsuites(forevalu-
ationfairness)andthe testsexamine different aspects ofthe bench-
marks,itcouldleadtodifferentperformancenumbers.Forexample,
oneofthefourtestcasesfor vec-deque aimsattesting thespeed
ofallocatingnewobjects,whichimposeslittleoverheadasnomem-
ory references need to be instrumented. It explains the differences
between the overhead reported in Table 2.
ComparisontoDFI, DFI[7]providesastrongprotectionagainst
control and data attacks, by ensuring the integrity of data flows at
runtime with respect to a statically computed data-flow graph. Un-
fortunatelyDFIincursprohibitiveoverheadinpractice(e.g.,around
4Xruntimeoverheadonaverageinourexperiments5).Intheirorig-
inalwork,Castroetal.useastaticreachingdefinitionanalysisto
determine the set of write instructions for each memory read, and
maintainaruntimedefinitiontable(RDT)torecordthelastwrite
instructiontoeachmemorylocationatruntime.Thisincursboth
largeruntimeoverhead(forcheckingallreadsandwrites)andspace
overhead (for storing the RDT) even after several optimizations.
Differently, XRustensuresthedata-flowintegrityfromunsafeRust
to safe Rust by isolating the unsafe memory region, thus it is much
faster(overanorderofmagnitude)thanthefullDFI,asreportedin
Table 2.
5The DFI prototype was implemented by ourselves on top of LLVM following the
paper [7], since DFI is not available.Table3:Allocationstatisticsinsafeandunsafeheapregions.
App#allocation
(safe)#allocation
(unsafe)%unsafe
allocation
base64 57.50M 25.41M 30.64%
byteorder 13.47K 4 0.02%
json 18.07M 0.39M 2.11%
bytes 34.06M 126.98M 78.85%
image 9.21M 10 0.00%
regex 19.83M 675 0.00%
Avg. 23.11M 25.46M 18.60%
vec 611.89M 37.49M 5.78%
string 516.80M 40.69M 7.21%
linked-list 2.93K 68.70M 99.95%
vec-deque 1.40K 12.54M 99.98%
btree 2.99K 20.51K 87.28%
Avg. 115.21M 42.26M 60.04%
6.2 Allocation Statistics
Table 3 reports the statistics of heap allocations in safe and unsafe
regions in our experiments. For most applications, they only use
unsafe Rust in limited locations and thus the allocations in the
unsafe region only account for a small fraction of the total amount
of heap allocations. One exception is bytes, which has around 80%
allocationsinunsafecode.Itisbecause bytesisalibrarythatdeals
with low-level data structure. It relies on unsafe Rust heavily to
access the low-level binary data. For other applications such as
regexandjson, almost all objects are safe. The data also confirms
our observation that in high-level user applications, programmers
typicallyavoid heavy use of unsafe Rust.
For the standard Rust libraries, the statistics are the opposite.
For three out of the five libraries, almost all the objects are unsafe.
However, this is not surprising since unsafe Rust is widely used in
standard libraries to deal with low-level operations.
Table 4: Performance of the heap allocator with different numbers of unsafe heap segments.
Size
(byte)#Thread:1 #Thread: 2 #Thread:4 #Thread: 8 Avg.
ptm-unsafeover-ptm-unsafe over-ptm-unsafeover-ptm-unsafeover-over-
alloc1ext.headallocext.headallocext.headallocext.headhead
16‚àº1k 25.9M24.5M 5.3%5.2M5.1M1.3%3.8M3.5M6.6%2.3M2.2M3.9%4.3%
32‚àº2k 25.6M23.7M 7.8%4.3M4.2M3.7%2.7M2.7M0.5%2.2M2.2M0.3%3.1%
64‚àº4k 16.0M15.5M 3.1%1.7M1.6M5.5%1.3M1.2M8.3%1.9M1.8M5.3%5.6%
128‚àº8k 14.9M13.8M 7.9%1.4M1.3M11.4%1.0M1.0M3.8%1.8M1.7M7.9%7.7%
256‚àº16k 13.7M12.9M 6.5%1.1M1.1M3.3%1.2M1.1M7.9%1.7M1.6M6.4%6.0%
Avg.19.2M18.1M 6.1%2.8M2.7M5.0%2.0M1.9M5.4%2.0M1.9M4.7%5.3%
1// using VecDeque as an example
2pub fnexploit() {
3//target object to corrupt (on stack)
4 lett = target_trait_obj;
5 let mut a=VecDeque::with_capacity(num);
6{
7// allocated just below deque
8 let mut b=Vec::with_capacity();
9
10// overflow here (in Section 6.4.1);
11deque.reserve();
12// corrupt metadata
13prepare_to_attack();
14deque.push_back(&t);
15}// free of b
16}
 
metadataHeap
FD
BK
metadataHeap
FD
BK
	

metadataHeap
FD
BK
Stack
 
 	



metadataHeap
FD
BK
Stack
 
 	


macrounlink {
*(FD+ off)
= BK
}



Figure 5: A proof-of-concept attack performed on VecDeque.
6.3 Performance of the Allocactor
The customized heap allocator is a core part of XRustand the
checks inserted inside the allocator can affect performance. To
quantifyitsperformance,wehaveheavilytestedtheallocatorusing
a benchmark from rpmalloc [19] and compared with unmodified
ptmalloc2 . In our settings, the benchmark iterates 20,000 times in
total and in each iteration it allocates and frees 30,000 heap objects
ofvarioussizes.Inaddition,alltheobjectsareallocatedviaextended
interfacesandplacedintheunsaferegion.Thisexperimentcouldbe
viewed as a worst case stress testing since the only functionalityof
thebenchmarkistoallocateanddeallocateheapmemory,andhence
provides insights on the worst case performance of the allocator.
The results are reported in Table 4. The overall performance
of the extended allocator is about 5% slower than ptmalloc2 on
average when tested with 1, 2, 4 and 8 threads.
6.4 Effectiveness on Real Vulnerabilities
Bythetimeofwriting,wefoundthreereportedmemorycorruption
errors in real-world Rust programs. We carefully studied each of
themandfoundthat XRustiscapableofpreventingalltheseerrors.
6.4.1 Corruption in VecDeque .VecDeque isadouble-endedqueue
implementedwithagrowableringbufferanditis apartofRust‚Äôs
standardlibrary.Abufferoverflowvulnerability(CVE-2018-1000657)
was discovered inside the VecDeque::reserve function only re-
cently. The simplified code is listed below:1pub fnreverse(&mut self, additional: usize){
2 letnew_cap = used_cap + additional;
3 ifnew_cap > self.capacity() {
4 self.buf.reserve(..);
5 unsafe{
6 self.handle_cap_increase(..);
7}}}
The root cause of the bug is on line 4, where the function mixes
upitsinternalcapacitywithitsuser-visiblecapacity.Becausethe
user-visible capacity is one element smaller than the actual size of
thebuffer,Theunsafefunction handle_cap_increase cancause
the pointer to point to out-of-bound memory address and upon
next push, a value can be written outside the buffer.
The vulnerability can be exploited to overflow one element out-
side the buffer, Because there is no public attack on this vulnera-
bility, we manually built a proof-of-concept case with a vulnerable
program using the function, and performed an unsafe unlink ex-
ploit[39]tomakeanarbitrarywritetovtablepointersasinFigure5.
Thisattackwouldfailonrecentglibcsinceextrasecuritychecks
wereaddedintothelibrary.Workaroundtobypassthecheckscould
befoundin[ 39].Theresultshowsthat XRustisabletodetectthe
attack consistently because both the stack and the data segment
are outside the unsafe heap region. A cross-region write to corrupt
the stack data and vtable pointers is detected by the heap allocator
sincethemetadatais corrupted by the overflow.
6.4.2 Corruption in str::repeat .Abufferoverflowbugwasre-
ported in the function str::repeat (CVE-2018-1000810), which is
alsoapartofRust‚Äôsstandardlibrary.Therootcauseofthebugisan
instanceofintegeroverflowtobufferoverflowbugs.Thesimplified
code is listed below:
1pub fnrepeat(&self,u :usize)- >Vec<T> {
2 let mut buf =Vec::with_capacity(n * len);
3
4 whilecondition {
5 unsafe{
6 ptr::copy(buf.as_ptr(),
7 buf.as_ptr().add(len),
8 len);
9 ...
10}}}
Thefunctionisusedtocreateastringthatrepeatsafixednumber
oftimes.Online2,whencalculatingthecapacityofthe Vectohold
thestringby n‚àólen,anintegeroverflowcouldhappen,whichin
turn results in a smaller buffer and causes an overflow when using
unsafe code to store the value on line 6. We similarly conductedthesameproof-of-the-conceptattackonitason
VecdDeque ,and
XRustcandetect the overflow as well.
6.4.3 Corruption in Base64 .Thedetailsofthiserror(CVE-2017-
1000430) have been presented in Section 2.2. Attacking this vul-
nerability ismore difficult than theprevious two cases,because it
requires triggering an overflow on a 64 bit integer. To perform a
proof-of-concept attack, we changed the Base64code to use 16 bit
integer. The experiment setting is similar to the other two cases,
andXRustis able to defend the attack in this case as well.
7 RELATED WORK
Techniques against memory-based attacks. Securing software
against memory-based attacks has been an extremely important
yet challenging problem. Many approaches have been proposed
for C/C++ programs, such as SoftBound+CETS [ 28,29] to provide
full memory safety, CPI [ 24] to secure code pointers, CFI [ 1]t o
defendagainstcontrol-flowattacks,andDFI[ 7]todefendagainst
data-flowattacks.Ourmethodofusingseparatememorytostore
metadataofpointersisinspiredbySoftBound,butinsteadofstoring
bound metadata in the shadow memory, we only require one bit
perpointerstoindicatewhetheritpointstoanunsafeobjectornot.
Also, instead of instrumenting every memory reference to check
theboundsofobjects,weonlyinstrumentmemoryreferenceson
unsafeobjectsandonlycheckifthereferencesarewithintheunsafe
heapregion.
Techniques target specifically at control-flow attacks such as
CFI [1], CPI [24] have seen wide adoption in commodity operating
systems and compilers [ 46], because they are practical to thwart
most abnormal control transfers with only a small or negligible
overhead. However, they can be bypassed by data-only attacks
such as Heartbleed [ 17]. DFI is a promising technique to deal with
memorycorruption,however,asshowninourexperiments,afull
DFIincursprohibitive runtime overhead.
1Measured by the number of memory operations per CPU second.Techniques specific to Rust. A few research efforts have been
investedintoRusttoformallyprovememorysafetypropertiesof
thelanguage[ 22,33,49],andtostaticallyverifyRustprograms[ 47].
Among them, FC [ 2] shares a similar goal as XRust, though with
very different techniques. At the technical level, FC uses operating
system-level support whereas XRustextends the heap allocator.
FConlyisolatesdatafromunsafeforeignfunctionsby mprotect
systemcallsinsteadofallsourcesofunsafeRustasaddressedby
XRust. Also, as discussed earlier in Section 5.1, FC does not handle
thesharedunsafeobjects in safe code.
TheRustbeltproject[ 22]hasformallyprovedthememorysafety
ofarealisticsubsetofRust,includingseveralstandardRustlibraries
withtheexistenceofunsafeRust.CRUST[ 47]usesboundedmodel
checkingtoverifymemorysafetyinunsafeRustcodebyfirsttrans-
lating Rust programs into C, and is shown effective in discovering
memory errors in the Rust standard libraries.
Isolation of resources. Isolation is a common approach to miti-
gate the influence of untrusted resources and XRustcan be viewed
as a new isolation approach within the address space of a single
Rust program. Researchers have proposed numerous techniques
to isolate memory regions in different domains. Native Client [ 51]
provides memory sandbox for untrusted library code by loading
libraries into limited containers. Codejail [ 50] propose another ap-
proach to limit libraries by making the program data read-only.
Linux‚Äôs seccomp [ 11] can also be utilized to limit system calls from
accessingsecurity-crucial data.For web browsers, the isolationof
resources (e.g., SOP [4]) is extremely important to defend agaist
maliciouswebsites.
There also exist a variety of isolation techniques by partition-
ing the code path. Wedge [ 6] provides memory isolation among
sthreads,eachofwhichcontainsathreadofcontrolandsecurity
policydefinedbytheprogrammer.Shreds[ 9],ontheotherhand,
splits each thread‚Äôs execution into multiple segments marked by
shred_enter() andshred_exit() ,andprovidesisolatedcompart-
mentsofcodeanddatabetweendifferentsegmentsthroughcom-
pilerandarchitectural support. Thesetwo are different from XRust
astheybothrequireprogrammers‚Äôefforttomodifytheprogram,
whereas XRustis fully automated by leveraging unique features of
the Rust programming language. PtrSplit [ 27] partitions the pro-
gramsbymarking sensitive pointersandselectivelycheckingthe
boundsofpointers.Theresourceisolationschemesarealsostud-
ied for Java programs. For example, Robusta [ 40] and Arabica [ 44]
isolatetheJavanative interface (JNI) from safe Java code.
8 DISCUSSIONS AND LIMITATIONS
We note that XRusttargets memory safety issues brought by un-
safe Rust only. XRustassumes Rust‚Äôs memory safety guarantees
to be valid, which requires a correct design and implementation of
Rust and its framework (including its standard libraries) so that no
memoryerrorwilloccurintheabsenceofunsafeRustcode.Thisis
essentialas safe abstractions provided by programming languages
are inherently encapsulations on unsafe operations. Attackers can-
not modify thecode segments since theyare unwritable and they
cannotcontroltheprogramloadingprocess.Theserequirements
ensurethattheintegrityoftheinstrumenteddynamicchecksand
the heapallocatorcan safely setup the isolation between safe and
unsafememory regions.
XRustdoesnothandledynamiccodegeneration.Thisisadifficult
problembecausethenewcodecannotbeanalyzedorinstrumented
statically by a compiler. This limitation is shared by techniques
relyingonstaticanalysis, e.g.,SoftBound[ 28],DFI[7],andCPI[ 24]
willallfailtoprotectagainstvulnerablecodegenerateddynamically.
A potential solution is to track dynamically generated code and
continuetheanalysisat runtime. We leave it as future work.
9 CONCLUSION
Wehavepresented XRust,anovelapproachtoprotectsafememory
objects in Rust from being corrupted by unsafe Rust code. The key
idea is to separate the address space of a Rust program into two
non-overlapping regions with a customized heap allocator and au-
tomatically insert runtime checks to efficiently detect cross-region
referencesonunsafeobjects.Ourextensiveevaluationonbothpop-
ularreal-worldRustapplicationsandstandardRustlibrariesshows
that XRustishighlyeffectiveandefficient:itpreventsattackson
the all the known Rust vulnerabilities while exhibiting small or
negligibleoverhead.Westressthatitispromisingtoapply XRust
to secure Rust applications in practice.
The source-code of the XRust compiler can be obtained through
https://github.com/parasol-aser/XRust.Theconfigureddockerim-
age can be obtained through https://hub.docker.com/repository/
docker/geticliu/xrust-icse2020
REFERENCES
[1]Mart√≠n Abadi, Mihai Budiu, Ulfar Erlingsson, and Jay Ligatti. 2005. Control-flow
integrity.In Proceedingsofthe12thACMconferenceonComputerandcommuni-
cationssecurity. ACM, 340‚Äì353.
[2]HussainMJAlmohriandDavidEvans.2018. FideliusCharm:IsolatingUnsafe
Rust Code. In Proceedings of the Eighth ACM Conference on Data and Application
Security and Privacy. ACM, 248‚Äì255.
[3] andigena.2016. ptmalloc fanzine. https://lwn.net/Articles/725832/.
[4] Adam Barth. 2011. Theweb origin concept. Technical Report.
[5]Rust base64 project. 2017. CVE-2017-1000430. https://www.cvedetails.com/cve/
CVE-2017-1000430/.
[6]Andrea Bittau, Petr Marchenko, Mark Handley, and Brad Karp. 2008. Wedge:
Splittingapplicationsintoreduced-privilegecompartments.USENIXAssociation.
[7]Miguel Castro, Manuel Costa, and Tim Harris. 2006. Securing software by
enforcingdata-flowintegrity.In Proceedingsofthe7thsymposiumonOperating
systemsdesignandimplementation. USENIX Association, 147‚Äì160.
[8]ShuoChen,JunXu,EmreCanSezer,PrachiGauriar,andRavishankarKIyer.2005.
Non-Control-DataAttacksAreRealisticThreats..In USENIXSecuritySymposium,
Vol. 5.
[9]Yaohui Chen, Sebassujeen Reymondjohnson, Zhichuang Sun, and Long Lu. 2016.
Shreds: Fine-grained execution units with private memory. In 2016 IEEE Sympo-
siumon Security and Privacy (SP). IEEE, 56‚Äì71.
[10]cmr. 2018. Unsafe Rust. https://doc.rust-lang.org/book/ch19-01-unsafe-rust.
html.
[11] JonathanCorbet.2009. Seccomp and sandboxing. LWN.net,May 25 (2009).
[12]JonathanCorbet.2017. Preventingstackguard-pagehopping. https://lwn.net/
Articles/725832/.
[13]JonathanCorbet.2017. TheStackClash. https://blog.qualys.com/securitylabs/
2017/06/19/the-stack-clash.
[14]Crispan Cowan, Calton Pu, Dave Maier, Jonathan Walpole, Peat Bakke, Steve
Beattie,AaronGrier,PerryWagle,QianZhang,andHeatherHinton.1998. Stack-
guard: Automatic adaptive detection and prevention of buffer-overflow attacks..
InUSENIXSecurity Symposium, Vol. 98. San Antonio, TX, 63‚Äì78.
[15]Alex Crichton. 2015. Tracking issue for changing the global, default allocator
(RFC1974). https://github.com/rust-lang/rust/issues/27389.
[16]ARM documentation. [n.d.]. ARM Memory Domain. http://infocenter.arm.com/
help/index.jsp?topic=/com.arm.doc.dui0056d/BABBJAED.html.
[17]ZakirDurumeric,JamesKasten,DavidAdrian,JAlexHalderman,MichaelBailey,
Frank Li, Nicolas Weaver, Johanna Amann, Jethro Beekman, Mathias Payer, et al .2014. The matter of heartbleed. In Proceedings of the 2014 Conference on Internet
MeasurementConference . ACM, 475‚Äì488.
[18]Wolfram Gloger. 2006. Wolfram Gloger‚Äôs malloc homepage. http://www.malloc.
de/en/.
[19]Mattias Jansson. 2017. rpmalloc-benchmark. https://github.com/rampantpixels/
rpmalloc-benchmark.
[20] japaric.2017. issue39699. https://github.com/rust-lang/rust/issues/39699.
[21]TrevorJim,JGregoryMorrisett,DanGrossman,MichaelWHicks,JamesCheney,
and Yanling Wang. 2002. Cyclone: A Safe Dialect of C.. In USENIX Annual
Technical Conference, General Track. 275‚Äì288.
[22]Ralf Jung, Jacques-Henri Jourdan, Robbert Krebbers, and Derek Dreyer. 2017.
RustBelt: Securing the foundations of the Rust programming language. Proceed-
ingsof the ACM on Programming Languages 2, POPL (2017), 66.
[23]Steve Klabnik and Carol Nichols. 2018. The Rust Programming Language.N o
Starch Press.
[24]Volodymyr Kuznetsov, L√°szl√≥ Szekeres, Mathias Payer, George Candea, R Sekar,
andDawnSong.2014. Code-Pointer Integrity.. In OSDI, Vol. 14. 00000.
[25]Doug Lea. 1996. A Memory Allocator. http://g.oswego.edu/dl/html/malloc.html.
[26]Stanley B Lippman. 1996. Inside the C++ object model. Vol. 242. Addison-Wesley
Reading.
[27]ShenLiu,GangTan,andTrentJaeger.2017. PtrSplit:SupportingGeneralPointers
in Automatic Program Partitioning. In Proceedings of the 2017 ACM SIGSAC
Conferenceon Computer and Communications Security. ACM, 2359‚Äì2371.
[28]Santosh Nagarakatte, Jianzhou Zhao, Milo MK Martin, and Steve Zdancewic.
2009. SoftBound:Highly compatibleandcomplete spatialmemorysafety forC.
ACM Sigplan Notices 44,6 (2009), 245‚Äì258.
[29]Santosh Nagarakatte, Jianzhou Zhao, Milo MK Martin, and Steve Zdancewic.
2010. CETS: compiler enforced temporal safety for C. In ACM Sigplan Notices,
Vol. 45. ACM, 31‚Äì40.
[30]George C Necula, Scott McPeak, and Westley Weimer. 2002. CCured: Type-safe
retrofitting of legacy code. In ACM SIGPLAN Notices, Vol. 37. ACM, 128‚Äì139.
[31]Phasar-Team. 2018. Phasar framework. https://github.com/secure-software-
engineering/phasar.
[32]Jonathan Pincus and Brandon Baker. 2004. Beyond stack smashing: Recentadvances in exploiting buffer overruns. IEEE Security & Privacy 2, 4 (2004),
20‚Äì27.
[33]Eric Reed. 2015. Patina: A formalization of the Rust programming language.
University of Washington, Department of Computer Science and Engineering, Tech.
Rep. UW-CSE-15-03-02 (2015).
[34]Rust-team.2011. TraitObjects. https://doc.rust-lang.org/book/trait-objects.html.
[35] Rust-Team. 2015. issue 26612. https://github.com/rust-lang/rust/issues/26612.[36]
Rust-Team.2017. UnsafeRust. https://doc.rust-lang.org/book/second-edition/
ch19-01-unsafe-rust.html.
[37]Pedro Sampaio. 2018. CVE-2018-1000657. https://bugzilla.redhat.com/show_
bug.cgi?id=1622249.
[38]Pedro Sampaio. 2018. CVE-2018-1000810. https://bugzilla.redhat.com/show_
bug.cgi?id=1632932.
[39]Shellphish. 2011. unsafe unlink. https://github.com/shellphish/how2heap/blob/
master/glibc_2.26/unsafe_unlink.c.
[40]Joseph Siefers, Gang Tan, and Greg Morrisett. 2010. Robusta: Taming the native
beast of the JVM. In Proceedings of the 17th ACM conference on Computer and
communicationssecurity. ACM, 201‚Äì211.
[41]Brain Smith. 2017. Stop using unsafe code. https://github.com/alicemaz/rust-
base64/issues/29.
[42]splotifun. 2015. Understanding glibc malloc. bhttps://sploitfun.wordpress.com/
2015/02/10/understanding-glibc-malloc/.
[43]YuleiSuiandJinglingXue.2016.SVF:interproceduralstaticvalue-flowanalysisinLLVM.In Proceedingsofthe25thInternationalConferenceonCompilerConstruction.
ACM, 265‚Äì266.
[44]Mengtao Sun and Gang Tan. 2012. Jvm-portable sandboxing of java√¢ƒÇ≈πs native
libraries. In European Symposium on Research in Computer Security. Springer,
842‚Äì858.
[45]Rustteam.2015. Langitems. https://doc.rust-lang.org/1.5.0/book/lang-items.
html.
[46]Caroline Tice, Tom Roeder, Peter Collingbourne, Stephen Checkoway, √ölfar
Erlingsson, Luis Lozano, and Geoff Pike. 2014. Enforcing Forward-Edge Control-
Flow Integrity in GCC & LLVM.. In USENIXSecurity Symposium. 941‚Äì955.
[47]John Toman, Stuart Pernsteiner, and Emina Torlak. 2015. Crust: A Bounded Veri-
fier for Rust (N). In Automated Software Engineering (ASE), 2015 30th IEEE/ACM
InternationalConference on . IEEE, 75‚Äì80.
[48]AnjoVahldiek-Oberwagner,EslamElnikety,NunoODuarte,PeterDruschel,and
DeepakGarg.2018. ERIM:Secure,EfficientIn-processIsolationwithMemory
Protection Keys. arXivpreprint arXiv:1801.06822 (2018).
[49]Aaron Weiss, Daniel Patterson, and Amal G Ahmed. 2018. Rust Distilled: An
Expressive Tower of Languages. CoRRabs/1806.02693(2018).
[50]Yongzheng Wu, Sai Sathyanarayan, Roland HC Yap, and Zhenkai Liang. 2012.Codejail: Application-transparent isolation of libraries with tight program in-
teractions.In EuropeanSymposiumonResearchinComputerSecurity.Springer,
859‚Äì876.
[51]Bennet Yee, David Sehr, Gregory Dardyk, J Bradley Chen, Robert Muth, Tavis
Ormandy,ShikiOkasaka,NehaNarula,andNicholasFullagar.2009. Nativeclient:A sandbox for portable, untrusted x86 native code. In Security and Privacy, 2009
30thIEEESymposiumon . IEEE, 79‚Äì93.
