Accelerating All-SAT Computation with Short Blocking Clauses
Yueling Zhang∗
ylzhang@smu.edu.sg
Singapore Management University
East China Normal UniversityGeguang Pu∗
ggpu@sei.ecnu.edu.cn
East China Normal University
Shanghai Trusted Industrial Control
Platform Co. Ltd.Jun Sun
junsun@smu.edu.sg
Singapore Management University
ABSTRACT
The All-SAT (All-SATisfiable) problem focuses on finding all satis-
fiable assignments of a given propositional formula, whose ap-
plications include model checking, automata construction, andlogic minimization. A typical ALL-SAT solver is normally based
oniterativelycomputingsatisfiableassignmentsofthegivenfor-
mula. In this work, we introduce BASolver, a backbone-based
All-SATsolverforpropositionalformulas.Comparedtotheexist-
ingapproaches,BASolvergeneratesshorterblockingclausesby
removing backbone variables from the partial assignments and the
blocking clauses. We compare BASolver with 4 existing ALL-SAT
solvers, namely MBlocking, BC, BDD, and NBC. Experimentalresults indicate that although finding all the backbone variablesconsumes additional computing time, BASolver is still more ef-ficient than the existing solvers because of the shorter blocking
clauses and the backbone variables used in it.
Withthe608formulas,BASolversolvesthelargestamountof
formulas (86), which is 22%, 36%, 68%, 86% more formulas than
MBlocking,BC,NBC,andBDDrespectively.FortheformulasthatarebothsolvedbyBASolverandtheothersolvers,BASolveruses
88.4%lesscomputingtimeonaveragethantheothersolvers.For
the 215 formulas which first 1000 satisfiable assignments are found
by at least one of the solvers, BASolver uses 180% less computing
time on average than the other solvers.
KEYWORDS
satisfiability, all-sat, blocking clauses
ACM Reference Format:
Yueling Zhang, Geguang Pu, and Jun Sun. 2020. Accelerating All-SAT Com-
putation with Short Blocking Clauses. In 35th IEEE/ACM International
Conference on Automated Software Engineering (ASE ’20), September 21–
25, 2020, Virtual Event, Australia. ACM, New York, NY, USA, 12 pages.
https://doi.org/10.1145/3324884.3416569
Geguang Pu* and Yueling Zhang* are the Corresponding Authors
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACMmustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ASE ’20, September 21–25, 2020, Virtual Event, Australia
© 2020 Association for Computing Machinery.
ACM ISBN 978-1-4503-6768-4/20/09...$15.00
https://doi.org/10.1145/3324884.34165691 INTRODUCTION
The satisfiability problem is a typical NP-complete problem. The
problemistodecidewhetheragivenpropositionalformulainCon-
junctive Normal Form (CNF) is satisfiable or not. The satisfiability
problem is ubiquitous in computer science and has attracted the
attentionofmanyresearchersbecauseofitssignificantimportance.
AnSAT(SATisfiability)solverisasoftwaretoolkitthatisableto
findasatisfiableassignmentforagivensatisfiableformulaoran
unsatisfiable proof for a given unsatisfiable formula. Although the
complexityofSATsolvingisNP-complete,modernSATsolversare
still able to find a satisfiable assignment efficiently. With the devel-
opmentofmodernSATsolvers,propositionalsatisfiabilitytheory
and satisfiable modulo theory have been widely applied to several
fields in computer science, including model checking [ 3,4], pro-
gramanalysis[ 2,6,22],networkverification[ 28,30,42],quantifier
elimination [5] and predicate abstraction [23].
SomeoftheapplicationsonlyneedtheSATsolvertofindone
satisfiableassignmentofthegivenformulaorprovethattheformula
isunsatisfiable,whileotherapplicationsmayrequiretheSATsolver
to find multiple or even all the satisfiable assignments of the given
formula.
Forexample,inthefieldofnetworkverification,theSATsolvers
areaskedtofindallthesatisfiableassignments.Sincemostmodernnetworksarecomplexandcontainmultipledevicessuchasrouters,
bridges, and firewalls. Device diversity together with erroneousmanual entry often lead to bugs that cause large downtime in
which valid packets are dropped, or invalid packets are let through.
Therefore, an ALL-SAT solver that computes all reachable packets
from a source to a destination is needed in network verification
[20,28,35,42].Lopesetal.[ 29]usetheALL-SATsolvingtechnique
tocomputeallthereachablepacketsforanetwork.Theygeneralizethereachabilityverificationtooltofindallthestatesinthereachableset.TheALL-SATsolvingtechniqueisalsoappliedtothepredicateabstraction[
7,23],whichisatechniquetoautomaticallyextracting
finite-stateabstractionsinsystemswithpotentiallyinfinitestatespace. For a formula and a set of predicates in a theory, Lahiri et
al. [24] use the ALL-SAT solver to enumerate all the models of the
formulaoverthepredicatesinthegiventheoryandfindthemost
preciseapproximationmodelofthesystem.Anotherapplicationof the ALL-SAT technique is in the field of image computation[
13,16,25,37] and symbolic model checking [ 31]. Gupta [ 17]e t
al. compute all the solutions below intermediate points in the SAT
decision tree.
In this work, we focus on the applications of SAT theory that
requirecomputingallthesatisfiableassignments(ALL-SAT)ofa
given formula, such as unbounded hardwaremodel checking [ 27],
logicminimization[ 36],temporallogicplanning[ 26],andknowl-
edge compilation [ 8]. Within these applications, the number of
62020 35th IEEE/ACM International Conference on Automated Software Engineering (ASE)
variablesintheSATformulasisusuallylargeandtheclausesare
usually complex. Therefore, the trivial method that blocks every
satisfiable assignment after finding it is inefficient.
There are mainly three methods to find all the satisfiable assign-
ments of a given formula, i.e., the blocking based strategy [ 31], the
backtracking based strategy [ 16] and the BDD (Binary Decision
Diagram) based strategy [ 40]. The key motivation of the block-
ing basedstrategy is togenerate lessand shorter blockingclauses
toblockmoresatisfiableassignments.Oncetheblockingclauses
falsifiedthegivenformula,thenallofthesatisfiableassignments
are expressed by the negation of the blocking clauses. The back-
trackingbasedstrategybacktrackstothepreviousdecisionlevelinside a DPLL (Davis-Putnam-Logemann-Loveland) tree. Choos-ing a good backtrack decision level is the key motivation of this
strategy. The BDDbased strategy complied with the CNF formula
into a Binary Decision Diagram using the knowledge complication
techniques, and all the satisfiable assignments are generated by
traversingallthepossiblepathsfromtherootnodetothesinknode
in the diagram.
When dealing with the formulas from these applications, the
existingblockingbased strategiestendtogenerate largeblocking
clausesthathindertheSATsolverfromquicklyfindingasatisfiable
assignment.Furthermore,thechoicesofbacktrack decisionlevels
arehardbecausethenumberofclausesintheformulaislarge.The
BDD itself tends to be too complex to traverse efficiently when the
numberofclausesandvariablesis large.Therefore,existingALL-
SATsolverswiththesethreestrategiesusuallyfailtofindallthe
satisfiable assignments ofthe formula generated fromthese appli-
cations. Due to the lack of proper ALL-SAT solver, the application
of SAT theory in these fields is limited.
In thiswork, wepropose anALL-SAT solver BASolver follow-
ing the blocking based strategy. But the generation of blocking
clauses in BASolver is different from the existing approaches. BA-
Solverfirstcomputesallthebackbonevariablesandpartsofthe
satisfiableassignmentsofthegivenformula.Atleastonesatisfiable
assignment is generated during the computing of the backbone
variables. Then BASolver uses the backbone variables to generate
thepartialassignmentsandtheblockingclausesfromtheknown
satisfiableassignments.Allbackbonevariablesareremovedfrom
thepartialassignments.Aclause ϕintheformulaiscoveredbya
variablexintheclauseif xisassignedto Trueinthegivensatis-
fiable assignment. BASolver uses a greedy strategy to generate
the shortestpartial assignmentsuch thateach clausein thegiven
formulaiseithercoveredbyabackbonevariableoravariableinthe
partialassignment.Finally,theblockingclauseisgeneratedwith
the negation of the partial assignment.
Comparing to the existing work, shorter blocking clauses are
obtained from the partial assignments in BASolver. There aretwoadvantagesofremovingbackbonevariablesfromthepartialassignments and the blocking clauses. Firstly, the complexity of
generatingapartialassignmentfromthefullsatisfiableassignment
isO(n×m), wherenis the number of variables in the formula and
mis the number of clauses in the formula. By directly removing
backbone variables from the partial assignment, the variables that
needtobecomputedinthepartialassignmentgenerationisreduced.
When thenumber ofclauses islarge, the reductionis significant.
Secondly,withshorterblockingclauses,theSATsolverisabletoreturn a new satisfiable assignment quicker, especially when the
numberofclausesislarge.Theexperimentalresultsshowthatwith
the help of backbone variables, the SAT solving in BASolver is
much faster, and less computing time is needed to generate a givenamountofsatisfiableassignments.Theresultsalsoshowthatwhen
all the backbone variables are added as unit clauses to the formula,
BASolver is still more efficient thanks to the shorter blocking
clauses used in it.
BASolverusesMiniSATv2.1.1[ 11]astheunderlyingSATsolver.
WecomparedBASolverwith4off-the-shelfALL-SATsolvers,in-
cluding two blocking based tools, MBlocking [ 41] and BC, one
backtracking based tool, NBC, and one BDD based tool, BDD [ 39].
Among all the ALL-SAT solvers, BASolver solves (finds every as-
signment of the given formula) the largest number of formulas
(86outof608)within10hoursand64Gmemory.While70,63,51
and 46 formulas are solved by MBlocking, BC, NBC and BDD,respectively. For the formulas that are solved by both BASolver
andoneofthecomparingsolvers,BASolveralsouses88.4%less
computing time than that used in the other solvers.
BASolver uses 24% less total computing time and 345% less
blockingtimeinfindingthefirst1000satisfiablepartialassignments
ofaformulawhosebackbonevariablesareaddedasunitclauses.
For the 69 formulas whose variables are all backbone variables,
BASolver solves the most formulas with the least computing time
comparing to each of thesolvers.More details of the experiments
are shown in Section 4.
The main contributions of our work are as follows:
•Weproposeanalgorithmtocomputeallthesatisfiableassign-
ments based on the backbone variables of the propositional
formula. It is the first application of the backbone variables
in the ALL-SAT solving problem.
•We propose a blocking based ALL-SAT solver BASolver to
compute all the satisfiable assignments of the given formula.Comparingtotheexistingwork,BASolverismoreefficient
duetotheuseofthebackbonevariables,theuseofshorter
partial assignments, and the use of shorter blocking clauses.
Experiments show that BASolver uses less computing timeamong all the blocking based, backtracking based, and BDD
based ALL-SAT solvers.
The remainder of the paper is organized as follows. We describe
notations and preliminaries in Section 2. The algorithms of BA-
Solver are discussed in Section 3, experimental results are shown
in Section 4, and the related work is discussed in Section 5. We
conclude the paper in Section 6.
2 BACKGROUND
In this section, we present the necessary background on the satisfi-
abilityproblemsandexplainhowbackbonevariablesareidentified.
We also discuss the straightforward blocking based methods to
compute all the satisfiable assignments and the backbone variables
of the given satisfiable formula.
2.1 The SAT and the ALL-SAT Problems
In this work, the propositional satisfiability formulas are described
in the Conjunction Normal Form (CNF), and the clauses are de-scribed in the Disjunction Normal Form (DNF). Let
Xbe a finite
7set ofBoolean variables. A variable x∈Xhas two literals, xand
¬x,andthevariable xiscalledthecorrespondingvariableofthe
literals. A clauseϕis a disjunction of the literals/logicalortext.1
li∈ϕli, which
is also represented as a set of literals {li|1≤i≤n}. A literal is
denotedas l∈ϕifϕisconsistsoftheliteral l.Avariable xisina
clauseϕiftheliteral xortheliteral ¬xintheclause ϕ.Aformula
Φis a conjunction of the clauses/logicalandtext.1
li∈ϕϕi. The formula Φcan also
berepresentedasasetofclauses {ϕi|1≤i≤n}.Forclarity,we
useϕto denote a clause and Φto denote a formula.
For every variable x∈Φ,Φxis the set of clauses that contain
eitherxor¬x, i.e.,ϕ∈Φxif and only if x∈ϕor¬x∈ϕ, and
Φp
xis the set of clauses that contain x,Φnxis the set of clauses that
contain¬x.
GivenasetofBooleanvariables,an assignment visamapping v:
X→{0,1,−1}.ThevalueofaBooleanvariable xinanassignment
visv(x).I fv(x)=1, thenv(¬x)=0. Ifv(x)=1, then¬v(x)=0,
i.e.,v(x)=¬¬v(x).I fv(x)=1,v(¬x)=0, ifv(x)=0,v(¬x)=1,
i.e.,v(x)=¬v(¬x). If the value of xinvis−1, then the value of
¬xinvis also−1, i.e.,v(¬x)=−1i fv(x)=−1. We also use the
conjunction of the literals whose value are 1 in an assignment vto
denotethe v,forexample,anassignment v(a)=1andv(b)=0is
alsowrittenas v=a∧¬b,whereaandbareliteralsoftheformula.
Thevalueof ϕundertheassignmentof vis1ifandonlyifthere
exists a literal l∈ϕandv(l)=1, denoted as v(ϕ)=1 if and only if
∃l∈ϕ,v(l)=1. For a clause ϕand an assignment v, we say that
v|=ϕif and only if v(ϕ)=1. The value of Φunder the assignment
ofvis 1 if and only if the value every clause ϕ∈Φis 1, denoted as
v(Φ)=1 if and only if ∀ϕ∈Φ,v|=ϕ, also written as v|=Φif and
only if ∀ϕ∈Φ,v|=ϕ.
An assignment vis afull assignment ofΦif and only if there
doesnotexistavariable x∈Φsuchthat v(x)=−1.Otherwise, xis
a partial assignment. Fora partial assignment vp, a fullassignment
vfimpliesvpif for every variable x∈Φ, such that vp(x)/nequal−1,
vf(x)=vp(x),denotedas vf→vp.Ifafullassignmentimpliesa
partial assignment, then the full assignment can be expressed and
replaced by the partial assignment in the set of all the assignments.
Anassignment λisasatisfiableassignment(solution)of Φifand
onlyifλ|=Φ.TheALL-SATproblemistocomputeallthesatisfiable
assignments of a given formula. Since the size of the satisfiable
assignmentscouldbeexponential,weusepartialassignmentsto
expressmultiplefullsatisfiableassignmentsatthesametime.For
a partial assignment vp, if every full assignment vfthat implies
vpis a full satisfiable assignment, then vpis called a satisfiable
partial assignment and can be used to express the set of all the
assignmentsthatimply vp,i.e.,vpexpressthesetoffullassignments
{vf|vf→vp,vf|=Φ}.
Modern SAT solvers usually use the DPLL algorithm [ 10][9]t o
findasatisfiableassignment.Therearetwokindsofvariablesduring
the solving, the decision variables, and the implication variables.
The solver assigns 0 or 1 to the decision variables and checks if
there exist any variables that need to be assigned to 1 after thecurrent decision.If there exist such variables,these variables are
called implication variables, and 1 is assigned to them. During the
DPLL process, a conflict happens if there exists a clause that the
value of every literal in the clause is 0. The solver backtracks to
the previous decision level whenever a conflict occurs. If a conflictoccursattherootlevel,thatmeanstheformulaisunsatisfiableand
the current conflict is a proof of it.
SATsolversalsosupporttheuseoftheassumptions.Anassump-
tionisasetofliteralsthatmustbeassignedto1inthesatisfiable
assignmentcomputedbytheSATsolver.Forasatisfiableformula Φ,
Φ∧assumightbeunsatisfiable.Inthiscase,theSATsolverreturns
asubsetof assuindicatingthereasonsthat Φisnotsatisfiableunder
the assumption of assu.
A straightforward blocking based method to compute all the
satisfiableassignmentsistoiterativelycomputesatisfiableassign-
ments. To avoid findingthe samesatisfiable assignment, thenega-
tionsofthealreadyknownsolutionsisaddedtotheformula.These
negations are called blocking clauses. Since a solution is a conjunc-
tionofunitliterals,thenegationofitisadisjunctionofunitliterals
(a clause), i.e., cλ=/logicalortext.1
lλ(l)=0. The formula Φ/primeis updated with
Φand the blocking clause c, i.e.,Φ/prime=Φ∧c,i fΦis unsatisfiable,
then all the satisfiable assignments are found. Otherwise a new
satisfiableassignment λ/primeisfoundbytheSATsolver Φ/primeisupdated
withΦ/prime∧c/prime
λuntilΦ/primeis unsatisfiable. If a assignment λ|=Φ/primeis
a satisfiable of Φ/primethenλis also a satisfiable assignment of Φ, i.e.,
λ|=Φifλ|=Φ/prime. In this way, all the satisfiable assignments of Φ
are found by the SAT solver with the help of Φ/prime.
We show an example to illustrate the above definitions. For a
propositional satisfiable formula Φ=(a∨b∨c)∧(a∨¬b∨c)∧
(a∨b∨¬c)∧(a∨¬b∨¬c). The set of clauses that contain the
variableais{a∨b∨c,a∨¬b∨c,a∨b∨¬c,a∨¬b∨¬c},theset
of clauses that contain the literal ¬ais∅. An assignment λsuch
thatλ(a)=1,λ(b)=1 andλ(c)=1 is a satisfiable assignment of
λ. A partial assignment vpsuch that vp(a)=1 is implied by λ, and
vpis a satisfiable partial assignment since all the full assignments
that imply vpis a satisfiable assignment of λ.
In an SAT solver with the given formula Φ, the variables a,b,
andcmay be assigned to 1 as decision variables respectively. In an
ALL-SATsolver,supposethefirstsatisfiableassignmentof Φisλ
such that λ(a)=λ(b)=λ(c)=1, then the blocking clause of λis
¬a∨¬b∨¬candΦ/prime=(a∨b∨c)∧(a∨¬b∨c)∧(a∨b∨¬c)∧(a∨
¬b∨¬c)∧(¬a∨¬b∨¬c). A new satisfiable assignment λ/primesuch
thatλ/prime(a)=1,λ/prime(b=1)andλ/prime(c)=0 is found by the SAT solver
andΦ/primeisupdatedwith Φ/prime=Φ/prime∧(¬a∨¬b∨c).Eventually, Φ/primewill
be updated to Φ/prime=Φ∧(¬a∨b∨c)∧(¬a∨¬b∨c)∧(¬a∨b∨
¬c)∧(¬a∨¬b∨¬c), and it is unsatisfiable. All the four satisfiable
assignments are λ1=a∧b∧c,λ2=a∧¬b∧c,λ3=a∧b∧¬c
andλ4=a∧¬b∧¬c.
2.2 The Backbone Variables
Foragivensatisfiablepropositionalformula Φ,avariable x∈Φisa
backbone variable ifthe valueof xinevery satisfiableassignment
ofΦremains the same. For an unsatisfiable propositional formula,
theredoesnotexistabackbonevariableastheredoesnotexista
satisfiableassignmentfortheformula.Aformaldefinitionofthe
backbone variable is as follows.
Definition2.1(TheBackboneVariables). Givenasatisfiablefor-
mulaΦ,avariable xisabackbonevariableof Φifandonlyif Φ∧x
is unsatisfiable or Φ∧¬xis unsatisfiable.
For a given formula Φ, a variable x∈Φis either a backbone
variable or a non-backbone variable. For a non-backbone variable
8Figure 1: Workflow of BASolver
xof the given formula Φ, there must exist two different satisfiable
assignments of Φsuch that λ1|=Φ,λ2|=Φ,λ1(x)/nequalλ2(x).
Astraightforwardalgorithmtocomputeallthebackbonevari-
ablesofagivenformula Φistoiterativelycheckthesatisfiabilityof
Φ∧xandΦ∧¬xforeveryvariable x∈Φ.Ifeitheroftheformulas
is unsatisfiable, then the variable xis a backbone variable.
Forexample,givenaformula Φ=(a∨b∨c)∧(a∨¬b∨c)∧(a∨b∨
¬c)∧(a∨¬b∨¬c),thevariable aisabackbonevariablesince Φ∧¬a
is unsatisfiable. And both the variable bandcare non-backbone
variables, since Φ∧b∧candΦ∧¬b∧¬care satisfiable.
3 ALL-SAT SOLVER USING THE BACKBONE
VARIABLES
The workflow of BASolver is shown in Figure 1. There are mainly
two phases in BASolver, the backbone computing phase, and the
blocking phase. In the backbone computing phase, BASolver com-
putes all the backbone variables of the given formula Φwith the
EDUCIBone tool [ 43]. There are two parts in the output of EDUCI-
Bone, a complete set of backbone variables and a set of satisfiable
assignments. Notice that it only generates parts of the solutions,
butBASolverstillbenefitsfromthesesolutionsasitdoesnotneed
to generate again. All the backbone variables of the given formula
Φare inBL(Φ)and parts of the satisfiable assignments are in S(Φ).
The partial assignments of S(Φ)are generated and stored in Sp(Φ)
in the blocking phase.
Intheblockingphase, BASolvertakesthebackbonevariables,
the given formula and the given satisfiable assignments as the
inputs and generates the partial assignment pλand the blocking
clausebcλfor each given satisfiable assignment λ∈Sp(Φ). The
blockingclause bcλisthedisjunctionoftheliteralsassignedto0in
thepartialassignment pλ,i.e.,bcλ=/logicalortext.1
pλ(l)=0l.Thentheformula
Φ/primeis updated with Φ∧bcλand the partial assignment pλis added
tothesetofthepartialassignments Sp(Φ).Ifthenewformula Φ/primeis
unsatisfiable,BASolverhasfoundallthesatisfiableassignments
of the given formula Φ. Otherwise, a new satisfiable assignment is
addedto S(Φ).Then,BASolvercomputesthepartialassignment
pλ/primeand the blocking clause bcλ/primefor the next satisfiable assignment
inSp(Φ), and updates Φ/primewithΦ/prime∧bcλ/prime. The partial assignment
pλ/primeis added to Sp(Φ). The blocking phase only terminates when
Φ/primeis unsatisfiable. Since the number of satisfiable assignments
of the formula Φis finite, and Φ/logicalandtext.1
∀λ|=Φbcλis unsatisfiable, Φ/primewilleventually becomeunsatisfiable intheblocking phase.When
BASolverterminates,allsatisfiableassignmentsof Φareexpressed
by the negation of the blocking clauses in S(Φ).
3.1 Computing the Backbone Variables
WebrieflyintroducethealgorithmweuseinBASolvertocompute
all the backbone variables. BASolver uses the EDUCIBone [ 43]
to compute the backbone variables, and the algorithm is shown in
Algorithm1.Thealgorithmfirstinitializes5arrays.Theset wisthe
setof theliteralsthat havenotbeen handledinthe algorithm,the
settis the set of the literals that need individual SAT solving. The
setblis the set of the currently known backbone variables and the
setnblis the set of the currently known non-backbone variables. S
is the set of the satisfiable assignments computed in Algorithm 1.
Atfirst,thealgorithmcomputesasatisfiableassignmentofthe
givenformula ΦusingSAT(Φ),ifΦissatisfiable, retisTrueandthe
satisfiableassignmentis λ,otherwise cistheunsatisfiablereason
(if exits). If Φis unsatisfiable, there isno backbone variable. If Φis
satisfiable,everyliteral lofΦwhichhasbeenassignedto0isadded
tow,andλisaddedto S.Thenthealgorithmiterativelyhandlesthe
literals in w. The variables in it are separated into groups, chunk
is the size of the group. Separating is very helpful in formulas
withlargeamountofvariables.The chunkamountis100according
to the most efficient configuration in [ 43]. We also try different
chunkvalues in the experiments, but the performance difference
issmall.Foragroupofliterals assu,ifΦ∧assuissatisfiable,then
thecorrespondingvariableofeveryliteralin assuisaddedto nbl,
and the new assignment is added to S. Otherwise, if the size of the
unsatisfiablereason cis1,thenthecorrespondingvariableofthe
literalincisaddedto blandremovedfrom assu.Ifthesizeofthe
unsatisfiable reason cis greater than 1, then all the literals in care
addedtotandremovedfrom assu.Thealgorithmtheniteratively
checkthesatisfiabilityof Φ∧assuuntilitissatisfiable.Sincethe
size ofassuis finite,assuwill either become empty or Φ∧assu
becomessatisfiable.Anewchunkofliteralswillbeassignedto assu
when the computing of the current chunk is finished. When the w
setisempty,thealgorithmstartstodealwiththeliteralinthe tset.
Foreachliteral l∈t,ifΦ∧lissatisfiable,thenthecorresponding
variable of lis a backbone variable, otherwise it is a non-backbone
variable.
3.2 Backbone Variables based Blocking Clauses
Computing
Wethenintroducethecomputingofthepartialassignmentandthe
blocking clause (the blocking phase) based on a given satisfiable
assignment λofthegivenformula Φandallthebackbonevariables
ofΦ.
Forasatisfiableformula Φandabackbonevariable x,ifthevalue
ofxin every satisfiable assignment of Φis 1, then the satisfiable
assignments of ΦandΦ∧xare the same. It means that if a as-
signment λ|=Φ, thenλ|=Φ∧x, and ifλ/negationslash|=Φ, thenλ/negationslash|=Φ∧x.
Therefore,foraformula Φandbackbonevariablesof ΦinBL(Φ),the
result of ALL-SAT solver will not be changed by replacing Φwith
Φ/logicalandtext.1
l∈BL(Φ) ,λ(l)=1l. After replacing the formula Φ, we can remove
the backbonevariables from allthe satisfiablepartial assignments
sincethevalueofthebackbonevariablesisalreadyfixedbythenew
9ALGORITHM 1: Computing the Backbone Variables
Function backbone Φ
w= [];t= [];nbl= [];bl= [];S= [];
(ret,λ,c)=S A T ( Φ);
if!retthen return ∅;
ifretthen
S.add(λ);
foreachl∈Φ,λ(l)=0dow.add(l);
whilew.size()/nequal0do
assu=w[0:chunk];
w.remove(assu);
(ret,λ,c)=S A T ( Φ∧assu);
while!retdo
ifc.size() == 1
end
thenbl.add(c);
elset.add(c);
assu=assu.remove(c);
(ret,λ,c)=S A T ( Φ∧assu);
nbl.add(assu);
S.add(λ);
endforeachl∈tdo
(ret,λ,c)=S A T ( Φ∧l);
ifretthen
nbl.add(l);
S.add(λ);
endelsebl.add(l);
end
endreturnbl,S;
end
formula. For a satisfiable partial assignment p,pcontains all the
backbonevariablesof Φ,although p/primeisnolongerasatisfiablepartial
assignmentafterremovingthebackbonevariables,wecaneasily
recoverpfromp/primeas all the backbone variables of Φare already
known. As we discussed before, shorter partial assignments will
leadtoshorterblockingclausesandacceleratetheALL-SATsolving
procedure. Based on the above observation, Algorithm 2 computes
the shorter partial assignment and the blocking clause. The idea of
thealgorithmistocomputethesatisfiablepartialassignmentand
removes all the backbone variables from it.
With a given formula Φ, a satisfiable assignment λ|=Φand
allthebackbonevariables BL(Φ)ofΦ.Algorithm2firsttraverses
the non-backbone variables in λ, if the variable xis an implication
variable, then xis added to the array of the partial assignment p.
BasedontheDPLLprocedureintheMiniSATSolver,ifavariable
xis an implication variable, then there must exist at least a clause
ϕofΦsuch that either xor¬xhas to be assigned to 1 to make
ϕsatisfiable. Therefore, the implication variable xmust exist in
the satisfiable partial assignment of λ. If the variable xis not animplication variable, and the value of xinλis 1, the algorithm
iteratively checks every clause ϕsuch that l∈ϕto see iflis the
only literal in ϕwhich has been assigned to 1. If so, lis also in
thepartialassignment.Thealgorithmcheckstheclausesin Φn
lif
λ(l)=0.Foreveryliteraladdedto p,thenegationoftheliteralis
added tob.
Aftercheckingallthenon-backbonevariables,thepartialassign-
mentpandtheblockingclause caregenerated.Thetimecomplexity
of Algorithm 2 is O(m×n×k), wherem,n,kare the number of
clauses,variablesandsatisfiableassignmentsof Φ.Toreducethe
computing in Algorithm 2, we add a small optimization in the
BASolver tool. We compare the difference between two satisfi-able assignment, and only the variables with different values are
computed.
ALGORITHM 2: ComputingthePartial Assignmentandthe
Blocking Clause
Function blocking Φ,λ,BL(Φ)
b= [];p= [];
foreachx∈λ,x/nelementBL(Φ)λ(x)=1orλ(¬x)=1do
ifxis an implication variable then
p.add(x);
ifλ(x)=0thenb=b∨x;
elseb=b∨¬x;
end
else
ifλ(x)=0then
foreachϕ∈Φp
xdo
if/nexistsl∈ϕ,λ(l)=1then
p.add(x);
b=b∨x;
break;
end
end
endifλ(x)=1then
foreachϕ∈Φnxdo
if/nexistsl∈ϕ,λ(l)=1then
p.add(x);
b=b∨¬x;
break;
end
end
end
end
endreturnp,b;
end
Therearetwoadvantagesofremovingthebackbonevariables
from the partial assignments. Firstly, the following SAT solving
is easier for the SAT solver since the size of the clauses has been
significantlyreduced.Moreover,eventhetimecomplexityofthe
computing the partial assignment and the blocking clause is in
10polynomial time, but it still could be time and memory consuming
whentheformulasandthenumberofthesatisfiableassignments
are large. By removing the backbone variables from the partial
assignments, we could save a large amount of computing time and
memory resources during the blocking phase. Experiments also
indicatethatfora special groupoftheformulas,whichonlyhave
one satisfiable assignment, finding all the backbone variables is
generallyfasterthandirectlyfindingallthesatisfiableassignments
using the existing ALL-SAT tools.
ALGORITHM 3: Computing all the Satisfiable Assignments
(BL(Φ),S) = backbone(Φ);
Sp= [];
Φ/prime=Φ;
foreachλ∈Sdo
(p,b) = blocking(Φ ,λ,BL(Φ));
Phi/prime=Φ/prime∧b;
(ret,λ,c)=SAT(Φ;);
ifretthen
S.add(λ/prime);
Sp.add(p);
end
else return Sp,BL(Φ);
end
Aftercomputingthepartialassignmentsandtheblockingclause
oftheagivensatisfiableassignment,weupdatetheformula Φto
Φ∧bcandcontinuefindingthenextsatisfiableassignmentofit.The
algorithm of BASolver is shown in Algorithm 3 with the function
ofbackbone (Φ)andblockinд(Φ,λ,BL(Φ))introduced in Algorithm
1 and Algorithm 2.
Foragivenformula Φ,BASolverfirstcomputesthebackbone
variables BL(Φ)ofΦ, the satisfiable assignments generated during
thecomputingisin S.ThenBASolvercomputesthepartialassign-
mentpandtheblockingclause bforeverysatisfiableassignment
λinS.IfΦ/prime∧bissatisfiable,newsatisfiableassignmentisadded
toS. The partial assignment of every satisfiable assignment in S
isaddedto Sp.IfΦ/prime∧bisunsatisfiable,BASolverreturns Spand
BL(Φ). The satisfiable partial assignments are generated by adding
all the backbone variables back to each partial assignment in Sp.
4 EVALUATION
We implemented BASolver based on the EDUCIBone tool, fol-
lowing a blocking based strategy. We use the Minisat 2.2 as the
SAT solver. BASolver is implemented in C++ with approximately
1000linesofcodeforthemainalgorithm.Theexperimentsarecon-
ducted on a cluster of Linux systems. The runtime limitation is 10
hours and the memory limit is 64GB. Only one formula is running
on a node of the cluster at one time, and no parallel techniques are
used during the experiments. BASolver uses the solve()interface
of the MiniSAT solver to solve formulas and the addClause ()in-
terfacetoaddnewblockingclausestotheformula.Itdidnotuse
other incremental features of the MiniSAT solver. We evaluate the
efficiencyofBASolverthroughmultipleexperiments,answering
the following research questions:•RQ1:HoweffectiveisBASolvercomparingtootherALL-
SAT solvers?
•RQ2:Is the shorter blocking clause really useful in the
ALL-SAT computing?
•RQ3:Is the percentage of the backbone variables in the
formulasrelatedtotheperformanceofBASolver?Isitcost-
effective to compute all the backbone variables first?
4.1 Experimental Setup
•BenchmarksandEvaluationMetrics. InasurveybyTodaand
Soh[39],threesourcesbenchmarksareused.TheSATcompetitions
of 2014, the SATLIB benchmark and the ISCAS85 libraries. We
extend the first source with benchmarks of SAT competitions from
2011to2017.Wefoundthatthelinkofthethirdsourceisnolonger
accessible, andthe formulas inthe SATLIB libraries areeither too
simple (all of the solvers finished within 1 second) or too hard
(none of the solver finishes). Therefore, we only uses the extended
first source as our benchmark. There are 1816 formulas in total,552 out of which are known as unsatisfiable, 608 out of whichare satisfiable and the satisfiability of the rest remains unknown.
The final benchmark is consists of the 608 satisfiable formulas.
Among the 608 formulas, EDUCIBone is able to compute all the
backbone variables of 214 formulas. For the rest of the formulas,
computingonesatisfiableassignmentalwaysspendsmostofthe
timelimitation,andfinishingALL-SATcomputingusinganysolver
is unlikely possible for them.
For an SAT solver, such as MiniSAT, we say a formula is solved
bytheSATsolverifitfindsatleastonesatisfiableassignmentof
theformula.FortheALL-SATsolvers,suchasBASolver,wesay
a formula is completely solved by the ALL-SAT solver if it finds
every satisfiable assignment of the formula, if the ALL-SAT solver
onlyfindspartsofthesatisfiableformula,wesayitpartiallysolvedtheformula.Weusethenumberofsolvedformulasandtheaveragecomputing time as metricsto evaluate the performance of theALL-
SATsolvers. Forthe formulasthat ALL-SATsolver arenotable to
find all the satisfiable assignments, we use the average computing
time of fining the first 1000 satisfiable assignments as the metrics.
•Baseline Approaches. To conduct a complete and objective com-
parisonbetweenBASolverandtheexistingtools,weuse4different
ALL-SATsolversintheexperiments.AmongthepublicALL-SAT
solvers with the available toolkit, these 4 performs the best.
The first ALL-SAT solver is MBlocking, it also uses the partial
assignmentstoexpressthefullsatisfiableassignments.Theauthors
propose three different strategies in MBlocking, All-Clauses, Non-
disjointing, and hybrid. We use the configuration of the hybridstrategy since the authors claim that it performs the best. Theother three tools are all from a survey in the year 2016. In the
survey, Toda and Soh [39] conclude the existing ALL-SAT solving
algorithmsandimplementedthemtoALL-SATsolvers.Thereare
different configurations used in these solvers, we use the default
configurations of these solvers. The second ALL-SAT solver is BC,
though is also uses the blocking basedstrategy. The last two ALL-
SAT solvers are NBC and BDD. NBC uses a backtracking basedstrategy to find all the satisfiable assignments and BDD uses the
BDD-basedstrategy.AllthelastthreeALL-SATsolver(BC,NBC
11Formulas AveVAR AveCL AveFST #AveSATInst BASolver MBlocking BC NBC BDD
dimacs(17) 680 17079 508.14 1 17 16 14 1 15
AProve(3) 8565 28931 7.32 78 3 2 2 2 0
complete(4) 600 27140 0.02 1 4 3 4 4 0
Encryption(17) 8616 82773 44.75 1 17 12 16 15 7
Manthey(25) 5179 23692 780 2.58 25 22 14 19 15
mp1(12) 16301 185948 630.41 305.75 12 10 9 6 8
Others(8) 11593 44557 325.19 1131 8 5 4 4 1
Total(86) 7323 393119 327.97 227.79 86 70 63 51 46
Table 1: Overall Performance of All-SAT Computing Tools
andBDD)changestheimplementationoftheMiniSATsolverwhile
BASolver and MBlocking use the MiniSAT solver as a black box.
Due to the strategies used in NBC and BDD, they do not use the
partial assignments to express the full satisfiable assignments, and
duetotheimplementationofBC,thoughitusesablockingbased
strategy, it also does not use the partial assignments to express the
full satisfiable assignments. The difference between the number of
the full satisfiable assignments and the number of partial assign-
ments that express them could be large. Therefore, the comparison
on the formulas which are not completely solved by any of the
5 ALL-SAT solvers are only conducted between BASolver and
MBlocking.
4.2 Results
•RQ1:Howeffectiveis BASolver comparingtootherALL-SAT
solvers?Weshowtheformulas ingroups thatare atleastsolvedby
one of the ALL-SAT solvers. The first column of Table 1 shows the
name of the groups. From the second to the fifth columns shows
thebasicinformationoftheformulas,includingtheaveragenum-
berofthevariables(AveVAR),theaveragenumberoftheclauses
(AveCL), the average computing time for the first satisfiable as-
signment (AveFST) and the average number of satisfiable formulas
(#AveSATInst).Theaveragenumberofsatisfiableformulasinthe
dimacs,complete,andEncryptiongroupis 1,indicatingthatallthe
variables in these formulas are backbone variables. The average
number of satisfiable formulas in the Manthey group is also small,
indicatingthatmostofthevariablesarebackbonevariablesinthese
formulas.
FromthesixthtothetenthcolumnsinTable1showsthenumber
offormulasineachgroupsolvedbyBASolver,MBlocking,BC,
NBC, and BDD respectively. Figure 2 shows the comparison of the
formulanumberssolvedbytheALL-SATsolversindifferentgroups.
Thereare8groupsofbars,indicatingthegroupsoftheformulas.
There are 5 bars in each of the groups, indicating the number of
solved formulas of the ALL-SAT solvers. The y-aixs shows the
numberofthesolvedformula.Thefirstbarineachgroupisalways
thehighest,itmeansthatBASolversolvesthemostformulasin
all the groups. In total, BASolver solves 86 formulas, which is 22%
more than MBlocking solves, 36% more than BC solves, 68% more
thanNBCsolves,and86%morethanBDDsolves.Theresultsshow
that BASolver solves more formulas than all the other 4 tools in a
given time limit.
Figure2:NumberofSolvedFormulasoftheALL-SATsolvers
Figure 3: Comparison of Computing Time among the 5Solvers
Figure 3shows the comparisonof computing timetime among
the 5 ALL-SAT solvers. Each bar shows the computing time of BA-
Solvertosolvetheformula.ThecomputingtimeofMBlocking,
BC,NBC,andBDDareshownwiththedot,cross,plus,andtriangle,
12Figure 4: Comparison of the Computing Time between BA-
Solverand the Most Efficient Solver
respectively. For most of the formulas, BASolver uses less com-
putingtimethantheother4solverssincemostoftheshapesare
notdrawn onthebars. Theaveragecomputingtime of BASolver
amongthe86formulasis3882seconds.Forthe70formulasthatare
both solved by BASolver and MBlocking, BASolver needs 209%
less computing time than MBlocking does. For the 63 formulas
that are both solved by BASolver and BC, BASolver needs 2%less computing time. For the 51 formulas that are both solved byBASolver and NBC, BASolver needs 36% less computing time,
andforthe46formulasthatarebothsolvedbyBASolverandBDD,
BASolver needs 107% less computing time.
Figure4 showsthecomparisonof thecomputingtimebetween
BASolver and the 4 comparison solvers. The minimal computing
time for a formula among the 4 comparison solvers is used to com-
parewithBASolver.Theredlinedenotesthecomputingtimeof
BASolver for each formula and the bars denote the comparison
computing time of the formulas. It shows that the performance be-
tweeneachsideissimilar,indicatesagoodversatilityofBASolver.
TheBASolversolvesmoreformulasthanthecomparisonsolvers
withthegiventimelimitation.Fortheformulasthatarebothsolved
byBASolverandeachofthecomparisonsolver,BASolveruses
less computing time. Moreover, BASolver also shows good ver-
satilitybyasimilarperformancecomparingtothemosteffective
solver, which is different for every different formula.
Answer to RQ1 :
BASolver solves more formulas within the given computing
limitation. And less computing time is used in BASolver for
solving the same formulas.
•RQ2: Is the shorter blocking clause really useful in the ALL-SAT
computing? SincetheuseofbackboneinformationintheALL-SAT
computingonlyhastwoconsequences,shorterblockingclausesandadditionalunitclauseswithbackbonevariables.ToanswerRQ2,we
add the backbone variables as unit clauses to the original formulas.
We then compare the SAT solving time, the blocking time, and
the total computing time of finding the first 1000 satisfiable partial
assignmentsofeachformulawiththedifferentsolvers.ThesolvingtimeindicatesthecomputingtimeconsumedbytheMiniSATsolver,
and the blocking time represents the computing time consumed by
the generation of the partial assignments and the blocking clauses.
SinceitisdifficulttoseparatetheblockingandthesolvingprocessinBC,NBC,andBDD,weonlycompareBASolverwithMBlocking
in this experiment.
Thereare214formulasinwhichallthebackbonevariablesare
foundbyEDUCIBone.Within10hours,and64GBmemorylimit,
BASolverfinishescomputingthefirst1000satisfiablepartialas-
signments of 105 formulas and MBlocking finishes computing the
first1000 satisfiablepartialassignments of94 formulas.Allthe 94
formulasfinishedbyMBlockingarealsofinishedbyBASolver.
Among them, for 76 of the formulas, BASolver uses less block-
ing time, and for 64 of the formulas, MBlocking uses less solving
time. In total, the average computing time for the 94 formulas in
BASolver is 472 seconds, which is 24% less than MBlocking (615
seconds). The average blocking time of BASolver (138 seconds)
is 345% time less than that used in MBlocking (615 seconds). The
average solving time of BASolver is 333 seconds, which is similar
to thatin MBlocking (339 seconds).Therefore, the more efficient
blocking process mainly contributes to the efficiency of BASolver.
Sinceallthevariablesareaddedasunitclausestothegivenformula,theshorterblockingclausesisthemainreasonthatBASolveruses
less blocking time than MBlocking does.
Figure 5 shows the comparison of the blocking time, solving
time, and the total computing time used in finding the first 1000
satisfiablepartialassignmentsforaformula.Theredbarsshowthe
blocking time used in BASolver, the blue bars show the solving
timeusedinBASolver,thegreenbarsshowtheblockingtimeused
in MBlocking, and the yellow bars show the solving time used in
MBlocking.Formosttheformulasintheplot,thetotalcomputingtimeusedinBASolverislessthanthatusedinMBlocking.Also,inbothofthesolvers,theblockingprocessconsumesmorecomputing
timethanthesolvingprocess,duetoalargenumberofvariables
and clauses in the formulas.
In this experiment, BASolver uses 345% less blocking time in
finding the first 1000 satisfiable partial assignments in each one of
the formulas. Theshorter blockingclauses areuseful inALL-SAT
solving as they are the main difference between BASolver and
MBlocking within the experiment.
Answer to RQ2 :
Theshorterblockingclausesleadtoalessblockingtime,which
is useful and efficient in the ALL-SAT solving.
•RQ3: Is the percentage of the backbone variables in the formu-
las related to the performance of BASolver? Is it cost-effective to
compute all the backbone variables first? For all the 5 solvers in
the experiments, more formulas are solved when there are morebackbone variables in the formulas. Nearly 75% of the formulas
solvedbythe5solvershave100%percentageofbackbonevariables.
Figure6showsthecomputingcomparisonofthe5solversonthe
formulas with a 100%percentage of backbone variables. The light
bluebarsarethecomputingtimeofBASolver,andthelightred
barsaretheleastcomputingtimeamongthe4comparingsolvers
for the same formula. Notice that the lighter (red) bars starts from
13Figure 5: Comparison of the Blocking and Solving Time be-
tweenBASolver andMBlocking
Figure 6: Comparison of the Computing Time for the For-mulas with 100% backbone variables
the top of the darker (blue) bars, which means that if that if BA-
Solver does not use the least computing time, the circles, dots, or
crosses might below the lighter bars. The dots, crosses, pluses, and
triangles represents the computing time of MBlocking, BC, NBC,
and BDD for the same formula, respectively. BASolver uses the
least total computing time among the 5 solvers. For almost half of
the formulas, BASolver needs the least computing time among all
the 5 solvers. It indicates that if only one solver is applied to these
formulas, BASolver is the most efficient one.
Wechoosethe64formulasthatbothBASolverandMBlocking
finds the first 1000 satisfiable partial assignments to study the rela-
tion between the performance of BASolver and the percentage of
thebackbonevariables.Thepercentageofthebackbonevariableintheseformulasrangesfrom0.001%to99.7%,theaveragepercentage
is 25.6%.
Figure7showsthecomparisonoftheblocking,solvingandcom-
puting time between BASolver and MBlocking among the 64
formulas.TheredplotshowstheblockingtimeofMBlocking,and
Figure 7: Comparison of the Computing Time for the For-mulas with Different Percentages of Backbone Variables
the blue plot shows the total computing time of MBlocking. From
bottomtotap,theyellowbarsshowtheblockingtimeinBASolver,
the green bars show the solving time in BASolver, and the purple
bars show the backbone computing time in BASolver. For most of
the formulas, the blocking time used in BASolver is less than that
in MBlocking. The average blocking time in BASolver is 200%times less than that in MBlocking. But due to the computing ofthe backbone variables, for nearly 20 formulas, BASolver needs
morecomputingtimetofindthefirst1000satisfiablepartialassign-
ments. For most of the formulas, less computing time is needed for
BASolver.
Figure8showsthecomparisonoftheaveragecomputingtime
between BASolver and MBlocking grouped by the percentageof the backbone variables. MBlocking uses less computing time
when the percentage of backbone variables is 50%, 80%, and 90%.
Thisisbecausethe64formulasarerelativelymoredifficulttothe
MiniSAT solver, more computing time are consumed when finding
allthebackbonevariables.Whentherearenotenoughsatisfiable
assignments in the formulas with more backbone variables, the
time-consuming in the backbone computing phase becomes moreand more serious.
The general performance of BASolver comparing to the other
solvers is not affected by the percentage of the backbone variables.
But since there are less satisfiable assignments that exist whenthe percentages of backbone variables are high, more formulas
aresolvedbyallofthe5solverswithmorebackbonevariablesin
the formulas.The experiments showthat even thoughcomputing
allthebackbonevariablesrequireadditionalcomputingtime,but
BASolver uses less computing time for each of the partial assign-
ments in most formulas. For the formulas that all the variables are
backbonevariables,theaveragecomputingtimeusedinfindingthe
onlysatisfiableassignmentinBASolverislessthanthatineach
ofthecomparingsolvers.Therefore,computingallthebackbone
variables in ALL-SAT solving is cost-effective. If there is only one
satisfiable assignment, BASolver is able to find it quickly after
computingallthebackbonevariablesformostoftheformulas.If
thereareamountofthesatisfiableassignmentsislarge,theaverage
14Figure 8: Computing Time of BASolver andMBlocking for
Formulas with Different Percentage of Backbone Variables
computing time of each satisfiable assignment in BASolver is less
after computing all the backbone variables.
Answer to RQ3 :
All the 5 solvers solves more formulas when there are more back-
bonevariablesintheformulas,thepercentageofthebackbone
variables does not influence the general performance of BA-
Solverdifferently. Computing all the backbone variables of
theformulas iscost-effectivefor theformulas,especially forthe
formulas with 100% percentage of backbone variables.
4.3 Limitations and Threats to Validity
Firstly,BASolverusestheMiniSATsolver[ 11]asablackboxto
solve the propositional formulas, and use the unsatisfiable reasons
returned by the MiniSAT solver. There are SAT solvers that are
fasterthanMiniSATandthereasonsreturnedbyMiniSATmaynot
bemostappropriateforALL-SATsolving.Also,sinceBC,NBCandBDDchangetheimplementationinsidetheMiniSATsolver,wecan
notcomparewiththeminthesecondandthirdexperiments.Sec-
ondly,differentblockingclausesinsidethesameALL-SATsolver
mayalsoinfluencetheperformanceoftheALL-SATsolver.Inthe
second and third experiments, we did not consider the order ofthe satisfiable partial assignment. It is possible that some block-
ing clauses may accelerate the following SAT solving significantly.
Moreover,weonlyusetheformulasfromtheindustrialtracksof
SATcompetitions.Theseformulasaregenerallymorechangeable
fortheALL-SATsolversasmoresolvingtimeisrequired.Although
thereare608formulas,thenumberofformulasthatsolvedbyat
least one of the solver is still less than 100, and most of them have
lessthan100satisfiableassignments.Wewouldliketochoosesomeformulaswithmorethan1000satisfiableassignmentsandtheaver-
agedifficultyfortheSATsolver.Wehopethatatleastoneofthe
solvers will solve these formulas completely, and then we can com-
pare the scalability among the solvers. Lastly, since only satisfiable
formulashavebackbonevariables, BASolverisnotapplicableto
over-constrained unsatisfiable formula. Although normally the in-
putofALL-SATSolversaresatisfiableformulas,itisalsopromisingtostudyontheover-constrainedformulaswiththetechniquesin
BASolver.
5 RELATED WORK
BASolverisablockingbasedALL-SATsolverandthegreedystrat-egyusedinittogeneratethepartialassignmentsisfromapproaches
proposed by Morgado and Marques-Silva [33] and Yu et al. [41] .
Jin and Somenz [ 21] proposed a blocking based ALL-SAT solver.
It finds all the satisfiable assignments for a generic Boolean cir-cuit using the blocking based framework. It can be directly used
inmanipulationsofthelogiccircuitssuchascomplementingand
flattening. Gebser [ 14] et al. applied similar techniques to the enu-
meration of Answer Set Programming.
MBlocking [ 41] is another blocking based ALL-SAT solver that
uses a greedy strategy named Minimal Blocking to generate the
minimalsetofblockingclauses.Forasolutionofthegivenformula,
MBlocking either uses the set of dominant variables based on the
clauses coverage or the set of decision variables and their corre-
sponding reason variables based on the search tree to generate the
blocking clauses. However, backbone variables may occur in the
minimal set ofblocking clauses and actuallycan be removed. The
short blocking clause used in BASolver is more efficient than that
usedinMBlocking,andthereducedlengthoftheblockingclauses
isakeyreasonthatBASolvercomputesmoreformulaswithless
computing time than MBlocking does.
Themaindifferencebetweenblockingbasedandnon-blocking
basedsolversistheuseofblockingclauses.Inordertoavoidfinding
thealreadyknownsolutionsoftheformula,blockingbasedtools
generate theblocking clauses ofeach known solutionand add the
blocking clauses back to the solver. In the non-blocking based All-
SAT solvers [ 1,25], backtrack techniques in the search tree are
usedtofindmoresolutionstothegivenformula.Oncea solution
is found, the non-blocking based tools choose a decision level and
backtrackthesearchtreetothatlevel.ADifferentdecisionismade
at that level and a new search path is generated based on the new
decision.
Jabbour [19] et al. proposed a non-blocking ALL-SAT solver. Af-
ter finding the first satisfiable assignment, it starts to run with the
restart configuration. When a conflict happens, the solver back-
trackstothepreviousdecisionlevelandpropagateswiththeconflict
reasons. Gebser [ 15] et al. proposes a new conflict-driven learning
algorithmthatusesanelaboratedbacktrackingscheme.Thescheme
records all the decision variables after finding some projected solu-
tions. In this way, the scheme can be maintained in the polynomial
spaceandonlyalinearnumberofsolution-excludingconstraints
areused.Grumberg[ 16]etal.introducedthenotionofsub-levels
and presented a sub-level based first UIP scheme that was compati-
blewiththenon-blockingapproaches.Gebser[ 14]etal.presents
alternative conflict resolution by means of non-chronological back-
tracking with a backtrack level limitation.
NBC[39]isanon-blockingbasedtoolthatbacktracksthesearch
tree to find every solution of the given formula. There are 4 differ-
ent backtrack strategies in NBC, and by using these strategies in
differentorders,thereare8differentstrategiesintotalinNBC.Eachstrategy performs differently on the formulas, therefore, the choiceofstrategiesisachallengeforNBC.ComparingtoNBC,BASolver
15onlyusesonestrategywhichistheshortblockingclausesobtained
by backbone variables to find every solution of the formula.
Formula caching technique associated with concise graph repre-
sentations of propositional theories is also applied in the ALL-SAT
solving field, including FBDD (Free Binary Decision Diagrams),
OBDD(OrderedBinaryDecisionDiagrams)andd-DNNF(determin-
istic Decomposable Negation Normal Form). Such a representation
is able to be efficiently constructedwhile executing an exhaustive
DPLLsearch.AconnectiontoAll-SATwasmentionedinHuangand
Darwiche[ 18].AnapplicationtoAll-SATsolvingitselfwasmoreex-
plicitlymentionedinTodaandTsuda[ 40]andacompilation-based
All-SAT solver has been released.
Besides formula caching, the dualization of the Boolean func-
tionscouldalsobeappliedtotheALL-SATsolving.GivenaDNF
(DisjunctionNormalForm)formulaofaBooleanfunction,theALL-
SATproblemsforthefunctiontransfertotheproblemofcomputing
the complete DNF formula for the dual function [12, 34, 38].
Anotherrelatedtopicis#SATcounting,whichcountsthetotal
numberof allthe satisfiableassignments. Someof theapproaches
in the #SAT field use similar blocking techniques that are also usedinALL-SATsolvers,butthestate-of-the-art#SATapproachisbased
on the universal hashing technique [ 32] which can not be applied
to the ALL-SAT solvers.
6 CONCLUSION
We propose an All-SAT solver BASolver which uses backbone
information to get shorter blocking clauses and achieve higher effi-
ciency. Comparing to other All-SAT solvers, BASolver removes
backbone variables from the blocking clauses. With shorter block-
ing clauses, the complexity of the following SAT solving decreases,
the number of SAT solving needed decreases and the efficiency of
All-SAT computing improves. Experiments show that BASolver is
an efficient ALL-SAT solver, the shorter blocking clauses used in it
leadstoareductionofthecomputingtime.Althoughcomputing
all the backbone variables requires additional computing time, but
it is cost-effective since the average computing time of each sat-isfiable assignment is reduced in BASolver. Also, all the solversin the experiments solve more formulas when the percentage of
thebackbonevariablesishigher,butthepercentagedoesnotaffect
BASolver differently.
ACKNOWLEDGMENTS
This research was partially supported by an industrial grant in
collaborationwithHUAWEITechnologiesCo.,LTD.GeguangPu
was partially supported by the NSFC Project No. 61632005 and the
NSFC Project. No. 61532019.
REFERENCES
[1]RobertoJBayardoJrandJosephDanielPehoushek.2000. Countingmodelsusing
connected components. In AAAI/IAAI. 157–162.
[2]DirkBeyerandMErkanKeremoglu.2011. CPACHECKER:atoolforconfigurable
software verification. In International Conference on Computer Aided Verification.
184–190.
[3]ArminBiere,AlessandroCimatti,EdmundMClarke,OferStrichman,andYun-
shan Zhu. 2003. Bounded Model Checking. Advances in Computers 58 (2003),
117–148.
[4]AaronRBradley.2012. UnderstandingIC3.In InternationalConferenceonTheory
and Applications of Satisfiability Testing. 1–14.[5]Jörg Brauer, Andy King, and Jael Kriener. 2011. Existential quantification as
incremental SAT. In International Conference on Computer Aided Verification.
Springer, 191–207.
[6]Cristian Cadar, Daniel Dunbar, and Dawson Engler. 2008. KLEE: unassisted
and automatic generation of high-coverage tests for complex systems programs.
InInternational Conference on Operating Systems Design and Implementation.
209–224.
[7]Edmund Clarke, Daniel Kroening, Natasha Sharygina, and Karen Yorav. 2004.
Predicate abstraction of ANSI-C programs using SAT. Formal Methods in System
Design25, 2-3 (2004), 105–127.
[8]Adnan Darwiche and Pierre Marquis. 2002. A knowledge compilation map.
Journal of Artificial Intelligence Research 17 (2002), 229–264.
[9]MartinDavis,GeorgeLogemann,andDonaldLoveland.1962.AMachineProgram
for Theorem-Proving. Commun. ACM 5, 7 (July 1962), 394–397.
[10]Martin Davis and Hilary Putnam. 1960. A Computing Procedure for Quantifica-
tion Theory. J. ACM7, 3 (July 1960), 201–215.
[11]NiklasEénandNiklasSörensson.2003. AnextensibleSAT-solver.In International
conference on theory and applications of satisfiability testing. Springer, 502–518.
[12]Andrew Gainer-Dewar and Paola Vera-Licona. 2017. The minimal hitting setgeneration problem: algorithms and computation. SIAM Journal on Discrete
Mathematics 31, 1 (2017), 63–100.
[13]Malay K Ganai, Aarti Gupta, and Pranav Ashar. 2004. Efficient SAT-based un-
bounded symbolic model checking using circuit cofactoring. In IEEE/ACM Inter-
nationalConferenceonComputerAidedDesign,2004.ICCAD-2004. IEEE,510–517.
[14]Martin Gebser, Benjamin Kaufmann, André Neumann, and Torsten Schaub. 2007.
Conflict-driven answer set enumeration. In International Conference on Logic
Programming and Nonmonotonic Reasoning. Springer, 136–148.
[15]Martin Gebser, Benjamin Kaufmann, and Torsten Schaub. 2009. Solution enu-
meration for projected Boolean search problems. In International Conference on
AI and OR Techniques in Constriant Programming for Combinatorial Optimization
Problems. Springer, 71–86.
[16]Orna Grumberg, Assaf Schuster, and Avi Yadgar. 2004. Memory efficient all-
solutionsSATsolveranditsapplicationforreachabilityanalysis.In International
Conference on Formal Methods in Computer-Aided Design. Springer, 275–289.
[17]Aarti Gupta, Zijiang Yang, Pranav Ashar, and Anubhav Gupta. 2000. SAT-based
image computation with application in reachability analysis. In International
Conference on Formal Methods in Computer-Aided Design. Springer, 391–408.
[18]Jinbo Huang and Adnan Darwiche. 2007. The language of search. Journal of
Artificial Intelligence Research 29 (2007), 191–219.
[19]Said Jabbour, Jerry Lonlac, Lakhdar Sais, and Yakoub Salhi. 2014. Extendingmodern SAT solvers for models enumeration. In Proceedings of the 2014 IEEE
15thInternationalConferenceonInformationReuseandIntegration(IEEEIRI2014).
IEEE, 803–810.
[20]Karthick Jayaraman, Nikolaj Bjørner, Geoff Outhred, and Charlie Kaufman. 2014.
Automatedanalysisanddebuggingofnetworkconnectivitypolicies. Microsoft
Research(2014), 1–11.
[21]HoonSangJinandFabioSomenzi.2005. Primeclausesforfastenumerationof
satisfyingassignmentstobooleancircuits.In Proceedings.42ndDesignAutomation
Conference, 2005. IEEE, 750–753.
[22]Daniel Kroening and Michael Tautschnig. 2014. CBMC - C Bounded Model
Checker. In International Conference on Tools and Algorithms for the Construction
and Analysis of Systems. 389–391.
[23]Shuvendu K Lahiri, Randal E Bryant, and Byron Cook. 2003. A symbolic ap-
proachtopredicateabstraction.In InternationalConferenceonComputerAided
Verification. Springer, 141–153.
[24]ShuvenduKLahiri,RobertNieuwenhuis,andAlbertOliveras.2006. SMTtech-
niques for fast predicate abstraction. In International Conference on Computer
Aided Verification. Springer, 424–437.
[25]Bin Li, Michael S Hsiao, and Shuo Sheng. 2004. A novel SAT all-solutions solver
forefficientpreimagecomputation.In ProceedingsDesign,AutomationandTest
in Europe Conference and Exhibition, Vol. 1. IEEE, 272–277.
[26]JianwenLi,KristinY.Rozier,GeguangPu,YuelingZhang,andMosheY.Vardi.
2019. SAT-Based Explicit LTLf Satisfiability Checking. In The Thirty-Third AAAI
Conference on Artificial Intelligence. 2946–2953.
[27]Jianwen Li, Shufang Zhu, Yueling Zhang, Geguang Pu, and Moshe Y. Vardi. 2017.
Safety model checking with complementary approximations. In 2017 IEEE/ACM
International Conference on Computer-Aided Design. 95–100.
[28]Nuno P Lopes, Nikolaj Bjørner, Patrice Godefroid, Karthick Jayaraman, and
GeorgeVarghese.2015. Checkingbeliefsindynamicnetworks.In 12th{USENIX}
Symposium on Networked Systems Design and Implementation ( {NSDI}15). 499–
512.
[29]NunoPLopes,NikolajBjørner,PatriceGodefroid,andGeorgeVarghese.2013.
Network verification in the light of program verification. MSR, Rep (2013).
[30]RupakMajumdar,SaiDeepTetali,andZilongWang.2014. Kuai:Amodelcheckerforsoftware-definednetworks.In 2014FormalMethodsinComputer-AidedDesign
(FMCAD). IEEE, 163–170.
[31]Ken LMcMillan. 2002. Applying SATmethods inunboundedsymbolic model
checking.In InternationalConferenceonComputerAidedVerification.Springer,
16250–264.
[32]KuldeepSMeel,MosheYVardi,SupratikChakraborty,DanielJFremont,SanjitA
Seshia,DrorFried,AlexanderIvrii,andSharadMalik.2016. Constrainedsamplingandcounting:UniversalhashingmeetsSATsolving.In Workshopsatthethirtieth
AAAI conference on artificial intelligence.
[33]António Morgado and Joao Marques-Silva. 2005. Good learning and implicit
model enumeration. In 17th IEEE International Conference on Tools with Artificial
Intelligence. IEEE, 6–pp.
[34]KeisukeMurakamiandTakeakiUno.2013.Efficientalgorithmsfordualizinglarge-
scalehypergraphs.In 2013Proceedingsof theFifteenthWorkshop onAlgorithm
Engineering and Experiments (ALENEX). SIAM, 1–13.
[35]Junaid Qadir and Osman Hasan. 2014. Applying formal methods to networking:
theory,techniques,andapplications. IEEECommunicationsSurveys&Tutorials
17, 1 (2014), 256–291.
[36]SamirSapra,MichaelTheobald,andEdmundClarke.2003. SAT-basedalgorithms
for logic minimization. In Proceedings 21st International Conference on Computer
Design. IEEE, 510–517.
[37]ShuoShengandMichaelHsiao.2003. Efficientpreimagecomputationusinga
novel success-driven atpg. In 2003 Design, Automation and Test in Europe Confer-
ence and Exhibition. IEEE, 822–827.[38]Takahisa Toda. 2013. Hypergraph transversal computation with binary decision
diagrams. In International Symposium on Experimental Algorithms . Springer, 91–
102.
[39]Takahisa Toda and Takehide Soh. 2016. Implementing efficient all solutions SAT
solvers.Journal of Experimental Algorithmics (JEA) 21 (2016), 1–12.
[40]Takahisa Toda and Koji Tsuda. 2015. BDD construction for all solutions SAT and
efficient caching mechanism. In Proceedings of the 30th Annual ACM Symposium
on Applied Computing. 1880–1886.
[41]Yinlei Yu, Pramod Subramanyan, Nestan Tsiskaridze, and Sharad Malik. 2014.
All-SAT using minimal blocking clauses. In 2014 27th International Conference on
VLSIDesignand201413thInternationalConferenceonEmbeddedSystems.IEEE,
86–91.
[42]Shuyuan Zhang, Sharad Malik, and Rick McGeer. 2012. Verification of computer
switching networks: An overview. In International Symposium on Automated
Technology for Verification and Analysis. Springer, 1–16.
[43]YuelingZhang,MinZhang,andGeguangPu.2020. Optimizingbackbonefiltering.
Sci. Comput. Program. 187 (2020), 102374.
17