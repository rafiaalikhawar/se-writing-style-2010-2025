Enhanced Compiler Bug Isolation via Memoized Search
Junjie Chenâˆ—â€ 
College of Intelligence and
Computing, TianjinUniversity
China, Tianjin
junjiechen@tju.edu.cnHaoyang Maâˆ—
College of Intelligence and
Computing, TianjinUniversity
China, Tianjin
haoyang_9804@tju.edu.cnLingming Zhang
University of Illinois at
Urbana-Champaign
USA, IL,Urbana
lingming@illinois.edu
ABSTRACT
Compiler bugs can be disastrous since they could affect all the soft-
waresystemsbuiltonthebuggycompilers.Meanwhile,diagnosing
compiler bugs is extremely challenging since usually limited de-
bugginginformationisavailableandalargenumberofcompiler
filescanbesuspicious.Morespecifically,whencompilingagiven
bug-triggering test program, hundreds of compiler files are usu-ally involved, and can all be treated as suspicious buggy files. Tofacilitate compiler debugging, in this paper we propose the first
reinforcementcompiler bugisolationapproach viastructuralmu-
tation,called RecBi. For a given bug-triggering test program, RecBi
first augments traditional local mutation operators with structural
ones to transform it into a set of passing test programs. Sincenot all the passing test programs can help isolate compiler bugs
effectively, RecBi further leverages reinforcement learning to intel-
ligentlyguidetheprocessofpassingtestprogramgeneration.Then,
RecBiranksall thesuspiciousfilesbyanalyzingthe compilerexe-
cution traces of the generated passing test programs and the given
failingtestprogramfollowingthepracticeofcompilerbugisolation.
Theexperimentalresultson120realbugsfromtwomostpopularC
open-sourcecompilers,i.e.,GCCandLLVM,showthatRecBiisabletoisolateabout23%/58%/78%bugswithinTop-1/Top-5/Top-10com-
pilerfiles,andsignificantlyoutperformsthestate-of-the-artcom-
piler bug isolation approach by improving 92.86%/55.56%/25.68%
isolationeffectivenessin terms of Top-1/Top-5/Top-10 results.
CCSCONCEPTS
â€¢Software and its engineering â†’Software testing and de-
bugging;Compilers ;â€¢Theory of computation â†’Reinforce-
ment learning .
KEYWORDS
CompilerBugIsolation,FaultLocalization,ReinforcementLearning
âˆ—Bothauthorscontributed equally to this paper.
â€ JunjieChenis the corresponding author.
Permissionto make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACM
mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ASEâ€™20,September 21â€“25, 2020, Virtual Event, Australia
Â© 2020Association for Computing Machinery.
ACM ISBN 978-1-4503-6768-4/20/09...$15.00
https://doi.org/10.1145/3324884.3416570ACM Reference Format:
Junjie Chen, Haoyang Ma, and Lingming Zhang. 2020. Enhanced Com-
pilerBugIsolationviaMemoizedSearch.In 35thIEEE/ACMInternational
Conference on Automated Software Engineering (ASE â€™20), September 21â€“
25, 2020, Virtual Event, Australia. ACM, New York, NY, USA, 12 pages.
https://doi.org/10.1145/3324884.3416570
1 INTRODUCTION
Compilers are one of themost fundamental software systems since
almost all software systems (ranging from operating systems, web
browsers, to script code written by end-users) are compiled by
them. Although dedicated efforts have been devoted to ensuring
their quality, compilers are still error-prone due to their extremely
large-scaleandcomplicatedcodebases[ 17,18,21,58,70].Inpractice,
compilerbugsareveryharmful,andcanpotentiallyaffectallthe
software systems compiled by the buggy compilers. Therefore, it is
essentialto detect, isolate, and fix all possible compiler bugs.
In the literature, many approaches have been proposed to au-
tomaticallydetectcompilerbugs[ 12â€“14,18,19,28,58,66,70,75],
but there is limited research efforts dedicated to automated debug-
ging of compiler bugs, such as bug isolation and fixing. That is,
compilerbugisolationandfixingarestillarathertediousandtime-
consumingprocessformoderncompilers.Inparticular,compiler
bugisolationisamorefundamentalproblemsinceitalsodirectly
helpswitheffectivecompilerbugfixing.Althoughmanyautomated
bug localization approaches (such as spectrum-based [ 7,27,73],
slicing-based[ 69],mutation-based[ 34,45,48,51,74],andtherecent
program-repair-based [ 9,46] approaches)have beenproposed for
commonsoftwaresystems,theseexistingapproachescanhardly
isolate compiler bugs due to either extremely high costs or pooreffectiveness; please refer to the extensive discussion in a recent
work [16] for more details.
To facilitate compiler bug isolation, Chen et al. [ 16] proposed
the first approach, named DiWi, which transforms the problemofcompilerbugisolationtotheproblemofpassingtestprogramgeneration. More specifically, given a failing test program, DiWi
first generates a set of passing test programs by traditional local
mutationoperators(whichchangeminimalprogramelementssuch
as modifiers and constants), and then leverages existing bug local-
ization techniques [ 6,36] to identify the compiler buggy files by
comparingtheexecutiontracesbetweenthegeneratedpassingpro-
grams andthe givenfailing testprogram. Althoughthe generated
passing test programs via DiWi has been demonstrated to perform
better thanbothdeveloper-written test programsand the testpro-
grams generated by the widely-used compiler fuzzing technique
(i.e., Csmith [ 70]) for compiler bug isolation [ 16], DiWi still suffers
fromtheeffectivenessissue. Forexample,asdemonstratedbythe
UI*&&&"$.*OUFSOBUJPOBM$POGFSFODFPO"VUPNBUFE4PGUXBSF&OHJOFFSJOH	"4&
ASE â€™20, September 21â€“25, 2020, Virtual Event, Australia Junjie Chen, Haoyang Ma, and Lingming Zhang
existingwork[ 16]andourstudy(tobepresentedinSection4.5),
developersusingDiWistillneedtocheckabout15innocentfiles
beforefindingthereallybuggyoneonaverage;about62.5%studied
bugs cannot be successfully isolated after checking 5 most sus-
picious files recommended by DiWi (please note that in practice,
most developers tend to abort the automated debugging tools if
they cannot localize buggy elements within Top-5 positions [38]).
To further advance state-of-the-art compiler bug isolation, in
this paper, we propose an enhanced compiler bug isolation ap-
proachvia memoized search andstructural mutation,called RecBi
(Reinforcement compilerBugisolation). More specifically, since
compiler bugs tend to occur in the components of compiler opti-
mizationsthattendtodependontestprogramstructure,foragiven
compiler bug with a failing test program, RecBi first augments the
traditional localmutationoperatorsusedbyDiWiwith structural
mutationoperators(whichchangethetestprogramstructurebyinserting some control-flow-alerting statements such as branch
andloopstatements)toeffectivelygeneratesimilartestprograms
thatcanflipthecompilerexecutionresults(i.e.,from failingto
passing). This is because traditional local mutation operators usu-
ally have small influence on program structure due to its minor
modification, while structural mutation operators can augment the
ability of changing program structure by effectively altering the
control-flow of test programs and in the meanwhile optimizations
areofteninvolvedincompilerbugsandstructuralmutationisgood
atskippingthebuggyoptimizations.However,notallthegenerated
passing test programs can facilitate isolating compiler bugs [ 16],
and thus casually or simply heuristically performing mutations on
the given failing test program may not be effective. Thus, RecBi
further incorporates reinforcement learning [ 37] (a kind of memo-
ized search), which can effectively learn both historical and future
knowledge,tointelligentlyguidehowtoconductmutationinorder
to generate a set of more effective passing test programs during
agivenperiod.Finally,similartotheexistingwork[ 7,16],RecBi
ranksallthesuspiciousfilesaccordingtotheirsuspiciousscoresby
comparing the compiler execution traces between the generated
passing test programs and the given failing program. In a word,the novelties of RecBi are twofold: 1) it opens a new dimension
for compiler bug isolation via structural mutation ;2 )it leverages
reinforcement learning for more intelligent compiler bug isolation.
ToevaluatetheeffectivenessofRecBi,weconductedanextensive
studybasedon120realcompilerbugsfromGCC[ 2]andLLVM[ 4],
whichare the most widely-used C compilers in both industry and
academia[ 16,41,58,70].OurexperimentalresultsshowthatRecBi
isabletoisolate27,70,93,107bugs(outof120compilerbugs)within
Top-1, Top-5, Top-10, and Top-20 files, respectively. That is, about
23%, 58%, 78%, and 89% bugs can be isolated successfully within
Top-1, Top-5, Top-10, and Top-20 files through RecBi, respectively.
In particular, RecBi substantially outperforms the state-of-the-art
approachDiWi.Forexample,theimprovementsofRecBioverDiWi
are up to 92.86%/55.56% in terms of Top-1/Top-5 results, 45.55% in
terms of MFR (Mean First Rank, measuring the effectiveness in
detectingthe first buggyfile for eachbug),and 44.62% in terms of
MAR(MeanAverageRank,measuringtheeffectivenessindetecting
all the buggy files for each bug). Furthermore, we investigated the
contributionsofbothmajorcomponentsinRecBi(i.e.,structural1intprintf( const char âˆ— ,...);
2inta,b=1;
3intmain(){
4inti;
5for(i=0;i<56;i++)
6 for(;a;aâˆ’âˆ’)
7;
8intâˆ—c=&b;
9if(âˆ—c)
10 âˆ—c=1%( unsigned int )âˆ—c|5;
11 printf("%d\n",b);12 return 0;
13 }
(a) Failing Program1intprintf( const char âˆ— ,...);
2inta,b=1;
3intmain(){
4inti;
5for(i=0;i<56;i++)
6 for(;a;aâˆ’âˆ’)
7;8intâˆ—c=&b;
9 while(aâ€“â€“)
10 if(âˆ—c)
11 âˆ—c=1%( unsigned int )âˆ—c|5;
12 printf("%d\n",b);13 return 0;
14 }
(b) Passing Program
Figure 1: GCC Bug 64682
mutation and reinforcement learning for passing test program gen-
eration), as well as the impacts of different RecBi configurations.
To sum up, this paper makes the following main contributions:
â€¢This work opens a new dimension of compiler bug isolation
via structural mutation, i.e., leveraging carefully designed
structural mutation operators for generating passing test
programs to boost compiler bug isolation.
â€¢This work brings reinforcement learning to the compiler
bug isolation area for the first time, i.e., leveraging state-
of-the-artreinforcementlearningtointelligentlyguidethe
structural-mutation-based compiler bug isolation process.
â€¢Theproposedtechniquehasbeenimplementedasapracti-
cal compiler bug isolation system, named RecBi, based on
mature tools and libraries, i.e., Clang Libtooling library [ 1],
Gcov [3], and PyTorch [5].
â€¢This work conducts an extensive study based on 120 real
compiler bugs from two most widely-used C compilers, i.e.,
GCC and LLVM, to evaluate the effectiveness of RecBi. The
results reveal the effectiveness of RecBi (significantly out-performing the state-of-the-art DiWi), the contribution of
eachmajorcomponentinRecBi,andtheimpactsofdifferent
RecBi configurations.
2 BACKGROUND
2.1 Test Program Mutation for Compiler Bug
Isolation
To solve the problem of compiler bug isolation, Chen et al. [ 16]
transformsthisproblemtotheproblemofpassingtestprogramgen-
eration.Accordingtotheideaofspectrum-basedbuglocalization
(alsocalledSBFL)[ 7,67],allthecompilerfilestouchedbyagiven
failingtestprogramduringcompilationaresuspectsandpassing
test programs are helpful to reduce the suspicion of innocent files.
If a passing test program has similar execution trace (except the
buggy files) with the given failing test program, the buggy filesare more likely to be isolated by comparing the execution tracebetween the passing test program and the given failing test pro-
gram.Therefore,DiWidesignsthreecategoriesoflocalmutation
operators to produce such similar passing test programs by chang-
ing three minimal program elements (i.e., variables, constants, and
operators) of the given failing test program.
Although these traditional local mutation operators in DiWi
cangeneratesomepassingtestprogramsasdemonstratedbythe
Enhanced Compiler Bug Isolation via Memoized Search ASE â€™20, September 21â€“25, 2020, Virtual Event, Australia
existing work [ 16], their effectiveness actually is restricted. This is
becausecompilerbugstendtooccurinthecomponentsofcompiler
optimizations, which tend to depend on test program structure;
onthecontrary,traditionallocalmutationoperatorsusuallyhave
small influence on program structure due to their minor modifi-
cationandthuscouldomitmanyeffectivepassingtestprograms.
Therefore,incorporatingnovelmutationoperatorsthatcaneffec-
tively altering program structure is necessary for compiler bug
isolation. In this work, we introduce the notion of structural mu-
tation,whichaugmentstheprogram-structure-alteringabilityby
inserting some control-flow-alerting statements (such as branch
and loop statements).
WeuseFigure1toillustratetheeffectivenessofstructuralmuta-
tion. Figure 1a shows a failing test program, which triggers a GCC
bug (ID: 64682) when using -O2and above of GCC revision 219832
tocompileit.Thisbugliesinthefile combine.c andtherootcause
isthatan isns(theRTLrepresentationofthecodeforafunction
in GCC) sets a wrong notefor a pseudo register after the correct
notehasbeendistributed.Whenusingtraditionallocalmutation
in DiWi to isolate this bug, during the given period (i.e., one hour),
79 passingprograms are generated andthe buggy file isranked at
the 30thposition. However, when introducing structural mutation,
there are 20 passing programs generated by structural mutation.
Figure1bshowsoneofthe20passingprograms.Byinsertingthe
statement while(a--) in Line 9, the buggy optimization can be
effectively avoided, leading to passing execution. With the help of
structuralmutation,the buggyfile is ranked at the7thposition.
2.2 ReinforcementLearning
To more efficiently generate effective passing test programs, we
aimtoincorporatereinforcementlearningtoguidetheprocessof
passing test program generation, and thus we briefly introduce
somebackground of reinforcement learning.
Reinforcement learning aims to learn how an agent should take
actionsinanenvironmentinordertomaximizecumulativereward
inalongrun[ 37,61].Anagenthasmanystatesandactions,and
duringthelearningprocess,itperformsanactionatastate,then
measurestherewardobtainedbythisaction,andmovestothenext
state. Through such a process, the agent gradually learns to select
a better action at the next state in order to obtain more reward. In
general, reinforcement learning can be divided into two categories:
value-based algorithms (e.g., Deep Q Learning algorithm [ 47]) and
policy-basedalgorithms(e.g.,PolicyGradientsalgorithm[ 60]).The
former is a deterministic strategy that approximates the optimal
valuefunctiontoselectthebestactionateachstateandtendsto
be efficient and steady, while the latter is a probabilistic strategythat learns the probability distribution (i.e., policy) of actions to
obtainthemostreward andtends tofit continuousandstochastic
environmentsand have faster convergence.
Withthedevelopmentofreinforcementlearning,thealgorithms
mergingbothvalue-basedandpolicy-basedstrategies,calledActor-
Critic algorithms (AC), are proposed [ 62]. In AC, the actor controls
howtheagentbehavesbylearningthebestpolicyviaanactorneu-
ralnetwork(ANN),whilethecriticpredictstherewardachievedby the action by calculating the value function via a critic neu-
ral network (CNN). Subsequently, the improved versions of ACdeveloper-provided 
test programs
ingredient pool
seed test program
 mutated test program










	

ppp
ggg
gg
Figure 2: Overview of Structural Mutation
are proposed, i.e., Advantage Actor-Critic (A2C) [ 63] and Asyn-
chronousAdvantageActor-Critic(A3C)[ 63].Insteadofthevalue
function,A2Clearnstheadvantagevaluefunctionbyevaluating
both how good the action is and how much better it can be (which
incorporatesfutureknowledge),whichcanreducehighvariances
of neural networks. A3C further incorporates the asynchronous
mechanism to improve the learning efficiency. In this work, we
utilize the framework of A2C to solve the problem of compiler bug
isolation, since it is both effective (compared with AC) and suitable
to single-thread and multi-thread systems (compared with A3C).
3 APPROACH
In this section, we present our reinforcement compiler bug iso-lation approach via structural mutation, named
RecBi. Given a
compiler bug with a failing test program, RecBi first generates a
set of effective passing test programs by mutating the given failing
testprogramthroughareinforcementlearningbasedmutationpro-
cess. Second, based on the given failing test program and the set
ofgeneratedpassingtestprograms,RecBileveragesoff-the-shelf
SBFLtoidentifythecompilerbuggyfiles.Themaincontribution
of RecBi lies in the first step. During the process of passing test
program generation, besides changing minimal program elements
viatraditionallocalmutation,RecBifurtherincorporatesstructural
mutation to change the structure of the given failing test program,
whichcould enlargethemutationspace toincludemore effective
passing test programs. However, not all the passing test programs
can facilitate to isolate compiler bugs as demonstrated by the exist-
ing work [ 16], and thus casually conducting mutation on the given
failing test program may not be effective. Therefore, RecBi further
incorporates reinforcement learning (which could effectively learnboth historical and future knowledge) to learn how to intelligentlyconduct mutation on the given failing test program so that a set of
more effective passing test programs can be generated.
In the following, we introduce our structural mutation in Sec-
tion3.1andpresentourreinforcement-learningbasedtestprogram
generation in Section 3.2. Although we do not propose any new
SBFLformulatocalculatethesuspiciousscoreofeachcompilerfileinthesecondstepofRecBi,westillbrieflyintroducetheapplication
of SBFL in RecBi in Section 3.3 to make the paper self-contained.
ASE â€™20, September 21â€“25, 2020, Virtual Event, Australia Junjie Chen, Haoyang Ma, and Lingming Zhang
1volatile
2inta,b,c=2;
3unsigned d;
4intmain(){
5inte=âˆ’32;
6d = âˆ’31;
7for(;d>2;d++)
8 for(e++;;b âˆ’âˆ’)
9 if(c)
10 break;
11 e&&a ;
12 return 0;
13 }
(a) Failing1volatile
2inta,b,c=2;
3unsigned d;
4intmain(){
5inte=âˆ’32;
6 âŠ²d=âˆ’31;
7 âŠ²for(;d>2;d++)
8 âŠ²for(e++;;b âˆ’âˆ’)
9 âŠ²if(c)
10 break;
11 âŠ²e&&a;
12 return 0;
13 }
(b) Locations1volatile
2inta,b,c=2;
3unsigned d;
4intmain(){
5inte=âˆ’32;
6 if(((long)(a-a))<1)
7d = âˆ’31;
8for(;d>2;d++)
9 for(e++;;b âˆ’âˆ’)
10 if(c)
11 break;
12 e&&a ;13 return 0;
14 }
(c) Mutant
Figure 3: Example of Structural Mutation
3.1 StructuralMutation
Thegoal ofmutationisto flipthecompilerexecution result(from
failing topassing) by transforming a given failing test program.
Aspresentedinpriorwork[ 16,18,19,58],mostofcompilerbugs
occur in the components of compiler optimizations, while the trig-
gering of compiler optimizationstends to depend on the structure
of test programs. Therefore, transforming the structure of a given
failing test program is helpful to generate effective passing test
programs. However, the existing local mutation operators in DiWi
usually have small influence on program structure due to its minor
modification,and thuswe furtherexplore structuralmutation in
RecBi. More specifically, we design four structural mutation op-
erators,whichinsertfourdifferenttypesofstatementstoagiven
failing test program respectively, to change the control-flow of the
failingtestprogram.Thefourtypesofinsertedstatementsare1)
branch statements ,2)loop statements ,3)function calls ,and
4)gotostatements , since they are recognized to be effective to
changethe control-flow of a program [23, 24, 42].
Exceptgotostatements,theother three types of statements re-
quire additional ingredients (i.e., conditions in a branch or loop
statement,aswellasthecalledfunctionanditsparametersinafunc-
tion call) to complete insertion. However, it could be inefficient to
casually construct these ingredients. As demonstrated by the exist-
ing work [ 16], although the state-of-the-art compiler bug isolation
approach DiWi outperforms the approach using the developer-
providedtestprogramstoisolatecompilerbugs,thelatterisable
to perform no worse than the former in some cases. Therefore,it may be promising to adapt the ingredients already within the
developer-providedtestprogramsforourstructuralmutation.In
thisway,theuniquevalueofthedeveloper-providedtestprograms
embodied in the existing work [16] can be incorporated by RecBi.
Figure2showstheoverviewofourstructuralmutation,which
consists of three steps. First, RecBi extracts all the branch condi-tions, loop conditions, declared functions and the corresponding
functioncalls,inthedeveloper-providedtestprogramsforthecom-
piler under test, as an ingredient pool. Second, RecBi randomlyselects an ingredient from the ingredient pool according to thetype of the statement to be inserted, and randomly selects an in-
sertablelocationintheseedtestprogram.Itwouldproduceinvalid
test programs or fake passing test programs [ 16] (i.e., the gener-
atedpassingtestprogramsarenotreallypassingandjustremoveTable 1: Summary of mutation operators in RecBi
IDDescription
1Inserta branch (i.e., if) statement;
2Inserta loop (i.e., while) statement;
3Inserta function call;
4Insertagotostatement;
5Insert/remove a qualifier (i.e., volatile, const, and restrict);
6Insert/remove a modifier (i.e., long,short,signed, and
unsigned);
7Replacea variable with another valid one
8Replacea constant with another valid one;
9Replace/remove an unary operator;
10Replacea binary operator with another valid one.
thetestoracles)when insertingastatementtoanimproper loca-tion. There are three types of non-insertable locations in RecBi:
1) the locations outside functions, 2) the locations before decla-
rations for the sake of maintaining the identifier scope, and 3)the locations before the statements used as test oracles (such as
printf/__builtin_abort/return statements). Third, RecBi per-
formsinsertion,andthenconductsrefactoringfornewvariables
in the selected ingredient, i.e., renaming the new variable to those
withintheseedtestprogramwithcompatibletypes,tomakethe
mutated test program valid. Figure 3 shows an illustrative example
forstructuralmutation,whereFigure3aisafailingtestprogram,
Figure 3b identifies all the insertable locations (denoted as âŠ²) in the
failing test program, and Figure 3c is a generated passing test pro-
gramvia ourstructuralmutation(by inserting abranch statement).
LocalMutationOperators. Besidesthesestructuralmutationop-
erators,RecBialsoincorporatesthetraditionallocalmutationoper-
ators targeting the minimal program elements, which have been
studiedbytheexistingworkforcompilerbugisolation[ 16].Therea-
son is that 1) the generated test programs via these local mutation
operators have been demonstrated to outperform the developer-provided test programs and the test programs generated via the
widely-usedcompilerfuzzingtechnique(i.e.,Csmith[ 70])[16],and
2) for the compiler bugs in the front-end component (although the
number of this type of compiler bugs is rare), local mutation could
be very useful. Therefore, RecBi has 10 mutation operators in total,
which are summarized in Table 1.
TestOracles. After mutation, it is also required to check whether
thegeneratedtestprogramispassingorstillfailing[ 15,16].Accord-
ing to the types of compiler bugs (i.e., crash bugs and wrong-code
bugs) [16,20,58], RecBi considers two types of test oracles ac-
cordingly. Regarding crash bugs (i.e., the compiler crashes whenusing some compilation options to compile a test program), theusedtestoracleiswhetherthecompilerstillcrasheswhenusing
the same compilation options to compile a generated test program.
Regarding wrong-code bugs (i.e., the compiler mis-compiles a test
programwithoutanyfailuremessages,causingthetestprogram
tohaveinconsistentexecutionresultunderdifferentcompilation
options),theusedtestoracleiswhetherageneratedtestprogram
still produces inconsistent execution results under the compilation
optionsproducing inconsistencies before.
Enhanced Compiler Bug Isolation via Memoized Search ASE â€™20, September 21â€“25, 2020, Virtual Event, Australia
3.2 Test Program Generation via
ReinforcementLearning
Sincenotallthepassingtestprogramsarehelpfultoisolatecom-
piler bugs as demonstrated by the existing work [ 16], it could be
ineffective to randomly perform mutation on a given failing test
program. In particular, different compiler bugs have different char-
acteristicsandrootcauses,andthustheeffectsofthesemutation
operators on different compiler bugs can be different. Therefore,
itisnecessaryforeachspecificcompilerbugtolearntheeffectof
each mutation operator in order to generate more effective passing
test programs efficiently during the given time period.
As presented in Section 2.2, reinforcement learning is a well-
recognized strategy to guide an agent to behave better in an envi-
ronmentsoastoobtainthemostreward[ 37],whichhighlymatches
ourproblem,i.e.,learningtogeneratemoreeffectivepassingtest
programs.Therefore,toachieveourgoal,weleveragethepowerof
reinforcement learning in RecBi, where reward refer to the quality
ofgeneratedpassingtestprograms(tobeexplainedinSection3.2.1).
Morespecifically,anagenthasmanystatesandactions,andduring
the iterative process of reinforcement learning, the agent learns
moreandbetterbyconductinganactionatastateandthenmeasur-ingtherewardofthisaction.InRecBi,a statereferstoastateofthe
set of mutation operators, i.e., the number of times that each muta-
tion operator has been selected to generate passing test programs,
while an actionrefers to selecting and then applying a mutation
operator to a given failing test program.
Here,RecBiadoptstheframeworkofA2C[ 63]tolearntheeffects
of these mutation operators in order to guide the generation ofeffective passing test programs for a given compiler bug. This isbecause it has been demonstrated to be effective and efficient in
practiceandperformstablywithlowvariance[ 29,56,57].Moreover,
A2CconvergesfasterthanthetraditionalACalgorithm.Figure4
illustratestheoverviewofthereinforcementlearningbasedstrategy
inRecBi.FollowingtheframeworkofA2C,RecBiconstructstwo
neuralnetworks,i.e.,ANN(ActorNeuralNetwork)andCNN(Critic
Neural Network). ANN aims to predict the probability distribution
ofactionsbasedon historicalknowledge andthenchooseanactionto
beperformed,whileCNNaimstopredictthepotentialrewardtobe
accumulatedfromthecurrentstatetoafuturestateafterperforming
the selected action, which incorporates future knowledge. Based
onthepredictedpotentialrewardand theactualrewardobtained
by performing the selected action, RecBi adopts an advantage loss
function(tobeintroducedinSection3.2.2)toupdatebothANNand
CNN in order to make them learn more and better. In particular,
following the practice of A2C [ 62,63], both ANN and CNN in
RecBi contain only one hidden layer in order to be light-weightand converge fast. The process is repeated until the terminating
conditionisreached,anditsoutputisasetofgeneratedeffective
passing test programs. In the following, we introduce the actual
rewardmeasurement(Section3.2.1)andtheadvantagelossfunction
(Section3.2.2) in detail.
3.2.1 ActualRewardMeasurement. Animportantaspecttothesuc-
cessoftheA2Cbasedapproachishowtomeasuretheactualrewardafterapplyingamutationoperatortothegivenfailingtestprogram.
Inspired by the existing work [ 16], a set of effective passing test
programs should satisfy both similarity and diversity criteria. The
ANN action

passing test 
program


actual reward	
potential reward

advantageloss function

CNN
state


Figure 4: Overview of Our Reinforcement Learning based
Test Program Generation Strategy
former refers to that each passing test program should share a sim-
ilarcompilerexecutiontracewiththegivenfailingtestprogram.
In this way, according to the idea of SBFL, the suspiciousness of
morebuggy-freefilescanbereduced.Thelatterreferstothatdiffer-
ent passing test programs should have diverse compiler execution
traces between each other in order to reduce the suspiciousness
of different buggy-free files. In this way, aggregating a set of pass-
ing mutated programs is helpful to effectively isolate the really
buggyfilesby avoiding bias. Given a set of generated passing test
programs denoted as ğ‘ƒ={ğ‘1,ğ‘2,...,ğ‘ ğ‘›}and the failing test pro-
gramdenotedas ğ‘“,wedefinethesimilarityanddiversitymetrics
achieved by the set of passing test programs on average as shown
in Formulae 1 and 2 respectively:
ğ‘ ğ‘–ğ‘š=/summationtext.1ğ‘›
ğ‘–=1(1âˆ’ğ‘‘ğ‘–ğ‘ ğ‘¡(ğ‘ğ‘–,ğ‘“))
ğ‘›(1)
ğ‘‘ğ‘–ğ‘£=/summationtext.1ğ‘›âˆ’1
ğ‘–=1/summationtext.1ğ‘›
ğ‘—=ğ‘–+1ğ‘‘ğ‘–ğ‘ ğ‘¡(ğ‘ğ‘–,ğ‘ğ‘—)
ğ‘›(ğ‘›âˆ’1)
2(2)
dist(a,b)=1âˆ’Covaâˆ©Covb
CovaâˆªCovb(3)
wheredist(,)isthecoveragedistancebetweentwo testprograms
and is measured by Jaccard Distance; Cov ğ‘andCov ğ‘represent the
set of statements in the compiler covered by test programs ğ‘andğ‘,
respectively; ğ‘›is the number of generated passing test programs.
Atatimestepdenotedas ğ‘¡,aftergeneratingapassingtestpro-
gram, RecBi measures the quality of the current set of passing test
programs by linearly combining the achieved similarity and diver-
sityasshowninFormula4.Then,RecBidetermineswhetherornot
to accept the generated passing test program according to whether
itcanimprovethe qualityofthepassingprogramsetcomparedwith
thelasttimestepdenotedas ğ‘¡-1.Formula5presentsthecalculation
of the improved quality compared with the last time step.
ğ‘„ğ‘¡=ğ‘›(ğ›¼Â·ğ‘‘ğ‘–ğ‘£ğ‘¡+(1âˆ’ğ›¼)Â·ğ‘ ğ‘–ğ‘š ğ‘¡) (4)
Î”ğ‘„ğ‘¡=ğ‘„ğ‘¡âˆ’ğ‘„ğ‘¡âˆ’1
=(ğ‘›âˆ’1)(ğ›¼Â·Î”ğ‘‘ğ‘–ğ‘£+(1âˆ’ğ›¼)Â·Î”ğ‘ ğ‘–ğ‘š)
+(ğ›¼Â·ğ‘‘ğ‘–ğ‘£ğ‘¡+(1âˆ’ğ›¼)Â·ğ‘ ğ‘–ğ‘š ğ‘¡),
Î”ğ‘‘ğ‘–ğ‘£ğ‘¡=ğ‘‘ğ‘–ğ‘£ğ‘¡âˆ’ğ‘‘ğ‘–ğ‘£ğ‘¡âˆ’1,Î”ğ‘ ğ‘–ğ‘š ğ‘¡=ğ‘ ğ‘–ğ‘š ğ‘¡âˆ’ğ‘ ğ‘–ğ‘š ğ‘¡âˆ’1(5)
whereğ›¼is the coefficient for the linear combination between di-
versityandsimilarity.Formula4alsohasacoefficient ğ‘›(thesize
ASE â€™20, September 21â€“25, 2020, Virtual Event, Australia Junjie Chen, Haoyang Ma, and Lingming Zhang
of the current passing test program set) due to the following in-
tuitionâ€“whenthesizeofthepassingtestprogramsetissmall,it
ispreferableforRecBitoacceptanewpassingtestprogrameven
though it may decrease the diversity and similarity (because when
ğ‘›is smaller, the actual delta is less important); but with the size
ofthepassingtestprogramsetincreasing,wehavelessinterests
to generate such low-quality passing test programs with RecBi.
Therefore, we incorporate ğ‘›to reflect such intuition in RecBi.
However, at each state only one mutation operator is selected
to generate a passing test program, and a mutation operator could
perform extremely differently due to various mutated locations,
which could lead to slow convergence for A2C. Moreover, it means
thattheimprovedqualityofthepassingprogramsetinthecurrenttimestepcannotpreciselyreflecttheeffectoftheselectedmutation
operator.Therefore,toreducetheinfluenceofvariousperformance
of a mutation operator, RecBi combines the improved quality at
thecurrenttimestepandthehistoricallyimprovedqualityby the
current mutation operator as the actual reward obtained at the
current timestep, instead of directly using the improved quality:
ğ‘…ğ‘’ğ‘¤ğ‘ğ‘Ÿğ‘‘ ğ‘¡=/summationtext.1ğ‘¡
ğ‘–=1Î”ğ‘„ğ‘–
ğ‘‡(ğ‘šğ‘–)(6)
where, Î”ğ‘„ğ‘–=0 if the selected mutation operator is not ğ‘šğ‘–at the
ğ‘–thtime step, otherwise Î”ğ‘„ğ‘–is calculated by Formula 5, and ğ‘‡(ğ‘šğ‘–)
referstothenumberoftimesthat ğ‘šğ‘–hasbeenselectedtomutate
the given failing test program.
3.2.2 Advantage LossFunction. After obtainingthe actualreward
at the current time step, RecBi further uses CNN to obtain thepredicted potential reward. To better take the future factors into
account,A2Cdesignsanadvantagelossfunctioninordertoreduce
thehighvarianceofthetwoneuralnetworksandavoidfallinginto
the local optimal [63], which is shown in Formula 7:
ğ´(ğ‘¡)=ğ‘¡+ğ‘¢/summationdisplay.1
ğ‘–=ğ‘¡(ğ›¾(ğ‘–âˆ’ğ‘¡)ğ‘…ğ‘’ğ‘¤ğ‘ğ‘Ÿğ‘‘ ğ‘–)+ğ›¾ğ‘¢+1ğ‘ƒğ‘…ğ‘¡+ğ‘¢âˆ’ğ‘ƒğ‘…ğ‘¡(7)
where,ğ‘¢representsthatCNNconsidersthefuture ğ‘¢consecutive
states and actions when predicting the potential reward, ğ›¾is the
weight of the actual future reward, PRt+uandPRğ‘¡are the predicted
potentialrewardsatthe(t+u )thandtthtimestepsbyCNNrespec-
tively.Inparticular,RecBirepeatstheprocessinatimestepfor ğ‘¢
timesand getthe approximation of the actual future reward.
Based on the loss calculated by the advantage function in For-
mula7,RecBiupdatestheweightsofbothANNandCNNaccording
to Formula 8.
ğœ”=ğœ”+ğ›½ğœ•(ğ‘™ğ‘œğ‘”ğ‘ƒ ğœ”(ğ‘ğ‘¡|ğ‘ ğ‘¡)ğ´(ğ‘¡))
ğœ•ğœ”(8)
where,ğ‘ ğ‘¡andğ‘ğ‘¡arethecurrentstateandaction, ğ‘ƒğœ”(ğ‘ğ‘¡|ğ‘ ğ‘¡)refersto
the probabilitythat ğ‘ğ‘¡is performedat ğ‘ ğ‘¡based onthe parameters
ğœ”in ANN and CNN, ğ›½is the learning rate.
3.3 CompilerBuggyFile Identification
Based on the set of generated passing test programs and the given
failingtestprogram,RecBileveragestheideaofSBFLtoidentifythe buggy compiler files via comparing the coverage of failing
andpassingtests[ 16].Morespecifically,followingpriorworkon
compilerbugisolation[ 16],RecBifirstadoptsstate-of-the-artSBFLformula, i.e., Ochiai [ 7] as shown in Formula 9, to calculate the
suspiciousscore of each statement:
ğ‘ ğ‘ğ‘œğ‘Ÿğ‘’(ğ‘ )=ğ‘’ğ‘“ğ‘ /radicalbig
(ğ‘’ğ‘“ğ‘ +ğ‘›ğ‘“ğ‘ )(ğ‘’ğ‘“ğ‘ +ğ‘’ğ‘ğ‘ )(9)
whereefğ‘ andnfğ‘ representthenumberoffailingteststhatexecute
and do not execute statement ğ‘ , andepğ‘ represents the number
of passing tests that execute statement ğ‘ . Since in RecBi there is
only one givenfailing test program, efğ‘ is 1. Moreover, RecBi only
considersthestatementsexecutedbythegivenfailingtestprogram,
and thus nfğ‘ is 0. Therefore, in RecBi the Ochiai formula can be
simplified as:
ğ‘ ğ‘ğ‘œğ‘Ÿğ‘’(ğ‘ )=1âˆš1+ğ‘’ğ‘ğ‘ (10)
After obtaining the suspicious score of each statement, RecBi
furthercalculatesthesuspiciousscoreofeachcompilerfile.Follow-
ingpriorwork[ 16],RecBiaggregatesthesuspiciousscoresofthe
statementsexecutedbythegivenfailingtestprograminacompiler
file as the suspicious score of the compiler file:
ğ‘†ğ¶ğ‘‚ğ‘…ğ¸(ğ‘“)=/summationtext.1ğ‘›ğ‘“
ğ‘–=1ğ‘ ğ‘ğ‘œğ‘Ÿğ‘’(ğ‘ ğ‘–)
ğ‘›ğ‘“(11)
whereğ‘›ğ‘“isthenumberofstatementsexecutedbythefailingtest
programinthecompilerfile ğ‘“.Accordingtothedescendingorderof
thesuspiciousscoreofeachcompilerfile,RecBiproducesarankinglistofcompilerfiles,wherethehigheracompilerfileisranked,the
higherpossibility the file has to be buggy.
4 EVALUATION
In this study, we aim to address the following research questions:
â€¢RQ1: How does RecBi perform on compiler bug isolation?
â€¢RQ2: How does each main component contribute to RecBi?
â€¢RQ3: How does different RecBi configurations impact the
effectivenessof RecBi?
4.1 Compilersand Bugs
Inthestudy,weusedbothGCCandLLVMassubjectstoinvestigatethe effectiveness of RecBi, covering almost all popular open-sourceCcompilersusedintheexistingwork[
13,16,21,41,70].Regarding
thesubjectbugs,weusedthereleasedbenchmark,including120
real compiler bugs (60 GCC bugs and 60 LLVM bugs), including all
bugsfrompriorcompilerbugisolationwork[ 16].Eachcompiler
bugcontainsthefollowinginformation:thebuggycompilerversion,
the failing test program, the compilation options to reproduce the
bug, and the buggy files (served as the ground-truth in our study).
Onaverage,aGCCbuggyversionhas1,758fileswith1,447Ksource
linesofcode(SLOC),whileaLLVMbuggyversionhas3,265files
with 1,723KSLOC.
4.2 ImplementationandParameters
We implemented our proposed approach RecBi based on Clang
Libtooling library [ 1], Gcov [3], and PyTorch [ 5]. They are used
toparseatestprogramtoanAST(AbstractSyntaxTree),collect
compilercoverageinformation,andprovidetheframeworkofA2C,
respectively.Followingthedefaultsettingintheexistingwork[ 8,
63],wealsoset ğ›¾andğ›½inA2Ctobe0.9and0.01,respectively.In
Enhanced Compiler Bug Isolation via Memoized Search ASE â€™20, September 21â€“25, 2020, Virtual Event, Australia
RecBi, the default settings of ğ›¼andğ‘¢are 0.8 and 5, respectively.
Note that we investigated the impacts of such main parameters
on RecBi in RQ3. Following the existing work [ 16], we set the
terminatingconditiontobeonehourlimit.Thatis,wecomparedall
thestudiedcompilerbugisolationapproachesunderthesametime
limitforfaircomparison.Toreducetheinfluenceofrandomness,
we repeatedly ran all the approaches for 5 times, and calculated
themedianresults.Ourstudyisconductedonaworkstationwith
32-core CPU, 120G memory and Ubuntu 14.04 operating system.
We have released our tool and experimental data at our project
homepage: https://github.com/haoyang9804/RecBi.
4.3 IndependentVariables
4.3.1 ComparedApproaches. WecomparedRecBiwiththestate-of-
the-art compiler bug isolation approach DiWi[16] to answer RQ1.
DiWi isolates compiler bugs via local mutation and the traditional
MH (Metropolis-Hasting) algorithm [ 25], which depends on the
mostrecentbehaviorofeachmutationoperatortodeterminethe
nextmutation operator. Moreover, intraditionalSBFL, developer-
provided tests are always used as the passing tests to reduce the
suspicion of innocent program elements. Thus, in RQ1 we also
investigated whether the generated passing programs via RecBi
outperformthedeveloper-providedpassingtestprogramsforthe
compiler under test. We call the approach using the latter Dev,
whichusesthesamestrategytorankallthecompilerfilesasRecBi
(presented in Section 3.3) but uses the developer-provided passing
programs instead of the generated passing programs via RecBi.
InRQ2,weinvestigatedthecontributionsoftwomaincompo-
nents in RecBi, including newly designed structural mutation and
the reinforcement learning based test program generation strategy.
Therefore, we designed the following variants of RecBi.
â€¢RecBimhreplacesthereinforcementlearningbasedtestpro-
gramgenerationstrategywiththetraditionalMHalgorithm
used in DiWi. That is, RecBi mhadoptsthe same strategyto
guide the process of test program generation as DiWi.
â€¢RecBirandremoves the reinforcement learning based test
program generation strategy from RecBi. That is, RecBi rand
does not have any guidance to generate test programs by
randomlyselectinga mutation operator in each time step.
â€¢RecBifilterremoves the reinforcement learning based test
program generation strategy from RecBi, but keeps the part
ofmeasuringthequalityofageneratedpassingtestprogram
sincethemeasurementmethodisthebaseofthereinforce-
ment learning based test program generation strategy. That
is,RecBi filterrandomlyselectsamutationoperatorineach
time step, then measures the quality of a generated passing
test program in the same way as RecBi, and finally filters
the low-quality passing test program ( Î”ğ‘„ğ‘¡< 0). Actually,
RecBifilteris an updated version of RecBi randby adding a
measuringcomponent.
We compared RecBi mhand DiWi to investigate the contribution
of our designed structural mutation operators. We then compared
RecBi, RecBi rand, and RecBi mhto investigate the contribution of
our proposed reinforcement learning based test program gener-ation strategy. Besides, we compared RecBi
randand RecBi filterto
investigatethe effectivenessof our designedmeasurement for thequalityof a generated passing test program, which is the base of
our reinforcement learning based test program generation strategy.
4.3.2 DifferentRecBiConfigurations. In RQ3,we investigateddif-
ferentconfigurationsofRecBi.Here,wediscussedtwomainparam-etersinRecBi,including
ğ›¼(usedtocombinesimilarityanddiversity
asshowninFormula4)and ğ‘¢(thenumberoffuturetimestepsthat
RecBi takes into account in Formula 7). Regarding ğ›¼, we studied
ğ›¼=0,0.2,0.4,0.6,0.8,and1,respectively.Here, ğ›¼=0meansthat
RecBi only considers similarity, while ğ›¼= 1 means that RecBi only
considers diversity. Regarding ğ‘¢, we studied ğ‘¢=1 ,2 ,3 ,4 ,5 ,6 ,a n d
7, respectively.
4.4 Measurements
Each compiler bug isolation approach produces a ranking list ofsuspicious compiler files, and thus we measured the position of
eachbuggyfileintherankinglisttomeasuretheeffectivenessof
each approach. Regarding the tie issue (i.e., multiple compiler files
have the same suspicious scores), we adopted the worst ranking
followingtheexistingwork[ 35,52].Morespecifically,wecalculated
the following metrics, which are widely-used by the existing work
in the area of bug localization [16, 40, 48, 55].
â€¢Top-nmeasures the number of bugs that are isolated suc-
cessfullywithin theTop-n position(i.e., ğ‘›âˆˆ{1,5,10,20}in
our study) in the ranking list. The larger the Top-n value is,
the more effective the approach is.
â€¢MeanFirstRanking(MFR) measuresthemeanoftherank
ofthefirstbuggyfileintherankinglistforeachbug.MFR
focuses on isolatingthe first buggy element fastin order to
facilitate debugging. The smallerthe MFR value is, themore
effective the approach is.
â€¢MeanAverageRanking(MAR) measuresthemeanofthe
averagerankofallbuggyfilesintherankinglistforeachbug.
MAR focuses on isolating all buggy elements precisely. The
smallertheMARvalueis,themoreeffectivetheapproachis.
4.5 Resultsand Analysis
4.5.1 RQ1:OveralleffectivenessofRecBi. Weillustratedthecom-
parisonresultsamongvariousapproachesinTable2.Overall,RecBi
is able to isolate 27, 70, 93, 107 compiler bugs (out of 120 compiler
bugs) within Top-1, Top-5, Top-10, and Top-20 files, respectively.
Thatis,nearly23%,58%,78%,and89%bugscanbeisolatedsuccess-
fully withinTop-1, Top-5,Top-10,and Top-20files throughRecBi,
respectively. We further analyzed the effectiveness of RecBi on
differentsubjectcompilers,andsurprisinglyfoundthatalthough
there are a larger number of compiler files in LLVM compared
withGCC,RecBiachievesbetterresultsonLLVMthanGCC.For
example, the MFR and MAR values of RecBi on LLVM are 7.77and 7.85 respectively while those of RecBi on GCC are 8.75 and9.35 respectively. Moreover, we found that the other approaches
indeedperformworseonLLVMthanGCC.Theresultsdemonstrate
that,theeffectivenessofRecBiisnotaffectedwhenfacinglarger
compilersystems,indicatingitsscalability.
We then compared RecBi with the state-of-the-art compiler bug
isolation approach DiWi. From Table 2, RecBi performs better than
DiWiintermsofallthemetricsandonbothofsubjectcompilers.
ASE â€™20, September 21â€“25, 2020, Virtual Event, Australia Junjie Chen, Haoyang Ma, and Lingming Zhang
Table 2: Compiler bug isolation effectiveness comparison
Sub Approach Top-1 â‡‘ğ‘‡ğ‘œğ‘âˆ’1Top-5 â‡‘ğ‘‡ğ‘œğ‘âˆ’5Top-10 â‡‘ğ‘‡ğ‘œğ‘âˆ’10Top-20 â‡‘ğ‘‡ğ‘œğ‘âˆ’20MFRâ‡‘ğ‘€ğ¹ğ‘… MARâ‡‘ğ‘€ğ´ğ‘…
LLVMRecBi 13 â€” 38 â€” 48 â€” 54 â€” 7.77 â€” 7.85 â€”
DiWi 6 116.67 23 65.22 37 29.73 47 14.89 16.80 53.75 16.92 53.61
Dev 2 550.00 12 216.67 22 118.18 37 45.95 37.36 79.20 37.49 79.06
RecBimh 10 30.00 31 22.58 42 14.29 50 8.00 11.17 30.44 11.48 31.62
RecBifilter 7 85.71 27 40.74 42 14.29 49 10.20 13.77 43.57 17.91 56.17
RecBirand 3 333.33 29 31.03 39 23.08 49 10.20 40.12 80.63 40.16 80.45
GCCRecBi 14 â€” 32 â€” 45 â€” 53 â€” 8.75 â€” 9.35 â€”
DiWi 8 75.00 22 45.45 37 21.62 49 8.16 13.53 35.33 14.15 33.92
Dev 3 366.67 12 166.67 25 80.00 32 65.62 22.44 61.01 23.04 59.42
RecBimh 13 7.69 30 6.67 41 9.76 49 8.16 10.52 16.83 10.92 14.38
RecBifilter 14 0.00 30 6.67 43 4.65 50 6.00 10.10 13.37 10.30 9.22
RecBirand 4 250.00 18 77.78 26 73.08 39 35.90 19.40 54.90 19.99 53.23
ALLRecBi 27 â€” 70 â€” 93 â€” 107 â€” 8.26 â€” 8.60 â€”
DiWi 14 92.86 45 55.56 74 25.68 96 11.46 15.17 45.55 15.53 44.62
Dev 5 440.00 24 191.67 47 97.87 69 55.07 29.90 72.38 30.26 71.58
RecBimh 23 17.39 61 14.75 83 12.05 99 8.08 10.84 23.80 11.20 23.21
RecBifilter 21 28.57 57 22.81 85 9.41 99 8.08 11.93 30.76 14.10 39.01
RecBirand 7 285.71 47 48.94 65 43.08 88 21.59 29.76 72.24 30.08 71.41
*Columnsâ€œ â‡‘âˆ—â€ present the improvement rates of RecBiover a compared approach in terms of various metrics.
The overall improvements of RecBi over DiWi in terms of Top-1,
Top-5, Top-10, Top-20 are 92.86%, 55.56%, 25.68%, and 11.46%, re-
spectively.Inparticular,asdemonstratedbytheexistingwork[ 38],
the Top-5 metric is more important in practice since most devel-
operstendtoaborttheautomateddebuggingtoolsiftheycannot
localizebuggyelementswithinTop-5positions[ 38],andthusRecBi
is more practical than DiWi by largely improving the effectiveness
of compiler bug isolation in terms of Top-5. The MFR and MAR
values of RecBi are 8.26 and 8.60 respectively while those of DiWi
are 15.17 and 15.53 respectively, demonstrating 45.55% and 44.62%
improvements of RecBi over DiWi respectively. That demonstrates
that RecBi indeed significantly outperforms the state-of-the-art
approach DiWifor compilerbug isolation.
We also compared RecBi with the approach using the developer-
provided passing test programs Dev. From Table 2, RecBi signif-icantly outperform Dev in terms of all the metrics and on both
GCC and LLVM. The overall improvements of RecBi over Dev are
440.00%, 191.67%, 97.87%, and 55.07% in terms of Top-1, Top-5, Top-
10, and Top-20, respectively. Also, the overall improvements of
RecBioverDevare72.38%and71.58%intermsofMFRandMAR,
respectively.Theresultsdemonstratetheapparentsuperiorityof
RecBi compared with Dev.
Qualitative Analysis. We further performed qualitative analysis
on RecBi with two examples. Figure 5 shows two programs, where
the left one is the given failing test program and the right one is a
passingtestprogramgeneratedviaourdesignedstructuralmuta-
tion (i.e., inserting a whilestatement). This bug is triggered when
compilingthefailingtestprogramusingGCCrevision228291at
-O2and above. The root cause lies in the compiler file " ifcvt.c",
which incorrectly uses 8-bit registers for optimization instead of
32-bitones. By inserting a whilestatementwith a false predicate,
a passing test program is generated as shown in Figure 5b, since it
invalidates the statement â€œ c=(b&15)Ë†e; â€ that triggers the buggy
optimizations.Wefurthercalculatedthesimilaritybetweenthetwo1intprintf( const char âˆ— ,...);
2inta;
3intb=10;
4charc;
5intmain (){
6chard;
7inte=5;
8for(a=0;a;a âˆ’âˆ’){e=0;}
9 c=(b&15)^e;
10 d=c>e?c:c<<e;
11 printf("%d\n",d);
12 return 0;
13 }
(a) Failing Program1intprintf( const char âˆ— ,...);
2inta;
3intb=10;
4charc;
5intmain (){
6chard;
7inte=5;
8for(a=0;a;a âˆ’âˆ’){e=0;}
9 while(e<a) {c=(b&15)^e;}
10 d=c>e?c:c<<e;
11 printf("%d\n",d);12 return 0;
13 }
(b) Passing Program
Figure 5: GCC Bug 67786
1inta;
2voidfn1 (){
3charb=0;
4for(;b!=âˆ’2;bâˆ’âˆ’)
5 for(a=0;a<1;a++)
6 if((unsigned int )b>1)
7 return;
8}
9intmain (){
10 fn1();
11 if(a!=0)
12 __builtin_abort();13 return 0;
14 }
(a) Failing Program1inta;
2voidfn1 (){
3charb=0;
4 goto Label;
5for(;b!=âˆ’2;bâˆ’âˆ’)
6 for(a=0;a<1;a++)
7 Label:
8 if((unsigned int )b>1)
9 return;
10 }11intmain (){
12 fn1();13 if(a!=0)
14 __builtin_abort();15 return 0;
16 }
(b) Passing Program
Figure 6: LLVM Bug 24356
test programs following Formula 1, which is 0.974. That demon-
strates the power of our structural mutation that guarantees the
generatedpassingtestprogramtoshareasimilarexecutiontrace
withthegivenfailingtestprogram.Inparticular,RecBiranksthe
buggyfile at the 2ndposition.
Enhanced Compiler Bug Isolation via Memoized Search ASE â€™20, September 21â€“25, 2020, Virtual Event, Australia
Figure6showsanotherexample,whichpresentsapassingtest
program (shown in Figure 6b) by inserting a gotostatement to the
failingtestprogram(showninFigure6a).Thisbugistriggeredwhen
compilingthefailingtestprogramat -O1andaboveusingLLVM
revision 243961. The buggy file is ScalarEvolution.cpp , which
causesthatLine6isdirectlyexecutedafterLine4byskippingLine
5 due to incorrect optimization. By inserting a gotostatement, the
programstructureavoidtriggeringthebuggyoptimization,leading
topassingexecution.Thesimilaritybetweenthetwoprogramsis
0.914,furtherconfirmingtheeffectivenessofRecBi.Inparticular,
RecBi ranks the buggy file at the 5thposition.
4.5.2 RQ2:ContributionsofMainComponents. ToanswerRQ2,we
investigatedthecontributionsoftwomaincomponentsinRecBi,i.e.,
structuralmutationandreinforcementlearningbasedtestprogram
generationstrategy.
ContributionofStructuralMutationinRecBi .Weinvestigated
the contribution of structural mutation by comparing DiWi and
RecBimhshown in Table 2. We found that RecBi mhperforms better
thanDiWiintermsofallthemetricsonbothGCCandLLVM.More
specifically, RecBi mhsuccessfully isolates 23, 61, 83, and 99 bugs
within Top-1, Top-5, Top-10, and Top-20 files respectively while
DiWi only isolates 14, 45, 74, and 96 bugs respectively. The overall
improvementsofRecBi mhoverDiWiare28.54%and27.88%interms
of MFR and MAR, respectively. The experimental results demon-
strate that incorporating structural mutation indeed improves the
effectivenessofcompilerbugisolation,confirmingthecontribution
of structural mutation in RecBi.
Wefurtheranalyzedthecontributionofeachstructuralmutation
operatortoisolatecompilerbugs.Wefoundthatforeachstudied
bug, there exist the passing test programs generated by our de-
signed structural mutation operators. More specifically, the fourstructural mutation operators (i.e., inserting branch statements,loop statements, function calls, and
gotostatements) generated
passing test programs for 61%, 76%, 3%, and 25% bugs, respectively.
That is, all the four structural mutation operators are indeed useful
to generate passing test programs during compiler bug isolation.
Inparticular,theoperatorinsertingloopstatementsmakethemost
contributions while that inserting function calls make the least
contributions among them. This phenomenon is as expected since
theoperatorinsertingfunctioncallstendtomorelargelychange
the program structure than the other three operators, leading to
muchlesssimilaritybetweenthegeneratedpassingtestprogram
and the given failing test program (i.e., a more low-quality passing
testprogram).Then,duetothequalitymeasurement(Formulae4
and5)inRecBi,suchlow-qualitypassingtestprogramsaremore
likely to be filtered.
ContributionofReinforcementLearningbasedTestProgram
Generation Strategy . We then investigated the contribution of
our reinforcement learning based test program generation strat-
egy,bycomparingRecBi,RecBi rand,andRecBi mhshowninTable2.
We found that among the three approaches, RecBi performs the
best while RecBi randperforms the worst. More specifically, the
improvements of RecBi over RecBi randin terms of Top-1, Top-5,
Top-10,Top-20,MFR,andMARare285.71%,48.94%,43.08%,21.59%,
72.24%,and71.41%respectively,andthoseofRecBioverRecBi mh
(a) GCC
 (b) LLVM
Figure 7: Similarity between the given failing test programand generated passing test programs
(a) GCC
 (b) LLVM
Figure 8: Diversity among generated passing test programs
are17.39%,14.75%,12.05%,8.08%,23.80%,and23.21%respectively.
That is, our reinforcement learning based strategy outperforms
both the random strategy andthe MH-based strategy used by the
state-of-the-art approach DiWi, demonstrating the contribution of
ourreinforcement learning based test program generation.
We further analyzed the reason why our reinforcement learning
based strategy outperforms the other two strategies by calculating
the similarity (Formula 1) and diversity (Formula 2) for the gen-
eratedpassingtestprogramsviathethreestrategies,respectively.
Figure7presentstheaveragesimilaritybetweenthegeneratedpass-
ing test programs and the given failing test program across all the
bugsforthethreestrategiesrespectively,whileFigure8presents
theaveragediversityamongallthepassingtestprogramsacrossallthebugs.Inthetwofigures,theviolinplotsshowthedensityatdif-
ferent values, and the box plots show the median and interquartile
ranges.FromFigures7and8,bothsimilarityvaluesanddiversity
values for RecBi are distributed more intensively than those for
RecBimhandRecBi rand,indicatingthatthequalityofthegenerated
passingtestprogramsthroughourreinforcementlearningbased
strategyismorestable.Ingeneral,thesimilarityachievedbyRecBi
is larger than that achieved by both RecBi mhand RecBi rand, and
RecBi does not have the low-quality passing test programs withlittle similarity. Moreover, we found that the diversity achievedby RecBi does not have superiority compared with RecBi
mhand
RecBirand. This phenomenon is as expected since both similarity
and diversity actually contradict each other to some degree. Theresults indicate that when staying high similarity, enlarging the
diversity would facilitate effective compiler bug isolation.
WethencomparedRecBi filterwithRecBi randtoinvestigatethe
contribution of our designed measurement for the quality of a gen-
eratedpassingtestprogram,whichisthebaseofourreinforcement
learning based strategy. From Table 2, we found that RecBi filtersig-
nificantly outperforms RecBi rand, although performing worse than
RecBi. More specifically, the MFR and MAR values of RecBi rand
areonly29.76and30.08respectivelywhilethoseofRecBi filterare
11.93 and 14.10 respectively. That is, incorporating our designed
ASE â€™20, September 21â€“25, 2020, Virtual Event, Australia Junjie Chen, Haoyang Ma, and Lingming Zhang
(a) Impact of ğ›¼
 (b) Impact of ğ‘¢
Figure 9: The impact of different parameter settings
qualitymeasurementintotherandomstrategyisabletolargelyim-
prove the effectiveness of the random strategy, demonstrating the
necessity of filtering low-quality passing test programs in RecBi.
4.5.3 RQ3:ImpactofDifferentRecBiConfigurations. Weinvesti-
gated the impact of two main parameters in RecBi, i.e., ğ›¼andğ‘¢.
Figure9ashowstheeffectivenessofRecBiatdifferent ğ›¼valuesin
terms of Top-1 and Top-5 metrics. As demonstrated by the existing
work [38], Top-1 and Top-5 results are more important in practical,
andthusweusedthetwometricsastherepresentativestoevaluate
the impact of different RecBi configurations. In Figure 9a, the x-
axis represents the ğ›¼values while the y-axis represents the metric
valuesonbothGCCandLLVM.Fromthisfigure,wefoundthatour
default setting (i.e., 0.8) is better than the other settings in terms of
bothTop-1andTop-5metrics,especiallybetterthanthesettingsof
0and1,indicatingthatcombiningbothsimilarityanddiversityout-
performs individual similarity or diversity for generating effective
passingtest programs.
Figure9bshowstheeffectivenessofRecBiatdifferent ğ‘¢valuesin
terms of Top-1 and Top-5 metrics. From this figure, we found that
the best setting ranges from 4 to 6, including our default setting
(i.e.,5).Thisisasexpectedsincewhenthevalueof ğ‘¢issmall,there
is little future knowledge considered in RecBi, leading to worse
effectiveness, while when the value of ğ‘¢is large, the prediction for
the future potential reward could become more inaccurate, leading
to worse effectiveness of RecBi.
5 DISCUSSION
5.1 Threatsto Validity
Theinternalthreattovaliditymainlyliesintheimplementationsof
ourapproachRecBiandthecomparedapproachDiWi.Toreduce
this threat, regarding the implementation of DiWi, we adopted
the implementationreleased bythe existingwork [16].Regarding
the implementation of RecBi, we implemented it based on mature
libraries as presented in Section 4.2 and carefully checked the code.
Theexternalthreats to validity mainly lie in the used compilers
and bugs. Regarding the used compilers, following the existing
workofcompilerbugisolation[ 16],wealsousedtwomostpopular
C open-source compilers, i.e., GCC and LLVM. Regarding the used
bugs, we used 120 real compiler bugs including all bugs from prior
compilerbugisolationwork[ 16].Tofurtherreducethesethreats,
we will collect more real compiler bugs from more compilers to
evaluate the effectiveness of RecBi.
Theconstruct threats to validity mainly lie in the settings of
parameters,randomness,andtheusedmeasurements.Regarding
the settings of parameters, we have presented our specific settings
in Section 4.2 and investigated the influence of main parameters in
Section 4.5.3. Regarding the involved randomness in our study, werepeatedly ran all the approaches for 5 times, and calculated the
medianresults.Regardingtheusedmeasurements,wehaveused
several widely-used measurementsin thearea ofbug localization.
To further reduce this threat, we will try to apply RecBi to the
industry and collect feedback from developers to evaluate RecBi.
5.2 Future Work
WediscussthefollowingextensionsofRecBiasourfuturework.
First,RecBi doesnotspeciallydeal withundefinedbehaviors[ 30]
(i.e.,thesemanticsofcertainoperationsareundefinedinthepro-
gramming languages standards). Similar to the existing work [ 16],
our mutation may also introduce undefined behaviors to a test pro-
gram, causing that the compiler may produce uncertain results for
the test program with undefined behaviors. However, undefined
behaviors tend to affect bug detection since different results of a
â€œfailingâ€ test program may be caused by real bugs or undefined be-
haviors. RecBi only keeps the passing test programs with the same
results to isolate compiler bugs, and thus undefined behaviors may
notaffect RecBi.As demonstratedby theexisting work[ 43,65],it
ischallengingtoidentifyundefinedbehaviorsincompilerresearch,inthefuturewewilltrytorelievethisproblembyadoptingexisting
efficienttechniques[ 43].Second,wewillfurtherextendRecBito
isolate compiler bugs at more fine-grained levels (e.g., methods) by
calculatingthe suspiciousscores at the corresponding levels.
6 RELATED WORK
RecBi is based on both mutation and reinforcement learning for
compilerbugisolation,andthusweintroducethreecategoriesof
relatedwork,includingcompilerdebugging,mutation-basedbug
isolation,and learning-based bug isolation.
CompilerDebugging. BesidesthemostrelatedworkDiWi[ 16]
describedbefore,Zeller[ 71]proposedtoproduceanentirecause-
effect chain from input to result in GCC to facilitate debugging.
Actually,RecBiiscomplementarytothecause-effectchain:1)the
latter produces bug-diagnosis information at the program-state
level while the former does this at the source-code level, 2) the
latter manipulatesin memory and may not handle external states,3) the former is more lightweight.
Besides,incompilerdebuggingtherearemanyworkfocusingon
providingdebuggingmessagesandvisualization[ 11,31,39,49,54].
Someworkalsofocusedonsimplifyingthetestprogramstriggering
compiler bugs in order to facilitate debugging [ 10,32,53,59,72].
Inourwork,thefailingtestprogramsarecollectedfromcompiler
bug reports, and all of them have already been the simplified ones
as required by compiler developers [ 16]. Some work focused on
identifying the test programs triggering the same compiler bug for
efficientdebugging[ 22,33].Differentfromthem,ourworkfocuses
oncompilerbugisolation bygeneratingpassingtestprogramsvia
reinforcement learning and mutation.
Mutation-basedBugLocalization. Mutation-basedbuglocaliza-
tion considers the actual impacts of code elements in the software
systemsundertestontestoutcomestolocalizebugsthroughmu-
tation testing [ 48,50,51,74]. More specifically, it injects mutation
bugs to each code element to simulate the actual impact of each
codeelement.Forexample,Papadakisetal.[ 50,51]proposedthe
firstmutation-basedbuglocalizationapproach,named Metallaxis.
Enhanced Compiler Bug Isolation via Memoized Search ASE â€™20, September 21â€“25, 2020, Virtual Event, Australia
Its basic insight is that if mutating a code element can change
theoutcomeofsomefailingtests,thecodeelementmayhavepo-
tentialimpactonthefailingtestsandthusmayhavebeenbuggy.
Meanwhile, Zhang et al. [ 74] independently proposed FIFL, the
first mutation-based bug localization approach for evolving sys-
tems. The basic insight is that regression bugs can be simulated
and localized via mutating corresponding code elements on the oldprogram version. More recently, Moon et al. [
48] proposed another
mutation-based bug localization approach, named MUSE, based on
the idea that mutating faulty code elements may cause more failed
teststo pass than mutating correct elements. Different from these
traditional mutation-based bug localization approaches, which aim
to mutate the software systems under test, our approach RecBi
aimstomutatethefailingtestcases(i.e.,testprograms)togenerate
passingtest programs for compiler bug isolation.
Learning-basedBugLocalization. Inrecentyears,alotoflearning-
based bug localization approaches have been proposed [ 40,44,55,
68]. For example, Xuan and Monperrus [ 68] proposed to utilize the
learning-to-rank algorithm to localize bugs by combining different
suspiciousscorescalculatedbySBFL.Leetal.[ 40]furtherconsid-
ered both the suspicious scores calculated by SBFL and program
invarianttolocalize bugsthroughthelearning-to-rank algorithm.
Recently, Li et al. [ 44] proposed to use deep learning techniques
to localize bugs by considering the suspicious scores calculated
by SBFLand mutation basedbug localization, aswell as staticfea-
turesextractedfromthedefectpredictionarea[ 64]andinformation
retrievalarea[ 26].Differentfromtheselearning-basedbuglocal-
izationapproaches,whichuselearningtechniquestorankallthe
suspiciouscodeelements,ourapproachRecBiutilizesthe reinforce-
ment learning algorithm (i.e., A2C) to guide the process of passing
test program generation for compiler bug isolation.
7 CONCLUSION
Inthispaper,weproposeareinforcementcompilerbugisolation
approach via structural mutation, which is called RecBi. RecBi first
augments traditional local mutation operators with structural ones
in order to generate a set of effective passing test programs for
a given compiler bug with a failing test program. In particular,
RecBi incorporates reinforcement learning to intelligently guide
the process of passing test program generation. Based on the set ofgeneratedpassingtestprogramsandthegivenfailingtestprogram,RecBiranksallthesuspiciousfilesbycomparingtheexecutiontrace
between them. We conducted an extensive study to evaluate RecBi
based on two most popular C open-source compilers (i.e., GCC
and LLVM) and 120 real bugs from them. The experimental results
demonstratetheeffectivenessofRecBi,significantlyoutperforming
the state-of-the-artcompilerbugisolationapproach.
ACKNOWLEDGEMENTS
This work was partially supported by the National Natural Science
Foundation of China 62002256 and National Science Foundation
underGrantNos. CCF-1763906and CCF-1942430,and Alibaba.
REFERENCES
[1]Accessed: 2020. Clang Libtooling library. http://clang.llvm.org/docs/LibTooling.
html.
[2] Accessed: 2020. GCC. https://gcc.gnu.org.[3] Accessed: 2020. Gcov. https://gcc.gnu.org/onlinedocs/gcc/Gcov.html.
[4] Accessed: 2020. LLVM. https://llvm.org.[5] Accessed: 2020. PyTorch. https://pytorch.org/.[6]
R.Abreu,P.Zoeteweij,andA.J.c.VanGemund.2006. AnEvaluationofSimilarityCoefficientsforSoftwareFaultLocalization.In 200612thPacificRimInternational
Symposium on Dependable Computing (PRDCâ€™06). 39â€“46.
[7]RuiAbreu,PeterZoeteweij,andArjanJCVanGemund.2007. Ontheaccuracyof
spectrum-based fault localization. In Testing: Academic and Industrial Conference
PracticeandResearchTechniques-MUTATION(TAICPART-MUTATION2007) .IEEE,
89â€“98.
[8]MilanAggarwal,AarushiArora,ShagunSodhani,andBalajiKrishnamurthy.2018.
Improving Search Through A3C Reinforcement Learning Based Conversational
Agent. In 18thInternationalConferenceon Computational Science . 273â€“286.
[9]Samuel Benton, Xia Li, Yiling Lou, and Lingming Zhang. 2020. On the Effective-
ness ofUnified Debugging: AnExtensive Study on16 Program Repair Systems.
InASE. to appear.
[10]Jacqueline M. Caron and Peter A. Darnell. 1990. Bugfind: A Tool for Debugging
OptimizingCompilers. SIGPLANNotices 25,1 (1990), 17â€“22.
[11]Bor-Yuh Evan Chang, Adam Chlipala, George C. Necula, and Robert R. Schneck.
2005. Type-basedverificationofassemblylanguageforcompilerdebugging.In
ProceedingsofTLDIâ€™05:2005ACMSIGPLANInternationalWorkshoponTypesin
LanguagesDesignand Implementation . 91â€“102.
[12]Junjie Chen. 2018. Learning toaccelerate compiler testing. In Proceedings of the
40thInternational ConferenceonSoftware Engineering:CompanionProceeedings .
472â€“475.
[13]Junjie Chen, Yanwei Bai, Dan Hao, Yingfei Xiong, Hongyu Zhang, and Bing Xie.
2017. Learningtoprioritizetestprogramsforcompilertesting.In 2017IEEE/ACM
39thInternationalConferenceon Software Engineering (ICSE) . IEEE, 700â€“711.
[14]Junjie Chen, Yanwei Bai, Dan Hao, Yingfei Xiong, Hongyu Zhang, Lu Zhang,
and Bing Xie. 2016. Test Case Prioritization for Compilers: A Text-Vector Based
Approach. In 2016 IEEE International Conference on Software Testing, Verification
andValidation. 266â€“277.
[15]Junjie Chen,Yanwei Bai, DanHao,Lingming Zhang, Lu Zhang, BingXie,and
HongMei.2016. Supportingoracleconstructionviastaticanalysis.In 201631st
IEEE/ACM International Conference on Automated Software Engineering (ASE).
IEEE,178â€“189.
[16]Junjie Chen, Jiaqi Han, Peiyi Sun, Lingming Zhang, Dan Hao, and Lu Zhang.
2019. Compilerbugisolationviaeffectivewitnesstestprogramgeneration.In
ProceedingsoftheACMJointMeetingonEuropeanSoftwareEngineeringConference
andSymposiumontheFoundationsofSoftwareEngineering,ESEC/SIGSOFTFSE
2019,Tallinn, Estonia, August 26-30, 2019. 223â€“234.
[17]Junjie Chen, Wenxiang Hu, Dan Hao, Yingfei Xiong, Hongyu Zhang, and Lu
Zhang. 2019. Static duplicate bug-report identification for compilers. SCIENTIA
SINICAInformationis 49,10 (2019), 1283â€“1298.
[18]Junjie Chen, Wenxiang Hu, Dan Hao, YingfeiXiong,Hongyu Zhang, Lu Zhang,
and Bing Xie. 2016. An empirical comparison of compiler testing techniques. In
Proceedingsofthe38thInternationalConferenceonSoftwareEngineering.180â€“190.
[19]JunjieChen,JibeshPatra,MichaelPradel,YingfeiXiong,HongyuZhang,Dan
Hao,andLuZhang.2020. ASurveyofCompilerTesting. ACMComputingSurveys
(CSUR)53 (02 2020), 1â€“36.
[20]Junjie Chen, Guancheng Wang, Dan Hao, Yingfei Xiong, Hongyu Zhang, and Lu
Zhang.2019. History-GuidedConfigurationDiversificationforCompilerTest-
Program Generation.In 34thIEEE/ACMInternationalConferenceonAutomated
Software Engineering. 305â€“316.
[21]Junjie Chen, Guancheng Wang, Dan Hao, Yingfei Xiong, Hongyu Zhang, Lu
Zhang,andXIEBing.2018. Coveragepredictionforacceleratingcompilertesting.
IEEETransactions on Software Engineering (2018).
[22]Yang Chen, Alex Groce, Chaoqiang Zhang, Weng-Keen Wong, Xiaoli Z. Fern,Eric Eide, and John Regehr. 2013. Taming compiler fuzzers. In ACM SIGPLAN
Conferenceon Programming Language Design and Implementation. 197â€“208.
[23]Yuting Chen, Ting Su, and Zhendong Su. 2019. Deep differential testing of JVM
implementations. In Proceedings of the 41st International Conference on Software
Engineering. 1257â€“1268.
[24]Yuting Chen, Ting Su, Chengnian Sun, Zhendong Su, and Jianjun Zhao. 2016.
Coverage-directeddifferentialtestingofJVMimplementations.In Proceedings
of the 37th ACM SIGPLAN Conference on Programming Language Design and
Implementation. 85â€“99.
[25]SiddharthaChibandEdwardGreenberg.1995. Understandingthemetropolis-
hastingsalgorithm. Theamericanstatistician 49,4 (1995), 327â€“335.
[26]TungDao,LingmingZhang,andNaMeng.2017.Howdoesexecutioninformation
helpwithinformation-retrievalbasedbuglocalization?.In Proceedingsofthe25th
InternationalConferenceon Program Comprehension . 241â€“250.
[27]NicholasDiGiuseppeandJamesA.Jones.2011.OntheInfluenceofMultipleFaults
on Coverage-Based Fault Localization. In Proceedings of the 2011 International
Symposium on Software Testing and Analysis. 210â€“220.
[28]AlastairF.Donaldson,HuguesEvrard,AndreiLascu,andPaulThomson.2017.
Automated testing of graphics shader compilers. Proc. ACM Program. Lang. 1,
OOPSLA(2017),93:1â€“93:29.
ASE â€™20, September 21â€“25, 2020, Virtual Event, Australia Junjie Chen, Haoyang Ma, and Lingming Zhang
[29]Ivo Grondman, Lucian Busoniu, Gabriel AD Lopes, and Robert Babuska. 2012.
A survey of actor-critic reinforcement learning: Standard and natural policy
gradients. IEEETransactionsonSystems,Man,andCybernetics,PartC(Applications
andReviews) 42,6 (2012), 1291â€“1307.
[30]ChrisHathhorn,ChuckyEllison,andGrigoreRosu.2015. Definingtheundefined-
nessofC.In Proceedingsofthe36thACMSIGPLAN ConferenceonProgramming
LanguageDesignandImplementation . 336â€“345.
[31]K. Scott Hemmert, Justin L. Tripp, Brad L. Hutchings, and Preston A. Jackson.
2003. SourceLevelDebuggerfortheSeaCucumberSynthesizingCompiler.In
11th IEEE Symposium on Field-Programmable Custom Computing Machines . 228.
[32]Satia Herfert, Jibesh Patra, and Michael Pradel. 2017. Automatically reducing
tree-structured test inputs. In Proceedings of the 32nd IEEE/ACM International
Conferenceon Automated Software Engineering . 861â€“871.
[33]JosieHolmesandAlexGroce.2018. CausalDistance-Metric-BasedAssistance
for Debugging after Compiler Fuzzing. In 29th IEEE International Symposium on
Software Reliability Engineering. 166â€“177.
[34]Shin Hong, Byeongcheol Lee, Taehoon Kwak, Yiru Jeon, Bongsuk Ko, YunhoKim, and Moonzoo Kim. 2015. Mutation-Based Fault Localization for Real-
World Multilingual Programs. In Proceedings of the 30th IEEE/ACM International
Conferenceon Automated Software Engineering . 464â€“475.
[35]Dennis Jeffrey, Neelam Gupta, and Rajiv Gupta. 2008. Fault localization using
valuereplacement.In Proceedingsofthe2008internationalsymposiumonSoftware
testingandanalysis. 167â€“178.
[36]James A. Jones and Mary Jean Harrold. 2005. Empirical Evaluation of the Taran-
tulaAutomaticFault-LocalizationTechnique.In Proceedingsofthe20thIEEE/ACM
InternationalConferenceon Automated Software Engineering . 273â€“282.
[37]Leslie Pack Kaelbling, Michael L Littman, and Andrew W Moore. 1996. Rein-
forcementlearning:Asurvey. Journalofartificialintelligenceresearch 4(1996),
237â€“285.
[38]Pavneet Singh Kochhar, Xin Xia, David Lo, and Shanping Li. 2016. Practitionersâ€™
expectations onautomated fault localization.In Proceedings ofthe 25th Interna-
tionalSymposiumon Software Testing and Analysis . 165â€“176.
[39]Nico Krebs and Lothar Schmitz. 2014. Jaccie: A Java-based compiler-compiler
for generating, visualizing and debugging compiler components. Sci. Comput.
Program. 79 (2014), 101â€“115.
[40]Tien-Duy B. Le, David Lo, Claire Le Goues, and Lars Grunske. 2016. A learning-
to-rankbased fault localization approach using likely invariants. In Proceedings
of the 25th International Symposium on Software Testing and Analysis. 177â€“188.
[41]Vu Le, Mehrdad Afshari, and Zhendong Su. 2014. Compiler validation via equiv-
alencemoduloinputs.In ACMSIGPLANConferenceonProgrammingLanguage
DesignandImplementation. 216â€“226.
[42]Vu Le, Chengnian Sun, and Zhendong Su. 2015. Finding deep compiler bugs via
guidedstochasticprogrammutation.In Proceedingsofthe2015ACMSIGPLAN
InternationalConferenceonObject-OrientedProgramming,Systems,Languages,
andApplications. 386â€“399.
[43]JuneyoungLee,YoonseungKim,YoungjuSong,Chung-KilHur,SanjoyDas,David
Majnemer,JohnRegehr,andNunoP.Lopes.2017. Tamingundefinedbehavior
inLLVM.In Proceedingsofthe38thACMSIGPLANConferenceonProgramming
LanguageDesignandImplementation . 633â€“647.
[44]XiaLi,WeiLi,YuqunZhang,andLingmingZhang.2019. DeepFL:integrating
multiple fault diagnosis dimensions for deep fault localization. In Proceedings of
the28thACMSIGSOFTInternationalSymposiumonSoftwareTestingandAnalysis .
169â€“180.
[45]Xia Li and Lingming Zhang. 2017. Transforming programs and tests in tandem
forfaultlocalization. Proc. ACM Program. Lang. 1, OOPSLA (2017), 92:1â€“92:30.
[46]YilingLou,AliGhanbari,XiaLi,LingmingZhang,HaotianZhang,DanHao,and
LuZhang.2020. CanAutomatedProgramRepairRefineFaultLocalization?A
Unified Debugging Approach. In ISSTA. to appear.
[47]Volodymyr Mnih, Koray Kavukcuoglu, David Silver, Alex Graves, Ioannis
Antonoglou, Daan Wierstra, and Martin Riedmiller. 2013. Playing Atari with
Deep Reinforcement Learning. (2013).
[48]Seokhyeon Moon, Yunho Kim, Moonzoo Kim, and Shin Yoo. 2014. Ask the
mutants:Mutatingfaultyprogramsforfaultlocalization.In 2014IEEESeventh
International Conference on Software Testing, Verification and Validation . IEEE,
153â€“162.
[49]KazunoriOgata,TamiyaOnodera,KiyokuniKawachiya,HideakiKomatsu,and
Toshio Nakatani. 2006. Replay compilation: improving debuggability of a just-in-
time compiler. In Proceedings of the 21th Annual ACM SIGPLAN Conference on
Object-Oriented Programming, Systems, Languages, and Applications . 241â€“252.
[50]MikePapadakisand Yves Le Traon. 2012. Using Mutants to Locate "Unknown"
Faults. In Fifth IEEE International Conference on Software Testing, Verification and
Validation. 691â€“700.
[51]MikePapadakisandYvesLeTraon.2015. Metallaxis-FL:mutation-basedfault
localization. Softw. Test. Verification Reliab. 25,5-7(2015),605â€“628.[52]Spencer Pearson, JosÃ© Campos, RenÃ© Just, Gordon Fraser, Rui Abreu, Michael D
Ernst, Deric Pang, and Benjamin Keller. 2017. Evaluating and improving fault
localization.In 2017IEEE/ACM39thInternationalConferenceonSoftwareEngi-
neering (ICSE). IEEE, 609â€“620.
[53]John Regehr, Yang Chen, Pascal Cuoq, Eric Eide, Chucky Ellison, and Xuejun
Yang.2012. Test-casereductionforCcompilerbugs.In ACMSIGPLANConference
on Programming Language Design and Implementation. 335â€“346.
[54]AnthonyM.Sloane.1999. DebuggingEli-GeneratedCompilersWithNoosa.In
Compiler Construction, 8th International Conference, CCâ€™99, Held as Part of the
European Joint Conferences on the Theory and Practice of Software. 17â€“31.
[55]Jeongju Sohn and Shin Yoo. 2017. FLUCCS: using code and change metrics to
improve fault localization. In Proceedings of the 26th ACM SIGSOFT International
Symposium on Software Testing and Analysis. 273â€“283.
[56]SriramSrinivasan,MarcLanctot,ViniciusZambaldi,JulienPÃ©rolat,KarlTuyls,
RÃ©mi Munos, and Michael Bowling. 2018. Actor-critic policy optimization in
partially observable multiagent environments. In Advances in neural information
processing systems. 3422â€“3435.
[57]Pei-Hao Su,Pawel Budzianowski, Stefan Ultes, Milica Gasic, and Steve Young.
2017. Sample-efficient actor-critic reinforcement learning with supervised data
fordialoguemanagement. arXivpreprint arXiv:1707.00130 (2017).
[58]Chengnian Sun, Vu Le, Qirun Zhang, and Zhendong Su. 2016. Toward under-
standingcompilerbugsinGCCandLLVM.In Proceedingsofthe25thInternational
Symposium on Software Testing and Analysis. 294â€“305.
[59]Chengnian Sun, Yuanbo Li, Qirun Zhang, Tianxiao Gu, and Zhendong Su. 2018.
Perses: syntax-guided program reduction. In Proceedings of the 40th International
Conferenceon Software Engineering. 361â€“371.
[60]RichardSutton,DavidMcallester,SatinderSingh,andYishayMansour.2000. Pol-
icyGradientMethodsforReinforcementLearningwithFunctionApproximation.
Adv. Neural Inf. Process. Syst 12 (02 2000).
[61]R. S. Sutton and A. G. Barto. 1998. Reinforcement Learning: An Introduction.
IEEETransactions on Neural Networks 9, 5 (1998), 1054â€“1054.
[62]Konda Vijay, R. and Tsitsiklis John, N. 2000. Actor-critic Algorithms. SIAM
Journalon Control and Optimization (April2000).
[63]MnihVolodymyr,BadiaAdriÃ ,PuigdomÃ¨nech,MirzaMehdi,andGravesAlex.
2016. AsynchronousMethodsforDeepReinforcementLearning.In ICML2016 .
1928â€“1937.
[64]Song Wang, Taiyue Liu, and Lin Tan. 2016. Automatically learning semantic
features for defect prediction. In Proceedings of the 38th International Conference
on Software Engineering. 297â€“308.
[65]XiWang,NickolaiZeldovich,M.FransKaashoek,andArmandoSolar-Lezama.
2013. Towards optimization-safe systems: analyzing the impact of undefined
behavior. In ACM SIGOPS 24th Symposium on Operating Systems Principles. 260â€“
275.
[66]ZanWang, MingYan,Junjie Chen,ShuangLiu,and DongdiZhang.2020. Deep
Learning Library Testing via Effective Model Generation. In The 28th ACM Joint
European Software Engineering Conference and Symposium on the Foundations of
Software Engineering. to appear.
[67]W. Eric Wong, Ruizhi Gao, Yihao Li, Rui Abreu, and Franz Wotawa. 2016. ASurvey on Software Fault Localization. IEEE Trans. Software Eng. 42, 8 (2016),
707â€“740.
[68]JifengXuanandMartinMonperrus.2014. LearningtoCombineMultipleRanking
Metrics forFault Localization.In 30th IEEEInternational Conferenceon Software
MaintenanceandEvolution . 191â€“200.
[69]Jifeng Xuan and Martin Monperrus. 2014. Test case purification for improv-ing fault localization. In Proceedings of the 22nd ACM SIGSOFT International
Symposium on Foundations of Software Engineering. 52â€“63.
[70]XuejunYang,YangChen,EricEide,andJohnRegehr.2011. Findingandunder-
standingbugsinCcompilers.In Proceedingsofthe32ndACMSIGPLANconference
on Programming language design and implementation. 283â€“294.
[71]AndreasZeller.2002. Isolatingcause-effectchainsfromcomputerprograms.In
Proceedings of the Tenth ACM SIGSOFT Symposium on Foundations of Software
Engineering. 1â€“10.
[72]Andreas Zeller and Ralf Hildebrandt. 2002. Simplifying and Isolating Failure-
InducingInput. IEEETrans. Software Eng. 28,2 (2002), 183â€“200.
[73]Lingming Zhang,MiryungKim, andSarfraz Khurshid. 2011. Localizingfailure-
inducing program edits based on spectrum information. In 2011 27th IEEE Inter-
nationalConferenceon Software Maintenance (ICSM) . 23â€“32.
[74]LingmingZhang,LuZhang,andSarfrazKhurshid.2013. Injectingmechanical
faultstolocalizedeveloperfaultsforevolvingsoftware.In Proceedingsofthe2013
ACM SIGPLAN International Conference on Object Oriented Programming Systems
Languages& Applications. 765â€“784.
[75]Qirun Zhang, Chengnian Sun, and Zhendong Su. 2017. Skeletal program enu-
meration for rigorous compiler testing. In Proceedings of the 38th ACM SIGPLAN
Conferenceon Programming Language Design and Implementation. 347â€“361.
