Supporting Quality Assurance with Automated
Process-Centric Quality Constraints Checking
Christoph Mayr-Dorn
Johannes Kepler University
Linz, Austria
christoph.mayr-dorn@jku.atMichael Vierhauser
Johannes Kepler University
Linz, Austria
michael.vierhauser@jku.atStefan Bichler
Johannes Kepler University
Linz, AustriaFelix Keplinger
Johannes Kepler University
Linz, Austria
Jane Cleland-Huang
University of Notre Dame
Notre Dame, USA
JaneHuang@nd.eduAlexander Egyed
Johannes Kepler University
Linz, Austria
alexander.egyed@jku.atThomas Mehofer
Frequentis AG
Vienna, Austria
thomas.mehofer@frequentis.com
Abstract ‚ÄîRegulations, standards, and guidelines for safety-
critical systems stipulate stringent traceability but do not pre-
scribe the corresponding, detailed software engineering process.
Given the industrial practice of using only semi-formal nota-
tions to describe engineering processes, processes are rarely
‚Äúexecutable‚Äù and developers have to spend signiÔ¨Åcant manual
effort in ensuring that they follow the steps mandated by quality
assurance. The size and complexity of systems and regulations
makes manual, timely feedback from Quality Assurance (QA)
engineers infeasible. In this paper we propose a novel framework
for tracking processes in the background, automatically checking
QA constraints depending on process progress, and informing
the developer of unfulÔ¨Ålled QA constraints. We evaluate our
approach by applying it to two different case studies; one open
source community system and a safety-critical system in the air-
trafÔ¨Åc control domain. Results from the analysis show that trace
links are often corrected or completed after the fact and thus
timely and automated constraint checking support has signiÔ¨Åcant
potential on reducing rework.
Index Terms‚Äîsoftware engineering process, traceability, de-
veloper support
I. I NTRODUCTION
Software quality assurance (QA) focuses on ensuring and
attesting that the engineering processes result in appropri-
ate quality of the software. To this end, various regula-
tions, standards, and guidelines stipulate stringent traceabil-
ity paths [1], [2], but don‚Äôt prescribe the corresponding,
detailed software engineering process. Examples in safety-
critical systems include the FDA principles in the medical
domain, DO-178C/ED-12C for airborne systems, ED-109A
for air trafÔ¨Åc management systems, and Automotive SPICE in
the automotive industry. Here, QA engineers need to inspect
Ô¨Åne-grained constraints over properties of engineering artifacts
(i.e., requirements, models, code, test cases, etc.) as well as
trace links at speciÔ¨Åc points in time (i.e., in different process
steps such as requirement elicitation, speciÔ¨Åcation reÔ¨Ånement,
coding, or test case speciÔ¨Åcation). The current practice in
industry, however, is to use semi-formal descriptions to specify
processes [3]. As a result, software engineering processes are
rarely ‚Äúexecutable‚Äù, meaning that there is little to no automatedsupport for checking whether these processes are followed, and
to what extent deviations occur during development.
In this paper we speciÔ¨Åcally address the problem of Devel-
opers andQuality Assurance Engineers being overwhelmed by
the complexity and extent of adhering to, and evaluating, QA
constraints. Typically, developers work on multiple projects,
sometimes simultaneously, with each project having different
quality standards or guidelines.
In an informal study with our industry partners, developers
reported being stressed about potentially missing important
steps mandated by quality assurance. QA Engineers, on the
other hand, need to conduct countless, tedious, often mind
numbing checks that involve (manually) navigating across
diverse artifacts and tools to ensure that the required con-
straints are fulÔ¨Ålled at the right process step. These checks
are error prone and rarely conducted in time to provide
immediate feedback to developers. Remediating problems later
on, however, interrupts developers who may have already
moved on to other steps or projects, causing even further delay.
In this paper we present a novel approach that aids de-
velopers and quality assurance engineers to reduce the effort
required in ensuring that development activities adhere to the
intended process ‚Äì ultimately leading to less rework. Our
approach relies on passive process execution, achieved by
tracking process steps via monitoring engineering artifacts
such as requirements, design documents, issues, change re-
quests, and tests. This is complemented by constant evaluation
of quality constraints. The key novelty is treating (quality) con-
straints neither as an implicit part of the engineering process
model nor as completely disjunct from it. Instead, we propose
treating (quality) constraint evaluations as Ô¨Årst class citizens:
i.e., as explicit development artifacts that determine process
progress. This contrasts with existing work on traceability
[2], [4] where links required by regulations and standards are
typically veriÔ¨Åed by an auditor at the end of a process stage
or prior to shipping the Ô¨Ånal product [5]. Similarly, work on
constraint checking [6], [7] primarily focuses on consistency
among diverse artifacts without addressing consistency issues
12982021 IEEE/ACM 43rd International Conference on Software Engineering (ICSE)
1558-1225/21/$31.00 ¬©2021 IEEE
DOI 10.1109/ICSE43902.2021.00118
between these artifacts and the underlying process.
The key contributions of this paper are as follows:
A process model that decouples process control and data
Ô¨Çow from QA constraints.
A passive process engine which explicitly tolerates in-
consistencies [8] and allows engineers to temporarily
deviate from the process while providing them with
timely feedback on QA constraint evaluation results.
A prototype that helps developers clearly understand
when they have completed a step or what they still need
to provide (e.g., speciÔ¨Åc content or trace links).
An evaluation against an open source system for un-
manned aerial vehicles (UA Vs) and an industrial air trafÔ¨Åc
control system (ATC), that measures the extent to which
the prescribed process was followed.
The remainder of this paper is structured as follows. Sec-
tion II motivates our work by describing constraint checks for
the development of safety-critical systems. Sections III and IV
provide an overview of our approach and introduce details on
modeling the process and constraints. We then evaluate our
approach using two distinct case studies in Section V, and
conclude with a discussion of results (Section VI), threats to
validity (Section VII), and related work (Section VIII).
II. M OTIVATING EXAMPLE
Our industry partner Frequentis is a world leading voice
communication provider for air-trafÔ¨Åc control and command-
control centers. In this domain the DO-278/ED-109 stan-
dard [9] speciÔ¨Åes traceability requirements according to dif-
ferent design assurance levels, ranging from ‚ÄúCatastrophic‚Äù to
‚ÄùMinor‚Äú or ‚Äúno Effect‚Äù.
However, while DO-278/ED-109 deÔ¨Ånes which trace links
need to be available, it does not specify when these trace links
need to be established or who should/must perform this task.
Figure 1 (left) depicts a partial traceability information
model (TIM) and excerpts from a simpliÔ¨Åed development
process representation (right) for one Frequentis product. The
process example indicates that once high-level requirements
(HLReq) and high-level design speciÔ¨Åcations (HLSpec) are
reviewed, HLReq may be reÔ¨Åned into low-level requirements
(LLReq) and cause updates to the low-level design speciÔ¨Å-
cation (LLSpec). Thus, developers should not start reÔ¨Åning
LLReq without the outcome of the review, even though
HLReqs and teams are already assigned to work packages
during the development iteration planning phase. Additionally,
before the implementation of LLReq can start, trace links from
HLReq to LLReq and trace links from LLReq to LLSpec need
to be reviewed. Constraints that are set up for the development
process are not only used to check for the existence of an
artifact or the existence of a trace link between the right
type of artifacts. Constraints build on the properties of an
artifact at a speciÔ¨Åc process progress. At the end of step
S3 (cf. Figure 1) the respective LLReqs need to be in state
‚ÄúComplete‚Äù, each having a trace link to a HLReq. Upon
completion of step S7 when a LLReq‚Äôs veriÔ¨Åcation method
is ‚ÄúDemonstration‚Äù, then there must exist at least one tracelink to a respective Test Case which is not of type ‚ÄúSoftware
Test Case‚Äù (but, for example, a simulation, demonstration,
or acceptance test). These constraints are complementary to
human-in-the-loop QA measures such as the trace reviews in
S5 and S6. The automated checks reduce the effort for these
reviews by ensuring the traces under review are syntactically
correct and thus the review can be done more efÔ¨Åciently.
Engineers who are updating the LLSpec (in S4), for exam-
ple, thus need to be aware when they may start with their step
to avoid rework if additional reÔ¨Ånements of an LLReq occur.
Similarly, engineers in S7 need timely feedback when they
can claim to have Ô¨Ånished implementation and thus trigger
the review in S8.
Knowing the state of the process helps assess the risk of
deviation. Starting early on HLReq reÔ¨Ånement (S3) may be too
risky if none of the requirements have gone through review in
S1 and S2 but perhaps necessary and ok due to time pressure
when S2 has only a few requirements left to review. The
following sections use this TIM, process, and constraints as
a running example to better explain process and constraint
modeling, as well as execution.
Fig. 1: Frequentis‚Äô simpliÔ¨Åed traceability information model
(TIM) excerpt (left) and process model excerpt (right).
III. A PPROACH ‚Äì THEPROCONFRAMEWORK
In this section we provide a comprehensive overview of
ProCon, our passive Process execution and quality Constraint
support framework. Two key aspects that characterize our
framework are: Ô¨Årst, the integrated handling of explicitly
distinct processes and constraints, and second, the tracking
of engineering progress achieved through explicitly linking
process descriptions to software engineering artifacts.
In ProCon, a passively executable Process SpeciÔ¨Åcation
describes the sequence and alternatives of carrying out en-
gineering activities (i.e., the ‚Äúcontrol Ô¨Çow‚Äù) and the software
engineering artifacts that serve as inputs and outputs of those
activities (i.e., the ‚Äúdata Ô¨Çow‚Äù). Explicitly modeling a software
engineering process for controlling the software engineering
life-cycle is not new, with a plethora of research dating back
until the 90s [10]‚Äì[13]. ProCon is different insofar as that
(i) the process is tracked in the background, based on the
1299Fig. 2: The ProCon framework.
software engineers‚Äô activities performed in the tools they are
using in their daily work rather than requiring engineers to
interact with a process engine, (ii) engineers are free to deviate
from the process, (iii) engineers may receive guidance even in
the presence of deviation, and (iv) ProCon supports control-
and dataÔ¨Çow conditions as well as constraints across diverse
artifact types and tools.
We refer to these abilities as ‚Äúpassive execution‚Äù as our
framework goes beyond simple process monitoring by deter-
mining available future steps, detecting premature steps, and
making this information immediately available to engineers.
With ProCon, deviations from the process are tracked via
process and quality constraints. These constraints, and their
respective evaluation results, are treated as Ô¨Årst-class citizens
in the software engineering process (model), hence are explicit
software engineering artifacts of their own. This in turn allows
for explicitly evaluating constraints as soon as actions are
performed and constraint evaluation results can provide valu-
able insights about the status of the process beyond whether
a step has been completed or not. Additionally, treating
constraints and their evaluation results as Ô¨Årst-class citizens
makes reuse and maintenance less cumbersome. Constraints
may be modiÔ¨Åed over time to accommodate changes in
the organization‚Äôs process, or may apply in diverse process
contexts, making them amenable to product line engineering
approaches. Imagine applying the concepts of software product
line engineering for better managing the variations in process
and QA concerns found in a larger organization [14].
A. ProCon High-level Architecture
ProCon consists of four major elements (depicted in Fig-
ure 2) that together allow deÔ¨Åning, checking, and maintaining
the process and development artifacts of an organization:
Existing Semi-informal process deÔ¨Ånitions, standards,
guidelines, and regulations serve as the initial input for Pro-
Con. Typically, these already exist within an organization anddescribe (and motivate) the prescribed processes and quality
assurance measures. Process deÔ¨Ånitions may be SPEM [15]
documents, PDFs with Ô¨Çowcharts, or simple text documents
outlining the steps and responsibilities of the different roles.
The process deÔ¨Ånitions are complemented by ‚Äì and used
in conjunction with ‚Äì a variety of diverse Tools within an
organization to create, update, and maintain the artifacts that
represent the input and output of the different process steps.
Artifacts such as issues often serve as a (partial) informal
representation of process instances. Tool Connectors (B) for
the respective tools provide (machine readable ‚Äì e.g., as JSON
data via a REST API) access to artifacts. These connectors
take on sophisticated tasks such as obtaining artifact updates
(via polling or subscriptions), managing which artifacts are
relevant for a process and thus need to be monitored, caching
the artifacts for quick repeated access, and keeping this cache
up to date (cf. Section V-A).
Passively Executable Process SpeciÔ¨Åcations and Con-
straints (C) are manually derived (cf. Section IV-A and IV-B,
respectively) based on the above two main inputs. Process
SpeciÔ¨Åcations formalize the (semi-)informal process deÔ¨Åni-
tions and guidelines and allow a Ô¨Åne-grained mapping to the
respective artifacts, properties, and their changes observable
via the tool connectors.
ThePassive Process Engine (D) manages instances of pas-
sively executable process speciÔ¨Åcations (or Process Instances
for sake of brevity). The passive process engine obtains artifact
state and events from tool connectors (E), feeds these changes
into a rule engine in which the process progress conditions
and QA constraints are evaluated. The rule engine eventually
Ô¨Åres events that the process engine utilizes to update the
process progress and quality constraint evaluation results (cf.
Sections IV-C and IV-D, respectively).
A web-based Process Dashboard makes Process progress
and QA constraint evaluation results (F) continuously available
to software engineers. It allows controlling the passive process
instance: triggering new instances, observing their progress,
and eventually archiving them (cf. Section V-A).
B. ProCon Usage
ProCon users are primarily QA engineers and developers,
but also include stakeholders such as product managers and
team leads. The former can use the framework with a focus
on quality assurance (the focus of this paper), while the latter
can use the framework with a focus on process progress.
Based on this, ProCon supports two distinct use cases.
In the process and constraint modeling use case, various
stakeholders map the informal process deÔ¨Ånitions, standards,
etc. (A) to passively executable process speciÔ¨Åcations (C). This
phase involves analyzing how engineers currently produce
evidence of process execution in the various tools (B). The
tool connectors describe what artifact properties are available
and thus what change events may serve as process progress
triggers during process execution: for example, what (custom)
properties are used for various Jira issues, what trace links are
available to navigate from a Jira [16] issue to a requirement
1300managed in Jama [17]. The outcome of the modeling use case
is a passively executable process speciÔ¨Åcation and its quality
constraints.
Note, that our approach does not require modeling the
complete process if tools don‚Äôt allow access to certain infor-
mation. One would typically start with those parts that are
most important, or most error prone, etc and focus on these.
Ambiguity may arise, for example, if rules expect one trace to
navigate to an artifact but Ô¨Ånd multiple ones, then a random
one will be selected. Mitigation includes correcting and/or
extending QA-constraints to identify the ambiguous situation.
In line with Lee Osterweil‚Äôs key observation that ‚Äúsoftware
processes are software, too‚Äù [18] we advocate the use of con-
temporary software engineering practices such as developing
in iterations, testing, versioning, and issue tracking. A key
element here is replaying of the artifacts‚Äô history to test the
constraints‚Äô ability to detect deviations [19].
The second use case focuses on the passive process exe-
cution. Upon process instantiation, the passive process engine
obtains artifacts and their changes as they occur in tools (D).
The engine then tracks the progress of each step and attached
constraints. It determines completed and in progress steps
(Figure 2 center, with solid border), which steps an engineer is
free to start next, and which ones should not yet start (dashed
border). Artifact and process updates trigger reevaluation of
constraints (document symbols with icons). ProCon users
then access the process progress and constraint evaluation
results (E). An engineer may notice an unfulÔ¨Ålled constraint,
conducts the necessary artifact changes via the tools, triggers
reevaluation, and conÔ¨Årms quality constraint fulÔ¨Ållment. Note
that users exclusively affect process progress and constraint
evaluation results via tool interactions (F) and never via direct
interaction with the passive process engine itself (except for
explicit triggering of quality constraint evaluation). In the next
section we describe the process and constraint modeling in
more detail as well as process execution.
IV. P ROCESS , CONSTRAINT MODELING ,AND EXECUTION
The following section describes how Process SpeciÔ¨Åcations
are structured and executed, and discusses the elements and
transitions of the ProCon Process SpeciÔ¨Åcation metamodel.
A. Process SpeciÔ¨Åcation Model
The challenge when passively executing processes is deter-
mining the steps that are currently available for engineers to
work on, steps that represent work in progress (but perhaps
shouldn‚Äôt be worked on yet), and Ô¨Ånally, steps that have been
(successfully) completed. The prevalent differences to existing
approaches hereby are not the basic building blocks (i.e., the
process steps) but rather in how transitions between these steps
are deÔ¨Åned and subsequently triggered. Figure 3 (left) provides
a simpliÔ¨Åed UML class diagram of the process model‚Äôs main
elements. The two main elements of the process model are
Steps andDecision Nodes attached to them.
AStep describes what an engineer ‚Äúshould‚Äù do (in contrast
to ‚Äúmust‚Äù do ‚Äì as prescribed by a a more restrictive traditionalprocess). For example, reÔ¨Åne a requirement, implement a fea-
ture, deÔ¨Åne a test case. A step has zero or more Input artifacts
attached that represent required data to make a decision or
artifacts that need to be modiÔ¨Åed. It further has zero or more
Output artifacts that describe the effect of having executed
the step (e.g., having modiÔ¨Åed an input artifact or created a
new artifact). Input and output artifacts can represent any kind
of information such as requirements, tests, issues, or trace
links. In addition to the textual description of an engineer‚Äôs
activity, a step consists of a set of event-condition-action rules
that deÔ¨Åne which event(s) from the engineering environment
(e.g., an artifact update), given additional constraints (i.e., the
condition) trigger the inclusion of an artifact to a step‚Äôs output
artifact set (i.e., the action part of the rule). For example in
S5, ‚ÄúWhen an engineer posts a review URL as a Jira issue
comment, then add that link as the step‚Äôs output artifact‚Äù.
ADecision Node describes how the completion of one or
more Steps ‚Äì and additional conditions ‚Äì leads to the execution
of subsequent steps. The set of decision nodes thus deÔ¨Ånes
the process‚Äô control Ô¨Çow. A decision node‚Äôs DataTransfer
declaration describes how the output of one step becomes the
input of a subsequent step, thereby deÔ¨Åning the process‚Äô data
Ô¨Çow. For example, ‚ÄúThe LLReq output artifacts of S3 and
LLSpec output artifacts of step S4 become the input artifacts
to step S6‚Äù. Note that a step may only have one preceding
and one subsequent decision node to avoid conÔ¨Çicting control
or data Ô¨Çow. Only a decision node may link to multiple steps.
Ultimately, a process consists of a set of steps and decision
nodes that create a single connected, directed graph. Note that
currently loops are not yet supported as the use cases at our
industry partner did not require this feature for two reasons:
Ô¨Årst, artifacts can be updated over and over again until QA-
constraints are fulÔ¨Ålled. Second, longer, explicit loops such as
sprints are typically represented as separate sub/processes and
thus are ‚Äúspawned‚Äù separately.
The speciÔ¨Åc activation conditions are placed on the InFlows
(from preceding steps to decision node), on the node itself, and
on the OutFlows (from decision node to subsequent steps).
Figure 3 (right) outlines how these conditions reÔ¨Çect in a
decision node‚Äôs state.
AVAILABLE : upon instantiation, a decision node is in
theAVAILABLE state. Depending on a decision node‚Äôs
InFlowType: AND, OR, XOR, it will check upon each
update of preceding steps whether all, at least one, or
exactly one InFlow are fulÔ¨Ålled to transition the node
intoPASSEDINCONDITIONS.
PASSED INCONDITIONS : in this state, conditions
independent on any preceding step, such as process or
date-time centric conditions need to be fulÔ¨Ålled before
transitioning into PASSED CONTEXT CONDITIONS.
PASSED CONTEXT CONDITIONS : in this state, the
decision node evaluates OutFlows. OutFlow conditions
serve as a Ô¨Ålter to dynamically select the relevant sub-
sequent steps to enable. Depending on a decision node‚Äôs
OutFlowType (AND, OR, XOR), it will check whether
all or at least one OutFlow is fulÔ¨Ålled, then transitioning
1301Fig. 3: Process speciÔ¨Åcation meta model: UML class diagram and state charts.
intoPASSED OUT CONDITIONS. In case of XOR, we
still need to enable all steps of fulÔ¨Ålled OutFlows as this
indicates a situation where the engineer decides which
one is the relevant one.
PASSED OUT CONDITIONS : this is a temporary state
to separate between having fulÔ¨Ålled all OutFlow condi-
tions and having also instantiated the subsequent steps
including data transfer.
PROGRESSED : all subsequent steps identiÔ¨Åed by Out-
Flow conditions are instantiated and have the required
input artifacts available according to the speciÔ¨Åed data
transfer.
As long as a decision node hasn‚Äôt reach PROGRESSED, any
change to the InFlow, context, and OutFlow conditions will
transition the state back to an earlier state.
Note that the conditions on InFlow, context, and OutFlow
are optional. For example, the decision node between step S1
and step S2 (not shown in Figure 1) does not have any of these
three conditions. Upon completion of S1 it will immediately
transition through all these states into state PROGRESSED,
thus serving as a simple trigger to activate step S2.
In addition to the decision node state, tracking each step‚Äôs
state is vital to provide developers with feedback on which
steps are ready for starting, which ones have started too early,
and which ones should not be done. Figure 3 (middle) depicts
a step‚Äôs life-cycle modeled as a Ô¨Ånite state machine.
AVAILABLE : when a step is instantiated it resides in
theAVAILABLE state, indicating that it‚Äôs input is not
sufÔ¨Åcient yet (i.e., it has not yet obtained the necessary
data from the preceding decision node).
ENABLED : once all speciÔ¨Åed input conditions are met
(for example, required input artifacts are available), a
decision node causes the step to transition to ENABLED,
indicating that an engineer is free to start working on it.
ACTIVE : when Artifact-to-Step Mappings signal that
artifacts attached to the state are updated or modiÔ¨Åed,
the step becomes ACTIVE, indicating that an engineer is
actively working on it.
NOWORK EXPECTED : when multiple mutual exclu-
sive steps are ENABLED it can initially not be deter-
mined which of these an engineer has chosen. Once,one of the alternative steps transitions into ACTIVE, the
remaining steps transition into NOWORK EXPECTED.
REVOKED : when a step‚Äôs input conditions are no longer
fulÔ¨Ålled, it transitions into REVOKED to indicate that
an engineer should not/no longer work on this step, or if
starting, respectively continuing, may need rework later
on. Once the input conditions are re-established, the step
transitions back into ENABLED orACTIVE (depending
on its previous state). The key difference between a
REVOKED step and NOWORK EXPECTED step is
that the former should eventually be carried out, while
the latter should not be carried out at all.
COMPLETED : when all output conditions are met (e.g.,
all required output artifacts are available), the step tran-
sitions into COMPLETED and triggers the evaluation of
the step‚Äôs subsequent decision node.
B. Quality Constraint Integration
For each step, Quality Constraints can be deÔ¨Åned describing
conditions the created or updated output artifacts must adhere
to. A constraint can refer to a step‚Äôs input and output artifacts,
its metadata, or process metadata.
Each constraint has an identiÔ¨Åer that allows triggering
constraints not only upon artifact changes but also manually,
on demand. This is important to provide control to the user and
to allow, for example, an engineer to trigger a constraint check
to reassure him/her that a step is indeed complete and nothing
has been overlooked. The language in which constraints are
implemented is Ô¨Çexible and can vary depending on the domain
or application scenario. The only requirement is that it has
to provide respective evaluation results (we provide further
examples on constraints and the constraint language as part of
the use cases in Section V) .
Every time a quality constraint is evaluated, a corresponding
new instance of Quality Constraint Evaluation Result is cre-
ated, reporting the result (i.e., fulÔ¨Ålled or unfulÔ¨Ålled) and lists
the artifacts subject to that constraint. For example, a constraint
for step S6 checks whether each low-level requirement (LL-
Req) output artifact has a trace link to a high-level requirement
(HLReq) which must be in state ‚Äúreleased‚Äù. Therefore, the
respective constraint evaluation result will contain the list
of LLReqs that fulÔ¨Åll this constraint, and a list of LLReqs
1302that violate this constraint. For every constraint, we further
store timestamps indicating when the constraint evaluation
result was (last) evaluated, and when the evaluation result last
changed from violated to fulÔ¨Ålled and vice versa. This, for
example, allows to infer how recent results are when shown
on the Process Dashboard. The evaluation results of all quality
constraints associated with the same step are collected and
bundled in a Quality Check Document which is added to the
output artifacts of that step.
The process model itself remains largely independent from
constraints and their evaluation results. While a process step‚Äôs
completion constraint must check whether a Quality Check
Document output artifact exists which contains only posi-
tive Quality Constraint Evaluation Result s, it doesn‚Äôt need
to understand the particular constraints that resulted in the
evaluation success. This loose coupling allows to execute the
same process with different levels of quality assurance by
switching in and out different quality constraints.
C. Passive Process Execution
Every process model comes with an activation condition,
typically an explicitly added artifact such as a change request
issue or work package issue that already serves as some form
of process representation. The process engine instantiates the
process and checks which steps and decision nodes can be
instantiated based on the provided activation artifact. Instan-
tiation occurs incrementally, i.e., only when a step reaches
the state ENABLED, will the process engine instantiate the
step‚Äôs subsequent decision node. Similar, only when a decision
node is in state PASSEDOUTFLOW CONDITIONS, will
the engine instantiate the steps identiÔ¨Åed by the outÔ¨Çow links.
With step instantiation, the engine also instantiates the quality
check constraints. Thus, as long as a step doesn‚Äôt exist, none
of its constraints will be checked.
In the passive process engine, incremental step and decision
node instantiation is insufÔ¨Åcient as engineers may decide to
work on steps not yet ready. When artifact changes trigger
Artifact-to-Step Mappings, the process engine will instantiate
the corresponding ‚Äúpremature‚Äù step and attempts to Ô¨Ånd an
existing preceding decision node that this step can be linked
to. If none exists yet, the step remains dangling in the process
until the process progress catches up: i.e., upon instantiating a
decision node, the engine checks if a dangling step exists that
should be linked via one of the decision node‚Äôs out Ô¨Çow links.
From the engine‚Äôs point of view, there is no difference between
missing a step and starting the next, or starting too early on the
next step. It will continue either way. In such as case, however,
then the engine will not be able to fully execute a DataTransfer
that requires the output of the skipped/incomplete step. The
consequence is then highlighted via the step‚Äôs status as having
insufÔ¨Åcient input artifacts.
Note that assessing the impact of prematurely starting a
step and how to mitigate any potential change propagation
is outside the scope of this paper. Premature steps stand
out from regular steps by having transitioned directly from
A V AILABLE to ACTIVE.D. Constraint Checking
We made the deliberate decision to execute constraint
checks upon explicit request and not automatically triggered
by every single artifact change. Often a single change is
not indicative of step completion. The reasons behind this
are manifold. First, as quality constraints often span across
multiple artifacts, a single change to an artifact is insufÔ¨Åcient,
multiple changes need to occur. For example in S6: not just one
low level requirement (LLReq) needs to be set to ‚Äúreleased‚Äù
but all linked ones. Second, an artifact may be involved in
multiple constraints, thus a change would trigger execution
of multiple constraints. Third, reevaluation on every change
puts unnecessary burden on the process engine, respectively
its constraint evaluation subsystem. Forth, when quality con-
straints involve diverse artifact types managed in different
tools, change events from these tools may not be readily
available as the engineer carries out the change in these tools
but need to be fetched periodically. Jama, for example, doesn‚Äôt
offer automatic event notiÔ¨Åcations but requires polling with
subsequent explicit fetching of changed artifacts. This would
result in executing checks on stale data.
V. E VALUATION
We evaluated ProCon against two distinct use cases for
which we created process speciÔ¨Åcations and constraints, and
implemented connectors for different issue tracking and re-
quirements management tools. The Ô¨Årst use case, Dronol-
ogy [20] ‚Äì an open source project ‚Äì represents an more agile,
lightweight process, whereas the second one ‚Äì a safety-critical
system in the air trafÔ¨Åc management domain ‚Äì describes a
rigid, standardized process with stringent quality assurance
criteria. We report on the application of ProCon to the two use
cases and our Ô¨Åndings and lessons learnt. Supplemental online
material [21] provides artifact data and trace links, process
deÔ¨Ånitions including constraints, and the experiment results.
The prototype source code is publicly available [22].
A. Prototype Implementation
We implemented a prototype to evaluate the two use cases
and to obtain feedback from our industry partner Frequentis.
Tool Connectors: To cover a reasonably large set of arti-
facts from our industry partner Frequentis and from Dronol-
ogy, we implemented connectors for Jira, a web-based tool for
planning, issue tracking, and reporting, and Jama, a tool for
requirements management, traceability, and test management.
The Jira Connector uses the Atlassian Java REST API to
retrieve artifacts and their attributes and is used to periodically
poll for changes in these artifacts. Similarly, the Jama connec-
tor uses the Jama REST API. To reduce load on network and
tools, the tool connectors cache Jira and Jama artefacts in a
CouchDB (a schemaless JSON database).
Process Engine: The Process Engine is implemented in
Java, containing an implementation of the process speciÔ¨Åcation
metamodel and a rule engine for checking constraints. We
opted for the Drools rule engine [23], a Business Rules
Management System that can be easily integrated into a Java
1303Fig. 4: ProCon Process Dashboard.
application and allows easy access to Java objects (represen-
tations of Jira and Jama artifacts) within rules written in a
Java dialect. Additionally, we persist the processes and Quality
Check Documents (including Quality Constraint Evaluation
Results) attached to the different process steps in a Neo4J
graph database. The graph structure simpliÔ¨Åes fetching all
related process steps, decision nodes, input and output artifact
(references), and quality check documents in a single query to
be shown on the process dashboard.
Passive Process SpeciÔ¨Åcations and QA Constraints: The
Drools rule engine evaluates process progress conditions and
quality constraints. We therefore deÔ¨Åned quality constraints as
well as the decision nodes‚Äô control and dataÔ¨Çow conditions in
respective Drools rules Ô¨Åles.
Process Dashboard: Figure 4 shows the user interface for
inspecting quality constraint evaluation results. The results
contain browseable links to the original artifacts thus enable
the engineers to quickly switch into their usual tools (here
Jama and Jira) to Ô¨Åx any unfulÔ¨Ålled constraints.
B. Open Source Use Case: Dronology
Dronology is a UA V management and control system pro-
viding a full project environment for managing, monitoring,
and coordinating the Ô¨Çights of multiple UA Vs. It can interact
with real hardware as well as a high-Ô¨Ådelity Software-in-
the-Loop simulator that enables experimentation with virtual
UA Vs. Dronology was developed, with both students and pro-
fessional developers, over several years as a research incubator
with various development artifacts publicly available [20],
[24]. For the purpose of this case study we obtained permission
to use data from multiple sprints maintained in Jira from 2017
to 2019. This includes the following artifacts: Bugs, Hazards,
Requirements, Design DeÔ¨Ånitions, Tasks, and Sub-Tasks.
Process and Constraint Creation: We treat each of these
issues as ‚Äúsmall sub processes‚Äù where the issue‚Äôs state rep-
resents a process step, and quality constraints for each step
describe the conditions that need to be fulÔ¨Ålled to transition
from one step to the next, respectively complete the process
(i.e., close the issue). Given the lean nature of typical agileopen source development processes the states were limited
to the default process steps in Jira, ‚ÄúOpen‚Äù, ‚ÄúInProgress‚Äù, and
‚ÄúClosed‚Äù. Based on the information available, we identiÔ¨Åed the
following eight quality constraints and allocated them to the
steps where they are most useful (note that some constraints
are reusable for multiple issue types). Process and constraint
creation took around 3 hours. We then contacted one of the
lead developers to conÔ¨Årm the validity of the constraints and
the process. An overview of the constraints can be found in
Table I. At the end of step ‚ÄúOpen‚Äù, we require constraints D-
C1 to D-C5 to be fulÔ¨Ålled, and at the end of step ‚ÄúIn Progress‚Äù
we require constraints D-C6 and D-C7 to be fulÔ¨Ålled.
C. Industry Use Case: Frequentis
For the Frequentis use case we selected a safety-critical
product for voice communication in air trafÔ¨Åc control centers.
The product consists of several subsystems for interfacing
with radio transceivers, managing near-real time voice streams,
and providing operator user interfaces. Frequentis follows a
V-model like engineering process. SpeciÔ¨Åcally, for this case
study, we focused on sub work packages (SubWP). This
process for each team (each responsible for one subsystem)
starts with high-level requirements resulting in the actual
implementation and the successful execution of test cases. This
covers steps S3 to S8 of the motivating scenario. Trace links
between SubWP‚Äôs and low-level requirements are therefore
the main focus of QA constraints deÔ¨Åned as the completion
conditions of steps S3 (represented by ATC-C1 to ATC-C4),
S4 (ATC-C5), S7 (ATC-C6 and ATC-C7), and S8 (ATC-C8)
(cf. Table I). Frequentis uses Jama to manage all artifacts and
trace links depicted in Figure 1 and uses Jira to manage the
engineering process.
Process and Constraint Creation: We deÔ¨Åned the con-
straints together with a QA engineer within two hours, and
took another two hours to specify the process. Frequentis‚Äô
informal process deÔ¨Ånition precisely deÔ¨Ånes how engineers
need to set properties of Jira and Jama artifacts for completing
the various steps. Changes to these properties serve as step
completion signals in our process engine.
D. Data Gathering
We were granted access to the Dronology project‚Äôs Jira
server REST API to obtain artifacts and their change history.
The data set consists of 802 process instances (i.e., Jira issues):
199 Tasks, 211 Sub-tasks, 109 Bugs, 247 Design DeÔ¨Ånitions,
and 36 Hazards. From Frequentis we obtained Jira issues
related to the aforementioned SubWPs. Each SubWP managed
in Jira has a corresponding Jama artifact with respective trace
links to LLReqs and subsequent artifacts. We used the Jama
REST API to navigate across these trace links to collect all
Jama artifacts (including their history) that are relevant for
constraint evaluation. This resulted in a set of 109 SubWPs and
14,000 linked Jama items (out of which 1,121 are LLReqs).
We used our trace link replay tool [19] to reset the entire
state of the dataset of Jira issues and Jama items and their
trace links to the earliest change event and then replayed
1304Constr. Description Issue Type
D-C1a The issue traces to one or more Design
DeÔ¨ÅnitionsTasks
D-C1b The issue traces to one or more Design
DeÔ¨Ånitions directly, or via its parentTask, Sub-Task
D-C2 The issue does NOT trace to a Requirement Task, Sub-Task
D-C3 The issue has an assignee Bug, Task,
Sub-Task
D-C4 The issue traces to a Requirement Design Def.
D-C5 The issue is mitigated by a Requirement
(i.e., trace type: isMitigated) or reÔ¨Åned by a
Hazard (i.e., trace type: isReÔ¨Åned)Hazards
D-C6 The issue has all related bugs (if any) closed Task, Sub-Task
D-C7 The issue has all sub-tasks (if any) closed Bug, Task
ATC-C1 All traced LLReq have status ‚Äúreleased‚Äù SubWP
ATC-C2 All traced LLReq have a release assigned SubWP
ATC-C3 All traced LLReq have a trace link to at
least one HLReqSubWP
ATC-C4 No traced LLReq has a trace to another
SubWP with a status other than ‚Äúclosed‚ÄùSubWP
ATC-C5 All traced LLReq have a trace link to ex-
actly one Functional UnitSubWP
ATC-C6 All traced LLReq have a link to at least
one test case matching the requirement‚Äôs
veriÔ¨Åcation methodSubWP
ATC-C7 The SubWP‚Äôs Jira issue has at least one ‚ÄúFix
version‚Äù.SubWP
ATC-C8 The SubWP‚Äôs Jira issue is set to ‚Äúresolved‚Äù SubWP
TABLE I: Constraints for the Dronology system (preÔ¨Åx ‚ÄúD‚Äù)
and the Frequentis system (preÔ¨Åx ‚ÄúATC‚Äù).
every single change in the correct temporal order. The changes
occurred between April 2017 and December 2019 for Dronol-
ogy and between May 2018 and June 2020 for Frequentis,
respectively. Using the replay tool allowed us to start from
the beginning of the development process and, step-by-step,
simulate (i.e., ‚Äúreplay‚Äù) changes made by engineers (e.g.,
modify the state of artifacts in Jira, add trace links, etc.)
allowing us to automatically trigger constraint checks and track
the process state the same way as in a ‚Äúlive‚Äù environment. For
each constraint evaluation we evaluated (i) whether a step‚Äôs
Quality Check Document was fulÔ¨Ålled; (ii) which constraints
were (not) fulÔ¨Ålled; and (iii) whether a step became active
without the constraints of the previous one(s) being fulÔ¨Ålled.
Additionally, for a process instance (i.e., a Jira artifact),
we collected the following metrics: number of Quality Check
Documents un/fulÔ¨Ålled; number of un/fulÔ¨Ålled constraints;
number of constraint checks performed; and the maximum
number of past steps with unfulÔ¨Ålled constraints (i.e., how
many steps an engineer advanced ahead without having the
completion condition of the previous steps fulÔ¨Ålled).
E. Process Replay Results
Table II reports the QA constraint evaluation results across
multiple process instances, grouped per process type. Row
AlwaysOk shows the numbers of process instances whereengineers only progressed to subsequent steps when all quality
constraint in previous steps were fulÔ¨Ålled. Row EventualOk
shows the processes for which all constraints were eventu-
ally fulÔ¨Ålled. The row CompleteNotOk shows processes for
which some constraint were never fulÔ¨Ålled. Row IncompleteOk
counts those process instances that were not Ô¨Ånished by the
end date of the timeframe but had all mandated constraints
up to their current state fulÔ¨Ålled. Row IncompleteNotYetOk
counts the partially completed process instances with unful-
Ô¨Ålled constraints but no progress beyond those not fulÔ¨Ålled
steps, in contrast to those with progress beyond in row
IncompleteProgressedNotOk. Percentage values are reported
relative to the sum of completed process instances, respectively
sum of incomplete process instances.
Dronogy: we noticed that for ‚ÄúTask‚Äù processes no com-
pleted process instance (i.e., Ô¨Ånished ‚ÄúTask‚Äù) ever fulÔ¨Ålled
every constraint before moving from one step to the next, yet
around 30% fulÔ¨Åll all their constraints at the end, with 70%
remaining unfulÔ¨Ålled at the end. ‚ÄúSub-task‚Äù processes see
30% of instances ‚Äúcorrectly‚Äù carried out, with only 50%
not fulÔ¨Ålling their constraints. ‚ÄúBug‚Äù processes are almost
always correctly executed. ‚ÄúDesign DeÔ¨Ånition‚Äù and ‚ÄúHazard‚Äù
processes are either correctly carried out from the beginning
(the vast majority), or remain with unfulÔ¨Ålled constraints.
Observing the incomplete process instances we encounter an
expected large number of processes with unfulÔ¨Ålled constraints
(i.e., hinting at steps with associated QA constraints that
are not complete yet). However, we notice that only in a
low percentage (< 20% for IncompleteProgressedNotOk ) of
instances have engineers started too early on subsequent steps
without having fulÔ¨Ålled the previous steps‚Äô constraints.
Frequentis: we noticed two aspects. First, the amount
of SubWPs ultimately Ok reaches almost 90%, with 10%
SubWPs remaining with unfulÔ¨Ålled constraints. We manually
investigated the violating artifacts (exclusively LLReqs) and
the comments attached to the SubWP Jira issue. Given that
Jira is used as the primary communication and coordination
mechanism amongst the distributed teams and QA department,
the comments provide an accurate and sufÔ¨Åciently complete
track of the SubWPs history. For the 10 CompleteNotOk
SubWPs we found that in two cases SubWPs were used
for documentation purposes rather than development (thus no
trace links to Functional Units were present). In one case
test cases were not applicable, and in three cases multiple
Functional Units were linked rather than one. This was due
to the fact that the conÔ¨Åguration subsystem affects multiple
Functional Units. Three times a test case was referenced in
the Jira comments (but no corresponding trace link in Jama
was created). Once an additional SubWP was traced without
closing the older one, and three times LLReq were marked
for proposed future changes (and thus being no longer in state
‚Äúreleased‚Äù). Note that some SubWPs experienced multiple,
diverse violations. Second, we found that 11 SubWPs are
IncompleteOk even we know that all the work was done.
Manual investigation revealed that the Jira custom Ô¨Åelds which
are used by the passive process engine as a signal to advance
1305the process were not used by the engineers, hence the process
remained in the Ô¨Årst step. We further discuss implications of
these Ô¨Åndings in Section VI.
Constraint FulÔ¨Ållment - Dronology: Table III reports the
differences in how often a constraint was fulÔ¨Ålled (limited
to completed process instances). A majority of constraints
was fulÔ¨Ålled most of the time (90% and higher). The lower
fulÔ¨Ållment rates for constraints D-C1a and D-C1b (<55%) are
the main reason ‚ÄúTask‚Äù and ‚ÄúSub-task‚Äù processes exhibit low
AlwaysOk andEventualOk values in Table II. Yet, constraints
applied across multiple process types (i.e., D-C1a/b, D-C2,
D-C3, D-C6, D-C7) exhibit similar fulÔ¨Ållment rates.
Frequentis: For this case we generally observed high ful-
Ô¨Ållment rates for all constraints. The 12 unfulÔ¨Ålled constraint
instances are distributed across the 10 CompleteNotOk Sub-
WPs described above. Recall, a Dronology constraint typically
requires the existence of a trace link to one artifact (e.g.,
D-C1a: a Task traces to a least one Design DeÔ¨Ånition). In
contrast, for Frequentis a constraint requires that all linked
artifacts (i.e., LLReqs in ATC-C1 to ATC-C6) fulÔ¨Åll speciÔ¨Åc
conditions. For ATC-C5, for example, a single LLReq out of
10 that doesn‚Äôt have a trace link to a Functional Unit will
cause the entire constraint to fail (regardless of whether all
other LLReqs are correct). We, therefore, also looked at the
number of times an artifact (primarily an LLReq) was part of
a constraint violation. With 1,121 LLReqs and six constraints
involving an LLReq, there are potentially 6,726 opportunities
that cause an overall constraint to fail. We observed 128, which
is less than 2%. Out of 128 LLReqs that were part of a
violation (due to missing, wrong, or too many trace links)
only 3 of these cases were part of two different constraint
violations. 98 LLReqs belonged to a single SubWP that was
used for documentation (and needed no Functional Unit trace
links), additional 12 LLReq belonged to single SubWP where
Test cases were not applicable. The remaining 18 LLReqs
violations were spread across the other eight CompleteNotOk
SubWPs.
F . Performance
An engineer typically checks constraints at the level of
Quality Check Documents to ensure all QA demands for
their step are fulÔ¨Ålled (and not necessarily for each individual
constraint). Overall the replay of 26,926 change events over
109 simultaneously active process instances resulted in 18,241
Quality Check Document evaluations. The resulting replay of
events from the Tool connector‚Äôs cache including constraint
evaluation took 6.5 minutes (averaged over 10 evaluation
runs). This corresponds to 0.02 seconds necessary for eval-
uating all quality constraints within a single Quality Check
Document: a duration that allows frequent and timely feedback
to developers.
VI. D ISCUSSION
The analysis of the Dronology data set indicated that the
actual process (in some cases signiÔ¨Åcantly) deviated from
the planned process. Upon requesting feedback, a projectlead at Dronology explained that while guidelines and a
development process were in place, it was not always feasibly
to follow them by the letter. Student teams were involved in
the development of some of the components, and while they
have been trained on the process, they still lacked experience
in following all prescribed rules and guidelines. Furthermore,
besides the software development aspect, the focus was also on
obtaining a data set of trace links and that the process had to be
adapted to the availability of open source developers. Rather
than forcing a change of process which might be infeasible, the
insights gained here could be used to decide where to better
place the QA checks, e.g., making constraint check results
available upon reviewing a pull request. Here ProCon would
then highlight where traces are missing or are incorrectly set.
A trace recommendation technique such as [25], [26] could
further assist in establishing the trace itself.
In contrast, the analysis for Frequentis‚Äô SubWPs conÔ¨Årmed
that engineers followed the high and stringent quality stan-
dards expected in the (highly safety-critical) ATC domain. The
Ô¨Ånding that 10% of process instances ‚ÄúEventualOK‚Äù conÔ¨Årms
the QA engineer‚Äôs experience that engineers need support for
producing correct and complete trace links as signiÔ¨Åcant addi-
tional work at a later stage was necessary. Our investigations
into the ‚ÄúCompleteNotOk‚Äù instances highlighted that, on the
one hand, corrections come with signiÔ¨Åcant coordination effort
and still may result in missing traces or incorrectly set artifact
properties. On the other hand, the investigations highlighted
the presence of edge cases where the QA constraints do not
apply, reinforcing the need for sometimes tolerating these
inconsistencies. ProCon offers two options in such a case:
Ô¨Årst to ignore the constraint evaluation results, and/or to adapt
the process, respectively constraints. In either of these two
cases, a rigid (thus inÔ¨Çexible), active process enforcement
environment would have severely hampered the engineer‚Äôs
available actions, effectively forcing the engineer to work
outside the deÔ¨Åned process. Finally, the huge amount of
>18.000 Quality Check Document evaluations explains why
manually providing timely feedback is infeasible.
Using ProCon can have signiÔ¨Åcant practical implications for
QA engineers. Supported by automated checks for ‚Äústandard‚Äù
cases, they can shift attention and focus their time on edge
cases and deviations from the process. Furthermore, they can
allocate time for improving constraints checks, and investigat-
ing whether these checks and following the process actually
result in better software quality [27]. Engineers can leverage
the immediate feedback they receive on their work status and
do not need to revisit their work at a later, inconvenient time.
The various stakeholders no longer need to build (error prone)
custom ‚Äúhelper tools‚Äù that are hard to maintain or to reuse.
We received very positive responses from engineers at Fre-
quentis upon presenting ProCon with one team lead wishing
to have it ready as a product by tomorrow, and a QA engineer
joking to be out of work then. QA engineers at Frequentis
used the prototype for writing new QA constraints during a
company internal innovation event to showcase its potential
and adaptability. While the prototype was applied only to one
1306Task % Sub-task % Bug % Design Def. % Hazard % SubWP %
AlwaysOk 0 0.0 55 31.2 94 98.9 134 82.7 26 72.2 78 79.6
EventualOk 42 31.1 31 17.6 0 0.0 2 1.2 0 0.0 10 10.2
CompleteNotOk 93 68.9 90 51.1 1 1.1 26 16.0 10 27.8 10 10.2
IncompleteNotYetOk 53 82.8 22 62.9 10 71.4 41 48.2 0 0.0 0 0.0
IncompleteProgressedNotOk 11 17.2 5 14.3 0 0.0 5 5.9 0 0.0 0 0.0
IncompleteOk 0 0.0 8 22.9 4 28.6 39 45.9 0 0.0 11 100.0
Total 199 211 109 247 36 109
TABLE II: Dronology quality constraint evaluation results per process type
Task (n=135) Sub-task (n=176) Bug (n=95) Design Def. (n=162) Hazard (n=36) SubWP (n=98)
X X% X X% XX% X X% X X% XX%
D-C1a 44 91 32.6 ATC-C1 95 3 96.9
D-C1b 94 82 53.4 ATC-C2 98 0 100.0
D-C2 135 0 100.0 168 8 95.5 ATC-C3 98 0 100.0
D-C3 132 3 97.8 164 12 93.2 94 1 98.9 ATC-C4 97 1 98.9
D-C4 136 26 84.0 ATC-C5 94 4 95.9
D-C5 26 10 72.2 ATC-C6 94 4 95.9
D-C6 133 2 98.5 176 0 100.0 ATC-C7 98 0 100.0
D-C7 121 14 89.6 175 1 99.4 95 0 100.0 ATC-C8 98 0 100.0
TABLE III: Quality constraint evaluation results per constraint type from completed process instances.
product group at Frequentis, we are currently rolling out the
prototype to three more product groups, each having different
rules (but use Jira/Jama), thus only the process and rules
needs to be adapted. Given the excellent performance during
replay (i.e., handling 27k artifact changes across 109 process
instances within a few minutes) we are conÔ¨Ådent that adding
more rules in the current rollout will not lead to performance
problems. We subsequently expect to obtain more detailed
insights into the prototype‚Äôs practical use.
Aside from immediate practical implications, ProCon has
huge potential as the foundation for additional support tools
building on top. Passive process execution has the beneÔ¨Åt of
enabling inspection at any time to what degree the process is
followed and where deviations have occurred (respectively are
not mitigated yet). Deviations can thus be detected earlier, e.g.,
an engineer has started too early on a step. Alerts or mitigating
actions may then be less invasive rather than signiÔ¨Åcant rework
later on. Other potential support mechanisms could guild the
engineer in how to setup the correct output artifacts, or direct
the engineer in how to Ô¨Åx a constraint violation or offers to
automatically Ô¨Åx it [28].
VII. T HREATS TO VALIDITY
Internal Validity. We address researcher bias by modeling
process and constraints from an open source system and
a company rather than conducting controlled experiments.
ProCon works on arbitrary artifacts, traces, and change events
and was not speciÔ¨Åcally tailored to Jama or Jira.
External Validity. Based on the limited scope of our eval-
uation with two different systems, we can not claim gener-
alizability of our Ô¨Åndings. However, we argue in line with
Briand et al. [29] that context-driven research will yield more
realistic results. Our work evaluated the ability of ProCon
to passively execute diverse engineering processes and QA
constraints (simple ones from an open source system and morecomplex ones from industry) in a timely manner. We analyzed
data from these two sources with one being ‚Äúproduction data‚Äù
from an industrial safety-critical system. Typically, being able
to obtain such data, and furthermore being able to publicly
report results is quite challenging as companies are reluctant
to provide insights into their working processes at that level
of detail, and open sources systems rarely come with such
extensive explicit artifacts and trace information.
A. Limitations
The evaluation process is exemplary of the processes at
Frequentis, but doesn‚Äôt cover all of ED109. The model and
engine however are not speciÔ¨Åc to ED109 and can be adopted
to the speciÔ¨Åc process setting as shown with Dronology that
followed a completely different process and TIM.
Adopting a different scenario then is mostly a matter
of connecting different tools. Tools tend to come with a
HTTP/REST interface, or client implementation (as did Jira
and Jama with dedicated Java clients). Hence, it requires little
effort in wrapping these clients for integration with the engine.
New tools (and artifacts) are then accessible in the rules.
We also make the assumption that step completion can be
detected from tools. The need for management, teamleads, and
project leaders to obtain an accurate picture of progress, as
well as having teams increasingly work distributed across mul-
tiple locations leads to a move away from informal signalling
of completion toward explicit one, e.g., assigning a different
member to an issue, setting a checkbox, setting the status of
an issue, etc. Thus we believe that obtaining such indicators
in almost all cases is reasonable.
VIII. R ELATED WORK
Several researchers have proposed techniques for continu-
ously assessing and maintaining software traceability [4]. EBT
(Event Based Traceability) uses a publish-subscribe model to
notify developers when trace links need to be updated [30]
1307while Rempel et al., proposed an automated traceability as-
sessment approach for continuously assessing the compliance
of traceability to regulations in certiÔ¨Åed products [31], [32].
These approaches are orthogonal to our work as they are
process-unaware, and hence provide little guidance for which
step in a process a trace link must be available. Further, we
assume engineers have chosen a suitable traceability strategy
[33] and assessed that the resulting TIM (supported by Ô¨Çex-
ible traceability management tools such as Capra [34]) also
conforms to the relevant guidelines [2].
Process-centric software development environments
(PCSDE) have received signiÔ¨Åcant attention in the 90‚Äôs.
We discuss an exemplary selection below, for a detailed
review see [35] or [36]. Step-centric modeling and active
execution frameworks such as Process Weaver [10], SPADE
[11], Serendipity [37], EvE [38], or PRIME [39] determine
which steps may be done at any given moment, automatically
executing them where possible. While such research supports
detailed guidance, deviations from the prescribed process
is not well supported. Approaches such as Shamus [40],
PROSYT [41], or Merlin [42] specify for engineering artifacts
which actions and conditions are available, and enforce their
correct order ‚Äì yet, without prescribing an overall step-
based engineering process. Often the supported artifacts are
limited to Ô¨Åles and folders. Systems such as MARVEL [43],
OIKOS [44], or EPOS [45] utilize ECA rules or pre- and
post-conditions, thereby providing signiÔ¨Åcant freedom of
action to the engineer but offer limited guidance.
The approaches described so far have the implicit assump-
tion that engineers primarily interact with the PCSDE for
executing work. Our aim is to remain in the background,
with engineers staying in their tools except for conÔ¨Årming
QA constraint fulÔ¨Ållment. Provenence [46] has a similar goal,
maintaining a process view from artifact change events. It‚Äôs,
however, limited to events from the Ô¨Åle system, relying on
moving Ô¨Åles to dedicated folders to signal process-meaningful
events. It also remains unaware of trace links between artifacts.
More recent work focuses on speciÔ¨Åc aspects in the en-
gineering life-cycle rather than general purpose processes.
DevOpsML [47] aims at reducing the effort to describe
continuous integration and deployment processes. AmalÔ¨Åtano
et al. [48] aim to fully automate the execution of the testing
process and to automatically generate appropriate traceability
links. Similarly, Hebig et al. [49] investigate how various
software design and code artifacts dependencies emerge from
MDE activities. When involving human steps, approaches
often assume pre-deÔ¨Åned process models and rigorous tool
integration. Kedji et al. provide a collaboration-centric de-
velopment process model and corresponding DSL [50]. At
a micro-level, Zhao et al. propose Little-JIL for describing
Ô¨Åne-grained steps involved in refactoring [51] and to help
developers track artifact dependencies during rework [52].
A few approaches on general purpose process modeling
and execution (e.g., [53]‚Äì[56]) focus on step-centric languages
such as SPEM and BPMN, which both imply active execution
where engineers cannot deviate from the prescribed process.Business process compliance checking approaches deter-
mine whether complex sequences of events and/or their timing
violate particular constraints. Ly et al. analyse frameworks for
compliance monitoring [57] and highlight that the investigated
frameworks have little or no inherent support for referenc-
ing data beyond the properties available in the respective
events (hence no access to the actual artifact details and their
traces/relations to other artifacts). They also show that hardly
any approach supports proactive violation detection, the ability
to continue monitoring after a violation, or root cause analysis
in a manner useful for software engineering. Also very recent
work, such as [58] or [59], lack this crucial support for deÔ¨Åning
constraints on artifact details. In general, processes in the
software engineering domain are comparatively simpler but
instead require a focus on keeping artifacts consistent with
each other, hence data-centric constraints are required which
our approach can check proactively and highlight that they are
not yet fulÔ¨Ålled.
QA constraint checking exhibits some similarities to cross-
artifact consistency checking. Examples include work on
model-to-model [7], [60], [61] or model-to-code checking [6].
These approaches support the correct propagation of changes
across artifacts once these artifacts are known to ‚Äúbelong‚Äù
together. Our work, in contrast, supports the engineer in what
state an artifact needs to be, and which trace links it needs to
exhibit depending on the process progress.
IX. C ONCLUSIONS AND OUTLOOK
We presented an approach for reducing the effort of ensuring
that development activities adhere to quality constraints. The
novel aspects are the decoupling of QA constraints from
process control and dataÔ¨Çow. We thereby tolerate that engi-
neers deviate from the process while informing them which
constraints are yet unfulÔ¨Ålled and which steps are complete.
Future work focuses on two main aspects. First we intend to
study the effect of having our prototype in use by engineers at
Frequentis. We aim to quantify the actual effort reduction and
gather qualitative feedback for further improvements. Second,
we will study QA engineers and process engineers during
the creation, evolution, and maintenance of process models
(including constraints) with ProCon to understand how their
task can be supported even better.
X. D ATA AVAILABILITY
The prototype and data used in this paper available at
Figshare https://doi.org/10.6084/m9.Ô¨Ågshare.12840053.
ACKNOWLEDGMENT
This work was funded by the Austrian Science Fund (FWF)
under the grant numbers P31989 and P29415-NBL, and
by the state of Upper Austria LIT-2019-8-SEE-118. The
Dronology case-study was supported by the United States
National Science Foundation under grants SHF:1741781 and
CPS:1931962.
1308REFERENCES
[1] D. B. Kramer, Y . T. Tan, C. Sato, and A. S. Kesselheim, ‚ÄúEnsuring
medical device effectiveness and safety: a cross‚Äìnational comparison of
approaches to regulation.‚Äù Food and drug law journal, vol. 69 1, pp.
1‚Äì23, i, 2014.
[2] P. Rempel, P. M ¬®ader, T. Kuschke, and J. Cleland-Huang, ‚ÄúMind the
gap: assessing the conformance of software traceability to relevant
guidelines,‚Äù in Proc. of the 36th Int‚Äôl Conf. on Software Engineering,
ICSE ‚Äô14. ACM, 2014, pp. 943‚Äì954.
[3] P. Diebold and S. A. Scherr, ‚ÄúSoftware process models vs descriptions:
What do practitioners use and need?‚Äù Journal of Software: Evolution
and Process, vol. 29, no. 11, 2017.
[4] J. Cleland-Huang, O. Gotel, J. H. Hayes, P. M ¬®ader, and A. Zisman,
‚ÄúSoftware traceability: trends and future directions,‚Äù in Proc. of the on
Future of Software Engineering, FOSE 2014. ACM, 2014, pp. 55‚Äì69.
[5] R. Watkins and M. Neal, ‚ÄúWhy and how of requirements tracing,‚Äù IEEE
Software, vol. 11, no. 4, pp. 104‚Äì106, 1994.
[6] A. Egyed, K. Zeman, P. Hehenberger, and A. Demuth, ‚ÄúMaintaining
consistency across engineering artifacts,‚Äù IEEE Computer, vol. 51, no. 2,
pp. 28‚Äì35, 2018.
[7] H. Klare, ‚ÄúMulti-model consistency preservation,‚Äù in Proc. of the 21st
ACM/IEEE Int‚Äôl Conf. on Model Driven Engineering Languages and
Systems: Companion Proceedings, ser. MODELS ‚Äô18. ACM, 2018, p.
156‚Äì161.
[8] R. Balzer, ‚ÄúTolerating inconsistency,‚Äù in Proc. of the 13th Int‚Äôl Conf. on
Software Engineering, 1991, pp. 158‚Äì165.
[9] EUROCAE, ‚ÄúED 109 software integrity assurance considerations for
communication, navigation, surveillance and air trafÔ¨Åc management
(cns/atm) systems,‚Äù January 2012. [Online]. Available: https://standards.
globalspec.com/std/1517993/eurocae-ed-109
[10] C. Fernstrom, ‚ÄúProcess weaver: Adding process support to unix,‚Äù in
Proc. of the 2nd Int‚Äôl Conf. on the Software Process-Continuous Software
Process Improvement. IEEE, 1993, pp. 12‚Äì26.
[11] S. Bandinelli, E. D. Nitto, and A. Fuggetta, ‚ÄúSupporting cooperation in
the SPADE-1 environment,‚Äù IEEE Trans. Software Eng., vol. 22, no. 12,
pp. 841‚Äì865, 1996.
[12] K. Pohl, K. Weidenhaupt, R. D ¬®omges, P. Haumer, M. Jarke,
and R. Klamma, ‚ÄúPRIME - toward process-integrated modeling
environments: 1,‚Äù ACM Trans. Softw. Eng. Methodol., vol. 8, no. 4,
pp. 343‚Äì410, 1999. [Online]. Available: https://doi.org/10.1145/322993.
322995
[13] I. Alloui and F. Oquendo, ‚ÄúManaging consistency in cooperating soft-
ware processes,‚Äù in Software Process Technology, V . Gruhn, Ed. Berlin,
Heidelberg: Springer Berlin Heidelberg, 1998, pp. 92‚Äì99.
[14] J. Simmonds, D. Perovich, M. C. Bastarrica, and L. Silvestre, ‚ÄúA
megamodel for software process line modeling and evolution,‚Äù in Proc.
of the 2015 ACM/IEEE 18th Int‚Äôl Conf. on Model Driven Engineering
Languages and Systems (MODELS), 2015, pp. 406‚Äì415.
[15] ‚ÄúSPEM,‚Äù 2008. [Online]. Available: https://www.omg.org/spec/SPEM/
About-SPEM/
[16] ‚ÄúJira,‚Äù https://www.atlassian.com/software/jira, accessed: 2020-08-20.
[17] ‚ÄúJama,‚Äù https://www.jamasoftware.com/, accessed: 2020-08-20.
[18] L. Osterweil, ‚ÄúSoftware processes are software too,‚Äù in Engineering of
Software. Springer, 2011, pp. 323‚Äì344.
[19] C. Mayr-Dorn, M. Vierhauser, F. Keplinger, S. Bichler, and A. Egyed,
‚ÄúTimetracer: a tool for back in time traceability replaying,‚Äù in Proc.
of the 42nd Int‚Äôl Conf. on Software Engineering, Companion Volume,
G. Rothermel and D. Bae, Eds. ACM, 2020, pp. 33‚Äì36. [Online].
Available: https://doi.org/10.1145/3377812.3382141
[20] J. Cleland-Huang, M. Vierhauser, and S. Bayley, ‚ÄúDronology: An
incubator for cyber-physical systems research,‚Äù in Proc. of the 40th Int‚Äôl
Conf. on Software Engineering: New Ideas and Emerging Results, ser.
ICSE-NIER ‚Äô18. ACM, 2018, p. 109‚Äì112.
[21] C. Mayr-Dorn, M. Vierhauser, S. Bichler, F. Keplinger,
J. Cleland-Huang, A. Egyed, and T. Mehofer, ‚ÄúSupporting Online
Material,‚Äù Aug 2020. [Online]. Available: https://Ô¨Ågshare.com/s/
1544630863a64d94d994
[22] C. Mayr-Dorn, S. Bichler, F. Keplinger, and A. Egyed, ‚ÄúGuiding engi-
neers with the passive process engine environment,‚Äù in Proc. of the 43rd
Int‚Äôl Conf. on Software Engineering: Companion (ICSE-Companion).
IEEE / ACM, 2021, p. to appear.
[23] ‚ÄúDrools,‚Äù https://www.drools.org, accessed: 2020-08-20.
[24] J. Cleland-Huang and M. Vierhauser, ‚ÄúDronology Public Datasets.‚Äù
[Online]. Available: https://dronology.info/research/datasets[25] M. Rath, J. Rendall, J. L. Guo, J. Cleland-Huang, and P. M ¬®ader,
‚ÄúTraceability in the wild: automatically augmenting incomplete trace
links,‚Äù in Proc. of the 40th Int‚Äôl Conf. on Software Engineering, 2018,
pp. 834‚Äì845.
[26] G. Antoniol, G. Canfora, G. Casazza, A. De Lucia, and E. Merlo,
‚ÄúRecovering traceability links between code and documentation,‚Äù IEEE
Transactions on Software Engineering, vol. 28, no. 10, pp. 970‚Äì983,
2002.
[27] R. Conradi, C. Fernstr ¬®om, and A. Fuggetta, ‚ÄúConcepts for evolving
software processes,‚Äù Software Process Modelling and Technology, pp.
9‚Äì31, 1994.
[28] C. Mayr-Dorn, R. Kretschmer, A. Egyed, R. Heradio, and D. Fern ¬¥andez-
Amor ¬¥os, ‚ÄúInconsistency-tolerating guidance for software engineering
processes,‚Äù in Proc. of the 43rd Int‚Äôl Conf. on Software Engineering:
New Ideas and Emerging Results (ICSE-NIER). IEEE / ACM, 2021,
p. to appear.
[29] L. Briand, D. Bianculli, S. Nejati, F. Pastore, and M. Sabetzadeh, ‚ÄúThe
Case for Context-Driven Software Engineering Research: Generalizabil-
ity Is Overrated,‚Äù IEEE Software, vol. 34, no. 5, pp. 72‚Äì75, 2017.
[30] J. Cleland-Huang, C. K. Chang, and M. J. Christensen, ‚ÄúEvent-based
traceability for managing evolutionary change,‚Äù IEEE Trans. Software
Eng., vol. 29, no. 9, pp. 796‚Äì810, 2003. [Online]. Available:
https://doi.org/10.1109/TSE.2003.1232285
[31] P. Rempel and P. M ¬®ader, ‚ÄúContinuous assessment of software
traceability,‚Äù in Proc. of the 38th Int‚Äôl Conf. on Software Engineering,
ICSE 2016,, L. K. Dillon, W. Visser, and L. Williams, Eds.
ACM, 2016, pp. 747‚Äì748. [Online]. Available: https://doi.org/10.1145/
2889160.2892657
[32] P. Rempel, ‚ÄúContinuous assessment of software traceability,‚Äù Ph.D.
dissertation, Technische Universit ¬®at Ilmenau, Germany, 2016. [Online].
Available: https://www.db-thueringen.de/receive/dbtmods 00029275
[33] P. Rempel, P. M ¬®ader, and T. Kuschke, ‚ÄúAn empirical study
on project-speciÔ¨Åc traceability strategies,‚Äù in Proc. of the 21st
IEEE Int‚Äôl Requirements Engineering Conf., RE 2013. IEEE
Computer Society, 2013, pp. 195‚Äì204. [Online]. Available: https:
//doi.org/10.1109/RE.2013.6636719
[34] S. Maro and J. Stegh ¬®ofer, ‚ÄúCapra: A conÔ¨Ågurable and extendable trace-
ability management tool,‚Äù in Proc. of the 24th IEEE Int‚Äôl Requirements
Engineering Conf., RE 2016. IEEE, 2016, pp. 407‚Äì408.
[35] P. Barthelmess, ‚ÄúCollaboration and coordination in process-centered
software development environments: a review of the literature,‚Äù Inf.
Softw. Technol., vol. 45, no. 13, pp. 911‚Äì928, 2003. [Online]. Available:
https://doi.org/10.1016/S0950-5849(03)00091-0
[36] V . Gruhn, ‚ÄúProcess-centered software engineering environments, a brief
history and future challenges,‚Äù Annals of Software Engineering, vol. 14,
no. 1-4, pp. 363‚Äì382, 2002.
[37] J. C. Grundy and J. G. Hosking, ‚ÄúSerendipity: Integrated environment
support for process modelling, enactment and work coordination,‚Äù
Autom. Softw. Eng., vol. 5, no. 1, pp. 27‚Äì60, 1998. [Online]. Available:
https://doi.org/10.1023/A:1008606308460
[38] A. Geppert, D. Tombros, and K. R. Dittrich, ‚ÄúDeÔ¨Åning the semantics
of reactive components in event-driven workÔ¨Çow execution with event
histories,‚Äù Inf. Syst., vol. 23, no. 3‚Äì4, p. 235‚Äì252, May 1998. [Online].
Available: https://doi.org/10.1016/S0306-4379(98)00011-8
[39] K. Pohl, K. Weidenhaupt, R. D ¬®omges, P. Haumer, M. Jarke, and
R. Klamma, ‚ÄúPrime‚Äîtoward process-integrated modeling environments:
1,‚ÄùACM Trans. Softw. Eng. Methodol., vol. 8, no. 4, p. 343‚Äì410, Oct.
1999.
[40] A. LaMarca, W. K. Edwards, P. Dourish, J. Lamping, I. Smith, and
J. Thornton, ‚ÄúTaking the work out of workÔ¨Çow: mechanisms for
document-centered collaboration,‚Äù in ECSCW‚Äô99. Springer, 1999, pp.
1‚Äì20.
[41] G. Cugola and C. Ghezzi, ‚ÄúDesign and implementation of prosyt: a
distributed process support system,‚Äù in Proc. of the IEEE 8th Int‚Äôl
Workshops on Enabling Technologies: Infrastructure for Collaborative
Enterprises (WET ICE‚Äô99). IEEE, 1999, pp. 32‚Äì39.
[42] G. Junkermann, B. Peuschel, W. Sch ¬®afer, and S. Wolf, MERLIN:
Supporting Cooperation in Software Development through a Knowledge-
Based Environment. GBR: Research Studies Press Ltd., 1994, p.
103‚Äì129.
[43] N. S. Barghouti, ‚ÄúSupporting cooperation in the marvel process-centered
sde,‚Äù ACM SIGSOFT Software Engineering Notes, vol. 17, no. 5, pp.
21‚Äì31, 1992.
1309[44] C. Montangero and V . Ambriola, ‚ÄúOikos: constructing process-centred
sdes,‚Äù in Software Process Modelling and Technology, 1994, pp. 131‚Äì
151.
[45] R. Conradi, M. Hagaseth, J.-O. Larsen, M. Nguyen, B. Munch,
P. Westby, W. Zhu, M. Jaccheri, and C. Liu, ‚ÄúObject-oriented and
cooperative process modelling in epos,‚Äù Software process modelling and
technology, pp. 9‚Äì32, 1994.
[46] B. Krishnamurthy and N. S. Barghouti, ‚ÄúProvence: A process visual-
ization and enactment environment,‚Äù in Proc. of the European Software
Engineering Con. Springer, 1993, pp. 451‚Äì465.
[47] A. Colantoni, L. Berardinelli, and M. Wimmer, ‚ÄúDevopsML: Towards
modeling devops processes and platforms,‚Äù in Proc. of the 23rd Int‚Äôl
Conf. on Model Driven Engineering Languages and Systems, ser.
Models‚Äô20. ACM, 2020, pp. 1‚Äì11.
[48] D. AmalÔ¨Åtano, V . D. Simone, A. R. Fasolino, and S. Scala, ‚ÄúImproving
traceability management through tool integration: an experience in the
automotive domain,‚Äù in Proc. of the 2017 Int‚Äôl Conf. on Software and
System Process, ICSSP 2017, R. Bendraou, D. Raffo, L. Huang, and
F. M. Maggi, Eds. ACM, 2017, pp. 5‚Äì14.
[49] R. Hebig, A. Seibel, and H. Giese, ‚ÄúToward a comparable characteriza-
tion for software development activities in context of MDE,‚Äù in Proc.
of the Int‚Äôl Conf. on Software and Systems Process, ICSSP, D. Raffo,
D. Pfahl, and L. Zhang, Eds. ACM, 2011, pp. 33‚Äì42.
[50] K. A. Kedji, R. Lbath, B. Coulette, M. Nassar, L. Baresse, and
F. Racaru, ‚ÄúSupporting collaborative development using process models:
An integration-focused approach,‚Äù in Proc. of the 2012 Int‚Äôl Conf. on
Software and System Process, ICSSP 2012, D. R. Jeffery, D. Raffo,
O. Armbrust, and L. Huang, Eds. IEEE, 2012, pp. 120‚Äì129.
[51] X. Zhao and L. J. Osterweil, ‚ÄúAn approach to modeling and supporting
the rework process in refactoring,‚Äù in Proc. of the 2012 Int‚Äôl Conf. on
Software and System Process, D. R. Jeffery, D. Raffo, O. Armbrust,
and L. Huang, Eds. IEEE Computer Society, 2012, pp. 110‚Äì119.
[Online]. Available: https://doi.org/10.1109/ICSSP.2012.6225953
[52] X. Zhao, Y . Brun, and L. J. Osterweil, ‚ÄúSupporting process undo and
redo in software engineering decision making,‚Äù in Proc. of the Int‚Äôl Conf.
on Software and System Process, ICSSP ‚Äô13, J. M ¬®unch, J. A. Lan, and
H. Zhang, Eds. ACM, 2013, pp. 56‚Äì60.[53] M. Dumas and D. Pfahl, Modeling Software Processes Using
BPMN: When and When Not? Cham: Springer International
Publishing, 2016, pp. 165‚Äì183. [Online]. Available: https://doi.org/10.
1007/978-3-319-31545-49
[54] R. Ellner, S. Al-Hilank, J. Drexler, M. Jung, D. Kips, and M. Philippsen,
‚Äúespem ‚Äì a spem extension for enactable behavior modeling,‚Äù in Mod-
elling Foundations and Applications, T. K ¬®uhne, B. Selic, M.-P. Gervais,
and F. Terrier, Eds. Berlin, Heidelberg: Springer Berlin Heidelberg,
2010, pp. 116‚Äì131.
[55] S. Alajrami, B. Gallina, I. Sljivo, A. Romanovsky, and P. Isberg, ‚ÄúTo-
wards cloud-based enactment of safety-related processes,‚Äù in Computer
Safety, Reliability, and Security, A. Skavhaug, J. Guiochet, and F. Bitsch,
Eds. Cham: Springer International Publishing, 2016, pp. 309‚Äì321.
[56] D. Winkler, L. Kathrein, K. Meixner, P. Staufer, M. Pauditz, and S. BifÔ¨Ç,
‚ÄúTowards a hybrid process model approach in production systems
engineering,‚Äù in Systems, Software and Services Process Improvement,
A. Walker, R. V . O‚ÄôConnor, and R. Messnarz, Eds. Cham: Springer
International Publishing, 2019, pp. 339‚Äì354.
[57] L. T. Ly, F. M. Maggi, M. Montali, S. Rinderle-Ma, and W. M. van der
Aalst, ‚ÄúCompliance monitoring in business processes: Functionalities,
application, and tool-support,‚Äù Information Systems, vol. 54, pp. 209 ‚Äì
234, 2015. [Online]. Available: http://www.sciencedirect.com/science/
article/pii/S0306437915000459
[58] C. Cabanillas, M. Resinas, and A. Ruiz-Cort‚Äôs, ‚ÄúA mashup-based frame-
work for business process compliance checking,‚Äù IEEE Transactions on
Services Computing, pp. 1‚Äì1, 2020.
[59] D. Knuplesch, M. Reichert, and A. Kumar, ‚ÄúA framework for visually
monitoring business process compliance,‚Äù Information Systems, vol. 64,
pp. 381 ‚Äì 409, 2017. [Online]. Available: http://www.sciencedirect.
com/science/article/pii/S0306437915301770
[60] A. Egyed, ‚ÄúAutomatically detecting and tracking inconsistencies in
software design models,‚Äù IEEE Trans. Software Eng., vol. 37, no. 2,
pp. 188‚Äì204, 2011. [Online]. Available: https://doi.org/10.1109/TSE.
2010.38
[61] H. K ¬®onig and Z. Diskin, ‚ÄúAdvanced local checking of global consistency
in heterogeneous multimodeling,‚Äù in European Conference on Modelling
Foundations and Applications. Springer, 2016, pp. 19‚Äì35.
1310