Just-In-Time Reactive Synthesis
Shahar Maoz
Tel Aviv University
IsraelIlia Shevrin
Tel Aviv University
Israel
ABSTRACT
Reactivesynthesisisanautomatedproceduretoobtainacorrect-by-
construction reactive system from its temporal logic specification.
GR(1) is an expressive assume-guarantee fragment of LTL that
enablesefficientsynthesisandhasbeenrecentlyusedindifferent
contexts and application domains.
Inthisworkwepresentjust-in-timesynthesis(JITS)forGR(1),a
novelmeanstoexecutesynthesizedreactivesystems.Ratherthan
constructing a controller at synthesis time, we compute next states
during system execution, and only when they are required. We
provethatJITSdoesnotcompromisethecorrectnessofthesynthe-
sizedsystemexecution. Wefurthershow thatthebasicalgorithm
can be extended to enable several variants.
We have implemented JITS in the Spectra synthesizer. Our eval-
uation, comparing JITS to existing tools over known benchmark
specifications,showsthatJITSreduces(1)totalsynthesistime,(2)
thesizeofthesynthesisoutput,and(3)theloadingtimeforsystem
execution,allwhilehavinglittletonoeffectonsystemexecution
performance.
CCS CONCEPTS
•Software and its engineering →Formal methods .
KEYWORDS
reactive synthesis, GR(1)
ACM Reference Format:
ShaharMaozandIliaShevrin.2020.Just-In-TimeReactiveSynthesis.In 35th
IEEE/ACMInternationalConferenceonAutomatedSoftwareEngineering(ASE
’20),September21–25,2020,VirtualEvent,Australia. ACM,NewYork,NY,
USA, 12 pages. https://doi.org/10.1145/3324884.3416557
1 INTRODUCTION
Reactivesynthesisisanautomatedproceduretoobtainacorrect-
by-constructionreactivesystemfromitstemporallogicspecifica-
tion [33]. Rather than manually constructing an implementation
andusing modelcheckingtoverify itagainsta specification, syn-
thesis offers an approach where a correct implementation of the
systemisautomaticallyobtainedforagivenspecification,ifsuch
an implementation exists.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACMmustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ASE ’20, September 21–25, 2020, Virtual Event, Australia
© 2020 Association for Computing Machinery.
ACM ISBN 978-1-4503-6768-4/20/09...$15.00
https://doi.org/10.1145/3324884.3416557GR(1)isafragmentoflineartemporallogic[ 32](LTL)thathas
an efficient symbolic synthesis algorithm [ 5,31] and whose ex-
pressivepowercoversmostofthewell-knownLTLspecification
patterns of Dwyer et al. [ 12,23]. GR(1) specifications include as-
sumptionsandguaranteesaboutwhatneedstoholdonallinitial
states, onall statesand transitions (safety), and infinitelyoften on
every run (justice). GR(1) synthesis has been used and extended in
different contexts and for different application domains, including
robotics [ 19,22,24], scenario-based specifications [ 28], aspect lan-
guages[27],event-basedbehaviormodels[ 11],hybridsystems[ 14],
and device drivers [37], to name a few.
The synthesis algorithm in [ 5], as implemented (with some vari-
ations) in existing GR(1) synthesizers RATSY [ 4], Slugs [13], and
Spectra[25],consistsoftwophases.Inthefirstphase,thealgorithm
checks for realizability. If the specification is found to be realizable
inthefirstphase,synthesiscontinuestothesecondphase,where
it constructs a controller using memory collected in the first phase.
According to experience reported on in [ 5] and supported by ev-
idencewereportinourevaluation,inmanycasesthefirstphase
of realizability checking takes only a small fraction of the total
synthesis time. Most of the time is spent in the second phase of
controller construction.
In this work we introduce just-in-time synthesis (JITS),
a novel means to execute synthesized reactive systems,
whichskipsthecontrollerconstructionphase.Instead,itef-
ficientlystoresthememorycollectedinthefirstphaseofre-alizability checking, and uses it during system execution tocompute next states, only when they are required. The con-troller is never constructed. However, importantly, as thenextstatecomputationisperformedusingthememorythat
was collected during realizability checking, JITS keeps sys-
tem execution correct-by-construction.
As JITS skips construction, it is expected to dramatically reduce
the overall synthesis time. Moreover, JITS symbolic representation
of the memory that is required for correct execution, consists ofchains of very similar BDDs, and makes storing it at the end of
synthesis and loading it just before system execution very efficient.
During system execution, at each step, JITS manipulates only a
smallnumberofBDDs,eachofrelativelysmallsize,andthusthe
effect on performance of the just-in-time next states computation
is kept to a minimum.
Beyondperformance,fromarchitecturalandmethodologicalper-
spectives, JITS decouples synthesis (realizability checking) from
system execution. This decoupling is significant, as indeed, synthe-
sistakesplaceatdevelopmenttimeandisexecutedondevelopment
machines, while system execution, i.e., the actual running of the
synthesized system, will typically run on very different machines,
e.g.,onarobot.Thedecoupling,whichisuniquetoJITS,enables
flexibility in system execution, and supports, for example, exten-sions and variants that aim to improve qualitative aspects of the
6352020 35th IEEE/ACM International Conference on Automated Software Engineering (ASE)
execution, such as eagerness, recovery, and configurability. See
Sect. 4.
Finally,JITSisdefinedforGR(1)andthusseamlesslysupports
any specification that is reduced to GR(1). In particular, the use
of JITS is independent of the use of advanced constructs such aspast LTL operators, patterns, counters, etc. as supported, e.g., inSpectra [
25]. Our evaluation of JITS (see below) indeed includes
such rich specifications.
We have implemented JITSon top of the Spectra synthesizer [ 2]
(using its implementation of realizability checking, ignoring its
implementationofcontrollerconstruction).ToevaluateJITS,we
compared it against existing tools over specifications from publicly
available benchmarks. The results show that JITS outperforms ex-
isting tools in all aspects of synthesis, including time and memory,
andthatitsoutputsofthesynthesisphasearesmallerandtypically
faster to load. In practical terms, it makes the execution of systems
withratherlargespecificationsfeasibleevenonenvironmentswith
limited resources. See Sect. 5.
Theremainderofthepaperisstructuredasfollows.InSect.2we
providenecessarybackgroundonGR(1)realizabilityandcontroller
construction. In Sect. 3 we present the JITS approach and prove
its correctness. In Sect. 4 we discuss several optional extensions to
JITS.InSect.5wepresentourevaluationsforJITSsynthesisand
execution as compared to other tools. Finally, in Sect. 6 and Sect. 7
we discuss related work and conclude.
2 PRELIMINARIES
Werecallthenotionsofrealizabilityandsynthesis,GR(1)realizabil-
ity problem, and the controller construction algorithm from [5].
2.1 LTL Realizability and Synthesis
The interaction of a reactive system [16] with its environment is
bestseenasaturn-basedinfinitedurationgamewhereineachof
its roundsthe environment first chooses an assignmentto its input
variables, and the system responds by choosing an assignment
toitsoutputvariables.Then,anLTLformulaovertheseBoolean
variablescanbeusedasaspecificationforthebehaviorofadesired
reactive system.
Weconsiderreactivesystemsthatcanbeimplementedby con-
trollersof finite size, i.e., by finite Mealy machines that compute
their outputs. A controller realizesan LTL specification ψif for all
environmentinputs,itprescribesoutputsthatresultincomputa-
tionswhichsatisfy ψ.Wesaythat ψisrealizable ifsuchacontroller
exists.Otherwise, ψisunrealizable.Itiswell-knownthat finitecon-
trollersaresufficientforrealizabilityofLTLspecifications[ 33].The
goalof LTL synthesis is,given anLTLspecification, toconstructa
controller that realizes it, if it is realizable.
2.2 GR(1) Realizability Problem
GR(1) synthesis [5,31] handles a fragment of LTL where speci-
fications have a predefined syntactic structure. Specifically, they
containinitialassumptionsandguaranteesoverinitialstates(de-
notedθeandθsresp.), safety assumptions and guarantees relating
the current and next state (denoted ρeandρsresp.), and justice
assumptionsandguaranteesrequiringthatanassertionholdsinfin-
itely many times during a computation (denoted JeandJsresp.).GR(1)synthesishasthefollowingnotionofrealizability1defined
by the LTL formula
(θe∧Gρe∧/logicalanddisplay.1
i∈1..mGFJe
i)→(θs∧Gρs∧/logicalanddisplay.1
j∈1..nGFJs
j)
The GR(1) realizability problem is formulated as a two-player
game between the system and the environment, and reduces to
decidingthewinnerinsuchgame.Intuitively,thesystemwinsif
it has a strategy that allows it to satisfy its njustice guarantees
infinitely often while maintaining initial and safety guarantees, or
forcetheenvironmenttoviolateanyofits mjusticeassumptions,
or its initial or safety assumptions.
We denote the states from which the system can force the envi-
ronment to visit a state in Xby(X), also called the controlled
predecessors, defined as:
(X)={c∈2X∪Y|∀x∈2X:¬ρe(c,x)∨∃y∈2Y:
(ρs(c,/angbracketleftx,y/angbracketright)∧/angbracketleftx,y/angbracketright∈X)}(1)
The winning states are characterized using the following three-
level nested μ-calculus formula from [5]:
Wsys=νZ.n/intersectiondisplay.1
j=1μY.m/uniondisplay.1
i=1νX.(Js
j∩(Z))∪(Y)∪(¬Je
i∩(X))(2)
Theoutputofformula2isthesetofwinningstatesforthesystem
player.
2.3 GR(1) Original Controller Construction
The realizability checking algorithm outputs additional intermedi-
ateresultsofthenestedfixed-pointcomputationsfromEq.2,stored
inmX[][][]andmY[][]. These intermediate results, along with the
winningset Wsys,arepresentedasfollows.Weuse1-basedindexes
for the justice assumptions and guarantees to conform with the
notation in [5].
2.3.1 . mX[j][r][i]represents the set of states in which the system
is at most rsteps from the satisfaction of Js
j(the system is at rank
r),andfromanystateinthisset,thesystemcaneitherkeepforcing
theenvironmenttoviolate Je
i,oralternativelymoveonestepcloser
towards satisfying Js
j. It is the result of the safety game innermost
greatest fixed-point computation from formula 2.
Specifically,when r=1,mX[j][1][i]representsthesetofstates
inwhichthesystemeithersatisfies Js
j,orforcestheenvironment
to violate Je
i.
2.3.2 . mY[j][r]represents the set of states in which the system is
at mostrsteps fromthe satisfaction of Js
j. Fromany state inthis
set, the system can either force the environment to violate at least
oneJe
ifor some i, or move one step closer towards satisfying Js
j.
mY[j][r]is defined as follows:
mY[j][r]=/uniondisplay.1
i∈[1..m]mX[j][r][i] (3)
1Thereexistsastrict,moreinvolvedvariantofrealizability[ 5].However,thedifference
is not relevant for the paper.
636Itisanintermediateresultoftheinnerreachabilitygameleast
fixed-point computation from formula 2. We denote by rjthe num-
ber of iterations during this computation. It holds that:
∀j,r<rj./parenleftBig
mY[j][r]⊆mY[j][r+1]/parenrightBig
(4)
Specifically, mY[j][rj]is the result of the reachability game inner
leastfixed-pointcomputation.Fromthisset,thesystemcaneven-
tuallysatisfy Js
j,orforcetheenvironmenttoviolatesomejustice
assumption.
2.3.3 .Finally,Wsys,denoted Zfromnowon,representsthesetof
states in which the system can act towards satisfying allits justice
guarantees in a round-robin fashion, or can force the environment
to violate any of its assumptions. It is the winning set of the GR(1)
game and the result of the safety game outermost greatest fixed-
point computation. Duringthe iterations of this computation,the
inner reachability games are adjusted each time to stop within the
boundaries of Z, hence finally:
∀j.Z=mY[j][rj] (5)
From these intermediate results, Bloem et al. [ 5] show how to
constructacontrollerimplementingawinningstrategyasdescribed
in Alg. 1. We briefly present the algorithm.
LetZndenotethevariablerepresentingtheindexofthecurrent
justicegoal.PrimedBDDs,e.g., X/prime,denotethesetofstates X,but
where variables refer to their next value. Denote ρasρe∧ρs.ρ,
as the BDD responsible for the transitions safety, contains both
primedandunprimedvariables.Denote ⊕astheadditionoperation
modulon.
Theconstructionisdividedintothreeparts.Eachpartconjuncts
valid transitions to the controller, i.e., relations between current
and next states:
•Givenj∈[1...n],aρ1transition (lines 2-6) is taken from Z
states,wherecurrentstatesatisfiesjusticeguarantee Js
j.Inthis
case,Znis updated with j⊕1 and next states are in Z.
•Givenj∈[1...n]andr∈[2...rj],aρ2transition (lines 7-15)
is taken from mY[j][r]states, where rank ris minimal, namely,
currentstateisin mY[j][r]butnotin/uniontext.1
r/prime<rmY[j][r/prime].Inthiscase,
controller proceeds to mY[j][r−1].
•Givenj∈[1...n],r∈[1...rj],andi∈[1...m],aρ3transition
(lines 16-26) is taken from mX[j][r][i]states, where current state
violatesJe
i,andrandiareminimal,namely,currentstateisin
mX[j][r][i]but not in/uniontext.1
r/prime,i/primemX[j][r/prime][i/prime]forr/prime<rorr/prime=rand
i/prime<i. In this case, the controller remains in mX[j][r][i].
TheoutputofAlg.1isasingleBDDovervariables X∪Yand
Znthat describes a reactive controller, i.e., a finite Mealy machine.
Since this representation uses a pre-computed BDD, we refer to it
hereasthe staticapproach,todifferentiatefromourjust-in-time
approach.
Bloemetal.[ 5]showthatthisconstructionissoundandcom-
plete,i.e.,thatallnextstatesreturnedarewinningforthesystem
and that if there is a winning next state, at least one is returned.Algorithm 1 Controller construction for the static approach
input: Z,mY[][],mX[][][]
1:trans←TRUE
2:for allj∈[1...n]do //ρ1transitions
3:transj←( Zn=j)∧Z∧Js
j∧ρ
4:transj←transj∧Z/prime∧(Z/primen=j⊕1)
5:trans←trans∨transj
6:end for
7:for allj∈[1...n]do //ρ2transitions
8:low←mY[j][0]
9:for allr∈[2...rj]do
10: transjr←( Zn=j)∧mY[j][r]∧¬low∧ρ
11: transjr←transjr∧low/prime∧(Z/primen=j)
12: trans←trans∨transjr
13: low←low∨mY[j][r]
14:end for
15:end for
16:for allj∈[1...n]do //ρ3transitions
17:low←mY[j][0]
18:for allr∈[1...rj]do
19: for alli∈[1...m]do
20: transjri←( Zn=j)∧mX[j][r][i]∧¬low∧¬Je
i∧ρ
21: transjri←transjri∧mX/prime[j][r][i]∧(Z/primen=j)
22: trans←trans∨transjri
23: low←low∨mX[j][r][i]
24: end for
25:end for
26:end for
27:returntrans
2.4 GR(1) Original Controller Execution
Beforesystemexecution,thisBDD,denoted trans,isloaded, andis
used during execution to compute next possible assignments to all
systemvariables,asweshowinAlg.2.Onestepoftheexecution
consistsoftheenvironmentchoosingvaluesforthenextinput,after
which the system must choose values for the next state (output)
from the result set of Alg. 2.
In Alg. 2, c∈2X∪Yis a BDD describing the current state of the
variables. x∈2Xis a BDD describing environment inputs. jis the
index of the current justice goal. The execution itself is straight-
forward. It conjuncts transwith current state c, inputsxprimed,
and the assignment Zn=j. Observe that the resulting BDD T
represents a subset of transitions encoded in transthat conform
tothegiveninputs.Thecontrollerextractsthenextstatesfrom T
by quantifying out unprimed variables and unpriming the result
(intuitively, it means moving to the next step in the game).
FromtheoutputofAlg.2,thecontrollerpicksoneassignment
to variables over Y∪{ Zn}, which is regarded as the next state.
This assignment can be chosen at random, or by applying some
deterministic rule.
We assume that environment inputs are checked for correctness
prior to the call to Alg. 2, namely, they do not violate the safety
assumptions.Incaseofaninvalidinputthecontrollermayraisean
error message.
637Algorithm 2 Controller next states for the static approach
input:c∈2X∪Y,x∈2X,j∈[1...n]
1:T←( Zn=j)∧c∧x/prime∧trans// wheretransis from Alg. 1
2:T←QuantifyOutUnprimedVars (T)
3:T←Unprime(T)
4:returnT
3 JUST-IN-TIME SYNTHESIS
We are now ready to present the main contribution. The JITS solu-
tion is divided into two separate phases: storing and execution. We
use set theoretic and logic notation interchangeably when describ-
ing operations on BDDs (as representations of sets and as Boolean
functions, respectively).
3.1 Storing
Given the intermediate results computed by the realizability check-
ing algorithm, we make the following key observations.
3.1.1 . mY[][]andZare derived from the array of mX[][][]fixed-
points, as seen in Equ. 3 and Equ. 5. Thus, even though they are
crucialforcorrectexecution,storingthemforlateruseisredundant.
3.1.2 .The mX[][][]array holds many BDDs, each of which de-
scribes a set of states. While there are/summationtext.1
j∈[1...n]m·rjsuch BDDs
in total, we expect them to be similar to one another because they
represent monotonic sequences of sets, i.e., ordered by subset rela-
tion. Formally:
∀j,r<rj,i./parenleftBig
mX[j][r][i]⊆mX[j][r+1][i]/parenrightBig
(6)
Equation 6 holds following Equ. 3 and Equ. 4. One may hope to
take advantage of this similarity when storing them.
3.1.3 .WhenencodingmultipleBDDstoafileondisk,thememory
optimizationachievedbysharingnodesintheinternalBDDengine
between these BDDs is lost if they are encoded separately.
Basedonthesethreeobservations,JITSencodestherequireddata
in a single BDDover three new variables J,R,I, and the variables
X∪Yas follows:
Xs=/logicalanddisplay.1
j,r,i/parenleftBig
(J=j∧R=r∧I=i)→mX[j][r][i]/parenrightBig
(7)
At the end of the construction phase, JITS stores the BDD Xs
along with the BDDs representing the justice assumptions Je
i, jus-
tice guarantees Js
j, initial and safety formulas θs,θe,ρsandρe
fromtheoriginalspecification.Asourevaluationshows,seeSect.5,
this representation is highly efficient.
Together, as we explain next, the stored BDDs provide all the
necessary information for correct execution.
3.2 Execution
3.2.1 Loading. SystemexecutionstartsbyloadingtheBDDsstored
at the end of the storing phase. As part of loading, JITS extracts ev-
erymX[j][r][i]toanarraybyrestrictingthe XsBDDtoeveryunique
assignmentof the J,R,andIvariables,and computes mY[][]arrayaccordingtodefinitionfromEqu.3.JITSalsoomits Zcalculation
since it holds that Z=mY[1][r1]from Equ. 5.
JITSloadstheinitialandsafetyBDDs,andsets ρ=ρs∧ρe.ρas
wellasallprimedversionsof mX[][][]andmY[][]BDDsarecomputed
at load time and cached for later use. Note that the variable Zn
is absent from the BDD state space of JITS. As we show in our
evaluation,JITSloadingtimeistypicallyshorterthanthatofthe
static approach (and the longer the loading time with the static
approach, the shorter JITS loading time becomes in comparison,
reaching order of magnitudes relative improvement).
3.2.2 Step-wise execution. At the end of loading, JITS is ready for
step-wise execution as we show in Alg. 3. This step-wise execu-tion algorithm acts as an eager, just-in-time implementation of
Alg. 1 static construction and Alg. 2 execution. As in the static
approach, we assume correct environment inputs, and in case of
aninvalidinput(whichviolatessafetyassumptions),canraisean
error message.
During runtime, JITS maintains, on the algorithm level, a helper
indexrminthat keeps the current rank (distance from Js
j). JITS
maintains this index, such that after initialization and at the end of
each step it points to the lowest rank possible.
Thealgorithmfirstchecksifthecurrentstate csatisfiesJs
j.A c-
cording to the ρ1transitions from the static construction, next
states should be the whole Zset. JITS instead, performs an eager
look-ahead to find the lowest rank for next justice goal given envi-
ronmentinputs x,andupdates rmin.TheBDD N,whichrepresents
the next states, is assigned with mY[j⊕1][rmin]. (lines 3-4).
Otherwise, JITS tries to decrease rank. According to the ρ2tran-
sitionsfromthestaticconstruction,nextstatesisthe mY[j][rmin−1]
set.Asbefore,JITSperformsaneagerlook-aheadtofindthenext
lowest rank possible for the current goal. It updates rminand as-
signsNtomY[j][rmin](lines 9-10).
Note that it is not always possible to decrease rank from cwith
inputsx, since for every jandr,mY[j][r]contains not only the
controlled predecessors of mY[j][r−1], but also the results of m
safetygamesforthisrankthatforcejusticeassumptionviolation.
Another possibility is that rminis currently 1, yet justice goal is
not satisfied.In thesecases, JITSresorts toforce theenvironment
toviolate some Je
i.It computesthe minimal iminforthat purpose
and assigns NtomX[j][rmin][imin](lines 12-13).
The final part is similar to Alg. 2. JITS conjuncts Nin its primed
state with c∧x/prime∧ρ. Then it processes the result by quantifying
out unprimed variables and unpriming, and finally returns a BDD
that represents a set of possible next assignments over Y. Observe
that at this stage, the next justice goal jis already decided. As in
thestaticapproach,asingleassignmentcanbechosenatrandom
or deterministically.
Remark1(Eagerness). ApropertyofJITSthatonemightcon-
sidereager,isthatitfirstandforemostconsiderstransitionsthatmake
progress towards satisfying the current justice guarantee, and resorts
to justice assumption violation only if conditions are not met. Theoriginal construction from [
5], on the other hand, always considers
ρ3transitions from any step, since they were already added to trans
BDD regardless.
638Algorithm 3 Controller next states for JITS
input:c∈2X∪Y,x∈2X,j∈[1...n]
1:ifc∈Js
jthen // corresponds to ρ1from Alg. 1
2:j/prime←j⊕1
3:rmin←min{r∈[1...rj/prime]|c∧x/prime∧ρ∧mY/prime[j/prime][r]/nequal∅}
4:N←mY[j/prime][rmin]
5:else
6:j/prime←j
7:rnew←min{r∈[1...rmin]|c∧x/prime∧ρ∧mY/prime[j/prime][r]/nequal∅}
8:ifrnew<rminthen // corresponds to ρ2from Alg. 1
9: rmin←rnew
10: N←mY[j/prime][rmin]
11:else // corresponds to ρ3from Alg. 1
12: imin←min{i∈[1...m]|c∈mX[j/prime][rmin][i]}
13: N←mX[j/prime][rmin][imin]
14:end if
15:end if
16:T←c∧x/prime∧ρ∧N/prime
17:T←QuantifyOutUnprimedVars (T)
18:T←Unprime(T)
19:returnT
Specifically, this creates a redundancy that the static construction
suffers from, and of which JITS is devoid. When the current state
satisfiesJs
j, Alg. 1 outputs as next states both Z(withZn=j⊕1)
andmX[j][1][i]for somei∈[1...m](withZn=j), since both ρ1
andρ3transitions are available. This may result in pairs of states
that agree on all variable values in X∪Yand disagree on the value
ofZn.Bloemetal.[ 5]attempttotacklethiscaseandminimizethe
transition system, but at the cost of a much larger BDD according to
their evaluation. In JITS, due to the inherent eagerness, this problem
does not exist.
3.3 Soundness and Deadlock-Freedom
JITS next states algorithm (Alg. 3) is sound w.r.t. the original static
approach, i.e., it does not return a state that the original static
approachwouldnothaveproduced.Moreover,JITSisdeadlock-free
w.r.t. the static approach,in the following sense: italways returns
a correct set of next states, if at least one such state exists. The
remainder of this subsection formalizes and proves these claims.
3.3.1 Formalization. Webridgethegapbetweentheoutputformat
of Alg. 2, where (multiple) possible assignments of Znare part
of the result BDD T, and Alg. 3, where the next justice goal is
deterministic and maintained outside the BDD state space.
Weusethetuple (s,k),wheres∈2Yandk∈[1...n],todescribe
an assignment sto system variables over Yalong with a justice
goalindex k.WedescribetheBDDoutputsofthestaticapproach
and JITS next state functions as a set of such tuples.
Givenc∈2X∪Y,x∈2X,andj∈[1...n],wedenote NSstatic
astheoutputofAlg.2and NSJITSastheoutputofAlg.3,inthe
formofasetoftuples (s,k).Letj/primebethevalueofthejusticegoal
index by the end of Alg. 3 for inputs c,x, andj. Observe that for
everytuple (s,k)∈NSJITS,khasthesamevalue,whichis j/prime,whileforeverytuple (s,k)∈NSstatic,kcanbeeither jorj⊕1(according
toZn).
Weproceedtostatethetheorems.Weassumecorrectenviron-
ment behavior, i.e., environment inputs that do not violate theenvironment assumptions. Soundness and deadlock-freedom for
the case of an environment assumption violation are trivial.
Theorem 1 (JITS is sound). For every c∈2X∪Y,x∈2X, and
j∈[1...n]:
NSJITS⊆NSstatic
Note the use of ⊆in Thm. 1. Equality happens when a ρ3transi-
tion is the onlytransition possible according to Alg. 1. In this case,
bothJITSandthestaticapproachkeepthejusticeguaranteegoal
indexintactandreturnnextstatesin mX[j][r][i]forsamevaluesof r
andi.Inallothercases,therelationbetween NSJITSandNSstatic
is a strict inclusion. In these cases, ρ2orρ1transitions are possible
aswell.WhileJITSwillignoreany ρ3transitionsthen,thestatic
approach will consider all possible transitions.
Theorem2(JITSisdeadlock-free). Forevery c∈2X∪Y,x∈
2X, andj∈[1...n]:
NSstatic /nequal∅=⇒NSJITS/nequal∅
3.3.2 Proofs. Denote the set of the intermediate results of the
fixed-point computations BDDs as FP:
FP={Z}∪/uniondisplay.1
j,r{mY[j][r]}∪/uniondisplay.1
j,r,i{mX[j][r][i]}
Observe that transBDD is a disjunction of transitions, each of
which is a BDD of the following form:
ZN∧A∧ρ∧B/prime∧ZN/prime
A∈FPrepresents a current set of states, B/prime∈FP/primerepresents
a primed next set of states, ZNrepresents an assignment to Zn,
andZN/primerepresentsanextassignmentto Zn.Therefore,line1in
Alg. 2 can be rewritten as:
T←( Zn=j)∧c∧x/prime∧/parenleftBig/logicalordisplay.1
all transitionsZN∧A∧ρ∧B/prime∧ZN/prime/parenrightBig
Alg. 2 extracts the next states from Tby targeting only primed
variables. Hence, we define NSstaticas follows:
NSstatic={(s|Y,s|Zn)|s∈x∧ρ∧/parenleftBig/logicalordisplay.1
all transitionsB∧ZN/parenrightBig
}
Observe that ZN’s support is the single variable Zn. We may re-
strictZnvalue to some k, and define NSstatic(k):
NSstatic(k)={(s|Y,k)|s∈x∧ρ∧/parenleftBig/logicalordisplay.1
Zn=kB/parenrightBig
}
Naturally, NSstatic(k)⊆NSstatic.
Similarly,JITSextractsthenextstatesfrom T,whichwascom-
puted in line 16 in Alg. 3. We define NSJITSas follows:
NSJITS={(s,j/prime)|s∈x∧ρ∧N}
N∈FP/{Z}is the BDD of next states. j/primeis the justice goal index
at the end of Alg. 3 for the given inputs.
639Proof of Thm. 1: JITS is sound. It is enough to show that
NSJITS⊆NSstatic(j/prime). Considering that xandρBDDs appear
on both sides, it is enough to show that N⊆/uniontext.1
Zn=j/primeB.
Weconsiderthreecases,basedontheassignmentto NinAlg.3:
•Nistheresultofcurrentstate csatisfying Js
j(lines3-4).Inthis
case,j/prime=j⊕1 andN=mY[j⊕1][rmin].
There is a corresponding ρ1transition with B=Zthat also
updatesZntoj⊕1. From Equ. 4 and Equ. 5 we know that
mY[j⊕1][rmin]⊆mY[j⊕1][rj]=Z.
•Nistheresultofthesystemprogressingatleastonesteptowards
satisfying its justice goal (lines 9-10). In this case, j/prime=jand
N=mY[j][rmin]for the lowest computed rmin.
Since previous rwas minimal such that c∈mY[j][r], there is a
corresponding ρ2transition with B=mY[j][r−1]that retains
Znvalue. From the fact that rmin≤r−1 and from Equ. 4 we
know that mY[j][rmin]⊆mY[j][r−1].
•Nistheresultofthesystemstayingatthesamedistancefrom
thejusticegoalandinsteadforcingtheenvironmenttoviolate
Je
ifor the minimal i(lines 12-13). In this case, j/prime=jandN=
mX[j][rmin][imin].
Sinceiis minimal such that c∈mX[j][rmin][i]there is a corre-
sponding ρ3transition with B=mX[j][rmin][imin]that retains
Znvalue.
/square
Proof of Thm. 2: JITS is deadlock-free. First we show that
NSstatic /nequal∅=⇒NSstatic(j/prime)/nequal∅. Consider two cases:
•There is a state (s,j⊕1)∈NSstaticthat is a result of a ρ1
transition, which also updates Zntoj⊕1. Hence, current state
satisfiesJs
jandsoj/prime=j⊕1inJITS.Thereforethisstateisalso
inNSstatic(j/prime).
•Allstates (s,j)∈NSstaticaretheresultof ρ2orρ3transitions,
which keep Znintact. Hence j/prime=jin JITS as well, and same
states are in NSstatic(j/prime).
We complete the proof by showing that NSstatic(j/prime)/nequal∅=⇒
NSJITS/nequal∅. Similarlyto Thm. 1, wecancel out xandρand show
that/uniontext.1
Zn=j/primeB/nequal∅impliesN/nequal∅.
We consider two cases:
•There is a B∈FPin/uniontext.1
Zn=j/primeBthat is a result of a ρ1orρ2
transition. In Alg. 3, either current state satisfies the current
justice goal (lines 3-4) or it is possible to decrease rat least by
one (lines 9-10). In any case, Nis assigned with one of the mY[][]
BDDs.
•AllB∈FPin/uniontext.1
Zn=j/primeBare the result of ρ3transitions. In this
case,thecontrollercannotprogresstowardssatisfyingcurrent
justicegoal.Alg.3doesn’tchange jandrindexes,andassigns
Nwith one of the mX[][][]BDDs (lines 12-13).
/square
4 EXTENSIONS
Thanks to the decoupling of synthesis from system execution, JITS
opensthewayforsynthesisindependentextensionsthatcanchange
system behavior at runtime, without the need to re-synthesize the
specification.Theseextensionscanbeimplementedasvariantsof
the controller loading procedures and of Alg. 3. The extensionsoughttobeindependentofeachother,andideallyoneshouldbe
able to combine multiple extensions during execution. We present
three such example extensions.
4.1 Justice Guarantees Bookkeeping
Schlaipferetal.[ 34]suggested“bookkeeping”asamethodtosatisfy
eachjusticeguaranteeasquicklyaspossible.Thisisachievedvia
a Boolean array that keeps track of the guarantees satisfied in the
current round and a master bit. On each step, the bookkeepingcode checks whether any guarantee other than the current goalis satisfied, and marks the relevant index in the Boolean array
accordingtothemasterbit.Whenthecurrentjusticegoalissatisfied
andthesystemchoosesitsnextgoal,itusesthearraytoretrieve
the smallest index not yet marked. Once all indexes in the array
are marked, it flips the master bit and starts a new round, with the
“bookkeeping” array and the master bit having inverted values.
We have added optional bookkeeping feature as an extension
to the basic JITS, with a slightly improved algorithm. Our method
tracks unsatisfied guarantees both backwards and forwards, i.e., it
doesnotwaituntilafullroundofjusticeguaranteesiscompleted
before it checks on a specific guarantee, but does so on every step.
The bookkeeping extension changes the basic JITS in two loca-
tions. First, we add “bookkeeping" array management code before
the call to JITS next states computation (Alg. 4). This code iterates
overalljusticeguarantees:foreach Js
kthatissatisfiedbythecur-
rentstate,thecodemarksthecorrespondingindex kinthebkarray
accordingtothe masterbit.Guaranteeswhoseindexissmallerthan
JITS’ current goal are marked with the opposite value of master.
This way, our method begins to track a new round even before the
system has satisfied all the remaining guarantees on the list.
Second, we replaced line 2 in Alg. 3 with the code in Alg. 5,
which returns the next justice goal according to bk,master, and
the current goal j. The method iterates over the justice guarantees
startingfromthe (j+1)-thplaceandfindsthesmallestindexwhose
justiceguaranteehasnotyetbeensatisfied.Onceitreachestheend
of the array, it flips the masterto indicate that a round of justice
guarantees has been completed, and then continues to iterate from
0t oj.
Note that in case all indexes in the bkarray are marked, the
algorithm simply returns to j. Specifically, this means that while
working its way to Js
j, the system has already satisfied all its other
justice guarantees.
4.2 Recovery
Wongetal.[ 38]suggestedcontrollerimplementationsthatattempt
torecoverincaseofenvironmentsafetyassumptionviolation.This
isachievedbyalteringtheoriginal,staticcontrollerconstruction
phase: removing the check whether a transition with a given en-
vironmentinputsatisfies ρeandisthereforeallowed,andinstead
considering allnext input possibilities. Then, the construction still
attemptstofindtransitionsthatensurethatthenextstatecankeep
satisfying the winning conditions, although such a next state may
not exist.
We have added optional recovery feature as an extension to the
basicJITS.Recallthatweassumedcorrectenvironmentbehaviorin
the previous sections. In this extension, we revisit this assumption
640Algorithm 4 Controller next states for JITS with bookkeeping
input:c∈2X∪Y,x∈2X,j∈1...n
1:for allk∈[j...n]do
2:ifbk[k]==masterandc∈Js
kthen
3: bk[k]←¬master
4:end if
5:end for
6:for allk∈[1...j−1]do
7:ifbk[k]==¬masterandc∈Js
kthen
8: bk[k]←master
9:end if
10:end for
11:returnnext states( c,x,j) // Call Alg. 3
Algorithm 5 Next justice goal for JITS with bookkeeping
input:j∈[1...n]
1:for allk∈[j+1...n]do
2:ifbk[k]==masterthen
3: returnk
4:end if
5:end for
6:master←¬master
7:for allk∈[1...j−1]do
8:ifbk[k]==masterthen
9: returnk
10:end if
11:end for
12:returnj
and do expect inputs that may violate environment safeties ρe
during runtime; instead of returning an error, we proceed with the
JITS next states algorithm and attempt to find a valid next state.
Recall that JITS always returns next states that are contained in
Z, which is the winning states set. Still, as in the static controller
recovery in [ 38], it may be the case that due to the environment
safetyviolation,nosuchpossiblenextstateexists,andthusnosuch
next state will be returned. Only in this case, the JITS recovery
extension returns an error, same as in the basic JITS variant.
4.3 Configurable Set of Justice Guarantees
Configurabilityisaknownextrafunctionalrequirement.Givena
familyofcloselyrelatedproducts,ratherthandevelopingaseparate
softwareforeach,oneisencouragedtodesignanddevelopasingleproduct that can be customized to a specific subset of the complete
requirements at deployment time. Configurability is related to the
ideaandmethodologyofsoftwareproductlines.Toapplyconfigura-bilitytoourdomainofsynthesizedreactivesystems,aconfigurablecontroller may be one that supports a set of justice guarantees that
is chosen from a larger superset of justice guarantees.
Inthestaticapproach,inordertoachievesuchconfigurability,a
uniquecontroller mustbesynthesized foreachrelevant subsetof
the justice guarantees, or alternatively, a unique flag variable must
bemaintainedinside thespecificationtorepresenttherelevanceof each justice guarantee, adding to the overall state space and
complexity of the specification.
In JITS however, this kind of configurability can be achieved at
execution time, via an extension that receives at load time a set
ofrequiredjusticeguaranteeindexesasanargument.Duringthe
extraction phase, JITS skips those indexes that are not in the set,
thusloadingonlytheBDDsrelevanttotheremainingindexes.This
solution does not affect synthesis time. It only requires that the
complete specification, containing allthe guarantees, is realizable.
Naturally,whenthecompletespecificationisrealizable,anyvariant
with only a subset of the justice guarantees is realizable as well.
Moreover,anyvariantwillbeavailableatdeploymenttime,sinceit
depends only on the required justice guarantees indexes argument.
Wehaveimplementedthisfunctionalityofconfigurablesetof
justiceguaranteesasanoptionalextensiontothebasicJITS.The
extension receives a set of required justice guarantee indexes as an
argument and loads only the BDDs relevant to these indexes. Note
that an execution based on the original basic JITS is still correct, as
the required set of justice guarantees is a subset of the completesuperset. However, one may expect that given a strict subset of
justice guarantees indexes, the extension typically loads faster and
takes less memory than the original basic JITS.
5 IMPLEMENTATION AND EVALUATION
WehaveimplementedJITSintheopensourceSpectra[ 2,25],which
alreadyincludesaGR(1)synthesizerandimplementationsofseveral
additional analyses. Our implementation in Java uses BDDs [ 6]
via the CUDD 3.0 [ 36] package. Realizability checking includes
heuristics described in [15].
All specifications used in our evaluation, the raw data we col-
lected, and the code to reproduce our experiments, are available in
supporting materials [1].
We consider the following research questions.
RQ0How does static controller construction time compare with
realizability checking time?
RQ1How does JITS compare with existing approaches duringsynthesis, w.r.t. time, memory usage, and size of its output
representation?
RQ2How does JITS compare with existing approaches duringsystem execution, w.r.t. load time, memory usage, and step
time?
Belowwereportontheexperimentswehaveconductedinorder
to answer the above questions.
5.1 Corpus of Specifications
We evaluate JITS using two sets of benchmark specifications from
the literature.
First,ARM’sAMBAAHBarbiter(AMBA)andIBM’sgeneralized
buffer (GenBuf). These two specifications have been extensivelyused in the GR(1) literature for evaluation purposes, e.g., in [
8,
15,18,20,29,34]. They are valuable as they are parametric and
therefore suitable for examining scalability.
Second, specifications from the SYNTECH benchmarks [ 15],
available from the Spectra website. These specifications were writ-
tenby3rdyearCSundergradsinclassprojectstaughtbytheauthorsof [
15]. The benchmarks have been used in some works [ 9,26,30].
641They include several versions of each specification submitted by
thestudents. Weuse herethe largestspecifications,i.e., allspecifi-
cations where the total number of variables is greater than 40. For
each, we use the final specification the students submitted. In total,
we use 5 specifications from the SYNTECH benchmarks.
5.2 Validation
We have systematically and automatically validated the correct-
nessofourimplementationbycreatingatestthatrunsthestatic
approach controller and the JITS step by step in parallel, against
thesameenvironmentbehaviors,andineverystep,checksthatthe
choice of next state by the latter is included in the possible next
statessuggestedbytheformer.Weexecutedthistestoverallthe
specifications in our corpus, against a random environment, for
runsof10,000steps.Thisvalidationincreasesourconfidenceinthe
correctness of our ideas and their implementation.
5.3 Experiment Setups
Weusedtwoseparateexperimentsetups,onetoexaminesynthesis
(RQ0, RQ1), the other to examine system execution (RQ2).
5.3.1 Synthesis setup. Forthe synthesissetup,wecompared JITS
againsttwoexistingtools:Slugs[ 13]andSpectra[ 25].Weusedthe
latestversionsofSlugsandSpectrafromGitHubandonlyadded
minimalcodetomeasuretimeandmemory.Bothtoolsuse(variants
of)theoriginalapproachfrom[ 5].Spectrarealizabilitychecking
includesallheuristicsdescribedin[ 15].WechosetocompareSpec-
tra against Slugs, and not against other GR(1) synthesizers, e.g.,
RATSY [4], as according to results in [ 15], the larger the specifica-
tion,thefasterSlugsrealizabilitycheckingtimecomparedtothatof
RATSY. Moreover, Slugs is a more recent tool; the version of Slugs
that we used is the latest available, from June 2018.
Wemeasuredsynthesistime,memoryused,andsizeofoutput
as follows. Synthesis time is the time of realizability checking com-
binedwithcontrollerconstructionorstoringtime.Memoryusedis
thenumberofactiveBDDnodesasreportedbyCUDD.Notethat
memory usage is as an important metric, as indeed some specifica-
tionscouldnotbesynthesized/executedsuccessfullybythestatic
approach due to an out-of-memory error. The size of the output is
the size of the output on disk.
We used a fixed timeout of two hours. We mark timeouts by
-.InsomecasesSlugsresultedinanout-of-memoryerrorduring
synthesis. We mark thesecases by xx. When synthesisfailed due
to any of these cases, we mark the other measures as n/a. All
values we report are median values of 10 runs per specification per
tool.Times wereportaremeasured byJavain milliseconds.Even
though the algorithms we deal with are deterministic, we repeated
each experiment 10 times since JVM garbage collection and CUDD
garbage collection add variance to running times.
For the specifications available for Slugs, AMBA and GenBuf,
wetooktheequivalentSpectraspecificationsavailablefrom[ 15],
and usedthem inthe comparisonbetween thethree tools.For the
specificationsfromtheSYNTECHbenchmarks,whicharericher
(e.g., include patterns) and therefore not available for Slugs, we
compared only between Spectra and JITS.
In this setup, we run all experiments on an ordinary PC, Intel
XeonW-2133CPU3.6GHz,32GBRAMwithWindows1064-bitOS,Table1: Comparisonofconstructionvs.realizabilityrunningtimes
for Slugs and Spectra
SpecificationSynthesis Time (sec)
Slugs Spectra
Real. Constr. Real. Constr.
AMBA1 0.20 0.02 0.20 0.17
AMBA2 3.32 0.25 1.52 1.63
AMBA3 44.18 2.94 21.18 130.33
AMBA4 2086.30 30.17 132.50 1030.89
AMBA5 – n/a 149.19 –
AMBA10 – n/a 2753.65 –
GenBuf5 1.50 0.65 0.18 0.27
GenBuf10 0.58 15.18 0.30 0.75
GenBuf20 1.46 xx 1.53 6.42
GenBuf30 3.88 xx 3.99 25.90
GenBuf40 16.09 xx 8.84 73.18
GenBuf90 331.15 xx 91.23 1486.84
AirportShuttle 48.04 7.79
Junction2 0.83 13.20
Junction3 9.21 1157.32
RoboticArm 3.97 12.33
SimpleVehicle 2.90 8.39
Java864Bit,andCUDD3compiledfor64Bit,usingonlyasingle
core of the CPU.
5.3.2 System execution setup. For the system execution setup, we
comparedJITSwithandwithoutthebookkeepingextensionagainst
Spectra. We could not compare againt Slugs because, to the best
of our knowledge, it does not provide a direct controller execution
API. We measured load time, memory used, and step time. We load
the controller and execute it for 10,000 steps against a random
environment.
Load time includes loading the BDDs, caching as described in
Sect. 3.2, and the initial step. Memory used is the number of active
BDDnodesasreportedbyCUDDlibraryattheendoftheexecution.
Steptimeisthetimetocomputethenextstep.Weuseaveragesteptimeoverthe10,000steps.Timeswereportaremedianvaluesof10
runs (of 10,000 steps each), per specification per tool, measured by
Java in milliseconds. Again, we repeated each experiment 10 times
to accommodate for the variance in running times.
InsomecasesSpectraresultedinanout-of-memoryerrorduring
load.Wemarkthesecasesby xx,andconsequentlywemarkthe
other measures for the same specification by n/a.
In this setup, we run all experiments on a Raspberry Pi 2 Model
B with 900MHz quad-core ARM Cortex-A7 CPU, 1GB of RAM
with Raspbian 8 32-bit OS, Java8 32Bit, and CUDD 3 compiled for
32Bit, using only a single core of the CPU. We chose this rather
weak computer (different and much weaker thanthe computer on
whichwerunsynthesis),asanexampleofatargetplatformfora
synthesized controller, e.g., a robot.
5.4 Results: Realizability vs. Construction
Table 1 presents a comparison between realizability and controller
construction times, in seconds, for Spectra and Slugs.
642Theresultsshowthatinbothtools,formostofthespecifications,
constructiontakesconsiderablymoretimethanrealizability(except
for the AMBA specifications for Slugs, and AirportShuttle). For
AMBA5 and up, Slugs could not complete realizability checking
and Spectra could not complete construction within the 2 hours
timeout. For GenBuf20 and up, Slugs construction resulted in an
out-of-memory error. In the extreme case of Junction3, more than
99%ofthetotalsynthesistimewasspentoncontrollerconstruction.
ToanswerRQ0:Wehaveevidenceshowingthatinbothtoolsand
for most of the specifications, construction takes significantlymoretimethanrealizabilitychecking.Thisevidenceisconsis-
tentwithdatareportedonin[ 5].Theseresultsstrengthenthe
motivation for JITS, which skips controller construction.
5.5 Results: Synthesis
Table2presentstheresultsforsynthesis.Foreachofthethreetools,
weshowconstruction/storingtimeinseconds,numberofactive
nodesinthousands,andspaceondiskinMb.NotethatJITSuses
Spectra realizability checking but replaces Spectra construction
with storing.
AMBA and GenBuf . In terms of construction time, the results
show that while Slugs and Spectra grow very fast with the size
ofthespecification(numberofmasters,numberofsenders),JITS
storingtimegrows,butmuchslower.Inabsoluteterms,inallbut
one specification (the smallest, AMBA1), JITS performs better than
bothothertools,sometimemorethananorderofmagnitudebetter.
In general, the larger the specification, the better the performance
of JITS relative to the two other tools.
Similarily,intermsofactivenodesandspaceondisk,theresults
show that whileSlugs and Spectragrowvery fast with thesize of
the specification, JITS growth is much slower.SYNTECH
.Thetablefurtherpresentstheresultsonspecifications
from the SYNTECH benchmarks. This part of the table does not
include data for Slugs as these specifications are rich; they include
patterns, monitors, etc., which are not supported by Slugs.
In terms of construction time, Spectra is in all cases higher than
JITSstoringtime.Asexpected,storingismuchfasterthanconstruc-
tion.
Intermsofactivenodesandspaceondisk,theresultsshowthat
JITSrequireslessmemoryanditsoutput’ssizeondiskissmaller,
in most cases, by a factor of 3 or more.
To answer RQ1: JITS outperforms existing approaches w.r.t. con-
struction time, memory usage, and output size, sometimes by
orders of magnitude. Moreover, JITS scales better than the other
two tools. The larger the specification, the better JITS synthesis
time,memoryusage,andsizeondiskcomparedtotheothertwo
tools.
5.6 Results: System Execution
Table3presentstheresultsforsystemexecution.Foreachofthe
twotools,weshowloadtimeinseconds,numberofactivenodesbytheendoftheexecutioninthousands,andsteptimeinmilliseconds.
For the number of active nodes and step time we show results also
for JITS with bookkeeping. We do not report load time for JITS
with bookkeeping since this extension is independent of this part.AMBA and GenBuf
.Intermsofloadtime,theresultsshowthat
whileSpectraloadtimegrowsveryfastwiththesizeofthespec-
ification (number of masters, number of senders), JITS load time
growsveryslowly.Inabsoluteterms,JITSloadtimeisalwaysfaster
than that of Spectra.
Intermsofactivenodesandsinglesteptime,theresultsshow
obvious advantage to JITS (with or without bookkeeping) as the
specifications grow larger.SYNTECH
.Thetablefurtherpresentstheresultsonspecifications
fromtheSYNTECHbenchmarks.Intermsofloadtime,activenodes,
andsinglesteptime,theresultsdonotshowaclearadvantageto
oneoftheapproachesovertheother.Inparticular,intermsofsingle
steptime,wedonotobservethatoneapproachisconsistentlybetter
than the other.
Weconsidertheseresults,forallspecifications,tobeagoodpoint
forJITS,as,apriori,onemayexpectthatgiventhecomputations
it has to do in every step, we would observe much slower step
timesforJITSthanforSpectra.However,recallthatthestatic trans
BDD,whichholdsallthetransitions,canbeverylarge.Loadingand
applying logical operations on large BDDs can be costly, and vary
greatlybasedonvariableordering.Incontrast,whiletypicallyJITShasahighernumberofoperationsperstep,theBDDsitmanipulates
are much smaller.
To answer RQ2: JITS does not compromise system execution
performance,andinsomecasesachievesevenbetterresultsthan
existing approaches w.r.t. load time, memory usage, and steptime. We also see that in many cases, JITS scales better than
Spectra.Thelargerthespecification,thebetterJITSloadtime,
memory usage, and step time compared to Spectra.
5.7 Threats to Validity
We briefly discuss threats to the validity of our results.
First,thesymboliccomputationsarenottrivialandourimple-
mentationmayhavebugs.Tomitigatethis,weperformedathor-
oughvalidationusingallspecificationsavailabletous,seeSect.5.2.
Second, even though the algorithms we deal with are determin-
istic,garbagecollectionoftheJVMandofCUDDaddvarianceto
running times. To mitigate this,werepeated each experiment 10
timesandwereportmedianvalues.CUDDdynamicreorderingmayresultinadditionalvariance.Duringrealizabilitychecking,weused
CUDD’sdefaultdynamicreorderingforalltools.Thisiscommon
practice in therelated literature, e.g., [ 5,26]. During construction,
we used the default for each tool2. During system execution, we
turned off dynamic reordering for Spectra and JITS because, for
both, it creates unpredictable occasional extremely slow steps.
Third,thespecificationsweusedintheevaluationmaynotbe
representativeof real-worldspecifications. Toalleviate thisthreat,
2Slugs turns it off, Spectra and JITS keep it on.
643Table 2: Comparison of Slugs (static), Spectra (static), and JITS: during synthesis
SpecificationConstruction Time (sec) Memory (# AN in thousands) Size on Disk (Mb)
Slugs Spectra JITS Slugs Spectra JITS Slugs Spectra JITS
Constr. Constr. Stor.
AMBA1 0.02 0.17 0.06 8.74 9.06 4.08 0.09 0.35 0.05
AMBA2 0.25 1.63 0.16 57.07 69.77 13.07 0.69 2.79 0.24
AMBA3 2.94 130.33 1.08562.94 904.68 65.29 9.48 33.07 0.94
AMBA4 30.17 1030.89 4.342649.62 2614.18 139.69 62.63 107.64 1.95
AMBA5 n/a – 10.83 n/a n/a 277.75 n/a n/a 6.24
AMBA10 n/a – 140.81 n/a n/a 1641.08 n/a n/a 46.00
GenBuf5 0.65 0.27 0.09 40.96 15.13 6.49 6.52 0.47 0.09
GenBuf10 15.18 0.75 0.17 13.53 30.07 6.64210.50 1.01 0.11
GenBuf20 xx 6.42 0.33 n/a 130.16 26.09 n/a 4.28 0.56
GenBuf30 xx 25.90 1.10 n/a 289.60 42.28 n/a 10.76 0.65
GenBuf40 xx 73.18 2.28 n/a 475.05 50.42 n/a 16.92 0.78
GenBuf90 xx 1486.84 33.68 n/a 2428.81 199.09 n/a 90.80 4.23
AirportShuttle 7.79 3.12 145.79 112.40 2.001.71
Junction2 13.20 0.27 294.16 13.96 10.43 0.29
Junction3 1157.32 5.54 5089.20 139.77 189.78 4.87
RoboticArm 12.33 5.74 282.34 67.91 9.691.96
SimpleVehicle 8.39 0.79 197.01 47.63 6.441.23
Table 3: Comparison of Spectra (static) and JITS: during system execution
SpecificationLoad Time (sec) Memory (# AN in thousands) Single Step Time (ms)
Spectra JITS Spectra JITS JITS w/ Bk. Spectra JITS JITS w/ Bk.
AMBA1 1.35 1.17 31.78 27.44 30.24 0.86 0.81 0.80
AMBA2 5.14 1.72 126.47 104.89 110.98 1.782.19 2.14
AMBA3 108.58 5.62 624.18 231.46 236.48 2.91 2.34 2.33
AMBA4 xx22.93 n/a355.30 420.65 n/a3.22 3.26
AMBA5 xx119.90 n/a611.46 711.47 n/a 4.22 4.24
AMBA10 xx2539.67 n/a2488.72 2724.19 n/a11.58 11.95
GenBuf5 1.64 1.43 98.30 49.77 66.55 1.951.52 1.67
GenBuf10 2.59 1.57 149.22 98.18 135.81 2.76 2.50 2.47
GenBuf20 13.84 3.17 349.35 165.27 161.71 6.03 5.20 4.97
GenBuf30 58.46 6.30 550.22 238.35 223.16 9.77 9.37 9.14
GenBuf40 170.52 12.61 980.38 422.54 394.45 16.12 14.52 13.48
GenBuf90 xx114.39 n/a 1646.85 1580.73 n/a 56.38 53.11
AirportShuttle 5.33 25.55 567.82 823.21 955.25 4.064.45 4.56
Junction2 15.20 2.191513.84 1607.80 1834.58 4.805.20 5.43
Junction3 xx54.46 n/a5321.92 6031.35 n/a 60.55 59.62
RoboticArm 20.63 24.23 806.99 1214.83 1258.72 7.258.22 8.17
SimpleVehicle 132.38 10.55 2249.34 1520.19 1631.03 8.82 8.18 8.07
we used several existing benchmarks from the literature. For the
AMBAandGenBufweuseddifferentnumberofmasters,asiscom-
mon practice in related literature. For the SYNTECH specifications,
we chose all specifications where number of variables is greater
than 40, see Sect. 5.1.
Finally,oursystemexecutionsetuprunsthecontrollerfor10,000
stepsagainstarandom(yet correct)environment,seeSect.5.3.In
practice, environment behavior is not expected to be random. Real
environmentbehaviorisnotavailableforthespecificationsathand.
That said, we are not aware of reasons to believe that next stepperformance against a real environment would be different than
what we observed, neither for Spectra nor for JITS.
6 RELATED WORK
GR(1) synthesis was introduced in [ 31]. It has since been used and
investigated by many, including, e.g., Kress-Gazit et al. [ 19,39],
whousedGR(1)inrobotics;MaozandRingert[ 23],whoshowed
GR(1) synthesis for specification patterns; Cavezza and Alrajeh [ 8],
who investigated assumptions refinement in unrealizable GR(1)
specifications,tolistafew.SeveraltoolssupportGR(1)synthesis,
644e.g.,RATSY[ 4],Slugs[13],andSpectra[ 25].Noneoftheseworks
and tools considered just-in-time synthesis.
Heuristics to improve the running time performance of GR(1)
synthesishavebeensuggestedin[ 10,15,34].Specifically,Firmanet
al.[15]presentandevaluateheuristicsatthelevelofthecontrolled
predecessor computation and BDDs, as well as heuristics for early
detection of fixed-points and early detection of unrealizability. The
work,however,is limitedtoacceleratingtherealizabilitychecking
phase. It has no effect on the controller construction phase and
no effect on system execution performance. The suggested heuris-
tics are implemented in Spectra. As noted earlier, our comparison
against Spectra includes all these heuristics.
Dathathri and Murray [ 10] suggest efficient GR(1) synthesis for
specifications with singleton liveness guarantees, i.e, guarantees
thatarelimitedtoasinglestate.Ourwork,however,isindependent
of any such restrictions on the GR(1) specifications.
Schlaipfer et al. [ 34] present an approach to GR(1) synthesis
without, what they refer to as a monolithic strategy, applied to
hardware synthesis. They synthesize several separate strategies,
one for each justice guarantee, and manage them via auxiliary
circuits.Thisreducesstrategyconstructiontimeandmemoryusage
at the expense of a major increase in circuit size. Evaluation is
limited to the AMBA specifications.
Heuristics to improve realizability and strategy construction
timeshavealsobeensuggestedintheseriesofSYNTCOMPcompe-
titions, e.g., [ 17]. The competition measures realizability checking
and strategy construction times where the targets are hardware
circuits,not softwaresystems.Evidently, JITSisapplicable tosyn-
thesized software systems, not hardware circuits. Moreover, the
specificationsusedinthecompetitionareeitherLTLorsafety-only
specifications. Our work focuses on GR(1) specifications, which on
the one hand are not as expressive as LTL but on the other hand
includenotonlysafetybutalsojusticeassumptionsandguarantees.
Thus, we cannot evaluate our work against the competition’s tools
and specifications.
In particular, Strix [ 21] is an LTL reactive synthesis tool, which
hasrecentlygainedattentionduetopromisingresultsintheSYNT-
COMP competition. Strix decomposes the LTL formula into sim-
plerformulas,translatestheseon-the-flyintodeterministicparity
automata, solves the intermediate parity games using strategy iter-
ation,andfinallytranslatesthewinningstrategy,ifitexists,into
aMealymachineoranAIGERcircuitwithoptionalminimization
using external tools. Only during the last step, the authors discuss
encoding of the Mealy machine as a BDD. Hence, one may con-
sider applying the concept of JITS (perhaps redesigned to adapt to
thedomain ofdeterministic parityautomata insteadofGR(1)) torevise this encoding and open the way for efficient execution of
controllers synthesized with Strix.
Finally,onemayconsiderJITStobesimilartoon-the-flyalgo-
rithmsinmodelcheckingandgamesanalysis,e.g.,[ 7,35].However,
these algorithms are meant to improve the performance of verifica-tionorrealizabilitychecking.JITS,incontrast,isanovelmeansfortheexecution ofthesynthesizedsystem.Itusesthesamerealizability
checking as the static approaches to GR(1) synthesis.7 CONCLUSION
We introduced JITS, just-in-time synthesis for GR(1). JITS provides
a novel, fast, and flexible means to execute synthesized controllers.
Itdoesnotcompromisethecorrect-by-constructionpromise,while,
fromarchitecturalandmethodologicalperspectives,itopensthe
way for the decoupling of realizability checking and system execu-
tion.
WehaveimplementedJITSontopoftheSpectrasynthesizer.We
showedthatcomparedtoexisting,staticapproaches,JITSgreatly
improves overall synthesis time, memory usage, and output size,
and scales better with larger specifications. Moreover, we showed
thatJITSremainscompetitivecomparedtothestaticapproachin
system execution performance w.r.t. time and space.
As future work we consider the following research directions.
First, one may investigate how to adapt JITS to specific system
execution platforms,and how tocontrol the tradeoffbetween per-
formance and memory consumption of JITS execution, potentially,
for example, using BDD reordering or different, possibly adaptive,
caching mechanisms.
Second, to further enhance the configurability of synthesized
controllers atload time,one maysuggest differentstoring mecha-
nisms.
Finally,mostrecently,Amrametal.havepresentedGR(1)*,anex-
tension of GR(1) with existential guarantees [ 3]. One may consider
to define and implement JITS for GR(1)*.
ACKNOWLEDGEMENTS
WethankOrPistinerandYanivSa’arforhelpfuladvice.Thisproject
hasreceivedfundingfromtheEuropeanResearchCouncil(ERC)
undertheEuropeanUnion’sHorizon2020researchandinnovation
programme (grant agreement No 638049, SYNTECH).
645REFERENCES
[1][n.d.]. JITS Supporting Materials Website. http://smlab.cs.tau.ac.il/syntech/jits/.
[2] [n.d.]. Spectra Website. http://smlab.cs.tau.ac.il/syntech/spectra/.
[3]Gal Amram, Shahar Maoz, and Or Pistiner. 2019. GR(1)*: GR(1) Specifications
ExtendedwithExistentialGuarantees.In FormalMethods-TheNext30Years-
Third World Congress, FM 2019, Porto, Portugal, October 7-11, 2019, Proceedings
(Lecture Notes in Computer Science), Maurice H. ter Beek, Annabelle McIver, and
José N. Oliveira (Eds.), Vol. 11800. Springer, 83–100. https://doi.org/10.1007/978-
3-030-30942-8_7
[4]Roderick Bloem, Alessandro Cimatti, Karin Greimel, Georg Hofferek, Robert
Könighofer, Marco Roveri, Viktor Schuppan, and Richard Seeber. 2010. RATSY -
A New Requirements Analysis Tool with Synthesis. In CAV (LNCS), Vol. 6174.
Springer, 425–429. http://dx.doi.org/10.1007/978-3-642-14295-6_37
[5]Roderick Bloem, Barbara Jobstmann, Nir Piterman, Amir Pnueli, and Yaniv Sa’ar.
2012. Synthesis of Reactive(1) Designs. J. Comput. Syst. Sci. 78, 3 (2012), 911–938.
http://dx.doi.org/10.1016/j.jcss.2011.08.007
[6]Randal E. Bryant. 1986. Graph-Based Algorithms for Boolean Function Manipu-
lation.IEEE Trans. Computers 35, 8 (1986), 677–691. https://doi.org/10.1109/TC.
1986.1676819
[7]Franck Cassez, Alexandre David, Emmanuel Fleury, Kim Guldstrand Larsen, and
Didier Lime. 2005. Efficient On-the-Fly Algorithms for the Analysis of TimedGames. In CONCUR 2005 - Concurrency Theory, 16th International Conference,
CONCUR2005,SanFrancisco,CA,USA,August23-26,2005,Proceedings (Lecture
Notes in Computer Science), Martín Abadi and Luca de Alfaro (Eds.), Vol. 3653.
Springer, 66–80. https://doi.org/10.1007/11539452_9
[8]Davide G. Cavezza and Dalal Alrajeh. 2017. Interpolation-Based GR(1) Assump-
tionsRefinement.In TACAS (LNCS),Vol.10205.281–297. https://doi.org/10.1007/
978-3-662-54577-5_16
[9]Davide G. Cavezza, Dalal Alrajeh, and András György. 2019. Minimal As-sumptions Refinement for GR(1) Specifications. CoRRabs/1910.05558 (2019).
arXiv:1910.05558 http://arxiv.org/abs/1910.05558
[10]Sumanth Dathathri and Richard M. Murray. 2017. Decomposing GR(1) games
withsingletonlivenessguaranteesforefficientsynthesis.In 56thIEEEAnnual
ConferenceonDecisionandControl,CDC2017,Melbourne,Australia,December
12-15, 2017. IEEE, 911–917. https://doi.org/10.1109/CDC.2017.8263775
[11]Nicolás D’Ippolito, Víctor A. Braberman, Nir Piterman, and Sebastián Uchitel.2013. Synthesizing nonanomalous event-based controllers for liveness goals.ACM Trans. Softw. Eng. Methodol. 22, 1 (2013), 9. http://doi.acm.org/10.1145/
2430536.2430543
[12]Matthew B.Dwyer, GeorgeS. Avrunin,and JamesC. Corbett.1999. Patternsin
Property Specifications for Finite-State Verification. In ICSE. ACM, 411–420.
[13]RüdigerEhlersandVasumathiRaman.2016. Slugs:ExtensibleGR(1)Synthesis.
InCAV (LNCS), Vol. 9780. Springer, 333–339. https://doi.org/10.1007/978-3-319-
41540-6_18
[14]IoannisFilippidis,SumanthDathathri,ScottC.Livingston,NecmiyeOzay,and
Richard M. Murray. 2016. Control design for hybrid systems with TuLiP: The
TemporalLogicPlanningtoolbox.In 2016IEEEConferenceonControlApplications,
CCA2016,BuenosAires,Argentina,September19-22,2016.IEEE,1030–1041. https:
//doi.org/10.1109/CCA.2016.7587949
[15]Elizabeth Firman, Shahar Maoz, and Jan Oliver Ringert. 2020. Performanceheuristics for GR(1) synthesis and related algorithms. Acta Inf. 57, 1-2 (2020),
37–79. https://doi.org/10.1007/s00236-019-00351-9
[16]D. Hareland A. Pnueli.1985. On theDevelopment of ReactiveSystems. Springer
BerlinHeidelberg,Berlin,Heidelberg,477–498. https://doi.org/10.1007/978-3-
642-82453-1_17
[17]Swen Jacobs, Roderick Bloem, Maximilien Colange, Peter Faymonville, Bernd
Finkbeiner, Ayrat Khalimov, FelixKlein, Michael Luttenberger, Philipp J.Meyer,
Thibaud Michaud, Mouhammad Sakr, Salomon Sickert, Leander Tentrup, and
Adam Walker. 2019. The 5th Reactive Synthesis Competition (SYNTCOMP
2018): Benchmarks, Participants & Results. CoRRabs/1904.07736 (2019).
arXiv:1904.07736 http://arxiv.org/abs/1904.07736
[18]Robert Könighofer, Georg Hofferek, and Roderick Bloem. 2013. Debuggingformal specifications: a practical approach using model-based diagnosis and
counterstrategies. STTT15,5-6(2013),563–583. http://dx.doi.org/10.1007/s10009-
011-0221-y
[19]Hadas Kress-Gazit, Georgios E. Fainekos, and George J. Pappas. 2009. Temporal-
Logic-BasedReactiveMissionandMotionPlanning. IEEETrans.Robotics 25,6
(2009), 1370–1381. http://dx.doi.org/10.1109/TRO.2009.2030225
[20]Aviv Kuvent, Shahar Maoz, and Jan Oliver Ringert. 2017. A symbolic justice
violations transition system for unrealizable GR(1) specifications. In Proceedings
of the 2017 11th Joint Meeting on Foundations of Software Engineering, ESEC/FSE
2017, Paderborn, Germany, September 4-8, 2017, Eric Bodden, Wilhelm Schäfer,
Arie van Deursen, and Andrea Zisman (Eds.). ACM, 362–372. https://doi.org/10.
1145/3106237.3106240
[21]Michael Luttenberger, Philipp J. Meyer, and Salomon Sickert. 2020. Practicalsynthesis of reactive systems from LTL specifications via parity games. Acta
Informatica 57, 1-2 (2020), 3–36. https://doi.org/10.1007/s00236-019-00349-3[22] Spyros Maniatopoulos, Philipp Schillinger,Vitchyr Pong, DavidC. Conner, and
Hadas Kress-Gazit. 2016. Reactive high-level behavior synthesis for an Atlas
humanoidrobot.In 2016IEEEInternationalConferenceonRoboticsandAutomation,
ICRA2016,Stockholm,Sweden,May16-21,2016,DanicaKragic,AntonioBicchi,
and Alessandro De Luca (Eds.). IEEE, 4192–4199. https://doi.org/10.1109/ICRA.
2016.7487613
[23]Shahar Maoz and Jan Oliver Ringert. 2015. GR(1) synthesis for LTL specification
patterns.In ESEC/FSE.ACM,96–106. http://doi.acm.org/10.1145/2786805.2786824
[24]ShaharMaozandJanOliverRingert.2015. SynthesizingaLegoForkliftController
in GR(1): A Case Study. In Proc. 4th Workshop on Synthesis, SYNT 2015 colocated
with CAV 2015 (EPTCS), Vol. 202. 58–72.
[25]Shahar Maoz and Jan Oliver Ringert. 2019. Spectra: A Specification Languagefor Reactive Systems. CoRRabs/1904.06668 (2019). arXiv:1904.06668 http:
//arxiv.org/abs/1904.06668
[26]Shahar Maoz, Jan Oliver Ringert, and Rafi Shalom. 2019. Symbolic repairs for
GR(1)specifications.In Proceedingsofthe41stInternationalConferenceonSoft-
ware Engineering, ICSE 2019, Montreal, QC, Canada, May 25-31, 2019, Gunter
Mussbacher, Joanne M. Atlee, and Tevfik Bultan (Eds.). IEEE / ACM, 1016–1026.
https://dl.acm.org/citation.cfm?id=3339632
[27]Shahar Maoz and Yaniv Sa’ar. 2011. AspectLTL: an aspect language for LTLspecifications. In AOSD, Paulo Borba and Shigeru Chiba (Eds.). ACM, 19–30.
http://doi.acm.org/10.1145/1960275.1960280
[28]Shahar Maoz and Yaniv Sa’ar. 2012. Assume-Guarantee Scenarios: Semantics
andSynthesis.In MODELS (LNCS),Vol.7590.Springer,335–351. http://dx.doi.
org/10.1007/978-3-642-33666-9_22
[29]ShaharMaozandRafiShalom.2020. InherentVacuityforGR(1)specifications.
InESEC/FSE. To appear.
[30]Claudio Menghi, Christos Tsigkanos, Patrizio Pelliccione, Carlo Ghezzi, and
Thorsten Berger. 2019. Specification Patterns for Robotic Missions. CoRR
abs/1901.02077 (2019). arXiv:1901.02077 http://arxiv.org/abs/1901.02077
[31]NirPiterman,AmirPnueli,andYanivSa’ar.2006. SynthesisofReactive(1)De-
signs.InVMCAI (LNCS),Vol.3855.Springer,364–380. http://dx.doi.org/10.1007/
11609773_24
[32]Amir Pnueli. 1977. The Temporal Logic of Programs. In 18th Annual Symposium
onFoundationsofComputerScience,Providence,RhodeIsland,USA,31October-
1November1977.IEEEComputerSociety,46–57. https://doi.org/10.1109/SFCS.
1977.32
[33]AmirPnueliandRoniRosner.1989. OntheSynthesisofaReactiveModule.In
POPL. ACM Press, 179–190.
[34]Matthias Schlaipfer, Georg Hofferek, and Roderick Bloem. 2011. Generalized
Reactivity(1) Synthesis without a Monolithic Strategy. In Hardware and Software:
VerificationandTesting-7thInternationalHaifaVerificationConference,HVC2011,
Haifa, Israel, December 6-8, 2011, Revised Selected Papers. 20–34.
[35]Stefan Schwoon and Javier Esparza. 2005. A Note on On-the-Fly Verification
Algorithms. In Tools and Algorithms for the Construction and Analysis of Systems,
11th International Conference, TACAS 2005, Held as Part of the Joint European
Conferences on Theory and Practice of Software, ETAPS 2005, Edinburgh, UK, April
4-8,2005,Proceedings (LectureNotesinComputerScience),NicolasHalbwachsand
Lenore D. Zuck (Eds.), Vol. 3440. Springer, 174–190. https://doi.org/10.1007/978-
3-540-31980-1_12
[36]Fabio Somenzi. 2015. CUDD: CU Decision Diagram Package Release 3.0.0. http:
//vlsi.colorado.edu/~fabio/CUDD/cudd.pdf.
[37]AdamWalkerandLeonidRyzhyk.2014. Predicateabstractionforreactivesynthe-sis.InFormalMethodsinComputer-AidedDesign,FMCAD2014,Lausanne,Switzer-
land,October21-24,2014.IEEE,219–226. http://dx.doi.org/10.1109/FMCAD.2014.
6987617
[38]KaiWengWong,RüdigerEhlers,andHadasKress-Gazit.2014. CorrectHigh-level
RobotBehaviorinEnvironmentswithUnexpectedEvents.In Robotics:Science
and Systems X, University of California, Berkeley, USA, July 12-16, 2014, Dieter
Fox,LydiaE.Kavraki,andHannaKurniawati(Eds.). https://doi.org/10.15607/
RSS.2014.X.012
[39]KaiWengWong,RüdigerEhlers,andHadasKress-Gazit.2018.Resilient,Provably-
Correct, and High-Level Robot Behaviors. IEEE Trans. Robotics 34, 4 (2018),
936–952. https://doi.org/10.1109/TRO.2018.2830353
646