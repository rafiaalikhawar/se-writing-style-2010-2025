FeatureTrace Recording
Paul MaximilianBittner
paul.bittner@uni-ulm.de
Universityof Ulm
Ulm, GermanyAlexander SchultheiÃŸ
alexander.schultheiss@hu-berlin.de
Humboldt-Universityof Berlin
Berlin, GermanyThomasThÃ¼m
thomas.thuem@uni-ulm.de
Universityof Ulm
Ulm, Germany
Timo Kehrer
timo.kehrer@hu-berlin.de
Humboldt-Universityof Berlin
Berlin, GermanyJeffreyM.Young
youngjef@oregonstate.edu
OregonStateUniversity
Corvallis, USALukas Linsbauer
l.linsbauer@tu-braunschweig.de
TUBraunschweig
Braunschweig,Germany
ABSTRACT
Tracingrequirementstotheirimplementationiscrucialtoallstake-
holdersofasoftwaredevelopmentprocess.Whenmanagingsoft-
warevariability,requirementsaretypicallyexpressedintermsof
features, a feature being a user-visible characteristic of the soft-
ware.Whilefeaturetracesarefullydocumentedinsoftwareproduct
lines,ad-hocbranchingandforking,knownasclone-and-own,is
stillthedominantwayfordevelopingmulti-variantsoftwaresys-
tems in practice. Retroactive migration to product lines suffers
from uncertainties and high effort because knowledge of feature
traces must be recovered but is scattered across teams or even lost.
We propose a semi-automated methodologyfor recording feature
tracesproactively, duringsoftwaredevelopmentwhentheneces-
sary knowledge is present. To support the ongoing development of
previouslyunmanagedclone-and-ownprojects,weexplicitlydeal
withtheabsenceofdomainknowledgeforbothexistingandnew
sourcecode. We evaluatefeature tracerecording byreplayingcode
edit patterns from the history of two real-world product lines. Our
results show that feature trace recording reduces the manual effort
tospecifytraces.Recordedfeaturetracescouldimproveautomation
in change-propagation among cloned system variants and could
reduce effortif developers decideto migrateto aproduct line.
CCS CONCEPTS
Â·Softwareanditsengineering â†’Softwareconfigurationman-
agement andversioncontrolsystems ;Software evolution .
KEYWORDS
featuretraceability,featurelocation,disciplinedannotations,clone-
and-own,software product lines
ACMReference Format:
PaulMaximilianBittner,AlexanderSchultheiÃŸ,ThomasThÃ¼m,TimoKehrer,
JeffreyM.Young,andLukasLinsbauer.2021.FeatureTraceRecording.In
Proceedingsofthe29thACMJointEuropeanSoftwareEngineeringConference
andSymposiumontheFoundationsofSoftwareEngineering(ESEC/FSEâ€™21),
August 23Å›28, 2021, Athens, Greece. ACM, New York, NY, USA, 14pages.
https://doi.org/10.1145/3468264.3468531
Publication rights licensed to ACM. ACM acknowledges that this contribution was
authoredorco-authoredbyanemployee,contractororaffiliateof anationalgovern-
ment.Assuch,theGovernmentretainsanonexclusive,royalty-freerighttopublishor
reproducethisarticle, orto allowothers to do so, for Government purposes only.
ESEC/FSE â€™21, August 23Å›28,2021, Athens,Greece
Â©2021 Copyright heldby the owner/author(s). Publicationrightslicensed to ACM.
ACM ISBN 978-1-4503-8562-6/21/08...$15.00
https://doi.org/10.1145/3468264.34685311 INTRODUCTION
For comprehending, maintaining, and extending existing software,
itiscrucialtofindlocationsofinterestinasoftwaresystemquickly,
reliably, and exhaustively [ 48,89,98]. To that end, tracing require-
mentstotheirimplementationisoneofthemostcommonactivities
of developers and crucial to all stakeholders of a software develop-
ment process [ 13,35,78,83,89,98,100]. Whenmanaging software
variability,requirementsaretypicallyexpressedintermsof features,
afeaturebeinginformallydefinedasauser-visiblecharacteristic
of the software [ 12]. Afeature trace identifies those artefacts of the
softwaresystemthatimplementacertainfeature,thusindicating
where,how,andwhichfeatures are implemented[ 8,19].
While features, their dependencies, and their locations are fully
documented in software product-line engineering [ 8,19,77], it
is rarely adopted in practice. The reasons for poor adoption are
unforeseenrequirementsatthebeginningofdevelopment[ 57],a
highup-frontinvestment[ 16,57],lackoftoolsupport[ 93],missing
flexibility[ 7,84,93], andnecessary workflowadaptations [ 7].
Inpractice, developmentbegins withonly asingle systemvari-
antofthesoftwaresystemtoreducecomplexityandcosts,orbe-
cause the need for future variants is unknown [ 7,24,57]. When
the demand for a new variant emerges, a fast and easy approach is
clone-and-own[ 7,24,84,93]:Bycloningthewholesoftwaresystem
toalterspecificpartsindependentlyfromthepreviousvariant(e.g.,
using branches or forks), developers can explore new ideas rapidly
andwithoutputtingtheactualsystematrisk[ 24,93].Thesecloned
variantsaremeanttoco-existwiththeoriginalvarianttoimplement
variability.Unfortunately,propagatingchangessuchasbugfixesto
other cloned variants is increasingly difficult and ambiguous with
agrowingnumberofvariants[ 7,24,41,51,57,84,93].Therefore,
a considerable amount of research focuses on migrating clone-and-
own software to product lines, allowing developers to switch to
an integrated platform when managing a set of variants in parallel
becomes infeasible [ 28,40,47,50,102]. However, migrations suf-
fer from high uncertainties because knowledge of feature traces is
scattered across the team or even lost [ 7,24,45,51,84,85,93]. The
migration to a product line may even fail and thus bears consider-
ableeconomical risks[ 28].
Wepropose featuretracerecording ,amethodologytoinferfea-
turetracessemi-automaticallyuponsourcecodechanges.Themain
ideaisthatbyrecordingfeaturetracesduringdevelopment,they
neither have to be recovered retroactively, suffering from uncer-
tainties, nor specified explicitly in a separate step, which causes
1007
ESEC/FSE â€™21, August 23Å›28, 2021,Athens,Greece P. M. Bittner, A.SchultheiÃŸ, T. ThÃ¼m,T. Kehrer, J. M. Young, L.Linsbauer
void pop() {
storage[head--] = null;
}
insert
context: 
SafeStack
void pop() {
if (!empty()) {
}
storage[head--] = null;
}
move
context: 
null
void pop() {
if (!empty()) {
storage[head--] = null;
}
}
context:ImmutableStackdelete
(1) (2) (3)
Stack<T> pop() {
Stack<T> c = clone();
if (!empty()) {
c.storage[c.head--] = null;
}
return c;
}
update
context:
ImmutableStack
void pop() {
Stack<T> c = clone();
if (!empty()) {
c.storage[c.head--] = null;
}
return c;
}
insert
context:
ImmutableStack
void pop() {
if (!empty()) {
}
}
(6) (5) (4)
Figure 1:Feature traces are recorded upon edits fromthefeature contextspecified by the developer.
overheadstotheactualsourcecodeeditingandbecomesincreas-
inglydifficultastimepassessincethelastedit.WhileJietal.showed
withhighmanualeffortthatrecordingfeaturetracesearlycansup-
portteamsinmanagingclone-and-ownsoftware[ 35],wearethe
firsttoproposeasemi-automatedmethodologythatinspectsdevel-
oper edits. Our core design philosophy is that contributing domain
knowledgeintheformoffeaturetracesmustplaceminimalburden
ontheuserinordertobeaccepted.Asdevelopersmightnotalways
know to which feature an edited artefact belongs, and because fea-
ture traces are initially absent inclone-and-own development, we
specificallydealwithabsentdomainknowledgeonbothnewand
existing sourcecode.
In our envisioned methodology, software development is per-
formed according to a session-oriented editing model where de-
velopers mayspecify the feature or feature interaction they are
currently implementing. From the edits developers make under
suchafeaturecontext ofaneditingsession,ourrecordingalgorithm
infers feature traces for changed source code automatically. More-
over, by employing disciplined annotations by KÃ¤stner et al. [ 37]
withAbstractSyntaxTrees( ASTs)[38],wereleasedevelopersfrom
manual,laborious,anderror-pronetasks,suchasassigningopening
andclosingbracketstospecifyfeaturetraceswhicharescattered
among several code fragments. In summary, our contributions are:
Feature TraceRepresentation (Sec.3).Wegeneralizesoftware
product-line concepts to clone-and-own by explicitly encod-
ingmissingdomainknowledge.
Feature TraceRecording (Sec.4).Wepresentamethodologyfor
recording feature traces upon artefact changes from a possi-
bly empty featurecontext specifiedbythe developer.
Prototype andEvaluation (Sec. 5). We show that feature trace
recordingreducesmanualefforttospecifytracesandenables
evolving variability in clone-and-own at the level of edits
common to software product lines.
2 OVERVIEW
Beforeformallyintroducingfeaturetracerecording,weillustrate
how developers can record feature traces, and show its potential
impact by describing how recorded feature traces can (1) guide
synchronisationsinclone-and-owndevelopmentand(2)beused
as inputfor amigrationto asoftware product line.2.1 Motivating Example
Fig. 1illustrates feature trace recording from the perspective of
an imaginary Java developer called Alice, who is responsible for a
singlesoftwarevariant(e.g.,abranchorfork).Alicerefinesthe pop
methodofaclass Stack.Wehighlightsourcecodeimplementing
certainfeatures withcorresponding colours.
Nofeaturetracesarepresentintheinitialcode(1),illustratedby
theabsenceofcolours.Alicenoticesthe popmethodisunsafe;it
doesnotcheckforanemptystack.Shedecidesthiserrorshouldonly
bepreventedwhendefensiveprogrammingisdesired,namelywhen
thefeature SafeStack isimplemented.Alicemakesthisdecision
explicit byspecifying SafeStack as thefeature context of heredit
(shown below arrows in Fig. 1). She inserts a condition to check
whether the stack is empty, yielding snapshot (2). The inserted
codeis recordedasbelonging to thefeature SafeStack . Afterthe
insertion,Alicehastomovetheoriginalimplementationofthe pop
methodintothecondition.AsAliceisnottheoriginaldeveloperof
thepopmethod,whichdoesnotexhibitanyfeaturetraces,sheis
unsurewhichfeaturethemovedstatementbelongsto.Byswitching
totheemptyfeaturecontext(denotedas null),Alicecancontinue
her working session without having to recover missing knowledge.
Insnapshot(3),themovedstatementisnotassociatedtoanyfeature.
Later, Alice is assigned anew issue: Stacksshould be immutable .
Shesetsthefeaturecontextto ImmutableStack forthesessionand
continuesworkingonthe popmethod.First,shedeletesthestate-
ment that modifies the stackâ€™s storage, leading to snapshot (4).
Second, she inserts new code to implement the immutable variant
(5) ofpop. All inserted code is recorded to belong to the feature
ImmutableStack ,asspecifiedbythefeaturecontext.Finally,there-
turntypeof pophastobeupdatedfrom voidtoStack<T> ,leading
tosnapshot(6).Featuretracerecordingassigns ImmutableStack
to the updatedreturn type.
In this example, Alice did not have to specify traceability in-
formationforeachchangedcodefragmentmanually.Instead,she
could record feature traces for almost the entire popmethod from
justthreedifferentfeaturecontexts.Thefeaturecontextisacon-
ceptweintroduceforfeaturetracerecording.It maybespecified
bydeveloperstoindicatethefeatureorfeatureinteractiontheyare
currently editing.
Ingeneral,featuretracerecordingisnottiedtoanyspecifictask
intheworkflowofdevelopers,suchascommitstoaversioncontrol
1008Feature Trace Recording ESEC/FSE â€™21, August 23Å›28, 2021,Athens,Greece
Figure 2: Feature traces recorded in several variants. Fea-
turesare indicated by differentcolours.
system. Instead, we record feature traces at the granularity of edits,
whichweachievewithdifferencingtechniquesorloggingediting
commands as explained later in Sec. 4. In our example, Alice could
commit to versioncontrolafter herfirsttwoeditsandat the end.
2.2 Scenario1: Enhancing Clone-and-Own
InFig.2,weframehowfeaturetracerecordingcouldenhanceclone-
and-own development. By knowing feature traces (top row) and
which variants implement those features (bottom row), target vari-
ants and code chunks for change synchronisation can be identified
automatically. The only prerequisites are thatdevelopers agree on
acommonsetoffeatures[ 58,83]anddocumentwhichfeaturesare
implemented by which variant [ 29,57,58]. This means, a cloned
variantisequippedwitha configuration [10,19],stating foreach
feature whether it is implemented in this variant or not. In our
example, Alice knows that her variantâ€™s configuration (bottom left)
includesatleastthetwofeatures SafeStack andImmutableStack .
Imagine a second developer, Bob, wants to propagate Aliceâ€™s
changesfrom Fig.1intohisvariant,assumingthatbothvariants
are two of several cloned variants in a clone-and-own project.
Bobâ€™s variant implements the feature SafeStack but not feature
ImmutableStack .Furtherassumethatbothvariantsstartedwith
version (1) of popinFig. 1and Bob did not apply simultaneous
changes.PropagatingAliceâ€™seditstoBobâ€™svariantyieldstheim-
plementation shown in Fig. 3. AsSafeStack is implemented in
Aliceâ€™sandBobâ€™svariant,propagatingthefirsttwoeditsfrom Fig.1
will yield the same code as in snapshot (3). Subsequent edits on
ImmutableStack arenotsynchronisedasthisfeatureisnotpresent
inBobâ€™svariant.
Nonetheless,Alice deletedthestatement storage[headâˆ’âˆ’] =
nullfromfeature ImmutableStack .Thismeansthatthestatement
doesnotbelong to ImmutableStack but it is still valid in those
variantsthatdonotimplement ImmutableStack (e.g.,Bobâ€™svari-
ant). Thus, we recorded the feature trace Â¬ImmutableStack for
the statement removed by Alice although it is not present in her
variantanymore.Wedosobystoringthehistoryofeditssuchthat
we can recall where and when artefacts got deleted. The feature
trace is then synchronised to Bobâ€™s variant in which the statement
shouldstillbepresent(purplecolourin Fig.3).Thesameapplies
forthereturntype voidthatwasupdatedbyAliceinhervariant.
Notably, the recorded trace Â¬ImmutableStack is different from Al-
iceâ€™sfeature context ImmutableStack as Aliceâ€™sedit indicatedthat
the deletedartefact does not belong to the editedfeature.void pop() {
storage[head--] = null;
}
Propagate applicable 
changes made in Fig. 1
voidpop() {
if (!empty()) {
storage[head--] = null;
}
}
Figure 3: Propagating Al-
iceâ€™s edits (see Fig. 1) to
Bobâ€™s variant.1#ifdef ImmutableStack
2Stack<T>
3#else
4void
5#endif
6pop() {
7#ifdef ImmutableStack
8Stack<T> c = clone();
9#endif
10#ifdef SafeStack
11 if (!empty()) {
12#endif
13#ifdef ImmutableStack
14 c.storage[c.head--]=null;
15#else
16 storage[head--]=null;
17#endif
18#ifdef SafeStack
19 }
20#endif
21#ifdef ImmutableStack
22 return c;
23#endif
24}
Figure 4: The variants of
Alice and Bob migrated to
an integrated codebase.
2.3 Scenario2: Migratingto aProductLine
Formigratingasetofclonedsystemvariantsintoasoftwareproduct
line, feature traces are essential to extract corresponding source
codeto,forexample,modulesinaframeworkoranintegratedcode
base. However, recovering feature traces in a post-mortem fashion
(1)requirestohaltdevelopmentforanunknowndurationand(2)is
error-pronebecauseknowledgeonfeaturesisusuallywidespread
across developers or even lost [ 7,24,45,51,84,85,93]. We argue
that feature trace recording could help in (2) increasing migration
accuracy as feature traces were recorded when developerâ€™s had the
necessary knowledge, and (1) reduce migration time as less feature
traces mighthave to be recovered.
Fig.4showsthe popmethodaftermigratingthevariantsofAlice
andBobtoapreprocessor-basedsoftwareproductline.Allvariants
are unified in a single code base where feature traces are specified
internally (i.e., inside the source code) via #ifdef-directives. Thus,
weomitcoloursasweusecolourstorepresentfeaturetracesthat
are stored externally (i.e., in a separate document). As shown in
Fig.1,Alicerecordedtraceabilityinformationforalmostallcode
elements of popby step (6). Hence, little effort is required to reach
full traceability as only the feature of the definition of popitself
remainsunknown(black colourin Fig.1and3).Forthisexample,
we assign trueto the definition of pop, meaning it is included in
all variants and thus not surrounded by preprocessor directives in
Fig.4.AliceandBobcanretrievetheirvariantsfrom Fig.4using
theirrespective configurationsfrom Fig. 2.
2.4 OurContribution
In this paper, we focus on Aliceâ€™s part of the example (see Sec. 2.1):
formallyintroducingthemethodologyoffeaturetracerecording
and evaluating its applicability. The described scenarios of enhanc-
ingclone-and-ownandmigrationstoproductlinesservetoillus-
trate potential benefits of recorded feature traces. We leave a more
detailed investigation of the scenarios to future work for which
feature traces are an essentialprerequisite.
1009ESEC/FSE â€™21, August 23Å›28, 2021,Athens,Greece P. M. Bittner, A.SchultheiÃŸ, T. ThÃ¼m,T. Kehrer, J. M. Young, L.Linsbauer
3 FEATURETRACEREPRESENTATION
While most stakeholders are usually interested in feature traces
(i.e., knowing which artefacts implement a given feature), from
a technical point of view, it is more natural to consider feature
mappings(i.e.,whichfeaturesareimplementedbyagivenartefact).
Aswewilllaterexplaininmoredetail,featuretracescanbeinferred
from feature mappings, andvice versa.
We do not store feature mappings by annotating source code
directly with preprocessor macros (or similar annotations [ 35,94])
for two reasons. First, preprocessor macros are known to be error-
prone as they obfuscate source code, thus reducing readability
and maintainability [ 37,38,52,54,63,64,91] as emphasized in
Fig. 4. Second, we aimto maintain developersâ€™ existing workflows
inwhichfeaturetracesmaynothavebeendocumentedatallyet.
Tothisend,westorefeaturemappingsexternally(i.e.,inaseparate
file)andvisualisethembycolouringsourcecodeasshowninour
motivatingexample in Fig. 1.
3.1 Minimizing SyntaxErrors
In general, removing artefacts that implement the same feature
should not invalidate the program, but should instead create a new
variant. We refer to program invalidation in terms of violating
a programming languageâ€™s grammar as syntax errors [37]. Line-
based feature traces, such as preprocessor macros, are unaware
oftheunderlyinglanguage.Itisthedeveloperâ€™sresponsibilityto
ensure that no syntax errors occur when deriving variants. For
instance, in Fig. 4, the closing bracket in Line 19has to be mapped
to the same feature ( SafeStack ) as the opening bracket in Line
11.Featuretracesthatdonotcausesyntaxerrorsuponremoving
associatedimplementationartefactsarereferredtoas disciplined
annotations [39].
We transfer the product-line concept of disciplined annotations
by KÃ¤stner et al. [ 37Å›39] to variant-oriented development, such as
clone-and-own,bymappingfeaturestonodesofanAbstractSyntax
Tree(AST)insteadofsourcecodelines. ASTsdescribethesyntactic
structureofanimplementationartefactandareconstructedfrom
the grammar of the artefactâ€™s language by abstracting from con-
cretesyntax[ 2].Inotherwords,an ASTrepresentsthestructural
elementsofthecorrespondingprogram1.Fig.5showsthe ASTof
version(3) ofthe popmethodinour motivatingexample in Fig. 1.
Whenfeaturesaremappedto ASTnodes,developersdonothave
totakecareofsyntacticelementssuchascommasorbrackets.In
Fig.5,threenodesareassignedtothefeature SafeStack ,indicated
by the solid blue colour; we describe the shapes and colours in
detailbelow.Tominimisepotentialsyntaxerrorswhenremovinga
featureâ€™snodes,weadheretothefollowingtworulesintroduced
byKÃ¤stneretal.[ 39]:
Optional-OnlyRule: Onlyoptionalnodesmaybeassignedtofea-
tures[38].Forinstance,entiremethodscanbesafelyremovedfrom
theAST.Incontrast,the Statements nodebelowthe MethodDef
shownin Fig.5ismandatory asremovingitwouldinvalidatethe
method.Though,mandatorynodescanstillberemovedwhenthey
arepartofanoptionalsubtree(e.g.removingtheentire MethodDef
1Ifnogrammarisavailable(e.g.,forareadmefile),asafallbacksolution,linebreaks
canbeused to separateelements(i.e., lines of text).MethodDef
pop
Type
voidStatements
Condition
Expression
UnaryOp
!
Expression
FuncCall
empty
ArgsStatements
ExprStatement
Expression
Assignment
=
VarRef
storage[head--]Expression
Literal
nullParametersDef
optional node mandatory node wrapper
mapped to
SafeStackinheritsSafeStack
in presence condi-
tion
Figure 5:ASTofversion(3) ofthe popmethod from Fig.1.
subtreefromitsclass).An ASTâ€™srootisalwaysoptionalasentire
files, classes, or modules can always be removed. In Fig. 5, optional
nodeshavesolidbordersandmandatorynodeshavedottedborders.
All mandatory nodes are uncoloured or hatched as they are not
mapped to any feature. Though, exceptions for some mandatory
nodes are useful [ 38,39]. For instance, we consider the return type
of a method as optional as it can be implemented differently across
variants (as inour motivatingexample in Sec. 2).
Subtree Rule: ASTs directly unveil membership relations. For in-
stance,statementsthatformtheimplementationofthe popmethod
canbefoundinthesubtreeof popâ€™s nodein Fig.5. Asthese state-
mentscannotexistwithoutthesurroundingmethod,theyshould
onlybe presentwhenthe method isalsopresent. Thus,wepropa-
gateanodeâ€™sfeaturemappingtoallitsdescendants(i.e.,allnodesin
itssubtree).Anexceptiontothisruleare wrappers [39](dashedbor-
dersinFig.5):Constructssuchasconditions,loops,orthe UnaryOp
inFig. 5that wrap nodes of the same type as the wrapperâ€™s parent
canberemovedsafelywithoutremovingtheirwrappedcontent.For
instance, removing the conditiontogether with its expression sub-
tree(leftsubtreein Fig.5)butwithoutitswrappedstatements(right
subtree)yieldsavalid AST again. Wrappers are alwaysoptional.
Formally,wewrite ğ‘£âˆˆğ‘‡ifanodeğ‘£isfoundinan ASTğ‘‡.Nodes
canpotentiallybepartofmultiple ASTs,forinstancetheoldand
newversionofan ASTbeforeandafterachangebythedeveloper.2
In the next section, we describe how features are assigned to AST
nodes andhowwe implement the optional-only andsubtree rule.
3.2 Encoding Missing Knowledge
With feature trace recording, we support ongoing development of
unmanaged clone-and-own projects in which artefacts may not
be associated to features at all. For instance, Alice did not know
the feature of the statement she moved, and feature knowledge on
2We employ differencing [ 17,27,30,31,75] or structural editing [ 65,73,80,97] to
determine if anodecanbefoundin the newand old version of anAST (cf. Sec. 4.1).
1010Feature Trace Recording ESEC/FSE â€™21, August 23Å›28, 2021,Athens,Greece
thepopmethod and its return type was initially missing. Thus, the
corresponding AST nodes are uncolouredin Fig. 5.
Formally, we introduce the propositional atomic value null. We
treatnullastheneutralelementinnegationsandconjunctions(i.e.,
Â¬nullâ‰¡nullandğœ‘âˆ§nullâ‰¡ğœ‘for any propositional formula ğœ‘),
yielding the ternary logic by SobociÅ„ski [ 81, p.70][90]. We refer to
a propositional formula whose literals may have nullas a possible
valueasnullablepropositionalformula .Assoftwareartefactsmaybe
associatedtosinglefeatures,featureinteractions,orevennegations
of features [ 8,53,59], we allow assigning nullable propositional
formulas over features to AST nodes:
Definition3.1. Afeaturemappingisafunction Fthatmapseach
optionalASTnode to a nullable propositional formula over the set
offeatures.
Thisdefinitionoffeaturemappingsrespectstheoptional-only
rule (cf.Sec. 3.1) as we only assign a formula to optional nodes.
Alsonotethat,froman ASTwithacorrespondingfeaturemapping,
one can acquire feature traces stating which artefacts implement a
given feature ğ‘“by grouping all nodes ğ‘£whereğ‘“|=F(ğ‘£)(we write
ğ´|=ğµif andonly if ğ´â‡’ğµisatautology).
To account for the subtree rule, we introduce the presence condi-
tion.Givenafeaturemapping F,thepresencecondition PC(ğ‘‡,F,ğ‘£)
of a node ğ‘£âˆˆğ‘‡is a nullable propositional formula which states
whenğ‘£must be present, depending on its own mapping and its
embedding into ğ‘‡:
PC(ğ‘‡,F,ğ‘£)â‰”ï£±ï£´ï£´ ï£²
ï£´ï£´ï£³F(ğ‘£)âˆ§/logicalandtext.1
ğ‘âˆˆAğ‘‡(ğ‘£)F(ğ‘), ğ‘£isoptional ,
PC(ğ‘‡,F,pğ‘‡(ğ‘£)),else.(1)
wherepğ‘‡(ğ‘£)istheparentnodeof ğ‘£inğ‘‡andAğ‘‡(ğ‘£)denotestheset
ofalloptional non-wrapper ancestors of ğ‘£inğ‘‡. The presence con-
dition of an optional node is a conjunction of its own feature map-
pingF(ğ‘£)and the mappings of all its surrounding constructs (e.g.,
methods and classes). As mandatory nodes are not assigned to any
feature and belong to their parentâ€™s definition, they have the same
presence condition as their parent (the else case). In Fig. 5, solid
and hatched blue nodes have the presence condition SafeStack . If
a nodeğ‘£âˆˆğ‘‡is unmapped(i.e.,F(ğ‘£)=null), it neitherinvalidates
norcontributestoitspresenceconditionas nullisneutralincon-
junctions. For the same reason, a node mapped to nullalso does
notinfluencethepresenceconditionsofitsdescendants.Differenti-
atingbetweenfeaturemappingandpresenceconditionseparates
two concerns: (1) assigning features to individual artefacts ( AST
nodes)and(2)respectinganartefactâ€™sstructure( AST)toemploy
disciplinedannotations.Thisallowsustoonlylookat(1)feature
mappings duringrecordinginthe nextsection while(2)presence
conditions willensure discipline automatically.
Insummary,werepresentfeaturetracesasassignmentsofnul-
lable propositional formulas to ASTnodes (formally referred to as
feature mappings) to account for missing knowledge on feature
traces. With ASTs, we can minimize syntax errors when remov-
ingartefactsofacertainfeaturebyimplementingdisciplinedan-
notations [ 39] through the presence condition. We store feature
mappingsexternallytosupportexistingworkflowsinwhichfea-
tureswereprobablynotdocumentedbydevelopersyetandtoavoid
shortcomingsofpreprocessorannotations.4 FEATURETRACERECORDING
Equippedwithaformalspecificationforfeaturetracesandartefacts,
we now turn to theirevolution by recordingfeature traces during
development. We first formalise our notions of edits and feature
context in Sec. 4.1, and present our recording algorithm in Sec. 4.2.
4.1 EditingofDevelopmentArtefacts
The goal of feature trace recording is to enable developers to docu-
ment their domain knowledge during development. In accordance
with our AST-based representation of feature traces, we handle
softwareevolutiononthelevelof ASTs.Specifically,wedescribe
changes onASTs as functionsto whichwe refer as edits:
Definition 4.1. An editğ‘’is a function, transforming an ASTğ‘‡to
anotherAST ğ‘‡â€²=ğ‘’(ğ‘‡).
Therearemanytypesofedits[ 9,14,17,27,30,31,34,70,71,75],
whereinsertionanddeletioncanbeconsideredprimitivesasthey
can modelany change by deletingeverything and inserting a new
version.However,suchanapproachisinfeasibleasexistingfeature
mappingsmaybelostupondeletion.Hence,wealsoconsider up-
datesandmoves,whereupdateschangepropertiesofnodes,such
as names, andmoves relocate subtrees [ 14,17,27,30,31,75].
Asintroducedinourmotivatingexamplein Sec.2.1,weassociate
eacheditwithafeaturecontext:anullablepropositionalformula
describing on which feature or feature interaction the developer is
currentlyworking.Thefeaturecontextcanbe nullasdevelopers
might sometimes not know to which feature an edited artefact
belongs, such as Alice inher secondeditin Fig. 1.
We restrict the feature context to formulas that are satisfiable
in the current variant. This means, the feature context must be
eithernullorsatisfiablegiventhecurrentvariantâ€™sconfiguration
(cf.Sec.2.2).Thus,whendevelopersspecifythefeaturecontext,we
ensure that they can only edit features comprised by their variant.
Detecting edits is possible through differencing [ 17,27,30,31,
42,43,75] where a list of edits is derived from the old and new
version of an AST(e.g., on commit to version control or document
save).Instructuralediting[ 65,73,80,97],usedfordomain-specific
or graphical programming languages, user interactions with the
IDE yield a list of edits directly. Given such a list of edits, we apply
our algorithm sequentiallyto eacheditseparately.
Inspecting ASTsduringdevelopmentisacommonmechanism
forstaticanalysisandcodehighlightinginmodernIDEs,evenon
syntacticallyinvalidstates.Thus,wedonotexpectscalabilityissues
whenextendinganIDEwithfeaturetracerecordingbecausewecan
reusethe ASTsprovidedbytheIDEduringruntime.Whenadopting
feature trace recording outside of an IDE (e.g., upon commit to
version control), every changed file has to be parsed exactly once.
4.2 FeatureTraceRecording Algorithm
Feature trace recording is defined in Alg. 1. It takes an edit ğ‘’made
to anASTğ‘‡ğ‘œğ‘™ğ‘‘under feature context ğœ‘, and the existing feature
mappingFğ‘œğ‘™ğ‘‘. Itcomputes thefeature mapping Fğ‘›ğ‘’ğ‘¤for the new
versionofthe AST ğ‘‡ğ‘›ğ‘’ğ‘¤=ğ‘’(ğ‘‡ğ‘œğ‘™ğ‘‘).
Featuretracerecordingisdesignedasaframework:Foreachtype
of editğ‘¡, it provides a dedicated recording function Rğ‘¡handling
edits of that type. Each Rğ‘¡is a function that takes the old AST
1011ESEC/FSE â€™21, August 23Å›28, 2021,Athens,Greece P. M. Bittner, A.SchultheiÃŸ, T. ThÃ¼m,T. Kehrer, J. M. Young, L.Linsbauer
Algorithm1 Feature TraceRecording
Input:editğ‘’,feature context ğœ‘,ASTğ‘‡ğ‘œğ‘™ğ‘‘,feature mappingFğ‘œğ‘™ğ‘‘
Output:newfeature mapping Fğ‘›ğ‘’ğ‘¤
1:ğ‘¡â†type ofğ‘’âˆˆ{ins,del,mov,up}
2:âˆ†â†AST nodes involvedin ğ‘’
3:Fğ‘›ğ‘’ğ‘¤â†Rğ‘¡(ğ‘‡ğ‘œğ‘™ğ‘‘,âˆ†,Fğ‘œğ‘™ğ‘‘,ğœ‘) âŠ²recordnewmapping
4:returnFğ‘›ğ‘’ğ‘¤
Table 1: Recorded feature mapping Fğ‘›ğ‘’ğ‘¤(ğ‘£)for edited AST
nodesğ‘£âˆˆâˆ†depending on the feature context ğœ‘and the old
feature mapping Fğ‘œğ‘™ğ‘‘(ğ‘£).
ğœ‘Fğ‘œğ‘™ğ‘‘(ğ‘£)Rins Rdel Rmov Rup
defined defined -PC(ğ‘‡ğ‘œğ‘™ğ‘‘,Fğ‘œğ‘™ğ‘‘,ğ‘£)âˆ§Â¬ğœ‘Fğ‘œğ‘™ğ‘‘(ğ‘£)âˆ§ğœ‘ ğœ‘
defined null ğœ‘Â¬ğœ‘ ğœ‘ ğœ‘
nulldefined - falseFğ‘œğ‘™ğ‘‘(ğ‘£) Fğ‘œğ‘™ğ‘‘(ğ‘£)
null null null null null null
ğ‘‡ğ‘œğ‘™ğ‘‘,thesetâˆ†ofedited ASTnodes,theoldfeaturemapping Fğ‘œğ‘™ğ‘‘,
and the feature context ğœ‘to derive the next feature mapping Fğ‘›ğ‘’ğ‘¤
forğ‘‡ğ‘›ğ‘’ğ‘¤. Here, the edit ğ‘’itself does not need to be considered in
detailaswehandleitstype ğ‘¡bychoosingaspecialisedrecording
function Rğ‘¡and collecting the involvednodesinthe set âˆ†. The set
âˆ†comprisesallinserted,removed,orupdatednodes,dependingon
theeditbeinganinsertion, deletion,orupdate, respectively. Ifthe
editisamove, âˆ†isthe setofallnodes inthe movedsubtree.
Asaframework,featuretracerecordingcanbetailoredtospe-
cific needs by providing custom implementations for the recording
functions Rğ‘¡.Inthispaper,weintroducerecordingfunctionsfor
insertion,deletion,move,andupdate(i.e., ğ‘¡âˆˆ{ins,del,mov,up}),
butthegeneralframeworkisopentobeextendedbyfunctionsthat
handle domain-specific editoperations (e.g.,refactorings).
Table1providesanoverviewofthemapping Fğ‘›ğ‘’ğ‘¤(ğ‘£)produced
by eachof our recordingfunctions Rğ‘¡for edited nodes ğ‘£âˆˆâˆ†.We
discuss the construction of each recording function Rğ‘¡in detail in
the following section.
4.3 Recording FeatureTracesforSpecific Edits
In the following, we describe our implementation of the recording
functions Rğ‘¡forinsertion,deletion,moves,andupdates.According
toAlg.1,wedeterminefeaturemappingsforalleditednodes ğ‘£âˆˆâˆ†
from the previous mapping Fğ‘œğ‘™ğ‘‘in the old ASTğ‘‡ğ‘œğ‘™ğ‘‘and feature
contextğœ‘,andkeepmappings ofunchangednodes ğ‘£âˆ‰âˆ†.
Insertions .Wedefinetherecordingfunction Rinsthatisused
uponinsertionsas follows:
Rins(ğ‘‡ğ‘œğ‘™ğ‘‘,âˆ†,Fğ‘œğ‘™ğ‘‘,ğœ‘)(ğ‘£)â‰”/braceleftBigg
ğœ‘, ğ‘£âˆˆâˆ†,
Fğ‘œğ‘™ğ‘‘(ğ‘£),else.(2)
As inserted ASTnodesğ‘£âˆˆâˆ†are new to the code base, they do not
haveafeaturemappingyet(i.e., Fğ‘œğ‘™ğ‘‘isundefinedforthem).The
featurecontext ğœ‘describesexactlythefeatureorfeatureinterac-
tiondevelopersarecurrentlyediting.Thus,weconsiderinserted
nodes being addedto that feature formula and assign ğœ‘to them.
If developers do not specify a feature context, we do not know
to which feature formula inserted nodes belong and thus assign
null. Feature mappings of existing nodes ğ‘£âˆ‰âˆ†remain unchanged
because they are not affectedbyinsertionsofothernodes.Deletions .Deletions of artefacts ğ‘£âˆˆâˆ†should be propagated
to exactly those variants that should not contain ğ‘£anymore, as
illustratedin Sec.2.2.Thus,themajortaskfor Rdelistodifferentiate
between total deletions (removing an artefact from all variants)
andpartialdeletions(removinganartefactinaparticularfeature
interaction). We assign feature mappings to deleted artefacts for
the sake of change synchronisation and to introduce the mappings
to variants in which the artefacts are not deleted. We do so by
storing the edit history to remember where and when artefacts
weredeleted,aspointedoutin Sec.2.2.Fortheremainderofthis
paper, we abbreviate the presence condition PC(ğ‘‡ğ‘œğ‘™ğ‘‘,Fğ‘œğ‘™ğ‘‘,ğ‘£)of a
nodeğ‘£inthe old versionof the AST with ğ‘ğ‘ğ‘œğ‘™ğ‘‘.
Rdel(ğ‘‡ğ‘œğ‘™ğ‘‘,âˆ†,Fğ‘œğ‘™ğ‘‘,ğœ‘)(ğ‘£)â‰”
ï£±ï£´ï£´ï£´ï£´ï£´ ï£²
ï£´ï£´ï£´ï£´ï£´ï£³ğ‘ğ‘ğ‘œğ‘™ğ‘‘âˆ§Â¬ğœ‘, ğ‘£âˆˆâˆ†,ğœ‘â‰ null,
false, ğ‘£âˆˆâˆ†,ğœ‘=null,ğ‘ğ‘ğ‘œğ‘™ğ‘‘â‰ null,
null, ğ‘£âˆˆâˆ†,ğœ‘=null,ğ‘ğ‘ğ‘œğ‘™ğ‘‘=null,
Fğ‘œğ‘™ğ‘‘(ğ‘£), ğ‘£âˆ‰âˆ†.(3)
We cover each case from top to bottom in a separate paragraph,
except forthe lastcase ğ‘£âˆ‰âˆ†which statesthat mappingsof nodes
being unaffectedbythe editremainunchanged.
When developers delete a node ğ‘£under a feature context ğœ‘â‰ 
null,ğ‘£does not belong to that feature formula anymore. However,
ğ‘£may still be a valid implementation in those variants not im-
plementingthecontext ğœ‘butğ‘£â€™scurrentfeatureformula ğ‘ğ‘ğ‘œğ‘™ğ‘‘as
is shown in our motivating example in Fig. 1: Alice removed the
statement storage[head--] = null fromhervarianttoreplace
it with an implementation for ImmutableStack , but the statement
wasstillavalidimplementationinthosevariantsnotimplementing
ImmutableStack such as Bobâ€™s variant. Thus, deleting a node ğ‘£
under context ğœ‘introduces a feature interaction. We can refine
itsmappingbyconjunction with Â¬ğœ‘andtherebyremove ğ‘£from
exactly those variants containing the interaction ğ‘ğ‘ğ‘œğ‘™ğ‘‘âˆ§ğœ‘. We
reason on the presence condition ğ‘ğ‘ğ‘œğ‘™ğ‘‘of a deleted node ğ‘£here
instead of just its mapping Fğ‘œğ‘™ğ‘‘(ğ‘£)because when removing ğ‘£from
theAST,weloseinformationonpreviousancestors.Thus,wehave
to inline the presence condition here to remember existing depen-
dencies. In case ğ‘£does not have a presence condition, we assign
nullâˆ§Â¬ğœ‘â‰¡Â¬ğœ‘toğ‘£asweonlyknowthat ğ‘£shouldnotbepresent
invariants implementing ğœ‘anymore.
Ifthedeveloperdoesnotgiveinformationonwhichfeatureis
currentlyeditedexplicitly(i.e., ğœ‘=null)butthedeletednode ğ‘£âˆˆâˆ†
has a presence condition ğ‘ğ‘ğ‘œğ‘™ğ‘‘â‰ null, we know that ğ‘£was a valid
implementation in at least those variants whose configurations sat-
isfyğ‘ğ‘ğ‘œğ‘™ğ‘‘.Wethusaimtoremove ğ‘£fromallvariantsimplementing
ğ‘ğ‘ğ‘œğ‘™ğ‘‘andcouldassignÂ¬ğ‘ğ‘ğ‘œğ‘™ğ‘‘toğ‘£.However,thiswouldmeanthat
ğ‘£should be present even in those variants satisfying Â¬ğ‘ğ‘ğ‘œğ‘™ğ‘‘which
did not contain ğ‘£before the deletion and should not do so after-
wards. Thus, there is no variant at all that should contain ğ‘£after
thedeletion.Wemakethisexplicitbyassigning falsetoğ‘£asfalse
is unsatisfiableinallvariants.Infact,asimilar situationmayalso
occurinthefirstcaseof Rdel,whenthefeaturecontext ğœ‘isdefined
and equal to the deleted artefactâ€™s presence condition ğ‘ğ‘ğ‘œğ‘™ğ‘‘. In this
case,ğ‘£hastoberemovedfromallvariantsbecauseitshouldnotbe
presentinthosevariantsimplementing ğ‘ğ‘ğ‘œğ‘™ğ‘‘butshouldalsonot
1012Feature Trace Recording ESEC/FSE â€™21, August 23Å›28, 2021,Athens,Greece
beinsertedtothosevariantsnotimplementing ğ‘ğ‘ğ‘œğ‘™ğ‘‘.Thisisindeed
thecasebecause ğ‘ğ‘ğ‘œğ‘™ğ‘‘âˆ§Â¬ğœ‘â‰¡ğœ‘âˆ§Â¬ğœ‘â‰¡falsewhenğœ‘â‰¡ğ‘ğ‘ğ‘œğ‘™ğ‘‘and
ğœ‘â‰ null.Asbefore,assigning falsetoğ‘£isimportantbecausejust
Â¬ğœ‘wouldmeanthat ğ‘£shouldbecontainedinthosevariantsthat
didnot contain ğ‘£before the deletion.
When neither a feature context is given nor the deleted node
ğ‘£âˆˆâˆ†ismapped(i.e.,itâ€™spresenceconditionis null),weonlyknow
that it cannot be present in the current variant. As this does not
give insight on which variants should contain ğ‘£, we make this
uncertainty explicit byassigning nullto deletedartefacts.
Moves.The advantage of considering moves explicitly is the
opportunity to keep existing mappings of moved nodes that would
be lost when expressing moves interms ofdeletion andinsertion:
Rmov(ğ‘‡ğ‘œğ‘™ğ‘‘,âˆ†,Fğ‘œğ‘™ğ‘‘,ğœ‘)(ğ‘£)â‰”/braceleftBigg
Fğ‘œğ‘™ğ‘‘(ğ‘£)âˆ§ğœ‘, ğ‘£âˆˆâˆ†,
Fğ‘œğ‘™ğ‘‘(ğ‘£),else.(4)
Movingan artefactmeansextractingitfrom oneplacetolocate it
somewhereelse,forinstance,movingamethodfromoneclassto
another. This means, the method does not belong to its previous
class but to the new one. However,the method may be assigned a
feature formula and also its statements may or may not implement
severalfeatures.Thus,wedecidetokeepthemappingsofmoved
artefacts (e.g., the method and its statements) but not the entire
presence condition as developers decided to extract the artefacts
from its surroundings (e.g., the class). Instead, presence conditions
of moved artefacts adjustautomatically according to surrounding
constructs (i.e., previous and new ancestors in the AST). When
developersindicatethecurrentlyeditedfeatureformulainterms
of thefeature context ğœ‘, weknowthemove affectsthat feature or
featurecombination ğœ‘.Hence,weintroduceafeatureinteraction
Fğ‘œğ‘™ğ‘‘(ğ‘£)âˆ§ğœ‘. When developers do not specify a feature context
(i.e.,ğœ‘=null), we keep the existing mapping without extending
it becauseFğ‘œğ‘™ğ‘‘(ğ‘£)âˆ§ğœ‘â‰¡Fğ‘œğ‘™ğ‘‘(ğ‘£)âˆ§nullâ‰¡Fğ‘œğ‘™ğ‘‘(ğ‘£). This is what
happenedwhenAlicemovedastatementinourmotivatingexample
inSec. 2.1withoutknowing whichfeature sheisediting.
Updates.Asformoves,consideringupdatesexplicitlyallowsto
keepexistingfeaturemappingsthatwouldbelostwhenexpressing
updatesjustinterms ofinsertionsanddeletions:
Rup(ğ‘‡ğ‘œğ‘™ğ‘‘,âˆ†,Fğ‘œğ‘™ğ‘‘,ğœ‘)(ğ‘£)â‰”/braceleftBigg
ğœ‘, ğœ‘ â‰ null,ğ‘£âˆˆâˆ†,
Fğ‘œğ‘™ğ‘‘(ğ‘£),else.(5)
When a node ğ‘£âˆˆâˆ†is updated, we have to ensure that this update
affects all variants implementing the currently edited feature ğœ‘. In
contrast to moves, updates change the artefacts themselves and
thus can be seen as more functional changes to the source code
(e.g., when a function call is renamed and could point to a different
function afterwards). Thus, we replace existing mappings of up-
dated nodes ğ‘£âˆˆâˆ†if a feature context is given. For instance, in our
motivating example in Sec. 2.1, Alice changed the return type of
thepopmethodforthefeature ImmutableStack .Themappingof
thereturntypeshouldbe ImmutableStack aftertheupdateeven
if it would have been mapped to another feature previously. When
no feature context is specified, we keep existing mappings as there
is no evidence by the developer that the edited feature is not the
feature ofthe updatedartefact itself.Summary .WithAlg. 1, feature traces can be recorded upon
editstothesoftwarefromthedeveloperâ€™sfeaturecontext.When
performingmultipleeditsonthesamefeature,thecontextcanbe
keptanddoes nothavetobeswitchedasshownin Fig.1.Feature
tracerecordingcanbeemployedonpreviouslyunmanagedcodeto
gradually record knowledge on the code base as we explicitly deal
withabsent knowledge (cf. Sec. 3).
5 EVALUATION
By recording feature traces upon source code edits, developers
can be released from three key challenges of documenting feature
traces for multi-variant software systems:(1) Taking care ofdisci-
plined feature mappings, (2) dealing with the absence of domain
knowledge, and(3) tracingartefacts thatare deleted inthe course
ofevolution.Thesearequalitativeachievementsovertraditional
source code annotations which are (1) known to be error-prone
(seeSec.3),(2)enforceanimmediatedecisiononfeaturemappings,
and(3) cannothandle the annotation of deletedartefacts.
Furthermore,weevaluatetheapplicabilityoffeaturetracerecord-
ing by investigatingwhether itenables developers to edit variable
softwaresystems(RQ1).Recordingshouldimposealowburdenfor
developers (RQ2+3) and ideally be easier than specifying feature
traces manually (RQ3).
RQ1Doesfeaturetracerecordingsupportcodechangesthatare
common when developingvariable software?
RQ2Howoften mustthe feature contextbe switched?
RQ3How complex is the feature context in comparison to the
desiredfeature trace formula?
5.1 StudyDesign
Ideally,featuretracerecordingwouldbeevaluatedbyanalysinga
real-world history of editswith feature contexts. As we introduce
thenotionofafeaturecontextinthispaper,therearenoexisting
datasetswecoulduseforthesakeofevaluationdirectly.Further-
more, feature traces are usually missing in existing clone-and-own
projectsorareimprecisewhenrecoveredretroactively[ 35](e.g.,on
migrationsasin Sec.2.2).Thisimpedesverifyingthecorrectness
of recorded traces as we are missing a ground truth to compare
our results with. To the best of our knowledge, exact and complete
feature traces can only be foundinsoftware product lines.
We thus inspect real-world edits to software product lines, as
feature traces are known beforeandafteredits. This lets us un-
derstandhow featuretraces havetochangewhen developersedit
sourcecode.Tothisend,weanalyseifandhowanedittoasoftware
productlinecanbeturnedintoaneditonvariantswhenemploying
feature trace recording (e.g., in clone-and-own). In terms of our
motivating example, this means to inspect if Alice and Bob can
reproducepossibleeditstotheunified popmethodin Fig.4when
they instead develop their respective variants with feature trace
recording.
Therefore,wereusetheclassificationofeditstosoftwareproduct
lines by StÄƒnciulescu et al. [ 92]. They derived a set of edit patterns ,
that classify all edits in the history of the product line Marlin3
and 99.27% of the edits in the product line Busybox4. Each pattern
3up to commit 3cfe1dce1 inhttps://github.com/MarlinFirmware/Marlin
4up to commit a83e3ae inhttps://git.busybox.net/busybox
1013ESEC/FSE â€™21, August 23Å›28, 2021,Athens,Greece P. M. Bittner, A.SchultheiÃŸ, T. ThÃ¼m,T. Kehrer, J. M. Young, L.Linsbauer
describes a possible kindof edit to software artefacts and their
feature mappings at a fine granularity (i.e., not on the level of
commitsbutedits).Infact,acommitmayconsistofseveralpattern
applications [ 92]. In our study, we analyse each edit pattern to
seeiffeaturetracerecordingiscapableofreproducingrespective
changes to feature traces andwhichfeature contextisnecessary.
5.2 ReproducingEditsto SoftwareProduct
Linesin Clone-and-Own
In this section, we examine if and how edits to software product
lines can be turned into edits when developing variants directly
with feature trace recording (e.g., in clone-and-own). Table 2gives
an overview of the examined edit patterns. As feature trace record-
ingworksoncodechanges,weomitallpatternsdescribingchanges
tofeaturetracesonly.Changingtracesexplicitlythatwayisorthog-
onaltoourrecordingandcanbeprovidedbyIDEtools.Foreach
pattern, the number of matched edits in Marlinâ€™s commit history is
given in the #editscolumn (computed by summing the #Multi and
#Only columns in the original paper [ 92, p. 327 ff.]). We give the
ratioofeditsforeachpatterninthe ratiocolumn.Featuremapping
formulasthataretobeinferredbyapatternaredenotedbyapropo-
sitionalformula ğ‘š.Weusethistargetfeaturemappingformula ğ‘š
asourbaselinetoanswerRQ2andRQ3becauseexistingtechniques
forproactivefeaturetracingduringdevelopment[ 35,94]require
specifying ğ‘šfor eachartefact manually (cf., Sec. 6).
Each pattern is a possible kind of edit to source code and to the
associated feature mappings. Thus, we depict feature mappings as
preprocessorstatementsasin Fig.4whendisplayingthepatterns.
Thisenablesus toshow ifand howfeaturemappings arealtered
wheneditingcorrespondingsourcecode.Accordingly,preprocessor
statements are notpart of the edited code. Instead, they describe
howfeaturemappingschangeuponaneditwhenturningapattern
to an edit on variants, just as preprocessor statements represent
featuremappingsinthemigrated popmethodin Fig.4butnotin
Alice, andBobâ€™svariants of popinFig. 1andFig. 3.
Conditions could be expressed by any of #ifdef,#ifndef, or
#if,ofwhichwechose #ifinthefollowingasitisthemostgeneral.
For visualising patterns, we adopt the unified diff notation. Added
lines are green and labeled with +. Removed lines are pink and
labeled with -. Lines without colour or marker remain unchanged.
Wealsosimulateeachpatterninourresearchprototype5with
structural editing to see if derived feature contexts are indeed suit-
abletoreproduceapattern.Additionally,ourprototypereproduces
our motivatingexample from Fig. 1.
5.2.1 AddIfdef. Thefirsteditpatterncoverstheinsertionofsource
code withafeature mapping formula ğ‘š:
+#ifğ‘š
+/* inserted code */
+#endif
Ingeneral ,codeisinsertedandmappedto ğ‘š.Wecanreproducethis
patterninanyvariantwhoseconfigurationisasatisfyingassign-
mentforthecondition ğ‘š.Insuchavariant,insertingcodeunder
featurecontext ğœ‘â‰”ğ‘šwouldreproducethispattern.Ouralgorithm
5GitHub:https://github.com/pmbittner/FeatureTraceRecording/tree/esecfse21
DOI:10.5281/zenodo.5109867Table 2:Editpatternswith necessary feature contexts ğœ‘.
patternname #edits ratio target ğœ‘in ğœ‘insiderespectively #variants
in % mapping general mapped scope toedit
AddIfdef 1098 9.0 ğ‘š ğ‘š nullorâª¯ğ‘š 1
AddIfdef*456 3.8 ğ‘š1,...,ğ‘šğ‘›ğ‘šğ‘–1,...,ğ‘šğ‘–ğ‘—âˆ€ğ‘šğ‘–ğ‘˜:nullorâª¯ğ‘šğ‘–ğ‘˜â‰¤ğ‘—
AddIfdefElse 275 2.3 ğ‘š ğ‘š nullorâª¯ğ‘š 2
Â¬ğ‘šÂ¬ğ‘š nullorâª¯Â¬ğ‘š
AddIfdefWrapElse 60 0.5 ğ‘š,Â¬ğ‘šğ‘š Å› 1
AddIfdefWrapThen 16 0.1 ğ‘š,Â¬ğ‘šÂ¬ğ‘š Å› 1
AddNormalCode 5554 45.7 ğ‘š ğ‘š nullorâª¯ğ‘š 1
RemNormalCode 4141 34.1 false trueorâª¯ğ‘ğ‘ğ‘œğ‘™ğ‘‘nullorâª¯ğ‘ğ‘ğ‘œğ‘™ğ‘‘ 1
RemIfdef 558 4.6 false nullorâª¯ğ‘ğ‘ğ‘œğ‘™ğ‘‘nullorâª¯ğ‘ğ‘ğ‘œğ‘™ğ‘‘â‰¤2
where"âª¯ğ‘š"meansğœ‘hastobeequal toor weaker than ğ‘š(i.e.,ğ‘š|=ğœ‘);and 1â‰¤ğ‘—â‰¤ğ‘›
usesRinsandtherebyassigns ğœ‘totheinsertedcodefragment.This
happens in our motivating example in Sec. 2.1, when Alice inserts
code under contexts SafeStack andImmutableStack .Inside an
optionalscopemappedto ğ‘š,(e.g.,aclassormethod)thecodecan
evenbeinsertedwithoutanycontext(i.e., null).Itwillinheritthe
outer scopeâ€™s formula ğ‘šin its presence condition (cf., Eq. 1). Thus,
setting the context ğœ‘tonullor any formula that is more general
thanğ‘š(i.e.,ğ‘š|=ğœ‘) is feasible. For instance, when ğœ‘=ğ‘š,ğœ‘=true,
orğœ‘=ğ‘šâˆ¨...,thepresenceconditionofthecodewillbe ğ‘šâˆ§ğœ‘â‰¡ğ‘š.
5.2.2 AddIfdef*. Thispatterngroups ğ‘›applicationsoftheprevi-
ousAddIfdef with conditions ğ‘š1,...,ğ‘šğ‘›, ğ‘›â‰¥2. As some of the
conditionsmightbeidentical,thefeaturecontexthastobechanged
at mostğ‘›times. Thus, we have to repeat pattern AddIfdef ğ‘—times,
1â‰¤ğ‘—â‰¤ğ‘›, with contexts ğœ‘ğ‘˜â‰”ğ‘šğ‘–ğ‘˜, ğ‘˜âˆˆ{1,..., ğ‘—}, where each
ğ‘–ğ‘˜âˆˆ{1,...,ğ‘›}denotes a unique index, such that each conditionis
considered exactly once. When some conditions contradict each
other(e.g., ğ´andÂ¬ğ´)orwhenthereisnovariantimplementingall
conditions atonce, wehave toadd thoseconditionâ€™scodeto adif-
ferentvariantaswecanonlyaddcodetoavariantifitimplements
thedesiredformula ğœ‘ğ‘˜.Soinworstcase,all ğ‘—contextscontradict
eachotherandthus the number of variants to editislimitedby ğ‘—.
5.2.3 AddIfdefElse. Similarto AddIfdef,codesurroundedbyacon-
dition isinsertedbut togetherwithan #elsebranch:
+#ifğ‘š
+/* inserted code (1) */
+#else
+/* inserted code (2) */
+#endif
The two inserted code fragments are supposed to have the feature
mappingsFğ‘›ğ‘’ğ‘¤(1)=ğ‘šandFğ‘›ğ‘’ğ‘¤(2)=Â¬ğ‘š.We cannotreproduce
thispatterndirectlyinasinglevariantbecausebothfeaturemap-
pingsaremutuallyexclusive(i.e.,contradicting).Eachfragmenthas
tobeaddedinavariantwhoseconfigurationsatisfiestherespective
formula.In general , each code fragment has to be inserted with the
correspondingfeaturecontextsuchthat Rinswillbeusedtoassign
thecontextasmapping,similarto AddIfdef.Notably,thealternative
codefragment(2)hastobeinsertedunder ğœ‘=Â¬ğ‘š.Thisispossible,
as we decided to use propositional formulas for feature context
andmappingsinsteadofsimplerconstructssuchaslistsoffeatures
employed elsewhere [ 29,38].Inside an optional scopemapped to ğ‘š
orÂ¬ğ‘šrespectively ,insertingcodeunderfeaturecontext nullorğœ‘
withğ‘š|=ğœ‘for code (1) andÂ¬ğ‘š|=ğœ‘for code (2) respectively, is
sufficient, justas for AddIfdef.
1014Feature Trace Recording ESEC/FSE â€™21, August 23Å›28, 2021,Athens,Greece
5.2.4 AddIfdefWrapElse. This pattern replaces an existing code
fragment withan implementationfor acertainfeature:
+#ifğ‘š
+/* inserted code (1) */
+#else
/* existing code (2) */
+#endif
In general , reproducing this pattern is possible with just the single
featurecontext ğœ‘=ğ‘štorecordbothmappings.Wehavetoedita
singlevariantthatimplements ğ‘šandisnotsupposedtocontainthe
existingcode(2)anymore.Bydeletingcode(2)itwillbemapped
toÂ¬ğ‘šbyRdel. The new code (1) can then be inserted under the
same feature context to map it to ğ‘šwithRins. This is what Al-
ice did in the motivating example with her third and fourth edit
inFig.1:Shesetsthefeaturecontextto ImmutableStack ,deletes
storage[head--] = null , and replaces it with the immutable
version afterwards. That way, Alice inserts new code mapped to
ImmutableStack after deleting existing code that is recorded as
belongingtoÂ¬ImmutableStack (i.e.,theelsecase).Insideanop-
tional scope mapped to ğ‘š, this pattern would be ill-formed as it
introducesdeadcode,evenintheproductlineitself(e.g.,Marlin):
Theelsecase(2)wouldgetthepresencecondition ğ‘šâˆ§Â¬ğ‘šâ‰¡false.
5.2.5 AddIfdefWrapThen. Reciprocal to AddIfdefWrapElse , this
pattern maps an existing artefact as belonging to a specific fea-
ture whileintroducing the more generalcase:
+#ifğ‘š
/* existing code (1) */
+#else
+/* inserted code (2) */
+#endif
Ingeneral ,thispatterncanbereproducedthesamewayas AddIf-
defWrapElse butwiththeinversefeaturecontext Â¬ğ‘š.In avariant
containingthecode(1)andsatisfying Â¬ğ‘š,deleting(1)willlet Rdel
determineÂ¬ğœ‘â‰¡Â¬Â¬ğ‘šâ‰¡ğ‘šas the new mapping. Subsequently,
code(2)hastobeinsertedunderthesamecontext.Again,froma
singlefeature context,twodifferentfeature mappingsarerecorded.
Insideanoptionalscopemappedto ğ‘š,thispatternisill-formedeven
inaproduct line,justas for AddIfdefWrapElse .
5.2.6 AddNormalCode. This pattern comprises the insertion of
code without any associated feature mapping. The inserted code is
eithernon-variableorissupposedtoexistinsideotherexisting #if
scopes.In general , the new code has to be inserted under feature
contextğœ‘=ğ‘šbeing the target mapping ğ‘š(ğ‘š=truefor non-
variable code) just as for AddIfdef.Inside an optional scope mapped
toğ‘š, the new code can be insertedunder feature context nullor a
formula weaker or equal to ğ‘šjust as for AddIfdef as the code will
inherit the outer scopeâ€™sformula inits presencecondition.
5.2.7 RemNormalCode. Thispatterndepictstheremovalofacode
fragment, regardless ofwhether itismappedto afeature ornot:
#ifğ‘š
-/* removed code */
#endif
As artefacts are removed from the entire software, they have to
disappear from each variant containing them, which means the
code has to be assigned false.In general , any feature context ğœ‘weaker than the deleted codeâ€™s presence condition ğ‘ğ‘ğ‘œğ‘™ğ‘‘|=ğœ‘(e.g.,
ğœ‘=true) is feasible. Rdelwill record ğ‘ğ‘ğ‘œğ‘™ğ‘‘âˆ§Â¬ğœ‘â‰¡falseas both
termscontradicteachother(cf. Eq.3).Ifğ‘ğ‘ğ‘œğ‘™ğ‘‘â‰¡null,thecontext
ğœ‘has to be set to true.Inside an optional scope mapped to ğ‘š, the
feature contextcan even be setto nullasRdelwillassign false.
5.2.8 RemIfdef. This pattern comprises the removal of preproces-
sorblocks.Itcovers annotations withandwithout #elsebranch:
-#ifğ‘š
-/* removed code (1) */
-#else
-/* removed code (2) */
-#endif
As forRemNormalCode , the removed code has to be assigned false
as it is removed from the entire software. As for AddIfdefElse , both
casescontradicteachother,andthustwovariantshavetobeedited.
Asthe artefacts have a presence condition, deletingthem without
any feature context (i.e., null) is sufficient as Rdelwill record false.
Analogousto RemNormalCode ,anycontext ğœ‘withğ‘ğ‘ğ‘œğ‘™ğ‘‘|=ğœ‘works,
asRdelwillrecord ğ‘ğ‘ğ‘œğ‘™ğ‘‘âˆ§Â¬ğœ‘â‰¡falseinthis case.
Summary. We summarise the results of our investigation of the
abovepatternsin Table2.Thepossiblefeaturecontextstoreproduce
each pattern and the number of variants that have to be edited are
given in the respective columns. All patterns can be reproduced.
When a pattern is applied inside a scope mapped to the target
mapping, even nullor multiple formulas are sufficient to record
desired traces.If multiple variants have to be edited,this is dueto
contradictory mappings.
5.3 Discussion
RQ1 Å› Applicability. We showed that feature trace recording can
beappliedsuccessfullytoreproduceallpresentededitpatterns.We
alsoreproduce allpatterns inour prototype (cf. Sec. 5.2).
Feature traces can be recordedfor allconsiderededitpatterns.
RQ2Å›FeatureContextSwitches. Weconsiderhowmanyvariants
havetobeedited,andhowoftenanewfeaturecontexthastobe
setto reproduce eachpattern.
Differentvariantshave tobe editedwhen feature formulascon-
tradict each other or when no variant is compatible to all formulas
atthesametime.Webelieveeditingmultiplevariantsatoncetobe
unlikely for clone-and-own development. Even in Marlin, artefacts
withcontradictingfeaturemappingswereaddedorremovedless
often than editing just a single mapping or variant: Only 2 .3% of
the edits were classified by AddIfdefElse , 4.6% byRemIfdef , and
3.8% byAddIfdef* , where the latter two may contain cases without
conflicting feature mappings.
Forallpatterns,theamountofrequiredfeaturecontextswitches
isequaltoorsmallerthanthenumberofdifferenttargetmappings,
asshown in Table 2.Asingle featurecontextcould alsobereused
whenapplyingseveralpatternsinarowasdonebyAlicein Sec.2.1.
Forreproducing singlepatterns,userinputisrequiredlessor
as frequent as for directly specifying mappings. Feature context
switchesarepotentiallylessfrequentwhenapplyingmultiple
patterns in a row. In at least 89 .3% of the cases only one variant
has to be edited.
1015ESEC/FSE â€™21, August 23Å›28, 2021,Athens,Greece P. M. Bittner, A.SchultheiÃŸ, T. ThÃ¼m,T. Kehrer, J. M. Young, L.Linsbauer
RQ3 Å› FeatureContext Complexity. To answer thisquestion, we
compare the feature contexts with the target feature mappings for
eachpattern, summarisedin Table2.
Allinsertionrelatedpatterns(i.e., Add...),exceptfor AddIfdef-
WrapThen , can be reproduced in our clone-and-own scenario by
settingthefeaturecontexttoexactlythedesiredfeaturemapping
of the artefact to edit. When deleting artefacts, developers can
differentiate whether they want to replace an artefact (cf. AddIfdef-
WrapElse ,AddIfdefWrapThen ) from a certain feature formula, or
want todeleteitfromallvariants(cf., RemIfdef,RemNormalCode ),
by specifying a corresponding feature context. In case of uncer-
tainty, deletinganartefact ğ‘£underafeaturecontext ğœ‘isalwaysa
validoptionbecauseitsrefinedmapping ğ‘ğ‘ğ‘œğ‘™ğ‘‘âˆ§Â¬ğœ‘shrinkstheset
ofvariantscontaining ğ‘£.Thisway,developerscaniterativelydecide
whetherğ‘£hastoberemovedfromfurthervariants(e.g.,variants
they are responsible for) such that ğ‘£may indeed be removed from
every varianteventually.
Forallpatterns,includingthemostcommonones AddNormal-
CodeandRemNormalCode that comprise 79 ,74% of all edits, the
featurecontextmayevenbeomitted.Whenartefactsareinserted
ordeletedinside scopes (e.g.,aclass or method)that already have
the target mapping, nullor several formulas are feasible. Only, the
rare patterns AddIfdefWrapThen andAddIfdefWrapElse (0.62%) are
ill-formedinthiscaseastheyintroducedeadcodewhenperformed
inthe product linealready.
In general, the feature context has to be equal to the target
featuremapping.Fortwopatterns,differentmappingscanbe
recorded with just a single context. For more than 99% of the
edits,nulloravarietyofformulasareafeasiblecontextwhen
an outer scope isalready assignedto the target mapping.
5.4 Threatsto Validity
Internal Validity. A possible bias could be introduced the way
wedeterminedthefeaturecontext.Ifmultiplepossibilitiesforre-
producing a pattern exist, we present the simplest one we could
identifyin termsof numberof editsanddivergence ofthe feature
context from the targeted feature mapping formula. In practice,
developers could choose more complicated contexts but they could
alsodosofor directannotations.
StÄƒnciulescuetal.admitthattheymighthaveintroducedbias
whenidentifyingthepatterns[ 92].Theyiterativelyidentifiedregu-
lar expressions until all edits in the considered history of Marlin
wereclassifiedandcross-validatedtheirresultswiththeproduct-
lineBusybox.
External Validity. The considered evolution might not be rep-
resentative for clone-and-own development. As discussed in our
studydesignin Sec.5.1,softwareproductlinesturnedouttobethe
only feasible datasets for our evaluation because clone-and-own
software suffers from absent or imprecise feature traces. However,
evensoftwareproductlineslackthedirectavailabilityoffeature
contexts. We thus decided against investigating development histo-
riesofexistingprojectsmanually.Instead,wearguethatreverse-
engineeringfeaturecontextsfor possiblechangestoproductlines
isthe besttrade-offfor our evaluation.The considered edit patterns might be incomplete regarding the
evolution of variable software systems. The history of Marlin anal-
ysed by StÄƒnciulescu et al. [ 92] contains 3,747 commits (excluding
merge commits) that lead to ~40k lines of code with more than 140
featuresin187sourcefiles(withoutfilesforArduino)inthelastver-
sionatcommit3cfe1dce1.Furthermore,somepatternswerealready
identifiedinpreviouswork[ 21,35,74]increasingourconfidence
that the mostcommon andessentialpatterns are included.
6 RELATED WORK
Featuretracerecordingisthefirststeptowardsourvisionforbridg-
ingthegapbetweenclone-and-ownandsoftwareproductlines[ 44],
depicted in Sec. 2.2. To this end, we extend early ideas on our Vari-
antSyncframework[ 76]withthefirststructuredandformalmethod
forinferringfeaturetracesfromdevelopersâ€™edits.Preliminaryre-
sults and ideas on feature trace recording were presented in the
firstauthorâ€™smasterâ€™s thesis[ 15].
Featuretracerecording isinspiredbyJietal.[ 35].Inanempirical
study, theyshowed the benefits of recording traces in a line-based
annotative approach known as embedded annotations [6,26,35]
orfeaturetags [33].Ji etal. simulatedthedevelopment ofvariable
software by manually inspecting the commits of the history of a
clone-and-ownproject.Foreachcommit,thefirstauthorembeds
line-based feature traces into the source code via comments "based
on his understanding of the codebase and the change history" [35,
p. 63]. Thus, Ji et al. discovered insights on the effectiveness of
documenting feature traces during development by embedding an-
notations manually. SulÃ­r et al. [ 94] report similar results when
using Javaannotations for manuallydocumenting concerns. Both
studiesrequiredhighmanual effort.Withfeaturetracerecording,
weintroduceastructuredandformalizedmethodologyreducing
thismanualeffort.Heidenreichetal.proposedFeatureMapper[ 32],
a tool for the specification of feature mappings in model-based
softwareproductlines.Whileinrecordingmode,FeatureMapper
assignsapre-definedfeatureexpressiontodeveloperedits.With
featuretracerecording,wedonotplainlyassignthefeaturecontext
toedits and edited artefacts but derive formulasbased on existing
feature mappings. Moreover, FeatureMapper is a pure software
product-linetool,whichdoesnotconsiderindividualvariantsas
necessary tosupport clone-and-own.In contrast,weexplicitlyin-
spect edits for information relevant to other variants (e.g., upon
deletions, moves, andupdates).
Feature location and recovery [22,83], also known as variability
mining, retroactively recovers or recommends [ 1] feature traces
withstatic[ 3,40,102]ordynamicanalyses[ 25,99,101],through
comparingsoftwarevariants[ 58,62,103],miningsoftwarereposito-
ries[4],orbycombiningthesemethods[ 36,67].Withfeaturetrace
recording,weunlocksoftwareevolutionasanewsourceforfeature
location.Onecommonapplicationoffeaturelocationand recovery
is the migration to a software product line [ 28,47,50] as exem-
plified in Sec. 2.3. Feature trace recovery tools require numerous
developer decisions on existing code [ 28,29,40,45,58,62,84,104]
forwhichthenecessarydomainknowledgemaybelost.Fullyau-
tomatic migration techniques [ 29,58,102,104] cannot yet retrieve
featuretracesinsufficientquality[ 45,85].Withfeaturetracerecord-
ing,developerscandocumentfeaturetracesgraduallywhenever
1016Feature Trace Recording ESEC/FSE â€™21, August 23Å›28, 2021,Athens,Greece
they have the necessary knowledge.Thus, potentially less feature
tracesmight have to be recovered when migrating asdiscussed in
Sec. 2.3. To this end, we explicitly deal with the absence of domain
knowledge. Recently, Michelon et al. raised awareness to distin-
guish features and their revisions in feature location tasks [ 68,69].
While not modelled explicitly in this paper, feature trace recording
supportsrecordingfeaturerevisions:Wheneverasequenceofedits
is performed under the same feature context, we can increment
the version of all features that occur in at least one positive literal
inthecontextâ€™sconjunctivenormalform.Moregenerally,feature
trace recording may serve as one of the building blocks for a better
integrationandmanagementofsoftwareevolutioninbothspace
andtime,amajorchallengewhichhasrecentlygainedincreasing
researchinterestacrossdifferentresearchcommunities [ 5,11,95].
Inspired by the product line tool CIDE[38], we employ disci-
plined annotations [37,39] to preserve syntactical correctness of
featuremappings.Experimentsconductedondiscipline[ 54,61,87]
revealthebenefitsforsuchconstraintsinindustrialpractice.Weim-
plemented disciplined annotations in terms of presence conditions
andextendedthemtobeabletohandlemissingdomainknowledge
by using the ternary logic by SobociÅ„ski [ 81, p.70][90]. Classifying
ASTnodes by the underlying grammar as optional, mandatory, or
wrapper nodes (see Sec. 3) wasautomatedbyKÃ¤stneretal.[ 39].
Variation control systems [18,29,55,56,92] and filtered product
lines [88] deal with variability on the level of features but where
softwareproductlinesaredevelopedbyediting(partial)variants.
Variation control systems either simplify development of software
productlines[ 92]orenhanceclone-and-owndevelopment[ 29]and
usuallyimposeatransaction-basedcheckout-change-commitwork-
flow. In contrast, feature trace recording is more general as it does
not require but could be adopted in such a workflow. Thus, vari-
ationcontrolsystemscanintegratefeaturetracerecordingwhen
developersare submitting their changes to a (partial) variant back
totherepository.Inthisregard,wedirectlysolveanissueStÄƒnci-
ulescu et al. stated as future work for their system: "How to handle
the cases when an ambition is weaker than the projection?" [92, p.
331],where ambitionandprojection areuser-specifiedpropositional
formulas.Withthe projection ,userscheckoutapartialvariantof
aproduct line.Whensubmittingchanges to theirsystemâ€™sprojec-
tional editor, the ambition describes which feature formula was
edited. StÄƒnciulescu et al. argue that a weaker ambition could be
desirable when an edit should not only affect the edited projection
(i.e., variant) but other variants as well, forexample when fixing a
bug[92,p.331].Wedirectlyaddressthisquestionasinourscenario
the feature context (similar to ambition) is always weaker than the
configuration(similar to the projection).
Clone management in terms of clone detection [ 66,84], elimi-
nation [82], tracking [ 20,23,72,86,96], or prevention [ 49], typi-
callyconsiderscodeclonesasasmall-scalephenomenon[ 46,79].
However, we envision to enhance large-scale clone-and-own de-
velopment at any stage of development. As we do not want to
impairdevelopersâ€™habitsandworkflowssignificantly,weaimto
enhanceclone-and-owndevelopmentinsteadofpreventingit.Re-
cently,Mahmoodetal.proposedVirtualPlatform,amethodandtool
for gradualvariabilitymanagementatdifferent stagesinthe spec-
trum between pure clone-and-own and software product lines [ 60].
Justasvariationcontrolsystemsandmigrationmethods,VirtualPlatformalsorequiresfeaturemappingswhichhavetobespecified
manually by developers with the MapAssetToFeature operator.
Feature trace recording could be a possible implementation for
MapAssetToFeature .
7 CONCLUSION
Tracingfeaturestotheirimplementationisoneofthemostcom-
mon tasks for developers and an essential prerequisite for variabil-
ity management solutions. If feature traces are not documented
proactively, as in software product lines, they have to be recovered
retroactivelywhichisofteninaccurateornotpossibleforalltraces.
Inturn,productlinescomewithahighup-frontinvestmentthat
maynot pay off when introducing just asinglenewvariant.
For this reason, we propose to record feature traces during soft-
waredevelopment. Featuretracerecording infersfeaturetracesupon
sourcecodeeditsfromafeaturecontext:auser-specifiedformula.
While product-line techniques and variation control systems re-
quire complete feature traces and migration techniques fail to com-
pletelyrecoverthem,featuretracerecordingaccountsforabsent
knowledge inboth editedandexisting sourcecode.
Inthefuture,weplantoemployrecordedfeaturetracesforvari-
antsynchronisationinclone-and-ownasillustratedinBobâ€™spart
of ourmotivating examplein Sec.2.2. Tothis end,we aim atbroad-
castingeditsandfeaturetracestoallrelevantcodelocationsacross
clonedvariantssimilartocherry-picking.Variantsmight evenbe-
come reconfigurable, when a certain degree of feature traces is
accumulated.Foralltheseideas,thefirstandforemostrequirement
isthe automatedrecording of feature traces.
ACKNOWLEDGMENT
We thank our reviewers for their constructive feedback. We also
thankDucAnhVu,AlexanderBoll,HelgeWrede,andKatharina
Juhnke for proof reading; Tobias HeÃŸ and Pascal Kohlhepp for
their help withthe artefact; Tobias Pett andIna Schaefer for early
feedback; and Larissa FÃ¶rster, Susana Castillo Alejandre, Marc Kas-
subeck,MoritzKappel,Jann-OleHenningson,SaschaFricke,and
Jan-Philipp Tauscher. This work has been partially supported by
theGermanResearchFoundationwithintheproject VariantSync
(TH 2387/1-1 andKE 2267/1-1).
REFERENCES
[1]Hadil Abukwaik, Andreas Burger, Berima Kweku Andam, and Thorsten Berger.
2018. Semi-Automated Feature Traceability with Embedded Annotations. In
Proc. Intâ€™l Conf. on Software Maintenance and Evolution (ICSME) . IEEE, 529Å›533.
https://doi.org/10.1109/ICSME.2018.00049
[2]AlfredV.Aho,MonicaS.Lam,RaviSethi,andJeffreyD.Ullman.2006. Compilers:
Principles, Techniques, and Tools(2nd Edition) . Addison-Wesley.
[3]Raâ€™Fat Al-Msieâ€™deen, Abdelhak Seriai, Marianne Huchard, Christelle Urtado,
Sylvain Vauttier, and Hamzeh Eyal Salman. 2013. Feature Location in a Col-
lectionofSoftwareProductVariantsUsingFormalConceptAnalysis.In Proc.
Intâ€™lConf.onSoftwareReuse(ICSR) ,JohnM.FavaroandMaurizioMorisio(Eds.),
Vol. 7925.Springer, 302Å›307. https://doi.org/10.1007/978-3-642-38977-1_22
[4]NasirAli,Yann-GaelGueheneuc,andGiulianoAntoniol.2013.Trustrace:Mining
Software Repositories to Improve the Accuracy of Requirement Traceability
Links.IEEETrans.onSoftwareEngineering(TSE) 39,5(2013),725Å›741. https:
//doi.org/10.1109/TSE.2012.71
[5]Sofia Ananieva, Sandra Greiner, Thomas KÃ¼hn, Jacob KrÃ¼ger, Lukas Linsbauer,
Sten GrÃ¼ner, Timo Kehrer, Heiko Klare, Anne Koziolek, Henrik LÃ¶nn, Sebastian
Krieter,ChristophSeidl,S.Ramesh,RalfReussner,andBernhardWestfechtel.
2020. AConceptualModelfor UnifyingVariability in Space and Time.In Proc.
Intâ€™l Systems and Software Product Line Conf. (SPLC) . ACM, Article 15, 12 pages.
https://doi.org/10.1145/3382025.3414955
1017ESEC/FSE â€™21, August 23Å›28, 2021,Athens,Greece P. M. Bittner, A.SchultheiÃŸ, T. ThÃ¼m,T. Kehrer, J. M. Young, L.Linsbauer
[6]BerimaAndam,AndreasBurger,ThorstenBerger,andMichelR.V.Chaudron.
2017. FLOrIDA: Feature LOcatIon DAshboard for Extracting and Visualizing
Feature Traces. In Proc. Intâ€™l Workshop on Variability Modelling of Software-
Intensive Systems (VaMoS) . ACM, 100Å›107. https://doi.org/10.1145/3023956.
3023967
[7]MichaÅ‚Antkiewicz,WenbinJi,ThorstenBerger,KrzysztofCzarnecki,Thomas
Schmorleiz, Ralf LÃ¤mmel, Stefan StÄƒnciulescu, Andrzej WÄ…sowski, and Ina
Schaefer. 2014. Flexible Product Line Engineering with a Virtual Platform.
InProc. Intâ€™l Conf. on Software Engineering (ICSE) . ACM, 532Å›535. https:
//doi.org/10.1145/2591062.2591126
[8]Sven Apel, Don Batory, Christian KÃ¤stner, and Gunter Saake. 2013. Feature-
OrientedSoftwareProductLines . Springer. https://doi.org/10.1007/978-3-642-
37521-7
[9]Muhammad Asaduzzaman, Chanchal K. Roy, Kevin A. Schneider, and Massim-
ilianoDiPenta.2013. LHDiff:ALanguage-IndependentHybridApproachfor
TrackingSourceCodeLines.In Proc.Intâ€™lConf.onSoftwareMaintenance(ICSM) .
IEEE,230Å›239. https://doi.org/10.1109/ICSM.2013.34
[10]Don Batory. 2005. Feature Models, Grammars, and Propositional Formulas.
InProc. Intâ€™l Systems and Software Product Line Conf. (SPLC) . Springer, 7Å›20.
https://doi.org/10.1007/11554844_3
[11]Thorsten Berger, Marsha Chechik, Timo Kehrer, and Manuel Wimmer. 2019.
SoftwareEvolutioninTimeandSpace:UnifyingVersionandVariabilityMan-
agement(DagstuhlSeminar19191). DagstuhlReports 9,5(2019),1Å›30. https:
//doi.org/10.4230/DagRep.9.5.1
[12]ThorstenBerger,DanielaLettner,JuliaRubin,PaulGrÃ¼nbacher,AdelineSilva,
Martin Becker, Marsha Chechik, and Krzysztof Czarnecki. 2015. What is a
Feature?AQualitativeStudyofFeaturesinIndustrialSoftwareProductLines.
InProc.Intâ€™lSystemsandSoftwareProductLineConf.(SPLC) .ACM,16Å›25. https:
//doi.org/10.1145/2791060.2791108
[13]Ted J. Biggerstaff, Bharat G. Mitbander, and Dallas Webster. 1993. The Concept
Assignment Problem in Program Understanding. In Proc. Intâ€™l Conf. on Software
Engineering (ICSE) . IEEE,482Å›498. https://doi.org/10.1109/ICSE.1993.346017
[14]Philip Bille. 2005. A Survey on Tree Edit Distance and Related Problems. Theo-
retical ComputerScience 337, 1Å›3(2005),217Å›239. https://doi.org/10.1016/j.tcs.
2004.12.030
[15]Paul Maximilian Bittner. 2020. Semi-Automated Inference of Feature Traceability
DuringSoftwareDevelopment . Masterâ€™sthesis.TUBraunschweig. https://doi.
org/10.24355/dbbs.084-202002271120-0
[16]Goetz Botterweck and Andreas Pleuss. 2014. Evolution of Software Product
Lines. In Evolving Software Systems . Springer, 265Å›295. https://doi.org/10.1007/
978-3-642-45398-4_9
[17]Sudarshan S. Chawathe, Anand Rajaraman, Hector Garcia-Molina, and Jennifer
Widom.1996. ChangeDetectioninHierarchicallyStructuredInformation.In
Proc. Intâ€™l Conf. on Management of Data (SIGMOD) . ACM, 493Å›504. https:
//doi.org/10.1145/233269.233366
[18]ReidarConradiandBernhardWestfechtel.1998. VersionModelsforSoftware
Configuration Management. ACM Computing Surveys (CSUR) 30, 2 (1998),
232Å›282. https://doi.org/10.1145/280277.280280
[19]Krzysztof Czarnecki and Ulrich Eisenecker. 2000. Generative Programming:
Methods,Tools,and Applications . ACM/Addison-Wesley.
[20]MichieldeWit,AndyZaidman,andArievanDeursen.2009. ManagingCode
Clones Using Dynamic Change Tracking and Resolution. In Proc. Intâ€™l Conf.
onSoftwareMaintenance(ICSM) .169Å›178. https://doi.org/10.1109/ICSM.2009.
5306336
[21]Nicolas Dintzner, Arie van Deursen, and Martin Pinzger. 2018. FEVER: An
Approach to Analyze Feature-Oriented Changes and Artefact Co-Evolution
inHighlyConfigurableSystems. EmpiricalSoftwareEngineering(EMSE) 23,2
(2018), 905Å›952. https://doi.org/10.1007/s10664-017-9557-6
[22]BogdanDit,MeghanRevelle,MalcomGethers,andDenysPoshyvanyk.2013.
FeatureLocationinSourceCode:ATaxonomyandSurvey. J.Software:Evolution
and Process 25,1 (2013), 53Å›95. https://doi.org/10.1002/smr.567
[23]Ekwa Duala-Ekoko and Martin P. Robillard. 2010. Clone Region Descriptors:
Representing and Tracking Duplication in Source Code. Trans. on Software
EngineeringandMethodology(TOSEM) 20,1(2010),31pages. https://doi.org/10.
1145/1767751.1767754
[24]Yael Dubinsky, Julia Rubin, Thorsten Berger, Slawomir Duszynski, Martin
Becker, and Krzysztof Czarnecki. 2013. An Exploratory Study of Cloning in
IndustrialSoftwareProductLines.In Proc.Europ.Conf.onSoftwareMaintenance
and Reengineering (CSMR) . IEEE, 25Å›34. https://doi.org/10.1109/CSMR.2013.13
[25]AndrewDavidEisenbergandKrisDe Volder.2005. DynamicFeatureTraces:
FindingFeaturesinUnfamiliarCode.In Proc.Intâ€™lConf.onSoftwareMaintenance
(ICSM). IEEE,337Å›346. https://doi.org/10.1109/ICSM.2005.42
[26]Sina Entekhabi, Anton Solback, Jan-Philipp SteghÃ¶fer, and Thorsten Berger.
2019. Visualization of Feature Locations with the Tool FeatureDashboard. In
Proc. Intâ€™l Systems and Software Product Line Conf. (SPLC) . ACM, 1Å›4. https:
//doi.org/10.1145/3307630.3342392
[27]Jean-RÃ©myFalleri,FlorÃ©alMorandat,XavierBlanc,MatiasMartinez,andMartin
Monperrus. 2014. Fine-Grained and Accurate Source Code Differencing. InProc. Intâ€™l Conf. on Automated Software Engineering (ASE) . 313Å›324. https:
//doi.org/10.1145/2642937.2642982
[28]WolframFenske,JensMeinicke,SandroSchulze,SteffenSchulze,andGunter
Saake. 2017. Variant-Preserving Refactorings for Migrating Cloned Products to
aProductLine.In Proc.Intâ€™lConf.onSoftwareAnalysis,EvolutionandReengi-
neering(SANER) .IEEE,316Å›326. https://doi.org/10.1109/SANER.2017.7884632
[29]Stefan Fischer, Lukas Linsbauer, Roberto E. Lopez-Herrejon, and Alexander
Egyed. 2015. The ECCO Tool: Extraction and Composition for Clone-and-
Own.InProc.Intâ€™lConf.onSoftwareEngineering(ICSE) .IEEE,665Å›668. https:
//doi.org/10.1109/ICSE.2015.218
[30]BeatFluri,MichaelWuersch,MartinPinzger,andHaraldGall.2007. Change
Distilling:Tree Differencingfor Fine-Grained SourceCodeChangeExtraction.
IEEETrans.onSoftwareEngineering(TSE) 33,11(2007),725Å›743. https://doi.
org/10.1109/TSE.2007.70731
[31]MasatomoHashimotoandAkiraMori.2008. Diff/TS:AToolforFine-Grained
Structural Change Analysis. In Proc. Working Conf. on Reverse Engineering
(WCRE). 279Å›288. https://doi.org/10.1109/WCRE.2008.44
[32]FlorianHeidenreich, Jan Kopcsek, andChristianWende. 2008. FeatureMapper:
Mapping Features to Models. In Companion Intâ€™l Conf. on Software Engineering
(ICSEC). ACM, 943Å›944. https://doi.org/10.1145/1370175.1370199 Informal
demonstrationpaper.
[33]PatrickHeymans,QuentinBoucher,AndreasClassen,ArnaudBourdoux,and
LaurentDemonceau.2012. ACodeTaggingApproachtoSoftwareProductLine
Development. Intâ€™lJ.SoftwareToolsforTechnologyTransfer(STTT) 14(2012),
553Å›566. Issue 5. https://doi.org/10.1007/s10009-012-0242-1
[34]James W. Hunt and Thomas Gregory Szymanski. 1977. A Fast Algorithm for
ComputingLongestCommonSubsequences. Comm.ACM 20,5(1977),350Å›353.
https://doi.org/10.1145/359581.359603
[35]Wenbin Ji, Thorsten Berger, Michal Antkiewicz, and Krzysztof Czarnecki. 2015.
Maintaining Feature Traceability with Embedded Annotations. In Proc. Intâ€™l
SystemsandSoftware ProductLineConf.(SPLC) .ACM, 61Å›70. https://doi.org/
10.1145/2791060.2791107
[36]Huzefa Kagdi, Malcom Gethers, and Denys Poshyvanyk. 2013. Integrating
Conceptual and Logical Couplings for Change Impact Analysis in Software.
Empirical Software Engineering (EMSE) 18, 5 (2013), 933Å›969. https://doi.org/10.
1007/s10664-012-9233-9
[37]ChristianKÃ¤stner.2010. VirtualSeparationofConcerns:TowardPreprocessors2.0 .
Ph.D. Dissertation. Universityof Magdeburg.
[38]Christian KÃ¤stner, Sven Apel, and Martin Kuhlemann. 2008. Granularity in
SoftwareProductLines.In Proc.Intâ€™lConf.onSoftwareEngineering(ICSE) .ACM,
311Å›320. https://doi.org/10.1145/1368088.1368131
[39]ChristianKÃ¤stner,SvenApel,SalvadorTrujillo,MartinKuhlemann,andDon
Batory.2009. GuaranteeingSyntacticCorrectnessforAllProductLineVariants:
ALanguage-IndependentApproach.In Proc.Intâ€™lConf.Objects,Models,Com-
ponents, Patterns (TOOLS EUROPE) , Manuel Oriol and Bertrand Meyer (Eds.).
Springer, 175Å›194. https://doi.org/10.1007/978-3-642-02571-6_11
[40]Christian KÃ¤stner, Alexander Dreiling, and Klaus Ostermann. 2014. Variability
Mining: Consistent Semiautomatic Detection of Product-Line Features. IEEE
Trans.onSoftwareEngineering(TSE) 40,1(2014),67Å›82. https://doi.org/10.1109/
TSE.2013.45
[41]Timo Kehrer. 2015. Calculation and Propagation of Model Changes Based on
User-Level Edit Operations: A Foundation for Version and Variant Management in
Model-DrivenEngineering . Ph.D. Dissertation. Universityof Siegen.
[42]Timo Kehrer, Udo Kelter, and Gabriele Taentzer. 2011. A Rule-Based Approach
totheSemanticLiftingofModelDifferencesintheContextofModelVersioning.
InProc. Intâ€™l Conf. on Automated Software Engineering (ASE) . ACM, 163.Å›172.
https://doi.org/10.1109/ASE.2011.6100050
[43]Timo Kehrer, Udo Kelter, and Gabriele Taentzer. 2013. Consistency-Preserving
Edit Scripts in Model Versioning. In Proc. Intâ€™l Conf. on Automated Software
Engineering (ASE) . ACM,191Å›201. https://doi.org/10.1109/ASE.2013.6693079
[44]TimoKehrer,ThomasThÃ¼m,AlexanderSchultheiÃŸ,andPaulMaximilianBittner.
2021. BridgingtheGapBetweenClone-and-OwnandSoftwareProductLines.
InProc. Intâ€™l Conf. on Software Engineering (ICSE) . IEEE, 21Å›25. https://doi.org/
10.1109/ICSE-NIER52604.2021.00013
[45]Benjamin Klatt, Martin KÃ¼ster, and Klaus Krogmann. 2013. A Graph-Based
AnalysisConcepttoDeriveaVariationPointDesignfromProductCopies.In
Proc. Intâ€™lWorkshop onReverse VariabilityEngineering (REVE) . 1Å›8.
[46]RainerKoschke.2007. SurveyofResearchonSoftwareClones.In Duplication,
Redundancy,andSimilarityinSoftware (DagstuhlSeminarProceedings,06301) ,
RainerKoschke,EttoreMerlo,andAndrewWalenstein(Eds.).IBFI. http://drops.
dagstuhl.de/opus/volltexte/2007/962
[47]Rainer Koschke, Pierre Frenzel, Andreas P. Breu, and Karsten Angstmann.
2009. Extending the Reflexion Method for Consolidating Software Variants
into Product Lines. Software Quality Journal (SQJ) 17, 4 (2009), 331Å›366.
https://doi.org/10.1007/s11219-009-9077-8
[48]Jacob KrÃ¼ger, ThorstenBerger, and Thomas Leich.2019. Features and How to
FindThem:ASurveyofManualFeatureLocation. In SoftwareEngineeringfor
1018Feature Trace Recording ESEC/FSE â€™21, August 23Å›28, 2021,Athens,Greece
VariabilityIntensiveSystems-FoundationsandApplications .AuerbachPublica-
tions / Taylor & Francis, 153Å›172. https://doi.org/10.1201/9780429022067-7
[49]BrunoLague,DanielProulx,JeanMayrand,EttoreM.Merlo,andJohnHudepohl.
1997. Assessing the Benefits of Incorporating Function Clone Detection in a
Development Process. In Proc. Intâ€™l Conf. on Software Maintenance (ICSM) . IEEE,
314Å›321. https://doi.org/10.1109/ICSM.1997.624264
[50]Miguel A. Laguna and Yania Crespo. 2013. A Systematic Mapping Study on
SoftwareProductLineEvolution:FromLegacySystemReengineeringtoProduct
LineRefactoring. ScienceofComputerProgramming(SCP) 78,8(2013),1010Å›1034.
https://doi.org/10.1016/j.scico.2012.05.003
[51]RaÃºl LapeÃ±a, Manuel Ballarin, and Carlos Cetina. 2016. Towards Clone-and-
Own Support: Locating Relevant Methods in Legacy Products. In Proc. Intâ€™l
SystemsandSoftwareProductLineConf.(SPLC) .ACM,194Å›203. https://doi.org/
10.1145/2934466.2934485
[52]Duc Le, Eric Walkingshaw, and Martin Erwig. 2011. #ifdef Confirmed Harmful:
Promoting Understandable Software Variation. In Proc. Intâ€™l Symposium on
Visual Languages and Human-Centric Computing (VL/HCC) . IEEE, 143Å›150.
https://doi.org/10.1109/VLHCC.2011.6070391
[53]JÃ¶rg Liebig, Sven Apel, Christian Lengauer, Christian KÃ¤stner, and Michael
Schulze. 2010. An Analysis of the Variability in Forty Preprocessor-Based
SoftwareProductLines.In Proc.Intâ€™lConf.onSoftwareEngineering(ICSE) .IEEE,
105Å›114. https://doi.org/10.1145/1806799.1806819
[54]JÃ¶rgLiebig,ChristianKÃ¤stner,andSvenApel.2011. AnalyzingtheDiscipline
ofPreprocessorAnnotationsin30MillionLinesofCCode.In Proc.Intâ€™lConf.
onAspect-OrientedSoftwareDevelopment(AOSD) .ACM,191Å›202. https://doi.
org/10.1145/1960275.1960299
[55]Lukas Linsbauer, Thorsten Berger, and Paul GrÃ¼nbacher. 2017. A Classification
of Variation Control Systems. In Proc. Intâ€™l Conf. on Generative Programming:
Concepts&Experiences(GPCE) .ACM,49Å›62. https://doi.org/10.1145/3136040.
3136054
[56]Lukas Linsbauer, Alexander Egyed, and Roberto Erick Lopez-Herrejon. 2016. A
VariabilityAwareConfigurationManagementandRevisionControlPlatform.
InProc.Intâ€™lConf.onSoftwareEngineering(ICSE) .ACM,803Å›806. https://doi.
org/10.1145/2889160.2889262
[57]Lukas Linsbauer, Stefan Fischer, Roberto E. Lopez-Herrejon, and Alexander
Egyed. 2015. Using Traceability for Incremental Construction and Evolution of
SoftwareProductPortfolios.In Proc. Intâ€™lSymposium onSoftwareandSystems
Traceability (SST) . IEEE,57Å›60. https://doi.org/10.1109/SST.2015.16
[58]Lukas Linsbauer, Roberto Erick Lopez-Herrejon, and Alexander Egyed. 2017.
Variability Extraction and Modeling for Product Variants. Software and System
Modeling (SoSyM) 16, 4 (2017), 1179Å›1199. https://doi.org/10.1007/s10270-015-
0512-y
[59]JiaLiu,DonBatory,andChristianLengauer.2006. FeatureOrientedRefactoring
ofLegacyApplications.In Proc.Intâ€™lConf.onSoftwareEngineering(ICSE) .ACM,
112Å›121. https://doi.org/10.1145/1134285.1134303
[60]Wardah Mahmood, Daniel Strueber, Thorsten Berger, Ralf Laemmel, and Muke-
labai Mukelabai. 2021. Seamless Variability Management With the Virtual
Platform.In Proc.Intâ€™lConf.onSoftwareEngineering(ICSE) .IEEE,1658Å›1670.
https://doi.org/10.1109/ICSE43902.2021.00147
[61]R. Malaquias, M. Ribeiro, R. BonifÃ¡cio, E. Monteiro, F. Medeiros, A. Garcia, and
R.Gheyi.2017. TheDisciplineofPreprocessor-BasedAnnotations-Does#ifdef
TAG nâ€™t #endif Matter. In Proc. Intâ€™l Conf. on Program Comprehension (ICPC) .
297Å›307. https://doi.org/10.1109/ICPC.2017.41
[62]Jabier Martinez, Tewfik Ziadi, TegawendÃ© F. BissyandÃ©, Jacques Klein, and Yves
Le Traon. 2015. Bottom-Up Adoption of Software Product Lines: A Generic
and ExtensibleApproach. In Proc. Intâ€™l Systems and Software Product Line Conf.
(SPLC). ACM,101Å›110. https://doi.org/10.1145/2791060.2791086
[63]FlÃ¡vio Medeiros, MÃ¡rcio Ribeiro, and Rohit Gheyi. 2013. Investigating
Preprocessor-BasedSyntaxErrors.In Proc.Intâ€™lConf.onGenerativeProgram-
ming: Concepts & Experiences (GPCE) . ACM, 75Å›84. https://doi.org/10.1145/
2517208.2517221
[64]FlÃ¡vio Medeiros, MÃ¡rcio Ribeiro, Rohit Gheyi, Sven Apel, Christian KÃ¤stner,
Bruno Ferreira, Luiz Carvalho, and Baldoino Fonseca. 2018. Discipline Matters:
RefactoringofPreprocessorDirectivesinthe#ifdefHell. IEEETrans.onSoft-
ware Engineering (TSE) 44, 5 (2018), 453Å›469. https://doi.org/10.1109/TSE.2017.
2688333
[65]Raul Medina-Mora and Peter H. Feiler. 1981. An Incremental Programming
Environment. IEEE Trans. onSoftwareEngineering (TSE) 5 (1981), 472Å›482.
[66]Thilo Mende, Rainer Koschke, and Felix Beckwermert. 2009. An Evaluation
of Code Similarity Identification for the Grow-and-Prune Model. J. Software
Maintenance and Evolution (JSME) 21, 2 (2009), 143Å›169. https://doi.org/10.
1002/smr.v21:2
[67]Gabriela Karoline Michelon, Lukas Linsbauer, Wesley K.G. AssunÃ§Ã£o, Stefan
Fischer, and Alexander Egyed. 2021. A Hybrid Feature Location Technique
for Re-Engineering SingleSystems intoSoftware ProductLines. In Proc.Intâ€™l
WorkingConf.onVariabilityModellingofSoftware-IntensiveSystems(VaMoS) .
ACM,Article11,9 pages. https://doi.org/10.1145/3442391.3442403[68]Gabriela Karoline Michelon, David Obermann, Wesley Klewerton Guez As-
sunÃ§Ã£o, Lukas Linsbauer, Paul GrÃ¼nbacher, and Alexander Egyed. 2020. Mining
FeatureRevisions inHighly-ConfigurableSoftwareSystems. In Proc.Intâ€™lSys-
temsandSoftwareProductLineConf.(SPLC) .ACM,74Å›78. https://doi.org/10.
1145/3382026.3425776
[69] GabrielaKaroline Michelon,David Obermann, Lukas Linsbauer, WesleyKlew-
erton GuezAssunÃ§Ã£o,Paul GrÃ¼nbacher, and AlexanderEgyed. 2020. Locating
Feature Revisions in Software Systems Evolving in Space and Time. In Proc.
Intâ€™l Systems and Software Product Line Conf. (SPLC) . ACM, Article 14, 11 pages.
https://doi.org/10.1145/3382025.3414954
[70]WebbMillerandEugeneW.Myers.1985. AFileComparisonProgram. Software:
Practice and Experience 15, 11 (1985),1025Å›1040. https://doi.org/10.1002/spe.
4380151102
[71]Eugene W. Myers. 1986. An O(ND) Difference Algorithm and Its Variations.
Algorithmica 1,1-4 (1986), 251Å›266. https://doi.org/10.1007/BF01840446
[72]HoanAnhNguyen,TungThanhNguyen,NamH.Pham,JafarAl-Kofahi,and
TienN.Nguyen.2012. CloneManagementforEvolvingSoftware. IEEETrans.
on Software Engineering(TSE) 38,5 (2012), 1008Å›1026. https://doi.org/10.1109/
TSE.2011.90
[73]David Notkin. 1985. The GANDALF Project. J. Systems and Software (JSS) 5, 2
(1985), 91Å›105. https://doi.org/10.1016/0164-1212(85)90011-1
[74]LeonardoPassos,JianmeiGuo,LeopoldoTeixeira,KrzysztofCzarnecki,Andrzej
WÄ…sowski, and Paulo Borba. 2013. Coevolution of Variability Models and
Related Artifacts: A Case Study from the Linux Kernel. In Proc. Intâ€™l Systems
and Software Product Line Conf. (SPLC) . ACM, 91Å›100. https://doi.org/10.1145/
2491627.2491628
[75]MateuszPawlikandNikolausAugsten.2011. RTED:ARobustAlgorithmforthe
Tree Edit Distance. Computing Research Repository (CoRR) 5, 4 (2011), 334Å›345.
[76]TristanPfofe,ThomasThÃ¼m,SandroSchulze,WolframFenske,andInaSchaefer.
2016. Synchronizing Software Variants with VariantSync. In Proc. Intâ€™l Systems
and Software Product Line Conf.(SPLC) . ACM, 329Å›332. https://doi.org/10.1145/
2934466.2962726
[77]Klaus Pohl, GÃ¼nter BÃ¶ckle, and Frank J. van der Linden. 2005. Software Product
Line Engineering: Foundations, Principles and Techniques . Springer. https:
//doi.org/10.1007/3-540-28901-1
[78]DenysPoshyvanyk,Yann-GaelGueheneuc,AndrianMarcus,GiulianoAntoniol,
and Vaclav Rajlich. 2007. Feature Location Using Probabilistic Ranking of
Methods Based on Execution Scenarios and Information Retrieval. IEEE Trans.
on Software Engineering (TSE) 33, 6 (2007), 420Å›432. https://doi.org/10.1109/
TSE.2007.1016
[79]DhavleeshRattan,RajeshBhatia,andManinderSingh.2013. SoftwareClone
Detection:ASystematicReview. J.InformationandSoftwareTechnology(IST)
55,7 (2013), 1165Å›1199. https://doi.org/10.1016/j.infsof.2013.01.008
[80]Thomas Reps and Tim Teitelbaum. 1984. The Synthesizer Generator. SIGPLAN
Not.19,5 (1984), 42Å›48. https://doi.org/10.1145/800020.808247
[81]Nicholas Rescher. 1968. Many-Valued Logic . Springer, 54Å›125. https://doi.org/
10.1007/978-94-017-3546-9_6
[82]MatthiasRieger,StÃ©phaneDucasse,andGeorgesGolomingi.1999. ToolSupport
forRefactoringDuplicatedOOCode.In Proc.Europ.Conf.onObject-Oriented
Programming(ECOOP) , Vol. 1743.Springer, 177Å›178.
[83]JuliaRubinandMarshaChechik.2013. ASurveyofFeatureLocationTechniques.
InDomainEngineering:ProductLines,Languages,andConceptualModels ,Iris
Reinhartz-Berger, Arnon Sturm, Tony Clark, Sholom Cohen, and Jorn Bettin
(Eds.).Springer, 29Å›58. https://doi.org/10.1007/978-3-642-36654-3_2
[84]Julia Rubin, Krzysztof Czarnecki, and Marsha Chechik. 2013. Managing Cloned
Variants: A Framework and Experience. In Proc. Intâ€™l Systems and Software
Product Line Conf. (SPLC) . ACM, 101Å›110. https://doi.org/10.1145/2491627.
2491644
[85]ThomasSchmorleizandRalfLÃ¤mmel.2014. SimilarityManagementviaHistory
Annotation.In Proc.SeminaronAdvancedTechniquesandToolsforSoftwareEvo-
lution(SATToSE) .DipartimentodiInformaticaUniversitÃ degliStudidellâ€™Aquila,
Lâ€™Aquila, Italy, 45Å›48.
[86]Thomas Schmorleiz and Ralf LÃ¤mmel. 2016. Similarity Management of â€™Cloned
and Ownedâ€™ Variants. In Proc. ACM Symposium on Applied Computing (SAC) .
ACM,1466Å›1471. https://doi.org/10.1145/2851613.2851785
[87]Sandro Schulze, JÃ¶rg Liebig, Janet Siegmund, and Sven Apel. 2013. Does the
Discipline of Preprocessor Annotations Matter?: A Controlled Experiment.
SIGPLAN Not. 49,3 (2013), 65Å›74. https://doi.org/10.1145/2637365.2517215
[88]Felix SchwÃ¤gerl and Bernhard Westfechtel. 2016. SuperMod: Tool Support
for Collaborative Filtered Model-Driven Software Product Line Engineering.
InProc. Intâ€™l Conf. on Automated Software Engineering (ASE) . ACM, 822Å›827.
https://doi.org/10.1145/2970276.2970288
[89]JanetSiegmund.2016. ProgramComprehension:Past,Present,andFuture.In
Proc.Intâ€™lConf.onSoftwareAnalysis,EvolutionandReengineering(SANER) .IEEE,
13Å›20.https://doi.org/10.1109/SANER.2016.35
[90]BolesÅ‚aw SobociÅ„ski.1952. Axiomatization of a Partial System of Three-Value
Calculus of Propositions. Journal of Computing Systems 1, 1 (1952), 23Å›55.
https://doi.org/10.2307/2267445
1019ESEC/FSE â€™21, August 23Å›28, 2021,Athens,Greece P. M. Bittner, A.SchultheiÃŸ, T. ThÃ¼m,T. Kehrer, J. M. Young, L.Linsbauer
[91]HenrySpencerandGeoffCollyer.1992.#ifdefConsideredHarmful,orPortability
Experience With CNews. In USENIX. USENIXAssociation, 185Å›197.
[92]StefanStÄƒnciulescu,ThorstenBerger,EricWalkingshaw,andAndrzejWÄ…sowski.
2016. Concepts, Operations, and Feasibility of a Projection-Based Variation
Control System. In Proc. Intâ€™l Conf. on Software Maintenance and Evolution
(ICSME). IEEE,323Å›333. https://doi.org/10.1109/ICSME.2016.88
[93]Stefan StÄƒnciulescu, Sandro Schulze, and Andrzej WÄ…sowski. 2015. Forked
and Integrated Variants in an Open-Source Firmware Project. In Proc. Intâ€™l
Conf. on Software Maintenance and Evolution (ICSME) . IEEE, 151Å›160. https:
//doi.org/10.1109/ICSM.2015.7332461
[94]MatÃºs SulÃ­r, Milan NosÃ¡l, and Jaroslav PorubÃ¤n. 2018. Recording Concerns
in Source Code Using Annotations. Computing Research Repository (CoRR)
abs/1808.03576 (2018).
[95]Thomas ThÃ¼m, Leopoldo Teixeira, Klaus Schmid, Eric Walkingshaw, Muke-
labaiMukelabai,MahsaVarshosaz,GoetzBotterweck,InaSchaefer,andTimo
Kehrer. 2019. Towards Efficient Analysis of Variation in Time and Space. In
Proc.Intâ€™lWorkshoponVariabilityandEvolutionofSoftware-IntensiveSystems
(VariVolution) . ACM,57Å›64. https://doi.org/10.1145/3307630.3342414
[96]Michael Toomim, Andrew Begel, and Susan L. Graham. 2004. Managing
Duplicated Code with Linked Editing. In Proc. Intâ€™l Symposium on Visual
Languages and Human-Centric Computing (VL/HCC) . IEEE, 173Å›180. https:
//doi.org/10.1109/VLHCC.2004.35
[97]Markus Voelter, Janet Siegmund, Thorsten Berger, and Bernd Kolb. 2014. To-
wardsUser-FriendlyProjectionalEditors.In Proc.Intâ€™lConf.onSoftwareLan-
guageEngineering(SLE) .Springer,41Å›61. https://doi.org/10.1007/978-3-319-
11245-9_3[98]Anneliese von Mayrhauser, A. Marie Vans, and Adele E. Howe. 1997. Program
Understanding Behaviour During Enhancement of Large-Scale Software. J.
Software: Evolution and Process 9, 5 (1997), 299Å›327. https://doi.org/10.1002/
(SICI)1096-908X(199709/10)9:5<299::AID-SMR157>3.0.CO;2-S
[99]Neil Walkinshaw, Marc Roper, and Murray Wood. 2007. Feature Location
andExtractionusingLandmarksandBarriers.In Proc.Intâ€™lConf.onSoftware
Maintenance (ICSM) . IEEE,54Å›63. https://doi.org/10.1109/ICSM.2007.4362618
[100]Jinshui Wang, Xin Peng, Zhenchang Xing, and Wenyun Zhao. 2013.
How Developers Perform Feature Location Tasks: A Human-Centric
and Process-Oriented Exploratory Study. J. Software: Evolution and
Process25, 11 (2013), 1193Å›1224. https://doi.org/10.1002/smr.1593
arXiv:https://onlinelibrary.wiley.com/doi/pdf/10.1002/smr.1593
[101]NormanWildeandMichaelC.Scully.1995. SoftwareReconnaissance:Mapping
ProgramFeaturestoCode. J.SoftwareMaintenance:ResearchandPractice 7,1
(1995), 49Å›62. https://doi.org/10.1002/smr.4360070105
[102]David Wille, Sandro Schulze,Christoph Seidl, and Ina Schaefer. 2016. Custom-
TailoredVariabilityMiningforBlock-BasedLanguages.In Proc.Intâ€™lConf.on
Software Analysis,Evolution andReengineering(SANER) .IEEE,271Å›282. https:
//doi.org/10.1109/SANER.2016.13
[103]YinxingXue,ZhenchangXing,andStanJarzabek.2012. FeatureLocationina
CollectionofProductVariants.In Proc.WorkingConf.onReverseEngineering
(WCRE). IEEE,145Å›154. https://doi.org/10.1109/WCRE.2012.24
[104]Tewfik Ziadi, Christopher Henard, Mike Papadakis, Mikal Ziane, and Yves
Le Traon. 2014. Towards a Language-Independent Approach for Reverse-
Engineering of Software Product Lines. In Proc. ACM Symposium on Applied
Computing(SAC) . ACM,1064Å›1071. https://doi.org/10.1145/2554850.2554874
1020