ConditionalInterpolation: MakingConcurrentProgram
VerificationMoreEffective
Jie Su
ICTTand ISN Laboratory, Xidian
University
Xiâ€™an,P.R. China
jsu_3@stu.xidian.edu.cnCongTian
ICTTand ISN Laboratory, Xidian
University
Xiâ€™an,P.R. China
ctian@mail.xidian.edu.cnZhenhua Duan
ICTTand ISN Laboratory, Xidian
University
Xiâ€™an,P.R. China
zhhduan@mail.xidian.edu.cn
ABSTRACT
Due to the state-space explosion problem, efficient verification
of real-world programs in large scale is still a big challenge. Par-
ticularly,threadalternationmakestheverificationofconcurrent
programsmuchmoredifficultsinceitaggravatesthisproblem.In
thispaper,anapplicationofCraiginterpolation,namelyconditional
interpolation, is proposed to work together with CEGAR-based ap-
proachtoreducethestate-spaceofconcurrenttasks.Specifically,
conditional interpolation is formalized to confine the reachable
region of states so that infeasible conditional branches could be
pruned.Furthermore,thegeneratedconditionalinterpolantsareuti-
lized to shorten the interpolation paths, which makes the time con-
sumedforverificationsignificantlyreduced.Wehaveimplemented
theproposedapproachontopofanopen-sourcesoftwaremodel
checker. Empirical results show that the conditional interpolation
iseffectiveinimprovingtheverificationefficiencyofconcurrent
tasks.
CCS CONCEPTS
Â·Theoryofcomputation â†’Verificationbymodelchecking .
KEYWORDS
softwaremodelchecking,concurrentprogramverification,state-
spacereduction, conditional interpolation, CEGAR
ACMReference Format:
Jie Su, Cong Tian, and Zhenhua Duan. 2021. Conditional Interpolation:
MakingConcurrent ProgramVerificationMore Effective.In Proceedingsof
the 29th ACM Joint European Software Engineering Conference and Sym-
posium on the Foundations of Software Engineering (ESEC/FSE â€™21), Au-
gust 23Å›28, 2021, Athens, Greece. ACM, New York, NY, USA, 11pages.
https://doi.org/10.1145/3468264.3468602
1 INTRODUCTION
Program verification can significantly improve the quality of a
program, therefore it is widely used in various scenarios. As an
automated verification approach, model checking [ 22] provides an
accurateandpath-sensitiveanalysistopromisethecorrectnessofa
Permissionto make digitalor hard copies of allorpart ofthis work for personalor
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACM
mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,
topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ESEC/FSE â€™21, August 23Å›28,2021, Athens,Greece
Â©2021 Associationfor Computing Machinery.
ACM ISBN 978-1-4503-8562-6/21/08...$15.00
https://doi.org/10.1145/3468264.3468602program w.r.t. certain properties. However, due to the exponential
growth of paths, this approach usually suffers from the state-space
explosionproblem.Particularly,verifyingconcurrentprogramis
more challenging since thread alternation aggravates this problem.
In orderto reduce the state-spaceeffectively, abstract interpreta-
tiontechnique[ 10],predicateabstraction[ 3,14,18]inparticular,
whichmapsaconcreteprogramontoanabstractmodelhasbeen
widelyusedinprogramverification.Withthisapproach,onecan
concludethatthereisnoerrorintheconcreteprogramiftheabstrac-
tionisconservativeandthereisnoerrorintheabstractmodel[ 12].
However, over-approximation mapping may introduce spurious
counterexamples,i.e.falsepathswhichviolatethegivenproperty
do not correspond to any concrete executions [ 8]. To eliminate
spuriouscounterexamples,counterexample-guidedabstractionre-
finement(CEGAR) approachis proposedtolearn predicatesfrom
theexploredfalsepaths,whichmakesitpossibletorefinetheab-
stract modeliteratively[ 4,7,8,25].
Aninterpolationtechnique,specificallyCraiginterpolation[ 13],
is often used for generating new predicates to adjust the precision
of abstract models [ 4,18,20]. Through utilizing these generated
predicates,certainpaths willbe pruned and the explorationspace
canbefurtherreduced.Severalinterpolationapproacheshavebeen
proposedtoimprovetheverificationefficiency.Forinstance, uni-
versal safety interpolant andexistential error interpolant [26] are
proposedtodeterminewhetherallthepathsemanatingfromastate
aresafeornot.However,theseinterpolationmethodsarelimitedin
performance improvement when verifying concurrentprograms.
In this paper, we focus on one of the most challenging tasks:
proving that a concurrent program satisfies certain reachability
properties. We propose conditional interpolation which can ef-
fectively reduce the state-space to be explored in the concurrent
verification tasks. Specifically, we construct the control-flow graph
(CFG)ofaconcurrentprogramandunwindittoobtaintheabstract
reachability tree (ART). During the unwinding process, predicates
learned from spurious counterexamples are utilized to refine the
abstract model. In addition to the interpolant ( reachability inter-
polantfor clarity) for parsimonious abstraction [ 17], a new kind of
interpolant,namely conditionalinterpolant ,isintroducedtoeffec-
tively prune redundant paths in ART. Different from most of the
abstraction-refinementapproachesthatpredicatesaregenerated
onlywhenerrorlocationsarereached,weimmediatelycompute
theconditionalinterpolantsateachchoicepointtoavoidexplor-
ing infeasible paths. The generated conditional interpolants are
further utilizedto shorten the interpolation paths, and thissimpli-
fication, in return, reduces the time consumption for generating
otherinterpolants withoutperformance degradation.
144ESEC/FSE â€™21, August 23Å›28, 2021,Athens,Greece JieSu,CongTian,andZhenhua Duan.
(a)ğ‘: x= x+ 1;
ğ‘:if(x<3)
ğ‘: x= x+ 2;
ğ‘ƒ1ğ´:intm = x- 1;
ğµ:if(x>4)
ğ¶: Error();
ğ‘ƒ2example.cintx= 0;
(b)ğ‘™1
ğ‘™2
ğ‘™3
ğ‘™4
ğ‘™5
ğºğ‘ƒ1ğ‘™6ğ‘:ğ‘¥=ğ‘¥+1
ğ‘:[ğ‘¥<3]
ğ‘:ğ‘¥=ğ‘¥+2ğ‘‘:[!(ğ‘¥<3)]ğ‘™1
ğ‘™2
ğ‘™3
ğ‘™4
ğ‘™5
ğºğ‘ƒ2ğ‘™6ğ´:ğ‘š=ğ‘¥âˆ’1
ğµ:[ğ‘¥>4]
ğ¶:Error()ğ·
:[!(ğ‘¥>4)]ğ¿0
ğ¿1
ğ¿2
ğ¿3
ğ¿4ğ¿5
ğ¿6
ğ¿7
ğ¿8ğ¿9
ğ¿10
ğ¿11
ğ¿12ğ¿13
ğ¿14
ğ¿15
ğ¿16
ğºğ‘ƒğ‘¥=0
ğ´
ğµ
ğ¶ğ´
ğµ
ğ¶ğ´
ğµ
ğ¶ğ´
ğµ
ğ¶ğ‘
ğ‘
ğ‘ğ‘
ğ‘
ğ‘ğ‘
ğ‘
ğ‘ğ‘
ğ‘
ğ‘
(c)
Figure1:(a)Aconcurrentprogramwithtwothreads;(b)Eachthreadisrepresentedbyasub-CFG( ğ‘‘andğ·denotetheimplicit
conditional branches);(c)The CFGofthisconcurrentprogram (for thesake ofsimplicity,we omitthe branch ğ‘‘andğ·).
WehaveimplementedtheaboveapproachonthebasisofCPAch-
ecker [2], and carried out experiments on the latest concurrency
track of SV-COMP. Empirical results show that compared with
otherinterpolationmethods,conditionalinterpolationiseffectivein
improving the verification efficiency of concurrent tasks. Through
conditional interpolation, the number of explored states is reduced
to 29.87% on average, and the number of programs that could be
verifiedincreasesby17.26%.
The rest of this paper is organized as follows. Section II intro-
duces the preliminaries. Section III presents the proposed condi-
tionalinterpolationapproach.InSectionIV,wepresentanempirical
evaluationofourapproach.Finally,SectionVreviewstherelated
work andSection VI concludes the paper.
2 PRELIMINARIES
This section presents useful notionsinvolvedinthis paper.
2.1 Control-FlowGraphsandAbstract
Reachability Tree
We considera concurrent program ğ‘ƒcomposedof multiplethreads
thatcommunicatethroughsharedvariables.We extendthedefini-
tionofcontrol-flowgraph[ 26]ofsequentialprogramstoconcurrent
programs as follows:
Definition 1. (Control-Flow Graph, CFG): Let ğ‘ƒbe a concurrent
program containing ğ‘â‰¥1threads. The CFG ğºğ‘ƒ=(ğ¿ğ‘ƒ,ğ‘‡ğ‘ƒ,ğ‘™0ğ‘ƒ,ğ‘“ğ‘ƒ)
ofğ‘ƒisdefinedastheproductofthesub-CFG ğºğ‘ƒğ‘–=(ğ¿ğ‘ƒğ‘–,ğ‘‡ğ‘ƒğ‘–,ğ‘™0ğ‘ƒğ‘–,ğ‘“ğ‘ƒğ‘–)
of each thread ğ‘ƒğ‘–(1â‰¤ğ‘–â‰¤ğ‘). Specifically, ğ¿ğ‘ƒğ‘–represents the set of
locationsof ğ‘ƒğ‘–,andğ‘‡ğ‘ƒğ‘–=ğ¿ğ‘ƒğ‘–Ã—Î£ğ‘–Ã—ğ¿ğ‘ƒğ‘–isthreadtransition,where
Î£ğ‘–representstheinstructionsetof ğ‘ƒğ‘–.Notethat,forall ğ‘¡âˆˆğ‘‡ğ‘ƒ,only
onethread ğ‘ƒğ‘–migratesfromonelocationtoitsdirectsuccessor.The
locationsforallotherthreadsremainunchanged.Finally, ğ‘™0ğ‘ƒğ‘–âˆˆğ¿ğ‘ƒğ‘–
represents the initial location of ğ‘ƒğ‘–andğ‘“ğ‘ƒğ‘–âˆˆğ¿ğ‘ƒğ‘–denotes the set of
finallocations of ğ‘ƒğ‘–,respectively.
As an example, two sub-CFGs ğºğ‘ƒ1andğºğ‘ƒ2of the simplified
concurrent program ğ‘ƒwhich contains two threads ğ‘ƒ1andğ‘ƒ2as
showninFig. 1(a)aredepictedinFig. 1(b),andtheoverallCFG ğºğ‘ƒ
isshowninFig. 1(c).Forsimplicity,weuseasubscript ğ‘–touniquelyrepresent a combination of thread locations (e.g., in Fig. 1(c),ğ¿2
indicates that ğ‘ƒ1andğ‘ƒ2are locatedat ğ‘™1andğ‘™2,respectively).
By unwinding a CFG ğºğ‘ƒ, anabstract reachability tree (ART)
could be generated. Specifically, an ART ğ´ğ‘ƒ=(S,E)consists of
asetSofabstractstatesandaset Eofedges.Eachabstractstate
ğ‘ âˆˆSis a triple ğ‘ =(ğ‘™ğ‘ ,ğ‘ğ‘ ,ğ‘ğ‘ ), whereğ‘™ğ‘ âˆˆğ¿ğ‘ƒis a location in
ğºğ‘ƒ,ğ‘ğ‘ isthecurrentcallstackthatmodelsasequenceoffunction
returnaddresses,and ğ‘ğ‘ isthesetofpredicatesthatconfinesthe
reachable region ğ‘Ÿğ‘ of variables. Here, ğ‘Ÿğ‘ =/logicalandtext.1
ğ‘–/dotaccğ‘ğ‘ 
ğ‘–represents the
reachableregionofabstractstate ğ‘ ,and/dotaccğ‘ğ‘ 
ğ‘–representstheevaluation
ofpredicate ğ‘ğ‘ 
ğ‘–âˆˆğ‘ğ‘ atstateğ‘ (i.e.,ğ‘ğ‘ 
ğ‘–orÂ¬ğ‘ğ‘ 
ğ‘–).Forexample,if ğ‘¥1=2
atstateğ‘ ,wecanuse ğ‘Ÿğ‘ =/dotaccğ‘ğ‘ 
1âˆ§/dotaccğ‘ğ‘ 
2=Â¬(ğ‘¥1â‰¤1)âˆ§(ğ‘¥1â‰¤3)toconfine
its reachable region, where ğ‘ğ‘ ={ğ‘ğ‘ 
1:ğ‘¥â‰¤1,ğ‘ğ‘ 
2:ğ‘¥â‰¤3}. Note that
ğ‘Ÿğ‘ =ğ‘¡ğ‘Ÿğ‘¢ğ‘’whenğ‘ğ‘ is empty. In addition, an edge ğ‘’âˆˆEis also a
tripleğ‘’=(ğ‘ ,ğ‘¡,ğ‘ â€²)whereğ‘ andğ‘ â€²are abstract states in S,ğ‘¡âˆˆğ‘‡ğ‘ƒ
is a thread transition where the transition formula ğ‘¡ğ‘“is encoded
accordingtotheinstruction ğœâˆˆÎ£ofğ‘¡.Giventwostates ğ‘ andğ‘ â€²,
wesayğ‘ iscoveredbyğ‘ â€²ifğ‘™ğ‘ =ğ‘™ğ‘ â€²,ğ‘ğ‘ =ğ‘ğ‘ â€²,andğ‘Ÿğ‘ â†’ğ‘Ÿğ‘ â€².Intuitively,
if stateğ‘ is covered by ğ‘ â€²and all the successors of ğ‘ â€²have been
explored,wedonotneedtoexplorethesuccessorsof ğ‘ sinceallthe
computationsalong ğ‘ willbe the same as thosealong ğ‘ â€².
A pathğœ‹=âŸ¨ğ‘ 0,ğ‘’0,...,ğ‘’ğ‘›âˆ’1,ğ‘ ğ‘›âŸ©of an ART is a finite alternating
sequence of states and edges, and the conjunction of transition
formulas ğœ‹ğ‘“=/logicalandtext.1ğ‘›âˆ’1
ğ‘=0ğ‘¡ğ‘ğ‘“ofğœ‹is called a path formula . Note that,
every variable occurring in ğœ‹ğ‘“is only assigned once (i.e., every
formulain ğœ‹ğ‘“isexpressedintheformofstaticsingleassignment
(SSA)),andweintroduceanewsubscripttoavariablewhenitis
newlyassigned.Finally,aconcurrentprogram ğ‘ƒissafew.r.t.certain
reachability properties if all the error locations ğ‘™âˆˆğ¿ğ‘ƒ(e.g.,ğ¿4in
Fig.1(c))are unreachable.
2.2 CraigInterpolation
Given two formulas ğœ™andğœ“such that ğœ™âˆ§ğœ“is unsatisfiable, if
anotherformula ğœŒsatisfiesthefollowingthreeconditions:1) ğœ™â†’ğœŒ,
2)ğœŒâˆ§ğœ“isunsatisfiable,and3)everynon-logicalsymbolin ğœŒoccurs
inbothğœ™andğœ“,wesaythatformula ğœŒisaCraiginterpolant[ 11]of
formulasğœ™andğœ“,andwedenotethisas ğœŒ=Craig(ğœ™,ğœ“).Intuitively,
ğœŒisarelaxationof ğœ™,but isstillinconsistentwith ğœ“.
145Conditional Interpolation: MakingConcurrentProgram Verification More Effective ESEC/FSE â€™21, August 23Å›28, 2021,Athens,Greece
ğ‘ 0ğ¿0
ğ‘ 1
ğ¿1 ğ‘ 2ğ¿5
ğ‘ 3ğ¿17
ğ‘ 4ğ¿18
ğ‘ 5ğ¿19
ğ‘ 6
ğ¿20
ğœ‹1ğ¶ğµ
ğ‘ 7
ğ¿21ğ·ğ´ğ‘‘
ğ‘ 8ğ¿9
ğ‘ 9ğ¿13
ğ‘ 10
ğ¿14
ğ‘ 11
ğ¿15
ğ‘ 12
ğ¿16ğœ‹2ğ¶ğµ
ğ‘ 13
ğ¿22ğ·ğ´ğ‘
ğ‘ 14
ğ¿10ğ´ğ‘ ğ‘ 15
ğ¿6ğ´ğ‘
ğ‘ 16ğ¿2
ğ‘ 17ğ¿6
ğ‘ 18
ğ¿18
ğ‘ 19
ğ¿19
ğ‘ 20
ğ¿20
ğœ‹3ğ¶ğµ
ğ‘ 21
ğ¿21ğ·ğ‘‘
ğ‘ 22
ğ¿10ğ‘
ğ‘ 23ğ¿7
ğ‘ 24
ğ¿8
ğœ‹4ğ¶ğµ
ğ‘ 25
ğ¿23ğ·ğ‘
ğ‘ 26
ğ¿24ğ· ğ‘ 27ğ¿3
ğ‘ 28
ğ¿4
ğœ‹5ğ¶
ğ‘ 29ğ¿7ğ‘ğµğ´ğ‘¥=0
Figure2:TheARTofexample.cconstructedbyreachabilityanalysisovertheemptypredicateset P.Andforthesakeofsaving
space,we omitthesuccessors ofsquare states.
2.3 Reachability Analysis & Reachability
Interpolant
Byusingfirst-orderformulas,wedefineaglobalset Pofpredicates
overthesetVofvariablesinaquantifier-freetheory.Whenexplor-
ing an ART, a finite subset ğ‘ğ‘ âŠ†Pof stateğ‘ confines the reachable
region of variables in V. If a transition formula ğ‘¡ğ‘“conflicts with
thereachableregion ğ‘Ÿğ‘ ofprecursorstate ğ‘ ,itsdirectsuccessor ğ‘ â€²is
unreachable.Formally,foranyedge ğ‘’=(ğ‘ ,ğ‘¡,ğ‘ â€²)âˆˆE,ğ‘ â€²isreachable
only if formula ğ‘Ÿğ‘ âˆ§ğ‘¡ğ‘“is satisfiable. Further, if ğ‘ â€²is reachable, then
the predicate set ğ‘ğ‘ â€²and the reachable region ğ‘Ÿğ‘ â€²are updated by:
1) choosing the predicates ğ‘ğ‘ â€²âŠ†Pthat have common variables
with the formula ğ‘Ÿğ‘ âˆ§ğ‘¡ğ‘“, and 2) computing the reachable region
ğ‘Ÿğ‘ â€²=/logicalandtext.1
ğ‘–/dotaccğ‘ğ‘ â€²
ğ‘–,ğ‘ğ‘ â€²
ğ‘–âˆˆğ‘ğ‘ â€²,where
/dotaccğ‘ğ‘ â€²
ğ‘–=ï£±ï£´ï£´ ï£²
ï£´ï£´ï£³ğ‘ğ‘ â€²
ğ‘–ifğ‘Ÿğ‘ âˆ§ğ‘¡ğ‘“âˆ§Â¬ğ‘ğ‘ â€²
ğ‘–isunsatisfiable,
Â¬ğ‘ğ‘ â€²
ğ‘–ifğ‘Ÿğ‘ âˆ§ğ‘¡ğ‘“âˆ§ğ‘ğ‘ â€²
ğ‘–isunsatisfiable,or
ğ‘¡ğ‘Ÿğ‘¢ğ‘’otherwise( ğ‘ğ‘ â€²
ğ‘–willnot be placedin ğ‘ğ‘ â€²).
In fact, this update operation builds an relaxation ğ‘Ÿğ‘ â€²ofğ‘Ÿğ‘ âˆ§ğ‘¡ğ‘“(i.e.,
ğ‘Ÿğ‘ âˆ§ğ‘¡ğ‘“â†’ğ‘Ÿğ‘ â€²) over the predicates in P.
Initially, the predicate set Pis empty. In order to expand it,
the interpolation aided CEGAR approach utilizes spurious coun-
terexamplesto generate interpolants.Specifically, thereachability
interpolant isdefinedas follows:
Definition 2. (Reachability Interpolant, R-Intp): Let ğœ‹=âŸ¨ğ‘ 0,ğ‘’0,
...,ğ‘’ğ‘›âˆ’1,ğ‘ ğ‘›âŸ©be a spurious path in an ART (i.e., ğœ‹ğ‘“is unsatisfiable).
For each0<ğ‘–<ğ‘›, the path ğœ‹can be split into two parts ğœ‹ğ´=
âŸ¨ğ‘ 0,ğ‘’0,...,ğ‘ ğ‘–âŸ©andğœ‹ğµ=âŸ¨ğ‘ ğ‘–,ğ‘’ğ‘–,...,ğ‘ ğ‘›âŸ©. Then, the reachability inter-
polant of these two parts is ğ‘ğ‘–=Craig(ğœ‹ğ´ğ‘“,ğœ‹ğµğ‘“). Meanwhile, the
predicatesetPcanbeupdated byP:=Pâˆª/uniontext.1ğ‘›âˆ’1
ğ‘–=1{ğ‘ğ‘–}.
3 CONDITIONALINTERPOLATION
Inthissection, conditionalinterpolation isintroducedtoprunere-
dundantconditional branchesthatfrequentlyoccurinconcurrent
verificationtasks.Foreaseofunderstanding,weuseamotivating
example to illustrate the approach.3.1 A Motivating Example
We consider a simplified concurrent program ğ‘ƒthat consists of
two threads ğ‘ƒ1,ğ‘ƒ2, and a global variable ğ‘¥as shown in Fig. 1(a). It
will be regarded as an unsafe program if thread ğ‘ƒ2could reach the
locationğ‘™4ofğºğ‘ƒ2.
Initially, all the states in Fig. 2are reachable because their reach-
able region ğ‘Ÿğ‘ defaultsto ğ‘¡ğ‘Ÿğ‘¢ğ‘’. By depth-firstsearch (DFS), thread
ğ‘ƒ2firstly reaches theerrorlocation ğ‘™4inpathğœ‹1. However, ğœ‹1isa
spuriouscounterexamplesincethepathformula ğœ‹1ğ‘“:ğ‘¥0=0âˆ§ğ‘¥1=
ğ‘¥0+1âˆ§Â¬(ğ‘¥1<3)âˆ§ğ‘š0=ğ‘¥1âˆ’1âˆ§ğ‘¥1>4âˆ§ğ‘¡ğ‘Ÿğ‘¢ğ‘’isunsatisfiable.Thus,
two predicates ğ‘0:ğ‘¥â‰¤0 andğ‘1:ğ‘¥â‰¤1 are generated by applying
R-Intp on ğœ‹1, and then the algorithm re-explores the ART from
theinitialstate ğ‘ 0.Thereafter,byreachabilityanalysis,weobtain
that the predicate set of state ğ‘ 2isğ‘ğ‘ 2={ğ‘0,ğ‘1}and the reachable
regionisğ‘Ÿğ‘ 2=Â¬(ğ‘¥1â‰¤0)âˆ§ğ‘¥1â‰¤1.Therefore,thestate ğ‘ 3isunreach-
ablesincethetransitionformula Â¬(ğ‘¥1<3)violatesğ‘Ÿğ‘ 2.Similarly,
afterseveralroundsofabstraction-refinement,threereachability
interpolants ğ‘0:ğ‘¥â‰¤0,ğ‘1:ğ‘¥â‰¤1, andğ‘2:ğ‘¥â‰¤3 are generated.
All the error locations in this ART are unreachable. Hence, this
concurrentprogramissafew.r.t.theexpectedreachabilityproperty.
In the above verification process, the following facts can be
observed:
1)Due to the lack of predicates, the conditional branch ğ‘‘:
Â¬(ğ‘¥1<3)in pathğœ‹1is explored in the initial exploration.
Actually, ğ‘‘:Â¬(ğ‘¥1<3)inğœ‹1is infeasible since ğ‘¥1=1
atğ¿5. Thus, insufficient predicates may cause redundant
exploration.
2)When checking the feasibility of path ğœ‹1, the portion that
makesthepathformula ğœ‹1ğ‘“unsatisfiablemainlycomesfrom
the conditional branch ğ‘‘:Â¬(ğ‘¥1<3)orğµ:ğ‘¥1>4. Hence,
conditionalbranchisthekeypointtoavoidredundantex-
ploration.
3)With thread alternation, there are 4 conditional branches
departing from location ğ¿6. While, in sequential verification
tasks, each location in an ART departs at most 2 conditional
branches. Therefore, thread alternation makes the occur-
rence ofconditional branchmore frequent.
146ESEC/FSE â€™21, August 23Å›28, 2021,Athens,Greece JieSu,CongTian,andZhenhua Duan.
3.2 Conditional Interpolation
Tosumup,thetraditionalabstraction-refinementiterationislowin
efficiencybecauseanumberofinfeasibleconditionalbranchesmay
be explored when predicates are insufficient. Particularly, when
verifyingconcurrentprograms,threadalternationwilllargelyin-
crease the frequency aconditional branch occursinthe ART. This
willaggravatetheredundancyexplorationproblem.Thissection
proposesconditionalinterpolationtoeffectivelypruneinfeasible
conditional branches throughout the verification.
Definition 3. (Conditional Interpolant,C-Intp): Let ğœ‹=âŸ¨ğ‘ 0,ğ‘’0,
...,ğ‘’ğ‘›âˆ’1,ğ‘ ğ‘›âŸ©beaprefixpathinanART.Supposethattherearemultiple
immediate conditional branches departing from state ğ‘ ğ‘›, and the
transitionscorrespondingtotheseconditionalbranchesformtheset
ğ¶ğ‘ ğ‘›. Then, the conditional interpolants at state ğ‘ ğ‘›is a setPğ‘ ğ‘›of
predicates,whereeach predicate ğ‘ğ‘âˆˆPğ‘ ğ‘›is computed by:
ğ‘ğ‘:=/braceleftbiggCraig(ğœ‹ğ‘“,ğ‘¡ğ‘“)ifğœ‹ğ‘“âˆ§ğ‘¡ğ‘“is unsatisfiable,
ğ‘¡ğ‘Ÿğ‘¢ğ‘’ otherwise.
Here,ğ‘¡ğ‘“is theSSAformulaoftransition ğ‘¡âˆˆğ¶ğ‘ ğ‘›.
Intuitively, a path that contains infeasible conditional branch is
aformofspuriouspathwhichdoesnotcorrespondtoanyconcrete
execution. By conditional interpolation,additional constraints are
introducedintothe reachableregionto eliminatecertainpaths.
Algorithm1 C-Intp(ğ‘ ğ‘›)
Input:The state ğ‘ ğ‘›that needto be explored.
1:Pğ‘ ğ‘›â†âˆ…;
2:/* Create the successor transitionset ğ¶ğ‘ ğ‘›ofğ‘ ğ‘›.*/
3:ğ¶ğ‘ ğ‘›:={ğ‘¡|ğ‘¡isconditional transitionat state ğ‘ ğ‘›};
4:/* Compute the conditional interpolants. */
5:forğ‘¡âˆˆğ¶ğ‘ ğ‘›do
6:/* Constructthe path ğœ‹fromğ‘ 0toğ‘ ğ‘›.*/
7:ğœ‹:=âŸ¨ğ‘ 0,ğ‘’0,...,ğ‘’ğ‘›âˆ’1,ğ‘ ğ‘›âŸ©;
8:ifğœ‹ğ‘“âˆ§ğ‘¡ğ‘“isunsatisfiable then
9:ğ‘ğ‘:=Craig(ğœ‹ğ‘“,ğ‘¡ğ‘“);
10:/* UpdatePğ‘ ğ‘›.*/
11:ifğ‘ğ‘â‰ ğ‘¡ğ‘Ÿğ‘¢ğ‘’ ğ‘ğ‘›ğ‘‘ ğ‘ ğ‘â‰ ğ‘“ğ‘ğ‘™ğ‘ ğ‘’then
12:Pğ‘ ğ‘›:=Pğ‘ ğ‘›âˆª{ğ‘ğ‘};
13:end if
14:end if
15:end for
16:/* Updatethe reachableregion.*/
17:P:=PâˆªPğ‘ ğ‘›;
18:ğ‘ğ‘ ğ‘›:=ğ‘ğ‘ ğ‘›âˆªPğ‘ ğ‘›;
19:ğ‘Ÿğ‘ ğ‘›:=/logicalandtext.1ğ‘˜
ğ‘–=1/dotaccğ‘ğ‘ ğ‘›
ğ‘–;
Algorithm 1shows the details of generating conditional inter-
polantsateachstate.Thisalgorithmiteratesovertheconditional
branches ğ‘¡âˆˆğ¶ğ‘ ğ‘›. If the conjunction of the path formula ğœ‹ğ‘“and
transitionformula ğ‘¡ğ‘“isunsatisfiable,anewconditionalinterpolant
ğ‘ğ‘is generated by applying the Craig interpolation to these two
parts.Thereafter,theglobalpredicateset P,andthereachablere-
gionğ‘Ÿğ‘ ğ‘›atstateğ‘ ğ‘›areupdatedaccordingly.Noticethat,different
from the existing abstraction-refinement approaches [ 14,18,26]
where predicates are generated only if error locations are reached,the proposed approach immediately computes sufficient amount of
predicatesateachchoicepoint.Therefore,moreattentioncanbe
paid to the explorationof feasible paths.
Reconsidertheconcurrentprogram example.c inFig.1(a),the
ART constructed by utilizing conditional interpolant is depicted in
Fig.3.Atstateğ‘ 2,thetransitionformula Â¬(ğ‘¥1<3)correspondingto
theconditionalbranch ğ‘‘makesthepathformula ğ‘¥0=0âˆ§ğ‘¥1=ğ‘¥0+1
unsatisfiable.Thus,anew interpolant ğ‘0:ğ‘¥â‰¤1canbegenerated
by applying C-Intp at this state. Thereafter, the reachable region
ğ‘Ÿğ‘ 2=ğ‘¡ğ‘Ÿğ‘¢ğ‘’isupdatedto ğ‘Ÿğ‘ 2=ğ‘¥1â‰¤1,andthestate ğ‘ 3isunreachable
sinceğ‘Ÿğ‘ 2âˆ§Â¬(ğ‘¥1<3)isunsatisfiable. Similarly,anewconditional
interpolant ğ‘1:ğ‘¥â‰¤3 is generated at state ğ‘ 10. Eventually, two
conditionalinterpolants, ğ‘0:ğ‘¥â‰¤1andğ‘1:ğ‘¥â‰¤3,aregenerated,
and a number of redundant states in the ART are avoided from
being explored.
Theorem1. (ConditionalUnreachable):Byutilizingconditional
interpolants,thestatesgeneratedalonginfeasibleconditionalbranches
areunreachable.
Proof.Letğœ‹=âŸ¨ğ‘ 0,ğ‘’0,...,ğ‘ ğ‘š,ğ‘’ğ‘š,ğ‘ ğ‘š+1,...,ğ‘ ğ‘›âŸ©beapath.Suppose
thattheformula ğ‘¡ğ‘šğ‘“w.r.t.thefirstconditionaltransition ğ‘¡ğ‘šmakes
thepathformula/logicalandtext.1ğ‘šâˆ’1
ğ‘=0ğ‘¡ğ‘ğ‘“âˆ§ğ‘¡ğ‘šğ‘“unsatisfiable.Fromline9ofAlgo-
rithm1,theconditionalinterpolant ğ‘ğ‘generatedatstate ğ‘ ğ‘šisğ‘ğ‘=
Craig(/logicalandtext.1ğ‘šâˆ’1
ğ‘=0ğ‘¡ğ‘ğ‘“,ğ‘¡ğ‘šğ‘“),andformula/dotaccğ‘ğ‘âˆ§ğ‘¡ğ‘šğ‘“isunsatisfiable.There-
fore, the new reachable region of ğ‘ ğ‘šisğ‘Ÿğ‘ ğ‘š=/logicalandtext.1ğ‘˜âˆ’1
ğ‘–=1/dotaccğ‘ğ‘ ğ‘š
ğ‘–âˆ§/dotaccğ‘ğ‘(we
assumethattheoriginalpredicateset ğ‘ğ‘ ğ‘šcontainsğ‘˜âˆ’1predicates).
According to the reachability analysis described in sub-section 2.3,
thestateğ‘ ğ‘š+1isunreachablesince ğ‘Ÿğ‘ ğ‘šâˆ§ğ‘¡ğ‘šğ‘“=/logicalandtext.1ğ‘˜âˆ’1
ğ‘–=1/dotaccğ‘ğ‘ ğ‘š
ğ‘–âˆ§/dotaccğ‘ğ‘âˆ§ğ‘¡ğ‘šğ‘“
isunsatisfiable.Hence,allthesuccessorstatesof ğ‘ ğ‘šareunreach-
able. â–¡
According to Theorem 1, infeasible conditional branches will
not be considered. Hence, the state-space to be explored will be
reducedcorrespondingly.
3.3 Simplifying InterpolationPaths
InAlgorithm 1,bothsatisfiabilitycheckingandCraiginterpolation
are time-consuming (i.e., lines 8 - 9). In order to generate condi-
tionalinterpolantsmoreefficiently,webuild theshortestconditional
interpolationformulachain tofurtherreducetheoverheadofthe
above two processes. The key idea is that at each choice point,
we trace back along the interpolation path and just preserve the
formulas that affectthe decision-making.
To start with, we use the example program in Fig. 1(a) to in-
tuitivelyshowtheapproach.Atstate ğ‘ 2inFig.3,weassumethat
theinterpolant ğ‘0:ğ‘¥â‰¤1hasalreadybeengenerated.Thereafter,
atthechoicepoint ğ‘ 10,weneedtoderivethevaluerangeofvari-
ableğ‘¥2to determine the feasibility of branch ğµ:ğ‘¥2>4. In its
prefix path formula ğœ‹â€²
ğ‘“:ğ‘¥0=0âˆ§ğ‘¥1=ğ‘¥0+1âˆ§ğ‘¥1<3âˆ§ğ‘¥2=
ğ‘¥1+2âˆ§ğ‘š0=ğ‘¥2âˆ’1, the formula ğ´:ğ‘š0=ğ‘¥2âˆ’1 does not affect
the evaluation of ğ‘¥2. Meanwhile, all the conditional branches in
ğœ‹â€²
ğ‘“are only used for guiding the direction of exploration. They are
redundantfortheinterpolationstep, thustheconditionalformula
ğ‘¥1<3 can be removed. Furthermore, the first two formulas are
redundant because we have already know that ğ‘¥1â‰¤1 at state ğ‘ 2
(i.e.,ğ‘¥0=0âˆ§ğ‘¥1=ğ‘¥0+1â†’ğ‘¥1â‰¤1).Therefore,wecaneasilyobtain
147Conditional Interpolation: MakingConcurrentProgram Verification More Effective ESEC/FSE â€™21, August 23Å›28, 2021,Athens,Greece
ğ‘ 0ğ¿0
ğ‘ 1
ğ¿1 ğ‘ 2ğ¿5 ğ‘¥1â‰¤1
ğ‘ 3ğ¿17
ğ‘ 4ğ¿18
ğ‘ 5ğ¿19
ğ‘ 6
ğ¿20
ğœ‹1ğ¶ğµ
ğ‘ 7
ğ¿21ğ·ğ´ğ‘‘
ğ‘ 8ğ¿9
ğ‘ 9ğ¿13
ğ‘ 10
ğ¿14Â¬(ğ‘¥2â‰¤1)âˆ§ğ‘¥2â‰¤3ğœ‹â€²
ğ‘ 11
ğ¿15ğœ‹
ğ‘ 12
ğ¿16ğœ‹2ğ¶ğµ
ğ‘ 13
ğ¿22ğ·ğ´ğ‘
ğ‘ 14
ğ¿10ğ´ğ‘ ğ‘ 15
ğ¿6ğ´ğ‘
ğ‘ 16
ğ¿2ğ‘¥0â‰¤1âˆ§ğ‘¥0â‰¤3
ğ‘ 17ğ¿6ğ‘¥1â‰¤1âˆ§ğ‘¥1â‰¤3
ğ‘ 18
ğ¿18
ğ‘ 19
ğ¿19
ğ‘ 20
ğ¿20
ğœ‹3ğ¶ğµ
ğ‘ 21
ğ¿21ğ·ğ‘‘
ğ‘ 22
ğ¿10ğ‘
ğ‘ 23ğ¿7
ğ‘ 24
ğ¿8
ğœ‹4ğ¶ğµ
ğ‘ 25
ğ¿23ğ·ğ‘
ğ‘ 26
ğ¿24ğ· ğ‘ 27ğ¿3
ğ‘ 28
ğ¿4
ğœ‹5ğ¶
ğ‘ 29ğ¿7ğ‘ğµğ´ğ‘¥=0
Figure3:TheARTconstructedbyutilizingtheconditionalinterpolation,wheretheblueformulaaroundastate ğ‘ isthereach-
able region ğ‘Ÿğ‘ ,andthegray nodes are regarded as redundant.
thatğ‘¥1â‰¤1âˆ§ğ‘¥2=ğ‘¥1+2â†’ğ‘¥2â‰¤3, and the reduced interpolation
pathformulais ğ‘¥1â‰¤1âˆ§ğ‘¥2=ğ‘¥1+2âˆ§ğ‘¥2>4.Essentially,theabove
approach preserves a reference chain of the decision-making vari-
ableğ‘¥2whichisusefulinreducingtheconsumptionofsatisfiability
checking andCraiginterpolation.
Now we formalize the above discussion. Formula ğœ™is called a
simpleformula ifitdoesnotconsistofdisjunctionorconjunctionof
otherformulas.Let Fğ‘bethesetofatomicformulas. ğœ™âˆˆFğ‘iscalled
anatomic formula if it contains a single variable, an assignment
formulaif it corresponds to an assignment instruction, and an
assumption formula ifitcorrespondsto anassumption instruction.
Definition 4. (Formula Affection Pair): Let Ağ‘ ğ‘”andAğ‘ ğ‘¢be the
set of assignment formulas and assumption formulas, respectively.
Forasimpleformula ğœ™,theformulaaffectionpair ğ‘ğœ™is
ğ‘ğœ™=/braceleftbigg(ğ‘ğ‘™(ğœ™),ğ‘ğ‘Ÿ(ğœ™))ifğœ™âˆˆAğ‘ ğ‘”
(ğ‘ğ‘(ğœ™),âˆ…)ifğœ™âˆˆAğ‘ ğ‘¢
Here,ğ‘ğ‘™(ğœ™)andğ‘ğ‘Ÿ(ğœ™)representthesetofvariablesontheleft
and right side of the assignment operator of ğœ™, respectively; and
ğ‘ğ‘(ğœ™)isthevariablesetof ğœ™.Asanexample,for ğœ™:ğ‘¥1=ğ‘¥0+1,ithas
ğ‘ğœ™=({ğ‘¥1},{ğ‘¥0}).Forconvenience,weuse ğ‘™ğ‘ğœ™andğ‘Ÿğ‘ğœ™torepresent
thefirstand thesecond element of ğ‘ğœ™. Intuitively, thevariablesin
ğ‘Ÿğ‘ğœ™affecttheevaluationofthevariablesin ğ‘™ğ‘ğœ™.Therefore,wesay
that formula ğœ™affects thevariables in ğ‘™ğ‘ğœ™, andğœ™is affected by the
variables in ğ‘Ÿğ‘ğœ™.
Forapairofsimpleformulas (ğœ™,ğœ“),wecancomputethevariables
inğœ™that(directlyorindirectly)affect ğœ“(e.g.,variable ğ‘¥1inğœ™:ğ‘¥2=
ğ‘¥1+1 affects the truth-value of ğœ“:ğ‘¥2>3). Formally, we use the
following functionto compute thesevariables.
Definition 5. (Affection Transitive Function): Given a simple
formula pair ğœ”=(ğœ™,ğœ“)whereğœ™Å‚orders-beforeÅ¾ ğœ“, the affection
transitivefunction ğ¼:ğ‘ğœ™Ã—ğ‘ğœ“â†’ğ‘ğœ™â€²is defined as:
ğ¼(ğ‘ğœ™,ğ‘ğœ“)
ğœ“âˆˆAğ‘ ğ‘¢=/braceleftBigg
((ğ‘™ğ‘ğœ“\ğ‘™ğ‘ğœ™)âˆªğ‘Ÿğ‘ğœ™,âˆ…)ifğ‘™ğ‘ğœ“âˆ©ğ‘™ğ‘ğœ™â‰ âˆ…1â—‹
(ğ‘™ğ‘ğœ“,âˆ…) ifğ‘™ğ‘ğœ“âˆ©ğ‘™ğ‘ğœ™=âˆ…2â—‹
ğ¼(ğ‘ğœ™,ğ‘ğœ“)
ğœ“âˆˆAğ‘ ğ‘”=/braceleftBigg
((ğ‘Ÿğ‘ğœ“\ğ‘™ğ‘ğœ™)âˆªğ‘Ÿğ‘ğœ™,âˆ…)ifğ‘Ÿğ‘ğœ“âˆ©ğ‘™ğ‘ğœ™â‰ âˆ…3â—‹
(ğ‘Ÿğ‘ğœ“,âˆ…) ifğ‘Ÿğ‘ğœ“âˆ©ğ‘™ğ‘ğœ™=âˆ…4â—‹Here,ğœ™â€²âˆˆAğ‘ ğ‘¢is an implicit assumption formula (i.e., ğ‘Ÿğ‘ğœ™â€²=âˆ…).
Andwesay ğœ™affectsğœ“ifthe rule 1â—‹or3â—‹is applied.
Infact,if ğœ™affectsğœ“,theabovefunctionremovesthecommon
variables they referenced in ğ‘™ğ‘ğœ™and addsvariables thataffect ğœ™to
maintainthereferencerelationofvariables.Asaresult,thevariables
inğ‘™ğ‘ğœ™â€²affectğœ“.Forexample,giventwoformulas ğœ™:ğ‘¥1=ğ‘¥0+1and
ğœ“:ğ‘¥1<3,weobtainthat ğ‘ğœ™=({ğ‘¥1},{ğ‘¥0})andğ‘ğœ“=({ğ‘¥1},âˆ…).By
applyingtherule 1â—‹(i.e.,ğœ™affectsğœ“),wehave ğ¼(ğ‘ğœ™,ğ‘ğœ“)=({ğ‘¥0},âˆ…).
Forasimpleformulachain ğœ”=âŸ¨ğœ™1,...,ğœ™ğ‘›âŸ©,wereverselytraverse
ğœ”toextract theformulas ğœ™â€²
ğ‘–inğœ”that affect ğœ™ğ‘›.Together with ğœ™ğ‘›,
aderivationchain ğœ”â€²=âŸ¨ğœ™â€²
1,...,ğœ™â€²ğ‘š,ğœ™ğ‘›âŸ©canbeobtained.Notethat
the order of the formulas in ğœ”â€²is the same as in ğœ”. Formally, ğœ”â€²is
aderivation chain ofğœ”if: 1)no variable affects ğœ™ğ‘›after a finite ap-
plicationoftheaffectiontransitivefunctionon ğœ”â€²(i.e.,ğ¼ğœ”â€²=(âˆ…,âˆ…),
whereğ¼ğœ”â€²=ğ¼ğ‘š(ğ‘ğœ™â€²
1,ğ¼ğ‘šâˆ’1(...,ğ¼1(ğ‘ğœ™â€²ğ‘š,ğ‘ğœ™ğ‘›)),and2)ğœ”â€²doesnotcon-
tainanyno-effectformula(i.e.,onlytherules 1â—‹and3â—‹areapplied
inğ¼ğœ”â€²). It is emphasized that the formulas corresponding to non-
deterministic statements (e.g., intğ‘¥=__VERIFIER_nodet_int ();)
areğ‘¡ğ‘Ÿğ‘¢ğ‘’.Thatis,itispossiblethatwecannotfindaderivationchain
ğœ”â€²ofğœ”that satisfies ğ¼ğœ”â€²=(âˆ…,âˆ…). In addition, for easily tracking
the reference relation of variables, the derivation of ğ¼ğœ”â€²relies on
relatively simple paths, whereas the paths that need to analyze
complex structures (e.g.,pointers) are ignoredconservatively.
Conceptually,theapproachofconstructingaderivationchain ğœ”â€²
â€˜slicesâ€™ [24]the formula chain ğœ”.That is,ğœ”â€²containsthe formulas
thataffect ğœ™ğ‘›.Nevertheless,interpolationwith ğœ”â€²isnotefficient
enough. For example, in Fig. 3, the derivation chain of ğœ”=âŸ¨ğ‘¥0=
0,ğ‘¥1=ğ‘¥0+1,ğ‘¥1<3,ğ‘¥2=ğ‘¥1+2,ğ‘š0=ğ‘¥2âˆ’1,ğ‘¥2>4âŸ©corresponding
totheprefixpath ğœ‹atstateğ‘ 11isğœ”â€²=âŸ¨ğ‘¥1<3,ğ‘¥2=ğ‘¥1+2,ğ‘¥2>4âŸ©,
wheretheassumptionformula ğ‘¥1<3isuselessforinterpolation
since it is just for guiding the direction of exploration. Further, the
conditionalinterpolant ğ‘0:ğ‘¥â‰¤1atstate ğ‘ 2isnotfullyusedinthe
derivationchain.Asamatteroffact, âŸ¨ğ‘¥1â‰¤1,ğ‘¥2=ğ‘¥1+2,ğ‘¥2>4âŸ©
is enough for the interpolation. With this in mind, the shortest
conditionalinterpolationformulachain isdefined.
Definition6. (TheShortestConditionalInterpolationFormula
Chain):Let ğœ‹â€²=âŸ¨ğ‘ 0,ğ‘’0,...,ğ‘ ğ‘—âŸ©beafeasibleprefixof ğœ‹=âŸ¨ğ‘ 0,ğ‘’0,...,ğ‘ ğ‘—,
ğ‘’ğ‘—,ğ‘ ğ‘—+1,...,ğ‘ ğ‘›âŸ©,ğ‘¡ğ‘—ğ‘“be the assumption formula corresponding to the
conditional branch ğ‘’ğ‘—, andFğ‘={/dotaccğ‘ğ‘ ğ‘–ğ‘|ğ‘ğ‘ ğ‘–ğ‘âˆˆğ‘ğ‘ ğ‘–âˆ©Fğ‘,0â‰¤ğ‘–â‰¤ğ‘—}
148ESEC/FSE â€™21, August 23Å›28, 2021,Athens,Greece JieSu,CongTian,andZhenhua Duan.
be the atomic formula set of conditional interpolants along ğœ‹â€². By
combiningthesetFğ‘andformulasin ğœ‹â€²
ğ‘“,weobtaintheformulachain
ğœ”=âŸ¨/dotaccğ‘ğ‘ 0ğ‘,ğ‘¡0ğ‘“,/dotaccğ‘ğ‘ 1ğ‘,...,ğ‘¡ğ‘—âˆ’1ğ‘“,/dotaccğ‘ğ‘ ğ‘—
ğ‘,ğ‘¡ğ‘—ğ‘“âŸ©.ğœ”â€²is the shortest conditional
interpolationformulachain of ğœ”if:
1)ğœ”â€²is aderivationchain,
2)ğœ”â€²doesnotcontainanyassumptionformulathatoccursin ğœ‹â€²,
3)any variable in ğœ”â€²corresponds to one atomic formula at most.
Algorithm2 SimplifyIntpPath( ğ‘ ğ‘›,ğ‘¡ğ‘›)
Input:An abstract state ğ‘ ğ‘›, and the conditional transition ğ‘¡ğ‘›atğ‘ ğ‘›.
Output: Theprefixformula ğœ‹â€²â€²
ğ‘“oftheshortestconditionalinter-
polation formula chain ğœ”â€².
1:Fğ‘‘â†âˆ…;
2:/* Buildthe pathfrom ğ‘ 0toğ‘ ğ‘›.*/
3:ğœ‹:=âŸ¨ğ‘ 0,ğ‘’0,...,ğ‘’ğ‘›âˆ’1,ğ‘ ğ‘›âŸ©;
4:/* Constructthe formula chain.*/
5:Fğ‘:={/dotaccğ‘ğ‘ ğ‘–ğ‘|ğ‘ğ‘ ğ‘–ğ‘âˆˆğ‘ğ‘ ğ‘–âˆ©Fğ‘,0â‰¤ğ‘–â‰¤ğ‘›};
6:ğœ”:=âŸ¨/dotaccğ‘ğ‘ 0ğ‘,ğ‘¡0ğ‘“,...,ğ‘¡ğ‘›âˆ’1ğ‘“,/dotaccğ‘ğ‘ ğ‘›ğ‘,ğ‘¡ğ‘›ğ‘“âŸ©;
7:/* Number eachformula ğœ™inğœ”for convenience.*/
8:ğœ”:=âŸ¨ğœ™1,...,ğœ™2ğ‘›,ğœ™2ğ‘›+1,ğœ™2ğ‘›+2âŸ©;
9:/* Generate the shortest C-Intpformula chain ğœ”â€².*/
10:ğ‘ğœ™â€²:=ğ‘ğœ™2ğ‘›+2;
11:for(ğ‘–:=2ğ‘›+1;ğ‘–>0;ğ‘–:=ğ‘–âˆ’1)do
12:ifğ‘™ğ‘ğœ™â€²=âˆ…ğ‘ğ‘›ğ‘‘ ğ‘Ÿğ‘ğœ™â€²=âˆ…then
13:break
14:end if
15:ifğœ™ğ‘–âˆ‰Ağ‘ ğ‘¢\Fğ‘then
16:/* Remove redundant C-Intpformulas. */
17:Fğ‘‘:=Fğ‘‘\{ğœ™|ğœ™âˆˆFğ‘‘âˆ©Fğ‘ğ‘ğ‘›ğ‘‘ ğ‘™ğ‘ğœ™âˆ©ğ‘™ğ‘ğœ™ğ‘–â‰ âˆ…};
18:/* Backwardderivation. */
19:ğ‘ğœ™â€²:=ğ¼(ğ‘ğœ™ğ‘–,ğ‘ğœ™â€²);
20:ifusedrule 1â—‹or3â—‹then
21:Fğ‘‘:=Fğ‘‘âˆª{ğœ™ğ‘–};
22:end if
23:end if
24:end for
25:ifğ‘™ğ‘ğœ™â€²=âˆ…ğ‘ğ‘›ğ‘‘ ğ‘Ÿğ‘ğœ™â€²=âˆ…then
26:/* Sortformulas in Fğ‘‘inthe order as they occur in ğœ”.*/
27:ğœ”â€²:=âŸ¨ğœ™â€²
1,...,ğœ™â€²ğ‘š,ğ‘¡ğ‘›ğ‘“âŸ©;
28:else
29:/* Existnon-deterministic variable.*/
30:ğœ”â€²:=âŸ¨ğ‘¡ğ‘Ÿğ‘¢ğ‘’âŸ©;
31:end if
32:ğœ‹â€²â€²
ğ‘“=/logicalandtext.1ğ‘š
ğ‘–=0ğœ™â€²
ğ‘–;
33:returnğœ‹â€²â€²
ğ‘“;
The above definition ensures that ğœ”â€²contains the core formulas
that affect the decision-making. Meanwhile, all the assumption
formulas in ğœ‹â€²which are unnecessary for the interpolation are
removed.Theredundantatomicformulas(mostofthemarethefor-
mulas corresponding to conditional interpolants) are also removed.
Different from predicate-based slicing [ 23] that uses predicates
asâ€˜indicatorsâ€™forprogramstatementselection,conditionalinter-
polants, as constraints of variables, are directly involved in the
construction offormula chain.In Algorithm 2, we build the initial interpolation chain ğœ”and
construct the shortest C-Intp formula chain ğœ”â€². Thereafter, the
path formula ğœ‹ğ‘“in lines 8 - 9 of Algorithm 1is replaced by the
global formula ğœ‹â€²â€²
ğ‘“. To generate ğœ”â€², we remove the formulas that
are redundant forthe interpolation (i.e., lines 15- 17) and search
the formulas ğœ™ğ‘–that affect ğ‘¡ğ‘›ğ‘“. After that, if a complete variable
referencechainisbuilt, ğœ”â€²couldbereconstructedbysortingthe
formulas inFğ‘‘in the orderas they occur in ğœ”and adding the last
conditional formula ğ‘¡ğ‘›ğ‘“. Note thatFğ‘‘preserves thecore formulas.
BacktotheexampleprograminFig. 1(a),atstate ğ‘ 10ofFig.3,we
haveFğ‘={/dotaccğ‘ğ‘ 2ğ‘:ğ‘¥1â‰¤1}andğœ”=âŸ¨ğ‘¥0=0,ğ‘¥1=ğ‘¥0+1,ğ‘¥1â‰¤1,ğ‘¥1<
3,ğ‘¥2=ğ‘¥1+2,ğ‘š0=ğ‘¥2âˆ’1,ğ‘¥2>4âŸ©. By applying rules 2â—‹and1â—‹, it
hasFğ‘‘={ğ‘¥2=ğ‘¥1+2}andğ‘ğœ™â€²=({ğ‘¥1},âˆ…).Thenweskiptheuseless
assumption formula ğ‘¥1<3 and apply rule 1â—‹again, the shortest
conditional interpolation chain ğœ”â€²=âŸ¨ğ‘¥1â‰¤1,ğ‘¥2=ğ‘¥1+2,ğ‘¥2>4âŸ©
is obtained and ğœ‹â€²â€²
ğ‘“=ğ‘¥1â‰¤1âˆ§ğ‘¥2=ğ‘¥1+2. Thereafter, by applying
Craig(ğœ‹â€²â€²
ğ‘“,ğ‘¥2>4), a new conditional interpolant ğ‘1:ğ‘¥â‰¤3 is
generated. Compared with the interpolation chain ğœ”, the length of
the newchain ğœ”â€²isshortenedbyhalf.
3.4 Verification with Conditional Interpolation
Nowweshowhowthereachabilityinterpolationandconditional
interpolation work togetherto effectively verify reachabilityprop-
ertiesofconcurrentprograms.
Start
Inputğ‘ƒ
Buildğºğ‘ƒ
Unwindğºğ‘ƒ,
Buildğ´ğ‘ƒ:(S,E)
exist new
stateğ‘ Safeproduce reachable state ğ‘ â€²,
addğ‘ â€²inS
explore state
ğ‘ =(ğ‘™,ğ‘,ğ‘)R-Intpğ‘ is
coverd
computeconditional
interpolants and update
simplifyinterpolation
path
ğ‘™is an
error loc.spurioushave cond.
braches
UnsafeNo
YesNo
Yes
YesYes
NoYesNo
No
Figure 4: The verification flowchart that combines the con-
ditional interpolation and reachability interpolation. The
parts in red dashed rectangle is the proposed C-Intp ap-
proach.
As shown in Fig. 4, the verification process of a concurrent pro-
gramğ‘ƒstarts from the construction of ğºğ‘ƒ. Then, through unwind-
ing the CFG ğºğ‘ƒfrom the initial state ğ‘ 0=(ğ¿0,âˆ’,âˆ…), an ART ğ´ğ‘ƒ
149Conditional Interpolation: MakingConcurrentProgram Verification More Effective ESEC/FSE â€™21, August 23Å›28, 2021,Athens,Greece
Table 1:ConcurrentBenchmark
No.Packages Files#KLOC
1goblint-regression 5245.1
2ldv-linux-3.14-races 770.3
3ldv-races 1221.1
4pthread 3836.3
5pthread-atomic 118.7
6pthread-C-DAC 45.5
7pthread-complex 59.2
8pthread-divine 1613.7
9pthread-driver-races 21147.3
10pthread-ext 4936.7
11pthread-lit 119.0
12pthread-nondet 64.3
13pthread-wmm 898768.7
Total 11301175.9Table 2:ExperimentalResults
No.R InterpChecker R+C
#Cor.#Inc.#Unk.#Cor.#Inc.#Unk.#Cor.#Inc.#Unk.
11051 0052 1051
2007007007
311108221110
411027 902911027
5911128911
6103103103
7005005005
84210 4210 4210
9180300212100
1015331 604315232
113170011 317
12204006204
13353 0545471 0427545 0353
Total 428 8694500 6624623 7500
ğ‘…ğ‘£ğ‘’ğ‘Ÿğ‘– 37.88% 44.25% 55.13%
isconstructedgradually.Duringtheunwindingprocess,ifanew
stateğ‘ =(ğ‘™,ğ‘,ğ‘)is located at an error location, then a counterex-
ample path ğœ‹=âŸ¨ğ‘ 0,ğ‘’0,...,ğ‘ âŸ©is constructed from the initial state ğ‘ 0.
Ifthiscounterexampleisnotspurious,weconcludethatthecon-
current program ğ‘ƒviolates the reachability property. Otherwise,
the R-Intp will be performed on path ğœ‹to generate reachability
interpolants.Ifstate ğ‘ hasimmediateconditionalbranches,thenthe
shortestconditional interpolation formula chain ğœ”â€²isconstructed
by simplifying the interpolation path. The conditional interpolants
and reachable region are generated and updated respectively by
utilizingğœ”â€².Subsequently,ifstate ğ‘ iscoveredbysomestateswhich
are visited previously, then we do not need to explore its succes-
sors.Otherwise,thereachablesuccessorsofstate ğ‘ aregenerated.
Theabove explorationstepswill stop if:1) no new state shouldbe
explored,or2)areal counterexample isfound.
Theabstract modelconstructed throughthe aboveverification
process is conservative, i.e., the property is proved when the verifi-
cationprocessterminatesandnoerrorpathisfound.Whenitgives
the â€˜Unsafeâ€™ answer, a real counterexample is returned. Otherwise,
itgivestheâ€˜Safeâ€™answer,andtheconstructedARTformsaproof
ofthe reachabilityproperty.
4 EXPERIMENTS
Wehaveimplementedtheproposedconditionalinterpolationontop
of the open-source model checker CPAchecker [ 2], which supports
thereachabilityinterpolationaidedCEGARalgorithm.CPAchecker
provides an efficient analysis frameworkfor program verification,
and our tool augments it with the proposed conditional interpo-
lation. The SMT solver MathSAT5 [ 6] is employed to efficiently
compute the Craig interpolants and perform satisfiability checking.
Meanwhile, cartesian abstraction [ 1] (SBE configuration) is applied
to compute the reachableregionofeachstate.
The concurrency track of SV-COMP1is adopted as the bench-
mark for evaluating our approach. The properties that a task need
tobeverifiedarespecifiedinthetask-definitionfile(i.e.,intheform
1https://github.com/sosy-lab/sv-benchmarks/tree/master/cof Å‚*.ymlÅ¾). There are 13 packages with totally 1251 verification
tasks in this benchmark where 1130 of them are used for reachabil-
ity property verification. As shown in Tab. 1, the second column
presentsthenameofeachpackage,thethirdcolumndenotesthe
amountoftheprogramsineachpackage,andthefourthcolumn
givesthetotallinesofcodeineachpackage.Alltheexperimentsare
performedonaserverrunningtheUbuntu18.04LTSsystemwitha
2.6GHzCPUand735GBRAM.Wesetthetimeboundandmemory
limitationfor eachtaskto 15 minutesand14 GB, respectively.
Ourworkfocusesonthechallengeofprovingwhetheraconcur-
rentprogramsatisfiescertainreachabilityproperties,whilemost
of the tools (e.g., the gold medal winner Lazy-CSeq [ 19]) in the
latestSV-COMParebugfinders.Toexaminetheimprovementof
verificationefficiencywithotherinterpolationapproaches,wecom-
pare the experimental results of the reachability interpolant aided
CEGAR algorithm (R), the work in [ 26] (InterpChecker), and the
conditional interpolant aided CEGAR approach (R+C), where R
and C represent R-Intp and C-Intp respectively. It is worth noting
that,alltheinterpolationapproachesareimplementedonthesame
abstraction-refinement basis (i.e., the CEGAR approach) and the
same verification framework (i.e., the CPAchecker). Therefore, the
followingexperimentseliminatetheinfluenceofotherfactorson
the validation efficiency of different interpolation methods. Mean-
while, the standard benchmarking tool BenchExec2is utilized to
carry out accurate and reliable experiments of the above interpola-
tionapproaches.OnaccountofthatBenchExeccouldnotcurrently
exhibit certain information (e.g., the number of explored states,
the length of interpolation path, etc.), we make statistics on the
intermediate results generatedbyBenchExec.
4.1 OverallExperimentalResults
Tab.2shows the overall experimental results. Column #Cor. rep-
resents thenumber of theprograms whose verificationresults are
correctlyreported.Column#Inc.givesthenumberoftheprograms
whoseverificationresultsareincorrectlyreported(i.e.,thereported
2https://github.com/sosy-lab/benchexec
150ESEC/FSE â€™21, August 23Å›28, 2021,Athens,Greece JieSu,CongTian,andZhenhua Duan.
Table 3:ComparisonsOverIdenticalPrograms that are CorrectlyReported
No.R InterpChecker R+C
#State #Refine #Time #State #Refine #Time #State #Refine #Time
1 - - - - - - - - -
2 - - - - - - - - -
310058.12 5.50 6.94s 8041.38 4.50 10.93s 7991.63 4.13 5.35s
491374.22 10.67 100.31s 55812.11 11.00 72.20s 74181.44 9.00 87.51s
54149.00 4.00 2.04s 4084.00 4.00 4.30s 2746.00 2.00 1.77s
673238.00 41.00 39.79s 69384.00 41.00 60.18s 19558.00 11.00 25.93s
7 - - - - - - - - -
820303.25 12.25 15.51s 19171.00 12.25 15.37s 20340.75 12.25 29.56s
9 - - - - - - - - -
104924.50 4.00 2.81s 7836.50 3.67 4.87s 3648.00 3.00 2.82s
11 - - - - - - - - -
12 - - - - - - - - -
13376728.06 17.60 159.73s 227296.66 14.95 137.21s 111002.03 3.1964.93s
#Avg.350848.76 16.93 150.38s 211960.37 14.47 129.09s 104786.40 3.4562.59s
resultsareinconsistentwiththetasklabels),includingfalseposi-
tivesand false negatives. Column #Unk.representsthe numberof
theprogramswithunknownverificationresults,i.e.,theresultsare
not given within the time bound, or there exist program structures
whichcannotbehandledbyCPAchecker. ğ‘…ğ‘£ğ‘’ğ‘Ÿğ‘–=ğ‘ğ‘ğ‘œğ‘Ÿ/ğ‘ğ‘¡ğ‘œğ‘¡ğ‘ğ‘™de-
notes the percentage of the programs that are correctly verified
within the time bound. Here, ğ‘ğ‘ğ‘œğ‘Ÿcorresponds to the values in
column#Cor.,and ğ‘ğ‘¡ğ‘œğ‘¡ğ‘ğ‘™=1130isthenumberofverificationtasks.
From the experimental results, we observe the following facts:
1)ComparedwithR, InterpChecker canimprovetheverifica-
tionefficiencyofconcurrentprograms,howevertheimprove-
menteffectislimited(only 6.37%).
2) R+Cisthemostefficientapproach.ComparedwithR,more
concurrent programs (17.26%) could be verified by using the
conditional interpolants.
Whenverifyingaconcurrentprogram, InterpChecker generates
predicates only when it reaches error locations. If the predicates
areinsufficient,thereachableregionoftheabstractstateinanART
is not precise enough to rule out infeasible paths. Whereas, our
approach eagerly computes the conditional interpolants at each
choice point, so that the process of generating predicates does not
needtobedelayeduntilspuriouscounterexamplesarefound.Thus,
asufficient amountof predicatescan be generatedefficiently, and
more attention can be paid to the analysisoffeasible paths.
In Tab.2, only a few number of packages show that the R+C
approachverifiesmoreprogramsthanothers.Thereasonsareas
follows:1)Someofthepackages,e.g.packagespthread-C-DACand
pthread-complex,onlycontainafewnumberofprograms.Thus,the
improvementeffectof R+Conthenumberofverifiedprograms
may not significant. 2) Many programs in the first 12 packages
cannot becorrectly handledby CPAchecker. Hence,we select 380
identicalprograms to make performance comparison more clear.
4.2 ComparisonsofCommonly andCorrectly
ReportedPrograms
Nowwe present theexperimentalresults on the 380 identicalpro-
grams which are correctly reported by the three approaches. InTab.3, the column #State indicatesthe average numberof explored
states, the column #Refine denotes the average times of performed
refinement, the column #Timerepresents the average verification
time, and the row #Avg. contains the average values of the three
evaluationindexesonthe380correctlyverifiedprograms.Thesym-
bolâ€˜-â€™inthistableindicatesthatnoidenticalprogramsarecorrectly
reported by these three approaches, and bold values represent bet-
terresults.Fig. 5clearlydepictsthequantileplotoftheseresults,
where x-axisdenotes the order ofthese results on thecorrespond-
ing evaluation index, and y-axis represents the time or memory
consumption. From Tab. 3andFig.5we can observe that:
1)Compared with R, our approach runs 62.59s on average,
whichis87.79sfasterthanthatofR,andtheaveragenumber
oftheexploredstatesandrefinementtimesarereducedto
29.87%and20.38%,respectively.
2)Comparedwith InterpChecker ,R+Cis66.50sfasteronaver-
age,and ourapproachperformsbetteron5 packages. Mean-
while,theaveragenumberoftheexploredstatesarereduced
to 49.44%.
3)According to the area under each curve, R+Cneeds less
time andmemory onthese380programs.
We also observe that R+Cperforms worse than InterpChecker
on package 4 and 8. The main reason for this anomaly is that
predicates are excessively computed, which makes too many predi-
catesconsideredwhencomputingthereachableregionofsuccessor
states.
4.3 The Effect ofPathSimplification on the
Speed ofC-Intp
We also investigate the effect of simplifying the interpolation path
on the speed of C-Intp. In Tab. 4,R+Câˆ—represents the C-Intp
with no path simplification (i.e., at each choice point, we build a
full formula chain from the root state). The column #Time here
onlydenotestheaveragetimecostontheconditionalinterpolation
whichdoesnottakeotheroverheadsintoaccount.Column#Len.
indicates the average length ofinterpolation path. Notethat, the
lengthoftheprefixesintroducedbyunusedsymbolsinheaderfiles
151Conditional Interpolation: MakingConcurrentProgram Verification More Effective ESEC/FSE â€™21, August 23Å›28, 2021,Athens,Greece
100 200 300 4000200400600800
ğ‘›thfastest correct resultcputime(s)R
InterpChecker
R+C
100 200 300 4005001,0001,5002,0002,500
ğ‘›thsmallest correct resultmemory (MB)R
InterpChecker
R+C
Figure 5:The quantileplot oftimeandmemory consumptioninlinear scale.
isnot included. Row#Avg. contains theaveragevaluesof the two
evaluation indexes on the 440 identical programs that are correctly
reported.
Table 4: Comparisons of the Effects of Path Simplification
on Time Consumption & LengthReduction
No.R+Câˆ—R+C
#Time #Len.#Time #Len.
1 - - --
2 - - --
36.42s 37.30 1.27s 1.85
43.27s 31.27 0.78s 2.34
510.94s 29.73 3.76s 1.72
64.30s107.65 1.05s 8.91
7 - - --
84.88s 39.68 1.31s 5.39
930.05s 118.56 3.00s 5.67
108.90s 42.51 1.52s 1.87
110.81s 20.12 0.49s 1.76
124.20s 50.52 1.22s 2.00
1355.16s 78.18 4.86s 2.40
#Avg.48.02s 75.02 4.37s 2.55
Averagely, R+Câˆ—andR+Cexplores 170108.53 and 136384.58
states, and consumes 133.81s and 76.09s, respectively. Compared
withR+Câˆ—,pathsimplificationmakes R+Capproachabout9.99
times faster, and the average length of interpolation path are re-
duced to 3.40%. In other words, only a small portion of formulas in
apathneedstobeconsideredwhenperformingC-Intp.Asanaside,
with no path simplification (i.e., use R+Câˆ—), only 450 programs
canbeverified.Therefore,pathlengthisoneofthemajorfactors
in limiting the performance of C-Intp. In addition, over the 423
identicalprograms whicharecorrectlyreportedbyR,R +Câˆ—,and
R+C, 26.29, 42.27, and 50.47 predicates are generated averagely. It
meansthat,morepredicatescouldbegeneratedbyC-Intpapproach
for pruning redundantbranches.
4.4 OtherExperiments
The above experiments are carried out on the set of concurrent
programs,andwealsoappliedtheC-Intpapproachonsequentialprogram verification tasks. We select 13 packages with totally 2728
sequential programs which constitute the subcategory Å‚Device
DriversLinux64Å¾ofSV-COMP,andallthesetupsarethesameas
the previous experiments.
Inthisexperiment,R, InterpChecker andR+Cverify1158,1164
and1172programsrespectively.Tab. 5showsthesequentialbench-
mark and the comparison results over the 1086 commonly and
correctlyreportedprograms,andboldvaluesrepresentbetterre-
sults.Wenoticethat,although R+Ccanverifymoreprograms,the
improvement onsequentialverification tasksisnot significant.
The main reason for this phenomenon is that sequential pro-
gramsare not effected bythread alternation.Hence, there are less
conditionalbranchesandstatesforconditionalinterpolation.Mean-
while, theoverhead oftheC-Intpsometimes does notbalancethe
pruning gains. This situation is more common in sequential pro-
gramswithfewer conditional branches.
5 RELATED WORK
Thestate-spaceexplosionproblem,aggravatedbythreadalterna-
tion,is one ofthe mostsignificantchallengesin program verifica-
tion. How to alleviate the exponential growth of state-space has
beenahot-spottopic.Inthepastdecades,manyefficienttechniques
have been emergedto moderatethis problem.
5.1 AbstractionRefinementBasedMethods
Abstract interpretation technique [ 10], specifically predicate ab-
straction [ 14,18], is efficient in reducing the state-space of verifica-
tion tasks. The work presented in [ 17] utilizes Craig interpolation
to effectively construct a parsimonious abstraction. Infeasible error
traces(i.e.,cannotbeconcretized)willberefutedbythisabstrac-
tion. The approach in [ 18] continuously builds and refines a single
abstract model on demand, and after several rounds of abstract-
check-refinesteps,asetofinterpolantsisgeneratedaccordingto
some spurious counterexamples. Whereas, in our approach, the
conditional interpolants can be generated before error locations
arereached.Ifaninfeasibleconditionalbranchisdiscovered,the
newly generated conditional interpolant prunes it automatically,
andmoreattentioncanbepaidtofeasiblepaths.Therefore,different
from most of the abstraction-refinement approaches that generate
only a few number of interpolants at the end of each iteration,
152ESEC/FSE â€™21, August 23Å›28, 2021,Athens,Greece JieSu,CongTian,andZhenhua Duan.
Table 5:SequentialBenchmark& ComparisonsOverIdenticalPrograms that are CorrectlyReported
No.Packages Files#KLOCR InterpChecker R+C
#State #Refine #Time #State #Refine #Time #State #Refine #Time
1ldv-challenges 2015925.2 203624.00 16.00 306.06s 52187.00 9.00 56.06s 53703.00 9.0050.89s
2ldv-commit-tester 54479.2 50996.53 2.4216.13s 53893.32 2.32 57.67s 54620.63 2.26 21.43s
3ldv-consumption 1632773.3 163008.25 4.00 63.28s 138388.88 4.25119.34s 138503.75 3.25 51.99s
4ldv-linux-3.0 39514.7 188877.36 10.00 51.67s 159502.91 9.36189.83s 150436.91 7.00 63.11s
5ldv-linux-3.12-rc1 40487.0 50033.00 8.50 21.17s 51339.00 9.50 59.15s 203169.50 9.50148.26s
6ldv-linux-3.14 3317802.9 - - - - - - - - -
7ldv-linux-3.16-rc1 1582172.8 143412.91 3.2755.73s 158157.00 3.82160.71s 268007.82 2.73160.99s
8ldv-linux-3.4-simple 11594899.7 21265.44 0.89 9.26s 16075.52 0.87 15.50s 20987.10 0.70 8.95s
9ldv-linux-3.7.3 11252.0 45573.00 9.00 26.22s 30326.00 7.00 31.78s 30324.00 7.0019.26s
10ldv-linux-4.0-rc1-mav 982141.0 235852.00 33.67 292.41s 74822.00 16.33 116.09s 61853.67 13.67 71.19s
11ldv-linux-4.2-rc1 42610112.4 143838.50 7.00 62.78s 67948.33 6.67 73.56s 102522.17 5.00 59.97s
12ldv-validator-v0.6 21217.6 43326.50 9.50 54.94s 37485.50 8.00 39.86s 52146.50 9.50 56.65s
13ldv-validator-v0.8 27271.0 83377.00 16.00 66.12s 60665.50 14.00 67.50s 74311.00 15.00 75.13s
Total||#Avg. 272838048.8 27432.96 1.2612.25s 21211.81 1.18 21.11s 27347.64 0.97 12.54s
ourapproachcaneffectivelygeneratesufficientamountofcondi-
tional interpolantswithinasingleroundof iteration. Thus,many
infeasibleconditional branches are avoidedfrom being explored.
5.2 InterpolationBasedMethods
The work proposed in [ 20] utilizes interpolants computed by Craig
interpolationtoobtainacompletemethodforfinite-statereacha-
bility analysis. Through combining lazy abstraction paradigm [ 18],
an extension work [ 21] applies decision procedure to individual
paths leading to error locations. This makes it possible to verify
infinite-state sequentialprograms.Themostrelatedworktoours
isgivenin[ 4]whichintegrateslazy abstractionand interpolation
based refinement into an explicit-value analysis. This approach
determines a location-specific precision that is strong enough to
refute the false paths in the future explorations. The follow-up
work[26]integratestwokindsofinterpolants,namelyuniversal
safetyinterpolantsandexistentialerrorinterpolants,intotheCE-
GARapproachtodeterminewhetherallpathsemanatingfroma
state are safe or not. However, the above two approaches generate
interpolants only when counterexamples are found. They rarely
considerthe infeasibleconditional branches that occur frequently
inconcurrentvalidationtasks.Thus,whenpredicatesareinsuffi-
cientorsomeinfeasiblepathsactuallycannotreacherrorlocations,
redundantstateswillbeexplored.Asshownintheexperimental
results, the universal safety interpolants and existential error in-
terpolantshavelimitedperformanceimprovementinconcurrent
programverificationtasks.Incontrast,ourapproachperformscon-
ditional interpolation at conditional branches, which effectively
avoids the exploration of a large number of infeasible paths in
anART.Hence,ourapproachimprovesthescalabilityofCEGAR
algorithm inconcurrentvalidation tasks.
5.3 BoundedModel Checking
Based on the observation that many bugs in real applications have
beenfoundtobeshallow,boundedmodelchecking[ 5,19,28]which
limits the search depthis oftenadopted.ESBMC[ 9] combines sym-
bolicmodelcheckingwithexplicitstate-spaceexploration.Ittra-
verses a reachability tree derived from the given system, and callstheSMTsolverwheneveraleafnodeisreached.Incontrast,ourap-
proach calls SMT solver when it finds a counterexample or reaches
the states that have conditional branch successor. To eliminate the
uncertainty of thread alternation, MU-CSeq [ 27] and Lazy-CSeq
[19] translate concurrent programs into equivalent sequential pro-
grams, and bound the times of context switches between different
threads. Then, the converted programs are verified by the tools for
verifying sequential programs. However, all of these approaches
can only guarantee the safety property within a given analysis
bound. That means the verification result is imprecise when these
approaches give â€˜Safeâ€™ answer. While, our verification process will
be stopped only when a real counterexample is found or no new
statecanbegenerated.Theconstructedabstractmodelisconser-
vative, i.e., the property is proved when the verification process
terminatesandnoerrorpathisfound.Whenourapproachgives
â€˜Safeâ€™ answer, the constructed ART forms a proof of a given verifi-
cation property.
5.4 OtherEffectiveTechniques
By focusing on selected aspects of semantics, program slicing tech-
nique[16,24]caneffectivelysimplifyprograms.Moststaticslicing
approachesutilizeflowgraphasthecoarseabstractprogrammodel,
which results in an imprecise program slice. In contrast, our ap-
proach slices the paths in ART, and the conditional interpolants
make the sliceof interpolation path more accurate. Different from
the predicate-based slicing[ 23] where predicatesdo not appear in
theconstructedpath,conditionalinterpolants,astheconstraintsof
variables, are directly involved in the process of path construction.
The newly generated interpolants along a path are closely related
to the conditional interpolants inthis path.
6 CONCLUSION & FUTUREWORK
Inthispaper,wefocusononeofthemostchallengingtaskofprov-
ing whether a concurrent program satisfies certain reachability
properties. At each choice point, we apply the proposed condi-
tional interpolation to avoid the exploration of infeasible condi-
tional branch. Compared with other interpolation approaches, the
proposedapproachcaneffectivelypruneextraconditionalbranches
153Conditional Interpolation: MakingConcurrentProgram Verification More Effective ESEC/FSE â€™21, August 23Å›28, 2021,Athens,Greece
and greatlyreduce the state-spacein concurrent verification tasks.
Experimental results show that more concurrent programs can be
verifiedwithinthegivenvalidationtime-limitbyapplyingcondi-
tionalinterpolation.
In the near future, we will further study other interpolation
approachestoimprovevalidationefficiency.Meanwhile,weplanto
integrate the partial-order reduction technique (POR) [ 15] into our
verification processto avoid the explorationofredundantpaths.
ACKNOWLEDGMENTS
ThisresearchissupportedbytheNationalKeyResearchandDe-
velopment Program of China with Grant No. 2018AAA0103202,
theNSFCwithGrantNo.61732013,andShaanxiKeyScienceand
TechnologyInnovationTeamProject withGrantNo. 2019TD-001.
Cong Tian isthe corresponding author.
REFERENCES
[1]Thomas Ball, Andreas Podelski, and Sriram K. Rajamani. 2001. Boolean and
Cartesian Abstraction for Model Checking C Programs. In Proceedings of the
7th International Conference on Tools and Algorithms for the Construction and
AnalysisofSystems (Genoa,Italy) (TACASâ€™01) .Springer-Verlag,Berlin,Heidelberg,
268Å›283. https://doi.org/10.1007/3-540-45319-9_19
[2]DirkBeyerandM.ErkanKeremoglu.2011. CPACHECKER:AToolforConfig-
urableSoftwareVerification.In Proceedingsofthe23rdInternationalConference
on Computer Aided Verification (Snowbird, UT) (CAVâ€™11). Springer-Verlag, Berlin,
Heidelberg, 184Å›190.
[3]DirkBeyer, M. Erkan Keremoglu,andPhilipp Wendler. 2010. Predicate Abstrac-
tionwithAdjustable-BlockEncoding.In Proceedingsofthe2010Conferenceon
FormalMethodsinComputer-AidedDesign (Lugano,Switzerland) (FMCADâ€™10) .
FMCADInc, Austin,Texas,189Å›198.
[4]DirkBeyerandStefanLÃ¶we.2013. Explicit-StateSoftwareModelCheckingBased
onCEGARandInterpolation.In Proceedingsofthe16thInternationalConferenceon
FundamentalApproachestoSoftwareEngineering (Rome,Italy) (FASEâ€™13) .Springer-
Verlag,Berlin,Heidelberg,146Å›162. https://doi.org/10.1007/978-3-642-37057-
1_11
[5]Armin Biere, Alessandro Cimatti, Edmund Clarke, Ofer Strichman, and Yunshan
Zhu. 2003. Bounded Model Checking. Advances in Computers 58 (12 2003), 117 Å›
148.https://doi.org/10.1016/s0065-2458(03)58003-2
[6]Alessandro Cimatti, Alberto Griggio, Bastiaan Joost Schaafsma, and Roberto
Sebastiani.2013. TheMathSAT5SMTSolver.In Proceedingsofthe19thInterna-
tional Conference on Tools and Algorithms for the Construction and Analysis of
Systems(Rome,Italy) (TACASâ€™13) .Springer-Verlag,Berlin,Heidelberg,93Å›107.
https://doi.org/10.1007/978-3-642-36742-7_7
[7]Edmund Clarke, Orna Grumberg, Somesh Jha, Yuan Lu, and Helmut Veith. 2003.
Counterexample-Guided Abstraction Refinement for Symbolic Model Checking.
J.ACM50,5 (Sept.2003),752Å›794. https://doi.org/10.1145/876638.876643
[8]Edmund M. Clarke, Orna Grumberg, Somesh Jha, Yuan Lu, and Helmut Veith.
2000. Counterexample-GuidedAbstractionRefinement.In Proceedingsofthe12th
International Conference on Computer Aided Verification (Chicago, IL, USA) (CAV
â€™00). Springer-Verlag, Berlin, Heidelberg, 154Å›169.
[9]LucasCordeiro,Jeremy Morse,Denis Nicole,and BerndFischer.2012. Context-
Bounded Model Checking with ESBMC 1.17. In Proceedings of the 18th Inter-
national Conference on Tools and Algorithms for the Construction and Analysis
of Systems (Tallinn, Estonia) (TACASâ€™12) . Springer-Verlag, Berlin, Heidelberg,
534Å›537. https://doi.org/10.1007/978-3-642-28756-5_42
[10]Patrick Cousot and Radhia Cousot. 1977. Abstract Interpretation: A Unified
Lattice Model for Static Analysis of Programs by Construction or Approxi-
mation of Fixpoints. In Proceedings of the 4th ACM SIGACT-SIGPLAN Sympo-
sium on Principles of Programming Languages (Los Angeles, California) (POPL
â€™77). Association for Computing Machinery, New York, NY, USA, 238Å›252.
https://doi.org/10.1145/512950.512973
[11]WilliamCraig.1957. ThreeusesoftheHerbrand-Gentzentheoreminrelating
modeltheoryandprooftheory. JournalofSymbolicLogic 22,3(sep1957),269Å›285.https://doi.org/10.2307/2963594
[12]Satyaki Das, David L. Dill, and Seungjoon Park. 1999. Experience with Predicate
Abstraction. In Proceedings of the 11th International Conference on Computer
AidedVerification (Trento,Italy) (CAVâ€™99) .Springer-Verlag,Berlin,Heidelberg,
160Å›171.
[13]JavierEsparza, Stefan Kiefer,andStefan Schwoon. 2006. AbstractionRefinement
with Craig Interpolation and Symbolic Pushdown Systems. In Proceedings of
the 12th International Conference on Tools and Algorithms for the Construction
andAnalysisofSystems (Vienna,Austria) (TACASâ€™06) .Springer-Verlag,Berlin,
Heidelberg, 489Å›503. https://doi.org/10.1007/11691372_35
[14]Cormac Flanagan and Shaz Qadeer. 2002. Predicate Abstraction for Software
Verification. In Proceedings of the 29th ACM SIGPLAN-SIGACT Symposium on
Principles of Programming Languages (Portland, Oregon) (POPL â€™02) . Association
for Computing Machinery, New York, NY, USA, 191Å›202. https://doi.org/10.
1145/503272.503291
[15]PatriceGodefroid,J.vanLeeuwen,J.Hartmanis,G.Goos,andPierreWolper.1996.
Partial-Order Methods for the Verification of Concurrent Systems: An Approach to
the State-ExplosionProblem . Springer-Verlag, Berlin, Heidelberg.
[16]Mark Harman and Robert Hierons. 2001. An overview of program slicing. Soft-
wareFocus 2,3 (2001), 85Å›92. https://doi.org/10.1002/swf.41
[17]Thomas A. Henzinger, Ranjit Jhala, Rupak Majumdar, and Kenneth L. McMillan.
2004. AbstractionsfromProofs.In Proceedingsofthe31stACMSIGPLAN-SIGACT
Symposium on Principles of Programming Languages (Venice, Italy) (POPL â€™04) .
Association for Computing Machinery, New York, NY, USA, 232Å›244. https:
//doi.org/10.1145/964001.964021
[18]Thomas A. Henzinger, Ranjit Jhala, Rupak Majumdar,and GrÃ©goire Sutre. 2002.
LazyAbstraction. SIGPLANNot. 37,1(Jan.2002),58Å›70. https://doi.org/10.1145/
565816.503279
[19]Omar Inverso, Truc L. Nguyen, Bernd Fischer, Salvatore La Torre, and Gen-
naro Parlato. 2015. Lazy-CSeq: A Context-Bounded Model Checking Tool for
Multi-ThreadedC-Programs.In Proceedingsofthe30thIEEE/ACMInternational
Conference on Automated Software Engineering (Lincoln, Nebraska) (ASE â€™15) .
IEEE Press,807Å›812. https://doi.org/10.1109/ASE.2015.108
[20]Kenneth L. McMillan. 2003. Interpolation and SAT-Based Model Checking. In
ComputerAidedVerification (Boulder,CO,USA) (CAVâ€™03).Springer-Verlag,Berlin,
Heidelberg, 1Å›13. https://doi.org/10.1007/978-3-540-45069-6_1
[21]KennethL.McMillan.2006. LazyAbstractionwithInterpolants.In Proceedings
of the 18th International Conference on Computer Aided Verification (Seattle, WA)
(CAVâ€™06). Springer-Verlag, Berlin, Heidelberg, 123Å›136. https://doi.org/10.1007/
11817963_14
[22]Stephan Merz. 2000. Model Checking: A Tutorial Overview. In Proceedings of
the 4th Summer School on Modeling and Verification of Parallel Processes (Nantes,
France)(MOVEP â€™00) . Springer-Verlag, Berlin, Heidelberg, 3Å›38. https://doi.org/
10.1007/3-540-45510-8_1
[23]Hyoung Seok Hong, Insup Lee, and Oleg Sokolsky. 2005. Abstract Slicing: A
NewApproachto ProgramSlicing Basedon AbstractInterpretationandModel
Checking. In Proceedings of the Fifth IEEE International Workshop on Source Code
Analysis and Manipulation (Budapest, Hungary) (SCAM â€™05) . IEEE Computer
Society, USA,25Å›34. https://doi.org/10.1109/SCAM.2005.2
[24]Josep Silva. 2012. A Vocabulary of Program Slicing-Based Techniques. ACM
Comput. Surv. 44, 3, Article 12 (June 2012), 41 pages. https://doi.org/10.1145/
2187671.2187674
[25]CongTian,ZhenhuaDuan,andZhaoDuan.2014. MakingCEGARMoreEfficient
inSoftwareModelChecking. IEEETransactionsonSoftwareEngineering 40,12
(2014), 1206Å›1223. https://doi.org/10.1109/TSE.2014.2357442
[26]CongTian,ZhaoDuan,ZhenhuaDuan,andC.-H.LukeOng.2017. MoreEffective
InterpolationsinSoftwareModelChecking.In Proceedingsofthe32ndIEEE/ACM
InternationalConferenceonAutomatedSoftwareEngineering (Urbana-Champaign,
IL,USA)(ASEâ€™17).IEEEPress,183Å›193. https://doi.org/10.1109/ase.2017.8115631
[27]Ermenegildo Tomasco, Omar Inverso, Bernd Fischer, Salvatore La Torre, and
Gennaro Parlato. 2014. MU-CSeq: Sequentialization of C Programs by Shared
Memory Unwindings. In Tools and Algorithms for the Construction and Analysis
ofSystems (Grenoble,France) (TACASâ€™14) .Springer-Verlag,Berlin,Heidelberg,
402Å›404. https://doi.org/10.1007/978-3-642-54862-8_30
[28]LiangzeYin,WeiDong,WanweiLiu,andJiWang.2020.OnSchedulingConstraint
Abstraction for Multi-Threaded Program Verification. IEEE Transactions on
Software Engineering 46, 5 (2020), 549Å›565. https://doi.org/10.1109/TSE.2018.
2864122
154