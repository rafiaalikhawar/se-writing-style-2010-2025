Demystifying Loops in Smart Contracts
Benjamin Mariano
bmariano@cs.utexas.edu
University of Texas at AustinYanju Chen
yanju@cs.ucsb.edu
University of California, Santa
BarbaraYu Feng
yufeng@cs.ucsb.edu
University of California, Santa
Barbara
Shuvendu K. Lahiri
shuvendu.lahiri@mircrosoft.com
Microsoft ResearchIsil Dillig
isil@cs.utexas.edu
University of Texas at Austin
ABSTRACT
This paper aims to shed light on how loops are used in smart con-
tracts. Towards this goal, we study various syntactic and semantic
characteristics of loops used in over 20,000 Solidity contracts de-
ployed on the Ethereum blockchain, with the goal of informing
future research on program analysis for smart contracts. Based on
ourfindings,weproposeasmalldomain-specificlanguage(DSL)
that canbe used tosummarize common loopingpatterns in Solid-
ity. To evaluate what percentage of smart contract loops can beexpressed in our proposed DSL, we also design and implement a
program synthesis toolchain called Solis that can synthesize loop
summariesinourDSL.Ourevaluationshowsthatatleast56%of
theanalyzedloopscanbesummarizedinourDSL,and81%ofthese
summaries are exactly equivalent to the original loop.
ACM Reference Format:
BenjaminMariano,YanjuChen,YuFeng,ShuvenduK.Lahiri,andIsilDillig.
2020.DemystifyingLoopsinSmartContracts.In 35thIEEE/ACMInterna-
tionalConferenceonAutomatedSoftwareEngineering(ASEâ€™20),September
21â€“25,2020,VirtualEvent,Australia. ACM,NewYork,NY,USA,13pages.
https://doi.org/10.1145/3324884.3416626
1 INTRODUCTION
Asprogramsthatrunonablockchain,smartcontractsenablemulti-
party transactions that involve the transfer of funds or other com-
modities. Due to their obvious security-critical nature, there has
beenaflurryofinterestâ€”bothinthesecurity,softwareengineering,andformalverificationcommunitiesâ€”indevelopingtechniquesforautomaticallycheckingthatsmartcontractsbehaveasexpected.Forexample,someofthesetechniqueslookforcertainpatterns,suchasre-entrancy, that are highly correlated with security vulnerabilities
in practice [ 20,34]. Other proposals aim for full functional correct-
ness and propose verification tools for checking smart contracts
against manually-written formal specifications [27, 30, 38, 40].
Despitenumerousdifferencesbetweenexistingcontractanalysis
techniques,acommonunifyingthemebehindthesetechniquesis
the assumption that loops occur rarely in smart contracts [ 40]. As
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACMmustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ASE â€™20, September 21â€“25, 2020, Virtual Event, Australia
Â© 2020 Association for Computing Machinery.
ACM ISBN 978-1-4503-6768-4/20/09...$15.00
https://doi.org/10.1145/3324884.3416626a result, most existing program analysis techniques in this space
brush aside the classical problem of loop invariant generation and
focus on challenges that are unique to smart contracts.
Thegoalofthispaperistostudyhowloopsareusedinsmart
contracts and examine how frequently they occur in practice. Our
main motivation behind this study is to guide and inform future
research on analysis techniques for smart contracts. Specifically,
we focus on Solidity, the most popular programming language
for smart contract development, and study over 20,000 Soliditycontracts deployed on the Ethereum blockchain. In addition to
evaluatingloopfrequency,wealsoinvestigateseveralinteresting
syntactic and semantic properties of smart contract loops. Our
primary goal in this study is to understand the nature of loops that
occurinsmartcontractssothatsubsequentresearchcandevelopsuitableabstractdomainsandotheranalysistechniquesformore
precise static reasoning about smart contracts.
As a first step towards achieving this goal, we implement a
basic static analysis to extract several interesting features of smart
contract loops. We then use the results of this analysis to clustersemantically similar loops and manually study the behavior ofdifferent clusters. Our manual investigation suggests that mostsmart contract loops can be summarized using a small domain-
specific language (DSL) with familiar functional operators, such as
map, fold, and zip.
Asanextsteptowardsprecisereasoningaboutsmartcontract
loops, we build a program synthesis toolchain for generating sum-
maries of Solidity loops in our proposed DSL. Our synthesizerperforms type-directed search over the DSL constructs and uses
properties of the loop body to significantly prune the search space
ofcandidatesummaries.Oncewegenerateacandidatesummary,
we then check for equivalence against the original Solidity loop
usinga(bounded)equivalencecheckerbuiltontopofRosette[ 44].
Wehaveimplementedoursmartcontractloopsummarization
techniqueinatoolcalledSolisandevaluateitonalargecollection
of Solidity loops. Our evaluation suggests that a majority of smart
contract loops can be summarized (either partially or precisely) in
our proposed DSL by leveraging program synthesis.
In summary, this paper makes the following contributions:
â€¢We perform an empirical study of loops in over 20,000 So-liditycontractsdeployedontheEthereumblockchainandstudy various syntactic and semantic properties of these
loops.Our studyshowsthathalf ofthecontracts withover
200 lines of code contain at least one loop and that a typical
contract contains one loop per 250 lines of Solidity code.
2622020 35th IEEE/ACM International Conference on Automated Software Engineering (ASE)
â€¢We cluster smart contract loops according to their semantic
featuresandmanuallyinvestigateeachclustertounderstand
common behaviors of Solidity loops.
â€¢Weuse the results fromour manual investigation todesign
a domain-specific language called Consul for summarizing
smart contract loops using familiar functional operators.
â€¢WeimplementaprogramsynthesistoolchaincalledSolis
for summarizing solidity loops in Consul, which uses type
informationandpropertiesoftheinputlooptoreducethe
space of candidate loop summaries that it needs to consider.
â€¢We perform an evaluation of our synthesizer on 1220 loops
and show that almost half of the loops can be precisely sum-
marized in our DSL using the proposed synthesis technique.
2 ASTUDYOFLOOPSINSMARTCONTRACTS
Inthissection,weprovidestatisticsaboutthefrequencyofloopsin
smartcontractsandreportonthedistributionofloopsaccording
to various features. To perform this study, we collected over 27,000
smart contracts from Etherscan and used the Slither static ana-
lyzer [12] to analyze their loops. In this section, we summarize our
findings for the 22,685 contracts that could be analyzed by Slither.1
2.1 Frequency of Loops
Since many program analyzers for smart contracts are based on
the assumption that loops are rare, we first study the frequency of
loops in smart contracts written in Solidity.
Figure1presentsabarchartshowingthepercentageofcontracts
thatcontainatleastoneloop(inred).Specifically,eachbarcorre-
sponds to a family of smart contracts grouped according to their
linesofSoliditycode.Acrossallcontracts,wefindthatroughlyone
infive contractshaveatleast oneloop,suggestingthat loopsmay
not be quite as rare as assumed in prior work [ 40]. However, the
percentageofcontractsthatcontainloopsincreasessignificantly
asweconsiderlargercontracts.Inparticular,forcontractsbetween
500-1000 lines of code, roughly four in five contracts contain at
least one loop, and almost no contract with over 1000 lines of code
is loop-free.
Next, we study the frequency of loops within a typical smart
contract. The blue bars in Figure 1 show the frequency of loops
per 100 lines of source code, again grouped according to lines of
Solidity code. Across all contracts, we encounter an average of one
loopper250linesofsourcecode.However,thisratioissignificantly
higher for larger contracts. In particular, for contracts with over
500 lines of code, we encounter an average of one loop per 100-125
lines of source code.
Keyfinding1: Roughlyoneinfivecontractscontainatleast
oneloop,andonlyhalfofthecontractswithover200linesof
codeareloop-free.Acrossallcontracts,wefindanaverage
of one loop per every 250 lines of source code.
2.2 Nature of Loops, Syntactically
In this section, we investigate various syntactic properties of loops
insmartcontracts.Inparticular,Table1presentsinformationabout
1Slitherisunabletoanalyzesomeofthesecontractsduetounsupportedversionsor
features of Solidity.
Figure 1: Percentage of smart contracts containing at leastoneloopandfrequencyofloopsperhundredlinesofsourcecode (grouped according to contract lines of source code)
Description AvgMedian Max
< 100 LoC
Size of the loop body 1.841 8
Nesting level 1.031 3
Number of variables 4.474 12
100-500 LoC
Size of the loop body 2.282 122
Nesting level 1.031 3
Number of variables 5.134 23
500-1000 LoC
Size of the loop body 2.282 23
Nesting level 1.071 3
Number of variables 5.335 22
>1000 LoC
Size of the loop body 2.392 19
Nesting level 1.111 3
Number of variables 4.704 25
Overall
Size of the loop body 2.272 122
Nesting level 1.051 3
Number of variables 5.064 25
Table1:Informationaboutloopsize,nestinglevel,andnum-
ber of variables touched
thesizeofloopsforafamilyofcontractsgroupedaccordingtotheir
size.Acrossallcontracts,wefindthatthemediansizeoftheloop
body istwo linesof code,and, unlike frequency(Figure 1),we see
that loop size does not seem to vary much according to contract
size.AsalsoshowninTable1,itisveryuncommontoseenested
loopsinsmartcontracts:Themediannestinglevel,includingfor
contracts over 1000 lines of code, is just one (i.e., no nested loops).
Furthermore, a typical loop touches an average of roughly five
263program variables.
Key finding 2: A typical smart contract loop is quite small,
containing roughly two lines of code in their body. Further-
more, nested loops are very uncommon.
Next, as summarized in Table 2 we study what percentage of
loops exhibitvarious syntactic properties. Ourfirst finding isthat
theoverwhelmingmajorityofsmartcontracts(around88%)involve
collections, meaning that they iterate over elements of arrays or
mappings.Furthermore,roughlythreeoutoffourloopsperform
writes, meaning that they involve side effects on contract state; the
remaining quarter of loops contain only purely read statements,
suchasrequire,transfer,log,andeventbroadcasts.Anotherinter-
esting observation is that, while the average loop body contains
approximately two lines of code, more than one in three loops con-
tain at least one control flow construct (e.g., if statement, continue
etc.) in their body. Other salient findings from our study can be
summarized as follows:
â€¢Batch transfer: Loops that involve calls to built-in Solid-
ityfunctionslike sendandtransfer typicallyperformso-
calledbatchtransfer,meaningthattheytransferethertoa
set of recipients. According to our findings, 8.5% of Solidity
loops perform batch transfer.
â€¢Enforcing requirements: Programmers use the require
constructinSoliditytoestablishsomepre-condition.Wefind
that13%ofloopsinvolvea requirestatement,suggesting
that these loops establish some universally quantified pre-
condition involving a data structure.
â€¢Nested loops: Aswesaw earlier,nestedloopsareuncom-
mon, and only 4.5% of loops contain a nested loop.
â€¢SafeMath: Approximatly13%oftheloops involveacallto
the SafeMath library for avoiding overflows.
â€¢Events:Solidity programs can emit so-called eventsthat
faciliate the convenient usage of EVM logging facilities. We
findthattheemissionofeventsisquiteuncommonwithin
loops â€“ only 4.5% of loops involve events.
â€¢Function calls: RoughlyoneinfiveSolidityloopscontain
a call to a function (excluding safemath calls and built-in
functions like transfer).
â€¢Bounded loops: Approximately 18% of the loops have a
constant bound, while the remaining ones all have symbolic
bounds.
Key finding 3: The overwhelming majority of loops iterate
overcollectionsandmodifycontractstate.However,since
functioncallswithinloopsarenotverycommon,analysisof most loops does not require interprocedural reasoning.Furthermore, 80% of Solidity loops have symbolic bounds;
therefore,analysistechniquesbasedonloopunrollingcannot
soundly handle most smart contract loops.
2.3 Nature of Loops, Semantically
Inthissection,weinvestigatesomeinterestingsemanticproperties
ofsmartcontractloops.Toperformthisstudy,weusetheSlither
infrastructure[ 12]toimplementabasicstaticanalysisforanalyzingDescription Percentage
Loops that involve collections 87.58%
Loops that involve writes 76.27%
Loops that involve events 4.50%
Loops that have function calls 21.95%
Loops that have control flow constructs 37.39%
Loops that have nested loops 4.52%
Loops that have transfers 8.46%
Loops that have requires 12.98%
Loops involving SafeMath 13.25%
Loops that have a constant bound 17.79%
Table 2: Syntactic properties of loops
Type of dependence Percentage
Scalar value depends on collection 18.14%
Collection depends on collection 23.77%
Collection depends on scalar 15.90%
Collection key depends on collection value 14.84%
Table 3: Semantic properties of loops
datadependenciesbetweenvariables.Theresultsofthisanalysis
are summarized in Table 3.
Our first finding is that 18% of the smart contract loops involve
somedatadependencyfromcollectionstoscalars.Suchdatadepen-
dencies typically arise when the loop performs some computation
byiterating over adata structure, suchascomputing thesum ofall
elements in an array.
Next,wefindthat24%ofloopsinvolvedatadependencybetween
a pair of collections (including dependencies between different
elementsofthesamecollection).Forexample,suchdependencies
arisewhenshiftingarrayelementsorbuildinganewdatastructure
based on values stored in other data structures. On the other hand,
dependencies of collections on scalars is slightly less common;roughly 16% of loops exhibit such a dependency. For instance, aloop that sets some range of array elements to a constant value
would exhibit such a collection-on-scalar dependency.
Finally,westudyhowoftencollectionelementsareusedtoindex
intoothercollections.Forinstance,considerascenariowherean
arrayğ´stores all participants in an auction, and another mapping
ğ‘€fromparticipantsto amountsstoresthebidof eachparticipant.
In this scenario, one may need to loop over all elements in array
ğ´and useğ´[ğ‘–]to access the bid of a given participant in ğ‘€.W e
refertothistypeofdependencyas value-to-key dependencyand
find that 15% of loops involve such a pattern.
2.4 Clustering Loops by Semantic Properties
In this section, we identify common looping patterns in smart
contractsusingacombinationofk-meansclusteringandmanual
sampling. In particular, we use the scikit-learn Python library [ 39]
tofacilitatesemanticclusteringofSolidityloops,andthenmanually
inspect samples from each cluster to determine common semantic
behaviors per cluster.
264Figure 2: Semantic clustering of 1279 smart contract loops,
projected into 3D space.
Toperformthisclustering,wefirstreducedtheloopstodepen-
dency graphs similar to DroidSift [ 47] and Holmes [ 18]. As the
fourpropertiesinTable3areclearlynotsufficientforclustering,
webrokedownthesepropertiesintocommondependencygraph
features [ 18,47], such as the number of different types of nodes
that are being read from or written to. In total, we used 37 features
that serve as refinements of the properties from Table 3. For a com-
pletelistofthefeaturesused,seeAppendixA2.Toidentifyonly
commonlooppatterns,werestrictedthenumberofclusters to 6.
Additionally,toreduceoverlapinclusters,welimitedloopstothose
withsingle-statementbodiesthatcontainonlycommonfunction
calls (transfers, requires, and SafeMath functions).3
Figure2showstheresultsofourclustering,projectedontothree
dimensions by performing a high-dimensionality reduction in ascatter plot. For each cluster, we randomly sampled 10 files, and
manually inspected each sample. We will now explain some of the
salient findings from our manual investigation.
Fold pattern. Both cluster 0 (pictured in red in Figure 2) and
cluster 1 (in green) contain loops that perform an accumulating
computation similar to a foldin functional programming. In partic-
ular, 6 of the 10 sampled loops from cluster 0 sum the values of an
array/mapping, while 8 of 10 from cluster 1 perform a fold using a
more complicated arithmetic function.
Map pattern. Clusters 2 (in blue), 3 (in orange), and 4 (in purple)
containloopsthatmapvaluesontoaglobalarray/mapping,similar
to the mapcombinator in functional programming. In particular,
8 of the 10 loops sampled from cluster 2 write a constant value ğ‘
to mapping ğ‘šindexed by an array ğ‘(i.e.,ğ‘š[ğ‘[ğ‘–]]=ğ‘whereğ‘–is
the loop iterator). 7 of the 10 sampled loops in cluster 3 and 5 of 10
fromcluster4containawritefromonemapping ğ‘š1toanother ğ‘š2,
2Appendix is included in the supplementary material.
3Initiallywetriedlessrestrictiveclustering,butthisledtoclusterswhosecommon
behaviors were hard to identify.e.g.,ğ‘š1[ğ‘–]=ğ‘š2[ğ‘–].
Require. In addition to the mapping pattern found in cluster 4
(in purple), we also found that 3 of the 10 sampled loops contain
callstothebuilt-in requirefunction,whichrevertsexecutionof
the smart contract if a user-defined condition is not met. For all
threeloops,theuser-definedconditionwasalinearconstrainton
values of an array/mapping.
Arithmetic. Finally, the loops sampled from cluster 5 (in grey)
allcontaincomplexarithmeticcomputationsoverglobalintegers.
Furthermore,alloftheseloopsusearithmeticfunctionsfromthe
common SafeMath library,whichmay bewhytheywereclustered
together.However,thisclusterissignificantly smallerthanallthe
other clusters â€” instancesin this cluster only constitute 2% ofthe
loops used for this analysis.
In addition to sampling instances from each cluster, we also
sampled larger loops to see if their behavior can be expressed asa combination of the behaviors observed in each of our clusters.
Whilewefoundmanyofthesamebehaviors,ourmanualinvesti-
gation of larger loops revealed another operator, namely zipWith,
that is useful for characterizing smart contract loops. In particular,
loopsinvolvingthispatternperformpair-wiseaggregationbetween
twoarrays/mappings.However,wefoundseveralvariantsofthe
zipWithpattern, where one or both of the mappings are indexed
by another mapping/array.
3 A DSL FOR LOOP SUMMARIZATION
Based on our findings from the previoussection, we now propose
a small-but-expressive DSL called Consul4that can be used to
summarize common Solidity loops. We believe this DSL can aid
analysis,verification,andoptimizationeffortsforsmartcontracts
by capturing common loop behaviors and facilitating the design of
suitable abstract domains for analyzing smart contract loops.
The syntax of the Consul summarization language is shown in
Figure 3. At a high level, Consul programs are compositions of
assignments ğ‘£=ğ¸(whereğ‘£isaprogramvariable),requirements,
andethertransfers.Specifically,assignmentscapturesideeffectsof
loops on program variables, and multiple side effects are expressed
via composition. In addition to capturing side effects on explicit
contract state, our DSL also captures the semantics of loops that
involve transferandrequire,whichoccurinanon-trivialportion
of loops (recall Table 2).
Intheremainderofthissection,wegiveahigh-leveldescription
ofConsulsemanticsandrefertheinterestedreadertoAppendixB
for the formal semantics of each construct.
3.1 Summarizing Side Effects on Contract State
ConsulprogramssummarizethesideeffectsofSolidityloopsusingthreefunctionaloperatorsandtheirvariants.Alloftheseconstructs
operate over mappings and produce either scalars or mappings.
4Stands for â€œCONcise SUmmaries of Loops"
265Core constructs
Stmtğ‘†â†’ğ‘£=ğ¸|ğ‘†;ğ‘†|transfer(ğ‘š1,ğ‘š2,ğ¹,ğœ‘)
|require(ğ‘š,ğœ‘1,ğœ‘2)
|requireNested (ğ‘š1,ğ‘š2,ğœ‘1,ğœ‘2)
Exprğ¸â†’ğ‘šâˆˆMappings
|map(ğ‘š,ğœ‘,ğ¹)
|foldl(ğ‘š,ğœ‘,ğ‘“,ğ‘–)whereğ‘“âˆˆ{ +,max,...}
|zip(ğ‘š1,ğ‘š2,ğœ‘,ğ‘“)whereğ‘“âˆˆ{ +,max,...}
|mapNested (ğ‘š1,ğ‘š2,ğœ‘,ğ¹)
|foldlNested (ğ‘š1,ğ‘š2,ğœ‘,ğ‘“,ğ‘–)whereğ‘“âˆˆ{ +,...}
|zipNestedSym (ğ‘š1,ğ‘š2,ğ‘š3,ğœ‘,ğ‘“),ğ‘“âˆˆ{ +,...}
|zipNestedASym (ğ‘š1,ğ‘š2,ğ‘š3,ğœ‘,ğ‘“),ğ‘“âˆˆ{ +,...}
Functions
Functionğ¹â†’ğœ†ğ‘¥.ğ‘¡
Termğ‘¡â†’ğ‘¥|ğ‘–
|ğ‘¥âŠ•ğ‘–whereâŠ•âˆˆ{ +,Ã—,âˆ’,/}
Intğ‘–â†’ğ‘âˆˆInt|ğ‘’âˆˆIntProgExprs
Predicates
Predicate ğœ‘â†’ğœ†(ğ‘¥,ğ‘¦).ğœ™
Formulağœ™â†’ true|inRange(ğ‘¥,ğ‘¡1,ğ‘¡2)
|ğ‘£/multicloseleftğ‘¡1whereğ‘£âˆˆ{ğ‘¥,ğ‘¦},/multicloseleftâˆˆ{=,â‰¤,<,â‰¥,>}
|Â¬ğœ™|ğœ™1âˆ§ğœ™2|ğœ™1âˆ¨ğœ™2
Figure 3: The ConsulDSL for expressing loop summaries
Map operator. The most basic construct in Consul is the map
operator map(ğ‘š,ğœ‘,ğ¹)which yields a new mapping ğ‘š/primewhich is
the same as ğ‘šexcept that any key-value pair (ğ‘˜,ğ‘£)satisfying ğœ‘
is changed to (ğ‘˜,ğ¹(ğ‘£)). For instance, a loop that increments the
firstğ‘›elements in an array ğ‘by one can be summarized using the
following Consul statement:
ğ‘=map(ğ‘,ğœ†(ğ‘¥,ğ‘¦).inRange(ğ‘¥,0,ğ‘›),ğœ†ğ‘¥.ğ‘¥+1)
Foldloperator. AsmentionedinSection2.3,roughlyoneinfive
Solidityloopsperformsomesortofaggregationoveradatastruc-
ture.Tocapturethiscommonpattern,Consulprovidesaconstruct
oftheform foldl(ğ‘š,ğœ‘,ğ‘“,ğ‘–)thataggregatesallvaluesin ğ‘šsatisfy-
ingğœ‘by using function ğ‘“and initial value ğ‘–. As an example, the
statement ğ‘¥=foldl(ğ‘,true,+,0)captures the behavior of a loop
thatcomputesthesumofallelementsinarray ğ‘andassignsitto
variableğ‘¥.
Zip operator. Another common pattern we observed in Solidity
loopsistoperformpair-wiseaggregationbetweentwo mappings.
Consul captures this common behavior using the zipconstruct.
For example, the statement ğ‘=zip(ğ‘,ğ‘,true,+)captures the effect
of aloop that constructsa new array ğ‘where eachelement ğ‘[ğ‘–]is
the sum of ğ‘[ğ‘–]andğ‘[ğ‘–].
Nested family of operators. As discussed in Section 2.3, many
Solidity loops iterate over a mapping ğ‘š1and use values in ğ‘š1to
access values in another mapping ğ‘š2. Furthermore, we found this
patterntooccurfrequentlybothforperformingaggregationaswell
asbuildingnewdatastructures.Therefore,theConsullanguageprovidesavariantofeachofthe map,zipandfoldlconstructsfor
expressing such behaviors.
Specifically, the construct mapNested (ğ‘š1,ğ‘š2,ğœ‘,ğ¹)is similar
tomapexcept that lambda expression ğ¹is applied to elements
ğ‘š1[ğ‘š2[ğ‘–]](ratherthan ğ‘š1[ğ‘–])forkeys/indices ğ‘–satisfyingpredicate
ğœ‘.Forinstance,considerasmartcontractthathasanarraycalled ğ‘
that stores a designated set of addresses as well as another array
calledğ‘that maps each address to some amount. Now, consider
a loop that increments the amount of money for each address in
ğ‘bysomeamount ğ‘ğ‘šğ‘¡.Thiscomplexpatterncanbesummarized
concisely using the mapNested pattern as follows:
ğ‘=mapNested (ğ‘,ğ‘,true,ğœ†ğ‘¥.ğ‘¥+ğ‘ğ‘šğ‘¡)
Next,thenestedvariantof foldl,called foldlNested allowsper-
formingnestedaggregation.Inparticular, foldlNested (ğ‘š1,ğ‘š2,ğœ‘,ğ‘“,ğ‘–)
aggregatesusingfunction ğ‘“allelements ğ‘š1[ğ‘š2[ğ‘–]]forkeys/indices
ğ‘–satisfying predicate ğœ‘. For instance, the statement
foldlNested (ğ‘,ğ‘,ğœ†(ğ‘¥,ğ‘¦).inRange(ğ‘¥,1,3),+,0)
computes the sum ğ‘[ğ‘[1]]+ğ‘[ğ‘[2]]+ğ‘[ğ‘[3]].
Finally, the two zipNested constructs provide nested variants of
zip. Specifically, consider three mappings:
ğ‘š1:ğœ1â‡’ğœ2ğ‘š2:ğœ1â‡’ğœ2ğ‘š3:ğœ3â‡’ğœ1
Then, zipNestedSym (ğ‘š1,ğ‘š2,ğ‘š3,ğœ‘,ğ‘“)creates a new mapping ğ‘š4
oftypeğœ1â‡’ğœ2whereğ‘š4[ğ‘š3[ğ‘–]]isequalto ğ‘“(ğ‘š1[ğ‘š3[ğ‘–]],ğ‘š2[ğ‘š3[ğ‘–]])
for those indices ğ‘–satisfying ğœ‘.
The other variant zipNestedASym is similar except that it is
asymmetric. Specifically, it operates over mappings with the fol-
lowing types:
ğ‘š1:ğœ1â‡’ğœ2ğ‘š2:ğœ3â‡’ğœ2ğ‘š3:ğœ3â‡’ğœ1
Then,theconstruct zipNestedASym (ğ‘š1,ğ‘š2,ğ‘š3,ğœ‘,ğ‘“)createsanew
mappingğ‘š4of typeğœ1â‡’ğœ2where:
ğ‘š4[ğ‘š3[ğ‘–]]=ğ‘“(ğ‘š1[ğ‘š3[ğ‘–]],ğ‘š2[ğ‘–])
for those indices ğ‘–satisfying ğœ‘. In practice, we found this asymmet-
ricvariantof zipNested tooccurmorefrequentlythanitssymmetric
variant.
3.2 Summarizing Transfers and Requirements
Recall fromSection 2.2 thatroughly one infiveSolidity loopsin-
volvecallstobuilt-inSolidityfunctionssuchas requireandtransfer.
Thus, our summarization language also provides constructs for
capturingthebehaviorofsuchloops.Forinstance,theconstruct
transfer(ğ‘š1,ğ‘š2,ğ¹,ğœ‘)isusedtosummarizebatchtransferswhere
ğ‘š1is a mapping ğœâ‡’Addressandğ‘š2is a mapping ğœâ‡’Int.
Inparticular, transfer(ğ‘š1,ğ‘š2,ğ¹,ğœ‘)indicatesthebatchtransferof
amountğ‘š2[ğ‘–]fromthereceiverobjecttoaddress ğ‘š1[ğ‘–]forallkeys
ğ‘–satisfying predicate ğœ‘.
Finally, our DSL provides two variants of requirefor summa-
rizing loops that enforce some pre-condition. In particular, the
construct require(ğ‘š,ğœ‘1,ğœ‘2)checksthatpredicate ğœ‘2issatisfiedfor
allelements ğ‘š[ğ‘–]whereğ‘–satisfiesğœ‘1.The requireNested construct
is similar and corresponds to the nested variant of require. Specif-
ically, require(ğ‘š1,ğ‘š2,ğœ‘1,ğœ‘2)checks that predicate ğœ‘2is satisfied
for all elements ğ‘š1[ğ‘š2[ğ‘–]]whereğ‘–satisfiesğœ‘1.
266Solidity Loop Consul Equivalent
for(j = 0; j < addrs.length; j++){
bal[addrs[j]] += amts[j];
}bal = zipNestedASym (bal,amts,addrs,inRange(x,0,addrs.length),+)
for(i = 0; i < _addrs.length; i++){
if(!wlst[_addrs[i]]) {
wlst[_addrs[i]] = true;
}
}wlst = mapNested (wlst,_addrs ,inRange(x, 0,_a ddrs.length) âˆ§Â¬ y, true)
for(j = 0; j < addrs.length; j++){
cur = addrs[j];
require(cur != 0x0);
require(now > uTime[cur]);
amts[j] *= 1e8;
total += amts[j];
}require (addrs,inRange(x,0, addrs.length), x!=0x0);
requireNested (uTime, addrs, inRange(x,0, addrs.length), x < now);
amts = map(amts,inRange(x,0,addrs.length), x*1e8);
total = foldl (amts, inRange(x,0,addrs.length), +, total)
Table 4: Examples of Solidity loops and their Consulequivalent. We omit lambdas to improve readability.
3.3 Examples
In this section we provide some sample Solidity loops and show
how they can be summarized in the Consul DSL.
Example3.1. ThefirstrowinTable4showsasinglelineSolidity
loopthatincrementsthebalanceofalistofaddressesbyagiven
amount.Thisloopcanbesummarizedusingtheasymmetricversion
of the zipNested construct, as shown on the right-hand-side of
Table 4.
Example 3.2. The second row of Table 4 shows a loop that
whitelists certain addresses if that address is not already on the
whitelist.Thisloopcanbesummarizedusingthe mapNested con-
struct, as shown in the second column of Table 4. Observe that the
predicateensuresthat,foranyupdatedelement,thekeymustbe
intherange [0,_addrs.length)andthecorrespondingvaluemust
be false.
Example 3.3. The last row in Table 4 shows a more complex
loop that establishes a pair of pre-conditions, while also having
sideeffectsoncontractstate.Asshownontherighthandsideof
the table, the summary of this loop involves the requireNested
construct since therequirement onthe thirdline ofthe loopbody
involves a nested data structure access. The update to the amts
arrayiscapturedusingthe mapconstructandthecomputationof
total amount is captured using foldlwith the+operator.
4 SYNTHESIS OF LOOP SUMMARIES
As a first step towards reasoning about loops in smart contracts,
we implemented a tool called Solis for automatically synthesizing
loop summaries. Our tool is based on the syntax-guided synthe-
sis paradigm [ 3] and, as shown in Figure 4, it leverages both an
type-directed search engine and a (bounded) equivalence checker.
Specifically, the search engine enumerates candidate Consul sum-
maries for thegiven loop and uses theverifier to test equivalence
betweentheloopandcandidatesummary.Thesearchenginecontin-
ues this enumeration process until we either exhaust all candidate
Consul programs forthe givenloopor until wegenerate an equiv-
alent summary. In the remainder of this section, we provide a briefoverview of the search engine and equivalence checker underlying
the Solis summary synthesis engine.
4.1 Type-Directed Search Engine
Similar to several other synthesizers [ 4,14,17], Solis enumerates
DSLprogramsinincreasingorderofcomplexityandleveragesprop-
erties of the input loop to avoid enumerating useless summaries.Specifically, our search engine utilizes both type information as
wellasbasicstaticanalysisoftheloopbodytoprunelargepartsof
the search space.
In more detail, Table 5 presents necessary conditions for our
search engine to enumerate a given Consul statement. These pre-
conditions make use of two main types of information:
â€¢Variable types: Given a variable ğ‘£, we write ğœ(ğ‘£)=ğœ1to
indicate that the type of variable ğ‘£isğœ1.I fğœ1=Map, the
notationğœ2â‡’ğœ3indicates that the key type of the map is
ğœ2and value type is ğœ3.
â€¢Read-write sets: For each loop ğ¿in the original contract,
we compute the set of variables it reads from and the set
ofvariablesitwritesto.Weusethenotation ğ‘£âˆˆReads(ğ¿)
(resp.ğ‘£âˆˆWrites(ğ¿)) to indicate that ğ‘£is read from (resp.
written to) in loop ğ¿.
Since the pre-conditions in Table 5 are fairly self-explanatory,
we do not describe all of them in detail but focus on a few example
constructs:
â€¢map:According to the second row of Table 5, Solis only
enumeratesthestatement ğ‘£1=map(ğ‘£2,ğœ‘,ğ¹)ifbothğ‘£1and
ğ‘£2have type mapping and ğ‘£1is written to by the input loop
whereasğ‘£2is read from.
â€¢foldlNested: Foraninputloop ğ¿,thesummaryshouldonly
containthestatement ğ‘£1=foldlNested (ğ‘£2,ğ‘£3,ğ‘“,ğ‘–)ifğ‘£1has
type Intand the value type of ğ‘£3is the same as the key type
ofğ‘£2. In addition, ğ‘£1must be written to and ğ‘£2,ğ‘£3must be
read from.
â€¢Composition: According to the first row of Table 5, differ-
entstatementsinthesummaryshouldnotwritetothesame
variable. This rule prevents Solis from enumerating useless
267SOLIS
Type-directed 
 SearchEquivalence 
 Checker
Loop Consul
Summary
Figure 4: Overview of Solis
Statement Pre-condition
ğ‘†1;ğ‘†2 Writes(ğ‘†1)âˆ©Writes(ğ‘†2)=âˆ…
ğ‘£1=map(ğ‘£2,ğœ‘,ğ¹) ğœ(ğ‘£1)=ğœ(ğ‘£2)=Mapâˆ§ğ‘£1âˆˆWrites(ğ¿)âˆ§ğ‘£2âˆˆReads(ğ¿)
ğ‘£1=foldl(ğ‘£2,ğœ‘,ğ‘“,ğ‘–) ğœ(ğ‘£1)=Intâˆ§ğœ(ğ‘£2)=Mapâˆ§ğ‘£1âˆˆWrites(ğ¿)âˆ§ğ‘£2âˆˆReads(ğ¿)
ğ‘£1=zip(ğ‘£2,ğ‘£3,ğœ‘,ğ‘“) ğœ(ğ‘£1)=ğœ(ğ‘£2)=ğœ(ğ‘£3)=Mapâˆ§ğ‘£1âˆˆWrites(ğ¿)âˆ§ğ‘£2,ğ‘£3âˆˆReads(ğ¿)
ğ‘£1=mapNested (ğ‘£2,ğ‘£3,ğœ‘,ğ¹)ğœ(ğ‘£1)=Mapâˆ§ğœ(ğ‘£2)=(ğœ1â‡’ğœ2)âˆ§ğœ(ğ‘£3)=(ğœ3â‡’ğœ1)âˆ§ğ‘£1âˆˆWrites(ğ¿)âˆ§ğ‘£2,ğ‘£3âˆˆReads(ğ¿)
ğ‘£1=foldlNested (ğ‘£2,ğ‘£3,ğœ‘,ğ‘“,ğ‘–)ğœ(ğ‘£1)=Intâˆ§ğœ(ğ‘£2)=(ğœ1â‡’ğœ2)âˆ§ğœ(ğ‘£3)=(ğœ3â‡’ğœ1)âˆ§ğ‘£1âˆˆWrites(ğ¿)âˆ§ğ‘£2,ğ‘£3âˆˆReads(ğ¿)
ğ‘£1=zipNestedSym (ğ‘£2,ğ‘£3,ğ‘£4,ğœ‘,ğ‘“) ğœ(ğ‘£1)=Mapâˆ§ğœ(ğ‘£2)=ğœ(ğ‘£3)=(ğœ1â‡’ğœ2)âˆ§ğœ(ğ‘£4)=(ğœ3â‡’ğœ1)
âˆ§ğ‘£1âˆˆWrites(ğ¿)âˆ§ğ‘£2,ğ‘£3,ğ‘£4âˆˆReads(ğ¿)
ğ‘£1=zipNestedASym (ğ‘£2,ğ‘£3,ğ‘£4,ğœ‘,ğ‘“) ğœ(ğ‘£1)=Mapâˆ§ğœ(ğ‘£2)=(ğœ1â‡’ğœ2)âˆ§ğœ(ğ‘£4)=(ğœ3â‡’ğœ1)âˆ§ğœ(ğ‘£3)=(ğœ3â‡’ğœ2)
âˆ§ğ‘£1âˆˆWrites(ğ¿)âˆ§ğ‘£2,ğ‘£3,ğ‘£4âˆˆReads(ğ¿)
require(ğ‘£,ğœ‘1,ğœ‘2) containsRequire (ğ¿)âˆ§ğ‘£âˆˆReads(ğ¿)
requireNested (ğ‘£1,ğ‘£2,ğœ‘1,ğœ‘2) containsRequire (ğ¿)âˆ§ğ‘£1,ğ‘£2âˆˆReads(ğ¿)âˆ§ğœ(ğ‘£1)=(ğœ1â‡’ğœ2)âˆ§ğœ(ğ‘£2)=(ğœ3â‡’ğœ1)
transfer(ğ‘£1,ğ‘£2,ğ¹) containsTransfer (ğ¿)âˆ§ğœ(ğ‘£1)=(ğœ1â‡’Address)âˆ§ ğœ(ğ‘£2)=(ğœ2â‡’Int)âˆ§ğ‘£1,ğ‘£2âˆˆReads(ğ¿)
Table 5: Pruning rules used by the search engine of Solis
1 (define (check-eq fun1 fun2 input K)
2 (define i-state (initial-state input ))
3 (define o1 (interpret fun1 i-state K))
4 (define o2 (interpret fun2 i-state K))
5 (verify (assert (equal? o1 o2)))
Figure 5: Core idea behind equivalence checker
summaries where the effect of one summary statement is
overridden by a subsequent one.
ForagivenSolidityloop ğ¿,therearetypicallynottoomanyConsul
statements that meet the pre-conditions from Table 5; thus, our
pre-conditions are effective at pruning a large part of the search
space during enumeration.
In addition to the rules shown in Table 5, Solis uses several
othertype-directedrulestoprunethespaceoffunctionsitneeds
to consider. For example, consider again the statement:
ğ‘£1=map(ğ‘£2,ğœ‘,ğœ†ğ‘¥.ğ‘¡)
Clearly,forthisprogramtotype-check,thetypeof ğ‘¡mustbethe
sameasthevaluetypeof ğ‘£1.Thus,Soliscanalsousetype-based
reasoning when filling in lambda expressions used in Consul con-
structs.
4.2 Equivalence Checker
Once Solis generates a candidate summary, it needs to check
whether the summary is equivalent to the original loop ğ¿. Towards
this goal,we first convert the Consul summary ğ‘†into equivalent
Solidity code ğ‘†/primeusing syntax-directed translation (see AppendixB). However, since there is no off-the-shelf equivalence checker for
Solidity programs, we also implemented a (bounded) verifier for
checking equivalence between a pair of Solidity programs.
Thekeyideaunderlyingourequivalencecheckerisillustrated
in the code shown in Figure 5. Specifically, the checker takes as
inputtwoSolidityprograms fun1andfun2aswellasasymbolic
input called inputand verification bound ğ¾that controls how
many times the loops are unrolled. Then, we symbolically evaluate
both fun1andfun2on the symbolic input state to obtain a pair
ofsymbolicoutputstates o1ando2.Iftheresultingoutputstates
are equal, this constitutes a proof (up to bound ğ¾) that the Consul
summary is equivalent to the original loop.
We have implemented our equivalence checker on top of the
Rosetteframework[ 44]andleverageitsSMTencodingfacilitiesas
wellasitssymbolicevaluationengine.Specifically,weimplemented
atranslatorfromSoliditycodetoanintermediaterepresentation
that can be symbolically evaluated by Rosette.
4.3 Compositional Synthesis
As is common in program synthesis, the search space of programs
wemustconsiderinConsulincreasesexponentiallyinthenumber
ofstatements.ToscaleoursynthesisproceduretolargerConsul
programs, we introduce compositional synthesis, which enables
synthesis of complex summaries by synthesizing their constituent
parts and then composing them together.
In particular, compositional synthesis works by independently
synthesizing partial summaries for each variable written in the
loop,andthencomposingthemtogetherwithConsulâ€™ssequencing
operator.Considerthefollowingloop,whichcanbeexpressedin
268Size # Loops Time-outs Precise sum. Partial sum. Overall (incl. T/O) Overall (excl. T/O)
1 352 7(2%) 266(76%) 0(0%) 76% 77%
2 443 42(9%) 241(54%) 84(19%) 73% 81%
3 164 75(46%) 22(14%) 17(10%) 24% 44%
4 82 0(0%) 9(11%) 21(26%) 37% 37%
â‰¥5 179 49(27%) 16(9%) 8(4%) 13% 18%
All loops 1220 173(14%) 554(45%) 130(11%) 56% 65%
Table 6: Evaluation Results
Consulasa foldover arr(storedin acc)followedbya mapover
arr(stored in arr).
1 for(uint i = 0; i < len; i++){
2 acc += arr[i];
3 arr[i] *= 5;
4 }
Westartbysynthesizingasingle-statementsummaryforeach
variablewhichiswrittenintheloop;inthiscasewesynthesizethe
following two summaries:
ğ‘ğ‘ğ‘=foldl(ğ‘ğ‘Ÿğ‘Ÿ,ğ‘–ğ‘›ğ‘…ğ‘ğ‘›ğ‘”ğ‘’ (ğ‘¥,0,ğ‘™ğ‘’ğ‘›),+,ğ‘ğ‘ğ‘)
ğ‘ğ‘Ÿğ‘Ÿ=map(ğ‘ğ‘Ÿğ‘Ÿ,ğ‘–ğ‘›ğ‘…ğ‘ğ‘›ğ‘”ğ‘’ (ğ‘¥,0,ğ‘™ğ‘’ğ‘›),ğ‘¥âˆ—5)
Finally,wecomposetogetherthetwosummariesusingthesequenc-
ing operator ; which gives us the complete summary.
While this optimization does not affect the soundness of our
synthesisalgorithm,itdoesmakeitincomplete.Inparticular,this
algorithm will not be able to synthesize a Consul program ğ‘ƒ=
ğ‘†1;ğ‘†2where statement ğ‘†2dependson statement ğ‘†1â€“ that is, where
variables read in ğ‘†2are written in ğ‘†1. This is because there is no
valid single-statement partial summary which captures ğ‘†2without
ğ‘†1. In practice, we observed relatively few loops with dependent
statements, and thus found it worth sacrificing completeness for
scalability.
5 EVALUATION
Toevaluate whatpercentageofSolidityloopscanbesummarized
in our proposed Consul language, we used Solis to synthesize
summaries for real-world Solidity loops. The main goal of our
evaluation is to answer the following research questions:
RQ1What percentage of loops can be precisely (or at least par-
tially) summarized in the Consul language?
RQ2WhatistherelativefrequencyofConsulconstructsthatare
used in Solidity loop summaries?
RQ3What types of loops cannot be summarized using Solis?
5.1 Experimental Set-up
We conduct this experiment on approximately 1,200 contracts that
containloops.Specifically,toperformthisexperiment,weextract
allloopscontainedinthese1200contractsandthenfilteroutloopsthatcontainSolidityfeaturesthatcannotbehandledbySolis.Such
features include user-defined constructs, multi-dimensional arrays,
and calls to functions that cannot be analyzed by Solis. Using
this methodology, we obtained a total of 1220 benchmarks, which
corresponds to approximately 40% of all loops found within the
original 1,000 Solidity contracts.All experiments reported in this section are conducted on a
t3.2xlarge machine on Microsoft Azure with an Intel Xeon Plat-
inum 8000 CPU and 32G of memory, running the Ubuntu 18.04
operating system and using a timeout of 120 minutes for each loop.
5.2 Key Results
We now summarize our key findings as they relate to the research
questions posed earlier.
Table6presentstheresultofrunningSolisoverour1220bench-
marks. Here, the first column shows the size of the loop body in
termsoflinesofSoliditycode,andthesecondcolumnshowsthe
total number of loops of that size. The next column labeled â€œTime-
outs" shows the number of benchmarks for which Solis fails tofinish its exploration within the given time limit. Next, the col-
umnlabeledâ€œPrecisesum."showsthenumberofloopsforwhich
Solis is able to find a precise summary â€“ that is, the generatedsummary is exactly equivalent to the original loop. On the other
hand, the column labeled â€œPartial sum." shows the number of loops
forwhichSoliscangenerateapartial,butnotprecise,summary
â€“ that is, a summary which over-approximates the loopâ€™s actual
post-condition. Finally, the column labeled â€œOverall (incl. T/O)"shows the percentage of loops for which Solis can generate anysummary (either precise or partial), including those benchmarks
where we encounter a time-out. The last column reports the same
information but excludesthose benchmarks on which Solis times-
out.Intheremainderofthisdiscussion,wemostlyfocusonthose
benchmarksonwhichSolisdoesnottimeout,asourprimarygoal
is to investigate Solidity loops rather than the Solis synthesizer.
AswecanseefromTable6,Soliscangenerateasummaryfor
65%ofthebenchmarks,andwefindthatthesesummariesareequiv-
alenttotheoriginalloopfor53%ofthebenchmarksonwhichwe
do not observe a time-out. As we can also see from Table 6, the
percentage of loops that can be summarized by Solis is smaller for
largerloops.However,uponmanualinspection,wefindthatthis
is often due to the incomplete decomposition strategy describedin Section 4.3. In particular, while this decomposition allows our
synthesis technique to be more scalable, it sacrifices completeness
insituationswhereonesideeffectoftheloopisdependentupon
anotherone.Thus,inreality,thepercentageofloopsthathavea
ConsulsummaryismuchhigherthanthedatapresentedinTable6.
Result for RQ1: At least 56% of the loops in Solidity con-
tracts have a summary that is expressible in the Consulloop summarization DSL, and 81% of these summaries are
equivalent to the original loop.
269Figure 6: Frequency of Consulconstructs
Next,toansweroursecondresearchquestion,Figure6shows
therelativefrequencyofeachConsulconstructinthegenerated
summaries. For each DSL operator ( map,foldetc), we group to-
gether its nested and non-nested version â€“ e.g., the bar labeled zip
includes all three variants of the zipconstruct. Finally, the last two
columnsdifferentiatebetweenthenestedandnon-nestedversion
of the DSL operators. For example, the bar labeled â€œnestedâ€ in-
cludes mapNested ,foldlNested ,requireNested and the two nested
variants of zip.
As we can see from Figure 6, mapis the most commonly occur-
ringDSLconstruct,followedbythe requireoperator.5Thenexttwo
most common operators are foldlandzip, and by far the least com-
mon construct is transfer. Another interesting observation from
Figure 6 is that the nested versions of the operators occur more
frequently than the non-nested versions (57% vs. 43%).
Result for RQ2: The most commonly occurring Consul
constructinthesynthesizedsummariesis map.Furthermore,
the nested variants of Consul operators occur more com-
monly than their non-nested variants.
Finally, to answer our third research question, we give some
examples of Solidity loops for which Solis was unable to generate
a useful summary despite exploring the whole search space (i.e.,
no time-out). As expected, there are two reasons why Solis fails to
summarizealoopâ€™sbehavior:(1)thesemanticsoftheloopcannot
be captured by the Consul DSL, or (2) synthesis fails due to the
incomplete decomposition heuristics employed by Solis.
To understand the latter issue, consider the last example from
Table4.Here,becausethereisadependencybetweentheloopâ€™smul-
tiplesideeffects(e.g.,thelast foldloperationdependsontheearlier
mapoperation), we cannot generate the summary in a composi-
tional way, so the decomposition strategy described in Section 4.3
failstowork.Asaresult,Solisisunabletocapturetheloopâ€™seffect
5Part of the reason that requireis so common is due to the fact that Solis summa-
rizes requirestatements with conjunctions in the Solidity code with multiple require
statements.1 for(uint i = 0; i < len; i++){
2 sig = bytes4(uint(sig) + uint(_data[i]) *
3 (2 ** (8 * (len - 1 - i))));
4 }
1 while (first < last){
2 uint256 check = (first + last) / 2;
3 if((n >> check) == 0) {
4 last = check;
5 }else {
6 first = check + 1;
7 }
8 }
1 for(uint256 j = 10; j > i; j--){
2 if(topWinners[j - 1] != msg.sender) {
3 topWinners[j] = topWinners[j - 1];
4 }else {
5 for (uint256 k = j; k < 10; k++) {
6 topWinners[k] = topWinners[k + 1];
7 }
8 }
9 }
Figure7:ExampleSolidityloopswhichcannotbeexpressed
inConsul
onthevariablecalled totaleventhoughtheloopâ€™sbehaviorcan
be precisely summarized in the Consul DSL.
BeyondlimitationsoftheSolistoolchain,thereare,ofcourse,
also Solidity loops that fundamentally cannot be expressed in Con-
sul. We show three such examples in Figure 7.
Forinstance,considerthefirstloopfromFigure7.Atfirstglance,
theloopappearstodoa foldoverthearraycalled _data. However,
theexpressionontheright-handsideincludessubtractionofthe
iterator i, which cannot be captured by any of the accumulator
functions in Consul.
The second loop in Figure 7 does not access a collection as most
loops do (see Section 2), but instead performs complicated arith-metic operations on the two integers
firstandlast. However,
we intentionally did not try to capture such numeric summaries in
the Consul DSL because (a) such behavior is not as common, and
(b) there is already a rich literature of program analysis techniques
for inferring numeric invariants (e.g., based on abstract interpreta-
tion[10,36],constraintsolving[ 9,23],Craiginterpolation[ 24,35],
abduction [11, 33] etc.).
The third loop in Figure 7 involves a conditional whose else
branchcontainsanestedloop.Whilethenestedloophasasummary
thatisexpressibleinConsul(andwhichcanalsobesynthesized
by Solis), the behavior of the outer loop does not appear to be
expressible in our summarization language.
Result forRQ3: There are two reasons why Solis may fail
to generate a useful loop summary. One reason is due to the
incomplete decomposition heuristic described in Section 4.3.
Another reason is the presence of complex arithmetic or
nestedloopsthatresultinbehaviorthatisnoteasilyexpress-
ible in the Consul DSL.
2705.3 Threats to validity
Webelievetherearetwomajorthreatstothevalidityofourcon-
clusions, which we explain below.
BenchmarkSelection. Asmentionedearlier,wewereabletoeval-
uateSolison1220ofthe22,685loopsconsideredinSection2dueto
limitations of our implementation and time restrictions. However,
webelievethatourbenchmarksarerepresentativeenoughinterms
of both complexity and diversity.
Validity of Summaries. As mentioned in Section 4, Solis uses
bounded verification when checking equivalence. In theory, this
meansthatsomeofthesummariessynthesizedbySolismaynot
actually be equivalent to the original loop. However, based on our
manualinspectionofrandomlysampledsummaries,wefindthat
theloopssynthesizedbySolisareindeedequivalenttotheoriginal
loop.
DSLConstruction. SincetheconstructsofConsulinFigure3are
designedmanuallybyus,theymaynotberepresentativeenoughto
coverallofthecommonlooppatternsfoundinSolidity.Tomitigatethisconcern,ourDSLdesignwasguidedbystaticanalysis,semantic
clustering, and random sampling as detailed in Section 2.
6 RELATED WORK
Programanalysisforsmartcontractshasbeenanactiveresearch
topicinrecentyears.Inwhatfollows,wesurveyrecentresearch
on smart contract analysis as well as a few other topics relevant to
this work.
Program analyzers for smart contracts. Existing tools for vetting
smart contracts are based on a variety of different approaches,including symbolic execution [
1,2,34,38], abstract interpreta-
tion [20,45], interactive theorem proving [ 21,25], and testing [ 26].
To the best of our knowledge, none of these existing techniques
aimtoinferpreciseloopinvariantsthatcapturealoopâ€™ssideeffects
oncontract state.Thus, existingtechniquesare eitherunsoundor
grosslyimpreciseinthepresenceofloops,ortheyrequiremanu-
ally provided invariants from the user. We view this work as being
complementary to existing efforts in the space of program analysis
for smart contracts. In particular, our work brings clarity about the
nature of loops that occur in smart contracts and takes a first step
towards automatically inferring their semantics.
Loopsummarization. Generallyspeaking,loopsummarization
referstothetaskofreplacingaloop ğ¿withaloop-freecodesnippet
ğ‘†(e.g., that over-approximates the actual behavior of theloop [ 19,
29,42]). Loop summarization has been shown to be very helpful in
program analysis, both in the context of verification [ 28] as well as
symbolicexecution[ 19].Loopsummarizationhasalsobeenshown
tobeeffectiveforprogramoptimization.Forexample,theQBStool
byCheungetal.improvesprogramperformancebysummarizing
JavaloopsusingSQLstatements[ 8].Thisworkisparticularlyre-
lated to ours in that they take a program synthesis based approach
towards loopsummarization; however,they perform synthesisus-
ing constraint solving as opposed to type directed search. Moregenerally, compared to all existing work on loop summarization,the key contribution of this paper is to provide a formalism (i.e.,
domain-specificlanguage)thatcanbeusedtosummarizebehaviorsof Solidity loops. In addition, we also take a first step towards loop
summarization for smart contracts.
Equivalencechecking. Checkingequivalencebetweenapairof
programs is a classical relational verification problem and arises in
many different contexts, including translation validation [ 37], dif-
ferentialprogramanalysis[ 31,46],andregressionverification[ 13].
Generally speaking, there are two different approaches to check-
ing equivalence. Oneapproachis to construct a so-calledproduct
programğ‘ƒsuch that two programs ğ‘ƒ1andğ‘ƒ2are equivalent if and
onlyifğ‘ƒdoesnothavefailingassertions[ 5,6,32].Analternative
approachistoutilizeprogramlogics,suchasrelationalHoarelogic,
that can be used to directly prove equivalence [ 7,43]. In this work
we taketheformer approachand constructa verysimple product
program through sequential composition. This simple approach is
sufficientinoursettingbecauseourequivalencecheckerisbased
on bounded verification. While more sophisticated product con-
struction mechanisms may better facilitate unbounded verification
ofSolidityprograms,thisisanorthogonalproblemthatweleave
to future work.
Program synthesis. This work is related to a long list of research
papers on program synthesis in that we automatically synthesize a
DSL program that satisfies the given specification (in our case, the
original Solidity loop). While program synthesis is a very activeresearch area with a multitude of different techniques and appli-
cations [4,14,15,17,22,44], our work is most similar to inductive
synthesizersbasedonexplicitsearch[ 4,14,15,17].Moreconcretely,
similar to prior efforts in this space [ 16,17,41], our synthesis tech-
niqueusestype-basedreasoningtosignificantlyprunethesearch
spacebut alsoutilizesbasicstatic analysisoftheoriginal loop to
further reduce the space of candidate summaries.
7 CONCLUSION AND FUTURE WORK
In this paper, we performed a large-scale investigation of loops
foundinSoliditysmartcontracts,includingboththeirsyntacticand
semantic features. Based on these findings, we proposed a DSL for
capturing common behaviors of Solidity loops and built a program
synthesis toolchain called Solis for automatic loop summarization
in smart contracts. Our experiments indicate that at least 56% of
loopscanbesummarizedusingourproposedDSLand81%ofthese
summaries are equivalent to the original loop.
Thereareseveraldirectionsforfuturework.First,whilewehave
takenafirststeptowardsloopsummarizationinsmartcontracts,
our proposed tool chain sacrifices completeness for better scalabil-ity and therefore fails to generate summaries for larger loops even
though an equivalent Consul summary exists. Thus, we plan to
investigatebetterloopsummarizationtechniquesinfuturework.
Second,weareinterestedinintegratingourloopsummarization
method with existing verification tools such as VeriSol [ 30] to fur-
ther automate the process of proving functional correctness of
smart contracts.
ACKNOWLEDGEMENTS
ThisworkwaspartiallysupportedbyNSFGrants1908494,1811865,
1762299, and a generous gift from Microsoft Azure.
271REFERENCES
[1]2016. Manticore. https://github.com/trailofbits/manticore/. [Online;accessed
01/09/2019].
[2]2018. MythrilClassic. https://github.com/ConsenSys/mythril-classic. [Online;
accessed 12/01/2018].
[3]Rajeev Alur, Rastislav BodÃ­k, Eric Dallal, Dana Fisman, Pranav Garg, Garvit
Juniwal, Hadas Kress-Gazit, P. Madhusudan, Milo M. K. Martin, Mukund
Raghothaman,ShambwadityaSaha,SanjitA.Seshia,RishabhSingh,Armando
Solar-Lezama, Emina Torlak, and Abhishek Udupa. 2015. Syntax-Guided Synthe-
sis. InDependable Software Systems Engineering. 1â€“25.
[4]Rajeev Alur, Arjun Radhakrishna, and Abhishek Udupa. 2017. Scaling Enumera-
tive Program Synthesis via Divide and Conquer. In Tools and Algorithms for the
Construction and Analysis of Systems - 23rd International Conference, TACAS 2017,
Held as Part of the European Joint Conferences on Theory and Practice of Software,
ETAPS 2017, Uppsala, Sweden, April 22-29, 2017, Proceedings, Part I. 319â€“336.
[5]Gilles Barthe, Juan Manuel Crespo, and CÃ©sar Kunz. 2011. Relational Verifica-
tion Using Product Programs. In FM 2011: Formal Methods - 17th International
SymposiumonFormalMethods,Limerick,Ireland,June20-24,2011.Proceedings.
200â€“214.
[6]Gilles Barthe, Juan Manuel Crespo, and CÃ©sar Kunz. 2016. Product programsand relational program logics. J. Log. Algebraic Methods Program. 85, 5 (2016),
847â€“859.
[7]Jia Chen, Jiayi Wei, Yu Feng, Osbert Bastani, and Isil Dillig. 2019. Relational
verification using reinforcement learning. Proc. ACM Program. Lang. 3, OOPSLA
(2019), 141:1â€“141:30.
[8]AlvinCheung,ArmandoSolar-Lezama,andSamuelMadden.2013. Optimizing
database-backedapplicationswithquerysynthesis.In ACMSIGPLANConference
onProgrammingLanguageDesignandImplementation,PLDIâ€™13,Seattle,WA,USA,
June 16-19, 2013. 3â€“14.
[9]Michael A ColÃ³n, Sriram Sankaranarayanan, and Henny B Sipma. 2003. Lin-ear invariant generation using non-linear constraint solving. In International
Conference on Computer Aided Verification. Springer, 420â€“432.
[10]Patrick Cousot and Nicolas Halbwachs. 1978. Automatic discovery of linear
restraints among variables of a program. In Proceedings of the 5th ACM SIGACT-
SIGPLAN symposium on Principles of programming languages. 84â€“96.
[11]IsilDillig,ThomasDillig,BoyangLi,andKenMcMillan.2013. Inductiveinvariant
generation via abductive inference. Acm Sigplan Notices 48, 10 (2013), 443â€“456.
[12]Josselin Feist, Gustavo Grieco, and Alex Groce. 2019. Slither: a static analysis
framework for smart contracts. In Proceedings of the 2nd International Workshop
on Emerging Trends in Software Engineering for Blockchain, WETSEB@ICSE 2019,
Montreal, QC, Canada, May 27, 2019. 8â€“15.
[13]Dennis Felsing, Sarah Grebing, Vladimir Klebanov, Philipp RÃ¼mmer, and MattiasUlbrich.2014.Automatingregressionverification.In ACM/IEEEInternationalCon-
ferenceonAutomatedSoftwareEngineering,ASEâ€™14,Vasteras,Sweden-September
15 - 19, 2014. 349â€“360.
[14]Yu Feng, Ruben Martins, Osbert Bastani, and Isil Dillig. 2018. Program synthesis
usingconflict-drivenlearning.In Proceedingsofthe39thACMSIGPLANConference
onProgrammingLanguageDesignandImplementation,PLDI2018,Philadelphia,
PA, USA, June 18-22, 2018. 420â€“435.
[15]Yu Feng, Ruben Martins, Jacob Van Geffen, Isil Dillig, and Swarat Chaudhuri.2017. Component-based synthesis of table consolidation and transformationtasks from examples. In Proceedings of the 38th ACM SIGPLAN Conference on
Programming Language Design and Implementation, PLDI 2017, Barcelona, Spain,
June 18-23, 2017. 422â€“436.
[16]Yu Feng, Ruben Martins, Yuepeng Wang, Isil Dillig, and Thomas Reps. 2017.
Component-Based Synthesis for Complex APIs. In Proc. Symposium on Principles
of Programming Languages. ACM, 599â€“612.
[17]JohnK.Feser,SwaratChaudhuri,andIsilDillig.2015. Synthesizingdatastructuretransformationsfrominput-outputexamples.In Proceedingsofthe36thACMSIG-
PLANConferenceonProgrammingLanguageDesignandImplementation,Portland,
OR, USA, June 15-17, 2015. 229â€“239.
[18]MattFredrikson,SomeshJha,MihaiChristodorescu,ReinerSailer,andXifeng
Yan. 2010. SynthesizingNear-Optimal MalwareSpecifications fromSuspicious
Behaviors. In 31st IEEE Symposium on Security and Privacy, S&P 2010, 16-19 May
2010, Berleley/Oakland, California, USA. 45â€“60.
[19]Patrice Godefroid and Daniel Luchaup. 2011. Automatic Partial Loop Summa-rization in Dynamic Test Generation. In Proceedings of the 2011 International
Symposium on Software Testing and Analysis (Toronto, Ontario, Canada) (IS-
STA â€™11). Association for Computing Machinery, New York, NY, USA, 23â€“33.
https://doi.org/10.1145/2001420.2001424
[20]Neville Grech, Michael Kong, Anton Jurisevic, Lexi Brent, Bernhard Scholz, and
YannisSmaragdakis.2018. MadMax:survivingout-of-gasconditionsinEthereum
smartcontracts.In Proc.InternationalConferenceonObject-OrientedProgramming,
Systems, Languages, and Applications. 116:1â€“116:27.
[21]Ilya Grishchenko, Matteo Maffei, and Clara Schneidewind. 2018. A Semantic
Framework for the Security Analysis of Ethereum Smart Contracts. In Principles
of Security and Trust - 7th International Conference, POST 2018, Held as Part oftheEuropeanJointConferencesonTheoryandPracticeofSoftware,ETAPS2018,
Thessaloniki, Greece, April 14-20, 2018, Proceedings. 243â€“269.
[22]Sumit Gulwani. 2011. Automating string processing in spreadsheets using input-
outputexamples.In Proc.SymposiumonPrinciplesofProgrammingLanguages.
ACM, 317â€“330.
[23]SumitGulwani,SaurabhSrivastava,andRamarathnamVenkatesan.2008. Pro-
gram analysis as constraint solving. In Proceedings of the 29th ACM SIGPLAN
Conference on Programming Language Design and Implementation. 281â€“292.
[24]ThomasAHenzinger,RanjitJhala,RupakMajumdar,andKennethLMcMillan.
2004. Abstractions from proofs. ACM SIGPLAN Notices 39, 1 (2004), 232â€“244.
[25]Yoichi Hirai. 2017. Defining the Ethereum Virtual Machine for Interactive Theo-
rem Provers. In Financial Cryptography and Data Security - FC 2017 International
Workshops, WAHC, BITCOIN, VOTING, WTSC, and TA, Sliema, Malta, April 7,
2017, Revised Selected Papers. 520â€“535.
[26]BoJiang,YeLiu,andW.K.Chan.2018.ContractFuzzer:fuzzingsmartcontractsfor
vulnerabilitydetection.In Proc.InternationalConferenceonAutomatedSoftware
Engineering. 259â€“269.
[27]Sukrit Kalra, Seep Goel, Mohan Dhawan, and Subodh Sharma. 2018. ZEUS:
AnalyzingSafetyofSmartContracts.In Proc.TheNetworkandDistributedSystem
Security Symposium.
[28]Daniel Kroening, Natasha Sharygina, Stefano Tonetta, Aliaksei Tsitovich, and
ChristophM.Wintersteiger.2008. LoopSummarizationUsingAbstractTrans-formers.In Proceedingsofthe6thInternationalSymposiumonAutomatedTech-
nologyforVerificationandAnalysis (Seoul,Korea) (ATVAâ€™08).Springer-Verlag,
Berlin, Heidelberg, 111â€“125. https://doi.org/10.1007/978-3-540-88387-6_10
[29]Daniel Kroening, Natasha Sharygina, Stefano Tonetta, Aliaksei Tsitovich, andChristoph M. Wintersteiger. 2009. Loopfrog: A Static Analyzer for ANSI-CPrograms.In ASE2009,24thIEEE/ACMInternationalConferenceonAutomated
Software Engineering, Auckland, New Zealand, November 16-20, 2009. 668â€“670.
[30]Shuvendu K. Lahiri, Shuo Chen, Yuepeng Wang, and Isil Dillig. 2018. FormalSpecificationandVerificationofSmartContractsforAzureBlockchain. CoRR
abs/1812.08829 (2018).
[31]ShuvenduK.Lahiri,ChrisHawblitzel,MingKawaguchi,andHenriqueRebÃªlo.
2012. SYMDIFF: A Language-Agnostic Semantic Diff Tool for Imperative Pro-
grams. In Computer Aided Verification - 24th International Conference, CAV 2012,
Berkeley, CA, USA, July 7-13, 2012 Proceedings. 712â€“717.
[32]Shuvendu K. Lahiri, Kenneth L. McMillan, Rahul Sharma, and Chris Hawblitzel.
2013. Differential assertion checking. In Joint Meeting of the European Software
Engineering Conference and the ACM SIGSOFT Symposium on the Foundations of
Software Engineering, ESEC/FSEâ€™13, Saint Petersburg, Russian Federation, August
18-26, 2013. 345â€“355.
[33]Boyang Li, Isil Dillig, Thomas Dillig, Ken McMillan, and Mooly Sagiv. 2013.
Synthesisofcircularcompositionalprogramproofsviaabduction.In International
Conference on Tools and Algorithms for the Construction and Analysis of Systems.
Springer, 370â€“384.
[34]Loi Luu, Duc-Hiep Chu, Hrishi Olickel, Prateek Saxena, and Aquinas Hobor.2016. Making Smart Contracts Smarter. In Proc. Conference on Computer and
Communications Security. 254â€“269.
[35]KennethLMcMillan.2006. Lazyabstractionwithinterpolants.In International
Conference on Computer Aided Verification. Springer, 123â€“136.
[36]AntoineMinÃ©.2006. Theoctagonabstractdomain. Higher-orderandsymbolic
computation 19, 1 (2006), 31â€“100.
[37]George C. Necula. 2000. Translation validation for an optimizing compiler. InProceedings of the 2000 ACM SIGPLAN Conference on Programming LanguageDesign and Implementation (PLDI), Vancouver, Britith Columbia, Canada, June
18-21, 2000. 83â€“94.
[38]DaejunPark,YiZhang,ManasviSaxena,PhilipDaian,andGrigoreRosu.2018.
A formal verification tool for Ethereum VM bytecode. In Proceedings of the 2018
ACM Joint Meeting on European Software Engineering Conference and Symposium
on the Foundations of Software Engineering, ESEC/SIGSOFT FSE 2018, Lake Buena
Vista, FL, USA, November 04-09, 2018. 912â€“915.
[39]F. Pedregosa, G. Varoquaux, A. Gramfort, V. Michel, B. Thirion, O. Grisel, M.
Blondel, P. Prettenhofer, R. Weiss, V. Dubourg, J. Vanderplas, A. Passos, D. Cour-
napeau,M.Brucher,M.Perrot,andE.Duchesnay.2011. Scikit-learn:Machine
Learning in Python. Journal of Machine Learning Research 12 (2011), 2825â€“2830.
[40]Anton Permenev, Dimitar Dimitrov, Petar Tsankov, Dana Drachsler-Cohen, and
MartinVechev.2020. Verx:Safetyverificationofsmartcontracts.In 2020IEEE
Symposium on Security and Privacy, SP. 18â€“20.
[41]Nadia Polikarpova, Ivan Kuraj, and Armando Solar-Lezama. 2016. Program
synthesis from polymorphic refinement types. Proc. Conference on Programming
Language Design and Implementation (2016), 522â€“538.
[42]Jake Silverman and Zachary Kincaid. 2019. Loop Summarization with Ratio-nal Vector Addition Systems (extended version). CoRRabs/1905.06495 (2019).
arXiv:1905.06495 http://arxiv.org/abs/1905.06495
[43]Marcelo Sousa and Isil Dillig. 2016. Cartesian hoare logic for verifying k-safety
properties. In Proceedings of the 37th ACM SIGPLAN Conference on Programming
LanguageDesign andImplementation, PLDI2016, SantaBarbara, CA,USA,June
13-17, 2016. 57â€“69.
272[44]EminaTorlakandRastislavBodÃ­k.2014. Alightweightsymbolicvirtualmachine
forsolver-aidedhostlanguages.In Proc.ConferenceonProgrammingLanguage
Design and Implementation. 530â€“541.
[45]Petar Tsankov, Andrei Marian Dan, Dana Drachsler-Cohen, Arthur Gervais,
Florian BÃ¼nzli, and Martin T. Vechev. 2018. Securify: Practical Security Analysis
ofSmartContracts.In Proc.ConferenceonComputerandCommunicationsSecurity.
67â€“82.
[46]Yuepeng Wang, James Dong, Rushi Shah, and Isil Dillig. 2019. Synthesizing data-
base programs for schema refactoring. In Proceedings of the 40th ACM SIGPLAN
Conference on Programming Language Design and Implementation, PLDI 2019,
Phoenix, AZ, USA, June 22-26, 2019. 286â€“300.
[47]Mu Zhang, Yue Duan, Heng Yin, and Zhiruo Zhao. 2014. Semantics-Aware
Android Malware Classification Using Weighted Contextual API Dependency
Graphs. In Proceedings of the 2014 ACM SIGSAC Conference on Computer and
Communications Security, Scottsdale, AZ, USA, November 3-7, 2014. 1105â€“1116.
273A SEMANTIC FEATURES USED FOR
CLUSTERING
In this section, we describe the semantic features we used when
performing our clustering analysis. These features are obtainedby constructing a type of program dependence graph (PDG) and
extractingvarioustypesofinformationfromthepathsofthecorre-
sponding PDG.
For our purposes, a program dependence graph Gis a tuple
(ğ‘,ğ¸ C,ğ¸D)whereğ‘=ğ‘Iâˆªğ‘Wâˆªğ‘Randğ‘I,ğ‘W,andğ‘Rcorre-
spond to variables of array indices, variables that are written to,
and variables (other than those that are used as array indices) that
arereadfrom,respectively. ğ¸Careedgesfrom ğ‘Rtoğ‘W,andğ¸D
are edges from nodes in ğ‘Itoğ‘W. Intuitively, an edge (ğ‘¢,ğ‘£)âˆˆğ¸D
indicates that a variable ğ‘¢is used as an index into collection ğ‘£.A n
edge inğ¸Cmodels other types of read-write dependency.
Figure8givesafewexamplesofSolidityloopsandtheircorre-
spondingPDGrepresentation.Specifically,nodesin ğ‘I,ğ‘W,and
ğ‘Rarecoloredinred,purple,andgrey,respectively.Also,dashed
arrows encodes edges in ğ¸Dwhile solid arrows denote edges in ğ¸C.
Figure8:Modelingthesemanticsofloopsusingprogramde-pendence graph.
Once we construct the graph representation, we extract the
following features from the PDG:
Pathrelated. Thefollowing8featuresrelatetopathsinthePDG.
â€¢Maximum and minimum number of ğ¸D/ğ¸C/any path from a
an od ei n ğ‘It oan od ei n ğ‘W.
â€¢Maximum and minimum number of mixed paths (involving
bothğ¸Dandğ¸Cedges) from a node in ğ‘It oan od ei n ğ‘W.
Degree related. The following 24 features relate to degrees of
nodes in the PDG.
â€¢Maximumandminimumnumberof ğ¸D-only/ğ¸C-only/mixed-
edge in-degrees of a node in ğ‘W.
â€¢Maximumandminimumnumberof ğ¸D-only/ğ¸C-only/mixed-
edge out-degrees of a node in ğ‘W.
â€¢Maximumandminimumnumberof ğ¸D-only/ğ¸C-only/mixed-
edge in-degrees of a node in ğ‘I.
â€¢Maximumandminimumnumberof ğ¸D-only/ğ¸C-only/mixed-
edge out-degrees of a node in ğ‘I.
Otherfeatures. Thefollowing5featuresareothercycleandpath-
length PDG features.â€¢Maximumandminimumnumberofcyclesinvolvingasingle
ğ‘Wnode.
â€¢Maximum, minimum and average path length from an ğ‘I
node to an ğ‘Wnode.
B SEMANTICS OF DSL CONSTRUCTS IN
TERMS OF SOLIDITY CODE
InthisAppendix,weprovideamoreformalsemantics of Consul
constructsintermsoftheirtranslationtoSoliditycode.Inparticular,
the left column in Table 7 shows a Consul construct and the right
column shows its corresponding Solidity equivalent.
Consul Construct Solidity Loop Equivalent
m4 = zipNestedASym (m1,m2,
m3, ğœ‘,
ğ‘“)for(kâˆˆkeys(m3)){
if(ğœ‘(k, m1[m3[k]]))
m4[m3[k]] = ğ‘“(m1[m3[k]],
m2[k]);
}
m4 = zipNestedSym (m1,m2,
m3,ğœ‘,
ğ‘“)for(kâˆˆkeys(m3)){
if(ğœ‘(k, m1[m3[k]]))
m4[m3[k]] = ğ‘“(m1[m3[k]],
m2[m3[k]]);
}
m3 = zip(m1,m2, ğœ‘,ğ‘“)for(kâˆˆkeys(m1)){
if(ğœ‘(k, m1[k]))
m3[k] = ğ‘“(m1[k], m2[k]);
}
m3 = mapNested (m1, m2,
ğœ‘,ğ¹)for(kâˆˆkeys(m2)){
if(ğœ‘(k, m1[m2[k]]))
m3[m2[k]] = ğ¹(m1[m2[k]]);
}
m2 = map(m1, ğœ‘,ğ¹)for(kâˆˆkeys(m1)){
if(ğœ‘(k, m1[k]))
m2[k] = ğ¹(m1[k]);
}
v= foldl (m, ğœ‘,ğ‘“, acc)v = acc;
for(kâˆˆkeys (m)){
if(ğœ‘(k, m[k]))
v= ğ‘“(v, m[k]);
}
v= foldlNested (m1, m2,
ğœ‘,ğ‘“,
acc)v = acc;
for(kâˆˆkeys(m2)){
if(ğœ‘(k, m1[m2[k]]))
v= ğ‘“(v, m1[m2[k]]);
}
require (m, ğœ‘1,ğœ‘2)for(kâˆˆkeys (m)){
if(ğœ‘1(k, m[k]))
require( ğœ‘2(k, m[k]));
}
requireNested (m1, m2,
ğœ‘1,ğœ‘2)for(kâˆˆkeys(m2)){
if(ğœ‘1(k, m1[m2[k]]))
require( ğœ‘2(k,
m1[m2[k]]));
}
transfer (m1, m2, ğ¹,ğœ‘)for(kâˆˆkeys(m1)){
if(ğœ‘(k, m1[k]))
transfer(m1 [k],
ğ¹(m2[k]));
}
Table 7: Consulconstruct equivalents. We omit lambdas to
improve readability.
274