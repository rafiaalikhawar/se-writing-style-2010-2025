SLACC:Simion-based Language AgnosticCode Clones
Ge
orge Mathew,ChrisParnin, KathrynT Stolee
NorthCarolinaStateUniversity
{george2,cjparnin,ktstolee}@ncsu.edu
ABSTRACT
Successfulcross-languageclonedetectioncouldenableresearchers
anddeveloperstocreaterobustlanguagemigrationtools,facilitate
learningadditionalprogramminglanguagesonceoneismastered,
andpromotereuseofcodesnippetsoverabroadercodebase.How-
ever,identifyingcross-languageclonespresentsspecialchallenges
totheclonedetectionproblem.Alackofcommonunderlyingrep-
resentation between arbitrary languages means detecting clones
requires one of the following solutions: 1) a static analysis frame-
work replicated across each targeted language with annotations
matching language features across all languages, or 2) a dynamic
analysisframeworkthatdetectsclonesbasedonruntimebehavior.
Inthiswork,wedemonstratethefeasibilityofthelattersolution,
adynamicanalysisapproachcalledSLACCforcross-languageclone
detection.Likepriorclonedetectiontechniques,weuseinput/out-
put behavior to match clones, though we overcome limitations of
priorworkbyamplifyingthenumberofinputsandcoveringmore
data types; and as a result, achieve better clusters than prior at-
tempts.Since clusters aregenerated based oninput/outputbehav-
ior, SLACC supports cross-language clone detection. As an added
challenge, we target a static typed language, Java, and a dynamic
typedlanguage,Python.ComparedtoHitoshiIO,arecentclonede-
tectiontoolforJava,SLACCretrieves6timesasmanyclustersand
hashigher precision(86 .7% vs.30.7%).
This is the /f_irst work to perform clone detection for dynamic
typedlanguages(precision=87 .3%)andthe/f_irsttoperformclone
detection across languages that lack a common underlying repre-
sentation (precision = 94 .1%). It provides a /f_irst step towards the
larger goalof scalable language migrationtools.
CCSCONCEPTS
•Softwareanditsengineering →Softwaremaintenancetools;
Object oriented languages ;Functional languages ; •Information
systems →Clustering .
KEYWORDS
semanticcode clone detection; cross-languageanalysis
ACM ReferenceFormat:
George Mathew, Chris Parnin, Kathryn T Stolee. 2020. SLACC: Simion-
basedLanguageAgnosticCodeClones.In 42ndInternationalConferenceon
Permission to make digital or hard copies of all or part of this work for personal or
classroomuseisgrantedwithoutfeeprovidedthatcopiesarenotmadeordistributed
for pro/f_it or commercial advantage and that copies bear this notice and the full cita-
tiononthe/f_irstpage.Copyrightsforcomponentsofthisworkownedbyothersthan
ACMmustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orre-
publish,topostonserversortoredistributetolists,requirespriorspeci/f_icpermission
and/or a fee. Request permissions frompermissions@acm.org.
ICSE’20,May23–29, 2020,Seoul, RepublicofKorea
©2020 AssociationforComputingMachinery.
ACMISBN978-1-4503-7121-6/20/05...$15.00
https://doi.org/10.1145/3377811.3380407Software Engineering (ICSE ’20), May 23–29, 2020, Seoul, Republic of Korea.
ACM,NewYork,NY,USA,12pages.https://doi.org/10.1145/3377811.3380407
1 INTRODUCTION
Modernprogrammerstypicallyworkonsystemsbuiltwithacock-
tailofmultipleprogramminglanguages[12].Arecentsurveyfound
thatprofessionalsoftwaredevelopershaveameanofsevendiﬀer-
entprogramminglanguagesintheirindustrialsoftwareprojects[30]
and open-source software projects frequently have between 2–5
programming languages [29, 43]. Programmers are also expected
to continue learning multiple programming languages on a daily
basis. Tolearn a new programminglanguage, studies have shown
that programmers attempt to use a cross-language learning strat-
egybyreusingknowledgefromapreviouslyknownlanguage[37,
38, 49]. This means programmers often need the ability to relate
code snippets acrossmultiple programminglanguages.
Traditional clone detection often works with only a single pro-
gramming language, meaning that typical applications and tools
are not applicable to modern programming systems and contexts.
These applications include bug detection in ported software [35],
maintaining quality through refactoring [52], and protecting the
securityofproducts[45].Forexample,securityteamsatMicrosoft
use clone detection to scan for other instances of vulnerable code
that might be present in any production software [8]. In short,
thereisaneedtoextendclonedetectiontoworkincross-language
contexts, but limitedsupportexists for them.
This paper presents Simion-based Language-Agnostic Code
Clone detection technique (SLACC), a cross-language semantic
clone detection technique based on code behavior. Our technique
can match whole and partial methods or functions. It works in
bothstaticanddynamiclanguages.Itdoesnotrequireannotations
or manual eﬀort such as seeding test inputs. Critically, unlike any
otherclonedetectiontechnique,weareabletodetectsemantically
similarcodeacrossmultipleprogramminglanguagesandtypesys-
tems (e.g., Pythonand Java).
SLACC /f_inds semantic clones by comparing the input/output
(IO)relationshipofsnippets,called simions(shortfor similarinput
output functions), in line with prior work [20, 40]. SLACC seg-
ments a target code repository into smaller executable functions.
Arguments for the functions are generated using a custom input
generator inspired by grey-box testing and multi-modal distribu-
tion.Functionsareexecutedonthegeneratedargumentsandsub-
sequently clustered based on the generated arguments and corre-
sponding return values. The similarity measure for clustering is
based on the IO behavior of code snippets and is independent of
their syntactic features. Hence, SLACC generates cross-language
clusterswithcodesnippetsfromdiﬀerentprogramminglanguages.
To validate our technique, using a single, static typed language,
weperformanempiricalstudywith19,188Javafunctionsderived
from Google Code Jam (GCJ) [15] submissions and demonstrate
2102020 IEEE/ACM 42nd International Conference on Software Engineering (ICSE)
ICSE’20,May23–29, 2020, Seoul, Republic of Korea M athewetal.
that SLACC identi/f_ies 6x more clones and with higher precision
(86.7% vs. 30.7%) compared to HitoshiIO [40], a state-of-the-art
code semantic clone detection technique. Using a single, dynamic
typedlanguage,weperformastudywith17,215Pythonfunctions
derivedfromGCJand/f_indthatSLACCcanidentifytruebehavioral
cloneswith87.3%precision.Forcross-languageclones,SLACC/f_inds
32 clusters with both Python and Java functions, demonstrating
that detection of code clones does not depend on a common type
system.
Insummary, thispaper makes thefollowingcontributions:
•Forsingle-languagestatictypedclonedetection,anempiri-
calvalidationdemonstratingSLACCcanbeusedtoidentify
6x more and better code clones clusters than the state-of-
the-artcode-clone detection technique HitoshiIO.
•The/f_irstexplorationofclonedetectionforadynamic-typed
language and demonstrated feasibility in Python with pre-
cisionof 87.3%.
•The/f_irstexplorationofcross-languageclonedetectionwhen
thelanguages lackanunderlyingrepresentation;SLACCis
successful in identifying cross-language clone clusters be-
tweenPythonand Javawith94.1% precision.
•An open-source tool for detection of semantic code clones
between diﬀerent programminglanguages.
2 MOTIVATION
Avery is preparing for a technical interview and was given a few
practicecodingchallenges[50]toworkon.Averyismorecomfort-
ablewritingcodeinJavaduringaninterviewsettingbutisworried
because thecompany exclusively codes inPython.As practice for
the interview, Avery wants to code with Python. First, Avery de-
cidestowritethecodeinJavatounderstandthesolution,andthen
translatethosesolutionsintoPythoncode.
One of the practice questions asks the coder to interleave the
resultsof twoarrays.Avery quickly writes thissolutioninJava:
1publicString interleave(int[] a, int[] b) {
2S
tring result = /quotedbl.Var/quotedbl.Var;
3inti =0;
4for( i = 0; i < a.length && i < b.length; i++ ) {
5 r
esult += a[i];
6 result += b[i];
7}
8int[] remaining = a.length < b.length ? b : a;
9for(intj = i; j < remaining.length; j++ ) {
1
0 result += remaining[j];
11}
12returnresult;
1
3}
WhileoneapproachistodirectlytranslatethecodeintoPython,
Averywondersifthereareotherwaystotakeadvantageofidioms
and capabilities in Python. After spending a few hours searching
StackOver/f_low[42]andGitHubGists[41],Avery/f_indsafewcode
snippetsthat seemtodo thesamething.
The /f_irst one seems a bit too complex and relies on another de-
pendency.
1deffancy_interleave(l1, l2):
2 fromitertools importchain3 return/quotedbl.Var/quotedbl.Var.join([str(x)
4 forxi nchain.from_iterable(zip(l1, l2))])
This other solution is similar to the Java solution, but is using
somethingnew,a zipfunction.Averyisexcitedtolearnsomenew
Pythontricks!
1defproblem2(l1, l2):
2 r
esult = /quotedbl.Var/quotedbl.Var
3 for(e1, e2) i n zip(l1, l2):
4 result += str(e1)
5 result += str(e2)
6 returnresult
A
veryfoundthestrategyofwritingcodeinJavaandtranslating
that code into Python helpful. However, the process of manually
searching and translating the code between languages was time-
consuming. Avery’s unfamiliaritywith Pythonmade it diﬃcult to
verify whether thesesnippetswere trulythesame.
At the interview, Avery was relieved to be asked to solve the
sameinterleave problemfromthepracticeset!However,whilecod-
ingupasolutioninPython,theinterviewerasked, doesthishandle
interleavingunevenlists? TheoriginalJava-basedsolutionhandled
thiscase,butthePythontranslationdidnot.Becausesearchingfor
code took solong, Avery never had thechance tofullyverifythat
thePythonsolutionworkedthesameastheJavasolution.Avery’s
assumptionthatthenew zipfunctionwouldworkonunevenlists
waswrong!HadtherebeenabetterwayforAveryto/f_indsemanti-
cally related snippets in other programming languages, this issue
may have beenavoided.
Inthiswork,weintroduceSLACC,whichcoulddetectthatthese
functions are not equivalent. From a corpus of code, it could in-
stead/f_indthissemanticallyidenticalsnippet—justoneofmanyap-
plications enabled bycross-languageclone detection:
1defvalid_interleave1(l1, l2):
2 r
esult = /quotedbl.Var/quotedbl.Var
3 a 1, a2 = len(l1), len(l2)
4 forii nrange(max(a1, a2)):
5 ifi < a1:
6 r
esult += str(list1[i])
7 ifi < a2:
8 r
esult += str(list2[i])
9 returnresult
3
SIMION-BASEDLANGUAGE-AGNOSTIC
CODE-CLONEDETECTION
Code clones can be broadly classi/f_ied into four types [36] as de-
scribedinTable1.TypesI,IIandIIIrepresentsyntacticcodeclones
where similarity between code is estimated with respect to the
structure of the code. On the other hand, type-IV indicates func-
tionalsimilarity.Syntacticcodeclonedetectiontechniquesareim-
practical for cross-language code clone detection as it would re-
quire an explicit mapping between the syntax of the languages.
This is feasible for syntactically similar languages like Java and
C#[11]butmuchharderfordiﬀerentlanguageslikeJavaandPython.
On the other hand semantic approaches for cross-language code
detection[33]relyonlargenumberoftrainingexamplesbetween
the languages and was yet again tested on similar programming
languages.
211SLACC:Simion-based LanguageAgnostic CodeClones I CSE’20,May23–29, 2020, Seoul, Republic ofKorea
Figure1: Highlevel work/f_low forSLACC.
W
e propose Simion-based Language-Agnostic Code-Clone de-
tection (SLACC), a semantic approach to code similarity that is
predicated on the availability of large repositories of redundant
code [2]. Instead of mapping API translations using prede/f_ined
rules [5, 11], or using embedded API translations [4, 33], SLACC
uses IO examples to cluster code based on its behavior. Further,
it relaxes the bounds of the datatypes across programming lan-
guages, which helps dynamic typed code snippets (e.g., Python)
tobeclusteredalongside statictypedcode snippets (e.g., Java).
In SLACC, we build on the ideas pioneered by EQMiner [20]
for using segmentation and random testing for clone detection.
SLACCstartsbyidentifyingsnippetsfromalargecodebaseandin-
volvesamulti-stepprocessdepictedinFigure1,whichstartswith
a)Segmentation of the code base into smaller fragments of code
calledsnippets,b) Functioncreation fromthesnippets,c) Input gen-
erationforthefunctions,d) Execution ofthefunctions,ande) Clone
detection based on clustering functions arguments and execution
results.
3.1 Segmentation
Inthe/f_irststage,codefromallthesource/f_ilesinaprojectisbroken
intosmallercodefragmentscalled snippets.Consecutivestatement
blocks of threshold MIN_STMT or more are grouped into a snippet.
Astatement block can be
(1)Declaration Statement. e.g.,intx;
(
2)Assignment Statement e.g.,x =5;
(
3)BlockStatement e.g.,static{x =10;}
(
4)Loopstatements. e.g.,for,while,do-while
(5)C onditional statements. e.g.,if,if-else-if ,switch,
(
6)TryStatement. e.g.,try,try-catch
Algorithm 1 illustrates the segmentation phase. For an AST AFo f
a function, the algorithm performs a pre-order traversal of all the
nodesintheAST(line5 )andthenusesaslidingwindowtoextract
Table1:Typesofcodeclones.TypesI,IIandIIIaresyntactic
whiletypeIVare semanticorbehavioral clones[36]
Type Description
I Identical sans whitespace andcomments
I
I IdenticalASTbutusesdiﬀerentvariablenames,types
or functioncalls
III SimilarASTbutusesdiﬀerentexpressions/statements.
For example, a) using whilein place of forloops or
b
) usingif else if in place of switchstatements.
I
V Diﬀerent syntax but behaviorally same. For example,
an iterative stack approach or a recursive approach
can be usedforbreadth /f_irstsearchof agraph.Algorithm 1 S egmentation
1:I nput: AF-AST Node
2:Output:S- Listof Segment
3:procedure S/e.sc/g.sc/m.sc/e.sc/n.sc/t.sc( AF)
4:S←ϕ
5:stmts←PreorderTra/v.alterse(AF)
6:foralli∈range(0,len(stmts)− 1)do
7: Si←{}
8: stmti←stmts[i]
9: forallj∈range(i,len(stmts)) do
10: stmtj←stmts[j]
11: Si.append(stmtj)
12: if len(Si)≥MIN_STMTSthen
13:S←S∪Si
14: ifstmtj.hasChildren() then
15:S←S∪SEGMENT( stmtj)
16:returnS
segments of size greater than a minimum segment size M IN_STMT
(lines 12-13 ). Further, for statements like Block, Loop, Conditional
and Try which have statements in its nested scope, the algorithm
is called recursivelyonthem (lines14-15).
3.2 FunctionCreation
Next, snippets are converted into executable functions. This sec-
tion describes how arguments, return variables, and types are in-
ferred.
Inferring arguments and return variables. We adapt a data/f_low
analysissimilartothatusedbySuetal.[40].Foreachmethod,po-
tential return variables are identi/f_ied as variables that are de/f_ined
or modi/f_ied within the scope of the snippet. If the last de/f_inition
ofavariableisaconstantvalue,thatvariableisremovedfromthe
set of potential return variables. Arguments are variables that are
1)usedbutnotde/f_inedwithinthescopeofthesnippet,and2)not
declared as public static variables for the class. For each potential
returnvariable inasnippet,afunction iscreated.
Inferring types. In the case of static typed languages, argument
types and return values can be inferred via static code analysis.
For dynamic typed languages, the parameters can take multiple
typesofinputarguments.Thisincreasesthepossiblevaluesofthe
arguments generated (see Section 3.3) to identify its behavior. In
many cases, the possible types for the arguments can be inferred
by parsing the code and looking for constant variables [7] in its
context. This technique has been used in inferring types in other
dynamiclanguageslikeJavaScript[18].Forexample,inthefollow-
ingPythonfunction,thetypeof ncanbeassumedtobeaninteger
since it iscompared against an integer.
1deffib(n):
2 ifn <=1:returnn
3 returnfib(n-1) + fib(n-2)
I
n cases where the types of the parameters could not be inferred
at compile time,suchas:
1defmain(a):
2 printa
212ICSE’20,May23–29, 2020, Seoul, Republic of Korea M athewetal.
1classShape {
2 public int length;
3 intwidth;
4 private int height;
5 publicShape(int l,intw,inth) {
6 l
ength=l; width=w; height=h;
7 }
8}
9publicShape func_s (int l,intw,intx) {
1
0 return new Shape(l + x, w * 2, x);
1
1}
12public int func_l (int l,intw,intx) {
1
3 returnfunc_s(l, w, x).length;
1
4}
15public int func_w (int l,intw,intx) {
1
6 returnfunc_s(l, w, x).width;
1
7}
Figure 2: An example depicting conversion of a function
with object as a return type to multiple functionswith non-
primitivemembersof theobject’s class.
a generic type is assigned (i.e., for a) allowing the argument to
assume any of the primitive types used in argument generation
(Section3.3).
Convertingobjectreturntypesintofunctions. Ifasnippetreturns
anobject,theobjectissimpli/f_iedintomultiplefunctionsreturning
each of its non-private members independently. For example, in
Figure 2, func_shas a return type of Shape. Shape has two mem-
bers,lengthandwidth. Hence,func_sis broken down into two
functions, func_landfunc_w,whichreturnthe lengthandwidth
of the shape object independently. Note that a third function for
heightis not created sinceit is aprivatemember.
Permutingargumentorder. Foreachofthesnippets,wegenerate
diﬀerentpermutationsbasedontheinputofargumentssinceorder
matters for capturing function behavior. Consider the two func-
tions in Figure 3; the /f_irst function divides awithbusing the divi-
sion(/)operatorwhiletheseconddivides dividend withdivisor
usingthesubtract(-)operatorrecursively.Fortheinputs(5,2)the
two functions would produce the values 2 and 0 respectively. But
if the arguments for the second function was reversed, it would
producethesameoutput2.Thus,foreveryfunction,wecreatedu-
plicatesindiﬀerentpermutationsofthearguments, ARGS,resulting
in|ARGS|! diﬀerent functions. To limit the creation of this explod-
ing space, we set an upper limit on the number of arguments per
functionthat isincluded inthe analysis(ARGS_MAX ).
3.3 InputGeneration
A set of inputs are required to execute the created functions. Fol-
lowingthis,clusteringisperformed.
Input creation. Inputs are generated based on argument type
andusingacustominputgeneratorinspiredbygrey-boxtesting[23]
and multi-modal distribution [20]. First, the source code is parsed1public int divide_simple (int a,intb) {
2 if(b ==0)return0
3 returna / b;
4}
5public int divide_complex (int divisor, intdividend) {
6 // Same as dividend/divisor
7 if(b ==0)return0
8 intquotient = 0;
9 while(dividend >= divisor) {
1
0 dividend = dividend - divisor;
11 quotient++;
12 }
13 returnquotient;
1
4}
Figure3:Anexampleillustratingtheneedforreorderingar-
guments.Thetwofunctionsperformintegerdivisionbutdo
not return the same return value for the same set of inputs
duetotheorderof argumentsinthefunctionde/f_inition.
and constants of each type are identi/f_ied. Next, a multi-modal dis-
tribution is declared for each of the types with peaks at the con-
stants. Finally, values for each type are sampled from this multi-
modal distribution. Our experiments create 256 inputs per func-
tion,as justi/f_iedinSection 6.1.
Memoization. Foreveryfunctionwiththesameargumenttypes,
a common set of inputs have to be used to compare them. This is
ensured using a database and the input generator. The generator
is used to create sample inputs for the given argument types and
stored in the database. For subsequent functions with the same
signaturefor thearguments,thestoredinput values arereused.
Supportedargumenttypes. SLACCcurrentlysupportsfourtypes
of arguments.
(1)Primitive. The multi-modal distribution for the argument
type is sampled to generate the inputs. This includes in-
tegers (and longs, shorts), /f_loats (and double), characters,
booleans, and strings.
(2)Objects.Objectsarerecursivelyexpandedtotheirconstruc-
torwithprimitivetypes;inputsaregeneratedforthetypes.
(3)Arrays. A random array size is generated using the input
generator for integers1. For each element in the array, a
valueisgeneratedbasedonthearraytype(PrimitiveorOb-
ject).
(4)Files:Filesarestoredasasharedresourcepoolofstringsin
thedatabase.Ifaseed/f_ile(s)isprovided,it israndomlymu-
tatedandstoredasastringinthedatabase.Intheabsenceof
aseed,constantsfromthemulti-modaldistributionaresam-
pledandstoredasstrings.Foranargumentwitha Filetype
(oritsextensions),atemporary(deletedontermination)/f_ile
object is created usingthestoredstrings.
Type size restrictions. Comparing code snippets requires com-
patiblesizesoftypesacrossprogramminglanguages.Forexample,
Java has 4 integer datatypes byte,short,intandlongwhich oc-
c
upy sizes of 1, 2, 4 and 8 bytes, respectively. On the other hand,
1If a negativeinteger is sampled, thedistribution is re-sampled.
213SLACC:Simion-based LanguageAgnostic CodeClones I CSE’20,May23–29, 2020, Seoul, Republic ofKorea
Python has two integer datatypes: intwhich is equivalent to the
longdatatype in Java and l ongwhich has an unlimited length.
Thus,wemakearestrictionwhengeneratinginputsforfunctions
across diﬀerent languages: inputs are generated from the smaller
boundofthetwoprogramminglanguages.Forexample,inthecase
ofJavaandPythonfunctionthathasan int,inputsaregenerated
w
ithinthebounds of Java.
3.4 Execution
Inthenextstage,thecreatedfunctionsareexecutedoverthegener-
ated input sets and the subsequent return values are stored. Each
function is assigned an execution time limit of TLseconds, after
which a Timeout Exception is raised. This occurs most frequently
whenthereisanin/f_initeloop,suchas while(true) w hentheloop
invariant is an argument. Each execution of the function is run
onanindependentthread.Subsequently,thereturnvalue,runtime
andexceptionfortheexecutedfunctionovertheinputsetisstored.
3.5 CloneDetection
The last stage of SLACC is identifying the clones, where the exe-
cuted functions are clustered on their inputs and outputs. SLACC
uses arepresentative based partitioning strategy [36, 40] to cluster
theexecuted functions.
Similarity Measure. In this work, a pair of functions have the
highestsemanticallysimilarityifforanygiveninput,thefunctions
returnthesameoutput.Thesimilaritymeasurebetweentwofunc-
tions is computed as the number of inputs for which the meth-
odsreturnthesameoutputvaluedividedbythenumberofinputs,
sameastheJaccardindex.Thiscreatesasimilarityvaluebetween
twofunctionswitharangeof [0 .0,1.0] with1.0beingthehighest.
Consider the functions from Section 2, interleave ,
fancy_interleave ,andvalid_interleave .Forvalues a = [2,3]
a
ndb = [4], we see that interleave(a,b) = [2,4,3] ,
f
ancy_interleave(a,b) = [ 2,4]a ndvalid_interleave(a,b)
= [2,4,3]. Functions interleave andvalid_interleave are
similar since they have the same output for the same input but
interleave andfancy_interleave are not similar. In contrast,
fora = [2,3]a ndb = [4,5], allthreefunctionswouldreturnthe
same output [2,4,3,5] . Based on these two inputs, interleave
andfancy_interleave have a similarity of 0 .5,interleave and
valid_interleave haveasimilarityof1 .0,andfancy_interleave
andvalid_interleave haveasimilarityof0 .5.Thisprocessisre-
peated for many such inputs aandbto compute similarity scores
between each pair of functions.
Functions are only compared if they have the same number of
arguments and cast-able argument types. For example, consider
the four functions f1(inta, String b), f 2(longa, File b),
f
3(File a, String b) andf4(String a) . Functions f1andf2
can be compared since intcan be cast to a longvalue. But they
c
annot be compared to f3since primitive types cannot be cast to
File. Similarly, f1,f2andf3cannot be compared f4due to the
diﬀerence innumber of arguments.
Clustering. A function is compared to a cluster by measuring
its similarity with the /f_irst function added to the cluster (calledAlgorithm 2 C lustering
1:I nput:F-List of Functions withInput andOutput
2:Output:C-List of clusters
3:procedure C/l.sc/u.sc/s.sc/t.sc/e.sc/r.sc(F)
4:C←ϕ
5:forallF∈Fdo
6: forallC∈Cdo
7: O←GetRepresentive(C)
8: if Similarity(O,F)≥SIM_Tthen
9: C←C∪F
10: break
11: if∀C∈C,F/nelementCthen
12: C|C|+1←F
13: SetRepresentative (C|C|+1,F)
14:C←C∪C|C|+1
15:returnC
representative ) .Theclusteringalgorithmisbrie/f_lydescribedinAl-
gorithm2.Anemptysetofclustersis/f_irstinitialized(line4 ).Each
function (line 5 ) is compared against each cluster (line 6 ). If the
similarity between the representative (line 7) and the function is
greater than a prede/f_ined similarity threshold, SIM_T(line 8), the
function is added to the cluster (line 9 ). If the function does not
belonginanycluster(line11),asingletonclusteriscreatedforthe
function (line 12 ) and the function is set as the cluster’s represen-
tative(line13).Thesingletonclusterisaddedtothesetofclusters
(line 14)
4 EVALUATION
OurgoalistoevaluatetheeﬀectivenessofSLACC.Thereisathree-
phase evaluation, /f_irst to compare SLACC to a comparable tech-
nique in a single, static typed language. Next, we apply SLACC to
a single, dynamic typed language (Python) and then to a multi-
language context; in both cases SLACC is compared to type-III
clones.
4.1 ResearchQuestions
SLACCisbenchmarkedagainstHitoshiIO[40]withrespecttocov-
erage and precision of code-clone detection. This leads us to our
/f_irstresearch question:
Research Question 1
H
oweﬀectiveisSLACConsemanticclonedetectioninstatic
typed languages?
Priorresearchhasalreadyshownthatsemanticclonescanbefound
in static typed languages [10, 20, 40] like C and Java. In our liter-
ature search, we failed to /f_ind techniques that identi/f_ied semantic
codeclonesindynamictypedlanguages.Therefore,weuseanAST
based comparison approach as an alternative baseline to bench-
markSLACC. Thisleads us tothenext researchquestion:
214ICSE’20,May23–29, 2020, Seoul, Republic of Korea M athewetal.
Table2:Projectsusedinthisstudywiththenumberofvalid
submissionsinboth JavaandPython.
Year Problem ID Java Python
2011 Irregular Cake Y11R5P1 48 16
2
012 Perfect Game Y12R5P1 47 24
2013 Cheaters Y13R5P1 29 19
2014 Magical Tour Y14R5P1 46 18
Total 1 70 77
Research Question 2
H
ow eﬀective is SLACC on semantic clone detection in dy-
namictyped languages?
Prior work identi/f_ied code clones between languages by mapping
APIs between similar languages (e.g., Java and C#) using prede-
/f_inedrules[11]orusinganembeddedAPItranslations[4,33].Asa
result,thesecodeclonesaresyntacticratherthansemantic.There-
fore:
Research Question 3
H
ow eﬀective is SLACC at cross-language semantic clone
detection?
4.2 Data
We validate this study on four problems from Google Code Jam
(GCJ) repository and their valid submissions in Java and Python.
GCJisanannualonlinecodingcompetitionhostedbyGooglewhere
participants solve the programming problems provided and sub-
mit their solutions for Google to test. The submissions that pass
Google’s tests are considered valid and are published online. We
use the /f_irst problem from the /f_ifth round of GCJ from 2011 to
20142. The details about the problem and submissions are in Ta-
ble2.Overallinthisstudy,weconsider247projects;170fromJava
and 77 from Python. The 170 Java GCJ submissions contain 885
methods and generated 19,188 Java functions. The 77 Python sub-
mission contains 301 methods and generated 17,215 Python func-
tions.
The code, projects and execution scripts for the project can be
foundinour GitHubRepository[28].
4.3 Experimental Setup
The experiments were run on a 16 node cluster with each node
havinga4-coreAMDopteronprocessorand32GBDDR31333ECC
DRAM.Our experiments havefour hyper-parameters
•Minimum size of snippet (MIN_STMT - Section 3.1): We set
thisto2tocapture snippetswithinterestingbehavior.
•Maximumnumberofarguments(ARG_MAX -Section3.2):This
value is set to 5. Hence if a snippet has more than 5 argu-
ments,itis omittedfromtheexperiments.
2Early rounds have many submissions to create a reasonably scoped experiment.
Thus,wechosesubmissions from thequarter/f_inals in round /f_ive.•Number of executions (Section 3.4): We execute each snip-
pet with 256 generated inputs (Section 3.3); see Section 6.1
for details onthis choice.
•SimilarityThreshold(SIM_T -Section3.5):Wesetthisto1.0
forourexperiment.Thisimpliesthattwofunctionsareonly
considered to be clones if for allinputs they generate the
same outputs.
Sensitivitytothenumberofexecutionsand ARG_MAXisexplored
and discussedinSections 6.1 and6.2 respectively.
4.4 Metrics
Our study uses three metrics primarily to address the research
questions wepose.
•NumberofClusters:Aclusterisacollectionoffunctions
withacommonproperty(i.e.,typeI-IVsimilarity).Thismet-
ricisthenumberofclustersgeneratedbyaclonedetection
algorithm.Thisisrepresentedas|Clusters|,#Clustersor#C.
•NumberofClones:Afunctionthatbelongstoaclusteris
called a clone. This metric is the total number of functions
in all the clusters generated by a clone detection algorithm.
Thisisrepresented as |Clones|,#Clones or #M.
•Number of False Positives: A false positive is a cluster
which contains one or more functions which does not ad-
here to the similarity measure of the cluster. This is repre-
sented as|False Positive|, #FalsePositives or #FP.
4.5 Baselines
ToanswerRQ1,RQ2,andRQ3,weusebaselinetechniquestoillus-
tratethecapabilities of SLACC.
4.5.1 RQ1:HitoshiIO. Asabaseline,weusetheclosesttechnique
to ours, HitoshiIO [40]. This tool identi/f_ies functional clones for
JavaVirtualMachine(JVM)basedlanguagessuchasJavaandScala.
Itusesin-vivoclonedetectionandinsertsinstrumentationcodein
the form of control instructions [47] in the application’s bytecode
to record input and output values at runtime. Inputs and outputs
are observed using the existing workloads, which allows it to ob-
serve behavior and identify clones in code for which input gener-
ators cannot generate inputs. The methods with similar values of
inputs and outputs during executions are identi/f_ied as functional
clones. HitoshiIO considers every method in a project as a poten-
tial functional clone of every other method and returns pairs of
clones. For comparison against SLACC, we group the pairs into
clusters as follows: two pairs of clones are grouped into a cluster
if both the pairs have a common function between them (i.e., for
pairs (A,B) and (B,C),a clone clusteris created with(A,B,C)).
Like the similarity threshold SIM_Tin SLACC, HitoshiIO has
a similar parameter that provides a lower bound on how similar
twomethodsmustbetobeconsideredafunctionalclone.Aswith
SLACC,HitoshiIOalsohasaparameterforanupperboundonthe
number of IOpro/f_iles consideredfor each method.
We used an existing and public implementation of HitoshiIO.3
TheworkloadusedtobenchmarkHitoshiIOwithGCJarethesam-
ple test input /f_iles. GCJ provides only two sample input /f_iles for
3github.com/Programming-Systems-Lab/ioclones;
Commithash: aa5b5b3; Dated: 05/06/2018
215SLACC:Simion-based LanguageAgnostic CodeClones I CSE’20,May23–29, 2020, Seoul, Republic ofKorea
a validating a submission. However, in SLACC each method was
executed256times.Tocreateabalancedbenchmark,werandomly
fuzzed the test input /f_iles 32 times before sending it to HitoshiIO.
Notethatwetriedfuzzingthe/f_iles256timesbuttheclone-detection
phaseof HitoshiIOcrashedfor largenumbers of inputs.
4.5.2 RQ2:AutomatedASTComparison. Tothebestofourknowl-
edgewecouldnot/f_indapriorworktodetectsemanticcodeclones
indynamiclanguages.HencewebenchmarkedSLACCfordynamic
andcross-languageclonesbymatchingtheAbstractSyntaxTrees
(ASTs) as a proxy for similarity. This technique has been adopted
bymanygraph-based(anexampleoftype-IIIclone)codeclonede-
tectiontechniques inC[3,19,51]and Java [19,25].
Like SLACC, the /f_irst phase of the AST comparison segments
the code into snippets. Next an AST is generated for the snippets.
We use the JavaParser [44] tool and Python AST [34] module to
construct the ASTs in the respective languages. We measure simi-
laritybymatchingtheASTs.Forclonesinthesameprogramming
language(RQ1,RQ2),wematchtheASTsandconsiderthemtobe
type-IIIclonesiftheASTsareequivalentorhaveadiﬀerenceofat
mostone node.
4.5.3 RQ3: Manual Cross-language AST Comparison. The
automatedASTcomparisonapproachcannotbeadoptedforcross-
languageclones(RQ3)duetothediﬀerenceinformatoftheASTs
for both the languages. In this case, conservatively, we sampled
cross-language snippets with extremely similar outputs and man-
uallyveri/f_iedtheASTsforsimilarity.Todothis,werandomlysam-
ple1millionpairsof aJavafunctionandaPythonfunction.If the
input and output types are compatible, and the outputs are the
sameforthesameinputsoroﬀbya consistent value,thenweman-
ually evaluate the ASTs for similarity. Consistency is determined
based on the output type. Values of primitive types are consistent
iftheyhaveaconstantdiﬀerence(forBooleanorNumericvalues),
constant ratio (for Boolean or Numeric values) or constant Leven-
shteindistance[48](forStrings)betweentheoutputs.Objectsare
consistent if each member of the object is consistent. Finally, two
arraysareconsistent,ifallthecorrespondingmembersofthearray
areconsistent.
Forexample,giventwomethods, intA(intx)a nddefB(y),
ifA
(1) =1,B (1) = 9,A (2) = 2, andB (2) = 18, thenA () and
B()aresimilarsincetheiroutputshaveaconstantratio(9).Ofthe
616 similar pairs, all had identical ASTs or had a diﬀerence of at
mostone node,making themtype-III clones.
4.6 Precision Analysis
SLACC and HitoshiIO are both clustered using IO relationships
of the functions. However, given a diﬀerent set of inputs, some
functionsinaclustermightproduceadiﬀerentsetofoutputssuch
thattheyarenotclones;suchclustersaremarkedas falsepositives
and considered invalid. We identify false positives at the cluster-
level inkeepingwith priorwork[20].
To detect false positives, SLACC clusters are re-executed on a
new set of 256 inputs generated using random fuzzing [20] based
onatriangulardistribution,andclustered.Ifanymethodinaclus-
ter is not grouped into the same cluster using the new input set,
the whole cluster is marked as a false positive. We observe thatTable 3: Number of whole method clones identi/f_ied by
HitoshiIO( H), SLACC( S) and both the approaches, after ac-
countingforfalsepositives.
Problem HitoshiIO( |H|) SLACC(|S|)|H∩S|
IrregularCake 3 44 3
Pe
rfect Game 4 35 4
Cheaters 4 21 4
Magical Tour 9 35 9
Total 2 0 135 20
thenumberofclustersandfalsepositivesisrelativelystableabove
6
4 inputs(Section 6.1).
TodetectfalsepositivesinHitoshiIO,werandomlyfuzzthetest
input /f_iles 32 times (Section 4.5) to generate a new test /f_ile that is
32x the size of the original, and then re-execute HitoshiIO. Clone
pairs are clustered and false-positives are detected when a new
cluster does not match anoriginalcluster, asdone for SLACC.
False positives in clusters generated by AST comparisons are
identi/f_ied in a similar manner to SLACC. ASTs in the clusters are
/f_irstconvertedtofunctions(asdescribedinSection3.2).Thefunc-
tionsarere-executedon256inputslikeSLACCclustersandchecked
forfalsepositives.Anyclusterthatcontainsadiﬀerentmethodaf-
ter execution is markedas a falsepositive.
5 RESULTS
The results show that SLACC identi/f_ies more method level clones
compared to prior work and with higher precision (RQ1), success-
fully identi/f_ies clones in dynamic typed languages (RQ2), and suc-
cessfullydetects clones between Java andPython(RQ3).
5.1 RQ1:Static Typed Languages
The885Javamethodsgenerated19,188Javafunctionsforanaly-
sis.SLACCwasabletosupport691ofthe885Javamethods.From
the 691 whole methods, 18,497 functions are derived into partial
method snippets. Of the total generated functions, 4,180 (22%) are
clones resulting in 632 clusters. These 4,180 clones derive from
4,038partial-methodsnippetsand142wholemethods.Wecallthem
statementlevel clones and methodlevel clones, respectively.
5.1.1 Methodlevelclones. WebenchmarkSLACCagainstHitoshiIO
by comparing clones detected by SLACC at a method level granu-
larity.Weprovideall885JavamethodstoHitoshiIO,whichgroups
43 of the methods into 13 clusters. False positives were identi/f_ied
for 9 of the 13 clusters (precision=30.7%).4The remaining valid
clusters from HitoshiIO contain 20 methods. From the 691 Java
methods, SLACC detected 142 methods, grouped into 15 clusters.
False positives were identi/f_ied for 2 of the 15 clusters (precision =
86.7%). The remaining valid clusters for SLACC contain 135 meth-
ods.
Table3showsthenumbersofvalidclustersforeachapproach,
as well as their intersection. All valid clusters from HitoshiIO are
4False positive rates in the original HitoshiIO paper [40] are computed at the pair-
level rather than cluster level and used student opinions rather than code behavior,
which may accountfortherelatively lowprecision reported here.
216ICSE’20,May23–29, 2020, Seoul, Republic of Korea M athewetal.
SLACCs tmt
1importY14R5P1.stolis.MMT3 // Parent Class MMT3
2public static int func_a(BufferedReader br){
3// Snipped from Y14R5P1.stolis.MMT3.main()
4if(!MMT3.in.hasMoreTokens())
5 M
MT3.in=newStringTokenizer(br.readLine());
6inta = Integer.parseInt(MMT3.in.nextToken());
7returna;
8}
SLACCm ethod
1importY12R5P1.xiaowuc.A // Parent Class A
2public static int func_b(Scanner in) {
3// Y12R5P1.xiaowuc.A.next()
4while(A.tok==null|| !A.tok.hasMoreTokens()) {
5 A
.tok=newStringTokenizer(in.readLine());
6}
7returnInteger.parseInt(A.tok.nextToken());
8}
HitoshiIO
1public static int func_c(StreamTokenizer in) {
2// Y11R5P1.burdakovd.A.nextInt()
3i n.nextToken();
4return(int) in.nval;
5}
1public static int func_d(StreamTokenizer in) {
2// Y11R5P1.Sammarize.Main.next()
3i n.nextToken();
4returnInteger.parseInt(in.nval);
5}
1importY14R5P1.eatMore.A // Parent Class A
2public static int func_e(Scanner in) {
3// Y14R5P1.eatMore.A.next()
4A .in = in;
5returnInteger.parseInt(A.nextToken());
6}
1public static int func_f(Scanner sc) {
2// Snipped from Y11R5P1.dooglius.A.go()
3intnext = sc.nextInt();
4returnnext;
5}
Fi
gure4:SemanticclustersdetectedbyHitoshiIO,SLACCon
methodlevel (SLACC method) and SLACC onstatement level
(SLACC stmt).Theclustercontainsfunctionsthattakeanob-
ject thatreads a/f_ileandreturns thenextIntegertoken.
containedwithinthevalidclustersforSLACC,( H≡H∩S),demon-
strating that among the valid clones, SLACC subsumes HitoshiIO
forthisexperiment.However,thelowprecisionforHitoshiIOmay
beduetotheuseoflimitedinputsortheexecutioncontext,sofur-
therinvestigation isneeded for generalization of this result.
AnexampleofaclusterthatcontainsmethodsfrombothSLACC
andHitoshiIOisshowninFigure4.Theclustercontainsfunctions
that take an object that reads a /f_ile and returns the next IntegerTable 4: # of Java, Python and Cross language clusters de-
tected by SLACC compared against AST (Type-III)clusters.
Java Python Java+Python
SLACC AST SLACC AST SLACC AST
#Clusters 6 32 6122 482 3971 34 616
#Valid 584 226 421 181 32 25
Precision 92.4 3.7 87.3 4.6 94.1 4.1
token. Functions f unc_candfunc_dare clones detected by Hi-
toshiIO. Within the same cluster, SLACC methodadditionally iden-
ti/f_ies two more method level clones that were not detected by Hi-
toshiIO:func_bandfunc_e.
5.1.2 Statement level clones. Additionally, SLACC identi/f_ies 624
clusters with 4,038 statement level code clones. Of these, 48 clus-
tersarefalsepositives(precision=92.3%).Thelargenumberofcode
clonesisintuitivebecauseeachmethodcancontainmultiplemod-
ular functionalities. That said, it should be noted that the higher
precisionforstatementlevelclusterswouldleadustobelievethat
detecting clones forsuccinct behavior ismoreaccurate.
Statementlevelclonescanbeclusteredwithwholemethodclones.
For example, in Figure 4, SLACC stmtrepresents a SLACC cluster
based on partial methods: func_aandfunc_fare functions seg-
mentedfromthe mainmethodinclass Y14R5P1. stolis.MMT3 and
t
hegomethodin Y11R5P1. dooglius.A ,respectively.
RQ1:Me thod level clones: SLACC identi/f_ies more method
level clones compared to HitoshiIO at higher precision.
Statementlevelclones: Segmentationofcodeincreasesthe
precisionofSLACCandyieldsahighernumberofseman-
tic clones.
5.2 RQ2:Dynamic Typed Languages
SLACCidenti/f_iedthat3,135(18.2%)ofthe17,215extractedPython
functionshadcloneswhichresultedin482cloneclusters.Ofthese
482clusters,421arevalid,resultinginprecisionof87.3%.Asabase-
line,usingthesamePythonfunctions,wesystematicallylookedfor
type-III clones. There exists 3,971 clusters, of which 181 are valid
(4.6% precision); these results are shown in the Pythoncolumn of
Table4,where ASTshowsthetype-IIIclones.Forsakeofcompar-
ison,theexperimentwasrepeatedforJavaclones;asimilardiﬀer-
ential between SLACC and AST precision was observed (92.4% vs.
3.7%).
Whentheseclustersarevalidated,61ofthe482SLACCclusters
(12.8%) were deemed to be false positive. This is more than the
percentageoffalsepositivesinJava(7 .3%),butwesuspectthatby
executingthefunctionsoveralargersetgeneratedarguments,the
subsequent clusteringcould yieldmore robustresults.
An example of Python clones identi/f_ied by SLACC can be seen
inFigure5.Boththefunctionsinthisexamplecomputethesumof
an array. func_db8e uses a loop that maintains the running sum
where each index in the array contains the array sum until that
index.Thelastindexofthearraywouldcontainthearraysumand
217SLACC:Simion-based LanguageAgnostic CodeClones I CSE’20,May23–29, 2020, Seoul, Republic ofKorea
1deffunc_db8e(a):
2 n
= len(a)
3 sum0 = [ 0] * (n + 1)
4 forii nxrange(n):
5 sum0[i + 1] = sum0[i] + a[i]
6 a
llv = sum0[- 1]
7 returnallv
1deffunc_43df(items):
2 _
sum = sum(items)
3 j = len(items) - 1
4 return_sum
Fi
gure 5: Semantic cluster of Python functions detected by
SLACC.Theclustercontainsfunctionsthatreturnsthesum
ofan inputarray.
1static long func_3b0e (Long[] x2) {
2 L
ong res = null;
3 L
ong[] arr = x2;
4 intlen = arr.length;
5 for(inti =0; i < len; ++i) {
6 longxx = arr[i];
7 if(xx >= res)
8 continue;
9 r
es = xx;
10 }
11 returnres;
1
2}
1deffunc_6437 (y):
2 y
min = min (y)
3 count = 0
4 returnymin
Fi
gure 6: Semantic cluster of a Java function and a Python
functiondetectedbySLACC.Theclustercontainsfunctions
thatreturnstheminimumvalueinan inputintegerarray.
iseventuallyreturned.Incontrast, func_43df usesthesumlibrary
functiontoperformthe sametask.
RQ2:S LACCcansuccessfullyidentifycodeclonesfordy-
namictyped languages withhighprecision(87.3%).
5.3 RQ3:AcrossProgrammingLanguages
We execute SLACC on the Java and Python projects from GCJ.
From 36,403 extracted snippets, SLACC identi/f_ied 131 Java and 48
Pythonfunctionsclusteredinto34cross-languageclusters(single-
language clusters are omitted from the RQ3 analysis). On valida-
tion, we /f_ind that 2 of these 34 (5 .8%) clusters are false positives
whichisbetterthanthepercentageoffalsepositivesfoundinJava
andPythonindependently.Thatsaid,SLACCwouldproducemore
clusterswhensupport forthe languages is broadened.
Wediscover616type-IIIclustersbycomparingtheASTsofJava
andPythonsnippets(Table4),ofwhich25clustersarevalid(4.1%
precision). It should be noted that this is a conservative precision
estimate;thebaselinewascreatedbystartingwithclosebehavioralTable 5: Mean and variance (in parenthesis) of # clones,
# clusters and # false positives for 20 repeats when # in-
puts varying between 8-256. The mean (and variance) are
reported.
#Inputs # Clones #Clusters #False Positives
8 4461(85) 218(16) 184(19)
1
6 4297(49) 355(17) 142(19)
32 4221(23) 412(13) 101(5)
64 4194(4) 623(6) 71(3)
128 4180(0) 630(1) 52(0)
256 4180(0) 632(0) 50(0)
matches,hencegivingtheASTanalysisaslightedgeonprecision
(
Section 4.5.2).
An example of a pair of Java-Python clones can be seen in Fig-
ure 6.func_3b0eis a Java function that uses a loop to /f_ind the
minimum in an array while func_6437 is a Python function uses
the inbuilt minfunctioninPython.
RQ3:S LACCsucceedsinidentifyingclonesbetweenpro-
gramming languages irrespective of theirtyping.
6 DISCUSSION
WehavedemonstratedhowSLACCcansuccessfullyidentifyclones
in single-language, multi-language, static typed language, and dy-
namic typed language environments. Compared to prior art (Hi-
toshiIO),SLACCidenti/f_iesasupersetoftheclustersandwithhigher
precision. Compared to type-III clone detection, SLACC achieves
a much higher precision in Python and in cross-language situa-
tions. This would lead us to believe that traditional methods that
detect syntactic type-III clones cannot be used for cross-language
clonedetection,despitesuccessfulapplicationsinsinglelanguages
foridentifyinglibrarieswithreusablecode[6],detectingmalicious
code[45],catchingplagiarism[1]andidentifyingopportunitiesfor
refactoring [31].
Next,weexplorethesensitivityofcodeclonestothenumberof
inputs,thenumber of arguments,and thesizeof the snippets.
6.1 Impact of input sizes
Prior studies have shown that varying the number of inputs can
alter the accuracy of clone detection techniques [20, 24, 46]. This
wasparticularlyevidentintheearliestclonedetectiontechniques
by Jiang and Su [20] where the authors limited the number of in-
putsto10withamaximumof120permutationsoftheinputdueto
theneedforlargecomputationalresourcesandthecorresponding
runtime.
We test the impact on clones, clusters, and false positives by
varying the number of inputs from 8 to 256 in powers of 2 and
repeating SLACC using the generated Java functions. Each exper-
iment is repeated 20 times on a set of randomly generated inputs.
Foreachsetofinput,werecordthemeanandvarianceforthenum-
berofclones,clustersandfalsepositives,asshowninTable5.For
218ICSE’20,May23–29, 2020, Seoul, Republic of Korea M athewetal.
Figure 7: Cumulative # clones with # arguments varying be-
t
ween1-5.
Figure 8: # clones for lines of code between ranging from
1
-29.Cloneswith30 ormorelinesare grouped into30+
a given number of inputs, each row represents the mean and vari-
ance (in parenthesis) of the number of clones, clusters and false
positives.Forlownumbersofinputs,weseemorefunctionsbeing
marked as clones and fewer clusters. As the number of inputs in-
creases, the number of clones reduces and the number of clusters
increases, demonstrating that the additional inputs are critical at
diﬀerentiating behavior between functions. The counts of clones,
clusters,andfalsepositivesappeartoplateauafter64inputs.This
highlights that 10 inputs used by Jiang and Su would not be suﬃ-
cientforoptimallyidentifyingtruefunctionalclonesandwilllead
toalargenumberoffalsepositives,assuggestedinpriorwork[9].
6.2 In/f_luenceof argumentsin clones
Weuseourengineeringjudgmenttoset ARGS_MAX = 5(Maximum
numb
er of Arguments) to limit the number of functions gener-
ated from snippets. Figure 7 represents the cumulative number of
cloneswithargumentsvaryingfrom1to5andcanbeusedtojus-
tifyourchoiceof ARGS_MAX .MostclonesdetectedbySLACChave
two arguments or less. In Java functions, 3252 of 4180 clones de-
tected have less than three arguments. Cross-language functions
are fewer in number and typically contain functions with 2 argu-
mentsorless(125outof131).Thiswouldseemintuitiveasmodu-
lar functions are more frequent compared to complex functionali-
ties. AsARGS_MAX increases, it begins to plateau around 3. Hence,
alargervalueof ARGS_MAX maynotyieldsigni/f_icantlylargernum-
ber of code clones but would incur more computational resources
(ARGS_MAX! functionexecutions).6.3 Clonesvs LinesOf Code
Priorworksuggeststhereismorecoderedundancyatsmallerlev-
els of granularity [40]. Aggregating all the cloned functions iden-
ti/f_ied by SLACC in RQ1, RQ2, and RQ3, we have 6,536 total, valid
cloned functions in Java and Python (duplicates removed, as the
samefunctioncouldbeincludedinanRQ1andanRQ3cluster,for
example).
Figure8representsthenumberofcloneswithlinesofcodevary-
ingfrom1to29.Cloneswith30ormorelinesaredenotedas“30+".
Morethan50%ofthevalidJavacloneshave6linesofcodeorless
(2037/3845),whilethemedianofvalidPythoncloneshave5linesor
less(1372/2691).Thisimpliesthatsnippetswithmorelinesofcode
aremoreuniqueandhardertoclonefunctionally.Onthecontrary,
smaller snippets are more likely to contain clones in a code base.
ThegreatermedianforJavaclonescomparedtoPythonclonescan
beattributedtotheverbosityinJavacomparedtothesuccinctna-
tureof Python[17].
7 RELATED WORK
In keeping with the survey on code clones by Roy et al. [36], re-
search on code clones can broadly be classi/f_ied as syntactic [3, 14,
19, 21, 26, 27], which represent structural similarities, and seman-
tic[10, 20,39,40],whichrepresent behavioral similarities.
EQMiner [20] is the closest related work with respect to our
methodology. They examined the Linux Kernel v2.6.24 by using a
similar segmentation procedure, used 10 randomly generated in-
putstoexecutethem,andclusterbasedonIObehavior.Compared
with SLACC, EQMiner crucially ignores cross-language clone de-
tection.Furthermore,theimplementationofEQMinercontainssev-
erallimitations,notedbyDeissenboeck[9],thatmakecross-language
detectioninfeasibleandevenreplicationitselfimpractical.Asare-
sult,webuildontheideaspioneeredbyEQMiner,whileovercom-
inglimitationsinitsoriginaldesign.Weintroducenovelcontribu-
tions,suchasusinggrey-boxanalysistoovercomethelimitations
ofsimplerandomrandomtesting,scaletheinputgenerationphase
from 10 to 256 inputs, which drastically reduces false positives,
introduce several steps and components to support complex lan-
guage features, such as lambda functions, and handle diﬀerences
arisingfromcross-languagetypes.Finally,SLACCintroduces/f_lex-
ibility in clustering as it permits a tolerance on similarity due to
theSIM_Thyper-parameter.
HitoshiIO [40] by Su et al. also performs simion-based compar-
isonstoidentifyclones.Itusesexistingworkloadsliketest-casesor
‘main’ function calls to collect values for the behavior rather than
the random testing approach proposed in EQMiner or the grey-
box analysis approach used in SLACC. Research shows that exist-
ing unit tests do not attain complete code coverage [16] and as a
result, the application of such a technique to open source reposi-
tories might not be produce a comprehensive set of clones. This
conjecture can be observed in RQ1 where SLACC identi/f_ies more
clones to HitoshiIO by an order of magnitude. Further, HitoshiIO
operates at a method level granularity while SLACC can operate
atmethodorstatementlevelgranularity.Naturally,thisensuresa
greater number of code clones since SLACC can identify succinct
behavior incomplex code snippets.
219SLACC:Simion-based LanguageAgnostic CodeClones I CSE’20,May23–29, 2020, Seoul, Republic ofKorea
LASSO [22] by Kessel and Atkinson, like HitoshiIO, is another
clonedetectiontechniqueformethodlevelclonesfromlargerepos-
itories using test cases. But unlike HitoshiIO, it does not use pre-
de/f_ined test cases; LASSO generates test cases using random gen-
eration via Evosuite [13]. That said, LASSO has many deviations
compared to HitoshiIO and SLACC. Firstly, LASSO identi/f_ies only
clones that have the same signature and method name (exclud-
ing case). Secondly, it detects clones only in methods where the
arguments are primitive datatypes, boxed wrappers of primitives,
strings, and one dimensional arrays of these datatypes. It fails to
supportobjects;SLACCsupportsobjectsthatcanbeinitializedre-
cursively using constructors of its members(Section 3.3). Finally,
LASSOsupportsonlystronglytypedlanguagesasitdoesnothave
atypeinference engine likeSLACC does.
Mostclonedetectiontechniques[3,14,19,21,26,27]havebeen
proposedforsinglelanguageclonedetection.Withrespecttocross
language clone detection, we failed to /f_ind any techniques based
onsemanticbehaviorofcode.Asmallnumberoftechniqueshave
been proposed on syntactic code features [32, 33]. API2Vec [33]
detectsclonesbetweentwosyntacticallysimilarlanguagesbyem-
beddingsourcecodeintoavectorrepresentationandsubsequently
comparing the similarity between vectors to identify code clones.
CLCDSA [32], identi/f_ies nine features from the source code AST
and uses a deep neural network based model to learn the features
anddetect crosslanguage clones.
SegmentationusedinSLACCisinspiredbymethodsthatparse
ASTs of the source code [3, 19]. These methods encode the ASTs
into intermediate representations and do not account for the se-
mantic relationships. For example, DECKARD [19] characterizes
sub-treesoftheASTintonumericalvectorsandclustersthembased
on the Euclidean distance which fails to capture the behavior of
codeintheclusters[20].Thislimitationhasbeenobservedinother
syntacticmethodsaswellandisareasonforadoptionofsemantic
techniques todetect code clones [20].
8 LIMITATIONSANDTHREATS
Threatstoexternalvalidityincludethefocusontwolanguagesas
instances of static and dynamic typing, so results may not gener-
alize beyond Java and Python. The use of GCJ code may not gen-
eralize to more complex code bases. Threats to internal validity
include that for RQ3, where we “help" the AST matching by start-
ing with behavioral clusters and then determining if the ASTs are
similar; which overestimates the precision of cross-language AST
matching.
Our implementation of SLACC hasthe followinglimitations:
Dynamic Typing. SLACC does not support two primitive types
longandcomplexforPython.Thatbeingsaid,weveri/f_iedthatthe
GCJ projects used in this study, do not explicitly use these values
in the source code and they are not present in the input /f_ile used
by the baseline HitoshiIO. Further, in case of a failure to identify
the type of a function argument, the function was fuzzed with ar-
guments of all supported types. In this study, we supported prim-
itive types and the simple data-structures tuple,set,listanddict.Supportforothersophisticateddata-structurescanbeincor-
poratedbyextendingtheexistingSLACCAPIwithinstructionsin
the wiki[28].
Unsupported Features. Although SLACC supports Object Ori-
ented features such as inheritance and encapsulation, it is limited
toobjectsderivedfromprimitivetypes.Hence,thecurrentversion
of SLACC cannot scale to more sophisticated objects like Threads
andDatabaseConnections.Similarly,forPythonwedonotsupport
moduleslikegeneratorsanddecorators.Nevertheless,itwouldbe
possibletosupportthesefeatures withmore engineeringeﬀort.
Dead Code Elimination: In the code-clone examples of Figure 5
andFigure6,weseethepresenceoflinesofcodethatdonotin/f_lu-
encethereturnvaluei.e.,DeadCode.Atthemoment,thefunctions
donotfailduetodeadcodebuteliminatingthemwouldmakethe
functions more succinct and comprehensible. This will be an av-
enue for futurework forspeci/f_ic applications of SLACC.
9 CONCLUSION
Inthispaper,wepresentSLACC,atechniqueforlanguage-agnostic
code clone detection that precisely yields semantic code clones
across programming languages. This is the /f_irst research to iden-
tify semantic code clones in a dynamic typed language and also
across diﬀerently-typed programming languages. SLACC identi-
/f_iesclonesbycomparingtheIOrelationshipofsegmentedsnippets
of code from a target repository. Input values for the segmented
code are generated using multi-modal grey-box fuzzing. This re-
sults in fewer false positives compared to current state of the art
semantic code clone detection tool, HitoshiIO. In our study, we
identify code clones between Java and Python from Google Code
Jam submissions. Compared to HitoshiIO, SLACC identi/f_ies sig-
ni/f_icantly (6 x) more code clones, with greater precision (86 .7% vs.
30.7%). SLACC also detects code clones in a multi-language code
corpora.Thenumberofclonesdetectedwasfewerandthenumber
offalsepositiveswasslightlymorecomparedtocodecloneswithin
thesamelanguage.However,futureworkthatbroadenslanguage
support is likely to improve these metrics. These results have im-
plications for future applications of behavioral code clones, such
as enabling robust language migration tools or mastery of a new
programminglanguage once oneis known.
SLACCisopen-sourceandthedatausedinthisstudyispublicly
available [28].
ACKNOWLEDGMENTS
Special thanks to Fang-Hsiang Su, Jonathan Bell, Gail Kaiser and
SimhaSethumadhavanformakingHitoshiIOpubliclyavailable.We
would also like to thank the anonymous reviewers for their valu-
able feedback. This material is based upon work supported by the
National Science Foundation under Grant No. 1645136 and Grant
No. 1749936.
REFERENCES
[1] BrendaSBaker.1995. On/f_indingduplicationandnear-duplicationinlargesoft-
ware systems. In Proceedings of 2nd Working Conference on Reverse Engineering.
IEEE,86–95.
[2] EarlTBarr,YuriyBrun,PremkumarDevanbu,MarkHarman,andFedericaSarro.
2014. The plastic surgery hypothesis. In Proceedings of the 22nd ACM SIGSOFT
InternationalSymposiumonFoundationsofSoftwareEngineering .ACM,306–317.
220ICSE’20,May23–29, 2020, Seoul, Republic of Korea M athewetal.
[3] IraDBaxter,AndrewYahin,LeonardoMoura,MarceloSant’Anna,andLorraine
Bier.1998. Clonedetectionusingabstractsyntaxtrees.In SoftwareMaintenance,
1998.Proceedings.,International Conference on . IEEE,368–377.
[4] JonathanBeit-Aharon.2002.Sourcecodetranslation. USPatentApp.15/894,096.
[5] StephenWBowlesandGeorgeEBethkeJr.1983. Multi-passsystemandmethod
forsourcetosourcecodetranslation. USPatent 4,374,408.
[6] Elizabeth Burd and John Bailey. 2002. Evaluating clone detection tools for
use during preventative maintenance. In Proceedings. Second IEEE International
Workshopon SourceCode AnalysisandManipulation.IEEE,36–43.
[7] Patrick Cousot and Radhia Cousot. 1977. Abstract interpretation: a uni/f_ied lat-
tice model for static analysis of programs by construction or approximation of
/f_ixpoints.In Proceedingsofthe4thACMSIGACT-SIGPLANsymposiumonPrinci-
plesofprogramminglanguages .ACM,238–252.
[8] Yingnong Dang, Dongmei Zhang, Song Ge, Ray Huang, Chengyun Chu, and
Tao Xie. 2017. Transferring Code-clone Detection and Analysis to Practice. In
Proceedingsofthe39thInternationalConferenceonSoftwareEngineering:Software
Engineering in Practice Track (Buenos Aires, Argentina) (ICSE-SEIP ’17) . IEEE
Press, Piscataway, NJ,USA,53–62. https://doi.org/10.1109/ICSE-SEIP.2017.6
[9] FlorianDeissenboeck,LarsHeinemann,BenjaminHummel,andStefanWagner.
2012. Challenges of the dynamic detection of functionally similar code frag-
ments. In Software Maintenance and Reengineering (CSMR), 2012 16th European
Conference on. IEEE,299–308.
[10] Rochelle Elva and Gary T Leavens. 2012. Jsctracker: A semantic clone detection
toolforjavacode. TechnicalReport.UniversityofCentralFlorida,Dept.ofEECS,
CSdivision.
[11] Alexandre Fau and Reinhold Bihler. [n.d.]. Java2CSharp.
http://sourceforge.net/projects/j2cstranslator/. Accessed: 2018-09-25.
[12] Hans-ChristianFjeldberg.2008. Polyglotprogramming . Ph.D.Dissertation.Mas-
ter thesis, Norwegian University of Science and Technology, Trondheim/Nor-
way.
[13] Gordon Fraser and Andrea Arcuri. 2011. EvoSuite: automatic test suite genera-
tion for object-oriented software. In Proceedings of the 19th ACM SIGSOFT sym-
posiumandthe13thEuropeanconferenceonFoundationsofsoftwareengineering .
ACM,416–419.
[14] Mark Gabel, Lingxiao Jiang, and Zhendong Su. 2008. Scalable detection of se-
manticclones.In Proceedingsofthe30thinternationalconferenceonSoftwareen-
gineering.ACM,321–330.
[15] Google.[n.d.]. GoogleCodeJam. code.google.com/codejam. Accessed:2018-09-
25.
[16] Rahul Gopinath, Carlos Jensen, and Alex Groce. 2014. Code coverage for suite
evaluation by developers. In Proceedings of the 36th International Conference on
SoftwareEngineering .ACM,72–82.
[17] Diwaker Gupta. 2004. What is a good /f_irst programming language? Crossroads
10, 4(2004), 7–7.
[18] Simon Holm Jensen, Anders Møller, and Peter Thiemann. 2009. Type analysis
forJavaScript.In InternationalStaticAnalysisSymposium.Springer, 238–255.
[19] Lingxiao Jiang, Ghassan Misherghi, Zhendong Su, and Stephane Glondu. 2007.
Deckard: Scalable and accurate tree-based detection of code clones. In Proceed-
ingsofthe29thinternationalconferenceonSoftwareEngineering.IEEEComputer
Society,96–105.
[20] LingxiaoJiangandZhendongSu.2009. Automaticminingoffunctionallyequiv-
alent code fragments via random testing. In Proceedings of the eighteenth inter-
national symposiumonSoftwaretestingandanalysis .ACM,81–92.
[21] ToshihiroKamiya,ShinjiKusumoto,andKatsuroInoue.2002. CCFinder:amul-
tilinguistictoken-basedcodeclonedetectionsystemforlargescalesourcecode.
IEEETransactionson SoftwareEngineering 28, 7(2002), 654–670.
[22] Marcus Kessel and Colin Atkinson. 2019. On the Eﬃcacy of Dynamic Behav-
ior Comparison for Judging Functional Equivalence. In 2019 19th International
Working Conference on Source Code Analysis and Manipulation (SCAM) . IEEE,
193–203.
[23] Mohd Ehmer Khan, Farmeena Khan, et al. 2012. A comparative study of white
box, black box and grey box testing techniques. Int. J. Adv. Comput. Sci. Appl 3,
6(2012).
[24] Heejung Kim, Yungbum Jung, Sunghun Kim, and Kwankeun Yi. 2011. MeCC:
memory comparison-based clone detector. In Proceedings of the 33rd Interna-
tional Conference on SoftwareEngineering .ACM,301–310.
[25] Rainer Koschke, Raimar Falke, and Pierre Frenzel. 2006. Clone detection using
abstractsyntaxsuﬃxtrees.In 200613thWorkingConferenceonReverseEngineer-
ing.IEEE,253–262.
[26] Jingyue Li and Michael D Ernst. 2012. CBCD: Cloned buggy code detector. In
Proceedings of the 34th International Conference on Software Engineering . IEEE
Press, 310–320.
[27] Zhenmin Li, Shan Lu, Suvda Myagmar, and Yuanyuan Zhou. 2004. CP-Miner:
AToolfor FindingCopy-pasteand Related Bugs in Operating System Code.. In
OSdi,Vol.4.289–302.
[28] George Mathew, Chris Parnin, and Kathryn T Stolee. [n.d.]. SLACC.
github.com/DynamicCodeSearch/SLACC/tree/ICSE20. [Online; accessed 06-
February-2020].[29] Philip Mayer and Alexander Bauer. 2015. An Empirical Analysis of the Utiliza-
tion of Multiple Programming Languages in Open Source Projects. In Proceed-
ingsofthe19thInternationalConferenceonEvaluationandAssessmentinSoftware
Engineering (Nanjing, China) (EASE ’15) . ACM, New York, NY, USA, Article 4,
10pages. https://doi.org/10.1145/2745802.2745805
[30] Philip Mayer, Michael Kirsch, and Minh Anh Le. 2017. On multi-language soft-
ware development, cross-language links and accompanying tools: a survey of
professional software developers. Journal of Software Engineering Research and
Development 5, 1(19Apr 2017), 1. https://doi.org/10.1186/s40411-017-0035-z
[31] Narcisa Andreea Milea, Lingxiao Jiang, and Siau-Cheng Khoo. 2014. Scalable
detection of missed cross-function refactorings. In Proceedings of the 2014 Inter-
national SymposiumonSoftwareTestingandAnalysis .ACM,138–148.
[32] KawserNa/f_i,TonnyShekaKar,BananiRoy,ChanchalK.Roy,andKevinSchnei-
der. [n.d.]. CLCDSA: Cross Language Code Clone Detection using Syntactical
Features and API Documentation. ([n.d.]).
[33] Trong Duc Nguyen, Anh Tuan Nguyen, Hung Dang Phan, and Tien N Nguyen.
2017. Exploring API embedding for API usages and applications. In Software
Engineering (ICSE), 2017 IEEE/ACM 39th International Conference on . IEEE, 438–
449.
[34] Python Community. [n.d.]. Python AST. docs.python.org/3/library/ast.html.
[Online; accessed 23-August-2019].
[35] BaishakhiRay,MiryungKim,SuzettePerson,andNehaRungta.2013. Detecting
and Characterizing Semantic Inconsistencies in Ported Code. In Proceedings of
the 28th IEEE/ACM International Conference on Automated Software Engineering
(Silicon Valley, CA, USA) (ASE’13). IEEE Press, Piscataway, NJ, USA, 367–377.
https://doi.org/10.1109/ASE.2013.6693095
[36] Chanchal K Roy, James R Cordy, and Rainer Koschke. 2009. Comparison and
evaluationofcodeclonedetectiontechniquesandtools:Aqualitativeapproach.
Science ofcomputerprogramming 74, 7(2009), 470–495.
[37] Jean Scholtz and Susan Wiedenbeck. 1990. Learning second and
subsequent programming languages: A problem of transfer. Inter-
national Journal of Human-Computer Interaction 2, 1 (1990), 51–72.
https://doi.org/10.1080/10447319009525970
[38] N. Shrestha, T. Barik, and C. Parnin. 2018. It’s Like Python But: Towards Sup-
porting Transfer of Programming Language Knowledge. In 2018 IEEE Sympo-
sium on Visual Languages and Human-Centric Computing (VL/HCC) . 177–185.
https://doi.org/10.1109/VLHCC.2018.8506508
[39] Fang-Hsiang Su, Jonathan Bell, Kenneth Harvey, Simha Sethumadhavan, Gail
Kaiser,andTonyJebara.2016. Coderelatives:detectingsimilarlybehavingsoft-
ware. InProceedings of the 2016 24th ACM SIGSOFT International Symposium on
Foundations of SoftwareEngineering.ACM,702–714.
[40] Fang-Hsiang Su, Jonathan Bell, Gail Kaiser, and Simha Sethumadhavan. 2016.
Identifyingfunctionallysimilarcodeincomplexcodebases.In ProgramCompre-
hension (ICPC),2016 IEEE24th International Conference on . IEEE,1–10.
[41] Team GitHub. [n.d.]. GitHub Gist. https://gist.github.com/discover. [Online;
accessed 23-August-2019].
[42] Team Stack Over/f_low. [n.d.]. Stack Over/f_low. https://stackover/f_low.com. [On-
line; accessed 23-August-2019].
[43] Federico Tomassetti and Marco Torchiano. 2014. An Empirical Assessment
of Polyglot-ism in GitHub. In Proceedings of the 18th International Confer-
ence on Evaluation and Assessment in Software Engineering (London, England,
United Kingdom) (EASE ’14) . ACM, New York, NY, USA, Article 17, 4 pages.
https://doi.org/10.1145/2601248.2601269
[44] Danny van Bruggen. 2015. Javaparser - For processing Java code.
github.com/javaparser/javaparser. [Online;accessed 23-August-2019].
[45] Andrew Walenstein and Arun Lakhotia. 2007. The software similarity problem
inmalwareanalysis.In DagstuhlSeminarProceedings .SchlossDagstuhl-Leibniz-
Zentrum für Informatik.
[46] Martin White, Michele Tufano, Christopher Vendome, and Denys Poshyvanyk.
2016. Deep learning code fragments for code clone detection. In Proceedings of
the 31st IEEE/ACM International Conference on Automated Software Engineering .
ACM,87–98.
[47] Wikipedia Contributors. [n.d.]. Java bytecode instruction listings.
en.wikipedia.org/wiki/Java_bytecode. [Online; accessed 23-August-2019].
[48] Wikipedia contributors. 2019. Levenshtein distance — Wikipedia, The Free En-
cyclopedia. en.wikipedia.org/wiki/Levenshtein_distance. [Online; accessed 23-
August-2019].
[49] QuanfengWuandJohnR.Anderson.1990. Problem-solvingtransferamongpro-
gramminglanguages . TechnicalReport.Carnegie MellonUniversity.
[50] Marvin Wyrich, Daniel Graziotin, and Stefan Wagner. 2019. A theory on indi-
vidual characteristics of successful coding challenge solvers. PeerJ Computer
Science5(Feb.2019), e173. https://doi.org/10.7717/peerj-cs.173
[51] WuuYang.1991. Identifyingsyntacticdiﬀerencesbetweentwoprograms. Soft-
ware:PracticeandExperience 21,7(1991), 739–755.
[52] R. Yue, Z. Gao, N. Meng, Y. Xiong, X. Wang, and J. D. Morgenthaler. 2018. Au-
tomatic Clone Recommendation for Refactoring Based on the Present and the
Past. In2018 IEEE International Conference on Software Maintenance and Evolu-
tion (ICSME) .115–126. https://doi.org/10.1109/ICSME.2018.00021
221