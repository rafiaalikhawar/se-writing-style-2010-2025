CheckingLTL[F,G,X]onCompressed Traces in PolynomialTime
Minjian Zhang
minjian2@illinois.edu
Universityof Illinoisat
Urbana-Champaign
Urbana, Illinois,USAUmang Mathur
umathur3@illinois.edu
Universityof Illinoisat
Urbana-Champaign
Urbana, Illinois,USAMahesh Viswanathan
vmahesh@illinois.edu
Universityof Illinoisat
Urbana-Champaign
Urbana, Illinois,USA
ABSTRACT
The problem of checking if a program execution meets a formal
specification arises in many software engineering tasks includ-
ingruntimeverificationanddesigningtestoracles.Whenonline
analysisisnotpossible,executiontracelogsarestoredforoffline
postmortem analysis, oftenin a compressed formatto reduce disk
spaceandwarehousingrequirements.Astraightforwardmethod
for checking if a compressed execution satisfies a property is to
first decompress it and then analyze the resulting uncompressed
execution.
Inthispaper,weconsidertheproblemofcheckingifanexecution
trace, compressed using a grammar-based lossless compression
scheme, satisfies a specification expressed in linear temporal logic,
without explicitly decompressing it. In general, this problem is
knowntobeintractable( PSPACE-hardinthesizeofthecompressed
traceandthe LTLformula).Weshowthattheproblemcanbesolved
inpolynomial time for the fragment LTL[F,G,X], which comprises
ofallBooleanandmodaloperatorsof LTLexceptthe untiloperator.
Our algorithm for analyzing SLPs (a grammar-based compression
scheme) is effective in practice Ð for a suite of large execution
traces obtained from open source projects, our algorithm shows
significant speed ups when compared with the performance of
checking LTLpropertiesovercorrespondinguncompressedtraces.
CCS CONCEPTS
·Softwareanditsengineering →Softwaretestinganddebug-
ging.
KEYWORDS
LinearTemporal Logic, Compression,RuntimeVerification
ACMReference Format:
Minjian Zhang, Umang Mathur, and Mahesh Viswanathan. 2021. Checking
LTL[F,G,X]onCompressedTracesinPolynomialTime.In Proceedingsofthe
29th ACM Joint European Software Engineering Conference and Symposium
on the Foundations of Software Engineering (ESEC/FSE ’21), August 23ś28,
2021,Athens,Greece. ACM,NewYork,NY,USA, 13pages.https://doi.org/
10.1145/3468264.3468557
Permissionto make digitalor hard copies of allorpart ofthis work for personalor
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACM
mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,
topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ESEC/FSE ’21, August 23ś28,2021, Athens,Greece
©2021 Associationfor Computing Machinery.
ACM ISBN 978-1-4503-8562-6/21/08...$15.00
https://doi.org/10.1145/3468264.34685571 INTRODUCTION
Consider the membership problem that can be abstractly defined
as follows: Given a program execution τ, determine if τis a łgoodž
behavior.Thiscomputationalproblemplaysakeyroleinseveral
approaches whose goal is the engineering of reliable and secure
software. The first sub-area where it arises is runtime verifica-
tion[10,27] where one dynamically monitors the behavior of a
systemwithtodetermineiftheitconformstosystemrequirements.
This approach can be used to augment testing by observing sys-
tem behavior along paths that were inadequately exercised during
testing,therebyresulting inincreasedcodecoverage. The keycom-
putationaltaskinruntimeverificationistosolvethe membership
problemÐ check whether the monitored execution needs satisfies
asystemrequirement.Asecondsub-areaofinterestisthedesign
test oracles [9]. Given executions of a system exercised by a test
suite, a test oracle is a program that distinguishes between cor-
rect and incorrectbehaviors of the system.Thus, a test oraclecan
be seen as solving the membership problem for the specific sys-
tem being tested. The membership problem also plays a key role
in intrusion detection [ 43]. Log files that record the interaction
between a network of elements need to be examined to detect pat-
terns of łintrusive behaviorž so that corrective measures can be
takentoavoidsecuritycompromises.Sincetheselogfilesarelarge,
and there are multiple patterns of intrusive behavior, intrusion
is typically detected automatically by a program that solves the
membershipproblemtodetermineifthelogfilesdonotcontainan
intrusivepattern.Finally,themembershipproblemalsoneedstobe
solvedwhen statisticallymodelchecking asystem.Statisticalmodel
checking [ 5,44] is an approach to verify quantitative properties of
stochasticsystems.Inthisapproach,themodelcheckerexecutes
the stochastic system a few times to draw a statistical sample of
systembehaviors,andthenusehypothesistestingtodeterminethe
likelihoodofapropertybeingtrueofasystem.Acrucialstepinthis
process is building an oracle that determines for each execution,
whether itsatisfiesadesiredlogical property.
Onepracticalchallengeineachoftheseapplicationareasthat
rely on solving the membership problem is the size of the program
executionthatneedstobeanalyzed.Programtracesthatarisein
runtime verification, testing or statistical model checking are often
huge,containingmillionsofevents.Longtracesareoftennecessary
toexerciselargepartsofthecodebasetoensuregoodcodecoverage.
Log files analyzed for intrusions often record interactions that take
placeoverlongwindowsoftime,sometimesovermultipledays.The
challenge therefore is two-fold: how to store such long traces/logs,
and how to effectively analyze them. The common solution to
addressthewarehousingneedsforsuchtracesistocompressthem
andthen store theminacompressedformat.
131
ESEC/FSE ’21, August 23–28, 2021,Athens,Greece MinjianZhang,UmangMathur, andMahesh Viswanathan
Given that program executions need to be compressed to ad-
dress storage costs, an important question in the context of the
membership problem is, to find effective solutions to the prob-
lem when the input trace is compressed. This question is not
new,andhasarichhistory,especiallyintheoreticalcomputersci-
ence[7,8,12,15,16,31,38,46].Theshortsummaryofresultsinthis
space isasfollows.There is alwaysanaïvealgorithmtosolve the
membershipproblemoncompressedtracesÐuncompressthetrace
and check membership. In many situations this is often (provably)
the best algorithm possible [ 7,16,38]. However, there are excep-
tions where the membership problem can be solved in time that
ispolynomialinthesizeofthe compressedtrace [30];onenotable
example isdynamicracedetection oncompressedstrings [ 23].
The main question we investigate in this paper is the following:
Given a program trace τin compressed form and a formula φin
lineartemporallogic(LTL)[ 39],determineif τsatisfiesφ.LTLis
widely used in testing and verification. It’s popularity relies on the
factthat,ontheonehanditisrichenoughtoexpressmanyrequire-
mentsthattypicallyariseinsoftwareengineering,andontheother
hand,theabsenceofexplicitquantification,makesitsimpleenough
for a practitioner to easily write properties. Compression schemes
we consider are those where aprogram trace is representedusing
astraight line program (SLP) . SLPs are special context-free gram-
mars where the language of the grammar contains exactly one
string, namely, the trace it represents. Several lossless compression
schemes. like run-length encoding and Lempel-Ziv encodes [ 50],
canbeefficientlyconvertedintoSLPswithsimilarsize.Thereare
efficient implementations of compression algorithms that produce
anSLPrepresentationofagivenexecution[ 3,21,22,25,37,48ś50].
Theproblemofdeterminingifafinitetracecompressedusingan
SLPsatisfiesanLTLproperty,hasbeenstudiedbefore.Theproblem
isknowntobeintractableÐitis PSPACE-hard[33].Therefore,we
ask if there is a rich fragment of LTL for which the problem can be
efficiently solved. We consider the fragment LTL[ F,G,X] which is
thecollectionofallLTLformulasthatarebuiltfrompropositions
using boolean operators, and only the temporal operators X(next),
F(eventuallyorfinally),and G(alwaysorglobally);inparticular, U
(until)cannotbeusedintheformulasof LTL[ F,G,X].Thefragment
LTL[F,G,X]isexpressivelyveryrich.Overinfinitetraces,LTL[ F,
G,X] can express properties in each class of the safety-progress
classification of temporal properties introduced by Manna and
Pnueli[32]1.Ourmainresultisthattheproblemofcheckingifa
finite trace represented by an SLP satisfies an LTL[ F,G,X] formula
can be decided in time that is polynomial in the size of the SLP
(compressedtrace) andthe formula.
We now outline the technical challenges and our theoretical
contributions in obtaining this result. The principal idea used in
verification, runtime verification, and automatic test oracle genera-
tionfortemporalpropertiesistoexploittheconnectionbetween
LTL formulas and automata Ð translate the formula into an au-
tomata,andthenłrunžtheautomatonwiththeprogramortrace
to verify or test. For runtime verification or test oracles, the au-
tomaton constructed from the formula needs to be deterministic .
Thisideacanalsobeusedwhencheckingcompressedtraceswhere
1Orin everyBorel class that has ω-regularproperties.you effectively łrunž the deterministic automaton on the grammar
representing the trace.
However, even for LTL [ F,G] formulas2, the smallest nondeter-
ministicautomatonisexponentialandthesmallestdeterministic
automaton is doubly exponential in the size of the formula [ 6].
Theoreticallowerboundsestablishthatthiscannotbeimproved.
Our first observation is that if the finite (uncompressed) trace is
processed right-to-left insteadofleft-to-right,thenthereisan expo-
nentialsized,deterministic automatonforeachLTL[ F,G,X]formula,
that can solve the membership question. łRunningž an automaton
left-to-right or right-to-left on an SLP is very similar and so this
change does not fundamentally change the algorithm for com-
pressedtraces.However,thefactthattheautomatonisexponential
sizedwouldaffectthecomplexity;forcompressedtraces,therun-
ning time of an algorithm using this automaton would be exponen-
tial in the formula. To combat this, we observe that the automaton
wedesignforLTL[ F,G,X]hasspecialłmonotonicityžproperties
and has a small łdiameterž. These two observations can be com-
bined to observe that there are łessentiallyž O(m)state changes
(mhere refers to the size of the LTL[ F,G,X] formula) when the
automatonisrunon any(uncompressed)trace,nomatterwhatthe
lengthofthetraceis.Finally,weexploitthespecialstructureofthe
states of this automaton, to design an algorithm for compressed
traces. To prove that this algorithm indeed runs in time that is
polynomialinthe formulasize andthe grammar, requires carefully
countingthenumberofsubstringsthatariseinastringrepresented
byan SLP.
Weevaluatetheperformanceofouralgorithmforcheckingcom-
pressedtracesoveropensourceJavaprojectsobtainedfromGitHub
(largelyderivedfrompriorstudy[ 28]).Wealsouse10 LTL[F,G,X]
properties describing specifications for the use of iterators, collec-
tions, file objects, etc., Our evaluation suggests that, large traces
fromopensourceprojectscanbeeffectivelycompressed(withan
averagecompressionratioofmorethan600 ×)andthatcompressed
traces can be effectively checked against these specifications, lead-
ingto significant speedups(averagingat34 ×).
The rest of the paper is organized as follows. Section 2dis-
cussesbackgroundrelevantfortheexposition.Section 3presents
anoverviewofouralgorithmforchecking LTL[F,G,X]formulae
on compressed traces, and Sections 4and5discuss the technical
details of the algorithm. We present our evaluation in Section 6,
relatedwork inSection 7andconcluding remarks inSection 8.
2 PRELIMINARIES
Inthissectionwepresentpreliminarynotationsaboutexecution
traces,LTLmonitoringandthe SLP compressionformat.
2.1 Execution Traces
In many approaches whose goal is to either prove the correctness
of a software or find errors, a key computational problem that
needs to be solved is the membership problem , where one needs to
determine if a given program execution is correct with respect to a
systemspecification.Inthissetting,anexecutiontrace(orsimplyan
execution)canbeabstractlymodeledasafinitesequenceofłeventsž
belongingtoaset(say) Σ.Thesetofevents Σisdeterminedbywhat
2TheseareLTLformulasthatonlyhave FandG(andnoXorU)astemporaloperators.
132CheckingLTL[F,G,X] onCompressedTracesin PolynomialTime ESEC/FSE ’21, August 23–28, 2021,Athens,Greece
classSetTraversal {
HashSet<Integer>s=newHashSet<Integer>();
publicvoidinsert(intmax) {
for(inti=0; i<max; i++) s.add(i);
}
publicintsumAllExcept (intval) {
Iterator <Integer>itr=s.iterator ();
intsum=0;
if(!itr.hasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNext()) returnsum;
while(true){
inti=itr.nextnextnextnextnextnextnextnextnextnextnextnextnextnextnextnextnext();
if(i==val)continue ;
sum=sum+i;
if(!itr.hasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNext()) break;
}
returnsum;
}
}
classSetTraversalTest {
@Test
voidtestInsertAndSum () {
SetTraversal st =newSetTraversal();
st.insert(128);
intactual=st.sumAllExcept (64);
intexpected =(127*(127+1))/2-64;
assertEquals(expected, actual);
}
}
Figure 1: Java class SetTraversal with methods insertand
sumAllExcept . The unit test testInsertAndSum tests these
twomethodsat once.
isvisibleorhasbeenmadevisiblethroughinstrumentationwhen
the program is executed. Thus, an execution isτ=e0e1···ek−1
where each ei∈Σ; theempty trace/sequence will be denoted by
ϵ. Let us fix an execution τ=e0e1···ek−1. Theith event in the
executionwillbedenotedby τ[i]=ei.Wewilldenotethesubstring
eiei+1···ej−1byτ[i:j],thesuffix eiei+1···ek−1byτ[i:]and
theprefix e0···ei−1byτ[:i]. Thelengthof execution τ, denoted
|τ|,isthe number ofeventsinitwhichis k.By definition|ϵ|=0.
Example1. ConsidertheJavaclass SetTraversal inFigure 1.Ev-
ery instance of this class has a member variable s, which is a set of
integerelements.Themethod insertinsertsallnon-negativeinte-
gerslessthan maxins,whilethemethod sumAllExcept returnsthe
sum of those elementsofthe set swhich are different fromthein-
tegerval.Weremarkthattheimplementationof sumAllExcept is
functionallycorrectwhenever valisnotthelastvaluewhentravers-
ingsusingtheiterator itr.Ifvalisthelastvaluein swhentravers-
ingusing itr,theloopbody canexecute nextnextnextnextnextnextnextnextnextnextnextnextnextnextnextnextnext()(aftertraversing
the node with itr), even though there are no remaining elements,
whichmayraiseaJava exception ( NoSuchElementException ).
The figure also shows a test class SetTraversalTest that im-
plementsaunittest testInsertAndSum thatfirstcalls inserton
aninstance stofSetTraversal withtheargument128andthen
checks if the sum of elements thus inserted (except the element
64) is as expected. The given unit test passes and, in fact, does not
expose the bug outlined above. The execution trace generated due
tothistest,canneverthelessbeusedtoinferthepossibilityofan
exception. If we instrument calls to the methods hasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNext() and
nextnextnextnextnextnextnextnextnextnextnextnextnextnextnextnextnext(),thenwewillobserveatraceoverthealphabet Σ={hhhhhhhhhhhhhhhhh,nnnnnnnnnnnnnnnnn},
wherehhhhhhhhhhhhhhhhhrepresents a call to hasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNext() andnnnnnnnnnnnnnnnnnrepresents a call to
nextnextnextnextnextnextnextnextnextnextnextnextnextnextnextnextnext().Fortheunittest testInsertAndSum ,wewillobservethe
execution trace τ=(hhhhhhhhhhhhhhhhhnnnnnnnnnnnnnnnnn)65nnnnnnnnnnnnnnnnn(hhhhhhhhhhhhhhhhhnnnnnnnnnnnnnnnnn)62hhhhhhhhhhhhhhhhh. This is because, in this case,the iterator traverses the set sin the order of insertion, and for
the first 65 elements (values 0 through 64), the method insertcor-
rectly calls hasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNext() beforenextnextnextnextnextnextnextnextnextnextnextnextnextnextnextnextnext(). However, in the next step,
it enters the loop and calls nextnextnextnextnextnextnextnextnextnextnextnextnextnextnextnextnextwithout checking hasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNext() . All
thesubsequentloopexecutionsgeneratethesequence (hhhhhhhhhhhhhhhhhnnnnnnnnnnnnnnnnn)62hhhhhhhhhhhhhhhhh.In
subsequent sections,we willdiscusshow analyzing τ, infact, can
hint at the possibility of an exception. Observe that |τ|=256,
τ[: 130]=(hhhhhhhhhhhhhhhhhnnnnnnnnnnnnnnnnn)65,τ[130 :]=nnnnnnnnnnnnnnnnn(hhhhhhhhhhhhhhhhhnnnnnnnnnnnnnnnnn)62hhhhhhhhhhhhhhhhhandτ[2 : 130]=(hhhhhhhhhhhhhhhhhnnnnnnnnnnnnnnnnn)64.
2.2 LinearTemporalLogic
Lineartemporallogic(LTL)isapopularlogicforspecifyingtempo-
ral properties of systems, and is widely used to specify correctness
properties.Inthissection,weintroducethesyntaxandsemantics
of LTLand some fragments thatare relevant inthis paper.Since
program executions encountered while testing and runtime ver-
ification are assumed to be finite, our semantics for LTL will be
defined for finite execution traces. While this is not the classical
semanticsforLTL,itisstandard[ 13].Wewillalsobeusingałletter
semanticsž for the logic Ð models are sequences of letters as op-
posedtosequencesofsets ofpropositions,andformulasarebuilt
using lettersas opposedto propositions.
Syntaxof LTL. Letusfixafinitealphabet Σ.Then,aformula φin
LTLover Σisgiven bythe following grammar.
φ::=a|¬φ|φ∧φ|φ∨φ|Xφ|Fφ|Gφ|φUφ
Here,aisa symbolin Σ,¬,∧and∨areBooleanconnectives and X
(‘next’),F(‘eventually’), G(‘always’)and U(‘until’)aretemporal
modal operators. We will use φ1=⇒φ2as a shorthand for
¬φ1∨φ2.
Semantics of LTL. The semantics of LTL is given by how an LTL
formulaφevaluates over a finite non-empty traceτ∈Σ+. We
formally describe thisevaluation relation |=fbelow; the subscript
‘f’in|=fstands for evaluation over finitetraces.
τ|=fa iffτ[0]=a
τ|=f¬φiffτ̸|=φ
τ|=fφ1∧φ2iffτ|=fφ1andτ|=fφ2
τ|=fφ1∨φ2iffτ|=fφ1orτ|=fφ2
τ|=fXφiff|τ|>1 andτ[1 :]|=fφ
τ|=fFφiffthere isan isuch that0≤i<|τ|
andτ[i:]|=fφ
τ|=fGφifffor everyisuch that0≤i<|τ|,
τ[i:]|=fφ
τ|=fφ1Uφ2iffthere isan isuch that0≤i<|τ|
andτ[i:]|=fφ2andfor every j
such that0≤j<i,τ[j:]|=fφ1
Remark. LTL, as presented here, only has future time operators.
Some presentations include past time operators as well: Y(for ‘yes-
terday’), the dual of X;O(for ‘once’), the dual of F;H(for ‘his-
torically’), the dual of G; andS(for ‘since’), the dual of U. Over
finite traces, the following property holds. Let /hatwideφbe the formula
obtained by replacing every past time (future time) operator by
the corresponding dual future time (past time) operator in φ. Then
τ|=fφifandonlyif τr|=f/hatwideφ;hereτrdenotesthereverseof τ.This
means that over finite traces, LTL with only past time operators is
133ESEC/FSE ’21, August 23–28, 2021,Athens,Greece MinjianZhang,UmangMathur, andMahesh Viswanathan
łequivalentž to LTL with only future time operators. Our results,
though presented only for LTL with future time operators, also
apply to LTLwithpurelypasttime operators.
Example 2. Consider the program shown in Figure 1and the
executionτproducedwhencallstomethods hasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNext() andnextnextnextnextnextnextnextnextnextnextnextnextnextnextnextnextnext()
aretracked.AsshowninExample 1,τ=(hhhhhhhhhhhhhhhhhnnnnnnnnnnnnnnnnn)65nnnnnnnnnnnnnnnnn(hhhhhhhhhhhhhhhhhnnnnnnnnnnnnnnnnn)62hhhhhhhhhhhhhhhhh,wherehhhhhhhhhhhhhhhhh
represents a call to hasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNext() andnnnnnnnnnnnnnnnnnrepresents a call to nextnextnextnextnextnextnextnextnextnextnextnextnextnextnextnextnext().
Intuitively, in a correct implementation, the program should check
theexistenceofanextelement(i.e.,event hhhhhhhhhhhhhhhhh)beforeaccessingthe
nextelement(i.e.,event nnnnnnnnnnnnnnnnn).TheprograminFigure 1doesnotsatisfy
this intuitive correctness requirement since an event hhhhhhhhhhhhhhhhhdoes not
precedetheevent nnnnnnnnnnnnnnnnnwhenthevalue65isaccessed.Wecanformalize
our informal intuition by requiring that ‘there are no successive
callstonextnextnextnextnextnextnextnextnextnextnextnextnextnextnextnextnext()’.However,thisbyitself isnotenoughbecausethe
execution nnnnnnnnnnnnnnnnnhhhhhhhhhhhhhhhhhnnnnnnnnnnnnnnnnndoesnothavesuccessive nnnnnnnnnnnnnnnnnevents,butthefirst nnnnnnnnnnnnnnnnnevent
is not preceded by hhhhhhhhhhhhhhhhh. So we must also require that the execution
does not begin with nnnnnnnnnnnnnnnnn. We could write this as φ=(¬nnnnnnnnnnnnnnnnn)∧G(nnnnnnnnnnnnnnnnn=⇒
¬X(nnnnnnnnnnnnnnnnn)).Onecanseethat τdoesnotsatisfythisproperty(asdesired)
becauseτ[129 :]=nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn(hhhhhhhhhhhhhhhhhnnnnnnnnnnnnnnnnn)62hhhhhhhhhhhhhhhhhdoes not satisfy nnnnnnnnnnnnnnnnn=⇒ ¬Xnnnnnnnnnnnnnnnnn.
Fragments of LTL. We will consider a couple of fragments of
LTL obtained by restricting the modal operators that appear in
formulas. The first fragment is LTL[X] which consists of formulas
builtfromeventsandBooleanoperatorsusingonly Xoperator.The
next fragment is LTL[F,G,X] which uses the modal operators X,F,
andG, but does not use U. We skip the formal BNF grammar for
thesefragments.
Formulasin LTL[F,G,X]canbeexpressedinanormalformthat
isobtainedbypushing Xasfarinaspossible.Since X(φ1∨φ2)≡
(Xφ1)∨(Xφ2),X(φ1∧φ2)≡(Xφ1)∧(Xφ2)andXFφ≡FXφ,wecan
pushXinside conjunctions, disjunctions and Foperators.However,
overfiniteexecutions Xcannotbepushedinside‘ ¬’or‘G’operators.
To see this, consider the execution σ=hhhhhhhhhhhhhhhhhnnnnnnnnnnnnnnnnn. Observe that σsatisfies
XGnnnnnnnnnnnnnnnnn,butnotGXnnnnnnnnnnnnnnnnnas|σ[1 :]|=1andthus σ[1 :]̸|=fXnnnnnnnnnnnnnnnnn.Similarly,
τ=nnnnnnnnnnnnnnnnnsatisfies¬XhhhhhhhhhhhhhhhhhbutnotX¬hhhhhhhhhhhhhhhhh.Thenormalformcanbedescribed
bythe following BNF grammar.
φ::=ψ|η|φ∧φ|φ∨φ|Fφ
η::=Xψ|Xη
ψ::=a|¬φ|Gφ(1)
Formulas in LTL[F,G,X] (φ) are one of X-formulas ( η),G-formulas
(ψ), conjunctions/disjunctions of LTL[F,G,X] formulas, or an F
operator applied to an LTL[F,G,X] formula in the normal form.
X-formulasarethosewherethetopleveloperatoris X.AXoperator
can only be applied to either a G-formula or an X-formula. Finally,
G-formulas are letters, or negations of LTL[F,G,X] formulas ( φ),
or haveGas the topmost operator. Every LTL[F,G,X] formula can
beconvertedintothisnormalform,withatmostquadraticblowup.
Example 3. Consider the LTL[F,G,X] formulaφ=X(Gnnnnnnnnnnnnnnnnn∨Fhhhhhhhhhhhhhhhhh).
Thenormalformforthiscanbeobtainedbypushing Xasfarinside
as possible. Thus, φ′=(XGnnnnnnnnnnnnnnnnn)∨(FXhhhhhhhhhhhhhhhhh)is the equivalent formula in
normal form.
Remark. The fragment LTL[ F,G,X] is expressively rich. For ex-
ample, it can express properties in each class of the safety-progess
classification of temporal properties introduced by Manna and
Pnueli [32]. Among the pattern-based specifications introducedin [14], most patterns, except precedence, chain precedence, and
scopes can be expressed in LTL[ F,G,X]. In fact, among the 555
commonly occurring specifications collected and surveyed in [ 14],
approximately80%ofthemcan be expressedinLTL[ F,G,X].
AutomataforLTLandits fragments. For LTL properties, algo-
rithms for verification, runtime verification, and test oracle gen-
eration, all rely on the translation of logic formulas to automata.
For a specification φ, the crucial step therefore, is the construction
ofanautomatonAφsuchthatanexecution τisacceptedbyAφ
if and only if τsatisfiesφ. The size ofAφhas big influence on
thecomplexityoftheverification/testingalgorithm.Forruntime
verification and test oracle generation, the automaton Aφneeds
to be deterministic. Because of the critical role translations from
LTL toautomata play in algorithms, these have beenwell studied.
Unfortunately,thetranslationfromformulastodeterministicau-
tomatacanresultinatleastadoubleexponentialblowup.Itisworth
emphasizing that the result below holds whether we interpret LTL
over finiteorinfinite executions.
Theorem 2.1 (Alur-LaTorre [ 6]).There is a family {φn}n∈Nof
LTL[F,G,X] formulas such that the size of φnisnand any deter-
ministic acceptor for φnisof size Ω(22n).
2.3 Compressed Executions
Inthispaper,wewillpresentalgorithmstosolvethemembership
problem when the program execution is compressed. The com-
pressed execution we consider will be encoded by a straight line
program (SLP) , which is a special context-free grammar whose lan-
guagehasexactlyonestring,namely,theexecutionitrepresents.
Severallosslesscompressionschemes,likerun-lengthencodingand
Lempel-Ziv encoding [ 50] can be efficiently converted into SLPs
of similar size. Several efficient algorithms that compress strings
using SLPsare known[ 3,21,22,25,37,48ś50].
Straight Line Programs (SLP). Recall that a context-free gram-
mar is a tuple G=(T,N,S,R), whereTis the set of terminals,Nis
thesetof non-terminals ,S∈Nisthestartingnon-terminal ,andRis
the set of rulesof the form A→α, whereA∈Nandα∈(N∪T)∗.
Astraightlineprogram(SLP)isspecialcontext-freegrammar,with
restrictions that ensure that the language associated with Ghas
exactly one string. In particular, we require that in an SLP, each
non-terminal Ahasexactly one rule where Aappearson the left,
and that there is a total ordering ‘ <’ on non-terminals such that if
anon-terminal Bappearsontheright-handsideoftherulefor A
thenA<B. These restrictions ensure that the language associated
with each non-terminal has exactly one string, and we denote this
stringas /llbracketA/rrbracket.
The size of a rule (A→α)∈Ris defined to be the size |α|
and the size of a grammar G, denoted by|G|, is defined to the be
sumofthesizesofallrules.Thecompressionratioofagrammar
G=(T,N,S,R)is defined to be|/llbracketS/rrbracket|
|G|, i.e., the ratio between the
length ofthe stringthat Grepresents, andthe size of G.
Example4. ThegrammarshowninFigure 2isanSLPthatencodes
the execution τ=(hhhhhhhhhhhhhhhhhnnnnnnnnnnnnnnnnn)65nnnnnnnnnnnnnnnnn(hhhhhhhhhhhhhhhhhnnnnnnnnnnnnnnnnn)62hhhhhhhhhhhhhhhhhof program in Figure 1from
Example1.Thegrammarhasstartsymbol S.Therulesaredesigned
to ensure that /llbracketAi/rrbracket=(hhhhhhhhhhhhhhhhhnnnnnnnnnnnnnnnnn)i,/llbracketB/rrbracket=nnnnnnnnnnnnnnnnn(hhhhhhhhhhhhhhhhhnnnnnnnnnnnnnnnnn)62hhhhhhhhhhhhhhhhhandtherefore /llbracketS/rrbracket=τ.
134CheckingLTL[F,G,X] onCompressedTracesin PolynomialTime ESEC/FSE ’21, August 23–28, 2021,Athens,Greece
S→A65B B→nnnnnnnnnnnnnnnnnC C →A62hhhhhhhhhhhhhhhhh
A1→hhhhhhhhhhhhhhhhhnnnnnnnnnnnnnnnnn A2→A1A1A4→A2A2
A6→A2A4A8→A4A4A16→A8A8
A24→A8A16A30→A6A24A32→A16A16
A33→A32A1A62→A30A32A65→A32A33
Figure2:Astraightlineprogramencodingoftheexecution
τ=(hhhhhhhhhhhhhhhhhnnnnnnnnnnnnnnnnn)65nnnnnnnnnnnnnnnnn(hhhhhhhhhhhhhhhhhnnnnnnnnnnnnnnnnn)62hhhhhhhhhhhhhhhhhfromExample 1.
TheSLPhas15rules.Allruleshavesize2.Thusthesizeofthe
SLP is 2×15=30.The compressionratioistherefore256
30≃8.53.
Every SLP can be transformed in linear time into Chomsky nor-
malformwherethesizeofeachruleisboundedby2.Fromnowon
we will assume that all the SLP grammars are written in Chomsky
normal form.
We remark that an SLP can be exponentially more succinct than
theuncompressedstringitrepresents.Forinstance,astring σ=hhhhhhhhhhhhhhhhh2n
of size 2ncan be represented by a grammar of size O(n)with rules
S→HnHn,Hn→Hn−1Hn−1,...,H2→H1H1andH1→hhhhhhhhhhhhhhhhh.
The problem of checking if an execution represented by an SLP
Gsatisfies an LTL formula φhas been studied before. A naïve
algorithmforthisprobleminvolves decompressing theSLPGand
checking if the uncompressed executionsatisfies φ.However, this
canbeexpensive because of thepossibleexponentialsuccinctness
oftheSLP,asoutlinedinthepreviousparagraph.Isthereabetter
algorithm that doesn’tinvolve uncompressing?
Automata for checking SLPs against LTL. One possible ap-
proach, thatworkswithout decompressing the SLP,leverages the
automata-theoretic connections of LTL. Given an LTLformula
φ, we can first construct a deterministic finite automaton Aφ=
(Q,Σ,q0,δ,F)as outlined in Section 2.2. For every non-terminal A
intheSLPgrammar Gandforeverystate q∈Q,wecantheninduc-
tively compute the state δ(q,/llbracketA/rrbracket)reached after running the string
generatedby Astartingfromthestate q.Inthebasecase,therule
correspondingto AisA→a(a∈Σ),andδ(q,/llbracketA/rrbracket)=δ(q,a).Inthe
inductive case of A→BC, we haveδ(q,/llbracketS/rrbracket)=δ(δ(q,/llbracketB/rrbracket),/llbracketC/rrbracket).
Finally checking if /llbracketA/rrbracket|=fφamounts to checking δ(q0,/llbracketS/rrbracket)∈F.
This approach would work in time O(|G|·|A|·D), whereDis the
time takento computethe transition function on an input symbol
and state. Note that D, in general, is at least log|A|because the
bitsencodingthestatehavetobereadandtheencodingofthenext
state needs to be produced. Based on Theorem 2.1, this is double
exponential in|φ|and thus intractable. Indeed, the following theo-
reticallowerboundestablishesthat there isno algorithmthat has
atractableasymptoticcomplexityfor the caseoffull LTL.
Theorem2.2 (Markeyand Schnoebelen[ 33]).GivenanSLP G=
(T,N,S,R)andanLTLformula φ,theproblemofcheckingif /llbracketS/rrbracket|=f
φisPSPACE-hard.
The main result of this paper shows that this problem can be
solved efficiently (in polynomial time) when the formula is from
the LTLfragment LTL[ F,G,X].
3 TECHNICAL OVERVIEW
Recall(fromSection 2.3)thatthereisasimpleautomata-theoretical-
gorithmforcheckingifacompressedtrace(SLP G)satisfiesagivenLTL formula φ(i.e.,/llbracketG/rrbracket|=fφ). This simple algorithm constructs
a DFAAφcorresponding to the given LTL formula φ(in time
O(|Aφ|)),andthen inductivelycomputes,for everynon-terminal
AofGand for every state qofAφ, the next state q′=δ(q,/llbracketA/rrbracket)
obtainedafterrunningthetracefragment /llbracketA/rrbracketonAφ.Asweprevi-
ouslyobservedthetotalrunningtimeofthissimplealgorithmis
O(|Aφ|+|G||Aφ|D)(whereDisthetimetocomputethetransition
function) which, based on the size of the smallest deterministic au-
tomaton,is O(|G|22|φ|2|φ|).Thealgorithmweproposeforformulas
inLTL[F,G,X] works on the same automata-theoretic paradigm
butwithmodificationsthatleadtoapolynomialrunningtime.In
thissectionweoutlinesomeoftheideasthathelpusachievethis
polynomialtime.
Backwardsautomaton. The first observation that our algorithm
relies on is that for the fragment LTL[F,G,X], there is a deter-
ministicautomatonthatworksbackwardsandonlysuffersanex-
ponential blow-up (instead of double exponential in the forward
automaton). That is, for the input formula φ∈LTL[F,G,X], we
construct an automaton Arφsuch that for any trace τ,τ|=fφ
iffτris accepted byArφ; for an execution τ=e0e1···ek−1its
reverseisτr=ek−1ek−2···e0. The algorithm for analyzing the
SLPGwiththisautomatonisalsostraightforward,andproceeds
as if the grammar Gis reversed (every rule of the form A→BC
becomesA→CB). But, this by itself is not enough if we are using
theexhaustiveparadigm‘compute δ(q,/llbracketA/rrbracket)forallqandA’because
|Arφ|=O(2|φ|). Thankfully, the backwards automaton Arφenjoys
a special structure that we exploit, in conjunction with the next
observation,to getour efficient algorithm.
Bounding running time with visited states. We next observe
that, insteadof computing δ(q,/llbracketA/rrbracket)for allpairs of state qand non-
terminalAintheautomata-theoreticalgorithm,wecanaffordto
onlycompute δ(q,·)forstatesthatareactually visited(insteadof
all states). Consider the production rule S→UV, whereSis the
startingnon-terminaloftheinputSLPgrammar G.Ourfinalgoal
istocomputethestate q=δ(q0,/llbracketS/rrbracket).Weremarkthatthiscanbe
computedasthecomposition q=δ(q′,/llbracketV/rrbracket),whereq′=δ(q0,/llbracketU/rrbracket).
Ifthisistheonlyrulethat Voccursin,weonlyneedtocompute
δ(q′,/llbracketV/rrbracket)(insteadofcomputing δ(p,/llbracketV/rrbracket)foreverystate p).Notice
that this intermediate state q′would also be visited when running
Aontheuncompressedtrace /llbracketS/rrbracket;thisispreciselythestatereached
after running the prefix /llbracketU/rrbracketof/llbracketS/rrbracket. In fact, this observation can
be generalized so that we only compute δ(q,A)for those states
qthat are ever visited when analyzing the uncompressed trace.
We formalize this as follows. For a trace τand an automaton A
with initial state q0, letv(A,τ)={δ(q0,τ[:i])|0≤i<|τ|}be
the states ofAthat are visited when running τonA. Then, we
can compute δ(q0,S)by only computing δ(q,A)for every non-
terminalAandstateq∈v(A,/llbracketG/rrbracket).This givesusanupperbound
ofO(|G|·|v(A,/llbracketG/rrbracket)|·D), an improvement over O(|G|·|A|·D)
(Ddenotesthe time to evaluate the transitionfunction).
Boundingnumber ofstates visited. Our third important obser-
vation is that any run of automaton Arφ(forφ∈LTL[F,G,X])
satisfies a łmonotonicityž property. This property allows us to
bound the number of states visited |v(A,/llbracketG/rrbracket)|on any input to
|φ||Σ|k(independent of||G||). Here,kis what we call the nesting
135ESEC/FSE ’21, August 23–28, 2021,Athens,Greece MinjianZhang,UmangMathur, andMahesh Viswanathan
depthofXinφ;aprecisedefinitionwillbepresentedinSection 4.
This combined with some other observations gives us a running
time ofO(|G||φ|2|Σ|k).
Furtherimprovements. Ouralgorithmforanalyzingcompressed
executionsrunsinstrictlypolynomialtime(andthusdoesnothave
theexponentialdependenceduetothefactor |Σ|k).Weachievethis
byperforminganinvolvedfinegrainedanalysisoftherunningtime
of the algorithm. Further, we also make use of the monotonicity
property outlined inthe previous paragraph to optimizethe space
usage ofthe algorithm.
InSection 4,wedescribetheautomatonconstruction,andthe
otherobservationsaboutmonotonicityandthenumberofvisited
states in greater detail. We finally present the algorithm for analyz-
ingcompressedexecutionsandimprovementsthereofinSection 5.
4 AUTOMATON FORLTL [F,G,X]
Inthissection,wepresenttheconstructionofa backwards deter-
ministicautomaton ArφsuchthatArφacceptsatrace τrifandonly
ifτ|=fφ; recall that τris the reverse of execution τ. The main
advantageofthisconstructionisthatthesizeof Arφisonlyexpo-
nential inφ(as opposed to doubly exponential). In addition, Arφ
hasaspecialstructurethatensuresthatthenumberofstatesvisited
byArφonany input τrispolynomialin|φ|.
Before presenting the construction, we will introduce some con-
ventionsandnotationsthatwewilluseintherestofthispaper.First,
as outlined in Section 2, we can assume that LTL[F,G,X] formulas
areinnormalformgivenbyEquation( 1),i.e.,Xoperatorshavebeen
pushed asfarinside aspossible. For any formula φ∈LTL[F,G,X],
we will use sub(φ)to denote the set of sub-formulas of φ. When
defining our automata, we will consider a special subset of sub-
formulas, called FGX-subformulae, denoted by subFGX(φ). These
aresub-formulas ψofφwhosetopmostoperatoriseither F,G,or
X, and if the top operator of ψisX, thenψhas a sub-formulawith
topmost operator G.We formally definethis setnext.
Definition1 (FGX-sub-formulas) .Foraformula φ∈LTL[F,G,X],
subFGX(φ)isthesetofsub-formulasdefinedinductivelyasfollows.
subFGX(a)=∅
subFGX(¬φ)=subFGX(φ)
subFGX(φ1⊕φ2)=subFGX(φ1)∪subFGX(φ2),⊕∈{∧,∨}
subFGX(Mφ)={Mφ}∪subFGX(φ),M∈{F,G}
subFGX(Xφ)=subFGX(φ), φ∈LTL[X]
subFGX(Xφ)={Xφ}∪subFGX(φ), φ/nelementLTL[X]
Letuslook at examplesto illustrate thesedefinitions.
Example 5. Consider the formula φ=¬nnnnnnnnnnnnnnnnn∧G(nnnnnnnnnnnnnnnnn=⇒ ¬Xnnnnnnnnnnnnnnnnn)from
Example2.Thesetofitssub-formulasis sub(φ)={φ,¬nnnnnnnnnnnnnnnnn,nnnnnnnnnnnnnnnnn,G/parenleftBig
(¬nnnnnnnnnnnnnnnnn)∨
¬(Xnnnnnnnnnnnnnnnnn)/parenrightBig
,(¬nnnnnnnnnnnnnnnnn)∨¬(Xnnnnnnnnnnnnnnnnn),¬Xnnnnnnnnnnnnnnnnn,Xnnnnnnnnnnnnnnnnn}.Similarly, subFGX(φ)={G((¬nnnnnnnnnnnnnnnnn)∨
¬(Xnnnnnnnnnnnnnnnnn))}. Notice that Xnnnnnnnnnnnnnnnnn/nelementsubFGX(φ)(even though its topmost
operator is X) as itdoes not have a G-sub-formula inits scope.
AsisstandardinautomataconstructionsforLTL,ourautomaton
Arφforφwilltrackthetruthofsub-formulasof φasitprocesses
the input. Instead of tracking the truth of allsub-formulas, our
automatonwillonly track thetruth of sub-formulasin subFGX(φ).
SincesubFGX(φ)issmallerthan sub(φ)(asillustratedbyExample 5),this results in smaller automata and better performance in practice.
But this is not our only reason for tracking fewer sub-formulas. As
we will show towards the end of this section, tracking the truth
offewersub-formulasrevealsthateveryrunoftheautomatonis
łmonotonicž,whichcanthenbeexploitedtoarguethatthenumber
ofstates visitedinthe run of Arφonany stringissmall.
Letusfixφ∈LTL[F,G,X].Thestatesofourautomaton Arφwill
keep track of which sub-formulasin subFGX(φ)are trueand which
onesarenot,on theinputseensofar.Thusastateisessentiallya
valuationh:subFGX(φ)→{⊤,⊥}overφ. We use Valφto denote
the setofallvaluations over φ.
While keeping track of the truth of sub-formulae is necessary, it
is not sufficient. In order to determine truth of formulas in LTL[X]
likeXXa, the automaton will additionally also keep track of the
last few events seen, in its control state. How many events need
to be tracked depends on the number of Xoperators that appear
inLTL[X]sub-formulasof φ.Recallthatweareassumingthat Xs
have been pushedas farinas possible in φ.
Forψ∈LTL[X], define Xdepth(ψ)to be the nesting depth of
Xoperators in ψ. And more generally, for φ∈LTL[F,G,X], we
defineXdepth(φ)=max{Xdepth(ψ)|ψ∈sub(φ)∩LTL[X]}. For
example, LTL[X]sub-formulasof XG(hhhhhhhhhhhhhhhhh=⇒(XXXnnnnnnnnnnnnnnnnn))arehhhhhhhhhhhhhhhhhandthe
sub-formulas of XXXnnnnnnnnnnnnnnnnn. Thus,Xdepth(XG(hhhhhhhhhhhhhhhhh=⇒XXXnnnnnnnnnnnnnnnnn))=3. On
theotherhand,sincetheonly LTL[X]sub-formulasof hhhhhhhhhhhhhhhhh∧(XGnnnnnnnnnnnnnnnnn)
arehhhhhhhhhhhhhhhhhandnnnnnnnnnnnnnnnnn,Xdepth(hhhhhhhhhhhhhhhhh∧(XGnnnnnnnnnnnnnnnnn))=0.
Tocomputethenextstate h′obtainedafterreadingasymbol ein
stateh,theautomatonneedstoupdatethetruthofallsub-formulas
insubFGX(φ). It turns out that we can, in fact, compute the truth
ofallsub-formulasin sub(φ)(andthusthevaluation h′)solelyby
lookingath,e,theformula φandthelast keventsseeninthetrace,
wherek=Xdepth(φ). This definition (of how truth of sub(φ)is
updated) is critical not only in defining the automaton but also
instatingitscorrectness.Wepresentthisdefinitionbeforegiving
theformaldefinitionof Arφ.Inthisdefinition,wewilluse Σ≤kto
denotethe setofallsequencesover Σof length at most k.
Definition 2. Letφ∈LTL[F,G,X],h∈Valφandbuf∈Σ≤k.
For any event e∈Σ,post(h,buf,e):sub(φ)→{⊤,⊥}is defined
inductivelyas follows.
post(h,buf,e)(a)=(a=e)
post(h,buf,e)(¬ϕ)=¬/parenleftBig
post(h,buf,e)(ϕ)/parenrightBig
post(h,buf,e)(ϕ1⊕ϕ2)=⊕post(h,buf,e)(ϕ1)
post(h,buf,e)(ϕ2)if⊕∈{∧,∨}
post(h,buf,e)(Gϕ)=h(Gϕ)∧post(h,buf,e)(ϕ)
post(h,buf,e)(Fϕ)=h(Fϕ)∨post(h,buf,e)(ϕ)
post(h,buf,e)(Xϕ)=/parenleftBig
buf|=fϕ/parenrightBig
Xϕ∈LTL[X]
h(ϕ)3otherwise
Havingoutlinedthebasicintuitionbehindtheconstructionof
Arφ, we are ready to present its formal definition. In the following,
for a function f:A→Band setC⊆A, we denote by f↾Cthe
restriction of fto the domain C.
3This definition assumes eis at least the second event read. post(h,buf,e)(Xϕ)=⊥
ifeisthe firstevent.
136CheckingLTL[F,G,X] onCompressedTracesin PolynomialTime ESEC/FSE ’21, August 23–28, 2021,Athens,Greece
(⊤,ϵ) (⊤,hhhhhhhhhhhhhhhhh) (⊤,nnnnnnnnnnnnnnnnn) (⊥,nnnnnnnnnnnnnnnnn) (⊥,hhhhhhhhhhhhhhhhh)
q0 q2 q1 q3 q4nnnnnnnnnnnnnnnnn
hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh
nnnnnnnnnnnnnnnnn nnnnnnnnnnnnnnnnnhhhhhhhhhhhhhhhhh nnnnnnnnnnnnnnnnnhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh
nnnnnnnnnnnnnnnnn
Figure3:Automatonfortheformula φ=¬nnnnnnnnnnnnnnnnn∧G(nnnnnnnnnnnnnnnnn=⇒ ¬Xnnnnnnnnnnnnnnnnn).
Definition 3 (Automatonfor LTL[F,G,X]).Forφ∈LTL[F,G,X]
withXdepth(φ)=kand event set Σ, the DFAArφ=(Q,Σ,q0,δ,F)
isdefinedas follows.
•Thestatesin Qaretriplesoftheform (h,b,buf)whereh∈
Valφ,b∈{⊤,⊥}andbuf∈Σ≤k. Intuitively, htracks the
truthof FGX-sub-formulas of φwhilebtracks whether φis
trueontheinputreadsofar.Additionally, bufstoresthelast
ksymbolsread bythe automatonthus far.
•The initial state q0is(h0,⊥,ϵ)where for every Gψ,Fψ∈
subFGX(φ),h0(Fψ)=⊥andh0(Gψ)=⊤.
•Thetransitionfunction δisgivenasfollows: δ((h,b,buf),e)=
(post(h,buf,e)↾subFGX(φ),post(h,buf,e)(φ),buf′),wherebuf′
istheprefixoflength koftheconcatenatedsequence e·buf.
•The final states F={(h,⊤,buf)|h∈Valφandbuf∈Σ≤k}.
Letusillustrate the automatonconstruction withan example.
Example 6. Consider the formula φ=¬nnnnnnnnnnnnnnnnn∧G(nnnnnnnnnnnnnnnnn=⇒ ¬Xnnnnnnnnnnnnnnnnn)from
Example2.Thebackwardsautomaton ArφforφisshowninFigure 3;
thealphabetisassumedtobe Σ={hhhhhhhhhhhhhhhhh,nnnnnnnnnnnnnnnnn}.Thesetofsub-formulas
subFGX(φ)={G(nnnnnnnnnnnnnnnnn=⇒ ¬Xnnnnnnnnnnnnnnnnn)}is singleton, and thus there are 2
valuations in Valφ. Further, Xdepth(φ)=1 and thus the buffer size
isatmost1.Thestatesof Araretriples (h,b,buf),whereh∈Valφ,
b∈{⊤,⊥}andbuf∈{hhhhhhhhhhhhhhhhh,nnnnnnnnnnnnnnnnn,ϵ}. In the figure, we only show the first
component(valuation h)andthethirdcomponent(thebuffer)of
the state. Since there is only one formula in subFGX(φ), we write
thevaluation hasthetruthvalueitmapsthesub-formulato.The
component bcan be inferred fromthe figure Ð b=⊤in a state iff
the state isan accepting state (state q1).
Nowconsiderthetraces τ1=hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnandτ2=hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhnnnnnnnnnnnnnnnnn.Observethat
theautomatonrejectsthetrace τr
1=nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhbutaccepts τr
2=nnnnnnnnnnnnnnnnnhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhas
τ1̸|=fφbutτ2|=fφ.
The correctnessproof oftheautomaton constructionin Defini-
tion3relieson the following technical lemma whichsaysthat the
automatoncorrectlycomputesthetruthofeverysub-formula.Itcan
beprovedusinganeasyinductionon |τ|andstructuralinduction
onthe formula.
Lemma 4.1. Forφ∈LTL[F,G,X], letArφ=(Q,Σ,q0,δ,F)be the
DFAasgiveninDefinition 3.Foranyexecution τ=eσwheree∈Σ,
foranyψ∈sub(φ),τ|=fψifandonlyif post(δ(q0,σr),e)(ψ)=⊤.
Wecannowstatethecorrectnessofourautomatonconstruction.
Theorem 4.1. Letφ∈LTL[F,G,X]andArφbetheDFAgivenin
Definition 3.Foranyexecution τ,τ|=fφifandonlyif τr∈L(Arφ).
Proof.Letτ=eσ. Observe that τr∈L(Arφ)iffδ(q0,τr)=
(h,⊤)forsomeh.Fromthedefinitionofthetransitionfunction δ,
thisisequivalentto post(δ(q0,σr),e)(φ)=⊤.FromLemma 4.1,this
isthe same as τ|=fφandthereby establishing the theorem. □Size ofArφ.Observe that the number of states of the automaton
Arφis2|subFGX(φ)|+1|Σ|k,wherek=Xdepth(φ).SincesubFGX(φ)⊆
sub(φ)and|sub(φ)|≤|φ|,the number of states is O(2|φ||Σ|k).
We next argue that though ArφhasO(2|φ||Σ|k)states, in any
run, it goes through at most O(|φ||Σ|k)states. This is based on the
observationthat state changes in Arφaremonotonic .
Consider two valuations д,h:subFGX(φ)→{⊤,⊥}. We will
say thatд⪯hif for every Fψ∈subFGX(φ), ifд(Fψ)=⊤then
h(Fψ)=⊤, and for everyMψ∈subFGX(φ)whereM∈{X,G}, if
д(Mψ)=⊥thenh(Mψ)=⊥.
Lemma 4.2. Forφ∈LTL[F,G,X], letArφ=(Q,Σ,q0,δ,F)be the
DFA defined in Definition 3. Letu∈Σ∗and let states (h1,b1,buf1)
and(h2,b2,buf2)be such that δ((h1,b1,buf1),u)=(h2,b2,buf2).
Then,h1⪯h2.
TheproofofLemma 4.2followsfromthedefinitionof thetran-
sition function δandinduction onthe length of u.
Lemma4.2establishes that once the valuation component of
thestatechanges,youneverrevisitthesamevaluation.Sincethe
assignment to any ψ∈subFGX(φ)can change at most once, the
numberofvaluationsvisitedinanyrunisboundedby |subFGX(φ)|,
thereby giving a bound on the number of states visited in any run:
Corollary4.1. Letφ∈LTL[F,G,X]beaformulaover Σ.TheDFA
ArφvisitsO(|φ||Σ|k)distinct states onany inputtrace τ∈Σ∗
5 MONITORING COMPRESSEDTRACES
AGAINSTLTL [F,G,X]
We will now present our main result Ð an efficient algorithm to
check,givenanSLP G=(T,N,S,R)andφ∈LTL[F,G,X],if/llbracketS/rrbracket|=f
φ.OuralgorithmfollowsthetemplatealgorithmforSLPsoutlinedin
Section2.3. That is, we will łrunž the automaton Arφ(Definition 3)
on the uncompressed trace /llbracketS/rrbracket,without explicitly uncompressing
the SLP. This can be accomplished by computing, for every state
qandnon-terminal A∈N,thestateδ(q,/llbracketA/rrbracketr)4,andthenfinally
checkingδ(q0,/llbracketS/rrbracketr)∈F,whereq0isthe initialstate and Fisthe
set of final states of Arφ. As pointed out in Section 2.3, this runs in
O(|G||Arφ|D)time(where Disthetimetocomputethetransition
function), which given the description of Arφ, isO(|G||φ|2|φ||Σ|k),
wherek=Xdepth(φ).Now,wecanobservethatitisnotnecessary
to compute δ(q,/llbracketA/rrbracketr)for every state q, but only for the states
visited during a run of Arφon/llbracketS/rrbracketr. This can be accomplished if
weusedałon-the-flyžalgorithmforthe δ(q,/llbracketA/rrbracketr)computations.
For such an algorithm, given the monotonicity properties of Arφ
(Lemma4.2)andtheresultingboundonthenumberofvisitedstates
(Corollary 4.1),wecanimprovetherunningtimeto O(|G||φ|2|Σ|k).
The main observation in this section is that this łon-the-flyž
algorithmin fact has a runningtime thatispolynomialin the size
ofGandφ. This requires us examine this algorithm in some detail,
andanalyze its running time carefully.
Recallthatastateof Arφisoftheform (h,b,buf)whereh∈Valφ,
b∈{⊤,⊥}isaBooleanrecordingthetruthof φ,andbufisthebuffer
trackingthelast ksymbolsread.Now,consideranon-terminal A,
4RecallthatAr
φrunsthe execution in reverse.
137ESEC/FSE ’21, August 23–28, 2021,Athens,Greece MinjianZhang,UmangMathur, andMahesh Viswanathan
and state (h,b,buf). Let(h′,b′,buf′)=δ((h,b,buf),/llbracketA/rrbracketr). Based
ontheDefinition 2,weknowthatthevalueoftheBoolean bdoesnot
influencethevaluesof h′,b′,andbuf′.ThisBoolean bisonlyneeded
to determine if the last state (i.e., δ(q0,/llbracketS/rrbracketr)) is a final state, This
can alternatively be determined from the valuation h′at the end
andbuffer buf′usingafunctionanalogousto post(Definition 2);
weskipgivingthisdefinition.Next buf′isnothingbuttheprefixof
lengthkoftheconcatenatedstring /llbracketA/rrbracket·buf,whichcanbecomputed
inaninductivemannerbasedontherulesinthegrammar.Inthe
interests of space, we don’t give how buf′can be computed but we
assume we have a function updateBuffer (A,buf)which returns
the prefix oflength kof/llbracketA/rrbracket·buf.
Algorithm1: Computestateofautomaton Arφafterreading
the string /llbracketA/rrbracketr
1function postState( A,h,buf)
2visited←visited∪{(A,buf)}
3ifA→ethen
4 if(e,buf)∈visitedthen return h
5 else/*(e,buf)/nelementvisited*/
6 visited←visited∪{(e,buf)}
7 h′←δ((h,⊥,buf),e)
8 ifh′/nequalhthenvisited←∅
9 returnh′
10else/*A→BC*/
11 if(C,buf)∈visitedthenh′←h
12 else/*(C,buf)/nelementvisited*/
13 h′←postState (C,h,buf)
14 buf←updateBuffer (C,buf)
15 if(B,buf)∈visitedthen return h′
16 else/*(B,buf)/nelementvisited*/
17 h′′←postState (B,h′,buf′)
18 returnh′′
Thecriticalfunctionisreallythecomputationof h′givennon-
terminalA, valuation hand buffer buf. A pseudocode for this func-
tionpostState is given in Algorithm 1. We will call postState
witharguments A,h,bufonlyonce.Afterthefirstcallwewillmem-
oize this result, and if in subsequent computations, there is a need
tocompute postState (A,h,buf)wewillusethestoredresult.The
data structure storing these previously computed postState re-
sults is called visitedin Algorithm 1. Observe that monotonicity
propertiesofArφ(Lemma4.2)meanthatifthevaluation hinthe
state changes during an execution, the automaton never returns to
the same valuation again. Hence, visitedjust stores the previous
calls for the currentvaluationh;assoon asthevaluationchanges,
we reset the data structure visitedbecause the previous calls to
postState will never be repeated as hhas changed. Moreover,
this means that visitedonly stores pairs (A,buf)when a call to
postState (A,h,buf) returns the valuation h.
Inline2,werecordthefactthatwehavemadeacall postState (A,
h,buf) by adding (A,buf)tovisited. The computation then pro-
ceeds based on the rule for the non-terminal A. IfA→e(e∈Σ)h0: [(S,ϵ),(B,ϵ),(C,ϵ),(hhhhhhhhhhhhhhhhh,ϵ),(A62,hhhhhhhhhhhhhhhhh),(A32,hhhhhhhhhhhhhhhhh),(A16,hhhhhhhhhhhhhhhhh),(A8,hhhhhhhhhhhhhhhhh),
(A4,hhhhhhhhhhhhhhhhh),(A2,hhhhhhhhhhhhhhhhh),(A1,hhhhhhhhhhhhhhhhh),(nnnnnnnnnnnnnnnnn,hhhhhhhhhhhhhhhhh),(hhhhhhhhhhhhhhhhh,nnnnnnnnnnnnnnnnn),(A30,hhhhhhhhhhhhhhhhh),(A24,hhhhhhhhhhhhhhhhh),
(A6,hhhhhhhhhhhhhhhhh),(A65,nnnnnnnnnnnnnnnnn),(A33,nnnnnnnnnnnnnnnnn),(A1,nnnnnnnnnnnnnnnnn),(nnnnnnnnnnnnnnnnn,nnnnnnnnnnnnnnnnn)]
h1: [(hhhhhhhhhhhhhhhhh,nnnnnnnnnnnnnnnnn),(A32,hhhhhhhhhhhhhhhhh),(A16,hhhhhhhhhhhhhhhhh),(A8,hhhhhhhhhhhhhhhhh),(A4,hhhhhhhhhhhhhhhhh),(A2,hhhhhhhhhhhhhhhhh),(A1,hhhhhhhhhhhhhhhhh)
(nnnnnnnnnnnnnnnnn,hhhhhhhhhhhhhhhhh),(hhhhhhhhhhhhhhhhh,nnnnnnnnnnnnnnnnn)]
Figure 4: Executing Algorithm 1on SLP in Figure 2with property
φ=¬nnnnnnnnnnnnnnnnn∧G(nnnnnnnnnnnnnnnnn=⇒ ¬Xnnnnnnnnnnnnnnnnn). The valuation h0corresponds to [G(nnnnnnnnnnnnnnnnn=⇒
¬Xnnnnnnnnnnnnnnnnn)/mapsto→⊤]andh1is[G(nnnnnnnnnnnnnnnnn=⇒ ¬Xnnnnnnnnnnnnnnnnn)/mapsto→⊥]. The figure shows the
setvisitedfor each valuation. Elements are added to visitedfrom
lefttorightasrecursivecallsaremade.Initiallythevaluationis h0,
which changes to h1whenδ((h0,⊥,nnnnnnnnnnnnnnnnn),nnnnnnnnnnnnnnnnn)is computed.
isthe rule, then we return hif we have computed it before (line 4)
orfindthenewvaluationbycomputingthetransitionfunction δ.
Note that visitedis set to∅if the valuation changes (line 8). On
theotherhand,iftheruleis A→BC(lines10through17),thenwe
compute the result byłrunningž CandthenB.
Example 7. Consider the trace τfrom Example 1of the program
inFigure 1.ItscompressionasanSLPisgiveninFigure 2.Letus
fixthepropertytobecheckedtobe φ=¬nnnnnnnnnnnnnnnnn∧G(nnnnnnnnnnnnnnnnn=⇒ ¬Xnnnnnnnnnnnnnnnnn)from
Example 2.Letussee howAlgorithm 1evaluatesφonthis SLP.
Recall that subFGX(φ)={G(nnnnnnnnnnnnnnnnn=⇒ ¬Xnnnnnnnnnnnnnnnnn)}. Thus there are two
valuations h0=[G(nnnnnnnnnnnnnnnnn=⇒ ¬Xnnnnnnnnnnnnnnnnn)/mapsto→ ⊤] andh1=[G(nnnnnnnnnnnnnnnnn=⇒
¬Xnnnnnnnnnnnnnnnnn)/mapsto→⊥], withh0being the initial valuation. Next, recall that
sinceXdepth(φ)=1,the buffer isof size at most1.
The algorithm starts with a call postState (S,h0,ϵ)(i.e., buffer
isempty)whichinitiatesasequenceofrecursivecallsto postState
with different arguments. Initially visitedis empty. Line 2 of Al-
gorithm1adds(S,ϵ)tovisited,andgiventherulefor S,makesa
recursivecall postState (B,h0,ϵ)(lines11to13).Theset visited
memoizestheresultofacallto postState toavoidre-computingan
answerÐif (A,buf)∈visitedafterreturningfromacall postState
(A,h,buf)then it means that the valuation after running /llbracketA/rrbracketfrom
valuationhwith buffer bufish. Figure4shows the set visited. The
first row shows the set visitedwhile the current valuation is h0,
andthesecondrowshows visitedafterthevaluationchangesto h1.
Recursivecallsto postState addelementsto visitedintheorder
shownfrom left to right.
ThecallpostState (B,h0,ϵ)leadstoacall postState (C,h0,ϵ)
which then results ina checkof δ((h0,⊥,ϵ),hhhhhhhhhhhhhhhhh)(lines 6through 9).
Sinceδ((h0,⊥,ϵ),hhhhhhhhhhhhhhhhh)=h0(see automaton in Figure 3),visitedis
not reset. The buffer changes to hhhhhhhhhhhhhhhhh(line 14), and a call is made
topostState (A62,h0,hhhhhhhhhhhhhhhhh)(line 17). This results in a sequence of
recursive calls with non-terminals Aifor valuesi<62. To see how
storing results in visitedhelps, let us see what happens during the
callpostState (A2,h0,hhhhhhhhhhhhhhhhh).Arecursivecall postState (A1,h0,hhhhhhhhhhhhhhhhh)is
made(line13)whichreturns h0;runningtheautomatoninFigure 3
on/llbracketA1/rrbracketfromh0leaves the valuation unchanged. The updated
buffer(line14)remains hhhhhhhhhhhhhhhhh,andsince (A1,hhhhhhhhhhhhhhhhh)∈visited(becauseof
the previous call), we do not make additional recursive calls to
postState (line 17). Such savings in calls to postState happen in
manyofthe calls involving the non-terminals Ai.
Aftertherecursivecall postState (B,h0,ϵ)returnsh0(nochange
tovaluation),thealgorithmwillmakeacallto postState (A65,h0,nnnnnnnnnnnnnnnnn),
sincethebufferafterreading /llbracketB/rrbracketisnnnnnnnnnnnnnnnnn.Thisleadstocalls postState
138CheckingLTL[F,G,X] onCompressedTracesin PolynomialTime ESEC/FSE ’21, August 23–28, 2021,Athens,Greece
(A33,h0,nnnnnnnnnnnnnnnnn)andpostState (A1,h0,nnnnnnnnnnnnnnnnn)aswellasacomputationof
δ((h0,⊥,nnnnnnnnnnnnnnnnn),nnnnnnnnnnnnnnnnn).Thevaluationreturnedby δisnowh1,whichleads
tovisitedbeingresetto∅(line8).Theevolutionoftheset visited
afterthechangeofvaluationisshowninthesecondrowofFigure 4.
Afterthecall postState (A65,h0,nnnnnnnnnnnnnnnnn)returnswithvaluation h1,
we need to evaluate whether φholds. It turns out that given a
valuation of each formula in subFGX(φ)(namelyh1) and the buffer
afterA65(namelyhhhhhhhhhhhhhhhhh), we can compute the truth valuation for all
subformulas of φ, including φitself. Details of this process are
omitted in the interests of space. Carrying this computation out,
we discover that φis not true and hence the execution encoded by
the SLP inFigure 2does not satisfy φ.
Running time. The running time for each call to postState is
dominatedbyeitherthetimetakenforline7orforline14.Thisisbe-
causeifwemakerecursivecallsto postState (lines13and17)that
timecanbeascribedtothoserecursivecalls.Line7takesatmost
timeO(|φ|)while line 14 takes O(k)time (recall k=Xdepth(φ)).
Thus,eachcallto postState takesO(|φ|)time.Thenumberofpos-
sible calls to postState is at most the number of triples (A,h,buf)
whichis|G||φ||Σ|k.Thus,thetotalrunningtimecanbebounded
byO(|G||φ|2|Σ|k).Thisboundhasanexponentialdependenceon
k=O(|φ|)andwe willshowthat this can be improved.
Thekeytoimprovingtheboundistodoamorecarefulcountof
thenumberof postState calls.Monotonicity(Lemma 4.2)ensures
that there are at most |φ|different valuations h. Therefore, for any
fixedvaluation h,wewilltrytoboundthenumberofpairs (A,buf)
thatcanariseasargumentsinacallto postState withhastheval-
uation. Our observation is that this is much less than |G||Σ|k. This
is because if (A,h,buf)is an argument to postState , then /llbracketA/rrbracketbuf
must be a substring of /llbracketS/rrbracket. Let us fix the uncompressed string, i.e.,
/llbracketS/rrbracket, to beτ. As a first step towards counting such pairs (A,buf),
we define the notion of when a non-terminal Cisresponsible for
generatingthe pair (A,buf).
Definition 4. A non-terminal Cis said to be responsible for a
substringτ[i:j]ofτifCisthelabelofthelowestinternalnode
ofthe parse tree for τthat hasτ[i:j] as asubstring.
Similarly,Cisresponsibleforpair (A,buf)ifCisresponsiblefor
some occurrenceof the string /llbracketA/rrbracket·buf(which isa substring of τ).
Observe that all nodes labeled Care responsible for the same
set of pairs (A,buf). This is because such pairs are completely
determinedbytheparsetreewithrootlabeled C.Moreover,thereis
some non-terminal that is responsible for each pair (A,buf). Thus,
wecanupperboundthenumberofpairs (A,buf)bycounting the
number of pairs each non-terminal Cis responsible for. Lemma 5.1
presentsonesuchbound,anditsproofispresentedintheAppendix.
Lemma5.1. Anon-terminal Cisresponsibleforatmost O(H(C)+
k)pairs; here H(C)is the height of the parse tree whose root is
labeledC.
TakingH(G)to denote the height of the grammar (or H(S)), we
canuse Lemma 5.1toget thefollowingbound ontherunningtime.
Theorem 5.1. Given an SLP Gwith start symbol Sand formula
φ∈LTL[F,G,X], the problem of determining if /llbracketS/rrbracket|=fφcan be
solvedintime O(|G|(H(G)+k)|φ|2).Theorem 5.1follows from observing that Lemma 5.1shows that
thenumberofcallsto postState isboundedby O(|G|(H(G)+k)|φ|)
andthe running time ofeachcallto postState isat mostO(|φ|).
6 EXPERIMENTALEVALUATION
Wegaugethefeasibilityofourproposedapproachofmonitoring
compressed execution traces by comparing the performance of
our algorithm against that of the standard approach of monitoring
traces without compressingthem. The goals of our evaluation are:
(1)Compression ratios. The asymptoticruntime ofour algo-
rithmvaries quadratically withthesizeofthecompressed
trace (Theorem 5.1). As a result, any speed up (over analysis
of uncompressed traces) will evidently only be because of
good compression ratios. We, therefore, want to evaluate
whetherexecutiontracesfromrealworld software projects
can be compressedefficiently.
(2)Performanceofalgorithm. Ournextgoalistounderstand
howtherunningtimevarieswiththesizeofthecompressed
trace(SLP)inpractice.Further,inordertoevaluatetheprac-
ticalfeasibilityofourapproach,wewanttoevaluatewhether
ouralgorithmforanalyzingcompressedtracesperformsbet-
ter than the standard approach of analyzing (uncompressed)
traces directly, by a good margin. Finally, we want to under-
standhowthespeedupvarieswithfactorssuchascompres-
sion ratio.
We next describe ourimplementation and experimental setup
(Section6.1) andthen discuss our evaluation results (Section 6.2).
6.1 Implementation andSetup
The broad outline of our experimental setup is as follows. For our
setofbenchmarkprograms,weextractexecutiontracesusingan
off-the-shelfloggingtool.Wethencompressthesetracesasstraight
line programs (SLPs) and analyze the SLPs thus generated using
ouralgorithmdetailedinSection 5.Wealsocomparetherunning
time of our algorithm with the time it takes to analyze the original
uncompressed traces using the standard approach (i.e., running
against finitestate automatacorresponding to our LTLspecs).
Implementation. We implemented our algorithm in our tool Zip-
MOP[4], primarily written in Java (in about 500 LoC). We use
JavaMOP [1,11,34]forextractingexecutiontraces. JavaMOP in-
struments a Java program under test and adds monitoring code
ateacheventofinterestforcheckingiftheprogram’sexecutions
meetsomeformalspecification.Forourexperimentalevaluation,
weobtainedexecutiontracesbymodifying JavaMOP sothatitlogs
eventstoafile.Toanalyzeuncompressedtracesagainst LTL[F,G,X]
properties,weuse Rabinizer -4.0[24]publiclyavailableat[ 2].Ra-
binizer-4.0isastate-of-thearttoolfortranslatingLTLformulaeinto
automata.ForeachoftheLTLpropertiesweconsider,weobtain
deterministic finite automata using Rabinizer -4.0 and check if this
automataacceptsthe trace inconsideration.
Benchmarks and Traces. Our subjects are open source GitHub
repositoriesderivedfromapriorempiricalstudy[ 28]onGitHub
projects, aswellasindependentlyobtainedfrom GitHubbasedon
theirpopularityscore(measuredbyGitHubstars).Weuse JavaMOP
to instrument these repositories so that all events of interest (those
139ESEC/FSE ’21, August 23–28, 2021,Athens,Greece MinjianZhang,UmangMathur, andMahesh Viswanathan
0.0
 200.0M
 400.0M
 600.0M
 800.0M
 1.0B
Size of Traces
0
10
20
30
40
(a)Distributionof tracesizes
0.0
 500.0k
 1.0M
 1.5M
 2.0M
Size of SLPs
0
10
20
30
40 (b) Distributionof sizes of compressedtraces
0.0
 100.0
 200.0
 300.0
 400.0
 500.0
 600.0
 700.0
 800.0
Compression Ratios
0
5
10
15
20
25
30
35 (c) Distributionof compressionratios
Figure 5:Sizes of(uncompressed andcompressed)traces andcompressionratios.
that occurin any of theLTL specs) are logged.We then generated
tracesbyrunningalltestclassesoftheserepositories.Wechosethe
top100tracesbasedonthetracelengths.Theminimum,maximum
and average trace lengths in this set are 52 .6M, 1.03B and 209M.
The overalldistributionisgiven inFigure 5a.
LTLSpecifications. OurLTLpropertiesarealsoobtainedfrom[ 28].
Most of these properties specify the expected usage of different
datastructuresandAPIsusedinthesesoftwareprojects,andare
expressed in many different formalisms (regular expressions, ERE,
LTL,FSM,etc.,).Anexamplepropertyis ¬nnnnnnnnnnnnnnnnn∧G(nnnnnnnnnnnnnnnnn=⇒ ¬Xnnnnnnnnnnnnnnnnn)from
Example 2(in Section 2.2), that specifies how an iterator of the
Setcollection must be used Ð every call to nextnextnextnextnextnextnextnextnextnextnextnextnextnextnextnextnext()(denoted by
‘nnnnnnnnnnnnnnnnn’)mustbeimmediatelyprecededbyacallto hasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNexthasNext() (denoted
by ‘hhhhhhhhhhhhhhhhh’). Another such property is φ=G(cr=⇒F(cl))which
statesthataresource(suchasabufferedstream)musteventually
be closed (‘ cl’) every time it is created (‘ cr’). We identified that
10 properties were expressible in the fragment LTL[ F,G,X], and
selectedallofthemfor our study.
Setup.We compare the running times of our algorithm over com-
pressed traces to the time for analyzing the corresponding uncom-
pressed traces against our LTL[F,G,X] specifications. After ob-
tainingtraces from our benchmark projects(using JavaMOP ),we
compress these traces using the Sequitur algorithm [ 37], available
publicly [ 3], which runs in linear time in the size of the uncom-
pressedtrace.Fortheuncompressedtraces,weuse Rabinizer -4.0
to generate a deterministic finite state automaton for each prop-
erty. For every property, Rabinizer -4.0 generates a Rabin automata,
which is essentially a finite state machine, together with an ac-
ceptance condition for deciding membership of infinitewords. We
manually transformed these automata so that they are suitable for
analyzing finite traces. Our experiments were conducted over a
2.6GHz 64-bitLinux machine.
6.2 EvaluationResults
Size of Compressed Traces and Compression Ratios. While
the uncompressed traces have lengths varying from 50M to 1 .03B,
the sizes of the compressed traces (SLPs) all lie between 54k and
1.8M.TheaveragesizeoftheSLPsisapproximately329 kandthe
overall distribution ispresented in Figure 5b. The compression ra-
tiosofeachtracewasobservedtobeatleast277.Themaximumand
average compression ratiosare1016and641, andthedistribution
is shown in Figure 5c. The significant compression ratios hint thatmostopensourceprojectsgenerateexecutiontracesthathavealot
ofrepetitionandthuscanbeeffectivelycompressed.Aplausible
explanationof largeamountofrepetitionsisthatmany unittests
inoursubjectrepositoriesrepeatedlymanipulatecollectionobjects
(such as listsorsets) inaloop.
Runningtimes. InFigure 6a,weplottherunningtime(inseconds)
for every compressed trace. These times are averaged over the
runningtimeof ZipMOPacrossallthe10 LTL[F,G,X]properties
weconsider.Further,inordertoensurefaircomparisonwiththe
analysis over uncompressed traces, we exclude the time to read
(uncompressedorcompressed)tracefilesinmemoryÐincluding
I/O times would penalize theuncompressed analysis more heavily
as they work over larger files. Observe that all the times are within
0.5 second (excluding I/O time). Also observe that, as expected, the
timesincreasewiththesize ofthecompressed trace(SLP). Infact,
we can see that the time increases linearlywith the size of the SLP,
despitetheworstcasedependenceof |G|2asinTheorem 5.1(H(G)
can beO(G)inworst case).
Speed-upoveranalysisofuncompressedtraces. Wenowcom-
parehowtherunningtimeovercompressedtracescomparewith
therunningtimeofanalyzinguncompressedtracelogs.Figure 6b
shows the speed upTime to analyze uncompressedtrace
Time to analyze SLP, where,
asbefore,boththenumeratoranddenominatorareaveragetimes
over all LTL specs. Further, both the times exclude I/O time. The
maximum, minimum and average speed ups are 90 ×, 15×and 34×.
Thehighspeedupshowsthepowerofcompressioninanalyzing
trace logsas comparedto uncompressedversions.
InFigure 7aweshowhowthespeedupvarieswiththecompres-
sionratio.Asexpected,ouralgorithmperformsbetter(asagainst
the uncompressed analysis) when the compression ratio is high.
This is because the time to analyze an uncompressed trace τis
O(|τ|)(time to check membership in a finite automaton) and the
time to analyze a compressed trace Gusing our algorithm (Sec-
tion5) is proportional to O(|G|)and the speed-up thus increases
withthe quantity O(|τ|/|G|),whichisthe compressionratio.
In Figure 7b, we analyze the efficiency of the algorithm, defined
asη=Speedup
Compressionratio.Theefficiencyfactorintuitivelycaptures
how well can the speed up over uncompressed traces be explained
using the compression ratio. We observe that the efficiency val-
ues are in the range 0 .04 to 0.11, and this is likely because of the
constant multiplicative factors involved in the running time of our
140CheckingLTL[F,G,X] onCompressedTracesin PolynomialTime ESEC/FSE ’21, August 23–28, 2021,Athens,Greece
0.0
 500.0k
 1.0M
 1.5M
 2.0M
Size of SLP
0.05
0.10
0.15
0.20
0.25
0.30
0.35Average Running Time (s)
(a)Running time v/ssize of compressedtrace
0.0
 20.0
 40.0
 60.0
 80.0
 100.0
Speed Up
0
5
10
15
20
25
30
35 (b) Distributionof speedup over uncompressedanalysis
Figure 6:Runningtimeandspeed overuncompressed analysis
200.0
 300.0
 400.0
 500.0
 600.0
 700.0
 800.0
Compression Ratio
20.0
30.0
40.0
50.0
60.0
70.0
80.0
90.0Speed Up
(a)Compressionratiov/sspeedup
0.0
 500.0k
 1.0M
 1.5M
 2.0M
Size of SLP
0.06
0.08
0.10
0.12
0.14η=  Speed Up / Compression Ratio (b) Efficiencyfactorv/ssize of SLP
Figure 7:Speed up,compressionratio andefficiency
algorithmforcheckingcompressedtraces.Further,theefficiency
factorincreases(almost)monotonicallywiththesizeofthecom-
pressed format, implying that higher compression ratios are more
effective when the compressedtraces are themselves large.
7 RELATED WORK
Fromatheoreticalstandpoint,theworkthatisclosesttooursisthat
of Markey and Schnoebelen [ 33] which established the PSPACE-
hardnessforthegeneralproblemofcheckingifastring,represented
as an SLP, satisfies a formulawritten in full LTL;our resultshows
polynomial time tractability for the LTL[F,G,X] sub-fragment. No-
tably, the hardness in [ 33] arises from the use of arbitrarily nested
until operators in LTLformulae. Lohrey [ 30] comprehensively sur-
veys algorithmic and complexity-theoretic aspects of language the-
oretic questions involving SLPs. Galperin and Wigderson [ 16], and
subsequentlyothers[ 7,8,12,15,16,31,38,46]showedthatgraph
problems that are tractable on the uncompressed input become
intractable when posed over compressed ( succinct) representations.
Analysis of execution traces or event sequences has been cen-
tral to the engineering of reliable and efficient software. While
in our work, we propose the use of compression in runtime ver-
ification [ 18ś20,27,35], prior works have focused on the use of
compression in race detection [ 23], profiling [ 17,26,29,42], or
programcomprehensionusingdynamicslicing[ 45,47].Morere-
centworksonlargescaledebugging[ 41],buglocalization[ 40]and
triaging[36]usingtracedataobtainedfromstacktracesobtainedat
the time of crashes, while implicitly rely on compression provided
by databases that store large columes of trace data, they do not
leveragecompressionintheactual analysistasks(suchaspatternminingorclustering).Aninterestingavenueforfutureworkwould
betodeveloptechniquestospeedupsuchtechniquesbyleveraging
compression.
8 CONCLUSIONS
We propose the use of compression as an algorithmic paradigm to
improve the efficiency of checking if execution traces conform
to specifications written in LTL(linear temporal logic). While
this problem is intractable ( PSPACE-hard) in general, we estab-
lishapolynomialtimealgorithmfortherichfragment LTL[F,G,X]
whose formulae do not include the Uoperator of full LTL. Our
polynomialtimealgorithmleveragesamonotonicitypropertyin
the automata theoreticrepresentation of formulaein LTL[ F,G,X].
On a comprehensive benchmark suite of open source Java projects,
our evaluation confirms that execution traces can be effectively
compressed and that the membership problem of traces can be effi-
cientlydecidedovercompressedformats(straightlineprograms),
withoutdecompressingthem,resultingintosignificantspeedups
when comparedto analysisover uncompressedtraces.
ACKNOWLEDGMENTS
Minjian Zhang and Mahesh Viswanathan are respectively sup-
ported by NSF CCF 2007428 and NSF CCF 1901069. Umang Mathur
waspartiallyfundedbyaGooglePhDFellowshipandbytheSimons
Institute for the Theory of Computing.
REFERENCES
[1]2021. JavaMOP. https://github.com/runtimeverification/javamop . Accessed:
2021-02-24.
141ESEC/FSE ’21, August 23–28, 2021,Athens,Greece MinjianZhang,UmangMathur, andMahesh Viswanathan
[2]2021. Rabinizer 4 - From LTL to Your Favourite Deterministic Automaton. https:
//www7.in.tum.de/~kretinsk/rabinizer4.html . Accessed:2021-02-24.
[3]2021. Sequitur:InferringHierarchiesFromSequences. http://www.sequitur.info/ .
Accessed:2021-02-24.
[4] 2021. ZipMOP. https://github.com/minjian233/ZIPMOP . Accessed:2021-06-20.
[5]Gul Agha and Karl Palmskog. 2018. A Survey of Statistical Model Checking.
ACMTrans.Model.Comput.Simul. 28,1,Article6(Jan.2018),39pages. https:
//doi.org/10.1145/3158668
[6]Rajeev Alur and Salvatorre La Torre. 2004. Deterministic generators and games
for LTL fragments. ACM Transactions on Computational Logic 5, 1 (2004), 1ś25.
[7]José L. Balcázar, Antoni Lozano, and Jacobo Torán. 1992. The Complexity of
AlgorithmicProblemsonSuccinctInstances . SpringerUS,Boston,MA,351ś377.
https://doi.org/10.1007/978-1-4615-3422-8_30
[8]JoséL. Balcázar. 1996. The complexity of searching implicit graphs. Artificial
Intelligence 86, 1 (1996), 171ś188. https://doi.org/10.1016/0004-3702(96)00014-8
[9]Earl T. Barr, Mark Harman, Phil McMinn, Muzammil Shahbaz, and Shin Yoo.
2015. TheOracleProbleminSoftwareTesting:ASurvey. IEEETransactionon
SoftwareEngineering 41(2015), 507ś525.
[10]Ezio Bartocci, Yliès Falcone, Adrian Francalanza, and Giles Reger. 2018. Intro-
ductiontoRuntimeVerification . SpringerInternationalPublishing,Cham,1ś33.
https://doi.org/10.1007/978-3-319-75632-5_1
[11]FengChenandGrigoreRoşu.2007. Mop:AnEfficientandGenericRuntimeVeri-
ficationFramework.In Proceedings ofthe22nd Annual ACM SIGPLAN Conference
on Object-Oriented Programming Systems, Languages and Applications (Montreal,
Quebec, Canada) (OOPSLA ’07) . Association for Computing Machinery, New
York, NY, USA,569ś588. https://doi.org/10.1145/1297027.1297069
[12]Bireswar Das,PatrickScharpfenecker,andJacoboTorán. 2014. Succinct Encod-
ings of Graph Isomorphism. In Language and Automata Theory and Applications ,
Adrian-Horia Dediu, Carlos Martín-Vide, José-Luis Sierra-Rodríguez, and Bianca
Truthe(Eds.).SpringerInternational Publishing,Cham,285ś296.
[13]Giuseppe De Giacomo and Moshe Y. Vardi. 2013. Linear Temporal Logic and
Linear Dynamic Logic on Finite Traces. In Proceedings of the Twenty-Third In-
ternationalJointConferenceonArtificialIntelligence (Beijing,China) (IJCAI’13) .
AAAI Press,854ś860.
[14]M.B. Dwyer, G.S. Avrunin, and J.C. Corbett. 1999. Patterns in property spec-
ifications for finite-state verification. In Proceedings of the 1999 International
Conference on Software Engineering (IEEE Cat. No.99CB37002) . 411ś420. https:
//doi.org/10.1145/302405.302672
[15]J.Feigenbaum,S.Kannan,M.Y.Vardi,andM.Viswanathan.1998. Complexity
of problems on graphs represented as OBDDs. In STACS 98 , Michel Morvan,
Christoph Meinel, and Daniel Krob (Eds.). Springer Berlin Heidelberg, Berlin,
Heidelberg, 216ś226.
[16]Hana Galperin and Avi Wigderson. 1983. Succinct representations of graphs.
Information and Control 56, 3 (1983), 183ś198. https://doi.org/10.1016/S0019-
9958(83)80004-7
[17]Ankit Goel, Abhik Roychoudhury, and Tulika Mitra. 2003. Compactly Repre-
sentingParallel ProgramExecutions.In ProceedingsoftheNinthACM SIGPLAN
SymposiumonPrinciplesandPracticeofParallelProgramming (SanDiego,Cali-
fornia, USA) (PPoPP ’03) . Association for Computing Machinery, New York, NY,
USA,191ś202. https://doi.org/10.1145/781498.781530
[18]KlausHavelund.2000. UsingRuntimeAnalysistoGuideModelCheckingofJava
Programs.In SPINModelCheckingandSoftwareVerification ,KlausHavelund,John
Penix, and Willem Visser (Eds.). SpringerBerlin Heidelberg, Berlin, Heidelberg,
245ś264.
[19]Klaus Havelund and Grigore Rosu. 2001. Monitoring Programs Using Rewriting.
InProceedingsofthe16thIEEEInternationalConferenceonAutomatedSoftware
Engineering (ASE ’01) . IEEE Computer Society, USA,135.
[20]Sampath Kannan, Moonzoo Kim, Insup Lee, Oleg Sokolsky, and Mahesh
Viswanathan.2019. ARetrospectiveLookattheMonitoringandChecking(MaC)
Framework. In Runtime Verification , Bernd Finkbeiner and Leonardo Mariani
(Eds.).SpringerInternational Publishing,Cham,1ś14.
[21]J.C.KiefferandE.-H.Yang.2000. Grammar-basedcodes:anewclassofuniversal
lossless source codes. IEEE Transactions on Information Theory 46, 3 (2000),
737ś754.
[22]J.C. Kieffer, E.-H. Yang, G.J. Nelson, and P. Cosman. 2000. Universal lossless
compressionviamultilevelpatternmatching. IEEETransactionsonInformation
Theory46,4 (2000), 1227ś1245.
[23]DileepKini,UmangMathur,andMaheshViswanathan.2018.DataRaceDetection
on Compressed Traces. In Proceedings of the 2018 26th ACM Joint Meeting on
EuropeanSoftware Engineering Conference and Symposium onthe Foundations of
SoftwareEngineering (LakeBuenaVista,FL,USA) (ESEC/FSE2018) .Association
for Computing Machinery, New York, NY, USA, 26ś37. https://doi.org/10.1145/
3236024.3236025
[24]JanKřetínský,TobiasMeggendorfer,SalomonSickert,andChristopherZiegler.
2018. Rabinizer 4: From LTL to Your Favourite Deterministic Automaton. In
Computer Aided Verification , Hana Chockler and Georg Weissenbacher (Eds.).
SpringerInternational Publishing,Cham,567ś577.[25]N.J.LarssonandA.Moffat.2000. Off-linedictionary-basedcompression. Proc.
IEEE88,11(2000), 1722ś1732.
[26]James R. Larus. 1999. Whole Program Paths. In Proceedings of the ACM SIGPLAN
1999 Conference on Programming Language Design and Implementation (Atlanta,
Georgia, USA) (PLDI ’99) . Association for Computing Machinery, New York, NY,
USA,259ś269. https://doi.org/10.1145/301618.301678
[27]I. Lee, S. Kannan, M. Kim, O. Sokolsky, and M. Viswanathan. 1999. Runtime
Assurance Based On Formal Specifications. In In Proceedings of the International
Conference onParalleland DistributedProcessingTechniquesand Applications .
[28]O. Legunsen, W. U. Hassan, X. Xu, G. Roşu, and D. Marinov. 2016. How good
are the specs? A study of the bug-finding effectiveness of existing Java API
specifications. In 2016 31st IEEE/ACM International Conference on Automated
SoftwareEngineering (ASE) . 602ś613.
[29]XianfengLi,HemendraSinghNegi,TulikaMitra,andAbhikRoychoudhury.2004.
DesignSpaceExplorationofCachesUsingCompressedTraces.In Proceedings
of the 18th Annual International Conference on Supercomputing (Malo, France)
(ICS’04).AssociationforComputingMachinery,NewYork,NY,USA,116ś125.
https://doi.org/10.1145/1006209.1006227
[30]M. Lohrey. 2012. Algorithmics on SLP-compressed strings: A Survey. Groups
Complexity Cryptology 4,2 (2012), 241ś299.
[31]AntonioLozanoandJoséL.Balcázar.1990. Thecomplexityofgraphproblemsfor
succinctly represented graphs. In Graph-Theoretic Concepts in Computer Science ,
Manfred Nagl (Ed.). SpringerBerlin Heidelberg, Berlin, Heidelberg, 277ś286.
[32]Z.MannaandA.Pnueli.1987. AHierarchyofTemporalProperties.In Proceedings
of the Sixth Annual ACM Symposium on Principles of Distributed Computing
(Vancouver,BritishColumbia,Canada) (PODC’87) .AssociationforComputing
Machinery, NewYork, NY, USA,205. https://doi.org/10.1145/41840.41857
[33]N. Markey and P. Schnoebelen. 2003. Model Checking a Path. In CONCUR 2003 -
ConcurrencyTheory ,RobertoAmadioandDenisLugiez(Eds.).SpringerBerlin
Heidelberg, Berlin, Heidelberg, 251ś265.
[34]Patrick O’Neil Meredith,Dongyun Jin, DennisGriffith, Feng Chen, and Grigore
Roşu. 2011. An Overview of the MOP Runtime Verification Framework. Interna-
tionalJournalonSoftwareTechniquesforTechnologyTransfer 14,3(June2011),
249ś289. https://doi.org/10.1007/s10009-011-0198-6
[35]MoonjooKim,M.Viswanathan,H.Ben-Abdallah,S.Kannan,I.Lee,andO.Sokol-
sky. 1999. Formally specified monitoring of temporal properties. In Proceedings
of11thEuromicroConferenceonReal-TimeSystems.EuromicroRTS’99 .114ś122.
https://doi.org/10.1109/EMRTS.1999.777457
[36]Vijayaraghavan Murali, Edward Yao, UmangMathur, and Satish Chandra. 2021.
ScalableStatisticalRootCauseAnalysisonAppTelemetry.In 2021IEEE/ACM43rd
InternationalConferenceonSoftwareEngineering:SoftwareEngineeringinPractice
(ICSE-SEIP) . 288ś297. https://doi.org/10.1109/ICSE-SEIP52600.2021.00038
[37]C.G. Nevill-Manning. 1996. Inferring Sequential Structure . Ph.D. Dissertation.
Universityof Waikato.
[38]Christos H. Papadimitriou and Mihalis Yannakakis. 1986. A note on succinct
representations of graphs. Information and Control 71, 3 (1986), 181ś185. https:
//doi.org/10.1016/S0019-9958(86)80009-2
[39]AmirPnueli.1977. TheTemporalLogicofPrograms.In Proceedingsofthe18th
AnnualSymposiumonFoundationsofComputerScience(SFCS’77) .IEEEComputer
Society, USA,46ś57. https://doi.org/10.1109/SFCS.1977.32
[40]Michael Pradel, Vijayaraghavan Murali, Rebecca Qian, Mateusz Machalica, Erik
Meijer,andSatishChandra.2020. Scaffle:BugLocalizationonMillionsofFiles.In
Proceedingsofthe29thACMSIGSOFTInternationalSymposiumonSoftwareTesting
andAnalysis (VirtualEvent,USA) (ISSTA2020) .AssociationforComputingMa-
chinery, New York, NY, USA, 225ś236. https://doi.org/10.1145/3395363.3397356
[41]Rebecca Qian, Yang Yu, Wonhee Park, Vijayaraghavan Murali, Stephen Fink,
andSatishChandra.2020. DebuggingCrashesUsingContinuousContrastSet
Mining.In ProceedingsoftheACM/IEEE42ndInternationalConferenceonSoftware
Engineering: Software Engineering in Practice (Seoul, South Korea) (ICSE-SEIP
’20).AssociationforComputingMachinery,NewYork,NY,USA,61ś70. https:
//doi.org/10.1145/3377813.3381369
[42]ManosRenieris,ShashankRamaprasad,andStevenP.Reiss.2005. ArithmeticPro-
gram Paths. In Proceedings of the 10th European Software Engineering Conference
Held Jointly with 13th ACM SIGSOFT International Symposium on Foundations
ofSoftwareEngineering (Lisbon,Portugal) (ESEC/FSE-13) .AssociationforCom-
puting Machinery, New York, NY, USA, 90ś98. https://doi.org/10.1145/1081706.
1081721
[43]MartinRoesch.1999. Snort-LightweightIntrusionDetectionforNetworks.In
Proceedings of the 13th USENIX Conference on System Administration (Seattle,
Washington) (LISA ’99) . USENIXAssociation, USA,229ś238.
[44]KoushikSen,MaheshViswanathan,andGulAgha.2005. VESTA:AStatistical
Model-Checker and Analyzer for Probabilistic Systems. In Proceedings of the
Second InternationalConference onthe Quantitative Evaluationof Systems (QEST
’05). IEEE Computer Society, USA,251. https://doi.org/10.1109/QEST.2005.42
[45]TaoWangandA.Roychoudhury.2004. Usingcompressedbytecodetracesfor
slicingJavaprograms.In Proceedings.26thInternationalConferenceonSoftware
Engineering . 512ś521. https://doi.org/10.1109/ICSE.2004.1317473
142CheckingLTL[F,G,X] onCompressedTracesin PolynomialTime ESEC/FSE ’21, August 23–28, 2021,Athens,Greece
[46]Helmut Veith. 1996. Succinct representation, leaf languages, and projection
reductions. In Proceedings of Computational Complexity (Formerly Structure in
Complexity Theory) . 118ś126. https://doi.org/10.1109/CCC.1996.507675
[47]TaoWangandAbhikRoychoudhury.2008. DynamicSlicingonJavaBytecode
Traces.ACM Trans. Program. Lang. Syst. 30, 2, Article 10 (March 2008), 49 pages.
https://doi.org/10.1145/1330017.1330021[48]T.A. Welch. 1984. ATechnique for High-Performance DataCompression. Com-
puter17,6 (1984), 8ś19.
[49]En-Hui Yang and J. C. Kieffer. 2000. Efficient universal lossless data compression
algorithms based on a greedy sequential grammar transform. I. Without context
models.IEEE Transactions onInformationTheory 46,3 (2000), 755ś777.
[50]J.ZivandA.Lempel.1977. Auniversalalgorithmforsequentialdatacompression.
IEEE Transactions onInformationTheory 23,3 (1977), 337ś343.
143