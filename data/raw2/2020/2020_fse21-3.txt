Skeletal Approximation Enumeration for SMT Solver Testing
Peisen Yao
The Hong Kong University of Science
and Technology
Hong Kong, China
pyao@cse.ust.hkHeqing Huang
The Hong Kong University of Science
and Technology
Hong Kong, China
hhuangaz@cse.ust.hkWensheng Tang
The Hong Kong University of Science
and Technology
Hong Kong, China
wtangae@cse.ust.hk
Qingkai Shi
Ant Group
China
qingkaishi@gmail.comRongxin Wu
Xiamen University
China
wurongxin@xmu.edu.cnCharles Zhang
The Hong Kong University of Science
and Technology
Hong Kong, China
charlesz@cse.ust.hk
ABSTRACT
Ensuring the equality of SMT solvers is critical due to its broad
spectrum of applications in academia and industry, such as symbolic
execution and program verication. Existing approaches to testing
SMT solvers are either too costly or nd diculties generalizing
to dierent solvers and theories, due to the test oracle problem. To
complement existing approaches and overcome their weaknesses,
this paper introduces skeletal approximation enumeration (SAE), a
novel lightweight and general testing technique for all rst-order
theories. To demonstrate its practical utility, we have applied the
SAE technique to test Z3 and CVC4, two comprehensively tested,
state-of-the-art SMT solvers. By the time of writing, our approach
had found 71 conrmed bugs in Z3 and CVC4, 55 of which had
already been xed.
CCS CONCEPTS
‚Ä¢Software and its engineering !Software verication and vali-
dation .
KEYWORDS
SMT solver testing, metamorphic testing, mutation-based testing
ACM Reference Format:
Peisen Yao, Heqing Huang, Wensheng Tang, Qingkai Shi, Rongxin Wu,
and Charles Zhang. 2021. Skeletal Approximation Enumeration for SMT
Solver Testing. In Proceedings of the 29th ACM Joint European Software
Engineering Conference and Symposium on the Foundations of Software Engi-
neering (ESEC/FSE ‚Äô21), August 23‚Äì28, 2021, Athens, Greece. ACM, New York,
NY, USA, 13 pages. https://doi.org/10.1145/3468264.3468540
1 INTRODUCTION
Satisability Modulo Theory (SMT) solvers evaluate the satisa-
bility of formulas over rst-order theories, such as integers, reals,
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for prot or commercial advantage and that copies bear this notice and the full citation
on the rst page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior specic permission and/or a
fee. Request permissions from permissions@acm.org.
ESEC/FSE ‚Äô21, August 23‚Äì28, 2021, Athens, Greece
¬©2021 Association for Computing Machinery.
ACM ISBN 978-1-4503-8562-6/21/08. . . $15.00
https://doi.org/10.1145/3468264.3468540bit-vectors, and strings [ 11,20,27,28,30,32,42]. To date, SMT
solvers have been widely used in a variety of techniques, such as
testing [ 23,33], verication [ 13,29], program repair [ 41], program
synthesis [ 14,50], and others. Despite the tremendous research
progress in SMT solving, state-of-the-art SMT solvers are still error-
prone [ 22,39,59,60]. Bugs in SMT solvers can aect the correctness
and robustness of the software that depends on the solvers. For in-
stance, in symbolic execution, spurious satisfying assignments (i.e.,
models) for path conditions are mapped to infeasible test inputs. In
program verication, wrong satisability results can invalidate the
results of the veriers, which can have detrimental consequences
for safety-critical domains [45, 58].
The predominant approach to validating SMT solvers consists of
various testing techniques. An important and challenging problem
is the test oracle, i.e., the input formula‚Äôs satisability, which is
crucial for detecting correctness bugs in SMT solvers. For example,
a buggy solver may return ‚Äúunsat‚Äù (i.e., unsatisable) for satisable
formulas, or return ‚Äúsat‚Äù (i.e., satisable) for unsatisable formulas.
To address the oracle problem, there are two categories of tech-
niques, dierential testing and oracle-guided approach. Dierential
testing techniques randomly generate syntactically valid formulas,
solve the formulas using multiple SMT solvers, and compare the
solving results to identify correctness bugs [ 15,19,48,59]. However,
dierential testing cannot be applied when a formula contains some
solver-specic extensions. For example, a formula with the specic
Z3 [28] extension ‚Äúassert-soft‚Äù cannot be solved by CVC4 [11].
In comparison, the oracle-guided approach systematically syn-
thesizes formulas whose satisability results are known by con-
struction [ 22,39,60]. Such information acts as the oracle, i.e., an
SMT solver violating the results is buggy. Compared to dieren-
tial testing, they do not need to run a formula against dierent
solvers and, thus, are usually more lightweight and easier to deploy.
However, we observe that existing oracle-guided techniques still
face the generality problem, owing to the innate semantic com-
plexity of SMT problems. As illustrated in the last three rows of
Table 1, on the one hand, some strategies only apply to specic
theories [ 22,60]. On the other hand, while the technique in [ 39] is
general for dierent theories, it only partially addresses the oracle
problem, i.e., its mutation strategy can only generate satisable
mutants. Consequently, the technique can miss certain bugs, i.e., a
formula is unsatisable, but the solver returns ‚Äúsat‚Äù.
1141ESEC/FSE ‚Äô21, August 23‚Äì28, 2021, Athens, Greece Peisen Yao, Heqing Huang, Wensheng Tang, Qingkai Shi, Rongxin Wu, and Charles Zhang
Table 1: Comparison among state-of-the-art techniques. The
‚ÄúOracle‚Äù column represents whether the tool can generate
formulas whose satisability is known by construction. The
‚ÄúTheory‚Äù column represents the supported theories.
Technique Oracle Theory
Blotsky et al. [15] dierential string
Scott et al. [48] dierential string, oat
Winterer et al. [59] dierential all theories
Bugariu et al.[22] sat,unsat string
Winterer et al. [60] sat,unsat int, real, string
Mansur et al. [39] sat all theories
This paper presents a new oracle-guided approach to testing
SMT solvers, which signicantly complements existing work, in
that our strategy is general enough for all theories and can generate
both satisable and unsatisable mutants. Our approach builds on
the metamorphic testing formalization [ 25], which takes as input a
seed formula œÜ, and tests the solver by identifying the inconsistency
between the satisability result of œÜand its equi-satisable mutants.
To generate the mutants, we propose to use a less-explored meta-
morphic relation that rests on a fundamental property of rst-order
formulas: let œÜoandœÜube an over-approximation and an under-
approximation of œÜrespectively, we have (1) œÜis satisable)
œÜois satisable , and (2)œÜis unsatisable)œÜuis unsatisable .
Thus, in our approach, with the satisability of a seed œÜdeter-
mined by the solver, we further compute an equi-satisable mutant
œÜoorœÜuvia logical approximations. If the solver does not provide a
consistent result for œÜand its approximations, then a potential aw
manifests. By nature of the metamorphic relation, our approach
can generalize to dierent theories and generate both satisable
and unsatisable mutants.
To instantiate the metamorphic relation, the major challenge
is how to correctly and eciently approximate the seed formulas.
Dierent from existing logical approximation techniques that are
either theory-specic [ 16,18,21] or costly due to heavyweight
logical reasoning [ 35,37,40], this paper introduces a novel gen-
eral and lightweight approximation approach, namely skeletal ap-
proximation enumeration (SAE) . SAE views an SMT formula, e.g.,
œÜ(x<10^/y.alt>5)_(x>2_z>3), as two parts: a Boolean
structure, e.g., (21^22)_(23_24), and a set of literals, e.g.,
fx<10;/y.alt>5;x>2;z>3g. The essence of SAE is to obtain
equi-satisable formulas by mutating the literals 2ilocally, which
is usually lightweight. We present a practical realization of SAE,
which is embodied by a series of literal-level mutation rules, and a
systematic way to combine the local mutants. We also prove the
correctness of our algorithms.
We have implemented the proposed idea as a tool named Sparrow
and applied the tool to testing Z3 and CVC4, two state-of-the-art
and comprehensively tested SMT solvers. By the time of writing,
Sparrow had found 29 and 42 conrmed bugs in Z3 and CVC4,
respectively. Besides, 55 of the bugs had been xed by the develop-
ers, among which 23 are correctness bugs. In summary, this paper
makes the following contributions:We present a new metamorphic testing approach for SMT
solvers, which leverages logical approximations as the meta-
morphic relation.
We introduce skeleton approximation enumeration (SAE), a
methodology for approximating SMT formulas, and propose
a practical realization of SAE.
We implement our approach as the Sparrow tool, which
detects 71 conrmed bugs in Z3 and CVC4, two state-of-the-
art SMT solvers. We also present several in-depth evaluations
to understand Sparrow‚Äôs eectiveness.
2 PRELIMINARIES
In this section, we present the notations and terminologies through-
out the paper.
Basic Notations .Satisability modulo theories (SMT) extend
the Boolean satisability problem (SAT) with the capability of rea-
soning with rst-order theories, such as integers, reals, arrays, and
strings. In a rst-order theory, a term can be a variable, a constant,
or an n-ary function applied to nterms. An atom istrue,false , or an
n-ary predicate applied to nterms. A literal is an atom or its nega-
tion. A formula is built from atoms using the Boolean connectives ,
e.g.,:;^;_;!. Given a formula œÜ, we denote its free variables and
literals by/v.altars (œÜ)andlits (œÜ), respectively. For ease of presenta-
tion, in the rest of the paper, we assume that all literals in lits (œÜ)
are distinct.
Denition 2.1. (Conjunctive Normal Form) A formula is in the
conjunctive normal form (CNF) if it is a conjunction of one or more
clauses ( C1^C2^ ), where each clause Ciis a disjunction of one
or more literals ( l1_l2_ ).
Example 2.1. In the theory of integers, the function symbols in-
cludef+; ;; =gand the predicate symbols consist of f<;; >;
;=;,g. Consider an integer formula œÜx1_: (xx>10). The
expressions 1 ;10;x, and xxare integer terms, and the expressions
x1 and:(xx>10)are literals. The formula is in CNF, which
has only one clause. By contrast, the formulas x>2!x>1 and
:(x>2^/y.alt>10)are not in CNF.
Logical Approximations .A formula œÜis satisable if there
exists an assignment to /v.altars (œÜ), under which the formula evaluates
to true. If it is impossible to nd such an assignment, the formula
is unsatisable. A formula œÜis atautology i its negation:œÜis
unsatisable. We write œï`œàto denote that the formula œï!œà
is a tautology. In other words, œï`œài the formula:(œï!œà)
:(:œï_œà)œï^:œàis unsatisable.
Denition 2.2. (Over- and Under-Approximations) Let œÜbe a
rst-order formula. We say a formula œÜoover-approximates œÜi
œÜ`œÜo(i.e.,œÜ^:œÜois unsatisable). We say a formula œÜuunder-
approximates œÜiœÜu`œÜ(i.e.,œÜu^:œÜis unsatisable).
Intuitively, the over- and under-approximations of a formula
are the necessary and sucient conditions for the formula to be
satisable, respectively.
Example 2.2. Consider an integer formula œÜx>5. Clearly, the
formulaœÜ0x>1 over-approximates œÜ. Ifx>1 does not hold,
then x>5 must also be unsatisable. Conversely, we can say that
œÜunder-approximates œÜ0.
1142Skeletal Approximation Enumeration for SMT Solver Testing ESEC/FSE ‚Äô21, August 23‚Äì28, 2021, Athens, Greece
Metamorphic Testing .A test oracle is a mechanism for deter-
mining whether a test has passed or failed. Under certain circum-
stances, however, the oracle is unavailable or too expensive to
achieve. This is known as the test oracle problem [ 57]. Metamor-
phic testing [ 25] can be exploited to alleviate the problem. Based on
the existing successful test cases, metamorphic testing generates
follow-up test cases by referring to domain-specic metamorphic
relations , which are the necessary properties of the target program
in terms of multiple inputs and their expected outputs. The viola-
tion of a metamorphic relation will be suspicious and indicate a
potential bug.
Example 2.3. LetFbe a program implementing the transcenden-
tal function ‚Äúsin‚Äù. The equation sin (œÄ x)=sin (x)is a typical
metamorphic relation with respect to F. Hence, given a successful
test case, say a=1:2, metamorphic testing generates its follow-up
test case a0=œÄ 1:2, and then runs the program over a0. Finally, the
two outputs, i.e., F(a)andF(a0), are checked to see if they satisfy
the expected relation F(a)=F(a0). If the relation does not hold, a
bug in Fmanifests.
An important property of metamorphic testing is that it does
not need a reference engine for dierential testing, because the
metamorphic relation provides an explicit oracle, i.e., the seed and
its variants must output the same result. When testing SMT solvers,
this property is particularly benecial when the test inputs contain
some solver-specic extensions.
3 PROBLEM FORMULATION
In this section, we rst present the metamorphic relation used in
our work. We then formulate skeletal approximation enumeration,
which aims to realize the metamorphic relation eectively.
3.1 Approximation-based Metamorphic
Relation
In SMT solver testing, the satisability of randomly generated
formulas is typically unknown, without which we cannot decide
whether the solver correctly solves the formulas. To address the
problem, our work follows the metamorphic testing formulation.
Specically, we propose to use a less-explored metamorphic rela-
tion for SMT problems, which builds on the following fundamental
property of rst-order logic.
T/h.sc/e.sc/o.sc/r.sc/e.sc/m.sc 3.1. LetœÜoandœÜube an over-approximation and an
under-approximation of a rst-order formula œÜ, respectively (i.e.,
œÜ`œÜoandœÜu`œÜ). We have (1) if œÜis satisable, then œÜois also
satisable, and (2) if œÜis unsatisable, then œÜuis also unsatisable.
Example 3.1. Consider the formula œÜx>5 in Example 2.2. The
formulaœÜ0x>1 over-approximates œÜ. Clearly, if œÜis satisable,
thenœÜ0is also satisable. Conversely, œÜunder-approximates œÜ0. If
œÜ0is unsatisable, then œÜmust be unsatisable.
Based on Theorem. 3.1, a metamorphic relation can be dened
within a pair of formulas (œÜ;œÜ0), whereœÜis a seed formula, and œÜ0
is a mutant. Given a formula œàand an SMT solver S, we denote S(œà)
the result of using Sto solveœà. We then dene the metamorphicrelation as follows:
S(œÜ)=S(œÜ0), where (1)
(œÜ`œÜ0ifœÜis satisable
œÜ0`œÜ ifœÜis unsatisable
To test the solver S, we could obtain and compare the solving results
S(œÜ)andS(œÜ0). IfS(œÜ),S(œÜ0), then a bug in the solver is revealed.
3.2 Skeletal Approximation Enumeration
To eectively instantiate the metamorphic relation in Equation 1, we
formulate the skeletal approximation enumeration problem, a new
methodology for approximating rst-order formulas. As mentioned
in ¬ß 1, an SMT formula œÜconsists of two parts: a Boolean structure
and a set of literals in some rst-order theory.
Denition 3.1. (Skeletal Approximation Enumeration) Given a
formulaœÜwith a set of literals lits (œÜ)=f21; : : : ;2ng, skeletal
approximation enumeration (SAE) computes the approximations
ofœÜby enumerating the approximations of the literals.
For a given literal 2i2lits (œÜ), SAE can randomly pick a new
literal l0
ito replace the literal, such that 2i`l0
iorl0
i`2i. We
denote the resulting mutant as œÜ0œÜ[l0
i=2i].
Example 3.2. Consider a satisable integer formula œÜ (x<
10^/y.alt>5)_(x>2_z>3). According to the metamorphic relation
in Equation 1, we should obtain the mutants by over-approximating
œÜ. Suppose x<10 is chosen for mutation. After replacing x<10
byx<11 (an over-approximation of x<10), we obtain a mutant
œÜ0(x<11^/y.alt>5)_(x>2_z>3), which over-approximates
the seedœÜ.
To realize skeletal approximation enumeration, there are many
potential methods for selecting the literals in a seed formula and
picking the new literals for replacement. These methods should
address the following challenges.
Correctness . First, we need to preserve the metamorphic rela-
tion in Equation 1, i.e., enforce that the mutant does over- or
under-approximate the seed formula, subject to the satisability of
the seed. In essence, SAE generates the mutants by enumerating
literal-level approximations. For the skeleton in Example 3.2, over-
approximating the literal x<10 can yield an over-approximation
of the seed formula. However, simply approximating a literal in a
given formula may lead to a nondeterministic mutant that can be
either an over-approximation or an under-approximation. Conse-
quently, the mutation strategy can violate Equation 1, making the
satisability of the mutant unpredictable.
Example 3.3. Suppose we need to over-approximate an integer
formulaœÜx>5!/y.alt>10. Clearly, the formula x>1 over-
approximates x>5. However, after replacing x>5 by x>1, the
new formula œÜ0x>1!/y.alt>10 does not over-approximate œÜ.
This is because
œÜ: (x>5)_/y.alt>10x5_/y.alt>10
œÜ0: (x>1)_/y.alt>10x1_/y.alt>10
Since x1 under-approximates x5, we conclude that œÜ0is an
under-approximation of œÜ.
1143ESEC/FSE ‚Äô21, August 23‚Äì28, 2021, Athens, Greece Peisen Yao, Heqing Huang, Wensheng Tang, Qingkai Shi, Rongxin Wu, and Charles Zhang
Eciency and Generality . Second, it is crucial but challenging
to approximate the seed formulas in various theories eciently,
considering SMT problems‚Äô innate semantic richness. The formulas
can encode relations about diverse variables, such as integers, reals,
bit-vectors, and oating points. The relations can be combined with
dierent Boolean connectives ( ^;_;:;!, etc.) in a complicated
manner. While there are many algorithms for approximating rst-
order formulas in the SMT solving literature, most of them are
either theory-specic [ 16,18,21], or rely on heavy-weight logical
reasoning [ 35,37,40], thereby undermining their applicability in
SMT solver testing.
Problem Statement .Based on the discussion above, we aim to
address two challenges in using skeletal approximation enumera-
tion to instantiate the metamorphic relation in Equation 1:
(1) How to guarantee that the generated mutant indeed over-
or under-approximates the seed formula? (2) How to design
the mutation strategies for eciently mutating literals in
dierent theories?
4 APPROACH
In this section, we rst present and prove the basic principle under-
lying our approach, which addresses the rst challenge. We then
present our literal-level mutation strategies, which address the sec-
ond challenge. Finally, we describe how to combine the literal-level
mutants for testing SMT solvers.
4.1 Approximation from CNF
Skeletal approximation enumeration approximates a formula by
enumerating the approximations of its literals. To ensure that the
literal-level approximations preserve the metamorphic relation in
Equation 1, we need to ll the gap between (1) approximating a seed
formula that can be an arbitrary Boolean combination of literals
and (2) approximating the individual literals in the seed.
To ll the gap, our key idea is to rst transform a seed formula
into a suitable ‚Äúinternal form‚Äù, and then design the mutation op-
erators. Our idea draws inspiration from existing SMT solving
algorithms that often build on some specic representations, such
as the add-inverter graph (AIG) [ 62] the conjunctive normal form
(CNF). Specically, we lay the foundation of our approach with the
following theorem.
T/h.sc/e.sc/o.sc/r.sc/e.sc/m.sc 4.1. LetœÜbe a rst-order formula in CNF and l2lits (œÜ)
a literal in œÜ. We have (1) if a formula l0over-approximates l, then
œÜ[l0=l]must over-approximate œÜ(i.e., l`l0)œÜ`œÜ[l0=l]), and
(2) if a formula l0under-approximates l, thenœÜ[l0=l]must under-
approximate œÜ(i.e.,l0`l)œÜ[l0=l]`œÜ).
P/r.sc/o.sc/o.sc/f.sc. We rst prove (1). By the denition of CNF (Deni-
tion 2.1), we assume that œÜC1^C2^^ Cn, where each
Ci(1in) is a disjunction of literals. Without loss of gen-
erality, we suppose l0
kover-approximates lkin the n-th clause
Cn(l1_l2__ lk), i.e., lk^:l0
kis unsatisable. Next, we
prove (1) by induction on the structure of CNF formulas.(a)First, we prove that C0nCn[l0
k=lk] over-approximates Cn,
i.e., the following formula is unsatisable.
Cn^:C0
n(l1__ lk 1_lk)^: (l1__ lk 1_l0
k)
For simplicity, we abbreviate (l1__ lk 1)toB.
Cn^:C0
n(B_lk)^: (B_l0
k)
(B_lk)^(:B^:l0
k)
(B^:B^:l0
k)_(lk^:B^:l0
k)
f alse_(lk^:B^:l0
k)
Since lk^:l0
kis unsatisable, we conclude that Cn^:C0n
is unsatisable, i.e., C0nover-approximates Cn.
(b)Then, we prove that œÜ0œÜ[C0n=Cn] over-approximates œÜ,
i.e., the following formula is unsatisable.
œÜ^:œÜ0(C1^^ Cn 1^Cn)^: (C1^^ Cn 1^C0
n)
For simplicity, we abbreviate (C1^^ Cn 1)toœà.
œÜ^:œÜ0(œà^Cn)^: (œà^C0
n)
(œà^Cn)^(:œà_:C0
n)
(œà^Cn^:œà)_(œà^Cn^:C0
n)
f alse_(œà^Cn^:C0
n)
Since Cn^:C0nis unsatisable (as proved in (a)), we conclude
thatœÜ^:œÜ0is unsatisable, i.e., œÜ0over-approximates œÜ.
Taking (a) and (b) together, we complete the proof for (1). The proof
for (2) is similar. We omit the details due to lack of space. 
Theorem 4.1 is crucial for fullling the correctness criterion of
skeletal approximation enumeration. Specically, if a seed formula
œÜhas been transformed into CNF, then locally over- or under-
approximating a literal in œÜcan yield a global over- or under-
approximation of the whole formula, respectively. As a result, it
allows us to turn the problem of approximating a rst-order formula
into (1) approximating the literals in the formula and (2) composing
the literal-level mutants.
Example 4.1. Consider again the formula œÜx>5!/y.alt>10
in Example 3.3. We can rst transform œÜto CNF, and obtain a
normalized formula œÜcnf: (x>5)_/y.alt>10x5_/y.alt>10.
We then perform the mutation on the CNF formula. For instance,
consider a formula x<10 that over-approximates x5. After
replacing x5 by x<10 inœÜcnf, we obtain the mutant œÜ0
cnf
x<10_/y.alt>10 that over-approximates œÜcnf.
In what follows, we detail how to realize skeletal approximation
enumeration for testing SMT solvers. Our approach has two build-
ing blocks: designing mutation strategies for literals in dierent
rst-order theories and combining literal-level mutants to obtain
the whole formula‚Äôs mutants.
4.2 Literal-level Mutation Strategies
We present two mutation strategies, predicate symbol transforma-
tion (¬ß 4.2.1) and live predicate injection (¬ß 4.2.2), which approx-
imates a literal by mutating the predicate symbols and injecting
formula snippets, respectively. Both strategies can over- and under-
approximate a literal. Without loss of generality, we assume that
the seed formula has been transformed into CNF.
1144Skeletal Approximation Enumeration for SMT Solver Testing ESEC/FSE ‚Äô21, August 23‚Äì28, 2021, Athens, Greece
4.2.1 Predicate Symbol Transformation (PST). The rst strategy
is to mutate the predicate symbol in a literal. Our basic observa-
tion is that the predicate symbols in a rst-order theory can have
some partial order relations (ordered by logical implication). Thus,
transforming the symbols in a literal can yield the over- or under-
approximations of the literal. For example, the following is a small
sample of transformations for various theories.
Letxand/y.altbe two integer variables. The predicate x/y.alt
over-approximates x</y.alt.
Letxand/y.altbe two real variables. The predicate x>/y.altunder-
approximates x/y.alt.
Letxand/y.altbe two string variables. The predicate ‚Äú xis a
prex of/y.alt‚Äù is an under-approximation of ‚Äú /y.altcontains x‚Äù.
In what follows, we detail the mutation strategies for predicate
symbols in literals of dierent theories.
Mutating an Atom .First, suppose that the literals to be mu-
tated do not contain logical negations, i.e., each literal is an atom.
Table 2 summarizes the rules for approximating an atom in integers,
reals, bit-vectors, oating points, and strings. The rules have several
characteristics. First, for a given atom, there can be more than one
mutation rule. For example, to over-approximate x=/y.altwhere x
and/y.altare integers, we can mutate ‚Äú =‚Äù to ‚Äú‚Äù or ‚Äú‚Äù. Intuitively, if
x=/y.altholds, then x/y.altandx/y.altmust also hold. Second, the
mutations may introduce fresh constants in the background theory.
For example, when over-approximating x/y.alttox</y.alt+a, we
can use a randomly-generated integer constant awhere a>0.
Third, there are some unsupported atoms for bit-vectors and oats,
due to the overow semantics [ 17]. For example, we cannot over-
approximate xbvule/y.alttoxbvult (/y.altbvadd a) (a>0)(like the
one for integers), because bit-vectors model bounded integers (e.g,
32-bits integers), where the ‚Äúadd‚Äù function may overow. We will
present the strategy for handling such atoms in ¬ß 4.2.2.
Mutating Negated Literals .So far, the mutation rules only
apply to atoms, i.e., negation-free literals. As our goal is to mutate
a literal that can contain negations (e.g., :x>/y.alt), we proceed to
discuss the approximations of such cases. The overall idea behind
our approach is to eliminate the negations, after which we can reuse
the rules in Table 2. The challenge, however, is how to eliminate
negations soundly. Our solution is embodied by two parts.
First, we can transform the literal to an equivalent and negation-
free atom, and then reuse the mutation rules for that atom. For
example, to over-approximate the integer literal :x>/y.alt, we rst
transform it to an equivalent atom x/y.altand then apply an over-
approximation rule for x/y.alt.
Second, there are some cases where it is hard to eliminate nega-
tions by nding equivalent atoms. For example, consider a literal
:(xstr.prefixof /y.alt)in the string theory, which means ‚Äú xis not a
prex of/y.alt‚Äù. It is nontrivial to represent the literal as an equivalent
atom. To handle such cases, our approach leverages the conver-
sions between under- and over-approximations, established by the
following proposition.
P/r.sc/o.sc/p.sc/o.sc/s.sc/i.sc/t.sc/i.sc/o.sc/n.sc 4.2. Given two rst-order formulas œÜoandœÜuthat
over-approximates and under-approximates a formula œÜ, respectively,
we have (1):œÜounder-approximates :œÜ(i.e.,œÜ`œÜo):œÜo`:œÜ),
and (2):œÜuover-approximates :œÜ(i.e.,œÜu`œÜ):œÜ`:œÜu).P/r.sc/o.sc/o.sc/f.sc. We sketch the proof of (1). Since œÜ`œÜo, we have that
:(œÜ!œÜo)is unsatisable. To prove (1), we need to show that
:(:œÜo! :œÜ)is unsatisble. Observe that :(:œÜo! :œÜ)
:(::œÜo_:œÜ): (:œÜ_œÜo): (œÜ!œÜo). Since:(œÜ!œÜo)
is unsatisable, we conclude that :œÜo`:œÜ. 
Proposition 4.2 has two implications. First, it allows us to use
over-approximating techniques to generate under-approximations,
and vice versa. Second, it allows for eliminating the negation in
a literal. As such, we can soundly reuse the rules in Table 2. For
example, suppose we need to over-approximate a literal :p, which
can be processed in three steps:
(1) Negate:pand obtain an atom, i.e., :(:p)p;
(2)Under-approximate p(using the rules in Table 2), and let the
result be p0(i.e.,p0`p);
(3)Negate p0and obtain the nal result :p0(By Proposition 4.2,
we have that:p0over-approximates :p, i.e.,:p`:p0).
In the above process, we only apply under-approximation rules
and logical negations, while the nal result over-approximates the
literal:p.
Example 4.2. Let:(xstr.prefixof /y.alt)be the string literal to
be over-approximated. First, we take its negation and obtain an
atom xstr.prefixof /y.alt. Second, we under-approximate the atom
xstr.prefixof /y.alt, and let the result be /y.alt=xstr.++ ‚Äúalice‚Äù , where
str.++ represents ‚Äústring concatenation‚Äù. Finally, we negate the re-
sult and obtain:(/y.alt=xstr.++ ‚Äúalice‚Äù ), which over-approximates
:(xstr.prefixof /y.alt).
Remarks .First, we should emphasize that literal-level approxi-
mations are not restricted to the rules in Table 2. A richer set of rules
can be designed. Second, the strategy is similar to the type-aware
operator mutation presented by Winterer et al . [59] . However, their
mutations do not guarantee the preservation of satisability. This
is because they operate over formulas with arbitrary Boolean struc-
tures, and perform the mutations randomly. For example, consider
a trivially unsatisable integer formula 2 >3. The approach in [ 59]
may mutate the formula to 2 3 or 2 <3, the second of which has
a dierent satisability result.
4.2.2 Live Predicate Injection (LPI). The PST strategy transforms
the predicate symbol of a literal but has two limitations. First, it can-
not mutate certain literals such as ‚Äúover-approximating xbvule/y.alt‚Äù.
Second, the search space is conned by the seed, e.g., PST cannot
change the function symbols and Boolean connectives in the seed.
To stress-test SMT solvers, we would like to generate syntactically
more complex mutants, which can exhibit diverse control- and
data-dependence between variables.
To this end, our second mutation strategy enriches a literal by
synthesizing a new formula snippet œà, and ‚Äúinjecting‚Äù it back to the
seed formula (using some proper Boolean connectives). The basic
idea is to utilize the formula snippet to relax or restrict the solution
space of a literal, thereby yielding the logical approximations of
the literal.
Example 4.3. Consider an integer formula œÜx+/y.alt>5 and its
two mutants below:
œÜ1x+/y.alt>5_x<3 (œÜ`œÜ1)
œÜ2x+/y.alt>5^x<3 (œÜ2`œÜ)
1145ESEC/FSE ‚Äô21, August 23‚Äì28, 2021, Athens, Greece Peisen Yao, Heqing Huang, Wensheng Tang, Qingkai Shi, Rongxin Wu, and Charles Zhang
Table 2: Mutation rules for approximating an atom in dierent theories. Each atom may have one or more possible mutants
(separated by ‚Äú,‚Äù). ‚Äú a‚Äù denotes a randomly generated constant in the corresponding theory. N/A means unsupported.
Logic Atom Over-approximation Under-approximation
x</y.alt(less than) x/y.alt;x,/y.alt x+a/y.alt(a>0)
x/y.alt(less than or equal to) x</y.alt+a(a>0) x=/y.alt;x+a</y.alt(a0)
Int & Real x>/y.alt(greater than) x/y.alt;x,/y.alt x/y.alt+a(a>0)
x/y.alt(greater than or equal to) x+a>/y.alt(a>0) x=/y.alt;x>/y.alt+a(a0)
x=/y.alt(equal) x/y.alt;x/y.alt axa^a/y.alta(any a)
x,/y.alt(inequal) :(x=a^/y.alt=a)(any a) x>/y.alt,x</y.alt
xbvult/y.alt(unsigned less than) xbvule/y.alt;x,/y.alt N/A
xbvule/y.alt(unsigned less than or equal to) N/A x=/y.alt;xbvult/y.alt
xbvugt/y.alt(unsigned greater than) xbvuge/y.alt;x,/y.alt N/A
xbvuge/y.alt(unsigned greater than or equal to) N/A x=/y.alt;xbvugt/y.alt
xbvslt/y.alt(signed less than) xbvsle/y.alt;x,/y.alt N/A
Bit-Vec xbvsle/y.alt(signed less than or equal to) N/A x=/y.alt;xbvsgt/y.alt
xbvsgt/y.alt(signed greater than) xbvsge/y.alt;x,/y.alt N/A
xbvsge/y.alt(signed greater than or equal to) N/A x=/y.alt;xbvsgt/y.alt
x=/y.alt(signed equal) xbvsle/y.alt;xbvsge/y.alt abvsle xbvsle a^abvsle/y.altbvsle a(any a)
x,/y.alt(signed inequal) :(x=a^/y.alt=a)(any a) xbvsgt/y.alt,xbvslt/y.alt
x=/y.alt(unsigned equal) xbvule/y.alt;xbvuge/y.alt abvule xbvule a^abvule/y.altbvule a(any a)
x,/y.alt(unsigned inequal) :(x=a^/y.alt=a)(any a) xbvugt/y.alt,xbvult/y.alt
xfp.lt/y.alt(less than) xfp.leq/y.alt;xfp.neq/y.alt N/A
xfp.leq/y.alt(less than or equal to) N/A xfp.eq/y.alt;xfp.lt/y.alt
Float xfp.gt (greater than) xfp.geq/y.alt;xfp.neq/y.alt N/A
xfp.gt (greater than) xfp.geq/y.alt;xfp.neq/y.alt N/A
xfp.geq/y.alt(greater than or equal to) N/A xfp.eq/y.alt;xfp.gt/y.alt
xfp.eq/y.alt(equal) xfp.leq/y.alt;xfp.geq/y.alt afp.leq xfp.leq a^afp.leq/y.altfp.leq a(any a)
xfp.neq/y.alt(inequal) :(xfp.eq a^/y.altfp.eq a)(any a) xfp.gt/y.alt,xfp.lt/y.alt
xstr.</y.alt(lexicographic ordering) xstr:/y.alt;x,/y.alt (xstr.++ a)str:/y.alt(len (a)>0)
xstr:/y.alt(lexicographic ordering) xstr: < (/y.altstr.++ a) (len (a)>0) x=/y.alt;xstr.</y.alt
xstr.prefixof /y.alt(xis a prex of /y.alt) xstr:/y.alt,/y.altstr.contains x /y.alt=xstr.++ a(len (a)0)
String xstr.suffixof /y.alt(xis a sux of /y.alt) xstr:/y.alt,/y.altstr.contains x /y.alt=astr.++ x(len (a)0)
xstr.contains /y.alt(xcontains/y.alt) /y.altstr:x /y.altstr.suffixof x;/y.altstr.suffixof x
x=/y.alt(equal)xstr.suffixof /y.alt;xstr.perfixof /y.alt,xstr.suffixof a^xstr.prefixof a^
xstr.contains /y.alt,xstr:/y.alt /y.alt str.suffixof a^/y.altstr.prefixof a(any a)
x,/y.alt(inequal) :(x=a^/y.alt=a)(any a) xstr.</y.alt,/y.altstr.< x
In the mutants œÜ1andœÜ2, the snippet x<3 is injected via dis-
junction and conjunction, respectively. Observe that œÜ1andœÜ2
over-approximates and under-approximates œÜ, respectively.
More concretely, we dene the mutation strategy as follows.
Denition 4.1. (Live Predicate Injection) Given a CNF formula
œÜand a literal l2lits (œÜ), live predicate injection rst randomly
generates a formula snippet œà, and then injects the snippet as
follows: (1) if œÜis satisable, it replaces lbyl_œà, and (2) if œÜis
unsatisable, it replaces lbyl^œà.
The correctness of live predicate injection (LPI) is enforced by
the following proposition.
P/r.sc/o.sc/p.sc/o.sc/s.sc/i.sc/t.sc/i.sc/o.sc/n.sc 4.3. Letlbe a literal and œàbe an any rst-order
formula. We have (1) l_œàover-approximates l, and (2) l^œàunder-
approximates l.
P/r.sc/o.sc/o.sc/f.sc. We sketch the proof of (1). By Denition 2.2, we need
to prove:(l! (l_œà))is unsatisable. Since :(l! (l_œà))
:(:l_(l_œà)): (l_:l_œà)f alse , we have (1). 
Taking Theorem 4.1 and Proposition 4.3 together, we conclude
that the mutants produced by LPI are equi-satisable with the
seed formula œÜ, and, thus, preserve the metamorphic relation in
Equation 1. Moreover, by Proposition 4.3, the conclusion holdsregardless of the satisability of the formula snippet œà, which
can contain any variables, function symbols, predicate symbols,
and Boolean connectives. This property allows us to generate
satisability-preserving mutants that exhibit dierent and diverse
control- and data-dependence.
Algorithm for LPI .To realize the LPI mutation strategy, we
need to generate formula snippets automatically. In what follows,
we use integer arithmetic to illustrate the essence of our approach,
and the handling of other theories is similar. The key observation
behind our solution is that, by nature, SMT formulas follow a lay-
ered construction. A formula is a Boolean combination of atoms,
which are built on top of lower-level terms. For example, the integer
formulaœÜx>1^/y.alt<2 consists of two atoms, where the atom
x>1 consists of two terms xand 1.
Algorithm 1 describes the process to build a formula snippet.
The function random _select randomly picks one element from a set.
The function smt_expr takes as input the operator and operands,
and returns an SMT expression. We omit the details of the functions
as their implementations are straightforward.
At a high level, Algorithm 1 works in a top-down manner. At
the top, we rst randomly choose a Boolean connective, e.g., nega-
tion, conjunction, and disjunction (line 2). We then proceed to
build the atoms. To generate an atom, the function generate _atom
1146Skeletal Approximation Enumeration for SMT Solver Testing ESEC/FSE ‚Äô21, August 23‚Äì28, 2021, Athens, Greece
Algorithm 1: Generating an integer formula snippet.
Input : A seed integer formula œÜ
Output : A new formula snippet
1Function generate _formula _snippet (œÜ)
2 op random _select (fnone ;:;^;_;!;xorg);
3 ifop==none then
4 return generate _atom (œÜ);
5 else if op==:then
6 l generate _atom (œÜ);
7 return smt_expr (op;l);
8 else
9 l1 generate _atom (œÜ),l2 generate _atom (œÜ);
10 return smt_expr (op;l1;l2);
11Function generate _atom (œÜ)
12 op random _select (f<;; >;;=;,g);
13 t1 generate _term (œÜ),t2 generate _term (œÜ);
14 return smt_expr (op;t1;t2);
15Function generate _term (œÜ)
16 op random _select (f+; ;; =g);
17/v.alt1 random _select (/v.altars (œÜ));
18 ifœÜin linear arithmetic and op2f ; =gthen
19/v.alt2 randomly generate a constant ;
20 else
21/v.alt2 random _select (/v.altars (œÜ));
22 return smt_expr (op;/v.alt1;/v.alt2);
(line 11-line 14) rst synthesizes two integer terms using the func-
tiongenerate _term (line 15-line 22), and then relates the terms with
an integer predicate symbol, e.g., <;and >. Note that when the
seed formula is in the theory of linear integer arithmetic, we should
not synthesize non-linear terms such as x/y.altandx=/y.alt. Thus, to
avoid generating such terms, the function generate _term restricts
the second operand /v.alt2to an integer constant, when the randomly
selected operator is or=(line 19).
Example 4.4. In the following formula pair, œÜ0over-approximates
œÜ. The mutant œÜ0is obtained by replacing /y.alt=zby/y.alt=z_
x+z</y.alt 1xor/y.alt z2x, where the shaded part is a ran-
domly generated formula snippet.
œÜ(x>/y.alt_ )^/y.alt=z
œÜ0(x>/y.alt_ )^(/y.alt=z_x+z</y.alt 1xor/y.alt z2x)
Remarks .First, in principle, one can generate and inject new
formulas that are arbitrarily large and complex. However, gener-
ating such formulas can be time-consuming. Second, the mutants
generated by LPI are not necessarily in CNF. By denition, CNF
formulas only contain three Boolean connectives, i.e., ^;_, and:,
while LPI can use other Boolean connectives such as xorand!.4.3 Bug Detection with Sparrow
Based on the principle introduced in ¬ß 4.1 and the mutation strate-
gies presented in ¬ß 4.2, we have designed and implemented Sparrow,
a tool for stress-testing SMT solvers.
Bug Types .Sparrow can detect three categories of bugs: (1)
soundness bugs : the solver returns ‚Äúunsat‚Äù for satisable formulas,
or returns ‚Äúsat‚Äù for unsatisable formulas; (2) invalid model bugs :
a formula is satisable and the solver returns ‚Äúsat‚Äù, but the solver
yields an infeasible model that falsies the formula; and (3) crash
bugs: the solver terminates abnormally when solving a formula,
which can be caused by some internal assertion failures or memory
safety problems such as buer overow. We refer to the rst two
categories as the correctness bugs .
Algorithm .Algorithm 2 shows the general workow of Spar-
row, which takes as input a set of seed formulas and an SMT
solver under test. The three sets soundness_bugs ,model_bugs , and
crash_bugs are used to collect soundness, invalid model, and crash
bugs, respectively (line 2). In each round of the loop, we rst ran-
domly choose a formula œÜfrom the seeds, convert it into CNF, and
pass the CNF formula to the SMT solver. If the solve yields ‚Äúsat‚Äù, we
generate a mutant œÜ0by over-approximating œÜ(line 10). Otherwise,
we obtain a mutant œÜ0by under-approximating œÜ(line 12). We
then invoke the solver to solve the mutant, and check whether it
gives a consistent answer or not. If not, we have found a candidate
soundness bug (line 15). If the answer is consistent and ‚Äúsat‚Äù, but
the solver returns a model that falsies œÜ0, we have found an invalid
model bug (line 19). Finally, if the solver crashes on the mutant, we
have found a candidate crash bug (line 21).
In Algorithm 2, the two sub-procedures over_approximate and
under_approximate can be implemented using the rules presented
in ¬ß 4.2. Briey, to approximate a CNF formula œÜ, we randomly select
a subset of literals from lits (œÜ), and then apply the corresponding
literal-level mutations. Note that, to guarantee the correctness, the
approximation type for a formulas‚Äô literals should be the same. For
example, if we over-approximate one literal but under-approximate
the other, it would be hard to gure out whether the solution space
of the CNF formula is enlarged or reduced. Consequently, we cannot
ensure whether the nal mutant over- or under-approximates the
seed formula.
Implementation .We have implemented Sparrow in 9,440 lines
of Python code, which instantiates Algorithm 2 as follows. First, we
convert a seed formula into CNF using Tseitin [54]‚Äôs CNF transfor-
mation algorithm, whose time complexity is linear in the formula
size. Second, for each seed formula, we generate 300 mutants by
default (line 8). Third, since the number of literals in a formula can
be gigantic, in practice, we bound the number of mutated literals
in each mutant as 5. To mutate each selected literal, we randomly
apply one applicable strategy from PST (¬ß 4.2.1) and LPI (¬ß 4.2.2).
After collecting the candidate bugs, we reduce the sizes of the
bug-revealing formulas via delta debugging [ 63]. We have auto-
mated the test case reduction, using ddSMT [ 2] and pyDelta [ 3], two
open-source delta debuggers for the SMT-LIB2 language. Finally,
we contact the solver developers to conrm the bugs.
1147ESEC/FSE ‚Äô21, August 23‚Äì28, 2021, Athens, Greece Peisen Yao, Heqing Huang, Wensheng Tang, Qingkai Shi, Rongxin Wu, and Charles Zhang
Algorithm 2: Testing SMT solvers via approximation.
Input : A set of seed formulas Seeds and an SMT solver S
Output : The candidate bugs
1Procedure test_smt_solver( Seeds ;S)
2 soundness _bu/afii10069.itals ; ;model _bu/afii10069.itals ; ;crash _bu/afii10069.itals ;;
3 while some budget is not reached do
4œÜ randomly select a formula from Seeds ;
5œÜ transformœÜinto CNF;
6 res solveœÜwith the solver S;
7 /* generate nequi-satisfiable mutants */
8 fori=1tondo
9 ifres==‚Äúsat‚Äù then
10 œÜ0 over_approximate (œÜ);
11 else
12 œÜ0 under_approximate (œÜ);
13 res0 solveœÜ0with the same solve S;
14 ifres0,resthen
15 soundness _bu/afii10069.itals soundness _bu/afii10069.itals[fœÜ0g;
16 else if res0==‚Äúsat‚Äù then
17 M a model of œÜ0returned by S;
18 ifMdoes not satisfy œÜ0then
19 model _bu/afii10069.itals model _bu/afii10069.itals[fœÜ0g;
20 else if Scrashed then
21 crash _bu/afii10069.itals crash _bu/afii10069.itals[fœÜ0g;
22 return soundness _bu/afii10069.itals[model _bu/afii10069.itals[crash _bu/afii10069.itals;
5 EVALUATION
To evaluate the eectiveness of skeletal approximation enumera-
tion, we conduct two sets of experiments. In the rst experiment,
we examine the eectiveness of Sparrow in nding bugs in Z3 and
CVC4. In the second experiment, we compare Sparrow with two
existing techniques [ 59,60] regarding performance, code coverage,
and bug nding.
5.1 Experimental Setup
Tested Solvers .We have selected Z3 [ 28] and CVC4 [ 11], the
two most popular SMT solvers for the experimental evaluation. We
choose the solvers by following four criteria. First, they have been
widely used in both academia and industry. Second, they support
most of the theories in the SMT-LIB2 standard [ 12]. Third, they
show a state-of-the-art performance, i.e., regularly achieve high
ranks in SMT-COMP [ 4], the annual SMT competitions. Finally, they
are mature and have been extensively tested by previous works [ 15,
19, 39, 48, 59, 60], which means nding their bugs is challenging.
We mainly focus on testing the default modes of the solvers. For
CVC4, we use the options --produce-models ,--incremental and
--strings-exp as needed to support all the seeds. To detect invalid
model bugs, we have supplied the --check-models option to CVC4
and the model.validate=true option to Z3.Seeds Selection .The seed formulas come from two sources: (1)
the regression test suits of several open-source SMT solvers, in-
cluding Z3, CVC4, Yices2, and OpenSMT [ 5‚Äì8], and (2) the SMT-
LIB2 standard benchmark suite maintained by the SMT-LIB Ini-
tiative [ 12]. After collecting the formulas, we preprocess them as
follows. First, we use Z3‚Äôs ‚Äú simplify ‚Äù tactic to lter out formulas
that are trivially satisable (e.g., p_:p) or unsatisable (e.g., 1 >2).
These formulas can often be instantly solved in the simplication
phase of SMT solvers, which may make our mutations futile. Next,
we exclude formulas that cannot be solved by Z3 and CVC4 within
5 seconds, to improve the testing throughput.
Environment .All the experiments are conducted on a Linux
workstation with an 80 Core Intel(R) Xeon(R) 2.20GHz processor
and 256 GB RAM. We compile Z3 and CVC4 using gcc-5.4.0, with
assertions and AddressSantizer [ 49] enabled. We use Gcov [ 52] to
measure the code coverage. All the tools are set to run in single-
threaded mode. For each of the experiments, we perform ten inde-
pendent runs and report the average results.
5.2 Results of Bug Finding
In this section, we present some statistical analyses of the bugs
found by Sparrow. All the bug reports are publicly available at the
site in [9].
Bug Count .Table 3 summarizes the status of the bugs. ‚ÄúRe-
ported‚Äù represents the number of reported bugs; ‚ÄúConrmed‚Äù rep-
resents the bugs that the developers conrm as real and unique;
‚ÄúFixed‚Äù represents the xed bugs; ‚ÄúDuplicate‚Äù represents the bugs
that the developers identify as duplicates; and ‚ÄúWon‚Äôt x‚Äù repre-
sents the bugs that the developers reject to x. Overall, Sparrow
nds 71 previously unknown, unique, and conrmed bugs in Z3
and CVC4, which are missed by the solver developers, users, and
regression testing. By the time of writing, 77.5% (55 out of 71) of
the conrmed bugs had already been xed.
Won‚Äôt x Bugs .Some bugs are marked as ‚Äúwon‚Äôt x‚Äù mainly
due to miss-congurations, i.e., improper options are supplied to the
solver. For example, in a Z3 bug report, the developer commented
that ‚Äú I am going to skip these bugs on strings tweaking strange con-
guration parameters ‚Äù.
Aected Theories .Sparrow can nd bugs in dierent SMT-LIB2
theories, such as integers, reals, bit-vectors, oating points, strings,
and the combinations of these theories. Figure 1 presents the distri-
bution of logic types among the conrmed bugs. Among the top-3
most frequent theories in Z3 are integers, strings, and bit-vectors.
Among the top-3 most frequent theories in CVC4 are integers,
strings, and reals. We observe that most of the bug-triggering in-
teger formulas are non-linear. The results indicate that decision
procedures for non-linear integer arithmetic and strings are among
the weak components in SMT solvers.
Bug Types .Table 4 shows the distribution of bug types among
the conrmed bugs. The most common bug category is crash bugs
(41 out of 71), followed by invalid model bugs (22) and soundness
bugs (8). In summary, 42.3% (30 out of 71) of the conrmed bugs
are correctness bugs (including soundness bugs and invalid model
1148Skeletal Approximation Enumeration for SMT Solver Testing ESEC/FSE ‚Äô21, August 23‚Äì28, 2021, Athens, Greece
integer string bit-vec468101211
8
5
(a) Z3integer string real5101514
11
6
(b) CVC4
Figure 1: Top-3 theory type of the conrmed bugs.
Table 3: Status of the bugs found by Sparrow.
Status Z3 CVC4 Total
Reported 38 46 84
Conrmed 29 42 71
Fixed 25 30 55
Duplicate 2 2 4
Won‚Äôt x 7 2 9
Table 4: Bug type of the conrmed bugs.
Type Z3 CVC4 Total Fixed
Soundness 4 4 8 7
Invalid model 10 12 22 16
Crash 15 26 41 32
bugs), which clearly demonstrates the strength of Sparrow in nd-
ing logic issues in SMT solvers.
Feedback of Developers .The developers of the solvers are gen-
erally responsive in xing our bug reports, which indicates that
they take our bugs seriously. For example, to quote the developers‚Äô
comments, ‚Äú This is due to a fairly obscure extended equality rewrite. ‚Äù
‚ÄúThanks a lot for the report. It turns out that the issue is a bit less
severe (though still pretty bad) than I rst thought .‚Äù As shown in
Table 4, among the 55 xed bugs, 23 (41.8%) are correctness bugs.
Besides, the developers have added the bug-triggering formulas to
the regression test suites of their solvers.
Taken together, we conclude that Sparrow is eective in nding
a large number of diverse bugs and its ndings are signicant.
5.3 Comparison to Existing Techniques
In this section, we present an in-depth study of the mutation strate-
gies in Sparrow, by comparing the following techniques:
YinYang(Fusion): a metamorphic testing based approach,
where the metamorphic relation is based on the semantic
fusion strategy [60];
YinYang(OpFuzz): a dierential testing based approach that
uses the type-aware operator mutation strategy [ 59] for the
input generation;
Sparrow(PST): the variant of Sparrow that only applies the
predicate symbol transformation strategy (¬ß 4.2.1);Table 5: Time (milliseconds) of generating a mutant.
Tool Avg Min Max StdDev
YinYang(Fusion) 4.5 1.9 78 3.8
YinYang(OpFuzz) 0.6 0.3 2.4 0.6
Sparrow(PST) 0.4 0.2 1.1 0.2
Sparrow(LPI) 1.3 0.6 33 2.4
Sparrow(PST+LPI) 0.7 0.2 3.2 0.5
Table 6: Number of tested mutants per hour.
Tool #Mutants
YinYang(Fusion) 10,582
YinYang(OpFuzz) 34,417
Sparrow(PST) 33,736
Sparrow(LPI) 26,676
Sparrow(PST+LPI) 32,365
Sparrow(LPI): the variant of Sparrow that only uses the pred-
icate symbol transformation strategy (¬ß 4.2.2);
Sparrow(PST+LPI): the default conguration of Sparrow.
We choose YinYang(Fusion) and YinYang(OpFuzz) because they
respectively represent the state-of-the-arts in the oracle-guided
approach and the dierential testing approach (¬ß 1).
We perform three experiments: (1) measuring the performance
of the tools, (2) comparing the line coverage of the solvers, and (3)
applying Sparrow to reproduce the bugs detected by YinYang. The
three experiments oer a comprehensive comparison between the
tools. To study (1) and (2), we randomly sample 1000 seed formulas,
and set each tool to generate 300 mutants per seed, following the
settings in [ 59]. Note that since YinYang(Fusion) [ 60] supports fewer
theories than YinYang(OpFuzz) [ 59] and Sparrow (c.f., Table 1), we
only sample seeds supported by all the tools. The timeout for the
solvers is set to 10 seconds per mutant.
Performance .First, we compare the performance of the ve
mutation strategies, in terms of the mutation cost and the overall
testing throughput.
Mutation Cost . Table 5 summarizes the statistics of the time cost.
For each tool, we report the average, minimum, maximum, and stan-
dard deviation of the time for generating one mutant. We make two
observations. First, the time cost of Sparrow to derive satisability-
preserving mutants is low. On average, it takes the three variants
of Sparrow 0 :4 to 1 :3 milliseconds to generate one mutant. The
speed of Sparrow(PST+LPI) lies between Sparrow(PST) and Spar-
row(LPI). Recall that PST only mutates the predicate symbols, while
LPI needs to generate a new formula snippet. Thus, Sparrow(PST)
is often faster than Sparrow(LPI). Second, the mutation speed of
Sparrow(PST+LPI) is similar to YinYang(OpFuzz), and is about 6 
faster than YinYang(Fusion).
Testing Throughput . To give a picture of the overall testing through-
put, Table 6 presents the number of tested mutants per hour. As can
be seen, YinYang(Fusion), YinYang(OpFuzz), and Sparrow(PST+LPI)
can test 10,582, 34,217, and 32,376 mutants in one hour, respectively.
1149ESEC/FSE ‚Äô21, August 23‚Äì28, 2021, Athens, Greece Peisen Yao, Heqing Huang, Wensheng Tang, Qingkai Shi, Rongxin Wu, and Charles Zhang
Table 7: Line coverage by mutating 1000 seeds (300 mutants
per seed). The baseline is the coverage of Z3 and CVC4 after
solving 1000 seeds (13.5% for Z3 and 8.7% for CVC4).
Tool Z3 CVC4
YinYang(Fusion) 17.3% 11.3%
YinYang(OpFuzz) 19.8% 14.2%
Sparrow(PST) 18.1% 13.3%
Sparrow(LPI)) 27.2 % 14.6%
Sparrow(PST+LPI) 27.9% 16.1%
We observe that most (> 98%) of the CPU time is taken up by the
SMT solvers. Therefore, the hardness of the mutant formulas is the
key factor of the throughput. For example, we nd that the mu-
tants generated by YinYang(Fusion) are often harder to solve than
other tools. Thus, the throughput of YinYang(Fusion) is smaller
than YinYang(OpFuzz) and Sparrow(PST+LPI).
To summarize, the mutation cost and testing throughput of Spar-
row(PST+LPI) are competitive against that of YinYang(OpFuzz).
Line Coverage .Second, we compare the line coverage improve-
ment achieved by the fuzz tools. The baseline is the line coverage of
Z3 and CVC4 after solving the 1000 sampled seeds, which are 13.5%
and 8.7%, respectively. We then use the fuzz tools to mutate these
seeds, run Z3 and CVC4 to solve the mutants, and measure the
solvers‚Äô cumulative line coverage. For each seed, we run each tool
to produce 100 mutants. Table 7 presents the comparison results.
As can be seen, Sparrow(PST+LPI) can consistently improve the
line coverage of the solvers over YinYang. Sparrow improves the
coverage over the baseline by 14.4% for Z3 and 7.4% for CVC4, while
the best one between YinYang(Fusion) and YinYang(OpFuzz) does
by 6.3% for Z3 and 5.5% for CVC4.
Reproducing Bugs .Finally, we conduct an experiment to com-
pare YinYang and Sparrow in terms of nding correctness bugs. In
particular, we rst select all the correctness bugs that are found by
YinYang(Fusion) and YinYang(OpFuzz) in November and December
2020, and xed by the developers by the time of writing. We then
try to reproduce the bugs using Sparrow. We choose the correct-
ness bugs because, as a metamorphic testing approach, Sparrow‚Äôs
primary goal is to nd those issues. The selected bugs cover various
theories such as integers, reals, bit-vectors, and strings.
For each of the bugs, we rst remove the seeds that can directly
reveal the bug (without being mutated). We then use Sparrow to
derive mutants from all the seed formulas with the identical logic
type.1We set the number of mutants per seed to 300 and repeat the
generation process 100 times. Then, the comparison proceeds as
follows. We rst check whether Sparrow can generate re-triggering
mutants from the seeds or not. If yes, we then check whether Spar-
row actually re-triggers the same bug. To achieve this goal, we run
the bug-revealing mutants against the rst solver commit ID with
the corresponding x. If the solver now answers correctly for the
mutants, we count the bug as successfully re-triggered.
1To oer an apples-to-apples comparison, we should have used the same seed for each
bug. However, we cannot know which seed YinYang has used to trigger a bug.Sparrow(PST) Sparrow(LPI) Sparrow(PST+LPI)51015
3814
Figure 2: The results of running Sparrow to re-trigger the
19 xed correctness bugs reported by YinYang(Fusion) and
YinYang(OpFuzz) in November and December 2020.
Figure 2 presents the reproduction results. Briey, we make two
observations. First, Sparrow(PST) and Sparrow(LPI) can reproduce
3 bugs and 8 bugs alone, respectively. But there are 7 bugs that can
only be found by Sparrow(PST+LPI), i.e., the combination of the two
strategies. Second, Sparrow(PST+LPI) successfully reproduces 73 :7%
(14 out of 19) the bugs. There are 5 bugs that cannot be reproduced,
because our current implementation has limited support for the
theories of recursive functions and abstract data types.
In summary, we nd that (1) Sparrow is competitive against
or complementary to YinYang(Fusion) and YinYang(OpFuzz) in
nding correctness bugs and (2) both of the two mutation strategies
in Sparrow contribute to its eectiveness.
5.4 Threats to Validity
The threat to internal validity mainly lies in the implementation of
our approach. To validate our implementation, we have used several
SMT solvers to cross-check if the mutants generated by Sparrow
are indeed the over- or under-approximations of the seed formula.
This validates the implementation to some extent. The threat to
external validity lies in the representativeness of the subjects. The
solvers we select for the evaluation are mature, widely-used, and
extensively tested by previous works [ 15,19,39,59,60]. The threat
to construct validity is the selection of the seed formulas and the
randomness of the mutations. To mitigate the threat, we run each
experiment ten times and use the average data.
6 DISCUSSION
Limitations of Sparrow .Our study demonstrates Sparrow‚Äôs
eectiveness for testing SMT solvers, but limitations exist in our
current implementation. First, for the predicate symbol transforma-
tion strategy (¬ß 4.2.1), Sparrow relies on manually given rules to
transform a literal. In the future, it would be interesting to synthe-
size new transformation rules automatically. For example, the CVC4
developers have applied syntax-guided synthesis (SyGuS) to gen-
erate term-level and equivalence-preserving rewriting rules [ 43].
Second, for the live predicate injection strategy (¬ß 4.2.2), Sparrow
can suer from performance issues if it attempts to generate a
large formula snippet. However, this limitation does not mean that
Sparrow can only generate small mutants, because it can mutate a
seed ‚Äúincrementally‚Äù, i.e., approximates the mutants produced in
the previous rounds. Third, Sparrow has limited support for a few
1150Skeletal Approximation Enumeration for SMT Solver Testing ESEC/FSE ‚Äô21, August 23‚Äì28, 2021, Athens, Greece
logics such as recursive functions and abstract data types, which
are recently introduced into the SMT-LIB2.6 standard.
Generality of SAE .Beyond SMT solver testing, skeletal approx-
imation enumeration suggests a general strategy for deriving se-
mantic approximations of a problem via (lightweight) syntactical
mutations. Specically, it can be protable to transform a seed into
some suitable representations and then design the mutation opera-
tors. There are several avenues for further exploring the applica-
bility of skeletal approximation enumeration. First, the techniques
and tools can facilitate testing other SMT solvers that take SMT-
LIB2 les as their input. Second, the general idea could be extended
to test other software systems that reason about programs‚Äô logic
properties, such as static analyzers and program veriers.
Future Work on Automated Debugging .While the focus of
this paper is bug detection, it could be promising to use our tech-
niques to ease the automatic debugging. First, a possible future
work is to aid delta debugging. Specically, we can trace the mu-
tations made by Sparrow, and perform some backtracking of the
mutations in the stage of delta debugging. The backtracking-based
strategy could assist or complement existing general-purpose delta
debuggers. Second, showing the minimal dierences to seed formu-
las that trigger bugs is helpful for the developers to understand the
bugs. Thus, providing the minimal literal-level mutations and the
original seed in the bug report would be another potential direction
to assist debugging.
7 RELATED WORK
SMT Solver Testing .FuzzSMT [ 19] is the rst grammar-based
fuzzing tool for SMT solvers. StringFuzz [ 15] and BanditFuzz [ 48]
follow the idea to test string and oating points solvers, respec-
tively. Winterer et al . [59] present a type-aware mutation strategy,
which mutates operators of conforming types within the seed for-
mulas to generate well-typed mutants. Falcon [ 61] explores the
combined formula-conguration space for testing SMT solvers. All
the above-mentioned techniques need to combine dierential test-
ing to nd soundness bugs. To address the test oracle problem,
several recent works generate SMT formulas whose satisability
is known by construction [ 22,39,60], which we term the oracle-
guided approach. Bugariu and M√ºller [22] propose an approach to
generating increasingly complex string formulas via satisability-
preserving transformations. Semantic fusion [ 60] fuses formula
pairs that generate mutants that are by construction either satis-
able or unsatisable. However, their implementations only support
integers, reals, and strings.2Storm [ 39] mutates the Boolean struc-
ture of a seed but can only generate satisable mutants. Compared
to the previous works, we present a new technique for the oracle-
guided approach, which applies to all theories and can generate
satisable and unsatisable mutant formulas.
Metamorphic Testing .The key idea of metamorphic testing [ 25]
is to detect violations of domain-specic metamorphic relations by
comparing the outputs between a seed test and its corresponding
mutant tests. Metamorphic testing has been successfully applied
2Note that, in theory, it could be possible to extend the idea of semantic fusion to
support other theories.in many application domains such as bioinformatics [ 26], web ser-
vices [ 24], compilers [ 36,51], debuggers [ 53], databases [ 47], ma-
chine learning-based systems [ 31,38], model counters [ 55], and
SMT solvers [60].
Our approach is an instance of metamorphic testing. A closely re-
lated work is semantic fusion [ 60], which generates equi-satisable
mutants from the concatenation of two seed formulas. Our approach
diers in two aspects. First, semantic fusion mutates variables using
the fusion functions, which can only introduce new variables and
function symbols in the mutants. In comparison, skeletal approxi-
mation enumeration can inject formula snippets, which can contain
new variables, function symbols, predicate symbols, and Boolean
connectives. Second, semantic fusion requires that the two seeds
are both satisable or unsatisable. In comparison, our algorithm
does not assume that the satisability of the seeds is known prior,
as it determines the mutation strategy according to the solving
result of the SMT solver under test.
Mutation-based Testing .A common technique for input gen-
eration is to mutate the seed corpus. For example, American fuzzy
lop (AFL) [ 1] is a well-known security-oriented fuzzer, which em-
ploys bit-level and byte-level mutations to generate new test cases.
However, such an ecient input generation approach cannot han-
dle inputs with a highly formatted structure or grammar. Thus,
grammar-aware mutation-based fuzzing has been proposed. Supe-
rion [ 56], AFLSmart [ 46], and Nautulius [ 10] are general grammar-
aware grey-box fuzzers that employ AST-based mutations, and
use code coverage to guide the mutations. CodeAlchemist [ 34]
preserves the semantic requirement, e.g., type correlation, as the
constraint during input generation. Zest [ 44] combines the coverage
feedback with property-based testing to provide better guidance for
seed prioritization. In comparison, our approach can be regarded as
an instance of grammar-aware mutation. Specically, Sparrow not
only generates syntactically correct mutants but also guarantees
their satisability results, which can serve as the ground truth for
nding correctness bugs.
8 CONCLUSION
This paper presents skeletal approximation enumeration, a new
methodology for testing SMT solvers. Our approach helped dis-
cover 71 conrmed bugs in Z3 and CVC4, two state-of-the-art and
comprehensively tested SMT solvers. More than 50 of the bugs have
been xed, and a signicant fraction of them are correctness bugs.
Our technique is general and may be adapted to other constraint
languages (such as Datalog and MiniZinc) and settings (such as
static analyzers and model checkers).
ACKNOWLEDGMENTS
We thank the anonymous reviewers for their insightful comments.
We also appreciate the developers of Z3 and CVC4 for discussing
and addressing our bug reports. Rongxin Wu is supported by the
Leading-edge Technology Program of Jiangsu Natural Science Foun-
dation (BK20202001) and NSFC61902329. Other authors are sup-
ported by the RGC16206517 and ITS/440/18FP grants from the Hong
Kong Research Grant Council, Ant Group through ant Research
Program, and the donations from Microsoft and Huawei. Heqing
Huang is the corresponding author.
1151ESEC/FSE ‚Äô21, August 23‚Äì28, 2021, Athens, Greece Peisen Yao, Heqing Huang, Wensheng Tang, Qingkai Shi, Rongxin Wu, and Charles Zhang
REFERENCES
[1]2014. AFL: american fuzzy lop. http://lcamtuf.coredump.cx/a/. Accessed: 2014.
[2] 2021. ddSMT. https://github.com/aniemetz/ddSMT.
[3] 2021. pyDelta. https://github.com/nafur/pydelta.
[4] 2021. SMT-COMP. https://smt-comp.github.io/.
[5] 2021. Z3 test scripts. https://github.com/Z3Prover/z3/src/test.
[6] 2021. CVC4 regression test suit. https://github.com/CVC4/CVC4/test/.
[7] 2021. Yices2 regression test suit. https://github.com/SRI-CSL/yices2/tests.
[8]2021. OpenSMT regression test suit. https://github.com/usi-verication-and-
security/opensmt/regression.
[9] 2021. https://smtfuzz.github.io/.
[10] Cornelius Aschermann, Tommaso Frassetto, Thorsten Holz, Patrick Jauernig,
Ahmad-Reza Sadeghi, and Daniel Teuchert. 2019. NAUTILUS: Fishing for Deep
Bugs with Grammars. In 26th Annual Network and Distributed System Security
Symposium, NDSS 2019, San Diego, California, USA, February 24-27, 2019 . The
Internet Society. https://www.ndss-symposium.org/ndss-paper/nautilus-shing-
for-deep-bugs-with-grammars/
[11] Clark Barrett, Christopher Conway, Morgan Deters, Liana Hadarean, Dejan
Jovanoviƒá, Tim King, Andrew Reynolds, and Cesare Tinelli. 2011. CVC4. In
Proceedings of the 23rd International Conference on Computer Aided Verication
(Snowbird, UT) (CAV‚Äô11) . Springer-Verlag, Berlin, Heidelberg, 171‚Äì177. http:
//dl.acm.org/citation.cfm?id=2032305.2032319
[12] Clark Barrett, Aaron Stump, and Cesare Tinelli. 2010. The satisability modulo
theories library (SMT-LIB). www. SMT-LIB. org 15 (2010), 18‚Äì52.
[13] Karthikeyan Bhargavan, Barry Bond, Antoine Delignat-Lavaud, C√©dric Fournet,
Chris Hawblitzel, Catalin Hritcu, Samin Ishtiaq, Markulf Kohlweiss, Rustan Leino,
Jay R. Lorch, Kenji Maillard, Jianyang Pan, Bryan Parno, Jonathan Protzenko,
Tahina Ramananandro, Ashay Rane, Aseem Rastogi, Nikhil Swamy, Laure Thomp-
son, Peng Wang, Santiago Zanella B√©guelin, and Jean Karim Zinzindohoue. 2017.
Everest: Towards a Veried, Drop-in Replacement of HTTPS. In 2nd Summit on
Advances in Programming Languages, SNAPL 2017, May 7-10, 2017, Asilomar, CA,
USA (LIPIcs, Vol. 71) , Benjamin S. Lerner, Rastislav Bod√≠k, and Shriram Krish-
namurthi (Eds.). Schloss Dagstuhl - Leibniz-Zentrum f√ºr Informatik, 1:1‚Äì1:12.
https://doi.org/10.4230/LIPIcs.SNAPL.2017.1
[14] Tim Blazytko, Moritz Contag, Cornelius Aschermann, and Thorsten Holz. 2017.
Syntia: Synthesizing the Semantics of Obfuscated Code. In 26th USENIX Secu-
rity Symposium, USENIX Security 2017, Vancouver, BC, Canada, August 16-18,
2017, Engin Kirda and Thomas Ristenpart (Eds.). USENIX Association, 643‚Äì
659. https://www.usenix.org/conference/usenixsecurity17/technical-sessions/
presentation/blazytko
[15] Dmitry Blotsky, Federico Mora, Murphy Berzish, Yunhui Zheng, Ifaz Kabir, and
Vijay Ganesh. 2018. StringFuzz: A Fuzzer for String Solvers. In Computer Aided
Verication - 30th International Conference, CAV 2018, Held as Part of the Federated
Logic Conference, FloC 2018, Oxford, UK, July 14-17, 2018, Proceedings, Part II
(Lecture Notes in Computer Science, Vol. 10982) , Hana Chockler and Georg Weis-
senbacher (Eds.). Springer, 45‚Äì51. https://doi.org/10.1007/978-3-319-96142-2_6
[16] Cristina Borralleras, Daniel Larraz, Enric Rodr√≠guez-Carbonell, Albert Oliveras,
and Albert Rubio. 2019. Incomplete SMT Techniques for Solving Non-Linear
Formulas over the Integers. ACM Trans. Comput. Log. 20, 4 (2019), 25:1‚Äì25:36.
https://doi.org/10.1145/3340923
[17] Aaron R. Bradley and Zohar Manna. 2007. The calculus of computation - decision
procedures with applications to verication . Springer. https://doi.org/10.1007/978-
3-540-74113-8
[18] Robert Brummayer and Armin Biere. 2009. Eective Bit-Width and Under-
Approximation. In Computer Aided Systems Theory - EUROCAST 2009, 12th In-
ternational Conference, Las Palmas de Gran Canaria, Spain, February 15-20, 2009,
Revised Selected Papers (Lecture Notes in Computer Science, Vol. 5717) , Roberto
Moreno-D√≠az, Franz Pichler, and Alexis Quesada-Arencibia (Eds.). Springer, 304‚Äì
311. https://doi.org/10.1007/978-3-642-04772-5_40
[19] Robert Brummayer and Armin Biere. 2009. Fuzzing and Delta-Debugging SMT
Solvers. In Proceedings of the 7th International Workshop on Satisability Modulo
Theories (Montreal, Canada) (SMT ‚Äô09) . Association for Computing Machinery,
New York, NY, USA, 1‚Äì5. https://doi.org/10.1145/1670412.1670413
[20] Roberto Bruttomesso, Edgar Pek, Natasha Sharygina, and Aliaksei Tsitovich.
2010. The OpenSMT Solver. In Tools and Algorithms for the Construction and
Analysis of Systems, 16th International Conference, TACAS 2010, Held as Part
of the Joint European Conferences on Theory and Practice of Software, ETAPS
2010, Paphos, Cyprus, March 20-28, 2010. Proceedings (Lecture Notes in Computer
Science, Vol. 6015) , Javier Esparza and Rupak Majumdar (Eds.). Springer, 150‚Äì153.
https://doi.org/10.1007/978-3-642-12002-2_12
[21] Randal E. Bryant, Daniel Kroening, Jo√´l Ouaknine, Sanjit A. Seshia, Ofer Strich-
man, and Bryan A. Brady. 2007. Deciding Bit-Vector Arithmetic with Ab-
straction. In Tools and Algorithms for the Construction and Analysis of Sys-
tems, 13th International Conference, TACAS 2007, Held as Part of the Joint Eu-
ropean Conferences on Theory and Practice of Software, ETAPS 2007 Braga, Por-
tugal, March 24 - April 1, 2007, Proceedings (Lecture Notes in Computer Sci-
ence, Vol. 4424) , Orna Grumberg and Michael Huth (Eds.). Springer, 358‚Äì372.https://doi.org/10.1007/978-3-540-71209-1_28
[22] Alexandra Bugariu and Peter M√ºller. 2020. Automatically testing string solvers.
InICSE ‚Äô20: 42nd International Conference on Software Engineering, Seoul, South
Korea, 27 June - 19 July, 2020 , Gregg Rothermel and Doo-Hwan Bae (Eds.). ACM,
1459‚Äì1470. https://doi.org/10.1145/3377811.3380398
[23] Cristian Cadar, Daniel Dunbar, Dawson R Engler, et al .2008. KLEE: Unassisted and
Automatic Generation of High-Coverage Tests for Complex Systems Programs..
InProceedings of the 8th USENIX Conference on Operating Systems Design and
Implementation (San Diego, California) (OSDI‚Äô08) . USENIX Association, Berkeley,
CA, USA, 209‚Äì224. http://dl.acm.org/citation.cfm?id=1855741.1855756
[24] W. K. Chan, S. C. Cheung, and Karl R. P. H. Leung. 2005. Towards a Metamor-
phic Testing Methodology for Service-Oriented Software Applications. In Fifth
International Conference on Quality Software (QSIC 2005), 19-20 September 2005,
Melbourne, Australia . IEEE Computer Society, 470‚Äì476. https://doi.org/10.1109/
QSIC.2005.67
[25] Tsong Y Chen, Shing C Cheung, and Shiu Ming Yiu. 2020. Metamorphic testing:
a new approach for generating next test cases. arXiv preprint arXiv:2002.12543
(2020).
[26] Tsong Yueh Chen, Joshua Wing Kei Ho, Huai Liu, and Xiaoyuan Xie. 2009. An
innovative approach for testing bioinformatics programs using metamorphic
testing. BMC Bioinform. 10 (2009). https://doi.org/10.1186/1471-2105-10-24
[27] J√ºrgen Christ, Jochen Hoenicke, and Alexander Nutz. 2012. SMTInterpol: An In-
terpolating SMT Solver. In Model Checking Software - 19th International Workshop,
SPIN 2012, Oxford, UK, July 23-24, 2012. Proceedings (Lecture Notes in Computer Sci-
ence, Vol. 7385) , Alastair F. Donaldson and David Parker (Eds.). Springer, 248‚Äì254.
https://doi.org/10.1007/978-3-642-31759-0_19
[28] Leonardo De Moura and Nikolaj Bj√∏rner. 2008. Z3: An ecient SMT solver. In
Proceedings of the Theory and Practice of Software, 14th International Conference
on Tools and Algorithms for the Construction and Analysis of Systems (Budapest,
Hungary) (TACAS‚Äô08/ETAPS‚Äô08) . Springer-Verlag, Berlin, Heidelberg, 337‚Äì340.
http://dl.acm.org/citation.cfm?id=1792734.1792766
[29] David Detlefs, Greg Nelson, and James B. Saxe. 2005. Simplify: A Theorem Prover
for Program Checking. J. ACM 52, 3 (May 2005), 365‚Äì473. https://doi.org/10.
1145/1066100.1066102
[30] Bruno Dutertre. 2014. Yices2.2. In Proceedings of the 16th International Conference
on Computer Aided Verication - Volume 8559 . Springer-Verlag, Berlin, Heidelberg,
737‚Äì744. https://doi.org/10.1007/978-3-319-08867-9_49
[31] Anurag Dwarakanath, Manish Ahuja, Samarth Sikand, Raghotham M. Rao,
R. P. Jagadeesh Chandra Bose, Neville Dubash, and Sanjay Podder. 2018. Iden-
tifying implementation bugs in machine learning based image classiers us-
ing metamorphic testing. In Proceedings of the 27th ACM SIGSOFT Interna-
tional Symposium on Software Testing and Analysis, ISSTA 2018, Amsterdam, The
Netherlands, July 16-21, 2018 , Frank Tip and Eric Bodden (Eds.). ACM, 118‚Äì128.
https://doi.org/10.1145/3213846.3213858
[32] Vijay Ganesh and David L Dill. 2007. A decision procedure for bit-vectors and
arrays. In Proceedings of the 19th International Conference on Computer Aided
Verication (Berlin, Germany) (CAV‚Äô07) . Springer-Verlag, Berlin, Heidelberg, 519‚Äì
531. http://dl.acm.org/citation.cfm?id=1770351.1770421
[33] Patrice Godefroid, Nils Klarlund, and Koushik Sen. 2005. DART: directed auto-
mated random testing. In Proceedings of the 2005 ACM SIGPLAN Conference on
Programming Language Design and Implementation (Chicago, IL, USA) (PLDI ‚Äô05) .
ACM, New York, NY, USA, 213‚Äì223. https://doi.org/10.1145/1065010.1065036
[34] HyungSeok Han, DongHyeon Oh, and Sang Kil Cha. 2019. CodeAlchemist:
Semantics-Aware Code Generation to Find Vulnerabilities in JavaScript En-
gines. In 26th Annual Network and Distributed System Security Symposium,
NDSS 2019, San Diego, California, USA, February 24-27, 2019 . The Internet Soci-
ety. https://www.ndss-symposium.org/ndss-paper/codealchemist-semantics-
aware-code-generation-to-nd-vulnerabilities-in-javascript-engines/
[35] Heqing Huang, Peisen Yao, Rongxin Wu, Qingkai Shi, and Charles Zhang. 2020.
Pangolin: Incremental Hybrid Fuzzing with Polyhedral Path Abstraction. In 2020
IEEE Symposium on Security and Privacy, SP 2020, San Francisco, CA, USA, May
18-21, 2020 . IEEE, 1613‚Äì1627. https://doi.org/10.1109/SP40000.2020.00063
[36] Vu Le, Mehrdad Afshari, and Zhendong Su. 2014. Compiler validation via
equivalence modulo inputs. In ACM SIGPLAN Conference on Programming Lan-
guage Design and Implementation, PLDI ‚Äô14, Edinburgh, United Kingdom - June
09 - 11, 2014 , Michael F. P. O‚ÄôBoyle and Keshav Pingali (Eds.). ACM, 216‚Äì226.
https://doi.org/10.1145/2594291.2594334
[37] Yi Li, Aws Albarghouthi, Zachary Kincaid, Arie Gurnkel, and Marsha Chechik.
2014. Symbolic Optimization with SMT Solvers. In Proceedings of the 41st ACM
SIGPLAN-SIGACT Symposium on Principles of Programming Languages (San Diego,
California, USA) (POPL ‚Äô14) . ACM, New York, NY, USA, 607‚Äì618. https://doi.
org/10.1145/2535838.2535857
[38] Pingchuan Ma, Shuai Wang, and Jin Liu. 2020. Metamorphic Testing and Certied
Mitigation of Fairness Violations in NLP Models. In Proceedings of the Twenty-
Ninth International Joint Conference on Articial Intelligence, IJCAI 2020 , Christian
Bessiere (Ed.). ijcai.org, 458‚Äì465. https://doi.org/10.24963/ijcai.2020/64
[39] Muhammad Numair Mansur, Maria Christakis, Valentin W√ºstholz, and Fuyuan
Zhang. 2020. Detecting critical bugs in SMT solvers using blackbox mutational
1152Skeletal Approximation Enumeration for SMT Solver Testing ESEC/FSE ‚Äô21, August 23‚Äì28, 2021, Athens, Greece
fuzzing. In ESEC/FSE ‚Äô20: 28th ACM Joint European Software Engineering Confer-
ence and Symposium on the Foundations of Software Engineering, Virtual Event,
USA, November 8-13, 2020 , Prem Devanbu, Myra B. Cohen, and Thomas Zimmer-
mann (Eds.). ACM, 701‚Äì712. https://doi.org/10.1145/3368089.3409763
[40] Kenneth L. McMillan. 2006. Lazy Abstraction with Interpolants. In Computer
Aided Verication, 18th International Conference, CAV 2006, Seattle, WA, USA,
August 17-20, 2006, Proceedings (Lecture Notes in Computer Science, Vol. 4144) ,
Thomas Ball and Robert B. Jones (Eds.). Springer, 123‚Äì136. https://doi.org/10.
1007/11817963_14
[41] Sergey Mechtaev, Jooyong Yi, and Abhik Roychoudhury. 2016. Angelix: Scalable
multiline program patch synthesis via symbolic analysis. In Proceedings of the
38th International Conference on Software Engineering (Austin, Texas) (ICSE ‚Äô16) .
ACM, New York, NY, USA, 691‚Äì701. https://doi.org/10.1145/2884781.2884807
[42] Aina Niemetz, Mathias Preiner, and Armin Biere. 2014. Boolector 2.0. J. Satisf.
Boolean Model. Comput. 9, 1 (2014), 53‚Äì58. https://doi.org/10.3233/sat190101
[43] Andres N√∂tzli, Andrew Reynolds, Haniel Barbosa, Aina Niemetz, Mathias Preiner,
Clark W. Barrett, and Cesare Tinelli. 2019. Syntax-Guided Rewrite Rule Enumera-
tion for SMT Solvers. In Theory and Applications of Satisability Testing - SAT 2019
- 22nd International Conference, SAT 2019, Lisbon, Portugal, July 9-12, 2019, Pro-
ceedings (Lecture Notes in Computer Science, Vol. 11628) , Mikol√°s Janota and In√™s
Lynce (Eds.). Springer, 279‚Äì297. https://doi.org/10.1007/978-3-030-24258-9_20
[44] Rohan Padhye, Caroline Lemieux, Koushik Sen, Mike Papadakis, and Yves Le
Traon. 2019. Semantic fuzzing with zest. In Proceedings of the 28th ACM SIGSOFT
International Symposium on Software Testing and Analysis, ISSTA 2019, Beijing,
China, July 15-19, 2019 , Dongmei Zhang and Anders M√∏ller (Eds.). ACM, 329‚Äì340.
https://doi.org/10.1145/3293882.3330576
[45] Stuart Pernsteiner, Calvin Loncaric, Emina Torlak, Zachary Tatlock, Xi Wang,
Michael D. Ernst, and Jonathan Jacky. 2016. Investigating Safety of a Radiotherapy
Machine Using System Models with Pluggable Checkers. In Computer Aided
Verication - 28th International Conference, CAV 2016, Toronto, ON, Canada, July
17-23, 2016, Proceedings, Part II (Lecture Notes in Computer Science, Vol. 9780) ,
Swarat Chaudhuri and Azadeh Farzan (Eds.). Springer, 23‚Äì41. https://doi.org/10.
1007/978-3-319-41540-6_2
[46] Van-Thuan Pham, Marcel B√∂hme, Andrew Edward Santosa, Alexandru Razvan
Caciulescu, and Abhik Roychoudhury. 2019. Smart greybox fuzzing. IEEE Trans-
actions on Software Engineering (2019), 1‚Äì17. https://doi.org/10.1109/TSE.2019.
2941681
[47] Manuel Rigger and Zhendong Su. 2020. Finding Bugs in Database Systems via
Query Partitioning. Proc. ACM Program. Lang. 4, OOPSLA, Article 211 (Nov.
2020), 30 pages. https://doi.org/10.1145/3428279
[48] Joseph Scott, Federico Mora, and Vijay Ganesh. 2020. BanditFuzz: A
Reinforcement-Learning Based Performance Fuzzer for SMT Solvers. In Software
Verication - 12th International Conference, VSTTE 2020, and 13th International
Workshop, NSV 2020, Los Angeles, CA, USA, July 20-21, 2020, Revised Selected
Papers (Lecture Notes in Computer Science, Vol. 12549) , Maria Christakis, Nadia
Polikarpova, Parasara Sridhar Duggirala, and Peter Schrammel (Eds.). Springer,
68‚Äì86. https://doi.org/10.1007/978-3-030-63618-0_5
[49] Konstantin Serebryany, Derek Bruening, Alexander Potapenko, and Dmitriy
Vyukov. 2012. AddressSanitizer: A Fast Address Sanity Checker. In 2012 USENIX
Annual Technical Conference, Boston, MA, USA, June 13-15, 2012 , Gernot Heiser
and Wilson C. Hsieh (Eds.). USENIX Association, 309‚Äì318. https://www.usenix.
org/conference/atc12/technical-sessions/presentation/serebryany[50] Armando Solar-Lezama and Rastislav Bodik. 2008. Program synthesis by sketching .
Citeseer.
[51] Chengnian Sun, Vu Le, and Zhendong Su. 2016. Finding compiler bugs via live
code mutation. In Proceedings of the 2016 ACM SIGPLAN International Conference
on Object-Oriented Programming, Systems, Languages, and Applications, OOPSLA
2016, part of SPLASH 2016, Amsterdam, The Netherlands, October 30 - November
4, 2016 , Eelco Visser and Yannis Smaragdakis (Eds.). ACM, 849‚Äì863. https:
//doi.org/10.1145/2983990.2984038
[52] G Team. 2014. Gcov-using the gnu compiler collection (gcc). Online, disponƒ±vel
em http://gcc. gnu. org/onlinedocs/gcc/Gcov. html-Ultimo acesso em 26, 02 (2014),
2015.
[53] Sandro Tolksdorf, Daniel Lehmann, and Michael Pradel. 2019. Interactive meta-
morphic testing of debuggers. In Proceedings of the 28th ACM SIGSOFT Interna-
tional Symposium on Software Testing and Analysis, ISSTA 2019, Beijing, China,
July 15-19, 2019 , Dongmei Zhang and Anders M√∏ller (Eds.). ACM, 273‚Äì283.
https://doi.org/10.1145/3293882.3330567
[54] Grigori S Tseitin. 1983. On the complexity of derivation in propositional calculus.
InAutomation of reasoning . Springer, 466‚Äì483. https://doi.org/10.1007/978-3-
642-81955-1_28
[55] Muhammad Usman, Wenxi Wang, and Sarfraz Khurshid. 2020. TestMC: Testing
Model Counters using Dierential and Metamorphic Testing. In 35th IEEE/ACM
International Conference on Automated Software Engineering, ASE 2020, Melbourne,
Australia, September 21-25, 2020 . IEEE, 709‚Äì721. https://doi.org/10.1145/3324884.
3416563
[56] Junjie Wang, Bihuan Chen, Lei Wei, and Yang Liu. 2019. Superion: grammar-aware
greybox fuzzing. In Proceedings of the 41st International Conference on Software
Engineering, ICSE 2019, Montreal, QC, Canada, May 25-31, 2019 , Joanne M. Atlee,
Tevk Bultan, and Jon Whittle (Eds.). IEEE / ACM, 724‚Äì735. https://doi.org/10.
1109/ICSE.2019.00081
[57] Elaine J Weyuker. 1982. On testing non-testable programs. Comput. J. 25, 4 (1982),
465‚Äì470. https://doi.org/10.1093/comjnl/25.4.465
[58] Virginie WIELS, Robert Delmas, David Doose, Pierre-Lo√Øc Garoche, J. Cazin,
and Guy Durrieu. 2012. Formal Verication of Critical Aerospace Software.
AerospaceLab 4 (May 2012), p. 1‚Äì8. https://hal.archives-ouvertes.fr/hal-01184099
[59] Dominik Winterer, Chengyu Zhang, and Zhendong Su. 2020. On the unusual
eectiveness of type-aware operator mutations for testing SMT solvers. Proc.
ACM Program. Lang. 4, OOPSLA (2020), 193:1‚Äì193:25. https://doi.org/10.1145/
3428261
[60] Dominik Winterer, Chengyu Zhang, and Zhendong Su. 2020. Validating SMT
solvers via semantic fusion. In Proceedings of the 41st ACM SIGPLAN International
Conference on Programming Language Design and Implementation, PLDI 2020,
London, UK, June 15-20, 2020 , Alastair F. Donaldson and Emina Torlak (Eds.).
ACM, 718‚Äì730. https://doi.org/10.1145/3385412.3385985
[61] Peisen Yao, Heqing Huang, Wensheng Tang, Qingkai Shi, Rongxin Wu, and
Charles Zhang. 2021. Fuzzing SMT Solvers via Two-Dimensional Input Space
Exploration. In ISSTA‚Äô21: 30th ACM SIGSOFT International Symposium on Software
Testing and Analysis, Virtual Event, USA .
[62] Cunxi Yu, Maciej J. Ciesielski, and Alan Mishchenko. 2018. Fast Algebraic Rewrit-
ing Based on And-Inverter Graphs. IEEE Trans. Comput. Aided Des. Integr. Circuits
Syst. 37, 9 (2018), 1907‚Äì1911. https://doi.org/10.1109/TCAD.2017.2772854
[63] Andreas Zeller. 1999. Yesterday, My Program Worked. Today, It Does Not. Why?
1687 (1999), 253‚Äì267. https://doi.org/10.1007/3-540-48166-4_16
1153