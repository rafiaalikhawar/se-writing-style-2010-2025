Pending Constraints in Symbolic Execution for
Better Exploration and Seeding
Timotej Kapus
Imperial College London
United Kingdom
t.kapus@imperial.ac.ukFrank Busse
Imperial College London
United Kingdom
f.busse@imperial.ac.ukCristian Cadar
Imperial College London
United Kingdom
c.cadar@imperial.ac.uk
ABSTRACT
Symbolic execution is a well established technique for software
testing and analysis. However, scalability continues to be a chal-
lenge,bothintermsofconstraintsolvingcostandpathexplosion.
In this work, we present a novel approach for symbolic execution,
whichcanenhanceitsscalabilitybyaggressivelyprioritisingexe-
cutionpathsthatarealreadyknowntobefeasible,anddeferring
all other paths. We evaluate our technique on nine applications, in-
cludingSQLite3,makeandtcpdumpandshowitcanachievehigher
coverage for both seeded and non-seeded exploration.
CCS CONCEPTS
•Software and its engineering →Software testing and de-
bugging.
KEYWORDS
Symbolic execution, KLEE
ACM Reference Format:
Timotej Kapus, Frank Busse, and Cristian Cadar. 2020. Pending Constraints
inSymbolicExecutionforBetterExplorationandSeeding.In 35thIEEE/ACM
International Conference on Automated Software Engineering (ASE ’20), Sep-
tember 21–25, 2020, Virtual Event, Australia. ACM, New York, NY, USA,
12 pages. https://doi.org/10.1145/3324884.3416589
1 INTRODUCTION
Symbolic execution is a dynamic program analysis technique that
has established itself as an effective approach for many softwareengineering problems such as test case generation [
4,12], bug
finding[6,13],equivalencechecking[ 10,11],vulnerabilityanaly-
sis [8, 27] and debugging [14, 20].
Even with well-engineered tools like KLEE [ 4], symbolic exe-
cution still faces important scalability challenges. These fall intotwo broad categories: constraint solving and path explosion. Assymbolic execution proceeds, the complexity of constraints and
the number of paths typically increase, often making it difficult to
make meaningful progress.
Inthiswork,weproposeanovelmechanismthataggressively
explorespathswhosefeasibilityisknownviacachingorseeding.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
onthe firstpage.Copyrights forcomponentsof thisworkowned byothersthan the
author(s)mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,or
republish,topostonserversortoredistributetolists,requirespriorspecificpermission
and/or a fee. Request permissions from permissions@acm.org.
ASE ’20, September 21–25, 2020, Virtual Event, Australia
© 2020 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ACM ISBN 978-1-4503-6768-4/20/09...$15.00
https://doi.org/10.1145/3324884.3416589Our approach tackles both scalability challenges of symbolic ex-
ecution. On the one hand, it enables more efficient use of solvedconstraints, thus reducing the burden on the solver. And on the
other hand, it provides a meta-search heuristic that gives a way to
guide the exploration towards interesting parts of the program.
Before presenting our idea, we briefly summarise symbolic exe-
cution. We focus here on the EGT-style of dynamic symbolic execu-
tion [5], embodied in tools such as KLEE [ 4], which unlike concolic
execution tools[12,24],storepartiallyexploredpathsinmemory.
Symbolicexecutionworksbyrunningtheprogramonsomesym-
bolic inputs,which means theycan initiallytake any value, as theyareunconstrained.Duringexecution,ifabranchconditiondepends
on a symbolic value, symbolic execution queries an SMT solver for
the feasibility of each of the two branches (under the current path
conditionwhichisinitiallyempty).Ifboththe thenandtheelse
branchesarefeasible,itforkstheexecutionexploringbothpaths
andaddingtherespectivebranchconditionstoeachpathcondition
(PC).Aftereveryfork,symbolicexecutionusesasearchheuristicto
decidewhatpathtoexplorenext.Eachpathexploredinsymbolic
execution is encoded by a statewhich keeps all the information
necessarytoresumeexecutionoftheassociatedpath(PC,program
counter, stack contents, etc. ).
Thecoreofouridearevolvesaround inverting theforkingpro-
cess. Instead of doing an (expensive) feasibility check first and
then forking the execution, we fork the execution first. The branch
condition is then added as a pending constraint, which means its
feasibility has not been checked yet. Werefer tostates (or paths)
with pending path constraints as pending states.
The responsibility for feasibility checking of pending path con-
straints is passed to the search heuristic. This gives the searchheuristic the capability to decide when and for which states it
wantstopaythepriceofconstraintsolving.Forexample,itcould
solve pending states immediately, thus restoring the original algo-
rithm, or could take into account the (estimated) cost of constraint
solving in its decisions.
In our approach, we take advantage of an important characteris-
tic of symbolic execution runs: the feasibility of some paths/states
canbequicklydeterminedwithoutusingaconstraintsolver.There
are two common cases. First, modern symbolic execution systems
like KLEE make intensive use of caching and many queries canbe solved without involving the constraints solver [
1,4,26]. Sec-
ond,symbolicexecutionisoftenbootstrappedwithasetofseeds
from which to start exploration: these can come from regression
test suites [ 18,19] or greybox fuzzers in hybrid greybox/whitebox
fuzzing systems [ 9,21,25]. By aggressively following paths for
whichfeasibilitycanbequicklydeterminedwithoutusingacon-
straint solver, our approach can minimise the constraint solving
1152020 35th IEEE/ACM International Conference on Automated Software Engineering (ASE)
Algorithm 1 Standard symbolic execution.
1:Setstates
2:
3:function Fork(State s, SymExpr condition )
4:ifIsSat(s.pc∧condition )∧IsSat(s.pc∧¬condition )then
5: falseState←s
6: falseState .pc←s.pc∧¬condition
7: s.pc←s.pc∧condition
8: SearcherAdd( s,falseState )
9:end if
10:end function
11:12:
function SearcherAdd(State s1, States2)
13:states←states∪{s1,s2}
14:end function
15:16:
function SearcherSelect()
17:returnSearchHeuristic( states)
18:end function
costs as well as provide an effective exploration of the program
search space.
Therestofthepaperisorganisedasfollows.In§2wepresent
in detail the design of our technique. Then in §3 we give further
implementation-specific details in the context of building our tech-
nique in KLEE. We finally evaluate our approach in §4, discuss
related work in §5 and conclude in §6.
2 ALGORITHM
Algorithm 1 presents, in simplified form, the forking and search
heuristics components of the standard symbolic execution algo-
rithm. The symbolic executor is exploring program paths encoded
as a set of states(line 1). As discussed before, a state keeps track of
alltheinformationnecessarytoresumeexecutionoftheassociated
path (program counter, stack contents, etc.) and particularly its
path condition pc. When a symbolic state sencounters a symbolic
branchcondition, the Fork function is called (line 3).
Forkfirstchecksifthe condition canbeboth trueandfalseunder
thecurrentpathcondition(line4).Ifso,thestateisduplicatedintoa
falseState (line5),whichwillbethestaterepresentingtheexecution
of the false branch. The path conditions of the two states are then
updatedaccordingly(lines6and7)andthenewstateisaddedtothesetofstatesofthesearchheuristicbycallingSearcherAdd(line8).
If thecondition cannot be both true and false, the path condition is
notupdatedand scontinuestoexecutetheonlyfeasiblesideofthe
branch (the updates to the program counter are omitted for ease of
exposition).
After each instruction, the symbolic executor calls SearcherSe-
lect(lines16–18)toselectthestatetobeexecutednext.Inthecase
of standard symbolic execution, SearcherSelect simply forwards
calls to the SearchHeuristic. For instance, the search heuristic
mightchoosestatesaccordingtodepthorbreadth-firststrategies
or randomly pick a state. Below, we introduce the three search
heuristics which we explore in this project:
Depth-first search is a standard graph traversal algorithm that
explores states as deep as possible before backtracking.Algorithm 2 Symbolic execution with pending constraints.
1:SetfeasibleStates ,pendinдStates
2:
3:function Fork(State s, SymExpr condition )
4:feasibleStates←feasibleStates\{s}
5:s.pendinдCondition ←condition
6:falseState←s
7:falseState .pendinдCondition ←¬condition
8:SearcherAdd( s,falseState )
9:end function
10:11:
function SearcherAdd(State s1, States2)
12:foreachStates∈{s1,s2}do
13: ifFastIsSat( s,s.pc∧s.pendinдCondition )then
14: s.pc←s.pc∧s.pendinдCondition
15: s.pendinдCondition ←∅
16: feasibleStates←feasibleStates∪{s}
17: else
18: pendinдStates←pendinдStates∪{s}
19: end if
20:end foreach
21:end function
22:23:
function SearcherSelect()
24:whilefeasibleStates =∅do
25: s←SearchHeuristic( pendinдStates )
26: ifIsSat(s.pc∧s.pendinдCondition )then
27: s.pc←s.pc∧s.pendinдCondition
28: s.pendinдCondition ←∅
29: feasibleStates←feasibleStates∪{s}
30: end if
31: pendinдStates←pendinдStates\{s}
32:end while
33:returnSearchHeuristic( feasibleStates )
34:end function
Random path search, introduced in the original KLEE paper [ 4],
worksby randomlyselecting apath throughtheexecution treeof
exploredstates.Thealgorithmstartsattherootofthetreeandwith
50%probabilityfollowstheleft-handsubtreeand50%probability
theright-handone.Theprocessrepeatsuntilaleafstateisreached,
which is selected for further exploration. By design, this search
heuristic favours states closer to the root of the execution tree.
Depth-biased search is a form of non-uniform random search
provided by KLEE. It works by randomly selecting states weighted
bytheirdepth—thehigherthedepthofastate,themorelikelyforit
tobeselected.Bydesign,thissearchheuristicfavoursstatesdeeper
in the execution tree.
2.1 Pending Constraints Algorithm
Note that the calls to IsSat in standard symbolic execution are
potentiallyvery expensiveandthusare theoptimisationtargetof
our proposed approach.
Algorithm 2 shows the same three functions in the pending
constraintsversionofsymbolicexecution.Inthisversion,wemain-
taintwodisjointsetsofstates: feasibleStates,whichstoresregular
states which we know are feasible; and pendingStates, which stores
pending states for which feasibility is still unknown (line 1).
116Algorithm 3 Fast satisfiability checking.
1:function FastIsSat(State s, SymExpr condition )
2:assiдnments←GetAssignmentsForState( s)
3:foreachAssignment a∈assiдnments do
4: ifSubstitute( a,condition )=truethen
5: returntrue
6: end if
7:end foreach
8:returnfalse
9:end function
In our version of Fork, the IsSat feasibility checks are skipped
and executionis forked unconditionally. First,we remove thecur-
rent state sfrom the list of feasibleStates (line 4), and assign the
condition to a special pending condition field associated with s
(line5).Second,weduplicate sintoanewstate falseState (line6)
and assign the negation of condition to its pending condition field
(line 7). When a state becomes pending, as sandfalseState here, it
means that it should not continue execution until its pending con-
ditionischeckedforfeasibility.Wecalltheprocessofcheckingthe
pendingconditionandaddingittothepathconditionas reviving
the state.
Finally, we call SearcherAdd (line 8) to let the searcher decide
whatto dowith thenewly createdpending states.For eachof the
twostates,SearcherAddcheckswhetherthependingcondition
is feasible using a fast satisfiability checker (line 13). If so, the
pending condition is added to the path condition (line 14), thependingCondition field is reset (line 15) and the state is added to
the set of feasibleStates (line 16). If the fast satisfiability check is
unsuccessful, the state is added to the set of pendingStates (line 18).
The fast satisfiability solver is discussed in §2.2.
The SearcherSelect function operates as in standard symbolic
execution as long as there are feasible states available (line 33).
However,whenallthefeasiblestateshavebeenexhausted,itkeeps
picking a pending state (line 25) until it finds one that can be re-
vivedsuccessfully.Thisisdonebyaskingthesolverwhetherthe
pendingconditionisfeasible(line26)andifso,byaddingthepend-
ing condition to the state’s path condition (line 27), clearing the
pendingCondition field(line28),andaddingthestatetothesetof
feasibleStates (line 29).
2.2 Fast Satisfiability Checking
Asdiscussedintheintroduction,thefastsatisfiabilitycheckerrelies
onthefactthatweoftenhaveexistingassignments(solutions)to
symbolic constraints. There are two common scenarios that occur
inpractice:first,modernsymbolicexecutionenginesuseasmart
form of caching to speed up constraint solving (§2.2.1) and second,
symbolic exploration often starts with a set of seeds (§2.2.2).
Algorithm 3 shows the fast satisfiability checking algorithm.
Moreformally,an assignment isamappingfromsymbolicvariables
toconcretevalues,e.g. {x←2,y←3}.TheSubstitutefunction
takes a symbolic condition and an assignment and evaluates theconditionundertheassignment(line4).Thatis,itsubstitutesallthe symbolic variables in the condition with the values specifiedin the assignment. If all the symbolic variables in the expressionare mapped by the assignment, Substitute will return a concrete
value (either trueorfalse). Otherwise it will return false.
FastIsSatfirstgetsalltheassignmentsassociatedwiththegiven
stateusingtheGetAssignmentsForStatefunction(line2);wewilldiscusshowthisfunctionworksbelow.Theconditionisthenevalu-
ated on every assignment returned by GetAssignmentsForState
and if the evaluation results in true, FastIsSat returns successfully
(line5).Ifnoneofthereturnedassignmentssatisfythecondition,
then FastIsSat returns unsuccessfully (line 8).
2.2.1 Caching. When issuing satisfiability queries to the solver,
modern symbolic execution engines typically also ask for a sat-isfying assignment when the query is satisfiable. This is becausecaching these assignments can be highly effective [
1,4,26]. In
thiswork,wesimilarlyusecachedassignmentstoimplementour
fast satisfiability checks. Substituting all assignments that were
returned bythe core solver at anyprevious point inthe execution
can be expensive and here we want to ensure the check is fast. So
instead,weusethesamemechanismusedbyassignmentcaching
in KLEE, and have GetAssignmentsForState (line 2) return only
theassignmentsassociatedwithasubsetofthepathconditionof
states.
The idea behind the pending constraints approach is to use
existing assignments as long as it is possible, and only ask forexpensive new solutions when absolutely necessary. As a result,
thesearchgoesdeepintotheexecutiontree,becauseitexploresthe
solutionsithastocompletion.Therefore,combiningthisstrategy
with a search heuristic that goes wide when picking a pending
state can be really effective. Note that the search heuristics thatoften perform best, such as random path search, tend to behavelike this [
4]. Another way of understanding our approach is as a
meta-searcherthatenhancesagivensearchheuristic,enablingittoexplore deeper parts of the program. Intuitively, this is achieved by
picking a path and sticking to it, while normally the same searcher
wouldkeepchangingbetweenpaths.Importantly,thepathitsticks
to issues no additional queries to the SMT solver and therefore
completes quickly.
Tomake things more concrete, consider the program in Figure 1
withDFS_FRIENDLY undefined. It has two symbolic variables: a
booleanisSpace and a string str. It first branches on isSpace
on line 14 and writes space as the first character of stron the
thenbranch or a zero on the elsebranch. The two loops between
lines 21–23 then introduce a large number of symbolic branches.
Aftertheseloops,itcomputesthefifteenthFibonaccinumberusing
an inefficient recursion. This represents some large concrete work-
load.Finally,weassert isSpaceisfalse.Notethatreachingthis
assertionfailureonlydependsonthefirstbranchandiscompletely
independent of the large number of paths spawned in the loops.
Vanilla KLEE executes around 4 million instructions, taking
around 10 seconds to reach the assertion failure using the ran-dom path search strategy. By contrast, the pending constraints
approach executes only around 67k instructions, taking less than a
second.ThereasonisthatvanillaKLEEneedstocomputealarge
numberofsolutionstothesymbolicbranchesintheloops,which
arenotneededtofindtheassertionfailure.Whereasthepending
constraints approach only needs one solver solution for str. Be-
cause random path search is the underlying search strategy, it is
1171unsigned fib(unsigned n) {
2 if(n == 0) return0;
3 if(n == 1) return1;
4 returnfib(n - 1) + fib(n - 2);
5}
6
7intmain() {
8 boolisSpace;
9klee_make_symbolic(&isSpace, sizeof(isSpace), "isSpace");
10 charstr[6];
11klee_make_symbolic(str, sizeof(str), "str");
1213#ifndef DFS_FRIENDLY
14 if(isSpace) str[0] = '␣';
15 elsestr[0] = '\0';
16#else
17 if(isSpace == 0) str[0] = '\0';
18 elsestr[0] = '␣';
19#endif
2021 for(inti=1 ;i<6 ;i++)
22 for(charj = 0; j < str[i]; j++)
23 str[i-1]++;
2425fib(15);
26assert(!isSpace);
27 return0;
28}
Figure 1: An example program where pending constraints
find the failing assertion faster.
also more likely to pick the pending states produced by the branch
on line 14 as it is closer to the root of the process tree.
Note that DFS reaches our one-hour timeout in this case. How-
ever, it performs similarly to the pending states if the order of
branches on line 14 is swapped (by defining DFS_FRIENDLY ). With
DFS_FRIENDLY defined, both pending states and upstream KLEE
find the assertion in about 33k instructions. This shows that while
DFS can be as efficient, it is highly dependent on the order of
branches, unlike the pending constraints approach.
2.2.2 Seeding. A seed is a concrete input to a program which is
giventosymbolicexecutiontobootstrapexploration.Aseedcan
make symbolic execution of the program easier for two reasons.First, it is used to guide symbolic execution toward parts of theprogram that are executed by real inputs. Second, it provides a
solutionforcomplexpathconstraints,thereforeremovingtheneed
for expensive constraint solving. Seeding has been shown to be
effectivewhensymbolicexecutioniscombinedwithregressiontest
suites [18,19,22] as well as when it is integrated with a greybox
fuzzer [9, 21, 25].
Our pending constraints approach can be easily extended to
supportseeding.InFastIsSat,wemodifytheGetAssignments-
ForState function to return the seeds as assignments (line 2). As a
result, onlythe states that satisfythe seeds arefollowed first, and
there are no calls to the SMT solver until all the paths followed by
the seeds are explored. In this use case, pending states represent
thepossibledivergencesfromtheseeds,fromwherewecanpick
up exploration once the seeding is completed.When seeds areavailable, random path search is unlikely to be
themosteffectivestrategy.Oncethepathsfollowedbytheseeds
arecompleted,randompathsearchwouldpickastateveryclose
to the start of the program, as the probability of picking a state
halvesateverysymbolicbranch.Thismeansthattheexploration
will behave similarly as to when no seeds are available.
Ontheotherhand,depth-biasedsearchwouldmostlikelypicka
state toward the end of the path executed by the seeds, meaning it
willstarttoexplorepathsthatareveryhardtoreachfromthestart
oftheapplication.Inotherwords,itbenefitsfromtheseedandcan
start exploring code out of reach of normal symbolic execution.
However, there are two limitations to this search heuristic. First,
bydesign,thisstrategymissescodethatiseasytoreachfromthe
start of the program. Therefore, it is best combined with a more
wide-reachingstrategysuchasrandompathsearch.Second,this
heuristic is more likely to select pending states that are infeasible,
asthepathconditionsforthosestateshavemoreconstraintsand
thus the pending condition is more likely to be infeasible in that
state.
3 IMPLEMENTATION
We implemented our approach in KLEE [ 4], a state-of-the-art sym-
bolic execution system that operates on LLVM bitcode [ 16]. Our
prototype is based on KLEE commit 0fd707band is configured to
use LLVM 7 and STP 2.3.3. We discuss below some of the most
important implementation aspects.
Wemakeourprototypeandassociatedartefactavailableathttps:
//srg.doc.ic.ac.uk/projects/pending-constraints and https://doi.org/
10.6084/m9.figshare.12865973.
3.1 Fast Satisfiability Solver
KLEE’sconstraintsolvingchainconsistsofaseriesofcachesand
other partial solvers, finally delegating the query to an externalSMT solver. For our fast solver we simply used this solver chain
without the final, potentially expensive, call to STP.
Seeding is easily implemented with KLEE’s counterexample (as-
signment) cache, as we simply add the seed to the cache as anadditional assignment at the start of execution. Note that this isdifferent from how vanilla KLEE implements seeding. However,tomakethecomparisonbetweenvanillaKLEEandpendingcon-
straints fair, we also added the seed to the cache in vanilla KLEE.
3.2 Error Checks
During execution, KLEE performs various checks to find errors.Examples include checks for division by zero and out-of-boundsmemory accesses. One option would be to treat these checks as
we treat regular branches and create pending states. However, that
would mean that errors wouldn’t be caught as soon as that code is
covered,asinvanillaKLEE(andinfacttheymightneverbecaught
if those pending states are killed later on due to memory pressure).
Therefore, we treat these checks specially by always performing
them instead of creating pending states.
However,ifhighercoverageismoreimportantthanbugfinding,
deferringthesecheckstopendingstatesmightmakemoresense.
Therefore, we also run our benchmarks without these checks in a
118version that we call pending constraints with relaxed checks.W e
explore this version in §4.5 and observe significant coverage gains.
3.3 Branching without a Branch Instruction
In KLEE there are several cases where forking happens without
abranchinstruction.Forinstance,inthedefaultconfiguration,a
switchinstructionishandledasabranchwithmultipletargets.This
fitslessneatlyinourmodelthereforewesimplyconfigureKLEEto
lower all switch instructions to a series of if-elsestatements.
Whenasymbolicpointerisencountered,KLEEscanstheaddress
space to find all memory objects to which it can point. If multiple
objects are found, it forks execution for each object, adding appro-
priate constraints [ 4,15]. In the default version of our approach,
we don’t create pending states in this case; instead we eagerly fork
as necessary, as in vanilla KLEE. However, with relaxed checks, for
eachmemoryobjecttowhichthepointercanrefer,thestategets
forkedintotwopendingstates:onein-boundsoftheobjectandthe
otheroneout-of-bounds.Thissecondpendingstateencompasses
all other resolutions of the symbolic pointer.
3.4 Releasing Memory Pressure
KLEEoftenhitsthememorylimitforlargeprogramsduetothevast
sizeofthesearchspaceandgenerallybroadsearchheuristics[ 3].
When exceeding the memory limit, KLEE terminates a number of
randomly-chosenstatestogetbackbelowthememorylimit.We
could follow the same approach with pending constraints, but this
could delete both feasible and infeasible pending states. Feasible
pending states potentially represent large parts of the search space
and we should avoid their termination. By reviving pending states,
we can select and terminate infeasible pending states. But this
comesataprice,asrevivingstatesrequiresexpensiveconstraint
solving. In our implementation, we decided to stop reviving states
when the remaining number of pending states equals the number
of states we still need to terminate to fall below the memory limit.
Atthatpoint,westarttorandomlychoosestatestoterminateasin
vanilla KLEE.
4 EVALUATION
Ourevaluationisstructuredasfollows.Wepresentourbenchmarksin§4.1andexplainwhyweevaluatedthemoninternalcoveragein
§4.2.Weevaluatependingconstraintsontheirabilitytoenhance
symbolic execution in a non-seeding context in §4.3 and then in a
seeding context in §4.4. We also evaluate the version with relaxed
checks in §4.5. Finally, we discuss our approach in further detail in
§4.6, via a case study on SQLite3.
We run all experiments in a Docker container on a cluster of
18 identical machines with Intel i7-4790 @ 3.60GHz CPU, 16GiB
of RAM and Ubuntu 18.04 as operating system. We repeat our
experimentsthreetimesandwherepossibleplottheaverageand
the minimum and maximum as an interval. In cases where wecombineexperiments,there arenointervalsshownaswemerge
all the repetitions.4.1 Benchmarks
Our aim is to demonstrate the capability of pending constraints to
increasetheexplorationpotentialofsymbolicexecution.Therefore,
we chose benchmarks that are challenging for symbolic execution.
SQLite31isoneofthemostpopularSQLdatabasesystems.We
used version 3.30.1 via its default shell interface with symbolicinput and without custom drivers. However, we adjusted somecompile-time flags, such as simplifying the allocation model, to
make it easier for symbolic execution.
magick2is a command-line utility for performing various oper-
ationsonimages.Weusedversion7.0.8-68intwoconfigurations,
converting (symbolic) jpeg images to png images and back, which
makes use of libjpeg3andlibpng4.
tcpdump5is used for capturing and printing network packets.
Weusedversion4.10.0toprintinformationfromasymboliccapture
file.
GNU m46isamacroprocessor.Weusedversion1.4.18toprocess
a symbolic file.
GNU make7is a widely-used build system. We used version 4.2
on a symbolic makefile.
oggenc8is a tool from the Ogg Vorbis audio compression for-
matreferenceimplementation.Weusedversion1.4.0toconverta
symbolic .wavfile to the .oggformat.
GNU bc9isanarbitraryprecisioncalculator.Weusedversion1.07
on symbolic standard input.
GNU datamash10isatoolforperformingcommand-linecalcula-
tionsontabulardata.Weusedversion1.5bothwithsymbolicinput
and symbolic arguments.
Table1givesamoredetailedoverviewofthebenchmarks,show-
ing their size, arguments we used and a brief description of the
seeds.TheprogramsizeismeasuredintermsofLLVMinstructions
asreportedbyKLEE.Thethirdcolumnshowstheargumentswe
usedtorunthebenchmarks.Theargumentsprefixedwith -symare
replacedwithsymbolicdata.Forexample, -sym-arg3 isreplaced
with a three-character symbolic argument, -sym-stdin 20 is a 20-
byte symbolic standard input stream, and -sym-file100 creates a
file named Awith 100 bytes of symbolic content.
ThelasttwocolumnsofTable1giveanoverviewoftheseeds
we used. Where possible, we give the exact data used as in the
case ofbc. However, in the case of magickand similar utilities that
wouldnotbetooinformative,sowegiveinsteadabriefdescription
of the seed. We took the smallest valid files from https://github.com/mathiasbynens/small. Some seeds were padded with zeroes
as necessary to make the seed size match the number of symbolic
bytes as specified by the arguments.
Figure 2 shows the percentage of time spent in the solver by
vanillaKLEEonourbenchmarks,on2-hourruns,usingdifferent
1https://www.sqlite.org/
2https://imagemagick.org/
3http://libjpeg.sourceforge.net/
4http://www.libpng.org/
5https://www.tcpdump.org/
6https://www.gnu.org/software/m4/
7https://www.gnu.org/software/make/
8https://xiph.org/vorbis/
9https://www.gnu.org/software/bc/
10https://www.gnu.org/software/datamash/
119Table 1: Overview of (symbolic) arguments and used seeds for our benchmarks. The benchmark size is given as number of
LLVM instructions in the bitcode file.
Benchmark Size Arguments Seed set 1 ( s1) Seedset2( s2)
bc 34,311-sym-stdin 20 435/4+6-3421 x=6 sqrt(2*x+5 )
datamash 63,405-sym-arg 3 -sym-arg 1 -sym-arg 4 -sym-arg 1 -sym-stdin 20 sum 1 mean 3 on a3×3matrix md5 1 sha1 2 on2×3matrix
m4 93,169-G -H37 -sym-arg 2 -sym-arg 5 -sym-stdin 20 -G -DM=6 withM is M also M is B -G -DM=6 withifdef(‘M’, ha, nah)
magickjpg1,368,912 jpeg:fd:0 png:fd:1 -sym-stdin 285 smallest valid JPEG file 1×1JPEG image created with GIMP
magickpng1,368,912 png:fd:0 jpg:fd:1 -sym-stdin 70 smallest valid PNG file 1×1PNG image created with GIMP
make 80,790-n -f A -sym-arg 2 -sym-arg 5 -sym-file 20 -n -Bfds with$(info $$helo ther) -n -Bfds witha:=4 $(info $a)
oggenc 87,142A -sym-file 100 smallest valid WAV file sine wave WAV file created by SciPy
SQLite3 283,020 -sym-stdin 20 SELECT * FROM t; CREATE TABLE t (i);
tcpdump 353,196 -r A -K -n -sym-file 100 100 byte captured packet another 100 byte captured packet
0%20%40%60%80%100%
bc
datamashm4
magickjpg
magickpngmakeoggenc sqlite3tcpdumpRelative Solver Time (%)RP Depth DFS
Figure 2: Relative time spent in the SMT solver (STP) by
vanilla KLEE in our non-seeded experiments with the ran-
dom path (RP), depth-biased (Depth) and DFS strategies.
searchstrategies.Ascanbeseen,mostofourbenchmarksaresolver-
bound,meaningtheyspentaveryhighproportionoftimeinthe
solver,forexample bcandmake.datamash istheonlybenchmark
thatisnotsolver-boundinanysearchstrategyconsidered,meaning
KLEE spends very little time constraint solving. SQLite3is only
solver-bound with the DFS search strategy.
4.2 Internal Coverage vs. GCovCoverage
WhenmeasuringthecoverageachievedbyvanillaKLEEandour
pendingconstraintsextension,wecanuseeithertheinternalcov-
erage reported by KLEE or the coverage reported by GCov11when
running the test inputs generated by KLEE.
The internal coverage reported by KLEE includes the lines of
codethatKLEEexecutedsymbolically,attheLLVMbitcodelevel.
Bycontrast,the GCovcoverageisthecoveragereportedby GCov
at the source code level, when rerunning the test inputs generated
byKLEEonaversionoftheprogramcompiledwith GCovinstru-
mentation.Bothapproacheshaveadvantagesanddisadvantages.
11https://gcc.gnu.org/onlinedocs/gcc/Gcov.html 0 10000 20000 30000 40000 50000 60000 70000 80000 90000
 0  500  1000  1500  2000  2500  3000 0 500 1000 1500 2000 2500 3000 3500 4000 4500Covered LLVM InstructionsCovered Source Lines
Unique Faults FoundInternal coverage
GCov coverage
bcoggencdatamashm4
tcpdumpmake
sqlite3magick jpgmagick png
bcoggencdatamashm4tcpdump
makesqlite3magick jpgmagick png
Figure 3: Dual-axis scatter plot of internal coverage (left y-
axis)and GCovcoverage(righty-axis)againstthenumberof
injected faults found.
On the one hand, GCovcoverage has the advantage of being dis-
connected from KLEE and LLVM; often developers just want a tool
like KLEE to generate a high-coverage test suite and assess this
coverageindependently,atthesourcecodelevel.Ontheotherhand,
GCovcoverage includes parts of the program that KLEE did not
executesymbolically;thesepartsofcodewerenoterror-checked
by KLEE, and thus bugs could be missed. It is important to note
herethatwhenKLEEperformsanerrorcheck,itfindsabugifthere
areanyvaluesthatcantriggeritonthatpath.Bycontrast,atest
case that covers the buggy path might not necessarily reveal the
bug.Therefore,ifKLEEisusedprimarilytorevealbugs,internal
coverage is more appropriate.
To illustrate this issue, we injected a division-by-zero error in
everybasicblockofsomeofourbenchmarks.Thesedivision-by-
zero errors are triggered by a different value in each basic block.
We then run vanilla KLEE for two hours on these fault-injected
programs and measure both internal and GCovcoverage.
120 0 10 20 30 40 50 60 70
bc
datamashm4
magickjpg
magickpngmakeoggenc sqlite3tcpdumpCovered Instructions × 1000Vanilla
Pending
Combined
(a) Random Path 0 10 20 30 40 50 60 70
bc
datamashm4
magickjpg
magickpngmakeoggenc sqlite3tcpdumpCovered Instructions × 1000Vanilla
Pending
Combined
(b) Depth-Biased 0 10 20 30 40 50 60 70
bc
datamashm4
magickjpg
magickpngmakeoggenc sqlite3tcpdumpCovered Instructions × 1000Vanilla
Pending
Combined
(c) DFS
Figure 4: Instructions covered by vanilla KLEE and pending constraints alongside their combination in 2h non-seeded runs.
Figure 3 shows a dual-axis scatter plot of both internal coverage
on the left y-axis and GCovcoverage on the right y-axis against
the number of unique injected faults found.
As can be seen, internal coverage seems to highly correlate
withuniquefaultsfound,whereas GCovcoverageshowsnosuch
correlation. We discuss this in more detail in a blog post [7].
Inourwork,weobservedthatpendingconstraintsdonotneces-
sarilyimprove GCovcoverage,butsignificantlyimproveinternal
coverage.Therefore,whileacceptingtheformer,weshowinour
experiments that it can improve the latter, and thus report internal
coverage in our experiments.
4.3 Non-seeded Experiments
To evaluate pending constraints in a setting without seeds, we ran
eachofourbenchmarksfor2hourswiththerandompath,DFSand
depth-biasedstrategies.TheresultsareshowninFigure4.Forsomebenchmarks,suchas bcandmake,pendingconstraintsconsistently
covermoreinstructionsforallsearchstrategies.Forothers,such
asm4andtcpdump,therelativeperformanceisdependentonthe
search strategy.
IfwelookatthecombinedcoverageofvanillaKLEEandpend-
ingconstraints, weseethatthere issomecomplementarity tothe
approaches.For instance,whilevanillaKLEE obtainsbettercover-
ageform4withthedepth-biasedsearch,thependingconstraints
reachcodethatisnotcoveredbyvanillaKLEE.Overall,pending
constraints reached 35%, 24% and 34% more instructions across ourbenchmarkswithrandompath,DFSanddepth-biasedsearchrespec-tively.Theseresultsshowthatpendingconstraintscansignificantly
increase the power of symbolic execution on some benchmarks by
themselvesand/orcoverdifferentpartsofthecodewhencompared
to vanilla KLEE. Therefore they seem to be an effective tool for
non-seeded exploration in symbolic execution.
Comparing the search strategies for pending constraints, we
observe that for these experiments DFS performs best overall, cov-
ering 11% more instructions than random path, which in turns
covers 14% more instructions than depth-biased search.
One advantage of the pending constraints approach is that it
usuallyspendslesstimesolvingqueriesthatturnouttobeinfeasible.
Figure 5 shows the time spent constraint solving queries that turn0%10%20%30%40%50%60%70%80%90%
bc
datamashm4
magickjpg
magickpngmakeoggenc sqlite3tcpdumpRelative Infeasible Query Solving TimeVanilla
Pending
Figure5:Relativetimespentsolvingqueriesthatwereinfea-sible, averaged across all three search strategies.
out to be infeasible relative to total constraint solving time. Weaveraged across all search strategies for brevity and clarity. For
mostbenchmarks,pendingconstraintsspendsignificantlylesstimeconstraint solving queries that are infeasible. The only exception isSQLite3, where the absolute time spent solving infeasible queries is
stilllowerforpendingconstraintsacrossallthreesearchstrategies.
4.4 Seeded Experiments
To evaluate our approach in the context of seeding, we ran both
vanillaKLEEandpendingconstraintsfor2hourswitheachseed
fromTable1.Bothversionsaregiventheseeds—vanillaKLEEas
assignment in the (counter-example) cache and additionally as
concrete input.
Figure6showsthecoverageachievedbyvanillaKLEEandpend-
ingconstraints,foreachsearchstrategy.Coverageresultsforthe
two seeds are merged in each configuration.
121 0 5 10 15 20 25 30 35 40 45 50
bc
datamashm4
magickjpg
magickpngmakeoggenc sqlite3tcpdumpCovered Instructions × 1000Vanilla
Pending
Combined
(a) Random Path 0 5 10 15 20 25 30 35 40 45 50
bc
datamashm4
magickjpg
magickpngmakeoggenc sqlite3tcpdumpCovered Instructions × 1000Vanilla
Pending
Combined
(b) Depth-Biased 0 5 10 15 20 25 30 35 40 45 50
bc
datamashm4
magickjpg
magickpngmakeoggenc sqlite3tcpdumpCovered Instructions × 1000Vanilla
Pending
Combined
(c) DFS
Figure 6: Covered instructions by vanilla KLEE and pending constraints alongside their combination in seeded runs on our
benchmarks.Eachseedsetisrunfor2hoursineachconfigurationandthecoverageresultsforthetwoseedsarethenmerged.
For some benchmarks, such as magickpng,SQLite3andtcpdump,
pendingconstraintssignificantlyoutperformvanillaKLEEforall
search strategies. For others, such as datamash andmake, there
does not seem to be a large difference. Finally, for m4, pending
constraintsperformslightlyworsethanvanillaKLEE.Thisisdue
to dereferences of symbolic pointers being very common in m4,
which do not benefit from pending constraints.
From the combined coverage bars, we can observe there is very
littlecomplementaritybetweenthetwoapproaches,withtheex-ception of tcpdump under DFS, where the combined coverage is
significantly higher. In this case, both runs explore the seed, butpending constraints go deeper in the exploration. We discuss in
moredetailtheadvantagesprovidedbypendingconstraintswith
seeding in the SQLite3case study of §4.6.
Overall,pendingconstraintscover25%moreinstructionswith
random path search, 30% more with depth-biased search, and 23%
more with DFS. In the pending constraints experiments, depth-
biasedsearchcovered2%moreinstructionsoverallwhencompared
to random path search, which in turn covered 3.5% more than DFS.
Figure 7 shows the coverage achieved with only seed set 1 be-
tween our pending constraints approach and vanilla KLEE withthe random path search strategy. For most utilities, we can drawsimilar conclusions as for the experiments of Figure 6 where the
coverage for the two seed sets is merged. oggencis an exception as
it shows no coverage improvement on only seed set 1.
4.5 Pending Constraints with Relaxed Checks
Figure 7 also shows the coverage achieved with relaxed checks for
criticalinstructions(Section3.2).Ascanbeseenforsometoolslike
bcorSQLite3,relaxingthesecheckscanleadtolargeincreasesin
number of covered lines. In the case of bcthe instruction coverage
more thandoubles. For mostother utilitiesthe increase issmaller,
but not insignificant, with oggenc,magickpngandtcpdump being
the notable exceptions showing no or small decreases in coverage.
Theseresultsshowthatpendingconstraintswithrelaxedchecks
can be used to effectively reach deeper into the program, but with
the downside of errors being missed during exploration. 0 5 10 15 20 25 30 35 40 45 50
bc
datamashm4
magickjpg
magickpngmakeoggenc sqlite3tcpdumpCovered Instructions × 1000Vanilla Pending Relaxed Pending
Figure7:Coveredinstructionsonseedset1ofvanillaKLEEagainst pending constraints with both strong and relaxedchecks with the Random Path search strategy.
4.6 Case Study: SQLite3
To provide more insight into our approach, we now discuss one of
ourbenchmarks, SQLite3,inmoredetail.Inparticular,welookatthe
evolutionofcoverageonlong-runningexperimentsandexamine
variouspairwisecombinationsofconfigurationstouncoverhow
different seeding approaches and search strategies complement
each other.
4.6.1 24-hour Non-seeded Runs. We first performed 24-hour ex-
periments with SQLite3without seeding, with each of the three
consideredsearchstrategies.Eachexperimentwasrepeated3times
to account for the randomness of the depth-biased and random
path strategies. The results are shown in Figure 8a.
DFS performs surprisingly well for this benchmark. However,
with vanilla KLEE, it achieves no additional coverage after the first
122 0 10 20 30 40 50 60 70 80
 0  5  10  15  20Covered Instructions × 1000
Time (hours)Pending DFS
Pending Depth
Pending RPVanilla DFS
Vanilla Depth
Vanilla RP
(a) Non-Seeded 0 10 20 30 40 50 60 70 80
 0  5  10  15  20Covered Instructions × 1000
Time (hours)Pending DFS
Pending Depth
Pending RPVanilla DFS
Vanilla Depth
Vanilla RPRelaxed Depth
(b)Seeded
Figure 8: Coverage of SQLite3over a 24-hour run. The experiments were repeated 3 times, represented as lines of the same
type. Both non-seeded and seeded runs are shown.
hour. By contrast, pending constraints with DFS continue to make
progress and end up achieving the highest coverage overall.
We inspected the test inputs generated using DFS to understand
whyitperformssowell.VanillaKLEEwithDFSappearstobelucky,
asitmanagestofindtwoshortkeywords,suchas ASandBY,which
seem to be located close to the edge of the search space. These two
keywordsarenotfoundbyvanillaKLEEusingtheothertwosearch
strategies. Pendingconstraints with DFSdoes notfind these short
keywords, but instead finds longer ones such as INSERT,FILTER,
VACUUMandWINDOW.Thisisnotsurprising,asthesearchspaceof
pendingconstraintswithDFSisoftenquitedifferentfromthatof
regular DFS.
Pending constraints with random path gain coverage quickly
duetoitsbroaderexploration,butmakeslimitedprogressinthelast
10 hours. Pending constraints with the depth-biased strategy make
littleprogressforalongtime,butgainalotofcoveragetowardsthe
endofthe run,achievingcoveragesimilar tothatofrandompath.
Vanilla KLEE makes steady progress with both search strategies,
but does not overtake pending constraints.
4.6.2 24-hour Seeded Runs. We also performed 24-hour experi-
ments with SQLite3with seed set 1, with each of the three con-
sidered search strategies. In addition, we also run in this settingpending constraints with relaxed checks, using the depth biased
strategy. As in the non-seeded runs, each experiment was repeated
3 times.
Figure8bshowstheresults.Theseedcovers37.2kinstructions.
VanillaKLEEperforms similarlyacrossthethree searchstrategies
(allthelinesforthevanillaKLEErunsareatthebottomofFigure8b)
and never manages to complete the seeded path, stalling around
13kcoveredinstructions.Itmakesveryslowprogress,coveringless
than 500 new instructions in the final 20 hours of its run. This isduetoKLEE’seagerfeasibilitychecks,withlargeconstraintsthat
take a long time to solve.
Our pending constraints approach manages to cover all instruc-
tionsontheseededpath.Witherrorchecksinplace,ittakesupto3
hours to complete the seeded path, whereas with relaxed checks it
only takes 4 minutes. There are about 303 memory bounds checks
on the seeded path and solving the associated constraints accounts
forthemajorityofthetimedifferencebetweentheconfiguration
without and with relaxed checks. Note that 4 minutes is still signif-
icantly slower than the pure interpretation time of KLEE on thisinput. Our approach still performs some solving activities suchas computing independent sets and substituting the seed in the
constraints.
There is no difference between search strategies in the initial
seeding phase as the exploration is guided by the seed. After pend-
ing constraintsfinish withthe seeding, theymake littleprogressfor up to several hours. During this time they are attempting to
revivependingstates,mostofwhichareinfeasibleandtherefore
killed,thusgivingnoadditionalcoverage.Finally,dependingonthe
search strategy, a feasible state is revived, leading to the execution
of a different path, potentially giving large coverage gains.
The depth-biased search, which picks good states to revive in 2
outof3ofourruns,achievessignificantnewcoverage.However,
random path search outperforms the depth-biased search in all of
the 3 runs and seems to generally achieve higher coverage. Due to
determinism ofDFS, there isno difference betweenits runs. They
all achieve coverage in-between the random path and depth biased
search strategies.
Weinspectedthegeneratedtestinputsforthedepth-biased,DFS
and random path runs. The test inputs generated by the depth-
biased runs were mostly very similar to the seed, with only a small
123Figure 9: Heatmaps of coverage combination pairs for
vanilla KLEE (lower triangle) and pending constraints (up-
per triangle) for SQLite3.
number of characters changed (e.g. SELECT * TEMp ;. . in-
stead of the seed SELECT * FROM t; ).12Even when it manages to
find new keywords, such as FILTER,HAVING,UPDATE,VACUUM, and
WINDOW,thetestinputisclosetotheinitialseed(e.g. uPdATE * FROM
t;....). Similarly, DFS-generated test inputs are almost identical
totheseed,withonlythelast2characterschanginginadepth-first
fashion. The random path search strategy, on the other hand, also
findsseveralmorenewkeywords,suchas BEFORE,HAVING,INSERT,
FILTER, andVACCUM, but diverges early from the seed and finds
additional keywords by exercising different code in the parser (e.g.
./.c....;expLain.... ). This difference between the generated
test inputs across the three search strategies is expected, as depth-
biased search and DFS pick states towards the end of the path,
where the seed has a greater impact.
4.6.3 Pairwise Coverage Combinations. Finally,wewantedtoex-
plore how the different combinations (non-seeded, seeded with
seed sets 1 and 2, and different search strategies) complement each
other. Therefore, we looked at the pairwise combinations of cov-
erage for 2-hour runs of each configuration. We decided to omitshowing the DFS runs in this case to illustrate the complemen-
taryaspectsofseedingversusnon-seedingrunsmoreclearly.As
showninFigure4c,DFSisreallyeffectivein SQLite3withoutseeds.
The union of non-seeded DFS and other approaches cover only
10-100moreinstructionsthanDFSby itself.However, we notethat
DFS is not always the best-performing strategy, as shown by other
benchmarks.
12Inputsshorterthanthespecifiedsymbolicinputsizearepaddedwith \0andnewlines
(\n, \r) are shown as ’.’Analysing this amount of data is hard, so we devised the visuali-
sationinFigure9,whichshowspairwisecomparisonsofcombined
coverageacrossthe6differentconfigurationsfor SQLite3.Thela-
bels indicate the search strategy used and the seed set is indicated
in the subscript. Un-subscripted labels indicate non-seeding runs.
The figure consists of three different heatmaps. The upper right
triangle (red) shows the coverage achieved by pending constraints.
The lower left triangle (green) shows the coverage achieved by
vanillaKLEE.Thediagonal(blue)showstheratiobetweenpending
states and vanilla for non-combined runs. The data in the two
triangles is normalised with respect to their upper-left corner, that
isthe2hdepth-biasedrunwithoutseeds.Thehypotenusesofthe
triangles therefore show the non-combined coverage.
As this graphic is dense with information, we will walk through
acoupleofexamples.Lookingatthetop-leftcornerofourtriangles,
weseethatbothpendingandvanillaKLEEwithdepth-biasedstrat-
egyhavethevalueof1 .00—thisisbecauseeverythingisnormalised
tothisvalue.However,theblue1 .82valuetellsusthatourpending
constraintsapproachcovered82%moreinstructionsthanvanilla
KLEE with depth-biased search strategy.
Nowfocusingontwoconfigurationsfromthelowergreentri-
angle: depth-biased without seeds and depth-biased with seeds for
vanilla KLEE. The coverage of the run with a seed from set 1 is 9%
(1.09)higher thanthat ofthe non-seededrun, whilethe combined
coverage of both achieve 36% (1.36) more coverage. This indicates
that there is complementarity between the coverage achieved with
and without a seed.
Lookingatthesame2combinationsintheupperredtriangle,we
can see that with pending constraints, seeding with set 1 achieves
61%(1.61)morecoveragethanthenon-seedingrun.Furthermore,
theircombinationachieves97%(1.97)morecoveragethansolelythenon-seedingrun.Thatindicatesagainthatthereiscomplementarity
between seeding and non-seeding runs as with vanilla KLEE.
Therandompathsearchstrategywithoutseedingachievesmore
thantwicethecoverageofthedepth-biasedsearchstrategyinboth
vanillaKLEE(2.47)andwithpendingconstraints(3.11).However,
pendingconstraintscover129%(2.29)morelinesthanvanillaKLEE.
There is also some complementarity of coverage between depth-
biased search and random path with pending constraints. Their
unioncovers217%(3.17)moreinstructionsthanjustdepth-biased
asopposedto211%(3.11)achievedbyrandompath.VanillaKLEE
behaves similarly.
Finally, looking at the union of coverage between non-seeded
andseededruns,wecanseethatforpendingconstraintsseeding
complementswellwithdepth-biasedexploration,achievingover
30% points (1.61 to 1.97 and 1.65 to 2.00) more coverage when com-
bined. With random path, we don’t see any such complementarity
(3.11). Vanilla KLEE follows a similar pattern.
4.7 ZESTI
ZESTI[18]isapromisingextensionofKLEEthatcombinesEGT-
style symbolic execution with seeding via regression test suites.
Unfortunately, its original implementation was never upstreamed,
partly because it is quite large and intrusive. In this section we
showthatpendingconstraintscanbeusedtobuildalightweight
and effective version of ZESTI.
124ZESTI consists of several parts. The two most important ones
aretheabilityto useavarietyofinputsasseedsand thesocalled
ZESTIsearcher,whosepurposeistoexplorepathsaroundsensitive
instructions. The idea of the ZESTIsearcher is to take a single seedandexecuteittocompletion,whilerecordingsensitiveinstructions
and divergence points. A divergence point is a symbolic branch
where the path not taken by the seed is feasible. ZESTI then starts
bounded symbolic execution from the divergence point closest to a
sensitiveinstruction.Itthenmovestothenextclosestdivergence
point and so on.
Re-implementingZESTIontopofpendingconstraintsisstraight-
forward. Consider a symbolic execution run with pending con-
straints after a single seed has been executed to completion. There
are no normal states and many pending states representing thedivergence points described above. The ZESTI searcher is imple-
mentedbyconsideringpendingandnormalstatesseparately.We
prioritise normal states, but only if their depth does not exceed the
depth ofthe lastrevived pendingstate plussome bound.Pending
states are revived in the order of distance to sensitive instructions.
This is equivalent to the ZESTI searcher and is easy to implement.
For simplicity, our implementation currently considers only mem-
ory accesses as sensitive instructions.
Wefoundthebenchmarksusedforevaluationtobetoohardfor
ZESTI. For example, as seen in §4.6.2 it takes 3 hours to executea simpleseedwith SQLite3. Thusrunning thewhole testsuite of
SQLite3andexploringasignificantamountofpathsaroundaseedis
impractical. Therefore, we chose three tools that KLEE can execute
more comfortably: dwarfdump13,readelf14andtar15. These are
inspired by the original ZESTI paper [ 18], where we replaced GNU
Coreutils withtaras recent modifications in the Coreutils build
system make it harder to use with ZESTI.
To capture the seeds, we replaced each binary with a script and
ran the application test suite. We then removed large seeds of over
8.1MiB to keep the execution time associated with an individual
seedshort.Thisresultedin1273,313and5seedsfor dwarfdump ,
tarandreadelfrespectively. Since we wanted to run each seed for
30 minutes as per the original ZESTI paper and keep the overall
time under 12 hours, we ran at most 200 seeds per benchmark.
These experiments found one bug in dwarfdump16and one in
tar17which have already been confirmed and fixed by the develop-
ers.BothofthesebugswerefoundbytheZESTIsearcherandwere
not triggered by the original seed. Vanilla KLEE seeded with the
seed ZESTI mutated was not able to find these bugs with a 2-hour
timeout.
5 RELATED WORK
Concolic executors such as CREST [ 2], DART [ 12]o rS A G E[ 13]
also drive each test input to completion, which is similar to the
behaviour of pending constraints. However, these tools suffer from
thedisadvantagesofconcolicexecutorssuchasre-executingpath
prefixes and exploring a single path at a time. Our approach brings
13https://www.prevanders.net/dwarf.html
14https://www.gnu.org/software/binutils/
15https://www.gnu.org/software/tar/
16https://www.prevanders.net/dwarf.html (28 June 2020 update)
17http://git.savannah.gnu.org/cgit/tar.git/commit/?id=
dd1a6bd37a0d57eb4f002f01f49c51fa5c6bb104some of the strengths of concolic execution to EGT-style tools like
KLEE while maintaining their advantages.
KLEE[4]hasanexistingseedingmechanism,whichisalsoused
byZESTI[ 18]andKATCH [ 19].However,whenfollowingaseed,
KLEEeagerlyperformsfeasibilitychecksateverysymbolicbranch,
unlike pending constraints which defer these checks for when apending state is revived. This in turn can have a big impact on
coverage, as we have shown in §4.4.
KLUZZER[ 17],awhiteboxfuzzerbasedonKLEE,implements
asimilarideaofdelayingthesatisfiabilitychecksbyonlyfollow-
ingthecurrentlysatisfiedbranchgivenbyaseed.However,their
approach goes further by trading off the benefits of EGT-style sym-
bolic execution completely and reverting to concolic execution.
UC-KLEE [ 23] introduces lazy constraints. Here, the executor
continuesexploringpathsalthoughtheunderlyingconstraintsolver
can’t determine the feasibility in a given amount of time. The cor-
responding expensiveconstraint is addedas lazyconstraint to the
respective path condition and only evaluated when some goal is
satisfied, e.g. a bug is found, to suppress false positives. This leads
to more states in memory and thus to more solver queries but can
also reduce the overall solver time as the additional constraints
alongsuchpathsnarrowdownthesolutionspacefortheconstraint
solver. Our approach explores a different design point, which al-
waysfavoursstatesthatareknowntobefeasible,eitherviacaching
or seeding, and when just pending states are left, they are only ex-
plored further if they are determined to be feasible.
Hybrid fuzzing approaches such as Driller [ 25], QSYM [ 28]o r
SAVIOR[ 9]passconcreteinputsbetweenagreyboxfuzzeranda
symbolicexecutor.Theseapproachescoulddirectlybenefitfrom
pendingconstraintstoachieveatighterintegrationbetweenfuzzing
and symbolic execution.
6 CONCLUSION
We have presented pending constraints, a strategy that achieves a
moreefficientuseofconstraintsolvingandadeeperexplorationof programs with symbolic execution. The key idea is to aggres-
sively follow paths that are known to be feasible either via caching
or seeding, while deferring all other paths by storing states withpending constraints. Weimplemented this approach in KLEE andevaluated it on nine hard benchmarks, including make,SQLite3
andtcpdump.Ourevaluationshowsthatpendingconstraintscan
significantly increase the coverage achieved by symbolic execution
in both seeded and non-seeded exploration.
ACKNOWLEDGEMENTS
WethankMartinNowack,JordyRuizandtheanonymousreviewers
for their helpful feedback on the paper. This research has received
fundingfromtheEPSRCUKviaaDTAstudentship,theDSONa-
tional Laboratories, Singapore, and from European Research Coun-
cil(ERC)undertheEuropeanUnion’sHorizon2020researchand
innovation programme (grant agreement No. 819141).
125REFERENCES
[1]AndreaAquino,GiovanniDenaro,andMauroPezzè.2017.HeuristicallyMatching
Solution Spaces of Arithmetic Formulas to Efficiently Reuse Solutions. In Proc. of
the 39th International Conference on Software Engineering (ICSE’17).
[2]Jacob Burnim. 2020. CREST: A Concolic Test Generation Tool for C. https:
//www.burn.im/crest/
[3]Frank Busse, Martin Nowack, and Cristian Cadar. 2020. Running SymbolicExecution Forever. In Proc. of the International Symposium on Software Testing
and Analysis (ISSTA’20).
[4]Cristian Cadar, Daniel Dunbar, and Dawson Engler. 2008. KLEE: Unassistedand Automatic Generation of High-Coverage Tests for Complex Systems Pro-
grams.In Proc.ofthe8thUSENIXSymposiumonOperatingSystemsDesignand
Implementation (OSDI’08).
[5]CristianCadarandDawsonEngler.2005.ExecutionGeneratedTestCases:Howto
Make Systems Code Crash Itself. In Proc. of the 12th International SPIN Workshop
on Model Checking of Software (SPIN’05).
[6]Cristian Cadar, Vijay Ganesh, Peter Pawlowski, David Dill, and Dawson Engler.
2006. EXE: AutomaticallyGenerating Inputsof Death.In Proc. ofthe 13thACM
Conference on Computer and Communications Security (CCS’06).
[7]Cristian Cadar and Timotej Kapus. 2020. Measuring the coverageachieved by symbolic execution. https://ccadar.blogspot.com/2020/07/
measuring-coverage-achieved-by-symbolic.html.
[8]Sang Kil Cha, Thanassis Avgerinos, Alexandre Rebert, and David Brumley. 2012.
Unleashing Mayhem on Binary Code. In Proc. of the IEEE Symposium on Security
and Privacy (IEEE S&P’12).
[9]Yaohui Chen, Peng Li, Jun Xu, Shengjian Guo, Rundong Zhou, Yulong Zhang,
Taowei, and Long Lu. 2019. SAVIOR: Towards Bug-Driven Hybrid Testing.
arXiv:cs.SE/1906.07327
[10]PeterCollingbourne,CristianCadar,andPaulH.J.Kelly.2011. SymbolicCross-
checkingofFloating-PointandSIMDCode.In Proc.ofthe6thEuropeanConference
on Computer Systems (EuroSys’11).
[11]Peter Collingbourne, Cristian Cadar, and Paul H.J. Kelly. 2011. Symbolic Testing
of OpenCL Code. In Proc. of the Haifa Verification Conference (HVC’11).
[12]Patrice Godefroid, Nils Klarlund, and Koushik Sen. 2005. DART: Directed Auto-
matedRandomTesting.In Proc.oftheConferenceonProgramingLanguageDesign
and Implementation (PLDI’05).
[13]Patrice Godefroid, Michael Y. Levin, and David A. Molnar. 2008. Automated
Whitebox Fuzz Testing. In Proc. of the 15th Network and Distributed System
Security Symposium (NDSS’08).
[14]WeiJinandAlessandroOrso.2012. BugRedux:ReproducingFieldFailuresforIn-house Debugging. In Proc. of the 34th International Conference on Software
Engineering (ICSE’12).
[15]Timotej Kapus and Cristian Cadar. 2019. A Segmented Memory Model for Sym-
bolicExecution.In Proc.ofthejointmeetingoftheEuropeanSoftwareEngineeringConferenceandtheACM SymposiumontheFoundationsofSoftwareEngineering
(ESEC/FSE’19).
[16]Chris Lattner and Vikram Adve. 2004. LLVM: A Compilation Framework forLifelong Program Analysis & Transformation. In Proc. of the 2nd International
Symposium on Code Generation and Optimization (CGO’04).
[17]HoangM.Le.2019. KLUZZER:WhiteboxFuzzingonTopofLLVM.In Automated
Technology for Verification and Analysis (ATVA).
[18]PaulDanMarinescuandCristianCadar.2012. maketest-zesti:ASymbolicExecu-
tion Solution for Improving Regression Testing. In Proc. of the 34th International
Conference on Software Engineering (ICSE’12).
[19]PaulDanMarinescuandCristianCadar.2013. KATCH:High-CoverageTestingofSoftwarePatches.In Proc.ofthejointmeetingoftheEuropeanSoftwareEngineering
ConferenceandtheACM SymposiumontheFoundationsofSoftwareEngineering
(ESEC/FSE’13).
[20]Hoang Duong Thien Nguyen, Dawei Qi, Abhik Roychoudhury, and Satish Chan-
dra. 2013. SemFix: Program Repair via Semantic Analysis. In Proc. of the 35th
International Conference on Software Engineering (ICSE’13).
[21]SaahilOgnawala,ThomasHutzelmann,EiriniPsallida,andAlexanderPretschner.2018. ImprovingFunctionCoveragewithMunch:AHybridFuzzingandDirected
Symbolic Execution Approach. (April 2018).
[22]Hristina Palikareva, Tomasz Kuchta, and Cristian Cadar. 2016. Shadow of a
Doubt:TestingforDivergencesBetweenSoftwareVersions.In Proc.ofthe38th
International Conference on Software Engineering (ICSE’16).
[23] David A. Ramosand DawsonEngler. 2015. Under-constrainedSymbolic Execu-
tion:CorrectnessCheckingforRealCode.In Proc.ofthe24thUSENIXSecurity
Symposium (USENIX Security’15).
[24]KoushikSen,DarkoMarinov,andGulAgha.2005. CUTE:AConcolicUnitTesting
EngineforC.In Proc.ofthejointmeetingoftheEuropeanSoftwareEngineering
ConferenceandtheACM SymposiumontheFoundationsofSoftwareEngineering
(ESEC/FSE’05).
[25]NickStephens,JohnGrosen,ChristopherSalls,AndrewDutcher,RuoyuWang,
Jacopo Corbetta, Yan Shoshitaishvili, Christopher Kruegel, and Giovanni Vigna.
2016. Driller: Augmenting Fuzzing Through Selective Symbolic Execution. In
Proc. of the 23rd Network and Distributed System Security Symposium (NDSS’16).
[26]Willem Visser, Jaco Geldenhuys, and Matthew B. Dwyer. 2012. Green: reduc-
ing,reusingandrecyclingconstraintsinprogramanalysis.In Proc.oftheACM
SIGSOFT Symposium on the Foundations of Software Engineering (FSE’12).
[27]JunfengYang,CanSar,PaulTwohey,CristianCadar,andDawsonEngler.2006.
Automaticallygeneratingmaliciousdisksusingsymbolicexecution.In Proc.of
the IEEE Symposium on Security and Privacy (IEEE S&P’06).
[28]Insu Yun, Sangho Lee, Meng Xu, Yeongjin Jang, and Taesoo Kim. 2018. QSYM: A
Practical Concolic Execution Engine Tailored for Hybrid Fuzzing. In Proc. of the
27th USENIX Security Symposium (USENIX Security’18).
126