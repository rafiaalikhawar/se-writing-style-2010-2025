11292020 35th IEEE/ACM International Conference on Automated Software Engineering (ASE)
User Web Server
JS Miner Server
Mining Pool ServerVisit a website
Retrieve a JS miner 
Authenticate with a site key
Assign a job with a target hash
Compute hash
Submit a result
Accept and record hashes completed 1
2
3
4
5
6
7
Repeating the steps 5~7
(i.e., continuously computing and submitting hashes)…
1130typedef struct {
uint32_t h [16]; // internal hash state
uint8_t buf [64]; // store partial block
int buflen ; // buf[] length
}hashState;
hashState S ;
void hash (uint8_t *msg,int msglen ,
uint8_t *hashval ){
index =0;
len =msglen ;
memcpy (S->h,H0,64);
for (;len>= 512; index+ =64,len=len- 512){
F(S->h,msg+index );
}
if(len >0){
memcpy (S->buf,msg+index ,len>>3);
S->buflen =len>> 3;
}while (S->buflen <64){
S->buf[ S->buflen ++] = 0;
}F(S->h,S->buf);
memcpy (hashval ,(unsigned char *)S->h+32,32);
}
(a) C Implementation.2
31
4
5
(b) WebAssembly Opcodes.12
34
5
6
7
8
9
10
11
121314
15
16
17
18
19
2021
22
23
241 Step
get_local $l1
i32.const 8000
i64.load
i64.store
get_local $l1
i32.const 8008
i64.load
i64.store offset =8
...
get_local $l1
i32.const 8056
i64.load
i64.store offset =561
2
3
45
6
78
9
10
11
122 Step
13
14
15
1617
18
1920
21
222324
25
2627
28
29
30
31
32get_local $p1
set_local $l4
loop $L0
get_local $l1
get_local $p0
get_local $l5
i32.add
call $f22
get_local $l5
i64.const 64
i64.add
set_local $l5
get_local $l4
i64.const -512
i64.add
tee_local $l4
i64.const 511
i64.gt_u
br_if $L0
end3 Step
33
34
35
3637
38
3940
41
424344
45
4647
48
49
50
51
52get_local $l4
i64.const 0
i64.ne
if$I0
get_local $p0
get_local $l5
i32.add
set_local $l6
get_local $l4
i64.const 3
i64.shr_u
set_local $l7
get_local $l2
get_local $l6
get_local $l7
call $f11
get_local $l3
get_local $l7
i32.store
end4 Step
53
54
55
5657
58
5960
61
626364
65
6667
68
69
70
71
7273
74
7576get_local $l8
i32.const 64
i32.lt_s
if$I1
loop $L1
get_local $l3
get_local $l8
i32.const 1
i32.add
i32.store
get_local $l2
get_local $l8
i32.add
i32.const 0
i32.store 8
...get_local $l8
i32.const 64
i32.lt_s
br_if $L1
end
endget_local $l1
get_local $l2
call $f225 Step
7778
79
8081
82
8384
85
8687
88
8990
91get_local $p2
get_local $l1
i32.const 32
i32.add
tee_local $l6
i64.load align =1
i64.store align =1
get_local $p2
get_local $l6
i64.load offset =8
i64.store offset =8
...
get_local $p2
get_local $l6
i64.load offset =24
i64.store offset =24
while(S->buflen <64){
S->buf[S->buflen++]= 0;
}
F(S->h,S->buf);19
20
21
22if(len>0){
memcpy(S->buf,msg+index,len>>3);
S->buflen=len>>3;
}15
16
17
18memcpy(S->h,H0,64); 11
for(;len>=512;index +=64,len=len-512){
F(S->h,msg+index);
}12
13
14
memcp y(hashval ,(unsigned cha r*)S->h+32,32); 23
1131(a) JavaScript Code. (c) WebAssembly
Opcodes.(b) JS-WebAssembly
Interoperation....
targetHash =0xffffff00
while (true ){
var hash =_argon2_hash ()
...
if(hash <targetHash )
break ;
...
(func _argon2_hash
...i64.or
i64.const 3
i64.shl
i64.and
i64.xor
i64.shr_u
i64.load
call $f53 ...12
3
4567
89
10
11
12
131415
16
1718
Stadnard
Wasm BinaryIntraprocedural
CFGHash Function
Inference
User Consent 
Call GraphInterprocedural
CFG
Detect
ResultMinerRayCFG Construction
Cryptojacking
DetectionBinary Converter/
JS-Wasm Compiler
Programming Language 
Liftingasm.js-derived 
Wasm Binary
asm.js
JavaScript 
ProgramProgram
Abstraction
* IR: Intermediate Representation
1132(a) WebAssembly Code. (c) Stack States$l18000
$l1[8000]64
$l18008
$l1[8008]64
$l1Line 1$l1
get_local $l1
i32.const 8000
i64.load
i64.store
get_local $l1
i32.const 8008
i64.load
i64.store offset =81
2
3
4
56
7
8Line 2 Line 3 Line 4
Line 5 Line 6 Line 7 Line 8
(b) Abstraction Rules AppliedLine Stack Operation Def Set Operation Abstraction
1 push( $l1)
2 push( 8000 )
3 pop() →8000 , push(R64( 8000 ))
4 pop() →R64(8000 ), pop() →$l1 Def($l1)=Def( $l1)∪{$l1=R64( 8000 )} W64( $l1, R64( 8000 ))
5 push( $l1)
6 push( 8008 )
7 pop() →8008 , push(R64( 8008 ))
8 pop() →R64(8008 ), pop() →$l1 Def($l1+8)=Def( $l1+8)∪{$l1=R64( 8008 )}W64( $l1+8, R64( 8008 )) Legend
Variable Constant Memory
1133(b) Merge Consecutive Writes in a Loop.W32(da,R32(sa));
W32(da+4,R32(sa+4));
...
W32(da+4i, R32(sa+4i));memcpy (da,sa,16i);
L:
W8(da+idx, R32(sa));
sa =sa +1;
idx= idx+1;
if(idx<idx+len)
gotoL;memcpy (da+idx,sa,len);
sa=sa+len;
idx=idx+len;(a) Merge Sequential Writes. 
memcpy (hash_state, initial_value_ptr, hash_state_size );
Loop :
Compression ();  /* compression function */
Increment block pointer by block_size
Decrement remaining message length by block_size
if (remaining message is larger than a full block ) 
goto Loop ;
if (remaining message exist ) {
memcpy (tmp_buf, remain_msg, remain_msglen);  
W32 (tmp_buflen_ptr, remain_msglen);  
}
if (temp buffer is not a full block ) 
memset ( tmp_buf[tmp_buflen_ptr], C, 
block_size -r e m a i n _ m s g l e n ) ;
Compression ();
memcpy (hash_value,hash_state*, hash_value_size );Step 1
Step 2
Step 3
Step 4
Step 5Initialization
Block 
Hashing Loop
Tail 
BlockHashing
Padding
FetchingHashing Algorithm (Step 2~4)
1134button. onClick =( )= >{
xhr. onreadystatechange =function ()
if(xhr.readyState === xhr.DONE ){
p.postMessage({type:
'auth-success' });
}
};
xhr. open ('POST' ,'authedmine.com/
auth/' );
xhr. send ('auth&key=' +siteKey );
}1
2
3
4
56
7
8
9
obj.onClick ()
Network Response
parent. onMessage ()
miner. work ()
miner. hash()
1135020406080100120140Number of Websites
050100150200250Number of Websites901 (Detected)900 (Detected)809 (Detected)810 (Detected)742 (Detected)838 (Detected)
6( F a l s e  A l a r m )1406 (False Alarm) 1 (Missed)92 (Missed), 1 (False Alarm)91 (Missed), 2 (False Alarm)159 (Missed)63 (Missed)
0 500 1000 1500 2000 2500MinerRayMineSweeperCMTrackerOutguardNo CoinminerBlock
Number of Samples
Detected False Alarm Missed
1136By entering TPB you agree to XMR being mined using your CPU. If
you don’t agree please leave now or install an adBlocker
1137113811391140