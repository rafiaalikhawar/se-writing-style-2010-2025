EfficientModule-Level Dynamic Analysis forDynamic
Languages with ModuleRecontextualization
Nikos Vasilakis
MITCSAIL
USA
nikos@vasilak.isGrigorisNtousakis
TUCrete
Greece
gntousakis@isc.tuc.gr
VeitHeller
Unaffiliated
Germany
veit@veitheller.deMartinC. Rinard
MITCSAIL
USA
rinard@csail.mit.edu
ABSTRACT
Dynamic program analysis is a long-standing technique for ob-
taininginformation aboutprogram execution.We present module
recontextualization ,anewdynamicanalysisapproachthattargets
modern dynamic languages such as JavaScript and Racket, enabled
bythefactthattheyfeatureamodule-importmechanismthatloads
codeatruntimeasastring.Thisapproachuseslightweightload-
timecodetransformationsthatoperateonthestringrepresentation
ofthemodule,aswellasthecontexttowhichitisabouttobebound,
toinsert developer-provided,analysis-specific codeintothe mod-
ule before it is loaded. This code implements the dynamic analysis,
enabling this approach to capture all interactions around the mod-
ule in unmodified production language runtime environments. We
implementthisapproachintwosystemstargetingtheJavaScript
andRacketecosystems.Ourevaluationshowsthatthisapproach
candeliverorder-of-magnitudeperformanceimprovementsover
state-of-the-artdynamicanalysissystemswhilesupportingarange
ofanalyses,implementedonaverageinabout100linesofcode.
CCS CONCEPTS
·Software and its engineering →Software maintenance tools ;
Dynamic analysis ;Frameworks .
KEYWORDS
Dynamic,Runtime,Analysis,Instrumentation,Recontextualization,
Performance,Security
ACMReference Format:
Nikos Vasilakis, Grigoris Ntousakis, Veit Heller, and Martin C. Rinard. 2021.
Efficient Module-Level Dynamic Analysis for Dynamic Languages with
Module Recontextualization. In Proceedings of the 29th ACM Joint European
Software Engineering Conference and Symposium on the Foundations of Soft-
wareEngineering(ESEC/FSE ’21), August 23ś28, 2021,Athens, Greece. ACM,
NewYork, NY, USA, 12pages.https://doi.org/10.1145/3468264.3468574
Permissionto make digitalor hard copies of part orall ofthis work for personalor
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
onthefirstpage.Copyrightsforthird-partycomponentsofthisworkmustbehonored.
Forallotheruses,contactthe owner/author(s).
ESEC/FSE ’21, August 23ś28,2021, Athens,Greece
©2021 Copyright heldby the owner/author(s).
ACM ISBN 978-1-4503-8562-6/21/08.
https://doi.org/10.1145/3468264.34685741 INTRODUCTION
Dynamic program analysis is a technique for monitoring, under-
standing,andpotentiallyinterveninginprogrambehaviorduring
its execution. To cite only a few examples, dynamic analysis has
beenusedtoinferinvariants,checksecurityconstraints,andextract
performance characteristics [ 3,29].
Existing dynamic analyses often impose significant runtime
overheadÐJalangi[ 33]andRoadRunner[ 13],forexample,report
No-Op analysis overheads on the order of 26ś32 ×and 52×, respec-
tively.Forthisreason,dynamicanalysisistypicallydeployedfor
offline useÐcollecting and replaying traces offline or stressing a
program withtestinputs inatestenvironment.The factthatpro-
ductionenvironmentscandifferconsiderablyfromofflineortesting
environments can significantly impair the utility of dynamic analy-
sesthataredeployedonlyduringdevelopmentortesting.Software
vulnerabilities, for example, can be latent during development and
test, but exploitableonly inproduction [ 30].
We present a new point in the dynamic analysis design space:
modulerecontextualization isanapproachthatoperatesatthegran-
ularity of modules, with the resulting analysis code executing at
moduleboundaries.1Weemphasizethatthegoalisnottosupplant
existingtechniquesthat operateatthegranularityofinstructions
orprocedures[ 22,26,33].Thegoalisinsteadtoprovideacoarse
analysis with low enough overhead (in practice, 2ś3% runtime
overhead) to enable always-on, uniform deployment during de-
velopment, testing, and production. In effect, we trade off detail
and precision to drive down the overhead while still supporting
meaningfulanalyses(ğ 5).
Module recontextualization leverages characteristics of modern
dynamic languages to dynamically transform each module when it
is loaded, applying both source code and object transformations. It
thusrequiresnochangestotheruntimeenvironmentandworks
with completely unmodified dynamic language production run-
times.Theanalysesthemselvesarewritteninthesamelanguageas
theanalyzed program, preservingdeveloperknowledge, expertise,
libraries,andcode,andenabling thedevelopment ofanalysesthat
analyzeanalysiscode.Theseanalysesremainfullyunderdeveloper
control, with module recontextualization supporting targeted anal-
ysisofonlyselectedmodulesanddynamictogglingonandoffas
the applicationexecutes.
1Weusethe terms moduleand libraryinterchangeably.
1202
ESEC/FSE ’21, August 23ś28, 2021,Athens,Greece Nikos Vasilakis,Grigoris Ntousakis,VeitHeller, andMartinC.Rinard
This paper makesthe following contributions:
•Module recontextualization: Itpresents module recontextu-
alization, a new dynamic analysis approach that targets modern
dynamic languages and operates atthe boundaries of (selected)
modules. Module boundaries go well beyond externally invoked
entrypointsÐtheyalsoincludereferencedglobalvariables,basic
languagefeaturessuchas importandexportstatements,and
basic type constructors such as NumberandArrayconstructors.
•Twoimplementations: It presents a two-part implementation
ofmodulerecontextualization,Lya,thattargetstheJavaScript
and Racket ecosystems. The discussion of the opportunities and
challenges associated with implementing Lya as a pluggable
library for modern dynamic languages focuses on the JavaScript
port, anddiscussesRacketwhen the twodiverge.
•Case studies andevaluation: It presents an evaluation of Lya
for three dynamic analyses of JavaScript applications and li-
braries,includingaread/write/executesecurityanalysis,aper-
formanceanalysis,andarun-timetypeinvariantdiscoveryanal-
ysis.ItshowsthatLyaincursruntime overheadsunder5%and
can accurately detectissuesand applicationcharacteristics that
would surface only in production environmentsÐ e.g., invalid
accesses during object deserialization, performance pathologies
inregular-expressionmatching, anddynamic type anomalies.
Lya has been open-sourced and is available for download from
GitHub:
https://github.com/andromeda/lya
2 BACKGROUND,EXAMPLES, AND SCOPE
Wefirstpresentbackgroundonmodulesystemsemployedbydy-
namic languages (ğ 2.1). We then describe three use cases that high-
light the kinds of the analyses the Lya is designed to support (ğ 2.2).
We finish by identifying the scope of Lya, i.e., the characteristics of
the environmentsandanalysesthat ittargets (ğ 2.3).
2.1 ModuleSystems
Modules encapsulate reusable functionality. This functionality typ-
ically falls into two categories: it either (i) comes bundled with the
language,possiblywrappingoperating-systeminterfacessuchas
the file system in a way that is system-agnostic and conforms to
the language’s conventions, or (ii) is provided by other developers
sharingcodeothersmightfinduseful.Consideramodulenamed
simple-mathbelow, providing a few mathematical functions such
asmulanddiv:2
letmath={
mul:(a, b) => a *b,
div:(a, b) => {
import("log").info(b);
returna/b } };
// ...some more code...
exports =math;
Thismodulemaybe importedandusedbyadifferentmodule,as
shownbelow:
2In the background and design sections of the paper, we write import; in the sections
describingthetwoimplementationsandevaluationofLya,weusetheactualname
corresponding to the prototypein eachlanguageÐ e.g.,require.letm=import("simple-math" );
letresult=m.div(m.mul( 1,2), m.mul( 3,4));
print(result); exports =result;
From a developer’s perspective, importing a module makes its
functionalityavailabletothe calling code bymeans ofbindingits
functionality to a name in the caller’s scope. This is achieved by
some form of exporting, where the module developer expresses
which values should become available to the importing code. The
definition of a value depends on the semantics of the language.
Internally, the module may importother modules, cause side ef-
fectsto the file systemor the network, or even be implemented in
multiple languages.
ImportingamoduleinadynamiclanguagesuchasJavaScript
typically involves several steps. The runtime system first locates
themodule inthefile system.It then reads the module and wraps
ittoresolvemodule-localnames,suchas __filename inJavaScript
and__name__ in Python, to meaningful values. The wrapper is
then interpreted and evaluated using the language’s interpreter,
whichmightresultinsideeffectsÐforexample,a process.exit()
inthemodule’stop-levelscopewillexittheentireprogram.Finally,
the value bound to the exported interface or returned from this
interpretation(dependingonthelanguage)ismadeavailabletothe
scope ofthe importingcode.
Complicationsmayincludetheuseofamodulecachetoavoid
loadingoverheadsandmaintainconsistencyformodulesthatare
loadedmultipletimesfromdifferentpartsofthecodebase.Theuse
of a module cache can also support recursive imports and cyclic
dependences. An increasingly common feature is to allow different
versions of the same module to co-exist in a program, to avoid
imposingonemutuallyexclusivechoiceÐaparadoxicalsituation
knownasłdependencyhellž.Asaresult,asingle importlmaynot
necessarilyresolvetothesame(versionofthe)module leverytime.
Thedualofthisisalsopossible:twodifferentmodulenamesmay
resolvetothesameidentifier( i.e.,pointtothesamecacheentry).
Thesefeaturescansignificantly complicatedynamicanalysesthat
operate at the granularity of modules. We further discuss these
issues,includinghowLyadeals withthem,inSection 3.
2.2 DynamicAnalysis Examples
Wenextdiscussthreeexampledynamicanalysesthatcanbeper-
formedatthegranularityofmodules:(i)aread-write-executese-
curity analysis, (ii) a performance-profiling analysis, and (iii) an
analysisextracting runtimetype invariants.
SecurityAnalysis: Thepervasiverelianceonthird-partylibraries
hasledtoanexplosionofsupply-chainattacks[ 18,20,23,35,39].
Both bugs and malicious code in libraries create attack vectors, ex-
ploitablelongafterlibrariesreachtheirendusers.Popularlibraries,
dependeduponbytensofthousandsofotherlibrariesorapplica-
tions, can allow vulnerabilities deep in the dependency graph to
affectagreatnumber ofapplications[ 43,44].
Consider, for example, the recent event-streamincident [ 11,
30], in which a maintainer of a highly popular library inserted
codetostealBitcoinwalletcredentialsfromprogramsusingthatli-
brary.Heavyweighttestingorinstrumentation[ 33]wouldnothave
helped,as event-streamactivated onlyduringproductionrather
1203Efficient Module-Level Dynamic Analysis forDynamic LanguageswithModule Recontextualization ESEC/FSE ’21, August 23ś28, 2021,Athens,Greece
than during testing or development. Whole-program OS-level con-
tainment or system-call interposition [ 32], would have not helped
either as the programs importing event-streamalready made use
of system calls to access the disk and network. Finally, static anal-
ysis wouldhave beenoflittleuse,as event-streamencryptedits
malicious payload.
Amodule-level dynamicanalysisofread/write/execute permis-
sions [40] used by this library would have detected the unusual re-
sources accessed by event-stream. Analyzing the behavior within
thelibraryitselfis notcritical:ifanydata exfiltration ishappening,
it will require calling out of the library and into the networkÐin
event-stream’scase,usingthe fslibrarytomodifyadifferentli-
braryandthencall httpfromthesecondlibrary.Both fsandhttp
arepartofthestandardlibrary,builtintotheruntimeenvironment.
Other examples of interfaces that are available to the entire pro-
gramincludeglobalvariables,libraryimporting,andthemodule
cacheÐallofwhichare accessible byany third-partylibrary.
PerformanceDiagnosis: Diagnosingperformanceproblemsisa
difficult task, exacerbated by the heavy use of third-party libraries.
Theselibrariesoftenworkwelluntilthereisanunexpectedchange
inthetypeorcharacteristicsoftheworkload[ 38].Inmanycases,
theperformancebehavioroftheselibrariesisaffectedbyasingle
unusualinput.
Consider,for example,the minimatch library,a regular-expres-
sion-basedfile-matchingutilitysusceptibletolongdelaysdueto
regular expressions that involve backtracking [ 21]. Pathological
inputs reaching minimatch , even if benign, can cause significant
performance degradation [ 6] deep in the dependency chain, af-
fecting also other parts of the program competing for the same
resources [ 7]. Developers use various techniques to understand
suchproblemsÐ e.g., collecting and replaying tracesagainstoffline
versions of the system, or using statistical profiling to identify hot
code-paths. These techniques, however, require significant manual
effort:capturingtraces,settinguptestbeds,replayingtraces,an-
alyzingstatistics,anddebuggingperformancearealltediousand
time-consuming tasks, compounded by the difficulties of mapping
the results to the right third-partylibraries.
A library-level profiling analysis would quickly detect any slow-
downandappropriatelyattributeittothebottlenecked minimatch .
Wrapping library interfaces with profiling logic can be of aid to
constructing a model of the current workload. Such profiling could
operate at a high resolution in time and spaceÐat every func-
tion call entering a library and on hundreds of libraries across
anapplicationÐbutdoesnotneedtotrackdetailedoperationssuch
as direct variable accesses. Each library wrapper can collect profil-
ing statistics at its own boundary, aggregating summaries into a
globalstructure orderinglibraries byresourceconsumption.
Type Invariant Discovery: Extracting type information at the
moduleboundaryishelpfulin a varietyof scenarios.For example,
itcanbeusedtoidentifyprograminvariantstobepreservedduring
code modifications [ 12], or guide program learning and regener-
ation[4].Dynamicallyextractedtypeinformationisparticularly
relevantfordynamicallytypedlanguagesthathavenoexplicittype
information inthe language.
Consider,forexample,the gRPCmoduleforserializingandde-
serializingobjects[ 37].Tousethismodule,developersprovideaprotocol-bufferspecificationdescribingthetypesofvaluesthatwill
be serialized. Given a libraryÐ e.g.,bignum,cryptoÐa developer
has to first call it manually, take note of the result’s type, and then
fillintheprotobufspec.Thisprocesshastoberepeatedwithevery
change,oftendue tolibraryupdatesor changesintheconsuming
program’s structure.
Module-leveldynamicanalysiscouldbeusedtodiscoversuch
typeassertionsorinvariants.Theanalysiswouldconsultthedefini-
tionofatypesystem,capturingthetypeofvaluesattheboundaries
oflibrariesbyobservingtheirargumentsduringtheexecutionof
the program.
2.3 Scope
Lyaexploits features of modern dynamic languageenvironments,
forexampledynamicmoduleloading,runtimemetaprogramming
facilities such as reflection or exposing object accesses as overload-
ablefunctions,andruntimeresolutionofexternalreferences.The
basic approach is therefore not appropriate for software written in
traditionalcompiledlanguagessuchasC,Java,ML,orHaskell.Itis
also not appropriate for traditional scripting languages such as the
Unixshell dueto several challenges [ 14].
Because Lya operates at the granularity of modules, it targets
modern application development methodologies where applica-
tions comprise hundreds of modules, with the modules typically
reused from large open source repositories such as GitHub or npm.
These methodologies deliver applications with (i) a module decom-
positioncoarseenoughforminimalruntimeoverhead,(ii)amodule
decompositionfineenoughtosupportmeaningfulanalysesthatop-
erateatthemodulegranularity(Lyaisthereforenotwellsuitedfor
monolithic applicationswith fewor no modules), and (iii) most of
the code obtained from external and potentially untrusted sources
(motivatingtheneedfordynamicanalysesthatcanpinpointand
helpsolve security orperformance issues).
Ourproposedtechniquesworkwellwhentherecencyofinfor-
mation(ideally,online)ismoreimportantthanthelevelofdetail.
They meet such recency needs through a combination of factors.
First, Lya provides the ability to perform the analysis online by
operatingatacoarsergranularity,byusingaproduction-optimized
runtime,andbytogglingpartsoftheanalysisonandoff.Second,it
allowsdeveloperstoleveragetheirexpertiseintheirlanguageof
choiceÐrather thanintroducing anewlanguageonly for analysis:
the program being analyzed and the program implementing the
analysis can only be in the same language, as the analysis trans-
formations are applied dynamically over theprogram by the same
runtime environment. Finally, it deconstructs programs only at
library boundaries,a natural boundary for many problems caused
(orexacerbated)bythird-partylibraries.
3 MODULE RECONTEXTUALIZATION
Lya starts by dynamically modifying the functionality of the mod-
ulesystemthatisresponsibleforimportingandloadingmodules:
instead of simply locating and loading a modules from the file sys-
tem,themodulesystemyieldscontroltoLya,whichappliesaseries
of transformations to modules with the goal of interposing at their
boundaries.WestartwithanoverviewofLya(ğ 3.1),highlighting
1204ESEC/FSE ’21, August 23ś28, 2021,Athens,Greece Nikos Vasilakis,Grigoris Ntousakis,VeitHeller, andMartinC.Rinard
severalkeychallenges,followedbyadetaileddescriptionofeach
step (ğ3.2ś3.4).
3.1 Overview
Lya operates by decomposing the program at the boundaries of
modules, applying transformations that insert analysis-specific ma-
chinery, and then carefully reassembling individual components to
maintain the originalsemantics:
•Decomposition: Lyastartsbyrecursivelydecomposingapro-
gram into its dependencies. This is achieved by rewiring the
language’s importfunction to go through Lya, resulting in Lya
walkingtheprogram’srecursivedependencystructureatrun-
time. During this phase, Lya has to determine the granularity
of the analysis ( e.g., top-level modules, a specific module etc.) in
orderto apply transformationsat thecorrect level and mapthe
providedanalysishooks to the corresponding modules.
•Recontextualization: Lyathensetsuptheprovidedanalysis,
by transforming each module interface, its surrounding envi-
ronment, and possibly the valuespassing through the module
boundary.Programmatictransformationswalkandwrapeach
oneofthesevaluesbasedontheirtype.Thisphaserequiressolv-
ingseveralchallenges,includingenumeratingallpointsofentry
intoandexitoutofamodule,andswappingalloriginalvalues
externallyavailabletoamodulewithonesthatarewrappedwith
interposition mechanisms.
•Reassembly Finally, Lya reassembles individual modified mod-
ules back into the program’s original structure. A key challenge
inthis phase is the treatment of the module cache (ğ 2.1), which
needstobeaugmentedtosupportmultiplewrapperspermodule,
eachcapturingapart ofthe overallanalysis.
ExampleÐCountingGlobalAccesses: Asthethreeaforemen-
tionedanalyses(ğ 2.2)aretoocomplextoshowhere,wepresenta
smaller analysis that counts all accesses to global variables from
thesimple-mathmodule:
letfs=import("fs");
letcount={};
forevery.global.inlib( /simple-math/ ).analyze({
pre:(name, path, _) => {
leto=resolve(name, path);
count[o] =count[o] ?count[o] + 1 : 1;
} });
process.on( "exit", () => { fs.writeFileSync(
"access.json" ,"utf-8", JSON.stringify(count)); });
Lya-provided forevery generates a set ofmodule identifiers.The
inlibfieldisamethodthattakesaregularexpressionmatching
module identifiers. If not empty, preandposthooks are called
before and after each access of the elements specified in the set.
Finally,resolveisamethod fortraversinganobjectgivenapath
within that object. Upon program exit, the results are written to
disk,allusing the expectedNode APIs.
To perform this analysis, Lya first interposes on the importcall
todetectwhen simple-mathisloaded.Whenloading simple-math,
Lya applies (1) a source-to-source program transformation that re-
define global identifiers as module-local ones, and (2) a dynamicmetaprogramming( i.e.,runtimereflection)transformationtotra-
verse global values and create a global-indirection map specific
to thesimple-mathmodule. For every global identifier the map
holdsmodifiedglobalvaluesthatarewrappedsuchthatanyaccess
to these values from within the simple-mathmodule is visible
by Lya, which upon access calls the corresponding prehook. Fi-
nally,Lyainterpretsthetransformed simple-mathmoduleusing
thebuilt-incodeevaluationprimitiveÐsimilartothevanillamodule
systemÐeffectivelylinkingthemodule-localidentifierlookupsto
the map entries that hold the modified values corresponding to
theseidentifiers.
The nextfewsubsections discuss the details.
3.2 Decomposition
WhenaLya-augmentedprogramstarts,itfirstloadstheanalysisfile
providedbythedeveloper.Thefilemayspecifyasubsetoflibraries
whoseboundariesareofinterestorasubsetoflibrariesthatshould
notbeanalyzed.Amongotherthings,Lyaneedstodeterminethe
library boundaries of interest and the granularity of analysis. To
dothis,itextractsanapproximationofthedependencygraphby
traversinglibraryfiles.Usingthisgraph,itprocessestheanalysis
file to extract a mapping from library identifiers to analysis hooks.
ItalsochecksforconstructsnotassociatedwithlibrariesÐforex-
ample, whether the analysis includes global variables, library-local
constructs,standardlibraries etc.Lyathenproceedstodynamically
replace the implementation of importand launch the program:
ratherthansimplylocatingandloadingalibrary,callsto import
nowyieldto Lya.
For every invocation of importLya checks the cache (ğ 3.4) to
determine(i)ifthelibraryhasalreadybeenloaded,and(ii)whether
thelibraryhasbeenloadedwiththesameanalysishooks.Ifbothare
determinedtrue,Lyaretrievesthecachedversionofthelibraryand
returnsthetransformed exported value.Ifthelibrary wasloaded
witha differentanalysisÐsay because there are differentanalyses
applied to different parts of a dependency treeÐLya constructs the
appropriate analysis and applies a transformation pass on a cached
copy of the unmodified library (ğ 3.4). Otherwise, Lya first invokes
the built-inlibrary loaderto locate the library.
The process of loading new libraries includes (i) a phase of read-
ing the necessary source files and (ii) a phase of interpreting them,
interspersedbyapplicationsoftransformations(ğ 3.3).Readingfiles
returns a string representation of the code; interpretation uses the
language’s runtime evaluation primitives to convert thecode into
an in-memory object.
Some analysesmay themselves makeuse ofglobalvariables, li-
braries,andotheranalyzableconstructs.Asthesewillbepartofthe
same execution context, Lyamust note toavoidtransforming and
wrapping these constructs as part of the analysis. Lya frameworks
mayalsowanttoaddanalysis-specifickeywordsnotprovidedby
thelanguage.Toachievethis,Lyawrapseachanalysishookwith
afunctionwhosebodystartsbydefiningtheexpectedkeywords.
The precise techniques for achieving this will be made clear in the
nextsection(ğ 3.3),aftercoveringtransformations;thekeypoint
to remember is that analyses are initially represented as source
strings,similar to libraries.
1205Efficient Module-Level Dynamic Analysis forDynamic LanguageswithModule Recontextualization ESEC/FSE ’21, August 23ś28, 2021,Athens,Greece
Mod ← {
  foo: () =>  {
    proc .id()
    var x ← y
    …
import Mod.foo
main ← {
  foo(1, 2);
  …
LYA
wrappers// context
proc ← mock.proc
glob.y ← 3
// return values
mod.foo ← n(Foo)
Figure 1: Shadowing segments. Cross-module variable name
resolution(left)augmentedwithLya(greenboxes),whichinterjects
non-bypassablestepsresolvingtoLya-augmentedvalues(topright:
implicitmoduleimports; bottom right: explicit import) ( Cf.ğ3.3).
3.3 Recontextualization
For each analyzed library, Lya needs to place hooks all around
its boundaryÐnot just its interface entry points (Figure 1). This
is achieved in three logical steps: (i) transforming the library’s
context,amappingfromnamestovaluesthatareavailablefrom
outsidelibrary,(ii)interpretingthelibrarywithinthiscontext,so
that all names bind and resolve toLya-augmented values,and (iii)
transformingthelibrary’s exportvalue,i.e.,thelibraryinterface,
oncetheinterpretationiscomplete.Beforediscussing whereeach
transformation isapplied,we show howthey are applied.
Transformations: Lya’s transformations boil down to a base
transform wrapthattraversesandaugmentsvalueswithruntime
analysismonitors.Atahighlevel, wraptakesavalue vandanalysis
fragments (α1,α2)andreturnsanewvalue v′thathaseveryone
ofitsfields fwrapped:every fisreplacedwithamethod f′that
callsfragment α1,callsf,callsfragments α2,andreturnstheresult
ofthe callto f.
More specifically, wrapcan be applied to any value in the lan-
guage, which can generally be a primitive, a function, or a com-
pound valueÐsay, a list of values or an object of key-value pairs.
Transformationswalkcompoundvaluesfromtheirroot,processing
componentvaluesbasedontheirtypes(Figure 2):(i)functionvalues
arewrappedbyclosuresthatcontainanalysis-specifichooks;(ii)
objectandlistvalues are recursively transformed, with their getter
andsettermethodsreplacedsimilartofunctionvalues;(iii) prim-
itivevaluesareeithertransformeddirectlyorcopiedunmodified
and wrapped with an access interposition mechanism. To avoid
cycles during the walk, values are added to a map that is consulted
at the beginningofeachrecursive call.
Direct field accesses, such as assignments, require detection
uponaccess.Toachievethis,Lyawrapsfieldswithaninterposition
mechanism;this mechanismessentiallytreatsdirect fieldaccesses
asfunctioncalls(seeğ 4forimplementationdetails).Extendinga
transformed object with a value will start withthe value’stransfor-
mation. For example, if a field in a transformed object is assigned a
new value, that value has to be transformed before it is attached to
the object.
Lyaallowstogglinganalyseson/off,changinganalyses,orchain-
ing multiple analyses during the execution of the program. To
achieve this, it maintains a handle to the root of both the unpro-
cessed and the newly processed values, for further processing: the
wrap ( e: Value, α: Analysis) : Value := match  e with
   | {(s, v) :: vs}        {(s, wrap v) :: wrap vs}
   | [v :: vs]              [(wrap v) :: wrap vs]
   | λ(…args ).f            λ(…args ).{ α1( f( α2(args) ) ) }
   | __                       interpose (α3, e)
end→
→
→
→Figure2:Basetransform. Thealgorithm(simplified)ispresented
infunctionalstyletosimplifyvariablebinding;types(object,list,
function,andprimitive),usedforpatternmatching,areshownin
lightturquoise (Cf.ğ3.3). The functions α1,α2, andα3stand for the
locations ofanalysishooks.
unprocessed value is used to create objects, at runtime, that run
differentanalyses;thenewvalueisusedtorevokeorchainanalyses
together.
ContextTransformation: To be able to track an analysis at the
library boundary, Lya needs to provide each library with values
thatareaugmentedwithinterpositionwrappersÐanddothisforall
ofthenamestowhichalibraryhasaccess.Thisincludesglobaland
pseudo-global3names providedbythe languageandits runtime.
Toachievethis,Lyafirstneedstoprepareatransformedcopyof
thelibrary’scontextÐamapfromvariablenamesthatare(expected
tobe)inscopetotheirvalues.Lyacreatesanauxiliaryhashtable
mappingnamestotransformedvalues.Namescorrespondtoany
namethat,bythelanguagedefinition,isaccessiblebythelibrary
andresolvestoavalueoutsidethatlibrary,suchasglobals,built-
ins,module-locals, etc.Transformedvaluesarecreatedbyapplying
wrapto valuesinthe context,addingthe providedanalysishooks.
Care must be taken with library-local variables. These are acces-
siblefromanywherewithinthescopeofalibrary(similartoglobal
variables),butresolvetoadifferentvalueforeachlibrary.Examples
includethelibrary’sabsolutefilenameas __name__ ,itsexported
values,andwhetherthelibraryisinvokedastheapplication’s main
library(ğ 2.1).Attemptingtoaccesslibrary-localvariablesdirectly
from within Lya’s scope will fail subtly, as they will end up re-
solving to library-local values of Lya itselfÐand specifically, the
module within Lya that is applying the transformation. Lya solves
this problem by leaving the value empty and deferring binding for
laterfrom within the scope of the library (see below).
ContextBinding: Tolinkthelibrarywiththenewlytransformed
version of its context, Lya wraps the libraryÐstill an uninterpreted
stringofsourcecodeÐwithaclosure.Theclosure’sbodystartswith
aprologue ofthe form:
local print =ctx.print
local error =ctx.error
// ...more entries...
Thesestatementsshadowglobalvariablenamesbyredefiningthem
asfunction-localones.Theclosureacceptsanargument ctxthat
willholdthecustomizedcontext(seeabove),assigningitsentries
totheirrespectivevariablenames.Theprologueexecutesbeforeev-
erythingelseinthelibrary.Thistechniqueleverageslexicalscoping
3Forexample,NodeintroducesobjectsthatarenotpartoftheEcmaScriptspecification
into the global scope, such as process andconsole; similarly, Lua’s Luvit introduces
its own globals such as p()andexports.
1206ESEC/FSE ’21, August 23ś28, 2021,Athens,Greece Nikos Vasilakis,Grigoris Ntousakis,VeitHeller, andMartinC.Rinard
toinjectanon-bypassablestepinthevariablenameresolutionpro-
cess:insteadofresolvingtovariablesinthecontext,resolutionwill
firstłhitžlibrary-local valuesaugmentedwithanalysismonitors.
Late-bound, library-localvariables,suchastheabsolutefilename
mentioned during context creation, are the result of applying wrap
over variable names in the current scope; these names are now
bound to the correctlibrary-local values.
LibraryInterfaceTransformation: Returningthelibrary’svalue
to its consumer amounts to interpreting the library, linking it with
thecustomcontext,andapplyingafinaltransformationtoitsreturn
value. The goal of the final transformation is to track activity at
theboundary.4Thisfinaltransformationisappliedforeverynew
consumer of the library, returning a fresh analysis wrapper. This is
due to the need for distinguishing between different boundaries of
the same library.
The treatment of this feature during reassembly is explained in
the nextsection (ğ 3.4).
3.4 Reassembly
Tosuccessfullyreassembletheapplication,Lyaneedstoensurethat
cross-references between libraries resolve correctly. The central
mechanismfor this resolutionisthe library cache.
To support multiple wrappers for a single cached library, the
cache is extended by two levels (for a total of three). The reason
for adding the two levels is that libraries are usually governed
by a single context analysis but multiple interface analyses, one
for each of their consumers. A context transformation is applied
at most a few times (usually only once), whereas a return-value
transformationisappliedonevery import.Thus,thefirstlevelis
indexedbylibraryidentifiers(asbefore);thesecondbycontextanal-
ysis; and the third by analysis of the exported interfaces. For each
library,thesecondlevelcontainsacollectionofentriescorrespond-
ing to mostly-transformed libraries, and the third level contains
fullytransformedlibraries.Mostly-transformedlibrarieshavegone
throughtheentiretransformationpipelineexceptforthelaststage:
theyhavebeeninterpretedandhavehadtheircontexttransformed
andlinked,buttheirreturnvaluehasnotbeenprocessedtotrack
analysisofits interface.
A special entry is reserved for the original library value as a
string(ğ3.3),sothatsubsequenttransformationscanskiploadingit
from disk. When a new analysis is applied to a library, Lya indexes
the cache by library identifier and applies the analysis-specific
wraptothelibrary’scontext.Itthenaddsthatresulttoaslotinthe
next layer of the cache, indexed by the analysis identifier. When
alibraryisalreadyloaded,Lyaindexesbyanalysis toretrievethe
(mostly) transformed library corresponding to this analysis. It then
appliesatransformationtothelibrary’sreturnvalue,andinserts
the (finalized)transformedlibrary to the thirdlayer ofthe cache.
4 TWO IMPLEMENTATIONS
WehaveimplementedLyaforserver-sideJavaScript(Node.jsv8.9.4,
about 2.5K LoC) and Racket (Racket v7.8, about 500 LoC). This
section details the JavaScript implementation, integrated into npm
4For some analyses, Lya needs to additionally augment the values going through
thelibrary’sinterfaceÐincludingcontinuationfunctionspassedasargumentstothe
library’s methods.and available for setup under andromeda /lya, and only refers to
Racketwhen the twodiverge.
There are two main ways to implement Lya. The first is as a
modified version of the runtime, in which several stages of its
library-loading facility have been augmented in-place. The second
approach is to implement Lya as a third-party library ( e.g., thelya
package)availablebythelanguage’s package manager. Withboth
approaches, the user experience is a backward-compatible, drop-in
replacement of the language’s module system indistinguishable
from the vanilla system. We went with the second approach, as
looser coupling seems to have several benefits: it does not force
Lya’s users to have a custom copy only for running analyses; it
removesLya’sdevelopersfromthecriticalpathofupdatesbetween
thelanguagedevelopersanditsusers;and itsimplifiesLya’scom-
parisonwiththevanillaenvironment(bothintermsofperformance
and correctness). The primary drawback was missing a few oppor-
tunities for lowering runtime performance and development effort.
ModuleSystemImplementation: In bothlanguages, the mod-
ulesystemisimplementedentirelyintherespectivelanguageitself,
exposing a library-local function for importing modules. Loading a
fresh module corresponds to the following five stages, all of which
areaugmentedbyLya:(R)Resolution:identifythefiletowhichthe
modulespecifiedcorresponds,locateitinthefilesystem,andassign
its absolute path as a module identifier. (L) Loading: depending on
thefiletype,identifythecorrespondingloaderÐ e.g.,V8compiler
forjs,JSON.parse forjsonetc.(W)Wrapping:wrapthemoduleso
thatlocalnamesdonotescapethemodule’sscopeandmodule-local
namesgetresolved.(E)Evaluation:evaluatethewrappedmodule
inthecurrentcontext,sothatglobalnamesandtop-levelobjects
get resolved correctly. (C) Caching: add the module to a handful of
module-relatedcaches, for consistency andperformance reasons.
Lya augments all of these steps. Interposing on resolution (R)
makesthe module identifier available to Lya without affectingthe
module resolution algorithm. If the module’s type corresponds to a
modulethatcanbeanalyzedbyLya,Lyafetchesthecorrespond-
inganalysisduringloading(L).Wrapping(W)andevaluation(E)
are where Lyatransforms the module boundary.Lyaadds awrap-
perfunction topass an additionalargument, the modified context
CTX.LyaforNodecomeswithahard-codedlistof variablenames
available to the code of a module, such as require andArray;
thelistcontainsabout150 entriesand correspondstothespecific
versions of EcmaScript and Node. Identifying names coming from
EcmaScriptwasrelativelyeasy,asthestandardmakesthemexplicit.
Node’sglobalnamesaredescribedatvariouspartsofthedocumen-
tation, but library-local names required close inspection of Node’s
internals; fortunately,they were only five names.
AchallengewithRacketwasitslackoffacilitiesforintercepting
moduleloading(L).Toaddressthis,Lyaprovidesitsowncustom
loaderwhichallowsittomodifythemodule’ssourcecodeearlyÐ
during the macro-expansion phase and prior to any evaluation.
During this phase Lya for Racket manipulates the code in AST
form, contrary to Lya for JavaScript that manipulates the code as a
string. Another challenge with Racket was its lack of support shad-
owingnamebindingsinsideamoduledirectlywhentheoriginal
value is used. This is because a name is resolved to the name de-
fined in the local module rather than in the parent module, raising
1207Efficient Module-Level Dynamic Analysis forDynamic LanguageswithModule Recontextualization ESEC/FSE ’21, August 23ś28, 2021,Athens,Greece
ałusebefore definitionž. Toaddressthis,Lyageneratesnames for
the original module in an intermediary module, and binds them to
theirexpectednamesintheoriginalmodule.Additionally,ifany
unused name is not (known to be) bound ahead of time, Racket
willcomplainÐwhichprecludesemitting evalformstobindany
symbolsorintroduceanyforms.SincetheRacketcompilerrunning
in phases and the resolution of require and macro expansion hap-
penattwodistinctphases,Lyashiftsphasesforthe safe-require
macroto work, expandingto a moduleandrequireform.
We found it useful to add an option for explicitly including and
excluding libraries. The configuration object accepts onlyandnot
expressionsthatindicatewhetheramoduleidentifierwillbepartof
the analysis. These expressions contain sets of regular expressions,
pattern-matchingagainstmoduleidentifiers(absolutefile-system
paths). Originally intended as an aid to Lya’s development and
debugging, this option proved useful enough for writing the three
analysesthatwedecidedtoexposeittoLya’susers.Examplesofits
useincludeexcludingbuilt-inlibrariesorincludingonlythelibrary
importedmostrecently.
ExampleTransformationFragments: The code fragments be-
lowexemplifyLya’stransformationsinthecontextofJavaScript,
as appliedto the simple-mathlibrary shownearlier(ğ 2.1).
Lyatraversesthe mathobject,creatinganewreplacementobject
whose functions are replaced with wrappers that call the corre-
spondingfunctionoftheoriginalobjectinterleavedwiththehooks
corresponding to the specific analysis:
let_=math; math ={};
math.mul =(...args) => {
letp=lya.hooks.prologue(args);
letv=_.mul(...args);
returnlya.hooks.epilogue(p, v); }
// skipping code for div etc.
Lyanextcreatesamodifiedversionofthesurroundingcontext,a
bindingfromnamestomodifiedvaluesÐ i.e.,objectstransformed
according to the aforementionedwrapping transformation:
varctx={
// original, unmodified value:
print:lya.print,
// lya-transformed value:
import:lya.txf( import,
lya.hooks.prologue,
lya.hooks.epilogue),
// (...more values below, omitted...)
}
Lya binds this new context to the module being loaded using a
source-to-sourcetransformthatwrapsthemoduleinaclosurethat
redefinesgloballyaccessible identifiers as module-local ones:
function (cxt) {
varprint=cxt.print;
var import =ctx.import;
// --start: original math module--
// (fragments omitted)
div:(a, b) => {
log.info.(b);
returna/b, }// --end: original math module--
}
Itfinallyinterpretsthemoduleclosure,whichreturnsanin-memory
Function object,andinvokesthe closurebypassingthemodified
contextcreatedabove as an argument.
5 EVALUATION
Questions: We seekto answer the following three questions:
•Q1: How does Lya perform in detecting real problems occurring
inproduction environments?
•Q2: What is the runtime overhead of Lya, and how does it com-
pare withprior analysisframeworks?
•Q3: How large (LoC) are the analyses developed, and how does
itcompare withprior analysisframeworks?
Summary: Weuseseveraldifferentsetsofbenchmarkstoanswer
these questions.We developthethree analyses outlined inğ 2and
applythemtobothindividuallibrariesandlargerprograms.The
analyses average 94 lines of code, and applied to the tests available
bythenominaldevelopersincurruntimeoverheadsofunder5%.We
also apply workloads identified from reports taken from GitHub
issues and CVE databases and confirm that Lya indeed detects
theseproblematicbehaviors.ApplyingLyaandJalangionJalangi’s
SunSpiderbenchmarksshowsLyaaveraging87 ×loweroverhead
thanJalangi.
Setup:Experimentswereconductedonamodestserverwith4GB
of memory and 2 Intel Core2 Duo E8600 CPUs clocked at 3.33GHz.
In terms of software, we used Docker version 18.09.7 running a
minimalUbuntu14.04.6,Jalangiv1,Node.jsv8.9.4(bundledwith
V8v6.1.534.50,LibUVv1.15.0,andnpmv6.4.1),andRacketv.7.8Ðall
atop a Debian Linux with kernel v4.4.0-134. All times reported are
inms,averagedover1Kruns; SA,PD,andTIDrespectivelystand
for security analysis, performance diagnosis, and type invariant
discovery.
5.1 Analyses
Wenowreportonthedevelopmentoftheseveraldynamicanalyses,
including ones targeting the problems outlined in ğ 2. Individual
analyses average 95.3 lines of code, but a significant part (about
20%) ofthis code isidenticalacrossthem.
Security Analysis (111LoC): To address the security concerns
ofthird-partylibraries,wedevelopeda RWXpolicythatanalyzesac-
cesses for every library-to-library combination. The analysis treats
built-inlibraries andglobalvariablesasmodules,anddevelops a
permission model where individual fields are governed by permis-
sion sets containing combinations of R,W, andXpermissions. At
the start of the analysis all permissions are set to ⊥(i.e., default-
deny), and are gradually overwritten based on the accesses seen
by the analysis. Example accesses include: (i) reading a value, in-
cluding assigning it to a variable and passing it around to other
modules; (ii) modifying or deleting a value; and (iii) executing a
valueÐe.g.,afunctionoramethodÐorinvokingaconstructor(usu-
allyprefixedby new).Theresultingpermissionsetsareorganized
ascollectionsofmaps,oneperlibrary,indexedbyobjectpathsÐ e.g.,
require( "Math").add:RX.
1208ESEC/FSE ’21, August 23ś28, 2021,Athens,Greece Nikos Vasilakis,Grigoris Ntousakis,VeitHeller, andMartinC.Rinard
Table1:Lya’spercent(%)overheadofitsanalysesappliedover30popularlibraries. On average, Lya’s analyses incur an overhead
of4.14% ,3.62%, and3.86% for the security analysis(SA), performance diagnosis(PD), andtype invariantdiscovery (TID).
algebraarray.chunkarray-firstarray-lastarray-rangearr-diffarr-flattenconcat-streamdeep-binddocument-readyfile-sizefs-promiseget-valuegroup-arrayhas-key-deephas-valueheidentity-functionin-arrayis-empty-objectis-generatoris-numberis-promiseis-sortedleft-padmissing-deep-keysnode-dunode-slugnormalize-pkgnot-definedSA 0.42 1.44 2.02 1.94 5.20 2.04 3.13 6.90 1.59 5.14 3.78 4.02 1.78 8.49 1.38 3.84 7.51 7.26 5.47 6.82 0.54 3.80 3.82 2.38 5.63 1.00 7.01 4.22 26.70 5.23
PD 0.23 0.42 1.93 1.41 5.61 2.13 2.19 6.31 1.87 4.75 2.24 2.60 1.05 6.94 1.79 2.75 5.78 7.63 4.90 6.01 0.71 3.41 2.91 1.12 5.71 0.62 6.36 3.24 19.86 4.88
TID 1.42 2.27 2.59 1.67 5.45 2.03 1.68 5.80 2.35 5.90 2.43 3.04 1.09 7.47 2.04 3.54 6.91 7.42 5.49 6.36 1.01 4.63 4.00 2.74 6.14 0.64 6.05 3.37 22.68 5.24
We apply Lya’s RWXanalysis to safe-eval (v0.3), a modulein-
tended as a sandboxed replacement to runtime code evaluation by
carefully sanitizing its input prior to calling eval. By executing
safe-eval ’stestsuite,wemanuallyinspecttheresultandconfirm
that the code didnot escape the sandbox.
CVE reports from Snyk [ 2], a public vulnerability database,
indicate potential vulnerability and include a proof-of-concept
exploit (PoC). The PoC payload breaks out of the sandbox by
accessing process through the prototype chain, and then bind-
ingchild_proceess to spawn a whoami. Using as a starting per-
mission set the one obtained from the tests, Lya’s RWXanalysis
records and reports multiple invalid accessesÐ e.g.,Raccess over
the prototype chain, Xaccess over require, andRpermission over
child_process .
PerformanceDiagnosis(87LoC): Wedevelopedaprofilinganal-
ysisthatoperatesattwolevels:(i)module-boundarywrappersthat
collectprofilingstatisticsforcallsbetweenmodulesbywrapping
module interfaces; and (ii) an aggregator function that collects
statistics from all boundary wrappers and generates a model of
libraryloadunderthecurrentworkload.Boundarywrappersop-
erate at a higher-frequency intervals than the aggregator, which
operates on summaries. Their analysis focuses on function calls,
skippingallotherdirectfieldaccesses.Functionsarewrappedwith
prologue and epilogue wrappers that record statistics from the
Node.jsruntimeÐfornow,afrequencycounterandatimerbetween
prologue-to-epilogue invocations. Boundary wrappers summarize
thesestatisticsbyperiodicallysendingawindowed,weightedaver-
age ofcalllatencies to the aggregatorfunction.
WeapplyLya’sperformanceanalysisto uri-js(v2.1.1),anexten-
sible URI parsing and validation module that is fast in the average
case. Issuing an HTTP load of 5Kreqs/s of uri-js’s test dataset,
uri-jsrespondswithan averagelatency of34.3ms ( σ: 2.8ms);
Specialpathologicalinputs,foundonpublicGithubissues[ 10],
cancause uri-jstospendupwardsof400msperURIinpathologi-
cal edge cases. Servicing a workload with 99% benign URIs and 1%
pathological URIs, the throughput of the unmodified uri-jsdrops
to 197req/s (15.2s per request, σ: 11.04s). Lya’s analysis detects and
reports the load pressure appliedon uri-js.
Type Invariant Discovery (86LoC): To infer type invariants
forserializationspecifications,webasedouranalysisonasimple
type systemmodeledafter the simply-typed lambdacalculus aug-
mented with: (i) unions (sum types), such as string|number,(ii) JavaScript-specifictypes such as null,NaN, orundefined ,and
(iii) anativetype for values that cannot be serialized, such as
console.log . Support for union types is useful for when our anal-
ysiswitnessesvariablesholdingvaluesofdifferenttypesÐalthough,
in practice, programs tend to make calls of the same type across
theirentire lifetime[ 12].
WeapplyLya’stypeinvariantdetectiontothebuilt-inJSONseri-
alization module. By pollingfroma fixed setof different invariants,
Lyacanquicklydetectwhetheravalueisnotlikelytobeprocessed
by the module intended for that valueÐin particular, here it ana-
lyzeswhetheraprovidedobjectstructurecontainscycles.While
objects in the test suite do not contain cycles, Lya detects multiple
anomalousinstanceswhereobjectscontaincyclesandthusrequire
adifferentserialization-deserializationlibrary.
5.2 Runtime Performance
To understandLya’s runtimeperformance characteristics, we per-
formedthreeexperiments.Inthefirstexperiment,weapplyLyaon
30 popularlibrariesfrom npmandobserve averageoverheads 3.6ś
4.1%. In the second experiment, we compare Lya with Jalangi on
Jalangi’sworkloads,andobserve1ś3ordersofmagnitudespeedups
(average87 ×).
Lya on Popular Libraries: For the first experiment, we evalu-
ateLyaon30JavaScriptmodulesfromthe npmecosystem.These
modules are from a curated list containing a list of łsmall, focused
Node.js modulesž [ 31], which we sort by module popularity, and
pickthetop30:Thesemodulesaverageabout4.8Mweeklydown-
loads (total: 227M) and are depended upon by about 656 other
modulesorapplicationsonaverage(total:30K).
Each library was run against the test suite provided by its nomi-
naldevelopers,via npm test .Astheselibrariesarequitepopular,
they have received significant investment in their testing infras-
tructure,resultingintotwomaincharacteristicsrelevanttoLya’s
evaluation:(i)differenttestsstressdifferentpartsofthelibraryand
correspondinganalysisprimitives;(ii)evenifmostapplicationsthat
importtheselibrariesuseonlyafractionoftheirfunctionality,tests
stillcoverthemajorityofprovidedfunctionalityÐ e.g.,weobserved
test suites that were10 ×the size of the corresponding library.
Tab.1showstheperformanceoverheadofapplyingLyatothese
librariesasapercentageofthevanillaruntime.Overheadsreporton
runningeachlibrary’sentiretestsuiteunderthethreeanalysesand
comparingagainst thenon-Lyaversion.For thesecurityanalysis,
1209Efficient Module-Level Dynamic Analysis forDynamic LanguageswithModule Recontextualization ESEC/FSE ’21, August 23ś28, 2021,Athens,Greece
theaverageis4.14%(max.:26.7%;min.:0.13%);fortheperformance
analysis,theaverageis3.62%(max.:19.86%;min.:0.23%);andfor
thetype-invariantanalysis,theaverageis3.86%(max.:22.68%;min.:
1.21%).Toaverageacrossanalyses,Lyaincursabout3.8%slowdown.
Wezoomintothesourcesoftheseoverheadsinalatersubsec-
tion(ğ5.3).
Lya vs.Jalangi: For the second experiment, we compare the per-
formance of Lya to that of Jalangi. Jalangi is a popular dynamic
analysisframeworkforJavaScript,providingfine-grainedinstru-
mentation byexecutingonacustominterpreter.
Forthisexperiment,weuseadifferentsetofbenchmarksÐthose
ofJalangiitselfÐaswewerenotabletorunJalangionthe30micro-
packages. This inability was because many of these 30 packages
make use of newer EcmaScript features; examples of such features
include arrow functions, template strings, destructuring, and en-
hancedobjectliterals.Jalangiwasfurtherperplexedby npm test
(which is an external program outside Node, but tightly coupled
with it). Contrary to Jalangi, Lya allows the existence of recent
languagefeatures,demonstratingthecompatibilitybenefitsofoper-
atingonanunmodifiedruntime.Jalangi’sbenchmarksuiteincludes
26 programs from SunSpider [ 9], which we execute as part of a
Jalangi-provided docker container [ 15]. For these experiments, Lya
wasalsorun inthe same container.
In terms of analysis, both systems are configured to perform
dynamic frequency analysis of accesses to global variables. The
analysis is a common denominator between Lya and Jalangi, de-
signed and implemented from scratch to ensure a meaningful com-
parison between the two frameworks. Such analyses are useful
for understandinghowprogramcomponentsinteract withglobal
stateÐe.g., for generating remote-procedure stubs or scaling out
functional components[ 38].
The performance results show that Lya performs better than
Jalangi, at times by a significant margin: on average, Lya takes 87 ×
(max.:266.3 ×,min.:3.1 ×)longertocompletethanLya.Thereare
tworeasonswhyLyaoutperformsJalangi,bothofwhichrelatedto
Lya’smainthesis.Thefirstreasonisthat,toachieveitsanalyses,
JalangiisimplementedasacustomJavaScriptinterpreterwrittenin
Python,whichislessefficientthanthenativeJavaScriptimplemen-
tation.Lya,ontheotherhand,operatesonacompletelyunmodified
V8engine,Google’sJavaScriptruntimeenvironment,takingadvan-
tageoftheenvironment’sjust-in-timecompiler,well-engineered
garbagecollector,andotherproduction-gradeengineeringinvest-
ment. The second reason is that Lya operates at a significantly
coarser granularity, selectively wrapping data values needed by
theanalysis,whereasJalangiinstrumentseverysub-expressionÐ
includinglanguage-levelconstructssuchas if,while,break,+etc.
Forthesetworeasons,Jalangiinterpretstheentireprogramusingits
own custom interpreter and hooks, whereas Lya adds only a small
overheadononlythedataflowsbeinganalyzed.Thesedifferences
show that language-based recontextualization transformations à la
Lyacan deliver non-trivialperformance improvements.
5.3 Further Micro-benchmarks
Thissubsectionpresentsaseriesofmicro-benchmarksthatzoom
further into Lya’s sources of overheads. The key results are that
(i)themajorityoftheoverheadcomesfromtheJavaScript’s withTable2: SyntheticMicro-benchmarks. Applyingthethreeanalyseson
a series of synthetic micro-benchmarks, created to stress different features.
Alltimings arein ms(Cf.ğ5.3).
Base SA PD TID
globalvars 0.90 4.70 4.54 4.30
built-in fields 1.44 6.46 6.24 5.96
counter 3.37 6.26 6.32 5.72
allnames 7.79 13.54 13.31 12.8
custom delays 24661 24848 24754 24760
direct-access 4.06 7.24 7.16 6.79
simple-types 4.11 7.25 7.23 6.86
cycles 4.32 8.32 8.19 7.73
construct, only used for a small fraction of Lya’s transformationsÐ
only to global variables;(ii) interposition overhead isnegligible in
practice; (iii) while wrapped and accessed fields increase exponen-
tially as a function of depth (as objects have many fields), object
explosion quickly plateaus around level four with under 400 fields;
and (iv) the majority of wrapped and accessed fields come from
Node andEcmaScript names ratherthanimports orglobalvalues.
SourcesofOverhead: Tounderstandthesourcesoftheseover-
heads,weperformaseriesofmicro-benchmarkswithtightloops
callingseveralES-internallibrarieswithoutanyI/O.Byenablingdif-
ferentpartsofLya,wediscoverthattheprimarysourceofoverhead
comes from JavaScript’s withconstruct: disabling withmakes 95%
of the overheads disappear. The reason withdominates overheads
is twofold: it (i) interposes on too many accesses, only a fraction
ofwhicharerelevant,and(ii)remainssignificantlyunoptimized,
since its use isstrongly discouragedbythe JavaScript standards.
InterpositionOverheads: Table2depictstheresultsofthethree
analysesappliedtoasubsetoftheaforementionedsyntheticbench-
marks. The firstcolumn indicates the focus of the benchmark; not
allanalysisśbenchmarkcombinationsareuseful:for example,the
łcustom-delayž benchmark features static bottlenecks across its
dependencytreebutdoesnotinvolveinterestingaccesspatterns.
Lya-inducedslowdownisunder2 ×,exceptforthefirsttwocases
thatfeature onlyaccesses.Closeinspectionconfirmsacorrelationto
thenumberofwrappedobjectsandthefrequencyofaccesses:these
benchmarks feature artificially tight loops with high-frequency ac-
cesses.Transformationoverheadsthemselves(notinTab. 2)remain
under1ms.
To understand the costs of proxy interposition, we measure the
timetoaccessdeeply-nestedpropertiesoftwoversionsofanob-
ject:unmodifiedandproxy-wrapped.Paths totheproperties ( e.g.,
a.b.c....) are random butgeneratedpriortorunningthe experi-
ment.Weconstruct300MB-sizedobjects,eachwithafanoutof8
fieldsnested for 12levels.The proxy-wrapped version introduces
interpositionateverylevel.Traversingonemillion12-edgepaths
(i.e.,roottoleaves)averages167.2msand595.7ms(3 .5×)fortheun-
modified and proxy-wrapped versions, respectively. We emphasize
thatthisisanartificiallyconstructedbenchmarkstressingworst-
caseoverheadsnowherenearannormalexecution:forcomparison,
the transformation of these objects itself took nearly 16 seconds
(103×morethanwhatwesawwithrealmodules).Thetakeaway
is that Lya-inherent overheads due to interposition are unlikely to
1210ESEC/FSE ’21, August 23ś28, 2021,Athens,Greece Nikos Vasilakis,Grigoris Ntousakis,VeitHeller, andMartinC.Rinard
# Objects (wrappers)0100200300400
0 1 2 3 4 5 6 7 8 9algebra:
array.chunk:
array-last:
array-range:
arr-diff:
arr-flatten:
71 more
    Valid Unique 0102030
0 1 2 3 4 5 6 7 8 9algebra:
array.chunk:
array-last:
array-range:
arr-diff:
arr-flatten:
71 more
Total Valid
0100020003000
0 1 2 3 4 5 6 7 8 9algebra:
array.chunk:
array-last:
array-range:
arr-diff:
arr-flatten:
71 more
Figure3:Analysischaracteristicsasafunctionoftheanaly-
sis depth. From the top: (i) number of Lya wrappers applied, (ii)
number of unique accesses ( i.e., counting each access once), (iii)
totalnumber ofaccesses( Cf.ğ5.3).
be the bottleneck of an analysis; what is likely to be is the analysis
itselfÐe.g.,updatingaglobalaggregatororinvokingsystemcalls
to extracttiming.
Analysis Depth: To understand the effect of depth in practice,
Figure3presentsthenumberofwrappedobject,uniqueaccesses,
andtotalaccessesasafunctionofdepthforall30libraries(ğ 5.2).
Depth is the distance from the root of each name path up to the
last accessible field and represents how deep Lya traverses refer-
ences starting starting from the names in scopeÐ e.g., the access
global.obj.x is two levels deep and fs.readFile is one level
deep.
Thereareafewhighlightsworthnoting.Whilethenumberof
objectswrappedbyLyastartsgrowingrapidly,itquicklyreaches
anaverageupperboundof400(dependingontheexactbenchmark).
AccessesgrowexponentiallyforthefirstcoupleoflevelsÐasobjects
atlevelshavemultiplefields,manyofwhichareaccessedseveral
thousandtimesÐbut thenstabilizearoundlevel5.This isbecause
mostinterfaces followa mostly-flatformatwhere allmethods are
definedat the top level orright under.
Context: Context refers to the broad source of names that are
available in the current scopeÐones defined by the EcmaScript
standard(es),throughanexplicitimport(exports),bytheNode.js
runtime(node),orviaglobalvariables(globs).Afewnamesseem
globally available but are in fact module locals ( require). User-
definedglobalvariablesarenotprefixedwith globalthusrequiring
specialinterposition ( with).
Tab.3showsLya’scontextcharacteristicsonall30libraries(ğ 5.2).
Intermsofthenumberofobjectswrapped,themajoritycomesfrom
Node(91.1%ofallwrappers).Intermsofuniquenumberofaccesses,
for both invalid and invalid the majority comes from require;
taking their number into account, valid accesses concentrate on ES
andNode,whereas invalidones concentrate on exports.Table3:Accesscharacteristicsasafunctionofcontext. Rows:
(1)numberofLyawrappers,(2)uniquevalidaccesses( i.e.,counting
eachaccess once),(3) total valid accesses( Cf.ğ5.3).
es require exports node globs with
ObjectWrappers 215 610 853 24260 531 158
UniqueValidAccesses: 52 611 108 273 54 0
Total ValidAccesses: 52 1556 110 13982 52 0
6 DISCUSSION, LIMITATIONS,& THREATS
TO VALIDITY
This sections discusses several aspects related to the design, imple-
mentation, andevaluation of modulerecontextualization.
Runtime Environment Modifications: A key benefit of the
analysisapproachpresentedinthispaperisthatthereisnoneed
tomodifytheruntimeenvironment.Thisleadstoimportantper-
formance and compatibility benefits discussed in the evaluation
section,butinprinciplecanalsoleadtosignificantusabilityben-
efits:developersdonotneedtosetupanduseamodifiedversion
of the runtime system different and possibly divergent from the
versionofthe runtimesystemthey normally use.
SecurityImplications: On the surface, the changes to the mod-
ulesystem, e.g.,inJavaScriptorRacket,oftheanalysisapproachpre-
sentedinthispapermightseemasaffectingthesecurityproperties
oftheoverallframeworkÐincludingtheinferenceandenforcement
of specific security policies expressed in Lya. In principle, however,
these security implications are no different from the ones of apply-
ingthesechangesintheunderlyingruntimeenvironmentitself.On
thecontrary,applyingthesechangestothelower-level,memory-
unsafe, and type-unsafe language of the runtime environment im-
plementationitselfÐ i.e.,C/C++forV8Ðwouldresultinahigherrisk
ofinsecurity.We alsonotethat differentsecurity-relatedanalyses
and instrumentations are developed in response to different threat
models; thus, understanding whether a modificationÐirrespective
ofthelevelapplied, i.e.,thatofthemodulesystemortheruntime
environmentÐissecurewithrespecttoaparticularthreatmodel
wouldnotbeconclusivewithoutconsideringthespecificanalysis
orpolicyat hand.
Other analyses: Module recontextualization is well-suited for
analyses on field-granularity read/write access and/or function-
granularitycontrolflows,andespeciallyonesthatmightbeneeded
incustomer-facingproductionenvironments(nottesting)suchas
runtimesubversion,denial-of-servicedetection,andcoarse-grained
taint tracking. It is not well-suited for analyses that operate at
the granularity of language-level constructs such as if,while,
break,+etc.Ðbut could be used even then to narrow down the
searchbeforeapplyingmoreheavyweightanalyses.Wenotethat
Lya’s analysis hooks allow for Turing-complete code, including
access to state not visible to the code being analyzed but shared
among all hooks comprising an analysis. This allows analysis code
toimplementpowerfulsecurityorperformancemonitorsbeyond
the ones presentedinthe currentpaper.
Semantic preservation: Analyses that focus on measurement
preserve the semantics of the original application, because Lya’s
1211Efficient Module-Level Dynamic Analysis forDynamic LanguageswithModule Recontextualization ESEC/FSE ’21, August 23ś28, 2021,Athens,Greece
transformations do not interfere with the runtime execution of
thetransformedvalues:wrapperssimplyforward callstointernal
functions, observing but not altering the call arguments. However,
whentheintentionoftheinstrumentation istoalterthebehavior
oftheprogram, wrappersinterpose tointroduce correctivebehav-
iorsnotpresentintheoriginalprogram:atypicalexampleisthe
enforcementofsecuritypolicies e.g.,monitoringaccesstosensitive
valuesandintervening to blockunauthorizedaccesses.
Language-specific hooks: One limitation of language-specific
modulerecontextualizationisthatitrequiresdeveloperstowritethe
same analysisin asmany languagesas the applicationstheywant
toanalyze.Wenotethatconventionalanalysisframeworks,suchas
Jalangi,mayhavethispropertytoo;eachoftheseframeworksÐLya
includedÐcould expose a DSL for writing analysis-specific code
in a language-agnostic fashion. However, language-specific hooks
haveseveralsignificantbenefits:they(1)preservedeveloperknowl-
edge,expertise,libraries,andcode;and(2)leveragethesemantic
correspondencebetweenthecodeimplementingtheanalysisand
code being analyzedÐfor example, cooperative vs.preemptive con-
currency,prototype-based vs.class-basedinheritance etc.
Top-levelScripts: AlimitationoftheLyaimplementationisits
inability to analyze the library importing LyaÐusually, the top-
level program entrypoint equivalent to main.This is because Lya
cannot transform the context of the top-level script, because the
context has already been loaded and bound to the interpreted code
(and which has also been interpreted). As a result, Lya as-is cannot
be applied to analyze single-file programsÐa pattern that is not
unusualinscriptinglanguages,oftenusedforquick-and-dirtytasks.
Thesimplestworkaroundwehavefoundistocreateanauxiliary
file that(1) importsLya,andthen (2)imports (andinvokes,ifthat
isnot achievedbythe import) the single-filescript.
Outperforming Lya: The likelihood of fine-grained analysis
frameworks such as Jalangi outperforming coarse-grained anal-
ysis frameworks such as Lya, especially on more complex analyses,
is a possible threat to the validity of the results. Based on (i) our
understandingofthetechniquesinvolved,and(ii)thedataaccumu-
lated through extensive use of Lya and Jalangi, we do not foresee a
situationinwhichthiswouldoccurÐespeciallyinmorecomplex
analyses.JalangisitsatadifferentdesignpointthanLya:itoperates
onacustomPythonruntimeandataveryfinegranularityÐboth
ofwhichresultinorder-of-magnitudedifferencesinoverheadon
real analyses.
7 RELATED WORK
Aspect-orientedprogramming(AOP)isaprogrammingmodelin
whichprogrampoints(ormoregenerallyqueriesagainst thepro-
gramtrace)maptoactionstakenatthesepoints[ 17].Aspectsare
typicallyimplementedviaexplicitlanguageextensions(e.g.AspectJ
and AspectC++)and/orviamodifications tothe originallanguage
implementationor runtime system. Lya, in contrast,leveragesthe
existing dynamic loading and metaprogramming capabilities in
moderndynamic languagesto operate completelywithinunmodi-
fiedproduction languageruntimes.
ThereareseveraldynamicanalysisframeworksforJavaScript[ 5,
16,33,36]. These systems allow much more fine-grained analyses,
including tracking language-level constructs such as if,while,break,+etc.Their goal is thus different from Lya’s, which focuses
oncoarser but onlineanalysisandenforcement.
NodeProf [ 36] is a fine-grained dynamic analysis that uses AST
instrumentation to insert analyses. While it supports finer-grained
analysisthanLya,itworkswiththeunderlyingGraal[ 41]andTruf-
fle[42]APIs.Graaliscompliantwith,butdifferentfrom,Node.js,
andthus NodeProfdoes not target unmodifiedNode.js. runtimes.
Dynamic instrumentation frameworks [ 8,13,22,24,26] wrap
basicblocksofaprogramincrementallyandrightbeforeexecution,
similar in vein to how Lya wraps libraries. They operate at a much
lowerlevel(binary)thanLya,aremuchmoredetailedandheavy-
weight,andareusuallynotavailabletohigh-levellanguagesasa
language-aware library.
JavaScriptisrelatedtoWebAssembly,astandardizedsubsetof
JavaScripttargetdesignedtoserveasacompilationtarget.Thefirst
dynamicanalysisframeworkforWebAssembly,Wasabi[ 19],shares
someofLya’goalsÐ e.g.,low-effortanalysisandAPIforobservation
rather than manipulation. Contrary to Lya, Wasabi instruments
binaries statically, i.e., ahead-of-time, and aims for heavier-weight
higher-resolutioninstrumentation.
Lya draws inspiration from data-oriented JavaScript analysis
and querysystemsforthe web[ 25,27,28].Contrarytothem,Lya
appliessource-to-sourcetransformationstoaddcustommodified
contextsfor production analysisandinstrumentation.
Lyaisrelatedtoprogramfractureandrecombination(PFR)[ 1,
34], a line of work less tied to program analysis and more towards
program synthesis and automated patch generation. PFR breaks
up multiple programs into many components with the goal of
exchanging functionality between donor-donee pairs of programs.
ContrarytoPFR,Lyaoperatesonsingleprograms,avoidsbreaking
semantics,andleveragestheexistenceofcomponentswith(mostly)
explicit boundaries inthe guiseof modules.
8 CONCLUSION
Thispaperpresentedmodulerecontextualization,anefficientmodule-
leveldynamicanalysistechnique,andLya,animplementationfor
JavaScriptandRacket.Lyadecomposes,transforms,andreassem-
bles programs by combining techniques for name shadowing, con-
text re-binding, and load-time transformation of the underlying
dependency graph. It delivers order-of-magnitude performance im-
provementsoverstate-of-the-artdynamicanalysissystemswhile
supportingarangeofusefulanalyses,eachimplementedinabout
100 lines of code. Lya is availableÐforinstallationand experimen-
tation withotherapplicationsandanalysesÐasopen source:
https://github.com/andromeda/lya
ACKNOWLEDGMENTS
WethankSageGerard, SotirisIoannidis,Konstantinos Kallas,Ben Karel, MichailG.
Lagoudakis, Mary McDavitt, Jeff Perkins, and MIT CSAIL’s PAC group. The term
łrecontextualizationž was used by AniaVu in a musical context, then recontextualized
bythefirstauthor.MuchofLya’sdesignwasinformedbyinteractionswiththebroader
community. We are particularly thankful to Isaac Z. Schlueter and CJ Silverio from
npm andPetros Efstathopoulos, DanielKatz, DanielMarino, andKevin Roundyfrom
Symantec/NortonLifeLockResearchGroup.ThisworkwaspartlysupportedbyDARPA
contract no. HR00112020013, HR001120C0191,and HR001120C0155.
1212ESEC/FSE ’21, August 23ś28, 2021,Athens,Greece Nikos Vasilakis,Grigoris Ntousakis,VeitHeller, andMartinC.Rinard
REFERENCES
[1]PeterAmidon,EliDavis,SteliosSidiroglou-Douskos,andMartinRinard.2015.
Programfractureandrecombinationforefficientautomaticcodereuse.In 2015
IEEE HighPerformance ExtremeComputingConference (HPEC) . IEEE,1ś6.
[2]Anirudh Anand. 2020. Sandbox Escape: Safe Eval .https://snyk.io/vuln/SNYK-JS-
SAFEEVAL-608076
[3]Esben Andreasen, Liang Gong, Anders Mùller, Michael Pradel, Marija Selakovic,
Koushik Sen, and Cristian-Alexandru Staicu. 2017. A survey of dynamic analysis
and test generation for JavaScript. ACM Computing Surveys (CSUR) 50, 5 (2017).
[4]José P. Cambronero, Thurston H. Y. Dang, Nikos Vasilakis, Jiasi Shen, Jerry
Wu,andMartinC.Rinard.2019. ActiveLearningforSoftwareEngineering.In
Proceedings of the 2019 ACM SIGPLAN International Symposium on New Ideas,
NewParadigms,andReflectionsonProgrammingandSoftware (Athens,Greece)
(Onward! 2019) . Association for Computing Machinery, New York, NY, USA,
62ś78.https://doi.org/10.1145/3359591.3359732
[5]Laurent Christophe, Coen De Roover, and Wolfgang De Meuter. 2015. Poster:
DynamicAnalysisUsingJavaScriptProxies.In Proceedingsofthe37thInterna-
tionalConference onSoftwareEngineering-Volume 2 (Florence,Italy) (ICSE’15) .
IEEE Press, Piscataway, NJ, USA, 813ś814. http://dl.acm.org/citation.cfm?id=
2819009.2819180
[6]Scott A. Crosby and Dan S. Wallach. 2003. Denial of Service via Algorithmic
Complexity Attacks. In Proceedings of the 12th Conference on USENIX Security
Symposium-Volume12 (Washington,DC) (SSYM’03) .USENIXAssociation,USA.
[7]JamesC.Davis,EricR.Williamson,andDongyoonLee.2018. ASenseofTime
for JavaScript and Node.Js: First-Class Timeouts as a Cure for Event Handler
Poisoning. In Proceedings of the 27th USENIX Conference on Security Symposium
(Baltimore, MD, USA) (SEC’18). USENIXAssociation, USA,343ś359.
[8]HenriMaximeDemoulin,IsaacPedisich,NikosVasilakis,VincentLiu,BoonThau
Loo,andLinhThiXuanPhan.2019. DetectingAsymmetricApplication-layer
Denial-of-Service Attacks In-Flight with FineLame. In 2019 USENIX Annual Tech-
nicalConference(USENIXATC19) .USENIXAssociation,Renton,WA,693ś708.
https://www.usenix.org/conference/atc19/presentation/demoulin
[9]Webkit Developers. 2020. SunSpider 1.0.2 JavaScript Benchmark .https://webkit.
org/perf/sunspider/sunspider.html
[10]PeterDotchev.2016. Parsehangsonsomelongurls .https://github.com/garycourt/
uri-js/issues/12
[11]Ayrton Sparling et al.2018.Event-Stream, GitHub Issue 116: I don’t know what to
say.https://github.com/dominictarr/event-stream/issues/116
[12]Michael D. Ernst, Jeff H. Perkins, Philip J. Guo, Stephen McCamant, Carlos
Pacheco, Matthew S. Tschantz, and Chen Xiao. 2007. The Daikon System for
Dynamic Detection of Likely Invariants. Sci. Comput. Program. 69, 1ś3 (Dec.
2007),35ś45. https://doi.org/10.1016/j.scico.2007.01.015
[13]Cormac Flanagan and Stephen N. Freund. 2010. The RoadRunner Dynamic
Analysis Framework for Concurrent Programs. In Proceedings of the 9th ACM
SIGPLAN-SIGSOFT Workshop on Program Analysis for Software Tools and En-
gineering (Toronto, Ontario, Canada) (PASTE ’10) . Association for Computing
Machinery, NewYork, NY, USA,1ś8. https://doi.org/10.1145/1806672.1806674
[14]MichaelGreenberg,KonstantinosKallas,andNikosVasilakis.2021. UnixShell
Programming:TheNext50Years.In ProceedingsoftheWorkshoponHotTopics
inOperatingSystems (HotOS’21) .AssociationforComputingMachinery,New
York, NY, USA,104ś111. https://doi.org/10.1145/3458336.3465294
[15]Hrishikesh. 2018. Dockerhub: Jalangi Docker Container .https://hub.docker.com/
r/hrishikeshrt/jalangi
[16]MatthiasKeilandPeterThiemann.2013.EfficientDynamicAccessAnalysisUsing
JavaScriptProxies.In Proceedingsofthe9thSymposiumonDynamicLanguages
(Indianapolis, Indiana, USA) (DLS ’13). ACM, New York, NY, USA, 49ś60. https:
//doi.org/10.1145/2508168.2508176
[17]GregorKiczales,JohnLamping,AnuragMendhekar,ChrisMaeda,CristinaLopes,
Jean-Marc Loingtier, and John Irwin. 1997. Aspect-oriented programming. In
European conference onobject-orientedprogramming . Springer, 220ś242.
[18]TobiasLauinger,AbdelberiChaabane,SajjadArshad,WilliamRobertson,Christo
Wilson,andEnginKirda.2017. ThouShaltNotDependonMe:Analysingthe
Use of Outdated JavaScript Libraries onthe Web. (2017).
[19]DanielLehmannandMichaelPradel.2019. Wasabi:AFrameworkforDynami-
cally Analyzing WebAssembly. In Proceedings of the Twenty-Fourth International
ConferenceonArchitecturalSupportforProgrammingLanguagesandOperating
Systems(Providence, RI, USA) (ASPLOS ’19) . Association for Computing Machin-
ery, NewYork, NY, USA,1045ś1058. https://doi.org/10.1145/3297858.3304068
[20] SS Jeremy Long. 2015. OWASPDependencyCheck. (2015).
[21] SnykLtd.2018. minimatch@2.0.10 .https://snyk.io/test/npm/minimatch/2.0.10
[22]Chi-KeungLuk,RobertCohn,RobertMuth,HarishPatil,ArturKlauser,Geoff
Lowney, Steven Wallace, Vijay Janapa Reddi, and Kim Hazelwood. 2005. Pin:
Building Customized ProgramAnalysis Tools with DynamicInstrumentation.
InProceedingsofthe2005ACMSIGPLAN ConferenceonProgrammingLanguage
Design and Implementation (PLDI ’05) . Association for Computing Machinery,
NewYork, NY, USA,190ś200. https://doi.org/10.1145/1065010.1065034[23]MichaelMaass.2016. ATheoryandToolsforApplyingSandboxesEffectively . Ph.D.
Dissertation. Carnegie Mellon University.
[24]LukášMarek,AlexVillazón,YudiZheng,DaniloAnsaloni,WalterBinder,and
ZhengweiQi.2012. DiSL:ADomain-SpecificLanguageforBytecodeInstrumenta-
tion.InProceedingsofthe11thAnnualInternationalConferenceonAspect-Oriented
SoftwareDevelopment (AOSD’12) .AssociationforComputingMachinery,New
York, NY, USA,239ś250. https://doi.org/10.1145/2162049.2162077
[25]James Mickens, Jeremy Elson, and Jon Howell. 2010. Mugshot: Deterministic
Capture and Replay for Javascript Applications. In Proceedings of the 7th USENIX
ConferenceonNetworkedSystemsDesignandImplementation (SanJose,California)
(NSDI’10) . USENIXAssociation, USA,11.
[26]NicholasNethercoteandJulianSeward.2007. Valgrind:AFrameworkforHeavy-
weightDynamicBinaryInstrumentation. SIGPLANNot. 42,6(June2007),89ś100.
https://doi.org/10.1145/1273442.1250746
[27]Ravi Netravali, Ameesh Goyal, James Mickens, and Hari Balakrishnan. 2016. Po-
laris:Fasterpageloadsusingfine-graineddependencytracking.In 13th{USENIX}
SymposiumonNetworkedSystemsDesignand Implementation( {NSDI}16).
[28]RaviNetravaliandJamesMickens.2019. Reverb:SpeculativeDebuggingforWeb
Applications. In Proceedingsofthe ACMSymposiumonCloudComputing .
[29]Flemming Nielson, Hanne R. Nielson, and Chris Hankin. 2010. Principles of
ProgramAnalysis . SpringerPublishing Company, Incorporated.
[30]npm, Inc. 2018. Details abouttheevent-streamincident .https://blog.npmjs.org/
post/180565383195/details-about-the-event-stream-incident
[31]AndreaParodi.2020. AwesomeMicronpmPackages .https://github.com/parro-
it/awesome-micro-npm-packages
[32]NielsProvos.2003. ImprovingHostSecuritywithSystemCallPolicies.In Pro-
ceedingsofthe12thConferenceonUSENIXSecuritySymposium-Volume12 (Wash-
ington,DC) (SSYM’03) . USENIXAssociation, USA,18.
[33]Koushik Sen, Swaroop Kalasapur, Tasneem Brutch, and Simon Gibbs. 2013.
Jalangi: A Selective Record-replay and Dynamic Analysis Framework for
JavaScript.In Proceedingsofthe20139thJointMeetingonFoundationsofSoftware
Engineering (Saint Petersburg, Russia) (ESEC/FSE 2013) . ACM, New York, NY,
USA,488ś498. https://doi.org/10.1145/2491411.2491447
[34]SteliosSidiroglou-Douskos,EricLahtinen,FanLong,andMartinRinard.2015.
Automatic Error Elimination by Horizontal Code Transfer across Multiple Appli-
cations.SIGPLAN Not. 50, 6 (June 2015), 43ś54. https://doi.org/10.1145/2813885.
2737988
[35]Snyk.2016. Find,fixandmonitorforknownvulnerabilitiesinNode.jsandRuby
packages.https://snyk.io/
[36]Haiyang Sun, Daniele Bonetta, Christian Humer, and Walter Binder. 2018. Ef-
ficient Dynamic Analysis for Node.Js. In Proceedings of the 27th International
Conference on Compiler Construction (Vienna, Austria) (CC 2018) . ACM, New
York, NY, USA,196ś206. https://doi.org/10.1145/3178372.3179527
[37] The gRPC Authors. 2018. gRPC.https://grpc.io/ Accessed:2019-04-16.
[38]Nikos Vasilakis, Ben Karel, Yash Palkhiwala, John Sonchack, André DeHon, and
Jonathan M. Smith. 2019. Ignis: Scaling Distribution-Oblivious Systems with
Light-TouchDistribution.In Proceedingsofthe40thACMSIGPLANConferenceon
Programming Language Design and Implementation (Phoenix, AZ, USA) (PLDI
2019). Association for Computing Machinery, New York, NY, USA, 1010ś1026.
https://doi.org/10.1145/3314221.3314586
[39]NikosVasilakis,BenKarel,NickRoessler,NathanDautenhahn,AndréDeHon,
and Jonathan M. Smith. 2018. BreakApp: Automated, Flexible Application Com-
partmentalization. In Networked and Distributed Systems Security (San Diego,
California) (NDSS’18) .https://doi.org/10.14722/ndss.2018.23131
[40]Nikos Vasilakis, Cristian-Alexandru Staicu, Grigoris Ntousakis, Konstantinos
Kallas, Ben Karel, André DeHon, and Michael Pradel. 2021. Preventing Dynamic
Library Compromise on Node.js via RWX-Based Privilege Reduction. In Pro-
ceedingsofthe2021ACMSIGSACConferenceonComputerandCommunications
Security(Seoul,SouthKorea) (CCS’21).AssociationforComputingMachinery,
NewYork, NY, USA.
[41]Thomas Würthinger, Christian Wimmer, Christian Humer, Andreas Wöunde-
fined,LukasStadler,ChrisSeaton,GillesDuboscq,DougSimon,andMatthias
Grimmer. 2017. Practical Partial Evaluation for High-Performance Dynamic
LanguageRuntimes. SIGPLANNot. 52,6(June2017),662ś676. https://doi.org/
10.1145/3140587.3062381
[42]ThomasWürthinger,ChristianWimmer,AndreasWöundefined,LukasStadler,
Gilles Duboscq, Christian Humer, Gregor Richards, Doug Simon, and Mario Wol-
czko.2013.OneVMtoRuleThemAll.In Proceedingsofthe2013ACMInternational
SymposiumonNewIdeas,NewParadigms,andReflectionsonProgramming&Soft-
ware(Indianapolis,Indiana,USA) (Onward!2013) .AssociationforComputingMa-
chinery, New York, NY, USA, 187ś204. https://doi.org/10.1145/2509578.2509581
[43]Serdar Yegulalp. 2016. How one yanked JavaScript package wreaked
havoc.http://www.infoworld.com/article/3047177/javascript/how-one-yanked-
javascript-package-wreaked-havoc.html
[44]MarkusZimmermann,Cristian-AlexandruStaicu,CamTenny,andMichaelPradel.
2019. Smallworld with High Risks: A Study of Security Threats in the Npm
Ecosystem. In Proceedings of the 28th USENIX Conference on Security Symposium
(SantaClara, CA, USA) (SEC’19). USENIXAssociation, USA,995ś1010.
1213