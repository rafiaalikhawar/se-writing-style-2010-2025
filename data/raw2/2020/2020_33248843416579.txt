Scalable Multiple-View Analysis of Reactive Systems via
Bidirectional Model Transformations
Christos Tsigkanos
TU Wien
Vienna, AustriaNianyu Li
Peking University
Beijing, ChinaZhi Jin
Peking University
Beijing, China
Zhenjiang Hu
Peking University
Beijing, ChinaCarlo Ghezzi
Politecnico di Milano
Milano, Italy
ABSTRACT
Systematicmodel-drivendesignandearlyvalidationenableengi-
neerstoverifythatareactivesystemdoesnotviolateitsrequire-
ments before actually implementing it. Requirements may come
frommultiplestakeholders,whoareoftenconcernedwithdifferent
facets – design typically involves different experts having different
concerns and views of the system. Engineers start from a specifica-
tion which may be sourced from some domain model, while valida-tion is often done on state-transition structures that support model
checking. Two computationally expensive steps may work against
scalability: transformation from specification to state-transition
structures,andmodelchecking.Weproposeatechniquethatmakestheformerefficientandalsomakestheresultingtransitionsystemssmallenoughtobeefficientlyverified.Thetechniqueautomatically
projects the specification into submodels depending on a property
soughttobeevaluated,whichcapturessomestakeholder’sview-
point. The resulting reactive system submodel is then transformed
intoastate-transitionstructureandverified.Thetechniqueachieves
cone-of-influencereduction,byslicingatthespecificationmodel
level. Submodelsare analysis-equivalentto thecorresponding full
model. If stakeholders propose a change to a submodel based on
their own view, changes are automatically propagated to the spec-
ificationmodelandotherviewsaffected.Automatedreflectionis
achievedthanks tobidirectionalmodel transformations,ensuring
correctness. We cast our proposal in the context of graph-based
reactivesystemswhosedynamicsisdescribedbyrewritingrules.
Wedemonstrateourview-basedframeworkinpracticeonacase
study within cyber-physical systems.
ACM Reference Format:
Christos Tsigkanos, Nianyu Li, Zhi Jin, Zhenjiang Hu, and Carlo Ghezzi.
2020.ScalableMultiple-ViewAnalysisofReactiveSystemsviaBidirectional
ModelTransformations.In 35thIEEE/ACMInternationalConferenceonAuto-
mated Software Engineering (ASE ’20), September 21–25, 2020, Virtual Event,
Australia. ACM, New York, NY, USA, 11 pages. https://doi.org/10.1145/
3324884.3416579
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACMmustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ASE ’20, September 21–25, 2020, Virtual Event, Australia
© 2020 Association for Computing Machinery.
ACM ISBN 978-1-4503-6768-4/20/09...$15.00
https://doi.org/10.1145/3324884.34165791 INTRODUCTION
Design complexity for a system is high because of the many differ-
ent intertwinedfacets thatneed tobe takeninto account.Further-
more, different viewpoints (or system aspects) typically need to be
accommodated[ 37].Differentstakeholdershavedifferentconcerns,
and different experts may be involved in the design of the system,
focusing ondifferent technicalaspects. Forexample, a distributed
system may be comprised of different software components con-
nected through networks – the arrangement of components in asoftware architecture is one viewpoint, while the network theyform is another. The advisable way to dominate complexity is to
applysound softwareengineeringprinciples–namely separationof
concerns and abstraction–to system design and early validation.
We consider the case where requirements to be satisfied by a
reactive system under design are specified in terms of assertionsin a temporal logic and that the system model is encoded into aformal graph-based modeling language. To support early design
validation,thebehaviorsthatcanemergewithinthereactivesys-
tem need to be verified against the requirements. This verification
can be supported by model checking, which requires an interpreta-
tion of the reactive system specification as a state machine. Model
checkingdoesanexhaustivesearchofthestatespaceforabsenceof
illegal behaviors [ 8]. However, like any exhaustive technique, such
statemachineinterpretationanditsmodelcheckingmaybecome
impractical as models become large and complex.
To address these difficulties, this paper investigates a technique
that leverages the different properties expressing the different con-
cerns of stakeholders to automatically project the specification
model into submodels, each depending on the property under con-
sideration.Projectionsautomaticallygeneratesubmodelsthatare
equivalent to the full source model from the standpoint of the spe-
cific properties that need to be verified. Projected models, however,
are generally smaller than the full source model, and therefore
verificationviamodelchecking,whichmaybeunfeasibleforthe
full reactive system model, may becomefeasible for the submodel.
Forexample,toreasonaboutthedeploymentofcomponentsina
softwarearchitecture,weonlyneedtocareaboutstructureandcon-
nectivityoftheinfrastructureonwhichthedifferentcomponents
of an application is hosted, and not e.g., network aspects.
Onceasubmodelisderived,adesignerwhoisconcernedwith
that specific view may analyze it and correct it if problems arefound. For example, to improve performance, a database expertmay decide that a cache should be placed in front of a database
withinavirtualmachine,reflectingthatinthedeploymentmodel.
9932020 35th IEEE/ACM International Conference on Automated Software Engineering (ASE)
In our proposal, we assure that changes applied to the submodel
arereflectedbackautomaticallyinthefullmodel,andfromthere
propagated to other projections [ 29] that may also be affected and
hence would need to be re-validated. The full reactive system spec-
ificationmodelandthevarioussubmodelsforthedifferentviews
are therefore automatically kept in sync, supporting separation of
concerns. Automated reflection is achieved thanks to the use of
bidirectionalmodeltransformations[ 11].Inourexample,wewould
need to verify that adding the new database cache does not lead to
violation of other requirements (for example referring to database
networkconnectivity),whichpertaintoanotherviewofthesystem
represented by a different submodel.
We leverage results on model slicing [ 3]1and devise a practical
softwareengineeringframeworkthatcansupportmultiple-view
analyses,keepingviewsautomaticallysynchronized.Theslicingprocess [
9,19] is performed at the reactive system specification
level,leveragingthetypesthatappearinthespecificationandinthe
properties under consideration. Our technique achieves scalability
inanalysisintwodimensions:(i)slicingisperformedatthereactive
system specification level, before the (expensive) generation ofthe state-transition structure describing its evolution, and thus
(ii) model checking occurs in a considerably smaller transition
system.Thelatterachieves cone-of-influence reductiononthestate-
transition structure submitted for model checking.
Weconsidersystemsthatareformallymodeled(static)graph-
basedstructuresalongwiththeirpossible(rule-based)dynamics,
yielding reactive behaviors. In particular, the specification is in
termsofacomplexstaticstructuregivenintermsofagraph(whichmay be sourced from some domain model), and reactive dynamism
is modeled by graph transformations. Interpretation of such speci-
ficationsiscostly;althoughstate-of-the-arttechniquesandtools
(e.g.,SPIN[ 21],NuSMV[ 7])employcone-of-influencereductionfor
traditionalreactivesystems,theinterpretationstepintheexpres-
sive, graph-based reactive systems we consider involves explicitly
constructing the state space, typically amounting to graph isomor-
phismoneachstep.Insteadofslicingastate-transitionstructure
– which in our case is not available and must be constructed – we
work at the model specification level [6, 28].
Ourcontributions liewithin atechnical frameworkintegrating
fundamentaltechniquestoscale-upautomatedanalysisbybuilding
upon the cone-of-influence intuition – that often only fractions of
a model are necessary for reasoning on specific behaviors. Thus
automatic projections can support verification even in cases where
otherwiseit wouldnot befeasiblefor thefullmodel. Specifically:
•Weconcretelysupportseparationofconcernsandabstrac-
tion by advocating multiple views tailored in an automated
way for analysis of specific requirements; those enjoy
•soundmodelsynchronizationshavingtwoconstituents:(i)
correctness ofmodel projections, where projectedsubmod-
elsaresufficientforcheckingagivenrequirement,and(ii)
correctnessofsynchronizations,where modelsinvolvedare
kept consistent under the “projection” relation. Finally,
•automatedreflectionfacilitiesmakeuseofbidirectionaltrans-formations,whoseapplicationtoslicing,multiple-viewanal-
ysis and model checking was not investigated before.
1Modelslicinggeneralizestomodelstheprogramslicingtechniqueintroducedby[ 48].Our modeling approach is based on bigraphs and Bigraphical
Reactive Systems (BRS [ 36]), a graph-based modeling formalism
proposed by R. Milner able to encompass other formalisms suchas process calculi and Petri nets. Our motivations for choosingthis formalism are (i) its generality, as bigraphs have seen appli-cations on systems ranging from cloud to cyber-physical, (ii) its
well-defined semantics and hierarchical structure leading to ele-
gantalgorithmictreatment,and(iii)itsnaturalrelationtoGraph
TransformationSystems,renderingfuturepracticaladoptionand
tool support easier. Following a model-driven approach, otherdomain specific models can derive the BRS specification models
we target. To provide concrete evidence of the proposed model-
basedapproach,wedemonstratethatthegoalofmakinganalysis
scalablethrough modelprojections canbe achievedinpractice on
a characteristic case study within cyber-physical systems where
multiple-view analysis is paramount to the design process.
Therestofthepaperisstructuredasfollows.Sec.2providesnec-
essary background, while Sec. 3 gives an overview of the proposed
approach.Sec.4introducesatype-basedapproachtoautomatically
generaterequirementviews,andSec.5describesmodelsynchro-
nization.Sec.6providesanassessmentoveracasestudy.Related
work is considered in Sec. 7, and Sec. 8 concludes the paper.
2 BACKGROUND
Inthissection,westartwithasimplescenarioservingasarunning
examplethroughoutthepaper.Subsequently,wesuccinctlyillus-
trate how to model graph-based structure (Sec. 2.1) and dynamics
(Sec. 2.2), i.e., possible ways in which the system may change over
timethroughactions.Then,weshow(Sec.2.3)howtheresulting
reactive system can be interpreted as a state machine, upon which
requirements may be verified by model checking.
RunningExample. Considerthecasewherearesourceconstrained
mobilerobotpatrols aspatialdomainto locateintruders.Thespa-tial domain is divided intoareas upon which a local edgeserver is
located,supportingrobotstoperformcomputationally-intensive
tasks (e.g., image recognition, to visually detect intruders) with-
out the latency that a cloud connection would incur. Computation
offloadingisperformedonVirtualMachines(VMs),towhichthe
edgeserveristhehost.Astherobotmoveswithinareas,aVMmayneedtobemigratedtotherespectiveserverlocatedinanotherarea.
To this end, network gateways may connect edge servers, through
whichmigrationoccurs.Theubiquitoussystemshouldfulfilltwo
requirements:(RQ1)anedgeservershouldnotbeidle,ifthereisanother one connected to it hosting 3 VMs (load balancing ), and
(RQ2) if there exists an intruder in the system, the robot must keep
surveying areas “one”, “two” and “three” in sequence, one after the
other (in a sequenced patrolling [34] pattern).
Notice that the example describes a simple reactive system. A
model of the system can be constructed, which represents struc-ture, entities and their relations within the scenario, as well as
dynamic evolution due toactions. Subsequently, interpretation as
astate-transitionmodelanditsverificationintheformofmodel
checkingcanbeusedtocheckiftherequirementshold.However,
interpretation and verification of large models may be impractical.Moreover, multiple stakeholders (e.g., robotic experts, deployment
engineers)mayhavedifferentinterestsinthesystem,soseparation
of concerns is highly desirable. Following such a principle implies
994supporting analysis on each concern separately and abstracting
away details that are irrelevant.
2.1 Modeling with Bigraphs
Modeling systems within software engineering is certainly a wide
theme. Our formalism of choice is bigraphs [ 36], a graph-based
processmeta-calculusthatisabletocapturewidelydifferentsys-
tems, while featuring interesting properties. A bigraph consists of
two graphs. A place graph is a forest, a set of trees defined over
a set of nodes, while a link graph is a hypergraph over the same
set of nodes and a set of edges each linking an arbitrary number
of nodes. Connections of an edge with its nodes are called ports.
Place and link graphs are orthogonal, and edges between nodes
cancrosslocalityboundaries.Nodesthatappearinabigraphare
typed2. What follows is an informal presentation of bigraphs as
used in the scope of this paper, recalling definitions in [36, 45].
P.Q Nestinд (Pcontains Q)
P|Q Juxtapositionof nodes
−i Sitenumbered i
Kw Nodewithtype Khavinдports w
W/bardblR Juxtapositionof biдraphs(1a)
(1b)
(1c)
(1d)
(1e)
Bigraphs can be described through a rigorous graphical representa-
tionaswellasequivalentalgebraicexpressions(Formulae1a-1e). P,
Q,and Karenamesthatdefineanode’stype.Nodescanbestruc-
tured hierarchically;the containment relationshipis expressedin
Formula 1a and is graphically described by nesting. Bigraphs may
be placed at the same hierarchical structure level, as shown in For-
mula 1b. Additionally, bigraphs can contain sites (Formula 1c) that
canbeusedtodenoteplaceholders,i.e.,thepresenceofunspecified
nodes,graphicallyrepresentedasshadedboxes.Absenceofasite
signifies no unspecified nodes in that part of the hierarchy. Eachnode type (“control”) can be associated with a number of named
ports. In Formula 1d the node identified by type Khas port names
w; ports are graphically represented as black bullets. Bigraphs can
be contained in roots that delimit different hierarchical structures,
thus being juxtaposed. In Formula 1e WandRare different roots.
An instance of the example system is illustrated in Fig. 1, where
entitiessuchasrobotsandserversarewithinthreeareas.Notice
howareasarelinkedtonamesidentifyingthem,andlinksofservers
tothenetworkgatewaytraversethehierarchies(i.e.,thenestingofnodes).Sitesdenoteunspecifiednodes.Usingthealgebraicnotation,
the bigraph of Fig. 1 can be represented as in Formula 2.
Area 1.(Robot|Server lnk.(VM|VM)) | Network lnk
|Area 2.(Intruder |Server lnk.VM|−1)|Area 3.(Intruder |Server lnk|−0)(2)
Formally, a bigraph arises from two superimposed relations. Let
VBbe a set of nodes and Kthe set of types of nodes. Let ctrlB:
VB→Kbe a typing function, called type map. A place graph is
a tupleBP=(VB,ctrlB,prntB,K)whereprntB:VB→VBis an
acyclicparentmappingmodelingnesting.A linkgraph isatuple
BL=(VB,EB,ctrlB,linkB,K)whereEBis a finite set of edges and
linkB:EB→2VBis a link mapping assigning each edge the set of
nodeswhichareconnectedbythatedge.Then,abigraph Bconsists
ofBPandBL:B=(VB,EB,ctrlB,prntB,linkB,K). Note that for B
of Formula 2, K={Robot,VM,Area...}.
2Types are called controlsin bigraphical terminology.AreaServerVMRobot
NetworkServerVM
Intruder0
Area Area1
2
3 10
ServerVM
lnk
Intruder
Figure 1: Bigraphical model of a ubiquitous system.
2.2 Modeling Dynamics with BRS
A Bigraphical Reactive System (BRS) [ 36] captures dynamic be-
havior. A BRS describes possible ways with which a bigraphical
structurecanevolvethroughapplicationoftransformationrules
–calledreactionrules– which selectively rewrite parts of a bigraph.
Reaction rules have the general form of R→R/prime, where the left-
hand-side R(theredex)representsapatterntobefoundinabigraph,
and a right-hand-side R/prime(thereactum) will replace a matched por-
tion upon application of the reaction. RandR/primeare also bigraphs.
Replacement of a subgraph matching a reaction rule redex with
the subgraph defined by the reactum occurs in a fashion similar to
graph rewriting[ 10], ina procedure called bigraph matching [36].
Rewritingproceduresarecomputationallycostly,astheyareequiv-
alent to graph isomorphism.
Utilizingreactionrules,dynamicsoftheexamplescenariocan
be modeled. The possible changes entail mobile robots changing
areas(move ),VMsmigratingfromconnectedservers(migrate ),and
therobotsuccessfullycapturinganintruder(capture ),modeledas
follows (a ,b,care variables ranging over named ports):
(move) Area a.(Robot|−0)|Area b.(−1)→Area a.(−0)|Area b.(Robot|−1)
(migrate) Server lnk.(VM|−0)) /bardblNetwork lnk/bardblServer lnk.(−1))
→Server lnk.(−0)) /bardblNetwork lnk/bardblServer lnk.(VM lnk|−1))
(capture) Area a.(Robot|Intruder |−0)→Area a.(Robot|−0)
2.3 Analysis of Reactive Behaviors
Given an initial configuration specified by a bigraph and a set of
reaction rules, new configurations may be generated by repeatedly
applyingreactions,andpossibleevolutionscanbedescribedbya
state-transitionstructure[ 45].Thisisa(doubly) LabelledTransition
System[8] (dLTS) L, defined as a tuple /angbracketleftS,i,A,AP,→,L/angbracketright, where:
•Sis a set of states describing configurations;
•i∈Sis the initial state;
•Ais a set of transition labels;
•AP is a set of atomic propositions;
•→ ⊆S×A×Sisa3-adicrelationoflabelledtransitions.If
p,q∈Sandα∈A,(p,α,q)∈ →is written as pα→q.
•L:S→2APis a function that labels each state with the set
of propositions that are true in that state.
ABRSspecificationcanbetranslatedintoanequivalentdLTS.In-
tuitively,givenaninitialconfigurationandasetofreactionrules,adLTScanbegeneratedbymappingbigraphicalconfigurationsontostates.Thesetofofpropositions
AP’thatlabelastate( p∈S)canbe
systematicallygeneratedbydeclarativelyencodingthecorrespond-
ingbigraphconfigurationofthestate.Transitionscorrespondto
995Area 1.(Robot|- 2)
Area 1.(Server lnk.(VM|VM)|Robot)
Area 2.(Intruder|Server lnk.VM|- 1)
Area 3.(Server lnk|Intruder|- 0) …s0 s1 s2✓ ×Area 2.(Robot|- 2)✓ Area 1.(Robot|- 2)
move moveArea 1.(Server lnk.(VM|VM))
Area 2.(Robot|Intruder|- 1) 
Area 3.(Server lnk|Intruder|- 0) Area 1.(Server lnk.(VM|VM)|Robot)
Area 2.(Intruder|Server lnk.VM|- 1)
Area 3.(Server lnk|Intruder|- 0) …
... ... ...
Figure 2: Evaluation of a property on a fragment of L.
applicationsofreactionrulesthatleadtonewbigraphicalconfigura-
tionsandtheirlabelsrecordactionsmodeledbyrules.Anexecutionfragment
ρofLisa(possiblyinfinite)alternatingsequenceofstates
si∈Sand transition labels αi∈A, written as:
ρ=s0α1→s1α2→...sn−1αn→sn...
such that siαi+1→si+1for alli≥0.
Behaviorofthesystemovertime(i.e.,executionfragments ρ)can
bereasoneduponwithatemporallogic.WeadoptLinearTemporalLogic[
8]withoutthenextoperator( LTLx[24]),definedasfollows:
ϕ::=true|α|¬ϕ|ϕ∨ϕ|ϕUϕ.
Propositions of the logic are bigraphs, interpreted over states of
L. Such bigraphs are termed parametric patterns, since sites can
be used to reason about unspecified nodes, and variables (e.g., a)
can match port names – for instance, Area a.(−0)would match
all areas of the model of Fig. 1. The properties modeled by LTLx
express behavioral constraints and are interpreted over execution
fragmentsof L.Intuitively,theformula ϕ1Uϕ2expressesthat ϕ1
istrueuntil ϕ2becomestrue;wecanderiveadditionalonessuch
as/diamondmathϕ=true Uϕ("eventually")and /squareϕ=¬/diamondmath¬ϕ("always").Then,
requirementsRQ1andRQ2oftherunningexamplecanbeformally
specified by Formulae 4b and 4a:
RQ1: /square¬(Server lnk/bardblNetwork lnk/bardblServer lnk.(VM|VM|VM))
RQ2: /square(Intruder →/square(/diamondmath(Area 1.(Robot|−1)∧
∧/diamondmath( Area 2.(Robot|−2))∧ /diamondmath(Area 3.(Robot|−3)))))(4a)
(4b)
LTLxproperties over bigraphical propositions (as patterns) as
previously defined may be readily checked upon dLTS L. For an
executionfragmentof LandanLTLxproperty,evaluationofthe
property entails i) finding truth values of bigraphical propositions
on states and subsequently ii) verifying the property’s temporal
componentoverthesequenceofstatesinthefragment.Toevaluate
bigraphicalpatternsonstates,matching[ 36]isused,while LTLx
properties are evaluated using established verification methods [ 8].
The restriction to LTLxis a known strategy [ 14,30] to enable
verification optimization techniques without significantly affecting
expressiveness of the language for practical considerations [3].
Fig.2showsanexecutionfragmentof L.Bigraphicalpatterns
areevaluatedineverystate,whiletemporalpropertiesareevalu-
ated over the sequence; in states s0ands1, patterns (shown above)
Area 1.(Robot|−0)andArea 2.(Robot|−0)arerespectivelytrue(and
the property holds true); in s1, the robot moves back to Area 1, ren-
dering the patrolling property RQ2 false.
3 VIEW-BASED REASONING FRAMEWORK
Given a reactive system specification comprising of an initial con-
figurationandasetofrewritingrules,analysisintheformofmodel
checking can be performed to check that possible behaviors do not
violate the stated requirements. Traditional analysis (shown in the
 R2
...Analysis
P
Properties
PropertyAnalysis
Dynamics 
Subset
Property Dynamics 
Subset...
R
Analysis
DynamicsSource ModelView Model
Initial Con ﬁgurationView
ConﬁgurationView
ConﬁgurationView Model
Synchronization
Synchronization P2
 R1  P1
Figure 3: Framework for Multiple-View Reasoning.
lower part of Fig. 3) would entail considering the entire model and
set of rules, generating a state-transition structure by exploring
application of all rules, and finally performing model checking for
eachpropertyencodingadifferentrequirement.Thecornerstone
of our approach, shown in Fig. 3, is that for each property, subsets
of both the initial configuration and the set of rules are taken into
account instead. This follows the spirit of slicing techniques as
applicabletomodels(i.e.,notprograms),wheretheslicingcriterion
is a temporal logic formula (i.e., and not program variables).
The benefits of the proposed approach are twofold: (i) slicing is
performedatthesystemspecificationlevel[ 4,18],beforethe(com-
putationally expensive) generation of the state-transition structure
describingitsevolution,andthus(ii)thesizeofthemodelsubmittedformodelcheckingisreducedandtailoredtoformalanalysisofeach
requirement.Theresultisknownasachievingcone-of-influence
reduction, which in this case has two dimensions. First, the size
of each state can bereduced. Recall that each stateis modeled by
a set of propositions, and in our case propositions declaratively
specifyalldetails ofanygivenbigraphical configuration.Ourslic-
ing approach automatically prunes all details that do not affect the
requirementunderconsideration.Second,the numberoftransitions
exiting each state (fan-out) can also be reduced.
The proposed approach not only supports effective mechanical
verification but is also beneficial to designers in their reasoning
about the current system. By projecting the full model into a more
concise one which is equivalent with respect to satisfaction of a
given requirement, it supports separation of concerns and abstrac-
tion.Ithelpsfocusingoneachconcernseparatelyandautomatically
factoring away details that are irrelevant to a given requirement.
For example, the robotic expert of the example system (Sec. 2) can
focus her analysis on robotic mission aspects that affect the re-
spective requirement, while the expert on load balancing can focus
onothers(inthiscase,VMmigration).Suchsystemconcernsare
capturedindifferentanalyzablepropertiesaswellasappropriate
subsets of the model and dynamics (upper part of Fig. 3).
996Finally,thetechniqueisrootedintothetheoryof bidirectional
transformations,whichguaranteessynchronizationbetweenmod-
els,consistency,andwell-behavedness.AsillustratedinFig.3,in
caseofchangeinoneoftheviews,changesareautomaticallyprop-
agatedbothtothefullmodelandotherviews,triggeringanalysis
if required. For our example scenario, if e.g., the robotic expert
changes the relevant submodel due to verification results of re-
quirementRQ2,analysiscanbetriggeredagainonthesubmodel
needed to check RQ1 as well.
4 PROPERTY-DRIVEN VIEW GENERATION
Letussupposethatareactivesystemspecificationmodelisgivenby
providing a bigraph describing an initial configuration (e.g., Fig. 1)
andasetofreactionrulesdescribingdynamics(asperSec.2.2).Thissectiondescribeshowa viewmodel canbegeneratedautomatically,
givenaproperty.Theapproachisrequirement-drivenandgeneratesaviewmodel,whichisaprojectionofthefullmodel.Theprojected
modelcomprisesaninitialconfigurationthatisasubgraphofthe
original, as well as a subset of the original rules. The description is
illustrated by referring to the running example. We first introduce
an algorithm that generates a view model for a given property
(Sec.4.1).Subsequently,Sec.4.2outlinestheproofofcorrectness
based on previous results achieved within model slicing.
4.1 Views through Type-based Transformation
The algorithm for view model generation has as input a full model
M–consistingofabigraph CandasetRofreactionrulesdescribing
dynamics – as well as an LTLxproperty Pspecifying a require-
ment.Theoutputisa projection ofthefullmodelintoasubmodel
comprising (i) a subgraph C/primeofCand (ii) a subset R/primeofRsuch
that satisfaction of Pon the full model can be proved equivalently
bycheckingthesatisfactionof Pontheviewmodel.Wedefinea
modeltransformationwherethe sourcemodelisthefullmodeland
thetargetmodelisthe viewmodel.Theproposedtransformationis
embeddedintoanimplementationthatsupports bidirectionalmodel
transformations, as discussed in Sec. 5.
A model that contains exactly what is relevant to check satis-
factionofarequirementandisminimal(an optimalmodel)could
be carefully hand-crafted in many cases. However , manual con-
struction is non-trivial and prone to human error. Instead, we aim
for an automatic technique to generate model views per require-
ment,thatare provablyequivalentwithrespectto analysisofthe
requirement on the source model. In the running example, intu-
itivelyonecanobservethatverificationofrequirement RQ2does
notrequireconsideringVMs:includingorexcludingthe migrate
rule in the dynamic analysis does not affect satisfaction or viola-
tion of that requirement. The presented algorithm utilizes types to
generateviews,byexploitingthecorrespondencebetweentypes
appearinginrequirements,initialconfiguration,anddynamics.The
algorithm does not guarantee generation of a minimal view model;
moreonthispointisdiscussedinSec.8.Recallthatinabigraphical
model, different kinds of entities are reflected in types (controls )o f
the bigraphical representation. A requirement may concern enti-ties having only certain types; consider Formula 4b, which onlypredicates about
AreaandRobotandIntrudernode types. Thus,
our approach to view generation builds on the basic intuition of
non-inclusion of node types that are not relevant to a requirement.Algorithm 1 Computing Types and Rules for a View Model.
Input:
P– Bigraphical temporal property
R– Set of reaction rules
Output:
PropTypes – Set of types needed for P
RP– Set of rules needed for P
1:PropTypes ⇐∅;RP⇐∅
2:for allp∈prop(P)do
3:PropTypes ⇐PropTypes ∪k(p)
4:end for
5:repeat
6:PropTypes/prime⇐PropTypes
7: for allr∈Rdo
8: ifk(rhs(r))∩PropTypes /nequal∅then
9: PropTypes ⇐PropTypes ∪k(lhs(r))
10: RP⇐{r}∪RP
11: end if
12: end for
13:untilPropTypes/prime==PropTypes
Algorithm1computesthesetoftypes PropTypes neededtoeval-
uateaproperty P,givena setofreactionrules R.Italso computes
a subsetRPofR, which includes the reaction rules we need to con-
sidertoevaluateproperty P.Thealgorithmusestwohelpfunctions,
kandprop.Function kmapsagivenbigraphintothesetoftypesof
its nodes. Recall that a temporal property has bigraphical patterns
as propositions; function propmaps a given property into all bi-
graphsfoundaspropositionsintheproperty(i.e.,discardingmodal
temporal operators). The algorithm iteratively computes the set of
types needed for the evaluation of the property, by considering the
left-hand-sidesandright-hand-sidesofreactionrules.Theresultis a subset of types that can be used to reduce the source model.In addition, the algorithm produces a subset of rules relevant to
analysis of the property.
The algorithm starts by initializing PropTypes with all node
typesappearinginbigraphicalpropositionsoftheproperty(lines2-3).ForthepropertyspecifyingRQ1,thealgorithmwillincludetypes
{Server,Network ,VM}. Rules need to be also taken into account
since sequences representing change of truth values of proposi-tions might affect satisfaction or violation of bigraphical propo-sitions within
P. To this end, every rule rin the set of reaction
rulesRneeds to be checked whether it is related to P. Specifi-
cally, while iterating through reaction rules (line 6), if the right-
hand-sideofarulehastypesincommonwith PropTypes (line9),
the types appearing in the left-hand-side of the rule are also in-cluded in
PropTypes (line 10). For example, for the rule migrate,
k(rhs(migrate))∩ PropTypes ={Server,Network ,VM}andk(lhs(
migrate)) ={Server,Network ,VM};thus,notypewillbeaddition-
ally included to PropTypes as they have already been there. The
algorithm continues to iterate until reaching a fixed point, i.e., the
setPropTypes does not change (line 12).
To generate a view model MP=<CP,RP>from a model
M=<C,R>, Algorithm 1 is used to produce RPand the set
oftypesPropTypes neededforevaluationof P.Thelatteristhen
used to generate a projected configuration CPby pruning the con-
figuration Cas described in Algorithm 2. We take advantage of the
fact that configurations are modeled as bigraphs, whose nodes are
997Algorithm 2 Generating a View Model.
pruneNode :(N,PropTypes)→ N/prime
N,N/primeare nodes of the form Q.(NL)
whereNLis a list of nodes with the recursive form N|NL
1:NL/prime⇐pruneNodeList(NL, PropTypes )
2:ifk(Q)∩PropTypes ≡∅andNL/primeis∅then
3:N/prime⇐null
4:else
5:N/prime⇐Q.(NL/prime)
6:end if
pruneNodeList :(NL,PropTypes)→NL/prime
1:ifNL/nequal∅and in the form of Nhead|NLtailthen
2:N/prime
head⇐pruneNode(N head,PropTypes )
3:NL/prime⇐N/prime
head|pruneNodeList(NL tail,PropTypes )
4:end if
arrangedhierarchically(theplacegraph,Sec.2).Foreachhierarchi-
cal layer, there might be several nodes (e.g., different Areas) which
are consideredasa list.The objectiveof pruneNode isto prunea
node, while pruneNodeList handles the list of nodes in order. In
pruneNode , the function pruneNodeList is invoked first to handle
nodes contained in that node (e.g., RobotandServerare contained
in an Area). The node shall be deleted if the control of that node is
not found in PropTypes and none of the nodes contained in it does
(line2,i.e., NL/primeisnull).Generationoftheviewconfigurationneeds
to ensure that: i) all nodes of the source configuration that have
typesinPropTypes areincludedintheproducedconfiguration,and
ii) all their ascendants in the tree structure are also included, to
ensure that structure is preserved. Sites are treated as having a
specialtype,andarealwaysincludedintheproducedconfiguration
– since they are placeholders for unspecified nodes. Fig. 4 presents
the view models (initial configuration and set of rules) produced
for requirements RQ1 and RQ2.
4.2 Correctness of Model Projections
Projection of a reactive system source model into a view model for
agivenproperty Pshouldyieldasubmodelequivalenttothefull
model as far as property Pis concerned. This section provides the
outline of a formal proof of this equivalence, leveraging theoretical
results in model slicing achieved in the past [3, 24, 35].
A view model produced by the method described in Sec. 4.1
satisfiesPifandonly ifthesourcemodelsatisfies Paswell.Since
Pisatemporalproperty,theequivalencehastobeshownacross
executionfragments.Theproofoutlineleveragesinsensitiveness
tostutterwithin temporal logic; this means that a property can
not distinguish between fragments that differ only by stuttering,i.e., finite repetition of similar states. Insensitiveness to stutter is
a prerequisite for widely used techniques in software engineering
such as partial order reduction [ 41] and model slicing [ 3]. Recall
thatpropertyspecificationoccurswithin LTLx,characterizedby
absence of the next-time LTLoperator. The next operator is sensi-
tive to finite stuttering, and a view projection essentially works by
projectingabehaviorand collapsingsequencesofstutteredstates.
AnyLTLxformula describes a stutter-invariant property [42].
Given a model Mconsisting of a bigraph Cdescribing an initial
configuration, a set of reaction rules Rdescribing dynamics and
a property P, a view model MP=<CP,RP>, whereRP⊆R,i sAreaServerVM
NetworkServerVM
0
Area
Area1
2
3
1
ServerVM
lnk0
(a)<CP1,{miдrate }>.
AreaRobot Intruder0
AreaArea1
23
1
Intruder0
(b)<CP2,{move ,capture }>.
Figure 4: View models generated for RQ1 (a) and RQ2 (b).Note the absence of Robot in C
P1, and of VMs in CP2.
produced. Initially we introduce the concept of a canonical form
ofexecutionfragments,thenweshowthatthereisa bisimulation
relationbetween the M’s execution fragments and MP’s execution
fragments. The proof outline consists of three steps. First, we show
that any execution fragment affecting Pobtained from the full
modelMhas an equivalent canonical execution fragment where
transition labels only belong to RP. We call these fragments canon-
icalbecause they are minimal with respect to P. In our context,
equivalentsignifiesthatproperty Peitherholdsordoesnotholdfor
bothexecutionfragments[ 3].Second,weshowthatforeachcanon-
ical execution fragment obtained from the full model Mthere is an
executionfragmentintheviewmodel MPwhichisP-equivalent.
Third, we show that for each execution fragment obtained from
the submodel MPthere exists a canonical form fragment obtained
from<C,R>which is equivalent.
Canonicalfragmentequivalenceinthefullmodel. Considerthe
following fragment obtained from the full model M=<C,R>,
whichcapturesapplicationofrules αi∈Afromtheinitialstate s0:
s0α1→s1α2→...sn−1αn→sn... (5)
The basic intuition behind the canonical form execution fragment
isthatifαj∈R\RP,αjdoesnotmodifyanypartofthebigraphof
statesjthatwillaffecttheevaluationoftheproperty.Anexecution
fragmentobtainedfrom <C,R>maycontainlabelscorrespond-
ing to rules from both RPandR\RPintermixed. To obtain the
correspondingcanonicalformfragment,anysub-sequencesoftran-sitions with labels in
R\RPcan be dropped. For example, consider
the case where in execution fragment (5), aj∈RPfor all 1≤j<i
andj≥i+k,andaj∈R\RPforalli≤j<i+k.Thecorresponding
canonical form fragment is:
s0α1...αi−1−−−−−−−−→siαi+k...αn−−−−−−−−→sn... (6)
Recallthatrulesin R\RPdonotaffectsatisfactionof P.Forany
executionfragment,one(andonlyone)canonicalformexists.Itcanbeeasilyshownthatthecanonicalfragmentisindeedanexecution
fragment of the full model.
Source-View fragment equivalence. As we observed, given any
execution fragment of M, we can produce a canonical execution
998fragment where all transitions are labeled with rules in RP:
s0α1→s1...αn→sn... (7)
Forthecanonicalexecutionfragment(7),byapplyingthepro-
cedure described in Sec. 4.1 on bigraphs that label states s0,s1...sn
to eliminate from the configurations all nodes whose types do not
affect property P, we obtain the following execution fragment:
sP0α1→sP1...αn→sPn... (8)
where the atomic proposition labeling state sP0, is a bigraph CPand for all i≥1,αi∈RPand the atomic proposition labeling state
sPiis a bigraph obtained from the one labeling sPi−1through the
application of the rule αi. Fragment (8) is an execution fragment of
MPandisequivalenttofragment(7).Thus,foreachexecutionfrag-
mentobtainedfromthe fullmodelthereisanexecutionfragment
in the view model which is equivalent with respect to property P.
Canonical fragment equivalence in the view model. Consider any
executionfragmentobtainedfrom MP=<CP,RP>,forexample
fragment (8). If we apply the same sequence of transitions αifor
alli≥1 to an initial state labeled by C, we obtain a canonical
execution fragment of M that is equivalent to fragment (8).
5 MODEL SYNCHRONIZATION
We have shown that a view model can be generated from a source
modelaccordingtoaspecificrequirement.However,aclassicprob-
lem in this view-based approach is how to reflect changes from the
viewtothesourcemodel.Ifanupdateismadetotheviewmodel
afterverification(e.g.,tocounteractarequirementviolationfound),
we should be able to reflect it to the source model, and from there
tootherviewmodelsthatmightalsobeaffected.Inthissection,we
show how to solve this problem by designing and implementing a
bidirectionaltransformation(BX)forsynchronizingthesourceand
the view models to correctly propagate changes between them.
Without loss of generality, the following description only dis-
cusseshowchangesinviewconfigurationsmayaffectmodelsyn-
chronizations(andviceversa).Changestodynamicscanbehandled
similarly. Precisely, we assume the set PropTypes for a view not to
change,andhencealsothesetofdynamicrules.Thus,whenever
weusetheterm modelinthissection,itstandsforonlythestatic
part (i.e., the bigraphical configuration ).
5.1 A BX Algorithm
Bidirectional transformation (BX) [ 11,17] is a useful mechanism
fordatasynchronization,whichwillbeusedforsynchronizationofsourceandviewmodels.ABXconsistsofapairoftransformations
дetandput.Theforwardtransformation дet(s)isusedtoproduce
atargetview vfromasource s,whilethe putbacktransformation
put(s,v)is used to reflect updates on the view vto the source s.
Thesetwotransformationsshouldbe well-behaved inthesensethat
they satisfy the following round-tripping laws:
put(s,дet(s))=sGetPut
дet(put(s,v))=vPutGet
The GetPut property requires that no change of the view shall be
reflected as no change of the source, while the PutGet propertyrequiresallchangesintheviewtobecompletelyreflectedtotheServerVMRobot
Area2
1
sourceget
putPropTypes
VM
ServerServerVM
Area2
1
view
Server
Area2
1migrate
view'ServerRobot
Area2
1
source'
Figure 5: Type-based Bidirectional Model Transformation.
Algorithm 3 Updating a View Model.
updateNode :(Ns,Nv,PropTypes)→N/primes
Ns,Nv,N/primesare nodes of the form Q.(NL).
1:Q/primes⇐update attributes of QswithQv
2:NL/primes⇐updateNodeList(NL s,NLv,PropTypes )
updateNodeList :(NL s,NLv,PropTypes)→NL/primes
NLs,NLv,NLs/primeare lists of nodes of the recursive form N|NL.
1:ifbothNLsandNLvare∅then
2:End Update
3:else ifmatchNsheadwithNvheadsuccessfully then
4:Nshead/prime⇐updateNode(N shead,Nvhead,PropTypes )
5:else ifk(Nshead)∩PropTypes ≡∅then
6:Nshead/prime⇐Nshead
7:else ifk(Nshead)∩PropTypes /nequal∅then
8:Nshead/prime⇐delete node (contained in) NsheadinPropTypes
9:else ifNLsis∅then
10:NLs/prime⇐NLv
11:else
12: raise exception(view NLvis illegal)
13:end if
14:NLstail/prime⇐updateNodeList(NL stail,NLvtail,PropTypes )
sourcesothatthechangedviewcanbecomputedagainbyapplying
the forward transformation to the updated source.
To use BX for synchronization, we need to develop a pair of
transformations between source and view models. The forward
transformation дetisstraightforward,whichistheviewgeneration
function (Sec. 4.1) when a set of types PropTypes is given:
дet(s)=pruneNode( s,propTypes ).
Whatisnotsoobvious,ishowtodefinethecorresponding putthat
can be paired with getto form a BX satisfying the GetPut and
PutGet properties. Before defining put, let us consider a concrete
example to see what this BX should be. As shown in Fig. 5 for the
running example and the load balancing requirement RQ1, theget
producesthe viewmodelwiththe types of VMandServer.When
theviewischangedto view’(VMismigrated),wehopetouse putto
propagate this change back to source, yielding the modified source’
(VMmovesawaywhiletherestofthethemodelremainsthesame).
Since our getis a projection, its corresponding putshould be an
embeddingoftheviewelementsintothesourcemodel.Todefine
put, we exploit the hierarchical tree structures of bigraphs echoing
the previous view generation transformation strategy, and use the
view to update the source layer by layer; putis defined by:
999put(s,v)=updateNode( s,v,PropTypes ),
where updateNode , informally defined by Algorithm 3, replaces
the attributes (i.e., ports) of the source with the information in
the view, and then invokes function updateNodeList to handle
nodes contained in the source node. Function updateNodeList
dealswiththesituationwhereboththesourceandviewarealist
ofnodes.Thesimpleststrategyforupdatingalistisposition-based
alignment,whichmatchesthesourceandviewelementsbytheir
positionsinthelists.Thereare6cases:1)bothsourceandvieware
emptyandwereachtheendofexecution;2)thefirstnodeofthe
source can be matched with the first of the view (e.g., Serverin the
sourcecanbematchedwith Serverintheview),and updateNode is
calledtoupdatethisnode;3)controlsinthefirstnode(includingallnodescontainedinit)ofthesourcearenotfoundin
PropTypes (i.e.,
noinformationshallbeextractedtotheview),inwhichcasethis
elementofthesourcewillremainthesame;4)somecontrolsinthefirstelementbelongto
PropTypes ,thenthisnodeanditscontaining
ones with controls found in PropTypes are deleted; 5) the source is
empty but the viewis not (i.e., the source listhas fewer elements);
thenewsourcenodeshavetobecreated;6)otherwisetheviewis
notlegal,andthecomputationfailstoguaranteewell-behavedness.
Later, updateNodeList will be invoked recursively to manage the
rest of the source and view lists. This putupdate strategy can be
pairedwiththe getdefinedinSec.4.1toformawell-behavedBX,
though the formal proof is omitted in this paper.
5.2 Implementing BX using BiGUL
The transformations getandputpresented in Sec. 5.1 could be
manually implemented. Although this solution provides the pro-grammer with full control in two directions and can be realized
usingstandardprogramminglanguages,maintenanceeffortisre-
quired to keep consistency between getandputif one of them
is changed; even a small modification to one of the transforma-
tions would require redefinition of the other. Moreover, the pair of
transformations should be proven to be correct and well-behaved.
To this end, we adopt BiGUL [ 25], a putback-based bidirectional
programminglanguage, whereone isonly requiredtoimplement
theputtransformation instead of both getandput. This is because
getis uniquely determined by putbased on well-behavedness [ 22].
InBiGUL,oncea puttransformationisgiven,thecorresponding get
isautomaticallyderived.Wewillnotdiveintoadetailedexplanation
ofput, as its semantics are illustrated in Algorithm 3. Interestingly,
fromthat putalgorithm,BiGULcanautomaticallyderivethe get,
withthesamesemanticsasAlgorithm2.Theinterestedreaderis
referredto[ 27]fortheunderlyingmechanismofBiGUL,andtothe
online appendix for the implementation [1].
Use of Synchronization. Synchronization between views is useful
for model maintenance purposes; recall the motivational example.
Assume that the cloud expert decides to improve load balancing by
dividingtheavailableareainto4areas,placinganedgeserverin
eachtoincreasesystemcapacity.Tothisend,shechangesthecloud
view and proceeds to verify RQ1. The source and the robot view
areupdatedautomatically,andverificationcanbeperformedfor
RQ2 as well – notice that in this case, the robot view has changed
as another area hasappeared. Observe that RQ2 can beviolated ifthe sequenced patrolling behaviour is not maintained.6 EVALUATION
To provide tool support for our multiple-view analysis framework,
werealizedaprototypicalviewgenerationandtransformationtool
based on BiGUL [ 26], which is freely available [ 1]. Thereupon, we
demonstratetheframeworkinpracticeoveracharacteristiccase
sourced from the domain of cyber-physical systems; experimental
setup and results obtained are subsequently presented. We high-light a typical design scenario where multiple-view analysis and
synchronizationthroughbidirectionaltransformationisparamount
to the design process and conclude with a discussion.
6.1 Multiple-Views in a Smart City Design
The prevalence of sensors, networks and devices has led to the
emergenceofsmarturbanenvironments. Weconsidertwogener-
alized cases which can be concretized for various scenarios; those
concerndifferentrequirementsbuttheiranalysisisbasedonthesame model, obtained from a domain model of a city. Typically
thosemaybeanalyzedseparatelybydifferentstakeholders;how-
ever–aswilllaterbeillustrated–duetochangeswithinatypical
designworkflow,aneedofsupportingsynchronizationamongmul-
tiple views arises. We note that are not debating the underlyingformalism here (e.g., for modeling CPS), as this is outside of the
scope of this paper – our goal is investigating analysis scalability.
The first case concerns environmental monitoring with Wireless
SensorNetworks (WSNs),comprisedof smalldevices scatteredin
wide areas collecting measurement data. In order to gather data
fromlow-poweredsensors,oneormoremobile sinkscanbeused.
A sink is a gateway able to connect to a WSN device and also
to larger networks like the Internet; a sink downloads data froma sensor when it is near it. This scenario entails verification of
data collection; sinks move over the transportation network of the
city, collecting data from sensors. The second case concerns search
and rescue, a setting of emergency response where autonomous
UAVsaredispatchedtolocatevictimsinthecity[ 45];UAVsmove
overbuildings,lookingforvictimsinneedofassistance.Weseek
to verify that all victims in the city are eventually located by the
swarm of UAVs, in all possible system behaviors.
6.2 Experiment Setup & Results
Toutilizeourapproachinpractice,thedesignerspecifiesthesystem
model including its dynamics, as well as desired system properties.
The views can then be produced automatically as described in
Sec. 4.1. Implementation is available in accompanying material [ 1],
along with models used and an experiment reproduction kit.
In the following, we illustrate the specification steps of the case
study.Bigraphicalmodelsofthephysicalspaceofcitiesareauto-
matically extracted [ 47] from randomly synthesized [ 5] domain
modelsinCityGML3. Therandomlysynthesizedmodelsaretocon-
trolforsizewhilemaintainingacanonicalstructureofrealcities.
Real city models can be used as well [ 47], but would distort results,
thegoalofthiscasestudybeingtodemonstratescalabilityinacon-
trollablesetting. Thebigraphicalconfigurationcontainsvarious
elementspresentinthecity,suchas Blocks,Buildinдs ,Roadsand
Crossroads , linked accordingly to capture the topological structure
inherentinthedomainmodel[ 45].Blocksmaycontainanarbitrary
3CityGML is a standard for urban modeling, with models existing for multiple cities.
1000Table 1: Experiment results on cyber-physical city models.
Bigraph # of dLTS Interpret. BX
Size Rules St. (Trans.) Time Time
city1–Source 307 24 3977 (23k) 46m —
city1–UAV view 118 12 286 (1k) 2m26ms
city1–WSN view 132 12 234 (1k) 13m24ms
city2–Source 666 24 14046(90k) 6h —
city2–UAV view 293 12 1895 (8k) 16m53ms
city2–WSN view 215 12 347 (2k) 3m52ms
city3–Source 119824— >10h —
city3–UAV view 601 12 4697 (30k) 1.5h65ms
city3–WSN view 279 12 423 (2k) 4m68ms
number of buildings; each is connected to the one next to it, and to
ablock’ssurroundingroadsifitislocatedintheblockboundary,
whileroadsarelinkedtocrossroads.Subsequently,sensorscontain-
ingDataToken s,describingsensordeployment,and Victimstobe
rescuedareplacedrandomly;fortheexperimentsetup,weconsider
5ofeach.Additionally,4 UAVandSinkentitiesarealsoplaced.Dy-
namics specification encodes (i) movement of data sinks across the
transportationnetworkinthecityanddatacollectionfromsensors,
and(ii)movementofUAVsandvictimlocalization. Theelements
placed (UAVs, Sensors etc) are the same in all source models, inorder to control for size: we seek to evaluate how increasing the
problem size (i.e., city model size) affects scalability, while keeping
dynamics stable. Since we are concerned with evaluating scala-
bility–thereductionoftransitionsystemsizeandinterpretation
time over views – and not verification, we consider example LTLx
properties, aiming to (i) capture data collection by data sinks (e.g.,
/diamondmath(/square¬DataToken) )and(ii)ensurevictimsearchandrescuebyUAVs
(e.g.,/square(Victim →/diamondmath ¬ Building ?.(Victim|−0))).
Afterspecification,viewsaregeneratedandinterpretedasde-
scribed in Sec. 2.3. For BRS interpretation, external tools can be
used,e.g.,[ 33,44].Thereupon,wereportonexperimentalresults.
View generation leads to smaller models both in terms of size in
nodesandports(Column“BigraphSize”inTab.1)aswellasreduceddynamicssets,withbothreducedstate-transitionsizeandmoreeffi-
cient interpretation times (Column “dLTS Size” and “Interpretation
Time” in Tab. 1) due to reduced configuration sizes in states and
lessconcurrencyduetoreduceddynamics.Progressivelylargercitymodelsdemonstratethis–notehowthesourcemodelof
city3was
unable to be interpreted. Experiments were performed on an Intel
i5 3.1GHz; absolute values of interpretation time naturally depend
on tools used – what matters in our setting is the improvement
obtained by analyzing views, which drastically reducesspace and
time. Model checking on the transition systems finally produced
can then be readily performed with typical tools (e.g., SPOT [ 13]).
Multiple-ViewswithintheSmartCityWorkflow. Aftertheanalyses
performed, we outline a scenario taking place in the smart city
design process, in which model synchronization proves useful:
(1)A stakeholder in the system indicates that sensors mustbe placed additionally in city buildings for environmental
monitoring. The city model is updated to reflect this.
(2)The change is propagated to the views corresponding tothe WSN and UAV scenarios, and analysis of the respec-tive requirements is triggered. The column “BX Time” in
Table1recordsthetimeofprojectionforeachnewmodel.We note that view generation time is in the order of tens of
milliseconds (source update time is similar, so omitted).
(3)Interpretation(andanalysis)isperformedyetagainonthe
two views – times are quite similar to the ones in Table 1,
so they are omitted. While analysis of the UAV requirement
may be successful, the requirement corresponding to data
collection is violated. Intuitively, since sensors are now also
located in buildings, data collection from them cannot occur
since sinks move only over the transportation network; a
change in the system design is required.
(4)Since UAVs move between buildings, an upgrade to their
hardware can render them equipped with data collection ca-
pabilities.Thedesignerencodesanappropriatereactionrule,
andinterpretation(andanalysis)ontheviewsistriggered
again; both requirements are finally satisfied.
Note that (i) in principle, every update in the views is supportedand will be correctly propagated, and that (ii) stakeholders may
analyze, debug or repair views, instead of the large source model.
6.3 Discussion & Limitations
Asillustratedinthecasestudy,thedesignprocesscanbefacilitated
by reasoning on multiple views, and analysis scalability can beincreased. Views can be produced via getand synchronization is
achievedby puttransformations.Notethatthetimeusedforgener-
ating views and synchronizing models can be neglected compared
to the costly reactive system interpretation. However, as explained
in the following, we note that (i) the view generation method used
is conservative, and that (ii) future consideration of diverse case
studies should assess applicability in other domains.
By performing analysis on the projected configurations and
with reduced dynamics, view models benefit from the reduced
concurrencyandsmallersize,resultinginsmallerstate-transition
structuressubmittedforverification.However,inthescenariospre-
sented, while respective requirements pertain a single model, they
aretoacertaindegreedisjointastheycapturedifferentconcerns.
Weacknowledgethatinthecasewheremodelshaveincreasedover-
lapintypes,theremaybenoincreaseinefficiency.Thisisduetothe
viewgeneratingAlgorithm1,whichconservatively(butefficiently)
only uses types to derive view models. A more advanced extension
would refine the model further; we identify bigraph matching [36]
as the key driver for further automatic view refinement.
Topreciselydiscussscalability,wemustconsiderthattheanal-
ysis technique we target is explicit-state model checking, whichreliesonanexhaustiveexplorationofthestatespace;thisintrin-
sicallyrequiresrestrictinga scopetobefeasible.Exhaustivestate
explorationismotivatedbythe smallscopehypothesis,whichstates
thatahighproportionofbugscanbefoundbyexaminingasystem
withinasmallscope[ 2,23].Theapproachpresentedallowstoscale
uptheboundarieswithinwhichitcanbeperformedwithaccept-
able performance. The results obtained indicate that the technique
iseffectivewithinamodelandworkflowofaCPS–stakeholdersin
such a scenario typically work with overlapping views of the same
system (e.g., the physical space of the city). Practical experience
withotherdomainswouldprovideadditionalusefulassessments
and be an interesting future effort. Specifically, a systematic inves-
tigation would assess if meaningful properties and view models in
typical use cases in other domains exhibit overlap in types.
1001Our multiple-view technique has been demonstrated as based
on bigraphs and BRS, which although generic and widely appli-
cablehavenotenjoyede.g.,practicalapplications.However,their
well-defined semantics and hierarchical structure led to elegant
algorithmictreatment(Sec.4.1and5.1).Wenotethatthetechnique
could be readily applied for generating reduced views for other
graph-based formalisms that utilize types, such as Graph Trans-
formation Systems, with similar procedures and adoption of BX to
support synchronization across models, guaranteeing consistency.
Finally and regarding the overall process, a typical design work-
flowasillustratedinSec.6.2showsthebenefitofview-basedrea-
soningthroughsynchronizationsautomaticallyupdatingmodels
whenchangesoccur.Moreover,theperformanceoftransformations
(rightmostcolumnofTable1)renderstheprocedureapplicabletoan
onlinesetting.Tothisend,webelievethatintegrationtoatoolchainsupportingdesignandanalysisasillustratedinthispaperhasmerit
andcanenablepracticaluses. User-facingissuespertainingtoin-
tegration to some workflow or pipeline, such as conflicts handling
(wheree.g.,twodesignersconcurrentlyedittwoviews)ormerging
should be tackled as well, along with general usability aspects.
7 RELATED WORK
Ourtechniqueisfoundedontheideathatmultipleviewsareneeded
toreasonaboutasystemfordifferentrequirements.Accordingly,
weclassifyrelatedworkintomultiple-viewreasoning,modelslicing,
and related approaches of synchronization with BX.
Viewsasfirst-classcitizenshavebeenintroducedbyNuseibeh
et al. in their work on requirements of composite systems [ 16,38],
where requirements are often elicited from multiple sources ex-
pressing multiple and partial viewpoints. A follow-up proposesinteraction and integration of different viewpoints contributing
to resulting requirements specifications [ 39]. Subsequent work in-
volved inconsistency handling between such viewpoints by sup-
plying logical rules [ 15]. The importance of a rich model providing
structure andintegrating complementaryviews capturingdiffer-ent system facets was highlighted in [
46]. Multi-view reasoning
was further adopted in architectures with multiple potentially con-
flictingconcernsforqualityrequirementswithinmission-critical
systems [ 12]. Ourreasoning framework issimilarly based onmul-
tiple views; our goal however of view generation is analysis of
different system facets according to a requirements specification.
Slicing has been proposed as a program analysis technique [ 48],
to extract the parts of a program that affect (or are affected by)
executionofagivenstatement.Slicinghasalsobeensuccessfully
applied at the model level [ 3]; in proposition-based slicing [ 19]
temporal logicformulae areused to reducethe size ofa transition
systemformodelchecking. Wangetal[ 24]useslicing toreduce
thestatespaceofUMLstatechartswhenmodelchecking LTLx.The
slicingcriteriontypicallyconsistsofelementsfromaproperty ϕ,
such as the set of states and transitions in ϕ, or the set of variables
inϕ(e.g., for programs). Theslice produced must preserve the be-
haviour of those parts of the model that affect the truth value of
ϕ[3]. The typical strategy to achieve this is a recursive application
ofanoperationuntilafixedpointisreached-whichissimilarto
the technique we employ upon a BRS specification. Our technique
traversesbigraphicalstructuresuntilafixedpointemerges,how-
ever we apply this on the system specification using types frombigraphical propositions within LTLxproperties. We note that our
domain (graph-based reactive systems), problem domain (multiple-
view analysis) and use of BX (to maintain consistency between
slices) are to the best of our knowledge novel.
Bidirectionalmodeltransformationsareapopularmechanism
for maintaining consistency of at least two related sources of infor-
mation.Anapproachthatdefinesaconsistencyrelationbetween
two models is the QVT Relations language in the OMG QVT stan-
dard, supported by a tool complying to checking semantics [ 32]. A
TripleGraphGrammar[ 43]canbeusedtoconcludeconsistency,
particularly between graph-like structures, as well as to find a
partialcorrespondencemodelcombinedwithlinearoptimization
techniques to detect maximum consistency portions [ 31]. How-
ever, it is time-consuming and non-trivial to manually maintain
round-trippinglaws.Otherapproachesconsiderastandardforward-
direction with automatically derived backward transformations,
suchastheAtlaslanguage[ 49]orviagraphquerying[ 20].However,
the forward transformation may not be injective and its ambiguity
ofvariouscorrespondingput-directionsiswhatmakesbidirectional
programming challenging in practice. Recently, putback-based ap-
proaches[ 22]havebeenproposedtoonlyallowwritingputback
transformations. By contrast, a puttransformation could uniquely
determine getby well-behavedness, and the putback-based pro-
gram guarantees that the getbehaviours are unambiguously speci-
fied.BiYacc[ 50]andBiFlux[ 40]aretypicalexamples.BiGULisa
formallyverifiedlanguagewhichservesasafoundationforhigher-
levelputback-basedlanguages[ 25,26].WeadoptBiGULinorder
to have full control over the consistency restoration behaviors.
8 CONCLUSION AND FUTURE WORK
Earlyrequirementsvalidationhasbeenrecognizedasafundamentalsoftwareengineeringprinciple.Withinreactivesystems,thiscanbe
achieved by providing formal high-level system and requirements
specifications, their interpretation and mechanical verification thatthesystemmodelformallysatisfiestherequirements.Fundamental
problems however, are scalability and usability – this paper offers
a novel approach that addresses exactly these problems. Regarding
usability,theproposedapproachsupportsseparationofconcerns,
andthustheabilityofdifferentstakeholderstoonlyfocusonviews
that pertain to their interest. To support coherence of the entire
system, a contribution of this work is the ability to keep views and
specificationsynchronized,achievedthroughbidirectionaltrans-
formations. Scalability is achieved by analyzing models tailored to
specific requirements, instead of the complete system.
In future work, we plan to improve the way submodels are pro-
jected for a given property. The type-based approach we presented
is conservative and can produce non-optimal submodels, although
submodelsareproducedveryefficiently.Instancesofnodesinstead
oftypesmightbetakenintoaccounttofurtherreducesubmodel
size. The technique developed has been exploited in the case ofa specific formalism based on bigraphs. The idea of view-basedrequirements validation, however, is more general and could beapplied to generating reduced model views for other formalisms
thatutilizetypes.suchasgeneralGraphTransformationSystems.
Likewise, bidirectional transformation techniques may be adopted
intheseothercasestosupportsynchronizationacrossmodels,guar-
anteeing consistency across system design and development.
1002ACKNOWLEDGEMENTS
ResearchpartiallysupportedbyAustrianScienceFund(FWF)project
M2778-N“EDENSPACE”andtheNationalNaturalScienceFoun-
dation of China under Grant Nos. 61620106007 and 61751210.
REFERENCES
[1]2020. Reproduction kit, models, and accompanying implementation.
http://dsg.tuwien.ac.at/staff/ctsigkanos/ase20.
[2]AlexandrAndoni,DumitruDaniliuc,SarfrazKhurshid,andDarkoMarinov.2003.
Evaluating the small scope hypothesis. In In Popl, Vol. 2. Citeseer.
[3] Kelly Androutsopoulos, DavidClark, MarkHarman, Jens Krinke,and Laurence
Tratt.2013. State-basedmodelslicing:Asurvey. ACMComputingSurveys(CSUR)
45, 4 (2013), 53.
[4]RameshBharadwajandConstanceL.Heitmeyer.1999. ModelCheckingComplete
RequirementsSpecificationsUsingAbstraction. Autom.Softw.Eng. 6,1(1999),
37–68.
[5]FilipBiljecki,HugoLedoux,andJantienStoter.2016. Generationofmulti-LOD
3DcitymodelsinCityGMLwiththeproceduralmodellingengineRandom3Dcity.
ISPRS Ann. Photogramm. Remote Sens. Spatial Inf. Sci. (2016), 51–59.
[6]Ingo Brückner and Heike Wehrheim. 2005. Slicing Object-Z specifications for
verification. In International Conference of B and Z Users. Springer, 414–433.
[7]AlessandroCimatti,EdmundClarke,FaustoGiunchiglia,andMarcoRoveri.2000.
NuSMV: a new symbolic model checker. International Journal on Software Tools
for Technology Transfer 2, 4 (2000), 410–425.
[8] E. M. Clarke, O. Grumberg, and D. A. Peled. 1999. Model Checking. MIT press.
[9]James C Corbett, Matthew B Dwyer, John Hatcliff, Shawn Laubach, Corina S
Pasareanu,HongjunZheng,etal .2000. Bandera:Extractingfinite-statemodels
from Java source code. In Proceedings of the 2000 International Conference on
Software Engineering. ICSE 2000 the New Millennium. IEEE, 439–448.
[10]AndreaCorradini,UgoMontanari,FrancescaRossi,HartmutEhrig,ReikoHeckel,
and Michael Löwe. 1997. Algebraic Approaches to Graph Transformation-Part I:
BasicConceptsandDoublePushoutApproach..In HandbookofGraphGrammars.
163–246.
[11]Krzysztof Czarnecki, J. Nathan Foster, Zhenjiang Hu, Ralf Lämmel, Andy Schürr,
andJamesF.Terwilliger.2009. BidirectionalTransformations:ACross-Discipline
Perspective.In TheoryandPracticeofModelTransformations,2ndIntl.Conf,ICMT
2009, Zurich, Switzerland, June 29-30, 2009. Proceedings. 260–283.
[12]Kadir Alpaslan Demir. 2015. Multi-View Software Architecture Design: Case
Study of a Mission-Critical Defense System. Computer and Information Science 8,
4 (2015), 12–31.
[13]Alexandre Duret-Lutz, Alexandre Lewkowicz, Amaury Fauchille, Thibaud
Michaud,EtienneRenault,andLaurentXu.2016. Spot2.0—aframeworkforLTLand
ω-automatamanipulation.In Proc.ofthe14thIntl.SymposiumonAutomated
Technology for Verification and Analysis (ATVA’16), Vol. 9938. Springer, 122–129.
[14]Kousha Etessami. 1999. Stutter-invariant languages, ω-automata, and temporal
logic. InIntl. Conference on Computer Aided Verification. Springer, 236–248.
[15]Anthony Finkelstein, Dov M. Gabbay, Anthony Hunter, Jeff Kramer, and Bashar
Nuseibeh.1993. InconsistencyHandlinginMulti-PerspectiveSpecifications.In
SoftwareEngineering-ESEC’93,4thEuropeanSoftwareEngineeringConference,
Garmisch-Partenkirchen, Germany, September 13-17, 1993, Proceedings. 84–99.
[16] AnthonyFinkelstein,JeffKramer,BasharNuseibeh,L.Finkelstein,andMichael
Goedicke. 1992. Viewpoints: A Framework for Integrating Multiple Perspec-
tives in SystemDevelopment. International Journal ofSoftware Engineering and
Knowledge Engineering 2, 1 (1992), 31–57.
[17]J. Nathan Foster, Michael B. Greenwald, Jonathan T. Moore, Benjamin C. Pierce,
andAlanSchmitt.2007. Combinatorsforbidirectionaltreetransformations:A
linguisticapproachtotheview-updateproblem. ACMTrans.Program.Lang.Syst.
29, 3 (2007), 17.
[18]Vinod Ganapathy and S. Ramesh. 2002. Slicing Synchronous Reactive Programs.
InElectronicNotesinTheoreticalComputerScience,65(5).1stWorkshoponSyn-
chronous Languages, Applications, and Programming. Elsevier, Grenoble, France.
[19]John Hatcliff, Matthew B Dwyer, and Hongjun Zheng. 2000. Slicing software for
modelconstruction. Higher-orderandsymboliccomputation 13,4(2000),315–353.
[20]Soichiro Hidaka, Zhenjiang Hu, Hiroyuki Kato, and Keisuke Nakano. 2009. A
compositionalapproachtobidirectionalmodeltransformation.In 31stInterna-
tional Conference on Software Engineering, ICSE 2009, May 16-24, 2009, Vancouver,
Canada, Companion Volume. 235–238.
[21]GerardJ.Holzmann.1997. ThemodelcheckerSPIN. IEEETransactionsonsoftware
engineering 23, 5 (1997), 279–295.
[22]Zhenjiang Hu, Hugo Pacheco, and Sebastian Fischer. 2014. Validity Checking
ofPutbackTransformationsinBidirectionalProgramming.In FM2014:Formal
Methods - 19th Intl. Symposium, Singapore, May 12-16, 2014. Proc. 1–15.
[23]Daniel Jackson and Craig Damon. 1996. Elements of Style: Analyzing a Software
Design Feature with a Counterexample Detector. IEEE Trans. Software Eng. 22, 7
(1996), 484–495.[24]WangJi,DongWei,andQiZhi-Chang.2002. Slicinghierarchicalautomatafor
modelcheckingUMLstatecharts.In InternationalConferenceonFormalEngineer-
ing Methods. Springer, 435–446.
[25]Hsiang-Shang Ko and Zhenjiang Hu. 2018. An axiomatic basis for bidirectional
programming. PACMPL 2, POPL (2018), 41:1–41:29.
[26]Hsiang-Shang Ko, Tao Zan, and Zhenjiang Hu. 2016. BiGUL: a formally verifiedcore language for putback-based bidirectional programming. In Proc. of the 2016
ACM SIGPLAN Workshop on Partial Evaluation and Program Manipulation, PEPM
2016, St. Petersburg, FL, USA, January 20 - 22, 2016. 61–72.
[27]Hsiang-Shang Ko. 2013. BiGUL: The Bidirectional Generic Update Language.
https://bitbucket.org/prl_tokyo/bigul.
[28]Sébastien Labbé and Jean-Pierre Gallois. 2008. Slicing communicating automata
specifications: polynomial algorithms for model reduction. Formal Aspects of
Computing 20, 6 (2008), 563–595.
[29]SimonSLamandAUdayaShankar.1984. Protocolverificationviaprojections.
IEEE transactions on software engineering 4 (1984), 325–342.
[30]Leslie Lamport. 1983. What good is temporal logic?. In IFIP congress, Vol. 83.
657–668.
[31] Erhan Leblebici, Anthony Anjorin, and Andy Schürr. 2017. Inter-model Consis-
tencyCheckingUsingTripleGraphGrammarsandLinearOptimizationTech-
niques.In FundamentalApproachestoSoftwareEngineering-20thInternational
Conference, Uppsala, Sweden, April 22-29, 2017, Proceedings. 191–207.
[32]NunoMacedoandAlcinoCunha.2013. ImplementingQVT-RBidirectionalModel
TransformationsUsingAlloy.In FundamentalApproachestoSoftwareEngineering
- 16th Intl. Conference, FASE 2013, Rome, Italy, March 16-24, 2013. Proc. 297–311.
[33]A.Mansutti,M. Miculan,andM.Peressotti.[n.d.]. Multi-agentSystemsDesign
and Prototyping with Bigraphical Reactive Systems. In 14th IFIP WG 6.1 Intl.
Conference, DAIS 2014, Berlin, Germany, June 3-5, 2014.
[34]C. Menghi, C. Tsigkanos, P. Pelliccione, C. Ghezzi, and T. Berger. 2019. Specifica-
tion Patterns for Robotic Missions. IEEE Transactions on Software Engineering
(2019), 1–1.
[35]LynetteIMillettandTimTeitelbaum.2000. IssuesinslicingPROMELAandits
applicationstomodelchecking,protocolunderstanding,andsimulation. Inter-
national Journal on Software Tools for Technology Transfer 2, 4 (2000), 343–349.
[36]Robin Milner. 2009. The Space and Motion of Communicating Agents. Cambridge
University Press.
[37]Bashar Nuseibeh, Jeff Kramer, and Anthony Finkelsteiin. 2003. ViewPoints:meaningful relationships are difficult!. In Proceedings of the 25th International
Conference on Software Engineering. IEEE Computer Society, 676–681.
[38]Bashar Nuseibeh, Jeff Kramer, and Anthony Finkelstein. 1993. Expressing the
Relationships Between Multiple Views in Requirements Specification. In Proc. of
the 15th Intl. Conf. on Software Engineering, USA, May 17-21, 1993. 187–196.
[39]Bashar Nuseibeh, Jeff Kramer, and Anthony Finkelstein. 1994. A Framework for
ExpressingtheRelationshipsBetweenMultipleViewsinRequirementsSpecifi-
cation.IEEE Trans. Software Eng. 20, 10 (1994), 760–773.
[40]Hugo Pacheco, Tao Zan, and Zhenjiang Hu. 2014. BiFluX: A Bidirectional Func-
tional Update Language for XML. In Proc. of the 16th International Symposium on
PrinciplesandPracticeofDeclarativeProgramming,UK,Sept.8-10,2014.147–158.
[41]DoronPeled.1994. Combiningpartialorderreductionswithon-the-flymodel-
checking.In InternationalConferenceonComputerAidedVerification.Springer,
377–390.
[42]Doron Peled and Thomas Wilke. 1997. Stutter-invariant temporal properties are
expressible without the next-time operator. Inform. Process. Lett. 63, 5 (1997),
243–246.
[43]Andy Schürr. 1994. Specification of Graph Translators with Triple Graph Gram-
mars. InGraph-Theoretic Conceptsin Computer Science,20th International Work-
shop, WG ’94, Herrsching, Germany, June 16-18, 1994, Proceedings. 151–163.
[44]MicheleSevegnaniandMuffyCalder.2015.BigraphswithSharing. Theor.Comput.
Sci.577 (2015), 43–73.
[45]Christos Tsigkanos, Timo Kehrer, and Carlo Ghezzi. 2017. Modeling and veri-
ficationofevolvingcyber-physicalspaces.In Proceedingsofthe201711thJoint
Meeting on Foundations of Software Engineering, ESEC/FSE 2017, 2017. 38–48.
[46]AxelvanLamsweerde.2009. BuildingMulti-ViewSystemModelsforRequire-
ments Engineering. In RE 2009, 17th IEEE International Requirements Engineering
Conference, Atlanta, Georgia, USA, August 31 - September 4, 2009. 368–369.
[47]EnnioVisconti,ChristosTsigkanos,ZhenjiangHu,andCarloGhezzi.2019.Model-
DrivenDesign ofCity Spacesvia BidirectionalTransformations. In Proceedings
of the 22nd ACM/IEEE International Conference on Model Driven Engineering
Languages and Systems, MODELS 2019, Munich, September 15-20, 2019. ACM.
[48]Mark Weiser. 1981. Program slicing. In Proceedings of the 5th international
conference on Software engineering. IEEE Press, 439–449.
[49]YingfeiXiong,DongxiLiu,ZhenjiangHu,HaiyanZhao,MasatoTakeichi,and
HongMei.2007. Towardsautomaticmodelsynchronizationfrommodeltrans-
formations.In 22ndIEEE/ACMInternationalConferenceonAutomatedSoftware
Engineering November 5-9, 2007, Atlanta, Georgia, USA. 164–173.
[50]Zirun Zhu, Hsiang-Shang Ko, Pedro Martins, João Saraiva, and Zhenjiang Hu.
2015. BiYacc: Roll Your Parser and Reflective Printer into One. In Proc. of the 4th
Intl. Workshop on Bidirectional Transformations L’Aquila, Italy, 2015. 43–50.
1003