Detecting Concurrency Vulnerabilities Based on Partial Orders of
Memory and Thread Events
Kunpeng Yu
Chenxu Wangâˆ—
yukunpeng33@stu.xjtu.edu.cn
cxwang@mail.xjtu.edu.cn
School of Software Engineering
MOE Key Lab of INNS, Xiâ€™an Jiaotong University
Xiâ€™an, Shaanxi, ChinaYan Cai
SKLCS, Institute of Software, Chinese Academy of
Sciences
University of Chinese Academy of Sciences
Beijing, China
ycai.mail@gmail.com
Xiapu Luo
The Hong Kong Polytechnic University
Hong Kong, China
csxluo@comp.polyu.edu.hkZijiang Yang
Xiâ€™an Jiaotong University
Xiâ€™an, Shaanxi, China
yang@guardstrike.com
ABSTRACT
Memory vulnerabilities are the main causes of software security
problems. However, detecting vulnerabilities in multi-threaded pro-
grams is challenging because many vulnerabilities occur under
specific executions, and it is hard to explore all possible executions
of a multi-threaded program. Existing approaches are either com-
putationally intensive or likely to miss some vulnerabilities due
to the complex thread interleaving. This paper introduces a novel
approach to detect concurrency memory vulnerabilities based on
partial orders of events. A partial order on a set of events repre-
sents the definite execution orders of events. It allows construct-
ing feasible traces exposing specific vulnerabilities by exchanging
the execution orders of vulnerability-potential events. It also re-
duces the search space of possible executions and thus improves
computational efficiency. We propose new algorithms to extract
vulnerability-potential event pairs for three kinds of memory vul-
nerabilities. We also design a novel algorithm to compute a potential
event pairâ€™s feasible set, which contains the relevant events required
by a feasible trace. Our method extends existing approaches for
data race detection by considering that two events are protected
by the same lock. We implement a prototype of our approach and
conduct experiments to evaluate its performance. Experimental
results show that our tool exhibits superiority over state-of-the-art
algorithms in both effectiveness and efficiency.
CCS CONCEPTS
â€¢Software and its engineering â†’Software testing and debug-
ging .
âˆ—Corresponding author
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior specific permission and/or a
fee. Request permissions from permissions@acm.org.
ESEC/FSE â€™21, August 23â€“28, 2021, Athens, Greece
Â©2021 Association for Computing Machinery.
ACM ISBN 978-1-4503-8562-6/21/08. . . $15.00
https://doi.org/10.1145/3468264.3468572KEYWORDS
concurrency vulnerability, multi-threaded programs, partial orders
ACM Reference Format:
Kunpeng Yu, Chenxu Wang, Yan Cai, Xiapu Luo, and Zijiang Yang. 2021.
Detecting Concurrency Vulnerabilities Based on Partial Orders of Memory
and Thread Events. In Proceedings of the 29th ACM Joint European Software
Engineering Conference and Symposium on the Foundations of Software Engi-
neering (ESEC/FSE â€™21), August 23â€“28, 2021, Athens, Greece. ACM, New York,
NY, USA, 12 pages. https://doi.org/10.1145/3468264.3468572
1 INTRODUCTION
Programs written in C/C++ are generally memory-efficient and
computationally fast because they allow direct memory access with-
out additional safety checks. However, this flexibility sometimes
could cause severe vulnerabilities due to wrong memory access.
For example, a dereference to a null pointer will cause undefined
behaviors in C/C++ programs, which usually leads to severe secu-
rity problems [ 25,29]. Technicians have developed several tools to
detect these memory-related errors [30, 33, 35].
With the development of multi-core processors, more and more
concurrency (multi-threaded) programs are developed for computa-
tional efficiency. When a multi-threaded program runs, operations
in various threads are interleaved in unpredictable orders, subject to
the constraints imposed by explicit synchronization operations. Al-
though operations in each thread are strictly ordered, the interleav-
ing of operations from a collection of threads is non-deterministic
and depends on the programâ€™s execution. That is, operations in
concurrency programs have various execution orders, and some
vulnerabilities only occur in specific thread interleaving. For exam-
ple, the execution order of two events accessing the same memory
address by different threads may be exchangeable because of thread
interleaving. If a read event to a variable occurs unexpectedly be-
fore a write one, an error may be caused in some situations [ 4].
However, it is challenging to detect concurrency memory vulnera-
bilities due to non-deterministic thread interleaving. Besides, it is
computationally intensive to explore all the possibilities of thread
interleaving, leading to the efficiency problem in concurrency vul-
nerability detection.
280
ESEC/FSE â€™21, August 23â€“28, 2021, Athens, Greece Kunpeng Yu, Chenxu Wang, Yan Cai, Xiapu Luo, and Zijiang Yang
In this paper, we focus on detecting three kinds of concurrency
vulnerabilities, including Use-After-Free (UAF), Double-Free (DF),
and Null-Pointer-Dereference (NPD), which are mostly caused by
wrong memory-address accesses in stochastic executions [ 28,34].
A UAF occurs when a dangling pointer accesses a freed memory [ 2].
When a program attempts to dereference a NULL pointer, an NPD
occurs. DF means that a memory address is improperly freed twice
[2]. It is easy to figure out these vulnerabilities in a single-threaded
program because all events occur in a definite sequence. However,
it is non-trivial to detect these vulnerabilities in multi-threaded
programs because only certain execution orders can trigger them.
There are two main approaches to detect concurrency vulnera-
bilities. An intuitive solution is to cooperate with the fuzzing tech-
nology by running a target program many times and try to retrieve
different execution orders exhaustively [ 5,15,19,36,37].Muzz
[5] is a grey-box fuzzer that uses thread-aware instrumentation to
get more various execution orders by adjusting thread priorities.
Krace [37] is a file system fuzzer aiming to detect data race among
multiple threads. It controls thread schedules by delaying a memory
access for a random number of accesses in other threads. However,
it is extremely expensive to get all possible execution orders due to
the explosion of search spaces [22].
Another way is to predict possible executions from observed
ones. Huangâ€™s UAF Finder Optimal (UFO) [ 13] is underpinned by a
data race detection model based on constraint solving algorithms.
UFO relies on the constraint solver Z3 [ 7], which is computationally
intensive for complex constraints. ExceptioNULL [11] rearranges
the trace to expose NPD vulnerabilities. It solves several constraints
to guarantee the feasibility of the constructed traces. The scheduling
constraints are employed to represent necessary execution orders
of a multi-threaded program, and then Z3 is adopted to solve the
constraints. However, this approach may cost a mass of time to solve
complicated constraints. ConVul [4] uses a heuristic method based
onsync-edge andsync-distance to determine whether two events
are exchangeable. A sync-edge is an edge either from a lock event
to its unlock event in the same thread or from an unlock event to a
lock event on the same lock in the other thread. The sync-distance
of two events is defined as the minimal number of sync-edges
ordering the two events [ 4].ConVul generates candidate traces
that trigger vulnerabilities by exchanging the execution orders
of events. It assumes that two events with short sync-distance
are more likely to be exchangeable for computational efficiency
improvement. If the sync-distance of two events is less than a
predefined threshold (default is 3), ConVul schedules the trace and
tries to exchange their execution order for vulnerability detection.
However, it may miss some exchangeable events with long sync-
distances. In summary, there is a lack of effective and efficient
methods to detect concurrency vulnerabilities.
This paper presents ConVulPOE , aConcurrency Vulnerability
detector based on Partial Orders of Events. Similar to ConVul
[4] and UFO [13],ConVulPOE attempts to generate execution
traces exposing vulnerabilities. However, ConVulPOE follows con-
structed partial orders of memory and thread events to generate
traces. First, we record the concerned thread operations and mem-
ory access events in an execution of a program through Intel Pin
[20]. We represent the sequence of events as a trace. Second, we
develop new algorithms to extract vulnerability-potential eventpairs that may cause vulnerabilities by passing through the trace.
We also design a novel algorithm to compute an event pairâ€™s feasible
set, which contains the relevant events required by a feasible trace
exposing a vulnerability.
Third, we construct a partial order for a feasible event set to
generate a new trace exposing a vulnerability. The partial orders of
an event set represent the deterministic execution orders between
contextual events. Compared with the heuristic algorithm used in
ConVul [4], following a partial order of events to generate a trace
allows us to detect vulnerabilities without false positive errors.
It also reduces the search spaces of possible executions, which
improves computational efficiency.
Finally, we implement a prototype of ConVulPOE for pthread-
based multi-threaded C/C++ programs based on Intel Pin. We con-
duct experiments to evaluate the performance of ConVulPOE . Ex-
perimental results show that our tool can find more vulnerabilities
than state-of-the-art detectors in less time.
2 PRELIMINARIES
A multi-threaded program Pconsists of various threads {ğ‘¡1,ğ‘¡2,...,
ğ‘¡ğ‘›}, whereğ‘›is the number of threads. Each thread has a sequence of
operations under sequential consistency semantics [ 17]. Operations
in different threads are interleaved randomly as the program runs.
Like prior works [ 4,13,23,26], this paper focuses on variable and
lock accessing operations because most concurrency vulnerabilities
are caused by improper synchronization on variables. We refer to
these operations as events . An access to a variable is a read orwrite
event. We use ğ‘Ÿ(ğ‘¥)andğ‘¤(ğ‘¥)to denote a read andwrite event
on variable ğ‘¥, respectively. Operations on a lock include acquire
andrelease . Similarly, we employ ğ‘ğ‘ğ‘(ğ‘™)andğ‘Ÿğ‘’ğ‘™(ğ‘™)to denote an
acquire andrelease event on lock ğ‘™, respectively.
We use a sequence of events to represent a programâ€™s execution
and call it trace . Events in a trace are ordered sequentially. Given
a traceğœ, we useEğœto denote the set of events in ğœandW(Eğœ)
(resp.,R(Eğœ),Lğ´(Eğœ),Lğ‘…(Eğœ)) to denote the write (resp., read ,
acquire ,release ) event set of ğœ. Given an event ğ‘’, we useğ‘¡ğ‘–ğ‘‘(ğ‘’)to
denote the thread that executes ğ‘’andğ‘™ğ‘œğ‘(ğ‘’)to denote the variable
(or lock) that ğ‘’accesses. If event ğ‘’is an acquire (release ) event,
we useğ‘šğ‘ğ‘¡ğ‘â„ğœ(ğ‘’)to denote the first release (acquire ) event
accessing the same lock following (previous to) ğ‘’in the same thread.
Given a pointer-type variable ğ‘¥, we useğ‘“ğ‘Ÿğ‘’ğ‘’(ğ‘¥)to denote an
event freeing ğ‘¥, andğ‘‘ğ‘’ğ‘Ÿğ‘’ğ‘“(ğ‘¥)to denote the dereference opera-
tion ofğ‘¥. Note that ğ‘“ğ‘Ÿğ‘’ğ‘’(ğ‘¥)andğ‘‘ğ‘’ğ‘Ÿğ‘’ğ‘“(ğ‘¥)are two special cases
ofğ‘Ÿğ‘’ğ‘ğ‘‘(ğ‘¥). Given a trace ğœ, we useğ¹ğ‘Ÿğ‘’ğ‘’(Eğœ)andğ·ğ‘’ğ‘Ÿğ‘’ğ‘“(Eğœ)to
denote the free anddereference event sets of ğœ, respectively.
The following presents two critical definitions relevant to the
execution of concurrency programs.
Critical sections: Given a lock ğ‘™, a critical section is the set of se-
quential events in the same thread starting from ğ‘ğ‘ğ‘(ğ‘™)and ending
withğ‘Ÿğ‘’ğ‘™(ğ‘™)=ğ‘šğ‘ğ‘¡ğ‘â„ğœ(ğ‘ğ‘ğ‘(ğ‘™))(includingğ‘ğ‘ğ‘(ğ‘™)andğ‘Ÿğ‘’ğ‘™(ğ‘™)).
Conflicting events: Two events are said to be conflicting if
they belong to different threads and access the same variable, and
at least one of them is a write event. We also say that two lock
accessing events are conflicting if they access the same lock. We
useğ‘’1â‰ğ‘’2to denote that ğ‘’1andğ‘’2are conflicting.
281Detecting Concurrency Vulnerabilities Based on Partial Orders of Memory and Thread Events ESEC/FSE â€™21, August 23â€“28, 2021, Athens, Greece
Both critical sections and conflicting events can be got by passing
through a trace once.
2.1 Memory Vulnerabilities
C/C++ programs adopt a series of functions or operators (e.g.,
malloc ,free ,new,delete ) for dynamic memory management.
A block of heap memory must be allocated before it is accessed
and freed after use. Accesses to a memory address that is not allo-
cated yet or previously freed will lead to undefined behaviors of a
program and usually cause crashes and security problems. This pa-
per focuses on three kinds of concurrency memory vulnerabilities,
including Use-After-Free (UAF), Null-Pointer-Dereference (NPD),
and Double-Free (DF).
Use-After-Free (UAF): A UAF occurs when a block of previ-
ously freed memory is used. It can cause serious consequences,
ranging from corruptions of valid data to the execution of arbitrary
codes [9].
NULL-Pointer-Dereference (NPD): An NPD occurs when a
NULL pointer is dereferenced. It typically causes a crash or an
abnormal exit. In rare circumstances, it also leads to the execution
of arbitrary codes [10].
Double-Free (DF): A DF occurs if a program calls free twice
with the same argument (i.e., the memory address). It can cause
programsâ€™ crashes or make them vulnerable to buffer overflow
attacks under specific conditions [8].
These vulnerabilities are caused by several flaws, such as race
conditions and other exceptional circumstances. The non-determi-
nistic execution of multi-threaded programs makes these vulnera-
bilities more frequent to occur and harder to be detected.
2.2 Feasible Traces
Not all reordered traces of an observed one are valid and feasible.
Even a few changes to the eventsâ€™ execution orders may cause
the program to execute other branches. Hence, we cannot use an
arbitrarily reordered trace to represent an execution. Every read
event should get the same value as it did in the original trace to
ensure the validity of the reordered trace. Given a trace ğœand a
read eventğ‘Ÿ, we say that ğ‘Ÿobserves a write eventğ‘¤inğœifğ‘¤is
the nearest event before ğ‘Ÿthat writes the same variable. We use
ğ‘œğ‘ğ‘ ğœ(ğ‘Ÿ)=ğ‘¤to denote that ğ‘Ÿobservesğ‘¤. We haveğ‘œğ‘ğ‘ ğœ(ğ‘Ÿ)=ğ‘¤,
iffğ‘™ğ‘œğ‘(ğ‘Ÿ)=ğ‘™ğ‘œğ‘(ğ‘¤)andğ‘¤<ğœğ‘Ÿ, and there is no other write event
ğ‘¤â€²thatğ‘™ğ‘œğ‘(ğ‘¤â€²)=ğ‘™ğ‘œğ‘(ğ‘Ÿ)andğ‘¤<ğœğ‘¤â€²<ğœğ‘Ÿ. For simplicity, we
assume that every variable has a write event initializing it. We
first define the projection of a trace onto a thread and then define
feasible traces.
Projection: Given a trace ğœand a thread ğ‘¡, the projection of ğœ
onto thread ğ‘¡is defined as the event sequence of ğ‘¡and is denoted
byğœâ†¾ğ‘¡. That is,ğœâ†¾ğ‘¡is a sub-sequence of ğœsatisfying that:
(1)ğœâ†¾ğ‘¡only contains the events of thread ğ‘¡. That is,Eğœâ†¾ğ‘¡âŠ†Eğœ
andâˆ€ğ‘’âˆˆEğœâ†¾ğ‘¡,ğ‘¡ğ‘–ğ‘‘(ğ‘’)=ğ‘¡.
(2)Event orders in ğœâ†¾ğ‘¡is the same as that in ğœ. That is,âˆ€(ğ‘’1,ğ‘’2âˆˆ
EğœÃ“ğ‘¡ğ‘–ğ‘‘(ğ‘’1)=ğ‘¡ğ‘–ğ‘‘(ğ‘’2)=ğ‘¡Ã“ğ‘’1<ğœğ‘’2),ğ‘’1<ğœâ†¾ğ‘¡ğ‘’2.
Given an observed trace ğœ, we say another trace ğœâ€²isfeasible if
the following properties hold:
(1)Traceğœâ€²only contains the events in ğœ. That is,Eğœâ€²âŠ†Eğœ.
ğœâ€²need not contain all the events in ğœbecause we just wantthe program to execute to the point where a vulnerability
occurs and do not care about what happens after it.
(2)Events in the same thread must execute in the same order in
ğœandğœâ€². That is, for every thread ğ‘¡,ğœâ€²â†¾ğ‘¡is a prefix of ğœâ†¾ğ‘¡.
(3)Critical sections on the same lock cannot overlap. That is,
given two acquire eventsğ‘ğ‘ğ‘1andğ‘ğ‘ğ‘2,andğ‘™ğ‘œğ‘(ğ‘ğ‘ğ‘ 1)=
ğ‘™ğ‘œğ‘(ğ‘ğ‘ğ‘ 2), ifğ‘ğ‘ğ‘1<ğœâ€²ğ‘ğ‘ğ‘2, thenğ‘šğ‘ğ‘¡ğ‘â„ğœ ğ‘ğ‘ğ‘1<ğœâ€²ğ‘ğ‘ğ‘2.
(4)Every read eventğ‘Ÿshould observe the same event in ğœâ€²as
it does inğœ. That is,âˆ€ğ‘ŸâˆˆR(Eğœâ€²),ğ‘œğ‘ğ‘ ğœâ€²(ğ‘Ÿ)=ğ‘œğ‘ğ‘ ğœ(ğ‘Ÿ).
2.3 Partial Orders
Multi-threaded programs usually have different execution orders
due to non-deterministic thread interleaving. The execution or-
ders of some events could be exchanged in different runs of a
multi-threaded program. In this paper, we are concerned about
exchangeable event pairs because they are more likely to cause
memory vulnerabilities. Given two events ğ‘’1andğ‘’2, we say that
(ğ‘’1,ğ‘’2)is exchangeable if two valid traces ğœandğœâ€²exist, and the
execution orders of ğ‘’1andğ‘’2in the two traces are different (i.e.,
ğ‘’1<ğœğ‘’2Ã“ğ‘’2<ğœâ€²ğ‘’1).
Some events must execute before others to make a reordered
trace feasible. We use partial orders to represent the execution
orders of events. Given an event set ğ¸, a (strict) partial order ğ‘ƒ(ğ¸)
is an irreflexive, transitive, and asymmetry relation over ğ¸. Ifğ¸
is clear from the context, we will use ğ‘ƒfor simplification. There
are two basic partial orders over Eğœfor a traceğœ. The first is the
execution order ( <ğœ) we mentioned above, which represents an
execution of a program. We denote the execution order by ğ‘¡ğ‘Ÿ(Eğœ),
which is determined by the trace ğœ. The execution of a single thread
can also be represented by a partial order. If event ğ‘’1is performed
before event ğ‘’2inğœ, and both events are in the same thread, we say
ğ‘’1isthread-ordered beforeğ‘’2, denoted by ğ‘’1<ğœâ†¾ğ‘¡ğ‘’2. We denote
the thread order by ğ‘‡ğ‘‚(Eğœ). Note that any two events of ğœare
ordered byğ‘¡ğ‘Ÿ(Eğœ), but only events in the same thread are ordered
byğ‘‡ğ‘‚(Eğœ). Given a partial order ğ‘ƒ, two events ğ‘’1,ğ‘’2areunordered ,
denoted byğ‘’1âˆ¥ğ‘ƒğ‘’2, if neitherğ‘’1<ğ‘ƒğ‘’2, norğ‘’2<ğ‘ƒğ‘’1. For example,
any two events in different threads are unordered by ğ‘‡ğ‘‚(Eğœ). On
the other hand, if a trace ğœâ€²is feasible, events in the same thread
must execute in the same order in ğœ. That is, given ğ‘’1,ğ‘’2âˆˆEğœand
ğ‘’1,ğ‘’2âˆˆEğœâ€², ifğ‘’1<ğœâ†¾ğ‘¡ğ‘’2, thenğ‘’1<ğœâ€²â†¾ğ‘¡ğ‘’2.
3 FEASIBLE TRACE CONSTRUCTION
In this section, we first give an example to illustrate the motivation
of our method. Then, we present the algorithm to generate new
feasible traces based on an observed one.
3.1 A Motivating Example
Figure 1(a) shows a trace containing three threads. We use ğ‘’ğ‘–to
denote theğ‘–-th event. Let ğ‘’14assign NULL to ğ‘¦. Note thatğ‘’11is a
pointer-dereference event, and (ğ‘’11,ğ‘’14)is an event pair protected
by the same lock ğ‘™. Ifğ‘’14executes before ğ‘’11, then an NPD occurs.
To prove that, we need to reorder these events and get a new trace
in whichğ‘’11is not included to make ğ‘’14execute first. Since the
new trace is feasible and includes the event right before ğ‘’11, we can
appendğ‘’11to the end of the new trace and keep it feasible.
282ESEC/FSE â€™21, August 23â€“28, 2021, Athens, Greece Kunpeng Yu, Chenxu Wang, Yan Cai, Xiapu Luo, and Zijiang Yang
The first step is to figure out what events should be included
in the new trace. For example, the events in ğ‘¡2are not needed in
the new trace because there is no write event, and other events
need not observe them. Therefore, the event set should be ğ¸=
{ğ‘’ğ‘–}5
ğ‘–=1âˆª{ğ‘’ğ‘–}10
ğ‘–=9âˆª{ğ‘’ğ‘–}15
ğ‘–=13. Events in the same thread have already
been ordered. To get a feasible trace, we need to make some events in
different threads reordered. We introduce partial order to solve the
problem. Figure 1(b) is a partial order graph constructed based on
ğ¸. We can see that there are two additional edges from ğ‘’1toğ‘’9and
fromğ‘’15toğ‘’10. The first edge makes ğ‘’9read the value written by ğ‘’1
as it does in the origin trace. And the second one makes the critical
sections on lock ğ‘™not overlap. Then we can get a feasible trace
ğ‘’1,ğ‘’9,ğ‘’2,ğ‘’3,ğ‘’4,ğ‘’5,ğ‘’13,ğ‘’14,ğ‘’15,ğ‘’10,ğ‘’11, whereğ‘’14executes before ğ‘’11.
Thus, we can prove that there is an NPD vulnerability.
Figure 1: An example of a trace and one of its partial orders.
In the rest of this section, we first define a feasible event set for
an execution trace of a multi-threaded program. A feasible event
set contains necessary events that build a new trace. Then, we build
a partial order based on the feasible event set to add some ordering
between events. Finally, we present the algorithm to generate new
feasible traces.
3.2 Feasible Event Sets
As we mentioned above, a feasible trace ğœâ€²need not contain all
the events in the original trace ğœ. Besides, not all partial orders
can produce a feasible trace. The first problem of getting a feasible
trace from a partial order is to extract a subset of Eğœ. We say that
a subset ofEğœisfeasible if it is prefix-closed, lock-feasible, and
observation-feasible for ğœ.
Prefix-closed: For every event pair ğ‘’1,ğ‘’2âˆˆEğœ, we say thatEğœâ€²
is prefix-closed if ğ‘’2âˆˆEğœâ€²andğ‘’1<ğœâ†¾ğ‘¡ğ‘’2, thenğ‘’1âˆˆEğœâ€². It ensures
thatğœâ€²â†¾ğ‘¡is a prefix of ğœâ†¾ğ‘¡for every thread ğ‘¡. We can see that the
event set in Figure 1(b) is prefix-closed.
Lock-feasible: We say thatEğœâ€²is lock-feasible if (i) âˆ€ğ‘Ÿğ‘’ğ‘™âˆˆ
Lğ‘…
ğœâ€²,ğ‘šğ‘ğ‘¡ğ‘â„ğœ(ğ‘Ÿğ‘’ğ‘™)âˆˆEğœâ€², and (ii)âˆ€ğ‘ğ‘ğ‘ 1,ğ‘ğ‘ğ‘ 2âˆˆğ‘‚ğ‘ğ‘›ğ´ğ‘ğ‘ğœ(Eğœâ€²),
ğ‘™ğ‘œğ‘(ğ‘ğ‘ğ‘ 1)â‰ ğ‘™ğ‘œğ‘(ğ‘ğ‘ğ‘ 2); whereğ‘‚ğ‘ğ‘›ğ´ğ‘ğ‘ğœ(Eğœâ€²)={ğ‘ğ‘ğ‘âˆˆ Lğ´
ğœâ€²|
ğ‘šğ‘ğ‘¡ğ‘â„ğœ(ğ‘ğ‘ğ‘)âˆ‰Eğœâ€²}is an event set that contains open acquire
events whose matching release events do not belong to Eğœâ€². The
first condition guarantees that the matching acquire event for
each release event inEğœâ€²is also inEğœâ€². The second ensures that
there is at most one open acquire event for every lock. In Figure1(b),ğ‘šğ‘ğ‘¡ğ‘â„ğœ(ğ‘’15)=ğ‘’2andğ‘’10is the only open acquire event. So
the event set is lock-feasible.
Observation-feasible. We callEğœâ€²is observation-feasible if âˆ€ğ‘Ÿ
âˆˆR(Eğœâ€²),ğ‘œğ‘ğ‘ ğœ(ğ‘Ÿ)âˆˆEğœâ€². It guarantees that there is a write event
writing the value read by later events. In Figure 1(b), ğ‘’1writes the
variableğ‘¥, which is read by later events ğ‘’3andğ‘’9. So the event set
is observation-feasible.
3.3 Trace-Closed Partial Orders
In this paper, we use partial orders to represent the execution order
of events. Given two partial orders ğ‘ƒandğ‘„over an event set ğ¸, we
say thatğ‘„refinesğ‘ƒ, ifâˆ€(ğ‘’1,ğ‘’2âˆˆğ¸Ã“ğ‘’1<ğ‘ƒğ‘’2), thenğ‘’1<ğ‘„ğ‘’2. We
denote it asğ‘„âŠ‘ğ‘ƒand say that ğ‘ƒisweaker thanğ‘„. A weaker partial
order means less constraints on the execution orders of events, and
we can construct more possible traces based on it. We give the
following conditions to construct a partial order required by a
feasible trace. The insight here is to first construct a basic partial
order that makes some events ordered. And then, considering the
newly ordered events, we add new ordering between two events
incrementally to meet all the constraints.
Given a trace ğœand a feasible event set ğ¸âŠ†E(ğœ), we useğ‘ƒto
represent a partial order over ğ¸that makes a trace feasible. First, ğ‘ƒâŠ‘
ğ‘‡ğ‘‚(ğ¸)ensures that every event pair in the same thread is ordered by
ğ‘ƒ. Then, for every release eventğ‘Ÿğ‘’ğ‘™âˆˆLğ‘…(ğ¸), ifğ‘‚ğ‘ğ‘›ğ´ğ‘ğ‘ğœ(ğ¸)â‰ âˆ…,
then for each event ğ‘ğ‘ğ‘âˆˆğ‘‚ğ‘ğ‘›ğ´ğ‘ğ‘ğœ(ğ¸)andğ‘™ğ‘œğ‘(ğ‘ğ‘ğ‘)=ğ‘™ğ‘œğ‘(ğ‘Ÿğ‘’ğ‘™), we
haveğ‘Ÿğ‘’ğ‘™<ğ‘ƒğ‘ğ‘ğ‘. It ensures that every open acquire event is the last
one that operates the lock. Otherwise, the lock will not be released.
Finally, for every read eventğ‘ŸâˆˆR(ğ¸), we haveğ‘œğ‘ğ‘ ğœ(ğ‘Ÿ)<ğ‘ƒğ‘Ÿ. It
ensures that every read event executes after the write event it
observes in trace ğœ. We say that such a partial order respects trace
ğœand useğ‘…ğ‘ ğœ(ğ¸)to denote the weakest partial order respecting
ğœ. The trace-respecting partial order ğ‘ƒoffers basic constraints on
execution orders between event pairs required by a feasible trace.
Letğœbe a trace,ğ¸âŠ† E(ğœ)be a feasible event set, and ğ‘ƒbe
a partial order over ğ¸that respects ğœ. To ensure that the criti-
cal sections on the same lock do not overlap, for every release
event pairğ‘Ÿğ‘’ğ‘™1,ğ‘Ÿğ‘’ğ‘™ 2âˆˆLğ‘…(ğ¸), letğ‘ğ‘ğ‘ 1=ğ‘šğ‘ğ‘¡ğ‘â„ğœ(ğ‘Ÿğ‘’ğ‘™1)andğ‘ğ‘ğ‘ 2=
ğ‘šğ‘ğ‘¡ğ‘â„ğœ(ğ‘Ÿğ‘’ğ‘™2), ifğ‘ğ‘ğ‘ 1<ğ‘ƒğ‘Ÿğ‘’ğ‘™2andğ‘™ğ‘œğ‘(ğ‘Ÿğ‘’ğ‘™2)=ğ‘™ğ‘œğ‘(ğ‘ğ‘ğ‘ 1), we have
ğ‘Ÿğ‘’ğ‘™1<ğ‘ƒğ‘ğ‘ğ‘ 2(see Figure 2(a)). We say that such a partial order
islock-closed . To ensure that every read event observes the same
event as it does in ğœ, for every read eventğ‘ŸâˆˆR(ğ¸), letğ‘¤=ğ‘œğ‘ğ‘ ğœ(ğ‘Ÿ),
and for every write eventğ‘¤â€²âˆˆW(ğ¸)\{ğ‘¤}such thatğ‘¤â€²â‰ğ‘Ÿ, we
have that (i) if ğ‘¤â€²<ğ‘ƒğ‘Ÿ, thenğ‘¤â€²<ğ‘ƒğ‘¤(see Figure 2(b)) and (ii) if
ğ‘¤<ğ‘ƒğ‘¤â€², thenğ‘Ÿ<ğ‘ƒğ‘¤â€²(see Figure 2(c)). We say that such a partial
order is observation-closed . The two rules make ğ‘¤the nearest event
writing the same variable as ğ‘Ÿreads. A partial order is trace-closed
(or simply closed ) if it is lock-closed and observation-closed. We
define the closure of ğ‘ƒas the weakest partial order ğ‘ƒâ€²which is
closed and refines ğ‘ƒ. That is,ğ‘ƒâŠ‘ğ‘ƒâ€²and there is no closed partial
orderğ‘„such thatğ‘ƒâ€²âŠ‘ğ‘„. Ifğ‘ƒâ€²does not exist, ğ‘ƒhas no closure.
3.4 Trace Construction Algorithm
Algorithm 1 presents the pseudo-code of constructing a feasible
trace from a feasible event set or deducing its nonexistence. The
inputs include a trace ğœand a feasible event set ğ¸âŠ†E(ğœ). We
represent a partial order ğ‘ƒas a graphGwhere nodes are events,
283Detecting Concurrency Vulnerabilities Based on Partial Orders of Memory and Thread Events ESEC/FSE â€™21, August 23â€“28, 2021, Athens, Greece
Figure 2: Illustrations of lock and observation-closed par-
tial orders. Solid arrows are observed execution orders and
dashed ones are partial orders added to make a trace closed.
and edges represent their execution orders. Figure 3 shows an
example of a partial order graph. The indices of events in Figure
3 represent the execution order in trace ğœ, i.e., ifğ‘–<ğ‘—,ğ‘’ğ‘–<ğœğ‘’ğ‘—.
The thick arrows throughout the events of each thread are thread-
order edges. Initially, we construct ğ‘ƒoverğ¸(line 1) by connecting
every threadâ€™s events. Then, we insert edges to Gto makeğ‘ƒlock-
closed and observation-closed (line 2). The solid line arrows are
observation edges ( ğ‘’1â†’ğ‘’7,ğ‘’5â†’ğ‘’10), and the dashed ones are
lock edges ( ğ‘’4â†’ğ‘’9). If a cycle is formed, it means that conflicts
occur among the constraints to construct a trace-closed partial
order. That is, ğ‘ƒhas no closure, and the algorithm returns âŠ¥(lines
3-4). Note that a closed partial order may still contain unordered
conflicting events, preventing us from getting a feasible trace. If
we get a closed partial order ğ‘„, for every conflicting event pair,
we insert an edge between the two events to ğ‘„. Note that after
inserting the new edge, ğ‘„may not be closed (see Figure 2). We
need to insert additional edges and get a new closure of ğ‘„(lines
5-8). We make two conflicting events keep their original execution
order (lines 6-7). The insight here is that it is mostly like to avoid
forming a cycle [ 26], although it may fail in some situations [ 23]. If
no cycle is formed, we build a feasible trace from ğ‘„. Given an event
ğ‘’and a thread ğ‘–, ifâˆƒğ‘’â€²âˆˆğ¸,ğ‘¡ğ‘–ğ‘‘(ğ‘’â€²)=ğ‘–,ğ‘’â€²<ğ‘„ğ‘’andÂšğ‘’â€²â€²âˆˆğ¸such
thatğ‘¡ğ‘–ğ‘‘(ğ‘’â€²â€²)=ğ‘–,ğ‘’â€²â€²<ğ‘„ğ‘’andğ‘’â€²<ğ‘„ğ‘’â€²â€², thenğ‘’â€²is a predecessor of
ğ‘’in threadğ‘–. For example, as shown in Figure 3, the predecessors of
ğ‘’8inğ‘¡1andğ‘¡2areğ‘’1andğ‘’7, respectively, and ğ‘’8has no predecessor
inğ‘¡3. Initially,ğ‘‡is an empty trace. If an event ğ‘’has no predecessor
inğ‘„or its predecessors are already in ğ‘‡, we addğ‘’to the new trace
ğ‘‡and remove it from ğ¸(lines 11-14).
Figure 3: An example of a partial order graph. Solid lines are
observation edges and dashed lines are lock edges.Algorithm 1: ConstructFeasibleTrace
Input: A traceğœ, and a feasible set ğ¸
Output: A feasible trace if it exists, otherwise âŠ¥
1ğ‘ƒâ†ğ‘…ğ‘ ğœ(ğ¸)
2ğ‘„â†GetClosure( ğ‘¡,ğ‘ƒ,ğ¸ )
3ifğ‘„=âŠ¥then // A cycle is formed
4 returnâŠ¥
5whileâˆƒğ‘’1,ğ‘’2âˆˆğ¸s.t.ğ‘’1â‰ğ‘’2andğ‘’1âˆ¥ğ‘„ğ‘’2do
6 ifğ‘’1>ğ‘¡ğ‘Ÿğ‘’2then
7 swap(ğ‘’1,ğ‘’2)
8ğ‘„â†InsertAndGetClosure( ğ‘„,ğ‘’ 1â†’ğ‘’2)
9 ifğ‘„=âŠ¥then // A cycle is formed
10 returnâŠ¥
11Letğ‘‡be an empty list
12whileâˆƒğ‘’âˆˆğ¸s.t.ğ‘’has no predecessor in ğ‘„or its predecessors
have been added to ğ‘‡do
13ğ‘‡.append(ğ‘’)
14ğ¸â†ğ¸\{ğ‘’} // Remove e
15returnğ‘‡
4 VULNERABILITY DETECTION
This section describes the approach to construct a feasible trace
exposing a concurrency vulnerability. We first extract vulnerability-
potential event pairs and then compute their feasible event sets.
Then we attempt to construct a feasible trace by Algorithm 1.
4.1 Potential Event Pairs
Given a trace ğœ, and an exchangeable event pair ğ‘’1,ğ‘’2âˆˆEğœ, if
ğ‘’1<ğœğ‘’2,ğ‘¡ğ‘–ğ‘‘(ğ‘’1)â‰ ğ‘¡ğ‘–ğ‘‘(ğ‘’2), and the exchange of their execution
order may cause a vulnerability (e.g., if ğ‘’1writes a memory address
and thenğ‘’2frees the memory, the exchange of their execution may
cause an UAF), we call them a vulnerability-potential event pair (or
simply potential pair). The following describes the algorithms to
get the potential pairs of UAF, NPD, and DF.
4.1.1 UAF. A UAF occurs when a block of previously freed memory
is used. Figure 4 shows how thread-interleaving causes a UAF. There
are two events in Figure 4(a). Pointer ğ‘is dereferenced ( 1â—‹) first in
threadğ‘¡1and is then freed ( 2â—‹) in threadğ‘¡2. If their execution order
is exchanged, and ğ‘is freed first in ğ‘¡2, then an UAF occurs when it
is being dereferenced in ğ‘¡1. Figure 4(b) shows other cases where a
UAF occurs. There are three events in two threads. In Figure 4(b), a
pointer is freed ( 1â—‹) first, and then a not NULL value ğ‘is written to
it (2â—‹), at last it is dereferenced ( 4â—‹). In this case, if ğ‘=ğ‘executes
after 4â—‹, whenğ‘is dereferenced ( 4â—‹) after it is free ( 1â—‹), then an
UAF occurs. Note that ğ‘=ğ‘may also be in other threads, making
the problem more complex. For example, let ğ‘=ğ‘in threadğ‘¡1, the
original trace is 1â—‹,3â—‹,4â—‹, if there is a trace 3â—‹,1â—‹,4â—‹, then an
UAF occurs. Therefore, event pairs ( 1â—‹,2â—‹) in Figure 4(a) and ( 1â—‹,
3â—‹) or ( 2â—‹,4â—‹) in Figure 4(b) are UAF vulnerability-potential pairs.
Algorithm 2 shows the pseudo-code to get potential event pairs
in a traceğœthat may cause UAFs. Given a trace ğœand an event ğ‘’, we
use the function ğµğ‘’ğ‘“ğ‘œğ‘Ÿğ‘’R(ğ‘’,ğ‘–)(ğµğ‘’ğ‘“ğ‘œğ‘Ÿğ‘’W(ğ‘’,ğ‘–),ğµğ‘’ğ‘“ğ‘œğ‘Ÿğ‘’ğ¹ğ‘Ÿğ‘’ğ‘’(ğ‘’,ğ‘–)
284ESEC/FSE â€™21, August 23â€“28, 2021, Athens, Greece Kunpeng Yu, Chenxu Wang, Yan Cai, Xiapu Luo, and Zijiang Yang
Figure 4: Illustrations of how UAFs occur. The gray events
are other possible events in different thread.
orğµğ‘’ğ‘“ğ‘œğ‘Ÿğ‘’ğ·ğ‘’ğ‘Ÿğ‘’ğ‘“(ğ‘’,ğ‘–)) to denote the first read (write ,free orde-
reference ) eventğ‘’â€²beforeğ‘’thatğ‘¡ğ‘–ğ‘‘(ğ‘’â€²)=ğ‘–andğ‘™ğ‘œğ‘(ğ‘’â€²)=ğ‘™ğ‘œğ‘(ğ‘’).
First, for every free event ğ‘’ğ‘“ğ‘Ÿğ‘’ğ‘’âˆˆğ¹ğ‘Ÿğ‘’ğ‘’(Eğœ)on a pointer, we get the
first dereference ğ‘’ğ‘‘ğ‘’ğ‘Ÿğ‘’ğ‘“ event before ğ‘’ğ‘“ğ‘Ÿğ‘’ğ‘’ on the same pointer
in each thread ğ‘–. If the event exists and ğ‘–â‰ ğ‘¡ğ‘–ğ‘‘(ğ‘’ğ‘“ğ‘Ÿğ‘’ğ‘’), we add
ğ‘’ğ‘‘ğ‘’ğ‘Ÿğ‘’ğ‘“, ğ‘’ğ‘“ğ‘Ÿğ‘’ğ‘’
to the potential pair set ğ‘†(lines 2-7). Then for every
dereference eventğ‘’ğ‘‘ğ‘’ğ‘Ÿğ‘’ğ‘“âˆˆğ·ğ‘’ğ‘Ÿğ‘’ğ‘“(Eğœ)on a pointer and every
threadğ‘–, we get the first write eventğ‘¤beforeğ‘’ğ‘‘ğ‘’ğ‘Ÿğ‘’ğ‘“ on the same
pointer in thread ğ‘–(lines 8-10). If ğ‘¤does not write NULL, then
for every thread ğ‘—, we get the first free eventğ‘’ğ‘—
ğ‘“ğ‘Ÿğ‘’ğ‘’in the thread
that frees the same pointer before ğ‘¤such thatÂšğ‘¤â€²âˆˆW(Eğœ),
ğ‘¡ğ‘–ğ‘‘(ğ‘¤â€²)=ğ‘—andğ‘’ğ‘—
ğ‘“ğ‘Ÿğ‘’ğ‘’<ğœğ‘¤â€²<ğœğ‘¤(lines 11-17). If there is no such
an eventğ‘’ğ‘—
ğ‘“ğ‘Ÿğ‘’ğ‘’for every thread ğ‘—, it continues (line 18). Otherwise,
we add
ğ‘¤,ğ‘’ğ‘‘ğ‘’ğ‘Ÿğ‘’ğ‘“
toğ‘†ifğ‘¡ğ‘–ğ‘‘(ğ‘¤)â‰ ğ‘¡ğ‘–ğ‘‘(ğ‘’ğ‘‘ğ‘’ğ‘Ÿğ‘’ğ‘“)(lines 19-20). For
every thread ğ‘—andğ‘’ğ‘—
ğ‘“ğ‘Ÿğ‘’ğ‘’(if exists), if ğ‘—â‰ ğ‘¡ğ‘–ğ‘‘(ğ‘¤), we add
ğ‘’ğ‘—
ğ‘“ğ‘Ÿğ‘’ğ‘’,ğ‘¤
toğ‘†(lines 21-23).
4.1.2 NPD. An NPD occurs when a NULL pointer is dereferenced.
As shown in Figure 5(a), a pointer ğ‘is dereferenced first and then
set to be NULL. If the execution order of them is exchanged, then an
NPD occurs. Like Figure 4(b), Figure 5(b) shows how three events
cause an NPD. If the execution order of the two write events ( 1â—‹,
3â—‹) is exchanged, then an NPD occurs. And if the dereference
event ( 4â—‹) executes before the write event that sets ğ‘a new value
(2â—‹), an NPD also occurs. The difference between Figure 4(b) and
5(b) is that the first event in Figure 4(b) is a free event while in
Figure 5(b), the first event is a write event and assigns NULL to ğ‘.
The algorithm that gets potential NPD event pairs in a trace ğœis
similar to Algorithm 2. We omit it for space concerns.
4.1.3 DF. A DF occurs when a block of memory is freed twice. As
shown in Figure 6, a pointer is assigned with a new value ( 2â—‹) after
being freed ( 1â—‹) and then be freed once again ( 4â—‹). The exchanges of
1â—‹and 2â—‹may cause an DF. Note that the assigning instruction can
also be in thread ğ‘¡1(see 3â—‹in Figure 6), which make the situation
more complex. Algorithm 3 shows the pseudo-code to get potential
event DF event pairs. For every free eventğ‘’ğ‘“ğ‘Ÿğ‘’ğ‘’âˆˆğ¹ğ‘Ÿğ‘’ğ‘’(Eğœ)on a
pointer and every thread ğ‘–, we get the first write eventğ‘¤on the
same pointer before ğ‘’ğ‘“ğ‘Ÿğ‘’ğ‘’ in threadğ‘–(lines 2-5). If ğ‘¤does not write
NULL, we get the free eventsğ‘’ğ‘—
ğ‘“ğ‘Ÿğ‘’ğ‘’â€²in every thread ğ‘—that freesAlgorithm 2: GetPotentialUAF
Input: A traceğœ
Output: Event pairs that may cause UAFs
1Letğ‘†be an empty set
2foreach free eventğ‘’ğ‘“ğ‘Ÿğ‘’ğ‘’âˆˆğ¹ğ‘Ÿğ‘’ğ‘’(Eğœ)do
3 foreach threadğ‘–do
4 ifğ‘–â‰ ğ‘¡ğ‘–ğ‘‘(ğ‘’ğ‘“ğ‘Ÿğ‘’ğ‘’)then
5 ğ‘’ğ‘‘ğ‘’ğ‘Ÿğ‘’ğ‘“â†ğµğ‘’ğ‘“ğ‘œğ‘Ÿğ‘’ğ·ğ‘’ğ‘Ÿğ‘’ğ‘“(ğ‘’ğ‘“ğ‘Ÿğ‘’ğ‘’,ğ‘–)
6 ifğ‘’ğ‘‘ğ‘’ğ‘Ÿğ‘’ğ‘“â‰ âŠ¥then
7 ğ‘†â†ğ‘†âˆª{(ğ‘’ğ‘‘ğ‘’ğ‘Ÿğ‘’ğ‘“,ğ‘’ğ‘“ğ‘Ÿğ‘’ğ‘’)}
8foreach dereference event ğ‘’ğ‘‘ğ‘’ğ‘Ÿğ‘’ğ‘“âˆˆğ·ğ‘’ğ‘Ÿğ‘’ğ‘“(Eğœ)do
9 foreach threadğ‘–do
10ğ‘¤â†ğµğ‘’ğ‘“ğ‘œğ‘Ÿğ‘’W
ğ‘™ğ‘œğ‘(ğ‘’ğ‘‘ğ‘’ğ‘Ÿğ‘’ğ‘“)(ğ‘’ğ‘‘ğ‘’ğ‘Ÿğ‘’ğ‘“)
11 ifğ‘¤â‰ âŠ¥then
12 ifğ‘¤.ğ‘”ğ‘’ğ‘¡ğ‘Šğ‘Ÿğ‘–ğ‘¡ğ‘’ğ‘‰ğ‘ğ‘™ğ‘¢ğ‘’()=ğ‘ğ‘ˆğ¿ğ¿ then continue;
13 letğ‘“ğ‘Ÿğ‘’ğ‘’ğ‘  be an empty set
14 foreach threadğ‘—do
15 ğ‘’ğ‘“ğ‘Ÿğ‘’ğ‘’â†ğµğ‘’ğ‘“ğ‘œğ‘Ÿğ‘’ğ¹ğ‘Ÿğ‘’ğ‘’(ğ‘¤,ğ‘—)
16 ifğ‘’ğ‘“ğ‘Ÿğ‘’ğ‘’â‰ âŠ¥and there is no ğ‘¤â€²âˆˆ
W(Eğœ),ğ‘¡ğ‘–ğ‘‘(ğ‘¤â€²)=ğ‘—âˆ§ğ‘’ğ‘“ğ‘Ÿğ‘’ğ‘’<ğ‘¡ğ‘Ÿğ‘¤â€²<ğ‘¡ğ‘Ÿğ‘¤
then
17 ğ‘“ğ‘Ÿğ‘’ğ‘’ğ‘ â†ğ‘“ğ‘Ÿğ‘’ğ‘’ğ‘ âˆª{ğ‘’ğ‘“ğ‘Ÿğ‘’ğ‘’}
18 ifğ‘“ğ‘Ÿğ‘’ğ‘’ğ‘ .ğ‘–ğ‘ ğ¸ğ‘šğ‘ğ‘¡ğ‘¦()then continue ;
19 ifğ‘¡ğ‘–ğ‘‘(ğ‘¤)â‰ ğ‘¡ğ‘–ğ‘‘(ğ‘’ğ‘‘ğ‘’ğ‘Ÿğ‘’ğ‘“)then
20 ğ‘†â†ğ‘†âˆª{(ğ‘¤,ğ‘’ğ‘‘ğ‘’ğ‘Ÿğ‘’ğ‘“)}
21 foreachğ‘’ğ‘“ğ‘Ÿğ‘’ğ‘’âˆˆğ‘“ğ‘Ÿğ‘’ğ‘’ğ‘  do
22 ifğ‘¡ğ‘–ğ‘‘(ğ‘’ğ‘“ğ‘Ÿğ‘’ğ‘’)â‰ ğ‘¡ğ‘–ğ‘‘(ğ‘¤)then
23 ğ‘†â†ğ‘†âˆª{(ğ‘’ğ‘“ğ‘Ÿğ‘’ğ‘’,ğ‘¤)}
24return S
Figure 5: Illustrations of how NPDs occur. The gray events
are other possible events in different thread.
the same pointer before ğ‘¤such thatÂšğ‘¤â€²âˆˆW(Eğœ), ğ‘¡ğ‘–ğ‘‘(ğ‘¤â€²)=ğ‘—
andğ‘’ğ‘—
ğ‘“ğ‘Ÿğ‘’ğ‘’â€²<ğ‘¡ğ‘Ÿğ‘¤â€²<ğ‘¡ğ‘Ÿğ‘¤(lines 6-11). If there is no such an event
ğ‘’ğ‘—
ğ‘“ğ‘Ÿğ‘’ğ‘’â€²for every thread ğ‘—, we continue (lines 12). Otherwise, we add
ğ‘¤,ğ‘’ğ‘“ğ‘Ÿğ‘’ğ‘’
to the potential pair set ğ‘†if they are not in the same
285Detecting Concurrency Vulnerabilities Based on Partial Orders of Memory and Thread Events ESEC/FSE â€™21, August 23â€“28, 2021, Athens, Greece
thread (lines 13-14). And for every thread ğ‘—andğ‘’ğ‘—
ğ‘“ğ‘Ÿğ‘’ğ‘’â€²(if exists), if
ğ‘—â‰ ğ‘¡ğ‘–ğ‘‘(ğ‘¤), then we add
ğ‘’ğ‘—
ğ‘“ğ‘Ÿğ‘’ğ‘’â€²,ğ‘¤
toğ‘†(lines 15-17).
Figure 6: Illustrations of how DFs occur. The gray events are
other possible events in different thread.
Algorithm 3: GetPotentialDF
Input: A traceğœ
Output: Event pairs that may cause DFs
1letğ‘†be an empty set
2foreach free eventğ‘’ğ‘“ğ‘Ÿğ‘’ğ‘’âˆˆğ¹ğ‘Ÿğ‘’ğ‘’(Eğœ)do
3 foreach threadğ‘–do
4ğ‘¤â†ğµğ‘’ğ‘“ğ‘œğ‘Ÿğ‘’W(ğ‘’ğ‘“ğ‘Ÿğ‘’ğ‘’,ğ‘–)
5 ifğ‘¤â‰ âŠ¥then
6 ifğ‘¤.ğ‘”ğ‘’ğ‘¡ğ‘Šğ‘Ÿğ‘–ğ‘¡ğ‘’ğ‘‰ğ‘ğ‘™ğ‘¢ğ‘’()=ğ‘ğ‘ˆğ¿ğ¿ then continue;
7 letğ‘“ğ‘Ÿğ‘’ğ‘’ğ‘  be an empty set
8 foreach threadğ‘—do
9 ğ‘’ğ‘“ğ‘Ÿğ‘’ğ‘’â†ğµğ‘’ğ‘“ğ‘œğ‘Ÿğ‘’ğ¹ğ‘Ÿğ‘’ğ‘’(ğ‘¤,ğ‘—)
10 ifğ‘’ğ‘“ğ‘Ÿğ‘’ğ‘’â‰ âŠ¥and there is no ğ‘¤â€²âˆˆ
W(Eğœ),ğ‘¡ğ‘–ğ‘‘(ğ‘¤â€²)=ğ‘—âˆ§ğ‘’ğ‘“ğ‘Ÿğ‘’ğ‘’<ğ‘¡ğ‘Ÿğ‘¤â€²<ğ‘¡ğ‘Ÿğ‘¤
then
11 ğ‘“ğ‘Ÿğ‘’ğ‘’ğ‘ â†ğ‘“ğ‘Ÿğ‘’ğ‘’ğ‘ âˆª{ğ‘’ğ‘“ğ‘Ÿğ‘’ğ‘’}
12 ifğ‘“ğ‘Ÿğ‘’ğ‘’ğ‘ .ğ‘–ğ‘ ğ¸ğ‘šğ‘ğ‘¡ğ‘¦()then continue ;
13 ifğ‘¡ğ‘–ğ‘‘(ğ‘¤)â‰ ğ‘¡ğ‘–ğ‘‘(ğ‘’ğ‘“ğ‘Ÿğ‘’ğ‘’)then
14 ğ‘†â†ğ‘†âˆª{(ğ‘¤,ğ‘’ğ‘“ğ‘Ÿğ‘’ğ‘’)}
15 foreachğ‘’ğ‘“ğ‘Ÿğ‘’ğ‘’â€²âˆˆğ‘“ğ‘Ÿğ‘’ğ‘’ğ‘  do
16 ifğ‘¡ğ‘–ğ‘‘(ğ‘’ğ‘“ğ‘Ÿğ‘’ğ‘’â€²)â‰ ğ‘¡ğ‘–ğ‘‘(ğ‘¤)then
17 ğ‘†â†ğ‘†âˆª{(ğ‘’ğ‘“ğ‘Ÿğ‘’ğ‘’â€²,ğ‘¤)}
18return S
4.2 Computing Feasible Event Sets
Given a trace ğœand a potential pair ğ‘’1,ğ‘’2âˆˆEğœ, we first compute a
feasible event set of an event pair in different threads. Then we con-
struct a trace ğœâ€²in whichğ‘’2executes before ğ‘’1to prove the existence
of a vulnerability. According to previous definitions, a feasible event
set must be prefix-closed, lock-feasible, and observation-feasible.
Letğ¸be the feasible set we want. Two cases need to be considered
for computing a potential pairâ€™s feasible set. If the two events are not
protected by the same lock, the reordered trace ğœâ€²should be ended
withğ‘’2,ğ‘’1(i.e.,ğ‘’1is right behind ğ‘’2and the trace is like ğ‘’,...,ğ‘’ 2,ğ‘’1).
In this case, we can easily construct a feasible set ğ¸=Eğœâ€²\{ğ‘’2,ğ‘’1}.
If the two events are protected by the same lock(s), we cannot put
them together at the end of a trace because of the lock semantic, i.e.,
ğ‘’1must execute after that all common locks of the two events arereleased by the thread ğ‘¡ğ‘–ğ‘‘(ğ‘’2). Letğ‘™be the last released common
locks,ğ‘Ÿğ‘’ğ‘™(ğ‘™)be the first release event onğ‘™afterğ‘’2inğ‘¡ğ‘–ğ‘‘(ğ‘’2),
andğ‘ğ‘ğ‘(ğ‘™)be the first acquire event onğ‘™beforeğ‘’1inğ‘¡ğ‘–ğ‘‘(ğ‘’1),
the reordered trace is like ğ‘’,...,ğ‘’ 2,...,ğ‘Ÿğ‘’ğ‘™(ğ‘™),ğ‘ğ‘ğ‘(ğ‘™),...,ğ‘’ 1and
ğ¸=Eğœâ€²\{ğ‘’1}. Note thatğ¸does not contain ğ‘’1andğ‘’2simultaneously
because it may make ğ¸not observation-feasible. If we get a feasible
traceğœâ€²fromğ¸, the trace constructed by adding ğ‘’2,ğ‘’1orğ‘’1to the
end ofğœâ€²is also feasible. Since there may be several additional
events between ğ‘’2andğ‘’1inğœâ€², we need to check whether the
vulnerability will occur in ğœâ€²at last to avoid false-positive errors.
In this paper, we first find the candidate feasible event sets of ğ‘’1
andğ‘’2separately and then get their union. We employ the relative
causal cones of an event relative to a thread to compute the feasible
set for an event [23].
Relative Causal Cones: Given a trace ğœ, an event pair ğ‘’1,ğ‘’2âˆˆ
Eğœ, letğ‘¡1=ğ‘¡ğ‘–ğ‘‘(ğ‘’1)andğ‘¡2=ğ‘¡ğ‘–ğ‘‘(ğ‘’2), the causal cone ğ‘…ğ¶ğ‘œğ‘›ğ‘’ğœ(ğ‘’1,ğ‘¡2)
ofğ‘’1relative toğ‘¡2represents the smallest event set satisfying:
(1) For each ğ‘’â€²âˆˆEğœ, ifğ‘’â€²<ğœâ†¾ğ‘¡1ğ‘’1, thenğ‘’â€²âˆˆğ‘…ğ¶ğ‘œğ‘›ğ‘’ğœ(ğ‘’1,ğ‘¡2).
(2)For every read eventğ‘ŸâˆˆR(Eğœ)âˆ©ğ‘…ğ¶ğ‘œğ‘›ğ‘’ğœ(ğ‘’1,ğ‘¡2), we have
ğ‘œğ‘ğ‘ ğœ(ğ‘Ÿ)âˆˆğ‘…ğ¶ğ‘œğ‘›ğ‘’ğœ(ğ‘’1,ğ‘¡2).
(3)For every lock-acquire event ğ‘ğ‘ğ‘âˆˆLğ´(Eğœ)âˆ©ğ‘…ğ¶ğ‘œğ‘›ğ‘’ğœ(ğ‘’1,ğ‘¡2),
ifğ‘¡ğ‘–ğ‘‘(ğ‘ğ‘ğ‘)â‰ ğ‘¡1andğ‘¡ğ‘–ğ‘‘(ğ‘ğ‘ğ‘)â‰ ğ‘¡2, thenğ‘šğ‘ğ‘¡ğ‘â„ğœ(ğ‘ğ‘ğ‘)âˆˆ
ğ‘…ğ¶ğ‘œğ‘›ğ‘’ğœ(ğ‘’1,ğ‘¡2).
(4)For every event pair ğ‘’â€²âˆˆğ‘…ğ¶ğ‘œğ‘›ğ‘’ğœ(ğ‘’1,ğ‘¡2)andğ‘’â€²â€²âˆˆEğœ, ifğ‘’â€²â€²
<ğœâ†¾ğ‘¡ğ‘–ğ‘‘(ğ‘’â€²)ğ‘’â€², thenğ‘’â€²â€²âˆˆğ‘…ğ¶ğ‘œğ‘›ğ‘’ğœ(ğ‘’1,ğ‘¡2).
ğ‘…ğ¶ğ‘œğ‘›ğ‘’ğœ(ğ‘’1,ğ‘¡2)is prefix-closed and observation-feasible but may
not be lock-feasible (there may be open acquires on the same lock
inğ‘¡1andğ‘¡2). Algorithm 4 shows the computation of a feasible
set via relative casual cones. We first consider the case that two
events are not protected by the same lock. A candidate feasible
set ofğ‘’1andğ‘’2isğ¸=ğ‘…ğ¶ğ‘œğ‘›ğ‘’ğœ(ğ‘’1,ğ‘¡2)âˆªğ‘…ğ¶ğ‘œğ‘›ğ‘’ğœ(ğ‘’2,ğ‘¡1)(line 3).
Rules 1, 2, and 4 ensure that ğ¸is prefix-closed and observation-
feasible. Rule 3 guarantees that there are no two open acquires on
the same lock. Note that this rule does not apply for the events
inğ‘¡1andğ‘¡2, becauseğ¸should only contain events before both ğ‘’1
andğ‘’2. These rules do not ensure that ğ‘’2âˆ‰ğ‘…ğ¶ğ‘œğ‘›ğ‘’ğœ(ğ‘’1,ğ‘¡2)and
ğ‘’1âˆ‰ğ‘…ğ¶ğ‘œğ‘›ğ‘’ğœ(ğ‘’2, ğ‘¡1). Moreover, the union of the two causal cones
is not always feasible. Hence, we must perform additional checks
(lines 4-5). If ğ‘’1andğ‘’2are protected by the same lock(s), let ğ‘™be
the last released one of the common locks (line 8), ğ‘Ÿğ‘’ğ‘™(ğ‘™)be the
first release event onğ‘™afterğ‘’2inğ‘¡ğ‘–ğ‘‘(ğ‘’2)(line 9), the candidate
feasible set is ğ¸=ğ‘…ğ¶ğ‘œğ‘›ğ‘’ğœ(ğ‘’1,ğ‘¡2)âˆªğ‘…ğ¶ğ‘œğ‘›ğ‘’ğœ(ğ‘Ÿğ‘’ğ‘™(ğ‘™),ğ‘¡1)âˆª{ğ‘Ÿğ‘’ğ‘™(ğ‘™)}
(line10). Similarly, we need to ensure that ğ‘’1âˆ‰ğ¸andğ¸are feasible
(lines 11-12). Now the feasible event set of the motivating example
in Figure 1 can be computed as follows: ğ‘…ğ¶ğ‘œğ‘›ğ‘’ğœ(ğ‘’11,ğ‘¡1)={ğ‘’9,ğ‘’10},
ğ‘…ğ¶ğ‘œğ‘›ğ‘’ğœ(ğ‘’15,ğ‘¡3)={ğ‘’1,ğ‘’2,ğ‘’3,ğ‘’4,ğ‘’5,ğ‘’13,ğ‘’14}, and the feasible set ğ¸=
{ğ‘’ğ‘–}5
ğ‘–=1âˆª{ğ‘’ğ‘–}10
ğ‘–=9âˆª{ğ‘’ğ‘–}15
ğ‘–=13.
5 IMPLEMENTATION
Figure 7 presents an overview of ConVulPOE , which consists of
two components: trace recorder and vulnerability predictor. Trace
recorder generates execution traces of a program, and vulnerability
predictor outputs potential vulnerabilities by exploring the traces.
286ESEC/FSE â€™21, August 23â€“28, 2021, Athens, Greece Kunpeng Yu, Chenxu Wang, Yan Cai, Xiapu Luo, and Zijiang Yang
Algorithm 4: GetFeasibleSet
Input: A traceğœ, and two conflicting events ğ‘’1,ğ‘’2âˆˆEğœ
Output: A feasible event set if exists, otherwise âŠ¥
1ğ‘¡1,ğ‘¡2â†ğ‘¡ğ‘–ğ‘‘(ğ‘’1),ğ‘¡ğ‘–ğ‘‘(ğ‘’2)
2ifğ‘’1andğ‘’2are not protected by the same lock then
3ğ¸â†ğ‘…ğ¶ğ‘œğ‘›ğ‘’ğœ(ğ‘’1,ğ‘¡2)âˆªğ‘…ğ¶ğ‘œğ‘›ğ‘’ğœ(ğ‘’2,ğ‘¡1)
4 if{ğ‘’1,ğ‘’2}âˆ©ğ¸â‰ âˆ…orğ¸is not feasible then
5 returnâŠ¥
6 returnğ¸
7else
8 Letğ‘™be the last lock that is released of the common
locks ofğ‘’1andğ‘’2
9 Letğ‘Ÿğ‘’ğ‘™(ğ‘™)be the first lock-release event on ğ‘™afterğ‘’2inğ‘¡2
10ğ¸â†ğ‘…ğ¶ğ‘œğ‘›ğ‘’ğœ(ğ‘’1,ğ‘¡2)âˆªğ‘…ğ¶ğ‘œğ‘›ğ‘’ğœ(ğ‘Ÿğ‘’ğ‘™(ğ‘™),ğ‘¡1)âˆª{ğ‘Ÿğ‘’ğ‘™(ğ‘™)}
11 ifğ‘’1âˆˆğ¸orğ¸is not feasible then
12 returnâŠ¥
13 returnğ¸
Figure 7: An overview of ConVulPOE .
5.1 Instrumentation and Record
To record the execution trace, we need to instrument the original
program. We employ Intel Pin [ 20], which instruments thread op-
erations with POSIX threading primitives, to achieve this goal. We
instrument the malloc andfree functions (which is also used in
newanddelete operators) to record dynamic memory allocation.
The limitation of Pin is that it cannot get a pointer-dereference
directly. We adopt a heuristic approach which is used in prior
work [ 4]. A pointer dereference usually consists of two consecutive
instructions, including a read instruction and a memory access
instruction. The read instructionâ€™s operand register is used as the
base register of the memory access.
5.2 Vulnerability Prediction
The vulnerability predictor is independent of the instrumentation. It
finds potential event pairs based on the traces generated by the trace
recorder. We construct a partial order incrementally by inserting
new events in an order as the same as they executed. In practice,
we also consider other thread-related operations and add additional
edges in the partial order graph. For example, we insert an edge
from every thread-create event to the first event in the created
thread. And for every thread-join event and the target thread it
waits for, we insert an edge from the last event in the target thread
to the thread-join event.6 EXPERIMENTS
In this section, we conduct experiments to evaluate the performance
ofConVulPOE and answer the flowing questions:
â€¢RQ1: CanConVulPOE detect the three kinds of concurrency
memory vulnerabilities?
â€¢RQ2: What is the capability of ConVulPOE in detecting
vulnerabilities in real programs with fuzzing tools?
â€¢RQ3: How does the number of threads influence ConVul-
POEâ€™s detection capability?
6.1 Effectiveness Validation
We run ConVulPOE on a CVE benchmark [ 3] to verify its ability
to detect vulnerabilities in multi-threaded programs. The dataset is
used in ConVul [4] and contains ten programs which have various
vulnerabilities. These programs reproduce real vulnerabilities in
Linux and Firefox. We run each program ten times and present
the experimental results in Table 1. The third column presents the
times that ConVulPOE finds a vulnerability, and the fourth one
shows the number of crashes in the ten runs. The fifth column
shows the causes of vulnerabilities in the programs. It shows that
some of these vulnerabilities are caused by race conditions, and
some are due to the exchange of critical sections (CS). The results
show that ConVulPOE finds vulnerabilities in eight benchmarks.
ConVulPOE cannot always detect a vulnerability in every run of a
program because it predicts vulnerabilities from a completed trace.
If a trace has no potential pairs, ConVulPOE detects no vulnera-
bilities. We can also see that some programs crashed because of
the occurrence of vulnerabilities during runtime. In such cases, the
predictor component does not work since the trace is not com-
plete. ConVulPOE fails to find vulnerabilities for two benchmarks,
including CVE-2011-2183 and CVE-2016-1972. An detailed investi-
gation reveals that CVE-2011-2183 contains an NPD vulnerability
and CVE-2016-1972 contains a UAF vulnerability. The vulnerabili-
ties in both benchmarks occur with totally new execution paths,
andConVulPOE fails to infer new feasible traces from an observed
one. We present the analyses of the code for both benchmarks in
supplemental material due to space limitations.
The results verify that our approach can detect all three kinds of
concurrency memory vulnerabilities. According to the evaluation
onConVul [4], other tools such as UFO [ 13], and ThreadSanitizer
[31] fails to detect most vulnerabilities in the benchmarks.
Table 1: Experimental results on CVE benchmarks
CVE ID Cat. # of suc. # of cra. Causes
CVE-2009-3547 NPD 10 0 exchange of CS
CVE-2011-2183 NPD 0 0 exchange of CS
CVE-2013-1792 NPD 4 0 race condition
CVE-2015-7550 NPD 6 4 exchange of CS
CVE-2016-1972 UAF 0 1 race condition
CVE-2016-1973 UAF 4 1 race condition
CVE-2016-7911 NPD 10 0 race condition
CVE-2016-9806 DF 10 0 race condition
CVE-2017-6346 UAF 9 0 race condition
CVE-2017-15265 UAF 10 0 race condition
287Detecting Concurrency Vulnerabilities Based on Partial Orders of Memory and Thread Events ESEC/FSE â€™21, August 23â€“28, 2021, Athens, Greece
6.2 Detection on Real Programs
In this experiment, ConVulPOE works as a bug oracle [ 21] from
the perspective of fuzzing. We evaluate the performance of Con-
VulPOE with several real multi-threaded programs tested by fuzzing
tools in prior works [ 5]. Table 2 shows a summary of the tested
programs, including four parallel compression/decompression utili-
ties (lbzip2, pbzip2, pigz, and xz), two libraries (libwebp and libvpx)
used in popular browsers like Chrome and Firefox, and two video
encoders (x264 and x265) for H.264/AVC and HEVC/H.265, respec-
tively. All these programs use the native pthread library. The binary
sizes of these programs range from 507K to 9.27M.
We adopt AFL to fuzz these programs for 24 hours with initial
seeds provided by Muzz [5] to get the inputs for our evaluation.
We do not use Muzz for fuzzing since the source code is unavail-
able. Before our evaluation, we use afl-cmin to minimize the input
files generated by AFL. AFL finds no vulnerability in the 24 hours
fuzzing. The fifth column of Table 2 shows the number of inputs
for these programs in our evaluation. All inputs are generated by
AFL except the inputs for x264 and x265. We use initial seeds as
the two programsâ€™ inputs because there is only one file left with a
broken format for each program after minimizing. The lengths of
recorded traces range from hundreds to 100 millions.
We compare with two state-of-the-art detection tools, including
ConVul [4] and UFO [ 13].ConVul is implemented as a pin tool
based on Intel Pin. Different from ConVulPOE ,ConVul detects
vulnerabilities during runtime. UFO works similarly to our tool. It
instruments the program, records the trace, and employs a trace
analyzer for vulnerability detection. UFOâ€™s instrumentation is based
on the LLVM pass, which inserts additional code during the compile
stage. Although LLVM-based instrumentation is faster than Pin,
it is more complicated. We use Pin for instrumentation because it
is suitable for black-box, binary-only instrumentation. Both Con-
VulPOE andConVul can detect UAF, NPD, and DF while UFO can
only detect UAF. All experiments are conducted on a server with an
Intel Xeon E5-2650 v4 CPU and 128GB RAM. The operating system
is Ubuntu 16.04, installed with GCC 9.3.0, AFL 2.57b.
We run these programs five times and report the average. When
we run ConVul and UFO, they cannot complete all the tests for
some programs. When ConVul analyzes pigz and cwebp, it seems
to trigger a deadlock, and the program is stuck. UFO sometimes
throws an unhandled exception, which makes UFO abort. After
finding a UAF, UFO is expected to write the relevant information
to a file. But in our evaluation, it did not work properly and threw
an exception in some cases, leading to the stop of the program
and the test. This is the major reason that the tests for lbzip2 and
cwebp are not completed. Considering that UFO and ConVul did not
complete some tests of inputs, and the numbers of inputs used for
different programs are different, we use the metric vulnerabilities-
per-input for fair comparisons. Table 3 presents the average number
of vulnerabilities detected in a single execution of these programs.
They all find the UAF vulnerability in lbzip2. Both ConVulPOE
andConVul find it in every execution. Currently, UFO can only
find UAFs. It finds 0.96 UAF in one execution on average for lbzip2.
ConVulPOE find more vulnerabilities on cwebp, x264 and x265 than
ConVul and UFO, indicating that it can find vulnerabilities that
cannot be found by other tools. However, ConVulPOE also missessome UAFs detected by UFO and some DFs detected by ConVul
in pigz. Both ConVulPOE and UFO miss some UAFs detected by
ConVul in vpxdec. These results indicate that ConVulPOE is an
important complement to existing tools.
Table 4 presents the time used by the three detectors. For Con-
VulPOE and UFO, the time includes the execution time of an instru-
mented program and the detection time based on the trace. UFO
consumes the least time on pbzip2-c, pbzip2-d, xz, and vpxdec be-
cause it finds no potential UAFs and needs no further computations.
Although UFO finds more vulnerabilities than ConVulPOE on pigz,
it costs more time (98544s vs. 287s). In general, ConVulPOE can
find more vulnerabilities in less time. For programs such as lbzip2,
cwebp, x264, and x265 with many potential UAFs, UFO needs to use
Z3 for verification, which consumes much time to solve constraints.
There usually are hundreds of potential UAFs in a single test, and
the timeout for Z3 to solve each potential UAFâ€™s constraints is 2
minutes by default. In most cases, Z3 reaches the timeout, indicating
that it usually takes more than one day to check all the potential
UAFs. A less timeout will make UFO faster. However, it results
in fewer vulnerabilities found by UFO. That is why UFO cannot
complete the whole test in a week for these programs. Compared
toConVul ,ConVulPOE consumes less time on pbzip2-c, pbzip2-d
and vpxdec. For pigz and cwebp, ConVulPOE finds more vulnera-
bilities in less time. We also present the average time used by the
predictor of ConVulPOE in parentheses. The results show that the
predictor costs much less time than the recorder to record an execu-
tion trace. Detailed investigations reveal that the instrumentation
of Intel Pin is time-consuming. For the programs that ConVulPOE
finds vulnerabilities, the time cost by the predictor accounts from
20% to 63% of the total time.
Table 5 presents the maximum, minimum, and average distances
of vulnerability-potential event pairs in each programâ€™s executions.
The distance of an event pair is defined as the absolute difference
between the indices of two potential events. The results show that
most vulnerability-potential event pairs have very large distances
in the traces. This finding indicates that even long-distant event
pairs can cause a vulnerability, verifying the difficulty of detect-
ing concurrency vulnerabilities. Compared with ConVul which
limits the maximum sync-distance of potential event pairs, Con-
VulPOE detects vulnerabilities without limitations on potential
event distances. It is also the reason why ConVulPOE finds more
vulnerabilities than ConVul , as shown in Table 3.
In summary, ConVulPOE detects more vulnerabilities than other
detectors with a competitive time. Although ConVul and UFO are
faster than ConVulPOE in some cases, they are also extremely slow
for some programs. However, ConVulPOE can finish the detection
in no more than two days. Therefore, ConVulPOE is an important
complement to existing detectors. The combination of AFL with
concurrency vulnerabilities detectors also works well. With the
help of these detectors, AFL can find more vulnerabilities.
6.3 Impacts of Number of Threads
To answer RQ3, we evaluate ConVulPOE on programs running
with varying numbers of threads. In this experiment, we chose
lbzip2, pigz, x264, and x265 for evaluation. The number of threads
288ESEC/FSE â€™21, August 23â€“28, 2021, Athens, Greece Kunpeng Yu, Chenxu Wang, Yan Cai, Xiapu Luo, and Zijiang Yang
Table 2: A Summary of tested Programs. The FILE in command will be replaced by actual input file.
ID Program Command Binary size # of inputs Ave. length Max. length
lbzip2 lbzip2 2.5 lbzip2 -k -t -9 -z -f -n4 FILE 507K 841 1,208,862 3,351,406
pbzip2-c pbzip2 1.1.13 pbzip2 -f -k -p4 -S16 -z FILE 509K 27 282 282
pbzip2-d pbzip2 1.1.13 pbzip2 -f -k -p4 -S16 -d FILE 509K 121 357 713
pigz pigz 2.5 pigz -p 4 -c -b 32 FILE 592K 106 3106 6819
xz xz 5.2.5 xz -9 -k -T 4 -f FILE 1.1M 39 2,251,121 23,282,362
cwebp libwebp 1.2.0 cwebp -mt FILE -o out.webp 4.5M 1182 3,617,616 115,915,206
vpxdec libvpx 1.9.0 vpxdec -t 4 -o out.y4m FILE 5.49M 1609 36,490 266,384
x264 x264 HEAD: 59c0609 x264 -threads=4 -o out.264 FILE 9.27M 17 495,141 845,987
x265 x265 3.4 x265 -input FILE -pools 4 -F 2 -o out.265 688K 10 11,116,821 11,116,880
Table 3: Average number of vulnerabilities detected per input.
The symbol (-) means that the tests are not completed.
ID ConVulPOE ConVul UFO
lbzip2 1 UAF 1 UAF 0.96 UAF (-)
pbzip2-c 0 0 0
pbzip2-d 0 0 0
pigz 0.69 UAF, 10.42 NPDs 0.29 DF (-) 15.29 UAFs
xz 0 0 0
cwebp 1.35 UAFs 0 (-) 0.58 UAF (-)
vpxdec 0 0.01 UAF 0 (-)
x264 5.35 NPDs 0.18 NPD 0 (-)
x265 1.5 NPDs 0.1 UAF 0 (-)
Table 4: Time consumed by different detectors. The symbol
- means that the tests either are not completed due to fatal
bugs or cannot complete in a week.
ID ConVulPOE (s) ConVul (s) UFO (s)
lbzip2 18,753 (3766.4) 8169 -
pbzip2-c 238 ( <1) 572 214
pbzip2-d 646 ( <1) 3367 496
pigz 287 (101.4) - 98,544
xz 567 (42.8) 211 143
cwebp 108,593 (25,266.4) - -
vpxdec 24,558 (17) 126,169 1069
x264 534 (239.6) 146 -
x265 994 (624.8) 140 -
Table 5: Distances of vulnerability-potential event pairs.
ID Max Min Average
lbzip2 3,351,132 2880 1,208,588.64
pigz 821 6 207.03
cwebp 34,106,101 1 1,027,149.48
x264 15,679 5 778.90
x265 4,191,081 682,628 1,924,895.62is set to be 2, 4, 8, and 16. Other settings are the same as previous.
We run each program five times and report the average results.
Figure 8 shows the average number of vulnerabilities that Con-
VulPOE finds in a programâ€™s single run versus the number of
threads. The average number of UAFs found in pigz per run in-
creases from 0.38 to 0.70, 0.68, and 0.69, respectively. However, the
average number of NPDs found in x264 and pigz per run decreases
as the number of threads increases. The number of threads has no
impact on the number of vulnerabilities found in lbzip2 and x265.
The results demonstrate that the number of threads has differ-
ent influences on ConVulPOE â€™s capability. On the one hand, the
probability of finding more potential pairs increases as the number
of threads increases. On the other hand, since Algorithm 1 always
makes unordered conflicting event pairs keep their original exe-
cution order, it increases the probability of forming a cycle. If a
cycle is formed due to wrong orders, we will miss a vulnerability.
Thus, ConVulPOE is more likely to miss some vulnerabilities as the
number of threads increases. In summary, the number of threads is
a double-edged sword for ConVulPOE .
Figure 8: Average number of vulnerabilities found by Con-
VulPOE per input versus the number of threads.
7 DISCUSSION
ConVulPOE works on the traces generated in the executions of a
program. To detect a vulnerability from a trace, we must generate
a new trace exposing the vulnerability. We use partial orders to
represent the necessary execution orders of events to reduce the
search space. The trace may be very large in some large programs,
289Detecting Concurrency Vulnerabilities Based on Partial Orders of Memory and Thread Events ESEC/FSE â€™21, August 23â€“28, 2021, Athens, Greece
consuming a long time to generate a partial order. In such a case,
we can divide the trace into multiple parts and detect each part
separately. Fuzzing tools like AFL also suggest using small input
files and simple target binary files [ 39]. It suggests detecting on
modules of a large program rather than the whole program.
There is also room for future research. The first is trace reducing.
Loop structures are widely used in programs, generating many
events if they contain some operations in which we are interested.
It is not extendable to record all the events. The second one is to im-
prove the completeness. Algorithm 1 needs to order the unordered
conflicting pairs and avoids forming a cycle. Every ordering inserts
a new edge to the partial order graph. Thus, a cycle may be formed
by different orderings. For example, as described in Section 3.3,
there may be unordered conflicting event pairs (see line 5 of Algo-
rithm 1). If these conflicts are not resolved properly, there may exist
edges such as ğ‘’â†’ğ‘’â€², ğ‘’â€²â†’ğ‘’â€²â€², andğ‘’â€²â€²â†’ğ‘’. Our algorithm cannot
construct a feasible trace from the partial order graph in these cases
and thus misses some vulnerabilities. That is, our algorithm is still
incomplete. It is worth noting that there are no guaranteed methods
(including ours) to find a vulnerability in polynomial time if there
is one. How to improve the completeness of the algorithm is worth
further studying.
8 RELATED WORK
Partial-order-based predictive analysis. In previous works, par-
tial-order-based prediction is used to detect data races in multi-
threaded programs. A data race occurs when two threads access
the same data simultaneously, and at least one modifies it. Most
race detectors [ 1,6,12,24,27,38] employ Lamportâ€™s happen-before
(HB) partial order [ 18]. It ensures that the partial order can al-
ways generate a feasible trace. However, it is highly incomplete.
Causally-precedes (CP) partial order [ 32] and weakly-causally-
precedes (WCP) partial order [ 16] are two weaker partial orders
based on HB. They can generate more different traces than HB.
However, they are still highly incomplete because they are closed
under the composition with HB. Doesnâ€™t-Commute (DC) [ 26] is
weaker than WCP and can explore more possible execution trace
and find more races. However, the constraints of DC are not suffi-
cient to generate a feasible trace. M2 [ 23] proposes the trace-closed
partial order, which is weaker and finds more races than DC.
Data race detection uses the partial order to determine the con-
currency of two events and get a valid trace exposing the data race.
Our algorithm is different from existing approaches designed for
data race detection [ 16,23,26]. The key to predicting a vulnerability
or a data race from an observed trace is to rearrange the trace to get
a new one exposing it. The new trace must meet several constraints
to be feasible. Such an approach is also widely used in prior data
race detection work. Our algorithm follows the same procedure but
expands it. First, we consider two additional event types, including
free anddereference , to detect memory vulnerabilities. Since
both events are read events, the new setting is still compatible with
the old ones. Second, memory vulnerabilities are more complicated
than data races, and their witness traces are quite different. A trace
exposing a data race only requires that the two events causing a
data race are rearranged consecutively (e.g., usually at the end ofthe trace). However, exposing a memory vulnerability is more com-
plicated because not all data races can cause memory vulnerabilities.
For example, if two events in different threads are protected by the
same lock, they cannot cause a data race. However, the execution
orders of the critical sections containing the two events may change
in some situations and thus cause a memory vulnerability.
Concurrency memory vulnerability detection. Programs
written in unsafe languages such as C/C++ are prone to memory
errors. UAF, NPD, and DF are serious threats to software security.
However, it is challenging to find them in multi-threaded programs.
UFO [ 13] is a concurrent UAF detector based on MaxModel [ 14],
which is used to capture a maximal set of feasible traces. To make the
trace feasible, it employs a constraint solver to solve the constraints.
ConVul [4] detects vulnerabilities by judging whether two events
are exchangeable based on sync-edge and sync-distance, which is
defined by HB. ExceptioNULL [11] detects NPD in concurrent Java
programs, which is also based on constraint solving. ExceptioNULL
adopts a scheme that focuses on a small trace segment to make
the constraints simpler. However, it reduces the number of feasible
traces and may miss some vulnerabilities.
Different from these methods, our approach constructs new
traces exposing vulnerabilities via partial orders. It benefits the
detection from the following two aspects. First, some events must
execute before others to meet these constraints. It is straightfor-
ward to use partial orders to represent such relations between two
events. Second, we can add new partial order relations via the rules
described in Section 3.2. Although a partial order graph meets all
the constraints, we may fail to get a feasible trace from it directly
because there may exist unordered conflicting events. To solve this
difficulty, we use a heuristic algorithm that inserts additional edges
to the partial order graph to get a feasible trace.
9 CONCLUSION
This paper proposes a new approach for concurrency vulnerability
detection based on partial orders. We propose algorithms to extract
vulnerability-potential event pairs from an execution trace of a
multi-threaded program. A novel algorithm is developed to gener-
ate an event pairâ€™s feasible set, which considers the cases that two
events are protected by the same lock. Then, we construct partial
orders of feasible event sets and generate a feasible trace exposing
vulnerabilities. Exploiting partial orders to generate traces reduces
the search space of possible executions and improves computa-
tional efficiency. Compared to other detectors, our method is more
theoretically sound and efficient. We implement a prototype of our
method and conduct experiments to evaluate its performance. Ex-
perimental results show that ConVulPOE shows superiority over
state-of-the-art tools in both effectiveness and efficiency.
ACKNOWLEDGMENTS
The research presented in this paper is supported in part by the Na-
tional Natural Science Foundation of China (No. 61602370, 62032010,
61772411, U1736205), the Natural Science Foundation of Shaanxi
Province (No. 2021JM-018), the Key Research Program of Fron-
tier Sciences, CAS (No. ZDBS-LY-7006), the Youth Innovation Pro-
motion Association of the Chinese Academy of Sciences (YICAS)
(No. 2017151), and the HK RGC Project (No. 152239/18E).
290ESEC/FSE â€™21, August 23â€“28, 2021, Athens, Greece Kunpeng Yu, Chenxu Wang, Yan Cai, Xiapu Luo, and Zijiang Yang
REFERENCES
[1]Michael D. Bond, Katherine E. Coons, and Kathryn S. McKinley. 2010. PACER:
Proportional Detection of Data Races. In Proceedings of the 31st ACM SIGPLAN
Conference on Programming Language Design and Implementation (Toronto, On-
tario, Canada) (PLDI â€™10) . Association for Computing Machinery, New York, NY,
USA, 255â€“268. https://doi.org/10.1145/1806596.1806626
[2]Juan Caballero, Gustavo Grieco, Mark Marron, and Antonio Nappa. 2012. Un-
dangle: Early Detection of Dangling Pointers in Use-after-Free and Double-Free
Vulnerabilities. In Proceedings of the 2012 International Symposium on Software
Testing and Analysis (Minneapolis, MN, USA) (ISSTA 2012) . Association for Com-
puting Machinery, New York, NY, USA, 133â€“143. https://doi.org/10.1145/2338965.
2336769
[3]Yan Cai. 2019. CVE Benchmark. Retrieved February 20, 2021 from https:
//github.com/mryancai/ConVul
[4]Yan Cai, Biyun Zhu, Ruijie Meng, Hao Yun, Liang He, Purui Su, and Bin Liang.
2019. Detecting Concurrency Memory Corruption Vulnerabilities. In Proceedings
of the 2019 27th ACM Joint Meeting on European Software Engineering Conference
and Symposium on the Foundations of Software Engineering (Tallinn, Estonia)
(ESEC/FSE 2019) . Association for Computing Machinery, New York, NY, USA,
706â€“717. https://doi.org/10.1145/3338906.3338927
[5]Hongxu Chen, Shengjian Guo, Yinxing Xue, Yulei Sui, Cen Zhang, Yuekang
Li, Haijun Wang, and Yang Liu. 2020. MUZZ: Thread-aware Grey-box Fuzzing
for Effective Bug Hunting in Multithreaded Programs. In 29th USENIX Security
Symposium (USENIX Security 20) . USENIX Association, 2325â€“2342. https://www.
usenix.org/conference/usenixsecurity20/presentation/chen-hongxu
[6]Mark Christiaens and Koenraad De Bosschere. 2001. TRaDe: Data Race Detection
for Java. In Proceedings of the International Conference on Computational Science-
Part II (ICCS â€™01) . Springer-Verlag, Berlin, Heidelberg, 761â€“770. https://doi.org/
10.1007/3-540-45718-6_81
[7]Leonardo de Moura and Nikolaj BjÃ¸rner. 2008. Z3: An Efficient SMT Solver. In
Tools and Algorithms for the Construction and Analysis of Systems , C. R. Ramakr-
ishnan and Jakob Rehof (Eds.). Springer Berlin Heidelberg, Berlin, Heidelberg,
337â€“340. https://doi.org/10.1007/978-3-540-78800-3_24
[8]Common Weakness Enumeration. 2006. CWE-415: Double Free. Retrieved
February 20, 2021 from https://cwe.mitre.org/data/definitions/415.html
[9]Common Weakness Enumeration. 2006. CWE-416: Use After Free. Retrieved
February 20, 2021 from https://cwe.mitre.org/data/definitions/416.html
[10] Common Weakness Enumeration. 2010. CWE-476: NULL Pointer Dereference.
Retrieved February 20, 2021 from https://cwe.mitre.org/data/definitions/476.html
[11] Azadeh Farzan, P. Madhusudan, Niloofar Razavi, and Francesco Sorrentino. 2012.
Predicting Null-Pointer Dereferences in Concurrent Programs. In Proceedings of
the ACM SIGSOFT 20th International Symposium on the Foundations of Software En-
gineering (Cary, North Carolina) (FSE â€™12) . Association for Computing Machinery,
New York, NY, USA, Article 47, 11 pages. https://doi.org/10.1145/2393596.2393651
[12] Cormac Flanagan and Stephen N. Freund. 2009. FastTrack: Efficient and Precise
Dynamic Race Detection. In Proceedings of the 30th ACM SIGPLAN Conference
on Programming Language Design and Implementation (Dublin, Ireland) (PLDI
â€™09). Association for Computing Machinery, New York, NY, USA, 121â€“133. https:
//doi.org/10.1145/1542476.1542490
[13] J. Huang. 2018. UFO: Predictive Concurrency Use-After-Free Detection. In 2018
IEEE/ACM 40th International Conference on Software Engineering (ICSE) . 609â€“619.
https://doi.org/10.1145/3180155.3180225
[14] Jeff Huang, Patrick Oâ€™Neil Meredith, and Grigore Rosu. 2014. Maximal Sound Pre-
dictive Race Detection with Control Flow Abstraction. In Proceedings of the 35th
ACM SIGPLAN Conference on Programming Language Design and Implementation
(Edinburgh, United Kingdom) (PLDI â€™14) . Association for Computing Machinery,
New York, NY, USA, 337â€“348. https://doi.org/10.1145/2594291.2594315
[15] D. R. Jeong, K. Kim, B. Shivakumar, B. Lee, and I. Shin. 2019. Razzer: Finding
Kernel Race Bugs through Fuzzing. In 2019 IEEE Symposium on Security and
Privacy (SP) . 754â€“768. https://doi.org/10.1109/SP.2019.00017
[16] Dileep Kini, Umang Mathur, and Mahesh Viswanathan. 2017. Dynamic Race
Prediction in Linear Time. In Proceedings of the 38th ACM SIGPLAN Conference
on Programming Language Design and Implementation (Barcelona, Spain) (PLDI
2017) . Association for Computing Machinery, New York, NY, USA, 157â€“170.
https://doi.org/10.1145/3062341.3062374
[17] Lamport. 1979. How to Make a Multiprocessor Computer That Correctly Executes
Multiprocess Programs. IEEE Trans. Comput. C-28, 9 (1979), 690â€“691. https:
//doi.org/10.1109/TC.1979.1675439
[18] Leslie Lamport. 1978. Time, Clocks, and the Ordering of Events in a Distributed
System. Commun. ACM 21, 7 (July 1978), 558â€“565. https://doi.org/10.1145/
359545.359563
[19] Changming Liu, Deqing Zou, Peng Luo, Bin B. Zhu, and Hai Jin. 2018. A Heuristic
Framework to Detect Concurrency Vulnerabilities. In Proceedings of the 34th
Annual Computer Security Applications Conference (San Juan, PR, USA) (ACSAC
â€™18). Association for Computing Machinery, New York, NY, USA, 529â€“541. https:
//doi.org/10.1145/3274694.3274718[20] Chi-Keung Luk, Robert Cohn, Robert Muth, Harish Patil, Artur Klauser, Geoff
Lowney, Steven Wallace, Vijay Janapa Reddi, and Kim Hazelwood. 2005. Pin:
Building Customized Program Analysis Tools with Dynamic Instrumentation.
InProceedings of the 2005 ACM SIGPLAN Conference on Programming Language
Design and Implementation (Chicago, IL, USA) (PLDI â€™05) . Association for Comput-
ing Machinery, New York, NY, USA, 190â€“200. https://doi.org/10.1145/1065010.
1065034
[21] Valentin Jean Marie ManÃ¨s, HyungSeok Han, Choongwoo Han, Sang Kil Cha,
Manuel Egele, Edward J. Schwartz, and Maverick Woo. 2019. The Art, Science,
and Engineering of Fuzzing: A Survey. IEEE Transactions on Software Engineering
(2019), 1â€“1. https://doi.org/10.1109/TSE.2019.2946563
[22] Madanlal Musuvathi and Shaz Qadeer. 2007. Iterative Context Bounding for
Systematic Testing of Multithreaded Programs. In Proceedings of the 28th ACM
SIGPLAN Conference on Programming Language Design and Implementation (San
Diego, California, USA) (PLDI â€™07) . Association for Computing Machinery, New
York, NY, USA, 446â€“455. https://doi.org/10.1145/1250734.1250785
[23] Andreas Pavlogiannis. 2019. Fast, Sound, and Effectively Complete Dynamic Race
Prediction. Proc. ACM Program. Lang. 4, POPL, Article 17 (Dec. 2019), 29 pages.
https://doi.org/10.1145/3371085
[24] Eli Pozniansky and Assaf Schuster. 2003. Efficient On-the-Fly Data Race Detec-
tion in Multithreaded C++ Programs. In Proceedings of the Ninth ACM SIGPLAN
Symposium on Principles and Practice of Parallel Programming (San Diego, Cali-
fornia, USA) (PPoPP â€™03) . Association for Computing Machinery, New York, NY,
USA, 179â€“190. https://doi.org/10.1145/781498.781529
[25] John Regehr. 2010. A Guide to Undefined Behavior in C and C++. Retrieved
February 20, 2021 from https://blog.regehr.org/archives/213
[26] Jake Roemer, Kaan GenÃ§, and Michael D. Bond. 2018. High-Coverage, Unbounded
Sound Predictive Race Detection. In Proceedings of the 39th ACM SIGPLAN Con-
ference on Programming Language Design and Implementation (Philadelphia, PA,
USA) (PLDI 2018) . Association for Computing Machinery, New York, NY, USA,
374â€“389. https://doi.org/10.1145/3192366.3192385
[27] D. Schonberg. 1989. On-the-Fly Detection of Access Anomalies. In Proceedings
of the ACM SIGPLAN 1989 Conference on Programming Language Design and
Implementation (Portland, Oregon, USA) (PLDI â€™89) . Association for Computing
Machinery, New York, NY, USA, 285â€“297. https://doi.org/10.1145/73141.74844
[28] E. J. Schwartz, T. Avgerinos, and D. Brumley. 2010. All You Ever Wanted to Know
about Dynamic Taint Analysis and Forward Symbolic Execution (but Might Have
Been Afraid to Ask). In 2010 IEEE Symposium on Security and Privacy . 317â€“331.
https://doi.org/10.1109/SP.2010.26
[29] SecuriTeam. 2016. OpenSSL NULL Pointer Dereference Vulnerabilities. Retrieved
February 20, 2021 from https://securiteam.com/securitynews/5FP3B00HQE/
[30] Konstantin Serebryany, Derek Bruening, Alexander Potapenko, and Dmitry
Vyukov. 2012. AddressSanitizer: A Fast Address Sanity Checker. In USENIX
ATC 2012 . https://www.usenix.org/conference/usenixfederatedconferencesweek/
addresssanitizer-fast-address-sanity-checker
[31] Konstantin Serebryany and Timur Iskhodzhanov. 2009. ThreadSanitizer: Data
Race Detection in Practice. In Proceedings of the Workshop on Binary Instrumen-
tation and Applications (New York, New York, USA) (WBIA â€™09) . Association for
Computing Machinery, New York, NY, USA, 62â€“71. https://doi.org/10.1145/
1791194.1791203
[32] Yannis Smaragdakis, Jacob Evans, Caitlin Sadowski, Jaeheon Yi, and Cormac
Flanagan. 2012. Sound Predictive Race Detection in Polynomial Time. In Pro-
ceedings of the 39th Annual ACM SIGPLAN-SIGACT Symposium on Principles
of Programming Languages (Philadelphia, PA, USA) (POPL â€™12) . Association for
Computing Machinery, New York, NY, USA, 387â€“400. https://doi.org/10.1145/
2103656.2103702
[33] E. Stepanov and K. Serebryany. 2015. MemorySanitizer: Fast detector of uninitial-
ized memory use in C++. In IEEE/ACM International Symposium on Code Genera-
tion and Optimization (CGO) . 46â€“55. https://doi.org/10.1109/CGO.2015.7054186
[34] L. Szekeres, M. Payer, T. Wei, and D. Song. 2013. SoK: Eternal War in Memory.
(2013), 48â€“62. https://doi.org/10.1109/SP.2013.13
[35] The Clang Team. 2007. UndefinedBehaviorSanitizer. Retrieved February 20,
2021 from https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html
[36] Nischai Vinesh and M. Sethumadhavan. 2020. ConFuzzâ€”A Concurrency Fuzzer.
InFirst International Conference on Sustainable Technologies for Computational
Intelligence , Ashish Kumar Luhach, Janos Arpad Kosa, Ramesh Chandra Poonia,
Xiao-Zhi Gao, and Dharm Singh (Eds.). Springer Singapore, Singapore, 667â€“691.
https://doi.org/10.1007/978-981-15-0029-9_53
[37] M. Xu, S. Kashyap, H. Zhao, and T. Kim. 2020. Krace: Data Race Fuzzing for Kernel
File Systems. In 2020 IEEE Symposium on Security and Privacy (SP) . 1643â€“1660.
https://doi.org/10.1109/SP40000.2020.00078
[38] Yuan Yu, Tom Rodeheffer, and Wei Chen. 2005. RaceTrack: Efficient Detection
of Data Race Conditions via Adaptive Tracking. In Proceedings of the Twentieth
ACM Symposium on Operating Systems Principles (Brighton, United Kingdom)
(SOSP â€™05) . Association for Computing Machinery, New York, NY, USA, 221â€“234.
https://doi.org/10.1145/1095810.1095832
[39] MichaÅ‚ Zalewski. 2014. Technical "whitepaper" for afl-fuzz. https://lcamtuf.
coredump.cx/afl/technical_details.txt
291