Calm EnergyAccountingforMultithreaded Java Applications
Timur Babakol
tbabako1@binghamton.edu
SUNY Binghamton
Binghamton,NY, USAAnthony Canino
acanino1@binghamton.edu
SUNY Binghamton
Binghamton,NY, USAKhaled Mahmoud
kmahmou1@binghamton.edu
SUNYBinghamton
Binghamton,NY, USA
RachitSaxena
rsaxena3@binghamton.edu
SUNY Binghamton
Binghamton,NY, USAYu DavidLiu
davidl@binghamton.edu
SUNY Binghamton
Binghamton,NY, USA
ABSTRACT
Energy accounting is a fundamental problem in energy manage-
ment, defined as attributing global energy consumption to individ-
ual components of interest. In this paper, we take on this problem
attheapplicationlevel, wherethecomponentsforaccountingare
application logical units , such as methods, classes, and packages.
GivenaJavaapplication,ournovelruntimesystem Chappie pro-
ducesan energyfootprint ,i.e.,therelativeenergyconsumptionof
allprogrammingabstractionunitswithin the application.
The design of Chappie is unique in several dimensions. First,
relative to targeted energy profiling where the profiler determines
theenergyconsumptionofapre-definedapplicationlogicalunit,
e.g., a specific method, Chappie istotal: the energy footprint en-
compassesallmethodswithinanapplication.Second, Chappie is
concurrency-aware :energyattributionisfullyawareofthemulti-
threadedbehaviorofJavaapplications,includingJVMbookkeeping
threads.Third, Chappieisanembodimentofanovelphilosophyfor
application-levelenergyaccountingandprofiling,whichstatesthat
the accounting run should preserve the temporal phased power be-
havioroftheapplication,andthe spatialpowerdistributionamong
the underlying hardware system. We term this important property
ascalmness.Againststate-of-the-artDaCapobenchmarks,weshow
that the energy footprint generated by Chappie is precise while
incurring negligible overhead. In addition, all results are produced
withahigh degree ofcalmness.
CCS CONCEPTS
Â·Software andits engineering â†’Software performance .
KEYWORDS
Energy Accounting, Energy Profiling, Power Disturbance, Concur-
rency
Permissionto make digitalor hard copies of allorpart ofthis work for personalor
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACM
mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,
topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ESEC/FSE â€™20, November 8Å›13, 2020, Virtual Event, USA
Â©2020 Associationfor Computing Machinery.
ACM ISBN 978-1-4503-7043-1/20/11...$15.00
https://doi.org/10.1145/3368089.3409703ACMReference Format:
Timur Babakol, Anthony Canino, Khaled Mahmoud, Rachit Saxena, and Yu
David Liu. 2020. Calm Energy Accounting for MultithreadedJava Applica-
tions.InProceedingsofthe28thACMJointEuropeanSoftwareEngineering
ConferenceandSymposium on the Foundationsof SoftwareEngineering(ES-
EC/FSE â€™20), November 8Å›13, 2020, Virtual Event, USA. ACM, New York, NY,
USA,13pages.https://doi.org/10.1145/3368089.3409703
1 INTRODUCTION
Application-levelenergymanagementhasemergedasanimportant
dimensionofenergy-efficientcomputing,withsolutionssharing
acommonpremise:the logicalunits withinanapplicationmatter
in energy management. In this paper, we revisit energy account-
ing, a fundamental problem that has been extensively studied at
the lower layers of the computing stack [ 20,52]. Our new focus
is on the application level: determining the energy consumption
of individual application logical units given the total energy con-
sumption of the application. This problem subsumes important
questions in green software development, e.g., which methods con-
sumethemostenergyinanapplication,whichmethodsleadthe
underlying system to a higher-power state, or how to compare
the energy/power consumption of two methods. Answering these
questionssystematicallymaysignificantlyimpactthestateofthe
art of energy-aware programming [ 8,13,16,37,49,53], energy-
adaptive software framework design [ 14,21,30,34,39], energy
testing and debugging [ 12,23,27,38,40,42], and energy-oriented
approximation [ 5,11,29,47].
At first glance, the problem of application-level energy account-
ingmayappeardeceptivelysimple.Todeterminetheenergycon-
sumption of method ğ‘š, a naive approach may reduce it to a trivial
energymeasurement problem:onemayinstrument ğ‘šatitsentrance
and exit program points, obtain a pair of energy readings from the
underlying hardware, and compute the difference of the two. This
naive approach however is flawed Ã or at best impractical Ã for
tworeasons.
Accounting Totality. Important questions such as which method
consumesthemostenergyinanapplicationrequirestheknowledge
of energy consumption for all methods in an application. Iterating
overeverymethodwithaninstrumentationapproachdoesnotscale
forrealisticapplications;theoverheadbecomesunrealisticallyhigh
(see ÄŸ2) when allmethodsare accountedfor at the same time.
Multi-threading. Morefundamentally,theinstrumentation-based
approach is concurrency-oblivious,whichmay leadtosignificant
976
ESEC/FSE â€™20, November8â€“13,2020,VirtualEvent, USA Timur Babakol,AnthonyCanino,KhaledMahmoud, RachitSaxena,andYuDavid Liu
foo
barfoo
Time
Garbage Collector
Figure 1: The Challenge of Accounting for the Energy Con-
sumptionofMethod foowithaMulti-threadedApplication
over-accounting.This is particularly badnews for server-type ap-
plicationswheremulti-threadedprogramsonparallelplatformsare
therule,nottheexception.ConsiderFigure 1.Theinstrumentation-
basedapproachmayattributetheentireenergyconsumptionduring
the execution of footo the method, without considering a portion
of such consumption results from the execution of bar, or even
anotherinstanceof foo.Inaddition,managedlanguageruntimes
may have co-running Virtual Machine (VM) bookkeeping threads,
such as the garbagecollector.
Beyondthesetwochallengesinenergyaccountingsystemdesign,
athirdone existsagainst producing high-qualityresults.
Disturbance. Any runtime system design that profiles the appli-
cationneedstoensurethattheruntimeprofilingmechanismsdo
not significantly alter the behavior of the original application. This
well-knownproblemisusuallycopedwiththroughensuringthe
executiontimeoverheadoftheprofilerunisnegligiblecompared
to the original run. Profiling for energy, however, introduces a new
layerofsubtlety.Theprofilerbehaviormayalterthepowerstate
oftheunderlyinghardware,leadingtotwoconsequences.First,a
changeinthepowerstatesiscorrelatedwiththeCPUfrequency
change,sothatexecutiontimeisnolongerareliableindicatorof
disturbance. Second,as energyistheaccumulated effectof power,
thedisturbanceofpowerconsumptionalterstheverybehaviorthat
theprofilertriestoaobserve,challengingthevalidityoftheresults
from energy accounting.
1.1Chappie
Wepresent Chappie,atotal,concurrency-aware,disturbance-mitigated
application-levelenergyaccountingsystemforJavaapplications.
WithChappie, the execution of each application can produce an
energyfootprint ,i.e.,therelativeenergyconsumptionofallprogram-
ming logical units within the application. For example, Figure 2
isatop-10energyfootprintforarealisticJavaapplication h2[3].
ItshowsValueDataType.compare isthemostenergy-consuming
methodintheapplication.Furthermore,itshowstherelativeen-
ergy consumption difference between any pair of methods, such
asPage.binarySearch andValueDataType.compareValues . In
additiontomethods, Chappieiscustomizablesothattheunitinan
energyfootprintcanbecourser-grainedasclassesandpackages,
orfiner-grainedas callingcontextsto methods.
At its heart, Chappie is a novel sampling-based runtime system
thatdrawsinformationfrommultiplelayersofthecomputingstack,
and composes it to provide the energy footprint. On the JVM level,
Chappie samples the per-thread call stacks, determining which
methods are currently executing at each sample. On the hardware
level,Chappie is able to sample the raw energy readings. When
0.00
 0.05
 0.10
 0.15
 0.20
 0.25
 0.30
 0.35
 0.40
Aware vs Oblivious Attributed Energy RatioMethod
ValueDataType.getMemoryTransactionStore.getOperationIdObjectDataType$LongType.compareValue.compareTypeSafeCursor.fetchNextMVMap.compareValueArray.getMemoryPage.createValueDataType.comparePage.binarySearchFigure 2: Method-Grained Energy Footprint for h2(The X-
Axis represents the percentage of energy consumption con-
sumedbyaparticularmethod.TheY-Axisliststhemethods
with top-10 energy consumption, with the most consuming
oneat thetop.)
multiplethreadsareactiveuponthereceiptofarawenergysample,
Chappieisabletodistributeashareofthelatteramongallrunning
methods,eachofwhichresidesonthecallstackofanactivethread.
Thecorealgorithmof Chappie combinesthehigh-levelinforma-
tionwiththelower-levelone,withfullawarenessofconcurrency.
Despiteitscross-layernature, Chappieisalightweight designwith
nomodificationstotheapplicationcode,thecompiler,theJDK,the
JVM, the OS, orthe hardware.
Anotherhighlightof Chappieisittreatsaccountingdisturbance
as a first-class concern. While overall execution time overhead and
overallenergyconsumptionoverheadmayprovidesomeinsight
into how an accounting system may affect the application to be
accountedfor,theyareinsufficienttoquantifydisturbanceinenergy
accounting.
1.2 CalmEnergy Accounting
Chappiefeaturescalm energy accounting with a novel fine-grained
metric to ensure the accounting system does not temporally and
spatiallydisturb the energy behavior of the original application, so
thattheenergyfootprintfaithfullycaptures thecharacteristicsof
theoriginalapplication.Toelaborate,letusconsiderthescenario
inFigure 3,whereanapplicationrunsona2-coremachine, CPU1
andCPU2,eachofwhichmayoperateattwoCPUfrequencies, 1GHz
and2GHz.The metric of calmness subsumestwoideas.
Temporal Calmness. The accounting run should preserve the
powerphasedbehavior oftheoriginalapplication[ 19,31],i.e.,the
power consumption of an application may vary from timestamp to
timestampandtogethertheymayformapattern.Thiswell-known
phenomenonresultsfrom time-dependentapplicationcharacter-
istics such as parallel vs. serial phases latent in multi-threaded
applications,andCPU-intensivevs.I/O-intensivephasedbehaviors.
The power variation is usually enabled by Dynamic Voltage and
FrequencyScaling(DVFS)[ 43],astandardfeaturesupportedbythe
vast majority of CPUs and enabled as default by most operating
systems. In Figure 3b, observe that the accounting run drives both
977CalmEnergyAccountingforMultithreadedJava Applications ESEC/FSE â€™20, November8â€“13,2020,VirtualEvent, USATemporalCPU
11 GHz 2 GHz 2 GHz
CPU
21 GHz 2 GHz 2 GHzOriginal Run
T1 T2 T3Sampling
Epoch
(a)
TemporalCPU
12 GHz 2 GHz 1 GHz
CPU
22 GHz 2 GHz 1 GHzAccounting Run
T1 T2 T3Sampling
Epoch
(b)SpatialCPU
11 GHz 1 GHz 1 GHz
CPU
22 GHz 2 GHz 2 GHzOriginal Run
T1 T2 T3Sampling
Epoch
(c)
SpatialCPU
11 GHz 2 GHz 1 GHz
CPU
22 GHz 1 GHz 2 GHzAccounting Run
T1 T2 T3Sampling
Epoch
(d)
Figure 3:TemporalPowerDisturbance (Figure (a) (b)) andSpatial PowerDisturbance (Figure (c) (d))
CPU1andCPU2to operate at 2Ghz at an earlier timestamp than the
original application, as shown in Figure 3a. Even though the accu-
mulatedenergyofthetworunsmaywellcorrespond,thetworuns
do not exhibit the same power behavior, which we call temporal
powerdisturbance .Inanutshell,temporalpowerdisturbanceisa
symptom ofthe phasedbehaviorchangeofthe application.
SpatialCalmness. Theaccountingrunshouldpreservethe power
distributionbehavior oftheoriginalrun,i.e.,thepowerconsump-
tionoftheunderlyingsystemmayvaryfromCPUcoretoCPUcore
andtogethertheymayformapattern.Thiswell-knownphenom-
enon results from application characteristics such as symmetric
vs. asymmetricworkloads, and the level of parallelism enabled by
the application-scheduler interaction. The power variation is again
enabledbyDVFS,whereahigherworkloadusuallydrivestheCPU
toahigher frequencystate Ãhencehigher powerconsumption Ã
andviceversa.InFigure 3c,thepowerdistributionbetween CPU1
andCPU2are lopsided, whereas in Figure 3d, the two are more
balanced. Even though the accumulated energy of the two runs
maywellcorrespond,whichwecall spatialpowerdisturbance .In
essence,spatialpowerdisturbanceisasymptomoftheworkload
behaviorchangeofthe application.
We evaluate Chappie over 11 state-of-the-art DaCapo bench-
markswithdiverseandrealisticworkloads.Weshowthat Chappie
cansuccessfullyproducetheenergyfootprintforallbenchmarks.
By judiciously setting the sampling rates, Chappie can achieve
bothtemporalcalmnessandspatialcalmnessforallbenchmarks.
When calmness is achieved, the time and energy overhead are neg-
ligible, with an average runtime overhead of 3.15 Â±3.03% and anaverage energy overhead is 0.84 Â±1.09% across all benchmarks. We
furthershowthattheproducedenergyfootprintsareprecise:the
energy footprint converges when samples from additional runs are
included.
Contribution. This paper makes the following contributions:
â€¢A novel and customizable energy accounting design that
produces an energy footprint , illustrating the relative energy
consumption ofallprogram logic units.
â€¢Asampling-basedcross-layer designthatallowsfor concurrency-
awareenergy accounting for multi-threaded Java applica-
tions
â€¢A novelcalmness metric for quantifying power disturbance
inapplication-level energy accounting
â€¢Anevaluationdemonstratingtheeffectivenessof Chappie
in understanding the energy behavior of realistic Java appli-
cation
Chappie is an open-source project, hosted at an (anonymous)
websitehttps://github.com/pl-chappie/chappie .
2CHAPPIE MOTIVATION
In thissection,we briefly motivatethe need for Chappie quantita-
tively.
Accounting Totality with Instrumentation. In order to support
totality in energy accounting, an instrumentation-based approach
would either need to iteratively instrument each method, or instru-
mentallmethodsatonce.Theformerwouldleadtoalargespace
toconsider.Thelatterapproach,despiterequiringfewruns,may
978ESEC/FSE â€™20, November8â€“13,2020,VirtualEvent, USA Timur Babakol,AnthonyCanino,KhaledMahmoud, RachitSaxena,andYuDavid Liu
Table 1: Overhead with the Instrumentation-Based Ap-
proach (The Å‚instrumentation X%Å¾ column shows the time
overhead when every method in the benchmark is instru-
mented and X% of the invocations are randomly selected to
take energy readings. The instrumentation was performed
through javassist [15]. All benchmarks appearing in this
section are fromtheDaCapobenchmarksuite [ 9]. )
instrumentation100% instrumentation5%
sunflow 189x 164x
batik 118x 117x
xalan 30x 29x
h2 25x 16x
Table 2: Energy Over-Attribution due to Concurrency-
ObliviousAccounting(Thefirstcolumnliststop-consuming
h2methods reported by Chappie , and the second column
reports the ratio of over-attribution if concurrency were ig-
nored.)
methodname over-attribution
ValueDataType.compare 2.88x
Page.binarySearch 2.20x
MVMap.compare 5.82x
MVMap.binarySearch 9.27x
LocalResult.next 3.43x
1
 2
 4
 8
16
 32
 64
Sampling Rate (ms)
âˆ’20
âˆ’10
0
10
20
30
40
50Normalized Energy/Time/Power
h2
energy
time
power
Figure 4: h2Disturbance (The X-Axis represents different
sampling rates. The Y-Axis represents the normalized dif-
ference between the accounting run and the original non-
accounting run. Each group consists of three bars, the en-
ergy/time/powerconsumption.Theerrorbarsindicatestan-
dard deviation.)
leadtosevereoverhead.Table 1showstheoverheadofthelatter
approach.Evenwiththeaggressiveomissionofenergyreadings,
that approach still yields a significant overhead. A compiler-based
approach ofselectiveinstrumentationmayhelp, butwiththegap
beingsolarge,itisunlikelysuchanapproachwouldproduceresults
withpracticallyviable overhead.Note that even if the instrumentation-based approach can get
overthehurdleoflongiterationorsignificantoverhead,suchan
approach is still fundamentally concurrency-oblivious: during the
executionbetweenthemethodstartandend,othermethodsmay
be co-running.
Concurrency-Oblivious Accounting. To quantify the impact of
concurrency awareness, we construct an experiment to show how
muchenergyover-attributioncouldhappenshould Chappieignore
multi-threading.Asthisexperimentisonlyformotivationpurposes,
we take the simple approach of assigning 100% of each energy
sample to a method if its host thread is active in that sampling
interval; whenmultiple threadsare active, duplicated assignments
are possible. We show these results in Table 2. The take-away
message here is that a concurrency-oblivious energy accounting
designmayleadtosignificantover-attributionofmethodenergy
consumption.
Power Disturbance. Our investigation into calmness was moti-
vatedbythecounter-intuitivebehaviorofsomebenchmarksduring
the early stageofthe Chappie evaluation.
Ourintuitionwasthatthebookkeepingofaccountingmaycarry
some overhead so the accounting run would be slower than the
originalrun.Someexperimentshoweverrevealedanoppositetrend.
As shown in Figure 4, ifChappie had set the sampling rate at 1
millisecond(ms),theexecutionof h2wouldturnouttobenearly
18%fasterthanthe originalnon-accounting run!
Thekeytoresolvingthisbafflingmysteryispowerconsumption.
As it turns out, the sampling rate of 1ms would lead to nearly a
50%ofpowerincrease:thesampling-basedapproachperiodically
Å‚pokesÅ¾theapplication,preventingtheapplicationfromsleeping
duringdowntime.Inthesescenarios,DVFSlikelyincreasesCPU
frequency to handle the higher workload, which in turn allows the
applicationto run faster.
Themoralofthestoryisthataccounting,ifdesignednaively,may
introducedisturbanceandsignificantlyaltertheenergybehaviorof
theoriginalapplication.The good newsis powerdisturbancewill
be reduced as the sampling rate decreases: as sampling slows to
32ms,thepowerconsumptiondifferencebetweentheaccounting
run andthe originalrun isonly 3%.
3CHAPPIE DESIGN
Inthissection,weprovideahigh-levelspecificationfor Chappie
runtimeandmetric design.
3.1 Runtime Design
On the top level, the Chappie runtime is specified by the Chap-
pieRuntime function in Algorithm 1. Here,Chappie continuously
samples raw energy consumption (Line 12) and JVM stack infor-
mation(Line 14)andcombinesthetwotoproducean attribution
(Line17),i.e.,howeachlogicalunitofthemonitoredapplication
(suchasamethod)maybeassignedwithaportionoftheenergy
consumptionreading obtained from theunderlying system. Struc-
turally, each attribution Ais a mapping from a logical application
unitLUnittoitsshare ofenergyconsumption ETypewhichisan
abstractrepresentationofjoules.Notation âˆ…representsanempty
map.
979CalmEnergyAccountingforMultithreadedJava Applications ESEC/FSE â€™20, November8â€“13,2020,VirtualEvent, USA
Algorithm1 Chappie Sampling
1typedefTidInt//thread ID
2typedefEtype Float //energy in joules
3typedefLunitStringâˆª{âŠ¥}//accountinglogicalunit
4EPOCH:Int//VMsampling interval
5A:Map<Lunit,Etype> //Output attribution
6T:Set<Tid> //VMthreads
7V:Map<Tid,Lunit> //thread-indexed logicalunits
8function ChappieRuntime
9Aâ†âˆ…
10loop atrate (EPOCH)
11Vâ†âˆ…
12ğœ–â†ESample()
13fortinTdo
14V[t]â†Abstract(Stack(t))
15ğ›¼=|{t|V[t]â‰ âŠ¥}|
16forvinVandvâ‰ âŠ¥do
17A[v]â†A[v]+ğœ–Ã—1
ğ›¼
18function ESample :EType//obtain energy reading
19function Stack(Tid):Stack//obtain thread stack
20function Abstract (Stack) :LUnit// transform stack to logical unit
The goal of each JVM sampling step (Line 14) is to obtain an
abstract representation (the Abstract function) of the runtime
stackoftherunningthreads(the Stackfunction).Thelatterreturns
either the runtime stack frame information if a threadis active, or
emptyotherwise,with Abstract(âˆ…)=âŠ¥.Givenanenergysample
ğœ–,thealgorithmfirstcountsthenumberofactivethreads ğ›¼,andeach
active thread Ã and its associated logical unit Ã will be attributed
withafraction1
ğ›¼ofğœ–.Theshareofenergyattributedtoeachlogical
unitisaccumulatedin A,at Line17.
Chappie features an extensible and customizable design. De-
pending on how the Abstract function and the Lunittype are
concretized, the algorithm can express a variety of granularities in
application-levelenergyaccounting.Ourdefaultimplementation
supports energyaccounting over deep application methods , which
assigns energy consumption to an application (i.e., non-library)
method when either the said method is at the stack top, or it is the
callingcontexttoalibrarymethodthatisatthestacktop. Chappie
allows users to customize the Abstract function. Currently, addi-
tionalversionshavebeenimplementedfor context-sensitive method
energy accounting, and class/package/thread energy accounting
(see ÄŸ5).
3.2 MetricDesign
We now provide a rigorous definition for calmness. Its essence lies
uponthesimilaritybetweentheruntimecharacteristicsofanac-
countingrunagainsta referencerun ,i.e.,theoriginalapplicationrun
when the accounting system is not at work. To simplify the matter,
wefirstconsidertheidealizedcasewhereoneinstanceofapplica-
tionexecutionissufficienttocapturetheruntimecharacteristics.
LetEPOCHrepresentthesetofepochsintheformof N+,withthe
firstepochofeachrunstartingatepoch1.Let COREthesetofCPU
coresandFREQthesetofobservableCPUfrequencies.Eachrunbenchmark workload methods total threads active threads execution time (s)
avrora large 576 71 69 175.98
batik large 924 9 8 17.41
biojava default 103 7 6 22.76
eclipse default 5423 706 18 59.14
graphchi huge 124 53 50 246.78
h2 large 3676 954 39 115.91
jython default 1426 7 6 10.63
pmd large 950 8 6 54.65
sunflow large 257 88 46 61.13
tomcat large 3214 109 106 27.0
xalan default 1071 47 46 9.0
Figure 5: Benchmark Statistics (Workload refers to the data
size specified by DaCapo for each benchmark. Methods
showsthenumberofuniquemethodsappearedinthetrace.
Total threads shows the number of the threads created
throughout the lifetime of the application. Active threads
shows the maximum number of the concurrent threads at
anyepoch. )
benchmark ratebatches PCC SERMSE
avrora 64 60.9944 0.0145 0.0027
batik 8 20.9998 0.0010.0005
biojava 128 30.9968 0.0139 0.022
eclipse 16 40.9950.0019 0.0002
graphchi 16 50.9981 0.0089 0.0066
h2 32 20.9977 0.0046 0.0013
jython 32 20.9980.0027 0.0005
pmd 16 20.9922 0.0079 0.0024
sunflow 64 20.9945 0.0088 0.004
tomcat 16 20.9999 0.0007 0.0004
xalan 16 20.9994 0.0013 0.0005
Figure 6: Accounting Parameters (Rate refers to the sam-
pling rate for each benchmark. Batches refers to the num-
berofdatacollectionrunsfortheaccountingofeachbench-
mark. PCC shows the correlation between the energy foot-
print produced from (n-1) batches and that produced from
n batches. SE shows the standard error of the PCC. RMSE
showstheroot meanssquare error.)
producesasetofsamples ğ‘†âˆˆP(EPOCHÃ—COREÃ—FREQ),where
eachsampleâŸ¨ğ‘’;ğ‘;ğ‘“âŸ©intuitivelysaystheCPUfrequencyofcore ğ‘
at epochğ‘’isğ‘“.First, letusintroduce someauxiliary functions.
Definition3.1(EpochCount). Wesayarunwithsamples ğ‘†con-
sists ofğ‘’ğ¶ğ‘œğ‘¢ğ‘›ğ‘¡(ğ‘†)epochswhere ğ‘’ğ¶ğ‘œğ‘¢ğ‘›ğ‘¡(ğ‘†)â–³=|ğ‘†|
|CORE|.
Definition 3.2 (Core Count). We say there are ğ‘ğ¶ğ‘œğ‘¢ğ‘›ğ‘¡(ğ‘†,ğ‘’,ğ‘“)
number of cores operating at frequency ğ‘“and epoch ğ‘’. where
ğ‘ğ¶ğ‘œğ‘¢ğ‘›ğ‘¡(ğ‘†,ğ‘’,ğ‘“)â–³=|{ğ‘|âŸ¨ğ‘’;ğ‘;ğ‘“âŸ©âˆˆğ‘†}|.Fromnowon,weusemetavari-
ableğ‘šâˆˆ[0..|CORE|]to represent the core count.
To study temporal calmness, we intuitively wish to characterize
how the power consumption Ã manifested by CPU frequencies
Ã Å‚flows and ebbsÅ¾ over time. We first introduce a function for
computing the CPU frequencies given a particular epoch ğ‘’in a
particular run.Observe that inoursample space, there are |CORE|
numberofsamplesforeachepoch,onefromeachcore.Ratherthan
assuming a fixed distribution, we represent the frequencies as a
distribution to preserve generality.Specifically,
980ESEC/FSE â€™20, November8â€“13,2020,VirtualEvent, USA Timur Babakol,AnthonyCanino,KhaledMahmoud, RachitSaxena,andYuDavid Liu
Epoch
frequency (GHz)
[2.75, 3.0)
[2.5, 2.75)
[2.25, 2.5)
[2.0, 2.25)
[1.75, 2.0)
[1.5, 1.75)
[1.25, 1.5)
[1.0, 1.25)
(a)no method sampling
Epoch
frequency (GHz)
[2.75, 3.0)
[2.5, 2.75)
[2.25, 2.5)
[2.0, 2.25)
[1.75, 2.0)
[1.5, 1.75)
[1.25, 1.5)
[1.0, 1.25) (b)32ms method sampling
Epoch
frequency (GHz)
[2.75, 3.0)
[2.5, 2.75)
[2.25, 2.5)
[2.0, 2.25)
[1.75, 2.0)
[1.5, 1.75)
[1.25, 1.5)
[1.0, 1.25) (c)1ms method sampling
Figure 7: Temporal Distribution of CPU Core Frequency for h2(The X-Axis represents the epoch series of the benchmark
execution,withthefirstepochandthelastepochindicatesthebeginningandendofexecution.Eachbarrepresentsaparticular
frequencyrange,whoseheightindicatesthenormalizednumberofCPUcoresatthatfrequencyatthatepoch.Forillustration,
we divide all frequencies into 8 ranges. For example, throughout the majority of (a), the orange bars show that 25% of cores
executebetween 1.25-1.5 GHz,untilthetail end, where 5% ofcoresexecute at that range.)
Definition3.3(TemporalCharacterization). Weuseğ‘‡ğ¶(ğ‘†)tocom-
pute thetemporal characterization for a run over samples ğ‘†.ğ‘‡ğ¶(ğ‘†)
computes to an element in EPOCHâ†¦â†’ (FREQâ†¦â†’ [0,1]), i.e.,
from each epoch to a frequency distribution . Formally, for each
ğ‘’âˆˆğ‘’ğ¶ğ‘œğ‘¢ğ‘›ğ‘¡(ğ‘†)andeach ğ‘“âˆˆFREQ,ğ‘‡ğ¶(ğ‘†)(ğ‘’)(ğ‘“)â–³=ğ‘ğ¶ğ‘œğ‘¢ğ‘›ğ‘¡(ğ‘†,ğ‘’,ğ‘“)
|CORE|.
Indeed, if we treat the frequency at epoch ğ‘’in the sample space
ğ‘†as a random variable, ğ‘‡ğ¶(ğ‘†)(ğ‘’)is its probability mass function
(PMF).
To study spatial calmness, we intuitively wish to characterize
how CPU frequencies Å‚spread outÅ¾ across cores. An intuitive repre-
sentationistoshowwhichcoresoperateoneachfrequency.This
intuitioncarriessomesubtlety.First,thereare ğ‘’ğ¶ğ‘œğ‘¢ğ‘›ğ‘¡(ğ‘†)number
of snapshots for the characterization of spreading out to be consid-
ered. The overall spatial characterization throughout an entire run
canbeintuitivelyviewedaseachepochintroducinganobservation
characterizing how CPU frequencies are spread out for that epoch.
Second,schedulingisfundamentallynon-deterministicandthreads
maymigratefromoneanother.Fordesigningacomparativemetric
like ours, this means that a comparative study for a fixed coreâ€™s
behavior is meaningless. What matters is how many cores operate
at a particular CPU frequency. With these two elaborations, we
define:
Definition3.4(SpatialCharacterization). Weuseğ‘†ğ¶(ğ‘†)tocom-
pute thespatial characterization for a run over samples ğ‘†.ğ‘†ğ¶(ğ‘†)
computes to an element in FREQÃ—CCOUNTâ†¦â†’ [0,1], i.e., a
frequency-coreCountbivariatedistribution ,definedas ğ‘†ğ¶(ğ‘†)(ğ‘“,ğ‘š)â–³=
|{ğ‘’|ğ‘š=ğ‘ğ¶ğ‘œğ‘¢ğ‘›ğ‘¡(ğ‘†,ğ‘’,ğ‘“)|}|
ğ‘’ğ¶ğ‘œğ‘¢ğ‘›ğ‘¡(ğ‘†).
Indeed, if we treat both the frequency and the core count in the
samplespace ğ‘†asa random variable, ğ‘†ğ¶(ğ‘†)istheirbivariate PMF.
Definition3.5(Calmness). Wesayanaccountingrunwithsam-
plesğ‘†iscalmrelative to areference run withsamples ğ‘†0iff:
â€¢[Time Correspondence] ğ‘’ğ¶ğ‘œğ‘¢ğ‘›ğ‘¡(ğ‘†)â‰ˆğ‘’ğ¶ğ‘œğ‘¢ğ‘›ğ‘¡(ğ‘†0)â€¢[Temporal Correspondence] for anyğ‘’such that ğ‘’<=
min(ğ‘’ğ¶ğ‘œğ‘¢ğ‘›ğ‘¡(ğ‘†),ğ‘’ğ¶ğ‘œğ‘¢ğ‘›ğ‘¡(ğ‘†0)),ğ‘‡ğ¶(ğ‘†)(ğ‘’)âˆ½ğ‘‡ğ¶(ğ‘†0)(ğ‘’)
â€¢[SpatialCorrespondence] ğ‘†ğ¶(ğ‘†)âˆ½ğ‘†ğ¶(ğ‘†0)
whereâ‰ˆandâˆ½abstractly represent the similarity between two
naturalnumbers andtwo distribution respectively, which we will
contretize inÄŸ 4.
Time correspondence captures that the accounting run must
have similar execution time as the reference run. The temporal
correspondenceandspatialcorrespondenceenforcethatthetwo
runsmusthavesimilarpowercharacteristics.Withenergybeingac-
cumulatedpowerovertime,thecriteriaabovetogethersaythatthe
energycharacteristicsbetweentheaccountingrunandreference
run are similar,the essenceof calm energyaccounting .
Multi-IterationRuns. Thediscussionsofarhasidealisticallyas-
sumed that there is only onereference run and oneaccounting run.
As most experiments are repeated to take into the fundamental
non-determinisminthesoftware-hardwarestack,thereferencerun
(as well as the accounting run) may consist of multiple executions
of theapplication,eachofwhich wecall an iteration. Ourcalmness
metric can be defined for multi-iteration runs in a nearly identi-
cal manner as Definition 3.5, with small changes. Let us assume
ağ‘˜-iterationrunproducessamples ğ‘†1,...,ğ‘†ğ‘˜respectively,wecan
followDefinition 3.5toconstructthecalmnessmetricoversamples
ğ‘†1âˆªÂ·Â·Â·âˆªğ‘†ğ‘˜,with|CORE|redefinedasthenumberofCPUsmulti-
plied byğ‘˜. Intuitively, this implies we can conceptually view the
ğ‘˜-iteration run as one parallel run of ğ‘˜instances of the application
overğ‘˜times of physical CPUs. This formal view simplifies our
algorithm specification: we do not need to repeat all definitions we
introduced earlier for multi-iterations runs. Practically, this means
we can merge all the samples we collected from different iterations
byreusingtheformaldefinitionwehavegivenforasingleiteration.
For example, Fig. 8shows the equivalentview of a three-iteration
run on a two-core machine (with CPU1andCPU2) of an application
981CalmEnergyAccountingforMultithreadedJava Applications ESEC/FSE â€™20, November8â€“13,2020,VirtualEvent, USA
CPU
1CPU
2App in
Iteration 1App in
Iteration 2App in
Iteration 3
CPU
1CPU
2CPU
1CPU
2
Figure 8:AMulti-IterationRun
app.Sincebothourreferencerunandprofilerunconsistofmulti-
iterations in our experiments, this view has been adopted in our
data analysisover calmness, to be reportedinthe nextsections.
4CHAPPIE IMPLEMENTATION
ThreadModelOverview. Weimplementthe Chappieruntimeasa
threadofitsown,inthesameJVMruntimeastheapplicationbeing
accountedfor.Thetop-levelloopconstructinthespecificationis
implemented with a timer. The thread periodically wakes up, with
nobusy waiting.
The globalstructure Tin the specificationrequiresthread-safe
access. To prevent it from becoming a bottleneck, we implement
it with a delayed buffer . Whenever a thread is started (or exited),
an entry is added (or removed) from this delayed buffer to indicate
the change. Periodically at every epoch, the thread that runs the
Chappieruntimewillretrievefromthebufferandapplythechanges
Ã adding a thread or removing a thread Ã to its exclusively held
Tstructure.Asaresult, Tdoesnotrequiresynchronization,and
only the delayedbuffer isimplementedas asynchronized Queue.
Call Stack Sampling. Traditional approaches for accessing the
thread stacks Ã such as through the Thread.getStackTrace Ã
incursignificantoverhead.Tocircumventthisrestriction,weresort
to a Hotspot VM API, the AsyncGetCallTrace method, to sample
thecallstack,amethodalsousedbypopularprofilerssuchasthe
asyncprofiler[ 2],whichourimplementationbuildson.Tointegrate
with the async tool which supports asynchronous stack sampling,
wemaintainabuffertokeepthestacksamples,andusetimestamps
to align themintoeachepoch.
The async profiler can sample both Java stacks and the native
stacks Ã the latter may result from either though JNI invocation or
JITcompilation Ãand Chappie can handle both as aresult.
HardwareEnergyReadingandCPUAffinity. WerelyonIntelâ€™s
RAPL [18] interface to obtain energy samples at the granularity
ofCPUpowerdomains(sockets).Energysampleswerecollected
using jRAPL [ 36], a Java library for interfacing with RAPL. We
are able to sample both CPU package and DRAM energy. As our
experimental platform consist of multiple sockets, we treat each
socketasaseparatelocaleforattribution(Algorithm 1)andcombine
data together. As the OS scheduler may migrate a thread from one
socket to another, we maintain the CPU affinity information to
keeptrackofthesocketÃandhencethelocaleofattributionÃa
thread belongs to.
MetricImplementation. Predicate ğ‘’â‰ˆğ‘’â€²inDefinition 3.5isim-
plemented as the normalized difference between ğ‘’andğ‘’â€²is less
than5%.Thesimilaritybetweendistributions( âˆ½)isimplementedthroughthestandardmetricofPearsonâ€™sCorrelationCoefficient
(PCC) between the pair of distributions. Two distributions are con-
sidered similar iff their PCC > 0.85. In general, PCC above 0.7 is
consideredstrongly correlated.
Theğ‘‡ğ¶andğ‘†ğ¶functions both usePMFs to represent the distri-
butions.AlthoughmodernCPUsonlypublishasmallnumberof
CPU frequencies, the observed CPU frequencies are much more
diverse. For example, in our experiments, we observed 225 distinct
frequencies in our data samples. This implies that if the original
PMF is used, there are a large number of elements in the vector
for PCC computation. This is a well-known problem, and we have
appliedFreedman-Diaconisruletobinsimilarfrequenciestogether.
Temporal correspondence in Definition 3.5relies on epoch-wise
distribution similarity. While time correspondence establishes that
the number of epochs for the reference run and those for the ac-
countingrunaresimilar,asmalldifferencemaystillexist.Defini-
tion3.5takes the approach of only considering the less number
oftheepochsbetweenthetworuns.Inpractice,wefoundthatif
anaccountingrunis(slightly)slowerthanthereferencerun,the
delayed effect w.r.t. the frequency behavior often exhibits gradu-
ally as time goes on. To capture this gradual shift, we use a simple
interpolationapproachtomakethetworunsmatchonepochs:if
the number of epochs for the reference/accounting run is ğ‘’0and
ğ‘’â€²
0respectively,weadjusteachrawsampleintheaccountingrun
âŸ¨ğ‘’;ğ‘;ğ‘“âŸ©toâŸ¨ğ‘’â€²;ğ‘;ğ‘“âŸ©whereğ‘’â€²=ğ‘’Ã—ğ‘’â€²
0
ğ‘’0. Sinceğ‘’0andğ‘’â€²
0are similar,
this adjustmentonly affectsasmall portion of samples.
5CHAPPIE EVALUATION
5.1 EvaluationMethodology
We evaluated Chappie on a dual socket Intel E5-2630 v4 2.20 GHz
CPUserver,with10coresineachsocketand64DDR4RAM.Hyper-
threadingisenabled.ThemachinerunsDebian4.9OS,Linuxkernel
4.9, with the default Debian powersave governor.All experiments
were run with Java 11 on top of Hotspot VM build 11.0.2+9-LTS.
Wheneachexperimentisperformed,theOShasnootherworkload.
Chappie isevaluatedovertheDaCapobenchmarksuite[ 9],of
its recent version evaluation-git+8b7a2dc, released in June 2019.
This release includes state-of-the-art workloads such as graphchi
andbiojava.Aslong(er)-runningapplicationsaremoreinteresting
w.r.t. energy management, we focus onbenchmarks whose execu-
tiontimeisaroundorabove10seconds.Amongthe13benchmarks
thatfitintothiscriterion,weexcluded2ofthem:themajorityof
application code of tradesoap andtradebeans is run in a new
processÃasopposedtoanew threadÃwhoseaccounting Chappie
currentlydoesnotsupportwithoutmodifyingbenchmarksource
code.
The statistics of the benchmarks are shown in Figure 5. Here
theexecutiontimereferstoaveragethebenchmarkrunningtime
over all of its iterations which we discuss shortly. The DaCapo
harnesssetuptimeisexcluded.ThebenchmarksarerealisticJava
applications with thousands of methods and diverse characteris-
ticsinmulti-threading,bothintermsoftotalcreatedthreadsand
concurrently running threads.
Figure6summarizestheparametersettingsusedfortheaccount-
ingofeachbenchmark.Recallthatcalmenergyaccountingrequires
982ESEC/FSE â€™20, November8â€“13,2020,VirtualEvent, USA Timur Babakol,AnthonyCanino,KhaledMahmoud, RachitSaxena,andYuDavid Liu
0
4
8
12
16
20
24
28
32
36
40
Cores Operating At Frequency
0.0%
5.0%
10.0%
15.0%
20.0%
25.0%
30.0%
35.0%
40.0%
Chance of Occurance
frequency (GHz)
[2.75, 3.0)
[2.5, 2.75)
[2.25, 2.5)
[2.0, 2.25)
[1.75, 2.0)
[1.5, 1.75)
[1.25, 1.5)
[1.0, 1.25)
(a)no method sampling
0
4
8
12
16
20
24
28
32
36
40
Cores Operating At Frequency
0.0%
5.0%
10.0%
15.0%
20.0%
25.0%
30.0%
35.0%
40.0%
Chance of Occurance
frequency (GHz)
[2.75, 3.0)
[2.5, 2.75)
[2.25, 2.5)
[2.0, 2.25)
[1.75, 2.0)
[1.5, 1.75)
[1.25, 1.5)
[1.0, 1.25) (b)32ms method sampling
0
4
8
12
16
20
24
28
32
36
40
Cores Operating At Frequency
0.0%
5.0%
10.0%
15.0%
20.0%
25.0%
30.0%
35.0%
40.0%
Chance of Occurance
frequency (GHz)
[2.75, 3.0)
[2.5, 2.75)
[2.25, 2.5)
[2.0, 2.25)
[1.75, 2.0)
[1.5, 1.75)
[1.25, 1.5)
[1.0, 1.25) (c)1ms method sampling
Figure 9: Spatial Distribution of CPU Core Frequency for h2(The X-Axis shows the number of cores observing the same
frequency in the same epoch. The Y-Axis shows the probability that a frequency is observed. For illustration, we divide all
frequencies into 4 ranges. For example, the red bar on the 3rd tick on (c) says that there is a 15% chance that 3 cores run in
frequencyrange 2.5 -3.0+GHzat thesametime.The sum ofheightsofallbars equals to 1.
minimaldisturbancetotheoriginalbenchmark, Chappiesetsadis-
tinctsamplingrate(asdefinedby EPOCHinAlgorithm 1)foreach
benchmarktoensurecalmness,showninthe ratecolumn.Thesec-
tion of this rate will be the focus of ÄŸ 5.2. To gain confidence in the
precisionoftheenergyfootprints, Chappiereliesonacombination
ofcold/hot executionsto collectdata: each batchisadistinct JVM
instance that subsumes iterations, i.e., hot execution instances of a
benchmark. We elaborate on the number of batches in Section 5.4.
Witheachbatch,weperform10iterationsbydefaultandfollowthe
standard practice of discarding thedata from the first2 iterations.
As exceptions, we perform 30 iterations (and discard the first 2)
forsunflowandjython,because ofthe relatively large standard
deviationoftheirexecutiontime(>10%)iffeweriterationsareused
for data collection.
5.2 AchievingCalmness
In this section, we study how the calmness metric is used for deter-
mining the judicious sampling rate for each benchmark. Before we
presenttheresultforallbenchmarks,webegin withavisualelab-
orationontemporalcorrespondenceandspatialcorrespondence,
the cornerstones ofcalmness.
Figure7shows the temporal behavior of h2under 3 different
settings: the reference run, the Chappie-accounting run under the
selectedsamplingrate32ms,andthe Chappie-accountingrunifthe
samplingrateweresetat1ms.Withineachsub-figure,timeelapses
from left to right. Its time-dependent variation is an illustration of
power phased behaviors. As one can see, the shape of the 32ms-
samplingresultissignificantlymoresimilartothatofthereference
run,thanthe1ms-samplingresult.Thetemporalcorrespondence
definitioninDef. 3.5isintendedtocapturethesimilarityofthefor-
mer(and the disimilarity of the latter).One interesting observation
isthatthe1ms-samplingresultshowsmoreCPUcoresarelikelyto
be driven into a higher frequency; this is consistent with our intu-
ition that a higher sampling rate may have significantly increased
activity in CPU cores, rendering them into higher frequencies due
to DVFS. Finally, observe that Figure 7(c) consists of fewer epochs,becausetheruncompletessignificantlyfasterthanthereference
run.
Figure7showsthespatialbehaviorof h2underthesame3differ-
entsettingsasearlier.Here,wecareabouthowafrequencyÅ‚spreads
outÅ¾ across cores. If all cores have the same frequency at the same
time, it indicates a Å‚perfectly balancedÅ¾ power consumption across
cores. Within each sub-figure, this is indicated by the rightmost
pointontheX-axis.Asonecansee,theshapeofthe32ms-sampling
result is again significantly more similar to that of the reference
run,thanthe1ms-samplingresult.Thespatialcorrespondencedefi-
nition in Def. 3.5is intended to capture the similarity of the former
(and the disimilarity of the latter). Specific to h2, the relative unbal-
ancednessisnotsurprising: h2asanin-memorydatabaseisknown
to be an I/O-intensive benchmark with a low degree of parallelism.
Finally, Figure 10summarizes the 3 components used to de-
termine calmness:time overhead, temporal correspondence, and
spatialcorrespondenceacrossallbenchmarks.Thefullresultsin-
cludingstandard deviationaredeferredtotheAppendix.Ifadata
point is missing, it means the data is out of the range (of our in-
terest).Basedonourprofilingcalmnessstudies,wehaveselected
the sampling rate for each benchmark with results shown in the
secondcolumn ofFigure 6.
5.3 ProducingEnergy Footprints
Method-GrainedAccounting. Theenergyfootprintreportedby
Chappie can be of various logical units of abstraction. The default
unit, i.e., each entry in the energy footprint, is the deep application
method,asdiscussedinÄŸ 3.Inourreporteddata,amethodisviewed
as a library method if it belongs to a class whose qualified name
startswith java,jdk,sun,andapache.commons .Amethodbelong-
ingtoanyadditionalthird-partylibraryistreatedasanapplication
method.
Fig.11illustratesaportionofthisfootprintÃthetop-10energy-
consuming methods Ã for graphchi , a concrete instance of the
983CalmEnergyAccountingforMultithreadedJava Applications ESEC/FSE â€™20, November8â€“13,2020,VirtualEvent, USA
1
 2
 4
 8
16
 32
 64
128
 256
 512
Sampling Rate (ms)
âˆ’15
âˆ’10
âˆ’5
0
5
10
15Runtime Overhead (%)
avrora
batik
biojava
eclipse
graphchi
h2
jython
pmd
sunflow
tomcat
xalan
(a)time overhead
1
 2
 4
 8
16
 32
 64
128
 256
 512
Sampling Rate (ms)
0.75
0.80
0.85
0.90
0.95
1.00Temporal Correspondence
avrora
batik
biojava
eclipse
graphchi
h2
jython
pmd
sunflow
tomcat
xalan
(b)temporal correspondence
1
 2
 4
 8
16
 32
 64
128
 256
 512
Sampling Rate (ms)
0.75
0.80
0.85
0.90
0.95
1.00Spatial Correspondence
avrora
batik
biojava
eclipse
graphchi
h2
jython
pmd
sunflow
tomcat
xalan
(c)spatial correspondence
Figure 10: A Summary of Benchmark Calmness (For both
sub figures, each line indicates a benchmark and the axis
indicates themethod samplingrate.)
namesake data-intensive graph processing system [ 35]. The Da-
Capoâ€™s benchmarkimplements ALS matrixfactorization, an itera-
tivealgorithmwithgraphtraversalandupdates.Theenergyfoot-
print generated by Chappie corroborates the nature of this bench-
mark,withthetoprankedmethodbeing ALSMatrixFactorization
.update. The next three highest-ranked methods are related to
graphtraversal,withmethods ChiVertex.outEdge andChiVertex
.inEdgeforaccessingtheedgesofavertex,and DataBlockManager.
dereference for fetchingthe valueassociatedwithan edge.
Itisinterestingtoobserve that energyconsumption and execu-
tiontimedonotalwayscorrespond.In graphchi ,methodALSMatrix
Factorization.update hasahighernormalizedenergyconsump-
tion than its execution time, indicating that the system is in a
higher-power state. This method is mathematical in nature, and
our results can be intuitively explained through a well-known phe-
nomenon: with default governors, compute-intensive workloads
often lead the CPU to a higher-power state. As a counter example,
0.0
 0.1
 0.2
 0.3
 0.4
 0.5
 0.6
 0.7
 0.8
Normalized Energy ConsumptionMethod
BufferedDataInputStream.readChiVertex.addInEdgeMemoryShard.loadAdjChunkFloatConverter.getValueHugeDoubleMatrix.getRowDataBlockManager.getRawBlockChiVertex.inEdgeDataBlockManager.dereferenceChiVertex.outEdgeALSMatrixFactorization.update
time
energyFigure 11: Top 10 Energy-Consuming Application Methods
forgraphchi (Each green/red bar indicates the normalized
energy/time of a top consuming method. Energy is directly
computedby Chappie accordingtoouralgorithmspecifica-
tion. Time is approximated by the number of samples mul-
tiplied by thelength ofthe samplinginterval. )
Page.binarySearch
[Cursor.min, Cursor.hasNext]
[MVMap.binarySearch, MVMap.binarySearch]
[MVMap.binarySearch, MVMap.get]
[MVMap.put, MVMap.put]
[MVMap.remove, MVMap.remove]
Figure 12: Context-Sensitive Method Accounting for top 10
energy-consuming method of h2. (Each slice with context
[X,Y]indicatesthatamethodiscalledbyYwhichinturnis
calledbyX.Notethatoneofthecallingcontextisrecursive.)
MemoryShard.loadAdjChunk has a lower power, consistent with
the fact that this methodisI/O-intensive.
CallingContext-GrainedAccounting. Throughprovidingdiffer-
ent concrete Abstract functions (see Section 3),Chappieis a gen-
eralframeworkthatcanbecustomizedtoaccountforprogramming
abstractionsatdifferentlevelsofgranularity.Forexample, Chappie
canreportmethodenergyconsumptioninacontext-sensitiveman-
ner, i.e., accounting for different calling contexts separately. Fig. 12
provides a finer-grained view into two top consuming methods
forh2, an in-memory database. Our results show that the majority
of energy consumption for Page.binarySearch comes from the
(recursive) calling context of MVMap.binarySearch which aligns
with our understanding of binary search algorithms. This example
showsthat Chappie atthecontext-sensitive granularity provides
additionalcontextthatpaintsafine-grainedpictureforunderstand-
ingthe energy behaviorof h2.
984ESEC/FSE â€™20, November8â€“13,2020,VirtualEvent, USA Timur Babakol,AnthonyCanino,KhaledMahmoud, RachitSaxena,andYuDavid Liu
0.0
 0.1
 0.2
 0.3
 0.4
 0.5
 0.6
Normalized Energy ConsumptionClass
CompositeGraphicsNodeSVGClipPathElementBridgeParsedURLDefaultProtocolHandlerSVGOMDocumentPNGEncodeParamAbstractGraphicsNodeFillShapePainterCSSEngineStrokeShapePainterPNGImageEncoder
energy
(a)Class
0.0
 0.1
 0.2
 0.3
 0.4
 0.5
 0.6
Normalized Energy ConsumptionPackage
org.apache.batik.css.engine.valueorg.apache.batik.css.parserorg.apache.xerces.implorg.apache.batik.utilorg.apache.batik.domorg.apache.batik.bridgeorg.apache.batik.anim.domorg.apache.batik.css.engineorg.apache.batik.gvtorg.apache.batik.ext.awt.image.codec.png
energy (b)Package
Figure 13: Top 10 Energy-Consuming Application Classes and Packages (Each green normalized energy of a top consuming
class orpackage.)
Class-and Package-GrainedAccounting. Alternatively, Chappie
can be customized with an Abstract for Java class- and package-
level granularity. Figure 13shows the result for batik, an Apache
toolkit for transforming and rendering Scalable Vector Graphics
(SVG) [1]. The DaCapo benchmark focuses on the use scenarios of
transformingSVGfilesintoPortableNetworkGraphic(PNG)im-
ages and rendering them. Our results show that PNGImageEncoder
andStrokeShapePainter classes are responsible for a majority of
batikenergy consumption, which happens to be aligned with the
main features of this application: transformation and rendering.
As classes are often the abstraction units for dividing program-
ming tasks among developers in large-scale software development,
Chappie class-level energy footprint provides insight on which
programmers are the critical link on developing energy-conscious
software. One granularity coarser, Chappie can further demon-
strate energy consumption at the package level. For batik, half of
itsenergyconsumptionresultsfromPNGcodec,asshowninthe
packageorg.apache.batik.ext.awt.image.codec.png .
5.4 Overhead andPrecision
As a disturbance-mitigated approach, Chappie is fundamentally
overhead-averse: it selects a sampling rate only when calmness
isachieved,leadingtominimaltimeoverhead(accordingtotime
correspondenceinDef. 3.5)andminimalpower/energyoverhead
(accordingtotemporal/spatialcorrespondenceinDef. 3.5).Forall
benchmarks operating at the selected sampling rate, the average
time overhead is 3.15 Â±3.03% and the average energy overhead is
0.84Â±1.09%.
Withmulti-batchrunsaspartofthedesign, Chappieisalsocon-
structed with precision as an inherent goal. Intuitively, the ground
truth of energy consumption of a method is the accumulation of
the energy consumption from all of its instructions. This is equiva-
lenttoasampling-basedapproachwherethenumberofsamples
approachesinfinity.Onestandardmetrictostudytheapproxima-
tion to the ground truth is the convergence of results, i.e., whether
introducing more samples maysignificantly changethe results.Toachievethisgoal,westudytheextentthattheenergyfootprint
may change when data from an additional batch are introduced.
Intuitively, if introducing additional batches of samples can lead to
little change in the energy footprint, convergence is achieved. We
compute the PCC between the data of n-1batches and that of n
batches, and set the batch parameter for the benchmark as nif the
PCCisgreaterthan0.99.The batchescolumnofFigure 6showsthe
batchsettingforeachbenchmark.Mostbenchmarksrequireonly2
batchesÃtheminimumnumberina relationalapproachwetake
Ã to achieve PCC> 0.99. The remaining benchmarks, e.g., avrora,
exhibithighervariability,butobservethateachstillconvergesto
our high PCCrequirement within alimitednumber of batches.
6 RELATED WORK
Energy accounting is a classic problem at lower layers of the com-
puting stack. Examples include iCount [ 20] at the digital circuit
level and Currentcy [ 52] at the OS level. With the primary goal
of attributing a global energy budget to individual components,
totalityisimplicitinenergyaccountingsolutions.Thispaperisa
systematic study of bringing energy accounting to the application
level, where the individual components at concern are methods,
callingcontexts,classes,andpackages.
At the application level, energy accounting and energy profiling
overlap in their overall goal of characterizing the runtime char-
acteristics of an application. While accounting is implicitly total,
profilingmayormaynot.Thisiswhyinstrumentationremainsa
viableapproachinexistingenergyprofilersastheymanychoose
to study the runtime characteristics of individual logical units one
by one. This approach is particularly common in empirical stud-
ies, where the energy consumption of specific program features
isreportedbasedoninstrumentingsuchfeatures.Withafeature
focusÃe.g.,theuseoftheconcurrentcollectionsAPI[ 25,45],or
the impact of data access patterns [ 36] Ã instrumentation can be a
feasible solution as it can be placed for one code block at a time. In
thisusescenario, Chappiemaybeusefulinimprovingtheprecision
ofprofiling by makingtheprofiler concurrency-aware.Eprof[ 41]
accounts for smartphone energy consumption through tracking
985CalmEnergyAccountingforMultithreadedJava Applications ESEC/FSE â€™20, November8â€“13,2020,VirtualEvent, USA
I/Osystemcallsandpre-definedSDK-NDKroutines,producinga
breakdownonimportantsmartphoneusescenariosrelatedtothe
use of 3G network, screen, etc. E-Android [ 23] is a profiler that de-
tects Android collateral energy consumption through tracing a set
ofpre-definedenergy-criticalevents.Theseenergyprofilersmay
profilepre-definedapplicationcomponents,suchasthesoftware
componentfor3Gnetworkinteractionorscreentracking,buttheir
designs are geared toward physical components of the platform,
without a full account of general logical units as Chappie does.
Bokharietal.[ 10]definesaconceptualenergyprofilingframework
for resampling in the presence of measurement inaccuracy. Earlier
energyprofilerssuchasJouleTrack[ 48]andPowerscope[ 22]focus
onmeasurementframeworkdesign,addressing e.g.,howtoprovide
high-rate energy samples and how to synchronize the execution
withthe measurements.
Anotherkeyfeatureuniqueto Chappie isitssystematicinves-
tigation into power disturbance. We are unaware of existing en-
ergy profilersthatprovide metricstoquantify andovercomeit. In
non-energy profiler design, that a profiler may intervene and alter
thebehavioroftheoriginalapplicationisabasicfact,motivating
designers to reduce the overhead introduced by the profiler. For
non-energyprofilers,sayamemoryconsumptionprofiler,theeffect
of power disturbance Ã if any Ã is of a lesser concern. This is in
contrast with energy profiling, power disturbance may alter the
verycharacteristictheprofilerintendstocapture. Sampling-based
non-energy profilers are standard[ 28,51,54].
One area Chappie may positively impact on is application-level
energymanagementandoptimization,withsolutionsrangingfrom
energy-aware programming languages and energy-adaptive frame-
works. Severalexamplesmaydemonstrate this synergy.Green [ 5]
relies on online energy accounting to perform QoS calibration.
PowerDial[ 30]andJouleGuard[ 29]mayuseenergyfeedbackto
make control decisions. LAB [ 34] needs to continuously account
forenergyconsumptiontobalancelatency,accuracy,andbattery.
Eco [53] must track energy consumption to match the applica-
tion demand and the system resource supply. Aeneas [ 14] relies
on online energy readings to enable energy optimization guided
byreinforcementlearning.With Chappie,theseapplication-level
energyeffortscangracefullyextendtothemorecomplexusesce-
narios where the application may be multi-threaded, and multiple
applicationsmayco-exist.Anotherarea Chappie mayprovidees-
sentialsupportforisenergytestinganddebugging,anemerging
research direction [ 6,7,12,23,27,38,40,42,46]. As energy and
performance often go hand in hand, this direction may unify with
performancebugstudies[ 4,17,33,44]toprovidecomprehensive
software lifecyclesupport for software non-functionalproperties.
Thedualofenergyaccountingisenergyanalysis,abottom-up
approachtodeterminetheenergyconsumptionofaprogrambased
on its building blocks. With a bottom-up design principle, these
approachesarefine-grainedbydesign.Instruction-levelpoweranal-
ysis[50]mayassociateinstructionswithpowerprofiles.Additional
designsexisttoperformenergyanalysisinaWCET-likesetting[ 32],
on the bytecode level [ 26], and the LLVM IR level [ 24] for instance.
Energy analysis has a nearly orthogonal interest in illuminating
programenergyconsumptiontoours,andthetwoapproachesmayname rate
1 2 4 8 16 32 64 128 256 512
avrora -28.47Â±5.99%-18.67Â±2.50%-14.13Â±1.33%-2.88Â±0.18%7.78Â±0.48%10.87Â±0.73%7.95Â±0.76%8.91Â±0.64%11.17Â±0.86%11.31Â±0.83%
batik 2.01Â±0.07% 1.10Â±0.05% -0.42Â±0.03%-2.06Â±0.08%-2.76Â±0.15%-3.48Â±0.16%-2.65Â±0.11%-8.17Â±0.31%-2.54Â±0.10%-6.18Â±0.25%
biojava 9.13Â±0.28% 8.72Â±0.32% 4.56Â±0.14% 4.58Â±0.15% 1.59Â±0.07% 2.16Â±0.07%-1.00Â±0.04%-1.11Â±0.04%-1.02Â±0.03%-1.63Â±0.05%
eclipse 0.82Â±0.02% -0.55Â±0.01% 0.04Â±0.00% -2.09Â±0.03%-2.45Â±0.05%-0.96Â±0.03%-0.06Â±0.00%0.05Â±0.00%-0.06Â±0.00%-2.84Â±0.06%
graphchi 11.52Â±0.11%12.61Â±0.13% 8.18Â±0.10% 6.92Â±0.07% 6.63Â±0.06% 2.99Â±0.03% 3.77Â±0.04%3.21Â±0.03% 3.60Â±0.03% 1.62Â±0.02%
h2-15.63Â±0.25%-12.63Â±0.25%-4.66Â±0.05%-5.61Â±0.09%-3.51Â±0.05%-3.15Â±0.05%-2.24Â±0.02%-1.75Â±0.02%-1.96Â±0.02%-1.93Â±0.02%
jython 12.86Â±2.55% 9.40Â±1.85% 9.32Â±1.78% 6.44Â±1.25% 4.07Â±0.80% 2.59Â±0.50%-0.53Â±0.10%-1.91Â±0.36%-1.51Â±0.29%-4.20Â±0.82%
pmd 9.79Â±0.38% 8.06Â±0.37% 5.07Â±0.15% 3.98Â±0.11% 0.92Â±0.02% 0.78Â±0.01% 2.43Â±0.05%-0.75Â±0.01%0.39Â±0.01%-1.20Â±0.03%
sunflow 1.94Â±0.45% 16.58Â±3.53% 1.76Â±0.41% 11.96Â±2.86%7.93Â±1.82%19.05Â±4.02%1.12Â±0.25%5.79Â±1.33%14.62Â±3.06%-1.12Â±0.25%
tomcat 0.10Â±0.00% 0.26Â±0.00% 0.29Â±0.00% 0.30Â±0.00% 0.39Â±0.00% 0.10Â±0.00%-0.08Â±0.00%-0.21Â±0.00%-0.13Â±0.00%-0.66Â±0.01%
xalan 0.61Â±0.02% -0.81Â±0.03% -1.46Â±0.06%-1.37Â±0.05%-2.91Â±0.11%-3.61Â±0.14%-2.44Â±0.09%-4.29Â±0.16%-4.64Â±0.19%-4.04Â±0.17%
(a)Overhead
name rate
1 2 4 8 16 32 64 128 256 512
avrora 0.79Â±0.010.64Â±0.010.65Â±0.010.83Â±0.010.78Â±0.010.87Â±0.010.93Â±0.010.93Â±0.010.95Â±0.000.95Â±0.01
batik 0.86Â±0.030.88Â±0.020.91Â±0.020.89Â±0.020.91Â±0.020.91Â±0.020.89Â±0.020.90Â±0.020.90Â±0.020.89Â±0.02
biojava 0.93Â±0.010.94Â±0.010.95Â±0.010.98Â±0.010.99Â±0.001.00Â±0.000.99Â±0.000.99Â±0.001.00Â±0.001.00Â±0.00
eclipse 0.98Â±0.010.98Â±0.010.98Â±0.010.98Â±0.010.98Â±0.000.99Â±0.000.98Â±0.000.98Â±0.000.99Â±0.000.99Â±0.00
graphchi 0.75Â±0.010.78Â±0.010.82Â±0.010.86Â±0.010.85Â±0.010.82Â±0.010.85Â±0.010.89Â±0.000.87Â±0.010.88Â±0.00
h20.75Â±0.020.81Â±0.010.90Â±0.010.90Â±0.010.90Â±0.010.94Â±0.010.94Â±0.010.94Â±0.010.93Â±0.010.95Â±0.01
jython 0.98Â±0.010.98Â±0.000.99Â±0.000.99Â±0.000.99Â±0.000.99Â±0.000.99Â±0.001.00Â±0.001.00Â±0.001.00Â±0.00
pmd 0.95Â±0.010.95Â±0.010.96Â±0.010.93Â±0.010.94Â±0.010.96Â±0.010.96Â±0.010.96Â±0.010.97Â±0.010.96Â±0.01
sunflow 0.98Â±0.000.98Â±0.000.98Â±0.000.98Â±0.000.98Â±0.000.98Â±0.000.97Â±0.010.97Â±0.010.98Â±0.010.98Â±0.01
tomcat 1.00Â±0.010.96Â±0.030.96Â±0.020.95Â±0.020.95Â±0.020.92Â±0.030.94Â±0.020.91Â±0.030.94Â±0.020.95Â±0.02
xalan 1.00Â±0.021.00Â±0.011.00Â±0.010.98Â±0.030.96Â±0.040.98Â±0.020.95Â±0.030.99Â±0.020.99Â±0.010.97Â±0.02
(b)Temporal Correspondence
name rate
1 2 4 8 16 32 64 128 256 512
avrora 0.08Â±0.12-0.03Â±0.13-0.27Â±0.120.10Â±0.130.70Â±0.100.86Â±0.070.89Â±0.060.98Â±0.020.97Â±0.040.95Â±0.04
batik 0.69Â±0.100.77Â±0.080.80Â±0.080.80Â±0.080.80Â±0.080.87Â±0.060.82Â±0.070.87Â±0.060.86Â±0.060.90Â±0.05
biojava 0.32Â±0.130.33Â±0.140.41Â±0.140.36Â±0.160.35Â±0.170.59Â±0.140.46Â±0.160.82Â±0.100.85Â±0.090.88Â±0.08
eclipse 0.78Â±0.100.72Â±0.110.75Â±0.100.87Â±0.070.95Â±0.050.94Â±0.050.91Â±0.060.94Â±0.050.90Â±0.060.93Â±0.05
graphchi 0.85Â±0.060.85Â±0.060.87Â±0.060.93Â±0.050.95Â±0.040.98Â±0.030.97Â±0.030.99Â±0.021.00Â±0.010.99Â±0.01
h20.04Â±0.120.16Â±0.120.50Â±0.100.47Â±0.110.77Â±0.080.91Â±0.050.94Â±0.040.97Â±0.030.96Â±0.040.97Â±0.03
jython 0.80Â±0.090.80Â±0.090.83Â±0.080.86Â±0.070.90Â±0.070.92Â±0.070.83Â±0.090.94Â±0.060.87Â±0.090.87Â±0.09
pmd 0.60Â±0.110.75Â±0.080.69Â±0.090.62Â±0.090.78Â±0.080.79Â±0.070.91Â±0.050.90Â±0.050.95Â±0.040.93Â±0.04
sunflow 0.48Â±0.120.46Â±0.130.39Â±0.130.49Â±0.130.47Â±0.130.61Â±0.130.87Â±0.080.92Â±0.070.97Â±0.060.96Â±0.06
tomcat 0.58Â±0.180.80Â±0.110.95Â±0.050.97Â±0.040.96Â±0.040.98Â±0.030.98Â±0.030.98Â±0.030.97Â±0.040.98Â±0.03
xalan 0.68Â±0.200.68Â±0.170.89Â±0.120.90Â±0.100.88Â±0.120.75Â±0.180.95Â±0.060.93Â±0.080.76Â±0.160.88Â±0.09
(c) Spatial Correspondence
Figure 14: Calmness Statistics (Rate refers to the sampling
rate.)
followaclassicdualityinsoftwareresearch,reasoningvs.monitor-
ing.Practically,itisunclearhowrelatedworkadapttoscenarios
withmulti-threadedexecutions.
7 CONCLUSION
Chappie is a novel runtime design for application-level energy
accounting of multi-threaded Java applications with calmness as a
new metric to quantify power disturbance in energy accounting.
Theprojectrepositorycontainsalldataforallbenchmarks,anda
report for additionalfigures coveringallbenchmarks.
ACKNOWLEDGMENTS
We thank Doug Lea and Aleksey Shipilev for useful discussions on
theAsyncGetCallTrace functionalityandthehonestprofiler.This
projectissupportedbyUS NSF CNS-1910532.
APPENDIX
The detaileddataonruntime overhead,temporalcorrespondence,
andspatialcorrespondence,withstandarddeviationinformation,
are reportedinFigure 14.
REFERENCES
[1] Apache batik, https://xmlgraphics.apache.org/batik .
[2] Asyncprofiler, https://github.com/jvm-profiling-tools/async-profiler .
[3] h2 databaseengine, https://www.h2database.com/html/main.html .
[4]Alam, M. M. u., Liu, T., Zeng, G., and Muzahid, A. Syncperf: Categorizing,
detecting, and diagnosing synchronization performance bugs. In Proceedings
of the Twelfth European Conference on Computer Systems (2017), EuroSys â€™17,
pp. 298Å›313.
986ESEC/FSE â€™20, November8â€“13,2020,VirtualEvent, USA Timur Babakol,AnthonyCanino,KhaledMahmoud, RachitSaxena,andYuDavid Liu
[5]Baek, W., and Chilimbi, T. M. Green: a framework for supporting energy-
consciousprogrammingusingcontrolledapproximation. In PLDIâ€™10,pp.198Å›209.
[6]Banerjee,A.,Chong,L.K.,Ballabriga,C.,andRoychoudhury,A. Energy-
patch: Repairing resource leaks to improve energy-efficiency of android apps.
IEEE Transactions onSoftwareEngineering 44 , 5 (May2018),470Å›490.
[7]Banerjee,A.,Chong,L.K.,Chattopadhyay,S.,andRoychoudhury,A. De-
tecting energy bugs and hotspots in mobile apps. In Proceedings of the 22nd
ACMSIGSOFTInternationalSymposiumonFoundationsofSoftwareEngineering
(New York, NY, USA, 2014), FSE 2014, Association for Computing Machinery,
p. 588Å›598.
[8]Bartenstein,T.,andLiu,Y.D. Greenstreamsfordata-intensivesoftware. In
Proceedings of the 35th International Conference on Software Engineering (ICSE
2013)(May2013).
[9]Blackburn, S. M., Garner, R., Hoffman, C., Khan, A. M., McKinley, K. S.,
Bentzur, R., Diwan, A., Feinberg,D., Frampton, D.,Guyer, S. Z., Hirzel,M.,
Hosking, A., Jump, M., Lee, H., Moss, J. E. B., Phansalkar, A., StefanoviÄ‡,
D., VanDrunen, T., von Dincklage, D., and Wiedermann, B. The DaCapo
benchmarks: Java benchmarking development and analysis. In OOPSLA â€™06 ,
pp. 169Å›190.
[10]Bokhari, M. A., Weng, L., Wagner, M., and Alexander, B. Mind the gap Å›
a distributed framework for enabling energy optimisation on modern smart-
phones in the presence of noise, drift, and statistical insignificance. In 2019 IEEE
CongressonEvolutionaryComputation (CEC) (2019), pp. 1330Å›1337.
[11]Boston,B.,Sampson,A.,Grossman,D.,andCeze,L. Probabilitytypeinference
for flexibileapproximate programming. In OOPSLAâ€™15 .
[12]Bruce,B.R.,Petke,J.,andHarman,M. Reducingenergyconsumptionusing
geneticimprovement. In ProceedingsoftheGeneticandEvolutionaryComputation
Conference,GECCO 2015, Madrid,Spain,July 11-15, 2015 (2015), pp. 1327Å›1334.
[13]Canino, A.,and Liu,Y.D. Proactiveandadaptiveenergy-awareprogramming
withmixedtypechecking. In Proceedingsofthe38thACMSIGPLANConferenceon
Programming Language Design and Implementation, PLDI 2017, Barcelona, Spain,
June 18-23, 2017 (2017), pp. 217Å›232.
[14]Canino, A., Liu, Y. D., and Masuhara, H. Stochastic energy optimization
for mobile GPS applications. In Proceedings of the 2018 ACM Joint Meeting on
European Software Engineering Conference and Symposium on the Foundations
of Software Engineering, ESEC/SIGSOFT FSE 2018, Lake Buena Vista, FL, USA,
November 04-09, 2018 (2018), pp. 703Å›713.
[15]Chiba, S. Load-time structural reflection in java. In Proceedings of the 14th
European Conference on Object-Oriented Programming (Berlin, Heidelberg, 2000),
ECOOPâ€™00, Springer-Verlag, pp. 313Å›336.
[16]Cohen,M.,Zhu,H.S.,Emgin,S.E.,andLiu,Y.D. Energytypes. In OOPSLAâ€™12 .
[17]Curtsinger,C.,andBerger,E.D. Coz:Findingcodethatcountswithcausal
profiling. In Proceedingsofthe25thSymposiumonOperatingSystemsPrinciples
(2015), SOSP â€™15, pp. 184Å›197.
[18]David, H., Gorbatov, E., Hanebutte, U. R., Khanna, R., and Le, C. Rapl:
Memorypower estimationand capping. In ISLPEDâ€™10 , pp. 189Å›194.
[19]Dhodapkar, A. S., and Smith, J. E. Managing multi-configuration hardware via
dynamic working set analysis. In Proceedings of the 29th Annual International
Symposium on Computer Architecture (USA, 2002), ISCA â€™02, IEEE Computer
Society, p. 233Å›244.
[20]Dutta,P.,Feldmeier,M.,Paradiso,J.,andCuller,D. Energymeteringforfree:
Augmenting switching regulators for real-time monitoring. In 2008 International
ConferenceonInformationProcessinginSensorNetworks(ipsn2008) (2008),pp.283Å›
294.
[21]Fei, Y., Zhong, L., and Jha, N. An energy-aware framework for coordinated
dynamic software management in mobile computers. In MASCOTSâ€™04 (2004),
pp. 306Å›317.
[22]Flinn, J., and Satyanarayanan, M. Powerscope: a tool for profiling the energy
usageof mobile applications. In ProceedingsWMCSAâ€™99.SecondIEEE Workshop
onMobileComputingSystemsand Applications (1999), pp. 2Å›10.
[23]Gao,X., Liu,D.,Liu, D.,Wang,H.,and Stavrou, A. E-android: A newenergy
profiling tool for smartphones. In 2017 IEEE 37th International Conference on
DistributedComputingSystems(ICDCS) (June2017),pp. 492Å›502.
[24]Grech, N., Georgiou, K., Pallister, J., Kerrison, S., Morse, J., and Eder, K.
Static analysis of energy consumption for llvm ir programs. In Proceedings of
the 18th International Workshop on Software and Compilers for Embedded Systems
(2015), SCOPES â€™15, pp. 12Å›21.
[25]GutiÃ©rrez,I.L. M.,Pollock,L. L.,andClause,J. SEEDS: asoftware engineerâ€™s
energy-optimizationdecisionsupportframework.In 36thInternationalConference
onSoftwareEngineering,ICSEâ€™14,Hyderabad,India-May31-June07,2014 (2014),
pp. 503Å›514.
[26]Hao, S., Li, D., Halfond, W. G. J., and Govindan, R. Estimating android ap-
plicationsâ€™ cpu energy usage via bytecode profiling. In Proceedings of the First
InternationalWorkshoponGreenandSustainableSoftware (2012),GREENSâ€™12,
pp. 1Å›7.
[27]Hao, S., Li, D., Halfond, W. G. J., and Govindan, R. Estimating mobile applica-
tion energy consumption using program analysis. In ICSE â€™13(2013), pp. 92Å›101.
[28]Hirzel, M., and Chilimbi, T. Bursty tracing: A framework for low-overhead
temporal profiling. In 4th ACM Workshop on Feedback-Directed and DynamicOptimization(FDDO-4) (2001), pp. 117Å›126.
[29]Hoffmann,H. Jouleguard: Energy guaranteesfor approximateapplications. In
Proceedings of the 25th Symposium on Operating Systems Principles , SOSP â€™15,
pp. 198Å›214.
[30]Hoffmann, H.,Sidiroglou, S.,Carbin,M., Misailovic, S.,Agarwal, A.,and
Rinard, M. Dynamic knobs for responsive power-aware computing. In ASPLOS
â€™11.
[31]Isci,C.,andMartonosi,M. Identifyingprogrampowerphasebehaviorusing
power vectors. In In Workshop onWorkloadCharacterization (2003).
[32]Jayaseelan,R.,Mitra,T.,andLi,X. Estimatingtheworst-caseenergyconsump-
tion of embedded software. In 12th IEEE Real-Time and Embedded Technology
and ApplicationsSymposium(RTASâ€™06) (2006), pp. 81Å›90.
[33]Jin, G., Song, L., Shi, X., Scherpelz, J., and Lu, S. Understanding and detecting
real-worldperformancebugs. In Proceedingsofthe33rdACMSIGPLANConference
onProgrammingLanguageDesignandImplementation (2012),PLDIâ€™12,pp.77Å›88.
[34]Kansal, A., Saponas, S., Brush, A. B., McKinley, K. S., Mytkowicz, T., and
Ziola, R. The latency, accuracy, and battery (lab) abstraction: Programmer
productivity and energy efficiency for continuous mobile context sensing. In
OOPSLAâ€™13 , pp. 661Å›676.
[35]Kyrola, A., Blelloch, G. E., and Guestrin, C. Graphchi: Large-scale graph
computation on just a PC. In 10th USENIX Symposium on Operating Systems
DesignandImplementation,OSDI2012,Hollywood,CA,USA,October8-10,2012
(2012), pp. 31Å›46.
[36]Liu, K., Pinto, G., and Liu, Y. D. Data-oriented characterization of application-
levelenergyoptimization. In ProceedingsofFASE2015;JRAPLHome: http://kliu20.
github.io/jRAPL/ .
[37]Lucia,B.,andRansford,B. Asimpler,saferprogrammingandexecutionmodel
for intermittent systems. In Proceedings of the 36th ACM SIGPLAN Conference on
Programming Language Design and Implementation (2015), PLDI â€™15, pp. 575Å›585.
[38]Ma,X.,Huang,P.,Jin,X.,Wang,P.,Park,S.,Shen,D.,Zhou,Y.,Saul,L.K.,and
Voelker,G.M. edoctor:Automaticallydiagnosingabnormalbatterydrainissues
on smartphones. In Proceedings of the 10th USENIX Conference on Networked
SystemsDesignand Implementation (2013), nsdiâ€™13,pp. 57Å›70.
[39]Noble,B.D.,Satyanarayanan,M.,Narayanan,D.,Tilton,J.E.,Flinn,J.,and
Walker, K.R. Agileapplication-awareadaptationfor mobility. pp. 276Å›287.
[40]Pathak, A., Hu, Y. C., and Zhang, M. Bootstrapping energy debugging on
smartphones: A first look at energy bugs in mobile devices. HotNets-X â€™11,
pp. 5:1Å›5:6.
[41]Pathak, A., Hu, Y. C., and Zhang, M. Where is the energy spent inside my
app?:Finegrainedenergyaccountingonsmartphoneswitheprof. In Proceedings
of the 7th ACM European Conference on Computer Systems (2012), EuroSys â€™12,
pp. 29Å›42.
[42]Pathak, A., Jindal, A., Hu, Y. C., and Midkiff, S. P. What is keeping my phone
awake?: Characterizing and detecting no-sleep energy bugs in smartphone apps.
InMobiSys â€™12 , pp. 267Å›280.
[43]Pering, T., Burd, T., and Brodersen, R. The simulation and evaluation of
dynamic voltage scaling algorithms. In Proceedings of the 1998 International
Symposium on Low Power Electronics and Design (New York, NY, USA, 1998),
ISLPED â€™98, Associationfor Computing Machinery, p. 76Å›81.
[44]Pinto, G., Canino, A., Castor, F., Xu, G. H., and Liu, Y. D. Understanding and
overcoming parallelismbottlenecks inforkjoin applications. In Proceedingsof
the 32nd IEEE/ACM International Conference on Automated Software Engineering,
ASE 2017, Urbana, IL, USA, October 30 -November 03,2017 (2017), pp. 765Å›775.
[45]Pinto, G., Liu, K., Castor, F., and Liu, Y. D. A comprehensive study on the
energyefficiencyofjavathread-safecollections. In InternationalConferenceon
SoftwareMaintenance and Evolution(ICSME2016) (2016).
[46]Sahin,C.,Pollock,L.,andClause,J. Howdocoderefactoringsaffectenergy
usage? In Proceedings of the 8th ACM/IEEE International Symposium on Empirical
Software Engineering and Measurement (New York, NY, USA, 2014), ESEM â€™14,
Associationfor Computing Machinery.
[47]Sampson,A.,Dietl,W.,Fortuna,E.,Gnanapragasam,D.,Ceze,L.,andGross-
man, D.EnerJ: Approximate data types forsafe and general low-power compu-
tation. In PLDIâ€™11.
[48]Sinha, A., and Chandrakasan, A. P. Jouletrack-a web based tool for software
energyprofiling. In Proceedingsofthe38thDesign Automation Conference(IEEE
Cat. No.01CH37232) (2001), pp. 220Å›225.
[49]Sorber, J., Kostadinov, A., Garber, M., Brennan, M., Corner, M. D., and
Berger, E. D. Eon: a language and runtime system for perpetual systems. In
SenSys â€™07 , pp. 161Å›174.
[50]Tiwari,V.,Malik,S.,Wolfe,A.,andLee,M.T.. Instructionlevelpoweranalysis
andoptimizationofsoftware. In Proceedingsof9thInternationalConferenceon
VLSIDesign (1996), pp. 326Å›328.
[51]Whaley, J. A portable sampling-based profiler for java virtual machines. In
Proceedings of the ACM 2000 Conference on Java Grande (New York, NY, USA,
2000),JAVAâ€™00, ACM,pp. 78Å›87.
[52]Zeng, H., Ellis, C. S., Lebeck, A. R., and Vahdat, A. Currentcy: A unifying
abstraction for expressing energy management policies. In In Proceedings of the
987CalmEnergyAccountingforMultithreadedJava Applications ESEC/FSE â€™20, November8â€“13,2020,VirtualEvent, USA
USENIXAnnual TechnicalConference (2003), pp. 43Å›56.
[53]Zhu,H.S.,Lin,C.,andLiu,Y.D. Aprogrammingmodelforsustainablesoftware.
InICSEâ€™15(2015), pp. 767Å›777.[54]Zhuang, X., Serrano, M. J., Cain, H. W., and Choi, J.-D. Accurate, efficient,
and adaptive calling context profiling. SIGPLANNot. 41 ,6 (June 2006), 263Å›271.
988