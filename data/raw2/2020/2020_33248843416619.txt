Exploring the Architectural Impact of Possible Dependencies in
Python Software
Wuxia Jinâˆ—â€ 
jinwuxia@mail.xjtu.edu.cn
Xiâ€™an Jiaotong University
Xiâ€™an, ChinaYuanfang Cai
yfcai@cs.drexel.edu
Drexel University
Philadelphia, USARick Kazman
kazman@hawaii.edu
University of Hawaii
Honolulu, USA
Gang Zhang
gangz@emergentdesign.cn
Emergent Design Inc
Shanghai, ChinaQinghua Zhengâˆ—
qhzheng@mail.xjtu.edu.cn
Xiâ€™an Jiaotong University
Xiâ€™an, ChinaTing Liuâˆ—
tingliu@mail.xjtu.edu.cn
Xiâ€™an Jiaotong University
Xiâ€™an, China
ABSTRACT
Dependencies among software entities are the basis for many soft-
wareanalyticresearchandarchitectureanalysistools.Dynamically
typed languages, such as Python, JavaScript and Ruby, tolerate the
lackofexplicittypereferences,makingcertainsyntacticdependen-
ciesindiscernibleinsourcecode.Wecallthese possibledependencies,
incontrastwiththe explicitdependencies thataredirectlyreferenced
insourcecode.Typeinferencetechniqueshavebeenwidelystud-
ied and applied, but existing architecture analytic research and
tools have not taken possible dependencies into consideration. The
fundamentalquestionis, towhatextentwillthesemissingpossible
dependencies impact the architecture analysis? To answer this ques-
tion, we conducted an empirical study with 105 Python projects,
using type inference techniques to manifest possible dependencies.
Our study reveale d that the architectural impact of possible depen-
dencies is substantialâ€”higher than that of explicit dependencies:
(1)file-levelpossibledependenciesaccountforatleast27.93%ofall
file-level dependencies, and create different dependency structures
than that of explicit dependencies only, with an average difference
of 30.71%; (2) adding possible dependencies significantly improves
the precision (0.52% âˆ¼14.18%), recall(31.73% âˆ¼39.12%), and F1 scores
(22.13%âˆ¼32.09%)ofcapturingco-changerelations;(3)onaverage,
afileinvolvedinpossibledependenciesinfluences28%morefiles
and 42% more dependencies within architectural sub-spaces than a
file involved in just explicit dependencies; (4) on average, a file in-
volved in possible dependencies consumes 32% more maintenance
effort. Consequently, maintainability scores reported by existingtools make a system written in these dynamic languages appear
to be better modularized than it actually is. This evidence strongly
âˆ—with the Ministry of Education Key Laboratory of Intelligent Networks and Network
Security (MOEKLINNS), Xiâ€™an Jiaotong University.
â€ with the School of Software Engineering, Xiâ€™an Jiaotong University.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACMmustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ASE â€™20, September 21â€“25, 2020, Virtual Event, Australia
Â© 2020 Association for Computing Machinery.
ACM ISBN 978-1-4503-6768-4/20/09...$15.00
https://doi.org/10.1145/3324884.3416619suggeststhatpossibledependencieshaveamoresignificantimpact
thanexplicitdependenciesonarchitecturequality,thatarchitecture
analysisandtoolsshouldassessandevenemphasizethearchitec-
tural impact of possible dependencies due to dynamic typing.
KEYWORDS
dynamictyping,possibledependency,softwarearchitecture,em-
pirical study
ACM Reference Format:
Wuxia Jin, Yuanfang Cai, Rick Kazman, Gang Zhang, Qinghua Zheng,
and Ting Liu. 2020. Exploring the Architectural Impact of Possible De-
pendencies in Python Software. In 35th IEEE/ACM International Conference
onAutomatedSoftwareEngineering(ASEâ€™20),September21â€“25,2020,Virtual
Event, Australia. ACM, New York, NY, USA, 13 pages. https://doi.org/10.
1145/3324884.3416619
1 INTRODUCTION
Dependencies among source code entities are the foundation for
many software architecture analyses, including architecture recov-
ery[10,47,63],architecturalmetrics[ 32][40],architecturalproblem
oranti-patterndetection[ 33,34,39],changeimpactanalysis[ 29],
defectprediction[ 43,68],etc.Manylanguagefeaturesmaycause
syntactic dependencies to be invisible in source code, such as poly-
morphism,casting, andreflection.This problem ismoreprominent
due to dynamic typing in popular dynamic languages, such asPython, JavaScript, and Ruby. Dynamic typing [
11] tolerates the
lack of type information, making certain syntactic dependenciesinvisible in source code. We define the invisible syntactic depen-dencies caused by dynamic typing as
possible dependencies in
contrast with explicit dependencies.
Type inference techniques have been widely studied in program
languageresearch[ 16,22,35,46]tostaticallyinferthetypesofcode
objectsfordynamiclanguages.Thesetechniquesmakeitfeasibletomakethesepossibledependenciesexplicit.However,aftercheckingmultiplepopularcommercialarchitectureanalysistools,suchasLat-
tix Architect [ 27], Structure101 [ 55], Understand [ 58] and DV8 [ 4],
wefoundthatnoneofthesetoolsconsiderpossibledependencies
when analyzing systems written in dynamic languages. To the best
ofourknowledge,fewofdependency-basedsoftwareanalyticre-
searchhavetakenthesepossibledependenciesintoconsideration.
The question is, to what extent will these missing possible
7582020 35th IEEE/ACM International Conference on Automated Software Engineering (ASE)
Figure 1: Explicit dependencies among files in the Java version and Python version
dependencies impact software architecture and analysis ?I t
is urgently necessary to deeply explore this question to advance
theunderstandingofpossibledependency,thusbetteranalyzing
software architecture in dynamic languages.
Hereweuseasimpleexampletoillustrateourmotivation.We
implemented two versions of a small system applying a visitor
pattern[18]using JavaandPythonrespectively,and thenreverse-
engineered dependencies among the source files using Understand.
We then transformed these dependencies into two matrices as
shown in Figure 1. In these matrices, rows and columns denotesource files listed in the same order. The numbers along the di-agonal indicate self-dependency. Cell
(ğ‘–,ğ‘—)with â€œÃ—" denotes that
thefileinrow ğ‘–syntacticallyandexplicitlydependsonthefilein
columnğ‘—.
InFigure1(a), CarElement isthebaseclassoftheconcreteele-
ment classes listed inrows 2, 3, 4, and 6.Since Java forces explicit
type declaration, the visitor interface, CarElementVisitor, has to
explicitly refer to the four concrete element classes, i.e., the sub-
classes of CarElement, hence the dependencies in row 5. Similarly,
since each concrete element class has to accept a visitor object,they all have to refer to CarElementVisitor, hence the dependen-
ciesincolumn5,formingadependencycycleshownbythebluemarkings. By contrast, in Figure 1(b) all these dependencies and
cyclesareâ€œinvisible": CarElementVisitor.py takesthesameroleas
CarElementVisitor.java,butitdoesnâ€™texplicitlydependonanyof
thecarelements,andviceversa.Overall,basedonthedependencies
extracted by Understand, it appears that the practice of dynamic
typing decouples software entities (only 9 dependencies in Python
version whereas 26 dependencies in Java one), making the Python
implementation appears to be better modularized and easier to
maintain than the Java one.
We suspect that the observation is misleading since the Python
andJavaversionimplementedexactlythesamepatternwithexactly
thesamefunctionality.Theseâ€œinvisible"dependenciesinPython
may still have consequences: If the methods defined in CarEle-
mentVisitor.py change,otherprogramelementsusingthesemeth-
ods may have to change accordingly and vice versa, imposing a
nontrivial architectural impact.
In order to quantitatively assess the severity of this problem,
weconductedanempiricalstudyusing105Pythonprojectswith
diversesizesanddomainscollectedfromGithub.Tosupportthis
study, we extended our previous tool, called ENRE [ 23], to extract
possible dependencies from source code, using existing type in-
ferencetechniques.Weextracted5,048,621(explicitandpossible)dependencies, and mined 614,222 change-related and 123,792 issue-
relatedrevisioncommits.Basedonthisdataset1,weexploredthe
following research questions:
RQ1: what is the proportion of possible dependencies and to
whatextentwilltheyimpactthedependencystructureofasoftware
system?
RQ2: to what extent will the ability of capturing co-change
relations be altered when considering possible dependencies?
RQ3: to what extent will possible dependencies impact the sub-
space structures of a software system?
RQ4: to what extent will possible dependencies impact main-
tainability of a software system?
The results reveal that: (1) file-level possible dependencies ac-
count for at least 27.93% of all syntactic dependencies among files,
and they create different dependency structures than those formed
byexplicitdependenciesonly,withanaveragedifferenceof30.71%;
(2)addingpossibledependenciessignificantlyimprovesthepreci-
sion(0.52% âˆ¼14.18%),recall(31.73% âˆ¼39.12%),andF1(22.13% âˆ¼32.09%)
of capturing co-change relations;(3) on average, a file involvedin
possibledependenciesinfluences28%morefilesand42%morede-
pendencies than a file involved in just explicit dependencies, hence
dramatically changingthe fileand dependencysets within23.11%
and 26.39% of architectural sub-spaces respectively; (4) on aver-
age,afileinvolvedinpossibledependenciesconsumes32%more
maintenance effort.
Our study provides strong evidence that the level of archi-
tectural impact imposed by these possible dependencies isnontrivial, and in fact surprisingly high compared with ex-plicit dependencies
. But the invisible nature of possible depen-
denciesmakes itmoredifficult tounderstandthemand tochange
them.Our results benefit architecture analysis and tools, in-
dicating that they should assess and even emphasize the ar-chitecturalimpactofpossibledependenciesduetodynamictyping.
In summary, this work makes the following contributions:
(1) We have extended the ENRE tool to infer possible dependen-
cies caused by dynamic typing from Python code.
(2) We present an empirical study on the possible dependencies,
revealing that the architectural impact imposed by such dependen-
cies is higher than that of explicit dependencies.
(3) We illustrate the benefits of analyzing possible dependencies
on architecture analysis and practices in dynamic languages.
1All data can be found at: https://github.com/jinwuxia/ASE2020data
759(4) We provide the benchmarks collected from 105 open source
projects for continued research of possible dependencies due to
dynamic typing in Python software.
Intherestofthispaper:Sections2and3presentthekeyconcepts
and describe the possible dependency extraction tool. Sections 4, 5,
and 6 report the study setup, study results, and potential impact of
our empirical study. Sections 7 and 8 discuss the threats to validity
and related work. Section 8 draws conclusions.
2 KEY CONCEPTS
Thekeyconceptsusedinthispaperinclude entity,explicitdepen-
dency, and possible dependency. This section will illustrate them
using the Python example shown in Figure 2.
Figure 2: A snippet of test.py
Entity. A code entity ğ‘’is an object with a given name or identi-
fier. An entity can be a variable, function, class, module, etc.
Dependency . According to the definition of Baldwin and Clark
[7],ğ‘’ğ‘¥depends on ğ‘’ğ‘¦ifchangestoğ‘’ğ‘¦may cause ğ‘’ğ‘¥to change. A
dependencyisdenotedas ğ‘’ğ‘¥â†’ğ‘’ğ‘¦.Adependencycanbea syntactic
dependency extracted from source code, a semantic dependency
extractedfromthetextualinformationofsourcecode,ora historical
dependency recorded in revision history [ 5,8,17,48]. We focus
on syntactic dependencies and identify two types of syntactic
dependencies in dynamic languages like Python:
a. Explicit dependency .Wedefine explicitdependency asthe
syntactic dependency relations that is explicitly manifested insource code. An explicit dependency
ğ‘’ğ‘¥â†’ğ‘’ğ‘¦satisfies one of
thefollowingconditions: 1)Thedependedentity ğ‘’ğ‘¦oritsparent
entity is explicitly imported; 2)The type of ğ‘’ğ‘¦or its parent en-
tityisdeclaredexplicitlyinitsvisiblescope.Forexample,Figure2 shows that
ğ‘š() â†’ğ‘“1()(Line 4),ğ‘“2() â†’ğ¶ğ‘™ğ‘ğ‘ ğ‘ ğ¸(Line 7), and
ğ‘“2() â†’ğ¶ğ‘™ğ‘ğ‘ ğ‘ ğ¸.ğ‘š ()(Line 8) are explicit dependencies.
b.Possibledependency .Wedefine possibledependencyasthe
syntactic dependency relation that is not explicitly manifested due
tothelackoftypeinformationindynamictyping.Thedepended
entitieswithin possibledependencies mayberesolvedintomorethan
one type, and the dependency can only be uniquely determined at
run-time. We denote a possible dependency asğ‘ƒğ‘–=ğ‘’ğ‘¥â†’ğ‘’ğ‘¦, where
ğ‘–is the number of possible types which ğ‘’ğ‘¦can be resolved to. In
particular, ğ‘ƒ1meansthatthisdependencyisdeterministic,thatis,
entityğ‘’ğ‘¦canonlyberesolvedintoonetype. ğ‘ƒğ‘–>1meansthatthe
dependencyisnon-deterministic:for ğ‘’ğ‘¦,thereareğ‘–candidatetypes.In Figure 2, ğ‘“4() â†’ğ‘Ÿ2.ğ‘š()(Line 28) is a ğ‘ƒ1dependency since ğ‘Ÿ2
canonlybe ğ¶ğ‘™ğ‘ğ‘ ğ‘ ğ¸.ğ‘“4() â†’ğ‘Ÿ1.ğ‘š1()(Line26)isa ğ‘ƒ2dependency
becauseğ‘Ÿ1 has two possible types, ğ¶ğ‘™ğ‘ğ‘ ğ‘ ğ´andğ¶ğ‘™ğ‘ğ‘ ğ‘ ğµ.
3 TOOL IMPLEMENTATION
To support ourempirical study on the architectural impactof pos-
sible dependencies, we incorporated the concept of ğ‘ƒğ‘–possible
dependenciesandthetypeinferencetechniqueofXuetal.[ 66]into
an extension of ENRE [ 23], an existing dependency extraction tool.
Our extension of ENRE can extract possible dependencies from
source code in Python.
Figure3showsthepossibledependencyextractionframework
based on ENRE. The input is source code, and the output is pos-
sibledependencies, ğ·ğ‘ğ‘–whereğ‘ƒğ‘–denotesthetypeofpossiblede-
pendency.WewillintroducetheframeworkbyusingthePython
example in Figure 2.
1) Entity Identification . This module, provided by ENRE, re-
solves and outputs code entities, ğ¸={ğ‘’}, and expressions, XP=
{ğ‘¥ğ‘}. An entity is defined using a tuple of attributes, including
id,qualifiedName,shortName,etc.Weuse( ğ‘ğ‘¦ğ‘¡â„ğ‘œğ‘›ğ‘“ğ‘–ğ‘™ğ‘’ ,ğ‘™ğ‘–ğ‘›ğ‘’ğ‘›ğ‘¢ğ‘šğ‘ğ‘’ğ‘Ÿ ,ğ‘’ğ‘¥ğ‘,
ğ‘“ğ‘Ÿğ‘œğ‘šğ‘›ğ‘ğ‘šğ‘’ ,ğ‘¡ğ‘œğ‘›ğ‘ğ‘šğ‘’)torepresenteach expression, ğ‘¥ğ‘,insourcecode
that implies possible dependencies.
For example, in Figure 2, Line 26 in test.pycontains one ex-
pression,ğ‘¥ğ‘1=(ğ‘¡ğ‘’ğ‘ ğ‘¡.ğ‘ğ‘¦,26,ğ‘Ÿ1.ğ‘š1(),ğ‘“4,ğ‘š1). It indicates one unre-
solveddependencyfrom ğ‘“4toğ‘š1,i.e.,ğ‘“4â†’ğ‘š1,andthetypeof
ğ‘Ÿ1 has not been resolved.
2)InferencebyAttributeConstraint . Usingğ¸andXPas the
inputs,thismodulefollowstheattributeconstraintsproposedby
Xuetal.[ 66]toinferallofthepossibledependencies.Thisisbased
on duck typing, i.e., the type of an object is determined by howits attributes are used by others [
15]. This module outputs an in-
termediate data structure, ğ‘‚={(ğ‘ , ğ‘, ğ¶ğ‘)}, to record possible
dependencies, where ğ‘ âˆˆğ¸is an entitythat denotes code scope,ğ‘is
anatomicexpression extractedfrom ğ‘¥ğ‘,andğ¶ğ‘denotesthesetof
candidate types of ğ‘.
Foranexpression, ğ‘¥ğ‘ğ‘–,inascope ğ‘ ,thismodulefirst generates
ahierarchicalstructure, ğ‘‡ğ‘–,bysplittingthe ğ‘’ğ‘¥ğ‘ofğ‘¥ğ‘ğ‘–intoatomic
expressions, and denotes their parent-child relations. For example,
the result of splitting ğ‘¥ğ‘1isğ‘‡1=<ğ‘1,ğ‘2>, whereğ‘1=ğ‘Ÿ1,ğ‘2=
ğ‘Ÿ1.ğ‘š1(), andğ‘1is the parent of ğ‘2, forming a layered structure.
Then this module resolves each ğ‘inğ‘‡ğ‘–. For the above ğ‘‡1, the
candidate types of ğ‘2=ğ‘Ÿ1.ğ‘š1()will be resolved as ğ¶ğ‘Ÿ1.ğ‘š1()=
ğ¶ğ‘‡1(2)={ğ¶ğ‘™ğ‘ğ‘ ğ‘ ğ´.ğ‘š 1(),ğ¶ğ‘™ğ‘ğ‘ ğ‘ ğµ.ğ‘š 1(),ğ¶ğ‘™ğ‘ğ‘ ğ‘ ğ¶.ğ‘š 1()}. Next, the can-
didatetypesofitsparent, ğ‘1=ğ‘Ÿ1,willberesolvedas ğ¶ğ‘Ÿ1=ğ¶ğ‘‡1(1)=
{ğ¶ğ‘™ğ‘ğ‘ ğ‘ ğ´,ğ¶ğ‘™ğ‘ğ‘ ğ‘ ğµ,ğ¶ğ‘™ğ‘ğ‘ ğ‘ ğ¶ }.Afterprocessingotherexpressionsinthe
same way, the following elements will be added to ğ‘‚:
1/circlecopyrt(ğ‘“4(),ğ‘Ÿ1,ğ¶ğ‘‡1(1)), whereğ¶ğ‘‡1(1)={ğ¶ğ‘™ğ‘ğ‘ ğ‘ ğ´,ğ¶ğ‘™ğ‘ğ‘ ğ‘ ğµ,ğ¶ğ‘™ğ‘ğ‘ ğ‘ ğ¶ }
2/circlecopyrt(ğ‘“4(),ğ‘Ÿ1.ğ‘š1(),ğ¶ ğ‘‡1(2)), where
ğ¶ğ‘‡1(2)={ğ¶ğ‘™ğ‘ğ‘ ğ‘ ğ´.ğ‘š 1(),ğ¶ğ‘™ğ‘ğ‘ ğ‘ ğµ.ğ‘š 1(),ğ¶ğ‘™ğ‘ğ‘ ğ‘ ğ¶.ğ‘š 1()}
3/circlecopyrt(ğ‘“4(),ğ‘Ÿ1,ğ¶ğ‘‡2(1)), whereğ¶ğ‘‡2(1)={ğ¶ğ‘™ğ‘ğ‘ ğ‘ ğ´,ğ¶ğ‘™ğ‘ğ‘ ğ‘ ğµ }
4/circlecopyrt(ğ‘“4(),ğ‘Ÿ1.ğ‘š2(),ğ¶ ğ‘‡2(2)), where
ğ¶ğ‘‡2(2)={ğ¶ğ‘™ğ‘ğ‘ ğ‘ ğ´.ğ‘š 2(),ğ¶ğ‘™ğ‘ğ‘ ğ‘ ğµ.ğ‘š 2()}
5/circlecopyrt(ğ‘“4(),ğ‘Ÿ2,ğ¶ğ‘‡3(1)), whereğ¶ğ‘‡3(1)={ğ¶ğ‘™ğ‘ğ‘ ğ‘ ğ¸}
6/circlecopyrt(ğ‘“4(),ğ‘Ÿ2.ğ‘š(),ğ¶ ğ‘‡3(2)), whereğ¶ğ‘‡3(2)={ğ¶ğ‘™ğ‘ğ‘ ğ‘ ğ¸.ğ‘š ()}
Now based on ğ‘‚, we infer the possible dependencies: ğ‘“4() â†’
ğ‘Ÿ1 andğ‘“4() â†’ğ‘Ÿ1.ğ‘š1()areğ‘ƒ3possible dependencies as |ğ¶ğ‘Ÿ1|=
|ğ¶ğ‘Ÿ1.ğ‘š1()|=3;ğ‘“4() â†’ğ‘Ÿ1 andğ‘“4() â†’ğ‘Ÿ1.ğ‘š2()areğ‘ƒ2possible
760Figure 3: The possible dependency extraction framework
Table 1: The investigated Python projects
#Subject Statistic #File #LoC #Commit #IssueCommit #Commiter #IssueCommitter #PyFile #PyLoC #AvgLoCPerPyFile
Min 18 1,635 6 0*20*16 881 29
105 Median 409 110,087 3,458 255 172 38 271 39,457 142
Max 8,699 1,836,608 49,849 12,717 2,841 1,974 3,636 786,680 556
Sum / / 614,222 123,792 / / / / /
*#IssueCommit=#IssueCommiter=0 appears in 5 projects out of 105 projects.
dependencies; ğ‘“4() â†’ğ‘Ÿ2 andğ‘“4() â†’ğ‘Ÿ2.ğ‘š()areğ‘ƒ1possible
dependencies.
3)InferenceRefinement .Thismodulerefinestheintermediate
structureğ‘‚, using the Scoping Rule and thePriority Rule.N e x ti t
extracts a set of possible dependencies, ğ·ğ‘ğ‘–, from the refined ğ‘‚.
Scoping Rule : In the above example, the elements 1/circlecopyrtand3/circlecopyrt
inğ‘‚should be grouped together since they indicate that ğ‘Ÿ1i s
withinthescopeof ğ‘“4(),andtheircandidatetypesshouldbethe
same. Their candidate types are refined to be the intersection of
their original ğ¶ğ‘:ğ¶=ğ¶ğ‘‡1(1)âˆ©ğ¶ğ‘‡2(1)={ğ¶ğ‘™ğ‘ğ‘ ğ‘ ğ´,ğ¶ğ‘™ğ‘ğ‘ ğ‘ ğµ }. Accord-
ingly, the candidates of their children are also updated: ğ¶ğ‘‡1(2)=
{ğ¶ğ‘™ğ‘ğ‘ ğ‘ ğ´.ğ‘š 1(),ğ¶ğ‘™ğ‘ğ‘ ğ‘ ğµ.ğ‘š 1()}andğ¶ğ‘‡2(2)={ğ¶ğ‘™ğ‘ğ‘ ğ‘ ğ´.ğ‘š 2(),ğ¶ğ‘™ğ‘ğ‘ ğ‘ ğµ.ğ‘š 2()}.
Priority Rule : For a candidate type set containing more than one
type, if one type inherits from another, we remove the sub-typefrom the candidate set. This rule follows the Liskov Substitution
Principle[ 36]:ifanentitydependsonparent/abstracttype,thenany
sub-types can besubstituted with each other whereverthe parent
typeis used.Thisrule manifeststheidea thatabstractclasses and
interfaces are design rules of software architecture [64].
Inthisexample,withincandidateset {ğ¶ğ‘™ğ‘ğ‘ ğ‘ ğ´,ğ¶ğ‘™ğ‘ğ‘ ğ‘ ğµ },ğ¶ğ‘™ğ‘ğ‘ ğ‘ ğµ
inherits from ğ¶ğ‘™ğ‘ğ‘ ğ‘ ğ´. As result, ğ¶ğ‘‡1(1)andğ¶ğ‘‡2(1)will be refined as
ğ¶ğ‘‡1(1)=ğ¶ğ‘‡2(1)={ğ¶ğ‘™ğ‘ğ‘ ğ‘ ğ´},andtheirchildrenwillalsobeupdated:
ğ¶ğ‘‡1(2)={ğ¶ğ‘™ğ‘ğ‘ ğ‘ ğ´.ğ‘š 1()}, andğ¶ğ‘‡2(2)={ğ¶ğ‘™ğ‘ğ‘ ğ‘ ğ´.ğ‘š 2()}.
Afterrefining ğ‘‚,wecanderiveasetof ğ‘ƒ1possibledependencies:
ğ·ğ‘1={ğ‘“4() â†’ğ¶ğ‘™ğ‘ğ‘ ğ‘ ğ´,ğ‘“ 4() â†’ğ¶ğ‘™ğ‘ğ‘ ğ‘ ğ´.ğ‘š 1(),ğ‘“4() â†’ğ¶ğ‘™ğ‘ğ‘ ğ‘ ğ´.ğ‘š 2(),
ğ‘“4() â†’ğ¶ğ‘™ğ‘ğ‘ ğ‘ ğ¸,ğ‘“4() â†’ğ¶ğ‘™ğ‘ğ‘ ğ‘ ğ¸.ğ‘š ()}.Wecanseethattheserules
refine some non-deterministic dependencies into ğ‘ƒ1, (i.e. determin-
istic) dependencies.
4 STUDY SETUP
To investigate the four research questions introduced in Section 1,
wesetupacomprehensiveempiricalstudywithmultiplesteps,and
collected data from 105 Python projects.4.1 Subjects
To minimize the possible bias caused by project domain or size,
we queried and chose open-source Python projects sorted by their
number of stars from Github using the Github REST API. We man-
ually excluded projects that are learning tutorials and repeatedprojects. Finally, we collected 105 projects with diverse domains
and sizes as the subjects of our empirical study.
Foreachprojectwecollecteditsrevisionhistoryfromtheversion
control system Git. The revision history covers from the beginning
tothelatestreleaseofaproject.Weonlyconsideredthecommits
inwhichasourcefileismodified;commitsthatonlyaddedfilesareignoredsincewefocusontheco-changeandmaintenanceactivities.
An issue-related commit is a commit labeled with an issue ID.
Table1summarizesthedemographicinformationoftheprojects
thatweanalyzed: #Fileâ€”totalnumberoffiles; #LoCâ€”totallinesof
code;#PyFileand#PyLocâ€”Python filesand Python LoConly; #Av-
gLoCPerPyFile â€”averageLoCperPythonfile,i.e.,#ğ‘ƒğ‘¦ğ¿ğ‘œğ¶
#ğ‘ƒğ‘¦ğ¹ğ‘–ğ‘™ğ‘’;#Commitâ€”
total number of commits in the revision history; #Committer â€”total
number of contributors; #IssueCommit and#IssueCommitter â€”issue-
relatedcommitsandcommittersasrecordedintherevisionhistory.
Min,Median, and Maxcorrespond to the minimum, median, and
maximum values of a columnâ€™s values over all projects.
4.2 Dependency Extraction and Verification
We used the Understand tool to extract explicit dependencies from
sourcecodeforeachproject.Understandcanidentifyexplicitdepen-
dencies such as method calls, variable references, and module/file
importing. This tool has been widely used in both academic re-
search [12, 13, 42] and industry [27, 55].
WethenusedthetoolimplementedinSection3todetectpossible
dependenciesfromsourcecode.Weverifiedthedependenciesby
collecting benchmarks from execution traces. The process is as
follows:
761Table 2: The Benchmarks and verification results
Project |ğ‘‡|ğ‘ƒ1ğ‘ğ‘’ğ‘›ğ‘â„ğ‘šğ‘ğ‘Ÿğ‘˜ğ‘  ğ‘ƒ 1ğ‘ğ‘œğ‘Ÿğ‘Ÿğ‘’ğ‘ğ‘¡ ğ‘ƒ 1ğ‘ğ‘ğ‘ğ‘¢ğ‘Ÿğ‘ğ‘ğ‘¦ ğ‘ƒ ğ‘›ğ‘ğ‘’ğ‘›ğ‘â„ğ‘šğ‘ğ‘Ÿğ‘˜ğ‘  ğ‘ƒ ğ‘›ğ‘ğ‘œğ‘Ÿğ‘Ÿğ‘’ğ‘ğ‘¡ ğ‘ƒ ğ‘›ğ‘ğ‘ğ‘ğ‘¢ğ‘Ÿğ‘ğ‘ğ‘¦
glance 2,554 15 12 0.80 18 12 0.67
docutils 5,911 375 359 0.96 513 360 0.71
pythonvisitor 41 12 12 1.00 12 12 1.00
python-patterns 467 17 17 1.00 21 17 0.81
sum 8,973 419 400 0.95 564 401 0.71
Table 3: Measures of the collected dependencies
Primitive File-level
Statistic Explicit ğ‘ƒ1Explicit
âˆªğ‘ƒ1Explicit ğ‘ƒ1Explicit
âˆªğ‘ƒ1
Min 509 32 631 421 1
Median 18,008 3,950 23,366 485 338 779
Max300,520 41,244323,325 20,213 3,43221,998
Sum4,278,728 769,893 5,048,621 167,017 60,078212,666
1)WeusethetoolimplementedinSection3todetectexpressions
thatimply possibledependencies andtoresolvethese dependen-
cies. The results are denoted as ğ·={ğ‘‘}whereğ‘‘=(ğ‘ğ‘¦ğ‘¡â„ğ‘œğ‘›ğ‘“ğ‘–ğ‘™ğ‘’ ,
ğ‘™ğ‘–ğ‘›ğ‘’ğ‘›ğ‘¢ğ‘šğ‘ğ‘’ğ‘Ÿ ,ğ‘’ğ‘¥ğ‘,ğ‘“ğ‘Ÿğ‘œğ‘šğ‘›ğ‘ğ‘šğ‘’ ,ğ‘¡ğ‘œğ‘›ğ‘ğ‘šğ‘’,ğ‘Ÿğ‘’ğ‘ ğ‘œğ‘™ğ‘£ğ‘’ğ‘‘ğ‘ ğ‘’ğ‘¡ ).Forexamplein
docutils2(v0.12),ğ‘‘=(ğ‘ğ‘’ğ‘ğ‘ .ğ‘ğ‘¦,130,ğ‘ğ‘’ğ‘_ğ‘¡ğ‘¦ğ‘ğ‘’=ğ‘ğ‘ğ‘Ÿğ‘.ğ‘ğ‘ ğ‘¡ğ‘’ğ‘¥ğ‘¡ (),ğ‘ğ‘’ğ‘ğ‘ .ğ‘ğ‘¦,ğ‘ğ‘ ğ‘¡ğ‘’ğ‘¥ğ‘¡,
{ğ‘›ğ‘œğ‘‘ğ‘’ğ‘ }). This means that ğ‘ğ‘’ğ‘_ğ‘¡ğ‘¦ğ‘ğ‘’ =ğ‘ğ‘ğ‘Ÿğ‘.ğ‘ğ‘ ğ‘¡ğ‘’ğ‘¥ğ‘¡ ()is an ex-
pression at line 130 in ğ‘ğ‘’ğ‘ğ‘ .ğ‘ğ‘¦.ğ‘ğ‘’ğ‘ğ‘ .ğ‘ğ‘¦callsğ‘ğ‘ğ‘Ÿğ‘.ğ‘ğ‘ ğ‘¡ğ‘’ğ‘¥ğ‘¡ (), thus
ğ‘“ğ‘Ÿğ‘œğ‘šğ‘›ğ‘ğ‘šğ‘’ isğ‘ğ‘’ğ‘ğ‘ .ğ‘ğ‘¦andğ‘¡ğ‘œğ‘›ğ‘ğ‘šğ‘’isğ‘ğ‘ ğ‘¡ğ‘’ğ‘¥ğ‘¡().ğ‘Ÿğ‘’ğ‘ ğ‘œğ‘™ğ‘£ğ‘’ğ‘‘ğ‘ ğ‘’ğ‘¡ ={ğ‘›ğ‘œğ‘‘ğ‘’ğ‘ }
is the resolved result, meaning that ğ‘ğ‘ğ‘Ÿğ‘is resolved as the type of
ğ‘›ğ‘œğ‘‘ğ‘’ğ‘ . This record ğ‘‘indicates one ğ‘ƒ1dependency is extracted, i.e.,
ğ‘ğ‘’ğ‘ğ‘ .ğ‘ğ‘¦â†’ğ‘›ğ‘œğ‘‘ğ‘’ğ‘ .ğ‘ğ‘ ğ‘¡ğ‘’ğ‘¥ğ‘¡ ()since|ğ‘Ÿğ‘’ğ‘ ğ‘œğ‘™ğ‘£ğ‘’ğ‘‘ğ‘ ğ‘’ğ‘¡ |=1.
2) We collect dependencies from execution traces. We executed
test cases included in various projects and traced executions bya Python module called trace[
50]. The dependencies ğ‘‡={ğ‘¡}are
extracted from executions, where ğ‘¡=(ğ‘ğ‘¦ğ‘¡â„ğ‘œğ‘›ğ‘“ğ‘–ğ‘™ğ‘’ ,ğ‘™ğ‘–ğ‘›ğ‘’ğ‘›ğ‘¢ğ‘šğ‘ğ‘’ğ‘Ÿ ,ğ‘’ğ‘¥ğ‘,
ğ‘“ğ‘Ÿğ‘œğ‘šğ‘›ğ‘ğ‘šğ‘’ ,ğ‘¡ğ‘œğ‘›ğ‘ğ‘šğ‘’,ğ‘Ÿğ‘’ğ‘ ğ‘œğ‘™ğ‘£ğ‘’ğ‘‘ğ‘ ğ‘’ğ‘¡ ), the same representation with ğ‘‘.
3)Wegenerate ğ‘ƒ1andğ‘ƒğ‘›possibledependencybenchmarksby
filteringğ‘‡.Forğ‘¡âˆˆğ‘‡,ifthe(ğ‘“ğ‘–ğ‘™ğ‘’ğ‘›ğ‘ğ‘šğ‘’,ğ‘™ğ‘–ğ‘›ğ‘’ğ‘›ğ‘¢ğ‘šğ‘ğ‘’ğ‘Ÿ,ğ‘’ğ‘¥ğ‘ )isequalto
thatofğ‘‘âˆˆğ·,addğ‘¡intoğ‘ƒğ‘›ğ‘ğ‘’ğ‘›ğ‘â„ğ‘šğ‘ğ‘Ÿğ‘˜ğ‘  .Addğ‘¡intoğ‘ƒ1ğ‘ğ‘’ğ‘›ğ‘â„ğ‘šğ‘ğ‘Ÿğ‘˜ğ‘ 
if the|ğ‘Ÿğ‘’ğ‘ ğ‘œğ‘™ğ‘£ğ‘’ğ‘‘ğ‘ ğ‘’ğ‘¡ |=1, i.e,ğ‘ƒ1ğ‘ğ‘’ğ‘›ğ‘â„ğ‘šğ‘ğ‘Ÿğ‘˜ğ‘  âŠ†ğ‘ƒğ‘›ğ‘ğ‘’ğ‘›ğ‘â„ğ‘šğ‘ğ‘Ÿğ‘˜ğ‘  .W e
used(ğ‘“ğ‘–ğ‘™ğ‘’ğ‘›ğ‘ğ‘šğ‘’,ğ‘™ğ‘–ğ‘›ğ‘’ğ‘›ğ‘¢ğ‘šğ‘ğ‘’ğ‘Ÿ,ğ‘’ğ‘¥ğ‘ )forfilteringinsteadof (ğ‘“ğ‘–ğ‘™ğ‘’ğ‘›ğ‘ğ‘šğ‘’,ğ‘’ğ‘¥ğ‘ )
sincesomeexpressionswiththesamestring,locatedinthesame
Pythonfile,mayexist indifferentcodeblocks, perhaps implying
distinctive dependencies.
4) We evaluate the accuracy of possible dependencies. If the
ğ‘Ÿğ‘’ğ‘ ğ‘œğ‘™ğ‘£ğ‘’ğ‘‘ğ‘ ğ‘’ğ‘¡ ofğ‘‘is completely equal to ğ‘Ÿğ‘’ğ‘ ğ‘œğ‘™ğ‘£ğ‘’ğ‘‘ğ‘ ğ‘’ğ‘¡ ofğ‘¡in bench-
marks, we considered that the possible dependency indicated by ğ‘‘
is verified to be correct. Since the benchmarks were collected byfiltering the execution traces against the expressions that imply
possible dependencies, the value of the recall is equal to that of theprecision.Thusweused
ğ‘ƒ1ğ‘ğ‘ğ‘ğ‘¢ğ‘Ÿğ‘ğ‘ğ‘¦ (orğ‘ƒğ‘›ğ‘ğ‘ğ‘ğ‘¢ğ‘Ÿğ‘ğ‘ğ‘¦)todenotethe
precision or recall against ğ‘ƒ1ğ‘ğ‘’ğ‘›ğ‘â„ğ‘šğ‘ğ‘Ÿğ‘˜ğ‘  (orğ‘ƒğ‘›ğ‘ğ‘’ğ‘›ğ‘â„ğ‘šğ‘ğ‘Ÿğ‘˜ğ‘  ).
2https://github.com/docutils-mirror/docutilsWe selected 4 projects from our subjects for evaluation, and
thecollectedbenchmarkswereplacedinourrepository.Assum-
marized in Table 2, 419 ğ‘ƒ1ğ‘ğ‘’ğ‘›ğ‘â„ğ‘šğ‘ğ‘Ÿğ‘˜ğ‘  and 564ğ‘ƒğ‘›ğ‘ğ‘’ğ‘›ğ‘â„ğ‘šğ‘ğ‘Ÿğ‘˜ğ‘ 
are collected in total. Against 419 ğ‘ƒ1ğ‘ğ‘’ğ‘›ğ‘â„ğ‘šğ‘ğ‘Ÿğ‘˜ğ‘  , 400ğ‘ƒ1depen-
dencies are resolved correctly, i.e., ğ‘ƒ1ğ‘ğ‘ğ‘ğ‘¢ğ‘Ÿğ‘ğ‘ğ‘¦ is 400/419=0.95.
ğ‘ƒğ‘›ğ‘ğ‘ğ‘ğ‘¢ğ‘Ÿğ‘ğ‘ğ‘¦ is 0.71 against ğ‘ƒğ‘›ğ‘ğ‘’ğ‘›ğ‘â„ğ‘šğ‘ğ‘Ÿğ‘˜ğ‘  . The incorrect results
are caused by the possible dependencies between source code and
Python libraries, which our tool is unable to detect. ğ‘ƒğ‘›ğ‘ğ‘ğ‘ğ‘¢ğ‘Ÿğ‘ğ‘ğ‘¦ is
lowerthan ğ‘ƒ1ğ‘ğ‘ğ‘ğ‘¢ğ‘Ÿğ‘ğ‘ğ‘¦ sinceitisdifficultforexecutiontracesto
cover all possible dependencies.
4.3 Statistics of the Collected Dependencies
Figure 4: The distribution of primitive dependencies
Wesummarizedthepossibledependenciesandexplicitdepen-
denciesextractedfromthe105studiedprojects. Theprimitivede-
pendencies extracted among all entities (e.g., methods, classes) can
be aggregated into dependencies among files. Table 3 shows thestatistics of both primitive and file-level dependencies of all sub-
jects.
Figure4presentsthepercentagesofdifferentprimitivedepen-
dency types collected from all projects, labeled with their aver-ages. It shows that, on average, 75.72% of all detected syntactic
dependenciesareexplicitdependencies,and24.28%arepossiblede-
pendencies. Among the possible dependencies, the majority are ğ‘ƒ1
dependencies,takingabout14.28%onaverage.Thismeansthat90%
(75.72%+14.28%)ofsyntacticdependenciescanbeunambiguously
determined using static analysis.
7625 STUDY RESULTS
5.1 RQ1: The Proportion and Impact on
Dependency Structure
Sincemanyarchitecture-levelanalysesusefilepairsasatomicunits
of analysis, we will observe the distribution of file-level possible
dependencies and the dependency structure formed by them.
Figure 5: The distribution of file-level dependencies
Weaggregateprimitivedependenciesintofile-leveldependen-
cies. When aggregating possible dependencies, for ğ‘ƒğ‘–>1dependen-
cies,ifallğ‘–possibilitiesareinter-fileorintra-filedependencies,it
isstraightforward;otherwise,itisimpossibletodetermine.Since
ğ‘ƒğ‘–>1dependencies are rare, we form a conservative baseline using
theunionofexplicitdependenciesand ğ‘ƒ1dependencies,whichcon-
tains the minimal number of deterministic syntactic dependencies
that should be taken into consideration.
To observe the difference between the dependency structures
formedby ğ·ğ‘’andğ·ğ‘’âˆªğ·ğ‘1,weemployedWCA,LIMBO,andACDC
toconstructsoftwaredependencystructurefromfile-leveldepen-
dencies. These techniques are also utilized in the work of Cui et
al. [13] to compare multiple dependency structures. WCA [ 10] and
LIMBO [3] are hierarchical clustering methods. WCA leverages
Unbiased Ellenberg (UE) or Unbiased Ellenberg-NM (UENM) to
measure the distance between entities, while LIMBO uses informa-
tion loss as a measure. ACDC follows subgraph patterns such as
the Subgraph Dominator Pattern [57].
5.1.1 Measures of the Dependency Structure Similarity. Tomeasure
thesimilaritybetweenthedependencystructurescreatedby ğ·ğ‘’and
byğ·ğ‘’âˆªğ·ğ‘1,weadopted MoJoFM[61],whichcomputesdependency
graph similarity by calculating the operations needed to transform
from one structure to another. A higher value of MoJoFMmeans
thetwostructuresaremoresimilar.Conversely,ahighervalueof
1âˆ’MoJoFM indicates a bigger difference.
5.1.2 Results. Figure5(a)depictstheaggregatedfile-level ğ‘ƒ1pos-
sible dependencies, ğ·ğ‘1, and how they overlap with explicit depen-
dencies,ğ·ğ‘’, averaged over all 105 projects. Figure 5(b) depicts the
ranges of their percentages and overlaps, labeled with the mean
values of all percentage scores. It shows that, of all the baseline de-
pendenciescontaining ğ·ğ‘’âˆªğ·ğ‘1,27.93%ofthemonlyhavepossible
dependencies, i.e., ğ·ğ‘1âˆ’ğ·ğ‘’âˆ©ğ·ğ‘1.
We usedocutils, one of the studied projects, as an example to
visualize these dependencies, as shown in Figure 6. The nodes (fileTable4:Thesimilaritybetweendependencystructuresformed
byğ·ğ‘’and byğ·ğ‘’âˆªğ·ğ‘1(Pt:Percentile)
MoJoFM WCA-uem WCA-uenm LIMBO ACDC Mean
25th PT 42.44% 37.26% 50.00% 67.06% /
50th PT 79.26% 77.45% 62.31% 77.16% /75th PT 92.98% 92.94% 80.20% 85.34% /
Mean 67.99% 66.24% 66.20% 76.73% 69.29%
entities)areplacedonthecircumferenceofacircle.Edges(file-level
dependencies)crossthecircle.Thethreesub-figuresrespectively
depictfilepairswithexplicitdependenciesonly,with ğ‘ƒ1possible
dependencies only, and with the overlaps.
Figure 6: File-level dependency visualization for docutils
Table4illustratesthe25thpercentile,50thpercentile(i.e.,me-
dian),75percentileandmeanof MoJoFMvaluesoverallprojects.
Forexample,the second columnshows similarityscores between
thedependencystructuresformedby ğ·ğ‘’andbyğ·ğ‘’âˆªğ·ğ‘1respec-
tively when using WCA-uem. The last column lists the average
value over the four approaches. On average, adding ğ·ğ‘1causes the
formed structures to differ by 30.71% (i.e., 1 âˆ’MoJoFM=1âˆ’69.29%).
5.1.3 Answering RQ1. File-levelğ‘ƒ1possible dependencies ( ğ·ğ‘1)
represent a significant portion (about 27.93% on average) of alluniquelyresolvablefile-leveldependencies(
ğ·ğ‘’âˆªğ·ğ‘1).Moreover,
ğ‘ƒ1possible dependencies make the created dependency structures
different from those created by explicit dependencies only, with an
average difference of 30.71%. For the following study, we use ğ·ğ‘’âˆª
ğ·ğ‘1asabaselinesincetheycanbeuniquelyresolvedusingstatic
analysis.Ourresultswillonlybestrengthenedif ğ‘ƒğ‘–>1dependencies
could be further resolved in the future.
5.2 RQ2: Capturing Co-change Files
Much prior research has leveraged revision history, especially how
files are committed together, as a benchmark for understanding
co-changerelations[ 56],changeimpactanalysis[ 54,67],andlocal-
izing problematic modules [ 40,65]. The assumption is that related
filesaremorelikelytobechangedtogether.Thequestionis: towhat
extentwilltheabilityofcapturingco-changerelationsbealteredwhen
considering possible dependencies?
5.2.1 Benchmarks and Subjects. Toconductarigorousstudy,we
derived20co-changebenchmarks, ğµğ‘’ğ‘›ğ‘â„ğ‘šğ‘ğ‘Ÿğ‘˜ ğ‘–,ğ‘–=1,2,...,20,from
the revision history of each project, each containing a set of file
pairs that have changed together at least ğ‘–times. That is, the larger
763Table 5: The improvement of the Precision, Recall, and F1 scores When adding ğ‘ƒ1dependencies
Benchmark 1234567891 0 1 1 1 2
Î”ğ‘ƒ(ğ·ğ‘’âˆªğ·ğ‘1)-1.71% -1.25% -0.60% -0.02% -0.05% 0.52% 1.62% 3.88% 5.10% 5.95% 6.02% 7.22%
Î”ğ‘…(ğ·ğ‘’âˆªğ·ğ‘1)34.25% 31.74% 31.73% 32.29% 32.57% 32.58% 32.52% 32.99% 33.75% 35.00% 36.25% 38.27%
Î”ğ¹1(ğ·ğ‘’âˆªğ·ğ‘1)32.09% 28.61% 27.77% 27.06% 26.38% 25.93% 24.94% 25.12% 24.71% 25.03% 24.21% 24.79%
Benchmark 13 14 15 16 17 18 19 20 range
Î”ğ‘ƒ(ğ·ğ‘’âˆªğ·ğ‘1)6.69% 6.53% 7.49% 8.33% 9.79% 11.00% 12.74% 14.18% -1.74%âˆ¼14.18%
Î”ğ‘…(ğ·ğ‘’âˆªğ·ğ‘1)37.46% 38.36% 38.76% 39.12% 38.27% 37.87% 38.05% 38.61% 31.73%âˆ¼39.12%
Î”ğ¹1(ğ·ğ‘’âˆªğ·ğ‘1)23.55% 22.18% 22.13% 22.41% 22.29% 22.66% 23.01% 23.73% 22.13%âˆ¼32.09%
Figure 7: The precision, recall, and ğ¹1measurements
theğ‘–, the more times two files were committed together, and hence
the stronger their relation. From ğµğ‘’ğ‘›ğ‘â„ğ‘šğ‘ğ‘Ÿğ‘˜ 1toğµğ‘’ğ‘›ğ‘â„ğ‘šğ‘ğ‘Ÿğ‘˜ 20, the
co-change relations become less random and more meaningful. We
used 84 of the 105 projects as subjects because we can obtain all
benchmark data from their revision histories. The 21 projects were
excluded since several benchmarks are unavailable due to larger ğ‘–.
5.2.2 Precision, Recall and ğ¹1Measures. Wemeasuretheabilityofa
setofdependencies, ğ·,toreflectco-changerelationsusing Precision
(ğ‘ƒ(ğ·))â€”the percentage of file pairs in the dependency set that are
also in the co-change benchmark, Recall(ğ‘…(ğ·))â€”the percentage
offilepairswithinthe co-changebenchmarkthatarecapturedby
the dependency set, and ğ¹1score (ğ¹1(ğ·))â€”the harmonic average
of the precision and recall. The larger the ğ‘ƒ(ğ·),ğ‘…(ğ·)andğ¹1(ğ·)
values,thestrongerthepotentialof ğ·toreflectco-changerelations.
We thus computed the precision, recall, and ğ¹1scores ofğ·ğ‘’and
ğ·ğ‘’âˆªğ·ğ‘1, for each project against each of the 20 benchmarks.
5.2.3 Results. Figure7(a)presentstheprecisionscoresforthein-
vestigatedprojectsusingthedifferentbenchmarks.Itshowsthat
ğ‘ƒ(ğ·ğ‘’âˆªğ·ğ‘1)>ğ‘ƒ(ğ·ğ‘’)except for the first five points in the curves.
This observation indicates that the stronger the co-change rela-
tions,themorelikelytheywillbecapturedwithadditionalpossible
dependencies. We used Î”ğ‘ƒ(ğ·ğ‘’âˆªğ·ğ‘1)=ğ‘ƒ(ğ·ğ‘’âˆªğ·ğ‘1)âˆ’ğ‘ƒ(ğ·ğ‘’)
ğ‘ƒ(ğ·ğ‘’)to com-
pute the improvement of ğ·ğ‘’âˆªğ·ğ‘1when compared with ğ·ğ‘’for
eachbenchmark.AsillustratedinTable5,exceptforthefirstfive
points in the curves, the improvement ranges from 0.52%âˆ¼14.18%.
Figure 7(b) presents recall scores, showing that adding possi-
ble dependencies always improves recall: ğ‘…(ğ·ğ‘’âˆªğ·ğ‘1)>ğ‘…(ğ·ğ‘’).
Similarly, weused Î”ğ‘…(ğ·ğ‘’âˆªğ·ğ‘1)to compute theimprovementof
ğ·ğ‘’âˆªğ·ğ‘1when compared with ğ·ğ‘’for each benchmark. As shown
inTable5,thevaluesof Î”ğ‘…(ğ·ğ‘’âˆªğ·ğ‘1)are31.73% âˆ¼39.12%.Similarly,Figure 7(c) illustrates the ğ¹1scores:ğ¹1(ğ·ğ‘’âˆªğ·ğ‘1)>ğ¹1(ğ·ğ‘’). The
values of Î”ğ¹1(ğ·ğ‘’âˆªğ·ğ‘1)range from 22.13% to 32.09%.
5.2.4 Answering RQ2. When adding ğ‘ƒ1dependencies to explicit
dependencies, the precision, recall and ğ¹1scores of capturing co-
changerelationsaresignificantlyimproved.Fortheprecision,both
the denominator and numerator in this formula are increased
when adding ğ‘ƒ1dependencies, while the value is enhanced by
0.52%âˆ¼14.18% (except for the first 5 values). The recall improve-
mentsrangefrom31.73% âˆ¼39.12%.Forthe ğ¹1scores,theimprove-
ments range from 22.13% âˆ¼32.09%. These results indicate that a
significant portion of co-changes reflects possible dependencies
among files.
5.3 RQ3: The Impact on Sub-space Structure
Wenowexplorehowpossibledependenciesmayimpactarchitec-
tural sub-space structure by compared with explicit dependencies:
howdotheyinfluencescopesoffilesanddependenciesusingthe
Design Rule Spaces (DRSpace) approach [ 7,63,64]. DRSpace mod-
elssoftwarearchitecturesasasetofoverlappingdesignspaces,i.e.,
sub-spaces,eachcontainingmodulesanddesignrules.Wecompare
thesub-spaceinfluencedbyafile( ğ‘“ğ‘–ğ‘™ğ‘’ğ‘1)involvedin ğ‘ƒ1possible
dependencieswiththatinfluencedbyafile( ğ‘“ğ‘–ğ‘™ğ‘’ğ‘’)involvedinex-
plicitdependencies.Ifthesizeofthesub-spaceinfluencedby ğ‘“ğ‘–ğ‘™ğ‘’ğ‘1
islargerthanthatof ğ‘“ğ‘–ğ‘™ğ‘’ğ‘’,thestructuralscopeinfluencedby ğ‘“ğ‘–ğ‘™ğ‘’ğ‘1
is greater than that of ğ‘“ğ‘–ğ‘™ğ‘’ğ‘’.
5.3.1 Measures of the Sub-space Similarity. To measure the sim-
ilarity between sub-spaces modeled from ğ·ğ‘’and fromğ·ğ‘’âˆªğ·ğ‘1,
weusedC2C[28][19].Usingeachfileinaprojectasaleadingfile
and splitting a sub-space containing files that directly or indirectly
depend on it [ 64], a pair of sub-spaces can be obtained using ğ·ğ‘’
764andğ·ğ‘’âˆªğ·ğ‘1respectively. Derived from ğ¶2ğ¶,ğ¶2ğ¶ğ‘‘measures the
similarity between the two dependency sets within the sub-spaces,
andğ¶2ğ¶ğ‘“measures how their file sets differ. Higher values of the
metrics indicate more similarity between sub-space structures, i.e.,
ahighervalueof1 âˆ’ğ¶2ğ¶ğ‘“or1âˆ’ğ¶2ğ¶ğ‘‘indicatesabiggerdifference.
5.3.2 Measures of the Sub-space Scope Influenced by a File. To
measure the structural scope influenced by a file, we used this file
as a leading file to split its sub-space based on ğ·ğ‘’âˆªğ·ğ‘1. More files
and dependencies in a sub-space led by this file indicate that the
structural scope influenced by it is bigger. For each project, we
computed ğ¾ğ‘“ğ‘–ğ‘™ğ‘’andğ¾ğ‘‘ğ‘’ğ‘:
ğ¾ğ‘“ğ‘–ğ‘™ğ‘’=#ğ‘“ğ‘–ğ‘™ğ‘’ğ‘–ğ‘›ğ‘ ğ‘¢ğ‘ âˆ’ğ‘ ğ‘ğ‘ğ‘ğ‘’ ğ‘™ğ‘’ğ‘‘ ğ‘ğ‘¦ ğ‘ ğ‘“ğ‘–ğ‘™ğ‘’ ğ‘1(ğ‘ğ‘£ğ‘”.)
#ğ‘“ğ‘–ğ‘™ğ‘’ğ‘–ğ‘›ğ‘ ğ‘¢ğ‘ âˆ’ğ‘ ğ‘ğ‘ğ‘ğ‘’ ğ‘™ğ‘’ğ‘‘ ğ‘ğ‘¦ ğ‘ ğ‘“ğ‘–ğ‘™ğ‘’ ğ‘’(ğ‘ğ‘£ğ‘”.)
ğ¾ğ‘‘ğ‘’ğ‘=#ğ‘‘ğ‘’ğ‘ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘›ğ‘ğ‘¦ ğ‘–ğ‘› ğ‘ ğ‘¢ğ‘ âˆ’ğ‘ ğ‘ğ‘ğ‘ğ‘’ ğ‘™ğ‘’ğ‘‘ ğ‘ğ‘¦ ğ‘ ğ‘“ğ‘–ğ‘™ğ‘’ ğ‘1(ğ‘ğ‘£ğ‘”.)
#ğ‘‘ğ‘’ğ‘ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘›ğ‘ğ‘¦ ğ‘–ğ‘› ğ‘ ğ‘¢ğ‘ âˆ’ğ‘ ğ‘ğ‘ğ‘ğ‘’ ğ‘™ğ‘’ğ‘‘ ğ‘ğ‘¦ ğ‘ ğ‘“ğ‘–ğ‘™ğ‘’ ğ‘’(ğ‘ğ‘£ğ‘”.)
Thenumeratorinthefractionof ğ¾ğ‘“ğ‘–ğ‘™ğ‘’formuladenotestheaverage
number of files contained in the sub-space led by a ğ‘“ğ‘–ğ‘™ğ‘’ğ‘1, whereas
the denominator denotes the average number of files contained in
the sub-space led by a ğ‘“ğ‘–ğ‘™ğ‘’ğ‘’in a project. Similarly, ğ¾ğ‘‘ğ‘’ğ‘considers
thenumberofdependenciesinsteadofthenumberoffiles.Avaluelargerthan1.0of
ğ¾ğ‘“ğ‘–ğ‘™ğ‘’andğ¾ğ‘‘ğ‘’ğ‘indicatesthat ğ‘“ğ‘–ğ‘™ğ‘’ğ‘1willinfluence
a larger structural scope in software architecture than ğ‘“ğ‘–ğ‘™ğ‘’ğ‘’.
Figure 8: The distribution of ğ¶2ğ¶values of sub-space pairs
5.3.3 Results. Figure 8 presents similarity distribution between all
53,727pairsofsub-spacesmeasuredby ğ¶2ğ¶ğ‘“andğ¶2ğ¶ğ‘‘respectively.
Within each pair, one sub-space is modeled from ğ·ğ‘’and the other
is fromğ·ğ‘’âˆªğ·ğ‘1. For example, the first bar in Figure 8(a) means
that 3.44% of sub-space pairs have 0%-10% similarity, measured by
ğ¶2ğ¶ğ‘“. The upper curve shows the cumulative percentage, e.g., the
dot on the curve within the red box indicates that 23.11% pairshave less than 60% similarity; they are drastically different fromeach other. The last bar in Figure 8(a) shows that 1
âˆ’43.67%=
56.33%ofsub-spacepairsareverysimilar,notseverelyimpacted
by adding ğ‘ƒ1possible dependencies. Similarly, in Figure 8(b), ğ‘ƒ1
possibledependenciessignificantlychanged26.39%ofsub-spacepairs, measured by
ğ¶2ğ¶ğ‘‘. Theğ¶2ğ¶ğ‘“andğ¶2ğ¶ğ‘‘scores show that
the files in 23 .11% of sub-spaces and the dependencies in 26 .39%
ofsub-spacesaresignificantly(about40%)changedbyadding ğ‘ƒ1
possible dependencies.Furthermore, Figure 9 illustrates ğ¾ğ‘“ğ‘–ğ‘™ğ‘’value andğ¾ğ‘‘ğ‘’ğ‘value for
eachstudiedproject.AsshowninFigure9(a),for (105âˆ’10)/105=
90.48% of the projects (i.e, 10 points are below ğ¾ğ‘“ğ‘–ğ‘™ğ‘’=1 line),
theğ¾ğ‘“ğ‘–ğ‘™ğ‘’scores are larger than 1. On average, ğ¾ğ‘“ğ‘–ğ‘™ğ‘’=1.28 and
ğ¾ğ‘‘ğ‘’ğ‘=1.42forallprojects.Thatis,onaverage,afileinvolvedin
possible dependencies influence 28% more files and involve 42%
more dependencies than that with explicit dependencies.
Figure 9: The distribution of ğ¾ğ‘“ğ‘–ğ‘™ğ‘’andğ¾ğ‘‘ğ‘’ğ‘for all projects
5.3.4 Answering RQ3. Thedatarevealedthatthefileand depen-
dencysetswithin23.11%and26.39%ofallsub-spacesaredrastically
changed after considering possible dependencies. A more interest-
ingresultisthatpossibledependenciesimposehigherimpacton
architectural structure when compared with explicit dependencies:
on average,a fileinvolved in ğ‘ƒ1possible dependencieshas thepo-
tentialtoinfluence28%morefilesand42%moredependenciesthan
a file involved in explicit dependencies.
5.4 RQ4: The Impact on Maintainability
Here we explore the impact of possible dependencies on mainte-
nanceeffortbycomparingthemaintenanceeffortof ğ‘“ğ‘–ğ‘™ğ‘’ğ‘1vs.ğ‘“ğ‘–ğ‘™ğ‘’ğ‘’
measured based on a projectâ€™s revision history. If the maintenance
effortofğ‘“ğ‘–ğ‘™ğ‘’ğ‘1(orğ‘“ğ‘–ğ‘™ğ‘’ğ‘’)isgreater,itmeansthatafilewithpossible
dependenciesincurhighermaintenancecostthanthatofexplicit
dependencies.
5.4.1 Measures of a Fileâ€™s Maintenance Cost. Byminingtherevi-
sion history of each project, we used ğ¾ğ‘ğ‘šğ‘¡,ğ¾ğ‘™ğ‘œğ‘,ğ¾ğ‘ğ‘¢ğ‘¡â„ğ‘œğ‘Ÿ,ğ¾ğ‘–ğ‘ ğ‘ ğ‘¢ğ‘’,
ğ¾ğ‘–ğ‘ ğ‘ ğ‘¢ğ‘’ğ¶ğ‘šğ‘¡, andğ¾ğ‘–ğ‘ ğ‘ ğ‘¢ğ‘’ğ¿ğ‘œğ‘to comprehensively assess the relative
maintenancecostofa ğ‘“ğ‘–ğ‘™ğ‘’ğ‘1ascomparedwiththatofa ğ‘“ğ‘–ğ‘™ğ‘’ğ‘’,from
6dimensions,similartotheworkofMoetal.[ 40].Thesixmeasures
are defined as follows:
ğ¾ğ‘ğ‘šğ‘¡=#ğ‘ğ‘œğ‘šğ‘šğ‘–ğ‘¡ ğ‘œğ‘“ ğ‘ ğ‘“ğ‘–ğ‘™ğ‘’ ğ‘1(ğ‘ğ‘£ğ‘”.)
#ğ‘ğ‘œğ‘šğ‘šğ‘–ğ‘¡ ğ‘œğ‘“ ğ‘ ğ‘“ğ‘–ğ‘™ğ‘’ ğ‘’(ğ‘ğ‘£ğ‘”.)
ğ¾ğ‘™ğ‘œğ‘=#ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ğ¿ğ‘œğ‘ ğ‘œğ‘“ ğ‘ ğ‘“ğ‘–ğ‘™ğ‘’ ğ‘1(ğ‘ğ‘£ğ‘”.)
#ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ğ¿ğ‘œğ‘ ğ‘œğ‘“ ğ‘ ğ‘“ğ‘–ğ‘™ğ‘’ ğ‘’(ğ‘ğ‘£ğ‘”.)
ğ¾ğ‘ğ‘¢ğ‘¡â„ğ‘œğ‘Ÿ =#ğ‘ğ‘¢ğ‘¡â„ğ‘œğ‘Ÿ ğ‘œğ‘“ ğ‘ ğ‘“ğ‘–ğ‘™ğ‘’ ğ‘1(ğ‘ğ‘£ğ‘”.)
#ğ‘ğ‘¢ğ‘¡â„ğ‘œğ‘Ÿ ğ‘œğ‘“ ğ‘ ğ‘“ğ‘–ğ‘™ğ‘’ ğ‘’(ğ‘ğ‘£ğ‘”.)
ğ¾ğ‘–ğ‘ ğ‘ ğ‘¢ğ‘’=#ğ‘–ğ‘ ğ‘ ğ‘¢ğ‘’ ğ‘œğ‘“ ğ‘ ğ‘“ğ‘–ğ‘™ğ‘’ ğ‘1(ğ‘ğ‘£ğ‘”.)
#ğ‘–ğ‘ ğ‘ ğ‘¢ğ‘’ ğ‘œğ‘“ ğ‘ ğ‘“ğ‘–ğ‘™ğ‘’ ğ‘’(ğ‘ğ‘£ğ‘”.)
ğ¾ğ‘–ğ‘ ğ‘ ğ‘¢ğ‘’ğ¶ğ‘šğ‘¡ =#ğ‘–ğ‘ ğ‘ ğ‘¢ğ‘’ğ¶ğ‘šğ‘¡ ğ‘œğ‘“ ğ‘ ğ‘“ğ‘–ğ‘™ğ‘’ ğ‘1(ğ‘ğ‘£ğ‘”.)
#ğ‘–ğ‘ ğ‘ ğ‘¢ğ‘’ğ¶ğ‘šğ‘¡ ğ‘œğ‘“ ğ‘ ğ‘“ğ‘–ğ‘™ğ‘’ ğ‘’(ğ‘ğ‘£ğ‘”.)
ğ¾ğ‘–ğ‘ ğ‘ ğ‘¢ğ‘’ğ¿ğ‘œğ‘ =#ğ‘–ğ‘ ğ‘ ğ‘¢ğ‘’ğ¿ğ‘œğ‘ ğ‘œğ‘“ ğ‘ ğ‘“ğ‘–ğ‘™ğ‘’ ğ‘1(ğ‘ğ‘£ğ‘”.)
#ğ‘–ğ‘ ğ‘ ğ‘¢ğ‘’ğ¿ğ‘œğ‘ ğ‘œğ‘“ ğ‘ ğ‘“ğ‘–ğ‘™ğ‘’ ğ‘’(ğ‘ğ‘£ğ‘”.)
765where,#commitâ€”the number of commits made to change a file;
#changeLoc â€”the total lines of changed code when modifying a
file;#authorâ€”the number of developers for maintaining a file; #is-
sueâ€”the number of issues that a file gets involved; #issueCmt â€”the
numberofcommitsofafileforfixingissues; #issueLoc â€”thetotal
lines of code changed to a file for fixing issues. The bigger these
measures, the more maintenance cost spent on a file.
Foraproject,ifoneofthe6scoresisbiggerthan1,itmeansthat
files involved in possible dependencies incur more maintenance ef-
fort,measuredinagivendimension,thanthoseinvolvedinexplicit
dependencies.
5.4.2 Results. Figure10showsthevaluesof ğ¾ğ‘ğ‘šğ‘¡,ğ¾ğ‘™ğ‘œğ‘,ğ¾ğ‘ğ‘¢ğ‘¡â„ğ‘œğ‘Ÿ,
ğ¾ğ‘–ğ‘ ğ‘ ğ‘¢ğ‘’,ğ¾ğ‘–ğ‘ ğ‘ ğ‘¢ğ‘’ğ¶ğ‘šğ‘¡,andğ¾ğ‘–ğ‘ ğ‘ ğ‘¢ğ‘’ğ¿ğ‘œğ‘foreachproject.Eachpointinthe
figure denotes the measurement on one project. Consider Figure
10(a) as an example, for all but 9 projects (i.e, 9 points are below
ğ¾ğ‘ğ‘šğ‘¡=1line),the ğ¾ğ‘ğ‘šğ‘¡scoresarelargerthan1.Similarresultscan
beobservedinothersub-figures.Onaverage,forallprojects, ğ¾ğ‘ğ‘šğ‘¡=
1.32,ğ¾ğ‘™ğ‘œğ‘=1.40,ğ¾ğ‘ğ‘¢ğ‘¡â„ğ‘œğ‘Ÿ =1.18,ğ¾ğ‘–ğ‘ ğ‘ ğ‘¢ğ‘’ =1.30,ğ¾ğ‘–ğ‘ ğ‘ ğ‘¢ğ‘’ğ¶ğ‘šğ‘¡ =1.39,
ğ¾ğ‘–ğ‘ ğ‘ ğ‘¢ğ‘’ğ¿ğ‘œğ‘ =1.31. The results show that, on average, the mainte-
nancecostspentona ğ‘“ğ‘–ğ‘™ğ‘’ğ‘ƒ1is(1.32âˆ’1)+(1.40âˆ’1)+(1.18âˆ’1)+(1.30âˆ’1)+(1.39âˆ’1)+(1.31âˆ’1)
6=
32% larger than that spent on a ğ‘“ğ‘–ğ‘™ğ‘’ğ‘’.
5.4.3 Answering RQ4. The results suggest that a file involved in
possibledependenciesincursabout32%moremaintenancecosts
thanthatofexplicitdependenciesonaverage.Theimplicationis
that possible dependencies are more difficult to manifest in source
code and thus more difficult to understand and to change.
5.5 The Impact on Maintainability Scores
Wehypothesize thatwithout ğ‘ƒ1dependencies,architectural main-
tainability scores may appear to be better than they actually are.
We tested this hypothesis as follows.
Using Decoupling Level (DL) and Propagation Cost (PC) met-
rics [32,40] as two state-of-the-art architectural maintainability
metrics,weobservehowthescoreschangewithandwithoutconsid-
ering possible dependencies. DL assesses how well files are decou-
pled into independent modules [ 40]. Its counterpart, PC, measures
howtightlycoupledasystemisbycalculatinghowchangesmay
propagate through direct and indirect dependencies among files
[32].ThehighertheDL,orthelowerthePC,thebetterthearchi-
tectural maintainability [40].
For the 105 projects, we computed their DL and PC scores using
ğ·ğ‘’andğ·ğ‘’âˆªğ·ğ‘1respectively. Table 6 lists the measures for all
projects.Weobservethat,afterconsidering ğ·ğ‘1,themeanDLscore
decreased from 73.77% to 65.66%, and the mean PC increased from
15.52% to 27.23%. The question is, which one can better reflect the
actual maintainability level of a project? Following the work of
Moetal.[ 40],weassesswhichsetofDLandPCscoresarebetter
correlated with maintenance effort, as reflected by six measures
mined from each projectâ€™s revision history.
Using history as ground-truth, we used the six measurements in
priorwork[ 40]:1)Change/BugCommitOverlapRatio (i.e.,CCOR
and BCOR)â€”the extent to which a file is modified by different bug-
fixingorchangecommits,2) Change/BugCommitFilesetOverlap
Ratio(CCFORandBCFOR)â€”theextenttowhichafileiscommitted
by different committers, and 3) Change/Bug Pairwise Committer
Overlap(CPCO and BPCO)â€”the likelihood that two committers
Figure 10: The distribution of ğ¾ğ‘ğ‘šğ‘¡,ğ¾ğ‘™ğ‘œğ‘,ğ¾ğ‘ğ‘¢ğ‘¡â„ğ‘œğ‘Ÿ,ğ¾ğ‘–ğ‘ ğ‘ ğ‘¢ğ‘’,
ğ¾ğ‘–ğ‘ ğ‘ ğ‘¢ğ‘’ğ¿ğ‘œğ‘, andğ¾ğ‘–ğ‘ ğ‘ ğ‘¢ğ‘’ğ¿ğ‘œğ‘for all projects
needtocommunicatebasedonwhethertheycommittedchanges
to the same set of files.
Forthesemeasuresofaprojecttobereliable,itrequiresthatthe
coderepositoryiswellmanagedâ€”withbugissuesandchangeissues
properly taggedâ€”and having sufficient history. Based on these cri-
teria we selected 40 out of the 105 projects for correlation analysis
betweendependency-basedDLandPCscoresandthehistory-based
maintainability ground-truth. We use the Pearson Correlation Co-
efficient to compute the correlation. The stronger the correlations,
the better these scores can reflect a projectâ€™s maintainability.
5.5.1 Results. Table 7 displays the correlation results with all the
p-valueslessthan0.001,suggestingthatthecorrelatedrelationship
is statistically significant. For example, the correlation between the
DL calculated using ğ·ğ‘’and the CCOR measure is âˆ’0.620, and this
correlation increased to âˆ’0.709 when ğ·ğ‘1is taken into consider-
ation. The Î”column represents the improvement of correlation
whencomparingthescorescalculatedusing ğ·ğ‘’âˆªğ·ğ‘1vs.usingğ·ğ‘’
only.Itisclearthat,aftersupplementing ğ·ğ‘’withğ·ğ‘1,theDLorPC
766Table 6: The DL/PC value based on ğ·ğ‘’andğ·ğ‘’âˆªğ·ğ‘1
StatisticDL PC
ğ·ğ‘’ğ·ğ‘’âˆªğ·ğ‘1ğ·ğ‘’ğ·ğ‘’âˆªğ·ğ‘1
Min 37.89% 17.87% 0.58% 2.52%
25th PT 66.59% 54.93% 6.39% 12.62%
50th PT 78.18% 68.21% 11.85% 23.47%
75th PT 86.81% 81.61% 17.80% 35.90%
Max 97.02% 94.95% 33.88% 69.78%
Mean 73.77% 65.66% 15.52% 27.23%
Table 7: Correlations between DL/PC and Ground-truth
PearsonDL PC
ğ·ğ‘’ğ·ğ‘’âˆªğ·ğ‘1Î”(%)ğ·ğ‘’ğ·ğ‘’âˆªğ·ğ‘1Î”(%)
CCOR -0.620 -0.709 14.380.6470.752 16.28
BCOR -0.577 -0.688 19.330.5750.630 9.52
CCFOR -0.623 -0.696 11.860.4680.599 27.85
BCFOR -0.559 -0.723 29.410.5340.647 21.13
CPCO -0.665 -0.742 11.550.6460.700 8.37
BPCO -0.616 -0.752 21.950.5670.764 34.67
Mean // 18.08// 19.64
scoreshavestrongercorrelationwiththemaintainabilitymeasures:
improving by 18.08% for DL and 19.64% for PC on average.
5.5.2 Summary. Theresultsshowthat,without ğ‘ƒ1dependencies,
architecturalmaintainabilityscoresappeartobebetterthanthey
actually are. After ğ‘ƒ1dependencies are included, the scores can
more accurately reflect the real maintainability of the system. The
accuracy is improved by 18.08% or 19.64%.
6 POTENTIAL IMPACT
Our study reveals the substantial impact ofpossibledependencies,
indicating that architecture analysis and tools should assess and
even emphasize the architectural impact of such dependencies.
1) Architecture Analysis . Our results suggest that architec-
tureanalysistechniques,likearchitecturalmetrics(e.g.cohesion
[9], coupling [ 24], and maintainability [ 40]), should account for
possible dependencies; otherwise, these measures may be distorted
for dynamic languages. As shown in Section 5.5, after consider-
ing possible dependencies, architectural maintainability scores are
decreased, more accurately reflecting the reality.
Priorworkreportedthatunnamedcouplingisanundetectable
symptom of modularity violation [ 62], one type of architectural
anti-patterns [ 41], referring to files that are frequently co-changed
to accommodate modification, but belong to separate modules that
are supposed to evolve independently [ 39,62]. Our study (RQ2)
indicated that possible dependencies explain a large portion of
co-change relations, and thus can detect a portion of â€œunnamed"
coupling. We envision that the awareness of possible dependency
related changes could help better understand and manage architec-
tural change or erosion [28, 45] during software evolution.
2)ToolImprovement. Eventhoughtypeinferencetechniques
have been widely studied [ 16,22,35,46], we have checked thatpopular commercial architecture analysis tools, such as Lattix [ 27],
Structure101[ 55],DV8[4],andUnderstand[ 58],havenotconsid-
ered dynamic typing. We reported study results to the architects of
DV8andDepends[ 38].Theyverifiedourfindingsanddecidedto
include possible dependencies for tool enhancement.
3) Change Prediction. Our results indicate that the possible
dependency is an important factor to cause co-change among files.
We envision that supplementing possible dependencies will im-
provetheperformanceof prediction-relatedresearchfordynamic
languages,suchasthepredictionoffuturecodechanges[ 25,29]
and defect localization [14, 60, 68].
4) Other Suggestions. These results suggest that developers
should be aware of code objects with possible dependencies when
changingcode,andtheycanhighlightsuchobjectsbytypehints
introduced in Python PEP484 [51].
7 THREATS TO VALIDITY
First,weusedUnderstandtoidentifyexplicitdependenciessince
itiswidelyusedinindustry[ 27,42,55].Weprovidedaprototype
tool based on ENRE [ 23] to detect possible dependencies by em-
ploying type inference techniques, which are also utilized in the
empirical study by Chen et al. [ 11]. It is difficult to manually verify
the possible dependencies for large-scale projects. To mitigate this
threat,wecollected ğ‘ƒ1andğ‘ƒğ‘›benchmarksfromexecutiontraces
offourprojectsofthestudiedsubjectstoevaluateourtoolofpossi-
ble dependencyextraction. Weused ğ‘ƒ1possible dependenciesand
explicit dependencies to form a conservative baseline for the study.
Second, we explored the architectural impact of possible depen-
dencies by compared with explicit dependencies. One threat is that
differenttechniquesmayproducedifferentobservations.Tomiti-
gate this threat, we used the state-of-the-art architecture analysis
techniques and diverse metrics with comprehensive ground-truth
inthisstudy.Inthefuture,wewillemployotheranalysistechniques
for further validation.
Third,weusedco-changehistoryasbenchmarkstoexploreRQ2.
Prior work often used arbitrary thresholds to determine co-change
relations[ 13].Itisunclearifthresholdsettingsaregeneralizable.To
mitigate this threat, our study used 20 co-change benchmarks (i.e.,
20 different threshold settings), ğµğ‘’ğ‘›ğ‘â„ğ‘šğ‘ğ‘Ÿğ‘˜ ğ‘–,ğ‘–=1,2,...,20, each
containing file pairs that have changed together at least ğ‘–times.
8 RELATED WORK
Type Inference. Dynamic languages such as Python, JavaScript, and
Ruby,supportdynamictypingcodeobjects.Nanzetal.[ 44]andRay
et al. [52] revealed that dynamic languages are more prone to run-
time defects due to the lack of static type checking. Kleinschmager
et al. [26] presented evidence that static typing can help fix type
errors. To mitigate type-related errors, much research has explored
typeinference bystatic codeanalysis [16,22,35, 46].The workof
Aycocketal.[ 6]andRigoetal.[ 53]analyzedtheuseofdataflow
to resolve types of objects with unknown types based on objects of
knowntypes.Xuetal.[ 66]leveragedtypehintsimpliedbycode
conventions such as variable names, code comments, and class
attributeaccess.Recentworkproposedneuralnetworkframeworks
fortypeinference[ 21,35].Ourworkhasleveragedexistingtype
767inferencetechniquestoexplorethearchitecturalimpactofpossible
dependencies caused by dynamic typing.
Architecture Analysis based on Dependencies. Many architecture-
levelanalysesusefilepairswiththedependenciesbetweenthemas
atomicunitsofanalysissuchasarchitecturerecovery[ 20],archi-
tecturalqualitymeasurements[ 40],andarchitectureanti-pattern
detection [ 40]. Architecture recovery reconstructs the modular
structure of software from code dependencies [ 20,49]. Lutellier et
al.[30,31]foundthatdynamicbindingrelateddependencieswill
improve the architecture recovery accuracy of software written in
static languages. Architecture metrics like modularity/maintain-
ability measures aim to evaluate software maintainability based on
designdecisionsembodiedbycodedependencystructures.MacCor-
mack et al. [ 32] and Mo et al. [ 40] proposed different architectural
metricstoassessmodularityandmaintainability.TheworkofMoet
al. [41] detected architecture anti-patterns, defined as connections
amongfilesthatviolatedesignprinciplesandimpactbug-proneness
andchange-proneness.Thesearchitectureanalysistechniquesas-
sumethatthedependencystructuresreflectdesigndecisions.Based
onthesameassumption,ourstudyemployedfile-levelanalysisbutforthepurposeofinvestigatingthearchitecturalimpactofpossible
dependencies.
Empirical Studies of Dynamic features. Recent research has stud-
ied dynamic features of programming languages, such as duck typ-
ing, introspection/reflection, object changes, code generation, and
libraryloading.Milojkovicetal.[ 37]studiedtheextenttowhich
duck typing is used in Smalltalk. Ã…kerblom et al. [ 2] inspected exe-
cution traces to measure the degree to which the method calls are
monomorphic or polymorphic at run-time in Python. Ã…kerblomet al. [
1] observed the usage of these features. Wang et al. [ 59]
demonstrated the correlation between frequent usage of dynamic
features and change-proneness of related code. Chen et al. [ 11]
focused on the misuse practice of dynamic typing in Python by
employing type inference techniques. Our study also leveraged the
type inference, but for a different purpose.
9 CONCLUSION
Inour studyof 105Python projectsweexploredthearchitectural
impactofpossibledependenciescausedbythelackoftypeinfor-
mationindynamiclanguages.Ourstudypresentedstrongevidencethat the architectural impact of possible dependencies is nontrivial,
and in fact surprisingly high compared with explicit dependencies.
Our results benefit software research and practice by: 1) provid-
ing empirical evidence of the impact of dynamic typing on design
structures, and 2) suggesting how automated architecture analy-
sistoolscan beimprovedâ€“augmentedwithpossibledependencies
relatedtodynamictyping.Theseresultsalsosuggesttheneedto
improve coding practice in dynamic languages by making devel-
opersmoreawareoftheimpactsoftheirdynamictypingchoices,
thus potentially leading to the adoption of safer practices.
ACKNOWLEDGMENTS
This work was supported by National Key R&D Program of China
(2018YFB0803501),NationalNaturalScienceFoundationofChina
(61632015,61772408,U1766215,61721002,61532015,61833015),Min-
istry of Education Innovation Research Team (IRT_17R86). Thiswork was also supported by the U.S. National Science Foundation,
Award numbers 1817267, 1816594, 1823177, and 1835292.
768REFERENCES
[1]Beatrice Ã…kerblom, Jonathan Stendahl, Mattias Tumlin, and Tobias Wrigstad.
2014. Tracingdynamicfeaturesinpythonprograms.In Proceedingsofthe11th
Working Conference on Mining Software Repositories. ACM, 292â€“295.
[2]Beatrice Ã…kerblom and Tobias Wrigstad. 2015. Measuring polymorphism in
Python programs. In ACM SIGPLAN Notices, Vol. 51. ACM, 114â€“128.
[3]Periklis Andritsos, Panayiotis Tsaparas, RenÃ©e J Miller, and Kenneth C Sevcik.
2004. LIMBO: Scalable clustering of categorical data. In International Conference
on Extending Database Technology. Springer, 123â€“146.
[4] ArchDia. 2004-2020. https://archdia.com.
[5]ErikArisholm,LionelCBriand,andAudunFoyen.2004. Dynamiccouplingmea-surement for object-oriented software. IEEE Transactions on software engineering
30, 8 (2004), 491â€“506.
[6] John Aycock. 2000. Aggressive type inference. language 1050 (2000), 18.
[7]Carliss Young Baldwinand Kim B Clark. 2000. Design rules: The power ofmodu-
larity. Vol. 1. MIT press.
[8]GabrieleBavota,BogdanDit,RoccoOliveto,MassimilianoDiPenta,DenysPoshy-
vanyk,andAndreaDeLucia.2013. Anempiricalstudyonthedevelopersâ€™per-
ception of software coupling. In Proceedings of the 2013 International Conference
on Software Engineering. IEEE Press, 692â€“701.
[9]LionelCBriand,JohnWDaly,andJÃ¼rgenWÃ¼st.1998. Aunifiedframeworkforco-
hesion measurement in object-oriented systems. Empirical Software Engineering
3, 1 (1998), 65â€“117.
[10]Mainak Chatterjee, Sajal K Das, and Damla Turgut. 2002. WCA: A weighted
clusteringalgorithmformobileadhocnetworks. Clustercomputing 5,2(2002),
193â€“204.
[11]ZhifeiChen,YanhuiLi,BihuanChen,WanwangyingMa,LenChen,andBaowen
Xu.2020.AnEmpiricalStudyonDynamicTypingRelatedPracticesinPythonSys-
tems.In2020IEEE/ACM28thInternationalConferenceonProgramComprehension
(ICPC).â€“ .
[12]ZadiaCodabuxandByronJWilliams.2016. Technicaldebtprioritizationusing
predictiveanalytics.In Proceedingsofthe38thInternationalConferenceonSoftware
Engineering Companion. ACM, 704â€“706.
[13]DiCui,TingLiu,YuangfangCai,QinghuaZheng,QiongFeng,WuxiaJin,Jiaqi
Guo,andYuQu.2019. InvestigatingtheImpactofMultipleDependencyStruc-
tures on Software Defects. In Software Engineering, 2019. ICSE 2019. Proceedings.
41th International Conference on. IEEE, â€“.
[14]HoaKhanhDam,TrangPham,ShienWeeNg,TruyenTran,JohnGrundy,Aditya
Ghose, Taeksu Kim, and Chul-Joo Kim. 2019. Lessons learned from using a deep
tree-based model for software defect prediction in practice. In Proceedings of the
16th International Conference on Mining Software Repositories. IEEE Press, 46â€“57.
[15]Python docs. 2001-2020. https://docs.python.org/3/glossary.html#term-duck-
typing.
[16]Michael Furr, Jong-hoon David An, Jeffrey S Foster, and Michael Hicks. 2009.Static type inference for Ruby. In Proceedings of the 2009 ACM symposium on
Applied Computing. ACM, 1859â€“1866.
[17]HaraldGall,KarinHajek,andMehdiJazayeri.1998. Detectionoflogicalcoupling
based on product release history. In Proceedings. International Conference on
Software Maintenance (Cat. No. 98CB36272). IEEE, 190â€“198.
[18]Erich Gamma. 1995. Design patterns: elements of reusable object-oriented software.
Pearson Education India.
[19]JoshuaGarcia,IgorIvkovic,andNenadMedvidovic.2013. Acomparativeanalysis
ofsoftwarearchitecturerecoverytechniques.In Proceedingsof28thIEEE/ACM
International Conference on Automated Software Engineering. IEEE, 486â€“496.
[20]JoshuaGarcia,DanielPopescu,ChrisMattmann,NenadMedvidovic,andYuan-
fangCai.2011. Enhancingarchitecturalrecoveryusingconcerns.In 201126th
IEEE/ACMInternationalConferenceonAutomatedSoftwareEngineering(ASE2011) .
IEEE, 552â€“555.
[21]VincentJHellendoorn,ChristianBird,EarlTBarr,andMiltiadisAllamanis.2018.
Deeplearningtypeinference.In Proceedingsofthe201826thacmjointmeeting
on european software engineering conference and symposium on the foundations of
software engineering. 152â€“162.
[22]SimonHolmJensen,AndersMÃ¸ller,andPeterThiemann.2009. TypeAnalysis
forJavaScript.In Proc.16thInternationalStaticAnalysisSymposium(SAS) (LNCS),
Vol. 5673. Springer-Verlag.
[23]WuxiaJin,YuanfangCai,RickKazman,QinghuaZheng,DiCui,andTingLiu.
2019. ENRE:atoolframeworkforextensibleeNtityrelationextraction.In Pro-
ceedings of the 41st International Conference on Software Engineering: Companion
Proceedings. IEEE Press, 67â€“70.
[24]WuxiaJin,TingLiu,YuQu,QinghuaZheng,DiCui,andJianleiChi.2018. Dy-
namic structure measurement for distributed software. Software Quality Journal
26, 3 (2018), 1119â€“1145.
[25]Huzefa Kagdi. 2007. Improving change prediction with fine-grained source code
mining.In Proceedingsofthetwenty-secondIEEE/ACMinternationalconferenceon
Automated software engineering. ACM, 559â€“562.
[26]Sebastian Kleinschmager, Romain Robbes, Andreas Stefik, Stefan Hanenberg,and Eric Tanter. 2012. Do static type systems improve the maintainability ofsoftware systems? An empirical study. In 2012 20th IEEE International Conference
on Program Comprehension (ICPC). IEEE, 153â€“162.
[27]Lattix. 2004-2020. https://www.sdcsystems.com/tools/lattix-software/lattix-
architect/.
[28]Duc Minh Le, Pooyan Behnamghader, Joshua Garcia, Daniel Link, Arman Shah-
bazian,andNenadMedvidovic.2015. Anempiricalstudyofarchitecturalchange
in open-source software systems. In 2015 IEEE/ACM 12th Working Conference on
Mining Software Repositories. IEEE, 235â€“245.
[29]BixinLi,XiaobingSun,HaretonLeung,andSaiZhang.2013. Asurveyofcode-
based change impact analysis techniques. Software Testing, Verification and
Reliability 23, 8 (2013), 613â€“646.
[30]Thibaud Lutellier, Devin Chollak, Joshua Garcia, Lin Tan, Derek Rayside, Ne-nad Medvidovic, and Robert Kroeger. 2015. Comparing software architecture
recoverytechniquesusingaccuratedependencies.In 2015IEEE/ACM37thIEEE
International Conference on Software Engineering, Vol. 2. IEEE, 69â€“78.
[31]Thibaud Lutellier, Devin Chollak, Joshua Garcia, Lin Tan, Derek Rayside, Nenad
MedvidoviÄ‡, and Robert Kroeger. 2018. Measuring the impact of code dependen-
cies on software architecture recovery techniques. IEEE Transactions on Software
Engineering 44, 2 (2018), 159â€“181.
[32]Alan MacCormack, John Rusnak, and Carliss Y Baldwin. 2006. Exploring the
structureofcomplexsoftwaredesigns:Anempiricalstudyofopensourceand
proprietary code. Management Science 52, 7 (2006), 1015â€“1030.
[33]Isela Macia, Roberta Arcoverde, Elder Cirilo, Alessandro Garcia, and Arndt von
Staa. 2012. Supporting the identification of architecturally-relevant code anom-
alies. In2012 28th IEEE International Conference on Software Maintenance (ICSM).
IEEE, 662â€“665.
[34]Isela Macia, Joshua Garcia, Daniel Popescu, Alessandro Garcia, Nenad Medvi-dovic, and Arndt von Staa. 2012. Are automatically-detected code anomaliesrelevanttoarchitecturalmodularity?:anexploratoryanalysisofevolvingsys-
tems.InProceedingsofthe11thannualinternationalconferenceonAspect-oriented
Software Development. ACM, 167â€“178.
[35]Rabee Sohail Malik, Jibesh Patra, and Michael Pradel. 2019. NL2Type: inferring
JavaScriptfunctiontypesfromnaturallanguageinformation.In Proceedingsof
the 41st International Conference on Software Engineering. IEEE Press, 304â€“315.
[36]Robert C Martin. 2002. Agile software development: principles, patterns, and
practices. Prentice Hall.
[37]NevenaMilojkovic,MohammadGhafari,andOscarNierstrasz.2017. Itâ€™sduck
(typing) season!. In 2017 IEEE/ACM 25th International Conference on Program
Comprehension (ICPC). IEEE, 312â€“315.
[38] Mltilang-depends. 2018-2020. https://github.com/multilang-depends/depends.[39] Ran Mo, Yuanfang Cai, Rick Kazman, and Lu Xiao. 2015. Hotspot patterns: The
formal definition and automatic detection of architecture smells. In 2015 12th
Working IEEE/IFIP Conference on Software Architecture. IEEE, 51â€“60.
[40]RanMo,YuanfangCai,RickKazman,LuXiao,andQiongFeng.2016. Decoupling
level:anewmetric forarchitecturalmaintenancecomplexity. In Proceedingsof
the 38th International Conference on Software Engineering. IEEE, 499â€“510.
[41]R. Mo, Y. Cai, R. Kazman, L. Xiao, and Q. Feng. 2019. Architecture Anti-patterns:
Automatically DetectableViolations ofDesign Principles. IEEE Transactionson
Software Engineering (2019), 1â€“1. https://doi.org/10.1109/TSE.2019.2910856
[42]RanMo,WillSnipes,YuanfangCai,SriniRamaswamy,RickKazman,andMar-
tin Naedele. 2018. Experiences applying automated architecture analysis tool
suites.In Proceedingsofthe33rdACM/IEEEInternationalConferenceonAutomated
Software Engineering. ACM, 779â€“789.
[43]NachiappanNagappan, ThomasBall, andAndreasZeller. 2006. Miningmetrics
to predict component failures. In Proceedings of the 28th international conference
on Software engineering. ACM, 452â€“461.
[44]SebastianNanzandCarloAFuria.2015. Acomparativestudyofprogramming
languages inrosetta code. In 2015 IEEE/ACM37th IEEE International Conference
on Software Engineering, Vol. 1. IEEE, 778â€“788.
[45]MatheusPaixao,JensKrinke,DongGyunHan,ChaiyongRagkhitwetsagul,and
MarkHarman.2017. Aredevelopersawareofthearchitecturalimpactoftheir
changes?. In Proceedings of the 32nd IEEE/ACM International Conference on Auto-
mated Software Engineering. IEEE Press, 95â€“105.
[46] J Palsberg. 1991. Object-oriented type inference. In Proc. OOPSLAâ€™91. 146â€“161.
[47] Chiragkumar Patel, Abdelwahab Hamou-Lhadj, and Juergen Rilling. 2009. Soft-
ware clustering using dynamic analysis and static dependencies. In Software
Maintenance and Reengineering, 2009. CSMRâ€™09. 13th European Conference on.
IEEE, 27â€“36.
[48]Denys Poshyvanyk, Andrian Marcus, Rudolf Ferenc, and Tibor GyimÃ³thy. 2009.
Using information retrieval based coupling measures for impact analysis. Empir-
ical software engineering 14, 1 (2009), 5â€“32.
[49]Kata Praditwong, Mark Harman, and Xin Yao. 2011. Software module clustering
as a multi-objectivesearch problem. IEEE Transactions onSoftware Engineering
37, 2 (2011), 264â€“282.
[50] Python. 2001-2020. https://docs.python.org/3.7/library/trace.html.[51] Python. 2001-2020. https://www.python.org/dev/peps/pep-0484/.[52]
BaishakhiRay,DarylPosnett,VladimirFilkov,andPremkumarDevanbu.2014.
A large scale study of programming languages and code quality in github. In
769Proceedingsofthe22ndACMSIGSOFTInternationalSymposiumonFoundationsof
Software Engineering. ACM, 155â€“165.
[53]Armin Rigo and Samuele Pedroni. 2006. PyPyâ€™s approach to virtual machine
construction. In Companion to the 21st ACM SIGPLAN symposium on Object-
oriented programming systems, languages, and applications. 944â€“953.
[54]Thomas Rolfsnes, Leon Moonen, and David Binkley. 2017. Predicting relevance
of change recommendations. In 2017 32nd IEEE/ACM International Conference on
Automated Software Engineering (ASE). IEEE, 694â€“705.
[55] Structure101. 2004-2020. https://structure101.com/.[56]
Yida Tao, Yingnong Dang, Tao Xie, Dongmei Zhang, and Sunghun Kim. 2012.
How do software engineers understand code changes?: an exploratory study in
industry. In Proceedings of the ACM SIGSOFT 20th International Symposium on
the Foundations of Software Engineering. ACM, 51.
[57]Vassilios Tzerpos and Richard C Holt. 2000. Accd: an algorithm for
comprehension-driven clustering. In Proceedings Seventh Working Conference on
Reverse Engineering. IEEE, 258â€“267.
[58] SciTools Understand. 1996-2020. https://scitools.com/.[59]
BeibeiWang,LinChen,WanwangyingMa,ZhifeiChen,andBaowenXu.2015.AnempiricalstudyontheimpactofPythondynamicfeaturesonchange-proneness..
InSEKE. 134â€“139.
[60]MingWen,RongxinWu,andShing-ChiCheung.2016. Locus:Locatingbugsfrom
software changes. In 2016 31st IEEE/ACM International Conference on Automated
Software Engineering (ASE). IEEE, 262â€“273.
[61]Zhihua Wen and Vassilios Tzerpos. 2004. An effectiveness measure for soft-
ware clustering algorithms. In Proceedings. 12th IEEE International Workshop onProgram Comprehension, 2004. IEEE, 194â€“203.
[62]Sunny Wong, Yuanfang Cai, Miryung Kim, and Michael Dalton. 2011. Detecting
softwaremodularityviolations.In Proceedingsofthe33rdInternationalConference
on Software Engineering. 411â€“420.
[63]Sunny Wong, Yuanfang Cai, Giuseppe Valetto, Georgi Simeonov, and Kan-
warpreet Sethi. 2009. Design rule hierarchies and parallelism in software devel-
opmenttasks.In Proceedingsofthe2009IEEE/ACMInternationalConferenceon
Automated Software Engineering. IEEE Computer Society, 197â€“208.
[64]Lu Xiao, Yuanfang Cai, and Rick Kazman. 2014. Design rule spaces: A new form
of architecture insight. In Proceedings of the 36th International Conference on
Software Engineering. ACM, 967â€“977.
[65]LuXiao,YuanfangCai,RickKazman,RanMo,andQiongFeng.2016. Identify-
ing and quantifying architectural debt. In Proceedings of the 38th International
Conference on Software Engineering. ACM, 488â€“498.
[66]ZhaoguiXu,XiangyuZhang,LinChen,KexinPei,andBaowenXu.2016. Python
probabilistic type inference with natural language support. In Proceedings of the
2016 24th ACM SIGSOFT International Symposium on Foundations of Software
Engineering. 607â€“618.
[67]Annie TT Ying, Gail C Murphy, Raymond Ng, and Mark C Chu-Carroll. 2004.
Predicting source code changes by mining change history. IEEE transactions on
Software Engineering 30, 9 (2004), 574â€“586.
[68]ThomasZimmermannandNachiappanNagappan.2008. Predictingdefectsusing
networkanalysisondependencygraphs.In 2008ACM/IEEE30thInternational
Conference on Software Engineering. IEEE, 531â€“540.
770