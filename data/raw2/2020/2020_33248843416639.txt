ER Catcher: A Static Analysis Framework for Accurate and
Scalable Event-Race Detection in Android
Navid Salehnamadi, Abdulaziz Alshayban, Iftekhar Ahmed, and Sam Malek
School of Information and Computer Sciences
University of California, Irvine, USA
{nsalehna,aalshayb,iftekha,malek}@uci.edu
ABSTRACT
Android platform provisions a number of sophisticated concur-
rencymechanismsforthedevelopmentofapps.Theconcurrency
mechanisms, while powerful, are quite difficult to properly master
by mobile developers. In fact, prior studies have shown concur-
rency issues, such as event-race defects, to be prevalent among
real-worldAndroidapps.Inthispaper,weproposeaflow-, context-,
and thread-sensitive static analysis framework, called ER Catcher,
for detection of event-race defects in Android apps. ER Catcher
introduces a new type of summary function aimed at modeling theconcurrentbehaviorofmethodsinbothAndroidappsandlibraries.
In addition, it leverages a novel, statically constructed Vector Clock
for rapid analysis of happens-before relations. Altogether, thesedesign choices enable ER Catcher to not only detect event-race
defects with a substantially higher degree of accuracy, but also in afractionoftimecomparedtotheexistingstate-of-the-arttechnique.
CCS CONCEPTS
â€¢Software and its engineering â†’Software testing and de-
bugging.
KEYWORDS
Program Analysis, Android, Concurrency, Event-Race Detection
1 INTRODUCTION
Modern mobile frameworks promote the development of highlyconcurrentsoftwareapplications,orâ€œappsâ€forshort.Inthecase
of Android, concurrency is ingrained in all facets of app behavior:
(1) an appâ€™s components run within their own threads, (2) com-
ponents can simultaneously interact with components within and
outsideoftheappbyexchangingIntentmessages,(3)thecompo-
nents at any point in time may receive lifecycle (e.g., onStart()
andonPause() )andsystem(e.g.,locationchange,batterylow)
callbackswithoutanyguaranteesastotheorderinwhichtheymay
occur.Toaidthedeveloperswithdevelopmentofconcurrentsoft-
ware,Androidprovisionsseveralnewconcurrencyconstructsinthe
form of libraries, such as AsyncTask andLooper. Nevertheless,
concurrencyisamajorsourceofconfusionfordevelopers[ 26]and
remains among the top 5 reasons for defects in Android apps [ 51].
ASE â€™20, September 21â€“25, 2020, Virtual Event, Australia
Â© 2020 Copyright held by the owner/author(s).
ACM ISBN 978-1-4503-6768-4/20/09. . . $15.00
https://doi.org/10.1145/3324884.3416639Theconventionaltechniquesfordetectionofconcurrencyissues
in Java, such as data-race defects [ 15,30,34,46], are not readily
applicable for Android [ 10,38]. They neither explicitly consider
the event-driven model ofapp behavior,nor supportthe newcon-
currency constructs in Android. More recently, researchers have
investigatedbothdynamic[ 10,20,29]andstatic[ 17,22,45]analysis
techniquesfordetectionofconcurrencyissuesinAndroid.Dynamicanalysistechniquesproposedsofararelimitedintheircapability,as
they miss true event races due to their limited coverage of the app
behavior [ 22]. Existing static analysis techniques [ 17,22,45] fail to
accuratelyidentifymanyeventracesdueto(1)imprecisemodeling
of concurrency behavior in Android, and (2) adoption of analy-
sesthatareinnatelyflow-,context-,thread-insensitive.Moreover,
theexistingstaticanalysistechniquesareslow,e.g.,nAdroid[ 17]
takes about 50 minutes on average to analyze an app. Besides that,
theseworkssupportonlyasmallandfixedsetofconcurrencyli-
braries,e.g.,SARD[ 45]onlyconsidersasynchronousinvocations
byHandler ,Activity ,andThread APIs,andcannotbeeasily
extendedtosupportotherlibraries.Furthermore,thetoolsrealizing
these techniques are either unavailable ([ 22,45]), or closed-source
([17]).
Inthispaper,weintroduceERCatcher,astaticanalysisframe-
work foreffective detectionof event-race defectsin Androidapps
thataimstoovercometheshortcomingsofpriorworks.Threenovel
conceptssetourworkapartfromthepriortechniquesandallow
us to succeed where others have failed.
First, ER Catcher relies on a new type of summary function,
calledConcurrency-awareSummaryFunction( ğ¶ğ‘†ğ¹),formodeling
theconcurrentbehaviorofmethodsinbothAndroidappsandli-
braries.The ğ¶ğ‘†ğ¹foreachappmethodisautomaticallyextracted,
whilethesetof ğ¶ğ‘†ğ¹srepresentingconcurrentbehaviorofmethods
comprising a library are manually constructed as a one-time effort.
ERCatcherprocessesmethodsinanappâ€™scallgraphinareverse
topologicalorder, therebyimprovingtheperformanceof analysis,
i.e., eliminating the need to reanalyze the same method multipletimes.Furthermore,bymodelingeachlibrary(e.g.,
AsyncTask ,
Handler ) as a set of ğ¶ğ‘†ğ¹specifications, the implementation of
ER Catcher is completely separated from its support of Android
libraries.This, inturn, allowsone toadd supportfor newor mod-
ified Android libraries by simply providing ER Catcher with theproper
ğ¶ğ‘†ğ¹specifications, and without requiring changes to the
ER Catcherâ€™s implementation.
Second,ERCatcherbuildsitsanalysisonanabstractionrepre-
sentation of app, called Context and Concurrency-aware Call Graph
(ğ¶3ğº).I nğ¶3ğº, each method call is represented in terms of its three
execution states:invocation, start,and end.Thestatesareconnected
3242020 35th IEEE/ACM International Conference on Automated Software Engineering (ASE)
This work is licensed under a Creative Commons Attribution International 4.0 License. 
325326327For each app method, the ğ¶ğ‘†ğ¹nodes and edges are extracted
using the control-flow graph of its body. Next, for each invocation
nodeofaconcurrencylibrarymethodencounteredintheapplogic,
the correspondinghelper function determinesthe attributes such
asğ‘…ğ‘‡andğ‘‡ğ‘‡. Finally, to capture the order of calls more accurately,
we change the source of call-graph edges to invocation nodes.
We model the concurrent behavior of Android components (i.e.,
Activity ,Service ,andBroadcastReceiver )usingğ¶ğ‘†ğ¹s
as well. An artificially created entryPoint method emulates
the invocation of a componentâ€™s callback methods according to
the lifecycle of the corresponding component type. We automat-
icallygeneratethe ğ¶ğ‘†ğ¹ofentryPoint methodssimilartoapp
methods, except the callbacks are invoked asynchronously in main
thread.
Currently, ER Catcher supports the following concurrency-
related constructs in Android: Thread,Looper,Handler ,
AsyncTask ,IntentService ,ServiceConnection ,
and lifecycle methods of Activity ,Service , and
BroadcastReceiver . Note that ER Catcher analyzes both app
code (written by the app developers) and app libraries, e.g., anadvertisement library. H owever, if a library introduces its own
concurrency mechanism, ER Catcher requires its corresponding
ğ¶ğ‘†ğ¹forpreciseanalysis.Formoredetailsontheimplementation
of Library ğ¶ğ‘†ğ¹, please visit the ER Catcherâ€™s website [2].
3.2 Event-Race Candidate Detection
In parallel to the construction of fine-grained models representing
the concurrent behavior of an app, ER Catcher analyzes the app to
identifyalistofallcandidateeventraces(recallFigure2).Thecrudeeventracesidentifiedatthisstagearethenfilteredinthesubsequent
steps. An event race is defined as a triplet (ğ‘†ğ‘¡ğ‘šğ‘¡1,ğ‘†ğ‘¡ğ‘šğ‘¡2,ğ¹), where
ğ‘†ğ‘¡ğ‘šğ‘¡1andğ‘†ğ‘¡ğ‘šğ‘¡2are executing in methods ğ‘€1andğ‘€2, andğ¹is
afield(representingamemorylocationstatically).Thesetriplets
havetosatisfythefollowingproperties:(1) ğ‘†ğ‘¡ğ‘šğ‘¡1andğ‘†ğ‘¡ğ‘šğ‘¡2have
accesstomemorylocation ğ¹,andatleastoneoftheaccessesisa
write; and (2) there is no happens-before relation between ğ‘†ğ‘¡ğ‘šğ‘¡1
andğ‘†ğ‘¡ğ‘šğ‘¡2
For example, theillustrative app of Figure1a has two potential
event races involving the memory location elapsedTime:
(initTime:22, onPostExecute:35, elapsedTime)
(onPostExecute:35, onPostExecute:35, elapsedTime)
In this component, we do not have any information about the
context of methods; therefore, we use a conservative approach and
presume no happens-before relation exists between the statements.
We use an off-the-shelf points-to analysis technique (SPARK [ 25])
todeterminethestatementsintwomethodsareaccessingthesame
memory location.
3.3 Context Augmentation
For precise event-race detection, we need to account for the exe-
cution context (recall Section 2). To that end, we need to augment
ğ¶2ğºwithcontextualinformationtoresolvetheunknownentries
suchasğ‘ˆğ‘ğ¾ ğ‘…ğ‘‡andğ‘ˆğ‘ğ¾ ğ‘‡ğ‘‡inğ¶ğ‘†ğ¹s.Onenaiveapproachforde-
terminingthecontexts ofallmethodsis totraversethecallgraph
alongtheedges,startingfromtheentrypoint.However,suchan
approachdoesnotscale,becausethenumberofpotentialpathsisO(2ğ‘›),whereğ‘›isthenumberofmethods.Toaddressthischallenge,
we use dynamic programming together with two filters (Race In-
volvement andSynchronousSubstitution ),whichsubstantiallyprune
the analysis and memory space. Once the contexts are determined,
the remaining parts (running and task threads) can be determined
by simply propagating threading information through the invo-cation caller sites. The result of this component is Context- and
Concurrency-aware Call Graph, called ğ¶3ğº.
Figure 4 depicts the process of determining the contexts for a
subset of the illustrative example. For brevity, only the ğ¶ğ‘†ğ¹nodes
involvedinthecontextaugmentationareshownhere.Theedges
annotated with Sare synchronous call-graph edges.
Weprocessthemethodsof ğ¶2ğº,showninFigure4a,inareverse
topological order.1During this process, a method can be in the
visited,visiting,ornon-visited stages.Foreachvisitingmethod ğ‘š,
wefirstapply RaceInvolvement filter:ifneither ğ‘šnoranyof ğ‘šâ€™s
descendants are involved in an event race, we do not process ğ‘š,
e.g., method findViewById in Figure 4b is pruned. This filter
reducestheanalysisspacedrastically.TheEvent-RaceCandidate
Detectioncomponent,discussedearlier,providesuswithalistof
methods that may be involved in an event race.
Ifğ‘špassesthisfilter,foreachincomingedgetoitsstartnode,we
makeacopyof ğ‘šandallofitsdescendantstomakeitsincoming
edges unique. We then connect each edge to the start node ofits corresponding copy (making the incoming edge of
ğ‘šâ€™s start
nodeunique).Forexample,inFigure4b,thestartnodeofmethod
onPost has only one incoming edge; therefore, there is only one
copy of onPost in Figure 4c.
If the invocation of a method is synchronous, e.g.,
onCreate â†’executeOnExecutor , it does not impact
the concurrent behavior of the app. In this situation, we apply
SynchronousSubstitution filterby(1)removingthecalleemethod,
(2) connecting the outgoing edges of caller method to the callee
methodâ€™s children, (3) annotating these edges with the caller to
maintainthesequenceofinvocations.Forexample,Figure4cshows
Synchronous Substitution ofexecuteOnExecutor . The method
executeOnExecutor is eliminated and replaced with two
annotated edges, representing alternative execution contexts. This
filtersubstantiallyimprovestheutilizedmemoryandprocessing
time of subsequent steps. Note that since we are processing themethods in the app call graph in a reverse topological order, all
descendants of ğ‘šare already visited.
Figure 4d shows the final stage of context augmentation. As
mentionedearlier,foreachincomingedgeof intermDoInBG â€™s
startnode(theedgesfrom onCreate andonClick ),acopyof
intermDoInBG anditsdescendants( onPost)iscreated,making
the incoming edge of each node unique.
Once the contexts of all methods are determined, the remain-
ing two parts (running and task threads) can be determined by
propagatingthethreadinformationstartingfromtheentrypoint.
The thread of the entry point is already known, since it runs on
theUIthreadandthereisnotaskthread(asdepictedinFigure3).
Using the ğ¶3ğºedges we propagate these information. For exam-
ple, in Figure 3, once the caller sites of executeOnExecutor
are resolved to be onCreate andonClick , the specific thread
1Ifğ¶2ğºis cyclic, we apply 1-unrolling [19] procedure and eliminate cycles.
328329330methods. Method ğ‘š1happens before method ğ‘š2if all end
states of ğ‘š1happen before start states of ğ‘š2. We remove all
event races in which there is a happens-before relation be-
tween their method calls. For example, we filter out the eventrace
(initTime:22, onPostExecute:35, elapsedTime) ,
because as depicted in Figure 5, there is a happens-beforerelation between all end states of
initTime and start
states of onPost:initTime.e â‰ºonPost-0.s and
initTime.e â‰ºonPost-1.s . However, for the event race
(onPostExecute:35, onPostExecute:35, elapsedTime) ,
there is neithera happens-before relation between onPost-0.s
and onPost-1.e , nor between onPost-0.e and
onPost-1.s. We thus report it as a possible event race.
To further prune the false event races, two filters (If-Guard and
Null-At-End ) are designed for Use-after-Free (UF) defects. A UF
defect is a harmful event race where one memory access makesa memory location free (writes
null) and another access uses
(reads)it,resultingina NullPointerException tobethrown.
If-GuardremovestheUFdefectswherethereadaccessisguardedby
a null-checking condition, e.g., in if (f!= null) f.use();
thefield fwillnotbeaccessedifitis null.Inaddition, Null-At-End
filtersUFdefectswherethememorylocationisnotreassignedwith
avalueotherthan nullafterbecomingfreee,g,.in f = null;
f = new F(); the field fis not null.
In addition to the above-mentioned filters that are sound, we
alsoprovideseveralheuristicsthatareunsound,butinpracticecan
significantly reduce the false warnings, as described next.
3.6 Prioritization
The reported event races by the previous component include all
possible event races that need to be reviewed by developers. To
facilitatethismanualprocess,weprioritizethedetectedeventraces
by our confidence in their existence. Our confidence is inversely
relatedtothedegreeofover-approximationinthestaticanalysis,
i.e.,lessover-approximationindetectinganeventraceleadstomore
confidenceaboutitsexistence.Duetotheover-approximationof
staticanalysisandourconservativeapproach,wedonotfilterevent
races for which we have incomplete information.
We prioritize event races according to the number of satisfied
over-approximationproperties. (Reachability) Weprioritizeevent
races that are reachable, i.e., there are paths in the call graph from
the entry-point to both methods of a reachable event race. The
thread-sensitive filters are not applied on unreachable event races
because their thread information is unknown. (Must-Alias) Event
racesthatinvolvestatementsaccessing must-alias fieldshavepri-
ority over may-alias fields. Two fields are must-alias if they always
pointtothesamememorylocation. (Known-Thread) Eventraces
where the threads of their methods are known have more priority
than others. For example, when we are not certain about the corre-
sponding Looper ofaHandler (whichcanbethemainthread
Looper or a custom thread Looper), we assume its messages
are handled in an unknown thread that dispatches messages in
parallel.4 EVALUATION
Thissectiondiscussesourexperimentalevaluationtoanswerthe
following research questions:
â€¢RQ1How accurate is ER Catcher in detecting true event
races?
â€¢RQ2How fast does ER Catcher analyze real-world apps?
â€¢RQ3How effective is ER Catcher in filtering false event
races?
â€¢RQ4Whatistheimpactofmodelingconcurrencyinimprov-
ing the overall accuracy of static analysis?
We evaluate ER Catcher using three different datasets. First, we
useasetofbenchmarkappscontainingevent-racedefects,called
BenchERoid [ 39]. For these apps the ground truth is known, allow-
ing us to report the precision, recall, and F1 score of ER Catcher.Second, we use a â€œCuratedâ€ dataset of 31 real-world apps withevent-race defects that have been confirmed, through either dy-
namic analysis, or code commit messages. We collected these apps
byreviewingthepriorliterature[ 17,21,29]andcrawlingtheopen-
source repositories. Finally, we evaluate the scalability and effec-tiveness of ER Catcher using 500 randomly selected apps from
F-Droid [3]. Table 1 summarizes the datasets used for evaluation.
We compare ER Catcher with nAdroid [ 17], the state-of-the-art
staticUse-after-Free(UF)event-race detectorthatisavailablepub-
licly,butnotentirelyopen-source.SincenAdroiddetectsonlyUF
event races, to make the comparison fair between ER Catcher and
nAdroid, we configure ER Catcher to report only UF event races.
WealsotriedtoempiricallycompareERCatchertoseveralother
tools, namely SIERRA [ 22], SARD [ 45], ASYNCCLOCK [ 20], and
EventRacer [ 10]. Since none of these tools are available, we con-
tacted the corresponding authors. Unfortunately, despite multiple
attempts,theauthorseitherdidnotrespondtousorconfirmedtheir
inabilitytoreleasetheirtool.Weprovideaqualitativediscussion
of thedifferences betweenER Catcherand theseother techniques
in Section 5.
Table 1: Properties of datasets used in our experiments.
Dataset # Apps Criteria Average Median MinMax
BenchERoid
dataset34#Methods 27 25.5 1851
#Components 1 1 13
Size (KB) 1123 1042 9311646
Curated
dataset31#Methods 1563 1066 785155
#Components 19 12 1138
Size (KB) 3850 2069 2926445
F-Droid
dataset500#Methods 1041 499 106432
#Components 9 5 1544
Size (KB) 4171 2000 1097676
4.1 RQ1: Accuracy
We ran ER Catcher and nAdroid on the 34 apps provided by
BenchERoidtomeasuretheirrespectiveaccuracy.Theresultsare
showninTable2.Theactualnumberofeventracesinthebench-
markappsareshownincolumn2.nAdroidusestwodifferentfilters
(soundandunsound)forreducingfalseeventraces;wereportboth
ofthemincolumns3and4,respectively.WereporttheeventracesidentifiedbyERCatcherincolumn5andtheprioritizedeventraces
(recallSection3.6)incolumn6.Wecategorizetheappsprovidedby
331BenchERoidintofourgroups.Thefirstgroupisnon-UFeventraces.
We do not consider them in comparing the accuracy of ER Catcher
withnAdroid,sincenAdroiddoesnotreportnon-UFeventraces.
ThesecondandthirdgroupsconsistofappscontainingUFevent
races related to flow- and thread-sensitivity, respectively. The rest
of the apps are placed in the â€œOther UFâ€ category.
Table 2: Benchmark Result. The general event races (high-
lighted rows) were not considered for the accuracy metrics.
âˆ—/circlecopyrtTrue Positive /circlecopyrtFalse Negative âˆ—False Positive.
App Name
# Ground Truth
Event Races
nAdroid
Sound
nAdroid
Unsound
ER Catcher
ER Catcher
Prioritized
Non-UF Event Races
SingleActivity7 1/circlecopyrt /circlecopyrt âˆ—/circlecopyrtâˆ— âˆ—/circlecopyrt
SingleActivity8 2/circlecopyrt/circlecopyrt /circlecopyrt/circlecopyrt âˆ—/circlecopyrtâˆ—/circlecopyrtâˆ—âˆ—âˆ—/circlecopyrtâˆ—/circlecopyrtâˆ—
Service5 1/circlecopyrt /circlecopyrt âˆ—/circlecopyrtâˆ— âˆ—/circlecopyrt
AsyncTask5 1/circlecopyrt /circlecopyrt âˆ—/circlecopyrtâˆ— âˆ—/circlecopyrt
AsyncTask6 0 âˆ—
Flow-Sensitive UF
SingleActivity2 0âˆ— âˆ—
SingleActivity5 2âˆ—/circlecopyrtâˆ—/circlecopyrtâˆ—âˆ—âˆ—/circlecopyrtâˆ—/circlecopyrtâˆ—âˆ—âˆ—/circlecopyrtâˆ—/circlecopyrt âˆ—/circlecopyrtâˆ—/circlecopyrt
SingleActivity6 2âˆ—/circlecopyrtâˆ—/circlecopyrtâˆ—âˆ—/circlecopyrtâˆ—/circlecopyrtâˆ—âˆ—/circlecopyrtâˆ—/circlecopyrt âˆ—/circlecopyrtâˆ—/circlecopyrt
AsyncTask2 0âˆ—
Looper1 0
Thread-Sensitive UF
SingleActivity3 1/circlecopyrt /circlecopyrt âˆ—/circlecopyrt âˆ—/circlecopyrt
AsyncTask1 1âˆ—/circlecopyrt /circlecopyrt âˆ—/circlecopyrt âˆ—/circlecopyrt
AsyncTask3 1âˆ—/circlecopyrt /circlecopyrt âˆ—/circlecopyrt âˆ—/circlecopyrt
Thread1 1âˆ—/circlecopyrtâˆ—/circlecopyrt âˆ—/circlecopyrtâˆ— âˆ—/circlecopyrtâˆ—
Thread2 1âˆ—/circlecopyrtâˆ—/circlecopyrt âˆ—/circlecopyrtâˆ— âˆ—/circlecopyrtâˆ—
Looper2 1âˆ—/circlecopyrt âˆ—/circlecopyrt âˆ—/circlecopyrt âˆ—/circlecopyrt
Service3 1/circlecopyrt /circlecopyrt âˆ—/circlecopyrt âˆ—/circlecopyrt
Service4 0 âˆ— âˆ—
Other UF
MultiComp1 2âˆ—/circlecopyrtâˆ—/circlecopyrt âˆ—/circlecopyrtâˆ—/circlecopyrt âˆ—/circlecopyrtâˆ—/circlecopyrt âˆ—/circlecopyrtâˆ—/circlecopyrt
Receiver 1âˆ—/circlecopyrt âˆ—/circlecopyrt âˆ—/circlecopyrt âˆ—/circlecopyrt
Service1 0âˆ— âˆ— âˆ— âˆ—
Service2 1âˆ—/circlecopyrt/circlecopyrt/circlecopyrt âˆ—/circlecopyrt/circlecopyrt/circlecopyrt âˆ—/circlecopyrtâˆ—/circlecopyrt/circlecopyrtâˆ—/circlecopyrtâˆ—/circlecopyrt/circlecopyrt
LifeCycle1 3âˆ—/circlecopyrtâˆ—/circlecopyrtâˆ—/circlecopyrtâˆ—/circlecopyrtâˆ—/circlecopyrtâˆ—/circlecopyrtâˆ—/circlecopyrtâˆ—/circlecopyrtâˆ—/circlecopyrtâˆ—/circlecopyrtâˆ—/circlecopyrtâˆ—/circlecopyrt
LifeCycle2 0
LifeCycle3 2âˆ—/circlecopyrtâˆ—/circlecopyrt âˆ—/circlecopyrtâˆ—/circlecopyrt âˆ—/circlecopyrtâˆ—/circlecopyrt âˆ—/circlecopyrtâˆ—/circlecopyrt
LifeCycle4 2âˆ—/circlecopyrtâˆ—/circlecopyrt âˆ—/circlecopyrtâˆ—/circlecopyrt âˆ—/circlecopyrtâˆ—/circlecopyrt âˆ—/circlecopyrtâˆ—/circlecopyrt
SingleActivity1 1âˆ—/circlecopyrt âˆ—/circlecopyrt âˆ—/circlecopyrtâˆ— âˆ—/circlecopyrt
SingleActivity4 0âˆ—âˆ—âˆ— âˆ—âˆ—âˆ— âˆ—âˆ— âˆ—âˆ—
AsyncTask4 1âˆ—/circlecopyrt /circlecopyrt âˆ—/circlecopyrt âˆ—/circlecopyrt
Executor1 1âˆ—/circlecopyrt âˆ—/circlecopyrt âˆ—/circlecopyrt âˆ—/circlecopyrt
Executor2 1âˆ—/circlecopyrtâˆ—/circlecopyrt /circlecopyrt /circlecopyrt
TimerTask1 1âˆ—/circlecopyrt âˆ—/circlecopyrt âˆ—/circlecopyrt âˆ—/circlecopyrt
TimerTask2 1âˆ—/circlecopyrt âˆ—/circlecopyrt âˆ—/circlecopyrt âˆ—/circlecopyrt
Looper3 1âˆ—/circlecopyrt âˆ—/circlecopyrt âˆ—/circlecopyrt âˆ—/circlecopyrt
Totalâˆ—/circlecopyrt(higher is better) 27 21 29 29
Total/circlecopyrt(lower is better) 4 10 2 2
Totalâˆ—(lower is better) 13 9 7 6
Precision %67 %70 %80 %82
Recall %87 %67 %93 %93
F1 %75 %68 %86 %88
Overall, ER Catcher is significantly more accurate than nAdroid.
ER Catcher achieves 80% precision and 93% recall, compared to
nAdroidâ€™s 67% precision and 87% recall. Due to its flow-sensitivity,
ER Catcher is able to filter all of the false positives reported by
nAdroidundertheFlow-SensitiveUFcategory.Duetoitsthread-
sensitivity,ERCatcherisabletoidentifyadditionaltrueeventraces
compared to nAdroid under the Thread-Sensitive UF category.AlthoughERCatcherismoreaccuratethannAdroid,ithasits
ownlimitations.ERCatcherispath-insensitive,thereforeitreports
falsepositiveUFeventracesthatresideonexecutionpathsthatwillnotexecute,e.g.,
Service1 .Duetotime-insensitivity,ERCatcher
reports false positives in cases where the statements execute atspecific times, e.g.,
SingleActivity4 . ER Catcher fails to fil-
ter one false-positive event race in SingleActivity1 due to
incomplete reachability information; however, it is removed in â€œER
Catcher Prioritizedâ€. The imprecision in the off-the-shelf points-to
analysisusedbyERCatcherleadstoafalsenegativein Service2 .
We also ran ER Catcher and nAdroid on the Curated dataset,
consisting of 31 real-world apps with confirmed event races. ER
Catcherwasabletoanalyzeallofthe31apps,whilenAdroidcouldonlyanalyze27ofthem.ERCatcherachieved100%recall,detecting
all of the event races in these apps, while nAdroid achieved 88%
recall. Since not all of the event races in these apps are known, we
are unable to report the recall using this dataset.
4.2 RQ2: Scalability
We analyzed all three datasets using ER Catcher and nAdroid to
compare the scalability of these techniques. Table 3 summarizes
the results. For the first two datasets (i.e., BenchERoid and Curated
datasets), we did not set a timeout. However, due to the large num-
ber of apps in the third dataset (F-Droid), we set a timeout of 5
minutes.Onaverage,ERCatcheranalyzedeachappintheCurated
dataset within 231 seconds, while nAdroid required 3 ,134 seconds
(âˆ¼52 minutes). Overall, ER Catcher finished the analysis between
12 to 13 times faster than nAdroid for the first two datasets.
FortheF-Droiddataset,ERCatcheranalyzed459outof500apps
(morethan 90%)within thedesignated timeof 5minutes (two apps
couldnotbeanalyzedbecauseFlowDroidcouldnotgeneratethe
call graph for them). However, nAdroid could only analyze 30 apps
(6%)withintheallottedtime.Furthermore,nAdroidcrashedduring
analysis of 316 apps (more than 60%) indicating nAdroid isunable
to complete the analysis irrespective of time.
Table 3: Analysis time summary
#Analyzed
Apps
Average
Median
Min
Max
BenchERoid
datasetnAdroid 29217s145s131s372s
ER Catcher 2918s20s7s35s
nAdroid
ER Catcher1x12x7x18x10x
Curated
datasetnAdroid 273134s786s83s22690s
ER Catcher 31231s29s4s5548s
nAdroid
ER Catcher0.87x 13x27x21x 4x
F-Droid
datasetnAdroid 30153s152s108s285âˆ—s
ER Catcher 459 53s29s4s296âˆ—s
nAdroid
ER Catcher0.06x 3x5x27x0.96x
4.3 RQ3: Effectiveness of Filters
ToevaluatethedegreetowhichERCatcherfiltersoutfalseevent
races in real-world apps, the number of UF event races in threestages of analysis are reported in Table 4. The first row shows
the number of event-race candidates identified by the â€œEvent-Race
Candidate Analysisâ€ component (recall Section 3.2). The second
332rowshowsthenumberoffilteredUFeventracesreportedbythe
â€œThread-SensitiveFilterâ€component(recallSection3.5).Thefourth
row reports the number of prioritized UF event races (recall Sec-
tion 3.6). The reduction rates achieved for the Curated and F-Droid
datasetsare%77and%86,respectively.Thisresultsinprioritizing
37and23UFeventracesthatrequiremanualinvestigationbyde-
velopers.Inpractice,manyofthedetectedeventracesarecaused
bythesamedefectincode,i.e.,onedefectincodecauseseventrace
conditions under multiple execution contexts. As a result, develop-
ers can often confirm the presence of a defect without having to
review the complete list of reported event races.
Table 4: Effectiveness of filters and prioritization
Criteria Average Median MinMaxCurated dataset#UF Candidates 317 341 01238
#Filtered UFs 150 114 0540
%Filtered
Candidates50% 54% 0%92%
#Prioritized UFs 37 15 0147
%Prioritized
Candidates23% 12% 0%100%F-Droid dataset#UF Candidates 308 57 09249
#Filtered UFs 129 5 01806
%Filtered
Candidates45% 48% 0%100%
#Prioritized UFs 23 0 01011
%Prioritized
Candidates14% 2% 0%100%
4.4 RQ4: Impact of Modeling Concurrency
A byproduct of modeling the concurrent behavior of Android apps
and libraries in the form of ğ¶2ğºis that ER Catcher can discover
a number of additional methods that are invoked indirectly, i.e.,
through the library callbacks. This enables ER Catcher to compute
reachability of methods in ways that are more accurate than other
state-of-the-art techniques, such as FlowDroid [ 7]. To evaluate this
facetofourwork,weranbothERCatcherandFlowDroidonthe
F-Droid dataset. We identified additional reachable methods in 169
of these apps. Compared to FlowDroid, ER Catcher was able to
detect on average 8 more reachable methods per app, and up to 78
more reachable methods in one app.
Thisisnotablegiventheextensivenumberoftools(e.g.,[ 8,9,23,
48])thatrelyonFlowDroidforanalysisofAndroidapps,particu-
larlyforsecurityassessment.Consider,forinstance,aninformation
leakage vulnerability caused by flow of data from a private source,
e.g., camera, to a sink, e.g., network. If the sink is located in a
methodthatisdeterminedtobeunreachablebytheanalysis,the
vulnerability cannot be discovered. According to our results, nu-
merous Android security analysis tools [ 8,9,48] built on top of
FlowDroid [ 7] would fail to discover vulnerabilities or malicious
behaviors that reside in such locations in code.
5 RELATED WORK
Ourworkbuildsuponthreemajorthreadsofresearch:concurrency
analysis,event-racedetection,andsummary-basedstaticanalysisinAndroid.Weprovideabriefoverviewoftherelevantresearch
for each of these threads in this section.
Analysis of Concurrent Behaviors: Researchers have investigated
concurrent behaviour of traditional programminglanguages such
as C or Java, primarily focusing on data races [ 27,33,36], dead-
locks[11,14,31],happens-before relation[ 52],sequential ornon-
sequentialconcurrencyerrors[ 35,49,50]andtesting[ 42].Noneof
these,however,hasinvestigatedtheconcurrentbehaviorofAndroid
apps. The most relevant work is that of Zhou et al. [ 52] that intro-
ducestheconceptofStaticVectorClocktoanalyze may-happen-
in-parallel relation betweeninstructions inC/C++; however, their
realization of this concept is not applicable to event-based systems
likeAndroid.ERCatcheraddressesthislimitationbyintroducing
event-based properties, e.g., Same Task-Queue Order.
ResearchershavealsoanalyzedtheconcurrentbehaviorofAn-
droidapps,mostlyfocusingondynamicanalysessuchastestgener-
ation [41], manipulating the code execution [ 16,44], and detecting
happens-beforerelations[ 28].Noneofthesetechniquesisableto
detect event races in Android.
Event Race Detection in Android: Although Android has tradi-
tionalJavathreadconstructs,toolsdevelopedforJavacannotreadily
detecteventracesinAndroidsinceexistingtoolsareunawareofre-
lations between events. To meet this gap, researchers have devised
dynamic and static event-race detection approaches for Android.
Dynamicevent racedetection approachesgather executiontraces
of Android apps either manually [ 21] or automatically [ 10,20,29]
usinganappcrawlersuchasMonkey[ 5].Thentheexecutiontraces
are analyzed off-line to detect happens-before relations betweenevents either by graph analysis [
10,21,29], or leveraging vector
clock[20].Thesetechniquesfailtoidentifyeventracesduetotheir
limited coverage of the behaviors of apps [22].
Static event-race detection techniques address the problem of
missingtruedefectsbyanalyzingthewholeprogram.DeVA[ 38]
detects "event anomalies" where two events access the same mem-
orylocation,andoneoftheaccessesisawrite.SinceDeVAdoesnot
considerhappens-beforerelations,itproducesalargenumberof
false positives. SIERRA [ 22] considers happens-before relation and
haslimitedcontext-sensitivity(capturingonlyoneasynchronous
actionas the context), but it is not aware of other threads except
for the main thread which may result in failure to identify bugs;
weaddressedthisissuebyourthread-sensitiveanalysismodeled
inğ¶3ğº. nAdroid [ 17] uses an existing traditional race detection
techniquetoidentifyUse-after-Free(UF)bugs.Duetotheimpre-
cisethreadificationmodelofnAdroid itreportsalargenumberof
false positives; we extensively explained and empirically evaluated
the limitations of nAdroid in comparison to ER Catcher earlier.
SARD [45], similar to nAdroid, detects UF bugs, using a flow- and
context-sensitive model of Looper. SARD applies an exhaustive
contextcreationstrategymakingitunscalable.Weaddressthescal-abilityissuebyusingsummary-basedanalysistechniquestoreduce
the space complexity.
Inallofthementionedtechniques,thesupportforvariousAn-
droid concurrency libraries is hardcoded in the implementationof tools, making it difficult to revise the tools to support new or
modified Android libraries. ER Catcher addresses this limitation by
separating the implementation of tool from the library ğ¶ğ‘†ğ¹s repre-
sentingtheconcurrentbehaviorofAndroidlibraries.Providedwith
333new or modified library ğ¶ğ‘†ğ¹s, ER Catcher can be readily extended
to support new or modified Android libraries without requiring
changestoitsimplementation. Summary-BasedStaticAnalysisin
Android:Another research thrust has investigated summary-based
approachesforpreciseandfastanalysis[ 4,6,7,12,13,47].These
techniquesmostlyuseInter-proceduralDistributedEnvironment
(IDE) framework [ 37] for modelling the inter-procedural data-flow
of the code; however, to the best of our knowledge, no prior work
has leveraged IDE frameworks to model concurrent behavior of
codelikehappens-beforerelations.Moreover,noneofthesetech-
niquescaptureinter-threadcommunicationprecisely.Asafuture
work, it would be interesting to see if IDE frameworks, or non-
distributive summary based analyses such as [ 32], can improve
thescalabilityofcreatingthe ğ¶3ğºmodel.ERCatchertakesastep
towards addressing this issue by introducing ways of summarizing
concurrency behavior in Android.
6 CONCLUSION
Concurrency-induced defects, such as event race, are one of the
most frequently encountered types of defect in Android apps [ 51].
We presented ER Catcher, a fast, novel and accurate static analysis
framework for event-race detection in Android. Experiments using
benchmarkappsshowthatERCatcherisaccurate,capableofde-
tectingeventraceswith80%precisionand93%recall.Compared
to the only other publicly available tool for event-race detection in
Android,ERCatcherissubstantiallyfaster(byafactorof12)and
moreaccurate(11%higherF1-measure).Resultsfurthercorroborate
itseffectivenessindetectingalloftheeventracesconfirmedtoexist
in a set of 31 real-world apps.
In our future work, we plan to expand the applications of ER
Catcher to other concurrency-related analyses. We believe the effi-
cienthappens-beforeanalysisofERCatchercanbeusedasaplugin
in Android Studio to provide real-time feedback to developers dur-
ingthedevelopment.Furthermore,sinceconcurrencyisthemain
cause of flaky tests [ 43], we aim to study the application of ER
Catcher in the detection of such tests.
ERCatcherandresearchartifactsarepubliclyavailablefordown-
load from the companion website [2].
ACKNOWLEDGMENT
Thisworkwassupportedinpartbyawardnumbers1618132and
1823262fromtheNationalScienceFoundation.Wewouldliketo
thank the anonymous reviewers of this paper for their detailed
feedback, which helped us improve the work.
REFERENCES
[1]2020.ERCatcherFormal Proofs. RetrievedAugust31, 2020fromhttps://github.
com/seal-hub/ERCatcher/blob/master/ERCatcher_Appendix.pdf
[2]2020.ER Catcher Tool. Retrieved August 31, 2020 from https://github.com/seal-
hub/ERCatcher
[3] 2020. F-Droid. Retrieved March 4 , 2020 from https://f-droid.org/en/
[4]Karim Ali and OndÅ™ej LhotÃ¡k. 2013. Averroes: Whole-program analysis without
the whole program. In European Conference on Object-Oriented Programming.
Springer, 378â€“400.
[5]Android.2020. UI/ApplicationExerciserMonkey. RetrievedFebruary2,2020from
https://developer.android.com/studio/test/monkey
[6]StevenArztandEricBodden.2016.StubDroid:automaticinferenceofprecisedata-
flow summaries for the android framework. In 2016 IEEE/ACM 38th International
Conference on Software Engineering (ICSE). IEEE, 725â€“735.[7]Steven Arzt, Siegfried Rasthofer, Christian Fritz, Eric Bodden, Alexandre Bar-
tel,JacquesKlein,YvesLeTraon,DamienOcteau,andPatrickMcDaniel.2014.
Flowdroid: Precise context, flow, field, object-sensitive and lifecycle-aware taint
analysis for android apps. Acm Sigplan Notices 49, 6 (2014), 259â€“269.
[8]VitaliiAvdiienko,KonstantinKuznetsov,AlessandraGorla,AndreasZeller,Steven
Arzt,SiegfriedRasthofer,andEricBodden.2015. Miningappsforabnormalusage
ofsensitivedata.In 2015IEEE/ACM37thIEEEInternationalConferenceonSoftware
Engineering, Vol. 1. IEEE, 426â€“436.
[9]HamidBagheri,AlirezaSadeghi,JoshuaGarcia,andSamMalek.2015. Covert:
Compositionalanalysisofandroidinter-apppermissionleakage. IEEEtransactions
on Software Engineering 41, 9 (2015), 866â€“886.
[10] Pavol Bielik, VeselinRaychev, andMartin Vechev.2015. Scalablerace detection
for Android applications. In Proceedings of the 2015 ACM SIGPLAN International
ConferenceonObject-OrientedProgramming,Systems,Languages,andApplications
-OOPSLA2015.ACMPress,Pittsburgh,PA,USA,332â€“348. https://doi.org/10.
1145/2814270.2814303
[11]Chandrasekhar Boyapati, Robert Lee, and Martin Rinard. 2002. Ownership
types for safe programming: preventing data races and deadlocks. In Proceedings
ofthe17thACMSIGPLANconferenceonObject-orientedprogramming,systems,
languages,andapplications (OOPSLAâ€™02).AssociationforComputingMachinery,
Seattle, Washington, USA, 211â€“230. https://doi.org/10.1145/582419.582440
[12]Yinzhi Cao, Yanick Fratantonio, Antonio Bianchi, Manuel Egele, Christopher
Kruegel, Giovanni Vigna, and Yan Chen. 2015. EdgeMiner: Automatically De-
tectingImplicitControlFlowTransitionsthroughtheAndroidFramework..In
NDSS.
[13]TomDeering,GaneshRamSanthanam,andSureshKothari.2015. Flowminer:Au-tomaticsummarizationoflibrarydata-flowformalwareanalysis.In International
Conference on Information Systems Security. Springer, 171â€“191.
[14]Dawson Engler and Ken Ashcraft. 2003. RacerX: effective, static detection of
raceconditionsanddeadlocks. ACMSIGOPSOperatingSystemsReview 37,5(Oct.
2003), 237â€“252. https://doi.org/10.1145/1165389.945468
[15]John Erickson, Madanlal Musuvathi, Sebastian Burckhardt, and Kirk Olynyk.
[n.d.]. Effective Data-Race Detection for the Kernel. ([n.d.]), 12.
[16]LinglingFan,TingSu,SenChen,GuozhuMeng,YangLiu,LihuaXu,andGeguang
Pu.2018. Efficientlymanifestingasynchronousprogrammingerrorsinandroid
apps. InProceedings of the 33rd ACM/IEEE International Conference on Automated
Software Engineering. 486â€“497.
[17]Xinwei Fu, Dongyoon Lee, and Changhee Jung. 2018. nAdroid: statically de-tecting ordering violations in Android applications. In Proceedings of the 2018
International Symposium on Code Generation and Optimization - CGO 2018.A C M
Press, Vienna, Austria, 62â€“74. https://doi.org/10.1145/3168829
[18]SumitGulwaniandAshishTiwari.2007. Computingproceduresummariesfor
interprocedural analysis. In European Symposium on Programming. Springer,
253â€“267.
[19]John LHennessy and DavidA Patterson. 2011. Computer architecture:a quanti-
tative approach. Elsevier.
[20]Chun-HungHsiao,SatishNarayanasamy,EssamMuhammadIdrisKhan,Cris-
tiano L Pereira, and Gilles A Pokam. 2017. Asyncclock: Scalable inference of
asynchronous event causality. ACM SIGPLAN Notices 52, 4 (2017), 193â€“205.
[21]Chun-Hung Hsiao, Cristiano L. Pereira, Jie Yu, Gilles A. Pokam, SatishNarayanasamy, Peter M. Chen, Ziyun Kong, and Jason Flinn. 2013. Race de-tection for event-driven mobile applications. In Proceedings of the 35th ACM
SIGPLAN Conference on Programming Language Design and Implementation -
PLDI â€™14. ACMPress, Edinburgh, United Kingdom,326â€“336. https://doi.org/10.
1145/2594291.2594330
[22]Yongjian Hu and Iulian Neamtiu. 2018. Static Detection of Event-based Races
in Android Apps. In Proceedings of the Twenty-Third International Conference on
ArchitecturalSupportforProgrammingLanguagesandOperatingSystems(ASPLOS
â€™18).ACM,NewYork,NY,USA,257â€“270. https://doi.org/10.1145/3173162.3173173
event-place: Williamsburg, VA, USA.
[23]R.Jabbarvand,J.Lin,andS.Malek.2019. Search-BasedEnergyTestingofAndroid.
In2019IEEE/ACM41stInternationalConferenceonSoftwareEngineering(ICSE).
1119â€“1130.
[24]LeslieLamport.2019. Time,clocks,andtheorderingofeventsinadistributed
system. In Concurrency: the Works of Leslie Lamport. 179â€“196.
[25]OndÅ™ejLhotÃ¡kandLaurieHendren.2003. ScalingJavapoints-toanalysisusingS
park. InInternational Conference on Compiler Construction. Springer, 153â€“169.
[26]Jun-WeiLin,NavidSalehnamadi,andSamMalek.2020. TestAutomationinOpen-
Source Android Apps: A Large-Scale Empirical Study. In 2020 35th IEEE/ACM
International Conference on Automated Software Engineering (ASE). IEEE.
[27]MagnusMadsen,FrankTip,andOndÅ™ejLhotÃ¡k.2015. Staticanalysisofevent-
driven Node. js JavaScript applications. ACM SIGPLAN Notices 50, 10 (2015),
505â€“519.
[28]PallaviMaiyaandAdityaKanade.2017. Efficientcomputationofhappens-before
relation for event-driven programs. In Proceedings of the 26th ACM SIGSOFT
International Symposium on Software Testing and Analysis. 102â€“112.
[29]Pallavi Maiya, Aditya Kanade, and Rupak Majumdar. 2014. Race detection for
Android applications. ACM SIGPLAN Notices 49, 6 (June2014), 316â€“325. https:
334//doi.org/10.1145/2666356.2594311
[30]Mayur Naik, AlexAiken,and John Whaley. 2006. Effective static racedetection
forJava.In Proceedingsofthe27thACMSIGPLANConferenceonProgramming
Language Design and Implementation. 308â€“319.
[31]MayurNaik,Chang-SeoPark,KoushikSen,andDavidGay.2009. EffectiveStatic
DeadlockDetection.In Proceedingsofthe31stInternationalConferenceonSoftware
Engineering (ICSE â€™09). IEEE Computer Society, Washington, DC, USA, 386â€“396.
https://doi.org/10.1109/ICSE.2009.5070538
[32]Rohan Padhye and Uday P Khedker. 2013. Interprocedural data flow analysis in
soot using value contexts. In Proceedings of the 2nd ACM SIGPLAN International
Workshop on State Of the Art in Java Program analysis. 31â€“36.
[33]Boris Petrov, Martin Vechev, Manu Sridharan, and Julian Dolby. 2012. Race
detection for web applications. ACM SIGPLAN Notices 47, 6 (2012), 251â€“262.
[34]Polyvios Pratikakis, Jeffrey S. Foster, and Michael Hicks. 2011. LOCKSMITH:
PracticalstaticracedetectionforC. ACMTransactionsonProgrammingLanguages
andSystems(TOPLAS) 33,1(Jan.2011),3:1â€“3:55. https://doi.org/10.1145/1889997.
1890000
[35]ShazQadeerandDinghaoWu.2004. KISS:keepitsimpleandsequential. ACM
SIGPLANNotices 39,6(June2004),14â€“24. https://doi.org/10.1145/996893.996845
[36]VeselinRaychev,Martin Vechev,and Manu Sridharan.2013. Effectiverace de-tection for event-driven programs. In Proceedings of the 2013 ACM SIGPLAN
international conference on Object oriented programming systems languages &
applications. 151â€“166.
[37]ThomasReps,SusanHorwitz,andMoolySagiv.1995. Preciseinterprocedural
dataflowanalysisviagraphreachability.In Proceedingsofthe22ndACMSIGPLAN-
SIGACT symposium on Principles of programming languages. 49â€“61.
[38]GholamrezaSafi,ArmanShahbazian,WilliamG.J.Halfond,andNenadMedvi-
dovic. 2015. Detecting event anomalies in event-based systems. In Proceedings of
the 2015 10th Joint Meeting on Foundations of Software Engineering - ESEC/FSE
2015.ACMPress,Bergamo,Italy,25â€“37. https://doi.org/10.1145/2786805.2786836
[39]NavidSalehnamadi,AbdulazizAlshayban,IftekharAhmed,andSamMalek.[n.d.].
Poster:ABenchmarkforEvent-RaceAnalysisinAndroidApps.In Proceedings
of the 18th Annual International Conference on Mobile Systems, Applications, and
Services.
[40]MichaSharir,AmirPnueli,etal .1978.Twoapproachestointerproceduraldataflow
analysis. New York University. Courant Institute of Mathematical Sciences ....
[41]HongyinTang,GuoquanWu,JunWei,andHuaZhong.2016. Generatingtestcases to expose concurrency bugs in android applications. In Proceedings of
the31stIEEE/ACMinternationalConferenceonAutomatedsoftwareengineering.648â€“653.
[42]ValerioTerragniandMauroPezzÃ¨.2018. Effectivenessandchallengesingenerat-
ing concurrent tests for thread-safe classes. In Proceedings of the 33rd ACM/IEEE
International Conference on Automated Software Engineering. 64â€“75.
[43]Swapna Thorve, Chandani Sreshtha, and Na Meng. 2018. An empirical study of
flaky tests in Android apps. In 2018 IEEE International Conference on Software
Maintenance and Evolution (ICSME). IEEE, 534â€“538.
[44]Jue Wang, Yanyan Jiang, Chang Xu, Qiwei Li, Tianxiao Gu, Jun Ma, XiaoxingMa, and Jian Lu. 2018. AATT+: Effectively manifesting concurrency bugs in
Androidapps. ScienceofComputerProgramming 163(Oct.2018),1â€“18. https:
//doi.org/10.1016/j.scico.2018.03.008
[45]D. Wu, J. Liu, Y. Sui, S. Chen, and J. Xue. 2019. Precise Static Happens-Before
Analysis for Detecting UAF Order Violations in Android. In 2019 12th IEEE
ConferenceonSoftwareTesting,ValidationandVerification(ICST).276â€“287. https:
//doi.org/10.1109/ICST.2019.00035
[46]Xinwei Xie, Jingling Xue, and Jie Zhang. 2013. Acculock: accurate and efficient
detectionofdataraces. Software:PracticeandExperience 43,5(2013),543â€“576.
https://doi.org/10.1002/spe.2121
[47]Dacong Yan, Guoqing Xu, and Atanas Rountev. 2012. Rethinking soot forsummary-based whole-program analysis. In Proceedings of the ACM SIGPLAN
International Workshop on State of the Art in Java Program analysis. 9â€“14.
[48]Wei Yang, Xusheng Xiao, Benjamin Andow, Sihan Li, Tao Xie, and William Enck.
2015. Appcontext:Differentiatingmaliciousandbenignmobileappbehaviors
using context. In 2015 IEEE/ACM 37th IEEE International Conference on Software
Engineering, Vol. 1. IEEE, 303â€“313.
[49]WeiZhang,JungheeLim,RamyaOlichandran,JoelScherpelz,GuoliangJin,Shan
Lu, and Thomas Reps. [n.d.]. ConSeq: Detecting Concurrency Bugs through
Sequential Errors. ([n.d.]), 14.
[50]Wei Zhang, Chong Sun, and Shan Lu. [n.d.]. ConMem: Detecting Severe Concur-
rency Bugs through an Effect-Oriented Approach. ([n.d.]), 13.
[51]Bo Zhou, Iulian Neamtiu, and Rajiv Gupta. 2015. A cross-platform analysis ofbugs and bug-fixing in open source projects: Desktop vs. android vs. ios. In
Proceedings of the 19th International Conference on Evaluation and Assessment in
Software Engineering. 1â€“10.
[52]Qing Zhou, Lian Li, Lei Wang, Jingling Xue, and Xiaobing Feng. 2018. May-
happen-in-parallel Analysis with Static Vector Clocks. In Proceedings of the 2018
InternationalSymposiumonCodeGenerationandOptimization (CGO2018).ACM,
New York, NY, USA, 228â€“240. https://doi.org/10.1145/3168813 event-place:
Vienna, Austria.
335