Improving Data Scientist Efficiency with Provenance
Jingmei Hu
Harvard University
Cambridge, MA, USAJiwon Joung
University of Michigan
Ann Arbor, MI, USAMaia Jacobs
Harvard University
Cambridge, MA, USA
Krzysztof Z. Gajos
Harvard University
Cambridge, MA, USAMargo I. Seltzer
University of British Columbia
Vancouver, BC, Canada
ABSTRACT
Data scientists frequently analyze data by writing scripts. We con-
ducted a contextual inquiry with interdisciplinary researchers,
which revealed that parameter tuning is a highly iterative process
andthatdebuggingis time-consuming.Asanalysisscriptsevolve
andbecomemorecomplex,analystshavedifficultyconceptualizing
their workflow. In particular, after editing a script, it becomes diffi-
culttodeterminepreciselywhichcodeblocksdependontheedit.
Consequently, scientists frequently re-run entire scripts instead
of re-running only the necessary parts. We present ProvBuild, atool that leverages language-level provenance to streamline thedebugging process by reducing programmer cognitive load anddecreasing subsequent runtimes, leading to an overall reduction
in elapsed debugging time. ProvBuild uses provenance to track de-
pendencies in a script. When an analyst debugs a script, ProvBuild
generates a simplified script that contains only the information
necessarytodebugaparticularproblem.Wedemonstratethatde-
buggingthesimplifiedscriptlowersaprogrammer‚Äôscognitiveload
and permits faster re-execution when testing changes. The com-bination of reduced cognitive load and shorter runtime reduces
thetimenecessarytodebugascript.Wequantitativelyandqual-
itatively show that even though ProvBuild introduces overhead
during a script‚Äôs first execution, it is a more efficient way for users
to debug and tune complex workflows. ProvBuild demonstratesa novel use of language-level provenance, in which it is used to
proactively improve programmer productively rather than merely
providing a way to retroactively gain insight into a body of code.
CCS CONCEPTS
‚Ä¢Software and its engineering ‚ÜíSoftware development tech-
niques.
KEYWORDS
Provenance,incrementalexecution,dependencytracking,dataanal-
ysis
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACMmustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ICSE ‚Äô20, May 23‚Äì29, 2020, Seoul, Republic of Korea
¬© 2020 Association for Computing Machinery.
ACM ISBN 978-1-4503-7121-6/20/05...$15.00
https://doi.org/10.1145/3377811.3380366ACM Reference Format:
Jingmei Hu, Jiwon Joung, Maia Jacobs, Krzysztof Z. Gajos, and Margo I.
Seltzer. 2020. Improving Data Scientist Efficiency with Provenance. In 42nd
International Conference on Software Engineering (ICSE ‚Äô20), May 23‚Äì29,
2020, Seoul, Republic of Korea. ACM, New York, NY, USA, 12 pages. https:
//doi.org/10.1145/3377811.3380366
1 INTRODUCTION
Researchersacrossawiderangeofdisciplinesroutinelyparse,trans-
form andprocess data by writingdata analysis scripts. Scriptsare
a convenient and flexible way for data scientists to decompose a
data processing procedure into steps, including preprocessing data
input, training models, tuning arguments or parameters, adding
new analysis functions, and propagating changes through to other
data.Bysomeestimates,millionsofpeoplewritescriptstoconduct
data analysis tasks. However, only a small portion are professional
software engineers [52].
It is standard for researchers to arrange their scripts and data
into a pipeline [ 3], which typically consists of reading data from
morethanoneinput,analyzingandingestingdatawithmultiple
processingstepsandproducingoneormoreoutputs.Weconducted
acontextualinquirywithfiveresearchscientistsatalargeresearch
university to understand common data processing procedures and
thepainpointsofanalysispipelinedevelopment.Whileeachpar-
ticipant struggled witha unique set of challenges, afew problems
werecommontoall.Allparticipantsusedaniterativeprocessbased
on editing, executing, and evaluating. In particular, researchers re-
peatedlychangedparametersandreranscriptsuntiltheyarrivedat
‚Äúgood‚Äù parameter settings. Parameter tuning accounted for the ma-
jority of development time. Although in theory each edit required
re-executingonlydependentportionsoftheanalysispipeline,in
practice,researchersdefaultedtorerunningtheentirescripts,be-
causeitwasnotobvioushowtorerunonlythenecessaryparts.This
procedure was both time-consuming and cognitively demanding.
Efficiently tuning model parameters is an open problem [ 49].
Tuning time grows exponentially as program dimensionality in-
creases[51].Rerunningapipelineaftermodifyingascripttechni-
cally requires rerunning only the dependent (downstream) compo-
nents. However, identifying these dependencies requires reasoningabouttheentireworkflow,whichiscomplexandinconvenient.Con-
sequently, researchers usually rerun entire workflows after each
change. As a result, each iteration takes more time than is strictly
necessary. Thus, tuning parameters and debugging can take hours.
A tool that optimizes this process has the potential to increase
researcher efficiency.
10862020 IEEE/ACM 42nd International Conference on Software Engineering (ICSE)
Toaddressthisinefficiency,wedevelopedProvBuild,adataanal-
ysis environment that uses change impact analysis [ 4] to improve
the iterative editing process in script-based workflow pipelines by
harnessing a script‚Äôs provenance. In particular, we use language-
level provenance [ 13], which records information about every line
of code executed by a script, including variable names, variable
values,functiondefinitions,functioncallsandtheirparameters,and
the relationships among all these objects [ 37]. ProvBuild demon-
stratesanoveluseofsuchprovenance.Traditionally,provenance
tools have been used for visualizing workflows (e.g., [ 7,45,48])
explaining the results of relational queries [ 9,10,19], or recording
systembehavior[ 5,36,42].Incontrast,ProvBuildusesprovenance
toimproveprogrammerproductivity.ProvBuildobtainsprovenance
usingnoWorkflow[ 44],aPython-basedprovenancecapturetool.
Using the provenance information, ProvBuild identifies dependen-
cies between inputs, program statements, functions, variables, and
outputs,allowingittopreciselyidentifythesectionsofascriptthat
mustbere-executedtocorrectlyupdateresultsafteramodification.
ProvBuildthen generatesacustomized script,the ProvScript,that
containsonlythosesectionsaffectedbyamodification.Wehypoth-esizedthatthisstreamlinedscriptwouldallowuserstoreasonmore
easily and quickly about the consequences of their edits incurring
lesscognitiveloadandallowinguserstocompletetheirjobmore
quickly. We evaluated this hypothesis in multiple ways.
First,weevaluatedProvBuildinacontrolledlaboratoryexper-
iment with 21 participants who performed a series of debuggingtasks with and without ProvBuild. Next, we ran benchmarks to
quantifyhowmuchtimeProvBuildsavedduringscriptre-execution.
Finally,weevaluated ProvBuildinanotheruser study. Inthisreal-
worlddeploymentstudy,wegave12participantsaccesstoProvBuild
foraweekandusedsurveystoassessProvBuild‚Äôsutility.Weasked
participants how and when they chose to use ProvBuild in their
daily work.
The contributions of this paper are:
‚Ä¢A novel use of language-level provenance. Provenance is
usedproactivelytoimproveprogrammerproductivityrather
than merely providing a way to retroactively gain insight
into a body of code. ProvBuild is the first debugging tool to
leveragelanguage-levelprovenancetoreducecognitiveload
and execution time.
‚Ä¢A quantitative experiment demonstrating that ProvBuild
shortens re-execution time using stored provenance.
‚Ä¢Acontrolledlabstudydemonstratingthatuserspreferpro-
grammingwithProvBuildtoprogrammingwithoutit,that
they complete programming tasks more quickly, and that
ProvBuild reduces their cognitive load.
‚Ä¢A real-world deployment study where users explained that
ProvBuild saved them time, helped them understand their
workflow, and provided more immediate results.
Section 2 describes our contextual inquiry that led to the devel-
opment of Provbuild. Section 3 presents ProvBuild‚Äôs design andimplementation. Sections 4-7 describe and report the results of
our various evaluations. Discussion, related work and conclusions
follow in Sections 8-10.2 PROBLEM FORMATION
ProvBuildistheresultofacontextualinquiryintohowresearchers
interactwiththeirdata.Usingthecontextualinquirymethod[ 6],
we conducted a field study with five researchers at a large research
university. The researchers‚Äô areas of expertise included appliedmathematics,computerscience,geography,appliedphysics,and
clinical biology.
Webeganbyinterviewingeachparticipantaboutthespecificsof
theirdataanalysistaskstakenfromtheirownresearchprojectsandthestepstheytakeinperformingthesetasks.Then,tworesearchers
observed participantswith minimal interferenceas they executed
thesetakes.Wetooknotesonhowtheyexecutedtheiranalysis(e.g.,
bytypingcommandstoaninterpreterorrunningascript),what
they did when they encountered a surprising or unexpected result,
andhowtheyevaluatedchangestheymade.Wealsoaskedthem
explicitly to verbally express any frustration with their process;afterward we asked them what sorts of tools might reduce that
frustration.
After comparing the individual researchers‚Äô notes, we drew two
mainconclusions.First,usersspentsignificanttimere-executing
scripts during the dataanalysis process, and parameter tuning ac-
counts for the majority of development time. Three participants
mentionedthattheyhadtorunscriptsmultipletimestoidentify
appropriate patterns, engineer features, and train models. Some
alsostatedthatitrequiredagreatdealofefforttoproduceadesired
output. They reported that tuning model parameters was time-consuming, because the process involved manually re-running
whole scripts for each parameter combination. Although changes
inthemiddleofananalysispipelinedonotrequireexecutingstate-
ments prior to the change, users report that it was difficult to iden-
tify which parts of a script were affected by a change; doing so
required too much effort. The researchers tended to treat the data
analysispipelineasadiscrete,indivisibleunit.Aftereditingascript,
our subjects all simply reran their entire pipeline.
Second, researchers placed a high premium on ease of adop-
tionwhenconsideringnew tools.Duringinterviews,participants
expressed interest in a tool that would reduce inefficiencies sur-
roundingdataprocessing.However,thisinterestwasqualifiedby
hesitations about the overhead of learning and adopting a new
tool. We concluded that familiarity and usability must be first class
considerations in addressing the re-execution inefficiency.
3 PROVBUILD: PIPELINE DEBUGGING USING
PROVENANCE
WedesignedanddevelopedProvBuildtoaddressthechallengeswe
discoveredinourcontextualinquiry.ProvBuildleverages language-
level provenance collected by noWorkflow [ 37], which uses pro-
gramslicing[ 56]torecordeveryactiontakeninascriptandthe
dependencies between objects, such as variables, values, and func-
tions.Usingthesedatadependencies,whenausermodifiesascript,
ProvBuildidentifiespreciselywhichscriptstatementsmustbere-
executed to produce new results. ProvBuild constructs a shortened
script,calleda ProvScript,thatreducesre-executiontimeandmakes
iteasiertoreasonabouttheeffectofauser‚Äôsmodification.ProvBuild
consistsofabackendengine(Figure1,Section3.3)andauserin-
terface (Figure 3, Section 3.5).
1087
!!!
!!!

!!
	




	


 	
!	 !
!!
Figure 1: ProvBuild Architecture.
3.1 The User View
When a user begins tuning or debugging a script, they upload
their script to ProvBuild. Using the frontend GUI, described in
Section 3.5, they select the function, output, or variable they aredebugging/tuning.(Fortherestofthesection,werefertothisas
thetarget.)ProvBuildthengeneratesa ProvScript,whichcontains
only the code necessary to produce the target. The example shown
in Figure 2 illustrates this procedure. Imagine that a user wishes to
debugthe bazfunction.The bazfunctionaffectslines9and14only,
since ccontainsthereturnvalueof baz(line9),whichisthenused
to compute ein line 14. ProvBuild treats variables a,b,d, and fas
constants,sincetheirvaluesdonotdependon bazanddonotneed
to be recomputed. ProvBuild extracts the appropriate values for
themfromtheprovenanceandassignsthosevaluestothevariables
in the resulting ProvScript.
Without ProvBuild,users typicallyrerun theentire scriptafter
eachedit;withProvBuild,usersruntheautomaticallygeneratedProvScript after an edit. In the example, ProvBuild inserts four
linesatthetopofthe ProvScript assigningtheconstantvaluesof
a,b,d, and f, inserts the definition of function baz, and includes
the dependent lines (7 and 8). ProvBuild ignores the definitionof functions
fooandbar, because they are irrelevant and do not
depend on bar. As such, the resulting ProvScript contains only
the code necessary to test changes to baz. The shortened script
minimizes re-execution time and isolates the code being debugged,
making it easier to reason about how modifications affect their
pipeline. Users need not modify their current debugging or tuning
behavior,sinceProvBuildhidestheprovenance-drivenoptimizationprocessbehindtheuserinterfaceandpresentsthemwithasimpler
editing task.
3.2 Provenance Collection
Figure 1 depicts ProvBuild‚Äôs high-level architecture. ProvBuild cap-
turesprovenanceusingnoWorkflow[ 37,44],anopensourceprove-
nance collectiontool for Python.noWorkflow usesa combination
ofstaticanddynamicanalysistocapturethreetypesofprovenance
[18].Definition provenance is a record of all global variables and
functiondefinitions,calls,andargumentsinascript. Deployment
provenance includes the execution environment and library depen-
dencies.Execution provenance accumulates while a script runs and
canbeeithercoarse-grainorfine-grain.Coarse-grainprovenance
includesinformationabouteveryfunctioninvocation(thefunction,
its arguments, and the return value) and file accesses. noWorkflow# original script # ProvScript
[1] def foo(var): [1]a=1 0
[2] return var [2]b=2 0
[3] def bar(var): [3]d=3
[4] return var*3 [4]f=2 0 4[5] def baz(var1,var2): [5] def baz(var1,var2):[6] return var1+var2 #####L5
[7] a = foo(10) [6] return var1+var2
[8] b = foo(20) #####L6
[9] c = baz(a,b) [7] c = baz(a,b) #####L9
[10] ifa%2= =0 : [ 8 ]e=b+c#####L15[11] d = foo(3)[12] else:[13] d = bar(2)[ 1 4 ]e=b+c[ 1 5 ]f=b*1 0[16] for i in range(1,5):[17] f += foo(1)
Figure 2: Comparison between an original script and the
ProvScript.
usesprogramslicing[ 56]tocapturefine-grainprovenance,such
as control flows and variables and their dependencies.
Although ProvBuild currently works with provenance captured
by noWorkflow, there is nothing in its design that precludes it
fromworkingwithotherlanguage-levelprovenancecapturesys-
tems, such as R‚Äôs RDataTracker [ 34]. We leave development of a
provenance-capture-agnostic version of ProvBuild to future work.
ProvBuild analyzes the fine-grain provenance to construct a de-
pendencygraph,whichidentifiesthepartsofthescriptonwhicha
particular edit depends. It then produces the ProvScript by travers-
ing the dependency graph, assigning variables concrete values
where possible and computed values otherwise. We discuss this in
more detail in the next section.
3.3 Dependency Exploration
ProvBuild‚Äôs backend consists of two main parts: (1) dependency
explorationand(2)scriptmerging.Wediscussdependencyexplo-
ration here and script merging in the next section.
ThekeytoProvBuildliesinitsabilitytoconstructanaccuratede-
pendencygraph.Somecomponentsofthedependencygraphappear
intheprovenancewhileothersdonot. Thefollowingparagraphs,
whichaddressfunctiondefinitionsandcontrolflow,describethe
differentstrategiesemployedinconstructingaprovenancegraph
in which we can explore dependencies.
3.3.1 Function Definitions. Thereare twokindsoffunctions that
theProvScript might need: those appearing in the script (which
are part of the definition provenance) and those that come from
imported libraries. ProvBuild identifies the necessary subset of the
the functions appearing in the script using the function invocation
informationintheprovenance.Ratherthanidentifyingprecisely
which functions are needed from libraries, we retain all import
statements from the original script in the ProvScript.
10883.3.2 Control Flow. There are aspects of a script that ProvBuild
needs to construct for the ProvScript that are not recorded in the
provenance.Forexample,noWorkflowprovenancedoesnotfully
captureconditionalcontrolflow,becauseprovenanceisanexecu-
tionrecord,andanyspecificexecutionfollowsonlyoneclauseof
anif-elif-else statement. Ho wever, ProvBuild needs to include
allconditionalclausesina ProvScript toensurethatre-execution
is correct. ProvBuild accomplishes this using static analysis of the
original script. During this static analysis, it creates a pseudo func-
tion for the the entire conditional expression (i.e., including all
conditions).WhenProvBuildneedstoincludeaconditionalexpres-
sion in the ProvScript, it includes the pseudo function instead of
including just the single clause from the actual execution.
Consider the following. In the original script in Figure 2, ais
even, so fooalways executes on line 11 and barnever does. The
execution provenance records the use of foobut not bar, which
appearsonlyinthedefinitionprovenance.Now,let‚Äôssaythatauser
isinterestedintuningthevalueof a(i.e.,changetheargumentto
foofrom 10 to 9).When they re-execute, noWorkflow‚Äôs execution
provenance indicates that foois the only function that depends on
x.ProvBuildobservesthataconditionalappearsinthe ProvScript
andincludesthefullconditionalclauseasshown inthefollowing
code, sothat re-executionproduces the correctresult, even when a
is odd during a later execution.
# ProvScript
[1] ... # variable b, c, e, f assignments[2] def foo(var): #####L1[3] return var #####L2[4] def bar(var): #####L3[5] return var*3 #####L4[6] a = foo(9) #####L7[ 7 ] i fa%2= =0 :#####L10[8] d = foo(3) #####L11[9] else: #####L12[10] d = bar(2) #####L13
Proactively including every possible function definition could lead
toanoverlycomplicated ProvScript.Instead,ProvBuildusesitera-
tive exception handling to identify only those function definitions
needed for a particular execution. The iterative exception handling
happensonlywhenexecutingstatementsinaconditionalthatei-
therwerenotexecutedthefirsttimeorrequireloadingofadditionalfunctions.ProvBuildinitiallyreliesontheexecutionprovenance;intheexample,the ProvScript includesonly
foo‚Äôsdefinition.Iftheuser
makes the value of aodd and re-executes, the ProvScript throws
aNameError exceptionwhenitencounterstheinvocationof bar.
ProvBuild catches the exception, extracts the necessary function
definitionfromtheoriginalscript,andregeneratesthe ProvScript
with the additional function. ProvBuild continues catching such
exceptions, regenerating the ProvScript each time, until script exe-
cutioncompleteswithoutthe NameError exception.The ProvScript
is a superset of a program slice and our iterative dynamic trapping
ensures that we are not missing necessary parts of the program.
3.3.3 Constructing the Provenance Graph. Given a target, we di-
videtheexecutionprovenanceofascriptinto upstreamprovenance ,
everything on which the target depends, and downstream prove-
nance, everything that depends on the target. If we view executionprovenance as a graph, ProvBuild collects upstream provenance
byselectingtheancestorsofthetargetandcapturesdownstream
provenancebyselectingthetarget‚Äôsdescendents.Whilemostprove-
nance systems avoid cycles in provenance graphs, noWorkflow al-
lowsthem,andtheyrequirespecialattention.Considertheoriginal
script(lines15‚Äì17)inFigure2.Assumethattheuserisinterested
in the derivation of the value of f. The provenance indicates that x
dependsonbothlines15and17.However,neithernoWorkflow‚Äôs
static nor dynamic analysis identify that it also depends on the
values of ithat occur in line 16.
ProvBuildperformsitsownloopanalysistoaddressthisomis-
sion. It creates upstream provenance for variables dependent upon
loop iterators. So, when ProvBuild constructs the ProvScript for the
exampleabove,itincludestheiterator iintheupstreamprovenance
off.
ProvBuild also uses the dynamically collected upstream and
downstreamprovenancetotrackimplicitdependencies.Consider
theoriginalscript(lines7‚Äì9).Function baztakes foo‚Äôsreturnvalues
aandbasparameters.Thismeansthat cdependson fooimplicitly
andbazexplicitly.Thus,changing bazrequiresrerunningonlyline
9anditsdownstream,whilechanging foorequiresrerunningall
threelinesandtheirdownstream.ProvBuildincludesallimplicit
function and variable relationship in the ProvScript.
Validity.Considering only deterministic programs, let Mbe the
point of the first modification. Assuming that noWorkflow cap-tures all dependencies, the ProvScript reproduces the state from
the original execution prior to M. Consider the two cases concern-
ingprovenancethatdependson M:1)Dependenciesthatexisted
in the original execution are, by definition, carried over into the
ProvScript ; 2) Dependencies that did not appear in the original exe-
cution,mustbetheresultofaconditionalexpressionintheoriginal
script; the ProvScript incorporates all clauses for every such con-
ditionalencountered.ProvBuildconstructsthetransitiveclosureof the dependencies in the program, ensuring that the resulting
ProvScript is correct.
3.4 Script Merging
Userscan editthesimpler ProvScript directly,and ProvBuildauto-
matically merges those changes back into the original script. After
merging, future ProvScript s are based on the new, merged version
of the file.
Tomergesuccessfully,ProvBuildmaintainsarecordofthediffer-
ences between the original script and the ProvScript. We annotate
eachlineinthe ProvScript withcommentsthatexplicitlymapthe
linetoitscorrespondinglineintheoriginalfile.Forexample,inthefollowing ProvScript, ProvBuild adds comments beginning with the
special ##### token, since the definition of function bazand the
assignmentsofvariable zinlines5,7,8and9areinheritedfrom
the original script. The assignments in lines 1‚Äì4 are inserted by
ProvBuild, not the user, so they are not marked.
# ProvScript (After user edits)
[1] a = 10[2] b = 20[3] d = 3[4] f = 204[5] def baz(var1,var2): #####L5
1089Figure 3: The ProvBuild interface features four boxes. We
assumethatalluserscriptswritetoanoutputfile.Theblueboxdisplaysthecontentsofthisoutputfile.Theyellowboxdisplays the original script for user reference and the blackbox displays the ProvScript. The grey box displays termi-
nal output, such as errors and print statements. The side-bar on the left provides easy access to the user commands.In ProvBuild mode, the user specifies the target, either afunction or variable, to change/debbug. After editing theProvScript,theuserrunsit,andexaminestheoutput.Whenthe user is satisfied with the output, the user merges thechangesintotheoriginalscript.Atthispoint,theyellowboxupdatestocontaintherevisedscript;theusercanthenselectanother object to edit.
[6] var1 = var1 + 1
[7] return var1+var2 #####L6[8] c = baz(a,b) #####L9[9] #####L15
New lines in the ProvScript (e.g., line 6), contain no added markers,
while deleted lines (e.g., line 9) appear as a line with the marker
ofthedeletedline,butnocode.Theinformationprovidedbythe
markers enables ProvBuild to correctly merge changes into the
original script.
Thesecommentcharactersareincidentaltoourprototype.We
used them to avoid making changes to the underlying editor. A
realdeploymentwouldimplementtrackingintheeditor,making
it invisible to the user. There are standard techniques for such
tracking [31, 35].
3.5 Interface Design
Our interface allows users to debug functions or variables on a
simplified version of an original script and seamlessly merge those
modifications back into the original script. To facilitate evaluation,
the ProvBuild prototype interface supports both conventional edit-
ing(i.e.,editingontheentirescript)andtheProvBuildprovenance-
driven editing of a ProvScript. In either case, the user begins by
selectingthe modeof interaction(conventional orProvBuild)and
identifyingthescriptwithwhichtheyareworking.InProvBuild
mode, the interface activates the provenance tracking backend.ProvBuildisdesignedtoabstracttheprovenance-drivenincre-
mental build process away from the user. Users interact with their
scripts through the three main modules shown in Figure 3. Each
module is explained in more detail below.
‚Ä¢Search:Theuserinputsthenameofthefunctionorvariable
to edit (see (1) in Figure 3). ProvBuild extracts the object‚Äôs
dependenciesbasedonthestoredprovenanceinformation
andgenerates a ProvScript containingonly codepertaining
to the chosen object.
‚Ä¢Execute:Insteadofrunningtheoriginalscript,ProvBuild
executes the shortened ProvScript for the user (see (2) in
Figure 3). This reduces run time.
‚Ä¢Merge: ProvBuild allows users to easily merge edits from
theProvScript into the original file (see (3) in Figure 3).
When used in conventional mode, the interface is similar to
common modern text editors. Users simply edit their scripts and
re-execute them in their entirety.
4 RESEARCH QUESTIONS
WeconductedthreestudiestoevaluateProvBuild‚Äôsperformance,
effectiveness, and usability. Our goal is to answer the following
four research questions (RQ):
‚Ä¢RQ1:HowwellcanProvBuildimprovedebuggingefficiency
in basic programming tasks?
‚Ä¢RQ2:How much overhead does noWorkflow introduce dur-
ing initial script execution?
‚Ä¢RQ3:How much speedup does ProvBuild produce when
re-executing a script after a modification?
‚Ä¢RQ4:Inreal-worldsettings,howdodatascientistsuseProv-
Buildin theirdaily work,and whatbenefitsand challengesdo they experience?
We address RQ1 using the results of a controlled experiment in-
volving a lab setting with scripts constructed specifically for the
experiment. We address RQ2 and RQ3 using quantitative measures
of ProvBuild runtime and overhead. We conducted another user
studyinvolvingdatascientistsusingProvBuildontheirownanaly-
sis scripts in the wild to answer RQ4.
5 STUDY 1: CONTROLLED LABORATORY
EXPERIMENT
To answer RQ1, we conducted a controlled lab study to quantify
ProvBuild‚Äôs ability to reduce the time to complete a task and to
obtain empirical insights into real-world challenges. We asked par-
ticipantsto performaseries ofdebuggingtasks withandwithout
ProvBuildandevaluatedtheirbehaviorbothqualitativelyandquan-titatively.Thestudydesignwasdrivenbythefollowinghypotheses:
‚Ä¢Hypothesis1:ProvBuildwilldecreasetaskcompletiontime.
Since the ProvScript is shorter than the original file
and its re-execution time is shorter, users will complete the
tasks more quickly.
‚Ä¢Hypothesis2:ProvBuildwilldecreaseusers‚Äôcognitiveload.
Cognitiveloadisthetotalamountofworkingmemory
resources being used. Because ProvBuild removes irrelevant
1090Average Task Completion Time
Task DiÔ¨ÉcultyEasy HardCompletion Time (seconds)
0100200300400500296359383487 Programming Tool
ProvBuild
Conventional
Figure 4: Average task completion time for easy and hard
tasks sorted by tool.
code,reasoningaboutcodein ProvScript willbelesstaxing
for users.
‚Ä¢Hypothesis3:Participantswillshowmorepositivesub-jectiveresponseswhenprogrammingwithProvBuild.
Participants will report that their experience is better when
using ProvBuild than when using a standard code editor.
5.1 Participants and Apparatus
We used snowball sampling [ 21] to recruit participants from multi-
plefieldsincludingcomputerscience,electricalengineering,appliedphysics,andappliedmathematics.21volunteersparticipatedinthestudy(14men,7women;21
‚àí28yearsold, M=24.3,2undergradu-
atestudents,11graduatestudents,8professionaldatascientists).
All had some experience programming in Python and had worked
on at least one data analysis project.
We conducted alltrials inthe same roomusing a MacbookPro
laptop running macOS. The ProvBuild interface ran in the Google
Chrome browser.
5.2 Procedure
Eachexperimentstartedwithabasicdemographicandtechnical
background survey. Next, participants were given instructionson
howtoeditineachmode(ProvBuildandConventionalmode).They
then engaged in one practice round with each tool. The practice
tasks were similar to the tasks given during the main study and let
the participants familiarize themselves with the interface.
Finally, each participant completed a series of four debugging
tasks.Thesetasksweremodeledaftercommondataanalysisproce-
dures. For each task, participants were asked to minimally modify
ascripttoagetspecifieddesiredoutput.Thetaskconditionscon-
sistedofprogrammingmodes(ProvBuildandConventional)and
difficulty levels (Easy and Hard). We designed the two difficulty
levels of tasks and validated their difficulties (Q9) in the user study
(Section 5.4.1). Easy tasks about math calculation and matrix trans-
formation contained fewer than 100 lines of code; hard tasks about
model training and parameter tuning contained nearly 300 lines of
code.Thetaskorderingswerecounterbalancedbothintheorder
of programming mode and difficulty level.
Participants were given ten minutes to complete each task, with
instructions to complete each task as quickly and accurately aspossible. We timed each task from the moment the participantAverage Cognitive Load Test Accuracy
Task DiÔ¨ÉcultyEasy HardAccuracy (%)
0102030405060708075
59.160.9
50.5Programming Tool
ProvBuild
Conventional
Figure 5: Average cognitive load test accuracy for easy and
hard tasks sorted by tool.
began reading the script to the moment she verbally expressedcompletion. Most participants completed each task comfortably
within the time limit. If the participant was unable to complete the
taskwithinthe10minutelimit,werecordedtheresultasunfinished.
IntheProvBuildprogrammingmode,participantshadtheoption
to identify functions or variables they wanted to modify therebygenerating a ProvScript as shown in Figure 3. After generating a
ProvScript, participants could modify and execute that ProvScript
insteadofworkingwiththeoriginalscript.Afterparticipantsob-
tained the desired output, they triggered the merge module tointegrate changes from the ProvScript back into the original file.
In the Conventional programming mode participants edited the
original script using a text editor and checked results by executing
the whole script.
To evaluate cognitive load, we examined their digital memo-
rization behaviors [ 14,55] in each task: we asked participants to
memorize ten random numbers in one minute before each task.
Upontaskcompletion,participantswereaskedtorecallthenum-
bers. If participants were able to recall more numbers, this was
indicativeoflightercognitiveloadduringtaskcompletion.After
completing each task, the participants were given a final question-
naireaskingthemtorespondona7-pointLikertscale.Thefirstsix
questions were the NASA-TLX standard questions, which evaluate
perceivedworkload[ 25,26]andprovidesubjectiveratingsalong
sixsubscales:MentalDemands,PhysicalDemands,TemporalDe-
mands, Own Performance, Effort Level and Frustration Level [ 24].
The remaining three questions evaluated the user‚Äôs perceived self-
efficacy and subjective assessment of ease of use and effectiveness.
Attheendoftheexperiment,participantswereaskedwhetherthey
had any feedback concerning ProvBuild. Each participant spent
approximately 60 minutes completing the experiment.
5.3 Data Analysis
Thiswasawithin-subjectsstudywithtwofactors:taskdifficulty
{easy, hard}, and programming tool {Conventional, ProvBuild} and
the following measures:
‚Ä¢Completiontime. We measured the completion time from
themomenttheystartedreadingthescripttothemoment
they declared that they were done. For participants who
1091Table 1: Summary of the results. ProvBuild and Conventional columns represent the average experiment results under both
taskdifficultyinthecorrespondingeditingmodes.Allninesubjectivemeasureswerereportedona7-pointLikertscale,while
self-reported preference is reported as the sum of nine responses; lower indicating higher preference. We used the Holm‚Äôssequentially-rejective Bonferroni procedure since we tested multiple simultaneous hypotheses. We report both raw and ad-justed p-values. Statistically significant results are marked with an asterisk.
Hypothesis ProvBuild Conventional Raw p-values Adjusted p-values Sig.?
H1 Completion time 339.70s 423.18s <0.0001 <0.0003 *
H2 Accuracy on cognitive load test 68.09% 54.79% = 0.0007 = 0.0014 *H3 Self-reported preference 25.98 30.05 = 0.0131 = 0.0131 *
Table2:DetailedsubjectiveresultsoftheNASA-TLXstandardquestionsandsubjectiveassessmentquestions.Theanswerwere
rated on a 7-point Likert scale. ‚àómeans the main effect for tools is statistically significant ( p<0.05)
Questions ProvBuild Conventional p-values Sig.?
1. How much mental and perceptual activity was required? (1 = low, 7 = high) 3.81 4.34 0 .0237 *
2. How much physical activity was required? (1 = low, 7 = high) 1.84 1.78 0 .6849
3. How much time pressure did you feel due to the pace at which the tasks
or task elements occurred? (1 = low, 7 = high)3.09 3.66 0 .0482 *
4. How successful were you in performing the task?
How satisfied were you with your performance? (1 = low, 7 = high)6.00 5.41 0 .0837
5. How hard did you have to work (mentally and physically)
to accomplish your level of performance? (1 = easy, 7 = hard)3.52 3.96 0 .1049
6. How irritated, stressed, and annoyed versus content, relaxed,
and complacent did you feel during the task? (1 = relaxed, 7 = stressed)3.22 3.66 0 .0798
7. How confident were you about your answer(s)? (1 = low, 7 = high) 6.07 5.59 0 .2308
8. How hard (irritating) was it to use the tool? (1 = easy, 7 = hard) 2.88 3.96 0 .0101 *
9. How hard was it for you to accomplish this task? (1 = easy, 7 = hard) 3.41 3.91 0 .1003
were unable to complete the task within the 10 minute time
limit, we recorded their time as 10 minutes1.
‚Ä¢Accuracyoncognitiveloadtest. Weaskedparticipantsto
memorizetenrandomnumbersandrecallthenumbersafter
each task. We interpreted recall accuracy as a measure of
cognitiveload(morenumbersrecalledcorrectlyindicating
lighter cognitive load).
‚Ä¢Self-reported subjective measures. After each task, we
askedparticipantssixquestionsrelatingtotheirperceived
workload and three subjective assessment questions. We
computed the sum of all nine subjective responses with
the same response order (lower indicates better) as the self-
reported subjective measure (two items were reverse coded
foranalysissuchthatlowernumberalwaysindicatedamore
positive response).
To guard against Type I errors due to multiple hypotheses being
tested, we applied the Holm‚Äôs sequentially-rejective Bonferroni
procedure [ 27,47] to the analyses, which introduces fewer Type II
errors than the more common simple Bonferroni correction. We
report both raw and adjusted p-values.
Duringevaluation,wefirstsummedallninesubjectiveresponses
to assess whether participants had an overall preference for either
1BecausemoreparticipantsfailedtofinishintimeusingConventionalmoderather
than ProvBuild mode, trimming the completion time to 10 minutes for incomplete
tasks did not unfairly advantage ProvBuild during analysis.mode (two items were reverse coded for analysis). We then con-
ducted a statistical analysis of each question separately.
5.4 Study Results
5.4.1 Main Analyses. The main results are summarized in Table 1.
Everyonewhocompletedataskintheallotted10minutesdidso
correctly.However,1ofthe21participantsdidnotfinishaneasy
task with either programming tool. 3 of the 21 participants did not
finish a hard task with the Conventional mode while only one did
not finish with ProvBuild.
We validated task difficulty to ensure that the Provbuild and
Conventionaltaskswerecomparable(Q9):thereisnosignificant
difficultydifferencebetweenthetwoeasytasks(averageddifficulty
rating 3.23 on a 7-point Likert scale, F(1,20)=0.5333, p=0.4737)
and two hard tasks (averaged difficulty rating 4.07 on a 7-point
Likert scale, F(1,20)=2.3343, p=0.1422), respectively.
As shown in Figure 4, participants had statistically significant
shorter average completion time ( F(1,20)=66.64, raw p<0.0001,
adjusted p<0.0003) using ProvBuild ( M=339.70 seconds) than
using the Conventional mode ( M=423.18 seconds). Hypothesis 1
was supported. ProvBuild decreased average task completion time
and significantly improved programming efficiency in both task
difficulty levels.
Participantshadgreaternumberrecallaccuracyafterprogram-
ming with ProvBuild ( M=68.09%) than after using the Conven-
tional mode ( M=54.79%) as shown in Figure 5. This main effect
1092was statistically significant ( F(1,20)=16.00, raw p=0.0007, ad-
justed p=0.0014).TheseresultssupportHypothesis2andindicate
thatProvBuildwasabletolightencognitiveload.Inotherwords,
ProvBuild is less taxing on the user‚Äôs mental resources.
Participants also reported being more satisfied overall after pro-
gramming with ProvBuild ( M=25.97, lower is better) than with
theConventionalmode( M=30.05).Thedifferencewasstatistically
significant ( F(1,20)=7.42, raw p=0.0131, adjusted p=0.0131).
Hypothesis3wassupportedbyoursubjectivedataanalysis:par-
ticipants overall preferred ProvBuild over conventional processing
methods.
Also, those who preferred Conventional mode commonly stated
theirpreferencewasduetothefactthattheyweremorefamiliar
withtheConventionalprogrammingmethodthanwithProvBuild.5
ofthe21participantsindicatedthattheyfeltitwasmoreconvenient
to program with ProvBuild in the latter tasks as they became more
familiar with the interface.
5.4.2 Additional Analyses. Table 2 presents the detailed subjective
results. These self-reported results demonstrate that the partici-
pants experienced significantly less mental effort (Q1, F(1,20)=
3.3727, p=0.0237)andfeltlesstimepressure(Q3, F(1,20)=4.4268,
p=0.0482) when using ProvBuild. Participants also felt that the
tasksweresignificantlyeasierandlessirritatingtouseProvBuild
than the Conventional interface (Q8, F(1,20)=8.0769, p=0.0101).
When using ProvBuild, participants also experienced relatively
lowerlevelsofirritationregardingthecodingtask(Q6, F(1,20)=
3.4069, p=0.0798)andhigherlevelsofperceivedsuccessintask
completion (Q4, F(1,20)=3.3140, p=0.0837). These differences
are marginally significant ( p<0.10).
6 STUDY 2: PERFORMANCE EVALUATION
Toanswerourperformance-relatedresearchquestions(RQ2and
RQ3),weranbenchmarksonaUbuntu18.04LTScomputerwith
Corei53.5GHzCPUs16GBofmemory,runningwithPython2.7andSQLite3.15(noWorkflow‚Äôsstorageengine).noWorkflowintroduces
three sources of overhead. It‚Äôs possible that a different provenance
capturemechanismwouldproduceloweroverheads,butanalysisofdifferentcapturemechanismsisoutsidethescopeofthisstudy.First,noWorkflowinitializesitsdatastoragepriortoscriptexecutioninapreprocessingstep.Second,duringinitialscriptexecutionforwhich
we collect provenance, noWorkflow‚Äôs dynamic analysis introduces
overhead.Third,noWorkflowwrites itsprovenance datatoaSQLite
database during execution; SQLite is not a terribly performant
database.WereporttheseoverheadsinTable3.Notethatweran
an unmodifiedversion of noWorkflow in thisstudy. As ProvBuild
does not depend on all the functionality of noWorkflow, it‚Äôs likely
thatastreamlinedimplementationofnoWorkflowcouldreducethe
overhead.
6.1 Initialization Slowdown
ToquantifyProvBuild‚Äôsoverhead(RQ1),wecollectedPythonscripts
frompublishedworkandcomparedscriptlengthandrunningtimes
with and without ProvBuild. Dataverse is a platform for publishing
datasetsusedinresearchpublications[ 29].Weuseditsprogram-
maticAPI[ 38]toobtainreal-worldPythonscripts.WequeriedHar-
vard University‚Äôs public Dataverse instance [ 39] for every archiveddata set containing Python scripts. We then downloaded the 92published data sets including Python code. Unfortunately, manyof the archived data sets were missing key files. Only 54 of the
92 containedboth scriptsand theaccompanyingdata. Ofthose 54
scripts, only eleven ran to completion as published.
Table3showsthebreakdowninrunningtime.Executiontime
increasesdramatically,inthebestcase,byonly56%,butintheworstcasebyaroundafactorof30.ThemajorityofthisoverheadisduetonoWorkflow‚Äôsdynamicprovenancetracking.Writingprovenanceto
the database also adds significant overhead (column Storage Time).
Otherprovenancetrackingsolutions[ 34]keepprovenanceinmain
memory and write it persistently after execution; this approach
seemsattractive.AswewillseeinSection7,usersdidvoiceconcernovertheinitialruntime,butnotenoughtopreventthemfromusing
ProvBuild.
6.2 DebuggingSpeedup
To demonstrate how ProvBuild can ultimately increase develop-
ment efficiency (RQ2), we measured ProvBuild‚Äôs performance after
makingthreetypesofchangestoeachoftheelevenscriptsfrom
Table 3. A Class Achange directly alters script output, e.g., chang-
ingtheformatoftheoutput.A ClassBchangealtersaninputfile
or input variable. A Class Cchange modifies the parameter of a
functioninthescript,e.g.,changingthevalueofamodelparameter.
For those eleven scripts, we randomly selected one of each type of
change and measured how long it took to execute the ProvScript
produced by ProvBuild.
The speedup inherently depends on the length of the code path
following the edit. As Class Achanges affect only the output stage
of analysis, ProvBuild often generates significantly shorter scripts
and produces significant speedup. For our eleven scripts, these
speedupsrangedfromafactorof1.78to39.31(i.e.,the ProvScript
ranalmost40timesfasterthanthefullscript).Table3showsthat
theProvScript sgeneratedfrom ClassAchangeshad74%fewerlines
of code, on average. Class BandClass Cchanges induce smaller
speedups.Theresulting ProvScript sretained,onaverage,77%and
58% of the lines of the original script, resp ectively, while the speed-
ups averaged 1.23X and 2.46X, respectively. ProvBuild explores
the dependencies downstream of the edits. Speed-ups are smaller,
becauseProvBuildmustretainallthedownstreamdependencies;
theearlierinthescriptamodificationismade,themoreofthescript
mustberetainedforre-execution,producinglongerre-execution
times. Even in the worst case (Class B ), we attain some speedup.
Inallthreeclasses,ProvBuildisabletousestoredprovenanceto
shorten run time.
7 STUDY 3: DEPLOYMENT IN THE WILD
We conducted another user study to evaluate ProvBuild‚Äôs useful-
ness(RQ4)andefficacyfordatascientistsfromdifferentdomains.
The study was a real-world deployment of the system in which
participants could choose when and how to use the tool. We ranthis field study to see if participants would choose ProvBuild inreal scenarios in place of other tools available to them. We used
surveys to obtain feedback from participants. Participants received
noincentivetouseProvBuild;feedbackwassolicitedonlyaftertheyusedit.Weapproachedthe21participantsfromthepriorstudy,and
1093Table3:ComparisonofrunningtimesandlinesofcodeofdataanalysisscriptexecutedwithoutProvBuildandwithit,averaged
over 5 runs (variances negligible)
Script
#LOCOriginal
Exec timeRuntimes w/ noWorkflow Class A Class B Class C
Pre-
processingExec
timeStorage
timeLOCRe-exec time
(Speedup)LOCRe-exec time
(Speedup)LOCRe-exec time
(Speedup)
1 137 0.19 11.12 1.57 1.06 13 0.03 ( 6.33x) 123 0.12 (1.58x) 90 0.07 (2.71x)
2 121 2.68 6.92 4.18 3.69 33 1.08 ( 2.48x) 110 2.10 (1.28x) 68 1.32 (2.03x)
3 57 4.42 15.14 124.03 6.24 12 1.05 ( 4.24x) 20 4.01 (1.10x) 16 2.00 (2.21x)
4 61 6.29 8.72 97.26 326.85 10 0.16 (39.31x) 29 5.81 (1.08x) 28 3.65 (1.72x)
5 543 7.25 14.06 14.64 5.88 72 1.43 ( 5.07x) 486 5.29 (1.37x) 182 2.15 (3.37x)
6 51 20.15 2.87 337.97 1520.11 26 11.30 ( 1.78x) 40 17.73 (1.14x) 37 13.21 (1.53x)
7 230 69.61 11.32 1540.81 2023.65 40 22.91 ( 3.04x) 178 60.47 (1.15x) 106 42.30 (1.64x)
8 854 78.73 63.47 298.88 39.45 76 14.24 ( 5.53x) 783 63.99 (1.23x) 576 33.40 (2.36x)
9 222 81.00 22.98 1917.23 3815.01 26 6.41 (12.64x) 184 67.30 (1.20x) 163 13.95 (5.81x)
10 102 129.12 1.89 4017.26 2914.30 92 56.61 ( 2.28x) 97 103.46 (1.25x) 94 82.04 (1.57x)
11 175 140.71 2.22 2835.34 2109.23 41 13.10 (10.74x) 127 118.35 (1.19x) 92 68.24 (2.06x)
12ofthem(8men,4women)agreedtoparticipateinthisstudy.The
detailsofthestudywererevealedonlyonceaparticipantagreedto
participate.
7.1 Procedure and Data Analysis
WegaveparticipantsaccesstoProvBuildforoneweek.Thisallowed
themtoexploreandusethetoolforPythondebuggingintheirdaily
work.Weintentionallygaveparticipantscompletelatitudeabout
when they used ProvBuild. At the end of each day, we asked the
followingsurveyquestionstounderstandifandhowparticipants
chosetouseProvBuild:(1)DidyouuseProvBuildtoday?Ifso,what
wereyoutryingtoaccomplishedbyusingit?(2)Whenyouused
ProvBuild,whatdidyoulikeaboutit?(3)Didyouhaveanyproblems
usingProvBuild?Ifso,pleasedescribethem.(4)AreyouinclinedtouseProvBuildagain?Why?(5)WouldyourecommendProvBuildto
others, why? These five questions were all free-response questions
withnocharacterlimitrequirement.Weaskedthemdailyandonly
requiredthemtoansweronthedaysthattheyhadchosentouse
ProvBuild.
Toanalyzethecollecteddata,weutilizedqualitativedataanal-
ysis methods [ 22] and performed the iterative inductive analysis
[12]. Two researchers first independently clustered the data and
opencodedthedatasetintothemes.Themesincludedcommonly
mentioned benefits and common challenges. Next, the researchers
collaborativelyreviewedthedata,comparedcodes,identifiedemer-
gent themes and discussed discrepancies to develop a mutuallyagreed upon set of themes. They then performed an additional
roundofindependentcodingandverifiedtheemergentthemesand
associated transcript segments.
7.2 Study Results
In this study, we collected 18 surveys from 12 participants. Allparticipants chose to use ProvBuild at least once, while four par-ticipants used it more than once in a one-week period. 11 out of
12participantsindicatedthattheywoulduseProvBuildinthefu-
ture (Q4). Participants reported a large number of programmingscenarios in which they used ProvBuild in their daily work. Onecommonsituationwasscriptdebuggingandparametertuning.Par-
ticipants used ProvBuild to debug ‚Äúsimple Python scripts‚Äù (P12) and
multiplescriptswith ‚Äúcomplicateddependencies‚Äù(P1),or ‚Äúfinelytune
parameters in code‚Äù (P9). Several participants focused more on writ-
ingscriptsformodeltraining,whilesomewereworkingonmath
calculations in Python.
7.2.1 ProvBuild Benefits. Participantsmentionedtendifferentben-
efits of using ProvBuild. The most frequent benefits, mentionedby nine participants, were that ProvBuild
saved programming
timeandallowedusersto findcodedependenciesmoreeasily :
‚ÄúIt helps find all the dependent code pieces when you target a spe-
cificproblem,whichgreatlysavestimeandreduceserrors.‚Äù(P1) ‚ÄúIt
explicitly tells me the dependence of certain functions and data. Itrunsreallyfast.‚Äù(P3) ‚ÄúItspeedsupcalculationsbystoringfiledata
withinthecode.‚Äù(P11) Anotherrespondentsreported ‚Äúitreallysaves
programming time (both execution time and thinking time)‚Äù (P8).
ProvBuild isalso consideredparticularly beneficialfor under-
standingprojectworkflow ,mentionedbysixparticipants: ‚ÄúIlike
thatitcutdownontheamountofcodeIhavetolearnandunderstand.‚Äù
(P9) ‚ÄúIt can provide the part that I want to rerun, so I don‚Äôt need to do
thewholepreprocessingeverytime.‚Äù(P2) ‚ÄúItwouldhelpwithcomplex
programming workflow.‚Äù (P7)
ProvBuild reduces the need for memorization of the details
in a workflow by providing shortened scripts, which makes pro-
gramminganddebuggingeasier.Fiveparticipantsmentionedthis
benefit,whichalsosupportsHypothesis2fromSection5,inreal-
worldstudies: ‚ÄúIlovethisbecauseitcankeeptherecordsoftheold
files and I don‚Äôt need to remember the workflow of all my programs.
The only thing I need to decide is which part of the program needs to
be changed.‚Äù (P6)
Another common benefit mentioned by seven participants is its
usefulness .It‚Äúsimplifies‚Äù(P4) thedebuggingprocessand ‚Äúshortens‚Äù
(P2)programscripts: ‚ÄúIt‚Äôsreallyeasytomakechangesinoldscriptsin
ordertomatchnewmodels.‚Äù(P6)‚ÄúIthinkit‚Äôsusefultodebugprograms
with complicated steps.‚Äù (P4)
ThreeparticipantsexplicitlymentionedthatProvBuild provides
intermediate results to facilitate programming process: ‚ÄúWhen
1094I do math in Python, I often need to print all variables to find the
problemandIforgettodothatsometimes.WithProvBuild,Icancheck
thoseconstantsineverystepanditreallyhelps‚Äù(P8) ‚ÄúIliketheidea
of considering the intermediate results as constants. Most of the time,
I only care about the follow-up calculation after those values.‚Äù (P4)
Overall, participants expressed a preference for using ProvBuild
and mentioned that ProvBuild improves the debugging process
mainlybyreducingprogrammingtime,allowinguserstofindde-
pendenciesandunderstandtheirworkflowmoreeasily,reducing
theneedformemorization.Participantsdonotreportanysignifi-
cant barriers to independent use.
7.2.2 ProvBuild Challenges. Participantsalsoraisedseveralcon-
cerns after their use with ProvBuild. The predominant concern
stated by five participants was the slow initial run time relative
to running without ProvBuild: ‚ÄúThe initial execution with ProvBuild
takes longer than I expected, especially when the training files are
large.However,onceIfinishthefirstrun,itultimatelysavestime.I
would like to continue to use ProvBuild for future debugging.‚Äù (P2) ‚ÄúI
found that the initialization of ProvBuild takes a bit longer. I guess it
needs to trace everything and keep the records.‚Äù (P7)
WhileProvBuildwasabletogenerateanewsimplifiedscript,two
participantswereconcernedaboutits ‚Äúaccuracy‚Äù(P2) andcomplete-
ness:‚ÄúProvBuildmayhavelimitationintrackingthe provenanceof
programexecution,whichmayreturnanincompleterelevantcodeseg-
ment.‚Äù(P12) Althoughsomeparticipantsexpressedconcernabout
the validity of ProvBuild, no one in this study obtained incomplete
or incorrect results.
Two participants explicitly mentioned that ProvBuild should
supportmultipletypesofsearchtargets :‚ÄúIcouldn‚Äôtsearchfora
variablethatwasafunctionargument.‚Äù(P10)‚ÄúItseemslikeProvBuild
can only search for global variables.‚Äù (P2)
Further concerns about ProvBuild are its scalability ‚Äúto process
a large project.‚Äù (P5) and‚Äúmemory usage‚Äù(P6).
Finally, since the participants have their own programming
styles, one of them asked ‚Äúis it possible to show some visualiza-
tionfromProvBuild?‚Äù(P3),whileanotherwonderedthat ‚Äúitwould
be better if it works with Jupyter.‚Äù (P4)
Overall,wefoundthesecriticismsencouraginginthattheyad-
dressedissuesweknewabout(e.g.,initialruntime)orthatcouldbe
easily addressed (e.g., integration with Jupyter). Convincing users
that ProvBuild produces correctresults is an interesting challenge
to address in future work.
8 DISCUSSION
ProvBuild allows data scientists to perform basic data analysis
routinewithlowercompletiontimeandlesscognitiveload,thereby
increasing their programming efficiency. Although its provenance
capture system increases initial runtime, participants found thecost-benefit trade-off worthwhile, demonstrating that its utility
compensated for the increased initial runtime.
Threats to Validity. Regarding internal validity, user perfor-
mance on the controlled experiments might depend on a user‚Äôs
ability to comprehend unfamiliar code. To mitigate this threat, we
didwithin-subjectexperimentstestingeachparticipantunderall
conditions;theindependentevaluationreduceserrorsassociated
with individual differences. A remaining challenge is to design astudy that is rigorously controlled, but allows users to work on
code with which they are already familiar.
Participants of the deployment study may have been inclined
to answerfavorably,since we wereasking about theirexperience
using ProvBuild. To reduce such bias, we used impersonal surveys,
rather than face-to-face interviews.
The greatest external threat to validity is our assumption that
noWorkflow captures provenance correctly. Its use in reproduction
studiessuggeststhatthecommunitybelievesittobeappropriateforreproducingcomputation,whichiseffectivelyhowweuseit[
17,37].
It is also possible that we have not identified all instances in which
theprovenancedoesnotcapturealltheinformationnecessaryto
produceacompleteandcorrect ProvScript.Shouldsuchsituations
arise, our experience suggests that the tools we‚Äôve developed make
it possible to easily collect additional information.
LimitationandFutureWork. ProvBuild‚Äôsinitialruntimeover-
headmightposeanobstacletoadoption,soourimmediateplans
includingchangingorimprovingtheprovenancecollectionstrategy,
disabling parts of the provenance capture that are unnecessary for
thisapplication,andtuningtheremainingpartsofit.RDataTracker-
lite is an R tool similar to noWorkflow [ 34], which showed that
capturingonlythedetailneededforProvBuildreducesoverheadbyroughly50%.Integrationwithawidely-usedIDE,suchasEclipse,orotherinteractivecomputationalenvironments,suchasJupyter[
30],
willalsofacilitateadoption.WhileProvBuildiscurrentlyPython-
specific, it relies only on the provenance output and the abilityto parse the input source code. It should be straight forward toadapt it to other languages that have provenance-tracking sup-
port,e.g.,R[ 34].Wealsobelieveitispossiblefortheselanguage-
specificcapturetoolstoproduceprovenanceinalanguage-agnosticform,whichwouldmakeitpossibletodevelopalanguage-agnostic
ProvBuild. In the longer term, we are looking for other opportuni-
tiestoleverageprovenancetohelpprogrammersstreamlinetheir
development process.
Data Availability. ProvBuild is available on the open-access
repository Zenodo[28].
9 RELATED WORK
Make[15] is a build automation tool that uses static analysis to
execute only those steps of a build process that depend upon modi-
fications.Ratherthanusingprovenance, makeuses Makefile sto
explicitlykeeptrackoffiletargets,inter-filedependencies,andcom-mandsequences.Usersbuild
Makefile smanuallyoruseadditional
tools, e.g., autoconf [16,54], to produce them. makeis similar to
ProvBuild in its ability to reduce re-execution time. However, make
does not address the cognitive load issue nor does it help users
identify problems more efficiently.
StarFlow is a make-like tool that tracks data dependencies in
Pythonatfunction-callgranularity[ 3].Thedependencytracking
procedure for StarFlow uses static analysis, dynamic analysis, and
optionaluserannotationsforspecifyingfunctioninputsandout-
puts. ProvBuild extends this work by removing the need for anno-
tations to track dependencies. Like make, StarFlow does nothing to
reduce cognitive load.
IncPyisacustom,open-sourcePythoninterpreterthatperforms
automaticmemoizationandpersistentdependencymanagement
1095atthefunctioncalllevel.IncPyautomaticallysendsfunctioncalls,
inputs,andoutputstoapersistenton-diskcacheimmediatelybefore
the targetprogram isabout toreturn froma functioncall [23].By
automatically caching and reusing the results of function calls,
IncPyenablesprogrammerstoiteratemorequicklyontheirscripts,
in a manner similar to ProvBuild. We wanted to compare IncPy
re-execution times with those of ProvBuild; unfortunately IncPyhas not been maintained, and we were unable to get it to run on
modern Python scripts.
Similar to IncPy, Joblib is a dynamic analysis tool that transpar-
ently caches arbitrary Python objects to avoid unnecessary com-
putationin Python[ 53].IncPy andJoblibaresimilar toProvBuild
in the re-execution part, but they do not track dependencies other
than functional ones and also do not address cognitive load.
ProvBuild uses both static and dynamic change impact analy-
sis(CIA)[ 4].Generally,CIAidentifiesthepotentialconsequences
of a change and estimates how to propagate the ramifications of
that change. Static CIA analyzes the syntax, semantics, and change
histories of a program without directly executing it [ 43,50]. Dy-
namicchangeimpactanalysiscapturesinformationbyexecuting
programs on a real or virtual processor and utilizes dynamic infor-
mationaboutprogrambehaviortodeterminethepotentialeffects
ofachange[ 32,33,40,41].CIAhasbeenusedinlargeandevolving
industrial software systems [ 2] to evaluate test suites when a soft-
waresystemchanges[ 46],comparelargeprogramswithdifferent
versiontohighlightchanges[ 8],andanalyzechangepropagationin
largesoftwaresystemsandarchitectures[ 20].Professionalsoftware
engineers leverage CIA to estimate large software project changes.
Tothebestofourknowledge,ProvBuildisanovelapplicationof
CIA, using it to improve runtime and cognitive load during data
analysis development tasks.
Incrementalcompilationandself-adjustingcomputationaretech-
niquesthatattempttosavetimebyrecomputingonlythoseoutputs
that depend on changed data [ 1,11]. Most of these techniques rely
ondependencygraphsthatrecordacomputation‚Äôsdataandcontrol
dependencies so the change-propagation algorithm can identify
sectionsthatareaffectedbyausermodificationandrebuildonly
these relevant portions. The major result of change propagation is
to incrementally build the script. It is similar to our work, while
ProvBuildalsodirectlyimprovestheuserprogrammingexperience.
10 CONCLUSION
ProvBuild is a novel use of language-level provenance that stream-
lines the iterative development process by allowing a developer
tofocusonlyonthecodethattheprogrammerisdebugging.We
use provenance to construct a dependency graph and generate a
simplified script containing only those code blocks pertaining to a
user-specified function or variable. This accomplishes three things.
First,ithelpsusersavoidunnecessarychangestotheirscript(which
frequentlyintroducenewbugs[ 57]).Second,itmakesiteasierto
identify and reason about code modifications that are necessary to
correctlyachieveagoal.Third,itreducesexecutiontimeandusers‚Äô
cognitiveload, becauseonly aportionof theoriginal scriptisrun
ateachiteration.Together,thesereducethetimeandeffortittakes
to debug data analysis pipelines. The results of the quantitativeevaluation and the user feedback show that ProvBuild can be aneasy, effective, and efficient tool for data scientists who use scripts
toprocessandanalyzedata.Tothebestofourknowledge,thisis
thefirsttimelanguage-levelprovenancehasbeenusedtoaddress
programmer efficiency.
ACKNOWLEDGMENTS
Thank you to Elisa Baniassad and Claire LeGoues for providing
extraordinarily useful feedback and advice on earlier versions of
this work. We also thank the anonymous reviewers for their usefulfeedback,whichgreatlyimprovedthispaper.Thisresearchwassup-
ported by NSF award #1450277 and the U.S. Air Force and DARPA
under contract FA8750-16-C-0045. We acknowledge the support of
the Natural Sciences and Engineering Research Council of Canada
(NSERC).Cetterecherchea√©t√©financ√©eparleConseilderecherches
en sciences naturelles et en g√©nie du Canada (CRSNG).
REFERENCES
[1]UmutA.Acar.2009. Self-adjustingComputation:(anOverview).In Proceedingsof
the2009ACMSIGPLANWorkshoponPartialEvaluationandProgramManipulation
(PEPM ‚Äô09). ACM, New York, NY, USA, 1‚Äì6. https://doi.org/10.1145/1480945.
1480946
[2]MithunAcharyaandBrianRobinson.2011. PracticalChangeImpactAnalysis
BasedonStatic ProgramSlicingforIndustrialSoftwareSystems. In Proceedings
ofthe33rdInternationalConferenceonSoftwareEngineering (ICSE‚Äô11).ACM,New
York, NY, USA, 746‚Äì755. https://doi.org/10.1145/1985793.1985898
[3]Elaine Angelino, Daniel Yamins, and Margo Seltzer. 2010. StarFlow: A script-
centricdataanalysisenvironment.In Proceedingsofthe3rdInternationalProve-
nance and Annotation Workshop (IPAW 2010). Lecture Notes in Computer Science,
Vol. 6378. Springer Berlin Heidelberg, Troy, NY, USA, 236‚Äì250.
[4]RobertS.Arnold.1996. SoftwareChangeImpactAnalysis. IEEEComputerSociety
Press, Los Alamitos, CA, USA.
[5]Adam Bates, Dave (Jing) Tian, Kevin R.B. Butler, and Thomas Moyer. 2015.
TrustworthyWhole-SystemProvenancefortheLinuxKernel.In 24thUSENIX
Security Symposium (USENIX Security 15). USENIX Association, Washington,
D.C., 319‚Äì334. https://www.usenix.org/conference/usenixsecurity15/technical-
sessions/presentation/bates
[6]HughBeyerandKarenHoltzblatt.1997. ContextualDesign:DefiningCustomer-
Centered Systems. Morgan Kaufmann Publishers Inc., San Francisco, CA, USA.
[7]MichelleABorkin,ChelseaSYeh,MadelaineBoyd,PeterMacko,KZGajos,M
Seltzer,andHPfister.2013. Evaluationoffilesystemprovenancevisualization
tools.IEEE transactions on visualization and computer graphics 19, 12 (2013),
2476‚Äì2485.
[8]L.C. Briand,Y.Labiche, andL.O‚ÄôSullivan.2003. ImpactAnalysisandChange
ManagementofUMLModels.In ProceedingsoftheInternationalConferenceon
Software Maintenance (ICSM ‚Äô03). IEEE Computer Society, Washington, DC, USA,
256‚Äì.
[9]Peter Buneman, Sanjeev Khanna, and Wang-Chiew Tan. 2000. Data provenance:
Some basic issues. In FSTTCS 2000: International Conference on Foundations of
SoftwareTechnologyandTheoreticalComputerScience.SpringerBerlinHeidelberg,
Springer Berlin Heidelberg, Berlin, Heidelberg, 87‚Äì93.
[10]Peter Buneman, Sanjeev Khanna, and Wang Chiew Tan. 2001. Why and Where:
A Characterization of Data Provenance. In Proceedings of the 8th International
ConferenceonDatabaseTheory (ICDT‚Äô01).Springer-Verlag,Berlin,Heidelberg,
316‚Äì330.
[11]MagnusCarlsson.2002. MonadsforIncrementalComputing.In Proceedingsofthe
SeventhACMSIGPLANInternationalConferenceonFunctionalProgramming (ICFP
‚Äô02). ACM, New York, NY, USA, 26‚Äì35. https://doi.org/10.1145/581478.581482
[12]KathyCharmazandLindaLBelgrave.2012. Qualitativeinterviewingandgrounded
theory analysis. SAGE Publications Inc., 347‚Äì366. https://doi.org/10.4135/
9781452218403.n25
[13]JamesCheney,AmalAhmed,andUmuta.Acar.2011. ProvenanceAsDependency
Analysis. Mathematical. Structures in Comp. Sci. 21, 6 (Dec. 2011), 1301‚Äì1337.
https://doi.org/10.1017/S0960129511000211
[14]Cary Deck and Salar Jahedi. 2015. The effect of cognitive load on economic
decision making: A survey and new experiments. European Economic Review 78
(2015), 97‚Äì119. https://doi.org/10.1016/j.euroecorev.2015.05.004
[15] Stuart I Feldman. 1979. Make - A program for maintaining computer programs.
Software: Practice and experience 9, 4 (1979), 255‚Äì265.
[16] Inc.FreeSoftwareFoundation.2016. Autoconf. https://www.gnu.org/software/
autoconf/. Accessed Aug 16, 2019.
1096[17]JulianaFreireandFernandoChirigati.2018. ProvenanceandtheDifferentFlavors
of Reproducibility. IEEE Data Eng. Bull. 41, 1 (2018), 15‚Äì26.
[18]JulianaFreire,DavidKoop,EmanueleSantos,andCl√°udioTSilva.2008. Prove-
nance for computational tasks: A survey. Computing in Science & Engineering 10,
3 (2008), 11‚Äì21. https://doi.org/10.1109/MCSE.2008.79
[19]Boris Glavic, Gustavo Alonso, Ren√©e J. Miller, and Laura M. Haas. 2010. TRAMP:
Understanding the Behavior of Schema Mappings through Provenance. Proc.
VLDB Endow. 3, 1√¢ƒÇ≈û2 (Sept. 2010), 1314√¢ƒÇ≈û1325. https://doi.org/10.14778/
1920841.1921003
[20]Arda Goknil, Ivan Kurtev, and Klaas van den Berg. 2016. A Rule-Based Change
Impact Analysis Approach in Software Architecture for Requirements Changes.
CoRRabs/1608.02757 (2016). arXiv:1608.02757
[21]Leo AGoodman. 1961. Snowball sampling. TheAnnals ofMathematical Statistics
32, 1 (1961), 148‚Äì170. https://doi.org/10.1214/aoms/1177705148
[22]JaberFGubrium,JamesAHolstein,AmirBMarvasti,andKarynDMcKinney.
2012.The SAGE Handbook of Interview Research: The Complexity of the Craft.
SAGE Publications, Thousand Oaks, CA.
[23]PhilipJ.GuoandDawsonEngler.2011. UsingAutomaticPersistentMemoization
to Facilitate Data Analysis Scripting. In Proceedings of the 2011 International
Symposium on Software Testing and Analysis (ISSTA ‚Äô11). ACM, New York, NY,
USA, 287‚Äì297. https://doi.org/10.1145/2001420.2001455
[24]EijaHaapalainen,SeungJunKim,JodiF.Forlizzi,andAnindK.Dey.2010. Psycho-
physiological Measures for Assessing Cognitive Load. In Proceedings of the 12th
ACM International Conference on Ubiquitous Computing (UbiComp ‚Äô10). ACM,
New York, NY, USA, 301‚Äì310. https://doi.org/10.1145/1864349.1864395
[25]SandraGHart.2006. NASA-taskloadindex(NASA-TLX);20yearslater. Proceed-
ings of the Human Factors and Ergonomics Society Annual Meeting 50, 9 (2006),
904‚Äì908. https://doi.org/10.1177/154193120605000909
[26]Sandra G Hart and Lowell E Staveland. 1988. Development of NASA-TLX (Task
Load Index): Results of empirical and theoretical research. Human mental work-
load1, 3 (1988), 139‚Äì183.
[27]S. Holm. 1979. A simple sequentially rejective multiple test procedure. Scandina-
vian Journal of Statistics 6, 65-70 (1979), 1979.
[28]JingmeiHu.2020. CrystalMei/ProvBuild:ProvBuildCodeforICSE‚Äô20(2020.1.27).
https://doi.org/10.5281/zenodo.3628097
[29]Gary King. 2007. An Introduction to the Dataverse Network as an Infrastructure
for Data Sharing. Sociological Methods and Research 36 (2007). https://doi.org/10.
1177/0049124107306660
[30]Thomas Kluyver, Benjamin Ragan-Kelley, Fernando P√©rez, Brian E Granger,Matthias Bussonnier, Jonathan Frederic, KyleKelley, Jessica B Hamrick,Jason
Grout,SylvainCorlay,andetal.2016. JupyterNotebooks-apublishingformatforreproduciblecomputationalworkflows.In PositioningandPowerinAcademicPub-
lishing:Players,AgentsandAgendas,20thInternationalConferenceonElectronic
Publishing. IOS Press, G√∂ttingen, Germany, 87‚Äì90. https://doi.org/10.3233/978-
1-61499-649-1-87
[31]BW Lampson. 1976. Bravo Manual in the Alto User‚Äôs Handbook. Xerox Palo Alto
Research Center (1976).
[32]JamesLawandGreggRothermel.2003. Incrementaldynamicimpactanalysisfor
evolvingsoftwaresystems.In Proceedingsofthe14thInternationalSymposium
on Software Reliability Engineering, 2003. ISSRE 2003. IEEE Computer Society,
Denver, CO, USA, 430‚Äì441. https://doi.org/10.1109/ISSRE.2003.1251064
[33]James Law and Gregg Rothermel. 2003. Whole Program Path-Based Dynamic
Impact Analysis.In Proceedings ofthe 25thInternational Conference onSoftware
Engineering (ICSE ‚Äô03). IEEE Computer Society, Washington, DC, USA, 308‚Äì318.
[34]Barbara Lerner, Emery Boose, and Luis Perez. 2018. Using Introspection toCollect Provenance in R. Informatics 5, 1 (2018), 12. https://doi.org/10.3390/
informatics5010012
[35]Ian A. Macleod. 1977. Design and implementation of a display oriented text
editor.Software: Practice and Experience 7, 6 (1977), 771‚Äì778. https://doi.org/10.
1002/spe.4380070611
[36]Kiran-KumarMuniswamy-Reddy,DavidA.Holland,UriBraun,andMargoSeltzer.2006. Provenance-awareStorageSystems.In ProceedingsoftheAnnualConference
on USENIX ‚Äô06 Annual Technical Conference (ATEC ‚Äô06). USENIX Association,
Berkeley, CA, USA, 4‚Äì4.
[37]LeonardoMurta,VanessaBraganholo,FernandoChirigati,DavidKoop,andJu-
liana Freire. 2015. noWorkflow: Capturing and Analyzing Provenance of Scripts.
InProvenanceandAnnotationofDataandProcesses.SpringerInternationalPub-
lishing, Cham, 71‚Äì83.
[38]The President & Fellows of Harvard College. 2015. API Guide. http://guides.
dataverse.org/en/4.2/api/. Accessed Aug 7, 2018.
[39]The President & Fellows of Harvard College. 2017. Harvard Dataverse. https:
//dataverse.harvard.edu/. Accessed Aug 7, 2018.
[40]AlessandroOrso,TaweesupApiwattanapong,andMaryJeanHarrold.2003.Lever-agingFieldDataforImpactAnalysisandRegressionTesting.In Proceedingsofthe
9thEuropeanSoftwareEngineeringConferenceHeldJointlywith11thACMSIG-
SOFTInternationalSymposiumonFoundationsofSoftwareEngineering (ESEC/FSE-
11). ACM, New York, NY, USA, 128‚Äì137. https://doi.org/10.1145/940071.940089[41]Alessandro Orso, Taweesup Apiwattanapong, James Law, Gregg Rothermel, and
MaryJean Harrold.2004. AnEmpirical ComparisonofDynamic ImpactAnaly-
sis Algorithms. In Proceedings of the 26th International Conference on Software
Engineering (ICSE ‚Äô04). IEEE Computer Society, Washington, DC, USA, 491‚Äì500.
[42]Thomas Pasquier, Xueyuan Han, Mark Goldstein, Thomas Moyer, David Ey-
ers,MargoSeltzer,andJeanBacon.2017. PracticalWhole-SystemProvenance
Capture. In Proceedings of the 2017 Symposium on Cloud Computing (SoCC
√¢ƒÇ≈π17). Association for Computing Machinery, New York, NY, USA, 405√¢ƒÇ≈û418.
https://doi.org/10.1145/3127479.3129249
[43]Maksym Petrenko and V√°clav Rajlich. 2009. Variable granularity for improving
precisionofimpactanalysis.In The17thIEEEInternationalConferenceonProgram
Comprehension, ICPC 2009, Vancouver, British Columbia, Canada, May 17-19, 2009.
IEEE Computer Society, Vancouver, BC, Canada, 10‚Äì19. https://doi.org/10.1109/
ICPC.2009.5090023
[44]Jo√£oFelipePimentel,LeonardoMurta,VanessaBraganholo,andJulianaFreire.
2017. noWorkflow: A Tool for Collecting, Analyzing, and Managing Provenance
fromPythonScripts. Proc.VLDBEndow. 10,12(2017),1841‚Äì1844. https://doi.
org/10.14778/3137765.3137789
[45]E.D.Ragan,A.Endert,J.Sanyal,andJ.Chen.2016. CharacterizingProvenancein
VisualizationandDataAnalysis:AnOrganizationalFrameworkofProvenance
Typesand Purposes. IEEETransactions onVisualizationand ComputerGraphics
22, 1 (Jan 2016), 31‚Äì40. https://doi.org/10.1109/TVCG.2015.2467551
[46]Xiaoxia Ren, Fenil Shah, Frank Tip, Barbara G. Ryder, and Ophelia Chesley. 2004.
Chianti: A Tool for Change Impact Analysis of Java Programs. In Proceedings
ofthe 19thAnnual ACM SIGPLANConference onObject-orientedProgramming,
Systems,Languages,and Applications (OOPSLA‚Äô04).ACM, NewYork,NY,USA,
432‚Äì448. https://doi.org/10.1145/1028976.1029012
[47]JulietP.Shaffer.1995. MultipleHypothesis-Testing. AnnualReviewofPsychology
46 (1995), 561‚Äì584.
[48]Cl√ÉƒÖudio T. Silva, Erik Anderson, Emanuele Santos, and Juliana Freire. 2011.
Using VisTrails and Provenance for Teaching Scientific Visualization. Computer
Graphics Forum 30, 1 (2011), 75‚Äì84. https://doi.org/10.1111/j.1467-8659.2010.
01830.x
[49]Leslie N. Smith. 2018. A disciplined approach to neural network hyper-parameters: Part 1 ‚Äì learning rate, batch size, momentum, and weight decay.
arXiv:cs.LG/1803.09820
[50]XiaobingSun,BixinLi,ChuanqiTao,WanzhiWen,andSaiZhang.2010. Change
ImpactAnalysisBasedonaTaxonomyofChangeTypes.In Proceedingsofthe
2010IEEE34thAnnualComputerSoftwareandApplicationsConference(COMPSAC
‚Äô10). IEEE Computer Society, Washington, DC, USA, 373‚Äì382. https://doi.org/10.
1109/COMPSAC.2010.45
[51]D.J.J.Toal,N.W.Bressloff,A.J.Keane,andC.M.E.Holden.2011.Thedevelopment
ofahybridizedparticleswarmforkriginghyperparametertuning. Engineering
Optimization 43,6(2011),675‚Äì699. https://doi.org/10.1080/0305215X.2010.508524
[52]Wil MP Van der Aalst. 2014. Data Scientist: The Engineer of the Future. In
Enterprise Interoperability VI. Springer International Publishing, Cham, 13‚Äì26.
[53]G Varoquaux and O Grisel. 2009. Joblib: running Python function as pipeline
jobs. packages. python. org/joblib.
[54]Gary V. Vaughan and Thomas Tromey. 2000. GNU Autoconf, Automake and
Libtool. New Riders Publishing, Thousand Oaks, CA, USA.
[55]Adrian Ward,Kristen Duke,Ayelet Gneezy,and MaarteBos. 2017. BrainDrain:
The Mere Presence of One‚Äôs Own Smartphone Reduces Available Cognitive
Capacity. JournaloftheAssociationforConsumerResearch 2,2(2017),140‚Äì154.
https://doi.org/10.1086/691462
[56]Mark Weiser. 1981. Program Slicing. In Proceedings of the 5th International
ConferenceonSoftwareEngineering(ICSE‚Äô81).IEEEComputerSociety,Piscataway,
NJ, USA, 439‚Äì449.
[57]Zuoning Yin, Ding Yuan, Yuanyuan Zhou, Shankar Pasupathy, and Lakshmi
Bairavasundaram. 2011. How Do Fixes Become Bugs?. In Proceedings of the 19th
ACMSIGSOFTSymposiumandthe13thEuropeanConferenceonFoundationsof
SoftwareEngineering (ESEC/FSE‚Äô11) .ACM,NewYork,NY,USA,26‚Äì36. https:
//doi.org/10.1145/2025113.2025121
1097