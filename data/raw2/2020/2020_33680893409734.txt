Java Ranger:Statically SummarizingRegions forEfficient
Symbolic Execution ofJava
Vaibhav Sharma‚àó
vaibhav@umn.edu
Universityof Minnesota
Minneapolis, MN, USASohaHussein‚àó
soha@umn.edu
Universityof Minnesota
Minneapolis, MN, USA
soha.hussein@cis.asu.edu.eg
Universityof AinShams
Cairo,EgyptMichael W.Whalen
mwwhalen@umn.edu
Universityof Minnesota
Minneapolis, MN, USA
StephenMcCamant
mccamant@cs.umn.edu
Universityof Minnesota
Minneapolis, MN, USAWillemVisser
wvisser@cs.sun.ac.za
Stellenbosch University
Stellenbosch, SouthAfrica
ABSTRACT
Mergingexecutionpathsisapowerfultechniqueforreducingpath
explosion in symbolic execution. One approach, introduced and
dubbed ≈Çveritesting≈æ by Avgerinos et al., works by translating a
boundedcontrolflowregionintoasingleconstraint.Thisapproach
is a convenient way to achieve path merging as a modification to a
pre-existing single-path symbolic execution engine. Previous work
evaluated this approach for symbolic execution of binary code,
butdifferentdesignconsiderationsapplywhenbuildingtoolsfor
other languages. In this paper, we extend the previous approach
for symbolic executionofJava.
Because Java code typically contains many small dynamically
dispatchedmethods,it isimportanttoincludethemin multi-path
regions; we introduce dynamic inliningof method-regions todo so
modularly. Java‚Äôs typed memory structure is very different from
thebinaryrepresentation,but weshow how the ideaof staticsin-
gle assignment (SSA) form can be applied to object references to
staticallyaccount for aliasing.
WehaveimplementedouralgorithmsinJavaRanger,anexten-
siontothewidelyusedSymbolicPathfindertool.Inasetofnine
benchmarks, Java Ranger reduces the running time and number
ofexecutionpathsbyatotalof38%and71%respectivelyascom-
pared to SPF. Our results are a significant improvement over the
performance of JBMC, a recently released verification tool for Java
bytecode.Wealsoparticipatedinastaticverificationcompetition
at a top theory conference where other participants included state-
of-the-artJavaverifiers.JRwonfirstplaceinthecompetition‚ÄôsJava
verification track.
‚àóTheseauthorscontributed equally to thisresearch.
Permissionto make digitalor hard copies of allorpart ofthis work for personalor
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACM
mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,
topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ESEC/FSE ‚Äô20, November 8≈õ13, 2020, Virtual Event, USA
¬©2020 Associationfor Computing Machinery.
ACM ISBN 978-1-4503-7043-1/20/11...$15.00
https://doi.org/10.1145/3368089.3409734CCS CONCEPTS
¬∑Theory ofcomputation ‚ÜíProgramanalysis .
KEYWORDS
symbolic execution,veritesting,path-merging
ACMReference Format:
VaibhavSharma,SohaHussein,MichaelW.Whalen,StephenMcCamant,
andWillemVisser.2020. JavaRanger: StaticallySummarizing Regionsfor
EfficientSymbolicExecutionofJava.In Proceedingsofthe28thACMJoint
EuropeanSoftwareEngineeringConferenceandSymposiumontheFounda-
tionsofSoftwareEngineering(ESEC/FSE‚Äô20),November8≈õ13,2020,Virtual
Event, USA. ACM, New York, NY, USA, 12pages.https://doi.org/10.1145/
3368089.3409734
1 INTRODUCTION
Symbolicexecutionisapopularanalysistechniquethatperforms
non-standard execution of a program: data operations generate
formulasoverinputs,andbranchconstraintsalonganexecution
path are combined into a predicate. Originally developed in the
1970s [19], [10], symbolic execution is a convenient building block
for program analysis, since arbitrary query predicates can be com-
bined with the logical program representation, and solutions to
these constraints are program inputs illustrating the queried be-
havior. Some of the applications of symbolic execution include test
generation [ 15,26], equivalence checking [ 25,28], vulnerability
finding[31,32],programrepair[ 22],invariantdiscovery[ 1],and
protocolcorrectnesschecking[ 33].Symbolicexecutiontoolsare
available for many languages, including CREST [ 7] for C source
code, KLEE [ 8] for C/C++ via LLVM, JDart [ 21] and Symbolic
PathFinder (SPF) [ 24] for Java, and S2E [ 9], FuzzBALL [ 4], and
angr[31]for binary code.
Althoughsymbolicanalysisisapopulartechnique,scalabilityisa
substantialchallengeformanyapplications.Inparticular,symbolic
executioncansufferfroma pathexplosion :complexsoftwarehas
exponentially many execution paths, and baseline techniques that
exploreonepathatatimeareunabletocoverallpaths.Dynamic
state merging [ 16,20] provides one way to alleviate scalability
challenges by opportunistically merging execution paths. Avoiding
123
ESEC/FSE ‚Äô20, November8≈õ13,2020,VirtualEvent, USA Vaibhav Sharma,Soha Hussein, MichaelW. Whalen, Stephen McCamant,andWillem Visser
even a single branch point can provide a multiplicative savings
inthenumberofexecutionpaths,thoughatthepotentialcostof
makingsymbolic state representations more complex.
Veritesting [ 3] is another technique that can dramatically im-
prove theperformance of symbolicexecutionby effectively merg-
ing paths. Rather than explicitly merging state representations,
veritesting identifies arbitrary fragments of code and encodes it
as a disjunctive predicate for symbolic execution. This encoding
allowsmanypathsto be collapsedintoasinglepath.
Inprevious work[ 3],constructing abounded staticrepresenta-
tion of code fragments was shown to allow symbolic execution the
abilitytofindmorebugs,andachievemorenodeandpathcoverage,
whenimplementedattheX86binarylevelforcompiledCprograms.
Thismotivatesustoinvestigatethebenefitofboundedstaticrep-
resentation of bytecode fragments for the symbolic execution of
Java programs. There are substantial differences between compiled
Java programs and C programs. In C programs, most functions
arestaticallydispatchedandexceptionsdonotoccur,allowingC
compilers to inline code and create relatively large code fragments
without non-local jumps. In Java programs, most functions are
dynamically dispatched, methods tend to be small, and the com-
pilerassumesan"open-world"somostfunctionsarenotinlined.In
addition,many,ifnotmost,Javabytecodescanthrowexceptions,
leadingtomanysmall,dynamicallydispatchedfragmentsofcode
with many non-local control jumps. In a naive implementation,
such non-local jumps reduce the size of the path-merged code that
can be created and increase the branching factor for exploration,
leading to poor performance. This makes Java more challenging
for creating boundedstaticrepresentations.
In this paper, we present Java Ranger, an extension of Symbolic
PathFinder.JavaRangeroperatesbyidentifyingparticularforms
of bytecode fragments that we call a region. A region can be one
oftwotypes:a Multi-PathRegion ,whichcorrespondstotheJava
bytecode fragment ofan if-statement, and a MethodRegion , which
corresponds to Java bytecode that spans the definition of a method.
JavaRangerthenutilizesdynamicinformationfromDynamicSym-
bolic Execution (DSE) environment such as stack slot and heap
values, and later uses them in a series of transformations to per-
form path-merging. Java Ranger‚Äôs transformations are designed to
transform features ofthe Java languageto asolver constraint.
In our experiments, we demonstrate exponential speedups on
benchmarks(ingeneral,themorepathscontainedwithinaprogram,
the larger the speedup) over the unmodified Java SPF tool using
this approach.
We make the following contributionsinthis paper:
(1)We propose Dynamic Method Region Inlining : this allows us
to construct summaries for multi-path regions containing
dynamically dispatched methodcalls, once types are known.
(2)Weproposeatechniquenamed Single-PathCases forsplitting
regionsintoexceptionalandnon-exceptionaloutcomes,and
use DynamicSymbolic Executionfor the exceptionalcases.
(3)We propose Early-Returns Summarization to collapse multi-
plereturnsintoadisjunctive-conditionalreturned-expressions.1  List<Integer> list = new ArrayList <>(7);
2  //put 7 symbolic int into list
3  int[] wrdStartIndArr = new int[(list.size() / 2) ];
4 for (int j = 0; j < wrdStartIndArr .length; j++)
5     wrdStartIndArr [j] = -1;
6  int wordCount = 0, element = 0, i = 0;
7  boolean inWord = false, done = false;
8  if (list.size() > 0) {
9    while (i < list.size() && !done) {
10      element = list.get(i);
11      if (element == -1) { 
12        done = true;
13      } else {
14    //list.get(i) returns sym. int
15        element = list.get(i);
16        if (element == 0) {
17          inWord = false;
18        } else if (!inWord) {
19          wrdStartIndArr [wordCount ] = i;
20          ++wordCount ;
21          inWord = true; }  }
22      ++i;  } }List< Integer >.
get(i) 
ArrayList< Integer >.
get(i) 
ArrayList< E>.
rangeCheck(i)
ArrayList< E>.
elementData(i)
ArrayList< E>.
elementData [i]Integer.
intValue()
Integer.
value(1)
(1b)(2)
(1a)
Figure 1: An example where Java Ranger summarizes two
multi-path regions
1.1 Motivating Example
ConsidertheexampleshowninFigure 1.Thecodecomputesthe
numberofwordsinalistandstoresthestartingindexofeachword
inwrdStartIndArr .Thelistvariablereferstoan ArrayList of
7Integer objects, each of which have an unconstrained symbolic
integerasafield.Thesizeof wrdStartIndArr issettohalfthesize
oflist,toaccountforthemaximumpossiblewordsthatcanoccur
inlistif all words are one character long (line 3). All elements in
fstWrdIndexArr are initialized to ‚àí1 (lines 4-5). In this example,
the concrete value 0acts as a delimiter for words and the value -1
acts as string terminator. Two conditions cause execution to exit
thewhileloop,(1)ififallelementsinthe listhavebeenprocessed
or(2) if astringterminator ( -1) isfound.
Thiscodehasabug.Considerthecasewhenthe listhasthe
following 7 values: {1,0,1,0,1,0,1} . In this case, there are 4
words, where each word is of size 1 character and where 0, 2, 4,
and6are thestartingindicesofeachword.But,theallocatedsize
ofwrdStartIndArr is 3 elements since we performed integer di-
vision on line 3 ( 7/2 = 3 ). This incorrect allocation causes an
ArrayOutOfBoundsException when trying to store the first index
of the 4th word in wrdStartIndArr at line 19. We ran this code
symbolicallywith thedepth-firstsearch heuristicwitha dynamic
symbolicexecutor(SymbolicPathFinder)andfoundthatitexplored
173execution paths before finding this bug. This number of ex-
ploredexecutionpathsdependsonthenumberofsymbolicinputs(7
in this example) when exploring with Symbolic PathFinder. Java
Ranger however, can find this bug after exploring only one execu-
tionpath,regardlessofthenumberofsymbolicinputs.JavaRanger
explorestwokindsofoutcomesthroughpath-merging:(a)thenon-
exceptionaloutcomewhichincludeswithin-boundsarrayaccess
,and(b)anexceptionaloutcome,whichexplores,inthiscasethe
ArrayOutOfBoundsExceptiontofindthebug.JavaRangerisable
toachievethisreductioninexecutionpathsbymergingthepaths
arisingout oftheif-branch inline11 through 21andexploring all
non-exceptionaloutcomes inasingleexecutionpath.
Path-merging of this simple region is not straightforward.
The call to list.get(int) at the source level results in the
following sequence of method calls (Figure 1): (1) It calls
ArrayList<Integer>.get(int) whichinternallydoestwothings,
124Java Ranger: StaticallySummarizingRegions forEfficient SymbolicExecutionof Java ESEC/FSE ‚Äô20, November8≈õ13,2020,VirtualEvent, USA
BB40 
if (x57 != 0)
BB42 
if (x67 != 0)
BB43 
     x39 [x64] = x66
BB44 
x58 = w64 + 1BB41 
goto BB40
BB45 
x59 = phi x64 , x64, x64, x58
x61 = phi x67 , 0, x67, 1
x62 = phi 1, x68, x68, x68
x63 =  x66 + 1BB35 
if (x52 != -1)
BB37 
x54 = invoke <List, get(I)Object> x9,x66 
BB38 
x55 = checkcast <Integer> x54
BB39 
x57 = invoke < Integer , intValue ()I> x55BB36 
goto BB40
Figure2:AsubgraphoftheCFGrepresentingtheRegionin
dashed box in Figure 1, where BB35 and BB45 is the entry
andexitblocks ofthesubgraph, respectively.
(a)Itchecksiftheindex argument accessesa value withinbounds
oftheArrayList bycalling ArrayList<E>.rangeCheck(int) .If
this access is not within bounds, it throws an exception. And (b) It
callsArrayList<E>.elementData(int) to access an internal ar-
raynamed elementData andgettheentryatposition i.Thiscall
results in an object of class Integer being returned. (2) It calls
Integer.intValue() on the object returned by the previous step.
Thiscallinternallyaccessesthe valuefieldofthe Integertoreturn
theintprimitive valueofthis object.
Themethodtobeinlineddependsonthedynamictypeoftheob-
jectreferencefortheinvokedmethod.Inthisexample,thedynamic
typeoflistisanArrayList ,whereasitisdeclaredstatictypeis
List.Path-mergingrequiresnotonlyinliningtherightmethodbut
alsoaccountingfor the possibility ofan exception beingraisedby
ArrayList<E>.rangeCheck(i) .
1.2 Java Ranger Overview
JavaRanger operatesontopofDSEandattemptstomergepaths
by creating a Region Constraint , a disjunctive formula describing
thebehavioroftheregion.ItintegrateswithDSEbyutilizingthree
mainfeaturesofDSE:(1)PathCondition( ùëÉùê∂),whichisacondition
ontheinputsymbolssuchthatifapathisfeasibleitspathcondition
issatisfiable.JavaRanger addstheconstraintdescribingthemerged
region to the ùëÉùê∂. (2) Program Counter ( ùëùùëê), which points to the
instruction to be executed. Java Ranger changes the ùëùùëêto skip
symbolic execution of a successfully merged region or to direct
DSE to execute unmerged paths. (3) Runtime/Instantiation time
informationoflocalvariablesonthestackandtheheap.JavaRanger
utilizesthis information to constructaregionconstraint.
Todopathmerging,JavaRanger interceptsanysymbolicbranch-
inginstruction duringDSE,andattemptstorecoverthecorrespond-
ingif-then-else statementstructure byrecognizinginstructionsthatbelongs to its"then"or"else"side. The recovered statementisrep-
resented in Java Ranger‚Äôs Intermediate Representation (IR) which
we call a static statement . For example,Listing 1in Figure 3shows
therecoveredstaticstatementofthebytecodecorrespondingtothe
code region between lines 11-21 in Figure 1. We call this process
Statement Recovery and it is part of the Static phase , described in
Section3.2.The inputtothestatementrecoveryisaControlFlow
Graph(CFG)ofthecorrespondingregion.JavaRangerusesWala
[17]toconstructtheCFGofthebytecoderegion.Figure 2shows
the CFG ofthe multi-path regioninlines11-21.
Giventhestaticstatementfromtheabovestep,JavaRanger then
triestofindinstantiation/runtimeinformationinDSEtoconcretize
values of variables and references used in the static statement.
We call this phase the Instantiation Phase and it consists of nine
instantiation-time transformations described in Section 3.4. The
outputofeachofthesetransformationsisamorerefined,rewritten
versionofthestaticstatementinJavaRangerIR.Wecallthisoutput
instantiated statement . For example, Listing 2in Figure 3shows
theinstantiated statement resulting from the Substitution transfor-
mationwith runtimeinformationsubstituted fromDSE, e.g., ùë•9is
substitutedwiththeinstantiationtimeobjectreference375of List
obtainedbyreadingastack slot inthe DSEenvironment.
Thegoaloftheinstantiationphaseistogenerateaninstantiated
statementthatcanbeconvertedintoaregionconstraintwhichcan
be conjuncted with the path condition of the DSE. Listing 3shows
thefinalformofaninstantiatedstatementjustbeforetranslating
it to a region constraint. We call this form of instantiated state-
mentlinearized sinceithasnobranchingstructureinitanymore
(compare it with Listing 1and Listing 2). Using the linearized in-
stantiated statement,Java Ranger generates region constraint and
conjunctsitwiththepathconditionoftheDSE.JavaRangeralso
re-directs the DSE to execute the instruction that follows the re-
coveredif-statement.This constitutes anexit point for JavaRanger.
AnExit Point is a program location at which JR transfers execu-
tion back to DSE. For example, after generating a region constraint
from Listing 3that represents the merged multi-path region in-
side the dashed box in Figure 1, the execution of DSE proceeds
from the instruction thatis following ùêµùêµ45in Figure 2. Generally,
therearethreekindsofexitpoints:aprogramlocationthatcorre-
sponds to the conditional branch‚Äôs immediate post-dominator, a
programlocationthatperformsanon-localjumpinthe formofa
returninstruction,andasetofprogramlocationsthatJavaRanger
does not merge and requires DSE exploration. We refer to these
three exit points as a non-exceptional and non-returningexit point
(NENR), a returning exit point (RE), and single-path exit point (SP)
respectivelyinthe restof this work.
2 RELATED WORK
Pathexplosionhindersscalableuseofsymbolicexecution,soanap-
pealingdirectionforoptimizationistocombinetherepresentations
ofsimilarexecutionpaths,whichwerefertoas pathmerging. Ifa
symbolic execution tool maintains objects representing multiple
execution states, a natural approach is to merge these states, espe-
cially oneswith thesamecontrol-flowlocation.Hansenetal. [ 16]
and Kuznetsov et al. [ 20] are representative examples of this ap-
proach.Asimilarexamplecanbefoundinthelarge-blockencoding
125ESEC/FSE ‚Äô20, November8≈õ13,2020,VirtualEvent, USA Vaibhav Sharma,Soha Hussein, MichaelW. Whalen, Stephen McCamant,andWillem Visser
if(!(x52!=-1 )) then{ skip; }
else{
x54 := invoke(List.get(I)Object, x9,x66);
x55 := checkcast(Integer, x54);
x57 := invoke(Integer.intValue()I, x55);
if(x57 != 0 ) then{
if(!(x67!= 0 )) then{
x39[x64] :=x66;
x58 := ( x64+ 1 );
}else{ skip; }
}else{ skip; }}
x59:=ùõæ
(x52!=-1,ùõæ(x57!=0, ùõæ(!(x67!=0),x58, x64),x64),x64);
x61:=ùõæ(x52!=-1,ùõæ(x57!=0, ùõæ(!(x67!=0),1,x67),0),x67);
x62 :=ùõæ
(x52!=-1,ùõæ(x57!=0, ùõæ(!(x67!=0),x68,x68),x68),1);
Listing 1: Static Statementif(!(a1!=-1 )) then{ skip; }
else{
x54 := invoke(List.get(I)Object, 375,
0);
x55 := checkcast(Integer, x54);
x57 := invoke(Integer.intValue()I, x55);
if(x57 != 0 ) then{
if(!(0!= 0 )) then{
399[0] :=0;
x58 := ( 0+ 1 );
}else{ skip; }
}else{ skip; }}
x59:=ùõæ(a1!=-1,ùõæ(x57!=0, ùõæ(!(0!=0),x58, 0),0),0);
x61:=ùõæ(a1!=-1,ùõæ(x57!=0, ùõæ(!(0!=0),1,0),0),0);
x62:=ùõæ(a1!=-1,ùõæ(x57!=0, ùõæ(!(0!=0),0,0),0),1);
Listing 2: Instantiated Statementr399[0]_5 := ùõæ(a1!=0, 0, -1);
r399[0]_8 :=ùõæ(a1!=-1, r399[0]_5, -1);
x59_1:=ùõæ(a1!=-1,ùõæ(a1!=0, 1, 0), 0);
x61_1:=ùõæ(a1!=-1,ùõæ(a1!=0, 1, 0), 0);
x62_1:=ùõæ(a1!=-1, 0, 1);
Listing 3: Linearized Instantiated Statement
Figure 3: Java Ranger‚Äôs High Level Overview. Bluevariables correspond to inputs to the region. Redvariables correspond to
outputsfromtheregion. x52, x9, x66, x67, x39, andx64refertotheinputof element, list, i, inWord, wrdStartIndArr,
andwordCount respectively. Similarly, r399[0]_8, x59, x61, andx62refer to the outputs of wrdStartIndArr[0], wordCount,
inWord,anddonerespectively.
approach [ 6] by Beyer et al. for model checking C code. Sen et al.‚Äôs
MultiSE [ 27] achieves similar benefits for symbolic execution as
part ofadifferenttoolarchitecture.
Another approach to achieve path merging is to statically sum-
marize regions that contain branching control flow. This approach
was proposed by Avgerinos et al. [ 3] and dubbed ≈Çveritesting.≈æ A
veritesting-styletechniqueisaconvenientwaytoaddpathmerging
to a symbolic execution system that maintains only one execution
state,likeSPF.Avgerinosetal.implementedtheirveritestingsys-
tem MergePoint to apply binary-level symbolic executionfor bug
finding. They found that veritesting provided a dramatic perfor-
mance improvement, allowing their system to find more bugs and
have bettercoverage.
The way that Java Ranger and similar tools statically convert
code regions into formulas is similar to techniques used in veri-
fication. In the limit where all relevant code in a program can be
summarized,suchaswithWBSandTCASinSection 4,JavaRanger
performssimilarlytoaboundedsymbolicmodelcheckerforJava.
SPFandJavaRangerbuildonJavaPathfinder(JPF)[ 36],whichis
widely used for explicit-state model checking of Java. The most
closelyrelatedJavamodelcheckingtoolisJBMC[ 11],whichshares
infrastructure with the C tool CBMC. JBMC performs symbolic
bounded model checking of Java code, transforming code and a
supportedsubsetofthestandardlibraryintoSMTorSATformulas
thatrepresentallpossibleexecutionpaths.Theprocessbywhich
JBMC transforms its internal code representation into SMT formu-
lasissimilartohowJavaRangerconstructsstaticregions.However,
the dynamic dispatch aspects of Java make creating entirely static
representations expensive. We believe that our approach can yield
simpler SMT formulas in many cases where it is difficult to com-
pletely statically summarize program behavior, and can be used in
cases when software is too large and/or complex to be explored
completely.
Manyotherenhancementstosymbolicexecutionhavebeenpro-
posed to improve itsperformance, including cachingandsimplify-
ingconstraints,summarizingrepetitivebehaviorinloops,heuristicguidancetowardsinterestingcode,pruningpathsthatarerepetitive
or unproductive, and many domain-specific ideas. A recent survey
byBaldoniet.al.[ 5]providespointersintothelargeliterature.One
approachthatismostrelatedtoourmulti-pathregionsthathave
methodinvocation,isthefunction-levelcompositionalapproach
calledSMARTproposedbyGodefroid[ 14].SMARTdiffersinbeing
based on single-path symbolic execution instead of static analysis,
andtargetingC itdoes not address dynamic dispatch.
3 TECHNIQUE
ConceptuallyJavaRangerhastwomainphases,a staticphase ,anda
instantiationphase .Thestaticphaseconsistsoftwotransformations
and the instantiation phase consists of nine transformations. Note
that Java Ranger‚Äôs default configuration chooses to perform the
transformationsofbothphasesdynamicallyduringexecution.More
concretelythestaticphaseisperformedon-the-flywhenneeded
rather than prior to symbolic execution to avoid the expense of
creating a static statement for unexecuted methods, classes, and
packages.Thedistinctionthenbetweenthetwophasesreferstothe
dependency of the transformation on dynamic or static informa-
tion rather than when they are executed. The transformations are
discussedinmoredetailinSections 3.2-3.4,butaresummarized
below.
The two transformations of the static phase are explained as
follows(more details inSection 3.2):
-IR Statement Recovery: To more easily implement the Java
Ranger transformations, we first convert the control flow graph
representation into an internal representation (IR) in the IR
Statementrecoverytransformation .
-Early-Returns Summarization : Multi-path and method regions can
sometimes have more than one return-instruction. DSE needs to
explore each return possibility in a separate execution path which
can increase the total number of execution paths explored by DSE.
In this transformation, Java Ranger collapses return paths into a
singlereturn paththat can explore allreturn possibilities.
126Java Ranger: StaticallySummarizingRegions forEfficient SymbolicExecutionof Java ESEC/FSE ‚Äô20, November8≈õ13,2020,VirtualEvent, USA
‚ü®ùë£ùëéùëô ùë£‚ü©::=ùê∂|ùëç|ùêµ‚ü®ùë£ùëéùëü ùë•‚ü©::=..|ùêºùëëùë†|ùêºùëëùë†ùëü
‚ü®ùëüùëíùëì ùëü‚ü©::=ùêºùëë‚ü®ùëìùëñùëíùëôùëë‚ü©::=ùêºùëë‚ü®ùëêùëôùëéùë†ùë† ùëê‚ü©::=ùêºùëë
‚ü®ùë†ùëñùëîùëî‚ü©::=...‚ü®ùëíùë•ùëù ùëí‚ü©::=...|ùõæ(ùëí1,ùëí2,ùëí3)
‚ü®ùë†ùë°ùëöùë° ùë†‚ü©::=ùë•:=ùëí|ùë†1;ùë†2|skip|ifùëíthenùë†1elseùë†2
|ùë•:=invoke(ùëî,ùëü,‚àí ‚Üíùëí) |putfield(ùëü,ùëì,ùëí) |getfield(ùëü,ùëì,ùëí)
|returnùëí|ùë•:=ùëü[ùëí] |ùëü[ùëí1]:=ùëí2|new(ùëê,‚àí ‚Üíùëí) |throwùëí
Figure 4:Main Constructs inRanger IR
Briefly,thenineinstantiationphasetransformationsareasfol-
lows:
-Alpha-Renaming :Nameclashesofsymbolicvariablesonthe ùëÉùê∂can
resultinunsoundbehaviour.Inthistransformation,JavaRanger
avoids this problem by using unique names for newly encountered
symbolic variables. For example in listing 3variables are appended
with_1to distinguishtheirnames.
-InputSubstitution :JavaRanger needstobindinputsofthestatic
statement to their runtime values to preserve soundness. It does
thisbycollectingandsubstitutingruntimeinformationfromDSE
intothe inputofthe staticstatement.
-Method Region Inlining andField and Array Reference GSA Cre-
ation: These transformations support method invocation as well
as field and array accesses. The former inlines method regions and
the latter represents field and array accesses in a Gated-Single-
Assignment(GSA) form [ 23,34].
-Simplification :Thistransformationpushesconcretevaluestosubse-
quent variables definitions using constant propagation, copy prop-
agation,andconstant folding[ 2].
-Single-Path Cases : Java Ranger avoids merging certain types of
statements(objectcreationandexceptions)becauseoflimitations
that Java Ranger has inherited. If Java Ranger had to abort all code
regions that contains these two types of statements because it is
unable to merge them, then it will miss many useful path-merging
instances. This transformation is Java Ranger‚Äôs way of partially
mergingpaths,whiledirecting SPF to executeunmergedones.
-LinearizationandGreen :EvenafterremovingallJava-specificstate-
mentsabove,apotentialJavaRanger‚Äôsstatementisstillnotreduced
enough toa solver constraint. These two transformations remove
if-statementstructures andgeneratearegionconstraint.
In the rest of this section we introduce JR‚Äôs IR grammar, discuss
JR‚Äôsstaticphase,presentJavaRanger‚Äôsinstantiationalgorithm,and
finally discuss Java Ranger‚Äôs instantiationtime transformations.
3.1 Java Ranger IRGrammar
Figure4shows the grammar of the IR for JR. Values are charac-
ters,integers,andbooleans.Inadditiontoprogramvariablesand
symbolicvariables ùêºùëëùë†,JR usesùêºùëëùë†ùëütocapturereturn-symbolicvari-
ables. Java Ranger IR identifies references ùëüùëíùëì, fieldsùëìùëñùëíùëôùëë, classes
ùëêùëôùëéùë†ùë†,andmethodsignatures ùë†ùëñùëî.
JavaRangerextendsusualexpressionswitha ùõæ-expression(seen
in Listing 1):ùõæ(ùëí1,ùëí2,ùëí2), which describes theGSA form, where ùëí1
is the condition and ùëí2andùëí3are the returned expressions if the
condition wasevaluatedto true orfalse.Statementsincludeassignment,composition, skip,if,method
invocation:x:= invoke(g,r,‚àí ‚Üíùëí),returnstatement: returnùëí,putfield
statement: putfield(ùëü,ùëì,ùëí)toputthevalueofexpression ùëíinthe
fieldùëìof reference ùëü, get field statement: ùë•:=getfield(ùëü,ùëì), array
load:ùë•:=r[ùëí]andarraystore:r [ùëí1]:=ùëí2,objectcreation: new(c,‚àí ‚Üíùëí)
whereùëêis the class type and‚àí ‚Üíùëíis the constructor parameters, and
finallythrowstatement to represent anexceptionbeing thrown in
the JR IR.
3.2 Static Phase
Thegoalofthestaticphaseistoidentifymulti-pathregionsthatcan
be summarized and to create an intermediate representation (IR)
for the region while collapsing return-statements. Listing 1shows
the output of the static phase. There are 2 main transformations in
this phase:
1)IR Statement Recovery
Inthistransformation,multi-pathregionsandmethodregions
are identified by first recovering their corresponding CFG using
Wala. Next, the CFG is converted to the Java Ranger‚Äôs intermediate
representation(IR) .JavaRanger distinguishes two typesof regions.
(1)Multi-PathRegion :thiscorrespondstotheJavabytecodeofan
acyclicsubgraphofthecontrol-flowgraph(CFG). Itbeginsfrom
the basic block containing a conditional branch and ends at this
basicblock‚Äôsimmediatepost-dominator.Anode ùëëimmediatelypost
dominatesanode ùëõifeverypathfromthe ùëõnodetoexitnodemust
go through ùëëandùëëdoes not strictly dominate any other node that
strictlydominates ùëõ.Forexample,theimmediatepost-dominator
of BB40 is BB45, while the immediate post-dominator of BB43 is
BB44.
Since Java allows if-statements to be nested, a multi-path re-
gionmayalsocontainothermulti-pathregions.Forexample,the
sub-graphsfromBB30-BB45,andBB35-BB45inFigure 2areboth
recognizedastwomulti-pathregions.Thereasonforrecognizing
both multi-path regions is that, while it may not be possible to
successfully path merge the larger multi-path region, the inner
regioncouldbemerged.(2) MethodRegion :thiscorrespondstoJava
bytecode that spans the definition of a method. For example, the
largerCFG (not shown), thatcontains the CFG in Figure 2,includ-
ing method entry and exit blocks constitutes a method region. The
recoveredJavaRangerIRcapturesthemulti-pathormethodregion
inGSA form.
The algorithms of the static statement recovery are similar to
those used for decompilation [ 39]. Starting from an initial basic
block in a control-flow graph, the algorithm first finds the immedi-
atepost-dominatorofall normalcontrolpaths,thatis,pathsthat
donotendinanexceptionorreturninstruction.Itthenlooksfor
nestedself-containedsubgraphs.
If, for any subgraph, the post-dominator is also a predecessor of
thenode,weconsideritaloopanddiscardtheregion.Forexample,
inFigure1,thesubgraphoftheCFGthatspanstheentirewhile-loop
fromline9-22,isdiscarded.Ontheotherhand,thesubgraphofthe
CFG that corresponds to the enclosed if-statement that spans lines
11-21isgoingtobecreated,becausetheimmediatepost-dominator
ofBB30 isBB40 anditisnot its predecessor (Figure 2).
Duringthisprocess, localinputs ,whereruntime-valuesaregoing
to be used, and outputs, where the result of path merging is going
127ESEC/FSE ‚Äô20, November8≈õ13,2020,VirtualEvent, USA Vaibhav Sharma,Soha Hussein, MichaelW. Whalen, Stephen McCamant,andWillem Visser
to be written to, of the static statement are identified. In particular,
givenaJRstatement,thefirst useofastackslotisdeemedalocal
inputandthe last defofastack slot isdeemedalocal output.
Forexample,considertheregioninthedashedboxinFigure 1with
staticstatementshowninListing 1.Herex64andx9,inListing 1,
correspond to the input of wordCount , andlist. Similarly x59,
x61,andx62correspondstotheoutputof wordCount ,inWord,and
donerespectively.
- Create Gated Single Assignment(GSA) : Part of the state-
ment recovery is the creation of the GSA from a Static-Single-
Assignment(SSA)form.ThusinthistransformationJavaRanger
changesùúô-statements,thatjoin localvariable updates fromdiffer-
entbranches,toanassignmentwiththeright-hand-sideexpression
being aùõæ-expression. The ùõæ-expression have an extra parameter
(thantheùúô-expression)thatdescribestheconditionofthematching
if-statement. For example, the right-hand side of the assignment
tox59(outputof wordCount )inListing 1istheGSAformforthe
firstùúô-expression shown in BB45 in Figure 2. The GSA captures
the conditions as well as possible assignments for x59.
2)Early-Return Summarization
Code regions can be exited due to function calls, exceptions, or
return-statements. In thistransformation, we factoroutthepredi-
cate that describes paths leading to a return-statement, i.e., RE exit
point.Thisisdonebycreatingandmaintainingtwoexpressions,
conditional-return-expressions andreturn path constraint (RPC) . The
conditional-return-expression contains all possible expressions en-
closedinreturn-statements,predicatedbytheirrelativepathcon-
dition inthe staticstatement.
For example, consider a simple if-statement:
ùëñùëì(ùë•1>1)ùëüùëíùë°ùë¢ùëüùëõ ùë•2ùëíùëôùë†ùëí ùëüùëíùë°ùë¢ùëüùëõ ùë• 3;. Hereùë•2 andùë•3 needs
to be captured in the conditional-return-expression. Thus Java
Ranger creates a new symbolic-return-variable ùë•ùëü‚ààùêºùëëùë†ùëü, and
assignsitto ùõæ-expressionthatdescribesthereturn-expressions,i.e.,
ùë•ùëü=ùõæ(ùë•1>1,ùë•2,ùë•3). TheùëÖùëÉùê∂on the other hand contains the
disjunctiveconditionsthatdescribeallreturn-conditions.Forthe
example above, the ùëÖùëÉùê∂will be (ùë•1>1 ||ùë•1<=1) which can be
reduced to ùë°ùëüùë¢ùëíto indicatethat anearly-return must occur inthis
simplestaticstatementonboth sidesofthe branch.
3.3 Java Ranger InstantiationAlgorithm
Thegoalof theinstantiationprocess,describedinAlgorithm 1,is
touseruntimevaluestoconvertastaticstatementtoalinearized
instantiatedstatementandfinally to aregionconstraint.
The algorithm starts when DSE is about to execute a multi-path
region that begins with a conditional branch instruction with a
symbolic operand(s) for whichJR has astaticstatement ùë†.
First, JR creates its initial environment ùúîùëúfrom the current DSE
stateùõøùë†ùë¶ùëö. JR state includes: JR‚Äôs local variables map and the static
statement‚Äôslocalinputs.JRstatealsoincludesamapforcreating
GSAformforwritestoobjectsreferencedinthestaticstatement.
Thismap isusedtomergewritestofields ofobjects andcontents
ofarrays.
Java Ranger ensures the uniqueness of variable in ùë†by running
alpha-renaming transformation (line 3). Then, Java Ranger runs
transformations fromthe lines (6-14) repeatedly until a fixpoint isAlgorithm1: JR Static Statement Instantiation Algorithm
1Input:(RangerIR Statement ùë†,DSEùõøùë†ùë¶ùëö);
2ùúîùëú=construct-initial-state(s, ùõøùë†ùë¶ùëö);
3(ùúîùõº,ùë†ùõº)=ùõº-renaming( ùúîùëú,ùë†);
4(ùúîùëèùëì,ùë†ùëèùëì)=(ùúîùõº,ùë†ùõº);
5ùúîùëéùëì=ùëõùë¢ùëôùëô;ùë†ùëéùëì=null;
6repeat
7if(ùúîùëéùëì,ùë†ùëéùëì)‚â†nullthenùúîùëèùëì,ùë†ùëèùëì=(ùúîùëéùëì,ùë†ùëéùëì);
8ùë†ùë†ùë¢ùëè=substitutelocal inputs( ùúîùëèùëì,ùë†ùëèùëì);
9(ùúî‚Ñéùëî,ùë†‚Ñéùëî)=inline methodregions( ùúîùëèùëì,ùë†ùë†ùë¢ùëè);
10(ùúîùëì,ùë†ùëì)=create ref. GSA( ùúî‚Ñéùëî,ùë†‚Ñéùëî);
11(ùúîùëéùëü,ùë†ùëéùëü)=create arr.GSA( ùúîùëì,ùë†ùëì);
12(ùúîùë†ùëöùëùùëô,ùë†ùë†ùëöùëùùëô)=simplify( ùúîùëéùëü,ùë†ùëéùëü);
13(ùúîùëéùëì,ùë†ùëéùëì)=(ùúîùë†ùëöùëùùëô,ùë†ùë†ùëöùëùùëô);
14until(ùúîùëèùëì,ùë†ùëèùëì)=(ùúîùëéùëì,ùë†ùëéùëì)
15(ùúîùë†ùëù,ùë†ùë†ùëù)=collectsingle-path cases( ùúîùëéùëì,ùë†ùëéùëì)
16ùë†ùëôùëõ=linearize( ùë†ùë†ùëù);
17ifis-linearized( ùúîùë†ùëù,ùë†ùëôùëõ)then
18ùëí=generateconstraint( ùúîùë†ùëù,ùë†ùëôùëõ)
19ùëÉùê∂=ùëÉùê∂‚àßùëí;
20populate outputs ( ùúîùë†ùëù);
21ùëùùëê=addressoffirstinst.after s;
22elseabort; /* resume DSE from cond. branch */
reached.Thesetransformationsperformdifferentoperationssuch
as substitutionandmethodinlining.
Notethatthereisnoparticularordertorunsomeofthetransfor-
mations. For example, a statement may have a method invocation
onanobjectwhichitselfistheresultofapriorfieldaccess.Inlining
amethod‚Äôs staticstatementrequires knowingthe runtimetype of
theobjecttowhichitisbound,whichcanonlybeobtainedafter
running the Field References GSA transformation. But, once the
method‚Äôs static statement has been inlined, it may include another
method invocation on an object which is the result of another field
access. Therefore, JR runs the transformations in lines 6-14 until
a fixpoint, in which the post-state region is unchanged from the
pre-state region,isreached.
Then Java Ranger factors out paths that involve object creation
andexceptionsinline14.These single-pathcases mustbeperformed
by the DSE due to architectural limitations in SPF/JPF. In line 15
Java Ranger runs the linearization transformation. If the resulting
statement ùë†ùë†ùëùislinearized , that isùë†ùë†ùëùis a composition of assign-
mentstatementswith nobranching,thenJavaRanger createsthe
solver constraint in line 18,and adds it to the path condition ( ùëÉùê∂).
ThenJavaRangerpopulatestheinstantiatedstatement‚Äôsoutputs
(r399[0]_8, x59_1, x61_1, andx62_1inFigure 3)tothestack
or the heap, where r399[0] is the output of the first element of
wrdStartIndArr .JavaRangeralsosets theprogram counter( ùëùùëê)
to theaddressofthe bytecodeinstruction thatoccursasthe first
instructionintheimmediatepost-dominator.Inourexample,this
is the address of the instruction that performs the addition opera-
tioninùêµùêµ45inFigure 2.Theseoperationsareshownonlines19-21
ofAlgorithm 1.
128Java Ranger: StaticallySummarizingRegions forEfficient SymbolicExecutionof Java ESEC/FSE ‚Äô20, November8≈õ13,2020,VirtualEvent, USA
Line21 describesthecasewhen theimmediatepost-dominator
is the NENR exit point of the multi-path region. Similarly, at the
SP and/or the RE exit point(s), Java Ranger transfers the control
backtoDSEiftheseexitpointsarefeasibleintheinstantiatedstate-
ment. The exploration of SP and RE exit points is done by creating
exploration branching in the DSE (not shown in the algorithm).
If a fully-linearized form of the instantiated statement cannot be
produced,JR aborts andallowsDSEto resume execution(line22).
3.4 Instantiation-Time Transformations
Inthissection,weexplainonlyseventransformationsoftheinstan-
tiationphase.Weelidethediscussionofthetwotransformations,
the alpha-renaming and the simplification transformations, as they
were previously explainedinSection 3.
1)InputSubstitution :Inthistransformation,JavaRangercollects
the runtime values for inputs(predetermined in the static phase)
and substitutes them. For example, in Listing 1,x52, x9, x66,
x67, x39, andx64areidentifiedasinputsfor element, list, i,
inWord, wrdStartIndArr, andwordCount respectively,andare
substitutedbyDSE‚Äôsruntimevalues(Listing 2).
2)MethodRegionInlining :Thistransformationinlinesthestatic
statement for a method invocation. It is, in general, impossible
to know statically which method to inline, and thus JR uses
instantiation-time values and type information to figure out (if
possible)themethodthatisabouttobeinvoked.Thisispossible
if JR is able to find out which concrete reference is used in the
invocation. For recursive functions, JR inlines methods up to a
user-specifiedparametric depth.
The effects of this transformation on our motivating example
are:
if(!(a1 != -1 )) then{ skip; }
else{ x4_3 = getfield(375, size);
if(!(0 < x4_3)) thenthrowelseskip;
x4_4 = getfield(375, elementData);
x5_4 = x4_4[0]; ... }
x59 :=ùõæ(a1!=-1, ùõæ(x57!=0, ùõæ(!(0!=0), x58, 0), 0), 0);
x61 :=ùõæ(a1!=-1 ùõæ(x57!=0, ùõæ(!(0!=0), 1, 0), 0), 0);
x62 :=ùõæ(a1!=-1 ùõæ(x57!=0, ùõæ(!(0!=0), 0, 0), 0), 1);
The above listing shows the result of inlining
ùê¥ùëüùëüùëéùë¶ùêøùëñùë†ùë°.ùëîùëíùë° (ùêº)ùëÇùëèùëóùëíùëêùë°in the static statement of the multi-
path region in Figure 1. To do that, ùë•9 in the recovered static
statementinListing 1issubstitutedby375,theruntimeconcrete
valueofthereference list.Then,usingtheconcretetypeof375
allowsJava Ranger to inline375 .ùëîùëíùë°(ùêº)ùëÇùëèùëóùëíùëêùë°shownabove.
3) Field References GSA Creation : This transformation ab-
stracts reference updates and lookups by capturing their semantics
throughfreshlocalGSAvariablesthatdescribethecomputation.
NotethatsincelocalvariablesobtainedfromtheCFGarealready
in an Static-Single-Assignment form, Java Ranger needs only a
simplertransformation(theGatedSingleAssignmenttransforma-
tion) to create their equivalent GSA form. This is unfortunately
not the case for references, and thus this transformation is used to
create the GSA for reference updatesandlookups.
At the NENR exit point of the instantiated statement, field as-
signments to the same field are mergedusing ùõæ-expression.
Inthemotivatingexample,thefieldreferencestransformation
on the above statement concretizes ùë•4_3. In this case, to determinethe value of variable ùë•43, the transformation looks up reference
number375inSPF‚Äôsrepresentationoftheheap,extractsthefield
‚Äôsize‚Äôanddeterminesthat itisbound to the concrete value7.
4) Array References GSA Creation : Similar to the field GSA
transformation, this transformation translates array accesses to
symbolicvariablesthatreflectthearraycomputations.Itmaintains
a path-specific copy of every array when it is first accessed using a
concretearrayreferencewithinaninstantiatedstatement.Reads
and writes of arrays are then performed on a path-specific copy
of the array. All array copies are merged at the NENR of the in-
stantiatedstatement.Themergedarraycopyrepresentsthearray‚Äôs
outputsoftheinstantiatedstatement.Out-of-boundsarrayaccesses
are explored as a SP exit point. The effect of this transformation
on the last shown statement introduces the fresh symbolic vari-
ablesr399[0]_8, r399[1]_9, andr399[2]_10 ‚ààùêºùëëùë†.Thesethree
symbolic variables describe possible assignments to elements of
wrdStartIndArr withaùõæcondition1.
if(!(a1 != -1)) then{ skip; }
else{...}
r399[2]_8 := ùõæ(a1!=-1, r399[1]_5, -1);
r399[2]_9 := ùõæ(a1!=-1, r399[1]_6, -1);
r399[2]_10 := ùõæ(a1!=-1, r399[2]_7, -1);
x59 :=ùõæ(a1!=-1, ùõæ(x57!=0, ùõæ(!(0!=0), x58, 0), 0), 0);
x61 :=ùõæ(a1!=-1 ùõæ(x57!=0, ùõæ(!(0!=0), 1, 0), 0), 0);
x62 :=ùõæ(a1!=-1 ùõæ(x57!=0, ùõæ(!(0!=0), 0, 0), 0), 1);
5) Single-Path Cases Generation :Summarizingobjectcreation
while path-merging requires maintaining a symbolic heap. Such
language features cannot be summarized and must be executed
using SPF because of the way SPF is architected and integrated
into JPF. In this phase, we build a guard predicate which avoids
paths that contain object creation and exceptions. We call these
pathssingle-pathcases,anduseSPFtoexecutethem.Theoutcome
of this process is: (a) an JR statement that captures non-SP exit
pointbehaviorintheinstantiatedstatementand(b)apredicatethat
is used to explore the SP exit point behaviour in the instantiated
statement.
In fact, the bug in our motivating example, Figure 1, is found
whenJavaRangerdirectstheDSEtoexploretheSPexitpointusing
the SP predicate for the out-of-bounds array access. The added
predicate for directing DSE to this particular path is: (x61_1 == 0
) && (!((x59_1 < 3 ) && ( x59_1 >= 0 ))) , wherex59and
x61are the outputofthe wordCount andinWord.
6)Linearization :At the point in Algorithm 1when thistransfor-
mationisrun,allJavafeaturesotherthanif-statements,composi-
tionand assignmentsstatementshave beenremoved fromwithin
theinstantiatedstatement.This transformationthenpreparesthe
instantiatedstatementbyreplacingif-statementswithacomposi-
tion of its "then" and "else" statements. This is correct as long as
the conditions of the eliminated if-statements are captured within
ùõæ-expressions. Running this transformation, after a fixpoint has
been reached, produces the linearized instantiated statement in
Listing3.
7) Constraint Generation : This transformation translates the
fullylinearizedstatementtoregionconstraintinGreen[ 35].This
1Definitions of r399[0]_5, r399[1]_6 , andr399[2]_7 elided for space reasons.
129ESEC/FSE ‚Äô20, November8≈õ13,2020,VirtualEvent, USA Vaibhav Sharma,Soha Hussein, MichaelW. Whalen, Stephen McCamant,andWillem Visser
is done by translating statement composition into conjunction, as-
signmentsasequalityconstraintswithassignmentsof ùõæ-expression
being translatedas adisjunctive equalityexpressions.
4 EVALUATION
4.1 Implementation
We implemented Java Ranger as an extension of Symbolic
PathFinder [ 24]. We used the existing listenerframework in SPF
thatinvokesacallbackfunctionforeachbytecodeinstructionex-
ecuted by SPF. JR adds a listener to SPF that, on every symbolic
branch,attemptspathmergingasdescribedinAlgorithm 1.JRuses
theincremental solvingmodeof theZ3theoremprover [ 12] with
the bitvectortheory.The incrementalsolvingmodesignificantly
reduces the number of times a constraint has to be passed to the
solver.JRusesaheuristictoestimatethenumberofpathsthrougha
linearized statement. The linearized instantiated statement is used
only ifthe estimated number of paths inthe linearized instantiated
statementisgreaterthanthenumberofexitpointsinit.Thisheuris-
ticavoidsuseofpath-mergingwhenitmaynothavebeenbeneficial.
Our implementationofJava Ranger ispubliclyavailable [ 30].
4.2 ExperimentalSetup
Table1:Benchmarkprograms usedtoevaluateJavaRanger
Bench
mark
nameDescription SLOC#
classes#
methods
WBScomponentto make
aircraft brake safely265 1 3
TCASmaintain aircraft
altitudeseparation300 1 12
replacesearch&replace
pattern ininput795 1 19
Nano
XMLXMLParser 4610 17 129
Sienaeventnotification
middleware1256 10 94
Schedule priority scheduler 306 4 27
Print
Tokens2lexical analyzer 570 4 30
ApacheCLI command-line parser 3612 18 183
Mer
Arbiterflight software comp.
ofNASAJPLMars
Exploration Rovers4697 268 553
We sought answers to the following researchquestions.
RQ1:Does Java Ranger reduce the number of execution paths and
running timein aprogramwhen exploringall feasible behaviors?
RQ2:DoesJava Rangerreduce the time required forcheckingfor
theabsenceofruntime errorsin aprogram?
RQ3:HowmuchdoeseachJavaRangerfeaturecontributetoper-
formance?
RQ4:HowdoesJavaRangercomparetootherstate-of-the-artJava
verifiers?We present the experimental setup used to answer each of these
researchquestionsandthe corresponding evaluation below.
RQ1: We evaluated the performance of Java Ranger using the
nine benchmarking programs presented in Table 1. We obtained
the first eight from the evaluation set used by Wang et al. [ 37] and
the last one (MerArbiter) from Yang et al. [ 40]. We used SPF as
theDynamicSymbolicExecutor(DSE)forcomparingitwithJava
Ranger. Path merging is useful in symbolic execution when it is
used for checking a property on all feasible behaviors or finding
allbugsinaprogram.WecomparedJRwithSPFwhenexploring
allfeasiblepathsthrougheachbenchmark.Allbenchmarkswere
single-threadedexecution, we leave exploration ofstatic regions
in multi-threaded programs to future work. We used a wall time
budget of 12 hours for every benchmark. We ran every benchmark
withthemostnumberofsymbolicinputswithwhichanexploration
ofallfeasiblebehaviorscouldbecompletedinawalltimebudgetof
12hours.Themaximumheapsizewaslimitedforallthebenchmark
runswithJRandSPFto8GB.Weranallofourexperimentsona
machinerunningUbuntu16.04.6LTSwithIntel(R)Xeon(R)CPU
E5-2623 v3 processor and 192 GB RAM. We report our results in
Table2.
JRachievesatotalreductionof38%and71%reductionintotal
runningtime and number ofexecution pathsrespectively across
all benchmarks. It also achieves an average of 63% reduction in
thenumberofsolverqueries.Itisabletosignificantlyreducethe
totalnumberofexecutionpathsoneverybenchmarkwhereitfinds
beneficialuse ofastaticstatementfor amulti-path region.
JR achieves a significant speed-up over SPF with 5 (WBS, TCAS,
NanoXML,ApacheCLI,MerArbiter)ofthe9benchmarksinrunning
time and number of execution paths. It also achieves a modest 21%
and 40% reduction in running time and number of execution paths
respectivelywiththe PrintTokens2 benchmark.
JR reduces the number of execution paths by about 88% in re-
place but incurs an increase in executiontime by 187%. The 67.3%
reductioninthenumberofsolverqueriescausesa240%increase
insolvertimespentbyJR.Inthefuture,weplantomitigatesuch
negative effects of path-merging by integrating JR with a query
count estimationheuristic[ 20].
While not instantiating any statement, JR incurs a 2.6% running
time overhead on Siena. This primarily results from JR‚Äôs checking
if a conditional branch has symbolic operands and lookup of a
static statement for every symbolic branch. The total running time
of Schedule with SPF and JR is very small (1.5 and 2.5 seconds
respectively) compared to other benchmarks. JR‚Äôs static analysis
alwaysaddsabout2-3secondstothetotaltime:thisaccountsfor
loadingtheWALAframework,constructingaclasshierarchyfor
all classes in the classpath, and building the CFG for all methods in
WalaIR.OnbenchmarkslikeSchedulewithasmalltotalrunning
time,thisoverheadfromstaticanalysisisahigherpercentageof
the totalrunning time.
RQ2: Since path-merging brings symbolic execution closer to
symbolicboundedmodel-checking,wealsousedthesebenchmarks
to compare JR with JBMC [ 11]. JBMC is a Java model checker that
verifiesprogramsbyunwindingloopsandlooksforruntimeexcep-
tions.WeraneachofourbenchmarkswithJBMCwith thesame
number of non-deterministic inputs reported in the ≈Ç# sym inputs≈æ
columnofTable 2.WeconfiguredJBMCtounwindloopsineach
130Java Ranger: StaticallySummarizingRegions forEfficient SymbolicExecutionof Java ESEC/FSE ‚Äô20, November8≈õ13,2020,VirtualEvent, USA
Table 2:Comparingexecution timeandpath count between JRand SPF
Bench
mark
name#sym
inputtooltotal
time
(sec)%
red.
in
timestatic
analysis
time
(sec)#
exec.
paths%red.
in#
exec.
paths%red.
in#
que-
ries#
summ.
used
WBS15SPF4427.799.90.07.96E+06100100.00-
30JR4.2 2.31.00E+00 140
TCAS24SPF353.199.10.03.92E+04100100.00-
120JR3.1 1.71.00E+00 40
replace11SPF1145.3-187.00.07.57E+0588.167.30-
11JR3287.6 5.99.04E+04 6502
Nano
XML7SPF5741.446.20.03.61E+0684.681.00-
7JR3087.1 3.15.54E+05 147185
Siena6SPF5571.9-2.60.02.99E+0600.00-
6JR5715.6 7.32.99E+06 0
Schedule3SPF1.5-70.30.03.43E+0200.00-
3JR2.5 3.43.43E+02 0
Print
Tokens25SPF17045.821.30.03.06E+0640.438.70-
5JR13421.3 25.11.82E+06 1981982
Apache
CLI5+1SPF4121.445.70.02.48E+0592.999.10-
5+1JR2238.1 5.31.76E+04 168907
Mer
Arbiter24SPF9494.080.30.02.53E+0583.981.50-
24JR1873.4 3.64.08E+04 59845
Summary-SPF47901.938.1301.89E+0771 --
-JR29632.8 57.75.51E+06 2364601
Table3:ComparingtotalrunningtimeofSPF,JavaRanger,JBMCoverthe9benchmarksforverifyingtheabsenceofcommon
runtime errors. TO indicates timeout, given a7 day timelimit. Times forSPF andJRare reported inseconds.
tool
nameWBSTCASreplaceNano
XMLSienaSchedulePrint
Tokens2Apache
CLIMer
Arbiter
SPF 4427353.11145.3 5741.45571.9 1.517045.8 4121.4 9494
JBMC 0.72.2 TO TOTO5.62E+05 TO TO TO
Java Ranger 4.23.13287.6 3087.15715.6 2.513421.3 2238.1 1873.4
benchmarkagivennumberoftimesandtoaddanassertionwhose
violation indicates that a loop was not unrolled sufficient times.
We performed binary search to find the smallest loop bound for
each benchmark that would not cause a loop unwinding assertion
violation with JBMC. The smallest loop bounds we found with this
binarysearchforeverybenchmarkwereasfollows:ApacheCLI=39,
Siena=8,PrintTokens2=82,replace=12,NanoXML=10,Schedule=10,
WBS=11, TCAS=11. For MerArbiter, we could not get JBMC to
falsify a loop-unwinding assertion for any positive value of the
loop-unwinding parameter. Therefore, we finally ran it with a loop
boundof1.WeraneverybenchmarkpresentedinTable 1usingSPF,
JavaRanger andJBMCwhereallthreetoolslookedforcommon
runtime errors such as null dereferences, accessing out-of-bounds
entries in arrays, type cast errors, and division-by-zero errors. We
useda7daytimeoutforallthreetools.Weraneverybenchmark
with the same number of symbolic inputs with all three tools. The
numberofsymbolicinputsisreportedinthe # sym inputs column
ofTable2.WepresentourresultsinTable 3.Therowslabeled SPFandJava
Rangerrepeatthetimereportedinthe total time (sec) column
ofTable2.WefoundJBMCwasthefastestamongthethreetools
at being able to verify the absence of any runtime errors in both
WBSandTCAS.But,wefoundJBMCtobemuchslowerwiththe
remaining7benchmarks. JBMCwasable to completeverification
withScheduleinabout7days.Fortheremainingsixbenchmarks,
JBMCdidnot finish in7days as indicatedby TOinTable3.
RQ3: JR can be separatedintofourpath-mergingfeatures.
(F1)JR onlytransforms multi-pathregionswitha single NENR
exitpoint.Thisincludesmulti-pathregionsthathavelocal,stack,
field, orarray outputs.
(F2)JR inlines statements for methods called from a multi-path
regionintothe statementof the multi-path region.
(F3)JR instantiates staticstatements withan SPexit point
(F4)JR uses early-return summarization to allow statements to
have aRE exit point.
ToanswerRQ3,weevaluatedtheeffecteachfeaturehasasmore
features are cumulatively used in JR. We set up an experiment
131ESEC/FSE ‚Äô20, November8≈õ13,2020,VirtualEvent, USA Vaibhav Sharma,Soha Hussein, MichaelW. Whalen, Stephen McCamant,andWillem Visser
Table 4: Presenting the ratio of three metrics with path-
mergingtothesamethreemetricswithoutpath-mergingfor
7 benchmarks where any path-merging was done. A ratio
lessthan1indicatespath-mergingwasbeneficial(smalleris
better).Path-mergingfeaturesaccumulatefromlefttoright.
(a)Comparing running time
Bench
mark
namebasic
p.m.+method
inlining+single
path
cases+early
return
summ.
WBS 0.0007 0.0007 0.0007 0.0006
TCAS 0.39 0.01 0.01 0.01
replace 1.36 2.10 2.82 2.87
Nano
XML1.31 1.28 1.54 0.54
Print
Tokens20.88 0.76 0.78 0.79
Apache
CLI0.17 2.54 0.50 0.54
Mer
Arbiter0.24 0.21 0.21 0.20
(b) Comparing number of executionpaths
Bench
mark
namebasic
p.m.+method
inlining+single
path
cases+early
return
summ.
WBS 1.2E-07 1.2E-07 1.2E-07 1.2E-07
TCAS 0.24 2.5E-05 2.5E-05 2.5E-05
replace 0.63 0.90 0.12 0.12
Nano
XML1.00 1.00 1.00 0.15
Print
Tokens20.84 0.84 0.84 0.60
Apache
CLI0.07 0.07 0.07 0.07
Mer
Arbiter0.16 0.16 0.16 0.16
where starting with no path-merging (aka SPF), we added path-
merging features in the aforementioned order (F1-F4). For every
benchmark where any path-merging was performed, we computed
the ratio of a metric with a set of path-merging features enabled
to the same metric‚Äôs value seen without path-merging. The two
metrics we measured were the running time, the number of exe-
cutionpathsexplored.Wepresenttheresultsofthiscomparison
in Table4. The ≈Çbasic p.m.≈æ column represents only enabling of
theF1featureinJR.The≈Ç+methodinlining≈æcolumnenablesthe
F1 and F2 (inlining of method statements) features in JR. The ≈Ç+
single-pathcases≈æcolumnenablestheF1,F2,andF3(single-path
cases)featuresinJR.The≈Ç+earlyreturnsumm.≈æcolumnenablesall
thefourfeatures withearly-return summarization.Table 4shows
summarizingmulti-pathregionsthathaveaNENRexitpoint(F1)is
mostoftenuseful.Thisobservationmatchesourintuitionthatsuch
multi-pathregionsoccurmostfrequentlyinJava.Theadditionof
method statement inlining (F2) provides a major reduction in allthreemetricsinTCAS.Thisobservationmatchesanobservation
made manually from TCAS‚Äô source code that multi-path regions in
itofteninvokemethodsthatcanbesummarizedbyJavaRanger.The
addition of single-path cases (F3) provides a major reduction in the
numberofsolverqueriesinthereplaceandNanoXMLbenchmarks.
Early-returnsummarization(F4)providesasignificantreduction
in the number of execution paths and number of solver queries
intheNanoXMLand PrintTokens2benchmarks.The benefitfrom
this featureresultsfrom thesebenchmarkscontainingmulti-path
regions that contain multiple RE exit points. Table 4shows that
everypath-mergingfeaturepresentinJRhasabeneficialimpact
onat leastone benchmarkinour set.
Table 5: Comparing Java Ranger with participants of the
JavaOverallcategory ofSV-COMP2020
tool score#correct
true results#correct
false results#incorrect
results
JayHorn[ 18] 278 109 92 1
SPF [24] 442 135 172 1
COASTAL[ 13] 472 135 202 0
JDart [21] 524 150 224 0
JBMC[11] 527 151 225 0
Java Ranger 549 173 203 0
RQ4:JavaRangerparticipatedinastaticverificationcompetition
namedSVComp[ 29]Thecompetitionconsistedof aJavaverifica-
tiontrackinwhichsixJavaverifierscompetedover416benchmark
programs. Thesebenchmarksspannedregression tests introduced
byeachoftheparticipatingtools.Thebenchmarksalsoincluded
implementations of algorithms for commonly used data structures
such as tries and red-black trees. The competition‚Äôs setup placed a
totalmemorylimitof15GBandalimitof8CPUcores.Thewall
time limit for running each benchmark in the competition was 15
minutes. We report the results from our participation as well as
scores ofallcompetition participants inthe Java track inTable 5.
JavaRangerwasthebestperformingtoolintheJavaverification
trackinthecompetition[ 38].Ofthetotal416Javaverificationtasks
thatwereusedinthecompetition,JavaRangerinstantiatedatleast
onestaticstatementon96differentbenchmarks.Thestaticstate-
mentforamulti-pathregioncanbeinstantiatedmorethanonce
oneachbenchmarkbecauseitispossibleforthesymbolicexecutor
toencounterthesamemulti-pathregionmorethanoncewhilerun-
ning the benchmark. In total, Java Ranger instantiated 356 distinct
static statements with the total number of instantiated statements
being20,182.JavaRangeralsoinlinedamethodstatementatotal
of62,857times whileinstantiating staticstatements.
JavaRangerfinishedwitha≈Çunknown≈æresulton40ofthe416
verification tasks used in the competition. 22 of these were caused
duetoalackofsupportforsymbolicstrings.JavaRangerdefaultsto
vanillaSPFwhenitfindsnoopportunityforpath-merging.Onthese
22benchmarks,SPF‚Äôslackofstablesymbolicstringsupportcaused
a crash. Similarly, 9 of the 40 ≈Çunknown≈æ results occurred due to
missingsupportforsymbolicarraylengthsinmulti-dimensional
132Java Ranger: StaticallySummarizingRegions forEfficient SymbolicExecutionof Java ESEC/FSE ‚Äô20, November8≈õ13,2020,VirtualEvent, USA
arraysinSPF.8ofthe40≈Çunknown≈æresultsranintoatimeout.The
last ≈Çunknown≈æ result was caused due to our limiting of the depth
ofexplorationchoicesfor the competition.
5 DISCUSSION & FUTUREWORK
JavaRanger attempts toperformpathmerging wheneverpossible
without optimizing towards making fewer solver calls. We plan
to work towards implementing heuristics that can measure the
effect of path merging on the rest of the program. JR currently
lacks support for symbolic object and array references. Supporting
these would require integrating our implementation with SPF‚Äôs
lazy initialization [ 24] to let summaries contain symbolic object
references.
Generating test cases that cover all branches is a useful applica-
tionofdynamicsymbolicexecution.Ifappliedas-is,testgeneration
will undo the benefits of path-merging. We intend to extend JR
towardstestgenerationformergedpathsinthefuturebytarget-
ingtestgenerationtowardsacoveragecriterionsuchasModified
Condition/Decision Coverage.
Pathmergingallowssymbolicexecutiontoexploreinteresting
partsofaprogramsooner.But,theeffectofpathmergingonsearch
strategies,suchasdepth-firstsearchremainstobeinvestigated.We
plantoexploretheintegrationofsuchguidanceheuristicswithpath
merging in the future. Finally, we plan to expand on our formalism
to prove completenessas well as soundness.
6 CONCLUSION
Wehave investigatedtheuse ofstatic summarizationstoimprove
the performance of symbolic execution of Java. For good perfor-
mance,wehadtoextendearlierworktoaccountforJava‚Äôsdynamic
dispatch and likelihood of exceptions. Our experiments demon-
strate that static summarization may yield significant performance
improvements over single-path symbolic execution. Java Ranger
providesevidencethatinliningmethodsummarizationsbyusing
typeinformationavailableatruntimecanleadtoafurtherreduc-
tioninthenumberofexecutionpaths.JavaRanger‚Äôsuseofpath-
mergingiscrucialtogivingitanedgeoverexistingJavaverifiers
as demonstrated by its participation in a static verification com-
petitioninatoptheoryconference.JavaRangerreinterpretsand
extends path merging for symbolic execution of Java bytecode and
may allow symbolic execution to scale to exploration of real-world
Java programs.
ACKNOWLEDGMENT
The research described in this paper has been supported in part by
the Google Summer of Code program and by the National Science
Foundationundergrant 1563920.
REFERENCES
[1]2014.ISSTA2014:Proceedingsofthe2014InternationalSymposiumonSoftware
TestingandAnalysis .AssociationforComputingMachinery,NewYork,NY,USA.
[2]Alfred V Aho, Ravi Sethi, and Jeffrey D Ullman. 2007. Compilers: principles,
techniques, and tools . Vol. 2. Addison-wesleyReading,MA,USA.
[3]Thanassis Avgerinos, Alexandre Rebert, Sang Kil Cha, and David Brumley. 2014.
Enhancing Symbolic Execution with Veritesting. In Proceedings of the 36th Inter-
national Conference on Software Engineering (ICSE 2014) . ACM, New York, NY,
USA,1083≈õ1094. https://doi.org/10.1145/2568225.2568293[4]Domagoj Babiƒá, Lorenzo Martignoni, Stephen McCamant, and Dawn Song.
2011. Statically-Directed Dynamic Automated Test Generation. In Proceed-
ings of the 2011 International Symposium on Software Testing and Analysis (IS-
STA ‚Äô11). Association for Computing Machinery, New York, NY, USA, 12≈õ22.
https://doi.org/10.1145/2001420.2001423
[5]RobertoBaldoni,EmilioCoppa,DanieleConoD‚Äôelia,CamilDemetrescu,andIrene
Finocchi. 2018. A Survey of Symbolic Execution Techniques. ACM Comput. Surv.
51,3,ArticleArticle50(May2018),39pages. https://doi.org/10.1145/3182657
[6]Dirk Beyer, Alessandro Cimatti, Alberto Griggio, M. Keremoglu, and Roberto
Sebastiani. 2009. Software model checking via large-block encoding. 9th Interna-
tionalConference Formal Methodsin ComputerAidedDesign, FMCAD2009 ,25 ≈õ
32.https://doi.org/10.1109/FMCAD.2009.5351147
[7]J. Burnim and K. Sen. 2008. Heuristics for Scalable Dynamic Test Generation. In
2008 23rd IEEE/ACM International Conference on Automated Software Engineering .
IEEE,NewYork, NY, USA,443≈õ446. https://doi.org/10.1109/ASE.2008.69
[8]Cristian Cadar, Daniel Dunbar, and Dawson Engler. 2008. KLEE: Unassisted and
Automatic Generation ofHigh-Coverage Tests for Complex Systems Programs.
InProceedings of the 8th USENIX Conference on Operating Systems Design and
Implementation(OSDI‚Äô08) . USENIXAssociation, USA,209≈õ224.
[9]Vitaly Chipounov, Volodymyr Kuznetsov, and George Candea. 2012. The S2E
Platform: Design, Implementation, and Applications. ACM Trans. Comput. Syst.
30,1 (2012), 2:1≈õ2:49. http://doi.acm.org/10.1145/2110356.2110358
[10]Lori A. Clarke. 1976. A System to Generate Test Data and Symbolically Execute
Programs. IEEETrans.SoftwareEng. 2,3(1976),215≈õ222. https://doi.org/10.1109/
TSE.1976.233817
[11]LucasCordeiro,PascalKesseli,DanielKroening,PeterSchrammel,andMarek
Trtik.2018. JBMC:ABoundedModelCheckingToolforVerifyingJavaBytecode.
InComputer Aided Verification , Hana Chockler and Georg Weissenbacher (Eds.).
SpringerInternational Publishing,Cham,183≈õ190.
[12]LeonardodeMouraandNikolajBj√πrner.2008. Z3:AnEfficientSMTSolver.In
ToolsandAlgorithms fortheConstruction and Analysis ofSystems ,C. R. Ramakr-
ishnanandJakobRehof(Eds.).SpringerBerlinHeidelberg,Berlin,Heidelberg,
337≈õ340.
[13] Jaco Geldenhuys,JustinStigling,andWillemVisser.2020. COASTAL:Concolic
analysis toolfor Java. https://github.com/DeepseaPlatform/coastal . (2020).
[14]PatriceGodefroid.2007. CompositionalDynamicTestGeneration. SIGPLANNot.
42,1 (Jan. 2007),47≈õ54. https://doi.org/10.1145/1190215.1190226
[15]Patrice Godefroid, Nils Klarlund, and Koushik Sen. 2005. DART: Directed Auto-
mated Random Testing. In Proceedings of the 2005 ACM SIGPLAN Conference on
ProgrammingLanguageDesignandImplementation(PLDI‚Äô05) .ACM,NewYork,
NY, USA,213≈õ223. https://doi.org/10.1145/1065010.1065036
[16]Trevor Hansen, Peter Schachte, and Harald S√πndergaard. 2009. State Joining
and Splitting for the Symbolic Execution of Binaries. In Runtime Verification ,
Saddek Bensalem and Doron A.Peled (Eds.). SpringerBerlin Heidelberg,Berlin,
Heidelberg, 76≈õ92.
[17]IBM. 2006≈õ2020. WALA. http://wala.sourceforge.net/wiki/index.php/Main_Page .
(2006≈õ2020). Accessed:2018-11-16.
[18]TemesghenKahsai,PhilippR√ºmmer,andMartinSch√§f.2019. JayHorn:AJava
Model Checker. In Tools and Algorithms for the Construction and Analysis of
Systems,DirkBeyer,MariekeHuisman,FabriceKordon,andBernhardSteffen
(Eds.).SpringerInternational Publishing,Cham,214≈õ218.
[19]James C. King. 1976. Symbolic Execution and Program Testing. Commun. ACM
19,7 (1976), 385≈õ394. http://doi.acm.org/10.1145/360248.360252
[20]Volodymyr Kuznetsov, Johannes Kinder, Stefan Bucur, and George Candea. 2012.
EfficientStateMerginginSymbolicExecution.In Proceedingsofthe33rdACM
SIGPLANConferenceonProgrammingLanguageDesignandImplementation(PLDI
‚Äô12). ACM,NewYork, NY, USA,193≈õ204.
[21]Kasper Luckow, Marko Dimja≈°eviƒá, Dimitra Giannakopoulou, Falk Howar, Malte
Isberner,TemesghenKahsai,ZvonimirRakamariƒá,andVishwanathRaman.2016.
JDart: A Dynamic Symbolic Analysis Framework. In Proceedings of the 22nd
InternationalConferenceonToolsandAlgorithmsfortheConstructionandAnalysis
of Systems (TACAS) (Lecture Notes in Computer Science) , Marsha Chechik and
Jean-Fran√ßoisRaskin(Eds.),Vol. 9636.Springer, NewYork, NY, USA,442≈õ459.
[22]T. Nguyen, M. B. Dwyer, and W. Visser. 2017. Symlnfer: Inferring program
invariantsusingsymbolicstates.In 201732ndIEEE/ACMInternationalConference
on Automated Software Engineering (ASE) . 804≈õ814. https://doi.org/10.1109/ASE.
2017.8115691
[23]KarlJ.Ottenstein,RobertA.Ballance,andArthurB.MacCabe.1990. TheProgram
DependenceWeb:ARepresentationSupportingControl-,Data-,andDemand-
drivenInterpretationofImperativeLanguages.In ProceedingsoftheACMSIG-
PLAN 1990 Conference on Programming Language Design and Implementation
(PLDI ‚Äô90) . ACM, New York, NY, USA, 257≈õ271. https://doi.org/10.1145/93542.
93578
[24]Corina S. PƒÉsƒÉreanu, Willem Visser, David Bushnell, Jaco Geldenhuys, Peter
Mehlitz, and Neha Rungta. 2013. Symbolic PathFinder: integrating symbolic
execution with model checking for Java bytecode analysis. Automated Software
Engineering 20, 3 (01 Sep 2013), 391≈õ425. https://doi.org/10.1007/s10515-013-
0122-2
133ESEC/FSE ‚Äô20, November8≈õ13,2020,VirtualEvent, USA Vaibhav Sharma,Soha Hussein, MichaelW. Whalen, Stephen McCamant,andWillem Visser
[25]DavidARamosandDawsonR.Engler.2011. Practical,Low-effortEquivalence
Verification of Real Code. In Proceedings of the 23rd International Conference
on Computer Aided Verification (CAV‚Äô11) . Springer-Verlag, Berlin, Heidelberg,
669≈õ685. http://dl.acm.org/citation.cfm?id=2032305.2032360
[26]Koushik Sen, Darko Marinov, and Gul Agha. 2005. CUTE: A Concolic Unit
TestingEngineforC.In Proceedingsofthe10thEuropeanSoftwareEngineering
Conference Held Jointly with 13th ACM SIGSOFT International Symposium on
FoundationsofSoftwareEngineering(ESEC/FSE-13) .ACM,NewYork,NY,USA,
263≈õ272. https://doi.org/10.1145/1081706.1081750
[27]Koushik Sen, George Necula, Liang Gong, and Wontae Choi. 2015. MultiSE:
Multi-path Symbolic Execution Using Value Summaries. In Proceedings of the
2015 10thJoint Meeting on Foundations of Software Engineering (ESEC/FSE 2015) .
ACM,NewYork, NY, USA,842≈õ853. https://doi.org/10.1145/2786805.2786830
[28]V.Sharma,K.Hietala,andS.McCamant.2018. FindingSubstitutableBinaryCode
forReverseEngineeringbySynthesizingAdapters.In 2018IEEE11thInternational
ConferenceonSoftwareTesting,VerificationandValidation(ICST) .IEEEComputer
Society,LosAlamitos,CA,USA,150≈õ160. https://doi.org/10.1109/ICST.2018.00024
[29]VaibhavSharma,SohaHussein,MichaelW.Whalen,StephenMcCamant,and
Willem Visser. 2020. Java Ranger at SV-COMP 2020 (Competition Contribution).
InToolsandAlgorithmsfortheConstructionandAnalysisofSystems ,ArminBiere
and David Parker (Eds.).SpringerInternational Publishing,Cham,393≈õ397.
[30]VaibhavSharma,SohaHussein,MichaelW.Whalen,StephenMcCamant,and
Willem Visser. 2020. java-ranger: v1.0.0. (Jun 2020). https://doi.org/10.5281/
zenodo.3907232
[31]Yan Shoshitaishvili, R. Wang, C. Salls, N. Stephens, M. Polino, A. Dutcher, J.
Grosen, S.Feng,C. Hauser,C. Kruegel,and G.Vigna. 2016. SOK:(State of)The
ArtofWar:OffensiveTechniquesinBinaryAnalysis.In 2016IEEESymposiumon
Security and Privacy (SP) . IEEE, New York, NY, USA, 138≈õ157. https://doi.org/10.
1109/SP.2016.17
[32]NickStephens,JohnGrosen,ChristopherSalls,AudreyDutcher,RuoyuWang,
Jacopo Corbetta, YanShoshitaishvili, Christopher Kruegel, and Giovanni Vigna.
2016. Driller: Augmenting Fuzzing Through Selective Symbolic Execution. In
23rdAnnualNetworkandDistributedSystemSecuritySymposium,NDSS2016,San
Diego,California,USA,February21-24,2016 .TheInternetSociety,SanDiego,CA,1≈õ16.
[33]Wei Sun, Lisong Xu, and Sebastian Elbaum. 2017. Improving the Cost-
effectiveness of Symbolic Testing Techniques for Transport Protocol Implemen-
tationsUnderPacketDynamics.In Proceedingsofthe26thACMSIGSOFTInterna-
tionalSymposiumonSoftwareTestingandAnalysis(ISSTA2017) .ACM,NewYork,
NY, USA,79≈õ89. https://doi.org/10.1145/3092703.3092706
[34]PengTuandDavid Padua.1995. EfficientBuilding andPlacingofGatingFunc-
tions. In Proceedings of the ACM SIGPLAN 1995 Conference on Programming
Language Design and Implementation (PLDI ‚Äô95) . Association for Computing
Machinery, NewYork, NY, USA,47≈õ55. https://doi.org/10.1145/207110.207115
[35]Willem Visser, Jaco Geldenhuys, and Matthew B. Dwyer. 2012. Green: Reduc-
ing, Reusing and Recycling Constraints in Program Analysis. In Proceedings
of the ACM SIGSOFT 20th International Symposium on the Foundations of Soft-
ware Engineering (FSE ‚Äô12) . ACM, New York, NY, USA, Article 58, 11 pages.
https://doi.org/10.1145/2393596.2393665
[36]Willem Visser, Klaus Havelund, Guillaume Brat, SeungJoon Park, and Flavio
Lerda.2003. ModelCheckingPrograms. AutomatedSoftwareEngineering 10,2
(01 Apr 2003),203≈õ232. https://doi.org/10.1023/A:1022920129859
[37]H. Wang, T. Liu, X. Guan, C. Shen, Q. Zheng, and Z. Yang. 2017. Dependence
Guided Symbolic Execution. IEEE Transactions on Software Engineering 43, 3
(March2017),252≈õ271. https://doi.org/10.1109/TSE.2016.2584063
[38]Phillipp Wendler. 2020. SV-COMP 2020 ≈õ JavaOverall ≈õ BenchExec
Results. https://sv-comp.sosy-lab.org/2020/results/results-verified/META_
JavaOverall.table.html . (2020).
[39]Khaled Yakdan, Sebastian Eschweiler, Elmar Gerhards-Padilla, and Matthew
Smith.2015. NoMoreGotos:DecompilationUsingPattern-IndependentControl-
FlowStructuringandSemantics-PreservingTransformations.In The2015Network
and Distributed System Security Symposium . The Internet Society, Reston, VA,
USA.https://doi.org/10.14722/ndss.2015.23185
[40]Guowei Yang, Corina S. PƒÉsƒÉreanu, and Sarfraz Khurshid. 2012. Memoized
SymbolicExecution. In Proceedingsofthe 2012 International Symposiumon Soft-
ware Testing and Analysis (ISSTA 2012) . ACM, New York, NY, USA, 144≈õ154.
https://doi.org/10.1145/2338965.2336771
134