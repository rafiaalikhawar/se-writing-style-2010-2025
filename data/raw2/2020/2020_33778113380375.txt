Managing data constraints in database-backed web applications
Junwen Yang
University of Chicago, USA
junwen@uchicago.eduUtsav Sethi
University of Chicago, USA
usethi@uchicago.eduCong Yan
University of Washington, USA
congy@cs.washington.edu
Alvin Cheung
University of California, Berkeley
USA
akcheung@cs.berkeley.eduShan Lu
University of Chicago, USA
shanlu@uchicago.edu
ABSTRACT
Database-backed web applications manipulate large amounts of
persistent data, and such applications often contain constraints
thatrestrictdatalength,datavalue,andotherdataproperties.Such
constraintsarecriticalinensuringthereliabilityandusabilityof
theseapplications.Inthispaper,wepresentacomprehensivestudy
on where data constraints are expressed, what they are about, how
often they evolve, and how their violations are handled. The re-
sults show that developers struggle with maintaining consistent
dataconstraintsandcheckingthemacrossdifferentcomponentsand versions of their web applications, leading to various prob-
lems.Guidedbyourstudy,wedevelopedcheckingtoolsandAPI
enhancements that can automatically detect such problems and
improve the quality of such applications.
1 INTRODUCTION
1.1 Motivation
Constraints are often associated with data used in software. These
range from describing the expected length, value, uniqueness, and
other properties of the stored data. Correctly specifying and check-
ingsuchconstraintsarecrucialforsoftwarereliability,maintainabil-ity,andusability.Thisisparticularlyimportantfordatabase-backed
webapplications,whereahugeamountofdatageneratedbymil-
lionsofusersplaysacentralroleinuserinteractionandapplication
logic. Furthermore, such data persists in database and needs to
continueservingusersdespitefrequentsoftwareupgrades[ 10]and
datamigration[ 9].Asaresult,consistentlyandcomprehensively
specifyingdataconstraints,checkingthem,andhandlingconstraint
violationsare of uttermost importance.
To better understand these challenges, consider an issue [ 16]
reported by users of Redmine [ 19], a popular project-management
web application written using Ruby on Rails. When a user tried to
createawikipage,sheinitiallyleftthe titlefieldempty,whichled
tothe‚Äútitleisinvalid‚Äùerrormessageshownnexttothe titlefield;
she then put in a long title, but got a ‚Äútitle is too long (maximum is
Permissionto make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACM
mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ICSE ‚Äô20, May 23‚Äì29, 2020, Seoul, Republic of Korea
¬©2020Association for Computing Machinery.
ACM ISBN 978-1-4503-7121-6/20/05...$15.00
https://doi.org/10.1145/3377811.3380375
	 	 
	 &$
			


)	(		('	(	*

	 	  	
 
	 !%$"   


Figure 1: Crossstack data constraints
60 characters)‚Äù error; finally, she tried a title a little shorter than 60
characters,butthewebpagethencrashedwithallthefilledcontent
lostwithsomeunreadabledatabaseerror displayed.
It turned out that different constraints were specified for the
titlefield across different components in Redmine. As shown
inFigure1,thefront-endHTMLfile views/wiki/new.html.erb
usedaregularexpression‚Äú.+"tospecifythatthetitleshouldhavea
positivelength;theapplicationmodelfile models/wiki.rb instead
usedRails validates_length_of APItolimitthemaximumtitle
length to be 60; finally, in the database schema file schema.rb , the
titlefieldisdeclaredas varchar(30) ,limitingthemaximumlength
to be 30.
Thisexample illustrates how common it is for database-backed
webapplicationstospecifyandcheckconstraintsforthesamepiece
of data in different code components: the front-end browser, the
applicationserver,andthedatabase.Assuchcomponentsareoften
separatelydevelopedandmaintained,theycouldholdconflicting
assumptions about the same piece of data. Such inconsistencies
canlead tovariousreliability andusabilityproblems. Particularly,
apieceof datathatpassesallbutthedatabase checkingoftenleads
to a web-page crash, as in the above example.
Consider another example in Diaspora [ 22], the most popular
social network application written using Ruby on Rails (according
to application-stars in Github). In earlier versions, the password
lengthisallowedtobethreecharactersorshorter.Inoneversion,
developersdecidedthatpasswordsshouldbelonger,probablyfor
security concerns. They then added a constraint ‚Äú......+‚Äù to the pass-
word field of the log-in page, requiring the password to be at least
6 characterslong. Asa result, manyusers, whose passwordswere
*&&&"$.OE*OUFSOBUJPOBM$POGFSFODFPO4PGUXBSF&OHJOFFSJOH	*$4&
Table 1: Highlight results of our study
(*:alltheidentified issues are in latest versions of these applications)
RQ1: How are constraints specified in one software version?
How 2.1 per 100 LoC
Many? 1.4 per 1 data field
77% of data fields have constraints
Where?76% in DB; 23% in application; 1% in front-end24% of application constraints are missing in DB
RQ2: How are constraints specified across versions?
49% of versions contain constraint changes>25% of changes tighten constraints on existing data fields
RQ3: What led to real-world constraint problems?
Where 21% of 114 studied issuesWhat 51% of 114 studied issuesWhen 10% of 114 studied issues
How 18% of 114 studied issues
RQ4: Can we identify constraint problems in latest version?
Where 1000+ string fields have length constraints in DB but not in app.
200+ fields forbidden to be nullin app. but nullby default in DB
88 fields required to be unique in app. but not so in DB
57 in(ex)clusion constraints specified in app. but missed in DB133 conflicting length/numericality constraints between app. and DB
What 19 incorrect case-sensitivity constraints identifiedHow 2 missing error-message problems identified
API default error-message enhancement preferred in user study
shorter than 6 characters, can no longer log in and are shown with
the unhelpful‚ÄúPlease use the required format‚Äù error.
Thisexampledemonstratesthatinasoftwareworldwherenoth-
ingenduresbutchange,itischallengingtomakelong-livingper-
sistentdataendurefrequentcodechanges,whichmayintroduce
neworevenconflictingrequirementstopersistentdatafields.Such
a conflict can lead to upgrade failures, user-unfriendly error pages,
and software misbehavior, like that in the above examples.
Insummary,effectivelymanagingconstraintsforthehugeamount
of persistent data in database-backed web applications (short as
web applications) is critical and challenging. To understand the
challenges involved, we first perform a comprehensive study to
understand the specification, checking, maintenance, and violation
handlingof data constraints in web applications.
1.2 Contributions
In this paper, we aim to answer four key research questions about
real-worlddatabase-backedwebapplications,aslistedinTable1bycomprehensivelystudyingthesourcecode,thecommithistory,and
the issue-tracking system of 12 popular Ruby on Rails applications
thatrepresent 6 most common web-application categories.
For RQ1, we wrote scripts to collect and compare constraints
expressed in various components of the latest versions of the 12
applications. We found that about three-quarter of all data fields
are associated with constraints. In total, there are hundreds to over
one thousandconstraints explicitly specified in each application,
averaging1.1‚Äì3.6constraintsspecifiedper100linesofcode.Data
presenceanddatalengtharethetwomostcommontypesofcon-
straints, while complicated constraints like the relationship among
multiplefieldsalsoexist.Wealsofoundthathundredstothousands
of constraints specified inthe database are missing in the applica-
tion source code, and vice versa, which can lead to maintenance,
functionality,andperformanceproblems.Thedetailsarepresented
in Section 4.ForRQ2,wecheckedhowdataconstraintschangethroughout
the applications‚Äô development history. We found that about 32%
of all thecode changes related todata constraints is aboutadding
new constraints or changing existing ones on data fields that have
alreadyexistedinsoftware.Thesechanges,regardlessofwhether
theyareduetodevelopers‚Äôearliermistakesorwarrantedbynew
code features, can easily lead to upgrade and usage problems for
datathatalreadyexistsinthedatabase.ThedetailsareinSection5.
For RQ3, we thoroughly investigated 114 real-world issues that
are related to data constraints. We categorize them into four major
anti-patterns: (1) inconsistency of constraints specified at different
places, which we refer to as the Whereanti-pattern; (2) inconsis-
tency between constraint specification and actual data usage in
the application, which we refer to as the Whatanti-pattern; (3)
inconsistencybetween data/constraintsbetween differentapplica-
tionversions,whichwerefertoasthe Whenanti-pattern;and(4)
problemswithhowconstraint-checkingresultsaredelivered(i.e.,
unclearormissingerrormessages),whichwerefertoasthe How
anti-pattern. These four anti-patterns are all common and difficult
to avoid by developers; they led to a variety of failures such as
web-pagecrashes,silentfailures,software-upgradefailures,poor
userexperience, etc. The details are presented in Section 6.
ForRQ4,wedevelopedtoolsthatautomaticallyidentifymany
data-constraint problems in the latest versions of these 12 appli-
cations, as highlighted in Table 1. We found around 2,000 ‚ÄúWhere‚Äù
problems, including many fields that have important constraintsspecified in the database but not in the application or vice versa,as well as over 100 fields that have length or numericality (i.e.,
numericaltypeandvaluerange)constraintsspecifiedinboththe
database and the application, but the constraints conflict with each
other. We also found 19 issues in which the field is associated
withcase-insensitiveuniquenessconstraints,butareusedbythe
application in a case-sensitive way (the ‚ÄúWhat‚Äù anti-pattern), as
well as two problems related to missing error messages (the ‚ÄúHow‚Äù
anti-pattern). We manually checked around 200 randomly sampled
problems and found a low false positive rate (0‚Äì10%) across dif-
ferenttypesofchecks.Nottooverwhelmapplicationdevelopers,
we reported 56 of these problems to them, covering all problem
categories.Wereceived49confirmationfromthedevelopers(nofeedback yet to the other 7 reports), among which our proposedpatches for 23 of those problems have already been merged into
theirapplicationsor included in the next major release.
WealsodevelopedaRubylibrarythatimprovesthedefaulterror
messagesoffiveRailsconstraint-checkingAPIs.Weperformeda
user study with results showing that web users overwhelmingly
prefer our enhancement. The details are presented in Section 7.
Overall, this paper presents the first in-depth study of data con-
straintproblemsinwebapplications.Ourstudyprovidesmotiva-
tionsandguidelinesforfutureresearchtohelpdevelopersbetter
managedataconstraints.Wehavepreparedadetailedreplication
packageforthedata-constraint-issuestudyandthedata-constraint
checking tools inthis paper. Thispackage is available onthe web-
pageofouropen-sourceHyperloopproject[ 12],aprojectthataims
to solve database-related problems in ORM applications.
2
Table 2: Different types of constraints in web apps
Run-timecheck Source-code Specification Specification
location location language API
Front end View HTML Reg. expression
ApplicationserverModel Ruby Built-in validation API
Model Ruby Custom validation API
Model/Controller Ruby Custom sanity check
DatabaseserverMigrationfiles Ruby ActiveRecord::Migration API
Migrationfiles SQL SQL ALTERTABLE queries
2 BACKGROUND
2.1 Architecture of web applications
Applications built using the Ruby on Rails framework are struc-
tured using the model-view-controller (MVC) architecture. For
example, when a web user submit a form through a URL like
http://foo.com/wikis/new/title=release ,acontroller action
‚Äúwikis/create ‚Äù is triggered. This action takes in the parameters
fromtherequest(e.g.,‚Äú release‚ÄùintheURLas params[:title] )
and interacts with the database by calling the ActiveRecord API
implementedbytheRailsObject-RelationalMapping(ORM)frame-
work. Rails translates ActiveRecord function calls into SQL queries
(awritequeryinthiscase),whoseresultsarethenserializedinto
modelobjects (e.g., the Wikimodel) and returned to the controller.
Thereturnedobjectsarethenpassedtothe viewfilestogenerate
a webpagethat issent backto users. Eachmodel isderived from
ActiveRecord , and is mapped to a database table by Rails. A view
file (ends with .erbor.haml) usually involves multiple languages
includingHTML, JavaScript, and Ruby.
2.2 Constraintsin web applications
Weroughlycategorizedataconstraintsintothreetypesbasedon
where they are checked and specified as shown in Table 2.
Front-endconstraints. Developerscanuseregularexpressions
to specify constraints about a particular HTML data-field insidea view file, such as the
pattern=‚Äò.+‚Äô for the titlefield in Fig-
ure 1. The majority of such constraints are related to persistent
data maintained by the database.
Suchconstraintsarecheckedwhentheusersubmitsawebform.
Failuretovalidatewillcausetheformsubmissiontofail,withan
error message specified by developers shown next to the corre-
spondingHTMLfield,withallthepreviouslyfilledcontentsremain
on the page.
Application constraints. Rails developers use validation func-
tionstospecifyconstraintsofdatafieldsinmodelclasses.Similar
mechanisms exist in other ORM frameworks, such as validatorfunctions in Django [
6], and validator annotations in Hibernate
[11].
Avalidationfunctionisautomaticallytriggeredeverytimewhen
the application saves an object of the corresponding model class
(i.e.,whentheORMframeworksavesthecorrespondingrecordinto
the database). Validation failure will cause the corresponding form
tofail.Theerrormessageassociatedwiththevalidationfunction
will be shown to web users if developers put error checking and
error-messagedisplaycode in the view file.Rails validation functions include built-in ones, which cover
many common constraints like text-field lengths (i.e., validates_
length_of ,asshowninFigure1),contentuniqueness( validates_
uniqueness_of ), content presence ( validates_presence_of ), as
wellascustomones,wheredevelopersexpressmorecomplicated
constraintslike keeping a strict order among multiple fields.
Developerscanalsoconstrainadatafieldthroughcustomsanity
checks, althoughthey are uncommon in Rails.
Databaseconstraints. Many data columns are associated with
constraints inside the database (DB), like the varchar(30) con-
straint shown in Figure 1. These constraints are specified in the ap-plications‚Äô migration files, which are used to alter database schema
over time.The majorityofthem (morethan 99.5%in ourstudied
applications)arespecifiedthroughRailsMigrationAPIs,andare
veryrarelyspecifiedthroughSQLqueriesdirectly(<30casesacross
all 12 applications we checked).
These constraints are checked by the DB when an INSERTor
/UPDATEquerytothecorrespondingcolumnsisissued(eitherby
the application or DB administrator). If the check fails, the applica-
tion will throw an ActiveRecord::StatementInvalid exception
toindicateanunderlyingDBerror.Unfortunately,inpractice,de-
velopers almost nevercatch such exceptions (it is caught in only 4
cases across thousands of model object saves across the 12 applica-
tionswestudied).Hence,oncetriggered,thewebuser‚Äôssessionwill
most likely crash, with all the filled-in contents lost with a cryptic
SQL error shown to users.
Why are the constraints distributed across components?
Front-end constraints are specified for web-form input data, which
isoftenrelatedtoDBrecord(e.g.,usedasqueryparameters,com-
pared with query results, etc.). Validation functions and DB con-
straintsarespecifiedonlyfordatabasefields,andarecheckedright
before saving data into the DB. The expressiveness of these two
are similar ‚Äî most constraints that are expressible using validation
functions can also be written using SQL queries or migration APIs,
andviceversa.Complicatedconstraintsexpressedusingcustomval-
idation functions can be expressed in the DB layer as CONSTRAINT
CHECKs or custom stored procedures. However, neither layer can
replacetheothergiventheexistenceof‚Äúbackdoors,‚Äùe.g.,DBadmin-
istratorsupdatingdata using theDB console, or sharingthe same
DB across multiple applications. Both are common practices [4].
3 METHODOLOGY
3.1 Applicationselection
There are many ORM frameworks available (e.g., Ruby on Rails,
Django,Hibernate,etc.).Amongthem,Railsisthemostpopularon
Github.Thus,westudied12open-sourceRubyonRailsapplications,
including the top two most popular Ruby applications from sixmajor categories of web applications on GitHub: Discourse (Ds)and Lobster (Lo) are forums; Gitlab (Gi) and Redmine (Re) are
collaborationpplications;Spree(Sp)andRorecommerce(Ro)are
Ecommerce applications; Fulcrum (Fu) and Tracks (Tr) are Task-management applications; Diaspora (Da) and Onebody (On) are
socialnetworkapplications;OpenStreetmap(OS)andFallingFruit
(FF)aremapapplications.Allofthemhavebeenactivelydeveloped
for years, with hundreds to tens of hundreds of code commits.
3
Table 3: # of data-constraint issues in our study and the
total# of issues in the issue-tracking system
Ds Lo Gi Re Sp Ro Fu Tr Da OnFF OS
Studied 14 1 16 30 31 2 1 1 11 5 0 2
Total 46072201803812117480511415814703206400 17650
Table 4: # Data constraints in web applications
Ds Lo Gi Re Sp Ro Fu Tr Da On FF OS
DB 1403 137 1582 437 346 378 34 108 361 345 159 242
App 165 33 496 220 132 219 13 30 116 82 17 176HTML 0 2 18 32 0 0 0 2 1 11 0 0
Total 1568 172 2096 689 478 597 47 140 478 438 176 418
LoC 62k 11k 122k 35k 31k 17k 1.7k 13k 21k 14k 7.8k 14k
#Col 1180 150 1384 338 456 384 53 107 510 268 171 228
#ColC882 104 1140 297 312 272 32 82 348 228 146 174
%ColC75% 69% 82% 88% 68% 71% 60% 77% 68% 85% 85% 76%
LoC:Linesof code. #Col: number of data columns stored in the database. #Col C.:
numberofcolumnsassociatedwithconstraints.Customsanitychecknotconsidered.
3.2 Issueselection
Section 6 studies the root causes and symptoms of real-world data
constraintproblemsusing114reportssampledfromtheabove12
applications‚Äô issue-tracking systems. For the 9 applications that
have medium-size issue databases (i.e., 100‚Äì5000 total reports), we
randomly sampled 100 reports for each. For Redmine and Gitlab,
which have more than 10,000 reports, we randomly sampled 200
reports for each. For FallingFruit, which only has 17 reports, we
took all of them. Among the resulting 1317 sampled reports, we
manually checked all the reports that contain keywords like ‚Äúdata
format,‚Äù ‚Äúdata inconsistency,‚Äù ‚Äúdata constraint,‚Äù ‚Äúformat change,‚Äù
‚Äúformat conflict,‚Äù etc. We finally obtained 114 reports that are truly
related to data constraints, as shown in Table 3.
4 CONSTRAINTS IN ONE VERSION
To understand how many constraints are specified in software,
where they are located, and what they are about, we wrote scripts
to extract data constraints from the latest version of the 12 applica-
tions described in Section 3. Our scripts obtain a web application‚Äôs
AbstractSyntaxTree,checkwhichRubyvalidationAPIsandmi-
grationAPIs are used, and analyze their parameters.
Inthispaper,ourscriptcoversalltypesofconstraintslistedin
Table2exceptforCustomsanitychecksandrawSQLconstraints.
Botharerarelyusedintheseapplications(e.g.,rawSQLconstraintsare only specified in fewer than 30 times across all 12 applications).
Note that, when we report inconsistency or missing constraints,
we manually check to make sure the inconsistency/missing con-
straintisnot causedbyourscriptnot coveringthesetwotypesof
constraints.
4.1 How many constraints are there?
As shown in Table 4, there are many constraints in these appli-
cations. Across all applications, 60% - 88% of data columns areassociated with constraints and there exists 1.1 to 3.6 constraint
specifications for every 100 lines of code.Summary. Data constraint specification widely exists in all
types of web applications. Their consistency, maintenance, and
handlingaffect the majority of the application data.
4.2 Where are the constraints?
As shown in Table 4, DB constraints are the most common, con-
tributingto 58‚Äì90%of allthe constraints.Applicationconstraints
contribute10‚Äì42%,whilefront-endconstraintsarefew.Itissurpris-ingthatthenumberofDBconstraintsdifferssignificantlycompared
to application constraints, as both are supposed to be applied to
agivenpieceofpersistentdata(Section2.2).Furthermore,incon-
sistenciesbetweenthemcanleadtoapplicationcrashesasinthe
example shown in Figure 1. This led to the next few study items.
WhatDB constraints are missing in applications? Table5
examinesover4,000DBconstraintsthataremissinginapplications.
Alarmingly,aboutonequarterofthesemissingconstraints(more
than1,000intotal)involvestring/textdatawheredevelopersdid
not specify any length constraints in the application, yet length
constraintsareimposedbytheDB.Forexample,whenevercreatingatablecolumnoftype‚Äústring‚ÄùusingRailsmigrationAPI,bydefault,
Rails framework forces a length constraint of 255-character in the
database,yetmanyofthesestringfieldshavenolengthconstraints
specified through application validation functions. This mismatch
could lead to severe problems: if a user tries to submit a long para-
graph/articleinsuchaseeminglylimitlessfield,hisapplicationwillcrashduetoafailed
INSERTquery,asshowninFigure1.Infact,we
foundmanyreal-worldissuesreportingthisproblem(Sec.6.1),ulti-
mately leading to developers adding the corresponding constraints
in the application layer.
About2%ofthemissingconstraints,101intotalacrossthe12
applications, are associated with data fields that do not exist in the
application.Someofthemareupdatedandreadthroughexternal
scripts, but never through the web application; others are depre-
catedfieldsthathavealreadybeenremovedfromtheapplication
but not dropped yet from the DB. Although this does not lead to
immediatesoftwaremisbehavior,thesecasesreflectchallengesin
datamaintenanceandcouldcausefunctionalityproblemsinthefu-
ture. In addition, they cause performance problems as the database
needs to maintain deprecated data.
About one third of the missing constraints are automatically
satisfied by Rails or the DB and are hence benign. This includes
presence and numericality constraints associated with foreign-key
fields(‚ÄúForeignKey‚Äù):foreignkeyfieldsareautomaticallygenerated
byRailsandsatisfypresenceandnumericalityconstraintsinthe
DB.Meanwhile,therearealsoconstraintsthatareguaranteedby
the DB (‚ÄúSelfSatisfied‚Äù), like presence constraints guaranteed by
non-null default values specified in the DB, uniqueness constraints
guaranteed by an auto-increment property in the DB, etc.
The remaining one third of the constraints ("other") are diffi-
culttoanalyzeautomatically.Basedonourmanualsamplingand
checking, most are already satisfied by how the application pro-
cessesand generatescorresponding datafields.Although theydo
not cause problems currently, developers should nonetheless beinformedaboutthem,sothatcodechangescanbetestedagainst
these constraintsto prevent regression failures.
4
Table 5: # Constraints in DB but not in Application
Ds Lo Gi Re Sp Ro Fu Tr Da On FF OS All
StrLength 243 21 406 49 182 47 18 21 101 69 74 28 1259 (28%)
AbsentData 21 0 40 2 2 2 2 1 22 7 2 0 101 (2%)
ForeignKey 266 31 271 82 27 99 7 27 61 91 16 30 1008 (22%)
SelfSatisfied 192 16 161 84 28 9 2 18 3 20 8 31 572 (13%)
Others 446 39 429 126 77 89 2 29 143 82 26 64 1552 (35%)
Table 6: # Constraints in Application but not in DB
(only built-in validation constraints are listed)
Ds Lo Gi Re Sp Ro Fu Tr Da On FF OS All
Presence 8 5 37 15 38 49 5 5 34 3 1 9 209 (51%)
Unique 3 1 12 18 19 5 0 4 16 1 0 9 88 (21%)
Inclusion/Exclusion 7 1 13 11 2 0 2 0 7 5 0 9 57 (14%)
RegEx 8 5 10 7 0 9 0 0 11 4 0 3 57 (14%)
Numeric 0 0 0 0 0 1 0 0 0 0 0 0 1 (0.2%)
False-positive analysis Besidesthe‚ÄúOthers‚ÄùrowinTable5,the
other4rowsarecountedbyourstatic-checkingscript.Tocheckthe
accuracyofourscript,werandomlyexamined102casesfromthese
4rows.Amongthesecases,wefound7falsepositives:5arenotDB
constraintsbutaremistakenlyidentifiedduetosyntaxnothandledbyourscript;2‚ÄúStrLength‚Äùcasesactuallybelongto‚ÄúOthers,‚Äùasthe
length requirement is guaranteed by application semantics. These
102 cases include 58 ‚ÄúStrLength‚Äù cases, among which 5 are false
positives‚Äî3a r en o tD Bconstraints and 2 belong to ‚ÄúOthers‚Äù.
Whichapplicationconstraintsarenotindatabase? Nearly
25% of the constraints specified through application validation are
missing in the DB. Table 6 breaks down the ones specified through
built-invalidationfunctionsbasedontheconstrainttype(412intotal). These missing constraints allow users to directly changepersistentdatausingSQLqueriesinwaysthataredisallowedby
theapplication,causingfunctionalityorevensecurityproblems.1
Furthermore,someofthesemissingconstraintsrepresentmissed
query optimization opportunities, such as improving cardinality
estimationin query plan generation using such constraints [35].
About half of these missing constraints are presence constraints.
Thatis,afield fisrequiredtobenon-nullintheapplication,butis
notrequiredsointheDB‚Äîtheirdefaultvaluesareironicallyset
tobenullintheDB.Whenusersoradministratorsdirectlyinsert
recordsinto theDBwithoutspecifyingthe valueforafield f,the
DBwouldaccepttheserecordsandputnullinto f.Subsequently,
when such records are retrieved and used in the application that
assumesall fto be non-null, software failures could occur.
Another category of missing constraints that can easily cause
problemsareuniquenessconstraints.WithoutbeingspecifiedintheDB,auniquenessconstraintoften
cannotbeguaranteedbytheap-
plication[ 13,14]:webuserscouldmakeconcurrentupdaterequests
1Itiscommonthatdatabaseadministratorsdirectlychangedatabasedatausingqueries
andscripts,bypassingtheapplicationserver.Table 7: Top 5 popular types of different layer
DB Presence Length Numericality Uniqueness -
1822 (32.9%) 1784 (32.3%) 1650 (29.8%) 276(5.0%) -
App. Presence Length Uniqueness Numericality Inclusion
888 (52.3%) 218(12.8%) 209 (12.3%) 101(5.9%) 67 (3.9%)
HTML Presence Length Format - -
52 (78.8%) 11 (16.7%) 3 (4.5%) - -
thatsaveduplicatevaluesintotheDB,violatingtheuniquenesscon-
straintand causingsoftware failures and maintenance challenges.
Regularexpressionandinclusion/exclusionconstraintsarerarely
found in the DB layer. While these can be enforced via procedures
orENUMtypes, they are not natively supported by the Rails DB
migrationAPIsandhavetobeexplicitlyspecifiedviaSQL,which
might be a reason why they tend to be missed in the DB. Inclu-sion/exclusion constraints limit the value of a field to a small set
of constants and would be very useful in avoiding data corruption,
saving storage space, and improving database performance (e.g.,
through DB selectivity optimization) if they are present.
The single numeric constraint in Table 6 is a ‚Äúphone number‚Äù
fieldthatisspecifiedtobenumericinapplicationbutstoredasa
‚Äústring‚Äùin the database.
False-positive analysis We randomly sampled and examined 10
cases from each of the 4 main categories in Table 6 (Presence,Unique, In/Ex-clusion, RegEx). 3 out of the 40 sampled cases are
falsepositives(2,0,0,1inthe4categories,respectively)‚Äîsyntax
corner cases caused our script to identify 1 spurious presence con-
straint, and theremaining 2 are related to conditional constraints.
Summary. Hundreds and thousands of database constraints
do not exist in application, and vice versa. The majority of thesediscrepancies can actually lead to bad user experience (missing
stringlengthconstraints),databasemaintenancechallenges(data
fieldsthatarenolongerusedintheapplication),codemaintenance
challenges (constraints implicitly guaranteed by the application
logic), data corruptions, software failures, or sub-optimal database
performance (missing DB constraints). They can be avoided by
implementingconstraintsintheapplicationandasSQLconstraints
in the database. However, in practice inconsistencies are likely
inevitable if we only rely on developers‚Äô manual effort. It would be
helpful to develop automated techniques that coordinate database
and applicationconstraints.
4.3 Whattypes of constraints are there?
Standard types. Table 7 shows the most popular constraint
types among all front-end, application built-in validation, and DB
constraints.Thetop2mostpopulartypesareconsistentlypresence
and length.
Customvalidationconstrainttypes. Customvalidationfunc-
tions are used much less often than built-in ones, but are not rare,
contributing about 5% to slightly over 25% of all application valida-
tion functions across the 12 applications (avg. 18% across all apps).
Werandomlysampled50customvalidationfunctionsandfound
that more than half of them are used to check multiple fields at the
sametime(27outof50),likethefunction presence_of_content
5
Table 8: App. versions with constraint changes (#Version C)
DsLoGi Re Sp Ro FuTr Da On FF OS
#Version 316 19 1040 159 253 31 7 26 39 86 12 95
#Version C187 18 563 44 89 20 4 12 26 18 10 41
%Version C59% 95% 54% 28% 35% 65% 57% 46% 67% 21% 83% 43%
Alltypes in Table 2 except for custom sanity checks are considered.
Red apps use a release as a version; Black apps use every 100 commits as a version.
in the StatusMessage model from Diaspora, which requires that
at least one of the fields textorphotosbe non-empty. These cus-
tom validations seldom have corresponding constraints in DB ‚Äî
only 4 out of the 50 we sampled exist in DB.
Customsanitychecktypes. Wealsosampled20sanitychecks
on input parameters from the controller code of 5 applications.
Amongthese20checks,themajority(17)areindeedcheckingin-
puts that are related to persistent data stored in the DB. Among
these 17, 5 are about data constraints, including presence and in-
clusion constraints, while the others are related to conditional data
update/re-processing.Amongthese5constraints,only1isspecified
in an application validation function and none exists in the DB.
Summary. Althoughsimpleconstraintslikepresence,length,
and numericality are the most common, more complicated con-straints, such as those involving multiple fields, are also widelyused. Most of the custom constraints are missing from the DB,
while constraints reflected by sanity checks are often missing in
boththeapplicationandDB.Futureresearchthatcanautomaticallyreasonaboutcustomsanitychecksandcustomvalidationfunctions
can greatly help to identify and add missing constraints.
5 CONSTRAINTS ACROSS VERSIONS
Thesoftwaremaintenancetaskforwebapplicationscomeswiththe
extra burden of database maintenance, including both data format
changes,likeaddingordeletingatablecolumn,anddataconstraint
changes, like changing the length requirement of a password field.
In this section, we study how constraints evolve across versions
and the related data-maintenance challenges.
How often do constraint-related changes occur? We first
checked the first commit of each application, and found nodata
constraintsinallbut3applications(Ds,Lo,FF).Forallapplications,
the majorityof the constraints were added in later commits.
AsshowninTable8,21‚Äì95%(avg.49%acrossallapps)ofcode
versionscontaindataconstraintsthataredifferentfromthosein
its previous version, indicating that constraint changes are com-
mon. Note that, for most applications, we treat one code release as
oneversion;for4applicationsthatdonotspecifyrelease/version
information,we treat every 100 code commits as one version.
Whattriggeredchanges? We categorize all the cross-version
changesaboutDBconstraintsandapplicationvalidationconstraints
into three types: (1) Add Column: adding constraints to a data col-
umn that did not exist in previous version; (2) Add Constraint:adding constraints to an existing data column that was not asso-ciated with that specific type of constraints, like adding a length
constraint to a data field that had no length constraint previously;
'V /R *L 5H 6S 5R )X 7U 'D 2Q )) 26&KDQJHFRQVWULDQWV $GGFRQVWUDLQWV $GGFROXPQV
Figure 2: Breakdown of # of adding/changing constraints
(3) Change Constraint: changing the detailed requirement of a con-
straintthat already existed in previous version.
What is alarming from the result (Figure 2) is that the Add-
Column type only contributes to around or lower than 50% of
changes in 5 out of the 12 applications. On the other hand, 13‚Äì
67%of constraint changes (23% across all applications) are adding
new types of constraints to columns that already existed in earlier
versions (i.e., tightening the constraints), indicating that constraint
addition is often developers‚Äô after-thoughts. Changing existing
constraints is much less common, but is still not rare, contributing
to more than 10% of constraint changes in 4 applications.
Summary. Itisproblematicthataroundormorethanaquarter
ofconstraint-relatedcodechangesinmostapplicationsareabout
adding constraints to already existing data columns. This indicates
awidelyexistingvulnerabilitythatallowsconstraint-violatingdatato be stored into the database before the correct constraints are im-posed.Toolsareneededtohelpdevelopersaddsuitableconstraints
whenever a new data column is created and warn of data that is
incompatiblewith the newly added constraints.
6 CONSTRAINT-RELATED ISSUES
We categorize 114 real-world issues into 4 types as shown in Table
9.
6.1 WHERE is the constraint specified?
As discussed, application and DB constraints for the same data
field can be inconsistent with each other. Such inconsistencies
contributed to 24 out of the 114 issues.
ApplicationconstraintslooserthanDBconstraints. 13out
of 24 issues fall into this category. In 12 of them, the constraintis completely missing in application layer while the rest one is-
suehappensbecausethelengthconstrainthasasmallervaluein
database layer than in application layer. In these cases, a record
saving operation would pass the application server‚Äôs checking but
failintheDB,causingawebpagecrashwithanunhandledrawDB
error thrown to end users, which is often difficult to understand
and causes poor user experience. The example discussed in Figure
1 is an illustration.
Application constraints stricter than DB constraints. 11
out of 24 issues fall into this category. In 9 of them, applicationconstraints are not defined in database layer at all while the rest
two are caused by that length constraint has smaller value in appli-
cationlayerthanindatabaselayer.Inthesecases,theapplication
misbehaves as the administrator/user directly changes databaserecords through SQL queries in a way that violates application
constraints.Thishappensquiteoften.Forexample,Spree[ 20],an
6
Table 9: Data-constraint issues in real-world apps
Ds Lo Gi Re Sp Ro Fu Tr Da On FF OSM SUM
WHERE 3 0 3 7 8 0 1 0 0 2 0 0 24
WHATvs. code 0 1 8 11 14 1 0 0 4 2 0 0 41
vs.user 6 0 0 4 3 1 0 1 1 1 0 0 17
WHEN 3 0 4 1 3 0 0 0 1 0 0 0 12
HOW 2 0 1 7 3 0 0 0 5 0 0 2 20
SUM 14 1 16 30 31 2 1 1 11 5 0 2 114
$ 
!	 
  
% 
&



 %
	
!	!

"#
! "#	!
Figure 3: Constraint mismatch in Spree
on-line shopping system, has 4 issues caused by administrators
modifyingdatabasecontentthroughdirectSQLrequests.Discourse
[2] even has scripts that bypass model constraints to import other
forumapplications‚Äôdata.
Figure3showssuchanissue[ 21]inSpree.Asshownin(b),each
LineItem isassociatedwitha variant objectanda presence con-
straint is used to ensure the existence of every associated variant.
This ensures that an expression like item.variant.image in (a) is
never null. However, this constraint does not exist in the database.
In this bug report, an adminstrator accidentally deleted a variant
record in the DB that is associated with a LineItem record, and
that led to a null pointer error when he tried to display an order
through the code in Figure 3a.
Summary. Asshownbyreal-worldissues,inconsistenciesbe-
tween application and database constraints cause problems, includ-
ing web page crashes and poor user experience. Considering the
hundreds and thousands of constraints that exist in the DB but not
inapplicationandviceversa(seeSection4.2),thisproblemcouldbe
muchmoresevereandwidespreadthanwhatreflectedbytheissue
reports. Automatically detecting such constraint inconsistencies
will be very helpful, which we further explore in Section 7.
6.2 WHAT is the constraint about?
The most common problem is a mismatch between how data is
supposedtobeusedintheapplicationandtheconstraintsimposed
on it. This accounts for 58 out of 114 issues.
6.2.1 Conflict with user needs. Users sometimes would relax an
existingconstraint,suchasincreasingtheinputlengthofnamefield
intrackerfrom30to100(Redmine-23235[ 17]).Thesecontribute
toabout10% oftheissuesinour study.Developersusuallysatisfy
the users‚Äô desires and change constraints accordingly.
Summary. Forcertaintypeofconstraints,likethelengthcon-
straint,itisdifficulttohaveonesettingthatsatisfiesallusers‚Äôneeds.
It would be helpful if refactoring routines can be designed to turn
a fixed-setting constraint into configurable.



&$##"
%  	


Figure 4: Type conflict example in Redmine
   

 	


			
		 

Figure 5: Case sensitivity conflict example in Gitlab
6.2.2 Conflict with application needs. Manyconstraintsarecreated
to guarantee program invariants that are crucial to applications‚Äô
functionalcorrectness.Constraintsthatareinsufficientorevencon-
flictingwithhowthecorrespondingdataisusedbytheapplication
contributeto more than one third of all the issues in our study.
Type conflicts .These constraints treat a data field as having
a general type, but the application uses the data field in a more
specialized way that demands tighter constraints. In one Redmine
issue[18],ausernoticedthatshecaninputinvaliddateslike‚Äú2011-
10-33‚Äùwithouttriggeringanyerrors.Thisproblemhappenedbe-
causeRedmine only useda regular expression ‚Äú\d{4}-\d{2}-\d{2}$‚Äù
to make sure the input follows the ‚Äúyyyy-mm-dd‚Äù format without
moredetailedchecking.Tosolvethisproblem,Redminelateradded
‚Äúvalue.to_date‚Äù to check whether the input can really be converted
to a date or not in the custom validate function shown in Figure 4.
Casesensitivityconflicts. Uniqueness isacommonconstraint
associated with a data field to avoid duplication, like preventing
twousersfromhavingthesameID.Acommonproblemisthata
field is written to the DB in a case-sensitive way of uniqueness,
whileusedorsearchedinacase-insensitiveway,orviceversa.Such
inconsistencycan leadto severe software misbehavior.
InaGitlabissue[ 7],auser‚Äôsprofileemailisallinlowercase,but
she committedcode with anupper-case letterin her email,which
then cannot be matched to herprofile. What is annoying was that
shewasunabletoaddthedifferentcasingasanalias,asGitlabsaid
the email was ‚Äúalready in use.‚Äù This happens because when a user-
emailisstoredintoDB,theuniquenesscheckingiscaseinsensitive‚Äî
‚Äúabc@example.com‚Äùistreatedthesameas‚ÄúABC@example.com.‚Äù
However, when the application searches for code commit using
emailastheindex,thesearchiscasesensitive‚Äîcodecommitted
by ‚ÄúABC@example.com‚Äù cannot be retrieved by a search using
‚Äúabc@example.com.‚Äù The patch made the search also case insen-
sitive, thus always converting the input email to pure-lowercase
before the search, as shown in Figure 5.
Boundary value conflicts. Therearecaseswherecertainval-
ues of a data field are allowed by the application logic, but disal-
lowed by the constraints. For example, in the typical checkout flowof Spree, users would enter their delivery details, then proceed to a
payments page to enter discounts and payment details, and then fi-
nallyarriveataconfirmationpage.However,inoneSpreeissue[ 23],
ausercomplainedthatwhensheenteredadiscountcouponthat
7
reduced the price to zero‚Äîwhich was actually a valid use case‚Äîthe
application did not allow him to proceed, and instead redirected
backtothedeliverypage.Thesourceofthebugwasaconstraint
in the model layer ( models/spree/order.rb ) which incorrectly
requiredthevalueofthe totalfieldtobestrictlygreaterthanzero.
Summary. Failuresymptomsofthesebugsarequitedifferent
from all the other types of bugs (WHERE, WHEN, HOW). They
canleadtoseveresoftwaremisbehaviororevendisableanentire
featureofawebapplication.Itwouldbeidealifaprogramanalysis
tool can compare how a data field is used in software and identify
inconsistency between how it is used and how it is constrained.
This is challenging for generic data types and data usage, but is
feasiblefor specific types of problems, which we explore in Sec. 7.
6.3 WHEN is the constraint created?
Whenupgradinganapplication,sometimesnewlyaddedorchanged
constraints might be incompatible with old data. 12 issues are
caused by such inconsistency across versions. The failure symp-
tomsvarybasedonthedifferentprogramcontextwherethetighter
constraintis checked.
Read path .When a constraint is newly created or tightened
alongaDB-recordloadingcodepath(e.g.,front-endconstraintor
application sanity-check changes), an incompatible new constraint
can cause failures in loading old data and hence severe function-
alityproblems.The Diaspora examplein Section 1belongs to this
category:thepassword‚Äôslengthrequirementtightenedandhenceinvalidated many old passwords.
Write path
.When a constraint is newly created or tightened
alongapaththatintendstosavearecordtothedatabase(e.g.,all
the application-validation constraints and database constraints),
theincompatibilitybetweenthenewconstraintandolddatacan
be triggered under the following two circumstances.
First, all the old data in the database will be checked against
thenewsetofDBconstraintsduringamigrationprocessduring
applicationupgrade.InconsistencybetweenolddataandnewDB
constraintscancauseanupgradefailure.Forexample,oneGitlab
issue[8]complainsthattheyfailedtoupgradefromversion9.4.5to
9.5.0dueto NotNullViolation duringdatamigration.Asshownin
Figure6,the decription_html columnwasaddedtoGitlabbefore
version9.4.5(inthe‚Äú20160829...‚Äùmigrationfile)andwasfilledwith
nullsbydefault.2Lateron,inthe‚Äú20170809...‚Äùmigration(shown
in the Figure 6), a non-null constraint was added to the column
throughtheAPI change_column_null withparameter false.This
causedmanyusers‚Äôupgradetofailbecausethereweremanyold
recordswithadefault nullinthatcolumn.Thepatchremovedthe
‚Äúnon null‚Äù constraint to the description_html column, as shown
in Figure 6.
Second,evenifalltheolddataisvalidatedagainstDBconstraints
andtheapplication hassuccessfullyupgraded,theold datamight
stillconflictwithnewconstraintsspecifiedthroughtheapplication
validationAPIsthatdidnotexistinthepriorversion.Thiscanlead
toproblemswhentheapplicationallowsuserstoeditanexisting
record‚Äîusers may have trouble in saving an edited record back. In
oneDiscourseissue[ 3],ausercomplainedthatshemadeasmall
edit to an old post‚Äôs title, but was unable to save with an error
2When no default value is specified in add_column ,nullis used as the default value.

	 	

	 

	 



	 

	
	 

	
Figure 6: Old data conflicts with new constraints in Gitlab
message stating that the title was invalid. It turned out that, the
title‚Äôslengthconstrainthasbeenchangedfrom30to20charactersin
theapplication‚Äôsvalidationfunction.Thatoldpost‚Äôstitlecontained
28 characters; the small edit did not change the title length. So, the
old post can still be loaded by the application, but cannot be saved
back after suchsmall edits.
Summary. Giventhefrequentconstraintadditionandchang-
inginwebapplications,itisinevitablethatolddatamaybecome
incompatible with new constraints. It would be helpful if auto-
mated tools can provide warnings for developers when constraints
becometighterinanewversion,particularly(1)ifthemigration
file has high probability to fail (e.g., specifying a constraint that
conflicts with a column‚Äôs default value), then developers should fix
themigrationfile;(2)iftheapplicationallowseditingolddata,thendevelopersshouldprobablyaddexplicitwarningtousersaboutthe
risk of editing old data; and finally (3) the case of having tighter
constraintsthatlimitthereadingofolddatashouldbeavoided.We
explore this in Section 7.
6.4 HOW are the checking results delivered?
Constraintviolationiscommoninwebapplications,aswebusers
cannot anticipate all the constraints in advance and will inevitably
input constraint-violatingdata. Consequently, delivering informa-
tiveandfriendlyerrormessagesiscrucialtowebapplications‚Äôuser
experience. 20 issues in our study are about this problem.
These 20 issues are mostly related to application-validation con-
straints.RailsvalidationAPIsprovidedefaulterrormessagesthat
aremostlyclear.3However,developerssometimesforgottodisplay
the error message associated with the validation APIs (8 cases)
and sometimesoverride the default message with uninformative
genericmessages(12cases),whichledtousercomplaints.Forex-
ample,inaDiasporaissue[ 1],ausercomplainedthatwhenhetried
to post a long article, the posting failed with an unhelpful error
message‚ÄúFailedtopost!‚ÄùDevelopersfoundoutthattheircodein
posts_controller forgottorendertheerrormessagedefinedin
post‚Äôsvalidationfunction.Thepatchfixedthisproblemandwould
displaythe required length limit, as shown in Figure 7.
Summary. Developersshouldberemindedtodisplayerrormes-
sagesassociatedwithvalidationAPIs.FutureIDEsshouldautomat-
ically synthesize default error checking and error-message display
code. Improving the quality of default and custom error message is
crucialto user experience. We will explore this in Section 7.
3Section7discussescaseswhenthedefaultmessageisunclearandhowweenhanceit.
8
	
 	






Figure 7: Unclear error message in Diaspora
7 SOLUTIONS & EVALUATION
Wenowdiscussourexperienceinbuildingtoolstoautomatically
discover the anti-patterns discussed earlier. We focus on applying
them to the latest versions of the studied applications, as these
represent potential bugs that have not been discovered.
7.1 Where issues
AsdiscussedinSection4.2,ourscriptscanautomaticallyfindmore
than 1000 string-length DB constraints that are missing in applica-
tion, and more than 400 application built-in-validation constraints
that are missing in the DB. We reported 16 of them covering differ-
ent types, with 12 of them already confirmed by developers from 3
applications(Lo, Ds, FF).
Inaddition,weextendedourscriptstoautomaticallyfindcon-
flicting cases, where the same type of constraint, like length, is
specifiedforthesamedatafieldinbothdatabaseandapplication,
but the exact constraint requirement is different.
As shown in Table 10, our checker reported 138 conflicting con-
straints in total. Our manual checking confirmed that 133 of them
are true conflicts and 5 are false positives.
These133conflictsinclude84caseswhereapplications‚Äôlength
constraints are tighter than the DB‚Äôs, 4 cases in the other way,
1 case where the columns referenced by uniqueness constraints
did not exactly match, and 44 cases where the range or type of
numeric values allowed in DB did not match the corresponding
restrictioninthemodel.Forexample,ourresultsshowedthat,inthe
Tracks application, there was a string field description in model
Todofor which the length in DB was limited to 255 characters,
but was limited to 300 in the model. We reported this mismatch to
developers and received confirmation that it was indeed a bug. As
anotherexample,wefound5instancesinOpenStreetMapwhere
developers meant to require fields to be integers in both the DB
and application. However, developers had typos in their use of
validation APIs, which caused the application-level numericality
constraintstobesilentlyignored.Wereportedthistodevelopers,
whothen fixed the bug.
As an example of range mismatch, there was a case in Spree
where the field pricemust be greater than or equal to zero. How-
ever, in the DB, the field type was decimal which allows negative
values.
Among the 5 false positives, 3 were caused by our tool‚Äôs limited
ability in handling non-literal expressions, and the others were
relatedtoourtool‚Äôsinabilitytodistinguishbetweenarraylength
and stringlengthvalidations.
7.2 What issues
Webuiltacheckertodetect‚Äúcase-sensitivityconflicts‚Äùdiscussedin
Section6.2.2.OurcheckerfirstidentifieseveryfieldthathascaseTable 10: # Mismatch constraints between DB-Model
Ds Lo Gi Re Sp Ro Fu Tr Da On FF OS
Length - DB looser 5 7 12 9 0 25 0 4 4 11 0 7
Length - DB tighter 0 0 0 0 0 3 0 1 0 0 0 0
Uniqueness 1 0 0 0 0 0 0 0 0 0 0 0
Numericality 4 0 24 1 6 0 3 0 0 0 3 3
False positives 002300000000
Total 10 7 38 13 6 28 3 5 4 11 3 10
Table 11: Our enhancement to default error messages
Default Enhanced
inclusion_of ‚Äúinvalid‚Äù ‚Äúhave to take values from {A, B, ...}‚Äù
exclusion_of ‚Äúreserved‚Äù ‚Äúcannot take values from {A, B, ...}‚Äù
confirmation_of ‚Äúinvalid‚Äù ‚ÄúCase does not match with earlier input‚Äù
uniqueness_of ‚Äúinvalid‚Äù ‚ÄúNotuniquein case (in)sensitive comparison‚Äù
associated ‚Äúo is invalid‚Äù ‚Äúfield f of object o is invalid‚Äù
insensitive constraints specified by the validation API validates_
uniqueness_of:field andcase_sensitive:false , then checks
all the statements that issue a read query to load such a field to see
if the loading is ever done in a case sensitive way. To identify all
thosereadqueries,weusedanexistingstaticanalysisframeworkfor
Rails [48]; to identify case-sensitive loading, we check whether the
queryisdirectlyorderedbythefield( .order(‚Äòfield‚Äô) )orfiltered
on the field (.where(field: params)) without case conversion.
Our checker found 19 issues in latest versions ‚Äî 14 in Lobsters,
3inRedmine,2inTracks.Ourmanualcheckingconfirmedthese
are all bugs (no false positives). We also got confirmation from
developersofLobstersandRedmine.Redminehasalreadyadded
ourpatch to their next major release 4.1.0.
7.3 Whenissues
Given two code versions, to detect inconsistency between old data
andnewconstraints,weextendourscriptthatexaminesconstraint
changes across versions (Section 5) to see if new constraints are
added or existing constraints are tightened. We then further check
whethertheapplicationallowseditingexistingDBdata,whether
the default value conflicts with the new/changed constraint, and
whetherthemigrationfileupdatesthecorrespondingcolumninthe
database,whichisacommonwaytoavoidincompatibilityproblems.
Dueto space constraints, we omit details of the algorithm.
We applied our checker to the 12 applications. It did not find
problems with the latest upgrade of these applications.
7.4 How issues
Improving built-in error messages. Rails built-in validation
APIs provide default error messages that are used by developers in
most cases, only overridden in 2% of the cases across all studied
applications.Consequently,havinginformativedefaultmessagesis
crucial.
9
Table 12: User study results
Task-1 # input attempts w/ modified # attempts w/ default Decrease
Inclusion 2.2 3.1 30%
Associated 2.3 3.4 33%
Task-2 % of users prefer modified % prefer default No preference
Exclusion 74% 22% 4%
Confirmation 81% 8% 11%
Uniqueness 74% 16% 10%
Wefoundthat5APIs‚Äôdefaultmessagescanbemoreinformative,
as shown in Table 11. For example, validates_confirmation_of
ensuresthatafieldanditsconfirmationfieldhavethesamecontent.
Instead of only saying the input is ‚Äúinvalid,‚Äù we add information
on whether the matching failure is caused by case sensitivity, so
theusercandecidewhethertochangejustthecaseortheactual
value.Asanotherexample, validates_associated checksifevery
fieldofasub-object o,whichisassociatedwithanotherobject,is
valid (e.g., a ‚Äúphoto‚Äù is a nested object of ‚Äúprofile‚Äù, and has fields
‚Äúsource_url‚Äù, ‚Äúwidth‚Äù, ‚Äúheight‚Äù). If the validation of any field of o
fails, the default message states only that the entire ois invalid.
Our enhancement lets the user know which specific field (e.g.,
‚Äúsource_url‚Äù or ‚Äúwidth‚Äù or ‚Äúheight‚Äù)is incorrect and how to revise.
Wehaveimplementedalibrary(i.e.,aRubygem)tooverwrite
theRailsdefaulterrormessagewithouradvancedones.Ourgem
redefined the existing error message generation functions with
customonesthat incorporated more information.
User Study. Toevaluateourerror-messagechanges,werecruited
100 participants using Amazon Mechanical Turk (MTurk). The
participants are all live in US and are at least 18 years old withhigher than 95% MTurk Task Approval rate. We asked users to
perform two tasks. First, users provided answers to questions such
as,enteratitle,firstname,andlastname;ortryandenteraunique
value for a given category. If they fail to provide a valid answer,
we either provide them with the Rails default error message, or
our improved error message. In each case, we track the numberof retries required for the user to reach a valid input, and if they
cannot after 5 retries, we skip to the next question. Each user was
given 2 of these tasks. In the second task, we provide a webpagescreenshot of a question and an incorrect answer-input to that
question.Thequestionsarebasedontheapplicationswestudied.
We then show two options for error messages: the default message
and the improved message. We ask the user to rate which error
messagewouldbemorehelpfulinarrivingatavalidinput.Each
user was given 3 of these tasks.
Asshown inTable 4,for thefirsttask, ourenhanced errormes-
sages reduced the number of tries users took to reach valid inputs
byabout30%;forthesecondtask,wefind74‚Äì81%ofuserspreferred
our enhanced error messages, depending on the type of validation.
Detecting missed error messages. Developers are required
to provide error messages for custom validations through the APIobject.errors.add(msg)
. We extend our script that identifies
custom validation functions to further check if an error message is
provided. We found one case in Diaspora where the error message
is missing. This is actually a severe problem: since Rails uses thecountoferrormessagestodeterminethevalidityofanobject,an
invalidobjectcanthenbeincorrectlytreatedasvalidandleadto
applicationfailures.WereportedthisbugtoDiasporadevelopers,
whohave confirmed that this is indeed a bug.
Detectingmissederrorrendering. Sincetherearemanyways
torendererrormessagesonawebpage,itisdifficulttoautomat-
ically detect this problem. We randomly chose 45 HTML pages
withformsacross12applications,andmanuallycheckediferror
messagescaused by invalid inputs were rendered. We found onecase where the message would never be rendered: on a page in
OpenStreetMap that asks users to input a URL, when the input has
animproperformat,thewebpagemarksthefieldwithredcolor,
withoutrenderingtheerrormessageassociatedwiththeconstraint.
8 DISCUSSION
8.1 Impactof False Positives
Our scripts for checking constraints inconsistency across layers
hassomefalsepositives,ofwhichthevastmajoritycomefromtwo
types of constraints: (1) string-length constraints in database, (2)
presence constraints in applications. The remaining false positives
are due to some validation/migration API call parameters being
derived from function calls or non-constant expressions, which we
do not currently evaluate.
Such false positives have limited impact on the paper‚Äôs findings
and are already considered in our finding presentation:
RQ1: This has little impact. The overall trends like many data
fieldsassociated withconstraints,DBcontaining mostconstraints
will not be affected by these small number of false positives.
RQ2: This has negligible impact. For instance, the number of
versionswithconstraintchangesremainsthesameevenifwedo
not considerthe above two types of constraints;
RQ3: There is no impact since the real-world issue study is con-
ducted manually;
RQ4:Thishasnegligibleimpact.AllfindingsinTable1stillhold,
astheyeitherarenotrelatedtothosetwotypesofconstraintsorare
reportedwithfalsepositivesalreadyprunedorcarefullyconsidered.
For instance, although our script reported 1,650 database string
lengthconstraintsmissingintheapplication,weintentionallyonlyhighlight‚Äú1000+stringfields...‚Äù,insteadof1,650,inTable1,exactly
because wehave takenthe potentialimpact of falsepositives into
account.
8.2 Threatsto Validity
Internal Threats to Validity : As discussed in Section 2.2 and 4,
we only considered DB constraints declared through Rails built-in
migrationAPIs, butnot thosethrough SQLqueries,which areex-
tremelyrare(fewerthan30acrossall12applications).Ouranalysis
covers only native DB types such as string, numeric, and datetime
types, and excludes non-native DB types such as JSON, spatial, or
IPformat,whichtogetheraccountforlessthan1%ofallcolumns.
Front-endconstraintsspecifiedthroughJavaScriptfileswerenot
considered.Finally,ourstaticcheckershavefalsepositivesasdis-
cussed in Section 4.2 and 7.
ExternalThreatstoValidity :The12applicationsinourstudy
clearlymaynotrepresentallreal-worldapplications;the114issues
studiedalsomaynotrepresentallconstraint-relatedissuesinthese
10
applications; the 100 participants of our user-study from MTurk
maynotrepresentallreal-worldusers.Overall,wehavetriedour
best to conduct an unbiased study.
AsdiscussedinSection2.2,otherORMframeworks,likeDjango
and Hibernate, also let developers specify application and database
constraintslikethatinRails.Wesampled22constraint-relatedissue
reports from the top 3 popular Django applications on Github, and
observed similar distributions, as shown below.
WHERE WHAT WHAT WHEN HOW SUM
vs.code vs.user
django-cms [5] 1 2 3 3 1 10
zulip [24] 1 4 2 0 0 7
redash [15] 0 2 0 0 3 5
9 RELATED WORK
Verifyingdata constraints. Priorworkhasinvestigatedveri-
fyingdatabase-relatedconstraints.ADSL[ 26]verifiesdata-model
related invariants (e.g., whether each todo object is associated
withaprojectobject)usingfirstorderlogic,whiletheinvariants
are provided by users using their invariant language. Singh and
Wang [39,42] check whether a set of DB constraints still hold
when DB schema evolves while Caruccio [ 27] conducts a survey of
related workin thisdomain. Pan [ 37] proposesa methodto lever-
age symbolic execution to synthesize a database to verify different
typesofconstraintslikequeryconstructionconstraints,DBschema
constraints,query-result-manipulationconstraints,etc.
Verifyingwebapplicationsusingconstraints. Anotherline
of work focuses on using constraints provided by the DB or ap-
plicationforapplicationverificationandsynthesis,likeverifying
the equivalence of two SQL queries[ 30,31,40], DB applications
[41],synthesizinganewDBprogramwithanewschemegiventhe
originalprogramwith anold scheme[42], andhandling chainsofinteractive actions [32].
Othertypesofdataconstraints.
Muchpreviousresearchhas
looked at how to specify security/privacy-related data constraints
and how to verify or enforce those constraints across different
components of database-backed applications [ 25,33,36,46]. These
constraints are currently not supported by web application frame-
works, and are orthogonal to this study.
Leveragingconstraintstoimproveperformance. Usingdata-
baseconstraintstoimprovequeryperformanceisalreadywidely
adopted in database systems. For example, Wang [ 34] leverages
foreignkeyconstraintstoacceleratethesamplingofjoinqueries.
Other work leverages DB data constraints to find an equivalent
but more efficient query plan, for instance, Chestnut [ 44] adds con-
straints as extra assumptions to help synthesize better query plans,
andQuro[ 43]leveragesdataaccessconstraintstooptimizetransac-
tionalapplications.Althoughmuchworklookedathowtoleverage
data constraints, little work has been done on studying how the
constraintsaredefinedandusedinDB-backedapplications,orwhat
are the common issues related to these data constraints. Our work
revealsthatdevelopersarespendingalotofeffortmanagingcon-
straints and suffer many problems that are hardly paid attentionto in research work. These findings open new research opportuni-
ties like automating constraint-consistency check or making the
constraintchangeseasier fordevelopers.
Empiricalstudy of web applications. Past empirical studies
lookedatdifferentaspectsofwebapplications,likeORM-related
performance problems [ 28,29,45,47] and client-side performance
problems [38] but not data-constraint problems.
10 CONCLUSION
Specifying and maintaining consistent and suitable constraints for
dataiscrucialtoensuretheapplicationcorrectnessandusability.
In this paper, we thoroughly studied how data constraints have
beenspecified,maintained,andledtoreal-worldissuesin12repre-
sentative open-source DB-backed applications. Our study shows
that tooling support is needed to help developers manage data con-
straints,and our checkeris the first step towards providing such
support.
ACKNOWLEDGEMENT
This work is supported in part by the NSF through grants CCF-
1837120, CNS-1764039, 1563956, 1514256, IIS-1546543, 1546083,
1651489,OAC-1739419,andthecomputationresourcefromChameleon
cloud;DARPAawardFA8750-16-2-0032;DOEawardDE-SC0016260;theIntel-NSFCAPAcenter;giftsfromAdobe,Google,andCERESre-
search center for Unstoppable Computing. We thank Madan Musu-
vathi and Suman Nath from Microsoft Research for inspiring us to
startthis research direction.
11
REFERENCES
[1]Diaspora-5090. https://github.com/diaspora/diaspora/issues/5090.
[2]Discourse. A blog application.
https://github.com/discourse/discourse/.
[3]Discourse-89148. https://meta.discourse.org/t/89148.
[4]Discourse Import Scripts . A blog application.
https://github.com/discourse/discourse/tree/master/script/import_scripts.
[5]Django-cms. An enterprise content management system.https://github.com/divio/django-cms/.
[6]
Django Validator Function . https://docs.djangoproject.com/en/2.2/ref/validators/.
[7]Gitlab-24493. https://gitlab.com/gitlab-org/gitlab-ce/issues/24493.
[8]Gitlab-36919. https://gitlab.com/gitlab-org/gitlab-ce/issues/36919.
[9]Gitlab database migrate. https://github.com/gitlabhq/gitlabhq/tree/master/db/
migrate.
[10] Gitlab releases. https://about.gitlab.com/releases/.
[11] Hibernate Validator Annotation. https://hibernate.org/validator/documentation/
getting-started/.
[12] Hyperloop. https://hyperloop-rails.github.io/vibranium/.
[13] Rails Uniqueness API . https://github.com/rails/rails/blob/master/activerecord/lib/
active_record/validations/uniqueness.rb#L165/.
[14] Rails Uniqueness Problem . https://thoughtbot.com/blog/the-perils-of-uniqueness-
validations.
[15] Redash. An application to connect your company‚Äôs data.
https://github.com/getredash/redash/.
[16] redmine-24283. https://www.redmine.org/issues/24283.
[17] Redmine-25235. http://www.redmine.org/issues/25235/.
[18] Redmine-9394. http://www.redmine.org/issues/9394/.
[19] redmine, a project management application. https://redmine.org/. (????).[20] Spree. A ecommerce application.https://github.com/spree/spree/.
[21] Spree-3829. https://github.com/spree/spree/issues/3829.
[22] Spree-4123. https://github.com/diaspora/diaspora/issues/4123.
[23] Spree-6673. https://github.com/spree/spree/issues/6673.
[24] Zulip. A powerful team chat system.
https://github.com/zulip/zulip/.
[25]
Muath Alkhalaf, Shauvik Roy Choudhary, Mattia Fazzini, Tevfik Bultan, Alessan-
dro Orso, and Christopher Kruegel. 2012. Viewpoints: differential string analysis
for discovering client-and server-side input validation inconsistencies. In Pro-
ceedings of the 2012 International Symposium on Software Testing and Analysis.
ACM, 56‚Äì66.
[26]IvanBociƒá,TevfikBultan,andNicol√°sRosner.2019. Inductiveverificationofdata
model invariants in web applications using first-order logic. Automated Software
Engineering 26,2 (2019), 379‚Äì416.
[27]Loredana Caruccio, Giuseppe Polese, and Genoveffa Tortora. 2016. Synchroniza-
tion of queries and views upon schema evolutions: A survey. ACM Transactions
on Database Systems (TODS) 41,2 (2016), 9.
[28]Tse-Hsun Chen, Weiyi Shang, Zhen Ming Jiang, Ahmed E. Hassan, Mohamed
Nasser, and Parminder Flora. 2014. Detecting Performance Anti-patterns for
ApplicationsDeveloped Using Object-relational Mapping. In ICSE. 1001‚Äì1012.
[29]Tse-Hsun Chen, Weiyi Shang, Zhen Ming Jiang, Ahmed E. Hassan, Mohamed
Nasser, and Parminder Flora. 2016. Finding and evaluating the performance
impact of redundant data access for applications that are developed using object-
relational mapping frameworks.. In ICSE. 1148‚Äì1161.
[30]Shumo Chu, Chenglong Wang, Konstantin Weitz, and Alvin Cheung. 2017.
Cosette:An Automated Prover for SQL. In CIDR.
[31]ShumoChu,KonstantinWeitz,AlvinCheung,andDanSuciu.2017. HoTTSQL:
Proving Query Rewrites with Univalent SQL Semantics. In PLDI. 510‚Äì524.
[32] AlinDeutsch,MonicaMarcus, LiyingSui,VictorVianu,andDayouZhou. 2005.
A verifier for interactive, data-driven web applications. In Proceedings of the 2005
ACM SIGMOD international conference on Management of data. ACM, 539‚Äì550.
[33]Nikolaos Karapanos, Alexandros Filios, Raluca Ada Popa, and Srdjan Capkun.
2016. Verena: End-to-end integrity protection for web applications. In 2016 IEEE
Symposium on Security and Privacy (SP). IEEE, 895‚Äì913.
[34]FeifeiLi,BinWu,KeYi,andZhuoyueZhao.2016. Wanderjoin:Onlineaggre-
gationviarandomwalks.In Proceedings of the 2016 International Conference on
Management of Data. ACM, 615‚Äì629.
[35]Guy Lohman. Is Query Optimization a ‚ÄúSolved‚Äù Problem? https://wp.sigmod.org/
?p=1075.
[36]JosephPNearandDanielJackson.2014. Derailer:interactivesecurityanalysis
forwebapplications.In Proceedings of the 29th ACM/IEEE international conference
on Automated software engineering. ACM, 587‚Äì598.
[37]Kai Pan, Xintao Wu, and Tao Xie. 2014. Guided test generation for database
applicationsviasynthesizeddatabaseinteractions. ACM Transactions on Software
Engineering and Methodology (TOSEM) 23,2 (2014), 12.
[38]MarijaSelakovicandMichaelPradel.2016. Performanceissuesandoptimizations
in javascript: an empirical study. In ICSE. 61‚Äì72.[39]Rohit Singh, Vamsi Meduri, Ahmed Elmagarmid, Samuel Madden, Paolo Papotti,
Jorge-Arnulfo Quian√©-Ruiz, Armando Solar-Lezama, and Nan Tang. 2017. Gener-
ating concise entity matching rules. In Proceedings of the 2017 ACM International
Conference on Management of Data. ACM, 1635‚Äì1638.
[40]ChenglongWang,AlvinCheung,andRastislavBod√≠k.2018.Speedingupsymbolic
reasoning for relational queries. PACMPL 2, OOPSLA (2018), 157:1‚Äì157:25.
[41]Yuepeng Wang, Isil Dillig, Shuvendu K. Lahiri, and William R. Cook. 2017. Veri-
fyingEquivalenceofDatabase-drivenApplications.In Proceedings of the ACM on
Programming Languages. 56:1‚Äì56:29.
[42]Yuepeng Wang, James Dong, Rushi Shah, and Isil Dillig. 2019. Synthesizing
databaseprogramsforschemarefactoring.In Proceedings of the 40th ACM SIG-
PLAN Conference on Programming Language Design and Implementation.ACM,
286‚Äì300.
[43]Cong Yan and Alvin Cheung. Leveraging Lock Contention to Improve OLTP
ApplicationPerformance. Proc. VLDB Endow. (2016) , 444‚Äì455.
[44]CongYanandAlvinCheung.2019. GeneratingApplication-SpecificDataLayouts
forIn-memory Databases. Proc. VLDB Endow. (2019),1513‚Äì1525.
[45]Cong Yan, Junwen Yang, Alvin Cheung, and Shan Lu. 2017. Understanding
Database Performance Inefficiencies in Real-world Web Applications. In CIKM.
[46]Jean Yang, Travis Hance, Thomas H Austin, Armando Solar-Lezama, Cormac
Flanagan, and Stephen Chong. 2016. Precise, dynamic information flow for
database-backed applications. ACM SIGPLAN Notices 51,6 (2016), 631‚Äì647.
[47]Junwen Yang, Pranav Subramaniam, Shan Lu, Cong Yan, and Alvin Cheung.
2018. Hownottostructureyourdatabase-backedwebapplications:astudyof
performance bugs in the wild. In ICSE. 800‚Äì810.
[48]Junwen Yang, Pranav Subramaniam, Shan Lu, Cong Yan, and Alvin Cheung.
2018. PowerStation:Automaticallydetectingandfixinginefficienciesofdatabase-
backed web applications in IDE. In FSE. 884‚Äì887.
12
