Dynamic Generation of Python Bindings
for HPC Kernels
Steven Zhu, Nader Al Awar, Mattan Erez, and Milos Gligoric
The University of Texas at Austin
{stevenzhu,nader.alawar,mattan.erez,gligoric}@utexas.edu
Abstract ‚ÄîTraditionally, high performance kernels (HPKs)
have been written in statically typed languages, such as C/C++
and Fortran. A recent trend among scientists‚Äîprototyping ap-plications in dynamic languages such as Python‚Äîcreated a gapbetween the applications and existing HPKs. Thus, scientistshave to either reimplement necessary kernels or manually createa connection layer to leverage existing kernels. Either optionrequires substantial development effort and slows down progressin science. We present a technique, dubbed W
AYOUT, which
automatically generates the entire connection layer for HPKsinvoked from Python and written in C/C++. W
AYOUTperforms
a hybrid analysis: it statically analyzes header Ô¨Åles to generatePython wrapper classes and functions, and dynamically generatesbindings for those kernels. By leveraging the type informationavailable at run-time, it generates only the necessary bindings. Weevaluate W
AYOUTby rewriting dozens of existing examples from
C/C++ to Python and leveraging HPKs enabled by W AYOUT.
Our experiments show the feasibility of our technique, as wellas negligible performance overhead on HPKs performance.
Index T erms‚Äîbindings, high performance kernels, dynamic
program analysis, Python
I. I NTRODUCTION
Traditionally, high-performance computing (HPC) applica-
tions are written in statically typed (and low-level) program-
ming languages, such as C/C++ and Fortran [1]‚Äì[3]. Theselanguages are the de facto standard in the HPC area due tothe excellent performance of the resulting applications.
HPC applications spend most of their execution time in
so-called high-performance kernels (HPKs), such as linear
algebra operations and solvers [4]. Over the last several years,the number of HPKs has been steadily growing and existingHPKs are constantly optimized and updated to support newhardware platforms.
Recently, several frameworks were introduced to enable
developers to write performance portable HPKs. Namely, adeveloper can write an HPK only once and the frameworkautomatically enables the execution of that HPK on a variety ofhardware platforms (e.g., Intel CPUs, Nvidia GPUs, and AMDGPUs). Some of the most notable frameworks that supportperformance portability include Kokkos [5], [6] and RAJA [7].These frameworks enable the rapid development of new HPKs,although they are still based on C/C++.
Meanwhile, scientists are transitioning to dynamically typed
languages, such as Python [8], Julia [9], or Lua, for writingtheir applications. In order to obtain good performance, sci-entists have to either: (a) implement HPKs in their languageof choice (using high-performance libraries like Numba [10]or PyKokkos [11]), or (b) create bindings to existing HPKs
implemented in C/C++ or one of the frameworks that supportsperformance portability (using libraries like pybind11 [12]).In either case, substantial work is required [13], [14]. Main-tenance of manually written bindings (as HPKs evolve) intro-duces additional challenges.
We present W
AYOUT, a novel approach to automati-
cally generating connection layers for existing (performanceportable) HPKs to be used by Python applications. W
AYOUT
is the Ô¨Årst approach that combines static and dynamic pro-gram analysis. SpeciÔ¨Åcally, for a given header Ô¨Åle, W
AYOUT
performs static analysis to create: (1) wrapper classes and
functions, i.e., a Python API provided to scientists that reÔ¨Çectthe given header Ô¨Åle, and (2) header Ô¨Åles with templated
bindings that will be instantiated at run-time. When a Pythonapplication is executed and one of the wrapper functions is in-voked, W
AYOUTintercepts the call, instantiates and generates
thebindings for the given types, and invokes an existing HPK.
One of the key insights behind W AYOUTis that it postpones
binding generation until it has the types needed (which are notavailable statically in Python). W
AYOUTalso caches generated
bindings, so only the very Ô¨Årst invocation of each function(with one set of type arguments) introduces some overhead;the cache is saved across application runs.
We designed W
AYOUTto overcome the limitations of
cppyy [15] and pyximport [16], which target the same task, buttake very different approaches. Unfortunately, neither of thetwo mentioned approaches could be used to invoke existingHPKs from within a Python application. Cppyy depends ona powerful but immature tool chain, including PyPy [17],an alternative implementation of the Python interpreter, andCling [18], an interactive C++ interpreter. On the other hand,pyximport does not support dynamic instantiation of templatesand thus is unable to instantiate bindings if types are knownonly at run-time.
We overcome a set of critical challenges to realize W
AY-
OUT, including: (1) the lack of function and method over-
loading in Python; (2) concurrent use of multiple templateinstantiations of the same class; (3) inferring types of returnedobjects; and (4) ambiguously typed template arguments.
We evaluate W
AYOUTby automatically generating bindings
for Kokkos Kernels [4], one of the most popular frameworksfor HPKs, and Thrust [19], a powerful template library con-taining parallel algorithms. We rewrote a number of existingexamples (that use Kokkos Kernels and Thrust) from C/C++
922021 36th IEEE/ACM International Conference on Automated Software Engineering (ASE)
DOI 10.1109/ASE51524.2021.000192021 36th IEEE/ACM International Conference on Automated Software Engineering (ASE) | 978-1-6654-0337-5/21/$31.00 ¬©2021 IEEE | DOI: 10.1109/ASE51524.2021.9678726
978-1-6654-0337-5/21/$31.00  ¬©2021  IEEE
to Python. Our experiments show the feasibility of our tech-
nique, as well as its negligible performance overhead on HPKperformance. In our experiments, we also show that W
AYOUT
does not impact the performance portability of HPKs: we wereable to execute all the examples on both CPUs and GPUs.
This paper makes the following key contributions:
‚Ä¢Design of W AYOUT, a novel approach for automatically
generating a connection layer for existing HPKs to be used
in Python applications. W AYOUTuses a hybrid approach‚Äî
a combination of static and dynamic program analysis‚Äîtoinstantiate the connection layer.
‚Ä¢Implementation of W AYOUTfor Python. The design of
WAYOUTis modular and others could use our processing
of header Ô¨Åles to support connection layer with other pro-gramming languages, e.g., Lua. Source code of W
AYOUTis
available at https://github.com/EngineeringSoftware/wayout.
‚Ä¢Evaluation of W AYOUTby rewriting a number of existing
examples from C/C++ to Python and using existing HPKsfrom Kokkos Kernels and Thrust. We chose Kokkos becauseit is a popular performance portability framework and itcurrently has only a few manually written bindings; wechose Thrust to demonstrate the generality of our approach.
II. M
OTIV ATION
In this section, we provide some background on HPKs and
binding generation, as well as motivation for W AYOUT.
A. HPKs
The usage of hand-optimized HPKs in scientiÔ¨Åc computing
is extremely common. Typically, these kernels are writtenusing high performance C/C++ frameworks that can exploitparallelism on multi-core processors, such as OpenMP [20] forCPUs and CUDA [21] for GPUs. More recently, frameworkssuch as Kokkos [5], [6] and RAJA [7] build abstractions ontop of these device-speciÔ¨Åc frameworks to enable performanceportability, i.e., code that is portable across devices while stillachieving good performance. As such, these frameworks are anatural choice for writing high-performance kernels. Kokkos,for example, is used by numerous applications and packagesfor large-scale scientiÔ¨Åc computing, such as Trilinos [22],LAMMPS [23], Albany [24], Empire [25], and others.
Kokkos Kernels [4] is a collection of performance portable
kernels written in Kokkos. It includes a large variety of mathkernels and data structures commonly used in linear algebraand graph algorithms. One such example of a linear algebrakernel is the sparse matrix vector multiply kernel, or SpMV
for short. The following code snippet shows how SpMV canbe called in a Kokkos (C++) application, where Ais a sparse
matrix, alpha andbeta are scalars, and xandyare vectors.
KokkosSparse::spmv("N", alpha, A, x, beta, y);
B. Binding Generation
The target audience for these HPKs is largely composed
of scientists [4], [22] who need them for simulations andexperiments. However, these scientists typically do not havePython
User CodeC++
HPKCall
HPK
Return
ResultLanguage
BindingsCall
Bindings
Return
Result
Fig. 1: An illustration of language bindings.
formal training in programming, so using C++, which isnotorious for its poor error messages and complicated buildsystems, can be a huge deterrent. Instead, they prefer higherlevel languages with ‚Äúbatteries included‚Äù [8], such as Python.
Several attempts have been made to expose these libraries
and kernels to other languages [11], [26], [27]. This requiresthe use of language bindings, which allow for interoperability
between different languages. Figure 1 shows a high-levelillustration of language bindings between Python and C++.Numerous frameworks have been implemented to providePython bindings to C++ code, such as Boost.Python [28],pybind11 [12], and SWIG [29]. The following code snippetshows what a call to SpMV could look like once it has been
exposed to Python through one of the binding frameworks.
spmv(char_ptr("N"), alpha, A, x, beta, y)
However, manually writing these bindings can be tedious
and challenging. For example, the Python bindings for creatinga Kokkos View [13], the main multi-dimensional data structurein Kokkos, are written in pybind11. Despite only bindinga small part of Kokkos, the total lines of code for thesebindings is over 900, as they make heavy use of C++ macrosand compile-time template instantiation to generate all the
different combinations of template arguments. For KokkosViews, this includes different data types (int16_t, int32_t,
double, etc.), dimensions (one through eight), memory lay-outs, memory spaces, and memory traits. Each combinationof these arguments forms a single template instantiation. Thefollowing code snippet shows one such instantiation.
Kokkos::View<int*, LayoutLeft, HostSpace>;
Besides being hard to write, compiling the bindings takes
a large amount of time (around 6 hours on our machinesfor a commonly used subset of all combinations) due to thelarge number of template instantiations that need to happen. Inaddition to the time overhead, compilation occasionally runsout of memory due to the large number of template argumentcombinations, meaning that the process will not terminatesuccessfully on some machines.
Prior work on automatic generation of Python bindings for
C++ code [30], [31] extracts library APIs by parsing headerÔ¨Åles for class and function declarations. While this simpliÔ¨Åeswriting the bindings, it requires that the user manually addscode to instantiate all the needed template arguments sincethese frameworks employ static analysis. Also, this does not
93solve the compilation issues for large numbers of template
instantiations. Therefore, such an approach does not work wellfor templated libraries such as Kokkos Kernels and Thrust.
As a result, we propose generating these bindings dy-
namically, i.e., on demand at run-time such that only thenecessary template instantiations are created. This allows typesto be passed at run-time, removing the need for the user tomanually add template instantiation. It also reduces the costof compilation by compiling bindings only when needed. Weshow that this approach can achieve performance comparableto manually written bindings.
III. W
AYOUTOVERVIEW
In this section, we show an example of high performance
kernel (HPK) from Kokkos Kernels, and then use this HPK todemonstrate the workÔ¨Çow of W
AYOUT.
We encountered multiple challenges during the design and
implementation of W AYOUT. We highlight these challenges
‚≠êlike so, and then outline our design choices and how we
solved these challenges.
A. Example
Figure 2 shows the function signature of the SpMV HPK
spmv (line 4) and the class declaration of CrsMatrix, the
sparse matrix data structure it operates on (line 13). This kernel
performs the operation y=beta‚àóy+alpha‚àóA‚àóx.
The template parameters of spmv are used to set the types
used in the kernel at compile-time: AlphaType, BetaType
are the scalar types, XVector andYVector are the vector
types, and AMatrix is the sparse matrix type, which can be
set to CrsMatrix in this example. The template arguments
forCrsMatrix are as follows: ScalarType is the type of
entries contained in the matrix, OrdinalType is the type
of the matrix index, Device speciÔ¨Åes on which device‚Äôs
memory (e.g., GPU) the matrix is located in, MemoryTraits
speciÔ¨Åes the Kokkos memory access trait to be used (Atomic,RandomAccess, etc.), and SizeType speciÔ¨Åes the type of the
row offset.
Figure 3 shows an example using spmv andCrsMatrix.
To call the kernel, the user Ô¨Årst deÔ¨Ånes mat_t to alias the
instantiated CrsMatrix type (line 3) and instantiates the
matrix and vectors (lines 7-10). The CrsMatrix constructor
takes in as arguments the number of rows, columns, andelements, followed by Views containing the matrix entries,row offsets, and column indices. Views yandxrepresent the
one-dimensional vectors, and their constructor speciÔ¨Åes thesize of the View. The View constructor is templated on thedatatype and dimensionality (one-dimensional double in this
case). Finally, the user can call the spmv kernel (as shown
on line 12). The arguments passed to the call are a stringspecifying the operation mode (no transpose, transpose, orconjugate transpose), the scalar alpha, the matrix A, the vector
x, the scalar beta, and the vector y. The latter is passed by
reference and will hold the result of the operation upon returnfrom the function.1template <class AlphaType, class AMatrix,
2 class XVector, class BetaType,
3 class YVector>
4void spmv(const char mode[], const AlphaType &alpha,
5 const AMatrix &A, const XVector &x,
6 const BetaType &beta, const YVector &y);
7 /* ... */
8
9template <class ScalarType, class OrdinalType,
10 class Device, class MemoryTraits = void,
11 class SizeType = typename Kokkos::ViewTraits
12 <OrdinalType *, Device, void, void>::size_type>
13class CrsMatrix;
14 /* ... */
Fig. 2: An example of a kernel and data structure declaration
from Kokkos Kernels.
1int main() {
2 /* ... */
3 using mat_t = KokkosSparse::CrsMatrix<
4 double, int,
5 Kokkos::DefaultExecutionSpace, void, int>;
6
7 mat_t A = mat_t(numRows, numCols, nnz, val, ptr, in);
89
View<double *> y(N);
10 View<double *> x(N);
1112
KokkosSparse::spmv( "N", alpha, A, x, beta, y);
13}
Fig. 3: An example using a kernel and data structure from
Kokkos Kernels.
B. WorkÔ¨Çow
Figure 4 shows a high-level overview of W AYOUT; in this
section we highlight the user workÔ¨Çow. There are two main
steps to W AYOUT‚Äôs workÔ¨Çow. First, the user provides the path
to the header Ô¨Åles or the include directory. W AYOUTthen
generates a Python API consisting of wrappers for the C++API, which was declared in the passed header Ô¨Åles. The usercan then access the C++ API using the Python API exposedby the generated wrappers.
1) Header Files: The Ô¨Årst step in using W
AYOUTis
passing in the header Ô¨Åles containing the required class andfunction declarations that together constitute the API (step 1/circlecopyrt
in Figure 4).
W
AYOUTcan then generate Python wrappers that mirror
the C++ API (kernel.py in Figure 4).
2) Python Wrappers: Once the Python wrappers have been
generated, they can be imported (step 2/circlecopyrt) and called (step 3/circlecopyrt)
by the user. Calling a wrapper for the Ô¨Årst time will generatethe templated bindings which will then be compiled into ashared library 4/circlecopyrt. Figure 5 shows the SpMV example using the
generated wrappers. Similar to the C++ version, we Ô¨Årst aliasthe matrix type (line 3), and then deÔ¨Åne the matrix and vectors(lines 5-9). We call the CrsMatrix class method nnz, which
returns the number of entries in the matrix, to demonstratehow a class method can be called (line 6). Finally, we call thespmv kernel (line 10).
W
AYOUTgenerates wrappers for both function and class
declarations, as well as wrappers for public Ô¨Åelds and methods,
94Fig. 4: An overview of W AYOUT‚Äôs workÔ¨Çow.
1if name ==‚Äùmain ‚Äù:
2 # assume constructor arguments are initialized
3 mat t = CrsMatrix(
4 Ô¨Çoat, int,‚ÄùKokkos::DefaultExecutionSpace‚Äù, None, int)
5 A = mat t(numRows, numCols, nnz, val, ptr, ind)
6 print(‚Äùnum elem:‚Äù, A.nnz())
7
8 y = View(‚Äùdouble *‚Äù)(N)
9 x = View(‚Äùdouble *‚Äù)(N)
10 spmv(char ptr(‚ÄùN‚Äù), alpha, A, x, beta, b)
Fig. 5: Python W AYOUTexample using spmv andCrsMatrix.
1if name ==‚Äùmain ‚Äù:
2 # assume constructor arguments are initialized
3 crsmat t = CrsMatrix(
4 Ô¨Çoat, int,‚ÄùKokkos::DefaultExecutionSpace‚Äù, None, int)
5 A = generate structured matrix2D(
6 ‚ÄùFD‚Äù, structure, template args=[crsmat t])
Fig. 6: Python W AYOUTexample using template_args.
in the original C++ API.
Functions. One Python wrapper function is generated for
each C++ function. An issue that arises here is overloaded
functions. ‚≠êPython does not allow overloaded functions i.e.,
redeÔ¨Åning a function with a different number and differenttypes of arguments. To account for this, W
AYOUTinstead
generates a single wrapper function with a variable number ofarguments for each unique function name. At run-time, if anoverloaded function is used, the correct instance will be calledbased on the number and types of the arguments passed bythe user.
Users can call templated functions normally because the
template arguments can be deduced from the argument typesat run-time in most cases. ‚≠êIn some cases, these types
cannot be deduced, and so have to be explicitly speciÔ¨Åedby the user. For example, Figure 6 shows a code snippettaken from a Kokkos Kernels tutorial using CrsMatrix.
Instead of calling the constructor directly, it calls thegenerate_structured_matrix2D kernel to initialize the
matrix. In C++, this kernel is templated on the type of thematrix to be initialized. The two arguments are for stenciltype and matrix structure. These arguments do not hint atwhat the type of the generated matrix should be, so the usersmust pass the template argument to W
AYOUT; otherwise, C++
compilation fails. These arguments can be passed in via thekeyword argument template_args.
When the user calls a function, the arguments are passed to
the underlying kernels by reference. However, there are caseswhere a kernel expects an argument as a pointer. To supportthis, W
AYOUTprovides a simple class named ptr which the
user can use to wrap their object and indicate that the argumentshould be passed as a pointer. A similar issue occurs withstring arguments: some functions require the standard C++string whereas others accept character pointers. To support
this, Python strings are cast to standard strings by default,and arguments that are character pointers use the char_ptr
wrapper class. Line 10 in Figure 5 shows an example of this.
If a function returns a pointer, the default behavior is to treat
it as a reference, i.e., assume that C++ retains ownership ofthe object. This means that when the resource is freed, Pythonwould not attempt to garbage collect the object and assumethe C++ run-time would do so. To override this behavior, theuser can set the boolean keyword argument take_ownership
so that Python is responsible for freeing memory.
Classes. One wrapper class is generated for each C++ class.
The__init__ method (i.e., the constructor in Python) of the
wrapper class is used to pass in template arguments, creating
atype object that can also be used as a type alias (Figure
5 line 3). To create an instance of the class, the user callsthe type object, passing in the constructor arguments to the__call__ method (line 5).
Wrapper classes can accept a variable number of templates
to support optional template arguments. Additionally, if thetemplate argument is a primitive data type (i.e., int, float,
etc.), the corresponding Python data type can be used. If thetemplate argument is a class type, it can be set to a type alias orit can be passed as a string. The latter is useful for referring totypedefs deÔ¨Åned in the header Ô¨Åles. For instance, in KokkostheDefaultExecutionSpace type is simply a typedef that
changes depending on compile-time Ô¨Çags, but we can still useit as a template argument in Python by passing it as a string tothe class constructor (line 3). This can also be used to specify
95pointer types (e.g., double*) for template arguments (line 8).
Once an object has been created, it can be used like any
Python object. The wrapper class contains all class Ô¨Åelds
and methods present in the C++ version. Private Ô¨Åelds andmethods are not accessible. As W
AYOUTsupports inheritance,
attributes from the parent class are accessible as well. Anyobject returned from a function call will be automaticallywrapped using the correct wrapper class.
Figure 7 shows the generated Python wrappers for the
SpMV example. The spmv wrapper is deÔ¨Åned on line 1 and
theCrsMatrix wrapper is deÔ¨Åned on line 8; the contents of
these wrappers are explained in the next section.
IV . T
ECHNIQUES
In this section, we describe our binding generation ap-
proach, including both static and dynamic phases. In thestatic phase (Section IV-A), W
AYOUTparses C++ header Ô¨Åles
to generate Python wrappers and templated bindings. In thedynamic phase (Section IV-B), W
AYOUTintercepts calls to the
Python wrappers. Then, it instantiates, compiles, and importsthe templated bindings based on the types known only atrun-time, completing the link between Python and C++. Wethen describe the casting mechanisms used to move argumentsfrom Python to C++ and vice versa (Section IV-C). Next, wedescribe our techniques to support inheritance (Section IV-D)and operator overloading (Section IV-E). Finally, we discussGPU support (Section IV-F) and integration with manuallywritten bindings (Section IV-G).
There are two highlights to our approach: Ô¨Årst, generating
Python code in the form of wrapper classes and functionsallows the user to easily use and potentially modify thegenerated bindings; second, the lazy approach to bindinginstantiation and compilation reduces the otherwise high com-putational cost of binding and compiling everything ahead oftime. Once a binding has been compiled, it is cached on theÔ¨Åle system for later use.
A. Static Generation
We use Clang [32] to parse the header Ô¨Åles and py-
bind11 [12] as the bindings library. We chose pybind11 due
to its popularity, Ô¨Çexibility, and ease of use. Writing bindingsusing pybind11 involves deÔ¨Åning a Python module object
which is used to register classes and functions so that theycan be accessed from Python.
When W
AYOUTis invoked by a user, it uses the Clang
Python API to parse the header Ô¨Åles and return the root nodeof the corresponding Abstract Syntax Tree (AST). W
AYOUT
can then extract the API from header Ô¨Åles by traversing theAST recursively to discover classes and functions. One issuewith this approach is that ‚≠êPython does not allow function
or method overloading, both of which are used heavily inHPKs, such as Kokkos Kernels, especially for constructors.To deal with this, W
AYOUTÔ¨Årst stores function names in a
set so that only one wrapper function is generated, even ifother overloaded instances exist. Inside the wrapper functionsfor overloaded functions, W
AYOUTadds code that selects1defspmv( *args, template args=None, take ownership=False):
2 mod, name=generate func binding(‚Äùspmv‚Äù, ‚ÄùKokkosSparse‚Äù,
3 args, includes, template args, take ownership)
4 args = [get handle(arg) forarginargs]
5 res = getattr(mod, name)( *args)
6 return cast return(res)
7
8class CrsMatrix:
9 ‚Äù‚Äù‚ÄùCompressed sparse row implementation of a sparse matrix.‚Äù‚Äù‚Äù
10 namespace = ‚ÄùKokkosSparse‚Äù
11 def init (self, *template args, handle=None):
12 self. handle = handle
13 self. cpp name = handle. cpp type ifhandle else\
14 register class(‚ÄùCrsMatrix‚Äù, self. namespace, template args)
15 def call (self, *args):
16 ifself. handle:
17 if hasattr(self, ‚Äôcpp call ‚Äô):
18 return self. cpp call (*args)
19 raise RuntimeError(
20 ‚ÄùError: can‚Äôt call constructor on instance!‚Äù)
21 mod,name = generate constructor(self. cpp name, args, includes)
22 args = [get handle(arg) forarginargs]
23 inst = copy.copy(self)
24 inst. handle = getattr(mod, name)( *args)
25 return inst
26 defnnz(self, *args, take ownership=False):
27 ‚Äù‚Äù‚Äù//! The number of stored entries in the sparse matrix.‚Äù‚Äù‚Äù
28 mod,name = generate class func binding(self, ‚Äùnnz‚Äù, args,
29 includes, take ownership)
30 args = [get handle(arg) forarginargs]
31 res = getattr(mod, name)(self. handle, *args)
32 return cast return(res)
33 ‚Äù‚Äù‚Äù/*...*/‚Äù‚Äù‚Äù
Fig. 7: Python wrapper generated by W AYOUTforspmv and
CrsMatrix.
1#include <pybind11/pybind11.h>
2#include <KokkosSparse_CrsMatrix.hpp>
3template <class T>
4void generate_class(pybind11::module &_mod,
5 const char *name, const char *cpp_type) {
6 pybind11::class_<T> _class(_mod, name);
7 _class.def_property_readonly_static( "_cpp_type",
8 [cpp_type](const pybind11::object&) {
9 return cpp_type;
10 });
11 _class.def_readwrite( "graph", &T::graph);
12 _class.def_readwrite( "values", &T::values);
13 /* ... */
14}
Fig. 8: Generated C++ templated header for the CrsMatrix.
the appropriate overloaded instance at run-time based on the
types of the arguments. These types are extracted from thearguments using the Python built-in function type().
W
AYOUTthen generates Python wrappers mirroring the
original C++ API. Figure 7 partially shows the generatedwrappers for the spmv function and CrsMatrix class, with the
latter also containing wrapper methods for its correspondingC++ class methods.
In addition to Python wrappers, W
AYOUTgenerates one
C++ header Ô¨Åle for each class encountered during AST traver-sal. Figure 8 shows the header generated for the CrsMatrix
class. The header Ô¨Åle contains a function templated on T,
where Tis the type to be registered via pybind11. The
96function registers the type Twith pybind11, as well as all
the class Ô¨Åelds. Since all instances of a templated class
have the same members, the header Ô¨Åle can be reused bydifferent instantiations of the templated class at run-time e.g.,CrsMatrix<double,...> orCrsMatrix<int,...>.
B. Dynamic Generation
At run-time, the user imports and calls the generated Python
wrappers (shown in Figure 7). Internally, the wrappers call
W
AYOUTto instantiate the templated functions based on
the types passed, generating a C++ source Ô¨Åle that uses thetemplated binding header Ô¨Åles generated in the static phase.
W
AYOUTthen compiles the C++ source into a shared object
Ô¨Åle (or simply DSO) that can be imported and used by thewrapper. Later calls to the same wrappers will reuse theexisting DSO if the types are unchanged.
1) Wrapper: In Figure 7, the spmv wrapper calls the
W
AYOUTfunction generate_function_binding (line 2)
to generate the function binding. This call captures infor-mation such as function name ("spmv") and namespace("KokkosSparse") which are needed to uniquely identifythe C++ function that needs to be bound. This is needed incombination with the arguments and optionally the templatearguments to generate a hash that uniquely identiÔ¨Åes the bind-ing instantiation. Similarly, the methods of CrsMatrix call
W
AYOUTto generate instantiated bindings. The generate
functions check to see if a module matching the hash has beenimported. If so, it simply returns the module object containingthe function. If the module has not been imported, W
AYOUT
attempts to import it from the Ô¨Åle system. If the correspondingDSO does not exist, then W
AYOUTgenerates the binding
instantiation source code for the function.
2) Binding Generation: There are two main types of bind-
ings. One is for registering classes so pybind11 knows howto cast objects between Python and C++, while the otheris for binding an instantiated templated function. For classregistration, the binding source code Ô¨Årst includes the classheader (shown in Figure 8) generated during the static phaseand uses it to register classes. For function bindings, W
AYOUT
generates intermediate C++ functions that cast arguments fromPython types to the corresponding C++ types and internallycall the API function.
Figure 9 shows examples for both types of bindings. During
class registration, a Python module object is Ô¨Årst created usingthePYBIND11_MODULE (line 4). The Ô¨Årst argument is the name
of the kernel which is set to the unique hash correspondingto that instantiation. The second argument is a handle to themodule object that is used to register functions for that module.Then, the class is registered in pybind11 (line 5).
W
AYOUTdeÔ¨Ånes an intermediate function for each method
(lines 15, 26, and 35) which accepts as input an argument oftype pybind11::args containing a list of arguments. We use
auto as the return type of the intermediate functions and rely
on the compiler to deduce it from the argument types.
Each intermediate function explicitly casts each argument to
its corresponding C++ type (e.g., lines 16-17) and then calls1/*==================================================*/
2/* generated binding code for registering CrsMatrix */
3#include "CrsMatrix.hpp"
4PYBIND11_MODULE(f_f8ee838d9c3174dc82a, k) {
5 generate_class<KokkosSparse::CrsMatrix<
6 double, int,
7 Kokkos::DefaultExecutionSpace, void, int>>(
8 k,"f_f8ee838d9c3174dc82a" ,
9 "KokkosSparse::CrsMatrix<double,int,"
10 "Kokkos::DefaultExecutionSpace,void,int>" );
11}
12
13/*==================================================*/
14/* generated binding code for CrsMatrix constructor */
15auto func(pybind11::args args) {
16 auto a0 = args[0].cast<std::string>();
17 auto a1 = args[1].cast<int>();
18 /* ... */
19 return new KokkosSparse::CrsMatrix< double, int,
20 Kokkos::DefaultExecutionSpace, void, int>
21 {a0, a1, a2, a3, a4, a5, a6};
22}
2324
/*==================================================*/
25/* generated binding code for nnz method of CrsMatrix */
26auto func(pybind11::args args) {
27 auto &a0 = args[0].cast<
28 KokkosSparse::CrsMatrix< double, int,
29 Kokkos::DefaultExecutionSpace, void, int> &>();
30 return a0.nnz();
31}
3233
/*==================================================*/
34/* generated binding code for spmv */
35auto func(pybind11::args args) {
36 auto a0 = args[0].cast<std::string>();
37 auto a1 = args[1].cast<double>();
38 /* ... */
39 return KokkosSparse::spmv(a0.c_str(), a1, a2, a3, a4, a5);
40}
Fig. 9: Generated C++ binding instantiation code for the
SpMV example.
the C++ API function. The Ô¨Årst function calls the CrsMatrix
constructor (line 19), the second function calls the nnz class
method (line 30), and the third function calls the standalone
spmv function (line 39).
The bindings are then compiled into object Ô¨Åles. Intuitively,
WAYOUTwould then link the Ô¨Åles containing all the instan-
tiations into one single DSO Ô¨Åle and import it. Whenever anew instantiation is generated and linked, W
AYOUTwould
reload the DSO. However, this will not work because ‚≠ê
Python does not provide support for dynamically reloadingDSOs unless their reference count reaches zero and they aregarbage collected. Waiting for the garbage collector to run isunreliable and might not even happen before the applicationcompletes. Our solution is to generate a separate DSO for eachtemplate instantiation of every class and function. This has theadded beneÔ¨Åt of avoiding the extra linking overhead when newbindings are generated. It also allows W
AYOUTto elegantly
support overloading and templates by separating them intodifferent modules and avoiding re-deÔ¨Ånition errors in Python,since each combination of arguments would correspond to adifferent module.
97The generated Python wrapper can then access and call
functions registered in the module using the built-in getattr
function (Figure 7, lines 5, 24, and 31).
C. Casting
When the user calls a bound function (such as spmv in
Figure 5, line 10), W AYOUTcasts the passed arguments from
types that are valid in Python to types that are valid in C++.
Once control returns to the Python side, the returned bindingobject is also cast to the correct wrapper class. W
AYOUTuses
three forms of casting: explicit, implicit, and autocasting.
1) Explicit Casting: As mentioned previously, intermediate
functions accept as input a list of arguments (args). Explicitcasting refers to calling the pybind11 cast method on ele-
ments of args to convert them into types that can be used in
C++, storing them in local variables (Figure 9, lines 16-17).These variables can then be passed to the C++ function call.
The type to be cast to is passed as a template argument.
Since the binding instantiation is generated at run-time, thesetypes are chosen based on the types of the passed arguments.This form of casting works Ô¨Åne if the argument is a primitive(e.g., int). However, if the argument type is one of the
wrapper classes (e.g., CrsMatrix), an additional implicit cast
may be required.
2) Implicit Casting: In heavily templated classes, it is
common for objects with slightly different template instantia-tions to be semantically equivalent. For instance, the KokkosView object has an execution space template argument, whichcan either be of type Device orMemorySpace, which are
interchangeable. In the SpMV example, spmv can accept both
Kokkos::View<double *, HostSpace> and
Kokkos::View<double *, Device<OpenMP, HostSpace>for its View arguments, even if they are different types, be-cause Kokkos internally implements implicit casting betweenthe two.
In order for pybind11‚Äôs cast to work on non-primitive
types, W
AYOUTmust use the type that was obtained during
class registration, as that is the type that pybind11 recognizes.Otherwise, cast throws an exception for an illegal cast.
In some cases, different parts of a C++ API depend on
different template instantiations of the same class, even ifthey are semantically equivalent. ‚≠êThis is a challenge for
W
AYOUT since it uses pybind11 to cast objects to the exact
type needed by functions, which will result in an exception ifthere is any difference in types.
To solve this, W
AYOUTcaches information about the C++
type of a binding object by adding an extra _cpp_type Ô¨Åeld
during class registration. This extra Ô¨Åeld is a string set tothe fully qualiÔ¨Åed C++ type name. Therefore, during bindinggeneration, W
AYOUTcan use this stored name to cast the
argument to the appropriate type.
3) Autocasting: ‚≠êWhen an object is returned from a
function, pybind11 does not cast it to one of WAYOUT‚Äôs
wrapper classes, so it cannot be used to access the Ô¨Åeldsand methods. Ideally, the functions would return objects ofthe same type as the generated wrapper class.W
AYOUTtherefore wraps these objects in the appropriate
wrapper class so the class Ô¨Åelds and methods can still beaccessed normally (Figure 7, line 6). To do so, W
AYOUT
Ô¨Årst checks if the returned object has the _cpp_type Ô¨Åeld.
If not, then the returned object is a primitive and no castingis needed. Otherwise, W
AYOUTinitializes a wrapper object
using the binding object as the handle.
Additional complications occur when the return type has not
been registered with pybind11. For example, assume the usercalls a function that returns a matrix type that has not beeninstantiated before. To solve this, we also generate dummy
functions which return empty instances of the return type.When a module is imported, W
AYOUTalso calls the dummy
function. If the class is not registered, a TypeError will be
thrown by pybind11, which we catch and parse to extract theclass that needs to be registered. Since this only needs to bedone once when a module is imported, the overhead is minimaland guarantees that all return types are registered.
D. Inheritance
Inheritance is a commonly used feature in C++ to facilitate
code reuse. While it is not used much in Kokkos Kernels,
Thrust [19] extensively utilizes inheritance in its variousstructures. W
AYOUTsupports inheritance during the static
phase, where the name of the parent can be extracted fromthe AST. Then we can naturally emulate the C++ inheritancerelationship by having the Python wrapper class of a C++ childclass inherit from the Python wrapper class of the parent.
E. Operator Overloading
Operator overloading in C++ is used to implement the built
in operators for custom datatypes, e.g., using the [ ] operator
to access elements in a data structure. W
AYOUTsupports
operator overloading by treating them as class methods, withthe caveat that the method name is mapped to the corre-sponding Python magic method name (e.g., operator[] to
__setitem__ and__getitem__). Since W
AYOUTalready
uses the __call__ magic method for invoking the constructor,
we map the C++ call operator to a new __cpp_call__
method which is invoked when a class instance is called(e.g., Figure 7 line 17). W
AYOUTcurrently supports the C++
addition, subtraction, bracket, call, and dereference operators,although support for others is planned.
F . GPU Support
As most HPKs support heterogeneous systems, it is impor-
tant for W
AYOUTto support GPUs as well. Code that runs
on GPUs (e.g., CUDA or HIP) typically cannot be compiled
using a regular C++ compiler such as g++. Instead, it needs tobe compiled with a speciÔ¨Åc compiler (e.g., NVCC for CUDA).This is easy to do in W
AYOUT, as the only modiÔ¨Åcation
needed is to switch to the right compiler. Additionally, sinceone of the main targets of our work is Kokkos, the kernelinterface does not change when running with a GPU, so nofurther modiÔ¨Åcations to W
AYOUTare needed.
98G. Integration of Manually Written Bindings
There are instances where it is still beneÔ¨Åcial to use man-
ually written bindings for convenience reasons. For instance,
the Kokkos View object is a general purpose n-dimensionaldata structure. It overloads the parentheses operator for readingand modifying data instead of the commonly used squarebrackets (e.g., int x = view(1);). This does not work well
with pybind11 since the parentheses operator returns a refer-ence to a primitive, which pybind11 handles by passing byvalue to Python, meaning that modiÔ¨Åcation of the contentsis not possible. However, Kokkos does have Python bindings(manually written) for Views [13]. These bindings leverage apybind11 feature that allows the Python buffer protocol [33]to be implemented for the raw data buffer contained in Views,which allows the internal data to be accessed normally fromPython. Since they are implemented using pybind11, thesebindings can be used seamlessly with W
AYOUT.
V. E V ALUATION
We evaluate W AYOUTby answering the following four
research questions:
RQ1. How effective is W AYOUTat generating bindings for
Kokkos Kernels and CUDA Thrust?RQ2. What is the run-time performance overhead of the
bindings generated by W
AYOUT?
RQ3. How does the run-time performance of the automatically
generated bindings compare to handwritten bindings?RQ4. What is the time needed to generate the bindings?
We ran all experiments on an Ubuntu 18.04 machine with a 6-
core Intel Core i7-8700 3.20GHz CPU and 64GB of RAM, andan Nvidia GeForce 1080 GPU with 8GB of memory. We usedPython 3.8.5, GCC 7.5, OpenMP 4.5, and CUDA 10.2. Weused Kokkos 3.1.01, and Kokkos Kernels from the ‚Äúdevelop‚Äùbranch (commit 62985984). Finally, we used Thrust 1.12.0.
All data presented are averaged over 3 runs and the Thrust
subjects were run for 100 iterations.
A. Results
RQ1: How effective is W
AYOUT at generating bindings for
Kokkos Kernels and CUDA Thrust?
Using W AYOUT, we automatically generated bindings for
allthe kernels in the Kokkos Kernels framework. We veriÔ¨Åed
that W AYOUTis able to run all 39 kernels present in the
Kokkos Kernels wiki [34], as well as the sparse matrix
container CrsMatrix and numerous other helper functions
used for memory allocation and initialization.
We then ported existing C++ programs that use these kernels
to Python. SpeciÔ¨Åcally, we implemented 7 applications fromthe ofÔ¨Åcial Kokkos repository [35] in Python:
‚Ä¢CGSolve: Implements a conjugate gradient algorithm forsolving systems of linear equations of the form Ax=b.
‚Ä¢CGSolve SpILUKprecond: Similar to CGSolve, but
uses preconditioning for faster convergence.
‚Ä¢GaussSeidel: Implements the Gauss-Seidel method forsolving a system of linear equations.‚Ä¢GraphColoring: Assigns colors to elements of a graphsuch that no neighboring nodes have the same color.
‚Ä¢InnerProduct: Calculates the inner product of the form
‚ü®y, A‚àóx‚ü©=yT‚àóA‚àóx.
‚Ä¢SpGEMM: Implements sparse matrix-matrix multiplica-
tion in two phases: symbolic followed by numeric, witha kernel for each phase.
‚Ä¢SpILUK: Implements sparse k-level incomplete LU fac-torization.
We also need Python bindings for Kokkos Views as theyappear frequently in our test subjects and in Kokkos Kernels.In our subjects, we used both the manually written Pythonbindings and bindings automatically generated by W
AYOUT.
As mentioned before, Views use the C++ parentheses operatorto modify data, meaning that they cannot be directly modiÔ¨Åedin Python using the automatically generated bindings, so weimplement only four of our subjects using the latter.
To demonstrate the generality of our approach, we also
generated bindings for kernels in the Thrust library. We ported7 examples from the ofÔ¨Åcial Thrust repository [36] to Python:histogram, mode, saxpy, set
operations, sort, sparse, and sum.
In summary, W AYOUTsuccessfully generated bindings to
Kokkos Kernels and Thrust, which we were able to use to portworkloads from C++ to Python.
RQ2: What is the run-time performance overhead of the
bindings generated by W
AYOUT?
Figure 10 shows plots of computation time (y-axis) vs. input
data size (x-axis) for our subjects from Kokkos Kernels andThrust. For W
AYOUT, we show computation time after the
bindings have been instantiated and compiled for all types thatoccur in each subject. We show binding generation time inRQ4. The time shown does not include time spent to initializethe subject, as most subjects initialize arrays in sequentialloops, which dominates the running time for larger input sizes.Including that time would mean comparing Python to C++rather than measuring the overhead of the generated bindings.
For most subjects, our Python implementation can achieve
performance comparable to the original C++ implementation.
For the CGSolve subject, we observe overhead that scales
with the size of the input data. This happens because thesubject runs most of its computations in a loop that calls thekernel internally. It also computes a square root in Pythonusing the math.sqrt() function. The number of iterations of
this loop scales with the size of the input data, increasing thenumber of calls to math.sqrt(), which in turn increases the
total time taken compared to the C++ implementation.
We also observe noticeable performance overhead for the
set
operations subject (Figure 10k). This subject invokes var-
ious functions that each allocates a result vector and callsa different set operation (e.g., merge, union). In C++, theresult vector is allocated on the stack, while in Python, theobject must be allocated on the heap. Both heap allocation andPython‚Äôs garbage collector introduce substantial overhead.
Thus, these two outliers can be attributed to Python itself
rather than W
AYOUT. In summary, bindings generated by
WAYOUTintroduce minimal performance overhead.
99
6L]H7LPH>V@
D&*6ROYH:D\2XW2SHQ03
.RNNRV2SHQ03
:D\2XW&8'$
.RNNRV&8'$

6L]H
E&*6ROYHB6S,/8.SUHFRQG:D\2XW2SHQ03
.RNNRV2SHQ03
:D\2XW&8'$
.RNNRV&8'$

6L]H
F*DXVV6HLGHO:D\2XW2SHQ03
.RNNRV2SHQ03
:D\2XW&8'$
.RNNRV&8'$

6L]H7LPH>V@
G*UDSK&RORULQJ:D\2XW2SHQ03
.RNNRV2SHQ03
:D\2XW&8'$
.RNNRV&8'$

6L]H
H,QQHU3URGXFW:D\2XW2SHQ03
.RNNRV2SHQ03
:D\2XW&8'$
.RNNRV&8'$

6L]H
I6S*(00:D\2XW2SHQ03
.RNNRV2SHQ03
:D\2XW&8'$
.RNNRV&8'$

6L]H7LPH>V@
J6S,/8.:D\2XW2SHQ03
.RNNRV2SHQ03
:D\2XW&8'$
.RNNRV&8'$

6L]H
KKLVWRJUDP:D\2XW2SHQ03
7KUXVW2SHQ03
:D\2XW&8'$
7KUXVW&8'$

6L]H
LPRGH:D\2XW2SHQ03
7KUXVW2SHQ03
:D\2XW&8'$
7KUXVW&8'$

6L]H7LPH>V@
MVD[S\:D\2XW2SHQ03
7KUXVW2SHQ03
:D\2XW&8'$
7KUXVW&8'$

6L]H
NVHWBRSHUDWLRQV:D\2XW2SHQ03
7KUXVW2SHQ03
:D\2XW&8'$
7KUXVW&8'$

6L]H
OVRUW:D\2XW2SHQ03
7KUXVW2SHQ03
:D\2XW&8'$
7KUXVW&8'$

6L]H7LPH>V@
PVSDUVH:D\2XW2SHQ03
7KUXVW2SHQ03
:D\2XW&8'$
7KUXVW&8'$

6L]H
QVXP:D\2XW2SHQ03
7KUXVW2SHQ03
:D\2XW&8'$
7KUXVW&8'$
Fig. 10: Kernel time using W AYOUTgenerated bindings vs. original Kokkos Kernels/Thrust implementation.
100TABLE I: Performance of Generated versus Manually Written Bindings.
Subject Size OpenMP Time [s] CUDA Time [s]
Manual Generated Ratio Manual Generated Ratio
CGSolve SpILUKprecond 22099.14 102.49 1.03 31.46 30.51 0.97
GaussSeidel 22443.09 43.33 1.01 18.14 19.76 1.09
InnerProduct 23031.65 31.62 1.00 212.82 213.79 1.00
SpILUK 2213.18 3.12 0.98 9.66 9.71 1.01
TABLE II: Bindings Build Time (Kokkos Kernels on the left and Thrust on the right).
Subject Kernels Modules Static
Phase
[s]Dynamic
Phase
(g++) [s]Dynamic
Phase
(NVCC) [s]Subject Kernels Modules Static
Phase
[s]Dynamic
Phase
(g++) [s]Dynamic
Phase
(NVCC) [s]
CGSolve 7 12 3.43 32.13 82.93 histogram 13 34 4.21 98.84 281.24
CG SpILUK 23 35 5.94 96.17 248.01 mode 10 28 4.15 81.86 230.83
GaussSeidel 8 15 5.77 43.17 111.63 saxpy 6 17 3.52 49.41 139.40
GraphColoring 11 17 5.13 51.29 130.21 setoperations 11 17 3.68 49.50 144.43
InnerProduct 2 2 3.05 7.59 26.28 sort 5 12 3.61 34.79 98.36
SpGEMM 7 12 4.37 33.23 85.83 sparse 9 33 3.81 96.60 273.38
SpILUK 18 28 5.31 76.49 196.39 sum 4 11 3.50 31.92 90.87
RQ3: How does the run-time performance of the automatically
generated bindings compare to manually written bindings?
We compare the manually written Python bindings provided
in the Kokkos repository for the View class against the bind-
ings generated by W AYOUT. Table I shows the performance
of the generated bindings versus the handwritten ones withboth OpenMP and CUDA. The Ô¨Årst column shows the nameof the subject. The second column shows the size of the inputdata. The rest of the table shows computation time for boththe manually written and automatically generated bindings, aswell as the ratio of generated time to manual time.
The results show that the performance of the bindings
generated by W
AYOUTmatches that of the manually written
bindings. This is expected as both sets of bindings use py-bind11, and W
AYOUTonly generates an additional lightweight
Python wrapper which has minimal performance overhead.
RQ4: What is the time needed to generate the bindings?
Table II shows the average time taken to automatically
generate the bindings for each library. The columns show the
name of the subject, the number of kernels used, the numberof modules generated (i.e., DSOs that instantiate the classesand functions), the time taken during the static phase, andthe time taken during the dynamic phase for g++ and NVCCrespectively.
The results show that W
AYOUThas acceptable execution
time. The largest cause of performance overhead in eitherphase is caused by calling the C++ compiler. The time takenduring the static phase is mostly caused by compiling theenums DSO Ô¨Åle and does not vary greatly across subjects.The time taken during the dynamic phase varies dependingon the number of modules generated and the compiler used.More kernel calls with different types results in more templateinstantiations, and therefore more modules generated. Forexample, the CGSolve
SpILUKprecond subject has a largedynamic phase execution time, as it calls 23 kernels andgenerates 35 modules, more than any other subject.
It is important to note that the execution time shown here
only occurs once, when the bindings are instantiated for theÔ¨Årst time. Later calls of kernels with the same types, andeven later runs of the same application would not incur thisoverhead as the modules are cached on the Ô¨Ålesystem.
W
AYOUTis also considerably faster than the approach used
in the Kokkos View bindings [13], which is a purely staticapproach that instantiates all combinations of types duringcompilation. On our machine, compiling those bindings takesover 6 hours, and runs out of memory on another machine.
VI. L
IMITATIONS
C++ allows passing arguments and returning values by
value, pointer, or reference. Python always passes primitivesby value and objects by reference. As such, the Python APIgenerated by W
AYOUTwill not always exactly match the
functionality of the C++ API: primitives are always passed andreturned by value, and objects are always passed by referenceor pointer. W
AYOUTallows passing pointers with ptr and
character pointers with char_ptr.
Another limitation of W AYOUTis that the generated wrap-
pers may not be very ‚ÄúPythonic‚Äù. For example, while ptr
andchar_ptr are practical solutions to pointer arguments,
such constructs will be unfamiliar to Python programmers.Additionally, the generated wrappers do not make use ofcertain Python features such as keyword arguments (i.e.,**kwargs) and dynamic typing.
It would be possible to make the generated APIs more
Pythonic by adding another layer of abstraction on top of thewrappers generated by W
AYOUT. Currently, this would require
additional effort from the user, although we plan to explore away to automate this step in future work.
101Some kernels in Thrust accept a function object as an argu-
ment in order for the user to deÔ¨Åne kernel behavior. W AYOUT
does not support these kernels as this would require translating
Python code to C++; an earlier work, PyKokkos [11], supportstranslation from Python to C++. However, since the goal of
W
AYOUTis to bind existing HPKs where the behavior is
already deÔ¨Åned, this is a minor limitation.
Finally, we focused primarily on Kokkos and Thrust in
our evaluation. We chose Kokkos because it is a popularperformance portability framework with a large number ofkernels, and Thrust is a popular CUDA library.
VII. R
ELATED WORK
A. Binding Frameworks
Boost.Python [28], pybind11 [12], SWIG [29], and pyxim-
port [16] are frameworks that allow binding C or C++ code sothat it can be called from Python. Typically, these frameworksrequire that the user specify the C++ interface to be boundusing some form of domain-speciÔ¨Åc language or conÔ¨ÅgurationÔ¨Åle. W
AYOUTonly asks the user for the header Ô¨Åles containing
class and function declarations, and automatically generatesthe bindings with no extra effort from the user.
B. Static Binding Generation
CFFI [37] is a Python library that can import C code using
C-like declarations and generate the necessary bindings in a C
Ô¨Åle. However, it does not support C++ and requires the userto manually declare the interface. AutoWIG [30] provides aPython API to pass in header Ô¨Åles and then generates bindingsusing Boost.Python. Additionally, the user has to provide aheader Ô¨Åle that contains all the needed template instantiationsfor templated classes and functions. Afterwards, the usermust compile the generated bindings. Similarly, Binder [31]statically parses header Ô¨Åles to obtain all classes and functions.As with AutoWIG, the desired template instantiations mustbe explicitly used or speciÔ¨Åed in the header Ô¨Åles. In contrastto AutoWIG, it is meant to be used entirely through thecommand-line. W
AYOUTis more Ô¨Çexible and more Pythonic
through its dynamic analysis: templates are only instantiatedat run-time through types passed to automatically generatedPython wrapper classes. The user does not have to specify allthe types that they want to use ahead of time.
C. Dynamic Binding Generation
Cppyy [15] dynamically generates bindings to C++ libraries.
It uses Cling [18], a C++ interpreter based on Clang and
LLVM, to generate C++ code that instantiates and calls classesand functions included in header Ô¨Åles, and then binds thatcode to enable accessing it from Python. The deÔ¨Ånitionsof those classes and functions are loaded at run-time bydynamically linking a shared object library. This presents aproblem for libraries such as Kokkos Kernels, which currentlycan only be compiled to a static library. W
AYOUTprovides the
Ô¨Çexibility of linking a static library during compilation, insteadof exclusively requiring shared object libraries as cppyy does.Additionally, W
AYOUT‚Äôs use of pybind11 to interface betweenPython and C++ allows the user to manually write bindingsfor some classes to make them more Pythonic if desired.
Furthermore, the dependence on Cling also limits supported
libraries to features supported by Cling. For instance, it doesnot have support for thread level storage symbol relocation,which is used in the shared object for Kokkos. Anotherexample is CUDA support. Since W
AYOUTinvokes a compiler
to compile shared objects, it has Ô¨Çexibility of choosing NVCCrather than g++ as the compiler, whereas Cling support forCUDA is still experimental.
D. High Performance Python
PyKokkos [11] is a framework for writing performance
portable kernels in Python. The user writes kernels in a
small, statically typed subset of Python, which PyKokkosthen translates to C++ (Kokkos) to obtain better performance.Numba [10] is a Python JIT compiler based on LLVM.Cython [16] adds C-like language extensions to Python toimprove performance. W
AYOUTis not meant for writing
kernels. W AYOUTprovides access to pre-existing, hand-tuned
high-performance kernels.
NumPy [27] and SciPy [26] both contain data structures and
kernels used in scientiÔ¨Åc computing. A signiÔ¨Åcant part of bothlibraries is implemented in C and C++ and manually wrappedso it can be accessed from Python. W
AYOUTautomatically
generates bindings to interoperate between Python and C++.
VIII. C ONCLUSION
We present W AYOUT, a technique for automatically gen-
erating Python bindings for C++ code, speciÔ¨Åcally high-performance kernels. W
AYOUTcombines static and dynamic
analysis in order to reconcile Python‚Äôs dynamic nature withC++‚Äôs static typing, and is able to support heavily templatedclasses and functions. We implement W
AYOUTby building
Python and C++ code generators that produce a connectionlayer between the two languages. Our evaluation shows that
W
AYOUTcan support Kokkos Kernels framework and CUDA
Thrust with minimal performance overhead. Additionally,
WAYOUTcan generate bindings at an acceptable performance
cost, making it more feasible than manually written and stati-cally generated bindings. We believe that W
AYOUTenables
faster development of scientiÔ¨Åc applications by connectingPython, a high-level language frequently used by scientists,to existing HPKs written in C++.
A
CKNOWLEDGMENT
We thank George Biros, Martin Burtscher, Ian Henrik-
sen, Jonathan R. Madsen, Arthur Peters, Keshav Pingali,Sivasankaran Rajamanickam, Christopher J. Rossbach, KarlW. Schulz, Christian Trott, and the anonymous reviewersfor their feedback on this work. This work was partiallysupported by the US National Science Foundation under GrantNos. CCF-1652517 and CCF-2107291, and the Departmentof Energy, National Nuclear Security Administration underAward Number DE-NA0003969.
102REFERENCES
[1] C. R. Trott, ‚ÄúExaMiniMD,‚Äù https://github.com/ECP-copa/ExaMiniMD,
2017.
[2] D. Lebrun-Grandi ¬¥e, A. Prokopenko, B. Turcksin, and S. R. Slattery,
‚ÄúArborX: A performance portable geometric search library,‚Äù ACM Trans-
actions on Mathematical Software, vol. 47, no. 1, pp. 1‚Äì15, 2020.
[3] S. Slattery, ‚ÄúCabana,‚Äù https://github.com/ECP-copa/Cabana, 2018.
[4] S. Rajamanickam, S. Acer, L. Berger-Vergiat, V . Dang, N. Ellingwood,
E. Harvey, B. Kelley, C. R. Trott, J. Wilke, and I. Yamazaki, ‚ÄúKokkoskernels: Performance portable sparse/dense linear algebra and graphkernels,‚Äù https://arxiv.org/abs/2103.11991, 2021.
[5] H. C. Edwards, C. R. Trott, and D. Sunderland, ‚ÄúKokkos: Enabling
manycore performance portability through polymorphic memory accesspatterns,‚Äù Journal of Parallel and Distributed Computing , vol. 74, no. 12,
pp. 3202‚Äì3216, 2014.
[6] C. Trott, L. Berger-Vergiat, D. Poliakoff, S. Rajamanickam, D. Lebrun-
Grandie, J. Madsen, M. Gligoric, N. Al Awar, G. Shipman, andG. Womeldorff, ‚ÄúThe Kokkos ecosystem: Comprehensive performanceportability for high performance computing,‚Äù Computing in Science and
Engineering.
[7] D. A. Beckingsale, J. Burmark, R. Hornung, H. Jones, W. Killian, A. J.
Kunen, O. Pearce, P. Robinson, B. S. Ryujin, and T. R. Scogland,‚ÄúRAJA: Portable performance for large-scale scientiÔ¨Åc applications,‚Äù inWorkshop on Performance, Portability and Productivity in HPC, 2019,pp. 71‚Äì81.
[8] T. E. Oliphant, ‚ÄúPython for scientiÔ¨Åc computing,‚Äù Computing in Science
and Engineering, vol. 9, no. 3, pp. 10‚Äì20, 2007.
[9] J. Bezanson, A. Edelman, S. Karpinski, and V . B. Shah, ‚ÄúJulia: A fresh
approach to numerical computing,‚Äù SIAM Review, vol. 59, no. 1, pp.
65‚Äì98, 2017.
[10] S. K. Lam, A. Pitrou, and S. Seibert, ‚ÄúNumba: A LLVM-based Python
JIT compiler,‚Äù in Workshop on the LLVM Compiler Infrastructure in
HPC, 2015, pp. 1‚Äì6.
[11] N. Al Awar, S. Zhu, G. Biros, and M. Gligoric, ‚ÄúA performance
portability framework for Python,‚Äù in International Conference on
Supercomputing, 2021, pp. 467‚Äì478.
[12] ‚ÄúPybind11 Documentation,‚Äù 2020, https://pybind11.readthedocs.io/en/
stable/intro.html.
[13] J. R. Madsen, ‚Äúkokkos-python,‚Äù https://github.com/kokkos/
kokkos-python, 2020.
[14] E. Slaughter and A. Aiken, ‚ÄúPygion: Flexible, scalable task-based par-
allelism with Python,‚Äù in Parallel Applications Workshop, Alternatives
To MPI, 2019, pp. 58‚Äì72.
[15] W. T. Lavrijsen and A. Dutta, ‚ÄúHigh-performance Python-C++ bindings
with PyPy and Cling,‚Äù in Workshop on Python for High-Performance
and ScientiÔ¨Åc Computing (PyHPC), 2016, p. 2735.
[26] P. Virtanen, R. Gommers, T. E. Oliphant, M. Haberland, T. Reddy,
D. Cournapeau, E. Burovski, P. Peterson, W. Weckesser, J. Bright, S. J.van der Walt, M. Brett, J. Wilson, K. J. Millman, N. Mayorov, A. R. J.Nelson, E. Jones, R. Kern, E. Larson, C. J. Carey, ÀôI. Polat, Y . Feng, E. W.
Moore, J. VanderPlas, D. Laxalde, J. Perktold, R. Cimrman, I. Henrik-
sen, E. A. Quintero, C. R. Harris, A. M. Archibald, A. H. Ribeiro,F. Pedregosa, P. van Mulbregt, and SciPy 1.0 Contributors, ‚ÄúSciPy 1.0:[16] S. Behnel, R. Bradshaw, C. Citro, L. Dalcin, D. S. Seljebotn, and
K. Smith, ‚ÄúCython: The best of both worlds,‚Äù in Computing in Science
and Engineering, 2011, pp. 31‚Äì39.
[17] ‚ÄúPyPy,‚Äù 2021, https://www.pypy.org/.
[18] V . Vassilev, P. Canal, A. Naumann, L. Moneta, and P. Russo, ‚ÄúCling
‚Äì the new interactive interpreter for ROOT 6,‚Äù in Journal of Physics:
Conference Series, 2012, pp. 52‚Äì71.
[19] N. Bell and J. Hoberock, ‚ÄúChapter 26 - Thrust: A productivity-oriented
library for CUDA,‚Äù in GPU Computing Gems Jade Edition, 2012, pp.
359‚Äì371.
[20] ‚ÄúOpenMP,‚Äù 2020, https://www.openmp.org.[21] ‚ÄúCUDA Zone,‚Äù 2020, https://developer.nvidia.com/cuda-zone.[22] The Trilinos Project Team, The Trilinos Project Website.
[23] ‚ÄúLAMMPS molecular dynamics simulator,‚Äù https://lammps.sandia.gov/,
2020.
[24] ‚ÄúAlbany multiphysics code,‚Äù http://snlcomputation.github.io/Albany/,
2020.
[25] M. T. Bettencourt and S. Shields, ‚ÄúEMPIRE: Sandia‚Äôs next genera-
tion plasma tool,‚Äù Sandia National Lab.(SNL-NM), Albuquerque, NM
(United States), Tech. Rep., 2019.Fundamental Algorithms for ScientiÔ¨Åc Computing in Python,‚Äù Nature
Methods , vol. 17, pp. 261‚Äì272, 2020.
[27] C. R. Harris, K. J. Millman, S. J. van der Walt, R. Gommers, P. Virtanen,
D. Cournapeau, E. Wieser, J. Taylor, S. Berg, N. J. Smith, R. Kern,M. Picus, S. Hoyer, M. H. van Kerkwijk, M. Brett, A. Haldane, J. F.del Rio, M. Wiebe, P. Peterson, P. Gerard-Marchant, K. Sheppard,T. Reddy, W. Weckesser, H. Abbasi, C. Gohlke, and T. E. Oliphant,‚ÄúArray programming with NumPy,‚Äù Nature, vol. 585, no. 7825, pp. 357‚Äì
362, 2020.
[28] D. Abrahams and R. W. Grosse-Kunstleve, ‚ÄúBuilding hybrid systems
with Boost.Python,‚Äù The C/C++ Users Journal, vol. 21, 2003.
[29] D. Beazley, ‚ÄúAutomated scientiÔ¨Åc software scripting with SWIG,‚Äù Future
Generation Computer Systems, vol. 19, no. 5, pp. 599‚Äì609, 2003.
[30] P. Fernique and C. Pradal, ‚ÄúAutoWIG: Automatic generation of Python
bindings for C++ libraries,‚Äù PeerJ Computer Science, vol. 4, 2018.
[31] RosettaCommons, ‚ÄúBinder,‚Äù https://github.com/RosettaCommons/
binder, 2016.
[32] C. Lattner and V . Adve, ‚ÄúLLVM: A compilation framework for lifelong
program analysis & transformation,‚Äù in International Symposium on
Code Generation and Optimization, 2004, pp. 75‚Äì86.
[33] T. Oliphant and C. Banks, ‚ÄúPep 3118 ‚Äì revising the buffer protocol,‚Äù
https://www.python.org/dev/peps/pep-3118/, 2006.
[34] S. Rajamanickam, ‚ÄúKokkos kernels wiki,‚Äù https://github.com/kokkos/
kokkos-kernels/wiki/APIReference, 2021.
[35] C. R. Trott, ‚ÄúKokkos Tutorials,‚Äù https://github.com/kokkos/
kokkos-tutorials, 2015.
[36] ‚ÄúThrust,‚Äù https://github.com/NVIDIA/thrust, 2021.
[37] ‚ÄúCFFI documentation,‚Äù https://cfÔ¨Å.readthedocs.io/en/latest/, 2012.
103