Reducing Bug Triaging Confusion by Learning from
Mistakes with a Bug Tossing Knowledge Graph
Yanqi Su
Australian National University
Australia
Yanqi.Su@anu.edu.auZhenchang Xing‚àó
Australian National University
Australia
Zhenchang.Xing@anu.edu.auXin Peng
Fudan University
China
pengxin@fudan.edu.cnXin Xia
Monash University
Australia
xin.xia@monash.edu
Chong Wang
Fudan University
China
wangchong20@fudan.edu.cnXiwei Xu
Data61, CSIRO
Australia
Xiwei.Xu@data61.csiro.auLiming Zhu‚Ä†
Data61, CSIRO
Australia
Liming.Zhu@data61.csiro.au
Abstract ‚ÄîAssigning bugs to the right components is the pre-
requisite to get the bugs analyzed and Ô¨Åxed. ClassiÔ¨Åcation-based
techniques have been used in practice for assisting bug component
assignments, for example, the BugBug tool developed by Mozilla.
However, our study on 124,477 bugs in Mozilla products revealsthat erroneous bug component assignments occur frequently and
widely. Most errors are repeated errors and some errors are
even misled by the BugBug tool. Our study reveals that complex
component designs and misleading component names and bug
report keywords confuse bug component assignment not only forbug reporters but also developers and even bug triaging tools.
In this work, we propose a learning to rank framework that
learns to assign components to bugs from correct, erroneousand irrelevant bug-component assignments in the history. To
inform the learning, we construct a bug tossing knowledge graph
which incorporates not only goal-oriented component tossingrelationships but also rich information about component tossing
community, component descriptions, and historical closed and
tossed bugs, from which three categories and seven types offeatures for bug, component and bug-component relation can
be derived. We evaluate our approach on a dataset of 98,587
closed bugs (including 29,100 tossed bugs) of 186 components
in six Mozilla products. Our results show that our approach
signiÔ¨Åcantly improves bug component assignments for both tossedand non-tossed bugs over the BugBug tool and the BugBug tool
enhanced with component tossing relationships, with >20% Top-
k accuracies and >30% NDCG@k (k=1,3,5,10).
Index T erms‚ÄîBug Triaging, Learning to Rank, Knowledge
Graph
I. I NTRODUCTION
Large software projects (e.g., Mozilla) receive a huge num-
ber of bug reports every day. To get the attention of suitable
developers on the bugs quickly, it is essential to assign bugs tothe right product and component (referred to as bug triagingin this work) whose developers have the expertise to review,analyze and Ô¨Åx the bugs. Manual bug triaging is a labor-intensive task, and is often error prone [1]‚Äì[4]. If the bug isnot assigned to the right component, it has to be re-assigned(or tossed) to the correct one. For example, the Mozilla‚Äôs
‚àóCorresponding author.‚Ä†Also with University of New South Wales.Bug 1194529 was initially assigned to Toolkit::Password
Manager (Product::Component) and then was tossed to Fire-fox::about:logins and Ô¨Åxed there. In this work, we refer to
bugs that have been tossed as tossed bugs, and bugs that areinitially assigned to correct components as non-tossed bugs.We refer to the component where a bug gets Ô¨Åxed as resolver,and the component(s) that a bug is erroneously assigned to asbystander(s). For example, Bug 1194529 is a tossed bug, andits resolver is Firefox::about:logins. This bug has a bystanderToolkit::Password Manager.
Since the seminal work by Anvik et al [5], machine learning
techniques have been used to assist bug triaging [1], [2]. These
techniques treat bug triaging as a multi-class classiÔ¨Åcationtask, taking as input the information of a bug (e.g., bug
summary) and predicting the most likely resolving componentas the class label. BugBug [6] is such a tool developed bythe Mozilla product team. We investigate 124,477 bugs of186 components of the six Mozilla products. We Ô¨Ånd that
38,374 (30.8%) bugs have been tossed at least once. Overall,
tossed bugs take 2.9 times longer to get Ô¨Åxed than non-tossed bugs. Compared with the statistics of bug tossingphenomena reported in early studies [1], [2], [4], the bugtossing situation actually does not change much, even after along-time deployment of machine learning based bug triagingtechniques.
As detailed in Section II, bug tossing is mostly caused by re-
peated erroneous bug-component assignments. These repeatederrors (no matter manually or by machine learning) stem fromthe lack of effective mechanisms to model and differentiateconfusing concepts related to bugs and software components,in particular complex component designs and relationshipsand misleading component names and bug report keywords.In practice, developers often resort to additional informa-tion such as detailed component descriptions and componentcommunities, rather than relying on only the information inbug reports, to correct erroneous bug-component assignments.Unfortunately, current bug triaging techniques [1], [2], [6] donot make use of such additional information. Furthermore,
UI*&&&"$.*OUFSOBUJPOBM$POGFSFODFPO"VUPNBUFE4PGUXBSF&OHJOFFSJOH	"4&
%0*"4&2021 36th IEEE/ACM International Conference on Automated Software Engineering (ASE) | 978-1-6654-0337-5/21/$31.00 ¬©2021 IEEE | DOI: 10.1109/ASE51524.2021.9678574

	
    
the formulation of bug triaging as a multi-class classiÔ¨Åcation
problem learns from each bug-component assignment indepen-dently. However, this is not sufÔ¨Åcient to distinguish misleadinginformation from key problem information in bug reports andhow different information relates to different components.
In fact, bug tossing history archives rick knowledge about
bug-component relations including both correct and erroneousassignments. We propose a novel framework (called LR-BKG, short for L
earn-to R ank with B ug tossing K nowledge
Graph) to reduce bug triaging confusion by learning from
bug tossing history. Inspired by the goal-oriented developer
tossing graph [7], our approach builds a goal-oriented com-
ponent tossing graph from bug tossing history. Driven byour empirical observation, we enrich this basic tossing graphinto a bug tossing knowledge graph by attaching three types
of information on each component (component description,closed bugs and tossed-out bugs), and by detecting componentcommunities based on historical tossing paths. We develop
three categories of features: bug feature, component fea-
tures and bug-component relation features. The feature designmakes full use of the concept- and community-enriched bugtossing graph. Instead of traditional multi-class classiÔ¨Åcation,we adopt a learning-to-rank framework which learns to differ-
entiate confusing bug-component relationships by contrasting
correct and erroneous bug assignments.
To evaluate our approach, we collect 98,587 closed bugs
(including 29,100 tossed bugs) of 186 components in sixMozilla products. To simulate real-world context, we sort thesebugs by their creation time and split them at 25th February,2020. This gives us 80% of bugs as ‚Äúhistorical‚Äù training dataand the rest 20% as ‚Äúfuture‚Äù bugs to test the trained model.We compare our approach with two baselines: BugBug andBugBug with tossing graph. Overall, LR-BKG achieves 20%or higher accuracy in recommending resolver components thanthe two baselines at all Top-ks (k=1, 3, 5, 10). It achievessame-level improvement for both tossed and non-tossed bugs,and achieves improvement for 73%-85% of components atdifferent Top-ks. Furthermore, LR-BKG can better rank by-stander components that have historical tossing relationshipswith resolver components (30% or higher NDCG@k (k=1, 3,5, 10) than BugBug). Our feature importance analysis showsthat all three categories of features as a whole contribute tothe signiÔ¨Åcant improvement LR-BKG achieves.
This paper makes the following contributions:
‚Ä¢We conduct an empirical study on the root cause ofrepeated bug tossing, which sheds the light on novel ways
to reduce bug triaging confusion.
‚Ä¢We propose a learning-to-rank framework that learnsto distinguish correct, erroneous and irrelevant bug-component assignments, based on a rich set of features
derived from our novel bug tossing knowledge graph.
‚Ä¢Our experiments conÔ¨Årm our approach‚Äôs superior perfor-
mance than the tool used in development practice, andconÔ¨Årm the effectiveness of our novel feature design. OurTABLE I: Tossed-In Bug Percentage of Product::Component
Tossed-In (%) 2.9-20% 20-40% 40-60% 60-80% 80-84.9%
#P::C 39 96 39 11 1
replication package can be found here1.
II. E MPIRICAL STUDY
We conduct an empirical study of bug tossing phenomena
to answer the following three research questions:
RQ1: Does bug tossing occur frequently and widely?
RQ2: Is bug tossing accidental mistake or repeated error?RQ3: What causes such repeated bug tossing?
A. Dataset
We use software products of Mozilla Foundation as study
subjects. We crawl 124,477 bugs from the Mozilla‚Äôs Bugzilla
website (https://bugzilla.mozilla.org/home) which involve sixproducts (Firefox, Firefox Build System, Toolkit, Core, Dev-Tools, WebExtensions) and their 186 components. Although
Mozilla‚Äôs Bugzilla website has thousands of components,many components have very few bugs. We restrict our study to
the components with at least 1% of the number of bugs of the
component with the largest number of bugs. These componentscover very frontend and backend features of Mozilla products.Thanks Bugzilla, we can extract the complete bug assignmenthistory of each bug. The history contains initially assignedcomponent and all subsequent components a bug has been
tossed to in chronological order.
B. RQ1: Bug Tossing Frequency and Impact
Among 124,477 bugs, 30.8% (i.e., 38,374 bugs) has been
tossed. Table I shows the tossed-in bug percentage of a compo-
nent (i.e., the bugs that are currently assigned to a componentbut were not initially assigned to this component). None of
186 components has zero tossed-in bug percentage. That is,all 186 components have some bugs that have been tossed-
in from other components. Toolkit::Blocklist Policy Requestsis the only component whose tossed-in bug percentage isbelow 5% (in particular 18/615 bugs, 2.9%). Tossed-in bugpercentage is 20-40% for 96 components and 40-60% for 39
components. For 12 components, tossed-in bug percentage iseven higher than 60%. For example, out of 258 bugs of FirefoxBuild System::Android Studio and Gradle Integration, 219 are
tossed-in bugs which give tossed-in bug percentage 84.9%. Forthe tossed bugs, the time it takes to close them is on averageabout 2.9 times longer than the non-tossed bugs.
Bug tossing not only occurs frequently but also widely onMozilla product components. In fact, bug tossing statisticsdo not change much in the past 15 years [1], [2], [4].
C. RQ2: Accidental Mistake or Repeated Error
For each tossed bug, we obtain a path from its ini-
tial component to its current component. We identify dis-
1https://github.com/SuYanqi/LR-BKG
TABLE II: Examples of Real Tossing Paths
Product::Component Tossing Path Frequency
Toolkit:: a. Firefox::Security ‚ÜíToolkit::Password Manager 6
Password Manager b. Toolkit::Password Manager:Site Compatibility ‚Üí 6
Toolkit::Password Manager
c. Firefox::about:logins ‚ÜíToolkit::Password Manager 4
Toolkit:: a. Firefox::Untriaged ‚Üí 23
Password Manager: Toolkit::Password Manager ‚Üí
Site Compatibility Toolkit::Password Manager:Site Compatibility
b. Toolkit::Password Manager ‚Üí 10
Toolkit::Password Manager:Site Compatibility
Firefox:: a. Toolkit::Password Manager ‚ÜíFirefox::about:logins 269
about:logins b. Firefox::Untriaged ‚ÜíToolkit::Password Manager ‚Üí 17
Firefox::about:logins
Firefox::Security a. Core::Security:PSM ‚ÜíFirefox::Security 3
b. Core::Networking:DNS ‚ÜíFirefox::Security 3
c. Firefox::Theme ‚ÜíFirefox::Security 2
Core::Security: PSM a. Firefox::Untriaged ‚ÜíCore::Security:PSM 207
b. Firefox::Security ‚ÜíCore::Security:PSM 16
c. Core::Networking ‚ÜíCore::Security:PSM 11
Toolkit::Themes a. Firefox::Theme ‚ÜíToolkit::Themes 18
b. Firefox::Preferences ‚ÜíToolkit::Themes 6
c. Toolkit::XUL Widgets ‚ÜíToolkit::Themes 5
d. Toolkit::Password Manager ‚ÜíToolkit::Themes 3
e. Firefox::Bookmarks & History ‚ÜíFirefox::Theme ‚Üí 2
Toolkit::Themes
Firefox::Theme a. Firefox::General ‚ÜíFirefox::Theme 33
b. Firefox::Bookmarks & History ‚ÜíFirefox::Theme 8
c. Toolkit::Themes ‚ÜíFirefox::Theme 6
tinct tossing paths and count their occurrence frequen-
cies among all tossed bugs. Table II shows some tossingpaths. For example, one tossing path is Firefox::Security ‚Üí
Toolkit::Password Manager, with the frequency 6. That is, 6bugs have been initially assigned to Firefox::Security, and thentossed to Toolkit::Password Manager, and is currently withToolkit::Password Manager. This path is just one of the 60paths along which a bug has been tossed to Toolkit::PasswordManager.
We identify 8,487 tossing paths for 38,374 bugs. Only 932
tossing paths occur once, accounting for 11.0% of all tossingpaths and 2.4% of all tossed bugs. The rest 7,555 tossing paths
have two or more bugs. Fig. 1(a) shows the distribution of
tossing path frequencies. We remove 10 large outliers ( ‚â•307)
to show this distribution more clearly. The median frequency is8, with 3 at 25% quantile and 19 at 75% quantile. 26 tossingpaths occurred even more than 200 times. The Ô¨Årst tossingpath for Firefox::about:logins in Table II is one of these mostfrequent paths, which occurs 269 times. Fig. 1(b) show thedistribution of the number of tossing paths per component,i.e., the number of paths ending with a particular component.The median is 33, with 18 at 25% quantile and 60 at 75%quantile. There are 18 components (e.g. Core::Security:PSM)with 100 or more different tossing paths.
Accidental mistake may account for only a small percent-age of bug tossing, while the majority of bug tossing arecaused by repeated erroneous bug-component assignments,and those repeated errors can occur in many different ways.
D. RQ3: Cause of Repeated Bug Tossing
Through observing repeated bug tossing paths, we Ô¨Ånd that
confusing concepts are an important cause of erroneous bug-component assignments. Confusing concepts come from two(a) Distribution of Tossing Path Frequencies
(b) Distribution of the Number of Tossing Paths per Component
Fig. 1: Distribution of Tossing Paths
sources: complex component designs and relationships, andmisleading component names and bug report keywords.
1) Complex Component Designs and Relationships: A
complex feature often involves a set of correlated components.For example, according to the Mozilla wiki and a meet-ing note, password management involves four components:Toolkit::Password Manager for remembering usernames andpasswords on sites and Ô¨Ålling them when the user returnsto the sites, Firefox::about:logins for issues with the Fire-fox Lockwise Logins and Passwords page, Toolkit::Password
Manager:Site Compatibility for issues of autoÔ¨Åll, autocomplete
or saving of logins/passwords/usernames not working on aspeciÔ¨Åc site, and Firefox::Migration for proÔ¨Åle migration fromother browsers. In total, 353 bugs that were initially assignedto one of these four components were tossed to the otherof these four components. Fig. 3 shows a partial tossinggraph constructed from bug tossing paths. Toolkit::PasswordManager, Firefox::about:logins and Toolkit::Password Man-ager:Site Compatibility actually form a bug tossing community(blue nodes and edges). This bug tossing community largelymatches the component design for password management.
In face of complex correlated components, bug reporters,
especially those without expertise background, often have
difÔ¨Åculties in assigning bugs to the correct components. Forthis problem, Mozilla sets general placeholder componentsfor reporters to report bugs, such as Firefox::General, Fire-fox::Untriaged. Then, developers have to toss them into rightcomponents. Table II shows some examples of tossing pathsstarting from Firefox::Untriaged or Firefox::General. First,this general-then-toss practice incurs signiÔ¨Åcant burden ondevelopers due to the sheer amount of bugs initially reportedto general placeholder components. Second, even developersmay not make right tossing decisions in many cases. 4,251
bugs that have been tossed from general components were
tossed again (e.g. Firefox::Untriaged ‚ÜíToolkit::Password
Manager ‚ÜíToolkit::Password Manager:Site Compatibility,
Firefox::Untriaged ‚ÜíToolkit::Password Manager ‚ÜíFire-
fox::about:logins). Sometimes developers may just randomly
assign a bug to one of correlated components and hope thatother developers who have the expertise will toss the bug tothe right component (Bug 1650593 is such an example).
2) Misleading Names and Keywords: Many components
have confusing names, which make them seem relevant to
some bugs. Such confusing names often confuse bug reportersand developers. For example, three bug reporters assignedbugs to Toolkit::Form AutoÔ¨Åll, but these bugs were tossed
to Toolkit::Password Manager, even though Toolkit::Form
AutoÔ¨Åll and Toolkit::Password Manager have no relation ac-cording to component design. An experienced developer com-mented one of these bugs (Bug 1595114) ‚ÄúThe Form AutoÔ¨Ållcomponent is for address and credit card autoÔ¨Åll, not logins(see the description).‚Äù Moreover, a developer assigned twobugs from Firefox::Untriaged to Toolkit::Form AutoÔ¨Åll. Then,another developer tossed these two bugs to Toolkit::PasswordManager and commented Bug 1596805 ‚Äúplease don‚Äôt movelogin/password bugs to Form AutoÔ¨Åll as it is only aboutaddress and credit card autoÔ¨Åll. Please use Toolkit::PasswordManager.‚Äù The developer who made the mistakes replied ‚ÄúNowI know, but the name of this component is obviously notintuitive.‚Äù Not only was this developer confused, but BugBugcould also make similar mistakes. For example, a comment ofBug 1653547 states ‚ÄúBugbug thinks this bug belongs to FormAutoÔ¨Åll, please revert in case of error‚Äù, and it was indeed anerror and tossed to Toolkit::Password Manager.
In fact, the information provided in the comments about bug
tossing is available in the detailed description of Toolkit::FormAutoÔ¨Åll. Unfortunately, many bug reporters, even developers
in Mozilla, have no knowledge of these detailed componentdescriptions. Similarly, 18 Toolkit::Themes bugs were initiallyassigned to Firefox::Theme. No matter for bug reporters or de-velopers, the two names are confusing. However, the detailedcomponent descriptions tell the differences. Firefox::Themeis responsible for general user interface, user experience, andvisual design for the default theme used in Firefox. Bugs aboutpackaged browser themes and about WebExtensions that usethe ‚Äúthemes‚Äù API should be triaged into Toolkit::Themes.
Bug reports very likely contain misleading information,
which may confuse bug reporters, developers, and auto-matic bug triaging tool BugBug developed by Mozilla. Forexample, Bug 1194529 states ‚ÄúAsk the user for their OSaccount password/biometrics before showing the passwordsin the password manager.‚Äù It contains keywords ‚Äúpassword‚Äù
and ‚Äúpassword manager‚Äù, and was initially assigned to
Toolkit::Password Manager. But this bug is essentially aboutan issue in Logins and Passwords page, and thus was tossedto Firefox::about:logins. For Bug 1584846, the situation is theopposite. Its summary states ‚ÄúSeparate preference setting forAutoÔ¨Åll logins/passwords from Ask to save logins/passwords‚Äù.It mentions ‚Äúlogins‚Äù and ‚Äúpassword‚Äù a couple of times. Thisbug was initially assigned to Firefox::about:logins, but wastossed to Toolkit::Password Manager as it is about passwordautoÔ¨Åll that Toolkit::Password Manager is responsible for.
As bug report summary and description is the most impor-
tant input to machine learning based bug triaging techniques,misleading information in bug reports could also misleadmachine learning techniques. For example, misled by the Bug-Bug‚Äôs recommendation, Bug 1644112 ‚ÄúPassword displayedtoo short with Standard Font 14 in Firefox access data‚Äù wastossed to Core::Graphics:Text. Unfortunately, this was a com-
pletely non-sense assignment. The Bug 1644112 was tossedto Firefox::WebPayments UI, and then Firefox::about:loginsand closed there. This mistake by BugBug is because the Bug1644112‚Äôs summary contains keywords like ‚Äúfont‚Äù, ‚Äúdisplay‚Äù,
‚Äúdata‚Äù that are often in the bug reports correctly assignedto Core::Graphics:Text. However, the key problem of thisbug is about password display that Firefox::about:logins isresponsible for. The initial non-sense assignment challengesthe Core::Graphics:Text developers as they lack experience inhandling bugs like Bug 1644112. As a result, they tossed thebug to Firefox::WebPayments UI which was still incorrect,and it took one day before this bug was tossed to the rightcomponent Firefox::about:logins.
Complex component designs and misleading componentnames and bug report keywords cause a lot of confusionin bug triaging and tossing. Developers often resort toadditional information such as detailed component descrip-tions and component communities to correct erroneous bugassignments. Furthermore, existing bug triaging techniqueslearn from each bug-component assignment independently,which often cannot effectively distinguish misleading infor-mation and key problem information in bug reports.
III. A PPROACH
Inspired by our empirical study Ô¨Åndings, we propose a
novel bug triaging approach with two aims: improve bugtriaging accuracy and avoid tossing-irrelevant bug triaging.As shown in Figure 2, our approach builds on a novel bug
triaging knowledge graph, which enriches basic goal-oriented
component tossing graph with rich information about compo-nent, component community, and correctly and erroneouslyassigned bugs. Instead of only bug-report centric features,we derive a rich set of features from bug tossing knowledgegraph, which represent additional knowledge (i.e., componentdescriptions and component community) commonly used tocorrect erroneous bug assignments, and rich relations betweenan input bug and those correctly or erroneously assignedbugs. In contrast to learning from each bug-component as-signment independently, our approach adopts a learning-to-
rank framework which ranks bug-component relevance by
contrasting correct, erroneous and irrelevant bug assignmentsin the history.
A. Construction of Bug Tossing Knowledge Graph
To make effective use of historical bug tossing information,
we Ô¨Årst construct a bug tossing knowledge graph from which
a rich set of bug and component features can be derived.
1) Goal-Oriented Bug Tossing Graph: Bug tossing rela-
tionships among components provide useful information forlearning the relevance of a bug to its resolver component asopposed to all other bystander components that the bug hasbeen erroneously assigned to. These relationships are capturedin real bug tossing paths (see Table II for some examples).We convert real tossing paths into goal-oriented tossing paths.The conversion is straightforward. For each component (exceptthe resolver component) in a real tossing path, we create agoal-oriented tossing path from this component to the resolvercomponent. Consider the real tossing path Firefox::Bookmarks
BugzillaHistorical 
BugsBug Tossing Knowledge Graph
Component 
Description
Corrected/Erroneous 
Bug AssignmentBug Tossing 
CommunitiesGoal-Oriented Basic Bug Tossing GraphBug Features
Component 
Features
Bug-Component 
Features
Learning To RankRelevance 
LabelProduct::
Component 
Feature 
Vector
Product::Component 
Ranking ListTrained Model
Future BugTrainingTraining phrase
Inference phrase
Predicting
Fig. 2: Approach Overview
Fig. 3: Goal-Oriented Bug Tossing Knowledge Graph
& History ‚ÜíFirefox::Theme ‚ÜíToolkit::Themes in Table II.
From this real tossing path, we create two goal-oriented tossing
paths: Firefox::Bookmarks & History ‚ÜíToolkit::Themes and
Firefox::Theme ‚ÜíToolkit::Themes. After processing all real
tossing paths, we identify distinct goal-oriented tossing paths
and count their occurrence frequencies
Goal-oriented tossing paths can avoid the two limitations
of real tossing paths. First, real tossing paths capture onlywhat have occurred in the past, but they will not cover all
possible tossing paths. For example, the presence of the tossing
path Firefox::Bookmarks & History ‚ÜíFirefox::Theme ‚Üí
Toolkit::Themes indicates that Firefox::Bookmarks & History‚ÜíToolkit::Themes is possible to occur. In fact, after 2.5 years
that Firefox::Bookmarks & History ‚ÜíFirefox::Theme ‚Üí
Toolkit::Themes occurred for Bug 1468080 and Bug 1476790,Firefox::Bookmarks & History ‚ÜíToolkit::Themes occurred
for Bug 1671000. However, before Bug 1671000 appeared,Firefox::Bookmarks & History ‚ÜíToolkit::Themes is not a
real tossing path for 2.5 years.
Second, the bystander components (e.g., Firefox::Theme
in the above path) may be somehow relevant to the tossedbug, but they are deÔ¨Ånitely not as relevant as the resolvercomponent (e.g., Toolkit::Themes in the above path). Evenworse, in many cases bystander components may not berelevant at all to the tossed bug. For example, in the tossingpath Core::Graphics:Text ‚ÜíFirefox::WebPayments UI ‚Üí
Firefox::about:logins for Bug 1644112, Firefox::WebPaymentsUI is irrelevant as the Core::Graphics:Text developers didnot know where is appropriate to toss Bug 1644112 either.
Learning from such tossing mistakes would not be beneÔ¨Åcial.
Given all goal-oriented tossing paths obtained, we construct
a goal-oriented bug tossing graph. The graph nodes are com-ponents. The edges are directed and represent goal-orientedtossing paths from one component to another. Fig. 3 shows asubgraph of the goal-oriented bug tossing graph constructedin our empirical study on Mozilla product::components. Thenodes of Toolkit::Password Manager and its direct neigh-bors are highlighted. From the faded background, we canobserve rather complex tossing relationships among Mozillaproduct::components. For each component node, the graphrecords two metrics: the number of bugs currently assigned
(including initially assigned and tossed from other compo-nents) to this component (e.g., 594 for Toolkit::PasswordManager); the number of bugs tossed from this component toother components (e.g., 277 for Toolkit::Password Manager).
For each edge, the graph records one metric: the occurrence
frequencies of the tossing between two components (e.g., 240from Toolkit::Password Manager to Firefox::about:logins).
2) Bug Tossing Community Detection: Frequent tossing
relationships among components will form some bug tossingcommunities in the bug tossing graph. In this work, we use
the community detection algorithm [8] to detect bug tossingcommunities in the bug tossing graph. This algorithm is basedon modularity optimization. We use the implementation in the
Gephi tool. For community detection, we Ô¨Ålter out edges withfrequency=1 as we deem them as likely accidental.
In the tossing graph used in our empirical study, the algo-
rithm detects 18 communities covering 186 components. The
community size is 10.3¬±16.2. In Fig. 3, nodes and edges with
the same color belong to one community detected by the algo-
rithm. Red and green communities are two large communitieswhich involve 48 and 46 components, respectively. As wehighlight nodes centered around Toolkit::Password Manager,many components in the red and green communities are notincluded or faded in the background (e.g., Firefox::Theme andWebExtensions::Themes at top-left corner).
The blue community in Fig. 3 is one of the small com-
munities, which includes Toolkit::Password Manager, Fire-
fox::about:logins, Toolkit::Password Manager:Site Compati-
bility and Toolkit::Form AutoÔ¨Åll. This tossing community isthe result of complex component design and misleading com-ponent name. The Ô¨Årst three components are all related to pass-word management (see Mozilla wiki and meeting note). Thefourth password management component Firefox::Migrationdoes not appear in this community because it did not havetossing paths from or to these components. Toolkit::FormAutoÔ¨Åll is not part of password management. It is in thecommunity because Ô¨Åve bugs were erroneously assigned toToolkit::Form AutoÔ¨Åll due to misleading component name, butthese bugs were Ô¨Ånally tossed to Toolkit::Password Manager.
3) Information Enrichment: Existing bug triaging tech-
niques [1], [2] treat components just as class labels and learnfrom only correctly assigned bug reports. However, in the bugtossing comments, additional information, such as componentdescriptions and the contrast of correctly and erroneously
assigned bugs, often provides the basis and justiÔ¨Åcation for bug
tossing decisions. Therefore, we enrich each component in thebug tossing graph with two types of information: componentdescription, and two sets of bugs (closed bugs versus tossed-
TABLE III: Three Categories of Features
Feature Dimension
Bug Feature
a. number of bug summary tokens 1
Component Features
a. bug tossing community index 1
b. number of closed bugs 1
c. number of tossed-out bugs 1
d. in-degree (unweighted & weighted) 2
e. out-degree (unweighted & weighted) 2
f. degree (unweighted & weighted) 2
Bug-Component Relation Features
a. sim(bug summary, component name) 2
b. sim(bug summary, component description) 2
c. Top30 sim(bug summary, closed bug summary) 60
d. Top30 sim(bug summary, tossed-out bug summary) 60
e. Percentage(nonzero(sim(bug summary, closed bug summary))) 2f. Percentage(nonzero(sim(bug summary, tossed-out bug summary))) 2
out bugs). This allows us to model and differentiate confusing
bug and component information more effectively.
Component description: Unlike class label which is just
a component index, component names reveal the identity ofcomponents (e.g., key functionality or concept) in a conciseform. As component names are sometimes misleading, wealso attach component descriptions which provide more detailsabout the components. Sometimes a component name maycontain acronyms, and the full names can generally be foundin the component description. In such cases, we keep theoriginal acronym and also expand the acronym into the fullname, for example Gecko Media Plugin for GMP. For acronymexpansion, we Ô¨Årst split the component name into tokens andidentify acronyms (i.e., tokens with all capital letters likeGMP). Then, we match the letters in an acronym with theword initials in the component description by the same order(i.e., G‚ÜíM‚ÜíP). If the concatenated initials of a sequence of
words match the acronym, this sequence of words is regardedas the full name of the acronym.
Closed and tossed-out bugs: In this work, we assume if
a bug is assigned to a component and closed there, this bugassignment is correct. Otherwise, if the bug is tossed to another
component, the bug assignment is erroneous. As shown in
Fig. 3, components generally have both closed bugs andtossed-out bugs. Some components (e.g., Toolkit::PasswordManager, Toolkit::Themes, Firefox::Security) have high ratiosbetween tossed-out bugs and closed bugs. By contrasting aninput bug with closed bugs and tossed-out bugs, the model
would learn not only how to make correct bug assignmentsbut also how to not make erroneous assignments.
B. Feature Design
In addition to the bug report feature, our bug tossing
knowledge graph allows us to extract a rich set of features
about components and bug-component relationships.
1) Text Preprocessing: Our approach takes as input the
summary of a bug report. We assume the minimal rep-resentation of bug reports so that the approach can havegood generalizability. In addition, we also need to processcomponent names, component descriptions and the summariesof historical bug reports attached to the components. Weprocess these texts as follows. First, we use camel case tosplit words, and convert all words to lowercase. For example,masterPassword is transformed into two lowercase words‚Äúmaster‚Äù and ‚Äúpassword‚Äù. Bug report summaries are shortsentences. But component descriptions may be a paragraphof text. We split a paragraph into sentences by punctuations.We perform tokenization and stemming using the NLTK tool.
We encode text in two types of word representations:
TF/IDF (Term Frequency/Inverse Document Frequency) andword embedding. TF/IDF is a high-dimensional one-hot vec-tor which can cover all words in a text corpus. For IDFcomputation, we consider the summaries of all bugs attachedto a component as a document. Word embeddings are low-
dimensional dense vectors. It requires to deÔ¨Åne a Ô¨Åxed vocab-ulary size. Bug reports often contain domain-speciÔ¨Åc terms
or acronyms, which are generally out of the word embeddingvocabulary. Rather than regarding these domain-speciÔ¨Åc termsand acronyms as out-of-vocabulary tokens, which may affectthe embedding quality, we use FastText that computes word
embeddings at subword level. We multiply the learned wordembeddings with IDF as a weight factor.
2) Input Bug Feature: Exist techniques [2], [6] directly use
the words in bug report summary as input features. We do not
do so because the text often contains misleading keywordsthat are hard to distinguish from key problem information bylooking at the text alone. In our approach, we take only asimple feature of input bug, i.e., the number of tokens in thebug report summary. This feature is indicative of the amountof information in the bug report summary. We make full use ofthe information in the bug report summary as bug-componentrelation features detailed in Section III-B4.
3) Component Features: Exist techniques [2], [6] simply
treat components as class labels. In contrast, we make gooduse of rich information that the components have, includingthree types of nine features as listed in Table III.
Component community: the index of the bug tossing
community that a component belongs to. This feature informs
the model whether the two components compared during learnto rank come from the same community. The same communityindicates that the two components have a track record of being
confusing. However, assigning a bug to bystander componentsin the same community as the resolver component is still better
than assigning the bug to the components in other communi-ties. Take Bug 1644112 as an example. If it cannot be assignedto Firefox::about:logins, it would be better to assign it to
Toolkit::Password Manager, rather than Core::Graphics:Text,as developers of components in the same community likelyknow where to toss, but developers may not have expertise to
make the right tossing across the communities.
The number of closed and tossed-out bugs: These two
features help to judge the probability of a component being
the resolver or bystander of a bug and the probability ofmaking mistakes. In Fig 3, we see that Toolkit::Password
Manager has 594 closed bugs and 277 tossed-out bugs. Fire-fox::about:logins has 304 closed bugs and only 10 tossed-
out bugs. Comparing these two components, Toolkit::PasswordManager is the resolver of much more bugs, but assigning abug to Toolkit::Password Manager has higher error probability
than assigning it to Firefox::about:logins.
unweighted and weighted (in/out)-degree: These six fea-
tures represent how many toss-in and toss-out relationships
a component has with its direct neighbors. In-degree corre-sponds to toss-in, out-degree corresponds toss-out, and degreeregards the edge as indirected. Unweighted metric counts thenumber of edges. Weighted metric measures how strong therelationship is, i.e., the sum of the frequencies on the edges. InFig 3, the in-degree of Toolkit::Password Manager is 8, and theweighted in-degree is 30. The out-degree of Toolkit::PasswordManager is 6 and the weighted out-degree is 267. The degreeand weighted degree are 14 and 297 respectively.
4) Bug-Component Relation Features: Exist techniques [2],
[6] infer implicit bug-component relations through the classi-
Ô¨Åer. In contrast, we explicitly model bug-component relationsin terms of the similarities between the input bug summaryand the information (component description, closed bugs andtossed-out bugs) of components, as three types of six features.These text similarity features contrast the input bug summarywith component information, rather than directly using bugsummary text as features. The similarity is computed basedon TF/IDF vectors and word embeddings. TF/IDF reÔ¨Çectswhether the bug summary and the component informationhave some keywords in common, while word embeddingsmeasure syntactic and semantic text similarity in a more fuzzymanner. We compute the cosine similarity between the twovectors, and use both TF/IDF-based and word-embedding-based similarities to achieve complementary effects.
Similarity between input bug summary and component
name/description: These four features (two for TF/IDF and
two for word embedding) allow the model to take into ac-count rich semantic in component names and descriptions and
semantic relations between bugs and components.
Top 30 similarities between the input bug and closed
bugs: This input-closed feature is a 60-dimensional vector
(30 for TF/IDF and 30 for word embedding). Each dimen-
sion is a similarity between the input bug summary and
the summary of one closed bug of the component. Thecomponent may have more than 30 closed bugs. We rankthe similarities and take top 30. The input-closed featureinforms the model how the input bug is similar to up to30 closed bugs of the components. Furthermore, they re-Ô¨Çect the distribution of the similarities. Consider the Bug1644807 initially assigned to Firefox::Preferences and thentossed to Toolkit::Password Manager. The top 5 input-closedsimilarities with Toolkit::Password Manager is {0.803, 0.798,
0.794, 0.789, 0.783}, while the top 5 input-closed similari-
ties with Firefox::Preferences is {0.791, 0.761, 0.739, 0.693,
0.678}. We see that the Bug 1644807 is consistently similar
to the closed bugs of Toolkit::Password Manager. In con-trast, this bug is only very similar to two closed bugs ofFirefox::Preferences, but not the rest of closed bugs. Thisdistribution comparison during learning to rank would helpthe model make the right choice.
Top 30 similarities between the input bug and tossed-out
bugs: This input-tossedout feature contains top 30 similarities(TF/IDF and word embedding respectively) between the inputbug and the top-30 most similar tossed-out bugs of thecomponent. The input-tossedout feature, as opposed to theinput-closed feature, allows the model to see how the inputbug looks like past mistakes. For example, the top 5 input-closed similarities for the Bug 1618597 and the componentFirefox::about:logins is {0.826, 0.819, 0.812, 0.808, 0.808 },
which make us feel Firefox::about:logins could be the resolver.However, when looking at the top 5 input-tossedout similari-ties{0.773, 0.737, 0.633, 0.584, 0.584} for the Bug 1618597
and Firefox::about:logins, we may realize that this assignmentcould be risky as the bug is very similar to some tossed-outbugs of Firefox::about:logins.
Percentage of nonzero input-closed or input-tossedout
similarities: The nonzero-input-closed (or nonzero-input-
tossedout) feature computes the percentage of all closed (ortossed-out) bugs of a component that have nonzero similaritieswith the input bug. For the component with less than 30closed (or tossed-out) bugs, many dimensions of input-closed
(or input-tossedout) will be zero, which makes this feature less
effective or even misleading. These two features would informthe model these zero-value dimensions may be useless.
C. Learning to Rank Framework
Considering complex and confusing relations between bugs
and components, our approach does not learn from each bug-
component assignment independently. Instead, our approachadopts a learning-to-rank framework that learns from more rel-
evant assignments against less relevant assignments pairwisely.In particular, we adopt LambdaMart [9] to rank componentsfor an input bug.
Learning to rank is a supervised machine learning algorithm.
Therefore, preparing meaningful training data is important.
Our learning goal is to assign an input bug to the resolvercomponent or at least to some bystander components havingtossing relationships with the resolver component. Based on
this goal, we construct the training data from bug triaging
and tossing history as follows. Let bbe a bug and C
fbe
its resolver. Without losing generality, let C1‚ÜíC2‚ÜíCf
be a real tossing path. A correct initial assignment withouttossing can be regarded as a tossing path with length 0. Webuild a data point for each component on the tossing path.The bug-component relevance is computed as
1
2d(Cx,Cf)where
d(Cx,Cf)is the distance from CxtoCfalong the path. In
this example, d(C1,Cf)=2,d(C2,Cf)=1 and d(Cf,Cf)=0,
and thus the relevance labels for b-C x(x=1,2,f) are 0.25, 0.5
and 1. For all other components Conot on the tossing path,
we create a data point for each of them with relevance label 0,
i.e.,b-C o=0. We construct data points using real tossing paths
rather than goal-oriented tossing paths because real tossing
paths produce more data points and more Ô¨Åne-grained bug-component relevance labels. For example, for another bug b
/prime
with real tossing path C1‚ÜíCf, the relevance label for b/prime-C1
is 0.5. By goal-oriented tossing path C1‚ÜíCf, we will have
only one data point with relevance label 0.5 for the two bugs.
For each data point b-C, we associate it with the three
categories of features described in Section III-B. At training
time, LambdaMart optimizes the gradient of objective functionthrough gradient boosting [9] which can be modeled bythe sorted positions of the components for an input bug b
against the ground-truth relevance labels. At inference time,
give an unseen bug, the trained model is used to produce a
relevance label for each component to be predicted based on
the features between the bug and the component, and thenrank the components by the predicted relevance labels.
IV . E
V ALUATION
This section reports the evaluation of our LR-BKG to
answer the following research questions:
RQ1: Can LR-BKG improve resolver component recom-
mendation over traditional bug triaging methods?
RQ2: Can LR-BKG improve tossing-relevant component
(resolver and bystander) recommendation over tradi-tional bug triaging methods?
RQ3: What features are the most important for the perfor-
mance of our approach?
A. Experimental Setup
1) Dataset: We crawl 124,477 bugs of six Mozilla products
and their 186 components. To ensure the validity of correctbug-component assignments, we retain only bugs whose statusis resolved, veriÔ¨Åed or closed. According to Mozilla‚Äôs bugstatus guide, bugs with these statuses are closed Bugs. Weassume that the component of a closed bug is the bug‚Äôsresolver. For bugs with other statuses, it is still uncertainwhich components would be their resolvers. After Ô¨Åltering byclosed bugs, we obtain 98,587 closed bugs covering 6 productsand 186 components. 29,100 out of these 98,587 closed bugsare tossed bugs. We split the dataset into training data andtesting data. In order to simulate real-world context, we cutdataset into 80% and 20% in chronological order. 78,870 bugs(including 24,039 tossed bugs) with creation time before 25thFebruary, 2020 are ‚Äúhistorical‚Äù training data. The rest 19,717bugs (including 5,061 tossed bugs) are ‚Äúfuture‚Äù testing data.
2) Baseline: We compare our approach with two baselines.
This Ô¨Årst baseline is the BugBug tool (in particular its compo-nent classiÔ¨Åer for assigning bugs to product::component) [6].The BugBug tool has been actively used in the Mozilla‚Äôsproduct development. It formulates bug triaging as a multi-class classiÔ¨Åcation task, and uses the logistic regression model
built in XGBoost. XGBoost is an optimized distributed gra-
dient boosting library, which implements machine learningalgorithms under gradient boosting framework [10]. BugBugtakes the one-hot representation of bug summary, descriptionand keywords/Ô¨Çags as features. We train BugBug using our
historical bug dataset.
The second baseline is BugBug with tossing graph
(BugBug-TG). This baseline is inspired by Jeong et al. [7]which uses bug tossing graph to improve the initial rec-ommendation lists by any bug triaging classiÔ¨Åers. LetTABLE IV: Top-k Accuracy
Tool Category Top-1 Top-3 Top-5 Top-10
Our Tossed 0.469 0.701 0.772 0.848
Approach Non-Tossed 0.593 0.779 0.836 0.892
Overall 0.562 0.759 0.820 0.881
BugBug Tossed 0.378 0.608 0.680 0.760
Non-Tossed 0.468 0.642 0.697 0.764
Overall 0.445 0.633 0.692 0.763
BugBug Tossed 0.378 0.610 0.680 0.760
with TG Non-Tossed 0.468 0.644 0.698 0.765
Overall 0.445 0.635 0.694 0.764
TABLE V: Component-Level Top-k Accuracy Comparison
Top-1 Top-3 Top-5 Top-10
#P::C (our<BugBug) 22 13 7 5 28 (any <)
#P::C (our=BugBug) 28 22 24 22
#P::C (our>BugBug) 136 151 155 159 120 (all >)
{C1,C2, ..., C n}be the initial recommendation list. BugBug-
TG starts from the top, and inserts the most possible tossing
target Cxtof each component Cxbased on the historical
tossing probability in the bug tossing graph. The resulting listlooks like {C
1,C1t,C2,C2t, ..., C n,Cnt}. Finally, BugBug-
TG returns the top N elements in the resulting list.
3) Evaluation Metrics: For RQ1, we evaluate if a method
can recommend the resolver component for a bug. As there isonly one resolver component for a bug, we use Top-k accuracy(also known as Hit@k accuracy) to evaluate the performance
of resolver component recommendation. Top-k accuracy is/summationtext
bi‚ààBisCorrect(b i,Top-k) /|B|where Brepresents the set
of all test bugs and the isCorrect(b i,Top-k) returns 1 if Top-k
components contain the resolver component of the input bug
bi, and returns 0 otherwise.
For RQ2, we want to recommend not only the resolver
component but also bystander components. We consider twotypes of bystanders: the components in the same tossing com-munity as the resolver component, and the components having
direct edges to the resolver component in the goal-orientedbug tossing graph. In addition to Top-k accuracy, we compute
NDCG@k in RQ2. NDCG @kisDCG @k/IDCG @k, and
DCG @kis/summationtext
k
i=1ri/log2(i+1 ) where ri= 1 if the i-th
component in the recommendation list is related (resolver or
bystander) to the input bug, and ri= 0 otherwise. IDCG is
the ideal result of DCG, which means all related componentsare ranked higher than unrelated ones.
For RQ3, we use feature importance analysis provided in
XGBoost [10] to validate the effectiveness of our featuredesign. Feature importance analysis plots importance based onÔ¨Åtted trees. The importance is calculated by importance types,
either ‚Äúweight‚Äù, ‚Äúgain‚Äù, or ‚Äúcover‚Äù. ‚Äúweight‚Äù is the number of
times a feature appears in a tree. ‚Äúgain‚Äù is the average gain ofsplits which use the feature. ‚Äúcover‚Äù is the average coverageof splits which use the feature and the coverage is deÔ¨Åned asthe number of samples affected by the split. The importance
type we use in this study is ‚Äúweight‚Äù.
B. Resolver Component Recommendation (RQ1)
Table IV shows the results. We can see that BugBug and
BugBug-TG have almost the same accuracies at all Top-ks.
This means that BugBug-TG‚Äôs simple heuristic use of com-
ponent tossing relationships is not effective. In contrast, ourLR-BKG achieves signiÔ¨Åcant higher accuracies than BugBugand BugBug-TG at all Top-ks. At Top-1, LR-BKG achievesoverall 0.562 accuracy, 0.469 for tossed bugs and 0.593 fornon-tossed bugs, while BugBug achieves only 0.445 overall,0.378 for tossed bugs and 0.468 for non-tossed bugs. At Top-10, LR-BKG achieves overall 0.88 accuracy, while BugBug isonly 0.76. Although our initial goal focuses on tossed bugs,our LR-BKG actually achieves the same-level improvementfor both tossed and non-tossed bugs.
Consider a tossed bug Bug 1644807 which was initially as-
signed to Firefox::Preferences and tossed to Toolkit::Password
Manager. BugBug recommends Firefox::Preferences at the top1 position. The summary of Bug 1644807 states ‚ÄúReplaceall user-facing instances that refer to master password‚Äù. Thekeywords such as user, replace, master password are highlyrelated to Firefox::Preferences and its historical bugs. Thesekeywords taken directly as features in BugBug confuse theclassiÔ¨Åer. In contrast, our LR-BKG correctly recommends theresolver component Toolkit::Password Manager at top 1.
Consider a non-tossed bug Bug 1618597 whose re-
solver component is Toolkit::Password Manager. However,BugBug recommends Firefox::about:logins at top 1 whichcould mislead the developers. Our LR-BKG recommendsToolkit::Password Manager at top 1. As seen in Fig. 3,Toolkit::Password Manager and Firefox::about:logins are veryconfusing components which have many erroneous assign-ments and tossing in between. The summary of Bug 1618597is ‚ÄúSaved logins and Master Password are cleared when
upgrade from Firefox56 to Firefox74.0beta via Firefox73.0.1‚Äùwhich includes many confusing keywords such as saved, lo-
gins and master password. These keywords are rather commonin the closed bugs of both Toolkit::Password Manager andFirefox::about:logins. However, our approach can effectivelydistinguish key problem information (e.g., cleared, upgrade)
from these common confusing information, and consequently
make the right recommendation.
We compute the Top-k accuracy for each component by LR-
BKG and BugBug. We count for how many components LR-BKG achieves higher, equal or lower accuracies than BugBug.We consider the accuracy difference below 0.03 as equal.Table V presents the results. The last column means if LR-BKG is lower than BugBug at any Top-k, we count it as LR-BKG< BugBug. Only if LR-BKG is higher than BugBug at
all Top-ks, we count it as LR-BKG> BugBug.
At different Top-ks, LR-BKG achieves higher accura-
cies than BugBug for 73%-85% of 186 components, andachieves the same accuracies as BugBug for 12%-15% ofcomponents, and achieves lower accuracies for only 3%-12% of components. With the strictest comparison, LR-BKG is better than BugBug for 120 (65%) components(all> ), and is worse than BugBug for only 28 (15%) compo-
nents (any< ). Consider Core::Networking:Cookies that has 30
tossed bugs. BugBug makes 13 correct recommendation at top1 and 18 in top 10. The erroneous recommendations includenot only confusing components (e.g, Core::Security:PSM,Core::Networking:HTTP) but also some non-sense compo-nents (e.g., DevTools::Console). LR-BKG recommends correctresolver components for 18 tossed bugs at top 1 and for 24tossed bugs in top 10.
We Ô¨Ånd that LR-BKG sometimes makes mistakes for re-
solver components in bug tossing communities. For example,Firefox::Sync belongs to the community that includes 48components (the red community in Fig. 3). Firefox::Synchas 140 bugs, among which LR-BKG assigns 52 bugs toother components in the community, such as Firefox::TabbedBrowser, Firefox::Preferences. This results in its low Top-1accuracy 0.443 which is lower than BugBug (0.543). However,LR-BKG does not rank resolver components totally off thetrack. For the Top-3, Top-5 and Top-10 accuracies, LR-BKGis 0.764, 0.836 and 0.900 respectively, while BugBug is only0.707, 0.743 and 0.771. That is, LR-BKG still identiÔ¨Åes theresolver component, but it has some difÔ¨Åculties in distinguish-ing the resolver components from some bystander componentsin the large community at the top-1 position.
Our LR-BKG signiÔ¨Åcantly improves the accuracy of resolvercomponent recommendation. The improvement comes fromboth tossed and non-tossed bugs equally, and is contributedby the improvement on the majority of components.
C. Tossing-Relevant Component Recommendation (RQ2)
Table VIa to Table VId show the results. Comparing the
results in Table IV, Table VIa and Table VIc, we see that all
approaches can recommend some bystander components. For
example, the overall Top-1 accuracy for resolver componentby LR-BKG is 0.562 (Table IV). If we consider the bystandercomponents from the same bug tossing community as correctrecommendation, the overall Top-1 accuracy by LR-BKGbecomes 0.799 (Table VIa). Furthermore, many bystandercomponents can be ranked in top 10 which gives >0.9Top-10
accuracies for all three methods.
As Top-k increases, the accuracy gap between our ap-
proach and BugBug narrows. However, the accuracy at Top-
1 by our approach is much higher than that of BugBugfor both bug tossing community and direct edge settings.For example, Bug 1644112 happens to be in our ‚Äúfuture‚Äùtesting data. BugBug recommends Core::Graphics:Text at top
1 for this bug. Although our approach does not recom-
mend Firefox::about:logins at top 1 either, it recommendsToolkit::Password Manager from the same bug tossing com-munity at top 1. The developers of Toolkit::Password Managermore likely know where to toss Bug 1644112 than the devel-
opers of Core::Graphics:Text.
Comparing NDCG@k of different approaches, we see that
our approach can better rank tossing-relevant componentsat the top of the list. Consider the bug tossing communitysetting. Our approach and BugBug have very close Top-10 accuracy (less than 0.02 difference), but our approachachieves NDCG@10=0.590 while BugBug‚Äôs NDCG@10 isonly 0.432. Similar to resolver component recommendation,
(a) Top-k Accuracy (Bug Tossing Community)
Tool Category Top-1 Top-3 Top-5 Top-10
Our Tossed 0.798 0.917 0.954 0.981
Approach Non-Tossed 0.799 0.919 0.951 0.976
Overall 0.799 0.919 0.952 0.977
BugBug Tossed 0.600 0.865 0.920 0.966
Non-Tossed 0.615 0.782 0.863 0.931
Overall 0.612 0.803 0.878 0.940
BugBug Tossed 0.600 0.860 0.917 0.965
with TG Non-Tossed 0.615 0.780 0.861 0.930
Overall 0.612 0.801 0.876 0.939
(b) NDCG@k (Bug Tossing Community)
Tool Category ndcg@1 ndcg@3 ndcg@5 ndcg@10
Our Tossed 0.798 0.712 0.665 0.590
Approach Non-Tossed 0.799 0.684 0.630 0.563
Overall 0.799 0.691 0.639 0.570
BugBug Tossed 0.600 0.534 0.491 0.432
Non-Tossed 0.615 0.485 0.438 0.385
Overall 0.612 0.497 0.451 0.397
BugBug Tossed 0.600 0.537 0.491 0.431
with TG Non-Tossed 0.615 0.494 0.445 0.390
Overall 0.612 0.505 0.457 0.401
(c) Top-k Accuracy (Direct Edge)
Tool Category Top-1 Top-3 Top-5 Top-10
Our Tossed 0.699 0.887 0.935 0.974
Approach Non-Tossed 0.761 0.902 0.939 0.969
Overall 0.745 0.898 0.938 0.970
BugBug Tossed 0.549 0.818 0.891 0.952
Non-Tossed 0.592 0.765 0.845 0.920
Overall 0.581 0.778 0.856 0.928
BugBug Tossed 0.549 0.816 0.886 0.950
with TG Non-Tossed 0.592 0.764 0.843 0.919
Overall 0.581 0.777 0.854 0.927
(d) NDCG@k (Direct Edge)
Tool Category ndcg@1 ndcg@3 ndcg@5 ndcg@10
Our Tossed 0.699 0.599 0.547 0.497
Approach Non-Tossed 0.761 0.630 0.574 0.521
Overall 0.745 0.622 0.567 0.515
BugBug Tossed 0.549 0.466 0.430 0.400
Non-Tossed 0.592 0.455 0.409 0.385
Overall 0.581 0.458 0.414 0.389
BugBug Tossed 0.549 0.470 0.431 0.400
with TG Non-Tossed 0.592 0.464 0.416 0.390
Overall 0.581 0.465 0.420 0.393
TABLE VI: Results of RQ2
BugBug and BugBug-TG have almost the same accuracies
and NDCG metrics, which means simple heuristic use ofcomponent tossing relationships is not effective for improvingbystander component recommendation.
Our LR-BKG can signiÔ¨Åcantly improve the ranking of by-stander components that have historical tossing relationshipswith the resolver component.
D. Feature Importance (RQ3)
We estimate the importance of 138 features (see Table VII)
by feature importance analysis [10], which assigns importantscores to input features based on how useful they are atpredicting a target variable. Table VII presents the top 30 im-TABLE VII: Top-30 Important Features
Feature Ranking
Bug Feature
a. number of bug summary tokens 7
Component Features
a. number of closed bugs 8
b. weighted in-degree 9
c. bug tossing community index 18
d. unweighted in-degree 23
e. unweighted degree 27
f. unweighted out-degree 30
Bug-Component Relation Features
a. TFIDF sim(bug summary, component name) 21
b. TFIDF sim(bug summary, component description) 14
c. FASTTEXT sim(bug summary, component name) 12d. FASTTEXT sim(bug summary, 16
component description)
e. TFIDF Top 1-7, 10, 8 sim(bug summary, 1, 5, 10, 11, 13,
closed bug summary) 17, 19, 22, 26
f. TFIDF Percentage(nonzero(sim(bug summary, 2
closed bug summary)))
g. TFIDF Top 1-4 sim(bug summary, 4, 15, 20, 28
tossed-out bug summary)))
h. TFIDF Percentage(nonzero(sim(bug summary, 24
tossed-out bug summary)))
i. FASTTEXT Top 1 sim(bug summary, 6
closed bug summary)
j. FASTTEXT Top 1, 2, 4 sim(bug summary, 3, 25, 29
tossed-out bug summary)))
portant features, which include one bug feature, six component
features and 23 bug-component relation features.
The number of bug summary tokens is the only bug feature
we use. This simple feature is ranked at the 7th importance.Six out of nine component features are important. The numberof closed bugs is ranked at the 8th position. Bug tossingcommunity index is ranked at 18th. Weighted in-degree andthree unweighted degree features are important, ranked atthe 9th, 23rd, 27th and 30th positions. For bug-componentrelation features, both TF/IDF-based and word-embedding-based similarities between input bug summary and componentname/description are important. TF/IDF similarities are moreimportant than word-embedding similarities for measuring therelevance of the input bug to the closed bugs of the com-ponents. TF/IDF and word-embedding similarities are equallyimportant for measuring the relevance of the input bug to thetossed-out bugs of the components. We see that the modelmainly focused on the top-ranked similarities. It considersmore top-ranked input-closed similarities (up to top 10) thaninput-tossedout similarities (up to top 4). Non-zero similaritypercentage features are important to inform the model theusefulness of input-closed and input-tossed-out feature vectors.
All categories of features play important role, which demon-strates the effectiveness of our feature design. Input-closedand input-tossedout features could be simpliÔ¨Åed.
V. R ELATED WORK
Machine learning techniques have been widely adopted
to support bug report management [3], including bug Ô¨Åeldprediction, bug Ô¨Åeld reassignment, bug localization, duplicatebug detection, bug-commit linking, etc. The close work toours is bug Ô¨Åeld prediction. Anvik et al. [5] propose touse the classiÔ¨Åer (e.g., Support Vector Machine) to assist
bug Ô¨Åxer assignment. Other studies focus on predicting bug
severity [11]‚Äì[14] and bug priority [15], [16]. Several stud-ies [1], [2] investigate component assignments. Somasundaramet al. [1] mine the topic model from the component‚Äôs historicalbugs for measuring bug component relevance. Sureka [2] usesa TF/IDF classiÔ¨Åer and a dynamic language model classiÔ¨Åerto predict the component of a bug report. The classiÔ¨Åcation-based method has been adopted in practice, e.g., the Mozilla‚ÄôsBugBug tool. Recently, deep-learning based classiÔ¨Åcation hasalso been used for supporting incident triage for online servicesystems [17]. Different from these classiÔ¨Åcation-based meth-ods, our approach is based on learning-to-rank, which learnsnot only from correct bug-component assignments but alsoerroneous and irrelevant assignments.
Jeong et al. [7] model developer tossing relationships in
a probability graph which helps to uncover team structures
and recommend bug Ô¨Åxers. Our work is different in that weconstruct a bug tossing graph among components and learnfrom historical component tossing relationships to reduce bug-component assignment confusion. Our baseline BugBug-TGis inspired by the way that Jeong et al. [7] use the developertossing graph for improving developer recommendation, butBugBug-TG is based on our component tossing graph. Ourresults show that the simple heuristic use of component tossingrelationships is not effective for improving bug componentassignment. Bhattacharya et al. [18], [19] extend Jeong et al.
[7] by incremental learning for effective use of each training
data point. Hu et al. [20] analyze historical bug-componentand component-Ô¨Åxer relations to assist Ô¨Åxer recommendation.However, none of these works effectively use erroneous andirrelevant assignments during learning.
Xia et al. [4] report an empirical study on bug Ô¨Åeld reas-
signment and they Ô¨Ånd that Ô¨Åxer and component reassignmentsoccur most frequently. Their follow-up work [21] trains multi-label classiÔ¨Åers to predict the possibility of Ô¨Åeld reassignment.Similar approaches have been adopted in [22]‚Äì[24]. However,these works do not predict which speciÔ¨Åc components shouldbe reassigned to. Tian et al. [25] and Han et al. [26] address theproblem of developer reassignment. They also use learning-to-rank, but their feature design is developer-centric. In contrast,our feature design is component-centric, with several explicitfeatures for component tossing community and tossed-outbugs. We also explicitly model and contrast the similaritydistributions between the input bug and the closed/tossed-outbugs of the components. These features are inspired by our em-pirical observation on additional information and mechanismsdevelopers often resort to for justifying bug tossing decisions.
VI. C
ONCLUSIONS AND FUTURE WORK
This paper presents an empirical study on bug tossing
phenomena and root cause, and a learning to rank frameworkto address the limitations of classiÔ¨Åcation-based bug com-ponent assignment revealed in our empirical study. Differentfrom classiÔ¨Åcation-based methods that learn from each bug-component assignment independently, learning-to-rank learnsby contrasting correct, erroneous and irrelevant assignments.Inspired by additional information developers often resort tofor correcting erroneous bug assignments, we construct a bugtossing knowledge graph from which rich bug, component andbug-component relation features can be derived and used toinform the learning-to-rank model. Our large-scale evaluationconÔ¨Årms the effectiveness of our learning-to-rank approachand feature design. In the future, we will enrich our bugtossing knowledge graph (e.g., with bug topics), improveour feature design (e.g., on component community and bugsimilarity distribution), and experiment deep-learning basedfeature extraction in the learning-to-rank framework.
VII. A
CKNOWLEDGEMENT
This research was partially funded by Data61-ANU Col-
laborative Research Project CO19314. We sincerely thank
the anonymous reviewers for the insightful and constructive
feedback.
REFERENCES
[1] K. Somasundaram and G. C. Murphy, ‚ÄúAutomatic categorization of
bug reports using latent dirichlet allocation,‚Äù in Proceeding of the 5th
Annual India Software Engineering Conference, ISEC 2012, Kanpur,
India, February 22-25, 2012, S. K. Aggarwal, T. V . Prabhakar,V . Varma, and S. Padmanabhuni, Eds. ACM, 2012, pp. 125‚Äì130.
[Online]. Available: https://doi.org/10.1145/2134254.2134276
[2] A. Sureka, ‚ÄúLearning to classify bug reports into components,‚Äù in
Objects, Models, Components, Patterns - 50th International Conference,
TOOLS 2012, Prague, Czech Republic, May 29-31, 2012. Proceedings,
ser. Lecture Notes in Computer Science, C. A. Furia and S. Nanz,
Eds., vol. 7304. Springer, 2012, pp. 288‚Äì303. [Online]. Available:https://doi.org/10.1007/978-3-642-30561-0
20
[3] W. Zou, D. Lo, Z. Chen, X. Xia, Y . Feng, and B. Xu, ‚ÄúHow
practitioners perceive automated bug report management techniques,‚ÄùIEEE Trans. Software Eng., vol. 46, no. 8, pp. 836‚Äì862, 2020. [Online].
Available: https://doi.org/10.1109/TSE.2018.2870414
[4] X. Xia, D. Lo, M. Wen, E. Shihab, and B. Zhou, ‚ÄúAn empirical
study of bug report Ô¨Åeld reassignment,‚Äù in 2014 Software Evolution
Week - IEEE Conference on Software Maintenance, Reengineering,
and Reverse Engineering, CSMR-WCRE 2014, Antwerp, Belgium,
February 3-6, 2014, S. Demeyer, D. W. Binkley, and F. Ricca,
Eds. IEEE Computer Society, 2014, pp. 174‚Äì183. [Online]. Available:
https://doi.org/10.1109/CSMR-WCRE.2014.6747167
[5] J. Anvik, L. Hiew, and G. C. Murphy, ‚ÄúWho should Ô¨Åx this bug?‚Äù
inProceedings of the 28th International Conference on Software
Engineering, ser. ICSE ‚Äô06. New York, NY , USA: Association
for Computing Machinery, 2006, p. 361‚Äì370. [Online]. Available:
https://doi.org/10.1145/1134285.1134336
[6] S. L. Marco Castelluccio, ‚Äúbugbug,‚Äù GitHub, https://github.com/mozilla/
bugbug.
[7] G. Jeong, S. Kim, and T. Zimmermann, ‚ÄúImproving bug triage with
bug tossing graphs,‚Äù in Proceedings of the 7th joint meeting of the
European Software Engineering Conference and the ACM SIGSOFT
International Symposium on Foundations of Software Engineering,
2009, Amsterdam, The Netherlands, August 24-28, 2009 , H. van Vliet
and V . Issarny, Eds. ACM, 2009, pp. 111‚Äì120. [Online]. Available:
https://doi.org/10.1145/1595696.1595715
[8] V . D. Blondel, J.-L. Guillaume, R. Lambiotte, and E. Lefebvre, ‚ÄúFast
unfolding of communities in large networks,‚Äù Journal of statistical
mechanics: theory and experiment , vol. 2008, no. 10, p. P10008, 2008.
[9] C. J. Burges, ‚ÄúFrom ranknet to lambdarank to lambdamart: An
overview,‚Äù Learning, vol. 11, no. 23-581, p. 81, 2010.
[10] ‚Äúxgboost,‚Äù GitHub, https://github.com/dmlc/xgboost.
[11] T. Menzies and A. Marcus, ‚ÄúAutomated severity assessment of
software defect reports,‚Äù in 24th IEEE International Conference on
Software Maintenance (ICSM 2008), September 28 - October 4, 2008,
Beijing, China. IEEE Computer Society, 2008, pp. 346‚Äì355. [Online].Available: https://doi.org/10.1109/ICSM.2008.4658083
[12] T. Zhang, J. Chen, G. Yang, B. Lee, and X. Luo, ‚ÄúTowards more
accurate severity prediction and Ô¨Åxer recommendation of software
bugs,‚Äù J. Syst. Softw., vol. 117, pp. 166‚Äì184, 2016. [Online]. Available:
https://doi.org/10.1016/j.jss.2016.02.034
[13] A. LamkanÔ¨Å, S. Demeyer, E. Giger, and B. Goethals, ‚ÄúPredicting
the severity of a reported bug,‚Äù in Proceedings of the 7th
International Working Conference on Mining Software Repositories,MSR 2010 (Co-located with ICSE), Cape Town, South Africa,May 2-3, 2010, Proceedings, J. Whitehead and T. Zimmermann,
Eds. IEEE Computer Society, 2010, pp. 1‚Äì10. [Online]. Available:
https://doi.org/10.1109/MSR.2010.5463284
[14] Y . Tian, D. Lo, and C. Sun, ‚ÄúInformation retrieval based nearest
neighbor classiÔ¨Åcation for Ô¨Åne-grained bug severity prediction,‚Äù in 19th
Working Conference on Reverse Engineering, WCRE 2012, Kingston,ON, Canada, October 15-18, 2012 . IEEE Computer Society, 2012, pp.
215‚Äì224. [Online]. Available: https://doi.org/10.1109/WCRE.2012.31
[15] ‚Äî‚Äî, ‚ÄúDRONE: predicting priority of reported bugs by multi-
factor analysis,‚Äù in 2013 IEEE International Conference on Software
Maintenance, Eindhoven, The Netherlands, September 22-28, 2013.IEEE Computer Society, 2013, pp. 200‚Äì209. [Online]. Available:
https://doi.org/10.1109/ICSM.2013.31
[16] F. Khomh, B. Chan, Y . Zou, and A. E. Hassan, ‚ÄúAn entropy evaluation
approach for triaging Ô¨Åeld crashes: A case study of mozilla Ô¨Årefox,‚Äùin18th Working Conference on Reverse Engineering, WCRE 2011,
Limerick, Ireland, October 17-20, 2011, M. Pinzger, D. Poshyvanyk,
and J. Buckley, Eds. IEEE Computer Society, 2011, pp. 261‚Äì270.
[Online]. Available: https://doi.org/10.1109/WCRE.2011.39
[17] J. Chen, X. He, Q. Lin, H. Zhang, D. Hao, F. Gao, Z. Xu, Y . Dang,
and D. Zhang, ‚ÄúContinuous incident triage for large-scale onlineservice systems,‚Äù in 34th IEEE/ACM International Conference on
Automated Software Engineering, ASE 2019, San Diego, CA, USA,November 11-15, 2019 . IEEE, 2019, pp. 364‚Äì375. [Online]. Available:
https://doi.org/10.1109/ASE.2019.00042
[18] P. Bhattacharya and I. Neamtiu, ‚ÄúFine-grained incremental learning
and multi-feature tossing graphs to improve bug triaging,‚Äù in 26th
IEEE International Conference on Software Maintenance (ICSM 2010),
September 12-18, 2010, Timisoara, Romania , R. Marinescu, M. Lanza,
and A. Marcus, Eds. IEEE Computer Society, 2010, pp. 1‚Äì10.[Online]. Available: https://doi.org/10.1109/ICSM.2010.5609736
[19] P. Bhattacharya, I. Neamtiu, and C. R. Shelton, ‚ÄúAutomated, highly-
accurate, bug assignment using machine learning and tossing graphs,‚Äù J.
Syst. Softw., vol. 85, no. 10, pp. 2275‚Äì2292, 2012. [Online]. Available:
https://doi.org/10.1016/j.jss.2012.04.053
[20] H. Hu, H. Zhang, J. Xuan, and W. Sun, ‚ÄúEffective bug triage based
on historical bug-Ô¨Åx information,‚Äù in Proceedings of the 2014 IEEE
25th International Symposium on Software Reliability Engineering ,
ser. ISSRE ‚Äô14. USA: IEEE Computer Society, 2014, p. 122‚Äì132.
[Online]. Available: https://doi.org/10.1109/ISSRE.2014.17
[21] X. Xia, D. Lo, E. Shihab, and X. Wang, ‚ÄúAutomated bug
report Ô¨Åeld reassignment and reÔ¨Ånement prediction,‚Äù IEEE Trans.
Reliab., vol. 65, no. 3, pp. 1094‚Äì1113, 2016. [Online]. Available:
https://doi.org/10.1109/TR.2015.2484074
[22] A. LamkanÔ¨Å and S. Demeyer, ‚ÄúPredicting reassignments of bug
reports - an exploratory investigation,‚Äù in 17th European Conference
on Software Maintenance and Reengineering, CSMR 2013, Genova,
Italy, March 5-8, 2013 , A. Cleve, F. Ricca, and M. Cerioli, Eds.
IEEE Computer Society, 2013, pp. 327‚Äì330. [Online]. Available:https://doi.org/10.1109/CSMR.2013.42
[23] E. Shihab, A. Ihara, Y . Kamei, W. M. Ibrahim, M. Ohira, B. Adams,
A. E. Hassan, and K. Matsumoto, ‚ÄúStudying re-opened bugs in opensource software,‚Äù Empir. Softw. Eng., vol. 18, no. 5, pp. 1005‚Äì1042,
2013. [Online]. Available: https://doi.org/10.1007/s10664-012-9228-6
[24] ‚Äî‚Äî, ‚ÄúPredicting re-opened bugs: A case study on the eclipse project,‚Äù
in17th Working Conference on Reverse Engineering, WCRE 2010,
13-16 October 2010, Beverly, MA, USA, G. Antoniol, M. Pinzger, and
E. J. Chikofsky, Eds. IEEE Computer Society, 2010, pp. 249‚Äì258.
[Online]. Available: https://doi.org/10.1109/WCRE.2010.36
[25] Y . Tian, D. Wijedasa, D. Lo, and C. L. Goues, ‚ÄúLearning to rank
for bug report assignee recommendation,‚Äù in 24th IEEE International
Conference on Program Comprehension, ICPC 2016, Austin, TX, USA,
May 16-17, 2016. IEEE Computer Society, 2016, pp. 1‚Äì10. [Online].
Available: https://doi.org/10.1109/ICPC.2016.7503715
[26] J. Han, J. Li, and A. Sun, ‚ÄúUFTR: A uniÔ¨Åed framework forticket routing,‚Äù CoRR, vol. abs/2003.00703, 2020. [Online]. Available:
https://arxiv.org/abs/2003.00703
