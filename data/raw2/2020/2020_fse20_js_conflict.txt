Detectingand Understanding JavaScriptGlobalIdentifier
Conflicts onthe Web
Mingxue Zhang
Chinese Universityof Hong Kong
Hong Kong SAR,China
mxzhang@cse.cuhk.edu.hkWei Meng
Chinese Universityof Hong Kong
Hong Kong SAR,China
wei@cse.cuhk.edu.hk
ABSTRACT
JavaScriptiswidelyusedforimplementingclient-sidewebappli-
cations, and it is common to include JavaScript code from many
differenthosts.However,inawebbrowser,allthescriptsloaded
inthesameframeshareasingleglobalnamespace.Asaresult,a
scriptmayreadorevenoverwritetheglobalobjectsorfunctionsin
other scripts, causing unexpected behaviors. For example, ascript
canredefineafunctioninadifferentscriptasanobject,sothatany
callofthat functionwouldcause an exception at run time.
We systematically investigate the client-side JavaScript code
integrity problem caused by JavaScript global identifier conflicts
inthispaper.Wedevelopedabrowser-basedanalysisframework,
JSObserver ,tocollectandanalyzethewriteoperationstoglobal
memorylocationsbyJavaScriptcode.Weidentifiedthreecategories
of conflicts using JSObserver on the Alexa top 100K websites, and
detected145,918 conflictson31,615websites.
WerevealthatJavaScriptglobalidentifierconflictsareprevalent
andcouldcausebehaviordeviationatruntime.Inparticular,we
discovered that 1,611 redefined functions were called after being
overwritten, and many scripts modified the value of cookies or
redefinedcookie-relatedfunctions.Ourresearchdemonstratedthat
JavaScript global identifier conflict is an emerging threat to both
the webusersandthe integrityofwebapplications.
CCS CONCEPTS
·Softwareanditsengineering →Softwaresafety ;·Security
andprivacy →Browser security .
KEYWORDS
JavaScript; Identifier conflicts;Webapplications
ACMReference Format:
MingxueZhangandWeiMeng.2020.DetectingandUnderstandingJavaScript
Global Identifier Conflicts on the Web. In Proceedings of the 28th ACM Joint
EuropeanSoftwareEngineeringConferenceandSymposiumontheFounda-
tionsofSoftwareEngineering(ESEC/FSE’20),November8ś13,2020,Virtual
Event, USA. ACM, New York, NY, USA, 12pages.https://doi.org/10.1145/
3368089.3409747
Permissionto make digitalor hard copies of allorpart ofthis work for personalor
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACM
mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,
topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ESEC/FSE ’20, November 8ś13, 2020, Virtual Event, USA
©2020 Associationfor Computing Machinery.
ACM ISBN 978-1-4503-7043-1/20/11...$15.00
https://doi.org/10.1145/3368089.34097471 INTRODUCTION
It is very common to separate code of different functionalities into
multipleexternalJavaScriptfilesandincludethescriptsfrommany
different hosts in developing web applications. This allows a devel-
oper to reuse the code in other third-party programming libraries
and to easily build an application rich of functionalities. For exam-
ple, to include a social plugin like the Facebook Like button, a web
developerneedstoincludeonlyaremotescriptfromFacebookand
add two<div>tags inher/his webpage [ 7].
Whileenhancingthefunctionalityofanapplication,theincluded
third-party scripts may cause unexpected behavior to the devel-
oper’sowncode.In JavaScriptand manyotherprogramminglan-
guages,developersuseanidentifiertorefertoavalue/objectora
function in memory. In the client-side JavaScript runtime environ-
ment,i.e.,thewebbrowser,thereexists asingleglobalnamespace
for all identifiers in scripts loaded in the same frame. Any variable
or function defined in a script’s own main scope is available to any
otherscriptexecutinginthesameframe.Thismeansthatascript
can not only directly call global functions and read the values of
global variables in another script, but also modify its global ob-
jects or functions. Since JavaScript is a weakly typed programming
language,ascriptcanevenchangethetypeofaglobalvariable/-
function without immediately causing any exceptions or errors.
Suchkindofglobalidentifierconflictscancompromisethe integrity
ofthedeveloper’sowncode,causingittotakeadifferentbranch,
return an incorrectvalue,orsimply crash, etc.
Global identifier conflicts are difficult to prevent. On the one
hand, to avoid identifier conflicts, a developer needs to carefully
examinethesourcecodebeforeshe/heincludesathird-partyscript,
whichcouldbeverydifficultbecauseofcodeminimizationorob-
fuscation.She/he might have to changeall conflictinglocations in
her/his own code to have a conflicting script included unless an
alternativenon-conflictingscriptcanbeused.Ontheotherhand,
if no conflict is found, a script might still cause a conflict in the
future.Thethird-partycodeishostedonaremoteserverandcan
bemodifiedbythescriptprovideratanytimewithoutnotifications.
The developer can enforce integrity check of a script, for example,
by using Subresource Integrity [ 21] or thesha256-option of the
Content-SecurityPolicy(CSP)[ 34].The application,however,can
bebrokenwhenevertheremotecodeneedstobeupdated( e.g.,due
to a security advice). Further, a script can dynamically include any
otherscripts,whichmayalsocontainglobalidentifiersthatconflict
withtheexistingones.Thiscouldbeprohibitedbyconfiguringa
CSPpolicy.However,CSPhadalimitedadoptionrate[ 5,6]because
many websites require to dynamically load additional scripts from
arbitrarysources.Forexample,millionsofwebsitesmakeprofitsby
38ESEC/FSE ’20, November8–13,2020,VirtualEvent, USA Mingxue Zhang andWeiMeng
including advertisingscripts, whichcan include additionalscripts
from otherpartnersinthe real-timeauctionprocess.
Priorresearchhavestudiedpotentialglobalidentifierconflicts
between two JavaScript libraries. In [ 25], the authors generated
syntheticclientstotestiftwolibrarieswouldcausedifferentbehav-
iorswhentheyareloadedunderdifferentsettings.Suchclientscan
test only the simple operations of the libraries whereas the code in
realapplicationscouldbemuchmorecomplex.Theresultcannot
reflecttheconflictsinrealapplications,whichmayincludemore
than two libraries. The applications may even include custom code
thatisdynamicallyloadedfromboththedevelopers’ownhostsand
the third-party hosts. Finally, the analysis is based on a selective
record-replaydynamicanalysisframework[ 33]thatinstruments
selectedsourcecode.Thus,thetooldoesnotcoveranyadditional
code that isdynamically loaded.
Inthispaper,weaimtostudyJavaScriptglobalidentifierconflicts
inrealwebsites.We faceseveralchallenges.First,mostJavaScript
codeisasynchronouslyexecutedascallback.Itisdifficulttoreason
about which definition is valid when a variable is used. Second,
JavaScriptisaweaklytypedand dynamicprogramminglanguage.
Static analysis is likely to overestimate the conflicts, resulting in
manyfalsepositives.Third,notallcodeinarealwebsiteisavailable
statically.Asitecanloadmultipleexternalscriptsfromarbitrary
sourcesdynamicallyatruntime.Fourth,JavaScriptsupportsobject-
orientedprogrammingfeatures.Awritetoaglobalobjectcanbe
performedwithin the methodofthat objectitself.
To overcome the above challenges, we develop JSObserver , a
browser-baseddynamicanalysisframeworkthatmonitorsandlogs
writeoperationstoJavaScriptglobalmemorylocations( i.e.,vari-
ables and functions). We perform just-in-time code instrumentation
by modifying the Chrome V8 JavaScript engine. The instrumenta-
tion allows us to cover all code that is executed at run time. We
dynamically insert the monitoring code when a script performs
an operationrelatedtomemorywrite. Specifically, we maintaina
shadowvariabletoperformdynamictypeinference.Welogafunc-
tiondefinitionwhenafunctionisfirstparsedinV8orafunction
literalisassignedtoavariable.Welogeachmemorywriteopera-
tion,includinganassignment,anobjectdefinition/creation,anda
functionreturn.SincetheobjectsinJavaScriptarecopied/passedby
reference instead of by value, we also implement a shadow and im-
mutable identifier property that uniquely identifies each JavaScript
objectin memory.This makesalias analysismuchsimpler andac-
curate.Withthelogs,wedetectthreekindsofconflictsÐvariable
valueconflict,functiondefinitionconflict,andvariabletypecon-
flict. Although our analysis is not sound because we do not test all
possible execution paths, it is precise as every conflict we detect
musthave happened.
Weimplementedaprototypeof JSObserver basedontheChrom-
iumbrowserversion71,andusedtheprototypetoanalyzethemain
pages of the Alexa top 100K websites. We show that this class of
codeintegrityproblemisverycommonÐoverall,wefound36,813
function definition conflicts on 9,566 websites, 27,893 variable type
conflicts on 3,501 websites and 81,212 variable value conflicts on
27,199 websites. The conflicts were mainly caused by the use of
short/simple identifiers and duplicate inclusion of scripts. In partic-
ular,becauseofconflicts,cookieson109websitesweremodified
andmanycookie-relatedfunctionswereredefined.OurresearchdemonstratesthestrongneedtoisolateJavaScriptcodefromdiffer-
entorganizationsintoseparate namespaces.
To thebest of our knowledge, we are thefirst tosystematically
measureandanalyzeJavaScriptglobalidentifierconflictsonalarge
scale.In summary,we make the following contributions.
•We develop JSObserver , a browser-based dynamic analysis
frameworkforstudyingJavaScriptglobalidentifierconflicts.
•We perform an empirical study on Alexa top 100K websites
andmake our data publiclyavailable.
•We characterize the detected conflicts in real web applica-
tionsanddiscuss the security implications.
The rest of this paper is organized as follows. We define our
research problem in ğ2. We describe the design of JSObserver and
our methodology in ğ3. Inğ4, we characterize the global identifier
conflictsanddemonstrateseveralinterestingcaseswedetected.We
discussthelimitationsofourstudyandfutureworkin ğ5.Finally,
we discuss relatedwork in ğ6andconclude in ğ7.
2 PROBLEM STATEMENT
In thissection,we firstformallydefine the threetypesof conflicts
that we study, then demonstrate the scope of our research, and
finally discuss our research challenges.
2.1 Definitions
We consider conflicts caused by writes by multiple scripts to the
same global memory location ( i.e., a variable or a function) in
JavaScript. A global memory location can be accessed through
one or more global identifiers in any scope in JavaScript. All mem-
orylocationsarepropertiesofsomeobject.Theycanbeaccessed
throughthedotnotationorthebracketnotation.Forexample,both
window.x["y"] andwindow.x.y point to a property named as "y"
of the objectwindow.x, which is a property named as "x"of the
global objectwindow. The identifierwindowis often omitted, e.g.,
as inx["y"]. Global functions are also considered as properties
(or more precisely,methods) of the object window. We define three
categoriesofJavaScript globalidentifier conflictsnext.
ValueConflicts. Valueconflictshappenwhentwoormorescripts
write to the same global variable with different values in the same
type. For example, a script S1may assign1to the variablestate,
whichisthenoverwrittenbyanotherscript S2to0.Thecontrolflow
ofS1can be changed if it later uses this variable in a conditional
statementinacallbackfunction.Notethatthewritestothesame
propertyofaglobalobjectvariable, e.g.,loc.x,withdifferentvalues
inthe same type are alsoconsideredas valueconflicts.
Function Definition Conflicts. This type of conflicts occurs if
twoormorescriptsdefineaglobalfunctionwiththesamename.
Theruntimebehaviorisnormallyundeterminedanddependson
theorderofthefunctiondefinitions.Normally,thefunctiondefined
inascript that ismostrecently loadedisselectedbythe browser.
Type Conflicts. A type conflict occurs when the same global
location,i.e., a variable or a function, is written by multiple scripts
with values of different types. For example, fwas defined by script
S1as a global function. Script S2may assign a string to f, which
would surpriseS1and cause it to crash when it calls f()to handle
someuseractions.Changingthetypeofapropertyofaglobalobject
variable byadifferentscript alsoconstitutes to atype conflict.
39DetectingandUnderstandingJavaScript GlobalIdentifier Conflicts onthe Web ESEC/FSE ’20, November8–13,2020,VirtualEvent, USA
2.2 ScopeofResearch
WefocusonstudyingaformofJavaScript codeintegrity problem
caused by global identifier conflicts. The conflicts can be caused by
scriptsfromeitheradifferentorganization, i.e.,thecross-organization
conflicts,orthesameorganization, i.e.,theintra-organizationcon-
flicts. We study the following three kinds of cross-organization
conflicts:1)athird-partyscriptoverwritesaglobalvariable/func-
tion defined by a first-party script; 2) a first-partyscript overwrites
aglobalvariable/functiondefinedby a third-party script; and3)a
third-party organization’s script conflicts with another third-party
organization’s script. Although a web developer may also write
codethat causesany of thethree types ofconflictsdefined in ğ2.1,
we think this is probably the design choice of the developer. There-
fore,we donot report conflictsoccurredwithin the same script.
In our research, an organization is recognized by the domain
name,excludingthetopleveldomain(TLD),ofascript’ssourceURL.
Forexample,scriptsloadedfrom www.google.com andadservice.
google.co.uk belongtothesameorganizationbecausetheirdomain
names are both google. We acknowledge that this is not the best
way to detect all domain names of a particular organization. For
example, both www.twitch.tv andwww.amazon.com are owned
by Amazon; cdn.a.com andwww.cdn-a.com may also belong to
the sameorganization a.com. However, such cases cannotbeeasily
detectedwithoutadditionalinformationprovidedbyhumans.We
leaveitasafutureworktoimprovethemethodtodeterminethe
relationships oftwodomainnames.
Aconflictingscriptcanbeeitherdirectlyincludedbytheweb
developer, or indirectly included by another script in the same
web frame. The conflicting script has the default full privilege to
accessanycontentinitsembeddingframe.Wedonotconsidercode
injectionattackslikecross-sitescripting(XSS),althoughtheyare
otherformsofthreatstotheintegrityofclient-sideJavaScriptcode.
Codeinjectionattacksareactuallyorthogonaltoglobalidentifier
conflicts as a conflicting script already executes in the target frame.
Note that our research goal is not to determine a conflict as
malicious or benign, as many of the conflicts can be caused un-
intentionally. Rather, we aim at detecting the conflicts that can
compromise the integrity of a script and analyzing the potential
security implications.
2.3 Research Challenges
We face the following challenges indetecting the conflicts.
Asynchronous Execution. JavaScript is single-threaded in the
browser.Mostscriptsareasynchronous, i.e.,theexecutionofmulti-
ple scripts can be interleaved with callback functions. Therefore,
staticreachingdefinitionanalysisisimprecisebecauseavariablede-
finedinthemainfunctioncanbeasynchronouslyusedinacallback
function andasynchronously redefinedbyanotherscript.
Type Inference. JavaScript is a dynamically-typed and weakly-
typed programming language. An identifier can be used for data of
differenttypeswithoutexplicittypeconversions.Thetypecheckis
performedatruntime.Therefore,apurelystaticanalysisapproach
isnot sufficient to detectvariable type conflicts.
Object Support. Objects in JavaScript are supported by its proto-
type mechanism. Except for the primitive types, all other variablesare of the type object. A script can overwrite a part ( i.e., a prop-
erty)ofanobjectindirectlybyinvokingamethodoftheobject.We
need to identify thereceiver object whena writeoperation occurs
within a method instead of a normal function. In particular, thisis
acommonlyusedidentifierinJavaScript,andcanpointtodifferent
objects in different contexts. For example, thispoints to the global
objectwindowinanormal function scope orintheglobalscope;it
referstoanobjectwhenitisaccessedwithinthescopeofamethod
oftheobject.Inordertodeterminethetargetofawrite,weneed
to inferprecisely whichobject thispointsto.
AliasAnalysis. AllobjectsinJavaScriptarecopied/passedbyref-
erenceinsteadofbyvalue.Therefore,thesamegloballocationmay
bepointedbymultipleidentifiersindifferentscripts.Forinstance,a
globalvariableXcanbemodifiedindirectlybyascriptthatwritesto
thepropertyofY(e.g.,Y.property = 1; )ifYisanaliastoX.Further,
when passed as an argument to a parameter of a function, a global
object can be modified through the parameter within the function.
Inotherwords,todetectthewritestoagloballocation,weneedto
keeptrack ofallidentifiers oraliasespointing to the same object.
3 DESIGN AND METHODOLOGY
In thissection, wepresent JSObserver ,abrowser-based dynamic
analysisframeworkfordetectingJavaScriptglobalidentifiercon-
flicts at run time. We record each function definition in the V8
parser to detect function definition conflicts ( ğ3.1). We perform
just-in-time instrumentation of all JavaScript code that is executed
tocoverallwritestoamemorylocation( ğ3.2).Therecordsallow
ustodetectconflictingwritesbydifferentscriptstothesameglobal
memory locations ( ğ3.3).
3.1 Recording GlobalFunctionDefinitions
The rootcauseoffunctiondefinitionconflicts is that twoor more
scriptscandefinetheirfunctionsusingthesameglobalidentifier
(i.e.,functionname).Therefore,weneedtofindallfunctionsthat
are defined in each script. A developer can define a global function
in two ways: 1) defining a named function directly in the global
scope,e.g.,functionf(args){ stmts; } ;and2)assigningafunc-
tion literal to a global variable, e.g.,window.f =function(args){
stmts; }.Notethatascriptmayassignafunctionliteralwitha
non-empty function name to a variable, e.g.,varx =functionf(
args){ stmts; } .Thatfunctionname( e.g.,f)isaninvalididentifier
(i.e.,undefined ) inJavaScript.
Finding the first type of function definition is not difficult. In
theV8engine,theparserneedstofirstparsetheJavaScriptcode
in the global scope before the compiler outputs the target code.
Therefore, JSObserver logs all global functions with a non-empty
name. Thelog includesauniqueID( e.g., timestamp),theposition
of the function definition, an ID of the script, and an ID of the exe-
cutioncontext.Thetimestamp-likelogIDenablesustounderstand
ateachpointoftimewhichdefinitionisvalid.Wecanalsoleverage
it to study variable type conflicts involving a global function. In
particular,wecandetermineifafunctionischangedtoanobject
orif an objectischangedto afunction.
Findingthesecondtypeoffunctiondefinitionrequiresustoalso
monitor writesto globalvariables. We discuss itnext.
40ESEC/FSE ’20, November8–13,2020,VirtualEvent, USA Mingxue Zhang andWeiMeng
3.2 Recording Writes to Variables
In this section, we describe how JSObserver logs the write opera-
tions to variables. A JavaScript variable can be written in primarily
twoways:1)directlywrittenbyassigningavaluetoitorbycopying
anothervariabletoit;or2)partiallywrittenbyassigningavalue
orbycopyinganothervariabletooneofitspropertiesifthevari-
ablebeingwrittenisanobject.Thevaluethatcanbewrittentoa
variableoritspropertiescanbeinseveralcategories:1)aprimitive
typevalue( e.g.,anumberorabooleanvalue);2)anobjectliteral
(e.g.,{a:1, b:0} ); and 3) an object initialized with a constructor
(e.g.,newPerson("John", 20) ).However,capturingallthewrites
to avariable isvery challenging.
First, variables in different scopes can use the same identifier
(name).Weneedtodifferentiatelocalvariablesfromglobalvariables
toavoidoverestimation.Totellifanidentifier visaglobalvariable
or not,JSObserver checks the scope of the current statement S
wherevisused.Ifthecurrentscopeisthe globalscope ,theidentifier
invisglobalandisdirectlylogged.Ifthecurrentscopeisa function
scope,JSObserver wouldsearchtheidentifier vintheparameter
list and declaration list of the current function. If vis found in
the lists, it is determined as a local name; otherwise JSObserver
continues to search the lists of an outer function scope until either
a match is found or itreaches the global scope. A special situation
isthatthecurrentscopeisanobjectscopeorafunctionscopeinan
object (i.e., a method) and the identifier points to a property of the
currentobject, e.g.,this.p.Thisrequiresustoinferwhichobject
the keywordthispointsto,whichwe describe next.
Second, variables of non-primitive types, i.e., objects, are copied
orpassed by referenceinsteadof by value inJavaScript. In order
todetectthewritesto thesameobject,weneedtoidentifyallthe
validaliases to it. One intuitive approach is to keep track of all the
assignmentsinvolvinganobjectoravariableofanobject.However,
thisapproachiserror-pronebecauseanobjectcanbepassedinto
severalnestedfunctioncallsorassignedasapropertyofanother
object. An object variable vcan also be assigned to another ob-
jectobj(e.g.,v = obj),hencebecomesanewaliasto obj.Further,
anobjectcanbeself-referencedinitsmethodswiththekeyword
this,which can potentially pointto any object. To solve this chal-
lenge,JSObserver maintainsauniqueandimmutableshadowID
propertyś__id__śofeachJavaScriptobjectinV8.Wheneveran
object is being written, we can identify it with this shadow ID
property,regardless ofthe JavaScript variable name being used.
Torecordthetypeofavariable,weleveragethe typeofoperator
in JavaScript. However, if its operand is an expression instead of a
simpleidentifier,theexpressionwouldbeevaluatedagainwhenwe
inferthetypeusingit.Thiswouldcausesomeunexpectedbehavior.
Forexample,considertheassignmentstatement arr[i++] = f() .
Tologthetypeofthememorywritedestination,wecanuse typeof
arr[i++].Thiswouldcauseanadditionalupdateofthevalueof
i, such that the type of the wrong memory location is returned.
Toavoidthiskindofsideeffects,weintroduceashadowvariable
v'for each direct write operation to a variable in our instrumen-
tation.Thewriteisappliedtotheoriginalvariablefirst,andthen
applied to the shadow target in a nested assignment statement.
JSObserver recordsthetypeofthewritetargetbyspecifyingthe
shadowvariable as the operand of typeof.Table 1:Instrumentation forrecording writeoperations.
1.v=e=⇒v′=v=e
recordWrite (v,v′,v′,e)
2.v+=e=⇒v′=v+=e
recordWrite (v,v′,v′,e)
3.v1=v2=e=⇒v′
1=v1=v′
2=v2=e
recordWrite (v2,v′
2,v′
2,e)
recordWrite (v1,v′
1,v′
1,
v′
2=v2=e)
4.v.p=e=⇒v′=v
v′.p=e
recordWrite (v.p,v′,v′.p,e)
5.{p1:e1,=⇒o′={p1:e′
1=e1,p2:e′
2=e2, ...}
p2:e2, ...} recordWrite (o′.p1,o′,e′
1,e1)
recordWrite (o′.p2,o′,e′
2,e2)
6.new Obj (...){=⇒new Obj (...){
this.p=e;} o′=this;
o′.p=e;
recordWrite (this.p,o′,o′.p,e);}
We next discuss in detail the instrumentations that JSObserver
performsforeachtypeofwriteoperationstoamemorylocation:1)
assignmentstatements;and2)objectliteralandconstructorexpres-
sions.Wesummarizetheinstrumentationsin Table1.Whenanyof
thewriteoperationsisexecuted, JSObserver infersandrecordsthe
typeofthememorywritetarget v,thevalueofthetargetifitisa
primitivetypevariable,theexpressions eintheoperation,aunique
log ID, and the IDs of the script and the execution context, using a
custom function recordWrite(v, s, t, e) . Inside the function, it
infers the type of the write target vby evaluatingtypeoft, where
tis a (shadow) variable whose type is identical to that of v. It logs
theshadowIDproperty s.__id__ wheresisanaliastothewrite
target object. If the target is of a primitive type, the variable tis
passed tosand the functioninstead logsthe valueof t. The write
sourceexpression eisalsorecorded.
3.2.1 AssignmentStatements. Assignmentstatementsarethemost
direct way that a script can write to a variable. For each direct
write targetvin an assignment statement where vis a variable,
JSObserver creates a shadow variable v'for it automatically. In
particular, JSObserver replacestheassignmentstatementwitha
nested assignment statement which writes to both vandv', as the
first rule shown in Table 1. This avoids evaluating an expression
likearr[i++] twice.
For a shorthand operator, e.g.,+=,JSObserver also creates a
shadow variable v'for the direct write target v, as the second
ruleinTable1.Incasethatanestedassignmentstatementisfound,
JSObserver wouldvisittheabstractsyntaxtree(AST)ofthenested
assignmentstatementandreplaceeachassignmentstatementnode
individually(rule #3 in Table1).
We need to also identify an object when it is partially written
through its property. We could again try to leverage the above
shadow variable to get the shadow ID to avoid re-evaluation of
41DetectingandUnderstandingJavaScript GlobalIdentifier Conflicts onthe Web ESEC/FSE ’20, November8–13,2020,VirtualEvent, USA
anexpression,asin v'= v.p = e .However,theshadowvariable
would be an alias to the source object ebeing assigned to the
property instead of an alias to the target object v. Further, if the
writesource’stypeisaprimitivetype,theshadowvariable v'would
be avaluecopy ofitinstead ofan alias to it.
In such a situation where the write target is a property of an
object variable, e.g.,v.p = 1,JSObserver creates a shadow vari-
ablev'oftheparentobjectvariable vinsteadofitsproperty v.p.It
then applies the writeto the property through the shadow variable
instead of the original variable, e.g.,v'.p = 1, to avoid expression
re-evaluation(rule#4in Table1).Asaresult,weareabletoiden-
tify property writes to the same object. For example, a method
writes to one property of the owner object through this.p = 1;.
JSObserver willtransferthecodeinto v'= this; v'.p = 1;,and
identifytheownerobjectthroughthevalue v'.__id__.Onespecial
caseisthatthepropertyisalsoanobject.Suchawritewouldnot
modifythatobjectrepresentedbytheproperty,whichwasessen-
tially an alias, but make the property either a new aliasto another
objectbeingassignedtoitoraprimitivetypevariable.Therefore,
we do not create a separate shadow variable for an object property.
Wedocheckthetypeoftheproperty( e.g.,typeofv'.p)ratherthan
that ofthe shadowobjectto detecttype conflicts.
3.2.2 Object Literal and Constructor Expressions. To detect a write
conflicttoapropertyofaglobalobject, JSObserver needstorecord
allwrites to it, including the initialdefinition.A property can be
defined in two ways. First, the property is directly initialized in
anobjectliteralexpression,asrule#5in Table1.JSObserver cre-
ates a shadow variable o'for the newly created object, and calls
recordWrite torecordthewritetoeachpropertyoftheobject.The
unique object ID would also be logged with the shadow variable
o'. Second, a property pmay be defined within the constructor
or a method of an object through the identifier this, as rule #6
inTable 1. In the case of an object constructor, JSObserver also
createsashadowvariable o'fortheobjectinsidetheconstructor.
JSObserver then logs the write to the property this.pand also
the shadowID of thisthrougho'.
With the help of the unique object shadow ID, we avoid the
burden of tracking the aliases to an object. In our analysis stage,
we are able to search backward in the logs to find all write records
withthe same objectshadowID to detectany writeconflicts.
3.3 Detecting Conflicts
Inthissection,wediscusshowweleveragetherecordscollectedby
JSObserver to detectthe three types ofglobalidentifier conflicts.
3.3.1 FunctionDefinitionConflicts. Thedetectionofglobalfunc-
tiondefinitionconflictsisverystraightforward.Wesimplycheck
the function definitions in each frame to find if the same global
functionhadbeendefinedformorethanoncebydifferentscripts.
However, a global function can also be defined by assigning a
function literal to a global identifier. To detect conflicting function
definitions by function literal writes, we also find assignment logs
where the type of the write target is function, and search the target
identifier, i.e.,the functionname,inthe function definitionlogs.
3.3.2 ValueConflictsandTypeConflicts. Ifaglobalvariableisof
aprimitivetype,itdoesnothaveanalias.Wewillsearchanyotherwrite records to the same global identifier. If the logged values
intworecordsaredifferentandthewritesareperformedbytwo
different scripts, we report it as a variable value conflict. However,
ifinonerecordthetypeoftheglobalvariableisdifferent,wereport
itas avariable type conflict.
If a global variable is an object, a value conflict may happen
in two situations. First, the variable vitself is overwritten with
another variable. This can be easily detected by searching only
the assignment records to the same identifier v. We do not need
to check if one of its aliases is overwritten because that would
effectively invalidate this variable vas an alias. Second, a property
oftheobjectiswritten.Thiscanbedetectedbysearchingthewrite
recordsofalltheobject’svalidaliaseswithregardstothecurrent
assignment. If the types of the property in two writes are the same,
wereportitasavariablevalueconflictifeitherthetypeisobject,or
thetypeisaprimitiveonebutthevaluesaredifferent.Otherwise
if the types differ, we report it as a variable type conflict. Note that
if the conflictiscausedbythe same script, we do not report it.
Variable and Function Type Conflicts. We find that a special
type of conflict may occur, i.e., a global identifier is used as both
a global function name and a global variable name. We call it as
variableandfunctiontypeconflicts.Forexample, fcouldbedefined
by a script as a global function. Another script may assign a primi-
tive type value or an object to feither before or after this function
definition.Similarly,aglobalvariable vofeitheraprimitivetypeor
anobject,maybeassignedwithafunctionliteralbyanotherscript,
asinv =function(){...};.In order todetect this kind oftype
conflicts,weneedtocrosscheckthefunctiondefinitionlogsand
variable writelogs. In particular, for each identifier thatis defined
asaglobalvariable,wesearchitinthefunctiondefinitionlogsas
well as the variable write logs to determine if it is also ever defined
as afunction.
3.4 Implementation
Weimplementedaprototypeof JSObserver basedonChromium
version71.0.3578.98usingabout4KlinesofC++code.Wemodified
the V8 parser to record global function definitions. We modified
the V8 bytecode generator to add our instrumentation code for
recording writes to memory locations. The write operation logs
recorded by JSObserver are stored in a string asgLogs, which is
implemented in the WebKit layer as a property of the DOMWindow
class. All the logs are dumped into the file system on the fly in
pageloadphase.TheprototypebinariesareavailablewiththeDOI:
10.5281/zenodo.3923232. We plan to release the source code of our
prototype implementationpublicly.
4 EVALUATION
In this section, we first describe the data collected in our web
crawling ( ğ4.1), then characterize the detected global identifier
conflicts by demonstrating what type of conflicts are generated
(ğ4.2)bywhichscripts( ğ4.3).Further,weprovidecasestudies( ğ4.4)
and analyze the affected websites and possible reasons of conflicts
(ğ4.5). Finally,we measure the performance of JSObserver (ğ4.6).
42ESEC/FSE ’20, November8–13,2020,VirtualEvent, USA Mingxue Zhang andWeiMeng
Table 2:Categorization ofglobalidentifierconflicts.
Category #Websites #Conflicts %Conflicts
Function Definition 9,566 36,813 25.23
third -> first 715 1,510 1.03
third -> diff_third 311 543 0.37
first-> third 349 704 0.48
third -> same_third 1,283 7,086 4.86
first-> first 6,829 25,580 17.53
unknown 891 1,390 0.95
Variable Type 3,501 27,893 19.12
third -> first 338 556 0.38
third -> diff_third 156 206 0.14
first-> third 288 434 0.30
third -> same_third 434 820 0.56
first-> first 1,881 22,882 15.68
unknown 643 2,995 2.05
Variable Value 27,199 81,212 55.66
third -> first 7,128 8,582 5.88
third -> diff_third 5,302 7,476 5.12
first-> third 2,021 2,493 1.71
third -> same_third 4,270 9,302 6.37
first-> first 11,986 40,248 27.58
unknown 7,980 13,111 8.99
4.1 DatasetandAvailability
WecrawleddatafromthemainpagesofAlexatop100Kwebsites
usingJSObserver in October 2019. For each website, we recorded
the writes to all identifiers and the calls to functions within 120s in
anassignmentlogfile,andstoredthedefinitionsofglobalfunctions
inafunctiondefinitionlogfile.Duringourexperiment,8,068(8.07%)
websitesdidnot finish loadingwithin2 minutes.Excluding those
thattimedoutorcrashedinourdatacollectionprocess,wesuccess-
fullygatheredassignmentlogfilesfrom79,083(79.08%)websites
andfunction definitionlogfilesfrom 80,566(80.57%)websites.
ThecollecteddataispubliclyavailablewiththeDOI:10.5281/zen-
odo.3874944.
4.2 CategoryofConflicts
Inthissection,wecharacterizeJavaScriptglobalidentifierconflicts
basedonthe categoriesthat we definein ğ2.1.
4.2.1 Function Definition Conflicts. In total, we detected 36,813
function definition conflicts on 9,566 websites. In particular, there
are1,065suchcaseswhereafunctionliteralwasdirectlyassignedto
an identifier, which was used as a function name by another script.
We considerthis as aspecialtype offunction definitionconflicts.
We then characterize these conflicts based on the class of the
conflictingscripts, i.e.,thirdpartyorfirstparty.Wecurrentlyare
notabletodeterminetheclassofadynamicallycreatedinlinescript
because it does not have a source URL. The class is "unknown" for
conflictsinvolvingsuchinlinescripts.Excludingthem,wewereable
to categorize35,423(96.22%) conflicts. Table2lists thebreakdown
ofthesefunctiondefinitionconflicts.
Cross-organization and Intra-organization Conflicts. Over-
all, we detected 2,757 (7.49%) cross-organization function defini-
tion conflicts. In particular, 543 (1.48%) cases were caused by a
third-partyorganization’sscriptthatredefinedfunctionsofother
third-partyscripts.Wealsodiscovered1,510(4.10%)conflictswhere
a third-party script modified a function defined by a first-party
script, and 704 (1.91%) cases where first-party scripts overwrote
functions defined by a third-party script. This indicates that scriptsTable 3:Topduplicatefunctions.
Function #Websites #Conflicts
gtag 450 631
_typeof 37 273
ez_getQueryString 235 241
getCookie 86 184
_classCallCheck 33 156
could break the integrity of other scripts loaded from a different
organizationbyoverwriting the function definitions.
Themajority(32,666or88.73%)offunctionredefinitionswere
intra-organizationconflicts.25,580(69.49%)ofthemwerecaused
byfirst-partyscriptsoverwritingotherfirst-partyscripts,andthe
conflictingdefinitionswereusuallysimilar.Wethinkthisisnota
goodcoding practice.
Conflicts on Browser Internal Objects. Interestingly, we de-
tected 24 function definition conflicts onbrowser internal objects,
and3ofthemarecross-organizationconflicts.Forexample,athird-
party and a first-party script assigned different function literals
toself.onerror .selfisareservedpropertyofthe windowobject
and points to the current window. The third-party script therefore
redefinedthewaythatruntimeerrorswerehandled.Theseconflicts
obviouslybroketheintegrityofscriptsfromotherorganizations.
We also found 21 intra-organization function definition conflicts
on the internal objects. In particular, 16 of them were found on
methods of internal objects. For instance, document.write() and
document.writeln() were modified on 6 and 4 websites, respec-
tively.Webelievethesewerethedevelopmentchoices,asthescripts
were all loaded from the first-party domain. However, exposing
the builtin methods to all scripts is dangerous, because any scripts
could changethe defaultbehaviorof the embedding websites.
DuplicateFunctionDefinitionandDuplicateScriptInclusion.
We identified several conflict cases where the two function defi-
nitionswereidentical,whichwecall duplicatefunctiondefinition .
Thismighthappenwhenthesamescriptisincludedformultiple
times.Intotal, wefound10,151(27.57%)casesthattheconflicting
functiondefinitionswereactuallyidentical,and9,198(24.99%)such
conflictsweredetectedbetweenscriptsofthesameorganization.
Theother953(2.59%)duplicatedefinitionswereprobablycaused
byincludingthe same libraries hostedbydifferentorganizations.
Table 3liststhe top functions of which we detected a duplicate
definition.Ascanbeseen,somecommonlyusedfunctions( e.g.,gtag
()andgetCookie() )wererepeatedlydefinedwiththesamecode.
Onepossibleexplanation isdevelopersusuallywould not checkif
a scripthas beenloaded before loading it twice.In total,we found
6,230 (16.92%) function definition conflicts caused by duplicate
inclusion of scripts. Duplicate inclusion does not necessarily break
the functionality of the embedding pages, but still could cause
unexpectedbehaviors, e.g.,invokingthesamefunctionformultiple
times.Therefore,we stillconsiderthis as abadcoding practice.
We do realize that our method to identify duplicate function
definitionsisnotcomprehensive,sinceafunctioncouldbeimple-
mentedinvariousways.Forexample, a && b = 1 isfunctionally
equivalenttoif(a){b = 1} .However,itisnotourmainfocusto
thoroughly compare the behavior of different functions, which
cannotbe easily decided.
43DetectingandUnderstandingJavaScript GlobalIdentifier Conflicts onthe Web ESEC/FSE ’20, November8–13,2020,VirtualEvent, USA
Table 4:Topredefined functions.
Function #Websites #Conflicts
getCookie 128 155
AKSB.done 115 115
AKSB.measure 115 115
AKSB.mark 114 114
_typeof 34 56
Table 5:Categorization ofcalls to redefined functions.
Category #Calls #Conflicts %Calls
third -> first 72 1,510 4.77
third -> diff_third 16 543 2.95
first-> third 66 704 9.38
third -> same_third 252 7,086 3.56
first-> first 1,091 25,580 4.27
unknown 114 1,390 8.20
TopRedefinedFunctions. Afterexcludingidenticalfunctiondef-
initions,weobtainthetopfivefunctionsthatweremostfrequently
redefined by scripts from different organizations, as listed in Ta-
ble4.Notethatthetopfunctionisrelatedtocookies.Byoverwriting
cookie-related functions, a malicious third-party script could ex-
poseawebsitetosecurityrisks,whichwewilldemonstratelater.
Meanwhile,thetopfunctionsthatarepropertiesofglobalobject
AKSBwere all redefined by one third-party script https://ds-aksb-
a.akamaihd.net/aksb.min.js .Furtherinvestigationshowsthatthe
first-partydefinitionofthesefunctionscontainedverysimplecode,
e.g., writes to an array. The third-party script modified them to
record several important events e.g.,domContentLoadedEventEnd .
For these conflicts, we think the first-party developers included
someinitialcodesnippetprovidedbytheAkamaiSDKs( e.g.,AKSB),
whichwouldupdatetheircode at runtime.
Call-after-redefinition. Toestimatetheimpactofthefunction
definition conflicts, we further searched in our logs to check if the
functionswerecalledaftertheywereredefinedbyadifferentscript.
Table 5gives the breakdown of the calls to the redefined functions.
Specifically,wedetected39caseswherethird-partydefinedfunc-
tionswereoverwrittenbyfirst-partyscripts,andwerecalledbythe
third-partyscripts later.Wealsofound29caseswherethefirst-party
scripts called a function that had been overwritten by a third-party
script. In particular, 12 of them were cookie-related functions. One
examplewasdetectedonthewebsite http://footdistrict.com/ ,where
afunctioncreateCookie() wasfirstlydefinedinafirst-partyscript,
butthenoverwrittenbyathird-partyscript.Afterthat,thefunction
createCookie() was called by the first party. Such a conflict could
introduce severe security risks, as a malicious third-party script
could manipulate the value of cookies to force a user to use the
attacker’ssession.
Summary. Wediscoverthatfunctiondefinitionconflictsexist
on over 9K popular websites. 2,757 (7.49%) conflicts were caused
by scriptsfromdifferent organizations, and1,611functionsgot
called after being redefined by a different script. We found 16
conflictsonbrowserbuiltinmethods,andsomecookie-related
functionswerefrequentlyredefined,whichcouldbeexploited
to expose the websites andtheirusersto security risks.4.2.2 Variable Type Conflicts. We detected 27,893 variable type
conflicts across 3,501 websites. The results are presented in Table 2.
Cross-organizationConflicts. Asshownin Table2,1,196(4.29%)
variabletypeconflictswerecausedbyscriptsfromdifferentorgani-
zations.Forexample,onthewebsite https://www.default-search.
net/,thevariablelocaleswasoriginallydefinedasastring "\&quot
;ar\_AE\&quot..." , and a third-party script from 12c719211bdf.
bitsngo.net modifiedittoanobject.Similarly,athird-partyscript
fromxml.adbetnet.com overwrotethevariable posdefinedbyan-
otherthird-partyscript from the number 4to an object.
Meanwhile,wealsodetected434(1.56%)caseswhereafirst-party
script modified the type of a third-party defined variable. For in-
stance,afirst-partyscriptmodifiedavariable formerCalledArguments
fromfalsetoanobject,andthatvariablewasoriginallydefinedby
a third-party script from d1lxhc4jvstzrp.cloudfront.net . This shows
that scripts in any class could be affected by variable type conflicts,
which can introduce potential risks because inconsistent types
could cause runtimeexceptions andleadto behaviordeviation.
Intra-organizationConflicts. Similartofunctiondefinitioncon-
flicts,most(23,702or84.97%)ofvariabletypeconflictswerecaused
by scriptsoverwriting variablesin scripts from the same organiza-
tion. We believe these conflicts could be the design choice of the
developers because the conflicting scripts were loaded from the
same organization’s domains. They could also cause difficult-to-
detectbugs if the developersof conflictingscripts were not aware
ofthe conflicts.
VariableandFunctionTypeConflicts. Wedetected971(3.48%)
special type conflicts where a primitive value or an object was
assigned to an identifier before or after the identifier was used as a
globalfunctionname.Specifically,3ofthemweredirectlydeclared
as a function. For example, the variable isChrome was defined as
truein a first-party script on https://www5.javmost.com/ before a
function was assigned to it. We detected 157 (0.56%) type conflicts
that a function was modified to be a non-function variable. As a
result,anycalltothemwouldcausearuntimeexception.Wealso
found one special case on the website http://vbspu.ac.in/ , where
afirst-partyscriptmodified dropdown toanobject,afterdeclaring
it as a function itself. Such a conflict caused a TypeError when
dropdown wascalledlater.This could be an implementationerror.
Further inspection showed that 106 out of 157 type conflicts
involvedidentifierswithalengthlessthan3, e.g.,ma,NN,etc.This
suggests that developers should use unique longer and meaningful
names to avoid the type conflicts.
Summary. We detected variable type conflicts on over 3K web-
sites, and 1,196 (4.29%) were caused by scripts of different or-
ganizations. Especially, global functions could be redefined as
non-functionvariables,whichcouldcauserun-timeerrorswhen
they are called. These conflicts were mainly caused by scripts
using simplefunction names, e.g.,NN. It indicatesthat thedevel-
opers should choose unique names to avoid the conflicts.
4.2.3 VariableValueConflicts. We detected81,212 variablevalue
conflictsacross27,199websites.Interestingly,wedetected10,733
(13.22%)cookie-relatedvariablevalueconflicts,asshownin Table6.
Cross-organizationandIntra-organizationConflicts. Wede-
tected18,551(22.84%)cross-organizationvariablevalueconflicts,
44ESEC/FSE ’20, November8–13,2020,VirtualEvent, USA Mingxue Zhang andWeiMeng
Table 6:Cookie value conflicts.
CategorySame Organization Diff Organization
#Conflict #Website #Conflict #Website
ValueModification 97 90 19 19
Addition 2,987 2,217 7,625 5,428
Deletion 5 4 0 0
and 8,582 (10.57%) of them were caused by third-party scripts
overwriting first-party variables. For example, ga.lwas modi-
fied from...437to...447by a third-party script on the web-
sitehttps://filmow.com/ .Meanwhile,wefound2,493(3.07%)cases
where a third-party defined variable was modified by first-party
scripts. We also found 49,550 (61.01%) value conflicts that were
causedbyscriptsofthesameorganization,andmostofthem(40,248
or49.56%)werecausedbyfirst-partyoverwritingfirst-partyvari-
ables. We thinktheseare the developmentchoices.
Conflictson Browser Internal Objects. Intotal,wefound228
casesthatmultiplescriptswrotetocookieswiththesamename.In
particular,116conflictscausedexistingcookievaluestobemodified,
astheconflictingscriptsassigneddifferentvaluestocookieswith
thesamename,pathanddomain,and19ofthemwerecausedby
scripts from different organization. One example is on the website
https://www.betfair.it/ ,whereathird-partyscriptfrom ie1-sscbf.
cdnppb.net overwrote the value of cookie bfsdfrom...39065 to
...41129. In this example, the cookie value was originally defined
by a first-party script. We believe this is a privilege abuse. We also
found97casesthatcookievaluesweremodifiedbyscriptsofthe
sameorganization. Although it shall be legitimatefora first-party
script to modify a cookie, we think third-party scripts shall not
modify cookies whichallbelong to the firstpartysite.
Moreover,wedetected5casesthatscriptsremovedanexisting
cookiebysettingtheexpiretimetoapastone.Oneexamplewas
found on website https://www.proporta.com/ , where a third-party
script removed an existing cookie "_gcl_au" that was originally
defined by another third-party script from googletagmanager.com .
We believe the above example is legitimate as Civic Computing
providesaserviceforcookiecomplianceunderGDPR[ 4].However,
removing an existing cookie may usually cause the server-side
program to malfunction.
Inadditiontodocument.cookie ,wealsofound52variablevalue
conflictsonotherinternalobjectproperties,and7ofthemarecross-
organizationconflicts.Oneexamplewasfoundonwebsite http://
popcornnowis.blogspot.com/ , where a third-party script overwrote
window.name defined by another third-party script loaded from a
differentdomain.
BooleanValueConflicts. Wealsodetected1,258booleanvalue
conflicts onglobal identifiers, which were usedto control the pro-
gram behavior. For instance, on website https://olxliban.com , a
first-partyscript defined avariable _adblock astrue, then athird-
party script https://olxbstatic-a.akamaihd.net/.../advertising.js?...
modified it tofalse. This variable was used to represent the ex-
istence of an ad blocker. In the case it is false, an advertising
scriptfrom doubleclick.net wouldbeincluded.However,thiscan
be abused by other third-party scripts. For example, a script can
always set_adblock to true to prevent the injection of ads from
Google DoubleClick andto injectits ownadsinstead.1window.uiOverlay=function(l) {
2if(document.readyState in {complete: 1,loaded: 1}) {
3require(["trjs!overlays/uiOverlay" ],function(e) {e.apply(
null,i); })
4}
5else{
6document.addEventListener ("DOMContentLoaded" ,function() {
...uiOverlay.apply(null,e); })
7}
8}
Listing 1:Original definition ofwindow.uiOverlay().
It reveals that because of variable value conflicts, the control
flow of JavaScript code and the appearance of the embedding page
could also be influenced. Although HTML elements can be directly
modified using JavaScript, it is much more difficult to reason about
the indirectmodificationcausedbyglobalidentifier conflicts.
Summary. Wedetected81,212variablevalueconflictsonover
27Kwebsites.116conflictscausedanexistingcookietobemodi-
fied.Also,27conflictswerecausedbythird-partyscriptsover-
writing internal object properties. We believe they are privilege
abuse. Some first-party defined boolean values were modified
bythird-partyscripts,resultingindifferentexecutionpathsof
the first-party program. The findings demonstrate thatvariable
valueconflictscould changeprogram behaviors.
4.3 Conflicting Scripts
We characterize the global identifier conflicts based on the conflict-
ingscripts, withafocusonthe cross-organizationconflicts.
4.3.1 FunctionDefinitionConflicts. Wedetected961uniquescripts
redefining a function of another script from a different organiza-
tion. As shown in Table 7, the top script doczy_full-1570133213.
min.jsredefined 125 third-party functions on the website https:
//modeloinicial.com.br/ ,whichincludedaduplicatescriptfroma
third-partyCDNhost cdn.plune.com .Thesituationsforothertop
scripts were similar. Even though the conflicting function defini-
tions were identical, including the same code for multiple times
could result inundesiredeffectsandshould be avoided.
The most prevalent scripts causing function definition conflicts
are listed in Table 8. Similar to the top script aksb.min.js that
we had discussed in ğ4.2, the script containr.js redefinedwindow.
mpfContainr() ,whichwasoriginallyaverysimplefunctiondefined
by the first party. In contrast, the scripts from exoclick.com and
wololo.net containedduplicatedefinitionoffunctions,whichhad
beendefinedbyfirst-partyscripts.Furtherinvestigationshowsthat
on some websites ( e.g.,https://www.stileproject.com ), the script
fromexoclick.com was indirectly included by other third-party
scripts, and it contained identical code as the script it overwrote.
Wethinkthattheseconflictingscriptswereoperatedunderdifferent
domain names but might actually belong to the same organization,
andthe conflictswere causedbyunexpectedduplicateinclusion.
In contrast, the script from static.tacdn.com indeed changed the
definitionoffunction window.uiOverlay() on23websitesthatall
came from tripadvisor.com . We think static.tacdn.com might be
a CDN host of TripAdvisor. However, as shown in Listing 1 and
Listing 2, theredefined functiondoes notwaituntil theDOMhas
been fully loaded before proceeding. Such a conflict could cause
different behaviors on the embedding page and should be avoided.
45DetectingandUnderstandingJavaScript GlobalIdentifier Conflicts onthe Web ESEC/FSE ’20, November8–13,2020,VirtualEvent, USA
1window.uiOverlay=function() {
2require(["overlays/uiOverlay" ],function(e) {e.apply(null,t
) });
3}
Listing 2:Redefinition ofwindow.uiOverlay().
Table 7:Topscriptsoverwriting globalidentifiers.
ConflictScript URL#Conflict
Category Targets
https://modeloinicial.com.br/js/doczy_full-...min.js 125
Function https://www.tcm.com/js/ads/cnn_adspaces.js 44
Definition https://analytics-eu.clickdimensions.com/forms.js?_=... 41
https://tmui2k8.fs.ml.bac-assets.com/sve/js/v4/ms/Microsoft_4.0_min...js? 31
http://cdn-5.wololo.net/wagic/wp-content/cache/minify/ae569.default... 20
http://www.acolyer.org/ 13
Variable https://www.engineersgarage.com/ 10
Type https://www.massdevice.com/ 10
https://www.asce.org/ 10
https://harpers.org/ 10
http://cr.acecounter.com/Web/AceCounter_AW.js?gc=BH3A414... 44
Variable http://cr.acecounter.com/Web/AceCounter_AW.js?gc=AS4A405... 41
Value http://sas.nsm-corp.com/sa-w.js?gc=... 40
https://www.informationweek.com/Default.asp 16
http://ads.bumq.com/ad_show2.js 12
4.3.2 Variable Type Conflicts. We detected 577 scripts causing
cross-organizationtypeconflicts.Thetopfivescriptsarealsolisted
inTable 7. Four of them are first-party inline scripts that redefined
variablesaj_adspot ,aj_zoneandaj_server ,etc.,fromundefined
toacertainvalue.Thesevariableswereoriginallydefinedbythe
third-partyscripts,andwereeventuallyusedtodeterminethead-
vertisements to inject. This indicates that by overwriting certain
customvariables,ałmaliciousžscriptcouldindirectlycontrolim-
portantDOMelements, e.g.,ads,that are shownto the visitors.
Thenoticeablescript https://blogroll/livedoor.net/js/blogroll.js
inTable8modifiedvariable blogroll_channel_id fromanumber
toundefined on 63 websites, after using it as the ID of an injected
<div>element. This reveals that variables could be modified by
otherscripts toundefined ,causing exceptions when referenced.
4.3.3 VariableValueConflicts. Intotal,wedetected7,419unique
scriptsmodifyingthevalueofvariables defined inscriptsofother
organizations. The most commonly included script came from
facebook.net .Itwasdetectedtomodifythevalueof fbq.version
from"2.0"to"2.9.4"on2,541websites. fbq.version wasinitially
defined by the first party scripts, and was used to determine the
versionofafacebookscriptincludedontheembeddingwebsites.In
thiscase,webelievethefirst-partydevelopersintentionallyallowed
fbevents.js to updatethe versionnumber.
In addition, three of the top scripts were third-party scripts that
addednewcookievalues.Similarly,threeofthetopprevalentscripts
modifiedthevalueofcookiesonhundredsofwebsites.Forinstance,
thescriptfrom cr.acecounter.com addedanewcookie "ACEFCID" ,
whosevaluewasusedbythefirst-partywebsitetodeterminethe
source URL of an image on that page. This suggests that cookies
arecommonwritetargetsofdifferentscriptsanditisriskytoallow
third-partyscripts to setthe cookies ofafirst-partywebsite.
4.4 CaseStudies
In this section, we discuss several interesting conflicts detected by
JSObserver to further demonstratethe potentialrisks.
OverwritingFunctionstoModifyDOMContent. Wedetected
functiondefinitionconflictsthatcouldcausemodificationsofDOM
elements.Forexample,onthewebsite https://dre.pt/ ,thefirst-partyTable 8:Topprevalent conflictingscripts.
ConflictScript URL #WebsiteCategory
https://ds-aksb-a.akamaihd.net/aksb.min.js 111
Function https://cdn.mookie1.com/containr.js 47
Definition https://ads.exoclick.com/ads.js 32
https://static.tacdn.com/js3/build/concat/short_lived_global-c-...js 23
https://cdn-gae-ssl-default.akamaized.net/js/isp.v.2.0.1.min.js?v=... 23
https://blogroll.livedoor.net/js/blogroll.js 62
Variable https://ads.exoclick.com/ads.js 38
Type https://s-pt.ppstatic.pl/o/js/osnowa.js?... 22
https://ads.exosrv.com/ads.js 16
http://1.citynews.stgy.ovh/shared/scripts/3rdp-censor/fab.js 14
https://connect.facebook.net/en_US/fbevents.js 2,541
Variable https://sb.scorecardresearch.com/beacon.js 1,473
Value https://top-fwz1.mail.ru/js/code.js 596
https://ssl.google-analytics.com/ga.js 260
https://secure.quantserve.com/quant.js 243
1function addHTML () {
2var html="...<img ...src=\"https://dre.pt/.../logo-portal.
png\" ...> ";
3if(isMobile.Android()){
4html+="<div ...><a href=\"...\" ...></a>Aceder</div>" ;
5}
6else if(isMobile.iOS()) {
7html+="<div ...><a href=\"...\" ...></a>Aceder</div>" ;
8}
9... ...
10document.body.innerHTML+=html;
11}
Listing 3: First-party definition of addHTML() on
https://dre.pt/.
1function addHTML () {
2var html="...<img ...src=\"https://dkq729jo4daj5.cloudfront
.net/.../logo-portal.png\" ...> " ;
3html+="<div ...> <a href=\"\" ...></a> Aceder </div>" ;
4... ...
5document.body.innerHTML+=html;
6}
Listing 4:Third-partyredefinition ofaddHTML().
definition ofaddHTML() was overwritten by a third-party script
fromcloudfront.net . As shown in Listing 3 andListing 4, the third-
party script redefined the function to insert a different image and a
different<div>element into the embedding website. We believe
thattheseconflictsshouldbeavoidedbecauseunexpectedelements
mightbe includedonthe embedding page.
RedefiningCryptographyFunctions. Wealsofoundcaseswhere
criticalcryptographyfunctionsweredefinedbymultiplescripts.For
example,thewebsite https://www.clublexus.com/ contained dupli-
catedefinitionsofseveralcryptographyfunctions, e.g.,b64_hmac_md5
(),binl2b64() andcore_hmac_md5() ,etc.Our inspection shows
thatthis website included two scripts that contain identical defini-
tionsofthesefunctions.However,athird-partyscriptcanmodify
core_hmac_md5() to generate fake message authentication code
(MAC)to breakdata integrity.
Conflicting AdsensePublisher IDs. Interestingly,wedetected
on several websites that first-party inline scripts wrote different
AdsensepublisherIDs.Forexample,onthewebsite https://www.ac-
illust.com/ , the developer’s scripts wrote two different values ca
-pub-5938... andca-pub-6219... to the same global identifier
google_ad_client . It is used as a unique identifier of a publisher’s
Adsense account to distribute the advertising revenues. In this
case, we believe that first-party developers may have two different
46ESEC/FSE ’20, November8–13,2020,VirtualEvent, USA Mingxue Zhang andWeiMeng
Figure1:Rankdistributionofwebsitescontainingconflicts.
Adsenseaccounts.However,amaliciousscriptcouldstealtheadver-
tisingrevenuesbysimplyreplacingthevalueof google_ad_client
withher/his ownpublisherID.
4.5 AffectedWebsites andReason ofConflicts
4.5.1 AffectedWebsites. Wedividetheaffectedwebsitesinto1,000
groups according to their ranks and calculate the rank distribution,
whichisdepictedin Figure1.Asisshown,websitesinallgroups
were affected by global identifier conflicts. Additionally, the con-
flicts caused by scripts from both first-party and third-party are
uniformly distributed.
In particular, we detected conflicts on some top ranked web-
sites.Oneofthetopaffectedwebsitesis https://www.amazon.com/ .
It included two scripts that assigned different callback functions
totheoneventhandler window.onerror usingwindow.onerror =
function(){...}, which would directly replace any existing event
handler [ 20]. The second script therefore redefined the way how
runtime JavaScript errors were handled on Amazon. Our inspec-
tion shows that the two scripts were both first-party inline scripts,
andtheseconddefinitionactuallycallstheoriginaleventhandler.
We believe that this is an implementation error. The developer
could haveused window.addEventListener("error", function()
{...})toavoidreplacingallexistingeventhandlers.Anotherex-
ample ishttp://babytree.com/ , whose Alexa ranking was 79. The
value of a global variable adefined by a first-party script was mod-
ified from an object to a string by another first-party script from
the same domain. We consider this as a bad coding practice, which
mightresult from the use ofsimplevariable names.
Ourstudyindicatesthatallwebsites,includingthetopranked
ones, are subjectto JavaScript globalidentifier conflicts.
4.5.2 PossibleCauseofConflicts. Wederivedthedistributionof
cross-organization conflicts regarding the length of conflict targets.
As shown in Figure 2, for all categories of conflicts, shorter conflict
targetsweremuchmorelikelytobeoverwrittenbyotherscripts.In
particular, 318 (11.53%)functiondefinitions conflicts,378(31.61%)
variable type conflicts and 3,103 (16.73%) variable type conflicts
weredetectedonvariables/functionswhosenamescontainnomore
than 6 characters. The top redefined identifiers include _tmr,_hsq,
anda,etc.This suggests the use of short and common names is
Figure 2: Conflict distribution regarding conflict targets
length.
Table 9:Slowdownon PageLoadingTime.
Round Average(X) Max(X) #IncompleteLoading
1 10.84 192.48 2
2 11.58 194.78 6
3 10.45 213.62 4
one possible cause of global identifier conflicts, and the developers
should assignlonger andunique names to avoid the conflicts.
Asdiscussedin ğ4.2andğ4.3,duplicatescriptinclusionisanother
cause of function definition conflicts, and is actually not rare (it
caused 16.92% of function definition conflicts). Web developers
should be careful when including scripts, as duplicate inclusions
could cause undesiredeffects.
4.6 Performance of JSObserver
Wemeasuretheslowdownonpageloadingtimetoevaluatetheper-
formanceoverheadincurredby JSObserver .Specifically,weuseda
VanillaChromiumbrowserandtheprototypeof JSObserver tovisit
theAlexatop100websitesseparately,waitedforatmost5minutes
beforeclosingthebrowser,andcalculatedtheaveragepageloading
timeandtheaverageslowdowninthreerounds.Theexperiment
resultsare shownin Table9. Asshown, JSObserver incursan av-
erage slowdown of 10.96X, and the maximum slowdown is around
200Xonhttps://www.youtube.com ,whichincluded35scripts.This
showsthat JSObserver incursloweroverheadcomparedwithsim-
ilar tools, e.g., Jalangi [ 33]. However, we also observed that several
pages did not finish loading within 5 minutes. The reason is we
injectedmultipleinstructionsforeachsimplewritetoamemory
location. We willfurther discuss in ğ5.
5 DISCUSSION
We discuss the limitations of our current work, the possible mitiga-
tionofthe identifier conflictthreat,andour future work.
Overhead and Coverage. JSObserver introduces high perfor-
mance overhead as it injects several instructions for each write
toamemorylocation.Therefore,manywebsitescouldnotfinish
loadingwithin2minutesinourexperiment.Ourgoalwasnotto
detect allpossibleconflicts inreal time.Instead,we triedto detect
asmanyaswecould.Indeed,wewerestillabletogathermanylogs
47DetectingandUnderstandingJavaScript GlobalIdentifier Conflicts onthe Web ESEC/FSE ’20, November8–13,2020,VirtualEvent, USA
generatedwithinthetimeoutandrevealtheglobalidentifiercon-
flictproblemintherealworld.Weplantooptimizetheperformance
ofJSObserver to improve the efficiency ofdata collection.
FalseNegatives. Ourconflictdetectionalgorithmisprecisebut
not sound. During data collection, we did not trigger any UI event.
Therefore, all the detected conflicts occur during normal page load,
andtheremightbefalsenegativeswhentheconflictscanonlybe
triggeredbyspecificsequenceofUIevents.Nevertheless,wedid
not aim to detect all the potential identifier conflicts. We leave it as
afutureworktoexplorethetriggerconditionsofconflictsonthe
web.
Script Isolation. A script can access and overwrite the global
identifiers in another script due to the fact that all the scripts in-
cludedinthesameframesharethesameglobalnamespace.This
indicatesthattheglobalidentifierconflictproblemcanbesolved
by isolating the scripts that write to the same memory location.
Therefore, we can leverageexisting browser isolation mechanism
toisolatedifferentJavaScriptcodeinseparateexecutionenviron-
ments. However, this may introduce a significantly high overhead
at run time and break the functionality of code that depends on
eachother.We leave itas our future work.
AvoidingCommon Identifiers. Ouranalysisshowsthatmany
scriptsusedsimpleorpopularidentifier names, e.g.,i,getCookie ,
etc., which is another cause of conflicts. Therefore, the problem
might also be mitigated by ensuring that the same identifier is
not used by multiple scripts. For example, we can statically or
dynamically instrument JavaScript code by appending different
random strings to the identifiers in different scripts. We plan to
implement andevaluate such amechanisminthe future.
6 RELATED WORK
JavaScript Conflict Analysis. Patraet al.[25] proposed Con-
flictJS,anautomatedapproachtoanalyzingtheconflictsbetween
JavaScriptlibraries.However,theystudiedonlyalimitednumberof
JavaScript libraries in a synthetic environment. In real world appli-
cations, there could be more than two JavaScript libraries. Further,
ConflictJSis built on top of Jalangi,whichisa dynamicJavaScript
analysisframeworkbasedonselectiverecord-replaytechnique[ 33].
Therefore,theyarenotabletodetecttheconflictsindynamically
loaded code. In contrast, JSObserver is able to detect the conflicts
betweenanyscripts,includingthosethataredynamicallyloaded.
Zhanget al.[36] also detected JavaScriptidentifierconflictsby in-
strumenting the Chromium browser. Nevertheless, they covered
only an incompletesetofJavaScript features.
JavaScriptTypeInference. Pradeletal.[26]proposedTypeDevil
to detectidentifiersthathaveinconsistenttypes.Jensen et al.[15]
proposed a static analysis framework for JavaScript and imple-
mented an analysis prototype on top of [ 24]. Hackett et al.[11]
presentedahybridtypeinferenceapproachforJavaScriptbasedon
points-to analysis. These works focus on inferring JavaScript type
information within a single script. However, our dynamic analysis
frameworkaimstodetectthetypeinconsistencyofglobalidenti-
fiersacrossdifferentscripts.Meanwhile,therehavebeenseveral
learning-based approaches to predicting the type for JavaScript
code [12,19,28]. They aimed to statically infer about a variabletypeandthereforeenablethegenerationofmuchfastercode,which
is orthogonal to our work. In our work, we leverage the JavaScript
built-intype checker to inferthe type of avariable at run time.
Cross-domainScriptInclusion. YueandWang[ 35]studiedsev-
eral insecure practices regarding JavaScript, including duplicate
inclusion. Ratanaworabhan et al.[27] and Richards et al.[31] an-
alyzed the behavior of popular JavaScript libraries. Richards et
al.[30] focused on the security risks imposed by the use of eval().
Nikiforakis etal.[23]analyzedscriptinclusionsonAlexatop10K
websitesandrevealedfourvulnerabilitiesthatcouldbeexploitedto
attackpopularwebsites.Lauinger etal.[17]showedmanywebsites
includedoutdatedorvulnerablelibraries,andpopularlibraries( e.g.,
jQuery)couldbeincludedformultipletimes.Inthiswork,wefocus
onthe globalidentifierconflictsratherthanthetrustrelationship
between scripts. Except forfunction definitionconflicts thatcould
result from duplicate inclusions, JSObserver can also detect other
categoriesofconflicts.
DynamicAnalysisofJavaScript. Manystaticanalysisapproaches
(e.g.,[1ś3])failtoreasonabouttheruntimebehaviorsofJavaScript
code. Therefore, prior works have studied the dynamicanalysis of
JavaScript.Gong etal.[10]proposedDLinttodynamicallydetect
the violations of several coding quality rules at run time. In [ 8],
theauthorscombinedstaticanddynamicanalysistodetectsuspi-
cious JavaScript code, e.g., unusually long functions. In contrast,
our analysis focuses on statement-level conflicts, especially the
conflicting writes to memory locations in different scripts. In [ 16],
the authors allowed forced execution of JavaScript code to explore
all the possible paths and revealed malicious behaviors. Other anal-
ysis includes data race detection [ 14,22,29], determinacy analy-
sis [32], JavaScript performance profiling [ 9], concurrency error
detection[ 13]and crashpathcomputation[ 18].These techniques
are orthogonal to JSObserver , which focuseson JavaScript global
identifier conflicts.
7 CONCLUSION
We have investigated a form of JavaScript code integrity problemÐ
theJavaScriptglobalidentifierconflictproblemontheWeb,withan
analysisframeworkdevelopedbasedontheChromiumbrowser.We
collected data from the main pages of the Alexa top 100K websites
and detected three categories of conflicts. We demonstrated that
many websites were affected by identifier conflicts. In particular,
we detected 145,918 conflicts on 31,615 popular websites. It is even
alarmingthatthird-partyscriptscouldcompromisetheintegrityof
first-partycodeandcookiesbecauseoftheprivilegeofaccessing
the same global namespace. Our research shows that JavaScript
globalidentifierconflictisanemergingthreattoboththewebusers
and the integrity of web applications, and highlights the need to
isolate JavaScript code from differentorganizations.
ACKNOWLEDGMENT
The workdescribed in thispaper waspartly supported by a grant
from the Research Grants Council of the Hong Kong Special Ad-
ministrative Region,China (CUHK24209418).
48ESEC/FSE ’20, November8–13,2020,VirtualEvent, USA Mingxue Zhang andWeiMeng
REFERENCES
[1]2015. The Closure Linter enforces the guidelines set by Google. https://code.
google.com/p/closure-linter/ .
[2] 2018. JSLint. http://www.jslint.com/.
[3] 2019. ESLint. http://eslint.org/ .
[4]2020. Cookie Control by Civic - GDPR Cookie Compliance Solution. https:
//www.civicuk.com/cookie-control .
[5]StefanoCalzavara,AlviseRabitti,andMicheleBugliesi.2016. Contentsecurity
problems? evaluating the effectiveness of content security policy in the wild.
InProceedings of the 23rd ACM Conference on Computer and Communications
Security(CCS) . Vienna, Austria.
[6]StefanoCalzavara,AlviseRabitti,andMicheleBugliesi.2018. Semantics-based
analysisofcontentsecuritypolicydeployment. ACMTransactionsontheWeb
(TWEB)12,2 (2018), 1ś36.
[7]Facebook.2019. LikeButtonfortheWeb. https://developers.facebook.com/docs/
plugins/like-button .
[8]AminMilaniFardandAliMesbah.2013. Jsnose:Detectingjavascriptcodesmells.
In2013IEEE13thInternationalWorking Conferenceon Source CodeAnalysis and
Manipulation (SCAM) . IEEE,116ś125.
[9]Liang Gong, Michael Pradel, and Koushik Sen. 2015. JITProf: pinpointing JIT-
unfriendlyJavaScriptcode.In Proceedingsofthe10thACMJointEuropeanSoftware
EngineeringConferenceandSymposiumontheFoundationsofSoftwareEngineering
(ESEC/FSE) . Bergamo, Italy.
[10]Liang Gong, Michael Pradel, Manu Sridharan, and Koushik Sen. 2015. DLint:
dynamicallycheckingbadcodingpracticesinJavaScript.In Proceedingsofthe
24thInternationalSymposiumonSoftwareTestingandAnalysis(ISSTA) .Baltimore,
MD.
[11]Brian Hackett and Shu-yu Guo. 2012. Fast and precise hybrid type inference for
JavaScript. ACMSIGPLAN Notices 47,6 (2012), 239ś250.
[12]VincentJHellendoorn,ChristianBird,EarlTBarr,andMiltiadisAllamanis.2018.
Deep learning type inference. In Proceedings of the 26th ACM Joint European
SoftwareEngineeringConferenceandSymposiumontheFoundationsofSoftware
Engineering (ESEC/FSE) . LakeBuena Vista,FL.
[13]ShinHong,YongbaePark,andMoonzooKim.2014. Detectingconcurrencyerrors
in client-side java script web applications. In 2014 IEEE Seventh International
Conference onSoftwareTesting,Verification and Validation . IEEE,61ś70.
[14]Casper S Jensen, Anders Mùller, Veselin Raychev, Dimitar Dimitrov, and Martin
Vechev. 2015. Stateless model checking of event-driven applications. ACM
SIGPLAN Notices 50,10(2015), 57ś73.
[15]SimonHolmJensen,AndersMùller,andPeterThiemann.2009. Typeanalysis
for JavaScript.In InternationalStatic AnalysisSymposium . Springer, 238ś255.
[16]Kyungtae Kim, I Luk Kim, Chung Hwan Kim, Yonghwi Kwon, Yunhui Zheng,
XiangyuZhang,andDongyanXu.2017.J-force:Forcedexecutiononjavascript.In
Proceedings of the 26th international conference on World Wide Web . International
WorldWideWeb Conferences Steering Committee, 897ś906.
[17]TobiasLauinger,AbdelberiChaabane,SajjadArshad,WilliamRobertson,Christo
Wilson, and Engin Kirda. 2018. Thou shalt not depend on me: Analysing the
useofoutdatedjavascriptlibrariesontheweb. arXivpreprintarXiv:1811.00918
(2018).
[18]Magnus Madsen, Frank Tip, Esben Andreasen, Koushik Sen, and Anders Mùller.
2016. Feedback-directedinstrumentationfordeployedJavaScriptapplications.InProceedingsofthe38thInternationalConferenceonSoftwareEngineering(ICSE) .
Austin,TX.
[19]Rabee SohailMalik, Jibesh Patra,andMichael Pradel. 2019. NL2Type:inferring
JavaScriptfunctiontypesfromnaturallanguageinformation.In Proceedingsofthe
41st International Conference on Software Engineering (ICSE) . Montréal, Canada.
[20]MDN web docs. 2019. DOM onevent handlers. https://developer.mozilla.org/en-
US/docs/Web/Guide/Events/Event_handlers .
[21]Mozilla. 2016. Subresource Integrity. https://developer.mozilla.org/en-US/docs/
Web/Security/Subresource_Integrity .
[22]ErdalMutlu,SerdarTasiran,andBenjaminLivshits.2015. DetectingJavaScript
races that matter. In Proceedings of the 2015 10th Joint Meeting on Foundations of
SoftwareEngineering . ACM,381ś392.
[23]Nick Nikiforakis, Luca Invernizzi, Alexandros Kapravelos, Steven Van Acker,
Wouter Joosen, Christopher Kruegel, Frank Piessens, and Giovanni Vigna. 2012.
You are what you include: large-scale evaluation of remote javascript inclusions.
InProceedings of the 19th ACM Conference on Computer and Communications
Security(CCS) . Raleigh,NC.
[24]NorrisBoydetal.2019.Rhino:JavaScriptforJava. http://www.mozilla.org/rhino/ .
[25]Jibesh Patra, Pooja N Dixit, and Michael Pradel. 2018. Conflictjs: finding and
understandingconflictsbetweenjavascriptlibraries.In Proceedingsofthe40th
InternationalConference onSoftwareEngineering (ICSE) . Gothenburg,Sweden.
[26]Michael Pradel, Parker Schuh, and Koushik Sen. 2015. TypeDevil: Dynamic type
inconsistency analysis for JavaScript. In Proceedings of the 37th International
Conference onSoftwareEngineering (ICSE) . Florence, Italy.
[27]Paruj Ratanaworabhan, Benjamin Livshits, and Benjamin G Zorn. 2010. JSMeter:
Comparing the Behavior of JavaScript Benchmarks with Real Web Applications.
WebApps 10(2010), 3ś3.
[28]Veselin Raychev, Martin Vechev, and Andreas Krause. 2015. Predicting program
propertiesfrom bigcode. In ACMSIGPLAN Notices , Vol. 50.ACM,111ś124.
[29]Veselin Raychev, Martin Vechev, and Manu Sridharan. 2013. Effective race detec-
tionforevent-drivenprograms.In ACMSIGPLANNotices ,Vol.48.ACM,151ś166.
[30]GregorRichards,ChristianHammer,Brian Burg,and JanVitek.2011. Theeval
thatmendo.In EuropeanConference onObject-OrientedProgramming .Springer,
52ś78.
[31]Gregor Richards, Sylvain Lebresne, Brian Burg, and Jan Vitek. 2010. An analysis
of the dynamic behavior of JavaScript programs. In ACM Sigplan Notices , Vol. 45.
ACM,1ś12.
[32]Max Schäfer, Manu Sridharan, Julian Dolby, and Frank Tip. 2013. Dynamic
determinacyanalysis. In Acm Sigplan Notices , Vol. 48.ACM,165ś174.
[33]Koushik Sen, Swaroop Kalasapur, Tasneem Brutch, and Simon Gibbs. 2013.
Jalangi:aselectiverecord-replayanddynamicanalysisframeworkforJavaScript.
InProceedings of the 18th European Software Engineering Conference (ESEC) / 21st
ACMSIGSOFTSymposiumontheFoundationsofSoftwareEngineering(FSE) .Saint
Petersburg,Russia.
[34] W3C. 2018. Content SecurityPolicyLevel 3. https://www.w3.org/TR/CSP3/ .
[35]ChuanYueandHainingWang.2013. Ameasurementstudyofinsecurejavascript
practices onthe web. ACMTransactions onthe Web (TWEB) 7,2 (2013), 7.
[36]MingxueZhang,WeiMeng,andYiWang.2019. Poster:FindingJavaScriptName
Conflicts on the Web. In Proceedings of the 26th ACM Conference on Computer
and Communications Security(CCS) . London,UK.
49