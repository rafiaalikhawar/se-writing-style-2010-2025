‚ÄúDo this! Do that!, And nothing will happen‚Äù
Do speciÔ¨Åcations lead to securely stored passwords?
Joseph Hallett, Nikhil Patnaik, Benjamin Shreeve and Awais Rashid
University of Bristol
Abstract ‚ÄîDoes the act of writing a speciÔ¨Åcation (how the code
should behave) for a piece of security sensitive code lead to
developers producing more secure code? We asked 138 developers
to write a snippet of code to store a password: Half of them
were asked to write down a speciÔ¨Åcation of how the code
should behave before writing the program, the other half were
asked to write the code but without being prompted to write a
speciÔ¨Åcation Ô¨Årst. We Ô¨Ånd that explicitly prompting developers to
write a speciÔ¨Åcation has a small positive effect on the security of
password storage approaches implemented. However, developers
often fail to store passwords securely, despite claiming to be
conÔ¨Ådent and knowledgeable in their approaches, and despite
considering an appropriate range of threats. We Ô¨Ånd a need for
developer-centered usable mechanisms for telling developers how
to store passwords: lists of what they must do are not working.
I. I NTRODUCTION
Developers struggle to store passwords securely. Naiak-
shina et al. have repeatedly shown that developers do not build
in security unless explicitly asked to do so (and even then
typically do so poorly) [3], [4], [5]. In organizations, one can
support developers coding securely through code review, and
acceptance testing‚Äîbut not all developers work in teams and
many work alone on their own projects [6], [7].
Developers continue to seek guidance on how to handle
passwords. In a survey of developers‚Äô posts on Stack OverÔ¨Çow
(a popular developer question and answer site) Barua et al.
found that posts related to authentication and security (in-
cluding password storage) and were one of the top 20 topics
on the site and accounted for 2.1% of all questions [8].
Furthermore in a survey of just security-focussed posts on
Stack OverÔ¨Çow, Yang et al. found that the most viewed
of all security-focussed posts related to passwords [9], with
each post viewed on average 2,731 times. Whilst there are
alternatives to passwords [10], many developers still appear
to be working with passwords and implementing password
storage in their apps and software. As well as working with
passwords they are seeking guidance on how to do it right .
It is well established that writing a speciÔ¨Åcation before
implementing it leads to code that is of a higher quality [11],
[12], [13], [14], [2], [15]. Since speciÔ¨Åcation writing is ben-
eÔ¨Åcial for quality , does the act of writing one also improve
developers‚Äô security practices? Naiakshina‚Äôs work suggests
that developers only consider security aspects if explicitly
prompted [5]; but if we try to continuously prompt developers
towork securely we risk security fatigue [16], [17]. Since
The quote in the title is attributed to Harry S. Truman [1], and is used as
the opening quote to chapter 6 in The Mythical Man-Month [2].speciÔ¨Åcation is an established developer practice, this paper
seeks to explore whether the act of writing any form of
speciÔ¨Åcation primes developers to program securely: in other
words whether giving developers time to make a plan (however
formally or informally) leads them to either recalling more
about how to store passwords, or to recall that a standard
exists and to check.
To test this we recruited 138 developers from an online
platform for recruiting participants for studies, and asked them
to write code to store a password in whatever language they
were most comfortable with. Half the developers were asked to
write down a speciÔ¨Åcation‚Äîany form of speciÔ¨Åcation from a
formal deÔ¨Ånition [18] to a prose description [19]‚Äîof how they
would implement this before they were allowed to write their
solution, the rest were allowed to write their implementation
immediately. We scored the security of their implementations
using Naiakshina‚Äôs end-user password storage criteria [3]
(Figure 1), which is itself based on NIST SP 800-63-3 [20],
and analyzed their written justiÔ¨Åcations of their choices and
threats considered.
SpeciÔ¨Åcally, we address the following research questions:
RQ1 Does speciÔ¨Åcation writing lead to a measurable improve-
ment in password storage method?
RQ2 What approaches do developers take when implement-
ing password storage and what do they typically remem-
ber and forget?
RQ3 How do developers justify their implementation ap-
proach and what threats do they consider?
Our key Ô¨Åndings are as follows:
Developers who were explicitly prompted to write a speci-
Ô¨Åcation, stored their passwords slightly more securely than
those who were not prompted ( p= 0:027,rrb= 0:209).
Only 38% of developers remembered to hash passwords,
14% remembered to salt them, but other secure password
storage practice was largely absent (Figure 1).
Developers think they are storing passwords correctly, but
their scores according to Naiakshina‚Äôs criteria (Figure 1) do
not indicate best practice.
If given time to reÔ¨Çect, some developers do realize that there
are threats to stored passwords and that their solutions may
not be secure.
Our novel insights are in examining whether speciÔ¨Åcation
is a useful tool for priming for security related tasks, and
how developers justify the code they write and the threats
they consider with respect to the speciÔ¨Åcations they write.
4862021 IEEE/ACM 43rd International Conference on Software Engineering (ICSE)
1558-1225/21/$31.00 ¬©2021 IEEE
DOI 10.1109/ICSE43902.2021.00053
The end-user password is salted (+1) and hashed (+1).
The derived length of the hash is at least 160 bits long
(+1).
The iteration count for key stretching is at least 1,000
(+0.5) or 10,000(+1) for PBKDF2 and at least 210for
bcrypt (+1).
A memory-hard hashing function is used (+1).
The salt value is generated randomly (+1).
The salt is at least 32 bits in length (+1).
Fig. 1. Naiakshina‚Äôs end-user password storage assessment criteria [3], copied
verbatim. A score6indicates industrial best practice.
Analyzing the developer‚Äôs rationale suggests that whilst some
developers consider appropriate threats, their knowledge of
best practice is out-of-date and that current cryptographic
guidelines [20]. Providing lists of what developers must do
is not working. Instead we must Ô¨Åt the task to the developer
and provide usable mechanisms for password storage.
II. B ACKGROUND AND RELATED WORK
A. BeneÔ¨Åts of speciÔ¨Åcation
The beneÔ¨Åts of program speciÔ¨Åcation are well established
in both the academic and engineering communities. Spolsky
notes their beneÔ¨Åt saying:
‚ÄúIf you don‚Äôt have a spec, you will always spend
more time and create lower quality code.‚Äù [13]
Brooks Jr. also notes the beneÔ¨Åt of a speciÔ¨Åcation:
‚ÄúCareful function deÔ¨Ånition, careful speciÔ¨Åcation,
and the disciplined exorcism of frills of function and
Ô¨Çights of technique all reduce the number of system
bugs that have to be found.‚Äù [2]
Dromey suggested that quality models and requirements spec-
iÔ¨Åcations could lead to an improvement in software qual-
ity [21]. Haigh and Landwehr have suggested that by build-
ing code to security speciÔ¨Åcations (drawing analogy to US
building codes ) we can reduce the vulnerability in software
systems [22], [23]. Polikarpova et al. found that twice as
many bugs were found when code was written with a strong
speciÔ¨Åcation [24]. Mohanani et al., however, found that speci-
Ô¨Åcations can lead to developers blindly following them without
considering why the rules exist [25]. Our work seeks to
demonstrate that the act of writing a speciÔ¨Åcation creates an
implicit priming effect that can impact a developer‚Äôs approach
to security.
B. Work on password security
There is a large body of work surrounding passwords, but a
small subset that addresses how developers perform password
storage and present analysis of the process. Password storage
is a feature generally supported by cryptographic libraries.
The usable security community has studied the developers‚Äô
interaction with the cryptographic APIs.
Naiakshina et al. ran the Ô¨Årst qualitative usability study
to observe how 20 computer science students address thetask of password storage [3]. They concluded that participants
consider functionality before security. Unless participants are
primed, they do not think the task of password storage requires
a secure solution. On the other hand, participants who were
primed to consider security used various hash functions and
different algorithms to secure their password. For the par-
ticipants who were primed, none of their solutions met the
academic standards of the time. Cryptographic frameworks
offer password storage as an opt-in feature. This means
the developers needs to understand cryptography to store
passwords. 10% of the non-primed participants attempted a
secure solution for password storage while 70% of the primed
participants attempted a secure solution. On asking the non-
primed students about the security oversight, they replied
that they would have implemented secure storage if they
were writing code for a commercial product. To address this
insight Naiakshina et al. conducted a Ô¨Åeld study with freelance
developers. Like students, freelance developers do not consider
security for password storage, unless prompted. Both students
and freelance developers have misconceptions about secure
password storage, however interestingly freelance develop-
ers show a wider range of these misconceptions. Freelance
developers often stored passwords with Base64, confusing
encoding functions with hash functions, a misconception they
shared with end-users. Naiakshina et al. conclude, that even
when developers believe they are coding for companies they
seldom store the password securely without prompting [5].
Acar et al. conducted an experiment with GitHub developers
to establish if they are an accurate representation of developers
in general for security-based developer studies. The GitHub
developers were asked to perform password storage securely.
The solutions included the storage of plain-text passwords,
use of static salts, use of unsafe hashing algorithms [26].
Our work goes beyond Acar et al.‚Äôs and Naiakshina et al.‚Äôs
work by examining developer‚Äôs rationale for their password
storage implementations and Ô¨Ånds that, whilst developers
aren‚Äôt storing passwords securely, they think they‚Äôre following
best practices.
Oesch et al. evaluated 13 popular password managers and
their solutions for handling the 3 main stages of a password‚Äôs
life-cycle; password generation, storage, and auto-Ô¨Åll. Their
evaluation of password storage showed that developers stored
information in plain-text, left metadata unencrypted, and used
insecure defaults [27]. Our work compliments this by diving
deeper into why developers do not engage with best practice.
There is a large body of work on end-user passwords and their
security [28], [29], [30], [31], [32], [33], [34], [35], [36]. In
contrast our work focuses on developer‚Äôs approaches to storing
passwords.
C. Work on secure programming
Weir et al. looked at the prevalence of security assurance
techniques (including threat assessment and code review)
among Android developers [37]. They found that between
only 22‚Äì30% of Android developers used these techniques
despite a high perceived need for security. We found that
48756% of developers claimed to write a speciÔ¨Åcation without
prompting. Fischer et al. examined the amount of code copied
from StackoverÔ¨Çow, and its security [38]. They found that
15% of Android apps contained vulnerable code copied from
StackoverÔ¨Çow. We found that 8% of developers copied from
StackoverÔ¨Çow speciÔ¨Åcally, but that a further 12% copied
from other online sources.
Many vulnerabilities arise due to developers misusing cryp-
tographic libraries. Nadi et al. performed an empirical in-
vestigation into challenges developers face when using Java
cryptographic APIs. Based on the analysis of 100 Stack
OverÔ¨Çow posts, 100 GitHub repositories and a survey of
48 developers, they found that developers Ô¨Ånd cryptographic
features such as encryption and digital signatures difÔ¨Åcult to
program. they also found that APIs are generally perceived to
be too low-level for developers [39].
Egele et al. studied the integration of cryptographic APIs
in Android applications. They found errors in 88% of the
applications. CryptoLint was introduced as a static analysis
tool to Ô¨Ånd these errors [40]. Patnaik et al. performed a the-
matic analysis of 2491 Stack OverÔ¨Çow posts from developers
seeking help with using 7 cryptographic libraries, and found
16 usability issues [41] that could be related to Green and
Smith‚Äôs earlier work that proposes usability principles for
cryptographic APIs. show that developers Ô¨Ånd cryptographic
APIs challenging to use. We Ô¨Ånd that as well as struggling
with APIs developers are not clear on what they need to do to
store passwords securely, following current guidelines [20].
III. M ETHOD
We used a between-subjects design to explore whether the
act of speciÔ¨Åcation writing results in more secure code being
produced.
A. Study Design
To test the effect speciÔ¨Åcation writing had on implementa-
tion we designed a study where developers would implement
the part of an app‚Äôs code for storing passwords. We chose pass-
word storage as a task as it is security relevant, implementable
within a relatively short space of time and is a common task
with plenty of guidance available that most developers would
have encountered in their work.
Our study was implemented as a set of online tasks and
questions (to capture rationale). Developers were randomly
assigned a grouping (either speciÔ¨Åcation orno-speciÔ¨Åcation )
and shown the following scenario:
You are working on the backend of an application. Users
create an account on the app, and login before being allowed
to use the program. The application is complete bar one
task: writing the login system users use to authenticate
with the app. You have been tasked with implementing this
part of the app. You decide to start with storing the users‚Äô
passwords. Your boss trusts your judgment when it comes
to implementing this feature.Developers in the speciÔ¨Åcation group were then asked to write
a speciÔ¨Åcation for how the password should be stored.
You decide to start by writing a speciÔ¨Åcation for how the
password should be stored, and to note down any special
requirements and implementation details. You are provided
with a username and password, and they have been checked
to see that they are valid text.
Describe your speciÔ¨Åcation below. You can describe your
speciÔ¨Åcation using formal notation, informal notes, a list,
mathematical notation or any other method. If you draw a
picture as part of your speciÔ¨Åcation, please say so and say
what is shown.
Both groups were then asked to implement the password
storage using whichever language they wished. If they used
a real programming language they were asked to note it.
You start writing the password storage method. You have
been given the password the user wishes to use and you
need to store it so that it can be checked whenever users try
and login. You are given a username and password. Both
have been checked to be valid text (i.e. neither empty nor
containing bad characters) Write code (or pseudocode) to
implement the password storage. Your code doesn‚Äôt need to
be compilable or syntactically correct but should illustrate
your general approach to the implementation.
Developers in the no-speciÔ¨Åcation group were then asked if
they had made some form of speciÔ¨Åcation or plan before
starting their implementation (without being asked to). Those
that indicated that they did, were asked to describe their
speciÔ¨Åcation and their results were added to those of the
speciÔ¨Åcation group. Both groups were then asked to provide
a rational for their coding approach in a free text box. They
were asked if they considered what threats might attack a
stored password , and, whether they referred to any standards
for password storage when implementing the code. Finally,
participants were asked whether they had any formal quali-
Ô¨Åcations in software engineering, or computer science; and,
to rate their knowledge of security and cryptography on a
5-point Likert scale,and brieÔ¨Çy describe their security and
development experience.
B. Analysis
To analyze the data we scored each of their implementations
using Naiakshina‚Äôs metric [3] and compared the average score
between different groups using the Mann Whitney Utest (a
rank-based non-parametric test to explore if two groups are
distinct [42]) to test for signiÔ¨Åcance and to calculate the effect
sizes (using the rank-biserial correlation [43]). To analyze
developer‚Äôs rationale and threat models we asked developers
to describe them and analyzed them qualitatively using a
grounded theory approach [44], [45].
C. Recruitment and Ethics
Developers were recruited from ProliÔ¨Åc Academic and were
screened, by ProliÔ¨Åc, based on their familiarity with computer
488programming. Developers were offered a Ô¨Ånancial reward for
completing the study of $5, inline with the living wage in our
country. All developers who completed the study were paid
for their work.
Ethical approval for the study was sought from and granted
by Bristol University. No personal data was collected, and
demographic data was deleted after coding and validation.
Data is available by request.
D. Limitations and Threats to Validity
We acknowledge the following limitations and threats to our
study:
Our developers were recruited by ProliÔ¨Åc Academic and
as such, may not be representative of how developers
as a whole behave. Other studies have also used similar
populations for studying passwords and developers [46],
[31], [47].
Developers may not know how to store a password, and may
not be aware that it is a security related task. We mitigate this
by qualitatively analyzing the developers‚Äô rationale behind
their code.
Developers who were not prompted to write a speciÔ¨Åcation,
may opt to write a speciÔ¨Åcation anyway. To correct for this
we asked developers not in the speciÔ¨Åcation group if they
wrote a speciÔ¨Åcation, after their implementation. We assume
that the speciÔ¨Åcation produced by the unprompted group is
similar to the prompted group (and we ask them to describe
it), but this may not be the case and some participants may
retrospectively write a speciÔ¨Åcation.
We ask the developers about their qualiÔ¨Åcations and expe-
rience, however all data is self-reported and may not be
accurate.
We asked developers to implement password storage and
99 developers (72%) did so. 19 developers (14%) instead
appeared to write code implementing password authentica-
tion (how one would check if a password was correct) but
from which their approach to password storage could be
seen. A further 15 developers (11%) stored the password,
but did so only checking if the password contained a suitable
range of letters, numbers and symbols, 3 (3%) approached
the problem by retransmitting their passwords over HTTP1,
and 1 insisted the passwords be stored alphabetically . We
include all in our analysis, as they were all conceivably ways
a developer may approach storing passwords.
Scoring implementations according to Naiakshina‚Äôs criteria
could introduce subjectivity. To mitigate this, one author
scored and then another author independently rescored all
the implementations and calculated Cohen‚Äôs Kappa (a mea-
sure of inter-rater reliability [48]). The kappa-value indicates
almost perfect agreement (= 0:94) [48]. Similarly, our
codebooks, whilst grounded in data, were likely inÔ¨Çuenced
by the coder‚Äôs background and experiences. Using our code-
books a separate coder independently re-coded the entire
1Three appeared to have copied the question from: https://stackoverÔ¨Çow.
com/questions/19999417/password-storage-in-code-how-to-make-it-safe.dataset. We found substantial agreement (= 0:72) with
our coding for developers‚Äô explanations for their implemen-
tations (Table VI) and almost perfect agreement (= 0:84)
with our coding for the threats developers considered.
We measure developers‚Äô password storage approaches using
Naiakshina‚Äôs criteria, but this poses a construct validity
threat. We chose this metric as it has been used in prior
work [3], [5], and on a NIST standard for password stor-
age [20]. We mitigate this threat by qualitatively analyzing
why developers wrote the code they did as well as their
implementations.
IV. Q UANTITATIVE RESULTS
Table III reports how the teams scored against Naiakshina‚Äôs
criteria (Figure 1). In our sample, only 53 developers (38%)
produced outputs that fulÔ¨Ålled at least one part of Naiakshina‚Äôs
criteria. The most common criterion fulÔ¨Ålled was that of
hashing data (demonstrated by 38% of participants who scored
a point, 14% of overall sample). Just under 20% of the
developers who scored a point used a random salt or an
appropriate hash length (7% overall); and the remainder of
the points in Naiakshina‚Äôs criteria were awarded rarely.
A. RQ1: Do speciÔ¨Åcations lead to securely stored passwords?
Developers prompted for a speciÔ¨Åcation ( n= 61 ) scored
better (= 1:03) than those that were unprompted ( n= 77 ,
= 0:47)‚Äîa comparison by Mann-Whitney Usuggests that
this is a signiÔ¨Åcant difference ( p= 0:024,U= 1947:5), but
with only a small effect size (rank-biserial coefÔ¨Åcient [43],
rrb= 0:171). There remains a signiÔ¨Åcant difference in
performance if we omit the subset of the unprompted group
who reported writing a speciÔ¨Åcation without being asked to‚Äî
prompted participants ( n= 61 ,= 1:03), in contrast to
developers who did not write a speciÔ¨Åcation ( n= 34 ,=
0:38). The two groups are distinct (Mann-Whitney U= 820 ,
p= 0:027) but the effect size remains small ( rrb= 0:209).
However, a comparison between all participants who wrote a
speciÔ¨Åcation, prompted or not, ( n= 104 ,= 0:83) and those
who did not write a speciÔ¨Åcation ( n= 34 ,= 0:38) is not
statistically signiÔ¨Åcant ( p= 0:061,U= 1495 ,rrb= 0:154).
This could be explained by developers in the unprompted
speciÔ¨Åcation group (those who were not asked to write a spec
but who claimed to have written one anyway) actually writing
their spec after their implementation in response to us asking
if they had written one beforehand. This theory is supported
by Table II where we found no signiÔ¨Åcant difference between
the unprompted speciÔ¨Åcation and the group that claimed not
to write a speciÔ¨Åcation ( p= 0:247).
The distribution of scores is given in Table I. 50‚Äì70% of
developers did not store a password in any meaningfully secure
way (a score of 0), and no developer obtained a perfect score
(of 7) using Naiakshina‚Äôs metric, although two developers
did meet the score indicating best practice (a score of 6;
both were in the prompted speciÔ¨Åcation group). Of the 77
developers whom we did not prompt to write a speciÔ¨Åcation
56% (43) claimed to write one anyway unprompted; 26% (36)
489TABLE I
DISTRIBUTION OF SCORES FOR PASSWORD STORAGE METHODS BY DIFFERENT GROUPS . ABSOLUTE VALUES ARE GIVEN IN (PARENTHESES ). T HE
SPECIFICATION GROUP CONSISTS OF TWO -SUBGROUPS :THOSE THAT WE EXPLICITLY PROMPTED FOR A SPECIFICATION ,AND THOSE THAT WE DID NOT
PROMPT BUT REPORTED WRITING ONE UNPROMPTED . A SCORE OF 6OR MORE IS CONSIDERED TO BE FOLLOWING BEST PRACTICE .
Group Count >0 0 1 2 3 4 5 6 7  
SpeciÔ¨Åcation 104 43 59% (61) 20% (21) 11% (11) 5% (5) 4% (4) 0 2% (2) 0 0.83 1.30
Prompted speciÔ¨Åcation 61 27 56% (34) 15% (9) 15% (9) 7% (4) 5% (3) 0 3% (2) 0 1.03 1.51
Unprompted speciÔ¨Åcation 43 16 63% (27) 28% (12) 5% (2) 2% (1) 2% (1) 0 0 0 0.53 0.88
Unprompted 77 26 66% (51) 25% (19) 6% (5) 1% (1) 1% (1) 0 0 0 0.47 0.79
No SpeciÔ¨Åcation 34 10 71% (24) 21% (7) 9% (3) 0 0 0 0 0 0.38 0.65
Used standard 36 16 56% (20) 19% (7) 11% (4) 8% (3) 3% (1) 0 3% (1) 0 0.94 1.41
No standard 102 37 64% (65) 21% (21) 10% (10) 2% (2) 3% (3) 0 1% (1) 0 0.64 1.10
Formally qualiÔ¨Åed 59 27 54% (32) 22% (13) 15% (9) 5% (3) 3% (2) 0 0 0 0.81 1.09
Not formally qualiÔ¨Åed 79 26 67% (53) 19% (15) 6% (5) 3% (2) 3% (2) 0 3% (2) 0 0.65 1.26
Overall 138 53 62% (85) 20% (28) 10% (14) 4% (5) 3% (4) 0 1% (2) 0 0.72 1.19
TABLE II
COMPARISON BETWEEN GROUPS USING THE MANN -WHITNEY UTEST .
Group 1 Group 2 U p r rb
Prompted SpeciÔ¨Åcation Unprompted 1948 0.024 0.171
SpeciÔ¨Åcation (all) No speciÔ¨Åcation 1495 0.061 0.154
Prompted speciÔ¨Åcation No speciÔ¨Åcation 820 0.027 0.209
Unprompted speciÔ¨Åcation No speciÔ¨Åcation 675 0.247 0.077
Used standard No standard 1638 0.135 0.108
Formal qualiÔ¨Åcation No qualiÔ¨Åcation 2018 0.061 0.134
TABLE III
FREQUENCY DIFFERENT POINTS IN NAIAKSHINA ‚ÄôS CRITERIA WERE
OBSERVED COMPARED TO THE WHOLE POPULATION . NO ANSWER SCORED
A HALF -POINT FOR KEY -STRETCHING . (A BSOLUTE VALUES ).
Criteria Observations
Hashed 38% (53)
Salted 14% (19)
Hash length 7% (9)
Key stretching 2% (3)
Memory-hard hashing 1% (1)
Random salt 7% (10)
Salt length 3% (4)
of developers reported referring to some kind of standard or
guide when writing their password storage method; 43% (59)
claimed some formal software engineering qualiÔ¨Åcation.
Finding: Examining the rank-biserial correlation ( rrb) to the
scores themselves in Table I, suggests that whilst forcing
developers to write a speciÔ¨Åcation before coding will lead
to more secure password storage approaches ( p= 0:024),
it isn‚Äôt going to make a huge difference‚Äîdevelopers might
remember to hash them or to add salt, but will still leave
them stored insecurely.
B. So what else has an effect?
If the act of forcing developers to write a speciÔ¨Åcation only
has a small impact on their ability to store passwords securely,
then do we Ô¨Ånd anything else having an effect?TABLE IV
CO-OCCURRENCES OF POINTS IN NAIAKSHINA ‚ÄôS CRITERIA (I.E. 36% OF
ALL PARTICIPANTS WHO HASHED THEIR PASSWORD ALSO SALTED THEIR
PASSWORDS ). (A BSOLUTE VALUES ).Hashed
Salted
Hash length
Key stretching
Memor y-hard
Random salt
Saltlength
Hashed36%
(19)17%
(9)6%
(3)2%
(1)19%
(10)8%
(4)
Salted100%
(19)26%
(5)11%
(2)0%
(0)53%
(10)21%
(4)
Hash length100%
(9)56%
(5)22%
(2)0%
(0)56%
(5)22%
(2)
Key stretching100%
(3)67%
(2)67%
(2)0%
(0)67%
(2)67%
(2)
Memory-hard100%
(1)0%
(0)0%
(0)0%
(0)0%
(0)0%
(0)
Random salt100%
(10)100%
(10)50%
(5)20%
(2)0%
(0)30%
(3)
Salt length100%
(4)100%
(4)50%
(2)50%
(2)0%
(0)75%
(3)
TABLE V
OBSERVATIONS OF SPECIFIC HASHING METHODS USED BY DEVELOPERS .
SOME DEVELOPERS RECOMMENDED MULTIPLE HASHING METHODS .
Hash Observations
Encryption 9
AES 1
MD5 6
SHA1 4
SHA256 7
SHA512 1
base64 3
Custom cipher 1
bcrypt 6
PBKDF2 4
Argon2 1
Insecure method 26
Secure method 11
490Participants reported their familiarity with cryptography
on a 5-point Likert scale. There is a small positive rela-
tionship between reported cryptography experience and score
(Spearmans Rho [49], s= 0:333,p= 0:00), with most
developers reporting that they had little to no experience
(107, 78%) ( No experience : 44 (32%), little experience : 63
(46%), moderate experience : 25 (18%), very experienced : 4
(3%), extremely experienced : 2 (1%)). This is in contrast to
the Ô¨Åndings of Hazhirpasand et al. who found no signiÔ¨Åcant
relationship between developer experience and their ability to
use a cryptography API [50]‚Äîthough Hazhirpasand et al. rated
developer experience on the basis of activity on GitHub, as
opposed to a self-reported value. We did not Ô¨Ånd a signiÔ¨Åcant
relationship between developers who had a formal software
engineering qualiÔ¨Åcation and those who did not ( p= 0:061).
Participants who reported using a standard to inform their code
implementation scored better than those who used no standard
but not signiÔ¨Åcantly ( p= 0:135).
C. RQ2: What did developers do?
Our observations of hashing and salting rates are broadly
inline with what Naiakshina et al. observed [3], where an
overall 35% (7
20) of developers hashed passwords and 25%
(5
20) also salted them‚Äîhowever Naiakshina et al.‚Äôs study
explicitly primed half of their developers (10
20) by asking them
to store them security, and only the primed groups hashed or
salted their passwords. In contrast, in our Ô¨Åndings we observe
similar rates over all participants.
In our study we asked developers to provide code in any
programming language, including pseudocode. Most devel-
opers described their implementation in these terms using
functions called hash and appending salts, however some
gave speciÔ¨Åc methods for storing their passwords. Table V
shows the speciÔ¨Åc methods we encountered for hashing pass-
words. Many developers recommended hash functions that
were inappropriate for password storage2‚Äîincluding MD5,
the SHA family, and a substitution cipher. Other developers
recommended encryption (which is unsuitable for password
storage [20]), or even using base64. Of all the developers who
stored their passwords hashed, 50% (26) used an inappropriate
hashing method [20], and only 21% (11) recommended a
secure modern password hash. One developer recommended
both a secure and insecure method:
...hash password in bcrypt or md5...
(scored 1)
Finding: Only a third of developers wrote code to store their
passwords hashed. 50% of those developers recommended
an insecure hash function, and only 21% recommended a
secure hash function. The remaining 29% did not specify
the method‚Äîthey just ‚Äòhashed‚Äô them. 14% of developers
remembered to salt and hash their passwords. More com-
prehensive security (Figure 1) was rare.
2They are quick to calculate using little memory, thus making them
amenable to cracking, unlike memory hard hashes such as PBKDF2.V. RQ3: W HY ARE DEVELOPERS STORING PASSWORDS
LIKE THIS ?
After implementing their solutions we asked developers why
they had used a particular approach. Two of the authors used
a grounded theory approach [44] to analyze the responses.
Two passes were required to reach the point of theoretical
saturation [45] when no new codes were identiÔ¨Åed. The
resulting codebook, and illustrative examples of each code, is
shown in Table VI. We also contrasted the distribution of codes
in the prompted speciÔ¨Åcation andno speciÔ¨Åcation groups and
found them to be broadly similar‚Äîwith the no speciÔ¨Åcation
group being slightly more likely to report they wrote their
code the way they did because the implementation was easy.
Consequently our remaining analysis of developers explores
why they implemented password storage in the way they did,
and is over the entire study group.
We also asked the developers if they considered any threats
when implementing their password storage solution? Threat
modeling is a standard technique when designing for secu-
rity [51] that encourages developers to consider what defenses
are needed to mitigate the potential threats to a system. 55%
(77) developers reported considering potential threats when
implementing their password storage solution. Their responses
were analyzed by one author, again using a grounded theory
approach [44]. Two passes were required to reach the point of
theoretical saturation [45] when no new codes were identiÔ¨Åed.
The resulting codebook, again with illustrative examples of
each code, is shown in Table VII.
A. You either think you do know, or you know you don‚Äôt know
Our analysis of the reasons why developers implemented
password storage in the ways they did reveal two interest-
ing sub-groups. Several answers appear to indicate that the
developers thought they had stored the passwords properly
(the experience ,replication of previous efforts ,perceived best
practice andtaken under advisement codes); whereas others
seemed to know that their implementation was limited and that
they didn‚Äôt know how to do it (the na¬®ƒ±ve,acknowledgment of
limitations andonly way I know codes).
Within the group who thought they knew how to store pass-
words, developers indicated that they believed their approaches
were best practice . One developer stored the password directly
into a database:
INSERT INTO ‚Äòusers‚Äò (‚Äòusername‚Äò, ‚Äòpassword
‚Äò) VALUES (‚Äôuser‚Äô, PASSWORD(‚Äôpassword1
‚Äô));:::
They explained this as:
‚ÄúBecause that is the best way to store the password‚Äù
Yet their solution stores the passwords directly without hashing
or salting: they scored 0. Others stated:
‚Äúthis is most accepted way of storing passwords‚Äù
(scored 4)
‚ÄúIt‚Äôs based on corporate best practices‚Äù (scored 0)
491TABLE VI
CODEBOOK FORMED FROM THE ANALYSIS OF DEVELOPERS ‚ÄôEXPLANATION OF THEIR IMPLEMENTATION APPROACH . QUOTES ARE GIVEN TO
ILLUSTRATE THE USE OF ALL CODES WITH RELEVANT PASSAGES UNDERLINED . SOME RESPONSES WERE ASSIGNED MORE THAN ONE CODE . NO MORE
THAN 3CODES WERE USED TO CAPTURE ANY SINGLE RESPONSE .
Code Description Count
Prompted
Spec
No
Spec
Implementation Ease The developer wrote it like that as the implementation would be ‚Äúsimple‚Äù 36 16% 29%
‚ÄúBecause it was a simple but quite effective way to store . To ensure that the data is secure, the function that encrypts the password
must be very good.‚Äù (scored 0)
Readability The developer focused on how understandable their code would be to a reader. 8 7% 9%
‚ÄúI wrote that way because it shows the idea very clearly . The encryption code is a more difÔ¨Åcult question and needs time and ideas to
implement a good encryption.‚Äù (scored 0)
Na¬®ƒ±ve The developer wrote the code in a literal manner without considering the merits
of any other approaches.13 7% 12%
‚ÄúBecause I don‚Äôt know how to wrote code, so just used a literal approach. ‚Äù(scored 0)
Experience The developer made reference to their experience when describing how they
wrote their code.19 11% 18%
‚ÄúI‚Äôm somewhat experienced in applied security and I consider the password should be stored securely, considering the worst case
possible.‚Äù (scored 3)
Replication of previous efforts The developer said they had done it like this before. 8 5% 6%
‚ÄúI wrote code like this because it is something I have done before. I‚Äôve written a login system for a password manager so recognise
that passwords before storage should always be hashed or encrypted to avoid storing them in plain text. I used a struct mainly for
storage purposes of this task, but would normally use a database such as SQL to store them, after hashing.‚Äù (scored 2)
Feature justiÔ¨Åcation The developer justiÔ¨Åed a speciÔ¨Åc feature of their implementation (e.g. ability to
send password reminders).4 3% 3%
‚ÄúThis is a simple way to code and allow for a reminder to the recipient! ‚Äù(scored 0)
Method justiÔ¨Åcation The developer justiÔ¨Åed the structure of their code. 20 18% 15%
‚ÄúI used a utility class. This class stores usernames and passwords in a Map data structure , and then provides functions for user
registration and login.‚Äù (scored 0)
Acknowledgment of limitations The developer noted that their code has limitations, and that it doesn‚Äôt have a
certain feature (e.g. it is insecure).14 7% 12%
‚ÄúIt assures the storage of password and allows to recover the password easily even if the security is not high. ‚Äù(scored 3)
Perceived best practice The developer did it this way as this is the correct way to store a password or a
standard way in their company.20 18% 12%
‚Äúthis is most accepted way of storing passwords‚Äù (scored 4)
Consideration of threats The developer considered a threat that might attack the code and explicitly
attempted to mitigate that threat.18 18% 9%
‚ÄúHashing passwords is a necessity, storing passwords in plain text is a huge security concern: and should never even be considered.‚Äù
(scored 2)
Taken under advisement Someone told them this was a good way to do it. 1 0% 0%
‚Äúmy friend who is into cybersecurity told me about this ‚Äù(scored 1)
Only way I know The developer indicates that this is the only way they knew how to complete the
task.15 11% 12%
‚ÄúThat was the only way i knew to solve that problem‚Äù (scored 0)
492TABLE VII
CODEBOOK FROM THE ANALYSIS OF DEVELOPERS ‚ÄôRESPONSES TO WHAT THREATS DID THEY CONSIDER WHEN STORING THE PASSWORDS . ONLY
DEVELOPERS WHO INDICATED THAT THEY HAD CONSIDERED A THREAT ‚ÄôS RESPONSES WERE ANALYZED . QUOTES ARE GIVEN TO ILLUSTRATE THE USE
OF ALL CODES WITH RELEVANT PASSAGES UNDERLINED . SOME RESPONSES WERE ASSIGNED MORE THAN ONE CODE . NO MORE THAN 4CODES WERE
USED TO CAPTURE ANY SINGLE RESPONSE .
Code Description Count
Prompted
Spec
No
Spec
Access Threat from unauthorized access to the database (e.g. leaks). 36 34% 15%
‚ÄúPassword leaks ‚Äù(scored 6)
Cracking Threat from attacks on stored passwords (e.g. cracking or rainbow tables). 20 16% 12%
‚Äúreverse the hash code but i think that is impossible because is unidirectional‚Äù (scored 1)
Hacking Threat from unspeciÔ¨Åed threat actors, phishing or social engineering. 16 11% 12%
‚ÄúStealing them by a hacker, hacked by an unknown user to steal information and data‚Äù (scored 0)
Programming concerns. The threat from vulnerabilities in their code (e.g. bugs, SQL injection) 10 8% 3%
‚ÄúSQL injection , unauthorized DB access‚Äù (scored 3)
ConÔ¨Ådentiality Concerns about making the stored passwords harder to see. 10 10% 3%
‚ÄúSomeone accessing the content that is not the main user. If I used strings the password would be stored in strings until the Garbage
Collector clears it and we cannot control when that happens.‚Äù (scored 0)
Malware Threat from malware, key-loggers or network attacks. 6 5% 6%
‚ÄúSomeone tracing you with keylogger or maybe trojan horse ‚Äù(scored 2)
ReÔ¨Çection Consideration of what they should have done and the security of their implementation. 5 3% 3%
‚ÄúSince the good is quite simple, I am not certain if the storage is secure .‚Äù(scored 0)
Wider-context Concerns about the wider impact of an insecurely stored password. 2 2% 0%
‚ÄúPotential of a database dump, hackers can just login if the passwords were stored in plain text, with hashed passwords they would
need to brute force the password. Failure to secure our users passwords
could lead to them having their accounts on other platforms compromised too as users tend to reuse passwords.‚Äù (scored 2)
Insider-threat Threats from insiders who might have access to stored passwords. 2 3% 0%
‚ÄúThe database being accessed by a 3rd party, internal threat actors (excepting those with access to the code for password storage)‚Äù
(scored 4)
Developers indicated that they knew their answer was correct
because they had done similar tasks before calling upon both
their experience as well as previously written code:
‚ÄúBecause I wrote a user registration system in the
past. ‚Äù (scored 2)
‚ÄúI‚Äôm used to implementing similar login and
authentication mechanisms in university projects and
the thought process is always the same:. . . ‚Äù (scored 0)
‚ÄúI wrote code like this because it is something I have
done before. I‚Äôve written a login system for a password
manager so recognize that passwords before storage
should always be hashed or encrypted to avoid storing
them in plain text.. . . ‚Äù (scored 2)The relevant part of the code based on the login system for
the password manager looked like:
user.username = std::cin.get();
user.password = hashPassword(std::cin.get
());}:::
void hashPassword(std::string password) {
//Cryptography algorithm to hash password
, preferably using a salt }
It hashed the password with a cryptography algorithm . It
would preferably use salt. Another developer told us that they
had taken advice from someone they considered knowledge-
able about cybersecurity:
493‚Äúmy friend who is into cybersecurity told me about
this‚Äù (scored 1)
Yet the solution their friend supplied was mostly inadequate,
only showing signs of hashing (with MD5).
:::string hashpass = MD5(password);
PasswordDatabase.put("login","password");"
This group of developers appear to believe their answers
are correct, and that they are following best practice.
They indicate that code similar to what they wrote is in
projects they‚Äôve implemented. Yet despite this, there are many
low scores. One developer described their experience as:
‚ÄúI have been working as a software engineer for 8
years and have developed authentication systems for
our clients hundreds of times so have come to learn the
best practices for doing so. ‚Äù (scored 3)
Their score would suggest they have more to learn.
Not all developers seemed to be so conÔ¨Ådent. In con-
trast to the Ô¨Årst group, other developers gave explana-
tions that suggest they are aware that they don‚Äôt know
how to store passwords properly, or at least that their
code had limitations. For example one developer stated:
‚ÄúI don‚Äôt have a lot of knowledge about password
storaging. . . ‚Äù (scored 1)
Their implementation hashed the password, suggesting the
developer was confused about the distinction between hashing
andencryption :
:::string encpass = anHashingFunction(
password);
myfile << username << endl;
myfile << encpass << endl;
They scored 1 point using Naiakshina‚Äôs criteria, for hashing
the password. Another said:
‚ÄúI wrote the code that way since it‚Äôs the only way I
know how to check if the passwords are valid, and the
hashing / storing bit because unhashed passwords are
unsafe. . . . Other methods could be used to encrypt the
password, but I‚Äôve heard hashing or MD5 hashing is
the most common. ‚Äù (scored 1)
The following two explanations came from developers who
were in the top 10% of highest scoring implementations,
according to Naiakshina‚Äôs criteria. Both acknowledge the
security of their implementations, and that it wasn‚Äôt perfect:
‚ÄúIt assures the storage of password and allows to
recover the password easily even if the security is not
high. ‚Äù (scored 3)
‚ÄúIt was the simplest and easiest way I could think . . .
This way it protects most cases, but of course a more
elaborate with more defence lines is needed (and the
salt implementations is not very well done, . . . )‚Äù
(scored 4)
This group of developers form a counterpoint to the Ô¨Årst group
who think they know how to store passwords: they know they
don‚Äôt know everything. Whilst directly comparing groups is
hard (the codes are not independent, and emerge from what
developers said) a comparison of average score between themsuggests that neither group is storing passwords more securely
(comparison of mean score between the think they know and
know they don‚Äôt know groups: 0:79vs0:63). In short, roughly
a third of developers appear to be overly conÔ¨Ådent in their
knowledge of best practice in our study. Despite this their
answers do indicate that developers are aware that password
storage is an inherently security oriented task. They know they
should be storing passwords securely, but plenty of them are
overconÔ¨Ådent and have misplaced assurance in what they do.
B. On reÔ¨Çection, perhaps you know
Theacknowledgment of limitations code from Table VI and
thereÔ¨Çection code from Table VII are interesting as they
highlight when developers indicated that their implementation
was lacking security aspects. For example, one developer re-
membered to use a hash function with a suitable length in their
implementation. When stating which threats they considered
they note that they had forgotten to salt the password (and
why that was necessary).
‚Äú. . . (Thinking about it, it might have been a good idea
to concatenate some constant text at the end of the
password so that whether the user uses the same
password on two different attacked services cannot be
determined simply by checking whether the hashes are
identical.)‚Äù (scored 2)
Others, on reÔ¨Çection, realized their solution was inadequate
(with respect to security). Both of the following developers
stored their passwords directly as plain-text (scoring 0), yet
when asked to consider the threats they later seemed to realize
that there were some they should have considered:
‚ÄúUnfortunately, I have not considered any threats, but I
know that the password should be encrypted. ‚Äù (scored 0)
‚ÄúActually I didn‚Äôt consider them in the pseudo-code but
I assume there are some threats like brute hacking‚Äù
(scored 0)
One developer stored their password directly, but when con-
sidering threats gave a guide to storing them that would have
scored at least 3:
‚ÄúThe best security practice is not to store the password
at all (not even encrypted), but to store the salted hash
(with a unique salt per password) of the encrypted
password. ‚Äù (scored 0)
Whilst we did not prime developers for storing passwords
securely as Naiakshina did [5], we still found that developers
talked about the security of their implementation. Around half
of the developers reported considering threats when imple-
menting their solutions, and some made reference to those
threats when describing why they‚Äôd implemented the code in
the way that they did. The threats described in Table VII are
reasonable: the reason we hash and salt passwords is to ensure
if the database is accessed illegally, that the passwords cannot
be trivially cracked . This is hopeful: it suggests developers
may be learning that passwords and security are linked and that
they should store them securely, not if we want them to [5].
Developers may not realize it immediately that passwords
494TABLE VIII
SITES APPARENTLY REFERENCED BY DEVELOPERS .
Source Count
stackoverflow.com 12
gist.github.com 1
docs.microsoft.com 1
simplecode121.blogspot.com 1
www.programcreek.com 1
happycoding.io 1
www.baeldung.com 1
pypi.org 1
www.codota.com 1
medium.com 1
www.the-art-of-web.com 1
www.tutorialspoint.com 1
www.cpp.re 1
docs.python.org 1
www.w3resource.com 1
howtodoinjava.com 1
should be stored securely, but if given time to reÔ¨Çect they
do seem to make that connection. Even if a developer doesn‚Äôt
initially realize that password storage is a security oriented
task, by giving them time to reÔ¨Çect (in complement with time
to consider a speciÔ¨Åcation) some developers do realize that
passwords must be stored securely.
C. Google is your friend
There is much guidance and advice online about how to
store passwords (on sites such as Stack OverÔ¨Çow , for example).
When analyzing developers reasons and implementations, we
checked for copying from such sites. We searched online to
see if any of the implementations and pseudocode developers
provided appeared online and found 12 appearing on the Stack
OverÔ¨Çow developer forum alongside 15 others appearing on
other websites (Table VIII). We found that 27 developers
(20%) appeared to have copied code from various sites (shown
in Table VIII), with the majority having taken code directly
from Stack OverÔ¨Çow. Of these 27, 7 reported using a standard.
The group that used the online source appeared to score
signiÔ¨Åcantly higher than the group whose source was unknown
(= 1:19vs= 0:60,p= 0:017) though the effect size
was relatively small ( U= 1155 ,rrb= 0:23); however when
reading the solutions online we noticed that some of the arti-
cles developers appeared to have copied from also contained
guidance on how to store them near-perfectly (according to
Naiakshina‚Äôs criteria). One developer justiÔ¨Åed their answer as:
‚ÄúI wrote the code like this because it is good practice
not to store a password in clear. ‚Äù (scored 2)
The solution appeared to have been taken from a how-to site
which described how to implement password storage with a
variety of hashes and salts, starting with MD5 and ending
with bcrypt and scrypt; however the site went on to describe
a solution at the end of the article that would have scored
6 points (losing the last point for only using 16 instead of
32 bits for the salt).Another developer described their implementation as:
‚ÄúThe Ô¨Årst and foremost way to store passwords in your
database is to have the plain text.. . . ‚Äù (scored 0)
This came from a blog post [52]. The remainder states:
‚Äú(don‚Äôt do this) I can‚Äôt emphasize strongly enough that
you should NEVER, EVER, store passwords in plain
text. ‚Äù
The article does describe how to store passwords using a
hash and a randomly generated salt (3 points); yet again the
developer only copied the insecure counter-example at the
start of the article.If we want developers to store passwords
correctly then we need to make sure the code we want them
to copy is immediately obvious. That developers are copying
code from online isn‚Äôt of itself worrying‚Äîif they copied the
right solutions we might see secure password storage. Instead,
some developers seem to be copying online code, using the
articles to justify themselves, but not reading the article all the
way through.
VI. D ISCUSSION
A. Do speciÔ¨Åcations lead to securely stored passwords?
Writing a speciÔ¨Åcation has a small, but positive, effect on
developers ability to store passwords securely. Yet in saying
this, we avoid the bigger issue that developers seem to really
struggle with implementing password storage correctly. In our
study 62% of developers failed to hash, salt or add any security
mechanism whatsoever.
Our paper joins an ever-growing body of work demon-
strating that developers are struggling implementing password
storage [53], [3], [5]; but our work also Ô¨Ånds that it isn‚Äôt
just that developers struggle to use cryptography APIs [54],
[41]; and it isn‚Äôt just that developers don‚Äôt know enough
about cryptography to complete the task correctly: developers
stated that hashing passwords with MD5 was best practice
(it isn‚Äôt [20]). Developers would forget about salting and say
that‚Äôs the way that they do it in their company. They would
claim cybersecurity expertise, to have password storage code
in production, as reasons why their code is secure; as reasons
why their code follows best practice‚Äîand yet they fall short.
Our paper Ô¨Ånds that speciÔ¨Åcation is beneÔ¨Åcial ( p= 0:024),
but, equally importantly, it highlights that developers don‚Äôt
know that they‚Äôre storing passwords insecurely.
B. Beyond Naiakshina‚Äôs criteria
In this study we measured developers‚Äô ability to store
passwords using Naiakshina‚Äôs criteria, as a proxy for the
NIST SP 800-63-3 standard [20] which deÔ¨Ånes current best
practice. The criteria and standard itself is somewhat quiz-
like, asking developers to remember cryptographic techniques
like hashing and salting as well as arbitrary lengths and counts.
If developers do not know these requirements then they will
not remember them. so what then do we learn beyond the fact
that developers do not seem to recall Naiakshina‚Äôs criteria?
An ideal speciÔ¨Åcation might have listed the criteria in full as
functional requirements, but it might also have been as simple
495as:‚Äústore the password securely, following NIST SP 800-63-
3. ‚Äù; yet none of the developers in our study made reference
to any standard in their speciÔ¨Åcations. Developers seemed to
know there was a best practice they ought to be following,
yet didn‚Äôt appear to go look up what it actually was. Whether
this generalizes and developers‚Äô recollection of other standards
is equally poor is a topic for future work. Whilst one good
approach to implementing password storage is to do what
the standard says, another equally valid (and arguably better)
aproach is to use a framework and let it do it for you. Web-
frameworks, like Django, include password storage systems
(and in Django‚Äôs case explicitly reference NIST password
standards [55]) and can take care of passwords for developers.
Again, developers in our study did not appear to make use of
frameworks like this, so is it that developers are unaware of
these features inside frameworks, or did they choose not to
use them? Perhaps given the seeming recalcitrance towards
reading standards, the resistance towards using frameworks,
and the conÔ¨Ådence many displayed that they were in fact
following best practice we might conclude that developers are
over conÔ¨Ådent in their abilities. Why use a library when you
can implement it yourself trivially? Why check the standard
when you know already what best practice is? Developers
seem to have learned not to roll their own crypto ; perhaps they
should also consider avoiding rolling their own authentication
in future too?
C. Developers are still not the enemy
We say that users and developers are not the enemy [56],
[54]‚Äîthat we must not blame users or developers when an
API or security interface is not designed for a human to be
able to use correctly. Yet when we talk about password storage
we present it as a list diktats that developers must implement to
ensure they do the task correctly. As we, and others [53], [3],
[5], have shown developers cannot follow these instructions.
Perhaps then, instead of pointing out that developers can‚Äôt
store passwords and providing lists on what they must do,
we should Ô¨Åt the task to the human and provide alternative
mechanisms for storing passwords correctly without having to
remember what the current best practice actually is, or under-
stand the intricacies of various hashing schemes. Truman said
of being the President: ‚ÄúHe‚Äôll sit here and he‚Äôll say, ‚ÄúDo this!
Do that!‚Äù And nothing will happen‚Äù [1]; and a comparison
can be drawn to the security and cryptography communities:
we cannot keep sitting here; saying, ‚ÄúHash this! Salt That!‚Äù
and pointing at NIST SP 800-63-3, because Truman was right:
‚Äúnothing will happen‚Äù . We need to Ô¨Ånd usable mechanisms
for password storage. What might these mechanisms look
like? Cryptography libraries, such as Google‚Äôs Tink [57], are
attempting to wrap cryptographic details so that developers can
use cryptography without understanding what a hash really
is [58]. There has been limited usability validation of such
approaches [59], however, and further work, documentation,
and exemplar code [41] is needed to show whether this ap-
proach is effective. Alternatively, some developers seemed to
copy code from online sources‚Äîensuring that developers canÔ¨Ånd the trivially Ô¨Ånd the right way to store passwords and that
theright code is trivially available may also help developers
without requiring them to understand the cryptographic details.
Finally, a different solution altogether may be to encourage
developers not to store passwords at all and instead use
federated identity management systems (such as OAuth [10]).
Whilst these systems can remove the need for some app
developers to implement cryptography correctly, they come
with their own set of privacy and security gotchas [60] and
challenges [61]‚Äîwe should be cautious that by recommending
an alternative to passwords we are not replacing the challenge
of storing a password with the challenge of implementing a
federated authentication system. Work on privacy-preserving
federated identity management has helped to resolve some
of the privacy challenges associated with federated identity
management [62], [63], though these are yet to be widely
adopted in practice.
Explicitly prompting developers to write a speciÔ¨Åcation does
help improve the quality of password storage; but developers
are still mostly failing at password storage whilst still believing
they are getting it right. Giving developers time to reÔ¨Çect
helps them realize the limitations of their approach: but until
we have developer-centered usable password storage methods,
the problem of poorly stored passwords isn‚Äôt going away. We
can do better than saying ‚ÄúDo this! Do that!‚Äù and watching
nothing happen.
VII. C ONCLUSION
Does the act of writing a speciÔ¨Åcation (how the code
should behave) for a piece of security sensitive code lead
to developers producing more secure code? In a statistical
sense: yes, though the effect is small ( p= 0:027,rrb=
0:209). In a broader sense however we show that whilst
writing a speciÔ¨Åcation does help developers remember more
of the conditions for secure password storage, leaving this
task to a memory exercise and hoping developers refer to
a standard isn‚Äôt working. Future work should examine and
empirically evaluate alternative strategies for helping devel-
opers complete authentication tasks‚Äîwhether in the form of
usable cryptography libraries, privacy preserving federated
identity schemes, or alternative awareness schemes to diktats
and standards. Additionally, whilst this study looked to see
ifany form of speciÔ¨Åcation improved developers ability to
store passwords correctly; speciÔ¨Åc approaches (whether that
be software building codes [64], requirements engineering, or
formal veriÔ¨Åcation) may yield more promising results. Finally,
in this study we saw developers struggling to remember how
to do secure password storage, but we may see similar results
for other areas where knowledge of what the right thing to do
is conveyed only through diktats and standards‚Äîfuture work
should examine whether this result is general or speciÔ¨Åc to
password storage.
ACKNOWLEDGMENT
This research is supported in part by EPSRC Grant
EP/P011799/2 and the National Cyber Security Centre.
496REFERENCES
[1] R. E. Neustadt, Presidential power . New American Library New York,
1960.
[2] F. P. Brooks Jr., The Mythical Man-Month . Addison Wesley, 1975, ch.
6. Passing the Word.
[3] A. Naiakshina, A. Danilova, C. Tiefenau, M. Herzog, S. Dechand,
and M. Smith, ‚ÄúWhy do developers get password storage wrong?: A
qualitative usability study,‚Äù in Proceedings of the 2017 ACM SIGSAC
Conference on Computer and Communications Security , ACM. Dallas,
TX: ACM, 2017, pp. 311‚Äì328.
[4] A. Naiakshina, A. Danilova, C. Tiefenau, and M. Smith, ‚ÄúDeception
task design in developer password studies: Exploring a student sample,‚Äù
inFourteenth Symposium on Usable Privacy and Security , M. E. Zurko
and H. R. Lipford, Eds. Baltimore, MD: USENIX Association, 2018,
pp. 297‚Äì313. [Online]. Available: https://www.usenix.org/conference/
soups2018/presentation/naiakshina
[5] A. Naiakshina, A. Danilova, E. Gerlitz, E. von Zezschwitz, and
M. Smith, ‚Äú‚ÄúIf you want, I can store the encrypted password‚Äù: A
password-storage Ô¨Åeld study with freelance developers,‚Äù in Proceedings
of the 2019 CHI Conference on Human Factors in Computing
Systems , S. A. Brewster, G. Fitzpatrick, A. L. Cox, and V . Kostakos,
Eds. Glasgow, Scotland: ACM, 2019, p. 140. [Online]. Available:
https://doi.org/10.1145/3290605.3300370
[6] A. N. Meyer, T. Zimmermann, and T. Fritz, ‚ÄúCharacterizing software
developers by perceptions of productivity,‚Äù in ACM/IEEE International
Symposium on Empirical Software Engineering and Measurement ,
A. Bener, B. Turhan, and S. BifÔ¨Ç, Eds. Toronto, ON, Canada:
IEEE Computer Society, 2017, pp. 105‚Äì110. [Online]. Available:
https://doi.org/10.1109/ESEM.2017.17
[7] D. van der Linden, P. Anthonysamy, B. Nuseibeh, T. T. Tun, M. Petre,
M. Levine, J. Towse, and A. Rashid, ‚ÄúSchr ¬®odinger‚Äôs security: Opening
the box on app developers‚Äô security rationale,‚Äù in 42nd International
Conference on Software Engineering (ICSE) , 2020.
[8] A. Barua, S. W. Thomas, and A. E. Hassan, ‚ÄúWhat are developers talking
about? An analysis of topics and trends in Stack OverÔ¨Çow,‚Äù Empirical
Software Engineering , vol. 19, no. 3, pp. 619‚Äì654, 2014.
[9] X.-L. Yang, D. Lo, X. Xia, Z.-Y . Wan, and J.-L. Sun, ‚ÄúWhat security
questions do developers ask? A large-scale study of Stack OverÔ¨Çow
posts,‚Äù Journal of Computer Science and Technology , vol. 31, no. 5, pp.
910‚Äì924, 2016.
[10] D. Hardt et al. , ‚ÄúThe OAuth 2.0 authorization framework,‚Äù RFC 6749,
Tech. Rep., 2012.
[11] B. W. Boehm, ‚ÄúVerifying and validating software requirements and
design speciÔ¨Åcations,‚Äù IEEE Software , vol. 1, no. 1, p. 75, 1984.
[12] D. L. Parnas, ‚ÄúA technique for software module speciÔ¨Åcation with
examples,‚Äù Communications of the ACM , vol. 15, no. 5, pp. 330‚Äì336,
1972.
[13] J. Spolsky, ‚ÄúThe Joel test: 12 steps to better code,‚Äù in Joel on Software .
Springer, 2004, pp. 17‚Äì30.
[14] T. DeMarco, ‚ÄúStructure analysis and system speciÔ¨Åcation,‚Äù in Pioneers
and Their Contributions to Software Engineering . Springer, 1979, pp.
255‚Äì288.
[15] B. Meyer, ‚ÄúApplying ‚Äúdesign by contract‚Äù,‚Äù IEEE Computer ,
vol. 25, no. 10, pp. 40‚Äì51, 1992. [Online]. Available: https:
//doi.org/10.1109/2.161279
[16] S. Furnell and K.-L. Thomson, ‚ÄúRecognising and addressing ‚Äòsecurity
fatigue‚Äô,‚Äù Computer Fraud & Security , vol. 2009, no. 11, pp. 7‚Äì11, 2009.
[17] S. Parkin, K. Krol, I. Becker, and M. A. Sasse, ‚ÄúApplying
cognitive control modes to identify security fatigue hotspots,‚Äù
in Twelfth Symposium on Usable Privacy and Security
(SOUPS 2016) . Denver, CO: USENIX Association, Jun. 2016.
[Online]. Available: https://www.usenix.org/conference/soups2016/
workshop-program/wsf/presentation/parkin
[18] A. van Lamsweerde, ‚ÄúFormal speciÔ¨Åcation: a roadmap,‚Äù in 22nd
International Conference on on Software Engineering, Future of
Software Engineering Track, ICSE 2000, Limerick Ireland, June 4-11,
2000 , A. Finkelstein, Ed. ACM, 2000, pp. 147‚Äì159. [Online].
Available: https://doi.org/10.1145/336512.336546
[19] A. Padegs, ‚ÄúSystem/360 and beyond,‚Äù IBM Journal of Research and
Development , vol. 25, no. 5, pp. 377‚Äì390, 1981.
[20] P. A. Grassi, M. E. Garcia, and J. L. Fenton, ‚ÄúDigital identity guidelines,‚Äù
NIST, Standard Special Publication 800-63-3, 2017.
[21] R. G. Dromey, ‚ÄúCornering the chimera [software quality],‚Äù IEEE Soft-
ware , vol. 13, no. 1, pp. 33‚Äì43, 1996.[22] T. Haigh and C. Landwehr, ‚ÄúBuilding code for medical device software
security,‚Äù IEEE Cybersecurity , 2015.
[23] C. E. Landwehr and A. Valdes, ‚ÄúBuilding code for power system
software security,‚Äù Technical Report. IEEE Computer Society , 2017.
[24] N. Polikarpova, C. A. Furia, Y . Pei, Y . Wei, and B. Meyer, ‚ÄúWhat
good are strong speciÔ¨Åcations?‚Äù in 35th International Conference
on Software Engineering, ICSE ‚Äô13, San Francisco, CA, USA, May
18-26, 2013 , D. Notkin, B. H. C. Cheng, and K. Pohl, Eds.
IEEE Computer Society, 2013, pp. 262‚Äì271. [Online]. Available:
https://doi.org/10.1109/ICSE.2013.6606572
[25] R. Mohanani, P. Ralph, and B. Shreeve, ‚ÄúRequirements Ô¨Åxation,‚Äù
inProceedings of the 36th International Conference on Software
Engineering , ser. ICSE 2014. New York, NY , USA: Association
for Computing Machinery, 2014, p. 895‚Äì906. [Online]. Available:
https://doi.org/10.1145/2568225.2568235
[26] Y . Acar, C. Stransky, D. Wermke, M. L. Mazurek, and S. Fahl, ‚ÄúSecurity
developer studies with GitHub users: Exploring a convenience sample,‚Äù
inThirteenth Symposium on Usable Privacy and Security (SOUPS
2017) , 2017, pp. 81‚Äì95.
[27] S. Oesch and S. Ruoti, ‚ÄúThat was then, this is now: A security evaluation
of password generation, storage, and autoÔ¨Åll in browser-based password
managers,‚Äù in Proc. of USENIX Security Symp , 2020.
[28] R. Shay, S. Komanduri, P. G. Kelley, P. G. Leon, M. L. Mazurek,
L. Bauer, N. Christin, and L. F. Cranor, ‚ÄúEncountering stronger password
requirements: user attitudes and behaviors,‚Äù in Proceedings of the Sixth
Symposium on Usable Privacy and Security , 2010, pp. 1‚Äì20.
[29] B. Ur, G. Kelley, S. Komanduri, J. Lee, M. Maase, M. L.Mazurek,
T. Passaro, R. Shay, T. Vidas, L. Bauer, N. Christin, L. F.Cranor,
S. Egleman, and J. L ¬¥opez, ‚ÄúHelping users create better passwords,‚Äù
USENIX ;login: , 2012.
[30] B. Ur, F. Noma, J. Bees, S. M. Segreti, R. Shay, L. Bauer, N. Christin,
and L. F. Cranor, ‚Äú‚Äù i added‚Äô!‚Äôat the end to make it secure‚Äù: Observing
password creation in the lab,‚Äù in Eleventh Symposium On Usable Privacy
and Security (fSOUPSg2015) , 2015, pp. 123‚Äì140.
[31] B. Ur, J. Bees, S. M. Segreti, L. Bauer, N. Christin, and L. F. Cranor, ‚ÄúDo
users‚Äô perceptions of password security match reality?‚Äù in Proceedings
of the 2016 CHI Conference on Human Factors in Computing Systems ,
2016, pp. 3748‚Äì3760.
[32] B. Ur, F. AlÔ¨Åeri, M. Aung, L. Bauer, N. Christin, J. Colnago, L. F.
Cranor, H. Dixon, P. Emami Naeini, H. Habib et al. , ‚ÄúDesign and
evaluation of a data-driven password meter,‚Äù in Proceedings of the 2017
CHI Conference on Human Factors in Computing Systems , 2017, pp.
3775‚Äì3786.
[33] J. Bonneau, ‚ÄúThe science of guessing: analyzing an anonymized corpus
of 70 million passwords,‚Äù in 2012 IEEE Symposium on Security and
Privacy . IEEE, 2012, pp. 538‚Äì552.
[34] S. Egelman, A. Sotirakopoulos, I. Muslukhov, K. Beznosov, and C. Her-
ley, ‚ÄúDoes my password go up to eleven? the impact of password meters
on password selection,‚Äù in Proceedings of the SIGCHI Conference on
Human Factors in Computing Systems , 2013, pp. 2379‚Äì2388.
[35] S. Komanduri, R. Shay, P. G. Kelley, M. L. Mazurek, L. Bauer,
N. Christin, L. F. Cranor, and S. Egelman, ‚ÄúOf passwords and people:
measuring the effect of password-composition policies,‚Äù in Proceedings
of the sigchi conference on human factors in computing systems , 2011,
pp. 2595‚Äì2604.
[36] M. Weir, S. Aggarwal, M. Collins, and H. Stern, ‚ÄúTesting metrics
for password creation policies by attacking large sets of revealed
passwords,‚Äù in Proceedings of the 17th ACM conference on Computer
and communications security , 2010, pp. 162‚Äì175.
[37] C. Weir, B. Hermann, and S. Fahl, ‚ÄúFrom needs to actions to secure
apps? the effect of requirements and developer practices on app security,‚Äù
in29th USENIX Security Symposium (USENIX Security 20) , 2020.
[38] F. Fischer, K. B ¬®ottinger, H. Xiao, C. Stransky, Y . Acar, M. Backes, and
S. Fahl, ‚ÄúStack overÔ¨Çow considered harmful? the impact of copy&paste
on Android application security,‚Äù in 2017 IEEE Symposium on Security
and Privacy (SP) . IEEE, 2017, pp. 121‚Äì136.
[39] S. Nadi, S. Kri ¬®uger, M. Mezini, and E. Bodden, ‚ÄúJumping through
hoops: Why do Java developers struggle with cryptography APIs?‚Äù in
2016 IEEE/ACM 38th International Conference on Software Engineer-
ing (ICSE) , 2016, pp. 935‚Äì946.
[40] M. Egele, D. Brumley, Y . Fratantonio, and C. Kruegel, ‚ÄúAn empirical
study of cryptographic misuse in android applications,‚Äù in Proceedings
of the 2013 ACM SIGSAC conference on Computer & communications
security . ACM, 2013, pp. 73‚Äì84.
497[41] N. Patnaik, J. Hallett, and A. Rashid, ‚ÄúUsability smells: An analysis of
developers‚Äô struggle with crypto libraries,‚Äù in Fifteenth Symposium on
Usable Privacy and Security ( fSOUPSg2019) , 2019.
[42] H. B. Mann and D. R. Whitney, ‚ÄúOn a test of whether one of two
random variables is stochastically larger than the other,‚Äù The annals of
mathematical statistics , pp. 50‚Äì60, 1947.
[43] E. E. Cureton, ‚ÄúRank-biserial correlation,‚Äù Psychometrika , vol. 21, no. 3,
pp. 287‚Äì290, 1956.
[44] A. L. Strauss and J. M. Corbin, Basic of qualitative research: Techniques
and procedures for developing Grounded Theory . Sage Publications,
1998.
[45] B. G. Glaser and A. L. Strauss, The discovery of Grounded Theory:
strategies for qualitative research . New York: Aldine de Gruyter, 1967.
[46] P. G. Kelley, S. Komanduri, M. L. Mazurek, R. Shay, T. Vidas, L. Bauer,
N. Christin, L. F. Cranor, and J. Lopez, ‚ÄúGuess again (and again and
again): Measuring password strength by simulating password-cracking
algorithms,‚Äù in 2012 IEEE symposium on security and privacy . IEEE,
2012, pp. 523‚Äì537.
[47] A. Naiakshina, A. Danilova, E. Gerlitz, and M. Smith, ‚ÄúOn conducting
security developer studies with CS students: Examining a password-
storage study with CS students, freelancers, and company developers,‚Äù
inCHI Conference on Human Factors in Computing Systems ,
R. Bernhaupt, F. F. Mueller, D. Verweij, J. Andres, J. McGrenere,
A. Cockburn, I. Avellino, A. Goguey, P. Bj√∏n, S. Zhao, B. P. Samson,
and R. Kocielnik, Eds. Honolulu, HI: ACM, 2020, pp. 1‚Äì13. [Online].
Available: https://doi.org/10.1145/3313831.3376791
[48] J. R. Landis and G. G. Koch, ‚ÄúThe measurement of observer agreement
for categorical data,‚Äù biometrics , pp. 159‚Äì174, 1977.
[49] C. Spearman, ‚ÄúThe proof and measurement of association between two
things,‚Äù Studies in individual differences: The search for intelligence ,
1961.
[50] M. Hazhirpasand, M. Ghafari, S. Kr ¬®uger, E. Bodden, and O. Nierstrasz,
‚ÄúThe impact of developer experience in using Java cryptography,‚Äù
in2019 ACM/IEEE International Symposium on Empirical Software
Engineering and Measurement (ESEM) . IEEE, 2019, pp. 1‚Äì6.
[51] A. Shostack, Threat modeling: Designing for security . John Wiley &
Sons, 2014.
[52] J. Cox, ‚ÄúPassword storage methods,‚Äù 2017. [Online]. Available:
https://medium.com/@jcox250/password-storage-d480309ca08f
[53] C. Wijayarathna and N. A. G. Arachchilage, ‚ÄúWhy johnny can‚Äôt store
passwords securely? a usability evaluation of bouncycastle passwordhashing,‚Äù in Proceedings of the 22nd International Conference
on Evaluation and Assessment in Software Engineering 2018 , ser.
EASE‚Äô18. New York, NY , USA: Association for Computing Machinery,
2018, p. 205‚Äì210. [Online]. Available: https://doi.org/10.1145/3210459.
3210483
[54] M. Green and M. Smith, ‚ÄúDevelopers are not the enemy!: The need
for usable security APIs,‚Äù IEEE Security & Privacy , vol. 14, no. 5, pp.
40‚Äì46, 2016.
[55] ‚ÄúPassword management in django,‚Äù accessed 2021-01-22. [Online].
Available: https://docs.djangoproject.com/en/3.1/topics/auth/passwords/
[56] A. Adams and M. A. Sasse, ‚ÄúUsers are not the enemy,‚Äù Communications
of the ACM , vol. 42, no. 12, pp. 40‚Äì46, 1999.
[57] Google, ‚ÄúTink.‚Äù [Online]. Available: https://github.com/google/tink
[58] S. Schmieg, ‚ÄúThis issue demonstrates nicely how software engineers
and cryptographers have a completely different idea about what a
hash function does. for many software engineers, a hash function is
a ‚Äúone-way‚Äù function, with the output being essentially meaningless.‚Äù
August 2020, tweet. @SchmiegSophie. [Online]. Available: https:
//mobile.twitter.com/SchmiegSophie/status/1292930642561265664
[59] K. Mindermann and S. Wagner, ‚ÄúFluid intelligence doesn‚Äôt matter!
Effects of code examples on the usability of crypto APIs,‚Äù in 42nd
International Conference on Software Engineering (ICSE) Posters , 2020,
poster.
[60] T. Lodderstedt, J. Bradley, A. Labunets, and D. Fett, ‚ÄúOAuth
2.0 security best current practice,‚Äù IETF Web Authorization Protocol,
Tech. Rep. draft-ietf-oauth-security-topics-16, 2020. [Online]. Available:
https://www.ietf.org/id/draft-ietf-oauth-security-topics-16.html
[61] S.-T. Sun and K. Beznosov, ‚ÄúThe devil is in the (implementation) details:
an empirical analysis of OAuth SSO systems,‚Äù in Proceedings of the
2012 ACM conference on Computer and communications security , 2012,
pp. 378‚Äì390.
[62] S. S. Chow, Y .-J. He, L. C. Hui, and S. M. Yiu, ‚ÄúSPICE‚Äìsimple privacy-
preserving identity-management for cloud environment,‚Äù in International
Conference on Applied Cryptography and Network Security . Springer,
2012, pp. 526‚Äì543.
[63] M. Isaakidis, H. Halpin, and G. Danezis, ‚ÄúUnlimitID: Privacy-preserving
federated identity management using algebraic MACs,‚Äù in Proceedings
of the 2016 ACM on Workshop on Privacy in the Electronic Society ,
2016, pp. 139‚Äì142.
[64] C. Landwehr, ‚ÄúWe need a building code for building code,‚Äù vol. 58,
no. 2, 2015. [Online]. Available: https://doi.org/10.1145/2700341
498