Watchman: Monitoring Dependency Conflicts for Python
Library Ecosystem
YingWang
wangying@swc .neu.edu.cn
Software College, Northeastern
University, ChinaMingWen‚àó
mwenaa@hust .edu.cn
School of Cyber Science and
Engineering,HUST, ChinaYepang Liu‚àó
liuyp1@sustech .edu.cn
Department of Computer Science and
Engineering,SUSTech, China
Yibo Wang, Zhenming Li,
ChaoWang
{wybneu ,lzmneu,wangcneu}@163 .com
Software College, Northeastern
University, ChinaHai Yu
yuhai@mail .neu.edu.cn
Software College, Northeastern
University, ChinaShing-Chi Cheung
scc@cse .ust.hk
Department of Computer Science and
Engineering,HKUST, China
ChangXu
changxu@nju .edu.cn
StateKey Lab for Novel Software
Technology and Department of
ComputerScienceand Technology,
NanjingUniversity, ChinaZhiliang Zhu
zzl@mail .neu.edu.cn
Software College, Northeastern
University, China
ABSTRACT
The PyPIecosystem has indexed millions of Python libraries to al-
lowdeveloperstoautomaticallydownloadandinstalldependencies
of their projects based on the specified version constraints. De-
spite the convenience brought by automation, version constraints
in Python projects can easily conflict, resulting in build failures.
We refer to such conflicts as Dependency Conflict (DC) issues. Al-
though DC issues are common in Python projects, developers lack
toolsupporttogainacomprehensiveknowledgefordiagnosingthe
rootcausesoftheseissues.Inthispaper,weconductedanempirical
studyon235real-worldDCissues.Westudiedthemanifestation
patterns and fixing strategies of these issues and found several key
factorsthatcanleadtoDCissuesandtheirregressions.Basedon
our findings, we designed and implemented Watchman, a tech-
niquetocontinuouslymonitordependencyconflictsforthe PyPI
ecosystem.Inourevaluation,Watchmananalyzed PyPIsnapshots
between 11 Jul 2019 and 16 Aug 2019, and found 117 potential DC
issues.Wereportedtheseissuestothedevelopersofthecorrespond-
ing projects. So far, 63 issues have been confirmed, 38 of which
have been quickly fixed by applying our suggested patches.
‚àóMingWenandYepangLiuarethecorrespondingauthorsofthispaper.HUST,SUSTech,
and HKUST are short for Huazhong University of Science and Technology, Southern
University of Science and Technology, and The Hong Kong University of Science and
Technology, respectively.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACM
mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,
topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ICSE‚Äô20,May23‚Äì29,2020,Seoul, Republic of Korea
¬©2020Association for Computing Machinery.
ACM ISBN 978-1-4503-7121-6/20/05...$15.00
https://doi .org/10.1145/3377811 .3380426CCS CONCEPTS
‚Ä¢Software and its engineering ‚ÜíSoftwarelibrariesandreposi-
tories;
KEYWORDS
Python,dependencyconflicts,software ecosystem
ACM Reference Format:
Ying Wang, Ming Wen, Yepang Liu, Yibo Wang, Zhenming Li, Chao Wang,
Hai Yu, Shing-Chi Cheung, Chang Xu, and Zhiliang Zhu. 2020. Watchman:
Monitoring Dependency Conflicts for Python Library Ecosystem. In Pro-
ceedings of 42nd International Conference on Software Engineering, Seoul,
Republic of Korea, May 23‚Äì29, 2020 (ICSE ‚Äô20), 11 pages.
https://doi .org/10.1145/3377811 .3380426
1 INTRODUCTION
Python projects are commonly shared as third-party libraries in
a server-side central repository PyPI[42], and reused by other
projectswithaclient-sidelibraryinstaller pip[36,46,55].ByJune
2019, the PyPIecosystem ( PyPIfor short) has indexed over 1.43
million Python libraries together with their metadata (e.g., version
information,dependencieson other libraries, etc.).
To use a library on PyPI, developers need to specify the desired
version constraint [ 51] in a configuration script such as setup.py
and requirements.txt [44].Whenalibraryisreusedbyanother
project, this library and other libraries on which it depends will be
automatically installed at the project‚Äôs build time. The automation
smartly combines a server-side central repository and a client-side
library installer to manage library dependencies. It considerably
simplifiesthebuildprocessofPythonprojects.Besides,theversion
constraintmechanismforarequiredlibraryallowsdevelopersto
restrictthedependenciestoasetofcompatibleversionsandenables
automaticlibrary evolution [ 3]. However, such automation comes
with the risk of potential Dependency Conflict (DC) issues, which
*&&&"$.OE*OUFSOBUJPOBM$POGFSFODFPO4PGUXBSF&OHJOFFSJOH	*$4&



	
 
"
 $$
$$


	
 
 
!$

	

	




	
 


 







	
 

#

$$
!$
		

	


	

		
Figure 1: Illustrative examples of dependency conflict issues
can cause build failures when the installed version of a library
violatescertainversion constraints on the library.
Figure1givesarealexample:issue#1277[ 6]in channels .A s
shownin channels 2.1.7‚Äôsconfigurationscript,itdirectlyrequires
libraries asgiref (versionconstraint: /angbracketleft‚â•2.3‚àß<3.0/angbracketright)and daphne
(version constraint: /angbracketleft‚â•2.2‚àß< 3.0/angbracketright). Note that when downloading
a library, the pipinstaller always chooses the latest version on
PyPIthat satisfies the library‚Äôs version constraint [ 37]. No DC
issues occurredwhen channels 2.1.7 wasbuiltbefore 9Apr 2019.
Both asgiref 2.3.0 and daphne2.2.5 selected for the build satisfy
the concerned constraints. However, issue #1277 [ 6] arose after
9 Apr 2019 when channels 2.1.7 was built via selecting the newly
releasedlibrary daphne2.3.0,whichadditionallyrequireslibrary
asgiref (version constraint: /angbracketleft‚â•3.0‚àß< 4.0/angbracketright). The DC issue (the
red curve a.1) happened because pipselected asgiref 2.3.0 to
satisfy the direct dependency constraint /angbracketleft‚â•2.3‚àß< 3.0/angbracketright, but this
version violated the constraint /angbracketleft‚â•3.0‚àß<4.0/angbracketrightspecified in daphne
2.3.0.Thisissuecaused a build error as shown in Figure 1(b).
Tofixtheissue, channels ‚Äôsdevelopersreleasedversion2.2.0on
14Apr2019,whichupdatedtherequirementon asgrief‚Äôsversion
to/angbracketleft‚â•3.0‚àß<4.0/angbracketright.This update ledtotheinstallation of asgrief
3.1.1(thelatestversionunder4.0)whenbuilding channels 2.2.0,
thusresolvingthefailure(thegreencurvea.2).However,thisfixin-
ducedanotherDCissuein channels-redis (issue#152[ 7]),asFig-
ure1(c)shows.Aftertheupgradeof channels ,tobuild channels
-redis2.3.3, pipstill selected asgiref 2.3.0 to satisfy the direct
dependency constraint /angbracketleft‚â•2.1‚àß< 3.0/angbracketright. Unfortunately, this version
violatestheconstraint /angbracketleft‚â•3.0‚àß<4.0/angbracketrightthatistransitivelyintroduced
bychannel 2.2.0,causinga build failure (red curve c.2).
To understand the scale of DC issues in Python projects and
theircharacteristics,weempiricallystudied235DCissuesin124
popular Python projects, which were reported on GitHubin the
lastfive years. We explored the following two research questions:
‚Ä¢RQ1(ManifestationPatterns) :HowdoDCissuesmanifestthem-
selvesinPythonprojects?Aretherecommonpatternsthatcanbe
leveraged for automated diagnosis of these issues?
‚Ä¢RQ2 (Fixing Strategies) :How do developers fix DC issues in
Python projects? Are there common practices that can be leveraged
forautomated repair of these issues?
Throughinvestigatingtheresearchquestions,weobservethat
DCissuesmainlyarisefromconflictscausedbyremotedependency
updates or local environments (see Section 3.2). We also found
common strategies for fixing DC issues and key factors that can
leadto DC issues and their regressions (see Section 3.3).
Asareal-worldPythondevelopercommentedonthereportof
pyenvissue#3118[ 21],thedependencyresolutioninthePython
worldisfarfrombeingeasy.Thedifficultiesaremainlyattributedtothecomplexdependenciesacrossprojects.Developersoftenspecify
version constraints on the dependent libraries of their projects
without considering the constraints specified in other projects. To
be specific, we summarize three major challenges as follows.
First,theversionofalibraryinstalledforaPythonprojectcan
vary over time. Recall that for each required library of a project,
pipwillinstallitslatestversionsatisfyingtheconcernedconstraint.
Therefore any update of libraries on PyPIcan affect the version of
thelibrariesinstalledforthedownstreamprojects(i.e.,theprojects
thatdependon these libraries), causing potential build failures.
Second, when a library updates its version constraints on other
libraries, its downstream projects might be affected. The impact
canbe further propagated to a wide range of projects.
Third,itisdifficultforPythondeveloperstoobtainafullpicture
oftheirprojects‚Äôdependencieswithversionconstraintinformation.
State-of-the-art tools like pipenvand Poetryonly show which
librarieshave been installed, rather than their dependencies.
ToaddressthechallengesandhelpPythondeveloperscombat
DCissues,wedesignedatechnique,Watchman,whichperforms
aholisticanalysisfromtheperspectiveoftheentire PyPIecosys-
tem, to continuously monitor dependency conflicts caused by li-
brary updates. For each library on PyPI,Watchmanbuilds a Full
Dependency Graph(FDG),aformal modelthat simulatesthe pro-
cess of installing dependencies for Python projects. The FDGs can
be incrementally updated as the libraries evolve on PyPI. Watch-
man then analyzes them to detect and proactively prevent DC
issues. Since FDGs record full dependencies of Python projects
with version constraints, they can also provide useful diagnostic
informationtohelpdevelopersunderstandtherootcausesofthe
detected DC issues, thus facilitating issue fixing.
ToevaluateWatchman,weplayedbacktheevolutionhistoryof
alllibrarieson PyPI,from1Jan2017to30Jun2019anddeployed
Watchman to detect DC issues. After analyzing PyPIsnapshots
during this time period, Watchman detected 515 DC issues and
502 (97.5%) of them were indeed fixed by developers during the
evolutionofthelibraries.Toevaluatetheusefulnessof Watchman,
we ranit to monitordependency conflicts forthe PyPIecosystem
between 11 Jul 2019 and 16 Aug 2019. During the time period,
it detected and reported 117 previously-unknown DC issues, 63
of which (53.8%) have been confirmed by developers. Further, 38
(60.3%)confirmedissueshavebeenfixedbyapplyingoursuggested
patches.DevelopersalsoexpressedgreatinterestsinWatchman.
In summary, our work makes three major contributions:
‚Ä¢Originality: To the best of our knowledge, we conducted the
firstempiricalstudyofDCissuesinopen-sourcePythonprojects.
Our findings help understand the characteristics of DC issues
andprovide guidance to future studies related to this topic.
‚Ä¢Dataset: We release the dataset for empirical study, comprising
235 DC issues collected from 124 real-world Python projects, to
facilitatefuture research.
‚Ä¢Technique: Weproposedaformalmodeltosimulatethebuild
process of Python projects and developed a DC issue diagnos-
tic technique Watchman ( http://www.watchman-pypi.com/ )
based on the model. Experimental results show that Watchman
can monitor the entire PyPIecosystem and detect DC issues
witha high precision.









	


#$
#$#$#$
#$	 




	
 " 
"!
	





Figure 2: Dependencies of a Python project
2 PRELIMINARIES
2.1 Dependencies of Python Projects
Figure 2 illustrates the concept of Python project dependencies.
Code reuse is pervasive in the Python world, where projects often
reuseotherprojectsaslibraries.Theconfigurationscriptofaproject
Pexplicitly constrains the versions of direct dependencies thatP
mayuse.Ifthesedirectdependenciesfurtherrelyonotherlibraries,
suchlibrariesarecalled transitivedependencies ofP.Inthispaper,
all direct and transitive dependencies are collectively referred to as
theupstreamprojects ofP.Correspondingly,wecall Padownstream
projectof its dependencies.
Python projects are often developed in a self-contained envi-
ronment, which can be created by tools such as virtualenv [43],
conda[2],and pipenv[38].WhenbuildingaPython project, the
library installer pipdownloads most of the required libraries from
PyPI. We refer to such libraries that need to be downloaded as
remote dependencies. For each required remote dependency, pip
downloadsitaccordingtoitsnameandversionconstraint.Ifmulti-ple releases of a library on
PyPIsatisfy the version constraint, pip
downloads and installs the latest version of the library [36].
Besides remote dependencies, the development of a Python
project can be affected by its local environment, including the local
developmenttoolchains(e.g.,thePythoninterpreterandGCC)and
local dependencies (i.e., libraries that are already installed). Local
dependenciesexistwhenthedevelopmentenvironmentisnotclean
(e.g.,theprojectisnotdevelopedinanisolatedvirtualenvironment).
If any version of a required dependency has been installed locally,
pipwillnotdownload the dependency from PyPI.
2.2 Library Version Constraints
Tousealibrary,aPythonprojectneedstospecifyaconstraintonits
desired library versions as shown in Figure 2 (i.e., the Cannotated
onsomeedges).Tofacilitatesubsequentdiscussions,weformally
defineversionconstraint usingthegrammarbelow( versionidrefers
to a specific version of a library, e.g., 1.24.1):
C/Colonequalœµ|range‚àßextra|=version id
range/Colonequalrange‚àßopversion id|opversion id
extra/Colonequalœµ|/nequalversion id|extra‚àß/nequalversion id
op/Colonequal>|‚â•|<|‚â§(1)
A constraint Ccould be empty, in which case pipwill choose
to download the latest version of the library from PyPIif the li-
braryisnotinstalledinthelocalenvironment.Developersmayalsospecify a specific version that is desired (e.g., = 1.24.1) or undesiredNumber of projects in each categoryUtilities
AdministrationInstallation/SetupTestingLibrariesBuild Tools
Development
Security
Engineering
ƒú¬å¬é»¶¬û¬ú¬í¬ó¬é¬ú¬ú
Others
Stars Forks Issues RevisionsDownstream
ProjectsCategory
KLOCKLOC
0K-1K
1K-5K
5K-10K 10K-50K50K-100K100K-500K
11 18 10 20 4 6 7 13 7 18 10
17 33 19 28 17 1002000400060008000
010002000300040005000
02000400060008000
012344
02000400060008000√ó10
Figure 3: Statistics of the projects used in our empirical study
(e.g.,/nequal1.24.1). In practice, developers mostly specify a range of
versionsinaconstraint(e.g., ‚â§1.24.1‚àß>1.11.0).Tounderstand
how frequent ranges are used in version constraints, we inves-
tigated the top 1,000 popular Python projects on PyPIbased on
the number of downstream projects. We found that 92.2% of these
projects‚Äôdirectdependenciesareconstrainedtoarangeofversions.
Incomparison,thisratioisonly0 .03%forJavaprojectsmanagedby
Mavenfollowing the same investigation method. Such heavy uses
of ranges in version constraints for dependencies make the diagno-
sisofDCissuesinthePythonworldcomplicatedandchallenging
(see Section 3).
3 EMPIRICAL STUDY
3.1 Data Collection
Followingthedatacollectionprocessofexistingstudies[ 47,49,58],
we prepared our dataset in two steps.
Step 1: Selecting subjects. To understand the manifestation
patterns and fixing strategies of DC issues, we need to study the
issuereports(withdiscussionsifany),dependencyconfiguration
scripts, issue-fixing patches, and related code revisions. For this
purpose,wesearched GitHubforPythonprojectsthatsatisfythree
conditions:(1) popular:havingmorethan50starsorforks,(2) being
used as libraries : containing more than three direct downstream
projects,and(3) well-maintained :havingover500coderevisions
orover50issuereports.Withthisprocess,weobtained1,596open-
source Python projects.
Step2:IdentifyingDCissues. TolocateDCissuesinthe1,596
projects,wesearchedfortheissuereportsthatcontainkeywords
‚Äúdependency conflict‚Äù or ‚Äúdependency hell‚Äù (case insensitive), filed
between Jul 2014 and Jul 2019 (i.e., in the past five years). We
obtained 2,593 and 334 issue reports by searching with the two
keywords, respectively. Next, we removed duplicates and noises
fromthesearchresultsandkeptonlythoseissuereportsthatsatisfythefollowingthreeconditions.First,thereportisrelatedtovalidDC
issues.Second,thereportcontainsdescriptionsofissuerootcauses.
Third,wecanfindcoderevisionsthatfixthereportedissue(s)inthe
concernedproject‚Äôscoderepositoryorthereisanexplicitconsensus
on the fixing solutions among developers as documented in the
issuereport.
Eventually, we obtained 235 DC issues from 124 projects, and
201 of the 235 issues have been fixed. Figure 3 shows the statistics
ofthe124projects.Aswecansee,theyare:(1)largeinsize(around
38 KLOC on average), (2) well-maintained (containing 78 revisions
and 92 issues on average), (3) popular (83% of them have over
100 stars), (4) impactful (86% of them have more than 5 direct
downstreamprojects),and(5)diverse(coveringover10categories).
In the following, we study the 235 issues to answer RQ1‚Äì2.
3.2 RQ1: Manifestation Patterns
DC issuesin Pythonprojects manifestthemselves dueto different
causes. Our studied issues can be divided into two categories ac-
cording to whether the issues are caused by remote dependencies or
localenvironment.Inthefollowing,wediscussthemanifestation
patternsof the issues in detail with illustrative examples.
Finding 1: 211outofthe235(89.8%)DCissuesthatinvolvethe
violation of library version constraints were introduced by the
updates of remote dependencies on PyPI.
3.2.1 Pattern A: Conflicts caused by remote dependency updates.
The root cause of the 211 issues is that the updates of some remote
dependencychangetheversionoftheconcernedlibrarytobein-
stalled by pip, which is hardly perceptible to project developers.
Suppose that a Python project Prequires a library Œ≤with a con-
straintC.I fCdoes not specify an upper bound on Œ≤‚Äôs version (e.g.,
C=/angbracketleft‚â•3.0/angbracketright),orthespecifiedupperboundisgreaterthanthelatest
version of Œ≤onPyPI(e.g.,C=/angbracketleft2.0‚â§‚àß‚â§4.0/angbracketright, while the latest
versionof Œ≤is3.0),thentheversionof Œ≤usedtobuild Pmaynot
becontrollableindevelopers‚Äôperspective,meaningthat Œ≤canbe
upgradedwhentherearenewversionson PyPI.Suchupgrading
caneasilyinduceDCissues: Œ≤‚Äôsnewversionmaynotsatisfythe
constraintsspecifiedby other dependencies of P; the versioncon-
straints specified by Œ≤for its own libraries may also change in new
versions, causing potential conflicts with the constraints for the
samelibrariesintroduced by P‚Äôs other dependencies.
The 211 issues can be further categorized based on where the
dependencyconflictscome from. Theoretically, conflicts couldhap-
pen in three different cases: (1) among direct dependencies, (2)
between directdependencies andtransitive dependencies,and (3)
amongtransitivedependencies.However,developersusuallywill
not introduce conflicts among direct dependencies by including
two conflicting libraries in the configuration script (such mistakes
canbeeasilycaught).Indeed,wedidnotobserveanyconflictsof
thefirstcase. In the following, we discuss the latter two cases.
a.Conflictsbetweendirectandtransitivedependencies(139/211).
SupposethataPythonproject Pdirectlydependsontwolibraries Œ±
andŒ≤with the version constraints CP‚ÜíŒ±andCP‚ÜíŒ≤, respectively,
andŒ≤furtherdependson Œ±withtheversionconstraint CŒ≤‚ÜíŒ±.In
other words, Œ±is not only a direct dependency of P, but also re-
quired by other direct dependencies of P(i.e.,Œ±can also be seen as
a transitive dependency of P). When building P,pipwill always
installthelatestversion vofthelibrary Œ±thatsatisfies CP‚ÜíŒ±,as
Œ±isatthetoplevelof P‚Äôsdependencytree[ 36].Ifvfallsintothe
version range(s) specified by CŒ≤‚ÜíŒ±,Pwill be built successfully.
However, once Œ±gets updated on PyPI, the update may cause pip
to install another version v/primeofŒ±.I fv/primefalls out of the range(s)
specified by CŒ≤‚ÜíŒ±,Pwill not be built successfully. For instance,
in issue #229 [ 15], the project gallery-dl directly requires the
libraries requests /angbracketleft‚â•2.11.0/angbracketrightand urllib3 /angbracketleft‚â•1.16‚àß/nequal1.24.1/angbracketright.
pipinstalledtheversion2.13.0of requests ,whichalsodepends
onurllib3 /angbracketleft<1.25.0‚àß‚â•1.21.1/angbracketright.Thingsworkedsmoothlywhen
gallery-dl was first released on PyPI, as the latest version ofurllib3 at that time was 1.24.2, which satisfies the constraints
/angbracketleft‚â•1.16‚àß/nequal1.24.1/angbracketrightand/angbracketleft<1.25.0‚àß‚â•1.21.1/angbracketright.However,whenthe
project urllib3 wasupdatedto1.25.0on18Apr2019, gallery-dl
began to suffer from build failures. This is because when build-
ing gallery-dl ,pipwill install the latest version (i.e., 1.25.0)
ofurllib3. However, the version 1.25.0 violates the constraint
/angbracketleft<1.25.0‚àß‚â•1.21.1/angbracketrightspecified in requests.
b.Conflictsbetweentransitivedependencies(72/211). Supposethat
a Python project Pdirectly depends on two libraries Œ±andŒ≤, both
of which depend on another library Œ∏but withtwo different ver-
sion constraints CŒ±‚ÜíŒ∏andCŒ≤‚ÜíŒ∏, respectively. If the version v
ofŒ∏downloaded by pipaccording to CŒ±‚ÜíŒ∏(suppose that it has
a higher priority) also satisfies CŒ≤‚ÜíŒ∏, the project Pcan be built
successfully.However,since Œ±andŒ≤aretwoseparateprojects,their
dependency relationshipon Œ∏may evolveover time.There canbe
caseswheretheupdatesof Œ±orŒ≤wouldresultinconflictingversion
constraints of Œ∏, consequently causing DC issues when building
P. We observed 72 such issues in our study. For example, the issue
report #3826 [ 24]o f rasadocumented an incident that a project
was forced to introduce multiple version constraints of the library
requests by its direct dependencies rasaand sagemaker . The
reasonisthat rasareleasedanewversion1.0.4andaddedacon-
straint/angbracketleft= 2.22.0/angbracketrightonrequests . However, this constraint is in con-
flict with another constraint on requests /angbracketleft‚â•2.20.0‚àß<2.21.0/angbracketright
introduced by sagemaker.
Finding2: 24outofthe235(10.2%)DCissuesaroseduetothecon-
flicts between remote dependencies and the tools/libraries installed
in the local environment.
3.2.2 Pattern B: Conflicts affected by local environment. Such
issuescanhappenwhentherequiredtoolofaremotedependencyis
incompatiblewiththelocalinstalledone(e.g.,requiringPython3.7.*
but installed Python 3.6.*). They can also happen when the version
ofadependency,whichisalreadyinstalledinthelocalenvironment,
doesnotsatisfytheconstraintspecifiedbyaremotedependency.
Take issue #25316 [ 17]o f gradient as an example. The project
failed to be built because there was already one version (1.13.3)
ofthelibrary numpyinstalledinthelocalenvironmentbeforethe
build, and this version is in conflict with the constraint /angbracketleft‚â•1.15/angbracketright
specified by pandasv0.24.1,a direct dependency of gradient.
3.2.3 Dependency Smells. By further analyzing developers‚Äô dis-
cussions in the issue reports and the dependency configuration
scriptsoftheprojectversionsthatwerenotaffectedbythereported
issues of Pattern A,1we observed several types of ‚Äúdependency
smells‚Äù. These smells are interesting as they do not immediately
causeDCissuesbutarelikelytoinduceissuesastheprojectsevolve.
Finding 3: Restrictingdependenciestospecificversionsforcom-
monlibrariescouldeasilyinduceDCissuestodownstreamprojects.
Build failures can easily happen if library version constraints
are too restrictive (e.g., only accepting specific versions), especially
for those common libraries. 59 of our studied 235 issues belong
to this case. For instance, the project molecule [41] depends on
1We ignored Pattern B issues as they are affected by developers‚Äô local environments,
whichare often unknown to us.
aspecificversionof ansible-lint (i.e.,version3.4.23),alibrary
thatisusedbymanyotherprojects.Thismakes molecule ‚Äôsdown-
stream projects that also depend on ansible-lint particularly
sensitive to the updates of ansible-lint . We observe that when-
ever there was a new version of ansible-lint released on PyPI,
molecule ‚Äôsdeveloperswouldreceiverequestsfromdownstream
projectstoupgradeitsversionconstrainton ansible-lint (e.g.,
[8,11]). As there were too many such requests, molecule devel-
opers finally chose to update and loosen the version constraint on
ansible-lint toarange /angbracketleft‚â•4.0.1‚àß<5/angbracketright[39],thusallowingmore
downstream projects to work well with it.
Finding4: DC issues can easily occur when the installed version
ofalibrarysatisfyingoneversionconstraintisclosetotheupper
bound specified in another version constraint.
67 out of the 235 issues belong to this case. As a library ver-
sion installed by pipin the concerned project is close to the upper
boundthat anotherversion constraintimposedon thelibrary,up-
dates of the library will likely induce build failures. For instance,
the projects that directly require both request and urllib3 have
oftenencounteredDC issues(e.g.,[ 23,27‚Äì29]).Thereason isthat
these projects always install the latest version of urllib3 since
the direct dependency constraints on urllib3 do not set an upper
bound. Besides, request also depends on urllib3 with a version
constraint /angbracketleft‚â•1.21.1‚àß<1.23/angbracketright.Theseprojectswerebuiltsuccess-
fully when urllib3‚Äôs latest version was 1.22.4, which satisfies
/angbracketleft‚â•1.21.1‚àß<1.23/angbracketright. However, the installed latest version 1.22.4
was close to the upper bound 1.23. In such cases, DC issues can
easilyarisewhenthere comes a newer version of urllib3.
Thesefindings are useful. We will show that identifying the two
types of smells can help perform predictive analysis to proactively
prevent DC issues before they cause real build failures.
3.3 RQ2: Fixing Strategies
To answer RQ2, we studied: (1) the patches of the 201 fixed issues,
(2) the planned fixing solutions of the remaining 34 issues, and
(3) the comments in the issue reports. We observed seven fixing
strategies,whichaltogetherresolved93.6%ofourcollectedissues.
Strategy1: Adjustingtheversionconstraints ofdirectdependen-
cies (98/235). The conflicts between direct and transitive dependen-
cieswerecommonlyfixedbyadjustingtheversionconstraintsof
directdependenciestobecompatiblewiththoseoftransitivedepen-
dencies. For example, in issue #32 [ 22] of project valinor, there
were two conflicting version constraints on the library pyyaml.
Oneconstraint /angbracketleft‚â•3‚àß<5/angbracketrightwasdirectlyspecifiedby valinor.The
other constraint /angbracketleft< 6.0‚àß‚â•5.1/angbracketrightwas transitively introduced by
pyOCD, a dependency of valinor. In such a case, any version of
pyyamlinstalledby pip,whichsatisfiestheformerconstraint,will
violatethelatterone.Tofixtheproblem,thedevelopersof valinor
revised the version constraint of pyyamlto/angbracketleft< 6.0‚àß‚â•5.1/angbracketright.
Strategy 2: Upgrading or downgrading the direct dependencies
thatrequireconflictinglibraries(27/235).Dependencyconflictsbe-
tweentransitivedependenciescanbesolvedbyupgradingordown-
gradingthedirectdependenciesthatintroducethetransitivedepen-
dencies.Takeissue#66[ 31]ofzhmcclient asanexample.Thetwo
conflictingversion constraints /angbracketleft=4.0.3/angbracketrightand/angbracketleft‚â•4.4/angbracketrightoncoveragewere transitively introduced by zhmcclient ‚Äôs direct dependen-
cies python-coveralls /angbracketleft= 2.9.1/angbracketrightand pytest-cov /angbracketleft‚â•2.4.0/angbracketright,r e -
spectively. Since the installed version pytest-cov 2.6.0 added
coverage /angbracketleft‚â•4.4/angbracketrightas its direct dependency, which caused the con-
flict, zhmcclient ‚Äôsdevelopersdowngraded pytest-cov bychang-
ingitsversionconstraintto /angbracketleft‚â•2.4.0‚àß<2.6.0/angbracketright.Afterrevisingthe
constraint, pytest-cov 2.5.1,whichrequires coverage /angbracketleft‚â•3.71/angbracketright,
was installed. This constraint /angbracketleft‚â•3.71/angbracketrightis not in conflict with
/angbracketleft= 4.0.3/angbracketrightandthus theDC issue was resolved.
Strategy 3: Coordinating with upstream projects to adjust con-
flicting version constraints (51/235). DC issues can also be fixed via
coordinating with upstream projects. Take issue #740 [ 33]o ft h e
project yottaasanexample.Althoughtheconflictcanberesolved
by adjusting the direct dependency‚Äôs version constraint (i.e., fol-
lowing Strategy 1), the developers chose to coordinate with the
upstreamprojectstosolvetheproblem.Thisavoidschangingthe
version of the directly required library.
Strategy4: Removingconflictingdirectdependenciesandkeeping
the transitive ones (8/235). When it is difficult to make a project‚Äôs
directdependenciesinlinewithitstransitiveones,developersmay
choose to remove the conflicting direct dependencies. For example,
as described in issue #407 [ 25] of the project wandb, conflicts oc-
curred when an upstream project updated its version constraint on
adirectdependency PyYAML,andthishappenedseveraltimes.As
wandbdevelopershadnodirectcontrolontheupstreamprojects,
theyremovedthe conflictingdirectdependencyfromtheconfigu-
rationscript,andused the transitively introduced one instead.
Strategy 5: Adding direct dependencies (16/235). There are cases
whentheversionconstraints CŒ±‚ÜíŒ∏andCŒ≤‚ÜíŒ∏oftwoconflicting
transitivedependenciesoverlap,meaningthatonecanfindsome
versions of the concerned library Œ∏to satisfy both constraints. The
DCissueinsuchacasecanberesolvedbyadding Œ∏asadirectdepen-
dencywithaconstraintthatentailsboth CŒ±‚ÜíŒ∏andCŒ≤‚ÜíŒ∏.Thiswill
instruct piptoinstalltheversionspecifiedbythedirectdependency
thatsatisfiesboththetransitivedependencies.Forinstance,inissue
#1586[9]of crossbar ,thereexisttwoconflictingtransitivedepen-
dencies: urllib3 /angbracketleft< 1.25‚àß‚â•1.21.1/angbracketrightand urllib3 /angbracketleft‚â•1.24.2/angbracketright.T o
resolve the conflict, developers added urllib3 /angbracketleft‚â•1.24.2‚àß< 1.25/angbracketright
as a direct dependency to avoid build failures.
Strategy6: Upgrading/downgradingdevelopmenttools(12/235).
Thedependencyconflictsbetweenthelocalenvironmentandthe
remotedependenciesareoftensolvedbyupgradingordowngrading
thedevelopment tools (e.g., issue #409 [26] of bandit).
Strategy 7: Creating an isolated environment (8/235). This is a
viable solution for resolving the dependency conflicts between
remote and locally installed dependencies. As recommended by
developersof spyder[35]and pandas[18],thereareseveraltools
such as virtualenv [43],conda[2], and pipenv[38], which can
createvirtualenvironmentstoisolatetheimpactsoflocallyinstalled
dependenciesto avoid such DC issues.
Therearenineissuesthatwerefixedbyrestrictingtheconflicting
librarytoaspecificversion.However,thisisnotagoodpracticeand
caninducenewissues(e.g.,[ 13,14,16])asdiscussedinFinding3.
Theremaining six issues were fixed by specific workarounds.
Table1summarizeshoweachpatternofissueswerefixed.From
the statistics, we can observe that there can be multiple ways to fix
DCissuesofacertainpattern.Inparticular,issuesofPatternA.a
Table 1: Statistics of manifestation patterns and fixing strategies
PatternStrategy1234567
A.a 949198
A.b 1832 16
B 4 128
can be fixed by adopting four different strategies, among which
Strategy 1 is the most wildly adopted one. This is because Python
developers have full control of the version constraints of their
projects‚Äô direct dependencies. If adopting Strategy 1 will cause
side effects such as security loopholes, developers may solve the
conflicts by upgrading or downgrading the direct dependencies of
theirprojects(Strategy2)orcoordinatingwithupstreamprojects
to adjust conflicting version constraints (Strategy 3). For Pattern
A.b, developers often adopt Strategies 2, 3, and 5 to resolve the
issues. Issues of Pattern B are mainly resolved via dealing with the
local environments. Due to the page limit, we do not make further
discussionsandwe summarize our observations in the following.
Finding5: TherecanbemultiplefixesforaDCissue.Thesolutions
canbeaffectedbytheissue‚Äôsmanifestationpattern,thetopologicalstructureoftheproject‚Äôsdependencygraph,
pip‚Äôsinstallationrules,
andtheinterferencebetweentheversionconstraintsofupstream
projects and those of downstream projects.
4 DEPENDENCY CONFLICT DIAGNOSIS
In view of many DC issues induced by complex dependenciesamong upstream and downstream projects on
PyPI, we further
propose a technique, Watchman, to continuously monitor depen-
dencyconflictsfrom the perspective of the entire ecosystem.
Figure 4 gives an overview of our technique. A major challenge
is to perform a holistic analysis of the huge number of projects on
PyPIand model their interdependent relationships, which are sub-
jecttochangeovertime.Toaddressthechallenge,Watchmanfirst
collectsthemetadataforeachlibraryversion,includingitsdirect
dependencies with version constraints and their declaration orders.Second, it consolidates the metadata of all libraries hosted on
PyPI
intoasinglerepositorytoenabletheanalysisoftheinterference
between the version constraints across upstream and downstream
projects. Then, by continuously monitoring library release infor-
mation on PyPI, Watchman synchronously updates the metadata
repositorytopreciselymodelthedependencyrelationships.Forthe
capturedlibraryupdates,Watchmanusesadepth-firstsearching
strategytoidentifytheaffecteddownstreamprojects.Italsoper-
formsabreadth-firstsearchofthemetadatarepositorytoconstruct
a full dependency graphfor each potentially affected downstream
project, according to the library installation mechanism of pip.
Finally, Watchman performs the automatic DC issue diagnosis.
4.1 Constructing Metadata Repository
Tomodelthedependencyrelationshipsamonglibraries,Watchman
uses themetadata structure to capture the version constraints of
the direct dependencies of each library version and the declaration
orders of these direct dependencies. For ease of understanding, in
the subsequent discussions, we shall use lowercase Greek letters to
denotelibrariesandsuperscriptsto denote versions.Algorithm1: IdentifyingAffected Downstream Projects
Input:LupandG
Output:Laf
1Laf‚Üê{ };
2foreachŒ∂v‚ààLupdo
3identifyAffectedLibrary (Œ∂v,Laf,G);
4Function identifyAffectedLibrary (Œ∂v,Laf,G)
5foreachG(Œ¥u)=(D,R,P)‚ààGdo
6ifŒ∂‚ààD&&vsatisfiesthe constraint CŒ¥u‚ÜíŒ∂then
7 Laf‚ÜêLaf‚à™{Œ¥u};
8 identifyAffectedLibrary (Œ¥u,Laf,G);
Definition 1 (Metadata Structure): For a library version Œ∂v,
i.e., the version vof library Œ∂,Watchman captures a collectionof
information G(Œ∂v)=(D,R,P), where
‚Ä¢D={Œ±,Œ≤,Œ≥¬∑¬∑¬∑}is a set of direct dependencies of Œ∂v.
‚Ä¢R={CŒ∂v‚ÜíŒ¥|Œ¥‚ààD}, whereCŒ∂v‚ÜíŒ¥denotes the version con-
strainton the dependency Œ¥specified by Œ∂v.
‚Ä¢Pmapseachdependency Œ¥‚ààDto its declaration order.
InourexperimentstodetectunknownDCissues,Watchman
extracted 1,423,291 versions of 191,787 distinct libraries from a
snapshot of PyPIon 15 Jun 2019. For each library version Œ∂v‚ààL,
whereLrepresentsalllibraryversions,itobtainedthestructured
metadata G(Œ∂v)via analyzing the dependency configuration script
ofŒ∂v. Such metadata of all extracted library versions formed an
initialmetadatarepository G,whichisdefinedas {G(Œ∂v)|Œ∂v‚ààL}.
This repository enables the queries of dependency relationships
amongall upstreamanddownstream projects on PyPI.
4.2 Analyzing the Impacts of Library Updates
The analysismainlyconsistsof two steps as explained below.
Step1:Monitoringlibraryupdates. Libraryupdateson PyPI
oftencauseDCissues.Therearetwotypesoflibraryupdateson
PyPI:new versions of an existing library being released andnew
librariesbeingreleased.Watchmancomputes Lupbymonitoring
thetwotypesoflibraryupdatesonadailybasis.Foreachlibrary
versionŒ∂v‚ààLup, Watchman collects the metadata G(Œ∂v)and
addsittotherepository G.Inthismanner,themetadatarepository
Gcan be synchronized with the evolution of the libraries on PyPI.
Step 2: Identifying affected downstream projects. Watch-
man performs backward search for identifying the set of down-stream projects affected by
Lup, denoted Laf, following the pro-
cessasdescribedinAlgorithm1.Thealgorithmworksasfollows.
First, it initializes Lafto an empty set (Line 1). For each library
Œ∂v‚ààLup, Watchman analyzes which libraries in the ecosystem
may be directly affected by the update via calling the function
identifyAffectedLibrary (Lines2‚Äì3),whichtakes Œ∂v,Laf,andGas
input and updates Lafwhen needed. For each piece of metadata
G(Œ¥u)=(D,R,P)inG,i fŒ∂is directly referenced by Œ¥u(i.e.,Œ∂‚ààD)
andtheversionnumber vsatisfiestheversionconstraint CŒ¥u‚ÜíŒ∂,
thenŒ¥uis possibly affected by Œ∂vand thus added to Laf. Then,
Watchman performs a depth-first search to recursively find more
downstream projects affected by Œ¥uandupdate Lafaccordingly.
4.3 Detecting DC Issues
As discussed earlier, the topological structure of a Python project‚Äôs
dependency tree determines the installed library versions. In order
	
	



 
Figure 4: The overall architecture of Watchman
todiagnoseDCissuesforeachlibraryversion Œ∂v‚ààLaf,w eneed
to analyze the relationships among all library versions that would
beinstalledby piptobuildŒ∂v.Tocapturesuchrelationships,we
propose a formal model FullDependency G raph(FDG).
Definition2(FullDependencyGraph): Thefulldependency
graph of a library version Œ∂v, denoted FDG(Œ∂v), is a three-tuple,
(N,E,FR), where
‚Ä¢N=N/prime‚à™{Œ∂v}is the set of nodes in the graph, and N/primedenotes
a set of library versions that pipinstalls for building Œ∂v. The
librarieshere include both direct and transitive dependencies.
‚Ä¢E={/angbracketleftŒ±x,Œ≤y/angbracketright|Œ±x,Œ≤y‚ààN}isasetofdirectededges,wherethe
edge from Œ±xtoŒ≤yrepresents that the version xof library Œ±
directly depends on library Œ≤.
‚Ä¢FRmapseachedges e=/angbracketleftŒ±x,Œ≤y/angbracketright‚ààEtotheversionconstraint
thatthelibrary version Œ±xsetson the library Œ≤, i.e.,CŒ±x‚ÜíŒ≤.
Note that the FDG of a library version may change overtime
whenthelibrary‚Äôsupstreamprojectsareupdatedon PyPI.Algo-
rithm 2 describes the process of constructing the FDG for a li-
brary version Œ∂v. Watchman constructs FDG(Œ∂v) following pip‚Äôs
breadth-first installation strategy: pipfirst installs direct depen-
dencies for a project, and then installs dependencies at the next
levelaccordingtotheproject‚Äôsdependencytree,andthisprocess
continues until all dependencies are installed. In the algorithm, we
use a queue named Queueto record the order of traversing and in-
stallingdependencies,and Œ∂visinitiallyaddedtothequeue.When
visitingeachdependency Œ±xinQueue,Watchmanfirstretrieves
its metadata G(Œ±x)‚â°(D,R,P). It then tries to add each depen-
dencyŒ≤inDtotheFDG.If Œ≤hasnotyetbeenloaded(orinstalled),
Watchmandeterminestheversiontobeloadedbasedonconstraint
CŒ±x‚ÜíŒ≤(recordedin R)following pip‚Äôsinstallationrules(Line8).
NandQueuearethenupdatedaccordingly(Line9).If Œ≤hasalready
beenaddedtotheFDG,Watchmanwillretrievetheloadedversion
(Line 11). A new edge /angbracketleftŒ±x,Œ≤y/angbracketrightis then added to E(Line 12). The
algorithmusesanotherqueue VisitedEd–¥es to record the orderin
whichtheedgesaretraversed(Line13).Watchmanalsosetsthe
version constraint of this edge (Line 14), which can be retrieved
fromR.Aftertraversingalldependenciesin Queue,theFDGofa
library is completely constructed.
DC Issue Detection. WatchmandetectsDC issuesby analyz-
ing the FDG of eachproject Œ∂v‚ààLafin the following steps. First,
Watchmantraverses FDG(Œ∂v)andlocatesthosenodeswithmul-
tipleincomingedges.Anodehasmultipleincomingedgeswhen
there aremultiple projectsthat directlydepend onthe libraryrep-
resented by the node. Next, for each such node Œ±x, Watchman
analyzesthesetofitsincomingedges,denoted EŒ±.Notethatthereis
oneedgeeinEŒ±thatistraversedfirstwhenconstructing FDG(Œ∂v).
Suppose that xis the latest version number of the library Œ±that
satisfies the constraint FR(e). To detect DC issues, Watchman
checksxagainst the set of constraints associated with other edges
inEŒ±,i.e.,{FR(e/prime)|e/prime‚ààEŒ±\{e}}.Ifxviolatesanysuchconstraints,
Watchman willreport a DC issue to the project Œ∂.Algorithm2: ConstructingFDG viaBreath-First Search
Input:Œ∂vandG
Output:FDG(lv)=(N,E,FR)
1N‚Üê{Œ∂v};E‚Üê{ };FR‚Üê{ };
2Queue.add(Œ∂v);Loaded‚Üê{Œ∂};VisitedEd–¥es ‚Üê{ };
3while!Queue.isEmpty ()do
4Œ±x‚ÜêQueue.pop();Loaded‚ÜêLoaded‚à™{Œ±};
5G(Œ±x)‚â°(D,R,P)‚ÜêgetMetadata( Œ±x,G);
6foreachŒ≤‚ààDdo
7 ifŒ≤/nelementLoaded then
8 Œ≤y‚ÜêgetToLoadVersion( Œ≤,CŒ±x‚ÜíŒ≤);
9 N‚ÜêN‚à™{Œ≤y};Queue.add(Œ≤y);
10 else
11 Œ≤y‚ÜêgetLoadedVersion( Œ≤,N);
12 E‚ÜêE‚à™{/angbracketleftŒ±x,Œ≤y/angbracketright};
13 VisitedEd–¥es .add(/angbracketleftŒ±x,Œ≤y/angbracketright);
14 FR(/angbracketleftŒ±x,Œ≤y/angbracketright)‚ÜêCŒ±x‚ÜíŒ≤;
4.4 Predictive Analysis for DC Issues
The constructed FDGs by Watchman can also enable us to per-
formpredictiveanalysis for proactiveprevention of DC issuesvia
detectingthe two types of smells discussed earlier (Findings 3‚Äì4).
Type 1:Restricting a dependency to a specific version. If a project
restrictsadependencytoaspecificversion,itsdownstreamprojects
may suffer from DC issues. Specifically, DC issues may arise if the
following conditionshold:
(1) There is a version vof project Œ∂, denoted Œ∂v, that restricts
itsdirect dependency Œ±to a specific version x.
(2) There is a version yof a downstream project Œ≤that depends
onbothŒ∂andŒ±,andŒ∂vandŒ±xaretheinstalledlibraryversions
forŒ≤yat the time of analysis.
LetDPbe the set of downstream projects (e.g., Œ≤) thus found.
The larger |DP|is, the more likely that DC issues can arise. This
isbecauseeachprojectin DPindependentlysetsitsownversion
constraintson Œ±.IfŒ∂vonlyacceptstheversion xofŒ±,thepossibility
thattheconstraint /angbracketleft=x/angbracketrightconflictswithotherconstraintson Œ±set
bytheprojectsin DPishigh,especiallywhen DPislarge.Inour
experiments,wewillwarnthedevelopersoftheproject Œ∂,if|DP|
is larger than a threshold value, which is set empirically.
Figure 5(a) gives an illustrative example. In project C2.0, the
constraint for library Ais restricted to /angbracketleft=2.0/angbracketright. In addition, C‚Äôs
downstream project B5.0depends on both C2.0and A2.0. In such
a case, it is very likely that the restrictive constraint Csets on A
would cause conflicts for B(e.g., when Agets updated on PyPI).
The risk of conflicts gets higherif we find more such downstream
projects. Watchman will find such cases and suggest project C‚Äôs
developerstorelaxitsconstrainton A,toavoidpotentialDCissues.
Type 2:The installed version of a library is close to the upper
bound specified in the version constraint. If the installed version of a
library satisfies the concerned version constraint but is close to the
upperboundspecifiedintheconstraint,buildfailuresmayoccur
when the library evolves. Watchman deems that a project Œ∂vhas
a potential DC issue, if the following conditions hold:
 

.
-

-

..' -)
/*
-,.+.(
	

	
	(&'&
(&+&
(&
 +&(&(&
*&*&
(&
  "!#%!#$!# !#


	
 	
Figure 5: Illustrative examples of potential DC issues
(1)InFDG(Œ∂v)=(N,E,FR),thereexistsanode Œ±uwithmultiple
incomingedges,where Œ±isadependencyof Œ∂vanduistheinstalled
version of Œ±. LetEŒ±be the set of incoming edges to Œ±u.
(2)Theversionconstraintofthefirsttraversededge einEŒ±does
not specify an upper bound on Œ±(e.g., the constraint is of the form
/angbracketleft‚â•y/angbracketright)orthespecifiedupperboundisgreaterthan Œ±‚Äôlatestversion
zonPyPI. In this case, any updates of Œ±onPyPIwill affect the
version of Œ±to be installed.
(3) There exists another edge e/primeinEŒ±(e/prime/nequale), of which the
associatedconstraint FR(e/prime)specifiesanupperboundontheversion
ofŒ±(e.g., the constraint is of the form /angbracketleft‚â§x/angbracketright) and the upper bound
is greater than or equal to the latest version of Œ±, i.e.,z.
Figure5(b)givesanillustrativeexample.IntheFDGofproject
Q5.0,therearetwoincomingedgestoproject T4.0,onefromproject
X2.0and the other from project P4.0. Suppose that the former edge
is traversed before the latter. Since the constraint that X2.0sets on
Thasnoupperbound,thelatestversion4.0of Twillbeinstalled.
Thereisnodependencyconflictat thetimeofanalysis. However,
sincetheconstraintassociatedwithlatteredge,i.e., /angbracketleft>2.0‚àß‚â§4.0/angbracketright,
restricts Ttoaversionrange,buildfailuresmayoccurifdevelopers
release a newer version (e.g., 4.1) of TonPyPI.
5 EVALUATION
To evaluate Watchman, we study two research questions:
‚Ä¢RQ3 (Effectiveness): How effective is Watchman in detecting
real DC issues and predicting potential ones?
‚Ä¢RQ4 (Usefulness): Can Watchman monitorDC issues in PyPI
andprovide useful diagnostic information to developers?
ToanswerRQ3,wereplayedtheevolutionhistoryofalllibraries
onPyPIfrom1Jan2017to30Jun2019.Wefirstconstructedameta-
data repository for PyPI‚Äôs snapshot on 1 Jan 2017, and then con-
ducted incremental analysis to extract daily updates of all libraries
until30Jun2019.Foreachlibraryupdate,weappliedWatchman
todetectDCissuesandpredictpotentialonesviaidentifyingde-
pendency smells. Since we have the whole evolution history, we
couldevaluateWatchman‚Äôseffectivenessbycheckingwhetherthe
detected DC issues have been resolved and whether the predicted
oneshave indeed evolved into real issues subsequently.
To answer RQ4, we deployed Watchman to monitor PyPIsince
1 Jul 2019, and configured it to detect new DC issues of Pattern
A, as well as potential ones that could be induced by the smells
ofType1andType2.NotethatissuesofPatternBcanhardlybe
detected since they are affected by developers‚Äô local environments,
on which we have no knowledge.
We then consolidated the detected DC issues and submitted
reportstotheconcernedprojects‚Äôissuetrackingsystems;if:(1)the
detectedissueshavenotbeenreportedorfixedintheunreleasedTable 2: Basic information of experimental subjects
Period1 Period2 Period3 Period4 Period5
#Projects 1,454 1,535 2,279 2,398 2,673
#Releases 11,759 13,202 18,418 18,984 19,746
#Commits 530 646 338 740 694
masterbranchesoftheprojectsand(2)theconcernedprojectshavemaintenancerecordsinthelasttwoyears(stillactive).Ineachissue
report, we pointed out the detected conflicts and explained how
they arose. Such diagnostic information can be easily provided by
Watchmansinceitsimulatesthebuildprocessofeachproject.The
report also includes fixing suggestions generated by Watchman
based on our observed common fixing strategies.
5.1 RQ3: Effectiveness
Datacollection. Aproject‚Äôsevolutionhistoryprovidesusefulin-
formation about how DC issues manifested themselves (and gotfixed). To ease experiments, we divided the whole time period
from 1 Jan 2017 to 30 Jun 2019 into the following five sub-periods:
1Jan2017‚Äì30Jun2017(Period1),1Jul2017‚Äì31Dec2017(Period2 ),
1 Jan 2018‚Äì30 Jun 2018 (Period 3 ), 1 Jul 2018‚Äì31 Dec 2018 (Period
4),and1Jan2019‚Äì30Jun2019(Period5 ).Foreachsub-period,we
collected open-source Python projects satisfying the following two
criteria as our experimental subjects: (1) having more than five re-
lease versions during this sub-period (active), and (2) having more
than 300 commits during this sub-period (well-maintained). Ta-
ble2liststhebasicinformationofthesesubjects.Onaverage,there
are16,421releasesof2,067projectsforeachsub-period.Wethen
appliedWatchmantodetectDCissuesofPatternAandpredictpo-
tentialonesthatmaybeinducedbysmellsofType1(Type1issues)
andType 2 (Type 2 issues), during each of the five sub-periods on
a daily basis.
Evaluation metrics. To evaluate Watchman‚Äôs effectiveness,
we define two metrics, resolving ratio andlasting time :
‚Ä¢For each detected issue of Pattern A, we checked whether it had
been resolved in the latest version of the project released on
PyPI,upto thedate20Jul2019.The metric resolvingratio mea-
surestheproportionofresolvedDCissuesinthosedetectedby
Watchman. Higher resolving ratios indicate better effectiveness
of Watchman.Themetric lastingtime measuresthegapbetween
the detection time of a DC issue and the resolving time of this
issue. A longer lasting time indicates a wider impact caused by a
DC issue on the concerned downstream projects.
‚Ä¢For the predicted issues, we checked whether they had turned
intorealones.Therearetwocases:(1)thepredictedissueindeed
arose (reported) in history due to library updates, and was fixed
by developers in subsequent project releases; (2) the predicted
issuewasnotreportedinhistorybutdevelopersstillfixeditto
avoid certain undesirable consequences. Accordingly, the metric
resolvingratio measurestheproportionofthepredictedDCissues
thatbelong to either case. The metric lastingtime measures the
gap between the time an issue was predicted and the time it wasreported for Case (1), and the gap between the time an issue was
predicted and the time it was resolved by developers for Case (2).
Results. Table 3 presents the experimental results. For all the
fivesub-periods,Watchmandetectedatotalof369DCissuesofPat-
tern A, and all of them had been fixed by developers (i.e., resolving
ratio= 100%). This strongly suggests that Watchman can precisely
Table 3: Results of DC issues reported by Watchman from 1 Jan
2017 to 30 Jun 2019
Period1Period2Period3Period4Period5Summar y
PatternA 56 42 84 72 115 369‚ãÜ
Fixed 56 42 84 72 115 369‚ãÜ
Resolving ratio 100% 100% 100% 100% 100% 100%/natural
Lastingtime (days) 25.2 27.3 25.0 20.8 31.6 26.0/natural
Type 1 10 13 12 11 15 61‚ãÜ
Type2 16 18 19 21 21 95‚ãÜ
Case(1) 2 2 3 4 2 13‚ãÜ
Case(2) 22 25 26 26 31 130‚ãÜ
Resolving ratio 92.3% 87.1% 93.5% 93.8% 91.7% 91.7%/natural
Lastingtime (days) 101.6 77.1 100.8 51.0 63.9 78.9/natural
/naturaldenotesthe average value while ‚ãÜdenotes the sum.
detectDCissues.Watchmanalsopredictedatotalof156Type1and
Type2issues,143ofwhichhadbeenresolvedbydevelopers,result-
inginanaverage resolvingratio of91.7%( =(13+130)/(61+95)).The
resolvingratio ofthepredictedissuesfordifferentperiodsranges
from87.1%to93.8%,whicharegenerallysatisfactory.Thissuggests
that Watchman is also effective in predicting potential DC issues.
Besides, we observed that all detected 369 DC issues were resolved
by developers within amonth (on average,26 days). Watchman
mayhelpreduce thisdelaysinceitcan detectDCissuestimely(it
performsanalysison adailybasis)and reportthemtodevelopers
along with fixing suggestions. If developers are able to fix Watch-
man‚Äôs detectedissues in duecourse, the sideeffect of theseissues
on downstream projects will be largely diminished.
As at 20 Jul 2019, 13 (8.7%) of the 156 DC issues predicted by
Watchman had not evolved into real ones. By further analyzing
the concerned projects,we found that the dependenciesintroduc-
ing these issueswere no longer active. For instance, in the project
finance-dl [5], Watchman found multiple version constraints
for library idna. When building finance-dl ,pipwould install
version2.8 of idna, whichis equal tothe upperbound ofthe con-
straint/angbracketleft‚â•2.5‚àß‚â§2.8/angbracketrightintroduced by the latest version of the
library selenium-requests . However, this potential DC issue
(Type2)didnotevolveintoarealone,since selenium-requests
hadstopped its update on PyPI(at our study time).
5.2 RQ4: Usefulness
Watchmandetectedandpredictedatotalof189DCissuessince
we started our online monitoring on 1 Jul 2019. We filtered out
23 issues that had been reported in the corresponding projects‚Äô
issue tracking systems and 49 issues whose associated projects had
no maintenance record in the last two years. After filtering, we
reported the remaining 117 DC issues to developers. As shown
inTable4,63issues(53.8%)wereconfirmedbydevelopersasreal
DC issues within a few days. 38 out of the 63 confirmed issues
(60.3%) were quickly fixed, and 25 confirmed issues (38.7%) are
under fixing. The remaining 54 issues are still pending, mainly due
to inactive maintenance of the associated projects. We provide a
detailed analysis in the following.
5.2.1 Feedback on reported issues. For 64 detected issues of
Pattern A,which were causedby libraryupdates, Watchmangot
a higher confirmation rate (60.9% = 39/64), which is within our
expectation.Forthese39confirmedDCissues,developersagreed
thatthedetectedconflictswouldcausebuildfailures,andinvitedus to submit patches to help resolve them. For instance, in issue
report #70 [ 32] of the project Osmedeus , the developer mentioned
that they had indeed encountered our reported DC issue when
deployingtheproject,andleftacomment‚ÄúIalsogetthaterrorwhen
installingtheprojectbutmyserverworksfine.JustsubmitaPRandI
willreview the patch ‚Äù.
Forthe21predictedDCissuesofType1,11ofthemhavealready
been spotted by developers and resolved in the master branches of
thecorrespondingprojects(butnotyetreleasedon PyPI)before
we reported them. For instance, the project MycroftAI adapt
relaxed its version constraint on library sixfrom/angbracketleft=1.10.0/angbracketrightto
/angbracketleft‚â•1.10.0/angbracketrightincommit 7eeadeb [1]withalog‚Äútoavoidincompati-
bility with downstream projects adapt-parser and jsonschema ‚Äù.
Therefore,wereportedonlytheremaining10issuesofType1to
thedevelopersofthecorrespondingprojects,and4ofthemhave
beenconfirmedbydevelopers.Encouragingly,intheissuereport
#182[12]oftheproject dynamic-prefer -ences ,wegotthefol-
lowing comment from developers after they resolved our reported
issue:‚ÄúItisahazzletokeeptrackofallthefrozenversionsofsome
dependencies,especiallyforlargerprojects.Ithinkitwouldbegoodto
getan automaticnotificationas maintainersomehow,if oneofyour
dependencieshaslocked its own libraries on a specific version.‚Äù
For the 43 predicted Type 2 issues, 20 of them have been con-
firmed by developers, although these issues may not cause build
failuresimmediately.Weobservedthatsomeof Watchman‚Äôswarn-
ings quickly caught developers‚Äô attention, and they added labels
‚Äúbug‚Äùand‚Äúdeploymentproblem‚Äùtoourissuereports(e.g.,[ 19,20]).
Among the 63 confirmed DC issues (including both detected
and predicted ones), developers resolved 54 (85.7%) of them follow-
ingoursuggestedsolutions.Forexample,wereportedanissueof
PatternA.atothedevelopersof webinfo alongwiththreefixing
solutions(issue #9[ 34]).Thedeveloperchosethe oneWatchman
generated based on Strategy 2 to resolve this conflict. For the re-
mainingnineconfirmed issues, for which our fixing solutions have
notbeenadoptedbydevelopers,wefoundthattheseprojectscan
besensitivetocertainlibraryupdatesandoursuggestedchanges
might introduce other side effects, such as vulnerability or compat-
ibilityissues(e.g., issue #16 [10] in project kindred).
5.2.2 Feedback on Watchman. Besides confirming our reported
DC issues, some developers expressed interests in our tool Watch-
man.Forexample,adeveloperleftthefollowingcommentinthe
pullrequest #71 [40] of the project arxiv-submission-core:
‚ÄúAbettermechanismofmaintainingthedependencyconstraints
amongprojects on PyPIlikewhatyou did, is much-needed! ‚Äù
In issue report #492 [ 30] of the project pywb, we found an en-
couraging comment from an experienced lead developer who is
also thefounderof the webrecorder community[4]:
‚ÄúAre you an ‚Äôautomation‚Äô written by Github community to help
resolvedependencyconflictissuesforPythonprojects?Ifso,apieceof nice work! I‚Äôd say this is a good approach, a nice friendly bot to
informof potential dependency issues.‚Äù
Such feedback indicates that monitoring library updates and
detecting/predictingdependencyconflictsisindeedimportantto
andwelcomedbyreal-worldPythondevelopers.Theinformation
provided by Watchman is also useful to help developers diagnose
DC issues in practice.
Table 4: Results of 117 DC issues reported by Watchman from 11 Jul 2019 to 16 Aug 2019
Manifestation Issuereports (Each item gives the issue report ID and the project name)
PatternA.aIssue#1,aucome; Issue#110, crypto; Issue#1,OrcaSong; Issue#2,pypmml-spark; Issue#138, toolium; Issue#26, GatewayFramework; Issue#56, Airbnb-data; Issue#2,Runcible;
Issue#95, identification; Issue#96, identification; Issue#1813, tasking-manager; Issue#356, Archery; Issue#325, bocadillo; Issue#21, crema; Issue#4,what-digit-you-write;
Issue#9,webinfo-crawler; Issue#35, zarp;Issue#4,open-helpdesk; Issue#5,languagecrunch;Issue#103, account-cr eator;Issue#9,jawfish; Issue#212, openpose-plus; Issue#16, kindred;
Issue#13, Generator-GUI; Issue#3,tabular; Issue#5,whats-bot; Issue#65, armory-bot; Issue#39, derrick; Issue#16, Historical-Prices; Issue#688, dxr;Issue#18526, erpnext;
Issue#1,scrapy-qtwebkit; Issue#4778, InstaPy; Issue#2,api-indotel; Issue#145, cert-issuer; Issue#146, django; Issue#4,pymacaron; Issue#1,mgz-db; Issue#1,twitterbots;
Issue#2,gremlin; Issue#17, AWSBucketDump; Issue#198, fabric-cli; Issue#1,BlockCluster; Issue#3,gateway; Issue#2,beauty_image; Issue#1389, Indy-node; Issue#130, swapi;
Issue#279, explorer; Issue#34footmark; Issue#3,driver-acs; Issue#56, driver-napi; Issue#11, simulator; Issue#9,Friends-Finder; Issue#1,chatbot-template; Issue#545, djangopackages;
Issue#2048, cadasta-platform; Issue#122, adminset; Issue#45, Wallpaper; Issue#21, ltiauthenticator; Issue#28, cryptography;
PatternA.b Issue#243, bakerydemo;Issue#4,pytools;Issue#70, Osmedeus;Issue#101, aldryn-search;
Type 1Issue#182, dynamic-preferences; Issue#20, ldapdomaindump; Issue#326, py-cluster; Issue#986, faker; Issue#717, newspaper; Issue#120, mixer; Issue#3,client-python;
Issue#75, PyInquirer;Issue#953, compressor;Issue#26, certstream;
Type 2Issue#8,AutoCrawler; Issue#31, BBScan; Issue#492, pywb; Issue#8,ct-exposer; Issue#71, EagleEye; Issue#1179, mythril; Issue#1,frida-util; Issue#34, python-urwid;
Issue#4,SecurityManageFramwork; Issue#295, sherlock;Issue#2077, freqtrade; Issue#36, trains;Issue#298, glastopf; Issue#5,Machine-Learning-with-Python; Issue#569, kalliope;
Issue#98, bless;Issue#70, arxiv-submission-core; Issue#2729, plaso;Issue#17, oauth-dropins; Issue#303, ripping-machine; Issue#27, ChannelBreakoutBot; Issue#167, tldextract;
Issue#183, messytables; Issue#9,kuberdock-platform; Issue#42, python-weixin; Issue#25, NoDB; Issue#146, Photon; Issue#911, pyspider; Issue#7,fan;Issue#126, historical;
Issue#49, stephanie-va; Issue#979, subliminal; Issue#56, WPSeku; Issue#3,zhihu-crawler; Issue#38, network-topology; Issue#647, marathon-lb; Issue#9,Konan; Issue#181, JBOPS;
Issue#962, hangoutsb ot;Issue#41, GyoiThon; Issue#120, automation-to ols;Issue#4,start-vm; Issue#10, ahmia-inde x;
Status1: The issueshave already been fixed using our suggested solutions; Status2: The issues have already been fixed using other solutions; Status3: The issues have been confirmed and are under fixing
usingour suggested solutions. Status4: The issues have been confirmed and are under fixing using other solutions. Status5: The issues are still pending.
We do not present the link of these issues due to page limit. The detailed information of them can be found on our project website (http://www.watchman-pypi.com/buglist).
6 DISCUSSIONS
Threatstovalidity. Keywordsearchcanintroduceirrelevantis-
suesintoourdataset.Suchnoisesposeathreattothevalidityofour
studyresults.TheerrorsinourmanualanalysisoftheDCissues
may also affect our study results. To reduce these threats, three
co-authors independently investigated our collected DC issues and
cross-validated their analysis results.
Limitations. Our work has three limitations. First, we focus on
the DC issues that cause build failures. However, in some cases,
dependencyconflictsmayleadtosemanticinconsistencies,runtime
errors, or other consequences in Python projects. Second, the rules
adopted in the predictive analysis can only help find a subset ofall possible DC issues that may be induced by the two types of
dependency smells. The rule set is designed based on our observed
realcasesintheempiricalstudyandisnotmeanttobecomplete.
Third, Watchman currently is not able to detect all patterns of
DCissuesobservedinourempiricalstudy.Wewilladdressthese
limitationsin future work.
7 RELATED WORK
Studies of dependency conflicts. Pradel et al. [ 52] studied the
dependency conflicts among JavaScript libraries and proposed a
detectionstrategy.Suzakietal.[ 45]conductedanextensivecase
study of conflict defects, including conflicts on resource access,
conflictsonconfigurationdata,andinteractionsbetweenuncom-
moncombinationsofpackages.Soto-Valeroetal.[ 54]studiedthe
problem of multiple versions of the same library co-existing in
Maven Central , and presented empirical evidence about how the
immutability of artifacts in Maven Central supports the emer-
gence of natural software diversity. Wang et al. [ 56] conducted
an empirical study to characterize dependency conflicts in Java
projects and developed Riddle to generate tests to collect crashing
stack traces to facilitate DC issue diagnosis [ 57]. To the best of our
knowledge,thereisnopreviousworkfocusingoncharacterizing
anddetectingDC issues in the Python world.
Studiesofsoftwareecosystem. Serebrenik et al. [ 53] performed
ameta-analysisofthedifficulttasksinsoftwareecosystemresearchandidentifiedsixtypesofchallenges,e.g.,howtoscaletheanalysis
to a massive amount of data. Mens [ 50] studied software ecosys-
tem from the socio-technical view on software maintenance and
evolution. Zimmermann et al. [ 59] studied the security risks in the
npmecosystem by analyzing data such as dependencies between
packagesandpubliclyreportedsecurityissues.Anotherstudyby
Lertwittayatraietal.[ 48]usednetworkanalysistechniquestostudy
the topology of the JavaScript package ecosystem and extracted
insights about dependencies and their relations. Our work studies
softwareecosystemfromanovelperspectivebytakingintoaccount
the interferencebetween the version constraints of upstream and
downstream projects. We also propose a technique to continuously
monitordependencyconflictsforPythonprojects.
8 CONCLUSION AND FUTURE WORK
In this work, we first conducted an empirical study of 235 real
dependency conflict issues in Python projects to understand the
manifestation patterns and fixing strategies of dependency conflict
issues.Motivatedbyourempiricalfindings,wethendesignedatech-
nique,Watchman,tocontinuouslymonitordependencyconflicts
forthe PyPIecosystem.EvaluationresultsshowthatWatchman
can effectively detect dependency conflict issues with a high preci-
sion andprovide useful diagnostic informationto help developers
fixtheissues.Infuture,weplantofurtherimprovethedetection
capability of Watchman and generalize our technique to other
Python library ecosystems such as Anaconda to make it accessible
to more developer communities.
ACKNOWLEDGMENTS
Theauthorswouldliketosincerelythanktheanonymousreviewers
of ICSE 2020 for their constructive comments that helped improve
this paper. Part of the work was conducted during the first au-
thor‚Äôs internship at HKUST in 2018. This work is supported by the
NationalNaturalScienceFoundationofChina(grants#61932021,
#61902056, #61802164, #61977014), the Hong Kong RGC/GRF grant
#16211919, MSRA grant, and the Program for University Key Labo-
ratory of Guangdong Province (Grant #2017KSYS008).
REFERENCES
[1]2020. Commit7eeadebofadapt. https://github .com/MycroftAI/adapt/commit/
7eeadeb4744b7e2dd7a9aa61e0350c4e22350eba. (2020). Accessed: 2020-02-06.
[2] 2020. conda. https://conda .io/.(2020). Accessed: 2020-02-06.
[3]2020. Dependency specification for Python. https://www .python.org/dev/peps/
pep-0508/. (2020). Accessed: 2020-02-06.
[4]2020. An experienced developer. https://github .com/ikreymer. (2020). Accessed:
2020-02-06.
[5]2020. finance-dl. https://github .com/jbms/finance-dl. (2020). Accessed: 2020-02-
06.
[6]2020. Issue #1277 of channels. https://github .com/django/channels/issues/1277.
(2020). Accessed: 2020-02-06.
[7]2020. Issue #152 of channels. https://github .com/django/
channels_redis/issues/152. (2020). Accessed: 2020-02-06.
[8]2020. Issue#1525ofmolecule. https://github .com/ansible-community/molecule/
issues/1525.(2020). Accessed: 2020-02-06.
[9]2020. Issue#1586ofcrossbar. https://github .com/crossbario/crossbar/issues/1586.
(2020). Accessed: 2020-02-06.
[10]2020.Issue#16ofkindred.https://github .com/jakelever/kindred/issues/16.(2020).
Accessed: 2020-02-06.
[11]2020. Issue#1607ofmolecule. https://github .com/ansible-community/molecule/
issues/1607.(2020). Accessed: 2020-02-06.
[12]2020. Issue#182ofdynamic-preferences. https://github .com/EliotBerriot/django-
dynamic-preferences/issues/182. (2020). Accessed: 2020-02-06.
[13]2020. Issue#1824ofallennlp. https://github .com/allenai/allennlp/issues/1824.
(2020). Accessed: 2020-02-06.
[14]2020. Issue#2195ofallennlp. https://github .com/allenai/allennlp/issues/2195.
(2020). Accessed: 2020-02-06.
[15]2020. Issue #229 of gallery-dl. https://github .com/mikf/gallery-dl/issues/229.
(2020). Accessed: 2020-02-06.
[16]2020. Issue#2483ofallennlp. https://github .com/allenai/allennlp/issues/2483.
(2020). Accessed: 2020-02-06.
[17]2020. Issue #25316 of pandas. https://github .com/pandas-dev/pandas/issues/
25316.(2020). Accessed: 2020-02-06.
[18]2020. Issue #25487 of pandas. https://github .com/pandas-dev/pandas/issues/
25487.(2020). Accessed: 2020-02-06.
[19]2020. Issue#2729ofplaso. https://github .com/log2timeline/plaso/issues/2729.
(2020). Accessed: 2020-02-06.
[20]2020. Issue #295 of sherlock. https://github .com/sherlock-project/sherlock/
issues/295.(2020). Accessed: 2020-02-06.
[21]2020. Issue #3118 of pipenv. https://github .com/pypa/pipenv/issues/3118. (2020).
Accessed: 2020-02-06.
[22]2020. Issue #32 of valinor. https://github .com/ARMmbed/valinor/issues/32.
(2020). Accessed: 2020-02-06.
[23]2020. Issue#36ofdbxfs. https://github .com/rianhunter/dbxfs/issues/36.(2020).
Accessed: 2020-02-06.
[24]2020. Issue#3826ofrasa. https://github .com/RasaHQ/rasa/issues/3826.(2020).
Accessed: 2020-02-06.
[25]2020. Issue#407ofwandb/client. https://github .com/wandb/client/issues/407.
(2020). Accessed: 2020-02-06.
[26]2020. Issue #409 of bandit. https://github .com/PyCQA/bandit/issues/409. (2020).
Accessed: 2020-02-06.
[27]2020. Issue #4669 of requests. https://github .com/psf/requests/pull/4669. (2020).
Accessed: 2020-02-06.
[28]2020. Issue #4674 of requests. https://github .com/psf/requests/pull/4674. (2020).
Accessed: 2020-02-06.
[29]2020. Issue #4675 of requests. https://github .com/psf/requests/pull/4675. (2020).
Accessed: 2020-02-06.
[30]2020. Issue #492 of pywb. https://github .com/webrecorder/pywb/issues/492.
(2020). Accessed: 2020-02-06.
[31]2020. Issue #66 of pythoncoveralls. https://github .com/z4r/pythoncoveralls/
issues/66.(2020). Accessed: 2020-02-06.
[32]2020. Issue #70 of Osmedeus. https://github .com/j3ssie/Osmedeus/issues/70.
(2020). Accessed: 2020-02-06.
[33]2020. Issue #740 of yotta. https://github .com/ARMmbed/yotta/issues/740. (2020).
Accessed: 2020-02-06.
[34]2020. Issue #9 of webinfocrawler. https://github .com/lubosson/webinfocrawler/
issues/9.(2020). Accessed: 2020-02-06.
[35]2020. Issue#9090ofspyder. https://github .com/spyder-ide/spyder/issues/9090.
(2020). Accessed: 2020-02-06.[36] 2020. pip. https://pypi .org/project/pip/.(2020). Accessed: 2020-02-06.
[37]2020. pip documentation. https://pip .pypa.io/en/stable/reference/pip_install.
(2020). Accessed: 2020-02-06.
[38] 2020. pipenv. https://docs .pipenv.org/.(2020). Accessed: 2020-02-06.
[39]2020. PR#1675ofmolecule. https://github .com/ansible-community/molecule/
pull/1675.(2020). Accessed: 2020-02-06.
[40]2020. PR #71 of arxiv-submission-core. https://github .com/arXiv/arxiv-
submission-core/pull/71.(2020). Accessed: 2020-02-06.
[41]2020. Project molecule. https://github .com/ansible-community/molecule. (2020).
Accessed: 2020-02-06.
[42] 2020. PyPI. https://pypi .org/.(2020). Accessed: 2020-02-06.
[43]2020. virtualenv. https://virtualenv .pypa.io/en/latest/.(2020). Accessed:2020-
02-06.
[44]Pietro Abate and Roberto Di Cosmo. 2011. Predicting upgrade failures using
dependency analysis. In Proceedings of the IEEE 27th International Conference on
DataEngineeringWorkshops. 145‚Äì150.
[45]Cyrille Artho, Kuniyasu Suzaki, Roberto Di Cosmo, Ralf Treinen, and Stefano
Zacchiroli.2012. Whydosoftwarepackagesconflict?.In Proceedingsofthe9th
IEEEWorking Conference on Mining Software Repositories (MSR‚Äô18). 141‚Äì150.
[46]Alexandre Decan, Tom Mens, and Maelick Claes. 2016. On the topology of
packagedependencynetworks:Acomparisonofthreeprogramminglanguage
ecosystems. In Proccedings of the 10th European Conference on Software Architec-
ture Workshops. 21.
[47]Jiajun Hu, Lili Wei, Yepang Liu, Shing-Chi Cheung, and Huaxun Huang. 2018.
ATaleofTwoCities:HowWebViewInducesBugstoAndroidApplications.In
Proceedings of the 2018 33rd ACM/IEEE International Conference on Automated
Software Engineering (ASE‚Äô18). 702‚Äì713.
[48]Nuttapon Lertwittayatrai, Raula Gaikovina Kula, Saya Onoue, Hideaki Hata,
ArnonRungsawang,PattaraLeelaprute,andKenichiMatsumoto.2017.Extracting
insightsfromthetopologyofthejavascriptpackageecosystem.In Proceedingsof
the 24thAsia-Pacific Software Engineering Conference (APSEC‚Äô17). 298‚Äì307.
[49]Yepang Liu, Chang Xu, and Shing-Chi Cheung. 2014. Characterizing and detect-
ing performance bugs for smartphone applications. In Proceedings of the 36th
InternationalConference on Software Engineering, (ICSE‚Äô14) . 1013‚Äì1024.
[50]Tom Mens. 2016. An ecosystemic and socio-technical view on software mainte-
nanceandevolution.In 2016IEEEInternationalConferenceonSoftwareMainte-
nanceandEvolution (ICSME‚Äô16). 1‚Äì8.
[51] FabioNelli.2015. Pythondataanalytics. Berkeley: Apress (2015).
[52]Jibesh Patra, Pooja N Dixit, and Michael Pradel. 2018. Conflictjs: Finding and
understandingconflictsbetweenjavascriptlibraries.In Proceedingsofthe40th
InternationalConference on Software Engineering (ICSE‚Äô18) . 741‚Äì751.
[53]Alexander Serebrenik and Tom Mens. 2015. Challenges in software ecosystems
research. In Proceedings of the 2015 European Conference on Software Architecture
Workshops. 40.
[54]C√©sarSoto-Valero,AmineBenelallam,NicolasHarrand,OlivierBarais,andBenoit
Baudry.2019. TheEmergenceofSoftwareDiversityinMavenCentral.In Pro-
ceedings of the 16th IEEE Working Conference on Mining Software Repositories
(MSR‚Äô19). 1‚Äì11.
[55]Marat Valiev, Bogdan Vasilescu, and James Herbsleb. 2018. Ecosystem-level
determinantsofsustainedactivityinopen-sourceprojects:Acasestudyofthe
PyPI ecosystem. In Proceedings of the 2018 26th ACM Joint Meeting on European
SoftwareEngineeringConferenceandSymposiumontheFoundationsofSoftware
Engineering(ESEC/FSE‚Äô18). 644‚Äì655.
[56]Ying Wang, Ming Wen, Zhenwei Liu, Rongxin Wu, Rui Wang, Bo Yang, Hai Yu,
Zhiliang Zhu, and Shing-ChiCheung. 2018. Do the dependency conflicts in my
projectmatter?.In Proceedingsofthe201826thACMJointMeetingonEuropean
SoftwareEngineeringConferenceandSymposiumontheFoundationsofSoftware
Engineering(ESEC/FSE‚Äô18). 319‚Äì330.
[57]YingWang,MingWen,RongxinWu,ZhenweiLiu,ShinHweiTan,ZhiliangZhu,
HaiYu,andShing-ChiCheung.2019. CouldIHaveaStackTracetoExaminethe
DependencyConflictIssue?.In Proceedingsofthe41thInternationalConference
on Software Engineering (ICSE‚Äô19). 572‚Äì583.
[58]Lili Wei, Yepang Liu, and Shing-Chi Cheung. 2016. Taming Android Fragmenta-
tion: Characterizing and Detecting Compatibility Issues for Android Apps. In
Proceedingsofthe31stIEEE/ACMInternationalConferenceonAutomatedSoftware
Engineering,(ASE‚Äô16). 226‚Äì237.
[59]MarkusZimmermann,CristianalexandruStaicu,CamTenny,andMichaelPradel.
2019. Small World with High Risks: A Study of Security Threats in the npm
Ecosystem. arXiv:Cryptography and Security (2019).
