Trace-Checking CPS Properties:
Bridging the Cyber-Physical Gap
Claudio Menghi
University of Luxembourg
Luxembourg, Luxembourg
claudio.menghi@uni.luEnrico ViganÃ²
University of Luxembourg
Luxembourg, Luxembourg
enrico.vigano@uni.luDomenico Bianculli
University of Luxembourg
Luxembourg, Luxembourg
domenico.bianculli@uni.luLionel C. Briand
University of Luxembourg
Luxembourg, Luxembourg
University of Ottawa
Ottawa, Canada
lionel.briand@uni.lu
Abstract â€”Cyber-physical systems combine software and physi-
cal components. Speciï¬cation-driven trace-checking tools for CPS
usually provide users with a speciï¬cation language to express
the requirements of interest, and an automatic procedure to
check whether these requirements hold on the execution traces
of a CPS. Although there exist several speciï¬cation languages
for CPS, they are often not sufï¬ciently expressive to allow the
speciï¬cation of complex CPS properties related to the software
and the physical components and their interactions.
In this paper, we propose (i) the Hybrid Logic of Signals (HLS),
a logic-based language that allows the speciï¬cation of complex
CPS requirements, and (ii) ThEodorE, an efï¬cient SMT-based
trace-checking procedure. This procedure reduces the problem of
checking a CPS requirement over an execution trace, to checking
the satisï¬ability of an SMT formula.
We evaluated our contributions by using a representative
industrial case study in the satellite domain. We assessed the
expressiveness of HLS by considering 212 requirements of our
case study. HLS could express all the 212 requirements. We also
assessed the applicability of ThEodorE by running the trace-
checking procedure for 747 trace-requirement combinations.
ThEodorE was able to produce a verdict in 74.5% of the cases.
Finally, we compared HLS and ThEodorE with other speciï¬-
cation languages and trace-checking tools from the literature.
Our results show that, from a practical standpoint, our approach
offers a better trade-off between expressiveness and performance.
Index Termsâ€”Monitors, Languages, Speciï¬cation, Validation,
Formal methods, Semantics
I. I NTRODUCTION
Cyber-physical systems (CPSs) combine cyber and physical
capabilities [1]. Cyber capabilities are typically provided by
software components that sense and act on the physical
environment, while physical capabilities are provided by the
environment in which the software is deployed. Therefore,
CPSs combine software and physical dynamics. Physical dy-
namics are typically modeled through formalisms that capture
the continuous evolutionâ€”according to physical lawsâ€”of the
environment over time (e.g., differential equations); the cor-
responding behaviors are typically represented as continuous
signals. Software (i.e., cyber) dynamics are typically modeled
with discrete event systems (e.g., ï¬nite state machines), whose
This work was carried out while the author was a student at Politecnico
di Milano (Italy), during an internship at the SnT Centre of the University of
Luxembourg.behavior is typically represented by a sequence of events.
Cyber-physical systems exhibit hybrid dynamics since they
combine both physical and software capabilities.
Engineers collect traces (i.e., logs) describing the behavior
of a CPS both when the CPS is simulated and, by means
of instrumentation and logging mechanisms, during the actual
execution of the CPS. A trace is a sequence of records
that contain some information about the execution (or the
simulation) of the cyber-physical components (e.g., the state
of the system variables). Trace records are usually labeled
with time-stamps representing the time instants at which the
recorded information was obtained.
Engineers analyze these traces to check whether they con-
form to the systemâ€™s requirements speciï¬cations; this ac-
tivity can be automated by means of trace-checking tools.
Speciï¬cation-driven trace-checking tools usually take as in-
put a trace to be analyzed and a requirement speciï¬cation;
they yield a Boolean verdict indicating whether the trace
satisï¬es the speciï¬cation. The algorithms implemented by
trace-checking tools are typically language-speciï¬c. In the
context of trace checking, there exist two main categories of
languages used for specifying CPS requirements: time-based
andsequence-based languages.
Time-based languages (e.g., STL [2], STL[3], RFOL [4],
SFO [5], TPTL [6]. and SB-TemPsy-DSL [7]) interpret the
records of the cyber and physical components as signals over
atime domain. Speciï¬cations written in a time-based language
express time relations over the occurrence of events. Such
languages are suitable to express CPS requirements related
to physical quantities; an example of such requirement is P1:
â€œbetween 2 sand10 s (measured starting from the origin of
the trace) the speed of the satellite is lower than 10 mÂsâ€.
However, time-based languages are not easily amenable to
specifying requirements related to software components. As
an example, let us consider the requirement P2: â€œwhenever
the satellite changes its mode from safe to normal, the speed
of the satellite decreasesâ€. To express the ï¬rst part of this
requirement (marked in italics), one should specify that 1)
in the trace there are two consecutive records; 2) the ï¬rst
record captures that the satellite is in â€œsafe modeâ€; and 3)
the second record captures that the satellite is in â€œnormal
modeâ€. This requirement cannot be easily expressed in time-
8472021 IEEE/ACM 43rd International Conference on Software Engineering (ICSE)
1558-1225/21/$31.00 Â©2021 IEEE
DOI 10.1109/ICSE43902.2021.00082
based languages since they generally do not provide constructs
speciï¬cally designed to specify the ï¬rst condition, i.e., that a
record immediately follows another one in the trace. Indeed,
expressing such a condition requires the speciï¬cation language
to provide access to the indices (i.e., positions in the trace) of
the different records.
On the other hand, in sequence-based languagesâ€”such as
LTL [8] (and domain-speciï¬c languages based on one of its
extensions, like the one in the SpeAR tool [9]), FRETISH [10],
and CoCoSpec [11]â€”traces are sequences of consecutive
records, whose temporal model is represented by the sequence
ofdiscrete indices of the records. This class of languages
interprets the records of the CPS software and physical
components as discrete-time signals. Speciï¬cations in these
languages constrain the indices in which events can occur;
such speciï¬cations are used to express properties that mostly
refer to the CPS software components, such as the ï¬rst part
of the aforementioned P2 property. However, these languages
cannot express time relations over the occurrence of events,
such as the one in property P1.
A third class of speciï¬cation languages is the one of hybrid
languages (e.g., STL-MX [12], HyLTL [13], HRELTL [14],
Differential Dynamic Logic [15], HTL [16]), which support
the speciï¬cation of both continuous and discrete behaviors.
However, these languages typically extend existing languages
(e.g., LTL) to support the speciï¬cation of hybrid behaviors
in speciï¬c contexts (e.g., using signal derivatives). Therefore,
they provide ad-hoc solutions that inherit some of the intrinsic
limitations of the base language, thus hindering the expressive-
ness of the resulting hybrid language. For example, a hybrid
language based on LTL cannot support metric operators to
constrain the time distance between events.
The goal of this paper is to tackle the challenge of specifying
hybrid behaviors of CPSs, in a way amenable to practical and
efï¬cient trace-checking. To reach this goal we propose:
(i) the Hybrid Logic of Signals (HLS), a new speciï¬cation
language tailored to specifying CPS requirements. HLS allows
engineers to express CPS requirements as properties (i.e.,
speciï¬cations) that refer both to the time-stamps and to the
indices of the records of CPS traces. In this way, HLS
speciï¬cations can easily express the behavior of both cyber
and physical components, as well as their interactions.
(ii)ThEodorE , an efï¬cient trace-checking approach for
properties expressed in HLS. ThEodorE reduces the problem
of checking an HLS property on a trace to a satisï¬ability
problem, which can be solved using off-the-shelf Satisï¬ability
Modulo Theories (SMT) solvers. The latter have efï¬cient
decision procedures for several background theories, thus
making it possible to check whether a formula expressed in a
ï¬rst-order logic is satisï¬able.
We evaluated our contribution using an industrial case study
in the satellite domain, in collaboration with the engineers who
developed the satelliteâ€™s on-board system.
(i) We assessed the expressiveness of HLS by checking
whether it could express the 212 requirements of our case
study. Our results show that HLS could express all therequirements of our case study. We also compared HLS with
SB-TemPsy-DSL [7] and STL [2], two speciï¬cation languages
proposed in the literature and for which trace-checking tools
are available. The results show that HLS is signiï¬cantly more
expressive than SB-TemPsy-DSL and STL, which could only
express 145 and 102 requirements, respectively.
(ii) We evaluated the trace-checking support provided by
ThEodorE by assessing its applicability on 20 large traces
provided by our industrial partner and obtained by simulating
the behavior of the satellite across representative, different
scenarios. We ran the ThEodorE trace-checker on 747 trace-
requirement combinations. ThEodorE completed the veriï¬ca-
tion in 74.5% of the cases within one hour, a reasonable time-
out considering typical CPS development contexts. ThEodorE
yielded a verdict for 67.9% of the 337 trace-requirement com-
binations containing a requirement that can not be veriï¬ed by
any of the other trace-checkers. We compared the applicability
of ThEodorE with SB-TemPsy-Check [7] and Breach [17],
for the trace-requirement combinations containing require-
ments expressible in SB-TemPsy-DSL and STL. For these
combinations, SB-TemPsy-Check and Breach were 21.9% and
4.9% more often applicable than ThEodorE, respectively. SB-
TemPsy-Check and Breach were also more efï¬cient, but not
to a point where it had practical implications.
Our results show that ThEodorE is broadly applicable as it
allows engineers to specify a large variety of requirements
while providing an efï¬cient trace-checking procedure. Since
in practical applications it is generally difï¬cult to know
in advance which requirement types engineers will need to
specify, our ï¬ndings suggest that ThEodorE is good default
choice. However, if ThEodorE is not able to produce a verdict,
and the requirement are expressible in SB-TemPsy-DSL or
STL, engineers should then use SB-TemPsy-Check or Breach.
The paper is organized as follows. Section II describes our
case study. Section III illustrates the syntax and semantics
of HLS. Section IV presents ThEodorE. Section V evaluates
our contribution based on an industrial case study. Section VI
discussed related work. Section VII concludes the paper.
II. C ASE STUDY AND MOTIVATIONS
Our industrial partner LuxSpace [18] developed, in collabo-
ration with ESA [19] and ExactEarth [20], a maritime satellite
to collect tracking information from vessels operating on Earth
and to relay those data to the ground. This is a representative
CPS made of complex software component interacting with
many actuators and sensors and the physical environment
where the satellite is to be deployed. This system should
satisfy many varied requirements regarding the behavior of the
software system itself but also its interactions with hardware
and the satellite physical dynamics in space. Its development
relies on technologies and practices typically seen in CPS
contexts, e.g., Model-in-the-loop development with SimulinkÂ®.
Software engineers check the compliance of the satellite
behavior to its requirements [21] both while the software is
being developed and at run time. This is done by (i) collecting
848ang-rate 20Â•122Â•223Â•3 20Â•421Â•1 3Â•2 1Â•1
mode 0 1 0 0 3 3 3
timestamp 0 0Â•2 0Â•9 1Â•8 3Â•0 4Â•9 5Â•7
index 0 1 2 3 4 5 6
RecordA3
Figure 1: A fragment of an execution trace of our case study.
execution traces of the system, and (ii) checking whether those
traces satisfy the system requirements.
Figure 1 shows a fragment of an execution trace, which
we will use to motivate this work. A trace is a sequence of
records that contain some information about the execution of
the system. In this example, the records include data about the
angular rate (ang-rate) and the (satellite) mode (mode).
The angular rate is a physical quantity represented by a real
value measured by sensors. The mode is an enumeration of
values that represent the state of the satellite software. There
are four different modes: â€œIdle Modeâ€, â€œSafe Spin Modeâ€,
â€œNormal Mode Coarseâ€, and â€œNormal Mode Fineâ€, which
are represented in the trace by the values 0,1,2, and 3,
respectively. In addition, each record is associated with a
timestamp, representing the time instant at which the recorded
information was obtained, and a progressive index value.
The requirements to be checked on the system traces
refer both to the software and to the physical dynamics of
the satellite. For example, let us consider requirement R1:
Whenever the satellite mode switches from â€œIdle Modeâ€ to
â€œNormal Mode Fineâ€, the satellite angular rate shall reach
a value lower than 1Â•5Â°Âswithin 10 s. Moreover, the angular
rate shall stabilize around an arbitrary value 2lower than
or equal to 1Â•5Â°Âs.R1speciï¬es a constraint on a physical
quantity, i.e., the angular rate of the satellite, which shall be
ensured as a reaction to a software change, i.e., the satellite
switching its mode from â€œIdleâ€ to â€œNormal Mode Fineâ€.
One way to express that the mode of the satellite switches
from â€œIdle Modeâ€ to â€œNormal Mode Fineâ€ , is to specify that
the trace contains: 1) two records with consecutive indices;
2) the ï¬rst record captures that the satellite is in â€œIdle Modeâ€;
3) the second record captures that the satellite is in â€œNormal
Mode Fineâ€. This requirement cannot be easily expressed in
the vast majority of time-based languages since they do not
provide access to the indices of the different records. To com-
pensate for this limitation when using time-based languages,
engineers can apply ad-hoc solutions, such as adding a new
Boolean ï¬‚ag to the trace records. In our example, such a ï¬‚ag
would be true whenever the mode of the satellite switches
from â€œIdle Modeâ€ to â€œNormal Mode Fineâ€. In this way, the
aforementioned requirement fragment would be rephrased as
the ï¬‚ag switch-from-IDLE-to-NORMAL-MODE-FINE
is true. However, this is impractical in real scenarios because:
(i) the number of ï¬‚ags to add in the trace records can
quickly grow and become unmanageable. For example, giventhe four possible values for the satellite mode in our case
study, to consider all possible combinations for switching
satellite mode, engineers would need to add 16 values in each
record (one for each mode switching combination). (ii) The
requirement is reformulated and its connection to the actual
software component behavior is lost.
Furthermore, requirement R1cannot be expressed using
sequence-based languages because they do not support time
relations over the occurrence of events. More speciï¬cally,
expressing that â€œthe [. . . ] angular rate shall reach [. . . ] within
10 sâ€ requires to access the timestamps associated with the
trace records (and compute a distance). This feature is not
provided by sequence-based languages.
Moreover, to the best of our our knowledge, among the
time-based and sequence-based languages mentioned in the
previous section, SFO [5] is the only language that allows
users to use quantiï¬ed variables in speciï¬cations, (as in â€œ(there
exist) an arbitrary value 2lower than or equal to 1Â•5Â°Âs
around which [. . . ] shall stabilizeâ€. This type of requirements
is quite common in practical CPS applications, since engineers
often want to check that the system stabilizes around a given
value (e.g., the steady-state value). Although engineers know
some properties of the steady-state value 2(i.e.,2shall be
lower than or equal to 1Â•5Â°Âs), they generally do not know its
exact value, which has to be indicated as a generic variable in
the requirement speciï¬cation.
This example, extracted from our case study, shows the need
for an expressive language for specifying hybrid behaviors of
CPSs. In the next section, we will introduce a new speciï¬ca-
tion language for CPSs, which overcomes the limitationsâ€”in
terms of expressivenessâ€”of state-of-the-art languages and is
supported by an effective trace-checking procedure.
III. H YBRID LOGIC OF SIGNALS
In this section, we illustrate HLS (Hybrid Logic of Signals),
our new speciï¬cation language for CPSs. We ï¬rst discuss the
design goals of the language (section III-A). Then, we deï¬ne
the mathematical model of the traces considered in this work
(section III-B). Finally, we present the syntax (section III-C)
and the semantics (section III-D) of the language.
A. Design goals
We designed HLS to provide a language for specifying CPS
properties that seamlessly combine the features of sequence-
based and time-based languages. Therefore, HLS extends
existing time-based languages (e.g., STL [2], RFOL [4],
and SFO [5]) and sequence-based languages (e.g., LTL [8],
FRETISH [10], and CoCoSpec [11]) to allow engineers to
refer both to trace indices and to timestamps in the logical
speciï¬cations, to arbitrarily combine them to deï¬ne properties
describing the expected behavior of a CPS, and to express
properties by quantifying over the values of the variables.
More speciï¬cally, HLS allows engineers to use ï¬rst-order
existential anduniversal quantiï¬ers with:
timestamp variables, to express properties that refer to
speciï¬c time instants and to the distance among them,
849such as â€œthere exists a time instant Cwithin 10 sfrom the
current time instant [. . . ]â€;
(trace) index variables, to express properties that refer
to the indices of trace records, such as â€œfor every trace
index8, such that the corresponding record captures that
the satellite is in â€œIdle Modeâ€, and the immediately
following record (at trace index 8Â¸1) captures that the
satellite is in â€œNormal Mode Fineâ€ [. . . ]â€;
real-valued variables, to express properties that refer to
arbitrary signal values, such as â€œthere exists a value 2
lower than or equal to 1Â•5Â°Âsaround which the signal
ang-rate shall stabilizeâ€.
Additionally, HLS supports speciï¬cations that use:
the value of a signal at a certain timestamp or associated
with a record at a certain index ;
the timestamp associated with the record at a certain
index ;
the index of the record with a certain timestamp;
expressions combining time variables, trace indices, and
real-valued variables, using arithmetic and relational op-
erators.
B. Traces
LetJ=f0Â–1Â–2Â–Â•Â•Â•Â–9Â–Â•Â•Â•Â–<g, with elements 92N, be a set
of indices. Let Tbe an interval of R; we call Ta time domain.
Let(=fB1Â–B2Â–Â•Â•Â•Â–B8Â–Â•Â•Â•Â–B=gbe a set of variables (hereafter
called â€œsignalsâ€) of the systems being monitored, with B82R.
A tracecis a ï¬nite sequence of records A0Â–A1Â–Â•Â•Â•Â–A9Â–Â•Â•Â•Â–A<,
with92J.
Each record A9is a tupleh9Â–CÂ–E 1Â–E2Â–Â•Â•Â•Â–E=i, where92Jis
the index associated with the record, C2Tis the timestamp at
which the recorded information was obtained, and E1Â–E2Â–Â•Â•Â•Â–
E=2Rare the values associated with signals B1Â–B2Â–Â•Â•Â•Â–B=in
the record. For a trace cwe use the array notation â€œ Â»9Â¼â€ to
denote the9-th record of c, and we use the dot notation to
denote an element of a record; we also introduce the notation
C9, short forcÂ»9Â¼Â•Cfor a given trace c. For example, let c4
be the fragment of the trace depicted in Figure 1; it contains
seven records. Record A3is denoted by c4Â»3Â¼; it is represented
by the tupleh3Â–1Â•8Â–0Â–20Â•4i, wherec4Â»3Â¼Â•C=C3=1Â•8is the
value of the timestamp, c4Â»3Â¼Â•mode =0is the value of signal
mode, and c4Â»3Â¼Â•ang-rate =20Â•4is the value of signal
ang-rate.
We assume that the values associated with the timestamps
are monotonically increasing, i.e., C9ÂŸC9Â¸1, since records refer
to consecutive timestamps. We say that a trace has a ï¬xed
sample rate srif, for every 9Â–09 ÂŸ< ,C9Â¸1 C9=sr, where
sris a constant value; otherwise, we say that the trace has a
variable sample rate. For example, trace c4in Figure 1 has a
variable sample rate.
Additionally, we introduce a function ]c:T!J: given a
timestamp value C,]cÂ¹CÂºis the value of the index 9of the
record incwith the highest timestamp C9such thatC9ÂŸ=C;
we will omit the trace subscript when it is clear from thecontext. For example, for trace c4in Figure 1, ]c4Â¹2Â•5Âº=3.
In this work, we consider two deï¬nitions of ]:
]+Â¹CÂº::=Â»C0CÂ¼Â»C ÂŸC 1Â¼0Â¸Â»C1CÂ¼Â»C ÂŸC 2Â¼1Â¸
Â•Â•Â•Â¸Â»C< 1CÂ¼Â»C ÂŸC<Â¼Â¹< 1ÂºÂ¸Â»C<=CÂ¼<
]Â¹CÂº::=jC
srk
Deï¬nition]+Â¹CÂºassumes that the trace has a variable sample
rate. Notice that the notation Â»%Â¼, where%is a logical
predicate, is the Iverson bracket; it evaluates to 1 if %is true,
and to 0 otherwise. The resulting arithmetic formula checks
where the timestamp Cprovided in input is situated w.r.t. the
timestamps of the trace (i.e., C0Â–C1Â–Â•Â•Â•Â–C<), and returns the
value of the index of the record that has the highest timestamp
that is smaller than or equal to C. For example, if the parameter
Cis greater than timestamp C2and lower than timestamp C3,
the only expression in ]+Â¹CÂºthat does not evaluate to 0 is
Â»C2CÂ¼Â»C ÂŸC 3Â¼2; therefore the index returned will be 2.
Deï¬nition]Â¹CÂºassumes that the trace has a ï¬xed sample
rate. In such as case, the index associated with a timestamp
can be simply retrieved by computing the ï¬‚oor of the ratio of
the timestamp Cover the sample rate sr.
In this work, we assume that all the variables are sampled
at each timestamp. This is a necessary requirement to enable
the evaluation of the satisfaction of the system requirements at
each timestamp. For systems that do not sample all the vari-
ables at each timestamp, engineers can use a pre-processing
step to generate values to be assigned to variables for which
the value is missing at certain timestamps. In this work, we
consider two complementary pre-processing strategies:
A1: In each record, an interpolation function (e.g., piece-
wise constant, linear, cubic) speciï¬c to each signal, is used
to generate values for unassigned variables. Notice that this
approach does not alter the original sample rate of the trace,
since it keeps the same records as the original trace and only
generates (in each record) values for the unassigned variables.
A2: If the trace has a variable sample rate, it is converted
into a trace with a ï¬xed sample rate. This is done by generating
a fresh set of records with a ï¬xed sample rate equal to
the smallest sample rate (i.e., the minimum time distance
between two records) of the original trace, and by using the
interpolation functions (as in the case of strategy A1) to
generate the values of allvariables.
As we will discuss in Section V, the strategy used to generate
the values of unassigned variables determines the trace accu-
racy. The latter inï¬‚uences the trace checking verdict and may
impact on the correctness of the trace-checking procedure.
C. Syntax
An HLS formula is deï¬ned according to the grammar
presented in Figure 2, whose start symbol is p. In the grammar,
we use the symbol 5to represent a generic (binary) arithmetic
function; the symbol jseparates alternatives. In the following,
we illustrate the various language constructs; in the explana-
tions, we will refer to the set TV=fg0Â–g1Â–Â•Â•Â•gof timestamp
variables over T, the set IV=ff0Â–f1Â–Â•Â•Â•gof index variables
850overJ, and the set RV=fd0Â–d1Â–Â•Â•Â•gof real-valued variables
overR.
Aterm (non-terminal tm) can be either a time term, an
index term, or a value term.
Atime term (non-terminal tt) allows engineers to refer
to timestamps in the speciï¬cations. A time term can be a
timestamp variable g2TV, a literal denoting a value C2T,
the value returned by the operator i2t, or an arithmetic
expression over these entities. The operator i2t(it) takes an
index term as argument and returns the timestamp associated
with the record at the (trace) index it. An example of time
term is the expression g0Â¸5Â•5Â¸i2tÂ¹2Âº.
Anindex term (non-terminal it) allows engineers to refer
to trace indices in the speciï¬cations. An index term can be
an index variable f2IV, a literal denoting a value 92J,
the value returned by the operator t2i, or an arithmetic
expression over these entities. The operator t2i(tt) takes
a time term as argument and returns the index 9of the trace
record with timestamp C9, whereC9is the highest timestamp
value for which C9tt. An example of index term is the
expressionf0Â¸2Â¸t2iÂ¹3Â•3Âº.
Avalue term (non-terminal vt) allows engineers to refer
to real values (e.g., signal values) in the speciï¬cations. A value
term can be a real-valued variable d2RV, a literal denoting
a valueG2R, the value of a signal returned by the operators
@i(â€œat indexâ€) and @t(â€œat timestampâ€), or an arithmetic
expression over these entities. The @ioperator is an inï¬x
operator that takes two arguments: a signal Band an index
termit; it returns the value of signal Bassociated with the
record at the (trace) index it. Similarly, the @toperator is
an inï¬x operator that takes two arguments: a signal Band a
time term tt; it returns the value of signal Bassociated with
a record at timestamp C9, whereC9is the highest timestamp
value in the trace for which C9tt. An example of value
term is the expression Â¹B1@i2ÂºÂ¸Â¹B2@t3Â•3ÂºÂ¸d0Â¸5Â•2, where
B1andB2are signals, 2is an index term, 3Â•3is a time term,
d0is a real-valued variable, and 5Â•2is a numeric literal.
Aformula (non-terminal p) is a relational expression over
terms, a logical expression over other formulae deï¬ned using
Boolean connectives, or an existentially quantiï¬ed formula.
As anticipated in section III-A, HLS supports three types of
quantiï¬cation:
(i) over timestamp variables, as in â€œexists gin)[. . . ]â€,
where)is a time range with bounds in T;
(ii) over index variables, as in â€œexists fin[. . . ]â€,
whereis a range of index values with bounds in J;
(iii) over real-valued variables, as in â€œexists d[. . . ]â€.
For example, the formula existsf0inÂ»3Â–5Â¼such that
Â¹B1@if0ÂºÂŸ2Â•5speciï¬es that there exists a record with index
greater than or equal to 3and lower than or equal to 5, in
which the value of signal B1is less than 2Â•5.
The language is further extended with additional relational
operators, additional logical connectives (e.g., implication
(implies), conjunction (and)), and universal quantiï¬ers
(forall) on timestamp variables, index variables, and real-
valued variables, using the standard logical conventions.Term tmFttjvtjit
Time Term ttFgjCji2tÂ¹itÂºj5Â¹tt1Â–tt2Âº
Index Term itFfj9jt2iÂ¹ttÂºj5Â¹it1Â–it2Âº
Value Term vtFdjGjÂ¹B@iitÂºjÂ¹B@tttÂºj5Â¹vt1Â–vt2Âº
Formula pFtm1ÂŸtm2jnotpjp1orp2
jexistsgin)such that p
jexistsfinsuch that p
jexistsdsuch that p
C2TÂ–92JÂ–G2RÂ–g2TVÂ–f2SVÂ–d2RVÂ–B2(
Figure 2: Syntax of the Hybrid Logic of Signals.
We now present an application of HLS for the speciï¬cation
of one of the requirements in our case study. Let us consider
a fragment of requirement R1:Whenever the satellite mode
switches from â€œIdle Modeâ€ to â€œNormal Mode Fineâ€, the
satellite angular rate shall reach a value lower than 1Â•5Â°Âs
within 10 s. We recall that the satellite mode is represented
by the signal mode, for which value 0 corresponds to â€œIdle
Modeâ€ and value 3 corresponds to â€œNormal Mode Fineâ€; also,
the angular rate is represented by the signal ang-rate. This
fragment can be speciï¬ed in HLS as:
forallf0inÂ»0Â–5Â¼such that
Â¹Â¹mode @if0Âº=0andÂ¹mode @iÂ¹f0Â¸1ÂºÂº=3Âº
implies exists g0inÂ»0 sÂ–10 sÂ¼ such that
Â¹ang-rate @tÂ¹g0Â¸i2tÂ¹f0ÂºÂºÂŸ1Â•5ÂºÂº
The sub-formulaÂ¹Â¹mode @if0Âº=0andÂ¹mode @iÂ¹f0Â¸
1ÂºÂº=3Âºdetects when the satellite switches from â€œIdle Modeâ€
to â€œNormal Mode Fineâ€ over two consecutive records (notice
the use of the â€œat indexâ€ operator to refer to the consecutive
indicesf0andf0Â¸1). This expression is within the scope of
the outer universal quantiï¬er, which iterates over a range of
values for the index variable f0. This range depends on the
length of the trace and on the use of f0in the formula. In
this case, since the requirement says â€œwhenever [the satellite
mode switches. . . ]â€, in the speciï¬cation we want to cover the
full length of the trace fragment c4in Figure 1, where record
index values span from 0 to 6. We achieve this by setting the
lower bound to zero and the upper bound to ï¬ve; in this way,
the term mode @iÂ¹f0Â¸1Âºalways refers to a record index of
the example trace.
The inner quantiï¬cation over the timestamp variable g0
checks whether the angular rate of the satellite reaches a
value lower than 1Â•5Â°Âswithin 10 s. More speciï¬cally, the
expressionÂ¹ang-rate @tÂ¹g0Â¸i2tÂ¹f0ÂºÂºÂŸ1Â•5Âºrepresents
the value of signal ang-rate at timestamp g0Â¸i2tÂ¹f0Âº,
whereg0is in the intervalÂ»0 sÂ–10 sÂ¼ (corresponding to the
distance of 10 s) and i2tÂ¹f0Âºis the timestamp at which the
satellite switches from â€œIdle Modeâ€ to â€œNormal Mode Fineâ€,
i.e., the timestamp associated with the record at index f0.
851D. Semantics
To evaluate whether an HLS formula is true or false over a
tracec, we must ï¬rst deï¬ne how time, index, and value terms
are interpreted and evaluated.
Let`TVÂ–`IVÂ–`RVbe variable assignments, respectively, for
timestamp, index, and real-valued variables; for example, `TV
is a mapping from a timestamp variable in TVto a value in T.
Let`denote, collectively, the family of variable assignment
functions`TVÂ–`IVÂ–`RV. We evaluate a generic term tmon
a tracec, using the variable assignment functions in `, by
means of an interpretation function ÃˆtmÃ‰cÂ–`.
The interpretation of HLS terms is deï¬ned inductively at
the top of ï¬gure 3. For all three term types, the interpretation
of a literal is the value denoted by the literal itself; a variable
is interpreted using the variable assignment function for the
corresponding type; an arithmetic expression deï¬ned using a
function5is interpreted by applying the interpretation of the
function symbol 5to the interpretation of the corresponding
arguments. The operators i2t, t2i, @i, and @tare inter-
preted according to the informal semantics provided in the
previous section.
The semantics of an HLS formula qis deï¬ned over a trace c
and a variable assignment `; we use the notation Â¹cÂ–`Âºj=qto
indicate that trace csatisï¬es formula qunder variable assign-
ment`. The satisï¬ability relation of HLS formulae is deï¬ned
inductively at the bottom of ï¬gure 3. The formula tm1ÂŸtm2
is satisï¬ed if and only if (iff) the interpretation of term tm1
is lower than the interpretation of term tm2. The semantics
of the Boolean connectives orandnot is the standard one.
A formula with an existential quantiï¬er over a timestamp
variable, of the form existsgin)such that p, is
satisï¬ed iff there exists a timestamp C92), such that when
substituting timestamp C9forgin the formula p(denoted by
pÂ»g C9Â¼), the resulting formula is satisï¬ed. The semantics of
the other two types of formulae with an existential quantiï¬er
is deï¬ned in a similar way.
IV. T RACE CHECKING HLS FORMULAE
In this section, we present ThEodorE, our trace checker
for HLS. ThEodorE reduces the problem of checking an HLS
property on a trace to a satisï¬ability problem, which can be
solved using off-the-shelf SMT solvers.
ThEodorE takes as input a property qexpressed in HLS
and a tracec. The ï¬rst step of ThEodorE is to automatically
translating property qand tracecformulae expressed using
a target logicL. This translation relies on two translation
functions h(for HLS formulae, see Section IV-B) and t
(for traces, see Section IV-A) and guarantees, that Â¹cÂ–`Âº j=
qiffhÂ¹:qÂº^tÂ¹cÂºis not satisï¬able, where `is a model for
hÂ¹:qÂº^tÂ¹cÂº), i.e.,`is a variable assignment leading to the
property violation, consistent with the values of the variables
of the trace records.
The second step of ThEodorE is checking the satisï¬ability
of formulakhÂ¹:qÂº^tÂ¹cÂº, expressed in the target logic
Lusing an SMT solver. Based on the condition stated above,
whenkis satisï¬able, it means that qdoes not hold on theTime Term Interpretation
ÃˆgÃ‰cÂ–`=`TVÂ¹gÂº, for allg2TV;
ÃˆCÃ‰cÂ–`=C, for allC2T;
Ãˆi2tÂ¹itÂºÃ‰cÂ–`=cÂ»ÃˆitÃ‰cÂ–`Â¼Â•C;
Ãˆ5Â¹tt1Â–tt2ÂºÃ‰cÂ–`=Ãˆ5Ã‰cÂ–`Â¹Ãˆtt 1Ã‰cÂ–`Â–Ãˆtt 2Ã‰cÂ–`Âº;
Index Term Interpretation
ÃˆfÃ‰cÂ–`=`IVÂ¹fÂº, for allf2IV;
Ãˆ9Ã‰cÂ–`=9, for all92J;
Ãˆt2iÂ¹ttÂºÃ‰cÂ–`=]cÂ¹ÃˆttÃ‰cÂ–`Âº;
Ãˆ5Â¹it1Â–it2ÂºÃ‰cÂ–`=Ãˆ5Ã‰cÂ–`Â¹Ãˆit 1Ã‰cÂ–`Â–Ãˆit 2Ã‰cÂ–`Âº;
Value Term Interpretation
ÃˆdÃ‰cÂ–`=`RVÂ¹dÂº, for alld2RV;
ÃˆGÃ‰cÂ–`=G, for allG2R;
ÃˆÂ¹B@iitÂºÃ‰cÂ–`=cÂ»ÃˆitÃ‰cÂ–`Â¼Â•B;
ÃˆÂ¹B@tttÂºÃ‰cÂ–`=cÂ»]cÂ¹ÃˆttÃ‰cÂ–`ÂºÂ¼Â•B
Ãˆ5Â¹vt1Â–vt2ÂºÃ‰cÂ–`=Ãˆ5Ã‰cÂ–`Â¹Ãˆvt 1Ã‰cÂ–`Â–Ãˆvt 2Ã‰cÂ–`Âº;
Formula Satisfaction
Â¹cÂ–`Âºj=tm1ÂŸtm2 iffÃˆtm 1Ã‰cÂ–`ÂŸÃˆtm 2Ã‰cÂ–`
Â¹cÂ–`Âºj=notp iffÂ¹cÂ–`Âº6j=p
Â¹cÂ–`Âºj=p1orp2 iffÂ¹cÂ–`Âºj=p1orÂ¹cÂ–`Âºj=p2
Â¹cÂ–`Âºj=existsgin) iffÂ¹cÂ–`Âºj=pÂ»g C9Â¼
such that p for someC92)
Â¹cÂ–`Âºj=existsfin iffÂ¹cÂ–`Âºj=pÂ»f 9Â¼
such that p for some92
Â¹cÂ–`Âºj=existsd iffÂ¹cÂ–`Âºj=pÂ»d EÂ¼
such that p for someE2R
Figure 3: Semantics of the Hybrid Logic of Signals.
tracec. Vice-versa, when kis not satisï¬able, it means that q
holds on the trace c.
The ï¬nal verdict yielded by ThEodorE can be â€œsatisï¬ed â€,
â€œviolated â€ or â€œunknownâ€; it is based on the answer of the
solver. ThEodorE yields the deï¬nitive verdicts â€œsatisï¬edâ€
or â€œviolatedâ€ when the solver returns â€œUNSATâ€ or â€œSATâ€,
indicating, respectively, that kis unsatisï¬able or satisï¬able.
However, the solver may return an â€œUNKNOWNâ€ answer,
since the satisï¬ability of the underlying target logic Lis
generally undecidable. In our case, this indicates that no
conclusion is drawn on the satisï¬ability of formula k, resulting
in an â€œunknownâ€ verdict returned by ThEodorE. Assessing
whether this is a frequent case in practical applications is part
of our evaluation (Section V).
The target logicLto be selected for trace checking of HLS
properties in ThEodorE shall fulï¬ll two goals:
G1: be sufï¬ciently expressive to encode the logic-based
representation of an input trace cand the (semantics of an)
HLS formula q. This means that it should include linear
real arithmetic (to support real-valued and timestamp terms),
quantiï¬ers (since HLS is a ï¬rst-order logic), and arrays (since
a trace can be seen as an array of records).
G2: be supported by an efï¬cient solver, so that the trace
checking procedure for HLS formulae can be completed within
practical time limits.
We have identiï¬ed the AUFLIRA (Closed linear formulae
with free sort and function symbols over one- and two-
dimentional arrays of integer indices and real values) fragment
of the SMT-LIB (Satisï¬ability Modulo Theories LIBrary)
852logic [22] as a suitable target logic for ThEodorE. The theories
used by AUFLIRA are identiï¬able through its name: A : arrays;
UF: extension allowing free sort and function symbols; LIRA :
linear integer and real arithmetics. Furthermore, AUFLIRA
does not restrict the formulae to be quantiï¬er-free. Based on
the list of supported theories, AUFLIRA satisï¬es G1. It also
satisï¬es G2, since it is included in the SMT-LIB logic, whose
satisï¬ability can be veriï¬ed using highly efï¬cient and opti-
mized solvers, as shown in the annual SMT competition [23].
In the following subsections we will describe functions t
andh. For simplicity, we will present the translation using the
syntax of the Z3 Python API [24].
A. Translating a Trace into the Target Logic
Function ttranslates a trace cinto a logic formula expressed
using the target logic L.
To represent the sequence of timestamps in c, the translation
creates an array variable t; the type of the array indices (i.e.,
the domain of t) isZ, whereas the type of the array values (i.e.,
the range of t) isR. Then, the translation deï¬nes a series of
constraints on the values in t: the value of array tat position
8(denoted by t[8]) is constrained to be equal to the value of
the timestamp contained in the record at index 8of tracec.
In addition, the translation creates an array variable for each
signal whose values are recorded in the trace; the variable
name is the string obtained by concatenating v_with the name
of the signal. For each of these array variables representing
signals, the translation deï¬nes a series of constraints on the
values of the array: the value of the array in position 8is
constrained to be equal to the value of the corresponding signal
in the record at index 8of tracec.
B. Translating an HLS Formula into the Target Logic
Function htranslates an HLS formula into a logic formula
expressed using the target logic L.
First, the translation declares a new variable for each
timestamp, index, and real-valued variable used in the HLS
formula; the name of the new variable is the string obtained
by concatenating v_with the named of the original variable.
The type of the new variables is Real for timestamp and
real-valued variables, and Int for index variables.
Afterwards, the translation recursively evaluates each node
in the parse tree of the input formula, starting from the root
node; each node is translated using the rules shown in Figure 4.
The translation of time, index, and values term nodes is
deï¬ned as follows. Nodes referring to HLS variables are
translated into the corresponding variables in the target logic
formula. Literal nodes are mapped into literals in the target
logic formula. Arithmetic expressions using a function 5
are translated by converting the function symbol into the
equivalent in the target language, and then by applying it
to the translation of its arguments. A time term node of the
form i2tÂ¹itÂº is translated into an expression that accesses
the element of the array tin position hÂ¹itÂº. An index term
node of the form t2iÂ¹ttÂº is translated into the application
of the translation of function ]tohÂ¹ttÂº. A value term of theTime Term
hÂ¹gÂº=v_g, for allg2TV;
hÂ¹CÂº=C, for allC2T;
hÂ¹5Â¹tt1Â–tt2ÂºÂº=hÂ¹5ÂºÂ¹hÂ¹tt1ÂºÂ–hÂ¹tt2ÂºÂº;
hÂ¹i2tÂ¹itÂºÂº =t[hÂ¹itÂº];
Index Term
hÂ¹fÂº=v_f, for allf2IV;
hÂ¹9Âº=9, for all92J;
hÂ¹5Â¹it1Â–it2ÂºÂº=hÂ¹5ÂºÂ¹hÂ¹it1ÂºÂ–hÂ¹it2ÂºÂº;
hÂ¹t2iÂ¹ttÂºÂº =hÂ¹]ÂºÂ¹hÂ¹ttÂºÂº ;
Value Term
hÂ¹fÂº=v_f, for allf2RV;
hÂ¹GÂº=G, for allG2R;
hÂ¹5Â¹vt1Â–vt2ÂºÂº=hÂ¹5ÂºÂ¹hÂ¹vt1ÂºÂ–hÂ¹vt2ÂºÂº
hÂ¹Â¹B@iitÂºÂº =v_s[hÂ¹itÂº];
hÂ¹Â¹B@tttÂºÂº =v_s[hÂ¹]ÂºÂ¹hÂ¹ttÂºÂº];
Formula (with)=Â»C0Â–C1Â¼and=Â»0Â–1Â¼)
hÂ¹tm1ÂŸtm2Âº=hÂ¹tm1ÂºÂŸhÂ¹tm2Âº;
hÂ¹p1orp2Âº=OrÂ¹hÂ¹p1ÂºÂ–hÂ¹p2ÂºÂº;
hÂ¹notpÂº=NotÂ¹hÂ¹pÂºÂº;
hÂ¹existsgin)such that pÂº=
ExistsÂ¹v_gÂ–AndÂ¹AndÂ¹C0v_gÂ–v_gC1ÂºÂ–hÂ¹pÂºÂºÂº
hÂ¹existsfinsuch that pÂº=
ExistsÂ¹v_fÂ–AndÂ¹AndÂ¹0v_fÂ–v_f1ÂºÂ–hÂ¹pÂºÂºÂº
hÂ¹existsdsuch that pÂº=ExistsÂ¹v_dÂ–hÂ¹pÂºÂº
Figure 4: Rules for translating HLS formulae into L.
formÂ¹B@iitÂº is translated into an expression that retrieves
the value of variable v_Bat index hÂ¹itÂº. Similarly, a value
term of the formÂ¹B@tttÂº is translated into an expression
that retrieves the value of variable v_Bat the index obtained
through the evaluation of hÂ¹]ÂºÂ¹hÂ¹ttÂºÂº .
The translation of function ]supports both deï¬nitions
presented in section III-B. It consists of a rewriting of the
deï¬nition into the equivalent syntax of the target logic. We
remark that the size of the arithmetic expression to compute
hÂ¹]+Âºin the case of a variable sample rate is linear in the
length of the trace and the number of timestamp variables.
Evaluating the impact of our translation and of the selection
of the deï¬nition of function ]on the performance of the trace-
checking procedure is part of our evaluation.
The translation of HLS formulae is basically their
rewriting into the equivalent syntax of the target logic,
modulo the translation of the variables and of the
sub-formulae. For example, a formula of the form
existsfinsuch that pis rewritten as
ExistsÂ¹v_fÂ–AndÂ¹AndÂ¹0v_fÂ–v_f1ÂºÂ–hÂ¹pÂºÂºÂº,
where the target logic variable v_fcorresponds to variable
fin the HLS formula, 0and1are the lower and upper
bounds of the closed interval 9, and hÂ¹pÂºis the translation
of sub-formula p.1
ThEodorE ensures that Â¹cÂ–`Âº j=qiffhÂ¹:qÂº^tÂ¹cÂºis
not satisï¬able. The correctness of our procedure is based on
two arguments: (i) ttranslates the trace cinto a set of array
1Our translation also supports open intervals. In this case, the relational
operatorÂŸ(instead of) is used in the target logic formula to constrain the
values v_fcan assume.
853variables whose values are set according to the values of the
original trace, and (ii) hrewrites the HLS formula into the
target logic without applying any change (that could alter the
semantics) to the structure of the formula.
C. Implementation
We implemented ThEodorE as an Eclipse plugin using
Xtext [25] and Xtend [26] and made it publicly available [27,
28]. We selected Z3 [24] as SMT solver, since it is an award-
winning [29, 30], industry-strength tool. As such, it is likely
to satisfy goal G2discussed above. Checking whether this
conjecture holds is part of our evaluation.
V. E VALUATION
In this section, we report on the evaluation of our contribu-
tions. First, we evaluate the expressiveness of HLS, and com-
pare it with state-of-the-art speciï¬cation languages. Second,
we evaluate the applicability of the ThEodorE trace checker,
and compare it to state-of-the-art tools. Speciï¬cally, we aim
to answer the following research questions:
RQ1 To which extent can HLS express requirements from
industrial CPS applications and how does it compare
with state-of-the-art speciï¬cation languages in terms of
expressiveness? (section V-A)
RQ2 Can ThEodorE verify CPS requirements on real-world
execution traces within practical time and how does it
compare with state-of-the-art tools? (section V-B)
A. Expressiveness of HLS (RQ1)
To answer RQ1, we collected a set of industrial CPS
requirements expressed in plain English text, and veriï¬ed
whether they could be expressed in HLS and in other state-
of-the-art speciï¬cation languages.
Dataset. We considered 212 industrial requirements from
our satellite case study, coming from three different sources:
S1:61requirements were randomly selected from 745
requirements contained in the requirement speciï¬cation docu-
ment of the satellite on-board software (OBSW). Due to the
prohibitive effort (more than 20hours spanned across several
working days) involved, both on our part and that of the
domain experts who helped us formalize these requirements,
we could only process a subset. Such requirements mostly
refer to the software dynamics of the satellite, as in â€œWhen the
satellite switches to â€œIdle Modeâ€, the OBSW shall checkout
the GPS, wait 50 ms, and then checkout the sun sensorsâ€.
S2:101requirements were provided by the authors of SB-
TemPsy-DSL [7]. They mostly refer to the physical dynamics
of the satellite, as in â€œthe beta angle [31] shall show an
oscillatory behavior with a maximum period of 2500 sâ€.
S3:50requirements were extracted from the design and
architectural documents of the satellite. These documents
describe the relations and interactions among the different
components of the satellite. They contain cyber-physical re-
quirements that relate the software and the physical dynamics
of the satellite, as in â€œif the satellite mode switches from â€œIdle
Modeâ€ to â€œSafe Spin Modeâ€ and the satellite is not in eclipse,Table I: Number of requirements expressible in each of the
languages for each set of requirements.S1S2S3 Total
HLS 61/61 101/101 50/50 212Â212 Â¹100%Âº
SB-TemPsy-DSL 34Â61 92/10119Â50 145Â212 Â¹68%Âº
STL 38Â61 51/10113Â50 102Â212 Â¹48%Âº
the magnetic ï¬eld recorded by the magnetometer shall contain
a spike with a maximum amplitude of 0Â•02 Tâ€.
Methodology. We tried to express the requirements from
our dataset using HLS and two state-of-the-art speciï¬cation
languages, namely SB-TemPsy-DSL [7] and STL [2]. We
selected these languages because they are both supported
by trace checking tools. We assessed the extent to which
requirements were expressible in each language.
Results. Table I reports2the number of requirements that
we were able to express in each of the languages, for each set
of requirements (S 1,S2, andS3). HLS was able to express
100% (212/212) of the requirements, while SB-TemPsy-DSL
and STL were able to express 68% (145/212) and 48%
(102/212) of the requirements, respectively. These results
conï¬rm that HLS is highly expressive and much more so than
alternatives. We remark that all the HLS constructs were useful
to express at least some of the considered CPS requirements,
though in very different proportions.The answer to RQ1 is that HLS could express allthe
requirements of our case study, many more than SB-TemPsy-
DSL (Â¸67) and STL (Â¸110).
B. Applicability of ThEodorE (RQ2)
To answer RQ2, we (i) assessed to which extent ThEodorE
can be applied to check the execution traces of our case study;
(ii) compared, in terms of applicability, ThEodorE with SB-
TemPsy-Check [7] and Breach [17]. SB-TemPsy-Check is the
trace checker for SB-TemPsy-DSL; Breach is a trace checker
for STL. We chose Breach among other similar tools listed in
a recent survey [32] (i.e., AMT [33, 34] and S-TaLiRo [35]),
because AMT 2.0, in contrast to Breach, is not publicly
available, and because Breach is faster than S-TaLiRo [17].
Furthermore, we excluded from our comparison tools for
online trace checking (e.g., SOCRaTEs [4] and RTAMT [36]).
Dataset. Our industrial partner provided 20 traces, obtained
by simulating the behavior of the satellite in different scenar-
ios; the simulation time ranged from four to six hours. Their
size (in number of entries) ranges from 41844 to 1202241
entries (avg =389771, sd=393718); the corresponding
ï¬le size ranges from 1Â•7 MB to58Â•9 MB (avg17Â•6 MB,
sd19Â•4 MB). The traces have a considerably large (yet
variable) number of records and size.
2The values in Table I marked with an asterisk are slightly different from
those reported in [7]. In the latter, quantiï¬cation on real-valued variables (not
supported in STL and SB-TemPsy-DSL) was handled by artiï¬cially selecting
a value for the quantiï¬ed variables within their quantiï¬cation range. In this
work, we marked such requirements as not speciï¬able.
854For each trace in our dataset, our industrial partner indicated
which requirements to check. Indeed, since only a subset of the
satellite signals is recorded in each simulation scenario, not all
the requirements have to be checked on each trace. In total, we
considered 747 trace-requirement combinations: 320 obtained
from requirements in S1, 178 obtained from requirements in
S2, and 249 obtained from traces in S3. We remark that, out
of these 747 combinations, 337 involve a requirement that can
be expressed neither in SB-TemPsy-DSL nor in STL.
Our industrial partner used a variable sample-rate for gen-
erating the trace records; hence not all the signal values were
recorded at each sample index. Since our approach assumes
that all the signals are assigned a value at each sample index,
we pre-processed the traces. First, for each trace-requirement
combination, we ï¬ltered out from the trace all the records
that contained only signals that were not used in the HLS
speciï¬cation of the requirement. This step prevents the trace
checker from handling an unnecessarily large set of records.
Then, we transformed the traces using both pre-processing
strategiesA1andA2presented in section III-B; in both cases,
the interpolation function to use for each signal was indicated
by the engineers of our industrial partner.
By applying theA1andA2strategies on the original
747 trace-requirement combinations, the ï¬nal dataset con-
tains 1494 trace-requirement combinations (with half of them
obtained using one of the two strategies). The size of the
traces obtained using A1ranges from 2 to 17321 entries
(avg=2071, sd=3840); the corresponding ï¬le size ranges
from15 B to5Â•9 MB (avg0Â•1 MB, sd0Â•4 MB). The size
of the traces obtained using A2ranges from 2 to 2360674
entries (avg =52406, sd=185875); the ï¬le size ranges from
15 B to90Â•0 MB (avg2Â•3 MB, sd8Â•4 MB).
Methodology. We ran ThEodorE over the 1494 trace-
requirements combinations in our dataset. When translating the
HLS properties in the target logic, we used function ]+for the
trace-requirement combinations generated using strategy A1
(since the pre-processed traces have a variable sample rate),
and function ]for those generated using strategy A2(since
the pre-processed traces have a ï¬xed sample rate).
We conducted our evaluation on a high-performance com-
puting platform, using nodes equipped with Dell C6320 units
(2 Xeon E5-2680v4@2 Â•4 GHz, 128 GB).3Each run (checking
a distinct combination of a trace and a property) was repeated
10 times, to account for variations in the performance of the
HPC platform and of the SMT solver. In total, we executed
149410=14940 runs of ThEodorE. We allocated 4 GB of
memory for each run and considered a timeout of one hour. We
recorded whether the trace-checking procedure ended within
the timeout, the trace checking result, and the time required
to yield a verdict.
As for the comparison with SB-TemPsy-Check and Breach,
we only considered the requirements from S2since it has the
highest number of requirements expressible in SB-TemPsy-
3We executed our experiments on the HPC facilities of the University of
Luxembourg [37].Table II: Output of ThEodorE (percentage and execution time)
when using the pre-processing strategies A1andA2.Output % avg min max sd
A1satisï¬ed 53.9 80.2 0.01 2693.0 334.7
violated 12.1 14.2 0.01 513.9 57.9
unknown 1.6 6.5 5.8 7.4 0.6
timeout 0.5 - - - -
max_depth_exceeded 13.0 - - -
out_of_memory 18.9 - - -
A2satisï¬ed 53.8 102.5 0.01 3432.9 331.7
violated 20.7 96.5 0.01 3143.5 379.8
unknown 2.2 8.7 5.4 12.3 2.1
timeout 23.3 - - - -
DSL and STL, and it was recently used for comparing SB-
TemPsy-DSL with STL [7]. More speciï¬cally, we considered
the 162 trace-requirement combinations (with requirements
from the setS2) expressible in SB-TemPsy-DSL, and the 103
trace-requirement combinations expressible in STL. We ran
the tools following the same methodology described above.
Since each run was repeated ten times, in total we considered
1620 runs of SB-TemPsy-Check and 1030 runs of Breach.
Results - Applicability of ThEodorE. Table II shows the
different types of output returned by ThEodorE for checking
the 7470 trace-requirement combinations generated using the
variable sample rate interpolation (row A1) and the ï¬xed
sample rate interpolation (row A2). Column â€œ%â€ indicates
the percentage of cases in which each type of verdict was
returned. For each of the cases in which ThEodorE ï¬nished
within the timeout (i.e., it yielded a satisï¬ed ,violated , or
unknown verdict), Table II also provides the average (avg),
minimum (min), maximum (max ) and standard deviation (sd )
of the ThEodorE execution time (s).
The results in row A1show that ThEodorE ï¬nished within
the timeout in 67.6% of the cases. In 66.0% of the cases,
ThEodorE produced a deï¬nitive verdict (i.e., satisï¬ed orvio-
lated ); in 0.5% of the cases, ThEodorE timed out. ThEodorE
returned a â€œmax_depth_exceeded - maximum recursion depth
exceeded during compilationâ€ error in 13Â•0%of the cases,
and an â€œout_of_memoryâ€ error in 18Â•9%of the cases; both
errors are generated by the Z3 solver. The root cause of
these errors is the translation of function ]+, used in the
case of variable sample rate traces: the size of the arithmetic
expression resulting from the translation is linear in the length
of the trace. As expected, ThEodorE inherits the limitations
of SMT solvers and its applicability is expected to improve
along with the quick pace of progress in that ï¬eld.
The results in row A2show that ThEodorE ï¬nished within
the timeout in 76.7% of the cases. In 74Â•5% of the cases,
ThEodorE produced a deï¬nitive verdict; in 23.3% of the cases,
ThEodorE timed out. When using strategy A2, the number of
times ThEodorE reached the timeout was higher than when
usingA1. Indeed, many trace-requirement runs that generated
max_depth_exceeded andout_of_memory errors in the case of
A1, timed out when using A2. As discussed for the case
ofA1, the applicability of ThEodorE when using A2is
855determined by the scalability of the underlying SMT solver.
To evaluate whether ThEodorE is applicable in cases in
which neither SB-TemPsy-Check nor Breach is applicable, we
considered the subset of 3370 runs associated with the 337
trace-requirement combinations that involve a requirement that
can be expressed neither in SB-TemPsy-DSL nor in STL. For
those combinations, ThEodorE was able to produce a verdict
in 67.9% of the cases.
To evaluate the impact of the trace accuracy (as determined
by the application of the pre-processing strategies A1and
A2) on the correctness of the trace-checking procedure, we
considered the 449runs in which ThEodorE returned a deï¬ni-
tive verdict both when using A1and when usingA2, and
we compared the verdicts. In 95.1% of the cases (427 over
449), the verdicts coincided. For the 22cases in which the
verdicts were different, we manually inspected the generated
traces and conï¬rmed that differences in verdicts were caused
by the pre-processing strategies.
Overall, these results show that ThEodorE, when conï¬gured
with the pre-processing strategy based on a ï¬xed sample rate
(A2), produced a deï¬nitive verdict for a considerable number
of trace-requirement combinations (74 Â•5%), thus conï¬rming
ThEodorEâ€™s applicability in practical scenarios. Relying on
theA2strategy led to a signiï¬cantly wider applicability of
ThEodorE than with the A1strategy (74Â•5% vs 66Â•0%), while
resulting in negligible differences in trace accuracy. Therefore,
for comparing ThEodorE with other tools, we resorted to using
theA2pre-processing strategy.
Finally, we remark that ThEodorE detected an issue in the
satellite design: some of the traces exhibited an unexpected
spike in a signal related to the physical dynamics of the
satellite, which was caused by a change in a signal related
to its software dynamics.
Results - Comparison with other tools. Table III reports the
percentage of cases in which ThEodorE, SB-TemPsy-Check,
and Breach provided a verdict within the timeout and the
minimum, maximum, average and standard deviation of the
time required to yield the verdict.
The results show that, when the requirements are expressible
in SB-TemPsy-DSL and STL, SB-TemPsy-Check and Breach
are faster than ThEodorE. However, given the usage scenario
considered in our work (ofï¬‚ine trace checking), the difference
in execution times reported in Table III does not have signif-
icant practical consequences since the average trace-checking
time (less than two minutes) is signiï¬cantly lower than the
time required to collect the traces (several hours). Note that
all tools were consistent in terms of verdicts: when ThEodorE
returned a deï¬nitive verdict, it matched the verdict returned by
SB-TemPsy-Check and Breach (when they did not time out).The answer to RQ2 is that ThEodorE could compute a
deï¬nitive verdict, within one hour, for 74.5% of the trace-
requirement combinations of our industrial case study, and
produced a verdict for 67.9% of the 337 trace-requirement
combinations that could not be checked by the other tools.Table III: Comparison of ThEodorE, SB-TemPsy-Check, and
Breach in terms of the execution time.
Tool % avg min max sd
ThEodorE 72.2 69.6 0.01 2506.2 317.6
SB-TemPsy 94.1 30.1 0.09 3440.0 310.1
ThEodorE 95.1 81.4 0.01 2506.2 345.7
Breach 100 0.03 0.02 0.1 0.007
C. Discussion and Threats to Validity
Based on results, we recommend the following workï¬‚ow.
Developers should initially use ThEodorE since its language
(HLS) is the most expressive, and it is generally difï¬cult to
know in advance which requirement types engineers will need
to specify. If the property to be veriï¬ed does not contain
thet2i HLS operator, which causes the generation of large
arithmetic expressions, engineers should use ThEodorE with
the pre-processing strategy based on a variable sample rate
(A1). If the property contains the t2i operator, engineers
should use the pre-processing strategy based on a ï¬xed sample
rate (A2). If ThEodorE was not able to produce a deï¬nitive
verdict, and the requirement is expressible in SB-TemPsy-DSL
or STL, engineers should use SB-TemPsy-Check or Breach.
Threats to validity. The requirements and traces we used in
our evaluation come from a single case study in the satellite
domain. Although this could inï¬‚uence the generalization of
our results, our industrial case study is representative of what
can be found in other cyber-physical domains, where the
system requirements are complex properties related to the
software system, its environment and their interactions, and
traces are obtained by simulating (or executing) the behavior
of the CPS in many different scenarios.
VI. R ELATED WORK
Our contribution is mainly related to work done in the area
of hybrid speciï¬cation languages.
STL-MX [12] extends STL to deï¬ne properties both on
discrete time and on dense time. The language includes two
layers, one based on LTL to express properties of discrete-time
Boolean signals (sampled at a ï¬xed sample rate), and another
one based on STL, to express properties on dense-time real-
valued signals. Time mapping operators deï¬ne the conversion
between dense-time and discrete-time signals and formulae.
A trace-checking procedure has been proposed for STL-MX,
but its implementation is not available. Compared with HLS,
STL-MX restricts discrete-time Boolean signals to be sampled
at a ï¬xed sample rate, and lacks ï¬rst-order quantiï¬ers on real-
valued variables.
HyLTL [13], HRELTL [14], and HTL [16] extend existing
languages (e.g., LTL) with operators to express constraints
on certain behaviors of signals (e.g., derivatives or limits). In
contrast to HLS, they cannot express properties that refer to
speciï¬c time instants and to the distance between them.
Differential Dynamic Logic [15] differs from HLS since it is
designed for specifying properties of systems expressed using
856the hybrid system [38] modeling formalism. As such, its modal
operators enable references to the states that are reachable after
ï¬ring the transitions of the hybrid system model.
The approach of reducing the trace-checking problem to
the veriï¬cation of the satisï¬ability of a logical formula has
been also used in other works ([14, 39, 40]). However, our
approach supports HLS, a more widely applicable language,
and developed an efï¬cient translation for it.
SOCRaTEs [4], Striver [41], TeSSLa [42], and RTLola [43]
and a tool recently proposed by Arrieta et al. [44] are also
related to our work. Unlike ThEodorE, which supports ofï¬‚ine
trace checking, these tools support online run-time veriï¬cation.
To summarise, in our context and given our goal, in addition
to the lack of trace-checking tools, none of the languages
discussed above is as expressive as HLS. Taking into account
the expressiveness limitations of state-of-the-art languages like
SB-TemPsy-DSL and STL, which were not able to express
many of our requirements (see section V), the development
of a new language (and of the corresponding trace-checking
tool) was indeed necessary.
VII. C ONCLUSION
Software veriï¬cation and validation requires speciï¬cation-
driven trace-checking techniques that strike a balance between
the expressiveness of the speciï¬cation language and the ef-
ï¬ciency of its trace-checking procedures. In this paper, we
speciï¬cally address this problem in the CPS domain. We
proposed the Hybrid Logic of Signals (HLS), a speciï¬cation
language tailored to the speciï¬cs of CPS requirements. HLS
allows engineers to specify complex CPS requirements related
to its cyber and the physical components, as well as their in-
teractions. Additionally, we developed ThEodorE, an efï¬cient
SMT-based trace-checking procedure for HLS.
We evaluated our solutions through a large-scale, complex
industrial case study involving an on-board satellite system.
Results show that our approach achieves a better trade-off
between expressiveness and performance than existing solu-
tions. HLS was able to express all system requirements in
contrast to existing languages. As a result, ThEodorE supports
a much wider set of property types than other trace checkers.
In most cases, ThEodorE was able to check those properties
within practical time limits. Furthermore, the applicability of
ThEodorE is expected to improve in the future along with the
underlying SMT technology. Last, based on results, we suggest
a way to effectively combine various trace-checking tools.
As part of future work, we plan to develop trace diagnostics
methods for HLS, inspired by existing work [45, 46], to
explain the violations found by ThEodorE.
VIII. D ATA AVAILABILITY
ThEodorE is publicly available [27, 28] under the Apache
License 2.0. The entry on Zenodo.org [28] contains, in addi-
tion to the software, the ï¬les containing the results produced
by ThEodorE, and the scripts to compute the aggregated results
presented in the paper. The traces and requirements used in
the experiments cannot be publicly released because they are
subject to a non-disclosure agreement.ACKNOWLEDGMENT
This work has received funding from the European Research
Council under the European Unionâ€™s Horizon 2020 research
and innovation programme (grant agreement No 694277),
from the Natural Sciences and Engineering Research Council
of Canada (NSERC) under the Discovery and CRC programs.
The experiments presented in this paper were carried out
using the HPC facilities of the University of Luxembourg [37]
â€” see hpc.uni.lu.
REFERENCES
[1] A. Platzer, Logical foundations of cyber-physical sys-
tems. Springer, 2018.
[2] O. Maler and D. Nickovic, â€œMonitoring temporal proper-
ties of continuous signals,â€ in Formal Techniques, Mod-
elling and Analysis of Timed and Fault-Tolerant Systems.
Springer, 2004, pp. 152â€“166.
[3] L. Brim, P. DluhoÅ¡, D. Å afrÃ¡nek, and T. Vejpustek,
â€œSTL: Extending signal temporal logic with signal-value
freezing operator,â€ Information and computation, vol.
236, pp. 52â€“67, 2014.
[4] C. Menghi, S. Nejati, K. Gaaloul, and L. C. Briand,
â€œGenerating automated and online test oracles for
simulink models with continuous and uncertain behav-
iors,â€ in European Software Engineering Conference and
Symposium on the Foundations of Software Engineering
(ESEC/FSE). ACM, 2019.
[5] A. Bakhirkin, T. FerrÃ¨re, T. A. Henzinger, and
D. Ni Ë‡ckovi Â´c, â€œThe ï¬rst-order logic of signals: keynote,â€
inInternational Conference on Embedded Software.
IEEE Press, 2018, p. 1.
[6] R. Alur and T. A. Henzinger, â€œReal-time logics: Com-
plexity and expressiveness,â€ Information and Computa-
tion, vol. 104, no. 1, pp. 35â€“77, 1993.
[7] C. Boufaied, C. Menghi, D. Bianculli, L. Briand, and
Y . Isasi-Parache, â€œTrace-checking signal-based temporal
properties: A model-driven approach,â€ in International
Conference on Automated Software Engineering (ASE
2020). IEEE, 2020, pp. 1004â€“1015.
[8] E. A. Emerson and J. Y . Halpern, â€œâ€œsometimesâ€ and
â€œnot neverâ€ revisited: on branching versus linear time
temporal logic,â€ Journal of the ACM (JACM), vol. 33,
no. 1, pp. 151â€“178, 1986.
[9] A. W. Fifarek, L. G. Wagner, J. A. Hoffman, B. D. Rodes,
M. A. Aiello, and J. A. Davis, â€œSpeAR v2. 0: Formalized
past LTL speciï¬cation and analysis of requirements,â€ in
NASA Formal Methods Symposium. Springer, 2017, pp.
420â€“426.
[10] D. Giannakopoulou, T. Pressburger, A. Mavridou, and
J. Schumann, â€œGeneration of formal requirements from
structured natural language,â€ in Requirements Engineer-
ing: Foundation for Software Quality (REFSQ 2020).
Springer, 2020, pp. 19â€“35.
[11] A. Champion, A. Gurï¬nkel, T. Kahsai, and C. Tinelli,
â€œCoCoSpec: A mode-aware contract language for reac-
tive systems,â€ in International Conference on Software
857Engineering and Formal Methods. Springer, 2016, pp.
347â€“366.
[12] T. FerrÃ¨re, O. Maler, and D. Ni Ë‡ckovi Â´c, â€œMixed-time
signal temporal logic,â€ in Formal Modeling and Analysis
of Timed Systems. Springer, 2019, pp. 59â€“75.
[13] D. Bresolin, â€œHyLTL: a temporal logic for model check-
ing hybrid systems,â€ arXiv preprint arXiv:1308.5336 ,
2013.
[14] A. Cimatti, M. Roveri, and S. Tonetta, â€œHRELTL: A
temporal logic for hybrid systems,â€ Information and
Computation, vol. 245, pp. 54 â€“ 71, 2015.
[15] A. Platzer, â€œDifferential dynamic logic for hybrid sys-
tems,â€ Journal of Automated Reasoning, vol. 41, no. 2,
pp. 143â€“189, 2008.
[16] T. A. Henzinger, Z. Manna, and A. Pnueli, â€œTowards
reï¬ning temporal speciï¬cations into hybrid systems,â€ in
Hybrid systems. Springer, 1992, pp. 60â€“76.
[17] A. DonzÃ©, T. FerrÃ¨re, and O. Maler, â€œEfï¬cient robust
monitoring for STL,â€ in Computer Aided Veriï¬cation
Conference (CAV). Springer, 2013, pp. 264â€“279.
[18] (2020) Luxspace. [Online]. Available: https://luxspace.lu/
[19] â€œThe European Space Agency (ESA),â€ 2020. [Online].
Available: https://www.esa.int/
[20] â€œexactEarth,â€ 2020. [Online]. Available: https://www.
exactearth.com/
[21] (2020) Satellite development phases. [Online]. Avail-
able: https://www.esa.int/Science_Exploration/Space_
Science/Building_and_testing_spacecraft
[22] C. Barrett, A. Stump, and C. Tinelli, â€œThe SMT-LIB stan-
dard - version 2.6,â€ Department of Computer Science,
The University of Iowa, Tech. Rep., 2017.
[23] T. Weber, S. Conchon, D. DÃ©harbe, M. Heizmann,
A. Niemetz, and G. Reger, â€œThe SMT competition 2015-
2018,â€ J. Satisf. Boolean Model. Comput., vol. 11, no. 1,
pp. 221â€“259, 2019.
[24] (2020) Z3. [Online]. Available: https://github.com/
Z3Prover/z3
[25] â€œXtext,â€ https://www.eclipse.org/Xtext/, 2020.
[26] â€œXtend,â€ https://www.eclipse.org/xtend/, 2020.
[27] â€œThEodorE,â€ https://github.com/SNTSVV/ThEodorE,
2020.
[28] C. Menghi, E. ViganÃ², D. Bianculli, and L. C.
Briand, â€œTheodore - trace-checker,â€ Feb. 2021. [Online].
Available: https://doi.org/10.5281/zenodo.4506795
[29] â€œACM SIGPLAN - Programming Languages Software
Award,â€ http://www.sigplan.org/Awards/Software/, 2020.
[30] â€œETAPS 2018 Test of Time Award,â€ https://etaps.org/
about/test-of-time-award/test-of-time-award-2018, 2020.
[31] (2020) Beta angle. [Online]. Available: https://en.
wikipedia.org/wiki/Beta_angle
[32] E. Bartocci, J. Deshmukh, A. DonzÃ©, G. Fainekos,
O. Maler, D. Ni Ë‡ckovi Â´c, and S. Sankaranarayanan,
â€œSpeciï¬cation-based monitoring of cyber-physical sys-
tems: a survey on theory, tools and applications,â€ in
Lectures on Runtime Veriï¬cation. Springer, 2018, pp.
135â€“175.[33] D. Ni Ë‡ckovi Â´c, O. Lebeltel, O. Maler, T. FerrÃ¨re, and
D. Ulus, â€œAMT 2.0: Qualitative and quantitative trace
analysis with extended signal temporal logic,â€ in Tools
and Algorithms for the Construction and Analysis of
Systems. Springer, 2018, pp. 303â€“319.
[34] D. Ni Ë‡ckovi Â´c, O. Lebeltel, O. Maler, T. FerrÃ¨re, and
D. Ulus, â€œAMT 2.0: qualitative and quantitative trace
analysis with extended signal temporal logic,â€ Interna-
tional Journal on Software Tools for Technology Trans-
fer, pp. 1â€“18, 2020.
[35] Y . Annpureddy, C. Liu, G. Fainekos, and S. Sankara-
narayanan, â€œS-taliro: A tool for temporal logic falsiï¬ca-
tion for hybrid systems,â€ in International Conference on
Tools and Algorithms for the Construction and Analysis
of Systems. Springer, 2011, pp. 254â€“257.
[36] D. Ni Ë‡ckovi Â´c and T. Yamaguchi, â€œRTAMT: Online robust-
ness monitors from STL,â€ in International Symposium
on Automated Technology for Veriï¬cation and Analysis
(ATVA). Springer, 2020, pp. 564â€“571.
[37] S. Varrette, P. Bouvry, H. Cartiaux, and F. Georgatos,
â€œManagement of an academic hpc cluster: The ul ex-
perience,â€ in Proc. of the 2014 Intl. Conf. on High
Performance Computing & Simulation (HPCS 2014).
Bologna, Italy: IEEE, July 2014, pp. 959â€“967.
[38] R. Alur, Principles of cyber-physical systems. MIT
Press, 2015.
[39] M. M. Bersani, D. Bianculli, C. Ghezzi, S. Krsti Â´c, and
P. San Pietro, â€œSMT-based checking of SOLOIST over
sparse traces,â€ in International Conference on Funda-
mental Approaches to Software Engineering (FASE), vol.
8411. Springer, 2014, pp. 276â€“290.
[40] D. Bianculli, C. Ghezzi, S. Krsti Â´c, and P. San Pietro,
â€œOfï¬‚ine trace checking of quantitative properties of
service-based applications,â€ in International Conference
on Service Oriented Computing and Application (SOCA).
IEEE, 2014, pp. 9â€“16.
[41] F. Gorostiaga and C. SÃ¡nchez, â€œStriver: Stream runtime
veriï¬cation for real-time event-streams,â€ in International
Conference on Runtime Veriï¬cation. Springer, 2018, pp.
282â€“298.
[42] L. Convent, S. Hungerecker, M. Leucker, T. Scheffel,
M. Schmitz, and D. Thoma, â€œTeSSLa: temporal stream-
based speciï¬cation language,â€ in Brazilian Symposium
on Formal Methods. Springer, 2018, pp. 144â€“162.
[43] P. Faymonville, B. Finkbeiner, S. Schirmer, and H. Tor-
fah, â€œA stream-based speciï¬cation language for network
monitoring,â€ in Runtime Veriï¬cation. Springer, 2016,
pp. 152â€“168.
[44] A. Arrieta, J. A. Agirre, and G. Sagardui, â€œA tool for
the automatic generation of test cases and oracles for
simulation models based on functional requirements,â€ in
International Conference on Software Testing, Veriï¬ca-
tion and Validation Workshops (ICSTW). IEEE, 2020,
pp. 1â€“5.
[45] W. Dou, D. Bianculli, and L. Briand, â€œModel-driven trace
diagnostics for pattern-based temporal speciï¬cations,â€ in
858International Conference on Model Driven Engineering
Languages and Systems (MODELS). ACM/IEEE, 2018,
pp. 278â€“288.
[46] T. FerrÃ¨re, O. Maler, and D. Ni Ë‡ckovi Â´c, â€œTrace diagnostics
using temporal implicants,â€ in International Symposium
on Automated Technology for Veriï¬cation and Analysis
(ATVA). Springer, 2015, pp. 241â€“258.
859