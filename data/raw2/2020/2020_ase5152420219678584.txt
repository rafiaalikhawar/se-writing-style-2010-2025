ASE: A Value Set Decision Procedure
for Symbolic Execution
Alireza S. Abyaneh
Department of Computer Sciences
University of Salzburg
Salzburg, Austria
alireza.abyaneh@cs.uni-salzburg.atChristoph M. Kirsch
Department of Computer Sciences
University of Salzburg, Salzburg, Austria
and Czech Technical University, Prague, Czech Republic
christoph.kirsch@cs.uni-salzburg.at
Abstract —A symbolic execution engine regularly queries a
Satisﬁability Modulo Theory (SMT) solver to determine reacha-
bility of code during execution. Unfortunately, the SMT solver isoften the bottleneck of symbolic execution. Inspired by abstractinterpretation, we propose an abstract symbolic execution (ASE)engine which aims at querying the SMT solver less often bytrying to compute reachability faster through an increasinglyweaker abstraction. For this purpose, we have designed andimplemented a value set decision procedure based on stridedvalue interval (SVI) sets for efﬁciently determining precise, orunder-approximating value sets for variables. Our ASE enginebegins reasoning with respect to the SVI abstraction, and thenonly if needed uses the theory of bit-vectors implemented inSMT solvers. Our ASE engine efﬁciently detects when the formerabstraction becomes incomplete to move on and try the nextabstraction.
We have designed and implemented a prototype of our engine
for a subset of 64-bit RISC-V . Our experimental evaluationshows that our prototype often improves symbolic executiontime by signiﬁcantly reducing the number of SMT queries while,whenever the abstraction does not work, the overhead for tryingstill remains low.
Index T erms—symbolic execution, value set decision procedure,
strided value interval set abstraction
I. I NTRODUCTION
Symbolic execution [1]–[4] computes inputs to a given
program that make the program run into an error state such as
division by zero within a given number of steps during con-crete execution. For this purpose, a symbolic execution engineconstructs, during program execution, a Satisﬁability ModuloTheory (SMT) formula for a given program path to a control-ﬂow location, called path condition, that is satisﬁable in thetheory of program expressions if and only if the location isreachable on that path. A variable assignment that satisﬁes theSMT formula corresponds to an input that makes the programrun into the location on that path. Conversely, an unsatisﬁableSMT formula indicates that the location is unreachable forall inputs that take the program onto that path. The engineregularly queries an SMT solver to determine reachabilityof the execution branches appearing in the program. Despiterecent advances, constraint solving is a scalability bottleneckin symbolic execution of code [1]. Employing a lightweightreasoning procedure to make decisions about the reachabilityof each of the execution branches enables the symbolic exe-cution engine to scale and to penetrate deeper into the code.While symbolically executing code, the generated con-
straints are typically modeled in the theory of bit-vectors [5] tobe passed to an SMT solver. A constraint solver for the theoryof bit-vectors with a solving algorithm which is designed tooperate on an arbitrarily general set of constraints including awide range and combination of operations may be inefﬁcientfor a set of constraints which use a small number of operationsand have speciﬁc features [6], [7]. In this paper we propose anabstract symbolic execution (ASE) engine exploiting an inte-ger decision procedure for constraint solving which performsa theory integration in a layered manner by considering twoabstractions: strided value interval (SVI) set abstraction [8],[9] and bit-vectors [5]. The respective decision proceduresfor each abstraction in this design strategy are organized ina layered order of increasing capability and complexity. Allthe decisions are made without querying the SMT solver forthe set of constraints which can be solved using the SVIdecision procedure in the ﬁrst layer. Otherwise, the theoryof bit-vectors implemented in SMT solvers is responsible foranswering reachability queries.
The decision procedure in the ﬁrst layer employs a
lightweight value set analysis technique designed for symbolicexecution which uses the SVI abstraction to propagate valuesand speedup the process of reachability decision making. TheSVI abstraction uses a set of strided value intervals to specifyvalues of program variables precisely. An SVI in this setis represented by a wrapped strided interval [8]–[12] whichmaintains an incrementing step of possible values in additionto the value bounds and allows wrapping in case of overﬂow.Keeping the incrementing step enables us to reason aboutmultiplication which introduces steps in possible values. Byemploying the SVI abstraction the decision procedure analyzesthe constraints at a higher level than bits (e.g., words anddouble words) in contrast to bit-precise reasoning used intypical SMT solvers which may be inefﬁcient because of costlybit-blasting [5] in their backend [6], [7].
The strided intervals and value set analysis technique are
typically used in the context of static analysis to over-approximate the values of variables in the program [8]–[12].However, in the context of symbolic execution the precisionof the decisions over reachability matters. Therefore, the SVIabstraction in ASE is used to represent values that variables
2032021 36th IEEE/ACM International Conference on Automated Software Engineering (ASE)
DOI 10.1109/ASE51524.2021.000282021 36th IEEE/ACM International Conference on Automated Software Engineering (ASE) | 978-1-6654-0337-5/21/$31.00 ©2021 IEEE | DOI: 10.1109/ASE51524.2021.9678584
978-1-6654-0337-5/21/$31.00  ©2021  IEEE
can certainly take (no false positive). Such a value set enables
us to make reachability or unreachability decisions precisely.The ASE engine is aware of when the SVI decision procedureis able to provide precise decisions over the set of under-lying constraints, and when this cannot be achieved becauseof a high imposing complexity or incapability, the baselineabstraction is upgraded to bit-vectors.
When the representation of precise values for variables is
not possible using the SVI abstraction, we propose a techniquein the SVI abstraction layer that under-approximates the set ofpossible values for involving variables in an operation whenapplicable. The technique employs an incomplete, lightweightextension of the propagation technique used for our preciseSVI decision procedure to make satisﬁability decisions andreduce the number of queries sent to the SMT solver andspeed up the symbolic execution time.
The following contributions are made by this paper: 1) We
propose an ASE engine which employs a theory integrationin the constraint solving component of the symbolic executionprocess, and beneﬁts from a novel value set analysis techniqueto propagate values at a higher level than bits. 2) We proposea value set decision procedure based on the SVI abstraction,deﬁne the theory behind it, and provide conditions under whichthe analysis provides precise values for program variables. Assuch, the decision procedure detects when such an abstractionleads to exact satisﬁability and unsatisﬁability decisions forsymbolic execution (Section IV). 3) In order to beneﬁt fromthe efﬁciency of our precise SVI decision procedure we intro-duce an extension technique which enables the ASE engine tomake satisﬁability decisions using an under-approximation ofthe set of possible values for variables (Section V).
Our experimental evaluation on a set of benchmarks shows
on average 33.62% and 59.84% reduction in symbolic execu-tion time compared to the state-of-the-art approach [13] andthe approach which always queries an SMT solver, respec-tively.
II. O
VERVIEW
The principled idea of abstract symbolic execution is to
integrate symbolic execution with decision procedures thatleverage domain speciﬁc reasoning to speedup constraintsolving by employing increasingly weaker abstractions. Thedecision procedure we propose here is able to reason aboutthe set of constraints generated out of a program with respectto an abstract domain:
Deﬁnition 2.1: A constraint satisfaction problem on ﬁnite
domains (CSP) is deﬁned by a triplet /angbracketleftX,D,C/angbracketrightwhereX=
{x
1,...,x n}is a set of variables, D={d1,...,d n}is the
set of variables’ domains (x i∈di), andC={c1,...,c m}
is a set of constraints over variables. A valuation is deﬁnedasv=(v
1,...,v n)wherevi∈di. A solution to the CSP is
deﬁned as a valuation swhich satisﬁes the set of constraints
C. The set of all solutions is denoted as S.
Given a speciﬁc abstract domain to represent the possible
values of variables, the set of all solutions Sfor a set of
constraints Ccan be represented precisely, or approximated.Deﬁnition 2.2: Given an abstract domain Aand a corre-
sponding set of solutions SA, this set is precise if SA=S
and is an under-approximation if SA⊆S. In case of an under-
approximation we write SAforS.
In this paper we present a decision procedure employing
a propagation technique which considers an SVI set as itsunderlying abstract domain to ﬁnd the precise, or the under-approximating set of all solutions to a CSP. To do so, weemploy a reﬁnement model [14] wherein initially variables cantake any value in their domain. While symbolically executingcode, constraints are generated and gradually variables’ valuesare reﬁned so that they satisfy the currently seen set ofconstraints. When the SVI decision procedure cannot providea decision, the abstraction is upgraded to bit-vectors and thedecision procedure implemented in an SMT solver is used tomake a decision.
Section IV presents the precise SVI decision procedure and
discusses the conditions under which the analysis provides theexact set of all solutions. In Section V we propose a techniquewhich continues propagating an under-approximation of theset of solutions when representation of the precise solutionsis not possible. Keeping the under-approximating solutionsS
Afor the currently seen constraints enables us to check the
satisﬁability (and not unsatisﬁability) of subsequent constraintsappearing in the program while still using the efﬁcient propa-gation technique of the decision procedure of Section IV. Theproposed symbolic execution algorithm and its implementationdetails are explained in Section VI.
III. R
ELATED WORK
In this paper we employ an abstract domain in the process
of symbolic reasoning about the set of generated constraintsout of a program. Abstracting values using interval domain is awell-studied and efﬁcient technique in the context of abstractinterpretation and program analysis. The concept of stridedintervals was introduced by Reps et al. [10] representing ﬁxed-precision value intervals with incrementing steps. However, astrided interval in their deﬁnition does not permit wrapping[15]. The application of the interval abstract domain becomesharder when it comes to the analysis of machine arithmeticwith wrap-around semantics in case of overﬂow. Integerwrapped intervals [15], [16] extends the classical intervals byconsidering wrap-around semantics. Gange et al. [15] providea sound analysis for wrapped interval abstract domain. Theyuse intervals to over-approximate the set of all possible valueswhich one variable can take. In our SVI decision procedurewe use their soundness conditions, however we extend theabstraction to wrapped strided intervals, propose completenessconditions for operations, and deﬁne the detailed semantics ofreachability decision making when the comparison operationis involved. In particular we deﬁne the inverse semantics of op-erations while propagation intervals backward (Section IV-B).
Sen et al. [8] employ the wrapped interval abstraction
with steps where they propose a new abstract domain calledCircular Linear Progressions (CLPs) to combine the efﬁciencyof interval abstract domain with the discreteness of linear
204congruence domain. In our SVI decision procedure we use
their deﬁned semantics, however we extend those by deﬁningsoundness and completeness conditions for each operationsince in the context of symbolic execution the precision ofdecisions matters. Moreover, we discuss the inverse semanticsof operations while propagating constraints backward (Sec-tion IV-B), and investigate the semantics of the remainderoperation during the forward propagation (Section IV-A).
The strided interval abstraction [10] has been used in several
research works [9], [11]. Balakrishnan et al. [11] propose valueset analysis (VSA) which uses a combined numeric and pointeranalysis algorithm to over-approximate the set of values. Later,to increase the precision, Shoshitaishvili et al. [9] extends theVSA of Balakrishnan et al. [11] to detect memory corruptionsby developing a new abstraction called strided interval set,
implementing a lightweight algebraic solver, and adopting asignedness-agnostic wrapped interval domain. However, theyomit discussing the detailed semantics of their algebraic solver.Both papers use VSA as a static analysis technique to over-approximate possible values that registers or abstract locationsin a program can take. We also use strided interval sets toanalyze possible values, however since we employ our SVIdecision procedure in symbolic execution, it is necessary to beable to make exact decisions. Therefore, additionally we derivecompleteness conditions under which our analysis providesexact values for variables and leads to exact reachabilitydecisions. Moreover, the provided under-approximating valuesby ASE can also lead to exact reachability decisions.
The layering design strategy which refers to employing
a set of theory solvers in an increasing order of capabilityand complexity is another related research topic [17]–[19].Bruttomesso et al. [17] proposed a three-layered theory solverincluding a solver for the logic of equality of uninterpretedfunctions as ﬁrst layer, an incomplete solver which is basedon term rewriting technique and inconsistency detection forbit-vector constraints as second layer, and a complete solverfor bit-vectors as third layer. Hadarean et al. [18] proposed alazy, layered approach for the theory of bit-vectors targetingequality and inequality constraints. Their proposed inequalitysolver applies a polynomial-time algorithm to check satisﬁa-bility given a set of constraints. In this paper we also use alayering design strategy in our decision procedure. However,we propose an SVI decision procedure as the ﬁrst layer.
In the context of symbolic execution there are many tools
which implement the symbolic execution algorithm targetingdifferent languages and by applying different techniques [1]–[4], [20]–[24]. In this paper we extend the idea of PARTI [13]which proposed an optimization technique to reduce thenumber of accesses to the constraint solver by implementingan incomplete solver for interval theory. Variable’s values insuch a solver are represented by a data-structure called multi-
interval. The expressions and operations which can be handledby this incomplete solver are solved efﬁciently and the restof the queries are passed to a complete SMT solver. Thecontributions of this paper over PARTI [13] are as follows.1) we extend the employed abstraction in PARTI, which isa set of non-wrapped value intervals, to a set of wrappedstrided value intervals. The strided value intervals introducean incrementing step for possible values needed to reasonabout linear multiplication. 2) Given the SVI abstraction, wepropose the corresponding propagation algorithm by deﬁningthe precise, formal semantics of each operation together withsoundness and completeness conditions (Section IV). Theextraction of such conditions is essential to make exact reach-ability decisions. PARTI omits to deﬁne the theory behindits engine formally including the detailed semantics of theoperations. 3) When a complete analysis is possible, ASEextents the theory by supporting several more operationsincluding linear multiplication, division, and remainder. 4)We propose an optimization technique based on the SVIabstraction which aims at solving satisﬁability by keeping anunder-approximating set of values for variables (Section V).On the other hand, PARTI supports features that ASE doesnot such as signed integer arithmetic and type casting.
IV . P
RECISE SVI D ECISION PROCEDURE
1 int x, y;
2 interval(&x, [10, 20]);
3 y=2 *x;
4 if(y < 30) {...;}
5 else {...;}
Listing 1: Code example.In this section we present
the value set decision proce-dure which is used in the ASEengine with respect to the SVIabstraction. Listing 1 shows acode example where a sym-bolic input is provided to the program. The execution of theprogram at line 2 assigns a symbolic value which varies in arange from 10to20into variable x. Then, at line 3 variable
yis assigned through a symbolic expression which therefore
assigns values {20, 22,..., 40} toy. These values cannot be
represented by only bounds because some values in betweenare missing. In order to handle such a case which is the resultof a multiplication we also need to keep the incrementingstep of possible values in addition to the bounds, denotedas a tuple /angbracketleftlo,up,step /angbracketright. Thus, the possible values for yare
represented as /angbracketleft20,40,2/angbracketright. The assignment of an arithmetic
expression to a variable is evaluated by the substitution ofvariables appearing on the right hand side. We call this processforward propagation of constraints. Afterwards, the executionof the conditional expression at line 4 creates two executionbranches. The evaluation of the branch to true and false,tightens the possible values of yto/angbracketleft20,28,2/angbracketrightand/angbracketleft30,40,2/angbracketright,
respectively. Since the assignment at line 3 created an aliasrelation between variables yandx, the values for xhave
to be updated in consequence of the tightened values fory. Therefore, the new values for xon the true and false
execution paths are /angbracketleft10,14,1/angbracketrightand/angbracketleft15,20,1/angbracketright, respectively.
As it is manifested in this example, the evaluation of aconditional expression may need to update previously storedvalue intervals for involving variables and those which werein relation with them through an assignment (which createsmemory aliasing). We call this process backward propagation
of constraints . The value intervals of variable xat each end-
point is used to generate test inputs which trigger each of twoexecution paths in Listing 1.
205In the context of ﬁxed-width machine arithmetic with over-
ﬂow semantics, integer variables can only take a ﬁnite range of
values representable by wbits. The performed operations on
these integers are denoted by a subscript w(e.g., +w). In this
paper we assume all arithmetic operations are unsigned and forintegers. In fact integer values are represented by a sequence ofbits of ﬁxed length and signedness is an interpretation of thosebits by using a method like two’s complement to representsigned numbers.
Deﬁnition 4.1: (Strided Value Interval). A strided value
interval (SVI) with wrap-around semantics is a tuple /angbracketlefta,b,s/angbracketright
w
wheres>0, each of a,b, andsare represented by w-bit
integers, and s|(b−wa). The tuple indicates the set of integer
values{a+wi∗s|0≤i≤imax}whereimax is the smallest
integer value which satisﬁes a+wimax∗s=b. The elements
a,b, andsspecify the lower bound, upper bound, and stride
(or step) of the values.
Deﬁnition 4.2: (Cardinality). The cardinality of a SVI
denoted as card(/angbracketlefta,b,s/angbracketrightw)is the number of integer values
in that interval and it is computed as (b−wa)/s+w1where
/is an integer division.
Deﬁnition 4.3: (Strided Value Interval Set). A strided value
interval set represents a set of SVIs with an identical strideindicating the values that a variable in the program can take.
Following the wrap-around semantics the bounds for a range
of values are represented on a number circle (as opposed tonumber line) [8], [15]. The values for an unsigned integer startwith 0and proceed clockwise to the maximum value which
is2
w−1. The representation of numbers in a circular manner
enables us to depict the overﬂow concept. For example, theaddition of maximum integer value, i.e. 2
w−1, and 1results
in0when a variable is represented by wbits. Given a value
interval/angbracketlefta,b,s/angbracketrightw, in the circular representation the starting
point of the interval can take place in a position where eithera≤bora>b . The latter case speciﬁes the occurrence of an
overﬂow which indicates a wrapping. Interval I=/angbracketlefta,b,s/angbracketright
w
represented on a number circle can be decomposed into atmost two sub-intervals which do not wrap as follows:/braceleftbigg/angbracketlefta,b,s/angbracketright
w/arrowhookleft→/angbracketlefta,b,s/angbracketrightw a≤b
/angbracketlefta,b,s/angbracketrightw/arrowhookleft→/angbracketlefta,max,s/angbracketright w∪/angbracketleftmin,b,s/angbracketrightwotherwise
(1)
wheremin =glbI(0)andmax =lubI(2w−1). The lubI(i)
function maps its argument ito the largest value that belongs
to the interval I=/angbracketlefta,b,s/angbracketrightwand is less-than or equal to i.
The glbI(i)function maps ito the smallest value that belongs
to the interval I=/angbracketlefta,b,s/angbracketrightwand is greater-than or equal to i.
The multi-interval data structure used in PARTI [13] con-
siders a set of non-wrapped intervals which only keeps valuebounds. It always splits the values when an overﬂow occurs.Moreover, representation of values with an incrementing step,may not be efﬁcient using the multi-interval data structure.For example, considering unsigned 64-bit integers, the set{2
64−1,2,5}contains 3 values where 264−1is the
maximum representable value for an unsigned 64-bit integer.Given the multi-interval abstraction this set is representedas{[2
64−1,264−1],[2,2],[5,5]}, whereas using the SVIabstraction this can be represented by /angbracketleft264−1,5,3/angbracketright64.
In the rest of this section we deﬁne the semantics for
forward and backward propagation of an SVI. Since we designa decision procedure for symbolic execution, it is critical toextract conditions under which the analysis provides correctand exact decisions based on the employed SVI abstraction.
A. F orward Propagation of Constraints
This section presents the forward semantics of arithmetic
operations and speciﬁes the conditions under which the re-
sulting value interval(s) represent the exact possible values.
1) Addition/Subtraction: The addition and subtraction of a
non-empty interval /angbracketlefta,b,s/angbracketright
wand a concrete integer value k
are computed as follows:
/angbracketlefta,b,s/angbracketrightw+k=/angbracketlefta+wk,b+wk,s/angbracketrightw
/angbracketlefta,b,s/angbracketrightw−k=/angbracketlefta−wk,b−wk,s/angbracketrightw
k+/angbracketlefta,b,s/angbracketrightw=/angbracketleftk+wa,k+wb,s/angbracketright w
k−/angbracketlefta,b,s/angbracketrightw=/angbracketleftk−wb,k−wa,s/angbracketright w(2)
Given two value intervals /angbracketlefta,b,s/angbracketrightwand/angbracketleftc,d,s/prime/angbracketrightwwhere car-
dinality of each is greater than 1, the addition and subtractionof those are computed as follows [8]:
/angbracketlefta,b,s/angbracketright
w+/angbracketleftc,d,s/prime/angbracketrightw=/angbracketlefta+wc,b+wd,gcd(s,s/prime)/angbracketrightw
/angbracketlefta,b,s/angbracketrightw−/angbracketleftc,d,s/prime/angbracketrightw=/angbracketlefta−wd,b−wc,gcd(s,s/prime)/angbracketrightw(3)
wheregcdcomputes the greatest common divisor of two inte-
gers. The resulting interval computed in Formula 3 is a soundover-approximation of all possible resulting values when thefollowing condition is satisﬁed [15]:
card (/angbracketlefta,b,1/angbracketright
w)+card (/angbracketleftc,d,1/angbracketrightw)≤2w+1 (4)
which means that the length of the resulting interval, i.e.(b−a)+(d−c), should not be overﬂowed. For the case
wherein both operands are symbolic and the condition inFormula 4 is satisﬁed, Formula 3 may provide an intervalwhich is a superset of the exact possible values in twofollowing cases. First case may happen when the steps of twointervals corresponding to the operands are not identical. Forexample, the addition of l=/angbracketleft0,90,10/angbracketright
64andr=/angbracketleft0,7,1/angbracketright64
value intervals results a proper subset of /angbracketleft0,97,1/angbracketright64containing
values such as 88which cannot be inferred from l+r.
We derive a condition under which the resulting interval inFormula 3 can provide the exact resulting values:
s
/prime%s=0∧card(/angbracketlefta,b,s/angbracketrightw)≥s/prime/s or
s%s/prime=0∧card(/angbracketleftc,d,s/prime/angbracketrightw)≥s/s/prime (5)
The second case is when the operands are related to each other,for example x+xorx−x. In such a case the resulting interval
will be an over-approximation of possible values.
2) Multiplication: The multiplication of a non-empty inter-
val/angbracketlefta,b,s/angbracketright
wand a concrete integer value k>0, is computed
as:
/angbracketlefta,b,s/angbracketrightw∗k=/angbracketlefta∗wk,b∗wk,s∗k/angbracketright (6)
The conditions under which the above formula provides anexact resulting values are deﬁned as follows: (b−a)∗k<
2
wands∗k< 2w, which implies that the length of the
resulting interval after multiplication [15] and the resulting
206step must not be overﬂowed. PARTI [13] supports left shifts
by using a so-called left shift attribute in its decision stage.Otherwise, non-constant multiplications are not supported byPARTI since it introduces value steps.
3) Division: Given a non-empty interval /angbracketlefta,b,s/angbracketright
wand a
concrete integer value k> 0, the division /angbracketlefta,b,s/angbracketrightw/kis
computed as follows:/braceleftbigg/angbracketlefta/k,b/k,s r/angbracketrightw a≤b
/angbracketleftmin/k,max/k,s r/angbracketrightwa>b(7)
wheremin andmax have the same deﬁnition as in Formula 1.
sris computed as s/k whens≥kand otherwise is equal to
1. Formula 7 provides a sound over-approximation of possiblevalues as result of division. In order to derive the resultinginterval which represents the exact possible values, we needto specify two conditions. First when a/negationslash=b, by checking
whether the step sand the divisor kare divisible or not which
means:s%k=0 ifs≥k. The second condition applies
on when a>b . In this case the interval /angbracketlefta,b,s/angbracketright
wshould
be split into two sub-intervals /angbracketlefta,max,s/angbracketrightwand/angbracketleftmin,b,s/angbracketrightw
according to Formula 1. The resulting values can be repre-sented as the two following intervals: /angbracketlefta/k,max /k,s
r/angbracketrightand
/angbracketleftmin/k,b/k,s r/angbracketright. PARTI [13] only supports right shifts by
constant.
4) Remainder: Given a non-empty interval /angbracketlefta,b,s/angbracketrightwwhere
a≤band a concrete integer value k> 0, the remainder
operation /angbracketlefta,b,s/angbracketrightw%kcan be computed as:
⎧
⎪⎪⎪⎪⎪⎪⎪⎨
⎪⎪⎪⎪⎪⎪⎪⎩/angbracketlefta%k,b %k,s/angbracketright
wb/k=a/k
/angbracketlefta%k−istart∗gcd(s,k),
a%k+iend∗gcd(s,k),
gcd(s,k)/angbracketrightwb−a≥lcm(s,k)−s∧
b/k/negationslash=a/k
/angbracketleft0,k−1,1/angbracketrightw otherwise
(8)
whereinlcm is the least common multiple function, istart =
(a%k)/gcd (s,k), andiend=(k−1−a%k)/gcd(s,k ). All
the arithmetic operations in the above formula are modulo
2w. When one of the two ﬁrst conditions in Formula 8 are
satisﬁed, the resulting interval represents the exact values.However in case of violation, the otherwise case represents
an over-approximation of the possible values.
In case of a>b , the resulting values should be the
remainder of both kand2
w. Whenb−a≥lcm(s,k)−s
andgcd(k,2w)=k then the resulting values can be rep-
resented by the second rule in Formula 8. Otherwise if theconditions are not satisﬁed, interval /angbracketlefta,b,s/angbracketright
wshould be split
into two sub-intervals according to Formula 1 and each isanalyzed separately. The remainder operator is not supportedby PARTI [13].
5) Comparison: The unsigned comparison expressions,
xcmpy, where cmp∈{<,≤,>,≥,=,/negationslash=}can all be converted
into an equivalent expression using only <operation. For
operations cmp∈{ ≤,>,≥,=,/negationslash=}the equivalent versions
are1−(y<x ),y<x ,1−(x<y ),y−x< 1,
and 0<y−x, respectively. Therefore, we only need tox?<yEvaluationResulting Interval
x y
ifb<cfalse ⊥ ⊥
true /angbracketlefta, b, s x/angbracketright /angbracketleftc, d, s y/angbracketright
ifd≤afalse /angbracketlefta, b, s x/angbracketright /angbracketleftc, d, s y/angbracketright
true ⊥ ⊥
ifc=d∧ false /angbracketleftc, b, sx/angbracketright /angbracketleftc, d, s y/angbracketright
a<c≤ btrue /angbracketlefta,lubx(c−1),s x/angbracketright/angbracketleftc, d, s y/angbracketright
ifa=b∧ false /angbracketlefta, b, s x/angbracketright /angbracketleftc, a, s y/angbracketright
c≤a<d true /angbracketlefta, b, s x/angbracketright /angbracketleftglby(a+1),d ,s y/angbracketright
TABLE I: The exact evaluation of less-than operation.
reason about <operation. Given two intervals x=/angbracketlefta,b,s x/angbracketright
andy=/angbracketleftc,d,s y/angbracketrightwherea≤bandc≤d, Table I shows the
conditions under which the evaluation of x<y can be decided
by specifying the exact values that each operand can take.
If the intervals for both operands are wrapped then the
precise operands’ values cannot be efﬁciently computed. How-ever, if only one of them is wrapped and the other operand isa concrete value then a precise decision can be made. In thiscase the evaluation is done by splitting the wrapped intervalinto two sub-intervals based on Formula 1 and then comparingthe operands accordingly.
Moreover, if either of the intervals for operands are repre-
sented by more than one SVI, the other operand has to be aconcrete value so that exact decisions can be made.
B. Backward Propagation of Constraints
Taking each branch of a conditional expression might
tighten the bounds of possible values for each operand. In
consequence, all the other variables in the program whichwere in relation with those operands through an assignmentexpression and up to the current program location have to beupdated. For example, if we consider the interval /angbracketleft10,20,1/angbracketright
for variable xand execute y=2∗xthe resulting interval for y
is/angbracketleft20,40,2/angbracketright. Now the program may contain either if(y<30)
orif(x< 18)statements which forms two different types of
bound propagation. The ﬁrst one should revise the value inter-vals back to the variables from which ywas computed (i.e., x
through the expression y=2∗x), and the second one should
update resulting variables of the assignment expressions inwhichxwere involved (i.e., yin the expression y=2∗x). We
call these two types of backward propagation as left-to-right,
and right-to-left propagations, respectively. In our example the
condition if(y<30)tightens the constraint on yto/angbracketleft20,28,2/angbracketright
and then this new constraint should be propagated to updatethe value interval of xto/angbracketleft10,14,1/angbracketright. Furthermore, for the right-
to-left propagation type, the condition if(x<18) tightens
the constraint on xto/angbracketleft10,17,1/angbracketrightand then this new interval is
propagated through the expression y=2∗xwhich updates
the value interval of yto/angbracketleft20,34,2/angbracketright.
The right-to-left propagation is the same as what is done
in forward propagation of constraints as described in SectionIV-A. In order to deal with the left-to-right propagation weneed to deﬁne the inverse semantics of each operation.
Let us assume that the values for variable xare represented
as/angbracketlefta,b,s
x/angbracketright. If we execute the expression y=x⊙kwhere
207⊙∈{ +,−,∗,/, %}andk>0is a concrete integer value, the
resulting values for ywill be represented by /angbracketleftc,d,s y/angbracketright. Now the
execution of the conditional expression if(y<t )may tighten
the possible values of yto/angbracketleftc/prime,d/prime,sy/angbracketrightwherec/prime,d/prime∈/angbracketleftc,d,s y/angbracketright.
In order to update the values of xbased on the new values of
y, we need to inverse the applied operation as follows.
Operation New Bounds
x+kork+xa/prime=c/prime−k
b/prime=d/prime−k
x−ka/prime=c/prime+k
b/prime=d/prime+k
k−xa/prime=k−d/prime
b/prime=k−c/prime
TABLE II: Inverse of addi-
tion and subtraction opera-tions.1) Addition/Subtraction:
The addition can be reversedby subtraction and thesubtraction is reversed usingeither addition or subtraction.Table II shows how to reversean addition or a subtractionby indicating expressions tocompute bounds of variable x.
The semantics of addition andsubtraction to do reversion is the same as what is explainedin Section IV-A.
2) Multiplication: The multiplication can be reversed using
division as follows:
a
/prime=a+(c/prime−c)/k andb/prime=a+(d/prime−c)/k (9)
for example, considering /angbracketleft263,264−1,1/angbracketright64as the value inter-
val ofx, then multiplication of xby2results in /angbracketleft0,264−2,2/angbracketright64
when the arithmetic is modulo 264. Now we execute if(y<
232)and thus the tightened interval for yis/angbracketleft0,232−2,2/angbracketright64.
The original bounds for xcan be updated as 263+(0− 0)/2and
263+(232−2−0)/2. PARTI [13] omits explaining the details
of how multiplication is reversed using a division especiallywhile wrapping occurs.
3) Division: Whenever for the original interval of xcon-
ditiona≤bis satisﬁed, the new bounds for xare as follows:
a
/prime=/braceleftbiggac/prime∗k≤a
glbx(c/prime∗k)c/prime∗k>a
b/prime=lubx(d/prime∗k+offset)(10)
Moreover, offset is computed as:/braceleftbiggb−d/prime∗kb < d/prime∗k+k−1
k−1b≥d/prime∗k+k−1(11)
In fact, the purpose of offset is to reverse the side effect of
integer division. In integer division the result loses its decimalpart (e.g. 15/2=7 ) and in order to be able to reverse
that we need to compute offset. For example, we assume
x=/angbracketleft11,27,4/angbracketrightand we execute y=x/2theny=/angbracketleft5,13,2/angbracketright
and the execution of if(5<y)results in a new value interval
y=/angbracketleft7,13,2/angbracketrightand thus x=/angbracketleft15,27,4/angbracketright.
In case of a>b , inversion should be applied with respect to
two non-wrapped sub-intervals /angbracketlefta,max,s
x/angbracketrightand/angbracketleftmin,b,s x/angbracketright
ofxcomputed according to Formula 1. The backward propa-
gation of division is not supported by PARTI [13].
4) Remainder: To reverse remainder, we need to compute
values inside the interval /angbracketlefta,b,s x/angbracketrightfor which x%k results a
value in/angbracketleftc/prime,d/prime,sy/angbracketright. The analysis of this operation may lead
to a large number of value intervals and thus may be costlyusing the SVI abstraction. Therefore, we omit to apply theexact backward propagation on remainder operation.C. Time Complexity
The time complexity of the decision procedure proposed in
this section depends on the number of instructions and theircost. Given an execution path in a program, we assume that n
indicates the number of instructions on the path, kidentiﬁes
the maximum number of value intervals returned by applyingan operation, and crepresents a constant indicating the upper-
bound on the cost of applying an operation. While doingforward propagation, the time complexity of each addition orsubtraction is O(k
2·c). Moreover, multiplication, division,
modulo, and comparison operations each can be computed inO(k·c). Backward propagation of intervals takes O(n·k·c)
since the depth of backward propagation might be proportionalto the number of executed instructions on the path. Therefore,the total time complexity of the analysis for an execution pathis computed as O(n·k
2·c)+O(n2·k·c). Let us assume that a
symbolic expression is represented by an abstract syntax tree.Each intermediate node of this tree represents an arithmeticoperation and each leaf node represents a concrete or a sym-bolic input value. When the symbolic expressions representingvariables and operands have shallow depth and can be boundedby a constant value d, then this time complexity order tends
toO(n·k
2·c)+O (n·d·k·c).
V. U NDER -APPROXIMATING SVI D ECISION PROCEDURE
In Section IV we explained the conditions under which
our SVI abstraction can provide exact decisions over a set ofconstraints. In order to exploit the efﬁciency of the decisionprocedure presented in Section IV, we propose a techniquewhich enables us to still reason about the satisﬁability of aset of constraints efﬁciently for the cases which conditions inTable I are not satisﬁed anymore. For example, considering theexpression x≤ywherex∈/angbracketleft0,10,1/angbracketrightandy∈/angbracketleft2,10,1/angbracketright, the
striped region in Figure 1b illustrates the values for each of x
andywhich satisfy x≤y. The values of the operands intersect
each other on interval /angbracketleft2,10,1/angbracketrightand for this intersection area in
addition to the value intervals, a less-than-equal relation hasto be set between variables. Representing the precise set ofvalues which each of xandyvariables can take is inefﬁcient
using the SVI abstraction since it may lead to many relativecases and may increase the complexity of the analysis. Theinterval theory proposed by Dustmann et al. [13] does notsupport the backward propagation of such constraints to theinvolving variables. In learning stage of their theory, onlybinary operations whose one side is a constant is analyzed.
In such cases where the intervals of the operands in a
comparison expression overlap each other, the analysis canstill be continued by maintaining an under-approximating setof values, S
A. Keeping a set of values which satisfy the
currently seen set of constraints on the path condition, asopposed to only one generated witness by an SMT solver,may help deciding the satisﬁability of the constraints whichwill appear further on the execution path (The unsatisﬁabili-ty/unreachability decisions cannot be proved using the under-approximation since the set of all values are not available). Thesatisﬁability of a set of constraints which can be determined by
208xy
246810246810
BBBBBBBBBB1111BBBBBBBBBBBBBBB222222222
(a)xy
246810246810
BBBBBBBBBBB
(b)
Fig. 1: a) Boxes B1andB2indicate two candidate under-
approximating regions for the evaluation of x≤yto true.
b) BoxBindicates an under-approximating region for the
evaluation of x≤yto true.
this set of values does not need to be checked by a complete
bit-vector decision procedure (i.e., SMT solver).
Deﬁnition 5.1: Given a constraint satisfaction problem
/angbracketleftX,D,C/angbracketright, a solution box is deﬁned as B=(I1,...,In),
whereIi⊆direpresents a value interval for xi, satisfying C.
An under-approximating set of possible values can be indi-
cated by a box. Figure 1 shows the region (striped) where x≤
yis evaluated as true where x∈/angbracketleft0,10,1/angbracketrightandy∈/angbracketleft2,10,1/angbracketright.
Choosing any box (or set of boxes) in this region determinescandidate intervals for each of the operands which under-approximate the possible resulting values. We avoid selectinga set of boxes since it increases the complexity of the propaga-tion algorithm which harms the efﬁciency. To keep the analysislightweight, one of the design factors is to trade off accuracy ofthe resulting candidate box(es) for faster selection of those. Wepropose and evaluate two methods for the under-approximatingbox selection based on the following observations. Giventhe conditional expression x≤yon an execution path of
a program, depending on the further usages of xandyon the
path, the selection of different boxes can be useful.
Observation 1. In a program which computes the maximum
of elements in an array, the comparison of two array elementsxandyalways takes the greater variable and continues the
execution with that (i.e., yforx≤y, andxfor the negation
x>y ). Therefore, the best choice is a box which prioritizes
the greater variable. The variable prioritization means thatwe assign the largest possible value interval satisfying thecondition to that variable. The story is reverse while computingthe minimum of elements in an array where the comparison oftwo array elements xandyalways takes the smaller variable
and continues the execution with that (i.e., yforx>y , andx
for the negation x≤y). Here the best choice is the box which
prioritizes the smaller variable. Based on this observation wepropose a heuristic which considers two candidate boxes: thebox in which variable yis prioritized over x, and the box
in which variable xis prioritized over y. For example, the
true evaluation of x≤y, as depicted in Figure 1a, leads
to the following choices, respectively: 1) x=/angbracketleft0,2,1/angbracketrightand
y=/angbracketleft2,10,1/angbracketright,2 )x =/angbracketleft0,10,1/angbracketrightandy=/angbracketleft10,10,1/angbracketright.W e
keep the above two choices as candidate boxes for the trueevaluation of x≤yand continue the execution. The ﬁrst
upcoming decision point on the execution path which involvesone of the operands will select one of the boxes which canprovide a decision and the execution is continued with thatchoice. For example, if after the true evaluation of x≤ythe
execution reaches the condition y≤zwherez=/angbracketleft0,5,1/angbracketrightthen
for the rest of the execution on this path the box x=/angbracketleft0,2,1/angbracketright
andy=/angbracketleft2,10,1/angbracketrightis chosen for the true evaluation of x≤y
since this choice leads to decisions for both true and falsebranches of the currently processing condition y≤z.
Observation 2.G i v e nx ≤yon an execution path of a
program, the second observation is when we cannot prioritizeone variable over the other one because both of them are usedfurther on the execution path. In this case we need to select arange of values for each of the involving variables instead ofone concrete value. Therefore, we propose a heuristic whichtakes the middle point in the intersection of the operands’intervals and derives the respective boxes accordingly. Themiddle point provides equal chance to each of the operands.Any other choice prioritizes one of the operands over the otherone. In Figure 1b the middle point of the intersection of theintervals representing variables xandyis6, and thus the
derived box for the x≤ywill be represented as x=/angbracketleft0,6,1/angbracketright
andy=/angbracketleft6,10,1/angbracketright.
Once the under-approximating box(es) is selected the execu-
tion will be continued accordingly. Any satisﬁability decisionwhich can be made base on the selected under-approximatingvalue boxes does not need to be checked with the SMT solver.
VI. I
MPLEMENTATION DETAILS
This section explains the implementation details of the
proposed symbolic execution engine.
Machine State Representation. Symbolic inputs to the pro-
gram are denoted by set In={α1,...,α n}whereαiis
represented as a value interval Ii. The symbolic execution
engine has to keep track of the machine state transitionsas a consequence of executing instructions using symbolicvalues. The machine state at each step of the executionis represented by the current state of the registers and thememory. The stored values inside the registers and memoryaddresses may be symbolic or concrete. The stored value isthe result of applying binary and unary operations on initialsymbolic or concrete input values expressed as a symbolicexpression E. The registers and memory states are indicated
by a mapping from register numbers and memory addressesto symbolic expressions and values which are guarded by thepath condition.
Deﬁnition 6.1: A symbolic value is represented as a tu-
ple/angbracketleftE
pc,V,A/angbracketrightwhereEpcspeciﬁes the symbolic expression
guarded by the path condition, Aindicates the abstraction, and
Vdenotes the set of values with respect to A.
A symbolic memory address M[addr ], or a symbolic
registerRiis represented by a symbolic value tuple which is
associated to the memory address or the register. The elementAof a symbolic value tuple associated to each memory
address indicates the abstraction which has been used so far
209to reason about the set of constraints involving that memory
address.Amainly takes three values of pvi,ubox andbvt
representing precise value interval, under-approximating valuebox, and bit-vector abstractions. A=pviandA=ubox mean
that our SVI decision procedure provides precise, and under-approximating analysis for the involving variable. Otherwisewhen the theory of bit-vectors is used to reason about theconstraints involving that memory address, Ais set tobvt. The
value set Vis represented by a set of wrapped strided value
intervals which specify the precise or under-approximatingvalues. In the worst-case Vonly contains one value which is
obtained from the SMT’s witness. We use a trace of executionhistory to keep track of memory state transitions, which iscalled the memory trace data-structure.
Deﬁnition 6.2: A trace entry, te, for memory address addr
is represented by a tuple /angbracketleft/lscript,prev,M/angbracketright where/lscriptis the location
of the instruction which caused creating the trace entry, prev
points to the previous symbolic value tuple of addr , andM
represents the new symbolic value tuple for addr .
The operations which update the memory trace are any
instructions whose execution affects the symbolic value of amemory address. These operations include storing a symbolicexpression into a memory address, evaluating a symbolic con-ditional expression, and executing a system call such as read,
orbrk. At each point of the execution of a program the trace
should return the most recently updated symbolic value tuplewhich is stored into a speciﬁc memory address. This is done bykeeping track of pointers which assign memory addresses tothe corresponding trace entries which contain the most recentlyupdated values. The previously stored values into a memoryaddress by previous instructions and on different pending pathsduring symbolic execution of code are kept on the trace forfurther backtracking.
ASE Algorithm. Algorithm 1 illustrates the symbolic exe-
cution algorithm. The execution starts at the initial programlocation/lscript
0. Depending on the instruction which is currently
under execution, the engine updates its state. When a memoryaddress (variable) is speciﬁed with a symbolic input then asymbolic value tuple representing its value is stored at thatmemory address (line 5). For example, if we assign a rangeof values between 10and20to variable a, then this is done
by assigning an interval /angbracketleft10,20,1/angbracketrightfor our value interval
abstraction and a symbolic expression denoting 10≤a≤20.
A symbolic expression is represented as an abstract syntaxtree. A symbolic expression which is evaluated as a concretevalue is stored accordingly in the memory.
The content of a memory address M[addr ]is loaded by
putting a symbolic value tuple /angbracketleftE
pc,V,A/angbracketrightstored at that
memory address into a destination register (line 7). Each store,
which may be interpreted as an assignment in high level code,updates the memory with the symbolic value of a register (line9). Moreover, it keeps track of the memory aliases which iscreated between variables through this assignment (e.g., thealiasing relation between aandbthrougha=3∗b).
During the execution whenever a conditional expression
R
d=RicmpRjis reached where cmp∈{<,≤,=,/negationslash=}, thenAlgorithm 1: Abstract Symbolic Execution Engine
Input : Program P
1/lscript=0 ;
2while true do
3 switch op(/lscript) do
4 case read:
5 M[addr ]=/angbracketleftEpc
α,Vα,pvi/angbracketright;
6 case load:
7 Ri=M[addr ];
8 case store:
9 M[addr ]=Ri;
10 caseif(Rd):
//Rd=RicmpRj,cmp∈{<,<=, =,/negationslash=}
11 false reachability = evaluate(R d=false );
12 iffalse reachability == true then
13 save_context(R d=false );
14 end
15 true reachability = evaluate(R d=true);
16 iftrue reachability == true then
17 pc=pc∧(Rd=true) ;
18 else
19 backtrack();
20 end
21 case end-point:
22 generate_witness();
23 backtrack();
24 default:
25 propagate_forward(op(/lscript), abstraction);
26 end
27/lscript=next/lscript;
28 if/lscript=0then terminate;
29end
the reachability of the true and false branches is evaluatedby calling the evaluate function. The reachability of the
false branch is tried ﬁrst and if it is reachable, the symbolicexecution context for the false evaluation of the conditionalexpression is saved for further backtracking (line 13). After-wards, the reachability of the true branch is examined and ifit is reachable, the true evaluation of the condition will beadded to the explored path condition so far (line 17). If thetrue branch is not reachable the execution will be continuedwith the false branch by backtracking (line 19).
Theevaluate function, as depicted in Algorithm 2, takes
the conditional expression as input and returns the reachabilitydecision as its output. In this function the decision proce-dures are tried in order. DP
pvi(.)andDPubox(.)functions
refer to the evaluation of the comparison operation in thedecision procedures of sections IV and V, respectively. Thepropagate_backward function implements the semantics
explained in Section IV-B. The newly evaluated SVIs for eachof the operands, R
iandRj, are propagated backwards with
respect to the underlying abstraction. This function reﬁnes thepossible values of the involving variable in each operand andall expressions in which those were involved until it reachesan input variable. While propagating backwards if the enginedetects that further propagation is not possible, for examplebecause of an unsupported operation such as remainder, thefunction returns a failure. In case neither of the precise and theunder-approximating decision procedures can provide a deci-sion, the reachability is decided by the SMT solver (line 18). In
210Algorithm 2: evaluate
Input : constraint Rd=RicmpRj
Output: true or false
1ifA(Ri)== pvi && A(Rj)== pvi then
2 [can handle, reachability result] = DPpvi(Rd);
3 ifcan handle == true then
4 ifreachability result == false then return false;
5 ri=propagate_backward(R iwhenRd,pvi);
6 rj=propagate_backward(R jwhenRd,pvi);
7 ifri== true && rj== true then return true;
8 end
9end
10ifA(Ri)/negationslash=bvt &&A(Rj)/negationslash=bvt then
11 [can handle] = DPubox(Rd);
12 ifcan handle == true then
13 ri=propagate_backward(R iwhenRd,ubox);
14 rj=propagate_backward(R jwhenRd,ubox);
15 ifri== true && rj== true then return true;
16 end
17end
18ifcheck_sat_SMT_solver(R d)== true then
19 upgrade_abstraction(bvt);
20 return true;
21else
22 return false;
23end
case of a satisﬁability decision, the abstraction of the involving
symbolic variables are upgraded to bvtand the value set Vof
each is updated with the generated witness of the SMT solverusing the upgrade_abstraction function (line 19).
The default case at line 25 of Algorithm 1 applies the
forward propagation of the other operations including addi-tion, subtraction, multiplication, division, and remainder. Theforward_propagation function applies forward propaga-
tion of the current instruction based on the semantics explainedin Section IV-A when the abstraction is SVI, or keeps trackof symbolic expressions to be used for bit-vector abstractionlayer. While symbolically executing the program, the targetmay be to generate test inputs which trigger an end-point, forexample the exit point of the program on a path or an errordetection (line 22). Moreover, reaching an end-point triggers abacktracking (line 23). Through the backtracking, the machinerestores its previous state for a given pending path. Thus, itundoes the effect of instructions which were executed after agiven branching point. This includes undoing trace entries byrestoring the previous value for each memory address, pointedbyprev element of the trace entry, and updating the pointer
to the most recent value of that memory address. Moreover,the path condition is retrieved to the previous state.
Considering the example of Listing 2, a conditional ex-
pression is evaluated as follows using evaluate function.
Variables xandytake two symbolic values represented as
two SVIs and their abstraction is set to pvi(lines 2 and 3).
When the execution reaches the conditional expression at line4, the reachability of the false evaluation of the branch istried ﬁrst by using the precise SVI decision procedure. Anexact decision for evaluating 3∗/angbracketleft10,30,1/angbracketright−1≥45can
be made by DP
pvi(.). Thus, the values for xwill then be
reﬁned to /angbracketleft16,30,1/angbracketrightusing propagate_backward functionwithpviabstraction and evaluate returnstrue. The current
execution context will be saved for further backtracking, andthen the reachability of the true branch is examined. Theevaluation of 3∗/angbracketleft10,30,1/angbracketright− 1<45is done accordingly
usingDP
pvi(.)and the values for xwill then be reﬁned to
/angbracketleft10,15,1/angbracketrightwithpviabstraction and evaluate returnstrue.
The recently evaluated constraint will be added to the pathcondition and the execution continues on the true branch.
1 int x, y;
2 x = <10, 30, 1>;
3 y = <10, 20, 1>;
4 if(3*x-1<4 5 ){
5 if(x <= y) {
6 if(x > 12) {
7 ...;
8 }else { ...; }
9 }else { ...; }
10 }else { ...; }
Listing 2: An example toshow how reachability isevaluated using ASE.At line 5 to decide the reacha-
bility of the false branch, x>y ,
ﬁrstDP
pvi(.)is tried since the
abstraction used for representingxandyis stillpvi. However,
since the operands’ value inter-vals overlap each other, the pre-cise backward propagation is notpossible (See Section V). Thus,at next step DP
ubox(.)is tried to
check if it can provide a decision.Using Observation 2 of Section V,a decision can be made by setting /angbracketleft13,15,1/angbracketrightand/angbracketleft10,12,1/angbracketright
under-approximating SVIs for operands xandy, respectively.
Hence, the abstraction for xandyare set to ubox and
evaluate returnstrue. The execution context will be saved,
and next the reachability of the true branch is investigated. Theevaluation of x≤y, is done accordingly using Observation 2
of Section V and the values for xandywill then be
reﬁned to /angbracketleft10,12,1/angbracketrightand/angbracketleft12,20,1/angbracketrightusingubox abstraction
andevaluate returnstrue. The path condition is updated
and the execution continues on the true branch. Later, whenline 6 is reached, the current abstraction for xisubox and
thusDP
ubox(.)is ﬁrst checked whether it can provide an exact
decision over reachability of the false branch, /angbracketleft10,12,1/angbracketright≤ 12,
based on the operands’ SVIs. The satisﬁability is decidedby considering values /angbracketleft10,12,1/angbracketrightforxusingubox abstrac-
tion. The current execution context for false branch is savedand then the true branch is evaluated. The evaluation of/angbracketleft10,12,1/angbracketright>12, however cannot be decided using DP
ubox(.)
since we only keep an under-approximation of possible valuesand those values do not satisfy the condition. Therefore, theabstraction is upgraded to bvtand a query, including the
symbolic constraint guarded by the path condition, will be sentto the SMT solver to be decided. The value sets for xandy
will be reﬁned by the generated witness of the solver (e.g.,V
x=/angbracketleft14,14,1/angbracketrightandVy=/angbracketleft14,14,1/angbracketright) and their abstraction is
set tobvt. Now that we reached to an end-point, the execution
backtracks to traverse the false evaluations of the conditionsstarting at the saved context for the false branch of line 6.It is worth mentioning that the interval theory proposed inPARTI [13] cannot reason about this example.
VII. E
V ALUATION
In this section, we demonstrate the effectiveness of our
proposed ASE engine in speeding up the symbolic analysis. InSection IV-C we discussed the asymptotic time complexity ofthe proposed SVI decision procedure. In this section the goal is
211benchmark #pathsASE (O1) ASE (O2) PARTI baseline reduction in execution time for ASE (%)
time (s) #queries time (s) #queries time (s) #queries time (s) #queriesversus PARTI versus baseline
O1 O2 O1 O2
bubble sort 1 300 32.86 0 33.50 0 32.49 0 206.39 67350 -1.13 -3.10 84.08 83.77
bubble sort 3 55445 670.84 637821 588.35 559587 779.11 728766 1207.21 1135634 13.90 24.48 44.43 51.26
bubble sort all 40320 244.69 233087 65.14 91796 255.90 234958 249.14 234958 4.38 74.54 1.79 73.85
heap sort 1 275 3.22 0 3.20 0 3.11 0 7.11 2340 -3.48 -2.68 54.69 55.04
heap sort 3 39286 93.41 104524 95.68 105620 140.81 162096 437.36 518822 33.66 32.05 78.64 78.12
heap sort all 135423 1188.13 960034 982.57 830632 1202.91 964444 1180.73 964444 1.23 18.32 -0.63 16.78
insertion sort 1 300 26.23 0 26.32 0 25.53 0 204.87 67350 -2.75 -3.07 87.19 87.15
insertion sort 3 55445 1391.06 1420769 1208.43 1249913 1575.29 1575736 2830.64 2860000 11.69 23.29 50.86 57.31
insertion sort all 40320 73.21 80057 5.22 4878 75.33 80638 74.35 80638 2.81 93.08 1.54 92.98
merge sort 1 300 0.91 0 0.91 0 0.88 0 1.93 896 -3.99 -3.58 52.80 52.98
merge sort 3 55445 40.14 29460 23.73 14125 45.12 34746 149.79 147400 11.04 47.41 73.20 84.16
merge sort all 40320 71.36 78750 58.94 63238 77.01 80638 76.84 80638 7.34 23.47 7.13 23.30
quick sort 1 300 19.73 0 19.94 0 19.84 0 18.55 598 0.52 -0.55 -6.34 -7.49
quick sort 3 49675 274.33 205666 212.65 162382 304.82 230898 558.60 446606 10.00 30.24 50.89 61.93
quick sort all 40320 109.53 78800 15.36 9757 111.27 80638 109.93 80638 1.56 86.20 0.37 86.03
selection sort 1 300 16.60 0 16.49 0 16.10 0 2697.72 1192300 -3.11 -2.43 99.38 99.39
selection sort 3 60535 3288.82 2913602 2658.36 2480695 3411.95 3030568 4358.47 3828538 3.61 22.09 24.54 39.01
selection sort all 101773 623.13 521344 403.23 351101 629.13 526350 625.52 526350 0.95 35.91 0.38 35.54
dijkstra 11632 775.70 88726 724.14 83034 790.76 89990 862.19 99564 1.90 8.42 10.03 16.01
kruskal 7129 746.51 711343 678.89 658255 794.07 738072 830.87 789714 5.99 14.51 10.15 18.29
bellman-ford 326 760.89 91752 766.24 91752 763.01 91752 836.81 102876 0.28 -0.42 9.07 8.43
binary search all 4001 0.12 0 0.11 0 904.50 8000 905.90 8000 99.99 99.99 99.99 99.99
linear ﬁnd all 1001 0.04 0 0.04 0 101.71 2000 102.66 2000 99.96 99.96 99.96 99.96
ispermutation 96499 1483.62 1622733 532.04 794099 1649.28 1716634 1620.05 1716634 10.04 67.74 8.42 67.16
gcd 401 272.69 3183 269.13 3183 266.32 3188 279.13 3192 -2.39 -1.05 2.31 3.58
loop invgen 4098 401.34 22859 262.02 17369 580.93 29846 775.26 34440 30.91 54.90 48.23 66.20
min max all 19683 128.90 72067 129.89 74362 139.27 77706 137.76 77706 7.45 6.74 6.43 5.71
dirname 65535 2.05 0 2.06 0 2.01 0 326.42 815764 -1.97 -2.15 99.37 99.37
ﬁbonacci 21 0.20 0 0.19 0 0.19 0 32.68 206554 -2.83 -1.92 99.40 99.41
half 1002 0.03 0 0.03 0 81.73 8006 81.36 8010 99.96 99.96 99.96 99.96
outer product 15625 0.36 0 0.36 0 189.72 140616 186.51 140616 99.81 99.81 99.81 99.81
TABLE III: The number of explored paths, the symbolic execution time, the number of reached queries to the SMT solver for
each of the ASE, the PARTI, and the baseline approaches. O1 and O2 stand for Observation 1 and Observation 2 which areapplied in the ASE approach. The reduction in symbolic execution time for the ASE compared to the PARTI and the baselineapproaches is reported in percentage and illustrated in last four columns.
to show the efﬁciency of employing the proposed SVI decisionprocedure in practice by running the ASE engine on a set ofbenchmark programs. We evaluate the engine by comparingthe following approaches: 1,2) ASE (O1) and ASE (O2) which
refer to the proposed engine and its decision procedure in thispaper by applying the heuristic methods of Observation 1 andObservation 2 proposed in Section V, respectively. 3) PARTI
refers to the state-of-the-art approach [13]. 4) baseline is a
design strategy which uses an SMT solver for the constraintsolving component of the symbolic execution. In baselineall the generated symbolic constraints out of the benchmarkprograms are sent to the SMT solver as query to be solved.
A. Experimental Setup
We ran our experiments on a 512GB NUMA machine with
four 16-core 2.3 GHz AMD Opteron 6376 processors and
Linux kernel version 4.15. For our experiments, we usedBoolector [25] version 3.2.1 with CaDiCaL as backend SATsolver, and incremental mode enabled. We used GCC andG++ version 9.3 to build Boolector SMT solver and compileour implemented ASE engine source code. We set depth ﬁrst
search (DFS) strategy to explore the paths in benchmark
programs. The witnesses for each explored path are computedbut they are not printed for none of the approaches. Whileexecuting, depending on the underlying abstraction the enginekeeps the set of values V(precise or under-approximation) for
variables on a path updated for all the approaches.
We run our experiments on a set of benchmarks from
different classes of programs typically used in evaluatingsymbolic execution approaches [13], [26], [27], includingsorting, searching, graph, and computational algorithms. Thesource code of the benchmark programs, which is written ina subset of C, are compiled to a subset of RISC-V using anon-optimizing compiler [28]–[30].
B. Experimental Results
Table III reports the execution results of running all ap-
proaches on a set of benchmarks. The reported data includes
the number of explored paths (which are identical for allapproaches), the symbolic execution time, and the number ofqueries that reached the SMT solver. The sufﬁxes added tothe names of the benchmarks indicate the number of involvedsymbolic values in their input data (e.g. array, graph), namelyall, 3, and 1. For example, in bubble
sort 1and bubble sort 3
the input arrays for sorting contain one and three symbolic val-ues respectively and the rest are concrete values. Similarly allthe values in the input array for bubble
sort allare symbolic.
The last four columns of Table III report the reduction
in symbolic execution time caused by employing ASE usingtwo different heuristic methods of Observations 1 and 2
212explained in Section V. Compared to the PARTI and the
baseline approaches, on average the ASE engine which isbased on Observation 1 led to 17.33% and 45.1% reductionin symbolic execution time, respectively. The application ofthe ASE engine based on Observation 2 showed an averageof 33.62% reduction in symbolic execution time comparedto the PARTI approach and an average of 59.84% reductioncompared to the baseline. The results show that the ASEengine using either of the heuristic methods of Observations1 and 2 performs effective while, whenever it does not work,the overhead remains low. Moreover, the usage of the heuristicof Observation 2 for generating under-approximating valueintervals often helps deciding more queries and consequentlyleads to better performance than the heuristic of Observation 1.
The array sorting benchmark programs provide a useful case
study for our evaluation. By inserting different number of sym-bolic values inside the input array to be sorted we can examinethe effectiveness of the techniques used in our engine. The sizeof input arrays for benchmarks with 1,3, and allsufﬁxes are
300, 40, and 8, respectively. The inserted symbolic values arerepresented by value intervals /angbracketleft0,2∗size, 1/angbracketrightwheresize is the
array length. Selecting an interval with a larger upper boundsuch as/angbracketleft0,MAX, 1/angbracketrightdoes not inﬂuence the number of ex-
plored paths for none of the approaches. However, selection ofthe larger interval /angbracketleft0,MAX, 1/angbracketrighton average causes the under-
approximating decision procedure to perform more effectively.As it is shown in Table III for the array sorting benchmarksASE performs almost as good as the PARTI approach when thenumber of symbolic values in the input array is one. However,when this number is increased ASE outperforms the PARTIapproach. When the number of involving symbolic values islimited to one, the precise SVI decision procedure is enoughto make decisions over the set of generated constraints. Forsorting algorithms this means that always one side of theinvolving comparison expressions on the path condition isevaluated to a concrete value. However, when this number isincreased, the precise SVI decision procedure may not be ableto decide all sets of constraints generated out of the program.In particular when the analysis involves the comparison ofvariables with overlapping symbolic values (e.g., x<y where
x=/angbracketleft0,80,1/angbracketrightandy=/angbracketleft0,80,1/angbracketright). The interval theory in
PARTI does not support the backward propagation of suchconstraints. Whereas, ASE tries to continue the analysis usingthe SVI abstraction with under-approximation (Section V),and thereafter if the engine still could not provide a decisionusing the under-approximation abstraction it sends the set ofconstraints to the SMT solver. As depicted in Table III theapplication of the SVI abstraction with under-approximationperforms effective for the array sorting benchmarks when morethan one symbolic value in the input is involved and it reducesthe number of sent queries to the SMT solver.
The results for bellman-ford and gcdprograms show cases
that the application of the under-approximating SVI deci-sion procedure does not perform effective. However, theinduced overhead is very low which is the result of apply-ing lightweight heuristics to compute under-approximatingboxes, and therefore this causes the ASE engine to workalmost as good as PARTI. On the other hand, the under-approximating SVI decision procedure performs effective toanalyze binary
search alland linear ﬁnd allprograms for
which all the required decisions are made by the precise andunder-approximating SVI decision procedures.
As depicted, all the generated constraints out of dirname,
ﬁbonacci benchmarks can be solved by the precise SVI deci-
sion procedure. Thus, ASE performs almost as good as PARTI.The half and outer
product benchmark programs contain
expressions with linear symbolic multiplication operation. Asexplained in Section IV this kind of expression has to bedealt with the value interval abstraction with step. Hence, theinterval abstraction proposed in PARTI which only considersvalue bounds cannot reason about such expressions. This is thereason why ASE outperforms PARTI for these benchmarks.
In summary, we learned that many of the constraints
generated out of the programs use a handful of operationswith special features that can be solved by the SVI decisionprocedure. Therefore, employing our theory integration in alayered manner of increasing capability and complexity forconstraint solving of symbolic execution is effective. However,a key design factor is to keep the former layers as lightweightas possible so that it does not harm efﬁciency and performancecompared to SMTs or when former layers fail.
VIII. C
ONCLUSION
We presented abstract symbolic execution (ASE) with the
goal of speeding up reachability decision making in symbolicexecution. The ASE engine beneﬁts from a theory integrationinside the constraint solving component of symbolic executionin a layered manner of increasing capability and complexity byemploying SVI and bit-vector abstractions. We learned throughexperiments on a set of benchmark programs that many of theconstraints generated out of the programs can be solved by theless complex SVI decision procedure. Therefore, employingour theory integration for constraint solving is often effectivein reducing symbolic execution time and the number of queriesreaching the SMT solver. However, keeping the former layerslightweight is a key design factor to preserve the efﬁciency ofthe analysis compared to SMTs or when former layers fail.
Extending the ASE engine to make decisions over ﬂoating-
point arithmetic is a promising future direction. Our conjectureis that employing the existing, more complicated propagationtechniques for the box abstraction leads to an even betterspeedup for ﬂoating-point numbers compared to integers.
A
CKNOWLEDGMENT
We thank the ASE reviewers for their thoughtful comments.
This work has been supported by the Czech Ministry ofEducation, Youth and Sports from the Czech OperationalProgramme Research, Development, and Education, undergrant agreement No. CZ.02.1.01/0.0/0.0/15
003/0000421, and
the European Research Council (ERC) under the EuropeanUnions Horizon 2020 research and innovation programme,under grant agreement No. 695412.
213REFERENCES
[1] R. Baldoni, E. Coppa, D. C. D’Elia, C. Demetrescu, and I. Finocchi,
“A survey of symbolic execution techniques,” ACM Computing Surveys,
vol. 51, no. 3, pp. 1–39, 2018.
[2] C. Cadar, D. Dunbar, and D. Engler, “Klee: Unassisted and automatic
generation of high-coverage tests for complex systems programs,” in
Proceedings of the 8th USENIX Conference on Operating SystemsDesign and Implementation, 2008, pp. 209–224.
[3] B. Korel, “A dynamic approach of test data generation,” in Proceedings.
Conference on Software Maintenance, 1990, pp. 311–317.
[4] J. C. King, “Symbolic execution and program testing,” Communications
of the ACM, vol. 19, no. 7, pp. 385–394, 1976.
[5] D. Kroening and O. Strichman, Decision Procedures, An Algorithmic
Point of View. Springer Berlin Heidelberg, 2008.
[6] M. Brain, D. Kroening, and R. McCleeary, “Algebraic techniques in
software veriﬁcation: Challenges and opportunities,” in Proceedings of
the 1st Workshop on Satisﬁability Checking and Symbolic Computation,2016, pp. 8–12.
[7] S. Bardin, N. Bjørner, and C. Cadar, “Bringing cp, sat and smt together:
Next challenges in constraint solving (dagstuhl seminar 19062),” inDagstuhl Reports, vol. 9, no. 2. Schloss Dagstuhl Leibniz Zentrumfuer Informatik, 2019.
[8] R. Sen and Y . N. Srikant, “Executable analysis using abstract inter-
pretation with circular linear progressions,” in Proceedings of the 5th
ACM/IEEE International Conference on F ormal Methods and Modelsfor Codesign, 2007, pp. 39–48.
[9] Y . Shoshitaishvili, R. Wang, C. Salls, N. Stephens, M. Polino,
A. Dutcher, J. Grosen, S. Feng, C. Hauser, C. Kruegel, and G. Vigna,“Sok: (state of) the art of war: Offensive techniques in binary analysis,”inIEEE Symposium on Security and Privacy, 2016, pp. 138–157.
[10] T. Reps, G. Balakrishnan, and J. Lim, “Intermediate-representation
recovery from low-level code,” in Proceedings of the ACM SIGPLAN
Symposium on Partial Evaluation and Semantics-based Program Ma-nipulation, 2006, pp. 100–111.
[11] G. Balakrishnan and T. Reps, “Wysinwyx: What you see is not what you
execute,” ACM Transactions on Programming Languages and Systems
(TOPLAS), vol. 32, no. 6, pp. 1–84, 2010.
[12] N. Redini, R. Wang, A. Machiry, Y . Shoshitaishvili, G. Vigna, and
C. Kruegel, “Bintrimmer: Towards static binary debloating throughabstract interpretation,” in International Conference on Detection of
Intrusions and Malware, and Vulnerability Assessment, 2019, pp. 482–501.
[13] O. S. Dustmann, K. Wehrle, and C. Cadar, “Parti: A multi-interval theory
solver for symbolic execution,” in Proceedings of the 33rd ACM/IEEE
International Conference on Automated Software Engineering, 2018, pp.430–440.
[14] B. Mayoh, E. Tyugu, and J. Penjam, Constraint Programming. Springer
Berlin Heidelberg, 1994.
[15] G. Gange, J. A. Navas, P. Schachte, H. Søndergaard, and P. J. Stuckey,
“Interval analysis and machine arithmetic: Why signedness ignoranceis bliss,” ACM Transactions on Programming Languages and Systems
(TOPLAS), vol. 37, no. 1, pp. 1–35, 2015.
[16] A. Gotlieb, M. Leconte, and B. Marre, “Constraint solving on mod-
ular integers,” in Proceedings of the Ninth International Workshop on
Constraint Modelling and Reformulation, 2010.
[17] R. Bruttomesso, A. Cimatti, A. Franz ´en, A. Griggio, Z. Hanna, A. Nadel,
A. Palti, and R. Sebastiani, “A lazy and layered smt(bv) solver for hardindustrial veriﬁcation problems,” in Proceedings of the 19th Interna-
tional Conference on Computer Aided V eriﬁcation, 2007, pp. 547–560.
[18] L. Hadarean, K. Bansa, D. Jovanovi ´c, C. Barrett, and C. Tinelli, “A tale
of two solvers: Eager and lazy approaches to bit-vectors,” in Proceedings
of the 26th International Conference on Computer Aided V eriﬁcation,2014, pp. 680–695.
[19] C. Barrett, C. L. Conway, M. Deters, L. Hadarean, D. Jovanovi’c,
T. King, A. Reynolds, and C. Tinelli, “Cvc4,” in Proceedings of the
23rd International Conference on Computer Aided V eriﬁcation, 2011,pp. 171–177.
[20] S. Anand, C. S. P ˘as˘areanu, and W. Visser, “Jpf–se: A symbolic exe-
cution extension to java pathﬁnder,” in Tools and Algorithms for the
Construction and Analysis of Systems, 2007, pp. 134–138.
[21] D. Beyer, T. A. Henzinger, and G. Th ´eoduloz, “Program analysis with
dynamic precision adjustment,” in Proceedings of the 23rd IEEE/ACMInternational Conference on Automated Software Engineering, 2008, pp.29–38.
[22] S. Anand, C. S. P ˘as˘areanu, and W. Visser, “Symbolic execution with
abstraction,” International Journal on Software Tools for Technology
Transfer, vol. 11, no. 1, pp. 53–67, 2009.
[23] J. Geldenhuys, M. D. B, and W. Visser, “Probabilistic symbolic exe-
cution,” in International Symposium on Software Testing and Analysis,
2012, pp. 166–176.
[24] T. A. Henzinger, R. Jhala, R. Majumdar, and G. Sutre, “Lazy abstrac-
tion,” in Proceedings of the 29th ACM SIGPLAN-SIGACT Symposium
on Principles of Programming Languages, 2002, pp. 58–70.
[25] A. Niemetz, M. Preiner, and A. Biere, “Boolector 2.0: System descrip-
tion,” Journal on Satisﬁability, Boolean Modeling and Computation ,
vol. 9, no. 1, pp. 53–58, 2014.
[26] C. Saumya, J. Koo, M. Kulkarni, and S. Bagchi, “Xstressor : Automatic
generation of large-scale worst-case test inputs by inferring path condi-tions,” in Proceedings of the 12th IEEE Conference on Software Testing,
V alidation and V eriﬁcation, 2019, pp. 1–12.
[27] SV-COMP, “Software veriﬁcation competition,” https://github.com/sosy-
lab/sv-benchmarks, 2020.
[28] C. M. Kirsch, “Selﬁe and the basics,” in Proceedings of the 2017 ACM
SIGPLAN International Symposium on New Ideas, New Paradigms, andReﬂections on Programming and Software, 2017, pp. 198–213.
[29] A. S. Abyaneh and C. M. Kirsch, “You can program what you want but
you cannot compute what you want,” in Principles of Modeling: Essays
Dedicated to Edward A. Lee on the Occasion of His 60th Birthday,2018, pp. 1–15.
[30] Selﬁe, “An educational software system of a tiny self-compiling c
compiler, a tiny self-executing risc-v emulator, and a tiny self-hostingrisc-v hypervisor,” http://selﬁe.cs.uni-salzburg.at/.
214