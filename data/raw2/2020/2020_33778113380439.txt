Burn After Reading: A Shadow Stack with Microsecond-level
Runtime Rerandomization for Protecting Return Addresses∗
Changwei Zou
School of Computer Science and Engineering
UNSW Sydney, AustraliaJingling Xue
School of Computer Science and Engineering
UNSW Sydney, Australia
ABSTRACT
Return-orientedprogramming(ROP)isaneffectivecode-reuseat-
tack in which short code sequences (i.e., gadgets) ending in a ret
instruction are found within existing binaries and then executed
by taking control of the call stack. The shadow stack, control flow
integrity (CFI) and code (re)randomization are three popular tech-
niquesforprotectingprogramsagainstreturnaddressoverwrites.
However, existing runtime rerandomization techniques operate on
concrete return addresses, requiring expensive pointer tracking.
Byaddingonelevelofindirection,weintroduceBarRA,thefirst
shadowstackmechanismthatappliescontinuousruntimereran-
domizationtoabstractreturnaddressesforprotectingtheircorre-
sponding concrete return addresses (protected also by CFI), thus
avoidingexpensivepointertracking.Asaniceside-effect, BarRAnaturallycombinestheshadowstack,CFIandruntimererandom-
izationinthesameframework.Thekeynoveltyof BarRA,however,
is that once some abstract return addresses are leaked, BarRA will
enforcetheburn-after-readingpropertybyrerandomizingthemap-
ping fromthe abstract to theconcrete return addressspace in the
order of microseconds instead of seconds required for rerandomiz-
ingaconcretereturnaddressspace.Asaresult,BarRAcanbeusedasasuperiorreplacementfortheshadowstack,asdemonstratedbycomparingbothusingthe19C/C++benchmarksinSPECCPU2006
(totalling 2,047,447 LOC) and analyzing a proof-of-concept attack,
providedthatwecantoleratesomeslightbinarycodesizeincreases
(byanaverageof29.44%)andarewillingtouse8MBofdedicated
memoryforholdingupto220returnaddresses(ona64-bitplatform).
Underaninformationleakageattack(forsomereturnaddresses),
theshadowstackisalwaysvulnerablebutBarRAissignificantly
more resilient (by reducing an attacker’s success rate to1
220on
average).Intermsoftheaverageperformanceoverheadintroduced,
both are comparable: 6.09% (BarRA) vs. 5.38% (the shadow stack).
KEYWORDS
ShadowStack,RuntimeRerandomization,ControlFlowIntegrity,
Return-Oriented Programming
∗Thanks to allthe reviewers for theirvaluable comments. This research issupported
by an Australian Research Council grant (DP180104069).
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACMmustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ICSE ’20, May 23–29, 2020, Seoul, Republic of Korea
© 2020 Association for Computing Machinery.
ACM ISBN 978-1-4503-7121-6/20/05...$15.00
https://doi.org/10.1145/3377811.338043902004006008001000
2010 2011 2012 2013 2014 2015 2016 2017 2018 2019# of Information Disclosure Vulnerabilities
Figure1:Riseofinformationdisclosurevulnerabilities[13].
1 INTRODUCTION
Software security is becoming increasingly important due to in-
creased reliance on computer systems. For performance reasons, C
andC++arestillthedefactolanguagesforimplementingOSker-
nels,browsersandwebservers.Duetotheirlackofmemorysafety,
security vulnerabilities such as buffer overflows are frequently
found in C/C++ software applications ranging from servers to em-
bedded systems [ 33,34,47,48,53]. This has allowed an attacker to
launch control-flow hijacking attacks to redirect execution to mali-
cious code by modifying code pointers such as return addresses on
thecallstack[ 40].Duetothewidespreadadoptionofdataexecution
prevention (DEP) techniques such as W ⊕X[31], code-injection
attacks(whichrelyonmaliciouscodeinjectedintoaprogram)[ 25]
are no longer threatening. To circumvent DEP, code reuse attacks
(whichrelyonmaliciouscodeformedfromexistingcodefragments
knownas gadgets)arebecomingmoreprevalent[ 5,8,44].Inpar-
ticular, return-oriented programming (ROP) [ 44] is an effective
code-reuse attack in which a return address on the call stack is
modified to redirect executionto a sequence of gadgets with each
ending ina ret instruction (ROP gadgets ) toperform arbitrary ma-
licious computations. It is thus imperative to develop mitigation
techniques to protect programs against return address overwrites.
Problem Statement. A shadow stack [ 1,3,22] protects a func-
tion’s return address on the call stack by hiding it in the shadow
stack, which cannot be as easily modified by a buffer overflow hap-
peningonthecallstack. However,this mechanismreliesoninforma-
tion hiding (for the shadow stack), and consequently, is vulnerable
to information disclosure and side-channel attacks [ 9,16,19,38].
ASLR (Address Space Layout Randomization) [ 49], which random-
izes the locations of modules at load time, is also vulnerable toinformation leakage attacks [
9,16,19,38]. As shown in Figure 1,
thenumberofinformationdisclosurevulnerabilitiesreportedon
the CVE website [13] has surged in recent years.
Controlflowintegrity(CFI)[ 1]canalsobeusedtoprotectreturn
addresses, by limiting all ROP gadgets to a set of predefined return
addresses, but the resulting attack surface is still too large [7, 15].
2582020 IEEE/ACM 42nd International Conference on Software Engineering (ICSE)
Given that some information leaks are detected during program
execution, we investigate how to apply continuous runtime reran-
domization to make the shadow stack significantly more secure.
Challenges. There are three challenges faced. First, how do we
provide lightweight runtime rerandomization, especially if it needs
to be frequently performed during program execution? Second,
how do we minimize the instrumentation overhead thus intro-
ducedformaintainingtheshadowstack?Finally,howcanwemake
the shadow stack significantly more secure by applying runtime
rerandomization, and possibly, CFI at the same time?
PriorWork:RerandomizingConcreteReturnAddresses. Ex-
isting runtime rerandomization techniques [ 4,28] operate on con-
crete return addresses, and consequently, are applied to the call
stack directly. Once a return address on the call stack has beenleaked, indicating that it may soon be replaced by the address to
aROPgadget,runtimererandomization[ 4,28]canbeappliedso
thattheaddressoftheROPgadgetbecomesinvalidated,thereby
mitigating the impact of information leakage. However, rerandom-
izing concrete return addresses requires expensive and difficult
pointer tracking.For example, RuntimeASLR [ 28] (astate-of-the-
artruntimererandomizer)takes35secondstotrackthepointersfor
thenginxwebserver.Duetoitsexcessiveperformanceoverhead,
RuntimeASLR rerandomizes a freshly-forked child process only
once,atthetimeof fork(),byreusingthepointertrackingresults
of its parent (as the child process inherits the state of its parent
just before it starts its execution). By failing to rerandomize a child
process that has executed for a while, RuntimeASLR avoids the
costsincurredbynewtime-consumingpointertrackingoperations,
but at the risk of being vulnerable to code-reuse attacks (Figure 1).
Tothebestofourknowledge,CFI[ 1]hasbeenappliedtoprotect
forward edges, i.e., indirect calls via function pointer and virtual
calls(insteadofbackwardedges,i.e.,returnaddresses).Theresearch
on forward-edge CFI [ 17,22,50] assumes usually that the shadow
stack mechanism is used for enforcing backward-edge CFI.
This Work: Rerandomizing Abstract Return Addresses. By
addingonelevelofindirection,weintroducethefirstshadowstack
mechanism, BarRA, that applies a novel runtime rerandomiza-tion technique to rerandomize abstract return addresses in theshadow stack to protect their corresponding concrete return ad-dresses,therebyavoidingexpensivepointertrackingasrequired
in RuntimeASLR [ 28]. Under some information leaks, BarRA will
immediately rerandomize the mapping from the abstract to the
concrete return address space in the order of microseconds instead
of seconds as required by RuntimeASLR [ 28]. This enforces the
burn-after-reading property,whichrequiresallleaked(returnad-
dress)informationtobemadeobsoleteviarerandomization.Asa
result, BarRA has made the traditional shadow stack significantly
moresecurewhileincurringacomparableinstrumentationover-
head on average. Finally, BarRA represents the first approach that
protects programs against return address overwrites by combining
the shadow stack, CFI and runtime rerandomization altogether.
This paper makes the following two major contributions:
•We introduce a novel shadow stack mechanism that is ca-pable of applying continuous microsecond-level runtimererandomization for protecting return addresses, makingthe traditional shadow stack significantly more secure at
comparable performance overheads (Sections 2 and 3).
•We have implemented BarRA as a software hardening tool
and experimentally confirmed BarRA as a superior replace-
mentforthetraditionalshadowstack(Section4).Inoureval-
uation, we have used all the 19 C/C++ benchmarks in SPEC
CPU2006(totalling2,047,447LOC)andaproof-of-conceptat-
tack. In the case of information leakage, the shadow stack is
always vulnerable. However, if we can tolerate slight binary
codesizeincreases(byanaverageof29.44%)andarewillingtouse8MBofdedicatedmemoryforholdingupto2
20return
addresses(ona64-bitplatform),wecanmakeBarRAsignifi-cantlymoreresilientthanthetraditionalshadowstackbyre-
ducinganattacker’ssuccessrateto
1
220onaverage.Bothhave
comparable average performance overheads: 6.09% (BarRA)
vs. 5.38% (the shadow stack).
2 BARRA: METHODOLOGY
WemotivateourBarRAmethodologybydescribinghowwecan
transformatraditionalshadowstackintoasignificantlymorese-
cure“burn-after-reading”shadowstack.Section2.1usesanexample
toexplainhowabufferoverflowcanleadtoreturnaddressover-
writesonthecallstack.Section2.2describeshowthisvulnerability
intheexamplecanbeexploitedtolaunchaROPattack.Continuing
with the same example, we describe why the traditional shadow
stackmechanismis vulnerabletoROP attacksinthepresence of
informationleakage(Section2.3)andhowour“burn-after-reading”
shadow stack is significantly more secure (Section 2.4).
2.1 Buffer Overflow Vulnerabilities
Figure 2 illustrates how a buffer overflow bug can cause the return
address of a function on the call stack to be modified.
high
low01 void read_and_echo(void){
02 char buf[BUFSIZE];
03 gets(buf);04 printf(buf);
05 }
06 void do_request(){
07 while(1){08 read_and_echo();09 }
10 }ret addr
...
buf[ ]ret addr
...
buf[ ]do_request
read_and_echo
call stack
Figure 2: A buffer overflow vulnerability.
In lines 1-5, read_and_echo()reads some user input and saves
it in a local buffer buf. As the C library function дets()does not
checkthecapacityof buf,thereisabufferoverflowvulnerabilityin
line 3. In addition, the C library function printf()invoked in line 4
also contains an information disclosure vulnerability [ 9] (exploited
in a proof-of-concept attack in Section 4). By inputting more data
thanbufcan hold, an attacker can corrupt the return address of
read_and_echo()on the call stack with one of her choosing. When
read_and_echo()returns, the control flow will be hijacked.
2592.2 Return Oriented Programming
Figure 3 illustrates a ROP attack [ 44], where three ROP gadgets, A,
B and C, are chained to compute *target = num . By exploiting
abufferoverflowvulnerability(Figure2),anattackercanreplace
thereturnaddressof read_and_echo()withtheaddressofgadget
A. Once this victim function returns, gadgets A, B and C will be
triggered one by one, resulting in a control-flow hijacking attack.
...
addr of gadget C
num
addr of gadget B
target
addr of gadget A...
addr of gadget C
num
addr of gadget B
target
addr of gadget A
call stack03 pop %rsi
04 ret
01 pop %rdi
02 ret05 mov %rsi,(%rdi)
06 ret
gadget C
gadget B
gadget Aret slotfake retfake ret*target = num
Figure 3: A ROP attack (by exploiting, say, the buffer over-
flowvulnerabilityin read_and_echo()ofFigure2),where%rsi
contains the value of numand %rdi the value of target.
ROPisTuringcomplete[ 44].Asaspecialcase,whenagadget
beginsattheentryofafunction,wehaveaso-called return-into-
libc attack [5,44]. The C library function system("/bin/sh") is thus a
popular choice for hijacking the victim by launching an interactive
shell (in a proof-of-concept attack in Section 4).
2.3 The Traditional Shadow Stack
TomitigateaROPattackillustratedinFigure3,ashadowstackhas
traditionallybeenusedtohidethereturnaddressesonthecallstack.
To prevent the return address of read_and_echo()from being over-
written,asshowninFigure4,thereturnaddressof read_and_echo()
is saved in the shadow stack at the offset −OFFSET +8+(%rsp)
(lines 3-4) on entering the function and restored (from the same
location)onleavingthefunction(lines6-8).Byconvention,%rspis
the standard stack pointer pointing to the top of the call stack. For
simplicity, the shadow stack is assumed to have the same size as
the call stack rather than as a FILO stack to save space [6, 22].
saved ret addr
...saved ret addr
...
shadow stack01 read_and_echo:
02 # save return address
03 popq -OFFSET(%rsp)
04 subq $8, %rsp
...
05 # retore return address06 addq $8, %rsp07 movq -OFFSET(%rsp),%r1108 jmpq *%r11ret addr
...
buf[ ]ret addr
...
buf[ ]
call stack
Figure 4: The traditional shadow stack mechanism for pro-
tecting the return address of read_and_echo()in Figure 2.
AsshowninFigure4,theshadowstackusuallyappearsbelowthe
callstackatafixedoffset, OFFSET,whichisgeneratedrandomlyat01 all_ret_addrs = {
02  ra_0, ra_1,..., ra_N-1
03 }
// mapping table
04 BAR_mtable[M]= {…,ra_2,…}
// indirect jump
05 ret_id = fetch_ret_id();
06 jmp BAR_mtable[ret_id]ret addr
...
buf[ ]ret addr
...
buf[ ]
call stack
(a) The B ARRA stack instrumentation rand ret id
...rand ret id
...
...
202...
202
BARRA stack...
  202...
  202204  =>     gadget A204  =>     gadget A
read re-rand...
8202...
8202attacked...
204...
2048204  =>  gadget A204    =>  non-gadget A 
rand 
ret id204  =>     non-gadget A
(b1) (b2) (b3) (b4) 
(b) Burn after reading BAR_mtable:
BARRA stack B ARRA stack B ARRA stackBARRA stack
Figure 5: The burn-after-reading shadow stack for protect-
ingthereturnaddressof read_and_echo()inFigure2against
the ROP attack (with gadgetsA–C )illustrated in Figure 3.
the beginning of program execution and then hidden subsequently,
say,inaread-onlycodesection.Thismechanism,whichrelieson
hidingthelocationoftheshadowstack,isvulnerabletoinformation
disclosure and side-channel attacks [9, 16, 19, 38].
As discussed already in Section 1, several complementary or
orthogonalmitigationtechniquesareineffective:ASLR[ 49](which
is still vulnerable to information disclosure and side-channel at-tacks [
9,16,19,38]), CFI [7,15] (which still has a large attack
surface), and runtime rerandomization on concrete return ad-dresses [
28] (which is too expensive in its pointer tracking op-
erations to be applied frequently, and is thus also vulnerable).
2.4 The “Burn-After-Reading” Shadow Stack
Figure5illustratesourBarRAmethodology,withtheunderlying
shadowstacknowreferredtoasthe BarRAstack.Unlikethecase
for the shadow stack, even if the location of the BarRA stack is
leaked,BarRAcanstillpreventthecontrolflowfrombeinghijacked
by modifying the return address of read_and_echo()with a high
probability, resulting in a significantly stronger security guarantee.
Thekeynoveltyof BarRAistoabstractaconcretereturnaddress
witharandomizedreturnidandstoretheabstractreturnaddress
thus obtained in the BarRA stack. This one level of indirectionmakes it possible to apply continuous runtime rerandomizationefficiently to the BarRA stack to enforce the burn-after-reading
property (requiring all leaked return ids to be made obsolete).
Figure 5(a) illustrates how the BarRA stack works. By apply-
ing program analysis, all the Nreturn addresses in the program
arefoundandsavedin all_ret_addrs(lines1-3).Duringprogram
execution, a table, named BAR_mtable, of sizeM, whereM/greaterorequalslantN,
maintains a mapping from return ids to their concrete return ad-dresses (line 4). When a BarRA-protected function returns, its
returnidisfetchedfromthe BarRAstack(line5)andanindirect
jump is made to its corresponding concrete return address (line 6).
260C/C++
Program
WLLVM
 Clang
BARRA 
(Assembly Instrumentator)ASM
 CodeHardened 
ProgramLLVM
 IR
Assembler
& LinkerInstrumented
ASM Code
Figure 6: The workflow of BarRA.
Figure5(b)illustrateshowBarRAmitigatestheROPattackwith
gadgetsA–C(Figure 3), where the attacker attempts to replace
the return id of read_and_echo()with the return id of gadget A.
Currently, the return id of read_and_echo()is 202 (Figure 5(b1)).
By performing some information leakage attacks, the attacker has
found the return id for gadget A to be 204. On detecting this in-
formationleak(Section3.3),BarRAwillenforceimmediatelythe
burn-after-reading propertyas illustrated inFigure5(b2).This is
doneby rerandomizingthe mapping BAR_mtable.Afterwards, as
shown in Figure 5(b3), the return ids for read_and_echo()and gad-
getAhavebeenchangedto8202and8204,respectively.Evenifthe
attacker manages to replace the return id of read_and_echo()with
204 in the BarRA stack, as shown in Figure 5(b4), gadget A can no
longer be executed (as its return id is now 8204)!
To recap from Section 1, BarRA has several salient properties:
•Lightweight Runtime Rerandomization. Rerandomizing
BAR_mtablecanbedonesimplybymodifyingarandomlygen-
eratedoffsetaddedtoallthereturnids(modulo M).Thisrequires
thereturnidsintheBarRAstacktobeupdated,intheorderofmi-crosecondsinsteadofsecondsasrequiredbyRuntimeASLR(dueto its expensive pointer tracking) [
28], delivering a six-orders-of-
magnitudespeedup.
•Low Instrumentation Overheads. BarRA exhibits compara-
ble instrumentation overheads as the shadow stack mechanism.
•Strong Security Guarantees. As the maximum number of re-
turnidsis M(thesizeof BAR_mtable),thechanceofguessingcor-
rectlythereturnidforgadgetAtobe8204inFigure5(b4)isonly
1
M.Ifweuse8MBofmemory(ona64-bitplatform)toimplement
BAR_mtable(whereM/greatermuchNis possible), an attacker’s success
rate is only1
220. Finally, unlike RuntimeASLR [ 28], BarRA inte-
grates CFI (by limiting all gadgets to be within all_ret_addrsin
Figure5(a))withtheshadowstackandruntimererandomization.
3 BARRA: DESIGN AND IMPLEMENTATION
Wefocusonprotectingreturnaddressesbyadoptingthesamethreat
model as before [ 1,17,22,49,50,54,55]. The attacker can read
any readable memory or write any writable memory by exploiting
existing vulnerabilities in order to hijack the control flow.
WehavedesignedandimplementedBarRAintheLLVMcom-
piler tool chain, as shown in Figure 6. Given a C/C++ program, its
sourcefilesarecompiledandlinkedbytheLLVMtoolchaininto
a single LLVM-IR (known as bitcode). We use a compiler wrap-per, WLLVM [
41], to build a whole-program LLVM bitcode file.
The BarRA assembly instrumentator, which is added in this pa-
per, generates instrumented assembly code that is amenable to
lightweight runtime rerandomization on abstract return addresses.
Finally,theinstrumentedassemblycodeisassembledandlinked
into a hardened binary by the assembler and linker, respectively.As is standard, every function is assumed to have at most one
return instruction (with jumps added where appropriate).
BelowweuseanexamplegiveninFigure7toillustratetheinstru-
mentationaddedbyBarRA.Forthemotivatingexamplerepeated
inFigure7(a),BarRAmaintainsthe(unused)concretereturnad-
dressesinthecallstack(forcompatibilityreasons)(Figure7(b))andtheirabstractreturnidsintheBarRAstack(Figure7(c)).Figure7(d)
(Figure 7(e)) gives the instrumented code (data) section.
3.1 Data Instrumentation
Figure 7(e) lists an instrumented data section added, consistingof a read-only table
all_ret_addrscontaining all the return ad-
dressesintheprogram(lines24-34),arandomlygeneratedvalue
BAR_randval(lines 35-42), and our mapping table BAR_mtable
(lines 43-50). Both BAR_randvalandBAR_mtablereside in the
.BSS sections, and thus take no actual space in the object file.
In this example, all_ret_addrsof sizeN=5 contains five re-
turn addresses. BAR_randval, which is a 8-byte value, is stored in
a 4096-byte page (on page-aligned boundaries) such that the entire
page can be set as read-only after BAR_randvalhas been gener-
ated after each round of runtime rerandomization. BAR_mtable
of sizeM, whereM/greaterorequalslantN, will be initialized at load time, such
that∀0/lessorequalslanti<N:BAR_mtable[i]=all_ret_addrs[i]and
∀N/lessorequalslanti<M:BAR_mtable[i]=address of a ROP catcher . When
an attacker tampers with the BarRA stack with a stale return id
mapped into the ROP catcher, a warning message can be issued.
In our approach, BAR_mtableis disclosed to the attacker. How-
ever, on detecting information leaks (or at the program startup),
every return id, i, will be changed randomly to (i+BAR_randval)
modM, so that the burn-after-reading property is enforced.
To provide strong security guarantees, BAR_mtableshould be
reasonablylarge.Itissuggestedtoallocate8MBofmemory(ona64-bitplatform)for
BAR_mtablesothatitcanholdupto M=0x100000
(i.e.,1M) returnaddresses.This way, anattacker’ssuccess ratefor
guessing the return id of a gadget correctly is only1
M=1
220.
3.2 Code Instrumentation
Figure 7(d) shows how to instrument a call instruction and its
corresponding return instruction. We need to add instrumentation
codebeforethecallfor read_and_echo()(butafterallitsparameter-
pass instructions, if any) in do_request()(line 16). We also add
instrumentation code to replace the return instruction (not shown
explicitly)in read_and_echo(),whose(concrete)returnaddressis
BAR_retaddr_2, i.e., 0x401296 and (abstract) return id is 2.
Unlike the shadow stack mechanism that instruments a call
instruction by adding its instrumentation code at the beginning of
allthe calleefunctions (Figure4), BarRA instrumentsall thecalls
separately in order to also protect their return edges using CFI [ 1].
26101 void read_and_echo(void){
02 char buf[BUFSIZE];
03 gets(buf);
04 printf(buf);
05 }
06 void do_request(void){
07 while(1){
08 read_and_echo();
09 }
10 }24 ###  void *all_ret_addrs[N]; 
###  N is 5.                  
25   .section .rodata
26   .type all_ret_addrs, @object
27   .globl all_ret_addrs28  all_ret_addrs:
29   .quad BAR_retaddr_0
30   .quad BAR_retaddr_1
31   .quad BAR_retaddr_2
32   .quad BAR_retaddr_333   .quad BAR_retaddr_4
34   .size all_ret_addrs, 40 
35 ###  int BAR_randval;       
    ###  Random value          
36    type BAR_randval, @object
37   .globl BAR_randval
38   .bss
39   .p2align 12
40  BAR_randval :
41   .zero 4096
42   .size BAR_randval, 4096
43 ###  void *BAR_mtable[M];  
    ###  M is 0x100000.        
44    .type BAR_mtable, @object
45    .globl BAR_mtable
46    .bss
47   .p2align 12
48  BAR_mtable:
49   .zero 8388608
50   .size BAR_mtable, 838860811 do_request:
...
12  401274: 48 c7 c0 02 00 00 00   mov    $0x 2,%rax
13  40127b: 48 03 04 25 00 50 e0 00   add    BAR_randval ,%rax
14  401283: 48 25 ff ff 0f 00      and    $0xfffff,%rax
15  401289: 48 89 84 24 f8 ff ff fe   mov    %rax,-(BAR_OFFSET+8)(%rsp)
16  401291: e8 2a 00 00 00         callq  read_and_echo
17 BAR_retaddr_2 :
    401296 : ...
  
18 read_and_echo:
...
19  401311: 4c 8b 9c 24 00 00 00 ff   mov    -BAR_OFFSET(%rsp),%r11
20  401319: 4c 2b 1c 25 00 50 e0 00   sub    BAR_randval,%r11
21  401321: 49 81 e3 ff ff 0f 00   and    $0xfffff,%r11
22  401328: 48 83 c4 08            add    $0x8,%rsp
23  40132c: 42 ff 24 dd 00 50 60 00   jmpq   * BAR_mtable(,%r11,8)(a) Source code
(d)  Instrumented code section (e)  Instrumented data section 0x401296
...0x401296
...2 + BAR_randval
...2 + BAR_randval
...ret addr ret id
(c) B ARRA stack (b) Call stack
Figure 7: BarRA’s instrumentation illustrated for an example program.
3.2.1 Call Instructions. For the call to read_and_echo(), our in-
strumentationcode(lines12-15)insertsitsrandomizedreturnid
(2+BAR_randval)modMinto the BarRA stack at its location
−BAR_OFFSET−8+(rsp),wherethemodulooperationisrealizedin
line14.Here, (rsp)−8pointstothereturnaddress BAR_retaddr_2
onthecallstack.Asinthecaseoftheshadowstack(Section2.3),
the BarRA stack appears below the call stack at a fixed distance of
BAR_OFFSET.Inline16, BAR_retaddr_2willstillbepushedinto
the call stack even it is not used (for compatibility reasons).
3.2.2 Return Instructions. To replace the return instruction in
read_and_echo(), we rely on some instrumentation code again
(lines 19-22). In lines 19-21, we retrieve its return id saved after
undoing the rerandomization as (2+BAR_randval)(line 19)−
BAR_randval(line 20) modM(line 21)≡ 2from the BarRA
stack. In line 22, we adjust rspby skipping the (unused) return
addressBAR_retaddr_2in the call stack for compatibility reasons.
3.3 Runtime Rerandomization
Ondetectinganinformationleak(orattheprogramstartup),BarRA
willstartanewroundofruntimererandomization(fortheabstract
returnaddresses),byinvoking rerandomize() inFigure8.Insteadof
rerandomizing BAR_mtabledirectly,weachievethesameeffect(as
validated easily by inspecting lines 12-15 and 19-23 in Figure 7(d))
more efficiently by modifying BAR_randval randomly.TorandomizeBAR_randval,asshowninFigure8(a),weincre-
mentitbyarandomlygeneratedoffset, curDelta(lines13-15).We
then callupdate_BarRA _stack( rbp)to add this offset to the return
idsintheBarRAstack(lines16-17).Inline16, rbp=GET_RBP()
isinitializedtopointto thebeginning ofthelist ofthe framepoint-
ers (rbps) saved on the call stack, as illustrated in Figure 8(b). By
traversingthislist(lines5-10),wecanlocatethereturnidsforall
the callers stored in the corresponding BarRA stack.
There are general approaches to detecting information leaks in
a program [ 20,57]. In our evaluation, we monitor whether some
input/output functions such as дets()in Figure 7 are called (as
in [4]) and invoke rerandomize ()as soon as this has happened.
Specifically, every input/output function can be hooked so that
rerandomize ()willbealwaysexecutedjustbeforeit.Onarrivingat
the server(where a BarRA-protected programis running) froma
remoteattacker,amaliciouspacketwillbehandledbysuchhooked
functions, resulting in burn-after-reading (via rerandomization).
3.4 An Example
WerevisitourmotivatingexamplebyrefiningFigure5(b)toFigure9
toseehowBarRAmitigatestheROPattackinFigure3,inwhich
theattackerattemptstoreplacethereturnidof read_and_echo()
with the return id of gadget A in the BarRA stack.
At timet0, we have two return ids, 2 for read_and_echo()and
4 for gadget A. At the program startup t1, BAR_randval = 200
is generated. Just before read_and_echo()is called (lines 12-15 in
262...
return address
prev frame pointer
...
return address
prev frame pointer...
return address
prev frame pointer
...
return address
prev frame pointer
call stackGET_RBP()
BAR_OFFSET- sizeof(unsigned long) 
return id
...
return idreturn id
...
return id
BARRA  stack01 void * all_ret_addrs[N];  // all return addresses
02 void * BAR_mtable[M];  // B ARRA mapping table 
03 int curDelta;  
04 void update_B ARRA_stack(unsigned long rbp){
05     while(rbp != STACK_END){
06         unsigned long * pRetId = (unsigned long *)
07 (rbp + sizeof(unsigned long) - BAR_OFFSET);
08         *pRetId = (*pRetId + curDelta) % M;
09         rbp = *((unsigned long *)rbp);
10     }
11 }
 
12 void rerandomize(){
13     srandom (time (0));
14     curDelta = random() % M;
15     BAR_randval = (BAR_randval + curDelta) % M;
16     unsigned long  rbp = GET_RBP();
17     update_B ARRA_stack(rbp);
18 }BAR_randval
circular queue0
N-1M-1
(a) Algorithm for runtime rerandomization (b) Stack layout
Figure 8: BarRA’s runtime rerandomization (with the police icon representing the return ids mapped to a ROP catcher).
init read attacked re turn
t0 t1 t2 t3 t4 t5 t6 t7
curDelta 0 200 200 8000 8000 8000
BAR_randval 0 200 200 8200 8200 8200
re turn id 2 202 202 8202 204 (204 - 8200)%M
first ROP gadget id 4 204 204 8204 8204 8204
Figure9:BarRA’smitigationfortheROPattackinFigure3
by protecting the return id of read_and_echo()in Figure 7.
Figure7(d)),itsrandomizedreturnid202isinsertedintotheBarRA
stack. The randomized return id for gadget A has been changed to
204,whichisdiscoveredbytheattackerat t2.Toenforceburn-after-
reading,BarRAcalls rerandomize() att3,sothatBAR_randval=
curDelta+200=8000+200=8200.At t4,therandomizedreturnid
ofread_and_echo()on the BarRA stack has been changed to 8202,
andthereturnidofgadgetAhasbeenre-randomizedto8204.Withtheattackcomingat
t5,therandomizedid8202ontheBarRAstack
will be overwritten with a malicious but stale gadget id 204. When
the attacked function returns, the instrumented code in lines 19-22
in Figure 7(d) will generate a return id (204−8200)%M, which is
not gadgetA. If (204−8200)%Mrepresents ourROP catcher,then
the attack will be flagged at t7 (marked by the police icon).
4 EVALUATION
We have implemented BarRA in C/C++ in the LLVM compiler
toolchain.Currently,BarRAsupportsboth32-bitand64-bitx86
assembly code.
To ensure that BarRA is compatible with closed-source, i.e.,
unprotected binaries, we have also implemented a simple static
analysis on top of SVF [ 46], an open-source pointer analysis frame-
work,toidentifythefunctionsinasoftwareapplicationthatmay
be called from closed-source binaries. These functions will be pro-
tected by the traditional shadow stack mechanism as their callinstructionscannotbeinstrumented.Infuturework,wewillcon-
sider binary instrumentation [ 30,35] and disassembly [ 2,32]t o
provide full BarRA-protection for all the functions in the program.
Our evaluation demonstrates the efficiency and effectiveness of
BarRA in protecting return addresses in real-world applications
(with the shadow stack as the baseline). We have selected all the
19 C/C++ programs in SPEC CPU2006 (totaling 2,047,447 LOC),
including 67,855 functions and 339,983 call instructions (Table 3).
We have also developed a proof-of-concept attack, which works
byexploitingsomeformatstringvulnerabilities,suchasCVE-2019-
7715andCVE-2019-7712ontheCVEwebsite[ 13].Weshowthat
undersomeinformationleakageattacks,theshadowstackisalways
vulnerable but BarRA is substantially more secure.
We address the following three research questions (RQs):
•RQ1.Is BarRA’s runtime rerandomization lightweight?
•RQ2.Does BarRA have low instrumentation overheads?
•RQ3.Is BarRA effective in protecting return addresses in
the presence of information disclosure vulnerabilities?
Our platform consists of a 3.20 GHz Intel Xeon(R) E5-1660 v4
CPU with 256 GB memory, running the (64-bit) Ubuntu OS. All
the SPEC CPU2006 programs are compiled under the optimization
flag“-O2”.Whenrunningaprogram,thecallstackusedis8MB(by
default) and its corresponding shadow/BarRA stack is also 8MB.
The time measurement for each metric is the average of 5 runs.
To enforce the burn-after-reading property, BarRA uses 8MB
of memory to implement its BAR_mtableas illustrated in Figure 7.
However, this is not needed by the traditional shadow stack.
4.1 RQ1: Lightweight Rerandomization
Accordingto rerandomize() inFigure8,thetimespentineachround
of runtime rerandomization depends on the depth of the call stack.
Byreading /proc/pid/stackforallthe19SPECCPUbenchmarks,
the depths of their call stacks are found to be all under 256. To
covermorecases,wehavewrittenarangeoftestprogramswith
263Table 1: The times spent for BarRA to perform runtime
rerandomization under different call stack depths.
Call Stack Depth Time (microseconds)
64 2
128 2
256 3
512 5
1024 8
2048 17
4096 33
8192 63
Table 2: Comparing RuntimeASLR and BarRA.
RuntimeASLR BarRA
Address Space Concrete Abstract
Randomization Timing fork() Any TimeCoverage All Pointers Return Addresses
Pointer tracking /check ×
Burn-after-Reading × /check
Overhead Seconds Microseconds
differentcallstackdepths.Theruntimererandomizationoverheads
under different call stack depths are listed in Table 1. It is worth
emphasizingthatnomorethan3microsecondsareneededwhen
the call stack depth is below 256. Elsewhere [ 4], the average call
stackdepthobservedismuchsmaller.Ingeneral,thetimetakenbyrerandomize() is linearly proportional to the depth of the call stack.
Table2summarizesthemajordifferencesbetweenBarRA(oper-
atingonanabstractaddressspace)andRuntimeASLR[
28](astate-
of-the-artruntimererandomizeroperatingonaconcreteaddress
space), as already discussed in Section 2. RuntimeASLR rerandom-
izes all the pointers in the program. In contrast, BarRA rerandom-
izes only the return addresses (i.e., backward edges) while leaving
theprotectionoftheforwardedgestoCFI[ 1].Byoperatingona
concreteaddressspace,RuntimeASLRmustperformexpensiveand
difficultpointertracking.Duetoitsexcessiveoverheads(e.g.,217
secondsfor soplex),RuntimeASLRoptstoapplyruntimererandom-
izationtoachildprocessonlyatthetimeof fork(),thusfailingto
enforcetheburn-after-readingpropertyinthepresenceoffrequentinformationleakageattacks.Incontrast,BarRAislightweight,mak-ingitsuitabletoenforcetheburn-after-readingpropertywhenever
some information leaks are detected.
Insummary,BarRAperformsruntimererandomizationinthe
order ofmicroseconds while RuntimeASLR operatesin theorder
ofseconds.Forthecallstackscontaininglessthan256calls,BarRA
turns out to be six-orders-of-magnitude faster (Table 1).
4.2 RQ2: Low Instrumentation Overheads
Table 3lists thestatisticsfor the19 C/C++SPEC benchmarks.For
eachbenchmark,#LOC,#Text,#Funsand#Callsgiveitssourcecode
size, its binary code size, the number of its functions, and the num-
ber of its calls, respectively. Under “Inst Overheads” (Columns 6-7),
weseetheinstrumentationoverheadsintroducedbythetraditionalshadowstackandBarRA.Under“CodeSizeIncreases”(Columns
8-9), we see the code size increases under two approaches.
Belowwecomparebothapproachesintermsoftheirinstrumen-
tation overheads introduced and code size expansion incurred.
4.2.1 Instrumentation Overhead. Despite significantly stronger
guaranteesprovided(Section4.3),BarRAexhibitscomparablein-
strumentationoverheadsastheshadowstack,5.38%fortheshadow
stack vs. 6.09% for BarRA (on average), as revealed in Columns6-7. These results correlate well with a similar number of instru-
mentation instructions executed under the shadow stack (Figure 4)
and BarRA (Figure 7). To instrument a call, BarRA introduces a
memory read (for BAR_randval) in line 13 and a memory write in
line15(Figure7).Incontrast,theshadowstackaddstheinstrumen-tationcodeatthebeginningofeachofitscalleefunctions(Figure4).
Itspopinstruction (line 3) consists of essentially a read on the call
stackandawriteontheshadowstack.Asthepagethatcontains
BAR_randvalisaccessedfrequently,itscachehitrateisexpected
tobehigh,reducingitsmemoryreadoverhead.Inaddition,BarRA
uses two additionalnon-memory-access instructions (lines 12 and
14 in Figure 7), while the shadow stack uses only one (line 4 in
Figure 4). A similar analysis applies to the instrumented code for a
return instruction. Therefore, BarRA is expected to have similar
instrumentation overheads as the shadow stack.
4.2.2 Code Size Expansion. In order to protect return addresses
betterthantheshadowstack(Section4.3),BarRAgeneratesslightly
larger binaries across the benchmarks, 6.15% for the shadow stack
vs. 29.44% for BarRA (on average), as revealed in Columns 8-9. For
aprogram,theextracodeaddedbyBarRAconsistsof(1)atable
all_ret_addrscontainingitsreturnaddresses(Figure7(e)),(2)the
instrumentation code for its call instructions (lines 12-15 in Fig-
ure7(d)),and(3)theinstrumentationcodeforitsreturninstructions
(lines19-23inFigure7(d)).Thetotalcodesizeincreasein(1)and
(2)isproportionaltothenumberofcallinstructionswhilethecode
sizeincreasein(3)isproportionaltothenumberoffunctionsinthe
program.Incontrast, thenumberofinstrumentationinstructions
added by the shadow stack to a program is always proportional to
the number of its functions (Figure 4). As a program has usually
more calls than functions (Table 3), BarRA is expected to generate
slightly larger binaries than the shadow stack, but in return for
stronger security guarantees provided (as discussed below).
In our actual implementation, the three instrumentation instruc-
tions (lines 13-15 in Figure 7(d)) shared at all calls to a function are
factorized and moved to the beginning of the function.
4.3 RQ3: Strong Security Guarantees
Firstofall,BarRAhasmadeaprogram’sattacksurfacesubstantially
smallerthantheshadowstack.DuetotheCFIpropertyenforced
by BarRA, the attack surface is limited to the set of potential gad-
getsfallinginto all_ret_addrs(Figure7(e)). Fortheshadowstack,
however, any gadget found in the program can be exploited.
In Figure 10, we demonstratevia a proof-of-concept attack that
theshadowstackisalwaysvulnerablebutBarRAissignificantly
more secure in the presence of information leakage attacks. Weassume a 32-bit platform with 4-byte addresses. In Figure 10(a),
we have implemented a multiple-process echo server on Ubuntu
264Table 3: The statistics for the 19 C/C++ SPEC benchmarks.
Benchmark #LOC #Text #Funs #CallsInst Overheads Code Size Increases
Shadow Stack BarRA Shadow Stack BarRA
bzip2 8381 83271 100 425 0.77% 3.74% 4.56% 18.07%
gcc 517621 4434399 5572 52763 3.16% 4.14% 3.13% 24.42%
gobmk 197303 1613664 2679 9980 5.65% 9.30% 1.80% 8.21%
h264ref 51752 692436 590 3543 1.93% 4.63% 2.32% 11.57%
hmmer 35992 345292 538 4086 0.57% 0.38% 4.65% 23.15%
lbm 1155 23518 19 71 -0.37% 5.17% 0.31% 13.75%
libquantum 4357 43429 115 556 0.54% 1.62% 8.82% 43.46%
mcf 2685 17381 24 79 4.35% 7.02% 18.36% 36.61%
milc 15042 141659 235 1619 1.07% 1.47% 5.64% 25.26%
perlbench 168274 1419350 1870 15334 3.34% 2.63% 3.41% 22.99%
sjeng 13847 155749 144 1361 4.04% 5.57% 2.56% 17.64%
sphinx 25104 205120 369 2753 0.20% 0.59% 3.86% 28.78%
astar 5842 49896 153 665 3.93% 4.44% 7.52% 36.92%
dealII 198642 4165302 19234 93380 29.81% 20.26% 12.07% 57.62%
namd 3188 477495 140 1497 0.68% 0.54% 1.72% 5.99%
omnetpp 48040 800247 2765 21041 15.69% 17.56% 9.08% 49.38%
povray 155163 1131443 2023 15114 17.14% 19.05% 4.64% 28.53%
soplex 41428 442572 1542 9867 8.63% 7.55% 9.14% 51.09%
Xalan 553631 5516159 29743 105849 1.12% 0.07% 13.31% 55.99%
Total 2,047,447 21,758,382 67,855 339,983
Average 5.38% 6.09% 6.15% 29.44%
Table 4: Read and write primitives by exploiting format strings in printf().
Read/Write Primitive Format String Example Semantics
Absolute write primitive %ku%hn printf("%65535u%hn", val, &cnt) Write two bytes, 0xFFFF (65535), to &cnt
Absolute read primitive %s printf("%s", &str) Read the content at &str
Relative read primitive %08x printf("%08x%08x%08x%08x%08x") Read the first five anonymous arguments
Relative read primitive %k$u printf("%3$u") Read the 3rd anonymous argument
(lines1-23),whichreceivesamessagefromaclientandsendsthe
message back to the client via a socket connection. The code for
creating socket connections has been elided. The system call fork()
in line 13 creates a child process and dup2()in line 16 redirects the
standardI/Ooftheservertothesocketconnection,sothat дets()
in line 3 will read a message from a remote client and printf()in
line4willsenditbacktotheclient.Thesourcecodeinlines1-10
is the same as that in the motivating example in Figure 2.
Theattackerwillexploittheformatstringvulnerabilityin printf()
in line 4. Some read and write primitives at his/her disposal are
listedinTable4.AsillustratedinFigure10(b),therearetwointernal
pointersmaintainedin printf():fmtinitiallypointstothebeginning
of the format string (line 24) and pArgis initialized to point to the
first anonymous argument on the stack (line 25). For a variadicfunction like printf(), its number of anonymous arguments is de-
termined by parsing the format string pointed by fmt(lines 26-39).
All the format specifiers (substringsstarting with ’%’) are handled
inthenormalmanner.Inthespecialcasewhentheformalspecifier
is "%08x"(lines 28-32),the anonymousargument pointedby pArg
isprintedasasequenceof8characters(withleading0’saddedifnecessary). Afterwards, pArgis made to point to next anonymous
argument.Onceanattackerhascontrolledtheformatstring,the
attacker can inspect the content in the call stack (by printing some
“anonymous arguments” never passed explicitly to printf()).
Letusexplainfirsthowthisechoserver,protectedbytheshadow
stack, will be smashed by a formal string attack launched fromprintf()in line 4. We then discuss briefly why BarRA provides
significantly stronger security guarantees under the same attack.
4.3.1 Attacking the Traditional Shadow Stack. In Figure 10(c), a
shadow-stack-hardened echo server server_SSis listening on port
9999. Due to some information disclose attacks (by experiment-ing with different probing format strings sent to the server), the
attackerhassucceededinobtainingthefollowingvaluableinforma-
tionabouttheechoserver:thereturnaddressof read_and_echo()
is 0x08048ea7 stored at 0xffc2c7cc in the call stack and also at0xfec2c7d0 in the shadow stack, the C library function
system()
resides at 0xf7e26da0, and the string "/bin/sh"starts at 0xf7f47a0b.
The attacker is now in action. In Figure 10(e), the attacker sends
a packet that contains a malicious format string to server_SS. For
265Table 5: BarRA’s three-in-one approach for protecting return addresses.
Mechanism Strengths Weaknesses
1 Shadow Stack Reducing Buffer Overflow Attacks Vulnerable to Information Leakage Attacks
2 Control flow integrity (Backward) Reducing Available ROP Gadgets Still Permitting Illegal Return Addresses
3 Runtime Rerandomization (Concrete) Alleviating Information Leakage Attacks Problematic Pointer Tracking
BarRA ( 1+2+3(Abstract)) All the Above but without Pointer Tracking Probabilistic Protection
clarity, we have split it into multiple lines (lines 48-54). The ob-
jective,asindicatedintheinlinecomments(lines45-47),isto(1)overwrite the return address of
read_and_echo()in the shadow
stack by 0xf7e26da0 (the address of system()), as shown in Fig-
ure 10(g), and (2) restore the return address of read_and_echo()as
0x08048ea7inthecallstack(foragracefulexitwithoutleavingany
trace)andinject0xf7f47a0b(theaddressof "/bin/sh")intothecall
stack (as the argument of system()), as shown in Figure 10(h).
Whenread_and_echo()returns,system("/bin/sh") will be exe-
cuted. The format string vulnerability at printf()in line 4 on the
serverhasresultedinacontrol-flowhijack,leadingtoaninterac-
tive shell environment that the attacker can control remotely, as
showninlines55-56ofFigure10(e).Inline55,theattackerentersa
command date, the reply (in line 56) from the server_SSindicates
that the attacker has succeeded in hijacking the remote server.
Below we explain briefly how the format string vulnerability at
printf()inline4isexploitedtolaunchthisattack.Inline3, дets()
reads the malicious format string prepared in lines 48-54 by theattacker (Figure 10(e)) into bufstored in the call stack depicted
in Figure 10(g). Just before printf()starts its execution, its two
internalpointers, fmtandpArg,pointtothisformatstringandfirst
anonymous argument on the call stack, respectively. As there may
besomegapbetween bufandfmt(dueto,e.g.,registerspilling),the
attackermayhavetoexperimentwiththerightnumberof"%08x"’s
used in the malicious format string.
Let us focus on describing how 0xf7e26da0 (the address of
system()) is written into the shadow shadow as a fake return ad-
dressforread_and_echo(),asillustratedinFigure10(g).Theformat
stringparserusedinternallyby printf()parsesthefirst16 ×3regular
charactersinlines48-50,whichareprinteddirectlyinlines35-38.
Then in line 51, a sequence of five format specifiers "%0x8" are en-
countered. After having handled all these five formal specifiers in
lines28-32(witheachprintedasasequenceof8chars), pArgwillbe
liftedtopointto buf.Atthispoint, printf()hasprinted16 ×3+8×5
characters after having processed lines 48-51. Next, printf()parses
"%27976u" in line 52, causing the current anonymous argumenton the call stack, i.e., 0x41414141 to be printed as 27976 charac-
ters. On encountering the first "%hn" in line 52, printf()has printed
16×3+8×5+27976,i.e.,0x6da0characters,whicharethelowertwo
bytes oftheaddress ofthe function system(),i.e., 0xf7e26da0.This
value will be written to the shadow stack at 0xfec2c7d0 pointed by
thecurrentanonymousargumentonthecallstack.Afterhaving
handled the remaining string "%35394u%hn" in line 52, the higher
twobytesoftheaddressof system().i.e.,0xf7e2willbewrittento
theshadowstackat0xfec2c7d2.Byparsinglines53-54(theremain-
ing of the format string) in a similar manner, the return address of
read_and_echo(), i.e., 0x08048ea7and the address of "/bin/sh"will
be written into the call stack, as shown in Figure 10(h).4.3.2 Attacking the Burn-After-Reading BarRA Stack. Our BarRA-
hardened echo server, server_BarRA, listening on port 8080 as
shown in Figure 10(d), will be significantly more secure. The at-
tacker can obviously attempt to smash the server in a similar way
byexploitingaformatstringvulnerabilityasshowninFigure10(f).
According to line 65, the attacker would like to replace the re-
turn id of read_and_echo()currently stored in the BarRA stack by
0x000000cc, i.e., 204 in line 65 (as per the comment in line 58) sothat the corresponding gadget (say, gadget A in Figure 3) will be
executed when read_and_echo()returns.
In order to discover this gadget, some information leakage at-
tacksmustbemade.AsillustratedearlierinFigure9,thiswilltrigger
BarRA’s rerandomize() torerandomize BAR_mtablebychanging
204 randomly into, say, 8204, defeating effectively the attack asshown in Figure 10(d). In our evaluation,
BAR_mtableis of size
M=220. The chance for guessing a gadget id correctly is very low,
i.e.,1
M=1
220only.
Due to the enforcement of CFI by BarRA, system()may no
longer be used as a gadget, as its address is not in BAR_mtable.
AsshowninFigure7(e), BAR_mtableofsizeMcontainsonly N
return addresses in its first Nslots, where M/greaterorequalslantN. All the other
slots are mapped to a ROP catcher. The possibility for the attacker
to be caught immediately by our ROP catcher is given byM−N
M.
If we are to forgo this instant attack-catching capability (as
demonstrated in Figure 10(d)), the slots filled with our ROP catcher
can be omitted to save memory. In this case, only a large virtual
(rather than physical) memory region needs to be allocated to
BAR_mtableto achieve a high entropy. Only when part of the
virtualmemoryregion(containingnoreturnaddresses)isaccessed
(attacked)willweneedtoallocateitscorrespondingphysicalpages.
4.3.3 Discussions. Therefore, BarRA represents a three-in-one so-
lution that combines naturally shadow stack, control flow integrity
and runtime rerandomization together to protect return addresses
against control-flow hijacks, as summarized now in Table 5.
Intheabsenceofinformationleakage,BarRAprovidesthesame
levelofsecurityguaranteesasthetraditionalshadowstackmech-
anism in mitigating buffer overflow attacks. In the presence of
informationleakage,however,theshadowstackbecomesbypass-
able but BarRA will still provide strong security guarantees albeit
probabilistically. There are two reasons. First, BarRA restricts a
gadgettostartonlywithanaddressmaintainedin all_ret_addrs
(Figure 7(e))due to theCFI thus enforced.In contrast, theshadow
stackmechanismallowsagadgettostartfromanyaddress.Second,
BarRA invokes immediately rerandomize() (Figure 8) to modify
the mapping maintained in BAR_mtable(on detecting an informa-
tion leakage), reducing significantly the chances for the attacker to
hijack the control flow successfully (as shown in Figure 5).
26644 U@ubuntu:echo$ ./client_SS 127.0.0.1 9999
    
45 // write 0xf7e26da0 to memory at 0xfec2c7d0
46 // write 0x08048ea7  to memory at 0xffc2c7d0
47 // write 0xf7f47a0b  to memory at 0xffc2c7d4
48 \x41\x41\x41\x41\xd0\xc7\xc2\xfe
   \x41\x41\x41\x41\xd2\xc7\xc2\xfe
49 \x41\x41\x41\x41\xd0\xc7\xc2\xff
   \x41\x41\x41\x41\xd2\xc7\xc2\xff
50 \x41\x41\x41\x41\xd4\xc7\xc2\xff
   \x41\x41\x41\x41\xd6\xc7\xc2\xff
51 %08x%08x%08x%08x%08x
52 %27976u%hn%35394u%hn
53 %38597u%hn%31069u%hn
54 %29191u%hn%32233u%hn
55 $date56 Fri Aug  2 22:50:27  2019
(e) Attack on the echo server hardened by the shadow stack01 void read_and_echo(){
02 char buf[BUFSIZE];03 gets(buf);
04printf(buf);
05 }
06 void do_request(){
07 while(1){
08 read_and_echo();
09 }
10 }11 void service(){
12 int status;
13 pid_t pid = fork();
14 if(pid == 0){ //child
15 //IO redirection16 dup2(...); 
17 do_request();
18 exit(0);
19 }else if(pid > 0){
20 waitpid(...);21 }
22 return 0;
23 }
...
...
0xfec2c7d2
0x41414141
0xfec2c7d0
0x41414141...
...
0xfec2c7d2
0x41414141
0xfec2c7d0
0x41414141%08x %08x %08x %08x %08x %27976u %hn %35394u %hn  ...
int printf(char *fmt, ...)fmt
return address
...
pArgfmt
return address
...
pArgbuf[ ]
0xfec2c7d0
%08x%08x%08x%08x%27976u%hn%35394u%hn
0xf7e26da00xf7e26da0
call stackshadow stack
%08x0xf7e26da0 is the address of the C library function  system()
0xf7f47a0b
0x08048ea7
0x08048ea70xf7f47a0b
0x08048ea7
0x08048ea7
int system(char *command)fake ret slot of system( )command“/bin/sh”
call stacksaved ret 
0xffc2c7d4
0xffc2c7d016*3 + 8*5 + 27976 = 28064 = 0x6da0 28064 + 35394 = 0xf7e2
(g) Anal ysis of the malicious format strin g in (e)57 U@ubuntu:echo$./client_B ARRA 127.0.0.1 8080
58 // write 0x000000cc  to memory at 0xfeb9a46c
59 // write 0x080493bf  to memory at 0xffb9a470
60 // write 0xf7e4ba0b  to memory at 0xffb9a474
61 \x41\x41\x41\x41\x6c\xa4\xb9\xfe
   \x41\x41\x41\x41\x6e\xa4\xb9\xfe
62 \x41\x41\x41\x41\x70\xa4\xb9\xff
   \x41\x41\x41\x41\x72\xa4\xb9\xff
63 \x41\x41\x41\x41\x74\xa4\xb9\xff
   \x41\x41\x41\x41\x76\xa4\xb9\xff
64 %08x%08x%08x%08x%08x
65 %116u%hn%65332u%hn
66 %37823u%hn%29765u%hn
67 %45575u%hn%15833u%hn
68 $date
69 The connection is closed by the remote server .  
(f) Attack on the echo server hardened by B ARRA
(h) The call stack  when hijacked in (e)system(“/bin/sh”)24 int printf(char *fmt,...){
25  char *pArg =
     ((char *) &fmt)+sizeof(char*);
    // format string parser
26  while(*fmt){
27     if(*fmt == '%'){//parameter28       if(is_equal(fmt,"%08x")){
29        int value = 
  *((int *)pArg);
30        output_hex(value, 0, 8);
31        pArg += sizeof(int);
32        fmt += strlen("%08x");
33       }else{//others
       ...
34       }
35     }else{ // regular character
36       output_char(*fmt);
37       fmt++;
38     }39  }
40 }
(a) Echo server  (b) Pseudo code of printf()  42 U@ubuntu:echo$./server_B ARRA 8080
   Server is running ...... 
43 ###### rop_attack_detected  #####
(d) Echo server hardened by B ARRA BARRA(c) Echo server hardened by the shadow stack 41 U@ubuntu:echo$./server_SS 9999
   Server is running ...... 
0xffc2c7cc ret slot of read_and_echo( )
Figure 10: Echo server hardened by BarRA and shadow stack.
267TolaunchaROPattackbyexploitingavulnerability,theattacker
needs to chain together a number of ROP gadgets in the same
payload and then replace a legitimate return id with the returnid of the first gadget in the chain, as illustrated in Figure 3. Withruntime rerandomization in BarRA, the probability of guessing
suchacorrectreturnidtouseisextremelylow.Ifweuse M=8MB
of memory (on a 64-bit platform) to store BAR_mtablecontaining
Nreturnaddresses,where M/greatermuchN,theattacker’ssuccessratein
guessing a correct return id to use as a gadget is only1
M=1
220.
BarRA applies runtime rerandomization by using the hooked
input/outputfunctionsasbefore[ 4].Byavoidingexpensivepointer
trackingasinRuntimeASLR [ 28],BarRAcanstartanewround
ofitsmicrosecond-levelrerandomizationatanyothertimewhen
needed. To further reduce memory accesses in the instrumented
code,adedicatedregistercanbeallocatedforstoring BAR_randval.
4.4 Limitations
To enforce burn-after-reading, and consequently, provide stronger
securityguaranteesthantheshadowstack,BarRAneedstocon-
sumeextramemoryformaintaining BAR_mtabletoachieveahigh
entropy (Figure 7(e)). With 8MB (on a 64-bit platform), we can
reduce an attacker’s success rate to1
220(as discussed above). In
addition, BarRA also generates slightly larger binaries (Table 3).
One policy for handling a multiple-threaded program is to let
every thread maintain a separate BarRA stack, protected by a
thread-localversion of BAR_randval(say, inthe threadlocal stor-
age%fs:BAR_randval@tpoff on x86). While avoiding the cross-
thread synchronization issue, this simple solution does not guar-
antee that all thread-specific versions of BAR_randval are updated
simultaneously,leadingtopotentialcross-threadstack-smashing
attacks [52]. A more secure solution would be to maintain only
onesingleBAR_randvalforallthethreadsandmodifythethread
dispatchertosuspendallthethreadsinthecurrentprocesswhen
runtime rerandomization occurs. We leave this to our future work.
Currently, we do not consider just-in-time code generation,
which can already be handled by some CFI techniques [ 36]. In
thiscase,BarRAcanbeextendedtoinstrumentthedynamically
generated code and update BAR_mtableappropriately.
5 RELATED WORK
Low-levellanguages like C/C++trade securityguarantees forper-
formance advantages. The absence of bounds-checking leads to
memory errors [ 48] in C/C++ programs. StackGuard [ 11] inserts a
canary inevery stack frame andthen tests whetherthe canary on
thecallstackhasbeencorruptedornotwhenthecorresponding
function returns. Despite its lightweightness, StackGuard is not
secure, as the attacker is still able to circumvent it by exploiting
some information disclosure vulnerabilities [9, 42].
SafeStack, as a part of the code pointer integrity project [ 27],
takesadvantageofprogramtransformationandinformationhiding
tohideallthecodepointersofaprograminthesaferegion.The
memory errors arising in the unsafe region do not compromise the
safety guarantees made for safe region. Thus, the integrity of code
pointerscanbeguaranteed.However,thesaferegionforaprogram
is too large and thus vulnerable to side channel attacks [16, 38].SoftBound [ 33] enforces spatial memory safety for C programs.
By applying compile-time program transformations, SoftBound
worksbymaintainingandreasoningaboutthemetadata(basead-
dresses and bounds) for all the pointers in the program. Later, Soft-
Boundisaugmentedorthogonallytoenforcealsotemporalmemory
safety [34]. To provide both types of memory safety, however, the
combined instrumentation overhead is as high as 116%.
ASLR[49]randomizesthebaseaddressesofcodeanddatasec-
tions of a program at load time. In particular, ASR [ 18] performs
fine-grained rerandomization for the Minix 3 microkernel. CC-
FIR[56]appliescoarse-grainedCFIandrandomizationforbinary
executables, but was shown later to be bypassable [ 15]. By exploit-
ing information disclosure attacks, JIT Code Reuse [ 45] reduces
the effectiveness of code randomization [ 21,26,39,51]. Protec-
tion mechanisms that use secret memory regions to hide infor-mation, such as CPI [
27] and ASLR-Guard [ 29], can also be by-
passed [16,19,23]. In Readactor [ 12], all the code sections are
hidden but the code pointers in data sections are still exploitable.
Runtime rerandomization that operates on a concrete address
space requires expensive and difficult pointer tracking in a pro-
gram [28]. For complex C/C++ programs, existing pointer-tracking
techniques [ 10,14,43] are inadequate in discovering all kinds
of pointers reliably. With the support of a customized compiler,
TASR [4], which applies to C rather than C++, can rerandomize
thecodesectionsofaCpr ogramatruntime,butitdoesnotwork
properly when function pointers are treated as data pointers. Run-
timeASLR [ 28] has reduced its false positive rate to a negligible
level, but still too costly (as discussed in Section 4.1).
In their seminal research on Control-Flow Integrity (CFI) [ 1],
Abadi et al observed that the control flow graph of a program
is an inherent property of the program and all runtime programexecution paths should be constrained to be within the controlflow graph. Their work has spurred a great deal of research onenforcingCFI[
17,22,37,50,54,55]andavoidingtype-confusing
errors[24,58]inthepastdecadeorso.Tothebestofourknowledge,
CFI[1]hasbeenappliedtoprotectforwardedges,i.e.,indirectcalls
viafunctionpointerandvirtualcalls(insteadofbackwardedges,
i.e., return addresses). The research on forward-edge CFI assumes
usually that the shadow stack mechanism is used for enforcing
backward-edge CFI [ 17,22,50]. However, the shadow stack is vul-
nerable to information leakage attacks, as demonstrated in our
proof-of-concept attack (Section 4.3). In contrast, BarRA provides
a significantly more secure mechanism for protecting return ad-
dresses,byenforcingburn-after-readingvialightweightruntime
rerandomization on abstract return addresses.
6 CONCLUSION
In this paper, we introduce a novel shadow stack mechanism,BarRA, that applies continuous lightweight runtime rerandom-ization whenever some information leaks are detected, therebyenforcing the burn-after-reading property and making the tradi-tional shadow mechanism significantly more secure. Enforcing
burn-after-readingisessentialforBarRAtomitigateinformation
disclosurevulnerabilitieseffectively.Performinglightweightrun-
time rerandomization on abstract return addresses (with one level
of indirection) is the new enabling technology proposed here.
268REFERENCES
[1]Martín Abadi, Mihai Budiu, Ulfar Erlingsson, and Jay Ligatti. 2005. Control-flow
integrity. In Proceedings of the 12th ACM SIGSAC Conference on Computer and
Communications Security. ACM, New York, NY, USA, 340–353.
[2]Erick Bauman, Zhiqiang Lin, and Kevin W Hamlen. 2018. Superset Disassembly:
Statically Rewriting x86 Binaries Without Heuristics. In Network and Distributed
System Security Symposium.
[3]Sandeep Bhatkar, R. Sekar, and Daniel C. DuVarney. 2005. Efficient Techniques
forComprehensiveProtectionfromMemoryErrorExploits.In Proceedingsofthe
14thConferenceonUSENIXSecuritySymposium.USENIXAssociation,Berkeley,
CA, USA, 255–270.
[4]David Bigelow, Thomas Hobson, Robert Rudd, William Streilein, and Hamed
Okhravi. 2015. Timely Rerandomization for Mitigating Memory Disclosures. In
Proceedingsofthe22ndACMSIGSACConferenceonComputerandCommunications
Security. ACM, New York, NY, USA, 268–279.
[5]Tyler Bletsch, Xuxian Jiang, Vince W. Freeh, and Zhenkai Liang. 2011. Jump-
oriented Programming: A New Class of Code-reuse Attack. In Proceedings of the
6th ACM Symposium on Information, Computer and Communications Security.
ACM, New York, NY, USA, 30–40.
[6]Nathan Burow, XinpingZhang, and Mathias Payer.2019. SoK: Shining lighton
shadowstacks.In Proceedingsofthe40thIEEESymposiumonSecurityandPrivacy.
985–999.
[7]NicolasCarlini,AntonioBarresi,MathiasPayer,DavidWagner,andThomasR.
Gross.2015. Control-flowBending:OntheEffectivenessofControl-flowIntegrity.
InProceedings of the 24th USENIX Conference on Security Symposium. USENIX
Association, Berkeley, CA, USA, 161–176.
[8]Stephen Checkoway, Lucas Davi, Alexandra Dmitrienko, Ahmad-Reza Sadeghi,
Hovav Shacham, and Marcel Winandy. 2010. Return-oriented Programming
Without Returns. In Proceedings of the 17th ACM Conference on Computer and
Communications Security. ACM, New York, NY, USA, 559–572.
[9]KarlChenandDavidWagner.2007. Large-scaleAnalysisofFormatStringVul-
nerabilitiesinDebianLinux.In Proceedingsofthe2007WorkshoponProgramming
Languages and Analysis for Security. ACM, New York, NY, USA, 75–84.
[10]James Clause, Ioannis Doudalis, Alessandro Orso, and Milos Prvulovic. 2007.
Effective Memory Protection Using Dynamic Tainting. In Proceedings of the 22nd
IEEE/ACM International Conference on Automated Software Engineering. ACM,
New York, NY, USA, 284–292.
[11]Crispin Cowan, Calton Pu, Dave Maier, Heather Hintony, Jonathan Walpole,Peat Bakke, Steve Beattie, Aaron Grier, Perry Wagle, and Qian Zhang. 1998.
StackGuard:AutomaticAdaptiveDetectionandPreventionofBuffer-overflow
Attacks. In Proceedings of the 7th Conference on USENIX Security Symposium.
USENIX Association, Berkeley, CA, USA, 1–16.
[12]Stephen Crane, Christopher Liebchen, Andrei Homescu, Lucas Davi, Per Larsen,
Ahmad-Reza Sadeghi, Stefan Brunthaler, and Michael Franz. 2015. Readactor:
Practicalcoderandomizationresilienttomemorydisclosure.In Proceedingsof
the 2015 IEEE Symposium on Security and Privacy. 763–780.
[13]CVE. [n. d.]. Common Vulnerabilities and Exposures. https://cve.mitre.org/.
Accessed Jan 24, 2020.
[14]Michael Dalton, Hari Kannan, and Christos Kozyrakis. 2007. Raksha: A Flexible
InformationFlowArchitectureforSoftwareSecurity.In Proceedingsofthe34th
Annual International Symposium on Computer Architecture. ACM, New York, NY,
USA, 482–493.
[15]Lucas Davi, Ahmad-Reza Sadeghi, Daniel Lehmann, and Fabian Monrose. 2014.
Stitching the Gadgets: On the Ineffectiveness of Coarse-grained Control-flowIntegrity Protection. In Proceedings of the 23rd USENIX Conference on Security
Symposium. USENIX Association, Berkeley, CA, USA, 401–416.
[16]I.Evans,S.Fingeret,J.Gonzalez,U.Otgonbaatar,T.Tang,H.Shrobe,S.Sidiroglou-
Douskos,M.Rinard,andH.Okhravi.2015. MissingthePoint(er):OntheEffec-
tiveness of Code Pointer Integrity. In Proceedings of the 2015 IEEE Symposium on
Security and Privacy. IEEE, San Jose, CA, USA, 781–796.
[17]Xiaokang Fan, Yulei Sui, Xiangke Liao, and Jingling Xue. 2017. Boosting the
precisionofvirtualcallintegrityprotectionwithpartialpointeranalysisforC++.
InProceedings of the 26th ACM SIGSOFT International Symposium on Software
Testing and Analysis, Santa Barbara, CA, USA, July 10 - 14, 2017. 329–340.
[18]Cristiano Giuffrida, Anton Kuijsten, and Andrew S. Tanenbaum. 2012. Enhanced
OperatingSystemSecurityThroughEfficientandFine-grainedAddressSpace
Randomization. In Proceedings of the 21st USENIX Conference on Security Sympo-
sium. USENIX Association, Berkeley, CA, USA, 40–55.
[19]EnesGoktas,AngelosOikonomopoulos,RobertGawlik,BenjaminKollenda,Elias
Athanasopoulos, Georgios Portokalidis, Cristiano Giuffrida, and Herbert Bos.
2016. Bypassing Clang’s SafeStack for Fun and Profit. In Black Hat Europe.
[20]SalvatoreGuarnieriandVBenjaminLivshits.2009. GATEKEEPER:MostlyStatic
Enforcement of Security and Reliability Policies for JavaScript Code.. In USENIX
Security Symposium, Vol. 10. 78–85.
[21]J. Hiser, A. Nguyen-Tuong, M. Co, M. Hall, and J. W. Davidson. 2012. ILR:
Where’d My Gadgets Go?. In Proceedings of the 2012 IEEE Symposium on Security
and Privacy. IEEE, San Jose, CA, USA, 571–585.[22]Hong Hu, Chenxiong Qian, Carter Yagemann, Simon Pak Ho Chung, William R.
Harris,TaesooKim,andWenkeLee.2018.EnforcingUniqueCodeTargetPropertyfor Control-Flow Integrity. In Proceedings of the 2018 ACM SIGSAC Conference on
Computer and Communications Security. ACM, New York, NY, USA, 1470–1486.
[23]YeongjinJang,SanghoLee,andTaesooKim.2016. Breakingkerneladdressspace
layout randomization with intel tsx. In Proceedings of the 2016 ACM SIGSAC
Conference on Computer and Communications Security. 380–392.
[24]YuseokJeon,PriyamBiswas,ScottCarr,ByoungyoungLee,andMathiasPayer.
2017. HexType: Efficient Detection of Type Confusion Errors for C++. In Pro-
ceedingsofthe2017ACMSIGSACConferenceonComputerandCommunications
Security. ACM, 2373–2387.
[25]GauravS.Kc,AngelosD.Keromytis,andVassilisPrevelakis.2003. Countering
Code-injection Attacks with Instruction-set Randomization. In Proceedings of
the 10th ACM Conference on Computer and Communications Security. ACM, New
York, NY, USA, 272–280.
[26]ChongkyungKil,JinsukJun,ChristopherBookholt,JunXu,andPengNing.2006.
AddressSpaceLayoutPermutation(ASLP):TowardsFine-GrainedRandomization
of Commodity Software. In Proceedings of the 22nd Annual Computer Security
Applications Conference. IEEE, San Jose, CA, USA, 339–348.
[27]Volodymyr Kuznetsov, László Szekeres, Mathias Payer, George Candea, R. Sekar,and Dawn Song. 2014. Code-pointer Integrity. In Proceedings of the 11th USENIX
ConferenceonOperatingSystemsDesignandImplementation.USENIXAssociation,
Berkeley, CA, USA, 147–163.
[28]KangjieLu,WenkeLee,StefanNürnberger,andMichaelBackes.2016. Howto
MakeASLRWintheCloneWars:RuntimeRe-Randomization.In Networkand
Distributed System Security Symposium.
[29]Kangjie Lu, Chengyu Song, Byoungyoung Lee, Simon P Chung, Taesoo Kim, and
WenkeLee.2015. ASLR-Guard:Stoppingaddressspaceleakageforcodereuse
attacks. In Proceedings of the 22nd ACM SIGSAC Conference on Computer and
Communications Security. 280–291.
[30]Chi-KeungLuk,RobertCohn,RobertMuth,HarishPatil,ArturKlauser,Geoff
Lowney, Steven Wallace, Vijay Janapa Reddi, and Kim Hazelwood. 2005. Pin:Building Customized Program Analysis Tools with Dynamic Instrumentation.
InProceedingsofthe2005ACMSIGPLAN ConferenceonProgrammingLanguage
Design and Implementation. ACM, New York, NY, USA, 190–200.
[31]Microsoft. [n. d.]. Data Execution Prevention. https://docs.microsoft.com/en-
us/windows/win32/memory/data-exe cution-prev ention. Accessed Jan 24, 2020.
[32]Kenneth Miller, Yonghwi Kwon, Yi Sun, Zhuo Zhang, Xiangyu Zhang, andZhiqiang Lin. 2019. Probabilistic Disassembly. In Proceedings of the 41st In-
ternational Conference on Software Engineering. IEEE Press, Piscataway, NJ, USA,
1187–1198.
[33]Santosh Nagarakatte, Jianzhou Zhao, Milo M.K. Martin, and Steve Zdancewic.
2009. SoftBound: Highly Compatible and Complete Spatial Memory Safety for C.
InProceedingsofthe30thACMSIGPLANConferenceonProgrammingLanguage
Design and Implementation. ACM, New York, NY, USA, 245–258.
[34]Santosh Nagarakatte, Jianzhou Zhao, Milo MK Martin, and Steve Zdancewic.2010. CETS: compiler enforced temporal safety for C. In ACM Sigplan Notices,
Vol. 45. ACM, New York, NY, USA, 31–40.
[35]NicholasNethercoteandJulianSeward.2007. Valgrind:AFrameworkforHeavy-
weightDynamicBinaryInstrumentation.In Proceedingsofthe28thACMSIGPLAN
Conference on Programming Language Design and Implementation. 89–100.
[36]Ben Niu and Gang Tan. 2014. RockJIT: Securing Just-In-Time Compilation
UsingModularControl-FlowIntegrity.In Proceedingsofthe2014ACMSIGSAC
ConferenceonComputerandCommunicationsSecurity.ACM,NewYork,NY,USA,
1317–1328.
[37]BenNiuandGangTan.2015. Per-InputControl-FlowIntegrity.In Proceedings
of the 22ndACM SIGSAC Conference onComputerand Communications Security .
ACM, New York, NY, USA, 914–926.
[38]Angelos Oikonomopoulos, Elias Athanasopoulos, Herbert Bos, and CristianoGiuffrida. 2016. Poking holes in information hiding. In Proceedings of the 25th
USENIXConferenceonSecuritySymposium.USENIXAssociation,Berkeley,CA,
USA, 121–138.
[39]Kaan Onarlioglu, Leyla Bilge, Andrea Lanzi, Davide Balzarotti, and Engin Kirda.
2010. G-Free: Defeating Return-oriented Programming Through Gadget-less
Binaries.In Proceedingsofthe26thAnnualComputerSecurityApplicationsCon-
ference. IEEE, San Jose, CA, USA, 49–58.
[40]AlephOne.[n.d.]. SmashingTheStackForFunAndProfit. http://phrack.org/
issues/49/14.html. Accessed Jan 24, 2020.
[41]Tristan Ravitch. [n. d.]. Whole Program LLVM. https://github.com/travitch/
whole-program-llvm. Accessed Jan 24, 2020.
[42]Gera Riq. [n. d.]. Advances in format string exploitation. http://phrack.org/
issues/59/7.html. Accessed Jan 24, 2020.
[43]Julian Seward and Nicholas Nethercote. 2005. Using Valgrind to Detect Unde-
fined Value Errors with Bit-precision. In Proceedings of the Annual Conference on
USENIXAnnualTechnicalConference.USENIXAssociation,Berkeley,CA,USA,
1–14.
[44]Hovav Shacham. 2007. The Geometry of Innocent Flesh on the Bone: Return-into-libc Without Function Calls (on the x86). In Proceedings of the 14th ACM
Conference on Computer and Communications Security. 552–561.
269[45]KevinZ.Snow,FabianMonrose,LucasDavi,AlexandraDmitrienko,Christopher
Liebchen, andAhmad-Reza Sadeghi.2013. Just-In-TimeCode Reuse:On theEf-
fectivenessofFine-GrainedAddressSpaceLayoutRandomization.In Proceedings
of the 2013 IEEE Symposium on Security and Privacy. IEEE, San Jose, CA, USA,
574–588.
[46]YuleiSuiandJinglingXue.2016.SVF:interproceduralstaticvalue-flowanalysisin
LLVM.In Proceedingsofthe25thInternationalConferenceonCompilerConstruction.
ACM, New York, NY, USA, 265–266.
[47]YuleiSui,DingYe,YuSu,andJinglingXue.2016. EliminatingRedundantBounds
Checks in Dynamic Buffer Overflow Detection Using Weakest Preconditions.
IEEE Trans. Reliability 65, 4 (2016), 1682–1699.
[48]LaszloSzekeres,MathiasPayer,TaoWei,andDawnSong.2013. SoK:EternalWar
inMemory.In Proceedingsofthe2013IEEESymposiumonSecurityandPrivacy.
IEEE, San Jose, CA, USA, 48–62.
[49]The PaX Team. [n. d.]. Address Space Layout Randomization. https://pax.
grsecurity.net/docs/aslr.txt. Accessed Jan 24, 2020.
[50]Caroline Tice, Tom Roeder, Peter Collingbourne, Stephen Checkoway, Úlfar
Erlingsson, Luis Lozano, and Geoff Pike. 2014. Enforcing Forward-edge Control-
flow Integrity in GCC & LLVM. In Proceedings of the 23rd USENIX Conference on
Security Symposium. USENIX Association, Berkeley, CA, USA, 941–955.
[51]RichardWartell,VishwathMohan,KevinW.Hamlen,andZhiqiangLin.2012. Bi-naryStirring:Self-randomizingInstructionAddressesofLegacyx86BinaryCode.
InProceedings of the 2012 ACM Conference on Computer and Communications
Security. ACM, New York, NY, USA, 157–168.[52]Xiaoyang Xu, Masoud Ghaffarinia, Wenhao Wang, Kevin W Hamlen, andZhiqiang Lin. 2019. CONFIRM: Evaluating Compatibility and Relevance ofControl-flow Integrity Protections for Modern Software. In Proceedings of the
28th Conference on USENIX Security Symposium). 1805–1821.
[53]Ding Ye, Yu Su, Yulei Sui, and Jingling Xue. 2014. WPBOUND: Enforcing Spatial
MemorySafetyEfficientlyatRuntimewithWeakestPreconditions.In Proceedings
of the 25th International Symposium on Software Reliability Engineering. 88–99.
[54]Chao Zhang, Chengyu Song, Kevin Zhijie Chen, Zhaofeng Chen, and Dawn
Song. 2015. VTint: Protecting Virtual Function Tables’ Integrity. In Network and
Distributed System Security Symposium.
[55]Chao Zhang, Dawn Song, Scott A Carr, Mathias Payer, Tongxin Li, Yu Ding, and
Chengyu Song. 2016. VTrust: Regaining Trust on Virtual Calls. In Network and
Distributed System Security Symposium.
[56]ChaoZhang,TaoWei,ZhaofengChen,LeiDuan,LaszloSzekeres,StephenMc-
Camant,DawnSong,andWeiZou.2013. PracticalControlFlowIntegrityand
RandomizationforBinaryExecutables.In Proceedingsofthe2013IEEESymposium
onSecurityandPrivacy.IEEEComputerSociety,Washington,DC,USA,559–573.
[57]RuiZhao,ChuanYue,andQingYi.2015. Automaticdetectionofinformationleak-
age vulnerabilities in browser extensions. In Proceedings of the 24th International
Conference on World Wide Web. 1384–1394.
[58]Changwei Zou, Yulei Sui, Hua Yan, and Jingling Xue. 2019. TCD: StaticallyDetecting Type Confusion Errors in C++ Programs. In Proceedings of the 30th
International Symposium on Software Reliability Engineering. 292–302.
270