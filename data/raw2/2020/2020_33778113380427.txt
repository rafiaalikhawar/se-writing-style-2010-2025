CPC:AutomaticallyClassifying and PropagatingNatural
Language Comments
viaProgramAnalysis
JuanZhai
Purdue University, Rutgers UniversityXiangzheXu
Nanjing UniversityYu Shi
PurdueUniversity
Guanhong Tao
PurdueUniversityMinxue Pan†
Nanjing UniversityShiqing Ma
Rutgers University
Lei Xu†
Nanjing UniversityWeifeng Zhang
Nanjing Universityof Posts and
TelecommunicationsLin Tan
PurdueUniversity
XiangyuZhang
PurdueUniversity
ABSTRACT
Codecommentsprovideabundantinformationthathavebeenlever-
agedtohelpperformvarioussoftwareengineeringtasks,suchas
bugdetection,speciicationinference,andcodesynthesis.However,
developers are less motivated to write and update comments, mak-
ing it infeasible and error-prone to leverage comments to facilitate
softwareengineeringtasks.Inthispaper,weproposetoleverage
program analysis to systematically derive, reine, and propagate
comments.Forexample,bypropagationviaprogramanalysis,com-
ments can be passed on to code entities that are not commented
such that code bugs can be detected leveraging the propagated
comments. Developers usually comment on diferent aspects of
code elements like methods, and use comments to describe various
contents, such as functionalities and properties. To more efec-
tivelyutilizecomments,aine-grainedandelaboratedtaxonomy
of comments and a reliable classiier to automatically categorize
a comment are needed. In this paper, we build a comprehensive
taxonomyandproposeusingprogramanalysistopropagatecom-
ments. We develop aprototype CPC, and evaluate iton 5projects.
The evaluation results demonstrate 41573 new comments can be
derivedbypropagationfromothercodelocationswith88%accu-
racy. Among them, we can derive precise functional comments for
87 native methods that have neither existing comments nor source
code.Leveragingthepropagatedcomments,wedetect37newbugs
inopensourcelargeprojects,30ofwhichhavebeenconirmedand
ixedbydevelopers,and304defectsinexistingcomments(bylook-
ingatinconsistenciesbetweenexistingandpropagatedcomments),
including 12 incomplete comments and 292 wrong comments. This
†Corresponding authors.
Permission to make digitalor hard copies of allorpart ofthis work for personalor
classroom use is granted without fee provided that copies are not made or distributed
forproitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
ontheirstpage.Copyrights forcomponentsofthisworkownedbyothersthanthe
author(s)mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,or
republish,topostonserversortoredistributetolists,requirespriorspeciicpermission
and/or afee. Request permissions from permissions@acm.org.
ICSE’20, May 23ś29,2020, Seoul, Republic ofKorea
©2020 Copyright heldby the owner/author(s). Publication rightslicensed to ACM.
ACM ISBN 978-1-4503-7121-6/20/05...$15.00
https://doi.org/10.1145/3377811.3380427demonstrates the efectiveness of our approach. Our user study
conirms propagated comments align well with existing comments
in terms of quality.
ACMReference Format:
Juan Zhai, Xiangzhe Xu, Yu Shi, Guanhong Tao, Minxue Pan†, Shiqing
Ma, Lei Xu†, Weifeng Zhang, Lin Tan, and Xiangyu Zhang. 2020. CPC:
AutomaticallyClassifyingandPropagatingNaturalLanguageCommentsvia
Program Analysis. In 42nd International Conference on Software Engineering
(ICSE’20),May23ś29,2020,Seoul,RepublicofKorea. ACM,NewYork,NY,
USA,13 pages. https://doi.org/10.1145/3377811.3380427
1 INTRODUCTION
Modernsoftwaresystemsusuallycontainalargevolumeofcode
comments[ 58]. Commentingcode hasbeenrecognized asa good
programming practice [ 23], which facilitates both code compre-
hensionandsoftwaremaintenance.Forexample,theresearchers
in[80,81,87]conductedexperimentsshowingthatcodecomments
can help improve code readability while the researchers in [ 30,36]
demonstratedthatcodecommentsplayedasigniicantroleinmain-
tainingsoftware.Moreover,codecommentsprovideabundantin-
formation that can be leveraged to help perform a wide range
of software engineering tasks, such as bug detection [ 69,77ś79],
speciication inference [ 17,59,90], testing [ 24,86] and code syn-
thesis [15,25,56,62,88]. However, as far as we know, existing
workbarelyutilizesprogramanalysistosystematicallyderive,re-
ine, and propagate commentsthat provide rich semantics beyond
traditionalartifactsthathavebeenusedinprogram analysissuch
astypes,controllowanddatalow.Forexample,bypropagation
through program analysis, comments can be passed on to code en-
tities that are not commented such that code bugs can be detected
by cross-checking code withthe propagatedcomments.
Due to the lack of standard of composing documentation, de-
velopershave substantiallexibilityand theytend tousearbitrary
ways to compose documentation. They usually comment on difer-
ent aspects of code elements like classes, methods and variables,
and use comments to describe various contents, such as summariz-
ingthefunctionality,explainingthedesignrationaleandspecifying
theimplementationdetails.Inaddition,ascommentsarewritten
in natural language, they are intrinsically ambiguous and accurate
13592020 IEEE/ACM 42nd International Conference on Software Engineering (ICSE)
ICSE ’20, May 23ś29, 2020,Seoul,Republicof Korea Zhai et al.
linguistic analysis is needed to acquire their exact meanings and
scopes.Tobetterunderstandcodeandmoreefectivelypropagate
comments,wemustirstknowwhichcodeelementstheycomment
onandwhatkindofinformationtheyconvey.Thatistosay,itis
imperative to design a ine-grained and elaborated taxonomy of
code comments and develop a reliable classiier to automatically
categorize acomment.
Therehavebeenefortsinsoftwaredocumentationclassiication.
Padioleauetal.[ 58]builtataxonomybasedonmeaningsofcom-
ments. The work in [ 46] proposed a taxonomy of knowledge types
inAPIreference documentation andusedthetaxonomytoassess
theknowledgetheycontain.Basedonthistaxonomy,researchersin
[43] developed a set of textual features to automatically categorize
theknowledge.In[ 74],researchersstudiedcommentcategorization
to provide better quantitative insights for comment quality assess-
ment.Featuresaremanuallygivenformachinelearningtechniques
to automatically classify comments. Researchers in [ 60,61] irst
manually classiied more than 2,000 code comments and then used
supervised learning to achieve about 85% classiication accuracy.
Their taxonomies are not designed to be coupled with program
analysis. It is unclear how to propagate and infer comments based
ontheirclassiication.
Hence,ourgoalistoirstbuildacomprehensivetaxonomyfrom
diferent perspectives (e.g., what and why) and diferent code enti-
ties (e.g., class and method), and then design a uniform analysis to
enable bi-directional analysis: (1) program analysis propagates and
updates comments, and (2) comments provide additional seman-
tic hints to enrich program analysis. Multiple software tasks can
beneit from the bi-directional analysis. For example, leveraging
program analysis to propagate comments can provide automation
supportinmaintainingdocumentationwhichisdiicult[ 21]and
leveraging comment analysis can help detect software bugs by
checking the comment semantics against sourcecode.
In this paper, we propose CPC, a principled and sophisticated
software reasoning method that couples comment analysis and
program analysis. It automatically classiies comments based on
diferent perspectives and code entities (namely builds a comment
taxonomy), and thus each comment is attributed to a code element
and becomes a irst-class object just like other classic objects in
program analysis (e.g., variables and statements). Based on the tax-
onomy,CPCleveragesprogramanalysistechniquestopropagate
comments from one code entity to another to update, infer, and
associatecomments with code entities. Then CPCextracts seman-
ticsfromthepropagatedcommentstofacilitatevarioussoftware
engineering tasks such as code bug detection. Our contributions
are as follows:
•Weconstructacomprehensivecommenttaxonomyfromdif-
ferentperspectiveswithvariousgranularitylevels,andtrain
sixclassiiersusingthreealgorithmstoautomaticallycatego-
rizecommentsintoappropriateperspectivesandgranularity
levels.
•We propose a novel bidirectionalmethod ofleveraging pro-
gramanalysistopropagatecommentsandleveragingcom-
mentanalysistofacilitatebugdetection,whichachievesa
seamlesssynergyofcommentanalysisandprogramanalysis.
•We develop a prototype CPC based on the proposed idea,
andevaluateiton5largereal-worldprojects.Theevaluationresultsdemonstratethat41573newcommentscanbederived
bypropagationfromothercodelocationswith88%accuracy.
Amongthem,wecanderiveprecisefunctionalcommentsfor
87 native methods that have neither existing comments nor
source code. Our user study shows propagated comments
are as useful as existing comments inhelping developers.
2 MOTIVATION
Modern software provide abundant natural language (NL) com-
ments and there is substantial existing work on analyzing NL com-
mentsandleveragingtheminawiderangeofsoftwareengineering
applications. However, as far as we know, existing work hardly
leveragesprogramanalysistechniquestoderive,reine,andprop-
agatecommentssystematically.Suchpropagatedcommentscon-
tain wealthy semantics beyond traditional artifacts that have been
widelyusedinprogramanalysislikedatatypes.Forexample,by
usingprogramanalysistechniques,wecanpasscommentsonto
codeentitiesthatarenotcommentedandleverageinformationcon-
tainedinthepropagatedcommentstodetectcodebugs.Ouroverall
goal is to achieve code-comment co-analysis: (1) program analysis
propagates and updates code comments, and (2) code comments
provideadditional semantic hints to enrich program analysis.
Softwaredeveloperstendtocommentondiferentaspectsofdif-
ferentcodeelements[ 58].Commentsofdiferentperspectivesentail
diferentpropagationrules.ConsiderthetwocommentsłThrows
IndexOutOfBoundsExceptioniftheindexisoutofrange(index<
0 || index >= size()).ž and łShits any subsequent elements to the
let (subtracts one from their indices).ž of method remove(int in-
dex). The former can be propagated through data low while the
latter cannot. Suppose we have an assignment o = list.remove(i), by
propagating the irst comment fromthe methoddeinition (tothe
statement),wecanknowthatifthecondition i<0||i>=size() holds,
theassignmentstatement willthrowan IndexOutOfBoundsExcep-
tion, which can be used to check the code. However, the second
commentdescribesthe implementationdetailsinvolvingthedata
structure used in remove(int index), which would be misleading
and make no sense if propagated to the assignment. Hence, the
irststeptowards commentspropagation and inference is to build
acomplete taxonomy for comments.
There have been eforts in software documentation classiica-
tion[46,58,60,61,74].Theresearchersin[ 58]proposeataxonomy
basedonthefollowingfourdimensions:commentcontents,com-
mentauthors/users,commentlocations(e.g.,beforealooporina
macro), and comment composition time. In [ 46], researchers manu-
allyclassifyAPIdocumentationbasedontheknowledgetypes(e.g.,
functionalities, concepts, directives and code examples) to help
humansunderstandandgaugethequalityofAPIdocumentation.
Theyalsostudythedistributionofdiferentkindsofcomments.The
taxonomies in [ 61,74] are similar and both include categories like
purpose(thefunctionalityofthecode),underdevelopment(topic
related to ongoing/future development) and metadata (authors,
license, etc.). They are produced to facilitate quality analysis of
comments.Thetaxonomyin[ 29]isproposedtoinvestigatedevelop-
ers’ documentation patterns while the work [ 74] studies comment
categorization to provide better quantitative insights about the
documentation forcomment qualityassessment. Theirtaxonomies,
1360Classifying andPropagatingNatural LanguageComments viaProgram Analysis ICSE’20, May 23ś29, 2020,Seoul,Republic of Korea
01/** Creates a new array with the specified component
02* type and length.  ...
03* @exception NegativeArraySizeException if the
04* specified code length is negative              */
05publicObject newInstance(Class<?> componentType,
intlength) throwsNegativeArraySizeException {
06returnnewArray(componentType, length); 
07}
...
08private static native Object newArray(
Cl
ass<?> componentType , intlength)
throws NegativeArraySizeException;New Comment: Creates a new array with 
the specified component type and length.Method2St
PropagationŚ
St2Callee 
Propagation ś
method what
Figure 2:Comment Defect Detection
Class ArrayList<E>
Implements all optional list operations, and
permits all elements, including null.
01private finalList<Collection<E>> all
= newArrayList<Collection<E>>();
...
02publicintsize() {
03 intsize= 0;
04 for(finalCollection<E> item: all)
05 size+=item.size();
06 returnsize;
07}
permit null elements
class property
may be nullŚ
Ŝ
ŝInstantiation Propagation
throw NullPointerException if item is nullContainer Propagationś
Figure 1:CodeBug Detection
however,donotdistinguishcommentsofdiferentcodeentitiesand
are not designed to be coupled with program analysis. It is unclear
where and how to propagate and infer comments based on their
classiication.Forourpurpose,weproposeacommenttaxonomy
according to the commented subjects (e.g., classes, methods, and
statements)andperspectives(e.g.,what,why,andhow).Foreach
kind of comments, we develop speciic rules to propagate them
through program analysis. We will use 3 cases todemonstrate the
beneitsofpropagatingcommentsaccordingtotheircategories.Ina
nutshell,ourtechniquecanrevealbugsinbothcodeandcomments.
Code Bug Detection. Propertiesarecriticalinformationembed-
ded incomments thatdeine intended behaviors of codeelements.
ThetopboxofFig.1showsthecommentofclass ArrayList<E> from
JDK.Thisclasspermitsallelementsincluding null(denotedwith
green background) as items in the list. Here, the description of per-
mittingnullelements is recognized as a property comment by our
technique(step 1○).Asapropertycomment,itcanbepropagatedto
the code where class ArrayList is actually used. The bottom box of
Fig. 1 is the code snippet from Apache Commons Collections, where
theclassield allisinstantiatedasan ArrayList instanceatline1.
The class property (permitting nullelements) ishence propagated
from class ArrayList to its instance (step 2○) applying the Instantia-
tion Propagation rule (detailed in Section 6.1). When variable allis
accessedlaterintheprogram(line4),thesamepropertyshouldalso
hold. Since variable allhas the property of allowing nullelements,
each of its elements itemis permitted to be null(step3○). As the
size()methodof element itemisinvokedtomeasure the size,with
itembeingnull,itwillcausenullpointeraccessandhencetriggera
NullPointerException. This is a new bug detected by our technique
(step4○).Intotal,wedetect29suchbugswhichcannotbedetected
byexistingtechniquessincetheyonlyuseinformationcontained
in existing comments which rarely comment on local variables
especiallycontrolvariablesonlyusedduringiteration.Allthe29bugs have been conirmed and ixed by developers. In addition, we
detectanother8 bugsbasedonour propagatedcomments.
CommentDefect Detection. Comments are critical for code un-
derstanding. They also serve as instructions/manuals for (third
party) developers to utilize classes and methods. Defective com-
mentscanmisleaddevelopersandevenincurcriticalbugs.Fig.2
demonstrates a real-world case where comments are missing for
nativemethods.Method newArray() isimplementedusingnative
code (line 08),and ithas two arguments componentType andlength.
Although comments are highly desirable here due to the black-box
natureofnativeimplementation,thereisnocommentforthenative
method, which can potentially lead to bugs (e.g., pass −1 to param-
eterlength). Such native methods are implemented in other lan-
guages (e.g., C++ and assembly) where the source code, in general,
is unavailable. Comments of these methods cannot be generated
using existing techniques since they either summarize source code
toinfercomments,oranalyzeexistingsoftwarerepositoriesanduse
the comments from similar code. We showcase how our technique
can address this problem using the example in Fig. 2. Firstly, there
is only one statement in method newInstance() (line 05). Hence,
wecanapplyrule Property-Method2St (detailedinSection6.1)
to propagate the what-comment (lines 01-02, meaning the func-
tionality)associatedwithmethod newInstance() tothestatement
at line 06 (step 1○). Secondly, the statement at line 06 only invokes
the native method newArray(), which satisies the preconditions
of ruleProperty-St2Callee (detailed in Section 6.2). Thus, the
commentcan befurther propagatedfrom thestatementat line06
toitscalleemethod newArray() (step2○).Throughthepropagation,
anewcommentcanbegeneratedforthenativemethod,specifying
thefunctionalityof newArray() istołCreatea newarraywiththe
specified component type and length. ž. Using our technique, we
are able to infer comments for 87 native methods that have neither
source code nor comments in JDK. Note that these native meth-
odsmaybeinvokedbymanyotherJavamethodssuchthattheir
generated comments can be usedto help theseinvocations.
Wrong Propagation Without Classiication. A comment tax-
onomy is vital for comment propagation as diferent kinds of com-
ments convey diferent semantic perspectives. As such, some of
them cannot be directly propagated. For instance, even if two code
snippetsareexactlythesame,propagatingcommentfromoneto
the other may be problematic. Consider the two code snippets
in Fig. 3(a) and Fig. 3(c). The method in Fig. 3(c) has a property-
commentłThismethodwillblockuntilthebytecanbewriten.ž.
Although the two code snippets are syntactically identical, we can-
not propagate the property comment from the method in (c) to the
methodin(a).Thisisbecausethemethodinvokedatline4of(a)
and that invoked at line 8 of (c) have diferent implementations
whichhavediferentcharacteristics.Speciically,line4in(a)calls
the write method in Fig. 3(b) that is non-blocking. In contrast, line
8 in (c) calls the write inFig. 3(d) that is blocking, indicated by the
łsynchronized ž keyword in Fig. 3(e). Therefore, it is incorrect to
propagate the aforementioned property comment. However, exist-
ing techniques [ 84,85] use the comment in (c) as comment for the
method in (a), as they work by identifying code clones and sharing
comments across all clones. In contrast, our technique does not
allow propagatingproperty comments insuch cases.
1361ICSE ’20, May 23ś29, 2020,Seoul, Republicof Korea Zhaiet al.
01
02
03public void write(byte[] b, intoff, intlen) throwsIOException {
...
while(!def.needsInput()) { deflate(); }                     } 
(d)  java.util.zip.DeflataerOutputStream.write(byte[] b, int off, int len ) 01
02
03
04publicvoidwrite(intb) throws IOException {
byte[] buf= newbyte[1];
buf[0] = (byte)(b& 0xff);
write(bu
f, 0, 1);        }
(a)  java.util.Base64. write(int b) 
01
02
03
04
0506
07
08/** Writes a byte to the compressed output
* stream. This method will block until the
* byte can be written.
*/
public void write(intb) throwsIOException {
byte[] buf= newbyte[1];
buf[0] = (byte)(b& 0xff);
write(bu
f, 0, 1);                       }
(c)  java.util.zip.DeflataerOutputStream. write(int b) 01
0203
04public int deflate( byte[] b, intoff, intlen, intflush) { ... 
synchron
ized (zsRef) {                  ...
intn= deflateBytes(zsRef.address(), b, off, len, flush);
... }                                                        }
(e)  java.util.zip.Deflataer. deflate(byte[] b, int off, int len, int flush)01
0203
04public void write(byte[] b, intoff, intlen) throwsIOException {
...
while(nBits24--> 0) { ...
out.
write(base64[( bits>>> 18) & 0x3f]); } ...           }
(b)  java.util.Base64. write(byte[] b, int off, int len) Cannot Be
Pr
opagated
method property
×
Code
Clone
does not block the method
block the methodCall
CallCall
Figure 3:Wrong Propagation WithoutClassiication
Table
1:Examples ofSoftware CommentsTaxonomy
Entity Perspective Comment Example Proje ct/Class/Methodor Field
ClassWhat This
classis a member of theJava CollectionsFramework. JDK/ArrayList
Why Thisenables eicientprocessing when most tasks spawnother subtasks. JDK/ForkJoinPool
How-it-is-done Resizable-array implementation of theListinterface. JDK/ArrayList
Property Implements all optional listoperations, andpermitsall elements, includingnull. JDK/LinkedList
How-to-useBut using thisclass, one mustimplement onlythecomputeNext method,and invokethe
endOfData method when appropriate.Guava/AbstractIterator
MethodWhat Pushes
an item ontothetop of thisstack. JDK/Stack/push(Eitem)
Why Iteliminatestheneed for explicitrangeoperations. JDK/ArrayList/subList(intfrom, intto)
How-it-is-done Shifts any subsequent elementsto theleft. JDK/LinkedList/remove(int index)
Property Thismethod is not a constant-time operation. JDK/ConcurrentLinkedDeque/size()
How-to-use Thismethod can be called only onceper callto next(). JDK/Iterator/remove()
StatementWhat Make
a new arrayof a’sruntime type,butmy contents. JDK/ArrayList/toArray(T[] a)
Why Toget betterand consistentdiagnostics, we calltypeCheck explicitly oneach element. JDK/Collections/checkedCopyOf(Collectioncoll)
How-it-is-done Place indices in thecenter ofarray(thatis not yet allocated).zou JDK/WorkQueue/WorkQueue(ForkJoinPool, ForkJoinWorkerThread)
Property Thisshouldn’t happen, since we are Cloneable. JDK/ArrayList/clone()
How-to-use Use as randomseed. JDK/WorkQueue/registerWorker(ForkJoinWorkerThreadwt)
VariableWhat The
number of charactersto skip. Guava/CharStreams/SkipFully(longn)
Why Helps prevent entries that endupin thesamesegmentfromalsoending upin thesamebucket. Guava/LocalCache/intsegmentShift
How-it-is-done Modiied onadvance/split. Guava/CharBuferSpliterator/intindex
Property Theindex must be a valuegreater thanor equal to 0. JDK/Vector/setElementAt(Eobj,intindex)
How-to-use Thecollectionto be iterated. JDK/Collections/Collectioniterate
3 THE TAXONOMYOFCOMMENTS
As aforementioned, taxonomy is critical for comment propagation.
However,existingtaxonomiescannotbeleveragedtofacilitatecom-
ment propagation due to two main reasons. The irst one is that
commentsarenotassociatedwiththecorrespondingcodeentities,mak-
ingitimpossibletoleverageprogramanalysistopropagatecomments.
Forexample,weneedtomakesureacommentiscommentingona
variablebeforewecanpropagateitthroughadeinition-userela-
tionofthevariable.Thesecondreasonisthat thetaxonomiesare
not designed to be coupled with program analysis and comments in a
category(byexistingwork)tendtodescribemultipleperspectivesofa
codeentitysuchthatitisunclearhowtopropagatesuchcomments .
Henceweproposetoconstructacommenttaxonomybyclassifying
comment texts based on twodimensions:code entity andcontent
perspective, where code entity means elements like classes and
methods and content perspective means functionalities, rationales,
implementationdetails,etc.Suchataxonomyisvitalsincediferent
commentsdescribediferentcodeentitiesfromdiferentperspec-
tives (e.g., what, why, and how) which entail diferent propagation
rules. To develop a comprehensive and rigorous taxonomy, we per-
formed a content analysis which is a methodology for studying the
contentsofdocumentsandcommunicationartifacts[ 55](Section4).
Ourinaltaxonomy is illustratedinTable1.The irst column lists
the code entities, namely, class,method,statement, and variable
which are the subjects that are commonly commented by develop-
ers. For each code entity, we are interested in the following ive
perspectives: what,why,how-it-is-done, propertyandhow-to-use.
What.Thewhatperspectiveprovidesadeinitionorasummaryof
functionalityofthesubjectand/oritsinterface.Criticalsemanticscanbeextractedfrom whatinformation,suchassecuritysensitiv-
ity, which is important for vulnerability identiication. By reading
such type of comments, developers can easily understand the main
functionality of the corresponding code entity, without diving into
(implementation) details. For example, the comment łPushes an
item onto the top of this stack" in the seventh row of Table 1
describes the main functionality of method push(E item).
Why.Thewhyperspective explains the reason why the subject
is provided or the design rationale of the subject. There are two
scenarios in which whyperspective is important. First, it helps
developersunderstandmethodswhoseobjectiveismaskedbycom-
plex implementation. For example, the comment łHelps prevent
entriesthatendupinthesamesegmentfromalsoendingupinthe
samebucketžofthemethod segmentShift() conveyswhyweneed
this method, while from the implementation we can only tell it
movessomeobjects.Second,thereexistmultiplemethodsthatlook
similarbutservediferentpurposes.Inthiscase,developersoften
providewhycommentstopointoutwhythesesimilarmethodsare
neededandexplainwhy they are not plain redundancy.
How-it-is-done. Thehow-it-is-done perspectivedescribes theim-
plementationdetailslikethedesignorthework-lowofthesubject.
Suchinformationiscriticalfordeveloperstounderstandthesubject,
especially when the complexity is high. Detecting inconsistencies
between how-it-is-done comments and implementation is a way
to ind bugs. Moreover, many program analyses avoid analyzing
complexlibraryimplementationduetotheentailedspaceandtime
overhead. Instead, program analysis developers often rely on how-
it-is-done commentstosynthesize(muchsimpler)codesnippetto
1362Classifying andPropagatingNatural LanguageComments viaProgram Analysis ICSE ’20, May 23ś29, 2020,Seoul,Republic of Korea
model library functionalities. For example, the comment łShits
the element currently at that position (if any) and any subsequent
elementstotheright(addsonetotheirindices)."ofmethod add(int,
E)impliesthatwecanimplementthefunctionalitybymanipulating
an array within a loop statement (e.g., łfor (int i=size-1; i >index;
i=i-1) elements[i]=elements[i-1] ž). While the original library code
is usually highly optimized (and hence complex and diicult to
analyse),the modelcode is simpleandmucheasier to analyze.
Property. Thepropertyperspectiveassertspropertiesofthesubject,
e.g., pre-conditions/post-conditions of a function and even some
statements. Pre-conditions specify the conditions that should hold
in orderto usethe subject whilepost-conditions indicatetheresult
of using the subject. Such comments are of importance as they
canbe usedin many software engineering tasks,such asprogram
veriication, defect detection and program testing. For example,
the comment łThe index must be a value greater than or equal
to 0.ž of the variable index(a parameter of setElementAt(E, int))
speciiesapre-condition index≥0thatmustbesatisiedformethod
setElementAt(E,int) to work properly.
How-to-use. Thehow-to-use perspective describes the expected
set-upofusingthesubject,suchasplatformsandcompatiblever-
sions.Forexample,thecommentłButusingthisclass,onemust
implement only the computeNext method,andinvoke theendOf-
Data method when appropriate.ž of the abstract class AbstractIter-
atorclearly points out the required implementation in its concrete
classes.Thesecommentsareimportantforcode-commentincon-
sistency detection [77].
4 TAXONOMYCONSTRUCTION
Inthissection,wediscusshowweperformalargescalestudyof
program comments to derive the aforementionedtaxonomy.
4.1 CommentSampling
We collected a sample set of natural language comments from four
frequently-used libraries, namely JDK 8 [ 8], Guava [ 7], Apache
Commons Collections [ 1], and Joda [ 9]. All the four projects are
open sourced. The size of the projects varies from 450 to 2500
classes and from 43 to 310 KLOC, and 30% of the lines of code
arecomments,whichclearlyindicatesthatdocumentationisnot
anecdotal inthoseprojects.
Due to the lack of standard of composing documentation, devel-
opers have substantial lexibility. They tend to have arbitrary ways
of composing comments and comment on diferent aspects of code
elements [ 58] like methods and parameters. To ensure our study
has good coverage, we performed stratiied random sampling [ 55]
to collect comments for distinct code entities: classes, methods,
statementsandvariables.Foreachsourceile,werandomlysam-
pled comments from each kind of code element in proportion to
the number of such elements in the ile. This ensured that com-
ments of diferent kinds of code entities were covered. Developers
usually write both single-line and multi-line comments (comment
blocks), and the sentences in a multi-line comment tend to provide
diferenttypesofinformationlikewhatthefunctiondoesorhow
the function is implemented. As such, we choose to use sentenceas
the comment unit to construct the sample set. In total, we collected
5000 comment units.4.2 Coding Procedure
In this section, we illustrate the coding procedure [ 51] that we fol-
lowed to construct the comment taxonomy. Coding procedure is a
standardanalyticalprocessthatcanbeutilizedtodeineandclassify
asubjectdataset.Tominimizesubjectivity,wefollowedthedefault
setting oftheprocedure [ 57] andmade use offour coders (partici-
pants in a coding procedure). All the coders had at least four years
of programming experience and were acquainted with program
comments.Withtheintentionofspecifyingastartingcodingframe-
work,onecodercarriedoutapilotstudyon200commentsofthe
sampling set by identifying diferent content perspectives with the
correspondingcharacteristics.Thisstudybroughtforththeinitial
comment taxonomy which covered the majority of the inal tax-
onomy. Some categories shown in Table 1 did not occur in the 200
comments and we reined the taxonomy in the later phrase. Based
ontheinitialtaxonomy,thiscoderhelda60-minutesessiontotrain
theremainingcoderseitheron-siteorthroughvideoconferences.
During the session we discussed the meaning and the examples of
eachcategory andclariiedmisunderstandingsthat arose.
The 5000 comment units were randomly and evenly assigned to
allthecoders,whichensuredthateachcodercategorizedcomments
of all the four projects. For each comment unit, the coders identify
its subject (the type of code entity) and analyze its content (e.g.,
to identify information like the functionality). Each comment unit
may target at diferent code entities and fall into multiple content
categories. For example, the comment łReturns the head of this
deque, or null if this deque is emptyž of method pollFirst() not
only describes the functionality (what) of this method, but also
impliestheimplementation(how-it-is-done)ofthismethod.Insuch
cases, the coders would mark the comment with two labels. As
mentioned earlier, it is possible that the coders would identify
some categories that were not in the initial taxonomy. Thus the
to-be-completed taxonomy was shared among coders via an online
spreadsheet,whichallowedeachcodertoaddnewcategoriestothe
taxonomy. Once a new category was identiied and included in the
taxonomy,alltheothercoderswouldbenotiiedandtheywould
discussandverify.Ifallthecodersagreeonthenewcategory,then
the taxonomy wouldbe updatedto include the newone.
As we manually processed comments, it is inevitable to intro-
duce subjectivity. To minimize such subjectivity, we utilized cross-
veriicationbyassigningeachcommentunittotwodiferentcoders.
Whendisagreementoccurs,allthecoderswouldinvolvetohave
anopendiscussiontoresolveit.Sincetowhatextendtwocoders
agreed on the categories of each comment unit is a direct mea-
surement of both the reliability of the comment taxonomy and
the quality of the labeled comments, we calculated the Kappa met-
ric[20]to measuretheagreementbetweentwo coders.The result
percentage is 82.6%, representing substantial agreement [16].
5 COMMENTCLASSIFICATION
In this section, we introduce how we train a classiier, according to
the taxonomy proposed in Section 3, to automatically categorize
comments.Wecollect5000commentsfrom4projectsasmentioned
in Section 4. Since our classiier works at the sentence level, the
1363ICSE ’20, May 23ś29, 2020,Seoul,Republicof Korea Zhai et al.
Table 2: FeaturesforCommentsClassiication
Feature Type Description
tokenNum numeric number of tokens in acleaned comment
classNum
numeric number of classesmentioned in acleaned comment
tree string adepthirsttraversalof Stanford parse tree
NPNum numeric number of noun phrasesin parse tree
VPNum numeric number of verbphrasesin parse tree
PPNum numeric number of prepositional phrasesin parse tree
caseNum numeric number of case marking relations
preconjNum numeric number of preconjunction relations
654321 ROOT
SINV
VP
VBZ
GetsNP
NP
DT
theNN
valuePP
IN
forNP
DT
theNN
Entry
(a) Stanford Parse Tree
1: ROOT; 2: SINV;3: VP NP;4: VBZ NP PP; 5: DTNN INNP;6: DTNN
(b) TheBFSSequence of Stanford Parse Tree
Figur
e 4: ParseTree and BFS
collected comments are split into sentences. Each comment is man-
ually annotated with the subject being commented and with the
perspective (see Table1).
5.1 WordEmbeddingandCommentCleaning
The irst step towards comment classiication is to train a word
embedding[ 49,50]basedonthecollectedcomments.Textwords
are represented as ixed-length vectors in word embedding and
thus words close to each other in the vector space share more simi-
larities.Existingwordembeddingsaretrainedfromnewsarticles
and hardlyrepresent thedomain speciicfeatures insoftware. For
example, the word newmay be a verb (e.g., łnew an objectž) in
software comments, but not in general English. Hence we propose
to train a word embedding based on our collected comments using
word2vec[ 12].Thetrainedwordembeddingwillbeusedtotrain
comment classiiers introducedin Section 5.3.
Beforetrainingtheembedding,wecleanthecollectedcomments
toremoveunnecessaryinformationandnormalizetextstoacquirea
more accurateand higher-qualityword embedding.Mainly weper-
formthefollowingfourtasks:1)Substitutingclass/method/variable
names with three corresponding placeholders to make theembed-
ding more general; 2) Removing stop words (common words ap-
pearing frequently [ 70]) which include will, the, a, an, it, its and
alsoin our case; 3) Reducing derived words to their word stem,
namelyrootform,byapplyingtheporterstemmingalgorithm[ 63].
For example, the word łinsertsž is transformed into łinsertž; and 4)
Lowercasingallthe words.
5.2 FeatureExtraction
To train models to classify comments, we extract eight features
showninTable2.Theirstcolumnliststhefeatures,andthesecond
column gives the type of each feature, namely numeric and string.
Thelastcolumndescribeseachfeature.Notethatallthefeaturesare
automatically extracted,meaning that no human efortis required
to use our trained classiiers to categorize comments.
FeaturetokenNum isthenumberoftokenscontainedinacleaned
comment, and classNum is the number of classes mentioned in acomment. A comment which mentions more classes tends to have
ahigherprobabilitytobeanexplanationofimplementationdetails,
indicating itself to be a how-it-is-done-comment. The remaining six
features are extracted from parse trees and Stanford dependencies
generated by Stanford Parser [ 40,65]. The Stanford parser parses a
sentenceanddeterminesPart-Of-Speech(POS)tags[ 41]associated
withdiferentwordsandphrases.Parsetreesrepresentgrammat-
ical structure of sentences and Stanford dependencies represent
grammaticalrelationsbetweenwordsinasentence.Forexample,
Fig.4(a)showstheStanfordparsetreeofthecommentłGetsthe
valuefortheEntryžwhere NP,VP,PP,etc.,arePOStags.Feature
treeis a string representation of a parse tree which is composed of
nodes that are traversed using breadth irst search (BFS). For exam-
ple, Fig. 4(b) is the BFS of the tree in Fig. 4(a). The features NPNum,
VPNumandPPNumcount the number of nounphrase (NP) nodes,
verb phrase (VP) nodes and prepositional phrase (PP) nodes, re-
spectively.Stanfordparseralsoprovidesdependencytypesforeach
pair of adjacent words [ 22]. We extract the relations caseNum and
preconjNum whicharethenumberoftype caseandtypepreconjcon-
tainedinasentence.The caserelationisusedforanycase-marking
element which is treated as a separate syntactic word (including
prepositions,postpositions,andcliticcasemarkers)[ 2].Preconjunc-
tionis the relation between the head of an NP and a word that
appearsatthebeginningbracketingaconjunctionandputsempha-
sis on it [ 10], such as łeitherž, łbothž, łneitherž. The six features
are utilized since based on our experiments, we observe that these
six features have positive importance on the classiication while
the other elements contained in parse trees and dependencies have
little positive importanceoreven have negative importance.
5.3 AlgorithmsandEvaluation
Totrainclassiierstocategorizecommentsintodiferentcodeen-
tities and diferent perspectives, we leverage the following three
algorithms:decisiontree[ 64],randomforest[ 18]andconvolutional
neural network (CNN) [ 38]. The three algorithms are frequently
used to train classiication models and they are proven to have
highaccuracyinclassiication[ 39,74].Thedecisiontreealgorithm
andtherandomforestutilizetheextractedfeaturestotrainmodels
while theCNN algorithmdoes not use anyfeature. As mentioned
earlier,acommentmayfallintodiferentcategoriesandthuswe
trainmulti-labelclassiicationmodels[ 83]forbothperspectivesand
code entities. The multi-label classiication problem is transformed
into a set of binary classiications and each binary classiication
checkswhether acomment can be classiiedintoone category.
To evaluate the classiiers, we apply the standard 5-fold cross
validation[ 42],namelywerandomlyselect20%commentscollected
inSection4asthetestingsetandtheremainingcommentsasthe
training set. The performance of perspective/code entity classiica-
tionissummarizedinTable3.Thecolumns DTC,RFCandCNN
respectively show the performance of decision tree, random forest
and CNN. The four metrics we use are Precision, Recall,F1 Score
andHamming Loss which are calculated using sklearn metrics [ 11].
Speciically, precisionmeasures the ability of the classiier correctly
labelsacomment,anditiscalculatedas TP/(TP+FP)whereTP
is thetotal numberof correctly classiied comments and FPis the
totalnumberofcommentsthatareclassiiedintowrongcategories.
The metric recallmeasures the ability of the models to correctly
1364Classifying andPropagatingNatural LanguageComments viaProgram Analysis ICSE ’20, May 23ś29, 2020,Seoul,Republic of Korea
Table 3: Comment Classiication Result
Perspective CodeEntity
DTC RFC CNN DTC RFC CNN
Precision 87.84% 87.78% 95.15% 97.39% 98.09% 89.33%
Re
call 95.22% 91.39% 93.78% 99.27% 99.27% 75.28%
F1
Score 93.43% 93.17%s 94.46% 98.55% 98.90%s 81.71%
Hamming
Loss0.014583 0.014583 0.011979 0.010417 0.0007813 0.0674157
classifyallthecommentsthatbelongtoonecategoryanditiscalcu-
lated asTP/(TP+FN)whereFNis the number of comments that
are notclassiied asone categorywhile infacttheybelong to that
category. The F1 scoreis a weighted average of precision and recall
andthehammingloss isthefractionoflabelsthatareincorrectly
predicted. For the irst three metrics, the higher the better while
for the hamming loss, the lower the better.
Fromthistable,wecanseethatthethreealgorithmsachievehigh
precision, recall and F1 score and low hamming loss in classifying
comments into correct perspectives, which indicates the efective-
nessofourclassiiers.Forthecodeentityclassiication,thedecision
treeandtherandomforestalgorithmshavehighprecision,recall
andF1score andlowhamming loss.In contrast,CNNhasrelative
lowerprecision,recallandF1scoreandrelativehigherhamming
loss compared with the other two algorithms. The classiication
ofcodeentityismoresensitivetoinputfeatures.CNNsperforms
their own feature abstraction, which may miss important features.
6 PROPAGATION
In this section, we will introduce the rules that are used to prop-
agate comments based on their corresponding code entities and
perspectives. These propagation rules achieve the goal of lever-
agingprogramanalysistechniquestoupdateexistingcomments,
infernewcommentsandassociatecommentswithcode.Wehave
diferentrulesfordiferentcodeentitiesandperspectives.Eachrule
isheadedbyitsname,followedbyafractionwiththenominator
the conditions andthe denominator the derived comment.
6.1 Property-commentPropagation
Theproperty-commentpropagationrulesaresummarizedinFig.5(a),
whichinvolverulesforpropagatingcommentsofdiferentlevelsof
granularity, namely class-, method-, statement-, and variable-level.
Class-levelPropagation. RuleProperty-Instan deinestheprop-
agation between a class and its instantiation. That is, if a comment
cis associated with a class oand a variable vinstantiates class o,
thentheproperty-commentispropagatedfromclass otovariable
v. The expression c[v/o]means the occurrence of oincis replaced
withv.Forexample,the property-commentłpermitsallelement,
including nullž of the class ArrayList is propagated to the instance
alldeclaredatline1inFig.1.Rule Property-Inher speciiesthat
if(1)acomment cisassociatedwithsuperclass q,and(2)thereis
aninheritancerelationbetweensubclass pandsuperclass q,then
property-comment cispropagatedfromsuperclass qtosubclass p
withtheclassname q(superclass)occurringin csubstitutedwith
the class name of p(subclass). Rule Property-Impl is analogous to
ruleProperty-Inher, where the property-comment cassociated
withinterface iispropagatedto its implementationclass o.
Method-levelPropagation. RuleProperty-Callee2St isapplied
to propagate a property-comment if a comment ccontains prop-
erties regarding a callee method mandmis invoked by a state-
ments, then the property-comment cis propagated from the calleemethodmto the statement swith the formal parameters fpinc
substitutedwiththeactualparameters apusedins.RuleProperty-
Method2St deines the scenario that a comment cassociated with
a method mis propagated to a statement swhen the statement sis
theonlystatementin m.Forexample,inFig.2,thestatement return
newArray(componentType, length) at line 6 is the only statement of
the method newInstance() and thuswe canpropagate the property-
commentł@exceptionNegativeArraySizeExceptionifthespecified
codelengthisnegative.žat lines3-4to the statementat line6.
Statement-level Propagation. RuleProperty-St2Callee spec-
iies that if (1) a statement sinvokes a callee method m, and (2)
shas no additional operations other than returning the result of
thecallee m,then the property-comment cispropagated fromthe
statement sto the callee method mwith the actual parameters
apsubstituted with the formal parameters fp. Consider the afore-
mentioned statement (line 6 in Fig.2) which invokes the method
newArray() anddoesnothaveoperationsexceptreturningtheresult
ofnewArray().Sincethetwoconditionsaremet,wecaninferanew
property-commentforthenativemethod newArray() bypropagat-
ing ł@exception NegativeArraySizeException if the specified code
length is negative.ž from the statement to the callee newArray().
We can observe that comments of a caller method can be prop-
agated from a callee method via the invocation statement based
on RuleProperty-Method2St and Rule Property-St2Callee.
RuleProperty-St2Method deines propagating comments from a
statement stoamethod mwhichcontains s,underthecondition
thatthesetofactualvariables apcontainedin sisasubsetofthe
parametersof m.Supposethatthe property-comment cdescribes
a property of a variable that is not a parameter of mand thus it
wouldbe inappropriate for cto be acomment of m.
Variable-levelPropagation. Variable-levelrulesincludetwocases:
deinition-useandcontainer-element.Rule Property-DefUse de-
ines the case that if a comment cis associated with a variable v
andvisusedincode u,thenthe property-comment cispropagated
fromdeinition vtouseu.RuleProperty-Container speciiesthat
if (1) a comment cis associated with container landlhas element
e, then a element-related property-comment is propagated from
container lto eachelement e.
6.2 What-commentPropagation
Therulestopropagate what-commentareshowninFig.5(b).Similar
totherulesof property-comment,theyarealsocategorizedbased
onclasses,methods,statements andvariables.
Class-levelPropagation. RuleWhat-Inher issimilarto Property-
Inher,wherea what-comment cassociatedwithasuperclass qis
propagated to asubclass p.RuleWhat-Impl isalsosimilar.
Method-levelPropagation. RuleWhat-Callee2St speciiesthat
if (1) a comment cis associated with a method m, and (2) there is a
methodinvocationrelationbetweenastatement sandthe callee
methodm,thenthe what-commentispropagatedfromthecallee m
tothestatement swiththeformalparameters fpincsubstituted
with the actual parameters ap. RuleWhat-Method2St denotes
the propagation from a method mto a statement sinside. Two
preconditions are required to be satisied for the propagation. The
irstconditionisthatthestatement sisthelaststatementofmethod
1365ICSE ’20, May 23ś29, 2020,Seoul,Republicof Korea Zhai et al.
Class-level PropagationRules:
Property
-InstanpropComment (o,c)Instantiation (v,o)
propComment (v,c[v/o])
Property
-InherpropComment (q,c)inheritance (p,q)
propComment (p,c[p/q])
Property
-ImplpropComment (i,c)implementation (o,i)
propComment (o,c[o/i])
Metho
d-level PropagationRules:
Property-Callee2StpropComment (m,c)invocation (s,m)
propComment (s,c[a p/fp])
Property-Method2StpropComment (m,c)onlySt(s,m)
propComment (s,c)
Statement-le
vel PropagationRules:
Property-St2CalleepropComment (s,c)invocation (s,m)&&noOtherOp (s)
propComment (m,c[f p/ap])
Property-St2MethodpropComment (s,c)contain(m,s)&&ap⊆fp
propComment (m,c[f p/ap])
Variable-level PropagationRules:
Property-DefUsepropComment (v,c)defUse(u,v)
propComment (u,c)
Property
-ContainerpropComment (l,c)contain(e,l)
propComment (e,c[e/l])
(a) Property Propagation RulesClass-levelPropagationRules:
W
hat-InherwhatComment (q,c)inheritance (p,q)
whatComment (p,c[p/q])
W
hat-ImplwhatComment (i,c)implementation (o,i)
whatComment (o,c[o/i])
Metho
d-level PropagationRules:
What-Callee2StwhatComment (m,c)invocation (s,m)
whatComment (s,c[a p/fp])
What-Method2St
whatComment (m,c)lastSt(m,s)&&(preSts==/empt†setAlt2 ||preSts⊆exSts)
whatComment (s,c)
Statement-le
vel PropagationRules:
What-St2Callee
whatComment (s,c)invocation (s,m)&&noOtherOp (s)
whatComment (m,c[f p/ap])
What-St2Method
whatComment (s,c)lastSt(m,s)&&(preSts==/empt†setAlt2 ||preSts⊆exSts)
whatComment (m,c)
V
ariable-levelPropagationRules:
What-DefUsewhatComment (v,c)defUse(u,v)
whatComment (u,c)
(b) What Propagation Rules
Method-level PropagationRules:
Ho
w-ClonehowComment (m,c)clone(m′,m,100%)
howComment (m′,c)
Ho
w-DiffTypehowComment (m,c)clone(m′,m,90%)&&diffType (m′,m)
howComment (m′,c[t′/t])
(c) How-it-is-done Propagation RulesNote:
ccomment uco
de that uses a variable v
oclass apactual parameters
psubclass fpformal parameters
qsuperclass lcontainer variable
iinterface eelementcontained in thecontainer l
m/m′method t/t′type
sstatement preSts statements before thecurrent statement
vvariable exSts exception-handling statements
Figure 5:Comment Propagation Rules
m. The second one canbe either 1) there are no statements before
s, namely preSts==∅or 2) all the previous statements are for
exception handling ( preSts⊆exSts). If the two conditions are met,
thewhat-comment ccan be propagated from themethod mto the
statement s.ConsidertheexampleshowninFig.2.The statement
atline6isthelaststatementofthemethod newInstance() (lines5-7),
meaning the irst condition is satisied. Also the method body does
nothavestatementsbeforeline6,meaningthesecondcondition
holds. Hence the what-comment ł Creates a new array with the
specifiedcomponenttypeandlength.žcanbepropagatedfromthe
methodnewInstance() to the statementat line6.
Statement-level Propagation. RuleWhat-St2Callee describes
propagation from a method invocation statement to the callee.
Speciically,astatement sinvokesamethod mandhasnoadditional
operationsotherthanreturningtheresultof m.Ifacomment cis
associated with s, thenccan be propagated to mwith the actual
parameters apsubstituted.Forexample,thestatementatline6of
methodnewInstance() inFig.2invokesmethod newArray() andit
doesnotinvolveotheroperations,andthuswecanpropagatethe
what-commentłCreatesanewarraywiththespecifiedcomponent
typeandlength.ž(propagatedtothestatementbasedonRule What-
Method2St) to newArray() at line 8. Rule What-St2Method is
symmetric to rule What-Method2St anddiscussioniselided.
Variable-levelPropagation. Variable-levelpropagationisdeined
by ruleWhat-DefUse. That is, if variable vis associated with a
comment candthere isadeinition-userelation between vandu,
thencispropagatedfrom deinition vto useu.6.3 How-it-is-done-comment Propagation
The propagation rules for How-it-is-done-comment are given in
Fig. 5(c) and they only involve method-level propagation. Com-
ments canbepropagatedin otherlevels,butin practice,most How-
it-is-done-commentsareinmethod-level.Theirstrule How-Clone
speciies the scenario that if (1) a how-it-is-done-comment cis asso-
ciated with a method m, and (2) the method body of mis the same
as the body of another method m′, thencis propagated from mto
m′.Thesecondrule How-DiffType speciiesthatifmethod m′is
acodecloneofmethod mbutwithdiferenttypesofvariablesor
formal parameters, then comment cis propagated from mtom′
withthe type information substituted.
7 EVALUATION
WeimplementaprototypeCPC,leveragingtheEclipseJDTtoolkit[ 6]
andthecodeclonetoolNicad[ 68],andempiricallyevaluateitto
address the following questions:
RQ1:HowefectiveisCPCinpropagatingcommentsofdiferent
perspectives andcode entites?
RQ2:Howuseful is CPC inhelping developers?
RQ3:Howefective isCPCinimprovingcomments?
RQ4:Howefective isCPCindetecting code bugs?
TheevaluationwasconductedonamachinewithIntel(R)Core(TM)
i7-8700KCPU(5.00GHz)and32GBmainmemory.Theoperating
systemis macOS High Sierra 10.13.6,andthe JDKversionis 8.
1366Classifying andPropagatingNatural LanguageComments viaProgram Analysis ICSE ’20, May 23ś29, 2020,Seoul,Republic of Korea
Table 5: Comment Propagation Accuracy
PerspectiveAccuracy
dist=0 dist<0.5 dist≥0.5
Property 100.00% 76.00% 85.00%
What 100.00% 71.00% 70.00%
Ho
w-it-is-done 100.00% 75.00% 70.00%
Table 4: Comment Propagation Summary
Perspe-
ctiv
eProjectSimilarity with ExistingComments
dist=0 dist<0.5 dist≥0.5
#c #m #ec #pc #cmt % #cmt % #cmt %
PropertyJDK 998 17727 21147 39274 9133 75.11% 2191 18.02% 835 6.87%
Collections 247 2687 3151 4222 1301 73.30% 372 20.96% 102 5.75%
Guava 518 6140 1940 8425 2718 88.28% 259 8.41% 102 3.31%
Joda-Time 219 5011 2344 4393 1313 80.50% 111 6.81% 207 12.69%
ApacheDB 193 3508 1898 2552 779 82.43% 57 6.03% 109 11.53%
WhatJDK 628 10841 12927 5029 1368 39.66% 1550 44.94% 531 15.40%
Collections 70 989 1472 330 105 44.30% 83 35.02% 49 20.68%
Guava 205 2847 1347 1294 419 49.47% 333 39.31% 95 11.22%
Joda-Time 83 1725 1949 885 237 29.40% 325 40.32% 244 30.27%
ApacheDB 78 1426 1316 682 169 29.14% 366 63.10% 45 7.76%
How-it-
is-doneJDK 261 974 1392 16285 15516 96.72% 394 2.46% 133 0.83%
Collections 41 98 100 113 53 67.09% 22 27.85% 4 5.06%
Guava 20 33 31 127 108 85.71% 16 12.70% 2 1.59%
Joda-Time 15 22 29 130 32 35.20% 37 29.13% 58 45.67%
ApacheDB 180 285 254 519 421 84.04% 58 7.39% 22 4.39%
7.1 Efectiveness in CommentsPropagation
ToanswerRQ1,wepropagate property-comments, what-comments
andhow-it-is-done-comments in ive projects. The results are sum-
marizedinTable4,whichpresentsthecommentperspective(col-
umn 1), the projects (column 2), the number of classes/methods
whose comments are propagated (columns #cand#m), the number
ofexistingcomments/propagatedcomments(columns #ecand#pc),
the similarity between an existing comment and an propagated
comment(columns7-12).Notethatthecomparisonisconducted
onlywhenthereisanexistingcomment.Thesimilarityismeasured
using the Word Mover’s Distance (WMD) algorithm [ 44]. A zero
distance means the existing comment and the propagated com-
mentareliterallythesame.Ifthedistanceisbetween0and0.5,it
meanstwocommentsareliterallysimilarandifthedistanceismore
than0.5,itmeanstwocommentsareliterallydiferent.Thelongest
distance is 10. For each distance range, the columns #cmtand%
presentthenumberofpropagatedcommentsandtheratiobetween
#cmtandthe totalnumber of propagatedcomment (column #pc).
FromTable4,wemakeafewobservations.Firstly,thenumber
ofpropagated commentsis larger than that of existingcomments
sinceonecommentmaybepropagatedtodiferentplaces.Secondly,
the number of propagated property-comments is much larger than
that ofwhat-comments and how-it-is-done-comments. This is due
tothefactthatdeveloperstendtocommentonexception-related
behaviors and one method may contain several diferent excep-
tion behaviors, and these exception-related comments belong to
propertycomments.Thirdly,thenumberofpropagated how-it-is-
done-commentsisrelativelysmallerduetotwofactors.Theirstone
isthatthenumberofcodeclonesissmallandthesecondoneisthat
fewer comments are about implementation details ( how-it-is-done).
Fourthly,thepercentageofpropagated property-commentsthatare
literally the same with existing comments (0 distance) is higher
than the other two perspectives (on average 80% vs 56%). This is
mainly because property-comments have limited contents with rel-
atively ixed sentence patterns while the other comments describe
variousaspectsandtendtobedepictedusingdiferentsentences
toexpressthesamesemantic.Fifthly,morethan88%propagatedcomments are literally similar with existing comments (distance
lessthan0.5),whichindicatesourpropagationtechniqueisfeasible
andeicientinmanipulatingcommentsasirst-classobjects.Lastly,
the percentage of comments with distance larger than 0.5 in the
projectJoda-Time is much higher than the others. By checking
the comments, we found that there are ten code snippets which
sharethesamecodeandoneofthemhasacommentthatisliterally
diferent from the comments of the remaining ones, and there are
some other similar cases. Such cases contribute a lot to the high
percentage given the small number of propagatedcomments.
TofurtheranswerRQ1,wemanuallymeasuretheaccuracyof
propagated comments for diferent distance ranges, summarized in
Table 5. The irst column gives the perspective of comments and
the remaining columns show the accuracies of diferent distance
ranges. Due to the large number of propagated comments, we can-
notmanuallycheckallofthem.Instead,foreachdistancerange,we
randomlysampled500commentsofeachperspectiveandmanually
checkedwhetherthepropagatedcommentsarecorrectornot.If
a propagated comment is inconsistent with the source code, it is
considered as false positive.
Table 5 shows that we achieve 100% accuracy when the distance
is0andanaverageof75%accuracywhenthedistanceislargerthan
0. This demonstrates that our propagation technique is efective in
inferringcomments.Notethateventhoughthedistanceislarger
than 0 or even larger than 0.5, it does not mean the propagated
comments are incorrect since the same semantics can be expressed
using diferent sentences. For example, the comment łReturns the
node;ornullifnotfoundžispropagatedtomethod remove()ofclass
ConcurrentSkipListMap and thismethod hasan existingcomment
łReturnsthepreviousvalueassociatedwiththespecifiedkey;or
null if there was no mapping for the key.ž. The two comments are
literally quitediferent,but they have the same semantics.
7.2 Usefulness in Helping Developers
To answer RQ2, we conducted a user study involving 14 users (6
graduatestudentsand8developersfromindustry)toparticipate.
We randomly selected 80 code entities that have both existing com-
mentsandpropagatedcomments(withatotalof160comments).
The generated comments are propagated from other places and
must be syntactically diferent from the existing ones. They are
mainlyfromCommonsCollections,JDK,andGuava,andhaveeven
coverageforthethreecommenttypes.Todiversifyourselection,
these code entities are selected from diferent source iles. To avoid
bias, we mix the propagated comments and the existing comments,
and thus the users are unaware of whether a comment is propa-
gatedorexisting.Foreachcomment,weprovidethecorresponding
code,andaskuserstoevaluatethecommentsfromthefollowing
threeperspectives: Meaningfulness (isacommentofhighquality
in helping developers understand code), Consistency (is a com-
ment consistent with code), and Naturalness (does a comment
efectively convey information as anaturallanguagesentence).
The users are asked to evaluate each comment based on the
widely-adopted ive-point Likert scale [ 45], and the scores 1,2,3,4,5
separately represent strongly disagree, disagree, neither agree nor
disagree, agree and strongly agree. Note that the numerical results
of these questions are not important as theyare dependent on the
1367ICSE ’20, May 23ś29, 2020,Seoul,Republicof Korea Zhai et al.
Table 6: Comment Propagation Improvement
ProjectPersp
ective Property What How-it-is-done
#N #I #W #N #I #W #N #I #W
JDK 26862 11 243 1580 1 0 242n.a. 0
Collections 2404 11 42 93 0 0 34 n.a. 0
Guava 5344 0 2 447 0 0 1 n.a. 0
Jo
da-Time 2757 0 5 79 0 0 3 n.a. 0
ApacheDB 1607 0 0 102 0 0 18 n.a. 0
Table 7: Code Bug Detection
Project Version #Bugs Buggy Method Conirmed
Collections 4.2 29Comp
ositeCollection.iterator() Yes
CompositeMap.removeComposited(inal Map<K, V>) Yes. . .
Guava 28.0 6Throwables.getRootCause(Throwable) No. . .
ApacheDB 3.2 2Utilities.printClasspath()Yes
ConsoleFileOutput.getDirectory() No
3.703.753.803.853.
903.954.00Consistency
Mea
ningfulness NaturalnessPropagated
Existing
Figure 6:User Study Comparison Result
quality of the original comments (recall our propagated comments
alsooriginatefromexistingcomments).Instead,thecomparative
resultsofthetwokindsofcommentsareimportant.Fig.6shows
thecomparisonresultsbetweenpropagatedcomments(blue)and
existingcomments(red):3.88vs3.86forconsistency,3.85vs3.84
formeaningfulness,and3.98vs4.00fornaturalness.Overall,the
resultsindicatepropagatedcommentsalignwellwithexistingones
intermsofquality.Furtherinspectionshowsthattheslightlyworse
results regarding naturalness are due to our sampling bias: the
propagatedcommentsare16.7%shorterthantheexistingcomments
and the users seem to consider longer comments are more natural.
7.3 Efectiveness in ImprovingComments
ToanswerRQ3,weevaluatetheefectivenessofourcommentprop-
agationinthreeaspects:1)inferringnewcommentsforcodeentities
thatdonothaveexistingcomments;2)identifyingincompletecom-
ments which may be misleading for users or developers; and 3)
detectingwrongcommentsthatmightleadtobugs.Theresultis
showninTable6,andthecolumns #N,#Iand#Wpresentthenum-
berofnewcomments,incompletecommentsandwrongcomments,
respectively. Here a new comment means the code entity where
thecommentispropagatedtodoesnothaveanycommentbefore.
Note that we do not give the number of incomplete how-it-is-done-
commentssinceitisunnecessaryandimpracticaltocommentall
the implementationdetails.
BasedonthenumberofnewcommentsshowninTable6andthe
accuracyinTable5,wecanseethatourtechniquecanefectively
generate new comments, which can be further used to facilitate
understandingandmaintaindocumentation.Bymanuallycheck-
ing some of the newly-generated comments, we ind that manycomments describe exceptional behaviors including the type of
exception and the corresponding exception-trigger condition. Such
commentsareusuallyconsideredveryimportantsinceamajority
ofbugsarecausedbytriggeringexceptions.Forexample,wecan
generatethenewcommentłThrowsIllegalArgumentExceptionif
thesizeislessthan1žforconstructor CircularFifoQueue(Collection),
which conveys that the parameter collection should have a size
larger than 0. Without such a comment, bugs are easily introduced
sinceveryfewmethodshavesuchrequirementsanddevelopersare
insensitivetothem.Moreover,amongthenewcomments,precise
functional commentsareinferred for 87 nativemethods thathave
neithercommentsnorsourcecode.Thesecommentscanserveas
manuals for developers to leveragethesenative methods.
We also identify 11 incomplete comments which can be seen as
inconsistencies between comments and code. Our propagated com-
ments can be used to complement existing comments to address
such inconsistencies and reduce the risk of introducing bugs when
the code is used. For example, łReturns true if this list changed as
a result of the call.ž is the existing comment of method addAll()in
classRoleList, and łReturns true if the RoleList specified is null.ž is
onepropagatedcommentofthemethod.Byanalyzingthecode,we
canseethepropagatedcommentiscorrect,meaningtheexisting
oneisincomplete.Inaddition,wedetectmanywrongcomments
that would be misleading and even lead to bugs. For example, in
the project Apache Commons Collection, we generate the propa-
gatedcommentłthrowsIndexOutOfBoundsExceptionifindex<0
orindex>=size()žwhichisinconsistentwiththeexistingcomment
łthrows IndexOutOfBoundsException if index <0 or index > size()ž
ofmethod setIterator inclassCollatingIterator.Weconirmedour
propagatedcommentiscorrect,and developersalsoconirmedthis
and corrected the existing wrongcomment [3].
7.4 Efectiveness in Bug Detection
To answer RQ4, we write a script to extract code whose propa-
gated comments describe behaviors related to NullPointerException
andIndexOutOfBoundsException basedonbuggypatterns.For Null-
PointerException, the buggy pattern is the code that does not check
whetherthereturnvalueofamethod(whosecommentsstateanull
value may be returned) is null before dereferencing it. For Index-
OutOfBoundsException, the buggy pattern is the code that does not
check if the returned value of a method (whose comments state -1
maybe returned)is -1 before using itto access an array.
Table 7 reports the bug detection results including, from left
to right, the project, the project version, the number of detected
bugs,thebuggymethodandwhetherthereportedbugisconirmed.
Duetothespacelimitations,notallthebugsarepresentedinthe
table. In total, our script reports 57 bugs. By manually checking
them,webelieve37ofthemaretruebugs.Wehavereportedthe
37 bugs to the developers, among which, 30 bugs have already
beenconirmedandixedbydevelopers [4,5],whiletheremaining
ones await conirmation. For the false positives, the main reason is
thatouranalysisscriptisnotcontext-sensitiveandhencecannot
identifycasesinwhichuserswillneverpassparametersthattrigger
the function to return null or -1. It is a limitation of our scanner,
not comment derivation.
1368Classifying andPropagatingNatural LanguageComments viaProgram Analysis ICSE ’20, May 23ś29, 2020,Seoul,Republic of Korea
8 THREATS TO VALIDITY
The threattoconstruct validityisthebias that maybe introduced
during the manuallabelingofcomments(Section 4).Tomitigate
this threat, each comment was categorized by two developers inde-
pendently, and a third developer would manually resolve all cases
when two developers disagreed. We assessed the labeling relia-
bilitybymeasuringtheinter-coderagreement(Section 4).Inthe
future, we will further minimize the threat by inviting more devel-
opers to categorize comments. The threat to internal validity is the
potentialoverittingproblemofthemachinelearningalgorithms.
Tominimizethis,werandomlyselected80%ofthedatasetasthe
training data and applied a ive-fold cross validation. The threat
to external validity is that it is plausible the classiiers produced
onourtraining datawouldhavelowaccuracywhencategorizing
commentsfromotherprojects.Toalleviatethisthreat,weprepared
labeled comments from four diferent software projects that cover
diferent types of functionalities (e.g., Java collection framework
and calendar system). While we believe that the comments from
these software systems well represent comments in other software
projects, we do not intend to draw any general conclusions. In the
future, we will train the classiiers with more labeled comments
of other kinds of systems to improve the generalizability. The user
study was conducted with 14 users and 80 code entities. While we
taskedeachuserwithalotofcodeandcomment,wewillextend
the study to alarger usergroup.
9 RELATED WORK
Comment Classiication. Researchersin[ 58]proposedataxon-
omy based on meanings of comments and manually classiied 1050
comments. They found52.6% of these commentscanbe leveraged
toimprovesoftwarereliabilityandincreaseprogrammerproduc-
tivity. In [ 52], researchers empirically studied API directives which
are constraints about usages of APIs, and built a corresponding
taxonomy.Theauthorsof[ 46]leveragedgroundedmethodsandan-
alyticalapproachestobuildataxonomyofknowledgetypesinAPI
referencedocumentationandmanuallyclassiied5574randomly-
sampleddocumentationunitstoassesstheknowledgetheycontain.
Based on this taxonomy, the researchers in [ 43] trained a classiier
for each knowledge type and assigned only one label to each docu-
ment unit based on nine features and their semantic and statistical
combinations. In comparison, each classiier in our work classi-
ies comments into diferent perspectives and code entities. The
work [29] built a taxonomy of comments to investigate developers’
commenting habits while the work [ 74] studied comment cate-
gorizationtoprovidebetterquantitativeinsightsaboutcomment
qualityassessment.Researchersin[ 60,61]producedataxonomy
ofcommentsandinvestigatedhowofteneachcategoryoccursby
manuallyclassifyingmorethan2,000codecomments.Unlikethem,
wedevelopthetaxonomytotreatacommentasanattributeofa
code entity and thus we can leverage program analysis techniques
toinfer,propagate,updateandreasonaboutcomments.Itisunclear
how to propagatecomments basedonexisting taxonomies.
CommentGeneration. Thereareefortsofgeneratingcomments
from source code/code changes, based on manually crafted tem-
plates [13,19,47,48,53,54,66,71ś73], information retrieval [ 27,28,32,84,85], and machine translation [ 14,31,33,35,62]. The
techniques [ 84,85] are most closely related and they generated
comments for a code snippet byusing commentsof its code clone.
However,they didnot distinguishbetweencomments ofdiferent
perspectives and thus may generate many wrong comments. Also
they did not utilize techniques like data low analysis to propagate
comments,whichisournovelty.Ourtechniquedifersfromcom-
mentgenerationinafewaspects.Commentgenerationproduces
comments from code. However, diferent projects have diferent
codingandcommentstyles.Agenerationtechniquetrainedonaset
of projects or based on rules may not generate good comments on
otherprojects.Insteadofgeneratingcommentsfromcode,weprop-
agateexistingcommentstocodeentitiesthatarenotcommented
byleveragingprogramanalysis.Ourtechniqueislesssensitiveto
such styles as it only classiies comments instead of generating
them. Comment propagation is deterministic and rigorous through
programanalysis.Secondly,generatingcommentsforcomplexcode
thatevenhumanscanhardlyunderstandiserror-prone.Forsuch
cases,ourtechniquecanleverageexistingcomments(fromother
places).Thirdly,evaluatingqualityofgeneratedcomments,such
astheirnaturalness,isahardchallenge.Ourtechniqueislargely
immune to this. Finally, our technique can propagate comments to
methods without code while existing work requires code as input.
Ontheotherhand,commentgenerationandcommentpropagation
are complementary. Through propagation, we can produce a much
larger training set for generation techniques. Generated comments
can be propagated throughour technique.
Comment-Code Inconsistency Detection. Research has been
conductedon improving APIdocumentation maintenancesuchas
reportingpotentialcode-commentinconsistenciesascodeevolves[ 21,
67], detecting existing code-comment inconsistencies [ 77ś79,89,
91], and enriching documentation (e.g., with code samples) [ 26,34,
37,75,76,82].Theydonotaimtoexplicitlypropagatecomments
as irst-class objectsandthus our efortsare complementary.
10 CONCLUSION
We build a comprehensive comment taxonomy from diferent per-
spectives with various levels of granularity and propose using pro-
gramanalysistopropagatecomments.WedevelopaprototypeCPC.
OurexperimentsshowthatCPCcangenerate41573newcomments
with 88% accuracy. The derived comments are used to detect 37
newcodebugsin5real-worldprojectswith30conirmedandixed
bydevelopers.Wealsoidentify304defectsinexistingcomments,
including 12 incomplete comments and 292 wrong comments. Our
user study conirms propagated comments align well with existing
comments regarding quality.
ACKNOWLEDGMENTS
We thank the anonymous reviewers for their constructive com-
ments.Thisresearchwassupported,inpartbyNSF-China61802166,
61972193and61832009,DARPAFA8650-15-C-7562,NSF1748764,
1901242and1910300,ONRN000141410468andN000141712947,and
Sandia National Lab under award 1701331. Any opinions, indings,
and conclusions in this paper are those of the authors only and do
not necessarily relectthe views of our sponsors.
1369ICSE ’20, May 23ś29, 2020,Seoul,Republicof Korea Zhai et al.
REFERENCES
[1]2019.Apache Commons Collections. https://commons.apache.org/proper/
commons-collections/.
[2]2019. CaseMarkingRelation. http://universaldependencies.org/docsv1/u/dep/
case.html.
[3]2019. Comirmed and Corrected Comments. https://issues.apache.org/jira/
browse/COLLECTIONS-727.
[4]2019. Comirmed and Fixed Bugs. https://issues.apache.org/jira/browse/
COLLECTIONS-710.
[5]2019.ComirmedandFixedBugs.https://issues.apache.org/jira/browse/JDO-780.
[6] 2019. EclipseJavadevelopmenttools(JDT). https://www.eclipse.org/jdt/.
[7] 2019. Guava. https://opensource.google.com/projects/guava/.
[8]2019. JDK. https://www.oracle.com/technetwork/java/javase/downloads/index.
html.
[9] 2019. Joda Time. https://www.joda.org/joda-time/.
[10]2019. Preconjunct Relation. https://nlp.stanford.edu/software/dependencies_
manual.pdf.
[11] 2019. sklearnmetrics. https://scikit-learn.org/stable/modules/classes.html.
[12] 2019. word2vectool. https://github.com/dav/word2vec.
[13]NahlaJAbid,NataliaDragan,MichaelLCollard,andJonathanIMaletic.2015.
Usingstereotypesintheautomaticgenerationofnaturallanguagesummaries
for c++ methods. In Software Maintenance and Evolution (ICSME), 2015 IEEE
InternationalConferenceon. IEEE,561ś565.
[14]Miltiadis Allamanis, Hao Peng, and Charles Sutton. 2016. A convolutional at-
tention network for extreme summarization of source code. In International
Conference onMachineLearning. 2091ś2100.
[15]Miltos Allamanis, Daniel Tarlow, Andrew Gordon, and Yi Wei. 2015. Bimodal
modellingofsourcecodeandnaturallanguage.In InternationalConferenceon
MachineLearning. 2123ś2132.
[16]J Viera Anthony and M Garrett Joanne. 2005. Understanding Interobserver
Agreement: The KappaStatistic. Family medicine 37(06 2005),360ś3.
[17]AriannaBlasi,AlbertoGoi,KonstantinKuznetsov,AlessandraGorla,MichaelD
Ernst, Mauro Pezzè, and Sergio Delgado Castellanos. 2018. Translating code
commentstoprocedure speciications.In Proceedingsofthe 27thACM SIGSOFT
InternationalSymposiumonSoftwareTestingand Analysis. ACM,242ś253.
[18] L.Breiman.2001. RandomForests. In MachineLearning. Vol. 45.5ś32.
[19]Raymond PL Buse and Westley R Weimer. 2010. Automatically documenting
program changes. In Proceedings of the IEEE/ACM international conference on
Automatedsoftwareengineering. ACM,33ś42.
[20]JacobCohen.1960. Acoeicientofagreementfornominalscales. Educational
and psychological measurement 20,1 (1960), 37ś46.
[21]BarthélémyDagenaisandMartinPRobillard.2014. Usingtraceabilitylinksto
recommendadaptivechangesfordocumentationevolution. IEEETransactionson
SoftwareEngineering 40,11(2014), 1126ś1146.
[22]Marie-Catherine de Marnefe, Bill MacCartney, and Christopher D. Manning.
2006. Generating Typed Dependency Parses from Phrase Structure Parses. In
Proceedings of the Fifth International Conference on Language Resources and Eval-
uation(LREC’06). European Language ResourcesAssociation(ELRA).
[23]Sergio Cozzetti B de Souza, Nicolas Anquetil, and Kathia M de Oliveira. 2005. A
study of the documentation essential to software maintenance. In Proceedings of
the23rdannualinternationalconferenceonDesignofcommunication:documenting
& designing for pervasiveinformation. ACM,68ś75.
[24]Alberto Goi, Alessandra Gorla, Michael D Ernst, and Mauro Pezzè. 2016. Auto-
matic generation of oracles for exceptional behaviors. In Proceedings of the 25th
InternationalSymposiumonSoftwareTestingand Analysis. ACM,213ś224.
[25]Tihomir Gvero and Viktor Kuncak. 2015. Synthesizing Java expressions from
free-formqueries.In Acm Sigplan Notices, Vol. 50.ACM,416ś432.
[26]Andrew Habib and Michael Pradel. 2018. Is this class thread-safe? inferring
documentation using graph-based learning. In Proceedings of the 33rd ACM/IEEE
InternationalConferenceonAutomatedSoftwareEngineering. ACM,41ś52.
[27]Sonia Haiduc, Jairo Aponte, and Andrian Marcus. 2010. Supporting program
comprehension with source code summarization. In Proceedings of the 32Nd
ACM/IEEEInternationalConferenceonSoftwareEngineering-Volume2.ACM,223ś
226.
[28]SoniaHaiduc,JairoAponte,LauraMoreno,andAndrianMarcus.2010. Onthe
useofautomatedtextsummarizationtechniquesforsummarizingsourcecode.
InReverse Engineering (WCRE),201017thWorking Conference on. IEEE,35ś44.
[29]Dorsaf Haouari, Houari Sahraoui, and Philippe Langlais. 2011. How good is
your comment? a study of comments in java programs. In Empirical Software
Engineering and Measurement (ESEM), 2011 International Symposium on. IEEE,
137ś146.
[30]CarlSHartzmanandCharlesFAustin.1993. Maintenanceproductivity:Obser-
vations based on an experience in a large system environment. In Proceedings of
the1993conferenceoftheCentreforAdvancedStudiesonCollaborativeresearch:
softwareengineering-Volume 1. IBM Press,138ś170.
[31]Xing Hu, Ge Li, Xin Xia, David Lo, and Zhi Jin. 2018. Deep code comment
generation. In Proceedings of the 26th Conference on Program Comprehension.
ACM,200ś210.[32]YuanHuang,QiaoyangZheng,XiangpingChen,YingfeiXiong,ZhiyongLiu,and
Xiaonan Luo. 2017. Mining version control system for automatically generating
commit comment. In Proceedings of the 11th ACM/IEEE International Symposium
onEmpiricalSoftwareEngineering and Measurement. IEEE Press,414ś423.
[33]Srinivasan Iyer, Ioannis Konstas, Alvin Cheung, and Luke Zettlemoyer. 2016.
Summarizingsourcecodeusinganeuralattentionmodel.In Proceedingsofthe
54thAnnualMeetingoftheAssociationforComputationalLinguistics(Volume1:
Long Papers), Vol. 1.2073ś2083.
[34]HeJiang,JingxuanZhang,ZhileiRen,andTaoZhang.2017. Anunsupervised
approachfordiscoveringrelevanttutorialfragmentsforAPIs.In Proceedingsof
the 39thInternationalConference onSoftwareEngineering. IEEE Press,38ś48.
[35]Siyuan Jiang, Ameer Armaly, and Collin McMillan. 2017. Automatically generat-
ing commit messages from difs using neural machine translation. In Proceedings
ofthe32ndIEEE/ACMInternationalConferenceonAutomatedSoftwareEngineering .
IEEE Press,135ś146.
[36]ZhenMingJiangandAhmedEHassan.2006. Examiningtheevolutionofcode
commentsinPostgreSQL.In Proceedingsofthe2006internationalworkshopon
Miningsoftwarerepositories. ACM,179ś180.
[37]Jinhan Kim, Sanghoon Lee, Seung-Won Hwang, and Sunghun Kim. 2013. Enrich-
ing documents with examples: A corpus mining approach. ACM Transactions on
InformationSystems(TOIS) 31,1 (2013), 1.
[38]YoonKim.2014. Convolutionalneuralnetworksforsentenceclassiication. arXiv
preprint arXiv:1408.5882 (2014).
[39]Yoon Kim. 2014. Convolutional neural networks for sentence classiication.
InProceedings of 2014 Conference on Empirical Methods in Natural Language
Processing(EMNLP).
[40]Dan Klein and ChristopherD. Manning. 2003. Accurate unlexicalized parsing. In
Proceedingsofthe 41st Meetingofthe Associationfor ComputationalLinguistics.
[41]Dan Klein and Christopher D Manning. 2003. Accurate unlexicalized pars-
ing.InProceedingsofthe41stAnnualMeetingonAssociationforComputational
Linguistics-Volume 1. Associationfor Computational Linguistics,423ś430.
[42]R.Kohavi.1995. AStudyofCross-ValidationandBootstrapforAccuracyEstima-
tionand ModelSelection. In IJCAIâĂŹ95.
[43]Niraj Kumar and Premkumar Devanbu. 2016. OntoCat: Automatically categoriz-
ingknowledge in API Documentation. arXiv preprint arXiv:1607.07602 (2016).
[44]Matt Kusner, Yu Sun, Nicholas Kolkin, and Kilian Weinberger. 2015. From word
embeddingstodocumentdistances.In InternationalConferenceonMachineLearn-
ing. 957ś966.
[45]RensisLikert.1932. Atechniqueforthemeasurementofattitudes. Archivesof
psychology (1932).
[46]WalidMaalejandMartinPRobillard.2013.PatternsofknowledgeinAPIreference
documentation. IEEE Transactions on Software Engineering 39, 9 (2013), 1264ś
1282.
[47]PaulWMcBurneyandCollinMcMillan.2014. Automaticdocumentationgen-
erationvia sourcecodesummarizationof methodcontext.In Proceedingsofthe
22nd InternationalConference onProgramComprehension. ACM,279ś290.
[48]PaulWMcBurneyandCollinMcMillan.2016. Automaticsourcecodesumma-
rization of contextfor java methods. IEEE TransactionsonSoftwareEngineering
42,2 (2016), 103ś119.
[49]Tomas Mikolov, Kai Chen, Greg Corrado, and Jefrey Dean. 2013. Eicient
estimationofwordrepresentationsinvectorspace. arXivpreprintarXiv:1301.3781
(2013).
[50]TomasMikolov,IlyaSutskever,KaiChen,GregSCorrado,andJefDean.2013.
Distributed representations of words and phrases and their compositionality. In
Advancesinneuralinformation processingsystems. 3111ś3119.
[51]MB Miles, AM Huberman, and J Saldaña. [n.d.]. Qualitative data analysis: a
methodssourcebook.2013 ThousandOaks.
[52]MartinMonperrus,MichaelEichberg,ElifTekes,andMiraMezini.2012. What
should developers be aware of? An empirical study on the directives of API
documentation. EmpiricalSoftwareEngineering 17,6 (2012), 703ś737.
[53]Laura Moreno, Jairo Aponte, Giriprasad Sridhara, Andrian Marcus, Lori Pollock,
andKVijay-Shanker.2013. Automaticgenerationofnaturallanguagesummaries
forjavaclasses.In ProgramComprehension(ICPC),2013IEEE21stInternational
Conference on. IEEE,23ś32.
[54]Laura Moreno, Andrian Marcus, Lori Pollock, and K Vijay-Shanker. 2013. Jsum-
marizer: An automatic generator of natural language summaries for java classes.
InProgram Comprehension (ICPC), 2013 IEEE 21st International Conference on.
IEEE,230ś232.
[55] KimberlyANeuendorf. 2016. The content analysis guidebook. Sage.
[56]AnhTuanNguyen,PeterCRigby,ThanhVanNguyen,MarkKaranil,andTienN
Nguyen. 2017. Statistical translation of English texts to API code templates.
InSoftwareEngineering Companion(ICSE-C),2017 IEEE/ACM 39thInternational
Conference on. IEEE,331ś333.
[57]ChaparroOscar,LuJing,ZampettiFiorella,MorenoLaura,DiPentaMassimiliano,
Marcus Andrian, Bavota Gabriele, and Ng Vincent. 2017. Detecting Missing
Information in Bug Descriptions. In Proceedings of the 2017 11th Joint Meeting
onFoundationsofSoftwareEngineering (Paderborn,Germany) (ESEC/FSE2017) .
ACM,NewYork, NY, USA,396ś407. https://doi.org/10.1145/3106237.3106285
1370Classifying andPropagatingNatural LanguageComments viaProgram Analysis ICSE ’20, May 23ś29, 2020,Seoul,Republic of Korea
[58]Yoann Padioleau, Lin Tan, and Yuanyuan Zhou. 2009. Listening to program-
mers Taxonomies and characteristics of comments in operating system code. In
Proceedings of the 31st International Conference on Software Engineering. IEEE
Computer Society, 331ś341.
[59]RahulPandita,XushengXiao,HaoZhong,TaoXie,StephenOney,andAmitParad-
kar.2012. InferringmethodspeciicationsfromnaturallanguageAPIdescriptions.
InProceedings of the 34th International Conference on Software Engineering. IEEE
Press,815ś825.
[60]LucaPascarella.2018. ClassifyingcodecommentsinJavaMobileApplications.
InConference onMobileSoftwareEngineering and Systems.
[61]Luca Pascarella and Alberto Bacchelli. 2017. Classifying Code Comments in Java
Open-sourceSoftwareSystems.In Proceedingsofthe14thInternationalConference
onMiningSoftwareRepositories (Buenos Aires, Argentina) (MSR ’17). 227ś237.
[62]HungPhan,HoanAnhNguyen,TienNNguyen,andHrideshRajan.2017. Sta-
tisticallearningforinferencebetweenimplementationsanddocumentation.In
Proceedings of the 39th International Conference on Software Engineering: New
Ideas and EmergingResults Track. IEEE Press,27ś30.
[63]M.F.Porter.1980.Analgorithmforsuixstripping. Program14,3(1980),130ś137.
[64] R. Quinlan and M.Kaufmann.1993. C4.5: Programsfor MachineLearning.
[65]Anna N Raferty and Christopher D Manning. 2008. Parsing three German
treebanks:Lexicalizedandunlexicalizedbaselines.In ProceedingsoftheWorkshop
onParsing German. Associationfor Computational Linguistics,40ś46.
[66]Sarah Rastkar, Gail C Murphy, and Alexander WJ Bradley. 2011. Generating
natural language summariesforcrosscutting source codeconcerns.In Software
Maintenance (ICSM), 201127th IEEE International Conferenceon.IEEE, 103ś112.
[67]InderjotKaurRatolandMartinPRobillard.2017. Detectingfragilecomments.
InAutomated Software Engineering (ASE), 2017 32nd IEEE/ACM International
Conference on. IEEE,112ś122.
[68]C. K. Roy and J. R. Cordy. 2008. NICAD: Accurate Detection of Near-Miss
Intentional Clones Using Flexible Pretty-Printing and Code Normalization. In
2008 16th IEEE International Conference on Program Comprehension. 172ś181.
https://doi.org/10.1109/ICPC.2008.41
[69]CindyRubio-GonzálezandBenLiblit.2010. Expecttheunexpected:errorcode
mismatches between documentation and the real world. In Proceedings of the
9th ACM SIGPLAN-SIGSOFT workshop on Program analysis for software tools and
engineering. ACM,73ś80.
[70]C. Silva and B. Ribeiro. 2003. The importance of stop word removal on recall
values in textcategorization.In Proceedings of the International JointConference
onNeural Networks. IEEE.
[71]Giriprasad Sridhara, Emily Hill, Divya Muppaneni, Lori Pollock, and K Vijay-
Shanker.2010. Towardsautomaticallygeneratingsummarycommentsforjava
methods. In Proceedings of the IEEE/ACM international conference on Automated
softwareengineering. ACM,43ś52.
[72]Giriprasad Sridhara, Lori Pollock, and K Vijay-Shanker. 2011. Automatically
detecting and describing high level actions within methods. In Proceedings of the
33rdInternationalConference onSoftwareEngineering. ACM,101ś110.
[73]Giriprasad Sridhara, Lori Pollock, and K Vijay-Shanker. 2011. Generating param-
eter comments and integrating with method summaries. In Program Comprehen-
sion (ICPC),2011IEEE 19thInternationalConference on. IEEE,71ś80.
[74]DanielaSteidl,BenjaminHummel,andElmarJuergens.2013. Qualityanalysis
of source code comments. In Program Comprehension (ICPC), 2013 IEEE 21st
InternationalConferenceon. IEEE,83ś92.
[75]JefreyStylos,BradAMyers,andZizhuangYang.2009. Jadeite:improvingAPI
documentation using usage information.In CHI’09ExtendedAbstracts onHumanFactorsinComputingSystems. ACM,4429ś4434.
[76]SiddharthSubramanian,LauraInozemtseva,andReidHolmes.2014. LiveAPI
documentation.In Proceedingsofthe36thInternationalConferenceonSoftware
Engineering. ACM,643ś652.
[77]Lin Tan, Ding Yuan, Gopal Krishna, and Yuanyuan Zhou. 2007. /* iComment:
Bugs or bad comments?*. In ACM SIGOPS Operating Systems Review, Vol. 41.
ACM,145ś158.
[78]Lin Tan, Yuanyuan Zhou, and Yoann Padioleau. 2011. aComment: mining anno-
tationsfromcommentsandcodetodetectinterruptrelatedconcurrencybugs.In
Software Engineering (ICSE), 2011 33rd International Conference on . IEEE, 11ś20.
[79]ShinHweiTan,DarkoMarinov,LinTan,andGaryTLeavens.2012. @tcomment:
Testing javadoc comments to detect comment-code inconsistencies. In Software
Testing,VeriicationandValidation(ICST),2012IEEEFifthInternationalConference
on. IEEE,260ś269.
[80]Ted Tenny. 1985. Procedures and comments vs. the banker’s algorithm. ACM
SIGCSE Bulletin 17,3 (1985), 44ś53.
[81]Ted Tenny. 1988. Program readability: Procedures versus comments. IEEE
Transactions onSoftwareEngineering 14,9 (1988), 1271ś1279.
[82]ChristophTreudeandMartinPRobillard.2016. AugmentingAPIdocumentation
withinsightsfromStackOverlow.In SoftwareEngineering(ICSE),2016IEEE/ACM
38thInternationalConference on. IEEE,392ś403.
[83]GrigoriosTsoumakasandIoannisKatakis.2007. Multi-labelclassiication:An
overview. InternationalJournalofDataWarehousingandMining(IJDWM) 3,3
(2007), 1ś13.
[84]Edmund Wong, Taiyue Liu, and Lin Tan. 2015. CloCom: Mining existing source
codeforautomaticcommentgeneration.In 22ndIEEEInternationalConference
onSoftware Analysis, Evolution, and Reengineering, SANER 2015,Montreal, QC,
Canada, March 2-6,2015. 380ś389.
[85]EdmundWong,JinqiuYang,andLinTan.2013. AutoComment:MiningQuestion
and Answer Sites for Automatic Comment Generation. In Proceedings of the
IEEE/ACM International Conference on Automated Software Engineering (ASE),
NewIdea.
[86]Edmund Wong, Lei Zhang, Song Wang, Taiyue Liu, and Lin Tan. 2015. DASE:
Document-assisted Symbolic Execution for Improving Automated Software Test-
ing. InProceedings ofthe 37th International Conference on Software Engineering-
Volume 1(ICSE). IEEE,620ś631.
[87]Scott N Woodield, Hubert E Dunsmore, and Vincent Yun Shen. 1981. The efect
of modularizationand commentsonprogramcomprehension.In Proceedingsof
the 5thinternational conference onSoftwareengineering. IEEE Press,215ś223.
[88]JuanZhai,JianjunHuang,ShiqingMa,XiangyuZhang,LinTan,JianhuaZhao,
and FengQin.2016. Automatic model generationfrom documentationfor Java
API functions. In Software Engineering (ICSE), 2016 IEEE/ACM 38th International
Conference on. IEEE,380ś391.
[89]Hao Zhong and Zhendong Su. 2013. Detecting API documentation errors. In
ACMSIGPLAN Notices, Vol. 48.ACM,803ś816.
[90]HaoZhong,LuZhang,TaoXie,andHongMei.2009. Inferringresourcespeci-
icationsfromnaturallanguageAPIdocumentation.In Proceedingsofthe2009
IEEE/ACM International Conference on Automated Software Engineering. IEEE
Computer Society, 307ś318.
[91]YuZhou,RuihangGu,TaolueChen,ZhiqiuHuang,SebastianoPanichella,and
HaraldGall.2017. AnalyzingAPIsdocumentationandcodetodetectdirective
defects.In Proceedingsofthe39thInternationalConferenceonSoftwareEngineering.
IEEE Press,27ś37.
1371