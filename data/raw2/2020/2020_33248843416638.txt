ChemTest: An Automated Software Testing Framework for an
Emerging Paradigm
Michael C. Gerten
Iowa State University
Department of Computer Science
Ames, Iowa, USA
mcgerten@iastate.eduJames I. Lathrop
Iowa State University
Department of Computer Science
Ames, Iowa, USA
jil@iastate.edu
Myra B. Cohen
Iowa State University
Department of Computer Science
Ames, Iowa, USA
mcohen@iastate.eduTitus H. Klinge
Drake University
Department of Mathematics and Computer Science
Des Moines, Iowa, USA
titus.klinge@drake.edu
ABSTRACT
Inrecentyearstheuseofnon-traditionalcomputingmechanisms
has grown rapidly. One paradigm uses chemical reaction networks
(CRNs) to compute via chemical interactions. CRNs are used to
prototype molecular devices at the nanoscale such as intelligent
drug therapeutics. In practice, these programs are first written and
simulated in environments such as MatLab and later compiled into
physical molecules such as DNA strands. However, techniques for
testing the correctness of CRNs are lacking. Current methods of
validating CRNs include model checking and theorem proving, but
these are limited in scalability. In this paper we present the first (to
thebestofourknowledge)testingframeworkforCRNs,ChemTest.ChemTestevaluatestestoraclesonindividualsimulationtracesand
supports functional, metamorphic, internal and hyper test cases. It
also allows for flakiness and programs that are probabilistic. Weperformed a large case study demonstrating that ChemTest can
find seeded faults and scales beyondmodel checking. Of our tests,
21%areinherentlyflaky,suggestingthatsystematicsupportforthis
paradigm is needed. On average, functional tests find 66.5% of thefaults, while metamorphic tests find 80.4%, showing the benefit of
usingmetamorphicrelationshipsinourtestframework.Inaddition,
we show how the time at evaluation impacts fault detection.
CCS CONCEPTS
‚Ä¢Software and its engineering ‚ÜíSoftware testing and de-
bugging.
KEYWORDS
chemicalreactionnetworks,softwaretesting,metamorphictesting,
flakiness
ASE ‚Äô20, September 21‚Äì25, 2020, Virtual Event, Australia
¬© 2020 Copyright held by the owner/author(s).
ACM ISBN 978-1-4503-6768-4/20/09.
https://doi.org/10.1145/3324884.3416638ACM Reference Format:
MichaelC.Gerten,JamesI.Lathrop,MyraB.Cohen,andTitusH.Klinge.
2020. ChemTest:An Automated Software Testing Frameworkfor an Emerg-
ingParadigm.In 35thIEEE/ACMInternationalConferenceonAutomatedSoft-
ware Engineering (ASE ‚Äô20), September 21‚Äì25, 2020, Virtual Event, Australia.
ACM,NewYork,NY,USA,13pages.https://doi.org/10.1145/3324884.3416638
1 INTRODUCTION
In recent years, utilization of non-traditional computing mecha-
nisms (i.e. programs not written in declarative, imperative, func-
tional languages) have proliferated in research and applications [ 2,
5,8,13,14,17,29,30,47‚Äì51,53,56,58‚Äì61,63,64]. Many of these
paradigmscanbespecifiedwithhigh-levelprogramminglanguages
[8,18,47,52,63]. One such paradigm is the chemical reaction net-
work (CRN). CRNs are an abstraction of the traditional model of
physicalchemistryandareofspecial interestbecausetheycanbe
compiledintodeoxyribonucleicacid(DNA)strandsthatsimulate
theirbehaviorviastranddisplacement[ 4,21,61].Asaresult,CRNs
are used as a programming language to deploy molecular programs
at the nanoscale. CRNs can naturally compute computational prim-
itives such as addition, multiplication, and square roots [ 11,15]a s
well as more complex algorithms such as watchdog timers, state
logging, and finite automata [ 22,23,32]. With new technologies
forsynthesizingDNAandothermolecules,itisnowcommonto
implementCRNsasphysicalnanodevicesinthelab.Thispower-
ful emerging computing paradigm is being promoted as a method
to provide intelligent drug delivery and to achieve other compu-tational functions at the nanoscale. Recently, new programming
methodsandtoolshavebeendevelopedtoeasethedevelopmentof
molecularprograms. Thereis evena newprogramminglanguage,
CRN++,designedto specifyCRNsusingtraditionalprogramming
primitives and control structures [63].
Given the explosive growth in molecular systems, it is impor-
tant to be able to validate and verify the behavior of CRNs. Thepotentially safety-critical nature of expected applications of thistechnology has led the research community to employ formal
methods to prove correctness of stochastic CRNs via model check-
ing, automated theorem proving, and even proving correctness by
hand[21,22,34,36,39].However,asnotedin[ 39],modelchecking
doesnotscaleforlargemoleculepopulations.Wedemonstratein
5482020 35th IEEE/ACM International Conference on Automated Software Engineering (ASE)
This work is licensed under a Creative Commons Attribution International 4.0 License. 
ourcasestudy,thatthePRISMmodelcheckerfailstobuildamodel
at a concentration of 50 molecules on at least one of our subjects.
Theoremprovingtechniquesarescalable,butthedollarcostand
timerequiredtodoso maybeprohibitive,andthetechniquesare
stillrudimentary.Whiletheorem provingtechniques arejustified
forextremesafety-criticalapplications,thereareincreasingnum-
bersofmolecularapplicationsthatarelesssafety-critical,suchas
buildingDNAorigami[ 51].Thereforetoleratingasmallprobability
of failure is acceptable.
An alternative and common approach is to use software testing
to improve scalability for validation, however, several issues make
utilizingstandardtestingframeworksfortestingCRNschallenging.
First, to test CRNs we must rely on a simulation environment;
testingthephysicalsysteminvolvesextensivechemistryandcan
only occur for a limited set of instances (as in other cyberphysical
environments).Forinstance, Qianetal.documentedthata single
experimenttook10hourstorun[ 48].Second,asinmanyscientific
systems,oraclesand/orcompletespecificationsmaynotexist.Third,
thestochasticandasynchronousnatureofthesesimulationsmeans
that they may result in flaky behavior obtaining different values
forthesamesetsofinputs[ 7].Fourth,evenwhenatestisnotflaky,
itcan betime dependent,and thatmay makeitappear flakyeven
whenitisnot.Last,manyoftheseprogramscanbeprobabilistic
and sets of testing trials will be needed.
In this paper, we present the first (to the best of our knowledge)
testing framework for CRNs, ChemTest. ChemTest supports dif-
ferent types of test cases (functional, metamorphic, internal and
hyper).ItformalizesrequirementsintoanLTL-likelanguageand
thenbuildsabstract(parameterized)testcaseswhichcanbeinstan-
tiatedforarangeofinputvalues.Oracleprocessingisperformed
at specific times on simulation traces of a CRN simulator. All tests
are run multiple times to account for flakiness and multiple test
trials are used for probabilistic programs.
In a large case study we evaluate CRNs of varying sizes and
show that (1) we can specify constraints and oracles for test re-quirements, (2) all types of tests are effective in varying degrees
and none outperform others on all mutants, (3) tests are dependenton time, and (4) test and mutant flakiness are inherent to the CRNs
and must be accounted for. The contributions of this work are:
‚Ä¢An end to end approach for a new type of programming
paradigm called ChemTest;
‚Ä¢A case study on different CRNs evaluating:
‚ÄìThe need for different types of tests and
‚ÄìTheimportanceofinherenttestflakinessandprobabilistic
outcomes
Inthenextsection,wepresentmotivatingexamplesandback-
groundonCRNs.InSection3,wepresentChemTest.Weconductacasestudyinsections4and5alongwithadiscussionandroadmap
for interesting research directions in CRN testing. We end with
related work (Section 6) followed by conclusions and future work.
2 MOTIVATION AND BACKGROUND
Chemicalreactionnetworks(CRNs)werefirstusedtomodelandan-alyzechemicalreactionsover50yearsago[
4].ACRNiscomposed
ofasetofspecies Sandasetofreactions Roverthosespecies.A
reactioniscomposedofasetofreactants(leftsideofreaction),asetofproducts(rightsideofreaction),andarateconstantthatdeter-
mineshowfastthereactionproceeds.Thelawofmass-actionyields
onecommonsemanticforCRNsandisdividedintotwovariants:
stochastic mass-action and deterministic mass-action semantics. In
thispaperweusestochasticmass-actionsemanticswheremolecule
counts are natural numbers, and a Markov process determines the
state of the network.
Theprobabilitiesaredeterminedbytherateconstantandproduct
of the reactants. A simple example illustrates these concepts; most
CRNsaremuchmorecomplexthanthis.TheCRNbelowconsists
of two reactions.
X11‚àí‚àí‚àí‚ÜíY (1)
X2+Y1‚àí‚àí‚àí‚Üínull (2)
Reaction (1)converts species X1t oYat a rate proportional to
theproductofthenumberof X1‚Äôsandtherateconstant1,andin
reaction(2),1species Yisremovedforevery X2inthesystem.This
isasubtractionprogram( X2issubtractedfrom X1andplacedin
Y)thatweuseasoneofourstudysubjects.Thisprogramcannot
return negative values. If X2 is larger than X1 it outputs zero Y‚Äôs.
WeshowatypicalsimulationenvironmentforthisCRNusing
MatLab‚Äôs SimBiology package [ 42] in Figure 1. On the left (part A)
we see the species at the top, initialized with molecular concen-
trations (we often just say molecules) of 10 and 5 for X1 andX2
respectively. Ystartswithaconcentrationof0.Thereactions(R1
and R2) are on the bottom, and the model is shown on the right.
On the right of this figure (part B) is a stochastic simulation of this
CRN.Atthestart X1is10,while X2is5and Yis0.At2simulation
seconds both X1 andX2 have reduced to 0, while Yis now 5. Y
is the output variable for this CRN. We note that X1 andX2a r e
inputvariables, butwecan alsoconsidertheminternal variables
since their value is not needed to evaluate the functional outcome.
They are still important since in some cases a wrong internal state
attheendcouldindicateafault(weseethisinourcasestudy).This
CRN is a specific type of a CRN which is called stable, since all
ofthereactionswillstoponce X1andX2havebeenfullyutilized
andtheCRNwillconvergetoasinglespecifiedstatewithproba-
bility1.ThustheprogramisdeterministiceventhoughtheCRN
proceedsinaprobabilisticfashion.OtherCRNsmaynotstabilize
to a single terminating state, and the program is expected to have
aprobabilisticresult.Weconsiderbothtypesofprogramsinthis
work.
Verifying CRNs
The state of the art for verifying CRNs uses model checking to
analyzespecificpropertiesinthestatespacegivena(small)fixed
number of initial molecules for each species [ 21,22,28,34,36,39].
However,asseenin[ 22]onmanyrealprograms,thiswillnotscale
beyond 5 to 10 molecules. The subtraction CRN is relatively small,
thereforewecanmodelcheckitfor1000sofmolecules.Thegoal
of verification however, is to evaluate potentially buggy programs.
If we add a single fault to this program, it is possible it will change
our ability to scale model checking on this CRN. In our case study,
severalofourmutantscausedamodelcheckertorunoutofmemory
before it could build the initial model at concentrations of 2,000
molecules. On another CRN, the original (correct CRN) was unable
549


	

 
Figure 1: The subtraction CRN encoded in MatLab‚Äôs SimBiology package. (A) shows the species X1,X2, andY. This program
willperformthesubtraction10-5=5.(B)showsastochasticsimulationwhereovertime.Atthestart X1is10and X2is5,while
Yis zero. At 2 simulation seconds Y(the output) stabilizes at the final result of 5.
to scale beyond 50 molecules. Both instances allowed for 20G of
memory.Instead,wecantesttheCRN,whichshouldscaletolarger
concentrations,buttothebestofourknowledgethereisnoexisting
systematic method to do this.
2.1 Challenges of Testing CRNs
To test a CRN, we first represent the CRN in a simulation environ-
ment such as MatLab‚Äôs SimBiology package [ 42], Visual GEC [ 46],
or Nuskell [ 5]. We also need to determine the input and output
species, a set of test requirements and test cases. Once the simula-
tionisrun,allofthespeciesstillholdsomevalue(allspeciesare
global),sowewillneedtochecktheirendingvaluesifintegrated
with other programs. If we know the functional output (which we
do in this case) we can perform traditional functional testing.
SinceCRNsoftenmodelphysicalprocesses,manyprogramshave
no known oracles. For instance, the absence detector part of the
MolecularWatchdogTimer[ 22]isaCRNthatchecksforthelackof
a signal (heartbeat) over a given time period. For this CRN we may
need other types of tests such as Metamorphic tests [ 12,40,54].
These are often used to reason about relationships between two
different runs of a program when the exact oracle is unknown. An
example metamorphic test for subtraction is: if the first test input,
X1,isgreaterthanthesecondtestinput X1/prime,andX2remainsthe
sameforboth,thentheoutputin Y/primewillbesmallerthantheoutput
inY. Although we do not specify what Yis, we know that the
second output is smaller. Another need for metamorphic testing
wouldbeintheabsenceofformalspecificationsorifwehavepartial
requirements. This may helpus bypass the need of acomplete set
of functional tests. In this work we support both functional and
metamorphic tests.
Inherent Flakiness
SinceCRNsaredistributedsystemsbasedonthelawsofphysics,we
cannot control the order in which reactions fire, hence there is no
direct analogy to a threadin traditional concurrent programs [ 62].
Thiscanimpacttheabilityofourteststodetectafaultandleadsto
flaky tests. We believe these are common in CRNs, therefore, we
choose to accept that we can‚Äôt fix them and mitigate the issue withmultipletestruns.Anexamplefaultthatisdetectedflakilychanges
subtraction reaction #2 (above) to X1+Y‚àí‚àí‚àí‚Üínull. This has the
impact of reducing X1t oYand then using X1 to remove Y. This is
incorrectbehavior,buttheoutputin Yisdependentontheorderreactionsfire.Inasmallpre-studywefoundthisfaultlessthan50%
of the time over ten test runs.
AnotherincorrectCRNforsubtraction(arandomfaultseeded
in our study, mutant #8), has an additional (third reaction), null‚Üí
X2+X1+Y, that creates new molecules. Adding an additional
reaction is a common mistake a CRN programmer may make. One
of our tests which checks if subtraction works correctly when
X2>X1(Yshould be 0), will be correct intermittently. Suppose
westartwith X2=200,X1=0.Yalsoequals0atthestartofthe
program. The first two reactions (original reactions) will not fire
sincethesearealreadycomplete.Ho wever,the thirdreactionisfree
tofireatanypointintime.Whenthisfiresthenewprogramstateis
X2=201,X1=1,Y=1. Reaction 2 now can fire removing an X2
and aY(X2=200,X1=1,Y=0). At this point, Yhas the correct
value (0) for the output and it would return a correct functional
result. But as other reactions continue to fire, this will return to
an incorrect state, cycling between the correct and incorrect value.
Thismutantwasfoundtobeflakyfor25%oftheinputvalueson
this test case. These are mostly large input values for X2 (small
valuesstabilizedquickly),somethingthatwecannotknowaheadof
time.Wealsomustbecognizantofsimulationtime,sinceevaluation
before the CRN stabilizes can also cause flakiness.
We address all of the issues raised in ChemTest. We allow for
different types of tests (functional, metamorphic, internal) and use
abstract tests instantiated with a broad range of concrete values.
We consider evaluations at different simulation times, and run
simulations (tests) multiple times. We also support setsof tests (or
hyper tests) that are needed to evaluate probabilistic outcomes.
3 CHEMTEST
We now present ChemTest as shown in Figure 2. We begin with
an existing CRN program and a set of requirements (or partial
requirements). We then formulate the test requirements using LTL-
likeproperties[ 6].Thesepropertiesarethenusedtocreatedifferent
types ofabstract test cases which define the input species and the
oracle. We use category partition (in the current framework weimplement this with the test specification language TSL [
44]) to
generateconcretetestcases.Theseareinformedbyconstraintsthat
come from the properties and the input species. We then perform
testingusingastochasticsimulationengineand oracleprocessing,
andthefinaloutputistheresultoftesting.Wedescribeeachpart
of the process in more detail next.
550(Partial)
System
Requirements
Test RequirementTSLCRN
Input
Species
Oracle
Output
Species
Concrete
Input
Simulation
Oracle
ProcessingConstraints
Abstract TestsTestingSimulation
Environment
Functional (F)
Metamorphic (M)Internal (I)Hyper-metamorphic (H)Iteration
Figure 2: Overview of ChemTest. ChemTest starts with an
existingCRNprogramand(partial)setofrequirements.Weformalizetheseandusethepropertiestocreateabstracttestcases.Wethengenerateconcretetestcases,performsimula-tions and process the oracle.
3.1 Formalizing Test Requirements
Inordertogeneratetestcasesandtheiroracles,weneedasetof
requirementstotest.Sincestochasticchemicalreactionnetworks
aremodeledusingMarkovchains,temporallogicisanaturalchoice.Lineartemporallogic (LTL)isarichlogicthatclassifiesthepathsof
a Markov chain and is especially useful for our purposes.
The structure of an LTL formula œïcan be defined recursively in
the following Backus‚ÄìNaur form:
œï:=true|a|¬¨œï|œï1‚àßœï2|Xœï|œï1Uœï2. (3)
Lineartemporallogicformulas[ 6]specifyconstraintsoninfinite
pathsœâ=(s1,s2,...)through a Markov chain where each siis a
state. In equation (3),ais anatomic proposition which evaluates
to true if the first state s1of the path satisfies the proposition a;
Xœïsays that œïis true in the nextstate ofœâ, i.e., that (s2,s3,...)
satisfiesœï; andœï1Uœï2says that œï2eventually holds starting at
some future state siand thatœï1holds for every state s1,...,si‚àí1.
Two commonly used operators are futuredefined by Fœï:=
trueUœïandgloballydefined by Gœï:=¬¨F¬¨œï. Intuitively, Fœïis
trueifthereexistsafuturestate sithatsatisfies œïandGœïistrueif
every state siin the path satisfies œï.
In this work, we use an LTL-like notation, adding some new
operatorsspecifictoCRNs.Weleavetheformalizationanddescrip-
tion of this notation for elsewhere, and instead describe important
aspects of the notation as we go.
ConsiderthesubtractionCRNdefinedearlierbythereactionsin
equations (1)and(2)whichtakesinputs X1andX2andproduces
a number of Ys equal to X1‚àíX2. Many of our test oracles for
subtractionrequirethatifthenumberof X1inputmoleculeschange,
thenthenumberof Youtputmoleculeschangeaccordingly.One
such test is as follows:
/bracketleftbig
X1/prime(0)=2¬∑X1(0)+1/bracketrightbig
‚àß/bracketleftbig
X1(0)is even/bracketrightbig
‚ÜíFG/bracketleftbig
Y/prime>Y/bracketrightbig
.(4)
ThisisametamorphictestwhichcomparesthebehavioroftheCRN
on two differentinputs. Wedenote one input with species X1,X2
and the other input with X1/prime,X2/prime. This requirement specifies that
when the number of initial X1 molecules, denoted by X1(0),i s
increased by a specified amount, then the output Y/primeof the CRNwith more X1 molecules will eventually be always greater than Y,
the one with fewer X1 molecules.
Wemanuallycreatedthesespecificationforthiswork.Wepro-
vide additional information on this notation and all of our formal-
ized specifications on our supplementary web page.
3.2 Abstract Test Generation
After we formalize test requirements, we generate abstract test
cases. The input/output species are determined by the CRN. A test
requirementspecifies constraints (leftsideofimplication)and the
oracle(rightsideofimplication).Wedefinefourtypesofabstract
tests. The first are functional tests (F) which use a single set ofinputs and have a known output. An example functional test for
subtraction is
[X1(0)>X2(0)]‚ÜíFG[Y=X1‚àíX2], (5)
which has a constraint that X1 is greater than X2 at the start of
the program. The oracle states that Ywill eventually always equal
X1‚àíX2.Thesecondtypeofabstracttestsaremetamorphictests
(M) which include two different input sets and are evaluated based
ontherelationshipoftheoutputs.Therequirementshowninequa-
tion(4)is an example of a metamorphic test. The third type of
tests are internal tests (I), which check internal state of the CRN is
correct at the end of computation.
[X2(0)>X1(0)]‚ÜíFG[X1=0], (6)
This test in equation (6) tests the subtraction property when
theinitialnumberofmoleculesin X2aregreaterthanin X1.We
expect the value of molecules in X1 (an internal variable) to be
zero when the computation is complete. This is internal since itdoes not involve our output species (
Y). It is a stronger program
oracle and is important as we move towards integration testing,
since other modules may depend on the state of this variable; The
hailstone subject from our study demonstrates an example of an
internal parity species which is a likely candidate for use by other
modules.
Thelasttypeoftestsarehyper-metamorphictestswhichwerefer
to as simply hypertests (H). A hyper test consists of multiple runs
of the same metamorphic test used for probabilistic programs such
as approximate majority, which is one ofthe CRNs we investigate
inourcasestudy.Hypertestsevaluatetheresultofmetamorphic
tests over some number of runs. An example of a hyper test is
[X1(0)>X2/prime(0)>X2(0)] (7)
‚Üí#[FG[X1/primewins]]<#[FG[X1 wins]] .
This test requirement states that, if the number of X2 molecules
is increased, then X1 ‚Äúwins‚Äù less frequently. Since approximate
majority is an algorithm that determines which of two species has
greater initial population by converting all molecules to a single
species, we use ‚Äú X1 wins‚Äù as shorthand to describe that species X1
has completely annihilated the population of X2 and therefore has
the majority. The # operator counts the number of times the oracle
is satisfied over many simulations of the CRN on that input.
3.3 Concrete Test Generation
Weuseconstraintsfromthetestrequirementsandtheinputspecies
togenerateconcreteinputsusingTSL.Eachabstracttesthasone
551or more concrete test cases that partition its valid test space. As an
example, in subtraction 10 and 5 can be concrete values for X1 and
X2. We use partitions that include large, small, even, odd, etc. Our
TSL is provided on the supplementary website.
3.4 Simulation
Wesimulateall ofthe CRNsusinga stochasticsimulatorsuch as
MatLab‚Äôs SimBiology environment [ 42]. We run each test, Ntimes
(a parameter of our testing process). In our study we use 100 for N.
Wealsoselectasimulationtime(relativetimeusedbythesimulator).
This may vary based on the CRN (see RQ2) and is important to
allowtheCRNtostabilize.Wecollecttracesfromthesimulationto
useintheoracle.Forthehypertestsweruneachofour Niterations
Ttimes. In our study we use 10 for T.
3.5 Oracle Processing
Last, we evaluate the results of checking each test requirement
against the system traces.We implemented a library to check prop-
erties against the simulation traces. We first read the full trace and
examinetheprogramstatefor eachtimeinterval.Thisiscompu-
tationallyexpensive,butcomplete.Forthemetamorphictestswe
evaluate two traces (the two differentinput simulations) together
andforhypertestsweruntheanalysisonpairsofsimulations, T
times and count the number of times the requirement holds. We
notethatour futureglobally operatormayfailpastthetimethatwe
areevaluating,butweassumethecorrectnesswithintheevaluation
time.
4 CASE STUDY
We evaluate several facets of ChemTest. Supplemental data for our
experiments are found on our supplementary website.1We ask the
following three research questions in this study. The first question
focuses on ChemTest‚Äôs core effectiveness:RQ1. How effective is ChemTest at fault detection?
As part of this question we ask how well ChemTest scales by
comparing it against the state of the art, model-checking. The next
two questions focus on unique aspects of CRNsRQ2. What is the impact of time on simulations?RQ3.HowdothestochasticandprobabilisticaspectsofCRNsimpact test results?
4.1 Objects of Study
WehaveselectedthreecommonlyusedCRNstostudyinthispaper.
ThefirsttwoareoftenusedtoillustrateCRNbehavior.Thethird
subjecthasbeenusedinmanyresearchpapers[ 16,31].Thefirst,
subtraction, is a simple CRN (only two reactions and 3 species)that has an obvious functional output. The second, hailstone, is
morecomplicatedwith11reactionsand11species.Thethirdisa
commonCRN,approximatemajority,describedearlier,thathasa
probabilistic output. It returns the correct result a large percentage
of time, but is not guaranteed to always converge on the same
answer. This has only 4 reactions and 3 species. Table 1 shows the
reactions for each of these programs. We describe each in more
detail below.
1https://github.com/LavaOps/ChemTestSubtraction. ThisCRNcomputes f(n1,n2)=n1‚àín2usinginput
speciesX1,X2and outputspecies Y. However, since CRNscannot
havenegativemolecule counts, the CRN outputs 0 if n1<n2.
Hailstone. This CRN computes the hailstone function [35]
f(n)=/braceleftBigg
n/2,ifnis even
3n+1,ifnis odd
using input species X1 and output species Y.
Approximate Majority. This CRN models a probabilistic al-
gorithm that is used in nature to make binary decisions such asthe cell cycle switch. It will quickly decide which of two species
has more molecules. Given an initial population of X1 andX2 the
algorithmoutputsitsdecisionbyconvertingthetotalpopulation
ofmoleculestothespecieswiththeinitialmajority.Both X1and
X2 are outputs.
Table 1: Reactions defining subject programs
Subtraction (S) Hailstone (H) Approximate
Majority (AM)
X1‚ÜíY X1‚ÜíPO+H+M X1+X2‚ÜíU+X1
X2+Y‚ÜínullPO+PO‚ÜíPE X1+U‚ÜíX1+X1
PE+PO‚ÜíPO X2+U‚ÜíX2+X2
PE+PE‚ÜíPE X1+X2‚ÜíU+X2
H+H‚ÜíD
M‚Üí3B+6A
2B+2A‚Üínull
PE+D‚ÜíPE+CE+Y
PO+A‚ÜíPO+CO+Y
CE+PO+Y‚ÜíPO+D
CO+PE+Y‚ÜíPE+A
4.2 Fault Seeding
Since we don‚Äôt have an existing bug repository of faulty CRNs, we
generaterandomprogrammutants(i.e.weusemutationtesting).
Program mutants have been shown to be similar to common types
offaultsintraditionalprograms[ 3,43].Whilewecannotguarantee
thesearerealisticand/orsufficient,wegeneratemutantsthatare
first ordermutants (i.e. singlechanges) and haverestricted them to
similar types of faults we have seen in the CRN programs we have
studied. The mutants are generated as follows. For each mutant
we randomly select a reaction and randomly select from a set of
high level operations, (1) add a new reaction, (2) remove a reaction,
(3) change a reaction. To add a new reaction we select from one
of 15 templates (up to three reactants and three products) andthen for each of the species we assign a valid species from theprogram (at random). To change a reaction we choose to eitheradd a product/reactant, remove a product/reactant or change an
existing product/reactant to a different species from that CRN.
We generated 10 random mutants for each subject. For approxi-
matemajority,oneofthemutantsimulationstimedoutafter4days
of runtime,therefore it was removed.We also restricted thetypes
of reaction modifications for approximate majority to preserve the
existence of two reactants in all cases, because this changes the
rate(aparameterofsimulation)andwediscoveredthatSimBiology
does not correctly handle different rates (its default is 1). This was
552not an issue for other subjects since they are stable CRNs. Table 2
showsthemutantsforeachsubjectbynumber.Thechanged/added
reaction is shown followed by a reaction number. If the number
is larger than the number of reactions in the original CRN (e.g.subtraction, M1) this means a new reaction is added. All others
represent changes and/or removals.
4.3 ChemTest Implementation
We manually created program requirements which formed our
abstracttestcases.Thesecanbefoundonourwebsite.Wegenerate
concrete test cases for all abstract test cases using TSL to definepartitions for each CRN (such as even, odd, large, small), guidedby test requirement constraints. Since some of our abstract testshave constraints such as
X1>X2, each set of abstract tests has
a different number of concrete tests. For all CRNs we used 200as the maximum input value for a single species. In some of our
metamorphictests,thesecondtracerequiredaspeciesthatislarger
(by a factor), e.g. test number 6 for hailstone, hence our largest
input population can be as high as 401 molecules.
Werunallconcretetests100times.Ifaconcretetesthasasingle
trace(i.e.functional,internal)wehave100tracesforthetestcase.Inthecaseofmetamorphicteststherearetwotracesforeachconcretetest,hencewehave200traces.Forthehyper-metamorphictestswerepeatourtests10times,thereforewehave1000testrunsand2000traces(2tracesforeachtest).Werunalltests(noninteractively)ona heterogeneous computation cluster with an allocation of 20GB ofRAM,IntelCPUwithfrequenciesfrom2.1-3.5GHzandutilizinga
single processor core, running Red Hat Linux 7 and Mabtlab2019a
version R2019a-io4754x. All rate constants are kept at 1 for all
reactions in the subjects of this study.
After simulation, we run the evaluation script on the generated
simulation traces. The oracle processing is done using a Python
script.ItevaluatesthepropertiesontheCRNsimulation,returning
(for each trace iteration) whether or not the property holds.
4.4 Flakiness Metrics
We define the metrics used to differentiate deterministic and flaky
tests and mutants in RQ3.
Deterministic/Flaky Concrete Test: A concrete test is deterministic if
itfailsonall Nsimulationtracesduringoracleprocessingandis
flakyif it fails on at least one but not all Ntraces.
Deterministic/Flaky/Mixed Abstract Test: An abstract test is deter-
ministicif all of its concrete tests are deterministic, is flakyif all
ofitscorrespondingconcretetestsareflaky,andis mixedithasa
combination of deterministic and flaky concrete tests.
Deterministic/Flaky/MixedMutant: Amutantis deterministic ifevery
test that finds it is deterministic, is flakyif every test that it finds it
isflaky,and mixediftherearebothdeterministicandflakyfailures.
4.5 Threats to Validity
We outline the most important threats to validity here. With re-
specttoexternalvalidity(generalization)weonlyusedthreeCRNs.
However,weusedCRNsthathavedifferentcharacteristics,used
fordifferentpurposes.WealsoranallofoursimulationsusingMat-Lab‚ÄôsSimBiologypackage.Wedid,however,keeporacleprocessingas a separate program so that this can be used on alternative types
ofsimulationtraces.WhilewebelievethatChemTestwillworkfor
otherstochasticsimulationengines,weleavethisasfuturework.
With respect to internal validity, the authors of this paper wrote
therequirementsdefinitions.Wetriedtousecommonproperties
of the systems we were testing, but, we cannot be sure that they
are complete and/orrepresentative of what other‚Äôsmight develop.
We leave automated test generation (from the CRN model itself) as
futurework.Allofouranalysisusedautomatedprogramswhich
could have faults themselves. We selected subsets of our data to
validate by hand, and examined multiple individual faults in depth.
We have also provide artifacts for this work on an external website
for others to re-validate. With respect to construct validity, the use
of correct metrics, we acknowledge there may be better metrics
touse, butwe chosestandard metrics(such asfault detectionand
runtime) used in testing.
5 RESULTS
In thissection wepresent the resultsof eachof our researchques-
tions.Wefollowwithadiscussionofsomeinterestingobservations,
and end with a roadmap for the future of CRN testing.
5.1 RQ1: How effective is ChemTest at fault
detection?
Table 3 shows testing results for the subtraction (top) and hail-
stone subjects (bottom). Table 4 shows data for the approximate
majoritysubject.ThefirstcolumnistheabstracttestID,thesecond
is the number of concrete tests generated for that test. The next
columnstatesthetesttypewhere‚ÄúF‚Äùmeansfunctional,‚ÄúM‚Äùmeans
metamorphic,‚ÄúI‚Äùmeansinternal,and‚ÄúH‚Äùmeanshypertest.Thecolumns represent individual mutations (10 for subtraction andhailstone, and 9 for approximate majority). Each test ID has two
rows. The first (unshaded) is the percent of failing tests that fail on
all 100 runs (i.e. deterministic). The second (shaded row) indicates
the percent of failed tests that fail in at least one, but not all ofthe 100 runs, (i.e. flaky). The sum of the two rows indicates thepercent of tests failing for that abstract test. For example, in the
firstrowofsubtraction,weseethatthisisafunctionalabstracttest
with 40 concrete tests. For mutation 1, 87% of the abstract tests fail
deterministically and none are flaky. On the other hand, for mu-
tation3,10.9%areflaky,87%aredeterministic;thetotaldetection
rate is 97.9%. Both of these mutants are easily detectable with this
functional test, however, for mutation 3 the concrete test plays a
biggerrole.Itispossibletomissthefaultdependingontheinput
and number of runs.
Overall, we can see that all mutants, except subtraction muta-
tion 2, are detected. We examined mutation 2 and determined it
isanequivalentmutation,henceweremovethisfromtherestof
the analyses (i.e. RQ2 and RQ3). However, mutation 2 did cause
performanceproblemsduringoursimulationssinceitiscreating
additional (unneeded reactions) accounting for 78% of the simu-lationtimeattime100.Forsubtraction,allmutantsarefoundbya mixture of functional, metamorphic, and internal tests and are
found both deterministically and flakily.
Forhailstone,mutation1isonlyfoundbyasinglefunctionaltest,
however,allthreeconcretetestsdetectthefaultdeterministically.
553Table 2: Mutants by subject. For each subject the changed reaction (R) and reaction number (#) is given.
S Change R #H Change R #AM Change R #
S1X1+X1‚àí>X23 H12B+3A‚àí>null 7A1X1+X2‚àí>U+X2+U4
S2Y‚àí>Y 3H2M‚àí>H 12A2Removed 1
S3X1+Y‚àí>null 2H3CE‚àí>3B+6A 6A3X1+X2‚àí>U+U 1
S4X1+X2+Y‚àí>null3H4CE+PO+y‚àí>null 12A4Removed 2
S5Removed 1H5N/A 4A5X2+X1‚àí>X2+X23
S6X2+Y+X1‚àí>null2H6X1‚àí>PO+H 1A6X1+X2‚àí>U+U+X24
S7Y‚àí>null 2H7CO+PE+Y‚àí>A 11A7X1+X2‚àí>U+X1+U1
S8null‚àí>X2+X1+Y3H8PO+A+Y‚àí>PO+CO+Y9A8X1+U‚àí>null 2
S9Y‚àí>X2+X23 H92B+2A+PO‚àí>null 7A9U+U‚àí>X1+X12
S10X2‚àí>null 2H10CO+PE+Y+CE‚àí>PE+A11
Mutation 5 is only found by an internal test. Mutation 6 is only
foundbyoneofthefunctionaltests,butmultiplemetamorphictests
(this pattern is reversed in other mutants). One of the functional
testsdoesnotfindanyofthemutants,andnotestfindsallmutants.
Nextweturntotheapproximatemajority(Table4).Sincethisis
probabilistic,weexpect somefailuresinthe originalprogram.We
include an additional column (column 3), labeled ‚ÄúO,‚Äù which is the
original,non-mutatedCRN.Inalltests,weonlyseeflakyfailures.
For most of the mutations, the mutants fail at a higher rate than
the original in at least some tests.
Wenowlookattheruntimesfortheexperiments.Wecapture
the runtime for all 100 simulations of each concrete test and the
time taken to evaluate the oracle. This data is presented in Table 5.
(Weincludethedataforsubtractionmutation2inthiscalculation.)
For subtraction, the simulation time took 5.2 hours andthe oracle
analysis took 24.6 hours. For hailstone, this is 5.3 hours and 16.8
hoursrespectively.Forapproximatemajority,thetimesroseto15.0
daysand42.2days.Overall,theMatLabsimulationtimeaccounts
for 17-26% of the total testing time, thus the majority of the testing
timewasduetooracleprocessingonthesimulationdata.Partofthe
reason for the long oracle processing was due to the I/O needed to
processthelarge,uncompressed,simulationfiles.AnotherreasonisthatouroracleprocessinglibrarywaswritteninPythonandoneoftheLTL-likeoperatorsusedaninefficientPythonloop.Performance
profiling revealed that the bottleneck was this loop and can be
optimizedbyrewritingthelibraryinalanguagelikeC.Asfuture
workwe planto optimizetheanalysis partof thisstudy andbuild
theoracleprocessingdirectlyinMatLab.Allthedatacollectedin
thisstudy,whichinvolvesadditionalprocessingoftheoraclesfor
different time slots in RQ2 and RQ3, have used from 6.5 days to
310.4days.Overall,theexperimentsrunrepresentapproximatelya
year of machine time, 25.5 days of which is simulation time.Scalability.
We compare against the current state of the art in
validating CRNs, model checking. We selected the Probabilistic
Symbolic(PR)ModelChecker[ 33],Version4.6.PRhaspreviously
beenusedtoevaluateCRNs[ 34].Sincethefirststepofmodelcheck-
ing,buildingthemodel,isrequiredtoevaluateindividualproperties,
we focus on this step. Likewise, we focus on the simulation (and
trace collection) phase of ChemTest for all concrete tests. It should
benotedthatbothmodelcheckingandChemTestcanevaluatemul-
tiplepropertiesonthesamemodelortracerespectively.Weused
the default configuration of PR except for the cudd memory. We
setthisparameter -cuddmaxmem to20gtogiveitafairchance.ThisTable 3: Percent of failing test cases by mutant. ID is the ab-
stract test number, NT is the number of concrete tests, TTis the type of test, F-functional, M-metamorphic, I-internal.Columns represent mutations.
IDNTTT12345678910
Subtraction
146F87.00.087.047.887.050.087.0100.087.058.7
0.00.010.90.00.08.70.00.00.00.0
240F0.00.025.00.00.025.00.070.00.055.0
0.00.030.00.00.025.00.027.50.00.0
340M0.00.00.00.00.00.00.00.00.00.0
0.00.00.00.00.00.00.00.00.00.0
440M75.00.00.035.095.05.085.00.092.50.0
17.50.097.510.00.045.015.075.05.02.5
540M85.00.00.042.590.05.090.00.090.090.0
10.00.092.52.50.035.00.070.00.05.0
640M55.00.00.010.055.02.552.50.055.047.5
45.00.052.55.00.017.50.057.50.05.0
746M0.00.06.50.00.010.90.076.10.058.7
0.00.052.20.00.021.70.023.90.00.0
840I0.00.00.00.055.00.00.00.00.00.0
0.00.00.00.00.00.00.0100.00.00.0
940I55.00.055.055.055.055.055.0100.00.0100.0
0.00.00.00.00.00.00.00.055.00.0
Hailstone
17F0.071.40.071.40.00.085.785.70.085.7
0.014.30.014.30.00.00.00.085.70.0
23F100.0100.0100.00.00.0100.00.0100.0100.0100.0
0.00.00.0100.00.00.00.00.00.00.0
31F0.00.00.00.00.00.00.00.00.00.0
0.00.00.00.00.00.00.00.00.00.0
46M0.00.00.00.00.00.00.0100.00.00.0
0.00.00.0100.00.00.00.00.0100.00.0
57M0.00.014.30.00.0100.00.0100.014.30.0
0.014.342.985.70.00.00.00.085.70.0
63M0.00.00.00.00.0100.00.0100.00.00.0
0.00.0100.0100.00.00.00.00.066.70.0
73M0.00.00.00.00.0100.0100.0100.00.0100.0
0.0100.0100.0100.00.00.00.00.0100.00.0
89I0.00.00.00.00.00.066.70.00.00.0
0.00.00.0100.066.70.00.00.0100.00.0
554Table 4: Percent of Mutants Found by Test Case for Approx.
Majority.IDistheabstracttestnumber,NTistheno.ofcon-
cretetests,TTistesttype,F-functional,I-internal,H-hyper.Columns are mutations.
IDNTTTO123456789
1190F0.000.720.000.000.040.340.720.710.590.00
0.000.060.000.010.170.430.050.070.180.63
2190F0.000.660.740.180.740.090.680.760.750.00
0.340.120.000.340.000.680.090.020.030.77
3183F0.000.730.000.000.000.680.730.640.390.01
0.280.000.000.010.030.090.000.090.360.52
4183I0.000.000.000.000.040.350.000.000.000.00
0.000.000.000.010.160.420.000.000.090.62
5183H0.000.000.000.100.010.300.000.000.000.00
0.040.360.120.080.230.400.050.260.000.75
6183H0.000.000.000.000.000.000.000.000.000.00
0.020.170.000.010.000.180.100.000.000.77
7183H0.000.000.000.000.000.000.000.000.000.00
0.020.000.000.010.030.000.000.000.000.02
8183H0.000.000.000.130.000.190.000.010.000.00
0.110.340.380.300.490.540.070.270.010.73
9183H0.000.000.000.000.000.000.000.000.000.00
0.090.160.000.070.000.400.100.000.000.74
10183H0.000.000.000.000.000.000.000.000.000.00
0.090.000.000.070.100.000.000.010.010.12
11183H0.000.270.680.460.460.400.090.240.000.00
0.220.180.090.110.090.340.030.130.030.76
12183H0.000.000.000.000.000.000.000.000.000.01
0.080.020.000.040.000.210.000.000.000.75
13183H0.000.000.000.000.000.000.000.000.000.00
0.080.000.000.040.020.010.000.010.030.12
14183H0.000.370.690.210.210.310.210.320.000.00
0.140.230.020.080.070.320.070.170.010.67
15183H0.000.000.000.000.000.000.000.000.000.07
0.050.010.000.020.000.160.010.000.000.65
16183H0.000.000.000.000.000.000.000.000.000.00
0.050.000.000.020.030.010.000.010.010.04
17183H0.000.010.000.000.000.000.010.000.000.00
0.360.150.000.400.000.760.090.000.000.77
18183H0.000.000.000.000.020.000.000.000.000.00
0.360.000.000.400.380.000.000.010.020.17
19183H0.000.010.010.010.010.010.010.020.010.01
0.370.170.000.400.000.750.100.000.000.75
20183H0.000.000.000.000.010.000.000.000.000.00
0.370.000.000.400.410.010.000.010.020.20
21183H0.000.000.000.000.000.000.000.000.000.00
0.340.010.000.010.000.160.000.000.000.55
22183H0.000.000.000.000.000.000.000.000.010.01
0.340.000.000.010.020.120.000.170.420.56
23183H0.000.000.000.000.000.000.000.000.000.00
0.370.010.000.010.000.190.000.000.000.56
24183H0.000.010.000.000.000.010.010.010.010.00
0.370.000.000.010.010.090.000.170.430.58
iscomparablewiththe 20GofmemoryweusedtorunChemTest
experiments.WegavePR21GBofRAMtoaccountforoverhead
andusethesamecomputingclusterasChemTest.Weusetwoof
our CRNs, subtraction and Hailstone. For subtraction we startedTable 5: RunTime Data. Total runtime for 100 simulations
(Sim)forallconcretetests,timetocalculatetheoracle(Ora-
cle). Times in Hours (h) or Days(h)
Subjects SimOracle Total% SimTot. Exp. Times
S 5.2h24.6h29.8h 17.4 9.4d
H 5.3h16.8h22.1h 24.0 6.5d
AM 15.0d 42.2d57.2d 26.2 310.4d
withaninputsize40andscaledupto10k.ForHailstonewecon-
structthemodelstartingat10molecules,increasingby10to100,
where model checking regularly fails. We run for all mutants for
each programsand record thetime taken tobuild the models (or
run the ChemTest simulations). We used a 6 hour timeout for both
PR and ChemTest.
Table 6 shows a subset of the results (the rest is on our website).
The rows represent input sizes and the columns are the mutant
programs. The first column, O, is the original CRN. For each, we
showtheresultsinseconds,minutes(m)orhours(h)foreachPR
(PR) and ChemTest (CT). As we see in subtraction, PR is faster
at small input sizes, but is not able to scale to 10k molecules in8 of the 11 mutants. In Hailstone, PR fails to build a model for
10of11modelswithaninputof100molecules;demonstratinga
lossofscalabilityonmorecomplexCRNs.WeexploredHailstone
mutation 6 further. The largest input it handled has 220 molecules
and consists of 1.7 billion states and 10 billion transitions.Summary of RQ1.
All four test types (metamorphic, internal and
hyper tests) are effective at finding faults. Every mutation wasidentified by at least one test type, and the majority were found
bymultipletesttypes.Wealsoseeamixtureofdeterministicand
flaky detection across the various types of tests. With respect to
scalability, wesee that wecan collect test tracesin minutes, while
PR fails to build models for larger molecule counts.
5.2 RQ2. What is the impact of simulation
time on test results in ChemTest?
ForthisRQwelookatfailuresatsimulationintervalsforsubtraction
and hailstone. Approximate majority is on our website and shows
similarresults.Weevaluatetheoracleattime2,4,6,8,10,25,50,
75,and100(thetimeusedinRQ1).ThesetimesareinternalMatlab
simulation times and not relative simulation runtimes, i.e. the time
chosen may have little impact on the practical runtimes, however,
itcanimpactthelengthofthetracesforanalysisifwedonotallow
the simulation to run long enough.
Figure3showsthetimedataasboxplotsfortwoofoursubjects.
Foreachtimeinterval(x-axis)weplotthenumberoffailingconcretetestcasespermutation.Afailuremeansthetestfailedatleastonceforamutation(thisconsidersbothflakyanddeterministicfailures).
The red line is the original (correct) CRN. In all cases at time 2, the
original CRN is appearing faulty since it has not yet converged on
an answer. Over time this converges to zero failures. The box plots
show that the number of failing tests drop over time and stabilize.
We break out the deterministic and faulty failures in RQ3.
Summaryof RQ2. Weconcludethatsimulationtimeisveryim-
portant. All three subjects are unstable early on, but converge at
some point in time.
555Table 6: Left is PRISM model checker (PR), right is time to run all tests in ChemTest (CT). Timeout of 6 hrs with 21 GB of
memory. Times in seconds unless noted, minutes (m), hours (h). M is a memory error and T is a time out.
InputSubtraction
S0 S1 S2 S3 S4 S5 S6 S7 S8 S9 S10
PRCTPRCTPRCTPRCTPRCTPRCTPRCTPRCTPRCTPRCTPRCT
400.11.90.18.50.12.10.19.51.015.80.08.71.117.20.010.012.713.00.19.60.08.3
2000.23.00.410.40.33.10.111.42.39.40.08.91.09.70.111.211.514.80.411.10.29.7
4001.54.62.410.11.64.70.513.519.1911.80.17.813.510.70.313.81.8 m16.92.813.81.310.8
6004.66.36.411.57.36.21.316.41.32 m14.60.47.51.1 m13.60.717.67.3 m23.25.217.42.714.9
8008.97.912.614.19.67.82.817.72.76 m15.20.48.52.2 m15.71.323.314.1 m23.19.920.15.016.6
1k14.19.620.111.415.19.54.919.45.9m16.50.87.64.9m15.92.223.327.7m26.116.224.58.019.7
2k1.3m24.21.6m19.41.3m17.424.929.5M23.54.09.2M22.810.336.52.6h38.41.6m36.351.335.3
3k3.3 m25.64.7 m15.63.6 m28.159.737.8M31.89.28.4M29.925.052.5T48.93.8 m48.42.0 m45.5
4k5.9m33.78.0m19.06.3m2.6m1.8m50.4M36.518.27.4M36.642.255.1T58.16.9m57.03.5m1.0m
5k11.2 m41.917.1 m22.311.8 m41.23.1 m56.5M42.328.98.3M41.71.5 m1.2 mT1.2 m24.8 m1.2 m9.2 m1.1 m
6k16.3m50.525.5m29.117.0m49.74.6m1.1mM51.838.48.5M48.12.0m1.4mT1.3m22.4m1.4m10.2m1.4m
7k25.9 m58.042.4 m2.5 m28.0 m57.16.0 m1.3 mM55.757.77.5M57.12.7 m1.4 mT1.5 mM1.4 m13.5 m1.4 m
8k29.3m1.2m1.8h42.439.3m5.2m11.1m1.3mM1.2m1.5m7.9M1.1m3.7m1.8mT1.9mM1.8m17.5m1.7m
9kM1.4 mM47.8M1.2 m25.2 m1.4 mM60.01.4 m9.3M58.85.6 m1.9 mT1.9 mM1.9 m23.6 m1.9 m
10kM1.4mM2.7mM2.5mM1.6mM1.2m2.2m13.2M1.2m6.4m2.1mT2.0mM2.0m31.2m2.0m
InputHailstone
H0 H1 H2 H3 H4 H5 H6 H7 H8 H9 H10
PRCTPRCTPRCTPRCTPRCTPRCTPRCTPRCTPRCTPRCTPRCT
102.6m27.62.624.12.6m22.721.48.446.711.136.315.219.76.129.78.538.610.81.4m9.32.8m2.2m
205.3m50.95.0m40.09.1m41.832.62.2m8.4m19.63.4m4.5m12.39.05.4m12.65.7m16.816.1m9.06.8m13.7
3026.8 m1.4 m24.3 m59.4M1.1 m4.4 m19.63.2 m30.044.0 m1.0 m15.713.544.4 m27.256.6 m23.93.3 h12.1345.8 m2.3 m
402.5h3.9m2.2h3.1mM1.6m7.9m26.6M48.82.9h1.5m30.718.73.2h2.4m3.9h33.6M15.63.3h24.9
50M2.6 mM1.8 mM2.1 m55.1 m34.82.9 m2.9 mM4.2 m42.033.93.5 h2.5 mM38.1M19.0T30.5
60M3.3mM2.2mT2.6mM42.5M5.2mM4.8m38.44.5mT32.8T45.7M29.2T38.7
70M4mM2.7 mT5.0 mM51.2M1.4 mM9.4 m1.1 m36.7T40.2T3.0 mM26.3T41.8
80M6.8mM5.2mM3.8mM3.0mM1.6mM4.4m1.6m47.1M42.7M3.1mM2.5T53.2
90T7.4 mT5.7 mT6.5 mM1.2 mM5.9 mM8.9 m2.4 m57.5M53.2T3.1 mM33.6T52.9
100M6.2mT4.4mT5.1mM3.3mM2.2mM7.7m3.5m59.2M52.8T1.2mM45.7T3.1m
5.3 RQ3. How do the stochastic and
probabilistic aspects of CRNs impact test
results?
If we return to Table 3 and 4, we see a mix of tests failing either
deterministically or flakily. In this question we look at this data
from another angle. Table 7 breaks out the data by each subject as
follows. It shows, those abstract tests, followed by concrete testsin parentheses, that are deterministic only, flaky only, or mixed.
All data is taken at 100 simulation seconds. These are mutually
exclusive categories. For instance, in subtraction zero abstract tests
are always deterministic, but 89 concrete test case are. Again zero
abstract tests are flaky, while 40 concrete tests are always flaky.Last, all of the abstract tests are always mixed (some flaky, some
deterministic),with224concretetestcasesfallingintothiscategory.
We also can determine from this data that 353 concrete tests failed
atleastonceinthisstudy.Forthemajorityoftestcases,flakiness
is dependent on the mutant that is being tested. The second line of
thistableshowsthatforsubtraction,3mutantsarealwaysfound
deterministically,nonearealwaysflaky,andthat6haveamixed
behavior. There is only one mutant, in Hailstone, that is alwaysflaky. In approximate majority, none of the mutants are always
deterministic and/or always flaky.Table7:No.ofDeterministic,FlakyandMixedtestcasesand
mutants by subject, Subtraction (S), Hailstone (H) and Ap-proximate Majority (AM). Tests are listed as both Abstract
(Abs) and Concrete (Conc.), in parentheses.
Subject Type Determ. Flaky Mixed
Abs(Conc) Abs(Conc) Abs(Conc)
S Test 0 (89) 0 (40) 9(224)
Mutant 3 0 6
H Test 0(0) 0(0) 7(34)
Mutant 5 1 4
AM Test 0(49) 8(1911) 16(877)
Mutant 0 0 9
We now return to the time data to see how determinism and
flakiness impacts fault detection over time. We use the subtraction
andhailstone data.Figure4 showssubtraction(top) andhailstone
by time for deterministic only faults and flaky only faults. These
graphsarethesameasthosefromRQ2,butsplitoutbycategory.In
subtractionthenumberoftestsfailing deterministicallyincreases
over time, while the number failing flakily decreases. In hailstone,
we see an initially higher deterministic set of failing tests, followed
byadecreaseandfinallyweseeanincreaseastheCRNstabilizes.
5562 4 6 8 10 25 50 75 1000 50 100 150 200 250 300
Simulation TimeNo. o f Failing Tests (of 372)
Original CRN
2 4 6 8 10 25 50 75 1000 10 20 30 40
Simulation TimeNo. o f Failing Tests (of 39)
Original CRN
Figure 3: Subtraction, Hailstone, Faults over time.
The flaky tests also reduce over time. This suggests that some of
the flakiness we see is due to simulation time. While we believe
that we ran our CRNs long enough (100 simulation seconds) for
alltostabilize,wecan‚Äôt,ofcoursebesure.Wedobelievethatthe
reasonsforflakinessgobeyondtime.Wedescribesomeexamples
of flaky tests/mutants in our discussion section.Summary of RQ3.
We conclude that stochasticness plays a big
role in testing CRNs. We have built in iterations (100 repetitions
for this study).
5.4 Discussion
InthissectionweinvestigateCRNmutationbehaviorinmoredetail
using two of the CRNs from this study.Hailstone H5Mutation
removes the reaction PE+PE‚ÜíPEre-
actionfromtheCRN.Thisisaninterestingmutationsinceithasnoeffectonthefunctionalbehavior,butviolatesthespecification.This
is directly tested by the CRN oracle property FG[PO+PE==1]
which says that eventually there is always only one of POorPE
molecule in the system, however, the mutation allows multiple PE
moleculesto accumulatewhentheCRN terminates.Thisaccumu-
lation ofPEmolecules only occurs on even inputs.
Evenwhentheinputisevenandtheaccumulationof PEmolecules
couldhappen,theorderofreactionsthatfiremaymasktheerror
in the mutation. For example, if all the firings of the reactions
PO+PE‚ÜíPOandPO+PO‚ÜíPEalternate,thenumbersof PE
molecules whenthe CRN stabilizes willbe 1, eventhough there is
noPE+PE‚ÜíPEreactionpossible.However,adifferentsequence
of reactions can result in multiple PEmolecules when the CRN
terminates. The hailstone H5 mutation is never detected by odd
inputs, and only detected less than 50% of the time on even inputs,
andonlyonasingletestthatutilizedinternalspecies(internaltest).Inaddition,thisCRNisdesignedandconstructedusingCRNsub-
components,e.g.,thethreereactionsthatcomputeparitycontrol
a multiplexer to decide if the output is 3 N+1o rN/2. While the
parity CRN was flawed but had no effect on the functional output,
this is not always the case. If the parity CRN is utilized in other
systemswhereitiscriticalthatonlyasingle PEorPOmoleculebe
present at the end of the computation, this other system would fail.
ApproximateMajorityA3Mutation highlightstheprobabilistic
nature of this CRN, how this manifests as flakiness, and how it
canfooloracles.Thefirstreactionismutatedsothespecies X1is
replacedbythespecies U.Theeffectofthisontheoverallsystem
gives a slight unfair advantage to species X2. Depending on the
input, this can fool hyper tests. Abstract Test 3 on with concrete
inputX1=11andX2=12onlyfailstwiceoutof100runs.Abstract
test 3 states that if X2 has an advantage ( X2>X1) thenX2 should
win.ComparethisresultwiththatofthecorrectAMCRNwhereit
fails 49 times on the same input. The reason is that the AM CRN
on equal inputs should yield ‚Äú X1 wins‚Äù 50 percent of the time, and
as the difference between X1 andX2 increases with X2>X1 this
frequency decreases. With this mutation, X2 is helped, and thus
returns the correct majority species with better frequency.
5.5 A Roadmap for the Future of CRN Testing
In this paper we have presented an initial framework for CRN
testing.Wehaveobservedmanyinterestingfuturedirectionsthat
we summarize briefly here.AutomatedSpecificationsandTestCases.
Wemanuallycreated
the specifications and test cases for our CRNs. We see many oppor-tunities for automated generation (both partial and complete) from
the CRN models.CRN Flakiness.
As demonstrated, test flakiness is an inherent
part of ChemTest. We ran all tests 100 times in our experiments to
ensureourresultswerevalid.However,webelievethatitispossibletodetermineasufficientnumberofiterationsfortesting.Thetopicofflakinessanditsrelationtoflakinessintraditionalenvironments
is an open and interesting question.Mutation Operators.
In this work we used mutation testing to
evaluatethequalityofourtestcases.Recentresearchonconcurrent
andflakymutationtesting[ 26,57]suggeststhatmutationtesting
should be customized for this new environment. While we haveseen some interesting faults that are similar to those which wehave observed in our own programs, a set of sufficient mutation
operators and a theory of mutation testing for CRNs is needed.Performance Optimization.
Inthisworkourfocuswasoncor-
rectness,however,someoftheoracleevaluationwasresourceinten-
sive. Better algorithms to improve this aspect of ChemTest, includ-
ing the evaluation of partial traces and states of the LTL operators,
areneeded.Simulation Parameters.
Several of our simulation parameters
were chosen based on simple heuristics. The best threshold for
considering parameters such as simulation time, with respect to
the input size or other characteristics of the CRN warrants further
investigation.Thesemaybedeterminedbyboththeoreticalanalysis
and experimental tuning.
5572 4 6 8 10 25 50 75 1000 50 100 150 200 250 300
Simulation TimeNo. o f Failing Tests (of 372)
Original CRN
2 4 6 8 10 25 50 75 1000 50 100 150 200 250 300
Simulation TimeNo. o f Failing Tests (of 372)
Original CRN

		


 
Simulation  Time

		


    
  

 
2 4 6 8 10 25 50 75 1000 10 20 30 40
Simulation TimeNo. o f Failing Tests (of 39)
Original CRN

	 		


Simulation  Time

  
  
2 4 6 8 10 25 50 75 1000 10 20 30 40
Simulation TimeNo. o f Failing Tests (of 39)
Original CRN

	 
Figure 4: Faults found over time (deterministic versus flaky)
6 RELATED WORK
There has been considerable research on defining and program-
ming CRNs for various tasks [ 5,24,27] including the development
of languages that can be compiled down to CRNs [ 63]. We fo-
cusprimarilyonvalidatingthecorrectnessofCRNs.Thestateof
the art is to use model checking or automated theorem proving
[21,22,28,34,36,39].CRNscanbemodeledasdeterministic(us-
ing systems of differential equations), concurrent and probabilistic
(usingcontinuoustimeMarkovmodel)systems[ 4,25].Wefocus
on stochastic CRNs which are both concurrent and probabilistic.
Thereisabodyofworkinconcurrenttesting[ 10,45,55,62].We
don‚Äôt attempt to reference it all here since it is geared towards
traditionalcodingconstructs.Someworkanalyzingconcurrencyat
thenanoscaleusingCRNshasalsobeeninvestigated(see[ 37]for
example).Inourwork,thephysicalpropertiesofthemodeldrive
thetestinganddonotexplicitlychangetheorderoffiringreactions.
Whilelockingmechanisms canbeachievedby programdesignin
CRNs, it is important to note that these systems are themselvesCRNs; the underlying physics in these systems are not changed.
TheCRNmodelisalsorelatedtothestandardPetrinetmodelwhich
iswidelystudied[ 9].However,theCRNmodelwhichdefinesacon-
tinuoustimeMarkovmodelrequiresembellishmentstothePetri
netmodel.Petrinetscanbeusedtoautomatetestgeneration,but
wedo notexplorethat here.Instead weutilizeour ownLTL-like
temporal logic which is natural for the expression of test oracles.
Therehasbeenresearchontestflakiness(see[ 7,38,41,57]as
asample),however,muchofthatworkfocusesonprogramming
constructs in traditional programming languages. We use the same
notionofflakiness,butweexplicitlyexpectandsupportthisphe-
nomenon.Last,therehasbeenresearchonprobabilisticprogram-
ming [1,19,20,45]. Some CRNs are probabilistic and ChemTestsupports that construct, but is not specifically about solving proba-
bilistic programming problems.
7 CONCLUSIONS AND FUTURE WORK
WepresentedChemTestanendtoendtestingframeworkforchemi-
calreactionnetworks.ChemTestformalizestestrequirementsinanLTL-likelanguageandusesthistospecifyconstraintsontheinputsandabstracttests.Itsupportsfunctional,metamorphic,internaland
hyper tests. Simulations are run multiple times to handle flakiness.
Inacasestudyweseeonaveragethatfunctionaltestsfind66.5%
of the mutants, while metamorphic test find 80.4%. The internal
and hyper tests find 65.4% and 53.6% respectively. In addition, time
of evaluation impacts fault detection. None of our abstract testsare fully deterministic and 21% are flaky across all concrete test
inputs.InfutureworkweplantoapplyChemTesttomorecomplex
CRNssuchasthosewhichrequireallmetamorphictests,integra-
tion across multiple CRN units and other probabilistic programs.
Wealsowilloptimizetheoracleprocessingwhichwasabottleneck
in this study and build ChemTest directly into MatLab.
8 ACKNOWLEDGEMENTS
Wethankthereviewersfortheirinsightfulcomments.Thiswork
is supported in part by NSF Grant numbers CCF-1909688, CCF-
1901543, and FET-1900716.
REFERENCES
[1]Aws Albarghouthi, Loris D‚ÄôAntoni, Samuel Drews, and Aditya V. Nori. 2017.
FairSquare:ProbabilisticVerificationofProgramFairness. Proc.ACMProgram.
Lang.1,OOPSLA,Article80(Oct.2017),30pages. https://doi.org/10.1145/3133904
[2]Dan Alistarh, Bart≈Çomiej Dudek, Adrian Kosowski, David Soloveichik, and Prze-
mys≈ÇawUzna≈Ñski.2017. RobustDetectioninLeak-PronePopulationProtocols.
(09 2017), 155‚Äì171.
[3]J. H. Andrews, L. C. Briand, and Y. Labiche. 2005. Is Mutation an Appropriate
ToolforTestingExperiments?.In Proceedingsofthe27thInternationalConference
558on Software Engineering (St. Louis, MO, USA) (ICSE ‚Äô05). Association for Comput-
ingMachinery,NewYork,NY,USA,402‚Äì411. https://doi.org/10.1145/1062455.
1062530
[4]RutherfordAris.1965.Prolegomenatotherationalanalysisofsystemsofchemical
reactions. Archive for Rational Mechanics and Analysis 19, 2 (1965), 81‚Äì99.
[5]StefanBadelt,SeungWooShin,RobertF.Johnson,QingDong,ChrisThachuk,
and Erik Winfree. 2017. A General-Purpose CRN-to-DSD Compiler with Formal
Verification,Optimization,andSimulationCapabilities.In Proceedingsofthe23rd
InternationalConferenceonDNAComputingandMolecularProgramming (Lecture
NotesinComputerScience).232‚Äì248. https://doi.org/10.1007/978-3-319-66799-
7_15
[6]Christel Baier and Joost-Pieter Katoen. 2008. Principles of Model Checking (Repre-
sentation and Mind Series). The MIT Press. https://doi.org/10.5555/1373322
[7]Jonathan Bell, Owolabi Legunsen, Michael Hilton, Lamyaa Eloussi, Tifany Yung,
andDarkoMarinov.2018. DeFlaker:AutomaticallyDetectingFlakyTests.In ICSE.
Association for Computing Machinery, New York, NY, USA, 433‚Äì444. https:
//doi.org/10.1145/3180155.3180164
[8]Michael A. Boemo, Alexandra E. Lucas, Andrew J. Turberfield, and Luca Cardelli.
2016. The Formal Language and Design Principles of Autonomous DNA Walker
Circuits. ACS Synthetic Biology 5, 8 (2016), 878‚Äì884. https://doi.org/10.1021/
acssynbio.5b00275
[9]W. Brauer, W. Reisig, and G. Rozenberg (Eds.). 1987. Petri Nets: Applications
and Relationships to Other Models of Concurrency. Springer Berlin Heidelberg.
https://doi.org/10.1007/3-540-17906-2
[10]YanCaiandZijiangYang.2016. RadiusAwareProbabilisticTestingofDeadlocks
with Guarantees. In Proceedings of the 31st IEEE/ACM International Conference on
Automated Software Engineering (Singapore, Singapore) (ASE 2016). Association
for Computing Machinery, New York, NY, USA, 356‚Äì367. https://doi.org/10.
1145/2970276.2970307
[11] Ho-Lin Chen,DavidDoty,and DavidSoloveichik.2014. Deterministicfunction
computation with chemical reaction networks. Natural Computing 13, 4 (01 Dec
2014), 517‚Äì534. https://doi.org/10.1007/s11047-013-9393-6
[12]TsongYuehChen,Fei-ChingKuo,HuaiLiu,Pak-LokPoon,DaveTowey,T.H.
Tse,andZhiQuanZhou.2018. MetamorphicTesting:AReviewofChallenges
and Opportunities. ACM Comput. Surv. 51, 1, Article 4 (Jan. 2018), 27 pages.
https://doi.org/10.1145/3143561
[13]Yuan-JyueChen,NeilDalchau,NiranjanSrinivas,AndrewPhillips,LucaCardelli,
David Soloveichik, andGeorg Seelig. 2013. Programmablechemical controllers
made from DNA. Nature Nanotechnology 8, 10 (2013), 755‚Äì762.
[14]Yuan-JyueChen,BenjaminGroves,RichardA.Muscat,andGeorgSeelig.2015.
DNAnanotechnologyfromthetesttubetothecell. NatureNanotechnology 10
(2015), 748‚Äì760. https://doi.org/10.1038/nnano.2015.195
[15]Kevin Cherry and Lulu Qian. 2018. Scaling up molecular pattern recognition
withDNA-basedwinner-take-allneuralnetworks. Nature559(2018),370‚Äì376.
Issue 7714. https://doi.org/10.1038/s41586-018-0289-6
[16]AnneCondon,MonirHajiaghayi,DavidG.Kirkpatrick,andJ√°nManuch.2017.
SimplifyingAnalysesofChemicalReactionNetworksforApproximateMajor-
ity. InProceedings of the 23rd International Conference on DNA Computing and
Molecular Programming (Lecture Notes in Computer Science, Vol. 10467). Springer,
188‚Äì209. https://doi.org/10.1007/978-3-319-66799-7_13
[17]DavidDoty,JackHLutz,MatthewJPatitz,RobertTSchweller,ScottMSummers,
and Damien Woods. 2012. The tile assembly model is intrinsically universal.
InProceedingsofthe53rdSymposiumonFoundationsofComputerScience.IEEE,
302‚Äì310. https://doi.org/10.1109/FOCS.2012.76
[18]DavidDotyandMatthewJ.Patitz.2009. ADomain-SpecificLanguageforPro-
grammingintheTileAssemblyModel.In Proceedingsofthe15thInternational
Conference on DNA Computing and Molecular Programming (Lecture Notes in
ComputerScience,Vol.5877),RussellDeatonandAkiraSuyama(Eds.).Springer,
25‚Äì34. https://doi.org/10.1007/978-3-642-10604-0_3
[19]SaikatDutta,OwolabiLegunsen,ZixinHuang,andSasaMisailovic.2018. Testing
ProbabilisticProgrammingSystems.In Proceedingsofthe201826thACMJoint
Meeting on European Software Engineering Conference and Symposium on theFoundations of Software Engineering (Lake Buena Vista, FL, USA) (ESEC/FSE
2018). Association for Computing Machinery, New York, NY, USA, 574‚Äì586.
https://doi.org/10.1145/3236024.3236057
[20]SaikatDutta,WenxianZhang,ZixinHuang,andSasaMisailovic.2019. Storm:
ProgramReductionforTestingandDebuggingProbabilisticProgrammingSys-
tems. InProceedings of the 2019 27th ACM Joint Meeting on European Software
Engineering Conference and Symposium on the Foundations of Software Engineer-
ing(Tallinn, Estonia) (ESEC/FSE 2019). Association for Computing Machinery,
New York, NY, USA, 729‚Äì739. https://doi.org/10.1145/3338906.3338972
[21]S.Ellis,E.Henderson,TitusH.Klinge,JamesI.Lathrop,J.Lutz,R.Lutz,Divita
Mathur,andA.Miner.2014. Automatedrequirementsanalysisforamolecular
watchdogtimer.In ASE‚Äô14.AssociationforComputingMachinery,NewYork,
NY, USA, 767‚Äì778. https://doi.org/10.1145/2642937.2643007
[22]SamuelJ.Ellis,TitusH.Klinge,JamesI.Lathrop,JackH.Lutz,RobynR.Lutz,An-drewS.Miner,andHughD.Potter.2019. RuntimeFaultDetectioninProgrammedMolecularSystems. ACMTOSEM 28(2019),6‚Äì20. https://doi.org/10.1145/3295740[23]SamuelJ.Ellis,JamesI.Lathrop,andRobynR.Lutz.2017.Statelogginginchemical
reaction networks. In Proceedings of the 4th ACM International Conference on
Nanoscale Computing and Communication, NANOCOM 2017, Washington, DC,
USA,September27-29,2017.AssociationforComputingMachinery,NewYork,
NY, USA, 23:1‚Äì23:6. https://doi.org/10.1145/3109453.3109456
[24] Martin Feinberg.1979. LecturesOnChemicalReactionNetworks. http://www.
crnt.osu.edu/LecturesOnReactionNetworks.
[25]DanielTGillespie.2009. TheDeterministicLimitofStochasticChemicalKinetics.
The Journal of Physical Chemistry B 113, 6 (2009), 1640‚Äì1644. https://doi.org/10.
1021/jp806431b
[26]Milos Gligoric, Lingming Zhang, Cristiano Pereira, and Gilles Pokam. 2013.Selective Mutation Testing for Concurrent Code. In Proceedings of the 2013
International Symposium on Software Testing and Analysis (ISSTA 2013).A s -sociation for Computing Machinery, New York, NY, USA, 224‚Äì234. https:
//doi.org/10.1145/2483760.2483773
[27]Jeremy Gunawardena. 2003. Chemical Reaction Network Theory for in-silico
Biologists. http://www.jeremy-gunawardena.com/papers/crnt.pdf.
[28]Arie Gurfinkel, Marsha Chechik, and Benet Devereux. 2003. Temporal Logic
QueryChecking:AToolforModelExploration. IEEETransactionsonSoftware
Engineering 29, 10 (2003), 898‚Äì914. https://doi.org/10.1109/TSE.2003.1237171
[29]DongranHan,SuchetanPal,JeanetteNangreave,ZhengtaoDeng,YanLiu,and
Hao Yan.2011. DNA Origamiwith ComplexCurvatures inThree-Dimensional
Space.Science332, 6027 (2011), 342‚Äì346.
[30]Yonggang Ke, Luvena L. Ong, William M. Shih, and Peng Yin. 2012. Three-Dimensional Structures Self-Assembled from DNA Bricks. Science338, 6111
(2012), 1177‚Äì1183.
[31]TitusH.Klinge.2016. RobustSignalRestorationinChemicalReactionNetworks.
InProceedingsofthe3rdInternationalConferenceonNanoscaleComputingand
Communication. ACM, New York, NY, USA, 6:1‚Äì6:6. https://doi.org/10.1145/
2967446.2967465
[32]TitusH.Klinge,JamesI.Lathrop,andJackH.Lutz.2020. Robustbiomolecular
finiteautomata. TheoreticalComputerScience 816,C(2020). https://doi.org/10.
1016/j.tcs.2020.01.008
[33]M.Kwiatkowska,G.Norman,andD.Parker.2011. PRISM4.0:VerificationofProb-
abilisticReal-timeSystems.In Proc.23rdInternationalConferenceonComputer
AidedVerification(CAV‚Äô11) (LNCS,Vol.6806),G.GopalakrishnanandS.Qadeer
(Eds.). Springer, 585‚Äì591. https://doi.org/10.1007/978-3-642-22110-1_47
[34]Marta Kwiatkowska and Chris Thachuk. 2014. Probabilisticmodel checking for
biology.Software Systems Safety 36 (2014), 165‚Äì189.
[35]Jefferey C. Lafarias (Ed.). 2010. The ultimate challenge : the 3x + 1 problem.
American Mathematical Society.
[36]MatthewR.Lakin,DavidParker,LucaCardelli,MartaKwiatkowska,andAndrew
Phillips.2012. DesignandanalysisofDNAstranddisplacementdevicesusing
probabilisticmodelchecking. JournaloftheRoyalSocietyInterface 9,72(2012),
1470‚Äì1485. https://doi.org/10.1098/rsif.2011.0800
[37]MatthewR.Lakin,DarkoStefanovic,andAndrewPhillips.2016. Modularverifica-tionofchemicalreactionnetworkencodingsviaserializabilityanalysis. Theoreti-
calComputerScience 632(2016),21‚Äì42. https://doi.org/10.1016/j.tcs.2015.06.033
Verification of Engineered Molecular Devices and Programs.
[38]WingLam,ReedOei,AugustShi,DarkoMarinov,andTaoXie.2019. IDFlakies:Aframeworkfordetectingandpartiallyclassifyingflakytests.In Proceedings-2019
IEEE12thInternationalConferenceonSoftwareTesting,VerificationandValidation,
ICST 2019. 312‚Äì322. https://doi.org/10.1109/ICST.2019.00038
[39]JamesI.Lathrop,JackH.Lutz,RobynR.Lutz,HughD.Potter,andMatthewR.
Riley.2020. Population-inducedphasetransitionsandtheverificationofchemical
reaction networks. In Proceedings of the 26th International Conference on DNA
Computing and Molecular Programming (DNA 2020). To appear.
[40]AndersLundgrenandUpuleeKanewala.2016. Experiencesoftestingbioinfor-
matics programs for detecting subtle faults. In Proceedings of the International
Workshop on Software Engineering for Science - SE4Science ‚Äô16. 16‚Äì22.
[41]Qingzhou Luo, Farah Hariri, Lamyaa Eloussi, and Darko Marinov. 2014. AnEmpirical Analysis of Flaky Tests. In Proceedings of the 22nd ACM SIGSOFT
International Symposium on Foundations of Software Engineering (Hong Kong,
China)(FSE2014).AssociationforComputingMachinery,NewYork,NY,USA,
643‚Äì653. https://doi.org/10.1145/2635868.2635920
[42]MATLAB. 2019. version 9.5.0 (R2018b). The MathWorks Inc., Natick, Mas-
sachusetts.
[43]Akbar Siami Namin and SahityaKakarla. 2011. The Use of Mutation in Testing
Experiments and Its Sensitivity to External Threats. In Proceedings of the 2011
InternationalSymposiumonSoftwareTestingandAnalysis(ISSTA‚Äô11).Association
for Computing Machinery, New York, NY, USA, 342‚Äì352. https://doi.org/10.
1145/2001420.2001461
[44]T.J.OstrandandM.J.Balcer.1988. Thecategory-partitionmethodforspecifying
and generating functional tests. Commun. ACM 31 (1988), 678‚Äì686.
[45]Burcu Kulahcioglu Ozkan, Rupak Majumdar, Filip Niksic, Mitra Tabaei Befrouei,
and Georg Weissenbacher. 2018. Randomized Testing of Distributed Systems
withProbabilisticGuarantees. Proc.ACMProgram.Lang. 2,OOPSLA,Article160
(Oct. 2018), 28 pages. https://doi.org/10.1145/3276530
559[46]Michael Pedersen and Andrew Phillips. 2009. Towards programming languages
for genetic engineering of living cells. Journal of the Royal Society Interface 6
(April 2009), S437‚ÄìS450. https://doi.org/10.1098/rsif.2008.0516.focus
[47]Andrew Phillips and Luca Cardelli. 2009. A programming language for compos-
able DNA circuits. Journal of the Royal Society Interface 6, 4 (2009), S419‚ÄìS436.
[48]LuluQianandErikWinfree.2011. Scalingupdigitalcircuitcomputationwith
DNA strand displacement cascades. Science332, 6034 (2011), 1196‚Äì1201.
[49]Lulu Qian and Erik Winfree. 2011. A simple DNA gate motif for synthesizing
large-scale circuits. Journal of the Royal Society Interface 8, 62 (2011), 1281‚Äì1297.
https://doi.org/10.1098/rsif.2010.0729
[50]LuluQian,ErikWinfree,andJehoshuaBruck.2011. Neuralnetworkcomputation
with DNA strand displacement cascades. Nature475, 7356 (2011), 368‚Äì372.
[51]Paul W. K. Rothemund. 2006. Folding DNA to create nanoscale shapes and
patterns. Nature440, 7082 (2006), 297‚Äì302.
[52]Christian E. Schafmeister. 2016. CANDO: A Compiled Programming Language
for Computer-Aided Nanomaterial Design and Optimization Based on Clasp
CommonLisp.In Proceedingsofthe9thEuropeanLispSymposiumonEuropean
LispSymposium (Krak√≥w,Poland).EuropeanLispScientificActivitiesAssociation,
9:75‚Äì9:82. https://doi.org/10.5555/3005729.3005738
[53]Nicholas Schiefer and Erik Winfree. 2015. Universal Computation and Opti-
mal Construction in the Chemical Reaction Network-Controlled Tile Assembly
Model.In Proceedingsofthe21stInternationalConferenceonDNAComputingand
Molecular Programming. Springer, 34‚Äì54.
[54]S. Segura, G. Fraser, A. B. Sanchez, and A. Ruiz-Cort√©s. 2016. A Survey on
MetamorphicTesting. IEEETSE 42,9(Sept2016),805‚Äì824. https://doi.org/10.
1109/TSE.2016.2532875
[55]Koushik Sen. 2007. Effective random testing of concurrent programs. In ASE‚Äô07
- 2007 ACM/IEEE International Conference on Automated Software Engineering.
Association for Computing Machinery, New York, NY, USA, 323‚Äì332. https:
//doi.org/10.1145/1321631.1321679[56]Ehud Shapiro and Yaakov Benenson. 2006. Bringing DNA computers to life.
Scientific American 294, 5 (2006), 44‚Äì51.
[57]August Shi, Jonathan Bell, and Darko Marinov. 2019. Mitigating the Effectsof Flaky Tests on Mutation Testing. In Proceedings of the 28th ACM SIGSOFT
InternationalSymposiumonSoftwareTestingandAnalysis (Beijing,China) (ISSTA
2019). Association for Computing Machinery, New York, NY, USA, 112‚Äì122.
https://doi.org/10.1145/3293882.3330568
[58]LloydM.Smith.2010. Nanotechnology:Molecularrobotsonthemove. Nature
465, 7295 (2010), 167‚Äì168.
[59]David Soloveichik, Matthew Cook, and Erik Winfree. 2008. Combining self-
healingandproofreadinginself-assembly. NaturalComputing 7,2(2008),203‚Äì
218. https://doi.org/10.1007/s11047-007-9036-x
[60]DavidSoloveichik,MatthewCook,ErikWinfree,andJehoshuaBruck.2008. Com-
putation with finite stochastic chemical reaction networks. Natural Computing
7, 4 (2008), 615‚Äì633.
[61]David Soloveichik, Georg Seelig, and Erik Winfree. 2009. DNA as a Universal
Substrate for Chemical Kinetics. In DNA Computing (Lecture Notes in Computer
Science, Vol. 5347). 57‚Äì69. https://doi.org/10.1007/978-3-642-03076-5_6
[62]ValerioTerragniandMauroPezz√®.2018. EffectivenessandChallengesinGenerat-ingConcurrentTestsforThread-SafeClasses.In Proceedingsofthe33rdACM/IEEE
InternationalConferenceonAutomatedSoftwareEngineering (Montpellier,France)
(ASE2018).AssociationforComputingMachinery,NewYork,NY,USA,64‚Äì75.
https://doi.org/10.1145/3238147.3238224
[63]Marko Vasic, David Soloveichik, and Sarfraz Khurshid. 2018. CRN++: MolecularProgramming Language. In DNA Computing and Molecular Programming, David
Doty and Hendrik Dietz (Eds.). Springer International Publishing, 1‚Äì18.
[64]DanielWilhelm,JehoshuaBruck,andLuluQian.2018. ProbabilisticswitchingcircuitsinDNA. ProceedingsoftheNationalAcademyofSciences 115(012018),
201715926. https://doi.org/10.1073/pnas.1715926115
560