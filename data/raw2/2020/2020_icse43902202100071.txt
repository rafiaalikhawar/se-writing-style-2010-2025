Fuzzing Symbolic Expressions
Luca Borzacchiello
DIAG Department
Sapienza University of Rome
Rome, Italy
borzacchiello@diag.uniroma1.itEmilio Coppa
DIAG Department
Sapienza University of Rome
Rome, Italy
coppa@diag.uniroma1.itCamil Demetrescu
DIAG Department
Sapienza University of Rome
Rome, Italy
demetres@diag.uniroma1.it
Abstract ‚ÄîRecent years have witnessed a wide array of results
in software testing, exploring different approaches and method-
ologies ranging from fuzzers to symbolic engines, with a full
spectrum of instances in between such as concolic execution
and hybrid fuzzing. A key ingredient of many of these tools is
SatisÔ¨Åability Modulo Theories (SMT) solvers, which are used to
reason over symbolic expressions collected during the analysis. In
this paper, we investigate whether techniques borrowed from the
fuzzing domain can be applied to check whether symbolic formu-
las are satisÔ¨Åable in the context of concolic and hybrid fuzzing
engines, providing a viable alternative to classic SMT solving
techniques. We devise a new approximate solver, FUZZY -SAT,
and show that it is both competitive with and complementary
to state-of-the-art solvers such as Z3 with respect to handling
queries generated by hybrid fuzzers.
Index Terms ‚Äîconcolic execution, fuzzing testing, SMT solver
I. I NTRODUCTION
The automatic analysis of modern software, seeking for high
coverage and bug detection is a complex endeavor. Two popu-
lar approaches have been widely explored in the literature: on
one end of the spectrum, coverage-guided fuzzing starts from
an input seed and applies simple transformations (mutations)
to the input, re-executing the program to be analyzed to
increase the portion of explored code. The approach works
particularly well when the process is guided and informed
by code coverage, with a nearly-native execution time per
explored path [1], [2]. On the other end of the spectrum,
symbolic execution (SE) assigns symbolic values to input
bytes and builds expressions that describe how the program
manipulates them, resorting to satisÔ¨Åability modulo theories
(SMT) [3] solver queries to reason over the program, e.g.,
looking for bug conditions. A popular variant of SE is concolic
execution (CE), which concretely runs one path at a time akin
to a fuzzer, collecting branch conditions along the way [4],
[5]. By systematically negating these conditions, it steers
the analysis to take different paths, aiming to increase code
coverage. The time per executed path is higher than fuzzing
but the aid of a solver allows for a smaller number of runs.
Different ideas have been proposed to improve the ef-
fectiveness of analysis tools by combining ideas from both
fuzzing and SE somewhere in the middle of the spectrum. As
a prominent example, hybrid fuzzing couples a fuzzer with
a symbolic executor to enable the exploration of complex
This paper is supported in part by European Union‚Äôs Horizon 2020 research
and innovation programme (grant agreement No. 830892, project SPARTA).branches [4], [6]. Compared to base fuzzing, this idea adds
a heavy burden due to the lack of scalability of symbolic
execution. It is therefore of paramount importance to speed
up the symbolic part of the exploration.
While there is no clear winner in the software testing
spectrum, tools that hinge upon an SMT solver get a high price
to pay in terms of running time, limiting their throughput.
Contributions. As a main contribution, this paper addresses
the following research question:
can we avoid using accurate but costly SMT solvers,
replacing them with an approximate solver to test
satisÔ¨Åability in the context of software testing?
We attempt to positively answer this question, devising
FUZZY -SAT, an approximate solver that borrows ideas from
the fuzzing domain. Our solver is tailored to the symbolic
expressions generated by concolic engines and can replace
classic SMT solvers in this context. By analyzing the ex-
pressions contained in symbolic queries, F UZZY -SATperforms
informed mutations to possibly generate new valuable inputs.
To demonstrate the potential behind F UZZY -SAT, we present
FUZZOLIC , a new hybrid fuzzer based on QEMU. To show
that F UZZY -SATcan be used in other frameworks, we integrate
it also in QSYM [4]. In our experimental evaluation:
1) we compare F UZZY -SATto the SMT solver Z3 [7] and
the approximate solver JFS [8] on queries issued by
QSYM, which we use as a mature baseline. Our results
suggest that F UZZY -SATcan provide a nice tradeoff
between speed and solving effectiveness, i.e., the number
of queries found satisÔ¨Åable by a solver.
2) we show that F UZZY -SATallows Q SYM to Ô¨Ånd more
bugs on the LA V A-M dataset [9] compared to Z3.
3) we evaluate F UZZOLIC on 12 real-world programs
against state-of-the-art fuzzers including AFL++ [2],
ECLIPSER [10], and Q SYM, showing that it can reach
higher code coverage than the competitors.
To facilitate extensions of our approach, we make our
contributions available at:
https://season-lab.github.io/fuzzolic/
II. B ACKGROUND
FUZZY -SATtakes inspiration from two popular software
testing techniques [11]: symbolic execution [12] and coverage-
7112021 IEEE/ACM 43rd International Conference on Software Engineering (ICSE)
1558-1225/21/$31.00 ¬©2021 IEEE
DOI 10.1109/ICSE43902.2021.00071
based grey-box fuzzing [13]. We now review the inner-
workings of these two approaches, focusing on recent works
that are tightly related to the ideas explored in this paper.
Symbolic execution. The key idea behind this technique
is to execute a program over symbolic , rather than concrete ,
inputs. Each symbolic input can, for instance, represent a
byte read by the program under test from an input Ô¨Åle and
initially evaluate to any value admissible for its data type
(e.g., [0;255] for an unsigned byte). SE builds expressions
to describe how the program manipulates the symbolic inputs,
resorting to SMT solver queries to reason over the program
state. In particular, when a branch condition bis met during
the exploration, SE checks using the solver whether both
directions can be taken by the program for some values of the
inputs, forking the execution state in case of a positive answer.
When forking, SE updates the list of path constraints that
must hold true in each state: bis added in the state for the true
branch, while:bis added to the state for the false branch. At
any time, the symbolic executor can generate concrete inputs,
able to reproduce the program execution related to one state,
by asking the solver an assignment for the inputs given .
SE can be performed on binary code (e.g., A NGR [14],
S2E [15]) or on more high-level representations of a program
(e.g., LLVM IR in K LEE [16], Java bytecode in SPF [17]).
Besides software testing, SE has been extensively used during
the last decade in the context of cybersecurity [18]‚Äì[20].
Concolic execution. A twist of SE designed with scalability
in mind is concolic execution [21], which given a concrete
inputi, analyzes symbolically only the execution path taken
by the program when running over i. To generate new inputs,
the concolic executor can query an SMT solver using :b^,
wherebis a branch condition taken by the program in the
current path while is the set of constraints from the branches
previously met along the path. A beneÔ¨Åt from this approach
is that the concolic executor only needs to query the solver
for one of the two branch directions, as the other one is taken
by the path under analysis. Additionally, if the program is
actually executed concretely in parallel during the analysis, the
concolic engine can at any time trade accuracy for scalability,
by concretizing some of the input bytes and make progress
in the execution using the concrete state. For instance, when
analyzing a complex library function, the concolic engine
may concretize the arguments for the function and execute
it concretely, without issuing any query or making more
complex due to the library code but possibly giving up on
some alternative inputs due to the performed concretizations.
A downside of most concolic executors is that they restart
from scratch for each input driving the exploration, thus
repeating analysis work across different runs. To mitigate this
problem, Q SYM [4] has proposed a concolic executor built
through dynamic binary instrumentation (DBI) that cuts down
the time spent for running the program by maintaining only the
symbolic state and ofÔ¨Çoads completely the concrete state to the
native CPU. Additionally, it simpliÔ¨Åes the symbolic state by
concretizing symbolic addresses [22], [23] but also generates
inputs that can lead the program to access alternative mem-ory locations. More recently, S YMCC [5] has improved the
design of Q SYM by proposing a source-based instrumentation
approach that further reduces the emulation time.
Approximate constraint solving. Many queries generated
by concolic executors are either unsatisÔ¨Åable or cannot be
solved within a limited amount of time [4]. This often is due
to the complex constraints contained in , which can impact
the reasoning time even when the negated branch condition is
quite simple. For this reason, Q SYM has introduced optimistic
solving that, in case of failure over :b^due to unsatness
or solving timeout, submits to the solver an additional query
containing only:b: by patching the input i(used to drive the
exploration) in a way that makes :bsatisÔ¨Åed, the executor is
often able to generate valuable inputs for a program.
A different direction is instead taken by JFS [8], which
builds on the experimental observation that SMT solvers can
struggle on queries that involve Ô¨Çoating-point values. JFS
thus proposes to turn the query into a program, which is
then analyzed using coverage-based grey-box fuzzing. More
precisely, the constructed program has a point that is reachable
if and only if the program‚Äôs input satisÔ¨Åes the original query.
The authors show that JFS is quite effective on symbolic
expressions involving Ô¨Çoating-point values but it struggles on
integer values when compared to traditional SMT solvers.
Two very recent works, P ANGOLIN [24] and T RIDENT [25],
devise techniques to reduce the solving time in CE. P ANGOLIN
transforms constraints into a polyhedral path abstraction ,
modeling the solution space as a polyhedron and using,
e.g., sampling to Ô¨Ånd assignments. T RIDENT instead exploits
interval analysis to reduce the solution space in the SMT
solver. Their implementations have not been released yet.
Coverage-based grey-box fuzzing. An orthogonal ap-
proach to SE is coverage-based grey-box fuzzing (CGF).
Given an input queue q(initialized with some input seeds) and
a programp, CGF picks an input ifromq, randomly mutates
some of its bytes to generate i0and then runs poveri0: if new
code is executed (covered) by pcompared to previous runs on
other inputs, then CGF deems the input interesting and adds
it toq. This process is then repeated endlessly, looking for
crashes and other errors during the program executions.
American Fuzzy Lop (AFL) [1] is the most prominent
example of CGF. To track the coverage, it can dynamically
instrument at runtime a binary or add source-based instru-
mentation at compilation time. The fuzzing process for each
input is split into two main stages. In the Ô¨Årst one, AFL
scans the input and deterministically applies for each position
a set of mutations, testing the effect of each mutation on
the program execution in isolation. In the second stage, AFL
instead performs several mutations in sequence, i.e., stacking
them, over the input, non deterministically choosing which
mutations to apply and at which positions. The mutations in
the two stages involve simple and fast to apply transformations
such as Ô¨Çipping bits, adding or subtracting constants, removing
bytes, combining different inputs, and several others [1].
Hybrid fuzzing. Although CGF fuzzers have found thou-
712sands of bugs in the last years [26], [27], there are still
scenarios where their mutation strategy is not effective. For
instance, they may struggle on checks against magic num-
bers, whose value is unlikely to be generated with random
mutations. As these checks may appear early in the execution,
fuzzers may soon get stuck and stop producing interesting
inputs. For this reason, a few works have explored combi-
nations of fuzzing with symbolic execution, proposing hybrid
fuzzing . DRILLER [28] alternates AFL and A NGR, temporarily
switching to the latter when the former is unable to generate
new interesting inputs for a speciÔ¨Åc budget of time. Q SYM
proposes instead to run a concolic executor in parallel with
AFL, allowing the two components to share their input queues
and continuously beneÔ¨Åt from the work done by each other.
Recent improvements in coverage-guided fuzzing. During
the last years, a large body of works has extended CGF, trying
to make it more effective without resorting to heavyweight
analyses such as symbolic execution. L AF-INTEL [29] splits
multi-byte checks into single-byte comparisons, helping the
fuzzer track the intermediate progress when reasoning on
a branch condition. V UZZER [30] integrates dynamic taint
analysis (DTA) [31] into the fuzzer to identify which bytes
inÔ¨Çuence the operands in a branch condition, allowing it to
bypass, e.g., checks on magic numbers. A NGORA [32] further
improves this idea by performing multi-byte DTA and using
gradient descent to effectively mutate the tainted input bytes.
As DTA can still put a high burden on the fuzzing strategy,
some works have recently explored lightweight approximate
analyses that can replace it. R EDQUEEN [33] introduces the
concept of input-to-state correspondence , which captures the
idea that input bytes often Ô¨Çow directly, or after a few simple
encodings (e.g., byte swapping), into comparison operands
during the program execution. To detect this kind of input
dependency, R EDQUEEN uses colorization that inserts random
bytes into the input and then checks whether some of these
bytes appear, as is or after few simple transformations, in the
comparison operands when running the program. Input-to-state
relations can be exploited to devise effective mutations and
bypass several kinds of validation checks.
WEIZZ [34] explores instead a different approach that Ô¨Çips
one bit at a time on the entire input, checking after each
bit Ô¨Çip which comparison operands have changed during the
program execution, possibly suggesting a dependency between
the altered bit and the affected branch conditions. While more
accurate than colorization, this approach may incur a large
overhead, especially in presence of large inputs. Nonetheless,
WEIZZ is willing to pay this price as the technique allows
it to also heuristically locate Ô¨Åelds and chunks within an
input, supporting smart mutations [26] to effectively fuzz
applications processing structured input formats.
SLF [35] exploits a bit Ô¨Çipping strategy similar to W EIZZ
to generate valid inputs for an application even when no
meaningful seeds are initially available for it. Thanks to the
input dependency analysis, SLF can identify Ô¨Åelds into the
input and then resort to a gradient-based multi-goal searchheuristic to deal with interdependent checks in the program.
ECLIPSER [10] identiÔ¨Åes a dependency between an input
byteikand a branch condition bwhenever the program
decision on bis affected when running the program on
inputs containing different values for ik. ECLIPSER builds
approximate path constraints by modeling each branch con-
dition met along the program execution as an interval. In
particular, given a branch b, it generates a new input using
a strategy similar to concolic execution, by looking for input
values that satisfy the interval from :bas well as any other
interval from previous branches met along a path. To Ô¨Ånd
input assignments, E CLIPSER does not use an SMT solver but
resorts to lightweight techniques that work well in presence
of intervals generated by linear or monotonic functions.
III. A PPROACH
Recent coverage-guided fuzzers perform input mutations
based of a knowledge on the program behavior that goes be-
yond the simple code coverage. Concolic executors by design
build an accurate description of the program behavior, i.e.,
symbolic expressions, but outsource completely the reasoning
to a powerful but expensive SMT solver, which is typically
treated as a black box. In this paper, we explore the idea that
a concolic executor can learn from the symbolic expressions
that it has built and use the acquired knowledge to apply
simple but fast input transformations, possibly solving queries
without resorting to an SMT solver. The key insight is that
given a query:b^, the inputithat has driven the concolic
exploration satisÔ¨Åes by design . Hence, we propose to build
using input mutations a new test case i0that satisÔ¨Åes:band
is similar enough to iso thatremains satisÔ¨Åed by i0. In the
remainder of this section, we present the design of F UZZY -
SAT, an approximate solver that explores this direction by
borrowing ideas from the fuzzing domain to efÔ¨Åciently solve
queries generated by concolic execution.
A. Reasoning primitives for concolic execution
While SMT solvers typically offer a rich set of solving
primitives, enabling reasoning on formulas generated from
quite different application contexts, concolic executors such as
QSYM are instead built on top of a few but essential primitives.
In this paper, we focus on these primitives without claiming
that F UZZY -SATcan replace a full-Ô¨Çedged SMT solver in a
general context. F UZZY -SATexposes the following primitives:
SOLVE (e;;i;opt ): returns an assignment for the sym-
bolic inputs in e^such that the expression e^
is satisÔ¨Åable. The Ô¨Çag optindicates whether optimistic
solving should be performed in case of failure. This
primitive is used by concolic engines when negating a
branch condition b, hencee=:b.
SOLVE MAX(e;;i )(resp. S OLVE MIN(e;;i )): returns
an assignment that maximizes (resp. minimizes) ewhile
makingsatisÔ¨Åable. Concolic executors use these prim-
itives before concretizing a symbolic memory address e
to keep the exploration scalable. These functions are thus
713Analysis 
Input Groups 
Input-to-State 
Range Intervals Constants 
Conflicting Exprs Reasoning 
Expression 
Metadata 
fetch 
& 
update Input-to-State Mutation Engine 
Range Brute Force 
Gradient Descent 
AFL Deterministic 
Multi-Goal Engine 
find conflicting expr e‚Äô if not 
 SAT fuzz
e‚Äô
fetch Constants 
AFL Non-Determ. Inputs Fig. 1. Internal architecture of F UZZY -SAT.
used to generate alternative inputs that steer the program
to read/write at boundary addresses.
SOLVE ALL(e;;i ): combines S OLVE MINand S OLVE -
MAX, yielding intermediate assignments identiÔ¨Åed during
the reasoning process as well. This primitive is valuable
in the presence of symbolic memory addresses accessing
a jump table or when the instruction pointer becomes
symbolic during the exploration.
Two main aspects differentiate these primitives in F UZZY -
SATwith respect to their counterpart from an SMT solver.
First, F UZZY -SATis an approximate solver and thus it
cannot guarantee that no valid assignment exists in case
of failure of S OLVE , i.e., F UZZY -SATcannot prove that an
expressione^is unsatisÔ¨Åable. Similarly, given an expression
e, FUZZY -SATmay fail to Ô¨Ånd its global minimum/maximum
value or to enumerate assignments for all its possible values.
Another crucial difference is that F UZZY -SATrequires that
the concolic engine provides the input test case ithat was
used to steer the symbolic exploration of the program under
test. This is essential as F UZZY -SATbuilds assignments by
mutating the test case ibased on facts that are learned when
analyzingeand. Given an assignment areturned by F UZZY -
SAT, a new input test case i0can be built by patching the bytes
inithat are assigned by a.
B. Overview
Architecture. To support the primitives presented in Sec-
tion III-A, the architecture of F UZZY -SAT(Figure 1) has been
structured around three main building blocks: the analysis
stage , the expression metadata , and the reasoning stage .
The analysis stage (¬ß III-C) is designed to analyze symbolic
expressions, extracting valuable knowledge to use during the
reasoning stage. It starts by identifying which input bytes
ikfrom the input iare involved in an expression and how
they are grouped. It detects input-to-state relations (¬ß II) and
collects constants appearing in the expression for later use in
the mutation phase. Expressions that constrain the interval of
admissible values for a set of inputs, dubbed range constraints ,
such asi0<10, are identiÔ¨Åed to keep track of the range
intervals over the symbolic inputs. Finally, this stage detects
whether the current expression shares input bytes with other
expressions previously processed by the analysis component,
possibly pinpointing conÔ¨Çicts that may result when mutating
these bytes during the reasoning stage.
The expression metadata maintains the knowledge of
FUZZY -SATon the expressions processed by the analysisfunction SOLVE (e,, i, opt ):
1M ANALYZE (, M)
2M ANALYZE (e, M)
3a, SA MUTATE (e,, i, M)
4ifa is not NULL then return a
5a PICKBESTASSIGNMENT (, SA)
6ifa is not NULL then
7 M0 FIXINPUT BYTES (a, M)
8 CC GETCONFLICTING EXPRESSIONS (e,, M0)
9 fore02CCdo
10 a0, SA MUTATE (e0,, i, M0)
11 ifa0is not NULL then return a0
12 a0 PICKBESTASSIGNMENT (, SA)
13 ifa0is NULL then break
14 a a0
15 M0 FIXINPUT BYTES (a, M0)
16 ifoptthen
17 ifa is NULL then a MUTATE OPT(e,, i, M)
18 return a
19 return NULL
Algorithm 1: SOLVE implementation of F UZZY -SAT:
analysis stage in light gray, reasoning stage in dark gray
(initial mutations due to eat lines 3-4, multi-goal strategy
at lines 5-15, and optimistic solving at lines 16-18).
stage over time. Internally, it is implemented as a set of
data structures optimized for fast lookup of different kinds of
properties related to an expression (and its subexpressions). It
is updated by the analysis stage and queried by both stages.
Finally, the reasoning stage is where F UZZY -SATexploits
the knowledge over the expressions to effectively fuzz the
input test case and possibly generate valid assignments. To
reach this goal, a mutation engine (¬ß III-D) is used to perform
a set of transformations over the input bytes involved in an
expressionelooking for an assignment that satisÔ¨Åes eand
(SOLVE ) or maximizes/minimizes ewhile satisfying (other
primitives). When this step Ô¨Ånds assignments for e, but none
of them satisÔ¨Åes , then F UZZY -SATperforms a multi-goal
strategy, which is not limited to changing the input bytes
involved in e, but attempts to alter other input bytes that are
involved in conÔ¨Çicting expressions present in .
Implementing the reasoning primitives. Algorithm 1
shows the interplay of these three components in F UZZY -SAT
when considering the primitive S OLVE . Lines 1 and 2 execute
the analysis stage by invoking the A NALYZE function on 
ande, respectively. A NALYZE updates the expression metadata
M, adding any information that could be valuable during
the reasoning stage. Since concolic engines would typically
call S OLVE several times during the symbolic exploration,
providing each time a that is the conjunction of branch
conditions met along the path and which have been already
analyzed by F UZZY -SATin previous runs of S OLVE , the call
at line 1 does not lead F UZZY -SATto perform any work in
most scenarios as the expression metadata M already has a
cache containing knowledge about expressions in .
Lines 3-18 instead comprise the reasoning stage and can be
divided into three main phases. First, the M UTATE function
is called at line 3 to run the mutation engine, restricting
the transformations on input bytes that are involved in the
expressione. When M UTATE Ô¨Ånds an assignment athat
714satisÔ¨Åes both eand, SOLVE returns it at line 4 without any
further work. On the other hand, when ais invalid but some
assignments SA found by M UTATE make at least esatisÔ¨Åable,
then S OLVE starts the multi-goal phase (lines 5-15). To this
end, F UZZY -SATuses function P ICKBESTASSIGNMENT to
select the best candidate assignment afrom SA1and then Ô¨Åxes
the input bytes assigned by ausing function F IXINPUT BYTES
to prevent further calls of M UTATE from altering these bytes.
It then reruns the mutation engine considering an expression e0
which has been marked as in conÔ¨Çict with eduring the analysis
stage. This process is repeated as long as three conditions hold:
(a)e^is not satisÔ¨Åed (line 11), (b) M UTATE returns at least
one assignment in SA for e0(line 13), and (c) there is still a
conÔ¨Çicting expression left to consider (condition at line 9).
The multi-goal strategy in F UZZY -SATemploys a greedy
approach without ever performing backtrack (e.g., reverting
the effects of F IXINPUT BYTES in case of failure) as it trades
accuracy for scalability. Indeed, F UZZY -SATbuilds on the
intuition that by altering a fewbytes from the input test case
i, it is possible in several cases to generate valid assignments.
Additionally, since many queries generated by a concolic
engine are unsatisÔ¨Åable, increasing the complexity of this
strategy would impose a large burden on F UZZY -SAT.
The last phase of S OLVE (lines 16-18) has been devised to
support optimistic solving in F UZZY -SAT. When the Boolean
optis true, F UZZY -SATreturns the last candidate assignment
found by the mutation engine, which by design satisÔ¨Åes the
expressione. However, since the previous calls to the mutation
engine in S OLVE may have failed to Ô¨Ånd an assignment a
foredue to the constraints resulting from the analysis of
expressions from , FUZZY -SATas last resort uses a variant of
the function M UTATE , called M UTATE OPT, that ignores these
constraints and exploits only knowledge resulting from ewhen
performing transformations over the input bytes.
The other reasoning primitives (S OLVE MIN, SOLVE MAX,
and S OLVE ALL, respectively) follow a workÔ¨Çow similar to
SOLVE and we do not present their pseudocode due to lack
of space. In the remainder of this section, we focus on the
internal details of functions A NALYZE (¬ß III-C) and M UTATE
(¬ß III-D), which are crucial core elements of F UZZY -SAT.
C. Analyzing symbolic expressions
We now present the details of the main analyses integrated
into the A NALYZE function, which incrementally build the
knowledge of F UZZY -SATover an expression e.
Detecting inputs and input groups. The Ô¨Årst analysis iden-
tiÔ¨Åes which input bytes ikare involved in an expression and
evaluates how these bytes are grouped. In particular, F UZZY -
SATchecks whether the expression can be regarded as an input
group , i.e., the expression is equivalent to a concatenation ( + +)
of input bytes or constants that never mixtheir bits. Single byte
expressions are also detected as input groups.
1We pick anathat maximizes the number of expressions satisÔ¨Åed in .Examples:
expressioni1+ +i0contains inputs i0andi1, and it
is an input group since the bits from these bytes do
not mix with each other but are just appended;
expression 0+ +i0contains input i0and it is a 1-byte
input group as it is a zero-extend operation on i0;
expressioni1+i0contains inputs i0andi1, but it
is not an input group as bits from i0are mixed, i.e.,
added, with bits from i1;
expression (0 + +i0) + (i18)contains inputs i0
andi1, and it is an input group as the expression is
equivalent to i1+ +i0, which is an input group.
Given an expression e, FUZZY -SATstores in the expression
metadata M the list of inputs involved in e, whethereis an
input group, and the list of input groups contained inewhen
recursively considering subexpressions of e.
Detecting uniquely deÔ¨Åned inputs. A crucial information
about an input byte is knowing whether its value is Ô¨Åxed to
a single value, dubbed uniquely deÔ¨Åned in our terminology,
due to one equality constraint that involves it. Indeed, it is not
productive to fuzz input bytes whose value is Ô¨Åxed to a single
constant. Given an expression e, then:
ifeis an equality constraint and one of its operands is
an input group, or contains exactly only one input group,
while the other operand is a constant, then M is updated
to reÔ¨Çect that the bytes in the group will be uniquely
deÔ¨Åned due to eifeis later added to ;
an input in eis marked as uniquely deÔ¨Åned whenever a
constraint from marks it as uniquely deÔ¨Åned;
the input group in e(if any) is marked as uniquely deÔ¨Åned
whenever the inputs forming it are all uniquely deÔ¨Åned
due to constraints in ;
Example. The expression i1+ +i0== 0xABCD makes
FUZZY -SATmark inputs i0andi1as uniquely deÔ¨Åned.
If this expression is later added to , theni0andi1
will be considered uniquely deÔ¨Åned in other expressions,
disabling fuzzing on their values.
Detecting input-to-state branch conditions. This analysis
checks whether econtains at least one operand that has input-
to-state correspondence (¬ß II). In F UZZY -SATwe use the
following conditions to detect this kind of branch conditions:
(a)ematches the pattern e0opcmpe00, whereopcmp is a
comparison operator (e.g., ,==, etc.) and (b) one operand
(e0ore00) is an input group. When eis a Boolean negation,
FUZZY -SATrecursively analyzes the subexpression.
Example. The expression 10i1+ +i0is an input-to-
state branch condition as is a comparison operator and
i1+ +i0is an input group.
Detecting interesting constants. FUZZY -SATchecks the ex-
pressione, looking for constants that could be valuable during
the reasoning stage, dynamically building a dictionary to
715use during the transformations. When speciÔ¨Åc patterns are
detected, F UZZY -SATgenerates variants of the constants based
on the semantics of the computation performed by e.
Example. When analyzing i10xF0 == 0x0F , FUZZY -
SATcollects the constants 0xF0 ,0x0F , and 0xFF (i.e.,
0xF00x0F ) since the computation is an exclusive or.
The patterns used to generate interesting constants can be
seen as a relaxation of the concept of input-to-state relations.
Detecting range constraints. FUZZY -SATchecks whether
eis a range constraint , i.e., a constraint that sets a lower
bound or an upper bound on the values that are admissible
for the input group in e(if any). For instance, F UZZY -SAT
looks for constraints matching the pattern e0opcmpe00where
e0is an input group, opcmp is a comparison operator, and
e00is a constant value. Other equivalent patterns, such as
(e0 e00)opcmpe000wheree0is an input group while e00and
e000are constants, are detected as range constraints as well.
By considering bounds resulting from expressions in 
and not only from e, FUZZY -SATcan compute reÔ¨Åned range
intervals for the input groups contained in an expression. To
compactly and efÔ¨Åciently maintain these intervals, F UZZY -SAT
uses wrapped intervals [36] which can transparently deal with
both signed and unsigned comparison operators.
Examples.
given the expressions i1+ +i0>10andi1+ +i030,
FUZZY -SATcomputes the range interval [11;30]for
the input group composed by i0andi1;
given the expression (i1+ +i0)+0xAAAA <unsigned
0xBBBB , F UZZY -SAT computes the intervals
[0;0x1110][[0x5556;0xFFFF] fori0andi1, cor-
rectly modeling the wrap-around that may result in
the two‚Äôs complement representation.
Detecting conÔ¨Çicting expressions. The last analysis is devised
to identify which expressions from may conÔ¨Çict withewhen
assigning some of its input bytes. In particular, F UZZY -SAT
marks an expression e0as in conÔ¨Çict with ewhenever the set
of input bytes in e0is not disjoint with the set from e.
Example. The expression i1+i0>10is in conÔ¨Çict with
the expression i1+i2<20as they both contain the input
bytei1. Hence, fuzzing the Ô¨Årst expression may negatively
affect the second expression.
Computing the set of conÔ¨Çicting expressions is essential for
performing the multi-goal strategy during the reasoning stage.
D. Fuzzing symbolic expressions
The core step during the reasoning stage of F UZZY -SATis
the execution of the function M UTATE , which attempts to Ô¨Ånd
a valid assignment a. To reach this goal, M UTATE performs a
sequence of mutations over the input test case i, returning
as soon as a valid assignment is found by one of these
transformations. When a mutation generates an assignment
that satisÔ¨Åed ebut not, then M UTATE saves it into a setof candidate assignment SA, which could be valuable later
on during the multi-goal strategy (¬ß III-B). In some cases, a
transformation can determine that there exists a contradiction
betweeneand the conditions in , leading M UTATE to an early
termination. Additionally, when M UTATE builds a candidate
assignment a, it checks that ais consistent with the range
intervals known for the modiÔ¨Åed bytes, discarding ain case
of failure and avoiding the (possibly expensive) check over .
We now review in detail the input transformations performed
by the function M UTATE .
Fuzzing input-to-state relations. When an expression eis an
input-to-state branch condition (¬ß III-C), F UZZY -SATtries to
replace the value from one operand e0into the bytes composing
the input group from the other (input-to-state) operand e00. If
e0is not constant, then F UZZY -SATgets its concrete value by
evaluatinge0on the test case i. Whene0is constant and the
relation is an equality, if the assignment does not satisfy ,
then F UZZY -SATdeems the query unsatisÔ¨Åable. Conversely,
when the comparison operator is not an equality, F UZZY -
SATtests variants of the value from e0, e.g., by adding or
subtracting one to it, in the same spirit as done by R EDQUEEN .
Example. Giveni1+ +i0== 0xABCD , FUZZY -SAT
builds the assignment fi0 0xCD;i1 0xABg. If the
range interval over i0is[0xDD;0xFF] due to constraints
from, then the assignment can be discarded without
testing, deeming the query unsatisÔ¨Åable (but keeping
the assignment in SA in case of optimistic solving).
Range interval brute force. When a range interval is known
for an input group contained an expression e, FUZZY -SAT
can use this information to perform brute force on its value
and possibly Ô¨Ånd a valid assignment. In particular, when an
expression contains a single input group and its range interval
is less than 2048, F UZZY -SATbuilds assignments that brute
force all the possible values assignable to the group. If no
valid assignment is found, then the query can be deemed
unsatisÔ¨Åable. If the interval is larger than 2048, then F UZZY -
SATonly tests the minimum and maximum value of the
interval. To make this input transformation less conservative,
FUZZY -SATruns it even when econtains at least one input
group whose interval is less than2512.
Example. Given the expression (i1+ +i0)0xABCD ==
0xCAFE and the range interval [1;9](built due to con-
straints from ) on the group gwithi0andi1, then
FUZZY -SATbuilds assignments for g2[1;9], deeming
the query unsatisÔ¨Åable if none of them satisÔ¨Åes e^.
Trying interesting constants. For each constant ccollected
by A NALYZE when considering the expression eand for each
input group gcontained in e, FUZZY -SATtries to set the bytes
fromgto the value c. Since constants are collected through
relaxed patterns, F UZZY -SATtests different encodings (e.g.,
little-endian, big-endian, zero-extension, etc.) for each constant
to maximize the chances of Ô¨Ånding a valid assignment.
2We pick the input group with the minimum range interval.
716Example. Given the expression (i1+ +i0)100 == 200
and assuming that A NALYZE has collected the constants
f2;99;100;101;199;200;201gwhere 2was obtained as
200=100, while other constants are obtained from 100and
200, then F UZZY -SATwould Ô¨Ånd a valid assignment when
testingfi0 2;i1 0g(c= 2, little-endian encoding).
Gradient descent. Given an expression e, FUZZY -SATtries
to reduce the problem of Ô¨Ånding a valid assignment for it
to a minimization (or maximization) problem. This is valu-
able not only in the context of S OLVE MIN, SOLVE MAX, or
SOLVE ALLwhere this idea seems natural, but also when
reasoning over the branch condition ein S OLVE . Indeed,
any expression of the form e0opcmpe00, whereopcmp is a
comparison operator, can be transformed into an expression
famenable to minimization to Ô¨Ånd a valid assignment [32],
e.g.,e0<e00can be transformed3intof <0withf=e0 e00.
The search algorithm implemented in F UZZY -SATis in-
spired by A NGORA [32] and it is based on gradient descent.
Although this iterative approach may fail to Ô¨Ånd a global
minimum for f, a local minimum can be often good enough in
the context of concolic execution as we do not always really
need the global minimum but just an assignment that satisÔ¨Åes
the condition, e.g., given i0<1, the assignmentfi0 0x0g
satisÔ¨Åes the condition even if the global minimum for i0 1is
given byfi0 0x81g. For this reason, F UZZY -SATin S OLVE
can stop the gradient descent as soon an assignment satisÔ¨Åes
botheand. When the input groups from ehave disjoint
bytes, F UZZY -SATcomputes the gradient considering groups
of bytes, instead of computing it for each distinct byte, as this
makes the descent more effective. In fact, reasoning on i0and
i1as a single value is more appropriate when these bytes are
used in a two-byte operation since gradient descent may fail
when these bytes are considered independently.
Example. Given the expression (i0+ +i1) 10>(i2+ +
i3) 5and a zero-Ô¨Ålled input test case, then F UZZY -SAT
transforms the expression into ((i2+ +i3) 5) ((i1+ +
i0) 10)<0, computes the gradients over the input
groups (i1+ +i0)and(i2+ +i3), Ô¨Ånding the assignment
fi0 0x80;i1 0x06;i2 0x84;i3 0x01gwhich
makes the condition satisÔ¨Åed as (0x80 + + 0x06) 10 =
32764> 31748 = (0x84 + + 0x01)  5.
Deterministic and non-deterministic mutations. These two
sets of input transformations are inspired by the two mutation
stages from AFL (¬ß II). Deterministic mutations include bit
or byte Ô¨Çips, replacing bytes with interesting well-known
constants (e.g., MAX_INT ), adding or subtracting small con-
stants from some input bytes. Non-deterministic mutations
instead involve also transformations such as Ô¨Çipping of random
bits inside randomly chosen input bytes, setting randomly
chosen input bytes to randomly chosen interesting constants,
subtracting or adding random values to randomly chosen bytes,
and several others [1]. The main differences with respect to
3For the sake of simplicity, we ignore in our examples the wrap-around.AFL are: (a) mutations are applied only on the input bytes
involved in the expression e, (b) multi-byte mutations are
considered only in the presence of multi-byte input groups,
(c) for non-deterministic mutations, F UZZY -SATgenerates
kdistinct assignments, with kequal to maxf100;ni20g
whereniis the number of inputs involved in e, and for each
assignment it applies a sequence (or stack) of nmutations
(n= 1(1 +rand (0;7))as in AFL).
E. Discussion
Similarly to fuzzers using dynamic taint analysis, F UZZY -
SATrestricts mutations over the bytes that affect branch
conditions during the program execution. However, it does not
only understand which bytes inÔ¨Çuence the branch conditions
but also reasons on how they affect them, possibly devising
more effective mutations.
FUZZY -SAT shares traits with A NGORA , SLF, and
ECLIPSER by integrating mutations based on gradient descent,
a multi-goal strategy, and range intervals, respectively. Nev-
ertheless, these techniques have been revisited and reÔ¨Åned to
work over symbolic constraints, which accurately describe the
program state and are not available to these fuzzers.
FUZZY -SATexposes primitives that are needed by concolic
executors and that are typically offered by SMT solvers but
it implements them in a fundamentally different way inspired
by fuzzing techniques, trading accuracy for scalability.
Finally, F UZZY -SATshares the same spirit of JFS but takes
a rather different approach. While JFS builds a bridge between
symbolic execution and fuzzers by turning expressions into a
program to fuzz, F UZZY -SATis designed to merge these two
worlds, possibly devising informed mutations that are driven
by the knowledge acquired by analyzing the expressions.
IV. I MPLEMENTATION
FUZZY -SATis written in C (10K LoC) and evaluates queries
in the language used by the Z3 Theorem Prover [7]. To
efÔ¨Åciently evaluate an expression given a concrete assignment
FUZZY -SATuses a fork of Z3 where the Z3_model_eval
function has been optimized to deal with full concrete models.
FUZZOLIC is a new concolic executor based on QEMU
4.0 (user-mode), written in C (20K LoC), that currently
supports Linux x86 64 binaries. Its design overcomes one
of the major problems affecting Q SYM: FUZZOLIC decouples
the tracer component, which builds the symbolic expressions,
from the solving component, which reasons over them. This
is required as recent releases of most DBI frameworks, such
as PIN [37] on which Q SYM is based on, do not allow an
analysis tool to use external libraries (as the Z3 solver in
case of Q SYM) when they may produce side effects on the
program under analysis [38]. This implementation constraint
has made it very complex to port QSYM to newer releases
of PIN, limiting its compatibility with recent software and
hardware conÔ¨Ågurations4. To overcome this issue, the two
components are executed into distinct processes in F UZZOLIC .
4QSYM has been recently removed from the Google project FuzzBench
due to its instability on recent Linux releases [39].
717In particular, the tracer runs under QEMU and generates
symbolic expressions in a compact language, storing them into
a shared memory that is also attached to the memory space
of the solving component, which in turn submits queries to
FUZZY -SATto generate alternative inputs. Similarly to Q SYM,
FUZZOLIC runs in parallel with two coverage-guided fuzzers.
V. E VALUATION
In this section we address the following research questions:
RQ1 : How effective and efÔ¨Åcient is F UZZY -SATat solv-
ing queries generated by concolic executors?
RQ2 : How do different kinds of mutations help F UZZY -
SATin solving queries?
RQ3 : How does F UZZOLIC with F UZZY -SATcompare
to state-of-the-art fuzzers on real-world programs?
Benchmarks. Throughout our evaluation, we consider the
following 12 programs: advmng 2.00, bloaty rev 7c6fc ,
bsdtar rev. f3b1f , djpeg v9d, jhead 3.00-5, libpng 1.6.37,
lodepng-decode rev. 5a0dba , objdump 2.34, optipng 0.7.6,
readelf 2.34, tcpdump 4.9.3 (libpcap 1.9.1), and tiff2pdf 4.1.0.
These targets have been heavily fuzzed by the community [27],
and used in previous evaluations of state-of-the-art fuzzers [4],
[5], [10], [33], [34]. As seeds, we use the AFL test cases [1],
or when missing, minimal syntactically valid Ô¨Åles [40].
Experimental setup. We ran our tests in a Docker container
based on the Ubuntu 18.04 image, using a server with two Intel
Xeon E5-4610v2@2.30 GHz CPUs and 256 GB of RAM.
A. RQ1: Solving effectiveness of FUZZY -SAT
To evaluate how effective and efÔ¨Åcient is F UZZY -SATat
solving queries generated by concolic execution, we discuss
an experimental comparison of F UZZY -SATagainst the SMT
solver Z3 and the approximate solver JFS. We Ô¨Årst focus
on S OLVE queries, collected by running the 12 programs
under QSYM on their initial seed with optimistic solving
disabled, comparing the solving time and the number of
queries successfully proved as satisÔ¨Åable when using these
three solvers. Then, we analyze the performance of Q SYM at
Ô¨Ånding bugs on the LA V A-M dataset [9] when using F UZZY -
SATwith respect to when using Z3, implicitly considering the
impact also of other reasoning primitives (e.g., S OLVE MAX)
and from enabling optimistic solving in S OLVE . In these
experiments, we consider Q SYM instead of F UZZOLIC to avoid
any bias resulting from its expression generation phase that
could beneÔ¨Åt F UZZY -SATand impair the other solvers.
FUZZY -SATvs Z3. Table I provides an overview of the
comparison between F UZZY -SATand Z3 on the queries gen-
erated when running the 12 benchmarks.
The Ô¨Årst interesting insight is that only a small subset of
the queries, i.e., less than 10%, has been proved satisÔ¨Åable
(even when considering together both solvers). The remaining
queries are either proved unsatisÔ¨Åable or make the solvers run
out of the time budget (10 seconds for Z3, as in Q SYM).
The second insight is that, when focusing on the queries
that are satisÔ¨Åable, F UZZY -SATis able to solve the majorityTABLE I
NUMBER OF QUERIES PROVED SATISFIABLE BY FUZZY -SAT W .R.T. Z3
(TIMEOUT 10SECS ). N UMBERS SHOW THE AVERAGE OF 5RUNS . THE
SPEEDUP CONSIDERS THE SOLVING TIME ON THE FULL SET OF QUERIES .
PROGRAM# #QUERIES PROVED SAT BY #SAT F UZZY -SAT SOLV. TIME
QUERIES BOTH Z3 FUZZY-SAT DIV.BY# SAT Z3 SPEEDUP
advmng 1481 236.7 +7.0 +64.3 1.24 17.1
bloaty 2085 95.0 +7.0 +1.0 0.94 47.8
bsdtar 325 124.0 +6.0 0 0.95 1.8
djpeg 1245 189.0 +6.0 +11.0 1.03 34.3
jhead 405 88.0 0 0 1.00 21.7
libpng 1673 31.0 0 0 1.00 70.9
lodepng 1531 100.3 +6.3 +4.7 0.98 75.6
objdump 992 146.0 +4.0 0 0.97 30.6
optipng 1740 42.0 0 0 1.00 67.3
readelf 1055 150.0 +8.0 0 0.95 69.5
tcpdump 409 58.3 +9.7 +28.7 1.28 37.3
tiff2pdf 3084 164.0 +9.0 0 0.95 28.1
G. MEAN 1335.4 118.7 +5.3 +9.1 1.02 31.2
of them and can even perform better than Z3 on a few bench-
marks: for instance, F UZZY -SATsolves 301 (236:7 + 64:3)
queries on average on advmng, while Z3 stops at 243:7
(236:7 + 7 ). Although this may seem unexpected, this re-
sult is consistent with past evaluations from state-of-the-art
fuzzers [10], [33] that have shown that a large number of
branch conditions can be solved even without SMT solvers.
Nonetheless, there are still a few queries were F UZZY -SATis
unable to Ô¨Ånd a valid assignment while Z3 is successful, e.g.,
FUZZY -SATmisses 7 queries on bloaty (but solves one query
that makes Z3 run out of time). Assessing the impact of solving
ornot solving a query in concolic execution is a hard problem,
especially when bringing into the picture hybrid fuzzing and
its non-deterministic behavior. Hence, we only try to indirectly
speculate on this impact by later discussing the results on the
LA V A-M dataset and the experiments in Section V-C.
Lastly, we can see in Table I that on average F UZZY -SAT
requires 31less time than Z3 to reason over the queries
from the 12 benchmarks. When putting together this result
with the previous experimental insights, we could speculate
why F UZZY -SATcould be beneÔ¨Åcial in the context of concolic
execution: it can signiÔ¨Åcantly reduce the solving time during
the concolic exploration while still be able to generate a large
number of (possibly valuable) inputs.
One natural question is whether one could get the same
beneÔ¨Åts of F UZZY -SATby drastically reducing the time budget
given to Z3. To tackle this observation, Figure 2a reports the
number of queries solved by Z3 when using a timeout of 1
second and Figure 2b shows how the speedup from F UZZY -
SATis reduced in this setup. F UZZY -SATis still 9:5faster
than Z3 and the gap between the two in terms of solved queries
increases signiÔ¨Åcantly ( +12% in F UZZY -SAT), suggesting that
this setup of Z3 is not as effective as one may expect.
FUZZY -SATvs JSF. One solver that shares the same spirit
of F UZZY -SATis JFS (¬ß II), which however is based on a
different design. When considering the queries collected on
the 12 benchmarks, it can be seen in Figure 2a that JFS is
able to solve only 1106 queries, signiÔ¨Åcantly less than the
1534 from F UZZY -SAT. On 127 out of the 325 queries from
bsdtar, JFS has failed to generate the program to fuzz due
718(a)
All benchmarks0500100015002000# queries proved SAT1367.71514.4
11061534Z3 (1 secs)
Z3 (10 secs)JFS
Fuzzy-Sat (b)
All benchmarks051015Speedup on solving time9.5
1.54.8Fuzzy-Sat vs Z3 (1 sec)
Fuzzy-Sat w/o cache vs JFS
Fuzzy-Sat vs JFS
Fig. 2. F UZZY -SATvs other solvers on the 12 benchmarks: (a) number of
queries proved satisÔ¨Åable and (b) speedup on the solving time.
TABLE II
BUGS FOUND ON LAVA-M IN5H: AVG (MAX )NUMBER OVER 5RUNS .
base64 md5sum uniq who
QSYM WITH Z3 48(48) 58(58) 19(29) 743(795)
QSYM WITH FUZZY -SAT 48(48) 61(61) 19.7 (29) 2256.5 (2268)
to the large number of nested expressions contained in the
queries, yielding a gap of 95solved queries between two
solvers. The remaining missed queries can be likely explained
by considering that: (a) it is not currently possible to provide
the input test case iused for generating the queries to the
fuzzer executed by JFS [41], as JFS generates a program that
takes an input that is different (in terms of size and structure)
fromiand builds its own set of seeds, (b) JFS does not provide
speciÔ¨Åc insights to the fuzzer on how to mutate the input,
and (c) JFS uses L IBFUZZER [42], which does not integrate
several fuzzing techniques that have inspired F UZZY -SAT.
When considering the solving time, F UZZY -SATis1:5
faster than JFS (Figure 2b). However, when enabling analysis
cache in F UZZY -SAT, the speedup increases up to 4:8.
JFS does not currently provide a C interface [43], requiring
concolic executors to dump the queries on disk: as this
operation can take a long time in presence of large queries,
we do not consider JFS further in the other experiments.
FUZZY -SATon LA V A-M. To test whether F UZZY -SATcan
solve queries that are valuable for a concolic executor, we
repeated the experiment on the LA V A-M dataset from the
QSYM paper [4], looking for bugs within the four benchmarks
base64, md5sum, uniq, and who. Table II reports the average
and max number of bugs found during 5-hour experiments
across 5 runs. Q SYM with F UZZY -SATÔ¨Ånds on average
more bugs than Q SYM with Z3 on 3 out of 4 programs. In
particular, the improvement is rather signiÔ¨Åcant on who, where
FUZZY -SATallows Q SYM to Ô¨Ånd 3more bugs compared to
Z3, suggesting that trading performance for accuracy can be
valuable in the context of hybrid fuzzing.
Interestingly, F UZZY -SATwas able to reveal bugs that the
original authors from LA V A-M were unable to detect [9], e.g.,
FUZZY -SAThas revealed 136 new bugs on who. Since other
works [10], [33] reported a similar experimental observation,
the additional bugs are likely not false positives.
B. RQ2: Impact of different kinds of mutations in FUZZY -SAT
An interesting question is which mutations contribute at
making F UZZY -SATeffective. Table III reports which trans-
formations have been crucial to solve the queries from the 12
benchmarks, assigning a query to the multi-goal strategy when
FUZZY -SAThad to reason over conÔ¨Çicting expressions fromTABLE III
EFFECTIVENESS OF THE DIFFERENT MUTATIONS FROM FUZZY -SAT: I2S
(INPUT -TO-STATE ), BF (R.I. B RUTE FORCE ), IC (I NTERESTING
CONSTANTS ), GD (G RADIENT DESCENT ), D+ND (D ETERMINISTIC AND
NON-DETERMINISTIC MUTATIONS ), MGS (M ULTI -GOAL STRATEGY ).
PROGRAM I2S BF IC GD D+ND MGS
advmng 176 31 74 2 18 0
bloaty 43 5 20 5 19 4
bsdtar 14 8 11 0 0 91
djpeg 98 29 28 6 14 25
jhead 27 5 41 6 8 0
libpng 14 8 7 1 1 0
lodepng 61 6 16 1 21 0
objdump 91 21 18 1 10 5
optipng 28 7 6 0 1 0
readelf 96 10 22 0 22 0
tcpdump 28 7 11 1 11 29
tiff2pdf 107 25 6 0 2 24
PERC.ON TOTAL 51.04% 10.56% 17.01% 1.50% 8.28% 11.60%
to solve the query. F UZZY -SATwas able to solve more than
51% of the queries by applying input-to-state transformations,
and an additional 17% was solved by exploiting the interesting
constants collected during the analysis stage. Range interval
brute-force was helpful on around 10% of the queries, while
mutations inspired by AFL were beneÔ¨Åcial in 8%of them.
Gradient descent solved just 1:5%of the queries. However,
two considerations must be taken into account: (a) the order of
the mutations affect these numbers, as gradient descent is not
used when previous (cheaper) mutations are successful, and (b)
gradient descent is crucial for solving queries in S OLVE MIN,
SOLVE MAX, and S OLVE ALL, which are not considered in this
experiment. Finally, the multi-goal strategy of F UZZY -SATwas
essential for solving around 11% of the queries.
C. RQ3: FUZZY -SATinFUZZOLIC
To further assess the effectiveness of F UZZY -SAT, we
compare F UZZOLIC , which is built around this solver, against
state-of-the-art binary open-source fuzzers on the 12 bench-
marks, tracking the code coverage reached during 8-hour
experiments (10 runs). Besides F UZZOLIC , we consider: (a)
AFL++ [2] rev. 3f128 in QEMU mode, which integrates [44]
the colorization technique from R EDQUEEN , as well as other
improvements to AFL proposed by the fuzzing community
during the last years [45], (b) E CLIPSER rev.b072f , which
devises one of the most effective approximations of concolic
execution in literature, and (c) Q SYM rev.89a76 with Z3.
As both F UZZOLIC and Q SYM are hybrid fuzzers that are
designed to run in parallel with two instances ( Fm,Fs) of
a coverage-guided fuzzer, we consider for a fair comparison
AFL++ and E CLIPSER in a similar setup, running them in
parallel to (Fm,Fs) and allowing the tools to sync their input
queues [46]. Hence, each run takes 83 = 24 CPU hours.
ForFmwe use AFL++ in master mode , which performs
deterministic mutations, while for Fswe use AFL++ in slave
mode that only executes non-deterministic mutations. Since
ECLIPSER does not support a parallel mode, we extended it
to allow AFL++ to correctly pick inputs from its queue.
Figure 3 shows the code coverage reached by the different
fuzzers on 8 out of 12 programs. On the remaining four
7190 7200 14400 21600 28800
Time (secs)357911131517Coverage Map Density (%)bsdtar
AFL++
Eclipser
Fuzzolic (Fuzzy-Sat)
QSYM (Z3)
0 7200 14400 21600 28800
Time (secs)234567Coverage Map Density (%)djpeg
AFL++
Eclipser
Fuzzolic (Fuzzy-Sat)
QSYM (Z3)
0 7200 14400 21600 28800
Time (secs)1234Coverage Map Density (%)libpng
AFL++
Eclipser
Fuzzolic (Fuzzy-Sat)
QSYM (Z3)
0 7200 14400 21600 28800
Time (secs)4710131619Coverage Map Density (%)objdump
AFL++
Eclipser
Fuzzolic (Fuzzy-Sat)
QSYM (Z3)
0 7200 14400 21600 28800
Time (secs)345678Coverage Map Density (%)optipng
AFL++
Eclipser
Fuzzolic (Fuzzy-Sat)
QSYM (Z3)
0 7200 14400 21600 28800
Time (secs)371115192327Coverage Map Density (%)readelf
AFL++
Eclipser
Fuzzolic (Fuzzy-Sat)
QSYM (Z3)
0 7200 14400 21600 28800
Time (secs)2112029384756Coverage Map Density (%)tcpdump
AFL++
Eclipser
Fuzzolic (Fuzzy-Sat)
QSYM (Z3)
0 7200 14400 21600 28800
Time (secs)4681012141618Coverage Map Density (%)tiff2pdf
AFL++
Eclipser
Fuzzolic (Fuzzy-Sat)
QSYM (Z3)Fig. 3. Coverage map density reached by F UZZOLIC with F UZZY -SATvs other state-of-the-art fuzzers. The shaded areas are the 95% conÔ¨Ådence intervals.
0 7200 14400 21600 28800
Time (secs)31221303948Coverage Map Density (%)tcpdump
Fuzzolic (Fuzzy-Sat)
QSYM (Z3)
QSYM (Fuzzy-Sat)
0 7200 14400 21600 28800
Time (secs)4710131619Coverage Map Density (%)objdump
Fuzzolic (Fuzzy-Sat)
QSYM (Z3)
QSYM (Fuzzy-Sat)
Fig. 4. Coverage map density: impact of F UZZY -SATin Q SYM.
benchmarks, the fuzzers reached soon a very similar coverage,
making it hard to detect any signiÔ¨Åcant trend and thus we omit
their charts due to lack of space. Similar to other works [4],
[5], we plot the density of the coverage map from Fsand
depict the 95% conÔ¨Ådence interval using a shaded area. As
bitmap collisions may occur [47], we validated the trends by
also computing the number of basic blocks [48].
FUZZOLIC reaches a higher code coverage than other so-
lutions on 6 programs, i.e., bsdtar, djpeg, objdump, readelf,
tcpdump, and tiff2pdf. In particular, tcpdump is the program
where F UZZOLIC shines better, consistently showing over time
an increase in the map density of 5%with respect to the
second-best fuzzer (AFL++). On optipng, although F UZZOLIC
appears to have an edge at the beginning of the experiment,
it then reaches a coverage that is comparable to other fuzzers,
which are all very close in performance. Finally, F UZZOLIC
falls behind other approaches on libpng, pinpointing one case
where F UZZY -SATseems to underperform compared to Z3,
as Q SYM dominates on this benchmark.
When comparing closely F UZZOLIC to Q SYM, the improve-
ment in the coverage is likely due to the better scalability of
the former with respect to the latter. For instance, on tcpdump
FUZZOLIC performs concolic execution on 11089 inputs ( 1:8
secs/input), generating 14415 alternative inputs, while Q SYM
only analyzes 376inputs ( 71:4secs/input) and generates 786
alternative inputs. When considering libpng, F UZZOLIC is
still faster than Q SYM (8:8secs/input vs 43:6secs/input) but
the number of inputs available in the queue from Fs(from
which F UZZOLIC and Q SYM pick inputs) over time is very
low. Hence, the difference between F UZZOLIC and Q SYM on
libpng is due to a few but essential queries that Z3 is able to
solve while F UZZY -SATfails to reason on.
The better scalability of F UZZOLIC with respect to Q SYM isgiven by the combination of an efÔ¨Åcient solver (F UZZY -SAT)
and an efÔ¨Åcient tracer (F UZZOLIC ). Indeed, when replacing Z3
with F UZZY -SATin Q SYM, this concolic executor improves
its performance but still falls behind F UZZOLIC . Figure 4
compares the coverage of Q SYM with the two solvers and
FUZZOLIC on two benchmarks. On tcpdump, Q SYM with
FUZZY -SATis able to analyze 2111 inputs ( 10:1secs/input)
and generate 3690 alternative inputs, improving the coverage
by 4%on average with respect to Z3 but still performing worse
than F UZZOLIC . Similarly, on objdump the improvement in
QSYM due to F UZZY -SATis even more noticeable but still
QSYM cannot match the coverage reached by F UZZOLIC .
When comparing F UZZOLIC to E CLIPSER and AFL++,
the results suggest that the integration of fuzzing techniques
into a solver provides a positive impact. Indeed, while these
fuzzers scales better than F UZZOLIC , processing hundreds of
inputs per second, they lack the knowledge that F UZZY -SAT
extracts from the symbolic expressions, which is used to per-
form effective mutations. Overall, colorization from AFL++
and approximate concolic execution from E CLIPSER seem to
generate similar inputs on several benchmarks, yielding often
a similar coverage in our parallel fuzzing setup. Moreover,
despite F UZZOLIC may spend several seconds over a single
input, it collects information that allows it to fuzz a large
number of branch conditions, paying on average only a few
microseconds when testing an input assignment. Hence, the
time spent building the symbolic expressions can be amortized
over thousands of (cheap) query evaluations, reducing the gap
between the efÔ¨Åciency of a fuzzer and a concolic executor.
Nonetheless, F UZZOLIC is still a hybrid fuzzer and it needs to
run in parallel to a traditional fuzzer to provide good results,
since some non-deterministic mutations, such as randomly
combining inputs, are not performed by F UZZOLIC .
VI. T HREATS TO VALIDITY AND LIMITATIONS
Floating-point arithmetic. Our current implementation of
FUZZOLIC and F UZZY -SATdoes not handle symbolic expres-
sions involving Ô¨Çoating-point operations. In case of Ô¨Çoating-
point instructions during program execution, F UZZOLIC con-
cretizes the symbolic expressions. Although this is the same
strategy adopted by Q SYM, we acknowledge that it may harm
720the effectiveness of the concolic executor on programs heavily
based on Ô¨Çoating-point computations.
Order of the mutations in F UZZY -SAT.The current im-
plementation of F UZZY -SATapplies mutations using a speciÔ¨Åc
order and stops as soon as one of the mutations is successful in
Ô¨Ånding a valid assignment for a query. In particular, F UZZY -
SATruns Ô¨Årst the cheapest rules that are more likely able to
succeed: e.g., given an input-to-state relation, trying the input-
to-state rule Ô¨Årst makes sense as it requires a few attempts
and has high chances to succeed [33]. Hence, results reported
in Section V are based on the order currently adopted by
FUZZOLIC . An interesting experiment would be to evaluate
how F UZZY -SATwould perform when changing the order of
the mutations.
Impact of F UZZY -SATin hybrid fuzzing . In Section V,
we have investigated the impact of F UZZY -SATinside two
concolic executors: F UZZOLIC and Q SYM. Our results are
promising and suggest that F UZZY -SATcan be beneÔ¨Åcial in
the context of hybrid fuzzing. However, we believe it would
be interesting to integrate F UZZY -SATin other frameworks to
have additional insights on its effect. For instance, the beneÔ¨Åt
from using F UZZY -SATinside a concolic executor that is slow
at building symbolic expression would be marginal as most
of the analysis time would be spent in the emulation phase
and not in the solving one. On the other hand, an efÔ¨Åcient
concolic executor should beneÔ¨Åt from F UZZY -SATas long
as the number of queries submitted to the solver during an
experiment is very high: if the number of queries is low, then
a slower but more accurate traditional SMT solver would likely
perform better than F UZZY -SAT.
VII. C ONCLUSIONS
FUZZY -SATis an approximate solver that uses fuzzing
techniques to efÔ¨Åciently solve queries generated by concolic
execution, helping hybrid fuzzers scale better on several real-
world programs.
We have currently identiÔ¨Åed two interesting future direc-
tions. First, we plan to integrate F UZZY -SATin the concolic
execution framework S YMCC, which has been shown to be
very efÔ¨Åcient at building symbolic expressions and thus should
beneÔ¨Åt from using an efÔ¨Åcient approximate solver. Second,
we would like to devise an effective heuristic for dynamically
switching during the exploration between F UZZY -SATand a
traditional SMT solver depending on the workload generated
by the concolic executor on the solver backend.
REFERENCES
[1] M. Zalewski, ‚ÄúAmerican Fuzzy Lop,‚Äù https://github.com/Google/AFL ,
2019, [Online; accessed 20-Aug-2020].
[2] M. Heuse, H. Ei√üfeldt, and A. Fioraldi, ‚ÄúAFL++,‚Äù https://github.com/
vanhauser-thc/AFLplusplus , 2019, [Online; accessed 20-Aug-2020].
[3] C. Barrett and C. Tinelli, SatisÔ¨Åability Modulo Theories . Springer
International Publishing, 2018, pp. 305‚Äì343.
[4] I. Yun, S. Lee, M. Xu, Y . Jang, and T. Kim, ‚ÄúQSYM: A
practical concolic execution engine tailored for hybrid fuzzing,‚Äù
inProceedings of the 27th USENIX Conference on Security
Symposium , ser. SEC‚Äô18, 2018, pp. 745‚Äì761. [Online]. Available:
http://dl.acm.org/citation.cfm?id=3277203.3277260[5] S. Poeplau and A. Francillon, ‚ÄúSymbolic execution with symcc: Don‚Äôt
interpret, compile!‚Äù in Proceedings of the 29th USENIX Security
Symposium (USENIX Security 20) . USENIX Association, Aug. 2020,
pp. 181‚Äì198. [Online]. Available: https://www.usenix.org/conference/
usenixsecurity20/presentation/poeplau
[6] N. Stephens, J. Grosen, C. Salls, A. Dutcher, R. Wang,
J. Corbetta, Y . Shoshitaishvili, C. Kruegel, and G. Vigna,
‚ÄúDriller: Augmenting fuzzing through selective symbolic execution.‚Äù
inProceeings of the 23th Annual Network and Distributed
System Security Symposium, NDSS , 2016. [Online]. Avail-
able: https://www.ndss-symposium.org/wp-content/uploads/2017/09/
driller-augmenting-fuzzing-through-selective-symbolic-execution.pdf
[7] L. De Moura and N. Bj√∏rner, ‚ÄúZ3: An efÔ¨Åcient smt
solver,‚Äù in Proceedings of 14th Int. Conf. on Tools and
Algorithms for the Construction and Analysis of Systems , ser.
TACAS‚Äô08/ETAPS‚Äô08, 2008, pp. 337‚Äì340. [Online]. Available:
https://doi.org/10.1007/978-3-540-78800-3 24
[8] D. Liew, C. Cadar, A. F. Donaldson, and J. R. Stinnett, ‚ÄúJust fuzz
it: Solving Ô¨Çoating-point constraints using coverage-guided fuzzing,‚Äù
inProceedings of the 2019 27th ACM Joint Meeting on European
Software Engineering Conference and Symposium on the Foundations
of Software Engineering , ser. ESEC/FSE 2019. New York, NY , USA:
Association for Computing Machinery, 2019, p. 521‚Äì532. [Online].
Available: https://doi.org/10.1145/3338906.3338921
[9] B. Dolan-Gavitt, P. Hulin, E. Kirda, T. Leek, A. Mambretti,
W. Robertson, F. Ulrich, and R. Whelan, ‚ÄúLA V A: Large-Scale
Automated Vulnerability Addition,‚Äù in Proceedings of the 2016 IEEE
Symposium on Security and Privacy , ser. SP ‚Äô16, 2016, pp. 110‚Äì121.
[Online]. Available: https://doi.org/10.1109/SP.2016.15
[10] J. Choi, J. Jang, C. Han, and S. K. Cha, ‚ÄúGrey-box concolic testing
on binary code,‚Äù in Proceedings of the 41st International Conference
on Software Engineering , ser. ICSE ‚Äô19, 2019, pp. 736‚Äì747. [Online].
Available: https://doi.org/10.1109/ICSE.2019.00082
[11] G. J. Myers, C. Sandler, and T. Badgett, The art of software testing ,
3rd ed. Hoboken and N.J: John Wiley & Sons, 2012.
[12] R. Baldoni, E. Coppa, D. C. D‚ÄôElia, C. Demetrescu, and I. Finocchi,
‚ÄúA survey of symbolic execution techniques,‚Äù ACM Computing
Surveys , vol. 51, no. 3, pp. 50:1‚Äì50:39, 2018. [Online]. Available:
http://doi.acm.org/10.1145/3182657
[13] A. Zeller, R. Gopinath, M. B ¬®ohme, G. Fraser, and C. Holler, ‚ÄúThe
Fuzzing Book,‚Äù https://www.fuzzingbook.org/ , 2019, [Online; accessed
20-Aug-2020].
[14] Y . Shoshitaishvili, R. Wang, C. Salls, N. Stephens, M. Polino,
A. Dutcher, J. Grosen, S. Feng, C. Hauser, C. Kruegel, and G. Vigna,
‚ÄúSOK: (state of) the art of war: Offensive techniques in binary
analysis,‚Äù in Proceedings of the 2016 IEEE Symposium on Security
and Privacy , ser. SP‚Äô16, 2016, pp. 138‚Äì157. [Online]. Available:
http://dx.doi.org/10.1109/SP.2016.17
[15] V . Chipounov, V . Kuznetsov, and G. Candea, ‚ÄúThe S2E platform:
Design, implementation, and applications,‚Äù ACM Trans. on Computer
Systems (TOCS) , vol. 30, no. 1, pp. 2:1‚Äì2:49, 2012. [Online]. Available:
http://doi.acm.org/10.1145/2110356.2110358
[16] C. Cadar, D. Dunbar, and D. Engler, ‚ÄúKLEE: Unassisted and
Automatic Generation of High-coverage Tests for Complex Systems
Programs,‚Äù in Proceedings of the 8th USENIX Conference on Operating
Systems Design and Implementation , ser. OSDI‚Äô08. Berkeley, CA,
USA: USENIX Association, 2008, pp. 209‚Äì224. [Online]. Available:
http://dl.acm.org/citation.cfm?id=1855741.1855756
[17] C. S. Pasareanu, P. C. Mehlitz, D. H. Bushnell, K. Gundy-Burlet,
M. Lowry, S. Person, and M. Pape, ‚ÄúCombining unit-level symbolic
execution and system-level concrete execution for testing nasa
software,‚Äù in Proceedings of the 2008 International Symposium on
Software Testing and Analysis , ser. ISSTA ‚Äô08, 2008, p. 15‚Äì26.
[Online]. Available: https://doi.org/10.1145/1390630.1390635
[18] S. K. Cha, T. Avgerinos, A. Rebert, and D. Brumley, ‚ÄúUnleashing
mayhem on binary code,‚Äù in Proceedings of the 2012 IEEE Symposium
on Security and Privacy , ser. SP ‚Äô12, 2012, pp. 380‚Äì394. [Online].
Available: https://doi.org/10.1109/SP.2012.31
[19] R. Baldoni, E. Coppa, D. C. D‚ÄôElia, and C. Demetrescu,
‚ÄúAssisting Malware Analysis with Symbolic Execution: A
Case Study,‚Äù in Proceedings of the 2017 Cyber Security
Cryptography and Machine Learning , ser. CSCML ‚Äô17. Springer
International Publishing, 2017, pp. 171‚Äì188. [Online]. Available:
https://doi.org/10.1007/978-3-319-60080-2 12
721[20] L. Borzacchiello, E. Coppa, D. C. D‚ÄôElia, and C. Demetrescu,
‚ÄúReconstructing C2 Servers for Remote Access Trojans with
Symbolic Execution,‚Äù in Proceedings of the 2019 Cyber Security
Cryptography and Machine Learning , ser. CSCML ‚Äô19. Springer
International Publishing, 2019. [Online]. Available: https://doi.org/10.
1007/978-3-030-20951-3 12
[21] P. Godefroid, M. Y . Levin, and D. A. Molnar, ‚ÄúAutomated
Whitebox Fuzz Testing,‚Äù in Proceedings of the 2008 Network
and Distributed System Security Symposium , ser. NDSS‚Äô08,
2008. [Online]. Available: http://www.isoc.org/isoc/conferences/ndss/
08/papers/10 automated whitebox fuzz.pdf
[22] E. Coppa, D. C. D‚ÄôElia, and C. Demetrescu, ‚ÄúRethinking
Pointer Reasoning in Symbolic Execution,‚Äù in Proceedings of
the 32nd IEEE/ACM International Conference on Automated Software
Engineering , ser. ASE ‚Äô17, 2017, pp. 613‚Äì618. [Online]. Available:
https://doi.org/10.1109/ASE.2017.8115671
[23] L. Borzacchiello, E. Coppa, D. C. D‚ÄôElia, and C. Demetrescu, ‚ÄúMemory
models in symbolic execution: key ideas and new thoughts,‚Äù Software
Testing, VeriÔ¨Åcation and Reliability , vol. 29, no. 8, 2019. [Online].
Available: https://doi.org/10.1002/stvr.1722
[24] H. Huang, P. Yao, R. Wu, Q. Shi, and C. Zhang, ‚ÄúPangolin: Incremental
hybrid fuzzing with polyhedral path abstraction,‚Äù in Proceedings of
the 2020 IEEE Symposium on Security and Privacy (SP) , 2020, pp.
1613‚Äì1627. [Online]. Available: https://doi.ieeecomputersociety.org/10.
1109/SP40000.2020.00063
[25] P. Yao, Q. Shi, H. Huang, and C. Zhang, ‚ÄúFast bit-vector satisÔ¨Åability,‚Äù
inProceedings of the 29th ACM SIGSOFT International Symposium
on Software Testing and Analysis , ser. ISSTA ‚Äô20, 2020, p. 38‚Äì50.
[Online]. Available: https://doi.org/10.1145/3395363.3397378
[26] V . Pham, M. Boehme, A. E. Santosa, A. R. Caciulescu, and
A. Roychoudhury, ‚ÄúSmart greybox fuzzing,‚Äù IEEE Transactions on
Software Engineering , 2019. [Online]. Available: https://doi.org/10.
1109/TSE.2019.2941681
[27] ‚ÄúGoogle OSS-Fuzz: continuous fuzzing of open source software,‚Äù https:
//github.com/google/oss-fuzz , 2019, [Online; accessed 20-Aug-2020].
[28] N. Stephens, J. Grosen, C. Salls, A. Dutcher, R. Wang,
J. Corbetta, Y . Shoshitaishvili, C. Kruegel, and G. Vigna,
‚ÄúDriller: Augmenting fuzzing through selective symbolic execution,‚Äù
inProceeings of the 23nd Annual Network and Distributed
System Security Symposium , ser. NDSS‚Äô16, 2016. [Online].
Available: http://www.internetsociety.org/sites/default/Ô¨Åles/blogs-media/
driller-augmenting-fuzzing-through-selective-symbolic-execution.pdf
[29] ‚ÄúCircumventing Fuzzing Roadblocks with Compiler
Transformations,‚Äù https://laÔ¨Åntel.wordpress.com/2016/08/15/
circumventing-fuzzing-roadblocks-with-compiler-transformations/ ,
2016, [Online; accessed 20-Aug-2020].
[30] S. Rawat, V . Jain, A. Kumar, L. Cojocar, C. Giuffrida, and
H. Bos, ‚ÄúVuzzer: Application-aware evolutionary fuzzing,‚Äù in 24th
Annual Network and Distributed System Security Symposium, NDSS ,
2017. [Online]. Available: https://www.ndss-symposium.org/ndss2017/
ndss-2017-programme/vuzzer-application-aware-evolutionary-fuzzing/
[31] B. Yadegari and S. Debray, ‚ÄúBit-level taint analysis,‚Äù in 2014 IEEE
14th International Working Conference on Source Code Analysis
and Manipulation (SCAM) , 2014, pp. 255‚Äì264. [Online]. Available:
https://doi.ieeecomputersociety.org/10.1109/SCAM.2014.43
[32] P. Chen and H. Chen, ‚ÄúAngora: EfÔ¨Åcient fuzzing by principled
search,‚Äù in Proceedings of the 2018 IEEE Symposium on Security
and Privacy (SP) , 2018, pp. 711‚Äì725. [Online]. Available: https:
//doi.org/10.1109/SP.2018.00046[33] C. Aschermann, S. Schumilo, T. Blazytko, R. Gawlik, and T. Holz,
‚ÄúREDQUEEN: fuzzing with input-to-state correspondence,‚Äù in Proceed-
ings of the 26th Annual Network and Distributed System Security Sym-
posium, NDSS , 2019. [Online]. Available: https://www.ndss-symposium.
org/ndss-paper/redqueen-fuzzing-with-input-to-state-correspondence/
[34] A. Fioraldi, D. C. D‚ÄôElia, and E. Coppa, ‚ÄúWEIZZ: Automatic
Grey-Box Fuzzing for Structured Binary Formats,‚Äù in Proceedings
of the 29th ACM SIGSOFT International Symposium on Software
Testing and Analysis (ISSTA ‚Äô20) , 2020. [Online]. Available: https:
//doi.org/10.1145/3395363.3397372
[35] W. You, X. Liu, S. Ma, D. Perry, X. Zhang, and B. Liang, ‚ÄúSLF: Fuzzing
without valid seed inputs,‚Äù in Proceedings of the 41st International
Conference on Software Engineering , ser. ICSE ‚Äô19, 2019, pp. 712‚Äì723.
[Online]. Available: https://doi.org/10.1109/ICSE.2019.00080
[36] J. A. Navas, P. Schachte, H. S√∏ndergaard, and P. J. Stuckey,
‚ÄúSignedness-agnostic program analysis: Precise integer bounds for
low-level code,‚Äù in Proceedings of the 10th Asian Symposium on
Programming Languages and Systems , ser. APLAS ‚Äô12, 2012, pp. 115‚Äì
130. [Online]. Available: https://doi.org/10.1007/978-3-642-35182-2 9
[37] C.-K. Luk, R. Cohn, R. Muth, H. Patil, A. Klauser, G. Lowney,
S. Wallace, V . J. Reddi, and K. Hazelwood, ‚ÄúPin: Building customized
program analysis tools with dynamic instrumentation,‚Äù ser. PLDI ‚Äô05.
ACM, 2005. [Online]. Available: http://doi.acm.org/10.1145/1065010.
1065034
[38] D. C. D‚ÄôElia, E. Coppa, S. Nicchi, F. Palmaro, and L. Cavallaro, ‚ÄúSoK:
Using Dynamic Binary Instrumentation for Security (And How You
May Get Caught Red Handed),‚Äù in Proceedings of the 14th ACM ASIA
Conference on Computer and Communications Security , ser. ASIACCS
‚Äô19, 2019. [Online]. Available: https://doi.org/10.1145/3321705.3329819
[39] Google, ‚ÄúFuzzBench: issue #131,‚Äù https://github.com/google/fuzzbench/
issues/131 , 2020, [Online; accessed 20-Aug-2020].
[40] M. Bynens, ‚ÄúSmallest possible syntactically valid Ô¨Åles of different
types,‚Äù https://github.com/mathiasbynens/small , 2019, [Online; accessed
20-Aug-2020].
[41] D. Liew, ‚ÄúJFS: issue #4,‚Äù https://github.com/mc-imperial/jfs/issues/4 ,
2019, [Online; accessed 20-Aug-2020].
[42] K. Serebryany, ‚ÄúlibFuzzer: a library for coverage-guided fuzz testing,‚Äù
http://llvm.org/docs/LibFuzzer.html , 2015, [Online; accessed 20-Aug-
2020].
[43] R. J. Stinnett, ‚ÄúJFS: issue #22,‚Äù https://github.com/mc-imperial/jfs/
issues/22 , 2019, [Online; accessed 20-Aug-2020].
[44] ‚ÄúCmpLog instrumentation for QEMU inspired by Redqueen,‚Äù https://
aÔ¨Çplus.plus/features/ , 2020, [Online; accessed 20-Aug-2020].
[45] A. Fioraldi, D. Maier, H. Ei√üfeldt, and M. Heuse,
‚ÄúAFL++: Combining incremental steps of fuzzing research,‚Äù
in Proceedings of the 14th USENIX Workshop on
Offensive Technologies , ser. WOOT ‚Äô20, 2020. [Online].
Available: http://www.internetsociety.org/sites/default/Ô¨Åles/blogs-media/
driller-augmenting-fuzzing-through-selective-symbolic-execution.pdf
[46] ‚ÄúSingle-system parallelization,‚Äù https://aÔ¨Çplus.plus/docs/parallel
fuzzing/ , 2020, [Online; accessed 20-Aug-2020].
[47] S. Gan, C. Zhang, X. Qin, X. Tu, K. Li, Z. Pei, and Z. Chen,
‚ÄúCollaÔ¨Ç: Path sensitive fuzzing,‚Äù in 2018 IEEE Symposium on Security
and Privacy , ser. SP ‚Äô18, 2018, pp. 679‚Äì696. [Online]. Available:
http://dx.doi.org/10.1109/SP.2018.00040
[48] A. Fioraldi, ‚ÄúaÔ¨Ç-qemu-cov,‚Äù https://github.com/andreaÔ¨Åoraldi/
aÔ¨Ç-qemu-cov , [Online; accessed 20-Aug-2020].
722