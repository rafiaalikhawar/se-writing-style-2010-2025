Characterizing and Detecting ConÔ¨Åguration
Compatibility Issues in Android Apps
Huaxun Huang‚Ä†, Ming Wen¬ß, Lili Wei‚Ä†, Yepang Liu¬∂, Shing-Chi Cheung‚Ä†*
‚Ä†Dept. of Computer Science and Engineering, The Hong Kong University of Science and Technology, Hong Kong, China
¬ßSchool of Cyber Science and Engineering, Huazhong University of Science and Technology, Wuhan, China
¬∂Dept. of Computer Science and Engineering, Southern University of Science and Technology, Shenzhen, China
Emails:{hhuangas@cse.ust.hk, mwenaa@hust.edu.cn, liliwei@cse.ust.hk, liuyp1@sustech.edu.cn, scc@cse.ust.hk }
Abstract ‚ÄîXML conÔ¨Åguration Ô¨Åles are widely used in Android
to deÔ¨Åne an app‚Äôs user interface and essential runtime informa-
tion such as system permissions. As Android evolves, it mightintroduce functional changes in the conÔ¨Åguration environment,thus causing compatibility issues that manifest as inconsistent appbehaviors at different API levels. Such issues can often inducesoftware crashes and inconsistent look-and-feel when running atspeciÔ¨Åc Android versions. Existing works incur plenty of falsepositive and false negative issue-detection rules by conductingtrivial data-Ô¨Çow analysis while failing to model the XML treehierarchies of the Android conÔ¨Åguration Ô¨Åles. Besides, littleis known about how the changes in an Android frameworkcan induce such compatibility issues. To bridge such gaps,we conducted a systematic study by analyzing 196 real-worldissues collected from 43 popular apps. We identiÔ¨Åed commonpatterns of Android framework code changes that induce suchconÔ¨Åguration compatibility issues. Based on the Ô¨Åndings, wepropose C
ONF DROID that can automatically extract rules for
detecting conÔ¨Åguration compatibility issues. The intuition is toperform symbolic execution based on a model learned from thecommon code change patterns. Experiment results show that
C
ONF DROID can successfully extract 282 valid issue-detection
rules with a precision of 91.9%. Among them, 65 extracted rulescan manifest issues that cannot be detected by the rules of state-of-the-art baselines. More importantly, 11 out of them have ledto the detection of 107 reproducible conÔ¨Åguration compatibilityissues that the baselines cannot detect in 30 out of 316 real-worldAndroid apps.
Index T erms‚ÄîXML conÔ¨Åguration, Android, compatibility,
static analysis
I. I NTRODUCTION
The Android framework provides a Ô¨Çexible XML conÔ¨Ågura-
tion environment, which is widely used by developers to con-
trol Android components‚Äô behaviors or even the entire apps,such as deÔ¨Åning User Interface (UI) structures of the apps‚Äôlayout and declaring the required system permissions, and soon.
Android continuously evolves to meet different market
demands, resulting in successive releases of thirty differentAPI levels since its launch [1]. Each API level introducesfunctional changes to the Android conÔ¨Ågurations to cater forrevised requirements. Such functional changes can cause thesame conÔ¨Åguration element in an Android app to manifestinconsistent behaviors at different API levels. We refer to such
‚àóShing-Chi Cheung is the corresponding author of this paper.Project: gecko-dev Stars: 2.1k+
Source Code:
)		
	*
) 	 ( 	 ('*
) 	(	
	 *

)	
	 	 (
	


 	



	 
*
) * 
!
"
#
$
%
&
'
Consequences: 
App crashes at API level 21
Inconsistent look-and-feel at API level 22 (See Figure 2(c))""

! *& *&
""""	$"!'()%
##
Fig. 1. A real-world example of conÔ¨Åguration compatibility issues reported
inBUG 1486200 of gecko-dev.
inconsistencies as conÔ¨Åguration compatibility issues, which
can lead to poor user experience.
Figure 1shows a real-world example of a conÔ¨Åguration
compatibility issue (i.e. BUG 1486200 [2]) reported by an
open-source Android browser engine project called gecko-
dev [3], which has received 2.1K+ stars in GitHub [4]. Lines3-8 specify a <selector> conÔ¨Åguration element to create
a color state list object. It has a child tag named <item>
containing a set of attributes such as android:color in
Line 6. The conÔ¨Åguration element triggers a compatibilityissue, where the app normally works at an API level ‚â•
23 but throws ArrayIndexOutOfBoundsException at
API level 21 and manifests inconsistent look-and-feel at APIlevel 22. The issue was caused by the different implementa-tions among API levels 21, 22, and 23 to process the attributevalue of android:color from XML conÔ¨Åguration Ô¨Åles in
the Android framework (see Section II-B for more details).
In our empirical study, we observe that among the 196 real-world conÔ¨Åguration compatibility issues in 43 popular Androidapps, 89 (45.4%) of them can induce app crashes at certainAPI levels, while a further 88 (44.9%) can induce inconsistentlook-and-feel across different API levels. This indicates that, inpractice, conÔ¨Åguration compatibility issues can induce severeproblems in Android apps.
Nevertheless, uncovering conÔ¨Åguration compatibility issues
caused by such changes is non-trivial. SpeciÔ¨Åcally, our investi-gation of 200 top-ranked Android apps found that each of them
5172021 36th IEEE/ACM International Conference on Automated Software Engineering (ASE)
DOI 10.1109/ASE51524.2021.000532021 36th IEEE/ACM International Conference on Automated Software Engineering (ASE) | 978-1-6654-0337-5/21/$31.00 ¬©2021 IEEE | DOI: 10.1109/ASE51524.2021.9678556
978-1-6654-0337-5/21/$31.00  ¬©2021  IEEE
on average speciÔ¨Åes 25,991.6 conÔ¨Åguration elements spreading
across 663.1 XML Ô¨Åles. Typically, Android apps are designedto run on a range of API levels. It is expensive to design teststo check whether all these conÔ¨Åguration elements and theirattributes are handled as intended across these diverse APIlevels. As a result, conÔ¨Åguration compatibility issues can easilybe missed by app developers. Although the related ofÔ¨ÅcialAndroid documentation, such as Android Developers [1] andAndroid API Differences Reports [5], records the informationof conÔ¨Åguration changes that can result in compatibility issues,such documentation can miss many conÔ¨Åguration changes thatmanifest runtime inconsistencies. Even if the relevant changesare documented, the documentation can be overlooked by de-velopers. Thus, an automatic tool to help detect conÔ¨Ågurationcompatibility issues is helpful.
Existing techniques on detecting software misconÔ¨Ågura-
tions [6]‚Äì[13] and Android incompatibilities [14]‚Äì[22] arenot effective in identifying such conÔ¨Åguration compatibilityissues and pinpointing the root cause. For example, the issuebetween API levels 22 and 23 in Figure 1is triggered by
using different API calls with different guarded conditions toload the value of android:color in the XML tag <item>.
Accurate identiÔ¨Åcation of the root cause requires path-sensitiveanalysis, which can be expensive. However, if we considerthe existence of a compatibility issue whenever there areimplementation differences on how the Android frameworkprocesses XML attributes, many issues identiÔ¨Åed are spuriousas many code changes are irrelevant to compatibility issues.It is non-trivial to analyze code changes that can triggerconÔ¨Åguration compatibility issues in the Android frameworkwith the large codebase (i.e., 4M+ LOC at API level 30)and a huge number of code changes in history (i.e., 250git development branches with changes from 566K+ commitsuntil April 2021). So far, no prior works have studied thecommon patterns of code changes in the Android frameworkthat induce conÔ¨Åguration compatibility. To Ô¨Åll such gaps, weconducted an empirical study linking the root causes of realconÔ¨Åguration compatibility issues in 43 popular open-sourceAndroid apps to the code changes in the Android frame-work. We found several common code change patterns thatcan induce conÔ¨Åguration compatibility issues in the Androidframework (Section III).
Based on the Ô¨Åndings, we further propose C
ONF DROID ,
which is a static analyzer encoding the common codechange patterns to automatically generate issue-detection rules.SpeciÔ¨Åcally, C
ONF DROID performs an intra-class level sym-
bolic execution based on the insight that common conÔ¨Åguration
compatibility issues are induced by the code changes withina single class that can process XML attributes in the Androidframework. In this way, we can greatly reduce the cost ofconducting path-sensitive analysis while ensuring comparableaccuracy when identifying detection rules.
We implemented C
ONF DROID based on Soot [23] and ran
it on the Android framework code among API levels 21-30 toextract rules for detecting conÔ¨Åguration compatibility issues.The experimental results show that C
ONF DROID achieved	 ,-,-&
	 "*(+.

#
 !  ! <"*+&
*) ! '"	*+'#!* 0"0++ &
"" #"" "" ! < ! &
* <<'"" ' +.
<	'
	 *% + &//
<* %+&/

  !"!!*(+.
 *"<1&=!'"&;;+.
 *"<1&=!,-'"&;;+.
#"#" < ,-, -&//
#"#"<,-, -&//
	 "*(+.

#
 !  ! <"*+&
*) ! '"	*+'#!* 0"0++ &
"" #"" "" ! < ! &
$  $ <!# !'""" #"!*"" !+ &
"
	 <' *
	
	 % '	+ &
! <* 
	 %(+//12
13
14
15
16
17
18
19
1:
21
22
23
24API level 21 & 22	
Parse
Loading
API level 232526
27
28
29
2:
31API level 21 only
API level 22 onlyArrayOutOfBoundsExceptionUsage
Called after 
	
Fig. 2. Code snippets adapted from ColorStateList in the Android
framework to process the attribute android:color among API level 21,
22 and 23.
a precision of 91.9% by successfully generating 282 valid
detection rules, which can be reproducible when manifestingruntime inconsistencies in the Android emulators. Besides,
C
ONF DROID can generate 65 validated rules that are missed
by three state-of-the-art baseline methods. Furthermore, weevaluated the usefulness of C
ONF DROID for issue detection in
the 316 real-world Android apps from F-Droid [24] and App-Brain [25]. Among 65 valid rules that are uniquely returnedby C
ONF DROID , 11 of them have been enabled to generate
107 warnings that can be reproduced to manifest conÔ¨Ågurationcompatibility issues in 30 apps. So far, 52 warnings have beenconÔ¨Årmed, and 51 warnings have been Ô¨Åxed by the developers.We released the empirical and experiment datasets as well asthe C
ONF DROID artifact in our project website [26].
To summarize, our work makes three major contributions.
‚Ä¢An empirical research on open-source apps to help un-derstand the common root causes and patterns of conÔ¨Åg-uration compatibility issues.
‚Ä¢A technique named C ONF DROID that can generate rules
to facilitate an automatic detection of conÔ¨Åguration com-patibility issues in Android apps.
‚Ä¢An empirical evaluation showing that (1) C ONF DROID
outperforms existing approaches on generating new de-tection rules with high precision, and (2) rules extractedby C
ONF DROID can be successfully applied for detecting
previously-unknown conÔ¨Åguration compatibility issues.
II. B ACKGROUND &M OTIV A TION
A. Processing XML ConÔ¨Åguration Files in Android
XML conÔ¨Åguration Ô¨Åles are an indispensable part of An-
droid projects. In general, there are two types of XML conÔ¨Åg-uration Ô¨Åles: (1) manifest Ô¨Åles (AndroidManifest.xml)that provide the essential runtime information for Androidapps, (2) resource XML Ô¨Åles (located in the /res/ folder)
that are commonly used to deÔ¨Åne an app‚Äôs user interfaces [27].The Android framework provides a Ô¨Çexible conÔ¨Åguration
518API level 23
API level 21(b)
(d)(a)
API level 22
(c)
Fig. 3. Reproduction steps for the issue as shown in Figure 1.
environment that can accept substantially different attributes
(e.g., 1,435 different attributes at API level 30). As the Androidframework evolves, compatibility issues arise from incon-sistent handling of these attributes and their values amongdifferent API levels.
A popular Android app typically consists of a few hundred
XML conÔ¨Åguration Ô¨Åles. Each is processed as the followingsteps by the Android framework.
Parsing. The Android framework uses XmlPullParser
to parse all the XML tags in conÔ¨Åguration Ô¨Åles and return anAttributeSet orTypedArray object for each XML tag.
In particular, AttributeSet andTypedArray are two
classes deÔ¨Åned in the Android framework to store each XMLattribute value as a key-value pair. The framework providesAPIs to trigger the parsing process and returns a newlycreated AttributeSet orTypedArray object, such as
getXml() in Line 1 of Figure 2.
Loading. AttributeSet andTypedArray deÔ¨Åne APIs
(e.g., AttributeSet#getAttributeIntValue() and
TypedArray#getBoolean()) that take conÔ¨Åguration at-tributes as parameters and return the corresponding attributevalues in predeÔ¨Åned formats. We refer to these APIs asconÔ¨Åguration APIs. In the loading step, the attribute valuesin the AttributeSet andTypedArray objects are loaded
to some program variables using the conÔ¨Åguration APIs.
Usage. The variables are processed by the Android frame-
work to represent the app‚Äôs runtime behavior.
ConÔ¨Åguration compatibility issues can occur when there are
inconsistent implementations in the above steps among thedifferent Android API levels.
B. Motivating Example
It is generally difÔ¨Åcult for developers to identify compat-
ibility issues from many XML conÔ¨Åguration Ô¨Åles in their
apps, especially for those issues that can only be triggeredunder speciÔ¨Åc conditions. Figure 3shows a test case that
can manifest the issue illustrated in Figure 1. To this end,
developers should Ô¨Årst let the app load a website containinga time picker as Figure 3(a) shows, and then choose thecorresponding input Ô¨Åeld to open the problematic time pickeras listed in Figure 1. It took the developers one month
to detect and Ô¨Åx the above issue. The issue was causedby the inconsistent processing of android:color in the
Android framework among API levels 21, 22, and 23. Thedifferent implementations of these API levels are shown inFigure 2. First, at API levels 21 and 22, the conÔ¨Åguration API
AttributeSet#getAttributeIntValue() in Line 7
is invoked to load android:color, whose value affects
the array mSpec in Line 8. However, there is a defect in
the Android framework at API level 21. It accesses an illegalindex of the array mSpec in Line 12, causing the app to
crash. At API level 22, we did not witness the crash asthe Android framework has Ô¨Åxed the processing of an-
droid:color, as shown in Line 13. Second, the conÔ¨Ågura-tion API AttributeSet#getAttributeIntValue()
fails to load the attribute values in the style format (i.e.,Line 7 of Figure 2). As a result, the style format attribute
value ?android:attr/textColorSecondary deÔ¨Åned
inandroid:color (Line 6 of Figure 1) is ignored, causing
the inconsistent look-and-feel as Figures 3(b) and (c) show.
The above example shows how the code changes in the
Android framework induce conÔ¨Åguration compatibility issues.However, it is non-trivial to automatically identify such codechanges. For example, at API level 22, the statement of loadingtheandroid:color attribute value (Line 7 of Figure 2)i s
guarded by a condition in Line 4 as shown in Figure 2.A n
accurate analysis of the loading behavior therefore requirespath-sensitivity. However, since path-sensitive analysis is ex-pensive, it cannot be scaled to the whole Android frameworkthat contains a large amount of code (i.e., 4M+ LOC of APIlevel 30) with long-term update history (i.e., 566K+ commitchanges until April 2021). To provide insights for automat-ically identifying such code changes and facilitating issuedetection, we conducted an empirical study (Section III)o n
real-world issues to understand the common patterns of codechanges that can induce conÔ¨Åguration compatibility issues.
III. E
MPIRICAL STUDY
To facilitate automated detection of conÔ¨Åguration com-
patibility issues, we conducted an empirical study on thecharacteristics and symptoms of such issues in real-worldAndroid apps. The study aims at answering the following tworesearch questions:
‚Ä¢RQ1 (Issue types and root causes): What are the
common types and the corresponding root causes ofconÔ¨Åguration compatibility issues?
‚Ä¢RQ2 (Issue symptoms): What are the common symp-
toms of conÔ¨Åguration compatibility issues?
A. Dataset Collection
We collected bug-related code revisions from well-
maintained open-source Android apps as the empirical dataset.To this end, we searched for suitable subjects on F-Droid[24], which is a famous repository containing high-qualityopen-source Android apps. SpeciÔ¨Åcally, we selected subjects
519that meet the following criteria: (1) maintaining a public
issue tracking system, (2) receiving more than 500 stars onGitHub [4] (popularity), and (3) pushing the latest git commitwithin the most recent three months (well-maintenance). Wechose these three criteria because the conÔ¨Åguration compatibil-ity issues located in these selected subjects are likely to affectmany users due to the popularity of the apps. As a result, 43apps were returned.
In order to locate the conÔ¨Åguration compatibility issues
affecting the 43 selected apps, we used the following two typesof keywords to search for related code revisions:
‚Ä¢Keywords related to Android framework versions. Inpractice, developers often indicate the speciÔ¨Åc versions ofthe Android framework in which compatibility issues oc-cur in the changelog. SpeciÔ¨Åcally, we used two keywords,API (API level for short), and Android [i] where
[i] stands for an integer, to search for Android system
versions in changelogs. Besides, we also looked for coderevisions that contain version-speciÔ¨Åc XML Ô¨Åles, whichare stored in the path that contains a version qualiÔ¨Åerv[L], where [L] represents the minimum API level
applicable to the Ô¨Åles.
‚Ä¢Keywords related to XML conÔ¨Åguration Ô¨Åles in Androidapps. SpeciÔ¨Åcally, we chose the following two keywords:resource, and AndroidManifest, so that they can
effectively cover all types of XML conÔ¨Åguration Ô¨Ålessupported in the Android framework.
In total, 2,376 unique code revisions were identiÔ¨Åed from the43 apps after removing duplicates from the searching results.
Next, we conducted manual analysis on the 2,376 code
revisions to reÔ¨Åne conÔ¨Åguration compatibility issues. SpeciÔ¨Å-cally, we collected the code revisions in three steps. First, wescreened out the code revisions unrelated to valid conÔ¨Ågurationcompatibility issues because some irrelevant code revisions(e.g., introducing new app features) can be accidentally re-turned by our keyword-based search. Second, we collected theincompatibility-inducing attributes and XML elements fromthe revision-related commit logs, bug reports, or code diffs. Toanswer RQ1, the code changes related to the incompatibility-inducing attributes and XML elements should also be iden-tiÔ¨Åed in the update history of the Android framework toinvestigate how these changes can cause issues. Third, toanswer RQ2, we referred to the information of code revisionsand online discussions of similar issues for the consequenceswhen developers did not handle problematic XML elementsor attributes well. Eventually, we collected 196 conÔ¨Ågurationcompatibility issues from code revisions as the empiricaldataset.
B. RQ1: Issue Root Causes
We elaborated on the six common types (or causes) identi-
Ô¨Åed from the 196 conÔ¨Åguration compatibility issues as shown
in Table I.
Unavailable conÔ¨Åguration APIs. The Android framework
loads attribute values by calling conÔ¨Åguration APIs after pars-ing the XML tags in conÔ¨Åguration Ô¨Åles to AttributeSet orTABLE I
COMMON ROOT CAUSES OF CONFIGURA TION COMPA TIBILITY ISSUES
Root Causes Issue #
Type 1 Unavailable conÔ¨Åguration APIs 116 (59.2%)
Type 2 Inconsistent conÔ¨Åguration APIs 42 (21.4%)
Type 3 Inconsistent Android internal XML conÔ¨Åg-
uration Ô¨Åles19 (9.7%)
Type 4 Inconsistent attribute dependencies 9 (4.6%)
Type 5 Inconsistent attribute usages 9 (4.6%)
Type 6 Inconsistent attribute default values 1 (0.5%)
		 	%
	
  
		
			
! 
		 %	 
	
			
"	 		! Class: LayerDrawble
#
$
Added at API level 23
Fig. 4. The Android framework code for loading the attribute value of
android:gravity in the class LayerDrawable.
TypedArray objects. Some statements invoking conÔ¨Ågura-
tion APIs are introduced or removed as the Android framework
evolves, resulting in an inability to load the associated con-Ô¨Åguration attribute values in a certain range of API levels. Inour empirical dataset, we found 116 (59.2%) issues that wereinduced by such a type of code changes. For example, theattribute value of android:gravity in Figure 4is loaded
byLayerDrawable to adjust the gravity for layer alignment
starting from API level 23. A navigation app OsmAnd [28]Ô¨Åled an issue in commit 1bbf578 that the attribute value ofandroid:gravity is not loaded when running at an API
level below 23, causing the incorrect display of graphic userinterfaces.
Inconsistent conÔ¨Åguration APIs. ConÔ¨Åguration APIs in the
Android framework are designed to load attribute values inspeciÔ¨Åc data formats. Compatibility issues can happen whenthe conÔ¨Åguration APIs to load an attribute vary across APIlevels. The example in Figure 1between API levels 22 and 23
falls into this types. Such an issue is caused by the style formatattribute value of android:color not being loaded by
the conÔ¨Åguration API getAttributeIntValue() at API
level 22. The loading of android:color in an unsupported
format can result in app crashes at API level 22. There are intotal 42 (21.4%) issues of this type.
Inconsistent Android internal XML conÔ¨Åguration Ô¨Åles.
The Android framework provides a set of internal XMLconÔ¨Åguration Ô¨Åles that can be referenced by the developersas a part of their apps. Compatibility issues can happen whenthere are changes in those internal XML conÔ¨Åguration Ô¨Åles asthe Android framework evolves. For example, QKSMS [29]commit 6b70a47 describes an issue caused by the internalXML conÔ¨Åguration Ô¨Åle ic_menu_added.xml, which was
introduced at API level 23. There are 19 (9.7%) issues fallinginto this issue type.
Inconsistent attribute dependencies. In the Android
framework, there are dependencies across conÔ¨Åguration at-
520/		
 				
 	
 	 #0
(a)
Class: DatePicker
API level 21API level 19


 .!$	!!(
 "% 
(b))
)-
*-
+,-.!$	!!( "% 
$..
	%&


 .!$	!!(
 "% 
'
Fig. 5. Code changes of loading android:spinnersShown in the class
DatePicker.
tributes. In other words, the runtime behaviors of one attribute
depend on the value of other attributes. We found ninecompatibility issues that were induced by the inconsistentimplementations on attribute dependencies among API levels.For example, open-keychain [30] reported an issue in commitbe06c4c. As Figure 5(a) shows, developers have speciÔ¨Åed the
value of android:spinnersShown astrue to make the
date picker widget be displayed in the spinner mode. Theattribute value cannot be loaded at API level 21 withoutspecifying the value of android:datePickerMode as
spinner, causing the date picker to be displayed in thecalendar mode by default. In this case, the app crashedat API level 21 due to a speciÔ¨Åc implementation of thedate picker in the calendar mode. The code changes inFigure 5(b) show that starting from API level 21, the con-
Ô¨Åguration API for android:spinnersShown is guarded
by the conditional statement that checks whether the value ofandroid:datePickerMode isspinner.
Inconsistent attribute usages. Compatibility issues can
happen when there are inconsistent implementations on howthe Android framework uses the attribute values after beingloaded by conÔ¨Åguration APIs. As Figure 2shows, there is
a change in processing the value of android:color (in
Line 12 and 13) between API levels 21 and 22. The changeavoids the ArrayIndexOutOfBoundsException when
the Android framework parses the XML element in Figure 1
at API level 22. In total, there are nine (4.6%) issues fallinginto this issue type.
Inconsistent attribute default values. There is one (0.5%)
issue caused by inconsistent default values of the attributeandroid:useLevel in the XML tag <shape> between
API levels 21 and 22, as reported in the commit a221442 ofOsmAnd [28].
C. RQ2: Issue Symptoms
We further analyzed the common issue symptoms as be-
low. SpeciÔ¨Åcally, 89 (45.4%) of the 196 issues in our em-
pirical dataset can cause the apps to crash when trigger-ing incompatibility-inducing XML conÔ¨Åguration elements,as shown by the motivating example in Figure 2. Another
88 issues (44.9%) can induce an inconsistent look-and-feelacross different API levels, affecting the apps‚Äô function-alities. For example, the problem reported in the commita221442 of OsmAnd [28] can force the progress bar toalways show a full circle. The remaining 19 issues (9.7%)can cause inconsistent app behaviors beyond crashes andlook-and-feel. For example, the app Slide [31] speciÔ¨Åedandroid:requestLegacyExternalStorage to make
sure the app can still request for the external storage at an APIlevel‚â•29. This shows that conÔ¨Åguration compatibility issues
can cause severe consequences to the app developers.
IV . C
ONF DROID APPROACH
In this section, we illustrate C ONF DROID , which extracts
detection rules for conÔ¨Åguration compatibility issues. C ONF -
DROID is built based on a novel conÔ¨Åguration constraint
that models how the attribute values speciÔ¨Åed in the XMLconÔ¨Åguration Ô¨Åles can be processed by conÔ¨Åguration APIs inthe Android framework. To overcome the limitations of exist-ing static-based approaches (see Section II-B), C
ONF DROID
performs symbolic execution, which follows the control Ô¨Çowsthat can affect the invocations of conÔ¨Åguration APIs, to extractconÔ¨Åguration constraints more precisely. Detection rules canbe subsequently derived by comparing the differences ofextracted conÔ¨Åguration constraints among API levels.
A. Android ConÔ¨Åguration Constraint Model
Our empirical study found that the majority (158/196) of
issues were induced by the inconsistent handling of con-
Ô¨Åguration APIs (Type 1 and Type 2) for a single attributeamong API levels. The inconsistencies can lead to failures
in loading attributes with speciÔ¨Åc data format under certainXML tags at some API levels. Motivated by these Ô¨Åndings, weformulate constraints that govern conÔ¨Åguration APIs, calledAndroid conÔ¨Åguration constraints. Formally, an AndroidconÔ¨Åguration constraint is deÔ¨Åned as a tuple {A,X,F}.
SpeciÔ¨Åcally, Astands for the attribute to be loaded by the
conÔ¨Åguration API, Xis the XML tag where the attribute Ais
located; and Fstands for the data format that can be assigned
toA. An Android conÔ¨Åguration constraint is extracted when
C
ONF DROID Ô¨Ånds a program path in the Android framework
that can invoke the conÔ¨Åguration API to load the attribute A
with data format Funder the XML tag X. Rules for issue
detection can then be identiÔ¨Åed by comparing the differencesin Android conÔ¨Åguration constraints among API levels.
A constraint {A,X,F} for a conÔ¨Åguration API is extracted
as follows. Acan be inferred from the parameter identifying
the attribute to be loaded in the conÔ¨Åguration API call; X
can be inferred from the return values of the conÔ¨ÅgurationAPI call, such as XmlPullParser#getName() in the
program path (e.g., Line 4 of Figure 2).Fcan be inferred
from the conÔ¨Åguration API used to load Asince each
conÔ¨Åguration API can only load attribute values in a speciÔ¨Åcgroup of data formats. Note that one conÔ¨Åguration API cangenerate multiple constraints if it can support loading attributevalues in different data formats. For example, as the codesnippets in Figure 2show, by analyzing the program paths
to the conÔ¨Åguration APIs getAttributeIntValue()
andgetColor(), we can obtain the following constraints
521between API levels 22 and 23.
API level 22:{android:color, item, int} (1)
API level 23:{android:color, item, int} (2)
{android:color, item, styled_int} (3)
As the API descriptions in Android Developers [1] shows,
comparing to getAttributeIntValue(), the conÔ¨Ågura-
tion API getColor() can load integer attribute values in the
style format, an additional Android conÔ¨Åguration constraint forandroid:color (Equation 3) is extracted at API level 23.
B.C
ONF DROID Overview
We propose C ONF DROID to identify Android conÔ¨Åguration
constraints, which can be inferred from conÔ¨Åguration APIinvocations in the Android framework to model the commonissue patterns (Type 1 and Type 2). The identiÔ¨Åed constraintscan be further reÔ¨Åned into a set of compatibility detectionrules based on the differences among the identiÔ¨Åed constraintsacross different API levels.
To identify Android conÔ¨Åguration constraints, we prefer us-
ing static analysis to dynamic analysis. Using dynamic analysisfor the purpose is expensive due to the large search space ofpossible test inputs. For example, a dynamic approach needs togenerate an XML Ô¨Åle as given in Figure 1to reach the conÔ¨Ågu-
ration API in Line 7 of Figure 2. The Ô¨Åle generation involves
searching for (1) the tree hierarchies of XML conÔ¨Ågurationelements (e.g., <item> is set as a child of <selector>),
(2) the XML elements embedding the concerned attributes(e.g., android:color should only be set in <item>), and
(3) other necessary conÔ¨Åguration settings to avoid crash whenparsing XML Ô¨Åles (e.g., android:state_activated in
Line 5). In contrast, static analysis enables us to comparethe approximated behaviors of these APIs without actuallygenerating valid test inputs.
However, the existing techniques [6], [8], [10], [11] analyze
conÔ¨Åguration APIs by conducting path-insensitive analysis,which can be somewhat inaccurate and miss incompatibleconÔ¨Åguration APIs without considering the if-conditions (e.g.,Line 6 in Figure 2). Therefore, a path-sensitive analysis is
necessary to obtain {A,X,F} by solving path constraints
triggering conÔ¨Åguration APIs with the constraint solver. Sym-bolic execution is a powerful path-sensitive analysis technique.Yet, an exhaustive symbolic execution is expensive and cannotscale to the size of the Android framework. In addition,the path constraints triggering the conÔ¨Åguration APIs canbe complex as the Android framework codebase is mixedwith components compiled to native code. To tackle theabove challenges, C
ONF DROID performs backward symbolic
execution from the call site of conÔ¨Åguration APIs. This isbased on a trimmed version of an inter-procedural controlÔ¨Çow graph, which is built by pruning the statements thatare not needed to infer the Android conÔ¨Åguration constraints(Section IV-C). The trimmed-ICFGs are designed to not only
address the scalability by reducing the number of programpaths and complex conditions to be analyzed, but also preservereasonable accuracy while conducting path-sensitive analysis.We illustrate the details of backward symbolic execution andtrimmed-ICFGs in the following parts.
To summarize, C
ONF DROID works as follows.
‚Ä¢CONF DROID builds a trimmed version of interpro-
cedural control Ô¨Çow graphs (trimmed-ICFGs) for
the Android framework code. We choose to build thetrimmed-ICFGs for scalability (Section IV-C).
‚Ä¢CONF DROID performs backward symbolic execution
on the trimmed-ICFGs to extract Android conÔ¨Ågurationconstraints (Section IV-D).
‚Ä¢CONF DROID generates detection rules by compar-
ing the differences of Android conÔ¨Åguration constraintsamong different API levels (Section IV-E).
C. Building Trimmed ICFG
C
ONF DROID performs analysis over a trimmed version of
an inter-procedural control Ô¨Çow graph, which is denoted asICFG
T, to ensure the scalability. Our idea to build such an
ICFGTis inspired by the observation that the code changes
triggering compatibility issues in unavailable conÔ¨Åguration
APIs and inconsistent conÔ¨Åguration APIs primarily reside in
the class that invokes the conÔ¨Åguration APIs to load theincompatibility-inducing attributes. Therefore, C
ONF DROID
builds an ICFGTfor each class that invokes conÔ¨Åguration
APIs by combining the call graph and each method‚Äôs controlÔ¨Çow graph within the class. The strategy limits the extractionof Android conÔ¨Åguration constraints to intra-class analysis.However, such a strategy does not pose a signiÔ¨Åcant impact onthe process of conÔ¨Åguration constraint extraction and detectionrule generation (Section IV-F).
D. Extracting Android ConÔ¨Åguration Constraints
Taking the generated trimmed-ICFGs ICFG
Tas inputs,
CONF DROID extracts Android conÔ¨Åguration constraints by an-
alyzing program paths to the target statements that contain theinvocation of conÔ¨Åguration APIs (Algorithm 1). SpeciÔ¨Åcally, it
takes the following two steps to extract Android conÔ¨Ågurationconstraints. First, starting from each target statement tgtStmt ,
C
ONF DROID performs backward symbolic execution from the
trimmed-ICFG ICFGTgenerated in Section IV-C to extract
the path constraint œÄ(Line 3-9). Such a path constraint œÄ
is a Ô¨Årst-order logic formula that records (1) the conditionsthat should be satisÔ¨Åed to invoke the target statement, and (2)the conÔ¨Åguration API invocation in the target statement (Line3-9). Unlike forward symbolic execution, backward symbolicexecution saves on testing efforts by only exploring relevantprogram statements to reach the target statements. Then, thepath constraints will be further reÔ¨Åned as a set of AndroidconÔ¨Åguration constraints with the help of SMT solver Z3 [32](Line 10-12).
Extracting path constraints. For each target statement
tgtStmt with conÔ¨Åguration API invocations, C
ONF DROID
computes the path constraints œÄby performing backward sym-
bolic execution along ICFGT. SpeciÔ¨Åcally, the analysis will
522Algorithm 1: Extracting Android ConÔ¨Åguration Con-
straints
Input:ICFGT: The trimmed-ICFG for the Android
framework
Output: ACC : Android conÔ¨Åguration constraints
1ACC‚Üê[]
2foreachtgtStmt ‚ààICFGTdo
3 add(tgtStmt, TRUE)toworklist
4 whileworklist is not empty do
5 remove (s/prime,œÜpost)fromworklist
6 foreachswith an edge (s,s/prime)inICFGTdo
7 œÜpre‚ÜêœÜpre‚à®trans(s,œÜ post)
8 ifœÜpre/negationslash=FALSE then
9 add(s,œÜ pre)intoworklist
10 foreachœÄoftgtStmt do
11 acc‚ÜêrefineACC (œÄ)
12 addacc toACC
13return ACC
maintain the symbolic states œÜpre(s)andœÜpost(s)representing
the precondition and postcondition of sinICFGT. The
symbolic states are computed iteratively along ICFGTwith
the symbolic state transformer trans, as deÔ¨Åned in Table II,
fromœÜpost(s)toœÜpre(s). After computing trans(s,œÜ post)for
a statement sandœÜpost, the algorithm merges the result with
œÜprethat is already presented before the statement s(Line 7).
In the presence of loops, we analyze them twice to ensure
that the algorithm terminates and traverses the back edge ofthe loop at least once. The path constraint œÄis obtained from
œÜ
pre of the statements sthat are the entry points of ICFGT.
Taking the Ô¨Årst code snippet in Figure 2as an example,
CONF DROID will analyze the target statement in Line 7, and
compute its path constraint œÄalong the path (7,6,5,4,3) as
follows:
‚Ä¢œÜprein Line 7, tgtStmt =attrs.getAttributeIntValue
(i,color );
‚Ä¢œÜprein Line 6, tgtStmt =attrs.getAttributeIntValue
(i, color )‚àßi=R.attr.color ;
‚Ä¢œÄ=œÜpre in Line 3 (entry point), tgtStmt =
getXml ().getAttributeIntValue( i, color )‚àßi =
R.attr.color ‚àßgetXml ().getName().equals (‚Äúitem ‚Äù);
ReÔ¨Åning Android conÔ¨Åguration constraints. CONF DROID
further reÔ¨Ånes the path constraints œÄas Android conÔ¨Åguration
constraints acc with the help of SMT solver Z3 [32] (Line
10-12). First, C ONF DROID checks whether the target state-
ments are reachable by the path constraints. To achieve this,
CONF DROID substitutes API calls in the path constraints to
symbolic variables according to the return types. C ONF DROID
will declare any variables whose data formats are not modeledin Z3 as integer variables and replace constants (e.g., null)
in the path constraints as integers in queries of Z3. Thetarget statement is reachable if its associated path constraintTABLE II
SPECIFICA TION OF SYMBOLIC STA TE TRANSFORMER trans FOR JAVA
STA TEMENTS .
statement trans(statement,œÜ)
tgtStmt œÜ‚àßtgtStmt
x=opy œÜ[y/x ]
x=yopz œÜ[(yopz )/x]
x=api(y 1,...,y n) œÜ[api(y 1,...,y n)/x]
x.y=z œÜ[z/x.y ]
arr[i]=x œÜ[x/arr [i]]
ifc(branch condition) œÜ‚àßc
‚àóThe string APIs modelled by Z3 (e.g., String#equals())a r e
considered as opinstead of api.
‚àóœÜ[a/b] means replacing the symbolic variable bin the symbolic state œÜ
bya.
is decided to be satisÔ¨Åable by Z3.
CONF DROID then calculates AandXfrom the path con-
straintsœÄ.Ais calculated from the parameter identifying
the attribute to be loaded in the API call (i.e., iin Line
7 of Figure 2).Xis calculated as the return value of the
API call XmlPullParser#getName(). Note that Xwill
be assigned as the class name where œÄlocates when the
concrete value of Xcannot be identiÔ¨Åed, because the Android
framework allows app developers using the class names asXML tags. C
ONF DROID then leverages Z3 to infer all the
possible values of the above symbolic variables for Aand
X. We set the time budget as one minute to Z3 for each
symbolic variable. C ONF DROID discards the cases when (1)
the value of symbolic variables for AorXare undecidable, or
(2) C ONF DROID cannot obtain all possible values of symbolic
variables for AorXwithin the time budget. Such a strategy
does not pose signiÔ¨Åcant problems to the accuracy of AndroidconÔ¨Åguration constraint extraction. Since those discarded casesonly account for 1.8% (29/1534) when applied to API level30 (Section IV-F).
Next, to infer the value of F, we manually built a map
between each conÔ¨Åguration API and its supported data formatbased on its API descriptions. C
ONF DROID further uses the
map of conÔ¨Åguration APIs with their supported data formatsto analyze FfortgtStmt . Finally, C
ONF DROID extracts
Android conÔ¨Åguration constraints acc with all the possible
combinations of A,XandF.
E. Generating Detection Rules
Detection rules are further inferred by comparing the dif-
ferences in Android conÔ¨Åguration constraints between the twoadjacent API levels l
1andl2(l1<l2) as follows.
‚Ä¢CONF DROID reports a rule of attribute loading change
if an attribute Aof the XML tag Xcan be loaded at
the API level l1only but not l2(or atl2only but not l1).
The rules falling into this type are induced by unavailableconÔ¨Åguration APIs (Type 1 in Section III-B).
‚Ä¢CONF DROID reports a rule of data format change if there
are inconsistencies in the supported data formats Ffor
an attribute Aof the XML tag Xbetweenl1andl2. The
523rules falling into this type are induced by inconsistent
conÔ¨Åguration APIs (Type 2 in Section III-B).
For example, by comparing the differences of Android con-
Ô¨Åguration constraints as shown in Section IV-A,C ONF DROID
generates a rule of data format change as follows.
/braceleftBigg
Attribute: android:color XML tag: item
Data format: styled_int API level: [22,23]/bracerightBigg
.
The above rule indicates that assigning the attribute value
in the styled integer format to android:color under the
XML tag <item> can trigger compatibility issues between
API levels 22 and 23.
F . Discussion
The accuracy of detection rules extracted by C ONF DROID
can be affected by the limitations of conducting backward
symbolic execution to infer Android conÔ¨Åguration constraints.First, C
ONF DROID performs an intra-class level backward
symbolic execution, which can cause AandXin Android con-
Ô¨Åguration constraints identiÔ¨Åed inaccurately. Second, C ONF -
DROID discards cases where values of AandXcannot be
inferred due to the inabilities of Z3. Therefore, false positiverules occur when an Android conÔ¨Åguration constraint cannotÔ¨Ånd the equivalent one at other API levels due to the limita-tions of our analysis. Plus, false negative rules are incurredwhen C
ONF DROID fails to generate Android conÔ¨Åguration
constraints for the evolved attributes. However, C ONF DROID
only discards 1.9% (29/1534) of the conÔ¨Åguration API callsites at API level 30, indicating the insigniÔ¨Åcant impact onthe inference of Android conÔ¨Åguration constraints due to theintra-class level symbolic execution and the inabilities of Z3.Although we cannot draw a whole picture of all the cases ofAndroid conÔ¨Åguration evolutions, we Ô¨Ånd that C
ONF DROID is
only unable to generate Android conÔ¨Åguration constraints for21.0% (301/1435) attributes at API level 30. These constraintsare accountable for the false negatives in the warnings reportedby C
ONF DROID (Section V-A ).
V. E V ALUA TION
We implemented C ONF DROID based on Soot [23]. In our
evaluation, we answer the following research questions:
‚Ä¢RQ3 (Effectiveness of detection rule extraction): What
is the effectiveness of C ONF DROID on extracting detec-
tion rules compared with baseline methods?
‚Ä¢RQ4 (Usefulness): Can rules that are uniquely extracted
by C ONF DROID be useful for detecting issues in real-
world Android apps?
A. RQ3: Effectiveness of Detection Rule Extraction
To answer RQ3, we ran C ONF DROID on the Android frame-
work code among API levels between 21 and 30 (inclusive).We evaluated its accuracy in extracting the detection rules ofconÔ¨Åguration compatibility issues. We compared the resultswith the following baseline methods.
‚Ä¢Baseline I: LINT [33], the popular static analyzer ofÔ¨Å-
cially released by Google. By modeling the API levelsTABLE III
EXECUTION TIME FOR RULE EXTRACTION AND VALIDA TION RAT E O F
EXTRACTED RULES .RULES IN LINT ARE HARDCODED .
Method CONF DROID LINT ORPL OCA TOR C DEP
Time 2h58m36s - 2m26s 3m25s
Validation
Rate91.9%(282/307)100.0%(218/218)85.6%(131/153)12.7%(28/220)
when attributes were introduced, L INT can detect con-
Ô¨Åguration compatibility issues caused by an unavailable
attributeAat API level L.
‚Ä¢Baseline II: ORPL OCA TOR [10], the state-of-the-art
technique for extracting attributes in a software system byconducting path-insensitive analysis on its conÔ¨ÅgurationAPIs. We ran ORPL
OCA TOR at different API levels to
extract detection rules for unavailable attribute Aat API
levelL.
‚Ä¢Baseline III: CDEP[11], the state-of-the-art software
misconÔ¨Åguration tool which focuses on analyzing at-tribute dependencies in the software system. We ran
CDEPamong API levels to generate detection rules for
the unavailable dependencies between two attributes A1
andA2at API level L.
Note that we did not choose SCIC [ 8], the state-of-the-art
tool for detecting misconÔ¨Ågurations caused by software evolu-tion, as the baseline since its artifact is not available. Besides,
ORPL
OCA TOR (Baseline II) and CDEP (Baseline III) are
more recently published techniques. The original algorithmsof ORPL
OCA TOR and CDEPcomprise inter-class analyses.
However, they cannot scale up to the Android frameworkand fail to extract any rules. As such, we slightly adapted
ORPL
OCA TOR and CDEPto performing intra-class analyses
in the construction of the two baselines.
Validating detection rules. We considered an issue-
detection rule ras valid if the XML conÔ¨Åguration Ô¨Åles that
satisfy the triggering conditions speciÔ¨Åed by rcan induce
conÔ¨Åguration compatibility issues between two API levels.SpeciÔ¨Åcally, for each issue-detection rule rextracted by
C
ONF DROID and other baselines, we used the attribute name,
the XML tag, and the incompatibility-inducing API levelsspeciÔ¨Åed in ras keywords to search for relevant discussions in
Stack OverÔ¨Çow [34] and GitHub [4]. For those rules rwith no
relevant discussions found, we manually crafted an Androidapp that includes XML conÔ¨Åguration Ô¨Åles satisfying the issue-triggering condition in rto manifest inconsistent behaviors
across API levels. Furthermore, the manifested inconsistentbehaviors should disappear after removing the incompatibility-inducing attribute from the concerned XML conÔ¨ÅgurationÔ¨Åle. A rule ris considered valid if we can Ô¨Ånd a relevant
online discussion or successfully craft an app conÔ¨Årming theexistence of conÔ¨Åguration compatibility issues.
Table IIIshows the execution time as well as the number
of rules extracted by C
ONF DROID and baseline methods. The
524execution time of L INT is inapplicable as the detection rule
is hardcoded. Although the execution time of C ONF DROID
is larger than path-insensitive approaches ORPL OCA TOR and
CDEP,C ONF DROID can extract more valid detection rules
and complete analyzing the Android frameworks within three
hours. In total, C ONF DROID successfully extracts 282 valid
detection rules, achieving a precision of 91.9%. By performingbackward symbolic execution on the conÔ¨Åguration APIs in theAndroid framework, the 65 unique valid detection rules (47unavailable conÔ¨Åguration APIs and 18 inconsistent conÔ¨Ågura-tion APIs) extracted by C
ONF DROID are not found in any of
the three baselines.
On the other hand, the 25 detection rules extracted by
CONF DROID cannot be validated due to the following two
reasons. First, the intra-class level symbolic execution andthe inabilities of using Z3 to process conÔ¨Åguration APIs cancause incomplete conÔ¨Åguration constraint extraction. Second,the Android framework has proposed an internal workaroundat the stage of the Android app compilations, which is notanalyzed by C
ONF DROID . Besides, 14.4% of the rules ex-
tracted by ORPL OCA TOR are invalid due to (1) the adaptation
of intra-class level analysis to ensure scalability, and (2) theinaccuracy of its path-insensitive analysis on the Androidframework. While we have resolved the scalability issuesof the original version of
CDEP, it achieves the lowest rule
validation rate because of (1) extracting incomplete attributedependencies by only performing intra-class level data Ô¨Çowanalysis, and (2) identifying minor code changes that will notinduce compatibility issues.
Still, we found 28 rules (28/218=12.8%) that are uniquely
included in L
INT but not C ONF DROID . The false negative
rules of C ONF DROID concern the theme attributes (e.g., an-
droid:attr/textColorSecondary in Figure 1) whose
value can only be referenced by another attributes in XML.Such theme attributes are not loaded using the Android con-Ô¨Åguration APIs and hence are missed by C
ONF DROID .W e
have not witnessed any false negative rules in C ONF DROID
that were extracted by ORPL OCA TOR because the valid rules
of C ONF DROID and ORPL OCA TOR fall into the pattern of
unavailable conÔ¨Åguration APIs. We also did not witnessedany false negative rules that are extracted by
CDEP. The
CDEPtool is designed based on the change pattern in attribute
dependencies (Type 4 in Section III-B). Such a pattern is not
modelled by C ONF DROID since it only accounts for 4.6% of
the issues in the empirical study dataset. In fact, the validationrules generated by
CDEPare all caused by the introduction
and removal of attributes, which are also dependent on otherattributes in the Android framework. Moreover, false negativescan also be induced by the inabilities of Z3 in processingconÔ¨Åguration APIs. Although it is challenging to measurefalse negatives as we lack an authoritative ground truth, weargue that the number of false negatives can be small since
C
ONF DROID can successfully process 98.1% (1504/1533) of
conÔ¨Åguration APIs, which cover 79.0% (1134/1435) of publicattributes at the API level 30.TABLE IV
NUMBER OF W ARNINGS DETECTED USING THE RULES EXTRACTED BY
CONF DROID AND BASELINES
CONF DROID LINT ORPL OCA TOR C DEP
D 50,157 9,998 8,424 4,304
Fv 46,580 7,316 5,433 3,595
Flib 41,790 5,007 4,134 4,290
D‚àíFv‚àíFlib 688 435 54 140
D: Warnings generated by rules only.
Fv: False warnings identiÔ¨Åed by API level Ô¨Ålter.
Flib: False warnings identiÔ¨Åed by support library Ô¨Ålter.
D‚àíFv‚àíFlib: The Ô¨Ånal output after Ô¨Åltering false warnings by FvandFlib
B. RQ4: Usefulness
To answer RQ4, we checked whether the rules of C ONF -
DROID could be applied to detect real issues with the com-
parison of three baselines. Note that Android has introducedvarious protection mechanisms documented in Android De-velopers [1] to prevent conÔ¨Åguration compatibility issues. Theprotection mechanisms include (1) checking the API levelranges in which the XML conÔ¨Åguration Ô¨Åle can be used and(2) using the Android support library (AndroidX) to parseXML conÔ¨Åguration Ô¨Åles. Leveraging detection rules alonewithout considering any protection mechanisms can inducea large number of false warnings. Therefore, we built twofalse warning Ô¨Ålters F
vandFlibto investigate the impact
of protection mechanisms on issue detection. SpeciÔ¨Åcally, Fv
checks whether the XML conÔ¨Åguration Ô¨Åle can be appliedto incompatibility-inducing API levels. App developers canprovide different copies of the XML conÔ¨Åguration Ô¨Åles fordifferent API levels with the identiÔ¨Åer -v (e.g., -v24 in
layout-v24/a.xml). For an issue reported by a rule r
with problematic API levels [l
1,l2],Fvconsiders the API level
identiÔ¨Åer with the parameter value of minSdkVersion to
check whether the XML Ô¨Åle can be used at l1.Fvalso checks
whether there is another copy of the Ô¨Åle for API level l2.
The reported issue is considered as invalid if the XML Ô¨Ålecannot be used in both l
1andl2.Flibchecks whether an XML
conÔ¨Åguration Ô¨Åle can be parsed by the Android support library(AndroidX) instead. Here, we consider an XML conÔ¨ÅgurationÔ¨Åle to be free of compatibility issues if it is only referencedby the APIs or attributes deÔ¨Åned in the library. We then builtfour different variants of issue detectors with two Ô¨Ålters F
v
andFlibas Table IVshows.
We applied the above variants to detect issues in real-world
Android apps. We crawled 116 open-source Android apps inF-Droid [24] with at least 50 stars in GitHub [4] and thelast git commit made within the past six months. We furthercollected 200 closed-source apps marked as top-ranked inAppBrain [25]. None of these 316 apps overlaps with thoseused in our empirical study (Section III) to avoid the risk of
overÔ¨Åtting.
Table IV shows the number of warnings produced by
each variant of issue detectors. We can see that the numberof false warnings is signiÔ¨Åcantly less when combining two
525false warning Ô¨Ålters FvandFlib, showing that the above
two mechanisms are often adopted to handle compatibility
issues. Several frequently-used attributes contribute to thenumber of warnings reported in Table IV. For example, de-
velopers intensively use an incompatibility-inducing attributeandroid:strokeColor in their apps. F
vhelps reduce
12,445 false warnings that developers have properly used suchan attribute with API level identiÔ¨Åers.
Considering the output of D‚àíF
v‚àíFlib, the rules of C ONF -
DROID generated 688 issue warnings, outperforming the other
baseline methods. Note that the number of warnings can bevaried depending on the frequency of which incompatibility-inducing attributes are used in apps. As for the 65 rulesthat were uniquely identiÔ¨Åed by C
ONF DROID , 11 of them
were activated to output 253 warnings from 74 apps, amongwhich 90 warnings were from 20 open-source apps, while theremaining 163 warnings were from 56 closed-source apps.The above results show that the rules uniquely generated by
C
ONF DROID can be leveraged to generate issue reports that
are unknown to other baselines.
We then conducted manual reproduction trying to mani-
fest inconsistent runtime behaviors on the warnings that areuniquely reported by rules in C
ONF DROID . SpeciÔ¨Åcally, we
Ô¨Årst tried to build test cases to reach the Activity using
the XML element in the issue reports. Then, we tried to man-ifest the runtime behavior controlled by the incompatibility-inducing attributes in the XML element by reading the codelogic of the Activity. Since we have no access to the
source code of the closed-source apps, we analyzed the apps‚Äôcode logic by reading the smali code decompressed fromtheir apk Ô¨Åles. An issue is considered reproducible if we canobserve inconsistent runtime behavior by building a test casebased on the above two steps. We successfully reproduced107 warnings in 30 apps (67 warnings in 12 open-sourceapps and 40 warnings in 18 closed-source apps). We failedto reproduce the remaining warnings for the following threereasons. First, the XML elements where the incompatibility-inducing attributes are located were not reachable becauseof special triggering conditions (e.g., paying for unlockinghidden functionalities). Second, false warnings were generatedbecause it cannot recover the workaround of conÔ¨Ågurationcompatibility issues made by app developers. Third, the appwas obfuscated so that it is difÔ¨Åcult for us to understand theapp‚Äôs runtime behavior through analyzing the smali code.
We further reported the 67 reproducible warnings con-
cerning 12 open-source apps to the original app developers.For each app, we only sent one issue report containing allwarnings found in it. Table Vshows the issue reports that
have been sent to the developers. The distribution of reportedissue warnings depends on the attribute usages in differentapps. For example, our issue detector reports 42 warnings inthe evaluation subject AndOTP since it frequently uses theattribute android:fillColor to deÔ¨Åne the colors in the
app icons. The processing of android:fillColor in the
Android framework has been changed between API levels 23and 24, causing an inconsistent look-and-feel on the app‚ÄôsTABLE V
ISSUE REPORTS
App ID Warnings ConÔ¨Årmed Fixed
AndOTP [35] 539142 42 42
Aria2App [36]4 2 2 0 0
Dash Wallet [37] 648 3 0 0
document-viewer [38] 328 1 0 0
FastScroll [39]3 6111 0
GoodTime [40] 197111 1
Metro [41]5 5 6 0 0
Kontalk [42] 1315 1 0 0
openWorkout [43]4 5 1 0 0
PersianCalendar [44] 621155 5
Twire [45] 119133 3
UniPatcher [46]5 2 1 0 0
Total -6 7 5 25 1
1Issues that have received replies from app developers.
icons. So far, 52 warnings concerning Ô¨Åve apps have beenconÔ¨Årmed, and 51 warnings in four apps have been Ô¨Åxed bydevelopers. We did not report issues for closed-source apps asthey do not have a public issue tracker. Instead, we releasedthe reproduction results of both open-source and closed-sourceapps on our project website [26]. The above conÔ¨Årmed orÔ¨Åxed warnings demonstrate the usefulness of rules extractedby C
ONF DROID to facilitate conÔ¨Åguration compatibility issue
detection.
VI. T HREA TS TO VALIDITY
Keywords for dataset collection. When collecting conÔ¨Åg-
uration compatibility issues, we used two sets of keywordsrelated to API levels and XML Ô¨Åles. Although differentapps may use different app-speciÔ¨Åc terms to refer to thesame concepts, such app-speciÔ¨Åc terms are hard to collect.Besides, using app-speciÔ¨Åc terms as keywords can returnmany irrelevant results. Therefore, our dataset was collectedprimarily using the above two groups of general keywords,which retrieves 196 conÔ¨Åguration compatibility issues.
Generality of our empirical Ô¨Åndings. In this paper, we
studied the conÔ¨Åguration compatibility issues in the Androidapps and further proposed C
ONF DROID to facilitate automatic
issue detection. Our empirical Ô¨Åndings may not be generalizedto other types of software systems. We chose Android as ourstudy platform because it is representative of a popular systemsupporting a high degree of conÔ¨Ågurability in thousands of at-tributes. The open-source Android framework code provides anice foundation for us to study the root causes of conÔ¨Ågurationcompatibility issues.
Empirical subject selection. The Ô¨Åndings from the issues
in the open-source Android app can be biased to the subjectsselected in our empirical study. We mitigated the threat byselecting a signiÔ¨Åcant number of issues and apps. As a result,the study was based on 196 issues from 43 open source appsthat are popular and well-maintained.
Evolving Android framework versions. The Android API
levels that we studied may become obsolete over time. It is a
526threat common to most studies based on Android. To mitigate
the threat, we base our study on the latest API levels.
Manual inspections and developers‚Äô feedbacks. We man-
ually inspected our evaluation to validate issues detected by
CONF DROID . The manual process can be subject to errors. We
also submitted the validated ones to the original app developersfor their feedback. However, several issue reports are stillpending. This is most likely because some developers tendto be less responsive to the issue reports in the issue tracker.To address the threat that our reported issues may not be realones, our manual process involves validating detection rulesand issuing warnings through actual executions. We also makeour validation steps and artifacts publicly available [26].
VII. R
ELA TED WORK
A. Software MisconÔ¨Ågurations
There are plenty of works [6]‚Äì[12] on detecting software
misconÔ¨Ågurations. For example, Behrang et al. [8] proposed
SCIC to study the attributes that cannot take effects because
of software evolution. Dong et al. [10] proposed ORPL O-
CA TOR to detect inconsistencies between documentations and
conÔ¨Åguration attributes in system code. Recently, Chen etal. [11] proposed
CDEPto extract attribute dependencies from
source code. Although these approaches can be adapted todetect compatibility issues across multiple system versions,the proposed path-insensitive analyses are ineffective for theAndroid framework. It is because the loading of conÔ¨Ågurationattributes in the Android framework is commonly guarded byvariables deÔ¨Åned in the same conÔ¨Åguration class. In contrast,
C
ONF DROID conducts intra-class level path-sensitive analysis
for more precise detection of compatibility issues.
There are works studying misconÔ¨Ågurations caused by sys-
tem evolution [47], [48]. For example, Zhang et al. [47] pro-posed a technique for debugging software misconÔ¨Ågurationsinduced by software evolution. However, the technique re-quires developers to provide test cases to manifest such issues,limiting its applicability. Recently, Zhang et al. [48] conductedan empirical study to understand how the conÔ¨Åguration designand implementation evolve in cloud systems. The study doesnot provide a technique for issue detection. C
ONF DROID Ô¨Ålls
the gap by incorporating automated techniques to extract issue-detection rules, which can be readily deployed at L
INT for
issue detection.
There are also a few related works [49]‚Äì[52] on automated
software misconÔ¨Åguration diagnosis. However, their researchgoal is to help understand the root causes of known softwaremisconÔ¨Ågurations. Their application scenario differs from thatof C
ONF DROID where the misconÔ¨Ågurations are unknown.
B. Android Compatibility Issues
A few studies have been conducted on Android compat-
ibility issues. For example, Wei et al. [16], [17] studiedthe root causes, symptoms, and Ô¨Åxing practices of Androidcompatibility issues. Huang et al. [19] studied compatibilityissues in Android callback APIs. Hu et al. [53] found Androidcompatibility issues in the WebView component. Cai et al. [54]studied the compatibility issues occurring at installation timeand runtime. Xia et al. [55] studied the practice of app devel-opers to handle Android compatibility issues. These studiesdo not cover the common root causes and patterns of AndroidconÔ¨Åguration compatibility issues, which are prevalent and cancause severe consequences in Android apps.
Researchers have proposed a set of tools to detect Android
compatibility issues. First, dynamic-based approaches [14],[15] can generate tests to identify app GUI inconsistenciesacross Android devices. These approaches adopt a randomtest generation strategy, which is ineffective in triggeringthe inconsistencies within the huge search space of anapp‚Äôs conÔ¨Åguration attributes. Second, existing static-basedapproaches [16]‚Äì[22] take a set of predeÔ¨Åned patterns tofacilitate compatibility issue detection in Android apps. How-ever, their approaches can only be leveraged to detect issuescaused by problematic API invocations. These approaches areinapplicable for the detection of conÔ¨Åguration compatibilityissues in Android apps. Besides, L
INT [33], a popuplar static-
based bug detection tool in the industry [56], can only detectconÔ¨Åguration compatibility issues due to the introduction ofnew attributes. In comparison, C
ONF DROID encodes common
issue patterns to extract detection rules from the Androidframework. The evaluation results show that such rules candetect issues that were previously unknown to app developers.
VIII. C
ONCLUSION &F UTURE WORK
To help app developers tackle conÔ¨Åguration compatibility
issues, in this study, we Ô¨Årst collected 196 conÔ¨Ågurationcompatibility issues to empirically understand the commonroot causes and patterns of such issues. Based on the Ô¨Åndings,we further proposed C
ONF DROID , which encodes common
issue patterns to automatically extract detection rules forconÔ¨Åguration compatibility issues. The results show that therules extracted by C
ONF DROID can facilitate detecting issues
that were previously unknown to app developers. In the future,we plan to investigate automated repair techniques for conÔ¨Åg-uration compatibility issues in Android apps. We also plan todesign a technique that can facilitate automated validation ofconÔ¨Åguration compatibility issue to minimise manual efforts.
A
CKNOWLEDGMENT
We sincerely thank anonymous reviewers for their valuable
comments. This work was supported by the National Natu-ral Science Foundation of China (Grant No. 61932021, No.61802164 and No. 62002125), Hong Kong RGC/GRF (GrantNo. 16211919), Hong Kong RGC/RIF (Grant No. R5034-18),and Guangdong Basic and Applied Basic Research Foundation(Grant No. 2021A1515011562). Huaxun Huang was supportedby the Hong Kong PhD Fellowship Scheme. Lili Wei wassupported by the Hong Kong RGC Postdoctoral FellowshipScheme.
R
EFERENCES
[1] ‚ÄúAndroid developers,‚Äù [EB/OL], https://developer.android.com/, 2021.
[2] ‚ÄúBug 1486200: Crash in java.lang.nullpointerexception,‚Äù [EB/OL], http
s://bugzilla.mozilla.org/show bug.cgi?id=1486200, 2021.
527[3] ‚Äúgecko-dev,‚Äù [EB/OL], https://github.com/mozilla/gecko-dev, 2021.
[4] ‚ÄúGithub,‚Äù [EB/OL], https://github.com, 2021.
[5] ‚ÄúDifference reports between api 28 and 29,‚Äù [EB/OL], https://develope
r.android.com/guide/topics/manifest/uses-sdk-element, 2021.
[6] A. Rabkin and R. Katz, ‚ÄúStatic extraction of program conÔ¨Åguration op-
tions,‚Äù in Proceedings of the 33rd International Conference on Software
Engineering (ICSE), 2011, pp. 131‚Äì140.
[7] T. Xu, J. Zhang, P . Huang, J. Zheng, T. Sheng, D. Y uan, Y . Zhou,
and S. Pasupathy, ‚ÄúDo not blame users for misconÔ¨Ågurations,‚Äù in
Proceedings of the ACM SIGOPS 24th Symposium on Operating SystemsPrinciples (SOSP), 2013, pp. 244‚Äì259.
[8] F. Behrang, M. B. Cohen, and A. Orso, ‚ÄúUsers beware: Preference
inconsistencies ahead,‚Äù in Proceedings of the 2015 10th Joint Meeting on
F oundations of Software Engineering (ESEC/FSE), 2015, pp. 295‚Äì306.
[9] T. Xu, X. Jin, P . Huang, Y . Zhou, S. Lu, L. Jin, and S. Pasupathy,
‚ÄúEarly detection of conÔ¨Åguration errors to reduce failure damage,‚Äù inProceedings of the 12th USENIX Symposium on Operating SystemsDesign and Implementation (OSDI), 2016, pp. 619‚Äì634.
[10] Z. Dong, A. Andrzejak, D. Lo, and D. Costa, ‚ÄúOrplocator: Identifying
read points of conÔ¨Åguration options via static analysis,‚Äù in Proceedings
of the 27th International Symposium on Software Reliability Engineering(ISSRE), 2016, pp. 185‚Äì195.
[11] Q. Chen, T. Wang, O. Legunsen, S. Li, and T. Xu, ‚ÄúUnderstanding and
discovering software conÔ¨Åguration dependencies in cloud and datacentersystems,‚Äù in Proceedings of the 28th ACM Joint Meeting on European
Software Engineering Conference and Symposium on the F oundationsof Software Engineering (ESEC/FSE), 2020, pp. 362‚Äì374.
[12] J. Toman and D. Grossman, ‚ÄúStaccato: A bug Ô¨Ånder for dynamic
conÔ¨Åguration updates,‚Äù in Proceedings of the 30th European Conference
on Object-Oriented Programming (ECOOP), 2016, pp. 24:1‚Äì24:25.
[13] E. Reisner, C. Song, K.-K. Ma, J. S. Foster, and A. Porter, ‚ÄúUsing
symbolic evaluation to understand behavior in conÔ¨Ågurable softwaresystems,‚Äù in Proceedings of the 32nd International Conference on
Software Engineering (ICSE), 2010, pp. 445‚Äì454.
[14] M. Fazzini and A. Orso, ‚ÄúAutomated cross-platform inconsistency
detection for mobile apps,‚Äù in Proceedings of the 32nd IEEE/ACM
International Conference on Automated Software Engineering (ASE),2017, pp. 308‚Äì318.
[15] T. Ki, C. M. Park, K. Dantu, S. Y . Ko, and L. Ziarek, ‚ÄúMimic: Ui
compatibility testing system for android apps,‚Äù in Proceedings of the
41st International Conference on Software Engineering (ICSE), 2019,pp. 246‚Äì256.
[16] L. Wei, Y . Liu, and S.-C. Cheung, ‚ÄúTaming android fragmentation:
Characterizing and detecting compatibility issues for android apps,‚ÄùinProceedings of the 31st IEEE/ACM International Conference on
Automated Software Engineering (ASE), 2016, pp. 226‚Äì237.
[17] L. Wei, Y . Liu, S.-C. Cheung, H. Huang, X. Lu, and X. Liu, ‚ÄúUn-
derstanding and detecting fragmentation-induced compatibility issuesfor android apps,‚Äù IEEE Transactions on Software Engineering (TSE),
vol. 46, no. 11, pp. 1176‚Äì1199, 2020.
[18] L. Wei, Y . Liu, and S.-C. Cheung, ‚ÄúPivot: learning api-device cor-
relations to facilitate android compatibility issue detection,‚Äù in 2019
IEEE/ACM 41st International Conference on Software Engineering(ICSE), 2019, pp. 878‚Äì888.
[19] H. Huang, L. Wei, Y . Liu, and S.-C. Cheung, ‚ÄúUnderstanding and
detecting callback compatibility issues for android applications,‚Äù in Pro-
ceedings of the 33rd ACM/IEEE International Conference on AutomatedSoftware Engineering (ASE), 2018, pp. 532‚Äì542.
[20] L. Li, T. F. Bissyand ¬¥e, H. Wang, and J. Klein, ‚ÄúCid: Automating
the detection of api-related compatibility issues in android apps,‚Äù inProceedings of the 27th ACM SIGSOFT International Symposium onSoftware Testing and Analysis (ISSTA), 2018, pp. 153‚Äì163.
[21] D. He, L. Li, L. Wang, H. Zheng, G. Li, and J. Xue, ‚ÄúUnderstanding
and detecting evolution-induced compatibility issues in android apps,‚ÄùinProceedings of the 33rd ACM/IEEE International Conference on
Automated Software Engineering (ASE), 2018, pp. 167‚Äì177.
[22] C. Li, C. Xu, L. Wei, J. Wang, J. Ma, and J. Lu, ‚ÄúElegant: Towards effec-
tive location of fragmentation-induced compatibility issues for android
apps,‚Äù in Proceedings of the 25th Asia-PaciÔ¨Åc Software Engineering
Conference (APSEC), 2018, pp. 278‚Äì287.
[23] P . Lam, E. Bodden, O. Lhot ¬¥ak, and L. Hendren, ‚ÄúThe soot framework
for java program analysis: a retrospective,‚Äù in Cetus Users and Compiler
Infastructure Workshop (CETUS), vol. 15, no. 35, 2011.
[24] ‚ÄúF-droid,‚Äù [EB/OL], https://f-droid.org, 2021.[25] ‚ÄúAppbrain,‚Äù [EB/OL], https://www.appbrain.com, 2021.
[26] ‚ÄúConfdroid webpage,‚Äù [EB/OL], https://sites.google.com/view/confdroi
d, 2021.
[27] K. Xu, Y . Li, R. H. Deng, and K. Chen, ‚ÄúDeepreÔ¨Åner: Multi-layer
android malware detection system applying deep neural networks,‚ÄùinProceedings of 2018 IEEE European Symposium on Security and
Privacy (EuroS&P), 2018, pp. 473‚Äì487.
[28] ‚ÄúOsmand,‚Äù [EB/OL], https://github.com/osmandapp/OsmAnd, 2021.
[29] ‚ÄúQksms,‚Äù [EB/OL], https://github.com/moezbhatti/qksms, 2021.
[30] ‚Äúopen-keychain,‚Äù [EB/OL], https://github.com/open-keychain/open-key
chain, 2021.
[31] ‚ÄúSlide,‚Äù [EB/OL], https://github.com/ccrama/Slide, 2021.
[32] ‚ÄúZ3 - an efÔ¨Åcient theorem prover,‚Äù [EB/OL], https://z3prover.github.io/
api/html/, 2021.
[33] ‚ÄúImprove your code with lint checks,‚Äù [EB/OL], https://developer.andr
oid.com/studio/write/lint, 2021.
[34] ‚ÄúStack overÔ¨Çow,‚Äù [EB/OL], https://stackoverflow.com/, 2021.
[35] ‚Äúandotp,‚Äù [EB/OL], https://github.com/andOTP/andOTP, 2021.
[36] ‚ÄúAria2app,‚Äù [EB/OL], https://github.com/devgianlu/Aria2App, 2021.
[37] ‚Äúdash-wallet,‚Äù [EB/OL], https://github.com/dashevo/dash-wallet, 2021.
[38] ‚Äúdocument-viewer,‚Äù [EB/OL], https://github.com/SufÔ¨ÅcientlySecure/doc
ument-viewer, 2021.
[39] ‚ÄúUnipatcher,‚Äù [EB/OL], https://github.com/zhanghai/AndroidFastScroll,
2021.
[40] ‚ÄúGoodtime,‚Äù [EB/OL], https://github.com/adrcotfas/Goodtime, 2021.
[41] ‚ÄúMetro,‚Äù [EB/OL], https://github.com/MuntashirAkon/Metro, 2021.
[42] ‚ÄúKontalk,‚Äù [EB/OL], https://github.com/kontalk/androidclient, 2021.
[43] ‚Äúopenworkout,‚Äù [EB/OL], https://github.com/oliexdev/openWorkout,
2021.
[44] ‚ÄúDroidpersiancalendar,‚Äù [EB/OL], https://github.com/persian-calendar/
DroidPersianCalendar, 2021.
[45] ‚ÄúTwire,‚Äù [EB/OL], https://github.com/twireapp/Twire, 2021.
[46] ‚ÄúUnipatcher,‚Äù [EB/OL], https://github.com/btimofeev/UniPatcher, 2021.
[47] S. Zhang and M. D. Ernst, ‚ÄúWhich conÔ¨Åguration option should i
change?‚Äù in Proceedings of the 36th International Conference on
Software Engineering (ICSE), 2014, pp. 152‚Äì163.
[48] Y . Zhang, H. He, O. Legunsen, S. Li, W. Dong, and T. Xu, ‚ÄúAn
evolutionary study of conÔ¨Åguration design and implementation in cloudsystems,‚Äù in Proceedings of the 43rd International Conference on
Software Engineering (ICSE) , 2021, pp. 188‚Äì200.
[49] M. Attariyan, M. Chow, and J. Flinn, ‚ÄúX-ray: Automating root-cause
diagnosis of performance anomalies in production software,‚Äù in Pro-
ceedings of the 10th USENIX conference on Operating Systems Designand Implementation (OSDI), 2012, pp. 307‚Äì320.
[50] A. Rabkin and R. Katz, ‚ÄúPrecomputing possible conÔ¨Åguration error diag-
noses,‚Äù in Proceedings of the 26th IEEE/ACM International Conference
on Automated Software Engineering (ASE), 2011, pp. 193‚Äì202.
[51] S. Zhang and M. D. Ernst, ‚ÄúAutomated diagnosis of software conÔ¨Ågu-
ration errors,‚Äù in Proceedings of the 35th International Conference on
Software Engineering (ICSE), 2013, pp. 312‚Äì321.
[52] S. Zhang and M. Ernst, ‚ÄúProactive detection of inadequate diagnostic
messages for software conÔ¨Åguration errors,‚Äù in Proceedings of the 2015
International Symposium on Software Testing and Analysis (ISSTA),2015, pp. 12‚Äì23.
[53] J. Hu, L. Wei, Y . Liu, S.-C. Cheung, and H. Huang, ‚ÄúA tale of two cities:
How webview induces bugs to android applications,‚Äù in Proceedings of
the 33rd ACM/IEEE International Conference on Automated SoftwareEngineering (ASE), 2018, pp. 702‚Äì713.
[54] H. Cai, Z. Zhang, L. Li, and X. Fu, ‚ÄúA large-scale study of application
incompatibilities in android,‚Äù in Proceedings of the 28th ACM SIGSOFT
International Symposium on Software Testing and Analysis (ISSTA),2019, pp. 216‚Äì227.
[55] H. Xia, Y . Zhang, Y . Zhou, X. Chen, Y . Wang, X. Zhang, S. Cui,
G. Hong, X. Zhang, M. Yang, and Z. Yang, ‚ÄúHow android developershandle evolution-induced api compatibility issues: A large-scale study,‚ÄùinProceedings of the 42nd International Conference on Software
Engineering (ICSE), 2020, pp. 886‚Äì898.
[56] L. Wei, Y . Liu, and S.-C. Cheung, ‚ÄúOasis: prioritizing static analysis
warnings for android apps based on app user reviews,‚Äù in Proceedings
of the 2017 11th Joint Meeting on F oundations of Software Engineering(FSE), 2017, pp. 672‚Äì682.
528