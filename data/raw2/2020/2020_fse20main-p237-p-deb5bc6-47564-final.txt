Past-SensitivePointer Analysis forSymbolic Execution
DavidTrabish
Tel Aviv University
Israel
davivtra@post.tau.ac.ilTimotej Kapus
ImperialCollegeLondon
UnitedKingdom
t.kapus@imperial.ac.uk
NoamRinetzky
Tel Aviv University
Israel
maon@cs.tau.ac.ilCristian Cadar
ImperialCollegeLondon
UnitedKingdom
c.cadar@imperial.ac.uk
ABSTRACT
Weproposeanovelfine-grainedintegrationofpointeranalysiswith
dynamicanalysis,includingdynamicsymbolicexecution.Thisis
achieved via past-sensitive pointer analysis, an on-demand pointer
analysisinstantiatedwithanabstractionofthedynamicstateon
whichitisinvoked.
Weevaluateourtechniqueinthreeapplicationscenarios:chopped
symbolicexecution,symbolicpointerresolution,andwriteintegrity
testing.Our preliminary results showthat the approachcan have a
significantimpactinthesescenarios,byeffectivelyimprovingthe
precisionofstandardpointeranalysiswithonlyamodestperfor-
mance overhead.
CCS CONCEPTS
¬∑Softwareanditsengineering ‚ÜíSoftwaretestinganddebug-
ging.
KEYWORDS
Symbolic Execution,Pointer Analysis
ACMReference Format:
DavidTrabish,TimotejKapus,NoamRinetzky,andCristianCadar.2020.
Past-SensitivePointerAnalysisforSymbolicExecution.In Proceedingsofthe
28th ACM Joint European Software Engineering Conference and Symposium
on the Foundations of Software Engineering (ESEC/FSE ‚Äô20), November 8≈õ
13, 2020, Virtual Event, USA. ACM, New York, NY, USA, 12pages.https:
//doi.org/10.1145/3368089.3409698
1 INTRODUCTION
Wepresentanoveltechniqueforincreasingtheprecisionof pointer
analysis[32,40,43,44] when used in the context of dynamic anal-
ysis and dynamic symbolicexecution .1We show that theincreased
1Wenotethatfromtheperspectiveofrunningapointeranalysisinadynamiccontext,
the dynamic analysis scenario is simply a particular case of the dynamic symbolic
executiononeinwhichasinglepathisexploredandnosymbolicdata(inparticular
Permissionto make digitalor hard copies of allorpart ofthis work for personalor
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACM
mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,
topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ESEC/FSE ‚Äô20, November 8≈õ13, 2020, Virtual Event, USA
¬©2020 Associationfor Computing Machinery.
ACM ISBN 978-1-4503-7043-1/20/11...$15.00
https://doi.org/10.1145/3368089.3409698precision, whichcomeswith a modestperformanceoverhead, can
benefit three applications: chopped symbolic execution,symbolic
pointer resolution, andwriteintegritytesting.
Our Approach. Existing dynamic analyses which employ static
pointer analysis run the pointer analysis first and then utilize its
results[2,7,13,33,47].Weproposeamorefine-grainedintegration:
invoke the pointer analysis on-demand whenever the symbolic ex-
ploration reaches a certain program point2where the points-to
information is needed, and at that point instantiate the analysis
withapath-specific abstractionofthecurrentsymbolicstate.Specif-
ically, our abstraction distinguishes objects already allocated in the
past, which are assigned a unique allocation site, from objects allo-
catedinthefuture,whichcanshareallocationsites,toanextent
depending on the sensitivity of the pointer analysis. We call our
analysispast-sensitivepointeranalysis( PSPA).
Applications. Manydynamicanalysistechniques,suchasvarious
formsofintegrityenforcement[ 2,7,13]anddifferentextensions
of dynamic symbolic execution [ 33,42,47] rely on the results of
a pointer analysis. In our paper, we specifically explore Chopped
SymbolicExecution [47],SymbolicPointerResolution [8,33,48],and
Write Integrity Testing [2].
ChoppedSymbolicExecution. Dynamicsymbolicexecution(DSE)[ 12]
computes an under-approximation of the program‚Äôs behavior by
systematicallyexploring multiple,butnotall,programpaths.Un-
fortunately,scalingsymbolicexecutiontohandlelargeprogramsis
challenging due tothe well-knownstate-explosion problem. Thus,
attemptshavebeen madeto utilizeinformation gainedbypointer
analysisduringthesymbolicexploration[ 33,42,47].Choppedsym-
bolicexecution[ 47]isaDSEvariantthatcanskipcallstofunctions
thatusers deemasirrelevant tothecode theywanttoanalyze.To
safely do so, the analysis relies on the results of a pointer analysis,
whichprovidesconservativeinformationaboutthe sideeffects of
theskippedfunctioncalls,i.e.thememorylocationsthatmaybe
modified by their code. If those locations are later read by the ana-
lyzedcode,a recoveryprocesstakesplace,inwhichrelevantparts
oftheskippedcodeareexecuted.Ofcourse,themoreprecisethe
results of the pointer analysis, the fewer unnecessary recoveries
takeplaceandthusthemoreeffectivethetechnique.Weshowthat
by running the pointer analysis in the symbolic state just before
symbolicpointers)arepresent.Therefore,intheremainingofthepaperwemainly
discuss ourtechnique in the moregeneral context of symbolicexecution.
2Technically, weonly invokepointer analysis at procedurecallsites.
197ESEC/FSE ‚Äô20, November8‚Äì13,2020,VirtualEvent, USA David Trabish, Timotej Kapus, Noam RinetzkyandCristian Cadar
skippedfunctioncalls,thenumberofrecoveriescanbesignificantly
reduced(ƒü 6.2).
Symbolic Pointer Resolution. Symbolic pointers present a particular
challengeforDSE[ 8,33,48].ModernDSEsystemstypicallymap
each symbolic memory object into a different solver array. Queries
involving symbolic memory objects are then easily translated into
SMT constraints involving the corresponding SMT arrays. Since
symbolicpointerscanpotentiallyrefertomultiplememoryobjects,
the DSE system first needs to find all the memory objects to which
the pointer could refer to, so that the right SMT arrays can be
referenced.Inoneofthemostpopularmemorymodels,the forking
model[8,10,38], the DSE system scans each memory object in
turn, issuing solver queries to determine if the pointer can refer
to that memory object. If a pointer analysis determines that the
pointercannotrefertoanobject,thatobjectcanbeignored,saving
potentiallyexpensivesolverqueries.Inthispaper,weshowthatour
approachcansignificantlyspeedupsymbolicpointerresolution,
byeliminatingamuchlargernumberofsolverqueriescompared
to astandardstaticpointer analysis(ƒü 6.4).
Write Integrity Testing (WIT). WIT [2] is a well-known defense
against certain classes of security attacks. At a high level, WIT
uses a pointer analysis to determine which pointers are allowed
to access which objects. For instance, the pointer analysis might
determinethatapointer pcanonlyrefertoobjects aandb.Dynamic
instrumentation is then added to enforce the results of the static
analysis√êe.g., if pis used to access another object cvia a buffer
overflow,executionissafelyterminated.Ofcourse,theprecisionof
the pointer analysis has a direct impact on the effectiveness of the
analysis.InourexperimentswithWIT[ 2],weshowthatcomputing
theanalysisinthedynamiccontextwheretheprogramhasalready
finisheditsinitializationcanleadtosignificantimprovementsin
precision andthus effectiveness (ƒü 6.3).
Maincontributions. Ourmain results canbe summarized asfol-
lows:
(1)We propose past-sensitivity √êa new form of sensitivity in
pointer analysis which makes use of the dynamic context
underwhichitisinvoked.
(2)Wedescribeatechniqueforgeneratingpath-specificpointer
abstractionsinthecontextofdynamicanalysisandsymbolic
execution.
(3)We provide an implementation based on the state-of-the-
art symbolic execution engine KLEE [ 8], which we make
available as open source.3
(4)We show the benefits of our technique in three different
scenarios: chopped symbolic execution, symbolic pointer
resolution, andwriteintegritytesting.
2 OVERVIEW OFOURAPPROACH
Wedemonstrateourapproachbyapplyingittothesymbolicexecu-
tion ofthe simpleprogram showninFigure 1.4First, the program
allocates two hash tables ( t1andt2), and inserts even elements
3https://srg.doc.ic.ac.uk/projects/pspa/
4The example demonstratescodepatterns that weencountered in realcode: libtasn1
createsatree-likedatastructurewherenodesareallocatedinsidealoopand m4utilizes
multiple hashtables.1#include <stdio.h>
2#include <stdlib.h>
3#include <string.h>
4
5#define N 20
6typedef struct elem_t
7{unsigned k;char*v;structelem_t *next;} elem_t;
8typedef struct {unsigned n; elem_t **array;} table_t;
9
10table_t *table_alloc( unsigned n) {
11table_t *t = malloc( sizeof(table_t));
12t->array = calloc( sizeof(elem_t *), n);
13t->n = n;
14returnt;
15}
16
17elem_t *table_lookup(table_t *t, unsigned k) {
18unsigned int hash = k % t->n;
19elem_t *e = t->array[hash];
20while(e) {
21 if(e->k == k) break;
22 e = e->next;
23}
24returne;
25}
26
27voidtable_insert(table_t *t, unsigned k,char*v) {
28elem_t *e = table_lookup(t, k);
29if(!e) {
30 e = malloc( sizeof(elem_t));
31 e->v = malloc(10);
32 e->k = k;
33 inthash = k % t->n;
34 e->next = t->array[hash];
35 t->array[hash] = e;
36}
37strcpy(e->v, v);
38}
39
40voidrun(table_t *t) {
41while(...) {
42 // wait for key and data
43 table_insert(t, k, v);
44}
45}
46
47voidmain() {
48table_t *t1 = table_alloc(N);
49table_t *t2 = table_alloc(N);
50for(unsigned i = 0; i < N; i++) {
51 table_t *t = i % 2 == 0 ? t1 : t2;
52 table_insert(t, i, "...");
53}
54unsigned k1, k2; // symbolic
55table_insert(t1, k1, "foo");
56elem_t *e = table_lookup(t2, k2);
57run(t2);
58}
Figure 1:Motivatingexample.
intot1and odd elements into t2(line52). At line 55it inserts a
new element into table t1with the symbolic key k1. The insertion
function uses table_lookup to check if the element already exists
in the table, which in turn computes the hash of the input key, and
198Past-Sensitive PointerAnalysis forSymbolicExecution ESEC/FSE ‚Äô20, November8‚Äì13,2020,VirtualEvent, USA
ùë® ùë¨ ùëªt1 t1.array t1.array[hash]
t2 t2.array t2.array[hash]
Figure 2:Abstractionwith static pointeranalysis.
ùë®‡´ö ùë¨‡´ö‡´ö, ùë¨‡´ö‡´õ,‚Ä¶ ùëª‡´öt1 t1.array t1.array[hash]
ùë®‡´õ ùë¨‡´õ‡´ö, ùë¨‡´õ‡´õ,‚Ä¶ ùëª‡´õt2 t2.array t2.array[hash]
Figure 3:Abstractionwith past-sensitive pointeranalysis.
iterates over the nodes of the relevant bucket to find the matching
element.
Assumethatadeveloperisinterestedintestingthepartofthe
code operating on table t2. The developer could try to reduce path
explosion(e.g.,duetothe whileloopatlines 20≈õ23)byskipping
the invocation of function table_insert at line55using chopped
symbolic execution. However, an attempt to skip the invocation
atline55usingtheoriginaltechnique,whichreliesonflow-and
context-insensitivepointeranalysis,willnotbesuccessful,sincethe
analysis will report a false dependency between the side effects of
table_insert atline55andthelocationsreadby table_lookup
at line56. The relevant part of the abstraction computed by the
(whole-program)pointeranalysisisshowninFigure 2.Notethat
acontext-(and flow-)sensitivepointeranalysiswillnotsolve our
problem,sincetheelementsofbothtablesareallocatedinthesame
context(at line 30oftable_insert ,whichiscalledfrom line 52).
Leveraging the fact that we need the side effects information
duringtheexecution(inparticularbeforethecallatline 55),and
notnecessarilyatitsstart,weaimtotakeadvantageofthedynamic
information at hand. In order to run a pointer analysis from a
dynamic context, we need the ability to compute the abstraction of
thecurrentsymbolicstate.Akeyobservationisthatwecanbenefit
from the ability to distinguish between objects which were already
allocated when the analysis is invoked, even if they have the same
staticallocation site.
The abstraction computed using our PSPAapproach, at the call-
site oftable_insert at line55, is shown in Figure 3. For each
of the objects allocated until that point at lines 11,12and30, we
assignauniqueallocationsite intheabstractstate.Therefore,when
functiontable_insert iscalledatline 55,weknowfromthedy-
namicabstractionthat: t1pointsto T1,thefield arrayoft1pointstoA1,andthepointersofthatarraypoint(index-insensitively)to
{E1
1,E2
1,...}(the elements that were already allocated at line 30).
Usingthisinformation,wecancomputepreciseenoughsideeffects
forthefunction table_insert ,whichallows us to eliminatethe
spuriousdata dependencies.
Another challenge arising from our example is the process of
symbolicpointerresolution,awell-knownchallengeindynamic
symbolic execution [ 8,33]. Note that in our example, when at line
55table_insert callstable_lookup , the value of the pointer e
at line19is symbolic, since it depends on the symbolic hashvalue
whichisderivedfrom k1.Therefore,atline 21,e->kdereferences
asymbolic pointer.
Typically,symbolicexecutorscreateoneSMTsolverarrayfor
each symbolic memory object [ 8,38]. Dereferences of symbolic
pointersposeachallengetothisapproach,aseachsymbolicpointer
mayrefertomultipleobjects.Asdiscussedintheintroduction,one
of the most common approaches for handling symbolic pointers is
theforking model , used by e.g., KLEE [ 8]: when a symbolic pointer
isencountered,theentirememoryisscannedtofindalltheobjects
to which the pointer could refer. Then, for each possible object,
the pointer is constrained to refer to that object only, making it
straightforward to express SMT constraints involving that pointer.
Determiningwhether thesymbolicpointercan refertoa certain
memory objectisexpensive,as itinvolves solver queries.5
We remark that the blind process of memory scanning can be
improved if one has points-to information in hand. If the symbolic
pointercannotstatically point to an object which has an allocation
siteAS,thenobjectswhoseallocationsiteis AScanbeignoredin
the scanning process, thus saving solver queries. Obviously, the
successofthisapproachdependsdirectlyontheprecisionofthe
pointeranalysis.Considerthesymbolicpointerdereference e->k
discussed above. With static pointer analysis, the scanned space
will be reduced to the objects whose allocation site is E(Fig.2), i.e.
theelementsallocatedbybothtables( t1andt2).Withour PSPA
approach, the scanned space will be further reduced to objects
whoseallocationsitesisoneof {E1
1,E2
1,...}(Fig.3),thusreducing
the number ofscannedobjectsbyafactor of 2.
So far we discussed the benefits of our dynamic approach in the
contextofsymbolicexecution.Nowwewillshowthebenefitsof
our approach in the context of write integrity testing, which we
introducedinƒü 1.Considertheexecutionofthe runfunction,which
waits for akeyand a value (ofanarbitrarysize), and insertsthem
into the table t2usingtable_insert . Note that if our value vis
longenough,thenabufferoverflowwilloccurduringtheexecution
oftable_insert at line37.
WhenWITisenforcedwithstaticpointeranalysis,allthestring
buffers allocatedatline 31correspond toa singlestatic allocation
site,and WITonlyenforcesthatthe strcpyaccessesone ofthese
buffers. Therefore, when the strcpyfunction overrides the next
objectinmemory(whichcouldbeanotherstringbuffer),abuffer
overflowcanbemissed.Withourdynamicapproach,wecanper-
form the pointer analysis just before the invocationof run, which
5Note that thisprocess canbe optimized to scan only part of the memory space [ 11],
buttools like KLEE don‚Äôtusethese optimizationsas theypose some implementation
challenges. Other memory models can also work better in some scenarios [ 24,33]
but present various trade-offs. Context-based resolution [ 48] can accelerate future
resolutions,butisanorthogonalapproach.
199ESEC/FSE ‚Äô20, November8‚Äì13,2020,VirtualEvent, USA David Trabish, Timotej Kapus, Noam RinetzkyandCristian Cadar
enables us to distinguish between each of the already allocated
values, andthose that willbe allocatedin thefuture. In particular,
wecandistinguishbetweenvaluesallocatedfor t1andt2.Since
runonly references t2and we track each past-allocated value,
we can distinguish the different values associated with t1. Thus
undersomeallocationschemes,e.g.,whenallstringbuffersareallo-
catedsequentially,thesedistinctionsallow PSPAtodetectpotential
strcpybuffer overflows that are missed when using a standard
staticpointer analysis.
3 SYMBOLIC STATEAPI
Symbolic execution (SE) [12] is an automated technique for evaluat-
ing the behavior of a program on arbitrary inputs. It has been suc-
cessfully used for e.g., test generation [ 8,25], bug and security vul-
nerabilitydiscovery[ 14,26,35,52],equivalencechecking[ 19,20]
and patch testing [ 36]. The idea behind symbolic execution was
introducedover40yearsago[ 6,18,34].However,inthelastdecade,
symbolic execution gained new momentum due to the dramatic
improvement inSMT solvers[ 23], andtheinvention ofdynamic/-
concolicsymbolic execution[ 9,25].
Roughlyspeaking,SEenginessuchasKLEE[ 8]systematically
exploreprogrampathsbymaintaining symbolicstates .Eachsuch
staterecordsthevaluesofvariablesandheap-allocatedlocations
aspath-dependentfunctionsofagiven symbolic inputanda path
condition.Thelatterisaconjunctionofquantifier-freefirst-order
formulas that tracks the sequence of branches the SE engine fol-
lowedalongthatpath.Thepathisfeasibleifandonlyiftheresulting
condition issatisfiable.
ModernSEengineslikeKLEEcomputesymbolicstateswhich
reflectthelayoutandthecontentsoftheprogram‚Äôsmemorywith
bit-level accuracy: Every time the SE engine encounters a memory-
allocation command, be it of a local variable, a global variable or a
heap object, it adds to the symbolic state a fresh memory object mo
spanning an appropriate number of bytes starting at a unique base
addressBases(mo)‚ààN.6
To simplify the presentation, we assume that the SE engine
represents every memory object as if it is comprised of a sequence
ofprimitive fields containing primitive values , which are either
integers or addresses. We represent thecontents ofeach primitive
field byaunique symbolicexpression e.7
Wefurtherexpectthateverymemoryobject moinasymbolic
stateshasatypet‚ààT,denotedby Types(mo),whichdetermines
thenumberofitsprimitivefieldsandtheirtypes(integeroraddress).
The setofpossible types isdefinedas follows:
T:=int|ref|Array(n,T)|Struct(T)
The types intandrefcorrespond to integer and pointer primi-
tive values occupying a single field. The type Array(n,t)is of
an array containing n‚ààN+elements of type t, and the type
Struct(t1,...,tn)indicates a record type containing nelements
where the ithelement, for 1‚â§i‚â§n, is of type ti. We denote the
numberoffieldsinanobjectoftype tbySize(t)anduseSizes(mo)
as ashorthand for Size(Types(mo)).
6If the size Nof the allocation is symbolic, the engine concretizes Nto a arbitrary
admissible size, i.e., one whichadheresto the accumulated pathconstraints.
7Wenotethat ourimplementation is bit-accurate.We assume that the SE engine exposes the set of allocated mem-
ory objects in a symbolic state s, their properties, and the value
ofpointerexpressions.Specifically,weexpectthattheSEengine
supports the following operations onagiven symbolic state s:
‚Ä¢MOsreturns the setofallocatedmemory objectsin s.
‚Ä¢Bases,TypesandASsreturnthebaseaddress,type,andallocation
site8ofmo‚ààMOs,respectively.
‚Ä¢Givenamemoryobject mo,andafieldindex0 ‚â§i<Sizes(mo),
thefunctions Types(mo,i),andEs(mo,i)returnthetypeofthe
ithprimitivefieldof moandthesymbolicexpressionrepresenting
its value,respectively.
‚Ä¢Givenasymbolicexpression eandaconstantvalue c,thefunction
mayBeTrues(e=c)determineswhether it ispossible that ehas
the value cins.
4 PAST-SENSITIVE POINTERANALYSIS
In this section, we present our technique for determining the ab-
stractionwheninvokingpointeranalysisfromdynamiccontexts.
Thetechniqueabstractsthe memorygraph inducedbythesymbolic
stateusinga past-sensitiveabstractdomain .Thus,wedescribethese
aspectsfirst.
4.1 MemoryGraphs
Thememory graph pertaining to a symbolic state s, denoted by Gs,
is a graph which conservatively represents the possible memory
layout in s: the nodes of the graph are the primitive fields of the
allocated memory objectsandits edges record thepossiblepoints-
torelations.GiventhesymbolicstateAPIdescribedintheprevious
section, constructing the graph isratherstraightforward:
Gs=(N,E),where
N={(mo,i)|mo‚ààMOs‚àß0‚â§i<Sizes(mo)}
E={((mo1,i1),(mo2,i2))|
mo1,mo2‚ààMOs‚àßTypes(mo1,i1)=ref‚àß
mayBeTrues(Es(mo1,i1)=Bases(mo2)+i2)}
Givenasymbolicexpression eandasymbolicstate s,wedenote
byTargetss(e)the set of nodes in the memory graph of scorre-
sponding to the locations (primitive fields)that emightpointto:
Targetss(e)={(mo,i)|mo‚ààMOs‚àß0‚â§i<Sizes(mo)
‚àßmayBeTrues(e=Bases(mo)+i)}
LetRbe a set of symbolic pointer expressions. We denote by
Gp
s(R)the sub-graphofthe Gsobtainedbyprojecting itusing R:
Gp
s(R)=(N‚Ä≤,E‚à©(N‚Ä≤√óN‚Ä≤))
where:
N‚Ä≤={n‚ààN|nis reachable in Gsfromn‚Ä≤‚àà/uniondisplay
e‚ààRTargetss(e)}
Note that when a function is invoked, it can only operate on the
part of the memory which is reachable from its formal parameters
andglobalvariables.Thus,assuming Rcontainsthesymbolicex-
pressionscorrespondingtotheaddressesoftheglobalvariablesand
the values of the actual parameters in s, we can soundly analyze
the invocation considering only part of the memory represented
byGp
s(R)instead of Gs.
8Weassumethat ASsassigns atag to everymemoryobject.
200Past-Sensitive PointerAnalysis forSymbolicExecution ESEC/FSE ‚Äô20, November8‚Äì13,2020,VirtualEvent, USA
Forexample,thememorygraphofthesymbolicstate scomputed
at line55of Figure 1right before the invocation of table_insert
contains several nodes: local variables( t1,t2, ...), allocated tables,
allocated arrays, etc. The part of the memory graph relevant to the
invocation Gp
s({t1}),containsonlystring "foo"and the elements
andthe stringbuffers intable t1.
4.2 Past-SensitiveAbstractDomain
Pointer analysis algorithms conservatively determine the target of
every pointer variable and field in the program. The most common
way to represent this information is to use a points-to graph . A
points-tographiscomprisedofnodesrepresenting(fields)ofmem-
ory objects and the edges which encode the possible contents of
the pointer fields. In addition, there are several roots, representing
the entry points tothe graph√êthe addresses ofvariablesand the
pointer parameterspassedto the program.
Intuitively,onecanthinkofapoints-tographasabstractinga
memory graph by collapsing multiple nodes of the memory graph
into single nodes which can representone or more memoryfields.
Toensuretheabstractionisbounded,andthusthatthepoints-to
algorithm terminates, there is a bounded a priori fixed partitioning
ofthenodes.Forexample,alltheheapobjectsallocatedatthesame
allocation site are often collapsed together into the same node. Dif-
ferent points-toabstractionsalter thegraphin different ways.For
example,theymayrefinetheabstractionbydifferentiatingbetween
objects allocated at different calling contexts (object-sensitivity) or
coarsenitbyignoringthedistinctionbetweenthedifferentfields
ofan object(field-insensitivity).
InPSPA,wealsouseanallocation-basedpointerabstraction,but
with a twist: As we know the exact dynamic context in which the
analysis should operate, we distinguish between the objects which
were allocated prior to the analyzed invocation and the ones the
analysisshouldconsiderasbeingpossiblyallocatedfromthispoint
on.Thus, everydynamiccontextinducesitsownabstraction .Tech-
nically,ourabstractdomain Aisdefinedover admissibleabstract
statesas formalizedbelow:
ASstatic=Theset ofstaticallocation sites in P
ASunique=ASstatic√óN
as‚ààAS=ASstatic‚à™ASunique
v‚ààV=Roots
o‚ààO=AS√ó(N‚à™{‚àó})
œÉ‚ààA=2V√ó2O√ó2(V‚à™O)√óO
Anabstract state (akapoints-to graph)œÉ=(V,O,PT)‚ààAis
comprisedofasetof rootsV,theprogram‚Äôsentrypointsintothe
memory; a set of abstract nodesOrepresenting memory locations;
andasetof abstractedges PTrepresentingthepoints-torelations.
Arootv‚ààVis the address of a global variable or the value of a
pointerparameter.An abstractnode o=(as,f)‚ààOiscomprisedof
anallocationsite as‚ààASandafieldindex fformemoryobjects
whichareabstractedinafield-sensitivemanner,oranallocation
site andthe specialsymbol ‚àófor thosewhichare not.
As explained above, an allocation site is either static, potentially
representing multiple objects allocated at a given line, or a unique
one, representing a single object allocated at a specific address.
During the execution of a symbolic state s, the tag of a memory
objectmo, that isASs(mo), is a unique allocation site (as,n)‚ààASunique,ifmoisaheapobject,andastaticone as‚ààASstatic
otherwise. Therefore, the abstraction of a symbolic state generates
nodes with unique allocation sites for already allocated objects
inthe heap.Forexample,intheprogramat Figure 1,eachobject
allocated at line 11will have a unique allocation site, and therefore
thepointeranalysisalgorithmwillbeabletodistinguishbetween
the elements intables t1andt2.
Ouranalysisaimstobefield-sensitive,i.e.,differentiatebetween
the pointer values of different fields. Thus, an abstract memory
object(as,f),wheref‚ààN,conservativelyrepresentsthecontents
of thefthfield of an object represented by allocation site as. In
case, however, the analysis cannot distinguish between different
fields of the objects represented by as, it degenerates into a field-
insensitiveabstractionwhichusesasinglememoryobject (as,‚àó)to
representall the fieldsofthe relevant objects.Clearly,an abstract
memoryobject canbe representedonly ineithera sensitiveor an
insensitiveway.Thus,anabstractstate œÉ=(V,O,PT)isadmissible
if‚àÄas,f.(as,f)‚àà O‚àß(as,‚àó)‚àà O=‚áíf=‚àó. In the rest of
the paper, we assume thatall abstract states are admissible unless
explicitly statedotherwise.
To define our abstract domain, we need to induce an approxima-
tionorder‚äëoverit.Anabstractmemorystate œÉ1ismoreprecise
thanœÉ2, denoted by œÉ1‚äëœÉ2, ifœÉ2can be obtained from œÉ1by
collapsingallthenodesrepresentingfieldsofsomememoryobjects
into field-insensitive nodes, and, possibly, adding additional edges.
4.3 AbstractionFunction
Past-sensitivity amounts to determining the initial state and the
abstractdomainforthepointeranalysisbyabstractingthememory
graph of the symbolic state son which the analysis is invoked into
apoints-tograph.
Essentially,everynodeinthememorygraphof sismappedto
an abstract node and the edges of the memory graph induce the
points-to relations, with the exception of nodes representing array
elements: Often, the size of arrays is not known at compile time.
Thus,points-toanalysesare index-insensitive ,i.e.,theydonotdistin-
guishbetweendifferentelements of anarray. However, ifthearray
elementsare structures, the abstraction does not smash together
all primitive fields; instead it distinguishes between the contents of
the different fields of the structure. Another way to understand the
resulting abstraction is to consider amemory graph and ≈Çsqueeze≈æ
everyarrayineverymemoryobjecttobeofsizeoneandaddtothat
singleelement all the points-to edges emanating from theoriginal
array.Notethat thepoints-toabstractionofthe≈Çsqueezed≈æobject
can still be field-sensitive. For example, if the memory object is an
array containing, say three point_t structures with fields xandy,
and thus comprised of six primitive fields, the ≈Çsqueezed≈æ object
wouldcontaintwofields:Thefirstwouldrepresentalltheprimi-
tivefieldspertainingtothe x-coordinateandthesecondtothose
representing the y-coordinate.
Toformallydefinetheabstractionfunction,wefirstintroduce
functionAbsFld(t,f)whichmapsthe fthfieldofamemoryobject
201ESEC/FSE ‚Äô20, November8‚Äì13,2020,VirtualEvent, USA David Trabish, Timotej Kapus, Noam RinetzkyandCristian Cadar
oftypetto an appropriate field index ofthe abstract node:
AbsFld(t,f)=
Ô£±Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£≤Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£≥0 f=0‚àßt‚àà{int,ref}
AbsFld(t‚Ä≤,i)t=Array(n,t‚Ä≤)‚àßi=fmodSize(t‚Ä≤)
AbsFld(tk,i)+d t=Struct(t1,...,tn)
‚àß0‚â§k<n‚àßc=/summationtextk
j=1Size(tj)
‚àßc‚â§f<c+Size(tk+1)
‚àßi=f‚àíc‚àßd=/summationtextk
j=1AbsSize(tj)
whereAbsSizeisdefinedas follows:
AbsSize(t)=Ô£±Ô£¥Ô£¥Ô£¥Ô£¥Ô£≤Ô£¥Ô£¥Ô£¥Ô£¥Ô£≥1 t‚àà{int,ref}
AbsSize(t‚Ä≤)t=Array(n,t‚Ä≤)/summationtextn
i=1AbsSize(ti)t=Struct(t1,...,tn)
Given a symbolic state s,AbsNode maps every node ( mo,i) in
the memory graph of sto the abstract node whichrepresents it:
AbsNode s(mo,i)=(ASs(mo),AbsFld(Types(mo),i)).
Givenasymbolicstate soccurringrightbeforetheinvocation
of a function, we use the symbolic state API to extract the memory
graphofsandabstractitintoanabstractstate Abs(s)=(V,O,PT).
We assume that the formal parameters of the invoked function
arep1,...,pkand that the values of the actual arguments of the
invocationaredefinedbythesymbolicexpressions ep1,...,epk.9
Similarly, we assume that the value of every global variable –¥‚àà
Globalisrepresentedbythesymbolicexpression e–¥.Thus,assuming
thatGs=(N,E),the abstractionisdefinedas follows:
Abs(s)=(V,O,PTV‚à™PTO),where
V={p1,...,pk}‚à™Global
O={AbsNode s(mo,i)|(mo,i)‚ààN}
PTV={(v,AbsNode s(mo,i))|v‚ààV‚àß(mo,i)‚ààTargetss(ev)}
PTO={(AbsNode s(mo1,i1),AbsNode s(mo2,i2))|
((mo1,i1),(mo2,i2))‚ààE}
Tolocalizetheanalysisoftheinvokedfunctiontotherelevantpart
ofthestate,wecomputeaprojectionof sbyremovinganymemory
object which is unreachable from the actual parameters and global
variables.Thatis,theinitialabstractstateisgivenby Abs(sp),where
spisobtainedfrom ssuch that Gsp=Gp
s({ev|v‚ààV}).
Once the abstraction of the initial state sis computed, we run a
standardpointeranalysisalgorithmtoobtainpoints-toinformation
which is sound with respect to any symbolic state that might arise
during a symbolic execution of the analyzed function starting at s.
4.4 Soundness
In thissection we prove that ourpast-sensitive approach issound
withrespecttotheunderlyingpointeranalysis.Weassumethatwe
haveapointeranalysisalgorithmwhichissoundwithrespecttothe
standardconcretedomain C:Aconcretestate c‚ààCiscomprisedof
a stack, a heap, and a set of global variables. We assume a standard
instrumentationoftheconcretesemanticswhereeachallocatedob-
ject is tagged with its corresponding static allocation site as‚ààAS.
Weexpecttohaveafunction Œ≤:C‚ÜíAthatmapsaconcretestate
9Forsimplicity,andwithoutlossofgenerality,weassumethatalltheformalparameters
arepointers. Thisassumption is justified as weignoreintegerparameters.to its best representation as an abstract state œÉ‚ààA, by merging
objectswhichhavethesameallocationsites.Thelatterinducesthe
abstraction Œ±: 2C‚ÜíAand concretization Œ≥:A‚Üí2Cfunctions
in the standard way [ 21]. In Lemma 4.1and Corollary 4.2we ex-
tend the soundness of Andersen‚Äôs pointer analysis algorithm [ 4] to
consider unique allocation sites and arbitrary initial abstract states.
A symbolic state s‚ààSrepresents a set of concrete states us-
ing the function r:S‚Üí2C, wherec‚ààr(s)if there is a model
of the path constraints of swhose assignment results in c. The
abstraction function Œ≤sym:S ‚Üí A maps a symbolic state s
to the points-to graph which abstracts the concrete states that
srepresents. The abstraction function Œ≤symis an extension of Abs
(ƒü4.3)thattakesintoaccountalsothelocalvariablesoftheactive
stack frames starting from the analyzed function, and tags heap
objects allocated by the analyzed function with static allocation
sites. In Theorem 4.3, we lift the soundness of the pointer anal-
ysis algorithm in the concrete domain to prove that it is sound
toutilize itsresults duringsymbolicexecution. Forspacereason,
theproofsappearinthesupplementarymaterial(AppendixAat
https://doi.org/10.6084/m9.figshare.12487679 ).
Lemma4.1. LetPbeaprogramwithasetoffunctions F,andf‚ààF.
LetAbetheabstract domainpresented in the paper,that is:
AS=ASstatic‚à™ASunique
LetœÉbe the initial abstract state, and œÉ‚Ä≤be the result of running
pointer analysis on ffromœÉ, then ifc‚Ä≤is reachable from c‚ààŒ≥(œÉ)
thenc‚Ä≤‚ààŒ≥(œÉ‚Ä≤).
Corollary4.2. LetPbeaprogramwithasetoffunctions F,andlet
cbeaconcretestatethatreachestheinvocationof f‚ààF.LetAbe
theabstract domainpresented in the paper,where:
AS=ASstatic‚à™ASunique
LetœÉ=Œ≤(c), andœÉ‚Ä≤be the result of running pointer analysis on f
fromœÉ,thenifc‚Ä≤is reachable from c‚ààŒ≥(œÉ)thenc‚Ä≤‚ààŒ≥(œÉ‚Ä≤).
Theorem4.3. LetPbeaprogramwithasetoffunctions F,and
letsbeasymbolicstatethatreachestheinvocationof f‚ààF.LetA
betheabstract domainpresented in the paper,where:
AS=ASstatic‚à™ASunique
LetœÉ=Œ≤sym(s),andœÉ‚Ä≤betheresultofpointeranalysison ffrom
œÉ,thenifs‚Ä≤is reachable from sthenŒ≤sym(s‚Ä≤)‚äëœÉ‚Ä≤.
4.5 Reusing Summaries
The number of function invocations during the symbolic explo-
ration can be very high, and therefore re-running the pointer anal-
ysis for every invocation which needs to be analyzed might in-
cur highperformance overhead.Weaddressthis issuebycreating
points-tosummariesandreusingthemwhen possible.
Thereusemechanismisbasedonagreedybest-effortisomorphism-
checking function checkStateIsomorphism which accepts a func-
tionf,twoabstractstates s1,forwhichwehavealreadyexecuted
the pointer analysis, and s2, for which we need to determine the
points-to graph resulting from invoking fon it.checkStateIso-
morphism checksifthetwostatesareisomorphicsothattheresults
obtained for s1can be used in the context of s2. The check is done
byfindingmatchingpairsofabstractobjectsfromthetwostates
202Past-Sensitive PointerAnalysis forSymbolicExecution ESEC/FSE ‚Äô20, November8‚Äì13,2020,VirtualEvent, USA
starting from the ones pointed to by the global variables and the
function parameters, while taking into account the field-sensitivity
ofthe investigatedobjects.
If the isomorphism check succeeds then checkStateIsomor-
phismreturnsanobject-matchingmapwhichallowstotranslate
the already computed points-to graph to the one needed. For ex-
ample,inthecontextofchoppedsymbolicexecution,thisallows
determiningtheside-effects ( mod set) obtainedwhen theanalysis
is invoked on s2from the side effects computed for s1. If it fails, we
re-run the pointer analysis with s2as the initial state and memoize
the results for future isomorphism checks.
For space reasons, we do not further discuss the reuse mecha-
nism,andrefertheinterestedreadertothesupplementarymaterial.
5 IMPLEMENTATION
OurimplementationisbasedonSVF[ 46]andKLEE[ 8].SVFimple-
mentswhole-programpointeranalysis,thusweextendittosupport
localpointeranalysis(fromanarbitraryinitialstate),andunique
allocation sites. We integrated the extended version of SVF on top
of KLEE with support for LLVM 3.8. We make our implementation
and associated artifact available at https://srg.doc.ic.ac.uk/projects/
pspa/.
TypeInformation. In ordertoabstractsymbolic statesin afield-
sensitivemanner,weneedtoknowthetypesofmemoryobjects.
Our implementation uses LLVM which often provides imprecise
typeinformationatmemoryallocationsites.However,aprogram
cansetthetypeofanobjectusingacastinstruction.Thus,wetrack
type cast instructions during the symbolic execution in order to
infertypeinformation.Ifthetypeofanobjectcannotbedetermined,
we conservativelyrepresent itinafield-insensitive manner.
6 EVALUATION
Inourexperiments,wedemonstratetheprecisionandscalability
benefits of our approach as follows: First, by examining the raw
results of the pointer analysis (ƒü 6.1), and second, by evaluating the
effectivenessofourapproachinthecontextofthreeclientanalyses:
chopped symbolic execution (ƒü 6.2), write integrity testing (ƒü 6.3),
and symbolic pointer resolution (ƒü 6.4). We used an Intel i7-6700
machine with8cores and32GBofRAM running Ubuntu16.04.
6.1 Precision
Wefirstevaluatetheaddedprecisionofourapproachbyexamining
itseffectonthesizeofthecomputedpoints-tosets.Inparticular,
we report the size of the mod-sets and theref-setsfor functions
calledduringasymbolicexecutionrun,i.e.how manyobjectsthe
pointer analysis determines that the function and its callees can
writeto andread from, respectively.
As benchmarks, we used three popular libraries which parse
various input formats: GNU libosip (11K SLOC), GNU libtasn1 (19K
SLOC) and libtiff(65K SLOC). GNU libosip is a library for parsing
SIP messages, GNU libtasn1 is a library for decoding and encoding
data in the Abstract Syntax Notation One (ASN.1) format, and
libtiffis a library for parsing TIFF images. We chose these libraries
becausewebelievetheyrepresentprogramswhichareagoodfit
forsymbolicexecutionastheyhaverathercomplicatedlogicand
require arelativelysimplemodelingofthe environment.Table 1:Average size ofmod-sets and ref-sets.
Mod-set Ref-set
SPAPSPASPAPSPA
libosip 17.78 2.94 32.98 3.68
libtasn1 7.35 1.55 8.24 1.94
libtiff 140.16 12.95 126.63 17.44
We compare the precision of the analysis in two configurations:
static pointer analysis ( SPA), where we obtain the points-to infor-
mation using a standard pointer analysis, and past-sensitive pointer
analysis ( PSPA), our approach for executing the pointer analysis
fromadynamiccontext.Ineachconfiguration,werunourmodified
version of KLEE for a limited number of instructions with the DFS
searchheuristic(whichisdeterministic,andthuscoversthesame
executionpathsacrossconfigurations),andrecordthesizeofthe
mod-set and ref-set of called functions. We analyze only functions
calledfromtheapplicationcode,excludingthetestdriverand uclibc
(KLEE‚Äôs versionofthe standardlibrary) internal functions.
Theprecision improvement of PSPAcomparedto SPAis signifi-
cant andcan be seen in Table 1, which shows foreach benchmark
andmodethe averagesize of thecomputed mod-sets andref-sets.
The sizes are expressed in terms of abstract objects; we strip away
the uniqueness of allocations sites, for the comparison with the
originalabstract domainto make sense.
6.2 Application: ChoppedSymbolic Execution
Toevaluatetheimpactof PSPAonchoppedsymbolicexecution,we
integratedthe Choppertool10intoour code base.
Insteadofcomputingthemod-setofaskippedfunctionstatically
(as in the original technique), we use PSPAto compute the mod-set
eachtimeaskippedfunctionisinvoked.Rememberfromƒü 1that
in chopped symbolic execution, whenever the program reads from
themod-setofaskippedfunction,a recoveryproceduretakesplace
to execute partsof the skipped function. An imprecise mod-set can
leadto manyunnecessary (andexpensive)recoveries.
When the program reads from an object that was allocated dur-
ing a recovery, we need to consider its static allocation site for the
side-effectsinference,sincethepoineranalysisgeneratesstaticallo-
cation sites for objects allocated in the analyzed skipped functions.
Additionally, to correctly handle multiple skipped function calls,
wekeepforeachskippedcallits post-abstractstate ,i.e.theresult
ofrunning pointer analysis on that function.Then,when we skip
another function call, we first merge the abstract state with the
post-abstract states of the previously skipped calls, in order take
intoaccount the information from the skippedcalls.
We performed several experiments. In ƒü 6.2.1, we show that our
techniquesignificantlyreducesthenumberofrecoveriesneededin
chopped symbolic execution due to an increase in the precision of
pointeraliasanalysis.Inƒü 6.2.2,wethenevaluatechoppedsymbolic
executioninthecontextoftestgeneration,showingthatitachieves
highercoveragewhenusing PSPAinsteadof SPA.Inƒü6.2.3andƒü6.2.4
we showthat PS PAcan speedupchoppedsymbolic execution.
10https://github.com/davidtr1037/chopper
203ESEC/FSE ‚Äô20, November8‚Äì13,2020,VirtualEvent, USA David Trabish, Timotej Kapus, Noam RinetzkyandCristian Cadar
10-1100101102103104Recoveries per path
Skipping configurationsSPA
PSPA
libtiff libtasn1 libosip
Figure 4:Recoveriesperpath (logscale).
6.2.1 ReducingtheNumberofRecoveries. Inthisexperiment,we
show that past-sensitive pointer analysis can help reduce the num-
ber ofrecoveries duringchoppedsymbolic execution.
We ran chopped symbolic execution with both SPAandPSPA
mod-set computation. For each benchmark, we generate a list of
calledfunctionsbyrunningvanillaKLEEfortenminutes.Werecord
onlyfunctionswhicharecalledfromthemainlibraryAPIwhich
the test driver invokes, and ignore uclibcinternal functions. We
thentaketenrandomsamplesoftenfunctionstoskipfromthatlist,
togeneratetendifferentskippingconfigurations.Foreachskipping
configuration, we ran chopped symbolic execution for ten minutes
with theDFS searchheuristicand count the number ofrecoveries.
Our random selection aims to remove the bias which may come
fromtheselectionofskippedfunctions.Wepickfunctionsfromthe
ones already reached by KLEE, to make sure that the skipped func-
tions we specify are indeed reached and skipped during execution.
Figure4showsthenumberofrecoveriesperpathexecutedfor
eachskippedconfiguration(tensetsoftenrandomlysampledfunc-
tionsforeachofthethreebenchmarks).Wecanseethat PSPAleads
toanumberofsignificantdecreasesinthenumberofrecoveries.
Thereductionfor libosiprangesbetween0%and42%,for libtasn1
between17% and 99%, while for libtiffbetween92% and 99%.The
largest decrease occurs in a configuration of libtiffwhere there are
43,344recoveriesacrosspathswith SPAandonly10with PSPA,a
reduction of99%.
6.2.2 ImprovingCoverage. Inƒü6.2.1,weshowthat PSPAcanhelp
decrease the number of recoveries in chopped symbolic execution.
Aswedon‚Äôtexpecttoimprovethestructuralcoveragebyrandomly
selectingtheskippedfunctions,werananadditionalexperiment
where the function selection is done manually (note that [ 47] simi-
larlyperforms the selection manually).
We then run chopped symbolic execution both with SPAand
PSPA, and with PSPAwithout reuse to evaluate the impact of our
reuseapproachfromƒü 4.5.Weusetwoheuristics:depth-firstsearch
(DFS) and random-path selection (Random) [ 8]. For each mode, we
runchoppedsymbolicexecutionforonehourandcomputetheline
coverageofthe generatedtest suite using gcov.11
11https://gcc.gnu.org/onlinedocs/gcc/Gcov.htmlTable2:Linecoverageachievedbyvariousconfigurations.13
Search SPA PSPA
Noreuse Reuse
libosipDFS 567 410 519
Random 592 314 647
libtasn1DFS 958 1079 1079
Random 950 1019 1019
libtiffDFS 669 673 673
Random 647 677 1034
Inlibosip, we chose to skip functions which process different
partsoftheURIcomponentoftheSIPmessage.Thesefunctionsare
widely used in the library, and therefore the context-insensitivity
ofSPAleads toaccumulation of side effects, which are propagated
fromallthecallsitesintheprogram.With PSPA,whichstartsthe
analysis from a much more precise initial state, we are able to
locally analyzesuch functions, and avoid the noise which comes
from considering othercallsites.
Inlibtasn1, some of the skipped functions manipulate a tree
data structure, which represents the structure of the parsed ASN.1
message. The nodes of this tree are dynamically allocated at the
same allocation site, and therefore the analysis treats all the nodes
inthetreeasonenode.Conversely, PSPAusesuniqueallocationsites
fordynamicallyallocatedobjects,whichallowsustodistinguish
between the differentnodes inthe tree.
Inlibtiff,weskiptheloggingfunctions(warnings,errors,etc.)
which receivesome parts ofthe symbolicinputand create many
redundantforks. These functionsare implemented using function
pointers,andtheimprecise functionpointerresolution ofSPAmakes
it impossible to skip these functions efficiently. With PSPA, the
precise initial state plays a critical role in the precise resolution of
function pointers, which allows us to entirely skip these functions
withouttriggeringany recoveries.
The results areshown inTable 2.Chopped symbolicexecution
withPSPA(andreuse) outperformedthestaticmodeinfiveoutof
sixcases,withanimprovementbetween-9%and60%.Wemanually
investigated the case where SPAachieved higher coverage, and
foundoutthatchoppedsymbolicexecutionwith PSPAhadlower
coverage in the skipped functions, but reached more than 100 lines
in the relevant (non-skipped) code which were not reached with
SPA. Thus, the PSPAmode had better results from the viewpoint of
the application(generatingtest casesfor non-skippedcode).12
TheeffectofthereusemechanismcanbeseeninTables 2and
3. Running without the reuse mechanism leads to higher over-
head in all six cases, especially in libosip, where the number of
analyzed functions is much higher. In the cases where the addi-
tionaloverheadwasnotsignificant,thecoverageremainedroughly
thesame.In libosip,wheretheadditionaloverheadwashigh,the
PSPAmode without reuse was not able to improve upon the SPA
12Itwasdifficulttoautomaticallyignorethecoverageoftheskippedfunctions,because
some codeiscalled from both askipped and a non-skipped context.
13Thereadermightnoticetherelativelysmalllinecoverageachievedinonehour.This
is partly due to the large and challenging benchmarks, and partly because we only
testasubset of the APIsin these libraries.
204Past-Sensitive PointerAnalysis forSymbolicExecution ESEC/FSE ‚Äô20, November8‚Äì13,2020,VirtualEvent, USA
Table 3: The overhead of pointer analysis related computa-
tions.No R: without reuse, R: with reuse, RR: reuse ratio
when run with reuse, N: number of static analysis invoca-
tions whenrun with reuse.
Search No R R RR N
libosipDFS 97.87% 6.41% 99.99% 6,680,404
Random 90.18% 2.66% 99.99% 919,326
libtasn1DFS 3.06% 2.31% 98.86% 967
Random 9.80% 3.54% 99.83% 6,800
libtiffDFS 3.24% 0.04% 98.75% 401
Random 95.74% 0.52% 99.99% 155,688
mode. Table 3also shows the reuse ratio, i.e. the percentage of
functioninvocationsforwhichtheresultofthemod-analysiscould
bereused withoutre-runningthepointer analysisalgorithm.The
high reuse ratio suggests that most of the called functions actually
have the same points-toinformation(with respectto context- and
flow-insensitive analysis). The SE engine creates states which have
different data constraints, but in most of the states this doesn‚Äôt
imply different points-to information, therefore data and points-to
information can be seen as mostly independent properties.
6.2.3 CVE Reproduction. In additionto thecoverage experiments
presentedabove, wewantedtounderstandthe impactof PSPAon
the experiments presentedin the paper introducingchoppedsym-
bolicexecution[ 47].Thepaperconsiderssixvulnerablelocations
inlibtasn1, manually selects a set of functions unrelated to the vul-
nerabilitiestobeskipped,andthenreportsthetimetakentofind
an input that reaches the vulnerable locations with and without
choppedsymbolic execution.
Wereplicatedtheexperimentsusingboth SPAandPSPAinturn.14
OurresultsareshowninthelasttwocolumnsofTable 4.Ascan
be seen,PSPAleads to significant savings in somecases, e.g., from
04:23 to 00:37 for the third vulnerability when DFS is used; and
from a timeout (set to one hour) to 10:25 for the fifth vulnerability
whenDFSisused.However,therearealsosomecasesinwhich SPA
does slightly better, with the largest difference of 01:51 vs 02:03 for
the secondvulnerabilitywhen the random heuristicisused.
While trying to understand why SPAdoes sometimes better, we
realizedthatthesearchheuristicusedin Chopper(whichprioritizes
non-recovery states, before invoking KLEE‚Äôs underlyingheuristic)
has a large influence on the results. Columns 4 and 5 of Table 4
showthe results when this heuristicisdisabled.In this case, PS PA
consistently outperforms SPA(with one small exception, 5 vs 4
secondsinone case),although the overallresults are worse.
To remove the significant influence of search heuristicson exe-
cution time, we decided to design a series of experiments in which
Chopper can exhaustively explore allthe paths in the program (for
asymbolicinputofagivensize).Sinceallthepathsareexplored,we
14We haven‚Äôt managed to incorporate yet one of the optimizations from Chopper, the
slicingoptimization [ 47].However,that optimizationdoes notdirectlyinteractwith
the mod-ref computation, which is what PSPAaffects. Wealso foundand fixed abug
in the SVF integration,whichhas animpactonsome of the baselineresults.Table4:ReplicationofCVEreproductionexperimentsfrom
[47], without the slicing optimization. Times are using the
formatminutes:seconds and the timeout(TO) is onehour.
CVE SearchChopping-awareheuristic
without with
SPAPSPASPAPSPA
#1 2012-1569Random 04:26 00:20 00:30 00:19
DFS 04:57 01:46 00:11 00:06
Coverage 03:54 00:19 00:23 00:23
#2 2014-3467 1Random TO TO 01:51 02:03
DFS 04:17 02:15 00:01 00:01
Coverage TO TO 01:20 01:20
#3 2014-3467 2Random 00:01 00:01 01:53 01:50
DFS TO TO 04:23 00:37
Coverage 00:01 00:01 01:51 02:02
#4 2014-3467 3Random TO TO 02:30 02:12
DFS TO TO 00:02 00:02
Coverage T.O T.O 03:56 01:09
#5 2015-2806Random 03:46 02:03 06:38 02:04
DFS TO 10:14 TO 10:25
Coverage 02:20 01:00 03:27 01:00
#6 2015-3622Random 00:03 00:03 00:03 00:02
DFS TO 07:25 07:16 06:33
Coverage 00:04 00:05 00:03 00:03
Table 5: The total execution time (in minutes:seconds ), with
atimeoutofonehour.
Vanilla SPAPSPA
libosip 33:30 Timeout 04:16
libtasn1 41:29 Timeout 02:12
libtiff 32:40 Timeout 10:02
cansimply count theexplorationtime(with SPAandPSPArespec-
tively),knowingthatthesearchheuristichasnoinfluence(other
thanthe overheadofthe search heuristicitself).
6.2.4 All-path exploration. As discussed above, we constructed
test drivers for our benchmarks that ensure that all paths can be
exploredinunderanhourwithvanillaKLEE.Wethenrunchopped
symbolic execution with SPAandPSPArespectively, with a time
limit ofone hour.We skip the same functionsas inƒü 6.2.2.
TheresultsareshowninTable 5.TheSPAmodetimesoutforall
benchmarks,due toahighnumberofrecoverystates,originating
fromtheimprecisionofwhole-programstaticanalysis.Bycontrast,
thePSPAmode achieves a significant speed-up relatively to vanilla
KLEE: 7.9xin libosip,18.9x in libtasn1and3.6x in libtiff.
205ESEC/FSE ‚Äô20, November8‚Äì13,2020,VirtualEvent, USA David Trabish, Timotej Kapus, Noam RinetzkyandCristian Cadar
6.3 Application: WIT
As discussed in the introduction, Write Integrity Testing (WIT) [ 2]
isarun-timesecuritymitigationtechniquethataimstodetectbuffer
overflows and other memory violations at run-time. WIT works by
using a pointer analysis to assign colours to pointers and memory
objects. A pointer and a memory object have the same colour if
the pointer can alias the memory object. WIT then enforces√êat
run-time√êthateachpointeronlywritestomemoryobjectsofits
colour,otherwiseitterminatesthe program.
The precision of the pointer analysis is of utmost importance to
WITasitseverelyimpactshowmanybufferoverflowsitcandetect:
If two objects are assigned the same colour, a buffer overflow from
one intothe othercannotbe detected.
Theapplication ofour techniqueto WITcomes fromtheobser-
vation that in a security context, we are not interested in moni-
toringwithWITallthepathsofaprogram,justtheonesthatare
attacker-controlled. In particular, the initialization code is typically
notcontrolledbytheattacker,soonecouldrunthepointeranalysis
after the initialization completes. This increases the precision of
the analysis, especially since at that point various configuration
options are fixed by the program. The disadvantage is that the
instrumentation(seeƒü 1)needstobefinalizedatrun-time,which
increasesthe initializationtime.
An implementation of WIT is not publicly available and re-
implementing WIT from scratch is difficult. Therefore, we decided
to conduct our evaluation using two indirect measures: number
ofcomputed colours (a static measure),and number oftransitions
between the colours of the buffers allocated in memory (computed
dynamicallyonacertainworkload,assumingasequentialalloca-
tor). The number of colour transitions indirectly measures how
many sequential overflows WIT could prevent. We restrict our
measurements to heap-allocatedobjects.
Moreprecisely,WITcandetectasequentialbufferoverflowif
adjacentbuffershavedifferent colours. Therefore,ifthecolourof
anobjectbeingallocatedisdifferentfromthecolouroftheprevious
object,we increment the number ofcolour transitions.
We compute colours with both SPAandPSPA, starting in the
execution state afterthe initialization completes (we manually an-
notated the end of the initialization section, but one could also
automatetheprocessbycheckingwhenauserinputisfirstread).
Weconsidereachfieldofastructureasaseparateobjectwithits
owncolour when countingthe colour transitions.
We builtthistransitionanalysis insideKLEE.We run KLEEfor
onehouroneachbenchmarkandrecordthenumberofpathsKLEE
exploredunderDFS.ThenwerunKLEEagainuptothatnumberof
pathsunderDFSinboththe SPAandPSPAmodes.Thisensuresthat
both runs used the same paths to count the number of transitions.
We report the sum oftransitionsacrossallthe exploredpaths.
As shown in Table 6,PSPAwas ableto computearound 4 times
more colours for the heap objects in libosipandlibtasn1. Forlibtiff
the increase in the number of colours is modest√êthe reason is
thatlibtiffdoes not have any setup or initialization code, so our
techniqueanalysesalmostthe wholeprogram.
Forlibosipandlibtasn1the number of transitions increases by a
factorof2.8xand4.5xrespectivelywhenusing PSPAinsteadof SPA.
This shows that PSPAcan significantly increase WIT‚Äôs ability toTable 6: The number of WIT heap colours and transitions
computed with differentpointeranalysis techniques.
Paths Colours Transitions
SPAPSPA SPA PSPA
libosip 12,084,552 70 277 108,532,593 302,069,717
libtasn1 90,290 157 645 8,848,420 39,456,716
libtiff 300 1047 1101 1,938 1,938
detect sequential heap buffer overflows on these two benchmarks,
as it now has the potential to detect several times as many over-
flows. For libtiffthere is no difference in the number of transitions,
stemming from the small difference in the number of colours. Note
that forlibtiffonly 300 paths were executed in one hour, as its
pathsare significantly more complex for symbolic execution.
6.4 Application: Symbolic PointerResolution
In this section, we show how PSPAcan be used to optimize the
forkingmodelforsymbolicpointerresolution.Asexplainedinƒü 1
and ƒü2, on a symbolic pointer dereference, the forking model scans
eachmemory objectin turn,issuingsolver queries to determine if
thepointercanrefertothatmemoryobject.Ifapointeranalysis
determines thatthe pointercannot refer to an object,that object
can be ignored,savingpotentiallyexpensive solver queries.
Dynamicallycomputingthepoints-tosetofasymbolicpointer
operand requires a snapshot of the symbolic state at the beginning
ofthecurrentfunction.However,takingasnapshotateachfunction
callisoverlyexpensive.Instead,werelyontheobservation√êtested
empiricallyonourbenchmarks√êthatsymbolicpointerdereferences
onlyoccurinafewfunctions.Therefore,wedesignalazysnapshot
mechanismthatdecideswhichfunctionstosnapshotatrun-time:
Thefirsttimeweencounterasymbolicpointer,weusethestandard
resolutionalgorithmandrememberthecalledfunction.Thenext
timethesamefunctioniscalled,wetakeasnapshotatitsbeginning.
Notethatthisapproachhastheadvantageofhavingnooverhead
for programs that don‚Äôthave symbolic pointer dereferences.
Toevaluateourapproach,weselectedprogramswheresymbolic
pointerscanbeencountered.Weselected m4(78KSLOC),apopular
implementation of the m4 macroprocessorincludedinmost UNIX-
based operating systems; GNU make(28K SLOC), one of the most
popularbuildsystems;and SQLite(127KSLOC),awell-knownSQL
databaseenginelibrary.Specifically,theseprogramsmakeextensive
use of hash tables which are a prolific source for symbolic pointers.
Eachbenchmarkwasruninthreeconfigurations:baseline, SPAand
PSPA.Foreachrun,wemeasuredthefollowingparameters:number
ofresolutionqueries,fractionoftimespentinpointerresolution,
totalexecutiontime andoverheadof pointer analysis.
As can be seen in Table 7,SPAonly slightly reduced the number
of queries in the case of m4andmake, therefore there was no
significant reduction in resolution time and total execution time.
Moreover, in the case of SQLite, the execution time of SPAwas
higherthanthebaseline,sincestaticpointeranalysistookalmost10
minutes.With PSPA,wereducedthenumberofqueriesuptoafactor
of 6.6x (in SQLite), which also results in a significant decrease in
206Past-Sensitive PointerAnalysis forSymbolicExecution ESEC/FSE ‚Äô20, November8‚Äì13,2020,VirtualEvent, USA
Table 7: Symbolic pointer resolution experiments on m4,
makeandSQLite.Q:queries, RT:resolutiontime(%), ET:ex-
ecution time(minutes), SA:static analysis time(%).
Q RT ET SA
m4Baseline 1,902 56% 49‚Äô -
SPA 1,836 55% 47‚Äô 0.15%
PSPA 960 38% 34‚Äô 0.54%
makeBaseline 21,832 56% 65‚Äô -
SPA 18,872 52% 60‚Äô 0.16%
PSPA 6,222 30% 41‚Äô 1.22%
SQLiteBaseline 7,726 28% 43‚Äô -
SPA 7,726 23% 51‚Äô 14.23%
PSPA 1,166 5% 33‚Äô 0.51%
resolutiontimeandexecutiontime,whilekeepingthecomputation
overheadofpointer analysislow(under1.22%).
7 RELATED WORK
Pointer analysis is a core static analysis technique, with numerous
applications [ 1]. As such, many research projects have focused
on improving the precision of the technique by making it flow-
sensitive [ 31], context-sensitive [ 49], object-sensitive [ 37], path-
sensitive [ 51], as well as usinghybrid combinations of the above
techniques [ 45]. Previous analyses have also tried to make the
analysissensitive tothe context inwhich objectsareallocated[ 39].
However,asfarasweknow,wearethefirsttoadddynamiccontext
sensitivity to pointer analysis which allows much finer abstraction
ofthememorystateatthecallsitethanothermethods.Wealsonote
that PSPAcan use andenhance any underlying points-toanalysis.
Proceduresummariesareastandardtechniqueforperforming
inter-procedural analyses [ 41], and have been used to obtain mod-
ularpointeranalysis,e.g.,[ 15,16].Ourreusealgorithmissimilar
in spiritto theseapproaches. However, instead of using procedure
summaries during the analysis, we employ it only to top-level calls
from whichthe analysisstarts.
W√ºstholz and Christakis [ 50] propose a novel technique for
targetedgrey-boxfuzzingwithonlinestaticanalysis,whichisused
to guide the fuzzer toward recently modified parts of the program.
In their online static analysis, the initial abstract state is computed
byre-executingthepathprefixintheabstractdomain,whichresults
inanover-approximationofallpossibleexecutionsofthatprefix.
In ourcase,theinitialabstraction stateis computeddirectlyfrom
thecurrentsymbolicstate,whichismoreprecise.Inaddition,we
extend our abstract domain with unique allocation sites , which
bringscontextsensitivityintothe staticanalysis.
Grechetal.[ 29]describeahybriddynamic/staticpointeranal-
ysis for Java programs where static analysis is utilized to over-
approximate the values of stack variables while the information
aboutthestructureoftheheapisobtaineddynamically.Specifically,
theheapisabstractedusingmultipleheapsnapshotsobtainedby
profiling the program‚Äôs heap [ 28] during the execution of selected
testcases.Thedynamicinformationallowstosharpentheresultsof
the analysis and overcome challenging issues such as the handlingofreflection,nativecode,andlambdas.However,theresultinganal-
ysisisnotsoundastheheapinformationisunder-approximated.
In contrast, our analysis produces sound results for all executions
starting at the abstracted dynamic/symbolic state. Furthermore,
Grech et al. [ 29] utilize an a priori fixed heap abstraction, whereas
our analysisemploys an input-state specific heapabstraction.
More broadly, there is a lot of work on combining static and
dynamic analysis,including static analysis and dynamicsymbolic
execution. For instance, Csallner and Smaragdakis [ 22] combine
a static checker with a test input generator to guide the latter
towardtheerrorsreportedbytheformer,whileChristakisetal.[ 17]
combinepartialstaticverificationwithdynamicsymbolicexecution
byguidingthelattertochecktheunverifiedprogramexecutions
fromtheformer.Tighterintegrationsofstaticanddynamicanalysis
also exist, which work by alternating may and must analyses to
simultaneouslyproveprogrampropertiesandsearchforbugs[ 5,
27,30].Ourworkissimilarinspirittosomeofthesecombinations,
but its main distinguishing feature is related to the need for a fine-
grainedconnectionbetweentheconcretememorylayoutandthe
abstractionusedbythe pointer analysis.
Anand et al. [ 3] abstract symbolic states to reduce the search
space for programs with recursive data structures, and Yorsh et
al. [53] abstract concrete states to determine whether to terminate
theanalysis.Weuseasimilartechniquebutforadifferentpurpose:
determinethe abstract domainof the staticpointer analysis.
8 CONCLUSIONS
We have presented past-sensitive pointer analysis, a new design
point for pointer analysis that takes into account the dynamic con-
textinwhichtheanalysisisinvoked.Adifferentpointerabstraction
is computed for eachdynamic context, withthe abstractionbeing
constructedjustbeforethepointeranalysisisneeded.Weshowthat
thisnoveldesignpointofferssignificantbenefitsinthreeimportant
application domains: chopped symbolic execution, write integrity
testing(WIT)andsymbolic pointer resolution.
ACKNOWLEDGEMENTS
The research leading to these results has received funding from
the LevBlavatnik and the BlavatnikFamily foundation,Blavatnik
Interdisciplinary CyberResearchCenter atTel Aviv University, the
Pazy Foundation, and Israel Science Foundation (ISF) grants No.
1996/18.ThisresearchhasalsoreceivedfundingfromtheEPSRCUK
via a DTA studentship and from European Research Council (ERC)
undertheEuropeanUnion‚ÄôsHorizon2020researchandinnovation
programme (grant agreement No.819141).
REFERENCES
[1]AlfredV.Aho,MonicaS.Lam,RaviSethi,andJeffreyD.Ullman.2006. Compilers:
Principles, Techniques, and Tools (2nd ed.). AddisonWesley.
[2]PeriklisAkritidis,CristianCadar,CostinRaiciu,ManuelCosta,andMiguelCastro.
2008.PreventingMemoryErrorExploitswithWIT.In Proc.oftheIEEESymposium
onSecurityand Privacy (IEEE S&P‚Äô08) (Oakland, CA, USA).
[3]SaswatAnand,CorinaS.PƒÉsƒÉreanu,andWillemVisser.2009. Symbolicexecution
with abstraction. International Journal on Software Tools for Technology Transfer
11,1 (Feb 2009),53≈õ67.
[4]Lars Ole Andersen. 1994. Program Analysis and Specialization for the C Program-
mingLanguage . Technical Report.
[5]Nels E. Beckman, Aditya V. Nori, Sriram K. Rajamani, and Robert J. Simmons.
2008. Proofs from tests. In Proc. of the International Symposium on Software
Testingand Analysis(ISSTA‚Äô08) (Seattle, WA, USA).
207ESEC/FSE ‚Äô20, November8‚Äì13,2020,VirtualEvent, USA David Trabish, Timotej Kapus, Noam RinetzkyandCristian Cadar
[6]RobertS.Boyer,BernardElspas,andKarlN.Levitt.1975. SELECT≈õAformalsys-
tem for testing and debugging programs by symbolic execution. ACM SIGPLAN
Notices10,6 (1975), 234≈õ245.
[7]CristianCadar,PeriklisAkritidis,ManuelCosta,Jean-PhillipeMartin,andMiguel
Castro.2008. DataRandomization . TechnicalReportMSR-TR-2008-120.Microsoft
Research.
[8]Cristian Cadar, Daniel Dunbar, and Dawson Engler. 2008. KLEE: Unassisted
and Automatic Generation of High-Coverage Tests for Complex Systems Pro-
grams.In Proc.ofthe8thUSENIXSymposiumonOperatingSystemsDesignand
Implementation(OSDI‚Äô08) (SanDiego, CA, USA).
[9]CristianCadarandDawsonEngler.2005.ExecutionGeneratedTestCases:Howto
Make Systems Code Crash Itself. In Proc. of the 12th International SPIN Workshop
onModelChecking ofSoftware(SPIN‚Äô05) (SanFrancisco, CA, USA).
[10]CristianCadar, VijayGanesh, Peter Pawlowski, David Dill,and Dawson Engler.
2006. EXE: AutomaticallyGeneratingInputsof Death.In Proc. ofthe 13thACM
Conference on Computer and Communications Security (CCS‚Äô06) (Alexandria, VA,
USA).
[11]CristianCadar, VijayGanesh, Peter Pawlowski, David Dill,and Dawson Engler.
2008. EXE: Automatically Generating Inputs of Death. ACM Transactions on
Informationand SystemSecurity(TISSEC) 12,2 (2008), 1≈õ38.
[12]Cristian Cadar and Koushik Sen. 2013. Symbolic Execution for Software Testing:
ThreeDecadesLater. CommunicationsoftheAssociationforComputingMachinery
(CACM)56,2 (2013), 82≈õ90.
[13]Miguel Castro, Manuel Costa, and Tim Harris. 2006. Securing Software by
EnforcingData-flowIntegrity.In Proc.ofthe7thUSENIXSymposiumonOperating
SystemsDesignand Implementation(OSDI‚Äô06) (Seattle, WA, USA).
[14]Sang Kil Cha, Thanassis Avgerinos, Alexandre Rebert, and David Brumley. 2012.
Unleashing Mayhem on Binary Code. In Proc. of the IEEE Symposium on Security
and Privacy (IEEE S&P‚Äô12) (SanFrancisco, CA, USA).
[15]Ramkrishna Chatterjee, Barbara G. Ryder, and William A. Landi. 1999. Rele-
vantContextInference.In Proc.ofthe26thACMSymposiumonthePrinciplesof
ProgrammingLanguages (POPL‚Äô99) (SanAntonio, TX, USA).
[16]Ben-ChungChengandWen-MeiW.Hwu.2000. ModularInterproceduralPointer
AnalysisUsingAccessPaths:Design,Implementation,andEvaluation.In Proc.
ofthe Conference on ProgramingLanguage Designand Implementation(PLDI‚Äô00)
(Vancouver, BC,Canada).
[17]Maria Christakis, Peter M√ºller, and Valentin W√ºstholz. 2006. Guiding Dynamic
Symbolic Execution Toward Unverified Program Executions. In Proc. of the 28th
InternationalConference onSoftwareEngineering (ICSE‚Äô06) (Shanghai, China).
[18]Lori A. Clarke. 1976. A Program Testing System. In Proc. of the 1976 Annual
Conference (ACM‚Äô76) (Houston, TX, USA).
[19]PeterCollingbourne,CristianCadar,andPaulH.J.Kelly.2011. SymbolicCross-
checkingofFloating-PointandSIMDCode.In Proc.ofthe6thEuropeanConference
onComputer Systems(EuroSys‚Äô11) (Salzburg,Austria).
[20]Peter Collingbourne, Cristian Cadar, and Paul H.J. Kelly. 2011. Symbolic Testing
of OpenCL Code. In Proc. of the Haifa Verification Conference (HVC‚Äô11) (Haifa,
Israel).
[21]P. Cousot and R. Cousot. 1977. Abstract Interpretation: A Unified Lattice Model
forStaticAnalysisofProgramsbyConstruction orApproximation of Fixpoints.
InProc. ofthe 4th ACM Symposiumonthe PrinciplesofProgrammingLanguages
(POPL‚Äô77) (LosAngeles, CA, USA).
[22]Christoph Csallner and Yannis Smaragdakis. 2005. Check ‚Äôn‚Äô Crash: Combining
staticcheckingandtesting.In Proc.ofthe27thInternationalConferenceonSoftware
Engineering (ICSE‚Äô05) (St.Louis, MO, USA).
[23]Leonardo De Moura and Nikolaj Bj√πrner. 2011. Satisfiability modulo theories:
introduction and applications. Communications of the Association for Computing
Machinery(CACM) 54,9 (Sept.2011),69≈õ77.
[24]BassemElkarablieh,PatriceGodefroid,andMichaelY.Levin.2009.PrecisePointer
Reasoning for Dynamic Test Generation. In Proc. of the International Symposium
onSoftwareTestingand Analysis(ISSTA‚Äô09) (Chicago, IL, USA).
[25]Patrice Godefroid, Nils Klarlund, and Koushik Sen. 2005. DART: Directed Auto-
matedRandomTesting.In Proc.oftheConferenceonProgramingLanguageDesign
and Implementation(PLDI‚Äô05) (Chicago, IL, USA).
[26]Patrice Godefroid, Michael Y. Levin, and David A. Molnar. 2008. Automated
Whitebox Fuzz Testing. In Proc. of the 15th Network and Distributed System
SecuritySymposium(NDSS‚Äô08) (SanDiego, CA, USA).
[27]Patrice Godefroid, Aditya V. Nori, Sriram K. Rajamani, and Sai Deep Tetali.
2010. Compositional May-Must Program Analysis: Unleashing the Power of
Alternation.In Proc.ofthe37thACMSymposiumonthePrinciplesofProgramming
Languages (POPL‚Äô10) (Madrid,Spain).
[28]Neville Grech, George Fourtounis, Adrian Francalanza, and Yannis Smaragdakis.
2017. HeapsDon‚ÄôtLie:CounteringUnsoundnesswithHeapSnapshots.In Proc.
ofthe ACMonProgrammingLanguages (OOPSLA‚Äô17) (Vancouver,BC,Canada).
[29]Neville Grech, George Fourtounis, Adrian Francalanza, and Yannis Smaragdakis.
2018.ShootingfromtheHeap:Ultra-scalableStaticAnalysiswithHeapSnapshots.
InProc.oftheInternationalSymposiumonSoftwareTestingandAnalysis(ISSTA‚Äô18)
(Amsterdam,The Netherlands).[30]Bhargav S. Gulavani, Thomas A. Henzinger, Yamini Kannan, Aditya V. Nori, and
Sriram K. Rajamani. 2006. Synergy: A New Algorithm for Property Checking. In
Proc. of the ACM SIGSOFT Symposium on the Foundations of Software Engineering
(FSE‚Äô06)(Graz, Austria).
[31]BenHardekopfandCalvinLin.2011. Flow-sensitivePointerAnalysisforMillions
of Lines of Code. In Proc. of the International Symposium on Code Generation and
Optimization(CGO‚Äô11) (Chamonix, France).
[32]Michael Hind. 2001. Pointer Analysis: Haven‚Äôt We Solved This Problem Yet?.
InProc. of the 2nd ACM SIGPLAN-SIGSOFT Workshop on Program Analysis for
SoftwareToolsand Engineering (PASTE‚Äô01) (Snowbird,UT, USA).
[33]Timotej Kapus and Cristian Cadar. 2019. A Segmented Memory Model for Sym-
bolicExecution.In Proc.ofthejointmeetingoftheEuropeanSoftwareEngineering
ConferenceandtheACMSymposiumontheFoundationsofSoftwareEngineering
(ESEC/FSE‚Äô19) (Tallinn, Estonia).
[34]James C. King. 1975. A New Approach to Program Testing. In Proc. of the
International Conference on ReliableSoftware (ICRS‚Äô75) (LosAngeles, CA,USA).
[35]PaulDanMarinescuandCristianCadar.2012. maketest-zesti:ASymbolicExecu-
tion Solution for Improving Regression Testing. In Proc. of the 34th International
Conference onSoftwareEngineering (ICSE‚Äô12) (Zurich,Switzerland).
[36]PaulDanMarinescuandCristianCadar.2013. KATCH:High-CoverageTestingof
SoftwarePatches.In Proc.ofthejointmeetingoftheEuropeanSoftwareEngineering
ConferenceandtheACMSymposiumontheFoundationsofSoftwareEngineering
(ESEC/FSE‚Äô13) (Saint Petersburg,Russia).
[37]Ana Milanova, Atanas Rountev, and Barbara G. Ryder. 2005. Parameterized
Object Sensitivity for Points-to Analysis for Java. ACM Transactions on Software
Engineering Methodology (TOSEM) 14,1 (Jan. 2005),1≈õ41.
[38]Corina S. PƒÉsƒÉreanu, Willem Visser, David Bushnell, Jaco Geldenhuys, Peter
Mehlitz, and Neha Rungta. 2013. Symbolic PathFinder: Integrating Symbolic
Execution withModel Checking for Java BytecodeAnalysis.In Proc.ofthe28th
IEEE International Conference on Automated Software Engineering (ASE‚Äô13) (Palo
Alto, CA, USA).
[39]John Plevyak and Andrew A. Chien. 1994. Precise Concrete Type Inference
for Object-oriented Languages. In Proceedings of the Ninth Annual Conference
onObject-orientedProgrammingSystems,Language,andApplications (Portland,
Oregon, USA) (OOPSLA‚Äô94) .
[40]BarbaraG.Ryder.2003. DimensionsofPrecisioninReferenceAnalysisofObject-
OrientedProgrammingLanguages.In InProc.ofthe12thInternationalConference
onCompiler Construction (CC‚Äô03) .
[41]Micha Sharir and Amir Pnueli. 1981. Two approaches to interprocedural data flow
analysis. Prentice-Hall,Englewood Cliffs,NJ, Chapter 7,189≈õ234.
[42]Jiri Slaby, Jan Strejƒçek, and Marek Trt√≠k. 2013. Symbiotic: Synergy of Instru-
mentation, Slicing, and Symbolic Execution. In Proc. of the 19th International
Conference on Tools and Algorithms for theConstruction and Analysis ofSystems
(TACAS‚Äô13) (Rome, Italy).
[43]Yannis Smaragdakis and George Balatsouras. 2015. Pointer Analysis. Found.
TrendsProgram. Lang. 2,1 (April2015),1≈õ69.
[44]Manu Sridharan,Satish Chandra, Julian Dolby, Stephen J. Fink, and Eran Yahav.
2013.AliasAnalysisforObject-OrientedPrograms . SpringerBerlinHeidelberg,
Berlin, Heidelberg, 196≈õ232.
[45]Yulei Sui and Jingling Xue. 2016. On-demand Strong Update Analysis via Value-
flow Refinement. In Proceedings of the 2016 24th ACM SIGSOFT International
SymposiumonFoundationsofSoftwareEngineering (Seattle,WA,USA) (FSE2016) .
[46]Yulei Sui and Jingling Xue. 2016. SVF: Interprocedural static value-flow analysis
inLLVM.In Proc.ofthe25thInternationalConferenceonCompilerConstruction
(CC‚Äô16)(Barcelona,Spain).
[47]David Trabish, Andrea Mattavelli, Noam Rinetzky, and Cristian Cadar. 2018.
Chopped Symbolic Execution. In Proc. of the 40th International Conference on
SoftwareEngineering (ICSE‚Äô18) (Gothenburg,Sweden).
[48]David Trabish and Noam Rinetzky. 2020. Relocatable Addressing Model for
Symbolic Execution. In Proc. of the International Symposium on Software Testing
and Analysis(ISSTA‚Äô20) (Online).
[49]RobertP.WilsonandMonicaS.Lam.1995. EfficientContext-sensitivePointer
Analysis for C Programs. In Proc. of the Conference on Programing Language
Designand Implementation(PLDI‚Äô95) (La Jolla, CA, USA).
[50]ValentinW√ºstholzandMariaChristakis.2018. TargetedGreyboxFuzzingwith
StaticLookaheadAnalysis.In Proc.ofthe42ndInternationalConferenceonSoft-
wareEngineering (ICSE‚Äô20) (Online).
[51]Hua Yan, Yulei Sui, Shiping Chen, and Jingling Xue. 2018. Spatio-temporal
Context Reduction: A Pointer-analysis-based Static Approach for Detecting Use-
after-freeVulnerabilities.In Proceedingsofthe40thInternationalConferenceon
SoftwareEngineering (Gothenburg,Sweden) (ICSE‚Äô18) .
[52]JunfengYang,CanSar,PaulTwohey,CristianCadar,andDawsonEngler.2006.
Automaticallygeneratingmaliciousdisksusingsymbolicexecution.In Proc.of
the IEEE Symposium on Security and Privacy (IEEE S&P‚Äô06) (Oakland, CA, USA).
[53]GretaYorsh,ThomasBall,andMoolySagiv.2006. Testing,Abstraction,Theorem
Proving: Better Together!. In Proceedings of the International Symposium on
SoftwareTestingand Analysis (ISSTA‚Äô06) .
208