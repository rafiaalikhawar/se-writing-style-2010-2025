DetectingandLocalizingKeyboardAccessibilityFailuresinWeb
Applications
Paul T.Chiou
Universityof SouthernCalifornia
USA
paulchio@usc .eduAli S.Alotaibi
Universityof SouthernCalifornia
USA
aalotaib@usc .eduWilliamG.J.Halfond
Universityof SouthernCalifornia
USA
halfond@usc .edu
ABSTRACT
Thekeyboardisthemostuniversallysupportedinputmethodop-
erable by people with disabilities. Yet, many popular websites lack
keyboard accessible mechanism, which could cause failures that
make the website unusable. In this paper, we present a novel ap-
proach for automatically detecting and localizing keyboard accessi-
bility failures in web applications. Our extensive evaluation of our
technique on real world web pages showed that our technique was
able to detect keyboard failures in web applications with high pre-
cisionandrecallandwasabletoaccuratelyidentifytheunderlying
elements inthe webpagesthat ledto the observedproblems.
CCS CONCEPTS
Â·Software andits engineering ;
KEYWORDS
Web Accessibility, WCAG, Software Testing, Keyboard Navigation
ACMReference Format:
Paul T. Chiou, Ali S. Alotaibi, and William G. J. Halfond. 2021. Detecting
and Localizing Keyboard Accessibility Failures in Web Applications. In
Proceedingsofthe29thACMJointEuropeanSoftwareEngineeringConference
andSymposiumontheFoundationsofSoftwareEngineering(ESEC/FSEâ€™21),
August 23Å›28, 2021, Athens, Greece. ACM, New York, NY, USA, 13pages.
https://doi.org/10.1145/3468264 .3468581
1 INTRODUCTION
The Web is fundamentally designed to work for Å‚all peopleÅ¾ [ 5];
yet,15%oftheworldâ€™spopulationpossessessometypeofdisability
[28]thatcanhindertheirabilitytousetheWeb.Forthem,access
towebapplicationsisparticularlyimportantastheWebprovides
connectionstoservicesandinformationthatmightotherwisebe
unavailable [ 9]. Despite legislation that mandates companies to
provideequallyaccessiblewebsites[ 54],webaccessibilityissuesare
widespread.Asof2019,70%ofinternetsitescontainedÅ‚accessibility
blockersÅ¾thatmadecriticalfunctionalityinaccessibletodisabled
users[3],resultinginconsiderabledisadvantagesforpeoplewith
disabilities.
Userswithdisabilitiesareoftenunabletouseatraditionalpoint-
and-clickortouch-operateddeviceandmustuseothermechanisms
Permissionto make digitalor hard copies of part orall ofthis work for personalor
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
onthefirstpage.Copyrightsforthird-partycomponentsofthisworkmustbehonored.
Forallotheruses,contactthe owner/author(s).
ESEC/FSE â€™21, August 23Å›28,2021, Athens,Greece
Â©2021 Copyright heldby the owner/author(s).
ACM ISBN 978-1-4503-8562-6/21/08.
https://doi.org/10.1145/3468264 .3468581to interact with web applications. For example, users with disabili-
tiesmayemployAssistiveTechnology( AT),suchasscreenreaders,
speech-basedcontrollers,andswitchdevices.Sincethekeyboard
isthemostuniversallysupportedalternativeinputmethodoper-
able by people with disabilities [ 12], mostATgenerate emulated
keystrokes to navigatea web applicationâ€™s User Interface( UI). Un-
fortunately, keyboard accessibility is one of the most common and
prevalent accessibility issues [ 6,50,70,71]. Studies show that as
many as 48% of popularwebsites lack keyboard accessible mecha-
nisms[66]and4%containaccessibilitybugsthatmakethekeyboard
completely unusable [ 52]. We call the manifestation of these issues
KeyboardAccessibilityFailures(KAFs) ,whichare,broadly,failures
thatpreventtheuser from interactingwith the webappâ€™s UIfea-
tures using the keyboard.
Testingfor KAFsischallengingduetothehighlycomplexnature
ofclient-side UIsinmodernwebapplications.These UIsprovide
responsive and dynamic interfaces that are highly mutable and
containcontentthatcanbedynamicallycreatedandbindedwith
JavaScript. This poses several challenges: First, the static HTML
source code may not resemble the Document Object Model ( DOM)
with which end-users actually interact, making traditional static
analysisonHTMLsourcecodeinadequate.Second,thekeyboard
interactiongovernedbytheevent-drivenexecutionenvironment
maybeconstantlychangingasthewebapplicationentersdifferent
UIstates.Thismakesitnecessarytoidentifyawebapplicationâ€™s
possiblebehaviors,beyondsimplyaone-timeÅ‚snapshot.Å¾Finally,
theJavaScriptcoderesponsibleforeventhandlersandtheirinterac-
tions can be difficult to analyze using static analysis, which makes
itdifficult tostaticallymodelkeyboard handlingina UI.Together,
these challenges can make it very difficult to adequately test for
keyboardaccessibilityissues.
Existingtechniquesforidentifyingkeyboardinaccessibilityis-
sues have limitations in their usage and applicability. For example,
Fona [66] statically analyzes a web pageâ€™s DOMcontent to iden-
tifyKAFs. However, it only analyzes specific attributes of DOM
elements and does not completely capture all the different ways
KAFscanbeintroducedintoawebpage.Otherapproaches,suchas
Pyccuracy [68]andaria-check [67]allowdeveloperstowriteoruse
scenariobasedteststocheckkeyboardaccessibilityrequirements.
However, these technique require developers to employ manually
generatedtestcasesforeachoftheirpagesandanticipatetheprob-
lems that may occur. As a result, keyboard accessibility testing
largely remains a manual effort that requires visual inspections of
a web page [ 10,26],which makes it a timeconsuming [ 69], costly,
anderror-prone [ 51]process.
Inthispaperwepresentournovelapproachforautomatically
detectingandlocalizing KAFsinwebpages.Toachievethis,ourap-
proachcombinesbothstaticanddynamicanalysisbasedtechniques
855
ESEC/FSE â€™21, August 23Å›28, 2021,Athens,Greece PaulT. Chiou, AliS.Alotaibi,andWilliamG.J. Halfond
1
2
3
4
5
6
7
89n
10
1112 n-1
1
2
3 4 5
6 7 8
9
Figure 1:Real-world examples ofKAFs ( Alexa- left;California DMV - right)
to both address the complications caused by complex modern web
appUIs and more completely identify behaviors that can cause
KAFs. Our approach defines a dynamic web crawling technique
that systematically builds a model representing the possible key-
boardbasednavigationthroughawebpageâ€™s UIelements,including
thoseinducedbyJavaScriptbasedbehaviors.Thenourapproach
analyzesthismodeltoidentifywhenthepresentormissingnav-
igationflowswillleadtoa KAF.Ourevaluationofthetechnique
showed that it is very accurate, in terms of precision and recall, in
detecting KAFs and identifying the HTML code responsible for the
observedfailures.Thekeycontributionsofthispaperare(1)The
firstdefinedkeyboard-basednavigationalmodelforawebpage,(2)
The first formalization of keyboard accessibility issues in terms of
graph-basedproperties,(3)Afullyautomateddetectionandlocal-
ization technique that outperforms state-of-the-art and practice on
real-world web applications, and (4) A study on a set of real-world
webpagesthat showsthat our approach isaccurateandefficient.
2 BACKGROUND
Keyboard usage is one of the foundational requirements for web
accessibility and it is reflected in Guideline 2.1 of the W3C Web
AccessibilityInitiative(WAI)â€™sWebContentAccessibilityGuideline
(WCAG) 2.1 [21]. These guidelines require web UIs to be usable by
themany users that operatethecomputersolelywith akeyboard-
based inputdevice. Keyboard-based users utilizeasetof standard
keyboard commands to navigate to different items of interest in
webapplicationsandcarry outadesiredaction [ 20].
Keyboard-based users and point-and-click ( PNC) based users
interactwithawebpageâ€™sUIelementsinaverydifferentmanner.
InthePNCmodality, usersmoveacursorusing apointingdevice
(e.g.,mouse)andpressbuttonstoactivatea UIelementunderneath
the cursor. In the keyboard modality, users must press keyboard
buttons, such as
 Taband
Shift+
Tab, to move the browserâ€™s focus
toaUIelementthattheuserwantstointeractwith.Unlikethe PNC
modality,movingbetween UIelementswithakeyboardhappens
sequentially;meaningthatifauseriscurrentlyonelement ğ‘›and
wantstointeractwithelement ğ‘›+ğ‘–,thentheusermustpressthe
Tabğ‘–timesuntilfocusisonthedesiredelement.Theusermayalso
press
Shift+
Tabto move backwards through the elements. The
ordering of the elements is determined by the browser based on
the structure of the DOM, but may be overridden by a developer
using JavaScript or HTML attributes, such as tabindex . In this
paper, we call the ordering of the elements in this sequence the
keyboardnavigationflow ofthewebpageâ€™s UI.Onceanelementhas
focus,akeyboardusercancarryoutactionsonitbypressingother
keyboard buttons. For example, when the focus is moved onto agroupofelements,suchasmenulistsorradio-buttons,thearrow
keys
 canbeusedtomovebetweentheelements
of the group. The
 Spaceor
Enterkeys are used to manipulatethe
element currently in focus and the
 Esckey is typically used to
exit a user prompt or dialog [ 26]. All web browsers are required by
the W3Câ€™s User Agent Accessibility Guidelines [ 23] to support this
standardsetofkeyboardstrokesthroughtheir keyboardAPI.
AlthoughKeyboardAccessibilityFailures( KAFs)canrefer toa
widerangeofkeyboardrelatedaccessibilityissues,inthispaper,we
usethetermtospecificallyrefertotwocommontypesof KAFsthat
impact the keyboard navigation flow of a web pageâ€™s UI. These are:
(1)InaccessibleFunctionalities(IAFs) and (2)Keyboard Traps ( KTFs),
which are formally defined under WCAGSuccess Criteria (SC)
sections 2.1.1 and 2.1.2. We explain these two types in detail below.
2.1 Inaccessible Functionalities
SC2.1.1 requires all functionality of a web page to be available via
the keyboard interface. The term Inaccessible Functionality ( IAF)
isusedtodescribefailuresofawebpage UItoconformwiththis
guideline. This type of KAFoccurs when an interactive element
is not included in the keyboard navigation flow of the UIor an
element in the navigation flow does not have a keyboard event
handler. This means that a keyboard-based user is either unable to
usethestandardkeyboardnavigationkeystoputfocusononeor
moreelementsinthepageâ€™s UIorthattheelementisnotactionable
and the user is unable to activate the UIelementâ€™s functionality.
Therearemanyrootcausesofthistypeoffailure,whichwediscuss
indepthinSection 5.4.2,butmostrelatetocustomcontrolelements
that do not have eventhandlers properly defined.
An example of inaccessible functionality occurs in the header
navigationmenuofthe Alexawebsite,whichwefoundinourEvalu-
ationandisshowninFigure 1.InthissubjecttheÅ‚solutionsÅ¾( âŠ)and
Å‚toolsÅ¾ (
12 ) menu items expand sub-menu items when the mouse
cursorishoveredoverthem.Thesemenuitemsareimplemented
with<div>elementsthathavethe :hoverCSSpseudo-class[ 13]
defined in the web pageâ€™s static CSS declarations to make them in-
teractable.Sincetheexpansionofthesub-menusareonlytriggered
withmousehover,thecontainedlinks( â‹to
11)arenotaccessible
to keyboard-based users, resulting in a situation where none of the
sub-menu items can be seen byakeyboard-baseduser.
2.2 Keyboard Traps
SC2.1.2requiresthatifkeyboardfocuscanbemovedtoa UIelement
ofthepageusingthekeyboardinterface,thenfocusmustalsobe
able to move away from that element using only the keyboard
856DetectingandLocalizing KeyboardAccessibility Failuresin WebApplications ESEC/FSE â€™21, August 23Å›28, 2021,Athens,Greece
interface.Theterm KeyboardTrap( KTF)isusedtodescribefailures
of a web page UIto conform with this guideline. This type of KAF
occurswhenfocusbecomes"stuck"onasequenceofoneormore
interactive elements and the user is unable to interact further with
otherpartsofthewebpageviathekeyboard.Aswiththefirsttype
ofKAF,therearemanypossiblerootcausesforthiskindof KAF,
whichwediscussindepthinSection 5.4.2,butthemostcommon
istheuseofthird-partywidgetpluginsthatoncereceivingfocus,
preventedtheuserfromreturningtocontentoutsideoftheplug-in
viathe keyboard.
Figure1showsanexampleofa KTFthatwefoundinoneofour
Evaluationsubjects,the CaliforniaDMV â€™sappointmentregistration
page[29].ThistrapwascausedbyJavaScriptthatautoadvanced
thekeyboardcursorwhentheusertypedpartofaphonenumber.
When three numbers were entered into the area code input field
(âŒ), developer-defined JavaScript code automatically advanced the
cursor to put focus on the next input field ( â). Consequently, a
keyboard user was not be able to make a correction to the area
code by moving backwards, since on each attempt to shift focus
to the area code input box would cause the JavaScript to again
advance focus to the next input field ( â). In fact, any interactive
elementprior tothetrap (e.g., âŠtoâŒ)was nolongeraccessible to
the keyboarduserafter enteringan area code.
3 WEBAPPLICATION MODELING
Toperformthedetectionandlocalizationof KAFs,ourapproach
firsttakesaPageUnderTest( PUT)asinputandbuildsmodelsof
the ways users can interact with it via both the keyboard and PNC.
This is shown in the left half of Figure 2. The Keyboard Navigation
Flow Graph ( KNFG) models the different ways a keyboard user
can interact with a PUT. To the best of our knowledge, we are
thefirsttodefinesuchamodel.ThePoint-ClickNavigationFlow
Graph (PCNFG) represents the ways a PNCuser can interact with
awebpageâ€™s UIandis similarto existing representations,such as
the state flowgraph [ 57].
Keyboard Navigation Flow Graph 
Point-Click Navigation Flow GraphPUT
xpath1
xpath2
â‹®
report
KNFG
PCNFGÂ§3.1
Â§3.2
Localization Detection
Â§4.1, Â§4.3  Â§4.2, Â§4.4  
Figure 2:Anoverview ofour approach
3.1 Modeling KeyboardNavigationFlow
KNFG Formal Definition. To model keyboard navigation flow,
we define a new abstraction, the Keyboard Navigation Flow Graph
(KNFG). APUTâ€™s keyboard navigation flow is represented by a set
ofKNFGs. EachKNFGrepresents the ways a web pageâ€™s UI can
be navigated from the perspective of a keyboard user. Formally,
we represent a KNFGas a tupleâŸ¨ğ‘‰,ğ‘‰ğ‘ ,ğ‘£0,Î¦ğ¾,ğ¸âŸ©, whereğ‘‰is theset of all nodes in the graph and each ğ‘£âˆˆğ‘‰corresponds to a
unique HTML element in the PUT,ğ‘‰ğ‘ âŠ†ğ‘‰represents a state of
thePUT, which we define as the set of HTML elements that are
visibleinthe PUT,ğ‘£0âˆˆğ‘‰ğ‘ istheentrynodeofthegraph(i.e.,the
first HTML element thatkeyboard-basedusers can interact with
when the PUTrenders in the browser); Î¦ğ¾is the set of standard
keyboard-based actions that may cause a focus transition between
nodesinthegraph;and ğ¸isthesetofdirectededgesthatrepresent
the transitionsthat can occur inthe PUT.
KNFG Nodes. The node set of a KNFG,ğ‘‰, contains a node
for each HTML element in the PUT. Our approach identifies the
nodesbyrenderingthe PUTinabrowserandthenanalyzingthe
PUTâ€™sDOMto identify each unique HTML element. Each node is
uniquely identified by its XPath in the DOM. Our approach groups
syntactically linked nodes such as a <label>and its bounded form
elementandelementswrappedwithinotherinlinecontrolelements,
sincethesenodesareintendedtorepresentasinglefunctionality.A
nodeğ‘£0âˆˆğ‘‰representstheentrynodeofthegraphandistheHTML
elementinthepagethatisthestartingpointforkeyboard-based
navigationofthepage.A PUTâ€™sinitialğ‘£0nodecanbeidentifiedby
determining the XPath of the element thatinitially has focus after
the page rendersinthe browser.
The inclusion of state ( ğ‘‰ğ‘ ) in theKNFGenables our approach to
modelmodern webapplications where new HTMLelementsmay
beenabledoraddedtoa PUT.Wedefine ğ‘‰ğ‘ asthesubsetofallnodes
inthePUTthatarevisibleinthebrowser.Althoughrelatedwork
hasproposedmanydefinitionofstateforwebpages,weusethis
because it is well-suited for our problem domain, since only visible
elementscanbeinteractedwithviathekeyboardandanychangein
thesetofvisibleelementsmayintroduceanewnavigationflow.To
illustrate,considerFigure 3,whichshowsahidden <div>compo-
nentthatisnotdisplayeduntiltheuseractivatesthe Å‚ForgotNameÅ¾
linkÅ›itseventhandlingtriggersandexpandsthehidden <div>,
displayingtheencompassedthree Å‚PhoneLookupÅ¾ textfields.Our
approach would consider
1 ,
2, and
3to be distinct states, since
the additional displayed links will define a new navigation flow
throughthe PUT.AchallengeinidentifyingtheHTMLelements
thatcomprise ğ‘‰ğ‘ isthatduetothecomplexinteractionsbetween
HTML andCSS attributes, there is nocanonical way to determine
if a given node is visible. Therefore, we compiled a set of heuris-
tics that our approach uses to determine if an element is visible.
Theseare(1)non-disabledelementsthatdonotexhibitafinalcom-
putedDOMlayout style of type="hidden" ,visibility:hidden ,
display:none , or inherit their ancestorâ€™s rendered hidden prop-
erties; (2) elements that are not rendered with a height or width
of zero pixels; or (3) excluded from the PUTâ€™s visual flow (e.g.,
elements inside another tab-menu, or inside containers that are
collapsed whose contents arenâ€™t shown). All of these heuristics
can be identified by analyzing the attributes of the elements in the
DOMofthe PUT when ithas been renderedinthe browser.
KNFGEdges. Theedgeset ğ¸ofaKNFGrepresentsthekeyboard
navigationflowpossibleasaresultofkeyboard-basedactions.A
keyboard user can manipulate a pageâ€™s interactive elements using
astandardsetofactions,whichwerepresentwith Î¦ğ¾.This setof
actions includes all standard keyboard commands used to navigate
awebapplicationâ€™sUIasdefinedbyW3C[ 24]andwebaccessibility
testing communities [ 10,19,26].Î¦â€™s operations can be broken
857ESEC/FSE â€™21, August 23Å›28, 2021,Athens,Greece PaulT. Chiou, AliS.Alotaibi,andWilliamG.J. Halfond
input divdiv Win
btn
input divdiv Win
btn link
link spaninput divdiv Win
btn link
link span
input input inputForgot 
Name
Sign Up [x]SearchNameDropdown 
#2Dropdown 
#1
Tel #1 Tel #2 Tel #3Forgot 
NameSearchName Dropdown 
#2
Sign Up [x]Dropdown 
#1Dropdown 
#1
Dropdown 
#2Name
SearchTab
Shift-Tab
Tab Shift-Tab
Enter / Space Esc
Esc
EnterTab
Shift-Tab
Tab
Shift-Tab
TabShift-TabTab
Shift-Tab Tab
Shift-TabTab
Shift-TabShift-Tab
TabTab
Shift-TabTab
Shift-Tab
Ïƒğ‘€Shift-TabShift-Tab Shift-Tab
Tab TabShift-Tab1
2
3
Dropdown 
#1
Dropdown 
#2Name
Searchinput divdiv User
btn
input divdiv User
btn link
link spaninput divdiv User
btndiv
div
div
input divdiv User
btn link
link span
input input inputinput divdiv User
btn div
div
â‹® â‹®Hover- In
Click
ClickClick
Clickmouseover
defaultmouseover
mouseover
click
clickdefault
clickdefault
click
clickmouseover
mouseoverdefault
clickdefault
default1
45
3Dropdown 
#1
Dropdown 
#2Dropdown 
#1
Dropdown 
#2Dropdown 
#1
Dropdown 
#2
Menuitem
#1
Menuitem
#2
Menuitem
#3Menuitem
#1
Menuitem
#2Name
SearchName
SearchName
Search
Dropdown 
#1
Dropdown 
#2Name
SearchForgot 
Name
Sign Up [x]
Forgot 
Name
Sign Up [x]
Tel #1 Tel #2 Tel #3Hover-Out
Enter / Esc
Enter / 
Esc
Ïƒğ‘€Shift-TabEnter , ğœ¹ = ğ…ğšğ¥ğ¬ğ ğ’—ğŸ
ğ’—ğŸ
ğ’—ğŸ
1 4
5
321
2
32
Figure 3: A simplified version of the KNFG* (left) and PCNFG* (right) with their corresponding UI states (omitted some non-
interactive nodes andself-loopedges incurred by
 ,
,
,
,
Enter,
Space,or
Esc)
intofourcategories:navigation(
 Tab,
Shift+
Tab),selection(
 ,
,
,
),actuation(
 Enter,
Space)anddismissal(
 Esc).Our
approach does not model keyboard shortcuts or scrolling keys
suchas
 PgUp,
PgDn,
Home,and
Endsincetheyonlychangehow
contents are displayed (or move the keyboard cursor within a text
input-basedcontrol)andservenointeractive purposes.Totrigger
navigationbehaviorsthatrequiretextinput,wealsoincludetwo
actionsthatrepresentstheentryoftext.Thefirstis Î£andrepresents
the entry of a random length string of alphanumeric characters.
Thesecondis Î£ğ‘€andrepresentstheentryofamaximumlength
string into the text input, where maximum length is determined
bythemaxlength attributeofthetextinput,ifdefined.Bothtext
entry actions are followed by the
 Tab,
Shift+
Tab, or no action.
This simulates the common user behavior of entering input or
interactingwithacontrol,andthenmovingtoeitherthenextor
priorelementinapage.Inthetext,wewilldenotethesesequences
by showing both relevant symbols as the action, even though they
can be represented as a single compound action (e.g., entering max
length text and then pressing tab would be represented as Î£ğ‘€
Tab)
KNFG Construction. At a high level, the edges in the KNFG
areidentifiedbyiterativelyexploringthepageusingonlykeyboard-
basedactions(i.e., Î¦ğ¾)untilnonewnavigationinformationisfound
(i.e., the graph has reached a fixed point). The first iteration of this
process begins by interacting with each node ğ‘£âˆˆğ‘‰ğ‘ . For a given ğ‘£,
our approach first sets the browserâ€™s focus on ğ‘£and then executes
everyactionin Î¦ğ¾onğ‘£. Aftereach action,our approach analyzes
thepagetodeterminethefocustransitionthatoccurred.Ifanaction
ğœ™causes a new state to be created, then the new state is added to a
worklist of states that will be explored in subsequent iterations of
the edge building process. If the action causes the page to attempt
tonavigatetoadifferentpage,ourapproachinterceptsthisevent
andpreventsitfromhappening.Ourapproachalsoincludestwo
edgesthatlinkthelastelementinapageâ€™stabordertothefirst(i.e.,
ğ‘£ğ‘›â†’ğ‘£0andğ‘£ğ‘›â†ğ‘£0). This is done in order to exclude browser
controls, which are accessible via
 Tab, from the KNFG. An edge
can be either an intra or inter state edge. We describe the details of
handling eachkindofedge below.
Intra-stateedgesdescribethenavigationflowinapageasaresult
of an action on a node when there is no new page state created.
Aftertriggeringanaction ğœ™âˆˆÎ¦ğ¾onanode ğ‘£ğ‘–,ourapproachdetectsthefocuschangefrom ğ‘£ğ‘–toğ‘£ğ‘–+1andcreatesanedgeinthegraph
âŸ¨ğ‘£ğ‘–,ğ‘£ğ‘–+1,ğœ™,ğ›¿,ğ‘‰ğ‘ âŸ©,indicatingthatthebrowserfocuscouldshiftfrom
a source node ğ‘£ğ‘–to a target node ğ‘£ğ‘–+1by pressing keystroke ğœ™
whileğ‘£ğ‘–is in focus. Our approach detects a change in focus by
queryingthebrowsertoidentifytheelementcurrentlyreceiving
focus in the PUT. If an action does not trigger a focus-shift (e.g.,
executing
 Spacetotickacheckbox),aselfedgeiscreated.Ouredge
creationmechanismcancaptureashift(ornoshift)infocusthatis
caused by JavaScript event handlers since it simply observes the
response of the page to the keyboard action, which would include
any JavaScript actions. Lastly, if ğœ™causes any sort of change in the
DOMâ€™sattributesâ€™values,then the ğ›¿flagissetto True,otherwise
itissetto False.Usingourrunningexample,anintra-stateedge
exists between the Å‚ NameÅ¾ input-field to the Å‚ SearchÅ¾ button since
focuscantransitionbetweenthetwoelementsbypressingthe
 Tab
and no new visible HTML elements appear (i.e., there is no new
statecreated).Thisedgeandotherintra-stateedgesforourexample
are showninredinFigure 3.
Inter-state edges describe the navigation flow in a page when
anactiononanodeleadstothecreationofanewUIstate.When
our approach detects a new state, it creates an edge in the same
waythatanintra-stateedgewouldbecreatedwiththeexception
of the target node. In this scenario, the target node is in the new
state(ğ‘‰â€²ğ‘ )andisthenode ğ‘£0âˆˆğ‘‰â€²ğ‘ towhichfocusistransferredto
bythebrowser.Anexampleofaninter-stateedgecanbeseenin
ourrunningexamplewherepressing
 EscontheÅ‚ForgotName Å¾and
Å‚Sign UpÅ¾ links in state
2 (when the <div>component containing
these links is active) will dismiss the <div>component and return
the navigation to state
1 . This edge and other inter-state edges are
representedas green edges inFigure 3.
TheKNFGconstruction is sound under the assumption that the
keyboard navigation is deterministic (i.e., executing ğœ™on every
node would always transition the focus to the same node and a
node has exactly one predecessor/successor through an intra-state
edge).Inthecaseswherenon-determinismdidoccur(anelement
could transition to different elements), we observed such cases
were always accompanied by some kind of visual state change,
which would be captured in the KNFGbuilding process. The edge
construction is complete with respect to the W3C default set of
standardizedkeyboardnavigationkeys.Ifawebpageweretouse
858DetectingandLocalizing KeyboardAccessibility Failuresin WebApplications ESEC/FSE â€™21, August 23Å›28, 2021,Athens,Greece
non-standard keys for interaction, our approach would not explore
these actions. However, it is important to note that these cases are
not common in practice and our Î¦ğ¾could be easily redefined to
handle other key sets. The node identification is complete, since
all nodes in a page can be identified by examining the DOMof the
page at runtime. The only exception to this is for web sites that
embed objects, such as legacy Flash, Silverlight, Java Applets, or
third-party plugins, neither of which are modeled in the KNFG.
However,notethatsupportfortheseframeworksiscurrentlybeing
phasedoutbymajorbrowsers [ 8].
3.2 Modeling Point andClick Navigation
Thenavigationandinteractionsavailabletoa PNCuserina PUT
are represented by a set of Point-Click Navigation Flow Graphs
(PCNFGs).EachPCNFGrepresentsthewaysawebpageâ€™sUIcanbe
interacted with from the perspective of a PNCuser for a particular
stateofthe PUTâ€™sUI.Formally,werepresenta PCNFGasatuple
âŸ¨ğ‘‰,ğ‘‰ğ‘ ,ğ‘£ğ‘¢ğ‘ ğ‘’ğ‘Ÿ,Î¦ğ‘€,ğ¸âŸ©, whereğ‘‰is the set of all nodes in the graph,
ğ‘‰ğ‘ âŠ†ğ‘‰represents the state, which is defined by the set of nodes
that are visible in the PUT,ğ‘£ğ‘¢ğ‘ ğ‘’ğ‘Ÿâˆˆğ‘‰is the initial node; Î¦ğ‘€is the
setofmouseeventtypes;and ğ¸isthesetofedgesthatrepresent
the mouse navigation controlflow.
Information about the nodes in the PCNFGis defined similar
to that of the KNFG. Specifically, the node set ( ğ‘‰) and state ( ğ‘‰ğ‘ )
ofthe PCNFG are definedand identifiedinthe same wayas those
for theKNFG. The one exception to this is the definition of the
entrynode ğ‘£ğ‘¢ğ‘ ğ‘’ğ‘Ÿofthegraph.Unlikethecaseofkeyboard-based
navigation, there is not a single node in the PUTthat represents
the starting point for PNCbased navigation.Therefore, we define
aspecialnode ğ‘£ğ‘¢ğ‘ ğ‘’ğ‘Ÿthatconceptuallyrepresentstheentrytothe
PUTand connects to all of the nodes that a PNCuser can interact
withinthe PUT.
APNCbased user can manipulate a pageâ€™s interactive elements
usingasetofactions,whichwerepresentwith Î¦ğ‘€.Thissetincludes
all mouse event types that implement the MouseEvent interface
[22],suchas mousedown ,mouseup,click,mouseover ,mouseenter ,
mouseleave , ormouseout . The edges in the PCNFGare defined
usingastandarditerativecrawlingexploration.Forexample,similar
totheconstructionofthestateflowgraphoriginallyproposedby
Crawljax[ 57].In ourapproach,thetargetelementsthat willhave
events triggered on them are represented by ğ‘‰ğ‘ and the events
to be triggered on them are represented by Î¦ğ‘€. We omit further
detailsofthisexplorationduetospaceconstraintsandsinceitis
notacontributionofourapproach.Anexample UIandPCNFGare
showninFigure 3.
4 DETECTIONAND LOCALIZATION OFKAFS
AsshowninFigure 2,onceourapproachhasgeneratedthe KNFGs
andPCNFGsforthePUT,itdetectsandlocalizes KAFsbyanalyzing
andcomparing the twographs.
4.1 DetectionofInaccessible Functionalities
AnIAFoccurs when functionality available to a point-and-click
(PNC) user is not available to a keyboard user. At a high level, our
approach identifies all of the interactive HTML elements available
to aPNCuser by analyzing the PCNFGand then, by analyzingtheKNFG, checksthat the same elements can be navigated to and
activatedbyakeyboarduser.
OurapproachtodetectIAFsisshowninAlgorithm 1.Theinputs
tothis algorithmare the set of PCNFGsandKNFGs thatwere pre-
viouslyconstructed.Wedenotethesesetsas PCNFG*andKNFG*,
respectively. First, the algorithm identifies the functionality (i.e.,
interactive elements) available to a PNCbased user (line 2). This is
done by calculating ğ‘‰ğ‘ƒğ¶the set of nodes in the PCNFG* that are
reachable from ğ‘£ğ‘¢ğ‘ ğ‘’ğ‘Ÿ(i.e., the entry node) of the initial state of the
PCNFG*. Next the approach iterates over each node ğ‘£ğ‘ğ‘âˆˆğ‘‰ğ‘ƒğ¶and
checksifitisalsoaccessibletoakeyboarduser(lines3Å›8).Foreach
ğ‘£ğ‘ğ‘, the approach finds the corresponding node ğ‘£ğ‘˜in theKNFG*
(line4).Notethatforagivenstate,boththe PCNFGandKNFGhave
the same ğ‘‰set, and therefore there will always be a corresponding
node if the corresponding KNFGstate exists.
Non-reachableIAFs. Thefirstaccessibilitycheck(line5)de-
terminesif ğ‘£ğ‘˜isreachablefrom ğ‘£0oftheKNFG*.Ifitisnot,then
thisimpliesakeyboardusercannotnavigateto ğ‘£ğ‘˜(i.e.,ğ‘£ğ‘˜cannot
receivekeyboardfocus)usingthekeyboardnavigationflowdefined
by thePUTandğ‘£ğ‘˜is considered to be inaccessible and added to
ğ‘‰ğ¼ğ¹,the setofelements inaccessibledueto flowproblems (line6).
Non-actionableIAFs. Thesecondaccessibilitycheck(line7)
determines if ğ‘£ğ‘˜is actionable. A naive way to detect this would
betosimplyexaminethe DOManddetermineif ğ‘£ğ‘˜haseitheran
explicitorimplicitkeyboardeventhandlerassociatedwithit.How-
ever,akeyboardeventhandlermaybeassignedthroughcomplex
event delegation, which may not be visible via DOMinspection,
orğ‘£ğ‘˜may handle some key presses (e.g., TabandShift+Tab) that
simply change the browser focus without actually activating the
element.Therefore,todetermineif ğ‘£ğ‘˜isactionableitisnecessaryto
check in the KNFGwhether it has any outgoing edges that modify
theDOMstate (i.e., ğ›¿is set toTrue). The presence of such an edge
indicates that there exists some keyboard action on the element
thatcanbetriggeredanddosomethingotherthantransferfocus
toanotherelement.Notethat WCAGonlyrequiresactionableas
anaccessibilitycriteriawhentheelementcanbetriggeredbythe
mouse. This is accounted for in our approach since ğ‘£ğ‘˜is the corre-
sponding node of a node already in the PCNFG, and, by definition,
a node is only in the PCNFGif it has an associated mouse event
handler.
Onceallnodesin ğ‘‰ğ‘ƒğ¶havebeenanalyzed,thedetectionreturns
True/Falsebased on whether any nodes have been identified as
inaccessible(line9).Thisalgorithmcanbeoptimizedforpage-level
detection by returning Truethe first time any inaccessible element
isidentified(i.e.,at lines6and8).
Algorithm1 InaccessibleFunctionalityDetection
Input: PCNFGâˆ—:Mousenavigationmodel
Input: KNFGâˆ—:Keyboard navigationmodel
Output: TrueorFalse
1:ğ‘‰ğ¼ğ¹â†âˆ…,ğ‘‰ğ‘ğ´â†âˆ…
2:ğ‘‰PCâ†getReachableNodes( ğ‘£ğ‘¢ğ‘ ğ‘’ğ‘Ÿ,PCNFGâˆ—)
3:forğ‘£ğ‘ğ‘âˆˆğ‘‰ğ‘ƒğ¶do
4:ğ‘£ğ‘˜â†correspondingNodeInKNFG (ğ‘£ğ‘ğ‘,KNFGâˆ—)
5:ifÂ¬isReachable (ğ‘£0â†’ğ‘£ğ‘˜,KNFGâˆ—)then
6:ğ‘‰ğ¼ğ¹â†ğ‘‰ğ¼ğ¹âˆª{ğ‘£ğ‘˜}
7:ifÂ¬âˆƒğ‘’âˆˆoutEdges(ğ‘£ğ‘˜)âˆ§e.ğ›¿==Truethen
8:ğ‘‰ğ‘ğ´â†ğ‘‰ğ‘ğ´âˆª{ğ‘£ğ‘˜}
9:return(ğ‘‰ğ¼ğ¹âˆªğ‘‰ğ‘ğ´)â‰ âˆ…
859ESEC/FSE â€™21, August 23Å›28, 2021,Athens,Greece PaulT. Chiou, AliS.Alotaibi,andWilliamG.J. Halfond
In theKNFG* from our running example (Figure 3), the algo-
rithm identifies that in state
1 ,ğ‘£ğ‘‘ğ‘Ÿğ‘œğ‘ğ‘‘ğ‘œğ‘¤ğ‘›2must be accessible via
the keyboard because it is reachable in the PCNFG. However, in
theKNFG, it is unreachable from ğ‘£0via flow edges (red edges),
thus putting this node in ğ‘‰ğ¼ğ¹. Similarly for ğ‘£ğ‘‘ğ‘Ÿğ‘œğ‘ğ‘‘ğ‘œğ‘¤ğ‘›1, the detection
finds it is reachable from ğ‘£0but finds there is no outgoing edge
withğ›¿=True(suchanedgewouldexistifits
 Enteredgecouldhave
exploredstate
4 ). Therefore this node isput into ğ‘‰ğ‘ğ´.
4.2 Localization ofInaccessible Functionalities
When Inaccessible Functionalities occur, it implies that there is
either (a)anedge missingfrom the KNFGthatwouldconnectthe
accessible components to the inaccessible components (i.e., not
reachable)or(b)anelementismissingarequiredkeyboardhandler
(i.e.,not actionable).
Non-reachableIAFs. To localize the missing edges that cause
elementstobecomeunreachable,ourapproachanalyzesthe PCNFG*
andKNFG*andassignsasuspiciousnessscoretovariousedgesthat
couldrepresentthemostlikelyconnectionpoint.Atahigh-level,
the intuition of our approach is to split the localization into two
parts. The first part tries to identify the most likely source node
ofthemissingedgeandthesecondparttriestoidentifythemost
likelytargetnodeofthemissingedge.Ourapproachcomputessus-
piciousnessscoresforeachofthesetwonodesetsandthenpresents
arankingoftheedgesbasedonthecombinedsuspiciousnessofthe
source and target nodes of the edge. The algorithm for computing
suspiciousnessofeachedgeisshowninAlgorithm 2.Theinputs
to this algorithm are PCNFG* andKNFG*, as defined above. The
algorithmiteratesovereachstateâ€™s PCNFGandcheckstoseeifthe
stateofthe PCNFGexistsinthe KNFG*.Sincebothtypesofgraphs
have the same ğ‘‰set and define their states in the same manner,
thischeckonlyneedstodetermineifthe ğ‘‰ğ‘ forthePCNFGexists
inthe KNFG*.
Ifthestate ispresentinthe KNFG*,the approachexaminesthe
state to determine if it contains nodes that are inaccessible (i.e.,
unreachable). Lines5Å›8 compute the set of nodes that are inacces-
sibleforthekeyboarduser( ğ‘‰ğ¾ğ´ğ¹),usingaprocesssimilartothat
defined in Algorithm 1. The approach then iterates over each node
ğ‘£ğ‘˜ğ‘ğ‘“âˆˆğ‘‰ğ¾ğ´ğ¹inordertodeterminethemostlikelysourceandtarget
nodesforthemissingedgethatcaused ğ‘£ğ‘˜ğ‘ğ‘“.Thepossiblesource
nodesarerepresentedas ğ‘‰ğ‘†,whichwasalreadycomputedastheset
ofnodesreachableinthe KNFGfromğ‘£0atline7.Sincethesenodes
are reachable from the entry point, one of them will be the node
that represents the source node of the missing edge. Conversely,
ğ‘‰ğ‘‡represents the set of possible missing edge target nodes. The
approachcomputes ğ‘‰ğ‘‡byfindingallof thenodesthat canreachto
ğ‘£ğ‘˜ğ‘ğ‘“.Onemightassumethatthemissingedgetargetnodewould
always be ğ‘£kaf, however it is possible that ğ‘£ğ‘˜ğ‘ğ‘“may be part of a
largercomponent,whichisalsoinaccessible.Inthisscenario,these
othernodesshouldalsobeconsideredaspossibletargets.Fornodes
inğ‘‰ğ‘‡, line 16 computes their suspiciousness score. The intuition of
thisscoreisthatnodesin ğ‘‰ğ‘‡representasubgraphofthe KNFGand
nodes higher in the topological ordering of this subgraph are most
likelythecorrecttargetnode,sincetheycanthemselvesconnect
tothemostnodesinthesubgraph.Therefore,rankassignsthese
nodes a higher suspiciousness. Specifically, the DOMbased rankofeachofthenodesin ğ‘‰ğ‘‡isusedtoassignsuspiciousness.Asus-
piciousness score is alsocomputed for nodes in ğ‘‰ğ‘†. In lines 13Å›14,
our approach iterates over each of the nodes in ğ‘‰ğ‘†and assigns a
suspicousness score to each. The basic ideaisthatnodes in ğ‘‰ğ‘†are
consideredmorelikelytobethesourcenodeiftheyarespatially
Å‚closeÅ¾ to nodes in ğ‘‰ğ‘‡. We define Å‚closeÅ¾ as the DOMtree based
distancebetweenthetwonodes,whichiscalculatedbythenumber
of edges that must be traversed in the DOMtree for one node to
reach another. This definition of closeness represents the design
practice that keyboard navigation generally transitions between
nodes that have some kind of locality. The approach then takes
the Cartesian product of ğ‘‰ğ‘†andğ‘‰ğ‘‡and assigns the suspiciousness
score of the edge(ğ‘£ğ‘ ,ğ‘£ğ‘¡)based on the sum of the suspiciousness
scores ofğ‘£ğ‘ andğ‘£ğ‘¡. The approach resets the node scores for ğ‘‰ğ‘†and
ğ‘‰ğ‘‡every time it processes a ğ‘£kafso the scores always reflect the
suspiciousnesswith respectto theinaccessiblecomponents. Note
thatthefinalscoresoftheedgesin ğ¸arecumulativeacrossallstates
(lines18Å›19).
In our running example (Figure 3), the localization algorithm
identifiesthatinstate
2 oftheKNFG*,ğ‘£ğ‘‘ğ‘Ÿğ‘œğ‘ğ‘‘ğ‘œğ‘¤ğ‘›2andğ‘£[ğ‘¥]mustbe
accessibleviathekeyboard,butsinceneithernodesarereachable
fromğ‘£0in that state, both are in the set ğ‘‰ğ¾ğ´ğ¹. When identifying
the edges responsible to connect these nodes, the algorithm first
identifies ğ‘‰ğ‘†as the blue cluster reachable from ğ‘£0andğ‘‰ğ‘‡as the
orangeclusterwhere ğ‘£ğ‘‘ğ‘Ÿğ‘œğ‘ğ‘‘ğ‘œğ‘¤ğ‘›2resides.Thealgorithmthen identi-
fies the purple dotted edge as the candidate faulty edge with the
highest suspiciousness score due to their proximity in the DOM.
This concept alsoapplies to ğ‘£[ğ‘¥]inits redcluster.
Algorithm2 InaccessibleFunctionalityLocalization
Input: PCNFGâˆ—:Mousenavigationmodel
Input: KNFGâˆ—:Keyboard navigationmodel
Output: Ranked listofsuspiciousedges
1:ğ¸â†âˆ…
2:foreachPCNFGâˆˆPCNFGâˆ—do
3:ğ¾ğ‘ğ¹ğºğ‘†ğ‘¡ğ‘ğ‘¡ğ‘’â†ğ‘ğ‘œğ‘Ÿğ‘Ÿğ‘’ğ‘ ğ‘ğ‘œğ‘›ğ‘‘ğ‘–ğ‘›ğ‘”ğ‘†ğ‘¡ğ‘ğ‘¡ğ‘’ (ğ‘ƒğ¶ğ‘ğ¹ğº)
4:ifğ¾ğ‘ğ¹ğºğ‘†ğ‘¡ğ‘ğ‘¡ğ‘’âˆˆKNFGâˆ—then âŠ²/*Intra-state*/
5:ğ‘‰ğ‘ƒğ¶â†getReachableNodes( ğ‘£user,PCNFG)
6:ğ‘‰Kâ†correspondingNodesInKNFG( ğ‘‰PC)
7:ğ‘‰Sâ†getReachableNodes( ğ‘£0,KNFG)
8:ğ‘‰KAFâ†ğ‘‰Kâˆ’ğ‘‰S
9: foreachğ‘£kafâˆˆğ‘‰KAFdo
10: ğ‘‰Tâ†backwardReachability( ğ‘£kaf)
11: /*Assignsuspiciousness scoresfor nodesin ğ‘‰S*/
12: forallğ‘£sâˆˆğ‘‰SdoresetScore(ğ‘£s)
13: forallğ‘£tâˆˆğ‘‰Tdo
14: forallğ‘£sâˆˆğ‘‰Sdoscore(ğ‘£s)âˆ’=distance(ğ‘£t,ğ‘£s)
15: /*Assignsuspiciousness scoresfor nodesin ğ‘‰T*/
16: forallğ‘£tâˆˆğ‘‰Tdoscore(ğ‘£t)=âˆ’rank(ğ‘£t,ğ‘‰T)
17: foreach(ğ‘£ğ‘ ,ğ‘£ğ‘¡)âˆˆğ‘‰SÃ—ğ‘‰Tdo
18: score((ğ‘£ğ‘ ,ğ‘£ğ‘¡))â†score(ğ¸.(ğ‘£ğ‘ ,ğ‘£ğ‘¡))+score(ğ‘£ğ‘ )+score(ğ‘£ğ‘¡)
19: ğ¸â†ğ¸âˆªaddEdge((ğ‘£ğ‘ ,ğ‘£ğ‘¡))
20:else âŠ²/*Inter-state*/
21:ğ‘’â†getStateTransitionEdge( PCNFG)
22:ğ¸â†ğ¸âˆªaddEdge(ğ‘’,0)
23:returnedgesinğ¸sorted by score ofeach edge
If the current PCNFGstate does not match a state in the KNFG,
then the identification of the missing edge is simplified (line 4 and
21Å›22). Becauseoftheway our approach constructs the KNFG*,a
newstateinthe KNFG*isonlydefinedifthereexistssomeaction(an
edge)thatduringthecrawlingofthecurrent KNFGstatetransitions
the stateâ€™s ğ‘‰ğ‘ toğ‘‰â€²ğ‘ . Thus, if a state exists in the PCNFG* and not
intheKNFG*,itindicates(1)thereexistssomemissingkeyboard
860DetectingandLocalizing KeyboardAccessibility Failuresin WebApplications ESEC/FSE â€™21, August 23Å›28, 2021,Athens,Greece
navigational transition leading to the ğ‘‰â€²state, and (2) the state
transitionedgeto ğ‘‰â€²stateinthe PCNFGâˆ—istheedgemostlikely
tobefaulty.Line22classifiesthemissingstatetransitionedgewith
thehighestpossiblesuspiciousnessscoreof0.Forexample,inthe
PCNFG* of our running example, state
4 and state
5 are explored
via mouse-hovering Dropdown1 andDropdown2 . The algorithm
identifies the inter-state edge (highlighted in green) that transition
from these nodes to
4 and
5as suspicious edges because these
states are not inthe KNFG*.
Non-actionable IAFs. The localization of elements that are
notactionableisexactlythesetofelementsidentifiedas ğ‘‰ğ‘ğ´inAl-
gorithm1and no further localization is needed for those elements.
4.3 DetectionofKeyboardTraps
TounderstandtheintuitionofourdetectionapproachforKeyboard
Traps, first recall that Keyboard Traps cause keyboard-based users
to become "stuck" in a sequence of one or more nodes. The nav-
igation flows that would cause this to occur will be identifiable
as cycles in the KNFG. This represents a situation where once a
keyboarduser hasentered the cyclewitheither
 Tabor
Shift+
Tab,
theywillbeunabletonavigateawayfromtheelementsinthecycle
using the keyboard.
TheapproachtodetectKeyboardTrapsisshowninAlgorithm 3.
The algorithm begins by iterating over each KNFGin theKNFG*
(Line1).Foreach KNFG,theapproachextractstwoedge-induced
subgraphs, one based on edges labeled with the
 Tabaction and
the other one based on edges labeled with the
 Shift+
Tab. The two
subgraphs are computed by iterating through the edge set ğ¸of
theKNFGand retaining the subset of edges where ğœ™=
Shift+
Tab
or
Tab. These two subgraphs represent the two ways keyboard-
basedusersareabletonavigateamongelementsandthatwouldbe
affected bya cycle. Using the edge induced subgraphs enables the
approach to avoid false-positives that would be caused by cycles
defined by the forward-backward edges created for each node due
to the
Taband
Shift+
Tabnavigation and by edges whose actions
maynotcauseafocusshift,suchas
 ,
,
,
,
Enter,or
Space. The approach then iterates over the two subgraphs (Line
4). The approach first removes the specially created edges that link
the last element in a pageâ€™s tab order and the first element (i.e.,
ğ‘£ğ‘›â†”ğ‘£0) (Line 5). The reason for this removal is that this specially
added edge creates a cycle in the KNFGto enable users to cycle
fromthelastnodeinthetabordertothefirst,butdoesnotrepresent
aKeyboardTrap.Aftertheedgeremoval,ourapproachanalyzes
thesubgraph todetermineifit containsacycle,inwhichcasethe
approach has identifiedthat aKTFexistsinthe KNFG(Line 6).
Algorithm3 KeyboardTrapDetection
Input: KNFGâˆ—:Keyboard navigationmodel
Output: TrueorFalse
1:foreachKNFGâˆˆKNFGâˆ—do
2:KNFGTABâ†getEdgeInducedSubgraph( KNFG)
3:KNFGSHIFTTABâ†getEdgeInducedSubgraph( KNFG)
4:foreachKNFGTABandKNFGSHIFTTAB asğºdo
5:ğº.removeEdges( ğ‘£ğ‘›â†”ğ‘£0)
6: ifğºcontains a cycle then return True
7:returnFalse
In state
3 of theKNFG* from our running example, the four
cycles highlighted in yellow would be detected. Of which, the twocycles of size 1 formed by edge âŸ¨ğ‘£ğ‘¡ğ‘’ğ‘™2,ğ‘£ğ‘¡ğ‘’ğ‘™2,Î£ğ‘€[
Shift+
Tab],ğ‘‰ğ‘ âŸ©and
âŸ¨ğ‘£ğ‘¡ğ‘’ğ‘™3,ğ‘£ğ‘¡ğ‘’ğ‘™3,Î£ğ‘€[
Shift+
Tab],ğ‘‰ğ‘ âŸ©areresultsoftheauto-tabbingmech-
anism. The larger two cycles of size 3 formed by edges âŸ¨ğ‘£ğ‘¡ğ‘’ğ‘™1,ğ‘£ğ‘¡ğ‘’ğ‘™2,
Tab,ğ‘‰ğ‘ âŸ©,âŸ¨ğ‘£ğ‘¡ğ‘’ğ‘™2,ğ‘£ğ‘¡ğ‘’ğ‘™3,
Tab,ğ‘‰ğ‘ âŸ©,âŸ¨ğ‘£ğ‘¡ğ‘’ğ‘™3,ğ‘£ğ‘¡ğ‘’ğ‘™1,
Tab,ğ‘‰ğ‘ âŸ©andâŸ¨ğ‘£ğ‘¡ğ‘’ğ‘™1,ğ‘£ğ‘¡ğ‘’ğ‘™3,
Shift
+
Tab,ğ‘‰ğ‘ âŸ©,âŸ¨ğ‘£ğ‘¡ğ‘’ğ‘™3,ğ‘£ğ‘¡ğ‘’ğ‘™2,
Shift+
Tab,ğ‘‰ğ‘ âŸ©,âŸ¨ğ‘£ğ‘¡ğ‘’ğ‘™2,ğ‘£ğ‘¡ğ‘’ğ‘™1,
Shift+
Tab,ğ‘‰ğ‘ âŸ©are
the result of the mechanism that prevents the user from leaving
the three telephoneboxesunless entrieshave been filled.
4.4 Localization ofKeyboardTraps
When aKTFoccurs it indicates that an edge has been created that
shouldnotbepresentinthenavigation.Thekeyinsightisthata
KTFiscausedbyanedgethatalreadyexistsbutwhosetransition
to the next node in the navigation flow is incorrect. Therefore our
analysistriestoidentifywhichedgeinthe KNFGismostlylikely
to be incorrect. Since there is not a definitive way of identifying
thisedge,weemployasuspiciousnessscorebasedapproachthat
encodes heuristics that we found useful in identifying the likely
faultyedge.
The approach for computing suspiciousness of the edges is
shown in Algorithm 4. Lines 2Å›6 employ the same preparatory
steps used in the detection algorithm (Algorithm 3). Namely, the
approach iterates over each KNFGof thePUT, identifies the two
edge induced subgraphs in the KNFG, and then removes the edges
betweenğ‘£ğ‘›andğ‘£0of each subgraph.Both heuristics employed by
our approach focus on the nodes and edges that are part of a cycle
(i.e.,thedetected KTF).Therefore,thenextstepsofthealgorithm
(lines7Å›9)identifyandextracttheconnectedcomponentsinthe
graph. Our approach does this by using Tarjanâ€™s bridge-finding
algorithm [ 27] to find and remove all bridges (i.e., edges that dis-
connect a component when removed) in ğº(lines 7Å›8). This leaves
onlyconnectedcomponentsin ğº.Sincethissetofcomponentsmay
include components of size one with no self-loops, the approach
removesthesenodes(line9.)Thesenodescanbesafelyremoved
from consideration since, by definition, they cannot be part of a
trap(i.e.,theydonotcontainaselfloopandarenotpartofalarger
cycle.)
The next part of the algorithm (lines 10Å›19) applies our ap-
proachâ€™s localization heuristics. Our approach employs two heuris-
tics for localization. The first heuristic is that edges in a connected
componentaremorelikelytobeafaultyedgethanthosenotinthe
component.Thisheuristic is reasonable sincetypically one ofthe
edgesinthecomponentâ€™scycleshouldactuallybedirectedtoanode
not in the cycle (i.e., breaking the cycle), and the failure to do so is
the cause of the KTF. This heuristic is implemented in lines 11Å›13,
which iterate over the edges in the component and increase the
suspiciousness score of each of them. The second heuristic focuses
on identifying the edge in the cycle that is most likely to represent
the back-edge with respect to the pageâ€™s navigation flow. The key
insight to doing this is that the default tab navigation rendered
bythebrowserisdeterminedbyadepthfirst,pre-ordertraversal
oftheDOMtree[11].Inmostcases,unlessscriptingwasusedto
alterthedefaulttabsequence,the DOMrankdeterminesthekey-
boardnavigationflow.Inlines14Å›17,ourapproachleveragesthis
informationtoidentifythemostsuspiciousedgewithinthecycle.
Specifically,forthe
 Tabinducedsubgraph,thisedgeistheonethat
flows from the lowest (min) DOMranked element to the highest
861ESEC/FSE â€™21, August 23Å›28, 2021,Athens,Greece PaulT. Chiou, AliS.Alotaibi,andWilliamG.J. Halfond
(max)DOMrankedelement(line15).Forthe
 Shift+
Tabinduced
subgraph, since this goes in the reverse direction, it is the edge
that flows from the highest (max) DOMranked node to the lowest
(min)DOMrankednode(line17).Notethatsuchback-edgemay
not exist if the default sequence of tab navigation is violated. In
suchextremelyuncommoncases,theheuristicwouldstillwork,but
not aswell(i.e., itwouldlowerthefaultyelementâ€™s ranking).The
back-edgeidentifiedbythisheuristichasitssuspiciousnessscore
increased(line19).Theseheuristicsareappliedforeach KNFGand
once all of them have been analyzed, the approach returns a list of
all edges ranked inorder oftheirscore, highestto lowest (line 20).
Algorithm4 KeyboardTrapLocalization
Input: KNFGâˆ—:Keyboard navigationmodel
Output: Ranked listofsuspiciousedges
1:ğ¸â†âˆ…
2:foreachKNFGâˆˆKNFGâˆ—do
3:KNFGTABâ†getEdgeInducedSubgraph( KNFG)
4:KNFGSHIFTTABâ†getEdgeInducedSubgraph( KNFG)
5:foreachKNFGTABandKNFGSHIFTTAB asğºdo
6:ğº.removeEdges( ğ‘£ğ‘›â†”ğ‘£0)
7:ğ¸bridgeâ†Tarjan(ğº)
8:ğº.removeEdges( ğ¸bridge)
9: forallğ‘£âˆˆğºwheredegree(ğ‘£)=0doğº.removeNode( ğ‘£)
10: foreachğ‘‰compâˆˆğºdo
11: forğ‘’ğ‘‘ğ‘”ğ‘’âˆˆğ‘‰compdo
12: ğ¸â†ğ¸âˆªedge
13: score(edge)+=1
14: ifğº.instanceOf( KNFGTAB)then
15: ğ‘’backâ†getEdge(min(rank( ğ‘‰comp)), max(rank(ğ‘‰comp)))
16: elseifğº.instanceOf( KNFGSHIFTTAB )then
17: ğ‘’backâ†getEdge(max(rank( ğ‘‰comp)), min(rank(ğ‘‰comp)))
18: ğ¸â†ğ¸âˆªğ‘’back19: score(ğ‘’back)+=1
20:returnedgesinğ¸sorted by score ofeach edge
In state
3 of theKNFG* from our running example, the cycle
formed across ğ‘£ğ‘¡ğ‘’ğ‘™1,ğ‘£ğ‘¡ğ‘’ğ‘™2,andğ‘£ğ‘¡ğ‘’ğ‘™3that prevents the user from
leaving the three telephone boxes consists of three edges in ei-
ther the
 Taband
Shift+
Tabdirection. The order of appearance of
thesethree text fields inthe DOMsequence wouldmake the edge
âŸ¨ğ‘£ğ‘¡ğ‘’ğ‘™3,ğ‘£ğ‘¡ğ‘’ğ‘™1,
Tab,ğ‘‰ğ‘ âŸ©andâŸ¨ğ‘£ğ‘¡ğ‘’ğ‘™1,ğ‘£ğ‘¡ğ‘’ğ‘™3,
Shift+
Tab,ğ‘‰ğ‘ âŸ©astherespective
Å‚back-edgeÅ¾that ismore suspicious.
5 EVALUATION
Toassesstheeffectivenessofourapproach,weconductedanem-
pirical evaluation that focusedonthree researchquestions:
RQ1:Whatistheaccuracyofourtechniqueindetecting KAFsin
webapplications?
RQ2:If aKAFis detected, what is the quality of the localization
results providedbyour technique?
RQ3:Howmuchtimedoesourtechniqueneedtodetectandlocalize
KAFs?
5.1 Implementation
We implemented our approach as a Java-based prototype tool,
KeyboardAccessibility Failure dEtector (KAFE). The implemen-
tationemploysacrawlerforeachsubjectpageâ€™sexplorationand
is fully automated, requiring no manual effort by users. It uses
Selenium WebDriver to load, render, and interact with the subject
web pages to build the KNFGandPCNFG. All web pages wererendered with a fixed screen resolution of 1920 Ã—1080 pixels on
Firefoxversion 68.0 controlledby Selenium version 3.141.5. During
interactionwithasubjectwebpage,weusedtheWebDriverAPI
[35]tosendkeypressestothepageandmonitortheswitchinfocus.
We wrote and executed JavaScript-based code to detect changes to
the subjectpage andcapturethepageâ€™s DOMfor furtheranalysis.
We ranKAFEand all experiments on a single AMD Ryzen Thread-
ripper 2990WX 64-bit machine with 64GB memory and Ubuntu
Linux18.04.4LTS.Theimplementationof KAFEandsubjectswill
be madeavailable to the community viathe projectwebsite [ 31].
5.2 Subject Web Pages / Accessibility Tools
We conducted our evaluation on a set of real-world subject web
pagesgatheredfrom(1)governmentandhighereducationwebsites
that are required bylaw to complywith WCAG [ 2], (2)frequently
visitede-commercewebsites,and(3)sitesfromtheMozTop500
mostvisitedwebsiteslist[ 17].Wechosesubjectsfromthesesources
duetotheirobligationforaccessibilitybytheADA[ 43]andtheir
popularity. The authors manually interacted with each web pageâ€™s
UIand the underlyingfunctional components perkeyboardacces-
sibility testing techniques [ 18] and used 40 of those that contained
atleastone KAF.Overall,oursubjectscontained168IAFsand28
KTFs. For each KAF, we identified the edge(s) that would either
enable access to IAFs orremove cycles causing KTFs,while at the
sametimeremainingconsistentwiththepageâ€™spre-existingnaviga-
tion flow. To help measure the false-positive detection rate in RQ1,
we also included 20 subjects that did not contain any KAFs. The
dynamic UI contents in the subjects comprised of modern HTML5
andcustomJavaScriptwidgets,suchassliders,dropdownmenus,
calendars,andtooltipscomponents.Duetospaceconstraints,wedo
notlisteachofthesubjectsinthepaper,butincludethemassupple-
mentarymaterialintheAppendix.Wecapturedacompleteversion
ofeachsubjectwebpage using an interactive HTTPproxy[ 16].
Forthepurposeofevaluatingourapproachâ€™sperformance,we
comparedagainstasetofstate-of-the-arttoolsfromtwosources:(1)
existing web accessibility testing tools described in research litera-
ture,and(2)the WebAccessibilityEvaluationToolsList [7]provided
bytheW3C.From(1),weselected aria-check [67],tabindex-counter
(the implementation of the Fona approach [ 66]), andQualWeb [47]
becausetheydetectedfailuresthatatleastpartiallyoverlappedwith
KAFs. The other tools we found ( aChecker [49],EvalAccess [36],
Hera-FFX [48],MAUVE[63],Pyccuracy [68]) did not target and
were not capable of detecting issues related to keyboard accessibil-
ity.From(2),weselectedthepopular WAVE[25]toolbecauseithad
the most completehandling of keyboard accessibilityissues of the
listedtools.Othertools onthelistignoredtheimpactof scripting
andstylingthatareresponsibleformostaccessibilityissues[ 41],
which meant they could not outperform WAVE. For all of these
tools,weusedthepubliclyavailableofficialimplementationsvia
theirwebsites.
5.3 ProceduresandPresentation ofResults
To answerRQ1 , we ranKAFEagainst the subject web pages and
measured how accurately it could detect both types of KAFs. In
thisexperiment,wemeasuredtheprecisionandrecallof KAFEâ€™s
detectionresultsandcomparedthisagainsttheaccuracyofexisting
862DetectingandLocalizing KeyboardAccessibility Failuresin WebApplications ESEC/FSE â€™21, August 23Å›28, 2021,Athens,Greece
Table 1:Detection,localization,andtimingresults foreachevaluated approach.
InaccessibleFunctionality Failure Keyboard TrapFailure Run time(Minutes)
Tool DEP(%) DER(%) LOR(%) #MEF #AEF DEP(%) DER(%) LOR(%) #MEF #AEF Average
KAFE 92 100 94 5 8.8 90 100 89 1 4 19.22
aria-check 60 100 n/a n/a n/a 0 0 n/a n/a n/a 0.03
tabindex-counter 93 39 n/a n/a n/a 0 0 n/a n/a n/a 0.03
QualWeb 83 27 6 6.9 12.4 0 0 0 n/a n/a 2
WAVE 68 70 16 8.5 18.5 0 0 0 n/a n/a 0.1
state-of-the-art approaches. For each subject web page, we consid-
eredadetectiontobecorrect(i.e.,atrue-positive)if KAFEindicated
thepagecontaineda KAFofatypeandwehadpreviouslydeter-
minedthatthepagecontaineda KAFofthattype.Wecalculated
false-positives, true-negatives, and false-negatives in an analogous
way.
The four state-of-the-art tools we compared against each had
their own way of reporting detections, so we normalized their
results so they could be compared against KAFE.QualWeb and
WAVEtarget several different types of accessibility related failures,
such as low color contrast and missing alternative texts, therefore
they generate many issue reports unrelated to KAFs. For these
two tools, we considered reports with any mention of keyboard
accessibilityissuesasa KAFdetectionforthecorrespondingweb
page.tabindex-counter scansandreportsaratio(0to1(100%))for
a web page based on the number of interactive elements that have
validtabindex andARIA roleattributes[ 15,33].Weconsidered
anyratiolessthan100%tobeadetectionforthepage. aria-check
usesbehaviour-basedacceptanceteststoevaluateapageâ€™sdynamic
behaviour with respect to accessibility requirements through 23
pre-defined usage scenario test cases. We considered the failure of
anyoftheseteststoconstituteadetection.Forallfourtools,our
mechanism for recognizing a detection was consistent with the
toolâ€™s intended usage and resulted in themostfavorable accuracy
scores for the tool. The result of RQ1 is shown in Table 1. Columns
Å‚DEPÅ¾andÅ‚DERÅ¾showeachtoolâ€™sdetectionprecisionandrecall
for eachtype ofKAFs.
ToanswerRQ2 ,wemeasuredtheabilityof KAFEtoaccurately
identify the faulty element(s) responsible for the KAF. For this RQ,
weonlycompared KAFEagainstQualWeb andWAVEsincetabindex-
counterandaria-check do not provide localization information. To
measurelocalization quality, weusedtheeffortmetricfrequently
usedinthefaultlocalizationcommunities[ 37,53]bycalculating
the expected number of elements a developer, using the output
ofeachtool,wouldhavetoexaminetofindthefault.Thismetric
reflectsanassumptionaboutdevelopersâ€™behaviorandprovidesa
normalization that allows us to quantify and relatively compare
results.
To calculate KAFEâ€™s localization quality for subjects containing
onlyasingle KAF,wedirectlyusedtherankofthefaultyedgein
therankedlistofedgesproducedastheoutputofthelocalization
algorithms. For subjects containing multiple failures, we calculated
therankofeachfaultyedgeusingthemethodologyproposedby
Jones and colleagues [ 53]. This methodology reports the rank of
the first faulty element that appears in the result set, simulates the
fix of that fault, and then reruns the localization analysis to get the
rankingofthenexthighestfault.Theintuitionbehindusingthis
methodologyisthatitapproximatestheworkflowofadeveloperwho scans the results, fixes a fault, and then reruns the analysis to
see if any more faultsremain.
To calculate the localization quality of the results generated
byQualWeb andWAVE,weemployedaslightlydifferentprocess.
This is necessitated by the fact that neither tool ranks the reported
HTMLelements.Therefore,weusedamethodologyproposedby
Alameer and colleagues [ 37]. This technique approximates anaver-
agerankundertheassumptionthatthefaultyelementisuniformly
distributed in an unordered set. For a single fault, the average rank
is, on average, half the size of the unordered set. In the case of
multiplefaults,thisgeneralizestoalinearsearchfor ğ‘˜items(faults)
inanunordered set ofsize ğ‘›where thedistribution ofthe ğ‘˜items
is uniformly random. The equation for calculating this value is
(ğ‘›+1)/(ğ‘˜+1). Lastly, since both tools return a set of HTML el-
ements, as opposed to edges, we considered a localization to be
successfulifthetoolidentifiedanodecorrespondingtoeitherthe
sourceortargetofthefaultyedge.InTable 1,columnÅ‚#LORÅ¾shows
thelocalizationrecallofeachtool,whichistheaveragepercentage
of output sets returned that contained the faulty element in any
rank. Columns Å‚#MEFÅ¾ and Å‚#AEFÅ¾show the median and average
number of elements needed to be examined to find the KAFs for
eachtool.
ToanswerRQ3 ,wemeasuredtherunningtimeofthefivetools
on each subject web page. For KAFE, the running time included
thetimetostartthetool,loadthebrowser,buildthemodels,and
compute detection and localization results (Algorithms 1to4). For
the other four tools, the running time included the time to run the
tool on a subject until the output of the tool was displayed. For
QualWeb, this meant the time to submit a subject link for analysis
until the result page was displayed. For WAVE, it included the
time from the browser extension was clicked until the results were
displayed. For tabindex-counter andaria-check , this included the
timeofloadingthepage,executingthetoolâ€™sunittestcodes,and
displaying the result. The results of RQ3 are shown in Table 1. For
eachtool,the Å‚AverageÅ¾column showsthe averagerunning time.
5.4 Discussion ofResults
FordetectingIAFs,theresultsinTable 1showsthat KAFEwasable
to detect IAFs in the subject applications with high accuracy. In
termsofprecision,only tabindex-counter performedbetter;however
itsrecallwasonly39%.Fromexaminingthisresult,weconcluded
that while using tabindex androleattributes to detectIAFs was
averypreciseapproach,itdidnotdetectallofthedifferentways
KAFscouldoccur.Intermsofrecall,only aria-check matchedthe
recall ofKAFEfor IAFs. In our examination of aria-check â€™s results,
we observed that 42 subjects failed all of its 23 test cases and all
of the subjects failed at least one of the test cases. This included
863ESEC/FSE â€™21, August 23Å›28, 2021,Athens,Greece PaulT. Chiou, AliS.Alotaibi,andWilliamG.J. Halfond
subjectsthatwehadverifiedasfreeofIAFs.Thisresultindicates
thatfailurestoconformtoARIAmarkupstructurearenotsufficient
to indicate the presence of IAFs. Lastly, none of the approaches,
exceptfor KAFEwereabletodetectanyofthe KTFs.Thekeyboard
traps were undetectable by the other tools because they focused
on examining DOMbasedproperties, but KTFs representruntime
behaviorthat isundetectable byexamining the DOM.
In terms ofthe qualityof thelocalization, KAFEperformed sig-
nificantly better than the other two approaches. One of the key
results that show this is the localization recall (LOR). For IAFs,
this metric shows that the HTML elements outputted by QualWeb
containedonly6%ofthefaultsand WAVEcontainedonly15%of
thefaults.Incontrast, KAFEâ€™soutputcontained94%ofthefaults.
Significantly,theresultsofmedianrank(MEF)andaveragerank
(AEF) show that KAFEwas able to consistently highly rank the
faulty elements. In fact, across all subjects, KAFEranked the faulty
edgeinthetopthreefor35%ofthefaults,andintoptenfor76%of
the faults. For KTFs,the localizationqualitywas also high,but it
wasnotpossibletocompareagainstotherapproachessincenone
ofthemcould detect(andtherefore localize)KTFs.
We investigated the results in more detail to understand the
cases in which our approach did not correctly detect or localize.
Fordetection,wefoundourapproachdetectedtwofalse-positive
IAFsandonefalse-positive KTF.FortheIAFs,thedevelopersim-
plementedsectionheadingsusingnon-accessiblelinks.Basedon
ourobservations,thesenon-accessiblelinksweresupposedtobe
accessiblebutinthiscontext,theyofferednointeractivitytothe
web page so we did not consider them to be true failures. Based
onourexperience,usinglinksforsectionheadingsisanunusual
implementationtechnique.Forthe KTF,thefalse-positiveoccurred
onacaptchacomponent.Inthelivewebpage,therewasnotrap.
However, during our experiment, a trap occurred because our web
proxy did not correctly cache this captchacomponent due to secu-
rityprotocols.Forlocalization,ourapproachwasunabletolocalize
five IAFs due to Firefoxâ€™s implementation of the DOMMutation
ObserverWebAPI[ 14]notbeingabletodifferentiatesomespecific
sub-states under mouse hover, which meant that they were not
included in the oracle PCNFG. Our approach was also unable to
localizethree KTFsbecauseinthoseparticularcases,thedeveloper
implemented dropdown boxes that visually overlaid each other.
This caused the Selenium WebDriver to be unable to interact with
thedropdowninwhichtheseadditionaltrapswerelocated.Inturn,
thismeantourapproachcouldnotbuild KNFGedgesoriginating
from thesedropdownboxes.
The runtime of KAFEwas significantly slower than the other
approaches.However,inabsolutetermstheaverageamountoftime
neededby KAFE,abouttwentyminutes,isnotasignificantamount
of time. Furthermore, this higher time cost is offset by its much
higherprecisionandrecallthantheotherapproaches.Weanalyzed
theruntimebreakdownofeachindividualstepin KAFEindetail
andfoundthatover99%ofthetotaltimewasspentonmodeling
and building the graphs. Specifically, the time spent on building
theKNFG* andPCNFG* averaged 9.9 minutes and 9.2 minutes,
respectively.Theaveragetimefor KAFdetectionwas0.8seconds
andforKAFlocalizationitwas3seconds.Theaveragedetection
andlocalizationtimeforIAFswas1.1secondsversus2.7seconds
for KTFs.
div
div
 div1
2 3(a)Groupon page where the Å‚ShowÅ¾ password button ( âŠ) is not
reachable (focusable), and the Facebook and Google log-in buttons
(â‹,âŒ)arereachable(focusable)butnotactionablebythekeyboard.
input
4
(b)Canonproduct registration page where the keyboard focus is
trappedon theproduct model inputbox( â).
Figure 4:Real-world examples ofKAFs
5.4.1 The impactof KAFs.The impactofthe KAFsthatwe found
in our subjects was generally quite severe. For IAFs, often core
functionalitiesofthewebpagewereunavailabletokeyboard-based
users. For example, they would be unable to log in via Google
or Facebookâ€™s external authentication (e.g., Figure 4a), unable to
retrievetheirpassword,unabletochangetheirlanguage/locality
preference, or sometimes unable to use the Å‚LikeÅ¾ Facebook plugin.
The impact for KTFs was even more dramatic. Users would get
stuckwhenenteringdataintowebformswithauto-tabbingscripts,
preventingthemfrommovingbackwardstomakecorrections.This
is particularly troublesome for blind users that must move back-
wardsthroughthefieldstoverifythattheycorrectlyenteredthe
numbers viascreen readers.When stuck,theywouldbe forcedto
refreshthepage,orclosethebrowserandrisklosingalloftheform
information entered.
5.4.2 The rootcausesof KAFs.Weanalyzedthesubjectwebpages
toidentifyrootcausesofIAFsandfoundseveralreoccurringpat-
terns. (1) Custom UI controls based on <div>,<span>, or<li>
where developers would implement mouse event handlers but not
keyboard handlers. We found that 37 out of 455 buttons and 22
out of 58 dropdown-lists across our subject pool were inaccessible
duetotheirinabilitytoreceivekeyboardfocus.Wealsofound34
instances where a <a>was used to trigger JavaScript instead of
having an Å‚hrefÅ¾ attribute. As a result, these elements were not
able to receive keyboard focus [ 34]. We found two instances where
the developer explicitly assigned a tabindex of 0 to make a cus-
tomwidgetfocusablebutyet,withoutdefininganykeyboardevent
handlers, the controls were not actionable. (2) Actions triggered
by mouse hovering. Overall, a remarkably high 35 of 49 menus
implemented to expand when a mouse hovered over them were
inaccessible.Roughly athirdofthosecouldnotreceive focus,and
mostof theothers thatcould receive focus could not expand via a
keyboardaction.Thisproblemalsoappearedwhentooltipswere
864DetectingandLocalizing KeyboardAccessibility Failuresin WebApplications ESEC/FSE â€™21, August 23Å›28, 2021,Athens,Greece
implemented using custom mechanisms. (3) Overriden standard
control elements. We found six cases of checkbox/radio-button
whose operations were delegated to a programmatically associated
<label>[32]. Clicking on the <label>indirectly activates the con-
trol. However, for aesthetics, the developers made these control
hidden and styled its <label>â€™s CSS to make it appear to be a cus-
tom checkbox/radio-button.These inaccessible implementations
assumethatuserswouldbeabletoÅ‚clickÅ¾onthe <label>totick
the associatedcontrol.
For root causes of KTFs, we similarly found several reoccurring
patterns.(1)Auto-advanceduringdataentryinwebforms.Over
half of the of the KTFs we found were due to mistakes in imple-
mentingthisfunctionality.(2)Customizedwidgetsboundtoscripts
that altered the focus or the layout of the UI. Often unintended
side effects of this alteration would lead to the KTF. (3) Text in-
put boxeswith overriden keydown andkeypress events.Typically,
these would be used to auto-complete data entered into search
boxes or to filter the contents of dropdown lists as users entered
text (e.g., Figure 4b). Mistakes in the implementation of these han-
dlers resulted in keyboard users being unable to navigate away
from the inputbox.
5.4.3 Limitations. The primary cause of inaccuracy in our ap-
proach was when Selenium WebDriverwas unable to interact with
some elements that it considers Å‚ NotInteractable Å¾ [30] or when the
DOMwas consideredÅ‚ StaleÅ¾ [4]. Thesesituations occur when ele-
mentsareobstructedbyothers,orwhenthe DOMisspontaneously
altered by AJAX calls that were not triggered via our automated
interaction (e.g.,eventsautomaticallyloadedvia atimer, aslider/-
carousel that constantly loads persistent streams, or asynchronous
calls that implement infinite scrolling to loadand populate data).
We believe that further improvements in web page capture and
replaytechniqueswouldallowforthisbehaviortobemorereliably
controlledfor duringanalysis.
5.5 Threatsto Validity
A potential threat to external validity is that our tool is imple-
mentedusingSeleniumâ€™sFirefoxDriverbuttherecouldbepotential
discrepancies in keyboard navigation behaviors between different
webbrowsersthatcausescross-browserbehavioralinconsistencies.
However, it is important to note that the KAFground-truth would
therefore also vary. These browser-specific KAFs could be easily
detected by systematically running KAFEusing different Selenium
WebDrivers for differentbrowsers.
A potential threat to criterion validity is that both the KAFs
(ground-truth)andfaultswereidentifiedbytheauthors.Interms
of mitigating this threat, it is important to note that the success
criteria in WCAGare, by design, defined in such a way as to make
it possible to objectively determine when a failure has occurred
[1].Inaddition,wefollowedbestpracticesdefinedin[ 10,19,26]
and there was no disagreement between the authors in terms of
what was classified as a IAFs or KTFs. The failures are also defined
intermsofbehaviorsofspecificelementsofa UI,whichmakesit
possible to objectively determine the faulty element that should be
identifiedby KAFE.Asfurthervalidation,weperformedafollow
upinvestigationofthe KAFsweidentifiedinourstudy.Sincewe
began the research project, 12 of the 40 subjects had been repairedby thedevelopers. We reached out via the websiteâ€™s contact forms
totheremaining28toreportourfindings.Fifteenacknowledged
ourreport,andthreeofthemreportedthattheywereaddressing
the KAFs.
6 RELATED WORK
Guideliner[ 55]isatoolthatassesseswebUIelementconformance
to a predefined set of usability guidelines. It focuses on visual
characteristics of web UIs, such as the position of elements on
the screen, the distance between the elements, and the length of
scrolling. VizAssert [ 58,59] uses formal verification methods to
attemptdetectionandrepaironinaccessiblelayoutproperties.Both
approaches focus on accessibility relating to layout properties and
are not capableofinteractingwiththe PUT to expose KAFs.
AxeRay[42] is an automated approach that infers semantic
groupings of elements across various regions of a web page to test
if these elements violate their WAI-ARIA rolesâ€™ semantic structure.
Researchwork[ 69]verifiesARIAspecifications[ 46]ondynamic
content and UI components to detect interactive accessibility is-
sues.AlthoughARIAisusefulinprovidingcustomattributesvia
thebrowserâ€™sAccessibilityAPI,italonedoesnotensurethesein-
teractablecontrolelementsareproperlyscriptedtobeaccessible.
Work done by Watanabe et al. evaluates various dynamic UI el-
ements that can cause ATaccessibility issues. They characterize
complex custom widgets and navigation elements such as drop-
downmenus[ 40],tabwidgets[ 70],menupopups,datepicker,[ 56],
slideshowsandCarouselswidgets[ 44]toensuretheybehaveac-
cording to accessibility standards. Although useful for inspiring
best practices for implementing IAFconformance, these ad-hoc
approachescannotbegeneralizedtohandlekeyboardonamore
diversescale.
Manytechniquesfocusonmobileaccessibilityissuesandtheir
conformance measures based on violations [ 60,61,65,72Å›74], par-
ticularly, [ 39,64,72] developed accessibility checkers to identify
andcategorizetheidentifiedissues.Whilethemajorityofthisre-
searchisrelatedtomobileaccessibilityfailuredetection,research
by Zhang et al. focus on repairing these failures [ 61,73,74] as well
as other deep learning [ 45] and search-based [ 38] repair. Latte [ 62]
isanothertechniquethatautomatically executesusecases using
assistive services to detect accessibility failures. However, these
approachesonly work onAndroid apps, not webapps.
7 CONCLUSION
Poorlydesignedwebapplicationscreatekeyboardaccessibilitybar-
riers that exclude people with disabilities from interacting with its
functionalities. In this paper, we presented a novel approach for
automaticallydetectingandlocalizing KAFsinwebpages.Theeval-
uationshowedthatourapproachcoulddetectandlocalizekeyboard
failures with high precision and recall. We believe these results are
positiveandshowthatourapproachcouldhelpdeveloperstodebug
KAFs inwebapplications.
ACKNOWLEDGMENTS
This work was supported by National Science Foundation under
GrantNo.2009045.
865ESEC/FSE â€™21, August 23Å›28, 2021,Athens,Greece PaulT. Chiou, AliS.Alotaibi,andWilliamG.J. Halfond
REFERENCES
[1]2016. W3C:TechniquesandFailuresforWebContentAccessibilityGuidelines
2.0.https://www.w3.org/TR/WCAG20-TECHS/ . Updated:2016-10-07.
[2]2017. The Section 508 Refresh and What It Means for Higher Edu-
cation.https://er..edu/articles/2017/12/the-section-508-refresh-and-what-it-
means-for-higher-education . Updated:2017-12-04.
[3]2019. The Internet is unavailable. https://nucleusresearch .com/research/single/
the-internet-is-unavailable/
[4]2019. Selenium:StaleElementReferenceException. https://www.selenium.dev/
exceptions/#:~:text =A%20stale%20element . Accessed:2021-02-15.
[5]2019. W3C WAI: Introduction to Web Accessibility. https://www.w3.org/WAI/
fundamentals/accessibility-intro/ . Updated:2019-06-05.
[6]2019. W3CWAI:KeyboardCompatibility. https://www.w3.org/WAI/perspective-
videos/keyboard/ . Updated:2019-01-23.
[7]2019. Web Accessibility Evaluation Tools List. https://www .w3.org/WAI/ER/
tools/. Updated:2016-03.
[8]2020. Beebom: Whatis HTML5and WhyHas itReplaced Flashand Silverlight?
https://beebom .com/what-is-html5/ . Updated:2020-12-24.
[9]2020. COVID-19PushesCommerceOnline,MakingADAWebsiteCompliance
MoreImportantThanEver. https://www .law.com/legaltechnews/2020/05/19/
covid-19-pushes-commerce-online-making-ada-website-compliance-more-
important-than-ever/ . Updated:2020-05-19.
[10]2020. CSUN Universal Design Center: Web Accessibility Criteria - Keyboard
Accessibility. https://www.csun.edu/universal-design-center/web-accessibility-
criteria-keyboard-accessibility . Accessed:2020-07-03.
[11]2020. DOM Living Standard. https://dom.spec.whatwg.org/#concept-tree-order .
Accessed:2020-08-28.
[12]2020. Keyboard Accessible: Understanding Guideline 2.1. https://www.w3.org/
TR/UNDERSTANDING-WCAG20/keyboard-operation .html
[13]2020. MDNWebDocs::hoverCSSpseudo-class. https://developer .mozilla.org/en-
US/docs/Web/CSS/:hover . Accessed:2020-08-16.
[14]2020. MDN Web Docs: MutationObserverInit.childList. https:
//developer.mozilla.org/en-US/docs/Web/API/MutationObserverInit/childList .
Accessed:2020-08-16.
[15]2020. MDN Web Docs: Using ARIA: Roles, states, and properties. https://
developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA _Techniques .
Accessed:2020-08-18.
[16]2020. mitmproxy: a free and open source interactive HTTPS proxy. https:
//mitmproxy.org/. Accessed:2020-08-16.
[17]2020. Mozâ€™s list of the most popular 500 websites on the internet. https://
moz.com/top500 . Accessed:2020-08-25.
[18]2020. U.S. GSA 18F Accessibility Guide: Keyboard access. https://
accessibility.18f.gov/keyboard/ . Accessed:2020-08-25.
[19]2020. UW: Designing for Keyboard Accessibility. https://www.washington.edu/
accessibility/checklist/keyboard/ . Accessed:2020-08-16.
[20]2020. W3C: How People with Disabilities Use the Web. https://www .w3.org/
WAI/people-use-web/ . Accessed:2020-08-27.
[21]2020. W3C: Keyboard Accessible Å› Understanding Guideline 2.1. https:
//www.w3.org/TR/UNDERSTANDING-WCAG20/keyboard-operation .html. Ac-
cessed:2020-08-27.
[22]2020. W3C: UI Events - Mouse Event Types. https://www.w3.org/TR/uievents/
#events-mouse-types . Accessed:2020-08-28.
[23]2020. W3C: User Agent Accessibility Guidelines (UAAG) Overview. https:
//www.w3.org/WAI/standards-guidelines/uaag/ . Accessed:2020-08-27.
[24]2020. W3C: WAI-ARIA Authoring Practices 1.1 - Keyboard Interaction. https:
//www.w3.org/TR/wai-aria-practices-1 .1/#keyboard-interaction . Accessed:
2020-08-28.
[25]2020. WAVE Web Accessibility Evaluation Tool. https://wave.webaim.org/.
Accessed:2020-08-25.
[26]2020. WebAIM: Keyboard Accessibility - Keyboard Testing. https://webaim .org/
techniques/keyboard/#testing . Accessed:2020-07-03.
[27]2020. Wikipedia: Bridge (graph theory). https://en.wikipedia.org/wiki/
Bridge_(graph_theory ). Accessed:2020-08-28.
[28]2020. World Health Organization: World Report on Disability. https://
www.who.int/disabilities/world _report/2011/report/en/ . Accessed: 2020-07-
02.
[29]2021. AUTO TAB HTML INPUT FIELDS. https://bartamediagroup .com/auto-
tab-html-input-fields/ . Updated:2016-08-21.
[30]2021. GitHub Issues: Element Not Interactable Exception in Selenium . https:
//github.com/SeleniumHQ/selenium/issues/4314 .
[31]2021. KAFEProject WebSite. https://sites.google.com/usc.edu/kafe/home . Up-
dated:2021-06-16.
[32]2021. MDN Web Docs: <label> Å› for. https://developer .mozilla.org/en-US/docs/
Web/HTML/Element/label#attr-for . Accessed:2021-06-18.
[33]2021. MDNWebDocs:tabindex. https://developer .mozilla.org/en-US/docs/Web/
HTML/Global_attributes/tabindex . Updated:2021-01-16.
[34]2021. TechniquesforWCAG2.1:Makingactionskeyboardaccessiblebyusing
theonclick eventofanchorsandbuttons. https://www.w3.org/WAI/WCAG21/Techniques/client-side-script/SCR35 .html. Accessed:2021-01-19.
[35]2021. The Selenium Browser Automation Project: WebDriver - Keyboard. https:
//www.selenium.dev/documentation/en/webdriver/keyboard/ . Accessed: 2021-
01-14.
[36]JulioAbascal,MyriamArrue,InmaculadaFajardo,andNestorGaray.2006. An
Expert-Based Usability Evaluation of the EvalAccess Web Service. In HCI related
papers of InteracciÃ³n 2004 , Raquel Navarro-Prieto and JesÃºs LorÃ©s Vidal (Eds.).
SpringerNetherlands,Dordrecht,1Å›17. https://doi.org/10.1007/1-4020-4205-1 _1
[37]A. Alameer, S. Mahajan, and W. G. J. Halfond. 2016. Detecting and Localizing
Internationalization Presentation Failures in Web Applications. In 2016 IEEE
InternationalConferenceonSoftwareTesting,VerificationandValidation(ICST) .
202Å›212.
[38]Ali S. Alotaibi, Paul T. Chiou, and William G. J. Halfond. 2021. Automated
RepairofSize-BasedAccessibilityIssuesinMobileApplications.In Proceedingsof
the36thIEEE/ACMInternationalConference onAutomated SoftwareEngineering
(Virtual Event, Australia) (ASE â€™21). Association for Computing Machinery, New
York, NY, USA.
[39]AbdulazizAlshayban,IftekharAhmed,andSamMalek.2020. AccessibilityIssues
in Android Apps: State of Affairs, Sentiments, and Ways Forward. In Proceedings
oftheACM/IEEE42ndInternationalConferenceonSoftwareEngineering (Seoul,
SouthKorea) (ICSEâ€™20) .AssociationforComputingMachinery,NewYork,NY,
USA,1323Å›1334. https://doi.org/10.1145/3377811 .3380392
[40]Humberto Lidio Antonelli, Rodrigo Augusto Igawa, Renata Pontin De Mattos
Fortes, Eduardo Henrique Rizo, and Willian Massami Watanabe. 2018. Drop-
DownMenuWidgetIdentificationUsingHTMLStructureChangesClassification.
ACM Transactions on Accessible Computing 11, 2 (June 2018), 10:1Å›10:23. https:
//doi.org/10.1145/3178854
[41]HumbertoLidioAntonelli,LeonardoSensiate,WillianMassamiWatanabe,and
RenataPontindeMattosFortes.2019. Challengesofautomaticallyevaluatingrich
internetapplicationsaccessibility.In Proceedingsofthe37thACMInternational
ConferenceontheDesignofCommunication(SIGDOCâ€™19) .AssociationforComput-
ing Machinery, Portland, Oregon, 1Å›6. https://doi.org/10.1145/3328020 .3353950
[42]MohammadBajammalandAliMesbah.2021. SemanticWebAccessibilityTest-
ingviaHierarchicalVisualAnalysis.In 2021IEEE/ACM43rdInternationalCon-
ference on Software Engineering (ICSE) . 1610Å›1621. https://doi.org/10.1109/
ICSE43902.2021.00143
[43]Peter Blanck. [n.d.]. ADA Title III and Web Equality: Litigation Begins. eQuality
([n.d.]), 81Å›104. https://doi.org/10.1017/cbo9781107280151 .009
[44]AlexChen,SimonHarper,DarrenLunn,andAndyBrown.2013. WidgetIdentifi-
cation:AHigh-LevelApproachtoAccessibility. WorldWideWeb 16(012013),
73Å›89.https://doi.org/10.1007/s11280-012-0156-6
[45]Jieshan Chen,Chunyang Chen,Zhenchang Xing, X. Xu,LimingZhu, Guoqiang
Li,andJ.Wang.2020. UnblindYourApps:PredictingNatural-LanguageLabels
for Mobile GUI Componentsby DeepLearning. ArXivabs/2003.00380 (2020).
[46]Joanmarie Diggs, Shane McCarron, Michael Cooper, Richard Schwerdtfeger,
andJamesCraig.[n.d.]. AccessibleRichInternetApplications(WAI-ARIA)1.1.
https://www.w3.org/TR/wai-aria/
[47]NÃ¡diaFernandes,DanielCosta,SergioNeves,CarlosDuarte,andLuÃ­sCarriÃ§o.
2012. Evaluating the accessibility of rich internet applications. In Proceedings
of the International Cross-Disciplinary Conference on Web Accessibility (W4A
â€™12).AssociationforComputingMachinery, Lyon,France,1Å›4. https://doi.org/
10.1145/2207016 .2207019
[48]JosÃ© L. Fuertes, Emmanuelle GutiÃ©rrez, and LoÃ¯c MartÃ­nez. 2011. Developing
Hera-FFXforWCAG2.0.In ProceedingsoftheInternationalCross-Disciplinary
ConferenceonWebAccessibility (Hyderabad,AndhraPradesh,India) (W4Aâ€™11) .
AssociationforComputingMachinery,NewYork,NY,USA,Article3,9pages.
https://doi.org/10.1145/1969289 .1969294
[49]GregGayandCindyQiLi.2010. AChecker:Open,Interactive,Customizable,Web
Accessibility Checking. In Proceedings of the 2010 International Cross Disciplinary
Conferenceon WebAccessibility (W4A) (Raleigh,North Carolina) (W4Aâ€™10) .As-
sociation for Computing Machinery, New York, NY, USA, Article 23, 2 pages.
https://doi.org/10.1145/1805986 .1806019
[50]BeckyGibsonandRichardSchwerdtfeger.2005. DHTMLaccessibility:solving
theJavaScriptaccessibilityproblem.In Proceedings ofthe 7th internationalACM
SIGACCESSconferenceonComputersandaccessibility (Assetsâ€™05) .Associationfor
ComputingMachinery, Baltimore, MD, USA,202Å›203. https://doi.org/10.1145/
1090785.1090830
[51]TeresaD.GilbertsonandColinH.C.Machin.2012. Guidelines,iconsandmar-
ketable skills: an accessibility evaluation of 100 web development company
homepages.In ProceedingsoftheInternationalCross-DisciplinaryConferenceon
WebAccessibility (W4Aâ€™12) .AssociationforComputingMachinery,Lyon,France,
1Å›4.https://doi.org/10.1145/2207016 .2207024
[52]WanAbdulRahimWanMohdIsa,AhmadIqbalHakimSuhaimi,NadhirahAriffrn,
NurulFatimahIshak,andNadilahMohdRalim.2016. Accessibilityevaluation
usingWebContentAccessibilityGuidelines(WCAG)2.0.In 20164thInternational
ConferenceonUserScienceandEngineering(i-USEr) .1Å›4.https://doi.org/10.1109/
IUSER.2016.7857924
866DetectingandLocalizing KeyboardAccessibility Failuresin WebApplications ESEC/FSE â€™21, August 23Å›28, 2021,Athens,Greece
[53]JamesA.Jones,JamesF.Bowring,andMaryJeanHarrold.2007. Debuggingin
Parallel. In Proceedings ofthe2007InternationalSymposium onSoftware Testing
and Analysis (London, United Kingdom) (ISSTA â€™07) . Association for Computing
Machinery,NewYork,NY,USA,16Å›26. https://doi.org/10.1145/1273463 .1273468
[54]Jonathan Lazar. 2019. The potential role of U.S. consumer protection laws in
improvingdigitalaccessibilityforpeoplewithdisabilities. U.Pa.JL&Soc.Change
22(2019), 185.
[55]Jevgeni Marenkov, Tarmo Robal, and Ahto Kalja. 2018. Guideliner: a Tool to
Improve Web UI Development for Better Usability. In Proceedings of the 8th
InternationalConferenceonWebIntelligence,MiningandSemantics (WIMSâ€™18) .
AssociationforComputingMachinery,NoviSad,Serbia,1Å›9. https://doi.org/
10.1145/3227609 .3227667
[56]ValentynMelnyk,Vikas Ashok,ValentynMelnyk, YuryPuzis,Yevgen Borodin,
AndriiSoviak,andI.V.Ramakrishnan.2015.LookMa,noARIA:genericaccessible
interfaces for web widgets. In Proceedings of the 12th Web for All Conference
(W4A â€™15) . Association for Computing Machinery, Florence, Italy, 1Å›4. https:
//doi.org/10.1145/2745555 .2746666
[57]AliMesbah,ArievanDeursen, andStefanLenselink.2012. CrawlingAjax-Based
WebApplicationsThroughDynamicAnalysisofUserInterfaceStateChanges.
ACM Trans. Web 6, 1, Article 3 (March 2012), 30 pages. https://doi.org/10.1145/
2109205.2109208
[58]Pavel Panchekha, Michael D. Ernst, Zachary Tatlock, and Shoaib Kamil. 2019.
Modularverificationofwebpagelayout. ProceedingsoftheACMonProgramming
Languages 3,OOPSLA(Oct.2019),151:1Å›151:26. https://doi.org/10.1145/3360577
[59]Pavel Panchekha, Adam T. Geller, Michael D. Ernst, Zachary Tatlock, and Shoaib
Kamil. 2018. Verifying that web pages have accessible layout. In Proceedings
of the 39th ACM SIGPLAN Conference on Programming Language Design and
Implementation(PLDI2018) .AssociationforComputingMachinery,Philadelphia,
PA, USA,1Å›14. https://doi.org/10.1145/3192366 .3192407
[60]Anne Ross, Xiaoyi Zhang, James Fogarty, and Jacob O. Wobbrock. 2020. An
Epidemiology-Inspired Large-Scale Analysis of Android App Accessibility. ACM
Trans. Access. Comput. 13, 1, Article 4 (April 2020), 36 pages. https://doi.org/
10.1145/3348797
[61]Anne Spencer Ross, Xiaoyi Zhang, James Fogarty, and Jacob O. Wobbrock.
2018. Examining Image-Based Button Labeling for Accessibility in Android
Apps Through Large-Scale Analysis. In Proceedings of the 20th International
ACM SIGACCESS Conference on Computers and Accessibility (Galway, Ireland)
(ASSETS â€™18) . ACM, New York, NY, USA, 119Å›130. https://doi.org/10.1145/
3234695.3236364
[62]NavidSalehnamadi,AbdulazizAlshayban,Jun-WeiLin,IftekharAhmed,Stacy
Branham, and Sam Malek. 2021. Latte: Use-Case and Assistive-Service Driven Au-
tomated Accessibility Testing Framework for Android . Association for Computing
Machinery, NewYork, NY, USA. https://doi.org/10.1145/3411764 .3445455
[63]Antonio Giovanni Schiavone and Fabio PaternÃ². 2015. An extensible envi-
ronment for guideline-based accessibility evaluation of dynamic Web appli-
cations. Universal Access in the Information Society 14 (03 2015), 111Å›132.https://doi.org/10.1007/s10209-014-0399-3
[64]Camila Silva, Marcelo Medeiros Eler, and Gordon Fraser. 2018. A Survey on
the Tool Support forthe AutomaticEvaluation ofMobileAccessibility.In Pro-
ceedingsofthe8thInternationalConferenceonSoftwareDevelopmentandTech-
nologies for Enhancing Accessibility and Fighting Info-exclusion (Thessaloniki,
Greece)(DSAI2018) .ACM,NewYork,NY,USA,286Å›293. https://doi.org/10.1145/
3218585.3218673
[65]C.Vendome,D.Solano,S.LiÃ±Ã¡n,andM.Linares-VÃ¡squez.2019. CanEveryone
use my app? An Empirical Study on Accessibility in Android Apps. In 2019 IEEE
International Conference on Software Maintenance and Evolution (ICSME) . 41Å›52.
[66]WillianMassamiWatanabe,AnaLuizaDias,andRenataPontinDeMattosFortes.
2015. Fona:QuantitativeMetrictoMeasureFocusNavigationonRichInternet
Applications. ACMTransactionsontheWeb 9,4(Sept.2015),20:1Å›20:28. https:
//doi.org/10.1145/2812812
[67] Willian Massami Watanabe, Renata P. Fortes, and AnaLuizaDias.2017. Accep-
tance Tests for Validating ARIA Requirements in Widgets. Univers. Access Inf.
Soc.16,1 (March2017),3Å›27. https://doi.org/10.1007/s10209-015-0437-9
[68]WillianMassamiWatanabe,RenataP.M.Fortes,andAnaLuizaDias.2012. Using
acceptanceteststovalidateaccessibilityrequirementsinRIA.In Proceedingsof
the International Cross-Disciplinary Conference on Web Accessibility (W4A â€™12) .
Association for Computing Machinery, Lyon, France, 1Å›10. https://doi.org/
10.1145/2207016 .2207022
[69]Willian Massami Watanabe, Renata P. M. Fortes, and Ana Luiza Dias. 2017.
AcceptancetestsforvalidatingARIArequirementsinwidgets. UniversalAccessin
theInformationSociety 16,1(March2017),3Å›27. https://doi.org/10.1007/s10209-
015-0437-9
[70]Willian Massami Watanabe, Rafael JosÃ© Geraldo, and Renata Pontin de Mat-
tosFortes.2014.Keyboardnavigationmechanismsintabwidgets:aninvestigation
onARIAâ€™sconformance.In Proceedingsofthe29thAnnualACMSymposiumon
Applied Computing (SACâ€™14) .Associationfor ComputingMachinery,Gyeongju,
Republic of Korea, 721Å›726. https://doi.org/10.1145/2554850 .2554947
[71]B.Wentz,P.T.Jaeger,andJ.C.Bertot.2015. AccessibilityforPersonswithDisabilities
and the Inclusive Futureof Libraries . Emerald Group Publishing Limited. https:
//books.google.com/books?id =tcNOCwAAQBAJ
[72]Shunguo Yan and P. G. Ramachandran. 2019. The Current Status of Accessibility
inMobileApps. ACMTrans.Access.Comput. 12,1,Article3(Feb.2019),31pages.
https://doi.org/10.1145/3300176
[73]Xiaoyi Zhang, Anne Spencer Ross, Anat Caspi, James Fogarty, and Jacob O.
Wobbrock. 2017. Interaction Proxies for Runtime Repair and Enhancement of
Mobile Application Accessibility. In Proceedings of the 2017 CHI Conference on
HumanFactorsinComputingSystems (Denver,Colorado,USA) (CHIâ€™17).ACM,
NewYork, NY, USA,6024Å›6037. https://doi.org/10.1145/3025453 .3025846
[74]Xiaoyi Zhang, Anne Spencer Ross, and James Fogarty. 2018. Robust Annotation
of Mobile Application Interfaces in Methods for Accessibility Repair and En-
hancement. In Proceedings ofthe 31st Annual ACMSymposium on User Interface
SoftwareandTechnology (Berlin,Germany) (UISTâ€™18) .ACM,NewYork,NY,USA,
609Å›621. https://doi.org/10.1145/3242587 .3242616
867