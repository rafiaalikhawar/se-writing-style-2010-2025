Inferring and Applying Def-Use Like Configuration Couplings
in Deployment Descriptors
Chengyuan Wen
wechyu88@vt.edu
Virginia Tech
Blacksburg, VirginiaYaxuan Zhang
yaxuan93@vt.edu
Virginia Tech
Blacksburg, Virginia
Xiao He
hexiao@ustb.edu.cn
University of Science and Technology
Beijing, ChinaNa Meng
nm8247@vt.edu
Virginia Tech
Blacksburg, Virginia
ABSTRACT
When building enterprise applications on Java frameworks (e.g.,
Spring), developers often specify components and configure op-
erations with a special kind of XML files named ‚Äú deployment
descriptors(DD) ‚Äù. Maintaining such XML files is challenging and
time-consuming; because (1) the correct configuration semantics is
domain-specificbutusuallyvaguelydocumented,and(2)existing
compilers and program analysis tools rarely examine XML files.
To help developers ensure the quality of DD, this paper presents a
novelapproach‚ÄîXeditor‚Äîthatextractsconfigurationcouplings
(i.e.,frequentlyco-occurringconfigurations)fromDD,andadopts
the coupling rules to validate new or updated files.
Xeditor has two phases: coupling extraction and bug detec-
tion.Toidentifycouplings,XeditorfirstminesDDinopen-source
projects,andextractsXMLentitypairsthat(i)frequentlycoexist
in the same files and (ii) hold the same data at least once. Xeditor
thenappliescustomizedassociationruleminingtotheextractedpairs. For bug detection, given a new XML file, Xeditor checks
whetherthefileviolatesanycoupling;ifso,Xeditorreportsthe
violation(s). For evaluation, we first created two data sets with the
4,248DDminedfrom1,137GitHubprojects.Accordingtotheex-
perimentswiththesedata sets,Xeditorextractedcouplingswith
highprecision(73%);itdetectedbugswith92%precision,96%recall,
and 94% accuracy. Additionally, we applied Xeditor to the version
history of another 478 GitHub projects. Xeditor identified 25 very
suspiciousXMLupdates,15ofwhichwerelaterfixedbydevelopers.
KEYWORDS
Configuration coupling, deployment descriptor, rule mining
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACMmustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ASE ‚Äô20, September 21‚Äì25, 2020, Virtual Event, Australia
¬© 2020 Association for Computing Machinery.
ACM ISBN 978-1-4503-6768-4/20/09...$15.00
https://doi.org/10.1145/3324884.3416577ACM Reference Format:
Chengyuan Wen, Yaxuan Zhang, Xiao He, and Na Meng. 2020. Inferring
and Applying Def-Use Like Configuration Couplings in Deployment De-
scriptors.In 35thIEEE/ACMInternationalConferenceonAutomatedSoftware
Engineering (ASE ‚Äô20), September 21‚Äì25, 2020, Virtual Event, Australia. ACM,
New York, NY, USA, 12 pages. https://doi.org/10.1145/3324884.3416577
1 INTRODUCTION
When building enterprise applications on top of software frame-
works(e.g.,JavaEEplatforms),developersusuallycreatedeploy-
ment descriptors (e.g., web.xml)‚Äîa special kind of XML files‚Äîto
configuredeploymentoptions[ 11].ErroneousDDcantriggerab-
normalruntimebehaviors[ 44]orconfusingerrors[ 13].Debugging
suchXMLfilescanbechallengingandtime-consumingforthree
reasons. First, frameworks have domain-specific rules to define
orspecify deploymentoptionsasXMLentities(i.e.,elements
andattributes) , and developers have application-specific ways to
configureDDfordistinctneeds.Unfortunately,thedomain-specific
rulesandapplication-specificconfigurationsareusuallyvaguely
documented [ 14]. Second, it is tedious and error-prone for devel-
operstomemorizeallDD-related rules.Third,existingcompilers
andtoolsexaminesourcecodeinsteadofXMLfiles.Eventhough
XMLfilevalidatorscanbebuilttovalidatesyntaxbasedonXML
Schemas or DTDs, the validators do not examine DD semantics.
Existing research provides quite limited support for checking
or transforming XML files [ 20,22,30]. For instance, XQuery is a
domain-specific language for finding elements and attributes in
XML documents [ 22]. To find particular XML errors, developers
havetolearnXQuery,andthenuseXQuerytomanuallydescribethepatternmatchingmechanism.ThelearningcurveofXQuerymaybelongtosomedevelopers,whilethepatterndefinitionprocedurecan
be also tedious and error-prone. We believe that with an automatic
approachto(1)inferrulesfromcorrectXMLconfigurationfilesand(2)applythoserulesinordertolocateerroneousXMLfiles,wecanprovidequalityassuranceforXMLfileswithoutrequiringmuchhumaneffort.
ThispaperpresentsXeditor,ournovelapproachtoinferand
apply XML rules based on open-source projects. Because different
frameworksdefinediverseformatsofXMLfilesandtheDDseman-
tics vary a lot, it is almost infeasible to infer arbitrarily complex
XMLrulesinadomain-agnosticway.Toensurethegeneralizability
of our approach, we designed Xeditor to mainly focus on one
type of rules that commonly exist in distinct frameworks: def-use
6722020 35th IEEE/ACM International Conference on Automated Software Engineering (ASE)
<beans xmlns=http://www.springframework.org/schema/beans
xmlns:xsi =http://www.w3.org/2001/XMLSchema-instance  ‚Ä¶>
 <bean id="OutputHelper ‚Äù class="com.mkyong.output.OutputHelper "> 
  <property name="outputGenerator "> 
   <ref local="CsvOutputGenerator "/> 
  </property > 
 </bean> 
 <bean id="CsvOutputGenerator ‚Äù 
class="com.mkyong.output.impl.CsvOutputGenerator "/> 
 ‚Ä¶
</beans>
Figure 1: An exemplar deployment descriptor
<bean id="validator ‚Äù
class="org.springframework...FactoryBean ">
<property name="validationMessageSource ‚Äù 
ref =‚ÄúmessageSource ‚Äù/>
</bean>
+ <!--
<bean id=‚ÄúmessageSource‚Äù class=...>
‚Ä¶
</bean>
+ -->
Figure2:Theincorrectlymaintained dispatcher-servlet.xml file
in project addressbook-sample-jpa that violates ref‚Üíid[12]
like couplings ‚Äú A‚ÜíB‚Äù between XML entities . Here, ‚ÄúA‚ÜíB‚Äù
means‚Äúifentity Areferstoanidentifierorastringliteral,thenthere
must be another entity Bthat defines meaning for that identifier.‚Äù
Forinstance,inSpring[ 5],abeanisanobjectthatisinstantiated,
assembled, and managed by a Spring container. In DD, a reference
to a bean identifier is always coupled with the identifier definition,
oranybeanreferenceisvalidonlywhenthereisadefinitionforthe
bean. Figure 1 presents an example to demonstrate this constraint.
Inthisfigure,entity refisareferenceto CsvOutputGenerator ,which
is coupled with the bean iddeclaration of CsvOutputGenerator , i.e.,
ref‚Üíid.OurresearchintendstorevealDDsemanticrulessimilar
to such def-use couplings. Notice that although ref‚Üíidis easy
to understand, based on our experience, many def-use like rules
are not so obvious (see Listing 1). More importantly, developerssometimes violated such rules when maintaining DD. Figure 2
showsan incorrectlyupdated deploymentdescriptorin theopen-
sourceproject address-sample-jpa [12],wheredeveloperscommented
the bean iddeclaration of messageSource but kept a refto that bean.
We believe that "if two entities frequently coexist in the same file
and often hold the same data, they are correlated ". With this insight,
wedesignedXeditortohavetwophases,asillustratedbyFigure3.
GivenDDoranXMLcorpusfromopen-sourceprojects,PhaseIex-tractscandidatepairsofXMLentitiesthat(i)frequentlyco-occurin
XMLfiles,and(ii)holdthesamedataorstringliteralsatleastonce.
For each candidate pair, Xeditor identifies the longest common
XMLpath Csharedby bothentities ontheXML parsingtree, and
thencontextualizes therepresentationof bothentitiesbased on C.
For every candidate (A,B), Xeditor tentatively extracts couplings
by applying our customized association rule mining technique. In
particular, Xeditor identifies all occurrences of each entity in the
XML corpus,together with thecorresponding stringliterals. If (1)
theoccurrenceofoneentity(e.g., A)isusuallycoupledwiththatof
the other entity (e.g., B), and (2) both entities usually hold identical
string literals, then Xeditor infers a rule (e.g., A‚ÜíB).
Phase II takes in an XML file fthat developers newly created
or updated from an existing file, Xeditor tentatively matches f"
""#
%" "#
"!
	
$

	#&!
# "$"
#!"
!



	&
# 
 "!
Figure 3: Xeditor consists of two phases: Phase I extractsconfiguration couplings from open-source projects, andPhase II uses the couplings to check for bugs in DD
against all extracted couplings. If there is a coupling rule for which
the file contains AwithoutB, Xeditor recommends developers to
(1)insert Bordelete Aand(2)ensurebothentitiesholdthesame
string literal. In the Continuous Integration (CI) practices [ 24], we
envision Xeditor to be used for correctness checking before a
submittedcommitisintegratedintothesoftwareproduct.Inthis
way, Xeditor helps developers correctly edit DD and complement
existing code-oriented program analysis techniques.
Forevaluation,wefirstappliedXeditortothe4,248DDfrom
1,137 projects, and manually inspected the extracted couplings.
Withthedefaultparametersetting,Xeditoridentified30couplings,
among which 22 couplings are true positives. It means that our
approach can extract rules with high precision (73%). Furthermore,
based on our manual inspection results, we built a ground truthdata set of coupling occurrences in the 4,248 DD. We randomly
split the XML corpus into 10 portions and conducted 10-fold cross
validation to evaluate Xeditor‚Äôs effectiveness of bug detection. In
each fold, we used nine portions of data for coupling extraction;
weconstructedtestcasesbyremovingsomeXMLentitiesfromthe
remainingoneportionofdata,andappliedXeditortothosetest
cases. Our evaluation shows that on average, Xeditor detected
bugs with 92% precision, 96% recall, and 94% accuracy.
Additionally, we applied Xeditor to the program commits in
another 478 open-source projects. Xeditor revealed 25 incorrectly
updatedDD,15ofwhichwerelaterfixedbydevelopers.Thisimplies
that Xeditor can help developers avoid introducing bugs whenthey modify DD. Finally, we compared Xeditor with a baselineapproach that extracts couplings from co-changed entities, andapplies both approaches to the same data sets. Our comparison
showsthatXeditordetectedmoreruleviolationsthanthebaseline;
Xeditorobtainedlowerprecision(92%vs.98%),muchhigherrecall
(96% vs. 78%), and higher accuracy (94% vs. 87%).
In summary, this paper makes the following contributions:
‚Ä¢Wedevelopedanovelapproach‚ÄîXeditor‚Äîtoautomatically
extract configuration couplings in DD and detect relatedbugs. Different from most prior work, Xeditor does not
needuserstomanuallyprescribeanyruleormatchinglogic.
‚Ä¢We built Xeditor to extract couplings from the coexistence
ofXMLentities.Comparedwithabaselinetechniquethatex-
tracts couplings from co-changed entities, Xeditor worked
better by detecting rule violations with higher accuracy.
‚Ä¢WeconductedacomprehensiveevaluationonXeditor.Our
evaluation shows that (1) Xeditor could identify important
couplingsbecausedevelopersdidmakemistakesbyignoring
673such delicate constraints, and (2) Xeditor suggested useful
corrective changes for buggy XML files.
Athttps://figshare.com/s/d4dc1f8ab527c1ce68ef, weopen-sourced
our program and data.
2 BACKGROUND
This section first introduces DD (Section 2.1) and XML syntax
(Section2.2).ItthenexplainswhyitischallengingtoconfigureDD
appropriately (Section 2.3).
2.1 Deployment Descriptors (DD)
Adeploymentdescriptorisaconfigurationfilethatspecifieshow
anartifactshouldbedeployed.Forinstance,inawebapplication
AppwritteninJava,thedeploymentdescriptor(e.g., web.xml)de-
scribes component classes, resources, and configurations of App;
italsospecifieshowaserverusesthesecomponentstoserveweb
requests [ 7]. Similarly, in a Java EE application, the deployment de-
scriptor(e.g., application.xml)clarifiestheconfigurations,container
options,andsecuritysettings[ 8].XMLisusedforthesyntaxof
DD. Depending on the types of applications and modules, DD may
be located in various file folders and named differently.
Listing 1: A simplified version of a web.xmlfile [2]
1 <?xml version="1.0" e ncoding="UTF‚àí8"?>
2< w e b‚àíapp version="2.5" xmlns="http://java.sun.com/..."
3 xmlns: xsi="http ://www.w3. org/2001/XMLSchema ‚àíinstance"
4 xsi:schemaLocation="http :// java.sun.com/xml/ns/..." >
5 ...
6 <security ‚àíconstraint>
7 ...
8 <auth‚àíconstraint>
9 <role ‚àíname>comm</role‚àíname>
10 </auth ‚àíconstraint>
11 </security ‚àíconstraint>
1 2 ...
13 <security ‚àírole>
14 <role‚àíname>comm</role‚àíname>
15 </security ‚àírole>
16 </web‚àíapp>
2.2 XML Syntax
XMLsyntaxdefineshowanXMLfilecanbewritten[ 10].Accord-
ingtothesyntaxrules,eachXMLfileincludesoneormore XML
elements ,whichareorganizedinatreestructure.Namely,thereis
only one root element in any XML file, and the root element has
one or more child elements . For the exemplar XML file shown in
Listing1,the <web-app>elementisroot;oneofitschildelementis
<security-constraint> .
Generally speaking, an XML document consists of markups
anddata.Markupsareprovidedintheformof tagsandattributes .
Dataisthetextthatgoesinbetweentagsorisprovidedasvalues
forattributes.XMLelementsarerepresentedbytags.Anelement
usually consists of an opening tag (e.g., ‚Äú <role-name> ‚Äù), a closing
tag (e.g., ‚Äú </role-name> ‚Äù), and data between the tags (e.g., ‚Äú comm‚Äù)
Attributes can be added to XML elements; they are represented
asname-value pairs (e.g.,‚Äúversion="2.5" ‚Äù).Thispaperuses XML
entitiesto refer to both XML elements and attributes.
2.3 Problem Statement
In DD, there are various rules that developers have to follow in order
to realize their deployment requirements. For instance, as shown
in Listing 1, a security constraint ( security-constraint )i su s e dt odefinetheaccessprivilegestoacollectionofresources;anautho-
rization constraint ( auth-constraint ) authorizes certain role(s)with
the defined access privileges, and has one or more role-name ele-
mentstolisttheauthorizedroles[ 17].Meanwhile,asecurityrole
(security-role ) defines an abstract name that can be assigned to
usersandgroups[ 9].Arelevantruleisthat eachrolenamelisted
inauth-constraint (e.g., comm) must correspond to the role name
definedinoneofthe security-role elements(e.g., comm). However,
inthebig andlengthyJavaEETutorial(with980pages),thereis
only one small paragraph together with a single code example [ 17]
vaguely implying the above-mentioned rule:
‚ÄúThefollowingsnippetofadeploymentdescriptordeclarestheroles
that will be used in an application using the security-role element
and specifies which of these roles is authorized to access protected
resources using the auth-constraint element: ...‚Äù
It is very tedious and error-prone for developers to identify,
remember,andfollowalldomain-specificruleswhentheymaintain
DD. According to a recent study on StackOverflow [ 36], many
developers asked various questions on how to correctly configure
DDandexpressedfrustrationswithXMLdebugging.Unfortunately,
there is limited tool support for bug detection or fix in DD. Two
reasons may explain such technique insufficiency:
(1)Domain-specific rules are usually vaguely described or even
poorly documented, so it can be time-consuming for toolbuilders to extract rules from software library/framework
documentation and then code those rules into their tools.
(2)DifferentsoftwaredefinesdivergentDDrules,soitcanbe
challengingfortoolbuilderstofrequentlyintegratetherules
related to newly released software into their tools.
TobuildatoolthatcanhelpdevelopersdebugDD,weneedtosolve
the two technical challenges mentioned above.
3 APPROACH
Inthissection,weexplainourautomaticapproach‚ÄîXeditor‚Äîthat
detectsbugsinXMLfilesandprovidescorrectivesuggestions.To
overcome the two technical challenges mentioned in Section 2.3,
we designed Xeditor to infer def-use like configuration couplings
from open-source DD, and to adopt the inferred couplings for bug
detection. As shown in Figure 3, Xeditor has two phases. This
sectionfirstsummarizesthestepsineachphaseandthendescribes
each step in detail (Section 3.1-Section 3.3).
Phase I: Rule Inference
‚Ä¢Givenasetofopen-sourceprojects,Xeditorlocatesasetof
DD:F={f1,f2,...,fm}, from which files Xeditor extracts
candidateXMLentitypairs C={c1,c2,...,cn},whereci=
(ei1,ei2)withei1andei2being coexisting entities.
‚Ä¢For each candidate ci, Xeditor searches among all files Fto
findtheoccurrenceofeitherentity(i.e., ei1andei2);itfurther
applies our customized association rule mining to infer any
def-uselikecouplingsbetweenentities.Eachminedrulehas
the format ‚Äú A‚ÜíB‚Äù and is saved into a database D.
Phase II: Rule Application
‚Ä¢GivenanewXMLfile f,foreachrule r‚ààD,Xeditorchecks
whetherAandBcoexistinthefile.Xeditorreportsabugif
(1)Aexistsbut Bdoesnot,or(2) Areferstoastringliteral
which is not held by any B.
674Byinferringdef-uselikerulesfromopen-sourceDDinadomain-
agnostic way, we avoid the manual effort of (1) extracting such
rules from software documentation and (2) hardcoding the rules in
Xeditor.Byimplementingthefirstphasetostorerulesto Dand
thesecondphasetoloadrulesfrom D,weensurethatXeditorcan
beeasilyextendedtocovernewrulesintroducedbynewlyreleased
software frameworks or libraries.
3.1 Candidate Identification
Given a set of open-source projects, we need to first locate DD.
Although the DD of different Java projects are all XML files, not all
XMLfilesareDD.ToefficientlylocateDDamongtheavailableXML
files, we adopted a heuristic to focus on files whose paths have any
of the following keywords: ‚ÄúWEB-INF‚Äù, ‚Äúspring‚Äù, ‚Äúsecurity‚Äù, and
‚Äúweb‚Äù.Wedefinedthisheuristicbecausebasedonourexperience,
DD usually exist in specific folders or have specialized names.
ForeachlocatedXMLfile,weappliedAntlr[ 15,16]togeneratea
parsingtree,wherenodesrepresentXMLentitiesordataandedges
represent the parent-child containment relationship. To identify
candidate pairs in the tree representation, a na√Øve approach can
‚Ä¢identify all XML entities E={e1,e2,...,en}, and
‚Ä¢create a pair for any two coexisting entities (i.e., (ei,ej),
wherei,j‚àà[1,n] andi/nequalj).
However,sincemanyirrelevantentitiesmaycoexistinthesame
file for distinct requirements, their coexistence is meaningless.
Therefore,manyofthecandidatepairsconstructedbytheabove-
mentioned na√Øve approach are actually useless for rule inference.
To overcome the challenge of noisy entity pairs and to iden-
tify promising candidates, we used a heuristic that ‚Äúif two XMLentities hold the same string value at least once, they are likely tobe correlated ‚Äù. As shown in Listing 1, the
<role-name> element un-
der<security-constraint> holds the data ‚Äú comm‚Äù (line 9), while the
<role-name> elementunder <security-role> containsthesamestring
literal(line14).Therefore,Xeditorgeneratesacandidatepairbased
on the two elements.
Before generalizing rules from the concrete candidate pairs, we
needtosolveanotherchallenge: howcanwerepresentcandidates
inanunambiguousway? InListing1,thetwoelementsreferring
to ‚Äúcomm‚Äù have the same tag <role-name> . If we simply use these tags
todefineacandidatepair (<role-name>, <role-name>) ,thesemantics
isveryconfusingandwecannottelltheelementsapart.Tosolve
this problem, we decided to include the context, i.e., the parent
and even ancestors of both entities, into our representation fordisambiguation.Supposethatanentity
Ahasitsparententityas
P, whilePis contained by the root element R. Then our context-
awarerepresentation for Ais:R_P_A, which corresponds to the
XML path from root to A. For the candidate pair mentioned above,
our context-aware representation is:
(web-app_security-constraint_auth-constraint_role-name,
web-app_security-role_role-name) .
When a rule-to-infer rhas multiple occurrences, it can corre-
spond to multiple candidates with distinct XML paths, such as
cp=(beans_bean_id ,beans_bean_property_ref )andcq=(beans_beans_bean_id ,
beans_beans_bean_property_ref ) shown in Figure 4. If we do not ap-
propriatelyprocessthepathdivergencesbetweencandidates,we
may fail to infer true rules or always infer duplicated rules. Es-
sentially, we need an abstractcontext-awarerepresentation of



	





	



 
Figure 4: XML trees to visualize the spatial relationship be-tween entities in c
pandcq
candidatesthatis(1)sensitivetothepathdivergencesbetweenenti-tiesinsideeachcandidate,but(2)insensitivetothepathdivergences
among candidates showing the same rule.
To create the abstract representation, for each candidate ci=
(ei1,ei2), Xeditor identifies the lowest common XML ancestor,
and converts the paths of both entities based on that ancestor. For
instance, the entities in cpof Figure 4 have the lowest common
ancestor as beans, so the abstract representation is (*_beans_bean_id,
*_beans_bean_property_ref) . Here ‚Äúwildcard (‚àó) ‚Äù represents the com-
mon XML path prefix of beansshared by both entities. Similarly, cq
is converted to (*_beans_bean_id, *_beans_bean_property_ref) . There-
fore, the above-mentioned candidate pair from Listing 1 can be
abstracted as:
(*_web-app_security_security-constraint_auth-constraint_role-name,
*_web-app_security_security-role_role-name) .
Byrepresentingcandidatepairsinanabstractandcontext-aware
way, we can (1) differentiate between same-tag entities, (2) cluster
candidates showing the same rule, and (3) simplify rule extraction
and application (Section 3.2-Section 3.3).
3.2 Rule Extraction
Afterextractingasetofcandidatepairs(i.e., C={c1,c2,...,cm})
fromcorpus F,Xeditorinfersruleswithourcustomizedassocia-
tion rule mining technique. This technique first adopts traditional
association rule mining [ 51] to infer the occurrence coupling be-
tweenXMLentities;itthenappliestwofilterstoremovecooccur-
ring entity pairs that are less likely to have def-use relations.
Associationrulemining(ARM) [51]isaclassicalwaytofind
patterns in data and detect couplings between data entities. An
assocationrule betweentwoentities e1ande2canhavetheformat
‚Äúe1‚áíe2‚Äùo r‚Äúe2‚áíe1‚Äù. In the notation ‚Äú e1‚áíe2‚Äù,e1is called the
antecedent,and e2iscalledthe consequent.Thenotationmeansthat
the occurrence of e1implies that of e2. With such rules, we can
predicttheoccurrenceof e2whene1occurs.ARMminesassociation
rules in a probabilistic way. Intuitively, ARM infers the rule ‚Äú e1‚áí
e2‚Äù if the two entities cooccur for a sufficient number of times and
whenever e1occurs,e2usuallyoccurs.Formally,supposethatthe
numbers of occurrences of e1ande2are separately freq (e1)and
freq (e2). We represent the number of cooccurrences between the
entities as freq (e1,e2). The rule ‚Äú e1‚áíe2‚Äù is derived if
(1)freq (e1,e2)‚â•supp, wheresuppis the threshold for the
number of cooccurrences, and
(2)Pr(e2|e1)=freq (e1,e2)
freq (e1)‚â•conf,whereconfisthethresh-
old for the probability.
In our research, for each candidate ci=(ei1,ei2), Xeditor iden-
tifies the occurrences of ei1andei2in all files; it then computes
675freq (ei1,ei2),Pr(ei2|ei1), andPr(ei1|ei2)accordingly to reveal ex-
istence couplings between entities.
Two Filters. In certain projects, some irrelevant entities acci-
dentally coexist a lot. To avoid inferring noisy def-use like rules
from such accidental coexistence, we decided to build two filters
that refine the above-mentioned existence couplings.
(F1)pfreq (e1,e2)‚â•pth, wherepthis the minimum number of
projects that support the cooccurrences between e1ande2.
We designedthis filter because certainaccidental coexistence was
introduced by the coding habitsof some programmers. However, it
isveryunlikelythatsuchaccidentalcoexistencepopularlyexistsin
many projects. This filter removes any rule that is only supported
by a small number of projects.
(F2)Pr(same_strin–¥ )=freq (strin–¥ (ei1)=strin–¥ (ei2))
freq (ei1,ei2)‚â•vth,
wherevthistheminimumrateofsame-stringcooccurrences.
We designed this filter because in some DD, developers unneces-
sarily set irrelevant XML entities to hold identical values such that
theydonothavetocarefullyexaminethecorrespondencebetweenentities.However,moredevelopersstillusedistinctandmeaningful
stringvaluestotellapartirrelevantentities.Therefore,thisfilter
removesanyrulewherethetwoentitiesdonotfrequentlyholdthe
same string literal.
By default, Xeditor extracts a def-use like rule ‚Äú ei1‚Üíei2‚Äùi f
supp=10,conf=0.9,vth=0.95, andpth=9. We used these
thresholdvaluesbecauseourevaluationshowsthatXeditorworks
most effectively with this setting (Section 4.3).
At the end of this step, Xeditor obtains a set of def-use con-
figuration couplings and saves them into its database D. For the
exampleshowninListing1,fromthisexemplarfiletogetherwith
several other files containing relevant entity pairs, Xeditor can
infer the following rule:
*_web-app_security-constraint_auth-constraint_role-name ‚Üí
*_web-app_security-role_role-name . (Rule 1)
3.3 Rule-Based Checking
Given a new XML file f, Xeditor enumerates the inferred rules to
detect bugs in the file and suggests changes when possible. Specif-
ically, Xeditor adopts Antlr to create a parsing tree for fand
extracts all entities from the tree. For each rule r=A‚ÜíBin
the database, Xeditor searches entity matches for AandBsepa-
rately.Forsimplicity,werepresentthetwosetsoffoundmatches
withEA={eA1,eA2,...,eAh}andEB={eB1,eB2,...,eBl}. Next,
Xeditorpairsup entitiesbetween EAandEBbased on(1)abstract
context-awarerepresentationsofentitiesand(2)thecommonstring
literalstheyshare.If eAi (i‚àà[1,h])cannotbepairedupwithany
entity inEB, Xeditor reports a bug and suggests possible fixes.
For instance, by applying the above-mentioned inferred rule
(Rule1)totheXMLfileinListing2,Xeditorcanfindtwomatches
fortheantecedent <role-name> elementunder <security-constraint> ,
but find no match for the consequent <role-name> element. In this
scenario,Xeditorreportstwobugsandsuggeststhecorresponding
fixes as below:
‚ÄúInsert a <role-name> entity with value ‚Äòprof‚Äô under <web-app>
<security-role>; or delete the <role-name> entity with value ‚Äòprof‚Äô
under <security-constraint> <auth-constraint>.‚Äù‚ÄúInsert a <role-name> entity with value ‚Äòstu‚Äô under <web-app>
<security-role>;ordeletethe<role-name>entitywithvalue‚Äòstu‚Äôunder
<security-constraint> <auth-constraint>.‚Äù
Listing 2: A simplified version of another web.xmlfile [1]
1 <?xml version="1.0" e ncoding="UTF‚àí8"?>
2< w e b‚àíapp version="2.5" xmlns="http://java.sun.com/..."
3 xmlns: xsi="http ://www.w3. org/2001/XMLSchema ‚àíinstance"
4 xsi:schemaLocation="http :// java.sun.com/xml/ns/..." >
5 ...
6 <security ‚àíconstraint>
7 ...
8 <auth‚àíconstraint>
9 <role ‚àíname>prof</role‚àíname>
10 </auth ‚àíconstraint>
11 </security ‚àíconstraint>
1 2 ...
13 <security ‚àíconstraint>
1 4 ...
15 <auth‚àíconstraint>
16 <role‚àíname>stu</role‚àíname>
17 </auth ‚àíconstraint>
18 </security ‚àíconstraint>
19 </web‚àíapp>
4 EVALUATION
This section first introduces our data sets (Section 4.1) and eval-
uation metrics (Section 4.2). Next, it presents our evaluation on
Xeditor‚Äôs effectiveness of rule inference (Section 4.3) and rule
application (Section 4.4). Finally, it expounds on the comparison
between Xeditor and a baseline technique (Section 4.5).
4.1 Data Sets
We constructed two major data sets for evaluation. Specifically, we
minedJavaopen-sourceprojectsonGitHub[ 3]usingtheheuristics
describedinSection3.1.Wecrawledthewebsiteforanyprojectthat
containsatleastoneXMLfile,whosefilepathhasanyofthefol-
lowingkeywords:‚ÄúWEB-INF‚Äù,‚Äúspring‚Äù,‚Äúsecurity‚Äù,and‚Äúweb‚Äù.Afterremovingredundantprojects,werandomlyputthecrawledprojects
intotwodatasets.Thefirstset( D1)contains70%ofprojects(i.e.,
1,137), while the second set ( D2) contains 30% of projects (i.e., 478).
ForD1,Xeditoridentified4,248DDinthelatestversionof1,137
projects. We used these DD to explore three research questions:
RQ1:How effectively does Xeditor infer rules?
RQ2:How effectively does Xeditor apply rules to locate bugs?
RQ3:How well does Xeditor compare with a baseline approach,
which detects XML bugs based on co-changed instead of
coexisting entities?
AfterinferringrulesfromD1,weusedXeditortoapplyrulesto
individual program versions in D2. We investigated two questions:
RQ4:DiddevelopersintroduceanyoftheXMLbugsthatXeditor
can detect during XML file maintenance?
RQ5:How well do Xeditor‚Äôs change suggestions match develop-
ers‚Äô actual fixes for those detected XML bugs?
OurexperimentswithD1intendtoassesstheusabilityof Xeditor,
whileourexperimentswithD2intendtomimictherealapplication
scenariosof Xeditorandassessthetool‚Äôsusefulnesstodevelop-
ers.NoticethatXeditorisactuallyapplicabletoarbitraryDDto
examine for any rule violation, no matter whether the files have
beennewlycreated,recentlyupdated,orunchangedforalongtime.
676InourexperimentswithD2,weintentionallyappliedXeditorto
revisions of programs to demonstrate one typical usage of the tool.
4.2 Metrics
Weusedthefollowingmetricstoevaluatetheeffectivenessof Xed-
itor and the baseline technique.
Precision (P) measuresamongallreportsgeneratedbyatech-
nique, how many of them are true positives:
P=# of correct reports
Total # of generated reports√ó100% . (1)
Precisioncanbeusedtoevaluatetheeffectivenessofruleinference
and rule application. For rule inference, Pmeasures how many
reported rules are correct rules. For rule application, Pmeasures
among all reported XML bugs, how many of them are real bugs.
Recall(R) measuresamongallknowntruepositives,howmany
of them are reported by a technique:
R=# of correct reports
Total # of true positives√ó100% . (2)
Sincewe donothaveany priorknowledgeonthe truerulesexist-
ing in XML files, we did not evaluate the recall of rule inference.
However,basedontheinferredrulesandourmanualinspection,
wemanagedto constructa ground truthdata setand evaluated the
recall of rule application.
F score (F) combines PandRto measure the accuracy:
F=2√óP√óR
P+R√ó100% . (3)
The F score measures the trade-off between precision and recall,
thus we leveraged it to measure the accuracy of rule application.
4.3 Effectiveness of Rule Inference
There are four parameters in Xeditor that can influence its ca-
pability of rule inference: supp,conf,vthandpth. To investigate
howsensitiveXeditoristotheseparameters,weappliedXeditor
tothefirstdatasetD1withdistinctparametersettings,andthen
manually inspected the inferred rules to calculate precision. Before
our manual inspection, we did not have any prior knowledge of
the correct rules. Therefore, it is infeasible for us to evaluate the
recall of Xeditor‚Äôs rule inference. To evaluate the precision, given
a rule reported by Xeditor, our manual inspection involves on-
linesearchfor(1)therelatedlibraryspecificationsorframework
tutorials,and/or(2)relevantdiscussionsontechnicalforums(e.g.,
StackOverflow[ 6]).Weconsideraninferredruletobetrueifonline
documentation or discussion recommends it, or no online XML
example violates the rule.
4.3.1 Sensitivity to supp.We increased suppfrom 0 to 19, and
explored 20 settings for the parameter. Due to the space limit, in
Table 1, we present the results for only five settings. Intuitively,
suppcounts the number of supporting instances for any candidate
rule. The more supporting instances there are, the more likely that
a candidate rule is a real one. As shown in the table, when supp
increases from 8 to 12, the number of inferred rules by Xeditordecreases from 56 to 40, while the number of correctly inferred
rules decreases from 34 to 24. The observations are understandablebecausewiththeotherparametersunchanged,themoresupportingTable 1: Rule inference with different settings of supp
supp conf vth pth# of Inferred
Rules# of Correct
RulesPrecision
(%)
8 0.9 0.9 3 56 34 61
9 0.9 0.9 3 53 32 60
10 0.9 0.9 3 50 32 64
11 0.9 0.9 3 44 27 61
12 0.9 0.9 3 40 24 60
Table 2: Rule inference with different settings of conf
supp conf vth pth# of Inferred
Rules# of Correct
RulesPrecision
(%)
10 0.75 0.9 3 59 32 54
10 0.80 0.9 3 54 32 59
10 0.85 0.9 3 52 32 62
10 0.90 0.9 3 50 32 64
10 0.95 0.9 3 40 25 63
Table 3: Rule inference with different settings of vth
supp conf vth pth# of Inferred
Rules# of Correct
RulesPrecision
(%)
10 0.9 0.75 3 67 38 57
10 0.9 0.80 3 58 35 60
10 0.9 0.85 3 53 33 62
10 0.9 0.90 3 50 32 64
10 0.9 0.95 3 36 23 64
Table 4: Rule inference with different settings of pth
supp conf vth pth# of Inferred
Rules# of Correct
RulesPrecision
(%)
10 0.9 0.95 8 32 23 72
10 0.9 0.95 9 30 22 73
10 0.9 0.95 10 27 20 74
10 0.9 0.95 11 24 17 71
10 0.9 0.95 12 15 10 75
instancesarerequired,thefewerruleshavesufficientoccurrence
rates to meet the criterion. Among all investigated settings, weidentifiedaprecisionpeakat
supp=10,whichis64%.Therefore,
we setsupp=10 by default.
4.3.2 Sensitivityto conf.Weincreased conffrom0.00to0.95with
0.05 increment, and explored 20 settings for the parameter. Due to
the space limit, Table 2 only presents our results for five parametersettings.Theoretically,foreachcandidaterule
A‚ÜíB,confreflects
the likelihood of B‚Äôs occurrence given A‚Äôs occurrence. Thus, the
higherconfis,themorelikelythatacandidateruleisatruepos-
itive. According to the table, as confincreases from 0 .75 to 0 .95,
the number of inferred rules decreases from 59 to 40, while thenumber of correctly inferred rules remains to be 32 initially and
thendecreases to25. Themajor reasonforthese observed trends is
that as the threshold increases, there are fewer rules satisfying the
filteringcondition.Becausetheprecisionof Xeditor‚Äôsinference
increases first and then decreases, we set conf=0.9 by default.
4.3.3 Sensitivityto vth.Weincreased vthfrom0.00to0.95with
0.05 increment, and explored 20 settings for the parameter. Table 3
showsourresultsforfiveofthoseinvestigatedsettings.Basically,
givenacandidaterule A‚ÜíB,vthreflectstheratioofsame-value
cooccurrencesbetween AandBamongallof theircooccurrences.
Therefore, the higher vthis, the more convincing a candidate rule
is. In Table 3, as vthincreases, Xeditor inferred fewer rules and
677Table 5: The 10-fold cross validation for Xeditor‚Äôs effectiveness of bug detection
IdRule Inference Rule Application
# of Rules
Inferred# of Correctly
Inferred Rules# of Bugs
Reported# of Known
Bugs# of Correctly
Reported BugsPrecision Recall Accuracy
1 25 20 304 283 271 89% 96% 92%
2 25 20 322 291 285 89% 98% 93%
3 21 17 258 251 240 93% 96% 94%
4 23 19 307 300 292 95% 97% 96%
5 26 21 283 276 272 96% 99% 97%
6 23 20 298 277 272 91% 98% 95%
7 21 17 270 269 252 93% 94% 94%
8 20 18 293 271 265 90% 98% 94%
9 20 18 270 268 253 94% 94% 94%
10 22 18 282 266 244 87% 92% 89%
acquired fewer correct rules; the inference precision goes up from
57% to 64%. Thus, by default, we set vth=0.95.
4.3.4 Sensitivity to pth.We increased pthfrom 0 to 19, and ex-
plored20 settingsfor theparameter. Table4 showsour resultsfor
five of the explored settings. Essentially, pthcounts the number of
projects holding at least one supporting instance for any candidate
rule.Themoreprojectstherearetosupportacandidaterule,the
more possible that the rule is true. In Table 4, as pthincreases, the
numberofrulesinferredbyXeditordecreasesfrom32to15and
the number of correct rules decreases from 23 to 10. The precision
rate first increases, then decreases, and next increases again. To
achieve a good trade-off between the number of correctly inferred
rules and inference precision, we set pth=9 by default.
Finding 1: Forruleinference,Xeditor‚Äôseffectivenessisconsid-
erablyinfluencedbythesettingsofallfourparameters.Aseach
parameterhasitsvalueincreased,Xeditorusuallyinfersfewer
rulesandobtainsfewercorrectrules,whiletheprecisionratemay
increase, decrease, or remain the same.
4.3.5 Xeditor‚Äô Precision for Rule Inference. After manually check-
ing all inferred rules by Xeditor with different parameter settings,
we confirmed 57 correctly inferred rules. Among these rules, 22
rules can be retrieved by Xeditor with its default configuration:
supp=10,conf=0.9,vth=0.95,andpth=9.Essentially,differ-
ent parameter settings indicate different trade-offs between two
factors:(1)thenumberofinferredrulesand(2)theprecisionrate.
Whenwedecideduponthedefaultsetting,wecaredmoreabout
precisionthantheotherfactor.ThisisbecausetomakeXeditor
usableto people,wewanttoensure thatmostofthe rulesreported
by Xeditor are correct and valuable.
Our experiment implies significant space for future improve-
ment in rule inference from DD. Specifically, with our carefully
chosen parameter configuration, Xeditor inferred rules with 73%
precision; novel approaches are still needed to considerably boost
theprecisionrate.Additionally,amongthe57validatedrulessofar,
atmost38rulescanberetrievedwithoneoftheexploredparam-
etercombinations.Moreadvancedtechniquesarestillinneedto
identify more true rules with reasonably good precision rates.
Finding2(ResponsetoRQ1): Withthedefaultsetting supp=
10,conf=0.9,vth=0.95, andpth=9, Xeditor effectively
inferred rules with high precision (73%).4.4 Effectiveness of Bug Detection and Fix
To evaluate Xeditor‚Äôs effectiveness of rule application, we con-
ducted two experiments. The first experiment splits D1 into 10
portionsevenly,andconducts10-foldcrossvalidationtoevaluate
how bugs detected by Xeditor match the known bugs in our data
sets.Inthesecondexperiment,with57rulesextractedfromD1,we
applied Xeditor to different versions of deployment descriptors
in D2, and validated the reported bugs and fixes based on later
versions in software history or developers‚Äô feedback.
4.4.1 Experiment Based on D1. We splitthe 4,248 DD into 10 por-
tionsP={p1,p2,...,p10},andconducted10-foldcrossvalidation
toevaluateXeditor‚Äôseffectivenessofbugdetectionandfix.Ineach
fold, we fed Xeditor with nine portions of data for rule inference
(e.g.,including p1,p2,...,p9);weusedtheremainingoneportion
ofdata(e.g., p10)tocreateatestset,andthenreliedonthetestdata
toassessXeditor‚Äôseffectivenessofruleapplication.Amongthe10
foldsofvalidation,werotateddataandensuredthateachportion
was used exactly once for test data creation.
Specifically, to build a test set with a data portion pi(i‚àà[1,10]),
wefirstappliedAntlrtoconverteachdeploymentdescriptor f‚ààpi
to a parsing tree t, and then extracted entities from t. If there is
any entity pair c=(e1,e2)demonstrating a rule r=A‚ÜíBwhich
belongs to the 22 confirmed rules in Section 4.3, we removed B‚Äôs
match(e.g., e2)fromthetreetogetadifferenttree t/prime.Inthisway,
if Xeditorworkssuccessfully,itshouldbeableto(1)inferrule r
fromtheothernineportionsofdata,and(2)usethatruletoreportabug(e.g.,missingB‚Äôsmatch
e2)whenscanning t/prime.Withthecreated
test sets, we compared all bugs reported by Xeditor against the
known bugs in modified parsing trees, and evaluated the precision,
recall, and accuracy accordingly.
Table 5 presents our experiment results for the 10-fold cross
validation.Inthetable, #ofRulesInferred showshowmanyrules
Xeditor inferred from the nine data portions for each round. #of
CorrectlyInferredRules reportshowmanyoftheinferredrules
are actually correct according to our manual analysis. # of Bugs
Reported presentsthenumberofbugsXeditordetectedinthetest
set.# of Known Bugs showsthenumberofbugsweintroduced
by modifying parsing trees and removing certain entities. #o f
Correctly Reported Bugs counts the reported bugs that match
our ground truth. Precision ,Recall, andAccuracy reflect the
effectivenessof Xeditor‚Äôsbugdetectioncapability.Forinstance,
in round 1, Xeditor inferred 25 rules from the given data portions,
while20oftheserulesaretruepositives.Basedonallinferred25
678Table 6: The 15 real XML bugs fixed by developers
Bug
IndexViolated Rule ( A‚ÜíB) Root Cause Category Fixing Strategy Vdiff(fix, bug)
1*_beans_bean_property_ref ‚Üí*_beans_bean_id Delete B only Import an XML file 2
2*_web-app_security-constraint_auth-constraint_role-name ‚Üí
*_web-app_security-role_role-nameUpdate the data of A while B‚Äôs data
is unchangedUpdate the data of B 1
3*_web-app_security-constraint_auth-constraint_role-name ‚Üí
*_web-app_security-role_role-nameUpdate the data of A while B‚Äôs data
is unchangedUpdate the data of B 1
4*_web-app_security-constraint_auth-constraint_role-name ‚Üí
*_web-app_security-role_role-nameInsert A only Insert B 4
5*_web-app_security-constraint_auth-constraint_role-name ‚Üí
*_web-app_security-role_role-nameInsert A only Insert B 4
6*_beans_bean_property_ref ‚Üí*_beans_bean_id Insert A only Delete A 2
7*_beans:beans_beans:bean_beans:property_ref ‚Üí
*_beans:beans_beans:bean_idInsert A only Delete A 1
8*_beans:beans_beans:bean_beans:property_ref ‚Üí
*_beans:beans_beans:bean_idDelete B only Delete A 5
9*_web-app_servlet-mapping_servlet-name ‚Üí
*_web-app_servlet_servlet-nameInsert A and B with different string
literals usedUpdate the data of A 3
10*_web-app_servlet-mapping_servlet-name ‚Üí
*_web-app_servlet_servlet-nameDelete B only Insert B 1
11*_web-app_servlet-mapping_servlet-name ‚Üí
*_web-app_servlet_servlet-nameInsert A only Insert B 150
12*_web-app_servlet_servlet-name ‚Üí
*_web-app_servlet-mapping_servlet-nameInsert A only Delete A 6
13*_web-app_servlet-mapping_servlet-name ‚Üí
*_web-app_servlet_servlet-nameInsert A only Delete A 1
14*_web-app_servlet-mapping_servlet-name ‚Üí
*_web-app_servlet_servlet-nameInsert A only Delete A 1
15*_web-app_servlet_servlet-name ‚Üí
*_web-app_servlet-mapping_servlet-nameInsert A and B with different string
literalsUpdate the data of B 3
rules, Xeditor detected 304 bugs in the test set, although there are
283knownbugsintheset.Theintersectionbetweenbugreports
and our ground truth is 271 bugs. Thus, Xeditor achieved 89%
precision, 96% recall, and 92% accuracy for round 1.
In each round, given 9 portions of data, Xeditor inferred 20-26
def-uselikerules,and17-21oftheserulesaretruerules.Basedonall
inferredrules,Xeditorreported258-322bugs,and240-292ofthemaretruebugs.Amongthe10rounds,onaverage,Xeditorachieved
92% precision, 96% recall, and 94% accuracy for bug detection. Two
reasonscanexplainwhyXeditorcouldnotachieve100%accuracy.First, when Xeditor obtained false positives for rule inference, theincorrectlyinferredrulesmisledXeditortoproducefalsepositives
forruleapplicationandthusreportfalsebugs.Second,sometrue
ruleshaveinsufficientsupportinginstancesintheselectedninedataportions. Consequently, these rules cannot be inferred by Xeditor,neithercanXeditordetecttheknownbugsinthetestsetforthese
rules. In other words, the false negatives in rule inference cause
false negatives in rule application.
Finding 3 (Response to RQ2): Xeditor detected bugs in XML
files with 92% precision, 96% recall, and 94% accuracy.
4.4.2 Experiment Based on D2. With the 57 true rules revealed in
Section 4.3, we applied Xeditor to the second data set D2 to evalu-
atewhetherXeditorcan(1)detectanyrealbuginupdatedXML
files, and (2) suggest fixes that correspond to developers‚Äô actualfixes in reality. Specifically for each project, if a commit
Cin the
versionhistorymodifiesadeploymentdescriptor f,Xeditorscans
the after-changeversion of f. If there is any bugdetected,we man-
ually examine versions after Cin the repository to decide whetherthereportedbugwasultimatelyfixedbydevelopers.Ifso,there-
portedbugisarealbug,andwecanfurthercompareXeditor‚Äôsfix
suggestion against the actual fix applied by developers.
By manually checking the bug reports generated by Xeditor,
we identified 25 really problematic XML updates. Interestingly,
15 of these 25 bugs were later fixed by developers according to
the version history. This observation means that developers did
introducethe XMLbugsthat Xeditorcandetect, andXeditoris
capable of revealing developers‚Äô mistakes when they edited DD.
Finding4(ResponsetoRQ4): Xeditorrevealed15XMLbugs
inopen-sourcesoftwarerepositories.OurobservationindicatestheimportanceofXeditor,becausedevelopersdidintroducetheXML
bugs that Xeditor could detect during XML file maintenance.
Table 6 presents the 15 bugs that developers later fixed. Specifi-
cally,column BugIndex showstheindexweassignedtoeachbug.
Violated Rule shows the rule Xeditor used to identify the bug.
Root Cause Category explains how developers introduced the
bug.FixingStrategy describeshowdevelopersresolvedthebugin
a later version. Vdiff(fix, bug) describes the version difference be-
tween the bug-fixing commit and bug-introducing one. Let us take
thefirstbugasanexample.Theviolatedruleis *_beans_bean_property
_ref‚Üí*_beans_bean_id . In one commit Ci, developers deleted the
consequententity(B)whilekeepingtheantecedent(A).Inalater
commitCi+2, developers fixed the bug by importing an XML file
whereBdefinestheliteralusedbyA.Therefore,Vdiff(fix,bug)=
(i+2)-i=2 .
679Table 7: The 10-fold cross validation for Baseline‚Äôs effectiveness of bug detection
IdRule Inference Rule Application
# of Rules
Inferred# of Correctly
Inferred Rules# of Bugs
Reported# of Known
Bugs# of Correctly
Reported BugsPrecision Recall Accuracy
1 23 18 252 272 248 98% 91% 95%
2 17 12 260 322 257 99% 80% 88%
3 21 16 225 287 222 99% 77% 87%
4 21 16 270 296 266 99% 90% 94%
5 21 16 254 288 248 98% 86% 92%
6 22 17 246 365 245 100% 67% 80%
7 20 15 230 321 227 99% 71% 82%
8 20 15 241 261 236 98% 90% 94%
9 21 16 238 343 234 98% 68% 81%
10 23 18 221 352 217 98% 62% 76%
According to Table 6, four bugs (i.e., 4th,5th,1 0th, and 11th)
werefixedviatheinsertionofB.Developersfixedanothersixbugs
(i.e., 6th,7th,8th,1 2th,1 3th, and 14th) by deleting A. Four bugs
(i.e., 2nd,3rd,9th, and 15th) were fixed via data updates to A or
B. One bug (i.e., 1st) was fixed when developers imported another
XMLfileforthedatavalueusedbyA.Amongalltheseappliedfixes,
10 fixes are covered by the strategies suggested by Xeditor (Insert
BorDeleteA).ItmeansthatXeditorusuallysuggestshelpfulfixes.
Additionally,for6outofthe15bugs,developersappliedfixes
in the immediate next commit; they fixed the remaining bugs af-
teratleasttwocommits.Mostinterestingly,developersfixedone
bug (i.e., 11th) after 150 commits. These observations imply that if
developers had used Xeditor to examine their updated XML files
before committing program changes, they should have avoided
checkingintheerroneousprogramchanges,orevenhavefixedthe
introduced bugs earlier.
Finding 5(Response toRQ5): Xeditor‚Äôs change suggestions
matchdevelopers‚Äôactualfixesfor10ofthe15detectedXMLbugs.
4.5 Comparison with Baseline
Prior change suggestion tools mine software version history for
co-change patterns, and use those patterns to identify any miss-
ing change [ 26,27,32,40,49,53]. For instance, ROSE leverages
associationrulemining (ARM)toidentifytheco-change rulesbe-
tween program entities (e.g., ‚Äúif method Ais changed, method B
shouldalsobechanged ‚Äù),suchthatwheneveranentity(e.g., A)is
changed and its related entity (e.g., B) is not, ROSE suggests the
missing change [ 53]. These tools are similar to Xeditor due to
theiradoptionofARM,butdifferentbyrelyingonthe co-changes
instead of coexistence of program entities. We were curious how
Xeditorcompareswithpriorwork,butnopriorworkextractsany
project-agnostic co-change rules for deployment descriptors.
The Baseline Approach (Baseline). To facilitate the com-
parison between two methodologies, i.e., coexistence-based vs. co-
change-based, we built a ROSE-like baseline approach (named
‚ÄúBaseline‚Äù for short). Baseline mines frequently co-changed XML
entities in software version history, and uses our customized as-sociation rule mining to infer rules of the format ‚Äú
Chan–¥e (A)‚Üí
Chan–¥e (B)‚Äù. Baseline then exploits these rules to check individual
program commits (i.e., the program changes) for any erroneous
XML update. Similar to Xeditor, Baseline extracts two entities
as a candidate pair if (i) they are frequently co-changed within the
same files and (ii) they usually refer to the same string literal.ExperimentSetting. AswithXeditor,Baselinealsohasfour
parameters: supp,conf,vth,andpth.Forfaircomparison,wetuned
parameters in the manner described in Section 4.3 and found areasonably good default setting for Baseline:
supp=5,conf=
0.65,vth=0.8, andpth=8. Afterwards, we evaluated Baseline
using 10-fold cross validation based on the data set D1.
Results. Table 7 presents Baseline‚Äôs effectiveness of bug de-
tection in the 10-fold cross validation experiment. According to
thetable,ineachround,Baselineinfers17-23rules,while12-18
oftheseinferredrulesarecorrect.Whendetectingbugsbasedon
all inferred rules, Baseline obtained 98%-100% precision, 62%-91%
recall, and 76%-95% accuracy. On average, Baseline detected bugs
with98%precision,78%recall,and87%accuracy.Comparedwith
Xeditor‚Äôs effectiveness shown in Table 5, on average, Baseline
achieved higher precision (98% vs. 92%), lower recall (78% vs. 96%),
and lower accuracy (87% vs. 92%). These results indicate that Xedi-
tor and Baseline achieved different trade-offs betweenprecision
and recall. When software practitioners choose an approach to use
for XML debugging, they can either choose Baseline for higher
precisionandlowerfalsepositiverates,orselectXeditorforhigher
recall and lower false negative rates.
Tworeasonscanexplaintheabove-mentionedcomparisonre-
sults. First, Baseline analyzes the evolution history of 4,288 DD,
whileXeditorexaminesonlyoneversionofthesefiles.Actually,
the frequent co-changes indicate stronger relevance between enti-
ties than recurring coexistence. Namely, if two entities are often
changed together in the same file, they definitely coexist; neverthe-less,iftwoentitiesoftencoexistinthesamefile,theydonothaveto
be changed or get frequently changed together. Consequently, the
rules inferred from co-changed entities are generally more precise.
Second, When two closely related entities are barely changed in
version history, Baseline cannot infer any correlation between
them, neither can it predict any co-changes for those entities. Con-
sequently, Baseline obtained lower recalls.
Finding6(ResponsetoRQ3): ComparedwithBaseline,Xed-
itor detected bugs with lower precision (92% vs. 98%), higher
recall(96%vs.78%),andhigheraccuracy(92%vs.87%).Thesetwo
approaches made distinct trade-offs between precision and recall.
5 THREATS TO VALIDITY
Threats to External Validity. All inferred rules and detected bugs
mentionedinthispaperarelimitedtoourexperimentdatasets.Theobservationsmaynotgeneralizewelltoclose-sourceprojects.Inthe
680future, we would like to include more projects into our evaluation,
orevenincludeclose-sourceprojectsifpossible,sothatourfindings
are more representative.
ThreatstoConstructValidity. Inour10-foldcrossvalidationfor
Xeditor‚Äôs effectiveness of bug detection and suggestion, for each
fold, we automatically generated bugs by removing some XML
entitiesfromDD.Thesebugsmaynotrepresenttherealbugsintro-
ducedbydevelopersduringsoftwaremaintenance,soourempirical
measurementscanbebiased.Inthe future,wewillconstructdata
setswithrealbugsinDDtobetterevaluateXeditor‚Äôscapability
of bug detection and suggestion.
ThreatstoInternalValidity. Ourmanualanalysisfortheoutput
by Xeditor is subject to human bias and limited to our domain
knowledge. To mitigate the problem, we had two authors to exam-
ine the rules reported by Xeditor for agreement. The two authors
agreed with each other in most scenarios. When they disagreed
uponcertainrulesmainlybecauseoftheirlimiteddomainknowl-
edge,theysharedrelevantdocumentationorexampleswitheach
other for discussionuntil coming to an agreement. Among the 25
really buggy XML updates detected by Xeditor, there are 10 bugs
not fixed by developers. We sent emails to the owner developers to
check whether any of these 10 bugs is true. So far, we have only
received one response email, which pointed out that the violation
showninListing3isafalsepositive.Aswegathermorecomments
from developers, we will further improve the quality of inferred
rules and change suggestions.
6 LESSONS LEARNED
Weconductedcustomizedassociationruleminingtoextractdef-use
likeXMLrulesinadomain-agnosticway.Ourapproachisbasedontheinsightthat‚Äúiftwoentitiesfrequentlycoexistinthesamefileandoftenholdthesamedata,theyarecorrelated ‚Äù.Ourevaluationshows
that Xeditor reveals some interesting rules that can effectively
capture the XML bugs caused by human errors. More importantly,
by manually analyzing the false positives produced by Xeditor,
we also learnt four research challenges in this area.
First,relatedentitiesdonotalwayscoexistinthesamedeployment
descriptor. We observed that some correlated entities are defined
in two separate XML files; their relationship is established when
(1)oneXMLfileimportstheotherfileor(2)aJavaannotationin
source code specifies both files. For instance, for the rule
*_beans_bean_property_ref ‚Üí*_beans_bean_id ,
wefound1,196occurrencesof refinD2,and49ofthemcorrespond
totheiddefinedinanotherXMLfile.Toresolvesuchissues,wewill
conductcross-fileassociationruleminingbytreatingmultipleXML
files and Java files as a whole and analyzing them simultaneously.
Listing3:Afilethatviolatesoneofourinferredrulesbutis
considered to be valid by its owner developer [4]
1 ...
2 <beans xmlns="http ://www.springframework.org/... >
3 <mongo:db ‚àífactory dbname="${mongo. database.name}" mongo
‚àíref="mongo" />
4 <bean id="mon goTemplate" class= ... >
5 <constructor ‚àíarg name=" mongoDbFactory "r e f = "
mongoDbFactory "/ >
6 </bean>
7 </beans>Second,some related entities may never refer to the same value.
Listing 3 presents a file that violates an inferred rule but is consid-
ered to be correct by the owner developer. Based on the rule
*_beans_bean_constructor-arg_ref ‚Üí*_beans_bean_id ,
Listing 3 has a rule violation and should include another beandefined with the id
mongoDbFactory . However, from our email con-
versation with the developer and relevant documentation [ 41], we
learnt that by default, the <db-factory> element enables Spring to
createaninstanceof MongoDbFactory andtoregistertheinstanceas
a bean named mongoDbFactory . In other words, with theexistence of
mongo:db-factory ,weshouldNOTdefineabeanwiththeid mongoDbFactory .
SuchdelicateconstraintsarecurrentlynotinferablebyXeditor,
becausethespecificationdoesnotalignwellwithourinsight.Toex-tractsuchconstraints,moreheuristicsanddomain-specificinsights
are needed for better approach design.
Third,some related entities may not cooccur frequently enough.
Currently, Xeditor adopts multiple parameters (i.e., suppandpth)
to refine inferred rules based on the cooccurrence frequency be-tween entities. According to our experience, there are def-use
rules that Xeditor could not identify simply because the cooccur-
rence rates are low. This limitation is commonly shared among all
probability-basedruleinferenceapproaches.Morenoveltechniques
are still needed to reveal rules based on rare entity occurrences.
Fourth,the fixing strategies for rule violations can vary a lot. Cur-
rently,whenarule A‚ÜíBisviolated,Xeditorsuggestsdevelopers
to either remove Aor insertB. However, in reality, developers‚Äô fix-
ingstrategiescanbemorediverse,suchasmodifyinganexisting
entity to satisfy the constraint or importing an XML file with B
defined.Researchesmayneedbettertechniquestoproposemore
fixing strategies automatically and to fully automate XML repair.
7 RELATED WORK
The related work of this research includes metadata validation,
program change prediction, traceability management, and configu-
ration debugging.
7.1 Validation of Metadata
Several approaches were proposed to help check and/or fix the
usageofmetadata(i.e.,XMLandannotations)[ 20,22,23,25,30,37,
43,45].Forinstance,XQueryisawidelyusedqueryandfunctional
programminglanguage thatqueriesand transformscollectionsof
structured or unstructured data in XML documents [ 22]. Similarly,
CDuce [20] andXDuce [ 31] areindependently developeddomain-
specific languages (DSLs) for XML processing. To validate and
transform XMLfiles, usershave tolearn one ofthese DSLsand use
the DSL to prescribe matching logic and change operations, which
procedure can be tedious and error-prone.
To validate Java annotation usage, Eichberg et al. provided a
DSL for users to define constraints [ 25]. To check user-specified
constraints, the researchers automatically converted Java bytecode
to XML documents, and converted constraints to XQuery path ex-
pressions.Similarly,Darwin[ 23]andNogueraetal.[ 37]separately
defined DSLs for users to specify and then validate the constraints
onannotationusage.However,generaldev elopersmaynothave
sufficient domain knowledge to properly utilize these languages.
681SongandTilevichbuiltanapproachto automaticallyinferand
check invariants between metadata and program constructs, with-
out requiring users to manually prescribe anything [ 43]. However,
this approach focuses on the relations between metadata and code;
it does not handle any editing constraint within XML files.
7.2 Program Change Prediction
Researchers built tools to mine version histories for co-change pat-
terns,andusedthosepatternstopredictanymissingchange[ 26,27,
49,53].Specifically,Galletal.minedreleasedatafortheco-change
relationshipbetweensubsystems[ 26]andclasses[ 27].Zimmerman
etal.andYingetal.furtherextractedtheco-changerelationship
between finer-grained program entities (e.g., classes, methods, and
fields)[49,53].However,theseapproachespredictchanges purely
based on entities‚Äô co-change frequencies, without considering any
syntacticorsemanticrelationshipbetweenentities.Whenlotsof
irrelevant entities are accidentally co-changed multiple times, such
tools may incorrectly infer rules and produce incorrect predictions.
Somehybridapproachescombinehistory-basedassociationrule
mining with information retrieval (IR) [ 28,35,50]. Given a soft-
ware entity E, these approaches leverage IR-based techniques to
(1) extract terms from Eand any other entity and (2) rank those
entities based on their term overlapping with E. Meanwhile, these
approachesalsominehistoryforco-changesandrankentitiesac-
cordingly. Given a new commit, these approaches combine the two
ranked lists in distinct ways to reveal any missing change. How-
ever,theeffectivenessoftheseapproachesarealsolimitedbythe
frequency of co-changed entities.
Severalresearchersusedthesyntacticrelationshipbetweenenti-
tiesorfilestopredictchanges[ 33,42,46].Forinstance,Shirabadet
al. trained a machine-learning model to characterize any common-
alitybetweenco-changedfiles,suchasnumbersofcommonlyused
types/functions/variables [ 42]. Given a changed file, the model pre-
dicts what other files to change together. Wang et al. characterized
the common field accesses and/or common method invocations
betweenco-changedmethods[ 47].Basedonthecharacterization,
Wangetal.builtCMSuggester,atooltopredictmethodsforchange
given an added field or method and one or more changed meth-
ods[33,46]. However, these approaches only analyze source code;
they are not applicable to non-code artifacts like XML files.
7.3 Traceability Management
Softwareartifacttraceabilitymeans‚Äútheabilitytofollowthelifeofarequirementinaforwardandbackwarddirection‚Äù[
29].Maintaining
traceabilityacrosssoftwareartifactshelpsensurethecoevolution
of artifacts [ 38]. For instance, when a high-level requirement docu-
ment is changed, traceability helps locate the pieces of design or
codewhichshouldalsobechanged.Variousinformationretrieval
approaches were proposed to reveal traceability links mainly be-
tweenrequirementdocumentationandothertypesofartifacts(e.g.,
designdocumentsandsourcecode)[ 21].Additionally,Kagdiand
Maleticbuiltatooltoanalyzecommitsinasoftwareversionhis-
toriesandtomineforhighlyfrequentlyco-occurringchangesto
different artifacts [ 34]. Lozano et al. built MaTraca‚Äîa tool that sup-
ports users to specify traceability links across domains via logicpredicates. With users‚Äô specifications, MaTraca checks the linksbetween (1) entity definitions in one domain (e.g., Java) and (2)entityusageinanother(e.g.,XML).However,noneofthesetools
examine the coevolution patterns within the same XML file.
7.4 Configuration Debugging
Severaltoolswerebuilttodiagnoseorfixsoftwareconfiguration
errors [18,19,39,48,52]. These approaches execute buggy soft-
ware, gather execution profiles, compare the profiles, and conduct
dynamic analysis to locate errors. For instance, ConfDiagnoserrecords program predicates that may be affected by each config-
urationoption,andcollectstheexecutionprofilesofaprogram‚Äôs
correctandundesiredruns[ 52].Bycomparingthebehavioraldif-
ferencesbetweentwotypesofrunsintermsofrecordedpredicates,ConfDiagnoseridentifiesthecandidateoptionswithmisconfigured
values.Weissetal.builtanapproachtogeneralizesystemconfigura-
tionrepairsforcertaintypesofmachinesfromtheshellcommands
developers entered to update one machine [48].
The configuration files examined by these approaches are irrele-
vanttoXMLdocuments.Noneofthesetoolscheckforanycoupling
between configuration options.
8 CONCLUSION
Deploymentdescriptorsarehardtocreateandmaintain,because
there are domain-specific constraints on the XML formats defined
by different software libraries. In this paper, we built Xeditor‚Äî
anapproachtoautomaticallyinferthedef-uselikeconfiguration
couplingsinDD.ByapplyingtheinferredrulestoagivenXMLfile,
Xeditor can identify any rule violation to report bugs and provide
suggestions.Similarto priorruleminingapproaches, Xeditor also
leverages association rule mining to infer rules based on statistics.
However, different from prior work, Xeditor (1) infers rules from
DD instead of source code, (2) relies on the common data sharedbetween XML entities to locate candidate pairs, (3) mines rulesbased on the coexistence instead of co-changes between entities,
and (4) adopts more filters to refine the mined rules.
Ourevaluationrevealsinterestingphenomena.First,theeffec-
tiveness of Xeditor is sensitive to its parameter settings. Withappropriate configuration, Xeditor was able to infer rules withhigh precision (73%). Second, Xeditor could detect bugs in DD
with high precision (92%), high recall (96%), and high accuracy
(94%).Third, Xeditorcouldidentifyrealbugs inDD,whichwere
actuallylaterfixedbydevelopers.Thisdemonstratestheusefulnessof XeditorandthenecessityofsimilarstaticanalysistoolsforDD.
ThereisstillsignificantspaceforfutureimprovementsinDD-
relatedruleinferenceandapplication.Ourresearchcurrentlyfo-
cuses on def-use like configuration couplings because we observed
such rules in various software frameworks. However, it is still un-
knownwhatmajortypesofDDbugsexistinrealsoftwaresystems
and how def-use bugs compare with other bug categories in terms
of the occurrence rates and severity. As the future work, we will
conduct an empirical study on DD bugs in open-source projects.
ACKNOWLEDGMENT
Wethank reviewersfor their insightfulcomments. Thiswork was
supported by NSF grants CCF-1845446 and CNS-1929701, and Bei-
jing Natural Science Foundation No. 4192036.
682REFERENCES
[1]bagh. https://github.com/moghim/bagh/commit/
cae2a77fbdefedc823291a5fa98a3f51bb0c4816#diff-
411d1a9625fc3f5d5be34d116942f6ca.
[2]demo-web. https://github.com/agile-shark/demo-web/blob/master/src/main/
webapp/WEB-INF/web.xml.
[3] GitHub. https://github.com.
[4]poc-spring-data-mongodb. https://github.com/rodrigozrusso/poc-spring-data-
mongodb/blob/master/src/main/resources/spring-mongodb.xml.
[5]Spring - Bean Definition. https://www.tutorialspoint.com/spring/spring_bean_
definition.htm.
[6] StackOverflow. https://stackoverflow.com.[7]
TheDeploymentDescriptor:web.xml. https://cloud.google.com/appengine/docs/
standard/java/config/webxml.
[8]Viewing Deployment Descriptors. https://www.ibm.com/support/knowledgecenter/en/SS7K4U_9.0.5/com.ibm.websphere.zseries.doc/ae/trun_
app_deploymtdesc.html.
[9]WorkingwithSecurityRoles. https://docs.oracle.com/cd/E19226-01/820-7627/
bncav/index.html.
[10] XML Syntax. https://www.w3schools.com/xml/xml_syntax.asp.[11]
IntroductiontoWebApplicationDeploymentDescriptors. https://docs.oracle.
com/cd/E19226-01/820-7627/bncbj/index.html, 2010.
[12]Manual Wiring Functional. https://github.com/yholkamp/addressbook-sample-
jpa/commit/726bf62be03eac0e8292362340b117a7e10dd611, 2012.
[13]SecuringRESTURLswithSpring. https://stackoverflow.com/questions/13836451,
2012.
[14]HowtoCorrectlyManageFeatureConfigurationDeploymentinJBossFuse6.2.1?
https://stackoverflow.com/questions/39706237, 2016.
[15] ANTLR. https://www.antlr.org, 2020.[16] Gumtreediff/gumtree. https://github.com/GumTreeDiff/gumtree, 2020.[17]
SecuringWebApplications. https://docs.oracle.com/javaee/7/tutorial/security-
webtier002.htm, 2020.
[18]M. Attariyan and J. Flinn. Using causality to diagnose configuration bugs. In
USENIX 2008 Annual Technical Conference, ATC‚Äô08, pages 281‚Äì286, Berkeley, CA,
USA, 2008. USENIX Association.
[19]M.AttariyanandJ.Flinn. Automatingconfigurationtroubleshootingwithdy-
namic information flow analysis. In Proceedings of the 9th USENIX Conference on
OperatingSystemsDesignandImplementation,OSDI‚Äô10,pages237‚Äì250,Berkeley,
CA, USA, 2010. USENIX Association.
[20]V.Benzaken,G.Castagna,andA.Frisch. Cduce:AnXML-centricgeneral-purposelanguage. In Proceedings of the Eighth ACM SIGPLAN International Conference on
Functional Programming, ICFP ‚Äô03, pages 51‚Äì63, New York, NY, USA, 2003. ACM.
[21]M. Borg, P. Runeson, and A. Ard√∂. Recovering from a decade: a systematic
mapping of information retrieval approaches to software traceability. Empirical
Software Engineering, 19(6):1565‚Äì1616, 2014.
[22]M. Brundage. XQuery: The XML Query Language. Pearson Higher Education,
2004.
[23]I. Darwin. Annabot: A static verifier for Java annotation usage. Advances in
Software Engineering, 2010.
[24]P.Duvall,S.M.Matyas,andA.Glover. ContinuousIntegration:ImprovingSoftware
QualityandReducingRisk(TheAddison-WesleySignatureSeries). Addison-Wesley
Professional, 2007.
[25]M.Eichberg,T.Sch√§fer,andM.Mezini. Usingannotationstocheckstructural
propertiesofclasses. In Proceedingsofthe8thInternationalConference,HeldAs
PartoftheJointEuropeanConferenceonTheoryandPracticeofSoftwareConference
on Fundamental Approaches to Software Engineering, FASE‚Äô05, pages 237‚Äì252,
Berlin, Heidelberg, 2005. Springer-Verlag.
[26]H.Gall,K.Hajek,andM.Jazayeri. Detectionoflogicalcouplingbasedonproduct
release history. In Proc. ICSM, pages 190‚Äì198, 1998.
[27]H. Gall, M. Jazayeri, and J. Krajewski. CVS release history data for detecting
logical couplings. In Proc. IWPSE, pages 13‚Äì23, 2003.
[28]M. Gethers, B. Dit, H. Kagdi, and D. Poshyvanyk. Integrated impact analysis for
managingsoftwarechanges. In 201234thInternationalConferenceonSoftware
Engineering (ICSE), pages 430‚Äì440, June 2012.
[29]O.C. Z.GotelandC. W.Finkelstein. Ananalysisof therequirementstraceabil-
ity problem. In Proceedings of IEEE International Conference on Requirements
Engineering, pages 94‚Äì101, 1994.
[30]H. Hosoya and B. C. Pierce. Regular expression pattern matching for XML. J.
Funct. Program., 13(6):961‚Äì1004, Nov. 2003.
[31]H. Hosoya and B. C. Pierce. Xduce: A statically typed XML processing language.
ACM Trans. Internet Technol., 3(2):117‚Äì148, May 2003.
[32]M. A. Islam, M. M. Islam, M. Mondal, B. Roy, C. K. Roy, and K. A. Schneider.[research paper] detecting evolutionary coupling using transitive association
rules. In2018IEEE18thInternationalWorkingConferenceonSourceCodeAnalysis
and Manipulation (SCAM), pages 113‚Äì122, Sep. 2018.
[33]Z.Jiang,Y.Wang,H.Zhong,andN.Meng. Automaticmethodchangesuggestion
tocomplementmulti-entityedits. JournalofSystemsandSoftware,159:110441,2020.
[34]H. Kagdi and J. Maletic. Software repositories: A source for traceability links.
TEFSE/GCT‚Äô07, 2007.
[35]H. H. Kagdi, M. Gethers, and D. Poshyvanyk. Integrating conceptual and logical
couplingsforchangeimpactanalysisinsoftware. EmpiricalSoftwareEngineering,
18:933‚Äì969, 2012.
[36]N. Meng, S. Nagy, D. Yao, W. Zhuang, and G. A. Argoty. Secure coding practices
in Java: Challenges and vulnerabilities. In ICSE, 2018.
[37]C. Noguera and L. Duchien. Annotation Framework Validation Using Domain
Models, pages 48‚Äì62. Springer Berlin Heidelberg, Berlin, Heidelberg, 2008.
[38]R.Oliveto,G.Antoniol,A.Marcus,andJ.Hayes.Softwareartefacttraceability:thenever-endingchallenge.In IEEEInternationalConferenceonSoftwareMaintenance,
ICSM, pages 485 ‚Äì 488, 11 2007.
[39]A. Rabkin and R. Katz. Precomputing possible configuration error diagnoses. In
Proceedings of the 2011 26th IEEE/ACM International Conference on Automated
Software Engineering, ASE ‚Äô11, pages 193‚Äì202, Washington, DC, USA, 2011. IEEE
Computer Society.
[40]T. Rolfsnes, S. D. Alesio, R. Behjati, L. Moonen, and D. W. Binkley. Generalizing
the analysis of evolutionary coupling for software change impact analysis. In2016 IEEE 23rd International Conference on Software Analysis, Evolution, and
Reengineering (SANER), volume 1, pages 201‚Äì212, March 2016.
[41]J.SharmaandA.Sarin. GettingStartedwithSpringFramework:CoversSpring5.
CreateSpace Independent Publishing Platform, USA, 4th edition, 2017.
[42]J. S. Shirabad, T. C. Lethbridge, and S. Matwin. Mining the maintenance history
of a legacy software system. In Proc. ICSM, pages 95‚Äì104, 2003.
[43]M. Song and E. Tilevich. Metadata invariants: Checking and inferring metadata
codingconventions. In 201234thInternationalConferenceonSoftwareEngineering
(ICSE), pages 694‚Äì704, June 2012.
[44]SpringsecurityJDKbasedproxyissuewhileusing@SecuredannotationonCon-
trollermethod. https://stackoverflow.com/questions/35860442/spring-security-
jdk-based-proxy-issue-while-using-secured-annotation\discretionary{-}{}{}on-
control.
[45]J. W. W. Wan and G. Dobbie. Extracting association rules from XML documents
using XQuery. In Proceedings of the 5th ACM International Workshop on Web
Information and Data Management, WIDM ‚Äô03, pages 94‚Äì97, New York, NY, USA,
2003. Association for Computing Machinery.
[46]Y.Wang,N.Meng,andH.Zhong. Cmsuggester:Methodchangesuggestionto
complement multi-entity edits. In SATE, 2018.
[47]Y. Wang, N. Meng, and H. Zhong. An empirical study of multi-entity changes in
realbugfixes. 2018IEEEInternationalConferenceonSoftwareMaintenanceand
Evolution (ICSME), pages 287‚Äì298, 2018.
[48]A.Weiss,A.Guha,andY.Brun. Tortoise:Interactivesystemconfigurationrepair.
InProceedings of the 32Nd IEEE/ACM International Conference on Automated
Software Engineering, ASE 2017, pages 625‚Äì636, Piscataway, NJ, USA, 2017. IEEE
Press.
[49]A.T.T.Ying,G.C.Murphy,R.Ng,andM.C.Chu-Carroll. Predictingsourcecode
changesbyminingchangehistory. IEEETransactionsonSoftwareEngineering,
30(9):574‚Äì586, Sept 2004.
[50]M. B. Zanjani, G. Swartzendruber, and H. Kagdi. Impact analysis of change
requestsonsourcecodebasedoninteractionandcommithistories. In Proceedings
of the 11th Working Conference on Mining Software Repositories, MSR 2014, pages
162‚Äì171, New York, NY, USA, 2014. ACM.
[51]C.ZhangandS.Zhang. AssociationRuleMining:ModelsandAlgorithms. Springer-
Verlag, Berlin, Heidelberg, 2002.
[52]S. Zhang and M. D. Ernst. Automated diagnosis of software configuration errors.
InProceedings of the 2013 International Conference on Software Engineering, ICSE
‚Äô13, pages 312‚Äì321, Piscataway, NJ, USA, 2013. IEEE Press.
[53]T. Zimmermann, P. Weisgerber, S. Diehl, and A. Zeller. Mining version histories
to guide software changes. In Proc. ICSE, pages 563‚Äì572, 2004.
683