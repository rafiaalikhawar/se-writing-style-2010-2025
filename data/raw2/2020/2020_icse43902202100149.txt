App‚Äôs Auto-Login Function Security Testing via
Android OS-Level Virtualization
Wenna Song ‚Ä†
Wuhan University
Wuhan, China
swenae@whu.edu.cn
Yi Xiang
Wuhan University
Wuhan, China
xiangyi@whu.edu.cnJiang Ming
The University of Texas at Arlington
Arlington, TX, USA
jiang.ming@uta.edu
Y uan Chen
Wuhan University
Wuhan, China
sairen@whu.edu.cnLin Jiang
Independent Researcher
Xian, China
pppaass@163.com
Jianming Fu ‚Ä†
Wuhan University
Wuhan, China
jmfu@whu.edu.cnHan Yan‚Ä†
Wuhan University
Wuhan, China
cool.yim@whu.edu.cn
Guojun Peng* ‚Ä†
Wuhan University
Wuhan, China
guojpeng@whu.edu.cn
Abstract ‚ÄîLimited by the small keyboard, most mobile apps
support the automatic login feature for better user experience.
Therefore, users avoid the inconvenience of retyping their ID
and password when an app runs in the foreground again.
However, this auto-login function can be exploited to launch the
so-called ‚Äúdata-clone attack‚Äù: once the locally-stored, auto-login
depended data are cloned by attackers and placed into their
own smartphones, attackers can break through the login-device
number limit and log in to the victim‚Äôs account stealthily. A
natural countermeasure is to check the consistency of device-
speciÔ¨Åc attributes. As long as the new device shows different
device Ô¨Ångerprints with the previous one, the app will disable
the auto-login function and thus prevent data-clone attacks.
In this paper, we develop VPDroid , a transparent Android OS-
level virtualization platform tailored for security testing. With
VPDroid, security analysts can customize different device arti-
facts, such as CPU model, Android ID, and phone number, in a
virtual phone without user-level API hooking. VPDroid‚Äôs isolation
mechanism ensures that user-mode apps in the virtual phone
cannot detect device-speciÔ¨Åc discrepancies. To assess Android
apps‚Äô susceptibility to the data-clone attack, we use VPDroid
to simulate data-clone attacks with 234 most-downloaded apps.
Our experiments on Ô¨Åve different virtual phone environments
show that VPDroid‚Äôs device attribute customization can deceive
all tested apps that perform device-consistency checks, such
as Twitter, WeChat, and PayPal. 19 vendors have conÔ¨Årmed
our report as a zero-day vulnerability. Our Ô¨Åndings paint a
cautionary tale: only enforcing a device-consistency check at
client side is still vulnerable to an advanced data-clone attack.
I. I NTRODUCTION
With the prosperous development of the Android system
and mobile networks [1], [2], the apps running on Android
keep updating constantly to meet the fast-growing demand of
smartphone users. In addition to the standard functionalities
such as communication and entertainment, apps are now
performing various critical tasks such as social networking [3],
GPS navigation [4], IoT device remote control [5], and mobile
payment [6]. Inevitably large amounts of private data (e.g.,
user credentials) are stored in the smartphone. Therefore, the
*Corresponding author: guojpeng@whu.edu.cn.
‚Ä†(1) Key Laboratory of Aerospace Information Security and Trust Com-
puting, Ministry of Education;
(2) School of Cyber Science and Engineering, Wuhan University.cyber arms race between bypassing user authentication and its
countermeasure has transformed into an intensive tug-of-war.
According to V erizon‚Äôs 2019 data breach investigation re-
port [7], ‚Äú76% of network intrusions exploited weak or stolen
credentials.‚Äù Over the past decade, the attacks to take over
smartphone user accounts also generated a large body of
literature. We particularly examine the high-impact attacks
and Ô¨Ånd out that, their root causes lie in either fundamental
design Ô¨Çaws or the system‚Äôs underlying vulnerabilities. Just as
severe security vulnerabilities in Android password manager
apps allow attackers to access the stored credentials [8], [9],
man-in-the-middle (MitM) attacks exploit the password reset
vulnerability to crack a mobile user‚Äôs account password [10],
[11], and the recently developed app-virtualization technique
deÔ¨Åes Android unique user ID mechanism, causing guest apps
vulnerable to the ‚Äúshared-everything threat‚Äù [12]‚Äì[14]. In this
paper, we focus on the security risk caused by mobile apps‚Äô
auto-login functions, which belongs to client-side tampering
vulnerabilities [15].
Most of the existing mobile apps support automatic login to
optimize the user experience. It avoids the hassle of retyping
user ID and password in a small keyboard when reaccessing
the app. Mobile users have gotten used to using the auto-
login feature due to its convenience. However, if an attacker
steals the auto-login depended data from a user‚Äôs device and
replaces his data with the user‚Äôs, the attacker can bypass
the login-device number limit and access the user‚Äôs account
without raising suspicion‚Äîwe call it as a ‚Äúdata-clone attack.‚Äù
In this paper, the meaning of ‚Äùcredential‚Äù or the auto-login
depended data is a token or user identity. Initial investigations
have studied this threat [16]‚Äì[18], but all of them are limited
to victim identity theft on a rooted device. Furthermore,
they missed an important fact: an increasing number of apps
check device consistency to prevent client-side tampering; if
they detect any device-speciÔ¨Åc discrepancies, their auto-login
functions will be disabled.
We present a new attack model that can break through
the paying-subscriber limit on non-rooted devices. For many
subscription-based apps [19], such as NetÔ¨Çix, Amazon Prime
16832021 IEEE/ACM 43rd International Conference on Software Engineering (ICSE)
1558-1225/21/$31.00 ¬©2021 IEEE
DOI 10.1109/ICSE43902.2021.00149
Video, and Apple Music, their revenue models impose a
maximum number of the same user‚Äôs login from different
devices at a time. For example, NetÔ¨Çix‚Äôs Basic plan only
allows to stream high-deÔ¨Ånition (HD) video on one device
at a time. A fraudster Ô¨Årst pays NetÔ¨Çix‚Äôs Basic plan fee.
Then, he leverages an OEM-made phone clone app [20] to
launch a data-clone attack. The OEM-made phone clone app
can copy private data between the same OEM phones without
rooting devices. In this way, the fraudster enjoys the Premium
plan service‚Äîwatching HD video on multiple screens at the
same time. This new attack model can even enable non-paying
customers to use premium services completely free of charge.
To assess Android apps‚Äô susceptibility to data clone attacks,
we perform an empirical study on 234 most-downloaded apps
from American and Chinese Android app markets ( Study 1 ).
Study 1 is presented in III.C: we perform data-clone attacks
with real devices. Our tested apps have billions of users in
total. After performing data clone attacks, we can successfully
bypass user authentication and access 131 apps, including
Facebook, Snapchat, QQ, and Weibo. We further study the
failure causes of the remaining 103 apps and Ô¨Ånd out that they
have already taken actions to secure the auto-login function.
The most common strategy is to check the consistency of
device footprints when the app is resumed, such as checking
Android ID, MAC address, and International Mobile Equip-
ment Identity (IMEI). If any device-speciÔ¨Åc discrepancies are
detected, the app will disable the automatic login, and users
have to retype their ID and password manually. Some critical
apps (e.g., PayPal) can even Ô¨Ångerprint a rooted device and
the Android runtime hooking framework, Xposed [21], which
can create an app-virtualization environment to modify device
attributes.
Not wanting to stop there, we explore Android OS-level
virtualization to develop a transparent device-attribute editing
platform, named VPDroid .1VPDroid provides a customiz-
able, native-performance virtual phone (VP) environment on
a single physical device. The VP runs a standard Android
environment, and security analysts can conÔ¨Ågure the VP with
up to 101 options to simulate a smartphone‚Äôs proÔ¨Åles. VPDroid
facilitates testing an app‚Äôs capability of detecting the change of
device, as well as the resilience against the data-clone attack.
VPDroid is a heavily modiÔ¨Åed version of Cells [22], which
is the Ô¨Årst mobile OS virtualization solution to support run-
ning virtual phones on a single OS instance. Unfortunately,
Cells‚Äôs virtualization methods to many hardware devices (e.g.,
Ô¨Ålesystem, network, display, and power) have been obsolete
since Android 6.0. Besides, Cells lacks virtualization support
for Bluetooth, GPS, and Android Debug Bridge (ADB). We
improve the multiplexing of hardware devices in two ways: 1)
rewriting kernel drivers (e.g., GPS) to adapt to new Android
version updates; 2) we develop a new user-level device virtu-
alization mechanism to virtualize proprietary devices, which
are completely closed source. More importantly, VPDroid
supports editing the VP‚Äôs device-speciÔ¨Åc attributes. We care-
fully design where to edit device attributes‚Äîall customization
functions are executed outside of the VP . Our isolation design
1‚ÄúVPDroid‚Äù means running a Virtual Phone on Android system.ensures that a user-mode app running in the VP is unaware of
device-speciÔ¨Åc differences.
VPDroid has been tested to work seamlessly across Android
6.0 and Android 10.0. We repeat Study 1 in Section VII
but on top of the custom virtual phone. We install VPDroid
in a Google Nexus 6P smartphone and redo Study 1 by
conÔ¨Åguring the VP as Ô¨Åve different environments: Xiaomi
Redmi Note 4, Redmi Note 4x, Huawei Honor 6x, Honor
8, and Google Nexus 6P .2In each VP , we can compromise
all of the 234 most popular apps‚Äô accounts, including 103
apps that perform device-consistency checks. We have made
responsible disclosure to the app vendors, and 19 of them have
conÔ¨Årmed our report as a zero-day vulnerability. At last, we
discuss possible countermeasures to defeat data-clone attacks.
Our study demonstrates that only enforcing device-consistency
checks is still vulnerable to an advanced data-clone attack. In a
nutshell, we make the following three signiÔ¨Åcant contributions:
‚Ä¢Our work reveals the security risk of Android apps‚Äô auto-
login functions. In a addition, we introduce a new attack
model that can break through the paying-subscriber limit
on non-rooted devices.
‚Ä¢We improve the Android OS-level virtualization tech-
nique to develop a transparent device-attribute editing
platform. Security analysts can simulate more diversiÔ¨Åed
VPs on a single device. All of our tested apps are
deceived into thinking that the device is not changed.
‚Ä¢VPDroid has broad applications that rely on a virtual
phone environment. Our clone attack demo video (https:
//youtu.be/cs6LxbDGPXU) shows that VPDroid enables
the attacker to bypass KakaoTalk‚Äôs device-consistency
check, and the victim is unaware that her account has
been compromised. We release VPDroid‚Äôs source code at
(https://github.com/VPDroid/Dev).
II. B ACKGROUND AND RELA TED WORK
In this section, we Ô¨Årst discuss the security risk of automatic
login in mobile apps. Existing works on exploiting Android
apps‚Äô auto-login functions are limited. Then, we introduce
OEM-made phone clone apps, which we take as a vector to
clone private data. At last, we describe the principle of Android
OS-level virtualization, which is the foundation of VPDroid.
A. Automatic Login in Mobile Apps
Limited by the small-scale touchscreen, typically, only one
app is running in the foreground of a smartphone, and users
frequently switch to other apps in the background. It is rather
cumbersome having to type ID and password every time users
access an app. To optimize the user experience, most mobile
apps support the automatic login feature by default. As a
result, users only need to input their ID and password at their
Ô¨Årst login time. After that, users can access the app smoothly
without retyping their ID and password. For all of our tested
234 apps, their auto-login functions still work even when we
kill their processes and restart them later.
Most auto-login functions store user credential data locally
and complete the authentication process with the app server
2Two Nexus 6P phones are different in CPU model and ROM size.
1684automatically. User credential data are the security tokens used
to certify a user‚Äôs identity with the app server. After the user
Ô¨Årst enters ID and password to go through the authentication
process, the app locally stores user credential data for future
veriÔ¨Åcation purposes. Android provides four options to save
app-private data [23]: 1) internal Ô¨Åle storage, 2) external
Ô¨Åle storage, 3) shared preferences, and 4) databases. User
credentials are typically stored either in the form of key-
value pairs as SharedPreferences or structured data in an
SQLite database. Both of them are under the private directory
of ‚Äú/data/data/[app name]/‚Äù, and other apps typically do not
have the privilege to access them.
B. Exploiting Auto-login Function Works and Limitations
If attackers steal the locally-stored, auto-login depended
data and put them under the same directory of a different
phone, attackers can leverage the auto-login feature to bypass
the authentication from the server side. This means attacks can
automatically log in to the victims‚Äô accounts without knowing
their ID and password.
We take WeChat, a social media app with over 1 billion
daily active users [24], as a case study. WeChat stores AES-
encrypted user credentials in a SQLite database Ô¨Åle ‚ÄúEnMi-
croMsg.db‚Äù. This Ô¨Åle is under the directory of ‚Äú/data/data/Mi-
croMsg/[xxxx...xxxx]/‚Äù, in which ‚Äúxxxx...xxxx‚Äù is the 32-bit
md5 value of a Ô¨Åle name. In addition to ‚ÄúEnMicroMsg.db‚Äù,
we Ô¨Ånd WeChat‚Äôs auto-login function also relies on multiple
Ô¨Åles under the same directory and a system conÔ¨Åguration Ô¨Åle,
‚Äú/data/data/MicroMsg/systemInfo.cfg‚Äù. ‚ÄúsystemInfo.cfg‚Äù is an
XML plaintext containing the connection information with
the app server. Apparently, only cloning ‚ÄúEnMicroMsg.db‚Äù is
not enough at all. Note that the exact Ô¨Åles that are needed
by the auto-login function vary on a case-by-case basis.
Therefore, the best strategy is to clone all of the data under
‚Äú/data/data/[app name]/‚Äù to the target device.
Recent papers have exploited the pervasive auto-login fea-
ture in Android apps [16]‚Äì[18]. These studies share two
common assumptions:
1) The victim‚Äôs device has been rooted.
2) Attackers either have physical access to the victim‚Äôs
rooted device, or the malware to steal credential data has
been installed on the rooted device.
Rooted Android devices are very common in countries outside
of North America, especially in Asian countries. Tencent
research shows that 80% of Chinese users had a rooted
device [25]. Besides, according to the ofÔ¨Åcial Android security
report [26], large families of harmful applications use privilege
escalation exploits to root devices. These papers [16]‚Äì[18]
demonstrated the feasibility of data-clone attacks with a very
small number of apps‚Äîonly six apps in total. However, none
of them take device-consistency checks into consideration.
We still take WeChat as an example to explain the limitation
of existing work [16]‚Äì[18]. We clone all of the data under
‚Äú/data/data/MicroMsg/‚Äù to a new smartphone, but we still
cannot automatically log in to WeChat. WeChat pops up the
login interface and asks us to retype ID and password. The root
cause is the change of a smartphone environment is almost
)UDPHEXIIHU
*38
%LQGHU
6HQVRUV

'HYLFH1DPHVSDFH
/LQX[.HUQHO,3&
3RZHU5RRW
1DPHVSDFH9LUWXDO3KRQH
)RUHJURXQG9LUWXDO3KRQH
%DFNJURXQG
Figure 1: Cells kernel-level device virtualization overview. The
VP running in the foreground is displayed at any time and
always given direct access to hardware devices.
instantly detected by WeChat, and then it terminates the auto-
login process. We Ô¨Ånd WeChat detects 22 device footprints
such as phone number, IMEI, and Bluetooth address. In our
dataset, a total of 103 apps such as Chrome, Apple Music,
KakaoTalk, and PayPal also conduct a similar detection when
invoking their auto-login functions.
Bianchi et at. [27] also simulate device-public informa-
tion to bypass user authentication. They exploit an entire
class of apps that only rely on device-public information
to authenticate the user to their backends. However, in our
tested 234 most-downloaded apps, no one adopts such a weak
authentication scheme, including WhatsApp and Viber that
were once vulnerable in this paper. Another major difference
is that they customize only 13 device-public proÔ¨Åles in the
Xposed framework [21] by hooking APIs. By contrast, we
improve OS-level virtualization to deliver an open-source,
more transparent device-attribute editing platform, which can
edit 101 device artifacts without user-level API hooking.
C. OEM-Made Phone Clone Apps
¬ßIII-B will describe paying-subscriber fraud, in which a
fraudster leverages OEM-made phone clone apps to launch
data clone attacks on non-rooted devices. Phone clone apps
are getting popular in various Android app markets. All of
the top Android phone manufacturers [28] custom their own
phone clone apps, such as Samsung Smart Switch, Huawei
Phone Clone, and Xiaomi Mi Mover. Most of them have
been downloaded more than 100 million times. These OEM-
made phone clone apps have a unique advantage: they have
the privilege to call Android Backup API [29] on the same
OEM phones. Therefore, in addition to contacts, call logs,
photos, and data in external storage, they are able to transfer
app-private data in ‚Äú/data‚Äù partition between the same OEM
phones without rooting devices. For example, Smart Switch
can seamlessly transfer app private data and home layouts
1685between Galaxy devices, and it is similar for other OEM-made
clone apps. This advantage brings users great convenience
when they upgrade their devices: the cloned smartphone just
becomes the replica of the old device, and apps behave exactly
as if they are still on the old device.
D. Android OS Virtualization
We apply Android OS-level virtualization to editing device-
speciÔ¨Åc artifacts. Mobile virtualization means running mul-
tiple separate instances of smartphone environments on the
same physical device. Unlike desktop and server machines,
resource-constrained mobile devices limit the adoption of
hypervisor-based virtualization [30], [31], while OS-level vir-
tualization [32], [33] becomes an acceptable option. Cells [22]
is the Ô¨Årst lightweight OS-level virtualization solution to run
multiple isolated virtual phones on a single Android instance.
In each virtual phone (VP), a user can execute unmodiÔ¨Åed
apps and perform normal smartphone operations. Cells made
most hardware device virtualization in the Linux kernel layer,
and Figure 1 shows an overview of Cells‚Äôs kernel-level virtual-
ization architecture. The VP running in the foreground is dis-
played at any time and always given direct access to hardware
devices . Cells invents a new device namespace mechanism
to support efÔ¨Åcient hardware resource multiplexing, and each
VP is associated with a unique device namespace for
device interaction. To make various hardware devices aware
ofdevice namespaces, Cells virtualizes kernel interfaces in
three ways: 1) create a device driver wrapper; 2) modify a
device subsystem; 3) modify a device driver.
Unfortunately, Cells‚Äôs design lacks Ô¨Çexibility. Many heavily-
modiÔ¨Åed kernel drivers are susceptible to new Android version
updates. Since Android 6.0, Cells‚Äôs virtualization to many
hardware devices has been obsoleted. In addition, it also
lacks device virtualization solutions for Bluetooth, GPS, and
ADB; their artifacts are commonly used to Ô¨Ångerprint different
devices. Even Cells‚Äôs commercial version, Cellrox3, is only
compatible with Android 5.1. Our work bridges the gap in
mainstream Android versions.
III. P AYING -SUBSCRIBER FRAUD &
DEVICE -CONSISTENCY CHECK
In this section, we Ô¨Årst describe the unique beneÔ¨Åt of
exploiting auto-login functions to bypass user authentication.
Next, we introduce a new data-clone attack model: paying-
subscriber fraud. Then, we perform data-clone attacks with
234 most-downloaded apps. Our results show that data-clone
attacks are a real threat to both the app economy and user
privacy, especially when skilled attackers are able to simulate
a Hi-Fi smartphone environment.
A. Data-Clone Attack‚Äôs Advantage
Compared to the case that the attacker can intercept the
user‚Äôs password, the unique beneÔ¨Åt of the data-clone attack is
much stealthier. The reason is that the login process by typing
the user‚Äôs ID and password would trigger the detection of the
login-device number limit on the server side. Many apps only
3Cellrox - Mobile Virtualization Platform: http://www.cellrox.com.You can only use one phone
number for KakaoTalk.
If you are already using this
phone number on another
device, you can no longer use
the KakaoTalk on that device.
Cancel ContinueRe-verification is required as your
device information has changed.
The data stored on your device
will be preserved even if you re-
verify your account
OK
(a) (b)
Figure 3: KakaoTalk‚Äôs warning notiÔ¨Åcations.
allow a single user to log in from one device at a time. This
means the legal user and the attacker cannot be online simul-
taneously by typing the user‚Äôs ID and password. For example,
when an attacker logs in to a messaging app, KakaoTalk, from
a different phone by typing the victim‚Äôs ID and password, the
attacker‚Äôs phone will receive a warning notiÔ¨Åcation as shown
in Figure 3(a). However, our key observation is counting the
number of login devices is not affected by multiple auto-login
attempts from the same device , which leaves a backdoor for us
to break through the login-device number limit. As a result,
the user‚Äôs sensitive data will be in jeopardy without raising
suspicion. If a social messaging app is compromised in this
way, the adversary can not only review chat history in real
time but also impersonate the victim to send messages.
Our demo video (https://youtu.be/cs6LxbDGPXU) shows
such an identity theft example. When the legal user is online,
the attacker cannot log in to KakaoTalk by typing the same
user‚Äôs ID and password. Furthermore, KakaoTalk can detect
the change of a new device. It disables the auto-login after
we copy the data in the directory of ‚Äú/data/data/KakaoTalk/‚Äù
to a new device (see Figure 3(b)). In contrast, we perform a
data-clone attack after we customize VPDroid‚Äôs VP with the
old phone‚Äôs proÔ¨Åles. We Ô¨Ånd the victim and the attacker can
be online at the same time without raising suspicion.
B. Paying-Subscriber Fraud
The subscription-based app economy thrives in mobile
markets, and customers have acclimated to the idea of regular
payments for a better service [19]. Typical examples are
the apps that provide video and music streaming services,
such as Y ouTube, NetÔ¨Çix, Amazon Prime Video, iQiyi, and
Y ouku Video. For a subscription-based app, only a paying
subscriber can enjoy its premium service, and it also enforces
the maximum number of the same user‚Äôs login from different
devices at a time. For example, NetÔ¨Çix‚Äôs premium plan allows
at most four screens that a user can watch on simultaneously.
As counting the number of login devices is typically not
affected by multiple auto-login attempts from the same device,
even with a non-rooted device, a fraudster can use an OEM-
made phone clone app to perform data-clone attacks and
break through the paying-subscriber limit. Figure 2 illustrates
such an example, and eventually, the fraudster can access
Android premium apps in multiple devices without payments.
Although Figure 2 shows a single-user fraud case, once this
attack model is turning into full-Ô¨Çedged, coordinated attacks
1686$WWDFNHU,QVWDOO,QVWDOO
3KRQH$
3KRQH&
6LQJOH8VHU)UDXG
:L)L+RWVSRW
6HQGEDFNXSGDWD 5HFHLYHDQGUHVWRUHGDWD
1HWIOL[$PD]RQ3ULPH9LGHR
..%R[*RRJOH3OD\0XVLF
L4L\L<RXNX7HQFHQW9LGHR
&2(00DGH
3KRQH&ORQH$SS
$XWRPDWLF
ORJLQUHTXHVW
6XFFHVVIXO
$SS6HUYHU
$
3KRQH%
Figure 2: Data-clone attacks distribute auto-login depended data for the paying-subscriber fraud.
in the Android black market, malicious actors can infringe
the revenue model of subscription-based apps, resulting in
tremendous Ô¨Ånancial losses to software vendors. Most of the
zero-day vulnerabilities that we found belong to this category,
and the leading app vendors such as NetÔ¨Çix, Amazon, Xiaomi,
Tencent, and Alibaba, have conÔ¨Årmed our Ô¨Åndings.
C. Experiments with Most-Downloaded Apps
We test data-clone attacks with 234 popular apps from
American and Chinese Android app markets, where have the
largest user base in the world. The selection criteria are: 1)
the app is among the top 300 apps in that market; 2) it
has more than 1 million downloads. After that, we have to
install each app on a real device to test whether it can work
properly. For example, some apps have regional restrictions.
Finally, we obtain 114 top apps from Google Play store
and 120 top apps from Huawei/Xiaomi app markets. Their
distributions are shown in the second column of Table I. One
of them is the subscription-based app, which relies on the
user‚Äôs regular payments to provide a better service. Besides,
it also uses the number of connected clients in their pricing
model. The citation [19] provides more details to advocate the
subscription-based app economy. For the smart home apps,
we also purchase related smart home devices, including one
smart lock, two security cameras, and one smart light bulb, to
test whether we can control them after launching a data-clone
attack.
There are three ways to collect backup data from victim
users for launching a data-clone attack. (1) Like the assump-
tion held by related work [16], [18], attackers either have
physical access to the victim‚Äôs rooted device or the malware
to steal credential data has been installed on the rooted device.
(2) If we assume that the users‚Äô devices are not rooted,
attackers can still exploit phone-clone app vulnerabilities to
intercept private user data. CVE-2019-15843 is such a zero-
day vulnerability we found. We exploit this vulnerability
and perform the MitM attack during data transmission. For
example, when the app sets up a Wi-Fi hotspot to transfer data
between two phones, we can perform ARP spooÔ¨Ång to suc-
cessfully intercept data frames on the WLAN and then launch
a data-clone attack. A concurrent work from ACSAC‚Äô20 [34],
demonstrates this type of vulnerability is popular. (3) As theTable I: The number of successes when performing data-
clone attacks with real devices, Xposed-based sandbox, and
VPDroid, respectively. Xposed-based sandbox and VPDroid
have been conÔ¨Ågured to match the victim phone‚Äôs proÔ¨Åles.
#Apps Real device Xposed VPDroid
Social media 104 65 73 104
Payment 99 39 46 99
Subscription 29 25 27 29
Smart home 2 2 2 2
Sum 234 131 148 234
users who perform the subscription fraud has full control of
the device, they can use the OEM-made phone clone app to
test subscription apps.
The third column of Table I lists the number of successes
when performing data-clone attacks with real devices. We
can automatically log in to 131 out of 234 apps. Table II
shows the examples of these compromised apps, including
prominent apps that have been downloaded for more than
one billion times (e.g., Facebook, WhatsApp, QQ, and Sina
Weibo). The attacks on smart home apps result in a more
severe consequence, because we can remotely control all smart
devices associated with our tested smart home apps. For
example, we are able to unlock the smart lock and turn off
the smart light bulb and security cameras.
D. Device-Consistency Check
For the remaining 103 failed cases, when we run them in
the new device, they exhibit one of the following responses:
1) the app terminates and exits; 2) the app requests the
user to type ID and password again. Many apps also pop
up a new window showing that the app is running on a
different device. Therefore, it is very likely that these apps
have already detected the change of device and thus disabled
the automatic login. To conÔ¨Årm our conjecture, we clone
these apps to an Xposed-based device-attribute editing tool,
XxsqManager [35]. It provides a virtual environment on top
of the Android framework, in which a user can edit device
attributes via API hooking and thus deceive guest apps.
We install XxsqManager in Huawei Honor 8. This tool
provides 65conÔ¨Åguration options, and we edit all of them
as the same proÔ¨Åles with our old phone (Xiaomi Redmi
1687Table II: The successful examples of data-clone attacks with
real devices. Due to the space limit, we only list top apps in
the number of downloads.
Type Apps
Social mediaFacebook, QQ, Instagram, Snapchat,
WhatsApp, Messenger, Tinder, Telegram,
Pinterest, Sina Weibo
PaymentPinduoduo, DiDi, Letgo, iHerb,
OfferUp, Postmark, Shpock,
GoFundMe, Banggood, Lazada
SubscriptionNetÔ¨Çix, Amazon Prime Video, KKBox, Hulu,
BBC News, Y ouku Video, Amazon Music,
iQiyi, Netease Cloud Music
Smart home Mi Home, 360 Smart Camera
Table III: The successful cases that are newly added when
performing data-clone attacks in Xposed-based sandbox.
Type Apps
Social mediaLINE, Microsoft Outlook, Douban, Toutiao,
Baidu Tieba, TikTok, Douyin, Wickr, BIGO LIVE
PaymentBest Buy, NetEase Kaola,
Ctrip, 5miles, Geek, KFC
Subscription TuneIn Radio, Qingting FM
Note 4). For the attack model of paying-subscriber fraud, as
fraudsters own the device in advance, they can run a third-party
device information tool to collect complete device artifact
data. The ‚ÄúXposed‚Äù column of Table I shows the number of
successes when performing data-clone attacks with an Xposed-
based sandbox. Compared to the experiment with real devices,
we have 17 compromised apps that are newly added (see
Table III). Our new experiment conÔ¨Årms that some apps have
already performed some device-consistency checks to secure
their auto-login functions, but their detections can be easily
evaded by the user-level API-hooking mechanism.
However, the app-virtualization technique is not entirely
transparent to guest apps [12]. For example, Xposed‚Äôs hooking
mechanism leaves identiÔ¨Åable Ô¨Ångerprints in package names,
call stack methods, suspicious native methods, and shared
objects loaded into memory [36]. We Ô¨Ånd some cloned apps
such as Alipay and Apple Music can also detect the existence
of Xposed-based sandbox and thus prevent data-clone attacks.
In what follows, we explore OS virtualization to provide a
transparent and customizable virtual environment.
IV . VPD ROID SYSTEM DESIGN
We develop a lightweight Android OS-level virtualization
architecture, VPDroid , to assist apps‚Äô account security testing.
With VPDroid, security analysts are able to conÔ¨Ågure different
device attributes according to a target phone‚Äôs proÔ¨Åles and
then boot up a virtual phone (VP) environment that closely
approximates the target device. Moreover, our solution enables
device-attribute editing operations not to interfere with the host
device‚Äôs normal operations. To deceive the cloned apps into
thinking the smartphone is not changed, VPDroid has to meet
two requirements ( Req1 &Req2 ):1)Req1 : the VP always gets direct access to hardware
devices; this design provides a close-to-native virtual
environment with high performance.
2)Req2 : user-mode apps in the VP are imperceptible to
the change of device; this requires our virtualization and
device-attribute customization functions are invisible to
user-mode apps running in the VP .
VPDroid is built on top of Cells [22], because its foreground
VP design meets Req1 . However, Cells exhibits three major
limitations. 1) Cells fails to meet Req2 : it is not designed to
edit device attributes. 2) Like API-hooking, Cells‚Äôs user-level
device virtualization modiÔ¨Åes the VP‚Äôs application framework
layer, which can be detected by VP‚Äôs apps. 3) Cells‚Äôs kernel-
level device virtualization to many hardware devices are not
compatible with Android 6.0 and later versions anymore. We
improve Cells signiÔ¨Åcantly to achieve our requirements on
mainstream Android versions.
A. Overview
Figure 4 provides an overview of VPDroid‚Äôs system ar-
chitecture. Please note that, as a virtualization framework,
VPDroid can smoothly run Ô¨Åve virtual phones. However, only
the VP running in the foreground can always directly access
all hardware devices, which is indispensable to satisfying both
Req1 and Req2 . Therefore, we maintain one VP in this paper.
The isolated VP runs a stock Android userspace environment.
VPDroid utilizes Linux namespaces as well as the device
namespace introduced by Cells to transparently remap OS
resource identiÔ¨Åers to the VP . The VP has its private device
namespace so that it does not interfere with the host.
We keep Cells‚Äôs kernel-level device virtualization methods
that still work in recent Android versions, including Input (e.g.,
touchscreen and input buttons ) and Sensors (e.g, accelerom-
eter and light sensors). We also keep the custom process,
‚ÄúCellD‚Äù, in the host device‚Äôs root namespace. CellD manages
the starting and switching of VPs, and it also coordinates our
ADB virtualization; ADB is used for copying data to the VP .
Since Android 8.0, Android OS has introduced a new vendor
interface between the Android OS framework and the vendor
implementation [37]. We improve Cells‚Äôs kernel-level device
virtualization methods in the Binder, power management, and
core network resource to be compatible with device changes
in new Android systems. Our key method is to rewrite the
source code of kernel drivers so that they are aware of the
device namespace. Besides, we add GPS virtualization by
rewriting ‚Äú/dev/gss‚Äù driver to support multiple connections.
VPDroid system development is heavy in engineering. In
the next two sections, we present our two signiÔ¨Åcant im-
provements to Cells. First, we design a new user-level device
virtualization solution with better portability and transparency
than Cells (see ¬ßV). Second, VPDroid can customize the VP‚Äôs
device attributes, but this function is not offered by Cells (see
¬ßVI).
V. N EWUSER-LEVEL DEVICE VIRTUALIZA TION
For Cells‚Äôs obsolete device virtualization solutions, rewrit-
ing every kernel driver is error-prone and complicated. Es-
pecially, some hardware vendors provide proprietary software
168888VHUOHYHO'HYLFH
9LUWXDOL]DWLRQFHOO6HUYLFH
&HOO'
%LQGHU
 ,QSXW *36
1DPHVSDFHSLGXWVPQWQHWXVHULSF GHYLFH
/LQX[.HUQHO1HWZRUN1HWZRUN
3RZHU
%OXHWRRWK7HOHSKRQ\
*36'LVSOD\	
*38,QSXW
%LQGHU9LUWXDOL]HG
'HYLFHV
&*URXS FKURRW%LQGHU6HUYLFH
6KDULQJ6XUIDFH)OLQJHU :LIL6HUYLFH
'HYLFH1DPHVSDFH
3UR[\%OXHWRRWK
6HUYLFH 5L/'3UR[\
,3&+RVW5RRW1DPHVSDFH
%OXHWRRWK
:L)L'LVSOD\ 5L/'
‡≤π3RZHU0DQDJHU
6HUYLFH6HUYLFH0DQDJHU
,QSXW0DQDJHU/RFDWLRQ0DQDJHU
6HUYLFH1HW6HUYLFH&HOO‡≤¨VYLUWXDOL]DWLRQ
UHXVHGE\93'URLG
.HUQHO/HYHO'HYLFH9LUWXDOL]DWLRQ&HOO‡≤¨VYLUWXDOL]DWLRQ
PRGLILHGE\93'URLG
1HZYLUWXDOL]DWLRQ
DGGHGE\93'URLG
6HQVRUV
$'%6HQVRUV.HUQHOOHYHO'HYLFH
9LUWXDOL]DWLRQ
)LOHV\VWHP$XGLR
*389LUWXDO3KRQH
Figure 4: VPDroid‚Äôs device virtualization architecture (kernel-level & user-level) and our changes to Cells.
stacks that are completely closed source. Without hardware
vendor‚Äôs support, it would be difÔ¨Åcult, if not impossible, to vir-
tualize them in the kernel. VPDroid‚Äôs user-level virtualization
offers a Ô¨Çexible and portable alternative without leaving any
in-guest virtualization component . Our mechanism contains
two methods to virtualize different devices.
Binder Service Sharing. For the system services that are
registered in ServiceManager (e.g., WiÔ¨ÅService), we develop
a new way to virtualize them. Binder is the inter-process com-
munication (IPC) mechanism in Android. The Binder driver
is a custom pseudo driver with no corresponding physical
device. We Ô¨Årst modify the Binder-driver data structure (e.g.,
context_mgr_node ,procs , and dead_nodes ) to en-
sure that the VP has its own Binder-driver data structure. In ad-
dition, we create a new speciÔ¨Åc handler in Binder‚Äôs data struc-
ture and make it point to the host‚Äôs context_mgr_node .
Ascontext_mgr_node is associated with ServiceManager,
with this handler, the VP can access the host phone‚Äôs Service-
Manager node. Therefore, this mechanism allows a service
process in the VP to share the corresponding service in the
host system. Furthermore, we leverage SELinux technology
to enforce which services in the host system can be shared by
the VP . In VPDroid, WiFi conÔ¨Åguration are virtualized in this
style.
Device Namespace Proxy. For the anonymous services that
are not registered in ServiceManager, as the kernel does not
have their binder_node andbinder_ref structures, we
cannot apply binder service sharing. Instead, we virtualize
them by creating a new device namespace proxy in the hostuserspace only. This proxy communicates the VP service
through Binder service sharing or socket. It distinguishes
the VP‚Äôs request from the host‚Äôs request by their associ-
ateddevice namespaces and interacts with kernel drivers
to respond to the VP‚Äôs request. In VPDroid, telephone are
virtualized using this method.
Next, we use WiFi conÔ¨Åguration and telephone as examples
to present our new user-level device virtualization mechanism.
A. Binder Service Sharing: WiFi ConÔ¨Åguration
WiFi conÔ¨Åguration and status notiÔ¨Åcations occur in the
userspace. ‚Äúwpa supplicant‚Äù is a user-level library that con-
tains wireless network service code ( 0in Figure 5). Cells
replaces ‚Äúwpa supplicant‚Äù inside the VP with a WiFi proxy,
which forwards all conÔ¨Åguration requests from the VP to
the host‚Äôs ‚Äúwpa supplicant‚Äù. In contrast, we leverage our
proposed Binder service sharing to achieve the same goal,
but leaving no change in the VP‚Äôs userspace. In the Android
system, WiÔ¨ÅService calls the library of ‚Äúwpa supplicant‚Äù to
detect WiFi connections, and such information is sent through
NetworkAgent to ConnectivityService, which answers app
queries about the state of network connectivity.
We use the Binder service sharing mechanism to share
WiÔ¨ÅService between the VP and the host system. The blue
two-way line in Figure 5 represents the workÔ¨Çow to answer a
WiFi status query from the VP‚Äôs app ( 1). Besides, we create
a new NetworkAgent in the host system and bind it to the VP‚Äôs
device namespace. As shown in Figure 5‚Äôs red line ( 2), to
automatically forward network status notiÔ¨Åcations to the VP ,
1689+RVW8VHUVSDFH
/LQX[.HUQHO+RVW%LQGHU:LIL6HUYLFH1HWZRUN$JHQW
931HWZRUN$JHQW
ZSDBVXSSOLFDQW:L)L-DYD1DWLYH
,QWHUIDFH
:3$6HUYHU	
&OLHQW
%LQGHUVHUYLFHVKDULQJ938VHUVSDFH
&RQQHFWLYLW\6HUYLFH:LIL0DQDJHU$SS
93%LQGHU
7KHDSSLQ93UHFHLYHV
QHWZRUNVWDWXV
QRWLILFDWLRQV7KHZRUNIORZWRDQVZHUD
:L)LVWDWXVTXHU\IURP
WKHDSSLQ931 1
1 22
2 0
Figure 5: VPDroid leverages binder service sharing mecha-
nism to virtualize wireless conÔ¨Åguration management.
we also use the Binder service sharing mechanism to transfer
the new NetworkAgent to the VP‚Äôs ConnectivityService. Fi-
nally, the VP succeeds in receiving the status notiÔ¨Åcations of
WiFi connectivity.
B. Device Namespace Proxy: Telephony
Figure 6 (a) shows the standard Android Radio Interface
Layer. As smartphone vendors customize their own proprietary
radio stack, Cells adopts a user-level device namespace proxy
to provide a separate telephony functionality for a VP . A VP
has its own proxy Radio Interface Layer (RIL) library. The
RIL proxy is loaded by Radio Interface Layer Daemon (RilD)
and connects to CellD running in the host‚Äôs root namespace,
and CellD, in turn, communicates the hardware vendor library
to respond to the VP‚Äôs requests. However, the RIL proxy is
visible to VP‚Äôs apps, which does not meet our Req2 .
As shown in Figure 6(b), we implement a socket-interface
based proxy scheme only in the host userspace, and it does not
require the assistance of CellD. In the host‚Äôs Radio Interface
Layer, we create a RiLD proxy between the communication
Ô¨Çow of Android telephony Java libraries (RIL Java) and RilD.
Then we create another two standard Unix Domain sockets
in the proxy. One socket connects to the RIL Java of the VP ,
and the other one connects to the RIL Java of the host system.
The RIL Java in the VP communicates with the host system‚Äôs
proxy, and the proxy passes the communication data (e.g.,
dial request and SIM) to the host system‚Äôs RilD. In turn, the
RilD proxy passes the VP-related arguments (e.g., call ring
and signal strength) to the VP‚Äôs RIL Java over a socket.
VI. C USTOMIZE THE VP‚Äô SDEVICE ATTRIBUTES
Based on the new Android OS-level virtualization frame-
work, we go one step further to customize the VP‚Äôs device
attributes. Figure 7 shows the workÔ¨Çow. VPDroid users pro-
vide a conÔ¨Åguration Ô¨Åle ‚Äúbuild.VPDroid.prop‚Äù in advance,
which stores device-speciÔ¨Åc attributes in the form of key-value5,/-DYD
9HQGRU5,/5LO'+RVW8VHUVSDFH
'ULYHUV333
%DVHEDQG
/LQX[.HUQHO'ULYHUV333
/LQX[.HUQHO%DVHEDQG5,/-DYD+RVW8VHUVSDFH
5LO'
9HQGRU5,/
D$QGURLG
5DGLR,QWHUIDFH/D\HUE93'URLG5DGLR,QWHUIDFH/D\HU938VHUVSDFH
5L/'3UR[\
5,/-DYD
Figure 6: VPDroid virtualizes telephony by creating a device
namespace proxy in the host userspace only.
pairs. We classify these key-value pairs into three categories:
Android system properties, user-level-virtualized device prop-
erties, and kernel-level-virtualized device properties. Each
category has a different customization method. Besides, we
incorporate multiple namespaces to isolate our customization.
Android System Properties. Android system properties,
stored in the init process‚Äôs shared memory, describe the conÔ¨Åg-
uration information of the smartphone, such as brand, model,
serial number, IMEI, and Android ID. These const values have
nothing to do with our device virtualization. Other processes
enquire about Android system properties at run time by calling
‚Äúproperty get‚Äù, an API for native code to read the data in the
shared memory from other processes. When booting up the
VP , we enforce the VP‚Äôs init process to load the customized
Android system properties from ‚Äúbuild.VPDroid.prop‚Äù into the
VP‚Äôs shared memory space ( 1in Figure 7).
User-Level and Kernel-Level Customization. The cus-
tomized data for both user-level-virtualized and kernel-level-
virtualized devices are loaded into the host init process‚Äôs
shared memory ( 2). We use the IPC namespace for the host
and VP shared memory isolation ( 3). Our customization
functions are located at the places where we just Ô¨Ånish
user-level device virtualization ( 4) or kernel-level device
virtualization ( 6). All of the customization functions work in
a similar style. They Ô¨Årst determine whether the current query
request is from the VP or the host by checking the associated
device namespace. For a user-level customization function,
if the query is from the VP , it calls ‚Äúproperty get‚Äù to get
the customized data from the host‚Äôs shared memory ( 5) and
then returns the custom data to the VP . However, for a kernel-
level customization function, the customized data loaded into
the init process have no privilege to enter the kernel space.
Therefore, we create a new system call to copy data from the
userspace to the kernel space ( 7).
The Advantages of VPDroid Customization. Compared
with existing Android device-attribute editing tools [27], [35],
our customization solution revels distinct advantages. First ,
16906KDUHG
0HPRU\8VHUOHYHOYLUWXDOL]HG
'HYLFH3URSHUWLHV+RVWLQLWSURFHVV
2
5
.HUQHOOHYHOYLUWXDOL]HG
'HYLFH3URSHUWLHV
SURSHUW\BJHW
&XVWRPL]HG6\VFDOO71
,3&
1DPHVSDFH+RVW0HPRU\EXLOG93'URLGSURS
<HV <HV3930HPRU\
$QGURLG6\VWHP
3URSHUWLHV%LQGHU6HUYLFH6KDULQJ
	
3UR[\3URFHVVHV
931DPHVSDFH"'LVSOD\	
*38
&XVWRPL]DWLRQ)XQFWLRQV%OXHWRRWK
‡≤π+RVW8VHUVSDFH.HUQHO'ULYHUV
931DPHVSDFH"%DWWHU\
&XVWRPL]DWLRQ)XQFWLRQV*36.HUQHO
9HUVLRQ.HUQHO6SDFH93'URLG'HYLFH9LUWXDOL]DWLRQ
/RFDWLRQ
7HOHSKRQ\SURFPHPLQIR
	
SURFFSXLQIR
4 66\VWHP3URSHUWLHV9LUWXDOL]HG'HYLFH3URSHUWLHV
&HOO6LWH
Figure 7: VPDroid‚Äôs workÔ¨Çow of customizing device-speciÔ¨Åc attributes.
00.20.40.60.811.2
Linpack Quadr. 2D 3Dmark Quadr. I/O SunSpider NetworkNative Phone VP
(a) Normalized Nexus 6p-1 results00.20.40.60.811.2
Linpack Quadr. 2D 3Dmark Quadr. I/O SunSpider NetworkNative Phone VP
(b) Normalized Nexus 6p-2 results00.20.40.60.811.2
Linpack Quadr. 2D 3Dmark Quadr.
I/OSunSpider NetworkNa∆üve Phone VP
(c) Normalized Nexus 6p-1 + music results
00.20.40.60.811.2
Linpack Quadr. 2D 3Dmark Quadr.
I/OSunSpider NetworkNa∆üve Phone VP
(d) Normalized Nexus 6p-2 + music results01282563845126407688961,024
No APPs Browser Browser
+EmailBrowser
+Email
+CalendƒÇrNa∆üve Phone VP
(e) Nexus 6p-1 memory usage in MB01282563845126407688961024
No APPs Browser Browser
+EmailBrowser
+Email
+CalendƒÇrNa∆üve Phone VP
(f) Nexus 6p-2 memory usage in MB
Figure 8: VPDroid‚Äôs performance measurements. ‚ÄúQuadr.‚Äù is short for ‚ÄúQuadrant‚Äù
all of our customization functions do not rely on any user-
level API hooking mechanism, and they are executed outside
of the VP‚Äôs runtime environment. This means our device
customization is invisible to VP‚Äôs user-mode apps. Although
our user-level device virtualization allows the VP‚Äôs process to
share certain services in the host system, with the device
namespace isolation, a user-mode app running in the VP is
still unaware of device-speciÔ¨Åc differences. Second , our VP‚Äôs
customization does not interfere with normal operations on
the host device. System modiÔ¨Åcations without leveraging OS-
level virtualization lack Ô¨Çexibility and compatibility. Besides,
they are very difÔ¨Åcult to achieve the same transparent and
stealthy capability as VPDroid, as blindly changing return
values of APIs/syscalls is likely to cause system crashes or
exceptions (e.g., Bluetooth system services keep restarting).
Due to the multiplexing of hardware devices, VPDroid avoids
incompatibility issues by decoupling device-attribute editing
operations from normal operations on the host device.VPDroid now can support customizing 101 device con-
Ô¨Åguration options, which span a broad spectrum of device
attributes. We collect these options from existing work on
the Android device artifact detection. To the best of our
knowledge, VPDroid offers the most comprehensive Android
device-attribute editing options so far.
VII. VPD ROID EV ALUA TION
The VP images are created on a PC and downloaded to
the host device via USB. We provide a control center app for
VPDroid users to efÔ¨Åciently switch between the VP and the
host system. To start a new VP to simulate a different device,
a user takes the following three steps: 1) exiting the original
VP; 2) updating and replacing a new ‚Äúbuild.VPDroid.prop‚Äù
conÔ¨Åguration Ô¨Åle; 3) stating a new VP via the control center
app. This section Ô¨Årst provides performance measurements
to show that VPDroid reveals native performance. In our
second experiment, we use the data-clone attack as a case
1691study to evaluate VPDroid‚Äôs capability on device-attribute
customization. Our results show that VPDroid substantially
increases the success rate of the data-clone attack.
A. Performance Measurements
We measure runtime overhead and memory usage using two
Google Nexus 6P phones that are different in CPU model
and ROM size: Nexus 6p-1 (ARM Cortex-A53, Adreno 430
GPU, 3G RAM, and 32G ROM), and Nexus 6p-2 (ARM
Cortex-A57, Adreno 430 GPU, 3G RAM, and 64G ROM).
We follow similar experimental settings with Cells‚Äôs paper in
SOSP‚Äô11 [22]. Our runtime overhead measurement contains
two scenarios. The Ô¨Årst one is running a set of benchmark apps
on VPDroid‚Äôs VP and a native phone, respectively. The second
one is running the same benchmark apps on the VP and the na-
tive phone, but simultaneously with an additional background
music player workload. All results are normalized against the
performance of running the same benchmark apps on the latest
manufacturer stock image available for Google Nexus 6P , but
without the background workload. Each benchmark app is
designed to stress some aspect of the system performance: Lin-
pack (v1.1) for CPU; Quadrant advanced edition (v2.1.1) for
2D graphics and Ô¨Åle I/O; 3DMark (v2.0.4646) for 3D graphics;
SunSpider (v1.0.2) for web browsing; and networking using
BusyBox wget (v1.21.1) to download a single 409M video Ô¨Åle
through a PC‚Äôs Wi-Fi hotspot.
Figure 8 shows the normalized runtime overhead and mem-
ory usage on two Nexus 6P phones. Compared to Cells 1-
VP‚Äôs data [22], VPDroid reveals the same level of variability
in measurement results, and it is even better than Cells in
Quadrant I/O, SunSpider, and Network results from 5% to
9%. Cells‚Äôs performance data were obtained using Nexus 1
and Nexus S. We admit that the hardware upgrade caused
by Nexus 6P also favorably impacts our results. The de-
viations between ‚ÄúVP‚Äù and ‚ÄúNative Phone‚Äù in Figure 8(a)
‚àºFigure 8(d) represent the additional overhead caused by
VPDroid‚Äôs device virtualization. The negligible deviations
indicate no user-noticeable performance difference between
running in VPDroid and running natively on the phone. The
major difference from Cells is memory usage. For example,
after booting up 1-VP with no apps running, Cells‚Äôs memory
usage is 128 MB, but this number increases to 512 MB for
VPDroid. As would be expected, the Android OS‚Äôs size is
also bloating. As shown in Figure 8(e) and Figure 8(f), the
memory usage in the VP is less than the native phone in all
workload cases. The reason is due to the lightweight OS-level
virtualization, the memory consumed by kernel services only
occurs at the host device.
B. Virtualization-Assisted Data-Clone Attack
We repeat our data-clone attacks with most-downloaded
apps (see ¬ßIII-C) in VPDroid. In particular, we take Google
Nexus 6P-2 as the host machine and conÔ¨Ågure the VP environ-
ment as Xiaomi Redmi Note 4, Redmi Note 4x, Huawei Honor
6x, Honor 8, and Google Nexus 6P-1, respectively. These Ô¨Åve
VP environments represent Ô¨Åve victim devices, and we provide
Ô¨Åve different device-attribute conÔ¨Åguration Ô¨Åles for VPDroid
to load. In spite of the diversity, we achieve the same resultsTable IV: Zero-day vulnerabilities that we found. The third
column shows the vulnerability ID or the vendor‚Äôs conÔ¨Årma-
tion time. The app‚Äôs name in bold represents this app takes the
device-consistency check to protect its auto-login function.
App V endor Vul. ID or Conf. Time
NetÔ¨Çix NetÔ¨Çix 10/12/2019
Prime Video Amazon 11/16/2019
Kugou Music Tencent VULBOX-2019-0221059
Tencent Video Tencent 8/18/2019
iQiyi iQiyi 8/18/2019
Y ouku Video Alibaba 8/18/2019
WPS OfÔ¨Åce Kingsoft 10/16/2019
Zhihu Zhihu CNVD-2019-42028
University MOOC NetEase 9/29/2019
Cloud Classroom NetEase 9/23/2019
Unipus Unipus CNVD-2019-42030
DragonÔ¨Çy FM DragonÔ¨Çy CNVD-2019-42031
LiuLiShuo LAIX CNVD-2019-42032
CAD Quick Look Glodon CNVD-2019-42034
VivaVideo Quwei CNVD-2019-42033
Yizhibo Yizhibo CNVD-2019-42029
Smart Camera Qihoo 360 1/20/2020
Mi Home Xiaomi 3/30/2019
Mi Mover Xiaomi CVE-2019-15843
for all cases. The last column of Table I shows the success
number of data-clone attacks in VPDroid: we can compromise
all of the 234 most popular apps‚Äô accounts. Compared with
the attacks on a real device, VPDroid wins by additional 103
apps; among them, 86apps can detect Xposed-based sandbox
but fail to detect VPDroid. Note that our attacks failed at Ô¨Årst
for some apps that rely on Android ‚ÄúAccountManager‚Äù APIs
to manage the auto-login function (e.g., Y outube, Google Play,
Twitter, and Skype). The reason is ‚ÄúAccountManager‚Äù stores
auto-login depended data under the directory of ‚Äú/data/sys-
tem xx/‚Äù rather than ‚Äú/data/data/[app name]/‚Äù. After we copy
the ‚Äú/data/system xx/‚Äù folder to the virtual phone in our
second try-out, our data-clone attacks succeeded.
To make sure no app can detect the change of device in
VPDroid, we perform another comparative experiment with an
OEM-made backup app. It has the privilege to call Android
Backup API [29] on the same OEM phones, so it can backup
and restore user private data in ‚Äú/data‚Äù partition. We Ô¨Årst use
this OEM-made backup app to backup our tested apps and
then restore them. Next, we keep a record of the apps whose
auto-login functions still work after backup-restore. We treat
the effect of this experiment as launching a data-clone attack
on the same device. However, if one of these apps fails to
automatically log in after we clone its auto-login depended
data to the VP , it means this app Ô¨Ånds VPDroid‚Äôs environment
is different from the original device. However, we did not
Ô¨Ånd such a counterexample. This conÔ¨Årms that our device
virtualization and customization are transparent to cloned apps.
Vendor Reaction . Table IV lists the zero-day vulnerabilities
we have identiÔ¨Åed. We Ô¨Ånd that Chinese vendors take our
Ô¨Åndings more seriously than American vendors. For example,
NetÔ¨Çix conÔ¨Årms our vulnerability Ô¨Ånding, but they treat it
as a ‚ÄúSingle-User Fraud‚Äù threat. We conÔ¨Årm that with the
latest NetÔ¨Çix version (7.68.4), our data-clone attack without
VPDroid still succeeds. By contrast, Chinese vendors such
as Alibaba, Tencent, and iQiyi have labeled our Ô¨Åndings as
high/middle-severity vulnerabilities. We speculate that Chinese
1692vendors are more vulnerable to paying-subscriber fraud. For
example, iQiyi, an online video app with more than 100
million users, has labeled our report as a high-severity vulner-
ability and added device-consistency checks in the new release
version. However, we have evaluated the latest version of iQiyi
in VPDroid and found that, VPDroid can still bypass the newly
added device-consistency checks.
VIII. D ISCUSSION
The most fundamental method against data-clone attacks
is that a mobile app never stores user credential data in local
Ô¨Åles. However, this strategy, at the cost of sacriÔ¨Åcing usability,
only works for critical apps that do not require frequent user
interactions. Another direction is to leverage a Trusted Exe-
cution Environment (e.g., ARM TrustZone) to encrypt/decrypt
user credential data before use. As the decryption key is stored
in the TrustZone environment, data-clone attacks cannot copy
the decryption key to another device together with encrypted
user credential data, and therefore the server will fail to verify
the login credentials. The recent papers, TruApp [38] and IM-
Visor [39] explore the feasibility of protecting app integrity
and sensitive data with TrustZone, and Rubinov et al.‚Äôs work
partitions a critical app automatically for TrustZone [40].
A natural response to breaking through the login-device
number limit is to monitor concurrent sessions at the app
server side. Unfortunately, the variable nature of mobile de-
vices (e.g., the switch of WiFi hotspot and cellular data) makes
it difÔ¨Åcult to determine an adequate number of concurrent
sessions. The previous work [17] has pointed out that, although
many apps do not permit duplicate logins from different
devices, they do allow multiple session requests from the same
device ID. Our evaluation also conÔ¨Årms that most apps allow
maintaining two or more connections per user. As the login
from VPDroid shows a different IP address from the victim‚Äôs
IP , a possible countermeasure is to detect multiple concurrent
IPs at the server side. However, this strategy cannot completely
thwart data-clone apps. For quite a few apps, such as Facebook
and the smart home apps we tested, they do allow multiple
logins from different devices.
We do not assume that detecting the presence of VPDroid
is strictly impossible, but it can prohibitively increase the cost.
If an app in the VP has the root privilege, it can Ô¨Ånd out the
footprint of our user-level device virtualization. For example,
VP‚Äôs telephony Java libraries do not interact with VP‚Äôs RilD.
The auto-login function could check the consistency of some
obscure device properties that are not covered by us, and
Ô¨Ånding all of them is an open problem.
IX. C ONCLUSION
In this paper, we characterize, research, and evaluate
the data-clone attack and its client-side countermeasure‚Äî
device-consistency check. Our technical contribution is to
develop a transparent device-attribute customization platform
via Android OS-level virtualization. Our evaluation with most-
downloaded apps demonstrates that the data-clone attack is an
imminent threat, leading to great losses to the app economy
and user privacy. We wish our study and open-source VPDroidhelp researchers redesign apps‚Äô auto-login functions and eval-
uate the device-artifact detection capability.
ACKNOWLEDGMENTS
We sincerely thank ICSE 2021 anonymous reviewers for
their insightful and helpful comments. This research was
supported in part by the National Natural Science Foundation
of China (U1636107, 61972297) and the National Science
Foundation (NSF) under grant CNS-1850434.
REFERENCES
[1] John Callaham. The history of Android OS: its name,origin and more.
https://www.androidauthority.com/history-android-os-name-789433/,
August 2019.
[2] Sascha Segan. Fastest Mobile Networks 2019. https://www.pcmag.com/
Fastest-Mobile-Networks, June 2019.
[3] Monica S. Lam. Omlet: A Revolution against Big-Brother Social
Networks (Invited Talk). In Proceedings of the 22nd ACM SIG-
SOFT International Symposium on F oundations of Software Engineering
(FSE‚Äô14) , 2014.
[4] Anthony Canino, Y u David Liu, and Hidehiko Masuhara. Stochastic
Energy Optimization for Mobile GPS Applications. In Proceedings of
the 2018 26th ACM Joint Meeting on European Software Engineering
Conference and Symposium on the F oundations of Software Engineering
(ESEC/FSE‚Äô18) , 2018.
[5] Eric Ruiz, Richard Avelar, and Xiaoyin Wang. Protecting Remote Con-
trolling Apps of Smart-Home-Oriented IOT Devices. In Proceedings of
the 40th International Conference on Software Engineering: Companion
Proceeedings (ICSE‚Äô18) , 2018.
[6] Mark Sherman. An Introduction to Mobile Payments: Market Drivers,
Applications, and Inhibitors. In Proceedings of the 1st International
Conference on Mobile Software Engineering and Systems , 2014.
[7] V erizon Wireless. 2019 Data Breach Investigations Report. https://
enterprise.verizon.com/resources/reports/dbir/, June 2019.
[8] Stephan Huber, Siegfried Rasthofer, and Steven Arzt. Extracting All
Y our Secrets: Vulnerabilities in Android Password Managers. Hack-
InTheBox 2017, 2017.
[9] Tamjid Al Rahat, Y u Feng, and Y uan Tian. OAuthLint: An Empirical
Study on OAuth Bugs in Android Applications. In Proceedings of
the 34th IEEE/ACM International Conference on Automated Software
Engineering (ASE‚Äô19) , 2019.
[10] Nethanel Gelernter, Senia Kalma, Bar Magnezi, and Hen Porcilan.
The Password Reset MitM Attack. In Proceedings of the 38th IEEE
Symposium on Security and Privacy (S&P‚Äô17) , 2017.
[11] Dong Wang, Jiang Ming, Ting Chen, Xiaosong Zhang, and Chao Wang.
Cracking IoT Device User Account via Brute-force Attack to SMS
Authentication Code. In Proceedings of the 1st Workshop on Radical
and Experiential Security (RESEC‚Äô18) , 2018.
[12] Luman Shi, Jianming Fu, Zhengwei Guo, and Jiang Ming. ‚ÄúJekyll and
Hyde‚Äù is Risky: Shared-Everything Threat Mitigation in Dual-Instance
Apps. In Proceedings of the 17th ACM International Conference on
Mobile Systems, Applications, and Services (MobiSys‚Äô19) , 2019.
[13] Lei Zhang, Zhemin Yang, Y uyu He, Mingqi Li, Sen Yang, Min Yang,
Y uan Zhang, and Zhiyun Qian. App in the Middle: Demystify Applica-
tion Virtualization in Android and its Security Threats. In Proceedings
of the 2019 ACM on Measurement and Analysis of Computing Systems
(SIGMETRICS‚Äô19) , 2019.
[14] Deshun Dai, Ruixuan Li, Junwei Tang, Ali Davanian, and Heng Yin.
Parallel Space Traveling: A Security Analysis of App-Level Virtualiza-
tion in Android. In Proceedings of the 25th ACM Symposium on Access
Control Models and Technologies (SACMAT‚Äô20) , 2020.
[15] I Luk Kim, Y unhui Zheng, Hogun Park, Weihang Wang, Wei Y ou,
Y ousra Aafer, and Xiangyu Zhang. Finding Client-side Business Flow
Tampering Vulnerabilities. In Proceedings of the 42nd International
Conference on Software Engineering (ICSE‚Äô20) , 2020.
[16] Junsung Cho, Dayeon Kim, and Hyoungshick Kim. User Credential
Cloning Attacks in Android Applications: Exploiting Automatic Login
on Android Apps and Mitigating Strategies. IEEE Consumer Electronics
Magazine , 7(3), 2018.
[17] Jongwon Choi adn Haehyun Cho and Jeong Hyun Yi. Personal
Information Leaks with Automatic Login in Mobile Social Network
Services. Entropy , 17(6), 2015.
1693[18] Suwan Park, Changho Seo, and Jeong Hyun Yi. Cyber Threats To
Mobile Messenger Apps From Identity Cloning. Intelligent Automation
and Soft Computing , 22(3), 2016.
[19] Richard Harris. The subscription based app model is
working and here‚Äôs proof. https://appdevelopermagazine.com/
the-subscription-based-app-model-is-working-and-here‚Äôs-proof/,
November 2018.
[20] iStarsoft. Top Three Phone Clone App To Copy Phone Data
in 2019. https://www.android-data-recovery.org/phone-clone-app.html,
June 2019.
[21] Xposed Module Repository. https://repo.xposed.info/, [online].
[22] Jeremy Andrus, Christoffer Dall, Alexander V an‚Äôt Hof, Oren Laadan,
and Jason Nieh. Cells: A Virtual Mobile Smartphone Architecture.
InProceedings of the 23rd ACM Symposium on Operating Systems
Principles (SOSP‚Äô11) , 2011.
[23] Android Developers. Data and Ô¨Åle storage overview. https://developer.
android.com/guide/topics/data/data-storage, [online].
[24] Cyrus Lee. Daily active users for WeChat ex-
ceeds 1 billion. https://www.zdnet.com/article/
daily-active-user-of-messaging-app-wechat-exceeds-1-billion/, January
2019.
[25] NuData Security. Rooted Devices: It‚Äôs Not the Device
That‚Äôs the Problem. https://nudatasecurity.com/resources/blog/
rooted-devices-not-device-thats-problem/, January 2017.
[26] Android. Android Security & Privacy 2018 Year In Re-
view. https://source.android.com/security/reports/Google Android
Security 2018 Report Final.pdf, March 2019.
[27] Antonio Bianchi, Eric Gustafson, Yanick Fratantonio, Christopher
Kruegel, and Giovanni Vigna. Exploitation and Mitigation of Authen-
tication Schemes Based on Device-Public Information. In Proceedings
of the 33rd Annual Computer Security Applications Conference (AC-
SAC‚Äô17) , 2017.
[28] AppBrain. Top Android phone manufacturers. https://www.appbrain.
com/stats/top-manufacturers, January 2020.
[29] Android Developers. Data backup overview. https://developer.android.
google.cn/guide/topics/data/backup.html, [online].
[30] Ken Barr, Prashanth Bungale, Stephen Deasy, Viktor Gyuris, Perry
Hung, Craig Newell, Harvey Tuch, and Bruno Zoppis. The VMware
Mobile Virtualization Platform: Is That a Hypervisor in Y our Pocket?
ACM SIGOPS Operating Systems Review , 44(4), 2010.[31] Christoffer Dall and Jason Nieh. KVM/ARM: The Design and Imple-
mentation of the Linux ARM Hypervisor. In Proceedings of the 19th
International Conference on Architectural Support for Programming
Languages and Operating Systems (ASPLOS‚Äô14) , 2014.
[32] Stephen Soltesz, Herbert P ¬®otzl, Marc E. Fiuczynski, Andy Bavier, and
Larry Peterson. Container-Based Operating System Virtualization: A
Scalable, High-Performance Alternative to Hypervisors. In Proceedings
of the 2nd ACM SIGOPS/EuroSys European Conference on Computer
Systems (EuroSys07) , 2007.
[33] Wes Felter, Alexandre Ferreira, Ram Rajamony, and Juan Rubio. An
Updated Performance Comparison of Virtual Machines and Linux Con-
tainers. In Proceedings of the 2015 IEEE International Symposium on
Performance Analysis of Systems and Software (ISPASS‚Äô15) , 2015.
[34] Siqi Ma, Hehao Li, Wenbo Yang, Juanru Li, Surya Nepal, and Elisa
Bertino. CertiÔ¨Åed Copy? Understanding Security Risks of Wi-Fi Hotspot
based Android Data Clone Services. In Proceedings of the 36th Annual
Computer Security Applications Conference (ACSAC ‚Äô20) , 2020.
[35] XxsqManage. The Best Tool to Change Android Phone‚Äôs ConÔ¨Åguration.
http://www.javaer.xyz/XxsqManager/html/index.html, 2019.
[36] Aethaellyn. Detection of Xposed Framework. https://programmer.group/
detection-of-xposed-framework.html, April 2019.
[37] Iliyan Malchev. Here comes Treble: A modular base for
Android. https://android-developers.googleblog.com/2017/05/
here-comes-treble-modular-base-for.html, May 2017.
[38] Sileshi Demesie Yalew, Pedro Mendonca, Gerald Q. Maguire Jr., Seif
Haridi, and Miguel Correia. TruApp: A TrustZone-based Authenticity
Detection Service for Mobile Apps. In Proceedings of the 13th
IEEE International Conference on Wireless and Mobile Computing,
Networking and Communications (WiMob‚Äô17) , 2017.
[39] Chen Tian, Yazhe Wang, Peng Liu, Qihui Zhou, Chengyi Zhang, and
Zhen Xu. IM-Visor: A Pre-IME Guard to Prevent IME Apps from
Stealing Sensitive Keystrokes Using TrustZone. In Proceedings of
the 47th Annual IEEE/IFIP International Conference on Dependable
Systems and Networks (DSN‚Äô16) , 2017.
[40] Konstantin Rubinov, Lucia Rosculete, Tulika Mitra, and Abhik Roy-
choudhury. Automated Partitioning of Android Applications for Trusted
Execution Environments. In Proceedings of the 38th International
Conference on Software Engineering (ICSE‚Äô16) , 2016.
1694