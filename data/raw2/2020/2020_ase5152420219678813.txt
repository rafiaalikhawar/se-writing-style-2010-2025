RULF: Rust Library Fuzzing via API Dependency
Graph Traversal
Jianfeng Jiang‚àó‚Ä†, Hui Xu‚àóY angfan Zhou‚àó‚Ä†
‚àóSchool of Computer Science, Fudan University, Shanghai, China.
‚Ä†Shanghai Key Laboratory of Intelligent Information Processing, Shanghai, China.
Email:{jfjiang19, xuh, zyf}@fudan.edu.cn
Abstract ‚ÄîRobustness is a key concern for Rust library devel-
opment because Rust promises no risks of undeÔ¨Åned behaviors
if developers use safe APIs only. Fuzzing is a practical approachfor examining the robustness of programs. However, existingfuzzing tools are not directly applicable to library APIs dueto the absence of fuzz targets. It mainly relies on humanefforts to design fuzz targets case by case which is labor-intensive. To address this problem, this paper proposes a novelautomated fuzz target generation approach for fuzzing Rustlibraries via API dependency graph traversal. We identify severalessential requirements for library fuzzing, including validity andeffectiveness of fuzz targets, high API coverage, and efÔ¨Åciency.To meet these requirements, we Ô¨Årst employ breadth-Ô¨Årst searchwith pruning to Ô¨Ånd API sequences under a length threshold, thenwe backward search longer sequences for uncovered APIs, andÔ¨Ånally we optimize the sequence set as a set covering problem.We implement our fuzz target generator and conduct fuzzingexperiments with AFL++ on several real-world popular Rustprojects. Our tool Ô¨Ånally generates 7 to 118 fuzz targets for eachlibrary with API coverage up to 0.92. We exercise each targetwith a threshold of 24 hours and Ô¨Ånd 30 previously-unknownbugs from seven libraries.
Index T erms‚ÄîFuzzing, Program Synthesis, Rust
I. I NTRODUCTION
Rust is an emerging programming language that promotes
memory-safety features while not sacriÔ¨Åcing much perfor-
mance. It promises developers that their programs would notsuffer undeÔ¨Åned behaviors if they do not use unsafe code.Meanwhile, the language embraces many novel features andbest practices of other programming languages, such as smartpointers and RAII (Resource Acquisition Is Initialization) [1].Due to these advantages, Rust has surged into popularity inrecent years [2] and has been adopted by many academicprojects (e.g., Redleaf [3], Theseus [4], Tock [5]) and industrial
ones (e.g., Intel Cloud Hypervisor VMM [6], TiDB [7],
Occlum [8]).
Although Rust provides specially-tailored mechanisms at
the language level to enhance security, many severe bugs arestill reported in existing Rust projects. In particular, Advisory-DB [9] and Trophy-Case [10] are two well-known publicrepositories with hundreds of bugs found in Rust projects. Aninteresting phenomenon of these bugs is that most of their hostprograms are libraries [11]. Such bugs can only be triggeredby composing a program with a speciÔ¨Åc usage of the libraryAPIs. Since Rust emphasizes software security and robustness,it is essential to hunt these library bugs. Unfortunately, we stilllack effective tools for examining the robustness of APIs. Forexample, fuzzing [12] and symbolic execution [13] generallyrequire executable problems; formal veriÔ¨Åcation [1] cannot befully automated for third-party library APIs.
In this paper, we aim to bridge the gap between Rust library
fuzzing and existing fuzzing tools. Fuzzing is a widely-adoptedtesting method that exercises a program by automaticallygenerating inputs in a random or heuristic way. However,a major problem confronted by Rust library fuzzing is theabsence of fuzz targets. A fuzz target deÔ¨Ånes an array ofbytes as input for executing a program composed with somelibrary APIs [14]. Fuzzing tools can mutate the input of fuzztargets to explore different paths. Existing fuzzing tools, suchas AFL [15], honggfuzz [16] and libFuzzer [17], all requirefuzz targets for library fuzzing, and writing fuzz targets mainlyrelies on human efforts. Fudge [18] is a recently proposedfuzz target generator for C/C++ programs by extracting codesnippets from Google code bases. However, its effectivenesslargely depends on the library usage and suffers substantiallimitations. For example, it is not applicable to newly-releasedlibraries or APIs; or it cannot generate fuzz targets for unusedAPIs, but bugs may relate to rarely-used features.
This paper investigates an automated fuzz target genera-
tion approach. Our approach pursues four objectives: validity
which means the program should be successfully compiled,effectiveness which means the fuzz targets should be friendly
to fuzzing tools in reaching high code coverage or bug Ô¨Ånding,coverage and efÔ¨Åciency meaning the fuzz targets should cover
as many APIs as possible and their set should be as small aspossible. To ensure validity, we compose fuzz targets based onthe API dependency graph of a given library. Since each fuzztarget can be viewed as a sequence of API calls, we breadth-Ô¨Årst search (BFS) API sequences under a length threshold onthe graph. For each uncovered API (deep-API) due to thelength limitation, we backward search their dependent APIsequences. Finally, we reÔ¨Åne our set of sequences to obtain aminimum subset that covers the same set of APIs.
We implement a fuzz target generator, RULF
1. Given the
API speciÔ¨Åcation of a Rust library, it can generate a set offuzz targets and seamlessly integrated with AFL++ [19] forfuzzing. We conduct experiments with 14 popular Rust li-braries, including three from GitHub and eleven from crates.io
1The acronym of RU stLibrary Fuzzing
5812021 36th IEEE/ACM International Conference on Automated Software Engineering (ASE)
DOI 10.1109/ASE51524.2021.000582021 36th IEEE/ACM International Conference on Automated Software Engineering (ASE) | 978-1-6654-0337-5/21/$31.00 ¬©2021 IEEE | DOI: 10.1109/ASE51524.2021.9678813
978-1-6654-0337-5/21/$31.00  ¬©2021  IEEE
(the ofÔ¨Åcial Rust crate registry). With a depth bound of three
for BFS, we generate 7-118 fuzz targets for each library.Further, we fuzz each target with a budget of 24 hours andÔ¨Ånd 30 previously-unknown bugs in seven libraries.
We summarize the main contributions of this paper as
follows:
‚Ä¢Our work serves as a pilot study to automatically generatefuzz targets for Rust libraries. It extends the applicabilityof existing fuzzing techniques, and such extension isurgently needed by Rust considering its intolerance ofundeÔ¨Åned behaviors.
‚Ä¢Our proposed approach leverages a sophisticated traversalalgorithm, which can achieve high API coverage withonly a small set of shallow fuzz targets. Such an approachis proven effective and efÔ¨Åcient. It can shed light tofurther investigation on code traversal.
‚Ä¢We have implemented an open-source prototype fuzztarget generator for Rust libraries
2. With the tool, we
successfully Ô¨Ånd 30 previously-unknown bugs in sevenpopular Rust libraries.
The rest of our paper is organized as follows. Section
II presents our motivation and research goals. We deÔ¨ÅneAPI dependency graph and introduce our proposed traversalalgorithm in section III, followed by the implementation of ourprototype tool in section IV. Section V presents our evaluationexperiments. Section VI reviews related work. We concludeour paper in section VII.
II. P
ROBLEM OF RUST LIBRARY FUZZING
A. Motivating Example
As Rust surges into popularity, many bugs of projects
written in Rust have been reported and analyzed, such asthose collected in Advisory-DB and Trophy-Case. A specialcharacteristic of these bugs is that most of them are located inlibraries [11]. Note that testing libraries is very different fromtesting executable programs. For library testing, developersshould compose their use cases of library APIs before testingthem or base the testing on unit tests. Since there could bedifferent ways or contexts of using an API, library testing ismore challenging.
Figure 1(a) demonstrates a library bug
3found in a Rust crate
just. The term crate represents the minimal compilation
unit in Rust. In this paper, we call a Rust library a crate.
The bug lies in the method justfile(), which is deÔ¨Åned
on a struct Parser. The method justfile() uses a third-
party data structure PutBack to store tokens. In the buggy
code, the Ô¨Årst two statements fetch two tokens, and the nexttwo statements put the two tokens back via put_back().
However, put_back() can put only one single item back
each time. If putting two items back, the Ô¨Årst item will beoverwritten. As a result, justfile() may parse an input
string incorrectly and panic the application. The patch simply
2RULF is publicly available on https://github.com/Artisan-Lab/RULF
3Issue link: https://github.com/casey/just/issues/363replaces the struct PutBack with another one PutBackN
that allows putting back multiple items.



	

 
	

 
	


	

		

		

	
	


	
	


	
	
	
(a) The bug detail.
use just::{Token, Lexer, Parser, Justfile}; 
let input = "export AA"; let tokens: Vec<Token> = Lexer::lex(input)?; let parser: Parser = Parser::new(input, tokens); let _justfile: Justfile = parser.justfile()?; 
(b) Code to reproduce the bug.
Fig. 1. An example bug in Rust crate just.
This bug had existed in the crate for over 10 versions
before it was found by a fuzzing tool. Reproducing the bug
requires composing a testing program for justfile() and
some speciÔ¨Åc test cases. To this end, the testing programshould create a Parser object via Parser::new(&str,
Vec<Token>), and Vec<Token> can be created by call-
ingLexer::lex(). Figure 1(b) presents a sample testing
program based on the analysis. Specifying ‚Äúexport AA ‚Äù as thevalue of input would crash the program.
B. Challenge of Fuzz Target Generation
To fuzz a library program, we need a set of testing programs
as fuzz targets. Such testing programs are similar to thosediscussed in Figure 1. However, how to automatically generatesuch testing programs is a challenging problem. Note thatthere could be dozens or even hundreds of APIs for a libraryprogram, and the fuzz targets should consider each API.
Taking the library in Figure2(a) as an example. The crate
toylib has two structs (S1 andS2) and Ô¨Åve public APIs (f1
tof5). We may design one speciÔ¨Åc fuzz target for each API,
or a large target that covers all APIs, or two potential fuzztargets (Figure 2(b) and Figure 2(c)) that can cover all APIsusing each API only once. Such options are essential factorsaffecting the effectiveness and efÔ¨Åciency of library fuzzing.
Below, we discuss four objectives for the fuzz target gen-
eration problem.
‚Ä¢Validity: The synthesized fuzz targets should be able
to be successfully compiled, i.e., all the parameters of
each API should be correctly settled. RULF achieves thisobjective by traversing the API dependency graph.
582struct S1; 
struct S2; fn f1(a: i16) -> S1; fn f2(b: u32) -> S2; fn f3(c: &[u8]) -> S2; fn f4(s1: S1, s2: &mut S2) -> S2; fn f5(s2: &S2, d: &str); 
(a) A toy Rust crate toylib.fn fuzz_target_1_for_toylib(data: &[u8]) { 
   if data.len() < 3 {return;} 
   let a = to_i16(data, 0);    let c = to_slice::<u8>(data, 2, data.len());   let s1 = toylib::f1(a);    let mut s2 = toylib::f3(c);    let _ = toylib::f4(s1, &mut s2); 
} 
(b) Fuzz target 1.fn fuzz_target_2_for_toylib(data: &[u8]) { 
    if data.len() < 5 {return;}     let b = to_u32(data, 0);     let d = to_str(data, 4, data.len());     let s2 = toylib::f2(b);     let _ = toylib::f5(&s2, d); } 
(c) Fuzz target 2.
Fig. 2. A sample problem for fuzz target generation.
‚Ä¢API coverage: For a library program, each of APIs has a
potential to contain bugs. Therefore, the set of generated
fuzz targets should cover as many APIs as possible.
‚Ä¢EfÔ¨Åciency: The set of generated fuzz targets should be
efÔ¨Åcient for fuzzing. On the one hand, the number offuzz targets should be manageable since fuzzing eachtarget generally requires several hours. On the other hand,we should avoid employing the same precedent APIs indifferent fuzz targets if possible because fuzzing the sameAPI multiple times may not be helpful.
‚Ä¢Effectiveness: The generated targets should be friendly
to fuzzing tools for bug hunting. In order to fuzz anAPI effectively, the generated program should be small.Otherwise, the fuzzing effort would be wasted on thetesting program or other APIs rather than the target API.
III. A
PPROACH
We model the problem of fuzz targets generation as an API
dependency graph traversal problem. This section Ô¨Årst deÔ¨Ånesthe API dependency graph and then introduces our traversalalgorithm.
A. API Dependency Graph
If the return value of one API and the parameter of another
API are of the same type, we can synthesize a valid program
that call the second API with the return value of the Ô¨Årst APIas the parameter. In other words, we say there is one possibledata Ô¨Çow dependency between the two APIs. Informally, anAPI dependency graph is a directed graph that captures allsuch possible data Ô¨Çow dependencies among the APIs of acrate.
Formally, we deÔ¨Åne an API dependency graph as a directed
graph G=(FN
m,PA R n,PE p,CE q)over a set of APIs Œ£,
where:
‚Ä¢FN m(API nodes) corresponds to all mAPIs inŒ£;
‚Ä¢PA R n(parameter nodes) corresponds to a subset of API
parameters in Œ£excluding those of primitive types. We do
not consider primitive types because they can be providedby fuzzer engines.
‚Ä¢PE p(producer edges) ‚äÜFN m√óPA R n, where an edge
fni‚Üípar jimplies fnireturns a value of type (or can
be inferred as type) par j.
‚Ä¢CE q(consumer edges) ‚äÜPA R n√óFN m, where an edge
par i‚Üífnjimplies par iis a non-primitive parameter for
fnj. The edge is weighted if fnjrequires multiple par is
as its parameters.

 	
	


	

Fig. 3. An API dependency graph of crate toylib.
We introduce parameter nodes into the graph to better dis-
tinguish two types of dependencies: 1) an API requires two pa-rameters returned by both two APIs (fn
i‚Üípar j&fni+1‚Üí
par j+1), and 2) an API requires one parameter returned
by either of the two APIs (fn i‚Üípar j|fni+1‚Üípar j).
Figure 3 demonstrates the API dependency graph for toylib
discussed in Figure 2(a). The graph contains Ô¨Åve API nodesFN
5={f1,f2,f3,f4,f5} and two parameter nodes
PA R 2={s1,s2}. s1 ands2 are two non-primitive type
parameters required to call f4;s2 is one non-primitive type
that can be produced by either f2 orf3.
We further deÔ¨Åne two kinds of special API nodes: start node
that consumes no non-primitive parameters and end node that
returns no non-primitive values. In Figure 3, f1,f2,f3 are
start nodes and f5 is an end node. f4 is neither a start node
nor an end node. Besides, an API node can be both a startnode and an end node.
B. V alidity of API Sequence
On an API dependency graph, an API node is reachable if
and only if it is a start node or all its required parameter nodes
are reachable and the weights of consumer edges are satisÔ¨Åed.Similarly, a parameter node is reachable if at least one APInode that can produce the parameter is reachable.
We say an API sequence fn
0, ..., fn kis valid if fn0
is a start node and each fni(0<i‚â§k)is reachable
given the subsequences of fn0, ..., fn i‚àí1. This is an essential
requirement for synthesizing valid fuzz targets. For example,{f2,f5} is a valid sequence in Figure 3; {f1,f4} is invalid
because s2 is not reachable for reaching f4.
Note that our deÔ¨Ånition of a valid API sequence does
not enforce a precedence relationship between each pair ofadjacent API nodes. In this way, a sequence with duplicated
583subsequences (or duplicated APIs) or with multiple end nodes
can also be valid. This is essential to deal with the movesemantics in Rust. BrieÔ¨Çy, move semantics mean the returnvalue can be used only once. If an API has two parametersof the same type, we may call f1 twice to serve the two
parameters. Therefore, {f1,f1} is also a valid sequence.
C. API Sequence Generation
We generate valid API sequences by traversing the API
dependency graph. According to the objective of fuzz targetgeneration discussed in Section II-B. The algorithm shouldmeet three objectives: API coverage, efÔ¨Åciency, and effective-ness. To this end, we Ô¨Årst employ BFS with pruning to obtaina set of API sequences that can cover the maximum numberof APIs given a length threshold; next, we backward searchvalid sequences for uncovered APIs with lengths larger thanthe BFS threshold. Finally, we merge the two sets as one andfurther reÔ¨Åne it to remove redundancies.
1) BFS with Pruning: We choose BFS as a basic algorithm
to generate valid sequences because fuzzing prefers shortsequences. Other traversal algorithms like random walk arenot suitable.
Algorithm 1 introduces our basic algorithm. The main part
of the algorithm is a while loop (line 6-17) that iterates overthe length of the generated sequences and terminates oncereaching a threshold. We start from a set with an emptysequence. In each iteration, we extend the sequences of lengthi-1 with one more API node to generate new sequences (line
7-13). To ensure validity, we perform ReachabilityTest
(line 11) for each candidate API as discussed in Section III-B.Besides, we employ an EndNodeTest function (line 8)
and a RedundancyTest function (line 19) to optimize the
sequence generation algorithm.
TheEndNodeTest function intends to terminate one
thread earlier once it reaches an end node. If we continuouslyappend new APIs to a sequence with an end node, theremust be another different sequence which is the same lengthand contains the same set of APIs and producer edges. Forexample, {f2,f5} is a sequence of toylib, and f5 is an
end node. If we append another API f3 to the sequence,
we will get {f2,f5,f3}, which contains the same set of
APIs and producer edges with another equal-length sequence{f2,f3,f5}. For such cases, our algorithm will generate{f2,f3,f5} only and prune {f2,f5,f3} as redundant.
TheRedundancyTest function is designed to Ô¨Ålter an-
other type of redundant sequences. Such sequences contain anAPI in the middle of the sequence that is not the dependencyof any following API. For instance, f1 is such an API in the
sequence {f3,f1,f5}. The sequence is redundant since BFS
has already generated another two shorter sequences {f1} and
{f3,f5} that contain the same APIs and producer edges. For
such cases, our algorithm will generate {f1} and{f3,f5}
and prune {f3,f1,f5} as redundant (line 19 in Algorithm
1).
2) Backward search: BFS with a threshold of sequence
length cannot cover APIs that require longer sequences (deep-Algorithm 1: BFS with pruning.
Input : A graph G(FN,PA R,PE,CE ),
Sequence length threshold max len
Output: A set of sequences SBFS
1Init:
2SBFS,Snew‚Üê‚àÖ ;
3Slast‚Üê{empty sequence} ;
4i‚Üê1;
5BFS with Pruning:
6 while i‚â§max len do
7 forseq inSlast do
8 ifEndNodeTest(seq )then
9 continue;
10 forfn inG‚ÜíFN do
11 ifReachabilityTest(G, seq,fn)then
12 new seq‚Üêseq .append(fn );
13 Snew .add(new seq );
14 SBFS .append(S new );
15 Slast‚ÜêSnew ;
16 Snew‚Üê‚àÖ ;
17 i‚Üêi+1;
18 forseq inSBFS do
19 ifRedundancyTest(seq )then
20 SBFS .remove(seq );
APIs). For example, an API that accepts several parametersmay need a long call sequence to satisfy each parameterrequirement. We observe that after running BFS with anarbitrary threshold three, only a few APIs cannot be covered.To reach these APIs, continuously searching for longer validsequences with BFS would be inefÔ¨Åcient. However, we cansearch the dependencies for these remaining uncovered APIsbackward.
For each uncovered API, our backward search approach
Ô¨Ånds its parameters directly based on already-generated se-quences. For toylib, after performing BFS with a threshold
one, we will generate three sequences {f1},{f2},{f3}.
Then, we backward search for the dependencies of f4, which
ares1 ands2. To produce s1 ands2, we can Ô¨Ånd a producer
edge from {f1} tos1 and another producer edge from {f2}
tos2. Since all parameters of f4 are satisÔ¨Åed, we can generate
a new sequence {f1,f2,f4} covering f4. Similarly, we
can generate a sequence {f2,f5} covering f5. We perform
backward search iteratively until no more APIs can be covered.
3) Merge and ReÔ¨Åne: Now, we merge the sequence sets
generated by BFS and backward search and reÔ¨Åne the set.The goal of our reÔ¨Ånement is to select a minimum subset ofsequences offering equivalent API coverage. This is in generalaSet Covering Problem (SCP) [20], which is NP-complete.
To solve the problem, we employ a greedy algorithm [21].
Our algorithm selects a sequence that contributes most to thecoverage until all APIs are covered. In particular, we prefer acandidate sequence A over B based on the following rules.
584
	
 

		






  

	







  


Fig. 4. Overview of our workÔ¨Çow.
‚Ä¢A covers more new nodes than B.
‚Ä¢A and B cover the same number of new nodes, but Acovers more new edges than B.
‚Ä¢A and B cover the same number of new nodes and edges,but A is shorter than B.
If there are multiple sequences with equal contribution
based on the above rules, we randomly select one from them.
Suppose {f3} and{f3,f5} are two candidate sequences
for selection. If f5 or the production edge from f3 tos2
(the parameter node of f5) has not been covered, we select
{f3,f5} because it contributes more to coverage. Otherwise,
we select {f3} because it is shorter.
After applying all the sequence generation steps to toylib,
we Ô¨Ånally obtain two sequences as shown in the boxes inFigure 2(b) and 2(c) (or two similar sequences).
IV . I
MPLEMENTA TION
We implement a prototype tool RULF to automatically
generate fuzz targets for Rust libraries. Our tool is based onRust 1.46.0-dev and contains about 6K lines of Rust codes.
Figure 4 overviews the workÔ¨Çow of RULF that inputs a
Rust lib crate and outputs a set of fuzz targets. There arethree essential components. The Ô¨Årst is to construct an APIdependency graph based on API signatures. The second is togenerate valid sequences by traversing the graph. The thirdis to synthesize Rust programs ready to compile from validsequences.
Next, we discuss the implementation details of each com-
ponent.
A. Construct API Dependency Graph
We construct an API dependency graph in two stages.
First, we extract all public API signatures from the source
code. We base RULF on an existing tool, rustdoc [22], which
is an ofÔ¨Åcial doc tool to generate API documentation for Rustprojects. Internally, rustdoc calls rust compiler to compile thecrate and extract API information from the compilation results.We directly add our codes into librustdoc.
After we extract all public API signatures, we infer de-
pendencies among APIs based on type inference to builddependency graph. We deÔ¨Åne call type for type inference. Ifthere is a call type from type A to type B, A and B are thesame type or A can be converted to B. All call types can beseen in Table I. Note that call types can be nested, e.g., there
is a call type from Option<T> to&T, which is Borrowed
reference (Unwrap option).
TABLE I
CALL TYPES FOR TYPE INFERENCE .T ,E ARE ANY RUST TYPE .
Call type Example
Direct call T‚ÜíT
Borrowed reference T‚Üí&T
Mutable borrowed reference T‚Üí&mut T
Const raw pointer T‚Üí‚àó const T
Mutable raw pointer T‚Üí‚àó mut T
Dereference borrowed reference &T‚Üí T
Dereference raw pointer ‚àóconst T‚ÜíT
Unwrap result Result/angbracketleftT, E /angbracketright‚Üí T
Unwrap option Option/angbracketleftT/angbracketright‚Üí T
To option T‚ÜíOption(T)
Call types deÔ¨Åned in Table I can be divided into two
categories. The Ô¨Årst seven are general call types (from Direct
call toDereference raw pointer ). The last three are speciÔ¨Åc
call types for two types, Result andOption (from Unwrap
result toTo option). Result andOption are two heavily-
used enumeration types in Rust. Result is used to return
recoverable errors. Option indicates a value that may be
empty. These two types are used to wrap a normal type,
e.g.,u8 is an 8-bit integer type, while Option<u8> can
be a normal u8 orNone. We can get the real u8 type by
unwrapping Option<u8> if it is not None. If these two types
are not specially treated, it will greatly affect the validity oftype inference.
More wrapper types can be treated specially, e.g.,Box.
Special treatment of these types helps infer dependencies moreaccurately. RULF can support this by adding a new call type.
B. Generate API Sequences
After we construct an API dependency graph, we generate
valid sequences by traversing the graph. The main approach
is mentioned in the previous section. Here are more details.
API dependency graph can only capture all possible data
Ô¨Çow dependencies, but this is not enough for generating allpossible sequences. Figure 5 demonstrates such a case. Since
585the return value of toylib::f4 is never used, this sequence
will be removed by RedundancyT est in previous section.
However, toylib::f5 uses the variable mutated by f4. So,
toylib::f4 is not a redundant API.
let s1 = toylib::f1(1); 
let mut s2 = toylib::f2(2); let _ = toylib::f4(s1, &mut s2); //f4 mutates s2let _ = toylib::f5(&s2, "a"); //f5 uses the variable mutated by f4  
Fig. 5. A mutation case on crate toylib.
To deal with this case, we integrate EndNodeT est and
RedundancyT est with mutation analysis. If an API has no
return value or returns a primitive type, it is an end node
according to the deÔ¨Ånition in the previous section. However, ifthe API can mutate the value of a variable (like setter methodsin Java), it is not appropriate that we treat this API as anend node. The EndNodeT est is based on the fact that the
API behind an end node can exchange orders with other endnodes. This fact does not hold if the end node can mutate thevalue. So we redeÔ¨Åne an API that satisÔ¨Åes the following tworequirements as an end node: 1) The API has no return valueor returns a primitive type. 2) The API does not mutate thevalue of any variable that another API returns.
We modify RedundancyT est similarly: if neither the return
value of an API nor variables whose values are mutated bythis API are used by other APIs, this API can be called a deadnode. Sequences containing such a dead node are redundantand can be Ô¨Åltered.
Determining whether an API can mutate a value in Rust
programs is easy. Rust has a keyword mut. Only if the
parameter of an API is modiÔ¨Åed with the keyword mut,t h e
API has the ability to mutate a value (e.g., toylib::f4 can
mutate the value of s2). After modifying the deÔ¨Ånitions of
EndNodeT est andRedundancyT est, we can still use the
algorithms in the previous section. Interior mutability in Rust,allowing unsafe code in a function to mutate the value of aparameter even if the parameter is not modiÔ¨Åed with mut,
may affect the effectiveness of mutation analysis. However,interior mutability does not affect the validity of sequencesgenerated by RULF. So we ignore the limitation in the currentimplementation of RULF.
To generate sequences that can pass the compiler‚Äôs check,
we take Rust‚Äôs language features into account. Ownership isRust‚Äôs most unique feature. In Rust, each value has only onevariable as its owner which has the exclusive ownership ofthe value. The ownership can be transferred among variables,which is called move. If a variable transfers the ownership,
the variable cannot visit the value anymore. Figure 6 demon-strates a simple move case. s1 deÔ¨Åned in line 1 is used by
toylib::f4 in line 3. s1 transfers the ownership in line 3.
We cannot use s1 in line 4 any more otherwise it will report
a compilation error.
Passing a value to a function may result in the value moved
or copied, so we should distinguish between moving andcopying cases. If a value is moved, we add a tag to thevariable which owns the value and do not use this variablein the following statements. Whether a value moves dependson the combination of call type and variable type. Consideringthat there are many call types (call types can be nested) andvariable types, it is not easy to distinguish moving and copyingcases correctly. In practice, we adopt a conservative strategy.We select some combinations of variable types and call typesthat we think are commonly used in API calls and mark thesecombinations as copying cases if they do be. For example, ifthe variable type is immutable reference and the call type isDirect Call, we will mark this case as a copying case. Exceptfor several cases marked as copying cases, we assume that allother cases are moving cases.
let s1 = toylib::f1(0); 
let mut s2 = toylib::f2(1); toylib::f4(s1, &mut s2);//s1 moves. s1 cannot be used any more.  
toylib::f4(s1, &mut s2);//Compilation error!  
Fig. 6. A simple move case on crate toylib.
Reference is also carefully dealt with. V ariables without
ownership can visit a value by having a reference. Thereare two categories of reference, immutable reference (sharedreference) and mutable reference (exclusive reference). Toavoid data race, immutable reference and mutable referenceof the same value cannot coexist. Multiple mutable referencesof the same value are not allowed to coexist too. We adda tag to variables that have a reference to make sure that therules about references are correctly followed. Currently, we donot take special treatment to the lifetime bounds of references,which may result in generating invalid sequences. We will addcheck of lifetime in our following work.
C. Synthesize Program
We synthesize Rust programs ready to compile from valid
sequences. We implement several stages in RULF to pass the
check of the compiler, e.g., adding mut tag, adding import
statements and so on. In this section, we focus on our methodto deal with primitive types.
We get all primitive parameters from the input buffer of fuzz
targets. We split this buffer into slices of different sizes. Thenwe convert each slice to a primitive value. This conversionrelies on a series of template functions we write in advance.We currently do not support some primitive types, e.g., string
with static lifetime or array with a static length that cannot beprovided by the fuzzer engine.
To decide how to split the input buffer, we divide all
primitive types into two categories. One is with a Ô¨Åxed length,such as u8 and char. The other is with a dynamic length, suchas string and slice. We Ô¨Årst assign a slice from the buffer toeach Ô¨Åxed-length variable. The remaining part of the bufferwill be divided equally among all dynamic-length variables.
When we merge and reÔ¨Åne the sequences after backward
search, we skip sequences without primitive parameters asinput since fuzzing these sequences is useless. We also givepreference to sequences with primitive parameters of dynamic
586length. These sequences have larger input space to search and
intuitively are more likely to contain errors.
V. E V ALUA TION EXPERIMENT
This section evaluates RULF by studying three research
questions.
‚Ä¢RQ1: Can RULF meet the four objectives (i.e., validity,
API coverage, efÔ¨Åciency, and effectiveness) of fuzz targetgeneration?
‚Ä¢RQ2: How does each step of our sequence generation
algorithm help generate high-quality fuzz targets?
‚Ä¢RQ3: Can RULF outperform the state-of-the-art ap-
proach?
A. Experiment Setting
We select 14 popular and high-quality Rust crates for
fuzzing experiments, including eleven from crates.io and threefrom GitHub. All these crates have been downloaded over tenmillion times or received more than 4000 stars. Meanwhile,all these crates have well-written unit tests and stable releases.All these crates manage their dependencies by cargo, i.e.,
running cargo build for these crates will return success
without manually downloading dependencies. We avoid select-ing certain libraries due to our current limitations (see SectionV -E), e.g., libraries containing many asynchronous APIs. We
download their latest version for our experiments. Table IIlists the names of these crates. Their API numbers vary a lot,ranging from 12 to 212.
When generating fuzz targets with BFS, we choose three
as the threshold of sequence length. The threshold cannot belarge due to path explosion. For instance, the running timeto generate fuzz targets on a crate time will exceed one
hour if we set the threshold to four. Meanwhile, the thresholdcannot be too small because we cannot explore different APIcombinations in a very short sequence. Three is a best practiceaccording to the code samples in Trophy-Case to reproducebugs. We Ô¨Ånd that most bugs can be reproduced by callinglibrary APIs within three times.
Before fuzzing each fuzz target, we generate 500 random
inputs and execute the target with each input. If all inputs leadto program crashes, the fuzz target is considered as an invalidtarget and removed. The rest inputs will be employed as seedsfor further fuzzing.
We use afl.rs from rust-fuzz [23] to compile and fuzz
these targets. afl.rs is a Rust binding for AFL++ [19],
which is AFL with community patches. We set the environ-mental variable AFL_EXIT_WHEN_DONE = 1, so the fuzzing
process will exit automatically when all branches are visited.We set AFL_NO_AFFINITY = 1, so we can fuzz more targets
parallel than the number of our cores. All other environmentalvariables are set with default values. We fuzz each crate for 24hours unless AFL itself terminates. After that, we obtain a setof crashes and reÔ¨Åne the result with aÔ¨Ç-tmin and aÔ¨Ç-cmin. Inparticular, these tools can merge crash reports with equivalentedge coverage.We manually check each crash report to determine whether
it is a real API bug. To this end, we reproduce each crashto analyze why the crash happens. If a crash is caused by anexplicit panic function call or is documented as a known paniccase, we do not treat it as a bug. Otherwise, the crash shouldindicate a bug.
All our experiments are conducted on a Dell T640 server
with 2 Intel Xeon Gold 6242R 3.10GHz 20-core CPUs and256GB memory.
B. RQ1: Can RULF meet the four objectives of fuzz target
generation?
We discuss the performance of RULF with respect to the
objectives of validity, API coverage, efÔ¨Åciency, and effective-
ness.
1) V alidity and API Coverage: Table II overviews our
experimental results. We generate 7 to 118 targets for eachlibrary, and the API coverage ranges from 0.27 to 0.92. Sincewe generate sequences by traversing the API dependencygraph, all parameters of each API are settled correctly, and allsequences are syntax-correct and can be compiled successfully.Among all fuzz targets, there are only 4/35 invalid targets forthe crate clap and 1/33 for proc-macro2. The main reason
is that our synthesized program does not follow the contex-tual requirement for using particular APIs. Figure 7 demon-strates the issue with an invalid target for proc_macro2.
The API proc_macro2::Span::unwrap is used to
convert proc_macro2::Span toproc_macro::Span.
However, since proc_macro::Span only exists within
the context of procedural macro (Rust‚Äôs syntax extensions),proc_macro2::Span::unwrap will always panic if we
call it outside procedural macros.
fn test(input: &[u8]) { 
   let literal = proc_macro2::Literal::byte_string(input);   let span = proc_macro2::Literal::span(&literal);    let _ = proc_macro2::Span::unwrap(span); 
}
Fig. 7. An invalid target on proc_macro2.
RULF achieves API coverage ranging from 0.27 to 0.92.
The remaining APIs cannot be covered mainly because their
parameters cannot be served by other APIs of the same crate.A large portion of these APIs depends on generic APIs thatinvolve dynamic types. Figure 8 demonstrates such an uncov-ered API multi_line. The API requires a parameter of
typeRegexSetBuilder (represented by self). However,
the only constructor method for RegexSetBuilder is a
generic API. We currently do not support synthesizing validprograms with generic parameters. Section V -E discusses moreon this issue.
2) Effectiveness: Our results show RULF is effective in
Ô¨Ånding bugs in libraries. We Ô¨Ånd 30 previously-unknown bugsin total in seven libraries. All bugs have been included inTrophy-Case. We manually check each crash and collect bugswith different API call paths. We submit issues about all
587TABLE II
EXPERIMENT RESULTS ON 14 LIBRARIES .T HE TOP ELEVEN ARE FROM CRA TES .IO.T HE LAST THREE ARE FROM GITHUB .
Crate name version API numbers API coverageFuzz targets
(invalid)Finished targetsAverage run time
(hours)Crashes
(after cmin)Bugs
clap 2.33.3 85 0.78 35(4) 27 3.24 236(28) 2
proc-macro2 1.0.24 60 0.65 33(1) 16 20.42 451(103) 0
serde json 1.0.61 89 0.46 25 24 1.20 0(0) 0
http 0.2.3 74 0.35 19 16 4.42 0(0) 0
url 2.2.0 74 0.91 61 0 24 422(75) 2
regex-syntax 0.6.22 177 0.58 74 67 2.30 0(0) 0
regex 1.4.3 129 0.74 67 20 16.84 7274(257) 10
semver 0.11.0 12 0.92 7 0 24 147(1) 1
semver-parser 0.10.2 15 0.80 10 7 13.56 0(0) 0
Ô¨Çate2 1.0.19 31 0.68 11 11 0.35 2(1) 0
time 0.2.24 198 0.88 118 118 0.27 321(122) 7
bat 0.17.1 91 0.27 20 2 21.76 0(0) 0
xi-core-lib 0.4.0 212 0.27 34 34 0.53 34(10) 4
tui 0.13.0 188 0.37 48 48 3.12 105(39) 4
impl RegexSetBuilder { 
    //constructor for RegexSetBuilder: generic API  
    pub fn new<I, S>(patterns: I) -> RegexSetBuilder     where S: AsRef<str>, I: IntoIterator<Item = S>,{}     //multi_line cannot be covered  
    pub fn multi_line(&mut self, yes: bool) -> &mut RegexSetBuilder{} }
Fig. 8. An uncovered API in regex.
TABLE III
THE TYPES OF BUGS WE FOUND BY RULF.
Crate Range Unwrap Arith UTF-8 Unreachable
clap 0 0 0 2 0
url 2 0 0 0 0
regex 6 0 2 2 0
tui 0 0 4 0 0
time 0 0 5 0 2
xi-core-lib 2 0 2 0 0
semver 0 1 0 0 0
bugs to the GitHub repository of these libraries. 24 bugs are
conÔ¨Årmed by the repository maintainers before we submit ourpaper. The types of bugs are shown in Table III. There areÔ¨Åve kinds of bugs in Table III, which are all common bugs inRust.
‚Ä¢Range: out-of-bound error
‚Ä¢Unwrap: call unwrap onErr() orNone
‚Ä¢Arith: arithmetic overÔ¨Çow
‚Ä¢UTF-8: problems with UTF-8 strings
‚Ä¢Unreachable: visit codes with macro unreachable!()
False positive is a key concern when we fuzz many targets.
False positive crashes are inevitably introduced to the resultsbecause the library developers may determine to panic theprogram under certain circumstances, e.g., when the library
API receives invalid parameters. In practice, the false positivecrashes can be determined at a glance due to clear outputinformation. Our preference to short sequences also facilitateschecking and analyzing each crash report. In our experiment,all crashes on one fuzz target do point to the same bug (or thesame false positive reason). To check all crashes of one cratetakes a graduate student ranging from one to Ô¨Åve hours.We present one library example as a case study. Regex is a
crate from Rust‚Äôs ofÔ¨Åcial team. It is one of the most importantcrates for Rust and is imported by more than three thousandprojects on crates.io. Regex has well-written unit tests and is
continuously fuzzed with OSS-fuzz [24]. RULF Ô¨Ånds ten newbugs in regex. Six bugs are related to improperly dealing withunexpected inputs. The remaining four bugs are logical errors.The code to reproduce one bug is in Figure 9.
use regex::{Regex, Match}; 
//compile a regular expression from string literal  
let re = Regex::new(r"(?-u)\S").unwrap(); //find the leftmost-first match in text  
let matched_str = Regex::find(&re, "/g624E").unwrap(); 
//returns the matched text let _ = Match::as_str(&matched_str); 
Fig. 9. Code to reproduce one bug we found in crate regex.
The reason behind this bug is that Regex is not allowed to
match invalid UTF-8 text. Match::as_str always assumes
it accepts a valid UTF-8 text, otherwise it will panic. However,\S can match any invalid UTF-8. Regex::find matches
an invalid UTF-8 text in our case. So Match::as_str
panics and reports an invalid UTF-8 error. The bug roots inRegex::new, where the given regex should not be allowedto compile.
Note that although the bug roots in Regex::new,w e
detect panic behaviors in Match::as_str.I fw ed on o t
construct such an API sequence and only fuzz Regex::new,
we cannot detect the bug due to no abnormal behaviors areobserved. We need to combine the APIs in a speciÔ¨Åc way.Besides, the bug can only be triggered by the input string with\S. Fuzzing can efÔ¨Åciently Ô¨Ånd the exact input. By combingfuzzing and API sequence generation, RULF is effective inÔ¨Ånding these bugs.
3) EfÔ¨Åciency: We reduce the size of the fuzz target set by
pruning and reÔ¨Åning. The average ratio of APIs to fuzz targetsis 1.43. Considering the length of most sequences is smallerthan or equal to three, the set of fuzz targets is compact. Table
588


Fig. 10. The number of crashes of fuzzing three crates where we Ô¨Ånd bugs in Ô¨Årst six hours. We sample every minute.
TABLE IV
COMPARISON STUDY OF DIFFERENT SEARCH STRA TEGIES FOR THE QUALITY OF FUZZ TARGETS ON FIVE CRA TES .
CrateBackward search Backward search & ReÔ¨Åne RULF
Targets Covered edgesAverage # to
visit one APITargets Covered edgesAverage # to
visit one APITargets Covered edgesAverage # to
visit one API
regex 94 94 2.30 81 94 2.08 67 94 1.92
clap 66 64 2.02 62 64 1.94 35 67 1.59
serde json 40 34 1.85 36 34 1.75 25 35 1.44
tui 64 81 2.69 55 77 2.42 48 91 2.14
http 26 19 1.73 22 19 1.58 19 21 1.54
TABLE V
THE NUMBER OF SEQUENCES ON SIX CRA TES AFTER PRUNING AND
REFINING .
Crate BFSEndNode-
TestRedundancy-
TestReÔ¨Åne
url 1698 1520 171 61
regex 2060 1909 352 67
time 382401 285669 3960 118
regex-syntax 25748 18266 424 74
serde json 2178 2020 174 25
clap 5036 4758 3572 35
IV shows in most cases, RULF visits each API for no more
than two times on average. This meets our design objective.
However, we still generate up to 118 fuzz targets for each
library. Previous work like Fudge [18] presents only a fewtargets for each library. So it is necessary to evaluate theefÔ¨Åciency of fuzzing by experiment.
The fuzzing efÔ¨Åciency varies greatly among different li-
braries. As shown in Table II, the average run time ranges from0.27 to 24 hours. For libraries like time andxi-core-lib,
all fuzzing processes exit in several hours (about 4 and 3 hoursrespectively). For libraries with complex APIs, e.g.,url,n o
fuzzing processes exit in 24 hours. The fuzzing efÔ¨Åciency maybe more related to the complexity of library APIs rather thanthe number of fuzz targets.
Figure 10 shows the relation between the number of re-
ported crashes and time. Newly-discovered crashes in eachminute are fewer and fewer. The reported crashes in the Ô¨Årsthour take 0.67 to 0.94 of those in the Ô¨Årst six hours. Formost libraries, newly-reported crashes after six hours are few.This indicates RULF is efÔ¨Åcient for fuzzing as the number ofcrashes converges in a not very long time.
C. RQ2: How does each step of our sequence generation
algorithm help generate high-quality fuzz targets?
The basic goal of our algorithm is to generate a set of
valid sequences to cover all APIs. Three optimization goals
are (1) to minimize the set size (2) to maximize produceredge coverage (3) to avoid repeatedly visiting the same API.
Combining BFS with backward search enables us to cover
all APIs efÔ¨Åciently. It takes less than 30 seconds to generatetargets for each library if the library is compiled.
Our pruning and reÔ¨Åning algorithms reduce the size of
the sequence set. As shown in Table V, the number ofsequences greatly decreases after we integrate pruning andreÔ¨Åning algorithms into BFS. The ratio of sequences generatedby BFS to fuzz targets after reÔ¨Åning ranges from 28 to 3241,i.e., we achieve equivalent API coverage with a much smaller
set. We can avoid fuzzing the same API too many times.
Backward search is efÔ¨Åcient for covering deep-APIs. The
longest sequence we generate by backward search is of lengthseven. It is hard for only BFS to generate this long sequencedue to path explosion. On our server, we cannot generate thislong sequence with only BFS before running out of memory.Besides, we cannot determine which API cannot be coveredwith only BFS. Backward search can cover 26 more APIs in 5out of 14 libraries after BFS. This number (26) is much smallercomparing to total API numbers (1435), which conÔ¨Årms ourprevious observation that only a few APIs cannot be coveredby BFS. Among all 30 bugs we found, one bug is reproducedby calling four library APIs. We cannot Ô¨Ånd this bug withoutbackward search.
589TABLE VI
COMPARISON WITH BASELINES ON THREE CRA TES WHERE RULF FOUND BUGS ABOUT THE EFFECTIVENESS OF BUG FINDING .
CrateRandom walk FLC FLUT RULF
TargetsAPI
coverageBugs TargetsAPI
coverageBugs TargetsAPI
coverageBugs TargetsAPI
coverageBugs
url 61 0.34 1 18 0.32 1 29 0.54 1 61 0.91 2
regex 67 0.28 1 13 0.16 3 133 0.44 6 67 0.74 10
time 118 0.38 0 15 0.11 0 124 0.43 5 118 0.88 7
BFS is useful to combine APIs in different ways. A possible
algorithm to cover all APIs is to only leverage backward search
to generate sequences from an empty sequence. For eachunvisited API, backward search tries to Ô¨Ånd dependency foreach parameter of the API from already-generated sequences.Table IV compares backward search, backward search withreÔ¨Åning and RULF on the quality of generated targets basedon our three optimizing goals. To cover all APIs, backwardsearch requires generating more targets and visiting the sameAPI repeatedly for more times. Besides, backward searchcan cover fewer producer edges. Even after performing ourreÔ¨Åning method on the results of backward search to removeredundant targets, RULF performs better. We limit our useof backward search to only a few deep-APIs to ensure thequality of generated targets. The reason is that BFS generatesall possible short sequences. When we reÔ¨Åne the result, wehave more sequences to select from. So we can obtain targetswith higher quality.
D. RQ3: Can RULF outperform the state-of-the-art ap-
proach?
There is no available fuzz target generator on Rust now.
The closest one is Fudge [18]. We select Fudge as our
Ô¨Årst baseline. Fudge can generate fuzz targets for C/C++libraries automatically. Fudge has earned great success andled to hundreds of bug Ô¨Åxes. Fudge extracts code snippets astargets by Ô¨Ånding the minimum data Ô¨Çow and control Ô¨Çowdependencies of library APIs in client codes. Fudge extractscode snippets from the whole Google code bases. Since wecannot visit Google code bases, we adopt Fudge‚Äôs algorithmon two available code bases: (i). ten client libraries with most
downloads on crates.io using APIs from the libraries to fuzz(FLC) and (ii). the unit tests from the library to fuzz (FLUT).
We extract codes manually with Fudge‚Äôs algorithm and dropduplicate targets with the same API call sequences.
We also implement random walk as our second baseline.
One possible alternative to generating targets is random walk.Random walk starts from an empty sequence. For each step,we pick up a random sequence from previously-generatedsequences and a random API from all library APIs. If the APIcan be added to the sequence to generate a valid sequence, wegenerate a new sequence. We perform random walk until wegenerate the same number of targets as generated by RULF.
For RULF, we fuzz each crate by a threshold of 6 hours.
For other methods, we ensure the total time threshold to fuzza library is the same as RULF. We compare RULF with othermethods on the effectiveness of bug Ô¨Ånding. The results canbe seen in Table VI.
The comparison results can be seen in Table VI. Among
four methods, random walk performs most poorly. Randomly-generated targets usually cover the same APIs and paths, sofuzzing these targets leads to the fewest bug Ô¨Åndings. FLCbehaves better than random walk but still poorly. We Ô¨Ånd thatclient codes usually limit their usage of library APIs to somemost common ones, so we can only extract very few targets.Client codes tend to use APIs with complex logic whichare more error-prone to some extent. So FLC can Ô¨Ånd morebugs than random walk. FLUT achieves higher API coverageand Ô¨Ånds more bugs than the Ô¨Årst two methods. Library unittests combine library APIs in different ways to ensure APIsbehave properly. The codes in unit tests cover most error-pronecases. FLUT can Ô¨Ånd some bugs beyond the capacity of thecurrent version of RULF, e.g., bugs involving third-party APIs
and advanced Rust features like closure. However, similar toclient codes, unit tests emphasize more on the combination ofcommonly-used APIs. So, FLUT fuzzes commonly-used APIsrepeatedly while missing bugs in other rarely-used APIs. Toimprove the performance of Fudge-like methods, we requirebetter code bases to capture the usage of library APIs. RULFbehaves best for we directly generate targets to achieve highAPI coverage from library source codes. We will not miss anyAPI that may go wrong.
E. Limitations and Future Work
RULF still has some limitations, and we leave these issues
as our future work.
Firstly, the API coverage of RULF can be further improved
by supporting polymorphic APIs. These APIs involve poly-
morphic types, such as generics and trait object. Since we inferdependencies only according to concrete types, we cannot inferdependencies for polymorphic APIs now. We will considersupporting typical usage patterns of polymorphic APIs in thefuture, such as trait object or generics with trait bound byexhausting all possible types deÔ¨Åned in the crate.
Secondly, the current version of RULF only considers
functions or methods as library APIs for fuzzing. It cannotsupport macro APIs. We will consider supporting macro in thefuture. RULF currently also does not support asynchronousAPIs. The execution of asynchronous APIs depends on aspeciÔ¨Åc runtime, such as async-std or Tokio [25]. We willinvestigate how asynchronous APIs inÔ¨Çuence the effectivenessof fuzzing in our following work.
590Finally, RULF only supports general fuzzing tools like AFL
and honggfuzz. We cannot support in-process fuzzers like
libFuzzer because we introduce std::process::exit
in our template functions to simplify current implemen-tation of RULF. We will consider replacing the use ofstd::process::exit to support in-process fuzzers. Be-
sides, general fuzzing tools are inefÔ¨Åcient to deal with highlystructured inputs [26] [27]. We will investigate how RULFperforms when we fuzz programs with different fuzzers.
VI. R
ELA TED WORK
Fuzzing tools such as AFL [15], libFuzzer [17], hongg-
fuzz [16] have attracted much attention in recent years. Ex-isting investigations mainly aim to improve the efÔ¨Åciency andeffectiveness of such tools, such as AFLFast [28], Driller [29],and Fairfuzz [30]. All these tools require well-deÔ¨Åned fuzztargets.
There exists some work about fuzz target generation.
Fudge [18] extracts short sequences from client projects asfuzz targets. The mechanism highly relies on high-qualitycode bases to generate fuzz targets. We have shown thelimitations of Fudge with several crates in our comparisonstudy. FuzzGen [31] builds A
2DG from existing code bases
to represent the data Ô¨Çow and control Ô¨Çow dependencies andgenerate fuzz targets based on the A
2DG . FuzzGen also relies
on high-quality code bases. [32] introduces a case study aboutautomatically-generated fuzz targets intended for C programs.Their method to get primitive parameters from the input bufferis similar to ours. However, [32] only fuzzes a single APIrather than combining APIs in different ways. RESTler [33]is another work that generates fuzz targets for RESTful APIs,and it is based on BFS. However, RESTful applications do nothave strong type requirements as Rust.
There are several automated unit test generation or program
synthesis approaches related to fuzz target generation. Forexample, Randoop [34] automatically generates valid methodcall sequences incrementally by using feedback information.RecGen [35] uses mutation analysis to better select sequencesand increase code coverage. Concolic execution is anotherway to improve the performance of unit test generation [36].SyRust [37] is a testing framework for Rust libraries. SyRustsynthesizes large numbers of programs for a small set oflibrary APIs and does not mutate the input value of eachprogram. All these approaches are not directly applicable tothe fuzz target generation problem for Rust libraries.
VII. C
ONCLUSION
To conclude, this work proposes an automated fuzz target
generation approach for Rust library fuzzing based on APIdependency graph traversal. Our approach employs BFS withpruning and backward search to generate valid API sequencesand reÔ¨Ånes the sequences to obtain an optimal sequenceset. We have implemented a prototype RULF and show thatit can successfully address the requirements of fuzz targetgeneration for Rust libraries, including validity, API coverage,effectiveness, and efÔ¨Åciency. Considering the characteristic ofRust and its reliability requirement on library APIs, suchtools are urgently needed and would play an essential rolein facilitating the development of the community.
A
CKNOWLEDGMENT
This work was supported by the National Natural Science
Foundation of China (Project No. 61971145). Hui Xu is thecorresponding author.
R
EFERENCES
[1] R. Jung, J. Jourdan, R. Krebbers, and D. Dreyer, ‚ÄúRustbelt: securing the
foundations of the rust programming language,‚Äù Proc. ACM Program.
Lang., vol. 2, no. POPL, pp. 66:1‚Äì66:34, 2018.
[2] StackoverÔ¨Çow, ‚Äú2020 developer survey,‚Äù 2020. [Online]. Available:
https://insights.stackoverÔ¨Çow.com/survey/2020
[3] V . Narayanan, T. Huang, D. Detweiler, D. Appel, Z. Li, G. Zellweger,
and A. Burtsev, ‚ÄúRedleaf: Isolation and communication in a safe
operating system,‚Äù in 14th USENIX Symposium on Operating Systems
Design and Implementation, OSDI 2020, Virtual Event, November 4-6,2020. USENIX Association, 2020, pp. 21‚Äì39.
[4] K. Boos, N. Liyanage, R. Ijaz, and L. Zhong, ‚ÄúTheseus: an experiment
in operating system structure and state management,‚Äù in 14th USENIX
Symposium on Operating Systems Design and Implementation, OSDI2020, Virtual Event, November 4-6, 2020. USENIX Association, 2020,pp. 1‚Äì19.
[5] A. Levy, B. Campbell, B. Ghena, D. B. GifÔ¨Ån, P . Pannuto, P . Dutta, and
P . Levis, ‚ÄúMultiprogramming a 64kb computer safely and efÔ¨Åciently,‚Äù inProceedings of the 26th Symposium on Operating Systems Principles,Shanghai, China, October 28-31, 2017. ACM, 2017, pp. 234‚Äì251.
[6] I. inc, ‚ÄúCloud hypervisor vmm,‚Äù 2020. [Online]. Available:
https://github.com/cloud-hypervisor/cloud-hypervisor
[7] PingCAP , ‚ÄúTidb: A distributed sql database,‚Äù 2020. [Online]. Available:
https://github.com/pingcap/tidb
[8] Y . Shen, H. Tian, Y . Chen, K. Chen, R. Wang, Y . Xu, Y . Xia, and S. Y an,
‚ÄúOcclum: Secure and efÔ¨Åcient multitasking inside a single enclave ofintel SGX,‚Äù in ASPLOS ‚Äô20: Architectural Support for Programming
Languages and Operating Systems, Lausanne, Switzerland, March 16-20, 2020, J. R. Larus, L. Ceze, and K. Strauss, Eds. ACM, 2020, pp.955‚Äì970.
[9] R. S. C. WG, ‚ÄúRustsec advisory database,‚Äù 2021. [Online]. Available:
https://github.com/RustSec/advisory-db
[10] R. F. Authority, ‚ÄúTrophy case,‚Äù 2021. [Online]. Available:
https://github.com/rust-fuzz/trophy-case
[11] H. Xu, Z. Chen, M. Sun, and Y . Zhou, ‚ÄúMemory-safety challenge
considered solved? an empirical study with all rust cves,‚Äù CoRR, vol.
abs/2003.03296, 2020.
[12] H. Liang, X. Pei, X. Jia, W. Shen, and J. Zhang, ‚ÄúFuzzing: State of the
art,‚Äù IEEE Trans. Reliab., vol. 67, no. 3, pp. 1199‚Äì1218, 2018.
[13] C. Cadar and K. Sen, ‚ÄúSymbolic execution for software testing: three
decades later,‚Äù Commun. ACM, vol. 56, no. 2, pp. 82‚Äì90, 2013.
[14] Google, ‚ÄúWhat makes a good fuzz target,‚Äù 2020. [Online]. Available:
https://github.com/google/fuzzing/blob/master/docs/good-fuzz-target.md
[15] Z. Michal, ‚ÄúAmerican fuzzy lop,‚Äù 2015. [Online]. Available:
https://lcamtuf.coredump.cx/aÔ¨Ç/
[16] Google, ‚ÄúHonggfuzz,‚Äù 2020. [Online]. Available:
https://github.com/google/honggfuzz
[17] L. team, ‚Äúlibfuzzer ‚Äì a library for coverage-guided fuzz testing.‚Äù 2020.
[Online]. Available: https://llvm.org/docs/LibFuzzer.html
[18] D. Babic, S. Bucur, Y . Chen, F. Ivancic, T. King, M. Kusano,
C. Lemieux, L. Szekeres, and W. Wang, ‚ÄúFUDGE: fuzz driver generationat scale,‚Äù in Proceedings of the ACM Joint Meeting on European
Software Engineering Conference and Symposium on the F oundationsof Software Engineering, ESEC/SIGSOFT FSE 2019, Tallinn, Estonia,August 26-30, 2019. ACM, 2019, pp. 975‚Äì985.
[19] A. Fioraldi, D. Maier, H. Ei√üfeldt, and M. Heuse, ‚ÄúAFL++: Combining
incremental steps of fuzzing research,‚Äù in 14th USENIX Workshop on
Offensive Technologies (WOOT 20). USENIX Association, Aug. 2020.
[20] M. R. Garey and D. S. Johnson, Computers and Intractability: A Guide
to the Theory of NP-Completeness. W. H. Freeman, 1979.
[21] V . Chv ¬¥atal, ‚ÄúA greedy heuristic for the set-covering problem,‚Äù Math.
Oper . Res., vol. 4, no. 3, pp. 233‚Äì235, 1979.
591[22] R. ofÔ¨Åcial team, ‚ÄúWhat is rustdoc?‚Äù 2020. [Online]. Available:
https://doc.rust-lang.org/rustdoc/what-is-rustdoc.html
[23] R. F. Authority, ‚ÄúRust-fuzz,‚Äù 2020. [Online]. Available:
https://github.com/rust-fuzz
[24] K. Serebryany, ‚ÄúOss-fuzz - google‚Äôs continuous fuzzing service for
open source software,‚Äù V ancouver, BC, Aug. 2017. [Online]. Avail-
able: https://www.usenix.org/conference/usenixsecurity17/technical-sessions/presentation/serebryany
[25] R. ofÔ¨Åcial team, ‚ÄúAsynchronous programming in rust,‚Äù 2021. [Online].
Available: https://rust-lang.github.io/async-book/
[26] A. Fioraldi, D. C. D‚ÄôElia, and E. Coppa, ‚ÄúWEIZZ: automatic grey-
box fuzzing for structured binary formats,‚Äù in ISSTA ‚Äô20: 29th ACM
SIGSOFT International Symposium on Software Testing and Analysis,Virtual Event, USA, July 18-22, 2020. ACM, 2020, pp. 1‚Äì13.
[27] B. Mathis, R. Gopinath, and A. Zeller, ‚ÄúLearning input tokens for
effective fuzzing,‚Äù in ISSTA ‚Äô20: 29th ACM SIGSOFT International
Symposium on Software Testing and Analysis, Virtual Event, USA, July18-22, 2020. ACM, 2020, pp. 27‚Äì37.
[28] M. B ¬®ohme, V . Pham, and A. Roychoudhury, ‚ÄúCoverage-based greybox
fuzzing as markov chain,‚Äù in Proceedings of the 2016 ACM SIGSAC
Conference on Computer and Communications Security, Vienna, Austria,October 24-28, 2016. ACM, 2016, pp. 1032‚Äì1043.
[29] N. Stephens, J. Grosen, C. Salls, A. Dutcher, R. Wang, J. Corbetta,
Y . Shoshitaishvili, C. Kruegel, and G. Vigna, ‚ÄúDriller: Augmentingfuzzing through selective symbolic execution,‚Äù in 23rd Annual Network
and Distributed System Security Symposium, NDSS 2016, San Diego,California, USA, February 21-24, 2016. The Internet Society, 2016.
[30] C. Lemieux and K. Sen, ‚ÄúFairfuzz: a targeted mutation strategy for
increasing greybox fuzz testing coverage,‚Äù in Proceedings of the 33rd
ACM/IEEE International Conference on Automated Software Engineer-ing, ASE 2018, Montpellier , France, September 3-7, 2018. ACM, 2018,pp. 475‚Äì485.
[31] K. K. Ispoglou, D. Austin, V . Mohan, and M. Payer, ‚ÄúFuzzgen: Auto-
matic fuzzer generation,‚Äù in 29th USENIX Security Symposium, USENIX
Security 2020, August 12-14, 2020. USENIX Association, 2020, pp.2271‚Äì2287.
[32] M. Kelly, C. Treude, and A. Murray, ‚ÄúA case study on automated fuzz
target generation for large codebases,‚Äù in 2019 ACM/IEEE Interna-
tional Symposium on Empirical Software Engineering and Measurement,ESEM 2019, Porto de Galinhas, Recife, Brazil, September 19-20, 2019 .
IEEE, 2019, pp. 1‚Äì6.
[33] V . Atlidakis, P . Godefroid, and M. Polishchuk, ‚ÄúRestler: stateful REST
API fuzzing,‚Äù in Proceedings of the 41st International Conference on
Software Engineering, ICSE 2019, Montreal, QC, Canada, May 25-31,2019. IEEE / ACM, 2019, pp. 748‚Äì758.
[34] C. Pacheco, S. K. Lahiri, M. D. Ernst, and T. Ball, ‚ÄúFeedback-directed
random test generation,‚Äù in 29th International Conference on Software
Engineering (ICSE 2007), Minneapolis, MN, USA, May 20-26, 2007.IEEE Computer Society, 2007, pp. 75‚Äì84.
[35] W. Zheng, Q. Zhang, M. R. Lyu, and T. Xie, ‚ÄúRandom unit-test
generation with mut-aware sequence recommendation,‚Äù in ASE 2010,
25th IEEE/ACM International Conference on Automated Software En-gineering, Antwerp, Belgium, September 20-24, 2010. ACM, 2010, pp.293‚Äì296.
[36] P . Garg, F. Ivancic, G. Balakrishnan, N. Maeda, and A. Gupta,
‚ÄúFeedback-directed unit test generation for C/C++ using concolic ex-ecution,‚Äù in 35th International Conference on Software Engineering,
ICSE ‚Äô13, San Francisco, CA, USA, May 18-26, 2013. IEEE ComputerSociety, 2013, pp. 132‚Äì141.
[37] Y . Takashima, R. Martins, L. Jia, and C. S. Pasareanu, ‚ÄúSyrust: automatic
testing of rust libraries with semantic-aware program synthesis,‚Äù in PLDI
‚Äô21: 42nd ACM SIGPLAN International Conference on ProgrammingLanguage Design and Implementation, Virtual Event, Canada, June 20-25, 2021. ACM, 2021, pp. 899‚Äì913.
592