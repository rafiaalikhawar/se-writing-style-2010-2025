A Longitudinal Analysis of Bloated Java Dependencies
C√©sar Soto-Valero
KTH Royal Institute of Technology,
Sweden
cesarsv@kth.seThomas Durieux
KTH Royal Institute of Technology,
Sweden
thomas@durieux.meBenoit Baudry
KTH Royal Institute of Technology,
Sweden
baudry@kth.se
ABSTRACT
We study the evolution and impact of bloated dependencies in a
single software ecosystem: Java/Maven. Bloated dependencies are
third-party libraries that are packaged in the application binary
but are not needed to run the application. We analyze the history
of435Java projects. This historical data includes 48,469distinct
dependencies, which we study across a total of 31,515versions of
Maven dependency trees. Bloated dependencies steadily increase
over time, and 89.2 %of the direct dependencies that are bloated
remain bloated in all subsequent versions of the studied projects.
This empirical evidence suggests that developers can safely remove
a bloated dependency. We further report novel insights regarding
the unnecessary maintenance efforts induced by bloat. We find that
22 % of dependency updates performed by developers are made on
bloated dependencies, and that Dependabot suggests a similar ratio
of updates on bloated dependencies.
ACM Reference Format:
C√©sar Soto-Valero, Thomas Durieux, and Benoit Baudry. 2021. A Longitu-
dinal Analysis of Bloated Java Dependencies. In ESEC/FSE‚Äô21. ACM, New
York, NY, USA, 11 pages. https://doi.org/nnnnnnn.nnnnnnn
1 INTRODUCTION
Software is bloated. From single Unix commands [ 13] to web browsers
[22], most applications embed a part of code that is unnecessary to
their correct operation. Several debloating tools have emerged in
recent years [ 14,21,22,24,26,29] to address the security and main-
tenance issues posed by excessive code at various granularity levels.
However, these works do not analyze the evolution of bloat over
time. Understanding software bloat in the perspective of software
evolution [ 12,30,32] is crucial to promote debloating tools towards
software developers. In particular, developers, when proposed to
adapt a debloating tool, wonder if a piece of bloated code might be
needed in coming releases, or what is the actual issue with bloat.
This work proposes the first longitudinal analysis of software
bloat. We focus on bloat among software dependencies [ 4,6,10,27]
in the Java/Maven ecosystem. Bloated dependencies are software
libraries that are unnecessarily part of software projects, i.e., when
the dependency is removed from the project, it still builds success-
fully. In previous work [ 29], we showed that the Maven ecosystem
is permeated with bloated dependencies, and that they are present
Permission to make digital or hard copies of part or all of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for third-party components of this work must be honored.
For all other uses, contact the owner/author(s).
ESEC/FSE‚Äô21, August 23‚Äì27, 2021 , Athens, Greece, Virtual Event
¬©2021 Copyright held by the owner/author(s).
ACM ISBN nnnnnnn.nnnnnnn.
https://doi.org/nnnnnnn.nnnnnnneven in well maintained Java projects. Our study revealed that soft-
ware developers are keen on removing bloated dependencies, but
that removing code is a complex socio-technical decision, which
benefits from solid evidence about the actual benefits of debloating.
Motivated by these observations about bloated dependencies,
we conduct a large scale empirical study about the evolution of
these dependencies in Java projects. We analyze the emergence of
bloat, the evolution of the dependencies statuses, and the impact of
bloat on maintenance. We have collected a unique dataset of 31,515
versions of dependency trees from 435open-source Java projects.
Each version of a tree is a snapshot of one project‚Äôs dependencies,
for which we determine a status, i.e. bloated or used. We rely on
DepClean , the state-of-the-art tool to detect bloated dependencies
in Maven projects. We analyze the evolution of 48,469distinct
dependencies per project and we observe that 40,493/48,469(83.5 %)
of them are bloated at one point in time, in our dataset.
Our longitudinal analysis of bloated Java dependencies investi-
gates both the evolution of bloat, as well as the relation between
bloat and regular maintenance activities such as dependency up-
dates. We present original quantitative results regarding the evolu-
tion of bloated dependencies. We first show a clear increasing trend
in the number of bloated dependencies. Next, we investigate how
the usage status of dependencies evolves over time. This analysis
is a key contribution of our work where we demonstrate that a
dependency that is bloated is very likely to remain bloated over
subsequent versions of a project. We present the first observations
about the impact of regular maintenance activities on software
bloat. Besides, we analyze the impact of Dependabot, a popular
dependency management bot, on these activities. We show that
developers regularly update bloated dependencies, and that many
of these updates are suggested by Dependabot. Furthermore, we
systematically investigate the root of the bloat emergence, and find
that84.3 %of the bloated dependencies are bloated as soon as they
are added in the dependency tree of a project.
To summarize, the contributions of this paper are:
‚Ä¢A longitudinal analysis of software dependencies‚Äô usage in
31,515versions of Maven dependency trees. Our results con-
firm the generalized presence of bloated dependencies and
show their increase over time.
‚Ä¢A quantitative analysis of the stability of bloated dependen-
cies: 89.2 %of direct dependencies remain bloated. This is a
concrete insight that motivates debloating dependencies.
‚Ä¢A novel analysis of unnecessary updates on bloated depen-
dencies made by a software bot. We find that developers
often accept Dependabot‚Äôs suggestions without considering
if the dependency is actually used or not.
‚Ä¢A qualitative manual analysis of the origin of bloated de-
pendencies, that reveals that adding dependencies is the
principal reason that originates this type of software bloat.arXiv:2105.14226v1  [cs.SE]  29 May 2021ESEC/FSE‚Äô21, August 23‚Äì27, 2021 , Athens, Greece, Virtual Event C√©sar Soto-Valero, Thomas Durieux, and Benoit Baudry
. . .<dependencies><dependency><groupId>org.d1</groupId><artifactId>d1</artifactId><version>1.1.0</version></dependency><dependency><groupId>org.d2</groupId><artifactId>d2</artifactId><version>0.1.1</version></dependency><dependency><groupId>org.d3</groupId><artifactId>d3</artifactId><version>3.0.0</version></dependency></dependencies>. . .
Figure 1: Dependency declaration.
p
d1
d2
d3
d4
d5Direct dependency
d6Transitive dependencyDependency relationship Figure 2: Dependency tree.
pd1d2d3d4d5d6Bloated dependencyUsed dependencyUsage relationshipAPI members Figure 3: Dependency usage.
2 BACKGROUND
In this work, we consider a software project as a collection of Java
source code files and configuration files organized to be build with
Maven.1In this section, we present the key concepts for the analysis
of a project ùëùin the context of the set of its software dependencies,
denoted asD.
Definition 2.1. Maven dependency: A Maven dependency de-
fines a relationship between a project ùëùand another compiled
project ùëë‚àà D . Dependencies are compiled JAR files, uniquely
identified with a triplet ( G:A:V ) where Gis the groupId ,Ais the
artifactId , and Vis the version . Dependencies are defined
within a scope, which determines at which phase of the Maven build
cycle the dependency is required (e.g., compile ,test ,runtime ).
A Maven project declares a set of direct dependencies in a spe-
cific configuration file known as pom.xml (acronym for ‚ÄúProject
Object Model‚Äù), located at the root of the project. Figure 1 shows an
excerpt of the dependency declaration in the pom.xml of a project
ùëù. In this example, developers explicitly declare the usage of three
dependencies: ùëë1,ùëë2, and ùëë3. Note that the pom.xml of a Maven
project is a configuration file subject to constant change and evolu-
tion: developers usually commit changes to add, remove, or update
the version of a dependency.
Definition 2.2. Direct dependency: The set of direct dependen-
ciesDdirect‚äÇD of a project ùëùis the set of dependencies declared in
ùëù‚Äôspom.xml file. Direct dependencies are declared in the pom.xml
by the developers, who explicitly manifest the intention of using
the dependency.
Definition 2.3. Transitive dependency: The set of transitive de-
pendenciesDtransitive‚äÇD of a project ùëùis the set of dependencies
obtained from the transitive closure of direct dependencies. Tran-
sitive dependencies are resolved automatically by Maven, which
means that developers do not need to explicitly declare these de-
pendencies.
Definition 2.4. Dependency tree: The dependency tree of a
Maven project ùëùis a direct acyclic graph of the dependencies of
ùëù, where ùëùis the root node and the edges represent dependency
relationships between ùëùand the dependencies in D.
To construct the dependency tree, Maven relies on its specific de-
pendency resolution mechanism.2First, Maven determines the set
1https://maven.apache.org
2https://maven.apache.org/guides/introduction/introduction-to-dependency-
mechanism.htmlof declared dependencies based on the pom.xml file of the project.
Then, it fetches the JARs of the dependencies that are not present
locally from external repositories, e.g., Maven Central.3
Figure 2 illustrates the dependency tree of the project ùëù, which
pom.xml file is in Figure 1. The project has three direct dependen-
cies, as declared in its pom.xml , and three transitive dependencies,
as a result of the Maven dependency resolution mechanism. ùëë4and
ùëë5are induced transitively from ùëë1, whereas the transitive depen-
dency ùëë6is induced from ùëë3. Note that all the bytecode of these
transitive dependencies is present in the classpath of project ùëù,
and hence they will be packaged with it, whether or not they are
actually used by ùëù.
Definition 2.5. Bloated dependency: A dependency ùëë‚ààD
in a software project ùëùis said to be bloated if there is no path in
the dependency tree of ùëù, between ùëùandùëë, such that none of the
elements in the API of ùëëare used, directly or indirectly, by ùëù.
We introduced the concept of bloated dependencies in 2020 [ 29].
Although they are present in the dependency tree of software
projects, bloated dependencies are useless and, therefore, devel-
opers can consider removing them.
Definition 2.6. Dependency usage status: The usage status of
a dependency ùëë‚ààD determines if ùëëisused orbloated w.r.t. to ùëù,
at a specific time of the development of ùëù.
Figure 3 shows an hypothetical example of the dependency usage
tree of project ùëù. Suppose that ùëùdirectly calls two sets of instruc-
tions in the direct dependency ùëë1and the transitive dependency ùëë6.
Then, the subset of instructions called in ùëë1also calls instructions
inùëë4. In this case, the dependencies ùëë1,ùëë4, and ùëë6are used by ùëù,
while dependencies ùëë2,ùëë3, and ùëë5are bloated dependencies.
Figures 1, 2 and 3 illustrate the status of a project‚Äôs dependencies
at some point in time. Yet, the pom.xml file, the dependency tree,
and the status of dependencies are prone to change for several rea-
sons. For example, a dependency that was used can become bloated
after a dependency migration or after some refactoring activities
that remove the usage link between the project and some of its
dependencies. It is also possible that developers add dependencies
in the pom.xml file or that more transitive dependencies appear in
the tree, e.g., when updating the direct dependencies. This work
investigates these software evolution changes and their impact on
bloat and maintenance.
3https://mvnrepository.com/repos/centralA Longitudinal Analysis of Bloated Java Dependencies ESEC/FSE‚Äô21, August 23‚Äì27, 2021 , Athens, Greece, Virtual Event
Collect single-module Maven projects
1Filter commits that modify the pom.xml
2Analyzethe status of dependencies at each commit
3Collect
500 single-module Maven projects47,276 commits on the pom.xmlfiles31,515 dependency trees analyzedover timeFilterAnalyze
‚Ä¶
147,991 Java projects on GitHub
InputDataset
‚Ä¶time435 projects
Figure 4: Overview of our data collection pipeline. From a set of 147,991Java projects on GitHub, we analyze the usage status
of the dependencies in 435Maven projects over time, to produce a dataset of 31,515dependency trees.
3 STUDY DESIGN
In this section, we present the research protocols that we follow
to conduct our empirical study, including the research questions
(RQs), the tooling utilized to detect bloated dependencies, the data
collection, and our methodology to address each RQ.
3.1 Research Questions
In this paper, we study four different aspects of bloated dependen-
cies. Our analysis is guided by the following research questions.
RQ1 .How does the amount of bloated dependencies evolve
across releases? With this first question, we aim at consoli-
dating the body of knowledge about software bloat. Several
recent studies have shed light on the massive presence of
bloat in different types of software projects [ 5,14,21,24,26].
The growth of bloat is an important motivation for these
works. Yet, this growth has never been assessed nor quanti-
fied. Our first research question addresses this lack, analyzing
the evolution of the amount of bloat over time.
RQ2 .How does the usage status of each dependency evolve
across time? Tools that remove bloated code are designed
under the assumption that a piece of code that is bloated at
some point in time will always be bloated, hence it makes
sense to remove it. In this second research question, we
investigate whether this assumption holds true in the case of
bloated Java dependencies. We analyze how the usage status
of dependencies evolves over time, from used to bloated, or
vice versa.
RQ3 .Do developers maintain dependencies that are bloated?
Bloated dependencies needlessly waste time and resources,
e.g., space on disk, build time, performance. However, one
of the major issues related to this type of dependency is the
unnecessary maintenance effort. In this research question,
we investigate how often developers modify the pom.xml to
update dependencies that are actually bloated.
RQ4 .What development practices change the usage status
of dependencies? The emergence of bloat is due to various
code maintenance activities, e.g., refactoring the code, or
modifying the pom.xml . In this research question, we expand
the quantitative analysis of the status of each dependency
and perform an in-depth analysis of the causes of dependency
bloat.3.2 Detection of Bloated Dependencies
To analyze the status of dependencies of Maven projects, we rely on
DepClean .4This is an open-source tool that implements a practical
way of detecting bloated dependencies in the complete dependency
tree of a Java Maven project. DepClean runs a static analysis, at the
bytecode level, to detect the usage of direct and transitive depen-
dencies. To do so, DepClean constructs a static call-graph of API
members‚Äô calls among the bytecode of the project and its dependen-
cies. Then, it determines which dependencies are referenced, either
directly by the project or indirectly via transitive dependencies. If
none of the API members of a dependency are referenced, Dep-
Clean reports the dependency as bloated, i.e., the dependency is not
necessary to build the project. DepClean generates a report with
the status of each dependency, a list of API members that are used
at least once, for each used dependency. The tool also generates a
modified version of the pom.xml without bloated dependencies.
3.3 Data Collection
The dataset used in our study consists of a collection of subsequent
versions of Maven dependency trees [ 8]. Each dependency in these
trees is analyzed in order to determine its status: used or bloated.
Figure 4 summarizes the process we follow to collect this dataset.
Rounded rectangles represent procedures, non-rounded rectangles
represent intermediate data results.
‚ù∂Collect. Our data collection pipeline starts from the list of Java
projects extracted from GitHub by Loriot et al. [ 19]. The authors
queried the GitHub API on June 9th of 2020, and provide a list of
GitHub URLs including all projects that use Java as the primary
programming language. From this list, we keep only projects with
more than 5stars. This initial dataset contains a total of 147,991
Java projects. Then, we inspect the projects‚Äô files and select those
containing a single pom.xml file in the root of the repository, to
focus our longitudinal analysis on single-module Maven projects.
This first data collection step provides a set of 34,560Java projects.
‚ù∑Filter. In this second step, we check all the commits on the
pom.xml file to determine the version of the project declared in
thepom.xml . Each time the version of the project changes and it is
not a SNAPSHOT or a beta-version, we consider that the commit
represents a new release. We sort the list of projects by the num-
ber of releases and then we select the first 500projects. We focus
on release commits since a release represents a stable version of
the project, which is a suitable moment to consider the presence
4https://github.com/castor-software/depcleanESEC/FSE‚Äô21, August 23‚Äì27, 2021 , Athens, Greece, Virtual Event C√©sar Soto-Valero, Thomas Durieux, and Benoit Baudry
Table 1: Descriptive statistics of the dependencies in the 435
analyzed projects.
Min 1st Qu. Median Avg. 3rd Qu. Max
# Months 5 48.5 75.5 81.01 109.5 235
# Analyzed commits 2 41.0 58.0 73.51 79.0 819
# Direct initial 0 3.0 5.0 8.28 10.0 120
# Transitive initial 0 2.0 10.5 46.77 56.0 300
# Direct final 0 5.0 10.0 13.97 18.0 111
# Transitive final 0 6.5 25.0 66.56 82.5 515
of bloated dependencies. In addition to the project releases, we
collect the commits that have been created by Dependabot,5a pop-
ular software bot that automatizes the update of dependencies on
GitHub [ 7]. The goal is to determine how many bloated dependen-
cies have been updated as a result of a pull request not made by a
human. We identify 2,017Dependabot commits for 143/500(28.6 %)
projects. At the end of this step, we have a total of 500projects, as
well as 49,293commits, including 47,276release commits.
‚ù∏Analyze. The final and most complex step in our pipeline is
to analyze the status of dependencies in the 49,293commits. We
perform the following tasks: 1) clone the repository and checkout
the commit, 2) compile the project using Maven, 3) if the project
compiles, then we execute DepClean on the commit to obtain the
dependency usage status. We analyze dependencies that have a
compile ortest scope. The compilation task is the most crucial
and difficult task because it involves downloading dependencies,
having the correct version of Java and having a proper project state,
i.e., the Java code needs to be valid. We mitigate those problems
by compiling the projects with Java 11 and then with Java 8. By
trying to compile with Java 8 when the project does not compile
with Java 11, we increase the number of successful compilations
by around 20 %. We also use a proxy for Maven that caches and
looks for dependencies in five different repositories to increase
the chances to resolve them. In total, the proxy cached 198,611
dependencies and 165Gbof data. As side effects, the proxy speeds
up the resolution of dependencies and increases the reproducibility
of the study, i.e., Maven will always resolve the same dependencies
even if we recompile the projects after several years.
This final step of our pipeline outputs the definitive dataset for
our longitudinal study: the dependency usage trees of 31,515(63.9 %)
commits collected from 435(87.0 %) projects. These trees capture
the history of 48,469dependency relationships, including 1,987
direct dependencies and 23,442transitive dependencies. Among the
commits, 29,822(63.1 %) are project releases and 1,693(83.9 %) are
Dependabot commits. We have kept only the projects for which
we can successfully analyze at least two dependency tree versions.
The dataset consists of a JSON file per commit for each project,
containing the status of each dependency at every point in time. The
dataset and the scripts are available in our experiment repository.6
Table 1 shows descriptive statistics of our dataset. The 435 projects
have been active for periods ranging from five months to 235
months (12 years and 7 months), with most of them in the range
48.5months (1st Qu.) to 109.5months (3rd Qu.). The number of
dependency trees analyzed for each project ranges from 2to819
(Median = 58, 1st Qu. = 41, 3rd Qu. = 79). The table also reports
5https://dependabot.com
6https://github.com/castor-software/longitudinal-bloatthe number of direct dependencies in the oldest analyzed commit
(Median = 5, 1st Qu. = 3, 3rd Qu. = 10), and transitive dependencies
(Median = 10.5, 1st Qu. = 2, 3rd Qu. = 56). The last two lines in the
table give the number of direct dependencies in the most recent
analyzed commit (Median = 10, 1st Qu. = 5, 3rd Qu. = 18), and
transitive dependencies (Median = 25, 1st Qu. = 6.5, 3rd Qu. = 82.5).
3.4 Methodology for RQ1
In RQ1, we analyze the evolution of the number of bloated depen-
dencies over time. We start with a global analysis of the bloat trend
in direct and transitive dependencies. To do so, we aggregate the
total number of bloated dependencies in all projects on a monthly
basis and compute the average values. Next, we look at each project
separately and assign a bloat evolution trend to each of them. We
represent the number of dependencies at each commit in a project
as a time series. Let ùëùbe a Maven project, Bùëù=ùëè1, ùëè2, ...ùëèùëõrepre-
sents a time series of length ùëõ. A time step in this series represents
one commit that modifies the pom.xml ofùëù. Each ùëèùëñis the total
number of bloated dependencies reported by DepClean at the ùëñùë°‚Ñé
commit on the pom.xml . We collect two series for each project, for
bloated-direct and bloated-transitive dependencies.
For each project ùëù, we determine the overall trend for the evolu-
tion of the number of bloated dependencies: increase, decrease or
stable. The following function over Bùëùshows how we determine
the trend for a project:
ùëì(Bùëù)=Ô£±Ô£¥Ô£¥Ô£¥ Ô£≤
Ô£¥Ô£¥Ô£¥Ô£≥inc ifùë†ùëôùëúùëùùëí(ùëôùëö(Bùëù))>0‚àß‚àÉùëèùëó‚ààBùëù:ùëèùëó<ùëèùëó‚àí1
dec ifùë†ùëôùëúùëùùëí(ùëôùëö(Bùëù))<0‚àß‚àÉùëèùëó‚ààBùëù:ùëèùëó>ùëèùëó‚àí1
stable if‚àÄùëèùëñ‚ààBùëù:ùëèùëñ=ùëèùëñ‚àí1
We notice that several projects do not have a monotonic trend
in the number of bloated dependencies (i.e. the value increases
and decreases at different time intervals). To account for projects
that have a non-monotonic number of bloated dependencies, we
fit a simple linear regression model, denoted as lm, and determine
the trend of the time series based on the sign of the slope of the
regression line. A project labelled as incis a project for which the
sign of the slope is positive, i.e., the number of bloated dependencies
increase over time. A project labelled as decis a project for which the
sign of the slope is negative, i.e., the number of bloated dependencies
decreases over time. If the number of bloated dependencies is the
same across all the data points in the time series of a project, we
label it as stable .
3.5 Methodology for RQ2
In this research question, we analyze the evolution of the usage sta-
tus of the 48,469dependencies in our dataset. Given a dependency
ùëë‚ààD, present in the dependency tree of a project ùëù, we collect the
status of ùëëat each analyzed commit (see data collection Section 3.3).
This provides a sequence of usage statuses for ùëëand serves as the
basis to determine the occurrence of transitional patterns between
used and bloated statuses.
LetVùëëbe a vector representing the history of usage statuses of
dependency ùëëacross the releases of a project, where each release
is ordered by its date. We label the usage status of a dependency ùëë
asBif it is a bloated dependency, or Uif it is a used dependency.A Longitudinal Analysis of Bloated Java Dependencies ESEC/FSE‚Äô21, August 23‚Äì27, 2021 , Athens, Greece, Virtual Event
1.0.01.1.01.1.12.0.0UsedBloated
timeDependency status
Figure 5: Example of a dependency analyzed over time. It
has a transition of usage status: from used at version 1.1.0 to
bloated at 1.1.1 (RQ2). The dependency has two subsequent
updates after bloated: at versions 1.1.1 and 2.0.0 (RQ3).
Figure 5 illustrates a transition in the usage status of a depen-
dency from used ( U) to bloated ( B). In this case, the dependency
is identified as used at the two first releases of the project, then it
becomes bloated at the third release, and stays as such. Therefore,
the usage pattern for this dependency results in [U,U,B,B]. Since
we are interested in analyzing transitional patterns, the consecutive
elements of the same category in the vector can be compressed to
a single status, e.g., the previous example is represented as [U,B].
In this research question, we focus on analysing the occurrence
of five transitional patterns: [U],[B],[U,B],[B,U], and fluctuating .
In the cases where the usage status of a dependency flickers over
time, we consider the status of the dependency as fluctuating .
3.6 Methodology for RQ3
We conjecture that developers could save some maintenance efforts
in the absence of bloated dependencies. In this research question,
we investigate how many times developers update the version of
dependencies that are in fact bloated. This type of change in the
pom.xml of a project is an unnecessary engineering effort that
could be avoided. We analyze two types of commits: the commits
where the developers update the version of the project to a new sta-
ble version (e.g., 1.0.0), and the Dependabot commits. Dependabot7
is a dependency management bot very active on GitHub. It cre-
ates pull requests that update the dependencies to remove known
vulnerabilities. Dependabot was launched on May 26, 2017 with
support for Ruby and JavaScript, and now it is supporting more
than ten languages, including Java since August, 2018.
We analyze Dependabot commits because they only contain edits
on the dependency versions in the pom.xml . It provides a clean
point of analysis to detect the impact of a dependency update. And
it allows us to study how many bloated dependencies are updated
by developers as a result of the suggestion of automatic bots.
Figure 5 illustrates a typical case of a dependency that continues
to be updated even after it becomes bloated. The dependency is
used by the project until version 1.1.0. Afterward, the dependency
is no longer used, but it is still updated twice, to version 1.1.1 and
then to version 2.0.0.
To answer this research question, we consider the 15,230com-
mits in our dataset that perform dependency updates in projects
that have at least one Dependabot commit. We obtain the number of
times a dependency is updated by a developer, by Dependabot, and
how many of those updates are performed on bloated dependencies.
For the dependency usage analysis, we tag each dependency as
used or bloated. We count every time the version of a direct depen-
dency is updated, and we count separately the number of updates
7https://dependabot.comapplied on bloated dependencies. In the example of Figure 5, we
count one update on a used dependency (when the used depen-
dency is updated to version 1.1.0), and two updates on a bloated
dependency (when the bloated dependency is updated to version
1.1.1 and version 2.0.0). Using this approach, we can compare the
ratio of updates made by developers and by Dependabot.
3.7 Methodology for RQ4
In this research question, we investigate the origins of bloated
dependencies. Each time a bloated dependency appears for the first
time in a project‚Äôs history, we first determine if it was used in the
commit that immediately precedes the apparition of bloat. If the
dependency was used in the previous commits, we determine in
which class it was used. By analyzing a dependency at the time it
appears as bloated, we can identify what causes the emergence of
bloat. We have identified four different situations:
(1)New dependency ( ND): The bloated dependency was not present
in the previously analyzed commit. It indicates that the depen-
dency was introduced in the project but never used.
(2)Removed code ( RC): The bloated dependency was present in
the previously analyzed commit and all the classes where the
dependency was used are removed.
(3)Updated code ( UC): The bloated dependency was present in the
previously analyzed commit, yet at least one class where the
dependency was used is still present in this commit. It means
that the code has been updated to remove the usage of the
dependency but the pom.xml still contains the dependency.
(4)New version ( NV): The bloated dependency was present in the
previously analyzed commit and the version of the dependency
changed. In the case of transitive dependency, the parent de-
pendency has been updated and the project does not use the
transitive dependency anymore.
For each of the 31,515dependency trees, we identify the bloated
dependencies. Then, we check the status of the dependency in the
previous commit. If the dependency is not present in the previous
commit, we consider the origin as ND. Otherwise, we check in the
previous commit in which classes the bloated dependency is used.
We then compare those classes with the new commit. If all classes
are removed, we consider the origin of the bloat as RC. If at least
one of the classes is still present, we consider the origin of the
bloat as UC. Additionally, we compare the version of the bloated
dependency with the previous commit. If the version changes, and
at least one class is still present, we mark the origin as UCandNV,
since both reasons could be the origin of the bloat.
4 RESULTS
In this section, we answer the four RQs presented in Section 3.1.
4.1 RQ1. Bloat Trend
In this research question, we analyze the evolution of the number of
bloated dependencies over time. We hypothesize that this number
tends to grow. Following the protocol described in Section 3.3, we
analyze the usage status of each dependencies in 31,515dependency
trees along the history of 435projects, as reported by DepClean .
We assign bloat trend labels to each project, according to the three
categories defined in Section 3.4.ESEC/FSE‚Äô21, August 23‚Äì27, 2021 , Athens, Greece, Virtual Event C√©sar Soto-Valero, Thomas Durieux, and Benoit Baudry
Figure 6 shows the monthly evolution trend of the number of
bloated-direct and bloated-transitive dependencies, from January
2011 to November 2020. The y-axis is the average number of bloated
dependencies of the 435projects. Each data point represents the
average of bloat measured each month. The lines represent linear
regression functions, fitted to show the trend of bloated-direct and
bloated-transitive dependencies, at a 95%confidence interval.
We observe that bloated-transitive dependencies have a clear ten-
dency to grow over time, whereas bloated-direct dependencies grow
at significantly lower pace. For example, the number of bloated-
transitive dependencies in 2011 was 1,695, and by the end 2020 this
number grew up to 286,228 (increase > 250√ó). The bloat is more
pervasive and variable (SD = 17.2) among transitive dependencies,
representing a larger share in comparison with direct dependencies
that are less numerous and less variable (SD = 1.3). We conclude
that, overall, the amount of bloat increases, being more notable for
transitive dependencies.
0
20
40
60
80
2012
2014
2016
2018
2020
Date
Avg. # of bloated dependencies
Dependency
bloated-direct
bloated-transitive
Figure 6: Trend of the average number of bloated-direct and
bloated-transitive dependencies per month.
Figure 6 shows an overall growing trend for the number of
bloated dependencies. Now, we look in more details at each project
separately. We count the number of projects that have different
trend of bloated dependencies. Figure 7 shows examples of time
series of projects in our dataset for which the bloated-direct de-
pendencies are labelled according to each category (increasing,
decreasing, and stable). The name of the projects correspond to
the < user>/<repository > on GitHub. The x-axis is the date of the
analyzed commits. The y-axis represents the number of bloated
dependencies detected. For instance, the time series of the project
zapr-oss/druidry has a total of 51commits on the pom.xml (i.e.,
data points in the time series), and it is labelled as incw.r.t. to both
the direct and transitive dependencies because both series tend to
continuously increase over time.
Figure 8 shows the distribution of the trend of bloated-direct and
bloated-transitive dependencies. The x-axis indicates the number of
projects with bloated-direct dependencies in each specific evolution
trend, given on the y-axis. Each bar in the plot is partitioned in three
parts that correspond to the share of projects with a given trend for
the number of bloated-transitive dependencies. For example, the top
bar of Figure 8 shows (i) that the number of bloated-direct depen-
dencies tends to increase for 245(56.3 %) projects; and (ii) among
these 245projects, 180also have a number of bloated-transitive
dependencies that tends to increases, 59of these projects have a de-
creasing number of bloated-transitive dependencies and 6projects
have a stable number of bloated-transitive dependencies. The bar in
2
2
2
2
3
3
3
3
3
4
4
zapr-oss/druidry
sonian/elasticsearch-jeÓÄºy
percy/percy-java-selenium
2
2
3
3
4
4
# bloated-direct
Trend
inc
dec
stable
20
20
21
21
22
22
16
18
20
22
24
26
2018
2019
2020
2012
2013
2014
2015
2016
2017
2018
2019
2020
2019
2020
5
10
15
20
Date
# bloated-transitiveFigure 7: Example of projects in the three classes of bloat
trend defined in Section 3.4.
the middle of the figure indicates that the number of bloated-direct
dependencies tends to decrease for 106(24.4 %) projects and the
bottom bar shows that this type of bloat is stable for 84(19.3 %)
projects because no new bloated dependencies are introduced in
thepom.xml .
Looking at the partitions of each bar in Figure 8, we first observe
that whatever the trend for the number of bloated-direct dependen-
cies, the number of bloated-transitive dependencies can evolve in
any way. Yet, the majority of projects have an increasing number
of bloated dependencies among their transitive dependencies. In
total, 286(65.7 %) projects have an increasing number of bloated-
transitive, whereas for 113(26.0 %) projects this number decreases.
The number of projects with stable transitive-dependencies, 36
(8.3 %), is relatively low.
Interestingly, from the 84projects with a stable number of bloated-
direct dependencies, 41(48.8 %) of the bloated-transitive depen-
dencies increase and 18(21.4 %) decreases (e.g., as in the project
percy/percy-java-selenium in Figure 7). This result indicates that
the usage status of dependencies change regardless of the mod-
ification of the pom.xml . The transition from used to bloated in
transitive dependencies becomes unnoticed. In other words, even if
developers update only the version of direct dependencies, without
doing anything else, then the bloat grows naturally due to the in-
flation of the rest of the dependency tree. It happens, for example,
41
18
25
65
36
5
180
59
6
stable
dec
inc
0
50
100
150
200
250
#Projects
Bloated-direct trend
Bloated-transitive trend
inc
dec
stable
Figure 8: Distribution of the number of projects with in-
creasing, decreasing, and stable trend of bloated-direct and
bloated-transitive dependencies.A Longitudinal Analysis of Bloated Java Dependencies ESEC/FSE‚Äô21, August 23‚Äì27, 2021 , Athens, Greece, Virtual Event
in the project jpmml/jpmml-sparkml when a developer updates
spark-mllib_2.11 from version 2.0.0 to 2.2.0, introducing 133
new transitives dependencies.
On the other hand, we observe that for 65(61.3 %) out of the 106
projects with a decreasing number of bloated-direct dependencies,
the number of bloated-transitive increases. It indicates that even in
projects for which direct dependencies decreases, the number of
bloated-transitive dependencies can increase and eventually lead
to a global growth of bloated dependencies for the project.
Answer to RQ1: The number of bloated-direct dependencies
and bloated-transitive dependencies increases over time for
56.3 %and65.7 %of the projects, respectively. This result sug-
gests that bloated dependencies tend to naturally emerge and
grow through software evolution and maintenance.
4.2 RQ2. Usage Patterns
This research question addresses an essential concern when devel-
opers think about removing bloat: is a piece of software identified as
bloat at one point in time prone to usage in future revisions? We an-
swer this question through a post-mortem analysis of the transition-
ing in the usage status of dependencies across the evolution of the
studied projects. Our hypothesis is that dependencies do not change
their usage status very frequently, i.e., a dependency that is used
in one commit is used in future commits, and similarly for bloated
dependencies. If our hypothesis holds, then it indicates that devel-
opers can be more confident when removing bloated dependencies.
We analyzed the five usage patterns described in Section 3.5. ??
shows one concrete example for each pattern. The examples are
taken from our dataset and the patterns are illustrated on the period
January 2017 to December 2020. The y-axis shows the name of the
direct dependency, with the pattern in square brackets. For exam-
ple, we analyze the usage status of the direct dependency h2in the
project dieselpoint/norm, from May 2018 to October 2020. As we can
observe, this dependency was always reported as bloated. On the
other hand, the dependency json in project PAXSTORE/paxstore-
openapi-java-sdk was reported as bloated in first four analyzed
commits, September 2018 to November 2019, and then it was used
in all the subsequent releases of the project.
Figure 10 shows the distribution of the five transitional usage
patterns among the 1,987direct and 23,442transitive dependencies
in our dataset. The x-axis represents the percentage of occurrence
of each pattern with respect to the total. The top bar of the plot
indicates that 64.3 %of the direct dependencies are used through
their whole lifespan, whereas 29.9 %are always bloated. This means
that94.2 %of direct dependencies never change their status through
the evolution of the software projects. This also means that most
bloated-direct dependencies are bloated by the time they are added
in the dependency tree and are likely to remain bloated forever. We
conjecture that this happens as a side effect of some development
practices, such as copy-pasting of pom.xml files, the use of Maven
Archetypes, or the deliberate addition of dependencies when setting
up the development environment.
The bottom bar of the plot shows a similar stability for the status
of transitive dependencies: 91.1% of transitive dependencies do not
change their usage status over their lifespan. A key difference hereis that most of the dependencies are always bloated: 78.3% of the
transitive dependencies are bloated from the start, whereas 12.8%
are always used. We hypothesize that most transitive dependencies
are unnoticed by the developers. Consequently, they are not man-
aged and stay in the dependency tree for no reason in most cases.
guava [fluctuating]
json [BU]
hÓÄºpmime [UB]
h2 [B]
commons-lang [U]
2017
2018
2019
2020
Date
Dependency
Usage status
U
B
Figure 9: Example of direct dependencies with distinct usage
patterns. Each dependency belongs to a different project, the
status of the dependency is analyzed at each commit that
changes the pom.xml of the project.
A key motivation for this research question is to determine
whether a dependency identified as bloated is likely to stay bloated.
We compute the percentage of dependencies bloated from the start
(B) or that remain bloated after being used ( UB), with respect to the
total number of dependencies that are bloated at some point in the
future, i.e., ( B+UB)/(B+UB+BU+fluctuating ). We find that 89.2 %of
bloated-direct dependencies and 93.3 %of bloated-transitive depen-
dencies remain bloated over time.
64.3%
29.9%
5.8%
78.3%
12.8%
8.9%
Transitive
Direct
0%
25%
50%
75%
100%
Percentage of occurrence
Dependency type
PaÓÄºern
B
U
BU
UB
fluctuating
Figure 10: Percentage of occurrence of usage patterns of
bloated-direct and bloated-transitive dependencies.
Answer to RQ2: The usage status is mostly constant over
time: 94.2% of the direct and of 91.1% of the transitive depen-
dencies do not change status through their lifespan i.e. they
are either always used or always bloated. When a dependency
is detected as bloated, it stays bloated in 89.2 %of the cases if
it is direct, and 93.3 %if is transitive. This indicates that devel-
opers can confidently take a debloating action when detecting
bloated dependencies.
4.3 RQ3. Unnecessary Updates
In this research question, we investigate how the update of depen-
dencies, a regular maintenance practice for all software projects,
more and more encouraged by automatic bots, relates to bloatedESEC/FSE‚Äô21, August 23‚Äì27, 2021 , Athens, Greece, Virtual Event C√©sar Soto-Valero, Thomas Durieux, and Benoit Baudry
0 2,000 4,000 6,000 8,000 10,0009,403 (77.96%)
2,659 (22.04%)
# Direct dependency updatesDevelopers updates on used dependencies Developers updates on bloated dependencies
Figure 11: Number of updates made by developers on direct
dependencies in projects that use Dependabot.
0 500 1,000 1,500 2,000 2,5002,452 (77.4%)
716 (22.6%)
# Direct dependency updatesDependabot updates on used dependencies Dependabot updates on bloated dependencies
Figure 12: Number of updates made by Dependabot on direct
dependencies in projects that use Dependabot.
dependencies. We hypothesize that developers invest some effort
in updating some of these dependencies, while this is not required.
To verify this hypothesis, we count how many times bloated-direct
dependencies are updated in the pom.xml and compare it to the
number of updates of used-direct dependencies. The methodology
for this count is described in Section 3.6. We analyze separately the
updates performed manually by developers and the updates sug-
gested by Dependabot that are eventually accepted by a developer.
Figures 11 and 12 present our main results for this research ques-
tion. Those plots present the number of dependency updates on
direct dependencies made by developers and by Dependabot re-
spectively. We focus on the 143projects in our dataset that have at
least one Dependabot commit. All the projects do not use Depend-
abot since its Java support is relatively recent (August 2018). The
total number of updates on direct dependencies in these projects
is15,230, of which 12,062have been performed by humans and
3,168have been suggested by Dependabot.
Figure 11 shows that, over a total of 12,062updates on direct
dependencies made by developers, 9,403(78.0 %) are preformed on
used dependencies, and 2,659(22.0 %) are made on bloated depen-
dencies. These 2,659unnecessary updates represent a significant
effort, as updating dependencies is a non trivial maintenance task
[16]. Figure 12 shows the number of updates on direct dependencies
made by accepting a suggestion from Dependabot. From Figure 12,
2,452(77.4 %) of Dependabot updates are performed on non-bloated
dependencies and 716(22.6 %) on bloated dependencies. Overall,
we observe that developers perform a significantly larger number
of dependency updates than Dependabot. Yet, the most interesting
fact is that developers and Dependabot perform the same ratio of
updates on bloated dependencies, 22.0 %and22.6 %respectively.
The consequences of updating a bloated dependency are not
only about the time and effort wasted by the developer. We have
observed that a possible side-effect of these unnecessary updates
is the increase of the total number of bloated dependencies in the
project. In RQ1, we showed that the number of bloated dependenciesincreases over time, with a strong trend for transitive dependencies.
In fact, a portion of this increasing transitive bloat is introduced
through the update of direct dependencies, i.e., the new version
has more dependencies. Note that this scenario can happen even
when updating a bloated-direct dependency. We have observed
this phenomenon in our dataset. The 6,091updates on bloated-
direct dependencies have introduced 1,883new bloated-transitive
dependencies.
Answer to RQ3: 22.0 %of developer updates and 22.6 %of
Dependabot accepted updates are performed on bloated-direct
dependencies, which represents a total of 6,091updates over
143projects. This is novel evidence that software bloat artifi-
cially increases maintenance effort and that dependency bots
need to be improved to detect bloated dependencies.
4.4 RQ4. Bloat Origin
In this research question, we investigate what type of maintenance
activity is at the origin of bloat emergence. In other words, we per-
form an in-depth analysis of the usage patterns BandUBpresented
in RQ2 by categorizing the origin of the bloat in four possible activ-
ities: new dependency ( ND), removed code ( RC), updated code ( UC),
and new version ( NV) as described in Section 3.7. Table 2 summa-
rizes the number of occurrences of activities that introduce bloat for
direct and transitive dependencies. In total, we analyze the 25,359
dependencies that become bloated at some point in time ( 1,987
directs, 23,442transitives) and determine in what condition they
become bloated. This corresponds to 2,215and34,071transitions
to bloat, on direct and transitive dependencies respectively.
We observe that the primary origin of bloat is the addition of
new dependencies ND, with 1,868(84.3 %) such additions that lead
to more bloated-direct dependencies and 33,370(97.9 %) new de-
pendencies that introduce more bloated-transitive dependencies.
This result confirms our findings in RQ2, where we observed that
the status of most dependencies does not change over time, which
hinted to the fact that bloated dependencies are bloated as soon as
they appear in the dependency tree. Additionally, the larger num-
ber of NDthat grow the number bloated-transitive dependencies is
consistent with the results of RQ1, where we showed a larger in-
crease of bloated-transitive dependencies than bloated-direct ones.
This new result consolidates the finding with the root cause of
the transitive bloat. The second most frequent origin of bloated
dependencies is different for direct and transitive dependencies.
The action of removing code RCis the second most frequent cause
of the emergence of bloated-direct dependencies, with 8,8%of the
cases. Updating code UCis the second most important root cause
for bloated-transitive dependencies. While these two actions are
similar in nature (evolve the code base), we did not find a clear expla-
nation for the difference between the types of bloated dependencies.
Updating to a new version of a dependency NVis the least frequent
cause of bloat emergence. The rarity of this cause is explained by
the fact that it can only happen in very specific conditions, when
the new version of the dependency changes drastically.
We now illustrate the different situations of bloat introduction
with real-world case studies observed in our dataset. The mostA Longitudinal Analysis of Bloated Java Dependencies ESEC/FSE‚Äô21, August 23‚Äì27, 2021 , Athens, Greece, Virtual Event
Table 2: Number of occurrence for each origin of bloat. The
occurrences are separated between the new bloated-direct
and transitive dependencies.
Origin Bloated-direct Bloated-transitive
New dependency ( ND)1,868(84.3 %) 33,370(97.9 %)
Removed code ( RC) 194(8.8 %) 206(0.6 %)
Updated code ( UC) 153(6.9 %) 495(1.5 %)
New version ( NV) 47(2.1 %) 124(0.4 %)
frequent cause of bloat introduction is a new transitive depen-
dency in the dependency tree ( ND), which is never used. For exam-
ple, this happens in the project couchbase/couchbase-java-client
at the commit 47ac44, where the dependency jackson-databind ,
which is induced transitively when encryption:1.0.0 has been
added to the pom.xml .jackson-databind is used in the class
HashicorpVaultKeyStoreProvider which is never used by the
couchbase/couchbase-java-client and, therefore, jackson-databind
is a bloated-transitive dependency in this project.
This case occurs with direct dependencies as well. For example,
the direct dependency jackson-core is added as a direct depen-
dency in the pom.xml of project jenkinsci/elasticbox-plugin, at
commit 008358. Yet, the dependency is never used in the code of the
project. One year and 4 months later a pull-request, #41, fixes the
bloat issue by removing the dependency directly. However, at the
time of writing this paper, the pull-request has not been merged.
Projects are evolving, adding and removing code is part of the
life cycle of a project. A consequence of code removal can be to
eliminate the need for a dependency. Yet, developers currently have
no tool support to determine that a dependency can also be removed
as part of their maintenance activities. Consequently, the depen-
dency is likely to become bloated ( RC). For example, we observed
that scenario happens in the project apache/commons-lang. The
commit def3c4 introduces the dependency bcel , which contains an-
notations to document thread safety. However, the commit 796b05
removes all classes where these annotations were used. According
to the commit, more discussions were needed to design the annota-
tion, and the maintainers reverted partially the changes to release
a new version. A developer removed the bloated dependency after
five months (see commit 66226e).
A similar scenario occurs when developers update classes ( UC).
For example, the commit 62aad3 introduces the annotation Ignore
JRERequirement on a method in the project jenkinsci/remoting.
However, this method is updated and deprecated in the commit
49c67e. The annotation IgnoreJRERequirement is removed and
the dependency animal-sniffer-annotation became bloated.
The project apache/commons-dbcp contains an interesting case
of bloat introduced when a dependency is updated ( NV). In the
commit 3550ad, the direct dependency geronimo-transaction
is detected as bloated. However, this dependency was not bloated
in the previous commit d7aa66, when the project was using the ver-
sion1.2-beta ofgeronimo-transaction . The dependency was
updated to version 2.2.1 with commit 3550ad. This new version
brought major changes in the dependency and, in 2.2.1 , all the
classes used by the project had been move in a transitive depen-
dency of geronimo-transaction . Therefore, the direct depen-
dency towards geronimo-transaction became bloated.Answer to RQ4: The addition of new dependencies is the
root cause of the emergence of 84.3 %of the bloated-direct de-
pendencies. Still, 15.7 %of the cases appear after code updates
or removals. This indicates that new dependencies should be
carefully reviewed the first time they are added, and we rec-
ommend developers to check the usage status of dependencies
when removing code.
5 IMPLICATIONS
Our findings provide practical, empirically justified implications for
improving dependency management [ 6,10]. The results of RQ1 and
RQ2 show that bloated dependencies are likely to remain bloated in
the future. This is empirical evidence that can motivate developers
and increase their confidence when they are faced with the oppor-
tunity to remove bloated dependencies. Motivation comes from
the benefits associated with reducing the number of dependencies
of the project and hence reduce associated maintenance activities.
Confidence comes with the strong likelihood that the dependency
that is removed will not be necessary in the future.
Our results show that there exist many practical difficulties re-
lated to the way of handling software dependencies. This can raise
the awareness of developers about the importance of understand-
ing what dependencies are more likely to become bloated, and
how their projects can reduce the size of dependency trees without
breaking the build. In particular, the use of tools, such as Dep-
Clean , to automatically detect and suggest changes in the build
files can contribute to a better awareness of developers about the
state of their dependencies. For example, we recommend to include
a bloat analysis before release to ensure that no bloat is shipped
and deployed. This is for reducing the size of the released binary
and for all projects that depend on it, i.e., the number of transitive
dependencies will be reduced.
In RQ3, we present original results of the negative impact of
bloated dependencies on the maintenance of the projects. In par-
ticular, we shed a new light on the limitations of dependency bots,
such as Dependabot, and provide evidence that developers accept
bots‚Äô suggestions when updating dependencies without checking
if the dependency is actually used. Bot creators should consider
improving their tools to automatically detect bloat and suggest
the removal of unused dependencies. On the same line, compil-
ers and IDEs should also warn developers when dependencies are
not used anymore and when a dependency is introduced without
encountering its counterpart usage on code.
Our dataset and our case studies on the origin of bloat provide
valuable references for the rapid identification of practices that
result in dependency bloat. Those references can be used to build
dedicated bots that ask for additional checks, e.g. when a new de-
pendency appears in the dependency tree, or to establish guidelines
for developers when they maintain pom.xml files.
6 THREATS TO VALIDITY
Internal Validity. The first internal threat relates to the detec-
tion of bloated dependencies. The results of our study are tied to
the accuracy of DepClean to find bloated dependencies in Maven
projects. This tool is based on advanced static analysis. Therefore,
some usages that rely on Java dynamic features might be missed,ESEC/FSE‚Äô21, August 23‚Äì27, 2021 , Athens, Greece, Virtual Event C√©sar Soto-Valero, Thomas Durieux, and Benoit Baudry
reporting some used dependencies as bloated. For example, lombok
is a Java library that relies on annotations to manipulate the byte-
code at compilation time, adding boilerplate code constructs such
as getters and setters. This mechanism makes the dependency to be
flagged as bloated by DepClean , since no reference to this depen-
dency remains in the bytecode of the compiled project. Nevertheless,
we consider that DepClean is a solid tool, evaluated on millions
of dependencies, used in industry, and developers have removed
hundreds of bloated dependencies thanks to its analysis [ 29]. The
second threat relates to the representativeness of the data and the
analysis performed. We mitigate those threats by collecting a large
dataset of projects from multiple domains and released across sev-
eral years. This allows us to draw general conclusions about the
evolutionary trend of bloated dependencies, regardless of the exis-
tence of some false positives, which are known to be hard to detect
using static analysis [17, 18, 25].
External Validity. When conducting this study, we focus on
bloated Java dependencies in projects that build with Maven. As
explained in Section 3.3, the analysis of the dependency trees of 435
projects requires compiling and analyzing the bytecode at different
time periods. There were cases where the compilation failed for
several reasons, making it difficult to obtain the complete history of
dependency changes. As we consider a large number of open-source
projects, we believe our results are generalizable in this specific
domain. Meanwhile, additional studies with proprietary projects or
other programming languages should be considered to consolidate
these very first result about software bloat evolution.
Construct Validity. This threat is related to the rationality of
the questions asked. We investigate the evolution of bloated depen-
dencies over time. To achieve this goal, we focus on four aspects:
bloat trend, usage patterns, unnecessary updates, and bloat origins.
We believe that these are rational questions that provide unique
and novel insights for researchers and developers.
7 RELATED WORK
Software Bloat. Previous research on software bloat has mainly
focused on reducing C/C++ binaries to mitigate the security risks
associated with unnecessary code [ 21,23,26]. Holzmann [ 13] re-
ports the historical growth in the size of the true command in Unix
systems. Similarly, we observed that the number of bloated depen-
dencies tends to grow over time, whether or not there is a need
for it. In the last years, there is a recent resurgence of interest in
debloating Java bytecode [ 5,14,20,28,29]. These tools remove Java
bytecode using static and dynamic analysis. In contrast, our study
focuses on the evolution and the emergence of bloat in Java projects,
while spotting some of the current research gaps and tooling for
effective dependency management. Other studies have focused on
eliminating bloat in source code [ 33], binary shared libraries [ 1],
highly configurable programs [ 15], or containers [ 24]. Other works
have focused on improving the debloat process through various
optimizations techniques [ 2,3,11,31,35]. As far as we know, we
are the first to conduct a longitudinal study to analyze software
bloat.
Bloated Dependencies. Our work follows up on our previous
study of bloated dependencies [ 29]. Our quantitative and qualitative
study of bloated dependencies in the Maven ecosystem, revealed theimportance of the phenomenon in Maven Central. Our interactions
with software developers showed that removing bloated dependen-
cies is perceived as a valuable contribution. Here we extend this
previous study in two ways. First, we perform a study of bloated
dependencies with distinct study subjects on a chronological basis.
This brings novel insights on the evolution of bloated dependen-
cies through the history of software projects, corroborating the
importance of maintaining pom.xml files. We bring novel evidence
in favor of removing bloated dependencies. Second, we perform a
unique study on the interaction between maintenance activities and
the emergence of bloat. These new results contribute to understand-
ing the origin of bloat as well as estimating the maintenance effort
unnecessarily invested when performing dependency updates.
Software Bots. Erlenhov et al. [ 9] perform an empirical study
about the interaction between practitioners and software bots. They
found that there is currently a lack of general-purpose smart bots
that go beyond simple automation tools, such as dependency ver-
sion updating. This is in line with our results, as we have seen
that dependency bots do not perform advanced dependency usage
analysis, sending unnecessary warnings that could be avoided. Wes-
sel et al. [ 34] rise attention on the inconvenient side of software
bots. They present empirical evidence that pull requests made by
bots are, in some cases, perceived as disruptive and unwelcoming
by developers. Thus, motivating our work on reducing the num-
ber of warnings caused by bots dedicated to automatically update
dependencies.
8 CONCLUSION
This paper presented the first large-scale longitudinal study about
the evolution of software bloat, with a focus on bloated Java de-
pendencies. We collected a unique dataset of 31,515dependency
tree versions, tagged with usage dependency status, from 435Java
projects hosted on GitHub. Through the analysis of 48,469depen-
dencies, we provided evidence about an essential phenomenon:
89.2 %of the dependencies that become bloated over evolution stay
bloated over time. As a consequence, developers spend significant
time updating dependencies that are actually bloated. We find that
22 % of dependency updates are made on bloated dependencies.
These updates include a significant number of updates suggested
by Dependabot. We also demonstrate that bloated dependencies
are primarily originated from the addition of new dependencies
that are never used, rather than from code changes.
Our work paves the way to better understand the importance
of debloating tools, such as DepClean , to handle the increasing
phenomenon of software bloat. In particular, evidence that bloated
code stays bloated is important for developers who need to decide
if they should remove code. Our novel findings about the role
of Dependabot on the unnecessary maintenance effort provide
concrete insights to improve the suggestions that this single bot
shares with developers.
ACKNOWLEDGMENTS
This work is partially supported by the Wallenberg AI, Autonomous
Systems, and Software Program (WASP) funded by Knut and Alice
Wallenberg Foundation and by the TrustFull project funded by the
Swedish Foundation for Strategic Research.A Longitudinal Analysis of Bloated Java Dependencies ESEC/FSE‚Äô21, August 23‚Äì27, 2021 , Athens, Greece, Virtual Event
REFERENCES
[1]Ioannis Agadakos, Nicholas Demarinis, Di Jin, Kent Williams-King, Jearson
Alfajardo, Benjamin Shteinfeld, David Williams-King, Vasileios P. Kemerlis, and
Georgios Portokalidis. 2020. Large-scale Debloating of Binary Shared Libraries.
Digital Threats: Research and Practice 1, 4 (2020), 1‚Äì28. https://doi.org/10.1145/
3414997
[2]Thibaud Antignac, David Sands, and Gerardo Schneider. 2017. Data Minimisation:
A Language-Based Approach. In ICT Systems Security and Privacy Protection
- 32nd IFIP TC 11 International Conference, SEC 2017, Rome, Italy, May 29-31,
2017, Proceedings (IFIP Advances in Information and Communication Technology) ,
Sabrina De Capitani di Vimercati and Fabio Martinelli (Eds.), Vol. 502. Springer,
442‚Äì456. https://doi.org/10.1007/978-3-319-58469-0_30
[3]Babak Amin Azad, Pierre Laperdrix, and Nick Nikiforakis. 2019. Less is More:
Quantifying the Security Benefits of Debloating Web Applications. In Proceed-
ings of the 28th USENIX Conference on Security Symposium (SEC‚Äô19) . USENIX
Association, USA, 1697‚Äì1714.
[4]Paolo Boldi and Georgios Gousios. 2021. Fine-Grained Network Analysis for
Modern Software Ecosystems. ACM Trans. Internet Techn. 21, 1 (2021), 1:1‚Äì1:14.
https://doi.org/10.1145/3418209
[5]Bobby R. Bruce, Tianyi Zhang, Jaspreet Arora, Guoqing Harry Xu, and Miryung
Kim. 2020. JShrink: In-depth investigation into debloating modern Java appli-
cations. In ESEC/FSE 2020 - Proceedings of the 28th ACM Joint Meeting European
Software Engineering Conference and Symposium on the Foundations of Software
Engineering . Association for Computing Machinery, New York, NY, USA, 135‚Äì146.
https://doi.org/10.1145/3368089.3409738
[6]Russ Cox. 2019. Surviving software dependencies. Commun. ACM 62, 9 (2019),
36‚Äì43. https://doi.org/10.1145/3347446
[7]Tapajit Dey, Sara Mousavi, Eduardo Ponce, Tanner Fry, Bogdan Vasilescu, Anna
Filippova, and Audris Mockus. 2020. Detecting and Characterizing Bots that Com-
mit Code. In Proceedings - 2020 IEEE/ACM 17th International Conference on Mining
Software Repositories, MSR 2020 . Association for Computing Machinery, New York,
NY, USA, 209‚Äì219. https://doi.org/10.1145/3379597.3387478 arXiv:2003.03172
[8]Thomas Durieux, C√©sar Soto-Valero, and Benoit Baudry. 2021. DUETS: A Dataset
of Reproducible Pairs of Java Library-Clients. In IEEE International Working
Conference on Mining Software Repositories .
[9]Linda Erlenhov, Francisco Gomes De Oliveira Neto, and Philipp Leitner. 2020. An
empirical study of bots in software development: Characteristics and challenges from
a practitioner‚Äôs perspective . Association for Computing Machinery, New York,
NY, USA, 445‚Äì455. https://doi.org/10.1145/3368089.3409680 arXiv:2005.13969
[10] Tomas Gustavsson. 2020. Managing the Open Source Dependency. Computer 53,
2 (2020), 83‚Äì87. https://doi.org/10.1109/MC.2019.2955869
[11] Matthew Hague, Anthony W. Lin, and Chih-Duo Hong. 2019. CSS Minification
via Constraint Solving. ACM Trans. Program. Lang. Syst. 41, 2 (2019), 12:1‚Äì12:76.
https://doi.org/10.1145/3310337
[12] Michael Hilton, Jonathan Bell, and Darko Marinov. 2018. A large-scale study of
test coverage evolution. In Proceedings of ASE . ACM, 53‚Äì63.
[13] Gerard J. Holzmann. 2015. Code inflation. IEEE Software 32, 2 (March 2015),
10‚Äì13. https://doi.org/10.1109/MS.2015.40
[14] Yufei Jiang, Dinghao Wu, and Peng Liu. 2016. JRed: Program Customization
and Bloatware Mitigation Based on Static Analysis. In Proceedings - International
Computer Software and Applications Conference , Vol. 1. IEEE Press., New York,
12‚Äì21. https://doi.org/10.1109/COMPSAC.2016.146
[15] Hyungjoon Koo, Seyedhamed Ghavamnia, and Michalis Polychronakis. 2019.
Configuration-Driven Software Debloating. In Proceedings of the 12th European
Workshop on Systems Security (EuroSec ‚Äô19) . Association for Computing Machin-
ery, New York, NY, USA, Article 9, 6 pages. https://doi.org/10.1145/3301417.
3312501
[16] Raula Gaikovina Kula, Daniel M. German, Ali Ouni, Takashi Ishio, and Katsuro
Inoue. 2018. Do developers update their library dependencies?: An empirical
study on the impact of security advisories on library migration. Empirical Software
Engineering 23, 1 (Feb. 2018), 384‚Äì417. https://doi.org/10.1007/s10664-017-9521-5
arXiv:1709.04621
[17] Davy Landman, Alexander Serebrenik, and Jurgen J. Vinju. 2017. Challenges
for Static Analysis of Java Reflection: Literature Review and Empirical Study. In
Proceedings of the 39th International Conference on Software Engineering (ICSE
‚Äô17). IEEE Press., New York, 507‚Äì518. https://doi.org/10.1109/ICSE.2017.53
[18] Benjamin Livshits, Manu Sridharan, Yannis Smaragdakis, Ond≈ôej Lhot√°k, J. Nelson
Amaral, Bor-Yuh Evan Chang, Samuel Z. Guyer, Uday P. Khedker, Anders M√∏ller,
and Dimitrios Vardoulakis. 2015. In Defense of Soundiness: A Manifesto. Commun.ACM 58, 2 (Jan. 2015), 44‚Äì46. https://doi.org/10.1145/2644805
[19] Benjamin Loriot, Fernanda Madeiral, and Martin Monperrus. 2020. Styler: Learn-
ing formatting conventions to repair checkstyle errors. arXiv 1 (2020), 1‚Äì1.
arXiv:1904.01754
[20] Konner Macias, Mihir Mathur, Bobby R. Bruce, Tianyi Zhang, and Miryung Kim.
2020. WebJShrink: A Web Service for Debloating Java Bytecode. In Proceedings
of ESEC/FSE . 1665‚Äì1669.
[21] Chenxiong Qian, Hong Hu, Mansour Alharthi, Pak Ho Chung, Taesoo Kim,
and Wenke Lee. 2019. RAZOR: A Framework for Post-Deployment Software
Debloating. In Proceedings of the 28th USENIX Conference on Security Symposium
(SEC‚Äô19) . USENIX Association, USA, 1733‚Äì1750.
[22] Chenxiong Qian, Hyungjoon Koo, Chang Seok Oh, Taesoo Kim, and Wenke Lee.
2020. Slimium: Debloating the Chromium Browser with Feature Subsetting. In
Proceedings of the ACM Conference on Computer and Communications Security .
Association for Computing Machinery, New York, NY, USA, 461‚Äì476. https:
//doi.org/10.1145/3372297.3417866
[23] Anh Quach, Aravind Prakash, and Lok Yan. 2018. Debloating Software through
Piece-Wise Compilation and Loading. In Proceedings of the 27th USENIX Con-
ference on Security Symposium (SEC‚Äô18) . USENIX Association, USA, 869‚Äì886.
https://doi.org/10.5555/3277203.3277269
[24] Vaibhav Rastogi, Drew Davidson, Lorenzo De Carli, Somesh Jha, and Patrick
McDaniel. 2017. Cimplifier: Automatically debloating containers. In Proceedings
of the ACM SIGSOFT Symposium on the Foundations of Software Engineering ,
Vol. Part F130154. Association for Computing Machinery, New York, NY, USA,
476‚Äì486. https://doi.org/10.1145/3106237.3106271
[25] Michael Reif, Florian K√ºbler, Michael Eichberg, and Mira Mezini. 2018. Sys-
tematic Evaluation of the Unsoundness of Call Graph Construction Algorithms
for Java. In Companion Proceedings for the ISSTA/ECOOP 2018 Workshops (IS-
STA ‚Äô18) . Association for Computing Machinery, New York, NY, USA, 107‚Äì112.
https://doi.org/10.1145/3236454.3236503
[26] Hashim Sharif, Ashish Gehani, Muhammad Abubakar, and Fareed Zaffar. 2018.
Trimmer: Application specialization for code debloating. In ASE 2018 - Proceedings
of the 33rd ACM/IEEE International Conference on Automated Software Engineering
(ASE 2018) . Association for Computing Machinery, New York, NY, USA, 329‚Äì339.
https://doi.org/10.1145/3238147.3238160
[27] Cesar Soto-Valero, Amine Benelallam, Nicolas Harrand, Olivier Barais, and Benoit
Baudry. 2019. The emergence of software diversity in maven central. In IEEE Inter-
national Working Conference on Mining Software Repositories (MSR ‚Äô19) , Vol. 2019-
May. IEEE Press., New York, 333‚Äì343. https://doi.org/10.1109/MSR.2019.00059
arXiv:1903.05394
[28] C√©sar Soto-Valero, Thomas Durieux, Nicolas Harrand, and Benoit Baudry. 2020.
Trace-based Debloat for Java Bytecode. arXiv 1, Article arXiv:2008.08401 (Aug.
2020), 12 pages. arXiv:cs.SE/2008.08401
[29] C√©sar Soto-Valero, Nicolas Harrand, Martin Monperrus, and Benoit Baudry. 2021.
A Comprehensive Study of Bloated Dependencies in the Maven Ecosystem.
Empirical Software Engineering 26, 3 (2021), 1‚Äì44.
[30] Diomidis Spinellis. 2017. A repository of Unix history and evolution. Empir.
Softw. Eng. 22, 3 (2017), 1372‚Äì1404. https://doi.org/10.1007/s10664-016-9445-5
[31] Chengnian Sun, Yuanbo Li, Qirun Zhang, Tianxiao Gu, and Zhendong Su. 2018.
Perses: Syntax-Guided Program Reduction. In Proceedings of the 40th International
Conference on Software Engineering (ICSE ‚Äô18) . Association for Computing Ma-
chinery, New York, NY, USA, 361‚Äì371. https://doi.org/10.1145/3180155.3180236
[32] C√©dric Teyton, Jean-R√©my Falleri, Marc Palyart, and Xavier Blanc. 2014. A study
of library migrations in Java. J. Softw. Evol. Process. 26, 11 (2014), 1030‚Äì1052.
https://doi.org/10.1002/smr.1660
[33] H. C. V√°zquez, A. Bergel, S. Vidal, J. A. D√≠az Pace, and C. Marcos. 2019. Slim-
ming javascript applications: An approach for removing unused functions from
javascript libraries. Information and Software Technology 107 (2019), 18‚Äì29.
https://doi.org/10.1016/j.infsof.2018.10.009
[34] Mairieli Wessel and Igor Steinmacher. 2020. The Inconvenient Side of Software
Bots on Pull Requests. In Proceedings of the IEEE/ACM 42nd International Confer-
ence on Software Engineering Workshops (ICSEW‚Äô20) . Association for Computing
Machinery, New York, NY, USA, 51‚Äì55. https://doi.org/10.1145/3387940.3391504
[35] Qi Xin, Myeongsoo Kim, Qirun Zhang, and Alessandro Orso. 2020. Program
Debloating via Stochastic Optimization. In Proceedings of the ACM/IEEE 42nd
International Conference on Software Engineering: New Ideas and Emerging Results
(ICSE-NIER ‚Äô20) . Association for Computing Machinery, New York, NY, USA,
65‚Äì68. https://doi.org/10.1145/3377816.3381739