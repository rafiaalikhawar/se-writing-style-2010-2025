Domain-Independent Interprocedural ProgramAnalysis
using
Block-AbstractionMemoization
Dirk Beyer
LMU Munich, GermanyKarlheinz Friedberger
LMU Munich,Germany
ABSTRACT
Wheneveranewsoftware-verificationtechnique isdeveloped, ad-
ditionaleffortisnecessarytoextendthenewprogramanalysisto
an interprocedural one, such that it supports recursive procedures.
We would like to reduce that additional effort. Our contribution
is an approach to extend an existing analysis in a modular and
domain-independentwaytoaninterproceduralanalysiswithout
large changes: We present interprocedural block-abstraction memo-
ization(BAM),whichisatechniqueforproceduresummarizationto
analyze (recursive) procedures. For recursive programs, a fix-point
algorithmterminatestherecursionifeveryprocedureissufficiently
unrolled and summarized to cover the abstract state space.
BAMInterproceduralworksfordata-flowanalysisandformodel
checking, and is independent from the underlying abstract domain.
To witness that our interprocedural analysis is generic and config-
urable,wedefinedandevaluatedtheapproachforthreecompletely
different abstract domains: predicate abstraction, explicit values,
and intervals. The interprocedural BAM-based analysis is imple-
mentedintheopen-sourceverificationframework CPAchecker.The
evaluation shows that the overhead for modularity and domain-
independence is not prohibitively large and the analysis is still
competitive with other state-of-the-art software-verification tools.
CCS CONCEPTS
·Software and its engineering →Formal methods ;Formal
software verification ;·Theory of computation →Program
verification ;Verification by model checking .
KEYWORDS
SoftwareVerification,InterproceduralProgramAnalysis,Recursive
C Program, Block Abstraction, Procedure Summary
ACM Reference Format:
Dirk Beyer and Karlheinz Friedberger. 2020. Domain-Independent Interpro-
ceduralProgramAnalysisusingBlock-AbstractionMemoization.In Proceed-
ingsofthe28thACMJointEuropeanSoftwareEngineeringConferenceand
SymposiumontheFoundationsofSoftwareEngineering(ESEC/FSE’20),No-
vember 8ś13, 2020, Virtual Event, USA. ACM, New York, NY, USA, 13pages.
https://doi.org/10.1145/3368089.3409718
Funded in part by Deutsche Forschungsgemeinschaft(DFG)ś 378803395 (ConVeY).
A
reproduction packageis available onZenodo [ 11].
ESEC/FSE ’20, November 8ś13, 2020, Virtual Event, USA
© 2020 Copyright held by the owner/author(s).
ACM ISBN 978-1-4503-7043-1/20/11.
https://doi.org/10.1145/3368089.34097181 INTRODUCTION
Software verification has been successfully applied to improve the
qualityandreliabilityofcomputerprograms[ 2,3,19,22,28,30,40].
In the last decades, several algorithms and approaches were de-
velopedtoperformsoftwaremodelcheckingforvariouskindsof
C programs. However, only a few verifiers for C support full inter-
proceduralanalysis,thatis,verificationofrecursiveprograms:Only
13outof22toolsubmissions(17differenttools)inthe2020com-
petition on software verification [ 5] participated successfully in
the benchmark category of recursive tasks.
A program analysis is called interprocedural if procedures are
analyzed separately and verification results are merged together
from the separate results. The idea is that a program analysis does
not depend on long traces through the program, but analyzes pro-
cedures independently from each other, such that the result of a
procedure’s analysis can be used at all call sites with the same con-
text (e.g., with the same abstract arguments). Many verifiers inline
called procedures into the calling procedure and verify long traces
througha program without any benefit from a modular approach.
Thisnotonlyhindersthereuseofsub-resultsoftheanalysis,but
alsomakesitimpossibletoverifyunboundedrecursiveprograms.
We present BAM Interprocedural, a generalization of summary-
based interprocedural analysis. The abstract framework is an ex-
tension of block-abstraction memoization (BAM) [ 9,57] and is
currentlyusedtoverifyreachabilitypropertiesaboutprograms.
Example. Weoutlinehowtoprovethecorrectnessoftheexample
programin Fig.1(illustratedin Fig.2),whichusestwounsignedin-
teger
variablesaandb,andnondeterministicallyinitializesthemas
inputfortherecursiveprocedure sum,whichreturnsthesumofits
arguments. The program is deemed correct if error()is not called.
This program can not be verified by a default bounded model
checker that iteratively unrolls the recursion, because the number
ofunrollingsisunknown.However,usingaproceduresummary
likeret=m+n, wheremandnare the parameters of procedure
sumandretis the return value of the procedure call, would help
withtheverification.Thissummaryisavalidabstractionforthe
control-flowforeverycalloftheprocedure sumandcanbeapplied
as a substitution for the initial call in procedure mainas well as
for the recursive call in procedure sumitself. For a fully automated
analysis,theverificationalgorithmmustcomeupwiththis(orsome
similar) summary and apply it as part of the proof strategy.
Thisexampleprogramrequiresanabstractdomainthattracksre-
lationsbetweenvariables.Thus,astandardpredicateanalysis(such
asinSect.4)isabletoinfersuch predicates(e.g.,viaCEGAR[ 27]
andinterpolation[ 43])andcansoundlyapplyproceduresummaries
for all call-sites of a procedure. In general, our approach works on
a domain-independent level and does not depend on SMT-based
summaries. The combination of procedure summaries with a fixed-
point algorithm computes an over-approximation of the reachable
50This work is licensed under a Creative Commons Attribution International 4.0 License.
ESEC/FSE’20, November8–13,2020,VirtualEvent, USA DirkBeyerandKarlheinzFriedberger
1void main(void) {
2uint a = nondet();
3uint b = nondet();
4uint s = sum(a, b);
5if (s != a + b) {
6 error();
7}
8}
9
10uint sum(uint n, uint m) {
11if (n == 0) {
12 return m;
13} else {
14 uint tmp = sum(n - 1, m + 1);
15 return tmp;
16}
17}
Figure 1:Example program with arecursive procedure sum
2
3
4
5
6error 7a=nondet()
b=nondet()
s=sum(a,b)
[s/nequala+b][s=a+b]11
12 14
15
16[n=0]![n=0]
tmp=sum(n−1,m+1)
returnm
returntmpBsumBmain
callsum
return from
sumcallsum
return fromsum
Figure 2: CFAs for the example program in Fig. 1, with pro-
cedure blocks BmainandBsum
state space of the recursive procedure. The algorithm first deter-
minesaproceduresummaryforasingleunrollingoftheprocedure,
i.e., for all paths through the procedure that are not traversing
the recursive call. Using the above mentioned abstract domain, the
analysisobtainsasummarylike ret=m+ninthisfirststep.Then,
the algorithm applies the computed procedure summary to the
recursive call and explores longer paths through the program and
refines the procedure summary until the algorithm cannot explore
any new path. For the given example, applying this summary once
for the recursive procedure call within the procedure sumdoes
not change the summary of the whole procedure sum, thus it is
sufficient to reach afixed-point and theanalysis can terminate.
Contribution. Our contribution consists of three parts:
(1)We present a domain-independent approach of BAM [ 57]
for a fully interprocedural analysis: every procedure is analyzed
separatelyandtheresultofaprocedure’sanalysis(anabstractionof
the procedure, also known as łprocedure summaryž) is integrated
in the analysis of the calling context.
(2)Aprogrammightcontain unboundedrecursion (e.g.,there-
cursion depth is depending on unknown input). Instead of just
cuttingoffprogramtracesatapredefineddepth,ouranalysister-
minatestheunrollingofarecursiveprocedureinasoundwayonceafixedpointisreached,anddoesnotomitfeasibleerrorpaths.The
fixed-point algorithm iteratively increments the unrolling of the
recursionuntilnonewabstractstateisreachable.Thealgorithm
is domain-independent, because only coverage checks for abstract
statesareused,whicharealreadyprovidedbyeachabstractdomain.
The overhead is negligible for non-recursive programs.
(3)We formally define an additional domain-specific operator
rebuildin the framework, such that recursive procedures can be
handledineverydomain.Thisoperatorrestoreseliminatedinfor-
mation of the calling context after leaving a recursive call.
Related Work. As programs with (recursive) procedures have
beenanalyzedandalsoverifiedsincedecades,manyideasareal-
ready available and implemented in some tools. We give a short
overview of the tools and the domains they are based on.
Inlining-Based Analysis. A common approach to analyze proce-
dures in bounded model checking is to unroll them up to a certain
limit and ignore any deeper recursive calls. Tools like Cbmc[29],
Esbmc[36], andSmack[47] implement this approach, which leads
toanunsoundanalysisincombinationwithrecursiveprocedure
calls, because there is no guarantee that the bug is unreachable
throughfurtherunrolling.Withouttheuserspecifyingabound,the
modelcheckermightrunintoanendlessunrollingoftherecursion.
Constant propagation (like in Cbmc) or additional checks can avoid
toofarunrollingofrecursiveprocedures.Alsounboundedframe-
workslike CPAchecker [15]haveseveralanalysesbasedondifferent
domains [ 16,17,46] that inline procedure calls. Our approach is
built on top of them and reuses existing components, such that the
amount of changes to a single analysis is minimal.
Interpolation-Based Summaries. Someapproachestoverifyre-
cursive programs start with a the analysis of single procedures
and compute procedure summaries when applying nested func-
tioncalls.Theboundedmodelchecker FunFrog[53,54]generates
interpolation-based[ 33]proceduresummariestoavoidtherepeated
analysisofprocedures. Whale[1]isanextensionof Impact[44]and
analyzes recursive procedures using two types of formulas in its
intra-proceduralanalysis,namelystate-andtransition-interpolants,
togetsummaries.Thoseapproachesseparatelyanalyzeeachpro-
cedure until a fixed-point is reached and the procedures (or the
representing formulas) are sufficiently refined. UAutomizer uses
nested interpolants [ 38] to compute formulas for procedures de-
pending on the caller’s context. Those approaches are bound to
an SMT-based domain and the algorithms do not support combi-
nations with other domains.
Further Domain-Specific Interprocedural Analyses. Bebop[4]
computesproceduresummariesforbooleanprograms.Theapplica-
tion ofBebophowever islimited to boolean programs and abstract
statesaredescribedwithbinarydecisiondiagrams. Abductor [23]is
aninterproceduralprogramverifierthatappliesthedomainofsepa-
rationlogictoprovememory-relatedsafetyproperties.Additionally,
arecursiveprogramcanbetransformedintoanon-recursiveone,
such that any verification tool without direct support for recur-
sioncanbeusedindirectlytoanalyzetherecursiveprogram.For
example, CPArec[26] is a light-weight approach using an external
black-box verifier and a fixed-point algorithm that increments the
unrolling depth to compute procedure summaries until coverage is
reached. This approach is limited to predicate-based verifiers.
51Domain-IndependentInterproceduralProgram Analysis usingBlock-AbstractionMemoization ESEC/FSE’20, November8–13,2020,VirtualEvent, USA
Interprocedural Data-Flow Analysis. The above examples are
basedonsymbolicanalysis,i.e.,dependingonBDD-,SAT-,orSMT-
baseddomains,whileourproposedapproachworksforclassicdata-
flowdomainsaswell.Sincemanyyears,programswereanalyzed
in interprocedural manner using several lattice-based domains [ 31,
50] and with procedure summaries [ 55]. The classic approach to
interproceduraldata-flowanalysis[ 21,41,48]isrestrictedtofinite-
height lattices of domain elements and an operator yielding the
join of two domain elements.
BAM Interprocedural works for arbitrary, unlimited abstract
domainsanddifferentoperatorsforcombiningelements(depending
on the represented data, not only join) or coverage checks for
elements (domain-specific comparison).
2 BACKGROUND
We describe the program representation as a control-flow automa-
ton and domain-independent reachability analysis based on the
concept of configurable program analysis. Afterwards, their appli-
cation as components in an interprocedural analysis is shown.
2.1 Programs
Aprogramis represented by a control-flow automata (CFA)A=
(L,l0,G)that consists of a set Lof program locations, an initial
programlocation l0∈L,andasetG⊆L×Ops×Lofcontrol-flow
edges.Anedgemodelsthecontrol-flowoperation(from Ops)be-
tween program locations, for example assignments or assumptions.
Figure2representstheexampleprogramasCFAs.Ourpresentation
usesasimpleimperativeprogramminglanguage,whichallowsonly
assignments,assumeoperations,procedurecallsandreturns,and
all variables are integers. The implementation of our tool provides
basicsupportforheap-relateddata-structuresincludingpointers
and arrays, but thisarticle avoidsthem forsimplicity.In general,
CPAchecker [15] supports the verification of C programs including
pointers and arrays. However, the analysis of recursive procedures
forsuchprogramsisstillunderdevelopmentandatopicofresearch.
2.2 Blocksin aProgram
Blocksare formally defined as parts of a program: A block B=
(L′,G′)of a CFA A=(L,l0,G)consists of a set L′⊆Lof
program locations and a set G′={(l1,op,l2) ∈G|l1,l2∈L′}
of control-flow edges. We assume that two blocks Band
B′are either disjoint ( B.L′∩B′.L′=∅) or one block is
completely nested in the other block ( B.L′⊂B′.L′). Each
block has inputandoutput locations , which are defined as
In(B)={l∈L′| (∃l′:(l′,·,l)∈G∧l′/nelementL′)∨(∄l′:(l′,·,l)∈G)}and
Out(B)={l∈L′| (∃l′:(l,·,l′)∈G∧l′/nelementL′)∨(∄l′:(l,·,l′)∈G)}, re-
spectively. In general, the block size can be freely chosen in our
approach. For an interprocedural analysis, we use procedures as
blocks,suchthatablockabstractionrepresentsaproceduresum-
mary. InFig. 2, the blocks BmainandBsumrepresent the two pro-
ceduresoftheprogram.Theinputandoutputlocationsaremarked
in color for each block.2.3 CPA andCPAAlgorithm
Thereachabilityanalysisisbasedontheconceptofconfigurable
programanalysis(CPA)[ 13],whichspecifiestheabstractdomain
for a program analysis and additional operations.
A CPAD=(D,/leadsto,merge,stop)consists of an abstract do-
mainD,atransferrelation /leadsto,andtheoperators mergeandstop.
The abstract domain D=(C,E,[[·]])consists of a set Cof concrete
states, a semi-lattice E=(E,⊑)over a set Eof abstract-domain
elements(i.e.,abstractstates)andapartialorder ⊑(thejoin⊔of
two elements and the join ⊤of all elements are unique), and a con-
cretization function [[·]]:E→2Cthat maps each abstract-domain
element to the represented set of concrete states. The transfer rela-
tion/leadsto⊆E×Ecomputes abstract successor states, a transfer rela-
tionд/leadstomatchesthetransferalonganedge д∈GoftheCFA.The
mergeoperator merge:E×E→Especifiesifandhowtomerge
two abstract states when control flow meets. The stop operator
stop:E×2E→Bdetermineswhetheranabstractstateiscovered
by a givensetof abstract states. Theoperators mergeandstopcan
be chosen appropriately to influence the abstraction level of the
analysis.Commonchoicesinclude mergesep(e,e′)=e′(whichdoes
not merge abstract states) and stopsep(e,R)=(∃e′∈R:e⊑e′)
(which determines coverage by checking whether the given ab-
stract state is less than or equal to any other reachable abstract
state according to the semi-lattice).
Given a CPA, we can apply a reachability algorithm (denoted
as CPA algorithm in [ 13]) that explores the abstract state space
ofa programand computesall reachable abstractstates. The stop
operatordeterminesthefixed-pointcriteria,i.e.,whetherastate
hasalready beendiscoveredbefore. For thefollowing description,
weconsiderareachabilityanalysis CPA(D,reached,waitlist)using
aCPADandtwosets reachedandwaitlistofabstractstatesasinput
andreturningtwosets reached′andwaitlist′ofabstractstates.The
idea is that starting with the given sets of already reached abstract
states andafrontier waitlist,thereachability algorithmcomputes
more reachable successors and a new frontier waitlist.
TheCPAalgorithmcanbeusedascomponentinaCEGAR-based
fixed-pointloop[ 27]torefinethegranularityofthecurrentanalysis.
For simplicity we ignore the precision in this article.
Inthefollowing Sect.3,wedescribeourinterproceduralexten-
sion of block-abstraction memoization, and then in Sect. 4pro-
videanapplicationoftheconcepttothreeseparatedomains:the
Callstack-CPAfortrackingacallstackoftheprogram,theValue-
CPAfortrackingvariableassignmentsexplicitly,andthePredicate-
CPA for handling variable assignments with predicates.
3 BAMFORINTERPROCEDURALANALYSIS
Block-Abstraction Memoization(BAM)[ 57]isa modular andscal-
able approach for model checking abstract state spaces by leverag-
ing the idea of divide and conquer . BAM divides a large program
into smaller parts, named blocks, and analyzes them separately.
The result of a block’s analysis is denoted as a block abstraction .
Blockabstractionsarestoredinacache.Wheneveralargerblock
depends on a nested block, a block abstraction of the nested block
is created during the larger block’s analysis. Block abstractions are
independentofaconcretedomainandworkonanabstractlevel.
52ESEC/FSE’20, November8–13,2020,VirtualEvent, USA DirkBeyerandKarlheinzFriedberger
There can be several block abstractions for the same block, e.g.,
depending on different input values of the block.
In the following, we use procedures as blocks. More precisely,
aprocedureblock Bfconsistsoftheprocedure fitselfandallpro-
cedures that are (transitively) called from f, such that the whole
control-flow of nested blocks, including call and return edges, is
included in the block Bf(seeFig. 2).
BAMensuresefficiencybyusingacache cache⊆ (Blocks×E) →
(2E×2E)forblockabstractions,whichmapstheinitialabstractstate
forablocktotheblockabstraction.Theblockabstractionisdefined
as the set of reached abstract states and the set of frontier abstract
states, which both are computed during the block’s analysis.
BAMisdefinedrecursively(independentofanyrecursioninthe
analyzed program) and repeatedly (nestedly) applies the reacha-
bilityanalysis.OurimplementationofBAMusesa stackofpairs
p∈Blocks×Ethat consists of all currently open analyses ref-
erenced by their block of the CFA to be analyzed and an initial
abstract state (starting point of the block abstraction).
This section defines BAM Interprocedural. We show that pro-
cedure blocks correspond to procedure summaries, describe the
problems of analyzing recursive procedures, the necessity of the
fixed-point algorithm, and a new operator rebuild.
3.1 OperatorsofBAM
BAMusestwocomplementingoperators reduce⊆Blocks×E→E
andexpand⊆Blocks×E×E→E, and an additional operator
rebuild⊆E×E×E→E, to drop or restore context-based infor-
mation for each analyzed block. A CPA with these three additional
operatorsiscalled CPAwithBAMoperators .Onanabstractlevel,the
reduce operator performs an abstraction of the given abstract state
andtheexpandoperatorconcretizesanabstractstateforagiven
context.Theseoperatorsaimtowards aninterproceduralanalysis
where each block can be analyzed without knowing its concrete
context.Howmuchofthiscontext-independencecanbeachieved
depends on the concrete domain (see Sect. 4for more details). The
implicit benefit of the first two operators is an improvement of the
cache-hit-rate. The operator reducedrops unimportant informa-
tion from an abstract state when entering a block. The resulting
abstractstateismoreabstractandisusedascachekeyandasini-
tial abstract statefor the block’s analysis. The importanceof some
information depends on the wrapped analysis and the available
block. For example,variables, predicates, or levels of the call stack
thatare not accessed inside the enteredblock,but onlydepend on
the surrounding context, might be good candidates to be removed
fromtheabstractstate.Theoperator expandrestoresremovedin-
formationforabstractstateswhenapplyingtheblockabstractionin
thesurrounding context. The operator rebuildavoidscollisions of
programidentifiers(likevariables)whenreturningfroma(possibly
recursive)procedurescopeintoitscallingcontext.Thisoperator
doesnotcomputeanabstraction,butperformssimpleoperations
dependingonthegivenabstractdomainsuchasrenamingvariables,
substituting predicates, or updating indices.
Withtheseoperators,wenowformallydefinetheCPAforBAM.Algorithm1 fixedPoint (Bmain,l0,e0)
Input:blockBmainwithinitial programlocation l0, abstract state e0
Output: setofreachablestates, whichallrepresentoutput states
ofthe block Bmain
Global Variables: booleanflag ﬁxedpointReached
Variables: setblockResult ofabstract states
1:repeat
2:ﬁxedpointReached :=true;
3:blockResult :=applyBlockAbstraction (Bmain,e0);
4:untilﬁxedpointReached
5:return blockResult ;
3.2 BAMas CPA
For usage with the CPA concept (see Sect. 2.3), BAM itself is for-
malized as a CPA BAM=(DBAM,/leadstoBAM,mergeBAM,stopBAM).
As BAM works on an abstract, domain-independent level, it re-
quires a separate abstract-domain-dependent analysis (like the
valueanalysis orpredicateanalysis )totrackvariables,values,and
assignments. This separate component analysis is also defined via
the CPA concept (see Sect. 4). For the following definition we
denote it as a general (wrapped) CPA with BAM operators W=
(DW,/leadstoW,mergeW,stopW,reduceW,expandW,rebuildW).
(1)The domain DBAMis the wrapped domain DW, i.e., BAM
simply uses the abstract states of the underlying domain.
(2)The transfer relation includes the transfer e/leadstoBAMe′for
twoabstract states eande′andablock Bif
e′∈ 
ﬁxedPoint (Bmain,l,e)ifl=l0andstack=[]
applyBlockAbstraction (B,e)ifl∈In(B)
{e′′|e/leadstoWe′′} ifl/nelementOut(B)
wherelistheprogramlocationfor eandstackistheinternal
stack ofnestedblocksduringthe analysis.
The transfer relation applies one of three possible steps:
(1)Thefixed-pointalgorithm Alg.1isexecutedifthecurrent
programlocationistheinitialprogramlocation l0andthe
stackisempty.(2)Ataninputlocationofablock B,i.e.,if
a new nested block would be entered from a surrounding
context, we apply the block abstraction returned from the
operation applyBlockAbstraction (cf.Alg. 2) for the nested
block. (3) For outputlocations of blocks, there is nosucceed-
ing abstract state (in the sub-analysis). For other program
locations, the wrappedtransfer relation /leadstoWisapplied.
(3)The merge operator mergeBAM=mergeWdelegates to the
wrappedanalysis,i.e.,BAM merges whenever the underly-
ingdomainmerges abstract states.
(4)The termination check stopBAM=stopWdelegates to the
wrappedanalysis,i.e.,thecoveragerelationbetweenabstract
states depends onthe underlying domain.
The transfer relation /leadstoBAMuses the fixed-point algorithm and
the computation of block abstractions as explained in the next
subsections.
53Domain-IndependentInterproceduralProgram Analysis usingBlock-AbstractionMemoization ESEC/FSE’20, November8–13,2020,VirtualEvent, USA
Algorithm2 applyBlockAbstraction (B,eI)
Input:abstract state eIat ablockinput location ofablock B
Output: abstract statesforthe outputlocationsofthe analyzed block B
Global Variables: booleanflag ﬁxedpointReached ,
setcachemappingablockandan abstract state to a
blockabstraction,
sequence stackconsisting ofpairsofaprocedureblock
andan abstract state
Variables: setsreachedandwaitlistofabstract states
forthe analysis ofthe currentblock
1:ei:=reduceW(B,eI);
2:if∃(B,ec) ∈stack:ei⊑ecthen
3:ifcachecontains(B,ec)then
4:(reached,·):=cache(B,ec);
5:else
6: reached:={}
7: ﬁxedpointReached :=false;
8:else
9:ifcachecontains(B,ei)then
10: (reached,waitlist):=cache(B,ei)
11:else
12: reached:={ei};waitlistr:={ei}
13:stack.push((B,ei));
14:(reached,waitlist):=CPA(W,reached,waitlist)
15:stack.pop();
16:ifcachecontains(B,ei)then
17: (reachedold,·):=cache(B,ei);
18: fore∈reacheddo
19: ifloc(e) ∈Out(B)∧∄e′∈reachedold:e⊑e′then
20: ﬁxedpointReached :=false;
21:cache(B,ei):=(reached,waitlist)
22:ecall:=getPredecessor (eI);
23:tmp:={expandW(B,eI,eo) |eo∈reached∧loc(eo) ∈Out(B)}
24:return{rebuildW(ecall,eI,eO) |eO∈tmp};
3.3 Fixed-PointAlgorithmforUnbounded
Recursion
An analysis of recursive procedures must handle a possibly un-
bounded unrolling of the call stack if the information of an ab-
stract state is insufficient to avoid deeper exploration and can
not cut off the state space. In our approach, the fixed-point al-
gorithm ( fixedPoint ,Alg. 1) repeatedly analyzes the program using
applyBlockAbstraction (Alg.2)fromtheinitialprogramlocationon-
wards.Ititerativelyincrementsthenumberofunrollingsandtermi-
nates only if coverage was reached for all analyzed procedure calls.
In each iteration of the fixed-point algorithm, we generate an
overapproximation of some (more) paths through the recursive
procedure(becauseofthelimitedunrollingoftherecursion)and
determine a summary for the currently analyzed procedure block.
The termination is decided by a coverage check for the abstract
states of the analyzed block summary.
The first iteration of the fixed-point algorithm assumes no valid
path through the recursive call. We only explore the non-recursive
parts of the program’s control flow and skip the recursive call
of the procedure. Depending on the abstract domain, the initial
summary for the recursive procedure is an empty set of abstract
states(Alg.2,line6).Theblockabstractionofaprocedureisstored
inthecacheafterreturningfromtheprocedurecall( Alg.2,line21).{P}b=f(a){Q} ⊢ {P∧p=a}Bf{Q∧p=a∧b=r}
{P}b=f(a){Q}
Figure 3: Hoare’s rule for recursion, for a given procedure
definition f(p) {Bf;returnr;}
{[[Pe]]}b=f(a){[[Qe]]} ⊢ {[[Pe]]}Bf{[[Qe]]}
{[[Pe]]}b=f(a){[[Qe]]}
Figure 4:Hoare’srule forrecursion(with abstract states)
In further iterations, we increment the limit of unrollings of the
recursiveprocedureandrefinetheblockabstraction,analyzethe
programagain,startingfromtheinitialprogramlocation(andusing
several intermediate results from the cache), until the procedure
summary becomes stable.
3.4 Soundness ofBAMforRecursion
The fixed-point criteria are based on Hoare’s rule for recursion
(Fig. 3): if the body of a procedure fsatisfies the pre- and post-
conditions PandQ(includingparameterpassingandreturnvalues)
under the condition that all recursive calls to the procedure f
satisfyPandQ, then the whole procedure fsatisfiesPandQ.
Translated into our model, we use (concretizations of) abstract
states as pre- and post-conditions of statements, the procedure and
its body corresponds to the procedure’s block; Fig. 4shows the
resulting rule. The renaming (or an equivalent operation) of equal
identifiers from the recursive call of f, which appear in the calling
andcalledprocedure f,isshiftedintoadifferentpartoftheanalysis
(seeSect.3.5onoperator rebuild)andishandledinasoundway.
To determine the fixed-point criteria for termination, Alg. 2
checks the following two properties during the analysis.
Firstly, wetrytostoptheunrollingofanunboundedrecursive
procedure by an over-approximating analysis. Thus, before analyz-
ing a new recursive procedure call, we check whether the abstract
state ataprocedure entryis alreadycovered by anyabstractstate
fromthecurrent stack(Alg.2,line2).Ifsuchacoveringabstract
stateexists,weskiptherecursivecallanduseaproceduresummary
insteadoffurtherexploringtherecursivecall( Alg.2,line3to7).
The procedure summary consists of either previously computed
abstractsuccessorstatesfromtheBAMcacheor(incaseofacache
miss) no successor states at all.
Secondly, because a procedure summary represents only a
bounded execution of the called procedure, this approach alone
represents only a subset of possible traces in the procedure and
might be unsound in cases that require deeper unrolling. To deter-
mineiftheinsertedproceduresummariesaresufficientforHoare’s
rule ofFig.4, wecheck for coverage oftheexit state(oftheproce-
dureexecutedwiththeinsertedproceduresummary)againstthe
previouslycomputedabstractstates(oftheproceduresummary).
Thischeckis performedinlines18to20of Alg.2.Ifthecoverage
relation is satisfied (for all procedures in the program), then the
fixed-point algorithm terminates, because ﬁxedpointReached was
neversetto falseduringtheiteration.Inthiscasewehavefounda
soundover-approximationoftherecursiveprocedure.Otherwise
the fixed-point algorithm continues.
54ESEC/FSE’20, November8–13,2020,VirtualEvent, USA DirkBeyerandKarlheinzFriedberger
3.5 Block-AbstractionComputation with
Operators
Theoperation applyBlockAbstraction (cf.Alg.2)startswiththere-
duction reduceW(B,eI)ofinitial abstractstate eIand determines
the block abstraction for a block B. The block abstractionis either
taken from the cache or computed via a separate application of the
reachability algorithm (i.e., CPA algorithm). To integrate the block
abstractionintoasurroundingcontext,theoperators expandWand
rebuildWareappliedtoeachabstractstateattheblock’soutputloca-
tion(lines23and24).Theoperators reduceandexpandabstractor
concretizethegivenabstractstateandaimtoincreasethecache-hit
rate of BAM. For an interprocedural approach, they remove and re-
store (most of) the context-based information of a procedure block.
Whilethefixed-pointalgorithmhandlesover-approximations
andrefinementsofblockabstractions,aninterestingdetailofthe
implementation remains open: How can we identify and work
with symbols, i.e., variable identifiers, across procedure scopes?
Identicalidentifiersforprogramvariablesofthesameprocedure
scopeareproblematicfortheanalysisofrecursiveprocedures.Due
tothemodularityoftheframework CPAchecker ,onlyaseparatecall-
stackanalysisknowsaboutprocedurescopesandallotheranalyses
assume unique identifiers across all operations. BAM also tracks
informationaboutproceduresinits stack,butitdoesnotusethis
information for detailed analysis of variables and identifiers. Each
recursive procedure entry starts a new procedure scope, where the
identifiers override existing (valid) identifiers from previous call-
stacklevels.Enteringaprocedureandoverridingexistingidentifiers
fromthecallingscopeisnoproblem,becauseonlythemostlocal
version ofan identifier is available(and visible) in the procedure
scope. Leaving the procedure afterwards is more complex, because
identifiersareoverriddenduringtheprocedure’straversalandhave
to be restored to match the calling context.
Asolutionlikeasimplerenamingofidentifiersisnotpossible,
because each domain has its own way of representing variables.
Additionally,eachdomainmusthaveastrategyforhandlingscoped
variables that allows a consistent use of the cache in BAM.
Wesolvethisproblembyusinganewoperator rebuild:E×E×
E→E, and we show how to implement it for different domains.
The operator rebuildis applied after analyzing the procedure-exit
location( Alg.2,line24),i.e.,afterleavingtheblockofa(maybere-
cursive)procedureandaftertheapplicationoftheoperator expand.
The operator rebuildmaps three abstract states (information about
the calling context from the procedure call state ecall, information
about the arguments and parameters of the called procedure from
theprocedureentrystate eI,andinformationaboutthereturnvalue
and the block abstraction from the procedure exit state eO) to a
new abstract state that is a successor of the procedure call and a
validstartingpointforthefurtheranalysis.Theoperator rebuild
is defined depending on the underlying analysis.
4 APPLICATION OF
BAMINTERPROCEDURALTO
ABSTRACTDOMAINS
In this section, we describe some component program analyses
that can be used by BAM Interprocedural to compute context-
independentblockabstractions.Usingtheframework CPAchecker ,program analyses are composed of several component CPAs. Com-
ponentCPAsaredefinedandimplementedfortrackingtheprogram
counter, the predecessor-successor relationship of the reachability
graph, or for combining other CPAs in a composite analysis. Thus,
wedonotneedtospecifytheseaspectswhendefiningacomponent
analysis, but directly specify the component analyses. In the fol-
lowing,weexplainananalysisfortrackingthecallstackandtwo
analyses for analyzing variables and assignments (namely value
analysisandpredicate analysis ).
Callstack-CPA. TheCPAwithBAMoperators forcall-stackanalysis
C=(DC,/leadstoC,mergeC,stopC,reduceC,expandC,rebuildC)explic-
itly tracks the call stack s=[f1,···fn]of the program, where f1
tofndenote procedure scopes for an abstract state s.
(1)The domain DC=(C,EC,[[·]])is based on the flat semi-
latticeEC=(S∪{⊤},⊑)for the setSof possible call stacks.
Theexpression s⊑s′isfulfilledif s=s′ors′=⊤,[[⊤]]=C.
For allsinS,we have [[s]]={c∈C|callstackOf (c)=s}.
(2)Thetransferrelation /leadstoChasthetransfer sд/leadstoCs′forCFA
edgeдandabstract states s=[f1,···,fn−1,fn]ands′,if
s′= 
[f1,···,fn,fn+1]ifдisaprocedure callto fn+1
[f1,···,fn−1]ifдisaprocedure return from fn
s otherwise
(3)The merge operator mergeC=mergesepdoes not combine
abstract states.
(4)The termination check stopC=stopsepreturns whether
the same abstract state wasalready reachedbefore.
(5)The reduce operator reduceCabstracts from a concrete call
stack and keeps only the context-relevant suffix. Therefore,
it determines the maximal range of procedure scopes of the
currentblock,i.e.,procedurescopesthatcanbepoppedfrom
the current call stack [f1,...,fi,...,fn]during an analysis of
thecurrentblock.Lettheprocedurescope fibethelowest
procedure scope on the stack that is reachable during the
block’s analysis. Then, the operator keeps only the reach-
able (most local) procedure scopes from the abstract state:
reduceC(B,[f1,...,fi,...,fn])=[fi,...,fn].
(6)The expand operator expandCrestores the removed part of
the callstack:
expandC([f1,...,fi,...,fn],B,[fi,...,fs])=[f1,...,fi,...,fs].
(7)Thecall-stackanalysis doesnottrackvariables,buttheproce-
durescopesthemselves.Thustherebuildoperatorisdefined
as:rebuildC(ecall,eI,eO)=eO.
Value-CPA. TheCPA with BAM operators forvalue analysis
E=(DE,/leadstoE,mergeE,stopE,reduceE,expandE,rebuildE)explic-
itly tracks the assignments of variables. The CPA is used as de-
scribed in previous work [ 12,17] and extended by BAM operators.
(1)The domain DE=(C,EE,[[·]])is based on the semi-lattice
EC=(V,⊑E)for the set V=(X−→ ◦Z)of partial func-
tions that model abstract variable assignments for a set X
of variables and the set Zof integer values. We use v(x)
to denote the value of a variable x∈Xfor an abstract
variable assignment v∈V, and we use dom(v)to denote
the set of variables for which vassigns a value, that is,
dom(v)={x| (x,·) ∈v}. The partial order ⊑E⊆V×Vis
definedas: v⊑v′ifdom(v′) ⊆dom(v)andv(x)=v′(x)is
55Domain-IndependentInterproceduralProgram Analysis usingBlock-AbstractionMemoization ESEC/FSE’20, November8–13,2020,VirtualEvent, USA
satisfied for all x∈dom(v′). The top element ⊤E∈V(least
upper bound) denotes the abstract variable assignment with
nospecificvalueforanyvariable: ⊤E={}.Thejoinoperator
⊔E:E×E→Eis based on the partial order and returns
the least upper bound of its operands. The concretization
function[[·]]:V→2Creturnsthemeaningforanabstract
variable assignment.
(2)Thetransferrelation /leadstoEhasthetransfer vд/leadstoEv′foraCFA
edgeд=(·,op,·)and two abstract variable assignments v
andv′,ifoneofthefollowingconditionsissatisfied(givena
predicatepandanabstractvariableassignment v,wedefine
ϕ(p,v):=p∧/logicalandtext.1
x∈dom(v)x=v(x)):
(a)op=assume(p)and predicate ϕ(p,v)is satisfiable, and
v′is defined as follows: (x,c) ∈v′ifcis the only satisfying
assignment for variable xofthe predicate ϕ(p,v),or
(b)op=(w:=exp)and(x,c) ∈v′if either (x/nequalwand
(x,c) ∈v)or(x=wandcistheonlysatisfyingassignment
for variable x′ofthe predicate ϕ(x′=exp,v)).
(3)The mergeoperator mergeE=mergesepdoes not combine
abstract states.
(4)Theterminationcheck stopE=stopsepreturnswhethera
coveringabstract state wasalready reachedbefore.
(5)The reduce operator reduceEonly keeps abstract assign-
mentsofvariablesthatareaccessedintheblock’scontext:
reduceE(B,eI)={(x,c) ∈eI|xusedinB}.
(6)Theexpandoperator expandErestorestheassignmentsthat
were removed by reduceEfrom the initial abstract state:
expandE(eI,B,eo)={(x,c) ∈eI|xnot usedin B}∪eo.
(7)Fortherebuildoperator rebuildE,wedefine globalvariables
asvariablesdeclaredintheglobalscopeandtherestas lo-
calvariables, i.e., variables declared in a local procedure
scope.Afterleaving a(recursive)procedurecall,theopera-
torrebuildEconsiders local variables from the calling scope,
andglobalvariablesandthereturnvariable1fromtheexited
procedure scope: rebuildE(ecall,eI,eO)=
{(x,c) ∈ecall| ¬isGlobal(x)∧¬isReturn(x)}∪
{(x,c) ∈eO|isGlobal(x)∨isReturn(x)}.
Becauseglobalvariablescanbeassignedduringtheproce-
dure’sexecution,theyarenotresettotheirassignedvalue
frombeforetheprocedure’sexecution;theirvaluesaretaken
from the abstract state eOat the procedure’sexit location.
Note that with these definitions of reduceEandexpandE, the
valueanalysis ofaprocedureblockisnotcompletelydetachedfrom
the calling context, because a block abstraction for this domain
depends on the input values of variables accessed in the block. For
procedure blocks, a block abstraction for a function call can be
takenfromtheBAMcachewheneverthefunctionargumentsand
global variables have identical values.
Predicate-CPA. TheCPAwithBAMoperators forpredicateanaly-
sisP=(DP,/leadstoP,mergeP,stopP,reduceP,expandP,rebuildP)uses
predicates to track variablesand their values [ 8,57]. Forthis analy-
sisasetPofpredicatesisused,whichcanbeincrementallycom-
puted in a CEGAR loop [ 27] that is applied on top of the CPA
1Our implementation introduces an additional variable to capture the return value,
such that weareable to referenceit hereas well.algorithm.Inthisdescription,wedonotgointodetailonhowto
determine useful predicates, but assume that the predicates are
already available, e.g., by applying an existing refinement strat-
egy [10,16]. The refinement procedure of the predicate analysis
computes interpolants that match the structure of the procedure
blocks [38] and allow an interprocedural analysis.
Foreachblock B,wepartitiontheset Pofpredicatesintotwo
disjoint sets PB={p∈ P |prelevantfor B}andP¬B=P \PB.
A predicate p∈ Pisrelevant for Bif it contain variables that are
accessedintheblock.Thepartition P¬Bcontainstherestof P.
(1)The domain DP=(C,EP,[[·]])is based on the set Cof con-
crete states, the lattice EP=(E,⊑P), and a concretization
function[[·]]:E→C.Thelatticeconsistsofabstractstates
e∈Ethat are tuples (ψ,lψ,φ) ∈ (P × ( L∪ {l⊤}) × P).
Theabstraction formula ψis a boolean combination of pred-
icates from Pand has been computed at the program lo-
cationlψ. Thepath formula φrepresents (the disjunction
of) all paths from lψto the abstract state e. The partial
order⊑ ⊆E×Eis defined for any two abstract states
e1=(ψ1,lψ1,φ1)ande2=(ψ2,lψ2,φ2)as:e1⊑e2if
(e2=⊤P) ∨ ((lψ1=lψ2) ∧ (ψ1∧φ1⇒ψ2∧φ2)). The
top element is ⊤P=(true,l⊤,true). The join operator ⊔:
E×E→Eisbasedonthepartialorderandreturnstheleast
upper bound ofits operands.
(2)The transfer relation /leadstoPhas the transfer eд/leadstoPe′for an
edgeд=(·,op,l′)andtwoabstractstates e=(ψ,lψ,φ)and
e′=(ψ′,lψ′,φ′),if
(ψ′,lψ′,φ′)=/braceleftBigg
(true,l′,(SPop(φ)∧ψ)Π)ifblk(e,д)
(ψ,l′,SPop(φ)) otherwise,
whereSPop(φ)denotes the strongest post-condition of a
given path formula φfor an operation op. The choice of
computingabooleanpredicateabstractiondependsonthe
configurable operator blk. For our work it returns trueat
leastforprocedurecalls,procedureentries,andprocedure
exits.Thebooleanpredicateabstraction (·)Πcomputesthe
strongestboolean combination of predicates from P.
(3)The merge operator mergeP:E×E→Ecombines the two
abstract states e1=(ψ1,lψ1,φ1)ande2=(ψ2,lψ2,φ2)ac-
cordingtotheirlastabstractioncomputation: merge(e1,e2)=/braceleftBigg
(ψ2,lψ2,φ1∨φ2)if(ψ1=ψ2)∧(lψ1=lψ2)
e2 otherwise
(4)Theterminationcheck stopP=stopsepreturnswhethera
coveringabstract state wasalready reachedbefore.
(5)For an abstract state eI=(ψI,lψI,true)at a block entry, the
operator reducePcomputes the set P¬B:={p1,...,pi}of
predicatesthatareirrelevantfortheblockabstractionand
removes themfrom the abstractionformula:
reduceP(B,eI)=((∃p1,...,pi:ψI),lψI,true).2
(6)Theoperator expandPrevertstheoperation reduceP,itcom-
putestheset PB:={pi+1,...,pn}ofpredicates,andrestores
thefullset ofpredicates P=P¬B∪PBfor anoutput state
eo=(ψo,lψo,true)as follows: The abstraction formula ψo
2We represent the abstraction formula ψin a way that makes it easy to remove
elements from Pin an atomic way from an abstraction formula. (We represent ψas a
binarydecisiondiagram(BDD)whosebooleanvariablesrepresentpredicatesfrom P.)
56ESEC/FSE’20, November8–13,2020,VirtualEvent, USA DirkBeyerandKarlheinzFriedberger
isextendedbytheremainingpartoftheinitialabstraction
formulaψI:
expandP(eI,B,eo)=((∃pi+1,...,pn:ψI)∧ψo,lψo,true).
(7)The operator rebuildPis based on the procedure-call state
ecall=(ψcall,lψcall,true), the (not reduced) procedure-
entry state eI=(ψI,lψI,true), and the expanded procedure-
exitstateeO=(ψO,lψO,true).Thepathformula φcallrepre-
sentstheCFAedgethatistheprocedureentryedgebetween
the program locations of the abstract states ecallandeIand
representstheencodingofallassignmentsoftheactualar-
guments to the formal parameter variables. The operator
rebuildPcomputesthepredicateabstractionfortheconjunc-
tionoftheabstractionsbeforeandaftertheprocedurecall
andthe parameterassignment:
rebuildP(B,ecall,eI,eO)=(ψcall∧φcall∧ψO)Π.
Interval-CPA. TheCPA withBAM operators forintervalanalysis
I=(DI,/leadstoI,mergeI,stopI,reduceI,expandI,rebuildI)tracks vari-
ables and the range (interval) of their possible assigned values.
Theinterval analysis is similartothe value analysis ,whichcanbe
seen as a special case using intervals containing only one value.
Thecoveragerelationbetweenintervalsisbasedontheinclusion
of intervals (instead of equality of values). We omit the detailed
definition here to keep the reader focused on our approach.
4.1 Soundness ofReduce andExpandOperator
fortheGivenDomains
Foreachofthedescribeddomains,thesoundnesscriterionofthe
whole interprocedural analysis is based on the soundness of the
CPAalgorithmitself(whichweassumeasbasis)aswellasonthe
propertiesofthespecificoperators reduceandexpand.Forasound
analysis, the abstract states that would have been reached with-
outapplyingablockabstraction(i.e.,onlyapplyingthewrapped
CPAW)needtobeasubsetofthestatesreachedwithanapplication
of the corresponding block abstraction, i.e., using block abstrac-
tionscanonlybelessprecisethanawrappedanalysis,butnever
cut off a reachable part of the abstract state space.
The transfer relation /leadstoBAMfor an abstract state e∈Esatisfies
the relation {e′∈E|e/leadstoWe′} ⊆ {e′′∈E|e/leadstoBAMe′′}.
Based on the definition of /leadstoBAM(Sect. 3.2), the interesting case
appears when applying a block abstraction. Thus, the concrete
implementationoftheoperators reduceandexpandmustsatisfy
the following condition for all blocks B:{e′∈E|e/leadstoWe′} ⊆
{expand(e,B,eo) ∈E|reduce(B,e)/leadstoWeo}.
For the call-stack analysis, each abstract call-stack state after an
application of a block abstraction exactly matches the call-stack
statewithoutsuchablockabstraction.Toprovethis,justextend
each call stack during the block analysis with the removed part
[f1,...,fi−1]fromthereduceoperation.Forthevalueanalysis(and
basedonaprogramminglanguagewithoutpointerhandling),the
same proof can be applied: Removing assignments from abstract
states and restoring them later results in an abstract state that
matches the state when not applying a block abstraction computa-
tion. A detailedsoundness proof for the predicate domain is given
in the literature [ 57]. Removing irrelevant predicates P¬Band con-
junctingthosepredicateswhenapplyingtheblockabstractiondoesonly make the analysis more imprecise, but does not reduce the
reachable abstract state space.
4.2 EmbeddingBAMInterproceduralinCEGAR
The framework CPAchecker defines BAM as a CPA and allows to
combinetheCPAalgorithmwithotheralgorithms,likeCEGAR[ 27],
whichallowstorefinethegranularityoftheabstractanalysisbased
oninformationextractedfrominfeasibleprogrampaths.Additional
operators for the refinement step in CEGAR are also defined in
a domain-independent manner and available in the framework.
In our case, the CEGAR algorithm can wrap the CPA algorithm
and the analysis of BAM can benefit from this. Whenever BAM
findsapropertyviolation,thereachabilityanalysisandthefixed-
point algorithm terminates and the surrounding CEGAR algorithm
checks the error path for feasibility. If necessary, CEGAR refines
theprecision,andBAMwiththefixed-pointalgorithmisre-started
with the updated precision.
In case of the predicate analysis , the refinement procedure com-
putes tree interpolants [ 20,38] according to procedure scopes, i.e.,
foreachentered(andexited)procedurescopealonganinfeasible
error path, a new subtree for the tree interpolation problem is con-
structed.Forotheranalyses,like valueanalysis ,therefinementof
recursive procedures does not need special handling. In this case, a
refinementstrategyforsequentialerrorpaths[ 17]issufficient.
4.3 Detailed Description oftheExample
Inthefollowing,weprovidedeeperinsightsforthepreviouslygiven
example program (see Sect. 1) inFig. 1, to show the control flow
ofBAMwiththefixed-pointalgorithmwhenusingthe predicate
analysis. We combine the previously defined Callstack-CPA Cand
the Predicate-CPA P, i.e., the transfer relation, coverage check,
reduce, expand, and rebuild operators are applied in both domains.
Figure 5shows the abstract states that are reached in the first
two iterations of the fixed-point algorithm, which terminates after
the second iteration. The labeling of each abstract state consists of
the program location (circled number in first line), the call stack
(second line), and the abstraction formula of the predicate anal-
ysis(third line). To keep the figure readable, we dismiss the call
stackandabstractionformula wheneverthereisnochangein the
abstract state. Outside the upper left corner of each node, we anno-
tateei, where index irefers to the exploration strategy and control
flow of the analysis.
Theoperators reduce,expand,andrebuildshowtheireffectat
theprogramlocations 11and16,whicharetheinputandoutput
locationsoftheprocedureblock Bsum.Forexample,theoperator
reduceCofthecall-stackanalysis removesofallprocedurescopes
exceptthemostlocalonefromthecallstack.Theoperator expandC
restoresthewholecallstackwhentheanalysisleavestheblock.The
effectofthe rebuildPatprogramlocation 16willbedescribedbelow.
Initialization. We assumethat the initialcache and the stack of
BAM are empty and the following set of predicates is defined as
precision: P:={ret=mp+np,ret=a+b,m=mp∧n=np}.
Thepredicateanalysis uses the symbols mp,np,andrettoencode
parameterassignmentsatfunctionentryandthereturnvalue.Such
predicates can be generated via an interpolation procedure from
previouslyfoundinfeasibleerrorpathsinthecontextofCEGAR.
57Domain-IndependentInterproceduralProgram Analysis usingBlock-AbstractionMemoization ESEC/FSE’20, November8–13,2020,VirtualEvent, USA
Bmain
Bsum
Bsum2
[main]
true
3
4
11
[main,sum]
true11
[sum]
true
12 14
11
[sum,sum]
true11
[sum]
truecachemiss16
[sum]
ret=mp+np
16
[main,sum]
ret=a+b
5
7
[main]
truereduce
reduce
expand
rebuild
apply block
abstractione1
e2
e3
e4e5
e6 e7
e8 e9 e10
e11
e12
e13coverage (1)
(a)Afterfirst iteration; cache missleads to seconditerationBmain
Bsum
Bsum2
[main]
true
3
4
11
[main,sum]
true11
[sum]
true
12 14
11
[sum,sum]
true11
[sum]
true
16
[sum]
ret=mp+np16
[sum,sum]
ret=m+ncachehit
for statee516
[sum]
ret=mp+np
16
[main,sum]
ret=a+b
15
16
[sum]
ret=mp+np5
7
[main]
truereduce
reduce
expand
rebuildexpand
rebuild
apply block
abstractionapply block
abstractione21
e22
e23
e24e25
e26 e27
e28 e29 e30
e8 e32
e33
e34e35
e36
e37coverage(1)
coverage (2)
(b)Afterseconditeration; fixed point isreached
Figure 5:Graph ofreached abstract statesafter thefirsttwofixed-point iterations
Forsimpleprograms(likethisexample)theymatchtheexpected
proceduresummary.Ingeneral,theanalysismightneedseveraliter-
ationsofCEGARtoobtainasufficientprecision.Inthisexample,we
concentrate on the rebuild operator. All predicates are relevant for
theblockBsum,i.e.,PB=P,i.e.,thereduceandexpandoperators
forpredicate analysis will keep the abstraction formula unchanged.
First Iteration. The result of the first iteration of the fixed-point
loopisshownin Fig.5a.Theanalysisstartswiththeinitialabstract
statee1at program location 2, entering the main block Bmain
and pushing e1(aseiinAlg. 2) onto the BAM stack. The recursive
procedureblock Bsumisanalyzedforthefirsttimeattheprocedure
callfromprogramlocation 4toprogram location 11,where BAM
starts a new sub-analysis with state e4(aseIinAlg. 2) for the
blockBsum.Thereductionremovesthesuffix mainofthecallstack
and keeps the abstraction formula true. The abstract state e5(asei
inAlg. 2) is pushed onto the BAM stack. When the procedure
blockBsumisentered thesecondtime (procedurecallat program
location14forstatee9),thereducedabstractstate e10iscompared
with elements in the BAM stack. The coverage relation ( Alg. 2,
line2)issatisfied.BAMhasnocomputedproceduresummaryin
the cache and returns an empty set of reachable abstract states
(line 6 of Alg. 2). The flag ﬁxedpointReached is set to falsein
line 7 of Alg. 2. The analysis continues with the exploration of
the non-recursive branch of the procedure. When leaving block
Bsum,theblock’ssummaryisinsertedintothecache,i.e.,theblock
abstraction from the abstract state e5towards the abstract state e8
(aseOinAlg. 2) is stored for later usage in the BAM cache. For
the predicate analysis, the summary of the block is the abstraction
formularet=mp+np, which describes the equality of the sum of
the two formal function parameters with the return value.Therebuildoperator rebuild(B,e3,e4,e8)restoresinformation
from the calling context. Using the abstraction formula ψ3:=true,
the parameter assignment from the procedure call φcall:=
(a=np∧b=mp), and the block summary ψ8:=(ret=mp+np),
the rebuild operator rebuildPcomputes (ψ3∧φcall∧ψ8)Π=
(ret=a+b).Thatis,basedonthegivenpredicatesfor e11,Π(e11)=
{ret=a+b},theprocedureissummarizedby ret=a+b,which
describestheequalityofthesumofthetwoactualfunctionargu-
ments with the return value. We do not describe internals of predi-
cateabstraction here, but referto the literature [ 16].Noproperty
violation is found along the path until state e13, i.e., the branching
towardsprogramlocation 6isnotsatisfiable,andthefixed-point
computation continues.
Second Iteration. The initial steps of the second iteration are
similar to the first iteration. After a few steps, the stack consists
of the abstractstates e21ande25.A different controlflowappears
whentheanalysisreachestherecursiveprocedurecallagainatstate
e30, with a coverage relation for the abstract state e25because it is
partoftheBAMstack.Nowwegetacachehitforthepreviously
computedblockabstractionbetweenstate e5andstatee8andapply
the procedure summary to skip the recursive procedure call (line 4
ofAlg.2).Usingtheabstractionformula ψ27:=true,theparameter
assignment from the procedure call φcall:=(n=np∧m=mp),
andtheblocksummary ϕ8:=(ret=mp+np),therebuildoperator
rebuildPcomputes (ψ27∧φcall∧ψ8)Π=(ret=m+n). When
leaving the procedure block, our approach ( Alg.2, line19) checks
for new (not yet covered) abstract states. In this example, state
e34isalready coveredby state e28,thus the fixed-point algorithm
terminatesafterthisiteration.Asthepropertyviolationatprogram
location6is not reachable, the program is verified.
58ESEC/FSE’20, November8–13,2020,VirtualEvent, USA DirkBeyerandKarlheinzFriedberger
5 EXPERIMENTALEVALUATION
WeevaluateBAMInterproceduralforseveraldomainsandshow
thatitiscompetitivewithexistingapproaches.Wedividetheevalua-
tionaccordingtothreeclaims.Forbothclaims,weuseabenchmark
set of non-recursive and recursive programs and provide the ef-
fectivity(numberofsolvedproblems)andperformance(runtime)
of our implementation, using several analyses of CPAchecker and
other verification tools.
ClaimI:Domain-IndependenceandModularity. Weclaimthat
ourinterproceduralapproachisdomain-independentandcanbe
implemented in a modular way as described in Sect. 3, such that
the development and integration overhead for an existing anal-
ysis in the framework CPAchecker is quite small. To evaluate the
claim,weapplytheapproachtoseveralabstractdomains,showthat
theanalysisworks,andcomparedifferentanalysesof CPAchecker
against each other.
ClaimII:EffectivenessandEfficiency(Part1). Weclaimthatour
approachÐdespitethemodulardesignÐdoesnotcauselargeperfor-
manceoverheadsinananalysis.Toevaluatetheclaim,wecompare
benchmarkresultsagainstseveralstate-of-the-artverificationtools
that are able to verify programs with recursive procedures.
Claim III: Effectiveness and Efficiency (Part 2). We claim that
our approach is comparable to intraprocedural analyses within the
sameframework.Toevaluatetheclaim,weapplydifferentanalyses
to a larger set of recursive and non-recursive benchmark tasks and
compare benchmark results from our interprocedural approach
against intraprocedural analyses with and without BAM.
5.1 Benchmark ProgramsandSetup
WeuseverificationtasksfromtheSV-COMP’20[ 5]benchmarkset3,
includingtaskswithandwithoutrecursivefunctioncallsfromcate-
goriesReachsafety-Bitvectors ,Reachsafety-ControlFlow ,Reachsafety-
Loops,Reachsafety-ProductLines ,andReachsafety-Recursive .Most
recursive programs are generic and allow to easily scale the pro-
grams to deeper recursion; they include recursive algorithms, e.g.,
Fibonacci ,Ackermann ,Towers of Hanoi , andMcCarthy91 . The
non-recursive programs use integer arithmetics and avoid heap-
related data-structures.
All experiments were performed on machines with a 3.4GHz
Quad Core CPU and 33GB of RAM. The operating system was
Ubuntu 20.04 (64 bit) with Linux 5.4.0. A CPU time limit of15min
andamemorylimitof15GBwereused,whichistheestablished
standard from SV-COMP. Measurements and resource limits were
managed by BenchExec [18].
5.2 Results andDiscussion
Claim I. We implemented our domain-independent approach in
CPAchecker for several domains, including value analysis ,predicate
analysis, andinterval analysis . In addition, we evaluated a reduced
product[14,32]ofvalueandpredicateanalysis.Weused CPAchecker
inversion1.9,whichalsoparticipatedinSV-COMP’20. CPAchecker
3https://github.com/sosy-lab/sv-benchmarks/tree/svcomp20Table1:ResultsforthecomparisonofBAMInterprocedural
combinedwithdifferentabstractdomainsin CPAcheckeron
category Reachsafety-Recursive ofSV-COMP
Domain CPUtime ( s) Proofs Bugs
Value 924 31 37
Predicate 3440 29 37
Interval 849 36 38
Value+ Predicate 1690 37 43
Table 2:Resultsforthe comparison ofdifferentverifierson
category Reachsafety-Recursive ofSV-COMP
Verifier CPUtime ( s) Proofs Bugs
Cbmc 662 32 47
CPAchecker (SV-COMP’20) 2180 37 46
Divine 1190 32 42
Esbmc 941 33 47
Map2Check 23600 34 37
PeSCo 3130 37 46
Pinaka 237 31 31
Symbiotic 138 33 45
UAutomizer 2160 41 37
UKojak 1010 19 28
UTaipan 6210 42 37
VeriAbs 7630 41 46
VeriFuzz 1960 0 45
waschosenastheimplementationplatformbecauseithasaconfig-
urable and modular design that is easy to extend by new concepts,
has a considerable user base, and is well maintained.4
Table1comparesBAMInterproceduralforfourdomains(one
ofthembeingaproduct),byprovidingtheCPUtime(inseconds,
withthreesignificantdigits)neededbytheverifiersforallcorrectly
solved verification tasks and the number of correctly solved tasks,
divided into proofs and bugs found in the category Reachsafety-
Recursive of SV-COMP.
Claim II. We provide the results ofstate-of-the-artsoftware veri-
fiers, which participated in SV-COMP’20 [ 5]5. We compare 13 ver-
ifiers that participated successfully in the category Reachsafety-
Recursive of SV-COMP. This includes the predicate-based verifiers
CPAchecker [35,56],PeSCo[34,49]andUltimateAutomizer [37,39],
the bounded model checkers Cbmc[29,42] andEsbmc[36,45], the
symbolic-execution tool Symbiotic [24,25], as well as the SMT-
basedtool Map2Check [51,52].Thebinaryarchivesofallverifiers
arepubliclyavailable.6Thedataareextractedfromthepublished
SV-COMP’20 results [6].
Table2providesthesumofCPUtimeneededbytheverifiersfor
allcorrectly solvedverification tasks,and thenumberofcorrectly
solvedtasks,dividedintoproofsandbugsfound.Theconfiguration
usedbyverifier CPAchecker (SV-COMP’20)combines valueanalysis
andpredicateanalysis withinour interproceduralapproach (same
configurationasinthelastentryof Table1),whichisautomatically
selectedasthestrategytoverifyrecursiveprograms[ 7].Theperfor-
mance of the tool with our approach ( CPAchecker ) also shows that
4https://www.openhub.net/p/cpachecker
5https://sv-comp.sosy-lab.org/2020/systems.php
6https://gitlab.com/sosy-lab/sv-comp/archives-2020/-/tree/svcomp20
59Domain-IndependentInterproceduralProgram Analysis usingBlock-AbstractionMemoization ESEC/FSE’20, November8–13,2020,VirtualEvent, USA
Predicate Value Interval Value+Predicate020406080
Reachsafety-Recursive#CorrectResults
Predicate Value Interval Value+Predicate02040
Reachsafety-Bitvectors#CorrectResults
Predicate Value Interval Value+Predicate0204060
Reachsafety-ControlFlow#CorrectResults
Predicate Value Interval Value+Predicate050100
Reachsafety-Loops#CorrectResults
Predicate Value Interval Value+Predicate0200400
Reachsafety-ProductLines#CorrectResults
Proofsand BugsfoundwithoutBAM
Proofsand BugsfoundwithBAM Intraprocedural
Proofsand BugsfoundwithBAM Interprocedural
Figure 6: Results for different benchmark categories for
thecomparisonofdifferentabstractdomainswithoutBAM,
with BAM Intraprocedural, and with BAM Interprocedural
inCPAchecker
although modularand domain-independent,it is competitive with
completely different tools and approaches in terms of effectiveness
andefficiency : BAM Interprocedural solves about as many tasks
astheothertoolswithinreasonableCPUtime.Noneofthetools
managedtoverifyalltasks,andthereareseveraltasksinthegiven
benchmark set that could not be solved by any verifier.
Claim III. AsCPAchecker istheconfigurable program analysis
framework, different domain-independent intraprocedural anal-
yses based on the CPA concept are available, such as the default
analysis without BAM and its combination with BAM. Figure 6comparesthosealgorithmswithournewapproachofBAMInter-
procedural. Each analysis is combined with four different domains
(one of them being a product). We provide the number of correctly
solved tasks, divided into proofs and bugs found. Each category
of SV-COMP’20isgiven separately, such that the strengthsof the
algorithmsarevisible.Incontrasttotheexistingintraprocedural
approaches without and with BAM, the new approach supports
theinterproceduralanalysisofrecursiveproceduresforallthree
domains separately as well as for a combination of domains and
leads togood results in the category Reachsafety-Recursive . For all
other categories, the results are comparable over all approaches.
Onlyfor the predicate domain, the resultfor the tasks in category
Reachsafety-ProductLines is worse. The reason for the result in this
singlecategoryiscausedbyavalid,butunfittingrefinementstep
(i.e.,asuboptimalheuristicintheSMTsolver),thatcausesexpen-
siveunrollingoftheprogram.Asmanytasksinthiscategoryare
similar, most results are affected. For value analysis ,interval analy-
sis,andalsofortheanalysis basedonvalueandpredicatedomain
together, the new approach performs approximately as good as the
existing approaches without or with BAM.
6 CONCLUSION
WehavepresentedBAMInterprocedural,anovelapproachtointer-
proceduralprogramanalysis.Thenewapproachis modular and
domain-independent , because it is not integrated in a specific
program analysis but wraps an existing analysis. In other words,
given anarbitraryabstractdomainfor intra-proceduraldata-flow
analysis,wecanturnitintoan inter-proceduralanalysiswithout
much (a) development work and (b) performance overhead. We
have illustrated in detail how to make predicate analysis andvalue
analysisinterprocedural. Our implementation and experiments
show thatBAMInterproceduralworkswellfor four differentpro-
gram analyses. The new approach supports recursive procedures,
becauseitisnotboundedtoafixednumberofprocedurescopes.
We showed the effectiveness on the benchmark set of recursive
programs fromSV-COMP’20: the approach is able to successfully
verifyrecursiveprocedures.Thenewapproachis efficient,because
itisintegratedintoBAM anddoesnot addmuchoverheadontop
of the wrapped abstract domain. Compared to other software veri-
fiers,thenewimplementationiscompetitive.Duetothemodular
approach,theeffectivenessandefficiencyheavilydependsonthe
wrapped program analysis. Our results are promising and there is
potential for optimization in our implementation. We plan to spec-
ify the operator rebuildfor further domains like binary decision
diagrams,symbolicmemorygraphs,oroctagons,e.g.,toanalyze
more difficult memory-accesses in recursive programs.
We hope that other researchers and developers of verification
toolscanbenefitfromourapproachbecauseitseparatestheconcern
of making an analysis interprocedural from the actual work on
implementing and improving abstract domains.
DataAvailabilityStatement. Allbenchmarktasksforevaluation,
configurationfiles,aready-to-runversionofourimplementation,
andtableswithdetailedresultsareavailableinourreproduction
package[ 11].Thesourcecodeofourextensionstotheopen-source
verificationframework CPAchecker [15]isavailableintheproject
repository; see https://cpachecker.sosy-lab.org .
60ESEC/FSE’20, November8–13,2020,VirtualEvent, USA DirkBeyerandKarlheinzFriedberger
REFERENCES
[1]A.Albarghouthi,A.Gurfinkel,andM.Chechik. 2012. Whale: AnInterpolation-
Based Algorithm for Inter-procedural Verification.In Proc. VMCAI (LNCS 7148) .
Springer, 39ś55. https://doi.org/10.1007/978-3-642-27940-9_4
[2]T. Ball, B. Cook, V. Levin, and S. K. Rajamani. 2004. Slamand Static Driver
Verifier:Technology Transferof FormalMethodsinside Microsoft.In Proc.IFM
(LNCS 2999) . Springer, 1ś20. https://doi.org/10.1007/978-3-540-24756-2_1
[3]T.Ball,V.Levin,andS.K.Rajamani.2011. ADecadeofSoftwareModelChecking
withSlam.Commun. ACM 54, 7 (2011), 68ś76. https://doi.org/10.1145/1965724.
1965743
[4]T. Ball and S. K. Rajamani. 2000. Bebop: A Symbolic Model Checker for Boolean
Programs. In Proc. SPIN (LNCS 1885) . Springer, 113ś130. https://doi.org/10.1007/
10722468_7
[5]D. Beyer. 2020. Advances in Automatic Software Verification: SV-COMP 2020. In
Proc. TACAS (2) (LNCS 12079) . Springer, 347ś367. https://doi.org/10.1007/978-3-
030-45237-7_21
[6] D. Beyer. 2020. Resultsof the 9thInternational Competition on SoftwareVerifi-
cation (SV-COMP2020). Zenodo. https://doi.org/10.5281/zenodo.3630205
[7]D.BeyerandM.Dangl.2018.StrategySelectionforSoftwareVerificationBasedon
Boolean Features: A Simple but Effective Approach. In Proc. ISoLA (LNCS 11245) .
Springer, 144ś159. https://doi.org/10.1007/978-3-030-03421-4_11
[8]D. Beyer, M. Dangl, and P. Wendler. 2018. A Unifying View on SMT-Based
SoftwareVerification. J.Autom.Reasoning 60,3(2018),299ś335. https://doi.org/
10.1007/s10817-017-9432-6
[9]D.BeyerandK.Friedberger.2018. Domain-IndependentMulti-threadedSoftware
Model Checking.In Proc. ASE .ACM,634ś644. https://doi.org/10.1145/3238147.
3238195
[10]D.BeyerandK.Friedberger.2018.In-Placevs.Copy-on-WriteCEGARRefinement
forBlockSummarizationwithCaching.In Proc.ISoLA(LNCS11245) .Springer,
197ś215. https://doi.org/10.1007/978-3-030-03421-4_14
[11]D.BeyerandK.Friedberger.2020. ReproductionPackageforArticle‘Domain-
Independent Interprocedural Program Analysis using Block-Abstraction Memo-
ization’inProc.ESEC/FSE2020. Zenodo. https://doi.org/10.5281/zenodo.4024268
[12]D. Beyer, S. Gulwani, and D. Schmidt. 2018. Combining Model Checking and
Data-FlowAnalysis. In HandbookofModelChecking .Springer,493ś540. https:
//doi.org/10.1007/978-3-319-10575-8_16
[13]D. Beyer, T. A. Henzinger, and G. Théoduloz. 2007. Configurable Software Verifi-
cation: Concretizing the Convergence of Model Checking and Program Analysis.
InProc. CAV (LNCS 4590) . Springer, 504ś518. https://doi.org/10.1007/978-3-540-
73368-3_51
[14]D. Beyer, T. A. Henzinger, and G. Théoduloz. 2008. Program Analysis with
Dynamic Precision Adjustment. In Proc. ASE . IEEE, 29ś38. https://doi.org/10.
1109/ASE.2008.13
[15]D. Beyer and M. E. Keremoglu. 2011. CPAchecker : A Tool for Configurable
Software Verification. In Proc. CAV (LNCS 6806) . Springer, 184ś190. https:
//doi.org/10.1007/978-3-642-22110-1_16
[16]D. Beyer, M. E. Keremoglu, and P. Wendler. 2010. Predicate Ab-
straction with Adjustable-Block Encoding. In Proc. FMCAD . FMCAD,
189ś197. https://www.sosy-lab.org/research/pub/2010-FMCAD.Predicate_
Abstraction_with_Adjustable-Block_Encoding.pdf
[17]D. Beyer and S. Löwe. 2013. Explicit-State Software Model Checking Based
on CEGAR and Interpolation. In Proc. FASE (LNCS 7793) . Springer, 146ś162.
https://doi.org/10.1007/978-3-642-37057-1_11
[18]D. Beyer,S. Löwe,and P.Wendler. 2019. ReliableBenchmarking:Requirements
and Solutions. Int. J. Softw. Tools Technol. Transfer 21, 1 (2019), 1ś29. https:
//doi.org/10.1007/s10009-017-0469-y
[19]D. Beyer and A. K. Petrenko. 2012. Linux Driver Verification. In Proc. ISoLA
(LNCS 7610) . Springer, 1ś6. https://doi.org/10.1007/978-3-642-34032-1_1
[20]R. Blanc, A. Gupta, L. Kovács, and B. Kragl. 2013. Tree Interpolation in Vampire.
InProc.LPAR (LNCS8312) .Springer,173ś181. https://doi.org/10.1007/978-3-642-
45221-5_13
[21]O. Burkart and B. Steffen. 1992. Model Checking for Context-Free Processes.
InProc. CONCUR (LNCS 630) . Springer, 123ś137. https://doi.org/10.1007/
BFb0084787
[22]C. Calcagno, D. Distefano, J. Dubreil, D. Gabi, P. Hooimeijer, M. Luca, P. W.
O’Hearn, I. Papakonstantinou, J. Purbrick, and D. Rodriguez. 2015. Moving Fast
with Software Verification. In Proc. NFM (LNCS 9058) . Springer, 3ś11. https:
//doi.org/10.1007/978-3-319-17524-9_1
[23]C. Calcagno, D. Distefano, P. W. O’Hearn, and H. Yang. 2011. Compositional
Shape Analysis by Means of Bi-Abduction. ACM58, 6 (2011), 26:1ś26:66. https:
//doi.org/10.1145/2049697.2049700
[24]M.Chalupa,J.Strejcek,andM.Vitovská.2018. JointForcesforMemorySafety
Checking.In Proc.SPIN .Springer,115ś132. https://doi.org/10.1007/978-3-319-
94111-0_7
[25]M.Chalupa,M.Vitovská,M.Jonás,J.Slaby,andJ.Strejcek.2017. Symbiotic 4:
Beyond Reachability (Competition Contribution). In Proc. TACAS (LNCS 10206) .
Springer, 385ś389. https://doi.org/10.1007/978-3-662-54580-5_28[26]Y.-F. Chen, C. Hsieh, M.-H. Tsai, B.-Y. Wang, and F. Wang. 2014. Verifying
Recursive Programs Using Intraprocedural Analyzers. In Proc. SAS (LNCS8723) .
Springer, 118ś133. https://doi.org/10.1007/978-3-319-10936-7_8
[27]E. M. Clarke, O. Grumberg, S. Jha, Y. Lu, and H. Veith. 2003. Counterexample-
guided abstraction refinement for symbolic model checking. J. ACM50, 5 (2003),
752ś794. https://doi.org/10.1145/876638.876643
[28]E.M. Clarke,T.A.Henzinger,H. Veith,and R.Bloem.2018. HandbookofModel
Checking. Springer. ISBN:978-3-319-10574-1 https://doi.org/10.1007/978-3-319-
10575-8
[29]E. M. Clarke, D. Kröning, and F. Lerda. 2004. A Tool for Checking ANSI-C
Programs. In Proc. TACAS (LNCS 2988) . Springer, 168ś176. https://doi.org/10.
1007/978-3-540-24730-2_15
[30]B.Cook.2018. FormalReasoningAbouttheSecurityofAmazonWebServices.
InProc. CAV (2) (LNCS 10981) . Springer, 38ś47. https://doi.org/10.1007/978-3-
319-96145-3_3
[31]P. Cousot and R. Cousot. 1977. Static Determination of Dynamic Properties
ofRecursiveProcedures.In FormalDescriptionofProgrammingConcepts:Proc.
oftheIFIPWorkingConferenceonFormalDescriptionofProgrammingConcepts .
North-Holland,237ś278.
[32]P.CousotandR.Cousot.1979.Systematicdesignofprogram-analysisframeworks.
InProc. POPL . ACM,269ś282. https://doi.org/10.1145/567752.567778
[33]W.Craig.1957.LinearReasoning.ANewFormoftheHerbrand-GentzenTheorem.
J.Symb.Log. 22,3 (1957), 250ś268. https://doi.org/10.2307/2963593
[34]M. Czech, E. Hüllermeier, M.-C. Jakobs, and H. Wehrheim. 2017. Predicting
Rankings of Software Verification Tools. In Proc. SWAN . ACM, 23ś26. https:
//doi.org/10.1145/3121257.3121262
[35]M.Dangl,S.Löwe,andP.Wendler.2015. CPAchecker withSupportforRecursive
Programs and Floating-Point Arithmetic (Competition Contribution). In Proc.
TACAS (LNCS9035) .Springer,423ś425. https://doi.org/10.1007/978-3-662-46681-
0_34
[36]M.R.Gadelha,F.R.Monteiro,J.Morse,L.C.Cordeiro,B.Fischer,andD.A.Nicole.
2018. ESBMC5.0:AnIndustrial-Strength CModel Checker.In Proc.ASE .ACM,
888ś891. https://doi.org/10.1145/3238147.3240481
[37]M. Heizmann, D. Dietsch, J. Leike, B. Musa, and A. Podelski. 2015. Ultimate
Automizer with Array Interpolation. In Proc. TACAS (LNCS 9035) . Springer,
455ś457. https://doi.org/10.1007/978-3-662-46681-0_43
[38]M.Heizmann,J.Hoenicke,andA.Podelski.2010. Nestedinterpolants.In Proc.
POPL. ACM,471ś482. https://doi.org/10.1145/1706299.1706353
[39]M. Heizmann, J. Hoenicke, and A. Podelski. 2013. Software Model Checking
for People Who Love Automata. In Proc. CAV (LNCS 8044) . Springer, 36ś52.
https://doi.org/10.1007/978-3-642-39799-8_2
[40]A. V. Khoroshilov, V. S. Mutilin, A. K. Petrenko, and V. Zakharov. 2009. Estab-
lishingLinuxDriverVerificationProcess.In Proc.ErshovMemorialConference
(LNCS 5947) . Springer, 165ś176. https://doi.org/10.1007/978-3-642-11486-1_14
[41]J.Knoop,O.Rüthing,andB.Steffen.1996. Towardsatoolkitfortheautomatic
generationofinterproceduraldata-flowanalyses. J.Program.Lang. 4,4(1996),
211ś246.
[42]D.KröningandM.Tautschnig.2014. Cbmc:CBoundedModelChecker(Com-
petition Contribution). In Proc. TACAS (LNCS 8413) . Springer, 389ś391. https:
//doi.org/10.1007/978-3-642-54862-8_26
[43]K.L.McMillan.2003. InterpolationandSAT-BasedModelChecking.In Proc.CAV
(LNCS 2725) . Springer, 1ś13. https://doi.org/10.1007/978-3-540-45069-6_1
[44]K. L. McMillan. 2006. Lazy Abstraction with Interpolants. In Proc. CAV
(LNCS 4144) . Springer, 123ś136. https://doi.org/10.1007/11817963_14
[45]J. Morse, M. Ramalho, L. C. Cordeiro, D. Nicole, and B. Fischer. 2014. Esbmc
1.22 (Competition Contribution). In Proc. TACAS (LNCS 8413) . Springer, 405ś407.
https://doi.org/10.1007/978-3-642-54862-8_31
[46]P. Müller and T. Vojnar. 2014. CPAlien: Shape Analyzer for CPAchecker
(Competition Contribution). In Proc. TACAS (LNCS 8413) . Springer, 395ś397.
https://doi.org/10.1007/978-3-642-54862-8_28
[47]Z. Rakamarić and M. Emmi. 2014. SMACK: Decoupling Source Language Details
from Verifier Implementations. In Proc. CAV (LNCS 8559) . Springer, 106ś113.
https://doi.org/10.1007/978-3-319-08867-9_7
[48]T.W.Reps,S.Horwitz,andM.Sagiv.1995. PreciseInterproceduralData-Flow
Analysis via Graph Reachability. In Proc. POPL . ACM, 49ś61. https://doi.org/10.
1145/199448.199462
[49]C.RichterandH.Wehrheim.2019. PeSCo:PredictingSequentialCombinationsof
Verifiers (Competition Contribution). In Proc. TACAS (3) (LNCS 11429) . Springer,
229ś233. https://doi.org/10.1007/978-3-030-17502-3_19
[50]N. Rinetzky, M. Sagiv, and E. Yahav. 2005. Interprocedural Shape Analysis for
Cutpoint-Free Programs. In Proc. SAS (LNCS 3672) . Springer, 284ś302. https:
//doi.org/10.1007/11547662_20
[51]H.O.Rocha,R.Barreto,andL.C.Cordeiro.2016. HuntingMemoryBugsinCPro-
gramswithMap2Check(CompetitionContribution).In Proc.TACAS (LNCS9636) .
Springer, 934ś937. https://doi.org/10.1007/978-3-662-49674-9_64
[52]H. O. Rocha, R. S. Barreto, and L. C. Cordeiro. 2015. Memory Management Test-
Case Generation of C Programs Using Bounded Model Checking. In Proc. SEFM
(LNCS 9276) . Springer, 251ś267. https://doi.org/10.1007/978-3-319-22969-0_18
61Domain-IndependentInterproceduralProgram Analysis usingBlock-AbstractionMemoization ESEC/FSE’20, November8–13,2020,VirtualEvent, USA
[53]O. Sery, G. Fedyukovich, and N. Sharygina. 2011. Interpolation-Based Function
Summaries in Bounded Model Checking. In Proc. HVC (LNCS 7261) . Springer,
160ś175. https://doi.org/10.1007/978-3-642-34188-5_15
[54]O.Sery,G.Fedyukovich,andN.Sharygina.2015. FunctionSummarization-Based
BoundedModelChecking. In ValidationofEvolvingSoftware .Springer,37ś53.
https://doi.org/10.1007/978-3-319-10623-6_5
[55]M. Sharir and A. Pnueli. 1981. Two approaches to interprocedural data-flow
analysis. In Program Flow Analysis: Theory andApplications . Prentice-Hall,189ś
233. ISBN: 978-0-137-29681-1[56]D.Wonisch.2012. BlockAbstractionMemoizationfor CPAchecker (Competition
Contribution).In Proc.TACAS (LNCS7214) .Springer,531ś533. https://doi.org/
10.1007/978-3-642-28756-5_41
[57]D. Wonisch and H.Wehrheim. 2012. Predicate Analysis with Block-Abstraction
Memoization. In Proc. ICFEM (LNCS 7635) . Springer, 332ś347. https://doi.org/10.
1007/978-3-642-34281-3_24
62