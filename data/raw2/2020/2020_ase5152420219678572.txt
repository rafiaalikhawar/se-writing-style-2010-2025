A Compositional Deadlock Detector
for Android Java
James Brotherston∗, Paul Brunet∗, Nikos Gorogiannis†and Max Kanovich∗
∗Dept. of Computer Science, University College London, UK
†Facebook, UK
Email: J.Brotherston@ucl.ac.uk, nikos.gorogiannis@gmail.com, Paul@Brunet-Zamansky.fr, M.Kanovich@ucl.ac.uk
Abstract —We develop a static deadlock analysis for commer-
cial Android Java applications, of sizes in the tens of millions of
LoC, under active development at Facebook. The analysis runsprimarily at code-review time, on only the modiﬁed code andits dependents; we aim at reporting to developers in under 15minutes.
To detect deadlocks in this setting, we ﬁrst model the real
language as an abstract language with balanced re-entrant locks,nondeterministic iteration and branching, and non-recursiveprocedure calls. We show that the existence of a deadlock in thisabstract language is equivalent to a certain condition over thesets of critical pairs of each program thread; these record, for all
possible executions of the thread, which locks are currently heldat the point when a fresh lock is acquired. Since the critical pairsof any program thread is ﬁnite and computable, the deadlockdetection problem for our language is decidable, and in NP.
We then leverage these results to develop an open-source
implementation of our analysis adapted to deal with real Javacode. The core of the implementation is an algorithm whichcomputes critical pairs in a compositional, abstract interpretationstyle, running in quasi-exponential time. Our analyser is built inthe I
NFER veriﬁcation framework and has been in industrial
deployment for over two years; it has seen over two hundredﬁxed deadlock reports with a report ﬁx rate of ∼54%.
Index T erms—deadlocks, concurrency, program analysis
I. I NTRODUCTION
The avoidance and detection of deadlocks in a system
is one of the most fundamental problems in concurrency.
Deadlocking is classically exempliﬁed by Dijkstra’s "FiveDining Philosophers” [10]: Five philosophers sit around atable, with a fork between each pair of philosophers and a bowlof “a very difﬁcult kind of spaghetti” in the centre, so that eachphilosopher requires both their left and right forks in order toeat. Without any communication between the philosophers,they will generally enter a deadlocked situation in which it isimpossible for any of them to eat (for example if each of themimmediately takes the fork to their left). More generally, in aconcurrent program, a deadlock describes a situation in which,for some subset of that program’s threads, it is impossible thatany thread can eventually execute its next command.
In this paper, we attack the problem of detecting deadlocks
in Android Java applications under continuous developmentat Facebook. These applications are typically in the tens ofmillions of LoC, and undergo thousands of revisions per day.Our main aim is to assist the developers in ﬁnding bugsintroduced by their code revisions, and thus there are twoprincipal desiderata of our deadlock analysis. The ﬁrst is that itmust return reports to developers relatively quickly, the targetbeing under 15 minutes. It is impossible to analyse whole,large programs in their entirety within such a timeframe, whichmeans that we need a method that works compositionally,
enabling us to focus only on the changed ﬁles and theirdependents. The second is that reports from our analysis mustactually be useful to developers, meaning that we focus on
minimising the number of false positive reports, as opposedto providing cast-iron guarantees of deadlock absence.
Our ﬁrst step is to model the real programming language as
an abstract programming language in which we can decide thepresence of deadlocks within a reasonable complexity bound.The abstract programming language we use is based on scoped(a.k.a. “nested”) re-entrant locks, nondeterministic iterationand branching, and nonrecursive procedure calls; it can beseen as an overapproximate model of Java, with all informationabout variable and memory assignment abstracted away.
We show that the existence of a deadlock in our abstract
programs can be precisely characterised as a condition on thecritical pairs of their (sequential) threads. Roughly speaking,
a critical pair of a thread is a pair (X,/lscript)such that some
execution of the thread acquires an unheld lock /lscriptwhile already
holding the set of locks X. For the case of two threads, we
establish that C
1||C2deadlocks if and only if there are critical
pairs(X1,/lscript1)and(X2,/lscript2)ofC1andC2respectively such
that/lscript1∈X2and/lscript2∈X1, withX1∩X2=∅; this condition
can be generalised to the case of arbitrarily many threads(cf. Theorem 4.4). Similar to other deadlock conditions in theliterature for communicating pushdown automata [24], [25],its correctness is crucially dependent on the fact that lockingisbalanced in our language, in that any thread must release
locks in the reverse of the order in which they are acquired, i.e.“last in, ﬁrst out”. This is true of real programming languageswhenever scoped-locking constructs are used, such as Java’ssynchronized keyword or C++’s std::lock_guard.
Since the set of critical pairs of any thread in our languageis in fact ﬁnite and computable, the existence of deadlocks inour abstract programs becomes decidable, and in NP.
Example 1.1. Consider a two-threaded program C
1||C2,
whereC1andC2are sequential programs acquiring locks
9552021 36th IEEE/ACM International Conference on Automated Software Engineering (ASE)
Work licensed under Creative Commons Attribution 4.0 License. https://creativecommons.org/licenses/by/4.0/
DOI 10.1109/ASE51524.2021.000882021 36th IEEE/ACM International Conference on Automated Software Engineering (ASE) | 978-1-6654-0337-5/21/$31.00 ©2021 IEEE | DOI: 10.1109/ASE51524.2021.9678572
(acq(−)) and releasing them (rel( −)) in reverse order:
C1:acq(x);acq(y);skip; rel(y);rel(x)
C2:acq(y);acq(x);skip; rel(x);rel(y)
C1has two critical pairs, (∅,x)and({x},y), and similarly
C2has two critical pairs (∅,y)and({y},x). By taking
(X1,/lscript1)=({x},y)and(X2,/lscript2)=({y},x), we can see that
the condition above is met, and indeed C1||C2deadlocks,
because there is an execution in which, simultaneously, C1
holdsxwhile waiting for y, andC2holdsywhile waiting
forx. Now consider the modiﬁed program C/prime
1||C/prime
2, where
C/prime
1=acq(z);C1;rel(z)andC/prime
2=acq(z);C2;rel(z).C/prime
1
now has three critical pairs (∅,z),({z},x)and({z,x},y),
andC/prime
2has critical pairs (∅,z),({z},y)and({z,y},x).I n
this case, the condition above is not met, and indeed C/prime
1||C/prime
2
does not deadlock, because zacts as a “guard lock” preventing
xandyfrom being accessed by C/prime
1andC/prime
2simultaneously.
We then leverage these theoretical results to design an
automatic deadlock analyser geared speciﬁcally towards code
changes in Android Java applications (in Section VI-B weoutline the Android-speciﬁc features of the analysis). Thecore of our implementation is a context-insensitive programanalysis that computes critical pairs in abstract interpretationstyle, running in quasi-exponential time in the syntactic sizeof the program. Crucially, this analysis is compositional in
that the critical pairs of a procedure call depend only onthe current state of the caller and the critical pairs of theprocedure itself, which can be computed in advance. Thismeans that, when analysing a code revision, we do not need tore-analyse the unchanged procedures in the program (i.e., theoverwhelming majority). These properties enable our analysisto detect deadlocks in programs ranging in the tens of millionsof LoC: two orders of magnitude larger than the largestprograms handled by state-of-the-art static deadlock detectors.
We provide an open-source implementation of our analyser
— named starvation and included as part of the I
NFER
static analysis framework [1] — and describe its deploymentand impact at Facebook, where it has analysed many hundredsof thousands of code revisions and seen over two hundreddeadlock reports ﬁxed in the last two years.
Important note. Contrary to what many readers may well
expect, we do not undertake an experimental comparisonof our tool with others in the literature, due to two majordivergences between our tool and others. The ﬁrst and mostimportant point of divergence is that most — if not all —of the tools in the literature require the whole program in
order to run. Since the programs we target are so large,these analysers might take hours or days to return a result,or simply run out of memory. In contrast, our tool can runrelatively quickly on these programs because it only analysescode changes, relying on compositionality of the analysis withrespect to the unchanged portions of the program. The second,less important divergence is that, since our priority is to avoidwasting developers’ time, we prioritise actionability of thetool’s deadlock reports, which means that we generally preferto admit false negative than false positive deadlock reports. Incontrast, most tools that we know of do just the opposite.
The remainder of this paper is structured as follows.
Section II introduces our abstract concurrent programs. InSection III we develop the key connections between sequentialprogram executions and their traces (of lock acquisitions and
releases). Then, in Section IV, we establish the soundness andcompleteness of our deadlock condition based on critical pairs.In Section V we show that the critical pairs of any sequentialprogram are computable, and so establish upper complexitybounds on the deadlock problem. Section VI describes ourimplementation of the deadlock analysis for Android Java, andits deployment impact at Facebook. Section VII surveys therelated work, and Section VIII concludes.
For space reasons, the proofs of our theoretical results
are only sketched in the present paper. However, the entiredevelopment has also been fully formalised in the Coq proofassistant, in roughly 8.7K lines of code.
II. P
ROGRAM SYNT AX AND SEMANTICS
Syntax. We let Locks be a ﬁnite set of global lock names and
Procs a set of procedure names. We deﬁne statements Cas
follows, where /lscriptranges over Locks andpover Procs :
C:=skip|p()|acq(/lscript)|rel(/lscript)|C;C
|if(∗)thenCelseC|while(∗)doC
We assume there is a function body() : Procs→Stmt
that sends every procedure name to a statement, its body.A function computing the callees of a statement callees(·):
Stmt→P(Procs)can be easily deﬁned. We forbid recursion
in statements; i.e., for all p∈Procs ,p/∈callees( body(p)).
A statement is called balanced if it is generated by the
following grammar, which ensures that acq(/lscript)andrel(/lscript)
only appear in balanced pairs:
C:=skip|p()|acq(/lscript);C;rel(/lscript)|C;C
|if(∗)thenCelseC|while(∗)doC
Moreover, balanced statements must call only balanced pro-cedures: if Cis balanced and p∈callees(C), then body(p)
must be balanced as well. We note that our balanced state-ments are similar to those produced by compiling scope-basedconstructs like Java’s synchronized keyword, or C++’s
std::lock_guard.
We will frequently need to reason by structural induction
over (balanced) statements. To account for procedure calls insuch proofs, we employ an extended notion of “substructure”for statements, given as the reﬂexive-transitive closure of thefollowing condition: any sub-statement of C(according to the
grammar above) is a substructure of C, and body(p) is a
substructure of p(). Since our procedures are non-recursive,
this ordering is still well-founded.
Finally, a parallel program is ann-tuple of balanced state-
ments written C
1||...||Cn.
Semantics. As our programs employ only lock guards and
non-deterministic control, our program states record only
956information about locks. We treat locks as re-entrant in that
a thread already holding a lock can re-acquire it without
deadlock.
Alock state is a function L:Locks→N, recording how
many times each lock has been acquired. We use the notation⌊L⌋ for{/lscript∈Locks|L(/lscript)>0}.I fL
1andL2are lock states
then we write L1#L2to mean that ⌊L1⌋∩⌊L2⌋=∅.W e
write∅for the lock state sending all locks to 0. We write
L[/lscript++] andL[/lscript−−] for the lock states deﬁned as L, except
thatL[/lscript++](/lscript)=L(/lscript)+1 andL[/lscript−−](/lscript)=L(/lscript)−1.
Aconﬁguration is a pair /angbracketleftC,L/angbracketright, whereCis a statement
andLis a lock state. A concurrent conﬁguration is then
a pair of the form /angbracketleftC1||...||Cn,(L1,...,L n)/angbracketright, where
C1||...||Cnis a parallel program and L1,...,L nare
lock states. We may also write concurrent conﬁgurations as/angbracketleftC
1,L1/angbracketright| |...|| /angbracketleftC n,Ln/angbracketright, or, using a “Σ-like” notation, as
||1≤i≤n/angbracketleftCi,Li/angbracketright. We write /angbracketleftCi,Li/angbracketright#/angbracketleftCj,Lj/angbracketrightto mean that
Li#Ljand, ifXis a set of lock states, L#Xto mean
thatL#L/primefor allL/prime∈X.
In Figure 1 we deﬁne the operational semantics of our
programs by giving the small-step relations for statementson ordinary conﬁgurations, →, and for parallel programs on
concurrent conﬁgurations, /squiggleright.A n execution (of statement C)
is then as usual a possibly inﬁnite sequence of conﬁgurationsπ=(γ
i)i≥0(withγ0=/angbracketleftC,_/angbracketright) such that γi→γi+1 for
alli≥0.Aconcurrent execution is deﬁned analogously
to an execution, by substituting concurrent conﬁgurations forconﬁgurations and /squigglerightfor→.
We often represent executions (γ
i)i≥0asγ0→∗γn, where
→∗is the reﬂexive-transitive closure of →, and similarly using
/squiggleright∗for concurrent executions.
Remark 2.1. F or any concurrent execution γ1||...||γn/squiggleright∗
γ/prime
1||...||γ/prime
nthere exist standard executions γi→∗γ/prime
ifor
each1≤i≤n. Furthermore, if γi#γj, thenγ/prime
i#γ/prime
j; i.e.,
no two threads can acquire the same lock simultaneously.
We deﬁne deadlock of a program to mean that at least
two of its threads are deadlocked. For this, we introduce anotation for projecting a concurrent conﬁguration onto a subsetof its threads. If σ=/angbracketleftC
1||...||Cn,(L1,...,L n)/angbracketrightis a
concurrent conﬁguration and I={i1,...,im}⊆{1,...,n}
is a set of “thread indices”, we write σIto mean the concurrent
conﬁguration /angbracketleftCi1,Li1/angbracketright| |...... || /angbracketleftCim,Lim/angbracketright.
Deﬁnition 2.2 (Deadlock). A concurrent conﬁguration, say
σ=/angbracketleftC1||...||Cn,(L1,...,L n)/angbracketright,i s deadlocked if there is
a sequential transition /angbracketleftCi,Li/angbracketright→/angbracketleftC/prime
i,L/prime
i/angbracketrightfor each thread
(i.e. for all 1≤i≤n) but there is no concurrent transition
σ/squigglerightσ/prime.
A parallel program C1||...||Cnis said to deadlock if
we have that /angbracketleftC1||...||Cn,(∅,...,∅)/angbracketright/squiggleright∗σandσIis
deadlocked for some I⊆{1,...,n}.
An immediate consequence is that if C1||...||Cmdead-
locks and m≤n, thenC1||...||Cnalso deadlocks.Proposition 2.3. Letσ=/angbracketleftC1||...||Cn,(L1,...,L n)/angbracketrightbe
a concurrent conﬁguration such that Li#Ljfor alli/negationslash=
j. The conﬁguration σis deadlocked iff there are statements
D1,...,D nand locks /lscript1,...,/lscript nsuch that, for all 1≤i≤n
/angbracketleftCi,Li/angbracketright→/angbracketleftDi,Li[/lscripti++]/angbracketright and/lscripti∈/uniontext
j/negationslash=i⌊Lj⌋.
Proof. Follows from the operational semantics.
III. E XECUTIONS AND TRACES
In this section, we develop a key technical idea: any
execution of a statement (in an arbitrary lock state) can be
viewed simply as a sequence of lock acquisitions /lscriptand releases
/lscript, which we call the execution’s trace. Thus, for example, the
two possible executions of the statement
acq(/lscript);if(∗)then(acq(j);skip; rel(j))
else(acq(k);skip; rel(k));rel(/lscript)
have respective traces /lscriptjj/lscriptand/lscriptkk/lscript, depending on which
branch of the if statement is chosen.
Traces preserve the essential information about executions,
in that the effect of an execution on any given initial lockstate can be computed from its trace. Moreover, executionsofbalanced statements have traces that are essentially well-
parenthesized strings of lock acquisitions and releases; in factthey are Dyck words in formal language theory [21].
Deﬁnition 3.1. The lock alphabet Σis deﬁned as the union
of two disjoint copies of Locks :
Σ: ={/lscript|/lscript∈Locks}∪{
/lscript|/lscript∈Locks}.
Aquasi-lock state is a function in Locks→Z. We lift the no-
tations[/lscript++] and[/lscript−−] from lock states to quasi-lock states
in the obvious way, and write +on quasi-lock states to denote
the pointwise sum of functions, i.e. (f+g)(x)=f(x)+g(x).
We deﬁne the function /angbracketleft·/angbracketrightfromΣ-words to quasi-lock states
inductively, as follows:
/angbracketleftε/angbracketright:=∅/angbracketleftu/lscript/angbracketright:=/angbracketleftu/angbracketright[/lscript++]/angbracketleftu/lscript/angbracketright:=/angbracketleftu/angbracketright[/lscript−−].
Lemma 3.2. F or allu,v∈Σ⋆we have/angbracketleftuv/angbracketright=/angbracketleftu/angbracketright+/angbracketleftv/angbracketright.
Proof. By structural induction on v.
In any sequential execution step /angbracketleftC,L/angbracketright→/angbracketleftC/prime,L/prime/angbracketrightwe have
L/prime=L,o rL/prime=L[/lscript++] orL/prime=L[/lscript−−] for some lock /lscript.
This justiﬁes the following deﬁnition.
Deﬁnition 3.3. Given a transition /angbracketleftC,L/angbracketright→/angbracketleftC/prime,L/prime/angbracketright,w e
deﬁne its traceu∈Σ∪{ε}as follows:
u=⎧
⎪⎨
⎪⎩εifL/prime=L
/lscriptifL/prime=L[/lscript++]
/lscriptifL/prime=L[/lscript−−].
The trace of an execution is then deﬁned as the concatenation
of the traces of its individual transitions. We often writetransitions and executions with their trace above the arrow,as in/angbracketleftC,L/angbracketright
u− −→/angbracketleftC/prime,L/prime/angbracketrightand/angbracketleftC,L/angbracketrightu− − →∗/angbracketleftC/prime,L/prime/angbracketright.
957/angbracketleftskip;C,L/angbracketright→/angbracketleftC,L/angbracketright (skip) /angbracketleftif(∗)thenCaelseCb,L/angbracketright→/angbracketleftCa,L/angbracketright (if1)
/angbracketleftp(),L/angbracketright→/angbracketleft body (p),L/angbracketright (proc) /angbracketleftif(∗)thenCaelseCb,L/angbracketright→/angbracketleftCb,L/angbracketright (if2)
/angbracketleftacq(/lscript),L/angbracketright→/angbracketleft skip,L [/lscript++]/angbracketright (acq) /angbracketleftwhile(∗)doC,L/angbracketright→/angbracketleft skip,L/angbracketright (while1)
/angbracketleftrel(/lscript),L/angbracketright→/angbracketleft skip,L [/lscript−−]/angbracketright (L(/lscript)>0)(rel) /angbracketleftwhile(∗)doC,L/angbracketright→/angbracketleftC;while(∗)doC,L/angbracketright(while2)
/angbracketleftC1,L/angbracketright→/angbracketleftC/prime
1,L/prime/angbracketright
/angbracketleftC1;C2,L/angbracketright→/angbracketleftC/prime
1;C2,L/prime/angbracketright(seq)/angbracketleftCi,Li/angbracketright→/angbracketleftC/prime
i,L/prime
i/angbracketrightL/primei#{Lj|j/negationslash=i}
/angbracketleftC1||...||Cn,(L1,...,L n)/angbracketright/squiggleright/angbracketleftC1||...||C/prime
i||...||Cn,(L1,...,L/primei,...,L n)/angbracketright(pari)
Fig. 1. Small-step semantics for statements (→) and parallel programs (/squiggleright).
Proposition 3.4. F or any execution /angbracketleftC0,L0/angbracketrightu− − →∗/angbracketleftCn,Ln/angbracketright
and statement C, we can obtain an execution /angbracketleftC0;C,L 0/angbracketrightu− − →∗
/angbracketleftCn;C,Ln/angbracketrightwith the same trace.
Proof. By inductively applying the semantic rule (seq) .
We deﬁne the language of a statement, roughly speaking,
as the set of traces of its possible executions. Subsequent
technical results will make this correspondence precise.
Deﬁnition 3.5. The language L(C)of a statement Cis deﬁned
inductively as follows:
L(skip):={ε}L (p()):=L(body(p))
L(acq(/lscript)):={/lscript}L (rel(/lscript)):={/lscript}
L(C1;C2):=L(C1)·L(C2)
L(if(∗)thenC1elseC2):=L(C1)∪L(C2)
L(while(∗)doC):=L(C)⋆
Remark 3.6. L(C)is in fact a regular language overΣ.
Our next lemma establishes that the effect of an execution
is essentially determined by its trace.Lemma 3.7. F or any execution π:/angbracketleftC,L/angbracketright
u− − →∗/angbracketleftC/prime,L/prime/angbracketrightwe
haveL/prime=L+/angbracketleftu/angbracketrightandu·L(C/prime)⊆L(C).
Proof. We ﬁrst prove the lemma for a single →-step by rule
induction on the semantics. The general result then follows by
reﬂexive-transitive induction on →∗.
Next, we recall the notion of Dyck words over our lock
alphabet Σ— essentially the well-parenthesized words of
opening and closing “parentheses” /lscriptand/lscript— and relate them
to executions of balanced statements.
Deﬁnition 3.8. The language Dof Dyck words overΣis
generated by the following grammar:
D:=ε|DD|/lscriptD/lscript.
The following lemmas establish basic properties of our
Dyck words and their relation to our mapping /angbracketleft·/angbracketright, and are
all proven by structural induction (using Lemma 3.2).
Lemma 3.9. IfCis a balanced statement, L(C)⊆D .
Lemma 3.10. F or anyu/lscriptv∈D , there exist words u1∈Σ⋆
andu2∈D such that u=u1/lscriptu2.
Lemma 3.11. F or anyu∈D we have/angbracketleftu/angbracketright=∅.Lemma 3.12. F or anyuv∈D we have/angbracketleftu/angbracketright∈Locks →N.
We now establish an analogue of Lemma 3.10 for executions
of balanced statements, which will be essential later for
“disentangling” concurrent executions (see Lemma 4.3).
Lemma 3.13. LetCbe a balanced statement. F or any
execution of the form
/angbracketleftC,∅/angbracketright=/angbracketleftC0,L0/angbracketright→∗/angbracketleftCn,Ln/angbracketright→/angbracketleftCn+1,Ln[/lscript−−]/angbracketright,
there exists j<n such that Lj=Ln[/lscript−−] andLj+1=Ln.
Proof. Follows from Lemmas 3.2, 3.7, 3.9, 3.10 and 3.11.
The ﬁnal main result in this section is a kind of converse
to Lemma 3.7, albeit for balanced statements only.Lemma 3.14. LetCbe a balanced statement, and let uv∈
L(C). F or any lock state L, there is a statement Dand an
execution π:/angbracketleftC,L/angbracketright
u− − →∗/angbracketleftD,L+/angbracketleftu/angbracketright/angbracketright such that v∈L(D).
Ifv=ε, then this statement also holds when D=skip.
Proof. By structural induction on C, making use of earlier
results. The main idea is to analyse the trace uv∈L(C)in
order to inductively build an execution of Cwith trace u.
Note that Lemma 3.14 does not hold for non-balanced
statements. E.g., /lscript∈L(rel(/lscript)), but there are no executions
of/angbracketleftrel(/lscript),∅/angbracketright.
Corollary 3.15. F or any balanced statement C, we have
L(C)={u|/angbracketleftC,∅/angbracketrightu− − →∗/angbracketleftskip,∅/angbracketright}.
Proof. The⊇inclusion follows from Lemma 3.7 and the ⊆
inclusion from Lemma 3.14 (with v=ε).
Example 3.16. LetCbe the statement from the beginning of
this section:
acq(/lscript);if(∗)then(acq(j);skip; rel(j))
else(acq(k);skip; rel(k));rel(/lscript)
From Deﬁnition 3.5 we have L(C)={/lscriptjj/lscript,/lscriptkk/lscript}, and
there are exactly two possible executions of Cfrom the empty
lock state ∅(we omit the intermediate commands and the
skip steps):
/angbracketleftC,∅/angbracketright/lscript− −→/angbracketleft _,{/lscript}/angbracketrightε− −→/angbracketleft _,{/lscript}/angbracketrightj− −→/angbracketleft _,{/lscript,j}/angbracketrightj− −→/angbracketleft _,{/lscript}/angbracketright/lscript− −→/angbracketleft skip,∅/angbracketright
/angbracketleftC,∅/angbracketright/lscript− −→/angbracketleft _,{/lscript}/angbracketrightε− −→/angbracketleft _,{/lscript}/angbracketrightk− −→/angbracketleft _,{/lscript,k}/angbracketrightk− −→/angbracketleft _,{/lscript}/angbracketright/lscript− −→/angbracketleftskip,∅/angbracketright
958The ﬁrst execution has trace /lscriptjj/lscript, and the second has trace
/lscriptkk/lscript. Thus indeed L(C)={u|/angbracketleftC,∅/angbracketrightu− − →∗/angbracketleftskip,∅/angbracketright}.
Remark 3.17. Statements can be viewed as string accepters
onΣ-words, where Cacceptsuiff/angbracketleftC,∅/angbracketrightu− − →∗/angbracketleftskip,∅/angbracketright.I f
Cis balanced then, by Corollary 3.15, it accepts exactly L(C).
SinceL(C)is a regular language, this means that balanced
statements can be viewed as ﬁnite automata.
IV . C HARACTERISA TION OF DEADLOCK EXISTENCE
Here, we obtain our main theoretical result: the existence
of a deadlock in a parallel program amounts to the existence
of a (certain kind of) conﬂict between individual “summaries”of its threads, called their (sets of) critical pairs. Roughly
speaking, a critical pair of a statement Cis a pair(X,/lscript)such
that some execution of Cacquires the lock /lscriptwhile holding
the set of locks X(which cannot already include /lscript). Our main
correctness result is stated as Theorem 4.4.
Deﬁnition 4.1. The set Crit(C)ofcritical pairs of a statement
Cis deﬁned as:
Crit(C):={(⌊/angbracketleftu/angbracketright⌋,/lscript)|∃v.u/lscriptv∈L(C)and/lscript/∈⌊ /angbracketleftu/angbracketright⌋}.
The reason for our language-based deﬁnition of Crit(C),
as opposed to an execution-based one, is that it turns out to be
easy to compute (see Section V). The following lemma givesan equivalent formulation in terms of executions.
Lemma 4.2. LetCbe a balanced statement. We have that
(X,/lscript)∈Crit(C)iff there exist statements C
/prime,C/prime/primeand a lock
stateLsuch that /angbracketleftC,∅/angbracketright→∗/angbracketleftC/prime,L/angbracketright→/angbracketleftC/prime/prime,L[/lscript++]/angbracketright , with
X=⌊L⌋ and/lscript/∈X.
Proof. The (⇐) direction follows from Lemma 3.7, and the
(⇒) direction from Lemma 3.14.
Our ﬁnal and most crucial lemma shows essentially that,
for balanced statements, considerations of reachability on the
concurrent transition relation /squigglerightcan be reduced to reachability
on the sequential relation →.
Lemma 4.3. SupposeC1||...||Cndoes not deadlock. Then
/angbracketleftC1||...||Cn,(∅,...,∅)/angbracketright/squiggleright∗γ1||...||γniff, for each
1≤i≤n, we have /angbracketleftCi,∅/angbracketright→∗γiwithγi#{γj|j/negationslash=i}.
Proof. (Sketch) The (⇒) direction is immediate from Re-
mark 2.1. For the (⇐) direction, we write γi,j=/angbracketleftCi,j,Li,j/angbracketright
for thejth conﬁguration in the execution πi:/angbracketleftCi,∅/angbracketright→∗γi.
An arbitrary concurrent conﬁguration given by an interleavingfrom these nexecutions is given by ||
1≤i≤nγi,ji. We call
such a conﬁguration compatible whenγi,ji#γk,jkfor all
k/negationslash=i, and reachable when/angbracketleftC1||...||Cn,(∅,...,∅)/angbracketright/squiggleright∗
||1≤i≤nγi,ji. It then sufﬁces to show that if ||1≤i≤nγi,jiis
compatible then it is also reachable.
We proceed by induction on J=Σ 1≤i≤nji. The
caseJ=0 is trivial. Otherwise, J>0and we con-
sider the compatibility of the “preceding” conﬁgurationsγ
k,jk−1|| ||1≤i≤n,i/negationslash=kγi,ji, where 1≤k≤n.W et h e n
consider two main subcases.The ﬁrst subcase is that some γk,jk−1|| ||1≤i≤n,i/negationslash=kγi,jiis
compatible. In that case, using the induction hypothesis andthe assumption that ||
1≤i≤nγi,jiis compatible, we have that
||1≤i≤nγi,jibecomes reachable by applying (pari).
The remaining subcase is then that noconﬁguration of the
formγk,jk−1|| ||1≤i≤n,i/negationslash=kγi,jiis compatible; we can assume
without loss of generality that these conﬁgurations are deﬁnedfor the ﬁrst m≥2threads and undeﬁned otherwise. Now,
letting1≤k≤m, we must have L
k,jk=Lk,jk−1[/lscriptk−−] for
some lock /lscriptk, by the subcase assumption. By Lemma 3.10,
we can ﬁnd hk<jksuch that Lk,hk=Lk,jkandLk,hk+1=
Lk,jk−1. It follows that ||1≤k≤mγk,hk|| ||m+1≤i≤nγi,ji
is also compatible. Thus, by the induction hypothesis that||
1≤k≤mγk,hk|| ||m+1≤i≤nγi,jiis reachable. To conclude
the proof, we show that ||1≤k≤mγk,hkis deadlocked, and
thusC1||...||Cndeadlocks, a contradiction.
If not, then ||1≤k≤mγk,hk/squigglerightσfor some σvia an
application of the rule (pari). In that case, we can de-
duce from the lock state information that Ci,himust begin
with the command acq(/lscripti)and soLi,hi+1=Li,ji−1. Thus
Li,ji−1#{Lk,hk|k/negationslash=i}. Since Lk,hk=Lk,jkfor each
k, this means that γi,ji−1|| ||1≤k≤m,k/negationslash=iγi,jiis compatible,
which contradicts the subcase assumption and so completesthe proof.
We are now ﬁnally in a position to characterise deadlock
existence as a “conﬂict condition” on the critical pairs of itssequential components.
Theorem 4.4 (Deadlock characterisation). A parallel program
C
1||...||Cndeadlocks iff, for some I⊆{1,...,n}with
cardinality ≥2, there are critical pairs (Xi,/lscripti)for eachi∈I
such that Xi∩/uniontext
j/negationslash=iXj=∅and/lscripti∈/uniontext
j/negationslash=iXj.
Proof. Case (⇒): Suppose C1||...||Cndeadlocks, mean-
ing that /angbracketleftC1||...||Cn,(∅,...,∅)/angbracketright/squiggleright∗σandσIis
deadlocked, for some index set I; without loss of gener-
ality, we assume that I={1,...,m }, and thus σI=
/angbracketleftD1||...||Dm,(L1,...,L m)/angbracketright. By Remark 2.1, we have for
each1≤i≤ma sequential execution /angbracketleftCi,∅/angbracketright→∗/angbracketleftDi,Li/angbracketright
withLi#{Lj|j/negationslash=i}.
SinceσIis deadlocked and Li#Ljfor alli/negationslash=j,
we have /angbracketleftDi,Li/angbracketright→/angbracketleftD/prime
i,Li[/lscripti++]/angbracketright with/lscripti∈/uniontext
j/negationslash=i⌊Lj⌋
for all1≤i≤m, by Proposition 2.3. Thus we have
executions /angbracketleftCi,∅/angbracketright→∗/angbracketleftDi,Li/angbracketright→/angbracketleftD/prime
i,Li[/lscripti++]/angbracketright , with
/lscripti/∈⌊Li⌋, because /lscripti∈/uniontext
j/negationslash=i⌊Lj⌋andLi#{Lj|j/negationslash=i}.
By Lemma 4.2, we obtain (⌊Li⌋,/lscripti)∈Crit(Ci). Taking
Xi=⌊Li⌋for eachi, all required conditions are satisﬁed.
Case (⇐): We assume w.l.o.g. that I={1,...,m }, where
m≥2. Let1≤i≤m; using (Xi,/lscripti)∈Crit(Ci)we have by
Lemma 4.2 that /angbracketleftCi,∅/angbracketright→∗/angbracketleftC/prime
i,Li/angbracketright→/angbracketleftC/prime/prime
i,Li[/lscripti++]/angbracketright and
Xi=⌊Li⌋and/lscripti/∈Xi. Moreover, since Xi∩/uniontext
j/negationslash=iXj=∅,
we haveLi#{Lj|j/negationslash=i}.
Now, suppose that C1||...||Cmdoes not deadlock. In
that case Lemma 4.3 yields /angbracketleftC1||...||Cm,(∅,...,∅)/angbracketright/squiggleright∗
/angbracketleftC/prime
1||...||C/prime
m,(L1,...,L m)/angbracketright, and hence the latter con-
ﬁguration cannot be deadlocked. But because /angbracketleftC/prime
i,Li/angbracketright→
959/angbracketleftC/prime/prime
i,Li[/lscripti++]/angbracketright and/lscripti∈/uniontext
j/negationslash=i⌊Lj⌋for each i(using the
assumption that /lscripti∈/uniontext
j/negationslash=iXj), this conﬁguration actually
isdeadlocked, by Proposition 2.3. Thus, C1||...||Cm
deadlocks after all, a contradiction.
The following example illustrates our deadlock condition.
Example 4.5. Deﬁne statements C1,...,C nas follows:
C1:=acq(/lscript2);acq(/lscript1);skip; rel(/lscript1);rel(/lscript2);
C2:=acq(/lscript3);acq(/lscript2);skip; rel(/lscript2);rel(/lscript3);
...
Cn−1:=acq(/lscriptn);acq(/lscriptn−1);skip; rel(/lscriptn−1);rel(/lscriptn);
Cn:=acq(/lscript1);acq(/lscriptn);skip; rel(/lscriptn);rel(/lscript1);
We have ({/lscript(i+1) mod n},/lscripti)∈Crit(Ci)for each1≤i≤n.
These critical pairs satisfy the deadlock condition of Theo-
rem 4.4, and indeed C1||...||Cndeadlocks, by executing
the ﬁrst acq(−)command in each thread. Conversely, any
smaller subset of these threads, e.g. C1||...||Cn−1, does
not satisfy the deadlock condition, and indeed we can observethatC
1||...||Cn−1does not deadlock.
V. C OMPUTING CRITICAL PAIRS
Having established that the existence of a deadlock in a
parallel program reduces to a condition over the critical pairsof its threads (Theorem 4.4), our next order of business is toshow that Crit(C)is in fact computable for any balanced
statement C— something that is perhaps not immediately
obvious from Deﬁnition 4.1. Here we establish a set of usefulidentities enabling us to compute Crit(C)inductively, with
the consequence that the deadlock problem for our languageis decidable and in NP (Theorem 5.5).
Proposition 5.1. The following identities hold for all balanced
statements C,C
/primeand locks /lscript:
Crit( skip)= ∅ (C1)
Crit(p()) = Crit( body(p)) (C2)
Crit( if(∗)thenCelseC/prime)=Crit(C)∪Crit(C/prime)(C3)
Crit(C;C/prime)=Crit(C)∪Crit(C/prime)(C4)
Crit( while(∗)doC)=Crit(C) (C5)
Crit( acq(/lscript);C;rel(/lscript)) ={(∅,/lscript)}∪
{(X∪{/lscript},/lscript/prime)|(X,/lscript/prime)∈Crit(C)and/lscript/negationslash=/lscript/prime}(C6)
Proof. We show each identity directly from Deﬁnition 4.1,
making use of auxiliary lemmas from section III.
Example 5.2. We continue Example 3.16, where Cis the
statement:
acq(/lscript);if(∗)then(acq(j);skip; rel(j))
else(acq(k);skip; rel(k));rel(/lscript).
First, using equations (C1) and (C6), we get
Crit( acq(j);skip; rel(j)) ={(∅,j)}
and Crit( acq(k);skip; rel(k)) ={(∅,k)}.Thus, writing C=acq(/lscript);C/prime;rel(/lscript), equation (C3) gives us
Crit(C/prime)={(∅,j),(∅,k)}. Finally, applying (C6) once again
and observing that j,k/negationslash=/lscript,w eg e t
Crit(C)=Crit( acq(/lscript);C/prime;rel(/lscript))
={(∅,/lscript)}∪{({/lscript},j),({/lscript},k)}
={(∅,/lscript),({/lscript},j),({/lscript},k)}.
Next we undertake a brief complexity analysis. We write
#X for the cardinality of a ﬁnite set X.
Deﬁnition 5.3. F or any statement C, deﬁne its size/bardblC/bardblby
/bardblC/bardbl:=|C|+/summationtext
p∈callees(C )|body(p)|,
where|C|is deﬁned inductively as follows:
|skip|=|acq(/lscript)|=|rel(/lscript)|=|p()|=1
|if(∗)thenC1elseC2|=|C1;C2|=|C1|+|C2|
|while(∗)doC|=|C|
Proposition 5.4. Crit(C)is ﬁnite and computable for any
balanced statement C, with#Crit(C)≤/bardblC/bardbl1+#callees(C )
and#X</bardblC/bardblfor all(X,/lscript)∈Crit(C).I fC does not
contain any procedure calls, then #Crit(C)≤|C|.
Proof. By structural induction on C, using Prop. 5.1.
To precisely state complexity bounds on the deadlock prob-
lem, we deﬁne the size of a parallel program as the sum ofthe sizes of its threads: /bardblC
1||...||Cn/bardbl=/summationtext
1≤i≤n/bardblCi/bardbl.
Theorem 5.5. Whether a given parallel program deadlocks
or not is decidable, and in NP.
Proof. We just need to show how to check the deadlock
condition of Theorem 4.4 in nondeterministic polynomial time.TheNP procedure runs in three stages: (i) nondeterministically
select an index set I⊆{1,...,n}of size≥2; (ii) nondeter-
ministically compute a critical pair (X
i,/lscripti)for eachi∈I,b y
recursing on the structure of Ciand using the equations (C1)–
(C6) in Proposition 5.1; (iii) verify that Xi∩/uniontext
j/negationslash=iXj=∅and
/lscripti∈/uniontext
j/negationslash=iXjfor alli,j∈I. The last step can be done in
polynomial time in /bardblP/bardblbecause, by Proposition 5.4, each Xi
is of size bounded by /bardblCi/bardbl.
Remark 5.6. An immediate consequence of Proposition 5.1 is
that, for any balanced statement C, its critical pairs Crit(C)
and size /bardblC/bardblboth remain unchanged under applications of
the following rewrite rules to substatements of C:
if(∗)thenC1elseC2/mapsto→C1;C2
and while(∗)doC/prime/mapsto→C/prime.
Therefore, the deadlock problem for our language reduces(polynomially) to the case where statements are restricted tothe ‘deterministic’ grammar:
C:= skip|p()|acq(/lscript);C;rel(/lscript)|C;C.
960VI. I MPLEMENT A TION AND IMPACT
In this section we describe our implementation of a compo-
sitional deadlock analysis tool for code changes in Android
Java applications. The core of the tool, described in Sec-tion VI-A, is an abstract interpretation analysis for computingthe critical pairs of a method. In Section VI-B we describe ourextension of this core procedure to an interprocedural analysisfor Android Java code, and in Section VI-C we discuss itsdeployment and impact at Facebook.
A. Core analysis in abstract interpretation style
The core of our implementation is an analysis that computes
the critical pairs of a statement in abstract interpretation style.
Given any statement C, we deﬁne an analysis function /llbracketC/rrbracket(·)
onabstract states, which track the lock state and the set of
critical pairs accumulated during the possible executions of C.
Deﬁnition 6.1. An abstract state is a pair /angbracketleftL,Z/angbracketright, whereL
is a lock state and Z⊆2
Locks×Locks . We deﬁne a partial
join operation /unionsqon abstract states by /angbracketleftL,Z 1/angbracketright/unionsq/angbracketleftL,Z 2/angbracketright=
/angbracketleftL,Z 1∪Z2/angbracketright. We often write αfor abstract states, and α⊥for
the “empty” abstract state /angbracketleft∅,∅/angbracketright.
The function /llbracketC/rrbracket(·)is then deﬁned by structural induction
onCin Figure 2. The clauses for the control ﬂow statements
are generic to abstract interpretation (given a suitable joinoperation /unionsq), which is why we do not simply deﬁne, e.g.,
/llbracketwhile(∗)doC/rrbracketα=α/unionsq/llbracketC/rrbracketαas would intuitively be implied
by equation (C5). However, this identity and similar ones canbe inferred from our correctness proof.
We draw particular attention to the clause for procedure
calls: computing the critical pairs of a procedure call p()
depends only on the current abstract state /angbracketleftL,Z/angbracketrightand the
critical pairs of the procedure body in the empty state,/llbracketbody(p)/rrbracketα
⊥, which can be computed “once and for all” in
advance. This means that our analysis is compositional in that,
when a procedure is changed, we only require to re-analysethat procedure and its dependents, not the whole program.
Proposition 6.2. F or any balanced statement Cand abstract
stateα=/angbracketleftL,Z/angbracketright, the result /llbracketC/rrbracketαof the analysis is given by
/angbracketleftL,Z∪{(⌊L⌋∪X,/lscript)|(X,/lscript)∈Crit(C)andL(/lscript)=0}/angbracketright.
Thus /llbracketC/rrbracketα
⊥=/angbracketleft∅,Crit(C)/angbracketright. Moreover , /llbracketC/rrbracketαis computable.
Proof. By structural induction on C, making use of the
equations (C1)–(C6) in Proposition 5.4.
Example 6.3. Continuing Example 5.2, statement Cis:
acq(/lscript);if(∗)then(acq(j);skip; rel(j))
else(acq(k);skip; rel(k));rel(/lscript)./llbracketacq(/lscript)/rrbracket/angbracketleftL,Z/angbracketright=/angbracketleftL[/lscript++],Z ∪Z/prime/angbracketright
whereZ/prime=/braceleftBigg
{(⌊L⌋,/lscript)} ifL(/lscript)=0
∅ ifL(/lscript)>0
/llbracketrel(/lscript)/rrbracket/angbracketleftL,Z/angbracketright=/angbracketleftL[/lscript−−],Z /angbracketright
/llbracketp()/rrbracket/angbracketleftL,Z/angbracketright=/angbracketleftL,Z∪Z/prime/angbracketright
where/angbracketleft_,Z/prime/prime/angbracketright=/llbracketbody (p)/rrbracketα⊥in
Z/prime={(⌊L⌋∪M,/lscript )|(M,/lscript )∈Z/prime/prime∧L(/lscript)=0}
/llbracketskip/rrbracketα =α
/llbracketC1;C2/rrbracketα = /llbracketC2/rrbracket(/llbracketC1/rrbracketα)
/llbracketif(∗)thenC1elseC2/rrbracketα =( /llbracketC1/rrbracketα)/unionsq(/llbracketC2/rrbracketα)
/llbracketwhile(∗)doC/rrbracketα =/unionsqtext∞
n=0/llbracketC/rrbracketnα
Fig. 2. Abstract analysis deﬁnition.
Writing abbreviations C=acq(/lscript);C/prime;rel(/lscript)andC/prime=
if(∗)thenC1elseC2, we have by the clauses for if and
for sequential composition (; ) in Figure 2:
/llbracketC/rrbracketα⊥=/llbracketacq(/lscript);C/prime;rel(/lscript)/rrbracketα⊥
=/llbracketC/prime;rel(/lscript)/rrbracket/llbracketacq(/lscript)/rrbracketα⊥
=/llbracketrel(/lscript)/rrbracket/llbracketC/prime/rrbracket/llbracketacq(/lscript)/rrbracketα⊥
=/llbracketrel(/lscript)/rrbracket/llbracketif(∗)thenC1elseC2/rrbracket/llbracketacq(/lscript)/rrbracketα⊥
=/llbracketrel(/lscript)/rrbracket(/llbracketC1/rrbracket/llbracketacq(/lscript)/rrbracketα⊥/unionsq/llbracketC2/rrbracket/llbracketacq(/lscript)/rrbracketα⊥).
This gives us the basic structure of the computation. Next,
using the rule for acq(/lscript)in Figure 2), we have
/llbracketacq(/lscript)/rrbracketα⊥=/llbracketacq(/lscript)/rrbracket/angbracketleft∅,∅/angbracketright
=/angbracketleft∅[/lscript++],{(∅,/lscript)}/angbracketright.
We write L/lscriptfor the lock state ∅[/lscript++] sending lock /lscriptto 1
(and all other locks to 0). Next, we have
/llbracketC1/rrbracket/llbracketacq(/lscript)/rrbracketα⊥
=/llbracketC1/rrbracket/angbracketleftL/lscript,{(∅,/lscript)}/angbracketright
=/llbracketacq(j);skip; rel(j)/rrbracket/angbracketleftL/lscript,{(∅,/lscript)}/angbracketright
=/llbracketskip; rel(j)/rrbracket/llbracketacq(j)/rrbracket/angbracketleftL/lscript,{(∅,/lscript)}/angbracketright
=/llbracketrel(j)/rrbracket/llbracketskip/rrbracket/llbracketacq( j)/rrbracket/angbracketleftL/lscript,{(∅,/lscript)}/angbracketright
=/llbracketrel(j)/rrbracket/llbracketskip/rrbracket/angbracketleftL /lscript[j++],{(∅,/lscript),({/lscript},j)}/angbracketright
=/llbracketrel(j)/rrbracket/angbracketleftL/lscript[j++],{(∅,/lscript),({/lscript},j)}/angbracketright
=/angbracketleftL/lscript[j++][j−−],{(∅,/lscript),({/lscript},j)}/angbracketright
=/angbracketleftL/lscript,{(∅,/lscript),({/lscript},j)}/angbracketright.
And, by a similar calculation,
/llbracketC2/rrbracket/llbracketacq(/lscript)/rrbracketα⊥=/angbracketleftL/lscript,{(∅,/lscript),({/lscript},k)}/angbracketright.
961Now, using the deﬁnition of our abstract join /unionsq,w eh a v e
/llbracketC1/rrbracket/llbracketacq(/lscript)/rrbracketα⊥/unionsq/llbracketC2/rrbracket/llbracketacq(/lscript)/rrbracketα⊥
=/angbracketleftL/lscript,{(∅,/lscript),({/lscript},j)}/angbracketright/unionsq/angbracketleftL/lscript,{(∅,/lscript),({/lscript},k)}/angbracketright
=/angbracketleftL/lscript,{(∅,/lscript),({/lscript},j),({/lscript},k)}/angbracketright.
Thus, putting everything together, we get
/llbracketC/rrbracketα⊥=/llbracketrel(/lscript)/rrbracket(/llbracketC1/rrbracket/llbracketacq(/lscript)/rrbracketα⊥/unionsq/llbracketC2/rrbracket/llbracketacq(/lscript)/rrbracketα⊥)
=/llbracketrel(/lscript)/rrbracket/angbracketleftL/lscript,{(∅,/lscript),({/lscript},j),({/lscript},k)}/angbracketright
=/angbracketleftL/lscript[/lscript−−],{(∅,/lscript),({/lscript},j),({/lscript},k)}/angbracketright
=/angbracketleft∅,{(∅,/lscript),({/lscript},j),({/lscript},k)}/angbracketright.
Thus, recalling our recursive computation of Crit(C)in
Example 5.2, we can see that indeed /llbracketC/rrbracketα⊥=/angbracketleft∅,Crit(C)/angbracketright.
Lemma 6.4. Given a balanced statement C, the computation
/llbracketC/rrbracketα⊥requires at most quasi-exponential time in /bardblC/bardbl.I fC
does not contain any procedure calls, the computation requires
at most quadratic time in |C|.
Proof. Follows from the fact that the computation of /llbracketC/rrbracketα⊥
is linear in the size of Crit(C)(its result) and the bounds on
Crit(C)given by Proposition 5.4.
Theorem 6.5. The problem of checking whether a parallel
program P=C1||...||Cndeadlocks can be solved in time
exponential in /bardblP/bardblandn. If the program does not contain
any procedure calls, checking for deadlocks can be solved intime polynomial in /bardblP/bardbland exponential in n.
Proof. Computing Crit(C
1),..., Crit(Cn)can be per-
formed in exponential time in /bardblP/bardbl, by Lemma 6.4, and
they contain at most exponentially many critical pairs, byProposition 5.4. Then, checking the deadlock condition ofTheorem 4.4 (over all possible index sets I) can be performed
within a time bound exponential in /bardblP/bardblandn.I fP does not
contain any procedure calls, then Lemma 6.4 and Prop. 5.4instead yield a time bound polynomial in /bardblP/bardbl(but still
exponential in n).
B. Analysing Android Java code changes
The requirement that the analysis targets code changes leads
to a number of design constraints, chief amongst which is thatthe analysis does not have the runtime envelope to analysethe whole program at hand; thus the analysis must work byanalysing a modest superset of the modiﬁed code in a commit.Such a constraint can be problematic in looking for concur-rency bugs due to their global nature. We note here techniquesfor addressing those difﬁculties as well as differences betweenimplementation and theory. We also outline features speciﬁc toAndroid Java which we leverage in our analysis (cf. paragraphsonNon-deterministic control and Concurrency inference).
Balanced locking. The correctness of our analysis relies on
balanced locking. As a general rule, this is good programmingpractice, supported in Java via the synchronized keyword,
and we have found very few instances of unbalanced lockingin the codebases targeted by our tool. This means that analysisprecision does not suffer and that no changes to the analysisare needed, and is one reason we opted for a balanced-lockinglanguage model in the ﬁrst place (the other reason beingdecidability). It is of course quite possible that unbalancedlocking might well be more prevalent in other domains, butthat is a matter of speculation. (Incidentally, our analyseractually will return a result when run on non-balanced code,
but its correctness is not then guaranteed.)
Non-deterministic control. Control in Java is mostly de-
terministic, so our abstract semantics is over-approximate.
In early trials of the tool, the majority of false positiveswe observed in practice stemmed from insensitivity to twoconditions: ﬁrstly, whether a lock acquisition succeeded (e.g.,viaLock.trylock); and secondly, whether the current
thread is the UI thread. Therefore, we specialised the imple-mentation domain to introduce partial path sensitivity on theseconditions; this eliminated most of the false positives due tocontrol abstraction.
Lock names. The set Locks must approximate the set of
Java objects that can be used as monitors. Rather than use
an expensive (and typically whole-program, which wouldrun against our main design constraint) pointer analysis, weuse access paths: syntactic expressions built with a program
variable root and iteration of ﬁeld- or array-dereferencing[22]. For example, this.f.g represents an object accessed
through dereferencing the ﬁeld fof the object this. Such
a domain of abstract addresses has several trade-offs withrespect to false positives and negatives, but that is beyondthe scope of this paper.
We also classify objects into globally referenced or objects
referenced through method parameters. Objects referencedthrough local variables are ignored. For globally referencedobjects, the rule for method calls in Figure 2 applies un-changed. For parameter-referenced objects we apply a substi-tution of argument expressions over parameters on the calleesummary before applying the procedure call rule. For instance,if the summary of method foo(x) involves the lock x.f,
then applying the procedure call rule on foo(h.g) will result
in the substitution [h.g/x] and the resulting critical pair at the
callsite will involve the monitor h.g.f.
Concurrency inference. Since whole-program analysis is
impracticable in our setting, we cannot always observe thespawning of execution threads, for these may happen inmethods that are unmodiﬁed and unrelated via the call graph.As such we use an abstract domain for thread identity, whereeach method can be: of unknown identity; the UI thread;some background thread; or both (it may be executed on theUI thread as well as background threads). We extract thisinformation from (a) thread annotations in Android code suchas@UiThread and@WorkerThread; (b) Android method
calls that test whether the current thread is the UI thread;(c) upward propagation through the call graph. Every criticalpair in a method summary is decorated with the inferred threadidentity, and this information is used to determine whether
962Fig. 3. Analysis report on textbook deadlock across two Java classes.
two critical pairs can occur concurrently (two UI-thread pairs
cannot be concurrent, though any other combination can).
Detecting deadlocks non-globally. As the analysis targets
code changes, it begins by summarising all methods in the
set of changed ﬁles in a commit. By the procedure callrule, this leads to analysing all methods transitively calledby the modiﬁed ﬁles. If we restrict deadlock detection tothis set of summaries, we will miss deadlocks due to lockacquisitions performed by methods outside the call graphrooted in modiﬁed ﬁles. Thus, the analysis selects additionalmethods to summarise using the following heuristic.
For every method Msummarised and every critical pair of
the form (L,root.f
1.....fn)in the summary of M, where
root is of class C, all methods of class Care also analysed (in
search of a critical pair (L/prime,/lscript/prime)where root.f 1.....fn∈L/prime).
The analyser continues this process until the set of analysedmethods reaches a ﬁxpoint.
This heuristic works well when certain Java idioms are
observed, namely when the monitors used are the this
object (for example, in synchronized methods), or they are
immutable private objects stored in object ﬁelds. For instance,this heuristic will catch the deadlock between classes Aand
Bin Figure 3 (where we also illustrate a sample report to
developers) even in a commit where only A.foo is modiﬁed.
It’s worth noting that our heuristic admits false negatives,e.g. when global locks are acquired in methods that residein classes not containing the globals. However, in the code weusually analyse global locks are signiﬁcantly less commonlyused than non-global objects.
C. Industrial deployment and impact
Our ﬂow-sensitive, context-insensitive analysis is imple-
mented in OCaml (around 3kLoC) within the I
NFER static
analysis framework [1], [11], and is speciﬁcally targeted at
detecting 2-thread deadlocks in code changes (commits) ofAndroid apps within a continuous integration environment
(CI).
Deployment. INFER is deployed at Facebook through a CI
system which launches an analysis job whenever a commit is
submitted for code review. This job concurrently runs multipleanalysers on the submitted code changes and appears to theauthors of the commit as yet another reviewer commentingon the code, based on the potential bugs found. The deadlock
analysis has been deployed on all Android code commits atFacebook for about two years.
Fixed reports. In a non-safety-critical context such as Face-
book, an analysis engineer’s time is better spent developing
analysis features than triaging reports for false positives. Thus,we track ﬁxed reports (reports that code authors addressedby submitting a new version of a commit) rather than truepositives. Since it was deployed, the deadlock analyser has
processed hundreds of thousands of commits, has issued morethan 500 deadlock reports with a ﬁx rate of 54%.
As for the 46% of non-ﬁxed reports, these fall into three
broad categories. First, true positives that were in fact ﬁxedby the developer, but not picked up by our ﬁx tracking (e.g.because the bug was ﬁxed in a new commit rather than a newversion of an existing commit). Second, true positives that thedeveloper decided not to address (e.g. because the bug wouldoccur only in very rare circumstances). Third, false positives(e.g. because the tool reports a deadlock between two methodsthat will never in fact be run concurrently). Unfortunately, wehave absolutely no way of knowing how many reports fall intoeach of these categories.
Analysis performance. The architecture of I
NFER means per-
analyser runtime is not recorded. For this reason, we report
only the total analysis time (including various other analysers),which provides an upper bound for our analysis. Runtime for
all analysers in the last 100 days to submission had a medianof 90 seconds and an average of 213 seconds per commit. Inthe same time period, I
NFER analysed a median of 2k methods
and on average 5k methods per commit.
VII. R ELA TED WORK
In this section we compare our contribution to related
work, ﬁrst, on theoretical deadlock detection results basedon automata, and second, on automated deadlock detectiontools. We note that such tools are naturally classiﬁed as eitherdynamic, static or hybrid, depending on whether they oper-ate primarily on program executions, program text, or both.Analysers that target Java programs typically rely on balancedlocking and must accurately model re-entrant locks, whereasanalysers for C code do not expect balanced locking andassume non-reentrant locks. In addition, deadlock analyserscan be categorised according to whether they detect deadlocksinvolving only two threads, or more, and whether they producefalse positives on guarded cycles.
963A. Automata-theoretical deadlock detection
There is a substantial body of work on the literature on
analysing general safety and liveness properties for commu-
nicating systems of pushdown automata, e.g. [34], [5], [20],[17], [14], [25], [26], [23], [24], [15]. Our abstract concurrentprograms fall under this general umbrella since, as we havealready observed (cf. Remark 3.17), they can be seen ascollections of ﬁnite automata that synchronise via their sharedlocks. Indeed, our model can be polynomially encoded as acommunicating pushdown system as considered e.g. in [5].However, while arbitrary dataﬂow properties of even two-threaded pushdown systems are undecidable in general [31],our deadlock problem is decidable and thus represents aspecial case, which relies crucially on the fact that lockingin our language is balanced.
The papers in this area most directly relevant to our own
work are probably [25] and [24], which both consider comuu-nicating pushdown systems in which locks are also balanced(there “nested”). In particular, [25] reports decidability of thedeadlocking problem for such systems, based on a cycle-checking condition in a graph obtained by augmenting theautomaton with lock acquisition histories. This condition issomewhat similar to (though arguably more complicated than)our condition based on critical pairs, and the central theoreticalresult on which it relies (Theorem 5) has the same essentialﬂavour as our similarly crucial Lemma 4.3, although thetechnical machinery is quite different. In [24] this result isstrengthened to the decidability of any LTL property of com-municating nested-lock pushdown systems, in exponential timein the number of locks. While these papers do not explicitlytreat reentrant locks, it is shown in [26] that reentrant locks canbe modelled in such systems using only non-reentrant locks,so this is not a serious point of difference.
Thus, although our deadlock characterisation result (Theo-
rem 4.4) is new in itself, it probably could have alternatively
been arrived at via a combination of the results in [25],[24] and [26], by encoding our language as a communicatingnested-lock pushdown system. However, such an approachwould almost certainly be messy, unsatisfying, and no lesswork than our own proof. Compared to these works, thenovelties of our approach are as follows: we characterisedeadlocks in a (simple) concurrent programming languagerather than a system of communicating automata; our deadlockcondition based on critical pairs is simpler than the automata-theoretic condition; and we give a proof for this setting that isentirely direct, self-contained and, we believe, quite elegant.
In a different direction, it is also worth mentioning [6]
and [16]. These both aim at deadlock avoidance (rather than
detection) in a concurrent functional language with re-entrantlocks, by developing a type system for the language such thattypable expressions are guaranteed not to deadlock. Whilethe earlier [6] requires locks to be balanced, [16] lifts thisrestriction, and provides a prototype implementation.B. Static analyses
Static deadlock detectors typically require a complete pro-
gram in order to run. Most are focused on soundness, wherethe absence of reports implies deadlock-freedom. All analysesdiscussed are interprocedural, top-down, context-sensitive andtypically non-compositional.
R
ACER X [12] is a path-insensitive analysis for C programs
which does not use a pointer analysis, instead using syntacticinformation and types about variables, ignoring locks in localvariables. Heavy use of caching transfer functions on state-ments is made, to improve runtimes due to context sensitivity.The search for cycles is up to a user speciﬁed number ofthreads. Many heuristics and techniques are employed toreduce false positive reports.
[32] reports on a Java analysis which targets libraries,
thus partly dealing with the problem of identifying programentrypoints. As such, the analysis cannot see global aliasinginformation and uses a coarse, type-based memory domain.It can detect cycles of more than two threads, up to a pre-speciﬁed bound. The pure analysis reports too many falsepositives, therefore several unsound heuristics are used.
J
ADE [29] is a path-insensitive Java analysis which breaks
down the problem into several sub-analyses, including reach-ability, aliasing/escaping, reentrancy and guarded-ness. It fo-cuses on two-thread deadlocks, and has explicit mechanismsfor rejecting guarded deadlock reports. It is expressed inDatalog and uses an iterative reﬁnement scheme to increaseprecision, where the degree of sensitivity is increased basedon the reports found in the last iteration.
[30] reports on an analysis for an abstract language, which
reduces detection of deadlocks into race detection. A typesystem captures lock dependencies, and the inferred types areused to detect program points where a nested lock acquisitionmay occur. These points are instrumented with code mutating"race" variables. A data race detector then ﬁnds possibledeadlocks. Too many false positives are reported for deadlocksamong more than two threads, and additional checks aremade to improve precision and to ﬁlter guarded cycles. Noimplementation is reported.
T
HREAD SAFE [3] is a commercial, ﬂow- and path-sensitive,
per-class analysis for Java. Little detail is reported on thefoundations of the analysis. It uses as entry points the publicmethods of each class, or modelled Android lifecycle methods.Only calls to private and protected methods are followed.
[27] reports on an analysis targeting C code with Posix
threads. It infers concurrency on spawn/join points throughthe program graph, and contexts represent call- and thread-creation- sites. A must-lock analysis is employed to deal withguarded locks. Function pointer calls are inlined into casedistinctions over the calls they might resolve to.
J
ADA [28] is a Java bytecode analysis that uses behavioural
type rules to compositionally extract an inﬁnite-state abstractmodel from bytecode. This model is then analysed using acontext-sensitive ﬁxpoint computation, generating reports ofcyclic dependencies. The main strength of the approach seems
964to be the ability to analyse recursive functions that spawn an
unbounded number of threads.
C. Dynamic and hybrid analyses
Analyses that work with program traces usually require the
whole program as well as appropriate test input, and tend to
be focused on completeness (most reports are true positives).
GOOD LOCK [18] is an analysis for Java programs imple-
mented in Java PathFinder (JPF) [19] which maintains a lock-tree for each execution thread, where each node representsthe lifetime of a lock acquisition and children nodes representacquisitions wholly contained within the parent. A warningis reported whenever two threads have lock-trees which mayrequest the same pair of locks in opposite orders. Since thewhole lock-tree is available, gate locks can be detected and thewarning suppressed. M
AGIC FUZZER [7], M AGIC LOCK [8],
UNDEAD [33] and A IRLOCK [9] all adopt and improve on
this basic approach by applying various optimisations to theextracted lock order graph, with U
NDEAD also attempting
to keep traces in memory rather than external storage as faras possible, and A
IRLOCK operating on-the-ﬂy, running a
polynomial-time algorithm on the lock graph to eliminate partswith no cycles before running the higher-cost algorithm todetect actual lock cycles.
[4] describes an analysis for Java programs, also imple-
mented in JPF, that constructs a lock-order graph from anexecution trace of an instrumented program. Although thegraph edges denote dependencies between only a pair of locks,they are also labelled by the complete lock-set and the threadacquiring the lock. These labels are used to detect deadlocksbetween more than two threads and to ﬁlter out gated cycles.
[2] presents a sound type inference mechanism for types
that ensure deadlock freedom for Java programs. Appropriateinstrumentation for the untyped parts of the program is thenused to feed an extension of the G
OOD LOCK algorithm to
the unbounded thread case, yielding a hybrid analysis. Furtherﬁltering is then used to exclude gated cycles.
S
HERLOCK [13] is an analysis for Java programs which
uses G OOD LOCK to get a set of deadlock candidates. The
program is run on given inputs, producing an initial schedulewhich is then concolically executed and permuted in repeatedsteps, in search of witnessing schedules. The G
OOD LOCK -
based algorithm can deal with more than two threads, and theoriginal version can deal with gated cycles.
VIII. C
ONCLUSIONS AND FUTURE WORK
In this paper we provide a highly scalable, open-source
deadlock analyser for Android Java, based on a sound andcomplete deadlock analysis (in NP) for an abstract concurrent
programming language. Our deadlock analyser has been de-ployed at Facebook as part of the I
NFER framework for the
last two years and has resulted in hundred of potential bugsbeing ﬂagged, with an actual developer ﬁx rate of over 50%
(and we note that this does not imply a false positive rate ofnearly50%). The abstract programming language on which the
analysis is based contains balanced (or nested) reentrant locks,nondeterministic control ﬂow commands and nonrecursiveprocedure calls, but with all other features — in particularvariable assignment — abstracted away. An abstraction ofthis sort is of course necessary to obtain decidability, forfundamental computability reasons. However, our overapprox-imation of real concurrent programs turns out to be sufﬁcientlyfaithful to detect deadlock bugs in practice, and sufﬁcientlyscalable to run on commercial Android applications.
It is natural to wonder whether and how our abstract
language might be extended while preserving the decidabilityof deadlock existence. Unfortunately, it seems to us thatalmost any nontrivial extension presents signiﬁcant obsta-cles. For example, allowing procedure calls to be recursivecauses problems for our approach since it is then possible tocreate statements with inﬁnite non-balanced traces (e.g. bythe procedure deﬁnition p:acq(/lscript);p();rel(/lscript)); a second
difﬁculty is that we also cannot straightforwardly reason byinduction over the structure of statements. Allowing controlﬂow to be deterministic, e.g. by allowing guards to query thelock state, is similarly problematic since the critical pairs ofa statement are then dependent on the lock state in whichit is executed, meaning that at the very least we wouldrequire a ﬁner abstraction in order to avoid false positives.Finally, modelling forking and joining by allowing parallelcompositions to appear nested within statements makes theproblem much more complicated since, conceptually, it wouldrequire that we construct abstractions of all subthreads as wellas determining which of them can run in parallel with eachother. We nevertheless consider these (and other) extensionsto be interesting potential directions for future work. It wouldalso be nice to establish a lower complexity bound on ourdeadlock problem; we speculate that the problem is likely NP-
complete, but unfortunately we have so far failed to ﬁnd asuitable reduction.
R
EFERENCES
[1] Facebook I NFER static analysis framework. https://fbinfer.com.
[2] R. Agarwal, L. Wang, and S. D. Stoller, “Detecting potential deadlocks
with static analysis and run-time monitoring,” in Hardware and Soft-
ware, V eriﬁcation and Testing. Springer, 2006, pp. 191–207.
[3] R. Atkey and D. Sannella, “ThreadSafe: Static analysis for java concur-
rency,” ECEASST, vol. 72, 2015.
[4] S. Bensalem and K. Havelund, “Dynamic deadlock analysis of multi-
threaded programs,” in Hardware and Software, V eriﬁcation and Testing.
Springer, 2006, pp. 208–223.
[5] A. Bouajjani, J. Esparza, and T. Touili, “A generic approach to the static
analysis of concurrent programs with procedures,” in Proceedings of
POPL-30. ACM, 2003, p. 62–73.
[6] G. Boudol, “A deadlock-free semantics for shared memory concurrency,”
inProceedings of ICTAC-6. Springer, 2009, pp. 140–154.
[7] Y . Cai and W. Chan, “MagicFuzzer: scalable deadlock detection for
large-scale applications,” in Proceedings of ICSE-34. ACM, 2012, pp.
606–616.
[8] ——, “MagicLock: Scalable detection of potential deadlocks in large-
scale multithreaded programs,” IEEE Transactions on Software Engi-
neering, vol. 40, no. 3, pp. 266–281, 2014.
[9] Y . Cai, R. Meng, and J. Palsberg, “Low-overhead deadlock prediction,”
inProceedings of ICSE-42. ACM, 2020, pp. 1298–1309.
[10] E. Dijkstra, “Hierarchical ordering of sequential processes,” Acta Infor-
matica, vol. 1, no. 2, pp. 115–138, 1971.
[11] D. Distefano, M. Fähndrich, F. Logozzo, and P . W. O’Hearn, “Scaling
static analyses at Facebook,” Comm. ACM, vol. 62, no. 8, p. 62–70, Jul.
2019.
965[12] D. Engler and K. Ashcraft, “Racerx: Effective, static detection of race
conditions and deadlocks,” in Proceedings of SOSP-19. ACM, 2003,
p. 237–252.
[13] M. Eslamimehr and J. Palsberg, “Sherlock: Scalable deadlock detection
for concurrent programs,” in Proceedings of FSE-22. ACM, 2014, p.
353–365.
[14] J. Esparza, P . Ganty, and R. Majumdar, “Parameterized veriﬁcation
of asynchronous shared-memory systems,” in Proceedings of CA V.
Springer, 2013, pp. 124–140.
[15] A. Farzan and Z. Kincaid, “Compositional bitvector analysis for concur-
rent programs with nested locks,” in Proceedings of SAS-17. Springer,
2010, pp. 253–270.
[16] P . Gerakios, N. Papaspyrou, and K. Sagonas, “A type and effect system
for deadlock avoidance in low-level languages,” in Proceedings of TLDI-
7. ACM, 2011, pp. 15–28.
[17] M. Hague, “Parameterised pushdown systems with non-atomic writes,”
LIPIcs, vol. 13, 09 2011.
[18] K. Havelund, “Using runtime analysis to guide model checking of
Java programs,” in SPIN Model Checking and Software V eriﬁcation.
Springer, 2000, pp. 245–264.
[19] K. Havelund and T. Pressburger, “Model checking Java programs
using Java PathFinder,” International Journal on Software Tools for
Technology Transfer, vol. 2, no. 4, pp. 366–381, 2000.
[20] A. Heußner, J. Leroux, A. Muscholl, and G. Sutre, “Reachability analysis
of communicating pushdown systems,” in Proceedings of F oSSaCS.
Springer, 2010, pp. 267–281.
[21] J. E. Hopcroft and J. D. Ullman, F ormal Languages and Their Relation
to Automata. Addison-Wesley, Jan. 1969.
[22] N. D. Jones and S. S. Muchnick, “Flow analysis and optimization of lisp-
like structures,” in Proceedings of POPL-6. ACM, 1979, p. 244–256.
[23] V . Kahlon, “Boundedness vs. unboundedness of lock chains: Character-
izing decidability of pairwise CFL-reachability for threads communicat-
ing via locks,” in Proceedings of LICS-24. IEEE, 2009, pp. 27–36.[24] V . Kahlon and A. Gupta, “An automata-theoretic approach for model
checking threads for LTL properties,” in Proceedings of LICS-21. IEEE,
2006, pp. 101–110.
[25] V . Kahlon, F. Ivancic, and A. Gupta, “Reasoning about threads com-
municating via locks,” in Proceedings of CA V-17. Springer, 2005, pp.
505–518.
[26] N. Kidd, A. Lal, and T. Reps, “Language strength reduction,” in
Proceedings of SAS-15. Springer, 2008, pp. 283–298.
[27] D. Kroening, D. Poetzl, P . Schrammel, and B. Wachter, “Sound static
deadlock analysis for C/Pthreads,” in Proceedings of ASE-31, 2016, pp.
379–390.
[28] C. Laneve and A. Garcia, “Deadlock detection of Java bytecode,” in
Logic-Based Program Synthesis and Transformation. Springer, 2018,pp. 37–53.
[29] M. Naik, C.-S. Park, K. Sen, and D. Gay, “Effective static deadlock
detection,” in Proceedings of ICSE-31. IEEE Computer Society, 2009,
p. 386–396.
[30] K. I. Pun, M. Steffen, and V . Stolz, “Deadlock checking by data race
detection,” Journal of Logical and Algebraic Methods in Programming,
vol. 83, no. 5, pp. 400 – 426, 2014, the 24th Nordic Workshop onProgramming Theory (NWPT 2012).
[31] G. Ramalingam, “Context-sensitive synchronization-sensitive analysis
is undecidable,” ACM Trans. Program. Lang. Syst., vol. 22, no. 2, p.
416–430, 2000.
[32] A. Williams, W. Thies, and M. D. Ernst, “Static deadlock detection for
Java libraries,” in ECOOP 2005 - Object-Oriented Programming,A .P .
Black, Ed. Springer, 2005, pp. 602–629.
[33] J. Zhou, S. Silvestro, H. Liu, Y . Cai, and T. Liu, “UnDead: detecting
and preventing deadlocks in production software,” in Proceedings of
ASE-32. ACM, 2017, pp. 729–740.
[34] W. Zielonka, “Notes on ﬁnite asynchronous automata,” RAIRO - Theo-
retical Informatics and Applications, vol. 21, no. 2, pp. 99–135, 1987.
966