RAICC: Revealing Atypical Inter-Component
Communication in Android Apps
Jordan Samhi, Alexandre Bartely, Tegawend ¬¥e F. Bissyand ¬¥eand Jacques Klein
SnT, University of Luxembourg, Ô¨Årstname.lastname@uni.lu
yDIKU, University of Copenhagen, ab@di.ku.dk
Abstract ‚ÄîInter-Component Communication (ICC) is a key
mechanism in Android. It enables developers to compose rich
functionalities and explore reuse within and across apps. Un-
fortunately, as reported by a large body of literature, ICC is
rather ‚Äúcomplex and largely unconstrained‚Äù, leaving room to a
lack of precision in apps modeling. To address the challenge of
tracking ICCs within apps, state of the art static approaches
such as E PICC , ICCTA and A MANDROID have focused on the
documented framework ICC methods (e.g., startActivity) to build
their approaches. In this work we show that ICC models inferred
in these state of the art tools may actually be incomplete: the
framework provides other atypical ways of performing ICCs.
To address this limitation in the state of the art, we propose
RAICC a static approach for modeling new ICC links and
thus boosting previous analysis tasks such as ICC vulnerability
detection, privacy leaks detection, malware detection, etc. We
have evaluated RAICC on 20 benchmark apps, demonstrating
that it improves the precision and recall of uncovered leaks in
state of the art tools. We have also performed a large empirical
investigation showing that Atypical ICC methods are largely used
in Android apps, although not necessarily for data transfer. We
also show that RAICC increases the number of ICC links found
by 61.6% on a dataset of real-world malicious apps, and that
RAICC enables the detection of new ICC vulnerabilities.
Index Terms‚ÄîStatic Analysis, Android Security
I. I NTRODUCTION
Android apps heavily rely on the Inter-component com-
munication (ICC) mechanism to implement a variety of in-
teractions such as sharing data [1], triggering the switch
between UI components or asynchronously controlling the
execution of background tasks. Given its importance, the
research community has taken a particular interest in ICC,
reporting on various studies that show how ICC can be ex-
ploited in malicious scenarios: ICC can be leveraged to easily
connect malicious payload to a benign app [2], leak private
data [3]‚Äì[5], or perform app collusion [6]. These scenarios are
generally executed by passing Intent objects, which carry
the data and information about explicitly/implicitly targeted
components [7]. Tracking information across Intents to link
components that may be connected via ICC thus becomes an
important challenge for the analysis of Android apps.
The resolution of ICC links (identiÔ¨Åcation of the source
and target components, type of the components, etc.) is a well-
studied topic in the literature. Approaches such as EPICC [8],
COAL/IC3 [9], SPARTA [10] or DroidRa [11] have con-
tributed with analysis building blocks in this respect. The ICC
links (also called ICC models) generated by these tools are
key and even mandatory for several Android app analysistasks. (1) In the case of data Ô¨Çow analysis, ICC poses an
important challenge in the community: ICC indeed introduces
a discontinuity in the Ô¨Çow of the analysis, since there is no
direct call to the target component life-cycle methods in the
super-graph (aggregation of control Ô¨Çow graphs [12] of caller
and callee methods in the absence of a single Main method).
Several tool-supported approaches such as A MANDROID [4],
ICCTA [5] and D ROID SAFE [3] have been proposed in the
literature to cope with this issue. To overcome the disconti-
nuity in the Ô¨Çow of the analysis, all these three tools rely on
an inferred ICC model to identify the target component and
the ICC methods in order to artiÔ¨Åcially connect components.
(2) In the case of Android malware detection, a tool such
as ICCD ETECTOR [7] leverages the ICC model generated
by EPICC to derive ICC speciÔ¨Åc features that are used to
produce a Machine-Learning model in order to detect new
type of Android malware. (3) In the case of vulnerability
detection, EPICC leverages its own ICC model to detect ICC
vulnerabilities, deÔ¨Åned in [8] as the sending an Intent that may
be intercepted by a malicious component, or when legitimate
app components, ‚Äìe.g., a component sending sms messages‚Äì
are activated via malicious Intent.
In all these cases, the proposed tools rely on a comprehen-
sive modeling of the ICC links. However, a major limitation
in ICC resolution relates to the fact that state of the art
approaches consider only well-documented ICC methods such
asstartActivity(). Indeed, we have discovered that
several methods from the Android framework can also be used
to implement ICC although the ofÔ¨Åcial Android documenta-
tion does not speciÔ¨Åcally discuss it [13]‚Äì[15]. Actually, ICC
can also be performed by leveraging Android objects (e.g.,
PendingIntent orIntentSender) that have been little
studied in the literature, and through framework methods that
can atypically be used to launch other components.
We have initially observed an atypical ICC implementation
during the manual reverse engineering of an Android app that
we identiÔ¨Åed as part of research on logic bomb detection.
This app uses the method set(int, long, Pending-
Intent) of the AlarmManager class for triggering a
BroadcastReceiver which in turn is used to launch
aService component. Such an implementation appeared
suspicious since it seems artiÔ¨Åcially complex: it is possible to
directly call the sendBroadcast method instead of lever-
aging an AlarmManager. We further performed extensive
investigations and found that several dozens of methods of
13982021 IEEE/ACM 43rd International Conference on Software Engineering (ICSE)
1558-1225/21/$31.00 ¬©2021 IEEE
DOI 10.1109/ICSE43902.2021.00126
the Android framework can atypically start a component with
objects of type PendingIntent and/or IntentSender .
We use the term ‚Äùatypical‚Äù to reÔ¨Çect the fact that, according
to the method deÔ¨Ånitions, their role is not primarily to start a
component (as ICC methods typically do) but to perform some
action (e.g., set an alarm or send an SMS). Unfortunately,
with such possibilities, an attacker could rely on such methods
to perform ICC-related malicious actions. Existing state-of-
the-art approaches, because they do not account for atypical
methods in their models, would miss detecting such ICC links.
Our work explores the prevalence of Atypical ICC (AICC)
methods in the Android framework as well as their usages
in Android apps. We then propose an approach for resolving
those AICC methods and an instrumentation-based framework
to support state-of-the-art tools in their analysis of ICC.
In summary, we present the following contributions:
We present Ô¨Åndings of a large empirical study on the use
of AICC methods in malicious and benign apps.
We propose a tool-supported approach named RAICC for
resolving AICC methods using code instrumentations in
order to generate a new APK with standard ICC methods.
We demonstrate that this instrumentation boosts state of
the art tools in various Android analysis tasks.
We improve D ROID BENCH [16] with 20 new apps using
AICC methods for assessing data leak detection tools.
The rest of the paper is organized as follows. First, we
present how state-of-the-art performs with ICC in Section II.
Then, in Section III, we give an example and explain why
we are studying atypical inter-component communication. In
Section IV, we detail RAICC, our tool-supported approach.
We evaluate RAICC and present our results in Section V. In
section VI, we present the limitations of the approach. Finally,
we discuss the related-work in Section VII and conclude in
Section VIII.
II. H OW DO STATE OF THE ART ANALYZERS HANDLE ICC?
Android apps are composed of components that are bridged
together through the ICC mechanism. The Activity compo-
nent implements the UI visible to users while Service compo-
nents run background tasks and Content Provider components
expose shared databases. An app may also include a Broadcast
Receiver component to be notiÔ¨Åed of system events. The
Manifest Ô¨Åle generally enumerates these components with the
relevant permission requests.
Components are activated by calling relevant ICC methods
provided in the Android framework. These ICC methods are
also used to pass data through an Intent object, which may
explicitly target a speciÔ¨Åc component or may implicitly refer to
all components that have been declared (through Intent Filters )
capable of performing the Intent actions.
The ICC mechanism challenges static analysis of apps.
Indeed, consider Listing 1 in which the MainActivity
component launches the TargetActivity component. The
discontinuity in the control-Ô¨Çow is clear since there is no direct
method call between MainActivity andTargetActi-
vity . Off-the-shelf Java static analyzers that analyze normal1public class MainActivity extends Activity {
2 protected void onCreate (Bundle b ) { ...
3 Intent i =new Intent (this ,TargetActivity .class );
4 this .startActivity (i);
5 }
6}
7public class TargetActivity extends Activity
8 {protected void onCreate (Bundle b ) {} }
Listing 1: An example of how ICC is performed between two
components.
method calls would not be able to detect the link between the
ICC method startActivity and the TargetActivity
component. Hence, if a data Ô¨Çow analysis is performed,
none of the data-Ô¨Çow values can be propagated correctly.
This is since ICC methods trigger internal Android system
mechanisms which redirect the call to the speciÔ¨Åed component.
Therefore, Android static analyzers have to preprocess the
application in order to add explicit method calls. That is
what state-of-the-art tools like I CCTA [5], D ROID SAFE [3]
and A MAN DROID [4] do with different techniques. If we
take the example of I CCTA, it Ô¨Årst relies on IC3 [9] to
infer the ICC links. Among other information, IC3 identiÔ¨Åes
the ICC methods (e.g., startActivity in Listing 1) and
resolves the target components (e.g., TargetActivity in
Listing 1). Then, I CCTA replaces any ICC method call with a
direct method call that passes the correct Intent . Thus, the
discontinuity disappears and the link to the target component
is directly available in the super-graph (see Figure 3 of
ICCTA paper [5]). The idea that we reuse in this paper is
the code instrumentation that allows preprocessing an app for
constructing the missing links to be processed by any analysis.
Nevertheless, in this paper, we will see that state-of-the-
art approaches only rely on well-documented methods for
performing inter-component communication. We aim at im-
proving their precision by revealing previously un-modeled
ICC links.
III. A TYPICAL ICC M ETHODS
Static analysis of Android applications is challenging due
to the speciÔ¨Åcity of the Android system‚Äôs inter-component
communication (ICC) mechanism. Therefore, as we have
overviewed in Section II, researchers have to come up with
approaches for considering and resolving ICC. In this section,
we show that one developer can perform atypical ICC by tak-
ing advantage of speciÔ¨Åc methods of the Android framework.
We deÔ¨Åne an atypical ICC method (AICC method) as
a method allowing to perform an inter-component commu-
nication while it is not its primary purpose. These AICC
methods rely on PendingIntents andIntentSenders .
PendingIntents objects are wrappers for Intents . They
can only be generated from existing Intents and describe
those latter. They can be passed to different components and
especially to different applications. When doing so, the receiv-
ing app is granted the right to perform the action described in
thePendingIntent with the same permissions and identity
of the source app. This introduces a security threat in which
a component could perform an action for which it does not
have the permission but it is granted this latter through the
1399PendingIntent . This security threat has been studied by
Gro√ü et al. [17]. An important fact is that PendingIntents
are maintained by the system and represent a copy of the
original data used to create it. The PendingIntents can
thus still be used if the original app is killed. IntentSenders
objects are encapsulated into PendingIntents . They can
be retrieved from a PendingIntent object via the method
getIntentSender() . Basically, they can be used the same
way than PendingIntents and represent the same artifact.
The abstract representation of AICC methods is shown in
Figure 1. The upper part of the Ô¨Ågure shows how standard ICC
methods behave. They communicate with the Android system
viaIntents to execute another component. The lower part
represents how AICC methods behave. They perform the
action they are meant to do through the Android system and at
the same time the PendingIntent or the IntentSender
is registered in a token list in the Android system [18], [19].
The action may or may not inÔ¨Çuence the decision for the
system to launch the component, depending on the AICC
method. For example, a PendingIntent could only be
launched in case of the success of the action. Also, the Android
system can receive a cancellation of a token from the app. (e.g.,
cancel an alarm). In that case, the target component would not
be launched.
The tokens represent the original data used for generating
aPendingIntent or an IntentSender . It means that
if the application modiÔ¨Åes the Intent used to construct the
PendingIntent , it does not affect the token as it is a copy
of the original data. More importantly, if the application is
killed, the list is maintained in the Android Framework and
the components can still be executed.
iccm() Android System Target Component
aiccm() action
Android SystemTarget Component
List of tokensIntent Intent
PendingIntent/
IntentSenderIntent
Fig. 1: Difference between normal ICC method and AICC
method. Tokens represent PendingIntents andIntentSenders .
Action represents the primary purpose of the AICC method (e.g. send an
SMS). An action might inÔ¨Çuence the list of tokens in the Android system,
which will later process the list and send Intents . The dotted line indicates
that the triggering of the target component may depend on the result of an
action.
A concrete Example: As described in Section I, while
manually analyzing a malicious application, we noticed that
it used the AlarmManager for performing ICC. The in-
teresting piece of code of this malicious app is presented
in Listing 2. We can see a PendingIntent created from
anIntent targeting the component AlarmListener . The
latter simply launches the Service component responsible
for retrieving external commands via HTTP. For launch-
ing the class AlarmListener , the developer could haveused the method sendBroadcast (AlarmListener ex-
tends BroadcastReceiver ), but instead it used the AICC
method set(int, long, PendingIntent) .
1public void reconnectionAttempts () {
2 Calendar cal =Calendar .getInstance ();
3 cal.add(12, this .elapsedTime );
4 Intent i =new Intent (this ,AlarmListener .class );
5 intent .putExtra ("alarm_message" ,"Wake up Dude !" );
6 PendingIntent pi =PendingIntent .getBroadcast (this ,
0,i, 134217728); ,!
7 AlarmManager am = (AlarmManager )
getSystemService ("alarm" ); ,!
8 am.set(0, cal.getTimeInMillis (), pi);
9}
Listing 2: A simpliÔ¨Åed example of how the method set of
theAlarmManager class is used in a malware.
When we focus more on the way PendingIntent works,
we understand why the developer used this technique. Indeed,
in this example, the alarm is set up to go off after 5, 10, or 30
minutes. But what happens if the user closes the app before
it goes off? In fact, the alarm will go off anyway and execute
the target component. This is due to the fact that when setting
an alarm, the PendingIntent is maintained by the Android
system until it goes off or gets canceled. We can see the power
of such a method to perform ICC. It could be used in different
scenarios by an attacker to perform its malicious activities.
Furthermore, AICC methods carry information in Intent
objects that are also embedded in PendingIntent or
IntentSender objects. Therefore, they can carry different
types of information, leading to potential sensitive data leaks.
Our benchmark includes examples scenarios for such leaks.
IV. A PPROACH
In this paper, we aim at resolving those AICC methods
through app instrumentation [20]. The goal for the new app is
to be analyzable by state-of-the-art Android static analyzers.
We Ô¨Årst introduce in section IV-A how we gather a comprehen-
sive list of AICC methods. Then, in section IV-B we describe
how we leveraged this list of methods to improve the detection
of inter-component communications leading to the increase of
precision metrics of existing Android-speciÔ¨Åc static analyzers.
A. List of Atypical ICC Methods
As explained in previous sections, during the reverse-
engineering of Android applications, we stumbled upon a
malicious app making the use of the set() method of the
AlarmManager class with a PendingIntent as param-
eter to stealthy perform an ICC (in this case, to start a
BroadcastReceiver ). Thanks to this example, we real-
ized that (1) Intent and method such as startActivity
are not the only main starting points of ICC, (2) other
objects (e.g. PendingIntent ) and other methods (e.g.
AlarmManager.set() ) can play a similar role.
Motivated by this discovery, we were eager to check if
this atypical mechanism is restricted to this set() method
and this PendingIntent object. In other words, are there
other atypical methods in the Android framework? Are there
other classes such as PendingIntent ? To answer these
1400questions, we performed a comprehensive analysis of the
Android framework.
We retrieved from the Android framework, from SDK
version 3 to 29 (versions 1 and 2 being unavailable), all
the methods that take as a parameter an object of type
PendingIntent . We obtained a list of 163 unique meth-
ods. The next step was to manually analyze all of them
in order to only keep those allowing to perform ICC.
The list reduced to 85 methods, indeed some methods
have a PendingIntent as a parameter but cannot per-
form ICC (e.g., android.bluetooth.le.Bluetooth-
LeScanner.stopScan(PendingIntent) ).
To identify classes similar to PendingIntent , we fol-
lowed a simple heuristic. We search for all class names
containing the string Intent . This search yielded 19 classes
that we manually checked. Finally, we identiÔ¨Åed one new
class, IntentSender , which, according to the Android
documentation, has the same purpose as PendingIntent .
We scanned again the Android framework to retrieve all
the methods that take as a parameter an object of type
IntentSender , and we discovered 17 new methods for
performing atypical inter-component communication.
To improve the conÔ¨Ådence in our list of AICC methods,
we performed further analyses. In particular, we downloaded
the source code of Android and studied the implementation
of some of the AICC methods we gathered. This approach
aimed at Ô¨Ånding patterns that we used to Ô¨Ånd similar usage in
the Android framework, we assumed that other AICC methods
use the same patterns. We also made some assumptions, e.g.,
considering the subclasses of those studied. Unfortunately, we
were not able to uncover additional AICC methods.
At this stage, our list reached a length of 102 (85 + 17 )
methods. It was all without counting the 9 methods of
PendingIntent andIntentSender classes that directly
allow launching a component. For example, the send()
method of the PendingIntent class allows to directly
communicate with a targeted component, likewise for method
sendIntent() of class IntentSender . Finally, our list
reached 111 methods.
In Listing 3 we illustrate the usage of four AICC methods
(chosen for their brevity). On the Ô¨Årst lines (4-8) objects
necessary to the AICC methods are instantiated. An Intent
is instantiated at line 4. At lines 5-6, a sensitive information,
the device unique identiÔ¨Åer, is retrieved and stored in the imei
variable. At line 7, the IMEI is added as an extra information in
the intent. At line 8, the PendingIntent is instantiated with
the intent containing the IMEI. Then, from line 10, we present
four ways of launching the TargetActivity component
through AICC methods.
We gathered a comprehensive list of 111 methods,
called AICC methods, allowing to perform atypical inter-
component communication.1public class MainActivity extends Activity {
2 @Override
3 protected void onCreate (Bundle b ) {...
4 Intent i =new Intent (this ,TargetActivity .class );
5 TelephonyManager tm = (TelephonyManager )
getSystemService (Context .TELEPHONY_SERVICE ); ,!
6 String imei =tm.getDeviceId ();
7 i.putExtra ("SensitiveData" ,imei );
8 PendingIntent pi =PendingIntent .getActivity (this ,
0,i, 0); ,!
9
10 (1.a)pi.send ();
11
12 (2.a)IntentSender s=pi.getIntentSender ();}
13 (2.b)s.sendIntent (this , 0,null ,null ,null );
14
15 (3.a)AlarmManager am = (AlarmManager )
getSystemService ("alarm" ); ,!
16 (3.b)am.setExact (0,System .currentTimeMillis () -
100, pi); ,!
17
18 (4.a)LocationManager l=(LocationManager )
getSystemService ("location" ); ,!
19 (4.b)l.requestLocationUpdates (0, 0 ,new
Criteria (), pi); ,!
20 }
21 }
Listing 3: Examples of how AICC methods (inyellow ) can
be used to perform inter-component communication.
B. Tool Design
General Idea: The o vervie w of our open-source tool called
RAICC is depicted in Figure 2. The general idea is to
instrument a given Android app to boost it by making it
aware of ICC links. For instance, if aPendingIntent
is used with an AICC method to start an acti vity, RAICC
will instrument the app‚Äô s source code by adding a method
startActivity() with the right intent as parameter . This
method is added at a point of interest in the app, i.e., just
after the AICC method call. Toperform this instrumentation,
RAICC needs (1) to infer the possible v alues/targets of ICC
objects (e.g., Intent ); (2) resolve the type of the target
component in order to instrument with the right standard ICC
methods (e.g., startActivity() if the target component
is an Activity ,startService() if the target component is
a Service, etc.).
1)Transform
into Jimple2)Infer tar get
component types
3)Collect
Intents5)New APK
generated4)Code
instrumentation
Fig. 2: Overvie w of our open-source tool R AICC.
Concrete Example: Weillustrate the result of our ap-
proach with Listing 4. It sho ws the transformation that the
JIMPLEcode under goes (sho wn as Java code for readability).
The AICC method (program point of interest) appears at
line 6. After inferring the tar get component type wi th the
help of COAL /IC3, RAICCgenerates a new standard ICC
method call right after the AICC method (i.e., at line 7)
corresponding to this type, i.e.,startActivity() . Indeed,
thePendingIntent has been generated with the method
getActivity , thus the tar get component type in the inferred
values is deÔ¨Åned as ‚Äùa‚Äù inCOAL /IC3, i.e., Activity . Also,
1401RAICC is able to recover the Intent used to create the
PendingIntent for using it as a parameter for the new
standard ICC method call.
1 Intent i =new Intent (this ,TargetActivity .class );
2 PendingIntent p =PendingIntent .getActivity (this , 0,
i, 0); ,!
3 LocationManager l =
(LocationManager )getSystemService ("location" ); ,!
4 Criteria c =new Criteria ();
5 // program point of interest
6 l.requestSingleUpdate (l.getBestProvider (c,false ),p);
7+startActivity (i);
Listing 4: How RAICC would instrument an app. (Lines with
‚Äù+‚Äù represent added lines)
Details of each step involved in RAICC:
Step 1: The app is transformed into Jimple [21], the internal
representation of the Soot framework [22] using Dexpler [23].
Step 2: RAICC leverages IC3 [9] which is able to infer
all possible values of ICC objects using composite constant
propagation at speciÔ¨Åc program points. To this end, we created
model Ô¨Åles using the COAL [9] declarative language to
query each of the AICC methods during program analysis
and retrieve the values of the parameters we need (i.e.,
PendingIntent andIntentSender ).
Given that they are built from Intent objects, IC3 is able
to identify all subparts which compose the objects (e.g., action,
category, extras, URI, etc.). The most important artifact for our
instrumentation is the types of potential target components.
It is inferred by COAL given its speciÔ¨Åcation, i.e., it is able
to get the target component type by recognizing methods for
creating PendingIntents (e.g., getActivity ). Indeed,
one can easily see the difference between a conventional ICC
method and an AICC method: standard ICC methods explicitly
describe the type of component that will be launched (e.g.,
startActivity() for an activity, startService() for
a service, sendBroadcast() for BroadcastReceiver, etc.),
whereas with AICC method we cannot statically directly
know the type of those components (e.g., the signature of
theset() method gives no information about the type of
the target component, and it is the same for most of the
AICC methods such as sendTextMessage() ,request-
LocationUpdates() , etc.).
Depending on the control-Ô¨Çow of the program during exe-
cution, the target component can change, hence its type too.
Consequently, we have to take into account all possible types
for different components. The main idea of our instrumentation
approach is to add as many new standard ICC method calls
as there are target components types and Intent objects for
creating PendingIntent andIntentSender right after
the program points of interest. The type is represented by a
single character in the COAL speciÔ¨Åcation for a given class.
For example, the target type of a PendingIntent can take
the following values: 1) ‚Äùa‚Äù for an Activity , 2) ‚Äùr‚Äù for a
BroadcastReceiver and 3) ‚Äùs‚Äù for a Service .
Step 3: After retrieving the possible target component types of
the AICC methods, RAICC has to recover the right Intent
that has been used for creating the PendingIntent or the
IntentSender which will be the parameter of the generatedstandard ICC method(s). To tackle this issue, RAICC Ô¨Årst
recovers the PendingIntent orIntentSender refer-
ence used in the AICC method. Note that it can be used
as a parameter in the AICC method (e.g., sendText-
Message() ) or as the caller object (e.g., send() ), we
annotated each AICC method for having this information
and, in the case it is a parameter, the index in the list of
parameters. Afterwards, RAICC interprocedurally searches
for the Intent used for creating the PendingIntent .
In the case of IntentSender , RAICC interprocedurally
searches for the PendingIntent , then recursively apply
the previous process for retrieving the Intent . Of course,
different Intent objects could be used in the code (not
shown in Listing 4). Therefore for correctly propagating the
‚Äùcontext information‚Äù among components for further analysis,
they should all be taken into account, as RAICC does.
Step 4: At this point, for each point of interest (AICC method),
RAICC leverages the list of potential target component type
and the list of potential Intents . The source code modiÔ¨Åca-
tion of the app to explicitly set the ICC methods is straightfor-
ward. After each AICC method, RAICC generates as many
invoke statements as there are combinations of potential target
types and potential Intents recovered. The new generated
invoke statements will depend on the type(s) inferred at step
2, i.e., startActivity for ‚Äùa‚Äù, startService for ‚Äùs‚Äù
andsendBroadcast for ‚Äùr‚Äù. Intent objects are used as
parameters of the new method calls.
Note that some of the AICC methods, likewise
startActivityForResult() , expect a result returned
if the target component type is an Activity . We have
carefully annotated the corresponding AICC methods,
therefore RAICC generates the right method call in this case,
i.e.,startActivityForResult() .
Step 5: Finally, RAICC packages the newly generated applica-
tion, and any existing tool dealing with standard ICC methods
can be used to perform further static analysis.
Note that although instrumentation can lead to non-runnable
apps, in this study, apps are not meant to be executed after
being processed by RAICC. Indeed, RAICC acts as a pre-
processor for other static analyses.
V. E VALUATION
We address the following research questions:
RQ1: Do AICC methods deserve attention? In other words,
are AICC methods often used in Android apps?
RQ2: Are AICC methods new in the Android Ecosystem?
RQ3: Can RAICC boost the precision of ICC-based data leak
detectors on benchmark apps?
RQ4: Does RAICC reveal previously undetected ICC links
in real-world apps? If so, are these newly detected ICC
links security-sensitive?
RQ5: What are the runtime performance and the overhead
introduced by RAICC?
1402A. Atypical ICC Methods Deserve Attention
In section IV-A, we described how we build a list of atypical
ICC methods . We used this list to conduct empirical analyses
assessing the use of AICC methods in the wild.
In a Ô¨Årst study, we randomly selected 50 000 malicious
apps and 50 000 benign apps from the Androzoo dataset [24].
For qualifying the maliciousness of the apps, we used the
VirusTotal [25] score (number of antivirus products that Ô¨Çag
an app as malicious) available in the metadata of the app in
Androzoo. Every app of our malicious set has a VirusTotal
score strictly greater than 20, those from the benign have a
score equal to 0.
Library code vs. developer code: It has been shown [26]
than libraries present in Android apps can seriously impact
empirical investigation performed on Android apps. Indeed,
code related to libraries is often larger than the code written
by the developers of the apps. For this reason, in this study, we
perform two experiments: (1) we count the number of AICC
methods present in each collected app by considering the entire
code (i.e., including library code); (2) we count the number of
AICC methods only present in the developer code. In practice,
to exclude library code, we rely on Soot which can discard
third party libraries from a given list (in our experiments,
we use the list from [26]) and system classes with simple
heuristics (e.g., discard if the signature starts with ‚Äùandroidx.*‚Äù
or ‚Äùorg.w3c.dom.*‚Äù, etc.)
Table I shows our Ô¨Åndings. We can see that among the
benign apps, considering only the developer code, 24 884
apps (50%) use at least one AICC method, and overall,
124 226 AICC methods are used. If we take into account
the libraries, it is no less than 43 754 apps ( 87:5%) using in
total 1 154 425 AICC methods. Clearly, in benign apps, the
large majority of AICC methods are leveraged by libraries. In
the malicious set, we face a different situation. The reported
Ô¨Ågures considering libraries or not are much closer. Finally, if
we compare both datasets, we note that overall, benign apps
tend to use much more AICC methods than malicious apps,
but when considering only the code written by the developers
of the apps, the situation is reversed, i.e., developers use much
more AICC methods in malicious apps than in benign apps.
Without libs With libs
Dataset #AICCM #apps ratioy#AICCM #apps ratioy
50k
benign12422624884
(49:8%)5/app 1154 42543 754
(87:5%)26:4/app
50k
malicious40246834710
(69:4%)11:6/app 52212639 845
(79:7%)13:1/app
yThe ratio is computed by considering apps with at least one AICC method.
TABLE I: Number of apps using at least one AICC method
in different datasets (AICCM: AICC method).
Table II presents for both datasets the top 5 used AICC
methods in developer code (excluding libraries). We no-
tice 3 common AICC methods in this table (i.e., set,
setRepeating andsetLatestEventInfo ). Regarding
the malicious apps, we can see that the methods from the
class SmsManager are present twice. It could be explained
by the fact that malicious apps tend to activate components via
SMS. We also note that method setLatestEventInfo isused an order of magnitude more than all other methods. This
method is actually related to the notiÔ¨Åcation mechanism of
Android. We postulate that malicious apps tend to be much
more aggressive in terms of notiÔ¨Åcations and advertisements
resulting in a high number of usages of this method.
Methods Counts %
Benigns (50000)
android.app.AlarmManager .set 27 214 21 :9%
android.widget.RemoteV iews.setOnClickPendingIntent 19 217 15 :5%
android.app.NotiÔ¨Åcation.setLatestEv entInfo 18 024 14 :5%
android.app.AlarmManager .setRepeating 9184 7 :4%
android.app.Acti vity.startIntentSenderForResult 6876 5 :5%
Malicious (50000)
android.app.NotiÔ¨Åcation.setLatestEv entInfo 238 462 59 :2%
android.app.AlarmManager .set 53 533 13 :3%
android.telephon y.SmsManager.sendTextMessage 39 011 9 :7%
android.app.AlarmManager .setRepeating 22 813 5 :7%
android.telephon y.SmsManager.sendDataMessage 13 075 3 :2%
TABLE II: Most used atypical ICC methods in be-
nign/malicious Android apps, without considering libraries.
 0 5000 10000 15000 20000 25000 30000 35000
1   3  Number of occurences
AICC Methods (names omitted)# of  occurence  of  each AICC  method  in benign  set 
# of  occurence  of  each AICC  method  in malicious  set
5   7   9   11   13    15    17     19     21    23    25    27    29    31
Fig. 3: Occurence of AICC methods in benign and malicious
applications (excluding libraries)
Finally, Figure 3 presents the number of usages of each
of the 111 AICC methods in the developer code in both
benign and malicious datasets. For each dataset, the methods
are ranked by their number of occurrences. For the sake
of readability, we have truncated the Ô¨Årst two bars of the
malicious datasets. Indeed, as shown in Table II, the number of
occurrence of the top 3 methods are 238k,53k and 39k
respectively. Thanks to Figure 3, we note that: (1) only a frac-
tion of the AICC methods is largely used by developers, (2)
21 methods are even not used at all, (3) malicious developers
tend to use a less diverse set of AICC methods but the AICC
methods that are used, are more frequently used.
RQ1 Answer: AICC methods are prevalent in Android
apps, and thus deÔ¨Ånitely deserve attention. They are used
in both malicious and benign apps, but signiÔ¨Åcantly more
by malicious developers. Only a fraction of the AICC
methods are regularly used.
B.Atypical ICC Methods e xist since the be ginning
Tothe best of our knowledge, state of the art approaches do
not consider AICC methods. One of the reasons could be the
fact that AICC methods ha veonly been introduced recently
in the Android Frame work. Tovalidate this h ypothesis, we
further check the use of AICC methods o vertime. F or this
purpose, we considered 5 sets of 5000 benign apps from
Androzoo (ordered by the creation date of the dex Ô¨Åle),
and 4 sets of malicious apps. Androzoo only contains a few
1403malicious apps from 2019 and no malicious app from 2020.
Thus, the 2019 malicious set is reduced compared to the
benign one and there is no 2020 malicious set. The sets, their
content and the results of the analyses are provided in Table III.
First, overall these results conÔ¨Årm the results of Table I. For
instance, in benign apps, AICC methods are mostly used in
libraries. Malicious developers still use more AICC methods
in their code, even if the difference between with or without
libraries is less pronounced. Regarding temporal evolution, we
note that in both datasets, the metrics are pretty stable, except
maybe in 2019 -malicious set- which seems to be an outlier
(weak ratio and high % of number of apps). This could be
explained by the low number of apps (548) collected for 2019.
Withtout libs With libs
Dataset #AICCM #apps ratioy#AICCM #apps ratioy
Benign Sets
2016 (5000) 14 130 2620 (52:40%) 5:4/app 129089 4584 (91:68%) 28:2/app
2017 (5000) 11 540 2486 (49:72%) 4:6/app 133803 4601 (92:02%) 29:1/app
2018 (5000) 15 167 2487 (49:74%) 6:1/app 143009 4708 (94:16%) 30:4/app
2019 (5000) 15 923 2629 (52:58%) 6:0/app 144467 4528 (90:56%) 31:9/app
2020 (5000) 15 300 2403 (48:06%) 6:4/app 106019 3488 (69:76%) 30:4/app
Malicious Sets
2016 (5000) 20 156 2371 (47:42%) 8:5/app 58967 2997 (59:94%) 19:7/app
2017 (2825) 16 316 1222 (43:26%) 13:3/app 45832 1583 (56:03%) 28:9/app
2018 (3067) 28 083 1676 (54:65%) 16:8/app 56623 1823 (59:44%) 31:1/app
2019 (548) 1494 378 (68:98%) 3:9/app 7268 429 (78:28%) 16:9/app
yThe ratio is computed by considering apps with at least one AICC method.
TABLE III: Temporal evolution of the usage of AICC methods
in benign and malicious apps.
To deepen our investigation about temporal evolution, we
also study the ‚Äùintroduction time‚Äù of the 111 AICC methods.
To that end, we count the number of AICC methods introduced
in each Android API level. The results are presented in
Figure 4. New AICC methods have been added at almost
each API level (often between 1 and 5 per API level). We
can see two peaks: one at API level 1 corresponding to the
creation of the Android Framework, and one at API level 28
corresponding to the introduction of AndroidX, a new set
of Android libraries. It is noteworthy that only two AICC
methods have been removed from the Android framework.
 0 5 10 15 20Number of methods
1 3 4 5 9 10 11 14 16 18 19 20 21 22 23 24 25 26 28 29 
API level# of new methods per API among our set of 111 methods
Fig. 4: API levels in which AICC methods have been added.
RQ2 Answer: AICC methods are not new in the Android
framework, they indeed exist since the very beginning.
C.Precision impro vement after applying RAICC
RQ3 aims at in vestig ating the efÔ¨Åcienc y of state-of-the-
art ICC data leak detector I CCTAand A MANDROIDafter
applying R AICC. To do so, we launched the tools before and
after e xecuting RAICC ag ainst 20 new apps that we plan to
integrate into D ROIDBENCH[27], an open test suite containingmore than 200 hand-crafted Android apps for e valuating the
efÔ¨Åcienc y of taint analyzers. D ROIDBENCHis used as a
ground-truth by the research community in order to assess the
efÔ¨Åcienc y ofstatic and dynamic analyzers. It contains different
types of leaks, e.g., intra-component, inter -component, inter -
app, etc. Howe ver, among the ICC leaks, none of them uses
AICC methods. Thus, our idea is to extend D ROIDBENCH
with 20 additional test cases focusing on ICC leaks (concrete
application of taint tracking) performed via AICC methods.
Note that, to detect false positi ves,we included 4 apps without
leak among the 20 apps (i.e., only 16 apps contain a leak).
Benchmark construction Todevelop those 20 apps, we
considered the most representati veAICC methods for both
malicious and benign apps identiÔ¨Åed in Section V-A. More
speciÔ¨Åcally, we considered the top 10 AICC methods (in terms
of occurrences) in both datasets leading to 14 AICC methods
(10+10-6 duplicates). Wealso randomly picked 4 additional
AICC methods to reach the Ô¨Ånal number of 18 AICC methods
(2 AICC methods ha vebeen used twice), which represent
93.5% and 91.1% of the AICC methods occurrences in our
datasets of 50 000 benign apps and 50 000 malicious apps
respectiv ely.
The implementation of most of our bench apps was
straightforward as well as the triggering of the under -
lying inter -component communication. Excerpts of such
bench apps are similar to the ones presented in Listing 3.
Howe ver, some AICC methods have required more so-
phisticated code, e.g., those manipulating Notification
objects, for instance theaddAction AICC method.
Another e xample of more comple x bench app is re-
lated to the AICC method setOnClickPendingIntent
of the android.widget.RemoteViews class. The
PendingIntent set as parameter of this method is triggered
after the user clicks on a widget appearing in the home screen
of the device. The widget (declared in the AndroidMani-
fest.xml Ô¨Åle) has to be insta lled on the home screen before
the user can click on it to trigger the tar get component.
Note that, beside de veloping applications using AICC meth-
ods, we combine multiple aspects of the w ay ICC can be
performed. F or example, in several apps, we considered the
data Ô¨Ço w within three dif ferent components or a data Ô¨Ço w
looping back into the Ô¨Årst component to check the beha vior
or R AICC.
Table IV lists the 20 bench apps. Forthe sak e of space, we
cannot gi vemore details about this benchmark, b ut we invite
the interested reader to refer to the project repository1which
contains the source code of each bench app.
Results Table IV sho ws the results of our e xperiment. Since
ICCTAand A MANDROIDare not designed to detect ICC data
leaks via AICC methods, it is not surprising to see that the y
performs v ery badly without applying RAICC (precision and
recall of 0%). Indeed, ICCTAand A MANDROIDare not able
to construct the links between the components for the 16
1https://github.com/T rustworth y-Software/RAICC
1404?=true-positive, ?= false-positive, = false-negative, C=
Components, UI = User Interaction
Test Case #C. Leak UI ICCTA Amandr oid
sendT extMessage1 2??
setSendDataMessage 3 ??
sendT extMessage2 2 ? ?
addAction1 2 ??
addAction2 2 ? ?
requestNetw ork 2 ??
requestLocationUpdates 3??
startIntentSenderF orResult 2  ?
send 3 ?
sendIntent 2 
setRepeating 2??
setOnClickPendingIntent 3 ??
setLatestEv entInfo 2??
setIne xactRepeating 2 ??
setExact 2??
setExactAndAllo wWhileIdle 2  ??
setW indow 2??
setDeleteIntent 2 ??
setFullScreenIntent 2??
setPendingIntentT emplate 3  ??
Sum, Precision, Recall
?,higher is better 0 16 0 15
?,lower is better 0 2 0 3
,lower is better 16 0 16 1
Precision p=?=(?+?) 0% 88.90% 0% 83.33%
Recall r=?=(?+) 0% 100% 0% 93.75%
F1-score =2pr=(p+r) 0 0.94 0 0.88
TABLE IV: Additional D ROID BENCH apps and results of
applying I CCTA and Amandroid before and after RAICC.
A more complete Table is available in the supplementary material document.
apps containing a leak. However, for the 4 apps which do
not contain any leak, they do not raise any alarm as expected.
After instrumenting the apps with RAICC, the performance
of I CCTA and A MANDROID is improved. They can reveal and
construct previously hidden ICC enabling the detection of the
leaks present in this benchmark.
Regarding I CCTA, it is able to reveal all the leaks after
applying RAICC. However, we can see 2 false-positives. The
Ô¨Årst one, in app ‚ÄùsendTextMessage2‚Äù, is due to I CCTA which
cannot correctly parse extra keys added into Intent ob-
jects (cf. startActivity7 of D R O I D BE N C H ). The sec-
ond one is due to RAICC which cannot, for the moment,
differentiate atypical inter-component communication made
asynchronously. What we mean is that in ‚ÄùaddAction2‚Äù, the
notiÔ¨Åcation is never shown to the user, hence the compo-
nent targeted by the PendingIntent will not be executed
through the notiÔ¨Åcation. Therefore, the leak cannot happen
during execution. Even if declaring a notiÔ¨Åcation and not
showing it to the user is not likely to happen in practice, it
is a good example to show that modeling an app behavior is
not trivial and demands more effort for certain methods. We
can notice that I CCTA behaves correctly with apps ‚Äùsend‚Äù and
‚ÄùsendIntent‚Äù by not raising an alarm.
AMANDROID performance is also boosted. Indeed, it can re-
veal almost all the leaks (1 false-negative). We can notice that
the same false-positives appears for I CCTA and A MANDROID
for apps ‚ÄùsendTextMessage2‚Äù and ‚ÄùaddAction2‚Äù. A MAN -
DROID reveals an additional false-positive for app ‚Äùsend‚Äù.
As a result, the precision of I CCTA combined with RAICC
reaches 88.90% (16 true-positives and 2 false-positives) and
its recall 100% (16 true-positives and 0 false-negative). As for
AMANDROID , combined with RAICC its precision reaches
83.33% (15 true-positives and 3 false-positives) and its recall93.75% (15 true-positives and 1 false-negative). I CCTAF1-
score reaches 0.94 and A MANDROID 0.88.
RQ3 Answer: RAICC boosts both the precision and the
recall of state-of-the-art data leak detectors.
D.Experimental r esults on real-world apps
In this section, we Ô¨Årst in vestig ate to what e xtent R AICC
discov ers pre viously undetected ICC links in real-w orld apps.
Then, we perform tw o checks on these newly detected ICC
links: (1) we check if the y are used to transfer data across
components or even to perform some privacyleaks; (2) we
check if they lead to ICC vulnerabilities.
1) Re vealing ne w ICC links: In this section, we study the
capacity of RAICC in revealing ne w ICC links in real-world
apps. T o that end, we extract, from Androzoo, two datasets
of5000 randomly selected apps containing respectiv ely only
benign and malicious apps. Then for each app, we count the
number of ICC links discov ered without RAICC (by relying
on the results yielded by I C3), as well as the number of
additional ICC links disco vered by R AICC. Note that we only
consider the developer code in this study (i.e., we e xclude the
libraries). T able V presents our results.
IC3 RAICC Increase
Component types Counts % Counts % %
Benign set (5000 )
Activity 17095 84:2% +2463 45:5% +14:4%
BroadcastRecei ver 1221 6:0% +1907 35:3% +156:2%
Service 1984 9:8% +1038 19:2% +52:3%
Total 20300 100% +5408 100% +26:6%
Malicious set (5000 )
Activity 13489 83:1% +7340 73:4% +54:4%
BroadcastRecei ver 747 4:6% +1468 14:7% +196:5%
Service 1986 12:3% +1193 11:9% +60:1%
Total 16222 100% +10001 100% +61:6%
TABLE V: Number of ICC links resolved by IC3and number
of additional ICC links discov ered by RAICC.
Among 5000 benign apps, 5408 new ICC links were re-
vealed by R AICC, corresponding to an increase of more than
25% in comparison with IC3.The most used tar get component
type is Activity with 45% of the new links. Ho wever,
while for IC3 the large majority of ICC links are related to
Activity , the distribution among the 3 types of component
is more balanced with RAICC.As re gards to malicious apps,
while the number if ICC links revealed by IC3 is relativ ely
close to the number of ICC links re vealed in the benign dataset
(20 300 vs.16 222 ), the number of ICC links revealed by
RAICC is much higher , almost twice as much as benign apps
(5408 vs. 10 001 ). Ov erall, R AICCincreases the number of
ICC links by 61% in malicious apps.
All three types of components are impacted by RAICC.
Howe ver, the increase of the number of ICC links is impressiv e
forBroadcastReceiver : 156% for benign apps, and
almost 200% for malicious apps. This suggests that developers
tend to use AICC methods m ore than traditional ICC methods
to ‚Äùbroadcast‚Äù an e vent. Through manual inspection, we
indeed notice that, for instance, an AICC method attached to
an ‚Äùalarm‚Äù is often used to trigger aBroadcastReceiver .
1405Finally, note that we also randomly picked 40 benign and
malicious apps to manually verify if RAICC had correctly
instrumented the real-world apps. The standard ICC methods
are correctly added right after the AICC methods, allowing
other tools to correctly model ICC.
2) Atypical ICC methods are largely used in real-world
apps, although not to transfer or leak data: For this study,
we only consider a set of 5000 malicious apps (the underlying
intuition is that malicious apps tend to leak more data than be-
nign apps). We Ô¨Årst run RAICC on this dataset (to resolve the
atypical ICC links), and then we leverage I CCTA to perform
the detection of ICC leaks (I CCTA uses a set of well-deÔ¨Åned
sources (i.e. sensitive information) and sinks to perform the
detection). Overall, I CCTA was able to detect 6129 intra-
component data leaks (i.e., leaks inside a single method) and
114 ICC data leaks. We manually inspect all 114 ICC data
leaks to check if the data is transferred via AICC methods or
standard ICC methods such as startActivity() . We did
not Ô¨Ånd a single case where sensitive information is leaked
via AICC methods.
We manually analyzed 60 apps to verify how AICC methods
were used. In the majority of cases the target component
is used likewise a callback method, i.e., this mechanism
is used to ‚Äùactivate‚Äù a given component. Actually, when
data is put inside the Intent used for constructing the
PendingIntent or the IntentSender , it is generally
non-sensitive data (most of the time simple constants). Let us
consider a concrete example, for instance the ‚ÄùM1 TraÔ¨Åk‚Äù app
from the Google PlayStore. In method setAlarm of class
com.m1_trafik.AlarmManagerBroadcastReceiver , an
Intent is created with an extra value representing the
Boolean false value. Information attached to this intent
also informs us that the target component is the current
class itself (i.e. the class AlarmManagerBroadcast-
Receiver ). APendingIntent is then retrieved from this
Intent using method getBroadcast() . Afterwards, the
AICC method setRepeating() of class AlarmManager
is leveraged for setting an alarm. When this alarm goes
off, the method onReceive of the target component (in
our case the same class) is executed. When analyzing this
method we can see no use of the extra value put in the
Intent . When applying RAICC, we can see the new
method call sendBroadcast() right after the call to
setRepeating() . Although it helps I CCTA constructing
the link between the components, the data transferred is not
sensitive. In this example, we see that AICC methods are
mostly used to leverage the powerful ‚Äùtoken‚Äù mechanism
explained in Section III, i.e., the target component will be
launched even if the application is closed.
3)RAICC &EPICC - revealing new ICC vulnerabilities:
EPICC [8] is a state-of-the-art ICC links resolver able to
detect ICC vulnerabilities. Such vulnerabilities are deÔ¨Åned by
Chin et al. in [1]. Examples include (1) when an app sends
an Intent that may be intercepted by a malicious component,
or (2) when legitimate app components, ‚Äìe.g., a component
sending sms messages‚Äì are activated via malicious Intent . Inthis section we aim at showing that RAICC boosts EPICC by
enabling the detection of previously unnoticed ICC vulnera-
bilities. To this end, we considered a dataset of 1000 randomly
selected benign apps, and a dataset of 1000 randomly selected
malicious apps. We ran EPICC on those two datasets before
and after applying RAICC, results are available in Table VI.
1000 benign apps 1000 malicious apps
Before RAICC 4796 9544
After RAICC 5032 9868
Impro vement +236 (+4.9%) +324 (+3.4%)
TABLE VI: Number of ICC vulnerabilities found by EPICC
before and after applying RAICC
Besides the signiÔ¨Åcant difference between benign and mali-
cious apps, we can see that after applying RAICC, i.e., model-
ing previously unrevealed ICC links, EPICC is able to detect
more ICC vulnerabilities, with an increase of 4.9% for benign
apps and 3.4% for malicious apps. This experiment shows that
RAICC boosts state-of-the-art tool EPICC by modeling new
ICC links and revealing new ICC vulnerabilities.
RQ4 Answer: RAICC signiÔ¨Åcantly increases the number
of resolved ICC links in real-world apps compared to the
state-of-the-art approach. While AICC methods seem to
not be used to leak sensitive information, they are used to
activate components (and thus potentially trigger malicious
payloads). RAICC boosts EPICC by allowing to reveal
new ICC vulnerabilities.
E.Runtime performance ofRAICC
In this section, we evaluate the runtime performance of
RAICC.Wealso e valuate the o verhead introduced by our tool
by considering a typical usage of RAICC,for instance when
RAICC is used to boost the results of ICCTA. Since ICCTA
leverages itself IC3,we in vestig ate the runtime performance
of IC3and I CCTAbefore and after applying RAICC on the
10 benchmark apps used in Section V-C.
The results are presented in Figure 5. First, we can see that
the R AICCexecution time does not exceed 80 seconds. Since
RAICC allo ws I C3and I CCTAto resolv e more additional
ICC links, we e xpect that the analysis time of both tools will
increase. W e indeed note that the tw o box-plots on the right
are higher conÔ¨Årming the overhead caused by R AICC. On
average, the overheads for IC3 and ICCTAare13:3seconds
and 10seconds respecti vely (36:74% and 24:74% overhead
respectiv ely).
 30 40 50 60 70 80
RAICC IC3 IccTA R-IC3 R-IccTATime (s)
 0 50 100 150 200 250 300
RAICC IC3 IccTA R-IC3 R-IccTATime (s)
Fig. 5: Runtime performance of RAICC, IC3 and IccTA with
(R- means with R AICC) and without AICCM preprocessing.
(left: on Droidbench, right: in the wild).
1406To conÔ¨Årm the results obtained on the benchmark apps,
we perform the same study but on a set of 1000 real-world
apps. The results are reported in Figure 5. Overall, we can
see that the performances (in time) reported on both Ô¨Ågures
are quite similar. However, slight differences can be noticed.
First, the runtime values are more scattered in Figure 5 than
with the benchmark apps. This could be explained by the fact
that real-world apps are more diverse. Second, the average
performances of the three tools are closer.
Regarding the overhead introduced by RAICC, we again
notice that this overhead exists. This is expected since the con-
stant propagation of IC3 has to process more values/methods.
Likewise, I CCTA has to build more links and to consider more
paths for the taint analysis. On this dataset, on average, the
overheads for IC3 and I CCTA are 21:8seconds and 5:8sec-
onds respectively (+ 43:8% and + 6:5% overhead respectively).
RQ5 Answer: The runtime performance of RAICC is
higher than IC3 and I CCTA, but still in the same order
of magnitude. On average, RAICC requires less than 2
minutes to analyze and instrument a real-world application.
VI.LIMITATIONS
The core component of our approach liesin the list of AICC
methods that we compiled during our research. Ev en though
we follo wed a systematic approach for retrie ving a maximum
of AICC methods, we might ha vemissed some of them in
the Android Framew ork. There are potentially other w ays to
perform such ICC, ne vertheless, our study is reproducible and
provides insight for future research in this direction.
By le veraging IC3 to infer the values of ICC objects,
RAICC inherits the limitations of IC3. Moreov er,like most
of the static analysis approaches, R AICCis subject to false-
positiv es. Currently , RAICC does not handle nati vecalls,
reÔ¨Çectiv e calls nor dynamic class loading, though some state-
of-the-art approach could be integrated [11], [28]. Besides,
although inter -app communication (IAC) is performed using
the same mechanisms as ICC [29], we did not in vestig ate in
this direction.
Furthermore, obfuscation is aconfounding f actor impacting
studies based on APKs [30], [31]. Therefore, R AICC‚Äôseffec-
tiveness is impacted by obfuscated code, especially if AICC
method calls are disguised (e.g., using reÔ¨Çection).
VII.RELATEDWORK
Tothe best of our knowledge, we ha vepresented the Ô¨Årst
approach taking into account AICC methods for connecting
Android components. Howe ver, as explained in a systematic
literature re view [32], the research literature has proposed a
large body of works focusing on statically analyzing Android
apps. One of the most popular topics is the use of static
analysis for checking security properties, and in particular for
checking data leaks. The pioneer tools such as FlowDroid,
Scandal, and others [27], [33]‚Äì[36] ha vestarted to focus on
the detection of intra-component data leaks. They all face the
limitations of not being able to detect ICC leaks.Several approaches have been developed to perform data
leak detection between components. Wewill present these
approaches in the follo wing. ICCTA[5] le verages IC3 [9]
to identify ICC methods and theirs parameters, and then
instruments the app by matching and connecting ICC meth-
ods with their tar get components. The identiÔ¨Åcation of ICC
methods and the instrumentation part rely on a list of ICC
methods that only contain well documented ICC methods . By
considering additional ICC methods (i.e., AICC methods),
our tool complements a tool s uch as ICCTA. In the same
way,DROIDSAFE[3] transforms ICC calls into appropriate
method calls to the destination component. Likewise, I CCTA,
the ICC methods considered by D ROIDSAFEare only the
well-documented ICC methods. As a result both D ROIDSAFE
and I CCTA share the same limitation, i.e., the y miss the
AICC methods. Unlike the pre viously described tools, AMAN-
DROID[4] constructs an inter -component data Ô¨Çow graph
(IDFG) and a data dependence graph (DDG) in which it can
run its analysis. Ag ain, it only considers documented ICC
methods manipulating Intents .
Other tools leverage ICC links to detect malicious apps.
ICCDETECTOR[7], for instance, uses Machine Learning
(ML) to detect Android malw are. The ML model is built by
using ICC-related features e xtracted with EPICC [8]. As it
relies on EPICC to extract ICC features, it is dependent on
EPICC for the considered ICC methods. Yet, EPICC,just
as IC3only considers documented ICC methods for inter -
component communicati on.In the same w ay,Li & al. [37]
set up a ML approach for detecting malicious applications.
The feature set used is based on Potential Component Leaks
(PCL) in Android apps. PCLs are deÔ¨Åned using components
as entry and/or e xit points. Again, they consider traditional
ICC methods as exit points for transferring data through
components.
ICCMATT[38] aims at conceptually modeling ICC in
Android apps to generate test cases. The purpose is to identify
components vulnerable to malicious data injection and pri vacy
leaks. The approach of the researchers takes into account
PendingIntent objects, b ut only at the conceptual le vel.
They describe them asIntent wrappers able to be shared
between components, mainly used in notiÔ¨Åcat ions and/or alarm
services as we ha veseen throughout this paper . The y do
not directly refer to methods for performing inter -component
communication atypically withPendingIntent objects.
In the same w ay,Enck et al. [39] describe the over-
all functioning ofPendingIntents for inte gration with
third-party applications. Nevertheless, the y do not e xplain,
as in [17], the security threats that it poses as well as the
difÔ¨Åculty it induces for ICC modeling in static analyzers.
PiAnalyzer [ 17]models speciÔ¨Åc vulnerabilities where other
apps can intercept broadcasted PendingIntents. In contrast,
RAICC generically models ICC links where PendingIntent (as
well as IntentSender) a re in volved. The goals of PiAnalyzer
and R AICC are thus different. Hence, R AICC was not
compared to PiAnalyzer in this study .
Besides static analysis approaches, dynamic analysis solu-
1407tions have also been studied for the detection of ICC data
leaks. For example, COPPER DROID [40] is able to reconstruct
the app behavior by observing interactions between the app
and the underlying Linux system. TAINT DROID [41] dy-
namically tracks sensitive information with a modiÔ¨Åed Dalvik
virtual machine. Monitoring the behavior of an Android app
is also popular in dynamic data leak detection [42]‚Äì[45]. De-
pending on the taint policy set up for propagating tainted data,
a dynamic analysis could consider and therefore detect atypical
ICC data leaks. Nonetheless, precise methods exist [46] for
bypassing taint-tracking, leading to false-negatives as well
as more general approaches for tackling ICC-related security
issues [47], [48].
VIII. C ONCLUSION
We addressed the challenge of precisely modeling inter-
component communication in Android apps. After empirically
showing that Android apps can leverage atypical ways for
performing ICC, we discuss the implications for state of
the art ICC modeling-based analysis. We contribute towards
using methods not primarily made for this purpose. We have
developed and open-sourced RAICC, which reveals AICC
methods and further resolves them into standard ICC through
instrumentation. We demonstrate that RAICC can boost ex-
isting analyzers such as A MANDROID and I CCTA, enabling
them to substantially increase their data leak detection rates.
IX. D ATA AVAILABILITY
We provide a complete set of artefacts for reproducibility
purposes. In particular, we provide the datasets used in our
study, third-party tools used as well as scripts to run them.
We also provide the entire source code of our tool RAICC.
All artifacts are available online at:
https://github.com/Trustworthy-Software/RAICC
X. A CKNOWLEDGMENT
This work was partly supported (1) by the Luxembourg
National Research Fund (FNR), under projects CHARAC-
TERIZE C17/IS/11693861, ONNIV A 12696663, and the AFR
grant 14596679, (2) by the SPARTA project, which has
received funding from the European Union‚Äôs Horizon 2020
research and innovation program under grant agreement No
830892, and (3) by the Luxembourg Ministry of Foreign and
European Affairs through their Digital4Development (D4D)
portfolio under project LuxWAyS.
REFERENCES
[1] E. Chin, A. P. Felt, K. Greenwood, and D. Wagner, ‚ÄúAnalyzing inter-
application communication in android,‚Äù in Proceedings of the 9th
international conference on Mobile systems, applications, and services ,
2011, pp. 239‚Äì252.
[2] L. Li, D. Li, T. F. Bissyand ¬¥e, J. Klein, Y . Le Traon, D. Lo, and
L. Cavallaro, ‚ÄúUnderstanding android app piggybacking: A systematic
study of malicious code grafting,‚Äù IEEE Transactions on Information
Forensics and Security , vol. 12, no. 6, pp. 1269‚Äì1284, 2017.
[3] M. I. Gordon, D. Kim, J. H. Perkins, L. Gilham, N. Nguyen, and M. C.
Rinard, ‚ÄúInformation Ô¨Çow analysis of android applications in droidsafe.‚Äù
inNDSS , vol. 15, no. 201, 2015, p. 110.[4] F. Wei, S. Roy, and X. Ou, ‚ÄúAmandroid: A precise and general
inter-component data Ô¨Çow analysis framework for security vetting of
android apps,‚Äù in Proceedings of the 2014 ACM SIGSAC Conference on
Computer and Communications Security , 2014, pp. 1329‚Äì1341.
[5] L. Li, A. Bartel, T. F. Bissyand ¬¥e, J. Klein, Y . Le Traon, S. Arzt,
S. Rasthofer, E. Bodden, D. Octeau, and P. McDaniel, ‚ÄúIccta: Detecting
inter-component privacy leaks in android apps,‚Äù in 2015 IEEE Interna-
tional Conference on Software Engineering . IEEE, 2015, pp. 280‚Äì291.
[6] F. I. Abro, M. Rajarajan, T. M. Chen, and Y . Rahulamathavan, ‚ÄúAn-
droid application collusion demystiÔ¨Åed,‚Äù in International Conference on
Future Network Systems and Security . Springer, 2017, pp. 176‚Äì187.
[7] K. Xu, Y . Li, and R. H. Deng, ‚ÄúIccdetector: Icc-based malware detection
on android,‚Äù IEEE Transactions on Information Forensics and Security ,
vol. 11, no. 6, pp. 1252‚Äì1264, 2016.
[8] D. Octeau, P. McDaniel, S. Jha, A. Bartel, E. Bodden, J. Klein,
and Y . Le Traon, ‚ÄúEffective inter-component communication mapping
in android: An essential step towards holistic security analysis,‚Äù in
Presented as part of the 22nd fUSENIXgSecurity Symposium , 2013,
pp. 543‚Äì558.
[9] D. Octeau, D. Luchaup, M. Dering, S. Jha, and P. McDaniel, ‚ÄúCom-
posite constant propagation: Application to android inter-component
communication analysis,‚Äù in 2015 IEEE/ACM 37th IEEE International
Conference on Software Engineering , vol. 1. IEEE, 2015, pp. 77‚Äì88.
[10] P. Barros, R. Just, S. Millstein, P. Vines, W. Dietl, M. D. Ernst et al. ,
‚ÄúStatic analysis of implicit control Ô¨Çow: Resolving java reÔ¨Çection and
android intents (t),‚Äù in 2015 30th IEEE/ACM International Conference
on Automated Software Engineering (ASE) . IEEE, 2015, pp. 669‚Äì679.
[11] L. Li, T. F. Bissyand ¬¥e, D. Octeau, and J. Klein, ‚ÄúDroidra: Taming reÔ¨Çec-
tion to support whole-program analysis of android apps,‚Äù in Proceedings
of the International Symposium on Software Testing and Analysis , 2016,
pp. 318‚Äì329.
[12] F. Allen, ‚ÄúControl Ô¨Çow analysis,‚Äù ACM Sigplan Notices , pp. 1‚Äì19, 1970.
[13] Google. (2020) Services documentation. [Online]. Available: https:
//developer.android.com/guide/components/services
[14] ‚Äî‚Äî. (2020) Components fundamentals documentation. [Online]. Avail-
able: https://developer.android.com/guide/components/fundamentals
[15] ‚Äî‚Äî. (2020) Intents documentation. [Online]. Available: https:
//developer.android.com/training/basics/intents
[16] S. S. Engineering. (2020) Droidbench: Open-source test suite. [Online].
Available: https://github.com/secure-software-engineering
[17] S. Gro√ü, A. Tiwari, and C. Hammer, ‚ÄúPianalyzer: A precise approach
for pendingintent vulnerability analysis,‚Äù in European Symposium on
Research in Computer Security . Springer, 2018, pp. 41‚Äì59.
[18] Google. (2020) Pendingintent documentation. [Online]. Available:
https://developer.android.com/reference/android/app/PendingIntent
[19] ‚Äî‚Äî. (2020) Intentsender documentation. [Online]. Available: https:
//developer.android.com/reference/android/content/IntentSender
[20] S. Arzt, S. Rasthofer, and E. Bodden, ‚ÄúInstrumenting android and java
applications as easy as abc,‚Äù in International Conference on Runtime
VeriÔ¨Åcation . Springer, 2013, pp. 364‚Äì381.
[21] R. Vallee-Rai and L. J. Hendren, ‚ÄúJimple: Simplifying java bytecode for
analyses and transformations,‚Äù 1998.
[22] R. Vall ¬¥ee-Rai, P. Co, E. Gagnon, L. Hendren, P. Lam, and
V . Sundaresan, ‚ÄúSoot: A java bytecode optimization framework,‚Äù
inCASCON First Decade High Impact Papers , ser. CASCON
‚Äô10. USA: IBM Corp., 2010, p. 214‚Äì224. [Online]. Available:
https://doi.org/10.1145/1925805.1925818
[23] A. Bartel, J. Klein, Y . Le Traon, and M. Monperrus, ‚ÄúDexpler: converting
android dalvik bytecode to jimple for static analysis with soot,‚Äù in
Proceedings of the ACM SIGPLAN International Workshop on State
of the Art in Java Program analysis , 2012, pp. 27‚Äì38.
[24] K. Allix, T. F. Bissyand ¬¥e, J. Klein, and Y . Le Traon, ‚ÄúAndrozoo:
Collecting millions of android apps for the research community,‚Äù in 2016
IEEE/ACM 13th Working Conference on Mining Software Repositories
(MSR) . IEEE, 2016, pp. 468‚Äì471.
[25] V . Total. (2020) Virus total free online virus, malware and url scanner.
[Online]. Available: https://www.virustotal.com/en
[26] L. Li, T. F. Bissyand ¬¥e, J. Klein, and Y . L. Traon, ‚ÄúAn investigation
into the use of common libraries in android apps,‚Äù in 2016 IEEE
23rd International Conference on Software Analysis, Evolution, and
Reengineering (SANER) , vol. 1, 2016, pp. 403‚Äì414.
[27] S. Arzt, S. Rasthofer, C. Fritz, E. Bodden, A. Bartel, J. Klein,
Y . Le Traon, D. Octeau, and P. McDaniel, ‚ÄúFlowdroid: Precise context,
1408Ô¨Çow, Ô¨Åeld, object-sensitive and lifecycle-aware taint analysis for android
apps,‚Äù Acm Sigplan Notices , vol. 49, no. 6, pp. 259‚Äì269, 2014.
[28] E. Bodden, A. Sewe, J. Sinschek, H. Oueslati, and M. Mezini, ‚ÄúTaming
reÔ¨Çection: Aiding static analysis in the presence of reÔ¨Çection and custom
class loaders,‚Äù in International Conference on Software Engineering .
IEEE, 2011, pp. 241‚Äì250.
[29] L. Li, A. Bartel, T. F. Bissyand ¬¥e, J. Klein, and Y . Le Traon, ‚ÄúApkcom-
biner: Combining multiple android apps to support inter-app analysis,‚Äù
inIFIP International Information Security and Privacy Conference .
Springer, 2015, pp. 513‚Äì527.
[30] M. Hammad, J. Garcia, and S. Malek, ‚ÄúA large-scale empirical
study on the effects of code obfuscations on android apps and
anti-malware products,‚Äù in Proceedings of the 40th International
Conference on Software Engineering , ser. ICSE ‚Äô18. New York,
NY , USA: Association for Computing Machinery, 2018, p. 421‚Äì431.
[Online]. Available: https://doi.org/10.1145/3180155.3180228
[31] M. Linares-V ¬¥asquez, A. Holtzhauer, C. Bernal-C ¬¥ardenas, and
D. Poshyvanyk, ‚ÄúRevisiting android reuse studies in the context
of code obfuscation and library usages,‚Äù in Proceedings of the 11th
Working Conference on Mining Software Repositories , ser. MSR 2014.
New York, NY , USA: Association for Computing Machinery, 2014, p.
242‚Äì251. [Online]. Available: https://doi.org/10.1145/2597073.2597109
[32] L. Li, T. F. Bissyand, M. Papadakis, S. Rasthofer, A. Bartel, D. Octeau,
J. Klein, and L. Traon, ‚ÄúStatic analysis of android apps,‚Äù Inf. Softw.
Technol. , vol. 88, no. C, p. 67‚Äì95, Aug. 2017. [Online]. Available:
https://doi.org/10.1016/j.infsof.2017.04.001
[33] C. Gibler, J. Crussell, J. Erickson, and H. Chen, ‚ÄúAndroidleaks: auto-
matically detecting potential privacy leaks in android applications on
a large scale,‚Äù in International Conference on Trust and Trustworthy
Computing . Springer, 2012, pp. 291‚Äì307.
[34] J. Kim, Y . Yoon, K. Yi, J. Shin, and S. Center, ‚ÄúScandal: Static analyzer
for detecting privacy leaks in android applications,‚Äù MoST , vol. 12, no.
110, p. 1, 2012.
[35] C. Mann and A. Starostin, ‚ÄúA framework for static detection of privacy
leaks in android applications,‚Äù in Proceedings of the 27th annual ACM
symposium on applied computing , 2012, pp. 1457‚Äì1462.
[36] Z. Yang and M. Yang, ‚ÄúLeakminer: Detect information leakage on
android with static taint analysis,‚Äù in 2012 Third World Congress on
Software Engineering . IEEE, 2012, pp. 101‚Äì104.
[37] L. Li, K. Allix, D. Li, A. Bartel, T. F. Bissyand ¬¥e, and J. Klein, ‚ÄúPotential
component leaks in android apps: An investigation into a new feature
set for malware detection,‚Äù in 2015 IEEE International Conference on
Software Quality, Reliability and Security . IEEE, 2015, pp. 195‚Äì200.
[38] A. K. Jha, S. Lee, and W. J. Lee, ‚ÄúModeling and test case generation
of inter-component communication in android,‚Äù in 2015 International
Conference on Mobile Software Engineering and Systems . IEEE, 2015,
pp. 113‚Äì116.
[39] W. Enck, M. Ongtang, and P. McDaniel, ‚ÄúUnderstanding android secu-
rity,‚Äù IEEE security & privacy , vol. 7, no. 1, pp. 50‚Äì57, 2009.
[40] K. Tam, S. J. Khan, A. Fattori, and L. Cavallaro, ‚ÄúCopperdroid: Auto-
matic reconstruction of android malware behaviors.‚Äù in NDSS , 2015.
[41] W. Enck, P. Gilbert, S. Han, V . Tendulkar, B.-G. Chun, L. P. Cox,
J. Jung, P. McDaniel, and A. N. Sheth, ‚ÄúTaintdroid: an information-
Ô¨Çow tracking system for realtime privacy monitoring on smartphones,‚Äù
ACM Transactions on Computer Systems , vol. 32, no. 2, pp. 1‚Äì29, 2014.
[42] M. Backes, S. Gerling, C. Hammer, M. Maffei, and P. von Styp-
Rekowsky, ‚ÄúAppguard‚Äìenforcing user requirements on android apps,‚Äù
inInternational Conference on TOOLS and Algorithms for the Con-
struction and Analysis of Systems . Springer, 2013, pp. 543‚Äì548.
[43] P. Hornyack, S. Han, J. Jung, S. Schechter, and D. Wetherall, ‚ÄúThese
aren‚Äôt the droids you‚Äôre looking for: retroÔ¨Åtting android to protect
data from imperious applications,‚Äù in Proceedings of the 18th ACM
conference on Computer and communications security , 2011, pp. 639‚Äì
652.
[44] R. Xu, H. Sa ¬®ƒ±di, and R. Anderson, ‚ÄúAurasium: Practical policy en-
forcement for android applications,‚Äù in Presented as part of the 21st
fUSENIXgSecurity Symposium ( fUSENIXgSecurity 12) , 2012, pp.
539‚Äì552.
[45] A. Bartel, J. Klein, M. Monperrus, K. Allix, and Y . Le Traon, ‚ÄúImproving
privacy on android smartphones through in-vivo bytecode instrumenta-
tion,‚Äù 2012.
[46] G. Sarwar, O. Mehani, R. Boreli, and M. A. Kaafar, ‚ÄúOn the effective-
ness of dynamic taint analysis for protecting against private information
leaks on android-based devices.‚Äù in SECRYPT , vol. 96435, 2013.[47] M. Hammad, J. Garcia, and S. Malek, ‚ÄúSelf-protection of android
systems from inter-component communication attacks,‚Äù in Proceedings
of the 33rd ACM/IEEE International Conference on Automated
Software Engineering , ser. ASE 2018. New York, NY , USA:
Association for Computing Machinery, 2018, p. 726‚Äì737. [Online].
Available: https://doi.org/10.1145/3238147.3238207
[48] J. Garcia, M. Hammad, N. Ghorbani, and S. Malek, ‚ÄúAutomatic
generation of inter-component communication exploits for android
applications,‚Äù in Proceedings of the 2017 11th Joint Meeting on
Foundations of Software Engineering , ser. ESEC/FSE 2017. New
York, NY , USA: Association for Computing Machinery, 2017, p.
661‚Äì671. [Online]. Available: https://doi.org/10.1145/3106237.3106286
1409