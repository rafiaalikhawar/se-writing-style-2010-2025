Same File, Different Changes: The Potential of
Meta-Maintenance on GitHub
Hideaki Hata,⇤Raula Gaikovina Kula,⇤Takashi Ishio,⇤Christoph Treude†
⇤Nara Institute of Science and Technology
{hata, raula-k, ishio}@is.naist.jp
†University of Adelaide
christoph.treude@adelaide.edu.au
Abstract —Online collaboration platforms such as GitHub have
provided software developers with the ability to easily reuse
and share code between repositories. With clone-and-own andforking becoming prevalent, maintaining these shared ﬁles isimportant, especially for keeping the most up-to-date version ofreused code. Different to related work, we propose the conceptof meta-maintenance—i.e., tracking how the same ﬁles evolve indifferent repositories with the aim to provide useful maintenanceopportunities to those ﬁles. We conduct an exploratory studyby analyzing repositories from seven different programminglanguages to explore the potential of meta-maintenance. Ourresults indicate that a majority of active repositories on GitHubcontains at least one ﬁle which is also present in anotherrepository, and that a signiﬁcant minority of these ﬁles aremaintained differently in the different repositories which containthem. We manually analyzed a representative sample of sharedﬁles and their variants to understand which changes might beuseful for meta-maintenance. Our ﬁndings support the potentialof meta-maintenance and open up avenues for future work tocapitalize on this potential.
I. I NTRODUCTION
Clone-and-own is a quick way to create customized variants
of a software project by copying an existing product and adapt-
ing it to a new set of requirements [1]–[3]. Despite perceivedbeneﬁts, such as simplicity, availability, and independence ofdevelopers [2], clone-and-own has been criticized for leadingto a large number of code clones [4], making it difﬁcultto propagate changes such as bug ﬁxes from one instanceto another. Clone-and-own also leads to problems related toawareness: developers do not know when and where their codeis being cloned, they do not know the origin of the clonedcode, and they have no means of staying aware of changesto other instances that might beneﬁt their own instance of thecloned code.
Source code reuse across multiple software projects has
been widely studied in code clone research. It is reported thata large number of projects included copies of libraries [5]–[7].Gharehyazie et al. reported that most projects obtain ﬁles fromoutside rather than providing their ﬁles to other projects [8].Forking, including traditional hard forking [9] and recentfork-based development in GitHub [10], [11], is one type ofsource code reuse. Recent studies discussed several problemsin forking, such as redundant development, lost contributions,and fragmented communities [12], [13].Even with its large-scale code resources and a large amount
of developers, Google is reported to address reuse properlywith a monolithic source code management system [14], [15].Such a monolithic system has several advantages: uniﬁedversioning, extensive code sharing and reuse, simpliﬁed de-pendency management, large-scale refactoring, and so on [14].Based on the monolithic source code management, changesto core libraries are promptly and easily propagated throughthe dependency chain into the ﬁnal products that rely on thelibraries [14].
Although introducing such a complete monolithic source
code management system in the entire free/libre open sourcesoftware (FLOSS) ecosystem is not practical, tracking sourcecode across multiple projects could bring new insight intosoftware maintenance. If we can aggregate and composeuseful changes from various repositories maintaining the sameorigins, sharing such composed changes can help softwaremaintenance activities efﬁciently for multiple projects. We callthis approach meta-maintenance.
To investigate the feasibility of meta-maintenance, in this
paper, we report on the results of an exploratory study ofalmost 28 million ﬁles that are shared by multiple GitHubrepositories. We found that in more than 70% of the repos-itories in our sample, there is at least one ﬁle which alsoexists in another repository. Most of these ﬁles have not beenmaintained, but there is a signiﬁcant minority which has notonly been maintained but often has received project-speciﬁcchanges, such as bug ﬁxes. We manually analyzed a represen-tative sample of such ﬁles as part of a qualitative analysis,and found that ﬁles that are shared by a large number ofrepositories are often libraries (e.g., jQuery) while ﬁles that areshared by a smaller group of repositories tend to contain utilityfunctionality (e.g., drivers). In the former case, the repositorieswhich share the ﬁle tend to be unrelated while in the lattercase, there is often a relationship between repositories (e.g.,one repository relying on the code in another).
Investigating how ﬁles changed in different repositories
revealed a number of different types of changes, includinglibrary updates (e.g., upgrading the jQuery library), commitstaken from a known origin (e.g., the Linux kernel project),as well as project-speciﬁc changes (e.g., bug ﬁxes). We ar-gue that project-speciﬁc changes have the largest potentialfor meta-maintenance, and we conducted a survey in which
7732021 IEEE/ACM 43rd International Conference on Software Engineering (ICSE)
1558-1225/21/$31.00 ©2021 IEEE
DOI 10.1109/ICSE43902.2021.00076
we asked project maintainers what they thought of speciﬁc
instances where meta-maintenance could be applied in their
repositories, i.e., the maintainers were maintaining a ﬁle that
had been changed in another repository, potentially incorpo-
rating interesting changes. This survey result provided further
evidence for the potential of meta-maintenance and pointed
out interesting areas for future work.
II. R ELATED WORK
Before outlining our methodology, we discuss extensive
literature related to code clones, origin analysis, and forks.
A. Cross-Project Code Clones
Code clone detection is the most popular approach to ana-
lyze source code reuse activities. Since developers may modify
a code fragment for their own purpose, various tools have
been proposed to detect similar source code fragments [16].
Kamiya et al. [17] proposed CCFinder that analyzes normal-
ized token sequences. Jiang et al. [18] proposed DECKARD
that compares a vector representation of an abstract syntax
tree. Nguyen et al. [19] proposed Exas that compares a
vector representation of a dependence graph. Sasaki et al. [20]
proposed FCFinder that recognizes ﬁle-level clones using hash
values of normalized source ﬁles. Cordy et al. [21] proposed
NiCad that compares a pair of code blocks using a longest
common subsequence algorithm. Sajnani et al. [22] proposed
SourcererCC that compares a pair of code blocks using Jaccard
index of tokens.
Code clone detection tools revealed that software devel-
opers often copy source ﬁles from other projects. Hemel
et al. [23] analyzed vendor-speciﬁc versions of Linux kernel.
Their analysis showed that each vendor created a variant
of Linux kernel and customized many ﬁles in the variant.
Ossher et al. [5] analyzed cloned ﬁles across repositories using
a lightweight technique. They reported that projects cloned
ﬁles from related projects, libraries, and utilities. Koschke
et al. [24] also reported that a relatively large number of
projects included copies of libraries. Lopes et al. [7] analyzed
duplicated ﬁles in 4.5 million projects hosted on GitHub and
reported that the projects have a large amount of ﬁle copies.
Gharehyazie et al. [8] analyzed cross-project code clones of
5,753 Java projects on GitHub. They also analyzed timestamps
of the clones and reported that developers often copy an entire
library, and some projects serve as hubs (sources) of clones
to other projects. The analyzed source code is a snapshot
at a certain point of time. Our study extends the analysis
by including additional programming languages and all the
versions of projects.
Identiﬁed code reuses across projects can be used for several
applications. Dang et al. [25] reported that Microsoft develop-
ers use code clone information to ﬁx bugs in multiple products
at once. Rubin et al. [26] reported that industrial developers
extract reusable components as core assets from existing
software products. Bauer et al. [27] proposed to extract code
clones across products as a candidate of a new library. Ishihara
et al. [28] proposed a function-level clone detection to identifyreusable functions in a number of projects. Luo et al. [29]
proposed a method to identify semantically equivalent basic
blocks for code plagiarism detection. Chen et al. [30] proposed
a technique to detect clones of Android applications using
similarity between control-ﬂow graphs of methods.
Davies et al. [31], [32] proposed a ﬁle signature to identify
the origin of a jar ﬁle using classes and their methods in the
ﬁle ignoring the details of code. Ishio et al. [3] extended the
analysis to automatically identify libraries copied in a product.
Similar to these approaches, this study starts the analysis from
ﬁle-level clones.
B. Origin Analysis
Software projects use source code repositories to manage
the versions of source code. Although a repository tracks
modiﬁed lines of code between two consecutive versions
of a ﬁle, the feature is not always sufﬁcient to represent
a complicated change. Godfrey et al. [33] proposed origin
analysis to identify merged and split functions between two
versions of source code. The method compares identiﬁers used
in functions to identify original functions. Steidl et al. [34]
proposed to detect source code move, copy, and merge in
a source code repository. The method identiﬁes a similar
ﬁle in a repository as a candidate of an original version.
Kawamitsu et al. [35] proposed an extension of origin analysis
across two source code repositories. Their method identiﬁes
an original version of source code in a library’s source code
repository. Spinellis [36] constructed a Git repository including
the entire history of Unix versions. The uniﬁed repository
enables developers to investigate the change history of source
ﬁles across projects. German et al. [37] used CCFinder to
detect code siblings reused across FreeBSD, OpenBSD and
Linux kernels, and then investigated the source code repos-
itories of the projects to identify the original project of a
code sibling. Krinke et al. [38] proposed to distinguish copies
from originals by comparing timestamps of code fragments
recorded in source code repositories. Krinke et al. [39] used the
approach and visualized source code reuse among GNOME
Desktop Suite projects. In this study, we do not intend to
identify origins but investigate ﬁles in clone sets in terms of
whether there are useful changes in their histories that could
beneﬁt other repositories.
C. Forks
Software developers often fork repositories in order to pro-
pose source code changes to the original projects. Stanciulescu
et al. [40] analyzed an OSS community and reported that
forks contribute new features while developers may spend their
effort on redundant development. Ren et al. [41] proposed
a machine learning model using change description, patch
content, and issue tracker to identify redundant code changes
in forks. Zhou et al. [12] proposed a tool named Infox to
automatically identify unique source code changes as new
features in forks. Different from those analyses, this study does
not focus on forked repositories, and revealed that non-forked
repositories also include their own changes to reused source
774code. Zhou et al. [13] reported that better modularity and cen-
tralized management are associated with more contributions
and a higher fraction of accepted pull requests from forks.
They also reported that the lower the pull request acceptance
rate, the higher the chance of a project having hard forks.
Regarding hard forking, Ray et al. analyzed porting of an
existing feature or bug ﬁx across forked projects [9]. They
reported that forking allows independent evolution but results
in the signiﬁcant cost of porting activity.
Propagating changes to others is also considered as a
challenge in software product line engineering. Strüber et
al. [42] included the task in scenarios for evaluating techniques
that support developers during the evolution of variant-rich
systems. To support such propagation of a bug ﬁx, ReDe-
Bug [43] and Cloriﬁ [44] have been proposed to efﬁciently
identify source ﬁle clones to which a patch should be applied.
III. M ETA-MAINTENANCE :TERMINOLOGY
The concept of meta-maintenance is based on the model
of individual evolution of the same ﬁles (clones) in differ-
ent repositories (not limited to forks), which is inspired by
Google’s monolithic source code management system [14],
with the aim to maintain the overall ecosystem. We now deﬁne
the terminology needed to describe meta-maintenance at ﬁle
level.
Aseed ﬁle is a speciﬁc version of a ﬁle that is shared in
multiple software repositories. In this paper, we focus on Git
repositories, thereby considering speciﬁc Git blobs appearing
in multiple repositories to be seed ﬁles. A Git blob stores the
content of a ﬁle with a speciﬁc version, and is identiﬁed with
its SHA-1 hash of the content [45]. Let frefer to a seed ﬁle for
a repository rso that r(f)indicates the repository rcontaining
ﬁlef. Software repositories that contain the same seed ﬁle
are then referred to as belonging to the same seed family
SF0, where SF0={r1(f),r2(f),. . . ,r n(f)}for repositories
r1,r2torn. After the time Tpassed, the seed family SF0
becomes SFT={r1(fx),r2(fy),. . . ,r n(fz)}, where fx,fy,
andfzrepresent updated ﬁles from the same seed ﬁle f, and
x,y, and zare the number of changes to the ﬁles. The ﬁle
f0=f, and we call fi(i> 0)avariant . We call fland
fmduplicate variants if their contents are the same even if l
andmare different. Meta-maintenance involves the analysis
of how variants in the same seed family evolve.
Forking is an explicit form of sharing seed ﬁles. In this paper
we do not focus on forks as seed families. Recent studies have
tried supporting change propagation in forks with a centralized
model, that is, accumulating changes upstream and distributing
them downstream [12], [13], [41]. As well as such explicit
reuse relationships, meta-maintenance is conceptualized to
be able to support implicit reuse relationships. We intend
to support repositories in seed families with a decentralized
model, that is, useful changes are aggregated from individual
repositories and are distributed to others.IV. P REPARATIONS
In this section, we present our research questions and data
collection methodology.
A. Research Questions
The main goal of the study is to explore the potential
for meta-maintenance for contemporary software projects in
GitHub. Based on this goal, we constructed six research
questions to guide our study. We now present each of these
questions, along with our motivation.
(RQ1): How prevalent are seed ﬁles in software repositories?
(RQ2): What kinds of seed ﬁles are there?
(RQ3): Are there relationships among repositories in seed
families?
(RQ4): What was the main driver of the changes for variants?
(RQ5): How uniquely do variants evolve in seed families?
(RQ6): How do developers consider changes for variants?
The motivation of RQ1 is to understand whether seed ﬁles
and their seed families are common in the wild. Further-
more, we would like to quantitatively explore the distribution,
maintenance statuses, and patterns of seed families. RQ2 ,
RQ3 andRQ4 require a deeper analysis of seed ﬁles and
repositories, where we would like to understand the nature
of the seed ﬁles and reasons behind their evolution. The key
motivation for RQ2 is to identify kinds of seed ﬁles that are
used in the software repositories. Such insights would help
identify the nature for why these seed ﬁles were reused in
other repositories. Then for RQ3 , we would like to understand
whether there is a connection among repositories in the same
seed families. The key motivation for RQ4 is to determine
the key drivers that inﬂuenced the changes that were made to
the seed ﬁles in those repositories. RQ5 then investigates the
seed ﬁles from an evolutionary and maintenance standpoint.
We would like to quantitatively understand how developers
are updating or maintaining variants after reusing seed ﬁles
in their projects and how differently variants evolve. Our aim
forRQ6 is to understand how developers react to changes in
other variants.
B. Data Collection
Here we describe our procedures for target repository prepa-
ration, Git blob extraction, and stratiﬁed sampling, for our data
collection.
a) Repository preparation: To pursue the feasibility of
meta-maintenance, we collect a large amount of software de-
velopment repositories that have been actively developed. We
follow the same procedure as in a previous study [46] to iden-
tify candidate repositories. We target software development
repositories on GitHub written in seven common programming
languages, that is, C, C++, Java, JavaScript, Python, PHP,
and Ruby. These languages have been ranked consistently in
the top 10 languages on GitHub from 2008 to 2018 (based
on the number of repositories from 2008 to 2015 [47], the
number of pull requests from 2014 to 2018 [48], and top
languages from 2014 to 2018 in the ofﬁcial report [49]). Using
775TABLE I: Collected repositories
language # candidates # obtained (%)
C 3,262 2,962 (91%)
C++ 4,219 3,824 (91%)
Java 5,911 5,427 (92%)
JavaScript 9,017 7,960 (88%)
Python 6,606 6,087 (92%)
PHP 3,877 3,388 (87%)
Ruby 2,639 2,359 (89%)
sum 35,531 32,007 (90%)
the GHTorrent dataset1[50], we identify active repositories
for the seven languages with the following criteria [46]: (i)
having more than 500 commits in their entire history (the
same threshold used in previous work [51]), and (ii) having
at least 100 commits in the most active two years to remove
long-term less active repositories and short-term projects that
have not been maintained for long. We determine repositories’
languages based on the GHTorrent information. As mentioned
in Section III, we exclude forked repositories in this study. We
remove repositories that had been recorded in GHTorrent as
forks of other repositories. Note that even though we exclude
such explicit forks, which have been targeted extensively by
related work [13], there can be implicit forks in our dataset.
This could be because repositories were forked outside of
GitHub, for example. Although these implicit forks are not
considered in research on fork-based development [12], [13],
[41], we keep these repositories in this study to investigate the
feasibility of meta-maintenance. With the above procedure,
we obtained the candidate list of repositories for the seven
languages as shown in Table I. From the candidate list, some
repositories were not available because they had been deleted
or made private. Additionally we exclude repositories that
have only one committer in order to remove self-learning
repositories (online judge code, for example). In total, we
obtained more than 32,000 repositories, which is almost 90%
of the candidate repositories.
b) Git blob extraction: From each repository, we ex-
tracted all existing blobs and their ﬁle names using git rev-
list -all -objects andgit cat-file commands.
Only the blobs of source ﬁles with the following ﬁle extensions
are targeted in this study: .c,.h(C),.cc,.cp,.cpp ,
.cx,.cxx ,.c++ ,.hh,.hp,.hpp ,.hxx ,.h++ (C++),
.java (Java), .js (JavaScript), .py (Python), .php (PHP),
and.rb (Ruby). Blobs appearing in multiple repositories are
considered to be seed ﬁles. In total, we obtained 27,994,587
seed ﬁles in our dataset.
c) Stratiﬁed sampling: To understand these seed ﬁles and
their characteristics towards answering our research questions,
we conducted stratiﬁed sampling to enable us to gain insights
into a variety of different scenarios. We hypothesize that
the size of the corresponding seed families is a particularly
important criterion for distinguishing different kinds of seed
1MySQL database dump 2019-02-01 from http://ghtorrent.org/downloads.
html.
Fig. 1: Plot of the number of seed families for each number
of seed ﬁles (log-log scale).
TABLE II: Construction of the stratiﬁed sample
# seed families sample size
common 662 243
sometimes 2,132,141 384
rare 25,861,784 384
sum 27,994,587 1,011
ﬁles. To understand the distribution of size of seed families
across seed ﬁles, we plotted the distribution, cf. Figure 1.
Each dot represents a tuple of <number of seed families,
size of seed family >, e.g., the left-most dot indicates that
there were more than 10 million seed families of size two.
We then divided seed ﬁles into three categories: those that
are part of big seed families (“common”), those are part of
small seed families (“rare”), and an additional category in
between (“sometimes”). Based on visual inspection of the
plot in Figure 1, we set the thresholds at a family size of
at least 331 for common, and at least 28 for sometimes. The
left side of Figure 1 represents small seed families (rare) with
less than 28 instances each and the right side represents large
seed families (common) with more than 330 instances each.
Table II shows the corresponding numbers. The stratum with
a family size of at least 331 contains 662 seed families, the
stratum with a family size of at least 28 (but no more than 330)
contains more than 2 million seed families, and the stratum
with a family size smaller than 28 contains more than 25
million seed families. The goal of our stratiﬁed sampling is to
understand these different groups better. We randomly sampled
a statistically representative number of seed families from each
stratum, ensuring that our conclusions regarding ratios within
each sample would generalize to the entire stratum with a
conﬁdence level of 95% and a conﬁdence interval of 5. The
last column of Table II shows the number of seed families in
each sample, for a total sample size of 1,011.
For the 1,011 seed families, the evolutionary period of
variants within a seed family, measured from the earliest
commit in seed ﬁles to the latest commit in variants, was a
minimum of 0.4 years, a median of 5.5 years, and a maximum
of 18 years.
776V. M ETHOD
We describe our mixed-method procedure including a quan-
titative analysis, a qualitative analysis, and a survey.
A. Quantitative Analysis
To understand the prevalence of seed ﬁles in a large amount
of software development repositories ( RQ1 ), we conduct a
quantitative analysis of our collected dataset and stratiﬁed
sample in terms of existence, status, size, and modiﬁcations
of seed ﬁles. The history of a variant is examined based on
the path of the seed ﬁle. Therefore, variants that have changed
signiﬁcantly in content can be tracked, but variants that have
been renamed or moved are not tracked in this study.
To investigate how variants evolve in different projects
(RQ5 ), we measure the degree of variant evolution in each
family using two metrics: Retention of similarities with seed
ﬁles and Uniqueness of differences with other variants.
Retention: how variants are similar to seeds. For a pair
of a variant vand its seed ﬁle s, we measure their similarity
as follows, similar to a previous study of clone-and-own [3].
Retention f(v,s)=|{⌧(v)\⌧(s)}|
|⌧(v)|
where ⌧(x)represents a set of trigrams of tokens in ﬁle x
ignoring comments and white spaces. To recognize tokens
and comments in source code, we employed lexical analyzers
based on the Ripper library for Ruby and ANTLR4 for the
other six languages. We calculate an average retention value
for all variants Vin a seed family as follows.
Retention (V,s)=P
v2VRetention f(v,s)
|V|
A higher Retention (V,s)means variants are similar to their
seed ﬁles, that is, variants have not been changed largely.
Uniqueness: how variants evolved differently. To measure
the amount of project-speciﬁc changes for each variant, we
calculate the uniqueness of content as follows.
Uniqueness (V,s)=P
v2Vu(v,{s}[V\{v})
|V|
u(v,F)=|{t2⌧(v)|8f2F.t /2⌧(f)}|
|⌧(v)|
The function u(v,F)measures the amount of trigrams only
in a variant vin the family. A higher Uniquness (V,s)value
indicates that the variants are more different from one another.
B. Qualitative analysis
To understand the types of seed ﬁles ( RQ2 ), the relation-
ships among repositories in seed families ( RQ3 ), and the
characteristics of changes for seed ﬁles ( RQ4 ), we manually
annotate seed ﬁles and seed families in our sample, which is
conducted in multiple iterations. In each iteration except for
the last one, three authors independently annotate instancesfrom each stratum using open coding. After each iteration,
the authors discuss the codes that have emerged and how
to distinguish between them. We repeat this process on new
subsets from each stratum until we ﬁnalize the list of codes
and achieve Kappa agreement of at least 0.7 among the three
annotators. One author then annotates the rest of the data.
Since there can be a large number of variants in a seed
family, we annotate up to ﬁve variants per seed family. If
a seed family contains more than ﬁve variants, we conduct
stratiﬁed sampling by selecting the three variants with the
largest number of commits and the two variants with the lowest
number of commits.
C. Survey
To understand the potential of meta-maintenance ( RQ6 ),
we conduct a survey for developer feedback. To ﬁnd meta-
maintenance opportunities, we searched unique commits in
seed families, that is, we identiﬁed commits that appear
only in single repositories. To limit the search space, we
target commits whose commit message contains the keyword
‘ﬁx’, which is considered to be related to ﬁxing bugs. There
are 26, 81, and 135 seed families that contain at least one
unique commit for rare, sometimes, and common samples,
respectively. Again, to limit the search space, seed families
with more than two unique commits are ﬁltered out, which
resulted in 11, 51, and 69 seed families for rare, sometimes,
and common samples, respectively. We manually investigate
these seed families. By checking the latest commits on GitHub,
we found that some repositories applied the identiﬁed unique
commits later by cherry-picking. We also found that some
unique commits are not easily applicable to other repositories
because of the large differences in the histories.
Five cases were selected where the changes were neither too
large nor too complex. The survey was distributed in forums,
issues, or emails of the corresponding projects. As part of the
questionnaire, we asked (a) how important the seed ﬁle was
to the project, (b) what kind of maintenance activities were
the developers interested in regarding the ﬁle, and (c) whether
they would be interested in a meta-maintenance approach. We
received three responses and noticed that due to speciﬁcity of
the ﬁles, only the core contributors of the projects responded
in all cases.
VI. F INDINGS
Here we present our ﬁndings for each research question.
A. Prevalence of Seed Files (RQ1)
a) Seed ﬁle existence: Figure 2a shows the percentages
of repositories that have at least one seed ﬁle. Although the
percentage is relatively low for Java (but still more than 70%),
more than 80% of repositories contain seed ﬁles for the other
languages. Especially for repositories written in C, JavaScript,
PHP, and Python, more than 90% of repositories contain seed
ﬁles. Figure 2b presents the distributions of the number of
different seed ﬁles per repository, for repositories that have at
least one seed ﬁle. Median values are shown in the boxplot. We
77791% 9%87% 13%72% 28%91% 9%93% 7%91% 9%87% 13%
CC++JavaJavaScriptPHPPythonRuby
type
a
anoSeed
Seed
(a) Percentage of repositories with and without seed ﬁles.323
122
32 47354
15 5902000400060008000
c c++ java javascript php python rubySeed_per_Repo
(b) Distribution of the number of seed ﬁles per repository.
Fig. 2: Prevalence of seeds from (a) seed ﬁle existence and (b) the number of seed ﬁles in a repository, per language.
TABLE III: Frequency of variant statuses in our sample
common sometimes rare
dormant 22,937 (18%) 13,290 (26%) 182 (13%)
inactive 83,517 (65%) 17,266 (33%) 671 (47%)unchanged 15,435 (12%) 1,278 (2%) 52 (4%)maintained 7,530 (6%) 20,181 (39%) 518 (36%)
sum 129,419(100%) 52,015(100%) 1,423(100%)
see that repositories contain dozens of seed ﬁles (at median),
which implies there likely exist sets of seed ﬁles commonlyshared by multiple repositories. For C and PHP, whose projectshave more seed ﬁles, we see forked projects from speciﬁcproducts, which should share many seed ﬁles.
b) Status of variants: For the concept of meta-
maintenance, we are interested in only repositories that aremaintaining variants. We distinguish variants based on theirstatuses as follows.
dormant: a variant is in a dormant or an unmaintained
repository. Similar to previous studies [52], [53], we set
one year as a threshold to consider dormant, that is,we consider a repository dormant or unmaintained if therepository does not have commits in 2018.
inactive: a variant does not exist in the main branch (usually
master in GitHub).
unchanged: the seed ﬁle has not been modiﬁed and exists in
the latest commit of the main branch.
maintained: a variant had been changed and exists in the
latest commit of the main branch.
Table III shows the frequencies of the variant statuses in thethree strata of our sample. We see that the majority of variantsare not maintained, 94% for common, 61% for sometimes, and
64% for rare.
c) Types of seed families: Table IV summarizes the
frequencies of seed family types as described below.
not maintained: We observed that some projects recorded in
GHTorrent point to the same repositories even though IDTABLE IV: Frequency of seed family types in our sample
common sometimes rare
not maintained 0 (0%) 48 (13%) 240 (63%)
empty seed 10 (4%) 0 (0%) 0 (0%)zero variance 132 (54%) 163 (42%) 128 (33%)non-zero variance 101 (42%) 173 (45%) 16 (4%)
sum 243(100%) 384(100%) 384(100%)
and/or project names are different. This happens when
repositories re-registered in GitHub. We consider a seedfamily not maintained if there is no maintained variantin the seed family after removing identical repositories,that is, all variants in the seed family are either dormant,inactive, unchanged, or identical.
empty seed: We found some seed ﬁles do not have meaning-
ful contents as source code, such as no line, only a blankline, or only comment lines. We manually identiﬁed thoseﬁles. As seen in Table IV, such empty seed ﬁles appearonly in the common stratum.
zero variance: There is only one maintained variant or the
same changes have been applied to all variants, that is,duplicate variants. We found some variants had been
cherry-picking commits from their origins with differentfrequencies.
non-zero variance: Even after removing duplicate variants,
there are multiple maintained variants in a seed family.
For meta-maintenance, we are only interested in variants thathave evolved independently. Therefore, only seed families ofnon-zero variance are targeted in our study. In the seed fam-
ilies, duplicate variants are removed for the further analyses.Table V shows the number of seed families and the number ofremaining variants in our ﬁltered sample. This sample is usedto answer the following research questions.
778TABLE V: Target data in our sample
# seed families # variants
common 101 897
sometimes 173 1,748
rare 16 47
sum 290 2,692
TABLE VI: Types of Seed Files
library conﬁguration utility other
common 91 5 2 3
sometimes 5 1 157 10
rare 1 1 12 2
Summary : We revealed that seed ﬁles are prevalent. In
more than 70% of the targeted 32,007 repositories in
GitHub, there exists at least one seed ﬁle. Despite the
large amount of seed ﬁles, most of them have not been
maintained nor used in the latest snapshots. However,
there exists some amount of potential variants for
meta-maintenance for each stratum.
B. Types of Seed Files (RQ2)
We achieved Kappa agreement of 0.7 in our annotation.
Our analysis revealed the following four types of ﬁles, with
Table VI showing the number of instances for each code in
each stratum:
library: Seed ﬁles which contain a library (a program that
contains a collection of code used by applications) are
particularly widespread in the common stratum where
they account for 91% of all seed ﬁles that we encountered
during our annotation, indicating that most seed families
in the common stratum are library users. A representative
example is the jQuery library, e.g., in the modxcms-
jp/evolution-jp repository.2
utility functionality: Seed ﬁles which contain utility func-
tionality (a system software for controlling the operation
of a computer, devices, etc.) were predominantly found
in the sometimes stratum where they account for 91% of
the annotated seed ﬁles—coincidentally the same ratio as
library ﬁles in the common stratum. Drivers, such as the
driver for Avance Logic ALS300/ALS300+ soundcards
in the masahir0y/linux repository3are a representative
example for this group of seed ﬁles.
conﬁguration: Conﬁguration ﬁles are much less common as
seed ﬁles, with most of them appearing in the common
strata. The conﬁg.php ﬁle of the contao/core-bundle4
repository can serve as an example.
2https://github.com/modxcms-jp/evolution-jp/blob/0dce7db4/manager/
media/script/jquery/jquery.min.js
3https://github.com/masahir0y/linux/blob/dc4060a5dc25/sound/pci/als300.c
4https://github.com/contao/core-bundle/blob/1373ebc29/src/Resources/
contao/conﬁg/conﬁg.php1 10 100 1000 10000raresometimescommon
Fig. 3: LOC in seed ﬁles, per stratum.
other: We used the code “other” mostly for header ﬁles or
ﬁles containing version information, such as version.php
in the gMagicScott/core.wordpress-mirror repository.5
We also investigated typical ﬁle sizes in each stratum.
Figure 3 shows the corresponding distributions. In general, the
number of lines of code for libraries, which are widespread
in the common stratum, is smaller compared to the other
strata, mostly due to presence of a large number of miniﬁed
JavaScript libraries. The differences between sometimes and
rare strata are negligible.
Summary : We revealed that seed ﬁles which are part
of large seed families are often libraries, whereas seed
ﬁles from medium-sized seed families tend to contain
utility functionality. Files from large seed families tend
to be smaller in terms of number of lines of code than
ﬁles from smaller seed families.
C. Repositories in Seed Families (RQ3)
As documented by previous work [54], GitHub hosts a wide
variety of projects, the characterization of which is beyond
the scope of this paper. Instead, to understand the potential
of meta-maintenance, our focus is on the relationships among
repositories in seed families, i.e., whether there is a connection
among them. Such connections could stem from forking or
copying as well as from the code of one repository using the
code from another repository. We distinguish each repository
in our sample into “related” or “non-related”. In this annota-
tion, we achieved perfect Kappa agreement (i.e., 1.0) among
the three annotators.
related: There is an explicit relationship among repositories,
e.g., one is a fork of another, their names are similar or
identical, or because one mentions the other prominently
in its documentation. The most common example of such
a relationship are the many Linux variants in our sam-
ple. For example, the driver ﬁle gl520sm.c is contained
in the repositories masahir0y/linux6and Whissi/linux-
stable.7The repositories can easily be connected based
on their names, even though only the former contains
the information that it is forked from torvalds/linux. In
5https://github.com/gMagicScott/core.wordpress-mirror/blob/8548899126/
wp-includes/version.php
6https://github.com/masahir0y/linux
7https://github.com/Whissi/linux-stable
779TABLE VII: Relationships among Seed Families
related non-related
common 0 398
sometimes 624 24
rare 40 5
TABLE VIII: Change Types
known library project- tangled other
origin updates speciﬁc updates
common 9 202 96 15 76
sometimes 619 11 11 3 4
rare 34 0 8 0 3
addition, the latter repository states in its description
that it is a mirror of the Linux distribution hosted on
git.kernel.org.8
non-related: On the other hand, many seed families do not
contain any evidence to suggest that there is a connec-
tion among the repositories, apart from using at least
one common ﬁle. For example, the repositories Move-
Lab/tigatrapp-server9and magda-io/magda10both contain
Twitter’s Bootstrap library via a bootstrap.js ﬁle. The
former repository contains a server with which Tigatrapp
(a Spanish citizen science project) apps communicate
whereas the latter contains an open-source software plat-
form designed to assist in all areas of the data ecosystem.
Apart from both repositories using Bootstrap, there is
no apparent connection among the repositories. Note that
both repositories have made one change to their instance
of bootstrap.js since the ﬁles were identical.
Table VII shows that the ratio of related vs. non-related
differs signiﬁcantly between the strata. While all repositories
in our sample from the common stratum were not related, the
vast majority from sometimes and rare were related.
Summary : Repositories which contain seed ﬁles that
are part of large seed families tend to not be related.
In many cases, they are different repositories using the
same library. On the other hand, repositories which
contain seed ﬁles which are part of smaller seed
families tend to be related.
D. Changes for Seed Files (RQ4)
To understand how the repositories might be able to beneﬁt
from meta-maintenance, we investigated the commit histories
of all ﬁles in our sample to characterize the set of changes
that had been applied to them. Our annotation revealed four
categories plus other, and we achieved Kappa agreement of
0.76.
reference to a known origin: For many repositories in our
sample, the origin is obvious—this applies in particular
8https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git
9https://github.com/MoveLab/tigatrapp-server
10https://github.com/magda-io/magdato the various Linux variants. In those cases, changes
that have been applied to seed ﬁles are often the same
commits that have been applied to the origin. We were
often able to detect this directly from the commit meta
information, e.g., when commit author and commit com-
mitter are different. For example, the process.c ﬁle11in
the Ziyann/omap repository attracted 104 commits since
being identical across its seed family, many of which
were committed by Linus Torvalds12and authored by a
contributor of the Ziyann/omap repository.
library updates: Library updates are the most common kind
of change in the common stratum, see Table VIII. An
example is the previously mentioned jQuery library, e.g.,
in the modxcms-jp/evolution-jp13repository. While there
have been 18 commits to this ﬁle since it was identical
across its seed family, the commit messages of these
commits14clearly show the pattern of library updates,
e.g., “Update jQuery 1.11.0 – >1.11.1” and “Update –
jQuery 3.2.1”.
project-speciﬁc changes: The most interesting case for meta-
maintenance are project-speciﬁc changes which are not
library updates or made in reference to a known origin.
As Table VIII shows, we found such ﬁles in all strata. An
example is the jQuery library15in the dmitrykuzmin/chat
repository which has one new commit since being iden-
tical across its seed family with the commit message
“Trying to ﬁx IE issues.”. We argue that such ﬁx attempts
might be relevant to other repositories containing the
same ﬁle. We found project-speciﬁc changes in at least
one quarter of seed families in the common and rare
strata.
tangled updates: In case the commit history contained
changes that could not easily be localized to the ﬁle under
investigation, we applied the code “tangled updates”. In
these cases, meta-maintenance on the basis of ﬁles is
unlikely going to be successful since changes affected
many ﬁles—often hundreds if not thousands. Tangled
updates were not widespread in our sample.
other: For change histories which did not ﬁt any of the
previous categories, we applied the code “other”. An
example are the commits to bootstrap.js16in the sparc-
request/sparc-request repository. All of the four commits
made since the ﬁle was identical across seed families
indicate updates to the copyright information, most of
them simply changing the year. This is unlikely to be
useful for maintenance.
11https://github.com/Ziyann/omap/blob/7c07453808b/arch/powerpc/kernel/
process.c
12https://github.com/torvalds
13https://github.com/modxcms-jp/evolution-jp
14https://github.com/modxcms-jp/evolution-jp/commits/
0dce7db475116f3a35206714e2721bf355f049c2/manager/media/script/jquery/
jquery.min.js
15https://github.com/dmitrykuzmin/chat/blob/fa33c7e/webapp/src/main/
webapp/lib/jquery-2.1.4.min.js
16https://github.com/sparc-request/sparc-request/blob/0eb424aba/app/
assets/javascripts/bootstrap.js
780common sometimes rare0.00.20.40.60.81.0Ratio of Seed Content
(a) Distribution of Retention (V,s ), per stratum.common sometimes rare0.00.20.40.60.81.0Ratio of Unique Content
(b) Distribution of Uniqueness (V,s ), per stratum.
Fig. 4: Evolution of variants from (a) similarities with seed ﬁles and (b) differences with other variants.
Summary : While some variants were updated in ref-
erences to a known origin or as part of regular library
updates, in particular seed ﬁles that are part of large
(common stratum) or small (rare stratum) seed families
also contain a signiﬁcant number of project-speciﬁc
changes which could be useful for meta-maintenance.
E. Uniqueness of Variants (RQ5)
Figure 4a shows the distributions of the Retention values
for each stratum. Their medians are 0.75, 0.75, and 0.71,
for common, sometimes, and rare, respectively. Most variants
include some changes from the seed ﬁle. While the rare
families seem to include more changes, the differences among
the strata are not statistically signiﬁcant. The Wilcoxon Rank
Sum Test results in p=0.267for the rare-sometimes pair,
p=0.065for the sometimes-common pair, and p=0.097for
the rare-common pair.
Figure 4b shows the distributions of the Uniqueness values
for each stratum. The medians are 0.09, 0.01, and 0.07, for
common, sometimes, and rare, respectively. The Wilcoxon
Rank Sum Test shows that sometimes families have sig-
niﬁcantly lower uniqueness than rare and common families
(p=0.005 for the rare-sometimes pair and p< 0.001 for
the sometimes-common pair). The difference between rare and
common families is not signiﬁcant ( p=0.674). The variants
in the common and rare families include more unique changes.
Those unique changes are potentially useful for other projects
in the same family. For the sometimes families, variants tend
to evolve by following the changes in their seed ﬁles but do not
include much unique content. This result conﬁrms the ﬁndings
from our manual investigation (Section VI-D).Summary : Variants in the common and rare families
contain project-speciﬁc changes in terms of unique
tokens, while variants in the sometimes families tend to
share common tokens. Although our analysis provides
the basis for understanding how uniquely variants
evolve, further research is needed to understand seed
ﬁles in terms of evolution and maintenance.
F . Developer Feedback on Meta-Maintenance (RQ6)
We present three cases where we received responses from
developers.
Case Study 1: variants of jQuery.js library. jQuery is
a widely used JavaScript library. Although the latest version in
March 2020 is 3.4.1, some projects had been using older 1.x
versions because of project-speciﬁc reasons. Joomla17is one
such project which had applied bug ﬁxing related to security
issues.18
The survey was completed by an experienced core developer
ofJoomla , who in the comments thanked us for bringing
up this topic. When asked about speciﬁc modiﬁcations to the
same ﬁle in another repository, the respondent revealed that
they are “ Mainly interesting for security reasons ” and gave us
the following detailed comment.
For 3rd party components, we use tools like npm
or composer to update them to the latest version.
Only if we have to support a particular version we
maintain the ﬁles our self and only for security ﬁxes.
This answer reveals an interesting use case for the concept
of meta-maintenance: the adoption of security-related changes
that have already been applied elsewhere. As a previous study
reported, vulnerability issues are not appropriately addressed
in many software development repositories [55]. Aggregating
17https://github.com/joomla/joomla-cms
18https://github.com/joomla/joomla-cms/commits/
a81ada410a5bf6b700a79d432fc5926146ac9f94/media/jui/js/jquery.js
781appropriate ﬁxes and distributing to individual repositories
may support such cases.
Case Study 2: variants of abc_object.cc in Blender
forks. Blender is an open source project for 3D computer
graphics. In the rare families of our sample, there are two
forks: Bforartists19and blender278 .20The former is an
active project merging all the recent commits from the origin
without project-speciﬁc changes, while the latter does not
have commits in the last half year but has project-speciﬁc
changes from before. Both projects maintained the seed ﬁle
abc_object.cc at least in 2018. After forking from the
same content, the former had been changed by 31 commits
and the latter had been changed by 13 commits.
The survey was completed by an experienced core developer
ofBforartists , who claimed that the ﬁle is of high priority (5/5
on the Likert scale). When asked about modiﬁcations to the
same ﬁle in another repository, the response was as follows.
Relevant is the Blender source code, since we regu-
larly merge the newest changes from Blender source
code. We are not interested in another fork with
probably outdated code, or code that conﬂicts with
our changes. ... maintaining code from others is
always problematic. It’s hard enough to keep our
own changes working. We are a fork of Blender, not
a fork of another fork..
These comments point out important future work to make
meta-maintenance a reality. To maintain seed ﬁles, some
forked projects prefer to keep following changes in the original
repository and do not consider applying changes from other
repositories. This is a reasonable approach when centralized
fork models work. We can easily identify repositories that
are only following the original repository—meta-maintenance
appears to be less relevant for them. In addition, we can
consider aggregating project-speciﬁc changes and send them
to the original repositories.
Case Study 3: variants of zlib library. zlib is a li-
brary for data compression, which is widely used in many
projects. We observed a local change which ﬁxes typos in one
repository.21The survey was completed by the author of zlib.
Although the developer was not interested in the suggested
typo ﬁx, he described the potential of applying commits from
other repositories as:
They may have performance or other improvements.
Summary : We learned from developers that sup-
porting changes related to security and performance,
among others, could be a promising use case for meta-
maintenance and is desired by developers. Responses
also point out future work to further understand the
nature of relationships between repositories.
19https://github.com/Bforartists/Bforartists
20https://github.com/tangent-animation/blender278
21https://github.com/radareorg/radare2/commit/
bc3425e73d294cbded877b66f0d60183edb5dd2eVII. D ISCUSSION
Based on our results, we now summarize the open chal-
lenges and barriers that need to be addressed before meta-
maintenance can be fully realized. Then we discuss the limi-
tations of our study.
A. Challenges to Meta-Maintenance
This paper establishes the state-of-the-practice for inves-
tigation of what type of meta maintenance is useful and
under which conditions. To fully realize the potential of meta-
maintenance, further research is required in the follow areas:
•In-depth investigation of clone-and-own relationships in
sets of seed ﬁles . This study only focuses on single ﬁles
as seeds. However, it is natural for software development
projects to reuse a set of ﬁles. We need to develop
techniques to identify seed families by considering a
set of ﬁles, similar to a previous study [3]. During our
manual investigation in RQ6 , we observed that some seed
families consist of sub-groups of repositories. Reposito-
ries in a group evolve similarly, and this results in large
differences in the histories across different sub-groups.
Measuring the similarities of histories (similar to the
analysis in RQ5 ) is a promising and challenging area
for future work.
•Developing a global source code tracking system , to
understand relationships of repositories and the histories
of seed ﬁles. This could be similar to Google’s monolithic
SCM system [14], [15], but in the ecosystem of open
source software projects. The ﬁndings from RQ1 reveal
that many repositories could be connected within this
global system.
•Techniques to identify useful changes between variants .
There exist related techniques for fork-based develop-
ment [12], [56] and software product lines [57]. Ex-
tending existing characterization studies, e.g., repeated
bug ﬁxes [58] to clone-and-own instances may provide
further insights to develop such techniques. As learned
from the ﬁndings in RQ6 , changes related to security
and performance are promising types to be identiﬁed as
useful changes.
•Tool support for meta-maintenance . Tools to help devel-
opers ﬁnd speciﬁc changes and maintain code automat-
ically could be practically useful. Such tools could be
based on push and pull models to aggregate and distribute
useful changes to the ecosystem.
B. Threats to Validity
Threats to construct validity exist in our data collection
procedure. Our criteria for selecting repositories may have
ignored recent active projects and projects worked on by
a single developer. Although we categorized repositories by
programming language based on GHTorrent information, the
information can be inaccurate. Further exploration to develop
better criteria is needed. Threats to external validity exist
in our repository preparation. Although we analyzed a large
amount of repositories on GitHub, we cannot generalize our
782ﬁndings to industrial projects nor FLOSS in general; some
FLOSS repositories are hosted outside of GitHub, e.g., on
GitLab or private servers. In addition, empirical studies are
needed for other programming languages. To mitigate threats
toreliability , we prepare an online appendix of our studied
dataset with associated information (see Section IX).
VIII. C ONCLUSION
To explore the potential of meta-maintenance, we con-
ducted an exploratory study with (i) a quantitative analysis of
27,994,587 seed ﬁles from 32,007 Git repositories to establish
the prevalence of seed ﬁles, the extent to which seeds evolve,
and the uniqueness of seeds; (ii) a qualitative analysis of a
stratiﬁed sample of 1,011 seed ﬁles to determine the kinds of
seeds, the relationships among seed families, and main drivers
for changes in the variants; and (iii) a survey for developer
feedback.
Our work shows the potential of meta-maintenance with an
extensive type of changes identiﬁed other than simple forking.
Based on this work which has established the prevalence of
seeds in GitHub projects, their multiple categories of seed
variants, uniqueness and practical useful potential of meta-
maintenance, there are many open avenues and challenges for
future work: understanding how to manage all seed variants
in seed families, further studies of what are useful changes,
and tool support to extract speciﬁc needs of a seed family to
query other repositories, to name a few.
IX. D ATAAVA I L A B I L I T Y
Our online appendix contains the list of the studied 32,007
repositories on GitHub, the list of the targeted 401,610,677
ﬁles, the results of the qualitative and quantitative analyses,
and survey material. The appendix is available at https://github.
com/NAIST-SE/MetaMaintenancePotential.
ACKNOWLEDGMENT
This work has been supported by JSPS KAKENHI
Grant Numbers JP16H05857, JP18KT0013, JP18H04094,
JP20K19774, and JP20H05706.
REFERENCES
[1]W. Fenske, J. Meinicke, S. Schulze, S. Schulze, and G. Saake, “Variant-
preserving refactorings for migrating cloned products to a product line,”
inProceedings of the 24th IEEE International Conference on Software
Analysis, Evolution and Reengineering , SANER, 2017, pp. 316–326.
[2]Y. Dubinsky, J. Rubin, T. Berger, S. Duszynski, M. Becker, and K. Czar-
necki, “An exploratory study of cloning in industrial software product
lines,” in Proceedings of the 17th European Conference on Software
Maintenance and Reengineering , CSMR, 2013, pp. 25–34.
[3]T. Ishio, Y. Sakaguchi, K. Ito, and K. Inoue, “Source ﬁle set search for
clone-and-own reuse analysis,” in Proceedings of the 14th International
Conference on Mining Software Repositories , MSR, 2017, pp. 257–268.
[4]C. K. Roy, J. R. Cordy, and R. Koschke, “Comparison and evaluation
of code clone detection techniques and tools: A qualitative approach,”
Sci. Comput. Program. , vol. 74, no. 7, pp. 470–495, May 2009.
[5]J. Ossher, H. Sajnani, and C. Lopes, “File cloning in open source java
projects: The good, the bad, and the ugly,” in Proceedings of the 27th
IEEE International Conference on Software Maintenance , ICSM, 2011,
pp. 283–292.[6]R. Koschke and S. Bazrafshan, “Software-clone rates in open-source
programs written in c or c++,” in Proceedings of the 23rd IEEE Interna-
tional Conference on Software Analysis, Evolution, and Reengineering ,
SANER, vol. 3, 2016, pp. 1–7.
[7]C. V. Lopes, P. Maj, P. Martins, V. Saini, D. Yang, J. Zitny, H. Sajnani,
and J. Vitek, “Déjàvu: A map of code duplicates on github,” Proceed-
ings of the ACM on Programming Languages , vol. 1, OOPSLA, pp.
84:1–84:28, 2017.
[8]M. Gharehyazie, B. Ray, and V. Filkov, “Some from here, some from
there: Cross-project code reuse in github,” in Proceedings of the 14th
International Conference on Mining Software Repositories , MSR, 2017,
pp. 291–301.
[9]B. Ray and M. Kim, “A case study of cross-system porting in forked
projects,” in Proceedings of the ACM SIGSOFT 20th International
Symposium on the Foundations of Software Engineering , FSE, 2012,
pp. 53:1–53:11.
[10] G. Gousios, M. Pinzger, and A. v. Deursen, “An exploratory study
of the pull-based software development model,” in Proceedings of the
36th International Conference on Software Engineering , ICSE, 2014,
pp. 345–355.
[11] G. Gousios, M.-A. Storey, and A. Bacchelli, “Work practices and
challenges in pull-based development: The contributor’s perspective,”
inProceedings of the 38th International Conference on Software Engi-
neering , ICSE, 2016, pp. 285–296.
[12] S. Zhou, c. St ˘anciulescu, O. Leßenich, Y. Xiong, A. W ˛ asowski, and
C. Kästner, “Identifying features in forks,” in Proceedings of the 40th
International Conference on Software Engineering , ICSE, 2018, pp.
105–116.
[13] S. Zhou, B. Vasilescu, and C. Kästner, “What the fork: A study of
inefﬁcient and efﬁcient forking practices in social coding,” in Proceed-
ings of the 27th ACM Joint Meeting on European Software Engineering
Conference and Symposium on the Foundations of Software Engineering ,
ESEC/FSE , 2019, pp. 350–361.
[14] R. Potvin and J. Levenberg, “Why google stores billions of lines of code
in a single repository,” Commun. ACM , vol. 59, no. 7, pp. 78–87, Jun.
2016.
[15] C. Sadowski, E. Aftandilian, A. Eagle, L. Miller-Cushon, and C. Jaspan,
“Lessons from building static analysis tools at google,” Communications
of the ACM , vol. 61, no. 4, pp. 58–66, Mar. 2018.
[16] C. K. Roy, J. R. Cordy, and R. Koschke, “Comparison and evaluation
of code clone detection techniques and tools: a qualitative approach,”
Science of Computer Programming , vol. 74, no. 7, pp. 470–495, May
2009.
[17] T. Kamiya, S. Kusumoto, and K. Inoue, “CCFinder: a multilinguistic
token-based code clone detection system for large scale source code,”
IEEE Transactions on Software Engineering , vol. 28, no. 7, pp. 654–670,
Aug. 2002.
[18] L. Jiang, G. Misherghi, Z. Su, and S. Glondu, “DECKARD: Scalable
and accurate tree-based detection of code clones,” in Proceedings of the
29th International Conference on Software Engineering , ICSE, 2007,
pp. 96–105.
[19] H. A. Nguyen, T. T. Nguyen, N. H. Pham, J. M. Al-Kofahi, and
T. N. Nguyen, “Accurate and efﬁcient structural characteristic feature
extraction for clone detection,” in Proceedings of the 12th Interna-
tional Conference on Fundamental Approaches to Software Engineering ,
FASE, 2009, pp. 440–455.
[20] Y. Sasaki, T. Yamamoto, Y. Hayase, and K. Inoue, “Finding ﬁle clones
in FreeBSD Ports Collection,” in Proceedings of the 7th IEEE Working
Conference on Mining Software Repositories , MSR, 2010, pp. 102–105.
[21] J. R. Cordy and C. K. Roy, “The nicad clone detector,” in Proceedings
of the 19th IEEE International Conference on Program Comprehension ,
ICPC, 2011, pp. 219–220.
[22] H. Sajnani, V. Saini, J. Svajlenko, C. K. Roy, and C. V. Lopes,
“SourcererCC: Scaling code clone detection to big-code,” in Proceedings
of the 38th International Conference on Software Engineering , ICSE,
2016, pp. 1157–1168.
[23] A. Hemel and R. Koschke, “Reverse Engineering Variability in Source
Code Using Clone Detection: A Case Study for Linux Variants of
Consumer Electronic Devices,” in Proceedings of the 19th IEEE Working
Conference on Reverse Engineering , WCRE, 2012, pp. 357–366.
[24] R. Koschke and S. Bazrafshan, “Software-clone rates in open-source
programs written in C or C++,” in Proceedings of the 10th International
Workshop on Software Clones , IWSC, 2016, pp. 1–7.
783[25] Y. Dang, D. Zhang, S. Ge, R. Huang, C. Chu, and T. Xie, “Transfer-
ring code-clone detection and analysis to practice,” in Proceedings of
the 39th International Conference on Software Engineering: Software
Engineering in Practice Track , ICSE-SEIP, 2017, pp. 53–62.
[26] J. Rubin, K. Czarnecki, and M. Chechik, “Managing cloned variants:
A framework and experience,” in Proceedings of the 17th International
Software Product Line Conference , SPLC, 2013, pp. 101–110.
[27] V. Bauer and B. Hauptmann, “Assessing Cross-Project Clones for
Reuse Optimization,” in Proceedings of the International Workshop on
Software Clones , IWSC, 2013, pp. 60–61.
[28] T. Ishihara, K. Hotta, Y. Higo, H. Igaki, and S. Kusumoto, “Inter-project
functional clone detection toward building libraries – an empirical study
on 13,000 projects,” in Proceedings of the 19th Working Conference on
Reverse Engineering , WCRE, 2012, pp. 387–391.
[29] L. Luo, J. Ming, D. Wu, P. Liu, and S. Zhu, “Semantics-based
obfuscation-resilient binary code similarity comparison with applica-
tions to software plagiarism detection,” in Proceedings of the 22nd
ACM SIGSOFT International Symposium on Foundations of Software
Engineering , FSE, 2014, pp. 389–400.
[30] K. Chen, P. Liu, and Y. Zhang, “Achieving Accuracy and Scalability
Simultaneously in Detecting Application Clones on Android Markets,”
inProceedings of the 36th International Conference on Software Engi-
neering , ICSE, 2014, pp. 175–186.
[31] J. Davies, D. M. German, M. W. Godfrey, and A. Hindle, “Software
bertillonage: Finding the provenance of an entity,” in Proceedings of
the 8th Working Conference on Mining Software Repositories , MSR,
2011, pp. 183–192.
[32] ——, “Software bertillonage: Determining the provenance of software
development artifacts,” Empirical Software Engineering , vol. 18, pp.
1195–1237, Dec. 2013.
[33] M. W. Godfrey and L. Zou, “Using Origin Analysis to Detect Merging
and Splitting of Source Code Entities,” IEEE Transactions on Software
Engineering , vol. 31, no. 2, pp. 166–181, Feb. 2005.
[34] D. Steidl, B. Hummel, and E. Juergens, “Incremental Origin Analysis
of Source Code Files,” in Proceedings of the 11th Working Conference
on Mining Software Repositories , MSR, 2014, pp. 42–51.
[35] N. Kawamitsu, T. Ishio, T. Kanda, R. G. Kula, C. De Roover, and K. In-
oue, “Identifying source code reuse across repositories using LCS-based
source code similarity,” in Proceedings of the 14th International Working
Conference on Source Code Analysis and Manipulation , SCAM, 2014,
pp. 305–314.
[36] D. Spinellis, “A repository of unix history and evolution,” Empirical
Software Engineering , vol. 22, no. 3, pp. 1372–1404, Aug. 2016.
[37] D. M. German, M. D. Penta, Y.-G. Guéhéneuc, and G. Antoniol, “Code
siblings: Technical and legal implications of copying code between
applications,” in Proceedings of the 6th Working Conference on Mining
Software Repositories , MSR, 2009, pp. 81–90.
[38] J. Krinke, N. Gold, Y. Jia, and D. Binkley, “Distinguishing copies from
originals in software clones,” in Proceedings of the 4th International
Workshop on Software Clones , IWSC, 2010, pp. 41–48.
[39] ——, “Cloning and copying between GNOME projects,” in Proceedings
of the 7th IEEE Working Conference on Mining Software Repositories ,
MSR, 2010, pp. 98–101.
[40] S. Stanciulescu, S. Schulze, and A. Wasowski, “Forked and integrated
variants in an open-source ﬁrmware project,” in Proceedings of the 31st
IEEE International Conference on Software Maintenance and Evolution ,
ICSME, 2015, pp. 151–160.
[45] S. Chacon and B. Straub, Pro Git , 2nd ed. Berkely, CA, USA: Apress,
2014.[41] L. Ren, S. Zhou, C. KÃd’stner, and A. WÄ ˇEsowski, “Identifying
redundancies in fork-based development,” in Proceedings of the 26th
IEEE International Conference on Software Analysis, Evolution and
Reengineering , SANER, 2019, pp. 230–241.
[42] D. Strüber, M. Mukelabai, J. Krüger, S. Fischer, L. Linsbauer, J. Mar-
tinez, and T. Berger, “Facing the truth: Benchmarking the techniques
for the evolution of variant-rich systems [research],” in Proceedings of
the 23rd International Systems and Software Product Line Conference
- Volume A , SPLC, 2019, pp. 26:1–26:12.
[43] J. Jang, A. Agrawal, and D. Brumley, “ReDeBug: Finding unpatched
code clones in entire OS distributions,” in Proceedings of the 33rd IEEE
Symposium on Security and Privacy , SP, 2012, pp. 48–62.
[44] H. Li, H. Kwon, J. Kwon, and H. Lee, “CLORIFI: software vulnerability
discovery using code clone veriﬁcation,” Concurrency and Computation:
Practice and Experience , vol. 28, no. 6, pp. 1900–1917, Apr. 2016.
[46] H. Hata, C. Treude, R. G. Kula, and T. Ishio, “9.6 million links in source
code comments: Purpose, evolution, and decay,” in Proceedings of the
41st International Conference on Software Engineering , ICSE, 2019, pp.
1211–1221.
[47] A. La, “Language Trends on GitHub – The GitHub Blog,” https://
blog.github.com/2015-08-19-language-trends-on-github/, 2015, [Online;
accessed Aug 2018].
[48] F. Beuke, “Github Language Statistics – GitHut 2.0,” https://madnight.
github.io/githut/, [Online; accessed Aug 2019].
[49] GitHub, “The State of the Octoverse 2018,” https://octoverse.github.
com/, 2018, [Online; accessed Aug 2019].
[50] G. Gousios, “The ghtorent dataset and tool suite,” in Proceedings of the
10th Working Conference on Mining Software Repositories , MSR, 2013,
pp. 233–236.
[51] M. Aniche, G. Bavota, C. Treude, M. A. Gerosa, and A. Deursen, “Code
smells for model-view-controller architectures,” Empirical Software En-
gineering , vol. 23, no. 4, pp. 2121–2157, Aug. 2018.
[52] J. L. C. Izquierdo, V. Cosentino, and J. Cabot, “An empirical study on
the maturity of the eclipse modeling ecosystem,” in Proceedings of the
ACM/IEEE 20th International Conference on Model Driven Engineering
Languages and Systems , MODELS, 2017, pp. 292–302.
[53] J. Coelho and M. T. Valente, “Why modern open source projects fail,”
inProceedings of the 11th Joint Meeting on Foundations of Software
Engineering , ESEC/FSE, 2017, pp. 186–196.
[54] N. Munaiah, S. Kroh, C. Cabrey, and M. Nagappan, “Curating GitHub
for engineered software projects,” Empirical Software Engineering ,
vol. 22, no. 6, pp. 3219–3253, Dec. 2017.
[55] R. G. Kula, D. M. German, A. Ouni, T. Ishio, and K. Inoue, “Do develop-
ers update their library dependencies?” Empirical Software Engineering ,
vol. 23, no. 1, pp. 384–417, Feb. 2018.
[56] L. Ren, “Automated patch porting across forked projects,” in Proceed-
ings of the 27th ACM Joint Meeting on European Software Engineering
Conference and Symposium on the Foundations of Software Engineering ,
ESEC/FSE, 2019, pp. 1199–1201.
[57] T. Pfofe, T. Thüm, S. Schulze, W. Fenske, and I. Schaefer, “Synchro-
nizing software variants with variantsync,” in Proceedings of the 20th
International Systems and Software Product Line Conference , SPLC,
2016, pp. 329–332.
[58] R. Yue, N. Meng, and Q. Wang, “A characterization study of repeated
bug ﬁxes,” in Proceedings of the 33rd IEEE International Conference
on Software Maintenance and Evolution , ICSME, 2017, pp. 422–432.
784