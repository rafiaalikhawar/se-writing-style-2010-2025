ACHyb: A HybridAnalysis Approachto Detect
Kernel AccessControl Vulnerabilities
Yang Hu
The Universityof Texasat Austin
Austin, Texas,USA
huyang@utexas.eduWenxi Wang
The Universityof Texasat Austin
Austin, Texas,USA
wenxiw@utexas.eduCasen Hunger
The Universityof Texasat Austin
Austin, Texas,USA
casen.h@utexas.edu
RileyWood
The Universityof Texasat Austin
Austin, Texas,USA
riley.wood@utexas.eduSarfraz Khurshid
The Universityof Texasat Austin
Austin, Texas,USA
khurshid@ece.utexas.eduMohitTiwari
The Universityof Texasat Austin
Austin, Texas,USA
tiwari@austin.utexas.edu
ABSTRACT
Access control is essential for the Operating System (OS) secu-
rity. Incorrect implementation of access control can introduce new
attack surfaces to the OS, known as Kernel Access Control Vulner-
abilities (KACVs). To understand KACVs, we conduct our study on
therootcausesandthesecurityimpactsofKACVs. Regardingthe
complexity of the recognized root causes, we particularly focus on
two kinds of KACVs, namely KACV-M(due to missing permission
checks) and KACV-I(due tomisusingpermission checks). We find
that over 60% of these KACVs are of critical, high or medium se-
curityseverity,resultinginavarietyofsecuritythreatsincluding
bypasssecuritychecking,privilegedescalation,etc.However,exist-
ingapproachescanonlydetect KACV-M.Thestate-of-the-art KACV-M
detector called PeXis a static analysis tool, which still suffers from
extremelyhigh false-positive rates.
In this paper, we present ACHyb, a precise and scalable approach
to reveal both KACV-MandKACV-I.ACHybis a hybrid approach,
which first applies static analysis to identify the potentially vulner-
able paths and then applies dynamic analysis to further reduce the
false positives of the paths. For the static analysis, ACHybimproves
PeXin both the precision and the soundness, using the interface
analysis,callsitedependenceanalysisandconstraint-basedinvari-
ant analysis with a stronger access control invariant. For the dy-
namicanalysis, ACHybutilizesthegreyboxfuzzingtoidentifythe
potential KACVs. In order to improve the fuzzing efficiency, ACHyb
adoptsournovelclustering-basedseeddistillationapproachtogen-
eratehigh-qualityseedprograms.Ourexperimentalresultsshow
thatACHybreveals 76 potential KACVs in less than 8 hours and
22ofthemareKACVs(19 KACV-Mand3KACV-I).Incontrast, PeX
reveals 2,088 potentialKACVs in more than 11hours, and only 14
ofthemareKACVs(all KACV-M).Furthermore, ACHybsuccessfully
uncovers 7 new KACVs, and 2 of them (1 KACV-Mand 1KACV-I)
have been confirmedbykernel developers.
Permissionto make digitalor hard copies of allorpart ofthis work for personalor
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
onthefirstpage.Copyrights forcomponentsofthisworkownedbyothersthanthe
author(s)mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,or
republish,topostonserversortoredistributetolists,requirespriorspecificpermission
and/or a fee. Request permissions from permissions@acm.org.
ESEC/FSE â€™21, August 23Å›28,2021, Athens,Greece
Â©2021 Copyright heldby the owner/author(s). Publicationrightslicensed to ACM.
ACM ISBN 978-1-4503-8562-6/21/08...$15.00
https://doi.org/10.1145/3468264.3468627CCS CONCEPTS
Â·Security and privacy â†’Operating systems security ;Soft-
ware securityengineering .
KEYWORDS
Program Analysis,Access Control, Operating System
ACMReference Format:
Yang Hu, Wenxi Wang, Casen Hunger, Riley Wood, Sarfraz Khurshid,
and Mohit Tiwari. 2021. ACHyb: A Hybrid Analysis Approach to Detect Ker-
nel Access Control Vulnerabilities. In Proceedings of the 29th ACM Joint Eu-
ropean Software Engineering Conference and Symposium on the Foundations
ofSoftwareEngineering(ESEC/FSEâ€™21),August23Å›28,2021,Athens,Greece.
ACM,NewYork,NY,USA, 12pages.https://doi.org/10.1145/3468264.3468627
1 INTRODUCTION
Access control [ 48] is a fundamental and indispensable security
mechanism for the OS kernel. It secures the resources in the OS by
blocking the accesses which violate authorization rules. The Linux
kernelprovidesseveralaccesscontrolmodules,includingAccess
Control List (ACL) [ 15], Linux Capabilities [ 23], Linux Security
Module (LSM) [ 51], etc. Thanks to these modules, the Linux kernel
has been appliedinmanysecurity sensitive environments [ 14].
Access control provides a security guarantee to the privileged
functions (i.e., the kernel functions implementing the security criti-
cal kernel functionalities), which ensures that privileged functions
can be called only when the caller/user has the permission. This is
usuallyachievedthroughthe accesscontroldecision returnedbythe
permissioncheck (i.e.,thekernelfunctionverifyingifthepermis-
sionsgranted tothecaller/userareconsistent withthecaller/user
operations). The security guarantee is realized in two steps: 1) gen-
erating an access control decision via a permission check before
calling a privileged function, and 2) enforcing the access control
decision in the control flow so that the privileged function will not
becallediftheaccesscontroldecisionisdenied.However,attackers
could break the security guarantee, if the access control is incor-
rectlyimplementedintheabovetwosteps.Thissecurityissueis
knownas the KernelAccess ControlVulnerability(KACV).
To understand KACVs, we conduct an empirical study in this
papertolearntherootcausesandthesecurityimpactofKACVs.
We firstcollected101 KACVs fromthe National VulnerabilityData-
base [40]. Aftermanual inspections, weclassifyKACVs intothree
categories based on our identified three root causes. Given the
316
ESEC/FSE â€™21, August 23â€“28, 2021,Athens,Greece Yang Hu,WenxiWang,Casen Hunger, Riley Wood, Sarfraz Khurshid,andMohitTiwari
complexityofonerootcause,inthispaper,weonlyfocusontwo
categories, namely KACV-Mwhich is due to missing permission
checks, and KACV-Iwhich is due to misusing permission checks.
According to the Common Vulnerability Scoring System (CVSS),
24.4% of the KACV-MandKACV-Iwere scored as high or critical
security severity, and 38.8% were scored as the medium severity. In
addition, our study found that KACV-MandKACV-Icause a variety
ofsecuritythreats,includingbypasssecuritychecking,privileged
escalation, denialofservices, etc.
Tothebestofourknowledge,existingapproachescanonlydetect
KACV-M,andnoworkhasbeenproposedtodetect KACV-I.Zhang
et al. [62] propose a static analysis tool called PeX, which is the
state-of-the-art KACV-Mdetector.PeXconducts its static analysis in
three stepsincluding 1)the permission check identification,2)the
privilegedfunctionidentification,and3)theinvariantanalysisover
the permission checks and privileged functions to uncover KACVs.
To identify permission checks, PeXrequires users to provide an
incomplete list of permission checks. It then performs program
slicing[28]toidentifythewrappersoftheinitiallyprovidedper-
missionchecksasthenewpermissionchecks.Next, PeXfindsan
over-approximation of the privileged functions with a control-flow
analysis to collect the kernel functions which always execute after
permission checks. Last, it performs a control-flow based invariant
analysistosearchforthepotentiallyvulnerablepathswhereapriv-
ilege function is not preceded by any permission checks. However,
PeXsuffersfromsignificantfalse-positiveratesduetothelimitation
ineachstep.First,thepermissioncheckidentificationisunsound
especiallywhentheuser-providedpermissioncheckslackdiversity.
Second,theprivilegedfunctionidentificationisimprecisedueto
theweakover-approximation. Third,theinvariantanalysis isalso
imprecise dueto the weakinvariant.
Tomitigate the limitations of PeX, we present a precise, scalable
KACV detector called ACHybwhich is capable of detecting both
KACV-MandKACV-I.ACHybis ahybridanalysis approach, which
first applies static analysis to identify the potentially vulnerable
paths and then applies dynamic analysis to further reduce the false
positives of the paths. For the static analysis, ACHybfollows the
three steps of PeX, but with its own improvements for each step to
enhanceboththeprecisionandthesoundness.Forpermissioncheck
identification, ACHybperforms a semi-automated interface analysis
which is a soundy(i.e., mostly sound [ 32]) approach. For privileged
functionidentification,insteadofusingcontrol-flowanalysisas PeX,
ACHybperforms our proposed callsite dependency analysis which is
a data-flow analysis that could significantly improve the precision.
Forinvariantanalysis, ACHybproposesastrongerinvariantandper-
formsaconstraint-basedanalysistochecktheinvariant.Toimprove
the efficiency, instead of conducting the standard inter-procedural
analysis,ACHybconducts the lightweight intra-procedural analysis
byexploitingthe features ofaccess control.
Moreover,instead ofrequestinghuman efforttodo themanual
inspection as PeX,ACHybapplies dynamic analysis to reduce the
false positives of the potentially vulnerable paths identified. The
ideaistoidentifythefeasiblepotentiallyvulnerablepathsinwhich
theaccesscontroldecisionsareeithermissing(potential KACV-M)or
denied (potential KACV-I). To achieve this, ACHybinjects invariant
checksonthepotentiallyvulnerablepathsandconductsgreybox
fuzzingtotriggerthesechecks.Toimprovethefuzzingefficiency,ACHybadopts our novel clustering-based seed distillation approach
to generatehigh-qualityseedprograms.
For static analysis, we implement ACHybon top of the LLVM
pass framework [ 45]. For dynamic analysis,we build ACHybbased
onthegreyboxfuzzercalled Syzkaller [57].Weperformanem-
pirical evaluation of ACHybon the Linux kernel v4.18.5. As a result,
ACHybreports 76 potential KACVs, 22 of which are KACVs includ-
ing19KACV-Mand3KACV-I.Incontrast, PeXreports2,088potential
KACVs, 14 of which are KACV-M. Besides, the KACVs detected by
ACHybcontain all the KACVs detected by PeX. We report 7 new
KACVs (5 KACV-Mand 2KACV-I) to kernel developers. By the time
of the paper publication, 2 new KACVs (1 KACV-Mand 1KACV-I)
havebeenconfirmed.Theresultsshowthat ACHybisnotonlymore
precisethan PeX,butalsocapableofdetectingnewKACVs.Inaddi-
tion,ACHybtakes less than 8 hours to detect theKACVs while PeX
takesmorethan11hours,whichshowsthat ACHybismoreefficient
thanPeX. The source code of ACHyband the dataset of our study
arepubliclyavailableat https://github.com/githubhuyang/achyb .
The contributionsofthis paper are:
â€¢Study.We did an empirical study on KACVs mainly in two
aspects: the rootcauses andthe security impactsof KACVs.
â€¢Approach. We present ACHyb, which combines static and
dynamicanalysistodetectboth KACV-MandKACV-Iprecisely
and efficiently. To the best of our knowledge, ACHybis the
firsttoolthat iscapableof detecting KACV-I.
â€¢Implementation. Weimplement ACHybontopofthe LLVM
andSyzkaller withabout5,000 linesof code.
â€¢Empirical Evaluation. Wedidanempiricalevaluationof
ACHybon the Linux kernel v4.18.5 The experimental results
show that ACHybis more precise and scalable than the state-
of-the-arttool PeX.
â€¢PracticalImpacts ACHybisabletodetect7newKACVs,2
ofwhichhave been confirmedbythe kernel developers.
2 A STUDYON KACVS
WestudytheKACVsmainlyintwoaspects:therootcausesandthe
securityimpactofKACVs.InordertogetKACVs,wefirstcollectall
the CVE reports related to KACVs from the National Vulnerability
Database [ 40]. We use the cve-search tool [11] to find the CVE
reports that contain the keywords related to the access control,
suchasÅ‚ACLÅ¾,Å‚capabilityÅ¾,Å‚permissionÅ¾,etc.Wefilteredoutthe
old CVE reports on the kernel version lower than v2.6, since we
want to focus on the KACVs in the newer kernel versions. As a
result,101CVEreportswerecollected.Fig. 1ashowsthenumber
ofCVEreportsrelatedtotheKACVsintherecent10years.Wecan
observe that from 4 to 18 KACVs were reported each year since
2010. Next, we extract the key information from the collected CVE
reports including the vulnerability descriptions,the CVSS ratings
(version3.0), andthe patchesthat fixthe KACVs.
We manually inspect the vulnerability descriptions and patches
in our collected CVE reports to identify the root causes of the
KACVs. As a result, we classify the KACVs into three categories
basedontheidentifiedrootcauses,asshowninFig. 1b.Thefirst
categoryiscalled KACV-M,whichreferstotheKACVsdueto miss-
ing permission checks . The secondcategory iscalled KACV-I, which
referstotheKACVsdueto misusingpermissionchecks .Thethird
317ACHyb: A Hybrid Analysis Approachto DetectKernelAccess Control Vulnerabilities ESEC/FSE â€™21, August 23â€“28, 2021,Athens,Greece
2009
2010
2011
2012
2013
2014
2015
2016
2017
2018
2019
2020
2021
Year
0
2
4
6
8
10
12
14
16
18# KACV
(a)KACVcounting across years
KACV-M
30.7%
KACV-I17.8%KACV-S 51.5% (b) Root causes
Low
36.7%
Medium38.8%High
22.4%Critical
2.0% (c) SeverityinCVSS
Bypass
44.9%
 Privilege
Escalation26.5%DoS
18.4%Information
  Leakage
6.1%Others
4.1% (d)Securitythreats
Figure 1:Statisticalresults ofour KACV study.
1/* fs/namespace.c in the Linux kernel v2.6.21 */
2static int do_change_type(...) {
3...
4// Missing the access control decision.
5/* Patch:
6 if (!capable(CAP_SYS_ADMIN))
7 return -EPERM;*/
8...
9// Privileged function
10change_mnt_propagation(m, type);
11...
12}
Figure 2:Anexample of KACV-M.
category is called KACV-S, which refers to the KACVs due to incor-
rectinternalaccesscontrolstates .Thepercentageof KACV-M,KACV-I,
andKACV-Sis30.7%,17.8%,and51.5%,respectively.Duetothecom-
plexityoftheinternalaccesscontrolstatesandthestatetransitions,
we leave KACV-Sdetection as our further research work. In this
paper,weonlyfocusonstudyinganddetecting KACV-MandKACV-I.
Note that, to the best of our knowledge, no existing work has been
proposedto detect KACV-I.
Weshowtwoexamplesof KACV-MandKACV-I,respectively.Fig.
2showsaKACV-Mexample.Obviously,thefunction do_change_type
missescallingthefunction capabletocheckifthecallerhasthe
permission (i.e., CAP_SYS_ADMIN capability) to call the privileged
functionchange_mnt_propagation (line10).Fig. 3showsaKACV-I
example.Thefunction vfs_dedupe_file_range callsthepermis-
sion checkfunction capabletoqueryif thecaller hasthepermis-
sion (i.e., CAP_SYS_ADMIN capability) to call the privileged func-
tion stored in the function pointer dedupe_file_range (line 16).
However,dueto the incorrect usage of the access controldecision
(is_admin ,line12),thereexistsafeasiblepathwheretheprivileged
function is called when the access control decision is false(i.e.,
denied).
Fig.1cshowsthevulnerabilityseverityof KCAV-MandKACV-I
which was measured in CVSS v3.0 ratings. 24.4% of the KCAV-M
andKACV-Iwere scored as high or critical severity, and 38.8%
were scored as the medium severity. Fig. 1dshows the statistics
of the security threats caused by KCAV-MandKACV-I, based on
the CVE reports. The most frequent security threat is bypassing
securitychecking(44.9%);thesecondfrequentthreatistheprivilege
escalation (26.5%); followed by the denial of service (18.4%); the
nextistheinformationleakage(6.1%).Thedatashowsthat KACV-M
andKACV-IhaveprofoundsecurityimpactsontheLinuxkernel .The1/* fs/read_write.c in the Linux kernel v4.9 */
2intvfs_dedupe_file_range(...) {
3// Direct callsite to a permission check
4boolis_admin = capable(CAP_SYS_ADMIN);
5// Direct callsite to a non-privileged funtion
6ret = clone_verify_area(...);
7...
8for(...) { // condition C1
9 ...
10 if(...) { // condition C2
11 ...
12 }else if (!(is_admin||...)) { //incorrect
condition C3
13 ...
14 }else{
15 // Indiret callsite to a privileged function
16 deduped = dst_file->f_op->dedupe_file_range(...)
;
17 ...
18 }
19}
20}
Figure 3:Anexample of KACV-I.
goalofthispaper istoproposeapreciseandscalable approachto
detectKACV-MandKACV-I.
3 METHODOLOGY
3.1 Overviewof ACHyb
Theoverviewof ACHybisshowninFig. 4.Theinputof ACHybisthe
Linux kernel under examination encoded in LLVM Intermediate
Representation(IR);theoutputisthedetectedKACVs( KACV-Mor
KACV-I).ACHybiscomposedoftwophases:thestaticanalysisphase
(left part of Fig. 4) and the dynamic analysis phase (right part of
Fig.4).ThestaticphasefirstlytakesinthekernelIRandoutputs
the potentially vulnerable paths, while the dynamic phase reduces
false positives ofthosepathsandoutputs the KACVs.
Specifically, in the static analysis phase, ACHybperforms a semi-
automated interface analysis to identify the permission checks
(Section3.2.1). It then conducts a callsite dependency analysis to
identify the privileged functions (Section 3.2.2). Finally, ACHybpro-
poses a stronger access control invariant over the detected permis-
sion checks and privileged functions, and performs a constraint-
based invariant analysis to get the potentially vulnerable paths
(Section3.2.3). In the dynamic analysis phase, ACHybfirstly injects
run-time invariant checks on these potentially vulnerable paths
318ESEC/FSE â€™21, August 23â€“28, 2021,Athens,Greece Yang Hu,WenxiWang,Casen Hunger, Riley Wood, Sarfraz Khurshid,andMohitTiwari
KACV
ReportsKernel
IR
Permission 
Check 
Detection
Static
Invariant 
AnalysisPrivileged 
Function
Detection
Directed
Greybox 
Fuzzing
Privileged 
Functions
Static Analysis Dynamic Analysis
Permission 
ChecksInvariant 
Check
Injection
Kernel 
Image
Seed 
Distillation
Selected 
Seeds
Potentially 
Vulnerable 
Path
Figure 4:Overview of ACHyb
(Section3.3.1).Next,ACHybconductsseeddistillationtogenerate
high-qualityseedprograms,andfinallyappliesthegreyboxfuzzing
using those seed programs to trigger the injected invariant checks
andgetthe KACVs (Section 3.3.2).
3.2 Static Analysis
3.2.1 Permission Check Identification. The detection of KACV-M
andKACV-Irequires thefulllistof permission checks.Since most
permissionchecksarenotwelldocumented,researchersareseeking
toemployprogramanalysistoautomaticallycollectthepermission
checks.PeX[62]identifiesthepermissionchecksbyutilizingcall
graph slicing to search the wrappers of those permission checks,
given an incomplete list of the user-provided permission checks.
Thisapproachisunsound,especiallywhentheuser-providedper-
missioncheckslackdiversity.
To mitigate the problem, our insight is that we can firstly get
an over-approximation of the permission checks and further re-
move the false positives with manual efforts. However, a weak
over-approximation might significantly increase the manual ef-
forts.To solvethisproblem, ACHybperformsa soundy(i.e.,mostly
sound [32]) interface analysis to give a good approximation of the
permission checks. Our approximation is based on the two key ob-
servations. One is thatapermissioncheck is usuallyimplemented
asanaccesscontrolinterface ,whichreferstoakernelfunctioninthe
accesscontrolmodulethatcanbecalledbythefunctionsoutside
the module. The other one is that a permission check usually re-
turnsanaccesscontroldecisionthroughaboolean/integervariable.
Based on these two observations, ACHybcollects the access control
interfaceswithbooleanorintegerreturntypestoserveasasoundy
approximation ofthe permissionchecks.
After obtaining the approximation set of the permission checks,
instead of asking users to manually inspect every access control
interface, ACHybonlyrequests users tomanually inspecta fewse-
lected ones. ACHybachieves this in two folds. First, it performs a
dependencyanalysisonthereturnvariablesoftheaccesscontrolin-
terfacestodividetheinterfacesintoseveralequivalenceclasses.The
equivalenceclassofaccesscontrolinterfacesisdefinedinDefini-
tion3.1.Here,wesaythatavariable ğ‘¥dependsonavariable ğ‘¦iffthe1/* kernel/capability.c in the Linux kernel v4.9 */
2...
3boolcapable( intcap) {
4return ns_capable(&init_user_ns, cap);
5}
6EXPORT_SYMBOL(capable);
7
8boolns_capable( struct user_namespace *ns, intcap) {
9return ns_capable_common(ns, cap, true);
10}
11EXPORT_SYMBOL(ns_capable);
12
13boolns_capable_noaudit( struct user_namespace *ns, int
cap) {
14return ns_capable_common(ns, cap, false);
15}
16EXPORT_SYMBOL(ns_capable_noaudit);
17...
Figure 5:Anexample ofpermission checkdetection.
value ofğ‘¦determines the value of ğ‘¥.Second, for eachequivalence
class, we ask users to manually inspect only one representative of
theclass.Iftherepresentativeismanuallyidentifiedasapermis-
sioncheck,thenalltheinterfacesinthesameequivalenceclassare
automatically taken as the permission checks; otherwise, all the
interfaces in the equivalence class are not taken as the permission
checks.
Definition 3.1 (The Equivalence Class of Access Control Inter-
faces).The interface ğ‘“ğ‘¥and the interface ğ‘“ğ‘¦are in the same equiv-
alenceclassiffthereexistsakernelfunction ğ‘“ğ‘§suchthatthereturn
variables of both ğ‘“ğ‘¥andğ‘“ğ‘¦depend onthe returnvariable of ğ‘“ğ‘§.â–¡
To illustrate, we use an example in Fig. 5. Consider the three
access control interfaces, which are capable,ns_capable , and
ns_capable_noaudit . Based on the above definition of the equiv-
alenceclass,weknowthattheinterface capableisequivalentto
the interface ns_capable , as the return variable of the interface
capabledepends on that of the interface ns_capable (ğ‘“ğ‘§can be
ğ‘“ğ‘¥orğ‘“ğ‘¦in Definition 3.1). Besides, the interface ns_capable is
equivalenttotheinterface ns_capable_noaudit ,asbothoftheir
return variables depend on the return variable of the interface
ns_capable_common .Therefore,thethree interfacesareclassified
into one equivalence class. If users manually identify any one of
thethreeinterfaces(e.g.,theinterface ns_capable )asapermission
check,thentheothers(e.g.,theinterface capable andtheinterface
ns_capable_noaudit ) will be automatically classified as permis-
sion checks. In the end, users only manually inspects one interface,
but identifies three permissionchecks.
3.2.2 Privileged Function Identification. Besides the permission
checks,thedetectionof KACV-MandKACV-Ialsorequiresalistof
privilegedfunctions.Unlikethepermissioncheckswhichcanbeap-
proximated bysyntactic features,identifyingprivileged functions
needs to exploit the semantic features. To address this problem,
PeX[62] over-approximates the privileged functions by finding
thekernelfunctionswhoseexecutionsare dominated [37]bythe
permissionchecks.Tobespecific,ifacallsiteofthekernelfunction
ğ‘“ğ‘¥always executes after a callsite of a permission check, then PeX
identifies the function ğ‘“ğ‘¥as the privileged function. However, this
over-approximation is weak and might cause high false-positive
319ACHyb: A Hybrid Analysis Approachto DetectKernelAccess Control Vulnerabilities ESEC/FSE â€™21, August 23â€“28, 2021,Athens,Greece
rates. To illustrate, we use the KACV-Iexample shown in Fig. 3.
Sincethe callsite of a permissioncheck (line4) dominatesthecall-
site of the function clone_verify_area (line 6),PeXclassifies the
function clone_verify_area as a privileged function. However,
thefunction clone_verify_area isactuallyanon-privilegedfunc-
tion.
Tolowerthefalse-positiverates,insteadofusingthecontrol-flow
analysisas PeX,ACHybappliesa more fine-grained data-flow anal-
ysisto over-approximate the privilegedfunctions. The data-flow
analysisisactuallya callsitedependency analysiswhichsearches
for the kernel functions whose executions depend on the access
controldecisions.Thedefinitionofthecallsitedependencyisgiven
in Definition 3.2. For the KACV-I example in the Fig. 3, the callsite
of a privileged function (line 16) depends on the callsite of a per-
missioncheck capable (line4).Becausetheaccesscontroldecision
is_admin returned by the permissioncheck is used in a condition
(line 12) which determines the execution of the privileged function.
Definition 3.2 (Callsite Dependency) .A callsite ğ‘ğ‘¥depends ona
callsiteğ‘ğ‘¦iff the return value of ğ‘ğ‘¦controls the execution of the
callsiteğ‘ğ‘¥. â–¡
Notethatidentifyingsuchdependencyusuallyneedsan inter-
procedural data-flow analysis, which is notorious for the scala-
bility limitation [ 21]. To mitigate the issue, ACHybperforms an
intra-procedural data-flow analysis to identify the dependencies.
Compared to the inter-procedural analysis which extracts every
data-flows in the kernel, the intra-procedural analysis only focuses
on identifying the data-flows inside the body of each individual
kernel function, thereby achieving much better efficiency and scal-
ability. Moreover, the intra-procedural analysis would not cause
muchaccuracylossinapproximatingtheprivilegedfunctions,as
weobservethatformostkernelfunctionsexcludingthepermission
checks, the access control decision is only used insidethe function
where it is defined and rarely used as an argument or a return vari-
able.Inotherwords,theaccesscontroldecisionisrarelypropagated
acrossthe kernel functions.
Algorithm 1demonstratesourmethodtodetecttheprivileged
functions. ACHybfirstly gets the direct/indirect callsites in each
of the kernel functions excluding the permission checks (line 2-
5).ACHybthen conducts a callsite dependency analysis to get all
the callsites that depend on the collected callsites of permission
checks,andstorethemintheset ğ‘†â€²(line6-8).Next,foreachcall-
site in the set ğ‘†â€²excluding the ones of permission checks, ACHyb
identifiesitscalleesastheprivilegedfunctions(line10-12).Toillus-
trate,Fig. 6presentstheintra-proceduraldata-flowanalysisforthe
KACV-IexampleshowninFig. 3.ACHybfirstlydetectsallthecall-
sites inside the function vfs_dedupe_file_range , including the
callsiteofthefunction capable (line4),andthecallsiteofthefunc-
tionsbtrfs_dedupe_file_range andxfs_file_dedupe_range
(line 16). Given a permission check list detected in the last sec-
tion,ACHybidentifies that only the function capable is a per-
mission check. Next, ACHybconducts a callsite dependency anal-
ysis based on the access control decision is_admin returned by
the permission check capable. Sinceis_admin is used in an if
condition (line 12) and controls the execution of the functions
btrfs_dedupe_file_range andxfs_file_dedupe_range ,ACHyb
classifies thesetwofunctionsas the privilegedfunctions.Algorithm1 Privilegedfunction detection algorithm.
Input:the kernel intermediate representation ğ‘…
the setofpermissionchecks ğ¹ğ‘ğ‘’ğ‘Ÿğ‘š
Output:the setofprivilegedfunctions ğ¹ğ‘ğ‘Ÿğ‘–ğ‘£
1:function ğºğ¸ğ‘‡_ğ‘ƒğ‘…ğ¼ğ‘‰_ğ¹ğ‘ˆğ‘ğ¶ğ‘‡ğ¼ğ‘‚ğ‘ğ‘† (ğ‘…,ğ¹ğ‘ğ‘’ğ‘Ÿğ‘š)
2:ğ¹ğ‘›ğ‘œğ‘›_ğ‘ğ‘’ğ‘Ÿğ‘šâ†ğ‘….ğ‘”ğ‘’ğ‘¡_ğ‘“ğ‘¢ğ‘›ğ‘ğ‘¡ğ‘–ğ‘œğ‘›ğ‘ ()âˆ’ğ¹ğ‘ğ‘’ğ‘Ÿğ‘š
3:ğ¹ğ‘ğ‘Ÿğ‘–ğ‘£â†âˆ…
4:forğ‘“âˆˆğ¹ğ‘›ğ‘œğ‘›_ğ‘ğ‘’ğ‘Ÿğ‘šdo
5: ğ‘†â†ğ‘“.ğ‘”ğ‘’ğ‘¡_ğ‘ğ‘ğ‘™ğ‘™ğ‘ ğ‘–ğ‘¡ğ‘’ğ‘ ()
6: forğ‘ âˆˆğ‘†do
7: ifğ‘ .ğ‘–ğ‘ _ğ‘ğ‘’ğ‘Ÿğ‘š_ğ‘ğ‘ğ‘™ğ‘™ğ‘ ğ‘–ğ‘¡ğ‘’()then
8: ğ‘†â€²â†ğ‘ğ‘ğ‘™ğ‘™ğ‘ ğ‘–ğ‘¡ğ‘’_ğ‘‘ğ‘’ğ‘ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘›ğ‘ğ‘’ _ğ‘ğ‘›ğ‘ğ‘™ğ‘¦ğ‘ ğ‘–ğ‘ (ğ‘“,ğ‘ )
9: forğ‘ â€²âˆˆğ‘†â€²do
10: ifÂ¬ğ‘ â€².ğ‘–ğ‘ _ğ‘ğ‘’ğ‘Ÿğ‘š_ğ‘ğ‘ğ‘™ğ‘™ğ‘ ğ‘–ğ‘¡ğ‘’()then
11: ğ¹ğ‘ğ‘ğ‘™ğ‘™ğ‘’ğ‘’â†ğ‘….ğ‘”ğ‘’ğ‘¡_ğ‘ğ‘ğ‘™ğ‘™ğ‘’ğ‘’ğ‘ (ğ‘ â€²)
12: ğ¹ğ‘ğ‘Ÿğ‘–ğ‘£â†ğ¹ğ‘ğ‘Ÿğ‘–ğ‘£âˆªğ¹ğ‘ğ‘ğ‘™ğ‘™ğ‘’ğ‘’
13:returnğ¹ğ‘ğ‘Ÿğ‘–ğ‘£
vfs_dedupe_file_range
line 4:   bool is_admin  = capable  (CAP_SYS_ADMIN );
line 12: if (!( is_admin  || â€¦ ) )
line 14-18: else statement
data flow
xfs_file_dedupe_range btrfs_dedupe_file_range
control flow (branch)
line 16:  deduped = dst_file -> f_op ->dedupe_file_range(...);
control flow 
(function call)capable
data flow
Figure 6: An example to illustrate our privileged func-
tion detection algorithm. btrfs_dedupe_file_range and
xfs_file_dedupe_range are identified as privileged func-
tions, as their callsite in line 16 depends on the callsite of
thecapablefunction (apermission check) inline 4.
3.2.3 StaticInvariantAnalysis. Thegoaloftheinvariantanalysis
is to identify the potentially vulnerable paths where the callsites
ofprivilegedfunctionsarenotprotectedbythepermisionchecks.
ThemajorlimitationoftheexistinginvariantanalysisforKACV
detection is that the defined invariant is not strong enough which
may cause false negatives. PeX[62] proposes an invariant: for each
path inthe control-flow graph,every callsite ofa privileged function
mustbepreceded byat leastone callsiteofapermission check . This
invariantanalysiscannotrevealthe KACV-IinFig.3,astheindirect
callsite of the privileged function(s) (line 16) always executes after
the callsite ofthe permissioncheck capable(line4).
To mitigate the limitations, ACHybfirstly proposes a stronger
accesscontrolinvariant: aprivilegedfunctionshouldnotbeexecuted
320ESEC/FSE â€™21, August 23â€“28, 2021,Athens,Greece Yang Hu,WenxiWang,Casen Hunger, Riley Wood, Sarfraz Khurshid,andMohitTiwari
when its corresponding access control decision is denied or not gen-
erated at all . One straightforward way to check this invariant is
to apply Symbolic Execution [ 5] on every path from each entry of
the kernel (i.e., the system calls) to the callsites of the privileged
function, and solve the constraints collected along the paths. How-
ever, this method suffers from the path explosion and the high
complexity of the path constraints. ACHybadopts two strategies to
make the constraint-basedinvariantanalysisscalable.
Onestrategyistoperformanintra-proceduralanalysisinsteadof
the inter-procedural analysis, based on the observation mentioned
in Section 3.2.2that the access control decision is rarely propa-
gatedacrossthekernelfunctions.Foreverypathwhichreachesa
privileged function, ACHybonlycollects the constraints inside the
callerof the privileged function.By replacingthe inter-procedural
analysis with the intra-procedural analysis, both the path space
and the complexity of the constraints can be largely reduced. How-
ever, since only partial path constraints are collected, this analysis
canonlyfind potentially vulnerablepaths. ACHybfurtherreduces
false positives among these paths using dynamic analysis which is
introducedinSection 3.3.
The other strategy is to perform theabove analysis only on the
non-privilegedfunctionswhichcallatleastoneprivilegedfunctions.
This is based on our observation that the non-privileged functions
usuallyneedtorequestaccesscontroldecisionsbeforetheycallthe
privileged functions, while the privileged functions rarely request
accesscontroldecisionswiththeassumptionthattheircallersre-
questandchecktheaccesscontroldecisionsbeforehand.Besides,
thereisnoneedtoconducttheanalysisonpermissionchecks,as
they never callprivilegedfunctions.
Algorithm 2shows our invariant analysis algorithm. ACHybfirst
collectsallthekernelfunctionsexcludingthepermissionchecks
and the privileged functions. Inside each of these functions, ACHyb
collectsthecallsitesoftheprivilegedfunctions(line2-5).Itthengets
alltheintra-proceduralpaths(withfiniteloopunrolling)thatreach
these callsites (line6-7).For each path, ACHybobtains the callsites
ofthepermissionchecksinthepath(line8-9).Ifnosuchcallsite
is found, the path is taken as a potentially vulnerable path (line
10-11). Otherwise, ACHybfetches the access control decision and
the path constraints, and checks the satisfiability of the constraint
which is theconjunction of thepath constraintsandan additional
constraintstatingthatalltheaccesscontroldecisionsare denied
(line 13-15). If the constraint is satisfiable, which means that the
path to the privileged function is feasible but the access control
decisions in the path are denied, the path is then identified as a
potentiallyvulnerable path(line16-17).
We demonstrate our static invariant analysis using the relevant
pathconditionsofthe KACV-IexampleshowninFig. 3.Sincethere
isacallsiteofaprivilegedfunctioninline16, ACHybanalyzesthe
path to the callsite inside the function vfs_dedupe_file_range .
For simplicity, we consider the loop is unrolled only once. The
pathtothecallsiteoftheprivilegedfunctionincludeslines2-10,12,
14-16. First, ACHybcollects 3 path constraints inside the function
vfs_dedupe_file_range :ğ¶1,Â¬ğ¶2, andÂ¬ğ¶3. Next,ACHybgener-
ates an additional constraint ğ¶4:=(ğ‘–ğ‘ _ğ‘ğ‘‘ğ‘šğ‘–ğ‘›=ğ‘“ğ‘ğ‘™ğ‘ ğ‘’), which
indicatesthattheaccesscontroldecisionofthefunction capable
isdenied(line4).Then, ACHybchecksifthefollowingconstraintAlgorithm2 Static invariantanalysisalgorithm.
Input:the kernel intermediate representation ğ‘…
the setofpermissionchecks ğ¹ğ‘ğ‘’ğ‘Ÿğ‘š
the setofprivilegedfunctions ğ¹ğ‘ğ‘Ÿğ‘–ğ‘£
Output:the setofpotentiallyvulnerable paths ğ‘ƒğ‘ğ‘œğ‘¡
1:function ğ‘†ğ‘‡ğ´ğ‘‡ğ¼ğ¶_ğ¼ğ‘ğ‘‰_ğ´ğ‘ğ´ğ¿ğ‘Œğ‘†ğ¼ğ‘† (ğ‘…,ğ¹ğ‘ğ‘’ğ‘Ÿğ‘š,ğ¹ğ‘ğ‘Ÿğ‘–ğ‘£)
2:ğ¹ğ‘œğ‘¡â„ğ‘’ğ‘Ÿâ†ğ‘….ğ‘”ğ‘’ğ‘¡_ğ‘“ğ‘¢ğ‘›ğ‘ğ‘¡ğ‘–ğ‘œğ‘›ğ‘ ()âˆ’ğ¹ğ‘ğ‘’ğ‘Ÿğ‘šâˆ’ğ¹ğ‘ğ‘Ÿğ‘–ğ‘£
3:ğ‘ƒğ‘ğ‘œğ‘¡â†âˆ…
4:forğ‘“âˆˆğ¹ğ‘œğ‘¡â„ğ‘’ğ‘Ÿdo
5: ğ‘†ğ‘ğ‘Ÿğ‘–ğ‘£â†ğ‘“.ğ‘”ğ‘’ğ‘¡_ğ‘ğ‘Ÿğ‘–ğ‘£_ğ‘ğ‘ğ‘™ğ‘™ğ‘ ğ‘–ğ‘¡ğ‘’ğ‘ (ğ¹ğ‘ğ‘Ÿğ‘–ğ‘£)
6: forğ‘ âˆˆğ‘†ğ‘ğ‘Ÿğ‘–ğ‘£do
7: ğ‘ƒğ‘™ğ‘œğ‘ğ‘ğ‘™â†ğ‘“.ğ‘”ğ‘’ğ‘¡_ğ‘ğ‘ğ‘¡â„ğ‘ (ğ‘ )âŠ²getpathsinside ğ‘“
whichreachthe callsite ğ‘ .
8: forğ‘âˆˆğ‘ƒğ‘™ğ‘œğ‘ğ‘ğ‘™do
9: ğ‘†ğ‘ğ‘’ğ‘Ÿğ‘šâ†ğ‘.ğ‘”ğ‘’ğ‘¡_ğ‘ğ‘’ğ‘Ÿğ‘š_ğ‘ğ‘ğ‘™ğ‘™ğ‘ ğ‘–ğ‘¡ğ‘’ğ‘ (ğ¹ğ‘ğ‘’ğ‘Ÿğ‘š)
10: ifğ‘†ğ‘ğ‘’ğ‘Ÿğ‘š=âˆ…then
11: ğ‘ƒğ‘ğ‘œğ‘¡â†ğ‘ƒğ‘ğ‘œğ‘¡âˆª{ğ‘}
12: else
13: ğ·â†ğ‘.ğ‘”ğ‘’ğ‘¡_ğ‘‘ğ‘’ğ‘_ğ‘£ğ‘ğ‘Ÿ(ğ‘†ğ‘ğ‘’ğ‘Ÿğ‘š)
14: ğ¶â†ğ‘.ğ‘”ğ‘’ğ‘¡_ğ‘ğ‘ğ‘¡â„_ğ‘ğ‘œğ‘›ğ‘ ğ‘¡ğ‘Ÿğ‘ğ‘–ğ‘›ğ‘¡ğ‘ ()
15: ğ¶â†ğ¶âˆª{ğ‘‘=denied|ğ‘‘âˆˆğ·}
16: ifğ‘–ğ‘ _ğ‘ ğ‘ğ‘¡ğ‘–ğ‘ ğ‘“ğ‘–ğ‘ğ‘ğ‘™ğ‘’(/logicalandtext.1
ğ‘âˆˆğ¶ğ‘)then
17: ğ‘ƒğ‘ğ‘œğ‘¡â†ğ‘ƒğ‘ğ‘œğ‘¡âˆª{ğ‘}
18:returnğ‘ƒğ‘ğ‘œğ‘¡
issatisfiable:
ğ¶1âˆ§Â¬ğ¶2âˆ§Â¬ğ¶3âˆ§ğ¶4.
Sincetheconstraintissatisfiable,thepathisidentifiedasapoten-
tiallyvulnerable path.
3.3 DynamicAnalysis
Thedynamicanalysisfocusesonreducingfalsepositivesamongthe
potentially vulnerable paths detected by the static analysis. ACHyb
achievesthisintwosteps.First, ACHybinjectstherun-timeinvariant
checks to the kernel image, as introduced in Section 3.3.1. Then,
ACHybconductsgreyboxfuzzingtocoverthepotentiallyvulnerable
paths so that the invariant checks can be triggered and the KACVs
can be revealed,as presentedinSection 3.3.2.
3.3.1 Invariant Check Injection. As mentioned in Section 3.2.3, the
intra-procedural invariant analysis would cause false positives. To
remedythisproblem, ACHybrigorouslycheckstheaccesscontrolin-
variantintheruntime.Foreachpotentiallyvulnerablepath, ACHyb
instruments the kernel with a run-time invariant check which is
added exactly before the callsite of each privileged function. As
introduced in Section 3.2.3, the static invariant analysis can detect
two kinds of potentially vulnerable paths reachable to the priv-
ileged functions: the paths with missing permission checks and
thepathswithdeniedaccesscontroldecisions.Ifatestexecution
triggers the run-time checks and covers the potentially vulnerable
path with missing permission checks, the potentially vulnerable
path is feasible and thus it is taken as the path that could reveal
KACV-M.Similarly,ifthepotentiallyvulnerablepathwithdeniedac-
cesscontroldecisionisfeasible,thepathisconsideredtorevealthe
KACV-I.FortheKACV-IexampleinFig. 3,ACHybinjectsarun-time
321ACHyb: A Hybrid Analysis Approachto DetectKernelAccess Control Vulnerabilities ESEC/FSE â€™21, August 23â€“28, 2021,Athens,Greece
Traces
Trace 
Slicing
Trace 
EmbeddingTracing
ClusteringCluster 
SelectionSampling
Real-World 
Programs
Seed 
Programs
Trace 
Slices
VectorsClustersSelected
ClustersKernel
Image
Potentially 
Vulnerable 
Paths
Sampled
Trace SlicesConversion
Trace 
Slices
Figure 7:Anoverview ofour seed distillation approach.
invariant check assert(is_admin) before calling the privileged
function(line16),tocheckifthepotentiallyvulnerablepath(line4-
10,12,14-16)isfeasiblewhentheaccesscontroldecision is_admin
isfalse(i.e.,denied).
3.3.2 Greybox Fuzzing with Seed Distillation. Greybox fuzzing has
been widely used in patch testing, bug detection, and bug repro-
duction[7,9,41].ACHybregardstheinvariantchecksasthetargets,
andutilizesthegreyboxfuzzingtotriggerthem.Tofurtherimprove
the efficiency of fuzzing, we propose a novel clustering-based seed
distillationapproachtogeneratehigh-qualityseedprograms(i.e.,
sequences of system calls) which could guide the fuzzer to rapidly
approachtheinvariantcheckswithlesschanceofbeingtrapped.
Fig.7brieflyshowsourseeddistillationapproach. ACHybfirstcol-
lectsexecutiontracesfromthereal-worldprogramsintheLinux
TestProject(LTP)[ 49].WechooseLTPbecauseitiswellmaintained
(by many companies such as IBM, Cisco, Red Hat, etc) aiming at
generatinggoodtestprogramsfortheLinuxdevelopment.Ithas
alsobeenappliedbythestate-of-the-artseeddistillationtoolcalled
Moonshine [42].Aftercollectingthetraces, ACHybthenperforms
program slicing [ 20,34] to split the traces into trace slices. Next,
ACHybdoes the trace embedding to get the vector representation
of each trace slice, and use the scikit-learn machine learning
framework [ 8] to perform the K-means clustering [ 30] on the trace
slices.ACHybselects the clusters which are Å‚closerÅ¾ to the poten-
tially vulnerable paths. Detailsabout the trace embedding and the
cluster selection are introduced in the following sections. For each
selected cluster, ACHybrandomly samples a few trace slices and
converts them into the seed programs. These seed programs are
finally fedto the greybox fuzzer.
TraceEmbedding. Inspiredbytheexistingprogramembedding
approaches [ 1,2,6,47,58], we propose our trace embedding ap-
proach to convert the trace slices into vector representations. First,
we convert all the trace slices into our defined multi-relation graph
which encodes the syntactic and semantic information of the trace
slices.Second,weusethe PyTorch-BigGraph system[29]togener-
atethevectorrepresentationforeachnodeinthegraphbasedonthe
information from their neighbors.Last, we extract the embedding
ofeachnode representing the trace slice as our trace embedding.
Formally, we define the multi-relation graph as a directed graph
represented by a tuple (ğ‘‰,ğ‘…,ğ¸), whereğ‘‰is a set of nodes, ğ‘…is
a set of relations, and ğ¸is a set of labeled directed edges ğ‘¥ğ‘Ÿâ†¦â†’ğ‘¦
trace slice t 1:
c1: a2 = n 1(a1) 
trace slice t 2:
c1: a2 = n 1(a1) 
c2: a3 = n 2(a2)
a1c1: a2 = n 1(a1) 
a2 a3 n1 n2
ğ°2
c2: a3 = n 2(a2)
ğ°1
ğ°1
ğ±1 ğ±1 ğ±2 ğ±3 ğ±3b1 bn
 ...
ğ²ğ²ğ²
ğ±2t1 t2Figure 8:Anexample oftrace embedding.
whereğ‘¥,ğ‘¦âˆˆğ‘‰andğ‘Ÿâˆˆğ‘…. The multi-relation graph depicts the
following syntacticandsemantic informationintrace slices:each
trace slice consists of at least one system call; each system call has
its system call name, its arguments (if any) and its return value (if
any); each trace slice covers a set of code branches. Accordingly,
we define fivenodetypes torepresenta trace slice(dented as ğ‘¡),a
system call (denoted as ğ‘), the name of a system call (denoted as ğ‘›),
theargument/return valueofa system call(denoted as ğ‘),and the
branchcoveredbyatraceslice(denotedas ğ‘),respectively.Besides,
we definefive relation types as follows:
â€¢Trace-to-Call Relations: The relation ğ›¼ğ‘–between the trace
sliceğ‘¡anditsğ‘–-th systemcall ğ‘ğ‘–isdenotedas ğ‘¡ğ›¼ğ‘–â†¦â†’ğ‘ğ‘–.
â€¢Call-to-Name/Arguments/Return Relations:Therelation ğ›½1
between the system call ğ‘and its callname ğ‘›is denoted as
ğ‘ğ›½1â†¦â†’ğ‘›; the relation ğ›½2between the system call ğ‘and its
argument ğ‘isdenotedas ğ‘ğ›½2â†¦â†’ğ‘;therelation ğ›½3betweenthe
systemcall ğ‘andits return value ğ‘£isdenotedas ğ‘ğ›½3â†¦â†’ğ‘£.
â€¢Trace-to-CoverageRelation:Therelation ğ›¾betweena trace
sliceğ‘¡andthe coveredcode branch ğ‘isdenotedas ğ‘¡ğ›¾â†¦â†’ğ‘.
Fig.8showsthemulti-relationgraphofabriefexample.Thereare
twotraceslices ğ‘¡1andğ‘¡2intheexample.Thetraceslice ğ‘¡1contains
onesystemcall ğ‘1,andthetraceslice ğ‘¡2containsasequenceoftwo
system calls ğ‘1andğ‘2. We get the vector representation of each
nodeinthe graphwiththe nodeembedding,and extractthevector
representationsofallthetraceslicenodes( ğ‘¡1andğ‘¡2)asourtrace
embedding.
ClusterSelection. Intuitively, if the paths covered by a cluster of
trace slices are similar to the potentially vulnerable paths, the seed
programs convertedfromthe traceslices inthe cluster are inclined
to cover the potentially vulnerable paths with a few mutations.
Ourclusterselectionisbasedonthisintuition.Foreachpotentially
vulnerablepath, ACHybselectstheclusterwhichhasthemaximal
path similarity to the path. The path similarity is defined based
on the Jaccard distance between the potentially vulnerable path
and the paths covered by system calls in the traceslices. Formally,
letğ‘be a potentially vulnerable path, and ğ‘„be a set of paths
which are covered by the clusters; the path similarity between
ğ‘andğ‘„is defined as ğ‘†(ğ‘,ğ‘„)=ğ‘šğ‘’ğ‘ğ‘›ğ‘âˆˆğ‘„(ğ½(ğµ(ğ‘),ğµ(ğ‘))),where
ğ½(ğ‘‹,ğ‘Œ)=|ğ‘‹âˆ©ğ‘Œ|
|ğ‘‹âˆªğ‘Œ|andğµ(ğ‘)is the set of branches covered by ğ‘. The
trace slices which are sampled from selected clusters are finally
322ESEC/FSE â€™21, August 23â€“28, 2021,Athens,Greece Yang Hu,WenxiWang,Casen Hunger, Riley Wood, Sarfraz Khurshid,andMohitTiwari
Table 1: The KACV detection precision of ACHybandPex. # perm refers to the number of detected permission checks. # priv
refers to the number of detected privileged functions. # pvp refers to the number of detected potentially vulnerable paths. #
wrn refersto thenumberofwarnings.# kcav refersto thenumberofdetected KACVs.
AC ACHyb PeX
Module #perm #priv #pvp #wrn #kacv precision #perm #priv #pvp #wrn #kacv precision
CAP 28 560 108 38 9 23.7% 19 3,245 850 850 4 0.5%
LSM 243 2,254 90 31 9 29.0% 243 10,260 1,017 1,017 7 0.7%
DAC 27 609 29 7 4 57.1% 22 537 221 221 3 1.4%
Total 298 3,423 227 76 22 28.9% 284 14,042 2,088 2,088 14 0.7%
convertedtoseedprograms.Supposethatthetraceslice ğ‘¡2inFig.
8has been sampled from a selected cluster. The seed program
converted from ğ‘¡2consists of two system calls from ğ‘¡2, which is
ğ‘›1(ğ‘1);ğ‘›2(ğ‘2).
3.4 Implementation
Weimplementthestaticanalysisof ACHybbasedontheLLVMpass
framework[ 45]withabout3,200linesofC++code.Forthedynamic
analysis,we build the greybox fuzzing andthe seed distillation on
topofthekernel greyboxfuzzercalledSyzkaller[ 56]with about
1,100 linesofGO code and600linesofPythoncode.
4 EVALUATION
4.1 ExperimentalSetup
Baseline. To evaluatethe KACV detectionperformanceof ACHyb,
we choose PeX[62], the state-of-the-art tool for KACV detection
whichhasitspubliclyavailableimplementation1,asourbaseline.
Besides, to evaluate our seed distillation approach, we choose
Moonshine [42]whichisthestate-of-the-artseeddistillationtool,
as our baseline.
Kernel Version and Compilation. We evaluate ACHybon the
Linux kernel v4.18.5, the version PeXuses in its evaluation. We
compile the kernel source with the allyesconfig configuration
using the clang-9toolchain[ 55]andthe wllvmtool[46].
Subjects. We take all the three subjectmodules in the PeXevalua-
tionasoursubjects.Theyarecommonlyusedkernelaccesscontrol
modules,includingLinux Capabilities (CAP), Linux Security Mod-
ules(LSM) andDiscretionary Access Control(DAC).
Environment. All the experiments are conducted on a machine
withtwoIntel(R)Xeon(R)E5-2620v4processors(32logicalcores
intotal)and256-GBRAM. The operating systemisUbuntu20.10.
4.2 Research Questions
We try to answer the three following research questions in our
experiments:
Question1. Howprecisely can ACHybdetectKACVs?
Question2. Howefficiently can ACHybdetectKACVs?
Question3. CanACHybdetectnewKACVs?
4.3 RQ1: DetectionPrecision
To evaluate the detection precision, we need to identify the KACVs
fromthewarnings(i.e.,potentialKACVs)reportedby ACHyband
1https://github.com/lzto/pexPeX.Todoso,weconductathree-stepmanualinspection.First,we
manuallyinspectallthewarningsreportedbybothtools,among
whichweobtain15KACVsthathavebeenconfirmedbythekernel
developersorreportedbytheauthorsof PeX.Then,wemanually
inspecttherestwarningsreportedby ACHybandidentify7warn-
ings as new KACVs. Next, we report these 7 new KACVs to the
kernel developers. By the time of the paper publication, they have
confirmed2newKACVs.
4.3.1 The Overall Detection Precision. Table1shows the detection
precision of ACHybandPeX. For CAP module, the detection pre-
cision of ACHybis 23.7%, while the precision of PeXis only 0.5%.
ForLSMmodule,thedetectionprecisionof ACHybis29.0%,while
theprecisionof PeXisonly0.7%.ForDACmodule,thedetection
precisionof ACHybis57.1%,whiletheprecisionof PeXisonly1.4%.
We can also observe that, among the three modules, both tools
perform with the highest precision on module DAC; perform with
the second highest precision on module LSM; perform with the
lowestprecisiononmoduleCAP.Intotal,forallthethreemodules,
28.9% of the warnings reported by ACHybare KACVs, while only
0.7% of the warnings reported by PeXare KACVs. Furthermore,
the KACVs detected by ACHybcontain all the ones detected by PeX.
Overall, we can say that ACHybis much more precise than PeXin
KACV detection.
4.3.2 Static and Dynamic Analysis. Table1also shows the inter-
mediateanalysisresults,whichcanhelpusunderstandhoweach
analysisin ACHybcontributesto its precise detection.
Permission Check Identification. As for the permission check
identification, ACHybreports14 morepermissionchecksthan PeX.
We manually inspect these permission checks and confirm that all
of them are the real permission checks. The results show that the
soundyinterfaceanalysisof ACHybcanhelpidentifymorepermission
checks than PeX.
Privileged Function Identification. From Table 1, we can ob-
servethat ACHybreportsmuchlessprivilegedfunctionsthan PeX.
Tostudythequalityofthereportedprivilegedfunctions,weran-
domly sample 400 functions reported by ACHybandPeX, respec-
tively. After manually inspecting the sampled privileged functions,
wefoundthat83%ofthesampledprivilegedfunctionsidentified
byACHybare the real privileged functions, while only 8% of the
sampled privileged functions identified by PeXare the real privi-
leged functions. Inaddition, thereal privilegedfunctions detected
byACHybcontainalltherealonesdetectedby PeX.Ingeneral,we
canconcludethatourproposedcallsitedependencyanalysisimproves
theprecision oftheprivileged functionidentification.
323ACHyb: A Hybrid Analysis Approachto DetectKernelAccess Control Vulnerabilities ESEC/FSE â€™21, August 23â€“28, 2021,Athens,Greece
CAP
 LSM
 DAC
 TOTAL
0
100
200
300
400
500
600
700
800# pvp
10890
29227329412
112853
ACHyb
ACHyb + PeX
Figure 9: The number of potentially vulnerable paths de-
tected by the invariant analysis. Å‚ ACHyb+PeXÅ¾ refers to the
resultsof PeXinvariantanalysiswiththepermissionchecks
and privileged functions detected by ACHyb. # pvp refers to
thenumberofdetected potentially vulnerablepaths.
Table 2: The time cost (in minutes) of static analysis. ğ‘¡ğ‘ğ‘’ğ‘Ÿğ‘š
refers to the time cost of permission check identification.
ğ‘¡ğ‘ğ‘Ÿğ‘–ğ‘£referstothetimecostofprivilegedfunctionidentifica-
tion.ğ‘¡ğ‘–ğ‘›ğ‘£referstothetimecostofinvariantanalysis. ğ‘¡ğ‘œğ‘£ğ‘’ğ‘Ÿğ‘ğ‘™ğ‘™
refersto thetotal timecostoftheentire static analysis.
AC ğ‘¡ğ‘ğ‘’ğ‘Ÿğ‘š ğ‘¡ğ‘ğ‘Ÿğ‘–ğ‘£ ğ‘¡ğ‘–ğ‘›ğ‘£ ğ‘¡ğ‘œğ‘£ğ‘’ğ‘Ÿğ‘ğ‘™ğ‘™
Module ACHybPeXACHybPeXACHyb PeXACHyb PeX
CAP 0.10.38.38.637.3272.245.7281.1
LSM 0.10.37.98.834.2254.942.2264.0
DAC 0.10.28.08.510.5119.318.6128.0
Total 0.30.824.225.982.0646.4106.5673.1
Invariant Analysis. The invariant analysis is based on the de-
tectedpermissionchecksandprivilegedfunctions.Toconductan
apple-to-applecomparisonontheinvariantanalysis,werun PeX
invariant analysis on the permission checks and privileged func-
tions detected by ACHyb. Fig.9shows the number of potentially
vulnerable paths detected by the invariant analysis of both tools.
PeXreports853potentiallyvulnerablepaths,while ACHybreports
only 227 potentially vulnerable paths. After manually checking all
the 853 paths reported by PeXunder the new configuration, we
foundthatthenumberoftherealvulnerablepathsreportedby PeX
is 19, while the number of real paths reported by ACHybis 22 (as
showninTable 1).Therefore,theprecisionof ACHybinvariantanal-
ysis is 9.7%, while the precision of PeXinvariant analysis is 2.2%.
Besides,therealvulnerablepathsreportedby ACHybcontainallthe
onesreportedby PeX.Theresultsshowthattheinvariantanalysisof
ACHybis more precise and sound than the invariant analysis of PeX.
DynamicAnalysis. Finally,wenoticethat33.4%ofthepotentially
vulnerablepathsarereportedaswarningsbyourdynamicanalysis.
We manually check the 151 unreported paths and found that all
of them arefalse positives. In contrast, PeXdirectly reports allthe
2,088potentiallyvulnerablepathsaswarningswhichcausestheex-
tremely high false-positive rates. The results show that our dynamic
analysishelpsto reduce thefalse positives in KACV detection.
0
 2
 4
 6
 8
 10
 12
Time (hour)
0.00
0.05
0.10
0.15
0.20
0.25
0.30
0.35% triggered invariant checks
ADistill
MDistill
NoDistill
NoSeedFigure10:Timeefficiencyintriggeringtheinvariantchecks
usingfour seed distillation approaches.
4.4 RQ2: DetectionEfficiency
4.4.1 Static Analysis. Table2shows the time cost by the static
analysis of ACHybandPeX. The results show that, in total, ACHyb
is6.3xfasterthan PeX.Thetimedifferencesaresubtleinboththe
permissioncheckdetectionandtheprivilegedfunctiondetection.
However,thebigtimedifferenceslieintheinvariantanalysiswhere
ACHybis 7.9x faster than PeX. In addition to the time costs of the
automatedanalysis, PeXrequiresuserstoprovideaninitiallistof
permissionchecks,while ACHybrequiresmanualefforttoinspect
therepresentativepermissioncheckcandidates.Forallthethree
subjectmodules,the user-provided listin PeXevaluation contains
196 permission checks, while the candidate list produced by ACHyb
only contains 17 permission checks. To measure the required man-
ualeffortinthecandidateinspection,eachstudentauthorinthis
paperinspectsthe17candidatesindependently.Asaresult,each
person spends 6 minutes on average (4 minutes in minimum and 8
minutesinmaximum)onthisinspection. Overall,theresultsindicate
that thestaticanalysisof ACHybis more efficientthan PeX.
4.4.2 Dynamic Analysis. To evaluate the efficiency of the dynamic
analysis, we focus on evaluating our proposed seed distillation
approach.Wechoosethestate-of-the-artseeddistillationtoolcalled
Moonshine [42]asourbaseline,andconstructfourgroupsofthe
seedprograms:1)noseedprograms(denotedasNoSeed);2)theseed
programswhichareconvertedfromtheexecutiontraceswithout
any distillation (denoted as NoDistill); 3) the seed programs which
aredistilledfromtheexecutiontracesusing Moonshine (denoted
as MDistill); 4) the seed programs which are distilled from the
execution traces using ACHyb(denoted as ADistill). We evaluate
thetimeefficiencyandthenumberoftriggeredinvariantchecks
ofACHybusingeachseedgroup.Togetthereliableexperimental
results,wefollowthefashionoftherecentresearchworkonfuzzing
evaluation[ 18,27].Foreachgroupoftheseedprograms,werun
ACHybwith 16 logical cores in 12 hours and repeat the experiment
11 times. We perform the Mann-Whitney U test [ 35] to analyze the
significance ofthe performance differences.
Fig.10shows the median percentageof thetriggered invariant
checks. We can observe that only about 5% of the invariant checks
can be triggered when no seed program is applied. While the seed
programswithoutdistillationhelptotriggermoreinvariantchecks,
324ESEC/FSE â€™21, August 23â€“28, 2021,Athens,Greece Yang Hu,WenxiWang,Casen Hunger, Riley Wood, Sarfraz Khurshid,andMohitTiwari
Table 3:New KACVs Detected by ACHyb.
ID File Path Function Type Description Status
CAP-1 net/core/rtnetlink.c do_setlink KACV-I Misusingthe CAP_NET_ADMIN check. Confirmed
CAP-2 drivers/char/random.c _extract_crng KACV-M Missingthe CAP_SYS_ADMIN check. Confirmed
CAP-3 net/ipv6/addrconf.c addrconf_join_anycast KACV-M Missingthe CAP_NET_ADMIN check. Ignored
CAP-4 drivers/tty/sysrq.c sysrq_do_reset KACV-M Missingthe CAP_SYS_BOOT check. Ignored
LSM-1 kernel/signal.c send_sig_info,force_sigsegv KACV-M Missingthe security_task_kill check. Ignored
LSM-2 ipc/sem.c newary KACV-I Misusingthe security_sem_alloc check. Ignored
DAC-1 fs/coredump.c cn_print_exe_file KACV-M Missingthe inode_permission check. Ignored
only 15% of the invariant checks can be triggered. Furthermore,
thereislessthan5%improvementwhenusingtheseedprograms
distilledbyMoonshine,comparedtousingtheseedprogramswith-
out any distillation. When using the seed programs distilled by
ACHyb, more than 30% of the invariant checks can be triggered.
Furthermore, the results of the Mann-Whitney U test indicate that
the triggered checks using ACHybseed distillation approach are
significantlymore thanthetriggeredchecksusing the otherthree
approaches (all three p-values of Mann-Whitney U test are smaller
than0.001). Basedontheaboveresults,wecanconcludethat ACHyb
seed distillation approach can significantly improvethe efficiencyof
triggering theinvariantchecks.
4.4.3 TheOverallDetectionEfficiency. Asintroduced, PeXrequires
human effort to remove the false positives of theresults produced
byitsstaticanalysis,while ACHybappliesdynamicanalysistore-
move the false positives. After manually inspecting the potentially
vulnerable paths, we find that ACHybhas successfully triggered all
the invariant checks associated with 22 KACVs in the first 6 hours.
Inadditiontothe112.5minutetimecostinthestaticanalysis(106.5
minutesforautomaticanalysisand6minutesformanualinspec-
tionofpermissioncheckcandidates), ACHybsuccessfullydetectsall
22KACVsinlessthan8hours.Onthecontrary, PeXspendsmore
than 11 hours on only the static analysis phase without taking into
accountthetimetakenbythemanualfalsepositiveremoval. The
resultsshow that ACHybis moreefficientthan PeX.
4.5 RQ3: NewKACVs
Table3showsthe7newKACVs(5 KACV-Mand2KACV-I)thatwe
reporttothekerneldevelopers.Asaresult,2newKACVs(1 KACV-M
and 1KACV-I) are confirmed by the kernel developers. We are still
waiting for the feedback for the rest of 5 new KACVs. In detail,
4KACVs( CAP-1,CAP-2,CAP-3,andCAP-4)are dueto missingor
misusing CAP checks in drivers or the net subsystem; 2 KACVs
(LSM-1andLSM-2) are due to missing or misusing LSM checks
in the signal mechanism or the semaphore mechanism; 1 KACV
(DAC-1)isduetomissingaDACcheckinthefilesystem. Overall,
wecansay that ACHybis ableto detectnew KACVs.
5 DISCUSSION
In this section, we want to discuss the limitations of ACHyband
our future work. We recognized four limitations of ACHyb. First,
ACHybcannotdetect non-function permissionchecks.Second, ACHyb
cannot detect privileged functions which are never protected by
any identified permission checks. However, this is a rare case, as itis quite unlikely that kernel developers failed to add any permis-
sion checks to protect a privileged function especially in recent
kernel versions. Third, ACHybmay get false positives in terms of
privileged function detection, as there may exist non-privileged
functionswhicharealsoprotectedbypermissionchecks.Fourth,
ACHybcannotguaranteethatallpotentiallyvulnerablepathscan
becoveredinagiventimebudget,whichmaycausefalsenegatives.
Nevertheless,thecoveragecanbeimprovedbyaddingmorediverse
seed programs. In future work, we will try to enhance ACHybto
overcome the above limitations. We also plan to upgrade ACHyb
to support more access control modules in the Linux kernel. In
addition,weplantoproposeeffectiveapproachestodetect KACV-S.
Onepossibledirectionwouldbetospecifythecorrectnessofthe
internal access control states and validate these states using the
specifications dynamically.
6 RELATED WORK
MissingCheckDetection. Detectingmissingchecksispioneered
by Englerâ€™s work [ 12], which attempts to automatically extract
the programmersâ€™ beliefs from the source code to detect missing
checks.Followingthisdirection,severalstaticanalysistoolshave
beenproposedtodetectmissingchecks. AutoISES [54]automati-
callyinfersthesecurityspecificationgivenasetofuser-provided
security checks and detects the security violations in the Linux
kernel.ROLECAST [52]leveragesthestandardsoftwareengineering
patterns/conventionstodetectthemissingsecuritychecksinthe
Webapplications. CRIX[31]proposesanovelpeerslicingapproach
to detect missing checks for the critical variables in the Linux ker-
nel.LRSan[60] proposes its specialized data-flow and control-flow
analysistodetectmissingrechecksforcriticalvariables. PeX[62]
is the state-of-the-art tool to detect themissing access control per-
mission checks ( KACV-M), which is the most related work to ACHyb.
ACHybdiffers from PeXin two main aspects. First, ACHybfocuses
ondetectingbothKACV-MandKACV-I.Second, ACHybperformsa
novel hybrid analysis to make the KACV detection both scalable
andprecise,while PeXisapurelystaticanalysistoolsufferingfrom
high false-positive rates.
Greybox Fuzzing of OS Kernel. Greybox fuzzing achieves big
success in revealing real-world vulnerabilities in recent decades
[33,59]. Several greybox fuzzers for OS kernel including Syzkaller
[57], TriforceAFL [ 19] and Trinity [ 22] have been released. Besides
the tool developments, researchers make great effort in enhanc-
ingboththeeffectivenessandtheefficiencyofthekernelfuzzing.
Breakthroughs have been made in the complex path condition
solving[4,24,26],seedgeneration[ 17],seeddistillation[ 42],file
systemtesting[ 25,61], driver/firmware testing[ 10,36,44,53,63],
325ACHyb: A Hybrid Analysis Approachto DetectKernelAccess Control Vulnerabilities ESEC/FSE â€™21, August 23â€“28, 2021,Athens,Greece
errorhandlingtesting[ 43],etc.Differentfromtheexistinggreybox
fuzzers,ACHybproposesanovelclustering-basedseeddistillation
approach to facilitate the greybox fuzzinginKACV detection.
Kernel Verification and Validation. Several approaches [ 3,13,
16,38,39,50] have been proposed to verify or validate the cor-
rectness of the kernel source code. For example, Serval[38] is
aframeworkforverifyingsystemsoftware.Givenaninterpreter
providedbyusers,itperformssymbolicexecutiononthesystem
code to do the verification. Besides, TESLA [ 3] provides users a
language to specify the dynamic safety properties of the Linux
kernel.Thespecifiedpropertiesarethenconvertedintorun-time
checks to validate the kernel. Different from the above approaches
which require the users to provide the specification of the Linux
kernel,ACHybis able to detect KACVs based on the invariants of
the access control.
7 CONCLUSION
In this paper, we first conduct an empirical study on KACVs using
National Vulnerability Database. Motivated by our study, we focus
on detecting two kinds of KACVs: KACV-MandKACV-I. We present
a precise and scalable hybrid analysis approach called ACHybto de-
tect both KACV-MandKACV-I.ACHybfirst performs a more precise
andmoresound staticanalysisto identifythe potentiallyvulnera-
ble paths, and then applies an efficient dynamic analysis to reduce
the false positives of these paths. Our experimental results show
thatACHyboutperforms PeX,thestate-of-the-artKACVdetector,in
terms of both the detection precision and the efficiency. Further-
more,ACHybdetects7newKACVs,2ofwhichhavebeenconfirmed
bythe kernel developers.
ACKNOWLEDGMENTS
WewouldliketothanktheanonymousFSEâ€™21reviewers,S&Pâ€™21
reviewersandkerneldevelopersfortheirvaluablefeedback.This
work was supported by Intel Strategic Research Alliance (ISRA)
grant,SRCgrantTS-2965,NSFgrants26101114,26101313,andCCF-
1718903, and a grant from the Army Research Office accomplished
under Cooperative Agreement Number W911NF-19-2-0333. The
views and conclusions contained in this document are those of the
authorsandshouldnotbeinterpretedasrepresentingtheofficial
policies,eitherexpressedorimplied,oftheArmyResearchOffice
or theU.S. Government.The U.S. Governmentis authorizedto re-
produce and distribute reprints for Government purposes notwith-
standingany copyright notation herein.
REFERENCES
[1]UriAlon,Meital Zilberstein,OmerLevy,andEranYahav.2018. Ageneralpath-
basedrepresentationforpredictingprogramproperties. ACMSIGPLANNotices
53,4 (2018), 404Å›419.
[2]Uri Alon, Meital Zilberstein, Omer Levy, and Eran Yahav. 2019. code2vec: Learn-
ing distributed representations of code. Proceedings of the ACM on Programming
Languages 3,POPL(2019), 1Å›29.
[3]Jonathan Anderson, Robert NM Watson, David Chisnall, Khilan Gudka, Ilias
Marinos, and Brooks Davis. 2014. TESLA: temporally enhanced system logic
assertions. In Proceedings of the Ninth European Conference on Computer Systems .
1Å›14.
[4]Cornelius Aschermann, Sergej Schumilo, Tim Blazytko, Robert Gawlik, and
Thorsten Holz. 2019. REDQUEEN: Fuzzing with Input-to-State Correspondence..
InTheNetworkandDistributedSystemSecuritySymposium(NDSS) ,Vol.19.1Å›15.
[5]Roberto Baldoni, Emilio Coppa, Daniele Cono Dâ€™elia, Camil Demetrescu, and
IreneFinocchi.2018.Asurveyofsymbolicexecutiontechniques. ACMComputing
Surveys(CSUR) 51,3 (2018), 1Å›39.[6]Pavol Bielik, Veselin Raychev, and Martin Vechev. 2016. PHOG: probabilistic
modelfor code. In InternationalConference onMachineLearning . 2933Å›2942.
[7]MarcelBÃ¶hme,Van-ThuanPham,Manh-DungNguyen,andAbhikRoychoudhury.
2017.Directedgreyboxfuzzing.In Proceedingsofthe2017ACMSIGSACConference
onComputer and Communications Security . 2329Å›2344.
[8]Matthieu Brucher. 2020. scikit-learn: Machine Learning in Python. https://scikit-
learn.org/stable/ .
[9]Peng Chenand HaoChen.2018. Angora: Efficientfuzzing byprincipledsearch.
In2018IEEE SymposiumonSecurityand Privacy (SP) . IEEE,711Å›725.
[10]Jake Corina, Aravind Machiry, Christopher Salls, Yan Shoshitaishvili, Shuang
Hao, ChristopherKruegel,and GiovanniVigna.2017. Difuze:Interface aware
fuzzing for kernel drivers. In Proceedings of the 2017 ACM SIGSAC Conference on
Computer and Communications Security . 2123Å›2138.
[11]Dulaunoy,MoreelsAlexandre,VinotPieter-Jan,andRaphael.2020.CVE-SEARCH
PROJECT. https://www.cve-search.org/ .
[12]Dawson Engler, David YuChen, SethHallem, Andy Chou, and Benjamin Chelf.
2001. Bugsasdeviantbehavior:Ageneralapproachtoinferringerrorsinsystems
code.ACMSIGOPSOperatingSystemsReview 35,5 (2001), 57Å›72.
[13]Andrew Ferraiuolo, Andrew Baumann, Chris Hawblitzel, and Bryan Parno. 2017.
Komodo:Usingverificationtodisentanglesecure-enclavehardwarefromsoft-
ware. In Proceedings of the 26th Symposium on Operating Systems Principles .
287Å›305.
[14]Google.2020. Systemandkernelsecurity. https://source.android.com/security/
overview/kernel-security .
[15]Andreas GrÃ¼nbacher. 2003. POSIX Access Control Lists on Linux.. In USENIX
Annual TechnicalConference, FREENIXTrack , Vol. 259272.
[16]XiaojieGuo,MaximeLesourd,MengqiLiu,LionelRieg,andZhongShao.2019.
Integrating Formal Schedulability Analysis into a Verified OS Kernel. In Interna-
tional Conference onComputer AidedVerification . Springer, 496Å›514.
[17]HyungSeok Han and Sang Kil Cha. 2017. Imf: Inferred model-based fuzzer. In
Proceedingsofthe2017ACMSIGSACConferenceonComputerandCommunications
Security. 2345Å›2358.
[18]Ahmad Hazimeh, Adrian Herrera, and Mathias Payer. 2020. Magma: A Ground-
Truth Fuzzing Benchmark. Proceedings of the ACM on Measurement and Analysis
ofComputingSystems 4,3 (2020), 1Å›29.
[19]JesseHertz.2016. AlinuxsystemcallfuzzerusingTriforceAFL. https://github.
com/nccgroup/TriforceLinuxSyscallFuzzer .
[20]Susan Horwitz, Phil Pfeiffer, and Thomas Reps. 1989. Dependence analysis
for pointer variables. In Proceedings of the ACM SIGPLAN 1989 Conference on
Programminglanguagedesignand implementation . 28Å›40.
[21]Joxan Jaffar, Vijayaraghavan Murali, Jorge A Navas, and Andrew E Santosa.
2012. Path-sensitivebackwardslicing.In InternationalStaticAnalysisSymposium .
Springer, 231Å›247.
[22]Dave Jones. 2011. Trinity: Linux system call fuzze. https://github.com/
kernelslacker/trinity .
[23]MichaelKerrisk.2019. overviewoflinuxcapabilities. http://man7.org/linux/man-
pages/man7/capabilities.7.html .
[24]KyungtaeKim,DaeRJeong,ChungHwanKim,YeongjinJang,InsikShin,and
Byoungyoung Lee. 2020. HFL: Hybrid Fuzzing on the Linux Kernel. In The
Network and DistributedSystemSecuritySymposium(NDSS) .
[25]Seulbae Kim, Meng Xu, Sanidhya Kashyap, Jungyeon Yoon, Wen Xu, and Taesoo
Kim. 2019. Finding semantic bugs in file systems with an extensible fuzzing
framework. In Proceedings of the 27th ACM Symposium on Operating Systems
Principles . 147Å›161.
[26]Su Yong Kim, Sangho Lee, Insu Yun, Wen Xu, Byoungyoung Lee, Youngtae
Yun, and Taesoo Kim. 2017. Cab-fuzz: Practical concolic testing techniques
for{COTS}operatingsystems. In 2017{USENIX}AnnualTechnicalConference
({USENIX}{ATC}17). 689Å›701.
[27]GeorgeKlees,AndrewRuef,BenjiCooper,ShiyiWei,andMichaelHicks.2018.
Evaluating fuzz testing. In Proceedings of the 2018 ACM SIGSAC Conference on
Computer and Communications Security . 2123Å›2138.
[28]BogdanKorelandJuergenRilling.1998.Programslicinginunderstandingoflarge
programs. In Proceedings. 6th International Workshop on Program Comprehension.
IWPCâ€™98 (Cat. No.98TB100242) . IEEE,145Å›152.
[29]Adam Lerer, Ledell Wu, Jiajun Shen, Timothee Lacroix, Luca Wehrstedt, Abhijit
Bose, and Alex Peysakhovich. 2019. Pytorch-biggraph: A large-scale graph
embeddingsystem. arXiv preprint arXiv:1903.12287 (2019).
[30]Aristidis Likas, Nikos Vlassis, and Jakob J Verbeek. 2003. The global k-means
clustering algorithm. Patternrecognition 36,2 (2003), 451Å›461.
[31]KangjieLu,AdityaPakki,andQiushiWu.2019. Detectingmissing-checkbugs
viasemantic-andcontext-awarecriticalnessandconstraintsinferences.In 28th
{USENIX}SecuritySymposium( {USENIX}Security19) . 1769Å›1786.
[32]Aravind Machiry, Chad Spensky, Jake Corina, Nick Stephens, Christopher
Kruegel, and Giovanni Vigna. 2017. {DR}.{CHECKER}: A soundy analysis
for linux kernel drivers. In 26th{USENIX}Security Symposium ( {USENIX}Secu-
rity 17). 1007Å›1024.
[33]Valentin Jean Marie ManÃ¨s, HyungSeok Han, Choongwoo Han, Sang Kil Cha,
Manuel Egele, Edward J Schwartz, and Maverick Woo. 2019. The art, science,
326ESEC/FSE â€™21, August 23â€“28, 2021,Athens,Greece Yang Hu,WenxiWang,Casen Hunger, Riley Wood, Sarfraz Khurshid,andMohitTiwari
and engineering of fuzzing: A survey. IEEE Transactions on Software Engineering
(2019).
[34]DrorE Maydan,JohnLHennessy,andMonicaSLam.1991. Efficient andexact
datadependenceanalysis.In ProceedingsoftheACMSIGPLAN1991conferenceon
Programminglanguagedesignand implementation . 1Å›14.
[35]PatrickEMcKnightand JuliusNajab.2010. Mann-WhitneyUTest. TheCorsini
encyclopediaofpsychology (2010), 1Å›1.
[36]AlejandroMera,BoFeng,LongLu,EnginKirda,andWilliamRobertson.2021.
DICE: Automatic Emulation of DMA Input Channels for Dynamic Firmware
Analysis. In 2021IEEE SymposiumonSecurityand Privacy (SP) . IEEE.
[37]Steven Muchnick et al .1997.Advanced compiler design implementation . Morgan
kaufmann.
[38]LukeNelson,JamesBornholt,RonghuiGu,AndrewBaumann,EminaTorlak,and
XiWang.2019. Scalingsymbolicevaluationforautomatedverificationofsystems
codewithServal.In Proceedingsofthe27thACMSymposiumonOperatingSystems
Principles . 225Å›242.
[39]LukeNelson,HelgiSigurbjarnarson,KaiyuanZhang,DylanJohnson,JamesBorn-
holt,EminaTorlak,andXiWang.2017. Hyperkernel:Push-buttonverification
of an OS kernel. In Proceedings of the 26th Symposium on Operating Systems
Principles . 252Å›269.
[40] NIST. 2020. National Vulnerability Database. https://nvd.nist.gov/ .
[41]SebastianÃ–sterlund,KavehRazavi,HerbertBos,andCristianoGiuffrida.2020.
Parmesan: Sanitizer-guided greybox fuzzing. In 29th{USENIX}Security Sympo-
sium ({USENIX}Security20) . 2289Å›2306.
[42]Shankara Pailoor, Andrew Aday, and Suman Jana. 2018. MoonShine: Optimizing
{OS}FuzzerSeedSelectionwithTraceDistillation.In 27th{USENIX}Security
Symposium({USENIX}Security18) . 729Å›743.
[43]Aditya Pakki and Kangjie Lu. 2020. Exaggerated Error Handling Hurts! An
In-DepthStudyandContext-AwareDetection.In Proceedingsofthe2020ACM
SIGSAC Conference onComputer and Communications Security .
[44]Hui Peng and Mathias Payer. 2020. USBFuzz: A Framework for Fuzzing USB
Driversby Device Emulation. (2020).
[45]LLVM Project. 2020. Writing an LLVM Pass. https://llvm.org/docs/
WritingAnLLVMPass.html .
[46]TristanRavitch.2020. WholeProgramLLVM. https://github.com/travitch/whole-
program-llvm .
[47]VeselinRaychev,PavolBielik,MartinVechev,andAndreasKrause.2016.Learning
programsfrom noisydata. ACMSIGPLAN Notices 51,1 (2016), 761Å›774.
[48]Ravi S Sandhu and Pierangela Samarati. 1994. Access control: principle and
practice. IEEE communicationsmagazine 32,9 (1994), 40Å›48.
[49]SGI,OSDL,andBull.2012.LinuxTestProject. https://linux-test-project.github.io .[50]Helgi Sigurbjarnarson, Luke Nelson, Bruno Castro-Karney, James Bornholt, Em-
ina Torlak,and Xi Wang. 2018. Nickel: A framework for design and verification
of information flow control systems. In 13th{USENIX}Symposium on Operating
SystemsDesignand Implementation( {OSDI}18). 287Å›305.
[51]StephenSmalley,TimothyFraser,andChrisVance.2020. LinuxSecurityModules:
General Security Hooks for Linux. https://www.kernel.org/doc/html/latest/
security/lsm.html .
[52]SooelSon,KathrynSMcKinley,andVitalyShmatikov.2011. Rolecast:finding
missing security checks when you do not know what checks are. In Proceedings
of the 2011 ACM international conference on Object oriented programming systems
languagesand applications . 1069Å›1084.
[53]DokyungSong,FelicitasHetzelt,DipanjanDas,ChadSpensky,YeoulNa,Stijn
Volckaert,GiovanniVigna,ChristopherKruegel,Jean-PierreSeifert,andMichael
Franz. 2019. PeriScope: An Effective Probing and Fuzzing Framework for the
Hardware-OS Boundary.. In The Network and Distributed System Security Sympo-
sium (NDSS) .
[54]Lin Tan, Xiaolan Zhang, Xiao Ma, Weiwei Xiong, and Yuanyuan Zhou. 2008. Au-
toISES: Automatically Inferring Security Specification and Detecting Violations..
InUSENIXSecuritySymposium . 379Å›394.
[55]TheClangTeam.2019. Clang9documentation. https://releases.llvm.org/9.0.0/
tools/clang/docs/ReleaseNotes.html .
[56] DmitryVyukov. 2015. syzbot. https://syzkaller.appspot.com/upstream .
[57] DmitryVyukov. 2015. Syzkaller. https://github.com/google/syzkaller .
[58]Ke Wang, Rishabh Singh, and Zhendong Su. 2018. Search, align, and repair:
data-driven feedback generation for introductory programming exercises. In
Proceedings of the 39th ACM SIGPLAN Conference on Programming Language
Designand Implementation . 481Å›495.
[59]PengfeiWangandXuZhou.2020. SoK:TheProgress,Challenges,andPerspec-
tivesof Directed GreyboxFuzzing. arXiv preprint arXiv:2005.11907 (2020).
[60]WenwenWang,KangjieLu,andPen-ChungYew.2018. Checkitagain:Detecting
lacking-recheck bugs in os kernels. In Proceedings of the 2018 ACM SIGSAC
Conference onComputer and Communications Security . 1899Å›1913.
[61]WenXu,HyungonMoon,SanidhyaKashyap,Po-NingTseng,andTaesooKim.
2019. Fuzzing file systems via two-dimensional input space exploration. In 2019
IEEE SymposiumonSecurityand Privacy (SP) . IEEE,818Å›834.
[62]Tong Zhang, Wenbo Shen, Dongyoon Lee, Changhee Jung, Ahmed M Azab, and
Ruowen Wang. 2019. Pex: A permission check analysis framework for linux
kernel. In 28th{USENIX}Security Symposium ( {USENIX}Security 19) . 1205Å›
1220.
[63]Yaowen Zheng, Ali Davanian, Heng Yin, Chengyu Song, Hongsong Zhu, and
LiminSun.2019. FIRM-AFL:high-throughputgreyboxfuzzingofiotfirmwarevia
augmentedprocessemulation.In 28th{USENIX}SecuritySymposium( {USENIX}
Security19) . 1099Å›1114.
327