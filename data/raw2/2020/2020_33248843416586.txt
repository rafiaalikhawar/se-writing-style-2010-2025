Synthesis of Infinite-State Systems with Random Behavior
Andreas Katis
katis001@umn.edu
University of Minnesota, USAGrigory Fedyukovich
grigory@cs.fsu.edu
Florida State University, USAJeffrey Chen
chen4233@umn.edu
University of Minnesota, USA
David Greve
david.greve@collins.com
Collins Aerospace, USASanjai Rayadurgam
rsanjai@umn.edu
University of Minnesota, USAMichael W. Whalen
whalen@cs.umn.edu
University of Minnesota, USA
ABSTRACT
Diversity in the exhibited behavior of a given system is a desirable
characteristic in a variety of application contexts. Synthesis of con-
formantimplementationsoftenproceedsbydiscoveringwitnessing
Skolem functions, which are traditionally deterministic. In this
paper, we present a novel Skolem extraction algorithm to enable
synthesisofwitnesseswithrandombehavioranddemonstrateits
applicability in the context of reactive systems. The synthesized
solutions are guaranteed by design to meet the given specification,
while exhibiting a high degree of diversity in their responses to
externalstimuli.Casestudiesdemonstratehowourproposedframe-
work unveils a novel application of synthesis in model-based fuzz
testing to generate fuzzers of competitive performance to general-
purpose alternatives, as well as the practical utility of synthesized
controllers in robot motion planning problems.
ACM Reference Format:
Andreas Katis, Grigory Fedyukovich, Jeffrey Chen, David Greve, Sanjai
Rayadurgam, and Michael W. Whalen. 2020. Synthesis of Infinite-State
Systems with Random Behavior. In 35th IEEE/ACM International Conference
onAutomatedSoftwareEngineering(ASE’20),September21–25,2020,Virtual
Event, Australia. ACM, New York, NY, USA, 12 pages. https://doi.org/10.
1145/3324884.3416586
1 INTRODUCTION
Programsynthesis aimsatautomatedgenerationofimplementations
that meet formal specifications. It has been thoroughly explored
in various contexts, such as controller synthesis and automatedprogram repair [
2,3,11,14,24,35,37]. The implementations are
generatedfromofthespecification’srealizabilityandhavetheform
ofdeterministic witnesses. Thus, by design they always compute
(1) an output that meets the specification, and (2) the same output
for each particular input. Determinism, however, prevents us from
synthesizingsystemsthattakeadvantageof randomness todiversify
their behavior1. Advantages offered by these systems can be better
1For the sake of brevity, throughout the paper, we refer to such systems using the
adjective random(e.g.randomsystem/design/witness/controller).
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACM
mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ASE ’20, September 21–25, 2020, Virtual Event, Australia
© 2020 Association for Computing Machinery.
ACM ISBN 978-1-4503-6768-4/20/09...$15.00
https://doi.org/10.1145/3324884.3416586understood when put into context of robot motion planning and
fuzz testing.
Fuzz testing .Synthesisofrandomdesignsallowsonetospec-
ifyandcreatesystem-specific fuzzers[34].Theideaistofollowa
mindsetsimilartohow model-basedtesting techniquesutilizethe
system-under-test(SUT)specificationtogeneratetestcases[ 45].
We propose to use the fragment of the model related to the SUT
inputstosynthesizeafuzzerthatrepeatedlygeneratesrandom(and
sometimes malformed) tests. This fragment can be alternatively
viewed as the fuzzer’s specification, which can be further enriched
withpropertiesthatdictateitsbehaviorwhencertaintestingobjec-
tivesaremet.Forexample,whenavulnerabilityisdetected,wecan
limit the fuzzer’s next generated test cases within a desired range
around the test that exposed the issue. System coverage is also one
such objective, where we can dictate how the fuzzer diversifies the
generated tests through its specification, improving the chances of
reachingpreviouslyunexploredsystemstates.Fromaqualitative
standpoint, synthesis in model-based fuzz testing can be consid-
eredasaviablehigh-levelsolutionthatdoesnotrequiretheuser
to createextensive corpora oftests. Furthermore, thesynthesized
fuzzerscanbeastrong,SUT-specificalternativetogeneral-purpose
model-based fuzzers. [4, 25, 46].
Robotmotion planning . In coverage path planning problems,
the goal is to maximize the area that a robot can cover while avoid-
ing obstacles[ 23]. Furthermore,randomness canserve asan addi-
tional security barrier in avoidance games that involve adversaries
with learning capabilities. A random strategy is inherently harder
toinferandexploit.Inthespecialcaseofinfinite-stateproblems,
it is an even bigger challenge, as the current state-of-the-art in
automata learning is limited to finite-state problems [26].
Wetreatsystemsintheaforementionedapplicationsasso-called
reactive systems, which have to exhibit specification-compliant be-
havioragainstanunpredictableenvironment.Examplesarecom-
monlyfoundinaviation,autonomousvehicles,andmedicaldevices.
Synthesis of random reactive designs is offered by the recent Reac-
tive Control Improvisation (RCI) [ 19,20] framework, but limited
onlytofinite-statesystems(i.e.,overthebooleandomain),relies
on probabilistic analysis to determine the realizability of the speci-
fication,anditssynthesizedwitnessesrequirefurtherrefinement
to be applicable in real world scenarios.
We present a novel approach to synthesis of random infinite-
state systems, whose corresponding specifications may involve
constraints over the Linear Integer or Real Arithmetic theories
(LIRA)[5]andthusnotlimitedtofinite-statesystems.Theintuition
behindthiseffortistoallowreasoning,andconsequentlysynthesis,
2502020 35th IEEE/ACM International Conference on Automated Software Engineering (ASE)
ASE ’20, September 21–25, 2020, Virtual Event, Australia Andreas Katis, Grigory Fedyukovich, Jeffrey Chen, David Greve, Sanjai Rayadurgam, and Michael W. Whalen
over ranges of safe reactions instead of computing witnesses with
deterministic responses.
The pursuit of generality poses new challenges, for which we
propose a novel Skolemization procedure tosimulate randomness.
We build on top of state-of-the-art reactive synthesis approach for
deterministicsystemscalledJSyn-vg[ 28].Ititerativelygenerates
a greatest fixpoint over system states that ensures the realizabil-
ityofthegivenspecificationbutoffersonlyabruteandinflexible
strategyforwitnessextraction(viapredeterminedSkolemization
rules) [14–16]. Our key novelty is in a new algorithm that enables
replacing deterministic assignments in the Skolem functions with
applicationsof uninterpretedrandomnumbergenerators.Uninter-
pretedfunctionsallowustoreasonaboutsolutionswithrandom,
broad, and most importantly, compliant behavior.
ThenewSkolemextractionalgorithmpreservesJSyn-vg’simpor-
tantproperties.Thus,theprocedureremainscompletelyautomated,
unlikepreviousworkoninfinite-statesynthesisthatrequiresad-
ditional templates, or the user’s intervention [ 3,7,17,42]. More
importantly, our work imposes no performance overheads over
JSyn-vg, remaining thus competitive with other state-of-the-art
tools which could be considered for random synthesis [ 35]. We
implementedtheSkolemextractionalgorithmandapplieditintwo
distinct case studies.
Model-based fuzz testing . We are the first to explore the appli-
cability of reactive synthesis in fuzz testing. On a chosen set of
applications designed forthe DARPA Cyber Grand Challenge[ 18,
33], the synthesized fuzzers performed competitively against well-
established tools (AFL [ 47], AFLFast [ 9]), both in terms of code
coverage as well as exposing vulnerabilities.Robot motion planning
. We synthesized safe robot controllers
thatparticipateinavoidancegamesonbothboundedandinfinite
arenas. Using simulation, we show how the synthesized controller
leads to the robot being capable of avoiding its adversary while
moving in random patterns. We demonstrate how the synthesized
strategiesaresafebydesign,nomatterwhatbiasisintroducedatthe
implementation level. Furthermore, we showcase why randomness
in the controller behavior is a mandatory feature, if synthesis is to
be considered for coverage path planning problems.
To summarize, the contributions of this work are:
/squaresolidthe first complete formal framework that enables specification
and synthesis of random infinite-state reactive systems;
/squaresolidanovelSkolemizationprocedurethatenablesrandomsynthesis
withnoperformanceoverhead,bytakingadvantageofuninter-
preted functions to reason about ranges of valid reactions;
/squaresolida novel application of synthesis in model-based fuzz testing,
where we generated reactive fuzzers, yielding competitive re-
sults in terms of system coverage and vulnerability detection;
and
/squaresolidthe application of synthesized random controllers in safety prob-
lems for robot motion planning, outlining important advantages
over deterministic solutions.
Therestofthepaperisstructuredasfollows.Sect.2providesthe
necessary formal background on which our work depends. Sect. 3
illustratesandSect.4describesindetailthealgorithmforsynthesis
of random Skolem functions. The implementation is outlined inAlgorithm 1: JSyn-vg/parenleftBig
A(/vecx,/vecy),GI(/vecy),GT(/vecy,/vecx,/vecy/prime)/parenrightBig
, cf. [28].
Input:A(/vecx,/vecy): assumptions, GI(/vecy),GT(/vecy,/vecx,/vecy/prime): guarantees
Output: /angbracketleftrealizable ,Skolem/angbracketright/unrealizable
1F(/vecy)←/latticetop;
2while/latticetopdo
3ϕ←∀/vecx,/vecy.(F(/vecy)∧A(/vecx,/vecy)⇒∃/vecy/prime.GT(/vecy,/vecx,/vecy/prime)∧F(/vecy/prime));
4/angbracketleftvalid,validRegion(/vec x,/vecy),Skolem/angbracketright←AE-VAL(ϕ);
5ifvalidthen
6 if∃/vecy.GI(/vecy)∧F(/vecy)then return /angbracketleftrealizable ,Skolem/angbracketright;
7 else return unrealizable;
8elseF(/vecy)←F(/vecy)∧¬ExtractUnsafe(validRegion(/vec x,/vecy));
9end
Sect. 5 and the case studies are presented in Sect 6 and Sect. 7.
Finally, we discuss related work in Sect. 9 and conclude in Sect. 10.
2 BACKGROUND AND NOTATION
Afirst-orderformula φissatisfiableifthereexistsanassignment m,
calledamodel,underwhich φevaluatesto /latticetop(denotedm|=φ).Ifev-
erymodelof φisalsoamodelof ψ,thenwewrite φ⇒ψ.Aformula
φis calledvalidif/latticetop⇒φ. For existentially-quantified formulas
oftheform ∃y.ψ(x,y),validityrequiresthateachassignmentof
variables in xcan beextended to a model of ψ(x,y). For a valid for-
mula ∃y.ψ(x,y), a termsky(x)is called a Skolem,i f ψ(x,sky(x))is
valid. More generally, for a valid formula ∃/vecy.ψ(x,/vecy)over a vector
of existentially quantified variables /vecy, there exists a vector of indi-
vidualSkolemterms,oneforeachvariable /vecy[j],where0<j≤N
andN=|/vecy|, such that: /latticetop⇒ψ(x,sk/vecy[1](x),...,sk/vecy[N](x)).
2.1 Synthesis with JSyn-vg
Webuildontopof JSyn-vg,areactivesynthesisprocedurethattakes
formal specifications in the form of Assume-Guarantee contracts.
Systemsaredescribedintermsofinputs /vecxandoutputs /vecy,usingthe
predicate I(/vecy)to denote the set of initial outputs and T(/vecy,/vecx,/vecy/prime)for
thesystem’stransitionrelation,wherethenext(primed)outputs /vecy/prime
dependonthecurrentinputandstate. Assumptions A(/vecx,/vecy)corre-
spondtoassertionsoverthesystem’scurrentstate,whilethesetof
guarantees isdecomposed intoconstraintsover theinitialoutputs
GI(/vecy), and guarantees GT(/vecy,/vecx,/vecy/prime)that have to hold over any valid
transition (i.e., with respect to T(/vecy,/vecx,/vecy/prime)).
The algorithm behind JSyn-vg performs a realizability analysis
todeterminetheexistenceofagreatestfixpointofstatesmeeting
the contract, that can lead to an implementation. Furthermore, the
computed fixpoint can be directly used for the purposes of synthe-
sis,asitpreciselycapturesacollectionofsystemoutputconstraints
which, when instantiated, define safe reactions. Formally, the com-
puted fixpoint is a set of viableoutputs, guaranteed to preserve
safety by requiring that a valid transition to another viable output
is always available.
Viable(/vecy)def=∀/vecx,/vecy.(A(/vecx,/vecy)⇒∃/vecy/prime.GT(/vecy,/vecx,/vecy/prime)∧Viable(/vec y/prime))(1)
The coinductivedefinition of viable statesis sufficient to prove
the realizability of a contract, as long as the corresponding deci-sion procedure can find a viable output that satisfies the initial
251Synthesis of Infinite-State Systems with Random Behavior ASE ’20, September 21–25, 2020, Virtual Event, Australia
guarantees GI(/vecy):
∃/vecy.GI(/vecy)∧Viable(/vec y)
Given a proof of the contract’s realizability, the problem of
synthesis is formally defined as the process of computing an ini-
tial output /vecyinitand a function f(/vecx,/vecy)such that GI(/vecyinit)and
∀/vecx,/vecy.Viable(/vecy)⇒Viable(f(/vecx,/vecy))hold true.
Alg. 1 summarizes JSyn-vg. It begins with the generic candidate
fixpointF(/vecy)=/latticetopand solves the ∀∃-formula ϕfor the validity
(line4)thatcorrespondstothedefinitionofviableoutputsinEq.1.If
ϕisvalidandanoutputvectorin F(/vecy)existsthatsatisfiestheinitial
guarantees,thenthecontractisdeclaredrealizable,andawitnessing
Skolem term is extracted. If ϕis invalid, the algorithm extracts the
largestsubsetof F(/vecy)∧A(/vecx,/vecy),denoted validRegion(/vec x,/vecy),suchthat
the following formula is valid:
∀/vecx,/vecy.(validRegion(/vec x,/vecy)⇒∃/vecy/prime.GT(/vecy,/vecx,/vecy/prime)∧F(/vecy/prime))
Due to the possibility of validRegion(/vec x,/vecy)strengthening the as-
sumptions A(/vecx,/vecy), we additionally extract a set of constraints over
unsafestates(ExtractUnsafe)from validRegion(/vec x,/vecy).Thenega-
tion of this set is then added as a new conjunct to the candidate
F(/vecy)andthealgorithmiteratesuntileither ϕisvalidor F(/vecy)=⊥.
For further details, we refer the reader to the original paper on
JSyn-vg[28].
2.2 Realizability and Synthesis withAE-VAL
The greatest fixpoint algorithm described by JSyn-vg uses AE-
VAL, an algorithm to determine the validity of ∀∃-formulas and
to generate(deterministic) witnessesin theform of Skolemterms.
Thelatterfeatureisalsothepointofinterestbehindthiswork,as
randomnesscanbeintroducedthroughreplacingthepartof AE-
VAL’s Skolemization strategy with our new proposed algorithm.
Alg. 2 gives a brief pseudocode of AE-VAL2. The idea is to enu-
merate all models of /vecxand to extend each of them to a model of
y. Because a naive enumeration would be endless, AE-VAL gen-
eratesasequenceofModel-BasedProjections(MBPs)[ 8]eachof
whichgroups modelsof /vecx.Formally,anMBPfor model misa for-
mulaP(/vecx), such that m|=P(/vecx), andP⇒∃y.ψ(/vecx,y). To create it,
AE-VALgathersallliteralsof ψwhichareevaluatedtotrueby m
(line6). Theseliterals arefurtherreferred toas Skolemconstraints
π.Inlineararithmetic,eachSkolemconstraintiscomposedonlyof
arithmeticrelations,linearcombinationsover /vecxandy,andnumeric
constants. Finally, to obtain an MBP pre, AE-VAL just eliminates y
from the conjunction of Skolem constraints (line 7).
TheExtractSkprocedure,usedforSkolemextraction,imple-
ments an inflexible strategy to transform Skolem constraints to
local Skolem terms (we refer the reader to the original paper on
AE-VAL for further details [ 15]). The final Skolem term has a form
of adecision tree, where preconditions are placed on the nodes and
localSkolemterms(i.e.,outputsof ExtractSk)areontheleaves,
i.e., the nested if-then-else structure (ite (·)):
sky(/vecx)def=ite(pre[1],sk1,y(/vecx),ite(pre[2],sk2,y(/vecx),...,
(ite(pre[M−1],skM−1,y(/vecx),skM,y(/vecx)))))
2Note that for simplicity of presentation, in the pseudocode we assume a single
existentiallyquantifiedvariable y(however,thealgorithmandtheimplementation
can handle any vector /vecy).Algorithm 2: AE-VAL/parenleftBig
∀/vecx∃y.ψ(/vecx,y)/parenrightBig
, cf. [15, 16].
Input: ∀/vecx∃y.ψ(/vecx,y)
Data:MBPspre, Skolem constraints π, Skolem terms sk
Output:Return value ∈{valid,invalid}of∀/vecx∃y.ψ(/vecx,y),
validRegion, Skolem
1M←1;
2while/latticetopdo
3ifM−1/logicalandtext.1
i=1¬pre[i](/vecx)⇒⊥then
4 return/angbracketleftvalid,/latticetop,DecisionTree(pre ,sk)/angbracketright;
5if∃m|=ψ(/vecx,y)∧M−1/logicalandtext.1
i=1¬pre[i](/vecx)then
6 π[M](/vecx,y)←{/lscript|/lscript∈literals(ψ)∧m|=/lscript};
7 pre[M](/vecx)←QElim(y,π[M](/vecx,y));
8 sk[M](/vecx,y)←ExtractSk(/vec x,y,/logicalandtext.1
c∈π[M](/vecx,y)c);
9 M←M+1;
10else return /angbracketleftinvalid,M−1/logicalortext.1
i=1pre[i](/vecx),/emptysetAlt2/angbracketright;
Finally,inthecasethattheinputformula ∀/vecx∃y.ψ(/vecx,y)isinvalid,
AE-VAL returnsM−1/logicalortext.1
i=1pre[i](/vecx)as the formula’s maximal region of
validity,i.e.,themaximalsetofmodelsoftheuniversallyquantified
variables for which the formula becomes valid. This region is used
by JSyn-vg in order to further refine the candidate fixpoint during
each of its iterations (Alg. 1, line 8).
3 RANDOM SYNTHESIS - MOTIVATING
EXAMPLE
In this section, we demonstrate a complete run of the synthesis
procedureandshowhowthestandardsynthesizedwitnessesare
unable to exhibit random behavior. As an example, we use a safety
robot motion planning problem from Neider et al. [ 35]. In this
problem, a robot is placed on a one-dimensional grid with two
players,theenvironmentandthesystem,controllingitsmovement.Eachplayercanchoosetoeithermovetherobotleftorright,ornot
moveitatall(werefertothesechoicesusingthevalues
−1,0,1).The
robot startsat position=0, andthe safety propertyfor the system
is to retain the robot in the area of the grid for which position≥0.
Fig. 1 shows an Assume-Guarantee contract for the example,
described in the Lustre language. The contract has the singletoninput
/vecx={x}(internally identified by the - -%REALIZABLE
statement) and the outputs /vecy={y,position}3. The contract as-
sumption is that the environment will only make legal choices, i.e.,
A(/vecx,/vecy)def=−1≤x∧x≤1. The initial guarantee refers to the initial
position of the robot and the system choices for movement, i.e.,
GI(/vecy)def=(position =0)∧(−1≤y∧y≤1).Ontheotherhand,the
transitional guarantee captures the safety property along with the
statefulcomputationstepforthenewposition,i.e., GT(/vecy,/vecx,/vecy/prime)def=
(position/prime=position+x+y/prime)∧(position/prime≥0)∧(−1≤y/prime∧y/prime≤1)
(thetransitionrelationfor positionisdefinedusingLustre’s ->and
3Variableproperty is local to the contract. Formally, local variables are treated as
system outputs.
252ASE ’20, September 21–25, 2020, Virtual Event, Australia Andreas Katis, Grigory Fedyukovich, Jeffrey Chen, David Greve, Sanjai Rayadurgam, and Michael W. Whalen
node onedim(x,y : int) re turns();
var
ok1, ok2 : bool;
position : int;
let
assert x >= −1 and x <= 1;
position = 0 −> (pre(position) + x + y);
ok1 = y >= −1 and y <= 1;
ok2 = position >= 0;
−−%PROPERTY ok1;
−−%PROPERTY ok2;
−−%REALIZABLE x;
tel;
Figure 1: Assume-Guarantee contract in Lustre.
void skolem() {
if(position + x == 1) {
y=−1;
} else if (position + x >= −1& &
position + x <= 0) {
y=−(position + x);
}e l s e{
y=0 ;
}
}
Figure 2: Synthesized deterministic witness in C.
preoperators).4The safety properties are captured by ok1and
ok2(declared as such using - -%PROPERTY).
TheprocedurebeginswithacalltoJSyn-vgusingthecontract
as its input. The contract is realizable and the greatest fixpoint
of viable states is F(/vecy)def=position≥0. AE-VAL declares that the
formulaϕdef=∀/vecy,/vecx.(A(/vecx,/vecy)∧F(/vecy)⇒∃/vecy/prime.GT(/vecy,/vecx,/vecy/prime)∧F(/vecy/prime)isvalid
and extracts a Skolem term as a witness. Fig. 2 presents a direct
translationofthefunctiontoC.Thesynthesizedimplementation
behaves in a deterministic way under the following conditions:
(1)whenever position+x=1, the system chooses to move left
(y=−1);
(2)ifposition+xequals0 or-1,then thesystem choosestodo
nothing or move right, respectively ( y=−(position +x));
(3)for any other case, the system chooses to do nothing ( y=0).
Whiletheimplementationpreservessafety,thesetofpossible
actions are limited due to the deterministic assignments to the
outputy. Interestingly, for this particular implementation the sys-
temforcestherobottogobacktopositionsthataredangerously
close to the unsafe region! Similarly, the corresponding solution
byNeideretal.isthewinningset [0,3),whichwouldtranslateto
implementations where the system would never move the robot
beyondposition=2.Nevertheless,implementationsexistforwhich
thesystemcanexerciseabroadersetofbehaviors.Forthisexample
4Intuitively, the problem is formalized in a manner where the position of the robot is
updatedafterbothplayersmakeachoice,withthesystemreactingtothechoiceof
the environment.inparticular,wheneithercondition(1)or(3)istrue,thesystemcan
freelychooseanypossiblemoveactionwithoutviolatingthesafety
properties. Fig. 3 shows an implementation that can (theoretically)
exerciseanysuchpossibleassignment(weexplainwhyinSect.4.2).
Inthefollowingsections,wepresentanewmethodtosynthesize
a random witness that can, in theory, provide all such possible
permutations using a single implementation.
4 SYNTHESIZING RANDOM DESIGNS
ThestandardSkolemtermextractionalgorithminAE-VALdoesnot
support the generation of Skolem functions with random variable
assignments.Inthissection,wepresentanewproceduretocompute
witnesses that can be used to simulate random behavior.
4.1 Overview
Our proposed algorithm preserves the overall structure of AE-VAL
as well as the soundness of its results [ 15]. The main idea is to
replace the deterministic assignments that eventually appear in
the leaves of the generated decision tree with applications of unin-
terpreted functions, which when translated at the implementation
level,canbeviewedasfunctioncallstoauser-definedrandomnum-
ber generator. We refer to these functions as uninterpreted random
number generators :
Definition4.1(UninterpretedRandomNumberGenerator(URNG)).
URNG is an uninterpreted function
frng(H,/lscriptclosed,uclosed,l,u):T1×...×T|D|×B×B×T×T→T,
whereT:{Z,R},Hisacollectionofrightsideexpressionsextracted
from the set of disequalities D,/lscriptandudetermine the bounded
interval for the randomly generated value, and /lscriptclosed,uclosedare
booleanflags that,whenset, identifythecorresponding boundasbeingclosed.Withoutlossofgenerality,werequirethefollowing
postconditions to hold, on any supplied implementation of frng:
(1)∀h∈H.frng(H,_,_,_,_)/nequalh
Algorithm 3: ExtractSk(/vec x,y,π)
Input:Variables /vecx,y, Skolem constraints
π(/vecx,y)=/logicalandtext.1
r∈E∪D∪G∪GE∪L∪LEr(/vecx,y)
Output:Termsk, such that (y=sk(/vecx)) ⇒π(/vecx,y)
1/lscriptclosed←⊥,uclosed←⊥;
2ifE/nequal/emptysetAlt2then return ASN(e), s.t.e∈E;
3ifG∪GE/nequal/emptysetAlt2then
4/lscript←MAX(G∪GE);
5/lscriptclosed←G=/emptysetAlt2∨MAX( G)<MAX(GE);
6ifL∪LE/nequal/emptysetAlt2then
7u←MIN(L∪LE);
8uclosed←L=/emptysetAlt2∨MIN(L)>MIN(LE);
9if/lscript(/vecx)=u(/vecx)then return /lscript;
10H←{ASN(d)|d∈D};
11if/lscript=undef∧u=undefthen return frng(H,/latticetop,/latticetop,−∞,+∞);
12if/lscript=undefthen return frng(H,/latticetop,uclosed,−∞,u);
13ifu=undefthen return frng(H,/lscriptclosed,/latticetop,/lscript ,+∞);
14returnfrng(H,/lscriptclosed,uclosed,/lscript ,u)
253Synthesis of Infinite-State Systems with Random Behavior ASE ’20, September 21–25, 2020, Virtual Event, Australia
(2)frng(H,⊥,⊥,/lscript,u)∈(/lscript,u)
(3)frng(H,⊥,/latticetop,/lscript,u)∈(/lscript,u]
(4)frng(H,/latticetop,⊥,/lscript,u)∈[/lscript,u)
(5)frng(H,/latticetop,/latticetop,/lscript,u)∈[/lscript,u]
The use of URNGs allows us to reason about valid regions of
valuesforvariableassignmentsinsteadofaparticularvalue.Fur-
thermore, the postconditions defined for these functions play an
integral role in determining the soundness of the resulting Skolem
function. It is important to note that we do not have to reason
regarding the emptiness of the intervals. The intuition behind this
is that such computed constraints infer an unrealizable contract.
In these scenarios AE-VAL would declare the input ∀∃-formula
as invalid, and the Skolem extraction algorithm would never be
invoked.
4.2 Algorithm
Alg.3showsourproposedprocedureforextractingSkolemfunc-
tionsthatallowforrandomchoices.ItisinvokedfromAlg.2and
takes a set of universally quantified variables /vecx, an existentially
quantifiedvariable y,andSkolemconstraints πcomputedinAlg.2.
Alg.3constructsagraphofafunctionthatisembeddedinarela-
tion,specifiedbyaconjunctionofexpressionsovertherelational
operators {=,/nequal,>,≥,≤,<}, using the following constraints:
Edef={y=fi(x)}iDdef={y/nequalfi(x)}iGdef={y>fi(x)}i
GEdef={y≥fi(x)}iLEdef={y≤fi(x)}iLdef={y<fi(x)}i
Inadditiontotheconstraintsabove,Alg.3alsoutilizesthefol-
lowing helper functions (where ∼∈{<,≤,=,/nequal,≥,>}):
ASN(y∼e(x))def=eMIN({s})def=ASN(s)MAX({s})def=ASN(s)
MIN(S)def=ite(ASN(s)(≤)MIN(S\{s}),ASN(s),MIN(S\{s})),s∈S
MAX(S)def=ite(ASN(s)(≥)MAX(S\{s}),ASN(s),MAX(S\{s})),s∈S
OperatorMIN(MAX)computesasymbolicminimum(maximum)
of the given set of constraints. While the algorithm is applicable
forbothLIAandLRA,thefollowingtransformationsareusedfor
the case of integers:
A<B
A≤B−1A≥B
A>B−1
These transformations help avoid clauses containing <and≥.
Line 1 initializes the value of the boolean flags /lscriptclosedanduclosedto
false,andline2handlesthecasewhereequalityconstraintsexist
overy. Lines 3 to 8 construct the expressions for the lower and
upper bounds, and the truth of the flags depends on the (symbolic)
comparison between the symbolic minima and maxima. Line 9handles the case where the lower bound is equal to the upperbound. It should be noted that for cases handled by lines 2 and 9
only deterministic choices exists.
Lines 10 to 14 attempt to compute an expression containing
a URNG that considers the set of disequalities D. First, the algo-
rithmextractstheright-handsideofdisequalitiesinline10.Ifbothbounds are undefined, line 11 returns the application of the URNG
frng(H,/latticetop,/latticetop,−∞,+∞), where−∞and+∞are represented as free
variablesthatcanbelatermappedrespectivelytotheminimumand
maximum arithmetic representations supported by the implemen-
tation (e.g. INT_MIN andINT_MAX for integers in C). If only the
lowerboundisundefined(line12),weuse frng(H,/latticetop,uclosed,−∞,u)
to generate a random value with an unconstrained lower bound.Similarly, we handle the case where no constraints exist for the
upper bound in line 13. In line 14, both /lscriptanduare defined and the
algorithm returns frng(H,/lscriptclosed,uclosed,/lscript,u)to capture a random
valuewithintherespectivebounds.Inallabovecases,when H/nequal/emptysetAlt2,
the URNG is expected to generate a value that satisfies all disequal-
ity constraints in D. For the special case where D=/emptysetAlt2, there are
no such disequalities over yand the Skolem term can freely assign
any value within the computed bounds /lscriptandu.
Asanillustrationofourprocedure,wepresentsummarizedruns
over the following examples.
Example4.2. Considertheformula ∀x.∃y1,y2.ψ(x,y1,y2)over
LIA, where:
ψ(x,y1,y2)def=
(x≤2∧y1>−3x∧y2<x)∨(x≥−1∧y1<5x∧y2>x)
Theformulaisvalidsincethereexistsanassignmentto y1and
y2thatsatisfiestheconstraintsin ψ,foranyx.Inordertoconstruct
such a witness, AE-VAL needs to consider two separate cases for x,
i.e., the constraints x≤2 andx≥−1.
Underx≤2, the deterministic Skolem terms would be −3x+1
fory1andx−1 fory2. For the random case, Alg. 3 computes
frng,y1(/emptysetAlt2,⊥,/latticetop,−3x,+∞)andfrng,y2(/emptysetAlt2,/latticetop,⊥,−∞,x). Underx≥
−1,thedeterministictermswouldbe −3x+1fory1andx+1fory2,
while Alg.3 computes thefunctions frng,y1(/emptysetAlt2,/latticetop,⊥,−∞,5x)and
frng,y2(/emptysetAlt2,⊥,/latticetop,x,+∞), respectively.
Note that for the random case, the above terms are finally com-
bined into the Skolem term for ∃y1,y2.ψ(x,y1,y2):
sk/vecy(x)def=ite(x≤2,
(y1=frng,y1(/emptysetAlt2,⊥,/latticetop,−3x,+∞)∧y2=frng,y2(/emptysetAlt2,/latticetop,⊥,−∞,x)),
(y1=frng,y1(/emptysetAlt2,/latticetop,⊥,−∞,5x)∧y2=frng,y2(/emptysetAlt2,⊥,/latticetop,x,+∞)))
Example 4.3. Consider an Assume-Guarantee contract for a sys-
tem with the input vector /vecx={x1,x2,x3}∈R3and one output
y∈Rand the following constraints
/squaresolidA(x1,x2)def=x1,x2∈(0,1)
/squaresolidGI(y)def=/latticetop
/squaresolidGT(y,x1,x2,y/prime)def=y/prime∈(0,1)∧y/prime/nequalx1∧y/prime/nequalx2
The above specification is realizable as there are infinitely many
assignmentsto ythatsatisfytheguarantees Ggivenanyvalueof
x1,x2in(0,1). Using Alg. 3 we retrieve the following Skolem term
to enable random behavior (note that input x3is not included in
the setH, i.e. the first argument of the function):
254ASE ’20, September 21–25, 2020, Virtual Event, Australia Andreas Katis, Grigory Fedyukovich, Jeffrey Chen, David Greve, Sanjai Rayadurgam, and Michael W. Whalen
void skolem() {
if(position + x == 1) {
y = RandVal(1, 1, −1, 1);
} else if (position + x >= −1& &
position + x <= 0) {
y=−(position + x);
}e l s e{
y = RandVal(1, 1, −1, 1);
}
}
Figure 3: Synthesized random witness.
double Ran dVal(_Bool lflag , _Bool uflag ,
double lbound , double ubound){
int min = lflag ? lbound : lbound+1;
int max = uflag ? ubound : ubound −1;
int range = max −min + 1;
double rnd = (double) rand() /
(1.0 + (double) RAND_MAX);
int value = (int) ((d ouble) range ∗ rnd);
return value + min;
}
Figure 4: Example random number generator.
sky(/vecx)def=frng,y({x1,x2},⊥,⊥,0,1).
Example 4.4. Consider the contract from Fig. 1. The details of
the synthesis procedure remain identical with the deterministic
approachupuntiltheSkolemizationstep.Fig.3showstheCimple-
mentation for the random witness that is synthesized using Alg. 3.
Our proposed Skolemization procedure returns the assignment
valueforythatisequivalentto frng(/latticetop,/latticetop,−1,1),fortheconditions
underwhichthesystemcansafelychoosetomovetheroboteither
left,right,ornotatall.Theactualchoiceisrandomlymadethrough
the application of a function named RandVal. The implementation
of the function is then left to the engineer’s discretion (an example
is given in Fig. 4).
It is important to note that throughout this section, we pre-
sentedAlg.3assumingthattheinputformula ψ(/vecx,y)toAE-VALis
disjunction-free. Themain difference betweenthe originalSkolem-
izationprocedureinAE-VALandournewoneisthattheformerdoesnotprovideallpossibleSkolemterms,whilethelatterdoes.
Thus,theoriginalAE-VALalgorithmisnotsensitivetotheshape
oftheoriginalformula,butournewalgorithmrequiresaspecial
treatmentforthedisjunctions.Infact,ourapproachisgeneralizable
tothe caseofarbitrary formulasviaconverting themtheDisjunc-
tive Normal Form (DNF). The set of Skolem functions can then be
generatedforeachofthedisjunctseparately.Thefinalsolutionis
thencomposedfromthese partialSkolemfunctionsalongwitha
parameter that randomly picks one of them.4.3 Soundness and Completeness
In this section we prove that Alg. 3 is sound and can provide allpossible Skolem terms given a set of Skolem constraints
π(/vecx,y).
AswenotedinthebeginningofSect.4.2,Skolemconstraintsare
createdfromliteralsofaformulainlineararithmetic,thusitcannot
contain disjunctions.
Theorem 4.5 (Soundness of Skolem Extraction). Assuming
that the properties 1-5 from Def. 4.1 hold, Alg. 3 returns valid Skolem
terms.
Proof.Toprovethisstatement,itsufficestoshowthatanycom-
putedSkolemterm sky(/vecx)byAlg.3accompaniedbytheassociated
postconditions in Def. 4.1, implies the input Skolem constraints in
π(/vecx,y).Returnlines2and9inExtractSKaretrivialcases,asthey
reducetoasimpleassignmentfromequalityconstraints.Line11
refers to the case where no bounds have been defined and the
computedSkolemtermisaURNGthatutilizestheunconstrained
variables −∞and+∞along with postcondition 5 to ensure the
choice of an arbitrary value within the specified domain. Lines 12
to 13 handle the case where inequalities exist that determine the
lower and upper bounds /lscript(/vecx)andu(/vecx). If the lower bound is un-
defined, line 12 returns a URNG that is guaranteed to provide a
randomvaluebetween −∞anduasperpostconditions4and5.We
prove the soundness of terms provided by line 13 in a similar man-
ner. If both bounds exist, then in line 14 the Skolem term returned
isaURNGguaranteedtoprovideavaluewithintherangespecified
by/lscript(/vecx),u(/vecx), as per postconditions 2-5. /square
Theorem 4.6 (Completeness of Skolem Extraction). The
SkolemtermsgeneratedbyAlg.3aresufficienttorepresentallpossible
witnesses of the conjunctive ∀∃-formula in Eq. 1.
Proof.It suffices to prove that no weaker set of postconditions
pc/prime(i.e.,pc⇒pc/prime) exists, such that:
∀/vecx.pc/prime(sk(/vecx)) ⇒π(/vecx,sk(/vecx)) (2)
We prove this by contradiction, assuming that pc/primeexists whenever
Alg. 3 returns.
Lines2and9 .Alg.3returnsthedeterministicassignments ASN(e)
and/lscript, for which no weaker postconditions exist.
Line11. In this case, no bounds have been defined, and postcondi-
tion5isusedtodenotearangewithunconstrainedbounds −∞and
+∞. Formally, we can simplify this postcondition to pc=true, for
whichnoweakerpostconditionexists.Itisalsonoteworthytostate
that weaker postconditions exist, but all of them have to violate at
least one disequality in D.
Line 12. We have/lscript=undef, i.e., no constraints exist for the lower
bound, and the Skolem term
sk(/vecx)=frng(H,/latticetop,uclosed,min,u)
is returned. Depending on whether the upper bound uis closed
ornot,wehavetwocases.Forbrevity,weshowtheproofforthe
case where uis closed, and the corresponding case for the open
bound follows similar principles.
255Synthesis of Infinite-State Systems with Random Behavior ASE ’20, September 21–25, 2020, Virtual Event, Australia
/squaresolidWhenuis closed, the output constraints are simplified to
π(/vecx,sk(/vecx))=sk(/vecx)≤uand the Skolem term
sk(/vecx)=frng(H,/latticetop,/latticetop,−∞,u)
is returned, with postcondition 5 capturing the term’s range.
Assume that a weaker postcondition pc/primeexists, such that
Eq. 2 holds. Without loss of generality, we pick
pc/prime=frng(H,/latticetop,/latticetop,−∞,u) ∈ [−∞,u/prime]
withu/prime>u. Therefore, we have that pc⇒pc/prime, but Eq. 2
doesnotholdfor pc/prime,asthenewtermmayprovidethevalue
u/primeas an output, falsifying π(/vecx,sk(/vecx)).
Line 13. Similar to proof for line 12.
Line 14./lscript/nequalu/nequalundef, and as such the output constraints can be
simplified into π(/vecx,sk(/vecx))=/lscript∼sk(/vecx)∼u, where∼∈ {<,≤}.W e
have the following cases corresponding to the possible ranges:
(1)(/lscript,u). In this case we have sk(/vecx)=frng(H,⊥,⊥,/lscript,u)and
aspostcondition pcthesecondpostconditionfromDef4.1.
Assume that a weaker postcondition pc/primeexists, such that
Eq. 2 holds. We can pick pc/prime=frng(H,⊥,⊥,/lscript,u)∈[/lscript,u].
Inthiscase, pc⇒pc/primeholds,butEq.2doesnothold,aswe
can pick any of the assignments sk(/vecx)=/lscript,sk(/vecx)=u, which
violate the constraints in π, reaching a contradiction.
(2)[/lscript,u). Similar to the previous proof, by picking, e.g., pc/prime=
frng∈[/lscript,u].
(3)(/lscript,u]. Similarly, we can pick pc/prime=frng∈[/lscript,u].
(4)[/lscript,u]. Similarly, we can pick pc/prime=frng∈[/lscript/prime,u], where
/lscript/prime</lscript.
/square
5 IMPLEMENTATION AND EVALUATION
We implemented our random synthesis algorithm as a complemen-
taryproceduretotheoriginalsynthesisframeworkJKind[ 21],a
Java implementation of a popular Kind model checker [ 12,21,28].
Following Kind, the input contracts are expressed using the Lustre
dataflow language [ 27]. JKind provides support for synthesis both
throughthefixpointalgorithminJSyn-vgaswellasitspredecessor,
JSyn,arealizabilitycheckingalgorithmbasedonthe k-induction
principle [ 22,29,30]. Our proposed Skolemization procedure in
Alg. 3 is a new extraction method that is performed after the va-
lidity checking procedure in AE-VAL, thus making it inherently
compatiblewithbothJSynandJSyn-vg5.Itisnoteworthythatour
approachdoesnot addanyperformanceoverheadto thebaseline
implementation of JSyn-vg, as shown in Table 2.
SincethesynthesizedSkolemfunctionsareexpressedintheSMT-
LIB 2.0 language [5] by default, we translate them into executable
C implementations. For the purposes of this paper, we mapped the
application of URNGs to calls to random number generators of
uniformly distributed values, unless otherwise noted.
The evaluation process of our work is twofold:
5The modified version of JSyn-vg for random synthesis is available at https://
github.com/andrewkatis/jkind-1/tree/synthesis. The modified version of AE-VAL
with the new Skolemization procedure is available at https://github.com/andrewkatis/
fuzzersynthesis.
/g94/g393/g286/g272/g349/g296/g349/g272/g258/g410/g349/g381/g374 /g38/g437/g460/g460/g286/g396 /g100/g258/g396/g336/g286/g410 /g68/g381/g374/g349/g410/g381/g396
/g58/g94/g122/g69/g882/g115/g39/g94/g455/g374/g410/g346/g286/g400/g349/g400
Figure 5: Fuzzer synthesis and testing diagram
(1)Empirical. We performed case studies in applications where
synthesis of random designs can be beneficial.6For the first
case study, we conducted an experiment in the context of
model-based fuzz testing, where the goal was to synthesize
reactivegrayboxfuzzers capableofexposingvulnerabilities
that can crash an application, through random test case
generation.Thesecondstudy revolvesaround controllersyn-
thesisfor avoidance games in robot motion planning.
(2)Synthesistime.WeinvestigatedtheeffectthatourSkolem-
ization algorithm had on JSyn-vg in terms of synthesis time.
Furthermore,wecompared ourworktoDT-Synth,astate-
of-the-art synthesis tool for infinite-state problems [35].
6 CASE STUDY 1: REACTIVE FUZZERS
In our first case study, we explored the applicability of synthesized
implementationswithrandombehaviorinfuzztesting.Wefocused
on model-based approaches to examine a system-under-test (SUT),
theinputspecificationofwhichwasusedtoderivetestcases(see
Utting et al. for a detailed survey [ 45]). In the past, model-based
fuzztestingrevolvedaroundtheuseofstructureddescriptionsof
thesysteminputintheformofgrammarsandasophisticatedim-
plementationofafuzzerthat,givenagrammar,wouldcontinuously
feed random inputs to the SUT [ 1,4,39,46]. We show that syn-
thesisoffersaviablealternativetechniqueinthiscontext,where
thegeneratedimplementationscanserveasSUT-specificfuzzers,
requiring for configuration nothing but the input specification for
the SUT.
6.1 Setup and Evaluation
ThemainintuitionisthattheSUT’sinputdescriptioncanbeviewed
asasubstantialfragmentofthefuzzer’sspecification,whichcan
thenbeusedtosynthesizeareactiverandomtestcasegenerator.Fig. 5 depicts our exact setup, where the designer already has aspecification for the SUT and uses JSyn-vg with our Skolemiza-tion algorithm to automatically generate a corresponding fuzzer.
ThefuzzeristhenattachedtotheSUT(Target),alongwithanac-
companied monitoring service (Monitor) that tracks progress with
respect to the SUT-related statistics (e.g., coverage). Following the
definitionof grayboxfuzzing,afeedbackloopexistswheremoni-
toredinformationcanbesubsequentlyfedtothefuzzer,inorderto
dictate the generation of future test cases.
Using this setup, we proceeded with a thorough performance
evaluation of our synthesized fuzzers, following guidelines that
were recently proposed by Klees et al. [31]:
6The benchmarks are publicly accessible online. DOI : 10.6084/m9.figshare.12228026
256ASE ’20, September 21–25, 2020, Virtual Event, Australia Andreas Katis, Grigory Fedyukovich, Jeffrey Chen, David Greve, Sanjai Rayadurgam, and Michael W. Whalen
Table 1: Fuzzer performance comparison and synthesis times.
AFL AFLFastSynthesized Fuzzerw/o corpus w/ corpus w/o corpus w/ corpus
System Under Test Coverage (%) Crashed? Coverage (%) Crashed? Coverage (%) Crashed? Coverage (%) Crashed? Coverage (%) Crashed? Synthesis times (s)
basic_messaging 83.76%  82.48%  82.48%  82.48%  81.21%  16.067
Dive_Logger 92.18%  92.41%  92.18%  92.18%  93.79%  99.852
Divelogger2 80.50%  87.04%  78.40%  85.08%  83.25%  77.689
Email_System_2 78.71%  92.90%  91.61%  92.90%  84.84%  36.624
Movie_Rental_Service 38.32%  38.72%  38.32%  38.72%  49.50%  140.826
Palindrome 78.13%  78.13%  78.13%  78.13%  75.00%  1.231
PTaaS 71.94%  78.06%  46.76%  46.76%  74.46%  77.041
Quadtree_Conways 67.04%  84.08%  67.04%  67.04%  64.79%  88.743
SCUBA_Dive_Logging 80.97%  80.67%  76.41%  76.41%  83.56%  101.813
User_Manager 58.43%  67.45%  29.02%  29.02%  79.80%  16.289
SUT Selection .WeconsideredtenapplicationsfromtheDARPA
CyberGrandChallenge(CGC)7,abenchmarkcollectionthathas
been extensively used in the past to assess the performance of
fuzzers due to the high degree of interactivity between the SUT
andtheuser[ 38,41,44].Theoriginalcollectionwasaimedtowards
the evaluation of automated reasoning and testing tools, and each
applicationisintentionallydocumentedinawaythatisinsufficient
to derive a precise specification from the documents themselves.
Tosimulatethecontextunderwhichsynthesiswouldmakemost
sense as a tool, we closely inspected and ran each application in
order to identify the types and sequences of inputs each applica-tion takes. The manual process of discovering and writing input
specifications per application was non-trivial, as each application
differsconsiderablyfromtherest,andwasthemainfactortothe
study being limited to a subset of ten applications.Fuzzerspecification
.Afterinspectingeachapplicationtoidentify
thekindsofinputsthatittakes,wewroteacorrespondingAssume-
Guaranteecontractforafuzzer.Eachfuzzerspecificationconsists
ofpropertiesthatcapturethevalidrangesofvaluesforeachone
oftheSUTinputs.Moreover,thespecificationisstateful,making
eachfuzzerreactivetochanges(orlackthereof)incoverageresults
frompreviouslygeneratedtests.Wespecifiedthebehaviorofthe
fuzzer in such a way that, for the majority of its runtime, validinputs are fed into the SUT. As long as no progress is made in
termsofcoverage,thefuzzerattemptsgeneratinginvalidtestswith
probability p=0.2.
Formalization . All of the aforementioned elements that comprise
the fuzzer specification can be expressed using a set of safetyprop-
ertiesovertheSUTinputs,whereeachsetpreciselycapturesthe
conditions under which a (in)valid value is generated for the corre-
spondinginput.Anexamplepairofsuchpropertiesisthefollowing:
/squaresolidprop1def=p/prime≥0∧p/prime≤1
/squaresolidprop2def=(¬cvд∧(p≤0.1∨p≥0.9)) ⇒in/primesys/nelementSvalid
Variables pandinsysare fuzzer outputs, with insysalso serving
as a corresponding input for the SUT. The value of p∈[0,1]is
picked randomly for each test, and it determines whether the next
(primed) system input in/primesyswill be assigned to a valid value (i.e.,
avaluein Svalid)ornot.Variable cvдisaninputtothefuzzerand
can be viewed as a flag which, when set, informs the fuzzer that
the previous test resulted in progress in system coverage (e.g., line
coverage improved). If such progress was not observed, then we
allow the fuzzer to randomly consider invalid values in subsequent
7The public CGC benchmark collection is available at https://bit.ly/2HBqrJq.tests. More specifically, when p≤0.1∨p≥0.9, the fuzzer will
generate an invalid value, i.e., a value that does not satisfy the con-
straintsthatdefine Svalid.Followingthenotationthatwedescribed
inprevioussections,thesynthesisproblemforthepropertiesabove
is to ensure that ∀p,cvд,insys∃p/prime,in/primesys.(prop1∧prop2)is valid.
SynthesisandEvaluation .Usingthefuzzercontracts,wesynthe-
sized a fuzzer for each application and ran it against the SUT usingthesetupinFig.5.Wesetthetimeoutforeachfuzzingcampaignto
nine hours, and monitored the SUT line coverage (gcov ) as well as
crashes.Tocompareperformance,wealsoranfuzzingcampaigns
usingAFL[ 47]andAFLFast[ 9],usingtheirdefaultconfigurations.
WeselectedthesetoolsprimarilyduetoAFLbeingoneofthemost
prominenttoolsinthearea,whileAFLFastisarecentextensionto
AFL that has been shown to perform better with respect to vulner-
abilitydetection.8Bothtoolswererunbothwithandwithoutan
initialcorpusinordertoprovideamorecompletepictureoftheir
performance, whether the user provides additional information or
not.Toremainfairwithrespecttotheevaluation,thecorporawere
created using tests that exercise application locations that are as
deep as possible.
Table 1 shows the results of our experiments. Most of the appli-
cations contain unreachable code related to debugging methods,and as such 100% coverage is not attainable using gcovwithout
further modifications to the source code. While we were able toachieve
≥75% line coverage for the majority of the benchmarks,
the application “Movie_Rental_Service” was the worst performing
with only 49.5%. Despite that, the synthesized fuzzer outperformed
bothAFLandAFLFastoneitherconfigurationwithasignificant
margin.Infact,oursynthesizedfuzzersoutperformedbothAFLand
AFLFastonfourapplicationsandremainedwithin4%ofthe best
performingtoolforfiveothers,with“Quadtree_Conways”being
the only exception. More interestingly, seven of the synthesizedfuzzers were able to crash the corresponding application at least
once, whereas AFL/AFLFast were only able to crash three.
Considering the performance results along with the low synthe-
sistimeperfuzzer,webelievethatsynthesisofmodel-basedfuzzersshould be considered a viable tactic towards testing systems where
aspecificationalreadyexists.Arguably,asynthesizedfuzzerisas
easy to use as a general-purpose tool like AFL. Furthermore, the
userdoesnothavetoprovideadditionalinformationthroughacor-
pus, a procedure in testing that often times can be time consuming
8Both AFL and AFLFast do not support line coverage reporting natively. To monitor
coverage,weused afl-cov[40],awrappertoolthatenablestheuseof gcovwithAFL
and its variants.
257Synthesis of Infinite-State Systems with Random Behavior ASE ’20, September 21–25, 2020, Virtual Event, Australia
andcumbersome,asbothvalidandinvalidinputsequenceshave
to be considered for a successful campaign.
7 CASE STUDY 2: ROBOT MOTION
PLANNING
In our second study, we synthesized implementations for robots
participating in two-player safety games against an adversary. The
study is furthermore split into two parts.
7.1 Simulating avoidance games
Weexperimentedonsimulatinganavoidancegameinabounded
arena, where the synthesized solution was used against two dif-
ferentadversarialscenarios.Boththepropertiesoftherobotand
the adversary were specified using their position in terms of (x,y)
coordinates. Formally, we described the game using the following
properties:
/squaresolidInitial state : The robot starts in (xinit,yinit)(similarly for the
adversary).
/squaresolidValidtransitions: x/prime
robot∈[xrobot−δ,xrobot+δ],whereδisuser-
definedandcapturesthemaximumdistancebetweensubsequent
moves(similarlyfor y-coordinateandtheadversarialtransitions).
/squaresolidIn-boundsproperty: xrobot≥xmin∧xrobot≤xmax(similarlyfor
they-coordinate).
/squaresolidAvoidance property : xrobot/nequalxadversary∨yrobot/nequalyadversary.
The first scenario in our presentation involves the adversary
patrolling on a specific route, while in the second the adversaryis always moving towards the robot. Trajectory videos for both
scenarios are available online9.
7.1.1 Real Coordinates. Fig. 6 shows three possible trajectories
thatweregeneratedafterrunningthesynthesizedsolutionfor1000
turns against the patrolling adversary. Both robots move in the
arenausingrationalcoordinatesina5x5box.Theinitiallocation
fortherobotisthepoint (0.5,0.5)andtheadversarybeginsitsroute
from(0.8,0.8). While the adversary has a predetermined route, the
robot is allowed to move towards any possible direction (vertically,
horizontallyanddiagonally).Moreover,therobotcanmoveatvary-ingdistancesupto0.1unitsawayfromitscurrentposition,inbothaxes(i.e.,
|xrobot−x/prime
robot|≤0.1,andsimilarlyfortheyaxis).Fig.6a
indicates how the synthesized solution can respond in a randompattern, covering different parts of the bounded arena while pre-
serving safety. Fig. 6b and 6c demonstrate the resulting trajectories
when the user introduces bias in the values returned by the ran-
domnumbergenerators,usingthesamegeneratedwitnessfrom
AE-VAL. As a result, the robot was limited to moves that would
retain its position within the central area of the arena (Fig. 6b) and
closetothebottomleftcornerofthepatrollingadversary’sroute
(Fig. 6c).
7.1.2 Integer Coordinates. Forthisexperiment,weaimedtodemon-
strate the advantages that randomness can provide with respect
tohowwellarobotcoversaboundedarena,inspiredbyworkin
coveragepathplanningproblems.Fig.7showshowtwotrajectoriesevolvedoverseveralturns(100,250and1000turns)forasimilarmo-
tion planning problem usingintegercoordinates. To demonstrate
9Picturesandvideosofthesimulatedgamespresentedinthissectionwereanonymized
and made available at https://figshare.com/s/ce2dfd885b3caf20f46d.whichpartsofthearenatherobotexploredweoutlineitstrajectorywithaboldblackline,whiletheredlinerepresentsthetrajectoryof
theadversary.Inthisgame,theadversaryisaggressivelychasing
after the robot in a random fashion. The robot’s objective remains
thesame,i.e.,movewithintheboundedarenawhileavoidingthe
adversary.Therobot’sinitiallocationisthepoint (0,0),whilethe
adversary begins at (6,6).
Infact,Fig.7a,7c,and7eshowmovesperformedbyarandom
controller, while Fig. 7b, 7d,and 7f depict the behavior of the de-
terministic solution provided by the standard synthesis algorithm
inJSyn-vg. Itis apparent thatthe former visits100% states inless
than 250 turns, whereas the latter visits only 30% states in 1000
turns.Thiscomparisonshowcasestheadvantagesthatarandom
solution can provide in terms of overall coverage as well as the
diversity of behaviors that can be observed and exercised when an
implementation can be generated that always considers the entire
set of safe choices, instead of an instantiated strategy.
8 EVALUATION – SYNTHESIS TIME
Ourcase studyin robotmotion planningwas inspiredby resultsin this context from the most recent and related work on DT-
Synth [35]. This reactive synthesis framework incorporates learn-
ing techniques to generate winning sets for infinite-state safetygames in the form of decision trees. DT-Synth has been shown
tooutperformpreviousproposedsynthesistools,bothininfinite-
state(ConSynth[ 6]andfinite-stateproblems(RPNI-Synthand
SAT-Synth[ 36]).Whiletheauthorsdonotexplicitlytalkaboutran-
domness, the winning sets provided by DT-Synth are sufficient to
generate implementations with diverse behavior. Despite this fact,
thegeneratedwinningsetsaresubsetsofthegreatestfixpointof
safestates,whichwouldleadtoimplementationsthatonlyexerciseafragment ofthereachablestate space.Anexampleis thewinning
set that we mentioned for the motivating example in Section 3.
NotethatDT-Synthworksonlyforfinite-branchinggamegraphs,
and the user must additionally specify a minimum value for thenumber of successors for each vertex in the graph. An incorrect
valueforthisthresholdcanleadtounsoundwitnesses.Withour
JSyn-vg,suchadditionalknowledgeisnotrequiredfromtheuser
sinceitisonlyreliantontheoriginalspecificationandisguaranteed
to provide sound results, thanks to Theorem 4.5.
Table2presentsthecomparisonof JSyn-vgandDT-Synth.As
an addendum we included the synthesis times for the problemsusing the existing deterministic synthesis algorithm in JSyn-vg.
As we mentioned in Sect. 5, the performance is identical when
compared to synthesizing random witnesses.
Forthepurposesofthiscomparison,weusedtheinfinite-state
benchmarks presented in the original paper on DT-Synth [ 35],
as well as the simulated avoidance games from Sect. 7.1, namelybounded_evasion andbounded_evasion_ints. The two tools have
similarperformanceforhalfthebenchmarks,withsignificantdif-
ferences for the rest. For diagonal, the main distinction is that
DT-Synth requires the definition of two additional expressions
toguidethelearning procedure,whereasJSyn-vgfindsasolution
without additional templates. On the other hand, DT-Synth’s abil-
ity to synthesize memoryless strategies allows for faster synthesis
forsolitarybox, where the robot is simply moving freely within
258ASE ’20, September 21–25, 2020, Virtual Event, Australia Andreas Katis, Grigory Fedyukovich, Jeffrey Chen, David Greve, Sanjai Rayadurgam, and Michael W. Whalen
0 0.2 0.4 0.6 0.8 100.20.40.60.81
(a)0 0.2 0.4 0.6 0.8 100.20.40.60.81
(b)0 0.2 0.4 0.6 0.8 100.20.40.60.81
(c)
Figure 6: Random trajectories of a robot (irregular solid line) while avoiding a patrolling adversary (inner square).
Table 2: Synthesis time of DT-Synth and JSyn-vg (seconds).
Benchmark JSyn-vgJSyn-vg
(random)DT-Synth
box 0.603 0.606 0.258
diagonal 1.109 1.011 6.027
evasion 0.705 0.605 0.660
follow 3.34 3.029 1.034
limitedbox 3.229 3.332 3.350
solitarybox 1.902 1.816 0.284
square 5.823 5.605 6.44
program-repair 3.122 3.638 2.452
repair-critical 83.891 88.073 30.593
synth-synchronization 23.013 23.2 89.804
cinderella ( c=2) 20.061 20.167>900
cinderella ( c=3) 12.02 11.294>900
bounded_evasion 49.528 49.662 unsupported
bounded_evasion_ints 31.614 32.611>900
an infinite arena while staying within a horizontal stripe of width
equal to three. JSyn-vg is targeted to synthesis of stateful systems,
and as such, a more elaborate strategy is generated.
Inthecaseof repair-critical,DT-Synthappearstobemoreeffi-
cient in termsof handling disjunctive expressions inthe specifica-
tion,whilefor synth-synchronization DT-Synthseemstorequire
more elaborate hypotheses in order to come up with a witness.
Thelatterisfurtherdemonstratedintheresultsforthe cinderella
andbounded_evasion_ints games, where DT-Synth fails to synthe-
sizeawitnesswithinthetimeoutof15minutes.Incontrast,JSyn-vg
computesagreatestfixpointofsafestatesandsynthesizesasolutionina fewseconds.Finally, forthegame bounded_evasion,DT-Synth
does not currently support the theory of linear real arithmetic.
9 RELATED WORK
The idea of synthesizing reactive designs with random behavior
isrelevanttosynthesisforpermissivegames.Thisareahasbeenexploredinthepastforfinite-stateproblems[ 10,32].Morerecently,
Fremont and Seshiadescribed a formal extension tothe theory of
Control Improvisation to support reactive synthesis [ 20]. Their
probabilisticapproachislimitedtofinite-stateproblemsandpracti-
cally useful only for the subset of safety games. The end result is a
maximally-randomized finite word generator, called an improviser,
where each word satisfies the predetermined probability thresh-
oldconstraints.Incomparison,ourapproachsynthesizesdesigns
for infinite-state problems that simulate randomness. Furthermore,
we do not provide guarantees regarding the randomness of the
responsesfromthe synthesizedwitness.Instead,we focusonsyn-
thesizingwitnessesthatconsiderregionsofvaluesascandidates
tovariableassignments,aproblemreducibletoSMT.Inourcase,
theendproductisanimplementationthatcanbefurtherrefined
by theengineer witha customprobability distribution toretrieve
randomvalues.Thisprovidesinvaluablefreedomastheusercan
thenchoosewhethertoexpressbiasthroughtherequirementsor
through the random number generators themselves.
The original work on JSyn-vg targeted the area of infinite-state
problems. In this context, Beyenne et al. first proposed a template-
basedapproachcalledConSynth,wherethespecificationisaccom-
paniedby atemplateregarding theshapeofthe solutiontoguide
thesynthesizertowardsasolution[ 7].Incontrast,JSyn-vgisacom-
pletely automated approach exempting the user from necessity to
furtherreasonabouttheshapeofthecomputedsolutionandallow-
ing to focus on expressing the problem in the form of input-output
contracts. Permissive solutions for infinite-state games have pri-
marily beenproposed inthe contextsupervisor synthesis [13,43],
where a controller is synthesized considering a formal representa-
tion of the behavior (inputs) provided by the participating plant.
Comparedtothiswork,ourproposedsolutionexplorestheappli-
cabilityofsynthesizedcontrollerswithrandombehavior,whilethe
overallsynthesis taskisinherentlyharder duetonot requiringan
exact implementation of the controller’s environment.
NeiderandMarkgrafrecentlyproposedDT-Synth[ 35],alearning-
basedapproachtosynthesizingwinningsetsforinfinitestategames
259Synthesis of Infinite-State Systems with Random Behavior ASE ’20, September 21–25, 2020, Virtual Event, Australia
- 1 01234567-101234567
(a) 100 turns- 1 01234567-101234567
(b) 100 turns
- 1 01234567-101234567
(c) 250 turns- 1 01234567-101234567
(d) 250 turns
- 1 01234567-101234567
(e) 1000 turns- 1 01234567-101234567
(f) 1000 turns
Figure 7: Trajectories and area coverage over time of random (left column)
versus deterministic (right column) controller.
in the form of decision trees, as an extension to previous work
byNeiderandTopcuforfinite-stateproblems[ 36].DT-Synthre-
quires additional knowledge regarding the number of successor
states, where lack thereof can lead to unsound results. Similarly to
ConSynth, for more complex problems, the game specification is
supported by additional syntactic expressions that help the learner
converge faster to a solution. In contrast, our Skolem extraction
algorithmisguaranteedtoprovidesoundwitnessesanddoesnot
depend on additional user-provided input.
10 CONCLUSION
WehavepresentedanovelSkolemizationprocedurefortheAE-VAL
solver enabling the synthesis of infinite-state reactive implementa-
tions with random behavior. The proposed solution is an extension
to the synthesis algorithm JSyn-vg that computes a greatest fix-
pointofsafestates.Theproductisawitnesswherevaluesinsidesafe regions are being considered as equally safe candidate assign-
ments.Our solutionprovides theengineer withflexibilitywhen it
comestointroducingadditionalbiasthroughthespecificationor
the implemented random number generators.
Tothebestofourknowledge,thisisthefirstworkthatiscapable
of synthesizing random infinite-state systems. We showed how the
extendedsynthesisframeworkcanbeeffectivelyusedtosynthesize
promising solutions in the context of robot motion planning, as
well as a novel application in fuzz testing. In the future, we wish to
continueexploringtheareaofreactivefuzzersynthesis,particularly
in the context of identifying a formal specification standard. To ex-
pand its applicability in robot motion planning, we wish to explore
waystosupportlivenessspecifications,aswellassoftrequirements.
TheoutstandingresultofthisworkisaSkolemextractionproce-
dure general enough to be applicable to other, unexplored, aspects
of the synthesis problem.
ACKNOWLEDGMENTS
The authors would like to thank Kristopher Cory for his invalu-
able advice towards setting up the fuzz testing experiments. Theauthors would also like to thank the anonymous reviewers for
theircomments.ThisworkwasfundedinpartbytheUnitedStates
DepartmentoftheNavy,OfficeofNavalResearchundercontract
N68335-17-C-0238.
REFERENCES
[1] [n.d.]. Peach fuzzer. https://www.peach.tech/.
[2]Alessandro Abate, Iury Bessa, Dario Cattaruzza, Lucas Cordeiro, Cristina David,
PascalKesseli,DanielKroening,andElizabethPolgreen.2017. Automatedformal
synthesisofdigitalcontrollersforstate-spacephysicalplants.In International
Conference on Computer Aided Verification. Springer, 462–482.
[3]Rajeev Alur, Rastislav Bodik, Garvit Juniwal, Milo MK Martin, Mukund
Raghothaman,SanjitASeshia,RishabhSingh,ArmandoSolar-Lezama,Emina
Torlak, and Abhishek Udupa. 2013. Syntax-guided synthesis. In 2013 Formal
Methods in Computer-Aided Design. IEEE, 1–8.
[4]Cornelius Aschermann, Tommaso Frassetto, Thorsten Holz, Patrick Jauernig,
Ahmad-Reza Sadeghi, and Daniel Teuchert. 2019. NAUTILUS: Fishing for Deep
Bugs with Grammars.. In NDSS.
[5]Clark Barrett, Aaron Stump, Cesare Tinelli, et al .2010. The smt-lib standard:
Version 2.0. In Proceedings of the 8th International Workshop on Satisfiability
Modulo Theories (Edinburgh, England), Vol. 13. 14.
[6]TewodrosBeyene,SwaratChaudhuri,CorneliuPopeea,andAndreyRybalchenko.
2014. A constraint-based approach to solving games on infinite graphs. In POPL.
ACM, 221–233.
[7]Tewodros A. Beyene, Swarat Chaudhuri, Corneliu Popeea, and Andrey Ry-balchenko. 2014. A constraint-based approach to solving games on infinite
graphs. In POPL. ACM, 221–234.
[8]Nikolaj Bjørner and Mikolás Janota. 2015. Playing with Quantified Satisfaction.
InLPAR (short papers) (EPiC Series in Computing), Vol. 35. EasyChair, 15–27.
[9]Marcel Böhme, Van-Thuan Pham, and Abhik Roychoudhury. 2017. Coverage-
basedgreyboxfuzzingasmarkovchain. IEEETransactionsonSoftwareEngineering
45, 5 (2017), 489–506.
[10]PatriciaBouyer,MarieDuflot,NicolasMarkey,andGabrielRenault.2009. Mea-
suringpermissivityinfinitegames.In InternationalConferenceonConcurrency
Theory. Springer, 196–210.
[11]SupratikChakraborty,DrorFried,LucasMTabajara,andMosheYVardi.2018.
Functional synthesis via input-output separation. In 2018 Formal Methods in
Computer Aided Design (FMCAD). IEEE, 1–9.
[12]AdrienChampion,AlainMebsout,ChristophSticksel,andCesareTinelli.2016.
The Kind 2 model checker. In International Conference on Computer Aided Verifi-
cation. Springer, 510–517.
[13]Koen Claessen, Jonatan Kilhamn, Laura Kovács, and Bengt Lennartson. 2017.
ASupervisoryControlAlgorithmBasedonProperty-DirectedReachability.In
Haifa Verification Conference. Springer, 115–130.
[14]GrigoryFedyukovichandAartiGupta.2019. FunctionalSynthesiswithExamples.
InCP (LNCS), Vol. 11802. Springer, 547–564.
[15]Grigory Fedyukovich, Arie Gurfinkel, and Aarti Gupta. 2019. Lazy but Effective
Functional Synthesis. In VMCAI (LNCS), Vol. 11388. Springer, 92–113.
260ASE ’20, September 21–25, 2020, Virtual Event, Australia Andreas Katis, Grigory Fedyukovich, Jeffrey Chen, David Greve, Sanjai Rayadurgam, and Michael W. Whalen
[16]Grigory Fedyukovich, Arie Gurfinkel, and Natasha Sharygina. 2015. Automated
Discovery of Simulation Between Programs. In LPAR (LNCS), Vol. 9450. Springer,
606–621.
[17]Bernd Finkbeiner. 2016. Synthesis of Reactive Systems. Dependable Software
Systems Engineering 45 (2016), 72–98.
[18]DustinFraze.[n.d.]. TheDARPACyberGrandChallenge. https://www.darpa.
mil/program/cyber-grand-challenge.
[19]Daniel J Fremont, Alexandre Donzé, and Sanjit A Seshia. 2017. Control improvi-
sation.arXiv preprint arXiv:1704.06319 (2017).
[20]Daniel J. Fremont and Sanjit A. Seshia. 2018. Reactive Control Improvisation.
InComputer Aided Verification, Hana Chockler and Georg Weissenbacher (Eds.).
Springer International Publishing, Cham, 307–326.
[21]Andrew Gacek, John Backes, Mike Whalen, Lucas Wagner, and Elaheh Ghassa-
bani.2018. TheJKindModelChecker.In InternationalConferenceonComputer
Aided Verification. Springer, 20–27.
[22]Andrew Gacek, Andreas Katis, Michael W Whalen, John Backes, and Darren
Cofer. 2015. Towards Realizability Checking of Contracts Using Theories. In
NFM (LNCS), Vol. 9058. Springer, 173–187.
[23]EnricGalceranandMarcCarreras.2013. Asurveyoncoveragepathplanning
for robotics. Robotics and Autonomous systems 61, 12 (2013), 1258–1276.
[24]Sumit Gulwani. 2010. Dimensions in program synthesis. In PPDP. ACM, 13–24.
[25]Christian Holler, Kim Herzig, and Andreas Zeller. 2012. Fuzzing with code frag-
ments. In Presented as part of the 21st {USENIX}Security Symposium ( {USENIX}
Security 12). 445–458.
[26]Falk Howar and Bernhard Steffen. 2018. Active automata learning in practice. In
Machine Learning for Dynamic Software Analysis: Potentials and Limits. Springer,
123–148.
[27]Erwan Jahier, Pascal Raymond, and Nicolas Halbwachs. [n.d.]. The Lustre V6
Reference Manual. http://www-verimag.imag.fr/Lustre-V6.html.
[28]Andreas Katis, Grigory Fedyukovich, Huajun Guo, Andrew Gacek, John Backes,
Arie Gurfinkel, and Michael W Whalen. 2018. Validity-guided synthesis of
reactivesystemsfromassume-guaranteecontracts.In InternationalConference
onToolsandAlgorithmsfortheConstructionandAnalysisofSystems.Springer,
176–193.
[29]Andreas Katis, Andrew Gacek, and Michael W Whalen. 2015. Machine-Checked
Proofs For Realizability Checking Algorithms. In VSTTE. Springer, 110–123.
[30]Andreas Katis, Andrew Gacek, and Michael W Whalen. 2016. Towards synthesis
fromassume-guaranteecontractsinvolvinginfinitetheories:apreliminaryreport.
InFormaliSE. IEEE, 36–41.
[31]GeorgeKlees,AndrewRuef,BenjiCooper,ShiyiWei,andMichaelHicks.2018.
Evaluating fuzz testing. In Proceedings of the 2018 ACM SIGSAC Conference on
Computer and Communications Security. 2123–2138.
[32]Bettina Könighofer, Mohammed Alshiekh, Roderick Bloem, Laura Humphrey,
Robert Könighofer, Ufuk Topcu, and Chao Wang. 2017. Shield synthesis. Formal
Methods in System Design 51, 2 (2017), 332–361.
[33]Newton Lee. 2015. DARPA’s Cyber Grand Challenge (2014–2016). In Counterter-
rorism and Cybersecurity. Springer, 429–456.
[34]Valentin Jean Marie Manès, HyungSeok Han, Choongwoo Han, Sang Kil Cha,
Manuel Egele, Edward J Schwartz, and Maverick Woo. 2019. The art, science,
and engineering of fuzzing: A survey. IEEE Transactions on Software Engineering
(2019).
[35]Daniel Neider and Oliver Markgraf. 2019. Learning-based synthesis of safety
controllers.In 2019FormalMethodsinComputerAidedDesign(FMCAD).IEEE,
120–128.
[36]Daniel Neider and Ufuk Topcu. 2016. An automaton learning approach to solv-
ingsafetygamesoverinfinitegraphs.In InternationalConferenceonToolsand
Algorithms for the Construction and Analysis of Systems. Springer, 204–221.
[37]ThanhVu Nguyen, Westley Weimer, Deepak Kapur, and Stephanie Forrest. 2017.
Connectingprogramsynthesisandreachability:Automaticprogramrepairusing
test-input generation. In International Conference on Tools and Algorithms for the
Construction and Analysis of Systems. Springer, 301–318.
[38]Hui Peng, Yan Shoshitaishvili, and Mathias Payer. 2018. T-Fuzz: fuzzing by
programtransformation.In 2018IEEESymposiumonSecurityandPrivacy(SP) .
IEEE, 697–710.
[39]Van-Thuan Pham, Marcel Böhme, and Abhik Roychoudhury. 2016. Model-based
whitebox fuzzing for program binaries. In Proceedings of the 31st IEEE/ACM
International Conference on Automated Software Engineering. 543–553.
[40]Michael Rash. [n.d.]. afl-cov - AFL Fuzzing Code Coverage. https://github.com/
mrash/afl-cov.
[41]Sanjay Rawat, Vivek Jain, Ashish Kumar, Lucian Cojocar, Cristiano Giuffrida,and Herbert Bos. 2017. VUzzer: Application-aware Evolutionary Fuzzing.. In
NDSS, Vol. 17. 1–14.
[42]Leonid Ryzhyk, Peter Chubb, Ihor Kuz, Etienne Le Sueur, and Gernot Heiser.
2009. Automatic device driver synthesis with Termite. In Proceedings of the ACM
SIGOPS 22nd symposium on Operating systems principles. ACM, 73–86.
[43]MohammadRezaShoaei,LauraKovács,andBengtLennartson.2014. Supervi-
sorycontrolofdiscrete-eventsystemsviaIC3.In HaifaVerificationConference.
Springer, 252–266.[44]NickStephens,JohnGrosen,ChristopherSalls,AndrewDutcher,RuoyuWang,
Jacopo Corbetta, Yan Shoshitaishvili, Christopher Kruegel, and Giovanni Vigna.
2016. Driller:AugmentingFuzzingThroughSelectiveSymbolicExecution..In
NDSS, Vol. 16. 1–16.
[45]Mark Utting, Alexander Pretschner, and Bruno Legeard. 2012. Ataxonomy of
model-basedtestingapproaches. Softwaretesting,verificationandreliability 22,5
(2012), 297–312.
[46]Spandan Veggalam, Sanjay Rawat, Istvan Haller, and Herbert Bos. 2016. Ifuzzer:
An evolutionary interpreter fuzzer using genetic programming. In European
Symposium on Research in Computer Security. Springer, 581–601.
[47]Michal Zalewski. [n.d.]. American Fuzzy Lop. https://lcamtuf.coredump.cx/afl/.
261