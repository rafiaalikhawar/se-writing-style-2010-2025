Characterizing Transaction-Reverting Statements in
Ethereum Smart Contracts
Lu Liua,b, Lili Weib, Wuqi Zhangb, Ming Wenc, Yepang Liua∗, Shing-Chi Cheungb∗
aDepartment of Computer Science and Engineering, Southern University of Science and Technology, Shenzhen, China
bDepartment of Computer Science and Engineering, Hong Kong University of Science and Technology, Hong Kong, China
cSchool of Cyber Science and Engineering, Huazhong University of Science and Technology, Wuhan, China
{lliubf, liliwei, wzhangcb, scc}@cse.ust.hk, {mwenaa}@hust.edu.cn, {liuyp1}@sustech.edu.cn
Abstract —Smart contracts are programs stored on blockchains
to execute transactions. When input constraints or security
properties are violated at runtime, the transaction being executedby a smart contract needs to be reverted to avoid undesirableconsequences. On Ethereum, the most popular blockchain thatsupports smart contracts, developers can choose among threetransaction-reverting statements (i.e., require, if...revert,
andif...throw) to handle anomalous transactions. While
these transaction-reverting statements are vital for preventingsmart contracts from exhibiting abnormal behaviors or suffer-ing malicious attacks, there is limited understanding of howthey are used in practice. In this work, we perform the ﬁrstempirical study to characterize transaction-reverting statementsin Ethereum smart contracts. We measured the prevalence ofthese statements in 3,866 veriﬁed smart contracts from populardapps and built a taxonomy of their purposes via manually an-alyzing 557 transaction-reverting statements. We also comparedtemplate contracts and their corresponding custom contracts tounderstand how developers customize the use of transaction-reverting statements. Finally, we analyzed the security impact oftransaction-reverting statements by removing them from smartcontracts and comparing the mutated contracts against theoriginal ones. Our study led to important ﬁndings. For example,we found that transaction-reverting statements are commonlyused to perform seven types of authority veriﬁcations or validitychecks, and missing such statements may compromise the secu-rity of smart contracts. We also found that current smart contractsecurity analyzers cannot effectively handle transaction-revertingstatements when detecting security vulnerabilities. Our ﬁndingscan shed light on further research in the broad area of smartcontract quality assurance and provide practical guidance tosmart contract developers on the appropriate use of transaction-reverting statements.
Index T erms—Ethereum, smart contract, transaction-reverting
statement, empirical study, security vulnerability
I. I NTRODUCTION
Smart contracts are programs stored on blockchains to
execute transactions. In recent years, smart contracts have been
widely used for various purposes such as to offer ﬁnancialservices [1]. Ethereum [2] is the largest decentralized platformfor smart contracts with the second biggest blockchain marketcapitalization [3]. There are over one million transactionsexecuted on Ethereum daily [4].
As smart contracts are often used to manage valuable user
assets, their security is of paramount importance. Anoma-lous transactions caused by various runtime errors should
* Yepang Liu and Shing-Chi Cheung are the corresponding authors.if(msg.sender != owner) { revert (); }
require (msg.sender == owner);
if(msg.sender != owner) { throw ;}
Fig. 1. Examples of transaction-reverting statements
be detected and reverted promptly to prevent undesirableconsequences such as ﬁnancial losses. In Solidity [5], the mostpopular programming language for Ethereum smart contracts,there are three statements that can help detect runtime errorsand revert transactions, namely, require, if...revert,
andif...throw. Figure 1 shows the example uses of
these transaction-reverting statements to revert transactions
submitted by unauthorized senders. While all three statementscan revert transactions when anomalous conditions occur, theﬁrst two would refund the unused gas to transaction senders.
Transaction-reverting statements are frequently used in
smart contracts. Our analysis reveals that over 94% of smart
contracts use transaction-reverting statements in certain ways.Surprisingly, this ﬁgure is even higher than that of general-purpose if statements. These statements are also frequently
discussed in the Solidity developers community. We searchedon Stack Overﬂow [6], the most popular Q&A website forprogrammers, using the keywords “require()”, “revert()”, and“if throw” under the tag “solidity”. As of August 2021, thereare already 1,280 questions related to the three transaction-reverting statements, many of which have been viewed thou-sands of times.
Transaction-reverting statements can effectively help pre-
vent smart contracts from exhibiting abnormal behaviors orsuffering malicious attacks. For example, in the SWC Reg-istry [7], which indexes common smart contract weaknesses,there is a kind of weakness called “Unchecked Call Re-turn V alue” (SWC-104 [8]). This weakness occurs whenthe return value of a message call is not properly checkedin a smart contract. To ease understanding, we give anillustrative example in Figure 2. In the code snippet, thecallNotChecked()function does not check the returnvalue of callee.call() (Line 2). When the execution of
callee.call() fails, the callNotChecked()function
would not do anything. This may cause serious and irreversibleconsequences, e.g., the contract announces to the caller witherror execution information that the call has been executed
6302021 36th IEEE/ACM International Conference on Automated Software Engineering (ASE)
DOI 10.1109/ASE51524.2021.000622021 36th IEEE/ACM International Conference on Automated Software Engineering (ASE) | 978-1-6654-0337-5/21/$31.00 ©2021 IEEE | DOI: 10.1109/ASE51524.2021.9678597
978-1-6654-0337-5/21/$31.00  ©2021  IEEE
1function callNotChecked( address callee) public {
2 callee. call();
3}
4
5function callChecked( address callee) public {
6 require (callee. call());
7}
Fig. 2. An example of the Unchecked Call Return V alue weakness
successfully, but actually, the call fails. To ﬁx the weakness,
developers are suggested to add a require statement to
check the execution status of callee.call() (such as in
Line 6 of callChecked()) so that the anomalous trans-
actions can be reverted and the unused gas can be returnedto the transaction sender upon unsuccessful execution ofcallee.call().
As we can see from the above example, appropriate uses
of transaction-reverting statements can help improve the re-liability and security of smart contracts. However, there islittle research on transaction-reverting statements. Without acomprehensive understanding of how these statements are usedin practice, one cannot design tools to effectively identifythe inappropriate uses of such statements or formulate goodpractices to help smart contract developers. We conductedthe ﬁrst empirical study to characterize transaction-revertingstatements in Ethereum smart contracts to bridge the gap.Speciﬁcally, we investigated the following four research ques-tions:
•RQ1 (Prevalence): Are transaction-reverting statements
commonly used in Ethereum smart contracts?
•RQ2 (Purpose): What are the major purposes of using
transaction-reverting statements in smart contracts?
•RQ3 (Developer Customization): Are there differences
between template contracts and custom contracts in termsof using transaction-reverting statements?
•RQ4 (Security Impact): Are there any security conse-
quences if transaction-reverting statements are missing insmart contracts?
For the study, we constructed a dataset of 270 template
contracts and 3,866 dapp contracts, which were collected
from popular template code repositories [9]–[12] and real-world dapps with millions of transactions. To answer RQ1, wemeasured the code density of transaction-reverting statementsand compared it with that of general-purpose if statements
in smart contracts. To answer RQ2, we built a taxonomyof the purposes of transaction-reverting statements via aninductive coding process [13]. To answer RQ3, we lever-aged a code clone detector to identify contracts developerscustomized from popular-used contract templates and studiedhow developers customize transaction-reverting statements ata ﬁne granularity of clauses of conditions based on templatecontracts. To answer RQ4, we analyzed the security impactof transaction-reverting statements by removing them fromsmart contracts and comparing the mutated contracts againstthe original ones. Our major ﬁndings include:
•Over 94% of our analyzed smart contracts use transaction-
reverting statements. Comparatively, only 87.9% of themuse general-purpose if statements. This shows that
transaction-reverting statements are pervasively used in real-world smart contracts and may play important roles inassuring the correct execution of transactions.
•Transaction-reverting statements are commonly used toperform seven types of security-critical checks, such asverifying user authorities.
•Developers are most likely to strengthen transaction-reverting statements by adding clauses, variables, ornew transaction-reverting statements. The customizedtransaction-reverting statements are commonly used forrange checks and logic checks.
•The lack of transaction-reverting statements may introducesecurity issues to smart contracts. Existing smart contract se-curity analyzers show weak support in handling transaction-reverting statements when detecting security vulnerabilities.
To summarize, the main contribution of this work is
the character study of transaction-reverting statements in
Ethereum smart contracts. To the best of our knowledge, thisstudy is the ﬁrst of its kind. The ﬁndings can facilitate furtherresearch in smart contract quality assurance and provide prac-tical guidance to smart contract developers on the appropriateuse of transaction-reverting statements. Our data are releasedon GitHub for public usage [14].
The organization of the remaining sections is as follows. In
Section II, we introduce some related background knowledge.Section III presents how we constructed four datasets ofsmart contracts for empirical analysis. Then in Section IV, wepresent the design of the empirical study to answer the fourresearch questions and introduce our data analysis methodolo-gies and empirical ﬁndings. We discuss threats to the validityof our studies in Section V. After that, we discuss relatedworks in Section VI and conclude our work in Section VII.
II. B
ACKGROUND
This section presents the background and explains the
terminologies used in the paper.
A. Smart Contracts & Dapps
Smart contracts are autonomous programs running on
blockchains like Ethereum [2]. The execution of smart con-
tracts does not rely on a trusted third party and is fullydecentralized. Dapps are decentralized applications that canoffer end-users various functionalities. The core logic ofdapps is backed by smart contracts to meet the requirementsof applications. Solidity [5] is the most popular high-levellanguage to program Ethereum smart contracts. In this paper,we focus on the smart contracts written in Solidity.
B. Error-Handling Statements
Solidity uses state-reverting exceptions to handle errors.
It provides four statements to deal with errors, namely,
require, if...revert, assert, and if...throw.I f
631these statements identify the occurrence of erroneous condi-
tions, they will throw an exception and revert the blockchainand contract state to the state before the execution of thetransaction. The four error-handling statements can be furtherdivided into the following two categories [5]:
•Transaction-reverting statements refer to the require,
if...revert, and if...throw statements, that are
used to check for erroneous conditions. Before ver-sion 0.4.10, Solidity provides the if...throw state-
ment for reverting transactions. As the language evolves,there are two more alternatives, namely, require and
if...revert, to replace if...throw since Solid-
ity 0.4.10. The if...throw statement is ofﬁcially dep-
recated in Solidity 0.4.13. These statements can all triggerstate reversion when erroneous conditions occur. The onlydifference between if...throw and the two replacements
is that if...throw will use up all remaining gas when
errors occur, while the two replacements will refund theremaining gas to the transaction sender.
•The assertion statement assert should only be used
for debugging purpose, which are not supposed to exist inproduction code. If a speciﬁed assertion is violated, it meansthat the contract has a bug, which needs to be ﬁxed.
In our study, we focus on transaction-reverting statements.
Since if...throw statement is already deprecated, we
mainly investigate the use of require andif...revert
statements in real-world smart contracts. In the following of
this paper, transaction-reverting statements refer to require
andif...revert statements if not otherwise speciﬁed.
C. Template Contracts & Custom Contracts
Writing a smart contract is non-trivial for developers, es-
pecially when there is a high demand for security [15]. Tofacilitate contract development and prevent vulnerabilities,template contracts are provided by industrial institutions and
organizations for different use cases. These template contractsare usually well-maintained and provide many high-qualityor fully functional components for reuse. In practice, manydevelopers copy or reuse components in template contracts intheir own contracts, which we call custom contracts,t os a v e
efforts and ensure security. Developers’ customizations mayadd, delete, or modify existing transaction-reverting statementsfor various purposes.
D. Solidity Components
Smart contracts written in Solidity are put in .sol ﬁles,
each of which may contain one or more components of three
kinds: contracts, libraries, and interfaces. Template contract
codebases often provide a set of such Solidity componentsthat developers can reuse.
III. D
A TASET CONSTRUCTION
To investigate our research questions, we constructed four
datasets of smart contracts for empirical analysis. This sectionexplains how these datasets were constructed.TABLE I
INFORMA TION OF THEDAPP CONTRACT DA TASET
Category # Contracts Total LOC Avg LOC # Transactions
Exchanges 371 256,652 695.53 1,001,698
Finance 621 460,218 742.29 1,257,473
Gambling 844 864,530 1,018.29 712,299
Game 1,152 853,524 708.32 2,028,069
High-risk 446 265,960 593.66 782,583
Marketplaces 140 120,620 815.00 395,204
Social 70 45,146 654.29 152,429
Utilities 132 78,737 601.05 376,976
Others 90 55,950 608.15 80,302
Total 3,866 3,001,337 763.50 6,787,033
A. Crawling Dapp Contracts
As of April 2021, over 40 million smart contracts have been
deployed on Ethereum [16]. Despite the large volume, many
Ethereum smart contracts are deprecated or rarely used (withfew transactions). In our empirical study, we aim to analyzerepresentative smart contracts that are often used in real life.For this purpose, we chose to collect smart contracts frompopular dapps. Such collected smart contracts are of higherquality, more frequently used, and better maintained.
Speciﬁcally, we collected smart contracts from all 1,699
dapps indexed by Dapp.com [17], a popular dapp collectionwebsite, in February 2021 by referring to the contract ad-dresses listed in the description of dapps. We found that mostdapps have less than 200 contracts, but the dapp Uniswapis an exception. Uniswap [18] is a decentralized exchangethat allows users to exchange one kind of token for anotherkind. It has 3,964 smart contracts because there is a con-tract factory, which will create a contract for every directlyexchangeable token pair on Uniswap, and most such createdcontracts share the same code. To reduce the impact of dataimbalance, we randomly selected 200 contracts for Uniswap(i.e., downsampling). For the other dapps, we collected all theaddresses of their used smart contracts listed on Dapp.com.Then, we leveraged the APIs provided by Etherscan [19], anEthereum block explorer, to collect contract source codes. Intotal, we collected 6,016 smart contracts, and 3,866 of them areveriﬁed ones with source code available, which will be usedin the subsequent studies. Table I provides the demographicinformation of the 3,866 veriﬁed contracts. As we can see,they are from different categories, contain hundreds of linesof code (on average), and have a large number of transactions.
B. Collecting Template Contracts
Template contracts play an important role in the Ethereum
ecosystem. When reusing them, developers may customize the
transaction-reverting statements. To study such customizations,we built a dataset of custom contracts and the correspondingtemplate contracts. For template contracts, we collected themfrom four data sources, which contain smart contracts that arewidely used on Ethereum. For custom contracts, we explainhow to identify them in the next subsection. Table II showsthe popularity of the data sources of template contracts, andwe introduce each of them in the following.
632TABLE II
THEPOPULARITY OF TEMPLA TE CONTRACT DATA SOURCES
Data Source # GitHub Stars # Repository Forks
OpenZeppelin 10k 4.5k
aragonOS 488 190
ConsenSys 4.1k 774
EIPs 6.2k 2.4k
•OpenZeppelin [9] is a library for secure smart contract de-
velopment, which provides reusable contract templates suchas implementations of token standards to help build customcontracts. We collected 115 contracts from OpenZeppelin.
•aragonOS [10] is a smart contract framework for buildingdecentralized organizations, dapps, and protocols. We col-lected 107 contracts from aragonOS.
•ConsenSys [11] provides Solidity smart contract code forsimple, standards-compliant tokens on Ethereum. We col-lected 34 contracts from ConsenSys.
•Besides the above data sources, we also collected 14 ﬁnalEIPs (E
thereum I mprovement P roposals) with 10 reusable
template contracts from the ERC website [12].
In total, we collected 270 template contracts.
C. Identifying Custom Contracts
It isn’t easy to associate template contracts with custom
contracts because developers rarely explicitly specify the
templates they reuse to write smart contracts. To identifycustom contracts, we leveraged a code clone detection tool,SmartEmbed [20], to calculate the code similarity between the270 template contracts and our collected 3,866 dapp contracts.If the code similarity between a dapp contract and a templatecontract is higher than or equal to 85%, we consider thatthe dapp contract is a custom contract based on the templatecontract. Via this process, we identiﬁed a set of 227 customcontracts based on 74 template contracts. We give more detailsof the custom contract dataset in Section IV-C.
D. Creating Mutated Contracts
To investigate the security impact of transaction-reverting
statements in smart contracts, we constructed a dataset of
mutated contracts by removing all transaction-reverting state-ments in the 3,866 contracts. The mutated contracts were lateranalyzed by existing smart contract vulnerability detectiontools to assess their security. A detailed description of themutated contracts is given in Section IV-D.
IV . E
MPIRICAL STUDY
With the four datasets, we conducted a large-scale empirical
study, aiming to 1) understand the use of transaction-revertingstatements in smart contracts, 2) identify good/bad practices,and provide suggestions to help developers appropriately usetransaction-reverting statements, and 3) inspire future research.In this section, we present our data analysis methodology andempirical ﬁndings for each of the four research questions listedin Section I.TABLE III
CODE DENSITY OF CONDITIONAL STA TEMENTS
Conditional Statement TypeTotal Lines
of StatementsCode Density
Transaction-reverting Statement 67,770 49.76
if...throw Statement 2,061 286.74
General-purpose if Statement 66,122 86.92
A. RQ1 (Prevalence)
Study Methodology: To answer RQ1, we measured the
prevalence of transaction-reverting statements in smart con-
tracts. Speciﬁcally, we ﬁrst identiﬁed all the transaction-reverting statements in the 3,866 dapp contracts and then com-puted the code density of these statements. Following existingpractices [21], [22], we computed code density for transaction-reverting statements as LOC/LOT, where LOC is the lines ofcode of a contract and LOT is the lines of transaction-revertingstatements. Similarly, we also computed the code density forgeneral-purpose ifstatements and if...throw statements
for comparison. Note that we separately analyzed general-purpose if,if..throw, and if...revert statements.
When an if statement is used with throw orrevert,w e
will not consider it as a general-purpose ifstatement since it
is used to revert transactions. In addition, we counted the num-ber of transaction-reverting statements within a if...throw
orif...revert code block as one.
Finding 1: In our analyzed smart contracts, transaction-
reverting statements are more frequently used than general-purpose ifstatements.
Among all the 3,866 contracts, 3,647 (94.3%) contracts con-
tain transaction-reverting statements, while only 3,399 (87.9%)contracts contain general-purpose if statements. Table III
gives the detailed results, where the column “Total Lines of
Statements” lists the total number of the concerned statements
in the whole dataset and the “Code Density” column shows the
average code density per contract for each type of statement.As shown in the table, transaction-reverting statements aremore frequently used than general-purpose if statements in
terms of both metrics. On average, there is one transaction-reverting statement per 49.76 lines of code, while general-purpose if statements are used once per 86.92 lines.
Finding 2: 8.6% of our analyzed smart contracts are still
using the deprecated if...throw statements, which may
cause unnecessary ﬁnancial loss to users.
As explained in Section II-B, if..throw statements can
also help revert transactions but using them would incuradditional costs of gas and induce unnecessary ﬁnancial loss tothe contract users. As a result, require andif...revert
statements were introduced in Solidity 0.4.10 as replace-ments and if..throw was ofﬁcially deprecated since So-
lidity 0.4.13 in 2017. However, we found that 332 (8.6%)of our analyzed smart contracts are still using if...throw
statements. Besides, in 252 smart contracts (6.5%), there existsa mixed use of if...throw andrequire statements. We
633further collected the Solidity versions used in these 3,866
contracts. Our results showed that 43 contracts (1.1%) still useSolidity versions before 0.4.10. Such contracts can only use thedeprecated if...throw statements to revert transactions.
The users who submit transactions to these contracts maysuffer from unnecessary costs of gas.
Answer to RQ1: Transaction-reverting statements are
more frequently used in smart contracts than general-purpose if statements. There are still a non-negligible
proportion of contracts using deprecated if..throw
statements, which may incur unnecessary gas consumptionwhen transactions revert.
Implication: Transaction-reverting statements may play an
essential role in assuring the correct execution of trans-
actions. Researchers working on smart contract qualityassurance and security analysis should pay more attentionto such statements as inappropriately using them may leadto abnormal contract behaviors or ﬁnancial losses.
B. RQ2 (Purpose)
Study Methodology: To understand the purposes of using
transaction-reverting statements, we manually analyzed ourcollected smart contracts with the following two steps:
Step 1: Statement selection. Since there are 67,770
transaction-reverting statements in the 3,866 dapp contracts,it is infeasible to analyze all of them manually. For our study,we randomly selected 382 of these statements, representingthe whole set with a conﬁdence level of 95% and a conﬁdence
interval of 5%. For the 270 template contracts, we analyzedall 175 transaction-reverting statements in them.
Step 2: Constructing the purpose taxonomy. To under-
stand and categorize the purposes, we ﬁrst sampled 100 of the557 (= 382 + 175) transaction-reverting statements for a pilotconstruction of the taxonomy. Similar to many existing em-pirical studies, we followed an open coding procedure [13] toinductively create the categories of our taxonomy in a bottom-up manner. Two authors read all the sampled transaction-reverting statements and the corresponding contracts to un-derstand their purposes. The two authors also consideredthe string arguments of the transaction-reverting statementsprovided by the contract owners and the comments around thetransaction-reverting statements when comprehending the con-tract code. They categorized the 100 statements independentlyand marked those unclear or insufﬁcient categories. They thendiscussed and adjusted their category tags during meetingswith the help of a third author to resolve conﬂicts. In thisway, we successfully constructed the pilot taxonomy.
Based on the coding schema in the pilot taxonomy, the
two authors continued to label the remaining 457 transaction-reverting statements for two more iterations. In these two itera-tions, the two authors went back and forth between categoriesand transaction-reverting statements to reﬁne the taxonomy.The conﬂicts of labeling were again discussed during meetingsand resolved by the third author. In this way, we adjusted thepilot taxonomy and obtained the ﬁnal results. We used theCohen’s Kappa score [23] to measure the agreement betweenthe two authors. The overall score is 0.73, indicating that thetwo authors had a high agreement on the taxonomy.
As shown in Table IV, the ﬁnal taxonomy is organized
into two categories, each of which is further divided into sub-categories. There is no overlap between these sub-categories,i.e., a clause in a transaction-reverting statement can only beclassiﬁed into one of them. The table also provides illustrativeexamples collected from our datasets to ease understanding.
Finding 3: Transaction-reverting statements are commonly
used to perform seven types of authority veriﬁcations orvalidity checks.
Authority Veriﬁcation. 76 of the 435 clauses in the 382
transaction-reverting statements in the dapp contracts are forAuthority V eriﬁcation. The ﬁgure for the template contractsis 31 of 175. Authority V eriﬁcation aims to check whether agiven contract address or token ID is authorized by the contractowner for the sake of security:
•Address Authority Check is to check whether a given
address, mostly the address of the transaction sender, isauthorized by the contract owner. We observed two types ofaddress checks. One is to check whether the given addressequals to a speciﬁed address. The other is to check whetherthe given address is within a list of authorized addresses. Theproportions of transaction-reverting statements that performaddress authority checks in dapp contracts and template con-tracts are 14.9% and 16.0%, respectively.
•T oken V eriﬁcation. Tokens are value counters stored
in a contract, which are mappings of addresses to accountbalances. Token veriﬁcation checks whether a given tokenID is authorized, i.e., within the mappings of addresses. Theproportions of transaction-reverting statements that performtoken veriﬁcation in dapp contracts and template contracts are2.5% and 1.7%, respectively.
Validity Check. 359 of the 435 clauses in the 382
transaction-reverting statements in the dapp contracts are forvalidity checks. The ﬁgure for the template contracts is 144of 175. Generally, validity checks are performed to check ifcertain runtime values are valid, i.e., satisfying pre-deﬁnedconditions. We observed ﬁve sub-categories of validity checks:
•Logic Check refers to the use of logical operators to
check the validity of certain runtime values. Such checksare commonly seen in the conditions of transaction-revertingstatements, such as checking the return value of a low-levelfunction call, checking the value of a boolean ﬂag, and so on.37.7% dapp contracts and 29.1% template contracts containtransaction-reverting statements for logic checks.
•Range Check is to check whether a runtime value (e.g.,
an input) is within a speciﬁc range. 29.4% dapp contractsand 26.9% template contracts contain transaction-revertingstatements for range checks.
•Overﬂow/Underﬂow Check is to check whether an input
value crosses the limit of the prescribed size for a datatype. 14.9% template contracts contain transaction-reverting
634TABLE IV
THEPURPOSES OF USING TRANSACTION -REVERTING STA TEMENTS IN THE PARAGRAPHS .
CategoryFirst-Level
Sub-CategorySecond-LevelSub-CategoryDescription Illustrative Example
AuthorityV eriﬁcationAddressAuthorityCheckEqual toa speciﬁcaddressCheck whether a contract addressis equal to a 20 bytes addressspeciﬁed by the contract owner.require(msg.sender ==
address(nonFungibleContract));
Withina speciﬁcaddress listCheck whether a contract addressis in a address list provided bythe contract owner.require(isAuthorized(msg.sender,msg.sig));
TokenV eriﬁcation-Some developers use a token IDto identify a contract address.The veriﬁcation of the token IDis actually the veriﬁcation ofa contract address.require(_exists(tokenId),"URI query for nonexistent token");(
exists() maps a token ID to a contract address
using a mapping to verify the contract address.)
V alidityCheckLogicCheck-Check runtime valuesusing logical operators.require(!_mintingFinished);
RangeCheck-Check whether the value ofa variable is within a value range.require(underlyingBalance > 0,"Not have any liquidity deposit");
Overﬂow/UnderﬂowCheck-Check whether the value of thevariable is out of range of thedeclared data type.require( ( z=x+y)>= x);
ArithmeticCheck-Check runtime values againstarithmetic constraints.require( b! =0 ) ;c=a/b ;
AddressV alidityCheck-Check whether a contract addressis a valid one.require(owner != address(0));
statements for overﬂow/underﬂow checks, while the ratio is
only 3.9% for dapp contracts. We further investigated thecorresponding template contracts and found that many of themadopt the SafeMath library, which provides safe number
operations to protect contracts from overﬂow/underﬂow vul-nerabilities. This also shows that template contracts emphasizemore on security, comparing than ordinary dapp contracts.
•Arithmetic Check is to check whether the value of a
variable violates common constraints in arithmetic operations,such as divided by 0, mod 0, etc. These checks are notfrequently performed comparing to the above categories. Only0.7% dapp contracts and 2.3% template contracts containtransaction-reverting statements for arithmetic checks.
•Address V alidity Check is to check whether a contract
address is valid. Note that this is different from the addressauthority check discussed above, which is to check whetheran address is an authorized one (a valid address may not beauthorized). For example, a common address validity check isto check whether a contract address is equal to address(0)
in an ether transfer function. When the address is zero, anew contract will be created instead of transferring ether. Toavoid such cases, address validity checks should be performed.10.8% dapp contracts and 7.4% template contracts containtransaction-reverting statements for address validity checks.
During our manual analysis, three clauses could not be
categorized into the above sub-categories. Since they are notcommon, we do not further discuss them in the paper.
From the above analysis, we can see that dapp con-
tracts and template contracts show differences in usingtransaction-reverting statements. 14.9% template contracts
contain transaction-reverting statements for overﬂow/under-ﬂow checks, while the percentage in dapp contracts is only3.9%. Besides, dapp contracts show higher percentages inusing transaction-reverting statements for logic checks, rangechecks, and address validity checks. One possible reasonis that developers will consider more speciﬁc factors whenapplying smart contracts to a real Ethereum environment,which could be complicated since a smart contract may need tointeract with other contracts and user accounts. Comparatively,developers should consider general factors when developingtemplate contracts and cannot anticipate the speciﬁc conditionsthat may arise in real environments.
Answer to RQ2: Transaction-reverting statements are
commonly used to perform authority veriﬁcations andvalidity checks, many of which involve security-criticalconstraints. Template contracts and dapp contracts havedifferent purposes for using transaction-reverting state-ments.
Implication: Since transaction-reverting statements of-
ten check the runtime status of smart contracts against
security-critical constraints, it is crucial to ensure theproper use of such statements. Future research canstudy the vulnerabilities induced by various misuses oftransaction-reverting statements and propose detection orrepairing techniques to combat such vulnerabilities.
C. RQ3 (Developer Customization)
Study Methodology: As discussed earlier, many developers
customize template contracts to develop their own smartcontracts. In RQ3, we aim to understand how developers cus-tomize transaction-reverting statements in template contracts.
635TABLE V
STA TISTICS OF THEPURPOSES OF TRANSACTION -REVERTING STA TEMENTS IN DAPP CONTRACTS AND TEMPLA TE CONTRACTS
Category First-Level Category # Dapp Contracts Ratio # Template Contracts Ratio
Authority V eriﬁcationAddress Authority Check 65 14.9% 28 16.0%
Token V eriﬁcation 11 2.5% 3 1.7%
V alidity CheckLogic Check 164 37.7%5 1 29.1%
Range Check 128 29.4% 47 26.9%
Overﬂow/Underﬂow Check 17 3.9%2 6 14.9%
Arithmetic Check 3 0.7% 4 2.3%
Address V alidity Check 47 10.8% 13 7.4%
Other 0 0.0% 3 1.7%
Total 435 100.0% 175 100.0%
TABLE VI
CONTRACT PRE-PROCESSING RESULT
# Contracts # Interfaces # Libraries
Template contracts (270) 190 32 27
Dapp contracts (3,866) 4,563 1,191 484
Step 1: Mapping Template & Custom Contracts: To
answer RQ3, the ﬁrst step is to build a dataset containing
template contracts and their corresponding custom contracts.However, real-world smart contracts rarely explicitly specifywhether they are customized from a certain template or not.To address this problem, we leveraged code clone detectiontechniques to compute the similarities between each of ourcollected template contracts and the dapp contracts. We con-sidered a dapp contract customized from a template contractif the two contracts have a high similarity.
A smart contract can contain multiple components, includ-
ing contracts, libraries, and interfaces. In practice, differentcomponents are usually put in one ﬁle in dapp contracts,while in template contracts, a ﬁle usually contains a singlecomponent. To normalize the two kinds of contracts, we ﬁrstbroke down the dapp contracts into components and then com-pared the contracts at the component level. Table VI presentsthe result after this pre-processing step, where # Contracts,# Interfaces, and # Libraries represent the number of individualcontracts, libraries, and interfaces, respectively.
We then adopted a code clone detector, SmartEmbed [20],
to compare the dapp contracts with the template contracts.SmartEmbed computes similarities between two contractsbased on word embeddings, and it has been shown to be effec-tive in code clone detection for smart contracts. Following theoriginal experiment setting of SmartEmbed, a dapp contractis considered a custom contract of a template contract if thesimilarity between these two contracts is higher than 85%. Wechose this threshold because it achieves the highest recall inthe evaluation of SmartEmbed.
As interfaces do not contain any statements, we excluded
them from our dataset. In total, we obtained 175 contractsand 52 libraries from dapp contracts that are similar to tem-plate contracts. These contracts and libraries form the customcontracts dataset for our subsequent analysis.
Step 2: Detecting Customization Patterns: We lever-aged the custom contracts to investigate how developers cus-tomized transaction-reverting statements. Inspired by an exist-ing study that characterizes changes to if statements [24],
we derived a taxonomy of possible customization patternsfor transaction-reverting statements as shown in Table VII.Since transaction-reverting statements are also conditionalstatements, the change patterns of if conditional statements
can also be applied to transaction-reverting statements. How-ever, we found that patterns identiﬁed in the existing work(marked with * in Table VII) are not sufﬁcient to cover allcustomizations on transaction-reverting statements. To identifymore patterns, we manually analyzed 30% of the customized
transaction-reverting statements. Speciﬁcally, we compared thetransaction-reverting statements in the custom contracts withthose in the corresponding template contracts and identiﬁedcommon customizations by checking the conditions of thetransaction-reverting statements. Via the sampling and manualanalysis, we identiﬁed ﬁve more patterns.
To investigate the prevalence of the customization patterns
and identify commonly used ones, we implemented a staticanalyzer based on a Solidity parser [25] to automaticallyidentify the occurrences of each customization pattern. Foreach pair of a template contract and a corresponding customcontract, we matched their functions by the function namesand input parameters. Functions with the same name andinput parameters are seen as matched function pairs. For eachmatched function pair, the analyzer 1) parses the source codeinto AST trees, 2) extracts all transaction-reverting statements,and 3) recognizes the customization patterns by comparingthe syntactic differences of the transaction-reverting statementsin the two functions. More details about the analyzer can befound on our project website [14].
Finding 4: Transaction-reverting statements in template
contracts are commonly customized. Developers are mostlikely to strengthen transaction-reverting statements by addingclauses, variables, or new transaction-reverting statements.
Table VII shows the frequency of each customization pat-
tern. In the 175 custom contracts and 53 custom libraries,our analyzer identiﬁed 529 occurrences of customization pat-terns. This indicates that developers commonly customizetransaction-reverting statements in template contracts. 50.1%of the customizations are statement-level changes involving
636TABLE VII
CUSTOMIZA TION PA TTERNS OF TRANSACTION -REVERTING STA TEMENTS
Category Customization Patterns Description Count Percentage
AddAdd Clauses* Add new clauses to a condition. 47 8.9%
Add V ariables* Use new variables in the condition. 27 5.1%
Add Statements Add new transaction-reverting statements. 161 30.4%
Sub-Total 235 44.4%
DeleteDelete Clauses* Remove some clauses from a condition. 41 7.8%
Delete V ariables* Remove some variables used in the condition. 24 4.5%
Delete Statements Delete some transaction-reverting statements. 104 19.7%
Sub-Total 169 31.9%
ChangeModify Statement TypesChange transaction-reverting statements to other kinds
of statements (e.g., change a require statement
to an if statement) while the condition remains the same.4 0.8%
Modify ClausesMake modiﬁcations to the clauses in the conditionof a transaction-reverting statements.59 11.2%
Sub-Total 63 11.9%
Other Cosmetic ChangesModiﬁcations that do not change the semanticsof the transaction-reverting statements.62 11.7%
Total 529 100.0%
Note: Patterns marked with * are deﬁned by an existing work [24]. The remaining patterns are newly identiﬁed by us.
the addition or removal of a transaction-reverting statement.
27.8% lie in clause granularity, including adding, deleting,and modifying a clause within the condition of a transaction-reverting statement. It is infrequent for developers to changetransaction-reverting statements to other kinds of statementswhile keeping the condition unchanged (0.8%). In our dataset,all of the four cases in this category are changing transaction-reverting statements to general-purpose if statements.
44.4% of the customizations fall into the “add” category,
31.9% fall into the “delete” category, and 11.9% involvedchanges. Besides, 11.7% customizations are cosmetic changes,such as changing the order of clauses, adding or removinga string message, etc. These changes do not alter the se-mantics of the original transaction-reverting statements. Theseresults show that developers are more likely to strengthen thetransaction-reverting statements in template contracts.
Finding 5: The customized transaction-reverting statements
are commonly used for range checks and logic checks.
We further investigated the purposes of customizing
transaction-reverting statements. We randomly sampled 100customized transaction-reverting statements and manually an-alyzed their purpose according to the taxonomy in Table IV.
Table VIII shows the analysis results. For the 100 state-
ments, we identiﬁed 112 customized clauses and categorizedthem accordingly. The results indicate that the most frequentpurposes of the customized transaction-reverting statementsare logic check (30.4%), range check (48.2%), and address
validity check (6.3%). This is reasonable since custom con-
tracts may need to deal with use cases different from thoseencountered by template contracts. They would naturally havedifferent deﬁnitions of the validity of runtime values. Figure 3shows an example of a transaction-reverting statement in acustom contract.require (
_amount > uint256 (0),
"Stake amount must not be zero."
);
Fig. 3. An example customization with Range Check purpose
require (msg.sender == ceo, "CEO Only" );
require (msg.sender == coo, "COO Only" );
require (msg.sender == cfo, "CFO Only" );
Fig. 4. An example customization with Address Authority Check purpose
It is a stake contract that allows EIP20 token to be staked.
Staking is the process of investing tokens into the networkand get a reward for doing it. Compared with the EIP20 tokentemplate contract, the custom contract adds a transaction-reverting statement to do Range Check to ensure that the staked
amount provided by a staker is greater than 0, which intendsto prevent the Integer Underﬂow vulnerability [26].
The other 17 (15.2%) customizations are related to ad-
dress authority check, among which, ten added statementsto perform authorization check on addresses and four deletedstatements for address authority check. This is also understand-able since custom contracts can have customized permissionsettings for different account types. For example, if there aremultiple authorized users with different identities, the customcontract should add new transaction-reverting statements toverify the identity of the transaction sender to prevent unau-thorized operations, as shown in Figure 4.
637TABLE VIII
THENUMBER OF USE PURPOSE FOR CUSTOMIZA TION PA TTERNS OF TRANSACTION -REVERTING STA TEMENTS
Category Sub-Category # TotalAdd Delete Modify Other
# Add
Statements# AddClauses# AddVariables# DeleteStatements# DeleteClauses# DeleteVariables# ModifyStatement Types# ModifyClauses# CosmeticChanges
AuthorityV eriﬁcationAddress Authority Check 17 10 0 0 4 0 0 0 2 1
Token V eriﬁcation 0 0 0 0 0 0 0 0 0 0
V alidityCheckLogic Check 34 19 00 8 00 01 6
Range Check 54 27 14 5 32 06 6
Overﬂow/Underﬂow Check00 0 00 0 0 0 00
Arithmetic Check 0 0 0 0 0 0 0 0 0 0
Address V alidity Check 7 3 0 1 1 0 0 0 0 2
Other 0 0 0 0 0 0 0 0 0 0
Total 112 59 1 5 18 3 2 0 9 15
Answer to RQ3: Transaction-reverting statements in tem-
plate contracts are commonly customized when developing
smart contracts. Developers tend to strengthen transaction-reverting statements, mainly for logic and range checks.
Implication: The customizations of transaction-reverting
statements often serve security purposes. Future research
may also focus on investigating the security impact of thecustomizations of transaction-reverting statements.
D. RQ4 (Security Impact)
Study Methodology: To answer RQ4, we mutated the dapp
contracts by removing the transaction-reverting statements. Wethen leveraged smart contract security analyzers to detect thevulnerabilities in the original and the mutated contracts andcompared the detection results. Speciﬁcally, we adopted astate-of-the-art framework, SmartBugs [27], to conduct thestudy. It integrates nine smart contract security analyzers,including HoneyBadger [28], Slither [29], Manticore [30],etc. Collectively, these nine analyzers can detect 141 typesof vulnerabilities, while many of them refer to the sametypes of vulnerabilities but have different names. To unifythe vulnerability types, we followed the existing practices [27]and used DASP [31], a smart contract vulnerability taxonomy,to categorize the reported vulnerabilities. Another problemwith these analyzers is that they may generate many falsealarms due to the imprecise static analyses [27]. To mitigatethis problem, we followed the existing practice [27] and onlycounted those vulnerabilities that are reported by at least twoof the nine analyzers.
Finding 6: Missing transaction-reverting statements can
introduce security vulnerabilities to smart contracts.
Table IX presents the number of original dapp contracts
and mutated contracts that are reported to contain vulnera-bilities. The number of vulnerable contracts increases afterremoving the transaction-reverting statements. In particular,the number of contracts containing Time Manipulation and
Front Running vulnerabilities increase signiﬁcantly, by 16.98%
and 12.90%, respectively. This shows that transaction-revertingstatements are useful in improving the security of smartcontracts. To ease understanding, we provide an example.Figure 5 shows a code snippet in a real smart contract. AfterTABLE IX
THENUMEBER OF CONTRACTS WITH A T LEAST ONE
VULNERABILITY DETECTED BY MULTIPLE ANALYZERS
Vulnerability Category # Before # After Increase Ratio
Access Control 3,857 3,857 0.00%
Arithmetic 1,871 2,041 9.09%
Denial Service 174 178 2.30%
Reentrancy 634 671 5.84%
Unchecked Low Calls 254 255 0.39%
Front Running 550 621 12.90%
Time Manipulation 132 159 16.98%
Unknown Unknowns 690 738 6.96%
“# Before” and “# After” present the security vulnerability detection
results for the original contracts and the mutated contracts, respectively.
1function requireCorrectReceipt( uint offset) view
private {
2 uint leafHeaderByte; assembly { leafHeaderByte
:=byte(0, calldataload(offset)) }
3 require (leafHeaderByte >= 0xf7, "Receipt leaf
longer than 55 bytes." );
4 offset += leafHeaderByte - 0xf6;
5 ...
6}
Fig. 5. The number of vulnerabilities increases after mutation in contract0x9F91b5Aa41b9fbDae6877593910586484d291F05.
removing the transaction-reverting statement in Line 3, the
contract is reported to have an Underﬂow/Overﬂow vulner-
ability [26]. In this example, both leafHeaderByte and
offset are unsigned integers. If Line 3 is removed, the value
ofleafHeaderByte in Line 4 can be smaller than 0xf7,
which may lead to an underﬂow.
Finding 7: Smart contract security analyzers can fail to
analyze transaction-reverting statements properly and inducefalse negatives in security vulnerability detection.
When inspecting the results reported by the nine analyzers,
we found that there are also cases where vulnerabilities inoriginal smart contracts disappear after removing transaction-reverting statements. This is counter-intuitive as we have foundthat transaction-reverting statements are commonly used forsecurity checks. We found out that eight out of the ninecontract analyzers (except Maian [32]) used in our studysuffered from this problem. We further inspected such cases
6381function contributeWithAddress( address contributor)
payable {
2 require (msg.value >= minContribAmount);
3
4 uint contribValue = msg.value ;
5 uint oldTotalContributed = totalContributed;
6 totalContributed = oldTotalContributed.add(
contribValue);
7 uint newTotalContributed = totalContributed;
8
9 if(newTotalContributed >= softCapAmount &&
10 oldTotalContributed < softCapAmount)
11 {
12 softCapReached = true;
13 endTime = afterSoftCapDuration.add( now);
14 onSoftCapReached(endTime);
15 }
16 ...
17}
Fig. 6. The number of vulnerabilities decreases after mutation in contract
0x0AbdAce70D3790235af448C88547603b945604ea.
identiﬁed in our dataset.
Figure 6 shows a code snippet in a real smart contract.
The function contributeWithAddress() is reported
to have a Timestamp Dependence vulnerability [33]. Due
to the direct use of now (Line 16) which is an alias of
block.timestamp, a malicious block miner can manip-
ulate the block’s timestamp to gain proﬁts from the contract.In this case, the transaction-reverting statement in Line 2 is notrelated to the vulnerability as it is not checking against blocktimestamp. In other words, after removing it, the Timestamp
Dependence vulnerability should still exist. However, the tool
Osiris [34] does not report the vulnerability after removing thistransaction-reverting statement. This shows that Osiris can befooled by the removal of transaction-reverting statements andinduce false negatives.
We observed 5,404 such cases in our dataset where the
originally detected vulnerabilities disappeared after removingtransaction-reverting statements. In our future work, we planto take a deeper look into this problem and investigate whyremoving transaction-reverting statements can fool smart con-tract security analyzers.
Answer to RQ4: Missing transaction-reverting statements
can induce security vulnerabilities in smart contracts. Inother words, transaction-reverting statements can be usedto avoid vulnerabilities effectively. However , there arealso cases where removing irrelevant transaction-revertingstatements can fool smart contract analyzers and inducefalse negatives in security vulnerability detection.
Implication: Researchers need to further improve the effec-
tiveness of smart contract security analyzers. In particular ,
properly dealing with transaction-reverting statements is abasic and critical requirement for such tools.V. T HREA TS TO V ALIDITY
The validity of our study results may be subject to several
threats. First, our selected template contracts may not besufﬁciently diverse or representative. To mitigate this threat,we considered the popularity of the templates in the selectionprocess. The four template contract repositories are all widelyused by developers on GitHub [35]. Second, we proposeda taxonomy to categorize the purposes of using transaction-reverting statements in Table IV. There could be other ways tocategorize the purposes. To address this threat, we followed thewidely-used open coding procedure to derive the results. Third,our study results may be affected by human subjectivity, whichis a common problem in qualitative coding [36]. To reduce thisthreat, we followed the common research practices on manuallabeling by involving multiple people. Three authors iteratedthe labeling process three times to obtain the ﬁnal taxonomy.This helped improve the reliability and generality of ourtaxonomy. Our data is also released for public scrutiny [14].Fourth, we used a code clone technique, SmartEmbed [37],to identify custom contracts of template contracts and set thecode similarity threshold as 85% following the experiments inthe original paper to reduce false negatives. The chosen codeclone technique and threshold may affect the mapping results.Also, the subjects used when investigating RQ3 are limited.We will keep expanding our dataset in the future and tryingother clone detectors to see if more reliable results can beobtained. Lastly, we used a framework supporting nine smartcontract security analyzers to detect vulnerabilities in RQ4.False positives and false negatives can both exist in the results.To reduce the threat, we only kept results for items detectedas vulnerable by more than one analyzer. Besides, the qualityof transaction-reverting statements used in our constructedcontract dataset may affect the accuracy of the results sinceour analysis is based on the assumption that the transaction-reverting statements analyzed are correct. We plan to conductmore experiments and analyses in future studies to validateour ﬁndings further.
VI. R
ELA TED WORK
Error-handling Statements. V arious studies have been
conducted to characterize error-handling statements in otherareas. Filho et al. [38] studied the impacts of factors that affectthe exception handling code in aspect-oriented programming(AOP) techniques. Tian et al. [39] conducted a comprehensivestudy of error-handling bugs and their ﬁxes and implementedErrDoc, a tool to diagnose and repair error-handling bugsin C programs automatically. Some other studies [40]–[44]automatically detected and patched error-handling bugs usinga variety of techniques. Different from the previous studies,our work conducts the ﬁrst empirical study on transaction-reverting statements (a type of error-handling statements) forEthereum smart contracts. It reveals the security impact oftransaction-reverting statements, which is speciﬁc to smartcontracts.
In terms of smart contracts, several previous studies have
discussed the usefulness of transaction-reverting statements
639for providing defenses for vulnerabilities. Xue et al. [45]
showed that the require statement could be used to pre-
vent reentrancy vulnerability. Zhou et al. [46] observed thatmost smart contracts implemented defenses via transaction-reverting statements to abort a transaction when noticing anattack. However, these studies only reported the use cases oftransaction-reverting statements for speciﬁc purposes and didnot regard them as their major focuses. In comparison, ourwork is the ﬁrst empirical study that systematically character-izes the use of transaction-reverting statements in real-worldsmart contracts.
Smart Contract Vulnerability Detection. In recent years,
there have been many studies targeting smart contract vul-nerability detection. Static analysis methods inspected thecode of smart contracts without executing them. Examplesare Oyente [47], Zeus [48], V andal [49], Securify [50], F*
Framework [51], and Fether [52]. Dynamic analysis meth-
ods check the runtime behavior of smart contracts to detectvulnerabilities. Nikolic et al. [53] employed inter-proceduralsymbolic analysis and concrete validators for detecting realsecurity vulnerabilities. Ting et al. [54] constructed three kindsof graphs to characterize major activities on Ethereum andproposed graph-based techniques to detect security issues.While these studies proposed different techniques to detectvulnerabilities in smart contracts, none discussed the securityimpact of transaction-reverting statements. Our work showedthe prevalence of transaction-reverting statements and con-cluded the security impact of such statements. Our ﬁndingscan help improve security vulnerability detection techniquesfor smart contracts.
VII. C
ONCLUSION AND FUTURE WORK
In this work, we present the ﬁrst empirical study on
transaction-reverting statements in Ethereum smart contracts.Through intensive analyses of 3,866 real-world smart con-tracts and 270 popular template contracts, we showed thattransaction-reverting statements are prevalent in smart con-tracts. They are often used to check the runtime status ofsmart contracts against security-critical constraints. Our studycharacterizes the usage of transaction-reverting statements inpractice and may shed light on future research in areas suchas smart contract security and quality assurance.
In the future, we plan to extend our study by investigating
the challenges in properly using transaction-reverting state-ments and identifying security issues induced by the misuseof transaction-reverting statements. We also plan to leverageour ﬁndings to improve the security vulnerability detectiontechniques for smart contracts.
A
CKNOWLEDGMENT
This work was supported by the National Natural Science
Foundation of China (Grant No. 61932021 and No. 62002125),Hong Kong RGC/GRF (Grant No. 16207120), Hong KongRGC/RIF (Grant No. R5034-18) and Guangdong ProvincialKey Laboratory (Grant No. 2020B121201001). Lili Wei was
supported by the Postdoctoral Fellowship Scheme of the Hong
Kong Research Grant Council.R
EFERENCES
[1] “Top 12 smart contract use cases,” https://101blockchains .com/smart-
contract-use-cases/.
[2] “Ethereum: A secure decentralized generalized transaction ledger,” https:
//ethereum.github.io/yellowpaper/paper.pdf.
[3] “Coinmarketcap. top 100 cryptocurrencies by market capitalization,”
https://coinmarketcap.com/.
[4] “Ethereum daily transactions chart,” https://etherscan.io/chart/tx.
[5] “Solidity documentation v0.8.3,” https://docs.soliditylang.org/en/
v0.8.3/.
[6] “Stack overﬂow website,” https://stackoverﬂow.com/.[7] “Swc registry,” https://swcregistry.io/.[8] “Swc 104: Unchecked call return value,” https://swcregistry.io/docs/
SWC-104.
[9] “Openzeppelin contract library,” https://github.com/OpenZeppelin/
openzeppelin-contracts.
[10] “Aragonos smart contract framework,” https://github.com/aragon/
aragonOS.
[11] “Ethereum smart contract best practices,” https://github.com/ConsenSys/
smart-contract-best-practices/.
[12] “Ethereum improvement proposals,” https://eips.ethereum.org/erc.[13] C. B. Seaman, “Qualitative methods in empirical studies of software
engineering,” IEEE Transactions on Software Engineering, vol. 25, no. 4,
pp. 557–572, 1999.
[14] “Dataset for ‘characterizing transaction-reverting statements in ethereum
smart contracts’,” https://github.com/transaction-reverting-statements/Characterizing-require-statement-in-Ethereum-Smart-Contract.git.
[15] W. Zou, D. Lo, P . S. Kochhar, X.-B. D. Le, X. Xia, Y . Feng, Z. Chen,
and B. Xu, “Smart contract development: Challenges and opportunities,”IEEE Transactions on Software Engineering, 2019.
[16] “Ethereum in bigquery: a public dataset for smart contract ana-
lytics,” https://cloud.google.com/blog/products/data-analytics/ethereum-bigquery-public-dataset-smart-contract-analytics.
[17] “Dapp.com,” https://www.dapp.com/.[18] “Uniswap,” https://uniswap.org/.[19] “Etherscan,” https://etherscan.io/.[20] Z. Gao, L. Jiang, X. Xia, D. Lo, and J. Grundy, “Checking smart con-
tracts with structural code embedding,” IEEE Transactions on Software
Engineering, 2020.
[21] D. Y uan, S. Park, and Y . Zhou, “Characterizing logging practices
in open-source software,” in Proceedings of the 2012 International
Conference on Software Engineering, 2012, pp. 102–112.
[22] J. Harty, H. Zhang, L. Wei, L. Pascarella, M. Aniche, and W. Shang,
“Logging practices with mobile analytics: An empirical study on ﬁre-base,” arXiv preprint arXiv:2104.02513, 2021.
[23] J. Cohen, “A coefﬁcient of agreement for nominal scales,” Educational
and psychological measurement, vol. 20, no. 1, pp. 37–46, 1960.
[24] K. Pan, S. Kim, and E. J. Whitehead, “Toward an understanding of
bug ﬁx patterns,” Empirical Software Engineering, vol. 14, no. 3, pp.
286–315, 2009.
[25] “Python solidity parser,” https://github.com/ConsenSys/python-solidity-
parser.
[26] “Swc 101: Integer overﬂow and underﬂow,” https://swcregistry .io/docs/
SWC-101.
[27] T. Durieux, J. F. Ferreira, R. Abreu, and P . Cruz, “Empirical review
of automated analysis tools on 47,587 ethereum smart contracts,” inProceedings of the 2020 ACM/IEEE 42nd International Conference onSoftware Engineering, 2020, pp. 530–541.
[28] C. F. Torres, M. Steichen et al., “The art of the scam: Demystifying
honeypots in ethereum smart contracts,” in Proceedings of the 2019
28th Usenix Security Symposium, 2019, pp. 1591–1607.
[29] J. Feist, G. Grieco, and A. Groce, “Slither: a static analysis framework
for smart contracts,” in Proceedings of the 2019 IEEE/ACM 2nd In-
ternational Workshop on Emerging Trends in Software Engineering forBlockchain, 2019, pp. 8–15.
[30] M. Mossberg, F. Manzano, E. Hennenfent, A. Groce, G. Grieco, J. Feist,
T. Brunson, and A. Dinaburg, “Manticore: A user-friendly symbolicexecution framework for binaries and smart contracts,” in Proceedings
of the 2019 IEEE/ACM 34th International Conference on AutomatedSoftware Engineering, 2019, pp. 1186–1189.
[31] “Decentralized application security project(dasp),” https://dasp.co/.[32] “Maian,” https://github.com/ivicanikolicsg/MAIAN.
640[33] “Swc 116: Block values as a proxy for time,” https://swcregistry.io/docs/
SWC-116.
[34] C. F. Torres, J. Sch ¨utte, and R. State, “Osiris: Hunting for integer bugs in
ethereum smart contracts,” in Proceedings of the 34th Annual Computer
Security Applications Conference, 2018, pp. 664–676.
[35] “Github,” https://github.com/.
[36] Y . Chandra and L. Shang, Qualitative research using R: A systematic
approach. Springer, 2019.
[37] Z. Gao, V . Jayasundara, L. Jiang, X. Xia, D. Lo, and J. Grundy,
“Smartembed: A tool for clone and bug detection in smart contractsthrough structural code embedding,” in Proceedings of the 2019 IEEE
International Conference on Software Maintenance and Evolution, 2019,pp. 394–397.
[38] F. Castor Filho, A. Garcia, and C. M. F. Rubira, “Extracting error
handling to aspects: A cookbook,” in Proceedings of the 2007 IEEE
International Conference on Software Maintenance, 2007, pp. 134–143.
[39] Y . Tian and B. Ray, “Automatically diagnosing and repairing error
handling bugs in c,” in Proceedings of the 2017 11th Joint Meeting
on Foundations of Software Engineering, 2017, pp. 752–762.
[40] W. Weimer and G. C. Necula, “Finding and preventing run-time error
handling mistakes,” in Proceedings of the 19th annual ACM SIGPLAN
Conference on Object-oriented programming, systems, languages, andapplications, 2004, pp. 419–431.
[41] M. Susskraut and C. Fetzer, “Automatically ﬁnding and patching bad
error handling,” in Proceedings of the 2006 Sixth European Dependable
Computing Conference, 2006, pp. 13–22.
[42] J. Lawall, B. Laurie, R. R. Hansen, N. Palix, and G. Muller, “Finding
error handling bugs in openssl using coccinelle,” in Proceedings of the
2010 European Dependable Computing Conference, 2010, pp. 191–196.
[43] S. Jana, Y . J. Kang, S. Roth, and B. Ray, “Automatically detecting error
handling bugs using error speciﬁcations,” in Proceedings of the 2016
25th USENIX Security Symposium, 2016, pp. 345–362.
[44] Z. Jia, S. Li, T. Y u, X. Liao, J. Wang, X. Liu, and Y . Liu, “Detecting
error-handling bugs without error speciﬁcation input,” in Proceedings
of the 2019 34th IEEE/ACM International Conference on AutomatedSoftware Engineering, 2019, pp. 213–225.[45] Y . Xue, M. Ma, Y . Lin, Y . Sui, J. Ye, and T. Peng, “Cross-contract static
analysis for detecting practical reentrancy vulnerabilities in smart con-tracts,” in 2020 35th IEEE/ACM International Conference on Automated
Software Engineering (ASE). IEEE, 2020, pp. 1029–1040.
[46] S. Zhou, M. M ¨oser, Z. Yang, B. Adida, T. Holz, J. Xiang, S. Goldfeder,
Y . Cao, M. Plattner, X. Qin et al., “An ever-evolving game: Evaluation of
real-world attacks and defenses in ethereum ecosystem,” in Proceedings
of the 2020 29th Usenix Security Symposium, 2020, pp. 2793–2810.
[47] L. Luu, D.-H. Chu, H. Olickel, P . Saxena, and A. Hobor, “Making smart
contracts smarter,” in Proceedings of the 2016 ACM SIGSAC conference
on computer and communications security, 2016, pp. 254–269.
[48] S. Kalra, S. Goel, M. Dhawan, and S. Sharma, “Zeus: Analyzing safety
of smart contracts.” in Proceedings of the 2018 ISOC Network and
Distributed System Security Symposium, 2018, pp. 1–12.
[49] L. Brent, A. Jurisevic, M. Kong, E. Liu, F. Gauthier, V . Gramoli, R. Holz,
and B. Scholz, “V andal: A scalable security analysis framework for smartcontracts,” arXiv preprint arXiv:1809.03981, 2018.
[50] P . Tsankov, A. Dan, D. Drachsler-Cohen, A. Gervais, F. Buenzli, and
M. V echev, “Securify: Practical security analysis of smart contracts,” inProceedings of the 2018 ACM SIGSAC Conference on Computer andCommunications Security, 2018, pp. 67–82.
[51] K. Bhargavan, A. Delignat-Lavaud, C. Fournet, A. Gollamudi,
G. Gonthier, N. Kobeissi, N. Kulatova, A. Rastogi, T. Sibut-Pinote,N. Swamy et al., “Formal veriﬁcation of smart contracts: Short paper,”
inProceedings of the 2016 ACM workshop on programming languages
and analysis for security, 2016, pp. 91–96.
[52] Z. Yang and H. Lei, “Fether: An extensible deﬁnitional interpreter for
smart-contract veriﬁcations in coq,” IEEE Access, vol. 7, pp. 37 770–
37 791, 2019.
[53] I. Nikoli ´c, A. Kolluri, I. Sergey, P . Saxena, and A. Hobor, “Finding the
greedy, prodigal, and suicidal contracts at scale,” in Proceedings of the
2018 34th Annual Computer Security Applications Conference, 2018,pp. 653–663.
[54] T. Chen, Z. Li, Y . Zhu, J. Chen, X. Luo, J. C.-S. Lui, X. Lin,
and X. Zhang, “Understanding ethereum via graph analysis,” ACM
Transactions on Internet Technology, vol. 20, no. 2, pp. 1–32, 2020.
641