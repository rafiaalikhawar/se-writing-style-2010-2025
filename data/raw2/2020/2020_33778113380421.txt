Ankou: Guiding Grey-box Fuzzing towards
Combinatorial Difference
Valentin J.M. Man√®s
CSRC, KAIST
Daejeon, Korea
valentinmanes@outlook.frSoomin Kim
KAIST
Daejeon, Korea
soomink@kaist.ac.krSang Kil Cha
KAIST
Daejeon, Korea
sangkilc@kaist.ac.kr
ABSTRACT
Grey-box fuzzing is an evolutionary process, which maintains and
evolvesapopulationoftestcaseswiththehelpofafitnessfunction.
Fitnessfunctionsusedbycurrentgrey-boxfuzzersarenotinforma-tiveinthattheycannotdistinguishdifferentprogramexecutionsas
longasthoseexecutionsachievethesamecoverage.Theproblem
is that current fitness functions only consider a union of data, but
not their combination. As such, fuzzers often get stuck in a localoptimumduringtheirsearch.Inthispaper,weintroduceAnkou,
the first grey-box fuzzer thatrecognizes different combinations of
executioninformation,andpresentseveralscalabilitychallenges
encountered while designing and implementing Ankou. Our exper-
imental results show that Ankou is 1 .94√óand 8.0√ómore effective
in finding bugs than AFL and Angora, respectively.
CCS CONCEPTS
‚Ä¢Software and its engineering ‚ÜíSoftware testing and de-
bugging;‚Ä¢Security and privacy ‚ÜíSoftware security engineer-
ing.
KEYWORDS
fuzz testing, guided fuzzing, grey-box fuzzing, software testing,
principal component analysis
ACM Reference Format:
Valentin J.M. Man√®s, Soomin Kim, and Sang Kil Cha. 2020. Ankou: Guiding
Grey-box Fuzzing towards Combinatorial Difference. In 42nd International
ConferenceonSoftwareEngineering(ICSE‚Äô20),May23‚Äì29,2020,Seoul,Re-
publicofKorea. ACM,NewYork,NY,USA,13pages.https://doi.org/10.1145/
3377811.3380421
1 INTRODUCTION
Fuzzing has recently gained popularity thanks to its proven record
and its ease of use [ 37]. It has identified thousands of real-world
vulnerabilities from a variety of software [ 6], and it has been de-
veloped by numerous security practitioners as well as academic
researchers.Furthermore,itdoesnotnecessitatemuchinformation
from the analyst beyond the entry point setup and optionally an
initial set of test cases, so-called seeds.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACMmustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ICSE ‚Äô20, May 23‚Äì29, 2020, Seoul, Republic of Korea
¬© 2020 Association for Computing Machinery.
ACM ISBN 978-1-4503-7121-6/20/05...$15.00
https://doi.org/10.1145/3377811.3380421Seeds provide initial starting points for fuzzing. A seed corre-
spondstoaprogramexecution,andfuzzerscanexploreprogram
paths mostly around this execution. Therefore, seeds need to be
dynamically added or removed from the initial seed pool during a
fuzzing campaign in order to efficiently explore the program state
space.Grey-boxfuzzers performsuchaprocessbyusinga fitness
function, which decides the quality of a given test case. As the seed
poolevolves,fuzzerstendtogeneratemoretestcasesthatmeetthe
fitness criteria enforced by the fitness function.
The current consensus is to leverage code coverage, such as
branchcoverage,astheirfitnessfunction.Forinstance,ifatestcase
coversanewbranchintheprogramundertest,thenweadditto
thepoolasitmeetsthefitnesscriterion.Theactualimplementation
variesforeachfuzzer,buttheysharethesameidea:theyprefertest
cases that achieve new code coverage.
Despiteitswideuse,thecurrentstrategyofusingcodecoverage
as a fitness function suffers from critical information loss. Sincecode coverage only considers a unionof information, if any one
ofthetestedexecutionsexercisesabranch,forinstance,thenthe
branch is regarded as visited. As such, fuzzers can easily disregard
testcasesthatdonotimprovecodecoverageeveniftheyallowour
fuzzerstoexercisevaluableexecutionpaths.However,bugsoften
manifest when we exercise a specific execution path, but not when
we visit a specific code snippet. For example, buffer overflow bugs
do not occur when we visit the buggy loop, but they show up only
when we exercise the loop more than a certain threshold.
Unfortunately, handing the aforementioned issue is challenging
for the following three reasons: ( C1) our fitness function should
beinformative in that it can quantify difference between program
executions,( C2)ourfitnessfunctionshouldbecomputationally fast
whilestillbeinginformative,and( C3)ourfitnessfunctionshould
not accept too many seeds in the seed pool to be able to handle
them in a practical manner.
First, our fitness function should be able to sensitively quantify
program executions. That is, given two program executions, weneed to be able to decide which one fits better for future fuzzing.
Supposewewanttousepathcoverageasafitnessfunction.That
is, if a test case exercises an unseen path, we consider it to meet
thefitnesscriterion.Inthiscase,thefitnessfunctionitselfcannot
judgetherelativeimportancebetweentestcasesbecausethefitnessfunctioncanonlymakeabinarydecision.Thesameproblemexists
for any coverage-based fitness function.
Second, computing informative fitness itself can be too costly.
Sinceprogramexecutionsnaturallyincorporatemillionsofinstruc-tionsalongwithcomplexsemantics,extractingtheircomprehensive
information from an execution is typically an expensive process.Furthermore, the time complexity of a fitness function is critical
10242020 IEEE/ACM 42nd International Conference on Software Engineering (ICSE)
for grey-box fuzzing as we will have to invoke the fitness function
for every test case generated during a fuzzing campaign.
Third, merely employing an informative fitness function can
quicklymake grey-boxfuzzingunproductiveas ourfuzzerwould
admit too many seeds in the seed pool. For instance, one may
produceaseedforeverysinglepathifweusepathcoverageasa
fitness function. In this case, it may not even be possible for the
fuzzer to give a trial for every seed in the pool.
Inthispaper,wetackle alltheabovechallengesbyintroducing
anovelfuzzingtechniquethatwerefertoas distance-basedfuzzing.
Itleveragesaninformativefitnessfunctionthatwecalldistance-
based fitness function to deal with ( C1). It also employs a novel
dimensionalityreductiontechniquethatwecalldynamicPCAto
handle(C2).Lastly,itmanagesitsseedpoolwithatechniquecalled
adaptive seed pool update for (C3).
Distance-based fuzzing employs an informative fitness function
that we refer to distance-based fitness function to handle ( C1). It
measures thebehavioral similarity betweentwo executionsby ex-
amining the combinations of exercised branches. The key intuition
is to expand our view from a set of program elements (such as
branches) to a set of combinations of program elements. By chang-
ing our perspective, we can easily identify the uniqueness of anexecution in contrast to other executions even if the executiondoes not achieve novel code coverage. Note our fitness function
onlyleveragesreadilyavailableinformationinmoststate-of-the-art
fuzzers, namely branch coverage (see ¬ß2.1).
Althoughtheideaofdistance-basedfitnessfunctionintegrates
well with grey-box fuzzing, it is still challenging to adopt it in
practiceascomputingthefitnessitselfiscomputationallyexpensive.
This is mainly because we need to deal with a higher number of
statesas ourfitness functiongets moreinformative. Accordingto
our study, fuzzing with our distance-based fitness function makesfuzzers 13 .2√óslower.
Totacklethischallenge( C2),wepresentdynamicPCA,which
is inspired by a well-known statistical approach called Principal
ComponentAnalysis(PCA)[ 27].PCAreducesthedimensionality
of a data set while guaranteeing to preserve the maximum amount
ofinformationfromtheoriginalset.However,PCAitselfiscom-
putationally too expensive to be used with fuzzing. We cannot run
PCAforeveryfuzzingiterationforthesamereasonthedistance-
based fitness cannot be directly used for fuzzing. To the best of our
knowledge, none of the existing PCA variations suits our needs.
Therefore,wepresentanovelandpracticaldimensionalityre-
duction technique that we call dynamic PCA. The core idea is to
make the PCA computation to be incremental so that we do not
need to recompute PCA from scratch. Our empirical study demon-
strates that dynamic PCA can efficiently reduce the computational
cost of the distance-based fitness function while introducing only
18% of information loss on average.
Finally, we introduce adaptive seed pool update to effectively
managethesizeoftheseedpool( C3).Thecruxofourapproachisto
dynamicallyadjustthesensitivityofourpoolupdatefunctionbased
ontherelativedifferencebetweenprogramexecutions.Sinceour
distance-basedfitnessfunctioncanquantifydifferencesbetween
program executions by its design, we can compare test cases basedon their fitness to actively decide the sensitivity of the pool update
function.Inourstudy,Ankouwithoutadaptiveseedpoolupdatewas not functioning due to the excessive memory requirement and
fitness computation cost.
Todemonstrateourideas,wedesignedandimplementedAnkou,
our prototype fuzzer, which leverages distance-based fitness func-
tion,dynamic PCA,as wellas adaptiveseed poolupdate totackle
allthethreechallenges.Weperformedathoroughevaluationfor
Ankouon24real-worldapplicationpackagesbyspendingatotal
of 2,682 CPU days. The results are promising, Ankou is 1 .94√óand
8.0√óbetter in finding unique crashes compared to AFL [ 58] and
Angora[14],respectively.Moreover, Ankoufoundalarge variety
of previously unknown software bugs in real-world software.
In summary, our contributions are as follows.
(1)We present an informative fitness function for grey-box
fuzzing that we call distance-based fitness function.
(2)We introduce dynamic PCA, which is a novel approach to
dynamicallyreducethedimensionalityofthedistance-based
fitness computation.
(3)We design and implement Ankou, the first fuzzer prototype
for distance-based fuzzing.
(4)We create our own benchmark, which consists of 24 real-
world application packages, and we make it public.
(5)We make our source code along with our benchmark pub-
liconGitHubtosupportopenscience:https://github.com/
SoftSec-KAIST/Ankou.
2 BACKGROUND
Thissectionpresentsfundamentalconceptsrequiredtounderstand
theproposedidea,anddefinesseveralnecessaryterminologiesthat
we use throughout the paper.
2.1 Fitness and Local Optimum Problem
Currentgrey-boxfuzzersprimarilyusecodecoverageastheirfit-
ness function: we add a test case to the seed pool if it achieves new
code coverage. However , coverage-guided fuzzing strategies can
missoutcriticaltestcasesthatmayguidefuzzerstowardsunseen
executionpathswhilenotnecessarilyimprovingthecodecoverage
per se. We say we have reached a local optimum [30] as we cannot
obtain any more test cases that fulfill our fitness criterion even
though we have not yet tested all possible executions of the PUT.
This is certainly the case for fuzzing because some bugs can
onlybetriggeredwhenaspecificexecutionpathisexercised.For
example, traditional buffer overflow bugs trigger when we exercise
a loop more than a certain threshold, but not when we simply
visited the loop; both the node and the branch coverage would
remain the same.
Tomitigatethisproblem,AFL[ 58]anditsdescendants[ 10,11,
14,32,33] employ a modified version of branch coverage, which
takes account of a hit count for each unique branch in the PUT.Note that the modified coverage can represent a greater numberof program states compared to branch coverage: two executionsmay hit branches for different number of times while achieving
thesamebranchcoverage.Wecallsuchinformationgatheredfrom
every program execution by AFL as branch-hit-count state1.
1NotethatAFLintroducesanotherapproximationintheiractualimplementation:it
bucketizes hit counts by powers of two to roughly measure how often each branch is
10250 2 4 6 8 100246
Branchhit count for branch 1Branchhit count for branch 2
Figure1:Ahypotheticalexampleshowingbranch-hit-count
statesof30uniqueprogramexecutions.Eachdotrepresentsa branch-hit-count state /vecx.
Definition 2.1 (Branch-Hit-Count State). Given a program pand
an inputt, the branch-hit-count state œµ
p(t)is a vector
œµp(t)=‚é°‚é¢‚é¢‚é¢‚é¢‚é¢‚é£x
1
...
xn‚é§‚é•‚é•‚é•‚é•‚é•‚é¶=/vecx
wherenis the number of branches in p, andxiis the number of
hits for branch iin the execution. For simplicity, we let the branch-
hit-count state with a vector notation /vecx.
We note, however, that the fitness functions using branch-hit-
count states still suffer from the local optimum problem. For exam-
ple,letusconsiderasimpleprogram pthathasonlythreebranches,
and assume that three test cases t1,t2, andt3respectively pro-
duce the branch-hit-count states œµp(t1)=(1,1,2),œµp(t2)=(1,1,0),
andœµp(t3)=(0,1,2). Suppose t1is firstly given, and t2andt3are
producedwhilefuzzingtheprogram.Inthiscase,currentfuzzers
includingAFLwillfavor t1asitcansolelycoverallthebranches,
and thus, t2andt3will be considered redundant, and will not be
included in the population. Indeed, this is the key observation that
motivates our research.
2.2 Principal Component Analysis
Principal Component Analysis (PCA) [ 27] is a way of reducing the
dimensionality of a dataset while preserving as much information
aspossible.TounderstandthebasicprocessofPCA,letusconsider
ahypotheticalexamplewherethereisaprogram pwithonlytwo
branches. Each execution of the program will produce a branch-
hit-count state /vecx=(x1,x2), which contains two hit-count numbers
for each branch. Suppose our fuzzer has produced 30 test cases,
which exercise30 unique programexecutions. Figure 1illustrates
thisexample.Eachdotrepresentsabranch-hit-countstateobtained
byanexecution,andtheX-andY-axisrepresentthehitcountfor
branch 1 and 2, respectively.
ThegoalofPCA,inthisexample,istoobtainan1-Dplotfrom
the2-Dplotinsuchawaythatallthepointsintheresultingplot
have the largest variance. For example, the dashed line in Figure 1
showssuchanaxis.Ifweprojectallthepointsontothenewaxis,
i.e.,thedashedline,thenweobtainthemaximumpossiblevariance
between dots in the resulting 1-D plot.
exercised. We intentionally omit such details for brevity, but we note that it does not
impact our analyses.In this paper, we let PCA be a function that takes in a space
representation asinput, andreturns anupdated spacerepresenta-
tionas output.A spacerepresentation isa tupleof abasis Banda
covariance matrix Œ£. That is, PCA is a function of type
PCA :(B,Œ£)‚Üí(B/prime,Œ£/prime).
The returned space representation has a reduced dimensionality
andeachaxis,i.e.,eachcolumnvectorof B/prime,islinearlyindependent
to the other ones.
InthecontextofPCA,thetupleofabasismatrixandacovari-
ancematrixeffectivelydescribesallthenecessaryinformation.A
covariance matrix is a symmetric matrix representing how each
datacomponentareaffectedbyeachother.Sincetheexampleplotis
ona2-DEuclideanspace,wecanrepresentitsbasisasa2standard
basis matrix.
B=/bracketleftbigg1001/bracketrightbigg
.
To represent the relationship between the two components of Fig-
ure1,weconsidera2 √ó2covariancematrix Œ£ofthespace.Each
element in the (i,j)position is the covariance between the i-th and
j-th components.
Œ£=/bracketleftbigg6.930 2.728
2.728 2.231/bracketrightbigg
.
The element in (1,1) represents the covariance between the first
componentanditself,whichmeansthevarianceofthefirstcompo-nent.Theelementsin(1,2)and(2,1)arethesameasthecovariance
between two components is the same regardless of their order.
In the perspective of linear algebra [ 52], PCA is equivalent to
an eigendecomposition process on the given covariance matrix,
whichreturnsadiagonalmatrix Œ£/primeandabasismatrix B/prime.Thebasis
B/primecontainseigenvectorsasitscolumnvectors,whichrepresents
the axes of a new coordinate system. Œ£/primehas the eigenvalues on its
diagonalentries,whicharethevariancesofthecorrespondingnewaxes.Specificallywhenappliedto
Œ£above,weobtainthefollowing
covariance matrix and basis matrix.
Œ£/prime=/bracketleftbigg8.180 0
00.981/bracketrightbigg
,andB/prime=/bracketleftbigg0.909 0.417
0.417‚àí0.909/bracketrightbigg
.
Inordertomaximizethevarianceofthelowerdimensionality
space, we chose the axes with the highest variances. In this case,
sinceit hasa varianceof 8.180,we select thevector [0.909,0.417],
whichcorrespondstothedashedlineofFigure1.Thisbecomesour
new axis of the desired 1-D plot.
3 DISTANCE-BASED FUZZING FITNESS
The key challenge that we address here ( C1) is designing an infor-
mative fitness function for grey-box fuzzing, which can sensitively
quantify the difference between test cases and their corresponding
executions on the PUT. Remarkably, we found that the branch-hit-
countstatesusedbycurrentfuzzersalreadyprovidejustenough
informationabouttestcases forjudgingtheir potential tobeused
asafutureseed.Theideaistoconsidereachbranch-hit-countstateas avector, as defined in ¬ß2.1, which enables us to compute relative
distances between them.
Since we are dealing with relative distances, two distinct ex-
ecutions that achieve the same coverage, but produce different
branch-hit-count states would represent two unique vectors in the
1026space,andwecan naturallyquantifytheirdifferencecomparedto
the other vectors in the space. Indeed this is the key intuition of
our distance-based fitness function.
3.1 Fitness as Distance between Vectors
Inourmodel,abranch-hit-countstatecorrespondstoavectorin
a space that we call the branch-hit-count state space Œ©p, which is
formally defined as follows. For any test case t, we can obtain a
branch-hit-count state œµp(t)inŒ©pby executing pwitht.
Definition3.1(Branch-Hit-CountStateSpace). Givenaprogram p,
thebranch-hit-count state space ofp,Œ©p, is the set of all possible
branch-hit-count states we can obtain by executing p.
Withthis,wenowintroducetheconceptof executiondistance,
whichmeasurestherelativedistancebetweentwobranch-hit-count
states,therebydeterminingthedifferencebetweentheirtwoexecu-
tions. Note that the distance between two vectors is dependent on
whichspacewearein.Thus,ourdefinitionofexecutiondistance
takes a basis Binto account.
Definition 3.2 (Execution Distance). Given a program pand a
basisB,anypairofbranch-hit-countstatesin Œ©phaveanexecution
distanceŒ¥Bonthespacedefinedby B,whichissimplydefinedas
the Euclidean distance
‚àÄ(/vecx,/vecy)‚ààŒ©2
p,Œ¥B(/vecx,/vecy)=/bardbl/vecxTB‚àí/vecyTB/bardbl.
Intuitively, two executions are similar to each other when their
executiondistanceissmall,andviceversa.Forexample,suppose
there is a program with only three branches, and there are three
executions of the program, which result in the branch-hit-count
states/vecx=(3,0,1),/vecy=(3,0,0),and/vecz=(0,1,1),respectively.Inthis
case,wecanreadilydeterminethat /vecxand/vecyaresimilartoeachother
asthefirstbranchisexercisedthreetimesinbothcases,unlike /vecz.Al-
thoughbranchhitcountsdonotcompletelyreflectthesemanticsofthe program executions, we can still extract meaningful distinction
between executions.
Since a test case produces an execution for a given PUT, we can
comparetwotestcasesforthePUTbyleveragingtheirexecution
distances. That is, the execution distance allows us to computethe difference between given test cases with respect to the PUT.
Therefore, we devise a new fitness function to quantify the novelty
of a given test case compared to the current population, i.e., test
cases in the seed pool. Let Œ†={t1,t2,¬∑¬∑¬∑,tm}beaseedpoolof m
testcases, the distance-basedfitness ofa newlygenerated tisthen
theminimumexecutiondistancebetween tandalltheseedsin Œ†.
As execution distance can vary depending on the current space we
arein,thedefinitionofdistance-basedfitnessfunctionalsotakes
the current space (B) into account.
Definition 3.3 (Distance-based Fitness Function). Given a pro-
grampandabasis B,thedistance-basedfitness ŒîB(t,Œ†)ofatest
casetwithregard toaseedpool Œ†istheminimum executiondis-
tance between œµp(t)and a set {‚àÄi‚ààŒ†:œµp(i)}on the space defined
byB. Formally, the distance-based fitness function is
ŒîB(t,Œ†)=min
i‚ààŒ†Œ¥B(œµp(t),œµp(i)).
Withthedistance-basedfitnessfunction,wecannowquantify
the difference between a test case and a pool of test cases. Forexample, let us consider the test cases with the following states:
œµp(t1)=(1,1,2),œµp(t2)=(0,1,1),œµp(t3)=(1,0,2), andœµp(t4)=
(0,3,3). Assume the current seed pool contains the first two seeds
{t1,t2}, and our fuzzer has generated the test case t3andt4.W e
can now compare the two test cases, decide which is the fittest
and include it in the pool. Using the standard basis as B, we obtain
ŒîB(t3,{t1,t2})=1, and ŒîB(t4,{t1,t2}) ‚âà2.45. Since t4execution
is further away from the seed pool, its inclusion in the pool brings
more novelty than t3would. Hence, t4is a better fit. Although
neither test cases bring new coverage, this is representative of howthecombinationoftheirbranch-hit-countdiffers.
t3executiononly
differs from t1on the second branch, while t4differs from t1on all
the branches.
3.2 Impracticality of Distance-based Fitness
Ourdistance-basedfitnessfunctionisindeedinformative‚Äîitpro-
vides a way to effectively quantify the fitness of generated test
cases‚Äîbut such benefit comes with a price. Although it does notrequire any new coverage metric to be introduced, it is not fea-sible to apply the idea directly to current fuzzers due to its high
computational cost.
Since we have to compute the fitness for every generated test
case, the performance of fitness computation is critical. Unfortu-
nately,itstimecomplexityisroughly O(mn),wheremisthenumber
ofseedsinourseedpool,and nisthenumberofbranchesinthe
PUT.Notethattherecanbeeasilythousandsofseedsinthepopula-tionaswellasthousandsofbranchesinthePUT.Thisisindeedthechallenge(
C2)thatweaddressinthepaper.Tomakeourapproach
practical, we need to reduce one of the terms.
Oneplausiblewaytoimprovetheperformanceistoemploya
specialized data structure designed for efficient distance queries,such as M-tree [
16]. It allows us to reduce the number of seeds
tolookforwithoutanylossofinformation.However,itdoesnot
guaranteeanypracticallowerbound.Inapreliminarystudyweper-
formed, we only observed about 70% of performance improvement
withM-tree,whichwasfarfromenoughtomakethedistance-based
fitness function practical for fuzzing.
Therefore, we address this impracticality challenge by reducing
thedimensionalityofthebranch-hit-countstates,whicheffectively
reducesn, the number of branches to consider. Recall that PCA
(asintroducedin¬ß2.2)isawell-knownmethodologyforreducing
the dimensionality of a dataset while minimizing the loss of in-formation. The goal here is to reduce the dimensionality of thebranch-hit-count state space, which can drastically improve the
performanceofourfitnessfunctioncomputation.Nevertheless,thisnewintermediarystepintroducesitsownchallengesaswedescribe
in the following section.
4 DYNAMIC PCA
The high computational demand of distance-based fitness function
naturally leads us to the second challenge ( C2). To tackle the chal-
lenge, we introduce dynamic PCA, a noveltechnique for reducing
the dimensionality of the branch-hit-count states.
As the name implies, dynamic PCA is inspired by PCA, but PCA
itselfdoesnotperfectlymeetourneedsforseveralreasons.First,
1027PCAitselfiscomputationallyexpensive:ithasacubic-timecom-
plexity in the number of samples and dimensions [ 21]. Second, the
underlying probability distribution we are sampling from changes
everytimeastheseedpoolvaries:grey-boxfuzzingcreatesady-
namicenvironment.ThismeanswewouldneedtocomputePCA
every time we add a new seed to our pool, but its cost would be-
comeextremelyhigh.Aswewillexplainin¬ß8,severalvariationsof
PCA havebeen introduced,none ofthem suitsour case.Dynamic
PCA overcomes these challenges by presenting an efficient approx-
imation ofPCA, which eventually enablesthe practical use ofthe
distance-based fitness for grey-box fuzzing.
4.1 Algorithm Overview
Atahighlevel, dynamicPCA achievesitsperformanceimprovement
by(1)reducingthenumberoftimeseigendecompositionisrun,and
(2)limitingthenumberofaxesinthespacetoperformeigendecom-
positionon.DynamicPCAperiodicallyrunseigendecomposition,
i.e., the standard PCA, for every time interval we choose, which is
oneminute inthe currentimplementation. Itmaintains areduced
covariance matrix and incrementally updates the matrix. When we
performeigendecomposition,werunitonlyonthereducedmatrix.
TheDynPCAfunctioninAlgorithm1describesthemainalgo-
rithm, which roughly takes in a space representation ( B,Œ£), and
returnsanupdatedone.Theinitialspacerepresentationisobtained
by runningthe standard PCAfor the seedsin the initialseed pool
given by the user. Unlike the standard PCA we described in ¬ß2.2,
though, it also takes in three more parameters as input: (1) /vecxis the
branch-hit-count state obtained by executing the currently gener-
atedtestcase,whichisrequiredtoupdatethespaceinformation;(2)
sisthenumberofgeneratedtestcases;and(3) Œ∏expisavariableau-
tomatically set by our algorithm, whose initial value is the infinity
‚àû. Dynamic PCA operates with three major functions: ExpandBa-
sisIfInteresting, UpdateCovMatrix, and PeriodicDecompose.
ExpandBasisIfInteresting checks whether the branch-
hit-countstate /vecxsuffersalarge informationlosswhenpro-
jected on B. If it does, then we consider /vecxas an ‚Äúinteresting‚Äù
vector, and add it to our basis Bas an extra axis (see ¬ß4.2).
UpdateCovMatrix updates the current covariance matrix
Œ£withregardtothegivenbranch-hit-countstate /vecx(see¬ß4.3).
Note that Œ£effectively summarizes the branch-hit-count
states of all the test cases the fuzzer observed so far.
PeriodicDecompose periodicallyreadjuststhebasis Bev-
ery minute by running the standard PCA. The current time
intervalisempiricallychosen,butitisauserconfigurableparameter in our implementation. Note that this function
needs to handle only a reduced space returned by the previ-
ous steps. That is, the number of axes in Bis several orders
ofmagnitudesmallerthanthetotalnumberofbranchesin
the PUT. This is indeed the key to our approach.
Information Lossdue to Dynamic PCA. Although dynamic PCA
makes itefficient to computethe principalcomponents of agiven
space representation, it loses the guarantee of maximizing the vari-
ance of the reduced space. Nonetheless, our empirical result shows
that the information loss caused by dynamic PCA is 20% or less in
most subjects we tested (see ¬ß6.3). Therefore, dynamic PCA can be
a practical alternative to standard PCA.Algorithm 1: Dynamic PCA
//Œ∏expis globally given, and initially set to ‚àû.
1function ExpandBasisIfInteresting(B, Œ£,/vecx)
2 loss‚Üê/radicalBig
/bardbl/vecx/bardbl2‚àí/bardbl/vecxTB/bardbl2// By Pythagoras
3 ifloss >Œ∏expthen
4 B,Œ£‚ÜêAppend(B, Œ£,/vecx)
5 B‚ÜêGramSchmidt(B)
6Œ∏exp‚ÜêUpdateLoss( Œ∏exp,loss)
7 returnB,Œ£
8function PeriodicDecompose(B, Œ£)
9 ifIsOneMinutePassed() then
10 B,Œ£‚ÜêPCA(B,Œ£)
11 returnB,Œ£
// The main function
12function DynPCA(B, Œ£,/vecx,s)
13B,Œ£‚ÜêExpandBasisIfInteresting(B, Œ£,/vecx)
14Œ£‚ÜêUpdateCovMatrix(B, Œ£,/vecx,s)
15B/prime,Œ£/prime‚ÜêPeriodicDecompose(B, Œ£)
16 returnB/prime,Œ£/prime
4.2 Incremental Basis Expansion
In ExpandBasisIfInteresting, the information loss caused byprojecting the execution on
Bis quantified by lossin Line 2. In
Line 3, theloss is consideredsignificant if above thethreshold Œ∏exp.
Then,inLine4,thenewbranch-hit-countstate,whichisavector
by definition, is appended to the basis and the covariance matrix Œ£
isexpanded byonerow andonecolumn.The newbasis Bisthen
orthonormalized by Gram-Schmidt [53] in Line 5.
To get a better understanding, let us consider the previous ex-
ampleillustratedinFigure1.Thereareonlytwobranchesinthe
programandwehave30initialseeds,oneforeachpointintheplot.
The initial BandŒ£are set using the standard PCA on the initial
seeds.Notethat thisisanexpensiveoperationasthebranch-hit-
countstateislikelytohavemanydimensions.Wecanonlyaffordit
once at the initialization. Now, let us assume that the first test case
wegeneratemanifeststhebranch-hit-countstate /vecx=(1,100).W e
pass the state to DynPCA, and we reach the ExpandBasisIfInter-
estingfunction.Thebranch-hit-countstateisindeedalargeoutlier,
whichwillpassthetestinLine3of ExpandBasisIfInteresting.
Therefore, this vector will be appended to B, and then orthonor-
malized into/bracketleftbig‚àí0.417,0.909/bracketrightbig
by the Gram-Schmidt [ 53] procedure.
Thefollowingtestcasesandtheirbranch-hit-countstateswillbe
projected onto the new 2-D basis until the call to the PCA function
in PeriodicDecompose will reconsolidate Binto a single vector.
Additionally,ExpandBasisIfInterestingupdatestheexpansion
threshold Œ∏expinLine6.UpdateLossrecordsallthe lossvaluesin
the past minute and sets Œ∏expto the maximum of the held data. In
our experiments, this was enough to make dynamic PCA maintain
a sufficient number of new axes while keeping the computational
costlow.OptimizingUpdateLossisbeyondthescopeofthispaper.
4.3 Dynamically Updating Covariance Matrix
As we generate test cases, we should also incrementally update
our covariance matrix to take account of newly sampled test cases
1028added to our space. However, there is an issue to be addressed for
updatingourcovariancematrix.PCAassumesthatoursampling
processisperformedonaconstantprobabilitydistribution,butthis
isnotthecaseforgrey-boxfuzzerswhereachangeintheseedpool
implies a change in the sampling process.
Toaddressthisproblem,weimplementUpdateCovMatrixto
include a discount factor Œ±in order to favor newer test cases rather
thanolderones.Particularly,everytimeweupdate Œ£,wegivehigher
weights to newer test cases by progressively decreasing weights
to the previous covariance matrix. Formally, given the (s+1)-th
generated test case, which produces /vecx, the UpdateCovMatrix
operates by updating Œ£/primeas follows.
Œ£/prime=(/vecxTB)¬∑(/vecxTB)T+Œ±wsŒ£
1+Œ±ws,wherews=1+Œ±+Œ±2+¬∑¬∑¬∑+Œ±s‚àí1.
IfŒ±issetto0,thenwecompletelyignorethehistory,andweendup
solely using the latest test case to construct Œ£/prime. On the other hand,
whenŒ±=1, the term Œ±wsbecomes s, and the resulting formula
simplyrepresentsanincrementalmeanwhere sisthetotalnumber
ofelements.When Œ±isbetweenzeroandone,weeffectivelygive
a weight of Œ±wsto the old covariance matrix Œ£in order to give
the decreasing influence to it as time passes. The lower Œ±is, the
more we forget about the past. Note that the old covariance matrix
represents stotaltestcasesgeneratedsofarwherethefirsttestcase
hasaweight Œ±(s‚àí1).Weempiricallyset Œ±to1‚àí10‚àí6inourcurrent
implementation.Althoughnotexplicitlymentionedforbrevity,the
branch-hit-count state /vecxis centered before being projected on B.
5 DISTANCE-BASED FUZZING
Inthissection,wefirstshowawaytodynamicallyadjustthesensi-tivityofourfitnessfunctiontohandle(
C3).Theprimaryissuehere
isthataninformativefitnessfunctionsuchasourdistance-based
fitness function would accept too many seeds in the pool. To set
thesensitivityofthefitnessfunction,weintroduceadaptiveseed
pool update, a novel population update mechanism that dynami-
cally changes its fitness criterion. With this, we present the design
andimplementationofAnkou,ourfuzzerprototypethatenables
distance-basedfuzzingbyaddressingallthreechallenges( C1,C2,
andC3). Ankou leverages the distance-based fitnessfunction (see
¬ß3) to obtain informative feedback, and employs the dynamic PCA
(see¬ß4)toefficientlycomputethedistance-basedfitnessfunction.
Italsousesadaptiveseedpoolupdatetodynamicallychangesits
fitness criterion.
5.1 Adaptive Seed Pool Update
The distance-based fitnessof atest casecharacterizes itsnovelty
compared to the current population, but having a way to measure
novelty (or fitness) does not tell us when should we add our testcase to the seed pool. Of course, we can add our test case to the
pool when its distance-based fitness is above a threshold, but what
should be the value of the threshold then? Note that the choiceof this threshold is critical as it sets the sensitivity of a fuzzer tonewbehaviorsofthePUT.Ifitisinfinitelyhigh,theseedpoolis
constant and the population does not evolve. On the other hand, if
the threshold is set to zero, any test case will be added to the pool,
which can quickly pack the seed pool.Algorithm 2: Adaptive seed pool update.
// The space information (B, Œ£) is globally given.
//Œ∏fitis globally given, and initially set to zero.
1function PoolUpdate(t, s,Œ†)
2B,Œ£‚ÜêDynPCA (B, Œ£,œµp(t),s)
3 ifŒîB(t,Œ†)>Œ∏fitthen
4 Œ†/prime‚ÜêAddToPool(t, Œ†)
5 Œ∏fit‚Üêmini‚ààŒ†/primeŒîB(i,Œ†/prime\{i})
6 return Œ†/prime
7 else return Œ†
Thus,wepropose adaptiveseedpoolupdate,anoveltechnique
that dynamically selects the threshold to adaptively control the
sensitivity of our fuzzer. The PoolUpdate function in Algorithm 2
describes the overall algorithm, which takes in a newly generated
testcaset,thetotalnumberoftestcasesgeneratedsofar s,andthe
seedpool Œ†asinput.Itthenoutputsanupdatedseedpool Œ†/prime.In
Line2,weperformdynamicPCAinordertomakeourfitnessfunc-
tion computation ŒîBefficient. We then check if the distance-based
fitness is bigger than the fitness threshold Œ∏fit, which is initially
givenaszero.Ifso,weupdateboththeseedpoolandthethreshold
inLine4and5.TheAddToPoolfunctioninLine4firstpopsout
theseedwiththelowestdistancetothepopulation,andthenadd
our test case tto the pool. That is, we remove the least fit test case
from the pool while adding a new one. To maintain a sufficientamount of seeds, AddToPool will only remove a test case when
the pool has 1,000 or more seeds in our current implementation.
InLine5,wecomputethedistance-basedfitnessforalltheseeds
inthepool,andsetthecurrentminimumfitnessasanewthreshold.
The intuition here is that in order for a test case to be useful, it
shouldbeatleastfurtherawayfromthepoolthanthesmallestgap
between the seeds. More formally, we set the next threshold Œ∏fitby
Œ∏fit=min
i‚ààŒ†ŒîB(i,Œ†\{i})=min
(i1,i2)‚ààŒ†2,i1/nequali2Œ¥B(œµp(i1),œµp(i2)).
PracticalImpactofAdaptiveSeedPoolUpdate. Tounderstandthe
impactofadaptiveseedpoolupdate,weperformedapreliminary
studywhereweranAnkouwithoutadaptiveseedpoolupdateona
subject in our benchmark. As a result, Ankou was killed by the OS
duetoitsexcessivememoryuseafterafewminutes.Duringitsrun,
Ankouwasmostlyspendingitstimecomputing ŒîBinLine3.Since
therearetoomany seedsinthepool,itscomputationalcost, even
with dimensionality reduction, became too extreme to be able to
run inpractice. Thus,we concludethat adaptiveseed poolupdateis an essential piece of distance-based fuzzing.
5.2 Ankou Architecture
Ankou follows the general architecture of grey-box fuzzing, which
consists of three major components: seed scheduler, pool manager,
and tester. Figure 2 illustrates the overall design of Ankou. The
seed scheduler selects a seed for fuzzing and passes it to the tester
module. The tester then generates inputs by mutating the given
seedandrun thePUT.UponthePUTexecution,thetesterpasses
the execution trace to the fitness function of the pool manager,
which computes its fitness value. The PoolUpdate function in the
1029	
 

 




	
	

	





Figure 2: Ankou architecture.
pool manager module then updates this value with the adaptive
seed pool update technique.
Note that the only difference between existing grey-box fuzzers
andAnkouisinthedesignofthepoolmanagermodule.Particularly,
Ankou uses the adaptive seed pool update for pool update, and the
distance-based fitness function enabled by the dynamic PCA. Any
grey-box fuzzers can easily benefit from distance-based fuzzing.
5.3 Implementation
AnkouisbuiltuponourownAFLimplementationinGo[ 3].Itis
asimplifiedversionofAFL,whichimplementsmostoftheAFL‚Äôs
features, but not all. For instance, our implementation does not
include culling since Ankou performs it on-the-fly in Line 4 of
Algorithm 2. Ankou does not implement the seed prioritization
heuristicsemployedbyAFL,whereseedshavingfastthroughput
and high coverage are likely to get a higher priority. Since our goal
in this paper is on designing a new fitness function for grey-box
fuzzing, we intentionally omitted such heuristics in our implemen-
tation to effectively measure the impact of our fitness function.Instead, Ankou chooses seeds from the seed pool at random and
generates test cases for a constant time interval, which is currently
one second in the current implementation.
Our current implementation of Ankou consists of 8K lines of
Go (as measured by CLOC [ 18]). We used the Gonum numeric
library [4] in order to implement the PCA function. Ankou em-
ploys the same instrumentation module provided by the vanilla
AFL [58]. Therefore, Ankou can easily support ASan [ 49] and AFL-
lafintel[29].Wemakeourprototypeimplementationaswellasour
benchmark publicly available on GitHub [38].
6 EVALUATION
We evaluated Ankou on the following research questions.
(1)Howmuchwasthe speedgainenabledb ydynamicPCAand
what was its impact on bug discovery?
(2)CandynamicPCAeffectivelyreducespacedimensionality
without significant information loss?
(3)How does the distance-based fitness function compare to
coverage-based fitness function?
(4)Howmuchisthecomputationalcostofdistance-basedfuzzing?
(5) How does Ankou compare to other grey-box fuzzers?6.1 Experimental Setup
BasicSetup. Weperformedourexperimentsontwoserverma-
chines, each of which is equipped with 44 Intel Xeon E5-2699 v4
coresand512GBofRAM.Foreveryfuzzingcampaign,weuseda
Dockercontainerassignedtoasinglecore.Unlessstatedotherwise,
all the reported numbers are the average of six repeated fuzzing
campaigns,eachofwhichwasperformedfor24hours.Weusedthe
Mann-WhitneyU-Test[ 7]withŒ±=0.05todeterminethesignifi-
cance ofeach experiment.When we reportthe numberof unique
crashes,wefollowAFL‚Äôsdefinition:iftwocrashesachievethesame
branch coverage, we count them as one.
Measuring Throughput. In RQ1, RQ3, and RQ4, the test case gen-
eration throughput‚Äîthe number of test cases the fuzzer produced
persecond‚Äîisusedasaproxytomeasurethecostoftheanalysis
eachfuzzerperforms.Whenafuzzerperformsatimeconsuming
operation (in the case of Ankou, the dynamic PCA), it is at the
expense of the test case that could have been generated and run in
the same amount of time. Thus, the lower the throughput is, the
higher the cost of the analysis the fuzzer is performing.
Fuzzers to Compare. Since Ankou is a source-based fuzzer it can-
notbefairlycomparedtobinary-basedfuzzerssuchasEclipser[ 15]
or RedQueen[ 9]. Recentsource-based fuzzerssuch as Steelix[ 33]
and CollAFL [ 22] were not made available for comparison. Lib-
Fuzzer[5]requiresacustomlibrarycallertobemadetorunexperi-
ments.Hence,wecompareAnkouagainstAFL2.52b[ 58],thelatest
version at the time of writing, and Angora [ 14]. When we run AFL,
we used the ‚Äú -d‚Äù option, which essentially enables AFLFast [ 2,11].
OurBenchmark. Tocreateourbenchmark,wecollectedallthe
programs, but with the latest versions, used by CollAFL [ 22]. This
benchmarkincludesatotalof24differentprogrampackages,con-
stitutingmorethan5MLoC(seeTable1).Whenaprogrampackagecontainsmorethanoneexecutable,weconsiderallofthemasasep-
aratesubject.Forexample, libtasn1 isalibrary,whichhasthree
distinct wrapper program executables in its source distribution. In
this case, we regard each executable as a distinct subject2.A sar e -
sult,weobtained150differentsubjectsfromthe24packages.Since
the authors of CollAFL have not opened their benchmark to the
public,weobtainedinitialseedsbygatheringtestcasesprovided
byeachpackage,andwedidnotperformanyadditionalprocessing.
We make our benchmark public along with the source code.
HoursofExperiments. WeranAnkouandAFLoneachsubject
of our benchmark suite for 24 hours, and repeated this experiment
for6times.WedidthesameforAngora,butonlyonthesubjectsit
wassuccessfully compiledfor(see ¬ß6.6).To answerRQ1and RQ3,
weselected24subjectsfromthebenchmarkbyrandomlychoosing
one executable per package. We then ran 24-hour fuzzing for each
of the 24 subjects of the selected subset 6 times. In total, all our
experiments constitute 2,682 CPU days.
6.2 RQ1: Impact of Dimensionality Reduction
DoesdynamicPCA reallyhelpimprovetheefficiency ofdistance-
basedfitnessfunction?To answerthisquestion,werunAnkouin
two modes: (mode 1) Ankou with the distance computed using the
2The term subject is widely used in practice by LibFuzzer [5].
10301101001000
13927
SubjectsCrash ratio
(in log)Throughput ratio
(in log)
# Crashes
Throughput
Figure 3: Comparison between distance-based fitness func-
tionwithandwithoutdynamicPCAintermsofthenumberof crashes found and test case generation throughput.
dynamicPCA,and(mode2)Ankouwithdistance-basedfitnessfunc-
tion but without dynamic PCA. Meaning, the distance is computed
using Definition 3.2, without any dimensionality reduction.
Figure 3 illustrates our experimental results after 24 hours of
fuzzing on each of the 24 selected subjects. The line with circles
shows the ratio between the number of crashes found with mode 1
and 2. The line with squares shows the ratio between the test
generation throughput of Ankou with mode 1 and 2. The first five
crash points (circles) have the ratio of one as we found no crash in
bothcases.Thelastsixpoints,witharatioof1,000,arethecases
where Ankou in mode 1 found crashes while mode 2 did not. In
allcases,thecrashratiowashigherthanone,meaningthatusing
dynamic PCA always produces better results than using Defintion
3.2. Ankou found 11.8 √ómore unique crashes and generated 13 .2√ó
more test cases with dynamic PCA than without it.
The‚Äú1<3Uvalue‚Äùandthe‚Äú 2<4Uvalue‚ÄùcolumnsofTable1
describe the result of the Mann-Whitney U Test on the experiment.
A value written in bold and with a grey background means the
experiment was successful. If the value is close to 1.0, it means the
hypothesisisvalidated,e.g.‚Äú 1<3‚Äù.Ontheotherhand,ifthevalue
isclose0.0,itmeanstheoppositeisvalidated,e.g.‚Äú 1>3‚Äù.Forthose
subjects that show statistical significance, dynamic PCA gave con-
siderablybetterresultsintermsofbothbugfindingandthroughput.
These results confirm the necessity of our dynamic PCA to enable
the practical usage of the distance-based fitness function.
6.3 RQ2: Effectiveness of Dynamic PCA
Although dynamic PCA allows us to efficiently generate test cases,
itcomesataprice.SincedynamicPCAisanapproximationprocess,
it may suffer from a loss of information. If so, how much would be
the loss? In other words, do the identified basis from dynamic PCA
successfully maximize the variances of branch-hit-count states?
To answer the question, we measured the effectiveness of dy-
namicPCAonallthefuzzingcampaignsagainstthe150subjects
in our benchmark. The effectiveness is quantified by the variances,
i.e., eigenvalues, appeared in the resulting covariance matrix Œ£/prime.
Bycomputingtheportionofthevariancesoftheselectedaxesin
Œ£/prime,wecanquantifyhowmuchinformationislostbyrunningthe
dynamicPCA(orstandardPCA)process.Forinstance,ifwelook
back at the example in ¬ß2.2, the effectiveness of PCA was about
89% (=8.18/(8.18+0.981)). The closer this number is to 100%, the
less loss of information in the PCA computation will be.
Figure 4 is the histogram showing the effectiveness of dynamic
PCAforallthe150subjects.For80%ofthesubjects,theeffectiveness0510152025
50 60 70 80 90 Effectivess of Dynamic PCA (%)Frequency
Figure 4: The effectiveness of dynamic PCA represented by
the percentage of preserved information on 150 subjects.
The green dashed line represents the median effectiveness.
0.251.004.00
0.251.004.00
SubjectsCrash ratio
(in log)Throughput ratio
(in log)# Crashes
Throughput
Figure 5: Comparison between distance-based fitness and
coverage-based fitness function in terms of the number ofcrashes found and test case generation throughput.
was above 78.8%, and for 90% of the subjects, the effectiveness was
above72.7%.Inotherwords,dynamicPCAwasabletokeep80%of the information obtained from program executions in most of
thesubjects.Thisresultindeedhighlightsthekeycontributionof
our paper: dynamic PCA can effectively reduce the dimensionality
of program state space without losing much information, which
enables the practicality of distance-based fuzzing.
6.4 RQ3: Distance- vs. Coverage-based Fitness
Recall from ¬ß3, one of the key motivations of distance-based fit-ness function was that coverage-based fitness functions do not
providesufficientinformationtofuzzersforfindingbugs.Tocon-
firm the value of distance-based fitness function, we ran Ankou
with and without distance-based fitness function. When disabling
thedistance-basedfitnessfunctionforAnkou,weonlyusedbranch
coverage as its fitness criterion.
Figure 5 shows our results after 24 hours of fuzzing on the
same 24 subjects as in RQ1. Overall, distance-based fitness func-
tionfound1.5 √ómoreuniquecrashes,andproducedmorecrashes
in60%ofthesubjects,excludingthe5subjectswherenocrashes
werefound.Atbest,thedistance-basedfitnessfunctionfound4 √ó
more unique crashes than without it. As the right-most columnsof Table 1 describe, for those subjects that manifest statistic sig-nificance, distance-based fitness function gave better results for
83%ofthecases(5outof6).However,fortheothersubjectsthat
were not found to be statistically significant, the distance-based fit-
nessfunctionwasusuallystillanimprovementoverthetraditional
coverage-based fitnessfunction in termsof thenumber of crashes
found. Otherwise, the difference was negligible. Since the expectedlossisslimwhilethepotentialgainislarge,weshouldbenefitfrom
choosing the distance-based fitness function a priori.
1031Table 1: Detailed experimental results for RQ1 and RQ3. We show the Mann-Whitney U test results along with the detailed
numbers for every experiment we performed. The shared areas indicate statistically significant results.
No PCA vs. Dynamic PCA (RQ1, ¬ß6.2) Coverage vs. Distance-based Fitness (RQ3, ¬ß6.4)
Package Name Version KLoC1Ankou
Crashes2Ankou
Throughput3No PCA
Crashes1<3
U Value4No PCA
Throughput2<4
U Value5Cov-based
Crashes1<5
U Value6Cov-based
Throughput2<6
U Value
binutils 2.32 1687 0.167 102 0 (-Inf) 0.42 23.9 (√∑4.27) 0.00 0.167 0.50 508 (+397%) 1.00
bison 3.3 82.4 497 20 13 (√∑38.22) 0.00 1.01 (√∑19.86) 0.00 232 (-53%) 0.00 20.8 (+3%) 0.33
catdoc 0.95 3.8 28.7 56.7 8.67 (√∑3.31) 0.00 2.48 (√∑22.90) 0.00 23.5 (-18%) 0.47 36.9 (-34%) 0.11
cflow 1.6 37.8 470 78.9 83.3 (√∑5.64) 0.00 4.72 (√∑16.70) 0.00 262 (-44%) 0.00 160 (+102%) 0.69
clamav 0.101.2 840 211 89.3 37 (√∑5.70) 0.00 2.55 (√∑35.07) 0.00 91 (-56%) 0.00 76.6 (-14%) 0.25
GraphicMagick 1.3.31 252 13.7 66.6 0 (-Inf) 0.08 4.44 (√∑14.99) 0.00 3.8 (-72%) 0.35 94.1 (+41%) 1.00
jasper 2.0.14 30.8 324 294 36.7 (√∑8.84) 0.00 11.5 (√∑25.64) 0.00 142 (-56%) 0.00 189 (-35%) 0.25
libav 12.3 586 23.7 14.8 5.67 (√∑4.18) 0.000.872 (√∑16.94) 0.00 35.4 (+49%) 0.80 12.7 (-14%) 0.40
dwarf b4f198 93.8 15.2 119 9.67 (√∑1.57) 0.00 4(√∑29.69) 0.00 17.5 (+15%) 0.92 102 (-14%) 0.44
libexiv2 0.27.1 72.9 57.3 49.1 36 ( √∑1.59) 0.50 4.02 (√∑12.22) 0.00 84.4 (+47%) 0.67 62.6 (+27%) 0.90
libgxps 0.3.1 8.8 2.33 48.6 2.33 0.50 19.4 (√∑2.51) 0.00 3 (+28%) 0.83 31.1 (-36%) 0.00
liblouis 3.9.0 36.2 488 30.9 1(√∑487.67) 0.00 5.57 (√∑5.54) 0.00 124 (-74%) 0.00 147 (+375%) 1.00
libming 0.4.8 81.2 337 56.2 1.33 ( √∑252.88) 0.38 9.63 (√∑5.83) 0.00 445 (+31%) 0.58 390 (+594%) 1.00
mpg123 1.25.10 41.1 0 18 0 0.50 0.894 (√∑20.14) 0.00 0 0.50 42.7 (+137%) 1.00
libncurses 6.1 112 209 33 34 ( √∑6.14) 0.38 2.5 (√∑13.16) 0.00 359 (+71%) 0.56 99.2 (+200%) 1.00
libraw 0.19.2 51.3 17.2 58.8 0 (-Inf) 0.33 9.25 (√∑6.36) 0.00 22 (+28%) 0.50 183 (+210%) 1.00
libsass 3.5.2 24.7 5 95.5 0 (-Inf) 0.33 3.63 (√∑26.30) 0.00 3 (-40%) 0.75 168 (+75%) 1.00
libtasn1 4.13 30.3 0 78.4 0 0.50 3.37 (√∑23.25) 0.00 0 0.50 204 (+159%) 1.00
libtiff 4.0.10 67.6 0.167 117 0 (-Inf) 0.42 10.4 (√∑11.22) 0.00 0.167 0.50 259 (+121%) 1.00
libtorrent 1.2.1 119 0 96.7 0 0.50 3.58 (√∑27.04) 0.00 0 0.50 134 (+38%) 0.89
nasm 2.14.03rc2 94.0 46.3 30.4 0 (-Inf) 0.00 3(√∑10.14) 0.00 45.8 (-1%) 0.61 185 (+507%) 1.00
pspp 1.2.0 257 312 19 0.5 ( √∑623.33) 0.29 1.18 (√∑16.17) 0.00 196 (-37%) 0.50 46.5 (+144%) 1.00
tcpdump 4.9.2 77.3 0 66.3 0 0.50 6.27 (√∑10.57) 0.00 0 0.50 189 (+184%) 1.00
vim 8.1.1332 347 123 10.20.667 (√∑185.00) 0.00 1.51 (√∑6.74) 0.00 62.7 (-49%) 0.33 13 (+27%) 0.53
Total 5037 3180 1649 269 ( √∑11.82) 139.7 (√∑11.80) 2152 (-32%) 3352 (+103%)
0.11.010.0
SubjectsThroughput ratio
(in log)
Figure6:Comparisonoftestcasegenerationthroughputbe-
tween Ankou and AFL.
On the other hand, Ankou using distance-based fitness function
had a test case generation throughput 51% lower because of thetime spent on computing its fitness function. Thus, even if the
distance-based fitnessincurs a significantlyslower throughput, it
allows Ankou to find more unique crashes.
Remarkably, the difference in branch coverage was insignificant :
it was under 1.5% on average. This result coincides with our obser-
vation:softwarebugsdonotmanifestwhenweachievecertaincode
coverage,butwhenweexerciseaspecificexecutionpath.Therefore,
we conclude that distance-based fitness function benefits grey-box
fuzzing in terms of finding software bugs in an effective manner.
6.5 RQ4: Distance-based Fuzzing Cost
In this subsection, we evaluate the practicality of distance-based
fuzzingwith thefollowingtwoquestions: (1)Isthedynamic PCA
necessary? How slow would it be if we were to use the standardPCA instead?; and (2) How much performance overhead can weobserve by enabling distance-based fuzzing assisted by dynamic
PCA instead of a coverage-based approach?
The answer to the first question is indeed simple: our initial
fuzzerprototypewiththestandardPCAwasnotusableasitspendsmost of its time on computing the PCA. On our machine, it took
aboutanhourtocomputethe PCAfor5,000seedfiles.Giventhat
fuzzerstypicallyrunthousandsoftestcasespersecond,itwould
not be possible to use the standard PCA in practice.
Toanswerthesecondquestion, wecomparedthetestcasegen-
eration speed of b oth Ankou and AFL. We chose AFL because it
is a highly optimized fuzzer in terms of its fuzzing speed[59]. Fig-
ure6showsthetestcasegenerationthroughput,whichisagood
measureforthecostofadditionaloperations,asdiscussedin ¬ß6.1.
WeobservedthatAnkouwas35.0%slowerthanAFLonaverage,
with89%ofthe experimentsbeingsignificant.However,thisdoes
notmean that Ankou is a worse fuzzer than AFL. Although Ankou
is slow in generating test cases, it produces more meaningful ones,
and thus, finds twice more bugs than AFL as we will see in ¬ß6.6.
Unexpectedly, Ankou showed abetter throughput than AFL on
13% of the subjects. We thought this could be caused by Ankou
achievinglowercodecoverage,makingexecutionsfaster.However,thecorrelationbetweenthecoverageandthethroughputratioswas
only -0.6%. We believe Ankou found new regions of the programs
thatquickly terminate,while AFLdid not.Overall, distance-based
fuzzingsignificantlydecreasesthethroughput,butitisworthwhiletoperformmoreinformed,hencemoreeffective,seedpoolupdates.
6.6 RQ5: Comparison against Other Fuzzers
Although dynamic PCA is costly, it can enable higher software
bug finding. To understand thepractical impact of distance-based
fuzzing, weanswer thefollowing two questions:(1) howeffective
Ankou is in terms of the number of unique crashes found? (2) how
fast can Ankou find a crash?
6.6.1 Number of Crashes. We ran Ankou, AFL, and Angora on
each subject. We then measured how many crashes were found for
each subject along with the achieved branch coverage.
10320.010.1110100
SubjectsCrash / Coverage rat io
(in log)# Crashes
Coverage
(a) Ankou vs. AFL.
110100
SubjectsCrash / Coverage rat io
(in log)# CrashesCoverage
(b) Ankou vs. Angora.
Figure 7: Comparison between Ankou and other fuzzers in
termsofthenumberofcrashesfoundandbranchcoverage.
Figure 7a presents the result against AFL. In total, Ankou found
3KmoreuniquecrashesthanAFL,whichis1 .94√ómoreonaverage.
Ankoufoundmorecrasheson75%ofthesubjects,onwhich66%
oftheexperimentswheresignificant.Ontheotherhand,thetwo
fuzzersachievedmoreorlessthesamebranchcoverage:onaverage
Ankoucovered1.27%morebranchesthanAFL.NotethatAnkou
was able to find twice more crashes even though there was no big
differenceintermsofcodecoverage.Thisresultindeedalignswith
ourkeyintuition:softwarebugsoftenmanifestwhenweexercise
a particular execution path, but not when we reach a node.
Figure 7b presents the result against Angora. Unlike AFL and
Ankou, Angora requires DFSan [ 1] instrumentation to perform
tainttracking,whichmakesitdifficulttocompileourbenchmark.
Asaresult,wewereonlyabletocompileabouthalfofthepackages.Amongthese,Angorafoundcrashesin22subjects.Here,wereport
results only on those. On average, Ankou found 8 .0√ómore crashes
than Angora.Ankou prevailedon most subjects,and halfof them
showed strong statistical significance. These results confirm using
the distance-based fitness function leads to better crash finding.
6.6.2 Time-To-Exposure of Crashes. We also measured how much
time each fuzzer spends to find the first crash. On the subjects
where bothAFL and Ankoufound crashes, Ankouwas 27% faster
in finding the first crash. Similarly, on the subjects where both
AngoraandAnkoufoundcrashes,Ankoufoundthem68%earlier.
ThisresultalsoconfirmstheeffectivenessofAnkouagainststate-
of-the-art fuzzers in terms of its bug-finding ability.
6.7 Examination on Bugs Found
In¬ß6.6(RQ5),wereportedtheaveragenumberofcrashesfoundfor
six repeated fuzzing experiments. During the whole experiment,
Ankoufound93,754crashesonthe150subjectsfor21,600hours
(=24√ó6√ó150). Although this number has its own value, we
analyzedfurthertounderstandhowmanyuniquebugseachfuzzerAnkou AFL
473 279 253
(a) Ankou vs. AFL.Ankou Angora
79 20 4
(b) Ankou vs. Angora.
Figure 8: Comparison of bugs found.
Table 2: Comparison between fuzzers by the number of
unique bugs when triaged with stack hash.
# of Bugs Found # of Bugs Found
Package Name Ankou AFL Ankou‚Ä†Angora
binutils 11 36 11 4
bison 58 71 36 2
catdoc 01 5 0 0
cflow 21 18 13 1
clamav 00 00
dwarf 22 22
GraphicsMagick 22 27 21 11
jasper 42 37 0 0
libav 17 00
libexiv2 82 59 16 4
libgxps 55 00
liblouis 18 11 0 0
libming 84 60 0 0
libncurses 48 53 0 0
libraw 24 00
libsass 155 12 0 0
libtasn1 00 00
libtiff 32 00
libtorrent 00 00
mpg123 00 00
nasm 28 12 0 0
pspp 168 99 0 0
tcpdump 00 00
vim 22 00
Total 752 532 99 24
‚Ä†As mentioned in ¬ß6.6.1, we were not able to compile Angora on all the packages. For fair com-
parison, we report bugs found by Ankou only on the subjects that Angora was able to run on.
found. This is important, as noted by Klees et al.[28], because
multiple unique crashes may be due to the same bug.
Unfortunately, manual inspection was not an option as there
weresimplytoomanycrashes.WeoriginallytriedtorunASan[ 49]
to triage the crashes, but it failed to detect the root cause of many
crashes.Therefore,wedecidedtousesafestackhash[ 12]instead,
whichworksthesameastheclassicstackhash[ 41]withoneexcep-
tion:whenthereisanunreachablereturnaddressinthestack-trace,
itstopstraversingthestack.Inourexperiment,wecomputedthe
safe stack hash of the top five stack-trace entries of each crash.
Although there are advanced crash triaging algorithms [ 17,56], it
is beyond the scope of this paper to adopt such techniques.
Figure8andTable2representsthenumberofuniquebugsfound
after running the safe stack hash on all the crashes found. Overall,
Ankoufound1.4 √óand4.1√ómoreuniquebugsthanAFLandAngora,
respectively. There were overlaps, but there were a higher number
of bugs that only Ankou was able to find. All these results confirm
the practicality of Ankou in terms of bug finding.
7 DISCUSSION
First, we define the execution distance (Definition 3.2) as the Eu-clidean distance in the branch-hit-count space
Œ©p. Although we
1033believethechoiceofEuclideandistanceisintuitive,onemaycon-
sideradifferentdistancemetricsuchasManhattandistance.Fur-
thermore, the fitness function is defined as the minimum distance
fromatestcase executiontotheseedpoolexecutions.Whilethis
isintuitivelytheamountofdiscoverymadebythisnewtestcase,
there may be a more optimal way of setting the fitness function.
We see improving this area as promising future work.
In our experiment, the dynamic PCA was always able to reduce
thestatespacewithanacceptableinformationloss.However,there
is no guarantee that it will be the case for all programs. We leave it
as future work to prove a theoretical bound of its information loss.
With the adaptive seed pool update, the fitness threshold Œ∏fitis
adaptivelysettotheminimumexecutiondistancebetweenanytwo
seeds.However,theremaybeopportunitiestochooseamoreap-
propriate threshold by not limiting ourselves to the contents of the
seed pool. For example, refused test cases, even though they were
notincludedinthepool,maybeabletoprovideusefulinformation
to help this choice. Designing an optimal strategy for updating the
seed pool is beyond the scope of this paper.
8 RELATED WORK
Fuzzing.Fuzzinghasshownremarkablesuccessinvariousar-
eas [9,11,12,23,25,26,32,33,35,37,39,43‚Äì47,51,57]. In the
context of fuzzing, usage of the evolutionary algorithm was first
introducedbySidewinderin2006[ 19]andpopularizedbyAFLand
LibFuzzer [ 5,58]. Ankou is also a grey-box fuzzer built upon the
evolutionary framework. However, its uniqueness is its leverage
of an informative fitness function that we call distance-based fit-
ness, which deals with the considerably high dimensionality of the
program state space, compared to the existing fitness functions.
Improving Fitness Function .Therehavebeenseveralresearch
papers on improving the information given to, and the objective of
the fitness function. CollAFL [ 22] improves information quality by
avoidinghashcollisions,thusindirectlyenhancesthefuzzerfitness
function.Althoughitgainsbyavoidingimprecision,itsfitnessis
still based on branch-hit-count states, so it suffers from the local
optimum problem. PerfFuzz [ 31] leverages multi-dimensional feed-
backconsideringbothcodecoverageandexecutioncountstotacklethelocaloptimumproblem.Eclipser[
15]usesbranchdistances[ 40]
to guide their search towards solving linear and monotonic con-
straints. Angora [ 14] augments its fitness function by considering
the calling context when calculating branch coverage. However,
noneoftheseapproacheshandlesthehigh-dimensionalityproblem
ofemploying aninformative fitnessfunction.Our distance-based
fitness function is complementary to them.
Distance between Test Cases .Feldtet al.[20] proposed a dis-
tance quantifying the difference between test cases. Unlike execu-
tiondistance(seeDefinition3.2),whichisbasedontheexecutionofaprogram,thisoneisbasedontheinputcontentsalone.Itcouldstill
have been used in complement to Œ¥Bif it was not for its high com-
putational cost. Pinilla-L√≥pez et al.[36] compute PCA on the most
recently discovered seeds to bias the seed scheduling. Although
theirworksharesthesameintuitioninconceptualizingthestate
space,ourapproachdiffersbothingoalaswellasintheunderlying
technique.Ourgoalisguidingafuzzingcampaignusingafitnessfunction,whiletheirsismodifyingtheseedschedulingalgorithm.
Moreover, scheduling algorithms can only be informed by seedsalready chosen by their fitness function. However, our approach
recognizes information from all the generated test cases.
Seed Scheduling .Starting from Woo et al.[55] seed schedul-
ing has been a popular topic for improving fuzzers. AFLGo [ 10]
and Hawekeye [ 13] combine fuzzing with information extracted
from static analysis to direct fuzzers. AFLFast [ 11] suggests power
scheduling,whichassignsmoreenergytoseedsthatachievehigher
code coverage. Cerebro [ 34] enhances seed schedulingbased on a
variety of objectives such as code complexity and code coverage
ofseeds.Suchimprovementhasthebenefitoffocusingonatiny
subset of test cases already selected by the user or the fitness func-
tion, i.e., the seed pool. Unfortunately, we cannot directly apply
these techniques to a fitness function due to its harsh performance
requirement: it needs to run for every single test case.
Advanced PCA .Roweis[48]suggestsanexpectationmaximiza-
tion algorithm for computing PCA. It does not need the covariance
matrix, and only calculates the desired number of principal com-ponents. However, this approach requires all the samples to be
givenatthebeginningofthealgorithm, whichdoesnotmeetour
needs since fuzzers generate samples throughout the fuzzing cam-
paign. On the other hand, the online PCA [ 42,54] aims to compute
principalcomponentsonthefly:whenevernewdataisacquired,itupdatesthecurrentprincipalcomponents.Thissolutionisnotsuitable for grey-box fuzzing as each of the online PCA updateshas a complexity of
O(n2), wherenis the number of dimensions
of the original space, i.e., the number of branches. Whereas the
timecomplexity ofdynamicPCAislinear in n.Otherapproaches
such as random projection based online PCA [ 24] and stochastic
PCA[8,50]havealinearcomplexity.Thisisachievedbydiscarding
muchoftheavailabledata,unlikethedynamicPCA,whichincludes
most of the data by updating the covariance matrix and its basisimprovement mechanism. Furthermore, none of the approaches
above includes a discount factor, described in ¬ß4.3.
9 CONCLUSION
WedesignedandimplementedAnkou,thefirstgrey-boxfuzzerthat
operates with a high dimensionality representation of the program
state space. Ankou employs distance-based fitness function, which
provides too much information about program executions to con-
sume in practice. However, we transform the information obtained
by the fitness function with our novel dimensionality reductiontechniquethatwerefertoasdynamicPCA.Asaresult,wewereable to greatly improve the current state of grey-box fuzzing in
terms of its bug finding ability. We made both our source code and
benchmark public to support open science.
ACKNOWLEDGMENTS
We thank anonymous reviewers for their constructive feedback.
This work was supported by Institute of Information & communi-
cations Technology Planning & Evaluation (IITP) grant funded by
theKoreagovernment(MSIT)(No.2019-0-01697,Developmentof
AutomatedVulnerabilityDiscoveryTechnologiesforBlockchain
Platform Security).
1034REFERENCES
[1][n.d.]. Data Flow Sanitizer. http://clang.llvm.org/docs/DataFlowSanitizer.html.
[2][n.d.]. Fidgety AFL. https://groups.google.com/forum/#!topic/afl-users/
fOPeb62FZUg.
[3] [n.d.]. The Go Programming Language. https://golang.org.
[4] [n.d.]. Gonum Numeric Library. https://www.gonum.org.[5] [n.d.]. LibFuzzer. http://llvm.org/docs/LibFuzzer.html.[6]
Mike Aizatsky, Kostya Serebryany, Oliver Chang, Abhishek Arya, and Meredith
Whittaker.2016. AnnouncingOSS-Fuzz:ContinuousFuzzingforOpenSource
Software. Google Testing Blog.
[7]Andrea Arcuri and Lionel Briand. 2011. A practical guide for using statistical
tests to assess randomized algorithms in software engineering. 1‚Äì10.
[8]Raman Arora, Andy Cotter, and Nati Srebro. 2013. Stochastic optimization ofPCA with capped MSG. In Advances in Neural Information Processing Systems.
1815‚Äì1823.
[9]Cornelius Aschermann, Sergej Schumilo, Tim Blazytko, Robert Gawlik, and
Thorsten Holz. 2019. REDQUEEN: Fuzzing with Input-to-State Correspondence.
InProceedings of the Network and Distributed System Security Symposium.
[10]MarcelB√∂hme,Van-ThuanPham,Manh-DungNguyen,andAbhikRoychoud-
hury.2017. Directed GreyboxFuzzing.In Proceedingsof theACM Conferenceon
Computer and Communications Security. 2329‚Äì2344.
[11]Marcel B√∂hme, Van-Thuan Pham, and Abhik Roychoudhury. 2016. Coverage-
based Greybox Fuzzing as MarkovChain. In Proceedings of the ACM Conference
on Computer and Communications Security. 1032‚Äì1043.
[12]Sang Kil Cha, Maverick Woo, and David Brumley. 2015. Program-Adaptive
MutationalFuzzing.In ProceedingsoftheIEEESymposiumonSecurityandPrivacy.
725‚Äì741.
[13]HongxuChen,YinxingXue,YuekangLi,BihuanChen,XiaofeiXie,XiuhengWu,
andYangLiu.2018. Hawkeye: Towardsa DesiredDirectedGrey-box Fuzzer.In
ProceedingsoftheACMConferenceonComputerandCommunicationsSecurity.
2095‚Äì2108.
[14]Peng Chen and Hao Chen. 2018. Angora: Efficient Fuzzing by Principled Search.
InProceedings of the IEEE Symposium on Security and Privacy. 855‚Äì869.
[15]JaeseungChoi,JoonunJang,ChoongwooHan,andSangKilCha.2019. Grey-box
ConcolicTestingonBinary Code.In ProceedingsoftheInternationalConference
on Software Engineering. 736‚Äì747.
[16]PaoloCiaccia,MarcoPatella,andPavelZezula.1997. M-Tree:AnEfficientAccessMethod for Similarity Search in Metric Spaces. In Proceedings of the International
Conference on Very Large Data Bases. 426‚Äì435.
[17]WeidongCui,MarcusPeinado,SangKilCha,YanickFratantonio,andVasileiosP.
Kemerlis. 2016. RETracer: Triaging Crashes by Reverse Execution from Par-
tialMemoryDumps.In ProceedingsoftheInternationalConferenceonSoftware
Engineering. 820‚Äì831.
[18]AlDanial.[n.d.]. CountLinesofCode:CoverageTool. http://cloc.sourceforge.
net/.
[19]Shawn Embleton, Sherri Sparks, and Ryan Cunningham. 2006. ‚ÄúSidewinder‚Äù: An
Evolutionary Guidance System for Malicious Input Crafting. In Proceedings of
the Black Hat USA.
[20]Robert Feldt, Simon Poulding, David Clark, and Shin Yoo. 2016. Test Set Diame-
ter: Quantifying the Diversity of Sets of Test Cases. In Proceedings of the IEEE
InternationalConferenceonSoftwareTesting,VerificationandValidation.223‚Äì233.
[21]John GF Francis. 1961. The QR transformation a unitary analogue to the LR
transformation. Comput. J. 4, 3 (1961), 265‚Äì271.
[22]ShuitaoGan,ChaoZhang,XiaojunQin,XuwenTu,KangLi,ZhongyuPei,and
Zuoning Chen. 2018. CollAFL: Path Sensitive Fuzzing. In Proceedings of the IEEE
Symposium on Security and Privacy. 660‚Äì677.
[23]PatriceGodefroid,HilaPeleg,andRishabhSingh.2017. Learn&Fuzz:Machine
Learning for Input Fuzzing. In Proceedings of the International Conference on
Automated Software Engineering. 50‚Äì59.
[24]NathanHalko,Per-GunnarMartinsson,andJoelATropp.2011. FindingStructure
withRandomness:ProbabilisticAlgorithmsforConstructingApproximateMatrix
Decompositions. SIAM review 53, 2 (2011), 217‚Äì288.
[25]HyungSeokHanandSangKilCha.2017. IMF:InferredModel-basedFuzzer.In
ProceedingsoftheACMConferenceonComputerandCommunicationsSecurity.
2345‚Äì2358.
[26]HyungSeok Han, DongHyeon Oh, and Sang Kil Cha. 2019. CodeAlchemist:
Semantics-Aware Code Generation to Find Vulnerabilities in JavaScript Engines.
InProceedings of the Network and Distributed System Security Symposium.
[27] Ian T. Jolliffe. 2011. Principal Component Analysis. Springer.
[28]GeorgeKlees,AndrewRuef,BenjiCooper,ShiyiWei,andMichaelHicks.2018.
Evaluatingfuzztesting.In ProceedingsoftheACMConferenceonComputerand
Communications Security. 2123‚Äì2138.
[29]lafintel. 2016. Circumventing Fuzzing Roadblocks with Compiler Trans-
formations. https://lafintel.wordpress.com/2016/08/15/circumventing-fuzzing-
roadblocks-with-compiler-transformations/.
[30]Joel Lehman and Kenneth O Stanley. 2008. Exploiting Open-Endedness to Solve
Problems through the Search for Novelty. In Proceedings of the International
Conference on Artificial Life. 329‚Äì336.[31]Caroline Lemieux, Rohan Padhye, Koushik Sen, and Dawn Song. 2018. PerfFuzz:
Automatically Generating Pathological Inputs. In Proceedings of the International
Symposium on Software Testing and Analysis. 254‚Äì265.
[32]CarolineLemieuxandKoushikSen.2018. FairFuzz:ATargetedMutationStrategyforIncreasingGreyboxFuzzTestingCoverage.In ProceedingsoftheInternational
Conference on Automated Software Engineering. 475‚Äì485.
[33]Yuekang Li, Bihuan Chen, Mahinthan Chandramohan, Shang-Wei Lin, Yang Liu,
andAlwenTiu.2017. Steelix:Program-stateBasedBinaryFuzzing.In Proceedings
of the International Symposium on Foundations of Software Engineering. 627‚Äì637.
[34]YuekangLi,YinxingXue,HongxuChen,XiuhengWu,CenZhang,XiaofeiXie,
Haijun Wang,and Yang Liu.2019. Cerebro:Context-Aware Adaptive Fuzzing for
Effective Vulnerability Detection. In Proceedings of the International Symposium
on Foundations of Software Engineering. 533‚Äì544.
[35]DanielLiew,CristianCadar,AlastairFDonaldson,andJRyanStinnett.2019. Just
FuzzIt:SolvingFloating-PointConstraintsusingCoverage-GuidedFuzzing.In
ProceedingsoftheInternationalSymposiumonFoundationsofSoftwareEngineering.
521‚Äì532.
[36]Jorge Pinilla L√≥pez. 2019. Improving fuzzing performance using hardware-
acceleratedhashingandPCAguidance. https://cs.anu.edu.au/courses/csprojects/
19S1/reports/u6759601_report.pdf.
[37]Valentin J. M. Man√®s, HyungSeok Han, Choongwoo Han, Sang Kil Cha, Manuel
Egele, Edward J. Schwartz, and Maverick Woo. 2019. The Art, Science, andEngineering of Fuzzing: A Survey. IEEE Transactions on Software Engineering
(2019). https://doi.org/10.1109/TSE.2019.2946563
[38]Valentin J. M. Man√®s, Soomin Kim, and Sang Kil Cha. 2020. Ankou. https:
//github.com/SoftSec-KAIST/Ankou.
[39]Bj√∂rnMathis,RahulGopinath,Micha√´lMera,AlexanderKampmann,Matthias
H√∂schele,andAndreasZeller.2019. Parser-directedFuzzing.In Proceedingsofthe
ACMConferenceonProgrammingLanguageDesignandImplementation .548‚Äì560.
[40]Phil McMinn. 2011. Search-Based Software Testing: Past, Present and Future. In
Proceedings of the IEEE International Conference on Software Testing, Verificationand Validation Workshops. 153‚Äì163.
[41]
DavidMolnar,XueCongLi,andDavidA.Wagner.2009.DynamicTestGenerationtoFindIntegerBugsinx86BinaryLinuxPrograms.In ProceedingsoftheUSENIX
Security Symposium. 67‚Äì82.
[42]Jiazhong Nie, Wojciech Kot≈Çowski, and Manfred K. Warmuth. 2013. OnlinePCA with Optimal Regrets. In Proceedings of the International Conference on
Algorithmic Learning Theory. 98‚Äì112.
[43]Shankara Pailoor, Andrew Aday, and Suman Jana. 2018. MoonShine: Optimizing
OSFuzzerSeedSelectionwithTraceDistillation.In ProceedingsoftheUSENIX
Security Symposium. 729‚Äì743.
[44]Jibesh Patra and Michael Pradel. 2016. Learning to Fuzz: Application-Independent
FuzzTestingwithProbabilistic,GenerativeModelsofInputData. TechnicalReport
TUD-CS-2016-14664. TU Darmstadt.
[45]Van-ThuanPham,MarcelB√∂hme,AndrewE.Santosa,AlexandruR.CƒÉciulescu,
andAbhikRoychoudhury.2019. SmartGreyboxFuzzing. IEEETransactionson
Software Engineering (2019). https://doi.org/10.1109/TSE.2019.2941681
[46]Sanjay Rawat, Vivek Jain, Ashish Kumar, Lucian Cojocar, Cristiano Giuffrida,and Herbert Bos. 2017. VUzzer: Application-aware Evolutionary Fuzzing. In
Proceedings of the Network and Distributed System Security Symposium.
[47]Alexandre Rebert, Sang Kil Cha, Thanassis Avgerinos, Jonathan Foote, David
Warren,GustavoGrieco,andDavidBrumley.2014. OptimizingSeedSelection
for Fuzzing. In Proceedings of the USENIX Security Symposium. 861‚Äì875.
[48]Sam Roweis. 1997. EM Algorithms for PCA and SPCA. In Proceedings of the 1997
Conference on Advances in Neural Information Processing Systems. 626 ‚Äì 632.
[49]Konstantin Serebryany, Derek Bruening, Alexander Potapenko, and Dmitriy
Vyukov.2012. AddressSanitizer:AFastAddressSanityChecker.In Proceedings
of the USENIX Annual Technical Conference. 309‚Äì318.
[50]OhadShamir.2015. AstochasticPCAandSVDalgorithmwithanexponential
convergence rate. In International Conference on Machine Learning. 144‚Äì152.
[51]HeyuanShi,RunzheWang,YingFu,MingzheWang,XiaohaiShi,XunJiao,Houb-ingSong,YuJiang,andJiaguangSun.2019. IndustryPracticeofCoverage-Guided
EnterpriseLinuxKernelFuzzing.In ProceedingsoftheInternationalSymposium
on Foundations of Software Engineering. 986‚Äì995.
[52]Gilbert Strang. 2003. Introduction to Linear Algebra (3 ed.). Wellesley-Cambridge
Press.
[53]CharlesFVanLoanandGeneHGolub.1983. Matrixcomputations. JohnsHopkins
University Press.
[54]ManfredK.WarmuthandDimaKuzmin.2008. RandomizedOnlinePCAAlgo-
rithms with Regret Bounds that are Logarithmic in the Dimension. Journal of
Machine Learning Research 9 (2008), 2287‚Äì2320.
[55]Maverick Woo, Sang Kil Cha, Samantha Gottlieb, and David Brumley. 2013.
Scheduling Black-box Mutational Fuzzing. In Proceedings of the ACM Conference
on Computer and Communications Security. 511‚Äì522.
[56]JunXu,DongliangMu,PingChen,XinyuXing,PeiWang,andPengLiu.2016.
CREDAL: Towards Locating a Memory Corruption Vulnerability with Your Core
Dump. In Proceedings of the ACM Conference on Computer and Communications
Security. 529‚Äì540.
1035[57]WeiYou,XuweiLiu,ShiqingMa,DavidPerry,XiangyuZhang,andBinLiang.
2019. SLF: Fuzzing Without Valid Seed Inputs. In Proceedings of the International
Conference on Software Engineering. 712‚Äì723.[58] Michal Zalewski. [n.d.]. American Fuzzy Lop. http://lcamtuf.coredump.cx/afl/.
[59]Michal Zalewski. [n.d.]. Technical ‚Äúwhitepaper‚Äù for afl-fuzz. http://lcamtuf.
coredump.cx/afl/technical_details.txt.
1036