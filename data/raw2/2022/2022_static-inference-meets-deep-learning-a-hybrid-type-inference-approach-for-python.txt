Static Inference Meets Deep Learning: A Hybrid Type Inference
Approach for Python
Yun Peng
TheChineseUniversityofHongKong
Hong Kong, China
ypeng@cse.cuhk.edu.hkCuiyun Gao‚àó
Harbin Institute of Technology
Shenzhen, China
gaocuiyun@hit.edu.cnZongjie Li
Harbin Institute of Technology
Shenzhen, China
lizongjie@stu.hit.edu.cn
Bowei Gao
Harbin Institute of Technology
Shenzhen, China
1160300103@hit.edu.cnDavid Lo
Singapore Management University
Singapore
davidlo@smu.edu.sgQirun Zhang
Georgia Institute of Technology
United States
qrzhang@gatech.edu
Michael Lyu
TheChineseUniversityofHongKong
Hong Kong, China
lyu@cse.cuhk.edu.hk
ABSTRACT
TypeinferencefordynamicprogramminglanguagessuchasPython
is an important yet challenging task. Static type inference tech-
niques can precisely infer variables with enough static constraints
but are unable to handle variables with dynamic features. Deep
learning (DL) based approaches are feature-agnostic, but they can-
not guarantee the correctness of the predicted types. Their per-
formance significantly depends on the quality of the training data
(i.e., DL models perform poorly on some common types that rarely
appear in the training dataset). It is interesting to note that the
static and DL-based approaches offer complementary benefits. Un-
fortunately,toourknowledge,precisetypeinferencebasedonboth
static inference and neural predictions has not been exploited and
remains an open challenge. In particular, it is hard to integrate DL
models into the framework of rule-based static approaches.
This paper fills the gap and proposes a hybrid type inference
approach named HiTyper based on both static inference and deep
learning.Specifically,ourkeyinsightistorecordtypedependen-
cies among variables in each function and encode the dependency
informationin typedependencygraphs (TDGs).BasedonTDGs,we
can easily integrate type inference rules in the nodes to conduct
static inference and type rejection rules to inspect the correctness
of neural predictions. HiTyper iteratively conducts static inference
and DL-based prediction until the TDG is fully inferred. Experi-
mentsontwobenchmarkdatasetsshowthatHiTyperoutperforms
state-of-the-artDLmodelsbyexactlymatching10%morehuman
‚àóCorresponding author
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACMmustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA
¬© 2022 Association for Computing Machinery.
ACM ISBN 978-1-4503-9221-1/22/05...$15.00
https://doi.org/10.1145/3510003.3510038annotations.HiTyperalsoachieves anincreaseof morethan30%
oninferringraretypes.Consideringonlythestaticpartof HiTyper,
itinfers2√ó‚àº3√ómoretypesthanexistingstatictypeinferencetools.
Moreover, HiTyper successfully corrected seven wrong human an-
notations in six GitHub projects, and two of them have already
been approved by the repository owners.
1 INTRODUCTION
Dynamically typed programming languages such as Python are be-comingincreasinglyprevalentinrecentyears.AccordingtoGitHubOctoverse2019and2020[
15],PythonoutranksJavaandC/C++and
becomes one of the most popular programming languages. The dy-
namic features provide more flexible coding styles and enable fast
prototyping.However,withoutconcretelydefinedvariabletypes,
dynamically typedprogramming languagesface challengesin en-
suringsecurityandcompilationperformance.Accordingtoarecent
surveybyJetbrains[ 23],statictypingoratleastsomestricttype
hints becomes the top 1 desired feature among Python developers.
To address such problems, some research adopts design principles
ofstaticallytypedprogramminglanguages[ 16,25,47].Forexample,
reusingcompilerbackendofthestaticallytypedlanguages[ 26]and
predicting types for most variables [ 2,4,11,17,18,21,39]. More-
over, Python officially supports type annotations in the Python
Enhancement Proposals (PEP) [28, 29, 56, 61].
Type prediction is a popular task performed by existing work.
Traditional static type inference approaches [ 4,11,17,21,48] and
typeinferencetoolssuchasPytype[ 45],Pysonar2[ 42],andPyre
Infer[40]cancorrectlyinfertypesforthevariableswithenough
static constraints, e.g., for a=1we can know the type of ais
int, but are unable to handle the variables with few static con-
straints,e.g.mostfunctionargumentsordynamicevaluationssuch
aseval()[51].
With the recent development of deep learning (DL) methods,w e
canleverage moretypehints suchasidentifiers andexistingtype
annotationstopredicttypes.ManyDL-basedmethods[ 2,18,31,35,
39,59]havebeenproposed,andtheyshowsignificantimprovement
20192022 IEEE/ACM 44th International Conference on Software Engineering (ICSE)
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:53:04 UTC from IEEE Xplore.  Restrictions apply. ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA Yun Peng, Cuiyun Gao, Zongjie Li, Bowei Gao, David Lo, Qirun Zhang, and Michael Lyu
comparedwithstatictechniques[ 27].WhileDL-basedmethodsare
effective, they face the following two major limitations:
(i)Noguaranteeofthetypecorrectness.Pradel etal.[39]findthat
thepredictionsgivenbyDLmodelsareinherentlyimpreciseasthey
returnalistoftypecandidatesforeachvariable,amongwhichonlyonetypeiscorrectunderacertaincontext.Besides,thepredictionsmadebyDLmodelsmaycontradictthetypingrules,leadingtotype
errors. Even the state-of-the-art DL model Typilus [ 2] generates
about10%ofpredictionsthatcannotpassthetestofatypechecker.
ThetypecorrectnessissuemakestheDL-basedmethodshardtobe
directlydeployed intolarge codebaseswithout validation.Recent
work [2,39] leverages a search-based validation in which a type
checkerisusedtovalidateallcombinationsoftypesreturnedbyDL
models and remove those combinations containing wrong types.However, these approaches cannot correct the wrong types but
only filter them out.
(ii)Inaccurate prediction of rare types. Rare types refer to the
typeswithlowoccurrencefrequenciesindatasets[ 2].Low-frequency
problem has become one of the bottlenecks of DL-based meth-ods [
24,30,46,50,60]. For example, Typilus‚Äôs accuracy drops by
more than 50% for the types with occurrence frequencies fewer
than100,comparedtotheaccuracyofthetypeswithoccurrence
frequencies more than 10,000. More importantly, rare types totally
account for a significant amount of annotations even though each
of them rarely appears. We analyze the type frequencies of twobenchmarkdatasetsfromTypilus[
2]andType4Py[ 34],andfind
along tail phenomenon, i.e., the top 10 types in the two datasets
alreadyaccountfor54.8%and67.8%ofthetotalannotations,and
more than 10,000 and 40,000 types in two datasets are rare types
with frequency proportions less than 0.1%. They still occupy 35.5%
and25.5%oftotalannotationsforthetworespectivedatasetsand
become the long ‚Äútail‚Äù of type distributions.
Toremedythelimitationsofthepreviousstudies,thispaperpro-
posesahybridtypeinferenceframeworknamedHiTyper,which
conducts static type inference and accepts recommendations from
DL models (Static+DL). We propose a novel representation, named
type dependency graph (TDG), for each function, where TDGrecords the type dependencies among variables. Based on TDG,
we reformulate the type inference task into a blank filling problem
where the ‚Äúblanks‚Äù (variables) are connected with dependencies so
thatbothstaticapproachesandDLmodelscanfillthetypesinto
‚Äúblanks‚Äù.
HiTyper infers the ‚Äúblanks‚Äù in TDG mainly based on static type
inference, which automatically addresses DL models‚Äô rare type pre-
diction problem since static type inferencerules are insensitive to
type occurrence frequencies. HiTyper extends the inference ability
of static type inference by accepting recommendations from DL
models when it encounters some ‚Äúblanks‚Äù that cannot be statically
inferred. Different from the search-based validation by Pradel et
al.[39], HiTyper builds a series of type rejection rules to filter out
allwrongpredictionsonTDG,andthencontinuestoconductstatic
type inference based on the reserved correct predictions.
We evaluate HiTyper on two public datasets. One dataset is
released by Allamanis et al.in the paper of Typilus [ 2], and the
other is ManyTypes4Py [ 35], one large dataset recently released
forthistask.ExperimentresultsshowthatHiTyperoutperforms
bothSOTADLmodelsandstatictypeinferencetools.Compared
Figure1:Typedependencygraphoftheparse()fromCode.1.
withtwoSOTADLmodelsTypilusandType4Py,HiTyperpresents
a 10%‚àº12% boost on the performance of overall type inference,
a n da6 % ‚àº71% boost on the performance of certainkinds of type
inferencesuchasreturnvaluetypeinferenceanduser-definedtypeinference.Withouttherecommendationsfromneuralnetworksand
onlylookingat thestatictypeinference part, HiTypergenerally
outputs 2 √ó‚àº3√ómore annotations with higher precision than cur-
rent static type inference tools Pyre [ 40] and Pytype [ 45]. HiTyper
can also identify wrong human annotations in real-world projects.
We identify seven wrong annotations in six projects of Typilus‚Äôs
dataset and submit pull requests to correct these annotations. Two
project owners have approved our corrections.
Contributions. Our contributions can be concluded as follows:
‚Ä¢To the best of our knowledge, we are the first to proposea hybrid type inference framework that integrates static
inference with DL for more accurate type prediction.
‚Ä¢We design an innovative type dependency graph to strictlymaintain type dependencies of different variables.
‚Ä¢
We tackle some challenges faced by previous studies and
design aseries of typerejection rules and atype correction
algorithm to validate neural predictions.
‚Ä¢Extensiveexperimentsdemonstratethesuperiorperformance
of the proposed HiTyper than SOTA baseline models and
static type inference tools in the task.
2 MOTIVATING EXAMPLE
Listing 1 illustrates an example of code snippet from the WebDNN
project.1Resultsofseveralbaselines,includingstatictypeinference
1https://github.com/mil-tokyo/webdnn
2020
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:53:04 UTC from IEEE Xplore.  Restrictions apply. Static Inference Meets Deep Learning: A Hybrid Type Inference Approach for Python ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA
techniques-PytypeandPysonar2,andstate-of-the-artDLmodels-
Typilus, are depicted in Table 1.
1#src/graph_transpiler /webdnn/graph/shape.py
2def parse(text):
3 normalized_text = _normalize_text(text)
4 tmp = ast.literal_eval(normalized_text)
5 shape = []
6 placeholders = {}
7 for i, t in enumerate (tmp):
8 if isinstance (t, str):
9 pt = Placeholder(label=t)
10 placeholders[t] = pt
11 elif isinstance (t, int):
12 pt = t
13 shape.append(pt)
14 return shape, placeholders
Listing 1: A Function from WebDNN.
Static Inference. According to Table 1, we can find that the
static type inference techniques fail to infer the type of the argu-
ment textsince the argument is at the beginning of data flow
withoutanyassignmentsordefinitions.Onecommonsolutionto
infer the type is to use inter-procedural analysis and capture the
functions that call parse() [52]. However, tracing the functions in
programs, especially in some libraries, is not always feasible. As
for the returnvalue, by analyzingthe data flow anddependencies
betweenvariables,staticinferencecaneasilyidentifythat shape
(line5,13)and placeholders (line6,10)consistofthereturnvalue.
It can recursively analyze the types of the two variables, and fi-nally output the accurate type of the return value. Indeed, both
Pysonar2andPytypecancorrectlyinferthatthereturnvalueisa
tuple containing a list and dict.
DL Approach. The DL model Typilus [ 2] accurately predicts
thetypeas straccordingtothesemanticsdeliveredbytheargu-
ment textandcontextualinformation.ThecaseillustratesthatDL
modelscanpredictmoretypes thanstaticinference.However,Typ-
ilusfailstoinfer thetypeofthereturnvalueof parse().Current
DL models cannot maintain strict type dependencies between vari-
ables. Therefore, Typilus only infers the type as a tuple but cannot
accuratelypredictthetypesinsidethetuple.Whenaddingatype
checkertovalidateTypilus‚Äôspredictions,itsargumentpredictionis
reserved since it does not violate any existing type inference rules.
However,forthereturnvalue,its2ndand3rdtypepredictionsin
Table1byTypilusarerejectedsincethereturnvalueof parse()
explicitlycontainstwoelementswithdifferenttypes.The1stpredic-
tion is also rejected because it contains the type Optional[text]
that does not appear in the return value. In this case, the model
does not produce any candidate type for the return value.
Static+DLApproach. Forthecodeexample,wefindthatstatic
inference is superior than DL models when sufficient static con-straintsordependenciesaresatisfied,whileDLmodelsaremore
applicable for the types lacking sufficient static constraints. Given
the code, HiTyper first generates the TDG of it, as shown in Fig. 1,
and tries to fill all nodes in TDG with corresponding types ("blank
filling").Fortheargument text,HiTyperidentifiesthatthetype
cannotbeinferredbystaticinference(itdoesnothaveanyinput
edges)andasksDLforrecommendations.HiTyperdoesnotdirectly
output thepredictions from DLas final typeassignments. Instead,Table1:PredictionresultsofdifferentbaselinesforListing1.
Approach Baseline Argument Return Value
GroundTruthstrTuple[List[int, Placeholder],Dict[str, Placeholder]]
StaticPysonar2 ? Tuple[List[int],Dict]Pytype ? Tuple[List, Dict]
DL Typilus 1. str1. Tuple[collections.OrderedDict[Text, List[DFAState]],Optional[Text]],Tuple[Any,List[Tuple[Any]], Any]2. Tuple[Text]3. Tuple[torch.Tensor]
Static+DLHiTyper(Typilus)strTuple[List[int, Placeholder],Dict[str, Placeholder]]
HiTypervalidatestheprediction‚Äôscorrectnessandacceptsthere-
sultonlyifnotypeinferencerulesareviolated.Whenpredicting
the return value, HiTyper captures its type dependencies based on
the TDG (it connects with two input nodes) and directly leverages
staticinferencetoinferthetype.Forthiscase,DLpredictionsare
not required, largely avoiding the imports of wrong types.
3 HITYPER
In thissection, wefirst introducethe definitionsused in HiTyper
and then elaborate the details of HiTyper.
3.1 Definition of Types
Fig. 3 shows the definitions of different types according to the
official documentation of Python [ 9] and its type checker mypy[8].
Note that we remove the objecttype and Anytype since they are
not strict static types. In general, all types can be classified into
built-in types and user-defined types. Built-in types are predefined
inthelanguagespecificationofPythonwhileuser-definedtypes
are created by developers. Developers can define the operations or
methodssupportedbyauser-definedtypeandoverwritesomebuilt-
in operations for their user-defined types. For example, developers
candefinean __add__() methodinaclasssothattwotypesderived
from this class can be directly added together using the built-in
operator +. The operation is called operator overloading. We create
a subcategory for user-defined types with operator overloading
behaviors since they have different type inference rules.
The type categories showed in Fig. 3 are widely used in most
static type inference techniques [ 37,40,45]. Differently, DL-based
studies [2,35] generally categorize the types into common types
andraretypes basedonapre-definedthresholdofoccurrencefre-
quencies (e.g., 100 in [ 2]). For a fair comparison, we also follow
this definition for evaluation. By analyzing the rare types in two
publicdatasetsTypilusandManyTypes4Py,wefindthat79.02%and
99.7%ofraretypesactuallyareuser-definedtypes.Becausestatic
inference technique is frequency-insensitive and cannot recognize
rare types, we mainly add supports for user-defined types on static
inference side of HiTyper.
3.2 Overview
HiTyper accepts Python source files as input and outputs JSONfiles recording the type assignment results. Fig. 2 illustrates its
2021
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:53:04 UTC from IEEE Xplore.  Restrictions apply. ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA Yun Peng, Cuiyun Gao, Zongjie Li, Bowei Gao, David Lo, Qirun Zhang, and Michael Lyu
          Type Dependency
         Graph GeneratorBlank Type Dependency Graph
(TDG)            Forward Type   
        Inference
Patially-Inferred
TDGTDG with
Hot Type Slots            Deep 
              Neural Network
     
             Recommended
TDG
Type Dependency Graph Generation Static Type InferenceFinal Output
Fully-Inferred 
TDGSimilarity-based 
Type Correction            Backward Type 
          Rejection
        Source
    Files
            Hot Type Slots 
          Finder
Neural Type Prediction
Figure2:OverallarchitectureofHiTyper.Blacksolidnodes,hollownodes,rednodesandyellownodesinthetypedependency
graphsrepresentinferredtypeslots,blanktypeslots,hottypeslots,andthetypeslotsrecommendedbyDLmodel,respectively.
ùúÉ‚ààType(Œò)::=ùõæ|ùõº[ùúÉ,...,ùúÉ]|ùë¢|None|type
ùõæ‚ààElementary Type (Œì)::=int|float|str|bool|bytes
ùõº‚ààGeneric Type (ùê¥)::=List|Tuple|Dict|Set|
Callable |Generator |Union
ùëè‚ààBuiltin Type (ùêµ)::=ùõæ|ùõº[ùúÉ]
ùë¢‚ààUser Defined Type (ùëà)::=all classes and named
tuples in code
ùëú‚ààOverloading User ::=ùëéùëôùëôùëêùëôùëéùë†ùë†ùëíùë†ùë§ùëñùë°‚Ñé
Defined Type (ùëÇ)operator overloading in code
Figure 3: Types in Python.
overall architecture. HiTyper includes three major components:
typedependencygraphgeneration,statictypeinference,andneural
type prediction. The static type inference component comprisestwo main steps, i.e., forward type inference and backward type
rejection.
TypeDependencyGraph(TDG)Generation. Specifically,given
aPythonsourcefile,HiTyperfirstgeneratesTDGsforeachfunction
andidentifiesalltheimporteduser-definedtypes(Sec.3.3).TDG
transformseveryvariableoccurrenceandexpressionintonodesandmaintainstypedependenciesbetweenthemsothatstaticinference
and DL models can work together to fill types into it.
Static Type Inference - Forward Type Inference. To main-
tainthecorrectnessofpredictionresults,HiTyperfocusesoninfer-
ring types using static inference. Given a TDG, HiTyper conducts
forwardtypeinferencebywalkingthroughthegraphandimple-
menting the type inference rules saved in each expression node
(Sec.3.4).However,duetothelimitationofstaticinference,inmost
cases HiTyper can only infer partial type slots, i.e., variables, in-
dicated as blacksolid nodes in the partially-inferred TDG in Fig.2;
whiletheblanknodesdenotethetypeslotswithoutsufficientstatic
constraintsandremainingunsolved.Tostrengthentheinference
ability of HiTyper, we ask DL models for recommendations.
Neural Type Recommendation. Through the hot type slot
finder, HiTyper identifies a key subset of the blank nodes as hot
type slots, marked as red nodes in Fig. 2, for obtaining recommen-
dations from DL models. HiTyper also employs a similarity-basedtype correction algorithm to supplement the prediction of user-
defined types, which are the primary source of rare types (Sec. 3.5).
The types recommended by the neural type prediction component
are filled into the graph, resulting in the recommended TDG.
StaticTypeInference-BackwardTypeRejection. HiTyper
utilizestyperejectionrulestovalidatetheneuralpredictionsinhot
typeslots(Sec.3.4).ThenittraversesthewholeTDGtotransmit
therejectedpredictionsfromoutputnodestoinputnodessothatall
nodesinTDGcanbevalidated.FinallyHiTyperinvokesforward
type inference again to infer new types based on the validated
recommendations.
The interactions between forward type inference and backward
type rejection could iterate until the TDG reaches a fixed point,i.e., the types of all nodes do not change any more. Meanwhile,
theiterationsbetweenstaticinferenceandneuralpredictioncan
repeat several times until all type slots are inferred, or a maximum
iteration limit is reached.
3.3 Type Dependency Graph Generation
This section introduces the creation of type dependency graph
(TDG),whichdescribesthetypedependenciesbetweendifferent
variablesinprograms.Fig.4presentsthesyntaxofalltheexpres-
sions that generate types in Python, where each expression corre-
spondstoanodeintheAST(AbstractSyntaxTree).GiventheAST
of a program, HiTyper can quickly identify these expressions. The
expressionnodesconstituteamajorpartofTDG.WedefineTDG
as below.
Definition. Wedefineagraph ùê∫=(ùëÅ,ùê∏)asatypedependency
graph (TDG), where ùëÅ={ùëõùëñ}is a set of nodes representing all
variables and expressions in source code, and ùê∏is a set of directed
edgesofùëõùëñ‚Üíùëõùëóindicatingthe typeof ùëõùëócanbe solvedbasedon
thetypeofùëõùëñbytypeinferencerules.Wealsodenote ùëõùëñistheinput
node ofùëõùëóandùëõùëóis the output node of ùëõùëñhere.
The TDG contains four kinds of nodes:
‚Ä¢symbolnodes represent all the variables for which the types
needtobeinferred.Wealsouse typeslots toindicatesymbol
nodes in the following sections.
‚Ä¢expression nodes represent all the expressions that generate
types as shown in Fig. 4.
‚Ä¢branchnodes represent the branch of data flows.
2022
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:53:04 UTC from IEEE Xplore.  Restrictions apply. Static Inference Meets Deep Learning: A Hybrid Type Inference Approach for Python ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA
ùëí‚ààExpr::=ùë£|ùëê|ùëíblopùëí|ùëínumopùëí|
ùëícmpopùëí|ùëíbitopùëí|
(ùëí,...,ùëí)|[ùëí,...,ùëí]|
{ùëí:ùëí,...,ùëí:ùëí}|{ùëí,...,ùëí}|
[ùëíforùëíinùëí]|{ùëíforùëíinùëí}|
{ùëí:ùëíforùëí,ùëíinùëí}|(ùëíforùëíinùëí)|
ùëí(ùëí,...,ùëí)|ùëí[ùëí:ùëí:ùëí]|ùëí.ùë£
ùë£‚ààVariables ::=all identifiers in code
ùëê‚ààConstants ::=all literals in code
ùëèùëôùëúùëù‚ààBoolean Operations ::=ùê¥ùëõùëë|ùëÇùëü|ùëÅùëúùë°
ùëõùë¢ùëöùëúùëù‚ààNumeric Operations ::=ùê¥ùëëùëë|ùëÜùë¢ùëè|ùëÄùë¢ùëôùë°|ùê∑ùëñùë£|ùëÄùëúùëë|
ùëàùê¥ùëëùëë|ùëàùëÜùë¢ùëè
ùëèùëñùë°ùëúùëù‚ààBitwise Operations ::=ùêøùëÜ‚Ñéùëñùëìùë°|ùëÖùëÜ‚Ñéùëñùëìùë°|ùêµùëñùë°ùëÇùëü|ùêµùëñùë°ùê¥ùëõùëë|
ùêµùëñùë°ùëãùëúùëü|ùêπùëôùëúùëúùëüùê∑ùëñùë£ |ùêºùëõùë£ùëíùëüùë°
ùëêùëöùëùùëúùëù‚ààCompare Operations ::=ùê∏ùëû|ùëÅùëúùë°ùê∏ùëû|ùêøùë°|ùêøùë°ùê∏|ùê∫ùë°|ùê∫ùë°ùê∏|
ùêºùë†|ùêºùë†ùëÅùëúùë°|ùêºùëõ|ùëÅùëúùë°ùêºùëõ
Figure 4: The syntax of expressions for typing in Python
‚Ä¢mergenodes represent the merge of data flows.
HiTyper creates a node for every variable occurrence instead
of every variable in TDG because Python‚Äôs type system allows
variables to change their types at run-time. Similar to static single
assignment (SSA), HiTyper labels each occurrence of a variable
with the order of occurrences, so that each symbol node in the
TDG has a format of $name$order($lineno) to uniquely indicate
avariableoccurrence.Forexample,inFig.1,wecreatethreesymbol
nodes ( pt0(9),pt1(10), pt2(12) ) for variable ptas it appears
three times in Listing 1 (Line 9, 10, and 12).
ImportAnalysis. BeforeestablishingTDGforeveryinputfunc-
tion, HiTyper first conducts import analysis to extract all user-
defined types so that it can distinguish the initialization of user-defined types from regular function calls. HiTyper first collectsall classes in source files, which constitute the initial set of user-defined types. Then it analyzes all local import statements such
as‚Äúfrompackageimportclass ",andaddstheimportedclassesinto
the user-defined type set. For all global import statements suchas ‚Äúimport package ", HiTyper locates the source of this package
and adds all the classes and named tuples in the source into theuser-defined type set. For each imported class, HiTyper solves
thelocationofexternalsourcefilesandcheckswhetheroperator
overloading methods exist in this class.
Type Dependency Graph Generation. Given the AST of in-
putcodeandalltheuser-definedtypesextractedbyimportanalysis,
HiTyper creates TDG for each function based on the main logicshown in Alg. 1. HiTyper first locates all the variables and ex-
pressions in the code by traversing the whole AST. Specifically, to
visit each AST node, HiTyper employs the ASTVisitor provided by
Python‚Äôsmodule ast[43].HiTyperidentifiesexpressionsaccording
to the definitions of expression nodes in Python (as depicted in
Fig.4)andrecordseveryvisitedexpressionnodeusinganexpres-
sion stack. Whenever HiTyper identifies an expression node (LineAlgorithm 1 Type Dependency Graph Generation
Input:The AST of given function, func_ast;
Output: Type dependency graph of the given function, ùë°ùëî
Initialize an expression stack ex_stack
Initialize a variable stack var_stack
1:for allùëõùëúùëëùëí‚ààfunc_ast && nodeis not visited do
2:// handle expression nodes
3:ifnode.type‚ààExpressions then
4:ex_stack.push(node );ex_node‚Üênew ex(node )
5:visit(node .operands); ex_stack.pop(node )
6:ifnotex_stack.empty()then
7:ùë°ùëî.addEdge(ex _node‚Üíex_stack.top())
8:end if
9:ùë°ùëî.addNode(ex _node)
10:end if
11:// handle symbol nodes
12:ifnode.type == ast.Name then
13:sym_node‚Üênew symbol(node )
14:ifnode.ctx == write then
15:ùë°ùëî.addEdge(ex _stack.top()‚Üísym_node)
16:else
17:ùë°ùëî.addEdge(ùë£ùëéùëü_ùë†ùë°ùëéùëêùëò.top()‚Üísym_node)
18:ùë°ùëî.addEdge(sym _node‚Üíex_stack.top())
19:end if
20:ùë£ùëéùëü_ùë†ùë°ùëéùëêùëò.push(sym _node);ùë°ùëî.addNode(sym _node)
21:end if
22:// handle branch and merge nodes
23:ifcheckTypeBranch(node )then
24:branch_node‚Üênew branch(node )
25:ùë°ùëî.addNode(branch _node)
26:ùëêùë°ùë•1,ùëêùë°ùë•2‚ÜêBranch(ùëêùë°ùë•)
27:visit(node .left,ùëêùë°ùë•1); visit(node .right,ùëêùë°ùë•2)
28:end if
29:ifcheckTypeMerge(node )then
30:merge_node‚Üênew merge(node )
31:ùë°ùëî.addNode(merge _node)
32:ùëêùë°ùë•‚ÜêMerge(ùëêùë°ùë•1,ùëêùë°ùë•2)
33:end if
34:end for
3), it builds a same node in the current TDG and pushes it into the
expressionstack.HiTyperwillthenrecursivelyvisitstheexpres-
sion‚Äôsoperandstocapturenewexpressionnodesuntilitencounters
a variable node (Line 12), which is the leaf node of the AST.
HiTyperbuildsasymbolnodeinTDGforeachvisitedidentifier
node of AST, and maintains a variable map to record all the occur-
rencesofeachvariable.TheASTalreadyindicatesthecontextof
each variable occurrence, i.e., whether readorwrite.
(i)If the variable context is read, HiTyper will obtain the last
occurrence of the variable according to the maintained variablemap under the current context. It then creates an edge from the
symbolnodeofthelastoccurrencetothesymbolnodeofthecurrent
variable (Line 16 - 18).
(ii)If the variable context is write, HiTyper will fetch the value
from thelast expressionin theexpression stackand buildan edge
2023
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:53:04 UTC from IEEE Xplore.  Restrictions apply. ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA Yun Peng, Cuiyun Gao, Zongjie Li, Bowei Gao, David Lo, Qirun Zhang, and Michael Lyu
connecting from the expression node to the symbol node of the
current variable (Line 14 - 15).
Analogous to regular data flow analysis, HiTyper also checks
whether the data flow branches (Line 23 - 27) or merges at certain
locations (Line 29 - 32).
In TDG, each symbol node keeps a list of candidate types while
each expression node includes type inference rules and type rejec-
tion rules. When HiTyper walks through TDG, the rules will be
activated to produce new types. Thus, types can flowfrom argu-
ments to return values. By traversal, HiTyper obtains the types of
each symbol node and outputs the type assignment. The leveraged
typeinferencerulesandtyperejectionrulesaredetailedinthenext
subsections.
3.4 Static Type Inference
Thissectiondescribesthetypeinferenceandrejectionrulesinte-
grated in expression nodes, which are the key component of our
statictypeinference.Fig.5denotesallthetypeinferenceandrejec-
tion rules used in static type inference. Each rule consists of some
premises(contentsabovetheline)andconclusions(contentsbelow
the line). They obey the following form:
ùúã/turnstileleftùëí:ùúÉ.
Inthisform, ùúãiscalledthecontext,whichincludesliststhatassign
typestoexpressionpatterns. ùëíistheexpressionshowedinFig.4,
andweuseùëí1,...,ùëí ùëõtorepresentdifferentexpressions. ùúÉisthetype
showed in Fig. 3. We use ùúÉ1,...,ùúÉ ùëõto represent different types. A
rule under this form is called a type judgement ortype assignment.
Ourgoalistogetthecontext ùúãthatassignstypestoallthevariables
in code.
The premises of each rule in Fig. 5 are the types of input nodes
ùúÉ1,ùúÉ2,...that constructs an expression, and the valid type set /tildewideùúÉfor
thecurrentoperation.Usuallytypeinferencerulesonlyhaveone
conclusion,whichistheresulttypeofcurrentexpression.However,aswealsoinvolveneuralpredictionsinTDGandusetyperejection
rulestovalidatethem,theconclusionsofeachruleinFig.5have
twoparts: 1)theresult typeof currentexpressionnode and2)the
validatedtypesofinputnodes.(Somerulesmaynothavethesecond
part because they accept any input types.)
Theresulttypeofthecurrentexpressionnodeiswhattraditional
statictypeinferencetechniquesusuallyinfer.Wedenoteitas for-
wardtypeinference.However,thereexisttypesthatarenotallowedtoconductcertainoperations,whichareguidedby typeconstraints.
Whenatypeconstraintisviolated,e.g.,addinganintegertoastring,
traditionalstaticinferencetechniques[
37,40,45]throwtypeerrors.
For the wrongly predicted cases, HiTyper does not directly throw
a type error since it accepts recommendations from DL models. To
‚Äúsanitize‚Äù the recommendations from DL models, we create type
rejection rules to validate and remove the wrong predictions in
input nodes. We call this as backward type rejection.
Forward Type Inference. HiTyper starts forward type infer-
encewith thenodes thatdo nothaveinput nodesin TDG.Itgradu-
allyvisits allnodes inthe graphandactivates correspondingtype
inferencerulesiftheirpremisesaresatisfied,i.e.,allinputnodesare
fully inferred. This is the forward traversal of TDGs. As forward
type inference in HiTyper is similar to traditional static type infer-
encetechniques,weonlydiscussthe[Call]ruleforwhichHiTyperhasaspecialstrategy.Thepremiseofthe[Call]rulerequiresthe
typeofcallees,whichisbeyondthescopeofcurrentfunctions.This
premiseisonemajorbarrierformoststaticinferencetechniques
to fully infer a program due to a large number of external APIsin Python programs [
19,52]. HiTyper only focuses on inferring
thetypes offunctionswith explicitimplementationin thecurrent
source code, in which the TDGs of the functions are connected.
HiTyperdoesnotinferexternalcallsfortworeasons:1)DLmodels
perform well on predicting the types of commonly-used APIs that
frequently occur in the training set; 2) Python maintains a type-
shed[44] project to collect the type annotations of frequently-used
modules, so HiTyper can directly access the types.
Backward Type Rejection. An input type in an expression
must fulfill two constraints before it can conduct the expression:
1) it must be the valid type to conduct a certain expression, 2) it
must have a valid relationship with other input types. HiTyperrejects the input types that violate these two constraints. It firstchecks whether the type is valid for an expression. We indicates
valid types for each expression as
/tildewideùúÉin Fig. 5. For example, in [In,
NotIn]rule,thetypesof ùëí2mustbeiterableso intisnotallowed
and should not be in the valid type set /tildewideùúÉ. Then HiTyper checks
whether the relationships between all inputs are valid. Apart from
valid types for a certain operation, some operations also require
theinputstosatisfyacertainrelationship.Forexample,in[Add]
rule, the two operands must have the same type. For types of two
inputs intandstr,eventhoughtheyareinthevalidtypesetof
this operation, they are still rejected because they are not the same
type. Therefore, in the [Add] rule, the final valid input types are
the intersection of all input type sets ùúÉ1,ùúÉ2and valid type set /tildewideùúÉ.
TypeRejectionrulescanvalidateandrejecttheinputtypesof
an operation. However, the input types are the results of previous
operations,sothetyperejectionprocesswillalsoaffecttheinput
types of previous operations. To thoroughly removethe influence
of wrong types, HiTyper also rejects the input types that resultin the rejected types according to forward type inference rules.
HiTypergraduallyvalidatesalltypeslotsbystartingfromthetype
slots without output edges and producing the rejected input types.
Then it traverses other slots until the whole TDG is visited. This is
the backward traversal of TDGs.
Correctness. Different from the DL-based approaches [ 18,35],
HiTypercanalwaysguaranteethecorrectnessofitstypeassign-
mentsbasedonstaticinference.Accordingtothearchitectureof
HiTyper in Fig. 2, the type assignments generated by HiTyper
have two cases: 1) If the static inference can successfully handle a
program, HiTyper does not need to invoke DL models to give type
recommendations. Consequently, the type assignments fully based
on the inference rules (Fig. 5) are sound because they are collected
from the Python official implementation CPython [ 10]; and 2) If
thestaticinferencecannotfullyinferaprogramandtheDLmodels
areinvokedtoprovidetyperecommendations(Sec.3.5),HiTyper
utilizestyperejectionrulestovalidatetherecommendationsand
then calls the type inference rules again to infer the remainingtypes. In this case, our rejection rules thoroughly eliminate the
influence of wrong recommendations, and the final results are also
producedbystaticinference.Therefore,HiTyperalwaysmaintains
the type correctness.
2024
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:53:04 UTC from IEEE Xplore.  Restrictions apply. Static Inference Meets Deep Learning: A Hybrid Type Inference Approach for Python ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA
ùë£‚ààDom(ùúã)
ùúã/turnstileleftùë£:ùúÉ(Variable)
ùúã/turnstileleftùëê:ùúÉ(Constant)
ùúã/turnstileleftùëí:ùúÉ
ùúã/turnstileleftùëí.ùë£:ùúÉ.ùë£(Attribute)
ùúã/turnstileleftùëí1:ùúÉ1ùúã/turnstileleftùëí2:ùúÉ2/tildewideùúÉ={bool,int,ùëÇ}
ùúã/turnstileleftùëí1bitopùëí2:ùúÉ‚àß/tildewideùúÉùúã/turnstileleftùëí1:ùúÉ1‚àß/tildewideùúÉùúã/turnstileleftùëí2:ùúÉ2‚àß/tildewideùúÉ
(LShift, RShift)
ùúã/turnstileleftùëí1:ùúÉ1/tildewideùúÉ={bool,int,float,ùëÇ}
ùúã/turnstileleftùëí2:ùúÉ2ùúÉ/prime=ùëîùëíùë°ùëÄùëúùëüùëíùëÉùëüùëíùëêùëñùë†ùëíùëáùë¶ùëùùëí (ùúÉ1‚àß/tildewideùúÉ,ùúÉ2‚àß/tildewideùúÉ)
ùúã/turnstileleftùëí1numopùëí2:ùúÉ/primeùúã/turnstileleftùúÉ1‚àß/tildewideùúÉùúã/turnstileleftùúÉ2‚àß/tildewideùúÉ
(Numeric Operations)
ùúã/turnstileleftùëí1:ùúÉ1/tildewideùúÉ1={int,bool}
ùúã/turnstileleftùëí2:ùúÉ2/tildewideùúÉ2={Œì,List,Tuple,ùëÇ}
ùúã/turnstileleftùëí1numopùëí2:ùúÉ2‚àß/tildewideùúÉ2ùúã/turnstileleftùëí1:ùúÉ1‚àß/tildewideùúÉ1ùúã/turnstileleftùëí2:ùúÉ2‚àß/tildewideùúÉ2
(Mult)
ùúã/turnstileleftùëí1:ùúÉ1ùúã/turnstileleftùëí2:ùúÉ2/tildewideùúÉ={Œì,List,Tuple,ùëÇ}
ùúã/turnstileleftùëí1cmpopùëí2:boolùúã/turnstileleftùëí1:ùúÉ1‚àßùúÉ2‚àß/tildewideùúÉùúã/turnstileleftùëí2:ùúÉ1‚àßùúÉ2‚àß/tildewideùúÉ
(Lt,LtE,Gt,GtE)
ùúã/turnstileleftùë¢(ùëí1,...,ùëí ùëõ):ùë¢(Class Instantiation)
ùúã/turnstileleftùëí1:ùúÉ1... ùúã/turnstileleftùëíùëõ:ùúÉùëõ
ùúã/turnstileleft(ùëí1,...,ùëí ùëõ):Tuple[ùúÉ1,...,ùúÉ ùëõ]ùúã/turnstileleft[ùëí1,...,ùëí ùëõ]:List[ùúÉ1,...,ùúÉ ùëõ]
ùúã/turnstileleft{ùëí1,...,ùëí ùëõ}:Set[ùúÉ1,...,ùúÉ ùëõ](Tuple, List, Set)
ùúã/turnstileleftùëí:ùúÉ/tildewideùúÉ={ùê¥,str,bytes}ùúÉ/prime=ùëîùëíùë°ùê∏ùëôùëíùëöùëíùëõùë°ùëáùë¶ùëùùëí (ùúÉ‚àß/tildewideùúÉ)
ùúã/turnstileleftforùë£inùëí:ùúÉ/primeùúã/turnstileleftùëí:ùúÉ‚àß/tildewideùúÉ
(Comprehension)
ùúã/turnstileleftforùë£inùëí1:ùúÉ1ùúã/turnstileleftùëí2[ùë£]:ùúÉ2
ùúã/turnstileleft(ùëí2[ùë£]forùë£inùëí1):Generator [ùúÉ2]
(Generator)
ùúã/turnstileleftforùë£inùëí1:ùúÉ1ùúã/turnstileleftùëí2[ùë£]:ùúÉ2
ùúã/turnstileleft[ùëí2[ùë£]forùë£inùëí1]:List[ùúÉ2]
ùúã/turnstileleft{ùëí2[ùë£]forùë£inùëí1}:Set[ùúÉ2]
(List, Set Comprehension)ùúã/turnstileleftùëí1:ùúÉ1ùúã/turnstileleftùëí2:ùúÉ2
ùúã/turnstileleftùëí1blopùëí2:Union[ùúÉ1,ùúÉ2]
(Boolean Operations)
ùúã/turnstileleftùëí1:ùúÉ1ùúã/turnstileleftùëí2:ùúÉ2/tildewideùúÉ={bool,int,Set,ùëÇ}
ùúã/turnstileleftùëí1bitopùëí2:ùúÉ‚àß/tildewideùúÉùúã/turnstileleftùëí1:ùúÉ1‚àß/tildewideùúÉùúã/turnstileleftùëí2:ùúÉ2‚àß/tildewideùúÉ
(BitOr, BitAnd, BitXor)
ùúã/turnstileleftùëí1:ùúÉ1ùúã/turnstileleftùëí2:ùúÉ2/tildewideùúÉ={Œì,List,Tuple,ùëÇ}
ùúã/turnstileleftùëí1numopùëí2:ùúÉ‚àß/tildewideùúÉùúã/turnstileleftùëí1:ùúÉ1‚àßùúÉ2‚àß/tildewideùúÉùúã/turnstileleftùëí2:ùúÉ1‚àßùúÉ2‚àß/tildewideùúÉ
(Add)
ùúã/turnstileleftùëí1:ùúÉ1ùúã/turnstileleftùëí2:ùúÉ2/tildewideùúÉ={Œì,Set,ùëÇ}
ùúã/turnstileleftùëí1numopùëí2:ùúÉ‚àß/tildewideùúÉùúã/turnstileleftùëí1:ùúÉ1‚àßùúÉ2‚àß/tildewideùúÉùúã/turnstileleftùëí2:ùúÉ1‚àßùúÉ2‚àß/tildewideùúÉ
(Sub)
ùúã/turnstileleftùëí1:ùúÉ1ùúã/turnstileleftùëí2:ùúÉ2
ùúã/turnstileleftùëí1cmpopùëí2:bool(Eq,NotEq,Is,IsNot)
ùúã/turnstileleftùëí1:ùúÉ1ùúã/turnstileleftùëí2:ùúÉ2
/tildewideùúÉ={str,bytes,List,Tuple,Set,Dict,Generator }
ùúã/turnstileleftùëí1cmpopùëí2:boolùúã/turnstileleftùëí2:ùúÉ2‚àß/tildewideùúÉ
(In,NotIn)
ùúã/turnstileleftùëí:ùúÉùúã/turnstileleftùëí1:ùúÉ1... ùúã/turnstileleftùëíùëõ:ùúÉùëõ
/tildewideùúÉ={Callable [[ùúÉ1,...,ùúÉ ùëõ],ùúÉ]}ùúÉ/prime=ùëîùëíùë°ùëÖùëíùë°ùë¢ùëüùëõùëáùë¶ùëùùëí (ùúÉ‚àß/tildewideùúÉ)
ùúã/turnstileleftùëí(ùëí1,...,ùëí ùëõ):ùúÉ
(Call)
ùúã/turnstileleftùëí1:ùúÉ1... ùúã/turnstileleftùëíùëõ:ùúÉùëõ
ùúã/turnstileleft{ùëí1:ùëí2,...,ùëí ùëõ‚àí1:ùëíùëõ}:Dict[ùúÉ1:ùúÉ2,...,ùúÉ ùëõ‚àí1:ùúÉùëõ]
(Dict)
ùúã/turnstileleftùëí1:ùúÉ1ùúã/turnstileleftùëí2:ùúÉ2/tildewideùúÉ1={Dict}ùúÉ/prime=ùëîùëíùë°ùëâùëéùëôùë¢ùëíùëáùë¶ùëùùëí (ùúÉ1‚àß/tildewideùúÉ1)
ùúã/turnstileleftùëí1[ùëí2]:ùúÉ/primeùúã/turnstileleftùëí1:ùúÉ1‚àß/tildewideùúÉ1
(SubScript)
ùúã/turnstileleftforùë£inùëí1:ùúÉ1ùúã/turnstileleftùëí2[ùë£]:ùúÉ2ùúã/turnstileleftùëí3[ùë£]:ùúÉ3
ùúã/turnstileleft{ùëí2[ùë£]:ùëí3[ùë£]forùë£inùëí1}:Dict[ùúÉ2:ùúÉ3]
(Dict Comprehension)
ùúã/turnstileleftùëí1:ùúÉ1ùúã/turnstileleftùëí2:ùúÉ2/tildewideùúÉ1={ùê¥,str,bytes}
/tildewideùúÉ2={int,bool}ùúÉ/prime=ùëîùëíùë°ùê∏ùëôùëíùëöùëíùëõùë°ùëáùë¶ùëùùëí (ùúÉ1‚àßùúÉ2)
ùúã/turnstileleftùëí1[ùëí2]:ùúÉ/primeùúã/turnstileleftùëí1:ùúÉ1‚àß/tildewideùúÉ1ùúã/turnstileleftùëí2:ùúÉ2‚àß/tildewideùúÉ2
(Slice)
Figure 5: Type inference and rejection rules of expressions in Python
3.5 Neural Type Recommendation
HiTyper conducts static type inference based on type inference
rules When static type inference can fully infer all the variablesin TDG. However, some variables are hard to be statically typedso that HiTyper only gets a partially-inferred TDG. In this case,HiTyper asks DL models for recommendations. The neural typerecommendation part of HiTyper includes two procedures: hot
type slot identification and similarity-based type correction.
Hot TypeSlot Identification. Somevariablescanimpactthe
types of many other variables because they locate at the beginning
of the data flow or possess type dependencies with many variables.
Wecallthesevariablesas hottypeslots.Giventhetypesofhottypeslots, static type inference techniques can infer the remaining type
slots.Therefore,tooptimizethetypecorrectnessof HiTyper,DL
models are only invoked on the hot type slots instead of all the
blank type slots.
Toidentifythehottypeslots,HiTyperfirstremovesslotsalready
filled by static type inference and obtains a sub-graph with allthe blank type slots. Then HiTyper employs a commonly-useddominator identification algorithm semi-NCA [
14] to capture all
dominators in the sub-graph. A node ùëãdominiating another node
ùëåinagraphmeansthateachentrynodeto ùëåmustpassùëã.Thus,ifa
type slotùëãdominates another type slot ùëå,ùëå‚Äôs type can be inferred
fromùëã‚Äôstype. HiTypergraduallyremovesthetypeslots ùëåfrom
2025
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:53:04 UTC from IEEE Xplore.  Restrictions apply. ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA Yun Peng, Cuiyun Gao, Zongjie Li, Bowei Gao, David Lo, Qirun Zhang, and Michael Lyu
Table 2: Comparison with the baseline approaches. Top-1,3,5 of HiTyper means it accepts 1,3,5 candidates from deep neural
networks in type recommendation phase. The neural network in HiTyper is the corresponding comparison DL model.
Dataset Type Category ApproachTop-1 Top-3 Top-5
Exact
MatchMatch to
ParametricExact
MatchMatch to
ParametricExact
MatchMatch to
Parametric
ManyTypes4PyArgumentNaive Baseline 0.14 0.16 0.33 0.38 0.43 0.51
Type4Py 0.61 0.62 0.64 0.66 0.65 0.68
HiTyper 0.65 0.67 0.70 0.74 0.72 0.76
Return ValueNaive Baseline 0.07 0.10 0.19 0.28 0.28 0.42
Type4Py 0.49 0.52 0.53 0.59 0.54 0.63
HiTyper 0.60 0.72 0.63 0.76 0.65 0.77
Local VariableNaive Baseline 0.13 0.17 0.33 0.45 0.47 0.65
Type4Py 0.67 0.73 0.71 0.78 0.72 0.79
HiTyper 0.73 0.85 0.74 0.86 0.75 0.86
AllNaive Baseline 0.13 0.16 0.31 0.40 0.43 0.57
Type4Py 0.62 0.66 0.66 0.72 0.67 0.73
HiTyper 0.69 0.77 0.72 0.81 0.72 0.82
Typilus‚Äôs
DatasetArgumentNaive Baseline 0.19 0.20 0.38 0.42 0.46 0.50
Typilus 0.60 0.65 0.69 0.74 0.71 0.76
HiTyper 0.63 0.68 0.72 0.76 0.76 0.79
Return ValueNaive Baseline 0.11 0.11 0.28 0.31 0.36 0.43
Typilus 0.41 0.57 0.48 0.62 0.50 0.64
HiTyper 0.57 0.70 0.63 0.75 0.64 0.77
AllNaive Baseline 0.17 0.18 0.35 0.39 0.44 0.48
Typilus 0.54 0.62 0.63 0.70 0.65 0.72
HiTyper 0.61 0.69 0.69 0.76 0.72 0.78
Algorithm 2 Type correction of user-defined types
Input:Variable name, ùëõùëéùëöùëí;
Valid user defined type set, ùëÜ;
Type String recommended by deep neural networks, ùë°;
Penaltyaddedforname-typesimilaritytoalignwithtype-type
similarity,ùëùùëíùëõùëéùëôùë°ùë¶;
Output: Corrected type of current variable, ùëêùë°;
1:ifùë°‚ààùëÜor isBuiltin (ùë°)then
2:ùëêùë°‚Üêùë°;
3:else
4:largest_sim ‚Üê0; largest_type ‚ÜêùëÅùëúùëõùëí;
5:ùë°ùë§‚ÜêBPE(ùë°);ùëõùëéùëöùëíùë§‚ÜêBPE(ùëõùëéùëöùëí);
6:foreachùëùùë°‚ààùëÜdo
7:ùëùùë°ùë§‚ÜêBPE(ùëùùë°);
8:ifùë†ùëñùëö(ùëùùë°ùë§,ùë°ùë§)>largest_sim then
9: largest_sim ‚Üêsim(ùëùùë°ùë§,ùë°ùë§); largest_type ‚Üêùëùùë°;
10:end if
11:ifùë†ùëñùëö(ùëùùë°ùë§,ùëõùëéùëöùëíùë§ )+ùëùùëíùëõùëéùëôùë°ùë¶ >largest_sim then
12: largest_sim ‚Üêsim(ùëùùë°ùë§,ùëõùëéùëöùëíùë§ ); largest_type ‚Üêùëùùë°;
13:end if
14:end for
15:ùëêùë°‚Üêlargest_type;
16:end if
thesub-graphuntilnotypeslotscanberemoved.Inthesmallest
sub-graph, each type slot is not dominated by other type slots, and
alltheslotsarehottypeslots.Forthesetypeslots,HiTyperaccepts
type recommendations from DL models.
Similarity-basedTypeCorrectionforUser-definedTypes.
DL models provide one or more type recommendations for eachhot type slot, depending on the strategy (Top-1, -3, or -5) HiTyper
uses. Some DL models [ 18,39] treat user-defined types as OOV
tokens and do not predict the types, while other models [ 2,45]
directly copy user-defined types from the training set but fail to
predict those never appearing in the training set. We propose to
complementtherecommendationofuser-definedtypesusingthe
similarity-basedtypecorrectionalgorithmshowninAlg.2.Note
that HiTyper only focuses on replacing the explicitly incorrect
user-defined types, i.e., those never imported or defined in current
source file, with the most similaruser-defined types collected by
import analysis.
Specifically,iftherecommendedtypedoesnotbelongtobuilt-
in types, HiTyper checks whether the type appears in the user-
definedtypesetcollectedfromimportanalysis(Line1).Ifthecheck
result is False, the type will be regarded as explicitly incorrectand should be corrected. For these incorrect user-defined types,
HiTyperreplacesthemwiththemostsimilarcandidateintheuser-
definedtypeset.HiTyperemploysWord2Vec[ 32]toembedtwo
types and the variable name into word embeddings, and calculates
the cosine distance as the similarity of the two types (Line 6-12).
For the OOV tokens, HiTyper splits them into subtokens using the
BPE algorithm [ 12,53] (Line 5). Finally, HiTyper chooses the type
candidate with the largest similarity to fill the user-defined type
(Line 15).
4 EVALUATION
In the section, we answer the following research questions:RQ1:
How effective is HiTyper compared to baseline approaches?
RQ2:Can HiTyper well predict the rare types?
2026
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:53:04 UTC from IEEE Xplore.  Restrictions apply. Static Inference Meets Deep Learning: A Hybrid Type Inference Approach for Python ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA
Table 3: Type distribution in the test set. ‚ÄúRare‚Äù indicates
rare types and ‚ÄúUser‚Äù indicates user-defined types.
Category Total RareUser ArgReturn Local
TypilusCount 15,772 7,103 5,572 11,261 4,511 -
Prop. 100% 45% 35% 71% 29% -
Type4PyCount 37,40814,035 10,023 11,807 5,491 20,110
Prop. 100% 37% 27% 32% 15% 53%
RQ3:What is the performance of the static type inference compo-
nent in HiTyper?
4.1 Experimental Setup
Dataset. We used the two Python datasets mentioned in Sec. 2
forevaluation.Oneisthe Typilus‚ÄôsDataset releasedbyAllamanis
et al.[2]; and the other one is ManyTypes4Py released by Mir et
al.[34], with the number of different types in the test set and more
detailed statistics shown in Table 3 and Sec. 2, respectively.
Evaluation Metrics. Following the previous work [ 2,35], we
choose two metrics Exact Match andMatch to Parametric for evalu-
ation.Thetwometricscomputetheratioofresultsthat:1) Exact
Match:completely matcheshumanannotations. 2) Matchto Para-
metric: satisfy exact match when ignoring all the type parameters.
Forexample, List[int] andList[str] areconsideredasmatched
under this metric.
Baseline Approaches. To verify the effectiveness of the pro-
posedHiTyper,wechoosefivebaselineapproachesforcomparison:
1)Anaivebaseline.Itrepresentsabasicdata-drivenmethod.We
buildthisbaselinefollowingthework[ 39],whichmakespredictions
by sampling form the distribution of the most frequent ten types.
2)Pytype[ 45]andPyreInfer[ 40].TheyaretwopopularPython
static type inference tools from Google and Facebook, respectively.
3)Typilus[ 2]andType4Py[ 35].Typilusisagraphmodelthatuti-
lizes code structural information. Type4Py is a hierarchical neural
network that uses type clusters to predict types.
Implementation of HiTyper The entire framework of Hi-
Typer is implemented using Python, which contains more than
9,000linesofcode.Weobtainalltypingrulesandrejectionrules
fromPython‚Äôsofficialdocumentation[ 9]anditsimplementation
CPython2.WeuseWord2Vecmodelfromthegensimlibrary[ 62]
as the embedding when calculating the similarity between two
types.WetraintheWord2Vecmodelbyutilizingalltheclassnames
andvariablenamesinthetrainingsetofTypilus.Thedimension
of the word embeddings and size of the context window are set
as 256 and 10, respectively. Due to the small training corpus for
Word2Vec,wechooseSkip-Gramalgorithmformodeltraining[ 33].
WechooseTypilusandType4Pyastheneuralnetworkmodelfrom
which HiTyper accepts type recommendations. We choose the ex-
act hyper-parameters for Typilus and Type4Py used in the original
papers. We run all experiments on Ubuntu 18.04. The system has a
Intel(R)Xeon(R)CPU(@2.4GHz)with32GBRAMand2NVIDIA
TiTAN V GPUs with 12GB RAM.
4.2 RQ 1: Effectiveness of HiTyper
Weevaluatetheeffectivenessof HiTyperconsideringdifferenttype
categories, including arguments, local variables, and return values.
The results are depicted in Table 2.
2https://github.com/python/cpythonOverallperformance. Thenaivebaselineachieveshighscores
regardingthetop-5exactmatchmetricfordifferenttypecategories,
some of which are even close to the performance of DL models.
Sincethenaivebaselineonlypredictstypeswithhighoccurrence
frequencies in the dataset, the results indicate the challenge ofaccurately predicting rare types. Typilus and Type4Py mitigatethe challenge by using similarity learning and type clusters and
achieve‚àº0.6 regarding the top-1 exact match metric. HiTyper fur-
therimprovesthemetricby11%and15%comparedwithTypilus
and Type4Py, respectively. HiTyper also enhances the top-1 match
toparametricmetricby17%and11%comparedwithTypilusand
Type4Py,respectively.Theimprovementindicatestheeffectiveness
of HiTyper in accurate type prediction. Besides, HiTyper presents
better performance than the respectiveDL models regarding thetop-3,5 metrics, demonstrating that HiTyper infers new results
based on the static type inference rules, instead of just filtering out
or reordering the predictions of DL models.
Type categories. Both Type4Py and Typilus perform better on
the argument category than the return value category, which may
reflect the difficulty of predicting the types of return values. By
building upon type inference rules and TDGs, HiTyper can handle
the complicated type dependencies of return values and thereby
improveType4PyandTypilusby22%and39%,respectively,w.r.t.
the Top-1 exact match metric. HiTyper also slightly meliorates
thepredictionoftheargumentcategoryby7%and5%compared
with Type4Py and Typilus, respectively. The improvement may be
attributed to thetype correction for user-definedtypes. Moreover,
HiTyper outperforms Type4Py by 9% for predicting local variables.
AnswertoRQ1: HiTypershowsgreatimprovement(11% ‚àº15%)
onoveralltypeinferenceperformance,andthemostsignificant
improvement is on return value inference (22% ‚àº39%).
4.3 RQ 2: Prediction of Rare Types
Rare types are defined as the types with proportions less than 0.1%
among the annotationsin the datasets, andwe observe that 99.7%
and 79.0% of rare types are user-defined types in ManyTypes4Pyand Typilus‚Äôs dataset, respectively. Table 4 illustrates the predic-
tionresultsofraretypesanduser-definedtypes.Wecanobserve
that the naive baseline barely infers rare types and user-defined
types. Besides, the performance of Type4Py and Typilus drops sig-
nificantly for the two type categories, which indicates that typeoccurrence frequencies can impact the performance of DL mod-els. HiTyper shows the best performance on predicting the two
type categories. Specifically, for inferring the rare types, HiTyper
outperforms Type4Py and Typilus by 31% and 34%, respectively,
w.r.t. the top-1 exact match metric. Regarding the prediction of
user-definedtypes,HiTyperincreasestheperformanceofType4Py
and Typilus by 69% and 47%, respectively.
AnswertoRQ2: HiTyper greatly alleviates the prediction issue
of rare types faced by DL models by achieving a >30% boost,
taking the advantage of the static type inference component.
2027
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:53:04 UTC from IEEE Xplore.  Restrictions apply. ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA Yun Peng, Cuiyun Gao, Zongjie Li, Bowei Gao, David Lo, Qirun Zhang, and Michael Lyu
Table 4: Comparison with the baseline DL approaches.
Dataset Type Category ApproachTop-1 Top-3 Top-5
Exact
MatchMatch to
ParametricExact
MatchMatch to
ParametricExact
MatchMatch to
Parametric
ManyTypes4PyUser-defined TypesNaive Baseline 0.00 0.00 0.00 0.00 0.00 0.00
Type4Py 0.29 0.29 0.34 0.34 0.36 0.36
HiTyper 0.49 0.49 0.56 0.56 0.58 0.58
Rare TypesNaive Baseline 0.03 0.07 0.08 0.21 0.13 0.35
Type4Py 0.39 0.46 0.45 0.54 0.47 0.57
HiTyper 0.51 0.66 0.56 0.72 0.58 0.73
Typilus‚Äôs
DatasetUser-defined TypesNaive Baseline 0.00 0.00 0.00 0.00 0.00 0.00
Typilus 0.32 0.32 0.40 0.40 0.42 0.42
HiTyper 0.47 0.47 0.56 0.56 0.60 0.60
Rare TypesNaive Baseline 0.00 0.01 0.01 0.03 0.03 0.09
Typilus 0.32 0.43 0.41 0.53 0.43 0.55
HiTyper 0.43 0.55 0.52 0.63 0.56 0.67
Table 5: Comparison with static type inference tools.
DatasetType
CategoryApproachExact #Correct
Match Annotations
ManyTypes4PyArgumentPytype - 0
Pyre Infer 0.96 613
HiTyper 0.94 1060
Return
ValuePytype 0.81 777
Pyre Infer 0.84 662
HiTyper 0.86 2603
AllPytype 0.81 777
Pyre Infer 0.89 1275
HiTyper 0.88 3663 (16918*)
Typilus‚Äôs
DatasetArgumentPytype - 0
Pyre Infer 0.96 543
HiTyper 0.88 983
ReturnValuePytype 0.79 552
Pyre Infer 0.71 484
HiTyper 0.91 2461
AllPytype 0.79 552
Pyre Infer 0.82 1027
HiTyper 0.90 3444
*The number of correct annotations when including local variables.
4.4 RQ 3: Performance of the Static Type
Inference Component
InthisRQ,weevaluatetheperformanceofthestatictypeinferencecomponentinHiTypercomparedwithpopularstatictypeinference
toolsPytype[ 45]andPyre[ 40].TheresultsareshowninTable5.
We only consider the type categories of argument and return value
forcomparison sincePyre andPytypedo notinfer typesforlocal
variables.Weusethemetric numberofcorrectannotations toreplace
the metric match to parametric that is usually used to evaluate DL
models, considering that the results of static inference are exact
and not recommendations.
As shown in Table 5, the exact match scores of all the static
tools are greatly high, and HiTyper achieves the best performance.
The results indicate the effectiveness of the static type inference
component in HiTyper. We also find that there remains ‚àº10% of
the results inconsistent with human annotations in the datasets.By using Python‚Äôs official type checker mypyto check these re-
sults,weobservethatallthetypesannotatedbyHiTyperdonotproduce type errors, which reflects the correctness of the proposed
HiTyper. After manual checking of these inconsistent types, wefind this inconsistency is caused by subtypes, we further discussthem in Sec. 5. Besides, mypy‚Äôs results indicate very few incon-
sistent cases are caused by incorrect human annotations. To test
whether HiTyper can rectify the incorrect annotations, we replace
the original annotations with the results inferred by HiTyper, and
inspectwhethertheoriginaltypeerrorsarefixed.Wefinallycor-
rect 7 annotations on 6 GitHub repositories, including memsource-
wrap [13], MatasanoCrypto [ 1], metadata-check [ 58], coach [ 20],
cauldron[ 54],growser[ 55],andsubmitpullrequeststotheserepos-
itoryowners.TheownersofMatasanoCryptoandcauldronhave
approved our corrections.
WhilePytypeandPyrepresenthighexactmatchscores,thenum-
bers of variables they can accurately infer are small. Table 5 shows
thatHiTypergenerallyoutputs2xargumenttypesand3xreturn
value types compared with them in both datasets, which suggests
HiTyper‚ÄôsstrongerinferenceabilitythanPyreandPytype.Such
improvementsattributetoHiTyper‚Äôsimportanalysisand[ClassIn-
stantiation] rule on supporting the inference of user-defined types,
and inter-procedural analysis on supporting the inference of class
attributes and functions.
Answer to RQ3: Only considering the static inference part, Hi-
Typer still outperforms current static type inference tools by
inferring 2√ó‚àº3√ó more variables with higher accuracy.
5 DISCUSSION
Inference of subtypes. Although HiTyper achieves promising
resultsfortypepredictionandpassesthecheckof mypy,itisstill
unabletoinfersomevariabletypes(around10%).Thefailuremainly
occurs in the inference of subtypes.
1#File: miyakogi.wdom/wdom/node.py
2#Human annotation: AbstractNode
3#Typilus: ForeachClauseNode HiTyper: Node
4def _append_element(self, node: Abstra ctNode) ->
AbstractNode:
5 ifnode. parentNode:
6 node. parentNode.removeChild( node)
7 self. __children.append(node)
8 node.__parent = self
2028
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:53:04 UTC from IEEE Xplore.  Restrictions apply. Static Inference Meets Deep Learning: A Hybrid Type Inference Approach for Python ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA
9 return node
10def _append_child(self, node):
11 if not isinstance (node, Node):
12 raise TypeError
13 ...
14 return self._ap pend_element( node)
Listing 2: An example HiTyper fails to infer.
Listing 2 shows an example for which HiTyper‚Äôs result is in-
consistent withthe original annotationsbut stillpasses the check
ofmypy. The return statement at Line 9 indicates that the type
ofreturnvalueisthesameasthetypeofargument node.Typilus
predicts the type as ForeachClauseNode , which is invalid since it
isnotimportedinthecodeandisfromotherprojectsinthetraining
set.HiTyperinfersthetypeas xml.dom.Node ,becausethefunction
is called by another function named _ùëéùëùùëùùëíùëõùëë_ùëê‚Ñéùëñùëôùëëin the same
file and the caller transmits a variable with type Node. However,
developersannotatethevariableas AbstractNode ,theparenttype.
Such behavior is common in practice and poses a challenge for
accurate type prediction.
6 RELATED WORK
Static and dynamic type inference. Existing static type infer-
encetechniquestowardsdifferentprogramminglanguages,suchas
Java [4], JavaScript [ 21], Ruby [11], Python [ 17] or using different
static analysis techniques [ 5,7,38], and inference tools used in
industry suchas Pytype[ 45], Pysonar2[ 42] andPyre [ 40] arecor-
rectbydesignwithrelativelyhighaccuracyonsomesimplebuiltin
types and generic types, but due to the dynamic feature [ 51]o f
programminglanguages,theycanhardlyhandleuser-definedtypesandsomecomplicatedgenerictypes.HiTyperextendstheinference
abilityofstaticinferencetechniquesbyconductingimportanaly-
sisandinter-proceduralanalysistohandletheuser-definedtypes,
classattributesandfunctionsincode.Dynamictypeinferencetech-niques[
3,36,49]andtypecheckerssuchasMypy[ 37],Pytype[ 45],
PyreCheck[ 40],Pyright[ 41]calculatethedataflowbetweenfunc-
tions and infer types according to several input cases. They can
moreaccuratelypredicttypesthanstatictypeinferencetechniques
but have limited code coverage and large time consumption. Thus,
they encounter difficulties when deployed on large scales of code.
Machine learning in type inference. Traditional static and
dynamic type inference techniques employ rule-based methods
andgivetheexactpredictedtypeforeachtypeslot.Xu etal.[59]
introduceprobabilistictypeinference,whichreturnsseveralcan-
didatetypesforonevariable.Hellendoorn etal.[18]regardtypes
as word labels and build a sequence model DeepTyper to infertypes. However, their model treats each variable occurrence as anew variable without strict constraints. Dash et al.[
6] introduce
conceptual types which divide a single type such as strto more
detailed types such as url,phone, etc. Pradel et al.[39] design 4
separate sequence models to infer function types in Python. They
also add a validation phase to filter out most wrong predictionsusing type checkers. Allamanis et al.[
2] propose a graph model
torepresentcodeanduseKNNtopredictthetypes.Themethodenlarges type set but still fails when the predicted types are notoccurring in the training set. Although DL models have showngreat improvement in this task, it still faces the type correctnessand rare type prediction problem, HiTyper addresses these twoproblems by integrating DL models into the framework of static
inferencesincestaticinferenceisdata-insensitiveandimplemented
on type inference rules that are sound by design. Despite efforts
onPythontypeinference,therearealsoabunchofworkontype
inferenceofotherdynamicallytypedprogramminglanguages.Wei
et al.[57] propose a neural graph network named LambdaNet to
conduct probabilistic type inference on JavaScript programs. Jesse
et al.[22] propose a BERT-style model named TypeBert that ob-
tains better performance on type inference of JavaScript than most
sophisticated models.
7 CONCLUSION
Inthework,weproposeHiTyper,ahybridtypeinferenceframe-
workwhichiterativelyintegratesDLmodelsandstaticanalysisfor
type inference. HiTyper creates TDG for each function and vali-
datespredictionsfromDLmodelsbasedontypingrulesandtype
rejectionrules.Experimentsdemonstratetheeffectivenessof Hi-
Typerintypeinference,enhancementforpredictingraretypes,and
advantage of thestatic type inference component in HiTyper. Hi-
Typerisopen-sourcedathttps://github.com/JohnnyPeng18/HiTyper.
8 ACKNOWLEDGMENTS
Theauthorswouldliketothanktheeffortsmadebyanonymous
reviewers. The work described in this paper was supported bythe Research Grants Council of the Hong Kong Special Admin-istrative Region, China (No. CUHK 14210920 of the General Re-
search Fund), National Natural Science Foundation of China under
projectNo.62002084,Stablesupportplanforcollegesanduniver-
sities in Shenzhen under project No. GXWD20201230155427003-
20200730101839009,andsupported,inpart,byAmazonunderan
Amazon Research Award in automated reasoning; by the United
StatesNationalScienceFoundation(NSF)undergrantsNo.1917924
andNo.2114627;andbytheDefenseAdvancedResearchProjects
Agency (DARPA) under grant N66001-21-C-4024. Any opinions,
findings, and conclusions or recommendations expressed in this
publication are those of the authors, and do not necessarily reflect
the views of the above sponsoring entities.
REFERENCES
[1]aldur. The return value at line 295., 2021.
https://github.com/aldur/MatasanoCrypto/blob/master/matasano/blocks.py.
[2]Miltiadis Allamanis, Earl T. Barr, Soline Ducousso, and Zheng Gao. Typilus:
Neuraltypehints. In Proceedingsofthe41stACMSIGPLANConferenceonPro-
grammingLanguageDesignandImplementation,PLDI2020,page91‚Äì105,New
York, NY, USA, 2020. Association for Computing Machinery.
[3]Jong-hoon (David) An, Avik Chaudhuri, Jeffrey S. Foster, and Michael Hicks.
Dynamicinferenceofstatictypesforruby. SIGPLANNot.,46(1):459‚Äì472,January
2011.
[4]Christopher Anderson, Paola Giannini, and Sophia Drossopoulou. Towards
typeinferenceforjavascript. In Proceedingsofthe19thEuropeanConferenceon
Object-OrientedProgramming,ECOOP‚Äô05,page428‚Äì452,Berlin,Heidelberg,2005.
Springer-Verlag.
[5]ShengChenandMartinErwig. Principaltypeinferenceforgadts. InRastislav
Bod√≠k and Rupak Majumdar, editors, Proceedings of the 43rd Annual ACM
SIGPLAN-SIGACT Symposium on Principles of Programming Languages, POPL
2016, St. Petersburg, FL, USA, January 20 - 22, 2016, pages 416‚Äì428. ACM, 2016.
[6]Santanu Kumar Dash, Miltiadis Allamanis, and Earl T. Barr. Refinym: Usingnames to refine types. In Proceedings of the 2018 26th ACM Joint Meeting on
European Software Engineering Conference and Symposium on the Foundations of
SoftwareEngineering,ESEC/FSE2018,page107‚Äì117,NewYork,NY,USA,2018.
Association for Computing Machinery.
[7]MichaelEmmiandConstantinEnea. Symbolicabstractdatatypeinference. In
Rastislav Bod√≠k and Rupak Majumdar, editors, Proceedings of the 43rd Annual
2029
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:53:04 UTC from IEEE Xplore.  Restrictions apply. ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA Yun Peng, Cuiyun Gao, Zongjie Li, Bowei Gao, David Lo, Qirun Zhang, and Michael Lyu
ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages,
POPL2016,St.Petersburg,FL,USA,January20-22,2016,pages513‚Äì525.ACM,
2016.
[8]Python Software Foundation. Official documentation of Mypy, 2020.
https://mypy.readthedocs.io/en/stable/builtin_types.html.
[9]Python Software Foundation. Official documentation of Python3, 2020.
https://docs.python.org/3.
[10]Python SoftwareFoundation. Cpython. python‚Äôsofficial implementation,2021.
https://github.com/python/cpython.
[11]Michael Furr, Jong-hoon (David) An, Jeffrey S. Foster, and Michael Hicks. Static
typeinferenceforruby. In Proceedingsofthe2009ACMSymposiumonApplied
Computing, SAC ‚Äô09, page 1859‚Äì1866, New York, NY, USA, 2009. Association for
Computing Machinery.
[12]Philip Gage. A new algorithm for data compression. C Users J., 12(2):23‚Äì38,
February 1994.
[13]gengo. Thereturnvalueatline853.,2021. https://github.com/gengo/memsource-
wrap/blob/master/memsource/api.py.
[14]Loukas Georgiadis, Robert Tarjan, and Renato Werneck. Finding dominators in
practice. volume 10, pages 69‚Äì94, 01 2006.
[15] Github. The 2020 state of the octoverse, 2020. https://octoverse.github.com/.
[16]StefanHanenberg,SebastianKleinschmager,RomainRobbes,√âricTanter,and
AndreasStefik. Anempiricalstudyontheimpactofstatictypingonsoftware
maintainability. Empirical Software Engineering, 19, 10 2013.
[17]Mostafa Hassan, Caterina Urban, Marco Eilers, and Peter M√ºller. Maxsmt-based
typeinferenceforpython3. InHanaChocklerandGeorgWeissenbacher,editors,
Computer Aided Verification, pages 12‚Äì19, Cham, 2018. Springer International
Publishing.
[18]Vincent J. Hellendoorn, Christian Bird, Earl T. Barr, and Miltiadis Allamanis.
Deep learning type inference. In Proceedings of the 2018 26th ACM Joint Meeting
on European Software Engineering Conference and Symposium on the Foundations
ofSoftwareEngineering,ESEC/FSE2018,page152‚Äì162,NewYork,NY,USA,2018.
Association for Computing Machinery.
[19]MingzheHu,YuZhang,WenchaoHuang,andYanXiong. Statictypeinference
for foreign functions of python. In 32nd International Symposium on Software
Reliability Engineering, October 2021.
[20]IntelLabs. The return value at line 95. https://github.com/IntelLabs/coach/blob/
master/rl_coach/memories/non_episodic/experience_replay.py, 2021.
[21]Simon Holm Jensen, Anders M√∏ller, and Peter Thiemann. Type analysis for
javascript. In Proceedings of the 16th International Symposium on Static Analysis,
SAS ‚Äô09, page 238‚Äì255, Berlin, Heidelberg, 2009. Springer-Verlag.
[22]Kevin Jesse, Premkumar T. Devanbu, and Toufique Ahmed. Learning type an-
notation: Is big data enough? In Proceedings of the 29th ACM Joint Meeting on
European Software Engineering Conference and Symposium on the Foundations of
SoftwareEngineering,ESEC/FSE2021,page1483‚Äì1486,NewYork,NY,USA,2021.
Association for Computing Machinery.
[23]Jetbrains. Python developer survey conducted by jetbrains and python soft-
ware foundation, 2020. https://www.jetbrains.com/lp/python-developers-survey-
2020/.
[24]Bingyi Kang, Saining Xie, Marcus Rohrbach, Zhicheng Yan, Albert Gordo, Jiashi
Feng,andYannisKalantidis. Decouplingrepresentationandclassifierforlong-
tailed recognition, 2020.
[25]C.M.KhaledSaifullah,M.Asaduzzaman,andC.K.Roy. Exploringtypeinference
techniques of dynamically typed languages. In 2020 IEEE 27th International
Conference on Software Analysis, Evolution and Reengineering (SANER), pages
70‚Äì80, 2020.
[26]Siu Kwan Lam, Antoine Pitrou, and Stanley Seibert. Numba: A LLVM-based
PythonJITcompiler. In 2ndLLVMWorkshopontheLLVMCompilerInfrastructure
in HPC.
[27]TrietH.M.Le,HaoChen,andMuhammadAliBabar. Deeplearningforsource
code modeling and generation: Models, applications, and challenges. ACM
Comput. Surv., 53(3), June 2020.
[28]Jukka Lehtosalo. PEP 589 ‚ÄìTypedDict: Type hints fordictionaries witha fixed
set of keys, March 2019. https://www.python.org/dev/peps/pep-0589/.
[29]Ivan Levkivskyi, Jukka Lehtosalo, and ≈Åukasz Langa. PEP 544 ‚Äìprotocols: Structural subtyping (static duck typing), March 2017.
https://www.python.org/dev/peps/pep-0544/.
[30]Jialun Liu, Yifan Sun, Chuchu Han, Zhaopeng Dou, and Wenhui Li. Deep rep-
resentationlearningonlong-taileddata:Alearnableembeddingaugmentation
perspective, 2020.
[31]RabeeSohailMalik,JibeshPatra,andMichaelPradel.Nl2type:Inferringjavascript
function types from natural language information. In Proceedings of the 41st
InternationalConferenceonSoftwareEngineering,ICSE‚Äô19,page304‚Äì315.IEEE
Press, 2019.
[32]Tomas Mikolov, Ilya Sutskever, Kai Chen, Greg Corrado, and JeffreyDean. Dis-
tributedrepresentationsofwordsandphrasesandtheircompositionality.NIPS‚Äô13,
page 3111‚Äì3119, Red Hook, NY, USA, 2013. Curran Associates Inc.
[33]Tom√°s Mikolov, Ilya Sutskever, Kai Chen, Gregory S. Corrado, and Jeffrey Dean.
Distributed representations of words and phrases and their compositionality.In Christopher J. C. Burges, L√©on Bottou, Zoubin Ghahramani, and Kilian Q.
Weinberger, editors, Advances in Neural Information Processing Systems 26: 27th
Annual Conference on Neural Information Processing Systems 2013. Proceedingsof a meeting held December 5-8, 2013, Lake Tahoe, Nevada, United States, pages
3111‚Äì3119, 2013.
[34]Amir M. Mir, Evaldas Latoskinas, and Georgios Gousios. Manytypes4py: Abenchmark python dataset for machine learning-based type inference. CoRR,
abs/2104.04706, 2021.
[35]Amir M Mir, Evaldas Latoskinas, Sebastian Proksch, and Georgios Gousios.
Type4py:Deepsimilaritylearning-basedtypeinferenceforpython. arXivpreprint
arXiv:2101.04470, 2021.
[36]Yusuke Miyazaki, Taro Sekiyama, and Atsushi Igarashi. Dynamic type inference
forgradualhindley-milnertyping. Proc.ACMProgram.Lang.,3(POPL):18:1‚Äì18:29,
2019.
[37] Mypy. https://github.com/python/mypy/.[38]
ZvonimirPavlinovic,YusenSu,andThomasWies. Dataflowrefinementtype
inference. Proc. ACM Program. Lang., 5(POPL):1‚Äì31, 2021.
[39]MichaelPradel,GeorgiosGousios,JasonLiu,andSatishChandra. TypeWriter:
Neural Type Prediction with Search-Based Validation, page 209‚Äì220. Associationfor Computing Machinery, New York, NY, USA, 2020.
[40] Pyre check. https://pyre-check.org/.[41] Pyright. https://github.com/microsoft/pyright.[42] Pysonar2. https://github.com/yinwang0/pysonar2.[43]
Python. The python ast module, 2021. https://github.com/python/cpython/blob/
3.9/Lib/ast.py.
[44] Python. The typeshed project, 2021. https://github.com/python/typeshed.[45] Pytype. https://github.com/google/pytype.[46]
VikasRaunak,SiddharthDalmia,VivekGupta,andFlorianMetze. Onlong-tailed
phenomena in neural machine translation. In Findings of the Association for
Computational Linguistics: EMNLP 2020, pages 3088‚Äì3095, Online, November
2020. Association for Computational Linguistics.
[47]BaishakhiRay,DarylPosnett,PremkumarDevanbu,andVladimirFilkov. Alarge-
scale study of programming languages and code quality in github. Commun.
ACM, 60(10):91‚Äì100, September 2017.
[48]Veselin Raychev, Martin Vechev, and Andreas Krause. Predicting program prop-
erties from "big code". SIGPLAN Not., 50(1):111‚Äì124, January 2015.
[49]BriannaM.Ren,JohnToman,T.StephenStrickland,andJeffreyS.Foster. The
rubytypechecker. In Proceedingsofthe28thAnnualACMSymposiumonApplied
Computing, SAC ‚Äô13, page 1565‚Äì1572, New York, NY, USA, 2013. Association for
Computing Machinery.
[50]Jiawei Ren, Cunjun Yu, Shunan Sheng, Xiao Ma, Haiyu Zhao, Shuai Yi, and
Hongsheng Li. Balanced meta-softmax for long-tailed visual recognition, 2020.
[51]GregorRichards,SylvainLebresne,BrianBurg,andJanVitek. Ananalysisofthe
dynamicbehaviorofjavascriptprograms. PLDI‚Äô10,page1‚Äì12,NewYork,NY,
USA, 2010. Association for Computing Machinery.
[52]Vitalis Salis, Thodoris Sotiropoulos, Panos Louridas, Diomidis Spinellis, and
DimitrisMitropoulos. Pycg:Practicalcallgraphgenerationinpython. In 43rd
IEEE/ACMInternationalConference onSoftwareEngineering,ICSE2021,Madrid,
Spain, 22-30 May 2021, pages 1646‚Äì1657. IEEE, 2021.
[53]Rico Sennrich, Barry Haddow, and Alexandra Birch. Neural machine translation
ofrarewordswithsubwordunits. In Proceedingsofthe54thAnnualMeetingof
theAssociationforComputationalLinguistics(Volume1:LongPapers),pages1715‚Äì
1725,Berlin,Germany,August2016.AssociationforComputationalLinguistics.
[54]sernst. The return value at line 35., 2021.
https://github.com/sernst/cauldron/blob/master/cauldron/steptest/functional.py.
[55]tomdean. The return value at line 56., 2021.
https://github.com/tomdean/growser/blob/master/growser/handlers/rankings.py.
[56]GuidovanRossum,JukkaLehtosalo,and≈ÅukaszLanga. PEP484‚ÄìTypeHints,
2014. https://www.python.org/dev/peps/pep-0484/.
[57]Jiayi Wei,Maruth Goyal, GregDurrett, and Isil Dillig. Lambdanet: Probabilistic
type inference using graph neural networks. CoRR, abs/2005.02161, 2020.
[58]wtsihgi.Thereturnvalueatline151.,2021.https://github.com/wtsi-hgi/metadata-
check/blob/master/mcheck/metadata/seqscape_metadata/seqscape_metadata.py.
[59]Zhaogui Xu, Xiangyu Zhang, Lin Chen, Kexin Pei, and Baowen Xu. Pythonprobabilistic type inference with natural language support. In Proceedings of
the 2016 24th ACM SIGSOFT International Symposium on Foundations of Software
Engineering, FSE 2016, page 607‚Äì618, New York, NY, USA, 2016. Association for
Computing Machinery.
[60]NingyuZhang,ShuminDeng,ZhanlinSun,GuanyingWang,XiChen,WeiZhang,andHuajunChen. Long-tailrelationextractionviaknowledgegraphembeddings
and graph convolution networks. In Proceedings of the 2019 Conference of the
North American Chapter of the Association for Computational Linguistics: Hu-
man Language Technologies, Volume 1 (Long and Short Papers), pages 3016‚Äì3025,
Minneapolis, Minnesota, June 2019. Association for Computational Linguistics.
[61]≈ÅukaszLanga. PEP589‚Äìtypehintinggenericsinstandardcollections,March
2019. https://www.python.org/dev/peps/pep-0585/.
[62]Radim ≈òeh≈Ø≈ôek and Petr Sojka. Software framework for topic modellingwith
large corpora. pages 45‚Äì50, 05 2010.
2030
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:53:04 UTC from IEEE Xplore.  Restrictions apply. 