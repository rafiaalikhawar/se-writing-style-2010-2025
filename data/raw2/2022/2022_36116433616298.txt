Co-dependenceAwareFuzzing for Dataflow-BasedBigData
Analytics
Ahmad Humayun
ahmad35@vt.edu
Virginia Tech
Blacksburg, Virginia,USAMiryungKim
miryung@cs.ucla.edu
University ofCalifornia,LosAngeles
LosAngeles,California,USAMuhammad Ali Gulzar
gulzar@cs.vt.edu
Virginia Tech
Blacksburg, Virginia,USA
ABSTRACT
Data-intensive scalable computing hasbecomepopular due tothe
increasing demands of analyzing big data. For example, Apache
Spark and Hadoop allow developers to write dataÔ¨Çow-based appli-
cations with user-deÔ¨Åned functions to process data with custom
logic.TestingsuchapplicationsisdiÔ¨Écult.(1)Theseapplications
often take multiple datasets as input. (2) Unlike in SQL, there is
no explicit schema for these datasets and each unstructured (or
semi-structured) dataset is segmented and parsed at runtime. (3)
DataÔ¨Çow operators ( e.g.,join) create implicit co-dependence con-
straints between the Ô¨Åelds of multiple datasets. An eÔ¨Écient and
eÔ¨Äective testing technique must analyze co-dependence among dif-
ferentregionsofmultipledatasetsatthelevelofrowsandcolumns
andorchestrate inputmutationsjointly on co-dependent regions.
Wepropose DepFuzz toincreasetheeÔ¨ÄectivenessandeÔ¨Éciency
offuzztestingdataÔ¨Çow-basedbigdataapplications.Thekeyinsight
behindDepFuzz is twofold. It keeps track of which code segments
operate on which datasets, which rows, and which columns. By
analyzingtheuseofdataÔ¨Çowoperators( e.g.,joinandgroupByKey )
intandemwiththesemanticsofUDFs, DepFuzz generatestestdata
that subsequentlyreachhard-to-reachregionsof the application
code. In real-world big data applications, DepFuzz Ô¨Ånds 3.4√ómore
faults,achieving29% morestatementcoverageinhalfthetimeas
Jazzer‚Äôs, a state-of-the-art commercial fuzzer forJava bytecode. It
outperforms prior DISCtestingby exposingdeepersemantic faults
beyondsimplerinputformattingerrors,especiallywhenmultiple
datasets have complex interactionsthroughdataÔ¨Çowoperators.
CCSCONCEPTS
‚Ä¢Softwareanditsengineering ‚ÜíSoftwaretestinganddebug-
ging.
KEYWORDS
Testing, Fuzzing,Dataanalytics, Provenance,Taint analysis
ACM Reference Format:
Ahmad Humayun, Miryung Kim, and Muhammad Ali Gulzar. 2023. Co-
dependence Aware Fuzzing for DataÔ¨Çow-Based Big Data Analytics. In Pro-
ceedings of the 31st ACM Joint European Software Engineering Conference
andSymposiumontheFoundationsofSoftwareEngineering(ESEC/FSE‚Äô23),
ESEC/FSE ‚Äô23, December 3‚Äì9, 2023, San Francisco, CA,USA
¬©2023 Copyright heldby theowner/author(s).
ACM ISBN 979-8-4007-0327-0/23/12.
https://doi.org/10.1145/3611643.3616298December 3‚Äì9, 2023, San Francisco, CA, USA. ACM, New York, NY, USA,
12pages.https://doi.org/10.1145/3611643.3616298
1 INTRODUCTION
Data-Intensive Scalable Computing (DISC) applications have be-
comeaprevalentwaytoprocesslarge-scaledata.DISCframeworks
likeHadoopMapReduce[ 2]andApacheSpark[ 3]oÔ¨ÄerAPIsthat
contain dataÔ¨Çow operators such as map,join, andgroupByKey for
parallel data processing across thousands of machines. A typical
DISC application builds on a series of dataÔ¨Çow operators in con-
junction with user-deÔ¨Åned functions (UDFs) that are passed as
argumentstothedataÔ¨Çowoperators.Despitethewidespreadusage
of DISC applications, testing remains diÔ¨Écult due to their large
inputsize andthe applications‚Äô complex interactions with data.
Fuzzing is an eÔ¨Äective software testing approach for many com-
plex programs [ 1,7,9,17,28,32,41,49,52]. Fuzzers make small
perturbations (mutations) to inputs to increase the likelihood of
exercising uncovered application logic. Such traditional fuzzing
maytakealongtimetogeneratemeaningfulinputsforDISCap-
plications because a large input data has too many locations to mu-
tate. Therefore, it is necessary to identify which rows and columns
areworthwhiletomutatewhenafuzzerattemptstoreachanew
codelocation.Naivemutationscannotsatisfycomplexinputcon-
straintsfrommixingdataÔ¨Çowoperatorsanduser-deÔ¨Ånedfunctions.
Forinstance, joinconcatenatesrowsfromtwodatasetsthathave
matching values in designated keycolumns. This introduces an
implicit equality constraint between the Ô¨Åelds of multiple datasets.
Consequently, to exercise code inside the UDF func1ofmapin
the code snippet dataset1.join(dataset2).map(func1) ,input
mutationsmustsimultaneouslyoperateonbothdatasets dataset1
anddataset2 toobservetheco-dependenceconstraint i.e.,there
mustexistarowin dataset1 withthesamekeyasthe dataset2 ‚Äôs
Ô¨Årstcolumninorderfor jointoproduceanydataonwhich mapcan
applyfunc1.Mutationsusedinfuzztestingtodayfailtoaccount
for suchco-dependence and thus may not exercise application logic
beyondjoin.This problemis furtherexacerbatedbecause,unlike
SQL, there is no explicitly deÔ¨Åned schema to identify columns, and
the inputs for DISC applications are usually parsedon the Ô¨Çy.
Wepropose DepFuzz,afuzzerthatperforms co-dependenceaware
rowselectionandcolumnmutationwhileensuringthatconstraints
amongmultipledatasets areobserved. DepFuzz combinesrow-level
andcolumn-leveldatatrackingviataintanalysis.Inotherwords,it
identiÔ¨Åeswhichrowsandwhichcolumnsfromwhichdatasetare
operatedbyindividuallinesofapplicationcode.Thisknowledgeof
row-levelprovenancehelpsreducedatasizeforsubsequentfuzzing
iterations,as DepFuzz retainsonlyselectedrowsandmutatesthem,
Thiswork islicensedunderaCreativeCommonsAttribution4.0Interna-
tional License.
1050
ESEC/FSE ‚Äô23, December3‚Äì9, 2023,San Francisco, CA, USA Ahmad Humayun, MiryungKim,andMuhammadAliGulzar
map
map
join
map
map
join
map
join
mapvalairports_and_coords =
airports 
.map(. . .)
valaflights_and_coords =
flights 
.map(. . .)
.join (airports_and_coords)
.map (. . .) 
valflights_and_distances =
flights 
.map(. . .) 
.join(airports_and_coords ) 
.map(. . .) 
.join(aflights_and_coords ) 
.map(. . .)
.collect()1
2 3
4 5
6 7
8
91
2
34
6
5
7
8
9
defdist(dep:Tuple[Float], arr:Tuple[Float]):
Float= {
. . .
// Fault: should be 1-a instead of .1-a
valc =2*math.atan2(math.sqrt(a), math.sqrt( .1-a)) 
(6373.0 * c * 0.621371).toFloat32556, PG0371 , 08-22 07:25 , 08-22 09:50 , KRO, DME, Arrived
22019, PG0240 , 09-03 15:00 , 09-03 02:50 , HMA, DME, Arrived
31522, PG0338 , 09-03 08:55 , 09-03 10:20 , ARH, DME, Arrived
DME, Domodedovo Airport , 37.91 , 55.41 , Moscow
ARH, Talagi Airport     , 40.72 , 64.60 , Moscow
HMA, Khanty Airport     , 69.09 , 61.03 , Yekaterinburg
KRO, Kurgan Airport     , 65.42 , 55.48 , Yekaterinburg
KRO , 32556
HMA , 22019 
ARH , 31522 DME , (37.91 , 55.41)
ARH , (40.72 , 64.60)
HMA , (69.09 , 61.03)
KRO , (65.42 , 55.48)DME , 32556
DME , 22019
DME , 31522
DME , (32556, (37.91 , 55.41))
DME , (22019, (37.91 , 55.41))
DME , (31522, (37.91 , 55.41))KRO , (32556, (65.42 , 55.48))
HMA , (22019, (69.09 , 61.03))
ARH , (31522, (40.72 , 64.60))
32556 , (DME, 37.91 , 55.41)
22019, (DME, 37.91 , 55.41)
31522, (DME, 37.91 , 55.41)32556 , (KRO, 65.42 , 55.48)
22019, (HMA, 69.09 , 61.03)
31522, (ARH, 40.72 , 64.60)
32556 , ((KRO, 65.42 , 55.48) , (DME, 37.91 , 55.41 ))
22019, ((HMA, 69.09 , 61.03) , (DME, 37.91 , 55.41))
31522, ((ARH, 40.72 , 64.60) , (DME, 37.91 , 55.41))
32556 , (KRO, DME, 1901.31)
22019, (HMA, DME, 2165.32)
31522, (ARH, DME,  528.17)
‚®ù ‚®ù
‚®ù12 3
4 5
6 7
8
9
(a) DISC Application in Spark (b) Directed Acyclic Graph (c) Data ProcessingFlights.csv
Airports.csv
Figure 1: A DISC application with a fault in the UDF of step 9,map: (a) code in Scala. (b) the corresponding dataÔ¨Çow graph, and
(c) an illustration of data manipulation in 9 steps. Blue and red colored texts are co-dependent regions identiÔ¨Åed by DepFuzz .
as opposed to the entire dataset during mutational fuzzing with-
out sacriÔ¨Åcing code coverage. By inferring co-dependence relations
among diÔ¨Äerent columns from multiple datasets, it increases the
chanceofgeneratingmeaningfulunstructuredinputsthatcanreach
thelaterstagesoftheapplicationafteroperationssuchas joinand
co-group are used.
DepFuzz instruments the program under test by overriding
dataÔ¨Çow operators and UDF components to capture row-level,
column-level, and dataset-level provenance. This is done by imple-
mentingdynamictainttrackingforUDFsanddataÔ¨Çowoperators.
By leveraging co-dependence aware row selection and column mu-
tations,itgeneratesinputsthatcanreachdeeperregions( i.e.,UDFs
inthe laterstagesofdataÔ¨Çowoperators).
To evaluate DepFuzz, we use 17 DISC applications and measure
(1)statementcoverage,(2)faultdetectioncapability,and(3)fuzzing
speed-up. To assess fault detection capability, we inject faults at
diÔ¨Äerentdepthsintermsoftheprogram‚ÄôsjointdataÔ¨Çowandcontrol
Ô¨Çow graph. We evaluate DepFuzz against two baseline techniques:
Jazzer [24], a coverage-guided greybox fuzzer for Java bytecode
based on LibFuzzer [ 45]; andBigFuzz[52], a greybox fuzzer for
DISC applications. Comparison against JazzerandBigFuzzserves
toassesstheoverallbeneÔ¨Åtintermsoffaultdetectionandspeed-
up, when orchestrating input mutations across multiple datasets
byidentifyingco-dependenceconstraints. DepFuzz achieves87%
statementcoverage,whichis29%and13%morethan Jazzerand
BigFuzz. It also obtains coverage 2.1√óand1.3√ófaster than Jazzer
andBigFuzz,respectively.Sincefaultsappearinginearlierstages
tendtobeeasiertoÔ¨Ånd( e.g.,duetoill-formattedinputs)thanthose
faults appearing in later processing stages, we evenly distributeinjectedfaultsinalldataÔ¨Çowoperatorsforfairness.Theaverage
depthofafaultfoundby DepFuzz is3.7operatorsdeepcomparedto
2.8 and 2.6 by JazzerandBigFuzz, respectively. Our contributions
are as follows:
‚Ä¢Wepresent anewfuzz testingapproachthatleverages rich
provenance information to increase mutational fuzzing‚Äôs
eÔ¨ÄectivenessandeÔ¨ÉciencyforDISCapplications.Thisisthe
Ô¨Årsttestgenerationapproachthatextractsco-dependence
constraints at the level of rows, columns, and datasets fully
automatically withoutrequiringanexplicitschemafroma
user.
‚Ä¢Our evaluation includes an extensive comparison against
two baselines on 17 diÔ¨Äerent benchmark programs for 24
hours each. The results show DepFuzz reaches previously
uncoveredcodefaster,Ô¨Åndsfaultsfaster,andreachesdeeper
code locations oflaterstagesthanexisting fuzzers.
‚Ä¢DepFuzz is built on extended dynamic taint tracking and
analysisofdataÔ¨Çowoperators.Ithascomprehensivesupport
for ApacheSpark-based DISC applicationswrittenin Scala,
anditskeyideageneralizestootherdataÔ¨Çow-basedbigdata
applicationssuchasGoogle‚ÄôsMapReduceorApacheHadoop.
DepFuzz is publicly available at https://github.com/SEED-
VT/DepFuzz [20]
2 MOTIVATING EXAMPLE
This section motivates DepFuzz with a concrete example. Suppose
a data analyst computes the distance traveled by airplanes for each
Ô¨Çightin2017fromtwoinputdatasets: flightscontainsmillions
1051Co-dependence Aware Fuzzing forDataflow-BasedBig DataAnalytics ESEC/FSE ‚Äô23, December3‚Äì9, 2023,San Francisco, CA, USA
Flights Dataset:
Int,String,String,String,String,String,String
20199,PG0320,08-09 06:55,08-09 09:15,MRV,PEE
Airports Dataset:
String,String,String,Float,Float,String
TOF,Bogashevo Airport,Tomsk,85.21,56.38,Krasnoyarsk
Duration:
24h
Figure 2: A sample conÔ¨Åguration Ô¨Åle required by BigFuzz.
The Ô¨Åle contains schemas and seed inputs for the flights
andairports dataset, and a user-speciÔ¨Åed time cut-oÔ¨Ä for
thefuzzingcampaign.
of Ô¨Çights Ô¨Çown worldwide in 2017 and airports contains the geo-
graphiclocationofairports.ThetoptwoboxesinFigure 1(c)show
samplerowsfromeachdataset.The flights datasethasaÔ¨ÇightID,
thedepartureandlandingtimes,thedepartureandarrivalairport
codes, and the Ô¨Çight status, all separated by commas. The airport
dataset maps airport codes to their airport name, longitude and lat-
itude coordinates, and the corresponding city. Figure 1(a) shows a
DISCapplicationwritteninSpark.ItconsistsofdataÔ¨Çowoperators,
suchasmapandjoin,wheresomedataÔ¨Çowoperators,suchas map,
takeauser-deÔ¨Ånedfunction(UDF)asanargument.Forexample,
the9maptakesaUDFthatcomputesdistanceusingtheHaversine
formula, showninthe expandedtextbox.
In1,theanalystextractstheairportcodeandlongitudeandlati-
tudevaluesfrom airport.Fromflights,sheselectsthedeparture
andarrivalairportcodesandtheÔ¨ÇightID,astheÔ¨Årstcolumnand
the second column in 2and3, respectively. She uses joinin4
and5tojointhearrivalanddepartureairportswiththeirlongitude
andlatitudecoordinates. 8joinsthetwodatastreamsusingaÔ¨Çight
ID.9applies the distfunction onthe pairsof latitude-longitude
tuples to compute the Haversine distance.
While writing the Haversine formula, she mistakenly writes
sqrt(.1-a) instead of sqrt(1-a) (text box for 9in Figure 1(a)).
This errorishard-to-spot andsubtleandcauses NaNexceptions.
Limitations of Existing Fuzzers. To reveal such errors, suppose
thatsherunsacommerciallyused,coverage-guidedgreyboxfuzzer,
Jazzer[24]. After a 24-hour fuzzing campaign, even with cover-
age guidance, Jazzer cannot produce an input to reach code be-
yond custom parsing logic at 2, where it persistently triggers the
sameArrayOutOfBoundsException .Jazzerachieves a maximum
statement coverage of 27%. Due to a lack of schema and a lack
of awareness of co-dependent regions, it continues to generate
random strings for the two datasets that cannot pass beyond the
parsingstage( i.e.,mapat2).
Similarly, BigFuzz [52] requires an input schema (as shown
in Figure 2) to apply schema-aware mutations such as changing
thenumericalvalue,changingintegerstoÔ¨Çoat,adding/removing
columns, or changing the delimiter. These mutations help BigFuzz
avoid some trivial parsing errors. Although BigFuzzachieves 98%
statement coverage in 24 hours, it is still unable to trigger the
faultin 9,becausetopassbeyond joinat8,thethreecolumns
(column0of airports andcolumns4and5of flights)musthave
thesame value to satisfy co-dependence constraintsto exercise the
UDF ofmapat9. SinceJazzerandBigFuzzmutate all columns
independently of each other, this three-way constraint is highly
unlikely to be satisÔ¨Åedbytheirmutations.Flights dataset:
-17252,P*34,4GJn50:0k0G,Zu:CSO.9-, D)N,D)N,A]i%e(
-17252,PG04,09-o0‚Äôgc:k7,zq-j01:55", D)N,D)N,]ZTed
Airports dataset:
D)N,SYhkutkl:irp7rS,Gap/ns4,1.64E9,1.30E9,JUSg3sk+
Figure 3: A test case generated by DepFuzz that causes a NaN
exceptionintheprogram inFigure 1
BeneÔ¨Åtsof DepFuzz .Supposethatthedataanalystuses DepFuzz
togeneratenewtestinputs.Shedoesnotneedtoprovideanexplicit
schema and simply provides the current dataset to DepFuzz. At
the end of 24 hours, DepFuzz generates new inputs as shown in
Figure3,leadingtoa NaNerror,reachingthefaultylineinsidethe
corresponding UDF of mapat9.
DepFuzz detects the two sets of co-dependent regions (high-
lighted in blue and red in Figure 3) and mutates them such that
theycanstillsatisfytheimplicitconstraintsimposedbythethree
joinoperators( 4,5,and 8).Therowsinblue( i.e.,-17252)must
beequalsince 8performsaself-join.Theredcells( i.e.,D)N)are
co-dependentbyequalityduetojoin 4and5.Closeinspection
of the applicationexecution on this input shows that variable cis
faultyat 9inFigure 1(b).Thedeveloperspotsthiserroronthesec-
ondlastlineandreplaces sqrt(.1-a) tosqrt(1-a) inaccordance
withthe Haversine formula.
DepFuzz
Dataset 1
Dataset 3
Dataset 2
DISC App.
 Operator Col Row Dataset
Join4 4 0 0
Join4 0 3 1
Join5 5 0 0
Join5 0 4 1
DISC App. 
+ Taint Analysis
+Co-Dependence Monitors
High-quality
Concise Seed Input
Co-dependency Between 
Input RegionsPhase IPhase II
Phase III
(D0,col(4),row(0))
(D1,col(0),row(3))
(D0,col(5),row(0))
(D1,col(0),row(4))
Test Result
I1 ‚úì
I2 ùô≠
‚Ä¶ ‚Ä¶Inputs Output
Phase IV
Fuzzing Campaign
Figure 4:WorkÔ¨Çow of DepFuzz .
3 APPROACH
Thekeycontributionof DepFuzz istodetectco-dependentregions
across multiple datasets and orchestrate input mutations on the co-
dependentregionsaccordingly.Inthissection,weformally deÔ¨Åne
co-dependenceandprovidedetailsofhow DepFuzz detectsthem.
DepFuzz consists of four phases as shown in Figure 4. Phase I
automatically instruments a given DISC application to enable Ô¨Åne-
grainedtaintanalysisatthelevelofrows,columns,anddatasetIDs.
This allows it to track data provenance through dataÔ¨Çow operators
andUDFstocaptureco-dependencerelationships.PhaseIIexecutes
this instrumented program on the entire dataset to capture co-
dependence constraints among multiple input datasets. Phase III
leverages this provenance tracking capability to select a precise
subset of rows from each dataset to use as seeds for subsequent
fuzzing iterations. Phase IV then initiates a fuzzing campaign with
the selected rows from Phase III and applies co-dependenceaware
mutations to expose deeper faults. After reaching a user-speciÔ¨Åed
time limit, DepFuzz outputs asetof test inputs.
Formalizing InputCo-dependence. Co-dependenceisadepen-
dencycreatedbetweenmultipleinputregionsbyanoperation( e.g.,
a dataÔ¨Çow operator or a binary operation that aÔ¨Äects control Ô¨Çow
in UDFs) that operates on such input regions. An input region is
1052ESEC/FSE ‚Äô23, December3‚Äì9, 2023,San Francisco, CA, USA Ahmad Humayun, MiryungKim,andMuhammadAliGulzar
data.filter { row =>
if(row.t_depart.time.after(13:00) )
return true
else
return false
}
.join(‚Ä¶)
.map(‚Ä¶)
.reduceByKey(‚Ä¶)
.map(‚Ä¶)f_id     t_depart       t_land       from    to  
32556 , 08-22 07:25 , 08-22 09:50 ,  KRO  , DME
22019 , 09-23 05:00 , 09-23 02:50 ,  HMA  , DME
31522 , 10-03 08:55 , 10-03 10:20 ,  ARH  , DME
54522 , 05-15 16:55 , 05-16 14:22 ,  LHE  , IAD
(a) The first three rows (shown in red) are dropped by the filter 
condition (shown in green) and therefore do not influence any code 
beyond the filter operation
(b) Co-dependence monitors are attached to each branch in the JDU 
Graph.data.monitoredFilter { row =>
if(monitoredPredicate (row.t_depart.time.after(13:00)))
return true
else
return false
}
.monitoredJoin (‚Ä¶)
.map(‚Ä¶)
.monitoredReduceByKey (‚Ä¶)
.map(‚Ä¶)
Figure 5: The red color rows do not participate in the join
operationsincethe filteroperationremovedthemearlier.
acontiguoussequenceofbytesinaninputdataset.Weformalize
co-dependenceasfollows.Givena DISCapplication,we deÔ¨Åneits
dataÔ¨Çow graph (DFG) with two types of vertices: operators and
datanodes , similar to the traditional DFG representation [ 27]. In
thecaseofDISCapplications, Operators arefunctionsinaprogram
thatoperateondata( e.g.,join()dataÔ¨Çowoperatoror ==inUDFs).
A comprehensive list of trackable operators is shown in Table 1.
Datanodes representdatathatpropagatefromone operatortoan-
other(i.e.,inputandoutputofanoperator).Thus,wedeÔ¨ÅneaDISC
application‚Äôs DFG, /u1D43A,as
/u1D43A=‚ü®/u1D442‚à™/u1D441,/u1D438‚ü©
where/u1D442={/u1D45C1,/u1D45C2,...,/u1D45C/u1D45B}isasetofoperators, /u1D441={/u1D45B1,/u1D45B2,...,/u1D45B/u1D45A}
is a set of datanodes. /u1D438‚äÜ (/u1D442√ó/u1D441) ‚à™ (/u1D441√ó/u1D442)is a set of directed
edges connecting operators with datanodes. An atomic unit of
this DFG has three nodes and two edges i.e.,an operator with
an incoming edge from an input datanode and an outgoing edge
to an output datanode. Furthermore, a datanode /u1D45Bholds data in
the form of a byte sequence /u1D44F1/u1D44F2.../u1D44F/u1D458. Let/u1D437(/u1D45B)be the set of all
possible subsequences of the byte sequence in a datanode /u1D45B,i.e.,
{/u1D44F1,/u1D44F2,...,/u1D44F1/u1D44F2,...,/u1D44F1.../u1D44F/u1D458}. Input datasets of DISC applications are
deÔ¨Åned as /u1D446, a set of initial datanodes which are external inputs to
the DFG. We combine regions in input datasets in /u1D446‚Ä≤, a union of
/u1D437(/u1D45B)acrossallinputdatanodes.
/u1D446‚Ä≤=/uniondisplay.1
‚àÄ/u1D45B‚àà/u1D446/u1D437(/u1D45B)1case class TaintedString(value: String, t: Taints){
2// A Tainted String class
3defconcat(other: String): TaintedString =
4return new TaintedString(value.concat(other), t)
5
6defconcat(other: TaintedString): TaintedString =
7return new TaintedString(
8 value.concat(x.value),
9 union(t,x.t)
10 )
11...// more overloaded operators
Figure 6:Taint analysis enabled String type inScala
Finally,wecharacterizeco-dependencyamonginputregionsasa
setoftuples, /u1D436
/u1D436={(/u1D45C,/u1D445) |/u1D445‚äÜ/u1D446‚Ä≤,‚àÄ/u1D45C‚àà/u1D442}
TheÔ¨Årstelement, /u1D45C,isanoperatorinthedataÔ¨Çowgraph;andthe
secondelement, /u1D445,isasubsetoftheregionsintheinputdatasets
that are co-dependent due to operator /u1D45C. Let/u1D43C(/u1D45C)be the incoming
datatoanoperator /u1D45C.Sinceco-dependencecanonlyoccurbetween
regionsoftheoriginaldatasets,wemustextract /u1D445from/u1D43C(/u1D45C),which
can be any arbitrary byte sequence in the incoming datanode of
operator /u1D45C. To extract such information, we deÔ¨Åne monitors that
are concretely explainedinSection 3.1.
/u1D440/u1D45C:/u1D43C(/u1D45C) ‚Üí P(/u1D446‚Ä≤)
whereP(/u1D446‚Ä≤)isthepowersetof /u1D446‚Ä≤.Amonitor, /u1D440/u1D45C,isanoperator-
speciÔ¨Åc function that takes /u1D43C(/u1D45C)as input and outputs a set of byte
sequences ( i.e.,input regions) from the original input datasets con-
sideredco-dependent w.r.t.givenoperator.Thepreciselogicbehind
this mapping depends on the semantics of the operators, which we
capture using dynamic tainting in DepFuzz. Take for example a
==operationin a.substr(0,5) == b.substr(0,5) .Themonitor,
/u1D440==,shouldyield {a.substr(0,5), b.substr(0,5)} ,resulting
inaco-dependencetuple (==, {a.substr(0,5), b.substr(0,5)
}).Table1listsconcreteexamplesofoperators,theirmonitors /u1D440,
andthe respective mutation strategies.
3.1 PhaseI: Enabling Fine-GrainedTaint
Analysis
Phase I instruments a given input program to enable taint analysis
andto capture co-dependence information.
Enablingtaintanalysisvia instrumentation. DepFuzz usestaint
analysis to identify precise columns and rows in the input datasets
contributing towardsa speciÔ¨Åcintermediateoutput or a Ô¨Ånalout-
put.DepFuzz Ô¨Årst replaces primitive data types with equivalent
taintedtypes.Thetainteddatatypeisatupleofanoriginaltypeand
a list of oÔ¨Äsets representing taints, (Value[T], List[Offset]) .
DepFuzz overrides all APIs of the original data type with taint-
enabled equivalent versions to propagate their taints. For example,
concatintstr1.concat(tstr2) concatenatestwotaintedstrings,
tstr1andtstr2,andattachesanewtaintwiththeuniononthe
two corresponding taints. Figure 6shows the implementation of
concatinTaintedString .DepFuzz providesaninstrumentedver-
sion of data loading APIs that read the input datasets in tainted
types instead of primitive types. Similarly, we instrument APIs for
Int,Float,DoubleandBoolean. Apache Spark‚Äôs textFile API
1053Co-dependence Aware Fuzzing forDataflow-BasedBig DataAnalytics ESEC/FSE ‚Äô23, December3‚Äì9, 2023,San Francisco, CA, USA
valdataset1 = fileWithTaint( "classes" )
valdataset2 = fileWithTaint( "rooms") 
dataset1
.map(s => s.split(regex=",|:")) 
.map {
(code,title,name,section) => 
valkey = code.concat (s":$section")
return(key, title)
} 
dataset2
.map(s => s.split(","))
.join(dataset1)DataTaint 
(Dataset ID,Column,Row)
CS365:Algorithms,John Smith,S1 (0,  0,  0)
CS365:Algorithms,Jane Doe,S2 (0,  0,  1)
CS563: Advanced OS,Jack Joe, S1 (0,  0,  2)Data Taint
CS365: S1,Room 234 (1,0,0)
CS365:S2,Room 121 (1,0,1)
CS563:S1 ,Room 404 (1,0,2)
Data Taint Data Taint Data Taint Data Taint
CS365 (0,0,0) Algorithms (0,1,0) John Smith (0,2,0) S1 (0,3,0)
CS365 (0,0,1) Algorithms (0,1,1) Jane Doe (0,2,1) S2 (0,3,1)
CS563 (0,0,2) Advanced OS (0,1,2) Jack Joe (0,2,2) S1 (0,3,2)
Data Taint Data Taint
CS365:S1 (0,0,0) | (0,3,0) Algorithms (0,1,0)
CS365:S2 (0,0,1) | (0,3,1) Algorithms (0,1,1)
CS563:S1 (0,0,2) | (0,3,2) Advanced OS (0,1,2) Data Taint Data Taint
CS365:S1 (1,0,0) Room 234 (1,1,0)
CS365:S2 (1,0,1) Room 121 (1,1,1)
CS563:S1 (1,0,2) Room 404 (1,1,2)Data Taint Data Taint
CS365:S1 (1,0,0) | (0,0,0) | (0,3,0) Room 234 (1,1,0)
CS365:S2 (1,0,1) | (0,0,1) | (0,3,1) Room 121 (1,1,1)
CS563:S1 (1,0,2) | (0,0,2) | (0,3,2) Room 404 (1,1,2)Dataset1 Dataset2
Figure 7: Taint propagation through a simple dataÔ¨Çow program. Yellow colored highlighted text is the provenance of red
colored textat thebottomleft table.
reads each row as a String, while the taint-analysis equivalent
version reads each row as a TaintedString with a row oÔ¨Äset and
adataset ID.
Taintpropagationatthelevelofrows,columns,anddatasets. Ran-
domlymutatingtheentirerowwilllikelymutatenon-participating
regions in the input. In Figure 1, the second, third, fourth, and sev-
enth columns in the Ô¨Årst dataset are never used by the application
code.DepFuzz implementsanextendedtaintanalysisatthelevel
of a dataset ID, a column oÔ¨Äset, and a row oÔ¨Äset i.e.,(Value[T],
List[(DatasetID, ColOffset, RowOffset)] . For example, in
Figure7,CS363:Advanced OS, Jack Joe, S1 hasataint [0,0,2]
meaning the data is from the Ô¨Årst dataset, the Ô¨Årst column, and the
third row. To reduce the storage overhead of attaching a tainted
object,DepFuzz encodesthethreeoÔ¨Äsetsintoasingle32-bitinteger.
Co-dependence monitors. In order to associatetaints at thelevel
ofbranchesanddataÔ¨Çowoperators, DepFuzz injectsco-dependence
monitorsateachdataÔ¨Çowoperatorandateachbranchpredicate
within UDFs, as shown in Figure 5. For example, this process re-
placesa dataÔ¨Çowoperator joinwithmonitoredJoin andreplaces
if(p)withif(monitoredPredicate(p)) within UDFs. This co-
dependencemonitorinjectionenables DepFuzz toidentifywhich
rowsandcolumnsfromwhichdatasetsdirectlyinÔ¨Çuenceindivid-
ual branching decisions. Branches in a DISC application include
both an explicit control predicate from an ifstatement or a for
loop in user-deÔ¨Åned functions and implicit branches from dataÔ¨Çow
operators ( e.g.,joinandfilter).
3.2 PhaseII: Fine-GrainedTaint Tracking
DepFuzz runs the instrumented, taint-analysis enabled version
fromPhaseIontheoriginaldatasets.Figure 7showshowdatais
trackedthroughthe executionofataint-enabledprogram.
Co-Dependence detection. DataÔ¨Çow operators and UDFs pose im-
plicit and explicit co-dependence constraints. For instance, join
enforcesan implicitconstraint that,for eachoutput row,the keys
of the two joining datasets must be equal. Similarly, if(airporta
== airportb) imposes an explicit constraint that the airporta
andairportb (derived from speciÔ¨Åc rows and columns of input
datasets)areequal.Co-dependencealsoarisesbetweentherowsof the same dataset. For example, aggregation operators such as
reduceByKey andgroupByKey result in co-dependence where one
or more rows must have the same key to have an output row
with the same key. Our insight is that while random mutations
are unlikely tosatisfy co-dependence constraints by chance, coor-
dinatedmutationstospeciÔ¨ÅcrowandcolumnoÔ¨Äsetsthatrespect
co-dependency constraintsare likely to reachdeeper code.
Exactly how taints are transformed into co-dependence con-
straints depends on the monitored dataÔ¨Çow operator type. For ex-
ample, for join, the key columns of the two participating datasets
must be the same (equality). For an ifcondition if(column0 >
column5) ,the co-dependence isa"greater than" relationship.
Oncetheinstrumentedapplication‚Äôsexecutionontheoriginal
datasets completes, DepFuzz consolidates co-dependence infor-
mation,documentingeachmonitor‚Äôsrelativepositionintermsof
dataÔ¨Çow operatordepth andthelistoftaintscontainingoÔ¨Äsetsat
thelevelofrows,columns,anddatasetIDs.Forexample,inFigure 1,
join 4hasadepthoftwoandformsaco-dependencebetweencol-
umn5of flights andcolumn0of airports whichactasthekeys
forthejoin.Notethat DepFuzz candetecttransitiveco-dependence
when there are overlappingconstraints acrossmultipleoperators.
For example, Figure 1has a three-way co-dependence among three
inputregionssince airports column 0overlaps with join 5.
3.3 PhaseIII:RowSelectionforData Size
Reduction
Tospeedupfuzzing, DepFuzz identiÔ¨Åesasmallsubsetofdatarows
thatretainthesamebranchcoverageastheoriginaldataset.This
reduces large-scale datasets to a set of seed inputs that are small
enoughforiterativefuzzing.Becausetheoriginalinputdatamay
beverylargewithmillionsofrows,thisstepsigniÔ¨Åcantlyreduce
thescopeofpotentiallocationstomutate,increasingeÔ¨Éciency.For
eachbranch, DepFuzz reducestheoriginalinputdatasetstoasubset
of rows reaching that particular branch. It then consolidates the
correspondingrowsforallbranches.Figure 5(a)showsanexample
of how row selection creates a smaller, eÔ¨Äective seed. A filter
operatorremoves allÔ¨Çights departingbefore 13:00onagivenday.
Therefore, the rows highlighted in red will not inÔ¨Çuence any code
1054ESEC/FSE ‚Äô23, December3‚Äì9, 2023,San Francisco, CA, USA Ahmad Humayun, MiryungKim,andMuhammadAliGulzar
Table1:Summaryofhoweachclassofoperatorsproducesco-dependentregionsintheinputdataset.Forsimplicity,weuse
row[1].col[3] as ahuman-readablerepresentation ofinput byte region /u1D44F/u1D456,.../u1D44F/u1D457,where0</u1D456</u1D457</u1D460/u1D456/u1D467/u1D452(/u1D451/u1D44E/u1D461/u1D44E/u1D460/u1D452/u1D461)
OperatorClass Sample Operators Example of IdentiÔ¨Åed Constraint Mutationstrategy
Fusionsdata1.join(data2)
data1.intersection(data2)
data1.cogroup(data2)/u1D440/u1D457/u1D45C/u1D456/u1D45B({/u1D451/u1D44E/u1D461/u1D44E1,/u1D451/u1D44E/u1D461/u1D44E2}).
Possible outputof /u1D440/u1D457/u1D45C/u1D456/u1D45B:
{data1.row[1].col[3], data2.row[23].col[0]}
{data1.row[31].col[3], data2.row[52].col[0]}
Co-dependencetuples:
(==, {data1.row[1].col[3], data2.row[23].col[0]})
(==, {data1.row[31].col[3], data2.row[52].col[0]})Anymutationapplied to data1.row[1].col[3]
must alsobeapplied to data2.row[23].col[0] .
Ifno rows with matchingkeysexists,selecta
rowfrom data1andcopy data1.col[3] to
data2.col[0] .
Aggregationsdata.aggregateByKey(udf)
data.reduceByKey(udf)
data.groupByKey()
data.countByKey()/u1D440/u1D45F/u1D452/u1D451/u1D462/u1D450/u1D452/u1D435/u1D466.alt/u1D43E/u1D452/u1D466.alt ({/u1D451/u1D44E/u1D461/u1D44E}).
Possible outputof /u1D440/u1D45F/u1D452/u1D451/u1D462/u1D450/u1D452/u1D435/u1D466.alt/u1D43E/u1D452/u1D466.alt :
{data.row[2].col[2],
data.row[43].col[2],
data.row[63].col[2]}
Co-dependencetuple:
(==, {data.row[2].col[2],
data.row[43].col[2],
data.row[63].col[2]})Anymutationapplied to data[row=2,col=2]
must alsobeapplied to data[row=43,col=2] .
Duplicate rows andapply same mutationto
key columnsofduplicates.
Filters data.filter(col0 > col5)/u1D440/u1D453/u1D456/u1D459/u1D461/u1D452/u1D45F({/u1D451/u1D44E/u1D461/u1D44E}).
Possible outputof /u1D440/u1D453/u1D456/u1D459/u1D461/u1D452/u1D45F:
{data.row[23].col[0], data2.row[23].col[5]}
{data.row[31].col[0], data2.row[31].col[5]}
Co-dependencetuples:
(>, {data1.row[23].col[0], data2.row[23].col[5]})
(>, {data1.row[31].col[3], data2.row[31].col[5]})Anymutationapplied to data.col[0] and
data.col[5] must ensurethat thereis a
true andfalserowfor thepredicate.
UDF Operatorsif(a.contains(b))
if(a != b)
if(a > b)/u1D440/u1D450/u1D45C/u1D45B/u1D461/u1D44E/u1D456/u1D45B/u1D460({/u1D44E,/u1D44F}).
Possible outputof /u1D440/u1D450/u1D45C/u1D45B/u1D461/u1D44E/u1D456/u1D45B/u1D460:
{data.row[1].col[0], data2.row[1].col[2]}
Co-dependencetuples:
(/u1D450/u1D45C/u1D45B/u1D461/u1D44E/u1D456/u1D45B/u1D460 , {data1.row[1].col[0], data2.row[1].col[2]})Anymutationapplied to data.col[0] and
data.col[2] must ensurethat string a
containsbfor some mutations. Itmust also
ensureitoccasionallycreates inputs that
violate this.
beyond the Ô¨Årst filter.DepFuzz thus retains only the green row
inthe seedinputfor subsequent fuzzingiterations.
3.4 PhaseIV:Co-Dependence AwareMutation
Phase IV performs a grey-box fuzzing campaign by designing new
mutations that target various co-dependence types. The output of
DepFuzz isalistoferrorsandtestinputsrevealingthoseerrors.Dif-
ferentfromstandardgrey-boxfuzzing, DepFuzz prioritizes where
to apply input mutations based on Ô¨Åne-grained taint tracking at
thelevelofrows,columns,anddatasets. DepFuzz designsanovel
inputmutationstrategythatmaintainsco-dependency.Basedon
the co-dependent constraints, we categorize dataÔ¨Çow operators
intofourclasses: Fusions,Aggregations ,Filters,andUDFOperators .
Table1summarizes mutation strategies for eachclass ofoperator.
‚Ä¢Forfusion operators likejoin,DepFuzz applies the same set
of mutations on the key columns of the two joining datasets
toensureequality.InFigure 1(c),when DepFuzzmutatesKRO
inrow0ofthe flightsdataset,itappliesthesamemutations
toKROinrow3of airports ,ensuring anon-empty output
forjoin.
‚Ä¢Foraggregation operators likereduceByKey ,DepFuzz dupli-
catesarowandappliesthesamesetofmutationsonthekey
columnofthoserows,ensuringatleast2rowsineachout-
put group. Suppose if reduceByKey is applied on the fourth
column of flightsin Figure 1.DepFuzz duplicates a row
>1 times and applies the same mutation on the key of the
originalandduplicatedrows.‚Ä¢ForÔ¨Ålter operators likefilter,DepFuzz applies mutation
on the columns used in the Ô¨Åltering predicate. In case of
filter(data.col[0]) >data.col[1] ,DepFuzz can cre-
ate at least one row where this predicate can be true or at
leastone rowwhere this predicate isfalse.
‚Ä¢ForUDF operators likemapandflatMap that take UDFs
asarguments, DepFuzz handlescontrolpredicatesinuser-
deÔ¨Ånedfunctionssimilarto filter.Forexample,inthecase
ofa.contains(b) ,DepFuzz identiÔ¨Åestheprovenanceofthe
stringsaandbasdata.col[0] anddata.col[3] respec-
tively.DepFuzz thenenforcesthetruepathforthiscondition
byembedding binaduringthe mutation process.
4 EVALUATION RESULTS
Weevaluate DepFuzz onfourcriteria:codecoverage,faultdetec-
tion,faultdepth,andtestingspeed,transcribedintotheresearch
questionsbelow.
RQ1:WhatisDepFuzz‚Äôstestcoveragecomparedtobaselinefuzzers?
RQ2:Howmanyerrorscan DepFuzz detectcomparedtobaselines?
RQ3:CanDepFuzz detecterrorslocatedin deepercode regions?
RQ4:How much overhead does DepFuzz‚Äôs instrumentation incur?
RQ5:DoesDepFuzz achieve code coveragefaster thanbaselines?
Benchmarks. Existing dataÔ¨Çow benchmarks like TPC-DS [ 5] or
Big Data Benchmark [ 4] are purely performance benchmarks writ-
teninSQLandthereforedonotcontainUDFsandnon-relational
dataÔ¨Çow operators.In contrast,the subjectprograms introduced
by prior work on fuzzing in DISC only operate on a single dataset,
omitting an entire class of operators related to real-world multiple
1055Co-dependence Aware Fuzzing forDataflow-BasedBig DataAnalytics ESEC/FSE ‚Äô23, December3‚Äì9, 2023,San Francisco, CA, USA
Table2:Subjectprogramsusedin DepFuzz ‚Äôsevaluation.Allprogramsrepresentreal-worldDISCusecasesandareadopted
frompriorwork. The data andcodecharacteristics ofbenchmarkprograms are alsoshown.
IDProgram Description Datasets # of
Opt.Max
DepthTotal
RowsOperatorsUsed
P1WebpageSegmentation [ 10,15] Findoverlapping UI components ona webpage 2 9 6 1M map,groupByKey ,join,filter
P2Customer Rewards[ 8] Findthetop-3 customers w.r.t purchase history 2 9 8 2M map,groupByKey ,join,filter,sortBy
P3Flight Distance [ 6] Computedistance travelledbya givenÔ¨Çight 2 9 5 500Kmap,join
P4BusDelays [ 35] Identify busroutesthataredelayedfrequently 2 9 8 2M flatMap,join,reduceByKey ,filter
P5CommuteType[ 19] Identify thetransportation typeusedona trip 2 4 4 1M map,mapValuesaggregateByKey
P6WordCount [ 19] Findthefrequency ofwords 1 2 2 1M map,flatMap,reduceByKey
P7Delivery Faults [ 36] Identify vendor sets leading tofaulty deliveries 1 5 5 1M map,groupByKey ,filter
P8ExternalCall [ 52] Findthefrequency ofwords 1 3 3 1M map,flatMap,reduceByKey ,filter
P9FindSalary [ 52] Totalincomeofindividualsearning ‚â§$300weekly 1 4 4 1M map,filter,reduce
P10StudentGrade [ 52] List ofclasseswith morethan 5 failingstudents 1 4 4 1M map,reduceByKey ,filter
P11MovieRating[ 19] Total numberofmovieswith rating ‚â•4 1 3 3 1M map,reduceByKey ,filter
P12InsideCircle [ 52] Check whetherthepoint (x,y)isina circle 1 2 2 1M map,filter
P13MapString [ 52] String mapping 1 1 1 1M map
P14NumberSeries[ 52] Findthenumbers whose 3n+1 series‚Äô length is25 1 3 3 1M map,filter
P15AgeAnalysis [ 52] Total numberofpeople with diÔ¨Äerent age ranges 1 3 3 1M map,filter
P16IncomeAggregation[ 19] Averageincomeperage range ina district 1 5 5 1M map,mapValuesfilter ,reduceByKey
P17LoanType[ 52] The countofloantypewithin a region 1 2 2 1M map
dataset analytics. Therefore, we evaluate DepFuzz on 17 unique
big data applications accumulated from nearly all publicly avail-
able prior work on DISC testing [ 19,52], DISC debugging [ 48],
and real-world DISC use cases [ 6,8,10,15,35,36]. Collectively,
our benchmark programs comprise (1) a variety of dataÔ¨Çow opera-
tors transformation (Ô¨ÇatMap, map), fusion (join), and aggregation
(reduce, group) operators, (2) UDFs, which are integral to DISC
applications,and(3)bothsingleandmultipleinputdatasets,which
are criticalfor practical data analysis.
ThecompletelistofsubjectprogramsisshowninTable 2.Forex-
ample,P7[ 36]identiÔ¨Åesthetypeoftransportationusedtoperform
thedailycommutes i.e.,bus,car,orwalk.Itconsolidatesinforma-
tion on trips from two datasets to Ô¨Ånd the starting and destination
zip codes, the distance traveled for the trip, and the time it took to
coverthisdistance.AnotherprogramP2isinspiredbyacommer-
cial case study of Apache Spark [ 8]. It analyzes customer purchase
history and rewards eligible customers (more than three instances
of $100 spending in the current year) with coupons valued propor-
tionally to spending. This is a multi-dataset program that joins the
customerinformationtablewiththepurchasehistorytable.Overall,
thebenchmarkprograms‚Äôsizeiscomparabletoreal-worldindustry
DISC applications [ 50], which are in the order of hundreds of LOC
but closed-sourced.
Baselines. Wecompare DepFuzz againsttwobaselines:(1)astate-
of-art schema-aware DISC application fuzzer, BigFuzz[52]; and (2)
themostadvancedcommercial-gradecoverageguidedfuzzerfor
the JVM, Jazzer[24], developed in part by Google. We compare
againstthesebaselinesbecausetheyarethestate-of-the-artfuzzers
forDISCapplicationsandJVM-basedapplications,respectively.We
usescoverage [43] to monitor Scala statement coverage of the
applications. We provide BigFuzzwith a seed input constructed by
randomly sampling a row fromthe dataset, along with a schema of
thedatasetasintheoriginalpaper.For Jazzer,wewriteinterfacing
code that converts the random byte stream generated by Jazzer
intoformatteddatasets expectedbythe DISC application.Evaluation Environment. We run each tool for up to 24 hours,
whichisastandardexperimentalsettingforfuzzingbenchmarks,
and measure statement coverage (%), cumulative error detection
(%), and error depth (# of operators) in the dataÔ¨Çow graph of the
benchmark programs. We perform these experiments on a 13-node
clustercomputingenvironmentwith112coresat3.10GHz,52TB
storage,and832GBmemory.WerunourexperimentsonApache
Spark 3.0 andHDFS 2.7.
4.1 TestCoverage Against Baseline
Figure8showshowcumulativestatementcoverageincreasesthrough-
out the 24-hour fuzzing campaign with DepFuzz and the two
baselines.Y-axisrepresentsthepercentageofstatementcoverage
achieved, and the X-axis represents the time elapsed in seconds.
DepFuzz signiÔ¨Åcantlyoutperformsbaselinesforprogramsingest-
ingmultipleinputdatasetsandcontainingfusion,aggregation,and
Ô¨Ålter operators) such as P1-P5. For programs that ingest only a sin-
gledataset( i.e.,P6-P17),DepFuzz showsslightlybetterperformance
onaverageinterms ofcoverage.
Program P1‚Äôs seventh operator is join, where each dataset‚Äôs
key is a concatenation of three columns. Since there are six co-
dependentcolumnsrelatedbythisequalityandbothbaselinefuzzers
mutateeachofthesixcolumnsindependentlyoftheothers,they
fail to generate even a single input with matching keys to pass
thisjoin. Even with its schema-aware mutations, BigFuzzonly
achieves28%coverage.Similarly, Jazzerstruggles topush beyond
20%coveragewithitsbyte-levelmutations. DepFuzz managesto
capturetheco-dependencebetweensixcolumnscreatedby join.It
immediately satisÔ¨Åes the constraints early in the fuzzing campaign
through tailored mutations for fusion operators. DepFuzz achieves
99%coveragewithin 24 hours of fuzzing.
In P7, we observe a drastic increase in statement coverage in
the Ô¨Årst iteration of DepFuzz, compared to the baselines. This
program uses an aggregation operator, groupByKey , followed by
filterthat requires a minimum number of rows with the same
key to exercise the code after filter. Mutations that randomly
1056ESEC/FSE ‚Äô23, December3‚Äì9, 2023,San Francisco, CA, USA Ahmad Humayun, MiryungKim,andMuhammadAliGulzar
100102104020406080100StatementCoverage(%)P1
100102104020406080100P2
100102104020406080100P3
100102104020406080100P4
100102104020406080100P5
100102104020406080100P6
100102104020406080100StatementCoverage(%)P7
100102104020406080100P8
100102104020406080100P9
100102104020406080100P10
100102104020406080100P11
100102104020406080100P12
100102104020406080100
Time (s)StatementCoverage(%)P13
100102104020406080100
Time (s)P14
100102104020406080100
Time (s)P15
100102104020406080100
Time (s)P16
100102104020406080100
Time (s)P17DepFuzz BigFuzz Jazzer
Figure 8:Statement coverage ofthree tools on 17benchmarkprograms during24hours
duplicate any row are unaware of the aggregation‚Äôs key column.
Thus, baseline fuzzers do not generate the required rows to pass
throughfilter.DepFuzz identiÔ¨Åes the groupByKey along with
theinputcolumnthatinÔ¨Çuencesthekey.Itthenduplicatesinput
rowstosatisfythejointconstraintimposedby aggregation and
filter.DepFuzz‚ÄôssuperiorperformanceinP2-P4canbeattributed
to similar reasons.
DepFuzz also performs better for single dataset applications P6-
P17thatdonothaveanyfusionoperators(duetoonlyoneinput
dataset),andtheiraveragedataÔ¨Çowoperatordepthisonlythree.
DepFuzz performs140KfewerbutmoreeÔ¨Äectivefuzzingiterations
thanbaselinesonaverageduetothehigheralgorithmiccomplexity
ofapplyingco-dependentmutations.Thebaseline Jazzerperforms
better in P16 because some statements in the program are only
reachable on one speciÔ¨Åc input value. The chances of reaching such
statements ( e.g.,stmt1 in if(45<x<60){stmt1} ) are purely ran-
dom. Thus, the technique with a higher number of iterations is
more likely to reach these statements. In P16, Jazzerperforms
twice as many iterations as DepFuzz, which increases its likeli-
hood of arbitrarily changing the input row from 90024,28,10990
to90024,46,10990, achieving additional statement coverage. In a
24-hour fuzzing campaign, DepFuzz achieves 29% higher coverage
thanJazzerand13%higher coveragethan BigFuzz.
To answer RQ5, we evaluate how quickly DepFuzz achieves
coverage compare to baselines by performing curve Ô¨Åtting with/u1D466.alt=/u1D45A/u1D465astheobjectivefunctiononthecumulativecoveragegraphs
since the gradientofthis line representsthe average rate of gain
of coverage over the course of the entire campaign. We Ô¨Ånd that
DepFuzz is1.3√ófasterthan BigFuzzand2.1√ófasterthan Jazzer
interms ofthe coverageincreaserate.
4.2 FaultDetection
We measure the fault detection capability of DepFuzz compared
tothebaselines.Forthisexperiment,ineachsubjectprogram,we
injectone fault ateachdepth ofa dataÔ¨Çow graphand then record
the number of faults. We deÔ¨Åne a fault‚Äôs depth as the number of
dataÔ¨Çow operators an input row has to go through before reaching
a faulty statement. For example, if a fault is seeded in a UDF /u1D453,
where/u1D453isanargumentto /u1D45B/u1D461‚ÑédataÔ¨Çowoperator,thefaultisseeded
at depth/u1D45B. For example, the fault in 9-Figure1has a depth of Ô¨Åve
becausethereareÔ¨ÅvedataÔ¨Çowoperatorsbeforethefaultycode.We
count only the faults triggered from correctly-formatted inputs, as
Jazzergenerates a massive number of ill-formatted inputs that all
lead to parsing errors such as ArrayIndexOutOfBound exception
fromsplit(",")[k] due to missing k/u1D461‚Ñécolumn in input data.
Parsing errors are caused by processing ill-formatted inputs in
a program. These errors normally appear in the Ô¨Årst operation
of a DISC application that takes a raw, unstructured input and
parsesitintoindividualdataÔ¨Åeldsandtheirtypes e.g.,keysand
1057Co-dependence Aware Fuzzing forDataflow-BasedBig DataAnalytics ESEC/FSE ‚Äô23, December3‚Äì9, 2023,San Francisco, CA, USA
100101102103104020406080100FaultsDetected(%)(c)TotalAverage
100101102103104020406080100
Time (s)(b)Single DatasetAverage
100101102103104020406080100(a) MultiDataset AverageDepFuzz Jazzer BigFuzz
Figure 9: Cumulative number of faults detected during 24 hours averaged across 17 programs. (b) shows the average for P5-P17
which ingest asingledataset, and(c)showsaverage forP1-P4which takemultiple datasetsas input.
10110210310412345678
Time (s)DataÔ¨ÇowDepthDepFuzz BigFuzz Jazzer #ofFaults: 35198
Figure10: DepthvsTimefor allfaultsdetectedby DepFuzz
andbaselines./circlemultiplytext.1denotescentroidsofeachtool. DepFuzz has
more points near the top left corner, which means it detects
deeperfaultsfasterthanbaselines. DepFuzz Ô¨Åndsmorefaults
than baselines.
values, similar to the Ô¨Årst mapapplied on dataset1 anddataset2
in Figure 7. These errors do not appear if the input data format
conformstotheprogram‚Äôsparsinglogic.Weevaluatefaultdetection
on two levels: 1) the total number ofunique faults detected and 2)
the depth within the dataÔ¨Çow graph at which a fault is detected.
Notethat eachdataÔ¨Çowoperator takes aUDF as an argument.
Fault Injection. We manually inject faults into the subject pro-
gramsbyrandomlyreplacingarithmeticoperators,binaryopera-
tors,andconstants[ 26].Forexample, sqrt(1-a) becomessqrt(.1-a)
afterinjectingafault,whichcanleadto NaNerror.Similarly,replac-
ingoperatorslike +with/willinjectadivision-by-zeroerror.Prior
work on Apache Spark recognizes the presence of such faults in
real-worldDISCapplications[ 19].Wealsoaddfaultsbyemploy-
ing a range check that throws RuntimeException if a particular
column value falls within a narrow range. For example, a faulty
program throws an exception if a string value in a column starts
with"&%".
Faultinjectioniswidelyusedinpracticetoevaluatenewtesting
techniques. Automated fault injection tools such as LAVA [ 14] and
Apocalypse [ 44] devise a set of principles that mimic properties
of real-world faults. When injecting faults, we also follow these
principles,whichare as follows.
‚Ä¢Rare:Theinjectedfaultsmanifestforonlyasmallfraction
of possible inputs. We inject a fault that is triggered if theÔ¨Årst column starts with the characters "&%". The number of
inputs that can trigger this fault is ‚âà25618. Assuming all
inputsareequallylikely,theprobabilityofrandommutations
triggeringthisfaultis ‚âà0.00002,assumingtherowlength
of 20 ASCII characters. Note that this is an overestimate
since,dependingonwherethefaultisinjected,severalother
control Ô¨Çow and data Ô¨Çow criteria will need to be met for
theexecutiontoreachtheinjectedfault,further restricting
the spaceofinputsthat can trigger this fault.
‚Ä¢Uncorrelated: Findingoneinjectedfaultneitherincreasesnor
decreasesthe likelihoodof Ô¨Åndingany otherfaults.
‚Ä¢Reproducible: Thefaultsaredeterministicandreproducible
inthat asingleinputcan prove the existenceof afault.
‚Ä¢Fair:The faults are injected in locations that can be feasibly
reachedbyanautomatedtechnique.Forexample,nofault
is guarded by a branch that requires solving an infeasible
mathematicalproblem,suchasfactoringalargeintegerinto
its constituent primes.
Intotal,weinject45faultsacross17benchmarkprograms.Sincethe
locationofafaultmayfavorcertaintechniques,weensurefairness
infaultinjectionbyinjectingafaultateachdataprocessingstep
inevery program.
Fault Detection. Figure9shows the cumulative average number
offaultsdetectedonthesubjectprograms.Wereportasummaryof
all detected program faults in Table 3. In Figure 9, the Y-axis repre-
sentsthepercentageofcumulativefaultsdetected,andtheX-axis
representsthefuzzingduration. DepFuzzoutperformsbaselinetech-
niques in terms of fault detection. For example, the majority of the
inputsproducedby JazzerhaveaninsuÔ¨Écientnumberofcolumns,
whichleadstodataparsingerrors( i.e.,ArrayIndexOutOfBound ex-
ception)afterthe splitoperation.Similarly,inP1, BigFuzzspends
over 50% of its iterations triggering the same four parsing faults
in the Ô¨Årst UDF, causing only NumberFormatException . Table3
lists the total faults detected by DepFuzz,BigFuzz, andJazzer.
Onaverage, DepFuzz Ô¨Ånds3.4√ómorefaultsthan Jazzerand84%
morefaultsthan BigFuzzduetoco-dependenceawaremutations.
DepFuzz‚Äôs strengths in fault detection are noticeable inP1-P4 and
P7,whereco-dependenceawaremutationshelp DepFuzz gopast
the fusionoperators andreachdeeper dataÔ¨Çowoperators.
Detecting Deeper Program Faults. We stratify the injected faults
bytheirdataÔ¨Çowoperatordepth.Figure 10showsascatterplotthat
1058ESEC/FSE ‚Äô23, December3‚Äì9, 2023,San Francisco, CA, USA Ahmad Humayun, MiryungKim,andMuhammadAliGulzar
Table3:Runningtimeoftheoriginalsubjectprogramand
the instrumented program with taint analysis along with
total errors detected by eachtool.
Program Application ExecutionTime Faults Detected
Original Instrumented Overhead DepFuzz BigFuzz Jazzer
P1 9.4 36.2 3.9 7 0 0
P2 15.6 149.2 9.6 3 0 0
P3 54.8 768.4 14.0 3 2 0
P4 11.2 27.8 2.5 1 1 0
P5 17.4 174.2 10.0 1 1 0
P6 7.0 13.0 1.9 1 1 0
P7 7.0 17.6 2.5 1 0 0
P8 7.0 12.8 1.8 2 2 1
P9 5.8 6.6 1.1 2 2 1
P10 6.8 12.0 1.8 3 2 3
P11 6.6 12.0 1.8 4 1 0
P12 4.8 5.8 1.2 1 1 0
P13 5.0 5.6 1.1 1 1 1
P14 5.0 6.0 1.2 2 2 2
P15 5.0 5.8 1.2 1 1 0
P16 6.8 8.0 1.2 1 1 0
P17 4.8 6.0 1.2 1 1 0
TotalFaultsDetected 35 19 8
visualizesthedepthofthefaultsacross17programs.Thetopofthe
plot represents deeper, hard-to-reach faults, whereas the bottom
represents faultsinthe initialphasesofthe application.
The scatter plot shows that, overall, DepFuzz Ô¨Ånds faults that
reside at a deeper dataÔ¨Çow depth. In P1, for instance, DepFuzz
Ô¨Åndsatotalof7faultsacrossthreediÔ¨ÄerentdataÔ¨Çowdepths(3,4,
and 6), whereas both BigFuzzandJazzerare unable to Ô¨Ånd any.
Theplotalsoshowsthat DepFuzz isconsistentlyfasteratÔ¨Ånding
deepfaultsthanbaselines.Forexample,inP3,thedeepestbugis
triggeredby BigFuzzalittleoveranhourintothefuzzingcampaign,
whereasDepFuzz Ô¨ÅndsitwithintheÔ¨Årstminute.Althoughthetime
diÔ¨Äerence is smaller for single dataset programs (P6-P17), a similar
pattern can be observed. For example, in P14, DepFuzz Ô¨Ånds the
deepestbugwithintheÔ¨Årsttwominutes,whereas BigFuzztakes
over13minutes.Figure 10alsoshowsthecentroidswith/circlemultiplytext.1foreach
tool. The size of/circlemultiplytext.1represents the number of detected faults. Note
thatthegapsbetweenthecentroidsarelargerthantheyappeardue
to the log-scaled x-axis. On average, the deepest faults detected by
DepFuzz are 1.1operatorsdeeperthan BigFuzzand0.9operators
deeper comparedto Jazzer.
4.3DepFuzz ‚ÄôsInstrumentationOverhead
DepFuzz enables dynamic taint analysis in a trial execution ( i.e.,
running an instrumented program on the original input data) to
identifyco-dependencerelationships.Notethatthisisa one-time
overheadfortheÔ¨Årstrun andisnotarecurringoverheadforeach
fuzzing iteration because its goal is to infer co-dependence con-
straints from existing data.
Table3shows the time diÔ¨Äerence between an instrumented run
andanuninstrumentedrunontheoriginalinputdatasets.Forin-
stance,inprogramP1,thetrialexecutionfordynamictaintanalysis
takes 36.2 seconds, whereas the original program takes 9.4 seconds
to process the same amount of data. This overhead is higher inprograms with multiple datasets, aggregator operators, and fusion
operators,P1-P5,astheyintroducecomplexdependenciesamong
columns and rows. These co-dependences are represented in dense
taint objects ( i.e.,RoaringBitmaps [ 11]). Across the 17 programs,
the Ô¨Årst instrumented run‚Äôs overhead is 1.1 √óto 14√óof the Ô¨Årst
uninstrumented run. Note that this overhead is a one-time upfront
costandtherestofthefuzzingloopdoesnotrequirerunningan
instrumented version with taint monitors; therefore, in the long
run, the cost of using DepFuzz becomes negligible compared to
many hours of fuzz testing. DepFuzz‚Äôs runtime overhead is on par
withothertaint analysisapproachesonDISC applications[ 46].
5 RELATED WORK
Fuzzinghasgainedpopularityinindustryandacademiarecently
duetoitsblack-boxnatureandeaseofadoption[ 38].Acommon
challengeinfuzzingisgeneratingstructurallyvalidinputs.Zest[ 40]
attempts to generate valid inputs using parametric generators. Big-
Fuzz[52]usesframeworkabstractiontoreducefuzztestinglatency.
However, BigFuzz is a simple random fuzzer and cannot iden-
tify co-dependent regions in the input. Symbolic execution tech-
niques [19,29,30,37] exist for testing DISC applications. However,
theycannoteasilygenerateconstraintsthatrespectco-dependence
relationshipswithinmultipledatasets,createdbythecomplexin-
teractionbetweendataÔ¨ÇowoperatorsandUDFs.Randomtesting
bears similarity to fuzz testing [ 13,33,39,42]. Randoop [ 39] and
EvoSuite [ 16] generate test suites for the program under test to
cause program crashes.
The closest line of work to ours is taint-based fuzzing. At a high
level, all taint analysis techniques attempt to isolate regions within
aninputcriticaltomutate.Forexample,Bekrar et.al.[7]propose
taint-based fuzzing that identiÔ¨Åes input regions to focus mutations.
TaintScope[ 49]andBuzzFuzz[ 17]isolateregionsoftheinputinside
asensitivelibraryandsystemcalls.PATA[ 32]performspath-aware
taint analysis to mitigate the problems of over-tainting and under-
taintingbyemployingpathinformation.Althoughthesetechniques
isolate critical input regions, none target DISC applications and
nonecandiscoverunderlyingco-dependencerelationsbyanalyzing
dataÔ¨Çow operators and UDFs. The inputs to DISC applications are
verylargeandconsistofmultipledatasets;soexistingtainttracking
atabyte-levelisalsoineÔ¨Écient. DepFuzz addressestheseproblems
by handling multiple datasets and by tracking taints at the level of
dataset IDs, columns, androwsfrom unstructuredinputs.
The idea of triggering hard-to-reach regions ofthe programhas
been seen frequently in the literature. FairFuzz [ 28] is a targeted
mutationstrategythatavoidsmutatinginputregionsthattrigger
rarebranches,similartohow DepFuzz analyzestheuseoffusion
operators to co-mutate certain regions. However, FairFuzz uses
coveragefeedbackandasimplemaskingstrategytofreezecontigu-
ousinputregions.AFLFast[ 9]prioritizesinputsthattriggerrare
pathsin the code. AFLFast instruments program binary and per-
formruntimecoverageanalysis.BothFairFuzzandAFLFastarenot
suitableforDISCapplicationsbecausetheydonotanalyzedataÔ¨Çow
operator usages and internal UDF semantics to infer co-dependent
input regions in large datasets. Neither perform provenance-aware
duplication to resolve aggregations, which are extremely common
1059Co-dependence Aware Fuzzing forDataflow-BasedBig DataAnalytics ESEC/FSE ‚Äô23, December3‚Äì9, 2023,San Francisco, CA, USA
inDISCapplications.Driller[ 47]switchestousingsymbolicexecu-
tiontoresolveadiÔ¨ÉcultbranchthatAFLfailstopass,causingitto
inherit the limitations of symbolic execution. Steelix [ 31] attempts
to produce a single input passing a diÔ¨Écult-to-hit branch in the
codeandemployssource-levelinstrumentationsimilarto DepFuzz.
SteelixisnotsuitableforDISCapplicationswithlargeinputsdue
to alackofÔ¨Åne-graineddata tracking.
TaintStream [ 51] implements cell-levelprovenancefor Apache
Spark in the context of Policy Enforcement. DepFuzz also tracks
provenance at the cell level. However, TaintStream requires ex-
tending the original dataset with tags, whereas DepFuzz‚Äôs cell
level tracking is fully automatic and does not require converting
theoriginaldataset. DepFuzz‚Äôstaintanalysisissimilartothatof
FlowDebug [ 48], as they both instrument primitive data types and
application code and do not require any modiÔ¨Åcations to the origi-
naldatasetstoenabletaintanalysis.However,FlowDebugconcerns
taint analysis only and does not generate test data nor does it iden-
tifyco-dependencyconstraintsamonginputdatasets.Furthermore,
existing dataprovenance techniques [ 12,21‚Äì23,34] performtaint
analysis only at the row level, support only a single dataset, and
do not support tracking at the column (cell) level. Spark-speciÔ¨Åc
dataprovenancesolutionsalsoexist,suchasTitian[ 25],butitis
limitedtorow-leveldataprovenanceforonlyasingleinputdataset.
BigSift[18]isanextensionofdeltadebuggingforDISCapplications
but its isolation works at the level of rows, not the level of dataset
IDs, rows,andcolumns, unlike DepFuzz.
6 CONCLUSION
Traditional fuzzing is ineÔ¨Äective for DISC applications due to re-
quirements to handle unstructured inputs, a lack of schema, the
inabilitytohandlemultipledatasets,andtheirlargeinputsize.In
thiswork,weintroduce DepFuzz,atechniquethatusesÔ¨Åne-grained
provenancetrackingtoinfercomplexco-dependenceconstraints
created by dataÔ¨Çow operators and user-deÔ¨Åned functions. The key
insightbehind DepFuzz istoorchestrateco-dependenceawaremu-
tations on multiple input datasets in concert. DepFuzz increases
code coverage fast, Ô¨Ånds more defects, and Ô¨Ånds defects that are
hardto Ô¨Ånd‚Äî29%higher statement coverage, 2.1√ófaster,and trig-
geringfaults thatare 0.9operators deeper thanthe onesfound by
the state ofthe art commercialfuzzerfor JVM.
ACKNOWLEDGEMENTS
Thisworkissupported bytheNationalScience Foundationunder
grant numbers 2106420, 1764077, 1956322, 1460325, 2106383 and
2106404.ItisalsosupportedinpartbyfundingfromAmazonand
Samsung. We want to thank the anonymous reviewers for their
constructive feedbackthat helpedimprove the work.
REFERENCES
[1]2021. American Fuzzy Lop. https://lcamtuf.coredump.cx/aÔ¨Ç/ . Accessed: 2021-12-
14.
[2] 2022. Apache Hadoop. https://hadoop.apache.org/ . Accessed:2021-12-14.
[3] 2022. Apache Spark. https://spark.apache.org/ . Accessed:2021-12-14.
[4]Accessed: 2022-09-01. Big Data Benchmark. https://amplab.cs.berkeley.edu/
benchmark/
[5]Accessed:2022-09-01. TPC-DSVersion2andVersion3. https://www.tpc.org/
tpcds/default5.asp
[6]Accessed: 2023-01-10. Demonstration Database.
https://postgrespro.com/community/demodb.[7]SoÔ¨Åa Bekrar, Chaouki Bekrar, Roland Groz, and Laurent Mounier. 2012. A Taint
BasedApproachforSmartFuzzing.In 2012IEEEFifthInternationalConference
on Software Testing, VeriÔ¨Åcation and Validation . 818‚Äì825. https://doi.org/10.1109/
ICST.2012.182
[8]Alexander Boyce and Mathieu Leger. Accessed: 2023-01-10. Stateful
Streaming with Apache Spark: How to Update Decision Logic at Run-
time. https://www.databricks.com/session_eu20/stateful-streaming-with-
apache-spark-how-to-update-decision-logic-at-runtime
[9]Marcel B√∂hme, Van-Thuan Pham, and Abhik Roychoudhury. 2019. Coverage-
BasedGreyboxFuzzingasMarkovChain. IEEETransactionsonSoftwareEngi-
neering45,5 (2019), 489‚Äì506. https://doi.org/10.1109/TSE.2017.2785841
[10]DeepayanChakrabarti,RaviKumar,andKunalPunera.2008. AGraph-Theoretic
Approach to Webpage Segmentation. In Proceedings of the 17th International
Conference on World Wide Web (Beijing, China) (WWW ‚Äô08) . Association for
ComputingMachinery,NewYork,NY,USA,377‚Äì386. https://doi.org/10.1145/
1367497.1367549
[11]SamyChambi,DanielLemire,OwenKaser,andRobertGodin.2015. Betterbitmap
performancewithRoaringbitmaps. Software:PracticeandExperience 46,5(April
2015),709‚Äì719. https://doi.org/10.1002/spe.2325
[12]Zaheer Chothia, John Liagouris, Frank McSherry, and Timothy Roscoe. 2016.
Explaining Outputs in Modern Data Analytics. Proc. VLDB Endow. 9, 12 (Aug.
2016),1137‚Äì1148. https://doi.org/10.14778/2994509.2994530
[13]Christoph Csallner and Yannis Smaragdakis. 2004. JCrasher: an
automatic robustness tester for Java. Software: Practice and Ex-
perience 34, 11 (2004), 1025‚Äì1050. https://doi.org/10.1002/spe.602
arXiv:https://onlinelibrary.wiley.com/doi/pdf/10.1002/spe.602
[14]Brendan Dolan-Gavitt, Patrick Hulin, Engin Kirda, Tim Leek, Andrea Mambretti,
Wil Robertson, Frederick Ulrich, and Ryan Whelan. 2016. LAVA: Large-Scale
Automated Vulnerability Addition. In 2016 IEEE Symposium on Security and
Privacy (SP) . 110‚Äì121. https://doi.org/10.1109/SP.2016.15
[15]Fariza Fauzi, Jer-Lang Hong, and Mohammed Belkhatir. 2009. Webpage Seg-
mentation for Extracting Images and Their Surrounding Contextual Information.
InProceedingsofthe17thACMInternationalConferenceonMultimedia (Beijing,
China)(MM ‚Äô09). Association for Computing Machinery, New York, NY, USA,
649‚Äì652. https://doi.org/10.1145/1631272.1631379
[16]Gordon Fraser and Andrea Arcuri. 2011. EvoSuite: Automatic Test Suite Gen-
erationforObject-OrientedSoftware.In Proceedingsofthe19thACMSIGSOFT
Symposiumandthe13thEuropeanConferenceonFoundationsofSoftwareEngi-
neering(Szeged,Hungary) (ESEC/FSE‚Äô11) .AssociationforComputingMachinery,
NewYork, NY, USA,416‚Äì419. https://doi.org/10.1145/2025113.2025179
[17]VijayGanesh,TimLeek,andMartinRinard.2009. Taint-baseddirectedwhitebox
fuzzing. In 2009 IEEE 31st International Conference on Software Engineering . 474‚Äì
484.https://doi.org/10.1109/ICSE.2009.5070546
[18]Muhammad Ali Gulzar, Matteo Interlandi, Xueyuan Han, Mingda Li, Tyson
Condie,andMiryungKim.2017. AutomatedDebugginginData-IntensiveScal-
ableComputing.In Proceedingsofthe2017SymposiumonCloudComputing (Santa
Clara, California) (SoCC ‚Äô17) . Association for Computing Machinery, New York,
NY, USA,520‚Äì534. https://doi.org/10.1145/3127479.3131624
[19]MuhammadAliGulzar,ShaghayeghMardani,MadanlalMusuvathi,andMiryung
Kim.2019. White-BoxTestingofBigDataAnalyticswithComplexUser-DeÔ¨Åned
Functions.In Proceedingsofthe201927thACMJointMeetingonEuropeanSoftware
EngineeringConferenceandSymposiumontheFoundationsofSoftwareEngineering
(Tallinn,Estonia) (ESEC/FSE2019) .AssociationforComputingMachinery,New
York, NY, USA,290‚Äì301. https://doi.org/10.1145/3338906.3338953
[20]Ahmad Humayun, Miryung Kim, and Muhammad Ali Gulzar. 2023. DepFuzz
Tool for "Co-dependence Aware Fuzzing for DataÔ¨Çow-Based Big Data Analytics".
https://doi.org/10.1145/3580412
[21]R.Ikeda,J.Cho,C.Fang,S.Salihoglu,S.Torikai,andJ.Widom.2012. Provenance-
Based Debugging and Drill-Down in Data-Oriented WorkÔ¨Çows. In 2012 IEEE
28thInternationalConferenceonDataEngineering .1249‚Äì1252. https://doi.org/
10.1109/ICDE.2012.118
[22]RobertIkeda,HyunjungPark,andJenniferWidom.2011. Provenanceforgen-
eralized map and reduce workÔ¨Çows. In In Proc. Conference on Innovative Data
SystemsResearch (CIDR) .
[23]R.Ikeda,A.DasSarma,andJ.Widom.2013. Logicalprovenanceindata-oriented
workÔ¨Çows?.In 2013IEEE29thInternationalConferenceonDataEngineering(ICDE) .
877‚Äì888. https://doi.org/10.1109/ICDE.2013.6544882
[24]Code Intelligence. 2022. Jazzer. https://github.com/CodeIntelligenceTesting/
jazzer.
[25]Matteo Interlandi, Kshitij Shah, Sai Deep Tetali, Muhammad Ali Gulzar, Se-
unghyun Yoo, Miryung Kim, Todd Millstein, and Tyson Condie. 2015. Titian:
Data provenance support in spark. In Proceedings of the VLDB Endowment In-
ternationalConferenceonVeryLargeDataBases ,Vol.9.NIHPublicAccess,216.
https://doi.org/10.1007/s00778-017-0474-5
[26]Ren√©Just.2014. TheMajorMutationFramework:EÔ¨ÉcientandScalableMutation
Analysis for Java. In Proceedings of the 2014 International Symposium on Software
TestingandAnalysis (SanJose,CA,USA) (ISSTA2014) .AssociationforComput-
ingMachinery,NewYork,NY,USA,433‚Äì436. https://doi.org/10.1145/2610384.
1060ESEC/FSE ‚Äô23, December3‚Äì9, 2023,San Francisco, CA, USA Ahmad Humayun, MiryungKim,andMuhammadAliGulzar
2628053
[27]Kavi, Buckles, and Bhat. 1986. A Formal DeÔ¨Ånitionof Data Flow Graph Models.
IEEETrans. Comput. C-35,11(1986), 940‚Äì948. https://doi.org/10.1109/TC.1986.
1676696
[28]CarolineLemieuxandKoushikSen.2018. FairFuzz:ATargetedMutationStrat-
egy for Increasing Greybox Fuzz Testing Coverage. In Proceedings of the 33rd
ACM/IEEEInternationalConferenceonAutomatedSoftwareEngineering (Mont-
pellier, France) (ASE ‚Äô18). Association for Computing Machinery, New York, NY,
USA,475‚Äì485. https://doi.org/10.1145/3238147.3238176
[29]Kaituo Li, Christoph Reichenbach, Yannis Smaragdakis, Yanlei Diao, and
ChristophCsallner.2013. SEDGE:SymbolicexampledatagenerationfordataÔ¨Çow
programs.In 201328thIEEE/ACMInternationalConferenceonAutomatedSoftware
Engineering (ASE) . 235‚Äì245. https://doi.org/10.1109/ASE.2013.6693083
[30]Nan Li, Yu Lei, Haider Riaz Khan, Jingshu Liu, and Yun Guo. 2016. Applying
Combinatorial Test Data Generation to Big Data Applications. In Proceedings of
the 31stIEEE/ACMInternational Conference on AutomatedSoftware Engineering
(Singapore,Singapore) (ASE‚Äô16).AssociationforComputingMachinery,New
York, NY, USA,637‚Äì647. https://doi.org/10.1145/2970276.2970325
[31]Yuekang Li, Bihuan Chen, Mahinthan Chandramohan, Shang-Wei Lin, Yang Liu,
andAlwenTiu.2017. Steelix:Program-StateBasedBinaryFuzzing.In Proceedings
of the 2017 11th Joint Meeting on Foundations of Software Engineering (Paderborn,
Germany) (ESEC/FSE 2017) . Associationfor ComputingMachinery, NewYork,
NY, USA,627‚Äì637. https://doi.org/10.1145/3106237.3106295
[32]J.Liang,M.Wang,C.Zhou,Z.Wu,Y.Jiang,J.Liu,Z.Liu,andJ.Sun.2022. PATA:
FuzzingwithPathAwareTaintAnalysis.In 20222022IEEESymposiumonSecurity
and Privacy(SP)(SP) . IEEE Computer Society, Los Alamitos,CA, USA, 154‚Äì170.
https://doi.org/10.1109/SP46214.2022.9833594
[33]Yu Lin, Xucheng Tang, Yuting Chen, and Jianjun Zhao. 2009. A Divergence-
Oriented Approach to Adaptive Random Testing of Java Programs. In 2009
IEEE/ACM International Conference on Automated Software Engineering . 221‚Äì232.
https://doi.org/10.1109/ASE.2009.13
[34]Dionysios Logothetis, Soumyarupa De, and Kenneth Yocum. 2013. Scalable
Lineage Capture for Debugging DISC Analytics. In Proceedings of the 4th Annual
SymposiumonCloudComputing (SantaClara,California) (SOCC‚Äô13) .Association
for Computing Machinery, New York, NY, USA, Article 17, 15 pages. https:
//doi.org/10.1145/2523616.2523619
[35]EhsanMazloumi,GrahamCurrie,andGeoÔ¨ÄreyRose.2010. UsingGPSDatato
GainInsightintoPublicTransportTravelTimeVariability. JournalofTransporta-
tion Engineering 136, 7(2010), 623‚Äì631. https://doi.org/10.1061/(ASCE)TE.1943-
5436.0000126
[36]FarhadNabhaniandAlirezaShokri.2009. Reducingthedeliveryleadtimeina
food distribution SME through the implementation ofsix sigmamethodology.
Journal of Manufacturing Technology Management 20, 7 (Sept. 2009), 957‚Äì974.
https://doi.org/10.1108/17410380910984221
[37]Christopher Olston, Shubham Chopra, and Utkarsh Srivastava. 2009. Gener-
ating Example Data for DataÔ¨Çow Programs. In Proceedings of the 2009 ACM
SIGMOD International Conference on Management of Data (Providence, Rhode
Island,USA) (SIGMOD‚Äô09) .AssociationforComputingMachinery,NewYork,
NY, USA,245‚Äì256. https://doi.org/10.1145/1559845.1559873
[38]Alessandro Orso and Gregg Rothermel. 2014. Software Testing: A Research
Travelogue(2000‚Äì2014).In FutureofSoftwareEngineeringProceedings (Hyderabad,
India)(FOSE 2014) . Association forComputing Machinery, New York, NY, USA,
117‚Äì132. https://doi.org/10.1145/2593882.2593885
[39]CarlosPachecoandMichaelD.Ernst.2007. Randoop:Feedback-DirectedRandom
TestingforJava. In Companiontothe 22ndACM SIGPLANConference on Object-
Oriented Programming Systems and Applications Companion (Montreal, Quebec,
Canada)(OOPSLA‚Äô07) . Associationfor Computing Machinery, NewYork,NY,
USA,815‚Äì816. https://doi.org/10.1145/1297846.1297902[40]Rohan Padhye, Caroline Lemieux, Koushik Sen, Mike Papadakis, and Yves
Le Traon. 2019. Semantic Fuzzing with Zest. In Proceedings of the 28th ACM SIG-
SOFT InternationalSymposiumon SoftwareTesting andAnalysis (Beijing, China)
(ISSTA2019) .AssociationforComputingMachinery,NewYork,NY,USA,329‚Äì340.
https://doi.org/10.1145/3293882.3330576
[41]Hui Peng, Yan Shoshitaishvili, and Mathias Payer. 2018. T-Fuzz: Fuzzing by
ProgramTransformation.In 2018IEEESymposiumonSecurityandPrivacy(SP) .
697‚Äì710. https://doi.org/10.1109/SP.2018.00056
[42]I. S. Wishnu B. Prasetya.2014. T3, a Combinator-Based Random Testing Tool for
Java:Benchmarking.In FutureInternetTesting ,TanjaE.JVos,KiranLakhotia,and
SebastianBauersfeld(Eds.).SpringerInternationalPublishing,Cham,101‚Äì110.
https://doi.org/10.1007/978-3-319-07785-7_7
[43]Roch, Grzegorz Slowikowski, Roland Tritsch, Sam, and Chris Kipp. 2022. scover-
age. https://github.com/scoverage. Accessed:2022-01-10.
[44]Subhajit Roy, Awanish Pandey, Brendan Dolan-Gavitt, and Yu Hu. 2018. Bug
Synthesis: Challenging Bug-Finding Tools with Deep Faults. In Proceedings of
the201826thACMJointMeetingonEuropeanSoftwareEngineeringConference
andSymposiumontheFoundationsofSoftwareEngineering (LakeBuenaVista,
FL, USA) (ESEC/FSE 2018) . Association for Computing Machinery, New York, NY,
USA,224‚Äì234. https://doi.org/10.1145/3236024.3236084
[45]Kostya Serebryany. Accessed: 2023-01-29. LibFuzzer ‚Äì a library for coverage-
guided FuzzTesting. https://llvm.org/docs/LibFuzzer.html
[46]DongdongShe,YizhengChen,AbhishekShah,BaishakhiRay,andSumanJana.
2020. Neutaint: EÔ¨Écient Dynamic Taint Analysis with Neural Networks. In 2020
IEEESymposiumonSecurityandPrivacy(SP) .1527‚Äì1543. https://doi.org/10.1109/
SP40000.2020.00022
[47]NickStephens,JohnGrosen,ChristopherSalls,AndrewDutcher,RuoyuWang,
Jacopo Corbetta, YanShoshitaishvili, Christopher Kruegel, and Giovanni Vigna.
2016. Driller: Augmenting fuzzing through selective symbolic execution.. In
NDSS, Vol. 16.1‚Äì16.
[48]Jason Teoh, Muhammad Ali Gulzar, and Miryung Kim. 2020. InÔ¨Çuence-Based
Provenance for DataÔ¨Çow Applications with Taint Propagation. In Proceedings
of the 11th ACM Symposium on Cloud Computing (Virtual Event, USA) (SoCC
‚Äô20).AssociationforComputingMachinery,NewYork,NY,USA,372‚Äì386. https:
//doi.org/10.1145/3419111.3421292
[49]Tielei Wang, Tao Wei, Guofei Gu, and Wei Zou. 2010. TaintScope: A Checksum-
Aware Directed Fuzzing Tool for Automatic Software Vulnerability Detection. In
2010 IEEE Symposium on Security and Privacy . 497‚Äì512. https://doi.org/10.1109/
SP.2010.37
[50]GuoqingHarryXu,MargusVeanes,MichaelBarnett,MadanMusuvathi,Todd
Mytkowicz, Ben Zorn, Huan He, and Haibo Lin. 2019. Niijima: Sound and
AutomatedComputation ConsolidationforEÔ¨Écient Multilingual Data-Parallel
Pipelines. In Proceedings of the 27th ACM Symposium on OperatingSystems Prin-
ciples(Huntsville,Ontario,Canada) (SOSP ‚Äô19) .Associationfor ComputingMa-
chinery, New York, NY, USA, 306‚Äì321. https://doi.org/10.1145/3341301.3359649
[51]ChengxuYang,YuanchunLi,MengweiXu,ZhenpengChen,YunxinLiu,Gang
Huang,andXuanzheLiu.2021. TaintStream:Fine-GrainedTaintTrackingfor
BigDataPlatformsthroughDynamicCodeTranslation.In Proceedingsofthe29th
ACM Joint Meeting on European Software Engineering Conference and Symposium
on the Foundations of Software Engineering (Athens, Greece) (ESEC/FSE 2021) .
Association for Computing Machinery, New York, NY, USA, 806‚Äì817. https:
//doi.org/10.1145/3468264.3468532
[52]Qian Zhang, Jiyuan Wang, Muhammad Ali Gulzar, Rohan Padhye, and Miryung
Kim. 2021. BigFuzz: EÔ¨Écient Fuzz Testing for Data Analytics Using Framework
Abstraction. In Proceedings of the 35th IEEE/ACM International Conference on
Automated Software Engineering (Virtual Event, Australia) (ASE ‚Äô20). Association
for Computing Machinery, New York, NY, USA, 722‚Äì733. https://doi.org/10.
1145/3324884.3416641
Received 2023-02-02; accepted 2023-07-27
1061