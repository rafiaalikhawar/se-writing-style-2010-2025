On the Benefits and Limits of Incremental Build of Software
Configurations: An Exploratory Study
Georges Aaron Randrianaina
Univ Rennes, CNRS, Inria, IRISA - UMR 6074
F-35000 Rennes, France
georges-aaron.randrianaina@irisa.frXhevahire TÃ«rnava
Univ Rennes, CNRS, Inria, IRISA - UMR 6074
F-35000 Rennes, France
xhevahire.ternava@irisa.fr
Djamel Eddine Khelladi
Univ Rennes, CNRS, Inria, IRISA - UMR 6074
F-35000 Rennes, France
djamel-eddine.khelladi@irisa.frMathieu Acher
Univ Rennes, CNRS, Inria, IRISA - UMR 6074
Institut Universitaire de France (IUF)
F-35000 Rennes, France
mathieu.acher@irisa.fr
ABSTRACT
Softwareprojectsusebuildsystemstoautomatethecompilation,
testing, and continuous deployment of their software products. As
softwarebecomesincreasinglyconfigurable,thebuildofmultiple
configurations isa pressing need,but expensive andchallenging to
implement. The current state of practice is to build independently
(a.k.a., clean build) a software for a subset of configurations. While
incremental build has been studied for software evolution and
relatively small changes of the source code, it has surprisingly not
been considered for software configurations. In this exploratory
study, we examine the benefits and limits of building softwareconfigurations incrementally, rather than always building them
cleanly. By using five real-life configurable systems as subjects, we
explore whether incremental build works, outperforms a sequence
of clean builds, is correct w.r.t.clean build, and can be used to
find an optimal ordering for building configurations. Our results
show that incremental build is feasible in 100% of the times in four
subjectsandin78%ofthetimesinonesubject.Inaverage,88 .5%
oftheconfigurationscouldbebuiltfasterwithincrementalbuild
while also finding several alternatives faster incremental builds.
However, only 60% of faster incremental builds are correct. Still,
whenconsideringthosecorrectincrementalbuildswithcleanbuilds,
we could always find an optimal order that is faster than just a
collection of clean builds with a gain up to 11 .76%.
CCS CONCEPTS
â€¢Softwareanditsengineering â†’Softwareproductlines ;Soft-
ware configuration management; Incremental compilers;
KEYWORDS
Configurable software systems, build systems, configuration build
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
onthe firstpage.Copyrights forcomponentsof thisworkowned byothersthan the
author(s)mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,or
republish,topostonserversortoredistributetolists,requirespriorspecificpermission
and/or a fee. Request permissions from permissions@acm.org.
ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
Â© 2022 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ACM ISBN 978-1-4503-9221-1/22/05...$15.00
https://doi.org/10.1145/3510003.3510190ACM Reference Format:
Georges Aaron Randrianaina, Xhevahire TÃ«rnava, Djamel Eddine Khelladi,
andMathieuAcher.2022.OntheBenefitsandLimitsofIncrementalBuildof
SoftwareConfigurations:AnExploratoryStudy.In 44thInternationalConfer-
enceonSoftwareEngineering(ICSEâ€™22),May21â€“29,2022,Pittsburgh,PA,USA.
ACM,NewYork,NY,USA,13pages.https://doi.org/10.1145/3510003.3510190
1 INTRODUCTION
Building software is a crucial activity for developers and maintain-
ersofprojects.Variousartifactsareassembled,compiled,tested,and
thendeployed,presumablysuccessfully.Theemergenceofcontinu-
ous integration (CI) has accelerated this trend with the integration
ofbuildservicesintomajorcodeplatforms(e.g.,GitHub,GitLab).
The goal is to continuously ensuresome quality assurance of soft-
ware products,whether in terms offunctionality or non-functional
properties(e.g.,security,executiontime).Althoughwidelyadopted,
buildingsoftwareisincreasinglycomplexandexpensiveinterms
of time and resources [6, 11, 21, 31].
Software configurations are adding further complexity to the
problem of building software. Different variants of the artifactscan be assembled e.g., due to conditional compilation directives
#ifdef-s in the source code. Different external libraries can be
compiled and integrated as well. The way the build is realized can
alsochange e.g.,withtheuseofdifferentcompilerflags.Developers
andmaintainersofaprojectwanttoensurethat,throughoutthe
evolution,alloratleastasubsetofsoftwareconfigurationsbuild
well. As most of todayâ€™s software is configurable in order to fit
constraints,functionalandperformancerequirementsofusers,itis
notsurprisingtoobservethatmanyorganizationsbuilddifferent
softwareconfigurationsoftheirprojects.Forinstance,initiatives
like KernelCI or 0-day build thousands of default or random Linux
configurations each day [ 26,33]. Another example is JHipster, a
popularWebgenerator,thatbuildsdozensofconfigurationsateach
commit, involving different technologies (Docker, Maven, grunt,
etc.) [19].
Thecurrentstateofpracticeistobuildindependentlyasubset
of configurations i.e., in a fresh and clean environment. This paper
proposes and explores an approach, called incremental build of con-
figurations. The idea is simple: instead of starting from scratch and
cleaning the buildâ€™s artifacts, a configuration can be built from an
existing and already completedconfiguration build (incrementally).
15842022 IEEE/ACM 44th International Conference on Software Engineering (ICSE)
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:30:33 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Randrianaina, et al.
The hope is to reuse artifacts of previous configurationsâ€™ build and
thus save some computations, resources, and time. This is just a
hunch;therealquestionistoquantifyhowmuchandwhenyoucan
gain (or lose) compared to a more conventional build. Moreover,
the approach is not without risk: an incremental build may not
work or may be incorrect compared to a conventional, clean build.
Thebuildsystemmayforgettorecompilesomenecessaryartifacts,
for example. In fact, it is a hypothesis that needs inquiry. Another
unknown is about the strategy to order the incremental build ofconfigurations. Given a configuration to build, with which other
configurations should the incremental build be carried out? Should
incrementalbuild beusedall times?There arenumerouspossible
orderings, possibly with different effects on the correctness andoverall build time. Our goal is to explore these hypotheses and
address,tothebestofourknowledge,new open questions:( ğ‘¹ğ‘¸1)
Is incremental build simply possible in real-world configurable sys-
tems?( ğ‘¹ğ‘¸2)Doesincrementalbuildoutperformcleanbuild?( ğ‘¹ğ‘¸3)
Istheresultofincrementalbuildthesameasthatofcleanbuild?
(ğ‘¹ğ‘¸4) Is there an order of configurations that brings an optimal
(overall) incremental build time?
Novelty.Surprisingly, whileincremental build issupported and
hasactuallybeendesignedforrelativelysmalledits,ithasnotbeen
explored for software configurations. A possible reason is that the
usualcompilationworkflowandbuildprocesstargetssmall,local
modifications (e.g., modification of one source file). Building sev-
eralconfigurationsinvolvelargemodificationsthatspannumerous
sourcefiles,thuschallengingbuildsystems.Therearenumerous
works in the software product line community about variability-
aware analysis [ 24,25,27,28,42,48,53]. The idea is to process
theconfigurablecodebase,exploitingsimilaritiesamongindivid-
ualvariantswiththegoalofreducinganalysiseffort.Incremental
build shares the same principle and aims to leverage similarities
amongconfigurationsâ€™build.However,weareunawareofworks
thatconsidertheactualbuildofconfigurationsinanincremental
way.Tothebestofourknowledge,investigatingthebenefitsand
limits of incremental build at the configuration level has not yet
been considered.
Significance of the problem. The promise is to reduce the cost
of building software, a stressing topic when you think about the
environmentalandfinancialcoststhatcompaniesandpublicorgani-zationsshouldhavetobear[
6,11,21,31].Societyreliesonsoftware,
but building software has an enormous cost: we aim to mitigate
thistrend.BeyondLinuxandJHipsterexamplesalreadymentioned,
numerous real-world software projects are configurable and actu-
allybuildseveralconfigurations.Thebuildisanecessarystepto
checkthecorrectnessofthecode,todynamicallytestthesystem,toobservenon-functionalproperties(e.g.,executiontime,security),tosynthesizeperformancemodels[
12,18,20,29,35,41,45,46,49,52].
Owingtothecostandthefrequenciesofsoftwarebuilds,anyim-
provement is more than welcome for developers and organizations.
Practical scenarios. Incremental build is mainly intended to be
part of a continuous integration. With each commit, rather than
buildingconfigurationsseparately,anorderingstrategycanbeused
to reduce build time or to build much more configurations given a
budget.Oncethe(optimal)orderoftheconfigurationsisestablished,
the benefits can be obtained several times during the evolutionof a software project. Of course, the ordering can be updated incase of major modifications. Out of an order, the distribution of
incremental build of software configurations on different machines
is also possible but out of the scope of the paper.
Methodology. This paper designs and performs the first study
about incremental build of configurations: the purpose is to under-
stand the challenges and practices in a real-world setting and togenerate hypotheses about other, similar contexts [
50]. Our con-
tribution is limited to the study of incremental build on existingand real projects. On the other hand, this study opens new per-
spectives and brings insights that can be used to design new build
systemsorschedulingheuristics.Ourdatasetcoversfivesubject
systems,namely x264,sqlite,xz,curl,and xtermcoveringdiffer-
entdomains, respectively,video encoding,database,compression
utility, network communication, and terminal emulator. Though
allwritteninClanguage,theirbuildprocesshighlydiffers(more
details in the paper). We explore whether incremental build works
(i.e.,produces somethingwithouterrors), whetheranincremental
strategy outperforms a sequence of clean builds, whether the re-sult is correct w.r.t.clean build, and what an optimal ordering of
configurations brings in terms of build time.
Significanceoftheresults. Ourresultsshowedthatincremental
build is feasible in 100% of the times in four subjects and in 78%of the times in the
xzsubject. On average, 88 .5% of the config-
urations could be built faster with incremental build while also
findingseveralfasteralternativeincrementalbuilds.However,only
60% of faster incremental build are correct. Still, when considering
thosecorrectincrementalbuildswithcleanbuilds,wecouldalways
find an optimal order that is faster than just a collection of cleanbuilds with a gain up to 11
.76%. Overall, our results suggest that
incremental build of configurations can be beneficial. Owing to
the importance and increasing cost of build systems in the field of
software engineering, it is worth addressing the open issues for
fully realizing the potential of incremental build.
The main contributions of this paper are:
(1) the idea of incremental build of configurations;(2)
thedesignofanexploratorystudytoinvestigatethepotential
benefits and pitfalls of incremental build;
(3) a quantitative and qualitative analysis of empirical results;(4)
adiscussionontheimpactsofourworksondevelopers,build
systemsdesigners,andresearchersinconfigurablesystem
or continuous integration;
(5) a link to our publicly available data set for reproducibility.
Therestofthepaperisstructuredasfollows.Section2givessome
background about build systems and introduces incremental build.
Section3describesthedesignofourexperiments.Section4reports
on empirical results and answers research questions. Section 5discusses the impacts of our study and results. Section 6 reportson threats to validity. Section 7 reviews related work. Section 8
formulates research directions after a short summary.
2 BACKGROUND AND MOTIVATION
Thissectiongivesabackgroundonthetoolsandtheprocessthatare
commonlyusedtobuildaC-based,configurablesoftwaresystem,
whicharethesubjectsofthisstudy.Then,wemotivateourwork
with an example taken from the xtermterminal emulator subject.
1585
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:30:33 UTC from IEEE Xplore.  Restrictions apply. On the Benefits and Limits of Incremental Build of Software Configurations: An Exploratory Study ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
configure.ac
Makefile.amAUTOCONF
AUTOMAKEconfigure
Makefile.in./configure [options]
Makefile
Figure 1: The workflow of Autotools utility
2.1 Autotools
Installing a software package requires having its dependencies
(e.g., utilities and libraries) available in the current environment. In
addition,thepackageneedsalsotoknowwhicharetheavailable
features ofthe currentoperating system inorder tobe configured
andbuiltaccordingly.Withthehighdiversityofoperatingsystems,
their features and even local hacks by the users, it is impossible to
manage the configuration script for every possible environment.
For this reason, the GNU Project introduced the Autotools utility to
automatically generate configuration and build scripts to fit to the
machine it is built upon.
ThepresentedC-basedprojectsinthispaper,assubjects,mainly
use the GNU Autotools with the utilities of Autoconf [15] andAu-
tomake[16],asshowninFigure1.Specifically,Autoconftakesas
inputafile configure.ac inwhichthedeveloperhasspecifiedthe
packages to check and to determine which ones can be used or are
missing.Thenitgeneratesa configure file,whichcontainsascript
tochecktheavailablepackagesandfeaturesofthecurrentmachine
and a script to configure the project given the userâ€™s configuration.
Ontheotherhand,whilewritingasoftwarewithalargeamountof
files, it is complicated to keep track and specify how to build each
one of them. Therefore, the developers of C-based projects mainly
use a Makefile to describe how to build the project. But, the Make-
filesupportisdifferent,dependingonthecomputerenvironment.
ThisiswhydevelopersrelyontheAutomakeutility.Specifically,
adeveloperfirstspecifiesthestructureofthecurrentprojectand
how to build it. Then, Automake generates a Makefile.in that
has the previous build rules with compatibility on the current ma-
chineâ€™s environment. Once the configure andMakefile.in are
generated,theuserneedstorunonlythe configure scriptinorder
toconfiguretheproject.The configure scriptcanusedifferentop-
tionsfromtheuser,whicharewell-knownascompile-timeoptions,
andgeneratesthe Makefile accordingly.Afterthisconfiguration
step, the users need to run the makecommand in order to build the
given project. This entire process is also sketched in Figure 1.
Usually, Autotools is installed on the developerâ€™s computer, but
notontheuserâ€™senvironment.Thus,the configure ,Makefile.am ,
andMakefile.in oftenareshipped withinthecompressedfolder
that contains the projectâ€™s sources. In this case, the user simply
needs to execute the configure && make && make install
commandinordertoconfigure,build,andinstallthatgivenproject.
2.2 Make and incremental build
Makeisawell-knownbuildsystem[ 13].Makereads Makefiles which
contain the build rules to build the current software package. AListing 1 Makefile rules, illustrated in Figure 2
1util.o: util.h util.c
2 cc -c util.c
3main.o: util.h main.c
4 cc -c main.c
5main: util.o main.o
6 cc util.o main.o -o main
Figure2:Filedependency(left)andincrementalbuild(right)
Makefile can be either generated by using Autotools or written by
thedevelopersthemselves.ToshowhowMakeworks,Figure2gives
an illustrative example of a Makefile for a toy project (its sourcefiles are not included here). It is a borrowed example from [
40],
with the build rules presented in Listing 1.
In the lines 1-2 of Listing 1 is defined the rule util.owhich
depends on the header file util.handutil.c. In its line 2 is de-
scribed how to build it by using a cccompiler: the flag -cand the
file to compile util.cin order to produce an object file util.o.
Thesamethingisdonebythenextruleof main.oinlines3-4.The
lastmainrule, in lines 5-6, specifies how to build the final main
product. In this case, it simply links the util.oandmain.ofiles.
From this Makefile, Make can build a dependency graph like
the one shown in Figure 2 (left). During the compilation for the
firsttime, asnothinghas beencompiledyet,Make willbuildeach
of the described rules in the Makefile in order to build the final
product. Building a project from scratch and from its clean basis is
well-known as a clean build.
But,ifadevelopermodifiesevenafile,thenMakewillrebuild
only the rules that depend on this file. To build only the necessary
rules,Makecheckstheirtimestamp.Arulemustberebuildifoneofitsdependenciesismorerecentthanit.Forinstance,ifthedeveloper
modifies main.c, Make will only build the rule that depends on it,
thatis,the main.orule.Then,therulethatdependson main.o,the
main,andsoon.As util.odoesnotdependon main.c,Makewill
not update it. These updated rules by Make are also highlighted in
blue color in Figure 2 (right). This process, where the build system
doesonlytheminimumworkwithoutrebuildingtheunmodified
targets is well-known as the incremental build.
The incremental build process of Make is meant for file changes
ofasinglesoftwareconfiguration.However,wecanleverageitto
apply on files changes that are triggered by different compile-time
configurations options in a C-based system. Indeed, configuration
optionsareenabledinthecodethroughfileadditionorCprepro-
cessor directives. Inclusion of more files in a rule forces its update.
Moreover,additionsofblocksofcodethroughCpreprocessordi-
rectives changes the fileâ€™s timestamp to a more recent one, hence it
forces again the rebuild of the targets depending on it. Thus, Make
will only recompile the necessary targets during an incremental
build of configurations.
1586
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:30:33 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Randrianaina, et al.
Table 1: Example of clean build (CB) and incremental build
(IB) on four random configurations of xterm
ğ‘1(33 options) ğ‘2(29 options) ğ‘3(35 options) ğ‘4(27 options)
â€“disable-active-icon â€“disable-ansi-color â€“disable-ansi-color â€“disable-ansi-color
â€“diabel-16-color â€“disable-direct-color â€“disable-16â€“color â€“disable-direct-colorâ€“disable-256-color â€“disable-88-color â€“disable-direct-color â€“disable-88-colorâ€“disable-88-color â€“enable-broken-osc â€“disable-88-color â€“enable-broken-oscâ€“disable-broken-st â€“disable-bold-color â€“disable-blink-cursor â€“disable-c1-print# +28 other options # +24 other options # +30 other options # +22 other options
CB:11.94 seconds 11.04 seconds 12.88 seconds 10.04 seconds
IB: â€“ 10.36 seconds 10.91 seconds 8.21 seconds
Diff: n/a 6.16% 15.30% 18.23%
Total CB: 45.90 seconds IB:41.42 seconds Diff:9.80%
2.3 Motivating example
Letusconsider xterm,astandardterminalemulatorfortheXWin-
dowSystem. xtermhas63compile-timeoptions,whichmaylead
tolessthan263configurations(theexactnumberiscertainlylower
duetoconstraintsamongoptions).Buildingall(orevenasubset)
ofitsconfigurationsiscostlyandtime-consuming.Itiswherein-
cremental build can play a positive role. Table 1 shows the build
results for four configurations randomly generated for xterm. The
topof Table1givesthe optionsofthe fourdiverseconfigurations,
and the bottom of Table 1 gives the build time for clean build of
eachconfigurationseparately,andtheincrementalbuildofthefour
configurations ğ‘1â†’ğ‘2â†’ğ‘3â†’ğ‘4. Note that in the incremental
build,thefirstconfigurationmustbebuiltfromscratchwithaclean
build. Only then we can start building incrementally the rest of
configurations.
From Table 1, we observe that the total sum in time (seconds) of
thecleanbuildsofthefourconfigurationis45 .90ğ‘ ğ‘’ğ‘ğ‘œğ‘›ğ‘‘ğ‘ .Whereas,
thetotalsumintimeoftheincrementalbuildis41 .42ğ‘ ğ‘’ğ‘ğ‘œğ‘›ğ‘‘ğ‘ ,that
is,thesumofthecleanbuildof ğ‘1(hencethe"â€“"foritsincremental
build) and of the incremental builds of ğ‘2toğ‘4. This represents
a total gain of 4 .48ğ‘ ğ‘’ğ‘ğ‘œğ‘›ğ‘‘ğ‘ and 9.76% of time difference. We also
observeindividualgainforeveryincrementalbuildofthethreelast
configurations, respectively 6 .16% forğ‘2,1 5.30% forğ‘3, and 18.23%
forğ‘4. This gain is only on four configurations and can potentially
bemoresignificantthebiggerthenumberofconfigurationsthat
needto bebuild.To thebestof ourknowledge,no studyexistson
exploring the benefits and limits of incremental build on config-
urablesoftware.Therestofthepaperdesignsandreportsonour
exploratory study.
3 EXPERIMENTAL APPROACH
This section details incremental build experimentation. We first
present the used research questions to address the goal of our
experiment. Then, we describe the used subject systems with their
configurations,andtheusedbuildapproachinourexperimentation.
3.1 Research questions
The goal of this study is to explore the feasibility, efficiency, op-
timization, and correctness of incremental build in real-life con-figurable software systems. Hence, we define the following four
research questions.Table2:Subjectsystemswiththeirrespectiveanalysedcom-
mit/tag ID, LoC (lines of code), considered compile-time op-
tions, range of options within configurations, and batches
System Commit/Tag ID #LoC #Opt. Range #Batches
x264 ae03d92 115.243 16 3 - 7 2 x 20
sqlite version-3.35.4 318.521 25 7 - 18 2 x 20
xz e7da44d 39.714 87 14 - 23 2 x 20
curl curl-7_78_0 248.713 109 39 - 47 2 x 20
xterm xterm-368 130.850 63 26 - 37 2 x 20
ğ‘…ğ‘„1âˆ’Feasibility: Is incremental build possible in each con-
figurablesystem? Wefirstexplorewhetherthebuildstatus
of each of our subject software systems is successful during
theincrementalbuildinitsallconsideredsetofconfigura-
tions, in some of them, or in none of them.
ğ‘…ğ‘„2âˆ’Efficiency: Does incremental build outperform clean
build?To this end, we propose a build approach to measure
andcomparethecleanbuildandincrementalbuildtimeof
each subject system in its respective set of configurations.
ğ‘…ğ‘„3âˆ’Correctness: Is the result of incremental build the
same as that of clean build? To this end, we compare
whethertheresultingexecutablebinarysizeanditssymbols
arethesameaftertheincrementalandcleanbuildofeach
respective configuration in five subject systems.
ğ‘…ğ‘„4âˆ’Optimal ordering: Is there an order of configurations
that brings an optimal (overall) incremental build
time?By using our build approach, we analyse whether
itexistsanorderofconfigurationssuchthatthesystemwithagivenconfigurationcanbeincrementallybuildfasterwhile
being correct.
3.2 Subject systems
Theobjectsofthisexperimentarefivereal-lifesoftwaresystems
(seeTable2).Toselectthem,wehadinconsiderationseveralcriteria.
Namely, the fact that the system is an open-source and availableproject, it has compile-time configuration options, is a popular
project,andcoversadifferent application domain.Asaresult,we
selectedfiveC-basedsoftwaresystemsassubjects.Wefirstselected
thecommand-linevideoencoderof x264,whichhasbeenwidely
studied among the highly configurable systems [ 2,3,23]. Then, we
selected the widely used SQL database engine sqlite, the general-
purposedatacompressionsoftwareof xz,thelibraryof curl,which
supports a wide range of data transfer protocols with URLs, and
xterm, which is the standard terminal emulator for the X Window
System. To reason on a projectâ€™s popularity, we mostly used as a
proxy the recent number of stars (from 29 to 21.6k), commits (from
1300 to 27k), and contributors in its git repository.
3.3 Variables
Ourexperimentaimstostudytheincrementalbuildofagivencon-
figurable system in contrast to its clean building. Hence, the incre-
mentalandcleanbuildofconfigurationsisthe independentvariable
wecontrolled.Toanswerourresearchquestions,weobservedthree
dependentvariables,namely:the buildtime ofaconfiguration,the
1587
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:30:33 UTC from IEEE Xplore.  Restrictions apply. On the Benefits and Limits of Incremental Build of Software Configurations: An Exploratory Study ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
system with ğ‘ğ‘
ğ‘1 ğ‘2...ğ‘ğ‘›
ğ‘2ğ‘3...ğ‘ğ‘›ğ‘1ğ‘3...ğ‘ğ‘›ğ‘1ğ‘2...ğ‘ğ‘›âˆ’1ğ‘‘ğ‘£1 ğ‘‘ğ‘£2 ğ‘‘ğ‘£ğ‘›
ğ‘‘ğ‘£12ğ‘‘ğ‘£13ğ‘‘ğ‘£1ğ‘›ğ‘‘ğ‘£21ğ‘‘ğ‘£23ğ‘‘ğ‘£2ğ‘›ğ‘‘ğ‘£ğ‘›1ğ‘‘ğ‘£ğ‘›2ğ‘‘ğ‘£ğ‘›ğ‘›âˆ’1Clean build
Incremental build
Figure 3: Experimentation workflow. Where ğ‘ğ‘is the sys-
temâ€™s baseline configuration, and ğ‘1-ğ‘ğ‘›are its random gen-
erated configurations. The ğ‘‘ğ‘£ğ‘›andğ‘‘ğ‘£ğ‘›ğ‘šare the measured
dependentvariables(buildtime,executablebinarysize,etc.)
systemâ€™s executablebinarysize,andthesystemâ€™s objectfiles inits
build resulting folder, after both the clean and incremental builds.
3.4 Build approach
To be able to explore the qualities of incremental build in config-
urablesystemsandanswerourresearchquestions,wedesignthe
following build approach, and apply it in the five subject systems.
Given a configurable system ğœ“with compile-time options ğ‘‚ğœ“=
{ğ‘œ1,ğ‘œ2,...,ğ‘œ ğ‘š}, whereğ‘šâˆˆN, we first create a sample of configu-
rationsğ¶ğœ“={ğ‘1,ğ‘2,...,ğ‘ ğ‘›}for that system. Where ğ‘›=20, in this
study, and each ğ‘ğ‘–âˆˆğ¶ğœ“has a varying size with a random list of
generated options from ğ‘‚ğœ“. In Figure 3 is given an overview of
our build approach. First, it should be noted that each configurable
system has a default configuration, to which we will refer in the
following as the baseline configuration ( ğ‘ğ‘). The system with its ğ‘ğ‘
isattherootofourbuildapproach.Then,weapplytwomainbuild
steps, named clean build andincremental build as in Figure 3.
Cleanbuild. Inthis step,thebaseline systemisbuild witheach
configuration ğ‘ğ‘–âˆˆğ¶ğœ“from scratch. During this clean build, we
measureandrecordthedependentvariables( ğ‘‘ğ‘£ğ‘–)ofğ‘ğ‘–,namely,the
build time, the executable binary size, and the generated files.
Incremental build. Then, over each clean build configuration (cf.
ğ‘1toğ‘ğ‘›inFigure3),weincrementallybuildthesameconfigurations,
except the current previous applied configuration during the clean
build. For instance, over the clean build of ğ‘ğ‘›we incrementally
buildallotherconfigurationsfrom ğ‘1uptoğ‘ğ‘›âˆ’1exceptthe ğ‘ğ‘›itself.
Weassumethattheincrementalbuildof ğ‘ğ‘›afteritscleanbuildwill
provide the same results, hence it will be insignificant to study.
Listings 2 and 3 show an illustrative example taken from the
first subject system of x264with two of its used configurations,
calledğ‘1andğ‘2. In Listing 2, the x264â€™s baseline system is first
build with ğ‘1(lines 2-4), that is, it is clean build, and then it is
incrementally build with ğ‘2(lines 9-11) over the previous build.
Similarly, in Listing3, the system is firstclean build with ğ‘2(linesListing 2 x264â€™s clean build with ğ‘1and incremental build with ğ‘2
1 /* Clean build with c1 */
2 [x264] $./configure --disable-interlaced --bit-depth=8 \
3 --chroma-format=444 --disable-bashcompletion
4 [x264] $time make ; ls -l x264
5 >>0m20.262s
6 >> -rwxr-xr-x 1904936 x264
7
8 /* Incremental build with c2, after the clean build with c1 */
9 [x264] $./configure --disable-asm --disable-gpl \
10 --disable-thread --disable-interlaced
11 [x264] $time make ; ls -l x264
12 >>0m2.256s
13 >> -rwxr-xr-x 2423016 x264
Listing 3 x264â€™s clean build with ğ‘2and incremental build with ğ‘1
1 /* Clean build with c2 */
2 [x264] $./configure --disable-asm --disable-gpl \
3 --disable-thread --disable-interlaced
4 [x264] $time make ; ls -l x264
5 >>0m2.422s
6 >> -rwxr-xr-x 2423016 x264
78
/* Incremental build with c1, after the clean build with c2 */
9 [x264] $./configure --disable-interlaced --bit-depth=8 \
10 --chroma-format=444 --disable-bashcompletion
11 [x264] $time make ; ls -l x264
12 >>0m19.658s
13 >> -rwxr-xr-x 1904936 x264
2-4)andthenitisincrementallybuildwith ğ‘1(lines9-11).Itshould
benotedthatafterthefirstbuild,inline9ofListings2and3,instead
ofcleaningthedirectorywith make clean ,wedirectlyconfigure
the system tohost the new configuration:this is what we referto
as an incremental build. Hence, we incrementally build the next
configuration on top of the previous clean build configuration.
Further, during each clean and incremental build process, we
measure the buildtime and the executable binary size of thesys-
tem (lines 4-6 and11-13). Moreover, we save the state of thebuild
systemâ€™s directory after each build. In this way, we can retrieve
usefuldatasuchasthebinary,configurationlogsandobjectfiles
for further analysis.
3.5 Experiments settings
By using the presented build approach, we conduct an experiment
with the five subject systems. Specifically, we build each system by
usingtwobatcheswith20randomgeneratedconfigurationseach.
In this way, we perform 2 âˆ—20 clean builds and 2 âˆ—(20âˆ—19)=760
incrementalbuilds,orintotal800buildsofeachsystem.Tocorrectly
handleallofthem,weusedalocalgitstructurewhereeachsystem
buildis savedin anew gitbranch. Theresultinggit structureof a
system with all its builds has the same view as in Figure 3.
Togeneratetherandomconfigurations,weusetherandomprod-
uctgeneratorintheFeatureIDEframework[ 38].Itshouldbenoted
thattherangeofoptionswithinthesampleofconfigurations(cf.
columnâ€™Rangeâ€™inTable2)changesquiteproportionallywiththe
numberofconsideredoptionsamongthesubjects(cf. columnâ€™#Opt.â€™
in Table 2). Whereas, for their comparison, we take two batches
with 20 sample of configurations in all five subjects. Further, to en-
sure that the generated set of configurations is diverse enough, we
looked at the distance between each pair of configurations within
abatch. Bydistance,we meanthepercentage ofcommonoptions
1588
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:30:33 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Randrianaina, et al.
Table3:Thebuildtimeandbinarysizeofsubjectsfortwobatches( ğµ1andğµ2)with20configurationseach.Legendofcolorsis
in Table 4. ğ¶ğµ- clean build, ğ¼ğµ-incremental build, ğ‘šğ¼ğµ- minimum IC, ğ‘ğ¼ğµ- currect IB, â€âˆ’â€- failed build, and â€/â€- no value
System ğ‘1 ğ‘2 ğ‘3 ğ‘4 ğ‘5 ğ‘6 ğ‘7 ğ‘8 ğ‘9 ğ‘10 ğ‘11 ğ‘12 ğ‘13 ğ‘14 ğ‘15 ğ‘16 ğ‘17 ğ‘18 ğ‘19 ğ‘20x264(ğµ1)CB (ğ‘¡ğ‘›) 38.09 38.60 34.91 70.58 38.24 66.00 21.30 20.79 66.40 32.27 65.72 38.13 20.61 17.90 33.91 18.57 40.74 19.14 35.15 37.87
IB (ğ‘ğ‘š) ğ‘3 ğ‘4 ğ‘11 ğ‘17 ğ‘4 ğ‘11 ğ‘4 ğ‘20 ğ‘3 ğ‘7 ğ‘3 ğ‘8 ğ‘5 ğ‘12 ğ‘11 ğ‘4 ğ‘8 ğ‘4 ğ‘6 ğ‘18
IB (ğ‘¡ğ‘›)37.4237.85 33.9369.2437.4165.1820.96 20.3365.3531.7864.5837.2520.25 17.6533.3818.1739.99 18.76 34.4637.22
BS [MB] 1.831.85 2.172.912.332.711.53 1.582.701.672.711.831.50 1.402.121.481.95 1.49 2.181.83x264(ğµ2)CB (ğ‘¡ğ‘›) 38.09 18.49 18.31 31.31 69.86 65.46 17.73 34.45 40.12 34.18 34.56 64.44 36.40 18.25 33.62 70.73 34.03 18.43 38.18 31.35
IB (ğ‘ğ‘š) ğ‘15 ğ‘8 ğ‘18 ğ‘3 ğ‘3 ğ‘14 ğ‘3 ğ‘16 ğ‘13 ğ‘1 ğ‘16 ğ‘3 ğ‘17 ğ‘1 ğ‘3 ğ‘3 ğ‘3 ğ‘15 ğ‘3 ğ‘17
IB (ğ‘¡ğ‘›)37.9518.54 18.2431.3269.8465.5217.70 34.5340.0634.0434.5164.5636.32 18.2333.6870.7734.03 18.38 38.0731.34
BS [MB] 1.851.42 1.481.642.952.751.37 1.781.952.172.182.691.79 1.482.172.962.17 1.47 1.851.64sqlite(ğµ1)CB (ğ‘¡ğ‘›) 61.07 65.67 68.35 68.64 68.55 72.64 57.08 59.41 72.58 71.36 68.11 68.57 54.45 70.82 62.49 65.98 67.85 58.87 72.43 70.91
IB (ğ‘ğ‘š) ğ‘7 ğ‘4 ğ‘15 ğ‘7 ğ‘7 ğ‘3 ğ‘4 ğ‘14 ğ‘3 ğ‘3 ğ‘15 ğ‘4 ğ‘4 ğ‘8 ğ‘8 ğ‘7 ğ‘5 ğ‘2 ğ‘8 ğ‘3
cIB (ğ‘¡ğ‘›)// /// 70.02 // / / / / // / / /// /
mIB ( ğ‘¡ğ‘›)0.010.01 0.010.010.010.010.01 0.010.010.010.010.010.01 0.010.010.010.01 0.01 0.010.01
BS[MB] 9.209.70 9.259.739.689.738.07 8.139.729.649.749.688.17 9.618.559.529.65 8.26 9.739.62sqlite(ğµ2)CB (ğ‘¡ğ‘›) 103.25 94.24 101.89 103.8 83.63 98.71 90.24 101.67 82.28 91.83 82.95 87.05 89.91 105.17 87.05 96.4 84.8 103.32 103.58 96.58
IB (ğ‘ğ‘š) ğ‘3 ğ‘16 ğ‘4 ğ‘1 ğ‘15 ğ‘20 ğ‘8 ğ‘3 ğ‘3 ğ‘9 ğ‘4 ğ‘3 ğ‘5 ğ‘4 ğ‘5 ğ‘2 ğ‘6 ğ‘12 ğ‘3 ğ‘16
cIB (ğ‘¡ğ‘›) 63.42 // / / 94.30 // / / / / // / / /// 56.32
mIB ( ğ‘¡ğ‘›)0.010.01 0.010.010.010.010.01 0.010.010.010.010.010.01 0.010.010.010.01 0.01 0.010.01
BS[MB] 9.709.51 9.629.738.419.759.23 9.608.078.648.588.399.68 9.738.619.688.62 9.70 9.729.70xz(ğµ1)CB (ğ‘¡ğ‘›) 12.15 10.78 11.39 10.52 10.24 10.37 11.20 11.89 11.24 10.59 10.29 10.20 10.58 10.44 10.53 12.46 10.53 11.17 11.59 10.19
IB (ğ‘ğ‘š) ğ‘18 ğ‘18 âˆ’ ğ‘18 ğ‘10âˆ’âˆ’ ğ‘9 ğ‘8 ğ‘5âˆ’ ğ‘18 ğ‘17 âˆ’ ğ‘18âˆ’ ğ‘13 ğ‘20 âˆ’ ğ‘18
cIB (ğ‘¡ğ‘›) 11.43 10.28 âˆ’10.72 /âˆ’âˆ’ 11.28 //âˆ’ 10.06 /âˆ’ 10.65 âˆ’/ 10.67 âˆ’10.30
mIB ( ğ‘¡ğ‘›)11.4310.28 âˆ’10.72 0.40 âˆ’âˆ’ 1.350.420.87 âˆ’10.06 0.61 âˆ’10.65 âˆ’0.9610.67 âˆ’10.30
BS [MB] 1.161.02 1.151.021.021.061.09 1.131.100.961.000.991.02 1.091.041.230.96 1.03 1.161.01xz(ğµ2)CB (ğ‘¡ğ‘›) 10.38 10.08 11.01 9.75 10.02 10.20 9.94 9.69 10.00 10.90 9.96 9.86 10.74 11.47 9.98 10.18 11.63 11.08 9.82 9.83
IB (ğ‘ğ‘š) ğ‘13 ğ‘17 ğ‘2 ğ‘2 ğ‘7âˆ’ ğ‘5 ğ‘9 ğ‘2 ğ‘6âˆ’ ğ‘3 ğ‘1 ğ‘8 ğ‘17 ğ‘18 ğ‘15 ğ‘5 ğ‘17 ğ‘2
cIB (ğ‘¡ğ‘›)/9.93 10.91 9.46 10.08 âˆ’/ 9.74 10.10 /âˆ’ 10.17 10.42 11.49 /10.18 11.51 10.95 /9.77
mIB ( ğ‘¡ğ‘›)0.869.9310.91 9.460.81 âˆ’0.47 9.7410.10 0.95 âˆ’10.17 0.8911.49 0.2810.18 1.9110.95 0.389.77
BS [MB] 1.171.01 1.180.941.021.181.05 0.921.061.191.091.021.08 1.171.101.031.16 1.06 0.951.01curl(ğµ1)CB (ğ‘¡ğ‘›) 23.56 42.42 30.52 44.02 24.99 23.61 22.91 34.05 29.37 24.05 55.98 26.14 40.80 70.95 41.08 44.38 29.34 23.26 21.72 56.86
IB (ğ‘ğ‘š) ğ‘5 ğ‘16 ğ‘1 ğ‘16 ğ‘9 ğ‘5 ğ‘6 ğ‘5 ğ‘3 ğ‘5 ğ‘16 ğ‘5 ğ‘16 ğ‘16 ğ‘16 ğ‘11 ğ‘1 ğ‘9 ğ‘18 ğ‘16
cIB (ğ‘¡ğ‘›)/38.17 25.99 39.82 // 18.66 // 19.66 51.47 22.01 36.34 64.56 37.70 /24.71 /17.33 52.37
mIB ( ğ‘¡ğ‘›)0.051.06 0.110.110.061.170.12 0.050.060.100.111.070.12 1.070.361.010.12 0.05 1.051.08
BS [MB] 4.673.50 0.614.151.024.314.09 4.560.754.314.290.822.61 4.543.473.894.45 0.69 1.104.01curl(ğµ2)CB (ğ‘¡ğ‘›) 28.61 71.51 33.53 39.86 25.26 67.21 30.87 28.31 29.61 50.13 23.47 41.16 23.40 23.58 44.98 23.35 25.30 22.97 44.97 29.27
IB (ğ‘ğ‘š) ğ‘13 ğ‘11 ğ‘11 ğ‘11 ğ‘11 ğ‘13 ğ‘11 ğ‘13 ğ‘13 ğ‘11 ğ‘13 ğ‘13 ğ‘11 ğ‘13 ğ‘11 ğ‘13 ğ‘13 ğ‘13 ğ‘13 ğ‘11
cIB (ğ‘¡ğ‘›) 24.69 67.95 29.63 36.75 21.32 65.67 26.98 24.39 25.80 46.52 /37.59 /19.61 41.64 19.32 21.18 18.93 41.48 24.82
mIB ( ğ‘¡ğ‘›)1.0635.01 0.1119.56 0.1234.78 1.06 0.110.1224.54 1.0119.94 0.05 0.1122.08 0.110.11 0.1121.82 1.07
BS [MB] 4.474.42 4.422.851.314.323.60 4.673.662.830.543.220.58 4.223.930.700.82 3.60 3.933.89xterm(ğµ1)CB (ğ‘¡ğ‘›) 8.60 8.24 11.64 11.33 11.82 10.23 9.74 9.96 11.53 10.77 9.89 9.08 10.17 8.91 10.26 9.83 7.67 8.63 11.85 10.91
IB (ğ‘ğ‘š) ğ‘3 ğ‘1 ğ‘10 ğ‘2 ğ‘1 ğ‘3 ğ‘2 ğ‘1 ğ‘18 ğ‘2 ğ‘20 ğ‘2 ğ‘1 ğ‘1 ğ‘2 ğ‘1 ğ‘15 ğ‘1 ğ‘1 ğ‘2
IB (ğ‘¡ğ‘›)8.428.0611.4311.1311.68 9.839.56 9.7411.4210.59 9.668.9410.01 8.7210.11 9.657.50 8.4911.6610.72
BS [MB] 2.612.35 3.053.193.302.882.72 2.773.072.882.772.752.88 2.622.922.732.28 2.61 3.142.89xterm(ğµ2)CB (ğ‘¡ğ‘›) 11.41 11.32 10.46 8.88 10.19 10.20 9.08 8.33 12.80 10.76 10.46 10.81 8.52 11.74 11.68 9.88 7.60 11.76 10.59 8.45
IB (ğ‘ğ‘š) ğ‘3 ğ‘1 ğ‘2 ğ‘5 ğ‘3 ğ‘2 ğ‘10 ğ‘10 ğ‘2 ğ‘2 ğ‘9 ğ‘7 ğ‘6 ğ‘3 ğ‘5 ğ‘3 ğ‘5 ğ‘2 ğ‘2 ğ‘5
IB (ğ‘¡ğ‘›)11.1811.11 10.24 8.6910.0510.06 8.93 8.1712.5710.6810.3110.62 8.3811.53 11.19.67 7.411.58 10.41 8.24
BS [MB] 3.113.09 2.882.552.812.842.52 2.503.382.912.803.042.44 3.213.132.612.30 3.23 2.752.51
â— â—â—â—â— â—â—â—â— â—
0 2 04 06 08 0 1 00x264_B1 x264_B2 sqlite_B1 sqlite_B2 xz_B1 xz_B2 curl_B1 curl_B2 xterm_B1 xterm_B2
Figure 4: The distance between different generated configu-
rations, per batch, in five subject systemsbetween configurations. Hence, the distance 0 between two config-
urationsğ‘ğ‘–,ğ‘ğ‘—âˆˆğ¶ğœ“indicates that the sets of compile-time options
in these two configurations are disjoint sets. Whereas, the distance
of1indicatesthat ğ‘ğ‘–isthesameoratleastasubsetof ğ‘ğ‘—.Figure4
showstheoverallcalculateddistributionofthedistancebetween
all pairs of configurations in our five subject systems. The median
distancevariesbetween33 .33%inthesecondbatch( ğµ2)ofx264and
48.57% in the second batch ( ğµ2)o fxterm, indicating that in each
subjecttheconsideredconfigurationswithinabatcharediverseformorethan50%onaverage.Wealsoobserved82configurationsof0distancein
x264(ğµ1andğµ2)andin sqlite(ğµ2),thatis,completely
different.Then,in x264(ğµ1andğµ2)thereareonlythreecaseswith
distance 1, that is, entirely included in another one.
We conducted the experiments on a Linux workstation running
Fedora 34 with Intel Core i7-10610U CPU and 15.3 GiB of memory.
To prevent side effects, all experiments are run twice using Docker
andsequentially,astheonlyprocessesintheworkstation.Moreover,
1589
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:30:33 UTC from IEEE Xplore.  Restrictions apply. On the Benefits and Limits of Incremental Build of Software Configurations: An Exploratory Study ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
theDockerfileofeachsubjectsystemismadeavailable1andcanbe
used toreproduce the experiments.At the sameplace, we provide
the build configurations in all systems with their generated data.
4 RESULTS
We now discuss the results with regard to our research questions.
4.1 Feasibility of incremental build ( ğ‘…ğ‘„1)
In order to measure and compare the build time and system cor-
rectness after an incremental build, we first had to ensure thatthe system is successfully building during the clean build of itsconfigurations, that is, it has a build status 0 and an executablefile is created. In cases when the system threw an error during
thecleanbuildofaconfiguration,weanalysedthedependencies
between compile-time options and resolved the error by removing
oneoftheconflictingoptions.Forexample,weencounteredsuch
optionâ€™sdependenciesintheconfigurationsof xterm.Asaresult,
inourexperimentwithfivesystems,thecleanbuildofeachoftheir
configurationsissuccessful.Putdifferently,inallourcleanbuild
cases,thesystemâ€™sbuildstatusis0andasystemâ€™sexecutablefileis
created.
Despitethesuccessfulcleanbuildofallconfigurations,weno-
ticed that some configurations in some systems have a failed build
statusduringtheirincrementalbuild.Findingoutwhetherthein-
crementalbuildisfeasibleinasystemornotwashardtodeduceby
simplyinspectingitsMakefile.Therefore,weincrementallybuild
all pairs of configurations in five systems and observed their build
status,includingthepresenceoftheirexecutablefile.Asaresult,
all of the configurations in x264,sqlite,curl, and xtermare suc-
cessfully incrementally build. But, there are 9 configurations in xz
thathaveafailedbuildstatusduringtheirincrementalbuild.These
cases are marked with a dash (/primeâˆ’/prime) in Table 3 for batches ğµ1and
ğµ2.Forinstance,byincrementallybuilding xzwithconfiguration
ğ‘3overanyotherconfiguration,in ğµ1,itresultedinafailedbuild
status and without an xzâ€™s executable file.
Based on our experiments with five subjects, a successful clean
build configurationis not necessarilybuild successfully duringits
incrementalbuild.Ourinitialobservations,basedonlyonthebuildstatusandthecreatedsystemâ€™sexecutable,arethattheincremental
buildis feasiblein 100%ofconfigurations in4systems, namelyin
x264,sqlite,curl, and xterm. Whereas, the incremental build in
xzis feasible in 78% of its configurations. This indicates that the
rest 22% of configurations in xzalways require to clean build.
ğ‘¹ğ‘¸1insights: Our results show that between 78% (in the
case of xz) and 100% (in the case of x264,sqlite,curl, and
xterm)ofconfigurationscanbebuiltincrementally.Hence,
instead of always clean building, the incremental build of
configurations is feasible on highly configurable systems.
4.2 Incremental vs. clean build time ( ğ‘…ğ‘„2)
To answer the second research question, we recorded the clean
build time of each configuration and the incremental build timeof their all paired combinations. For this purpose, we follow the
1https://doi.org/10.5281/zenodo.5915116
Figure 5: The %of configurations per system that have a
faster,slower,andfailedincrementalbuild,thancleanbuild
described build approach in Section 3.4. In Table 3 is given the
resultingcleanandincrementalbuildtimeofeachconfiguration,
fortwobatches ğµ1andğµ2,ineach subject system.Allbuildtimes
are expressed in seconds. Specifically, the row ğ¶ğµ(ğ‘¡ğ‘›)shows the
obtained clean build time per configuration. For instance, the cleanbuildtimeof
ğ‘10intheğµ2ofcurlis50.13ğ‘ ğ‘’ğ‘ğ‘œğ‘›ğ‘‘ğ‘ .Therow ğ‘šğ¼ğµ(ğ‘¡ğ‘›)
showstheminimumincrementalbuildtimeofconfiguration ğ‘›,from
its all paired incremental builds. For instance, the fastest time toincrementally build
ğ‘2ofğµ1inxzis 10.28ğ‘ ğ‘’ğ‘ğ‘œğ‘›ğ‘‘ğ‘ . The next row,
ğ¼ğµ(ğ‘ğ‘š), shows which is the clean build configuration for which
the incremental build of a given configuration is faster. In the case
ofxz, theğ‘2inğµ1is incrementally build faster after the clean
build ofğ‘18. To easily notice whether the incremental build of a
given configuration is faster than its clean build, then the fastest
incremental build is colored in green, given in the row of ğ‘šğ¼ğµ(ğ‘¡ğ‘›).
Otherwise, when it is slower, it is colored in red. For instance,the incremental build of
ğ‘1in theğµ2ofx264is 37.95ğ‘ ğ‘’ğ‘ğ‘œğ‘›ğ‘‘ğ‘ ,o r
0.14ğ‘ ğ‘’ğ‘ğ‘œğ‘›ğ‘‘ğ‘ faster than its clean build, therefore it is colored in
green.Onthecontrary,the ğ‘12intheğµ2ofx264is64.56ğ‘ ğ‘’ğ‘ğ‘œğ‘›ğ‘‘ğ‘ ,
or 0.12ğ‘ ğ‘’ğ‘ğ‘œğ‘›ğ‘‘ğ‘ slower than its clean build, hence it is in red.
From Table 3, it can be observed that in four systems, namely,
inx264(ğµ1),sqlite(ğµ1,ğµ2),curl(ğµ1,ğµ2), and xterm(ğµ1,ğµ2),
there is always a pair combination of configurations for which the
incremental build of a given configuration is faster. However, in
x264(ğµ2) there are 7 from 20 configurations for which the incre-
mental build is always slower than the clean build. Similarly, there
are7from20casesin xz(ğµ1,ğµ2)thatalwayshaveaslowerincre-
mentalbuildthancleanbuild.InFigure5isgiventhepercentage
of configurations per system that resulted in a faster, slower, or
failedbuildduringtheirincrementalbuild.Specifically,100%ofthe
configurationsin sqlite,curl,and xtermhaveatleastonecase
where they are incrementally build quicker than during their clean
build.Further,82 .50%oftheconfigurationsin x264and60.00%of
theconfigurationsin xzhaveafasterbuildduringtheirincremental
building.Inaverage,forallfivesystems,88 .50%oftheconfigura-
tions are built faster during their incremental build than duringtheir clean build. Then, only 7
.00% of them are built slower, and
4.50% have a failed built during the incremental building.
1590
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:30:33 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Randrianaina, et al.
â—â—â—â— â—â— â—
0 5 10 15 20x264_B1x264_B2sqlite_B1sqlite_B2xz_B1xz_B2curl_B1curl_B2xterm_B1xterm_B2
Figure 6: The number of configurations with a faster incre-
mental build (IB) than clean build (CB) in each system
In cases when a configuration showed a quicker incremental
build, we went further and wondered whether it has more than
one pair combination for which it is faster than its clean build. For
instance, ğ‘1in theğµ1ofxtermis incrementally built over all other
19cleanbuildconfigurations,thatis,overthecleanbuildconfigura-
tions ofğ‘2toğ‘20. When it is built over ğ‘3, given in the row ğ¼ğµ(ğ‘ğ‘š),
itisfasterfor0 .18ğ‘ ğ‘’ğ‘ğ‘œğ‘›ğ‘‘ğ‘ thanduringitscleanbuilding.But,we
noticedthattherearealsocasesforwhichthe ğ‘1isincrementally
built faster, which cases are not shown in Table 3. Therefore, wecount all these cases and show them summarized in Figure 6. Itresulted that, except in two case in
sqliteandcurl, all their 20
configurations in two batches show a faster incremental build time
in all 19 pair combinations with the other configurations. In the ğµ1
ofx264, there are between 15 and 19 pair combinations for which
20 configurations are incrementally built faster. In the contrary,
intheğµ2ofx264thereareless,between1and13pairsofcombi-
nations. Quite similarly, in xzthere are configurations that have
faster incremental build in up to 3 and 8 pairs of combinations per
batch,respectively.In xtermthereisalsoalargenumberofcases
forwhichaconfigurationcanbeincrementallybuildfaster,upto
15 and 19 cases, per batch. Hence, in the majority of the cases, one
can find more than one pair combination to incrementally build a
configuration faster than in its clean build.
Inaddition,incaseswhentheincrementalbuiltconfigurations
arefaster,wethenwonderedforhowmuchtheyare.Inthisway,we
want to find out for how many minutes or seconds one can benefit
by incrementally building instead of clean building a configuration.
To analyse it, we calculated the difference between the clean build
timeandthefastest(thebest)incrementalbuildtimeofeachconfig-
urationinallsystems.The obtainedresultsareshowninFigure7.
The gained time by incrementally building a configuration in x264
is between 0 and 1 .34ğ‘ ğ‘’ğ‘ğ‘œğ‘›ğ‘‘ğ‘ . Quite similarly, in xzis between
0 and 10.82ğ‘ ğ‘’ğ‘ğ‘œğ‘›ğ‘‘ğ‘ .I nxtermis the smallest gain, between 0 .08
and 0.58ğ‘ ğ‘’ğ‘ğ‘œğ‘›ğ‘‘ğ‘ . Whereas, in sqliteis the largest gained time,
between54 .44ğ‘ ğ‘’ğ‘ğ‘œğ‘›ğ‘‘ğ‘ upto1ğ‘šğ‘–ğ‘›ğ‘¢ğ‘¡ğ‘’ ğ‘ğ‘›ğ‘‘ 45ğ‘ ğ‘’ğ‘ğ‘œğ‘›ğ‘‘ğ‘ .Thisseems
to be related also with the taken time to build the system itself. Forinstance,
xtermhas the smallest build time, less than 12 ğ‘ ğ‘’ğ‘ğ‘œğ‘›ğ‘‘ğ‘ in
all cases. Hence, the gained time during the incremental build is
thesmallestin xterm.Theoverallgainedtimeforanincremental
build configuration, in all systems, is between 0 (i.e., it is the same
time as in the clean build) and almost 2 ğ‘šğ‘–ğ‘›ğ‘¢ğ‘¡ğ‘’ğ‘ .â—â—
0 2 04 06 08 0 1 00x264_B1  x264_B2  sqlite_B1  sqlite_B2  xz_B1  xz_B2  curl_B1  curl_B2  xterm_B1  xterm_B2
Figure 7: The gained time, in seconds, by the incremental
build of configurations instead of their clean build
These findings show several things. First, in the majority of the
cases (88.50%), the incremental build of a systemâ€™s configuration is
fasterthanitscleanbuild.Asuccessfulcleanbuildconfiguration
may have a fail incremental build (in 4 .5% of the cases). Thirdly, in
order to benefit on time during the incremental build, the order of
buildconfigurationsmaymatter.Then,dependingonthesystem,
one can find more than one pair combination of configurations
(between 1 and 19) to quickly build a given configuration. The
gained time per configuration is quite large (from 0 ğ‘ ğ‘’ğ‘ğ‘œğ‘›ğ‘‘ğ‘ to
1ğ‘šğ‘–ğ‘›ğ‘¢ğ‘¡ğ‘’ ğ‘ğ‘›ğ‘‘ 45ğ‘ ğ‘’ğ‘ğ‘œğ‘›ğ‘‘ğ‘ ). Benefiting in terms of seconds can be
significant,forexample,incaseswhenthesystemneedstobeoften
build and regarding several configurations.
ğ‘¹ğ‘¸2insights: Theincrementalbuildofagivenconfiguration
canoutperformitscleanbuild,butthegaindependsonthe
configuration that was previously built. Our results show
that,inaverage,88 .5%ofconfigurationscanbebuildfaster
with incremental build.
4.3 System correctness ( ğ‘…ğ‘„3)
The observations in the second research question show that in
themajorityofcasestheincrementalbuildofasystemâ€™sconfigu-
ration is faster than its clean build. For instance, the clean build
time of the configurations in sqliteis between 54 .45ğ‘ ğ‘’ğ‘ğ‘œğ‘›ğ‘‘ğ‘ and
1ğ‘šğ‘–ğ‘›ğ‘¢ğ‘¡ğ‘’ ğ‘ğ‘›ğ‘‘ 45ğ‘ ğ‘’ğ‘ğ‘œğ‘›ğ‘‘ğ‘ , whereas their fastest incremental build
time is always 0 .01ğ‘ ğ‘’ğ‘ğ‘œğ‘›ğ‘‘ğ‘ . Similar examples can be observed also
inxzandcurl.Hence,weraisedthequestionwhethertheresult-
ing incremental build systems in these cases are also correct. That
is,whetherthesystemaftertheincrementalbuildandcleanbuild
is exactly the same. To reason about a systemâ€™s correctness, we
first defined the correctness of an incremental build based on somepropertiesofitsproducedbinary.Itshouldbenotedthatcomparing
the binaries of the same clean and incremental build configuration
bit by bit can give inaccurate results. This happens because the
incrementalbuildisnotexpectedtobeanexactreproductionofthe
clean build in the binary level. Still, two binaries that are produced
bythesameconfigurationsharesomesimilarities,suchasthebi-
nary size and symbol table. Hence, we chose these two properties
of a binary (i.e., binary size and symbol table) to ensure the system
correctness.
1591
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:30:33 UTC from IEEE Xplore.  Restrictions apply. On the Benefits and Limits of Incremental Build of Software Configurations: An Exploratory Study ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
Table 4: The percentage of correct systems after their incre-
mental builds, based on their binary size (BS) and symbols
Legend:
x264(ğµ1)
x264(ğµ2)
sqlite(ğµ1)
sqlite(ğµ2)
xz(ğµ1)
xz(ğµ2)
curl(ğµ1)
curl(ğµ2)
xterm(ğµ1)
xterm(ğµ2)
Fast&Same BS &2 01 21358 1 3 1 82 02 0
Â¬Fast&Same BS & 0 7003500 0 0
Fast&Â¬Same BS & 0 1 1 9 1 75572 0 0
Â¬Fast&Â¬Same BS & 0 0007200 0 0
Overall same BS ( %) 100 95 5 15 40 65 65 90 100 100
Same Symbols ( %) 1 0 0 9 52222 3 2 4 6 1 0 0 1 0 0
Â¬Same Symbols ( %) 0 59 79 89 89 86 85 4 0 0
In the row of ğµğ‘†[ğ‘€ğµ]in Table 3 is given the executable bi-
narysize,inmegabytes(MB),ofeachcleanbuildsystemforeach
configuration.Thesevaluesaresummarized inthefirstfourrows
in Table 4. As it can be observed, we encountered the four possible
cases.Specifically,60%ofconfigurationsinallsystemshaveafaster
incrementalbuildandtheresultingsystemhasthesameexactbi-
nary size as in the clean build. Then, 7 .50% of their configurations
haveaslowerincrementalbuild,butstilltheirsystemhasthesame
exact binary size. On the other hand, there are 32 .50% of configura-
tions inall systems thathave a fasteror slower incrementalbuild,
buttheirresultingsystemhasalwaysadifferentbinarysize.Hence,basedonthebinarysize,in67
.50%ofthecasesthesystemsthatare
built incrementallyare correct, whereasin 32 .50% of the casesthey
areincorrect.ThesecasescanalsobeeasilyidentifiedinTable3by
using the legend of the colors given in Table 4.
Besides, we compared the systemâ€™s executable symbols after
the clean and incremental build of each configuration in all five
subjects. The obtained results are summarized in the last two rows
in Table 4. It can be observed that, x264andxtermafter each built
configurationsarecorrect,thatis,in100%ofthecasestheyhave
thesamebinarysizeandsymbols.Intheothersystems, sqlite,xz,
andcurl,therearelessnumberofconfigurations(between2%and
46%)thathavethesamesymbolsduringtheircleanandincremental
builds. In all systems, there are 48 .03% of configurations for which
the resulting system has the same symbols in both build scenarios.
Based on these results, in almost all incrementally build cases
x264andxtermare correct. After investigation, we noticed that
the incremental build in these systems is actually not performed
by design. In both cases, the configure script is generating a con-
figuration file ( config.h andxtermcfg.h , respectively) on which
alltheotherfilesdependon.Hence,aftereachconfiguration,ev-
erythingisrebuiltfromscratch.Therefore,theincrementalbuild
that we were expecting is actually equivalent to a clean build in
these two systems. In the contrast, in xzwe had incremental build
issues. We were getting a same specific linker error telling thatsome symbols are undefined in some libraries. The reason of the
error is that some libraries were supposed to be rebuilt during the
incremental build of a configuration, but they were not. Further,
thereasonforwhich curlandsqlitewereincorrectisthesame.
Whenevertwoconfigurationssharedthesamefilesandgenerate
the same object files then, even when the content in these filesTable 5: Results for the optimal ordering
SystemTotal Clean
BuildTotal Optimal Orderingof Incremental BuildGainReduced NÂ° ofClean Builds
x264(ğµ1) 754.92 [sec] 666.12 [sec] 11.76% 20â†’2
x264(ğµ2) 747.99 [sec] 747.26 [sec] 0.10% 20â†’8
sqlite(ğµ1) 1,325.83 [sec] 1323.21 [sec] 0.20% 20â†’19
sqlite(ğµ2) 1,888.35 [sec] 1803.85 [sec] 4.47% 20â†’17
xz(ğµ1) 218.35 [sec] 216.89 [sec] 0.67% 20â†’13
xz(ğµ2) 206.52 [sec] 205.67 [sec] 0.41% 20â†’13
curl(ğµ1) 710.01 [sec] 652.01 [sec] 8.17% 20â†’7
curl(ğµ2) 707.35 [sec] 641.14 [sec] 9.36% 20â†’2
xterm(ğµ1) 201.06 [sec] 197.33 [sec] 1.86% 20â†’1
xterm(ğµ2) 204.92 [sec] 201.14 [sec] 1.84% 20â†’1
changes by a configuration, they are not rebuild and updated. Con-
sequently,theincorrectbuildsinthesesystemsreturnawarning
message notifying that there is nothing to build.
ğ‘¹ğ‘¸3insights: After anincremental build of configurations,
configurable systems are likely to be correct (in 57 .80% of
the cases), but not always. Specifically, the resulting bina-
riesarecorrect w.r.t.theirexecutablebinarysizefor67 .50%
ofconfigurationsand w.r.t.theirsymboltablefor48 .03%of
configurations.
4.4 Optimal ordering ( ğ‘…ğ‘„4)
Nowthatwefoundthatincrementalbuildcanbefasterandcorrect,
thequestionistowhatextentcanweleverageonthattooutperform
clean build of all configurations. To answer this research question,
we use our whole data and not only the minimum time that we
report in Table 3, that is, all measured times for the different com-
binations of incremental build. For this reason, we searched for an
optimal ordering of configurations based on build time. To do that,
wefirststartbybuildingadirectedgraph ğ‘”=(ğ‘‰,ğ¸)wherevertices
ğ‘‰areallconfigurationsandedges ğ¸areincrementalbuildsbetween
configurations2. We add an edge only when the incremental build
issuccessfulandiscorrect.Eachedgehasasaweighttheminimum
timeofincrementalbuild.TheseinformationcomesfromTable3.
Then, we add a root vertex that is linked with all other vertices by
edgesweightedwiththeirrespectivecleanbuildtimes.Thisisessen-tialforconfigurationsthatcannotbebuiltincrementally.Afterthat,
we run a minimum spanning tree directed graph algorithm [ 17].
Inthisway,wecalculatetheoptimalorderofconfigurationsthat
leverages to the best possible time on incremental build.
Table 5 shows our obtained results after running our algorithm
on all incrementally build configurations for two batches on five
subjectsystems.Fromthecolumn Gain,wecanobservethatindeed
we are able to find an optimal ordering that allows us to correctly
buildallconfigurationswhilebeingfasterbyperformingincremen-
talbuilds.Thegainvariesfrom0 .10%to11 .76%.Furthermore,we
could observe that we were always reducing the required number
ofcleanbuildsinasystem,whichvaryfrom1,2,7,8,13,17to19
times. Where 1 meaning one necessary clean build upon which the
2The graphs are available in our companion page.
1592
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:30:33 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Randrianaina, et al.
restofconfigurationsareincrementallybuilt,and19whereonly
one incremental built was possible. In particular, xterm,x264, and
curldid not need many clean builds and used several incremental
builds contrary to sqliteandxz. For example, in the optimized
orderfor xtermğµ1wehadonly1cleanbuildandtherestwasatree
ofincrementalbuildsfortherestoftheconfigurations.Whereas,
sqliteğµ2used only 3 incremental builds and 17 clean builds.
ğ‘¹ğ‘¸4insights: Itispossibletofindanorderofconfigurations
forwhich(1)allincrementalbuildconfigurationsinthisorder
arecorrect;(2)theoverallincrementalbuildtime(withfew
cleanbuildsinthemiddleoftheorder)isalwayssmallerthan
the overall time when configurations are only clean built.
5 DISCUSSION
This section discusses the impacts of our results on three actors.
For developers. From our experiments, we observe that ğ‘…ğ‘„2and
ğ‘…ğ‘„4highlightthebenefitsofincrementalbuild,while ğ‘…ğ‘„1andğ‘…ğ‘„3
highlight its limits. Nonetheless, we see that the benefits overcome
the limits, in particular, when finding the correct optimal order-
ing. Hence, developers can already benefit from incremental build.
A current limitation is that the optimal order is specific to a set
of configurations and deserves an upfront computational invest-
ment.However,thereareseveralprojectsthathaveapredefinedor fixed set of default configurations to build (e.g., JHipster [
19]).
Furthermore, the investment can pay for itself with the frequency
of commits and thus the use of incremental builds several times
throughout the continuous evolution.
Besides, developers should take into account the specifics of
theirprojectsandpossiblyfixtheirbuildartifactstofullyrealizethe potential of incremental build. For instance, the case of
xz
(cf.Section 4.3) is challenging: a critical library on which the build
ofconfigurationsdependsmustbeforcedtorebuild.Indeed,itisspecifiedthatthebuildrulerelatedtothelibrarymustberebuilt
each time, allowing it to propagate the build to its dependency and
update the new configuration. This rebuild is unnecessary, and the
build could be done once and for all. Therefore, developers of con-
figurablesoftwarecanmissopportunitiesofrelyingonincremental
build due to mismanagement of their build scripts.
Forbuildsystemdesigners. Numerousbuildsystemshavebeen
recentlydesignedanddevelopedtosupportthespecificneedsof
organizations[ 5,7,37,43].Thedesignspaceofbuildsystemisstill
tobeexploredandthecaseofconfigurationsaddsanewdimension.
Designers should give an interface between the build rules written
bythedeveloperandthebuildsystemâ€™sback-endwhichisbuildingtheproject.InthecaseofMake,theissuesobservedwhenaimingtoincrementallybuildinourcasestudiescannotbeonlyspottedbythe
developerinchargeofwritingbuildrules.Hence,configurations-
aware build systems are still to be designed and developed. We
believe the limits and insights of our study can help.
Forresearchers. Ourresultscallformoreresearchonthetopicof
incremental buildofconfigurations. Researcherscan evaluatethe
incrementality of existing build systems: most have been designed
tosupportvariabilityintime(evolution),notvariabilityinspace
(configurations). We encourage researchers to assess the feasibility,correctness, and performance of build systemswith the novel sce-
narioofbuildingsuccessivesoftwareconfigurationsaswedidin
thestudy.Ingeneral,thereisstillalackofevaluationonawider
scopeofincrementalbuildofconfigurationswithvariousbuildsys-tems[
5,7,37,43].Researcherscandesignfurtherempiricalstudies
(e.g.,confirmatorystudies)togainfurtherinsightsorvalidatesome
hypothesesofourwork.Amajorspecificityofincrementalbuildof
configurations is that there is an order to define. Intuitively, given
a set of configurations, the order of their incremental build canbe defined given according to their distance and closeness. How-ever, this notion of distance has to be defined precisely. It can be
based on the difference of activated options within configurations,
or on the relation between options and their implementation, oreven include the impact on the build. Therefore, understanding
whycertain pairs of configurations benefit more from incremental
build is an immediate research direction. It would be interesting to
propose heuristics to find an order before the actual build, based
onconfigurationsimilaritiesandbuildrules.Inotherwords,how
can we automatically find the optimal orders in ğ‘…ğ‘„4?I ti sa no pe n
problem that deserves much more research (e.g.,, choice and defini-
tionofametric,correlationofdistancewithbuildtime,thorough
evaluation).
6 THREATS TO VALIDITY
Internalvalidity. Tomeasurethebenefitsandlimitsofincremen-
tal build, we had to build several pairs of configurations. To reduce
theriskofinterferencewithotherrunningsoftware,weisolated
the build environment. To do so, we created one docker image per
system with the needed build tools and only needed dependencies.
Themachineweusedwasdedicatedtotheexperiment.However,
someOSprocessesandserviceswerestillrunningonthecomputer
thatcanbringmeasurementsnoises.Nevertheless,aswedocker-
ized similarly every run of our experiments, we expect that the
noiseswouldbesimilar,inparticular,thatwedidnotlaunchany
other task in parallel. We only run twice the experiments owingto the cost of computations. Moreover, there is a threat related
tothesamplingusedtogenerateconfigurations.Wedeliberately
used random sampling to diversify our data sets of configurations.
However, we observe from Figure 4 that our configurations are
relativelydisjoint.Nevertheless,foreachsamplebatch,werepeat
theexperimentprocess2times.Finally,tocheckforthecorrectness
ofanincrementalbuild,wecomparedthesizeandsymbolsofthe
produced binary with the one produced with a clean build.
Externalvalidity. WeexperimentedonfivesubjectsthatareC-
basedconfigurablesoftwaresystemswiththeMakebuildsystem.
Although we think that the incremental build would be applica-
ble in other build systems and software technologies, we cannot
generalize our results. Further experimentation is necessary.
Conclusion validity. Our experimentsshowed promising results
for incremental build of configurations by accelerating the buildtime. We also show limits when it comes to correctness. Eventhough, we could still find faster and correct incremental builds,
whichweusedtofindtheoptimalorderingofconfigurations.To
have more insights and statistical evidence, further evaluation is
needed on more subject systems and larger set of configurations.
1593
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:30:33 UTC from IEEE Xplore.  Restrictions apply. On the Benefits and Limits of Incremental Build of Software Configurations: An Exploratory Study ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
7 RELATED WORK
Buildsystems. Manyworksexistonincrementalbuildsystems
(e.g.,[5,12,13,20,29,35,39,46,52]) but without handling a set of
configurations.InCaoetal .[8],theauthorsforecasttheduration
ofincrementalbuildjobsforover2thousandofcommitsinGLib
(library) and VTK (Visualisation ToolKit). While incremental build
jobs vary in terms of duration, they propose a tooled approach,
BuildMÃ‰TÃ‰O, to forecast how long a job will take based on the de-
pendencygraphextractedfromafirstcleanbuildusingMAKAO[ 1].
BuildMÃ‰TÃ‰O can estimate the build time of a project after some
modifications in its files. However, it is considering only the evolu-
tionofoneconfigurationoftheprojectandnotdiverseoneslikeour
preliminary study. In CserÃ©p and Fekete [ 10], they introduce a way
todetectonlythenecessaryfilestobuildbyparsingthewholecode-
base. Instead of parsing every file from scratch each time, which
takesanimportantamountoftime,theyuseincrementalparsing.
Inaddition,theyalsocheckthebuildrulesmodificationsassociated
withthefiles.Hence,afiletorebuildisafilethathasbeeneither
modifiedorforwhichabuildrulehaschanged.Bydoingso,they
do not check the binariesâ€™ metadata, such as timestamps like Make
does, and thus avoid issues we present in Section 4.3. Maudoux
andMens[ 34]presentintheirpaperthatincrementalbuildhelps
to save time on local builds. However, it is not available yet on
continuous integration (CI) platforms. Indeed, incremental build is
not brought on CI because of some factors such as the correctness
of the produced binary. In our paper, we show that the correctness
of incremental build with real-world projects based on GNU Build
System is not ensured due to the Makeâ€™s strategy to perform incre-
mental build over configurations. Further, Konat et al .provide a
DSL to increase the effectiveness of writing build scripts by using
theirproposedlanguageofPIE[ 29,30].Withsuchexpressivebuild
scripts,analysisanderrordetectioncouldbepreventedbeforehand.
They also introduce a build system that takes track of files and
focus only on the part that changed, to avoid having too much
informationinmemoryandperformstrictlytheminimumwhile
being effective.
Several empirical studies on build systems have been performed
(e.g.,[21,22,31,35,36,54]). For instance, a case study at Google
reported a large corpus of builds and build errors mainly focusing
on static compilation problems [ 47]. Beller et al .[6] performed an
analysisofbuildswithTravisCIontopofGitHub.About 10%ofbuilds show different behavior when different environments are
used.Inourcase,weareconsideringdifferentconfigurationsratherthanenvironments.Tothebestofourknowledge,incrementalbuild
for software configurations has received little attention.
Software product line (SPL) and variability. The SPL community
develops numerous methods and techniques to manage a familyof variants (or products). Configurations are used to build vari-ants and are subject to intensive research. Formal methods and
programanalysiscanidentifysomeclassesofconfigurationsâ€™de-
fects[9,51],leadingtovariability-awaretestingapproaches(e.g.,
[14,24,25,27,28,32,42,48,53]).Thegeneralprincipleistoexploit
the commonalities among variants, mainly at the code level. For
instance, variability-aware execution [ 4,27,42] instruments an in-
terpreter of the underlying programming language to execute the
testsonlyonceonallthevariantsofaconfigurablesystem.Nguyenet al.implemented Varex, a variability-aware PHP interpreter, to
testWordPressbyrunningcodecommontoseveralvariantsonly
once[42].Reisneretal .useasymbolicexecutionframeworktoeval-
uate how the configuration options impact the coverage of the sys-
temgivenatestsuite[ 44].Staticanalysisandnotablytype-checking
has been used to look for bugs in configurable software and can
scale to very large code bases such as the Linux kernel [ 24,25,53].
Though variability-aware analysis is relevant in many engineering
contexts,ourinterestdiffersandconsistsinstudyingthepractice
of concretelybuilding asample of(representative) configurations
with an unexplored approach â€“ incremental build.
There are several empirical studies about the build of SPLs and
configurablesystems.Forinstance,Halinetal .[19]reportonthe
endeavortobuildallpossibleconfigurationsofanindustry-strength,
open source configurable software system JHipster, a popular code
generator for web applications. We are unaware of studies that
consider incremental build of configurations.
8 CONCLUSION
Inthispaper,weconductedanovelstudyinvestigatingthebenefits
and limits to incrementally build software configurations, as op-
posed to always cleaning as in conventional build. By considering
fivereal-life configurablesoftware systems,weexplored whether
incrementalbuildworks,outperformsasequenceofcleanbuilds,iscorrectw.r.t.cleanbuild,andcanbeusedtofindanoptimalordering
of building configurations. Our results suggest that incremental
buildofconfigurationscanreducebuildtimewithouttradingcor-
rectness. Developers and maintainers can already benefit from this
simple approach. Owing to the frequencies of buildin continuous
integrationandtheirincreasingcost,weencouragethesoftware
engineering community (build system designers, researchers, etc.)
to further investigate incremental build of configurations.
Asafuturework,weplantoreplicateourstudywithotherbuild
systemsandmorebatchesofconfigurationsamples.Wealsoplan
to investigate the possibility of having a heuristic for finding auto-
matically the optimal ordering. This is challenging as it requires to
inferaprioritheunknowndistancesamongconfigurations.Finally,
we aim to synthesize knowledge of patterns and anti-patterns of
incremental build to increase benefits and reduce limits.
ACKNOWLEDGMENTS
Wethankanonymousreviewersfortheirvaluablecommentsand
suggestions. This research was funded by the ANR-17-CE25-0010-
01 VaryVary project and the SLIMFAST project with DGA-PÃ´le
Cyber (PEC) and Brittany region.
REFERENCES
[1]Bram Adams, Kris De Schutter, Herman Tromp, and Wolfgang De Meuter. 2007.
Design recovery and maintenance of build systems. In Proceedings of the 23rd
InternationalConferenceonSoftwareMaintenance(ICSM).IEEEComputerSociety,
Paris, France, 114â€“123. https://doi.org/10.1109/ICSM.2007.4362624
[2]Juliana Alves Pereira, Mathieu Acher, Hugo Martin, and Jean-Marc JÃ©zÃ©quel.
2020. Samplingeffectonperformancepredictionofconfigurablesystems:Acase
study.In ProceedingsoftheACM/SPECInternationalConferenceonPerformance
Engineering. 277â€“288. https://doi.org/10.1145/3358960.3379137
[3]JulianaAlvesPereira,HugoMartin,MathieuAcher,Jean-MarcJÃ©zÃ©quel,Goetz
Botterweck,andAnthonyVentresque.2021. LearningSoftwareConfiguration
Spaces:ASystematicLiteratureReview. JournalofSystemsandSoftware (Aug.
2021). https://doi.org/10.1016/j.jss.2021.111044
1594
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:30:33 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Randrianaina, et al.
[4]Thomas H. Austin and Cormac Flanagan. 2012. Multiple facets for dynamic
information flow. ACM SIGPLAN Notices 47, 1 (Jan 2012), 165. https://doi.org/10.
1145/2103656.2103677
[5]Bazel.Online;accessed2022. Afast,scalable,multi-languageandextensiblebuild
system. https://bazel.build/.
[6]Moritz Beller, Georgios Gousios, and Andy Zaidman. 2017. Oops, My tests broke
the build: An explorative analysis of Travis CI with GitHub. In Proceedings of
the 14th International Conference on Mining Software Repositories (MSR â€™17). IEEE
Press, 356â€“367. https://doi.org/10.1109/MSR.2017.62
[7]BuildGrid. Online; accessed 2022. RECC. https://buildgrid.gitlab.io/buildgrid/
user/using_recc.html.
[8]QiCao,RuiyinWen,andShaneMcIntosh.2017. Forecastingthedurationofincre-
mental build jobs. In 2017 IEEE International Conference on Software Maintenance
and Evolution (ICSME). IEEE, 524â€“528. https://doi.org/10.1109/ICSME.2017.34
[9]Andreas Classen, Maxime Cordy, Pierre-Yves Schobbens, Patrick Heymans, Axel
Legay,andJean-FranÃ§oisRaskin.2013. FeaturedTransitionSystems:Foundations
forverifyingvariability-intensivesystemsandtheirapplicationtoLTLmodel
checking. IEEE Transactions on Software Engineering 39, 8 (Aug 2013), 1069â€“1089.
https://doi.org/10.1109/TSE.2012.86
[10]MÃ¡tÃ©CserÃ©pandAnettFekete.2020. Integrationofincrementalbuildsystems
into software comprehension tools. In ICAI. 85â€“93. http://ceur-ws.org/Vol-
2650/paper10.pdf
[11]JackEdge.2020. Thecostsofcontinuousintegration. https://lwn.net/Articles/
813767/.
[12]Sebastian Erdweg, Moritz Lichter, and Manuel Weiel. 2015. A sound and optimal
incremental build system with dynamic dependencies. ACM Sigplan Notices 50,
10 (2015), 89â€“106. https://doi.org/10.1145/2858965.2814316
[13]StuartI.Feldman.1979. Make-apr ogramformaintainingcomputerprograms.
Software:PracticeandExperience 9,4(1979),255â€“265. https://doi.org/10.1002/
spe.4380090402
[14]StefanFischer,RudolfRamler,ClausKlammer,andRickRabiser.2021. Testing
ofhighlyconfigurablecyber-physicalsystemsâ€“Amultiplecasestudy.In 15th
InternationalWorkingConferenceonVariabilityModellingofSoftware-Intensive
Systems (VaMoSâ€™21). ACM, New York, NY, USA, Article 19, 10 pages. https:
//doi.org/10.1145/3442391.3442411
[15]GNU Project - Free Software Foundation. Online; accessed 2022. Autoconf.
https://www.gnu.org/software/autoconf/.
[16]GNU Project - Free Software Foundation. Online; accessed 2022. Automake.
https://www.gnu.org/software/automake/.
[17]HaroldNGabow,ZviGalil,ThomasSpencer,andRobertETarjan.1986. Efficient
algorithmsforfindingminimumspanningtreesinundirectedanddirectedgraphs.
Combinatorica 6, 2 (1986), 109â€“122. https://doi.org/10.1007/BF02579168
[18]JianmeiGuo,KrzysztofCzarnecki,SvenApel,NorbertSiegmund,andAndrzej
Wasowski.2013. Variability-awareperformanceprediction:Astatisticallearning
approach.In 201328thIEEE/ACMInternationalConferenceonAutomatedSoftware
Engineering (ASE). IEEE, 301â€“311. https://doi.org/10.1109/ASE.2013.6693089
[19]AxelHalin,AlexandreNuttinck,MathieuAcher,XavierDevroey,GillesPerrouin,
andBenoitBaudry.2019. Testthemall,isitworthit?Assessingconfiguration
sampling on the JHipster Web development stack. Empir. Softw. Eng. 24, 2 (2019),
674â€“717. https://doi.org/10.1007/s10664-018-9635-4
[20]Matthew A. Hammer, Joshua Dunfield, Kyle Headley, Nicholas Labich, Jeffrey S.
Foster, Michael Hicks, and David Van Horn. 2015. Incremental computation
withnames. Proceedingsofthe2015ACMSIGPLANInternationalConferenceon
Object-OrientedProgramming,Systems,Languages,andApplications (Oct2015).
https://doi.org/10.1145/2814270.2814305
[21]MichaelHilton, NicholasNelson,Timothy Tunnell,DarkoMarinov,and Danny
Dig. 2017. Trade-offs in continuous integration: assurance, security, and flexi-bility. InProceedings of the 2017 11th Joint Meeting on Foundations of Software
Engineering. 197â€“207. https://doi.org/10.1145/3106237.3106270
[22]MichaelHilton,TimothyTunnell,KaiHuang,DarkoMarinov,andDannyDig.
2016. Usage,costs,andbenefitsofcontinuousintegrationinopen-sourceprojects.
In2016 31st IEEE/ACM International Conference on Automated Software Engineer-
ing (ASE). IEEE, 426â€“437. https://doi.org/10.1145/2970276.2970358
[23]PooyanJamshidi,NorbertSiegmund,MiguelVelez,ChristianKÃ¤stner,Akshay
Patel,andYuvrajAgarwal.2017. Transferlearningforperformancemodelingof configurable systems: an exploratory analysis. In Proceedings of the 32nd
IEEE/ACMInternationalConferenceonAutomatedSoftwareEngineering,ASE2017,
Urbana, IL, USA, October 30 - November 03, 2017, Grigore Rosu, Massimiliano Di
Penta, and Tien N. Nguyen (Eds.). IEEE Computer Society, 497â€“508. https:
//doi.org/10.1109/ASE.2017.8115661
[24]ChristianKastnerandSvenApel.2008. Type-checkingsoftwareproductlines
-Aformalapproach.In 23rdIEEE/ACMInternationalConferenceonAutomated
Software Engineering. IEEE, 258â€“267. https://doi.org/10.1109/ASE.2008.36
[25]AndyKenner,ChristianKÃ¤stner,SteffenHaase,andThomasLeich.2010. Type-
Chef: Toward type checking #ifdef variability in C. In Proceedings of the 2Nd
InternationalWorkshoponFeature-OrientedSoftwareDevelopment (Eindhoven,
The Netherlands) (FOSD â€™10). ACM, New York, NY, USA, 25â€“32. https://doi.org/
10.1145/1868688.1868693[26] KernelCI. Online; accessed 2022. KernelCI. https://kernelci.org/.[27]
Chang Hwan Peter Kim, Don S Batory, and Sarfraz Khurshid. 2011. Reducing
combinatoricsintestingproductlines.In ProceedingsoftheTenthInternational
Conference on Aspect-Oriented Software Development (AOSD â€™11). ACM, 57â€“68.
https://doi.org/10.1145/1960275.1960284
[28]Chang Hwan Peter Kim, Darko Marinov, Sarfraz Khurshid, Don Batory, Sabrina
Souto,PauloBarros,andMarcelodâ€™Amorim.2013. SPLat:lightweightdynamic
analysis for reducingcombinatorics in testing configurable systems.In Proceed-
ingsofthe20139thJointMeetingonFoundationsofSoftwareEngineering.ACM,
257â€“267. https://doi.org/10.1145/2491411.2491459
[29]GabriÃ«lKonat,SebastianErdweg,andEelcoVisser.2018. Scalableincremental
buildingwith dynamictask dependencies.In 201833rdIEEE/ACMInternational
ConferenceonAutomatedSoftwareEngineering(ASE).IEEE,76â€“86. https://doi.
org/10.1145/3238147.3238196
[30]GabriÃ«l Konat, Roelof Sol, Sebastian Erdweg, and Eelco Visser. [n.d.]. Precise,
efficient, and expressive incremental build scripts with PIE. ([n.d.]).
[31]CarleneLebeuf,ElenaVoyloshnikova,KimHerzig,andMargaret-AnneStorey.
2018. Understanding, debugging, and optimizing distributed software builds: A
design study. In 2018 IEEE International conference on software maintenance and
evolution (ICSME). IEEE, 496â€“507. https://doi.org/10.1109/ICSME.2018.00060
[32]Jackson A. Prado Lima, Willian Douglas Ferrari MendonÃ§a, Silvia R. Vergilio,
andWesleyK.G.AssunÃ§Ã£o.2020. Learning-basedprioritizationoftestcasesin
continuousintegrationofhighly-configurablesoftware.In SPLCâ€™20:24thACM
International Systems and Software Product Line Conference, Montreal, Quebec,
Canada,October19-23,2020,VolumeA,RobertoErickLopez-Herrejon(Ed.).ACM,
31:1â€“31:11. https://doi.org/10.1145/3382025.3414967
[33]Hugo Martin, Mathieu Acher, Juliana Alves Pereira, Luc Lesoil, Jean-Marc
JÃ©zÃ©quel, and Djamel Eddine Khelladi. 2021. Transfer Learning Across Vari-
ants and Versions: The Case of Linux Kernel Size. IEEE Transactions on Software
Engineering (2021), 1â€“17. https://hal.inria.fr/hal-03358817
[34]GuillaumeMaudouxandKimMens.2017. Bringingincrementalbuildstocontin-
uous integration. In Proc. 10th Seminar Series Advanced Techniques & Tools for
Software Evolution. 1â€“6.
[35]GuillaumeMaudouxandKimMens.2018. Correct,efficient,andtailored:The
future of build systems. IEEE Software 35, 2 (2018), 32â€“37. https://doi.org/10.
1109/MS.2018.111095025
[36]GuillaumeMaudouxandKimMens.2019. LessonsandpitfallsinbuildingFirefox
with Tup.. In SATToSE.
[37]Maven. Online; accessed 2022. A software project management and comprehen-
sion tool. https://maven.apache.org/.
[38]Jens Meinicke, Thomas ThÃ¼m, Reimar SchrÃ¶ter, Fabian Benduhn, Thomas Leich,
andGunterSaake.2017. MasteringsoftwarevariabilitywithFeatureIDE. Springer.
[39]NeilMitchell.2012. Shakebeforebuilding. ACMSIGPLANNotices 47(102012),
55. https://doi.org/10.1145/2398856.2364538
[40]AndreyMokhov,NeilMitchell,andSimonPeytonJones.2018. BuildsystemsÃ 
la carte.Proceedings of the ACM on Programming Languages 2, ICFP (2018), 1â€“29.
https://doi.org/10.1145/3236774
[41]VivekNair,ZheYu,TimMenzies,NorbertSiegmund,andSvenApel.2020.FindingfasterconfigurationsusingFLASH. IEEETrans.SoftwareEng. 46,7(2020),794â€“811.
https://doi.org/10.1109/TSE.2018.2870895
[42]Hung Viet Nguyen, Christian KÃ¤stner, and Tien N Nguyen. 2014. Exploring
variability-aware execution for testing plugin-based web applications. In Pro-
ceedingsofthe36thInternationalConferenceonSoftwareEngineering-ICSEâ€™14.
ACM, 907â€“918. https://doi.org/10.1145/2568225.2568300
[43]Ninja. Online; accessed 2022. A Small Build System with a Focus on Speed.
https://ninja-build.org/.
[44]Elnatan Reisner, Charles Song, Kin-Keung Ma, Jeffrey S Foster, and Adam Porter.
2010. Usingsymbolicevaluationtounderstandbehaviorinconfigurablesoftwaresystems.In Proceedingsofthe32ndACM/IEEEInternationalConferenceonSoftware
Engineering (ICSEâ€™10,Vol.1) .ACM,445. https://doi.org/10.1145/1806799.1806864
[45]AtriSarkar,JianmeiGuo,NorbertSiegmund,SvenApel,andKrzysztofCzarnecki.
2015. Cost-efficient sampling for performance prediction of configurable sys-
tems (T). In 2015 30th IEEE/ACM International Conference on Automated Software
Engineering (ASE). IEEE, 342â€“352. https://doi.org/10.1109/ASE.2015.45
[46]RobertW.SchwankeandGailE.Kaiser.1988. Smarterrecompilation. ACMTrans.
Program. Lang. Syst. 10, 4 (Oct. 1988), 627â€“632. https://doi.org/10.1145/48022.
214505
[47]Hyunmin Seo, Caitlin Sadowski, Sebastian Elbaum, Edward Aftandilian, and
Robert Bowdidge. 2014. Programmersâ€™ build errors: A case study (at Google). In
Proceedings of the 36th International Conference on Software Engineering (ICSE2014). ACM, New York, NY, USA, 724â€“734. https://doi.org/10.1145/2568225.
2568255
[48] Jiangfan Shi, Myra B. Cohen, and Matthew B. Dwyer. 2012. Integration Testing
of Software Product Lines Using Compositional Symbolic Execution. In Proceed-
ings of the 15th International Conference on Fundamental Approaches to Software
Engineering (LNCS, Vol. 7212). Springer, 270â€“284. https://doi.org/10.1007/978-3-
642-28872-2_19
1595
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:30:33 UTC from IEEE Xplore.  Restrictions apply. On the Benefits and Limits of Incremental Build of Software Configurations: An Exploratory Study ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
[49]NorbertSiegmund,AlexanderGrebhahn,SvenApel,andChristianKÃ¤stner.2015.
Performance-influence models for highly configurable systems. In Proceedings of
the 2015 10th Joint Meeting on Foundations of Software Engineering - ESEC/FSE
2015. ACM, 284â€“294. https://doi.org/10.1145/2786805.2786845
[50]Klaas-Jan Stol and Brian Fitzgerald. 2018. The ABC of software engineering
research. ACMTransactionsonSoftwareEngineeringandMethodology(TOSEM)
27, 3 (2018), 1â€“51. https://doi.org/10.1145/3241743
[51]Thomas ThÃ¼m, Sven Apel, Christian KÃ¤stner, Ina Schaefer, and Gunter Saake.
2014. Aclassificationandsurveyofanalysisstrategiesforsoftwareproductlines.
Comput. Surveys 47, 1 (2014), 6:1â€“6:45. https://doi.org/10.1145/2580950
[52]Walter F. Tichy. 1986. Smart recompilation. ACM Trans. Program. Lang. Syst. 8, 3
(June 1986), 273â€“291. https://doi.org/10.1145/5956.5959
[53]AlexandervonRhein,JÃ¶rgLiebig,AndreasJanker,ChristianKÃ¤stner,andSven
Apel.2018. Variability-awarestaticanalysisatscale:Anempiricalstudy. ACM
27, 4 (2018), 18:1â€“18:33. https://doi.org/10.1145/3280986
[54]Yangyang Zhao, Alexander Serebrenik, Yuming Zhou, Vladimir Filkov, and Bog-
dan Vasilescu. 2017. The impact of continuous integration on other software
development practices: a large-scale empirical study. In 2017 32nd IEEE/ACM
InternationalConferenceonAutomatedSoftwareEngineering(ASE).IEEE,60â€“71.
https://doi.org/10.1109/ASE.2017.8115619
1596
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:30:33 UTC from IEEE Xplore.  Restrictions apply. 