Improving Fault Localization and Program Repair with Deep
Semantic Features and Transferred Knowledge
Xiangxin Meng
SKLSDE Lab, Beihang University
Beijing, China
mengxx@act.buaa.edu.cnXu Wangâˆ—
SKLSDE Lab, Beihang University
Beijing, China
wangxu@act.buaa.edu.cnHongyu Zhang
The University of Newcastle
NSW, Australia
Hongyu.Zhang@newcastle.edu.au
Hailong Sun
SKLSDE Lab, Beihang University
Beijing, China
sunhl@act.buaa.edu.cnXudong Liu
SKLSDE Lab, Beihang University
Beijing, China
liuxd@act.buaa.edu.cn
ABSTRACT
Automaticsoftwaredebuggingmainlyincludestwotasksoffaultlo-
calizationandautomatedprogramrepair.Comparedwiththetradi-
tionalspectrum-basedandmutation-basedmethods,deeplearning-basedmethodsareproposedtoachievebetterperformanceforfaultlocalization.However,theexistingmethodsignorethedeepseman-
tic features or only consider simple code representations. They do
notleveragetheexistingbug-relatedknowledgefromlarge-scale
open-source projects either. In addition, existing template-based
programrepairtechniquescanincorporateprojectspecificinforma-tionbetterthandeep-learningapproaches.However,theyareweak
in selecting the fix templates for efficient program repair. In this
work,weproposeanovelapproachcalledTRANSFER,whichlever-
agesthedeepsemanticfeaturesandtransferredknowledgefrom
open-source data to improve fault localization and program repair.
First,webuildtwolarge-scaleopen-sourcebugdatasetsanddesign
11 BiLSTM-based binary classifiers and a BiLSTM-based multi-
classifier to learn deep semantic features of statements for fault
localization and program repair, respectively. Second, we combine
semantic-based,spectrum-basedandmutation-basedfeaturesand
use an MLP-based model for fault localization. Third, the semantic-
based features are leveraged to rank the fix templates for program
repair.Ourextensiveexperimentsonwidely-usedbenchmarkDe-
fects4J show that TRANSFER outperforms all baselines in fault
localization,andisbetterthanexistingdeep-learningmethodsin
automated program repair. Compared with the typical template-
based work TBar, TRANSFER can correctly repair 6 more bugs (47
in total) on Defects4J.
âˆ—Corresponding author: Xu Wang, wangxu@act.buaa.edu.cn.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACMmustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
Â© 2022 Association for Computing Machinery.
ACM ISBN 978-1-4503-9221-1/22/05...$15.00
https://doi.org/10.1145/3510003.3510147CCS CONCEPTS
â€¢Software and its engineering â†’Software verification and
validation.
KEYWORDS
Fault localization, program repair, transfer learning, neural net-
works, software debugging
ACM Reference Format:
XiangxinMeng,XuWang,HongyuZhang,HailongSun,andXudongLiu.
2022.ImprovingFaultLocalizationandProgramRepairwithDeepSemantic
FeaturesandTransferredKnowledge.In 44thInternationalConferenceon
Software Engineering (ICSE â€™22), May 21â€“29, 2022, Pittsburgh, PA, USA. ACM,
New York, NY, USA, 12 pages. https://doi.org/10.1145/3510003.3510147
1 INTRODUCTION
Fault localization (FL) and automated program repair (APR) are
two consecutive tasks for automatic software debugging. Fault
localizationprovidesthesuspiciousfaultlocationsandthenAPR
tries to repair them. Since 80% of the total software cost is spent
onfinding softwarefaults [ 46],fault localizationapproaches have
beenwidelystudiedtoreducetheheavyburdenondevelopers[ 2,5,
20,24,28,37,45,59,61,63,64].Faultlocalizationcanbeconducted
at different granularities, such as class [ 15,66], method [ 25,26,37],
and statement [ 1,28]. The finer the localization granularity is, the
easier the subsequent bug repair task would be. Thus we prefer
faultlocalizationatthestatementlevel.Basedonthelocatedfaulty
lines of code, many APR approaches have been proposed to fix the
faults [9, 14, 16, 17, 21â€“23, 27, 31â€“33, 35, 36, 39, 50, 55, 58, 67].
Traditionalfaultlocalizationapproaches,suchasspectrum-based
and mutation-based methods, adopt manually extracted featuresto locate suspicious code elements [
1,2,18,30,41,43,44,57,61â€“
63].Spectrum-basedfaultlocalization(SBFL)producesasuspicious
score for each code element (i.e., class, method or statement) by
performingstatisticalanalysisoffailed/passedtestcases.Mutation-
based fault localization (MBFL) applies specific mutation operators
to the original code elements and analyzes the execution of themutants. Besides SBFL and MBFL, other features including code
complexity,codechangefrequency,andtextsimilarityarealsolever-
agedtoimprovefaultlocalization[ 25,28,51].Hybridapproaches
have also been proposed to combine multiple suspicious scores
from different FL techniques [26, 59].
11692022 IEEE/ACM 44th International Conference on Software Engineering (ICSE)
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:21:06 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Xiangxin Meng, Xu Wang, Hongyu Zhang, Hailong Sun, and Xudong Liu
Recently, deep learning-based approaches, such as DeepFL [ 25]
andDeepRL4FL[ 28],areproposedforfaultlocalizationandhave
achieved promising results.DeepFLimproves fault localization by
integratingmorethan200featuresfromspectrum-based,mutation-
based,complexity-based,andtextualsimilarityfeatures.DeepRL4FLimprovesfaultlocalizationperformanceatthestatementandmethod
level by incorporating representation learning of code coverage,
datadependency,andcodesemantic.However,theseapproaches
have two major limitations. First, although deep semantic infor-mation has been proven to be effective in code representation
[3,4,42,49,53,54,56,60,65],thedeepsemanticfeaturesofsource
codeareignoredbyDeepFL,andDeepRL4FLonlyconsiderssim-
ple semanticrepresentation by thefully connected layerafter the
concatenation of word embeddings at the statement level; second,
although the bug-related knowledge extracted from historical bug
reports and bug-fix commits is helpful for bug detection [ 29,47],
theexistingapproacheslargelyignoresuchbug-relatedknowledge.
In this work, we consider the deep semantic features of source
code and the transferred knowledge from open-source bug data to
further improve fault localization.
Having obtained the suspicious code returned by FL techniques,
the template-based repair methods are widely used for automated
program repair [ 9,14,16,21â€“23,31,32,35,36,50,55,58]. These
methods utilize fix templates predefined or extracted from similar
code snippets to repair specific bugs. Among them, TBar [ 32] uses
15 manually-extracted common fix templates and selects them one
byoneinapredefinedimmutableordertogeneratepossiblepatches.
Recently,theencoder-decoderbasedneuralprogramrepairtech-
niqueshavebeenpresentedtogeneratecoderepairpatchesbeyond
predefined templates [ 7,17,27,39,52]. However, they intend to
produce the frequent repair patterns and words in the training set
andignoretheprojectspecificinformation[ 67].Recoder[ 67]learns
syntax-guided edits (i.e., templates) and replaces placeholders with
possible project specific identifiers to optimize neural programrepair. Since template-based APR methods naturally adopt local
informationinfillingtemplates,weleveragethedeepsemanticfea-
tures and transferred knowledge to help select better fix templates
for efficient repair and remove plausible but incorrect patches.
In this work, we propose TRANSFER, a novel deep learning-
basedapproachtofaultlocalizationandprogramrepairbyincorpo-
rating the deep semantic features and transferred knowledge from
the large-scale open-source bug datasets. More specifically:
1)Weconstructtwolarge-scalebugdatasetscollectedfromhigh-
quality GitHub projects to learn bug-related knowledge for fault
localization( ğ·ğ‘ğ‘¡ğ‘ğ‘ ğ‘’ğ‘¡ ğ‘“ğ‘™)andautomatedprogramrepair( ğ·ğ‘ğ‘¡ğ‘ğ‘ ğ‘’ğ‘¡ ğ‘ğ‘Ÿ),
respectively. We choose 11 kinds of bug-fix templates from TBar
[32]basedonthebugpopularityandtreatthemasthepossiblebug
types. Based on these 11 bug types, we then build 11 datasets con-
sistingof785,134samplesasourfaultlocalizationdataset ğ·ğ‘ğ‘¡ğ‘ğ‘ ğ‘’ğ‘¡ ğ‘“ğ‘™.
We also use 408,091 bug-fix commits and their bug types to con-
structourprogramrepairdataset ğ·ğ‘ğ‘¡ğ‘ğ‘ ğ‘’ğ‘¡ ğ‘ğ‘Ÿ.Foreachbugtype,we
train a BiLSTM-based binary classifier to predict whether or notonemethodcontainsabugofthistypeinaspecificlocation.We
also train a BiLSTM-based multi-classifier model to predict which
fixtemplateshouldbetriedtorepaironesuspiciousstatement.Thelearnedclassifierswillbereusedtotransferbug-relatedknowledge
to target projects.2)Forthefaultlocalizationtask(TRANSFER-FL),weextracteach
statementanditscontextualmethodofatargetprojecttoobtain
itsdeepsemanticfeaturesbyperformingthe11binaryclassifiers
trainedonğ·ğ‘ğ‘¡ğ‘ğ‘ ğ‘’ğ‘¡ ğ‘“ğ‘™.Thesemanticfeatures,togetherwithexisting
spectrum-basedandmutation-basedfeatures,arefurtherusedto
train an MLP-based (Multi-layer Perceptron) ranking model for all
statements.Inthisway,wegeneratethesuspiciousscoreofeach
statementfromtheMLP-basedrankingmodelforfaultlocalization.
3) For the program repair task (TRANSFER-PR), based on the
BiLSTM-based multi-classifier trained on ğ·ğ‘ğ‘¡ğ‘ğ‘ ğ‘’ğ‘¡ ğ‘ğ‘Ÿas the trans-
ferredknowledge,wefurtherfine-tunethemodelparameterson
the target project. Given an unseen and faulty statement, the 11-
dimensionvectoroutputbythemulti-classifierrepresentstheprob-
abilities for selecting the corresponding fix template. The selection
orderoffixtemplatesbasedontheseprobabilitiesisusedtoimprove
program repair.
Weconductextensiveexperimentson395realsoftwarefaults
fromthewidelyusedDefects4Jbenchmark[ 19](V1.2.0)toevaluate
our proposed approach. The experimental results show that, for
thefaultlocalizationtask,ourFLmethod(TRANSFER-FL)signifi-
cantlyoutperformsallbaselinesincluding3typicalspectrum-based
methods, 1 mutation-based method and 2 recent deep learning-
basedmethods.Specifically,ourapproachincreasesthefaultshit
by 13/16/29 on Top-1/3/5, respectively. For the automated program
repairtask,ourAPRmethod(TRANSFER-PR)outperformsboththe
state-of-the-art template-based repair technique TBar [ 32] and the
state-of-the-art deep learning-based repair technique CURE [ 17].
ComparedwiththestrongbaselineTbar,TRANSFER(thecombi-
nation of FL and PR) canwork together to correctly repair 6 more
bugs (47 in total) on Defects4J.
The main contributions of this paper are as follows:
â€¢We build two large-scaleopen-source bug datasets, andde-
signBiLSTM-basedclassifierstolearndeepsemanticfeatures
of statements for fault localization and program repair.
â€¢WeproposeTRANSFER,whichleveragesthesemantic-based,
spectrum-based,andmutation-basedfeaturesforeffective
fault localization and leverages the semantic-based features
for effective program repair.
â€¢We conduct extensive experiments on widely-used bench-mark Defects4J to evaluate our approach, and the experi-
mental results confirm that our approach is effective.
2 RELATED WORK
Learning-basedFaultLocalization. Learning-to-Rank[ 34]isan
importantapproachininformationretrievalarea,whichutilizessu-
pervised machine learning to solve ranking problems. Some recent
studies apply the Learning-to-Rank strategy to fault localization
[5,26,51,59],whichtakesmultiplefeaturesasinputsfromdifferent
sources,suchassuspiciousscoresfromSBFLandMBFLtechniques.
Amongthem,thepairwisetrainingisfrequentlyusedtorankfaulty
elements before correct ones. Recently, deep learning-based ap-
proachesareproposed,suchasDeepFL[ 25]andDeepRL4FL[ 28],
which achieve promising results for fault localization. DeepFL im-
provesfaultlocalizationbyintegratingmorethan200featuresfrom
four traditional feature groups but misses the deep semantic fea-tures. DeepRL4FL combines a coverage representation approach
1170
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:21:06 UTC from IEEE Xplore.  Restrictions apply. Improving Fault Localization and Program Repair with Deep Semantic Features and Transferred Knowledge ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
with code representation learning for fault localization, which sim-
plyusesthefullyconnectedlayerwiththeconcatenationmatrix
of word embeddings at the statement level. Both deep learning-based methods have not captured the deep semantic features of
source code well, especially the sequential dependencies of tokens,
whichlimits theeffectiveness ofstatement-level faultlocalization.
Grace[38] is another deep learning-based method which leverages
GNNs(GatedGraphNeuralNetworks)tolearnvaluablefeatures
fromthegraph-basedcoveragerepresentation.However,itremoves
all children nodes of the statement structures of ASTs (Abstract
SyntaxTrees),whichisusefulformethod-levelFLbutmissesthe
statement-level semantics. Moreover, the method-level fault local-
ization effectivenessof Grace isworse thanDeepRL4FL, so itis not
included in our fault localization experiments.
Template-basedprogramrepair. Template-basedprogramre-
pair approach is a widely studied researcharea in APR, which uti-
lizespredefinedfixtemplatestofixspecificbugs.Therepairprocess
can be basically divided into four steps, i.e., fault localization, fix
template selection, donor code search, and patch candidate valida-
tion.Thefirst3stepsofthemdeterminethefinaleffectivenessof
the corresponding repair technique. Typical template-based pro-
gram repair techniques include TBar [ 32], Simfix [ 16], Avatar [ 31],
FixMiner [ 21] and so on. Among them, TBar [ 32] is the state-of-
the-art template-based repair technique, which contains 15 com-
monly used fix templates and achieves a good performance on the
benchmark Defects4J [ 19]. However, the approach of fix template
selection has not been well studied, which influences the entire
program repair task.
Deeplearning-basedprogramrepair. Recently,somestudies
treat the program repair task as a statistical machine translationtask, and adoptthe widely-used encoder-decoder architecture to
learn to generate possible patches. DLFix [ 27] proposes an efficient
way to embed the contextual information into the faulty statement.
CoCoNuT[ 39]combinesCNNs(ConvolutionalNeuralNetworks)
andanewcontext-awareneuralmachinetranslationarchitectureto
generate patches token by token. CURE [ 17] pre-trains a language
modeltoextractbug-fixknowledgeandproposeanewcode-aware
search strategy to reduce the search space. Recoder [ 67] learns
syntax-guided edits (i.e., templates) and replaces placeholders with
possible project specific identifiers to optimize neural program
repair.Nevertheless,theprojectspecificinformationishardtolearn
andthefrequentrepairpatternsandwordsappearingintraining
sets are more likely to be selected. In contrast, template-based APRmethodsnaturallyadoptlocalinformationtofilltemplates,butthey
cannot effectively select fix templates. In this work, we address thetemplate selection problem by learning useful semantic knowledge
fromopensourcecode,whileretainingtheadvantagesoftemplate-
basedtechniques.Therecentdeeplearning-basedprogramrepair
methodsincludingDLFix[ 27],CoCoNuT[ 39]andCURE[ 17]ar e
used as baselines in this paper.
3 PROPOSED APPROACH
3.1 Overview
In order to improve the performance of statement-level fault local-
ization and automated program repair, the deep semantic features
of statements and the transferred knowledge from large-scale bugdatasetsareleveraged inourapproach.Asshownin Figure1,our
approach,TRANSFER,mainlyincludesthreecomponents.Thefirst
component(Section3.2)isdesignedtolearntransferredbug-related
knowledge from our two large-scale open-source bug datasets,
which includes 11 different binary classifiers to detect whether one
statementhascorrespondingbugsandonemulti-classifiertopre-
dictwhichfixtemplateshouldbeusedforafaultystatement.Based
on the transferred knowledge, the second component (TRANSFER-
FL, Section 3.3) aims to improve fault localization with the deep
semanticfeatures,andthethirdcomponent(TRANSFER-PR,Sec-
tion 3.4) can improve automated program repair by predicting the
order of fix templates to be used.
3.2 Learning Transfer Knowledge
3.2.1 ExtractionofBug-FixCommitsforDifferentBugTypes. We
firstcollectandanalyzealargenumberofhistoricalbug-fixcom-
mits in open source projects. Specifically, we collect 2,000 open
source Java projects with most stars on GitHub. Four projects (i.e.,
Joda-Time,Closurecompiler,Apachecommons-lang,andApache
commons-math)areremovedfromthecollectedprojectsbecause
theyalso existinthe targetbenchmark(i.e., Defects4J).Weutilize
theapproachdescribedin[ 48]toextractallcommitsrelevanttobug
fix. Specifically, a commit is considered bug-relevant if its message
contains keywords such as "error", "bug", â€œfixâ€, â€œissueâ€, "mistake",
"incorrect","fault","defect","flaw","type",etc.Wekeepthecommitsthatmodifycodeinonlyonemethod,andintotal1,010,628commits
are collected.
Wethenidentifybugtypesfromthebug-fixcommits.Giventhat
theextractedcommitsarerelatedtobugfix,ifthecodemodifica-
tionsofacommitmatchthechangeactionsdefinedinaspecificfix
template, the code element before this commit is made is consid-
ered to contain the corresponding type of bugs. A fix template [ 32]
definesapatternofcodemodifications,whichisappliedtoafaulty
code element to help generate possible patches. If a buggy code
elementğ‘isrepairedafterapplyingthefixtemplate ğ‘“ğ‘¡,wesaythat
ğ‘containsbugswithatypecorrespondingto ğ‘“ğ‘¡.Wecollectall15
fix templates defined in TBar [ 32], and the corresponding bug type
of each fix template is shown in Table 1.
We implement an AST-based (Abstract Syntax Tree) syntax
checkerthroughanAST-basedcodedifferencingalgorithm(similar
toGumTree[12])andarule-basedmatchingtoolthatmatchesthe
edits to the fix templates shown in Table 1. On the one hand, once
a fix template is identified, the code element before the commitis tagged with the corresponding bug type. Note that a commitmay match multiple fix templates, because the predefined codechange actions in different fix templates may overlap. As the ex-ample shown in Table 2, both Mutate Conditional Expression and
MutateVariable fixtemplatesarematched,whiletheformerconsid-
ersthemodificationfrom ğ‘>=ğ‘toğ‘>=ğ‘andthelatterconsiders
that fromğ‘toğ‘. On the other hand, if no fix template is identified,
the commit will be discarded. Simultaneously, we mark the startline of the statement where modification is located as the faulty
position. Still taking Table 2 as an example, the line 2 is marked as
faulty position because it is the start line of the If Statement which
wraps the modification. To verify the correctness of the labeling
1171
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:21:06 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Xiangxin Meng, Xu Wang, Hongyu Zhang, Hailong Sun, and Xudong Liu
Figure 1: An Overview of TRANSFER
process using our syntax checker, we have randomly sampled 100
results, and checked that they are all accurate.
Afterapplying thesyntax checker,wefind thatthe numbersof
commits corresponding to 4 bug types are very small (less than
100),whicharedifficulttobeutilizedforthesubsequentlearning
tasks,soweonlystudytheremaining11bugtypes(showninTable
4) in this paper. In total, 408,091 commits are extracted with the
annotations of bug types and faulty positions.
3.2.2 Dataset Construction.
1) Construction of ğ·ğ‘ğ‘¡ğ‘ğ‘ ğ‘’ğ‘¡ ğ‘“ğ‘™.Having collected the bug-fix com-
mits tagged with bug types, we assign each commit to one or more
groups (11 in total) according to its bug type(s). Then, for each
group, we further extract all the methods before the commits were
made as the positive samples. Each positive sample consists of
two parts: 1)the faulty statement,which marked with <BOS>and
<EOS>, and2) the contextualmethod ofthe faulty statement.The
first column in Table 3 gives the positive sample to the commit
inTable2for MutateVariable fixtemplate.Inthisexample,since
the faulty code element is the variable ğ‘in line 2, whose nearest
statement-typeancestoristheifstatementwrappingit.Thus,we
addthemarks<BOS>and<EOS>atthestartandendpositionof
line 2 respectively. Since the commit is also tagged with the bug
type corresponding to Mutate Conditional Expression, for this fix
template, the generated positive sample is the same as that of Mu-
tate Variable, because the nearest statement-type ancestor of the
faulty code element ğ‘>=ğ‘is also the if statement.
Tocollectthenegativesamples,weproposeanewapproach.We
firstlookforanotherstatementinthesamemethod,whichcontains
the same necessary syntax ingredients as the positive sample. Thenecessarysyntaxingredientsforeachfixtemplate(bugtype)areunderlinedinthesecondcolumninTable1.Ifnosuchstatement
is found in the method, we will expand the scope and continue
searchinginthesameJavafile.Wecollectallstatementscontaining
thenecessarysyntaxingredientsandthecorrespondingmethods
theybelongtoasnegativesamplecandidates,andthenselectoneofthemrandomly.However,ifnosuitablenegativesamplesarefound,
the corresponding positive samples will be discarded in order to
constructabalanceddataset.ThesecondcolumninTable3showsa
negativesamplecorrespondingtothealreadygeneratedpositive
sample in the first column for Mutate Variable fix template. The
necessarysyntaxingredientof MutateVariable isavariablecode
element, as long as a statement contains at least one variable, itcan be selected and marked to generate a negative sample. Thus,
bothğ‘Ÿğ‘’ğ‘¡ğ‘¢ğ‘Ÿğ‘›ğ‘;andğ‘Ÿğ‘’ğ‘¡ğ‘¢ğ‘Ÿğ‘›ğ‘;statementscanbemarked.Afterthe
random selection, the former is finally marked and the negative
sample is generated.
Finally, 11 datasets containing 392,567 positive samples and the
samenumberofnegativesamples(785,134intotal)areconstructed
for the subsequent fault localization task (the detailed statistics are
shown in Table 4), which are called collectively as ğ·ğ‘ğ‘¡ğ‘ğ‘ ğ‘’ğ‘¡ ğ‘“ğ‘™.
2) Construction of ğ·ğ‘ğ‘¡ğ‘ğ‘ ğ‘’ğ‘¡ ğ‘ğ‘Ÿ.For program repair, given a faulty
statement, our goal is to select the correct fix templates to repair it,
which can be regarded as a multi-classification task. Thus, for each
commit extracted in Section 3.2.1, we only keep the method before
thecommitwasmadeandcategorizeitintooneofthe11predefined
bug types. As a bug-fix commit can be tagged with one or morebug types, we assign it to the bug type that is deeper in the AST
hierarchy.Intuitively,adeeperASTnodeneedsarelativelysimpler
1172
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:21:06 UTC from IEEE Xplore.  Restrictions apply. Improving Fault Localization and Program Repair with Deep Semantic Features and Transferred Knowledge ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
Table 1: 15 Fix Templates and the Corresponding Bug Types
Fix Templates Corresponding Bug Types
Insert Cast Checker At least one cast expression exists without checking the compatibility of the original type and the cast type.
Insert Range Checker At least one array (collection) access exists without checking whether the index (key) is beyond the scope.
Insert Null Pointer Checker At least one field (expression) is used without checking if it has a nulltype.
Insert Missed Statement Missing a specific type of statement including method invocation/return/if/try-catch statement.
Mutate Conditional Expression A conditional expression should be added, removed or modified.
Mutate Data Type The data type used in cast expression or variable declaration expression is incorrect.
Mutate Literal Expression The literal expression used in the statement is incorrect.
Mutate Method Invocation Expression The name or at least one of the parameters of the method invocation expression is incorrect.
Mutate Class Instance Creation ğ‘ ğ‘¢ğ‘ğ‘’ğ‘Ÿ.ğ‘ğ‘™ğ‘œğ‘›ğ‘’ ()method should be used rather creating a new class instance in an overridden clone method.
Mutate Integer Division Operation An integer literal is used in division operation and results in the loss of accuracy.
Mutate Operators At least one relational/arithmetic/instanceof/parentheses operator is incorrectly used.
Mutate Return Statement The expression in return statement is incorrect.
Mutate Variable The variable used in the statement is incorrect.
Move Statement A statement is placed in an incorrect position.
Remove Buggy Statement A statement should not appear in the current position and is expected to be removed.
Table2:AJavaCodeExampleBeforeandAftertheCommit
Method Before Commit Method After Commit
1
23456public int max(int a, int b) {
if (a >=a){
return a;
}return b;
}public int max(int a, int b) {
if (a >=b){
return a;
}return b;
}
Table 3: An Example Pair of Positive and Negative samples
for the fix template Mutate Variable
Positive Sample Negative Sample
123456public int max(int a, int b) {<BOS> if (a >= a
) { <EOS>
return a;
}return b;
}public int max(int a, int b) {
if (a >=a){
<BOS> return a; <EOS>}return b;
}
repairtemplatewithasmallerchangearea,whichispreferredby
actual developers. For example, for the method (before the commit
wasmade)showninTable2,thecorrespondingASTisconstructed
inFigure2.Wecanseethatthecodeelementfocusedonby Mutate
Conditional Expression is the conditional expression node whose
depthis4,whilethecodeelementfocusedonby MutateVariable is
the variable node ğ‘(the child of Right Operand node ) whose depth
is 7. Thus, the Mutate Variable should be selected as the unique
label because it focuses on a deeper AST node.
Inthisway,weconstructadatasetwith11categoriesand408,091
samplesintotal,whichiscalled ğ·ğ‘ğ‘¡ğ‘ğ‘ ğ‘’ğ‘¡ ğ‘ğ‘Ÿ.Eachsampleconsistsofa
faultystatementwiththecontextualmethodanditscorresponding
bug type. The detailed statistics are shown in Table 4.Table 4: Statistics of ğ·ğ‘ğ‘¡ğ‘ğ‘ ğ‘’ğ‘¡ ğ‘“ğ‘™andğ·ğ‘ğ‘¡ğ‘ğ‘ ğ‘’ğ‘¡ ğ‘ğ‘Ÿ, where positive
and negative samples are seperated by the slashes.
Fix Templates#Samples
inğ·ğ‘ğ‘¡ğ‘ğ‘ ğ‘’ğ‘¡ ğ‘“ğ‘™#Samples
inğ·ğ‘ğ‘¡ğ‘ğ‘ ğ‘’ğ‘¡ ğ‘ğ‘Ÿ
Insert Null Pointer Checker 5660/5660 7600
Insert Missed Statement 47120/47120 54445
Mutate Conditional Expression 31167/31167 30530
Mutate Data Type 3293/3293 5178
Mutate Literal Expression 35536/35536 55044
Mutate Method Invocation Expr. 198754/198754 166943
Mutate Operators 1673/1673 2326
Mutate Return Statement 12511/12511 20680
Mutate Variable 29918/29918 35156
Move Statement 7313/7313 7812
Remove Buggy Statement 19622/19622 22377
Total 392567/392567 408091
Figure 2: An Example to Illustrate the Selection of theUnique Bug Type
1173
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:21:06 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Xiangxin Meng, Xu Wang, Hongyu Zhang, Hailong Sun, and Xudong Liu
3.2.3 Learning Knowledge for Fault Localization.
1) The design of binary classifiers. We build 11 Bi-LSTM based
binaryclassifierswithsamestructurestojudgewhetherthebugs
withcorrespondingbugtypeexistinthecodeornot.Theoverall
architectureofthemodelisshowninFigure3.Sincewearestudying
statement-level fault localization, the input of the model is a token
sequence <ğ‘¡1,ğ‘¡2,...,ğ‘¡ğ‘>including the specified statement and
its contextual method, where ğ‘represents the length of the token
sequence. Then, the token sequence is fed into an embedding layer
withthepre-trainedword2vec[ 40]parameters ğ‘Šğ‘’âˆˆR|ğ‘‰|Ã—ğ‘‘where
ğ‘‰is the vocabulary size and ğ‘‘is the embedding dimension of each
token, to generate a sequence of token vectors <ğ‘’1,ğ‘’2,...,ğ‘’ğ‘>.
The vector representation ğ‘’ğ‘˜of tokenğ‘¡ğ‘˜can be obtained by:
ğ‘’ğ‘˜=ğ‘Šğ‘’Tğ‘¥ğ‘˜ (1)
whereğ‘¥ğ‘˜istheone-hotrepresentationoftoken ğ‘¡ğ‘˜.Next,weutilize
LSTM [13], one type of recurrent neural network, to extract the
contextualsemanticfeaturescontainingtokensequentialdependen-
cies, while the fully connected layer after the concatenation matrix
of token embeddings used in DeepRL4FL [ 28] in statement-level
fault localization cannot extract such dependency relationships.
Inordertoobtainricherdependencyinformationamongtokens,
we adopt a bidirectional LSTM (Bi-LSTM), the output of which is a
new state generated by concatenating the hidden states from both
directions at time ğ‘¡:
âˆ’ â†’â„ğ‘¡=âˆ’âˆ’âˆ’âˆ’â†’ğ¿ğ‘†ğ‘‡ğ‘€(ğ‘’ğ‘¡),â† âˆ’â„ğ‘¡=â†âˆ’âˆ’âˆ’âˆ’ğ¿ğ‘†ğ‘‡ğ‘€(ğ‘’ğ‘¡),â„ğ‘¡=[âˆ’ â†’â„ğ‘¡,â† âˆ’â„ğ‘¡](2)
Toextractthemostimportantfeaturesforeachdimension,wekeep
the hidden states of all time steps, which are then pushed into a
stack and sampled by max pooling. We assume that the result after
processing of max pooling is ğ‘”, which is calculated as follows:
ğ‘”=[max
1â‰¤ğ‘¡â‰¤ğ‘(â„ğ‘¡1),max
1â‰¤ğ‘¡â‰¤ğ‘(â„ğ‘¡2),...,max
1â‰¤ğ‘¡â‰¤ğ‘(â„ğ‘¡Â·2ğ‘š)](3)
whereğ‘šrepresents the dimension of hidden states. Finally, we
putğ‘”into a dense layer with ğ‘ ğ‘œğ‘“ğ‘¡ğ‘šğ‘ğ‘¥ activation function, and the
output indicates the probability of containing the corresponding
type of bugs, which is exactly the semantic feature we need.
2)Trainingthebinaryclassifiers. Wedividethetrainingtaskinto
two phases. In the first phase, for each of the 11 bug types, weuse
ğ·ğ‘ğ‘¡ğ‘ğ‘ ğ‘’ğ‘¡ ğ‘“ğ‘™for model training, after which the optimal model
parameters are saved. We call the knowledge learned in this phase
astransferredknowledge.Inthesecondphase,eachsuspiciousstate-
mentwithitscontextualmethodintargetdatasetsisinputintothe
trained models to obtain 11 deep semantic features. In addition, as
mentioned above, the annotated statements in both positive and
negativesamplesin ğ·ğ‘ğ‘¡ğ‘ğ‘ ğ‘’ğ‘¡ ğ‘“ğ‘™mustcontainthenecessarysyntax
ingredientsforitscorrespondingbugtype.Therefore,inthesecond
phase, for each suspicious statement in target projects, we first
judgewhetherthe statementcontainsthenecessarysyntaxingre-
dientsrequiredbyeachbugtype.Ifitdoes,thisstatementandits
contextual method will be input into the binary classifier for the
corresponding bug type to obtain the output probability, otherwise
theprobabilityissetto0ifthenecessarysyntaxingredientsmiss.
In this way, the 11-dimension deep semantic features are extracted
for all suspicious statements in target projects, which will be used
in the subsequent fault localization task.
Figure 3: Bi-LSTM based Binary Classifier Model for Learn-ing Transfer Knowledge for Fault Localization
3.2.4 Learning Knowledge for Program Repair. For selecting cor-
rect fix templates to enhance the existing template-based program
repairapproaches,webuildaBiLSTM-basedmulti-classifier,whosearchitectureisthesameasthebinaryclassifierdescribedinSection
3.2.3,exceptthedimensionoftheoutputlayer,whichischanged
from 2 to 11 (i.e., the number of bug types). We feed the large-scale
ğ·ğ‘ğ‘¡ğ‘ğ‘ ğ‘’ğ‘¡ ğ‘ğ‘Ÿintothemulti-classifierformodeltraining,andinthis
way, the transferred knowledge for judging which fix templates
shouldbeselectedfirsttogeneratepatchesislearned,whichcan
be used for the subsequent program repair task.
3.3 TRANSFER-FL: Effective Fault Localization
based on Transferred Knowledge
3.3.1 Spectrum-based and Mutation-based Features.
1) Spectrum-based Features. Spectrum-based fault localization
(SBFL) is one of the most widely studied fault localization ap-
proaches.SBFLapproachestakesourcecodeandrelevanttestcases
as inputs, and output a sorted list of code elements ordered by sus-
piciousscores,whicharecalculatedfromtheexecutioninformation
of test cases. It has been found that the results of SBFL approaches
can serve as part of input features for training learning-to-rankmodels in some recent studies [
16,21,31,33]. Learning-to-rank
approaches have been proved to help better fault localization byoptimizing the combination of features [
26,51]. In this work, we
adopt the learning-to-rank method and select 3 most commonlyused SBFL techniques (i.e., Tarantula [
18] , Ochiai [ 1] and DStar
[57]) to generate features for the spectrum-based feature group.
TheequationsofcalculatingsuspiciousscoresforthethreeSBFL
techniquesareasfollows,where ğ‘‡ğ‘“(ğ‘’)/ğ‘‡ğ‘(ğ‘’)representsthenumber
offailed/passed testsexecutingcodeelement ğ‘’,whileğ‘‡ğ‘“(Â¯ğ‘’)/ğ‘‡ğ‘(Â¯ğ‘’)
represents the number of failed/passed tests that do not execute ğ‘’,
andğ‘‡ğ‘“/ğ‘‡ğ‘represents the number of all failed/passed tests.
ğ‘‡ğ‘ğ‘Ÿğ‘ğ‘›ğ‘¡ğ‘¢ğ‘™ğ‘ :ğ‘†ğ‘¢ğ‘ (ğ‘’)=ğ‘‡ğ‘“(ğ‘’)/ğ‘‡ğ‘“
ğ‘‡ğ‘“(ğ‘’)/ğ‘‡ğ‘“+ğ‘‡ğ‘(ğ‘’)/ğ‘‡ğ‘(4)
1174
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:21:06 UTC from IEEE Xplore.  Restrictions apply. Improving Fault Localization and Program Repair with Deep Semantic Features and Transferred Knowledge ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
ğ‘‚ğ‘â„ğ‘–ğ‘ğ‘–:ğ‘†ğ‘¢ğ‘ (ğ‘’)=ğ‘‡ğ‘“(ğ‘’)
/radicalBig
ğ‘‡ğ‘“Â·(ğ‘‡ğ‘“(ğ‘’)+ğ‘‡ğ‘(ğ‘’))(5)
ğ·ğ‘†ğ‘¡ğ‘ğ‘Ÿ:ğ‘†ğ‘¢ğ‘ (ğ‘’)=ğ‘‡ğ‘“(ğ‘’)âˆ—
ğ‘‡ğ‘(ğ‘’)+(ğ‘‡ğ‘“(Â¯ğ‘’))(6)
2) Mutation-based Features. Mutation-based fault localization
(MBFL) is another approach which calculates suspicious scores by
analyzing the changes of execution results between the original
codeelementanditsmutants.SimilartoSBFL,theoutputsofMBFL
approaches can also serve as input features for learning-to-rank
models [25,26]. MBFL approaches need to additionally specify the
set of mutation operators as well as the granularities of failure out-
puts/messages. We adopt the four types of granularities proposed
by TraPT [ 26]: (1) passed/failed information, (2) exception type
information, (3) exception type and message, (4) exception type,
message and the full stack trace of exception.
As described in Metallaxis [ 44], the formulae from SBFL ap-
proaches can be utilized to calculate suspicious scores for mutants,
and the highest score among all mutants is then selected as the
suspicious score of the corresponding original code element. Equa-
tion 7 takesOchiai algorithm as anexample,where ğ‘€(ğ‘’)denotes
all mutants of code element ğ‘’,ğ‘‡(ğ‘š)
ğ‘“(ğ‘’)denotes the number of
originally failed tests which are impacted by mutant ğ‘š,ğ‘‡(ğ‘š)
ğ‘(ğ‘’)
denotes the number of originally passed tests whichare impacted
by mutantğ‘š, and so on. We choose the frequently-used Ochiai
algorithm for Metallaxis to extract the mutation-based features.
Finally, 4 mutation-based features are extracted because 4 types of
granularities are considered which are mentioned above.
ğ‘†ğ‘¢ğ‘ (ğ‘’)=max
ğ‘šâˆˆğ‘€(ğ‘’)ğ‘‡(ğ‘š)
ğ‘“(ğ‘’)
/radicalbigg
ğ‘‡(ğ‘š)
ğ‘“Â·(ğ‘‡(ğ‘š)
ğ‘“(ğ‘’)+ğ‘‡(ğ‘š)
ğ‘(ğ‘’))(7)
3.3.2 DeepSemanticFeatures. Bothsuspiciousscoresgenerated
by SBFL and MBFL approaches can be used as input features for
alearning-to-rankmodeltoimprovetheeffectivenessoffaultlo-
calization. However, the semantic features have not been included
yet,whichcanprovideusefulinformationfromadifferentaspect.
Infaultlocalizationresearcharea,especiallywhenprogramdata
iscompilableandexecutable,thedynamicexecutioninformation
is still the most frequently used feature [ 25,26,51]. In contrast,
the use of static semantic features is relatively preliminary, such
as DeepRL4FL [ 28], which simply uses the fully connected layer
withtheconcatenationmatrixofwordembeddingsatthestatement
level. Therefore, our goal is to propose a more effective way of ex-
tractingand utilizingcontextualsemanticsto furtherimprovethe
effectiveness of fault localization. As described in Section 3.2.3, we
have obtained the 11-dimension deep semantic feature of each sus-
picious statement in the target dataset by applying the transferred
knowledge learned from the large-scale ğ·ğ‘ğ‘¡ğ‘ğ‘ ğ‘’ğ‘¡ ğ‘“ğ‘™.
3.3.3 Faultlocalizationwithtransferredknowledge. Throughthe
abovesteps,threefeaturegroupsareobtained,including3spectrum-
based features, 4 mutation-based features and 11 deep semantic
features.Wecancombinethesefeaturesinalearning-to-rankmodelto predict the probability of being faulty for each suspicious state-
ment in the target project. Compared with the task in Section 3.2.3
tojudgewhetherasuspiciousstatementcontainsbugswithspecific
types,thecurrenttaskcanalsoberegardedasabinaryclassifica-
tion task to judge whether bugs exist in a suspicious statementno matter what bug type it is. Thus, a model based on the MLP
(Multi-Layer Perceptron) architecture is designed to achieve this
goal, which is shown in Figure 4. Before fed into the model, the
spectrum-basedandmutation-basedfeaturesarenormalizedbythe
ranking positions, because the suspicious scores before normaliza-
tionarenotnecessarilyintherange [0,1),whilethedeepsemantic
features are. The equation of calculating the normalized score of
suspicious statement ğ‘’is as follows:
ğ‘†ğ‘¢ğ‘ (ğ‘’)=1âˆ’ğ‘–ğ‘›ğ‘‘ğ‘’ğ‘¥(ğ‘’)
ğ‘™ğ‘’ğ‘›(ğ‘ ğ‘¢ğ‘ ğ‘ğ‘–ğ‘ğ‘–ğ‘œğ‘¢ğ‘  _ğ‘™ğ‘–ğ‘ ğ‘¡)(8)
whereğ‘ ğ‘¢ğ‘ ğ‘ğ‘–ğ‘ğ‘–ğ‘œğ‘¢ğ‘  _ğ‘™ğ‘–ğ‘ ğ‘¡isasortedlistcontainingallsuspiciousstate-
ments in the target project. It is sorted according to the suspi-cious score before normalization of each statement from biggestto smallest. Function
ğ‘™ğ‘’ğ‘›(ğ‘ ğ‘¢ğ‘ ğ‘ğ‘–ğ‘ğ‘–ğ‘œğ‘¢ğ‘  _ğ‘™ğ‘–ğ‘ ğ‘¡)returns the length of
ğ‘ ğ‘¢ğ‘ ğ‘ğ‘–ğ‘ğ‘–ğ‘œğ‘¢ğ‘  _ğ‘™ğ‘–ğ‘ ğ‘¡,andfunction ğ‘–ğ‘›ğ‘‘ğ‘’ğ‘¥(ğ‘’)returnsthepositionwhere
the suspicious score of ğ‘’last appears in the ğ‘ ğ‘¢ğ‘ ğ‘ğ‘–ğ‘ğ‘–ğ‘œğ‘¢ğ‘  _ğ‘™ğ‘–ğ‘ ğ‘¡. For
example, if ğ‘ ğ‘¢ğ‘ ğ‘ğ‘–ğ‘ğ‘–ğ‘œğ‘¢ğ‘  _ğ‘™ğ‘–ğ‘ ğ‘¡contains 5 statements {ğ´,ğµ,ğ¶,ğ·,ğ¸ },
andthecorrespondingsuspiciousscoresare {2.0,1.0,0.5,0.5,0.2},
then the normalized scores of the five statements are calculated as
{0.8,0.6,0.2,0.2,0.0}.Thus,thethreegroupsofnormalizedfeatures
can now be fed into the model. Since the number of features indeep semantic group exceeds the other two groups a lot, it mayhave an unexpected greater impact on the results. Thus, we first
putthe11semanticfeaturesintoanMLP(SemanticFusionLayerin
Figure 4), the output dimension of which is set as 3. Then, the new
generated3-dimensionsemanticfeatureisconcatenatedwithother
two feature groups to obtain a 10-dimension vector, which is then
fedintoanotherMLP(Multi-SourceFusionLayerinFigure4)for
automaticfeatureextraction.Finally,thedataflowstotheoutput
layer, and a 2-dimension vector normalized by ğ‘ ğ‘œğ‘“ğ‘¡ğ‘šğ‘ğ‘¥ activation
function is generated. The output vector gives the probability ofbeing faulty for the current suspicious statement, which can beregarded as a new suspicious score. A new suspicious list can be
generated according to the suspicious scores of all statements.
3.4 TRANSFER-PR: Effective Program Repair
based on Transferred Knowledge
3.4.1 Template-based program repair. Template-based automated
program repairis widelystudied [ 16,21,31,32], whichutilizes fix
templates predefined or extracted from similar code snippets torepair specific bugs. The repair process can be basically divided
intofoursteps:faultlocalization,fixtemplateselection,donorcode
search, and patch candidate validation, corresponding to step 1
tostep4inAlgorithm1respectively.Thefirst3stepsareclosely
related to patch generation, while the last step is for validation.
Therefore,underthepremisethatatemplate-basedrepairtechnique
has been selected, that is, the set of fix templates to be used has
beendetermined,wecanoptimizethefirst3stepstotunetherepair
performance. Step 1 corresponds to our attempt to optimize theeffectiveness of fault localization tasks in Section 3.3. For step 2,a naive way is used to traverse all fix templates (e.g., predefined
1175
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:21:06 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Xiangxin Meng, Xu Wang, Hongyu Zhang, Hailong Sun, and Xudong Liu
Figure 4: MLP-based Ranking Model for Fault Localization
orderorrandomtraversal)intraditionaltemplate-basedprogram
repairtechniques,whichisunabletogiveguidanceforwhichfix
template should be selected first to generate patch candidates for a
specificinput.Thisleadstoaproblemduringbugfixing.Assuming
that the real faulty statement is reached, the repair technique may
still generate a plausible but incorrect patch candidate (i.e., a patch
canpassalltestsbutisregardedasaincorrectpatchafteramanual
check)becauseawrongfixtemplateistriedearlier.Onceaplausible
patch is generated, the entire repair process will be terminated
accordingtothecommonly-usedrepairsetup,andfinallytheactual
fix template has no chance to be selected. Therefore, we convert
thefixtemplateselectionproblemintoamulti-classificationtask,
which will be described in detail below.
3.4.2 Fix template selection with transferred knowledge. In Section
3.2.4, we have obtained the transferred knowledge by training the
multi-classifier on large-scale ğ·ğ‘ğ‘¡ğ‘ğ‘ ğ‘’ğ‘¡ ğ‘ğ‘Ÿ. For a target project, we
can first extract existing bug-fix commits from its development his-
tory, and then use the syntax checker to tag them with the unique
labels, just like what we have done to build ğ·ğ‘ğ‘¡ğ‘ğ‘ ğ‘’ğ‘¡ ğ‘ğ‘Ÿin Section
3.2. Then, the newly extracted samples can be used to further fine-tune the model parameters of the multi-classifier, which is already
trainedonğ·ğ‘ğ‘¡ğ‘ğ‘ ğ‘’ğ‘¡ ğ‘ğ‘Ÿ.Inthisway,wemergethetransferredknowl-
edgelearnedfrom ğ·ğ‘ğ‘¡ğ‘ğ‘ ğ‘’ğ‘¡ ğ‘ğ‘Ÿwiththespecificinformationofthe
targetproject.Forafaultystatementwithitscontextualmethod,
thefine-tunedmulti-classifierisusedtopredictwhichfixtemplates
shouldbeselectedfirsttogeneratepatches,whichisexpectedto
optimize the fix template selection task at step 2 in Algorithm 1.
4 EVALUATION
Inthissection,weconducttheextensiveexperimentstoevaluate
theourapproachonthefaultlocalizationandprogramrepairtasks.
4.1 Benchmark Dataset
WeuseDefects4J(V1.2.0)benchmark[ 19]inourexperiments,which
iswidelyusedfortheevaluationoffaultlocalizationandautomated
program repair tasks [ 16,25,26,28,32]. This benchmark is com-
posed of 6 open source projects containing 395 real faults.Algorithm 1 The process of template-based program repair
Input:The project to be repaired ğ‘ƒand its test cases ğ‘‡;
Output: The patch candidate ğ‘that can pass all test cases;
1:ğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡_ğ‘¡ğ‘–ğ‘šğ‘’â†ğ‘”ğ‘’ğ‘¡_ğ‘ğ‘¢ğ‘Ÿğ‘Ÿğ‘’ğ‘›ğ‘¡_ğ‘¡ğ‘–ğ‘šğ‘’();
2:ğ‘â†ğ‘ğ‘ˆğ¿ğ¿;
3:ğ‘ ğ‘¢ğ‘ ğ‘ğ‘–ğ‘ğ‘–ğ‘œğ‘¢ğ‘  _ğ‘™ğ‘–ğ‘ ğ‘¡â†ğ‘“ğ‘ğ‘¢ğ‘™ğ‘¡_ğ‘™ğ‘œğ‘ğ‘ğ‘™ğ‘–ğ‘§ğ‘ğ‘¡ğ‘–ğ‘œğ‘› (ğ‘ƒ,ğ‘‡);
4:// step 1
5:foreachğ‘ğ‘œğ‘ âˆˆğ‘ ğ‘¢ğ‘ ğ‘ğ‘–ğ‘ğ‘–ğ‘œğ‘¢ğ‘  _ğ‘™ğ‘–ğ‘ ğ‘¡do
6:// step 2
7:foreachğ‘“ğ‘¡âˆˆğ‘“ğ‘–ğ‘¥_ğ‘¡ğ‘’ğ‘šğ‘ğ‘™ğ‘ğ‘¡ğ‘’ğ‘  do
8:ğ‘‘ğ‘œğ‘›ğ‘œğ‘Ÿ_ğ‘ğ‘œğ‘‘ğ‘’_ğ‘™ğ‘–ğ‘ ğ‘¡â†ğ‘ ğ‘’ğ‘ğ‘Ÿğ‘â„_ğ‘‘ğ‘œğ‘›ğ‘œğ‘Ÿ_ğ‘ğ‘œğ‘‘ğ‘’(ğ‘ğ‘œğ‘ , ğ‘“ğ‘¡);
9:// step 3
10:foreachğ‘’ğ‘™ğ‘’ğ‘šğ‘’ğ‘›ğ‘¡âˆˆğ‘‘ğ‘œğ‘›ğ‘œğ‘Ÿ_ğ‘ğ‘œğ‘‘ğ‘’_ğ‘™ğ‘–ğ‘ ğ‘¡do
11:ğ‘ğ‘ğ‘›ğ‘‘ğ‘–ğ‘‘ğ‘ğ‘¡ğ‘’ â†ğ‘”ğ‘’ğ‘›ğ‘’ğ‘Ÿğ‘ğ‘¡ğ‘’_ğ‘ğ‘ğ‘¡ğ‘â„(ğ‘ğ‘œğ‘ , ğ‘“ğ‘¡, ğ‘’ğ‘™ğ‘’ğ‘šğ‘’ğ‘›ğ‘¡ );
12: // step 4
13: ifğ‘£ğ‘ğ‘™ğ‘–ğ‘‘ğ‘ğ‘¡ğ‘’(ğ‘ğ‘ğ‘›ğ‘‘ğ‘–ğ‘‘ğ‘ğ‘¡ğ‘’, ğ‘‡ )ğ‘–ğ‘ True then
14: ğ‘â†ğ‘ğ‘ğ‘›ğ‘‘ğ‘–ğ‘‘ğ‘ğ‘¡ğ‘’ ;
15: returnğ‘;
16: end if
17:ğ‘ğ‘¢ğ‘Ÿğ‘Ÿğ‘’ğ‘›ğ‘¡_ğ‘¡ğ‘–ğ‘šğ‘’â†ğ‘”ğ‘’ğ‘¡_ğ‘ğ‘¢ğ‘Ÿğ‘Ÿğ‘’ğ‘›ğ‘¡_ğ‘¡ğ‘–ğ‘šğ‘’();
18: ifğ‘ğ‘¢ğ‘Ÿğ‘Ÿğ‘’ğ‘›ğ‘¡_ğ‘¡ğ‘–ğ‘šğ‘’âˆ’ğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡_ğ‘¡ğ‘–ğ‘šğ‘’ >ğ‘‡ğ¼ğ‘€ğ¸_ğ‘‡ğ»ğ‘…ğ¸ğ‘†ğ»ğ‘‚ğ¿ğ·
then
19: returnğ‘;
20: end if
21:end for
22:end for
23:end for
24:returnğ‘;
4.2 Experimental Settings
As shown in Table 5, columns 2 to 5 list the experimental setups
for running the BiLSTM-based binary classifiers in Section 3.2.3
(ğ‘´ğ’ğ’…ğ’†ğ’ ğ’ƒğ’Š),theMLP-basedrankingmodelinSection3.3( ğ‘´ğ’ğ’…ğ’†ğ’ ğ’“ğ’Œ),
the BiLSTM-based multi-classifier trained on ğ·ğ‘ğ‘¡ğ‘ğ‘ ğ‘’ğ‘¡ ğ‘ğ‘Ÿin Section
3.2.4( ğ‘´ğ’ğ’…ğ’†ğ’ ğ’ğ’–),andtheBiLSTM-basedmulti-classifierfine-tuned
on Defects4J in Section 3.4 (still ğ‘´ğ’ğ’…ğ’†ğ’ ğ’ğ’–), respectively. It should
be noted that all hyper-parameters are determined based on thecorresponding validation set through grid search. For obtaining
spectrum-based andmutation-based features forfault localization
task,weutilizeGZoltar[ 6](V1.7.2)andPIT[ 8](V1.1.5)tools.For
PIT, we adopt the same modifications following TraPT [ 26] and
DeepFL [25].
WhentrainingtheMLP-basedrankingmodel,weadoptpairwise
approachbecausethegoaloffaultlocalizationtaskistorankthe
faulty statements higher than the correct ones, while other rela-
tionsarenotconsidered.Sincemostofthesuspiciousstatements
arenotfaulty,thenumberofpositivesamplesisfarlessthanthat
of negative samples. Therefore, during training, we adopt down-
samplingandrandomlyselect10negativesamplesforeachpositive
sample togenerate samplepairs like< ğ‘ ğ‘ğ‘œğ‘ ,ğ‘ ğ‘›ğ‘’ğ‘”>. Then,the hinge
function is utilized to calculate the loss of a sample pair. When
trainingthemulti-classifiermodel,duetotheimbalanceofsamples
among 11 different bug types on ğ·ğ‘ğ‘¡ğ‘ğ‘ ğ‘’ğ‘¡ ğ‘ğ‘Ÿ, the down-sampling
approach isalso adopted.Wekeep upto 10,000 samplesfor each
1176
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:21:06 UTC from IEEE Xplore.  Restrictions apply. Improving Fault Localization and Program Repair with Deep Semantic Features and Transferred Knowledge ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
Table 5: Setups for Experiments
Setups ğ‘´ğ’ğ’…ğ’†ğ’ ğ’ƒğ’Š ğ‘´ğ’ğ’…ğ’†ğ’ ğ’“ğ’Œ ğ‘´ğ’ğ’…ğ’†ğ’ ğ’ğ’– ğ‘´ğ’ğ’…ğ’†ğ’ ğ’ğ’–
Dataset ğ·ğ‘ğ‘¡ğ‘ğ‘ ğ‘’ğ‘¡ ğ‘“ğ‘™Defects4J ğ·ğ‘ğ‘¡ğ‘ğ‘ ğ‘’ğ‘¡ ğ‘ğ‘ŸDefects4J
Batch Size 64 64 64 8
Epochs 30 30 15 30
Loss Function CE Hinge-loss CE CE
Input Dim 400 18(11+3+4) 400 400
Hidden Units 50 - 80 80
Optimizer Adam Adam Adam Adam
Learning Rate 1e-3 1e-3 1e-3 1e-4
Dropout Rate - 0.3 0.3 -
ğœ†for L2-Reg - 1e-4 1e-4 -
bug type. Finally, we use 10-fold cross validation on the fault local-
ization(column3)andprogramrepairtasks(column5)toobtain
the experimental results. We set the running time of each repair
process to 3 hours, which is the same as TBar [32].
All the experiments are conducted on Ubuntu 18.04 server with
20coresof2.4GHzCPU,384GBRAMandNVIDIATeslaV100GPUs
with 32 GB memory.
4.3 Evaluation Metrics
We adopt the following common evaluation metrics used in the
previous fault localization studies [25, 26, 28, 51]:
Top-N,which represents the number of faults with at least one
faulty statement located in the top N positions. Following previous
researches [25, 26, 28], Top-1, Top-3, and Top-5 are reported.
MeanFirstRank(MFR): Iftherearemultiplefaultystatements
inafault,localizingthefirstoneisimportant.TheMFRmetricof
one project is the mean of the highest faulty statementâ€™s rank of
each fault.
MeanAverageRank(MAR), whichiscomputedastheaverage
rank of all faulty statements for each fault, and the MAR metric of
one project is the mean of the average rank of all its faults.
Amongthem,thebiggerisbetterforTop-1/3/5whilethesmaller
isbetterforMFRandMAR.Fortheprogramrepairtask,weusethe
numberoffixedfaultstomeasuretheeffectivenessofaprogram
repair technique.
4.4 Results and Discussion
RQ1: How does TRANSFER-FL perform in statement-level
fault localization?
To answer this research question, we compare the effective-
ness of TRANSFER-FL with three SBFL techniques (i.e., Ochiai[
1], Tarantula [ 18] and DStar [ 57]) whose suspicious scores are
usedtoformthespectrum-basedfeaturegroupinthispaper,and
oneMBFLtechnique(i.e.,Metallaxis[ 44])formutation-basedfea-
turegroup,andtwodeeplearning-basedtechniques(i.e.,DeepFL
[25] and DeepRL4FL [ 28]). Note that the experimental results of
DeepFL are obtained after we make simple modifications (i.e., only
semantic-based and mutation-based features are kept) based onits open source repository to meet the needs of statement-levelfault localization tasks, which is originally designed for method-
level.ForDeepRL4FL,thestate-of-the-arttechnique,sincetheopen
source repository and relevant dataset are not publicly available,Table 6: Fault Localization Results
Techniques Top-1Top-3Top-5 MFRMAR
Ochiai [1] 196599183.78 233.14
Tarantula [18] 196397189.28 241.58
Dstar [57] 206599183.75 233.52
Metallaxis [44] 133663512.28 649.41
DeepFL [25] 60122140128.02 170.46
DeepRL4FL [28] 71128142 - -
TRANSFER-FL 8414417179.97120.47
wearenotabletoreproduceitsresults.Thus, wedirectlycitethe
experimental results reported in their paper [28]1.
Table 6 presents the detailed experimental results. From the
table, we can see that TRANSFER-FL can perform all comparedtechniques in all metrics. More specifically, compared with the
threeSBFLtechniques,theincreasednumbersofthefaultshiton
Top-1,3,5 are 64+, 79+ and 72+, while the improvements on MFR
and MAR are 56.5% and 48.3%. When compared with the MBFL
technique Metallaxis, the increased numbers on Top-1, 3, 5 are 71,
108 and 108,while the improvements onMFR and MAR are 84.4%
and 81.4%. SBFL and MBFL methods only consider the dynamic
informationgeneratedbyexecutingtestcases,andlacktheanalysesforprogramsemantics.Whencomparedwiththetwodeeplearning-
based methods, the increased numbers on Top-1,3,5 are 13+, 16+and 29+, while the improvements on MFR and MAR are 37.5%
and29.3%,showingthatTRANSFER-FLsignificantlyoutperforms
thestate-of-the-artdeeplearning-basedmethods.Sincesemantic
features are not used or just simply used by concatenating the
word embeddings in the existing deep learning-based methods, the
transferredknowledgelearnedfromourbuiltlarge-scaledataset
andthedeepsemanticfeaturesgeneratedby11binaryclassifiers
can significantly enhance the effectiveness of fault localization.
RQ2:HoweffectivearethemaincomponentsofTRANSFER-
FL?
In this RQ, we explore the effectiveness of main components
in TRANSFER-FL. Since TRANSFER-FL is based on the fusion of3 feature groups, we design 6 model variants, each of which rep-resents a specific combination of features groups. As shown in
Table7,thefirst3variantsretainonlyonefeaturegroup,andthe
following2variantsretainthecombinations{spectrum,semantic}
and {mutation, semantic},respectively. Thelast variantretainsall 3featuregroups(i.e.,TRANSFER).Throughtheexperimentalresults,
we find that under the restriction of using only one feature group,
ğ‘£ğ‘ğ‘Ÿğ‘–ğ‘ğ‘›ğ‘¡ğ‘šğ‘¢ğ‘¡ğ‘ğ‘¡ğ‘–ğ‘œğ‘› performsbestonall5metrics,and ğ‘£ğ‘ğ‘Ÿğ‘–ğ‘ğ‘›ğ‘¡ğ‘ ğ‘’ğ‘šğ‘ğ‘›ğ‘¡ğ‘–ğ‘
performsbetterthan ğ‘£ğ‘ğ‘Ÿğ‘ğ‘–ğ‘›ğ‘¡ğ‘ ğ‘ğ‘’ğ‘ğ‘¡ğ‘Ÿğ‘¢ğ‘šonTop-1,whiletheresultsare
opposite on other 4 metrics. Next, compared with ğ‘£ğ‘ğ‘Ÿğ‘–ğ‘ğ‘›ğ‘¡ğ‘ ğ‘ğ‘’ğ‘ğ‘¡ğ‘Ÿğ‘¢ğ‘š
(ğ‘£ğ‘ğ‘Ÿğ‘–ğ‘ğ‘›ğ‘¡ğ‘šğ‘¢ğ‘¡ğ‘ğ‘¡ğ‘–ğ‘œğ‘›),ğ‘£ğ‘ğ‘Ÿğ‘–ğ‘ğ‘›ğ‘¡ğ‘ ğ‘ğ‘’ğ‘+ğ‘ ğ‘’ğ‘š(ğ‘£ğ‘ğ‘Ÿğ‘–ğ‘ğ‘›ğ‘¡ğ‘šğ‘¢ğ‘¡+ğ‘ ğ‘’ğ‘š) achieves sig-
nificant improvement, indicating that the semantic features can beeffectively integrated with existing traditional features to generate
richerinformation,whichisbeneficialforfaultlocalization.Finally,
the experimental results of ğ‘£ğ‘ğ‘Ÿğ‘–ğ‘ğ‘›ğ‘¡ğ‘ğ‘™ğ‘™on all 5 evaluation metrics
1Note that we find that the MFR and MAR results reported in DeepRL4FL [ 28]a r e
strangelyverylow(20.32and28.63,respectively).Aftercheckingthecodeandconsult-
ingtheauthorsofDeepRL4FL,wehavetochoosenottocomparethesetwometrics
with DeepRL4FL.
1177
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:21:06 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Xiangxin Meng, Xu Wang, Hongyu Zhang, Hailong Sun, and Xudong Liu
Table7:Comparativeanalysiswithdifferentfeaturegroups
Techniques Top-1Top-3Top-5 MFRMAR
ğ‘£ğ‘ğ‘Ÿğ‘–ğ‘ğ‘›ğ‘¡ğ‘ ğ‘ğ‘’ğ‘ğ‘¡ğ‘Ÿğ‘¢ğ‘š 206398180.53 232.32
ğ‘£ğ‘ğ‘Ÿğ‘–ğ‘ğ‘›ğ‘¡ğ‘ ğ‘’ğ‘šğ‘ğ‘›ğ‘¡ğ‘–ğ‘ 255171253.27 350.03
ğ‘£ğ‘ğ‘Ÿğ‘–ğ‘ğ‘›ğ‘¡ğ‘šğ‘¢ğ‘¡ğ‘ğ‘¡ğ‘–ğ‘œğ‘› 55109138110.10 173.96
ğ‘£ğ‘ğ‘Ÿğ‘–ğ‘ğ‘›ğ‘¡ğ‘ ğ‘ğ‘’ğ‘+ğ‘ ğ‘’ğ‘š4991120118.80 174.64
ğ‘£ğ‘ğ‘Ÿğ‘–ğ‘ğ‘›ğ‘¡ğ‘šğ‘¢ğ‘¡+ğ‘ ğ‘’ğ‘š7012115293.98148.41
ğ’—ğ’‚ğ’“ğ’Šğ’‚ğ’ğ’• ğ’‚ğ’ğ’ 8414417179.97120.47
Table 8: Repair Results under Perfect Fault Localization
Project DLFix CoCoNuT CURE TBarTRANSFER-PR
Chart 5 7 10 10 10
Closure 11 9 14 16 18
Lang 8 7 910 13
Math 13 16 19 20 20
Time 2 1 1 3 3
Mockito 1 4 3 3 3
Total 40 44 56 62 67
arebetterthanthoseofallothervariants,provingthateachfeature
group has a positive impact on the fault localization task.
RQ3: How does TRANSFER-PR perform in program re-
pair under perfect fault localization?
InordertoevaluatewhetherTRANSFER-PRiseffectiveornot,
we conduct experiments under perfect fault localization setup (i.e.,
theactualfaultystatementsaregiven).Wethencomparetherepair
resultsofdifferentmethods.AsshowninTable8,DLFix[ 27],Co-
CoNuT[39],CURE[ 17]areencoder-decoderbaseddeeplearning
methods, while TBar [ 32] is the state-of-the-art template-based
method.TRANSFER-PRisimplementedbasedonTBar,becausethe
predefined fix templates used in this paper are derived from it. The
experimental results show that TRANSFER-PR can fix 5 more bugs
(67intotal)thanTBar,whichreflectstheimprovementgainedfrom
the optimized fix template selection mechanism. When compared
withdeeplearning-basedrepairmethods,TRANSFER-PRcanfix
11 more bugs than the state-of-the-art method CURE. Furthermore,
TRANSFER-PR achieves the best results on 5 out 6 projects. The
resultsshowthatusingpredefinedhigh-qualityfixtemplatesand
optimizing the selection of fix templates can improve the repair
performance.
RQ4:CanTRANSFER,asawhole,improvetheperformance
of program repair?
In this RQ, we evaluate the effectiveness of TRANSFER (both
FL and PR) in automated program repair. As TRANSFER-PR is a
template-basedapproachderivedfromTBar[ 32],andTBaristhe
best-performingrepairmethodasshowninTable8,weuseTBar
as the baseline in this RQ. As described in TBar [ 32], there are
71bugversionsthatcanbefixedwhenthefaultystatementsand
the fix templates are both directly given. However, in actual repair
scenario, these two premises are not satisfied. Thus, we preform a
set of comparison experiments to explore how TRANSFER-FL and
TRANSFER-PRimproveprogramrepairinactualrepairscenario(both faulty statements and fix templates are unknown). Table 9
shows the repair results in different {FL Approach Ã—PR Approach}Table9:RepairExperimentsinDifferentLocalizationand
Repair Setups
Localization Repair #Not-fixed Bugs1#Fixed
Approaches Approaches TimePos.Pat.Bugs
OchiaiTBar 189341
TRANSFER-PR 189242
TRANSFER-FLTBar 1012643
TRANSFER-PR 1012247
1Reasons for not-fixed bugs: Time (Timeout), Pos (Position) and Pat (Pattern).
setups. We find that the number of fixed bugs under {Ochiai, TBar}
setup (which is the default setup in TBar [ 32]) is 41, while the
number under {Ochiai, TRANSFER-PR} setup is 42, showing theeffectiveness of TRANSFER-PR method. In addition, the numberoffixedbugsunder{TRANSFER-FL,TBar}steupis43,indicating
that TRANSFER-FL can also help improve the repair performance.
Then, when both TRANSFER-FL and TRANSFER-PR are used (i.e.,
TRANSFER), there are 47 bugs can be fixed, which achieves the
bestresult.The detailedstatisticsofthe fixedbugscorresponding
to4setupsareshowninFigure5-(a).Figure5-(b)showsthebugs
which can be fixed in all 4 setups.
Table 9 also shows the number of not-fixed bugs and the cor-
responding reasons. We divide the reasons why a bug cannot be
successfullyfixedintothreecategories:1)Timeout:thefaultystate-
ments are ranked too low in suspicious list to be found within a
limitedtime.2)Position:aplausiblebutincorrectpatchisgenerated
in another suspicious statement, when the real faulty statement
has notbeen reached. 3) Pattern:a plausible butincorrect patch is
generated due to a wrong fix template being selected. Table 9 also
shows that, after adopting TRANSFER-FL, the number of not-fixed
bugswiththereasonofTimeoutissignificantlyreduced(from18
to10).Thisresultshowsthatmanybugsthatpreviouslyfailedto
be located within a limited time have now been successfully found.
After adopting TRANSFER, there are still 24 not-fixed bugs, caused
by Timeout (10), Position (12), and Pattern (2). In our future work,
wewilladdressthesenot-fixedbugsandfurtherimprovetherepair
performance.
Figure 5: Overlapping Analysis for Program Repair Exper-iment (C:Chart, Cl:Closure, L:Lang, M:Math, Moc:Mockito,
T:Time)
1178
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:21:06 UTC from IEEE Xplore.  Restrictions apply. Improving Fault Localization and Program Repair with Deep Semantic Features and Transferred Knowledge ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
5 DISCUSSION
5.1 Why Does it Work?
For the fault localization task, previous spectrum-based, mutation-
based,anddeeplearning-basedmethodseitherdonotconsiderdeep
semanticfeatures,orjustusesomesimplefeaturesbyconcatenating
thewordembeddings,whileourapproachincorporatesthedeep
semantic features and transferred knowledge from the large-scale
open-sourcebugdataset.Specifically,wedesign11binaryclassifiers
to extract deep semantic features for predicting the probabilities of
containing bugs of different bug types.
For the program repair task, selecting the correct fix template
forthestatementtoberepairedisimportant,becauseifanincor-
rect fix template is selected, a plausible but incorrect patch maybe generated and the whole fix process will be terminated. Ourapproach includes a multi-classifier, which learns deep semantic
features from historical data that contains knowledge about which
fixtemplateshouldbeselected.Inthisway,thenumberofplausi-
blebutincorrectpatchesdecreasesandtherepairperformanceis
improved.
5.2 Threats to Validity
One threat to external validity is the target programming language
weuse,i.e.,theselectedfixtemplatesandgenerateddatasetsareall
forJavalanguage.However,mostofthefixtemplatescanbegener-
alized to other languages because of the generic representation of
AST.Ontheotherhand,therearesufficientprojectsinopensource
communities (e.g., GitHub) to build datasets for other languages.
The second threat to external validity is that we use one defect
benchmark (Defects4J-V1.2.0) in our study. Although it is a widely-
used benchmark, Durieux et al. [ 10] showed that fault localization
and program repair techniques may overfit on this benchmark. To
reduce this threat, we have conducted a preliminary experiment
on a recent benchmark Defects4J-V2.0.0. The results (given in our
project page) show similar trend as that on Defects4J-V1.2.0 and
confirmtheeffectivenessoftheproposedapproach.Inourfuture
work, we will conduct more comprehensive experiments to further
evaluatethegeneralityofourmethodsonmoredefectbenchmarks.
Onethreattointernalvalidityistheimplementationofthesyntax
analyzer developed by ourselves. In order to reduce the threat, the
analyzer is developed based on the widely used JDT framework[
11]. Another internal threat is the manual annotation for faulty
statements in Defects4J,because the standards tojudge whether a
statementisfaultyornotmaybedifferent.Toreducethisthreat,
we choose the standard given by the authors of Defects4J [45].
6 CONCLUSION
In this paper, we propose a fault localization method (TRANSFER-
FL)thatincorporatesthedeepsemantic-basedfeaturesextractedby
learningthetransferredknowledgefromlarge-scaleopen-source
data.Wealsoproposeaprogramrepairmethod(TRANSFER-PR)foroptimizingtheselectionoffixtemplates,whichcanbeusedtogether
withthefault localizationmethodtoimprove theperformanceof
existingtemplate-basedprogramrepairtechniques.Ourapproach
TRANSFER (the combination of FL and PR) can fix 47 bugs on
Defects4J dataset, which is 6 more than that of the state-of-the-art
template-based repair technique TBar [32].Our source code and experimental data are publicly available at:
https://github.com/mxx1219/TRANSFER . The code and data
can facilitate replication of our study. Furthermore, the large-scale
datasetsğ·ğ‘ğ‘¡ğ‘ğ‘ ğ‘’ğ‘¡ ğ‘“ğ‘™andğ·ğ‘ğ‘¡ğ‘ğ‘ ğ‘’ğ‘¡ ğ‘ğ‘Ÿbuilt by us can be utilized in
future automatic software debugging research.
ACKNOWLEDGMENTS
This work was supported partly by National Key Research and
DevelopmentProgramofChina(No.2018YFB1306000),partlybyNa-tionalNaturalScienceFoundationofChina(No.62072017,62141209)and Australian Research Council Discovery Projects (DP200102940,
DP220103044), and the Ministry of Industry and Information Tech-
nology of the PRC.
REFERENCES
[1]Rui Abreu, Peter Zoeteweij, and Arjan JC Van Gemund. 2006. An evaluation
of similarity coefficients for software fault localization. In 2006 12th Pacific Rim
International Symposium on Dependable Computing (PRDCâ€™06). IEEE, 39â€“46.
[2]RuiAbreu,PeterZoeteweij,andArjanJCVanGemund.2007. Ontheaccuracyof
spectrum-based fault localization. In Testing: Academic and Industrial Conference
PracticeandResearchTechniques-MUTATION(TAICPART-MUTATION2007).IEEE,
89â€“98.
[3]MiltiadisAllamanis,EarlTBarr,ChristianBird,andCharlesSutton.2015. Sug-
gestingaccuratemethodandclassnames.In Proceedingsofthe201510thJoint
Meeting on Foundations of Software Engineering. 38â€“49.
[4]MiltiadisAllamanis,MarcBrockschmidt,andMahmoudKhademi.2017. Learning
to represent programs with graphs. arXiv preprint arXiv:1711.00740 (2017).
[5]Tien-Duy B. Le, David Lo, Claire Le Goues, and Lars Grunske. 2016. A learning-
to-rank based fault localization approach using likely invariants. In Proceedings
of the 25th International Symposium on Software Testing and Analysis. 177â€“188.
[6]JosÃ© Campos, AndrÃ© Riboira, Alexandre Perez, and Rui Abreu. 2012. Gzoltar: an
eclipseplug-infortestinganddebugging.In Proceedingsofthe27thIEEE/ACM
International Conference on Automated Software Engineering. 378â€“381.
[7]Saikat Chakraborty, Miltiadis Allamanis, and Baishakhi Ray. 2018. Codit:
Code editing with tree-based neural machine translation. arXiv preprint
arXiv:1810.00314 (2018).
[8] Henry Coles. 2021. PIT. https://pitest.org/[9]
Thomas Durieux, Benoit Cornu, Lionel Seinturier, and Martin Monperrus. 2017.
Dynamic patch generationfor null pointer exceptionsusing metaprogramming.
In2017 IEEE 24th International Conference on Software Analysis, Evolution and
Reengineering (SANER). IEEE, 349â€“358.
[10]Thomas Durieux, Fernanda Madeiral, Matias Martinez, and Rui Abreu. 2019.
EmpiricalreviewofJavaprogramrepairtools:Alarge-scaleexperimenton2,141bugsand23,551repairattempts.In Proceedingsofthe201927thACMJointMeeting
on European Software Engineering Conference and Symposium on the Foundations
of Software Engineering. 302â€“313.
[11] Eclipse. 2021. JDT. https://www.eclipse.org/jdt/[12]
Jean-RÃ©my Falleri, FlorÃ©al Morandat, Xavier Blanc, Matias Martinez, and Martin
Monperrus. 2014. Fine-grained and accurate source code differencing. In Pro-
ceedings of the 29th ACM/IEEE international conference on Automated software
engineering. 313â€“324.
[13]SeppHochreiterandJÃ¼rgenSchmidhuber.1997. Longshort-termmemory. Neural
computation 9, 8 (1997), 1735â€“1780.
[14]JinruHua,MengshiZhang,KaiyuanWang,andSarfrazKhurshid.2018. Towardspracticalprogramrepairwithon-demandcandidategeneration.In Proceedingsof
the 40th international conference on software engineering. 12â€“23.
[15]Xuan Huo, Ming Li, and Zhi-Hua Zhou. 2020. Control flow graph embedding
based on multi-instance decomposition for bug localization. In Proceedings of the
AAAI Conference on Artificial Intelligence, Vol. 34. 4223â€“4230.
[16]Jiajun Jiang, Yingfei Xiong, Hongyu Zhang, Qing Gao, and Xiangqun Chen.
2018. Shapingprogramrepairspacewithexistingpatchesandsimilarcode.In
Proceedingsofthe27thACMSIGSOFTinternationalsymposiumonsoftwaretesting
and analysis. 298â€“309.
[17]Nan Jiang, Thibaud Lutellier, and Lin Tan. 2021. CURE: Code-Aware NeuralMachine Translation for Automatic Program Repair. In 2021 IEEE/ACM 43rd
International Conference on Software Engineering (ICSE). IEEE, 1161â€“1173.
[18]JamesAJonesand Mary JeanHarrold.2005. Empiricalevaluationofthetaran-
tula automatic fault-localization technique. In Proceedings of the 20th IEEE/ACM
international Conference on Automated software engineering. 273â€“282.
[19]RenÃ©Just,DarioushJalali,andMichaelDErnst.2014. Defects4J:Adatabaseofex-istingfaultstoenablecontrolledtestingstudiesforJavaprograms.In Proceedings
of the 2014 International Symposium on Software Testing and Analysis. 437â€“440.
1179
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:21:06 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Xiangxin Meng, Xu Wang, Hongyu Zhang, Hailong Sun, and Xudong Liu
[20]Pavneet Singh Kochhar, Xin Xia, David Lo, and Shanping Li. 2016. Practitionersâ€™
expectations onautomated fault localization.In Proceedings ofthe 25th Interna-
tional Symposium on Software Testing and Analysis. 165â€“176.
[21]Anil Koyuncu, Kui Liu, TegawendÃ© F BissyandÃ©, Dongsun Kim, Jacques Klein,
Martin Monperrus, and Yves Le Traon. 2020. Fixminer: Mining relevant fix
patternsforautomatedprogramrepair. EmpiricalSoftwareEngineering (2020),
1â€“45.
[22]Xuan-BachDLe,Duc-HiepChu,DavidLo,ClaireLeGoues,andWillemVisser.
2017. S3: syntax-and semantic-guided repair synthesis via programming by
examples.In Proceedingsofthe201711thJointMeetingonFoundationsofSoftware
Engineering. 593â€“604.
[23]XuanBachDLe,DavidLo,andClaireLeGoues.2016. Historydrivenprogram
repair.In 2016IEEE23rdinternationalconferenceonsoftwareanalysis,evolution,
and reengineering (SANER), Vol. 1. IEEE, 213â€“224.
[24]XiangyuLi,Marcelodâ€™Amorim,andAlessandroOrso.2016. Iterativeuser-driven
fault localization. In Haifa Verification Conference. Springer, 82â€“98.
[25]Xia Li, Wei Li, Yuqun Zhang, and Lingming Zhang. 2019. Deepfl: Integrating
multiple fault diagnosis dimensions for deep fault localization. In Proceedings of
the28thACMSIGSOFTInternationalSymposiumonSoftwareTestingandAnalysis .
169â€“180.
[26]XiaLiandLingmingZhang.2017. Transformingprogramsandtestsintandemforfaultlocalization. ProceedingsoftheACMonProgrammingLanguages 1,OOPSLA
(2017), 1â€“30.
[27]Yi Li, Shaohua Wang, and Tien N Nguyen. 2020. Dlfix: Context-based codetransformation learning for automated program repair. In Proceedings of the
ACM/IEEE 42nd International Conference on Software Engineering. 602â€“614.
[28]YiLi,ShaohuaWang,andTienNNguyen.2021.FaultLocalizationwithCodeCov-
erage Representation Learning. In 2021 IEEE/ACM 43rd International Conference
on Software Engineering (ICSE). IEEE, 661â€“673.
[29]YiLi,ShaohuaWang,TienNNguyen,andSonVanNguyen.2019. Improvingbug
detection via context-based code representation learning and attention-based
neuralnetworks. Proceedingsofthe ACMonProgrammingLanguages 3,OOPSLA
(2019), 1â€“30.
[30]Ben Liblit, MayurNaik, Alice X Zheng, Alex Aiken,and Michael I Jordan. 2005.
Scalable statistical bug isolation. Acm Sigplan Notices 40, 6 (2005), 15â€“26.
[31]KuiLiu,AnilKoyuncu,DongsunKim,andTegawendÃ©FBissyandÃ©.2019. Avatar:
Fixing semantic bugs with fix patterns of static analysis violations. In 2019 IEEE
26thInternationalConferenceonSoftwareAnalysis,EvolutionandReengineering
(SANER). IEEE, 1â€“12.
[32]KuiLiu,AnilKoyuncu, DongsunKim,andTegawendÃ©FBissyandÃ©.2019. Tbar:
Revisitingtemplate-basedautomatedprogramrepair.In Proceedingsofthe28th
ACM SIGSOFT International Symposium on Software Testing and Analysis. 31â€“42.
[33]KuiLiu,AnilKoyuncu,KisubKim,DongsunKim,andTegawendÃ©FBissyandÃ©.
2018. LSRepair:Livesearchoffixingredientsforautomatedprogramrepair.In
2018 25th Asia-Pacific Software Engineering Conference (APSEC). IEEE, 658â€“662.
[34] Tie-Yan Liu. 2011. Learning to rank for information retrieval. (2011).[35]
Xuliang Liu and Hao Zhong. 2018. Mining stackoverflow for program repair.In2018 IEEE 25th international conference on software analysis, evolution and
reengineering (SANER). IEEE, 118â€“129.
[36]Fan Long, Peter Amidon, and Martin Rinard. 2017. Automatic inference of code
transforms for patch generation. In Proceedings of the 2017 11th Joint Meeting on
Foundations of Software Engineering. 727â€“739.
[37]Yiling Lou, Ali Ghanbari, Xia Li, Lingming Zhang, Haotian Zhang, Dan Hao,
andLu Zhang.2020. Canautomated programrepairrefine faultlocalization?a
unifieddebuggingapproach.In Proceedingsofthe29thACMSIGSOFTInternational
Symposium on Software Testing and Analysis. 75â€“87.
[38]Yiling Lou, Qihao Zhu, Jinhao Dong, Xia Li, Zeyu Sun, Dan Hao, Lu Zhang, and
Lingming Zhang. 2021. Boosting coverage-based fault localization via graph-
basedrepresentationlearning.In Proceedingsofthe29thACMJointMeetingon
European Software Engineering Conference and Symposium on the Foundations of
Software Engineering. 664â€“676.
[39]ThibaudLutellier,HungVietPham,LawrencePang,YitongLi,MoshiWei,and
Lin Tan. 2020. Coconut: combining context-aware neural translation modelsusing ensemble for program repair. In Proceedings of the 29th ACM SIGSOFT
international symposium on software testing and analysis. 101â€“114.
[40]TomasMikolov,IlyaSutskever,KaiChen,GregSCorrado,andJeffDean.2013.
Distributed representations of words and phrases and their compositionality. In
Advances in neural information processing systems. 3111â€“3119.
[41]Seokhyeon Moon, Yunho Kim, Moonzoo Kim, and Shin Yoo. 2014. Ask themutants:Mutatingfaultyprogramsforfaultlocalization.In 2014IEEESeventh
International Conference on Software Testing, Verification and Validation. IEEE,
153â€“162.
[42]LiliMou,GeLi,LuZhang,TaoWang,andZhiJin.2016. Convolutionalneuralnet-
works over tree structures for programming language processing. In Proceedings
of the AAAI Conference on Artificial Intelligence, Vol. 30.
[43]LeeNaish,HuaJieLee,andKotagiriRamamohanarao.2011. Amodelforspectra-basedsoftwarediagnosis. ACMTransactionsonsoftwareengineeringandmethod-
ology (TOSEM) 20, 3 (2011), 1â€“32.[44]MikePapadakisandYvesLeTraon.2015. Metallaxis-FL:mutation-basedfault
localization. Software Testing, Verification and Reliability 25, 5-7 (2015), 605â€“628.
[45]Spencer Pearson, JosÃ© Campos, RenÃ© Just, Gordon Fraser, Rui Abreu, Michael D
Ernst, Deric Pang, and Benjamin Keller. 2017. Evaluating and improving fault
localization.In 2017IEEE/ACM39thInternationalConferenceonSoftwareEngi-
neering (ICSE). IEEE, 609â€“620.
[46]Strategic Planning. 2002. The economic impacts of inadequate infrastructure for
software testing. National Institute of Standards and Technology (2002).
[47]Michael Pradel and Koushik Sen. 2018. Deepbugs: A learning approach to name-
based bug detection. Proceedings of the ACM on Programming Languages 2,
OOPSLA (2018), 1â€“25.
[48]Baishakhi Ray, Vincent Hellendoorn, Saheel Godhane, Zhaopeng Tu, Alberto
Bacchelli,andPremkumarDevanbu.2016. Onthe"naturalness"ofbuggycode.
In2016IEEE/ACM38thInternationalConferenceonSoftwareEngineering(ICSE).
IEEE, 428â€“439.
[49]VeselinRaychev,MartinVechev,andEranYahav.2014. Codecompletionwith
statistical language models. In Proceedings of the 35th ACM SIGPLAN Conference
on Programming Language Design and Implementation. 419â€“428.
[50]RiponKSaha,YingjunLyu,HiroakiYoshida,andMukulRPrasad.2017. Elixir:
Effectiveobject-orientedprogramrepair.In 201732ndIEEE/ACMInternational
Conference on Automated Software Engineering (ASE). IEEE, 648â€“659.
[51]Jeongju Sohn and Shin Yoo. 2017. Fluccs: Using code and change metrics to
improve fault localization. In Proceedings of the 26th ACM SIGSOFT International
Symposium on Software Testing and Analysis. 273â€“283.
[52]Michele Tufano, Cody Watson, Gabriele Bavota, Massimiliano Di Penta, Martin
White,andDenysPoshyvanyk.2018. Anempiricalinvestigationintolearning
bug-fixingpatchesinthewildvianeuralmachinetranslation.In Proceedingsof
the 33rd ACM/IEEE International Conference on Automated Software Engineering.
832â€“837.
[53]Song Wang, Taiyue Liu, and Lin Tan. 2016. Automatically learning semantic
features for defect prediction. In 2016 IEEE/ACM 38th International Conference on
Software Engineering (ICSE). IEEE, 297â€“308.
[54]HuihuiWeiandMingLi.2017. SupervisedDeepFeaturesforSoftwareFunctional
Clone Detection by Exploiting Lexical and Syntactical Information in Source
Code.. In IJCAI. 3034â€“3040.
[55]Ming Wen, Junjie Chen, Rongxin Wu, Dan Hao, and Shing-Chi Cheung. 2018.Context-aware patch generation for better automated program repair. In 2018
IEEE/ACM 40th International Conference on Software Engineering (ICSE). IEEE,
1â€“11.
[56]MartinWhite,MicheleTufano,ChristopherVendome,andDenysPoshyvanyk.
2016. Deep learning code fragments for code clone detection. In 2016 31st
IEEE/ACM International Conference on Automated Software Engineering (ASE).
IEEE, 87â€“98.
[57]WEricWong,VidrohaDebroy,YihaoLi,andRuizhiGao.2012. Softwarefaultlo-calizationusingdstar(d*).In 2012IEEESixthInternationalConferenceonSoftware
Security and Reliability. IEEE, 21â€“30.
[58]Qi Xin and Steven P Reiss. 2017. Leveraging syntax-related code for automated
programrepair.In 201732ndIEEE/ACMInternationalConferenceonAutomated
Software Engineering (ASE). IEEE, 660â€“670.
[59]Jifeng Xuan and Martin Monperrus. 2014. Learning to combine multiple ranking
metricsforfaultlocalization.In 2014IEEEInternationalConferenceonSoftware
Maintenance and Evolution. IEEE, 191â€“200.
[60]JianZhang,XuWang,HongyuZhang,HailongSun,KaixuanWang,andXudong
Liu.2019. Anovelneuralsourcecoderepresentationbasedonabstractsyntax
tree. In2019 IEEE/ACM 41st International Conference on Software Engineering
(ICSE). IEEE, 783â€“794.
[61]Lingming Zhang,Miryung Kim, andSarfraz Khurshid. 2011. Localizingfailure-
inducing program edits based on spectrum information. In 2011 27th IEEE Inter-
national Conference on Software Maintenance (ICSM). IEEE, 23â€“32.
[62]LingmingZhang,LuZhang,andSarfrazKhurshid.2013. Injectingmechanical
faults to localize developer faults for evolving software. ACM SIGPLAN Notices
48, 10 (2013), 765â€“784.
[63]Xiangyu Zhang, Neelam Gupta, and Rajiv Gupta. 2007. Locating faulty code by
multiple points slicing. Software: Practice and Experience 37, 9 (2007), 935â€“961.
[64]XiangyuZhang,HaifengHe,NeelamGupta,andRajivGupta.2005. Experimental
evaluationofusingdynamicslicesforfaultlocation.In Proceedingsofthesixth
international symposium on Automated analysis-driven debugging. 33â€“42.
[65]Gang Zhao and JeffHuang. 2018. Deepsim: deep learning code functional simi-
larity.InProceedingsofthe201826thACMJointMeetingonEuropeanSoftware
EngineeringConferenceandSymposiumontheFoundationsofSoftwareEngineering.
141â€“151.
[66]Jian Zhou, Hongyu Zhang, and David Lo. 2012. Where should the bugs be fixed?
more accurate information retrieval-based bug localization based on bug reports.
In201234thInternationalConferenceonSoftwareEngineering(ICSE).IEEE,14â€“24.
[67]Qihao Zhu, ZeyuSun, Yuan-an Xiao, Wenjie Zhang, Kang Yuan, Yingfei Xiong,
and Lu Zhang. 2021. A Syntax-Guided EditDecoder for Neural Program Repair.
InProceedingsofthe29thACMJointMeetingonEuropeanSoftwareEngineering
Conference and Symposium on the Foundations of Software Engineering. 341â€“353.
1180
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:21:06 UTC from IEEE Xplore.  Restrictions apply. 