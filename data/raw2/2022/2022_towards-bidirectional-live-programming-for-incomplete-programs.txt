Towards Bidirectional Live Programmingfor Incomplete ProgramsXing Zhang Zhenjiang Hu∗Key Laboratory of High Con!dence Software Technologies, MoESchool of Computer Science, Peking Universityzhangstar@stu.pku.edu.cn huzj@pku.edu.cnABSTRACTBidirectional live programming not only allows software develop-ers to see continuous feedback on the output as they write theprogram, but also allows them to modify the program by directlymanipulating the output, so that the modi!ed program can getthe output that was directly manipulated. Despite the appealingof existing bidirectional live programming systems, there is a biglimitation: they cannot deal with incomplete programs where codeblanks exist in the source programs.In this paper, we propose a framework to support bidirectionallive programming for incomplete programs, by extending the out-put value structure, introducing hole binding, and formally de!n-ing bidirectional evaluators that are well-behaved. To illustratethe usefulness of the framework, we realize the core bidirectionalevaluations of incomplete programs in a tool called BidirectionalPreview. Our experimental results show that our extended back-ward evaluation for incomplete programs is as e"cient as that forcomplete programs in that it is only 21/u1D45A/u1D460slower on a program with10 holes than that on its full program, and our extended forwardevaluation makes no diﬀerence. Furthermore, we usequick sortandstudent grades, two nontrivial examples of incomplete programs,to demonstrate its usefulness in algorithm teaching and programdebugging.KEYWORDSlive programming, bidirectional evaluation, direct manipulation,hole bindings, hole closuresACM Reference Format:Xing Zhang Zhenjiang Hu∗. 2022. Towards Bidirectional Live Program-ming for Incomplete Programs. In44th International Conference on SoftwareEngineering (ICSE ’22), May 21–29, 2022, Pittsburgh, PA, USA.ACM, NewYork, NY, USA, 11 pages. https://doi.org/10.1145/3510003.3510195Permission to make digital or hard copies of all or part of this work for personal orclassroom use is granted without fee provided that copies are not made or distributedfor pro!t or commercial advantage and that copies bear this notice and the full citationon the!rst page. Copyrights for components of this work owned by others than ACMmust be honored. Abstracting with credit is permitted. To copy otherwise, or republish,to post on servers or to redistribute to lists, requires prior speci!c permission and/or afee. Request permissions from permissions@acm.org.ICSE ’22, May 21–29, 2022, Pittsburgh, PA, USA© 2022 Association for Computing Machinery.ACM ISBN 978-1-4503-9221-1/22/05. . . $15.00https://doi.org/10.1145/3510003.35101951 INTRODUCTIONSoftware developers have psychological expectations1on the out-put when programming in many scenarios, particularly in the de-sign of systems such as dynamic web pages, graphical user inter-faces (GUIs), slide-based presentations, and data visualizations. Tocombine the intuitiveness of direct manipulation on the outputwith the abstractness and repeatability of text-based programming,researchers have developed many useful bidirectional live program-ming systems, such as Sketch-n-Sketch [11], Capstudio [7], andCarbide Alpha [9], which can not only allow developers to seecontinuous feedback on the output when they write programs, butalso allow them to modify the program by directly manipulatingthe output so that the modi!ed program can get the output thatwas directly manipulated.Despite the appeal of the existing bidirectional live programmingsystems, there is a big limitation: they cannot deal with incompleteprograms where code blanks exist in the source programs [13]. Inpractice, software developers tend to program in a way where theyskip some parts by leaving some code blank here and there in theprogram during programming. Therefore, it would be practicallyuseful if, even when the program is incomplete, developers couldstill directly manipulate the output and automatically synchronizethe program with the updated output.Fortunately, Omar et al. [14] have made a nice progress in thisdirection, showing that it is possible to do (unidirectional) live pro-gramming for incomplete programs. They model incomplete pro-grams as expressions with holes, which denote missing expressions.Rather than aborting the evaluation when a hole is encountered,they track the evaluation state (also known as closure), i.e., vari-ables with their bindings that can be accessed by the hole instances,allowing developers to observe this information in editor services.With the technique of live programming for incomplete pro-grams, what we need to do is to make this technique bidirectionalto achieve the goal of bidirectional live programming for incom-plete programs. Diﬀerent from complete programs, the output ofincomplete programs may consist of the output value and closuresof holes, both of which should allow direct manipulation (modi!ca-tion).To this end, we are facing three challenges: (1) In forward eval-uation, since the output of incomplete programs is more complexthan that of complete programs and it needs to be re$ected backlater, the output value structure needs to be carefully designed;(2) In backward evaluation, holes in the program are special and1Psychological expectations refer to users’ expectations of what the output looks likeand what content the output displays. For example, in web development, developersoften design prototypes in advance and have expectations about what componentsare included and where they are located.
21542022 IEEE/ACM 44th International Conference on Software Engineering (ICSE)
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:57:11 UTC from IEEE Xplore.  Restrictions apply. ICSE ’22, May 21–29, 2022, Pi/t_tsburgh, PA, USAXing Zhang Zhenjiang Hu∗
Figure 1: An incomplete program written in Bidirectional Preview generates an incomplete HTML table of classmate namesand their date of birth. The language used is de/f_ined in Figure 9.should not simply be treated as an undetermined value, becauseone hole may be referred many times in the forward evaluationand thus each hole may be associated with multiple values; (3) Toguarantee the stability of bidirectional evaluation for incompleteprograms, it is important to securely concatenate upstream anddownstream backward evaluations that are hole-partitioned andsatisfy the round-tripping properties.To address challenge (1), we extend the de!nition of values withthree types of holes, including instantiations of the source holeexpressions, temporary holes generated when evaluation cannotcontinue, and sub holes generated after holes decomposition. Toaddress challenge (2), we propose the notion of hole bindings, whichrecord the value of a hole under a certain evaluation state. As partof the forward evaluation input, it will be updated in backwardevaluation. To address challenge (3), we carefully design a pair offorward and backward evaluations and prove that they satisfy theround-tripping property. This implies that the local consistencycan guarantee global consistency.In this paper, we propose a new framework for bidirectional liveprogramming for incomplete programs. The framework supportsdevelopers not only to write incomplete programs and observe theoutput with hole closures in editor services, but also to directlymanipulate them to synchronize the program with the output. Ourmain technical contributions can be summarized as follows:•We design a programming framework to support bidirec-tional live programming for incomplete programs so thatdevelopers can directly manipulate the output to synchro-nize the program with the updated output even when theprogram is not!nished (Section 3). As far as we are aware,this is the!rst framework that can support bidirectional liveprogramming for incomplete programs.•We formalize a bidirectional evaluation for incomplete pro-grams (Section 4), which successfully solves the three chal-lenges of de!ning operable output values for incompleteprograms, updating holes with constants, and updating pro-grams with hole values. Besides, the round-tripping proper-ties [6, 12] can be guaranteed (Section 4.4).•We give an e"cient implementation of the bidirectional liveprogramming framework as a concrete tool called Bidirec-tional Preview, which is available at the public repository1.We use two nontrivial examples (Section 5) to demonstratepractical usefulness of our system in algorithm teachingand program debugging. Besides, our experimental resultsshow that compared to bidirectional evaluation for completeprograms, our backward evaluation is only 21/u1D45A/u1D460slower onan incomplete program with 10 holes than on its completeprogram, and the forward evaluation is almost no diﬀerent(Section 6).2 OVERVIEWIn this section, we shall demonstrate how developers go throughbidirectional live programming (forward text-based programmingand backward direct manipulation) to accomplish a web develop-ment task. Consider the task of implementing an HTML table thatdisplays each of your classmates along with their date of birth.Note that the HTML example is adapted from the baseline workon the complete program in Sketch-n-Sketch [11]. With our toolBidirectional Preview, the developer may start with an incompleteprogram that generates an incomplete prototype.2.1 Initial Incomplete ProgramFigure 1 shows a screenshot of the system, which consists of anincomplete program (the auxiliary functions are omitted) on the leftand the incomplete table it generates on the right. Lines 41 through46 de!ne the classmate data; each element is a three-element list,1https://github.com/xingzhang-pku/BidirectionalPreview2155Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:57:11 UTC from IEEE Xplore.  Restrictions apply. Towards Bidirectional Live Programmingfor Incomplete ProgramsICSE ’22, May 21–29, 2022, Pi/t_tsburgh, PA, USA
Figure 2: When modifying “James” to “Jack” in the/f_irst lineof the Context, the classmate data in line 42 of the sourceprogram changes correspondingly.
Figure 3: When modifying hole∗2in the/f_irst line of theHTML table to “Sept. 5th, ”, the output value is propagatedto the source program and/uni210E1is inferred to be “, ”.consisting of the name, the month and day of birth, and the year ofbirth (for now, the data is missing).The main program consists of two parts: lines 48 through 53de!ne the data process, using aspacerto connect two parts ofthe date; and lines 54 through 68 de!ne the HTML rendering oftable headers and content. The program contains three holes (rednumbers): the!rst one/uni210E1is the expression assigned to variablespacer; the second one/uni210E2is an uninitialized string-type constant inlistcolors, and the last one/uni210E3is the body of data rendering functiondrawRow.Due to the missing code indrawRow, the output HTML table hasits header but lacks content. On the top of the OUTPUT window,the four purple boxes denote four unknown HTML elements. Holevalues are indicated by the hole name written in curly braces. Inparticular, holes 3_9 through 3_12 are four instantiations of/uni210E3,and their closures (free variables and their values) can be switchedvia the selector in the CONTEXT window. The current CONTEXTwindow shows a partial closure of hole 3_9, includingrowbeing[“/u1D43D/u1D44E/u1D45A/u1D452/u1D460”,{∗2}],ibeing 0, etc, where{∗2}stands for a temporaryhole value generated by string concatenation with/uni210E1.2.2 Direct Manipulation on ContextAlthough the program is un!nished, the developer can performdirect manipulation on the output and the context. The modi!cationincludes updating a value to another value and updating a hole toa value, or vice versa.Figure 2 shows that when modifying the!rst element of/u1D45F/u1D45C/u1D464from "James" to "Jack" in the!rst line of the Context, the classmatedata in Line 42 of the program is updated correspondingly. HTMLvalues are presented as HTML strings in the Context likeheaderRowin Figure 1 and can also be modi!ed.2.3 Direct Manipulation on OutputThe functionality of the missing code at/uni210E3is to color the even-numbered lines of the table lightblue and the odd-numbered lines
Figure 4: Fill in the missing code in/uni210E3.
Figure 5: When using DOM Inspector to initialize the uncer-tain color of the cell with “Linda” on it, “lightyellow” is prop-agated to/uni210E2and insert a new piece of record to hole bindings.the missing color at/uni210E2. After the developer!lls in/uni210E3as shown inFigure 4, the shape of the table is complete but the “Date of Birth”column is still incomplete because of/uni210E1, where holes∗2,∗4,∗6, and∗8 display in purple boxes.2.3.1 Modify Text in Output.As shown in the right of Figure 3,the developer updates hole∗2 in the!rst row to “Sept. 5th, ” whichis in his/her expected date format. The modi!ed HTML table ispropagated to the source program and the system infers that thevalue of/uni210E1is “, ”.Without replacing/uni210E1locally, a new piece of record is added tothe Hole Bindings as shown in the left of Figure 3, which means/uni210E1should be evaluated to “, ”, under the context (not shown in full)including/u1D450/u1D459/u1D44E/u1D460/u1D460/u1D45A/u1D44E,/u1D452/u1D460and so on.2.3.2 Modify Output Using DOM Inspector.Besides directly mod-ify the text in output, developers can conveniently modify theoutput using developer tools (e.g. DOM Inspector) in the browser.As shown in Figure 5, when the developer is not sure of the desiredcolor, he/she set the!rst element in/u1D450/u1D45C/u1D459/u1D45C/u1D45F/u1D460to/uni210E1. After the forwardevaluation, due to the uninitialized color for odd-numbered linesof the HTML, the background color is default white. Then the de-veloper uses the DOM inspector to select the cell “Linda” in thethird row of the table, and sets its background-color property to“lightyellow” in the Styles Box. Through backward evaluation, thecolor value is propagated to/uni210E2and a new piece of record about/uni210E2is added to hole bindings as shown in the bottom of Figure 5.2156Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:57:11 UTC from IEEE Xplore.  Restrictions apply. ICSE ’22, May 21–29, 2022, Pi/t_tsburgh, PA, USAXing Zhang Zhenjiang Hu∗
Figure 6: System FrameworkSummaryAfter the above series of manipulations, the developer accomplishedthe task of!nishing the program with/uni210E1being “, ” and/uni210E2being“lightyellow”, and/uni210E3being de!ned in Figure 4, which runs to get theexpected HTML table. In summary, our tool is a direct manipulationsystem of incomplete programs with friendly interactions, beingeﬀective and productive.3 SYSTEM DESIGNOur framework for supporting bidirectional live programming forincomplete programs is shown in Figure 6. The down arrows repre-sent the forward process of normal live programming, and the uparrows represent the backward process of modifying the programby directly manipulating the output. We use four colors to markthe four parts of the input, output, intermediate results, and thecore implementation respectively.The user input is a source program, which is written in a simplefunctional language (used in [11]) with the hole extension. Thelanguage used in our system is de!ned in Figure 9. The outputthat developers can direct manipulate consists of two parts: one isthe visual object designed by the developer (we use HTML pagesas an example, but it can also be slide-based presentations, datavisualizations, etc.); the other is the closures related to hole values invisual objects, also known as the Context in Bidirectional Preview.Developers can modify the value of each variable in a hole closurein the Context, and if the value is a hole value, they can jump to itsclosure and modify it. The intermediate results in the system arethe internal representation of the program-Abstract Syntax Tree(AST) and the internal representation of the output values.The core part of the system is the content in white boxes, includ-ing three bidirectional transformations [4] denoted with red dottedboxes. The front-end bidirectional transformation maintains theconsistency between the program and its AST, including the parserwhich parses the program to the AST, and the printer which printsthe updated AST back to the program in the original format withthe same white spaces. The back-end transformation maintains the
Figure 7: Quick Sort
Figure 8: Student Gradesconsistency between the output value and the HTML pages withhole closures, including the HTML printer which prints the HTMLpages and collects the hole closures, and the HTML parser whichparses the HTML pages with hole closures to the output values.The core bidirectional transformation is the most critical bidirec-tional evaluators, including the forward evaluation and backwardevaluation. The forward evaluation takes the AST and hole bindingsas input and returns the output values. The backward evaluationtakes the updated output values and the original AST with holebindings as input and returns the updated AST with hole bindings.The core bidirectional transformation maintains the consistencybetween the AST with hole bindings and the output values.It should be noted that the parser and printer in the front-endand back-end bidirectional transformations are not special. Theframework has been implemented in Bidirectional Preview , ba-sically following the structure of Sketch-n-Sketch [11]. The mostimportant contribution of this paper is the crucial bidirectionalevaluation part, which will be explained in detail in Section 4.4 THE CORE BIDIRECTIONAL EVALUATORSIn this section, we show how to tackle the most challenging partof the framework. As discussed in the introduction, we need to ad-dress three issues: de!ning operable output values for incompleteprograms, updating holes with constants, and updating programswith hole values. In the following, we shall address these issues,by explaining the (source) programs to be developed, and de!n-ing evaluation rules for the forward evaluator and the backwardevaluator in the framework of bidirectional live programming forincomplete programs.4.1 Source ProgramThe source program is written in a simple functional language,almost the same as that in Sketch-n-Sketch [11] with additionalholes. It is a functional language with holes to denote blank codes.2157Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:57:11 UTC from IEEE Xplore.  Restrictions apply. Towards Bidirectional Live Programmingfor Incomplete ProgramsICSE ’22, May 21–29, 2022, Pi/t_tsburgh, PA, USAExpressions e ::=(||)/u1D462|/u1D450|/u1D465|./u1D45D./u1D452|/u1D4521/u1D4522|/u1D4521::/u1D4522|(/u1D4521,/u1D4522)|let p e1e2|letrec p e1e2||if e1e2e3|case e(p1,e1)···Constants c ::=/u1D45B|/u1D44F|/u1D460|[ ]|( + )|(∗)|(&&)|/u1D45B/u1D45C,Pa%erns p ::=/u1D450|/u1D465|/u1D45D1::/u1D45D2|(/u1D45D1,/u1D45D2)Environment E ::=∅|/u1D438,/u1D465/uni21A6.endl→/u1D463Values v ::=(||)uE|dvDeterminate Values dv ::=c|(E,.p.e)|v1:: v2|(v1,v2)Hole Name u ::=n|∗n|u_n|u.nFigure 9: SyntaxFigure 9 gives the syntax of the language. In particular, we de!nethe output of an incomplete program suitable for manipulation,which addresses the!rst issue (i.e., the de!nition of operable outputvalues) we mentioned.In our language, expressions (i.e. programs) include hole expres-sions(||)/u1D462(/u1D462is the hole name), constants/u1D450, variable/u1D465, function ap-plication/u1D4521/u1D4522(apply function/u1D4521to arguments/u1D4522), list construction/u1D4521::/u1D4522(append the list/u1D4522with the head element/u1D4521), tuple(/u1D4521,/u1D4522),let-bindingslet/u1D45D/u1D4521/u1D4522, letrec-bindingsletrec/u1D45D/u1D4521/u1D4522, conditionalsif/u1D4521/u1D4522/u1D4523, and case expressionscase/u1D452(/u1D45D1,/u1D4521)···. The de!nitionof constant includes numbers/u1D45B, booleans/u1D44F, strings/u1D460, the emptylist[], and primitive operators.Simply put, a source program is an expression that has let-bindings combined. Each expression can only access variables de-!ned in the outer let-bindings. We have seen an example in theoverview, and there are two more example programs, i.e.quick sortshown in Figure 7 andstudent gradesshown in Figure 8.4.2 Forward EvaluatorThe forward evaluator computes the value of an expression, whichexplains how the output we de!ned in the previous subsectionis obtained. Figure 10 de!nes the evaluation rules (whose namesare pre!xed with “E-”) of the forward evaluator, which is standardand similar to that in Sketch-n-Sketch [11], except for the evalua-tion rules involving holes. In this section, we mainly explain theevaluation of holes in hole expressions, function calls, primitive op-erations, conditionals, etc, where the three diﬀerent types of holesare generated. The forward evaluation judgment/uni03A3;/u1D438/turnstileleft/u1D452⇒/u1D463states that “the expression e evaluates to v under the environment/u1D438and the hole bindings/uni03A3.”4.2.1 Two Bindings.There are two bindings, environment/u1D438andhole bindings/uni03A3, used in the forward evaluator. As shown in Figure9, environment/u1D438is a variable-value mapping that denotes the eval-uation state./u1D438,/u1D465/uni21A6.endl→/u1D463denotes inserting the binding of/u1D465with/u1D463to/u1D438. Hole-bindings/uni03A3maps pairs of hole names/u1D462and environments/u1D438to determinate values and its notation is the same as environments.Example 4.1.Consider the expressionx+(|| )1under the envi-ronment{/u1D465/uni21A6.endl→1}(/u1D438) and the hole bindings{(1,{/u1D465/uni21A6.endl→1})/uni21A6.endl→2}(/uni03A3). The variable/u1D465evaluates to 1 according to/u1D438and(|| )1under/u1D438evaluates to 2 according to/uni03A3./squareIn addition, supplementary de!nitions of values and hole namesare as follows. Values v include determinate values/u1D451/u1D463and holevalues(||)/u1D462/u1D438where/u1D462means the hole name and/u1D438means the closure.The de!nition of hole closures is the same as the environment,which is a variable-value mapping. Determinate values includeconstants/u1D450, function closure(/u1D438,./u1D45D./u1D452)where/u1D438binds free variablesin the body of the function.p.e, list values/u1D4631::/u1D4632, and tuples(/u1D4631,/u1D4632). Hole names/u1D462includes numbers/u1D45Brepresenting source holeexpressions, numbers beginning with an asterisk∗/u1D45Brepresentingintermediate temporary hole values, numbers joined with an un-derscore/u1D462_/u1D45Brepresenting hole instantiations, and numbers joinedwith a dot/u1D462./u1D45Brepresenting sub holes.4.2.2 Hole instantiations.The hole instantiations are generatedwhen evaluating the source hole expressions. E-Hole-2 is the sameas the evaluation rule of hole expressions de!ned by Omar et al.[14]. It says that when the pair consisting of/u1D462and/u1D438is not foundas a key in hole bindings/uni03A3, the hole expression(|| )/u1D462evaluates to ahole instantiation(|| )/u1D462_/u1D45B/u1D438, where/u1D45Bmeans the nth instantiation ofthe hole expression/u1D462and the environment/u1D438as a closure attachesto it. There is no hole binding when the developer has just!nishedthe initial incomplete program, so all hole expressions evaluate tohole instantiations.E-Hole-1 is diﬀerent from the rule in previous work [14]. It saysthat if hole expression name/u1D462binds a determinate value/u1D451/u1D463inhole bindings/uni03A3under the environment/u1D438, it will evaluate to/u1D451/u1D463.For example, Figure 3 shows that/uni210E1binds the value “, ” under theenvironment (containing/u1D450/u1D459/u1D44E/u1D460/u1D460/u1D45A/u1D44E,/u1D452/u1D460, etc). Therefore,/uni210E1assignedto/u1D460/u1D45D/u1D44E/u1D450/u1D452/u1D45Fevaluates to “, ”, and the date of birth of Kim evaluates to“Jan. 16th, ”, rather than the hole value∗4.4.2.3 Sub Holes.Sub holes are new in our evaluation, and theyare generated when hole values do pattern matching. Before adetailed explanation of that, we show an example!rst, where ahole decomposes to a list construction and matches with a listpattern to produce two sub holes.Example 4.2.Consider the function call(\[x].x)(|| )1. The ar-gument(|| )1evaluates to(|| )1_1∅which decomposes to(|| )1_1.1∅::(|| )1_1.2∅. In particular,(|| )1_1.1∅and(|| )1_1.2∅are sub holes of(|| )1∅, andmatch with[/u1D465](i.e.,/u1D465::[]) to returns{/u1D465/uni21A6.endl→(|| )1_1.1∅}, according toM-Cons (explained later). Therefore, the!nal result is(|| )1_1.1∅./squarePattern matching is the process of matching values with struc-tural patterns and binding values with corresponding variables inthe pattern. The two key axioms in matching rules are de!ned asfollows. The matching judgement/u1D45A/u1D44E,/u1D450/uni210E(/u1D45D,/u1D463)=/u1D438states that “value/u1D463matches with pattern/u1D45Dand the result is the matched bindings/u1D438. ” The rule M-Const says that a hole value(||)/u1D462/u1D438matches with anyconstant pattern/u1D450and no binding is generated. The rule M-Consis used when the value/u1D463matches with the list pattern/u1D45D1::/u1D45D2. Ifthe decomposition of/u1D463is/u1D4631::/u1D4632,/u1D4631matches with/u1D45D1to produce/u1D4381and/u1D4632matches with/u1D45D2to produce/u1D4382,r e s p e c t i v e l y .T h em a t c h e dbindings are the concatenation of/u1D4381and/u1D4382.2158Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:57:11 UTC from IEEE Xplore.  Restrictions apply. ICSE ’22, May 21–29, 2022, Pi/t_tsburgh, PA, USAXing Zhang Zhenjiang Hu∗E-Const/uni03A3;/u1D438/turnstileleft/u1D450⇒/u1D450E-Var/u1D438(/u1D465)=/u1D463/uni03A3;/u1D438/turnstileleft/u1D465⇒/u1D463E-Hole-1/uni03A3(/u1D462,/u1D438)=/u1D451/u1D463/uni03A3;/u1D438/turnstileleft(||)/u1D462⇒/u1D451/u1D463E-Hole-2(/u1D462,/u1D438)/uni2209/u1D451/u1D45C/u1D45A(/uni03A3)/u1D45B/u1D456 /u1D460 /u1D453/u1D45F /u1D452 /u1D460 /uni210E/uni03A3;/u1D438/turnstileleft(||)/u1D462⇒(||)/u1D462_/u1D45B/u1D438E-Fun/uni03A3;/u1D438/turnstileleft./u1D45D./u1D452⇒(/u1D438,./u1D45D./u1D452)E-App/uni03A3;/u1D438/turnstileleft/u1D4521⇒(/u1D438/u1D453,./u1D45D./u1D452/u1D453)/uni03A3;/u1D438/turnstileleft/u1D4522⇒/u1D4632/u1D438/u1D45A=/u1D45A/u1D44E,/u1D450/uni210E(/u1D45D,/u1D4632)/uni03A3;/u1D438/u1D45A◦/u1D438/u1D453/turnstileleft/u1D452/u1D453⇒/u1D463/uni03A3;/u1D438/turnstileleft/u1D4521/u1D4522⇒/u1D463E-Case-1/uni03A3;/u1D438/turnstileleft/u1D465⇒(||)/u1D462/u1D438/u1D45B/u1D456 /u1D460 /u1D453/u1D45F /u1D452 /u1D460 /uni210E/uni03A3;/u1D438/turnstileleft/u1D450/u1D44E/u1D460/u1D452 /u1D465(/u1D45D/u1D456→/u1D452/u1D456)/u1D456=1../u1D45B⇒(||)∗/u1D45B/u1D438E-Case-2/uni03A3;/u1D438/turnstileleft/u1D465⇒/u1D451/u1D463(/u1D457./u1D438/u1D45A=/u1D45A/u1D44E,/u1D450/uni210E(/u1D45D/u1D457,/u1D451/u1D463)/uni03A3;/u1D438/u1D45A◦/u1D438/turnstileleft/u1D452/u1D457⇒/u1D463/uni03A3;/u1D438/turnstileleft/u1D450/u1D44E/u1D460/u1D452 /u1D465(/u1D45D/u1D456→/u1D452/u1D456)/u1D456=1../u1D45B⇒/u1D463E-Fix/uni03A3;/u1D438/turnstileleft/u1D452(/u1D453/u1D456 /u1D465 /u1D452)⇒/u1D463/uni03A3;/u1D438/turnstileleft/u1D453/u1D456 /u1D465 /u1D452⇒/u1D463E-Plus/uni03A3;/u1D438/turnstileleft/u1D4521⇒(||)/u1D4621/u1D438/u1D45C/u1D45F/uni03A3;/u1D438/turnstileleft/u1D4522⇒(||)/u1D4622/u1D438/u1D45B/u1D456 /u1D460 /u1D453/u1D45F /u1D452 /u1D460 /uni210E/uni03A3;/u1D438/turnstileleft/u1D4521+/u1D4522⇒(||)∗/u1D45B/u1D438Figure 10: Evaluation Rules of Forward EvaluatorM-Const/u1D45A/u1D44E,/u1D450/uni210E(/u1D450,(||)/u1D462/u1D438)=∅M-Cons/u1D463/trianglerightsld/u1D4631::/u1D4632/u1D45A/u1D44E,/u1D450/uni210E(/u1D45D1,/u1D4631)=/u1D4381/u1D45A/u1D44E,/u1D450/uni210E(/u1D45D2,/u1D4632)=/u1D4382/u1D45A/u1D44E,/u1D450/uni210E(/u1D45D1::/u1D45D2,/u1D463)=/u1D4381◦/u1D4382The decomposition relation is de!ned using symbol/trianglerightsld, and/u1D4631/trianglerightsld/u1D4632states that “/u1D4631decomposes to/u1D4632.” The determinate val-ues decompose to themselves, such as[1,2]/trianglerightsld[1,2]. The holevalue decomposes to a list construction with two sub holes, writtenas(|| )/u1D462/u1D438/trianglerightsld(|| )/u1D462.1/u1D438::(|| )/u1D462.2/u1D438.4.2.4 Temporary Holes.To make the forward evaluator continuethe subsequent evaluation when it’s stuck because of holes, we usetemporary holes as result, rather than proceeding around holes [14].In particular, temporary holes are generated in the evaluation ofcase expressions (E-Case-1) and primitive expressions (E-Plus). It isimportant to note that guard expressions in case expressions onlyconsider the situation of a single variable; more complex situationscan be achieved through syntactic sugar of function calls.The rule E-Case-1 says that the case expression evaluates to atemporary hole value(|| )∗/u1D45B/u1D438when/u1D465evaluates to a hole value. Theclosure of the temporary hole value is the environment/u1D438, and/u1D45Bdoes not con$ict with the names of the source hole expressions.The rule E-Plus is similar to E-Case-1, which stops the forwardevaluation and returns a temporary hole value when encountersthat/u1D4521or/u1D4522evaluates to a hole value.4.3 Backward EvaluatorIn this subsection, we explain how to address the second and thirdissues we mentioned at the beginning of this section, i.e., how toupdate hole expressions, and how to update incomplete programswith hole values in the backward evaluator.The backward evaluator is the most important part of our ap-proach. It takes the original internal-representation AST of theprogram with the hole bindings and the updated output valuesas the input and returns the updated AST and hole bindings. Thebackward evaluation judgment/uni03A3;/u1D438/turnstileleft/u1D452)/u1D463/prime/leadsto/uni03A3/prime;/u1D438/prime/turnstileleft/u1D452/primestatesthat "when the output value updates to/u1D463/prime,t h ep r o g r a m/u1D452updatesto/u1D452/prime, the environment/u1D438updates to/u1D438/prime, and the hole bindings/uni03A3updates to/uni03A3/prime”.The evaluation rules (whose names are pre!xed with “U-”) of thebackward evaluator are de!ned in Figure 11. The backward evalu-ation rules come in three categories: replacement rules overwritevalues (base constants, function closures) in the program with newones and update bindings of hole expressions; propagation rules,as the opposite of their corresponding forward rules, propagate theupdated output to the whole evaluation process (through variables,applications, conditionals, etc); primitive rules de!ne how to updateoperations on values, and the evaluation policies are heuristic andcan be customized by domain experts.4.3.1 Replacement Rules.Replacement rules de!ne what can beoverwritten in the source program and how to update the holebindings. There are three axioms for holes, constants, and functionclosures, respectively.Hole Expressions.The rule U-Hole-1 de!nes how a determinatevalue updates the hole expression, like Example 4.3.Example 4.3.Consider the programlet a = 1 in(|| )1. Whenthe output value(|| )1_1{/u1D44E/uni21A6.endl→1}updates to 2, rather than rewriting theprogram tolet a = 1 in 2, the hole binding which binds pair(1,/u1D44E/uni21A6.endl→1)with 2 is added to the hole bindings while the program re-mains unchanged. The hole binding means that the hole expression(|| )1evaluates to 2 when variable/u1D44Eevaluates to 1. In the forwardevaluation with the updated hole bindings, the program evaluatesto 2./squareThe rule U-Hole-1 says that, if a determinate value/u1D451/u1D463updates ahole expression/u1D462, then the binding of pair(/u1D462,/u1D438)with/u1D451/u1D463is insertedinto the hole bindings, or the original binding of(/u1D462,/u1D438)is updated,while the program remains unchanged. The rule U-Hole-2 de!neshow a hole value updates the hole expression, like Example 4.4Example 4.4.Consider the program in Example 4.3. If the outputvalue is a hole value(|| )1_1{/u1D44E/uni21A6.endl→2}, the updated hole closure{/u1D44E/uni21A6.endl→2}willpropagate to the variable/u1D44Ethrough U-Fun. Therefore, the programupdates tolet a = 2 in(|| )1./squareThe rule U-Hole-2 says that, if the output value is a hole value(|| )/u1D462/prime/u1D438/prime, the domain of the updated hole closure is checked to see if2159Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:57:11 UTC from IEEE Xplore.  Restrictions apply. Towards Bidirectional Live Programmingfor Incomplete ProgramsICSE ’22, May 21–29, 2022, Pi/t_tsburgh, PA, USAU-Hole-1/uni03A3/prime=/uni03A3,(/u1D462,/u1D438)/uni21A6.endl→/u1D451/u1D463/uni03A3;/u1D438/turnstileleft(||)/u1D462)/u1D451/u1D463/leadsto/uni03A3/prime;/u1D438/turnstileleft(||)/u1D462U-Hole-2/u1D451/u1D45C/u1D45A(/u1D438)=/u1D451/u1D45C/u1D45A(/u1D438/prime)/uni03A3;/u1D438/turnstileleft(||)/u1D462)(||)/u1D462/prime/u1D438/prime/leadsto/uni03A3;/u1D438/prime/turnstileleft(||)/u1D462U-Const-1/uni03A3;/u1D438/turnstileleft/u1D450)/u1D450/prime/leadsto/uni03A3;/u1D438/turnstileleft/u1D450/primeU-Const-2/u1D451/u1D45C/u1D45A(/u1D438)=/u1D451/u1D45C/u1D45A(/u1D438/prime)/u1D4622/u1D456/u1D460 /u1D453 /u1D45F/u1D452/u1D460/uni210E/uni03A3;/u1D438/turnstileleft/u1D450)(||)/u1D4621/u1D438/prime/leadsto/uni03A3;/u1D438/turnstileleft(||)/u1D4622U-Plus-1/uni03A3;/u1D438/turnstileleft/u1D4521⇒(||)/u1D462/u1D438/uni03A3;/u1D438/turnstileleft/u1D4522⇒/u1D451/u1D4632/uni03A3;/u1D438/turnstileleft/u1D4521)/u1D451/u1D463/prime+/u1D451/u1D4632/leadsto/uni03A31;/u1D4381/turnstileleft/u1D452/prime1/uni03A3;/u1D438/turnstileleft/u1D4521+/u1D4522)/u1D451/u1D463/prime/leadsto/uni03A31;/u1D4381/turnstileleft/u1D452/prime1+/u1D4522U-Plus-2/u1D451/u1D45C/u1D45A(/u1D438)=/u1D451/u1D45C/u1D45A(/u1D438/prime)/uni03A3;/u1D438/turnstileleft/u1D4521⇒(||)/u1D4621/u1D438/u1D45C/u1D45F/uni03A3;/u1D438/turnstileleft/u1D4522⇒(||)/u1D4622/u1D438/uni03A3;/u1D438/turnstileleft/u1D4521+/u1D4522)(||)/u1D462/u1D438/prime/leadsto/uni03A3;/u1D438/prime/turnstileleft/u1D4521+/u1D4522U-Cons/u1D463/prime/trianglerightsld/u1D463/prime1::/u1D463/prime2/uni03A3;/u1D438/turnstileleft/u1D4521)/u1D463/prime1/leadsto/uni03A31;/u1D4381/turnstileleft/u1D452/prime1/u1D438/prime=/u1D4381⊕/u1D438/u1D4382/uni03A3;/u1D438/turnstileleft/u1D4522)/u1D463/prime2/leadsto/uni03A32;/u1D4382/turnstileleft/u1D452/prime2/uni03A3/prime=/uni03A31⊕/uni03A3/uni03A32/uni03A3;/u1D438/turnstileleft/u1D4521::/u1D4522)/u1D463/prime/leadsto/uni03A3/prime;/u1D438/prime/turnstileleft/u1D452/prime1::/u1D452/prime2U-Fix/uni03A3;/u1D438/turnstileleft/u1D452(/u1D453/u1D456 /u1D465 /u1D452))/u1D463/prime/leadsto/uni03A3/prime;/u1D438/prime/turnstileleft/u1D4521(/u1D453/u1D456 /u1D465 /u1D4522)/u1D452/prime=/u1D4521⊕/u1D452/u1D4522/uni03A3;/u1D438/turnstileleft/u1D453/u1D456 /u1D465 /u1D452)/u1D463/prime/leadsto/uni03A3/prime;/u1D438/prime/turnstileleft/u1D453/u1D456 /u1D465 /u1D452/primeU-Case/uni03A3;/u1D438/turnstileleft/u1D465⇒(||)/u1D462/u1D438(/u1D457./u1D438/u1D45A=/u1D45A/u1D44E,/u1D450/uni210E(/u1D45D/u1D457,(||)/u1D462/u1D438)/uni03A3;/u1D438/u1D45A◦/u1D438/turnstileleft/u1D452/u1D457)/u1D463/prime/leadsto/uni03A3/prime;/u1D438/prime/u1D45A◦/u1D438/prime/turnstileleft/u1D452/prime/u1D457∅;/u1D438/prime/u1D45A/turnstileleft/u1D45D/u1D457⇒/u1D463/u1D457/u1D438/prime/prime=/u1D438/prime,/u1D465/uni21A6.endl→/u1D463/u1D457/uni03A3;/u1D438/turnstileleft/u1D450/u1D44E/u1D460/u1D452 /u1D465(/u1D45D/u1D456→/u1D452/u1D456)/u1D456=1../u1D45B)/u1D463/prime/leadsto/uni03A3/prime;/u1D438/prime/prime/turnstileleft/u1D450/u1D44E/u1D460/u1D452 /u1D465(/u1D45D/u1D456→/u1D452/u1D456)/u1D456/uni2260/u1D457|(/u1D45D/u1D457→/u1D452/prime/u1D457)U-App/uni03A3;/u1D438/turnstileleft/u1D4521⇒(/u1D438/u1D453,./u1D45D./u1D452/u1D453)/uni03A3;/u1D438/turnstileleft/u1D4522⇒/u1D4632/u1D438/u1D45A=/u1D45A/u1D44E,/u1D450/uni210E(/u1D45D,/u1D4632)/uni03A3;/u1D438/u1D45A◦/u1D438/u1D453/turnstileleft/u1D452/u1D453)/u1D463/prime/leadsto/uni03A3/u1D453;/u1D438/prime/u1D45A◦/u1D438/prime/u1D453/turnstileleft/u1D452/prime/u1D453/uni03A3;/u1D438/turnstileleft/u1D4521)(/u1D438/prime/u1D453,./u1D45D./u1D452/prime/u1D453)/leadsto/uni03A3;/u1D4381/turnstileleft/u1D452/prime1∅;/u1D438/prime/u1D45A/turnstileleft/u1D45D⇒/u1D463/prime2/uni03A3;/u1D438/turnstileleft/u1D4522)/u1D463/prime2/leadsto/uni03A32;/u1D4382/turnstileleft/u1D452/prime2/u1D438/prime=/u1D4381⊕/u1D438/u1D4382/uni03A3/prime=/uni03A32∪/uni03A3/u1D453/uni03A3;/u1D438/turnstileleft/u1D4521/u1D4522)/u1D463/prime/leadsto/uni03A3/prime;/u1D438/prime/turnstileleft/u1D452/prime1/u1D452/prime2Figure 11: Evaluation Rules of Backward Evaluatorit’s equal to the domain of the environment/u1D438. If the domains areequal, U-Hole-2 replaces/u1D438with/u1D438/primedirectly. This is a key step forthe updated hole closure to aﬀect updating the source program.As shown in Example 4.4, the updated hole closure has the samedomain as that of the original closure, which is{/u1D44E}. In fact, domainconsistency is an overly strict condition. If the domain of E’ coversE, there is no bad eﬀect on backward evaluation. However, if thevariables in/u1D438are missing in/u1D438/prime, it will cause a breakdown in back-ward evaluation. To simplify the problem in Bidirectional Preview,there is no interface for adding or deleting bindings in Context, sothe domain of the environment is always consistent.Constants.The backward evaluation rules of constants need toconsider the types of output values. The rule U-Const-1 says that,when the output value/u1D450updates to/u1D450/prime, the expression/u1D450also updatesto/u1D450/prime. For example, when the output of the expression 1 updates to2, the expression updates to 2. The rule U-Const-2 de!nes how ahole value updates the constant expression, like Example 4.5.Example 4.5.Consider the programlet a = 1 in a. If theoutput value 1 updates to a hole value(|| )1_1∅, the program willupdate tolet a =(|| )1in a./squareThe rule U-Const-2 says that when a hole value(||)/u1D4621/u1D438/primeupdatesthe constant expression/u1D450,/u1D450will be replaced with a hole expression/u1D4622while the environment/u1D438remains unchanged. The hole name/u1D4621and hole closure/u1D438/primeare ignored because the hole value is generatedin the output without de!ning a closure./u1D4622is a fresh hole namefor the new hole expression which is diﬀerent from the names ofexisting holes. The rule U-Const-2 is the only way to add new holeexpressions to the program by modifying the output. When a holevalue updates the determinate value in the output, the hole valuewill$ow through the entire evaluation process and only changethe!nal constant in the program, like Example 4.5.Function Closures.The function rule U-Fun (not shown) saysthat when the output value(/u1D438/prime,./u1D45D./u1D452/prime)updates the expression./u1D45D./u1D452under/u1D438and/uni03A3,./u1D45D./u1D452updates to./u1D45D./u1D452/primeand/u1D438updates to/u1D438/primewhile/uni03A3remains unchanged. U-Fun is important to propagate the changesin the environment to sub derivations.4.3.2 Propagation Rules.Propagation rules de!ne how the outputchanges$ow throughout the whole derivation. There are threeaxioms for variables, function calls, and conditionals, respectively.Function Calls.The rule U-App de!nes how to update functioncalls, which follows the main idea in Sketch-n-Sketch [11] exceptfor the hole bindings.There are four steps in U-App: (1)/u1D4521evaluates to the functionclosure(/u1D438/u1D453,./u1D45D./u1D452/u1D453)while/u1D4522evaluates to/u1D4632, then the pattern match-ing between/u1D4632and/u1D45Dreturns the matched bindings/u1D438/u1D45A; (2) Theoutput value/u1D463/primeupdates the function-body expression/u1D452/u1D453under theconcatenation of/u1D438/u1D45Aand/u1D438/u1D453with the original hole bindings/uni03A3, then/u1D452/u1D453updates to/u1D452/prime/u1D453,/uni03A3updates to/uni03A3/u1D453, and/u1D438/u1D45A◦/u1D438/u1D453updates to/u1D438/prime/u1D45A◦/u1D438/prime/u1D453;(3) The function closure(/u1D438/prime/u1D453,./u1D45D./u1D452/prime/u1D453)updates/u1D4521under/u1D438and/uni03A3, then/u1D4521updates to/u1D452/prime1,/u1D438updates to/u1D4381, and/uni03A3remains unchanged, whilethe updated output value/u1D463/prime2updates/u1D4522and the result is that/u1D4522updates to/u1D452/prime2,/u1D438updates to/u1D4382and/uni03A3updates to/uni03A32; (4) Merging/u1D4381and/u1D4382returns/u1D438/prime, while merging/uni03A32and/uni03A3/u1D453returns/uni03A3/prime. Example4.6 shows the four steps in practice.Example 4.6.Consider the function call(\x. [x, a]) awiththe environment{/u1D44E/uni21A6.endl→1}and the hole bindings∅. Its output is[1,1]and then updates to[2,1]. In step (1),/u1D4521evaluates to({/u1D44E/uni21A6.endl→1},./u1D465.[/u1D465,/u1D44E])while/u1D4522evaluates to 1 and/u1D438/u1D45Ais{/u1D465/uni21A6.endl→1}. In step(2),/u1D452/prime/u1D453is the same as/u1D452/u1D453, i.e.,[x,a]./u1D438/prime/u1D45A◦/u1D438/prime/u1D453is{/u1D465/uni21A6.endl→2,/u1D44E/uni21A6.endl→1}and/uni03A3/u1D453is empty. In step (3),/u1D4521remains unchanged. The outputvalue 2 updates/uni03A3;/u1D438/turnstileleft/u1D4522to∅;{/u1D44E/uni21A6.endl→2}/turnstileleft/u1D44E.S t e p( 4 )r e c o n c i l e s/u1D43812160Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:57:11 UTC from IEEE Xplore.  Restrictions apply. ICSE ’22, May 21–29, 2022, Pi/t_tsburgh, PA, USAXing Zhang Zhenjiang Hu∗({/u1D44E/uni21A6.endl→1}) and/u1D4382({/u1D44E/uni21A6.endl→2}) with the original/u1D438({/u1D44E/uni21A6.endl→1}) andreturns{/u1D44E/uni21A6.endl→2}because/u1D44Ein/u1D4382is diﬀerent with the one in/u1D438./squareEnvironments merge and hole bindings merge are two key stepsto reconcile con$icts between two sub derivations of/u1D4521and/u1D4522.A sfor environments merge, if a variable appears free in both expres-sions, the traditional two-way merge requires that it is updatedwith the same new value in both environments. Since two-waymerge is too restrictive to make the backward evaluation work inmost scenarios, we adapt the three-way merge instead, which isexplained in detail in Sketch-n-Sketch [11]. The three-way mergeis able to handle con$icts between/u1D4381and/u1D4382smoothly because itselects the value of the variable from/u1D4381or/u1D4382that is diﬀerent fromthat in/u1D438like the environments merge in Example 4.6. Abstractly,the three-way merge implies that the updated value has a higherpriority to be used than the original value.As for hole bindings merge, it simply unions two hole-bindingsdirectly, as shown in Example 4.7. The reason is that the updatedor inserted hole bindings in/uni03A32and/uni03A3/u1D453must be diﬀerent becauseclosures of holes in/u1D4522and/u1D452/u1D453must be diﬀerent. The updated closuresof holes in/u1D452/u1D453have the same domain as that of/u1D438/u1D45A◦/u1D438/u1D453,h o w e v e r ,i n/u1D4522the updated closures of holes have the same domain as that of/u1D438.Example 4.7.Consider the function call(\x.[x,(|| )1])(|| )2.Its output is[(|| )2_1∅,(|| )1_1{/u1D465/uni21A6.endl→(||)2_1∅}]and then updates to[1,2]. Instep (2),/u1D438/prime/u1D45A◦/u1D438/prime/u1D453is{/u1D465/uni21A6.endl→1}and/uni03A3/u1D453is{(1,{/u1D465/uni21A6.endl→(|| )2_1∅})/uni21A6.endl→2}. Instep (3),/uni03A32is{(2,∅)/uni21A6.endl→1}. According to the hole bindings merge,/uni03A3/primeis the union of/uni03A3/u1D453and/uni03A32./squareCase Expressions.The rule U-Case de!nes how to update a caseexpression of which the guard expression evaluates to a hole value,like Example 4.8.Example 4.8.Consider the expressioncase a of [x]->1|[]->2under the environment{/u1D44E/uni21A6.endl→(|| )1_1∅}. Its output is(|| )∗1(through E-Case-1) and then updates to 3. At!rst,/u1D44Eevaluates to(|| )1_1∅and triesto match with the!rst branch, i.e.,[x]->1. Then the output value 3successfully updates the branch expression 1 to 3 (through U-Const-1). Finally, the expression updates tocase a of [x]->3|[]->2with the environment and hole bindings unchanged. Otherwise,if the output value fails to update the!rst branch, the backwardevaluator will try the second branch[]->2./squareThe rule U-Case says that when/u1D465evaluates to a hole value, thehole value tries to match with each pattern and the output valuetries to update the corresponding branch. If the update success, theupdated value/u1D463/u1D457replaces the original binding of/u1D465in/u1D438/prime/prime, and theupdated branch expression/u1D452/prime/u1D457replaces/u1D452/u1D457.Variables.The rule U-Var is omitted and it just replaces theoriginal binding in the environment with the output value andthe expression remains unchanged. For example, when the outputvalue updates to 2,∅;{/u1D465/uni21A6.endl→1}/turnstileleft/u1D465updates to∅;{/u1D465/uni21A6.endl→2}/turnstileleft/u1D465.4.3.3 Primitive Rules.There are many strategies to update prim-itive operations, which can be tailored to diﬀerent domains andproblems. Suppose the strategy is that the eﬀect of backward eval-uation on the source program is as small as possible. Here we useplus operation and list construction as examples.Plus.In the rule U-Plus-1, instead of updating/u1D4522that originallyevaluates to a determinate value/u1D451/u1D4632, the diﬀerence/u1D451/u1D463/prime+/u1D451/u1D4632as theoutput value updates/u1D4521, which originally evaluates to a hole value.Example 4.9.Consider the plus expression(|| )1+1. Its outputvalue is(|| )∗1∅(through E-Plus) and then updates to 2. According toU-Plus-1,/u1D4522remains unchanged and the diﬀerence 2+1 updates/u1D4521. Through U-Hole-1, the backward evaluator returns{(1,∅)/uni21A6.endl→1};∅/turnstileleft(|| )1./squareThe rule U-Plus-2 says that when the output value is a hole value(|| )/u1D462/u1D438/primeand/u1D4521or/u1D4522evaluates to a hole, the environment/u1D438is replacedby the hole closure/u1D438/prime.There are many backward evaluation rules for other situations(such as both/u1D4521and/u1D4522evaluate to hole values) and the updatestrategies are somehow subjective, so they are omitted. In our im-plementation, each situation is handled only by a unique backwardevaluation rule, so there is only a unique solution for the wholebackward evaluation and no ambiguity. It is a better choice to pro-vide multiple options like Sketch-n-Sketch [11], however since thisis not what we focus on, we didn’t implement it in our tool.List Construction.The rule U-Cons de!nes how to update alist construction, like Example 4.10.Example 4.10.Consider the expression[a,a]under the envi-ronment{/u1D44E/uni21A6.endl→(|| )1_1∅}and the hole bindings{(1,∅)/uni21A6.endl→1}. Itsoutput is[1,1](through E-Hole-1) and then updates to[1,2]. Thehead of the output value 1 updates the head of the list construc-tion/u1D44Eto{(1,∅)/uni21A6.endl→1};{/u1D44E/uni21A6.endl→(|| )1_1∅}/turnstileleft/u1D44E. The tail of the outputvalue[2]updates the tail of the list construction[/u1D44E]to{(1,∅)/uni21A6.endl→2};{/u1D44E/uni21A6.endl→(|| )1_1∅}/turnstileleft[/u1D44E]. According to the three-way merge, the holebindings update to{(1,∅)/uni21A6.endl→2}./squareThe rule U-Cons says that the output value/u1D463/primeshould decom-pose to two sub-values, which update the head expression and tailexpression respectively. The environments merge is the same asthat in U-App, while the hole bindings merge is diﬀerent. This isbecause there may be con$icts in/uni03A31and/uni03A32. We also adopt theprinciple that the updated value has a higher priority, so the ruleU-Cons apply three-way merge on hole bindings. The values boundto holes in/uni03A31or/uni03A32that is diﬀerent from that in/uni03A3is selected to beinserted into the updated hole bindings/uni03A3/prime.4.3.4 Recursion.Since recursion is not discussed in Sketch-n-Sketch[11], here is an explanation of our approach. Although recursionis not relevant with holes, it is essential to the expressiveness of alanguage.The U-Fix rule propagates the output value/u1D463/primeto the expandedexpression/u1D452(/u1D453/u1D456 /u1D465 /u1D452)which updates to/u1D4521(/u1D453/u1D456 /u1D465 /u1D4522). If/u1D4521is diﬀerentfrom/u1D452, then/u1D4521is selected, otherwise,/u1D4522is selected.4.4 Round-Tripping PropertiesThe forward evaluation and the backward evaluation form a lens[6] to maintain consistency betweensource(AST of programs withhole bindings) andview(output with hole closures). To ensurethe stability of the system, the relationship of the forward evalu-ation and the backward evaluation should satisfy round-trippingproperties, i.e., GETPUTand WEAKPUTGET[12] de!ned as follows.2161Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:57:11 UTC from IEEE Xplore.  Restrictions apply. Towards Bidirectional Live Programmingfor Incomplete ProgramsICSE ’22, May 21–29, 2022, Pi/t_tsburgh, PA, USA
Figure 12: The student modi/f_ies/u1D45F_/u1D460/u1D45A/u1D44E/u1D459/u1D459/u1D452/u1D45Fin hole∗3to[1]and/u1D45F_/u1D460/u1D45A/u1D44E/u1D459/u1D459/u1D452/u1D45Fin hole∗5closure to[1,2,3].L&/m.sc/m.sc(4.11 (GETPUT). If/uni03A3;/u1D438/turnstileleft/u1D452⇒/u1D463and/uni03A3;/u1D438/turnstileleft/u1D452)/u1D463/leadsto/uni03A3/prime;/u1D438/turnstileleft/u1D452, then/uni03A3/prime;/u1D438/turnstileleft/u1D452⇒/u1D463and/uni03A3⊆/uni03A3/prime.L&/m.sc/m.sc(4.12 (WEAKPUTGET). If/uni03A3;/u1D438/turnstileleft/u1D452)/u1D463/prime/leadsto/uni03A3/prime;/u1D438/prime/turnstileleft/u1D452/primeand/uni03A3/prime;/u1D438/prime/turnstileleft/u1D452/prime⇒/u1D463/prime/prime, then/uni03A3;/u1D438/turnstileleft/u1D452)/u1D463/prime/prime/leadsto/uni03A3/prime;/u1D438/prime/turnstileleft/u1D452/prime.The GETPUTLemma requires that whenever the output has notbeen updated, the same program and hole bindings as the originalone are obtained by backward evaluation. However, things are alittle diﬀerent for the bidirectional evaluators in our approach. Ahole with a data structure decomposes to sub holes when it doespattern matching in the forward evaluation, and it binds with thedata structure in hole bindings in the backward evaluation. There-fore,/uni03A3is a sub-set of the updated hole bindings/uni03A3/prime. For example,when hole(|| )/u1D462/u1D438matches with/u1D465::/u1D465/u1D460, the binding of(|| )/u1D462/u1D438with(|| )/u1D462.1/u1D438::(|| )/u1D462.2/u1D438is inserted into hole bindings. It’s easy to prove thatthe inserted hole bindings does not aﬀect the forward evaluation,i.e., expression/u1D452under/u1D438and/uni03A3/primestill evaluates to v.The WEAKPUTGETLemma requires that: (1) the output value/u1D463/primeupdates the source program/uni03A3;/u1D438/turnstileleft/u1D452to/uni03A3/prime;/u1D438/prime/turnstileleft/u1D452/prime; (2)/u1D452/primeunder/u1D438/primeand/uni03A3/primeevaluates to/u1D463/prime/prime; (3)/u1D463/prime/primeupdates/uni03A3;/u1D438/turnstileleft/u1D452to the sameupdated program/uni03A3/prime;/u1D438/prime/turnstileleft/u1D452/prime. This property is important because itensures that/u1D463/primeand/u1D463/prime/primeupdate the program to get the same result.We prove that the bidirectional evaluations with the three-waymerge satis!es WEAKPUTGETwhen considering that there are noprimitive rules and the control$ow remains unchanged in thebackward evaluation.5 TWO APPLICATIONSIn this section, we usequick sortandstudent grades, two nontrivialexamples, to illustrate the usefulness of our system in algorithmteaching and program debugging.5.1 Quick SortSuppose that we are teaching the quick sort algorithm. An incom-plete program is given in Figure 7, where we de!ne a recursivefunction/u1D45E/u1D460/u1D45C/u1D45F,; the auxiliary function/u1D45D/u1D44E/u1D45F,/u1D456,/u1D456/u1D45C/u1D45Bis used to screenout/u1D460/u1D45A/u1D44E/u1D459/u1D459/u1D452/u1D45Fand/u1D44F/u1D456/u1D454/u1D454/u1D452/u1D45Fwith pivot as the boundary, and/u1D45E/u1D460/u1D45C/u1D45F,isrecursively applied to/u1D460/u1D45A/u1D44E/u1D459/u1D459/u1D452/u1D45Fand/u1D44F/u1D456/u1D454/u1D454/u1D452/u1D45Fand get/u1D45F_/u1D460/u1D45A/u1D44E/u1D459/u1D459/u1D452/u1D45Fand/u1D44F_/u1D460/u1D45A/u1D44E/u1D459/u1D459/u1D452/u1D45F, respectively. Now assume that we are not sure how toproduce the!nal result and we add a hole in Line 23.
Figure 13: The bindings of hole1in quick sort.Our system provides two convenient ways for students to un-derstand the behavior of programs. First, they can "see". Studentscan observe the context of each recursive call of quick sort throughthe Context window. Second, they can "edit". Students can edit the"Context", changing the unknown value to the one they expect.For example, when students tell the system that sorting the list[1]should yield[1](which is initially unknown), then the system willshow what the value should be for the hole in the context, whichhelps them to guess what to!ll in the hole.Suppose the student runs the incomplete quick sort program andgets the Context table on the right in Figure 12. Students may wishto view the nested hole (e.g. *3) of the outer hole (e.g. *5), so theycould click the subitem and jump to its context. At this time, theContext table displays the content on the left in Figure 12. "WHICHIS THE OUTPUT" in UI shows the click path “{*5}·r_smaller(0)”.Note that the selector in the "Context" header is designed to showthe hole names in the "Output" of the program, so both table headersin Figure 12 show *5. Next, it is easy for students to understandthat the function/u1D45E/u1D460/u1D45C/u1D45F,applied to/u1D460/u1D45A/u1D44E/u1D459/u1D459/u1D452/u1D45Flist[1]results in[1],so he/she modi!es/u1D45F_/u1D460/u1D45A/u1D44E/u1D459/u1D459/u1D452/u1D45Fto[1]in the Context like Figure 12.In the same way back to the closure of the outermost hole{∗5},students know that/u1D45F_/u1D460/u1D45A/u1D44E/u1D459/u1D459/u1D452/u1D45Fshould be[1,2,3]and modify theContext again like the right context in Figure 12.After students!ll in the hole in the Context with the results theyexpected, the hole-bindings in Figure 13 are generated throughbackward evaluation. With the second hole-binding, students knowthat when/u1D45D/u1D456/u1D463/u1D45C,is 2 and/u1D45F_/u1D460/u1D45A/u1D44E/u1D459/u1D459/u1D452/u1D45Fis[1], the value of hole ex-pression 1 should be[2,3]. Through observing the context of thesecond hole binding, he/she might have reasoned that the holeshould actually be the connection of[/u1D45D/u1D456/u1D463/u1D45C,]and/u1D45F_/u1D44F/u1D456/u1D454/u1D454/u1D452/u1D45F.It is remarked that, for a hole in the program, our system providesdevelopers only with the value of the hole and its context (as partof the output for one to modify); it does not infer the code for thehole, though developers may bene!t from the value and its contextto guess a possible code shape.5.2 Student GradesConsider that a teacher computes the students’!nal grades at theend of the semester. Suppose there are only three students, andthe teacher wants to score according to the weighted average ofhomework, midterm, and!nal. He/she writes the program in Figure8, where the function/u1D464/u1D452/u1D456/u1D454/uni210E,/u1D452/u1D451_/u1D44E/u1D463/u1D452/u1D45F/u1D44E/u1D454/u1D452applies to each student’sscore in Line 21.Suppose that the program runs to get an incorrect output, say[2701.5,2345.9,847.3]. The teacher does not know which part ofthe expression in Line 19 was wrong, and he/she doubts the valueat/uni210E/u1D464/u1D45F∗/uni210E/u1D464. Therefore, he/she changes the expression in Line 19to_+/u1D45A/u1D456/u1D451/u1D45F∗/u1D45A/u1D456/u1D451,/u1D452/u1D45F/u1D45A+/u1D453/u1D456 /u1D45B /u1D45F∗/u1D453/u1D456 /u1D45B /u1D44E /u1D459and propagates the wrong2162Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:57:11 UTC from IEEE Xplore.  Restrictions apply. ICSE ’22, May 21–29, 2022, Pi/t_tsburgh, PA, USAXing Zhang Zhenjiang Hu∗
Figure 14: Hole-bindings of using[2701.5,2345.9,2847.3]to up-date the program with a hole expressionoutput through backward evaluation to get the records in the Holebindings window (as shown in Figure 14). It is easy to know thatthe value (2790, 2280, and 2640) of the hole expression 1 (which is/uni210E/u1D464/u1D45F∗/uni210E/u1D464originally) is wrong. Then the teacher observes the valueof/uni210E/u1D464/u1D45Fand/uni210E/u1D464in the context of hole bindings and!nds that thevalue of/uni210E/u1D464/u1D45Fshould be 0.3, rather than 30.Note that the purpose of turning a suspected expression intoa hole is to observe its context and value to be sure that they arewhat we want for this expression. The example just shows themechanism of using our work for debugging; in fact, the teachermay choose to convert any expression into a hole, not just/uni210E/u1D464/u1D45F∗/uni210E/u1D464.Summary.These two examples and the example in Section 2demonstrate the potential of our work in three areas: web develop-ment, classic algorithms, and program debugging. These examplesare nontrivial and cover su"cient language constructs such asconditionals, function calls, and recursions (similar to loops).6 EFFICIENCYWe have implemented the core bidirectional evaluators based onthe framework of bidirectional live programming for incompleteprograms in our tool Bidirectional Preview. Our implementationis written mostly in Elm, a functional language, with about 6,000lines of code.To evaluate whether our framework is eﬀective enough to givethe developers quick feedback after directly manipulating the out-put, we measured the running time (in milliseconds) of the variousparts of the framework on the nontrivial example “table of states”(used in Sketch-n-Sketch [11]). The selected program has 76 linesof codes written in the language we de!ned. Note that in practice,an incomplete program is usually not long, particularly in the liveprogramming setting. We’ve instrumented a timing mechanismin our implementation, which can record running times for eachpart of our implementation (such as times for parsing, forward andbackward evaluations) when our system is running.We use diﬀerent numbers of hole expressions to indicate thedegree of incompleteness of the same program. The more holesthere are, the more incomplete the program is. The holes wereintroduced into some entries of the input table for the selectedprogram, which can be propagated to various places of the programduring evaluation. The experiments include four settings with 0, 1,5, and 10 holes. We test up to 10 holes because there are generallynot many holes in an incomplete program at one time in practicalprogramming.Table 1 shows a summary of our results averaged over 10 trials.We con!rm that the$uctuation range of most of the results is within5%. The “HN” column shows the number of hole expressions inthe initial program. The “Env Merge” column shows the runningtime of the environment merges, while the “HB Merge” columnshows the running time of the hole bindings merges. “Env Merge”and “HB Merge” are parts of “Backward Evaluator” and they areexplained in Section 4.3.2.In Table 1, as the number of holes in the program increase from 1to 10, the time diﬀerence of forward evaluation is within 1/u1D45A/u1D460, almostthe same as that of the complete program. And it takes around thesame amount of time to parse and print code. However, with theincrease of holes, the time diﬀerence of backward evaluation isgreater, and the diﬀerence is up to 21/u1D45A/u1D460when there are 10 holes.This is an acceptable increase compared to the time it takes to parsecode and HTML. The time to parse HTML code has also increasedslightly, and this is due to hole elements in the HTML page, whichtake up some time.There is a diﬀerence between the complete program and theincomplete program in backward evaluation, and the diﬀerenceincreases with the increase in the number of holes. This is becausethe time of environments merge and hole-bindings merge increasesand accounts for most of the running time of the backward evalua-tion, as can be seen from Table 1. In both merges, values need tobe compared. After adding holes into the de!nition of values, thecomparison becomes more complicated because a hole value is car-ried with a closure, which can have nested hole values. Therefore,the recursive comparison process is very time-consuming.7 RELATED WORKOur work on bidirectional live programming is much related tothe work on program sketching, direct manipulation programmingsystem, live programming, and program debugging.Program Sketching.Program sketching is a useful technique wheredevelopers express their high-level insights using an incompleteprogram as a sketch and leave the low details to the computer tosynthesize [15]. Justin et al. [10] propose abidirectional evaluationto propagate input-output examples through partially evaluatedsketches. It is a bidirectional evaluation of incomplete programs,but there is a sharp diﬀerence from ours: it propagates input-outputexample constraints to the holes, whereas our method propagatesoutput values back to the program. In particular, as our intentionis to directly manipulate the output of incomplete programs, bothholes and their closures are editable in our method but not editablein [10].Direct Manipulation Programming System.Our approach is builtupon the bidirectional evaluation in Sketch-n-Sketch [11], with asigni!cant extension from complete programs to incomplete pro-grams. In fact, our framework is the!rst to perform direct manipu-lation on incomplete programs, which is in sharp contrast to thetraditional direct manipulation systems, such as [1,3,7,16], whichcan work on only complete programs.2163Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:57:11 UTC from IEEE Xplore.  Restrictions apply. Towards Bidirectional Live Programmingfor Incomplete ProgramsICSE ’22, May 21–29, 2022, Pi/t_tsburgh, PA, USATable 1: Running Time of Bidirectional EvaluationsHNParse CodeForward EvalParse HTMLBackward EvalPrintEnv MergeHB Merge036.33.3318.171.138.41137.073.4339.113.331.179.771.67536.373.738.421.11.0711.475.271035.634.2746.6729.97116.436.53HN: Number of holes in program; Env Merge: Environment Merge; HB Merge: Hole Bindings MergeParse Code refers to the “Parser” in Figure 6; Forward Eval refers to the “Forward Evaluator” described in Section 4.2; Parse HTMLrefers to “HTML Parser”; Backward Eval refers to “Backward Evaluato” described in Section 4.3; Print refers to “Printer” in Figure 6.Live Programming.Live programming allows developers to editthe code of a running program and immediately see the eﬀect ofthe code changes [2]. To deal with incomplete programs, Omaret al. [14] proposed to model incomplete functional programs asexpressions with holes. Inspired by this work, we extend it from"unidirectional" to "bidirectional".Recently, Omar et al. [13] import hole expressions to de!ne atyped livelit calculus, and the system continuously gathers closuresassociated with the hole that the livelit is!lling. Livelit helps de-velopers with some special editing tools, including colors, tabulardata, and diagrams, through user-de!ned GUIs to!ll holes in theprogram online. Essentially, this approach is still unidirectional.Although our work is also to!ll in the hole expressions, we do itby editing the output and propagating it back to the program.Program Debugging.Program debugging [8] is related to backwardevaluationbecause when the output of the wrong test case is known,backward evaluation can help to locate the wrong code fragments.For instance, Faddegon and Chitil [5] present an approach to algo-rithmic debugging that builds a computation tree from the runtimevalue observations by adding annotations to suspected modules, ofwhich the aim is to limit the scope of debugging. As demonstratedin the paper, our framework can be used for debugging, where thesuspicious expression can be set as a hole and the observation inhole bindings and hole closures helps with decision-making. As ourfuture work, we are interested in looking into the deep relationshipbetween algorithmic debugging and backward transformation ofincomplete programs.8 CONCLUSIONWe present the!rst framework to support bidirectional live pro-gramming for incomplete programs. Essentially, it can be consid-ered either as bidirectionalization of the technique of live program-ming for incomplete programs or as an extension of the frameworkof bidirectional live programming from complete programs to in-complete programs. The challenge lies in the richer output (ofincomplete programs) which makes backward evaluation di"cult.In particular, the holes need much attention because they can beinstantiated many times and decomposed into sub-holes duringevaluation. We carefully design the algorithms for e"cient bidirec-tional evaluation and implement the tool Bidirectional Preview thatis shown to be useful to develop various HTML applications inter-actively. In addition, we highlight the usefulness of bidirectionallive programming of incomplete programs in algorithm teachingand program debugging. It is worth noting that although only func-tional programs are considered in this paper, the framework can beadapted to other programs such as imperative programs.REFERENCES[1]Gideon Avrahami, Kenneth P. Brooks, and Marc H. Brown. 1989. A Two-ViewApproach to Constructing User Interfaces.SIGGRAPH Comput. Graph.23, 3 (July1989), 137–146. https://doi.org/10.1145/74334.74347[2]Sebastian Burckhardt, Manuel Fahndrich, Peli de Halleux, Sean McDirmid, MichalMoskal, Nikolai Tillmann, and Jun Kato. 2013. It’s Alive! Continuous Feedbackin UI Programming.SIGPLAN Not.48, 6 (June 2013), 95–104. https://doi.org/10.1145/2499370.2462170[3]Ravi Chugh, Brian Hempel, Mitchell Spradlin, and Jacob Albers. 2016. Program-matic and direct manipulation, together at last.Proceedings of the 37th ACMSIGPLAN Conference on Programming Language Design and Implementation(Jun2016). https://doi.org/10.1145/2908080.2908103[4]Krzysztof Czarnecki, J. Nathan Foster, Zhenjiang Hu, Ralf Lämmel, Andy Schürr,and James F. Terwilliger. 2009. Bidirectional Transformations: A Cross-DisciplinePerspective. InTheory and Practice of Model Transformations, Richard F. Paige(Ed.). Springer Berlin Heidelberg, Berlin, Heidelberg, 260–283.[5]Maarten Faddegon and Olaf Chitil. 2015. Algorithmic Debugging of Real-WorldHaskell Programs: Deriving Dependencies from the Cost Centre Stack.SIGPLANNot.50, 6 (June 2015), 33–42. https://doi.org/10.1145/2813885.2737985[6]J. Nathan Foster, Michael B. Greenwald, Jonathan T. Moore, Benjamin C. Pierce,and Alan Schmitt. 2007. Combinators for Bidirectional Tree Transformations: ALinguistic Approach to the View-Update Problem.ACM Trans. Program. Lang.Syst.29, 3 (May 2007), 17–es. https://doi.org/10.1145/1232420.1232424[7]Koumei Fukahori, Daisuke Sakamoto, Jun Kato, and Takeo Igarashi. 2014. Cap-Studio: An Interactive Screencast for Visual Application Development. InCHI’14 Extended Abstracts on Human Factors in Computing Systems(Toronto, Ontario,Canada)(CHI EA ’14). Association for Computing Machinery, New York, NY,USA, 1453–1458. https://doi.org/10.1145/2559206.2581138[8]Alex Groce, Mohammad Amin Alipour, Chaoqiang Zhang, Yang Chen, and JohnRegehr. 2016. Cause reduction: delta debugging, even without bugs.Softw. Test.Veri/f_ication Reliab.26, 1 (2016), 40–68. https://doi.org/10.1002/stvr.1574[9] K. kwok and G. Webster. 2016.Carbide Alpha. https://alpha.trycarbide.com/[10]Justin Lubin, Nick Collins, Cyrus Omar, and Ravi Chugh. 2020. Program sketchingwith live bidirectional evaluation.Proceedings of the ACM on ProgrammingLanguages4, ICFP (Aug 2020), 1–29. https://doi.org/10.1145/3408991[11]Mikaël Mayer, Viktor Kuncak, and Ravi Chugh. 2018. Bidirectional evaluationwith direct manipulation.Proceedings of the ACM on Programming Languages2,OOPSLA (Oct 2018), 1–28. https://doi.org/10.1145/3276497[12]Keisuke Nakano. 2019. Towards a Complete Picture of Lens Laws.arXiv:1910.10421 [cs.PL][13]Cyrus Omar, David Moon, Andrew Blinn, Ian Voysey, Nick Collins, and RaviChugh. 2021. Filling Typed Holes with Live GUIs(PLDI 2021). Association forComputing Machinery, New York, NY, USA, 511–525. https://doi.org/10.1145/3453483.3454059[14]Cyrus Omar, Ian Voysey, Ravi Chugh, and Matthew A. Hammer. 2018. LiveFunctional Programming with Typed Holes. arXiv:1805.00155 [cs.PL][15]Armando Solar-Lezama. 2013. Program Sketching.Int. J. Softw. Tools Technol.Transf.15, 5–6 (Oct. 2013), 475–495. https://doi.org/10.1007/s10009-012-0249-7[16]Xiaoyin Wang, Lu Zhang, Tao Xie, Yingfei Xiong, and Hong Mei. 2012. Au-tomating Presentation Changes in Dynamic Web Applications via CollaborativeHybrid Analysis(FSE ’12). Association for Computing Machinery, New York, NY,USA, Article 16, 11 pages. https://doi.org/10.1145/2393596.2393614
2164Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:57:11 UTC from IEEE Xplore.  Restrictions apply. 