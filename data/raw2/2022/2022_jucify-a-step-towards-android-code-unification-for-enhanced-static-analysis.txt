JuCify: A Step Towards Android Code Unification for Enhanced
Static Analysis
JordanSamhi1,JunGao1,NadiaDaoudi1,PierreGraux1,3,HenriHoyez4,XiaoyuSun2,KevinAllix1,
TegawendÃ© F. BissyandÃ©1, Jacques Klein1
1SnT, University of Luxembourg, Luxembourg, firstname.lastname@uni.lu
2Monash University, Australia, firstname.lastname@monash.edu
3Univ. Lille, CNRS, Centrale Lille, UMR 9189 CRIStAL, F-59000 Lille, France, firstname.lastname@univ-lille.fr
4Technische UniversitÃ¤t Kaiserslautern, Germany, firstname.lastname@sms-group.com
ABSTRACT
Native code is now commonplace within Android app packages
whereitco-existsandinteractswithDexbytecodethroughtheJava
NativeInterfacetodeliverrichappfunctionalities.Yet,state-of-the-
artstaticanalysisapproacheshavemostlyoverlookedthepresenceofsuchnativecode,which,however,mayimplementsomekeysen-
sitive, or even malicious, parts of the app behavior. This limitation
ofthestateoftheartisaseverethreattovalidityinalargerangeof
static analyses that do not have a complete view of the executable
codeinapps.Toaddressthisissue,weproposeanewadvancein
the ambitiousresearch directionof buildinga unified modelof all
codeinAndroidapps.TheJuCifyapproachpresentedinthispaper
is a significant step towards such a model, where we extract andmerge call graphs of native code and bytecode to make the final
modelreadily-usablebyacommonAndroidanalysisframework:
in our implementation, JuCify builds on the Soot internal inter-
mediaterepresentation.Weperformedempiricalinvestigationsto
highlight how, without the unified model, a significant amount
ofJavamethodscalledfromthenativecodeareâ€œunreachableâ€in
appsâ€™call-graphs,bothingoodwareandmalware.UsingJuCify,we
were able to enable static analyzers to reveal cases where malware
relied on native code to hide invocation of payment library code
or of other sensitive code in the Android framework. Additionally,
JuCifyâ€™smodelenablesstate-of-the-arttoolstoachievebetterpreci-
sion and recall in detecting data leaks through native code. Finally,
we show that by using JuCify we can find sensitive data leaks that
pass through native code.
ACM Reference Format:
Jordan Samhi1, Jun Gao1, Nadia Daoudi1, Pierre Graux1,3, Henri Hoyez4,
Xiaoyu Sun2, Kevin Allix1, TegawendÃ© F. BissyandÃ©1, Jacques Klein1. 2022.
JuCify: A Step Towards Android Code Unification for Enhanced Static
Analysis.In 44thInternationalConferenceonSoftwareEngineering(ICSEâ€™22),
May 21â€“29, 2022, Pittsburgh, PA, USA. ACM, New York, NY, USA, 13 pages.
https://doi.org/10.1145/3510003.3512766
This work is licensed under a Creative Commons Attribution International 4.0 
License.
ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
Â© 2022 Copyright held by the owner/author(s).
ACM ISBN 978-1-4503-9221-1/22/05.
https://doi.org/10.1145/3510003.35127661 INTRODUCTION
Android app analysis has been one of the most active themes of
software engineering research in the last decade. Static analysis re-
search,inparticular,hasproducedavarietyofapproachesandtools
that are leveraged in a variety of tasks, including bug detection,
securitypropertychecking,malwaredetection,orempiricalstudies.
Thewidely-usedstate-of-the-artapproaches,suchasFlowDroid[ 5],
develop analyses that focus on the Dex bytecode in apps. Unfortu-
nately,recentstudies[ 1,38,50,62,69]haveshownthatmalware
authorsoftenbuildonnativecodetohidetheirmaliciousoperations
(e.g., private data leak) or to implement sandbox evasion [64].
The need to account for native code within Android apps is
becoming urgent as the usage of native code is growing within
both benign and malicious apps. Our empirical investigation on
apps from the AndroZoo [ 3] repository reveals that, in 2019, up to
62.9% of collected apps included native code within their packages.
Yet,nativecodeisscarcelyconsideredinappsecurityvetting[ 2,69].
Inthemajorityofstatic[ 5,13,16,25,34,47,78],dynamic[ 6,49,79]
and machine learning based techniques [ 48,55], native code is
overlooked since it presents several challenges.
When researchers propose techniques to address native code
such as with JN-SAF[69],DroidNative [2],NativeGuard [60],Tain-
tArt[61] and others [ 1,15,31,50], the integrated analyses (e.g.,
for taint tracking, native entry-point detection and machine learn-
ingfeatureextraction)aregenerallyad-hoc.Indeed,theseworks
develop custom techniques to bridge native code and bytecode,
typicallybycombiningresultsofseparateanalysesofbytecodeand
native code. Therefore, they do not yield an explicit unified model
of the app to which generic analyses can be applied to explore
bytecode and native code altogether.
Our work aims to fill the gap in whole-app analysis by research-
ingmeanstobuildaunifiedmodelofAndroidcode.Wepropose
JuCify,asteptowardbuildingaframeworkthatbreaksbytecode-
native boundaries for Android apps and therefore copes with acommon limitation of static approaches in the literature. To thebest of our knowledge, JuCify is the first approach that targetsthe unification of Android bytecode and native code into a uni-fied model and is instantiated in a standard representation [
36].
We target the Jimple[67] IntermediateRepresentation assupport
forJuCifyunifiedmodel.Jimpleistheinternalrepresentationin
the widely-used Soot framework and is indeed the representation
that is considered in a large body of static analysis works [ 36].
By supporting Jimple, JuCify provides the opportunity for several
analyses in the literature to readily account for native code.
12322022 IEEE/ACM 44th International Conference on Software Engineering (ICSE)
This paper. JuCify is a multi-step static analysis approach that
weimplementasaframeworkforgeneratingaunifiedmodelofapps
taking into account native code. It Â‚relies on symbolic execution
to retrieve invocations between both the Dex bytecode and the
native worlds, Âƒpre-computes native call-graph, Â„merges Dex
bytecode and native call-graphs, and Â…populates newly generated
functions with heuristic-based defined Jimple statements using
code instrumentation.
The main contributions of our work are as follows:
â€¢We propose JuCify, an approach to build a unified model of
Android app code for enabling enhanced static analyses. We
haveimplementedJuCifytoproducetheJimplecodethat
unifies bytecode and native code within an app package;
â€¢We conduct an assessment of the JuCify yielded model. We
showthatJuCifycansignificantlyenhanceAndroidappsâ€™
call-graphs. JuCify connects previously unreachable meth-
ods in Android apps call-graphs;
â€¢Weevaluatetheunifiedmodelofappcodeinthetaskofdata
flowtracking. We showthat JuCify cansignificantly boost
the precision of the state-of-the-art FlowDroid, from 0%
to82%anditsrecallfrom0%to100%onanewbenchmark
targeting bytecode-native data flow tracking;
â€¢We evaluate JuCify on a set of real-world Android apps and
show that it can augment existing analysers, enabling them
to reveal sensitive data leaks that pass through the native
code which were previously undetectable.
â€¢Wereleaseouropen-sourceprototypeJuCifytothecommu-
nity as well as all the artifacts used in our study at:
https://github.com/JordanSamhi/JuCify
The remainder of this paper is organized as follows. We first
introduce background notions and motivate our work in Section 2.
In Section 3, we present our JuCify approach. We evaluate JuCify
in Section 4. In Sections 5 and 6, wepresent the limitations and the
threats to validity of the current state of our approach. Finally, we
overview the related work in Section 7 and conclude in Section 8.
2 BACKGROUND & MOTIVATION
JavaandKotlinarethetwomainstreamprogramminglanguages
that support the development of Android apps. Their programs
are compiled into Dex bytecode and included within app packages
(in the form of DEX files). Nevertheless, thanks to Java Native
Interface[23], native code functionalities are accessible in Android
apps.Theycomeinbinary(e.g., .sosharelibrary)filescompiled
from input programs written in C/C++ for instance.
2.1 Java Native Interface (JNI)
JNIisanimplementationofthe ForeignFunctionInterface (FFI)[19]
mechanism that allows programs written in a given language to
invoke subroutines written in another language. JNI allows both
Java to native and native to Java invocations.
2.1.1 Java to native code. Listing 1 presents an example where JNI
capabilities are used to call a native function (here written in C ++)
fromJava.First,arelevantJavamethodisdefinedwiththekeyword
native(line4).Wewillrefertoitasa Javanativemethod .Then,its1/*** JAVA WORLD ***/
2 public class MainActivity extends Activity {
3 static{System.loadLibrary ("native-lib" );}
4 public native StringnativeGetImei (TelephonyManager tm );
5@Override
6 protected voidonCreate (Bundle savedInstanceState ){
7 super.onCreate (savedInstanceState );
8 TelephonyManager tm =(TelephonyManager )getSystemService ("phone");
9 String imei =nativeGetImei (tm);
10 Log.d("IMEI",""+imei);
11 }
12 public voidmalicious () {/* malicious code */ }
13}
14/*** C++ WORLD ***/
15JNIEXPORT jstring JNICALL
16Java_MainActivity_nativeGetImei (JNIEnv*env,jobject thiz ,jobject tm ){
17 jclass c =( *env).GetObjectClass (tm);
18 jmethodID m =( *env).GetMethodID (c,"getImei" ,"()Ljava/lang/String;" );
19 jstring i =(jstring)(*env).CallObjectMethod (tm,m);
20 c=( *env).GetObjectClass (thiz);
21 m=( *env).GetMethodID (c,"malicious" ,"()V");
22 (*env).CallObjectMethod (thiz,m);
23 returni;
24}
Listing 1: Code illustrating how an app can trigger native
code. (Methods and code are simplified for convenience)
correspondingnativefunctionisregisteredtosetupthemapping
between them. Such a registration can be:
Static-thenativefunctiondefinitionfollowsanamingconvention
based on specific JNI macros. For example, the Java native method
nativeGetImei (line 4) corresponds to a native function named
Java_com_example_nativeGetImei in C++(line 16).
Dynamic - developers can arbitrarily name their native functions
(in C++) as shown in Listing 2 (lines 10-13), but must inform JNI
abouthowtomapthemwithJavanativemethods.Thus,develop-
ersÂ‚first map Java native methods to their counterpart native
functions by using specific JNINativeMethod structures (lines 14-
16 in Listing 2); Âƒoverload a specific JNI Interface function [ 18],
JNI_OnLoad , to register the mapping (lines 17-24 in Listing 2); and
Â„invokeRegisterNatives inJNI_OnLoad which will be called
by Android VM (line 22 in Listing 2).
2.1.2 Native to Java. With JNI, developers can create and manipu-
lateJava objectswithin thenative code(e.g., writtenin C ++). The
fieldsandmethodsofJavaobjectsarealsoaccessiblefromthena-
tive code and can be invoked using specific JNI Interfacefunctions.
Eventually, likewise Java reflection [ 14], i.e., using strings to get
methods and classes, the developer can invoke the Java methods
(e.g., lines 17-19 in Listing 1).
Note that Listings 1 and 2 illustrate the interaction between Java
and C++. However, JuCify, the approach proposed in this paper,
works at the apk level. Therefore, the invocations are between
bytecode and compiled native code.
2.2 Motivating Example
Binarystaticcodeanalysisisinitselfachallenge[ 43]sincethecom-
piled code is hard to represent for appropriate investigation [30].
Althoughcurrentstate-of-the-artAndroidstaticcodeanalysis
approaches are sophisticated [ 5,34,56,70,76], most of the time
they overlook native code, with only a few of them considering
it [31, 69].
WithasimpleexampleillustratedinListing1,wemakethecase
thatnativecodeshouldbeconsideredinstaticanalysisapproaches.
12331/*** JAVA WORLD ***/
2 public class MainActivity extends Activity {
3 static{System.loadLibrary ("native-lib" );}
4 public native StringnativeMethod ();
5 @Override
6 protected voidonCreate (Bundle b ){nativeMethod ();}
7}
8/*** C++ WORLD ***/
9JNIEXPORT jstring JNICALL
10jstring arbitrary_name (JNIEnv*e,jobject thiz ){
11 std::string str ="str";
12 returne->NewStringUTF (str.c_str());
13}
14 static const JNINativeMethod m [ ]={
15 {"nativeMethod" ,"()Ljava/lang/String;" ,(jstring*)arbitrary_name }
16};
17JNIEXPORT jint JNI_OnLoad (JavaVM*vm,void*reserved ){
18 JNIEnv*e=NULL;
19 if(vm->GetEnv((void**)&e,JNI_VERSION_1_4 )! =JNI_OK){return-1;}
20 jclass c =e->FindClass ("com/example/MainActivity" );
21 if(!c){return-1;}
22 if(e->RegisterNatives (c,m,sizeof(m)/sizeof(m[0]))){ return-1;}
23 return1;
24}
Listing 2: Dynamic native function registration example.
(Methods and code are simplified for convenience)
First,intheonCreate() methodofthemain Activity ,aString
is retrieved on line 9 from the method nativeGetImei , then this
Stringisusedasaparametertothemethod Log.d().Fromthepoint
of view of taint tracking, there is a flow from the getImei() method
(source)tothe Log.d()method(sink). However,moststate-of-the-
artapproacheswillmissthisflowduetotechnicallimitationssince
themethod nativeGetImei isnotanalyzed.Thereforethevariable
imeiis not tainted, and the flow is not detected.
Second,themethod malicious() (line12)isnevercalledinthe
Javacode,thus,itwillnotappearinthecall-graphsinceitisconsid-
eredasunreachable .Henceitwillnotbeanalyzed,causingexisting
tools to fail to detect potential malicious code in the method.
Let us consider Figure 1, which presents the expected call-graph
ofthisexample.Thecurrentstate-of-the-artapproaches,suchas[ 5,
17, 34, 35, 70], generally analyze the green nodes which are reach-
able from an entry point. However, the red nodes will only be con-
sidered by approaches able to analyze the native code. Approaches
tryingtoovercomethechallengeofnativecodeanalysisinAndroid
apps, already exist (e.g., [ 31,50,52,69]). However, they focus on
specific analyses and propose custom solutions to bridge bytecode
and native code. In contrast, in this paper, we aim at offering an
explicitunifiedmodelofAndroidappstowhichgenericanalysis
could be applied to explore altogether bytecode and native code.
onCreatednativeGetImei
getSystemService getImeiGetObjectClassGetMethodId CallObjectMethod
malicious
Figure 1: Unified call-graph representation for the code in
Listing 1: Greennodes represent reachable nodes of exist-
ing static approaches, while Redones represent the nodes
unreachable with most of the existing static approaches
3 APPROACH
For a given Android app, JuCify aims to unify its Dex bytecode
and native code into a unified model and instantiate this model intheJimplerepresentation(i.e.,theintermediaterepresentationof
the popular Soot framework). In this section, we will first detail
theoverallJuCifyconceptualapproach,andthenwewillbriefly
present how we instrument the app to approximate the native
behavior.However,duetospaceconstraints,wewillnotpresentall
technicaldetails relatedtoJimple. Weinvite theinterestedreader
toconsiderallourpublicly-sharedartifactsontheprojectGithub
repository1. JuCify implementation is fully open-sourced.
3.1 Call Graph as Unified Preliminary Model
Toexplaintheoverallfunctioningof JuCify,wewillrestrictour
explanationstothenotionofCallGraph(CG).ACGcanbedefined
asð¶ðº=(ð‘‰,ð¸), whereð‘‰is a set of vertices representing functions,
andð¸âŠ†{ (ð‘¢,ð‘£)|ð‘¢,ð‘£âˆˆð‘‰}is a set of edges such as âˆ€(ð‘¢,ð‘£)âˆˆð¸,
there is a call from ð‘¢toð‘£in the program.
JuCify is a multi-step static analysis framework whose over-
all architecture is depicted in Figure 2. First, a submodule called
NativeDiscloser constructs the native callgraph and extracts the
mutualinvocationsbetweenbytecodeandnativecode.Then,native
callgraphisprunedandpreparedtobeSoot-compliantbeforebeing
mergedwiththebytecodecallgraph.Eventually,bothcallgraphs
are unified thanks to information related to the bytecode-native
method invocations. In the following with give more details about
the different steps of our approach.
Step 0: Native Call Graph Construction
Nativeprogramcall-graphconstructionisnottrivial[ 21].Infact,
a large body of work tackled this problem and proposed several
solutions to find function boundaries [ 21,26,44]. In this work,
thecall-graphsnativelibrariesinAndroidappsaregeneratedby
Angr [57], a well-known binary analysis framework, which is
wrapped into our submodule NativeDiscloser.
Step 1: Bytecode-Native Code Invocations Extraction
This step is performed over 4 sub steps: Â‚Retrieve bytecode
methods information; ÂƒExtract entry method invocations (i.e.,
bytecode to native); Â„Track native function calls and extract exit
method invocations.
Step 1.1: Methods info extraction is a straightforward task that
extracts information of bytecode methods, such as the class of a
method,methodsignature.Thisstepaimstocompletethesignature
informationrequiredtoperformthemethodinvocationsextraction
task for statically registered functions. We perform this task by
relying on AndroGuard [4].
Step1.2:Entrymethodinvocationsextraction: Anentrymethod
invocation is a native method invocation from the bytecode (i.e.,
abytecode-to-native"link").AsdescribedinSection2.1,forsuch
an invocation, we need to match a "Java native method" (i.e., a
method declared in Java with the nativekeyword, also called
entry method ) and anentry function (i.e., the counterpart native
function). To perform this task, we have to take care of both static
anddynamicregistrations.Thestaticallyregisteredfunctionscanbe
easily spotted via their naming conventions. However, as dynamic
registrationreliesonJNI interfacefunctioncalls,moresophisticated
techniquesarerequired.Inourcase,werelyonsymbolicexecution.
1https://github.com/JordanSamhi/JuCify
1234CG = Call-Graph, â€¢â€¢= Native CG Node, â€¢= Bytecode CG Node, â€¢= Previously Unreachable Bytecode CG Node
Step 1.1:
Methods Info
ExtractionStep 1.2: Entries
ExtractionStep 1.3:
Exits
Extraction
Step 0: Native
CG extraction
Step 2.1: Native
CG pruning
Step 3.1: Native
CG conversionStep 3.2: Patch
CG with
bytecode-to-
native edgesStep 3.3: Patch
CG with native-
to-bytecode edges
and bytecode nodes
Step 2.2:
Bytecode CG
constructionNativeDiscloser
Entry
functions
Final App ModelCG Component GenerationBytecode and Native Call-Graphs Unification
Entry
invocationsEntry/Exit invocations
.dex files.so files
Method info
Entry/Exit
invocationsEntry
functions
Figure 2: Overview of the JuCify Approach from the Angle of Call-Graph Construction
From a more technical point of view, NativeDiscloser takes as
input the library (i.e., .so) files of an apk and the method informa-
tionfromthepreviousstep.Itfirstscansthesymboltableofeach
binary to search for (1) statically registered native functions and
(2) theJNI_OnLoad function for the case of dynamically registered
functions.Then,if JNI_OnLoad exists,thisfunctionissymbolically
executed to further detect dynamically registered native functions.
For symbolic execution, NativeDiscloser relies on Angr [57].
Step1.3:Exitmethodinvocationsextraction: Wearelookingfor
theinvocationsofabytecodemethodfromthenativecode.Wecall
exit method this bytecode method. In Section 2.1.2, we explained
that this exit method is called by invoking certain JNI Interface
functionsinachainedmanner.Collectinginformationrelatedto
this chain of JNI function invocations is challenging.
Inpractice,toovercomethischallenge,NativeDiscloserexe-
cutes all the entry functions acquired from step 1.2 symbolically
to search for the exit method invocations and set up the relation
mapping between entry and exit method invocations.
Furthermore, exit methods could be invoked deep down in a na-
tivefunctionchain.However,thesymbolicexecutionisnotawareof
the boundaries between native functions. Hence, we implemented
atrackingmechanismduringthesearchofexitmethods.Werely
onthestartingaddressofeachnativefunctionobtainedfromthe
native call-graph to maintain a stack of native functions and push
a new function into the stack when its starting address is reached.
Popping a function from the stack is triggered by the arrival of
the return addresses of native functions, which can be obtained
fromacertainregisterormemorylocationbasedonarchitecture
specifications (e.g., link register LRforARM) during entering a
nativefunction.Thisallowsustoknowfromwhichnativefunction
an exit method invocation occurs.
Step 2: CG Components Generation
Step 2.1: Native CG pruning. Since in .so libraries not all the
functions are necessarily called in an app, we rely on a strategy to
onlykeeprelevantcallgraphparts.Todoso,weprunetheobtainednative call-graphs constructed in Step 0 with the help of the entry
functions passed in from Step 1. We only keep the sub-graphs
startingfromtheentryfunctions(withallsuccessornodes)since
the remaining parts will not be reachable from the bytecode.
Step 2.2: Bytecode CG construction. Our approach also requires
thebytecodecall-graph.Forthispurpose,weuse FlowDroid[ 5]
(itself based on Soot [ 66]) which leverages an advanced modeling
of app componentsâ€™ life-cycle.
Step 3: Bytecode and native call-graphs unification
Step3.1:NativeCGconversion. Inpractice,thetargetistoload
both native and bytecode call-graphs in Soot. Although this is
straightforward for the bytecode call-graph, the native call-graph
requires a conversion step to fit with Soot technical constraints.
Once loaded, the sets of nodes and edges of both call-graphs are
merged, but the call-graphs are not yet connected together.
Step3.2:PatchCGwithbytecode-to-nativeedges. Then,according
to the entry invocations obtained from Step 1.2, edges between
entry methods (in bytecode) and their counterpart entry functions
(in native code) are added.
Step 3.3: Patch CG with native-to-bytecode edges and bytecode
nodes.Finally, with the information of exit invocations and the
relationswithentryinvocationsfromStep1.3,edgesbetweennative
functionstoexitmethodsareadded.Thisstepallowsuncovering
previously unreachable bytecode callgraph nodes.
3.2 From CG to Jimple for a Unified Model
A call-graph is a useful model, but it is still limited because it
does not contain enough information to perform static analysis
(e.g.,dataflowanalysis).Indeed,importantinformationsuchasthe
statements present in each method is missing (i.e., the control flow
graph(CFG)).AtoolsuchasFlowDroidprovidestheCFGforeach
bytecodemethodwherethemethodbehaviorisrepresentedwith
Jimple statements. We will now explain how JuCify adds Jimple
statements in specific native functions in a best-effort mode. After
1235thisstep,foragivenAPK,weobtaintheJimplerepresentationof
the apk with both bytecode and native code unified.
Native functions generation: JuCify relies on a DummyBina-
ryClasswhosepurposeistoincorporateanynewlyimportednative
function in the Soot representation. For each native function in
the native call-graph, JuCify generates a new method in the Dum-
myBinaryClass with appropriate signatures.
Bytecode method statements instrumentation: JuCify gener-
ates bytecode-to-native call-graph edges. It also has to replace the
initialcalltothenativemethodatthestatementlevelwithacall
to the newly generated native function. JuCify takes care of the
returnedvalueandtheparameterstonotfoolanyanalysisbased
on the new built model.
Native function statements generation: There is no bijection
between native code and Jimple code [ 67]. Moreover, bytecode
and native code manipulate different notions (e.g., pointers) that
cannotbetranslateddirectly.Therefore, wehavetouseheuristics
based on the information at our disposal to put a first step toward
reconstructing native function behavior.
Letusconsideranativefunctionnamed foo()containingatleast
oneinvocationtoabytecodemethod ð‘š.AsexplainedinSection3.1,
the first step of JuCify aims to collect information about bytecode
methods(fullsignature).Thankstothis,wecanapproximatethe
parameters used by ð‘šas well as its return values.
More specifically, in Listing 3, we detail the steps JuCify imple-
mentstopopulatethenativefunction foo()thatcallsabytecode
methodð‘š.Letconsider ð‘šisdefinedinaJavaclassnamed MyClass.
In line 1, JuCify starts with the empty method foo(). Then:
Step 1 in Listing 3: If the bytecode method ð‘šshould return a
value, JuCify generates a new local variable with the same type as
the methodâ€™s return type (line 4).
Step2inListing3: JuCify generates the declaration of a variable
oftypeMyClass,theclassinwhich ð‘šisdefined(line8).Inline9,
JuCifycreatesanew MyClassinstance(ifthereisnotoneusable
as a base for the bytecode call).
Step3inListing3: Regardingtheparametersthatshouldbeused
for the invocation of ð‘š, JuCify scans foo()for local variables and
parameters whose types match the types of the parameters of ð‘š.
If, for a given type, no local variable, nor parameter of foo()is
found, JuCify generates one (e.g., line 15). Then, it generates all
the permutations of these variables with a given length (i.e., the
number of parameter of ð‘š) and retains only those matching the
typesâ€™ order of the parameters of ð‘š((ð‘–1,ð‘ ), and(ð‘–2,ð‘ )in Listing 3).
Each retained permutation corresponds to a possible call to the
bytecode method in the native function as an over-approximation.
Nevertheless, these calls cannot be generated sequentially since
they correspond to different realities. Hence, we rely on opaque
predicates ( ifstatements whose predicate cannot be evaluated
statically)sothateachcontrolflowpathisconsideredidentically
(lines 16-17).
Step 4 in Listing 3: If the native function returns a value (from
the signature of foo()), JuCify should generate return statements.
Todoso,itoperatesasfor ð‘š.Itreliesonopaquepredicates.Indeed,
first,JuCifyscansthebodyofthecurrentnativefunctiontofind
any local variable corresponding to the type of the return value
(eventhosenewlygeneratedlocalvariablesthatcouldbereturned).
Ifnovariableisfound,JuCifygeneratessuchavariable.Else,for1 public boolean foo(inti1,inti2,boolean b1){}
2// STEP 1
3 public boolean foo(inti1,inti2,boolean b1){
4 boolean b2;
5}
6// STEP 2
7 public boolean foo(inti1,inti2,boolean b1){
8 boolean b2;MyClass jc ;
9 jc=newMyClass();
10}
11// STEP 3
12 public boolean foo(inti1,inti2,boolean b1){
13 boolean b2;MyClass jc ;String s ;
14 jc=newMyClass();
15 s=newString();
16 if(opaque_predicate ){b2=jc.m(i1,s);}
17 else if(opaque_predicate ){b2=jc.m(i2,s);}
18}
19// STEP 4
20 public boolean foo(inti1,inti2,boolean b1){
21 boolean b2;MyClass jc ;String s ;
22 jc=newMyClass();
23 s=newString();
24 if(opaque_predicate ){b2=jc.m(i1,s);}
25 else if(opaque_predicate ){b2=jc.m(i2,s);}
26 if(opaque_predicate ){returnb1;}
27 else if(opaque_predicate ){returnb2;}
28}
Listing 3: JuCifyâ€™s process to populate native functions
eachoffoundlocalvariables,JuCifygeneratesreturnstatements
withopaquepredicatessothateachpathcanbeequallyconsidered
(lines 26-27 in Listing 3).
Finally, JuCify yields a unified model of Android apps on which
analysts can perform any static analysis.
4 EVALUATION
Weinvestigatethefollowingresearchquestionstoassesstheim-
portance of our contributions:
RQ1:Whatistheproportionandevolutionofnativecodeusage
in both real-world benign and malicious apps?
RQ2:To what extent our bytecode-native invocation extraction
step(namedNativeDiscloser)yieldsbetterresultsthanthe
state-of-the-art ?
RQ3:Can JuCify boost existing static data flow analyzers?
RQ4:How does JuCify behave in the wild? We address this ques-
tion both at the quantitative and qualitative levels:
â€¢RQ4.a:To what extent can JuCify augment appsâ€™ call-
graphs and reveal previously unreachable Javamethods?
â€¢RQ4.b:Can JuCify reveal previously unreachable data
leaks that pass through native code in real-world apps?
4.1 RQ1: Native code usage in the wild
This section presents general statistics about the usage of native
code in both benign and malicious Android apps. We also perform
an evolutionary study of this usage.
Dataset: We rely on the AndroZoo repository [ 3] to build Â‚
a dataset of 2641194 benign apps (where we consider an app as
benignifnoAntivirusinVirusTotal[ 65]hasflaggedit-score0);
andÂƒadatasetof 174342maliciousapps(whereweconsideran
appasmaliciouswhenatleast10AntivirusenginesinVirusTotal
haveflaggedit).Bothdatasetscontainalltheappsfrom2015to2020
thatwewereabletocollectfromAndroZoowiththementioned
VirusTotal constraints.
Empiricalstudy: AndroidprogrammingwiththeNativeDevel-
opment Kit (NDK) suggests developers to integrate native libraries
1236(i.e.,.sofiles) whose code can be invoked from the Java world.
Therefore,tostudytheextentofnativecodeusageinAndroidapps,
asapreliminarystudy,foreachapp,wecheckifitcontainsatleast
one .so file in its APK file. However, since native libraries can be
presentinappsbutneverused,wealsocheckforeachappifJava
native methods (cf. Section 2.1) are declared in the bytecode.
Goodware Malware
#Apps w/.so files w/native methods #Apps w/.so files w/native methods
2015632279220934 (34.9%)216329 (34.2%) 8954265221 (72.8%)63275 (70.7%)
20161103899 405209 (36.7%)404357 (36.6%) 4835835601 (73.6%)34240 (70.8%)
2017277690143463 (51.7%)143183 (51.6%) 151418742 (57.7%) 8539 (56.4%)
2018304746191491 (62.8%)184447 (60.5%) 108908415 (77.3%) 8018 (73.6%)
2019179309113433 (63.3%)112873 (62.9%) 9773 8993 (92.0%) 8311 (85.0%)
202014327181755 (57.1%) 81111 (56.6%) 638 446 (69.9%) 274 (42.9%)
Total2641194 1156285 (44%) 1142300 (43%) 174342127418 (73%) 122657 (70%)
Table 1: Number and proportion of Android apps that con-
tainatleastone" .sofile"/"Javanativemethod"(w/=with).
Resultsof our empirical study are presented in Table 1. They
indicate that, overall, 1156285 benign apps (i.e., 44%) contain at
leastone.sofile,and 1142300 (i.e.,43%)containatleastoneJava
native method declaration. This means that 98.8% of apps with
native libraries contain Java native method declaration in their
bytecode. Regarding malware, 127418(i.e.,73%) of apps contain
nativelibrariesand 122657(i.e.,70%)Javanativemethoddeclara-
tions.Hence, 96.3%ofmalwarewithnativelibrariescontainJava
native method declarations. Overall, these results show that native
code is, in proportion, more used in malicious apps.
Regarding usage evolution in benign apps, the rate increases
until 2018 to reach a plateau at around 60%. The trend regarding
malware is much more erratic (with sharp decreases in 2017 and
2020).However,foreachyear,maliciousappsusesignificantlymore
native code than benign apps.
RQ1answer: NativecodeisdefinitelypervasiveinAndroidapps.
Whilebothbenignandmaliciouscodeleveragenativecode,native
invocationsare substantiallymore commonin malware( 70%vs.
43%).
Theseresultsindicatethatignoringnativecodeisaseriousthreat
to validity in Android static code analysis.
4.2 RQ2: Bytecode-Native Invocation
Extraction Comparison
Identifyingnative-to-bytecodeandbytecode-to-nativecodeinvo-
cationsarekeysteps towardscodeunification.Ourobjectiveisto
estimatetowhatextentthecorrespondingbuildingblockinJuCify
is effective against a benchmark and against the state of the art.
Native to Bytecode: Fourtounis et al.[15] proposed an ap-
proach to detect exit invocations (i.e., native to bytecode invo-
cations, c.f., Section 3.1) in native code via binaryscanning. Their
tool named Native-Scanner [ 46] has been developed as a plugin
ofaframeworkcalledDOOP[ 45].Briefly,theirtoolscansbinary
filesforstringconstantsthatmatchJavamethodnamesandJava
VMtypesignaturesandfollowstheirpropagation.Inthisway,they
consider all matches as new entry points back to bytecode.
TocompareourNativeDiscloserwithNative-Scanner,we
developed and released 16 benchmark apps. All these apps are
executable Android apps and have been tested on a Nexus5 phone
with Android version 8.1.0. We design these apps to cover differentsituations such as dynamic/static registration, chained invocations
innativefunctions,parameterpassingviastructuresandclasses,
stringaccessingviaarraysandfunctionreturns,stringobfuscation,
etc. Table 2 presents the results obtained with both tools.
TP= True Positive, FP= False Positive, FN= False Negative
BenchmarkNative-Scanner NativeDiscloser
TP FP FN TP FP FN
ð‘ð‘š1âˆ’5,ð‘ð‘š7,ð‘ð‘š10âˆ’12â€ 101200
ð‘ð‘š6,ð‘ð‘š8 102300
ð‘ð‘š9 002002
ð‘ð‘š13 015500
ð‘ð‘š14 141200
ð‘ð‘š15,ð‘ð‘š16 101101
Precision 73.68% 100%
Recall 37.84% 89.19%
â€ due to space limitation, we put together apps with same results.
E.g., NativeDiscloser detects 3 TP for each app ð‘ð‘š6andð‘ð‘š8.
Table 2: Comparison of Tools
These results show that Native-Scanner misses a high number
ofexitinvocations.WerealizedthatNative-Scannerseemsnot
to consider Android framework APIs (the tool misses the API invo-
cationsinallbenchmarkapps).Notethat Native-Scannerisnot
specific to Android. This could explain why it does not consider
Android APIs. The tool is also challenged by constant string obfus-
cation(app ð‘ð‘š9),whichisalsothecaseforNativeDiscloser. bm14
implements fake method string constants in the native part. For
this app,we can observethe over-estimation of Native-Scanner
(i.e.,ahighnumberoffalse-positive)whileNativeDiscloserisnot
affected.Finally,NativeDiscloseralsofailedwithstringconstants
passing via arrays and function returns as implemented in bm15
andbm16respectively. Limitations of Angr could cause this in
parsingpointerofpointers.Overall,comparedtoNative-Scanner,
NativeDiscloser obtains significantly higher precision and recall.
Bytecode to native: We were unable to compare NativeDis-
closer with Native-Scanner. Unlike our tool,Native-Scanner
doesnotinvestigate(1)bytecodetonativeentryinvocationsand
(2) the relations mapping between entry and exit invocations.
Note,however,thatonourbenchmarkof16apps,NativeDis-
closer yields 100% precision in finding both the entry invocations
and theentry-to-exit relations and achievesa recall of 95.59%and
89.19% respectively.
RQ2answer: Comparedtothestate-of-the-artNative-Scanner,
our NativeDiscloser extracts exit invocations with better preci-
sionandrecall.Besides,itcanprovideextrainformation,including
entry invocations (i.e., bytecode to native invocations) and the
relations with exit invocations, which is essential to generate
comprehensive call-graphs.
4.3 RQ3: Can JuCify boost static data flow
analyzers?
InSection3,wedescribedhowJuCifycouldapproximatethebe-
havior of native functions based on the information retrieved from
signatures,parameters,returntype,andbytecodemethodscalled
from native code via JNI. In this RQ, we check if this first step
approximationhelpsperformadvancedstaticanalysessuchasdata
1237leak detection on a well-defined benchmark. We will assess the
capability of JuCify on real-world applications in RQ4.
The benchmark that we built for RQ3 contains 11 apps that we
plantointegrateintoDroidBench,anopentestsuitethatcontains
hand-crafted Android apps to assess taint analyzers. Among these
apps,9containaflowgoingthroughthenativeworld,and2donot
contain any data flow(to detect potentialfalse positives). Then, we
apply the state-of-the-art FlowDroid taint-analysis engine before
and after applying JuCify in our benchmark apps, to show that
FlowDroidcan,likewisein[ 56],beboosted.FlowDroiddetects
paths from well-defined sources (e.g., getDeviceId() ) and sinks
(e.g.,sendTextMessage() ) methods in Android apps.
Benchmarkconstruction: We identified 4 cases on which we
builtour11benchmarkappstoassesstheabilityoftoolsindetecting
data leak via native code:
a) Getter: Source in native code and sink in Java code
b) Leaker: Source in Java code and sink in native code
c) Proxy: Source in Java code and sink in Java code
d) Delegation: Source in native code and sink in native code
Note that "Source/Sink in native code" means that the call to
a sensitive method is actually performed in native code, but the
sensitive method is always a method from the Android framework
accessedwithJNI(e.g.,callingwithJNIthe getDeviceId() from
thenativecode).Foreachofthesecases,atleastonestephappensin
native. Figure 3 illustrates these four cases. The red dots represent
tainted information from a source method, and the red arrows
representhowthisinformationflowsintheprogram.The Getter
use-caseallowsdeveloperstogetsensitivedatafromthenativecode
to leak it in the Java world. The Leakeruse-case allows developers
to get sensitive data from the Java world to leak it in the native
world.Regardingthe Proxyuse-case,thesensitiveinformationis
retrieved in the Java world, sent to the native world to "break" the
flow, and sent back to the Java world to be leaked. Concerning the
Delegation use-case,asimplenativefunctioniscalledfromtheJava
world, and the sensitive information is retrieved and leaked in the
native world.
Our benchmark apps has been built, upon these four cases that
weidentified,toberepresentativeofthesecases,withcombination
of multiple cases.
Results: Table 3 provides the results of our experiments. Flow-
Droid is clearly limited and not designed to handle native code.
Therefore its inferior performances are not surprising. Indeed,
FlowDroid gets a precision and recall of 0% on this benchmark.
Nevertheless,wecanseethatafterapplyingJuCify,FlowDroid
performanceissignificantlyboosted.Indeed,itcandetectallthe
leakspresentinthebenchmark,henceachievingarecallscoreof
100%. Regardingapps getter_string andleaker_string , FlowDroid
reportsforbothofthemafalsepositivealarmleadingtoaprecision
of 82% on this benchmark. In these apps, a string is sent outside
theapps,notsensitivedata.Thisiseasilyexplainedbythefactthat
when JuCify reconstructs the native functionâ€™s behavior, it uses
opaquepredicatestoapproximatewhatvariablecanbereturnedby
the current function given its signature. Therefore, there is a path
in which the sensitive data is considered, whereas it is not leaked.â€¢= Tainted Information, = Call Edge, â†’= Taint Propagation,
â€¢= Method entrypoint
= native()
sink( )= source( )
return
Java Native
(a) Getter= source()
native( )sink( )
Java Native
(b) Leaker
= source()
= native( )
sink( )return
Java Native
(c) Proxynative()= source()
sink( )
Java Native
(d) Delegation
Figure 3: Four propagation scenarios through native code
/circlecopyrtâ˜…= true-positive, â˜…= false-positive, /circlecopyrt= false-negative
Test Case LeakFlowDroid JuCify
getter_imei â€¢ /circlecopyrt /circlecopyrtâ˜…
leaker_imei â€¢ /circlecopyrt /circlecopyrtâ˜…
proxy_imei â€¢ /circlecopyrt /circlecopyrtâ˜…
delegation_imei â€¢ /circlecopyrt /circlecopyrtâ˜…
getter_string â—¦ â˜…
leaker_string â—¦ â˜…
proxy_double â€¢ /circlecopyrt /circlecopyrtâ˜…
delegation_pr oxy â€¢ /circlecopyrt /circlecopyrtâ˜…
getter_leaker â€¢ /circlecopyrt /circlecopyrtâ˜…
getter_pr oxy_leaker â€¢ /circlecopyrt /circlecopyrtâ˜…
getter_imei_de ep â€¢ /circlecopyrt /circlecopyrtâ˜…
Sum,Precision, Recall
/circlecopyrtâ˜…,higheris better 0 9
â˜…,lower is better 0 2
/circlecopyrt,lower is better 9 0
Precisionð‘=/circlecopyrtâ˜…/(/circlecopyrtâ˜…+â˜…) 0% 82%
Recallð‘Ÿ=/circlecopyrtâ˜…/(/circlecopyrtâ˜…+/circlecopyrt) 0% 100%
ð¹1-score=2ð‘ð‘Ÿ/(ð‘+ð‘Ÿ) 0% 90%
Table 3: Results of data leak detection through native code
inbenchapps.FlowDroidcolumnrepresentstheresultsof
running FlowDroid alone. JuCify column represents the
results of running FlowDroid after applying JuCify
RQ3answer: Jucifyisessentialforboostingstate-of-the-artstatic
analyzerssuchasFlowDroidtotakeintoaccountnativecode.On
our constructed benchmark, FlowDroid, which failed to discover
any leak, is now able to precisely identify leaks in a high number
of samples (F1-score at 90%).
12384.4 RQ4: JuCify in the wild
In this section, we evaluate JuCify in the wild from two points
of view: Â‚a quantitative assessment in section 4.4.1; and Âƒa
qualitative assessment in section 4.4.2.
4.4.1 RQ4.a:TowhatextentcanJuCifyaugmentappsâ€™call-graphs
and reveal previously unreachable Java methods?
Toassesstowhatextentcall-graphsareaugmentedby JuCify,
we appliedit on twosets ofAndroidapps: 1) 1000benign apps;2)
1000malware.Notethatweonlyselectedappsthatcontainatleast
one.sofile.TheresultsreportedconcernappsforwhichJuCify
succeededtomakecall-graphchanges.Thereasonsforwhichthere
are apps without changes is related to the absence of bytecode-to-
nativelinks(i.e.,for559goodwareand384malware)and/orJuCify
reaching the 1h-timeout (i.e., for 15 goodware and 51 malware).
Number of nodes and edges in call-graphs: We first report
the average number of nodes (i.e., the number of methods) and
edges (i.e., the number of potential invocations) in the call-graphs
obtained before and after having applied JuCify.
Thecall-graphaugmentationsbroughtbyJuCifyarevisiblein
Table4.Column #appsrepresentsthenumberofappsforwhich
JuCify made callgraphchanges, i.e., theydid not reach the timeout
andcontainedbytecode-nativelinks.Wenoticethatabouthalfof
theappsâ€™call-graphsareimpactedbyJuCify(426and565forgood-
wareandmalwarerespectively).Wethennoticethatthenumber
ofnodesandedgesaddedbyJuCifyishigherforgoodwarethan
formalware:270 vs.197onaverageperapp fornodes,and778vs.
446 for edges. This shows that classical static analyzers that do not
take into account the native code, overlook a significant amount of
nodes and edges in their call-graph.
Before JuCify After JuCify Difference
#apps#Nodes#Edges #Nodes#Edges Added Nodes Added Edges
Goodware 426 4515 18287 4784 19065270 (+5.9%) 778 (+4.2%)
Malware565 3056 14266 3253 14712197 (+6.4%) 446 (+3.1%)
Table 4: Average numbers of nodes and edges before and af-
ter JuCify on 426 goodware and 565 malware
Numberofbinaryfunctionsintheaugmentedcall-graph:
Newlyaddednodescanbeexplainedbythebinaryfunctions(i.e.,
functionsinthenativecodepart)thatarenowconsideredinthe
unifiedcallgraphyieldedbyJuCify.Figure4detailsthedistribu-
tionsofthenumberofbinaryfunctionsforbothdatasets.Wenotice
thatbenignappstendtohavemoreaddedbinaryfunctionnodes
(median = 172, and mean = 269.7) in the call-graph than malicious
apps(median=162,andmean= 197.2).Bothdistributionsaresig-
nificantly different, as confirmed by a Mann-Whitney-Wilcoxon
(MWW) test [41] (significance level set at 0.05).
(PPEXBSF.BMXBSF
Figure 4: Distribution of the number of binary functions
nodes in benign and malicious Android apps
Numberofbytecode-to-nativecall-graphedges: Newlycre-
ated edges can originate from nativefunction invocations in byte-
code methods (i.e., entry invocations). We compute the number
of bytecode-to-native edges in appsâ€™ call-graph and detail theirdistributions over our datasets in Figure 5. The difference between
malwareandgoodwareissignificant,withamedianequalto14for
malwareand8forgoodware.Overall,JuCifyrevealsatotalof 6758
bytecode-to-nativeinvocationsinthemalwaredatasetand 29908
in the goodware dataset.
(PPEXBSF.BMXBSF
Figure 5: Distribution of the number of bytecode-to-native
edges in benign and malicious Android apps
Numberofnative-to-bytecodecall-graphedges: Newlyadd-
ed edges can also originate from bytecode methods invoked in na-
tivefunctions(i.e.,exitinvocationswithreflection-likemechanisms
as explained in Section 2.1.2). The median of number of edges is
significantlylowforbothgoodwareandmalware.Indeed,theme-
dian of native-to-bytecode edges is equal to 3 for both datasets, the
distribution is available in Figure 6. Overall, JuCify reveals a total
of261native-to-bytecodeinvocationsintheentiregoodwareset
and 4288 in the malware set. The conclusion that can be drawn
from these results is the following:
thelownumbersofnative-to-bytecodeedgesingoodwareshows
thatbenignappsmakelittleuseofreflection-likemechanismsto
invoke Java methods from native code, compared to malware.
(PPEXBSF.BMXBSF
Figure 6: Distribution of the number of native-to-bytecode
edges in benign and malicious Android apps
Newpreviouslyunreachablebytecodemethods: Byconsid-
eringnativecode,JuCifycanrevealpreviouslyunreachablebyte-
code methods that are now reachable (because called from the
nativepart).Thenumberofpreviouslyunreachablebytecodemeth-
odsishighlylinkedtothenumberofnative-to-bytecodecall-graph
edgesdiscussedinthepreviousparagraph.However,anewedge
fromnativetobytecodecansimplyendtoapreviouslyreachable
node,whichdoesnotpresentaninteresthere.Indeed,newlyreach-
ablenodesareinterestingsincetheyallowstaticanalyzerstonot
consider them as dead code anymore. In Section 4.3, we give a
concrete example of the importance of this metric.
Overall,JuCifycanreveal 34previouslyunreachablebytecode
methods in 18 benign apps (with a maximum of 5 for one given
app). For malicious apps, JuCify reveals 122previously unreach-
able bytecode methods called from native code in 54 apps. This
accountsfor13%ofnative-to-bytecodeinvocationingoodwareand
2.8%formalware.ThissuggeststhatinmostcaseswhenAndroid
app developers invoke bytecode methods from native code, it is
to trigger bytecode methods that are already reachable from the
bytecode.However,thisshowsthatanon-negligeableproportion
of bytecodeinvocation from the nativein goodware and malware
are overlooked by classical static analyzers since they account for
non-reachable nodes in original bytecode callgraph.
Goodware vs. Malware native/bytecode calls: Tobetterun-
derstand the difference between goodware and malware, we in-
spected the native functions invoked from the bytecode and the
1239bytecodemethodsinvokedfromthenativecode.Resultsindicate
thatin82.7%ofthecases,thenativefunction Java_mono_android_-
Runtime_register isinvokedfromthebytecodeingoodware.In
fact, most of the top invoked native functions in goodware are
from the monoframework, which is used by Xamarin [ 74]. The
samemethodis,however,notfoundinthemalwaredataset.The
top invoked native functions in malware is composed of differ-
ent elements such as Java_com_seleuco_mame4all_Emulator_-
setPadData ,Java_com_shunpay210_sdk_CppAdapter210_pay ,or
more suspicious functions: Java_iqqxF_TZfff_ggior andJava_-
glrrx_efgnp_twCJN .
From native to bytecode, we note some interesting insights:
while benign apps invoke from the native code, in the majority
ofcases,bytecodemethodslike Context.getPackageName (14.2%),
orThreadLocal.get (8.2%),maliciousappsinvokemethodssuchas
TelephonyManager.getDeviceId (2.4%),orTelephonyManager.-
getSubscriberId (4.3%) which can indicate suspicious behaviors.
Ourresultsbecomemoreconvincingbyfocusingonbytecode
methodsthatwerepreviouslyunreachableincall-graphsandcalled
fromnativecode.Whilemostofthebytecodemethodsthatwere
previouslyunreachableandcalled inthenativecodeingoodware
areMonoframework methods, in malware, the situation is differ-
ent. Indeed, the most used bytecode methods in native code are
dedicatedtopaymentlibraries(e.g., com.shunpay208.sdk.Shun-
Pay208), and sensitive methods such as getDeviceId .
RQ4.a answer: JuCify helps to discover new paths in app be-
haviour.Itaugmentscall-graphswithabout5-6%newnodesin
bothbenignandmalwareapps.Overall,appstendtousemuch
more bytecode-to-native invocations than native-to-bytecode.
However,malwareseemstousebytecodeinvocationsfromnative
to perform suspicious activities.
4.4.2 RQ4.b:CanJuCifyrevealpreviouslyunreachablesensitivedata
leaks that pass through native code in real-world apps?
WiththisRQ,ourgoalistoassessJuCifyfromaqualitativepoint
ofview.Inparticular,wecheckwhetherthecall-graphsaugmented
by JuCify with previously unseen nodes are relevant. To that end,
we run JuCify and FlowDroid on real-world apps to check if
FlowDroidcandetectsensitivedataleaksthroughthenativecode.
Experimental setup: To assess JuCify in the wild, we selected
malicious applications since the intuition is that malicious apps
tend to leak sensitive data more than goodware. Therefore, we
randomly selected 1800malicious apps (i.e., VirusTotal score >20)
fromAndrozoo[ 3]thatcontain.sofiles.Besides,todetectdataleaks,
weusedthedefaultsourcesandsinksprovidedbyFlowDroid.For
each of these 1800apps, we set a 1-hour timeout (30 min for the
symbolic execution and 30 min for FlowDroid).
Findings: Among the 1800malicious apps, 1460contained Java
native methods declaration(s) in the code. In total, JuCify was
abletoaugmentthecall-graphof 1066(i.e.,73%)ofthe 1460apps
that contain both .so files and Java native method declaration in
bytecode. From these 1460apps, FlowDroid revealed sensitive
data leaks that take advantage of the native code in 14 apps. These
14 apps were manually checked and confirmed to contain sensitivedataleaksthatgoesthroughthenativecode.Notethatthisnumber
is highly linked to the source and sink methods used.
In the following, we discuss two case studies where JuCify was
able to reveal sensitive data leaks that pass through native code.
Both Android apps were manually checked by the authors to con-
firm the presence of a leak detected by FlowDroid.
4.4.3 Getter-Scenario Case Study. In Figure 3a we illustrated an
exampleofhowmalwaredeveloperscanrelyonnativecodetohide,
from static analyzers, the retrievalof sensitive data from static ana-
lyzers.JuCifyrevealedanAndroidmalware2implementingthis
specificbehavior.JuCifyreconstructedthe A()nativemethodfrom
thecom.yclass as the following: " <DummyBinaryClass: java-
.lang.String Java_com_y_A(android.content.Context)> ".In
this native function, the IMEI number of the device is obtained
via the JNI interface and returned as a result. This reconstructed
method is called in method b()of classcom.cance.b.q to store
the IMEI number. The resulting IMEI number is then wrapped and
transferred to a method to log it.
After examining the VirusTotal report of this app, we found
that the flags raised by antiviruses refer to Trojan behavior and
explicitlymentiontheretrievalofsensitiveinformationfromthe
deviceaswellastheuseofnativecodeintheimplementationof
the malicious behaviour. To some extent, this corroborates that
JuCifycontributedtouncoveramaliciousbehaviourthatishidden
through exploiting native-to-bytecode links (which state of the art
static analyzers could not be aware of).
4.4.4 Leaker-ScenarioCaseStudy. InFigure3b,weillustratedhow
app developers can rely on native code to hide the leakageof sensi-
tivedata.JuCifyrevealedanAndroidmalware3withthisbehavior.
First,theIMEInumberisobtainedinthe getOperator() method
of thecom.umeng.adutils.AppConnect class and stored in the
imeifield of the same class. Then, in the processReplyMsg()
method of this class (method which is triggered when an SMS
isreceived),theIMEInumberiswrappedinanotherstringandsent
to the native method " stringFromJNI() " as a parameter. JuCifyâ€™s
instrumentation engine constructed the following method from
this native method: " <DummyBinaryClass: java.lang.String
Java_com_umeng_adutils_SdkUtils_stringFromJNI(android.-
app.PendingIntent,java.lang.String,java.lang.String)> ".
Thislatterhasbeenpopulatedwiththeinformationgivenbythe
symbolicexecutionandrevealedthatthe sendTextMessage() met-
hodfromthe android.telephony.SmsManager classiscalledwith
the valued derived from the IMEI number as parameter.
Tosummarize,avaluederivedfromtheIMEInumberissentout
of the device using an SMS through the native code. Doing so, the
leak would have remained undetected without JuCify.
Asinthepreviouscasestudy,weexaminedtheVirusTotalreport
of this app. In their majority, antiviruses flag it as a Trojan app.
Some reports even explicit tag the use of getDeviceId() and of
native code for the malicious operations. Thus, with JuCify we
enabled an existing analyzer to uncover a leak being performed
through native code.
2SHA-256: 54DAFDF3635B18C0FD9F5CE89FE14C072D75AB4687B376FBADF370388574DC14
3SHA-256: A0B7BFBC272B462A2F59CC09ACC8B75114137CF7A2B391201C14C1A90EA7E369
1240RQ4.b answer: JuCify is effective for highlighting data flows
across native code that were previously unseen. Indeed, its en-
hanced call-graphs enable static analysers to reveal sensitive data
leaks within real-world Android apps.
5 LIMITATIONS
Our approach is a step towards realizing the ambition offull code
unification for Android static analysis. Our current prototype of
JuCify,despitepromisingperformances,presentsafewlimitations:
First,ourimplementationreliesonexistingtoolstoextractnative
call-graphsandmutualinvocationsbetweenbytecodeandnative
code.LimitationsofthesetoolsarethereforecarriedovertoJuCify.
Suchlimitationsincludetheexponentialanalysistimeforsymbolic
execution,thelimitationinfindingtheboundariesofnativefunc-
tions,theunsoundnessinappmodelingwithFlowDroiddueto
reflectivecalls[ 35],multi-threading[ 40],anddynamicloading[ 75].
Second, our prototype currently relies on symbolic execution
whichisknowntobenon-scalableinthegeneralcase.Therefore,as
describedinSection4.4.1,thecall-graphofsomeAndroidappswas
notaugmentedduetothesymbolicexecutionthatdidnotreturn
native-bytecode links and/or due to the timeout.
Third, a major limitation of JuCify lies in the fact that it does
notyetreconstructnativefunctionsbehaviorwithhighprecision.
Indeed, as described in Section 3.2, for the native functions that
represent Java native function, JuCify considers a partial list of
statements: it employs opaque predicates to guide static analyzers
into considering every possible path during analyses. Moreover,
JuCifyoverlooksnativefunctionsthatarenotexplicitlytargeted
by JNI Java calls since it cannot approximate their behavior in
the current implementation. As a result, JuCify cannot generate
nativefunctionsâ€™controlflowgraphswithJimplestatementsthat
cover the full behavior of functions. This limitation implies that if,
for instance, a leak is performed by using Internet communication
implemented"purely"inC(e.g.,withasocket),thenthisleakwould
notbedetectedwithFlowDroidevenafterJuCifyprocessing.Also,
duringthereconstructionphasedescribedinSection3.2,in some
cases where the number of parameter is important, the number
ofparametercombinationcanexplode.Thiscanleadtomethods
beingextremelylongthatmightnotrepresentreality.Weplanto
address this limitation in future work.
6 THREATS TO VALIDITY
Manual Checking. To check the correctness of the results, we
manually checked a hundred Android apps. To do so, we relied on
Java bytecode decompilers and native code decompilers such as
Jadx [58] and RetDec [ 29]. Although native code manual checking
ischallenging,wewereabletoconfirmthatthenativenodesadded
byJuCifymatchedthenodesfromthenativecallgraphconstructed
byNativeDiscloser.Regardingbytecode-to-nativelinks,asthe
symbolswerealwaysavailablefortheappswechecked(sincenative
methods were statically registered), we were able to confirm the
correctness of those links in the callgraph generated by JuCify.
We reverse-engineered these apps and were able to reach the same
conclusions.Regardingnative-to-bytecodelinks,themethodnames
arerepresentedasstrings,whicharenotdirectlyavailableinthe
nativecode.Therefore,wefacedachallengetocheckifthesymbolicexecution yielded correct links. One way to verify would be to
executethecodeparttotriggerthenativecodeandensurethatthe
correct information are yielded by NativeDiscloser, but this is a
challengeperseanditisoutofthescopeof thisstudy.Therefore,
we made the hypothesis that the symbolic yields correct results.
7 RELATED WORK
StaticanalysisofAndroidapps. StaticanalysisofAndroidapps
iswidelyexploredtoassessappproperties.Lessthan10yearsafter
theintroductionofAndroid,asystematicliteraturereview[ 36]has
shownthatoveronehundredpaperspresentedstaticapproaches
to analyze Android apps. The review highlights that Android appsâ€™
security vetting is one of the main concerns for analysts, who
assess properties such as sensitive data leak detection [ 5,34,56],
or check for maliciousness [ 20,33,72]. Static approaches have
alsobeenimplementedtoidentifyfunctionalandnon-functional
defects [10,73] and towards fixing runtime crashes [ 27,63]. Static
analysis is also further leveraged to collect information in apps
towards improving dynamic testing approaches [ 28,42,59,77].
Given these fundamental usages of static analysis, it is essential
totakeintoaccountallcodethatimplementsanypartoftheapp
behavior. Therefore, the fact that many analyses are reduced to
focus on the bytecode (while leaving out native code within app
packages) constitutes a severe threat to validity in many studies.
Binary analysis. Binary analysis techniques have been applied
for different platforms, using static [ 7,9,12,21], dynamic [ 6,8,37],
hybrid [11,22,54] and machine-learning-based [ 32,39,68,71]
approaches. A recent work [ 15] tackles the challenging task of
analyzing binaries by combining declarative static analysis (us-
ingDatalogdeclarativelogic-basedprogramminglanguage)with
reverse-engineering techniques to perform x-refs analysis in na-
tive libraries using Radare2 [ 51]. In the Android realm, analysis of
binaries can be essential to cope with obfuscation [24].
Cross-languageanalysis. Severalresearchershavealsoacknowl-
edged the presence of native code alongside bytecode in their anal-
ysisofAndroidapps.Forinstance,in2016,Alametal.[ 2]presented
DroidNative which can perform Android malware detection con-
sidering both the bytecode and the native code. NDroid[50] and
TaintArt [61] were proposed for dynamic taint analysis to track
sensitive information flowing through JNI. JN-SAF[69] is also pro-
posed as an inter-language static analysis framework to detect
sensitive data leaks in Android apps, taking into account native
code.Alltheaforementionedtools,however,aretask-specific.They
also, typically, perform their analyses separately for bytecode and
nativecode,andlaterpost-processandmergetheoutputstopresent
unifiedanalysisresults.Incontrast,JuCifyproposestounifythe
representation before task-specific analyses. This enables other
analysestobebuiltupontheoutputof JuCify.Forexperimental
assessment of JuCify representation for data flow analysis (RQ-
5),weenvisionedacomparisonwithJN-SAF.Unfortunately,two
co-authors independently failed to run the tool.
Overall,therearevariousapproachesandstudies[ 1,31,53,60]in
the literature that investigate the possibility to analyze apps by ac-
countforthedifferentlanguage-specificartifactsinthepackage.Al-
though the approaches described are promising for cross-language
analysis, they do not generally offer a practical framework to unify
1241the representation of both the bytecode and the native code into a
single model that standard static analysis pipelines can leverage.
Our prototype JuCify does bring such a unified model and targets
theJimpleintermediaterepresentation,whichisthedefaultinter-
nal representation of Soot. Therefore, by pushing in this research
direction,weexpecttoprovidethecommunitywithareadilyusable
framework,whichwillallowto(re)performtheiranalysesonwhole
code in Android apps.
8 CONCLUSION
Wecontributeintheambitiousresearchagendaofunifyingbyte-
codeandnativecodetosupportcomprehensivestaticanalysisof
Androidapps.WepresentedJuCify,asasignificantsteptowards
thisunification:itgeneratesanativecall-graphthatismergedwith
thebytecodecall-graphbasedonlinksretrievedviasymbolicex-
ecution.Inthismodel(i.e.,theunifiedcall-graph),weareableto
heuristicallypopulatespecificnativefunctionswithJimplestate-
ments.TheJimpleintermediaterepresentationwasselectedtoread-
ily support existing static analysers based on the Soot framework.
We first empirically showed that JuCify significantly improves
Android apps call-graphs, which are augmented (to include native
code nodes) and enhanced (to reveal pre viously unreachable meth-
ods). Then, we showed that JuCify holds its promise in supporting
state-of-the-artanalyzerssuchasFlowDroidinenhancingtheir
tainttrackinganalysis.Finally,wediscusshowJuCifycanreveal
sensitive data leaks that pass through the native code in real-world
Android apps, which were previously undetectable.
9 DATA AVAILABILITY
For the sake of Open Science, we provide to the community all
the artifacts used in our study. In particular, we make available the
datasets used for our experimentations, the source code of JuCify,
the JuCify executable, and our benchmark apps. All artifacts (code,
benchmarks, results) are available at:
https://github.com/JordanSamhi/JuCify
10 ACKNOWLEDGMENT
Thisworkwaspartlysupported(1)bytheLuxembourgNational
Research Fund (FNR), under projects Reprocess C21/IS/16344458
the AFR grant 14596679, (2) by the SPARTA project, which has
receivedfundingfromtheEuropeanUnionâ€™sHorizon2020research
and innovation program under grant agreement No 830892, (3)
by the NATURAL project, which has received funding from the
EuropeanResearchCouncilundertheEuropeanUnionâ€™sHorizon
2020 research and innovation programme (grant N Â°949014), and
(4) by the INTER Mobility project Sleepless@Seattle No 13999722.
REFERENCES
[1]Vitor Afonso, Antonio Bianchi, Yanick Fratantonio, Adam DoupÃ©, Mario Polino,
Paulo deGeus, Christopher Kruegel,and Giovanni Vigna. 2016. Going native:
Using a large-scale analysis of android apps to create a practical native-code
sandboxingpolicy.In TheNetworkandDistributedSystemSecuritySymposium .
1â€“15.
[2]Shahid Alam, Zhengyang Qu, Ryan Riley, Yan Chen, and Vaibhav Rastogi.
2017. DroidNative: Automating and optimizing detection of Android native
code malware variants. Computers & Security 65 (2017), 230 â€“ 246. https:
//doi.org/10.1016/j.cose.2016.11.011
[3]Kevin Allix, TegawendÃ© F. BissyandÃ©, Jacques Klein, and Yves Le Traon. 2016.
AndroZoo: Collecting Millions of Android Apps for the Research Community. InProceedingsofthe13thInternationalConferenceonMiningSoftwareRepositories
(Austin, Texas) (MSR â€™16) .ACM,New York,NY, USA,468â€“471. https://doi.org/
10.1145/2901739.2903508
[4] Androguard. [n.d.]. https://androguard.readthedocs.io. Accessed April 2021.
[5]Steven Arzt, Siegfried Rasthofer, Christian Fritz, Eric Bodden, Alexandre Bar-
tel,JacquesKlein,YvesLeTraon,DamienOcteau,andPatrickMcDaniel.2014.
FlowDroid:PreciseContext,Flow,Field,Object-SensitiveandLifecycle-Aware
Taint Analysis for Android Apps. SIGPLAN Not. 49, 6 (June 2014), 259â€“269.
https://doi.org/10.1145/2666356.2594299
[6]UlrichBayer,AndreasMoser,ChristopherKruegel,andEnginKirda.2006. Dy-
namic analysis of malicious code. Journal in Computer Virology 2, 1 (2006),
67â€“77.
[7]J. Bergeron, M. Debbabi, M. M. Erhioui, and B. Ktari. 1999. Static analysis of
binary code to isolate malicious behaviors. In Proceedings. IEEE 8th International
WorkshopsonEnablingTechnologies:InfrastructureforCollaborativeEnterprises
(WET ICEâ€™99) . 184â€“189. https://doi.org/10.1109/ENABL.1999.805197
[8]Young-Hyun Choi, Min-Woo Park, Jung-Ho Eom, and Tai-Myoung Chung. 2015.
Dynamic binary analyzer for scanning vulnerabilities with taint analysis. Multi-
media Tools and Applications 74, 7 (2015), 2301â€“2320.
[9]C. Cifuentes and A. Fraboulet. 1997. Intraprocedural static slicing of binary
executables.In 1997ProceedingsInternationalConferenceonSoftwareMaintenance .
188â€“195. https://doi.org/10.1109/ICSM.1997.624245
[10]LuisCruz,RuiAbreu,JohnGrundy,LiLi,andXinXia.2019. DoEnergy-oriented
ChangesHinderMaintainability?.In The35thIEEEInternationalConferenceon
Software Maintenance and Evolution (ICSME 2019) .
[11]Anusha Damodaran, Fabio Di Troia, Corrado Aaron Visaggio, Thomas H Austin,
and Mark Stamp. 2017. A comparison of static, dynamic, and hybrid analysis for
malwaredetection. JournalofComputerVirologyandHackingTechniques 13,1
(2017), 1â€“12.
[12]JosselinFeist,LaurentMounier,andMarie-LaurePotet.2014. Staticallydetect-
ing use after free on binary code. Journal of Computer Virology and Hacking
Techniques 10, 3 (2014), 211â€“217.
[13]H.Fereidooni,M.Conti,D.Yao,andA.Sperduti.2016. ANASTASIA:ANdroid
mAlware detection using STatic analySIs of Applications. In 2016 8th IFIP In-
ternationalConferenceonNewTechnologies,MobilityandSecurity(NTMS) .1â€“5.
https://doi.org/10.1109/NTMS.2016.7792435
[14]Ira R Forman, Nate Forman, and John Vlissides Ibm. 2004. Java reflection in
action. (2004).
[15]George Fourtounis, Leonidas Triantafyllou, and Yannis Smaragdakis. 2020. Iden-
tifying Java Calls in Native Code via Binary Scanning. In Proceedings of the 29th
ACM SIGSOFT International Symposium on Software Testing and Analysis (Virtual
Event, USA) (ISSTA 2020) . Association for Computing Machinery, New York, NY,
USA, 388â€“400. https://doi.org/10.1145/3395363.3397368
[16]Y.Fratantonio,A.Bianchi,W.Robertson,E.Kirda,C.Kruegel,andG.Vigna.2016.
TriggerScope: Towards Detecting Logic Bombs in Android Applications. In 2016
IEEE Symposium on Security and Privacy (SP) . 377â€“396. https://doi.org/10.1109/
SP.2016.30
[17]YanickFratantonio,AntonioBianchi,WilliamRobertson,EnginKirda,Christo-
pher Kruegel, and Giovanni Vigna. 2016. Triggerscope: Towards detecting logic
bombsin androidapplications. In 2016IEEE symposiumonsecurity andprivacy
(SP). IEEE, 377â€“396.
[18]JNIFunctions.[n.d.]. https://docs.oracle.com/javase/7/docs/technotes/guides/jni/
spec/functions.html. Accessed April 2021.
[19]MichaelFurrandJeffreyS.Foster.2005.CheckingTypeSafetyofForeignFunction
Calls. In Proceedings of the 2005 ACM SIGPLAN Conference on Programming
Language Design and Implementation (Chicago, IL, USA) (PLDI â€™05) . Association
for Computing Machinery, New York, NY, USA, 62â€“72. https://doi.org/10.1145/
1065010.1065019
[20]Michael Grace, Yajin Zhou, Qiang Zhang, Shihong Zou, and Xuxian Jiang. 2012.
Riskranker:scalableandaccuratezero-dayandroidmalwaredetection.In Pro-
ceedingsofthe10th internationalconferenceonMobilesystems,applications,and
services. 281â€“294.
[21]Laune C. Harris and Barton P. Miller. 2005. Practical Analysis of Stripped Binary
Code.SIGARCH Comput. Archit. News 33, 5 (Dec. 2005), 63â€“68. https://doi.org/
10.1145/1127577.1127590
[22]Y.Hu,Y.Zhang,J.Li,H.Wang,B.Li,andD.Gu.2018. BinMatch:ASemantics-
BasedHybridApproachonBinaryCodeCloneAnalysis.In 2018IEEEInternational
Conference on Software Maintenance and Evolution (ICSME) . 104â€“114. https:
//doi.org/10.1109/ICSME.2018.00019
[23]JNI.[n.d.]. https://docs.oracle.com/javase/8/docs/technotes/guides/jni/. Accessed
April 2021.
[24]Zeliang Kan, Haoyu Wang, Lei Wu, Yao Guo, and Daniel Xiapu Luo. 2019.
Automated deobfuscation of Android native binary code. arXiv preprint
arXiv:1907.06828 (2019).
[25]HyunjaeKang,JaewookJang,AzizMohaisen,andHuyKangKim.2015.Detecting
andClassifyingAndroidMalwareUsingStaticAnalysisalongwithCreatorInfor-
mation.International Journal of Distributed Sensor Networks 11, 6 (2015), 479174.
https://doi.org/10.1155/2015/479174 arXiv:https://doi.org/10.1155/2015/479174
1242[26]Joris Kinable and Orestis Kostakis. 2011. Malware classification based on call
graph clustering. Journal in computer virology 7, 4 (2011), 233â€“245.
[27]PingfanKong,LiLi,JunGao,TegawendÃ©FBissyandÃ©,andJacquesKlein.2019.
Mining Android crash fixes in the absence of issue-and change-tracking systems.
InProceedings of the 28th ACM SIGSOFT International Symposium on Software
Testing and Analysis . 78â€“89.
[28]PingfanKong,LiLi,JunGao,KuiLiu,TegawendÃ©FBissyandÃ©,andJacquesKlein.
2018. Automatedtestingofandroidapps:Asystematicliteraturereview. IEEE
Transactions on Reliability 68, 1 (2018), 45â€“66.
[29]J.KÅ™oustekandP.Matula.2018. RetDec:AnOpen-SourceMachine-CodeDecom-
piler. [talk]. Presented at Pass the SALT 2018, Lille, FR.
[30]C. Lattner and V. Adve. 2004. LLVM: a compilation framework for lifelong
programanalysistransformation.In InternationalSymposiumonCodeGeneration
and Optimization, 2004. CGO 2004. 75â€“86. https://doi.org/10.1109/CGO.2004.
1281665
[31]S. Lee, H. Lee, and S. Ryu. 2020. Broadening Horizons of Multilingual Static
Analysis:SemanticSummaryExtractionfromCCodeforJNIProgramAnalysis.In
2020 35th IEEE/ACM International Conference on Automated Software Engineering
(ASE). 127â€“137.
[32]YoungJunLee,Sang-HoonChoi,ChulwooKim,Seung-HoLim,andKi-Woong
Park.2017. Learningbinarycodewithdeeplearningtodetectsoftwareweakness.
InKSII The 9th International Conference on Internet (ICONI) 2017 Symposium .
[33]LiLi,KevinAllix,DaoyuanLi,AlexandreBartel,TegawendÃ©FBissyandÃ©,and
Jacques Klein. 2015. Potential Component Leaks in Android Apps: An Investiga-
tionintoanewFeatureSetforMalwareDetection.In The2015IEEEInternational
Conference on Software Quality, Reliability & Security (QRS) .
[34]LiLi,AlexandreBartel,TegawendÃ©FBissyandÃ©,JacquesKlein,YvesLeTraon,
StevenArzt,SiegfriedRasthofer,EricBodden,DamienOcteau,andPatrickMc-
Daniel. 2015. Iccta: Detecting inter-component privacy leaks in android apps. In
2015IEEE/ACM37thIEEEInternationalConferenceonSoftwareEngineering ,Vol.1.
IEEE, 280â€“291.
[35]Li Li, TegawendÃ© F BissyandÃ©, Damien Octeau, and Jacques Klein. 2016. Droidra:
Taming reflection to support whole-program analysis of android apps. In Pro-
ceedings of the 25th International Symposium on Software Testing and Analysis .
318â€“329.
[36]LiLi, TegawendÃ©F.BissyandÃ©,MikePapadakis, SiegfriedRasthofer, Alexandre
Bartel,DamienOcteau,JacquesKlein,andYvesLeTraon.2017. Staticanalysisof
androidapps:Asystematicliteraturereview. InformationandSoftwareTechnology
88 (2017), 67 â€“ 95. https://doi.org/10.1016/j.infsof.2017.04.001
[37]Lixin Li and Chao Wang. 2013. Dynamic analysis and debugging of binary code
for security applications. In International Conference on Runtime Verification .
Springer, 403â€“423.
[38]Martina Lindorfer, Matthias Neugschwandtner, Lukas Weichselbaum, Yanick
Fratantonio,VictorVanDerVeen,andChristianPlatzer.2014.Andrubisâ€“1,000,000
apps later: A view on current Android malware behaviors. In 2014 third interna-
tional workshop on building analysis datasets and gathering experience returns for
security (BADGERS) . IEEE, 3â€“17.
[39]Alwin Maier, Hugo Gascon, Christian Wressnegger, and Konrad Rieck. 2019.
TypeMiner: Recovering types in binary programs using machine learning. In
InternationalConferenceonDetectionofIntrusionsandMalware,andVulnerability
Assessment . Springer, 288â€“308.
[40]Pallavi Maiya, Aditya Kanade, and Rupak Majumdar. 2014. Race detection for
Android applications. ACM SIGPLAN Notices 49, 6 (2014), 316â€“325.
[41]H. B. Mann and D. R. Whitney. 1947. On a Test of Whether one of Two Random
Variables is Stochastically Larger than the Other. Ann. Math. Statist. 18, 1 (03
1947), 50â€“60. https://doi.org/10.1214/aoms/1177730491
[42]KeMao,MarkHarman,andYueJia.2016.Sapienz:Multi-objectiveautomatedtest-
ing for Android applications. In Proceedings of the 25th International Symposium
on Software Testing and Analysis . 94â€“105.
[43]XiaozhuMengandBartonP.Miller.2016. BinaryCodeisNotEasy.In Proceedings
ofthe25thInternationalSymposiumonSoftwareTestingandAnalysis (SaarbrÃ¼cken,
Germany) (ISSTA2016) .AssociationforComputingMachinery,NewYork,NY,
USA, 24â€“35. https://doi.org/10.1145/2931037.2931047
[44]Gail C. Murphy, David Notkin, William G. Griswold, and Erica S. Lan. 1998. An
EmpiricalStudyofStaticCallGraphExtractors. ACMTrans.Softw.Eng.Methodol.
7, 2 (April 1998), 158â€“191. https://doi.org/10.1145/279310.279314
[45]DOOP Github page. [n.d.]. https://bitbucket.org/yanniss/doop/src/master/. Ac-
cessed April 2021.
[46]Native Scanner Github page. [n.d.]. https://github.com/plast-lab/native-scanner.
Accessed April 2021.
[47]Dorottya Papp, Levente ButtyÃ¡n, and Zhendong Ma. 2017. Towards semi-
automateddetectionoftrigger-basedbehaviorforsoftwaresecurityassurance.
InProceedings of the 12th International Conference on Availability, Reliability and
Security. 1â€“6.
[48]N.PeiravianandX.Zhu.2013. MachineLearningforAndroidMalwareDetection
Using Permission and API Calls. In 2013 IEEE 25th International Conference on
Tools with Artificial Intelligence . 300â€“305. https://doi.org/10.1109/ICTAI.2013.53[49]ThanasisPetsas,GiannisVoyatzis,EliasAthanasopoulos,MichalisPolychronakis,
andSotirisIoannidis.2014. Rageagainstthevirtualmachine:hinderingdynamic
analysis of android malware. In Proceedings of the Seventh European Workshop on
System Security . 1â€“6.
[50]C.Qian,X.Luo,Y.Shao,andA.T.S.Chan.2014. OnTrackingInformationFlows
through JNI in Android Applications. In 2014 44th Annual IEEE/IFIP International
Conference on Dependable Systems and Networks . 180â€“191. https://doi.org/10.
1109/DSN.2014.30
[51] Radare2. [n.d.]. https://github.com/radareorg/radare2. Accessed April 2021.
[52]Siegfried Rasthofer, Steven Arzt, Marc Miltenberger, and Eric Bodden. 2016.
Harvesting Runtime Values in Android Applications That Feature Anti-Analysis
Techniques.. In NDSS.
[53]Claudio Rizzo. 2020. Static Flow Analysis for Hybrid and Native Android Applica-
tions. Ph.D. Dissertation. Royal Holloway â€“ University of London.
[54]Kevin A Roundy and Barton P Miller. 2010. Hybrid analysis and control of
malware. In International Workshop on Recent Advances in Intrusion Detection .
Springer, 317â€“338.
[55]J.SahsandL.Khan.2012. AMachineLearningApproachtoAndroidMalware
Detection.In 2012EuropeanIntelligenceandSecurityInformaticsConference .141â€“
147. https://doi.org/10.1109/EISIC.2012.34
[56]J.Samhi,A.Bartel,T.F.Bissyande,andJ.Klein.2021. RAICC:RevealingAtypical
Inter-Component Communication in Android Apps. In 2021 IEEE/ACM 43rd
International Conference on Software Engineering (ICSE) . IEEE Computer Society,
Los Alamitos, CA, USA, 1398â€“1409. https://doi.org/10.1109/ICSE43902.2021.
00126
[57]YanShoshitaishvili,RuoyuWang,ChristopherSalls,NickStephens,MarioPolino,
AudreyDutcher,JohnGrosen,SijiFeng,ChristopheHauser,ChristopherKruegel,
and Giovanni Vigna. 2016. SoK: (State of) The Art of War: Offensive Techniques
in Binary Analysis. In IEEE Symposium on Security and Privacy .
[58]Skylot.[n.d.]. JadX:DextoJavadecompiler,https://github.com/skylot/jadx .A c -
cessed August 2021.
[59]Ting Su, Guozhu Meng, Yuting Chen, Ke Wu, Weiming Yang, Yao Yao, Geguang
Pu,YangLiu,andZhendongSu.2017. Guided,stochasticmodel-basedGUItesting
ofAndroidapps.In Proceedingsofthe201711thJointMeetingonFoundationsof
Software Engineering . 245â€“256.
[60]MengtaoSunandGangTan.2014. NativeGuard:ProtectingAndroidApplications
from Third-Party Native Libraries. In Proceedings of the 2014 ACM Conference on
Security and Privacy in Wireless & Mobile Networks (Oxford, United Kingdom)
(WiSecâ€™14) .AssociationforComputingMachinery,NewYork,NY,USA,165â€“176.
https://doi.org/10.1145/2627393.2627396
[61]MingshenSun,TaoWei,andJohnC.S.Lui.2016. TaintART:APracticalMulti-
LevelInformation-FlowTrackingSystemforAndroidRunTime.In Proceedings
ofthe2016ACMSIGSACConferenceonComputerandCommunicationsSecurity
(Vienna,Austria) (CCSâ€™16).AssociationforComputingMachinery,NewYork,
NY, USA, 331â€“342. https://doi.org/10.1145/2976749.2978343
[62]Kimberly Tam, Salahuddin J Khan, Aristide Fattori, and Lorenzo Cavallaro. 2015.
Copperdroid: Automatic reconstruction of android malware behaviors.. In Ndss.
[63]ShinHweiTan,ZhenDong,XiangGao,andAbhikRoychoudhury.2018.Repairing
crashes in android apps. In 2018 IEEE/ACM 40th International Conference on
Software Engineering (ICSE) . IEEE, 187â€“198.
[64]Oguzhan Topgul. [n.d.]. Android Malware Evasion Techniques - Emulator De-
tection. https://www.oguzhantopgul.com/2014/12/android-malware-evasion-
techniques.html Accessed December 2020.
[65]VirusTotal.2021. Virustotalfreeonlinevirus,malwareandurlscanner . https:
//www.virustotal.com/en
[66]RajaVallÃ©e-Rai,PhongCo,EtienneGagnon,LaurieHendren,PatrickLam,and
Vijay Sundaresan. 2010. Soot: A Java Bytecode Optimization Framework. In
CASCON First Decade High Impact Papers (Toronto, Ontario, Canada) (CASCON
â€™10). IBM Corp., USA, 214â€“224. https://doi.org/10.1145/1925805.1925818
[67]RajaVallee-RaiandLaurieJHendren.1998. Jimple:SimplifyingJavabytecode
for analyses and transformations. (1998).
[68]S. Wang, P. Wang, and D. Wu. 2017. Semantics-Aware Machine Learning for
FunctionRecognitioninBinaryCode.In 2017IEEEInternationalConferenceon
SoftwareMaintenanceandEvolution(ICSME) .388â€“398. https://doi.org/10.1109/
ICSME.2017.59
[69]Fengguo Wei, Xingwei Lin, Xinming Ou, Ting Chen, and Xiaosong Zhang. 2018.
JN-SAF: Precise and Efficient NDK/JNI-Aware Inter-Language Static Analysis
FrameworkforSecurityVettingofAndroidApplicationswithNativeCode.In
Proceedingsofthe2018ACMSIGSACConferenceonComputerandCommunications
Security(Toronto,Canada) (CCSâ€™18).AssociationforComputingMachinery,New
York, NY, USA, 1137â€“1150. https://doi.org/10.1145/3243734.3243835
[70]Fengguo Wei, Sankardas Roy, Xinming Ou, and Robby. 2014. Amandroid: A
Precise and General Inter-Component Data Flow Analysis Framework for Se-
curity Vetting of Android Apps. In Proceedings of the 2014 ACM SIGSAC Con-
ference on Computer and Communications Security (Scottsdale, Arizona, USA)
(CCSâ€™14).AssociationforComputingMachinery,NewYork,NY,USA,1329â€“1341.
https://doi.org/10.1145/2660267.2660357
1243[71]M. White, M. Tufano, C. Vendome, and D. Poshyvanyk. 2016. Deep learning
code fragments for code clone detection. In 2016 31st IEEE/ACM International
Conference on Automated Software Engineering (ASE) . 87â€“98.
[72]Dong-JieWu,Ching-HaoMao,Te-EnWei,Hahn-MingLee,andKuo-PingWu.
2012. Droidmat: Android malware detection through manifest and api calls
tracing. In 2012 Seventh Asia Joint Conference on Information Security . IEEE,
62â€“69.
[73]Haowei Wu, Shengqian Yang, and Atanas Rountev. 2016. Static detection of
energydefectpatternsinAndroidapplications.In Proceedingsofthe25thInter-
national Conference on Compiler Construction . 185â€“195.
[74]XAMARIN. [n.d.]. https://dotnet.microsoft.com/apps/xamarin. Accessed April
2021.
[75]YinxingXue,GuozhuMeng,YangLiu,TianHuatTan,HongxuChen,JunSun,
and Jie Zhang. 2017. Auditing anti-malware tools by evolving android malware
and dynamic loading technique. IEEE Transactions on Information Forensics and
Security12, 7 (2017), 1529â€“1544.
[76]Z. Yang and M. Yang. 2012. LeakMiner: Detect Information Leakage on Android
with Static Taint Analysis. In 2012 Third World Congress on Software Engineering .
101â€“104. https://doi.org/10.1109/WCSE.2012.26
[77]HailongZhang,HaoweiWu,andAtanasRountev.2016. Automatedtestgener-
ation for detection of leaks in Android applications. In Proceedings of the 11th
International Workshop on Automation of Software Test . 64â€“70.
[78]QingchuanZhao,ChaoshunZuo,BrendanDolan-Gavitt,GiancarloPellegrino,
and Zhiqiang Lin. 2020. Automatic Uncovering of Hidden Behaviors From Input
Validation in Mobile Apps. In 2020 IEEE Symposium on Security and Privacy (SP) .
IEEE, 1106â€“1120.
[79]Cong Zheng, Shixiong Zhu, Shuaifu Dai, Guofei Gu, Xiaorui Gong, Xinhui Han,
and Wei Zou. 2012. Smartdroid: an automatic system for revealing ui-based
trigger conditions in android applications. In Proceedings of the second ACM
workshop on Security and privacy in smartphones and mobile devices . 93â€“104.
1244