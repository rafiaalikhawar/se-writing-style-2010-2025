StateMergingwith /Q_uantifiers in Symbolic Execution
DavidTrabish
Tel Aviv University
Tel Aviv, Israel
davivtra@post.tau.ac.ilNoamRinetzky
Tel Aviv University
Tel Aviv, Israel
maon@cs.tau.ac.il
SharonShoham
Tel Aviv University
Tel Aviv, Israel
sharon.shoham@cs.tau.ac.ilVaibhav Sharma
Universityof Minnesota
Minneapolis, USA
vaibhav@umn.edu
ABSTRACT
We address the problem of constraint encoding explosion which
hinders the applicability of state merging in symbolic execution.
Speci/f_ically,ourgoalistoreducethenumberofdisjunctionsand
if-then-else expressions introduced during state merging. The main
ideaistodynamicallypartitionthesymbolicstatesintomerging
groupsaccordingtoasimilaruniformstructuredetectedintheir
path constraints, which allows to eï¬ƒciently encode the merged
pathconstraintandmemoryusingquanti/f_iers.Toaddresstheadded
complexity of solving quanti/f_ied constraints, we propose a special-
izedsolvingprocedurethatreducesthesolvingtimeinmanycases.
Our evaluation shows that our approach can lead to signi/f_icant
performance gains.
CCS CONCEPTS
â€¢Software andits engineering ;
KEYWORDS
Symbolic Execution,StateMerging
ACMReference Format:
David Trabish,Noam Rinetzky, SharonShoham, and VaibhavSharma. 2023.
StateMergingwithQuanti/f_iersinSymbolicExecution.In Proceedingsofthe
31stACMJointEuropeanSoftwareEngineeringConferenceand Symposium
on the Foundations of Software Engineering (ESEC/FSE â€™23), December 3â€“9,
2023, San Francisco, CA, USA. ACM, New York, NY, USA, 13pages.https:
//doi.org/10.1145/3611643.3616287
1 INTRODUCTION
Symbolic execution is a powerful program analysis technique that
hasgainedsigni/f_icantattentionoverthelastyearsinbothacademic
and industrial areas, including software engineering, software test-
ing, programming languages, program veri/f_ication, and cybersecu-
rity. It lies at the core of many applications, such as high-coverage
test generation [ 19,20,42], bug /f_inding [ 19,31], debugging [ 34],
Permissionto make digitalor hard copies of allorpart ofthis work for personalor
classroom use is granted without fee provided that copies are not made or distributed
forpro/f_itorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
onthe/f_irstpage.Copyrights forcomponentsofthisworkownedbyothersthanthe
author(s)mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,or
republish,topostonserversortoredistributetolists,requirespriorspeci/f_icpermission
and/or a fee. Request permissions from permissions@acm.org.
ESEC/FSE â€™23, December 3â€“9, 2023, San Francisco, CA,USA
Â©2023 Copyright heldby the owner/author(s). Publicationrightslicensed to ACM.
ACM ISBN 979-8-4007-0327-0/23/12.
https://doi.org/10.1145/3611643.3616287automaticprogramrepair[ 39,40],crosschecking[ 22,35],andside-
channelanalysis[ 17,18,41].Insymbolicexecution,theprogramis
run with an unconstrained symbolic input, rather than with a con-
crete one. Whenever the execution reaches a branch that depends
on the symbolic input, an SMT solver [ 26] is used to determine the
feasibility of each branch side, and the feasible paths are further
exploredwhileupdatingtheirpathconstraintswiththecorrespond-
ingconstraints.Oncetheexecutionofagivenpathiscompleted,
thesolverprovidesasatisfyingassignmentforthecorresponding
pathconstraints,fromwhich a concrete testcasethatreplaysthat
pathcan be generated.
A key remaining challenge in symbolic execution is path ex-
plosion [21].Statemerging[ 33,37]isawell-knowntechniquefor
mitigatingthisproblem,whichtradesthenumberofexploredpaths
with the complexity of the generated constraints. More speci/f_ically,
merging multiple symbolic states results in a symbolic state where
the pathconstraint is expressed using a disjunction ofconstraints,
and the memory contents are expressed using ite(if-then-else)
expressions.
Unfortunately,theintroductionofdisjunctiveconstraintsand ite
expressionsmakesconstraintsolvingharderandslowsdownthe
exploration, especially when the number of states being merged is
high. Consider, for example, the function memspnfrom Section 1
which is based on the implementationof strspninuClibc[54].1
memspnreceives a buï¬€er s, the size of the buï¬€er n, and a string
chars,andreturnsthesizeoftheinitialsegmentof swhichconsists
entirely of characters in chars. Suppose that memspnis called with
asymbolicbuï¬€er s,asymbolicsize nboundedbysomeconstant /u1D45A,
andtheconstantstring "a". Theexplorationoftheloopatlines 3-8
results in /u1D442(/u1D45A)symbolic states. If we merge these symbolic states,
then the encoding of the merged symbolic state, which records,
among others, the path constraint and the value of variable count,
is of size at least linear in /u1D45A. Now, suppose that the merged return
value ofmemspnis used later, for example, in the parameter sin
anothercallof memspn.Inthatcase,ifweperformasimilarmerging
operation,thentheencodingofthemergedsymbolicstatewillbeof
sizeatleastquadraticin /u1D45Asincethemergedvaluepropagatestothe
path constraints. Such encoding explosion istypically encountered
duringtheanalysisofreal-worldprograms,thusdrasticallylimiting
the eï¬€ectiveness ofstate merging inpractice.
We propose a state mergingapproachthat reduces the encoding
complexityofthepathconstraintsandthememorycontents,while
1strspnreceivesnull-terminated buï¬€ers, slightlycomplicatingthe presentation.
1140
ESEC/FSE â€™23, December3â€“9, 2023,San Francisco, CA, USA David Trabish, Noam Rinetzky, SharonShoham, andVaibhav Sharma
1intmemspn(char*s, size_t n, char*chars) {
2char*p = chars; intcount = 0;
3while(*p && count < n) {
4 if(*p == s[count]) {
5 count++; p = chars;
6 }else
7 p++;
8}
9returncount;
10}
Figure 1:Motivatingexample.
preservingsoundnessandcompletenessw.r.t.standardsymbolic
execution.Atahighlevel,ourapproachtakesasaninputtheexecu-
tiontree[ 36],whichcharacterizesthesymbolicbranchesoccurring
during the symbolic execution of the analyzed code fragment, and
dynamically detects regular patterns in the path constraints of the
symbolic states in the tree, which allows us to partition them into
merging groups of states whose path constraints have a similar
uniformstructure.This enables us to encode the mergedpath con-
straints using quanti/f_ied formulas, which in turn may also simplify
theencodingof iteexpressionsrepresentingthemergedmemory
contents.
We observed that the generic method employed by the SMT
solvertosolvetheresultingquanti/f_iedqueriesoftenleadstosubpar
performance compared to the solving of the quanti/f_ier-free variant
of the queries. To address this, we propose a specialized solving
procedurethatleveragestheparticularstructureofthegenerated
quanti/f_ied queries, and resort to the generic method only if our
approach fails.
WeimplementedourapproachontopofKLEE[ 19]andevalu-
ated it on real-world benchmarks. Our experiments show that our
approachcanhavesigni/f_icantperformancegainscomparedtostate
mergingandstandardsymbolic execution.
2 PRELIMINARIES
StateMerging. Asymbolicstate /u1D460consistsof (i)a pathconstraint
/u1D460./u1D45D/u1D450, (ii) asymbolic store /u1D460.memthat associates variables2/u1D449with
symbolicexpressionsobtainedfromthesymbolicinputs,(iii)and
aninstruction counter /u1D460.ic. Symbolic states are merge-compatible
if they have the same instruction counter and contain the same
variables intheirstores.
De/f_inition 2.1. The merged symbolic state resulting from the
merging of the merge-compatible symbolic states {/u1D460/u1D456}/u1D45B
/u1D456=1is the
symbolic state /u1D460de/f_inedas follows:
/u1D460.icâ‰œ/u1D4601./u1D456/u1D450, /u1D460.pcâ‰œ/logicalortext.1/u1D45B
/u1D456=1/u1D460/u1D456./u1D45D/u1D450,
/u1D460.memâ‰œ/u1D706/u1D463âˆˆ/u1D449.merge_var ({/u1D460/u1D456}/u1D45B
/u1D456=1,/u1D463)
where the mergedvalueofavariable /u1D463isde/f_inedby:
merge_var ({/u1D460/u1D456}/u1D45B
/u1D456=1,/u1D463)â‰œ
ite(/u1D4601./u1D45D/u1D450,/u1D4601.mem(/u1D463),
ite(...,ite(/u1D460/u1D45Bâˆ’1./u1D45D/u1D450,/u1D460/u1D45Bâˆ’1.mem(/u1D463),/u1D460/u1D45B.mem(/u1D463))))
2For simplicity, we do not describe the handling of stack variables and heap-allocated
objects.Ourimplementation supports both.Statemergingisappliedonagivencodefragment,typicallya
loop or a function. Once the symbolic exploration of the code frag-
ment is complete, the resulting symbolic states are partitioned into
(merge-compatible) merging groups. Then, each merging group is
transformedintoasinglemergedsymbolicstate.Finally,theresult-
ing merged symbolic states are added to the state scheduler [ 19] of
the symbolic executionengine to continue the exploration.
Execution Trees. Anexecution tree [36] is a tree where every
node/u1D45Bisassociatedwithasymbolicstate /u1D45B./u1D460andasymboliccondi-
tion/u1D45B./u1D450correspondingtothetakenbranchsuchthattheconditions
associated with any two sibling nodes are mutually inconsistent
and the condition of the root node is true. The execution tree char-
acterizestheanalysisofanarbitrarycodefragment,whichisnot
necessarilythewholeprogram.Therootnodecorrespondstothe
symbolicstatethatreachedtheentrypointofthecodefragment,
and the leaf nodes correspond to the symbolic states that com-
pletedtheanalysisofthecodefragment. Forexample,considerthe
symbolic execution of memspn(Section1) with a symbolic buï¬€er
s,asymbolicsize n,and"a",wherenisboundedby3.Thecorre-
spondingexecutiontreeisdepictedinFigure 2,wherethesymbolic
conditionassociatedwitheachnodeisdepictedontheincoming
edgeofthenode.The node /u1D45B1correspondsto theinitialsymbolic
state (i.e., /u1D45B1./u1D460./u1D45D/u1D450â‰œ/u1D45Bâ‰¤3), the nodes /u1D45B2,/u1D45B6/u1D45B10, and/u1D45B14corre-
spond to paths where siscomprised of only acharacters, and the
nodes/u1D45B5,/u1D45B9,and/u1D45B13correspondtopathswhere scontainsanon- a
character.For now,ignore the colorof the nodes.
Givenanexecutiontree /u1D461withroot /u1D45F,wedenotethesequence
of nodes on the path from node /u1D45B1to node/u1D45B/u1D458in/u1D461by/u1D70B/u1D461(/u1D45B1,/u1D45B/u1D458)
andwrite /u1D70B/u1D461(/u1D45B/u1D458)when/u1D45B1istheroot /u1D45F.Givenapath /u1D70B/u1D461(/u1D45B1,/u1D45B/u1D458)=
[/u1D45B1,/u1D45B2,...,/u1D45B/u1D458]in/u1D461, we de/f_ine its tree path condition (tpc) andtree
path condition tail (tpc):
tpc/u1D461(/u1D45B1,/u1D45B/u1D458)â‰œ/u1D45B1./u1D450âˆ§tpc/u1D461(/u1D45B1,/u1D45B/u1D458)tpc/u1D461(/u1D45B1,/u1D45B/u1D458)â‰œ/logicalanddisplay.1
1</u1D456â‰¤/u1D458/u1D45B/u1D456./u1D450
We write tpc/u1D461(/u1D45B)â‰œtpc/u1D461(/u1D45F,/u1D45B)andtpc/u1D461(/u1D45B)â‰œtpc/u1D461(/u1D45F,/u1D45B)as short-
hands. We omit the tree subscript when it is clear from the context.
For example,inthe executiontree depictedinFigure 2:
/u1D70B(/u1D45B3,/u1D45B7)â‰œ[/u1D45B3,/u1D45B4,/u1D45B7]
tpc(/u1D45B3,/u1D45B7)â‰œ/u1D45B>0âˆ§/u1D460[0]=97âˆ§/u1D45B>1
tpc(/u1D45B3,/u1D45B7)â‰œ/u1D460[0]=97âˆ§/u1D45B>1
An execution tree /u1D461with root /u1D45Fisvalidif/u1D45B./u1D460./u1D45D/u1D450=/u1D45F./u1D460.pcâˆ§
tpc(/u1D45B)foreverynode /u1D45B.Notethat /u1D45F./u1D460isnotnecessarilytheinitial
symbolic state of the whole program, so tpc(/u1D45B)is a suï¬ƒx of the
pathconstraints. From nowon,we assumethat alltrees are valid.
LogicalNotations. Weencodesymbolicpathconstraintsand
memory contents in /f_irst-order logic modulo theories using formu-
lasandterms,respectively.Atermiseitheraconstant,avariable,or
anapplicationofafunctiontoterms.Aformulaiseitheranapplica-
tionofapredicatesymboltotermsorobtainedbyapplyingboolean
connectivesorquanti/f_ierstoformulas.Let /u1D711,/u1D711â€²beformulasand
/u1D45Aa model. We write /u1D711â‰¡/u1D711â€²to note that /u1D711and/u1D711â€²are semantically
equivalentand /u1D711/doteq/u1D711â€²tonotethattheyaresyntacticallyequal.We
write/u1D45A|=/u1D711tonotethat /u1D45Aisamodelof /u1D711.Foraterm /u1D461,wedenote
by/u1D45A(/u1D461)thevalueassignedby /u1D45Ato/u1D461,andwewrite /u1D4611â‰¡/u1D4612todenote
that/u1D45A(/u1D4611)=/u1D45A(/u1D4612)in any model /u1D45A. We use the standard theory of
arrays [51]andwrite /u1D44E[/u1D452]as ashorthand for select(/u1D44E,/u1D452).
1141StateMerging with/Q_uantifiersin SymbolicExecution ESEC/FSE â€™23, December3â€“9, 2023,San Francisco, CA, USA
Â¬ğ’ > ğŸğ’ğŸ
ğ’ > ğŸ
ğ’”ğŸ = ğŸ—ğŸ• Â¬ğ’”ğŸ = ğŸ—ğŸ•ğ’ğŸ ğ’ğŸ‘
ğ’ğŸ’ ğ’ğŸ“
ğ’ğŸ” ğ’ğŸ•Â¬ğ’ > ğŸ ğ’ > ğŸ
ğ’ğŸ– ğ’ğŸ—
ğ’ğŸğŸ ğ’ğŸğŸ
ğ’ğŸğŸ ğ’ğŸğŸ‘ğ’”ğŸ = ğŸ—ğŸ• Â¬ ğ’”ğŸ = ğŸ—ğŸ•
ğ’”ğŸ = ğŸ—ğŸ• Â¬ ğ’”ğŸ = ğŸ—ğŸ•Â¬ğ’ > ğŸ ğ’ > ğŸ
ğ’ğŸğŸ’Â¬ğ’ > ğŸ‘
Figure2:TheexecutiontreeoftheloopfromSection 1when
charsisset to"a".(Recallthat theASCII codeof ais97.)
3 STATEMERGINGWITH QUANTIFIERS
In this section, we describe our approach for state merging with
quanti/f_iers. We start with a motivating example and subsequently
formalize our approach.
MotivatingExample. Considerthesymbolicstates associated
withthe nodes /u1D45B5,/u1D45B9, and/u1D45B13from theexecution treein Figure 2,
whosetreepathconditions,i.e.,, tpc(/u1D45B5),tpc(/u1D45B9),andtpc(/u1D45B13),are:
/u1D45B>0âˆ§Â¬/u1D460[0]=97
/u1D45B>0âˆ§/u1D460[0]=97âˆ§/u1D45B>1âˆ§Â¬/u1D460[1]=97
/u1D45B>0âˆ§/u1D460[0]=97âˆ§/u1D45B>1âˆ§/u1D460[1]=97âˆ§/u1D45B>2âˆ§Â¬/u1D460[2]=97
Thepathconstraintoftheinitialsymbolicstate( /u1D45B1./u1D460)is/u1D45Bâ‰¤3,so
applyingstandardstatemerging(De/f_inition 2.1)onthesymbolic
statesofthenodesabovewillresultinasymbolicstatewhosepath
constraintisequivalentto:
/u1D45Bâ‰¤3âˆ§ (tpc(/u1D45B5) âˆ¨tpc(/u1D45B9) âˆ¨tpc(/u1D45B13))
Note,however,thateachofthedisjunctsabovehasthefollowing
uniform structure: It uses /u1D458formulas (for /u1D458=0,1,2) of the form
/u1D45B>_âˆ§/u1D460[_]=97to encode that the size of the buï¬€er ( /u1D45B) is big
enoughtocontain /u1D458consecutiveoccurrencesof acharacters,and
another formula /u1D45B>/u1D458âˆ§Â¬/u1D460[/u1D458]=97. This uniformity is exposed
whenrewritingeachdisjunctusinguniversalquanti/f_iersasfollows:
/parenleftbigâˆ€/u1D456.1â‰¤/u1D456â‰¤0â†’/u1D45B>/u1D456âˆ’1âˆ§/u1D460[/u1D456âˆ’1]=97/parenrightbigâˆ§/u1D45B>0âˆ§Â¬/u1D460[0]=97/parenleftbigâˆ€/u1D456.1â‰¤/u1D456â‰¤1â†’/u1D45B>/u1D456âˆ’1âˆ§/u1D460[/u1D456âˆ’1]=97/parenrightbigâˆ§/u1D45B>1âˆ§Â¬/u1D460[1]=97/parenleftbigâˆ€/u1D456.1â‰¤/u1D456â‰¤2â†’/u1D45B>/u1D456âˆ’1âˆ§/u1D460[/u1D456âˆ’1]=97/parenrightbigâˆ§/u1D45B>2âˆ§Â¬/u1D460[2]=97To exploit the common structure of the rewritten disjuncts, we
canintroduceanauxiliaryvariable( /u1D458)andobtainan equisatis/f_iable
mergedpathconstraint3:
/u1D45Bâ‰¤3âˆ§ (/u1D458=0âˆ¨/u1D458=1âˆ¨/u1D458=2) âˆ§/parenleftbigâˆ€/u1D456.1â‰¤/u1D456â‰¤/u1D458â†’/u1D45B>/u1D456âˆ’1âˆ§/u1D460[/u1D456âˆ’1]=97/parenrightbigâˆ§
(/u1D45B>/u1D458âˆ§Â¬/u1D460[/u1D458]=97)
Theauxiliaryvariableallowsustoachievesimilarsavingsinthe
encodingofthemergedmemorycontents.Consider,forexample,
thevariable count. Its value inthesymbolic states corresponding
to/u1D45B5,/u1D45B9, and/u1D45B13is0,1, and2, respectively, so its merged value
withstandardstate merging is:
ite(tpc(/u1D45B5),0,ite(tpc(/u1D45B9),1,2))
Note, however, that with the rewritten merged path constraint, the
path constraints of the symbolic states corresponding to /u1D45B5,/u1D45B9,
and/u1D45B13are now correlated with the values of /u1D458:0,1, and2. As the
valuesof countcanbeencodedasafunctionofthosevalues,we
can simply rewritethe complex iteexpressionabove to /u1D458.
OurApproach. Ourgoalistoreducethenumberofdisjunctions
anditeexpressions introduced in standard state merging. Given
a set of merge-compatible symbolic states, our state merging ap-
proach works as follows. First, we compute partitions of symbolic
statesbased onthesimilarity ofthe pathconstraints (Section 3.1).
Then, for each partition,we attemptto synthesize the merged sym-
bolic state using universal quanti/f_iers (Sections 3.2and3.3), and
resortto standardstate merging if that fails.
3.1 PartitioningMerging Groups viaRegular
Patterns
Toidentifysimilaritybetweensymbolicstates,weusetheexecution
tree of the analyzed code fragment. Recall that the symbolic states
ineachmerginggroupareassociatedwithleafnodesandrespective
paths in the execution tree. We abstract each path to a sequence
ofnumbersusingaspecialized hashfunction ,whichallowsusto
detectsimilaritybetween pathsbasedonasharedregularpattern.
De/f_inition 3.1. Ahash function /uni210Emaps constraints (formulas) to
numbers (N). We say that /uni210Eisvalidfor an execution tree /u1D461if for
any twosibling nodes /u1D45B1and/u1D45B2:
/uni210E(/u1D45B1./u1D450)â‰ /uni210E(/u1D45B2./u1D450)
In the sequel, we assume a /f_ixed arbitrary valid execution tree /u1D461
and a /f_ixed arbitrary valid hash function /uni210Efor/u1D461.4We now extend /uni210E
to pathsas follows:
De/f_inition3.2. Thehashofapath /u1D70B(/u1D45B1,/u1D45B/u1D458)=[/u1D45B1,...,/u1D45B/u1D458]in/u1D461is
de/f_inedas follows:
/uni210E(/u1D70B(/u1D45B1,/u1D45B/u1D458))â‰œ/uni210E(/u1D45B1./u1D450)/uni210E(/u1D45B2./u1D450).../uni210E(/u1D45B/u1D458./u1D450) âˆˆNâˆ—
Notethatthevalidityof /uni210Eensuresthateverypathin /u1D461isidenti/f_ied
uniquely byits hash value.
De/f_inition 3.3. Aregular pattern is a tuple (/u1D7141,/u1D7142,/u1D7143), where
/u1D7141,/u1D7142,/u1D7143âˆˆNâˆ—arewords(sequences)ofnumbers.Givenleafnodes
{/u1D45B/u1D457}/u1D45B
/u1D457=1in/u1D461,andnumbers {/u1D458/u1D457}/u1D45B
/u1D457=1âŠ†N,wesaythat {(/u1D45B/u1D457,/u1D458/u1D457)}/u1D45B
/u1D457=1
3Notethat (/u1D458=0âˆ¨/u1D458=1âˆ¨/u1D458=2)canberewrittenas 0â‰¤/u1D458â‰¤2.
4In practice, we use a hash function that distinguishes between a condition and its
negation, eï¬€ectively ensuring validity for any execution tree.
1142ESEC/FSE â€™23, December3â€“9, 2023,San Francisco, CA, USA David Trabish, Noam Rinetzky, SharonShoham, andVaibhav Sharma
Table 1:Aregular partitioningoftheleaf nodes oftheexecution tree inFigure 2,and the resultingmerged states.
RegularPattern RegularPartition Pattern-Based Merged States
(W,GB,GY) { /u1D45B5,/u1D45B9,/u1D45B13} formulapattern :(true,/u1D45B>/u1D465âˆ’1âˆ§/u1D460[/u1D465âˆ’1]=97,/u1D45B>/u1D465âˆ§Â¬/u1D460[/u1D465]=97)
pc:/u1D45Bâ‰¤3âˆ§0â‰¤/u1D458â‰¤2âˆ§ (âˆ€/u1D456.1â‰¤/u1D456â‰¤/u1D458â†’/u1D45B>/u1D456âˆ’1âˆ§/u1D460[/u1D456âˆ’1]=97) âˆ§ (/u1D45B>/u1D458âˆ§Â¬/u1D460[/u1D458]=97)
mem:[countâ†¦â†’/u1D458,pâ†¦â†’chars+1,sâ†¦â†’s,nâ†¦â†’n,charsâ†¦â†’chars]
(W,GB,R) { /u1D45B2,/u1D45B6,/u1D45B10,/u1D45B14}formulapattern :(true,/u1D45B>/u1D465âˆ’1âˆ§/u1D460[/u1D465âˆ’1]=97,/u1D45Bâ‰¤/u1D465)
pc:/u1D45Bâ‰¤3âˆ§0â‰¤/u1D458â‰¤3âˆ§ (âˆ€/u1D456.1â‰¤/u1D456â‰¤/u1D458â†’/u1D45B>/u1D456âˆ’1âˆ§/u1D460[/u1D456âˆ’1]=97) âˆ§Â¬/u1D45B>/u1D458
mem:[countâ†¦â†’/u1D458,pâ†¦â†’chars,sâ†¦â†’s,nâ†¦â†’n,charsâ†¦â†’chars]
matchthe regular pattern (/u1D7141,/u1D7142,/u1D7143)if for every /u1D457=1,...,/u1D45B:
/uni210E(/u1D70B(/u1D45B/u1D457))=/u1D7141/u1D714/u1D458/u1D457
2/u1D7143.
De/f_inition 3.4. A set of leaf nodes {/u1D45B/u1D457}/u1D45B
/u1D457=1in/u1D461is called a regular
partition if there exists a regular pattern (/u1D7141,/u1D7142,/u1D7143)and a set
{/u1D458/u1D457}/u1D45B
/u1D457=1âŠ†Nsuch that {(/u1D45B/u1D457,/u1D458/u1D457)}/u1D45B
/u1D457=1match that pattern. A regular
partitioning of leaf nodes in /u1D461is a partitioning into disjoint regular
partitions.
Example1. Considerahashfunction /uni210Ethatoperatesontheab-
stractsyntaxtree(AST)ofaformulaandassignsthesamepre-de/f_ined
valuetoalltheconstantnumericalterms.Suchahashfunctionen-
sures that formulas with a similar shape will be assigned the same
hashvalue,forexample:
/uni210E(/u1D45B>0)=/uni210E(/u1D45B>1)=/uni210E(/u1D45B>2)
/uni210E(/u1D460[0]=97)=/uni210E(/u1D460[1]=97)
Figure2shows the resulting hash values of the nodes in the execu-
tiontree. Forsimplicity,we visualizeeveryhashvalueas adistinct
color: white (W), red (R), blue (B), green (G), and yellow (Y). Here,
{(/u1D45B5,0),(/u1D45B9,1),(/u1D45B13,2)}matchtheregularpattern (W,GB,GY)since:
/uni210E(/u1D70B(/u1D45B5))=WGY, /uni210E(/u1D70B(/u1D45B9))=WGBGY, /uni210E(/u1D70B(/u1D45B13))=WGBGBGY
A (possible) regular partitioning of the leaf nodes in Figure 2is
giveninTable 1,whichshowsinthetwoleftmostcolumnstheregular
patternsand their correspondingregularpartitions.
In the following sections, we show how given a regular parti-
tionanditscorrespondingregularpattern,wecansynthesizethe
resultingmergedsymbolic state using quanti/f_iers.
3.2 Pattern-BasedState Merging
A regular pattern indicates the potential existence of a uniform
structure in the path conditions of the symbolic states in the asso-
ciatedregularpartition.We formalizethisintuitionusing formula
patterns.
De/f_inition 3.5. Aformula pattern is a tuple (/u1D7111,/u1D7112(/u1D465),/u1D7113(/u1D465)),
where/u1D7111is a closed formula, and /u1D7112(/u1D465)and/u1D7113(/u1D465)are formulas
with a free variable /u1D465. We say that {(/u1D45B/u1D457,/u1D458/u1D457)}/u1D45B
/u1D457=1matchthe formula
pattern(/u1D7111,/u1D7112(/u1D465),/u1D7113(/u1D465)),if for every /u1D457=1,...,/u1D45B:
tpc(/u1D45B/u1D457)/doteq/u1D7111âˆ§/parenleftbig/u1D458/u1D457/logicalanddisplay.1
/u1D456=1/u1D7112[/u1D456//u1D465]/parenrightbigâˆ§/u1D7113[/u1D458/u1D457//u1D465]
Theuniformstructureexposedbyformulapatternsenablesus
to perform state mergingwithquanti/f_iers:De/f_inition 3.6. Let{/u1D45B/u1D457}/u1D45B
/u1D457=1be a set of leaf nodes in /u1D461such that
{/u1D45B/u1D457./u1D460}/u1D45B
/u1D457=1are merge-compatible and {(/u1D45B/u1D457,/u1D458/u1D457)}/u1D45B
/u1D457=1match the for-
mulapattern (/u1D7111,/u1D7112(/u1D465),/u1D7113(/u1D465)).Thepattern-basedmergedsymbolic
stateof{/u1D45B/u1D457./u1D460}/u1D45B
/u1D457=1is a symbolic state /u1D460whose path constraint, /u1D460./u1D45D/u1D450,
is:
/u1D45F./u1D460./u1D45D/u1D450âˆ§ (/u1D45B/logicalordisplay.1
/u1D457=1/u1D458=/u1D458/u1D457) âˆ§/u1D7111âˆ§ (âˆ€/u1D456.1â‰¤/u1D456â‰¤/u1D458â†’/u1D7112[/u1D456//u1D465]) âˆ§/u1D7113[/u1D458//u1D465]
where/u1D458is a fresh constant, /u1D456is a fresh variable, and /u1D45Fis the root
of/u1D461.
The symbolic store of /u1D460is de/f_ined as follows. For every vari-
able/u1D463, if there exists a term /u1D461(/u1D465)with a free variable /u1D465such that
/u1D461[/u1D458/u1D457//u1D465]/doteq/u1D45B/u1D457./u1D460./u1D45A/u1D452/u1D45A(/u1D463)for every /u1D457=1,...,/u1D45B, then the value
of/u1D463is encoded as /u1D460.mem(/u1D463)â‰œ/u1D461[/u1D458//u1D465]. Otherwise, /u1D460.mem(/u1D463)â‰œ
merge_var ({/u1D45B/u1D457./u1D460}/u1D45B
/u1D457=1,/u1D463)(De/f_inition 2.1).
Pattern-basedstatemergingissoundandcompletew.r.t.standard
state merging. This isformalizedinthe following theorem:
Theorem 3.7. Under the premises of De/f_inition 3.6, let/u1D460be the
pattern-based merged symbolic state of {/u1D45B/u1D457./u1D460}/u1D45B
/u1D457=1, and let/u1D460â€²be their
merged symbolic state obtained with standard state merging (De/f_ini-
tion2.1). Thefollowingholdsfor anymodel /u1D45A:
â€¢/u1D45A|=/u1D460â€²./u1D45D/u1D450iï¬€/u1D45A[/u1D458â†¦â†’Ëœ/u1D458] |=/u1D460./u1D45D/u1D450for someËœ/u1D458âˆˆN.
â€¢If/u1D45A|=/u1D460./u1D45D/u1D450then/u1D45A(/u1D460â€².mem(/u1D463))=/u1D45A(/u1D460.mem(/u1D463))for every
variable/u1D463.
Example 2. Consider the regular partition {/u1D45B5,/u1D45B9,/u1D45B13}shown in
the/f_irstrowofTable 1.Theformulapattern (/u1D461/u1D45F/u1D462/u1D452,/u1D45B>/u1D465âˆ’1âˆ§/u1D460[/u1D465âˆ’
1]=97,/u1D45B>/u1D465âˆ§Â¬/u1D460[/u1D465]=97)ismatchedby ({(/u1D45B5,0),(/u1D45B9,1),(/u1D45B13,2)}.
The merged symbolic state induced by that formula pattern is shown
intherightmostcolumninTable 1(pcandmem).Notethatforthe
variablecount,theterm /u1D461(/u1D465)â‰œ/u1D465satis/f_ies:
/u1D461[0//u1D465]=0,/u1D461[1//u1D465]=1,/u1D461[2//u1D465]=2
so themergedvalue ofthatvariablecanbesimpli/f_ied to /u1D458.Themerg-
ing of the other variables is rather trivial as the symbolic states being
merged agreeontheir values.
3.3 Synthesizing FormulaPatterns
Sofar,wehaveyettodiscusshowformulapatternsareobtained.
Wenowdescribeanapproachthatattemptstosynthesizeaformula
pattern given a regular pattern and its associated regular partition.
AsexplainedinSection 3.2,thisenablesustoperformstatemerging
withquanti/f_iers.
Our hash function /uni210E, which we assume to be valid for /u1D461(De/f_ini-
tion3.1), has the following useful property:
1143StateMerging with/Q_uantifiersin SymbolicExecution ESEC/FSE â€™23, December3â€“9, 2023,San Francisco, CA, USA
Lemma 3.8. Thefollowingholdsforanytwo nodes /u1D45B1and/u1D45B2in/u1D461:
(1) If/uni210E(/u1D70B(/u1D45B1))=/uni210E(/u1D70B(/u1D45B2))then/u1D45B1=/u1D45B2.
(2)If/uni210E(/u1D70B(/u1D45B1))is a pre/f_ix of /uni210E(/u1D70B(/u1D45B2)), then there is a single path
/u1D70B(/u1D45B1,/u1D45B2)in/u1D461.
Accordingly,we de/f_ine:
De/f_inition 3.9. Let/u1D7141,/u1D7142âˆˆNâˆ—be twowordssuch that:
/uni210E(/u1D70B(/u1D45B1))=/u1D7141, /uni210E(/u1D70B(/u1D45B2))=/u1D7141/u1D7142
for somenodes /u1D45B1and/u1D45B2in/u1D461.Then we de/f_ine:
/u1D452/u1D465/u1D461/u1D45F/u1D44E/u1D450/u1D461(/u1D7141)â‰œtpc(/u1D45B1), /u1D452/u1D465/u1D461/u1D45F/u1D44E/u1D450/u1D461(/u1D7141,/u1D7141/u1D7142)â‰œtpc(/u1D45B1,/u1D45B2)
whichgivesusthetreepathconditiontailsassociatedwiththepaths
/u1D70B(/u1D45B1)and/u1D70B(/u1D45B1,/u1D45B2), respectively. (Note that Lemma 3.8ensures
that/u1D45B1and/u1D45B2are uniquely determinedby /u1D7141and/u1D7142.)
Weuseextracttode/f_inethesuï¬ƒcientrequirementstoobtaina
formula pattern from agiven regularpattern.
Lemma 3.10. Suppose that {(/u1D45B/u1D457,/u1D458/u1D457)}/u1D45B
/u1D457=1match the regular pat-
tern(/u1D7141,/u1D7142,/u1D7143). Let(/u1D7111,/u1D7112(/u1D465),/u1D7113(/u1D465))be a formula pattern that
satis/f_ies:
/u1D7111/doteq/u1D452/u1D465/u1D461/u1D45F/u1D44E/u1D450/u1D461(/u1D7141)
/u1D7112[/u1D456//u1D465]/doteq/u1D452/u1D465/u1D461/u1D45F/u1D44E/u1D450/u1D461(/u1D7141/u1D714/u1D456âˆ’1
2,/u1D7141/u1D714/u1D456
2) (/u1D456=1,...,max{/u1D458/u1D457}/u1D45B
/u1D457=1)
/u1D7113[/u1D458/u1D457//u1D465]/doteq/u1D452/u1D465/u1D461/u1D45F/u1D44E/u1D450/u1D461(/u1D7141/u1D714/u1D458/u1D457
2,/u1D7141/u1D714/u1D458/u1D457
2/u1D7143) (/u1D457=1,...,/u1D45B)
Then{(/u1D45B/u1D457,/u1D458/u1D457)}/u1D45B
/u1D457=1match(/u1D7111,/u1D7112(/u1D465),/u1D7113(/u1D465)).
BasedonLemma 3.10,wereducetheproblemof/f_indingaformula
patterntotwosynthesistasks,for /u1D7112and/u1D7113.(Notethat /u1D7111istrivially
obtained from the /f_irst requirement of the lemma.) Each synthesis
taskhas the form:
/u1D711[/u1D451/uni2113//u1D465]/doteq/u1D713/uni2113(/uni2113=1,...,/u1D45D)
where(i) /u1D711(/u1D465)istheformulato besynthesized(i.e., /u1D7112or/u1D7113),(ii)/u1D45D
isthenumberofequations(whichiseither /u1D45A/u1D44E/u1D465{/u1D458/u1D457}/u1D45B
/u1D457=1inthecase
of/u1D7112or/u1D45Bin the case of /u1D7113), (iii){/u1D713/uni2113}/u1D45D
/uni2113=1are formulas (obtained
from the extracted path constraints), and (iv) {/u1D451/uni2113}/u1D45D
/uni2113=1are constant
numericalterms(whicharethe /u1D456â€™sinthecaseof /u1D7112orthe/u1D458/u1D457â€™sin
the caseof /u1D7113).
As synthesis is a hard problem in general, we focus on thecase
where all formulas in {/u1D713/uni2113}/u1D45D
/uni2113=1are syntactically identical up to a
constant numerical term, i.e., there exists a formula /u1D703(/u1D466.alt)such that
/u1D703[/u1D6FE/uni2113//u1D466.alt]/doteq/u1D713/uni2113for some numerical constants {/u1D6FE/uni2113}/u1D45D
/uni2113=1. To obtain
/u1D711(/u1D465)from/u1D703(/u1D466.alt), it remains to synthesize a term that will express
each/u1D6FE/uni2113using the corresponding /u1D451/uni2113. Technically, if there exists a
term/u1D461(/u1D465)such that:
/u1D461[/u1D451/uni2113//u1D465] â‰¡/u1D6FE/uni2113(/uni2113=1,...,/u1D45D)
then the desired formula /u1D711(/u1D465)will be given by /u1D703[/u1D461(/u1D465)//u1D466.alt]. When
lookingforsuch /u1D461(/u1D465),werestrictourattentiontotermsoftheform
/u1D44EÂ·/u1D465+/u1D44Fwhere/u1D44Eand/u1D44Fare constant numerical terms that must
satisfy:
/u1D45D/logicalanddisplay.1
/uni2113=1(/u1D44EÂ·/u1D451/uni2113+/u1D44F=/u1D6FE/uni2113)
The existence of such /u1D44Eand/u1D44Fcan be checked using an SMT solver.Example3. Consideragaintheregularpattern (W,GB,GY)which
ismatchedby {(/u1D45B5,0),(/u1D45B9,1),(/u1D45B13,2)}.Welookforaformulapattern
(/u1D7111,/u1D7112(/u1D465),/u1D7113(/u1D465))that satis/f_ies:
/u1D7111/doteq/u1D461/u1D45F/u1D462/u1D452 /u1D452/u1D465/u1D461/u1D45F/u1D44E/u1D450/u1D461 (W)
/u1D7112[1//u1D465]/doteq/u1D45B>0âˆ§/u1D460[0]=97 /u1D452/u1D465/u1D461/u1D45F/u1D44E/u1D450/u1D461(W,WGB)
/u1D7112[2//u1D465]/doteq/u1D45B>1âˆ§/u1D460[1]=97 /u1D452/u1D465/u1D461/u1D45F/u1D44E/u1D450/u1D461(WGB,WGBGB)
/u1D7113[0//u1D465]/doteq/u1D45B>0âˆ§Â¬/u1D460[0]=97 /u1D452/u1D465/u1D461/u1D45F/u1D44E/u1D450/u1D461(W,WGY)
/u1D7113[1//u1D465]/doteq/u1D45B>1âˆ§Â¬/u1D460[1]=97 /u1D452/u1D465/u1D461/u1D45F/u1D44E/u1D450/u1D461(WGB,WGBGY)
/u1D7113[2//u1D465]/doteq/u1D45B>2âˆ§Â¬/u1D460[2]=97/u1D452/u1D465/u1D461/u1D45F/u1D44E/u1D450/u1D461(WGBGB,WGBGBGY )
Consider, for example, the formulas associated with /u1D7112. First, note
that they are identical up to a constant numerical term, e.g., for
/u1D703(/u1D466.alt)â‰œ/u1D45B>/u1D466.altâˆ§/u1D460[/u1D466.alt]=97:
/u1D703[0//u1D466.alt]/doteq/u1D45B>0âˆ§/u1D460[0]=97/u1D703[1//u1D466.alt]/doteq/u1D45B>1âˆ§/u1D460[1]=97
Now welook forconstantnumerical terms /u1D44Eand/u1D44Fsuchthat:
(0=(/u1D44EÂ·/u1D465+/u1D44F)[1//u1D465]) âˆ§ (1=(/u1D44EÂ·/u1D465+/u1D44F)[2//u1D465])
whichis satis/f_ied by /u1D44Eâ‰œ1and/u1D44Fâ‰œâˆ’1,therefore:
/u1D7112(/u1D465)â‰œ/u1D703[(/u1D465âˆ’1)//u1D466.alt]/doteq/u1D45B>/u1D465âˆ’1âˆ§/u1D460[/u1D465âˆ’1]=97
Wesimilarlysynthesize /u1D7113(/u1D465)â‰œ/u1D45B>/u1D465âˆ§Â¬/u1D460[/u1D465]=97.
Ifwesucceededtosynthesizeaformulapattern (/u1D7111,/u1D7112(/u1D465),/u1D7113(/u1D465))
matched by {(/u1D45B/u1D457,/u1D458/u1D457)}/u1D45B
/u1D457=1, we attempt to synthesize the merged
valueofavariable /u1D463bysynthesizing aterm /u1D461(/u1D465)that satis/f_ies:
/u1D461[/u1D458/u1D457//u1D465]/doteq/u1D45B/u1D457./u1D460./u1D45A/u1D452/u1D45A(/u1D463) (/u1D457=1,...,/u1D45B)
Suchterms are synthesizedsimilarlyto formula patterns.
For each regular partition shown in Table 1, we automatically
synthesizetheformulapatternandtheinducedmergedsymbolic
state using the techniqueabove.
The proofs for Theorem 3.7and the other lemmas are given
in[53,Section A].
4 INCREMENTALSTATEMERGING
When symbolically analyzing code fragments that contain disjunc-
tiveconditions,thenumberofgeneratedstates,aswellasthesizeof
the generated execution trees, might be exponential. In such cases,
theexplorationofthecodefragmentmightnotterminatewithin
the allocated time budget and the analysis might not even reach
the point where state merging, and pattern-based state merging in
particular,can be applied.
Toaddressthisissue,weproposean incremental approachfor
state merging, in which we merge leaves in the execution tree
not only with other leaves but also with internal nodes during
theconstructionofthetree.Thisallowstocompressthetreeasit
is constructed. Once the construction of the tree is complete, we
can apply our pattern-based state merging approach on the leaves.
Technically,inadditiontothe activesymbolicstates,i.e.,thosethat
are stored in the current leaf nodes, we keep also the non-active
symbolic states, i.e., those that are stored in the internal nodes.
When a new leaf /u1D45B1is added to the execution tree, we search for
the highest node /u1D45B2, i.e., closest to the root, such that /u1D45B1./u1D460and/u1D45B2./u1D460
aremerge-compatibleandhavethesamesymbolicstore w.r.t.live
variables [11]. We additionally require that /u1D45B1is unreachable from
1144ESEC/FSE â€™23, December3â€“9, 2023,San Francisco, CA, USA David Trabish, Noam Rinetzky, SharonShoham, andVaibhav Sharma
ğ’ğŸ
ğ’”ğŸ = ğŸ—ğŸ• Â¬ ğ’”ğŸ = ğŸ—ğŸ•
ğ’”ğŸ = ğŸ—ğŸ– Â¬ ğ’”ğŸ = ğŸ—ğŸ–
Â¬ ğ’”ğŸ = ğŸ—ğŸ•âˆ§ (Â¬ ğ’” ğŸ = ğŸ—ğŸ–) ğ’”ğŸ = ğŸ—ğŸ•âˆ¨ (Â¬ ğ’” ğŸ = ğŸ—ğŸ•âˆ§ ğ’”ğŸ = ğŸ—ğŸ–)ğ’ğŸ ğ’ğŸ‘
ğ’ğŸ’ ğ’ğŸ“
ğ’ğŸ
ğ’ğ’ğ’†ğ’˜ ğ’ğŸ“before
after
Figure3:Executiontreetransformationwhen memspniscalled
withcharsset to"ab".
/u1D45B2toavoidin/f_initesequencesofmerges.Ifsuchanode /u1D45B2isfound,
wereplace /u1D45B1and/u1D45B2(andtheirsubtrees)withasinglemergednode
/u1D45Bnewthat is added as a child of their lowest common ancestor, /u1D45Blca.
We/f_ix/u1D45Bnew./u1D450â‰œtpc(/u1D45Blca,/u1D45B1)âˆ¨tpc(/u1D45Blca,/u1D45B2)and/u1D45Bnew./u1D460isthemerged
state of/u1D45B1./u1D460and/u1D45B2./u1D460.Afterthe above,ifa node /u1D45Dremains witha
single child /u1D45B, we remove /u1D45D, redirect its incoming edge to /u1D45B, and
update the condition of /u1D45Bto/u1D45B./u1D450âˆ§/u1D45D./u1D450. As we merge internal nodes,
our approach does not relyon thesearch heuristic tosynchronize
betweentheactivesymbolicstatestoproducesuccessfulmerges.
Toavoidnodeswithmorethantwochildren,werequirethat /u1D45Blca
isthe parentof /u1D45B1or/u1D45B2.(Thisrestrictioncan be easily lifted.)
Example4. Consideragainthefunction memspnfromSection 1.
Whensymbolicallyanalyzing memspnwhilesettingthevalueof the
charsparameter to "ab", instead of "a", this results in an expo-
nential execution tree. The upper part of Figure 3shows the partial
execution tree with some of the nodes that were added during the
executionofthe/f_irstiterationsoftheloopatline 3.Assumingthat /u1D45B2
is added last, we merge it with /u1D45B4as the symbolic states associated
with/u1D45B2and/u1D45B4are both located at line 5and their symbolic stores
w.r.t.livevariablesareidentical,since pisdeadatthislocation.We
remove/u1D45B2and/u1D45B4togetherwithitssubtree,andaddanewnode /u1D45B/u1D45B/u1D452/u1D464
asachildof /u1D45B1,thelowestcommonancestorof /u1D45B2and/u1D45B4.Then,/u1D45B3is
left with its own child, /u1D45B5, so we remove /u1D45B3and appropriately update
the condition of /u1D45B5. This results in the execution tree shown in the
lower part of Figure 3. After applying similar steps in the subsequent
iterations of the loop, the /f_inal execution tree is similar to the one
from Figure 2, and can be obtained from it by replacing /u1D460[/u1D456]=97
andÂ¬/u1D460[/u1D456]=97with/u1D460[/u1D456]=97âˆ¨ (Â¬/u1D460[/u1D456]=97âˆ§/u1D460[/u1D456]=98)and
Â¬/u1D460[/u1D456]=97âˆ§Â¬/u1D460[/u1D456]=98, respectively (for /u1D456=0,1,2). Now, pattern-
based state merging can be applied similarly to the example given in
Section3.
Theincrementalstatemergingapproachusesastandardliveness
analysis [ 11] to /f_ind symbolic states to be merged. If the computed
liveness results are imprecise, our approach will not be able to /f_ind
matchingsymbolicstatesandthereforewillnotbeabletocompress
the execution tree. In that case, our approach will only impose the
overhead of maintaining snapshots of non-active symbolic states.5 SOLVING QUANTIFIED QUERIES
In general, the quanti/f_ied queries generated by our approach (Sec-
tion3) can be solved using an SMT solver that supports quanti/f_ied
formulas,e.g.,Z3[ 24].Inpractice,however,weobservedthatthe
generic method employed by Z35to solve such queries often leads
tosubparperformancecomparedtothesolvingofthequanti/f_ier-
freevariantofthequeries.Hence,wedeviseasolvingprocedure
that leverages theparticular structure of thegeneratedquanti/f_ied
formulas, andresortto the genericmethodif our approach fails.
Our solving procedure assumes a closed formula /u1D711=/logicalandtext.1/u1D450where
eachclause /u1D450iseitheraquanti/f_ier-freeformulaorauniversalfor-
mula of the form âˆ€/u1D456.1â‰¤/u1D456â‰¤/u1D458â†’/u1D713where/u1D713is a quanti/f_ier-free
formulawithafreevariable /u1D456.Oursolvingprocedureworksinfour
stages:6
(1)Quanti/f_ierstripping. Weweaken /u1D711intoaquanti/f_ier-free
formula/u1D711QFbyreplacingquanti/f_iedclauseswithimpliedquanti/f_ier-
free clauses. Technically, each quanti/f_ied clause âˆ€/u1D456.1â‰¤/u1D456â‰¤/u1D458â†’/u1D713
in/u1D711isreplacedwiththeconjunctionofthefollowingtwoquanti/f_ier-
free formulas7:
(1)/u1D458â‰¥1â†’/u1D713[1//u1D456] (2)/logicalanddisplay.1
{Â¬(1â‰¤/u1D461â‰¤/u1D458) | (Â¬/u1D713[/u1D461//u1D456]) âˆˆ/u1D711}
Intuitively,the formerprovidesaquanti/f_ier-free clausewhichpar-
tiallypreservesthepropertiesimposedbythequanti/f_iedclause,and
thelatterreducesthechancesthattheSMTsolvercomputesamodel
of/u1D711QFthat does not satisfy /u1D711: if1â‰¤/u1D461â‰¤/u1D458thenâˆ€/u1D456.1â‰¤/u1D456â‰¤/u1D458â†’/u1D713
demands that /u1D713[/u1D461//u1D456]holds in any model of /u1D711. If the SMT solver
fails to /f_ind a model for /u1D711QF, then/u1D711is also unsatis/f_iable. If a model
wasfound,we checkwhether itisalsoamodelof /u1D711.
Example 5. Consider the following query, a simpli/f_ication of a
representativequeryfrom our experiments:
/u1D711â‰œ(/u1D460[/u1D45B]=0) âˆ§ (1â‰¤/u1D458â‰¤10) âˆ§ (/u1D460[/u1D458âˆ’1]=8)âˆ§
(âˆ€/u1D456.1â‰¤/u1D456â‰¤/u1D458â†’/u1D460[/u1D456âˆ’1]â‰ 0)
Notethat(a)theinstantiationofthequanti/f_iedformulausing /u1D456=1
results in /u1D458â‰¥1â†’/u1D460[0]â‰ 0, and (b) /u1D460[/u1D45B]=0is obtained by
substituting Â¬(/u1D460[/u1D456âˆ’1]â‰ 0)[/u1D45B+1//u1D456]. Thus, the weakened query
obtained byquanti/f_ierstripping is givenby:
/u1D711QFâ‰œ(/u1D460[/u1D45B]=0) âˆ§ (1â‰¤/u1D458â‰¤10) âˆ§ (/u1D460[/u1D458âˆ’1]=8)âˆ§
(/u1D458â‰¥1â†’/u1D460[0]â‰ 0) âˆ§Â¬(1â‰¤/u1D45B+1â‰¤/u1D458)
Thefollowingmodel,forexample,is amodelof /u1D711QF:
/u1D45Aâ‰œ{/u1D45Bâ†¦â†’7,/u1D458â†¦â†’7,/u1D460â†¦â†’ [1,0,0,0,0,0,8,0]}
but,unfortunately,it is not amodelof /u1D711.
(2)AssignmentDuplication. If/u1D45Aisnotamodelof /u1D711,wemodify
/u1D45Ainto a model /u1D45A/u1D451which assigns to every array cell accessed by a
quanti/f_ied clause a value /u1D463of a cell in that array that was explicitly
constrainedby /u1D711QF.Technically,foreveryarray /u1D44Eaccessedwithan
oï¬€setthatdependsonthequanti/f_iedvariable /u1D456wedothefollowing:
(1)pickanaccessedoï¬€set /u1D45Cof/u1D44Ein/u1D713suchthat /u1D45Cdependson /u1D456,(2)
evaluatethevalueof (/u1D44E[/u1D45C])[1//u1D456]in/u1D45A,namely/u1D463,and(3)compute
theconcreteoï¬€setsobtainedbyevaluating /u1D45C[/u1D457//u1D456]in/u1D45A(for2â‰¤/u1D457â‰¤
5CVC5 [15] and Yices [ 28] failed to solvemostof ourqueries.
6Fortheinterestedreader,acompletepseudocodeofthesolvingprocedureisgiven
in [53, SectionB].
7Wewrite /u1D450âˆˆ/u1D711to notethat /u1D450is one of the clauses of /u1D711.
1145StateMerging with/Q_uantifiersin SymbolicExecution ESEC/FSE â€™23, December3â€“9, 2023,San Francisco, CA, USA
/u1D45A(/u1D458)) and modify /u1D45Asuch that the values of /u1D44Eat these oï¬€sets are
set to/u1D463. Recall that the accessed cells of /u1D44Ein/u1D713[1//u1D456]were explicitly
constrainedin /u1D711QF,so/u1D463isagoodcandidateto/f_illinalltheother
cellsof/u1D44Econstrainedin /u1D711.However,thisduplicationisrathernaive
andmightresult inamodelthat does not even satisfy /u1D711QF.
Example6. ContinuingExample 5,wepickfromthequanti/f_ied
clause the accessed oï¬€set /u1D456âˆ’1of the array /u1D460, and update the value
of/u1D460[/u1D457]to/u1D45A(/u1D460[/u1D456âˆ’1][1//u1D456])for each1â‰¤/u1D457â‰¤6. This results in the
followingmodel:
/u1D45A/u1D451â‰œ{/u1D45Bâ†¦â†’7,/u1D458â†¦â†’7,/u1D460â†¦â†’ [1,1,1,1,1,1,1,0]}
The model /u1D45A/u1D451helps to satisfy the quanti/f_ied clause, but does not
satisfy/u1D711(speci/f_ically,theclause /u1D460[/u1D458âˆ’1]=8is violated).
(3)ModelRepair. If/u1D45A/u1D451isnotamodelof /u1D711,wefurthermodify
/u1D45A/u1D451intoanothermodel, /u1D45A/u1D45F,which,muchlike /u1D45A/u1D451,attemptstosat-
isfytheconstraintsonthecontentsofarraysthatareimposedby /u1D711
but omitted in /u1D711QF. For every quanti/f_ied clause âˆ€/u1D456.1â‰¤/u1D456â‰¤/u1D458â†’/u1D713,
wecollectalltheaccesses /u1D44E[/u1D45C]where/u1D45Cdependson /u1D456.Foreachsuch
access andfor each 2â‰¤/u1D457â‰¤/u1D45A(/u1D458),we compute the concrete oï¬€set
obtainedbyevaluating /u1D45C[/u1D457//u1D456]in/u1D45A/u1D451andstrengthen /u1D711QFwiththe
instantiation /u1D713[/u1D457//u1D456]ifthat oï¬€set appears in the concrete oï¬€sets of
aviolatedquanti/f_ier-freeclause(oraviolatedinstantiation).Rather
than computing from scratch a new model for the strengthened
query, we /f_ix the values of all the array cells (and variables) ac-
cording to their interpretation in /u1D45A/u1D451except for the arrays that are
accessedwith /u1D456,thoseforwhichanewinterpretationissought.If
theresultingqueryhas amodel, weapplyassignment duplication
onit.Thistime,toavoidoverwriting,theduplicationisnotapplied
to the oï¬€sets involvedinviolations.
Example7. ContinuingExample 6,theviolatedclauseinthemodel
/u1D45A/u1D451is/u1D460[/u1D458âˆ’1]=8,anditsconcreteaccessis /u1D460[6].Theconcreteaccess
in the instantiation (/u1D460[/u1D456âˆ’1]â‰ 0)[7//u1D456]that was omitted in /u1D711QFis
also/u1D460[6], so we add it to /u1D711QF. In addition, we concretize the values
of/u1D45Band/u1D458according to /u1D45A/u1D451. The resulting strengthened query and its
possiblemodelare:
/u1D711QFâˆ§ (/u1D460[6]â‰ 0) âˆ§ (/u1D45B=7) âˆ§ (/u1D458=7)
{/u1D45Bâ†¦â†’7,/u1D458â†¦â†’7,/u1D460â†¦â†’ [1,0,0,0,0,0,8,0]}
Then, we duplicate again, but this time while skipping over the
cell/u1D460[6]. Similarly to the /f_irst duplication, /u1D463is set to 1, but the value
of/u1D460[/u1D457]is updated only for 1â‰¤/u1D457â‰¤5, thus avoiding the original
violation. Theresulting modelindeed satis/f_ies /u1D711:
/u1D45A/u1D45Fâ‰œ{/u1D45Bâ†¦â†’7,/u1D458â†¦â†’7,/u1D460â†¦â†’ [1,1,1,1,1,1,8,0]}
(4) Fallback. If no model /u1D45A/u1D45Fis found, or if it does not satisfy /u1D711,
we ask the SMTsolver to /f_ind amodelfor /u1D711.
6 IMPLEMENTATION
WeimplementedourstatemergingapproachontopoftheKLEE[ 19]
symbolic executionengine, con/f_igured withLLVM7.0.0[ 38]. Our
approach generates quanti/f_ied queries overarrays and bitvectors,
so we use Z3 [ 25] (version 4.8.17) as the underlying SMT solver.
We extended KLEEâ€™s expression language to support quanti/f_ied
formulas, andmodi/f_ied some parts of thesolver chain accordingly.
Weimplementedoursolvingprocedure(Section 5)asanadditional
component in the solver chain. To implement the hashfunctionusedbythepattern-basedstatemergingapproach(Section 3),we
relied on the expression hashing utility of KLEE and modi/f_ied it
byassigningapre-de/f_inedhashvaluetoallconstants.Toextract
the regularpatternsfrom the executiontrees, we used abasicreg-
ular expression matching algorithm. If our hash function is not
valid for a given generated execution tree (De/f_inition 3.1), or the
number of extracted regular patterns in that tree exceeds a user-
speci/f_ied threshold, then we fallback to standard state merging
(De/f_inition 2.1). Our implementationisavailable at [ 1].
7 EVALUATION
Evaluating astate-merging approach requires determining the de-
siredmergingpoints,i.e.,thecodesegmentswherestatemerging
should be applied. In our case, this translates to identifying code
segments that produce merging operations that involve many sym-
bolicstates.Todoso,weevaluateourapproachinthecontextofthe
symbolic-size memorymodel[ 52].Thismodelsupportsbounded
symbolic-sizeobjects,i.e.,objectswhosesizecanhavearangeof
values,limitedbyauser-speci/f_ied capacitybound.8Itwasobserved
in [52] that loops operating on symbolic-size objects typically pro-
duce many symbolic states, and state-merging was suggested to
combat the ensued state explosion problem. Thus, this memory
model provides a suitable basis for evaluating our state-merging
approach. Furthermore, the automatic detection of merging points
in [52] avoids the need for manual annotations. We emphasize,
however, that our technique is independent of the symbolic-size
memory model itself (see Section 7.7). That said, the symbolic-size
memorymodeldoes have thepotentialtoproducemorechalleng-
ingmergingoperationsthantheconcrete-sizemodelasitconsiders
alarger state space.
The followingmodes arethe mainsubjectsofcomparison: The
PATmodeisthepattern-basedstatemergingapproachdescribedin
Section3which partitions the symbolic states into merginggroups
based on regular patterns in the execution tree, and uses quan-
ti/f_iers to encode the merged path constraints. In the PATmode,
the incremental state merging approach (Section 4) and the solv-
ingprocedure(Section 5)areenabled.The CFGmodeisthestate
mergingapproachdiscussedabove( SMOptmodefrom[ 52]),which
partitions the symbolic states into merging groups according to
their exit point from the loop in the CFG, and uses the standard
QFABVencoding [ 29] (disjunctions and iteexpressions). The BASE
mode isthe forking approach usedinvanilla KLEE [ 19].
The following research questionsguide our evaluation:
(RQ1) Does PATimprove standardstate merging ( CFG)?
(RQ2) Does PATimprove standardsymbolic execution( BASE)?
(RQ3) Doallcomponentscontributeto the performance of PAT?
7.1 Benchmarks
The benchmarks used in our evaluation are listed in Table 2. These
benchmarkswerechosenastheyarechallengingforsymbolicex-
ecution and provide numerous opportunities for applying state
merging.Ineachbenchmark,weanalyzedasetofsubjects(APIs
and whole programs) whose inputs (parameters, command-line
8This is in contrast to the standard concrete-size model where every object has a
concretesize.
1146ESEC/FSE â€™23, December3â€“9, 2023,San Francisco, CA, USA David Trabish, Noam Rinetzky, SharonShoham, andVaibhav Sharma
arguments,etc.)canbemodeledusingsymbolic-sizeobjects,i.e.,ar-
rays and strings. In libosip[7],libtasn1[6], andlibpng[10], the test
driversfortheAPIsweretakenfrom[ 52].9Inwget[8],alibraryfor
retrieving/f_ilesusingwidelyusedinternetprotocols(HTTP,etc.),we
reusedthetestdriversfromtheexistingfuzzingtestsuitewhenever
possible, and for other APIs, we constructed the test drivers manu-
ally. Inapr[12] (Apache Portable Runtime), a library that provides
aplatform-independentabstractionofoperatingsystemfunction-
alities,weconstructedtestdriversforAPIsfromseveralmodules
(strings,/f_ile_ioandtables) which manipulate strings, /f_ile-system
paths, and data structures. In json-c[9], a library for decoding and
encodingJSONobjects,weconstructedtestdriversforAPIsthat
manipulate string objects. In busybox[4], a software suite that pro-
vides a collection of Unix utilities, we focused on utilities whose
inputcomes from command-line arguments and /f_iles,which can
besymbolicallymodeledusingKLEEâ€™s posixruntime.Wedidnot
analyze utilities whose behavior depends on the state of system
resources(processinformation,permissions,/f_ile-systemdirectories,
etc.),sinceKLEEhasnosymbolicmodelingforthose.Toprevent
the symbolic executor from getting stuck in getopt() , the routine
usedinbusyboxtoparsecommandlinearguments,weaddedthe
restriction that symbolic command line arguments do not begin
withaâ€˜-â€™character.
7.2 Setup
Weruneverymodeunderthesymbolic-sizememorymodel[ 52]
withthefollowingcon/f_iguration:aDFSsearchheuristic,aone-hour
time limit,anda4GB memorylimit.The capacitysettings ineach
ofthe benchmarks are showninTable 2.10
Ineveryexperiment,weusethefollowingmetricstocompare
betweenthemodes:analysistimeandlinecoveragecomputedwith
GCov[5].Whenthecomparedmodeshavethesameexploration
order,weadditionallyusethepathcoveragemetric,i.e.,thenumber
ofexploredpaths.
Each benchmark consists of multiple subjects, so when compar-
ingthetwomodes,wemeasuretherelativespeedupandtherelative
increase in coverage for each subject. Note that when we measure
the average (and median) speedup, for example, the speedup in
thesubjectswherebothmodestimedoutisalways1 Ã—.Similarly,
when we measure coverage, the coverage in the subjects where
both modesterminated, i.e., completed theanalysis before hitting
the timeout, is always identical. To separate the subjects where the
resultsaretriviallyidentical,wereporttheaverage(andmedian)
over asubsetof the subjects depending on the evaluated metric:
Whenmeasuring analysis time,we considerthe subsetof thesub-
jects where at least one of the modes terminated. When measuring
coverage, we consider the subset of the subjects where at least one
ofthemodestimedout.In[ 53,SectionC.1.1],weadditionallyreport
the average(andmedian)when computedover allthe subjects.
We ran our experiments on several machines (Intel i7-6700 @
3.40GHz with32GBRAM)withUbuntu20.04.
9We noticed that some of the APIs from libosipthat were used in [ 52] are similar,
i.e., diï¬€erent APIs with the same internal functionality. The analysis of such APIs
leadstothesameresults,therefore,weexcludedthemfromtheevaluationtoavoid
redundancy.
10Inlibosip,libtasn1, andlibpng, the capacity settings were set similarly to the experi-
ments from [ 52].Table 2:Benchmarks.
Version SLOC #Subjects Capacity
libosip 5.2.1 18,783 35 10
wget 1.21.2 100,785 31 200
libtasn1 4.16.0 15,291 13 100
libpng 1.6.37 56,936 12 200
apr 1.6.3 60,034 20 50
json-c 0.15 8,167 5 100
busybox 1.36.0 198,500 30 100
7.3 Results: PATvs.CFG
In this experiment, we compare between the performance of the
statemergingmodes: PATandCFG.TheresultsareshowninTable 3
andFigure 4.
AnalysisTime. ColumnSpeedupinTable3showsthe(average,
median, minimum, and maximum) speedup of PATcompared to
CFGin the subjects where at least one of the modes terminated.
Column#showsthenumberofconsideredsubjectsoutofthetotal
numberofsubjects.In libosip,wget,apr,json-c,andbusybox,PAT
wassigni/f_icantlyfasterinmanysubjects,andin libtasn1andlibpng,
theanalysistimeswereroughlyidentical.Figure 4abreaksdown
the speedup of PATcompared to CFGper subject. Overall, there
were12subjectswhere PATwasslowerthan CFG.Inlibosip,PAT
was slower only in one API. In this case, the slowdown of 0.03 Ã—
(from20 to 554 seconds) wascaused bya small number of queries
(9)thatoursolvingprocedure(Section 5)failedtosolve,andwhose
solving using the SMT solver required most of the analysis time.
Inwget,PATwas slower in two APIs. In one case, the slowdown
wascausedbythecomputationaloverheadoftheincrementalstate
mergingapproach.Intheothercase,theslowdownwascausedbya
relatively high number of queries that our solving procedure failed
to solve. In libtasn1,PATwas slower in seven APIs, but the time
diï¬€erence in these cases was rather minor (roughly 10 seconds). In
libpng,PATwasslightlyslowerinoneAPIduetothecomputational
overheadofextractingregularpatterns.In busybox,PATwasslower
in one utility with a minor time diï¬€erence of two seconds. Column
Diï¬€.inTable3showsthediï¬€erencebetween PATandCFGinterms
ofthe totaltime required to analyze allthe subjects. Notethat the
time diï¬€erence is interpreted as zero in subjects where both modes
are timed out. In libosip,wget,apr, andbusybox,PATachieved a
considerable reduction of roughly 8, 4, 1, and 3 hours, respectively.
Injson-c,PATachievedareductionofroughly20minutes,andin
libtasn1andlibpng,thetimediï¬€erencewasminor.Figure 4bbreaks
downthe time diï¬€erence between PATandCFGper subject.
Coverage. ColumnCoverage inTable3shows the(average, me-
dian,minimum,andmaximum)relativeincreaseinlinecoverageof
PAToverCFGinthesubjectswhereatleastoneofthemodestimed
out. Again, column #shows the number of considered subjects. In
libosipandwget,PATachievedhighercoverageinmanycases.In
libtasn1,PATresortedtostandardstatemerginginmostcases,asit
didnot/f_indregular(andformula)patterns.Therefore,theresults
weresimilartothoseof CFG,andcoveragewasnotimproved.In
libpng,thecoveragewasroughlyidenticalinalltheAPIsexceptfor
twoAPIswhere PATachievedanimprovementof8.69%and18.33%.
Inapr, the coverage was identical in all the APIs except for two
cases where PAThad an increase of 16.62% and a decrease of 2.12%.
1147StateMerging with/Q_uantifiersin SymbolicExecution ESEC/FSE â€™23, December3â€“9, 2023,San Francisco, CA, USA
Injson-c, there was only one API where one of the modes timed
out, and in this case, CFGachieved higher coverage. In busybox,
there were 23 cases where at least one of the modes timed out.
In four cases, PATachieved an improvement of 3.98%-15.45%, and
intwocases, CFGachievedanimprovementof1.15%and61.78%.
Intheremaining17cases,thecoveragewasidentical.(Inmostof
thesecases, PATdidnot/f_indformulapatterns,resultinginidentical
explorations.)Column Diï¬€.inTable3showsthediï¬€erencebetween
PATandCFGinterms ofthetotalnumberofcoveredlinesacross
all the subjects. Again, note that there is no diï¬€erence in coverage
in subjects where both modes terminated. It is possible to have an
improvementinaverage coveragebut not intotalline diï¬€erence
(apr) and vice versa ( busybox). This happens due to shared code
that is covered by only one mode in one subject but covered by the
othermodeinothersubjects.Figure 4cbreaksdownthecoverage
improvement of PAToverCFGper subject.
Scaling.The main obstacle in applying state merging originates
fromtheintroductionofdisjunctiveconstraintsand iteexpressions,
especiallywhenthenumberofstatestobemergedishigh.Weeval-
uate the ability of our approach to cope with a particular aspect of
thischallengewherethestatesaregeneratedbyloopsiteratingover
largedataobjects,afrequentsituationinourexperience.Techni-
cally,weconductedacasestudyon libosip,oneofourbenchmarks,
where we gradually increase the capacityofsymbolic-sizeobjects.
Whenthecapacityisincreased,thesizeofthesymbolic-sizeobjects
ispotentiallyincreasedaswell.Thistypicallyleadstoadditional
forks,forexample,inloopsthatoperateonsymbolic-sizeobjects.
As we apply state merging in such loops, this eventually results
inmorecomplexmergingoperations.Thus,increasingthecapac-
ityallowsustomeasurehoweachmodescalesw.r.t.thenumber
of merged states. In this experiment, we run each API in each of
the state merging modes ( PATandCFG) under several diï¬€erent
capacitysettings.The results are showninTable 4.
Ascanbeseen, PATachievedbetterresultsthan CFGinallthe
capacity settings. In general, when the capacity is increased, there
are typically more forksandqueries,whichmakestheanalysis of
size-dependent loops harder for both modes. Therefore, the cover-
ageimprovementwaslesssigni/f_icantunderthehighestcapacity
settings(100and200)comparedtothelowercapacitysettings.Note
alsothatunderthosecapacitysettings,therewereonly/f_iveAPIs
inwhichatleastoneofthemodesterminated.Weobservedthat
in these APIs, the analysis time increased in both modes when
thecapacitywasincreased.However,with CFG,theanalysistime
increased more signi/f_icantly, so the speedupunder the highest ca-
pacitysetting(200)wasgreater.Thisindicatesthatourapproach
is less sensitive to the input capacity and hence to the resulting
number ofmergedstates.
RQ1 Answer: PAT outperforms CFG in many cases and scales
better in executing complex statemergingoperations.
7.4 Results: PATvs.BASE
In this experiment, we compare the performance of PATandBASE,
i.e., standard symbolic execution that uses the forking approach.
The results are showninTable 5.
ColumnSpeedupshowsthe(averageandmedian)speedupof PAT
compared to BASEin the subjects where at least one of the modesterminated. As can be seen, PATachieved a considerable speedup
inthemajorityofthebenchmarks.Overall,therewereninesubjects
in which PATwas slower than BASE. In three of these cases, the
timediï¬€erencewasminor(roughly5seconds).Intheothercases,
the slowdown was caused by the computational overhead of the
incrementalstatemergingapproachandthecomplexconstraints
thatwereintroducedduringthestatemerging.Regardingtimeouts,
therewere20subjectsinwhich BASEtimedoutand PATterminated,
andonlyonesubjectinwhich PATtimedoutand BASEterminated.
ColumnCoverage shows the (average and median) relative in-
crease inline coverage of PAToverBASEin thesubjects where at
least one of the modes timed out. PATachieved higher coverage
in many subjects, especially in libosipandlibpng. In most of the
casesinlibtasn1,apr,andjson-c,bothmodescoveredmostofthe
reachablelinesinarelativelyearlystage,sothecoveragewassimi-
lar. Inwgetandbusybox,PATachieved higher coverage in some of
thecases,buttherewerealsocasesinwhich BASEachievedhigher
coverage.Ingeneral,thisisaconsequenceoftheknowntradeoï¬€
betweenforkingand statemerging:Theforking approachexplores
more pathsbut generatesless complex constraints.
In addition, we observed that there were four subjects in which
BASEran out of memory. In two of these cases, BASE/f_inished the
analysis before PAT, but its analysis was incomplete since KLEE
prunes the searchspaceoncethe memory limit isreached.
For space reasons, the breakdown of the improvement of PAT
overBASEper subjectisshownin[ 53,Section C.1.2].
RQ2Answer: PAToutperformsBASEinmanycases,however,the
known tradeoï¬€ betweenstatemergingand forkingremains.
7.5 Results:Component Breakdown
Now,weevaluatethesigni/f_icanceofthecomponentsusedinour
pattern-basedstate merging approach (i.e., PAT).
7.5.1 SolvingProcedure. Toevaluateoursolvingprocedure(Sec-
tion5), we ran each subject in two versions of PAT: one that relies
only on the SMT solver (vanilla Z3) and another one that uses our
solvingprocedure. Both modesarerunwith the incremental state
mergingapproach enabled.
To evaluate the impact of the solving procedure, we show in
Table6its eï¬€ect on analysis time and coverage in the relevant
subsets. Here, the two modes have the same exploration order,
so we use the path coverage metric as well. In libosip,wget,apr,
json-c, andbusybox, our solving procedure generallyleads to lower
analysis times and higher (line or path) coverage. The results were
mostlysimilarin libtasn1andlibpngsincethenumberofquanti/f_ied
queries was relatively low. The only exception was one of the APIs
inlibpng,where the pathcoveragewasincreasedby39.51%.
7.5.2 IncrementalStateMerging. Toevaluatetheincrementalstate
merging approach (Section 4), we run each subject in two versions
ofPAT: one that disables incremental state merging and another
one that enables it.The results are showninTable 7.
Inlibosip,therewererelativelymanyloopswhereincremental
state merging was successfully applied, i.e., reduced the number of
exploredpaths.Thisresultedinasigni/f_icantspeedupandhigher
linecoverage.In wget,therewerefourAPIswhereincrementalstate
mergingcouldbe applied,andintwo ofthesecases, the coverage
1148ESEC/FSE â€™23, December3â€“9, 2023,San Francisco, CA, USA David Trabish, Noam Rinetzky, SharonShoham, andVaibhav Sharma
Table 3:Comparisonof PATvs.CFG.
Time Coverage(%)
Speedup( Ã—) Diï¬€.(seconds) Diï¬€.(lines)
# Avg. Med. Min. Max. # Avg. Med. Min. Max.
libosip 16/35 7.18 5.50 0.03 180.00 27668 28/35 20.45 9.00 0.00 88.63 291
wget 11/31 2.69 1.67 0.54 14.69 12942 24/31 15.02 0.00 -40.00 300.00 89
libtasn1 7/13 0.94 0.95 0.90 0.96 -41 6/13 0.00 0.00 0.00 0.00 0
libpng 1/12 0.70 0.70 0.70 0.70 -9 11/12 2.03 0.00 -2.88 18.33 104
apr 10/20 3.50 1.63 1.00 138.46 4375 11/20 1.31 0.00 -2.12 16.62 0
json-c 4/5 3.16 2.97 2.00 5.76 1149 1/5 0.81 0.81 0.81 0.81 1
busybox 8/30 1.68 1.07 0.92 16.20 10100 23/30 -1.08 0.00 -61.78 15.45 74
Subjectsspeedup (x)
0.1110100
(a) Speedup in analysis time ( Ã—) in the sub-
jectswhereatleastoneofthemodestermi-
nated(inlog-scale).
Subjectsdiff. (seconds)
-100001000200030004000(b) Diï¬€erence in analysis time ( seconds) in
thesubjectswhereatleastoneofthemodes
terminated.
Subjectscoverage (%)
-100-50050100(c)Relativeincreaseincoverage(%)inthe
subjects where at least one of the modes
timedout.
Figure 4:Breakdownoftheimprovementof PAToverCFGpersubject.
Table4:Comparisonof PATvs.CFGunderdiï¬€erentcapacity
settings (column Capacity ) inlibosip.
Capacity Speedup( Ã—) Coverage(%)
# Avg. Med. # Avg. Med.
10 16/35 7.18 5.50 28/35 20.45 9.00
20 13/35 4.58 5.53 29/35 23.41 19.29
50 12/35 1.99 2.43 30/35 15.19 10.63
100 5/35 2.99 2.75 30/35 10.23 2.32
200 5/35 4.81 6.11 30/35 4.22 0.00
Table 5:Comparisonof PATvs.BASE.
Speedup( Ã—) Coverage(%)
# Avg. Med. # Avg. Med.
libosip 17/35 11.21 3.10 28/35 11.43 1.88
wget 12/31 2.75 3.72 24/31 -2.32 0.00
libtasn1 7/13 4.94 9.30 7/13 1.49 0.00
libpng 1/12 2.46 2.46 11/12 23.59 7.14
apr 10/20 8.40 3.91 14/20 -0.15 0.00
json-c 4/5 1.36 3.09 2/5 0.82 0.82
busybox 9/30 2.43 2.51 22/30 -2.76 0.00
was improved by 33.33% and 300.00%. In apr, there were four APIs
where incremental state merging could be applied, and in one of
these cases, the analysis time was reduced by 138.46 Ã—and the
coverage was improved by 16.62%. In busybox, there were two
utilities whereincrementalstate mergingcould be applied,andin
thesecases,thecoveragewasimprovedby11.33%and15.45%.In
libtasn1,libpng, andjson-c, there were no loops where incremental
state merging could be applied. In some cases, this resulted in a
minor performance penalty due to the computational overhead of
theapproach,whichmainlycomesfromtheneedtomaintainthe
snapshotsofthe non-active symbolic states inthe executiontree.Table 6:Impactofsolvingprocedure.
Speedup( Ã—) Coverage(%)
Line Path
# Avg. Med. # Avg. Med. Avg. Med.
libosip 16/35 1.55 1.57 19/35 0.26 0.00 89.31 72.82
wget 11/31 4.28 3.62 27/31 14.81 0.00 110.17 30.94
libtasn1 7/13 0.99 0.99 6/13 0.00 0.00 -0.74 -0.24
libpng 1/12 1.03 1.03 11/12 -0.23 0.00 2.62 0.00
apr 10/20 2.86 3.49 10/20 0.00 0.00 38.31 5.57
json-c 4/5 2.89 2.33 1/5 0.00 0.00 79.49 79.49
busybox 8/30 1.29 1.09 23/30 0.52 0.00 9.53 1.65
Table 7:Impactofincremental statemerging.
Speedup( Ã—) Coverage(%)
# Avg. Med. # Avg. Med.
libosip 16/35 6.78 2.80 28/35 18.98 5.83
wget 11/31 0.97 0.97 20/31 16.66 0.00
libtasn1 7/13 0.96 0.98 6/13 0.00 0.00
libpng 1/12 0.96 0.96 11/12 2.35 0.00
apr 11/20 1.60 1.00 11/20 1.71 0.00
json-c 4/5 1.01 1.01 1/5 0.00 0.00
busybox 8/30 0.98 1.00 20/30 0.76 0.00
RQ3Answer: Allthecomponentscontribute.
7.6 FoundBugs
We found two bugs during our experiments with busybox. In both
cases,anull-pointerdereferenceoccurredintheimplementationof
realpath inklee-uclibc ,KLEEâ€™smodi/f_iedversionof uClibc[54].We
reportedthebugs,whichwerecon/f_irmedand/f_ixedbytheoï¬ƒcial
maintainers[ 2].Wenotethatthesebugsweredetectedby PATand
BASE,but were not foundby CFGdueto atimeout.
1149StateMerging with/Q_uantifiersin SymbolicExecution ESEC/FSE â€™23, December3â€“9, 2023,San Francisco, CA, USA
7.7 Threatsto Validity
First,ourimplementationmayhavebugs.Tovalidateitscorrectness,
weperformedaseparateexperimentwhereeachsubjectwasrun
in thePATmode with a timeout of one hour. During these runs,
wevalidatedthateveryexecutedstatemergingoperationiscorrect
w.r.t. Theorem 3.7. In addition, for every query that our solving
procedure was able to solve, we validated the consistency of the
reportedresult w.r.t. the underlying SMTsolver.
Second,ourchoiceofbenchmarksmightnotberepresentative
enough.Thatsaid,wechoseadiversesetofreal-worldbenchmarks
used in prior work [ 35,47,52]. In addition, we used benchmarks
that processinputsofboth binary andtextual formats.
Third,weevaluatedourapproachinthecontextofthesymbolic-
size model [ 52]. To address the threat that our approach may be
bene/f_icial only in the context of that particular memory model, we
performedanadditionalexperimentusingthestandardconcrete-
sizememorymodel.Inthisexperiment,wesettheconcretesizesof
theinputobjectsaccordingtothecapacitycon/f_igurationinTable 2,
andapplystatemerginginloopswhoseconditionsdependonthese
sizes, as we do in our original experiments. The results, shown
in[53,SectionC.3],leadtoconclusionssimilartotheonesdrawn
from the originalexperiments.
Fourth, the search heuristic might aï¬€ect the coverage when
theexploration doesnot terminate. Toaddress thethreat that our
resultsmaybevalidonlyfortheDFSsearchheuristic,weperformed
anadditionalexperimentusingthedefaultsearchheuristicinKLEE.
The results, shownin[ 53,Section C.4], are comparable.
7.8 Discussion
Takingahigh-levelviewoftheexperiments,weobservethatour
approachbringssigni/f_icantgainsw.r.t.bothbaselinesinmostofthe
benchmarks( libosip,wget,apr,json-c,andbusybox).Thisisbecause
these benchmarks contain an abundant number of size-dependent
loops that generate expressions that are linearly dependent on the
numberofrepetitivepartsinthepathconstraints,whichleadsto
the detection of many regular (and formula) patterns. In libtasn1
andlibpng, however, most of the size-dependent loops generate
expressions that cannot be synthesized with our approach, for
example, aggregate values such as the sum of array contents. As a
result,relativelyfewformulapatternsaredetected.Nevertheless,
in these cases, our approach still preserves the bene/f_its of standard
state mergingw.r.t. standardsymbolic execution.
8 RELATED WORK
Compact symbolic execution [ 50] uses quanti/f_iers to encode the
path conditions of cyclic paths that follow the samecontrol /f_low
pathineachiterationandupdateallthevariablesinaregularman-
ner.Thisallowsthemtoencodetheeï¬€ectofunboundedrepetitions
ofsomeof the cyclic paths in the program. In contrast, we seek
regularity at the level of the constraints and, therefore, do not rely
on uniformity in the control /f_low graph.In memspn(Section1), for
example, they can only summarize the paths in which either all
thecharactersof sarematchedwiththe/f_irstcharacterof chars
(the then branch) or the /f_irst character of sis unmatched (the
else branch). In contrast, our approach can summarize allpaths
up to a given bound using two merged states. Furthermore, [ 50]solves quanti/f_ied queries using a standard solver as opposed to our
specializedsolving procedure.
Godefroidetal.[ 32]proposeadynamicapproach forinferring
invariantsininput-dependentloops,whichallowsthemtopartially
summarize the loopâ€™s eï¬€ect on induction variables. Loop-extended
symbolicexecution[ 46]summarizesinput-dependentloops.Ituses
staticanalysistoinferlinearrelationsbetweenvariablesandtrip
count variables tracking the number of iterations in the loop. In
contrast,ourapproachdoes notrelyoninduction variablesorthe
numberof loopiterations. Kapus et al.[ 35] summarize stringloops
by synthesizing calls to standard string functions. S-Looper [ 55]
introduces string constraints that can be solved by solvers that
support thestringtheory. Ourapproach is not restrictedtostring
loopsanddoes not require asolver supportingstringtheory.
Veritesting [ 13] improves the performance of symbolic execu-
tion by merging similar execution paths. Given a symbolic branch,
veritestingsummarizessideeï¬€ectsfrombothbranchsidestoavoid
path explosion. Java Ranger [ 49] extends veritesting of Java pro-
grams to support dynamically dispatched methods, by using the
runtime information available during the analysis. MultiSE [ 48]
summarizes updates to values by eï¬ƒciently guarding each value
withapathpredicate.Kuznetsovetal.[ 37]mergesymbolicstates
based on a query count heuristic that estimates if the merging
would reduce the solving time in the future. Trabish et al. [ 52]
perform state merging in loops that depend on objects whose size
issymbolic.Theyreducethesizeoftheencodingintheresulting
mergedstatesusingtheexecutiontree,butstillrelyondisjunctions
anditeexpressions,thereforeunabletoachievethereductionob-
tainedwithourapproach.Weexplicitlycomparedourtechnique
with theirs (referred to as CFGin Section 7) and show that our
approach performs better in many cases. The works mentioned
above do not address the encoding explosion problem caused by
using disjunctionsand iteexpressions.
There are many works on handling quanti/f_ied formulas [ 14,
16,23,27,30,43â€“45]. Our solving procedure (Section 5) mainly
targetssatis/f_iablequeries,andadaptsideasfromE-matching[ 23]
and model-based quanti/f_ier instantiation [ 30] to our speci/f_ic needs.
9 CONCLUSIONSAND FUTUREWORK
Weproposeastatemergingapproachthatsigni/f_icantlyreducesthe
encoding complexity of merged symbolic states and show through
our evaluation that this is a promising direction toward scaling
state merginginsymbolic execution.
Ourapproachautomaticallydetectsregularpatternstopartition
similar symbolic states into merging groups. For each group, we
synthesize a formula pattern that enables an eï¬ƒcient encoding
of the merged symbolic state using quanti/f_iers. Extracting more
complexpatterns,e.g.,beyondlinearformulas,canfurtherimprove
the applicabilityofour approach.
Acknowledgements. This research was partially funded by the
Israel Science Foundation (ISF) grants No. 1996/18 and No. 1810/18
andbyLen Blavatnik andthe Blavatnik Familyfoundation.
10 DATA AVAILABILITY
Our replication package is available at [ 3]. It contains a Docker
imagewithallthe resourcesneededto run the experiments.
1150ESEC/FSE â€™23, December3â€“9, 2023,San Francisco, CA, USA David Trabish, Noam Rinetzky, SharonShoham, andVaibhav Sharma
REFERENCES
[1] 2023. https://github.com/davidtr1037/klee-quanti/f_iers .
[2] 2023. https://github.com/klee/klee-uclibc/pull/47 .
[3] 2023. https://doi.org/10.6084/m9./f_igshare.21990386.v8 .
[4] 2023. busybox. https://busybox.net/ .
[5] 2023. GCov. https://gcc.gnu.org/onlinedocs/gcc/Gcov.html .
[6] 2023. GNU libtasn1. https://www.gnu.org/software/libtasn1/ .
[7] 2023. GNU oSIP. https://www.gnu.org/software/osip/ .
[8] 2023. GNU Wget. https://www.gnu.org/software/wget/ .
[9] 2023. json-c. https://github.com/json-c/json-c/ .
[10] 2023. libpng. http://www.libpng.org/pub/png/libpng.html .
[11]AlfredV.Aho,MonicaS.Lam,RaviSethi,andJeï¬€reyD.Ullman.2006. Compilers:
Principles, Techniques, and Tools (2nd ed.). AddisonWesley.
[12] APR. 2023. ApachePortable Runtime .
[13]Thanassis Avgerinos, Alexandre Rebert, Sang Kil Cha, and David Brumley. 2014.
Enhancing Symbolic Execution with Veritesting. In Proc. of the 36th International
ConferenceonSoftwareEngineering(ICSEâ€™14) (Hyderabad,India). https://doi.org/
10.1145/2568225.2568293
[14]KshitijBansal,AndrewReynolds,TimKing,ClarkBarrett,andThomasWies.2015.
Deciding local theory extensions via e-matching. In Computer Aided Veri/f_ication:
27th International Conference, CAV 2015, San Francisco, CA, USA, July 18-24, 2015,
Proceedings,Part II 27 . Springer, 87â€“105.
[15]Haniel Barbosa, Clark W. Barrett, Martin Brain, Gereon Kremer, Hanna Lachnitt,
MakaiMann,AbdalrhmanMohamed,MudathirMohamed,AinaNiemetz,Andres
NÃ¶tzli, Alex Ozdemir, Mathias Preiner, Andrew Reynolds, Ying Sheng, Cesare
Tinelli, and Yoni Zohar. 2022. cvc5: A Versatile and Industrial-Strength SMT
Solver. In Tools and Algorithms for the Construction and Analysis of Systems -
28th International Conference, TACAS 2022, Held as Part of the European Joint
ConferencesonTheoryandPracticeofSoftware,ETAPS2022,Munich,Germany,
April2-7,2022,Proceedings,PartI ,DanaFismanandGrigoreRosu(Eds.).Springer.
https://doi.org/10.1007/978-3-030-99524-9_24
[16]Aaron R Bradley, Zohar Manna, and Henny B Sipma. 2006. Whatâ€™s decidable
about arrays?. In International Workshop on Veri/f_ication, Model Checking, and
AbstractInterpretation . Springer, 427â€“442. https://doi.org/10.1007/11609773_28
[17]Tegan Brennan, Seemanta Saha, Tev/f_ik Bultan, and Corina S PÄƒsÄƒreanu. 2018.
Symbolic path cost analysis for side-channel detection. In Proceedings of the 27th
ACM SIGSOFT International Symposium on Software Testing and Analysis . 27â€“37.
https://doi.org/10.1145/3213846.3213867
[18]Robert Brotzman, Shen Liu, Danfeng Zhang, GangTan, andMahmut Kandemir.
2019. CaSym:Cacheawaresymbolicexecutionforsidechanneldetectionand
mitigation.In 2019 IEEESymposiumonSecurity andPrivacy (SP) . IEEE, 505â€“521.
https://doi.org/10.1109/SP.2019.00022
[19]Cristian Cadar, Daniel Dunbar, and Dawson Engler. 2008. KLEE: Unassisted
and Automatic Generation of High-Coverage Tests for Complex Systems Pro-
grams.In Proc.ofthe8thUSENIXSymposiumonOperatingSystemsDesignand
Implementation(OSDIâ€™08) (SanDiego, CA, USA).
[20]CristianCadar, VijayGanesh, Peter Pawlowski, David Dill,and Dawson Engler.
2006. EXE: AutomaticallyGeneratingInputsof Death.In Proc. ofthe 13thACM
Conference on Computer and Communications Security (CCSâ€™06) (Alexandria, VA,
USA).https://doi.org/10.1145/1455518.1455522
[21]Cristian Cadar and Koushik Sen. 2013. Symbolic Execution for Software Testing:
Three Decades Later. Commun. ACM 56, 2 (Feb. 2013), 82â€“90. https://doi.org/10.
1145/2408776.2408795
[22]PeterCollingbourne,CristianCadar,andPaulH.J.Kelly.2011. SymbolicCross-
checkingofFloating-PointandSIMDCode.In Proc.ofthe6thEuropeanConference
onComputerSystems(EuroSysâ€™11) (Salzburg,Austria). https://doi.org/10.1145/
1966445.1966475
[23]Leonardo de Moura and Nikolaj BjÃ¸rner. 2007. Eï¬ƒcient E-Matching for SMT
Solvers.In AutomatedDeductionâ€“CADE-21 ,FrankPfenning(Ed.).SpringerBerlin
Heidelberg, Berlin, Heidelberg, 183â€“198.
[24]LeonardodeMouraandNikolajBjÃ¸rner.2008. Z3:AnEï¬ƒcientSMTSolver.In
ToolsandAlgorithms fortheConstruction and Analysis ofSystems ,C. R.Ramakr-
ishnanandJakobRehof(Eds.).SpringerBerlinHeidelberg,Berlin,Heidelberg,
337â€“340.
[25]LeonardodeMouraandNikolajBjÃ¸rner.2008.Z3:AnEï¬ƒcientSMTSolver.In Proc.
of the 14th International Conference on Tools and Algorithms for the Construction
and AnalysisofSystems(TACASâ€™08) (Budapest,Hungary).
[26]Leonardo De Moura and Nikolaj BjÃ¸rner. 2011. Satis/f_iability modulo theories:
introductionandapplications. Commun.ACM 54,9(2011),69â€“77. https://doi.
org/10.1145/1995376.1995394
[27]David Detlefs, Greg Nelson, and James B Saxe. 2005. Simplify: a theorem prover
for programchecking. Journal ofthe ACM(JACM) 52,3 (2005), 365â€“473.
[28]BrunoDutertre.2014. Yices2.2.In Proc.ofthe26thInternationalConferenceon
Computer-AidedVeri/f_ication (CAVâ€™14) (Vienna, Austria).
[29]Vijay Ganesh and David L. Dill. 2007. A Decision Procedure for Bit-vectors and
Arrays. In Proceedings of the 19th International Conference on Computer AidedVeri/f_ication (Berlin,Germany) (CAVâ€™07).Springer-Verlag,Berlin,Heidelberg,519â€“
531.http://dl.acm.org/citation.cfm?id=1770351.1770421
[30]Yeting Ge and Leonardo MendonÃ§a de Moura. 2009. Complete Instantiation
forQuanti/f_iedFormulasinSatis/f_iabilibyModuloTheories.In ComputerAided
Veri/f_ication,21stInternationalConference,CAV2009,Grenoble,France,June26-
July2,2009.Proceedings (LectureNotesinComputerScience,Vol.5643) ,Ahmed
Bouajjani andOdedMaler (Eds.).Springer,306â€“320. https://doi.org/10.1007/978-
3-642-02658-4_25
[31]Patrice Godefroid, Michael Y. Levin, and David A. Molnar. 2008. Automated
Whitebox Fuzz Testing. In Proc. of the 15th Network and Distributed System
SecuritySymposium(NDSSâ€™08) (SanDiego, CA, USA).
[32]Patrice Godefroid and Daniel Luchaup. 2011. Automatic Partial Loop Sum-
marization in Dynamic Test Generation. In Proc. of the International Sympo-
sium on Software Testing and Analysis (ISSTAâ€™11) (Toronto, Canada). https:
//doi.org/10.1145/2001420.2001424
[33]Trevor Hansen, Peter Schachte, and Harald SÃ¸ndergaard. 2009. State Joining
and Splitting for the Symbolic Execution of Binaries. In Proc. of the 2009 Runtime
Veri/f_ication (RVâ€™09) (Grenoble, France). https://doi.org/10.1007/978-3-642-04694-
0_6
[34]WeiJinandAlessandroOrso.2012. BugRedux:ReproducingFieldFailuresfor
In-house Debugging. In Proc. of the 34th International Conference on Software
Engineering(ICSEâ€™12) (Zurich,Switzerland). https://doi.org/10.1109/ICSE.2012.
6227168
[35]Timotej Kapus, Oren Ish-Shalom, Shachar Itzhaky, Noam Rinetzky, and Cristian
Cadar. 2019. Computing Summaries of String Loops in C for Better Testing
andRefactoring.In Proc.oftheConferenceonProgramingLanguageDesignand
Implementation(PLDIâ€™19) (Phoenix,AZ,USA). https://doi.org/10.1145/3314221.
3314610
[36]James C. King. 1976. Symbolic execution and program testing. Communications
ofthe Associationfor ComputingMachinery(CACM) 19,7 (1976), 385â€“394.
[37]Volodymyr Kuznetsov, Johannes Kinder, Stefan Bucur, and George Candea. 2012.
Eï¬ƒcient state merging in symbolic execution. In Proc. of the Conference on
Programing Language Design and Implementation (PLDIâ€™12) (Beijing, China).
https://doi.org/10.1145/2345156.2254088
[38]Chris Lattner and Vikram Adve. 2004. LLVM: A Compilation Framework for
LifelongProgram Analysis& Transformation.In Proc.ofthe 2ndInternational
Symposium on Code Generation and Optimization (CGOâ€™04) (Palo Alto, CA, USA).
https://doi.org/10.1109/CGO.2004.1281665
[39]Sergey Mechtaev, Jooyong Yi, and Abhik Roychoudhury. 2016. Angelix: Scalable
multiline program patch synthesisvia symbolic analysis. In Proceedingsofthe
38th international conference on software engineering . ACM, 691â€“701. https:
//doi.org/10.1145/2884781.2884807
[40]Hoang Duong Thien Nguyen, Dawei Qi, Abhik Roychoudhury, and Satish Chan-
dra. 2013. SemFix: Program Repair via Semantic Analysis. In Proc. of the 35th
InternationalConferenceonSoftwareEngineering(ICSEâ€™13) (SanFrancisco,CA,
USA).https://doi.org/10.1109/ICSE.2013.6606623
[41] CorinaSPasareanu,Quoc-SangPhan,andPasqualeMalacaria.2016. Multi-run
side-channelanalysisusingSymbolicExecutionandMax-SMT.In 2016IEEE29th
Computer SecurityFoundationsSymposium(CSF) . IEEE,387â€“400.
[42]Corina S. PÄƒsÄƒreanu, Willem Visser, David Bushnell, Jaco Geldenhuys, Peter
Mehlitz, and Neha Rungta. 2013. Symbolic PathFinder: Integrating Symbolic
Execution withModel Checking for Java BytecodeAnalysis.In Proc.ofthe28th
IEEE International Conference on Automated Software Engineering (ASEâ€™13) (Palo
Alto, CA, USA).
[43]AndrewReynolds,HanielBarbosa,andPascalFontaine.2018. Revisitingenumer-
ativeinstantiation.In ToolsandAlgorithmsfortheConstructionandAnalysisof
Systems: 24th International Conference, TACAS 2018, Held as Part of the European
JointConferencesonTheoryandPracticeofSoftware,ETAPS2018,Thessaloniki,
Greece,April14-20, 2018, Proceedings,Part II 24 . Springer, 112â€“131.
[44]AndrewReynolds,CesareTinelli,andLeonardoDeMoura.2014. Findingcon-
/f_licting instances of quanti/f_ied formulas in SMT. In 2014 Formal Methods in
Computer-AidedDesign(FMCAD) . IEEE,195â€“202.
[45]AndrewReynolds,CesareTinelli,AmitGoel,SavaKrstiÄ‡,MorganDeters,and
Clark Barrett. 2013. Quanti/f_ier instantiation techniques for /f_inite model /f_inding
in SMT. In Automated Deductionâ€“CADE-24: 24th International Conference on Au-
tomatedDeduction,LakePlacid,NY,USA,June9-14,2013.Proceedings24 .Springer,
377â€“391.
[46]Prateek Saxena, Pongsin Poosankam, Stephen McCamant, and Dawn Song. 2009.
Loop-extended SymbolicExecution on BinaryPrograms. In Proc. ofthe Interna-
tional Symposium on Software Testing and Analysis (ISSTAâ€™09) (Chicago, IL, USA).
https://doi.org/10.1145/1572272.1572299
[47]DanielSchemmel,JulianBÃ¼ning,FrankBusse,MartinNowack,andCristianCadar.
2022. ADeterministicMemoryAllocatorforDynamicSymbolicExecution.In
36th European Conference on Object-Oriented Programming (ECOOP 2022) (Berlin,
Germany).9:1â€“9:26.
[48]Koushik Sen, George Necula, Liang Gong, and Wontae Choi. 2015. MultiSE:
Multi-Path Symbolic Execution Using Value Summaries. In Proceedings of the
201510thJointMeetingonFoundationsofSoftwareEngineering (Bergamo,Italy)
1151StateMerging with/Q_uantifiersin SymbolicExecution ESEC/FSE â€™23, December3â€“9, 2023,San Francisco, CA, USA
(ESEC/FSE 2015) . Association for Computing Machinery, New York, NY, USA,
842â€“853. https://doi.org/10.1145/2786805.2786830
[49]VaibhavSharma,SohaHussein,MichaelW.Whalen,StephenMcCamant,and
WillemVisser.2020. JavaRanger:StaticallySummarizingRegionsforEï¬ƒcient
Symbolic Execution of Java. In Proceedings of the 28th ACM Joint Meeting on
European Software Engineering Conference and Symposium on the Foundations
of Software Engineering (Virtual Event, USA) (ESEC/FSE 2020) . Association for
ComputingMachinery,NewYork,NY,USA,123â€“134. https://doi.org/10.1145/
3368089.3409734
[50]Jiri Slaby, Jan Strejcek,and MarekTrtÃ­k. 2013. Compact Symbolic Execution. In
AutomatedTechnologyforVeri/f_icationandAnalysis-11thInternationalSymposium,
ATVA 2013, Hanoi, Vietnam, October 15-18, 2013. Proceedings (Lecture Notes in
ComputerScience,Vol.8172) ,DangVanHungandMizuhitoOgawa(Eds.).Springer,
193â€“207. https://doi.org/10.1007/978-3-319-02444-8_15
[51]Aaron Stump, Clark W. Barrett, David L. Dill, and Jeremy R. Levitt. 2001. A
DecisionProcedureforanExtensionalTheoryofArrays.In Proc.ofthe16thIEEESymposiumonLogicinComputer Science(LICSâ€™01) (Boston, MA,USA).
[52]DavidTrabish,ShacharItzhaky,andNoamRinetzky.2021. ABoundedSymbolic-
Size Model for Symbolic Execution. In Proceedings of the 29th ACM Joint Meeting
on European Software Engineering Conference and Symposium on the Foundations
ofSoftwareEngineering .AssociationforComputingMachinery,NewYork,NY,
USA,1190â€“1201. https://doi.org/10.1145/3468264.3468596
[53]DavidTrabish,NoamRinetzky,SharonShoham,andVaibhavSharma.2023. State
Merging with Quanti/f_iersin SymbolicExecution. arXiv: arXiv:2308.12068
[54] uClibc2022. uClibc. https://www.uclibc.org/ .
[55]XiaofeiXie,YangLiu,WeiLe,XiaohongLi,andHongxuChen.2015. S-looper:
AutomaticSummarizationforMultipathStringLoops.In Proc.oftheInternational
SymposiumonSoftwareTestingand Analysis(ISSTAâ€™15) (Baltimore, MD, USA).
Received 2023-02-02; accepted 2023-07-27
1152