Use of Test Doubles in Android Testing:
An In-Depth Investigation
Mattia Fazzini‚àó, Chase Choi‚àó, Juan Manuel Copia‚Ä†, Gabriel Lee‚àó,
Yoshiki Kakehi‚Ä°, Alessandra Gorla‚Ä†, Alessandro Orso‚Ä°
‚àóUniversity of Minnesota, Minneapolis, MN, USA; mfazzini@umn.edu, choix698@umn.edu, gnlee@umn.edu
‚Ä†IMDEA Software Institute, Madrid, Spain; juanmanuel.copia@imdea.org, alessandra.gorla@imdea.org
‚Ä°Georgia Institute of Technology, Atlanta, GA, USA; yoshikikakehi@gatech.edu, orso@cc.gatech.edu
ABSTRACT
Androidappsinteractwiththeirenvironmentextensively,which
canresultinflaky,slow,orhard-to-debugtests.Developersoftenad-
dress these problems using test doubles‚Äîdeveloper-defined objects
that replace app or library classes during test execution. Although
testdoubles are widelyused,there islimitedunderstanding ofhow
theyareusedinpractice.Tobridgethisgap,wepresentanin-depth
empiricalstudythataimstoshedlightonhowdeveloperscreate
andusetestdoublesinAndroidapps.Inourstudy,wefirstanalyzeadatasetof1,006appswithpubliclyavailabletestsuitestoidentify
which frameworks and approaches developers most commonly use
tocreatetestdoubles.Wetheninvestigateseveralresearchques-tions by studying how test doubles defined using these popular
frameworksarecreatedandusedinthetenappsinthedatasetthat
define the highest number of test doubles using these frameworks.
Our results, based on the analysis of 2,365 test doubles that replace
a total of 784 classes, provide insight into the types of test doubles
used within Android apps and how they are utilized. Our resultsalso show that test doubles used in Android apps and traditional
Java test doubles differ in at least some respect. Finally, our results
show that test doubles can introduce test smells and even mistakes
in the test code. In the paper, we also discuss some implications of
ourfindingsthatcanhelpresearchersandpractitionersworkingin
this area and guide future research.
CCS CONCEPTS
‚Ä¢Softwareanditsengineering ‚ÜíSoftwaretestinganddebug-
ging.
KEYWORDS
Test mocking, mobile apps, software environment
ACM Reference Format:
MattiaFazzini‚àó,ChaseChoi‚àó,JuanManuelCopia‚Ä†,GabrielLee‚àó,,Yoshiki
Kakehi‚Ä°,AlessandraGorla‚Ä†,AlessandroOrso‚Ä°.2022.UseofTestDoublesin
AndroidTesting:AnIn-DepthInvestigation.In 44thInternationalConference
on Software Engineering (ICSE ‚Äô22), May 21‚Äì29, 2022, Pittsburgh, PA, USA.
ACM,NewYork,NY,USA,13pages.https://doi.org/10.1145/3510003.3510175
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACMmustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA
¬© 2022 Association for Computing Machinery.
ACM ISBN 978-1-4503-9221-1/22/05...$15.00
https://doi.org/10.1145/3510003.35101751 INTRODUCTION
Most Android apps have rich interactions with their environment.
Android devices, for instance, provide built-in motion, location
information, and position sensors that apps can use to offer a rich
setoffeaturestousers.Ingeneral,appsinterfacewithexternalweb
services,theunderlyingAndroidsystem,third-partylibraries,as
well as content providers exposed by the device. Such extensive
interactions complicate the testing of an app, as exploring specific
behaviors may require complex configurations of the environment,
and test execution may become slow and result in flakiness.
To mitigate these issues, developers can rely on test doubles
(TDs)‚Äîclasses that mimic the structure of other classes but offer
alternative implementations that are fully controlled by the devel-
operforthepurposeoftesting.InthecontextofAndroidapps,TDs
canreplaceclassesdefinedintheappitself,classesfromtheJava
library,classesdefinedinthird-partylibraries,andclassesfromthe
Androidframework.Furthermore,dependingontheirpurpose,TDs
maybeclassifiedasfollows:(i) dummies,whichareoftenusedto
simplyfill-inparametersthataremeaninglessforaspecifictest;(ii)
stubs,whicharesimpleobjectsthatreturnhard-codedvalueswhen
their methods are invoked; (iii) mocksandspies, which are more
complexobjectsthatcanverifyinteractionswithotherclasses;and
(iv)fakes, which consist of partially working implementations that
are more efficient than the actual class(es) they are replacing.
Because creating and maintaining TDs can involve considerable
manual effort, researchers have started investigating techniques to
supportdevelopersinthistask(e.g.,[ 1‚Äì5]).Unfortunately,however,
there is limited understanding of how TDs are used in practice,
whichhindersourabilitytodefineeffectivetechniquesinthisspace.
SeveralpreviousempiricalstudiesaimedtoidentifygeneraltestingpracticesinthedevelopmentofAndroidapps[
6‚Äì11],buttheyeither
ignored or didnot specifically focus onTDs. Other related studies
analyzed howJava developers use mockswhen testing traditional
(i.e.,non-mobile)software[ 12‚Äì14].However,someoftheirfindings
may not directly apply to Android apps, or new findings might
arise from the peculiarities of the Android platform.
Tobridgethisgap,wepresentanin-depthstudyofhowdevelop-
ers create and use TDs when developing and testing Android apps.
Specifically,thegoalofourstudyis to getabetter understanding
of(1)howTDsareusedintheAndroidecosystem,and(2)whether
TDs developed for Android apps differ from traditional TDs.
In our study, we first analyzed a dataset of 1,006 apps with pub-
licly available test suites to collect information on the frameworks
andapproachesusedtocreateTDs.ThisanalysisshowsthatMock-
itoandMockito-Kotlinarethemostpopularframeworksforcre-ating TDs, with 33.5% of the apps in the dataset using either one
22662022 IEEE/ACM 44th International Conference on Software Engineering (ICSE)
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:59:42 UTC from IEEE Xplore.  Restrictions apply. ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USAMattia Fazzini‚àó, Chase Choi‚àó, Juan Manuel Copia‚Ä†, Gabriel Lee‚àó,
Yoshiki Kakehi‚Ä°, Alessandra Gorla‚Ä†, Alessandro Orso‚Ä°
of these two frameworks. We then investigated several research
questions by studying how TDs defined using these popular frame-
worksarecreatedandusedinthetenappsinthedatasetthatdefine
the highest number of TDs using these frameworks.
Our results, based on the analysis of 2,365 TDs that replace a
totalof784classes,provideinsightonthetypesofTDsusedwithin
Androidappsandhowtheyareutilized.Inparticular,theyshow
thatdeveloperscreateTDstoreplacebothclassesintheappand
external classes, and that different kinds of TDs are indeed cre-
ated,includingstubs,mocks,anddummies.Ourresultsalsoshow
thatTDsusedfortestingappsdifferinatleastsomerespectfrom
TDs used in traditional Java software. Specifically, our study found
that there are different categories of TDs that are prevalent in this
context, namely, TDs replacing classes in the Android framework,
configuration classes, and GUI components. Whereas the first cate-
gory is not surprising, the latter two provide evidence that, within
Android apps, configurations are more common and classes are
more tightly coupled with GUI elements than in traditional Java
software. Finally, our results show that TDs can introduce test
smells and even mistakes in test code, which motivates developing
techniques to detect and eliminate these problems.
Contributions and Significance. To the best of our knowl-
edge, this isthe first studythat classifies how developersuse TDs,
categorizingthembasedontheirpurposeandthroughbothqualita-tiveandquantitativeanalyses.Webelievethatourfindingsandtheirimplicationscaninformfutureresearchinthisareaandhelpdefine
automated or semi-automated techniques for better supportingdevelopers in creating and maintaining TDs, ultimately improv-ing the process of testing Android apps. Furthermore, our study
infrastructure and experimental data are publicly available [15].
2 BACKGROUND
AndroidappsandtheirtestsaremainlywrittenintheJavaorKotlin
programming languages [ 10]. These tests can run on either the
JVM (JVM tests) or a device (device tests ). Generally, JVM tests can
include unit and integration tests, while device tests can includeunit, integration, system, and GUI tests [
10,16]. Both JVM and
devicetestscanuseTDstofacilitatetestingactivities1.Wedefinea
TDasadeveloper-definedobjectthatprovidesa(possiblypartial)
replacementforaclassintheapporinanexternallibraryduring
testing. Within Android apps, TDs can replace classes defined in
the app, classes from the Java library, classes defined in third-party
libraries, and classes from the Android framework. Based on thefunctionality that the TDs provide to the test code, they can beclassified [
17,18] into five main types: (i) dummies, (ii) stubs, (iii)
mocks, (iv) spies, and (v) fakes. App developers can create TDs
using test mocking2frameworks or by extending/implementing
classes/interfaces.Amongtheframeworksthatallowforcreating
TDs,therearebothgeneric(e.g.,Mockito[ 19],Mockito-Kotlin[ 20],
PowerMock[ 21])andspecialized(e.g.,OkHttp[ 22],Retrofit[ 23],
1In this work, we discuss TDs of JVM and device tests, as this grouping is readily
available through the source code of Android apps‚Äîgenerally, JVM tests are in the
testfolderanddevicetestsareinthe androidTest folder.Weleaveasfuturework
theanalysisofTDsinrelationtohowJVManddevicetestscanbedividedintounit,
integration, system, and GUI tests.
2Althoughtheseframeworksareinformallycalled mockingframeworks,developers
actually use the frameworks to create different types of TDs.Android Test Mock [ 24]) test mocking frameworks. The former
allowforreplacingclassesofvaryingfunctionality,whilethelatter
target classes offering a specific functionality (e.g., classes that
connecttoawebserver).WenowdescribehowdeveloperscanusegenerictestmockingframeworkstocreateTDsandthensummarize
the characteristics of the different types of TDs.
2.1 Generic Test Mocking Frameworks
When developers create a TD usinga generic test mocking frame-
work,theymustfirstspecifytheclassbeingreplacedbytheTD.To
thisend,developerscanuseinitializationmethodsorannotations
provided by the framework API (e.g., the mockmethod from the
MockitoAPI[ 25]).Afterthisstep,developerscandefinestubbed
methodimplementationsfortheTDandspecifywhichmethodcalls
madetotheTDshouldbeverifiedduringtestexecution.Tostuba method, developers must specify (i) the method that should be
stubbed,(ii)theargumentstowhichthestubbedmethodshouldre-spond,and(iii)thevalue/exceptionreturnedbythestubbedmethod.
GenerictestmockingframeworksofferAPImethodsthatcanbe
combined to implement this functionality. For example, developers
can use when(td.m(arg)).thenReturn(val) (based on the Mockito
API) to specify that the TD tdshould return valwhen the method
mis called with argument argon the object. Developers can also
usetheframeworkAPItospecifythemethodcallsthatshouldbe
verified.Forexample,developerscanuse verify(td).m(arg) (based
on theMockito API)to checkthat (1)method mwas calledduring
test execution on the object tdand (2) the argument passed to the
methodwas arg.Finally,developerscanusetheAPIsoftheseframe-
workstocreatedifferenttypesofTDs.Inourwork,thetypeofa
TD is not identified by the API method used to create it (e.g., mock
in Mockito), but rather by the functionality it provides.
2.2 Test Doubles Types
Thissectionreportsthedefinitionsweusetocharacterizethedif-
ferent types of TDs, as formulated in related work [ 17,18]. Due to
space limitations, we do not provide here code examples for the
differenttypesbutmakethemavailableinouronlineappendix[ 15].
Dummy: A dummy is an object that a test uses to exercise the
componentundertest(CUT)butsuchthatneitherthetestcodenor
the CUT access the object‚Äôs state during test execution. Tests tend
tousedummiestoprovidemethodparametersthatareirrelevant
for a specific test.Stub:
Astubisanobjectprovidinghard-coded(i.e.,stubbed)an-
swers when its callers invoke the object‚Äôs methods during test
execution.Astubmightprovidehard-codedanswersonlyforsome
ofitsmethods,andtheanswersareoftenspecifictotheintentof
the particular test using the stub.Mock:
A mock is an object that offers a replacement for a class
and suchthat some of theinteractions with theobject are verified
during test execution. The verification task is defined in the test
code but carried out within the mock object. A mock object might
also provide hard-coded answers for some of its methods.Spy:
A spy is similar to a mock object in that some of the interac-
tionswiththeobjectareverifiedduringtestexecution.However,
differentlyfromamockobject,theprimaryoperationsforverifying
the behavior of the spy are defined in the test code, rather than
2267
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:59:42 UTC from IEEE Xplore.  Restrictions apply. Use of Test Doubles in Android Testing:
An In-Depth Investigation ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA
within the TD. Usually, these operations are encoded as developer-
defined assertstatements.Asinthecaseofamockobject,aspy
might also provide hard-coded answers for some of its methods.
It is worth noting that this definition is consistent with related
work [17,18] but differs from the use of the term within Mock-
ito[19].Specifically,inMockito,aspyisanobjectforwhichreal
method implementations are invoked during test execution unless
they are stubbed. Because the two definitions focus on different
aspects,ourfindingsshouldnotbedirectlymappedtoMockito‚Äôs
spiesand shouldbe insteadinterpreted basedon thefunctionality
provided by the TD.Fake:
A fake is an object that provides a working implementation
for some of its methods but such that the implementation is made
more efficient through ‚Äúshortcuts‚Äù not suitable for production.
3 METHODOLOGY
ToshedlightonhowAndroiddeveloperscreateanduseTDs,we
investigated the following research questions (RQs):
‚Ä¢RQ1: Which frameworks and approaches are most com-
monly used to create TDs? This RQ aims to identify the most
commonly used frameworks and approaches for creating TDs in
thedomainofAndroidapps.WeusethefindingsfromthisRQ
to scope the analyses of the remaining RQs.
‚Ä¢RQ2:WhattypesofclassesdodevelopersreplacewithTDs?
ThegoalofthisRQistocategorizethetypesofclassesthatare
commonlyreplacedbyTDs.IntheRQ,wealsoprovideadetailed
analysisoftheAndroidframeworkclassesthatarereplacedby
TDs.
‚Ä¢RQ3:What TDtypes dodeveloperscreate? ThisRQ investi-
gatesthetypesofTDsusedinthecontextofAndroidapptesting.
This RQ also analyzes whether developers use different types of
TDs for different types of classes.
‚Ä¢RQ4: How do tests use TDs? While RQ2 and RQ3 characterize
TDs through a manual inspection of the code associated with
TDs, this RQ aims to characterize the runtime properties of TDs.
Specifically,itinvestigateshowtestsusestubbedmethodsand
how often interactions with TDs are verified.
‚Ä¢RQ5:WhatproblemscanTDsintroduce? BecauseTDsare
usuallymanually-created,theymayintroducetestsmellsoreven
errorsinthetestcode.ThisRQinvestigatesissuesemergingfrom
the use of TDs.
The overall goal of these RQs is to inform researchers and prac-
titioners and provide insights that can guide them in developing
techniquesandtoolsforcreating,using,andmaintainingTDs.To
answer our RQs, we divided our study into two parts. First, we
identifiedwhichframeworksandapproachesdevelopersmostcom-
monly use to create TDs (RQ1). Then, we studied how the TDsdefined with the most popular frameworks and approaches are
createdandused(RQ2,RQ3,RQ4andRQ5).Therestofthissection
describesthequalitativeandquantitativeanalysesweperformed
to answer the RQs.
3.1 Frameworks and Approaches for TDs
Inthissection,wedescribeourmethodologyforansweringRQ1.
Specifically,wedescribethedatasetweused,theframeworksand
approaches we considered, and the analysis we performed.3.1.1 Dataset. To answer RQ1, we needed a dataset containing
Android apps with a publicly available test suite. To the best of our
knowledge,thedatasetreleasedbyLinandcolleagues[ 10]isthe
most recent one satisfying this requirement, as it contains 1,002
appswithtests.TheseappswereminedfromGitHub,andeachappis available on at least oneof 16 app markets (including the Google
Playstore[ 26]).Whenweclonedtheapprepositories,972ofthe
1,002 apps were still available on GitHub. To ensure our dataset
doesnotincludepossiblytrivialapps,wefurtherfilteredthedataset
to only contain apps available on the Google Play store. After this
step, the dataset contained 886 apps.
Weperformedasanitychecktoverifythattheappshavetestsin
their testand androidTest directories,whicharethedefaultloca-
tions used to store JVM and device tests [ 16], respectively. For this
purposewebuiltanautomatedanalysisontopofJavaParser[ 27]
and ktlint [ 28] to traverse the abstract syntax tree (AST) of the
test files looking for methods annotated with @Test,@SmallTest ,
@MediumTest ,@LargeTest ,o r @UiThreadTest ; we classified a test as
any method having any of these annotations. Note that, by op-erating at the AST level, the analysis avoids considering tests incommented code. The analysis also excludes tests automaticallycreated by Android Studio, which can be identified based on thename convention used by the IDE. Our analysis identified someapps without any meaningful test. Manual inspection confirmed
that,atthetimeweretrievedthem,thoseappshadnotestsatall,
had tests that had been commented out, or only had tests automat-
icallycreatedbyAndroidStudio.Afterremovingtheseapps,833
apps remained in the dataset.
After manually inspecting the list of remaining apps, we ob-
servedthatcertainwidelyusedapps,suchasAnkiDroid[ 29,30]
(overfivemilliondownloads),werenotpresentinthedatasetde-
spitebeingavailableinthecuratedlistofopen-sourceappsprovidedbyF-Droid[
31],whichwasconsideredin[ 10].Wenoticedthatthese
apps have multiple AndroidManifest.xml files [32], and that apps
with these characteristic were excluded by Lin and colleagues [ 10].
Therefore, to avoid missing relevant apps, we decided to add apps
(i) listed on F-Droid, (ii) available on GitHub, (iii) present on the
GooglePlay store,and (iv)having meaningfultests. Thisresultedintheadditionof173appstothedataset,foratotalof1,006apps.
We used this dataset to answer RQ1.
3.1.2 Frameworks and Approaches Considered. In RQ1, we investi-
gated how oftendevelopers create TDs (1) usingeither generic or
specialized test mocking frameworks, or (2) extending/implement-
ingclasses/interfaces.Toensureweconsideredacomprehensive
setofrelevantframeworks,weperformedaGooglesearchusing
‚Äúandroidtestmocking ‚Äù3asthesearchtermsandanalyzedthefirst
100 results. Our online appendix [ 15] contains the complete search
results. Based on the search results, we considered the generic test
mocking frameworks EasyMock [ 33], jMock [ 34], Mockito [ 19],
Mockito-Kotlin[ 20],MockK[ 35],andPowerMock[ 21],whichall
allow for creating TDs as described in Section 2.
WealsoconsideredAndroidTestMock[ 24],MockServer[ 36],
OkHttp[22],Retrofit[ 23],Robolectric[ 37],andRxAndroidBle[ 38]
as additional, specialized frameworks. Android Test Mock provides
3We used the word ‚Äúmocking ‚Äù because developers and the documentation of multiple
frameworks use this term to refer to test doubles in general.
2268
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:59:42 UTC from IEEE Xplore.  Restrictions apply. ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USAMattia Fazzini‚àó, Chase Choi‚àó, Juan Manuel Copia‚Ä†, Gabriel Lee‚àó,
Yoshiki Kakehi‚Ä°, Alessandra Gorla‚Ä†, Alessandro Orso‚Ä°
stubs and mocks for ten specific classes of the Android framework.
MockServer, OkHttp, and Retrofitsupport the creation of TDsfor
classes communicating with a web server. Robolectric allows for
running tests interacting with the Android framework on the JVM
byusingalargesetofclassesthatofferasimplifiedimplementation
ofAndroidframeworkclasses.Robolectricalsoallowsappdevelop-
erstoimplementtheirownreplacementsforAndroidframework
classes;thesedeveloper-definedreplacementclassesarethosewe
consider in this study. Finally, RxAndroidBle is a library that facili-
tatesBluetoothcommunicationsandofferssupportforreplacing
the framework‚Äôs classes during testing.
3.1.3 RQ1: Which frameworks and approaches are most commonly
used to create TDs? ‚Äî Analysis. To identify the general and spe-
cialized test mocking frameworks used by a certain app, we firstidentified all the relevant importstatements for each framework
(e.g., org.mockito for Mockito), and then checked the import state-
mentsintheASTsoftheapp‚Äôstestfiles;ifatestfileusedanimport
statement of a certain framework, we considered the app as usingthat framework.In that case, theanalysis also computedthe num-
beroftestfilesusingthatframework,soastoprovideanindicative
measure of the extent to which the framework was used by theproject. It is worth noting that this measure could be computeddifferently, and possibly in a more accurate way (e.g., by consid-
eringall theAPImethodsin theframeworksandidentifying calls
to these methods in the test code). However, we believe that this
approximationissufficient,as(1)weusethisinformationonlyas
asecondarymeasure,withtheprimaryonebeingthenumberof
apps using the framework, and (2) this measure does not affect the
mainfindingsofthestudy.Todeterminewhetheranappextend-
s/implements classes/interfaces for creating TDs, we analyzed the
ASTs of the app‚Äôs test files and looked for classes that (i) contain
‚ÄúDummy‚Äù,‚ÄúStub‚Äù,‚ÄúMock‚Äù,‚ÄúSpy‚Äù,or‚ÄúFake‚Äùintheirname,(ii)have
anamethatdoesnotendwith‚ÄúTest‚Äùor‚ÄúTests‚Äù,and(iii)arepart
ofafilethatdoesnotusetheimportstatementsfromthegeneral
and specialized frameworks we considered. This strategy is in line
with an approach previously used in related work [ 13]. If an app
hadsuchaclass,weconsideredtheappasextending/implementing
classes/interfaces for creating TDs.
3.2 Detailed Analysis of TDs
After investigating which frameworks and approaches developers
usetocreateTDs,weidentifiedMockitoandMockito-Kotlinasthe
most popular frameworks for creating TDs in Java and Kotlin code
(see details in Section 4). Consequently, we focused the remaining
partofourstudyonthesetwoframeworks.Thispartincludesboth
manual, qualitative analyses and automated, quantitative analyses.
We nowdescribeour methodologyto select theten appsand detail
the analyses we performed to answer the remaining RQs.
3.2.1 Apps. Our qualitative analysis focused on the ten apps with
thehighestnumberofTDscreatedusingMockitoorMockito-Kotlin
and whose tests are maintained. We focused on ten apps due tothe significant amount of manual effort involved in this part of
the study, for both preparing the apps and performing the analysis.
For example, even simply building the apps can be extremely time-
consuming[ 39‚Äì41].Asfortheanalysis,therearemanytasksthatinvolve a significant manual work, including classifying the types
ofclassesreplacedbyTDsandmanuallyidentifyingthetypesof
TDs. Although focusing on a smaller set of apps may hinder the
generalizability of our results, as we also discuss in Section 6, it
allowed us to perform a detailed analysis of how developers create
and use TDs and get valuable insights.
To identify the number of TDs in an app, we (1) analyzed the
Mockito and Mockito-Kotlin APIs [ 20,25], (2) identified API meth-
ods (e.g., mock) and annotations (e.g., @Mock) that can be used to
createTDs,(3)parsedtheASTsofthetestfilesintheapptocollect
the locationsusing such methods orannotations, and (4)counted
the number of such locations. To identify whether an app‚Äôs tests
were maintained, we analyzed the app‚Äôs repository, counted the
number of commits of the test files in the year preceding the be-
ginning ofour study (August 2020), andconsidered the teststo be
maintainediftheapphadonecommitpermonthonaverageonthe
test files. The rationale for using this second criterion is that tests
that are maintained are more likely to be relevant. Table 1 reports
thetenappsweselectedbasedonthisstrategy.Foreachapp,the
table provides an identifier (ID A), the app‚Äôs name (Name ), the app‚Äôs
category as listed on the Google Play store (Category ), the app‚Äôs
version considered (Version ), the lines of code (in KLOC) for the
app‚Äôs source files (SL(K) ), the lines of code (in KLOC) for the app‚Äôs
testfiles(TL(K) ),andthenumberofTDsintheappcreatedusing
MockitoorMockito-Kotlin(Total underthe TestDoubles header).
Itisworthnotingthatsixofthetenappsalsouseadditionaltestmocking frameworks beside Mockito or Mockito-Kotlin. Specifi-
cally,sixapps(A02,A04,A06,A08,A09,andA10)create12class
replacements using Robolectric, two apps (A08 and A09) create 30
TDs using Powermock, and one app (A06) creates one TD using
OkHttp. Since our analysis is based on 2,365 Mockito/Mockito-
Kotlin TDs, we believe that considering the few TDs created using
other frameworks would impact the results only marginally.
3.2.2 RQ2: What types of classes do developers replace with TDs?
‚Äî Analysis. To answer RQ2, we performed four analyses. First, we
characterized the functionality provided by the classes. Second, we
identified whether the classes belonged to the app, the Java library,
third-party libraries, or the Android framework. Third, we studied
thedependenciesofthoseclassesthataredefinedintheapp.Finally,
weperformedacategorizationoftheclassesthatarereplacedby
TDs and are part of the Android framework.
Thefirstoneisaqualitativeanalysisthatcombinesdeductive,
inductive,andaxialcoding[ 42,43].Deductivecodingisasystematic
approachformanuallycoding(i.e.,labeling)textualcontentstartingfromanalreadyavailablesetofcodes(i.e.,labels).Inductivecoding
derivesnewcodesbasedonasystematicanalysisofthetextdata.
Axial coding relates codes to one another and finds higher-level
codes that represent abstractions of the original codes.
Inouranalysis,acodeisalabelthatcategorizesthefunctionality
providedbyaclass,whichweinferredbyanalyzingthesourcecode
and the documentation of the class. We also analyzed any class
dependenciesthat mayhelp clarifythe classfunctionality andthe
codeoftheTDreplacingtheclass.Specifically,wefirstlookedat
the test code using the TD to identify the part of the app being
tested. We then focused on the class being replaced by the TD and
inspectedthenameoftheclass,importeddependencies,declared
2269
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:59:42 UTC from IEEE Xplore.  Restrictions apply. Use of Test Doubles in Android Testing:
An In-Depth Investigation ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA
Table 1: Characteristics of the ten apps (and their tests) considered in the second part of our study.
IDA Name Category VersionSL (K)TL (K)Test Doubles PC Analysis TDT Analysis Tests
TotalùêΩVMDevice Total CBSample CBTotalùêΩVMDevice
A01andFHEM Personalization 6.0.225.25.67070 02810 6010587585 2
A02AnkiDroid Education 2.1352.87.06060 03211 53 7341274 67
A03AnySoftKeyboard Tools 1.128.721.6166166 05317117 231,0381,038 0
A04Nextcloud Productivity 3.12.165.16.5116108 85719 90161,1421,032 111
A05OpenSRP Medical 1.0.1419.72.5153153 08529110 22 5656 0
A06StreetComplete Travel & Local 21.227.48.0179166 13 6320123 25770664106
A07Travel Weather Travel & Local 1.5.13.21.9104104 05519 8315128128 0
A08WiFi Analyzer Tools 2.1.28.010.7193193 07825129 28706706 0
A09Wikimedia Commons Photography 2.1324.34.3222222 08126141 31270246 24
A10WordPress Productivity 15.2.1135.331.311021098 4252832861541,5141,396 118
2,3652,340 257842591,192 3316,5536,125 428
methods, used variables, and provided code comments. We also
used the same procedure to inspect the classes used by the class in
the case that this operation was necessary to better understand the
functionality provided by the class.
Overall, we analyzed 784 classes. Table 1 reports the number of
classes analyzed for each app (column Totalunder the PC Analysis
header).ThesearealltheclassesassociatedwiththeTDswecon-
sidered,whichweidentifiedbystaticallyanalyzingthecompiled
code of the tests. Specifically, we compile the tests, retrieve the
locations where developers initialized TDs (e.g., where developers
usethe mockmethod),andextracttheclasstypesassociatedwith
the objects. We built this analysis on top of Soot [44].
Ourqualitativeanalysisisdividedintothreepartsandperformed
by two raters, which are two of the paper authors. In the first part
oftheanalysis,thetworatersanalyzedasampleof259classesto
define the analysis codebook‚Äîa document detailing, for each code,
thesetofrulesspecifiesthecharacteristicsthatshouldbeobserved
to assign a code to a class. The set of rules also includes typical
examples of classes having a specific code. The sample size used to
create the codebook was created using stratified random sampling
and is statistically significant with a 95% confidence level (CL) and
a5%marginoferror(ME).Table1reportsthesamplesizesweused
to create the codebook (column CBunder the PC Analysis header).
Thetworatersusedthecategoriesidentifiedbyrelatedwork[ 12,
13,45]astheinitialsetofcodesforthecodebook(deductivecoding).
In the process of analyzing the classes in the sample, the raters
increased the number of categories to 28 (inductive coding) andthen grouped the categories into five main groups (axial coding).
Thisiterativepartoftheanalysistooktheratersaroundtwoperson-
months to complete. Table 2 reports the codes produced by this
partoftheanalysis.Theentirecodebookweusedisavailableinour
online appendix [ 15]. Our analysis produced two categories that
arenotpresentinrelatedwork: configuration andGUIcomponent.
Webelievethatthesenewcategoriesemergedbecausethesoftware
domainwetargetischaracterizedbyaspects(e.g.,GUIcomponents)
that are not a key part of the software domains analyzed in related
work [12,13,45]. Conversely, our codebook does not include some
ofthecategoriesidentifiedinrelatedwork‚Äîjavalibrary andexternal
dependencies ‚Äîbecausewedistinguishbetweenclassesintheapp,
the Java library, third-party libraries, or the Android framework
laterinanorthogonalcategorization.Finally,ourcodebookcontains
category generic, for classes whose functionality did not fall into a
bigenoughcategoryduringtheaxialcodinganalysis.Thiscategory
includesclasseslabeledas domainobjects inrelatedwork[ 12,13,Table2:CodesusedtocategorizetheclassesreplacedbyTDs.
Code Summary Description
Configuration Class used to manage the app‚Äôs settings.
Database Class that performs database operations.
GUI Component Class that is part of the app‚Äôs GUI.
Networking Class that perform network operations.
Generic Class that provides a functionality not falling
in the other categories.
45] and can also include classes from the Android framework or
externallibrariesthatcanbeconsideredasdomainobjectswhen
the framework or libraries are considered in isolation.
After creating the codebook, the two raters analyzed 10% of the
remaining classes using the codebook (i.e., they used the codebook
rulestocategorizetheclasses),andwemeasuredtheirinter-rater
reliability(i.e.,thedegreeofagreementamongratersintheanal-
ysis)usingtheKrippendorff‚Äôsalphacoefficient[ 46,47].Basedon
the codes assigned by the two raters, the alpha value was 0 .88,
which indicates high reliability. After discussing and resolving mis-
matching codes, the two raters proceeded with the last part of the
analysis and coded the remaining classes. Given the high value of
their inter-rater reliability, they equally split the remaining classes
and coded them independently.
After finishing the coding process, the raters also identified
whethereachanalyzedclassbelongedtotheapp,theJavalibrary,
a third-party library, or the Android framework. Then, for each of
the classes in the app, we identified whether the class was directly
coupled with the Android framework by checking its dependen-cies using an AST parser that analyzes the import statements inthe class. Finally, we identified the most recurring classes from
the Android framework replaced by TDs and performed a detailed
categorization based on their containing package.
3.2.3 RQ3: What TD types do developers create? ‚Äî Analysis. To
characterize the types of TDs that appear in the test code, we con-
ducted a qualitative analysis based on deductive coding, where the
codeindicatesatypeofTD.ToassignacodetoaTD,westudiedthe
functionality of the TD by inspecting the test code, by focusing on
themethodsintheMockitoAPIandonassertionstatements.Forex-ample,ifthetestcodeonlycreatestheTDobjectwithoutspecifyinganyadditionalbehaviorforit,wewouldclassifytheTDasadummy.
Asanotherexample,ifthetestcodecreatestheTDobjectandstubs
oneofitsmethods(e.g.,usingthe
when(x.m()).thenReturn(y) con-
struct fromMockito), wewould classifythe TDas astub. Because
different tests might define a different behavior for the same TD
2270
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:59:42 UTC from IEEE Xplore.  Restrictions apply. ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USAMattia Fazzini‚àó, Chase Choi‚àó, Juan Manuel Copia‚Ä†, Gabriel Lee‚àó,
Yoshiki Kakehi‚Ä°, Alessandra Gorla‚Ä†, Alessandro Orso‚Ä°
Table 3: Codes used to categorize the types of TDs.
Code Summary Description
Dummy The behavior of the test double is not stubbed nor verified.
Stub The test double offers stubbed method implementations.
Mock The interactionswith the test double are verified.
Spy The test verifies the test double‚Äôs interactions using assertions.
Fake The test double provides a simplified implementation.
object (e.g., when the TD is created as a test class attribute), our
analysis might assign multiple codes to the same object.
Wesplitthiscodingprocessintothreeparts,aswedidforthe
qualitative analysis of RQ2, and the same two authors that per-
formed the analysis of RQ2 performed this analysis as well. In the
firstpartoftheanalysis,theratersanalyzedastatisticallysignifi-
cantsample(CL=95%andME=5%)of331TDstodefinetheanalysis
codebook. Table 1 reports the sample sizes we used to create the
codebook (column CBunder the TDT Analysis header). Table 3
reportsthecodesusedinourcodebookandtheirsummarydescrip-
tions. The entire codebook is available in our online appendix [ 15].
Aftercreatingthecodebook,thetworaterslabeledastatistically
significant(CL=95%andME=5%)sampleofTDsforeachapp,ex-
cludingsamplesalreadylabeledwhencreatingthecodebook,for
atotalof1,192TDs.ThesamplesizesperapparereportedinTa-
ble1(Samplecolumn).Weanalyzedstatisticallysignificantsamples
instead of the whole dataset because the effort required to do so
wouldbeconsiderable(estimatedataroundfourperson-months).
Inthesecondpartoftheanalysis,theraterscoded10%oftheTDsinthesamples,andwemeasuredtheirinter-raterreliability.Basedon
the coding results, the Krippendorff‚Äôs alpha value was 0 .97, which
indicateshighreliability.AsforRQ2,afterdiscussingandresolving
mismatching codes, the two raters split the remaining TDs and
coded them independently.
After categorizing the types of TDs, we combined the results
fromRQ2andthisRQtounderstandhowthetypesofTDsrelate
to the type of class they replace.
3.2.4 RQ4: How do tests use TDs? ‚Äî Analysis. To further char-
acterize key properties of TDs, we analyzed how tests use TDs
byrunningthetestsoftheappswithaninstrumentedversionof
Mockito4while collecting various data. As the tests ran, our in-
strumentation logged the calls made to the methods of the TDs,
identifiedwhichcallsweremadetostubbedmethods,andrecorded
how many of these calls were being verified during test execution.
The instrumentation also computes various properties of these
methods: how many unique methods were being stubbed, the loca-
tioninwhichthesemethodswerestubbed,andwhethermethods
return hard-coded values or intended exceptions. Table 1, in theTestssection on the right, reports the number of executed tests,
both overall (Total ) and grouped by test type (JVM orDevicetests).
3.2.5 RQ5: What problems can TDs introduce? ‚Äî Analysis. Toan-
swerRQ5,ouranalysisidentified unnecessarystubs ‚Äîstubbedmethod
never called during test execution‚Äîand mismatched stubs ‚Äîstubbed
methods called with arguments that differ from those specified for
the stub (e.g., a stub tdspecified as when(td.m(2)).thenReturn(3)
andthencalledbyatestas td.m(4)).Althoughtheseissuesmight
4BecauseMockito-Kotlin internallyrelieson Mockito,ourMockito instrumentation
worked for it transparently.Table4:Frameworksandapproachesconsideredinourstudy
together with their occurrences in our dataset of 1,006 apps.
Type Framework/Approach Name AppsOccurrences
Generic
Test
Mocking
FrameworksEasyMock 2 3
jMock 0 0
Mockito 323 2123
Mockito-Kotlin 55 605
MockK 17 108
PowerMock 41 148
Specialize
Test
Mocking
FrameworksAndroid Test Mock 18 24
MockServer 0 0
OkHttp 42 137
Retrofit 4 5
Robolectric 29 87
RxAndroidBle 0 0
Extend/Implement
Classes/Interfaces- 68 146
not lead to test failures, these problems often indicate potential
issuesintheunderliningtestcode.Unnecessarystubs,inparticular,
mayindicatesuperfluous,dead,oroutdatedcodeinthetests.Fur-
thermore, both unnecessary and mismatched stubs may indicatetests that are not checking for the intended behavior of the CUT.
To identify these kinds of stubs, we ran the tests with the stubbing
hintsoptionofMockitoenabled[ 48],byaddingatestruletothe
tests. It is worth noting that the next major release of Mockito will
notify developers when these problems occur [ 49], which indicates
that they are perceived as potentially relevant issues.
4 RESULTS
In this section, we present the results of our study on how develop-
ers create and use TDs when testing Android apps.
4.1 RQ1: Which frameworks and approaches
are most commonly used to create TDs?
Table4showshowmanyofthe1,006appsinourdatasetusethe
frameworksandapproachesweconsidered.Foreachframework/ap-proach,thetablereportsitsname(Framework/ApproachName ),the
numberofappswithteststhatusetheframework/approach(Apps ),
and the number of files using the framework/approach (Occur-
rences).ForRobolectricandtheapproachbasedonextending/im-
plementingclasses/interfaces,thenumberofoccurrencesidentifiesthenumberof developer-definedTDclasses.Ofthe1,006appscon-
sidered, 397 apps (39%) use either a framework or an alternativeapproach to create TDs. (Adding the number of apps in Column
Appsresults in a higher number because some apps use more than
oneapproachtocreateTDs,andthusappearinmorethanonerow.)
Mockito is the most used framework, with 323 apps and 2,123
testfilesusingit.Thisresultisinlinewiththefindingsfromrelated
work[50],whichidentifiedMockitoasthemostpopularframework
for Java-based projects. Our results also highlight that Mockito-
KotlinfindsasignificantadoptioninAndroidapps,with55appsand605testfilesusingthatframework.Webelievethatthisresultisdue
tothefactthatKotlinisgainingpopularityamongthelanguages
used to develop Android apps [ 51‚Äì53]. The total numberof apps
using either Mockito or Mockito-Kotlin is 337, which accounts for
33.5%oftheappsinourdataset.Afterfurtheranalyzingthetestcode
of these apps we found that developers use the two frameworks
2271
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:59:42 UTC from IEEE Xplore.  Restrictions apply. Use of Test Doubles in Android Testing:
An In-Depth Investigation ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA
morefrequentlyin JVMteststhanindevicetests.Specifically,we
observed that 39.1% of the 758 apps with JVM tests use one of the
twoframeworkswithinthesetests.Thisisincontrastwithwhat
happens for the 562 apps with device tests, where only the 9.1%
oftheappshaveteststhatuseeitheroneofthetwoframeworks.Furthermore, among the apps using Mockito or Mockito-Kotlin,
thereare7,303TDsdefinedacross18,747JVMtests,and315TDs
definedacross3,524devicetests.Thisbiggapseemstoindicatethat
TDs are a relevant aspect of JVM-based testing of Android apps,
whereas they play a smaller role in the context of device tests.
Ourresultsalsoshowthatgenerictestmockingframeworksfind
awideradoptionthanspecializedtestmockingframeworks.Specif-
ically, 35.9% of the apps use a generic test mocking framework,
while only 6.2% of them use a specialized one. Note that, although
developers do not often use Robolectric to create manually-defined
TDs (only 2.8% of the apps defines such TDs), they use the TDs
already provided by the framework more extensively; 17.3% of the
apps in our dataset have tests that rely on those TDs. When we
analyzed apps with tests that create TDs by extending/implement-
ingclasses/interfaces,wefoundthatonly6.8%oftheappsinour
dataset use this approach. Our analysis also revealed that 67.6% of
themalsouseagenerictestmockingframework.Thisresultseems
to suggest that, at least in some cases, developers find it necessary
to create ad-hoc TDs in addition to those they create using test
mockingframeworks, whichmay indicatetheneed foradditional
features within these frameworks.
Finally,by comparingapps thatusea frameworkorsome alter-
nativeapproachtocreateTDsandappsthatdonot,weobserved
that the average number of tests for the apps in the former cate-
gory is 65.1 andthe median is 22, while forthe latter category the
averageis13.9andthemedianis5.AMann-WhitneyUtest(95%
CL) shows the difference between the two groups to be significant.
AswefurtherdiscussinSection5,webelievethisisapotentially
interesting result that deserves further investigation.
RQ1 answer: Mockito and Mockito-Kotlin are the most widely
used frameworks, with 33.5% of the apps using either one of thetwo frameworks. Furthermore, generic frameworks find a wider
adoption than specialized frameworks or approaches. Finally,some apps use multiple approaches, which may indicate the
need for extending the individual approaches.
4.2 RQ2: What types of classes do developers
replace with TDs?
Figure 1, Figure 2, and Table 5 present the main results of the anal-
ysesweperformedtoanswerRQ2.Fig.1reportsthecategorization
forthetypesofclassesreplacedbyTDs,showingthepercentage
of each category for each app and the number of classes in each
category.Fortheappsweconsidered,thegenericcategoryincludes
the highest number of classes replaced by a TD. This result is in
line with related work [ 12,13,45] (as we included domain objects
in this category) and is expected, as this category is the broader
category among those we considered.
The remaining categories account for 32.5% of the classes we
analyzed, with the GUI component category being the most fre-quent and including 10.7% of the classes. All the classes in thiscategorywerereplacedby TDsinJVMtests.Theremainingthree
categories(database,networking,andconfiguration)includeclassesthatprovideaccesstoexternalresources.AlltheappscreatingTDs
for either one of these categories do so for multiple classes (e.g.,
WordPress(A10)createsTDsfor31classesaccessingthenetwork).
After analyzing the types of classes replaced by TDs, we investi-
gated whether those classes are defined in the app, the Java library,third-partylibraries,ortheAndroidframework.Figure2illustrates
the results of this analysis. Across all apps, there is an approxi-mately equal balance between the classes defined in the sourcecode of the apps and those defined in either third-party librariesor the Android framework. Specifically, 54.6% of the classes that
arereplacedbyTDsaredefinedintheapps‚Äôsourcecode,and43.5%
of them are defined in external dependencies. Our analysis alsorevealed that 90% of the classes defined in the app‚Äôs source codeand replaced by TDs have external dependencies, and for 63.1%of those, the dependencies involve the Android framework. This
resultdiffersfromrelatedworkanalyzingmockingintraditional
Java programs [ 12,45], where the percentage of classes replaced
by TDs and with external dependencies is lower than 60%5
Furthermore, 19.4% of the classes replaced by TDs belong to
the Android framework. Table 5 reports, for the ten most recur-ring packages that contain those classes, the number of unique
classesfromthepackages(column Classes(#) )andthenumberof
times that those were replaced by a TD (column Occur. (#) ). The
package containing the highest number of classes and occurrences
isandroid.content , which contains classes used to share content
betweenapplicationcomponentsthroughtheframework.Forexam-
ple,classes android.content.Context and android.content.Intent
werereplacedbyTDstoallowtestcodetoretrievespecificappli-
cation data during test execution. The top packages also include
android.location , which provides classes for location-based ser-
vices. The classes from this package that were replaced by TDs
provide specificlocation information orfacilitate access to thein-
formation during testing.
AmongtheAndroidframeworkclassesreplacedbyTDs,none
arefromthe android.hardware package,whichcontainscameraand
sensorclasses,evenifthreeapps(A02,A06,andA10)useclasses
from thispackage. We findthis resultinteresting andbelieve that
suitably replacing those classes might help in producing bettertest suites. We additionally observed that the six apps that use
Robolectric(A02,A04,A06,A08,A09,andA10)alsoreplaceclasses
defined in the Android framework, suggesting that better Robolec-
tricmodelsmaybeneededbecauseeithertheydonotincludesome
commonly used classes or, if they do, they are not used.
RQ2 answer: Developers replace classes that fulfill domain
logic (67.5%), model GUI components (10.7%), access the net-
work (8.7%), perform database operations (8.5%), and provide
appconfigurations(4.6%).Inalargenumberofcases(90%)de-
veloperscreateTDsforclassesthatareexternalorcoupledwith
external dependencies. Developers also replace Android classes
to be able to access specific app data during testing.
5We computed this number by aggregating the results from RQ1 in [12].
2272
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:59:42 UTC from IEEE Xplore.  Restrictions apply. ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USAMattia Fazzini‚àó, Chase Choi‚àó, Juan Manuel Copia‚Ä†, Gabriel Lee‚àó,
Yoshiki Kakehi‚Ä°, Alessandra Gorla‚Ä†, Alessandro Orso‚Ä°
Figure 1: Types of classes replaced by TDs. Figure 2: Location of the classes replaced by TDs.
Table 5: Packages of classes from the Android framework
frequently replaced by TDs.
IDùëÉPackage Classes (#) Occur. (#)
P01android.content 10 36
P02android.widget 10 10
P03android.view 7 15
P04android.app 6 12
P05androidx.lifecycle 6 9
P06android.os 5 7
P07android.location 4 5
P08androidx.fragment.app 4 4
P09android.net 3 9
P10android.content.res 3 7
4.3 RQ3: What TD types do developers create?
Figure 3 shows the different types of TDs in the apps we consid-
ered. Figure 3 displays the relative frequency for each type andis based on the statistically significant samples of Table 1 (TDT
analysissection).Acrossallapps,weidentified28unusedTDs(e.g.,
attributes annotated with @Mockbut never used by any test), which
are not reported in Figure 3. For this reason, and because we might
assign more than onetype to a single TD(e.g.,when a TD is used
differentlybydifferenttests),thetotalnumberoftypesinthefigure
mightdifferfromthesamplesizereportedinTable1.Ourresults
showthattheappsdousedifferenttypesofTDs,andthatdummies,
stubs, and mocks are the most prevalent types of TDs. Specifically,
39.9% of the TDs are dummies, 32.9% are stubs, 26% are mocks, andonly1.2%arespies.Notably,ouranalysisdidnotidentifyanyfakes
inthetenappsweconsidered.Thisresultwasexpected,asthese
apps rely on Mockito and Mockito-Kotlin, which do not support
the creation of fakes. Overall, these numbers show that developers
oftendefinestubbedimplementationsformethodsbutalsoverify
interactions between components under test and the TDs.
To provide a different view on these data, the first part of Ta-
ble6reportsthenumberofdummies,stubs,mocks,andspiesforeach type of class identified in RQ2. A chi-squared test at a signifi-
cance level of 5% rejected the null hypothesis that TDs types are
independent from thetypes of classes. Thesecond part of Table 6
presents TD types with respect to the classes grouped based on
where they are defined. Also in this case, a chi-squared test at a
significance level of 5% rejected the null hypothesis that TDs types
are independent from classes grouped by location.
Amongthe twocategories thatare notpresentin relatedwork,
GUI component and configuration, the most frequent types of TDs
aremocks(40%)andstubs(38%),respectively.MocksfortheGUIcomponentsaremostlyusedtoverifyinteractionsthatshouldor
shouldnothappen,whereasstubsfortheconfigurationcomponents
allow the tests to retrieve specific configuration values.
RQ3answer: Dummies(39.9%), stubs(32.9%)and mocks(26%)
frequently occur in the tests of the Android apps we considered.
This seems to indicate that, although a large number of TDs are
trivialclassescreatedsimplytoallowtheteststorun,developers
also (1) make extensive use of stubbed implementations and (2)
frequently use TDs to verify interactions.
4.4 RQ4: How do tests use TDs?
Table 7 reports the results of the dynamic analysis described in
Section 3.2.4. The table shows the characteristics of the calls made
by the tests on both stubbed and verified methods. For each app, it
reports the following information: number of TDs whose methods
arecalledatleastoncebythetests(TD,forbothstubbedandverified
methods), total number of calls to stubbed methods made by the
tests(SMC ),totalnumberoflocationsintheteststhatmakecallsto
stubbed methods (CL), number of unique methods that are stubbed
at least once, whether they are called or not by the tests (SM ),
number of different locations in which any method is stubbed
(SL), total number of stubbed methods returning values (VR ), total
number of stubbed methods returning exceptions (ER ), and total
2273
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:59:42 UTC from IEEE Xplore.  Restrictions apply. Use of Test Doubles in Android Testing:
An In-Depth Investigation ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA
Figure 3: Types of TDs (percentages).
number of method calls verified (VMC ). In total, the tests made
27,111callstostubbedmethods.Analyzingthe1,493codelocations
making these calls and the 782 unique methods being called, we
noticed that tests tend to rely heavily on a small subset of the
stubbedmethods.Forexample,forthreeoftheapps(A01,A03,and
A04), a single stub accounts for over 50% of the calls to stubbed
methods.Wealsoinspectedthecodedefiningandusingthethree
most called stubbed methods for each app and observed that themajorityofthesemethodsarestubbedtoimprovetestexecution
performance (e.g., to avoid reading from configuration files).
Table7alsoshowsthatdevelopersstubbedthesamemethods
at different code locations. Specifically, the 782 unique stubbed
methodsarestubbedin2,174differentlocations,and423ofthese
methods are stubbed more than once, which seems to indicate
thattestsusestubbedmethodsfordifferentpurposes.Furthermore,
althoughthemajorityofstubbedmethodsreturnvalues(column
VR), some of them return exceptions (column ER).
The numbers in the table for the verified methods show that
2,008 TDs were used to verify 3,492 method calls. Consideringthat the total number of test execution is 6,553 (see Table 1), this
roughly correspond to oneverified method call for every other test
execution(onaverage).Thisresultfurtherconfirmsourfindings
from RQ3 that TDs are frequently used to verify interactions.
RQ4 answer: Tests perform a large number of calls to stubbed
methods(27,111callsacross6,553testexecutions).Manyofthesecallsinvolvestubscreatedto improveperformance andspeedup
test execution. Methods are often stubbed at multiple locations,
indicatingthattestsmaystubthesamemethoddifferentlyfor
different purposes.
4.5 RQ5: What problems can TDs introduce?
The analysis we discussed in Section 3.2.5 revealed that all the
apps we considered contain unnecessary stubs. In many cases, this
happens becausethe test code that createsstubs is overlygeneral,
and stubsare created alsoby tests thatdo not actuallyneed them.
The most extreme example of this issue is in app andFHEM (A01),Table 6: TD types for the different class types (abs. values).
Category Dummy StubMockSpy
Configuration 3338290
Database 4763400
GUI Component 5537644
Networking 6556401
Generic 50136925715
App 4933692889
Java 11451
Third Party Lib. 2669161
Android 1711211219
Table7:Characteristicsofthecallsmadebythetestsonboth
stubbed and verified TD methods.
IDAStubbed Verified
TDSMCCLSMSLVRERTDVMC
A01368155747358484055
A0213039546356054636133
A0359611104974112812176261445
A042083779553776742139236
A059559929244868604648
A06405711796421018129180206
A071131855538696183544
A0840665923014440439311497781
A09115135434312311677086
A10174079875493019349322374508
4,17627,1111,4937822,1742,102722,0083,492
in which a method in the test code defines a stub for each of the
767resourcestrings[ 54]oftheappandiscalledby135teststhat
do not actually need the stubs. Overall, in the tests we considered,
106,545 unnecessary stubs are created at 624 test code locations. It
is worth noting that this problem can be seen as an instance of the
general fixture test smell [55].
Although not as prevalent as unnecessary stubs, our analysis
alsorevealed19issuesrelatedtomismatchedstubsin4different
apps (A02, A07, A08, and A10). Mismatched stubs are problematic
because a test may exercise a behavior different from the intended
oneandstillpass.Forexample,inAnkiDroid(A02),atestmeant
to exercise specific lines in the code never reaches them becausethe call to a mismatched stub returns a value different from theexpected one, which causes the execution of a different controlflow without affecting the outcome of the test. We provide a full
discussion of this issue in our online appendix [15].
RQ5answer: The106,545unnecessaryand19mismatchedstubs
reported by our analysis provide evidence that TDs can lead to
testsmellsandtothetestingoffunctionalitythatdiffersfrom
the intended one.
5 DISCUSSION AND ACTIONABLE INSIGHTS
Inthissection,wesummarizethemainfindingsofourstudyand
discuss some insight and actionable items derived from them.
ImportanceofTDsinAndroidtesting. Beforethisstudy,it
was not known how frequently Android apps use a framework or
some alternative approach to create TDs. Our study shows that
2274
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:59:42 UTC from IEEE Xplore.  Restrictions apply. ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USAMattia Fazzini‚àó, Chase Choi‚àó, Juan Manuel Copia‚Ä†, Gabriel Lee‚àó,
Yoshiki Kakehi‚Ä°, Alessandra Gorla‚Ä†, Alessandro Orso‚Ä°
aconsiderablepercentage(roughly40%)oftheappsthatcontain
automatedtestsuseatleastoneofthoseframeworksorapproaches.
Thisresultmotivatestheinvestigationanddevelopmentoftechniques
that support developers in creating and maintaining TDs . The study
also finds that these apps tend to have a larger test suite as com-
pared to apps that do not use TDs. We believe that it is worthwhile
to perform additional studies, possibly including interviews to de-
velopers, to assess whether this is just a correlation or it instead
indicates that extensive testing of an app is likely to require the
use of TDs. The latter would provide an even stronger motivation
for the development of techniques that support the creation and
maintenance of TDs.
Supporting Mockito and Mockito-Kotlin. Similar to what
wasfoundbystudiesonJavaprojects[ 50],weidentifythatMockito
and Mockito-Kotlin, which are used by one third of the apps inour dataset, are the most frequently used frameworks. However,
comparingtheadoptionofthesetechnologiesbetweenAndroidand
Javaprojects,ourresultsshowthatthesetwoframeworksaremore
widelyusedwithin AndroidappsthanMockitowithin traditional
Javaprojects(23%adoptionrate)[ 50].Onepossibleexplanationfor
this difference is that Android apps are more tightly coupled with
their external dependencies [ 5,56‚Äì58], and it is therefore necessary
toaccountforthesedependenciesduringtesting.Infact,amongthe
tenappsweconsideredinourdetailedanalysis,amajority(90%)ofclassesreplacedbyTDseitheraredefinedinexternaldependencies
or use external dependencies. This is in contrast with what was
identified by related work [ 12,45] in the domain of Java programs,
wherethis percentagewas 60%.Theseresults, inaddition tomoti-
vating the development of techniques for creating and maintaining
TDs,also indicate that the techniques would be mostly useful if they
would support Mockito and Mockito-Kotlin.
HelpingdeveloperscreateTDs. Whencreatingtests,devel-
opers must decide which parts of a system to replace with TDsand which TDs to use [
12,14,45]. We believe that the results of
our study, and possibly further studies along similar lines, can help
guide the development of recommender systems that help develop-
ers identify classes that should be replaced by TDs.
As a first observation, our results show that Android developers
usedifferenttypesofTDs,andthatstubbedimplementationsand
mocks that verify interactions between code under test and TDs
are prevalent. As far as stubs are concerned, we observe recurring
patterns. In particular, developers stub methods for data communi-
cations that are hard to setup (e.g., communications with classes
inthe android.content package)orforspecifictypesofdata(e.g.,
data associated with classes in the android.location package). De-
velopersalsocreatestubstoimprovetestexecutionperformance.
AsforTDsthatverifyinteractionsbetweenTDsandcomponents
undertest,wefindthatthisisdoneforallthetypesofclasseswe
analyzed and that both interactions that should and should not
happenareverified.Basedontheresults,webelievethat techniques
that support creating and maintaining TDs should focus on stubs‚Äî
helpingdevelopersidentifywhichmethodsrequirestubbingandwhat
values should be returned by these stubs‚Äîbut also on mocks‚Äîhelping
developers also decide which interactions to verify.
Identification of which methods to stub could be done by ana-
lyzing how the data is generated within the method (e.g., whether
itislocationdependent)orbyexaminingtheperformancecostofdifferent methods called during testing. This latter case is partic-ularly important to ensure that JVM tests run quickly, as that isone of the goals of those tests [
59]. As for the values (or excep-
tions) that should be returned by the created stubs, test carving
techniques[ 60‚Äì62]couldbeusedtoidentify,record,andsuggest
values flowing between the boundaries of tests and code under
test. Similarly, approaches that analyze the interactions between
testsandcodeundertestcouldbeusedtoidentifyinteractionsthat
shouldandshouldnothappen,createcorrespondingchecks,and
suggest them to developers.
Android-specific TDs. An additional way in which our results
could be leveraged to develop techniques that support Android
developers isby analyzing theAndroid-specific TDs thatare used
intheapps.Specifically,ouranalysisofthedifferenttypesofclassesthatarereplacedbyTDsidentifiestwocategoriesofclassesthatare
characteristic of Androidapps: configuration and GUIcomponent.
Because configuration and GUI component classes are typically part
of the Android framework or inherit from classes therein, they can
beeasilyidentifiedandproposedtothedeveloperaspossiblecandi-
dates for replacement by TDs. Furthermore, our study found thata large percentage of classes replaced by TDs consists of classes
that either are external dependencies or use external dependencies,andthatthishappensmorefrequentlythanfortraditionalJavapro-
grams [12,45]. One possible explanation is that Android apps tend
to have a tighter coupling with their external dependencies [ 5,56‚Äì
58].Additionalstudies focusedon thecoupling informationbetween
apps and their external dependencies may help identify which classes
should be replaced by TDs.
TDsinJVManddevicetests. AndroiddeveloperscanuseTDs
in both JVM and device tests [ 10,16]. Our study identifies a notice-
ably larger number of TDs‚Äîin particular, Mockito and Mockito-
KotlinTDs‚ÄîinJVMtestsascomparedtodevicetests.Althoughthis
is not surprising, as JVM tests are run without a complete Android
framework and might therefore need to account for the missingelements (even when Robolectric is used as the library provides
apartialimplementationoftheAndroidframework[ 37,63]),itis
interesting to observe such a large difference. Based on these find-
ings,we recommend prioritizing the design of automated techniques
for supporting the creation and integration of TDs in ùêΩVM tests,a s
those are likely to find larger adoption in practice.
Furthermore, future workcould investigate the reasons behind
thesedifferences.Analyzingthe25TDsinthedevicetestsforthe
10 apps in Table 1, in particular, we found that all of them occur
within integration tests, none is used within GUI tests, and 17 of
themarecheckingforinteractionshappeningwiththeTDs.This
was lessexpected because, forinstance, GUI testswould typically
interactwithexternalservices(e.g.,abackendserveroradatabase)
andwouldthereforebenefitfromtheuseofTDs.Basedonthesepreliminary data, we hypothesize that developers may prefer to
avoidTDsindevicetests,inordertohavehigher-fidelitytests,and
only use them for specific purposes (e.g., verifying that some calls
happen during testing, rather than replacing components in the
system).Interviewswithappdevelopersmayhelpconfirmorrefuse
thesehypothesesand,moregenerally,shedlightonwhyTDsare
less used in device tests.
Supporting debugging of TDs. Like all activities that involve
aconsiderableamountofmanualeffort,creatingandmaintaining
2275
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:59:42 UTC from IEEE Xplore.  Restrictions apply. Use of Test Doubles in Android Testing:
An In-Depth Investigation ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA
TDs in Android apps is error prone. In fact, our study identifies
cases of faulty TDs and instances of test code smells related to the
usageofTDs(seeSection4.5),whichmotivatesthedevelopment
of techniques that support developers in debugging TDs. Based on
ourresults, astartingpointcouldbethedevelopmentoftechniques
that identify obsolete TDs, which could be done by identifying TDs
that are not actually exercised during testing and by analyzing code
andtestsco-evolution.Itisworthnotingthat,althoughourstudy
highlights these issues in TDs for Android apps, they might alsoappear in other types of software, so other application domains
could also benefit from these techniques.
6 THREATS TO VALIDITY
As it is the case for most empirical studies, there are threats to
validity associated with the results we presented. In terms of ex-
ternalvalidity,ourresultsmightnotgeneralizetootherAndroid
appsandcorrespondingtests.InRQ1,wemitigatedthisthreatby
considering the largest (to the best of our knowledge) dataset of
appswithpublicly availabletestsuitesinthe literature,withapps
thatvarywidelyintermsofsizeandcategory.ForRQ2‚ÄìRQ5,we
chose to perform our in-depth analysis based on the ten apps with
the highest number of TDs due to the significant manual effort
involved in preparing the apps for the analysis and performing the
analysis, as we discussed in Section 3.2.1. Although this allowed us
to perform a detailed investigation on over 2,000 TDs and carefully
inspecttheresultsandthe correspondingcode,we acknowledge
thatthispartoftheanalysisisacasestudy.Additionalstudiesbasedonmoreapps,possiblyselectedusingadifferentsamplingstrategy,are needed to confirm the validity of our results and gather further
insights into how developers create and use TDs.
Intermsofconstructvalidity,ourresultsmightbeaffectedby
errorsintheimplementationofthetoolsweusedtoperformour
analyses. To mitigate this threat, we extensively tested our toolsand manually inspected our results. Finally, we also performedqualitative analyses, which might be characterized by divergent
understandingamongtheraters.Weareconfidentinthereliabil-
ity of our analysis as the inter-rater reliability we measured was
considerably high.
7 RELATED WORK
OtherresearchersperformedempiricalstudiesonAndroidapptest-
ing[6‚Äì11].Specifically,someworkobservedthatdevelopersuse
testingframeworkssuchasJUnit,Robolectric,andRobotium[ 7].
Other work confirmed that most apps are still poorly tested, al-
though test automationand test quality areimproving along with
the increasing success and wide adoption of mobile apps [ 8‚Äì10].
Yetotherworkshowedthatmanyappshadatleastoneflakiness
issue in their lifetime, and that the environment is one of the main
causes of flakiness together with concurrency [ 11]. None of this
body ofwork focuseson how Androiddevelopers useTDs within
their test suites.
Other researchers, however, have studied test mocking prac-
tices in non-mobile projects [ 12‚Äì14,45,50,64]. Spadini and col-
leagues[12]analyzeover2,000mocksobjectsin4Javaprojectsand
reportthattheusageofmockshighlydependsontheresponsibilityoftheclass,andthatdevelopersfrequentlymockdependenciesthatmaketestingdifficult.Theirstudyalsoshowsthatmockstendto
existsincetheveryfirstversionofthetestclassandtendtostay
foritswholelifetime.PereiraandHorafurtherexplorethistopicby
analyzing12popularJavasoftware projects,distinguishingmock
objects from mock classes, and further classifying which classesdevelopers mock [
13]. Similarly, Zhu and colleagues study over
10,000 tests in 4 open-source projects and propose a tool, Mock-
Sniffer,foridentifyingandrecommendingmocksforunittests[ 14].
Additionally,theworkfromTrautschandcolleagues[ 64]focuses
on mocking practices in 10 Python projects. To the best of our
knowledge,noneofthestudiesonmockingpractices(1)differen-
tiates uses of TDs as we do in this paper, (2) focuses on mobile
apps,or(3)aimstoidentifypossibleissueswithTDs.Ourresults
show, for instance, thatAndroid apps replace types of classes that
werenotcategorizedbeforeandhighlightthatbothstubbingand
operationsto verifymethodcalls arefrequentand important.Our
study also shows the need for better techniques for debugging and
maintaining TDs.
Finally, related work also focused on generating, using, or main-
tainingtestmocksautomatically[ 1‚Äì3,5,65‚Äì73].Ourpaperprovides
specific insights for researchers who want to define approaches
along these lines for in the context of Android.
ACKNOWLEDGMENTS
This work was partially supported by NSF, under grants CCF-
1563991 and CCF-0725202, Spanish Government‚Äôs SCUM grant
RTI2018-102043-B-I00, the Madrid Regional project BLOQUES,DARPA,undercontractN66001-21-C-4024,ONR,undercontract
N00014-18-1-2662,DOE,undercontractDE-FOA-0002460,andgifts
from Facebook, Google, IBM Research, and Microsoft Research.
8 CONCLUSION
In this paper, we presented an in-depth study aimed to understand
howdeveloperscreateanduseTDsinAndroidapps.Ourresultsshowed that Mockito and Mockito-Kotlin are the most popular
frameworks for creating TDs. They also show that TDs are used to
replacebothclasseswithintheappandexternaldependencies,that
developers use different types of TDs, and that TDs can introduce
test smells and even errors in the test code.
Our results motivate further research in this area, justify the
development of techniques that can support developers in creating
and maintaining TDs, and identify several directions for future
work.Asafirststep,wewillpresentourresultstoAndroiddevelop-
erstogathertheirfeedback,confirmorrefuseourfindings,andgain
further insights. We will also perform additional studies focused
onthecouplingbetweenappsandtheirexternaldependenciesto
develop analysis techniques that can help identify which classes
shouldbereplacedbyTDsandwhichinteractionsbetweeninternalandexternalcodeshouldbemockedandverified.Acomplementary
lineofresearchwewillpursueinvolvesthedevelopmentoftech-
niques for automatically or semi-automatically generating stubs
and mocks given a set of relevant classes and interactions. Finally,
wewillkeepperformingempiricalstudiestoconfirmourresults
and validate the new techniques we define.
2276
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:59:42 UTC from IEEE Xplore.  Restrictions apply. ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USAMattia Fazzini‚àó, Chase Choi‚àó, Juan Manuel Copia‚Ä†, Gabriel Lee‚àó,
Yoshiki Kakehi‚Ä°, Alessandra Gorla‚Ä†, Alessandro Orso‚Ä°
REFERENCES
[1]K. Taneja, Y. Zhang, and T. Xie, ‚ÄúMODA: automated test generation for database
applications via mock objects,‚Äù in ASE 2010, 25th IEEE/ACM International Con-
ferenceonAutomatedSoftwareEngineering,Antwerp,Belgium,September20-24,
2010, C. Pecheur, J. Andrews, and E. D. Nitto, Eds. ACM, 2010, pp. 289‚Äì292.
[2]A.Arcuri,G.Fraser,andR.Just,‚ÄúPrivateapiaccessandfunctionalmockingin
automatedunittestgeneration,‚Äùin 2017IEEEInternationalConferenceonSoftware
Testing, Verification and Validation (ICST). IEEE Computer Society, 2017, pp.
126‚Äì137.
[3]T. Bhagya, J. Dietrich, and H. W. Guesgen, ‚ÄúGenerating mock skeletons for light-
weight web-service testing,‚Äù in 26th Asia-Pacific Software Engineering Conference,
APSEC 2019, Putrajaya, Malaysia, December 2-5, 2019. IEEE, 2019, pp. 181‚Äì188.
[4]N.Alshahwan,Y.Jia,K.Lakhotia,G.Fraser,D.Shuler,andP.Tonella,‚ÄúAUTO-
MOCK: automated synthesis of a mock environment for test case generation,‚Äù in
PracticalSoftwareTesting:ToolAutomationandHumanFactors,14.03.-19.03.2010,
2010.
[5]M. Fazzini, Q. Xin, and A. Orso, ‚ÄúAutomated api-usage update for android apps,‚Äù
inProceedings of the 28th ACM SIGSOFT International Symposium on Software
TestingandAnalysis. NewYork,NY,USA:AssociationforComputingMachinery,
2019, p. 204‚Äì215.
[6]P.S.Kochhar,F.Thung,N.Nagappan,T.Zimmermann,andD.Lo,‚ÄúUnderstanding
thetestautomationcultureofappdevelopers,‚Äùin 8thIEEEInternationalConference
on Software Testing, Verification and Validation, ICST 2015, Graz, Austria, April
13-17, 2015. IEEE Computer Society, 2015, pp. 1‚Äì10.
[7]M. L. V√°squez, C. Bernal-C√°rdenas, K. Moran, and D. Poshyvanyk, ‚ÄúHow do
developerstestandroidapplications?‚Äùin 2017IEEEInternationalConferenceon
Software Maintenance and Evolution, ICSME 2017, Shanghai, China, September
17-22, 2017. IEEE Computer Society, 2017, pp. 613‚Äì622.
[8]L. Cruz, R. Abreu, and D. Lo, ‚ÄúTo the attention of mobile software developers:
guess what, test your app!‚Äù Empir. Softw. Eng., vol. 24, no. 4, pp. 2438‚Äì2468, 2019.
[Online]. Available: https://doi.org/10.1007/s10664-019-09701-0
[9]F. Pecorelli, G. Catolino, F. Ferrucci, A. D. Lucia, and F. Palomba, ‚ÄúTesting of
mobileapplicationsinthewild:Alarge-scaleempiricalstudyonandroidapps,‚ÄùinICPC‚Äô20:28thInternationalConferenceonProgramComprehension,Seoul,Republic
of Korea, July 13-15, 2020. ACM, 2020, pp. 296‚Äì307.
[10]J. W. Lin, N. Salehnamadi, and S. Malek, ‚ÄúTest automation in open-source an-
droidapps:Alarge-scaleempiricalstudy,‚Äùin 202035thIEEE/ACMInternational
Conference on Automated Software Engineering (ASE), 2020, pp. 1078‚Äì1089.
[11]S. Thorve, C. Sreshtha, and N. Meng, ‚ÄúAn empirical study of flakytests in android apps,‚Äù in 2018 IEEE International Conference on Software
Maintenance and Evolution, ICSME 2018, Madrid, Spain, September 23-29,2018. IEEE Computer Society, 2018, pp. 534‚Äì538. [Online]. Available:
https://doi.org/10.1109/ICSME.2018.00062
[12]D.Spadini,M.Aniche,M.Bruntink,andA.Bacchelli,‚ÄúMockobjectsfortesting
java systems,‚Äù Empirical Software Engineering, vol. 24, no. 3, pp. 1461‚Äì1498, 2019.
[13]G. Pereira and A. Hora, ‚ÄúAssessing mock classes: An empirical study,‚Äù in 2020
IEEE International Conference on Software Maintenance and Evolution (ICSME),
2020, pp. 453‚Äì463.
[14]H.Zhu,L.Wei,M.Wen,Y.Liu,S.-C.Cheung,Q.Sheng,andC.Zhou,‚ÄúMocksniffer:Characterizingandrecommendingmockingdecisionsforunittests,‚Äùin 202035th
IEEE/ACM International Conference on Automated Software Engineering (ASE),
2020, pp. 436‚Äì447.
[15]M.Fazzini,C.Choi,J.M.Copia,G.Lee,Y.Kakehi,A.Gorla,andA.Orso.(2022,
Feb.)Anartifactforthearticle:"useoftestdoublesinandroidtesting:Anin-depth
investigation". [Online]. Available: https://doi.org/10.5281/zenodo.6000372
[16](2021, Apr.) Fundamentals of testing. [Online]. Available: https://developer.
android.com/training/testing/fundamentals
[17]G. Meszaros, xUnit test patterns: Refactoring test code. Pearson Education, 2007.
[18]M. Fowler. (2021, Apr.) Testdouble. [Online]. Available: https://martinfowler.
com/bliki/TestDouble.html
[19] (2021, Apr.) Mockito. [Online]. Available: https://site.mockito.org[20]
(2021, Apr.) Mockito-kotlin. [Online]. Available: https://github.com/mockito/
mockito-kotlin
[21] (2021, Apr.) Powermock. [Online]. Available: https://powermock.github.io[22] (2021, Apr.) Okhttp. [Online]. Available: https://square.github.io/okhttp[23] (2021, Apr.) Retrofit. [Online]. Available: https://square.github.io/retrofit[24]
(2021, Apr.) Android test mock. [Online]. Available: https://developer.android.
com/reference/android/test/mock/package-summary
[25](2021, Apr.) Mockito api. [Online]. Available: https://javadoc.io/doc/org.mockito/
mockito-core/latest/org/mockito/Mockito.html
[26] (2021, Apr.) Google play. [Online]. Available: https://play.google.com/store[27] (2021, Apr.) Javaparser. [Online]. Available: https://javaparser.org[28] (2021, Apr.) ktlint. [Online]. Available: https://github.com/pinterest/ktlint[29]
(2021,Apr.)Ankidroid.[Online].Available:https://play.google.com/store/apps/
details?id=com.ichi2.anki
[30](2021, Apr.) Ankidroid github. [Online]. Available: https://github.com/ankidroid/
Anki-Android
[31] (2021, Apr.) F-droid. [Online]. Available: https://f-droid.org/en[32](2021, Apr.) App manifest overview. [Online]. Available: https://developer.
android.com/guide/topics/manifest/manifest-intro
[33] (2021, Apr.) Easymock. [Online]. Available: https://easymock.org[34] (2021, Apr.) jmock. [Online]. Available: http://jmock.org[35] (2021, Apr.) Mockk. [Online]. Available: https://mockk.io[36] (2021, Apr.) Mockserver. [Online]. Available: https://www.mock-server.com[37] (2020, Apr.) Robolectric. [Online]. Available: http://robolectric.org[38]
(2021, Apr.) Rxandroidble. [Online]. Available: https://github.com/Polidea/
RxAndroidBle
[39]T. Su, J. Wang, and Z. Su, ‚ÄúBenchmarking automated gui testing for android
againstreal-worldbugs,‚Äùin Proceedingsofthe29thACMJointMeetingonEuropean
SoftwareEngineeringConferenceandSymposiumontheFoundationsofSoftware
Engineering. New York, NY, USA: Association for Computing Machinery, 2021,
p. 119‚Äì130.
[40]T.Wendland,J.Sun,J.Mahmud,S.M.H.Mansur,S.Huang,K.Moran,J.Rubin,
and M. Fazzini, ‚ÄúAndror2: A dataset of manually-reproduced bug reports for
androidapps,‚Äùin 2021IEEE/ACM18thInternationalConferenceonMiningSoftware
Repositories (MSR), 2021, pp. 600‚Äì604.
[41]J. Johnson, J. Mahmud, T. Wendland, K. Moran, J. Rubin, and M. Fazzini, ‚ÄúAn
empirical investigation into the reproduction of bug reports for android apps,‚Äù in
Proceedings of the 29th edition of the IEEE International Conference on Software
Analysis, Evolution and Reengineering. IEEE Computer Society, 2022.
[42]J. Corbin and A. Strauss, Basics of qualitative research: Techniques and procedures
for developing grounded theory. Sage publications, 2014.
[43]M.B.Miles,A.M.Huberman,andJ.Salda√±a, Qualitativedataanalysis:Amethods
sourcebook. Sage publications, 2018.
[44]R. Vall√©e-Rai, P. Co, E. Gagnon, L. Hendren, P. Lam, and V. Sundaresan, ‚ÄúSoot: A
java bytecode optimization framework,‚Äù in CASCON First Decade High Impact
Papers. USA: IBM Corp., 2010, p. 214‚Äì224.
[45]D. Spadini, M. Aniche, M. Bruntink, and A. Bacchelli, ‚ÄúTo mock or not to mock?
an empirical study on mocking practices,‚Äù in Proceedings of the 14th International
Conference on Mining Software Repositories. IEEE Press, 2017, p. 402‚Äì412.
[46]K. Krippendorff, ‚ÄúReliability in content analysis: Some common misconceptions
andrecommendations,‚Äù Humancommunicationresearch,vol.30,no.3,pp.411‚Äì
433, 2004.
[47]‚Äî‚Äî,Content analysis: An introduction to its methodology. Sage publications,
2004.
[48](2021, Apr.) Mockitohint. [Online]. Available: https://javadoc.io/static/org.
mockito/mockito-core/3.2.4/org/mockito/quality/MockitoHint.html
[49](2021, Apr.) Mockito strictness documentation. [Online]. Avail-able: https://javadoc.io/doc/org.mockito/mockito-core/latest/org/mockito/
quality/Strictness.html
[50]S.MostafaandX.Wang,‚ÄúAnempiricalstudyontheusageofmockingframeworks
in software testing,‚Äù in 2014 14th International Conference on Quality Software,
2014, pp. 127‚Äì132.
[51]B.G.MateusandM.Martinez,‚ÄúAnempiricalstudyonqualityofandroidapplica-
tionswritteninkotlinlanguage,‚Äù EmpiricalSoftwareEngineering,vol.24,no.6,
pp. 3356‚Äì3393, 2019.
[52]V. Oliveira, L. Teixeira, and F. Ebert, ‚ÄúOn the adoption of kotlin on android
development: Atriangulationstudy,‚Äùin 2020 IEEE27th International Conference
on Software Analysis, Evolution and Reengineering (SANER). IEEE, 2020, pp.
206‚Äì216.
[53](2021,Apr.)Updateonkotlinforandroid.[Online].Available:https://android-
developers.googleblog.com/2017/11/update-on-kotlin-for-android.html
[54](2021, Apr.) String resources. [Online]. Available: https://developer.android.com/
guide/topics/resources/string-resource
[55]A. Peruma, K. Almalki, C. D. Newman, M. W. Mkaouer, A. Ouni, and F. Palomba,
‚ÄúOn the distribution of test smells in open source android applications: An ex-
ploratory study,‚Äù in Proceedings of the 29th Annual International Conference on
Computer Science and Software Engineering. USA: IBM Corp., 2019, p. 193‚Äì202.
[56]H. Wang, Y. Guo, Z. Ma, and X. Chen, ‚ÄúWukong: A scalable and accurate two-
phase approach toandroid app clone detection,‚Äù in Proceedings of the2015 Inter-
national Symposium on Software Testing and Analysis, ser. ISSTA 2015. New
York, NY, USA: Association for Computing Machinery, 2015, p. 71‚Äì82.
[57]H.WangandY.Guo,‚ÄúUnderstandingthird-partylibrariesinmobileappanaly-
sis,‚ÄùinProceedingsofthe39thInternationalConferenceonSoftwareEngineering
Companion, ser. ICSE-C ‚Äô17. IEEE Press, 2017, p. 515‚Äì516.
[58]T. McDonnell, B. Ray, and M. Kim, ‚ÄúAn empirical study of api stability andadoption in the android ecosystem,‚Äù in 2013 IEEE International Conference on
Software Maintenance. IEEE, 2013, pp. 70‚Äì79.
[59](2021, Dec.) Build local unit testsk. [Online]. Available: https://developer.android.
com/training/testing/unit-testing/local-unit-tests
[60]S.Elbaum,H.N.Chin,M.B.Dwyer,andJ.Dokulil,‚ÄúCarvingdifferentialunittest
casesfromsystemtestcases,‚Äùin Proceedingsofthe14thACMSIGSOFTInterna-
tional Symposium on Foundations of Software Engineering. New York, NY, USA:
Association for Computing Machinery, 2006, p. 253‚Äì264.
[61]S. Elbaum, H. N. Chin, M. B. Dwyer, and M. Jorde, ‚ÄúCarving and replaying
differential unit test cases from system test cases,‚Äù IEEE Transactions on Software
2277
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:59:42 UTC from IEEE Xplore.  Restrictions apply. Use of Test Doubles in Android Testing:
An In-Depth Investigation ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA
Engineering, vol. 35, no. 1, pp. 29‚Äì45, 2009.
[62]A.KampmannandA.Zeller,‚ÄúCarvingparameterizedunittests,‚Äùin 2019IEEE/ACM
41st International Conference on Software Engineering: Companion Proceedings
(ICSE-Companion), 2019, pp. 248‚Äì249.
[63] (2020, Apr.) Robolectric. [Online]. Available: http://robolectric.org/extending
[64]F.TrautschandJ.Grabowski,‚ÄúArethereanyunittests?anempiricalstudyon
unittestinginopensourcepythonprojects,‚Äùin 2017IEEEInternationalConference
onSoftwareTesting,VerificationandValidation,ICST2017,Tokyo,Japan,March
13-17, 2017. IEEE Computer Society, 2017, pp. 207‚Äì218.
[65]M. Islam and C. Csallner, ‚ÄúGenerating test cases for programs that are codedagainst interfaces and annotations,‚Äù ACM Trans. Softw. Eng. Methodol., vol. 23,
no. 3, pp. 21:1‚Äì21:38, 2014.
[66]A.Arcuri,G.Fraser,andJ.P.Galeotti,‚ÄúGeneratingTCP/UDPnetworkdatafor
automated unit test generation,‚Äù in Proceedings of the 2015 10th Joint Meeting on
FoundationsofSoftwareEngineering,ESEC/FSE2015,Bergamo,Italy,August30-
September4,2015,E.D.Nitto,M.Harman,andP.Heymans,Eds. ACM,2015,
pp. 155‚Äì165.
[67]L. Gazzola, M. Goldstein, L. Mariani, I. Segall, and L. Ussi, ‚ÄúAutomatic ex-vivo
regressiontestingofmicroservices,‚Äùin AST@ICSE2020:IEEE/ACM1stInterna-
tional Conference on Automation of SoftwareTest,Seoul, Republic of Korea, 15-16
July, 2020. ACM, 2020, pp. 11‚Äì20.
[68]P.ZhangandS.G.Elbaum,‚ÄúAmplifyingteststovalidateexceptionhandlingcode:
An extended study in the mobile application domain,‚Äù ACM Trans. Softw. Eng.Methodol., vol. 23, no. 4, pp. 32:1‚Äì32:28, 2014.
[69]G. Fourtounis, L. Triantafyllou, and Y. Smaragdakis, ‚ÄúIdentifying java calls in
nativecodeviabinaryscanning,‚Äùin ISSTA‚Äô20:29thACMSIGSOFTInternational
Symposium on Software Testing and Analysis, Virtual Event, USA, July 18-22, 2020,
S. Khurshid and C. S. Pasareanu, Eds. ACM, 2020, pp. 388‚Äì400.
[70]L.Brutschy,P.Ferrara,O.Tripp,andM.Pistoia,‚ÄúShamdroid:gracefullydegradingfunctionalityinthepresenceoflimitedresourceaccess,‚Äùin Proceedingsofthe2015
ACMSIGPLANInternationalConferenceonObject-OrientedProgramming,Systems,
Languages,and Applications,OOPSLA2015, partofSPLASH 2015,Pittsburgh,PA,
USA,October25-30,2015,J.AldrichandP.Eugster,Eds. ACM,2015,pp.316‚Äì331.
[71]B.Mariano, J.Reese,S. Xu,T.Nguyen, X.Qiu,J. S.Foster,and A.Solar-Lezama,
‚ÄúProgram synthesis with algebraic library specifications,‚Äù Proc. ACM Program.
Lang., vol. 3, no. OOPSLA, pp. 132:1‚Äì132:25, 2019.
[72]X. Wang, L. Xiao, T. Yu, A. Woepse, and S. Wong, ‚ÄúAn automatic refactoring
frameworkforreplacingtest-productioninheritancebymockingmechanism,‚Äù
inProceedingsofthe29thACMJointMeetingonEuropeanSoftwareEngineering
Conference and Symposium on the Foundations of Software Engineering.N e w
York, NY, USA: Association for Computing Machinery, 2021, p. 540‚Äì552.
[73]M. Fazzini, A. Gorla, and A. Orso, ‚ÄúA framework for automated test mocking
ofmobileapps,‚Äùin 202035thIEEE/ACMInternationalConferenceonAutomated
Software Engineering (ASE), 2020, pp. 1204‚Äì1208.
2278
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:59:42 UTC from IEEE Xplore.  Restrictions apply. 