ProMal: Precise Window Transition Graphs for Android via
Synergy of Program Analysis and Machine Learning
Changlin Liu1Hanlin Wang1Tianming Liu2Diandian Gu3Yun Ma3
Haoyu Wang4Xusheng Xiao1
1Case Western Reserve University,2Monash University
3Peking University,4Beijing University of Posts and Telecommunications
1{cxl1029,hxw458,xusheng.xiao}@case.edu,2Tianming.Liu@monash.edu,3{gudiandian1998,mayun}@pku.edu.cn,
4haoyuwang@bupt.edu.cn
ABSTRACT
Mobileappshavebeenanintegralpartinourdailylife.Asthese
appsbecomemorecomplex,itiscriticaltoprovideautomatedanal-
ysistechniquestoensurethecorrectness,security,andperformance
of these apps. A key component for these automated analysis tech-
niquesistocreateagraphicaluserinterface(GUI)modelofanapp,
i.e.,awindowtransitiongraph(WTG),thatmodelswindowsand
transitions among the windows. While existing work has provided
both static and dynamic analysis to build the WTG for an app, the
constructed WTG misses many transitions or contains many infea-
sibletransitionsduetothecoverageissuesofdynamicanalysisand
over-approximationofthestaticanalysis.WeproposeProMal,a
â€œtribridâ€ analysisthat synergisticallycombines static analysis,dy-
namic analysis, and machine learning to construct a precise WTG.
Specifically, ProMal first applies static analysis to build a static
WTG,andthenappliesdynamicanalysistoverifythetransitions
inthe staticWTG.Forthe unverifiedtransitions, ProMalfurther
provides machine learning techniques that leverage runtime in-formation (i.e., screenshots, UI layouts, and text information) to
predictwhethertheyarefeasibletransitions.Ourevaluationson40real-worldappsdemonstratethesuperiorityof ProMalinbuilding
WTGsoverstaticanalysis,dynamicanalysis,andmachinelearning
techniques when they are applied separately.
CCS CONCEPTS
â€¢Theoryofcomputation â†’Programanalysis;â€¢Softwareand
itsengineering â†’Softwaretestinganddebugging;â€¢ Comput-
ing methodologies â†’Machine learning.
KEYWORDS
mobileapps;windowtransitiongraph;staticanalysis;deeplearning
ACM Reference Format:
ChanglinLiu,HanlinWang,TianmingLiu,DiandianGu,YunMa,Haoyu
Wang,XushengXiao.2022.ProMal:PreciseWindowTransitionGraphs
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACMmustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ICSE â€™22, May 22â€“27, 2022, Pittsburgh, PA, USA
Â© 2022 Association for Computing Machinery.
ACM ISBN 978-1-4503-9221-1/22/05...$15.00
https://doi.org/10.1145/3510003.3510037for Android via Synergy of Program Analysis and Machine Learning. In
Proceedings of the 44th IEEE/ACM International Conference on Software Engi-
neering(ICSEâ€™22),May22â€“27,2022,Pittsburgh,USA. ACM,NewYork,NY,
USA, 13 pages. https://doi.org/10.1145/3510003.3510037
1 INTRODUCTION
Mobile applications (i.e., apps) have become an integral part of
our daily life, from entertainment, travel, education, and even tobusiness [
12,53]. Thus, it is critical to improve the quality and
reliability of these apps by developing automated analysis tech-
niquestoensurethecorrectness,security,andperformanceofthese
apps [19,26,41,47,47,54,69,70]. As a key component for these
automated analysis techniques, we focus on creating a graphical
userinterface(GUI)modelofanapp,i.e.,awindowtransitiongraph
(WTG). In WTG, nodes represent windows and edges represent
transitionsbetweenwindows,triggeredbycallbacksexecutedin
theGUIthread.Forexample,clickingabuttonintheGUIwillresultintheexecutionofacallbackthatchangesthescreentodisplayan-otherwindow.WTGcanbedirectlyusedforunderstanding,testing,
and exploring appsâ€™ behaviors [ 7,26,54]. It can also assist static
analyses, such as detecting security-sensitive behaviors and other
non-functional properties like energy efficiency [9, 10, 63, 65].
Whileconsiderableresearcheffortshavebeenspenttoconstruct
WTGs [26,41,47,54,70] via either static analysis techniques or
dynamic analysis techniques, it is still challenging to obtain anaccurate WTG. On one hand, dynamic analysis such as dynamic
exploration[ 26,41,54]ispreciseinidentifyingtransitionsbetween
windows, but this type of techniques suffer from the notorious
coverage problem as other dynamic analysis techniques [ 14,64,
66].Ontheotherhand,whilestaticanalysisthatmodelstheGUI
objects, events,and callbacks[ 47,69,70] showspromising results
in constructing a more comprehensive WTG, the imprecision in
referenceanalysisandover-approximationincomputingdataflowsoftenresultininfeasibletransitions.Forexample,iftheimprecision
ofthereferenceanalysiscausesseveralbuttonstobealiaseswith
eachother,thenatransitiontriggeredbyonebuttonwillalsoresultinthemodeltoincludeincorrecttransitionsfromtheotherbuttons.Suchincorrecttransitionswillfurthercausetheimprecisionforthedownstreamanalysissuchascontrolanddataflowanalysis[
47,69].
To address these challenges, we propose a novel â€œtribrid anal-
ysisâ€ approach, ProMal, that synergistically combines static/-
dynamicprogramanalysisandmachinelearningtechniques
toconstructaWTGforanapp .Inparticular,ProMalaimsto
benefit from the precise analysis from dynamic analysis, and at the
17552022 IEEE/ACM 44th International Conference on Software Engineering (ICSE)
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:34:15 UTC from IEEE Xplore.  Restrictions apply. sametimemitigatethelowcoverageofdynamicanalysisandthe
imprecisioncausedbythestaticanalysis. xSpecifically,ProMal
firstcombines static analysis and dynamic analysis: ProMal applies
static analysis to construct a WTG, and then runs dynamic analy-
sistoverifythedetectedtransitions.Duetothecoverageissuesofdynamic analysis and over-approximation of the static analysis,it is expected that a substantial amount of transitions cannot be
verifiedbythedynamicanalysis. yInsteadofincludingallthese
unverified transitions in the WTG, which potentially will gener-ate many infeasible transitions, ProMal further uses a machine
learningtechnique,windowtransitionprediction,thatleveragesthe
features for the unverified transitions (e.g., screenshots and text) to
predictwhichtransitiontoinclude. Ournoveltechniques( xfor
verifyingstaticWTGsusingdynamicWTGsand yforpre-
dictingunverifiedtransitions)allowingProMaltoconstruct
amorepreciseWTGthatcanbenefitdownstreamanalysis
techniques.
Existing static analysis techniques [ 47,69,70] are effective in
detecting transitions among windows, but are limited in detecting
transitions among dialogs. ProMal improves the existing static
analysisbymodelingthedialogbuilderAPIsanddetectstransitionsburiedinthecallbacksofdialogstoidentifythetransitionsfromdi-alogstootherwindowsanddialogs.Asdynamicanalysis[
26,41,54]
typically models the window transitions differently from the static
analysis,ProMalinstrumentstheappunderanalysis,whichwill
recordtheinformationthatcanbeusedtoalign thedynamicWTG
withthestaticWTG.ThisincludestheidentifiersofGUIwidgets
(i.e.,XPath) and interaction events. Moreover, the instrumentation
willcollecttheruntimeinformation,includingscreenshotsofthe
windows,theviewtree1[23],andthetext showninthewindows.
Theruntimeinformationislaterusedbythemachinelearningtech-
niques to predict unverified transitions. For the windows found by
static analysis but dynamic analysis cannot reach due to coverage
issues, ProMal uses static UI rendering based on ADT (Android
Developer Tools) [ 3,32] to render the UI layouts for obtaining the
screenshots and the view tree, and applies static analysis on the UI
layout file to obtain the text.
To predict whether unverified transitions should be included in
theWTG,weconstructamodelofwindowtransitionpredictionbased on machine learning techniques. Given a GUI widget in a
windowandanotherwindow,themodelfirstextractsfeaturesof
them to learn their low-dimensional representations, which are
then fed into a link predictor to estimate the likelihood of whether
theseexistsatransitionbetweenthewidgetandwindow.However,duetothelargeamountofparametersinthepredictionmodel,itis
difficult to directly train the model since obtaining a large amount
of manually labelled WTGs is infeasible. To address this issue, we
adoptatwo-phasetrainingmodels:(1)pre-trainingonthedynamic
WTGscollectedbydynamicprogramanalysisfromalargeamount
of apps, and (2) fine-tuning on the manually labelled WTGs from a
small set of apps. The essence of the design lies in getting a model
general enough to accurately predict window transitions.
WeimplementProMaluponGator[ 47,69,70]andPaladin[ 41],
andevaluateProMalonadiversifiedsetofrealapps(40appswith
1A tree structure shows that hierarchy of the GUI widgets and the layout containers
(e.g., LinearLayout andRelativeLayout ).âˆ¼2.5 million LOC). These apps have non-trivial WTGs of differ-
entsizes(#ofedgesrangingfrom5to538).WeapplyPaladinto
constructWTGsfortheseapps,andcomparetheWTGswiththe
groundtruth WTGs. We pre-train our prediction model on 1,625appsexploredbyPaladin,andfine-tunethemodelusing90%of
theappsinourevaluationdataset.Weperform10-foldvalidationtopredict the transitions for each app. The results show that ProMal
effectively identifies the feasible transitions among the windows
in constructingWTGs, achievinga precision of 90 .18%, arecall of
79.69%, and a ğ¹1-score of 82 .82% on average. Moreover, the WTGs
builtbyProMalachievesasignificantlybetter ğ¹1-scorethanthe
WTGsbuiltbyGator(46 .24%)andthecombinedWTGsbuiltby
GatorandPaladin(61 .93%).Theseresultsrevealthelimitations
of static analysis in modeling windows/callbacks for diversified
real apps, and demonstrate the effectiveness of ProMal in using a
synergy approach of program analysis and machine learning.
This paper makes the following main contributions:
â€¢Anovelapproach,ProMal,thatsynergisticallycombinesstatic/-
dynamicanalysisandmachinelearningtoconstructWTGsfor
Android apps.
â€¢AnovelstaticanalysistechniquethatbuildsstaticWTGswith
transitions among windows and dialogs.
â€¢Anoveldynamicanalysistechniquethatinstrumentsappsun-
deranalysisandleveragesappexplorationtechniquestobuild
dynamic WTGs and collect runtime information for window
transition prediction.
â€¢A machine-learning model to predict window transitions, which
can be pre-trained on apps explored by dynamic analysis and
fine-tuned using labelled WTGs to improve the performance.
â€¢AnevaluationonadiversifiedsetofAndroidappstodemonstratetheeffectivenessof ProMal.Thetoolandtheresultsareavailable
at the project website [4].
2 BACKGROUND
In an Android app, an activity provides a window to draw theGUI [
23]. A GUI consists of GUI widgets (e.g., buttons and text
boxes) and layout models (e.g., linear layout) that describe how to
arrangeUIwidgets.EachGUIwidgetcanrespondtoseveralevents,
whereeacheventtriggersasequenceofcallbacks.Forexample,the
click event in a button corresponds to clicking the button, and ittriggers the event handler callback that is registered to the clickevent, such as
onClick. A callback can open a new window. For
example, thiscan bedone viacalling the API startActivity . When
a new window is opened, it causes a window transition. Besides
widget event callbacks, hardware events (e.g., pressing BACK or
HOMEbutton)canalsotriggercallbackstocausewindowtransi-
tions. In particular, Android maintains a back stack that stores the
order of the opened window, so that it can be used to decide which
window to return to when the BACK button is pressed.
Window transition graph (WTG) is a type of GUI model that
representswindowtransitions.Existingwork[ 47,69,70]defines
aWTGasadirectedgraph,wherenodesrepresentwindowsand
edges represent transitions. The edges in WTG are annotated with
three types of labels (i.e., ğœ–,ğ›¿,ğœ), where ğœ–represents the event to
trigger the transition, ğ›¿represents a sequence of window stack
1756
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:34:15 UTC from IEEE Xplore.  Restrictions apply. $FWLYLW\5RRW $FWLYLW\0HQX
Figure1: ExampleUIsof â€œSubscriberAssistantApplicationâ€
and a window transition
operationsthatpushorpopthewindowtothewindowstack2,and
ğœrepresentsthesequenceofcallbacksforthetransition.Besides
widget events such as click events, the model further supports
fivedefault events that correspondsto pressingthe BACK, HOME,
POWER, MENU buttons and rotating the phone. A series of static
analysis techniques are then developed to identify GUI widgets,
associatetheircallbacks,andbuildastaticWTG.Whiledynamic
analysis such as app exploration [ 26,40,41,54] usually does not
explicitlybuildaWTG,theyprovidetheirownmodelstorepresent
UIstates,whichcanbeconsideredasanothertypeofWTGswith
different representations for windows and their transitions.
Applications of WTGs. WTGs can be used to improve various
types of software analysis, such as testing, security vetting, and
performance profiling [ 11,56,60,62,63,68]. Wu et al. [ 62] gen-
erates GUI tests based on the paths in the WTGs and analyzesthe UI callbacks and activity life cycle methods to examine sen-sors that are not properly released. Yang et al. [
68] uses a WTG
to determine which activities can reach more other activities toprioritize test exploration. Another GUI testing tool [
11] uses a
staticallycomputedWTGtoguidewhichwidgettotriggerwhen
theotherexplorationrulesfail.Besidestesting,WTGsarealsousedforperformanceprofilingandsecurityvetting.Wangetal.[
60]pro-
filepotentialresourcedemandingtasksintheUIthreadbyusing
WTGs to identify callbacks that trigger â€œjankyâ€ operations and the
windowtransitionsequencesthattriggersuchcallbacks.Tanget
al. [56] build a UI-oriented program dependence graph, which is
essentially a WTG, to discover link hijacking vulnerabilities. All
theseapplicationsrelyonWTGsbuiltexplicitlyorimplicitly,and
thus it is crucial to improve the precision of the built WTGs for
improving the effectiveness of these applications.
3 MOTIVATION EXAMPLE
Figure 1 shows the UI (after translation) of an example windowtransition of the app â€œSubscriber Assistant Applicationâ€
3, which
allows users to subscribe various services in Russia. When the
highlightedbuttonisclicked,theUItransitsfromtheactivity Rootto
theactivity Menu,resultinginawindowtransition.Wecanconstruct
2Window stack is a generalization of Android back stack that includes more types of
windows (dialogs and menus) and models the changes of the stack.
3Package name of the app is â€œcom.olsoft.sa.ntvplusâ€.D)DYRULWHV
D6HQG&RPPDQGD0HQX D5RRWHOLVW
FOLFN
HEDFND1HZV
HEWQ
FOLFN
HJDOOHU\
FOLFNHEDFN
HEDFNN
HEWQ
FOLFN
HOLVW
FOLFNHPHQX
FOLFN
HEDFN
HEDFNHOLVW
FOLFND6HQG&RPPDQG
HEDFNHOLVW
FOLFN
HEDFNE N
Figure 2: Partial WTG of â€œSubscriber Assistant Applicationâ€
9LHZ7UHHRI>D5RRW@
DQGURLGZLGJHW)UDPH/D\RXW
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
;3DWK)UDPH/D\RXW/LQHDU/D\RXW)UDPH/D\RXW/LQHDU/D\RXW/LVW9 LHZ/LQHDU/D\RXW
%RXQGV>@>@DQGURLGZLGJHW/LQHDU/D\RXW
DQGURLGZLGJHW)UDPH/D\RXW
DQGURLGZLGJHW/LQHDU/D\RXW
DQGURLGZLGJHW/LQHDU/D\RXW DQGURLGZLGJHW/LVW9LHZ
DQGURLGZLGJHW/LQHDU/D\RXW ÄÄÄÄÄÄÄÄ$FWLYLW\5RRW
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄDQGURLGZLGJHW
Figure 3: Example view tree of Root window
aWTGfor thisapptomodelthesetransitions, where8nodesare
used to represent the activities and 125 edges are used to represent
the transitions among them. Due to space limit, Figure 2 showsthe partial WTG of the app. There are 5 nodes and 12 edges in
theWTG.Thenodesshowthenameoftheactivity(e.g., a0: Root
and a1: Favorite ).Thelabelsontheedgesrepresenttheeventsto
trigger the transition (e.g., e3: btn, click means that after clicking
the button,the active windowof appwill transit fromthe activity
Rootto the activity Favorite).
To obtain this WTG, ProMal first applies both static and dy-
namic WTG analysis to obtain the static WTG and the dynamic
WTG,respectively.Then,ProMalalignsthestaticWTGandthedy-
namic WTG to form a single WTG. As shown in Figure 2, the solid
edgesrepresentmatchingedgesbetweenthestaticWTGandthe
dynamicWTG,i.e.,,verifiededges.Duetotheover-approximationofstaticWTGanalysisandthecoverageissueofthedynamicWTG
analysis,therealwayswillbesomeedgesinthestaticWTGthat
cannotbeverifiedbythedynamicWTG.Theonedashededgein
Figure 2 represents such kind of unverified edge. To address this
problem,ProMalfurtheruseswindowtransitionpredictiontopre-dictwhethertheunverifiededgesarelikelytobetransitionsornot.
Todoso,ProMalcollectsthescreenshotsandthetextinformation
1757
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:34:15 UTC from IEEE Xplore.  Restrictions apply. 

#
#
##
#
"

$#



!
!

	!




 

Figure 4: Workflow of ProMal
oftheactivities(asshowninFigure1)andalsothestructuralinfor-
mationoftheUIlayout,i.e.,theviewtree.Figure3showsthepartial
viewtreeoftheactivity Root.Aswecansee,theviewtreeshowsthe
hierarchyoftheUIwidgets(e.g., ListView)andthelayoutcontainer
(e.g., LinearLayout ), and also the boundary of each UI widget (i.e.,
represented using screen coordinates). Since Android uses XMLlayout files to build view trees at runtime, XPath [
1] can be used
to locate theUI widget and thelayout container. For example, the
XPathshownatthebottomofFigure3pointstoa LinearLayout that
canbeclicked,andtheâ€œBoundsâ€showsitsboundaryintheUIusing
screen coordinates. With the screenshots and the text information
oftheactivitiesandtheviewtreeasinput,thewindowtransition
predictioncorrectlypredictsthetransitionfromtheactivity Rootto
theactivity Menu)inFigure1,enhancingtheWTGconstructedby
the static and dynamic WTG analysis.
4 OVERVIEW
Figure4showstheworkflowof ProMal.ProMalconsistsofthree
majorcomponents:staticWTGanalysis,dynamicWTGanalysis,
and window transition prediction. ProMal accepts an Androidapp APK file as input and applies both static and dynamic WTG
analysis to obtain the static and dynamic WTGs, respectively. The
static WTG analysis performs static analysis on the GUI layoutfiles and the code of the APK file and outputs a static WTG. The
dynamic WTG analysis consists of two steps: it firsts performs app
instrumentation, which adds the code component into the APK
filetocollectruntimeinformation,andthenappliesdynamicapp
exploration to explore appsâ€™ behaviors for building the dynamic
WTG. ProMal then aligns the static and dynamic WTGs to obtain
theedges(i.e.,windowtransitions)thatareverifiedbythedynamic
WTG analysis (i.e., verified edges ). For the unverified edges, Pro-
Mal uses the window transition prediction to predict whether the
unverifiededgesarelikelytobefeasibletransitions.Thewindow
transition prediction trains its model on a set of training APK files,
andusestheruntimeinformation(i.e.,screenshots,textinforma-
tion,andUIlayouts)topredictwindowtransitions.Asunverified
edges are not explored by the dynamic analysis, ProMal statically
renderstheGUIsinvolvedintheunverifiededgesforobtainingthe
information required for the prediction. The output WTG contains
onlytheverifiededgesandtheedgespredictedtobefeasibleedges.5 DESIGN OF PROMAL
In this section, we first provide the formal definition of window
transition graph (WTG), and then describe the three major compo-
nents of ProMal: static WTG analysis, dynamic WTG analysis, and
window transition prediction.
5.1 Definition of WTG
We represent a WTG as a directed graph ğº=(ğ‘Šğ‘–ğ‘›,ğ¸,ğœ–), where
ğ‘Šğ‘–ğ‘›representsasetofnodeswhereeachnoderepresentsa window
of an app, ğ¸âŠ†(ğ‘Šğ‘–ğ‘›Ã—ğ‘Šğ‘–ğ‘›)is the set of edges that represent
transitionsamongwindows,and ğœ–:ğ¸â†’ğ¸ğ‘£ğ‘¡representstheedge
labels that describe the events ğ¸ğ‘£ğ‘¡that cause the transitions.
Window.Weconsider3categoriesofwindowsthatuserscanin-
teractwithasanodeinaWTG: activities, menus,and dialogs.An
activity is often presented to the users as a full-screen window,
serving as the build block of an appâ€™s GUI. Menus include Options-
Menuwhichisassociatedwithactivitiesand ContextMenu whichis
associated with GUI widgets. Dialogs are short-lived windows that
often need user actions to proceed to the next window.
Edge(Transition).Anedge ğ‘’=(ğ‘¤ğ‘–ğ‘›ğ‘ ,ğ‘¤ğ‘–ğ‘› ğ‘¡)representsatransi-
tion from a source window ğ‘¤ğ‘–ğ‘›ğ‘ to a target window ğ‘¤ğ‘–ğ‘›ğ‘¡, and the
labels on the edges describe the events that cause the transition,such as a button click. Without loss of generality, we treat backedges as the other edges but with a special â€œbackâ€ label, whichmakes it easier to match the back edges identified in the static
WTGwiththedynamicallyobservedones.Moreover,weexclude
loops in ğ¸. A loop is an edge ğ‘’ğ‘™=(ğ‘¤ğ‘–ğ‘›ğ‘ ,ğ‘¤ğ‘–ğ‘› ğ‘¡)that points to it-
self,i.e., ğ‘¤ğ‘–ğ‘›ğ‘ =ğ‘¤ğ‘–ğ‘›ğ‘¡.Forexample,whentheuserclicksabutton
representing numbers in a calculator app, which does not result in
awindowtransitionbutstaysatthesamewindow,resultingina
loop.AsGUIwidgetsthatdonotcauseinter-windowtransitions
willresultinloops,theseedgesareofalargeamount.Thus,adding
loops to ğ¸only complicates a WTG without providing more useful
information.
Event.A ne v e n t ğ‘’ğ‘£ğ‘¡=(ğ‘¤,ğ‘¡)is a label associated with an edge
ğ‘’=(ğ‘¤ğ‘–ğ‘›ğ‘ ,ğ‘¤ğ‘–ğ‘› ğ‘¡),where ğ‘¤representsaGUIwidgetin ğ‘¤ğ‘ andğ‘¡isthe
typeofthisevent(e.g., ğ‘¤isabuttonand ğ‘¡isâ€œlong_clickâ€).Wemodel
twotypesofevents: widgetevents anddefaultevents.Widgetevents
correspondtotheinteractionswithaGUIwidget(e.g.,clickinga
button), which are categorized into two groups: (1) click events,
including touch,select,click,item_click,and item_selected,and(2)
long click events, including long_click anditem_long_click.W e
exclude several widget events because they mainly cause loops,such asscroll,drag,focus_changed, and enter_text. In fact, in our
evaluation dataset, all 181 edges corresponding to these eventsare loops. Default events correspond to the interactions with the
physical buttons or rotating the device. We focus on the eventscaused by pressing the back button and the menu button, and
excludeeventscausedbyrotatingthephoneandpressingthehome
buttonandthe powerbuttonssincethese excludeddefaultevents
onlycauseloopsandappswitches.Inourdataset,1,116outof1,430edgesrelatedtotheseeventsareloops,andtheremaining314edges
representappswitches.Forexample,whenanappshowsamenu
oradialogandtheuserpressesthehomebutton,thephoneexits
theappandshowsthehomescreen;whentheusergoesbacktothe
app, the app shows the parent activity of the menu or the dialog.
1758
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:34:15 UTC from IEEE Xplore.  Restrictions apply. While it seems like a â€œtransitionâ€ from the menu or the dialog back
to the activity, it is in fact an app switch, which is generally not
interesting in app explorations or testing [26, 41, 54, 72].
Ourmodelcurrentlydoesnotinclude Systemevents sincethey
usually do not trigger window transitions but rather changing the
statesofawindow.Systemeventscorrespondtochangesofsystem
states, such as receiving new messages and volume adjustment [ 5,
17,42,45,54,59]. These events are of a huge amount and can
significantly damper the performance of the testing tool, and thus
they are randomly injected during testing [45, 54].
5.2 Dynamic WTG Analysis
Dynamic WTG analysis instruments apps and leverages app ex-
ploration techniques to automatically explore appsâ€™ behaviors and
collecttheruntimeinformationforbuildingdynamicWTGsand
predicting window transitions. We next describe the app instru-
mentation and runtime information collection.
App Instrumentation. ProMal instruments an app to record
widget interactions and window transitions. Specifically, based
on our WTG definition, ProMal monitors two major types of
interaction events:
â€¢WidgetEvents :ProMalrecordstheclickevents,theclickcoordi-
nates, and the GUI widgets.
â€¢DefaultEvents :ProMalrecordsthedefaulteventsforpressing
the BACK and the MENU buttons.
To correctly identify window transitions, the instrumentation
records theforeground activitybefore eachinteraction, andlever-
agesthechangesoftheforegroundactivitytoidentifythesource
window and the target window when a transition happens. During
the exploration, we collect the attributes of the visited windows
(e.g.,titlesandtexts),thecallstacksoftheirparentmethods,and
the screenshots of dialogs and menus.
SincesomeGUIwidgetsmaynotpossesswidgetIDs,ProMal
furtherusescoordinatesandXPathtoidentifyGUIwidgetsinawin-
dow,asillustratedinFigure3.ProMalhooksthe dispatchTouchEvent
APItoobtainthescreencoordinatesforeachinteraction(e.g.,click-
ingabutton), andleveragesUIAutomator[ 25]toobtain theinfor-
mationoftheGUIstateaftertheinteraction,whichincludesaview
treeandascreenshot.AsAndroidâ€™sGUIisrenderedbasedonan
XML layout file, the rendered GUI state can be represented as a
view tree, where the root element is a layout container such as
LinearLayout . Based on this view tree, we can use XPath to describe
thepathfromtherootelementtotheXMLelementoftheclicked
GUIwidget.Besides,aviewtreeprovidestheboundariesofeach
GUIwidget,whichenablesProMaltolocatetheGUIwidgetsinthe
viewtreeusingthescreencoordinatesofaninteraction,andthen
generate the XPath of the clicked widget accordingly. To ensurethe interaction event is fully executed when we capture the GUI
state,thedynamicexplorationaddsawaitingperiodoftwoseconds
between two interaction commands.
BuildingDynamicWTG.TobuildadynamicWTG,ProMalfirst
identifies windows from the data collected during app exploration.
ProMal leverages two types of information to uniquely identify a
window:(1) windowtype (i.e.,â€œActivityâ€,â€œDialogâ€,â€œMenuâ€)and(2)
resource name. For an activity, the resource name is the resourceid of the activity. For a menu, the resource name is the resourceid of the activity that owns the menu. For a dialog, the resourcename is the resource id of the activity that owns the dialog (i.e.,host activity) plus the method calls that create the dialog, whichcan distinguish different dialogs opened from the same activity.
Then, ProMal leverages the source window, the target window,
theclassoftheGUIwidget,thewidgetID,andthecoordinatesof
the interaction as the attributes to uniquely identify edges among
the windows. These identified edges and windows are then used to
build the dynamic WTGs.
5.3 Static WTG Analysis
Static WTG analysis applies static analysis to identify windows,GUI widgets, and the transitions among the windows. Based onour definition, three types of windows are considered: activities,
dialogs,andmenus.Notethatweconsiderboththeclassesâ€œCon-
textMenuâ€ and â€œOptionsMenuâ€ as menus. ProMal first applies the
existing static analysis technique (i.e., Gator) [ 47,70] to identify
edgesamongwindowsaswedefinedin5.1.ItperformsaconstraintgraphbasedreferenceanalysistomodelAndroidGUIrelatedobjects
(e.g., Activities, Views, and callback listeners) and their association
relationship. It then builds a WTG based on the analysis of theGUI event callbacks and the window lifecycle callbacks. Besides
modelingGUIrelatedobjects,ProMalextractsGUIwidgetinfor-
mation(i.e.,titleandtext)fromtheviewtree,whichislaterusedfor
matchingthedynamicWTGs.Foreventsthattriggertransitions,
our static analysis focuses on widget events (i.e., â€œClickâ€ and â€œLong
Clickâ€ events) and default events (i.e., pressing the back and the
menu buttons).
DialogTransitions.Existingstaticanalysis[ 47,69]mainlyidenti-
fiestransitionsfromactivitywindowtodialogs,butfailstoidentifytransitions from the dialogs to other windows. The major reason is
thatthese transitionsare oftenburiedin thecallbacksof dialogs,
which are defined using specific APIs in dialog builders (e.g., the
setItemsAPI of AlertDialog.Builder ). To identify these transitions,
we extend the static analysis techniques to identify these APIs,
andassociatethecallbacksbuiltthroughtheseAPIstothedialog
constructed by the dialog builders. Specifically, our extended static
analysis techniques identify the following dialog transitions:
â€¢To Other Dialogs : the analysis examines whether a known dialog
allocation API call is found in the associated callbacks.
â€¢To Host Activities : executing APIs such as dismissorcanceland
registering a nullornophandler will trigger a transition to the
hostactivityofthedialog.Todetectsuchtransitions,ouranalysis
first leverages the dynamic runtime information collected in
Section5.2toidentifythehostactivitiesforallthedialogs;ifa
dialogisnotcoveredduringdynamicexploration,ouranalysis
usesthecallbackregistrationsitesidentifiedbythestaticanalysis
techniques to infer the activity.
â€¢To Other Activities : the analysis examines the activity transition
calls(e.g., startActivity() and startActivityForResult )andtheval-
ues of their Intentarguments to identify the other activities.
â€¢To Previous Activities : calling APIs like Activity.finish will cause
transitionstothepreviousactivity.Thesetransitionsareinferred
based on the collected dynamic exploration traces.
1759
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:34:15 UTC from IEEE Xplore.  Restrictions apply. 5.4 Alignment of Static and Dynamic WTG
AfterobtainingthestaticWTGandtheDynamicWTGofanapp,
ProMalalignsthembymatching each edgeinthestaticWTGto
an edge in the dynamic WTG. We next describe the detailed steps.
MatchingWindows. ProMalmatcheswindowsusingdifferent
attributes based on their types: (1) for activities, ProMal checks
theiractivitynames;(2)formenus,ProMalchecksthenamesofthe
activities that create the menus; (3) for dialogues, ProMal checks
the call stack of the functions that creates the dialogs.
MatchingEventsandGUIWidgets.Tomatchtheeventonan
edge, we first check if the event types are identical. For widget
eventsthatassociatewithacertainGUIwidget,ProMaltriesto
obtainthewidgetIDinboththestaticWTGandthedynamicWTG
to match the widgets. However, the edges in the static WTGs do
not always possess a widget ID. Sometimes they can only provide
aclassnameoftheGUIwidgetsorevenprovidenothingtoinfer
the associated widgets. This imprecision of static analysis makes it
impossible for users to pinpoint the widgets, and hence they are
regarded as unmatched.
The edges in the static WTGs that cannot be matched will be
subject to further machine learning prediction.
5.5 Window Transition Prediction
Thewindowtransitionmodelisusedtopredicttheunverifiededges
in the static WTGs. As shown in the example of Figure 5, the win-
dowtransitionmodelconsistsoftheembeddingmodels(thewidget
embedding model and the window embedding model) and the link
predictor. Given a pair of a GUI widget and a window, ProMal
firstextractsthefeaturesfromthem,suchasscreensnapshotand
text,andthenfeedsthesefeaturesintotheembeddingmodelsto
obtaintheembeddingvectorsoftheGUIwidgetandthewindow.
Thelinkpredictorthenusesthetwoembeddingvectorstotellhow
likely there is a link between the widget and the window. We next
describe the embedding models and the link predictor in detail.
WindowEmbeddingModel. Thewindowembeddingmodeluses
the features of a window (i.e., screen snapshot, text information,
andGUItree)togeneratealow-dimensionalembeddingvector.We
next describe the features of a window:
â€¢Screenshot : The screenshot of a window displays all visible frag-
ments of an app activity in one image. Following the recent
successinusingCNNformodelingimages[ 22,29,37],weadopt
a block of DenseNet [ 31] to retrieve useful information from the
screenshots.
â€¢Text:Userscaneasilyunderstandthewindowâ€™spurposeandfunc-
tionalityfromthetextsinGUIs.Toutilizethesetexts,ProMal
segments the textsand uses a pre-trained Word2Vec [ 43] model
to generate the representations of each word. Then, ProMal
computes the average word embedding as the feature vector for
the window. Figure 5 shows how the window embedding model
computes the embedding of all the text in the target window.
â€¢GUITree:AGUItreecontainsalltheGUIwidgetsinawindow.
AGUIwidgetcanbeaninstanceofasystemwidgetclass(e.g.,
buttons and checkboxes) or a customized widget class extending
theclass android.view.View .Thus,thenameofaGUIwidgetclassâ€™s
superclass,which weregard as theGUI widgetâ€™sâ€œtagâ€, contains
the information about the basic functionality of this widget, andone-hot embedding is used to represent the tag. Besides the tags,
thepositionsandsizesoftheGUIwidgetsmayalsobeusedto
infer the functionality of widgets. To encode all the GUI widgets
in a window, ProMal traverses the GUI tree via in-order tree
traversaltogeneratea widgetsequence,andadaptsLSTM[ 22,29,
30] to learn the representation of the widget sequence. Figure
5 shows how the tags and other information in a GUI tree are
unrolled to a sequence.
The representations of these three features are then concatenated
and fed to a fully connected layer (FC) to generate the window
embedding vector.
Widget Embedding Model. To generate an embedding vector
for a GUI widget, besides the features of the source window, the
widgetembeddingmodelalsoextractsthefeaturesofaGUIwidget,
includingthewidgetscreenshot,thetext,andtheGUIproperties.
The feature extraction for the source window adopts the same
approachasthewindowembeddingmodel.Wenextdescribethe
other three features:â€¢
Widget Screenshot : The widget embedding model uses a block
ofDenseNet formodeling thescreenshotof thesource window,
andanotherblockofDenseNetformodelingthescreenshotof
the GUI widget, as shown in the red frame in Figure 5.
â€¢Text:Thewidgetembeddingmodelsegmentsboththetextsin
the source window and the GUI widget and feed both sequences
of words to the Word2Vec model to generate two vectors. As
showninFigure5,thewidgetembeddingmodelcomputesthe
word representation of the text â€œDoes not repeatâ€ in the GUI
widget as well as the average embedding of every word in the
source window.
â€¢GUIProperty :ThewidgetembeddingmodelencodestheGUItree
usingasimilarapproachasthewindowembeddingmodel.Apart
from the widget sequence of the source window, it also extracts
the tag,the size,and the position of theGUI widget,and feeds
these featuresto a fullyconnected layer togenerate a vector,as
shown in Figure 5.
Thefeature vectorsof thesource windowand theGUIwidget are
concatenatedandfedintoafullyconnectedlayertogeneratethe
widget embedding vector.
LinkPredictor. Thewidgetembeddingandwindowembedding
generatedbytheembeddingmodelswillbefedtothelinkpredictor
toinferwhetherthereisalinkbetweenthewidget-windowpair.
The link predictor is designed by leveraging the neural tensor net-
work (NTN) [ 52], which relates the two inputs (i.e., the widget em-
bedding and window embedding vectors) multiplicatively instead
ofonlyimplicitlythroughthenon-linearityaswiththestandard
neural networks where the entity vectors are simply concatenated.
Thus, it provides a more powerful way to infer the relationship
between entities than a standard neural network layer.
Letğ‘¤represent a GUI widget and ğ‘represent a window of
an app activity. ğœ™ğ‘¤is the widget embedding model and ğœ™ğ‘is the
window embedding model. The link predictor computes a score of
howlikelythereisalinkbetweenthem,whichisrepresentedby
Î¨(ğœ™ğ‘¤(ğ‘¤),ğœ™ğ‘(ğ‘)). The score is computed by using the following
1760
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:34:15 UTC from IEEE Xplore.  Restrictions apply. ,-#$ "* 00/ +$ 6-21!-2,#0

	
,-#$ "* 00(,$ / 6-21 !-2,#07
,-#$ "* 00/ +$ 6-21!-2,#07
7
,-#$ "* 00(,$ / 6-21!-2,#0

	
,-#$ "* 00/ +$ 6-21!-2,#07
,-#$ "* 00($4!-2,#07
,-#$ "* 00(,$ / 6-21!-2,#07
,-#$ "* 00+ &$($4!-2,#07
7$,0$$1
*-")
-/#$"
"-," 1
	


	
$,0$$1
*-")
-/#$"
"/$$,0'-1
$./$0$,1 1(-,
$51
$./$0$,1 1(-,
/$$
$./$0$,1 1(-,"-," 1


	



	
(,$ / 6-21

	/ +$ 6-217
($47(,$ / 6-217+ &$($477,/-**(,&8(1*$98"&%%98%%978-$0,-1/$.$ 197
8-$0,-1/$.$ 1983$/6'-2/983$/6# 697,/-**(,&
/ +$ 6-21

	(,$ / 6-217/ +$ 6-2177#(1$5177"/$$,0'-1
$./$0$,1 1(-,
$51
$./$0$,1 1(-,
/$$
$./$0$,1 1(-,
$,0$$1
*-")
-/#$"
"/$$,0'-1
$./$0$,1 1(-,
$51
$./$0$,1 1(-,
/$$
$./$0$,1 1(-,
 "-," 1	

			

	
			
	
8-$0,-1/$.$ 19
$51($4				

 
	

 

 
	


		
Figure 5: Illustration of how the window transition model predicts whether interacting with a GUI widget in a source window
causes a transition to a target window. The figure shows part of the extracted features for the GUI widget, the source window,
andthetargetwindow,andillustrateshowtheyareprocessedintheembeddingmodelstoproducetheembeddingvectors,
which are used by the link predictor to make the prediction.
function:
Î¨(ğœ™ğ‘¤(ğ‘¤),ğœ™ğ‘(ğ‘))=ğ‘¢ğ‘‡
ğ‘…ğ‘“(ğœ™ğ‘¤(ğ‘¤)ğ‘‡ğ‘Š[1:ğ‘˜]
ğ‘…ğœ™ğ‘(ğ‘)+ğ‘‰ğ‘…/bracketleftbiggğœ™ğ‘¤(ğ‘¤)
ğœ™ğ‘(ğ‘)/bracketrightbigg
+ğ‘ğ‘…)
(1)
whereğ‘“=ğ‘¡ğ‘ğ‘›â„isastandard non-linearity applied element-wise
andğ‘Š[1:ğ‘˜]
ğ‘…âˆˆRğ‘‘Ã—ğ‘‘Ã—ğ‘˜is a tensor. ğœ™ğ‘¤(ğ‘¤)ğ‘‡ğ‘Š[1:ğ‘˜]
ğ‘…ğœ™ğ‘(ğ‘)is a bilinear
tensor product and resultsin a vector ğ‘‘âˆˆğ‘…ğ‘˜, where each entryis
computedbyoneslice ğ‘š=1,...,ğ‘˜ofthetensor: ğœ™ğ‘¤(ğ‘¤)ğ‘‡ğ‘Š[ğ‘š]
ğ‘…ğœ™ğ‘(ğ‘).
Theotherparametersforrelation Rarethestandardformofaneural
network: ğ‘‰ğ‘…âˆˆRğ‘˜Ã—2ğ‘‘andğ‘ˆâˆˆRğ‘˜,bğ‘…âˆˆRğ‘˜[52].
Two-Phase Training. Due to the large amount of parameters
in the model, we have to use a correspondingly large amount of
widget-windowpairsasthetrainingdata,whichareinfeasibleto
be manually labeled. To address this challenge, we adopt a two-
phase training process. We first apply dynamic app exploration
techniques[ 26,41,54]to automaticallyexplore alargenumber of
appsdynamicallyandpre-trainthemodelbasedonthedynamically
observed transitions. The variety of apps makes the embedding
models general enough. As these transitions bias towards the tran-
sitions that can be easily found by dynamic analysis, we further
finetunethepre-trainedmodelbasedonthemanuallyidentified
window transitions from a smaller set of apps. In the fine tuningprocess,theparametersoftheembeddingmodelsarefrozen(i.e.,
weights and biases), meaning that these parameters do not change,
whiletheparametersofthelinkpredictoraresettrainabletoadapt
the patterns related to window transitions.
6 EVALUATION
In this section, we seek to evaluate the effectiveness of ProMal to
constructwindowtransitiongraphsforreal-worldAndroidapps.
WeimplementProMalinJava.ProMalusesGator[ 47,69,70],
astate-of-the-artstaticAndroidGUIanalysistool,tobuildstatic
WTGs, and uses Paladin [ 41], a state-of-the-art app exploration
tool,tobuilddynamicWTGs.ProMalalsousesXposed[ 2]toin-
strumentappsforcollectingwindowtransitionsandotherruntime
information. The window transition prediction is implemented us-
ingKeras[ 13].Specifically,weaimtoanswerthefollowingresearch
questions:
â€¢RQ1:How effectively can ProMal build the WTGs?
â€¢RQ2:How effectively can ProMal improve over Gator and
Paladin?
â€¢RQ3:How effectively can the NTN model and the two-phase
training improve ProMalâ€™s window transition prediction?
1761
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:34:15 UTC from IEEE Xplore.  Restrictions apply. Table 1: 40 apps used in our evaluations. The 35 real apps
are sorted by their densities and divided evenly in 7 groups.
F-Droid is the last group.
Group Density LOC # Nodes # Edges
Group 1 1.5â€“3.25 33,048 28 61
Group 2 3.3â€“4.8 46,508 28 59
Group 3 5.2â€“7.8 78,217 32 83
Group 4 8.8â€“12.7 344,144 40 136
Group 5 14.0â€“23.6 389,586 72 186
Group 6 25.5â€“37.4 823,086 76 246
Group 7 37.6â€“155.6 55,259 43 122
F-droid 1.5â€“35.8 714,044 50 178
Total â€“2,483,892 369 1,071
6.1 Subjects and Evaluation Setup
WeuseadiversifiedsetofappsfromGooglePlay[ 24]asourevalu-
ationsubjects.Theseappsarefrom14categories,suchasGame,En-
tertainment, and Education. We also include popular open-sourced
apps from F-Droid [ 20] in our evaluation subjects. Once we down-
loadedanapp,weappliedGatortobuildstaticWTGsandexcluded
theappswithlessthan3windows,sincetheirWTGsarefairlysim-
pleandwillnotbepropersubjectsforassessingtheeffectiveness
of ProMal. In total, we examined 4,326 apps and got 2,216 apps
with at least 3 windows. As shown in Figure 2, a node (window)
may have multiple edges (transitions) to another node in WTGs,
making the WTGs more complex than the WTGs that have one or
two transitions among windows. Thus, we use densityto represent
the complexity of WTGs, where the density is computed using the
numberofedgesdividedbythenumberofnodesinstaticWTGs.
Note that the edges in static WTGs may be infeasible, but theycan still form a reasonable estimation of the actual WTG. Based
on the density, we divided the apps into 7 groups equally, and ran-
domly sample a subset from each group to evaluate ProMal on
theWTGsofdifferentcomplexities.Asthereisnopubliclyavail-
able groundtruth WTG for these apps, we need to construct the
groundtruth WTGs by manually exploring the apps and inspecting
theirsourcecode.Becausethenumberofedgesgrowsdrastically
as the complexity of the App grows, collecting the groundtruth
requiresa non-trivialeffort.Within ouraffordableefforts, weran-
domly chose 5 apps from each group as our evaluation subjects.
Together with the 5 apps chosen from F-Droid, we have 40 apps
in 8 density groups. These apps also belong to different popular
categories (e.g., sports, game, tools). The total LOC of these apps is
âˆ¼2.5 million. The summary of the apps is shown in Table 1, and
more details can be found on our website [4].
We then applied Paladin and ProMal on these 40 apps to build
dynamicWTGsandperformedwindowtransitionpredictionsto
buildtheoptimizedWTGs.Paladinisadynamicappexploration
toolthat modelsview treesas UIstates toavoid visitingthe same
UIstatesduringtheexploration.Ittriggersactionablewidgetsin
a Depth-First-Search manner to exercise as many behaviors as
possible.AmongalltheappsanalyzedbyPaladin,theminimum
running time is 1 .35 minutes, and the maximum time is around 97
minutes. The average running time for all the apps is about 15 .8
minutes per app.ObtainingGroundtruthWTGs.Weinstalledtheseappsonan
Android phone, and manually explored the apps by interacting
with each GUI widget to construct the groundtruth WTGs. We
then matched the manually explored edges to the static WTGs,
and then manually verify the unmatched edges in the static WTGs.
Asdescribed inthe studies[ 69,70],due tothe deficienciesin win-
dow/widget modeling [ 47] and event handler analysis [ 69], Gator
willincorrectlyincludeinfeasibleedgesandalsomisssomefeasible
edges in the built WTGs. Thus, we further manually inspected the
decompiled source code using Jadx [ 51] in the real apps and the
source code in open source apps. We analyzed all the method calls
ofstartActivity and all the callbacks of GUI widgets to identify the
windowsandtransitionsthatwecannotobserveinthestaticWTGs.
The statistics of the groundtruth WTGs are shown in Table 1.
Training Prediction Model. To train the prediction model, we
collect the most popular 30 apps (indicated by the downloading
times)fromeachcategoryoftwoappmarketplaces,i.e.,GooglePlay
and Wandoujia [ 58] (a leading Android app marketplace in China).
Then we use Paladin to perform dynamic analysis on each of the
collected apps, and finally get dynamic WTGs from 1,625 apps. In
thepre-trainingprocess,themodellearnstheparametersforthe
embeddingmodelusingthesedynamicWTGs.Inthefine-tuning
process,themodellearnstoexploretherelationshipbetweenan
appwidgetandanappwindow.Themodelisevaluatedusing10-
fold cross validation, which is repeated 10 times. For the model
parameters, we set the max word sequence length to 512, the word
embeddingsizeto100,theLSTMstatesizeto72,thefullyconnectedlayer(FC)unitsofboththeembeddingmodelsto64,andtheoutput
size of NTN layer to 16. We take a batch size of 32 in both thepre-training and fine-tuning processes. Since there are far morenegative samples (i.e., widget-window pairs without edges) than
the positive samples (i.e., widget-window pairs with edges) in the
dataset,weapplythemethodofnegativesampling,bywhichwe
sample negative samples randomly for training. The final number
of the negative samples is four times of the number of positivesamples, so the class weights for the negative samples and the
positive samples are set to 1 and 4, respectively.
Metrics. To measure the effectiveness of ProMal, we measurethe nodes and edges of the WTGs built by ProMal, Gator, and
Paladin,andcomparetheseWTGswiththegroundtruthWTGsto
computetheprecision,recall,and ğ¹1-scoreforthedetectededges.
An edge (i.e., a window transition) in a WTG is considered as a
true positive ( ğ‘‡ğ‘ƒ) only if the nodes (i.e., windows) of the edge
and the edge both match the corresponding nodes and edge in the
groundtruth WTG; otherwise, it is considered as a false positive
(ğ¹ğ‘ƒ).IfaWTGmissesanedgeinthegroundtruthWTG,weconsider
the missing edge as a false negative ( ğ¹ğ‘); otherwise, it is a true
negative ( ğ‘‡ğ‘). Based on these values, we compute the precision as
ğ‘ğ‘Ÿğ‘’ğ‘=ğ‘‡ğ‘ƒ
ğ‘‡ğ‘ƒ+ğ¹ğ‘ƒ, recall as ğ‘Ÿğ‘’ğ‘=ğ‘‡ğ‘ƒ
ğ‘‡ğ‘ƒ+ğ¹ğ‘, andğ¹1=2Â·ğ‘ğ‘Ÿğ‘’ğ‘Â·ğ‘Ÿğ‘’ğ‘
ğ‘ğ‘Ÿğ‘’ğ‘+ğ‘Ÿğ‘’ğ‘.
6.2 RQ1: Overall Effectiveness
Table2showsthedetailsoftheWTGsbuiltbyProMalforeach
app. Column â€œ# Nodesâ€ shows the number of nodes in the WTG.
Columnâ€œ#Edgesâ€showsthenumberofedgesintheWTG.Column
â€œPrec. (Edges)â€ and Column â€œRecall (Edges)â€ shows the precision
and the recall of the detected edges. As we can see, on average,
1762
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:34:15 UTC from IEEE Xplore.  Restrictions apply. Table 2: Details of the WTGs built by ProMal
App Group # Nodes # Edges Prec. (Edges)âˆ—Recall (Edges)âˆ—
Group 1 26 56 89.00% 92.86%
Group 2 24 54 100.00% 92.95%
Group 3 28 63 97.33% 75.40%
Group 4 34 122 81.29% 71.08%
Group 5 52 148 83.98% 73.59%
Group 6 51 155 82.36% 59.34%
Group 7 36 107 90.37% 80.47%
F-Droid 27 154 97.09% 91.84%
Total 275 859 90.18% 79.69%
âˆ—Prec. and Recall are average values.
ProMal achieves a precision of 90 .18%, a recall of 79 .69%, and a
ğ¹1-scoreof82 .82%.Inparticular,ProMalachieves97 +%precision
in Groups 2 and 3, and 92 +% recall for Groups 1 and 2. It also
achieves 91 +% precision and recall for the F-droid group. These
resultsshowthat ProMalishighlyeffectiveinidentifyingfeasible
edges in building WTGs.
Combination of Gator and Paladin. We comparethe WTGs
built by ProMal and the combination of Gator and Paladin. The
resultsshowthattheWTGsbuiltbycombiningtheWTGsof Gator
andPaladinachieveaprecisionof53 .95%,arecallof88 .47%,and
ağ¹1-score of 61 .93% on average. Since all the edges produced by
Paladinarefeasibleedges,thelowprecisioniscausedbyahuge
numberofinfeasibleedgesintroducedby Gator.Forthe40apps
in our dataset, Gator yields 3 ,236 edges in total, while only 12 .2%
can be found in the WTGs built by Paladin. Thus, the majority
ofedgesinGatorarefurtheranalyzedbythewindowtransition
prediction.Forthe2 ,841unverifiededges,47 .1%(1,337)containsin-
completeinformation(e.g.,missingUIlayoutinformationorunable
to locate the widget based on Gatorâ€™s widget information). Our
modelhenceregardstheseedgesasinfeasibleedgesandpredicts
the remaining 1 ,504 edges. It is also noteworthy that 245 of the
remaining edges from Gator are not specified with a widget ID.
Instead,thewidgetsoftheseedgesareoftenassignedtoawhole
window or an anonymous MenuItem, or a certain type of class name.
Toaddresssuchimprecisionof Gator,ProMalconsidersallthe
clickablewidgetsthatfitthewidgetinformationprovidedbyGator
inthesourcewindowoftheseedgesastheedgesâ€™sourcewidgets,
and predicts whether the edges are feasible. For edges with backevents,weconsiderthemasfeasibleifanon-backedgefromthe
target window to the source window can be found in the predicted
WTG. Only the edges that are predicted to be feasible edges are
kept in the final WTGs. With the window transition prediction,the precision of the built WTGs is significantly improved (from53
.95% to 90 .18%), which results in a significant improvement of
ğ¹1-score(from61 .93%to82 .82%).Theseresultsclearlydemonstrate
the effectiveness of ProMal in using a synergy approach of program
analysis and machine learning.
FPs and FNs. Due to the ğ¹ğ‘ƒs and the ğ¹ğ‘s, ProMal achieves
a relatively low precision in Groups 4, 5, 6 and a relatively low
recallinGroup6(i.e.,morethan5%lower).Figure6illustrateshowProMalproducesan
ğ¹ğ‘ƒandanğ¹ğ‘.Thewindowontheleftisfrom
the activity MainPage. ProMal correctly identifies a transition from
MainPageto the activity Preference , resulted from clicking the â€œinfoâ€
button(highlightedingreen).However,ProMalalsoincorrectly
identifiesanothertransitiontotheactivity Preference ,resultedfrom
FP
TP
FN
Figure 6: Example ğ¹ğ‘ƒandğ¹ğ‘produced by ProMal
Table 3: Details of the static WTGs built by Gator
App Group # Nodes # Edges Prec. (Edges)âˆ—Recall (Edges)âˆ—
Group 1 20 36 62.64% 46.22%
Group 2 23 48 62.36% 48.54%
Group 3 32 120 64.87% 77.00%
Group 4 44 212 48.99% 71.92%
Group 5 79 552 28.49% 77.02%
Group 6 117 832 28.47% 56.51%
Group 7 481219 22.75% 69.48%
F-Droid 29 217 50.00% 32.44%
Total 392 3,236 46.07% 59.89%
âˆ—Prec. and Recall are average values.
clickingtheâ€œHighâ€button(highlightedinred).This ğ¹ğ‘ƒiscausedby
the patterns learned by the machine learningmodel. Figure 6 also
includesa ğ¹ğ‘producedbyProMal.Inthe Preference activity,ifthe
â€œMoreAppâ€buttonisclicked,theappwilltransittothe Moreactivity,
which serves as a built-in browser and displays a website to users.
Due to the drastic changes of the UI states, the window transition
predictionmodelcannotinferanycloserelationshipbetweenthe
sourcewindowandthetargetwindowfromtheirUIlayoutsand
screen snapshots, and thus produces a ğ¹ğ‘.
Furthermore, the limitations of Gatorâ€™s model hinders the per-
formance of ProMal. First, gator have trouble distinguishing wid-
gets without widget IDs and will associate them with all pos-sible handlers declared in the same method. This type of over-approximation makes ProMal generate extra edges. Second, a
large number of false negatives are caused by Gator failing to iden-
tify dialog instances. Thus ProMal cannot detect transitions from
these dialogs.
6.3RQ2: Comparison with Paladin and Gator
Comparison with Gator Table 3 shows the details of the WTGs
built by Gator for each app. As indicated by the results, many
oftheedgesfoundbyGatorareinfeasibleedges,i.e., ğ¹ğ‘ƒs.These
resultsshowthattheWTGbuiltbyGatorforeachappisrather
inaccurate, achieving a precision of 46 .07%, a recall of 59 .89%, and
ağ¹1-score of 46 .24%.
Uponfurtherinvestigations,wefindthatGatorperformspoorly
on both precision and recall for two main reasons. The first reason
is due to the imprecision of Gator. We empirically find out that
Gatoroftenyieldsmultipletransitionswithdifferenttargetwin-
dows from the same UI widget, while most of them turn out to be
infeasible.Figure7showsanexampletransitionfromthegameapp
â€œcom.twobitinc.cornholescoreâ€.Theleftwindowisfromtheactivity
OptionsActivity ,whichshows5buttonsforuserstocustomizecer-
taingameparameterssuchasthecoloroftheteamandthescoring
1763
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:34:15 UTC from IEEE Xplore.  Restrictions apply. Click
Figure 7: Example ğ¹ğ‘ƒproduced by Gator
Click
Figure 8: Example ğ¹ğ‘produced by Gator
mode.Whentheâ€œSetColorâ€buttonisclicked,theUItransitstothe
activity RgbPickActivity . However, due to the imprecision in asso-
ciatingwidgetIDsandeventhandlermethods,Gatorinfersthat
clicking any of the button will transit to 3 different activities. In
this way, Gator infers 2 infeasible edges for each of the 5 buttons,
and results in 10 ğ¹ğ‘ƒedges for a single activity, which significantly
reduces Gatorâ€™s precision.
Second, Gator often fails to identify transitions between activi-
ties due to the limitationin modeling certain transitions. Figure 8
shows an example transition for the app â€œcom.jacobsmedia.spartsâ€.
Upon clicking the â€œhockeyâ€ button, the app transits from the ac-
tivity Mainto another activity XmlPage. ButGator fails to infer this
edge.Actually,thebuiltWTGforthisappindicatesthattheactivity
XmlPage, along with two other activities, have only transitions to
themselves. However, there are in fact 9 edges among the three
activities in the groundtruth WTGs, which cause 9 ğ¹ğ‘s for Gator.
ComparedtoGator,ProMalsignificantlyimprovesboththe
precisionandtherecallinbuildingWTGs,withthehelpofdynamic
analysis and window transition prediction. The predictions on the
unverifiededgesintotalruleout2 ,351outof2 ,399ğ¹ğ‘ƒedges,hence
significantly improving the precision of ProMal by 95 .02%, from
46.24%to90 .18%.Byaddingthe708edgesdetectedbyPaladinand
the63edgesfromGatorâ€™sWTGs,therecalloftheWTGbuiltby
ProMal is improved from 59 .89% to 79 .69%.
Comparison with Paladin. Table 4 shows the details of the
WTGs built by Paladin. As Paladin adopts dynamic analysis, theTable 4: Details of the dynamic WTGs built by Paladin
App Group # Nodes # Edges Prec. (Edges)âˆ—Recall (Edges)âˆ—
Group 1 26 55 100.00% 91.04%
Group 2 24 44 100.00% 76.36%
Group 3 26 54 100.00% 65.91%
Group 4 33 104 100.00% 67.68%
Group 5 51 122 100.00% 64.31%
Group 6 45 107 100.00% 46.61%
Group 7 35 82 100.00% 68.23%
F-Droid 45 140 100.00% 89.87%
Total 285 708 100.00% 71.25%
âˆ—Prec. and Recall are average values.
precision in finding feasible edges is always 100%. On average, the
WTGs built by Paladin achieve an average recall of 71 .25% in
findingfeasibleedges.WecanobservethatProMalimprovesthe
built WTGs with the help of static analysis and window transition
prediction. On average, ProMal improves the recall of Paladin
by 8.44% and in turn improves the ğ¹1-score by 2 .35%. In particular,
ProMal improves the recall significantly for Group 2 (from 76 .36%
to92.95%)andGroup7(from68 .23%to80 .47%).Theincreasedrecall
willenabletestingtocovermorebehaviorswithtolerableextraefforts
on the reported infeasible transitions, with the precision still being
90+%.
6.4 RQ3: Window Transition Prediction
We first compare the performance of the alternative models for the
link predictor, and then measure the improvement brought by the
two-phase training.
ComparisonofLink PredictorModels.WecompareourNTN
modelwiththebilinearmodel[ 33,55],whichisalsoaneffective
way to model the relationships between entities. We train both
models using the window transitions collected from the dataset
of1,625apps,whichareautomaticallyexploredbyPaladin.The
results show that NTN achieves a precision of 96 .97%, a recall of
95.26% and a ğ¹1-score of 95 .73%, while the bilinear model only
achieves a precision of 83 .64%, a recall of 75 .40% and a ğ¹1-score of
73.98%. Thus, NTN is a better choice for the link predictor.
EffectivenessofTwo-PhaseTraining.Byperformingourtwo-
phasetraining,thepredictionmodelachievesaprecisionof50 .00%,
a recall 73 .91%, and a ğ¹1-score of 59 .65%. However, if we directly
use90%ofthegroundtruthWTGstotrainthemodel,theprediction
modelachievesaprecisionof33 .82%,arecallof67 .65%,anda ğ¹1-
scoreof45 .10%.Thisclearlydemonstratestheimprovementbrought
bythetwo-phasetraining.Moreover,eventhoughthetwo-phase
training improves the performance of the prediction, the overall
performanceofpredictionisstillnotsatisfactory.Thereasonisthat
fortheseunverifiededges,ProMalusesstaticGUIrendering[ 3,32]
to render thelayout files toobtain the view treesand screenshots,
which are not as accurate as dynamic analysis. Even so, when it is
applied on only the unverified edges, ProMal can achieve further
improvement by combining the prediction results of the unverified
edges with the verified edges, improving the ğ¹1-score to 82 .82%. If
we use the model without pre-training in ProMal, the precision
dropsto61 .12%,therecallbecomes78 .31%,andthe ğ¹1-scoreisonly
65.33%, indicating the importance of two-phase training.
1764
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:34:15 UTC from IEEE Xplore.  Restrictions apply. 7 DISCUSSION
StaticAnalysis.ProMalbuildsthestaticanalysisuponGator[ 47,
69,69], and extends the static analysis to detect dialog transitions
buried in the callbacks of dialogs. While Gator provides a compre-
hensivemodelofAndroidenvironment(e.g.,backstacks,events,
and callbacks), it adopts an over-approximation algorithm that ap-
pliesonlyweakupdateswhenassociatingthewidgetIDsandevent
handler callbacks. Such problems can be mitigated by applying
moreexpensivebutpreciseanalysissuchaspath-sensitiveanalysis
like FlowDroid [6] and symbolic execution [21, 34, 36, 44, 49].
DynamicAnalysis.Dynamicappexploration[ 26,27,40,41,54]
hasbeenusedtogenerateGUItests,discoverappbehaviors,andde-
tectviolationsadfraud.ProMalleveragesdynamicappexploration
to build the dynamic WTG for an app. While these approaches can
automaticallytrigger both UIwidgetevents andhardwareevents
(e.g., pressing BACK button), they still suffer from coverage issues
duetovariousenvironmentdependencies.Thisissuecanbemit-igated by using developer-provided test cases as seeds [
8,71]t o
improve app exploration.
Window Transition Prediction. Due to the functionality and
designdifferencesbetweendifferentapps,manytransitionfeaturesarequiteunique.Therefore,thepredictionmodelhasarathergoodperformance in apps similar to its training set and performs poorlyinotherapps.Infuturework,weplantoextractmorefeaturessuchas whether the widget is clickable or not to improve the prediction.
Threats to Validity Our evaluation subjects may not be represen-
tativeoftheentiremarket.Tomitigatetheissue,wechooseapps
that have WTGs of different complexities, and the subjects usedfor pre-training (1,625 apps) also alleviate the issue. We plan to
addressthislimitationbyincludingmorediversifiedmarketapps
to further reduce the threats. Also, we discard apps that cannot be
analyzed by either Paladin or Gator, which are mainly caused by
thecompatibilityproblemofthelibrariesandSDKversions.This
can be mitigated by upgrading the libraries and adding support for
later SDK versions. Inaccuracies in the manual code inspection are
inevitableduetothelackofthegroundtruthWTGs.Inaddition,
there may be human errors in collecting statistics and studying the
evaluation results. These threats are mitigated by double-checking
all manual work and ensuring that the results were agreed upon
by at least two authors.
8 RELATED WORK
AndroidUIModelling.Rountevetal.â€™sGator[ 47,69,70]isamong
the first to provide a static analysis framework for modeling An-droidappsâ€™UIs.GatormodelsGUI-relatedAndroidobjects,their
flowthroughtheapplication,andtheirinteractionswitheachother
via the abstractions defined by the Android platform [ 47], and pro-
vides a context-sensitive static analysis of callback methods to link
callbackmethodstoGUIobjects[ 69].Builtuponthisstaticanalysis,
Gatorfurthergeneralizestheanalysiswithexplicitmodelingofthe
window stack to generate a static WTG [ 70]. Besides static anal-
ysis,dynamicanalysisbuildsaUImodelthatrepresentsdifferent
states for windows, which can be considered as a finer grained
WTG[26,40,41,54].TheseUIstatesareusedtoguidethedynamic
exploration to either discover more behaviors or identify certain
violations(e.g.,adfrauds).ProMalâ€™sWTGanalysisisbuiltuponthesestaticanddynamicanalysistechniques,wherethedynamic
analysis is used to verify the results of the static analysis.
Hybrid Program Analysis. Hybrid program analysis has been
used toimprove theprecision of variousstatic analysis.Check â€™nâ€™
crash [15,16] takes the error conditions inferred using theorem
provingtechniquesbyastaticcheckerandproducestestcasesto
determine whether an error truly exists. This technique has shown
advantages over both static checking and automatic testing indi-
vidually. Blended analysis [ 18,61] combines dynamic and static
analysisbyfirstapplyingdynamicanalysistocaptureruntimeinfor-
mation and then performing static analysis on each dynamic trace
toidentifysolutions,whichhasbeenshowntoachievepromisingre-sultsinperformanceunderstandingandtaintanalysis.Anotherim-portantlineofhybridanalysisisconcolictesting[
21,49,57,66,67],
where dynamic analysis is used to collect constraints along the
executedprogrampathsandstaticsymbolicanalysisandconstraint
solver are used to derive new inputs to explore more program
paths. ProMalâ€™s â€œtribrid analysisâ€ is inspired by the idea of hybrid
program analysis, where machine learning techniques are used to
address the limitations of both static and dynamic analysis.
Machine-Learning Based Link Prediction. Link prediction is a
fundamental problem in link mining that attempts to predict the
existence of a link between two nodes based on observed links and
theattributesofnodes[ 50].Linkpredictionandrecommendation
problemwasfirstproposedbyLiben-nowellet.al[ 39].Tradition-
ally, there are two ways of making link predictions: one way tomake this prediction is based on structural properties of the net-
work [39], another way is to make use of attribute information for
linkprediction[ 46].Recently,alotofmethodsbasedonmachine
learningtechniquesareproposed[ 35,38,48].Thefirsttostudythe
link prediction problem as a supervised learning problem is Hasan
et. al. [28], where the existing and non-existing social links are
treatedasthepositiveandnegativeinstancesrespectively.ProMal
is related to link prediction but focuses on predicting transitions
among windows using app-specific UI information.
9 CONCLUSION
WehaveproposedProMal,asynergisticanalysisthatcombines
staticanalysis,dynamicanalysis,andmachinelearningtoconstruct
a precise WTG. ProMal applies static analysis and dynamic analy-
sis to build the static WTG and the dynamic WTG for an app, and
identifies the verified edges by matching the edges in these two
WTGs.ProMalthenleveragesmachinelearningtechniquestopre-
dicttheunverifiededgesintheWTGtodeterminewhethertheyare
feasible transitions. Our evaluations on 40 real-world apps demon-
strate the superiority of ProMal in building WTGs over static
analysis and dynamic analysis when they are applied separately.
ACKNOWLEDGMENTS
Xusheng Xiaoâ€™s work is partially supported by the National Sci-
ence Foundation under the grants CCF-2046953 and CNS-2028748.
Xusheng Xiao is the corresponding author.
REFERENCES
[1]1999. XMLPathLanguage(XPath). https://www.w3.org/TR/1999/REC-xpath-
19991116/.
[2]2017. Xposed. http://repo.xposed.info/module/de.robv.android.xposed.installer
1765
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:34:15 UTC from IEEE Xplore.  Restrictions apply. [3]2019. Android Development Tools (ADT).
https://marketplace.eclipse.org/content/android-development-tools-eclipse.
[4] 2021. Promal Project Website. https://github.com/promal-android/Promal.
[5]2021. UI/ApplicationExerciserMonkey. https://developer.android.com/studio/
test/monkey. Accessed: 2021-01-30.
[6]Steven Arzt, Siegfried Rasthofer, Christian Fritz, Eric Bodden, Alexandre Bar-
tel,JacquesKlein,YvesLeTraon,DamienOcteau,andPatrickMcDaniel.2014.
FlowDroid: Precise context, flow, field, object-sensitive and lifecycle-aware taint
analysisforAndroidapps.In ProceedingsoftheACMConferenceonProgramming
Language Design and Implementation (PLDI).
[7]TanzirulAzimandIulianNeamtiu.2013. Targetedanddepth-firstexploration
forsystematictestingofAndroidapps.In ProceedingsoftheACMInternational
ConferenceonObjectOrientedProgrammingSystemsLanguages&Applications
(OOPSLA).
[8]Domagoj BabiÄ‡, Lorenzo Martignoni, Stephen McCamant, and Dawn Song. 2011.
Statically-directed dynamic automated test generation. In Proceedings of the
International Symposium on Software Testing and Analysis (ISSTA).
[9]AbhijeetBanerjee,LeeKeeChong,ClÃ©mentBallabriga,andAbhikRoychoudhury.
2018. EnergyPatch: Repairing resource leaks to improve energy-efficiency of
Android apps. IEEE Transactions on Software Engineering (TSE) 44, 5 (2018),
470â€“490.
[10]AbhijeetBanerjee,LeeKeeChong,SudiptaChattopadhyay,andAbhikRoychoud-hury.2014. Detectingenergybugsandhotspotsinmobileapps.In Proceedingsof
the ACM International Symposium on Foundations of Software Engineering (FSE).
[11]Farnaz Behrang and Alessandro Orso. 2019. Test migration between mobileapps with similar functionality. In Proceedings of the IEEE/ACM International
Conference on Automated Software Engineering (ASE).
[12]buildfire. 2020. Mobile App Download and Usage Statistics (2020).
https://buildfire.com/app-statistics/. Accessed: 2021-01-30.
[13] FranÃ§ois Chollet et al. 2015. Keras. https://keras.io.[14]
Shauvik Roy Choudhary, Alessandra Gorla, and Alessandro Orso. 2015. Auto-mated test input generation for Android: Are we there yet?. In Proceedings of
IEEE/ACM International Conference on Automated Software Engineering (ASE).
[15]Christoph Csallner and Yannis Smaragdakis. 2005. Check â€™Nâ€™ Crash: Combining
static checking and testing. In Proceedings of the International Conference on
Software Engineering (ICSE).
[16]Christoph Csallner, Yannis Smaragdakis, and Tao Xie. 2008. DSD-Crasher: A
hybrid analysis tool for bug finding. ACM Transactions on Software Engineering
and Methodology (TOSEM) 17, 2 (2008), 8:1â€“8:37.
[17]Zhen Dong, Marcel BÃ¶hme, Lucia Cojocaru, and Abhik Roychoudhury. 2020.
Time-traveltestingofAndroidapps.In ProceedingsoftheACM/IEEEInternational
Conference on Software Engineering (ICSE).
[18]Bruno Dufour, Barbara G. Ryder, and Gary Sevitsky. 2007. Blended analysis for
performance understanding of framework-based applications. In Proceedings of
the ACM International Symposium on Software Testing and Analysis (ISSTA).
[19]Michael D. Ernst, RenÃ© Just, Suzanne Millstein, Werner Dietl, Stuart Pernsteiner,
Franziska Roesner, Karl Koscher, Paulo Barros, Ravi Bhoraskar, Seungyeop Han,
Paul Vines, and Edward XueJun Wu. 2014. Collaborative verification of informa-
tionflowforahigh-assuranceappstore.In ProceedingsoftheACMConference
on Computer and Communications Security (CCS).
[20] F-Droid. 2021. FOSS Apps for Android. https://f-droid.org/[21]
PatriceGodefroid,Nils Klarlund,andKoushikSen.2005. DART:Directedauto-
mated random testing. In Proceedings of the ACM Conference on Programming
Language Design and Implementation (PLDI).
[22]IanJ.Goodfellow,YoshuaBengio,andAaronC.Courville.2016. DeepLearning.
MIT Press. http://www.deeplearningbook.org/
[23]Google.2017. AndroidViewSystem. https://developer.android.com/guide/topics/
ui/declaring-layout.html.
[24] Google. 2017. Google Play Store. https://play.google.com/store?hl=en.[25]
Google. 2020. UI Automator. https://developer.android.com/training/testing/ui-
automator.
[26]Tianxiao Gu, Chengnian Sun, Xiaoxing Ma, Chun Cao, Chang Xu, Yuan Yao,Qirun Zhang, Jian Lu, and Zhendong Su. 2019. Practical GUI testing of An-droid applications via model abstraction and refinement. In Proceedings of the
International Conference on Software Engineering (ICSE).
[27]Shuai Hao, Bin Liu, Suman Nath, William G. J. Halfond, and Ramesh Govindan.
2014. PUMA: Programmable UI-automation for large-scale dynamic analysis
ofmobileapps.In ProceedingsoftheAnnualInternationalConferenceonMobile
Systems, Applications, and Services (MobiSys).
[28]MohammadAlHasan,VineetChaoji,SaeedSalem,andMohammedZaki.2006.
Linkpredictionusingsupervisedlearning.In ProceedingsofSDMworkshopon
Link Analysis, Counterterrorism and Security.
[29]GeoffreyE.Hinton,SimonOsindero,andYee-WhyeTeh.2006. Afastlearning
algorithm for deep belief nets. Neural Computing 18, 7 (2006), 1527â€“1554.
[30]Geoffrey E Hinton and Ruslan R Salakhutdinov. 2006. Reducing the dimensional-
ity of data with neural networks. Science313, 5786 (2006), 504â€“507.
[31]Gao Huang, Zhuang Liu, Laurens Van Der Maaten, and Kilian Q Weinberger.2017. Densely connected convolutional networks. In Proceedings of the IEEEConference on Computer Vision and Pattern Recognition (CVPR).
[32]Jianjun Huang, Zhichun Li, Xusheng Xiao, Zhenyu Wu, Kangjie Lu, Xiangyu
Zhang, and Guofei Jiang. 2015. SUPOR: Precise and scalable sensitive user input
detection for Android apps. In Proceedings of the USENIX Security Symposium
(USENIX Security).
[33]Rodolphe Jenatton, Nicolas Le Roux, Antoine Bordes, and Guillaume Obozinski.
2012. A latent factor model for highly multi-relational data. In Proceedings of the
Advances in Neural Information Processing Systems (NIPS).
[34]Jinseong Jeon, Kristopher K. Micinski, and Jeffrey S. Foster. 2012. SymDroid:
Symbolicexecutionfordalvikbytecode.TechnicalReport.CS-TR-5022,Department
of Computer Science, University of Maryland, College Park.
[35]Mohammad Mehdi Keikha, Maseud Rahgozar, and Masoud Asadpour. 2021.DeepLink: A novel link prediction framework based on deep learning. Jour-
nal of Information Science 47, 5 (2021), 642â€“657.
[36]James C. King. 1976. Symbolic execution and program testing. Communications
of ACM (CACM) 19, 7 (1976), 385â€“394.
[37]Yann LeCun, Yoshua Bengio, et al .1995. Convolutional networks for images,
speech, and time series. The handbook of brain theory and neural networks 3361,
10 (1995), 1995.
[38]XinLiandHsinchunChen.2009. Recommendationaslinkpredictioninbipartite
graphs: A graph kernel-based machine learning approach. Decision Support
Systems54, 2 (2009), 213â€“216.
[39]David Liben-nowell and Jon Kleinberg. 2010. The link prediction problem forsocial networks. Journal of the American Society for Information Science and
Technology (JASIST) 58, 7 (2010), 1019â€“1031.
[40]BinLiu,SumanNath,RameshGovindan,andJieLiu.2014. DECAF:Detectingandcharacterizing Ad fraud in mobile apps. In Proceedings of the USENIX Symposium
on Networked Systems Design and Implementation (NSDI).
[41]Yun Ma, Yangyang Huang, Ziniu Hu, Xusheng Xiao, and Xuanzhe Liu. 2019.
Paladin:AutomatedgenerationofreproducibletestcasesforAndroidapps.In
Proceedings of the International Workshop on Mobile Computing Systems and
Applications (HotMobile).
[42]KeMao,MarkHarman,andYueJia.2016. Sapienz:Multi-objectiveautomated
testingforandroidapplications.In ProceedingsoftheInternationalSymposiumon
Software Testing and Analysis (ISSTA).
[43]Tomas Mikolov, Kai Chen, Greg Corrado, and Jeffrey Dean. 2013. Efficient
estimationofwordrepresentationsinvectorspace. arXivpreprintarXiv:1301.3781
(2013).
[44]Nariman Mirzaei, Sam Malek, Corina S. Pasareanu, Naeem Esfahani, and Riyadh
Mahmood. 2012. Testing Android apps through symbolic execution. ACM
Software Engineering Notes (SEN) 37, 6 (2012), 1â€“5.
[45]Minxue Pan, An Huang, Guoxin Wang, Tian Zhang, and Xuandong Li. 2020.
Reinforcementlearningbasedcuriosity-driventestingofAndroidapplications.
InProceedings of the ACM International Symposium on Software Testing and
Analysis (ISSTA).
[46]APopescul.2003. Statisticalrelationallearningforlinkprediction.In Proceedings
of the IJCAI Workshop on Learning Statistical MODELS From Relational Data.
[47]Atanas Rountev and Dacong Yan. 2014. Static reference analysis for GUI objects
inAndroidsoftware.In ProceedingsofAnnualIEEE/ACMInternationalSymposium
on Code Generation and Optimization (CGO).
[48]Salvatore Scellato, Anastasios Noulas, and Cecilia Mascolo. 2011. Exploiting
placefeaturesinlinkpredictiononlocation-basedsocialnetworks.In Proceedings
of the ACM International Conference on Knowledge Discovery and Data Mining
(KDD).
[49]KoushikSen,DarkoMarinov,andGulAgha.2005. CUTE:Aconcolicunittesting
engine for C. In Proceedings of the ACM Joint Meeting on European Software
EngineeringConferenceandSymposiumontheFoundationsofSoftwareEngineering
(ESEC/FSE).
[50]ChuanShi,YitongLi,JiaweiZhang,YizhouSun,andPhilipS.Yu.2016. Asurveyof heterogeneous information network analysis. IEEE Transactions on Knowledge
and Data Engineering (TKDE) 29, 1 (2016), 17â€“37.
[51] skylot. 2020. JADX - Dex to Java decompiler. https://github.com/skylot/jadx.[52]
R.Socher,D.Chen,C.D.Manning,andA.Y.Ng.2013. Reasoningwithneuralten-
sor networks for knowledge base completion. In Proceedings of the International
Conference on Neural Information Processing Systems (NIPS).
[53]Statista. 2020. Global mobile OS market share.
https://www.statista.com/statistics/266136/global-market-share-held-by-
smartphone-operating-systems/.
[54]Ting Su, Guozhu Meng, Yuting Chen, Ke Wu, Weiming Yang, Yao Yao, Geguang
Pu, Yang Liu, and Zhendong Su. 2017. Guided, stochastic model-based GUItesting of Android apps. In Proceedings of the ACM Joint Meeting on European
SoftwareEngineeringConferenceandSymposiumontheFoundationsofSoftware
Engineering (ESEC/FSE).
[55]IlyaSutskever,JoshuaTenenbaum,andRussRSalakhutdinov.2009. Modelling
relational data using bayesian clustered tensor factorization. Advances in neural
information processing systems 22 (2009).
[56]Yutian Tang, Yulei Sui, Haoyu Wang, Xiapu Luo, Hao Zhou, and Zhou Xu. 2020.
All your app links are belong to us: understanding the threats of instant apps
1766
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:34:15 UTC from IEEE Xplore.  Restrictions apply. based attacks. In Proceedings of the ACM Joint Meeting on European Software
EngineeringConferenceandSymposiumontheFoundationsofSoftwareEngineering
(ESEC/FSE).
[57]NikolaiTillmannandJonathandeHalleux.2008. Pex-Whiteboxtestgeneration
for.NET.In ProceedingsoftheInternationalConferenceonTestsandProofs(TAP).
[58]wandoujia.2017. WanDouJiaAppStore. http://www.wandoujia.com/apps. Ac-
cessed: 2021-01-30.
[59]Jue Wang, Yanyan Jiang, ChangXu, Chun Cao, Xiaoxing Ma,and Jian Lu. 2020.
ComboDroid:generatinghigh-quality testinputsforAndroidappsvia usecase
combinations.In ProceedingsoftheACM/IEEEInternationalConferenceonSoftware
Engineering (ICSE).
[60]Yan Wang and Atanas Rountev. 2016. Profiling the responsiveness of android ap-
plications via automated resource amplification. In Proceedings of the IEEE/ACM
InternationalConferenceonMobileSoftwareEngineeringandSystems(MOBILE-
Soft).
[61]Shiyi Wei and Barbara G. Ryder. 2013. Practical blended taint analysis for
JavaScript. In Proceedings of the International Symposium on Software Testing
and Analysis (ISSTA).
[62]HaoweiWu,YanWang,andAtanasRountev.2018. Sentinel:generatingGUItests
for Android sensor leaks. In Proceedings of the IEEE/ACM International Workshop
on Automation of Software Test (AST).
[63]ShengquXi,ShaoYang,XushengXiao,YuanYao,YayuanXiong,FengyuanXu,
Haoyu Wang, Peng Gao, Zhuotao Liu, Feng Xu, , and Jian Lu. 2019. DeepIntent :
Deepicon-behaviorlearningfordetectingintention-behaviordiscrepancyinmo-bileapps.In ProceedingsoftheACMConferenceonComputerandCommunications
Security (CCS).
[64]Xusheng Xiao, Sihan Li, Tao Xie, and Nikolai Tillmann. 2013. Characteristic
studiesofloopproblemsforstructuraltestgenerationviasymbolicexecution.In
ProceedingsoftheInternationalConferenceonAutomatedSoftwareEngineering(ASE).
[65]XushengXiao,XiaoyinWang,ZhihaoCao,HanlinWang,andPengGao.2019.
IconIntent:AutomaticidentificationofsensitiveUIwidgetsbasedoniconclassifi-cationforAndroidapps.In ProceedingsoftheInternationalConferenceonSoftware
Engineering (ICSE).
[66]XushengXiao,TaoXie,NikolaiTillmann,andJonathandeHalleux.2011. Precise
identification of problems for structural test generation. In Proceedings of the
International Conference on Software Engineering (ICSE).
[67]Tao Xie,Nikolai Tillmann, Pelide Halleux,and Wolfram Schulte.2009. Fitness-
guided path exploration in dynamic symbolic execution. In Proceedings of the
IEEE/IFIP International Conference on Dependable Systems and Networks (DSN).
[68]JiweiYan,HaoLiu,LinjiePan,JunYan,JianZhang,andBinLiang.2020. Multiple-entrytestingofandroidapplicationsbyconstructingactivitylaunchingcontexts.
InProceedings of the IEEE/ACM International Conference on Software Engineering
(ICSE).
[69]ShengqianYang,DacongYan,HaoweiWu,YanWang,andAtanasRountev.2015.
Static control-flow analysis of user-driven callbacks in Android applications. In
Proceedings of the International Conference on Software Engineering (ICSE).
[70]ShengqianYang,HailongZhang,HaoweiWu,YanWang,DacongYan,andAtanasRountev.2015. StaticwindowtransitiongraphsforAndroid.In Proceedingsofthe
IEEE/ACM International Conference on Automated Software Engineering (ASE).
[71]X.YuanandA.M.Memon.2007.UsingGUIrun-timestateasfeedbacktogenerate
test cases. In Proceedings of the International Conference on Software Engineering
(ICSE).
[72]YujieYuan,LihuaXu,XushengXiao,AndyPodgurski,andHuibiaoZhu.2017.
RunDroid: recovering execution call graphs for Android applications. In Proceed-
ings of the ACM Joint Meeting on European Software Engineering Conference and
Symposium on the Foundations of Software Engineering (ESEC/FSE).
1767
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:34:15 UTC from IEEE Xplore.  Restrictions apply. 