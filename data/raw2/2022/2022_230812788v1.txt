Understanding Solidity Event Logging Practices in the Wild∗
Lantian Li
Shandong University
lilantian@mail.sdu.edu.cnYejian Liang
Shandong University
yejianliang@mail.sdu.edu.cn
Zhihao Liu
Shandong University
zhihaoliu@mail.sdu.edu.cnZhongxing Yu
Shandong University
zhongxing.yu@sdu.edu.cn
ABSTRACT
Writing logging messages is a well-established conventional pro-
gramming practice, and it is of vital importance for a wide variety of
software development activities. The logging mechanism in Solidity
programming is enabled by the high-level event feature, but up
to now there lacks study for understanding Solidity event logging
practices in the wild. To fill this gap, we in this paper provide the
first quantitative characteristic study of the current Solidity event
logging practices using 2,915 popular Solidity projects hosted on
GitHub. The study methodically explores the pervasiveness of event
logging, the goodness of current event logging practices, and in
particular the reasons for event logging code evolution, and delivers
8 original and important findings. The findings notably include the
existence of a large percentage of independent event logging code
modifications, and the underlying reasons for different categories
of independent event logging code modifications are diverse ( e.g.,
bug fixing and gas saving). We additionally give the implications
of our findings, and these implications can enlighten developers,
researchers, tool builders, and language designers to improve the
event logging practices. To illustrate the potential benefits of our
study, we develop a proof-of-concept checker on top of one of our
findings and the checker effectively detects problematic event log-
ging code that consumes extra gas in 35 popular GitHub projects
and 9 project owners have already confirmed the detected issues.
CCS CONCEPTS
•Software and its engineering →Maintaining software ;Lan-
guage features ;•General and reference →Empirical studies .
KEYWORDS
Solidity, Ethereum, event, logging, empirical study
ACM Reference Format:
Lantian Li, Yejian Liang, Zhihao Liu, and Zhongxing Yu. 2023. Understanding
Solidity Event Logging Practices in the Wild. In Proceedings of the 31st
∗Zhongxing Yu is the corresponding author of this work, and the first three authors
(Lantian Li, Yejian Liang, and Zhihao Liu) contributed equally to this work.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior specific permission and/or a
fee. Request permissions from permissions@acm.org.
ESEC/FSE ’23, December 3–9, 2023, San Francisco, CA, USA
©2023 Association for Computing Machinery.
ACM ISBN 978-x-xxxx-xxxx-x/YY/MM. . . $15.00
https://doi.org/10.1145/nnnnnnn.nnnnnnnACM Joint European Software Engineering Conference and Symposium on the
Foundations of Software Engineering (ESEC/FSE ’23), December 3–9, 2023, San
Francisco, CA, USA. ACM, New York, NY, USA, 13 pages. https://doi.org/10.
1145/nnnnnnn.nnnnnnn
1 INTRODUCTION
Ethereum is widely recognized as a distributed single-state world
computer, which innovatively combines the computing architec-
ture of a typical, general-purpose stored-program computer with a
decentralized blockchain [ 3]. In particular, the Ethereum platform
features the execution of arbitrary programs termed smart contracts ,
which are registered immutably on the blockchain and have their
correct executions enforced by the consensus protocol [ 33]. As
smart contracts are programmable, decentralized, and transparent,
they promise to renovate plenty of areas ( e.g., financial institutes,
supply chains, and government governance), and recent years have
witnessed a snowballing application on these areas [25, 26, 37].
Smart contracts are essentially Turing-complete programs that
run in a highly constrained and minimalistic execution environment
named Ethereum virtual machine (EVM), which runs a particular
kind of low-level programming language code called EVM bytecode .
While in principle any high-level programming language could be
adjusted to write smart contracts, it is extremely cumbersome to
adapt an arbitrary language for compliance with EVM bytecode.
Consequently, smart contracts in practice are programmed by a
few languages specifically designed for writing smart contracts,
including for example Solidity ,Vyper ,Serpent . Among these lan-
guages, Solidity is up to now the most popular and even widely
perceived as the de facto language of Ethereum [ 3]. Solidity features
theimperative programming paradigm, and its syntax resembles
that of JavaScript, C++, or Java. A Solidity contract is first compiled
into EVM bytecode and then executed by EVM on the blockchain.
As smart contract issues can literally cost money, the contract
code is extremely expensive, if not impossible, to change after de-
ployment, and the whole program state of smart contracts is trans-
parent to everyone, it is of vital importance to develop high-quality
smart contract programs. However, the present quality of Solidity
programs is far from satisfactory and the literature [ 1,13,25,32] has
reported a variety of issues about even deployed Solidity contracts.
We argue that one fundamental reason for this bad status lies in that
developers are not adequately acquainted with Solidity language
features. Being a new programming language, Solidity offers some
new, counter-intuitive high-level language features [ 5] which are
unfamiliar to developers who are even quite adept at programming
with other languages of longer history. As an example, Solidity
features exceptions like many other languages, but with a pecu-
liar behavior. When an exception is thrown, it cannot be caught:arXiv:2308.12788v1  [cs.SE]  24 Aug 2023ESEC/FSE ’23, December 3–9, 2023, San Francisco, CA, USA Lantian Li, Yejian Liang, Zhihao Liu, and Zhongxing Yu
the execution stops and all the side effects — including transfers
of ether — are reverted. Security problems like gasless send can
arise because of this. Moreover, the formal specification of Solidity
language features is absent and the current documentation about
these features is ambiguous and incomplete. To ameliorate this
issue, an effective solution is gathering empirical evidence about
thepractices applied by Solidity developers when using language
features, and using the evidence to impact at least four audiences:
(1)Researchers are informed about the real unsolved issues faced by
the Solidity developers, and hence set research agenda to advance
the present state-of-the-art.
(2)Language designers are aware of whether the language features
they design are correctly used by the Solidity developers, or are
instead misused or underused.
(3)Tool builders realize how to customize their tools ( e.g., coding
assistants) to the real needs and practices of the Solidity developers.
(4)Developers understand both the good and bad practices con-
cerned with the use of Solidity language features, and consequently
improve the quality of the written code.
Writing logging messages is a well-established programming
practice [ 47], and it plays an extremely important role in various
software development activities [ 6,14,16,21–23,45,46,48], in-
cluding for example failure diagnosis, auditing, and profiling. The
logging mechanism in Solidity programming is enabled by the high-
level event feature, which is an abstraction on top of the logging
primitives of EVM. Compared to conventional logging, Solidity
event logging features a few distinctions. First, event logging prints
the logging message to Ethereum blockchain instead of the console
or file routinely done by conventional logging. Second, while the
target application scenario of conventional logging mainly revolves
around failure diagnosis, the target application scenario of event
logging is not well established and varies. Event logging in principle
can have a wide variety of application scenarios, and the reported
scenarios include for example alternative cheaper storage venues
and debugging [ 4]. Given these distinctions, it is of vital impor-
tance to study how Solidity developers use event logging in practice
and thus positively impact researchers, language designers, tool
builders, and developers to improve the event logging practices.
To fill the gap, we in this paper conduct a large-scale empir-
ical study about Solidity event logging practices in the wild. In
particular, we aim to shed light on these three questions:
•RQ1 (Pervasiveness of Event Logging): How common is
event logging? This question aims to explore whether event
logging feature is indeed widely used by developers in practice.
•RQ2 (Goodness of Event Logging Practice): Is current event
logging practice good enough ? This question aims to study
whether developers use event logging feature in a right way.
•RQ3 (Reasons for Event Logging Code Modifications): Why
do developers modify event logging code? This question aims
to understand the specific reasons for developers’ modifications
to event logging code.
To answer these questions, we choose 2,915 popular open source
Solidity projects on GitHub as subjects. For RQ1 , we explore the
density of event logging instruction in source code. For RQ2 , we
first study the churn rate [ 29] according to the code revision history
and then separate those event logging code modifications that aretruly modifying event logging code as after-thoughts from those
that are solely consistency updates along with other non-event
logging code changes. We hereafter term the former and latter
modifications as independent and dependent event logging code
modifications respectively. By “after-thought”, we here emphasize
that independent event logging code modifications arise because
event logging code is not written right by developers at the first
attempt, they later detect the problem and modify the event logging
code accordingly. Unlike dependent event logging code modifica-
tions which are unlikely to reflect much developers’ concerns over
the event logging code itself, independent event logging code modi-
fications are prone to reflecting more directly developers’ concerns
over the event logging code. We thus focus on independent event
logging code modifications in this paper. For RQ3 , we randomly
sample 419 independent event use code modifications and divide
them into different categories. Moreover, we investigate the details
of them to understand the underlying reason for each category.
Our large-scale study enables us to deliver 8 original and impor-
tant findings. In short, the findings include: (1) The average value
of event logging code per project and per line of code (LOC) is 32.8
and 0.022 respectively, yet the maximal values can be exceptionally
large; (2) The average churn rate of event logging code is nearly the
same as that of the entire code, and a significant percentage (with
lower bound being 10.64%) of event logging code modifications
are independent ones; (3) Within independent event logging code
modifications, three major change categories include parameter
change of event logging code, addition of new event logging code,
and deletion of existing event logging code. The underlying reasons
for these change categories are diverse, and notably are related
with bug fixing, gas saving, and debugging support. We addition-
ally give the implications of our findings, and these implications
can enlighten developers, researchers, tool builders, and language
designers to improve the practices of event logging.
To illustrate the potential benefits brought by our study, we
develop a proof-of-concept checker to detect problematic event
logging code that consumes extra gas by using Storage type variable
instead of Memory type variable (inspired by our Finding 5). For
the top 200 popular GitHub Solidity projects, our checker detects
that 35 projects suffer from this issue in the latest versions of their
code (with 207 problematic event logging instructions in total). The
owners of 9 projects have confirmed the detected problems and
some of them commented that our finding is extremely interesting
and can be integrated into the compiler optimization process. The
result certifies that our findings are truly beneficial to tool builders
for improving the quality of Solidity event logging instructions.
This paper makes the following major contributions:
•We conducted the first large-scale and systematic empirical study
about Solidity event logging practices on 2,915 popular open-
source Solidity projects hosted on GitHub.
•We presented 8 original and important empirical findings about
Solidity event logging practices. We additionally presented 8 im-
plications from our findings, and these implications are beneficial
for researchers, language designers, tool builders, and developers
in order to improve all facets of Solidity event logging.
•We developed a checker to detect problematic event logging code
that consumes extra gas by using Storage type variable insteadUnderstanding Solidity Event Logging Practices in the Wild ESEC/FSE ’23, December 3–9, 2023, San Francisco, CA, USA
of Memory type variable, and the usefulness of the checker has
been confirmed.
2 BACKGROUND
2.1 Ethereum Basics
Unlike Bitcoin (with a quite constrained scripting language), Ethereum
has been designed as a general-purpose, Turing-complete pro-
grammable blockchain that runs the EVM capable of executing
smart contracts of arbitrary complexity [ 4]. Smart contracts will
execute transactions automatically in case certain conditions have
been met, and can invoke other contracts during the execution of
transactions initiated by external users.
Being a Turing-complete computing model, to ensure that denial-
of-service attacks or transactions that consume excessive resources
are avoided, Ethereum introduces a metering mechanism called gas
to control the use of resources by transactions. More specifically,
Gas measures the computational and storage resources required for
different EVM instructions, and it has an exchange rate relation-
ship with ether (the native Ethereum cryptocurrency). The required
gases for different EVM instructions vary greatly, depending ma-
jorly on where the associated data reside. EVM can store data in
three different places: Storage, Memory, and Stack. While most
instructions cost 3-10 gas, Storage usage instructions like sstore
can cost as much as 20,000 gas because Storage data are persistent
on the blockchain (similar to hard drive of computer). To prevent
malicious infinite loops and other forms of computational waste,
the creator of each transaction needs to set a limit on the amount
of gas that they are willing to pay for transaction execution. If the
resource consumption during the execution exceeds the gas limit
specified, the EVM will terminate the execution of the contract.
Beyond the initial vision of being a general-purpose blockchain,
the vision of Ethereum has rapidly expanded to become a platform
for programming DApps (i.e., Decentralized Applications). In a
DApp, smart contracts serve as the backend and are employed
to store the business logic (program code) and the related state
of application, but the frontend can make use of standard web
technologies, including typically HTML, CSS, and JavaScript.
2.2 Solidity Event Definition and Use
The message logging in Solidity code is achieved by the high-
level event feature, which in turn will be compiled into EVM log-
ging primitives. EVM has 5 logging primitives log0 ,log1 ,log2 ,
log3 , and log4 , and these primitives can be used to create log
records that describe an event within a smart contract. Each log
record consists of two parts, topic anddata . The topic part is
used to describe what’s going on in an event, and the data part
is the payload (value) of the event. The 5 EVM logging primitives
differ in the number of topics that need to be included in the log
record, and logi will include itopic(s). The use of topics makes
it efficient to find logs by matching topics.
To declare a Solidity event, we begin with the keyword “event”,
then give the identifier, and lastly give a list of typed parameters. In
particular, we can add the attribute indexed to certain parameters,
which will make them become the topic parts of the log records
produced by EVM logging primitives instead of the data parts. In
other words, parameters with keyword indexed are searchable.Fig. 1 gives an example of event definition. For the defined event
Deposit , parameters _from and_id are searchable.
To use the defined event, we begin with the “emit” keyword, then
we give the name of the event, and finally we provide the arguments
(if any) in parentheses. Fig. 1 also gives an example of the use of the
event Deposit . After the event has emitted, the passed arguments
are stored alongside the blockchain to allow retrieving them. More
specifically, they are stored in the log entries of the transaction
receipt which is produced when a transaction completes. These logs
are connected with the contract address and will be incorporated
into the blockchain and stay there provided that a block is accessible.
Note that an event generated is not accessible from within contracts,
not even the one which has created and emitted them.
Our goal in this paper is to reveal issues with using the event that
is defined in a suitable manner, we thus concentrate on studying
event use for a certain defined event and hereafter event logging
(code) refers to event use (code), and we use them interchangeably.
2.3 Solidity Event Applications
While conventional logging is mainly used for failure diagnosis
[45,46,48], the application scenario of Solidity event logging varies.
Event logging in principle can have various application scenarios,
and the reported typical scenarios include the following [4].
•Execution monitoring to update client front end. Once
events are emitted, they can be listened for by subscribing to
catch these events using ethers.js—a complete and compact li-
brary for Ethereum. As a result, DApps or other light clients can
monitor particular events and act accordingly. In particular, the
client front end can thus be updated automatically.
•Alternative cheaper storage venue. Storing data in permanent
Storage area is extremely expensive in Ethereum, dominating the
gas cost of a typical transaction. Storing the data in log record
instead is much cheaper. Thus, event logging can serve as an
alternative cheaper storage venue.
•Debugging during development. Events can be used to record
specific activities or states that may occur during the execution
of a smart contract, and thus provide an invaluable source of
information into the operation of a smart contract. By regularly
tracking and auditing the log entries (generated after events have
emitted) of the transaction receipt, developers can check whether
the smart contract is running as expected and quickly identify
any potential bugs or security issues that may arise.
3 METHODOLOGY
3.1 Subjects and Data Used in Our study
We use popular Solidity projects hosted on GitHub as the study
subjects. Borges and Valente [ 7] found through a survey with 400
Stack Overflow users that the stargazers counts are viewed by prac-
titioners as the most useful measure of popularity on GitHub. We
Figure 1: Example of Event Definition and Use.ESEC/FSE ’23, December 3–9, 2023, San Francisco, CA, USA Lantian Li, Yejian Liang, Zhihao Liu, and Zhongxing Yu
Figure 2: Boxplots for Some Metrics about the Dataset.
thus focus on Solidity projects hosted on GitHub with relatively
larger stargazers counts. Smaller stargazers counts represent lower
popularity and the corresponding projects are more likely written
by novice developers, and studying these projects will less likely
reveal current event logging practices by Solidity developers. As
Solidity is a relatively new programming language, we find that
the stargazers counts for Solidity projects are small compared to
that for other older languages such as Java and C++. Finally, we
retrieve all non-fork, non-private 2,915 Solidity repositories whose
stargazers counts are larger than 5 (at the time of our data collec-
tion date–September 1, 2022) as the study subjects. The threshold
of 5-star is chosen as follows. We initially crawled 10,000 Solidity
repositories hosted on GitHub and randomly sampled 200 reposito-
ries to study their features by checking the accompanied project
descriptions andReadme files. The first author conducts the
check and reports 18 sample projects ( e.g., teach how to write your
first solidity program) among the 200 repositories, and the second
author confirms that the reported 18 repositories truly are sample
projects. The stargazers counts for the 18 projects are all less than
or equal to 5. We thus conjecture that for those projects whose
stargazers counts are less than or equal to 5, quite a few are sample
projects and there exists serious homogeneity among them.
Figure 2 shows boxplots with the distribution of stargazers
counts, the age (in number of months), number of contributors, and
number of lines of code (LOC, exclude the comments and empty
lines) for the 2,915 projects in the dataset (outliers are omitted). The
average value is respectively 42.1, 14.4, 3.8, and 1460.1 for stargazers
counts, age, number of contributors, and number of lines of code.
While the code line numbers of the studied projects are typically
smaller than that of popular projects written in other languages,
Solidity projects of the studied size are complex and might take
much time and effort to audit [38].
To study the churn rate and evolution of event logging code, we
need to explore the evolution history. As the ages of the considered
projects are relatively young (see Figure2b), we account for the full
evolution history for each project. In particular, we use the REST
API to get all non-merged commits for each project, and further
the author name, commit log, and involved files for each commit.
3.2 Study Methodology
We investigate numerous aspects of the practices of event logging.
To investigate the density of event logging code, we count the LOC
of the event logging code as well as the LOC of the whole program.
To achieve this purpose, we develop a small utility which only
counts the actual lines of source code and excludes the comments
and empty lines. To recognize the event logging code, we make use
of the regular expression “\s+emit\s+(\w+)\s*\(([\s\S]*?)\)\s*”.To study the goodness of event logging practice, we first con-
trast the churn rate of event logging code with that of the entire
code. Code churn is a metric that indicates how often a given piece
of code gets edited. If a given piece of code receives changes too
often, that’s usually a bad sign. The code churn rate is calculated
asChurned LOC /Total LOC [29], where Churned LOC consists of
added, modified, or deleted code lines. Likewise, we measure churn
rate for event logging code as Churned Event Use /Total Event Use ,
where Churned Event Use consists of event use lines added, modi-
fied, or deleted. Our developed utility parses each revision in the
considered commit history to establish the churned code lines and
event use lines, and then the churn rate is calculated accordingly.
The calculated churn rates for all revisions of a certain project are
finally averaged to get the final churn rate for this project.
We further establish the percentage of independent event log-
ging code modifications. Within the studied commit history, there
are in total 43, 550 event logging code modifications. Within these
modifications, there exist two kinds: some are solely consistency
updates along with other non-event logging code modifications
(e.g., bug fix) within the same revision, and others are modifications
that modify the event logging code as after-thoughts. The same
modification categories have been employed to investigate conven-
tional logging code changes [ 9] and annotation changes [ 41]. To
distinguish these two kinds, one conservative policy is to examine
whether the revisions only include changes solely to event use code
but not to other non-event use code. Using this policy, we can get
1,132 event use code modifications. These event use code modifica-
tions are absolutely independent event use code modifications, and
account for 2.59% of all event use code modifications.
However, the policy above is too conservative as developers are
inclined to batch multiple code changes into one revision. During
our analysis of the event logging code modification, we made one
observation: if the variables involved in event logging code mod-
ification are not affected by other code changes within the same
revision, then this event logging code modification is likely to be in-
dependent of other code changes. For instance, given the event log-
ging code modification emit Send(msg.sender, id1) →
emit Send(msg.sender, id2) where Send is the name of
an event and id1 andid2 are identifiers of two variables, the
changed variable is id1 and this modification is likely to be an in-
dependent modification if id1 is not affected by other code changes
within the same revision. This makes sense because if the values of
the involved variables have not changed, then the reason for event
use code change is very likely that we have not appropriately used
the event logging feature at first. To determine whether a variable is
affected, we conservatively check whether it is redefined or passed
as an argument of a function call within the revision.
On top of this observation, we can get 5,033 independent event
logging code modifications, which account for 11.56% of all event
logging code modifications. As the result based on this observa-
tion can possibly be inaccurate, we further randomly sample 500
modifications and manually verify our analysis results on them to
see the accuracy of our analysis. This manual verification step is
done by two distinct authors, and we deem a checked modification
as true independent event logging code modification only when
both of the authors have agreed with it. The manual verification
suggests that the accuracy of our analysis is 92%. The Cohen’sUnderstanding Solidity Event Logging Practices in the Wild ESEC/FSE ’23, December 3–9, 2023, San Francisco, CA, USA
(a) Event Use by Project
 (b) Event Use by LOC
Figure 3: Density of Event Use by Project and LOC.
kappa coefficient is 0.85 for this manual verification, indicating a
good agreement rate. There are majorly two sources for the false
positive: (1) The event logging code modification is on the string
text description, and the text description is related with changes of
other non-logging code; (2) The event logging code is dependent
on a condition, and the modifications on the condition result in the
event logging code modification.
To understand the underlying reasons for independent event
logging code modifications, we randomly sample 419 modifications
from the 1,132 absolute independent event logging code modifi-
cations, which achieves 99% confidence level and ±5% confidence
interval, and investigate their details. For these sampled modifica-
tions, we examine developers’ commit messages about the modi-
fications, relevant source code, code comment, and together with
the specific event logging code modifications to understand the
modifications. To minimize our own subjective judgment, each
modification is checked independently by two authors of the paper.
If they cannot clearly understand the reason or have disagreements
with the reason for some modifications, we always conservatively
classify them into the “unknown” category when our results are
presented. The Cohen’s kappa coefficient is 0.75 for this manual
check, suggesting the agreement rate is good.
The above two manual studies in particular consist of three
phases. In phase one, the first two authors of the paper indepen-
dently derive an initial list of the categories (whether or not a
modification is independent one for the first study and the rea-
son behind the independent modification for the second study). In
phase two, the two authors compare the derived categories and dis-
cuss the disagreements, and make refinements to their established
categories according to the discussion results. In phase three, the
Cohen’s kappa coefficient is calculated based on the refined cate-
gories. Similar process has been employed by other works [ 17,49].
4 RQ1: PERVASIVENESS OF EVENT LOGGING
To begin with, we want to see whether event logging feature is
indeed widely used by Solidity developers in practice. It is observed
that there are 95,803 event uses in total for the latest versions of the
studied 2,915 projects in this paper. Figure 3a displays the density
plot of the event use numbers for the 2,915 projects. We can see
from the figure that a majority of projects make use of a moderate
number of event logging features, but a couple of projects make
use of an exceptionally large number of event logging features. In
particular, the average number of event logging uses per project is
32.8. On the whole, it can be concluded that the use of event logging
feature is pervasive in Solidity programming by developers.A potential concern that will arise from Figure 3a is whether de-
velopers will overuse event logging feature in practice. By overuse,
we here hypothesize that event logging feature is used frequently
with the value of event use per LOC larger than 0.1 and is used
in a way that consumes unnecessary more gas. To check this, for
each studied project, we additionally calculate the value of event
use per LOC. The density plot of the calculated value across all the
considered 2,915 projects is shown in Figure 3b. We can see that the
value is small for majority of projects, yet can be greater than 0.1
or even close to 0.4 for certain projects. The minimum, 1st quartile,
median, 3rd quartile, and maximum value is 0.0, 0.006, 0.020, 0.031,
and 0.388 respectively, and the average value is 0.022. In particular,
among the 2,915 projects, the value is larger than 0.1 for 33 projects.
If the value is greater than 0.1, it suggests that there is an event use
for every less than 10 lines of code. From these data, we can see
that while majority of the projects have a reasonable value of event
use per LOC, a few projects have an exceptionally large value of
event use per LOC and thus potentially suffer from the problem of
“overuse of event logging feature”.
We further manually check the 33 projects for which the value
of event use per LOC is larger than 0.1. We find that a major reason
for the high value is that developers use several separate events to
record transaction-related information, while the general case is
that developers use a single event (or at least fewer events) to record
the information. As an illustration, it can be that the specific event
event0 (x,y,z) to record transaction-related information is
replaced by three separate events: event1(x) ,event1(y) , and
event1(z) . The recorded information are essentially the same
for these two event use cases, but using more events will cost more
gas. Thus, “overuse of event logging” raises the potential question
of whether the corresponding event definitions are appropriate and
(if not) whether refactorings are needed.
Finding 1 : The average value of event use per project and per
LOC is 32.8 and 0.022 respectively, yet the maximal values can be
exceptionally large for both of the two metrics. For projects with
exceptionally high value of event use per LOC, one major reason
is that developers use several separate events instead of a single
event to record transaction-related information.
Implication 1 : Solidity event logging feature is used pervasively
in practice, but can be overused occasionally. IDE can warn de-
velopers if event logging feature is overused, and the numerical
data summarized here and detailed online can be referred to set
the thresholds. In addition, to save gas when the event is used, it
is preferable that developers define event in a way that contains
more parameters. These parameters correspond to different as-
pects of a certain subject to be logged ( e.g., the different addresses
involved in a transaction).
5 RQ2: GOODNESS OF EVENT USE PRACTICE
We first want to check whether event use code is actively main-
tained. Among all the commits in the studied commit history, we
find that 11.83% of them involve modifications to event use code.
This suggests that despite the relatively small density of event use
code compared to the entire code, event use code takes an excep-
tionally important part of code evolution. We also compare the code
churn rate of the event use code with that of the entire code (asESEC/FSE ’23, December 3–9, 2023, San Francisco, CA, USA Lantian Li, Yejian Liang, Zhihao Liu, and Zhongxing Yu
Figure 4: Code Churn Rate for Event Use and Entire Code.
detailed in Section 3.2), and Figure 4 shows the result. The average
value of code churn rate for entire code and event use code is 0.0030
and 0.00282 respectively. Thus, there is no significant difference
between these two code churn rates. Overall, we see that event
use code has been actively and continuously modified, suggesting
that Solidity developers are actively maintaining event use code for
software functionality like they maintain other code.
Finding 2 : Event use code is modified in a significant number
(11.83%) of all the committed revisions, and its average churn rate
is nearly the same as that of the entire code.
Implication 2 : Event use code is being actively and continuously
maintained by developers, and it takes an exceptionally important
part of code evolution despite its relatively small density.
As detailed in Section 3.2, some event use code modifications are
dependent ones and others are independent ones. For all the event
use code modifications, we establish a percentage 2.59% of absolute
independent event use code modifications using the conservative
policy. Moreover, we identify a percentage 11.56% of independent
event use code modifications using an automatic analysis procedure
on top of one observation. Given the accuracy of the automatic anal-
ysis is 92%, it can be deemed that the automatic analysis identifies
a percentage 10.64% (11.56% ×92% = 10.64%) of independent event
use code modifications. Considering that other independent event
use code modifications can be neglected by our automatic analysis,
it can be deemed that an absolute lower bound 2.59% and a relaxed
lower bound 10.64% of independent event use code modifications
have been established. Overall, there exists a non-neglectable per-
centage (with lower bound being 10.64%) of independent event use
code modifications. For these modifications, event use code is not
written right by developers at their first attempt and developers later
detect the problem and modify the event logging code accordingly.
The large percentage of this kind of independent event use code
modifications suggests that the current developer practice of using
Solidity event feature is not good enough, and some developers are
inclined to use event logging feature in an arbitrary and subjective
way. After detecting the event use problems, Solidity developers
take time and efforts to address them as after-thoughts. By “good
enough”, we here mean that if developers use event logging feature
in a principled and correct way, nearly all of the changes to the
event logging code ideally should be consistent updates. In other
words, besides consistent updates, no (or few) modifications are
needed on the event use code. Thus, use of Solidity event logging
feature “good enough” will make the percentage of independent
event logging modifications very low. In particular, we deem the use
of Solidity event logging feature as “good enough” if the percentage
of independent event logging modifications is below 5.0%.Finding 3 : There exists a significant percentage (with lower
bound being 10.64%) of event use code modifications that are
independent of other non-event logging code changes.
Implication 3 : The current practice of using event logging fea-
ture is not good enough, introducing issues to the quality of event
logging that developers will address as after-thoughts. Tools that
support the systematic testing of event logging behaviours would
be helpful. Besides, the Solidity event logging feature should be
more extensively discussed in books and tutorials, so that devel-
opers can make better-informed implementation decisions.
6RQ3: REASONS FOR EVENT LOGGING CODE
MODIFICATIONS
In this section, we give the results of our manual analysis of the
randomly sampled 419 independent event use code modifications.
Overall, the 419 modifications can be divided into 5 categories as
shown in Table 1. The particular meanings of the 5 categories are as
follows: the category Parameter Change means that the parameters
of event use code have changed but the name of the used event
does not change, the category Addition refers to adding an event
use, the category Deletion refers to the deletion of an event use,
the category Move means that the location of the event use code
has been moved but its parameters and name remain the same,
and finally the category Replacement means that the name of the
used event is modified without modifying the parameters. For three
modifications, they change both the name and parameters of the
used event, so we do not classify them into any category.
We can see from the table that the instances for categories Param-
eter Change ,Addition , and Deletion are most dominating, accounting
for 92.36% of all sampled modifications. Having tools to help check
for problematic event parameters (i.e., event parameters that should
be substituted by other parameters for better logging quality), miss-
ing use of events, and unnecessary use of events can thus help
developers better use events the first time they write code, reducing
subsequent event use changes. In particular, the high percentage of
Parameter Change andAddition instances is in line with existing
studies on conventional logging, and the explored automatic log-
ging support for “what to log” and “where to log” is also invaluable
for Solidity event logging [ 48,50]. By contrast, the instances for
categories Move andReplacement are relatively limited.
Finding 4 : Within independent event use code modifications, de-
velopers spend significant efforts in changing parameters, adding
a new event use, and deleting an existing event use (accounting
for 92.36% of all modifications). They seldom move an event use
or replace an event use with another one.
Implication 4 : Tool builders should focus on developing tools for
helping developers to detect and fix issues related with problem-
atic event parameters, missing event use, and unnecessary event
use. The explored automatic logging support about “what to log”
and “where to log” for conventional logging is also invaluable for
Solidity event logging, and a viable solution is using the “learn to
log” principle on top of high quality training data.
We next give a detailed analysis of the reasons for the modifica-
tions in the 5 categories.Understanding Solidity Event Logging Practices in the Wild ESEC/FSE ’23, December 3–9, 2023, San Francisco, CA, USA
Table 1: Category of Independent Event Use Code Changes
Change type #Instance #Percentage
Parameter Change 168 40.09%
Addition 145 34.61%
Deletion 74 17.66%
Move 24 5.73%
Replacement 5 1.19%
6.1 Parameter Change
Category Parameter Change is most common according to our data
(with a percentage of 40.09%), and its specific reasons are also the
most diverse.
6.1.1 Unintended Wrong Usage. 41.67% (70 instances) of modifica-
tions in this category arise because unintended wrong value related
with a certain non-address variable has been recorded by event use.
The wrong value emerges due to typical programming errors re-
lated with variables. Among the 70 instances, there are 25, 12, 9, and
3 instances that fall into change kind replace a variable with another
variable that is in scope ,arithmetic error change ,replace a wrapped
method call (for a variable) with another method call that is similar
in identifier name , and wrap/unwrap a variable with a method call
respectively. As the search space for these change kinds is relatively
small, there exists the prospect of well-designed tools to automati-
cally conduct these changes. Given much progress has been made
in recent years towards automatically detecting [ 11,36,39,40,42]
and fixing [ 20,28,35,43,44] relatively simple bugs, this prospect
is huge. An example is shown in Fig. 5(a) where the parameter
referrer is wrapped with method call plasmaOf in the new
version. According to the definition of plasmaOf , depending on
a condition, the return value of it may or may not be the argument
passed in (the referrer in this case). According to the change,
what needs to be logged is the return value of the function (for an
argument) but not the argument itself, so the direct use of argument
referrer is unintended and wrong.
6.1.2 Mixed Use of Addresses. 20.24% (34 instances) of modifica-
tions in this category are related with mixed use of addresses. It
is a common practice to use event to record transaction-related
information in Solidity programming, and the information in gen-
eral will include the addresses involved in the transaction (i.e., the
addresses of the recipient and sender). However, when using event
to record information, addresses are often mixed, and the most
common one is mixing the sender’s address with that of the caller.
For example, given a scenario where contract Acalls contract Bto
transfer Xtokens in account Cto account D, then account Cis the
actual token sender and account Dis the actual token recipient. In
event logging, we then should record the addresses of account C
and account D. However, a mistake that many developers are prone
to making is to record msg.sender as the actual token sender,
that is, record Aas the actual token sender. In other words, the
address for caller of the contract is mixed with that for the actual
token transferer. Fig. 5(b) gives a real example where src is the
actual token transferer. However, developer mistakenly records the
contract caller msg.sender as the token transferer.
6.1.3 Improving String Description. 9.52% (16 instances) of modifi-
cations in this category are improving string description, makingthe content in the string easier to understand or closer to what the
developer wants to express. Besides logging value, event logging
feature can also be used to log one or several string descriptions for
explaining what value has been logged or the purpose of the logged
value. However, developers may not pay enough attention to the
string description at the beginning, and they gradually improve
it. An example is shown in Fig. 5(c) where the initial string de-
scription “ _mint b ” is much less informative than the new string
description “ initOptinoToken ”.
6.1.4 Gas Saving. 6.55% (11 instances) of modifications in this cat-
egory are related with gas saving, which replaces Storage type
variable with Memory type variable to save gas. The reason is after
compiling the event use to EVM bytecode, an extra Sload EVM
operation would be needed to access the variable if it is Storage
type, and the Sload operation costs 800 gas since it deals with
data in Storage area. Thus, when we use event to store the value of
a certain variable in transaction log, local Memory type variable
would be preferable to Storage type variable if they hold the same
value. Fig. 5(d) gives an example, the original variable delay is
a global variable and the new variable delay_ is a function pa-
rameter, which will respectively be Storage type and Memory type
in Solidity. Since their values are the same for event DelaySet ,
using Memory type variable delay_ can save gas. Given the ut-
most relevance of reducing the gas costs of smart contracts in the
blockchain ecosystem [ 2], it would be extremely worthwhile to
investigate the gas impact of this kind of variable replacement on
the whole Ethereum net in the future.
For the remaining 37 (22.02%) instances in this category, we are
not clear or have not agreed with the underlying reasons.
Finding 5 : For changes that change parameters of event use, four
key reasons are: unintended wrong variable-related value has
been recorded (41.67%), mixing addresses of transaction sender,
transaction recipient, and contract caller (20.24%), improving
string description (9.52%), and gas saving (6.55%). For wrong
variable-related value, the wrong value emerges due to typical
programming errors related with variables, such as arithmetic
error and forgetting to wrap the variable with a method call. For
gas saving, developers replace Storage type variable with Memory
type variable that has the same value.
Implication 5 : Testing event logging behaviours is important
and testing efforts should pay special attention to typical program-
ming errors related with variables and the addresses involved
in event use. With regard to wrong variable-related value, there
exists the prospect of well-designed tools to automatically con-
duct changes to correct the value as the change space is relatively
small. With regard to gas saving, tools can automatically help
developers conduct the change from Storage type variable to
Memory type Variable and compilers can do this gas optimiza-
tion during the optimization process. Besides, developers should
take the string description in event use seriously, making it as
informative as possible.
6.2 Addition
Category Addition accounts for a significant percentage (34.61%) of
the 419 modifications, and the underlying reasons are as follows.ESEC/FSE ’23, December 3–9, 2023, San Francisco, CA, USA Lantian Li, Yejian Liang, Zhihao Liu, and Zhongxing Yu
6.2.1 Recording Transaction-related Information. 35.86% (52 in-
stances) of modifications in this category are post-transaction addi-
tions, which add an event use after the asset transfer code to record
transaction-related information. The information typically include
the addresses involved in the transaction, the amount, the bal-
ance, etc. If event logging is employed to record transaction-related
information, the Ethereum platform will notify the client of the
occurrence of the transaction. As a result, there is no need to contin-
uously check the Ethereum ledger to determine whether the trans-
action exists. An example is shown in Fig. 6(a). The newly added
Transfer event records the addresses user andaddress(0)
of the two parties involved in the transaction, as well as the number
of transferred tokens value .
6.2.2 Debugging Support. 18.62% (27 instances) of modifications in
this category are related with facilitating debugging. Solidity does
not provide developers with language-level debugging facilities
typically found in other languages ( e.g.,print ). The difficulty of
debugging is thus increased, and developers can use event logging
to facilitate debugging. There are various ways in which developers
can use event logging to help with debugging, including logging
the value of an intermediate variable, logging string information
related to debugging, using empty events without parameters (note
in this case, transaction logs will still have information related with
event such as its identifier), etc. An example is shown in Fig. 6(b)
where OrderStart is an empty event, and the (trimmed) commit
message confirms that this modification is for debugging.
Figure 5: Example of Parameter Change.
Figure 6: Example of Addition Change.6.2.3 Monitoring Variable Value Change Caused by Assignment.
17.93% (26 instances) of modifications in this category are post-
assignment additions, where the assignment includes not only the
direct variable-to-variable assignment, but also the assignment of
results of typical operations (such as function call and math opera-
tion, but excluding transaction operation) to variables or elements
of more complex data structure such as array. Event logging in
this case can typically be used to monitor the value change for
variables of interest, updating front end of light clents and DApp
services accordingly. An example is shown in Fig. 6(c). After using
an assignment “ enabled[token]=true ” to change the value
ofenabled[token] , the event use “ TokenAdded(token) ”
is employed to indicate that now the account with address token
is allowed to participate in something such as a transaction.
The use of event logging after transaction and assignment op-
erations is of great significance, in particular for DApps. The high
percentage of post-transaction and post-assignment additions sug-
gests that developers frequently forget to use event logging after
transaction and assignment operations, and the commit messages
for most of these modifications clearly explain that the developers
forget to use events at the beginning. Thus, dedicated tools could
offer support for recommendations of event uses for these opera-
tions. For the remaining 40 (27.59%) instances in this category, we
are not clear or have not agreed with the underlying reasons.
Finding 6 : For changes that add an event use, three major rea-
sons are: recording transaction-related information (by post-
transaction additions, 35.86%), debugging support (18.62%), and
monitoring variable value change caused by assignment (by post-
assignment additions, 17.93%).
Implication 6 : Research on providing automatic “where to log”
support could focus on transaction and assignment operations,
and more systematic work is needed for exploring in detail the
specific types of transaction and assignment operations for which
event logging is highly desired. Besides, it is worthwhile to further
explore the attributes of code snippets for which event logging is
added to support debugging.
6.3 Deletion
Category Deletion accounts for a large percentage (17.66%) of the
419 modifications, and the underlying reasons are as follows.
6.3.1 Debugging Removal. 58.11% (43 instances) of modifications
in this category are related with removing event logging previously
used for debugging. As these event debugging removals are indepen-
dent of other non-logging code changes, so these event debugging
removals in principle can actually also be done in last commit or
earlier commits (more specifically at the code version for which
the use of a certain event for code debugging has finished). Thus,
the high percentage of modifications in this category suggests that
developers often do not delete events that are no longer needed in a
timely manner after using event feature for debugging, negatively
impacting code readability and increasing gas cost. However, it is
typically impossible to analyze whether the developer has finished
debugging from the code only. The first author checks the 43 event
debugging removals, and finds that there are three common formsUnderstanding Solidity Event Logging Practices in the Wild ESEC/FSE ’23, December 3–9, 2023, San Francisco, CA, USA
of event logging debugging. The second author confirms the result,
and the three forms are as follows:
•Log one informative string or use an empty event. In this
case, developer uses event logging to log a string description that
may have special meaning for himself or use an empty event as
exemplified in category Addition . Fig. 7(a1) gives an example of
this form.
•Log one or several variables and one informative string. In
this case, developer uses event logging to log the value of one
or several variables, and one informative string that is typically
related with the variable name(s). The purpose is to judge whether
the variable value is consistent with the expected value. Fig. 7(a2)
gives an example of this form.
•Use same event to log one or several variables multiple
times but in different locations. In this case, developer uses
same event multiple times to see whether the value change of
a certain variable is expected, facilitating debugging. Fig. 7(a3)
gives an example of this form.
Given these common forms of event logging debugging, tools can
check them and inform developers to delete them in case debugging
has already finished.
6.3.2 Redundancy Removal. 12.16% (9 instances) of modifications
in this category are removing redundant event logging code. That
is, if the recorded content by a certain event use is the same as
or already included in the recorded contents by some other event
uses, then the event use can be deleted to save gas. Fig. 7(b) gives
an example of this change type. Since the value of the parameter
_amount is logged by both events Burn andTransfer , one of
them is deleted.
6.3.3 Useless Removal. There are two additional instances (2.70%)
in this category that arise for removing useless event logging code.
If event logging records something that is unnecessary or not used
at all, then it should be deleted since EVM logging primitives cost
gas. In general, it is hard to determine whether the developer has
used useless event logging code from the source code only. We need
to also consider the commit message if available. Fig. 7(c) gives an
Figure 7: Example of Deletion Change.example where the commit message clearly says the purpose of the
deletion.
Note that the underlying reasons for the above 54 change in-
stances can be viewed more generally as gas saving in a way. For
the remaining 20 (27.03%) instances in this category, we are not
clear or have not agreed with the underlying reasons. In partic-
ular, we are not aware of any deletion instances of “dead” event
logging code in our sample. It can be that such change instances
will nearly always be consistency updates, and further work needs
to be conducted to investigate this problem.
Finding 7 : For changes that delete an event use, two major rea-
sons are: remove no-longer needed event logging previously used
for debugging (58.11%) and remove redundant event logging
(12.16%). The event logging used for debugging typically has
three forms: log one informative string or use an empty event,
log one or several variables and one informative string, and use
same event to log variable(s) multiple times in different locations.
Implication 7 : Developers often do not delete event uses that are
no longer needed in a timely manner. Based on the common forms
of event logging debugging, dedicated tools can check them and
remind developers to delete them if debugging has finished. Also,
by conducting advanced analysis ( e.g., alias analysis), dedicated
tools can check whether there exist redundant event uses that
record the same content and suggest the redundancy removal.
6.4 Move
Category move accounts for a relatively small percentage (5.73%)
of the 419 modifications. The reasons for changes in this category
cannot be easily determined. We list the types of move below and
try to give reasons for some of them.
Figure 8: Example of Move Change.
58.33% (14 instances) of modifications in this category are mov-
ing the event use code from before an operation (such as transaction,
assignment, authorization, etc.) to the after of the operation. An
example is shown in Fig. 8(a). This change type is in line with com-
mon sense, that is, “ finish things first and then record the completed
things ”. It is also compatible with the significant number of post-
transaction and post-assignment additions of event use in Category
Addition . The high percentage of this type of changes suggests that
it is desirable for IDE to warn developers if they put event logging
code before an operation.
29.17% (7 instances) of modifications in this category are moving
the event use code from the inside body of conditional statement
or loop statement to outside, or vice versa. An example is shownESEC/FSE ’23, December 3–9, 2023, San Francisco, CA, USA Lantian Li, Yejian Liang, Zhihao Liu, and Zhongxing Yu
in Fig. 8(b). We can see from the commit message that developer
has changed the conditions for the event logging to trigger. For the
other 6 instances of this type, the commit messages do not have a
clear explanation for the change, but we surmise that the reason
for this type of change is either the condition for triggering event
logging has changed or the original triggering condition is wrong.
There are 2 change instances in this category which instead
move the event logging code from after an operation to the before
of the operation. This change type is anti-intuition and relatively
rare, and there are usually special reasons behind it. For one change
instance (commit 33de75b), the developer’s commit message is “ This
triggered a warning when static analysis tools were used, because
emitting an event is considered a state change. ", so the change aims
to avoid triggering warnings from static analysis tools. For the
other change instance (commit 3cc7b64), the developer’s commit
message is “ Moved the CreatePool event before the AddLiquidity
event for cleaner subgraph code ", so the purpose of the change it to
clean code. Due to the small number of occurrences, there is little
commonality in the reasons.
Finding 8 : For changes that move an event use, developers fre-
quently move an event use from before an operation (such as
transaction, assignment, authorization, etc.) to the after of the
operation (58.33%). In addition, they also often move the event use
from the inside body of conditional statement or loop statement
to outside, or vice versa (29.17%).
Implication 8 : Developers are conservative in moving event
use code. Given event use in general is placed after an operation,
dedicated tools can check whether event use is placed before an
operation and warn developers about this abnormal behaviour.
6.5 Replacement
Category Replacement accounts for a very small percentage (1.19%)
of the 419 modifications (note for changes in this category, even
though the recorded value has not changed, but the names of the
two events are different and this will be reflected in transaction logs),
and it arises as the wrong event is used at the beginning or there is
an event that is more suitable for recording the needed information.
With regard to the reason, it is speculated that developer defines too
many events or the locations of the event definitions are scattered,
so they forget which events have been defined. It is in general
impossible to determine whether a certain event use should be
replaced by another event use, but we can justify some of these
modifications by analyzing whether the name of the function where
the event use is located has a corresponding relationship with the
name of the event. An example is shown in Fig. 9. In this example,
the developer uses the EscrowWithdrawn event in the refund
function, which is later changed to the EscrowRefunded event.
It can be seen that the name of the event used at the beginning does
not match with the name of the function where it is located.
Figure 9: Example of Replacement Change.7 PROBLEMATIC EVENT LOGGING
PARAMETER CHECKER FOR GAS SAVING
To demonstrate the possibility of automatic event logging sup-
port on top of our findings, we design a simple parameter-level
checker to detect a particular type of problematic event logging
code which consumes extra gas than needed. The checker is moti-
vated by the non-neglectable number of parameter changes that
replace Storage type variable with Memory type variable (Finding
5), and contributes to saving gas.
Our observation is that when we use event logging to store the
value of a certain variable in transaction log, Memory type variable
would be preferable to Storage type variable if they hold the same
value. Note that both the Storage type variable and Memory type
variable are already declared elsewhere in the code, we are not
changing their definitions and we just reference them as event
parameters. Since these two variables share the same value, the
stored value in the transaction log will be the same. Since we are
not changing the definitions and value of Storage type variables,
the persistence of Storage type variable on the blockchain will not
be impacted. Thus, changing the parameter of an event use from a
Storage type variable to another Memory type variable (when these
two variables share the same value) will not impact code semantics.
The checker is implemented in approximately 800 lines of Python
excluding dependencies, comments, and empty lines, and is built
uponpython-solidity-parser [15] which can partially com-
pile Solidity code snippet. In particular, the checker relies on the
parsed AST to work. It takes the path of the contract or the project
directory as an input, and then analyzes whether each contract in
the directory has gas optimization opportunities and outputs the
following information if so: (1) The contract line number for which
the gas can be optimized; (2) The specific event use in the line to
optimize; (3) The specific Storage type variable of the identified
event use; (4) The specific Memory type variable to replace the iden-
tified Storage type variable. In particular, the checker contains two
major phases. First, it identifies all event use code in the contract
whose parameters involve a certain Storage type variable. Then,
it checks whether there exists an in-scope Memory type variable
whose value is the same as the Storage type variable.
To investigate the effectiveness of the tool on the most popu-
lar projects, we applied the checker to the top 200 (in terms of
stargazers counts) GitHub Solidity projects. The checker detected
that 35 projects suffered from this issue for their latest versions
of code. In total, there are 207 problematic event logging uses. For
each of the 35 projects, we opened an issue which includes the
following information: (1) A short message explaining the purpose
of our study; (2) The explanation of our finding about gas saving
opportunities involving Memory and Storage type variables; (3) The
exact code line(s) and variable(s) for which gas can be optimized
based on our finding (with the code snippet embed); (4) A ques-
tion about confirmation of the detected problem. The owners of 9
projects have already confirmed the detected problems (confirming
103 problematic event logging uses in total) and most of them have
merged the changes into the code base. We have received very pos-
itive feedback from Solidity developers. One developer said “This is
interesting, thanks a lot for taking the time to identify this optimiza-
tion”. This result suggests that on top of our findings, even a simple,Understanding Solidity Event Logging Practices in the Wild ESEC/FSE ’23, December 3–9, 2023, San Francisco, CA, USA
proof-of-concept checker can effectively contribute to improving
the quality of Solidity event logging instructions. In particular, the
result confirms that to obtain systematic and automatic assistance
for better event logging, the first essential step is to understand the
current manual efforts involved with event logging.
8 THREATS TO VALIDITY
External Validity. First, our study uses Solidity projects hosted on
GitHub and these projects may not be sufficiently diverse or rep-
resentative. Thus, whether the results can be generalized to other
Solidity projects ( e.g., hosted on BitBucket) is a potential issue. To
mitigate this threat, our study accounts for a considerable number
of popular Solidity projects on GitHub and the existing study [ 38]
suggests that popular Solidity projects on GitHub will cover diverse
application domains (like auctions and tokens). Second, we sample
certain independent event logging code modifications to under-
stand the underlying reason. To reduce the sampling bias, we have
ensured that the results fall under the confidence level of 95% with
a confidence interval of ±5%. Third, while we use stargazers counts
to select popular projects and previous works have suggested the
existence of many popular, deployed projects on GitHub [ 12,38],
it is possible that sample, not-deployed projects sneak into our
dataset. Finally, the proof-of-concept checker is evaluated only on
the top 200 popular GitHub projects and more evaluations need to
be conducted to see its effectiveness in a more general sense.
Internal Validity. Our study methodology in Section 3.2 involves
two manual processes and bias can possibly be introduced. To mit-
igate this threat, each manual analysis will involve two distinct
authors of the paper. They independently conduct the analysis and
the analysis results will be compared. In particular, for the manual
examination of the characteristics of the 419 sampled independent
event logging code modifications, we examine developers’ com-
mit messages, source code, together with the event logging code
modifications to reason about the modifications.
Construct Validity. For all of our developed programs, in particu-
lar the utility to calculate LOC and the proof-of-concept checker,
we have performed thorough testing to ensure their correctness.
9 RELATED WORK
Empirical Study on Smart Contract. The transaction-reverting
statement can effectively protect smart contracts against abnor-
mal or malicious attacks. To explore how developers can enhance
transaction-reverting statements, Liu et al. [ 24] analyze the security
implications of transaction-reverting statements. Mariano et al. [ 27]
conduct an empirical study of loops in Ethereum smart contracts
and they cluster smart contract loops according to their semantic
features. Durieux et al. [ 12] conduct an empirical study to analyze
and compare several state-of-the-art smart contract analysis tools.
To our knowledge, our work is the first to explore Solidity event
logging feature and gives a systematic study about density and in
particular evolution of Solidity event logging code.
Smart Contract Analysis and Verification. As vulnerabilities
in smart contract can potentially be exploited, recent years have
witnessed a surge of proposed approaches to ensure that smart
contracts are free of vulnerabilities. Securify [ 34] and Ethainter
[8] leverage the rewriting system Datalog to detect vulnerabilitiesthrough pattern matching. Luu et al. [ 25] present an approach
which uses symbolic execution to find potential security bugs in
smart contracts. Rodler et al. [ 31] design a framework for on-the-fly
automatic patching of faulty smart contracts. Ren et al. [ 30] design a
security-enhanced code suggestion module on top of a bidirectional
LSTM network. Compared to these approaches, our work instead
aims to uncover the practical issues faced by Solidity developers
(when using the event feature) and inspire the development of
analysis and verification methods to alleviate the issues.
Research on Logging. In general, logging messages can improve
program comprehension and reduce maintenance costs. Yuan et al.
[45,47] conduct a series of studies about logging in system software,
covering characteristics study, tool design for log enhancement, etc.
Chen and Jiang [ 10] conduct the first large-scale empirical study of
the use of Java log tools in the wild. Kim et al. [ 18] propose a log
analysis system on top of log history. The system uses statistical
text mining techniques to calculate significance and noise scores
for each log line, and then highlights abnormal log lines based on
the calculated scores. Le et al. [ 19] propose a log-based anomaly
detection method that does not demand parse of log messages. So-
lidity event logging features a few important distinctions compared
to conventional logging (as given in Section 1), and thus it is impor-
tant to study how Solidity developers use event logging in practice.
We in this paper fill the research gap by conducting a large-scale
empirical study about Solidity event logging practices in the wild.
10 CONCLUSION
We provide the first quantitative characteristic study of the current
Solidity event logging practices using 2,915 Solidity projects hosted
on GitHub. The study methodically investigates the pervasiveness
of event logging, the goodness of event logging practice, and in
particular the reasons for event logging code evolution, and de-
livers 8 original and important findings. We additionally give the
implications of our findings, and these implications are beneficial
for researchers, language designers, tool builders, and developers in
order to improve all facets of Solidity event logging. Based on one of
our findings, we develop a proof-of-concept checker and effectively
detect problematic event logging code that consumes extra gas in
35 popular GitHub projects and 9 project owners have confirmed
the detected issues. For future work, we would like to develop tools
that conduct systematic testing of event logging behaviours based
on our findings. We are also passionate about building an advanced
tool on top of our findings which can effectively support automatic
code transforms related with Solidity event logging, including bug
fixing, refactoring, and optimization.
11 DATA AVAILABILITY
Our replication package (including code, dataset, etc.) is available
at https://github.com/zhongxingyu/Solidity-Event-Study.
ACKNOWLEDGMENTS
We are grateful to the anonymous reviewers for their insightful
comments. This work was partially supported by National Natu-
ral Science Foundation of China (Grant No. 62102233), Shandong
Province Overseas Outstanding Youth Fund (Grant No. 2022HWYQ-
043), and Qilu Young Scholar Program of Shandong University.ESEC/FSE ’23, December 3–9, 2023, San Francisco, CA, USA Lantian Li, Yejian Liang, Zhihao Liu, and Zhongxing Yu
REFERENCES
[1] 2017. Understanding The DAO Attack . https://tinyurl.com/yc3o8ffk/
[2]Elvira Albert, Pablo Gordillo, Alejandro Hernández-Cerezo, Albert Rubio, and
Maria A. Schett. 2022. Super-Optimization of Smart Contracts. ACM Trans. Softw.
Eng. Methodol. 31, 4, Article 70 (jul 2022), 29 pages. https://doi.org/10.1145/
3506800
[3]Andreas M Antonopoulos and Gavin Wood. 2018. Mastering Ethereum: Building
Smart Contracts and DApps . O’Reilly Media, Incorporated. https://books.google.
com.hk/books?id=SedSMQAACAAJ
[4]Andreas M Antonopoulos and Gavin Wood. 2018. Mastering ethereum: building
smart contracts and dapps . O’reilly Media.
[5]Nicola Atzei, Massimo Bartoletti, and Tiziana Cimoli. 2017. A Survey of Attacks
on Ethereum Smart Contracts SoK. In Proceedings of the 6th International Confer-
ence on Principles of Security and Trust - Volume 10204 . Springer-Verlag, Berlin,
Heidelberg, 164–186. https://doi.org/10.1007/978-3-662-54455-6_8
[6]Ivan Beschastnikh, Yuriy Brun, Michael D Ernst, Arvind Krishnamurthy, and
Thomas E Anderson. 2011. Mining temporal invariants from partially ordered
logs. In Managing Large-scale Systems via the Analysis of System Logs and the
Application of Machine Learning Techniques . 1–10.
[7]Hudson Borges and Marco Tulio Valente. 2018. What’s in a GitHub Star? Under-
standing Repository Starring Practices in a Social Coding Platform. Journal of Sys-
tems and Software 146 (2018), 112–129. https://doi.org/10.1016/j.jss.2018.09.016
[8]Lexi Brent, Neville Grech, Sifis Lagouvardos, Bernhard Scholz, and Yannis
Smaragdakis. 2020. Ethainter: A Smart Contract Security Analyzer for Com-
posite Vulnerabilities. In Proceedings of the 41st ACM SIGPLAN Conference
on Programming Language Design and Implementation (London, UK) (PLDI
2020) . Association for Computing Machinery, New York, NY, USA, 454–469.
https://doi.org/10.1145/3385412.3385990
[9]Boyuan Chen and Zhen Ming Jiang. 2017. Characterizing and detecting anti-
patterns in the logging code. In 2017 IEEE/ACM 39th International Conference on
Software Engineering (ICSE) . IEEE, 71–81.
[10] Boyuan Chen and Zhen Ming Jiang. 2020. Studying the use of java logging
utilities in the wild. In 2020 IEEE/ACM 42nd International Conference on Software
Engineering (ICSE) . IEEE, 397–408.
[11] Yali Du and Zhongxing Yu. 2023. Pre-training Code Representation with Semantic
Flow Graph for Effective Bug Localization. In Proceedings of the 31th ACM Joint
Meeting on European Software Engineering Conference and Symposium on the
Foundations of Software Engineering .
[12] Thomas Durieux, João F Ferreira, Rui Abreu, and Pedro Cruz. 2020. Empirical
review of automated analysis tools on 47,587 Ethereum smart contracts. In Pro-
ceedings of the ACM/IEEE 42nd International conference on software engineering .
530–541.
[13] Joel Frank, Cornelius Aschermann, and Thorsten Holz. 2020. ETHBMC: A
Bounded Model Checker for Smart Contracts. In Proceedings of the 29th USENIX
Conference on Security Symposium (SEC’20) . USENIX Association, USA, Article
155, 18 pages.
[14] Qiang Fu, Jieming Zhu, Wenlu Hu, Jian-Guang Lou, Rui Ding, Qingwei Lin,
Dongmei Zhang, and Tao Xie. 2014. Where do developers log? an empirical
study on logging practices in industry. In Companion Proceedings of the 36th
International Conference on Software Engineering . 24–33.
[15] github. 2020. GitHub. https://github.com/ConsenSys/python-solidity-parser
[16] Shilin He, Pinjia He, Zhuangbin Chen, Tianyi Yang, Yuxin Su, and Michael R
Lyu. 2021. A survey on automated log analysis for reliability engineering. ACM
Computing Surveys (CSUR) 54, 6 (2021), 1–37.
[17] Dong Jae Kim, Nikolaos Tsantalis, Tse-Hsun Peter Chen, and Jinqiu Yang. 2021.
Studying Test Annotation Maintenance in the Wild. In Proceedings of the 43rd
International Conference on Software Engineering (Madrid, Spain) (ICSE ’21) . IEEE
Press, 62–73. https://doi.org/10.1109/ICSE43902.2021.00019
[18] Jinhan Kim, Valeriy Savchenko, Kihyuck Shin, Konstantin Sorokin, Hyunseok
Jeon, Georgiy Pankratenko, Sergey Markov, and Chul-Joo Kim. 2020. Automatic
abnormal log detection by analyzing log history for providing debugging insight.
In2020 IEEE/ACM 42nd International Conference on Software Engineering: Software
Engineering in Practice (ICSE-SEIP) . IEEE, 71–80.
[19] Van-Hoang Le and Hongyu Zhang. 2021. Log-based anomaly detection with-
out log parsing. In 2021 36th IEEE/ACM International Conference on Automated
Software Engineering (ASE) . IEEE, 492–504.
[20] Claire Le Goues, ThanhVu Nguyen, Stephanie Forrest, and Westley Weimer. 2012.
GenProg: A Generic Method for Automatic Software Repair. IEEE Transactions
on Software Engineering 38, 1 (2012), 54–72. https://doi.org/10.1109/TSE.2011.104
[21] Heng Li, Tse-Hsun Peter Chen, Weiyi Shang, and Ahmed E Hassan. 2018. Studying
software logging using topic models. Empirical Software Engineering 23, 5 (2018),
2655–2694.
[22] Heng Li, Weiyi Shang, Bram Adams, Mohammed Sayagh, and Ahmed E Hassan.
2020. A qualitative study of the benefits and costs of logging from developers’
perspectives. IEEE Transactions on Software Engineering (2020).
[23] Zhenhao Li, Tse-Hsun Chen, Jinqiu Yang, and Weiyi Shang. 2019. DLFinder:
characterizing and detecting duplicate logging code smells. In 2019 IEEE/ACM
41st International Conference on Software Engineering (ICSE) . IEEE, 152–163.[24] Lu Liu, Lili Wei, Wuqi Zhang, Ming Wen, Yepang Liu, and Shing-Chi Cheung.
2021. Characterizing Transaction-Reverting Statements in Ethereum Smart
Contracts. In 2021 36th IEEE/ACM International Conference on Automated Software
Engineering (ASE) . IEEE, 630–641.
[25] Loi Luu, Duc-Hiep Chu, Hrishi Olickel, Prateek Saxena, and Aquinas Hobor.
2016. Making Smart Contracts Smarter. In Proceedings of the 2016 ACM SIGSAC
Conference on Computer and Communications Security (Vienna, Austria) (CCS
’16). Association for Computing Machinery, New York, NY, USA, 254–269. https:
//doi.org/10.1145/2976749.2978309
[26] Loi Luu, Jason Teutsch, Raghav Kulkarni, and Prateek Saxena. 2015. Demystifying
Incentives in the Consensus Computer. In Proceedings of the 22nd ACM SIGSAC
Conference on Computer and Communications Security (Denver, Colorado, USA)
(CCS ’15) . Association for Computing Machinery, New York, NY, USA, 706–719.
https://doi.org/10.1145/2810103.2813659
[27] Benjamin Mariano, Yanju Chen, Yu Feng, Shuvendu K Lahiri, and Isil Dillig.
2020. Demystifying loops in smart contracts. In 2020 35th IEEE/ACM International
Conference on Automated Software Engineering (ASE) . IEEE, 262–274.
[28] Martin Monperrus. 2018. Automatic software repair: a bibliography. ACM
Computing Surveys (CSUR) 51, 1 (2018), 1–24.
[29] Nachiappan Nagappan and Thomas Ball. 2005. Use of Relative Code Churn
Measures to Predict System Defect Density. In Proceedings of the 27th International
Conference on Software Engineering (St. Louis, MO, USA) (ICSE ’05) . ACM, New
York, NY, USA, 284–292. https://doi.org/10.1145/1062455.1062514
[30] Meng Ren, Fuchen Ma, Zijing Yin, Ying Fu, Huizhong Li, Wanli Chang, and Yu
Jiang. 2021. Making smart contract development more secure and easier. In
Proceedings of the 29th ACM Joint Meeting on European Software Engineering
Conference and Symposium on the Foundations of Software Engineering . 1360–
1370.
[31] Michael Rodler, Wenting Li, Ghassan O Karame, and Lucas Davi. 2021.
{EVMPatch}: Timely and automated patching of ethereum smart contracts.
In30th USENIX Security Symposium (USENIX Security 21) . 1289–1306.
[32] Samuel Steffen, Benjamin Bichsel, Mario Gersbach, Noa Melchior, Petar Tsankov,
and Martin Vechev. 2019. Zkay: Specifying and Enforcing Data Privacy in Smart
Contracts. In Proceedings of the 2019 ACM SIGSAC Conference on Computer and
Communications Security (London, United Kingdom) (CCS ’19) . Association for
Computing Machinery, New York, NY, USA, 1759–1776. https://doi.org/10.1145/
3319535.3363222
[33] Nick Szabo. 1997. The idea of smart contracts . https://www.fon.hum.uva.nl/
rob/Courses/InformationInSpeech/CDROM/Literature/LOTwinterschool2006/
szabo.best.vwh.net/idea.html
[34] Petar Tsankov, Andrei Dan, Dana Drachsler-Cohen, Arthur Gervais, Florian
Bünzli, and Martin Vechev. 2018. Securify: Practical Security Analysis of Smart
Contracts. In Proceedings of the 2018 ACM SIGSAC Conference on Computer and
Communications Security (Toronto, Canada) (CCS ’18) . Association for Computing
Machinery, New York, NY, USA, 67–82. https://doi.org/10.1145/3243734.3243780
[35] Simon Urli, Zhongxing Yu, Lionel Seinturier, and Martin Monperrus. 2018. How
to Design a Program Repair Bot? Insights from the Repairnator Project. In Pro-
ceedings of the 40th International Conference on Software Engineering: Software
Engineering in Practice (Gothenburg, Sweden) (ICSE-SEIP ’18) . Association for
Computing Machinery, New York, NY, USA, 95–104. https://doi.org/10.1145/
3183519.3183540
[36] W. Eric Wong, Ruizhi Gao, Yihao Li, Rui Abreu, and Franz Wotawa. 2016. A
Survey on Software Fault Localization. IEEE Transactions on Software Engineering
42, 8 (2016), 707–740. https://doi.org/10.1109/TSE.2016.2521368
[37] Karl Wüst, Sinisa Matetic, Silvan Egli, Kari Kostiainen, and Srdjan Capkun. 2020.
ACE: Asynchronous and Concurrent Execution of Complex Smart Contracts. In
Proceedings of the 2020 ACM SIGSAC Conference on Computer and Communications
Security (Virtual Event, USA) (CCS ’20) . Association for Computing Machinery,
New York, NY, USA, 587–600. https://doi.org/10.1145/3372297.3417243
[38] Valentin Wüstholz and Maria Christakis. 2020. Targeted Greybox Fuzzing with
Static Lookahead Analysis. In Proceedings of the ACM/IEEE 42nd International
Conference on Software Engineering (Seoul, South Korea) (ICSE ’20) . Association
for Computing Machinery, New York, NY, USA, 789–800. https://doi.org/10.
1145/3377811.3380388
[39] Zhongxing Yu, Chenggang Bai, and Kai-Yuan Cai. 2013. Mutation-Oriented Test
Data Augmentation for GUI Software Fault Localization. Inf. Softw. Technol. 55,
12 (dec 2013), 2076–2098. https://doi.org/10.1016/j.infsof.2013.07.004
[40] Zhongxing Yu, Chenggang Bai, and Kai-Yuan Cai. 2015. Does the Failing Test
Execute a Single or Multiple Faults? An Approach to Classifying Failing Tests. In
Proceedings of the 37th International Conference on Software Engineering - Volume
1(Florence, Italy) (ICSE ’15) . IEEE Press, 924–935.
[41] Zhongxing Yu, Chenggang Bai, Lionel Seinturier, and Martin Monperrus. 2021.
Characterizing the Usage, Evolution and Impact of Java Annotations in Practice.
IEEE Transactions on Software Engineering 47, 5 (2021), 969–986. https://doi.org/
10.1109/TSE.2019.2910516
[42] Zhongxing Yu, Hai Hu, Chenggang Bai, Kai-Yuan Cai, and W. Eric Wong.
2011. GUI Software Fault Localization Using N-gram Analysis. In 2011 IEEE
13th International Symposium on High-Assurance Systems Engineering . 325–332.Understanding Solidity Event Logging Practices in the Wild ESEC/FSE ’23, December 3–9, 2023, San Francisco, CA, USA
https://doi.org/10.1109/HASE.2011.29
[43] Zhongxing Yu, Matias Martinez, Zimin Chen, Tegawendé F. Bissyandé, and
Martin Monperrus. 2023. Learning the Relation Between Code Features and
Code Transforms With Structured Prediction. IEEE Transactions on Software
Engineering 49, 7 (2023), 3872–3900. https://doi.org/10.1109/TSE.2023.3275380
[44] Zhongxing Yu, Matias Martinez, Benjamin Danglot, Thomas Durieux, and Martin
Monperrus. 2019. Alleviating Patch Overfitting with Automatic Test Generation:
A Study of Feasibility and Effectiveness for the Nopol Repair System. Empirical
Softw. Engg. 24, 1 (feb 2019), 33–67. https://doi.org/10.1007/s10664-018-9619-4
[45] Ding Yuan, Haohui Mai, Weiwei Xiong, Lin Tan, Yuanyuan Zhou, and Shankar
Pasupathy. 2010. SherLog: Error Diagnosis by Connecting Clues from Run-Time
Logs. In Proceedings of the Fifteenth International Conference on Architectural
Support for Programming Languages and Operating Systems (Pittsburgh, Pennsyl-
vania, USA) (ASPLOS XV) . Association for Computing Machinery, New York, NY,
USA, 143–154. https://doi.org/10.1145/1736020.1736038
[46] Ding Yuan, Soyeon Park, Peng Huang, Yang Liu, Michael M Lee, Xiaoming
Tang, Yuanyuan Zhou, and Stefan Savage. 2012. Be conservative: Enhancing
failure diagnosis with proactive logging. In 10th USENIX Symposium on OperatingSystems Design and Implementation (OSDI 12) . 293–306.
[47] Ding Yuan, Soyeon Park, and Yuanyuan Zhou. 2012. Characterizing Logging Prac-
tices in Open-Source Software. In Proceedings of the 34th International Conference
on Software Engineering (Zurich, Switzerland) (ICSE ’12) . IEEE Press, 102–112.
[48] Ding Yuan, Jing Zheng, Soyeon Park, Yuanyuan Zhou, and Stefan Savage. 2011.
Improving Software Diagnosability via Log Enhancement. SIGARCH Comput.
Archit. News 39, 1 (mar 2011), 3–14. https://doi.org/10.1145/1961295.1950369
[49] Haoxiang Zhang, Shaowei Wang, Tse-Hsun (Peter) Chen, and Ahmed E. Hassan.
2021. Are Comments on Stack Overflow Well Organized for Easy Retrieval by
Developers? ACM Trans. Softw. Eng. Methodol. 30, 2, Article 22 (feb 2021), 31 pages.
https://doi.org/10.1145/3434279
[50] Jieming Zhu, Pinjia He, Qiang Fu, Hongyu Zhang, Michael R. Lyu, and Dongmei
Zhang. 2015. Learning to Log: Helping Developers Make Informed Logging Deci-
sions. In Proceedings of the 37th International Conference on Software Engineering
- Volume 1 (Florence, Italy) (ICSE ’15) . IEEE Press, 415–425.
Received 2023-02-02; accepted 2023-07-27