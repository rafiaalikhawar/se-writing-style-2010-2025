Precise Divide-By-Zero Detection with Affirmative Evidence
Yiyuan Guo
The Hong Kong University of Science
and Technology
Hong Kong, China
yguoaz@cse.ust.hkJinguo Zhou
Ant Group
China
jinguo.zjg@antgroup.comPeisen Yao
The Hong Kong University of Science
and Technology
Hong Kong, China
pyao@cse.ust.hk
Qingkai Shi
Ant Group
China
qingkai.sqk@antgroup.comCharles Zhang
The Hong Kong University of Science
and Technology
Hong Kong, China
charlesz@cse.ust.hk
ABSTRACT
The static detection of divide-by-zero, a common programming
error,isparticularlypronetofalsepositivesbecauseconventional
static analysis reports a divide-by-zero bug whenever it cannot
provethesafetypropertyâ€”thedivisorvariableisnotzeroinallexecutions. When reasoning the program semantics over a large
numberofunder-constrainedvariables,conventionalstaticanaly-
ses significantly loose the bounds of divisor variables, which easily
fails the safety proof and leads to a massive number of false pos-itives. Wepropose a static analysisto detect divide-by-zero bugstaking additional evidence for under-constrained variables intoconsideration. Based on an extensive empirical study of known
divide-by-zero bugs, we no longer arbitrarily report a bug once the
safety verification fails. Instead, we actively look for affirmative
evidences, namely source evidence and bound evidence, that imply
a high possibility of the bug to be triggerable at runtime. When
applyingourtoolWittothereal-worldsoftwaresuchastheLinux
kernel, we have found 72 new divide-by-zero bugs with a low false
positive rate of 22%.
CCS CONCEPTS
â€¢Software and its engineering â†’Software verification and
validation.
KEYWORDS
Static program analysis, bug detection, divide-by-zero.
ACM Reference Format:
Yiyuan Guo, Jinguo Zhou, Peisen Yao, Qingkai Shi, and Charles Zhang.
2022. Precise Divide-By-Zero Detection with Affirmative Evidence . In
44thInternationalConferenceonSoftwareEngineering(ICSEâ€™22),May21â€“
29, 2022, Pittsburgh, PA, USA. ACM, New York, NY, USA, 12pages.https:
//doi.org/10.1145/3510003.3510066
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACMmustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
Â© 2022 Association for Computing Machinery.
ACM ISBN 978-1-4503-9221-1/22/05...$15.00
https://doi.org/10.1145/3510003.35100661 INTRODUCTION
Divide-by-zeroisoneofthemostcommonprogrammingerrorsthat
can lead to undefined runtime behaviors. Over the past five years,
there are more than 90 security vulnerabilities related to divide-by-
zero documented in the Common Vulnerabilities and Exposures
(CVE) database. Static analysis is an important approach to combat
this problem. However, its high false positive rate remains a major
obstacleforadoption.Inourexperiments,weobservefalsepositive
rates of over 70% in representative static analyzers.
To understand the reason behind these high false positive rates,
we first examine how static analysis reports a potential divide-
by-zero bug. The central question is how to decide if the divisor
variable may equal zero in some executions. More specifically, a
divide-by-zero happens when
C1.Thereexistsafeasibleexecutionpath ğ‘ƒreachingthedivision
instruction (Let ğ‘ğ‘denote the path condition for ğ‘ƒ).
C2.The divisor variable ğ‘£may equal zero when ğ‘ƒreaches the
division instruction (Let ğ‘„def=(ğ‘£=0)denote the error
condition for triggering a divide-by-zero bug).
Conventionally,staticanalysisreportsadivide-by-zerobugif ğ‘ğ‘âˆ§ğ‘„
is satisfiable, i.e., under the condition ğ‘ğ‘, the divisor variable ğ‘£can-
notbeprovedtobenon-zero.However,weobservethatthisscheme
often leads to a high false positive rate in divide-by-zero detection
since the under-constrainedness of static analysis makes it easy to
satisfy the query ğ‘ğ‘âˆ§ğ‘„. Many variables are under-constrained in
the static analysis [13]:
â€¢The program under analysis can be an open program. For
example, the analysis often sees a module by interface only,
of which the variables are under-constrained [11, 15].
â€¢The inherent limitations of static analysis introduce the
under-constrained variables to represent imprecision in the
analysis, e.g., the runtime state of the operating system and
thepresenceofunmodeledcodeconstructs,suchasinline
assembly and many others [13, 14].
To improve the precision, our key insight is that, instead of
reportingerrorswheneversafetyverificationfails,wecanattack
the divide-by-zero detection problem from a different angle by
activelyfindingaffirmativeevidencefortriggeringthebug.Such
evidence serves as the extra information on the under-constrained
variables, thus contributes to improving the precision.
17182022 IEEE/ACM 44th International Conference on Software Engineering (ICSE)
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:32:16 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Yiyuan Guo, Jinguo Zhou, Peisen Yao, Qingkai Shi, and Charles Zhang
1structcontrol_panel {
2intx;inty;intz;
3intflag;intdistantce; ...
4};
5
6voidtop_fun() { // not tracked by the analysis when analyzing move
7...
8if( d x! =0& &d y! =0 )
9// calls move with nonâˆ’zero values of dx and dy.
10 move(dx, dy, d, ctr);
11}
12
13voidmove (int dx,intdy,intd, control_panel âˆ—ctr) {
14intdiff;
15if(dx >= dy)
16 diff=1+dxâˆ’dy;
17else
18 diff = âˆ’1;
19
20ctrâˆ’>z += get_step(ctr, diff);
21if( d x> =d| |d y> =d )
22 ctrâˆ’>setFlag(LONG_MOVE);
23
24intdz = 2âˆ—dx âˆ’ (dy+d);
25ctrâˆ’>x += get_step(ctr, dx);
26ctrâˆ’>y += get_step(ctr, dy);
27ctrâˆ’>z += get_step(ctr, dz);
28}
29
30intget_step(control_pane âˆ—ctr, intstep_size) {
31returnctrâˆ’>distantce / step_size;
32}
Figure 1: A motivating example.
We use the motivating example in Figure 1to illustrate the idea.
In Figure 1, the function moveupdates the control panel ctrby
adding values to its (x,y,z) coordinates computed in the function
get_step throughadivisionoperation.Also,weassumethatthe
caller function top_fun for the function moveis external to the
module under analysis and, thus, not tracked by the analysis. Now
consider how static analysis can detect potential divide-by-zero
errors in this program.
Line 20 cannot trigger a divide-by-zero because the used divisor
diffis eitherâˆ’1 or no less than 1. A path-sensitive static analysis
correctlyverifiesitssafetysincethetwoqueries dxâ‰¥dyâˆ§1+dxâˆ’
dy=0 anddx<dyâˆ§âˆ’1=0 associated with thetwo paths across
Lines 15-18 are both unsatisfiable.
However,thepath-sensitivestaticanalysisstillencountersthe
precision problem. In our example, the divide-by-zero errors are
reported for the three calls to get_step at Line 25, 26, and 27
because the queries dx=0,dy=0, anddz=0 are all satisfiable.
However,since top_funonlycalls movewithnon-zerovaluesfor dx
anddy(Line 10), the reports at Lines 25-26 are false positives. This
fact is unknown to the static analysis because it fails to trace back
to the origin of the arguments of movein the function top_fun.
Ontheotherhand,wenoticethatthedivide-by-zeroreportat
Line 27hashigh confidenceto betrue sincewe canfind evidence
to explain it. Specifically, Line 21 of Figure 1explicitly compares
dxanddywith d, suggesting that the programmer has beliefs [ 16]
thattheymaybeequalto d.Ifsuchbeliefsactuallyhold, dzmust
equal zero at Line 24, i.e., dz = 2*dx-(dy+d) = 2*d-(d+d) = 0 ,
leading to a plausible divide-by-zero report for Line 27.How to report the high confidence divide-by-zero bug at Line
27 instead of the false positives at Lines 25-26? Note that all of the
three divisions cannot be proved safe by the static analysis, regard-
less of being path-sensitive or not. H owever, we have identified
theevidence basedon analyzing theprogrammerâ€™s beliefsforthe
bugreportatLine27,whichleadstoitshighconfidencetooccur.
Specifically, in this work, we identify two categories of evidence:
(a)Source evidence : The fact that an explicit source of â€œbadâ€
valueisassignedtoavariable ğ‘£.Thesourcecanbeeithera
directassignmentofzero(e.g.,theassignment v:=0)ortakes
the value of some tainted input (e.g., v:=atoi(argv[1])).
(b)Bound evidence :Theequalityfact ğ‘£1=ğ‘£2generatedfrom
aboundcheckingstatementintheprogramthatcompares
ğ‘£1andğ‘£2. Statements like Line 21 of Figure 1that check
numerical bounds of variables can convey the important
informationonthepossiblevaluesofthecheckedvariables:acomparisonbetween
ğ‘£1andğ‘£2suggeststhattheprogrammer
may believe that ğ‘£1can equalğ‘£2.
With the generated evidence, our method reports a divide-by-zero
bug by adapting the requirements C1 and C2 as follows.
C1*.C1andC2hold: ğ‘ğ‘âˆ§ğ‘„issatisfiable,where ğ‘ğ‘denotesthe
path condition for reaching the division instruction, and
ğ‘„â‰¡(ğ‘£=0)is the error condition for divide-by-zero.
C2*. One of the following conditions holds:
â€¢The divisor variable ğ‘£has the source evidence.
â€¢There exists a set ğ¸of bound evidence consistent with ğ‘ğ‘
such thatğ‘£mustbe zero under ğ¸.
In other words, we seek to detect a fraction of divide-by-zero bugs
withhighconfidencebyfindingtheaffirmativeevidencetoexplain
its occurrence. For example, in Figure 1,ğ‘‘ğ‘§at Line 27 is the only
variable that meets these requirements: ğ‘‘ğ‘§=0musthold if the
evidenceğ‘‘ğ‘¥=ğ‘‘andğ‘‘ğ‘¦=ğ‘‘hold. Hence, our approach will only
report one divide-by-zero bug at Line 27.
Inthispaper,weproposeWit,aframeworkfortheprecisede-
tection of divide-by-zero with the affirmative evidence. First, to
understandtheapplicabilityofourdefinitionofevidenceandthecri-teriaC1*-C2*fordetectingbugs,weperformanempiricalstudyonexistingCVEsrelatedtodivide-by-zerobugsandinvestigateifthey
can be detected by finding a set of supporting evidence. The result
showsthat74%ofthestudieddivide-by-zerobugshavethesupport-ingevidencethatexplainsitsoccurrence,showingthegeneralityofourintuition.Tocapturetheevidence-basedreasoninginachieving
the precise divide-by-zero detection, we design a static analysisalgorithm to perform the evidence-based inference, adhering tothe criteria C1*-C2* for reporting bugs. The algorithm generatesevidence directly from certain code patterns and propagates the
generated evidence path-sensitively. To improve its efficiency, we
utilize a symbolic domain to compactly encode the possible numer-
ical values for variables and apply the data dependence analysis
[17] to prune irrelevant execution paths, scaling to million lines of
code.
In summary, we make the following contributions in this paper:
â€¢The insight for improving the precision of divide-by-zero
detectionbyfindingtheaffirmativeevidencetotriggerthe
bug.
1719
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:32:16 UTC from IEEE Xplore.  Restrictions apply. Precise Divide-By-Zero Detection with Affirmative Evidence ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
â€¢AnempiricalstudyofCVEsrelatedtodivide-by-zerobugs.
We investigate and classify these existing divide-by-zero
bugsandshowthatmanyofthemcanbeeffectivelydetected
based on evidence.
â€¢A formalization of the insight in a semantic framework and
analgorithm forfindinghigh confidencedivide-by-zeroer-
rors through the evidence propagation.
â€¢Animplementationand extensiveevaluationofthe divide-
by-zero checker. We demonstrate that it is both precise and
efficient,uncovering72divide-by-zerobugs(14ofwhichare
confirmed by the developers) in large codebases such as the
Linux kernel with a low false positive rate of 22%.
2 EMPIRICAL STUDY ON DIVIDE-BY-ZERO
BUGS
Tofurtherunderstandtheapplicabilityoftheevidence-baseddivide-
by-zero detection method, we perform an empirical study on CVEs
caused by divide-by-zero bugs. Through the empirical study, we
aim to answer the following research questions:
â€¢RQ1: How often can we find the evidence for the divide-by-
zerobugs?Inotherwords,howoftendoourbugdetection
criteria C1* - C2* apply to the existing divide-by-zero bugs?
â€¢RQ2: What is the distribution for the two kinds of evidence
defined in Â§ 1?
2.1 Data Collection
Wesearchforthekeywordsâ€œdivide-by-zeroâ€andâ€œdividebyzeroâ€
in the CVE database and examine the CVEs starting from the year
2011. There are 123 CVEs in total that are caused by the divide-
by-zero bugs. We exclude the bugs with no source code or stack
traces(16),orunabletounderstandwithoutadeepknowledgeof
the system (12), or sharing the same root with other bugs (8). Thus,
we are left with 87 CVEs to study.
2.2 Classification Criteria
Sinceourgoalistostudytheproblemingeneralwithoutbeingtied
to a specific analysis algorithm or target system, we have adopted
the following criteria to mimic the reasoning process of a static
analyzer:
(1)Starting from the crash site of the bug (i.e., the division
instruction with zero divisor), we manually examine a back-
ward slice Bof some fixed size. In our experiment, we ex-
aminebackwardsatmost10callframesfromtheinvolved
division. This isreasonable as lengthy bug traces outputby
static analyzers take a non-trivialamount of time for users
to triage [1, 4], thus should be avoided by practical tools.
(2)Basedonourmanualinspectionof B,weclassifythedivide-
by-zero bugs based on the evidence found:
(a)ClassSrc:Source evidenceisfound. Anexplicitsource of
zero value for the divisor variable exists in B. The source
is either a direct assignment of zero value to the variableor of a tainted value from the input.
(b)
Class Bd: Bound evidence is found. We can find a set
of evidence from the bound checking statements in BTable 1: Classification of 87 CVEs caused by divide-by-zero
bugs. Class Src is bugs with source evidence (further classi-fied into constant source and taint source), Class Bd is bugs
withboundevidence,andClassUnisbugswithnoevidence.
Class SrcClass Bd Class Src âˆ©Class Bd Class Unconsttaint
192821 4 23
that guarantee the divisor variable to be zero. Specifi-
cally,foranybranchingstatementinvolvingcomparisons:
if (x cmp y) (cmpis<,<=,etc.),weconsiderthefact x=y
as the bound evidence likely to be true.
(c)Class Un: No evidence is found (i.e., unknown). We can
neitherfindsourceevidencenorboundevidencein B.For
example, CVE-2018-19628 is marked as unknown because
it requires a deep context of 14 call frames to understand
the root cause, exceeding the code range of B.
Conventional static analysis methods detect all three classes ofdivide-by-zerobugs.AsillustratedinÂ§ 1,theyarelikelytoincur
massivefalsepositives.OurmethoddetectsbugsofClassSrcand
Class Bd since they are the classes that satisfy the requirement C1*
- C2*, aiming for a fraction of high confidence divide-by-zero bugs
withpossiblefalsenegatives.Theclassificationattemptstostudy
how much can be covered by our method.
2.3 Study Result
Bug Classification . Table1shows the classification result of
the87CVEscausedbydivide-by-zerobugs.ForClassSrcbugswith
explicit sources, we further divide them into two groups: those
with constant zero value as the source (the column labeled with
â€œconstâ€) and those with the tainted input as the source (the column
labeled with â€œtaintâ€). The bugs with both the source evidence and
the bound evidence are counted in the column labeled â€œClass Src âˆ©
Class Bdâ€.
From the data we gather, we answer the two research questions
empirically as follows:
Answer to RQ1: We can find evidence for a large proportion
(ğ‘†ğ‘Ÿğ‘+ğµğ‘‘âˆ’ğ‘†ğ‘Ÿğ‘âˆ©ğµğ‘‘
87=74%) of divide-by-zero bugs. Thus, our
bug detection criteria C1* - C2* are widely applicable.
AnswertoRQ2:Forthedivide-by-zerobugsthatwecanfind
evidence, 73% of them have source evidence, 33% of them
have bound evidence, and 6% of them have both evidence.
Therefore, we conclude that finding evidence to facilitate the
precise divide-by-zero detection indeed works in real scenarios,
coveringalargeproportionofinterestingbugs.Also,bothsource
evidence and bound evidence are useful for bug detection in prac-
tice.
Case Study of Bugs with Evidence . To give an intuitive un-
derstandingofthebugsdetectedbasedonevidence,weillustrate
some example CVEs from Class Src and Bd.
1720
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:32:16 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Yiyuan Guo, Jinguo Zhou, Peisen Yao, Qingkai Shi, and Charles Zhang
1voidstart_input_gif(j_compress_ptr cinfo, cjpeg_source_ptr sinfo) {
2 U_CHAR hdrbuf[10];
3// ReadOK is a wrapper of fread
4if(!ReadOK(sourceâˆ’>pub.input_file, hdrbuf, 6))
5 EREXIT(cinfo, JERR_GIF_NOT);
6 width = LM_to_uint(hdrbuf, 0);
7 height= LM_to_uint(hdrbuf, 2);
8// use the second arg as divisor
9 DIVOP(cinfo, width âˆ— NUMCOLORS);
10 }
(a) Example #1: CVE-2021-20205
1intApplyEvaluateOperator(RandomInfo âˆ—r, Quantum p, Operator op, intv) {
2 ...
3switch(op) {
4caseDivideEvaluateOperator:
5 result=p/( v= =0?1:v ) ;
6 break;
7caseGaussianNoiseEvaluateOperator:
8 result = GenerateDifferentialNoise(r,p,GaussianNoise,v)
9}
10 }
11intGenerateDifferentialNoise(RandomInfo âˆ—r, Quantum p, NoiseType ty, intv)
{
12 ...
13 noise = (QuantumRange âˆ— i / v);
14 }
(b) Example #2: CVE-2021-20176
Figure 2: Example of bugs with evidence.
Figure2ashowsaClassSrcbug.Thebuffer hdrbufistaintedby
the call to ReadOK(Line 4), allowing itto parse the variable width
to zero value, leading to a divide-by-zero bug at Line 9.
Figure2bshows a Class Bd bug. At Line 5 of the code in Fig-
ure2b, the programmer explicitly checks the value of variable ğ‘£
against 0. We can propagate the checked bound as evidence to
Line 8, uncovering a divide-by-zero bug inside the called function
GenerateDifferentialNoise at Line 13. This bug is due to the
fact that the programmer has missed the check at Line 8, which is
successfully captured by the generated bound evidence.
ImplicationsofourFindings .Fromthefindingsofourempir-
ical study, we conclude that:
(1)Manyrealdivide-by-zerobugsdohavethesupportingevi-
dence.Inaddition,boththesourceevidenceandthebound
evidence are useful for understanding existing divide-by-
zerobugs.Thus,criteriaC1*-C2*forthedivide-by-zerode-
tectionareapplicableforalargeproportionofdivide-by-zero
bugs.
(2)Staticanalyzerscanbedesignedtodiscoverandreasonabout
the evidence to achieve precise detection results, aiming for
the high confidence bugs of Class Src and Class Bd.
3 OVERVIEW
Inthissection,wegiveanoverviewofourevidence-baseddivide-
by-zerodetectionmethod,usingthemotivatingexampleinFigure 1.
ExistingApproaches .Beforepresentingourapproach,wefirst
briefly discuss two conventional techniques for divide-by-zero de-
tectionandtheirdrawbacks,namelythenumericalabstractinterpre-tation[
8,9,25]andtheunder-constrainedsymbolicexecution[ 28].If we apply the polyhedra abstract domain [ 9] that is an expres-
sive domain capable of reasoning about the linear relations among
variables,thebranchstatementsfromLine15toLine18inFigure 1
will produce the following abstractions along the two paths:
ğ´ğ‘ğ‘ 1:{dxâˆ’dyâ‰¥0,dxâˆ’dyâˆ’diff+1=0}
ğ´ğ‘ğ‘ 2:{dxâˆ’dyâ‰¤0,diff+1=0}
Since the two abstractions are joined to produce a sound over-
approximationwhenpathsmergeinabstractinterpretation,ase-
vere precision loss can occur. Specifically, since ğ´ğ‘ğ‘ 1/unionsqğ´ğ‘ğ‘ 2=
{diffâ‰¥âˆ’1}, the analysis concludes that diffmay be equal to
zeroandgeneratesafalsepositivedivide-by-zerobugforthecall
at Line 20. Thus, lacking path sensitivity, the numerical abstract
interpretation can be imprecise for divide-by-zero detection.
Ontheotherhand,theunder-constrainedsymbolicexecution
performs the path-by-path exhaustive exploration, starting from
thetestedfunction move(recallweassumethattheanalysisdoes
nottrackthefunction top_fun).Theanalysisrecordsthetwopaths
inthefunction movereachingLine20asthefollowingexecution
states:
ğ‘ 1=(dxâ‰¥dy)âˆ§(diff=1+dxâˆ’dy)
ğ‘ 2=(dx<dy)âˆ§(diff=âˆ’1)
Withthepath-sensitivestateencoding,theunder-constrainedsym-
bolic execution successfully proves that divide-by-zero cannot hap-
pen for Line 20. However, as illustrated in Â§ 1, due to the presence
of the under-constrained variables, we conclude that all three calls
at Lines 25-27 of Figure 1can trigger divide-by-zero with two false
positives. This is because all the execution paths reaching these
lineshavesatisfiableconstraintsfortriggeringdivide-by-zero.Thus,
withoutfindingtheaffirmativeevidence,evenapath-sensitivetech-
nique for divide-by-zero detection can be imprecise when faced
with under-constrained variables.
To summarize, conventional approaches to divide-by-zero detec-
tion suffer from imprecision problems because they may lack path
sensitivity or do not attempt to find evidence for potential bugs.
OurApproach . As illustrated in Â§ 1, our work uses the criteria
C1* - C2* to precisely report potential bugs. We argue that bothpath sensitivity of the analysis and finding affirmative evidenceare crucial in achieving good precision. Thus, we seek to track
the evidence path-sensitively to achieve the precise divide-by-zero
detection.
For this purpose, the analysis needs to reason about the nu-
merical computations path-sensitively and fuse the evidence inthe analysis process. We propose to apply a dedicated symbolic
domain Î“to track the numerical computation in the analysis path-
sensitively and utilize the evidence to refine the analysis result.Specifically,
Î“represents the abstract state for a variable ğ‘£as a
guarded symbolic value set Î“(ğ‘£)={(ğ‘£ğ‘1,ğ‘1),...,(ğ‘£ğ‘ğ‘˜,ğ‘ğ‘˜)}, mean-
ingthatğ‘£==ğ‘£ğ‘ğ‘–mayholdunder thecondition ğ‘ğ‘–.Notethat itis
nontrivialtocompute Î“efficiently,andwedeferthedetailsofthe
algorithm to Â§ 4. For the example in Figure 1, our analysis deduces
that
(1+dxâˆ’dy,dxâ‰¥dy),(âˆ’1,dx<dy)âˆˆ Î“(diff)
(2Ã—dxâˆ’(dy+d),ğ‘¡ğ‘Ÿğ‘¢ğ‘’)âˆˆÎ“(dz)
1721
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:32:16 UTC from IEEE Xplore.  Restrictions apply. Precise Divide-By-Zero Detection with Affirmative Evidence ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
Theanalysissuccessfullyinfersthatnodivide-by-zerocanoccurfor
Line 20 based on the path-sensitive representation of Î“(diff).H o w -
ever,itstillreportstwospuriousdivide-by-zerobugsforLines25-26,
similartotheunder-constrainedsymbolicexecutionapproach,as
the variables dx,dy, and dare under-constrained in Î“.
Thus, to further improve the pr ecision, our analysis attempts to
deduce the evidence for those under-constrained variables. First,
it attempts to find the source evidence fordx,dy, and dby asking
â€œAre these variables tainted?â€. The tracking of the source evidence
can be done by the taint analysis [ 31], following the value that
originatesfromabadsourceandcheckingwhereitflowsto.Inthis
example, no such source evidence exists. On the other hand, the
analysis tries to find the bound evidence to constrain the under-
constrained variables. As introduced in Â§ 1, we generate the bound
evidenceğ‘£1=ğ‘£2fromtheboundcheckingstatementsthatcompare
ğ‘£1withğ‘£2,whichrepresentthepossiblebeliefstheprogrammers
may have. For example, in Figure 1, Lines 15 compares dxwith
dy, while Line 21 compares dxwith danddywith d, causing the
analysis to generate the following bound evidence:
ğ‘‘ğ‘¥=ğ‘‘ğ‘¦,ğ‘‘ğ‘¥=ğ‘‘,ğ‘‘ğ‘¦=ğ‘‘
How can we take advantage of the generated bound evidence toimprove the precision of divide-by-zero detection? We treat thebound evidence as the additional constraints and propagate it to
update the representation of Î“, such that the additional constraints
areenforced.Forthevariable dz,fromtheboundevidenceabove
andtheguardedvalue (2Ã—dxâˆ’(dy+d),ğ‘¡ğ‘Ÿğ‘¢ğ‘’)fordz,wededuce
that
(2Ã—ğ‘âˆ’(ğ‘+ğ‘),ğ‘¡ğ‘Ÿğ‘¢ğ‘’)âˆˆÎ“(ğ‘‘ğ‘§),ğ‘,ğ‘,ğ‘âˆˆ{dx,dy,d}
Apparently, 0 âˆˆÎ“(ğ‘‘ğ‘§)and thus our analysis successfully reports
Line 27 of Figure 1as a divide-by-zero bug. Meanwhile, since no
evidence is inferred for dxordyto be zero (i.e., 0 âˆ‰Î“(ğ‘‘ğ‘¥),0âˆ‰
Î“(ğ‘‘ğ‘¦)), it avoids generating spurious reports at Lines 25-26.
In summary, our analysis encodes the possible values for the
variables in the program path-sensitively using a symbolic domain.
Duringthenumerical inferenceprocess,itattemptsto(1) directly
find the source evidence and (2) propagate the generated bound
evidencetorefinetheanalysisresult.Sinceweapplystandardmeth-
odsintrackingthesourceevidence,wemainlyfocusonutilizing
theboundevidenceinourmethod.Therearetwomajorchallenges:
â€¢How to efficiently compute the guarded symbolic value set
Î“(ğ‘£)forvariable ğ‘£?Anaiveapproachthatexhaustivelyenu-
merates all execution paths can be too expensive, wasting
time exploring irrelevant paths.
â€¢How to propagate bound evidence to refine the symbolic
analysis result?
To address the first challenge, we utilize the data dependence
analysis to slice away the irrelevant control flow paths for improv-
ing theefficiency. Forthe secondchallenge, weencode thebound
evidence as the additional constraints for Î“and enforce these con-
straints when computing the guarded symbolic value sets.Program P ::=fun+
Function fun ::=fun :(ğ‘£1,...,ğ‘£ ğ‘›)â†’ğ‘Ÿ
{ğ‘ }
Statement s ::=ğ‘ 1;ğ‘ 2|ğ‘£:=ğ‘’
|if(ğ‘£1ğ‘ğ‘šğ‘ğ‘£2)ğ‘ 2elseğ‘ 3,cmpâˆˆ{ â‰¤,=}
|ğ‘£:=ğ‘”(ğ‘1,...,ğ‘ ğ‘›)|ğ‘£:=ğœ™(ğ‘£1,...,ğ‘£ ğ‘›)
Expression e ::=ğ‘£|ğ‘|ğ‘¡ğ‘ğ‘–ğ‘›ğ‘¡ğ‘’ğ‘‘|ğ‘’1opğ‘’2,opâˆˆ{ +,âˆ’,Ã—,Ã·}
Figure 3: A simple programming language.
step_size@30
dz@24
ğ‘¡1âˆ’ğ‘¡2dy@13 dx@13diff@20 âˆ’1
1+ğ‘¡32Ã—ğ‘‘ğ‘¥
ğ‘¡1ğ‘‘ğ‘¦+ğ‘‘
ğ‘¡2
ğ‘¡3
ğ‘‘ğ‘¥âˆ’ğ‘‘ğ‘¦1ğ‘‘ğ‘¥<ğ‘‘ğ‘¦
ğ‘‘ğ‘¥â‰¥ğ‘‘ğ‘¦
Figure 4: Augmented data dependence graph for Figure 1.
4 METHODOLOGY
4.1 Preliminary Definitions
We formulate our analysis using a simple imperative programming
language defined in Figure 3. The language is assumed in the static
singleassignmentform[ 10]inwhicheachvariablehasaunique
definition,andwedenotetheSSAphifunctionby ğœ™.Weuseğ‘£@ğ‘™to
denoteavariable ğ‘£definedattheprogramlocation ğ‘™.Thelanguage
hasstandardsemantics,andweomitaformaldefinitionforbrevity.
As mentioned in Â§ 3, we utilize data dependence analysis to
compute Î“efficiently. Specifically, the analysis operates over a
sparse representation of the program called the augmented data
dependence graph, defined as follows:
Definition 4.1. Anaugmenteddatadependencegraph Gisadi-
rected graph G=(ğ‘‰,ğ¸,ğ¿ ğ‘‰,ğ¿ğ¸)where:
(1)ğ‘‰=ğ‘‰ğ‘âˆªğ‘‰ğ‘›âˆªğ‘‰ğ‘œâˆªğ‘‰ğ‘¡isthesetofnodes. ğ‘‰ğ‘areconstantvalues,
ğ‘‰ğ‘›are variable definitions,and ğ‘‰ğ‘œare nodes corresponding
toanarithmeticoperation ğ‘£1opğ‘£2,whereğ‘£1,ğ‘£2âˆˆğ‘‰\ğ‘‰ğ‘œ.ğ‘‰ğ‘¡
is the set of tainted input sources.
(2)ğ¸âˆˆğ‘‰Ã—ğ‘‰is the set of edges representing data dependence
relationssuchthat ğ‘’=(ğ‘£1,ğ‘£2)âˆˆğ¸whenğ‘£1isusedtodefine
ğ‘£2.ğ¿ğ¸labels any ğ‘’âˆˆğ¸with a condition ğ‘ğ‘œğ‘›ğ‘‘under which
the value flow can happen.
(3)ğ¿ğ‘‰labelseachnode ğ‘›âˆˆğ‘‰ğ‘›with(ğ‘£@ğ‘™,ğ‘ğ‘œğ‘›ğ‘‘).ğ‘ğ‘œğ‘›ğ‘‘isthecon-
ditionforğ‘£â€™sdefinition(i.e.,forsomeexecutiontoreachLine
ğ‘™).ğ¿ğ‘‰also labelsnodes in ğ‘‰ğ‘œwith itsarithmetic expression
ğ‘£1opğ‘£2and nodes in ğ‘‰ğ‘with its constant ğ‘.
Example 4.1. Figure4shows the augmented data dependence
graphfortheprograminFigure 1.Anarrow ğ‘£1â†’ğ‘£2indicatesthat
ğ‘£1isusedtodefine ğ‘£2(i.e.,(ğ‘£1,ğ‘£2)âˆˆğ¸),andeacharrowislabeled
with a path condition under which the flow of value can happen
(omitted in Figure 4if it isğ‘¡ğ‘Ÿğ‘¢ğ‘’). Notice that arithmetic operations
arealsocompactlyencodedonthegraphbyintroducingtemporary
variablesğ‘¡1,ğ‘¡2,andğ‘¡3torepresentintermediatecomputationresults.
1722
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:32:16 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Yiyuan Guo, Jinguo Zhou, Peisen Yao, Qingkai Shi, and Charles Zhang
Thesparsegraphrepresentationisusedtotrackrelevantdata
and control dependencies of the concerned variable while skipping
irrelevantstatements[ 17].Ithasbeenpreviouslyshowneffective
indetectingnullpointerdereference[ 3,29],useafterfree[ 29],and
memory leak [ 6,30]. We take inspiration from these works to first
utilize data dependence analysis in finding divide-by-zero bugs.
As illustrated in Â§ 3, to achieve precise divide-by-zero detection,
ouranalysisneedstotracknumericalcomputationspath-sensitively
andutilizeaffirmativeevidencetofindhighconfidencebugs.For
trackingnumericalcomputations,weapplyasymbolicdomain Î“,
formally defined as follows:
Definition 4.2. The guarded symbolic value set domain is a map-
ping Î“âˆˆğ‘‰â†’P(ğ‘‰ğ‘ğ‘™Ã—ğ¶ğ‘œğ‘›ğ‘‘), where:
ğ‘‰ğ‘ğ‘™def={ğ‘,Ë†ğ‘£|ğ‘âˆˆZ,ğ‘£âˆˆğ‘‰}âˆª{ğ‘£ğ‘1ğ‘œğ‘ğ‘£ğ‘2|ğ‘£ğ‘1,ğ‘£ğ‘2âˆˆğ‘‰ğ‘ğ‘™}
ğ¶ğ‘œğ‘›ğ‘‘def=the set of path conditions
We useË†ğ‘£to denote an unknown symbolic value for a node ğ‘£.
Î“encodesthesymbolicvaluesforvariablespath-sensitively.It
maps a node ğ‘£âˆˆGto guarded value pairs of the form (ğ‘£ğ‘,ğ‘),
whereğ‘£ğ‘âˆˆğ‘‰ğ‘ğ‘™is a symbolic expression and ğ‘is the condition
under which ğ‘£may have the value ğ‘£ğ‘. The symbolic expression
inğ‘‰ğ‘ğ‘™is either a basic term (i.e., constant or unknown symbolic
value) or a binary operation involving other symbolic expressions.
At a high level, our analysis first constructs the augmented data
dependence graph Gutilizing the existing method [ 29]. We then
compute the guarded symbolic value set Î“(ğ‘£)for a divisor variable
ğ‘£on-demand.Finally,weusetheresult Î“(ğ‘£)indetectingdivide-by-
zerobugs.Specifically,wecompute Î“(ğ‘£)bybuildingandresolvinga
systemofconstraintsfor Î“.Toimprovetheprecision,ouranalysisis
path-sensitiveandevidenceaware,encodingboundevidenceasad-
ditionalconstraints.Toremainefficient,weutilizedatadependence
relations in constructing and resolving constraints.
4.2 Evidence-based Symbolic Analysis
Givenaprogram ğ‘ƒandavariable ğ‘£,ourevidence-basedsymbolic
analysis shown in Algorithm 1computes the guarded symbolic
value set for ğ‘£. We build the augmented data dependence graph
Gforğ‘ƒusing standard methods (Line 2), generate a system of
constraints ğ¶ğ‘œğ‘›ğ‘ (Î“)on-demand (Line 4), and solve the constraints
to obtain the guarded symbolic value set for ğ‘£(Lines 5-6).
Â§4.2.1demonstratestheprocessofon-demandconstraintsgener-
ation for a node ğ‘›âˆˆG, which is the node corresponding to a given
variableğ‘£. We also generate bound evidence to produce additional
constraints, further refining the result and improving the preci-
sion. Â§4.2.2discusses the procedure ğ‘ ğ‘œğ‘™ğ‘£ğ‘’for resolving constraints
andobtainingthesolution Î“,whichmapsfromvariablestotheir
guarded symbolic value sets.
4.2.1 Symbolic Constraints Generation. Our analysis generates
constraints for Î“from the programâ€™s augmented data dependence
graphG. Before presenting the rules for constraint generation, we
first define some operators for Î“(cf. Definition 4.2):
Definition 4.3. Operators and helper functions definitions for Î“:Algorithm 1: Demand-driven evidence-based symbolic
analysis.
Input:A program ğ‘ƒand a cared variable ğ‘£.
Output:The guarded symbolic value set for ğ‘£.
1defsymbolicAnalysis( ğ‘ƒ,ğ‘£):
2G(ğ‘‰,ğ¸)â†buildGraph (ğ‘ƒ)
3ğ‘›â†node inGcorresponding to ğ‘£
4ğ¶ğ‘œğ‘›ğ‘ (Î“)â†genConstraints (G,ğ‘›)
5 Î“â†solve(ğ¶ğ‘œğ‘›ğ‘ (Î“))
6return Î“(ğ‘›)
7defgenConstraints( G,ğ‘›):
8ğ¶ğ‘œğ‘›ğ‘ (Î“)â†âˆ…
9ğ‘†ğ‘’ğ‘={ğ‘£ğ‘–}â†backward dfs order of Gstarting from ğ‘›
10foreachğ‘£âˆˆğ‘…ğ‘’ğ‘£ğ‘’ğ‘Ÿğ‘ ğ‘’(ğ‘†ğ‘’ğ‘)do
11 Apply the rules in Figure 5and add the generated
constraints to ğ¶ğ‘œğ‘›ğ‘ (Î“)
12end
13returnğ¶ğ‘œğ‘›ğ‘ (Î“)
14defsolve(ğ¶ğ‘œğ‘›ğ‘ (Î“)):
15 Î“â†ğœ†ğ‘£.âˆ…
16while Î“has changed do
17 foreach(ğ¶:Î“(ğ‘œ)â†â†ªğ‘†)âˆˆğ¶ğ‘œğ‘›ğ‘ (Î“)do
18 ğ‘†/primeâ†Î“(ğ‘œ)/dotaccâˆªeval(ğ‘†,Î“)
19 Î“â†Î“[ğ‘œâ†¦â†’ğ‘†/prime]
20 end
21end
22return Î“
(1)The binary operator /tildewideroponP(ğ‘‰ğ‘ğ‘™Ã—ğ¶ğ‘œğ‘›ğ‘‘)is defined as:
ğºğ‘‰1/tildewideropğºğ‘‰2={simplify(ğ‘£ğ‘1opğ‘£ğ‘2),ğ‘1âˆ§ğ‘2)|(ğ‘£ğ‘1,ğ‘1)âˆˆ
ğºğ‘‰1,(ğ‘£ğ‘2,ğ‘2)âˆˆğºğ‘‰2}
(2)Thelogicalandoperation âˆ§isextendedtoaddanadditional
conditiontoaguardedvalueset ğ‘†âˆˆP(ğ‘‰ğ‘ğ‘™Ã—ğ¶ğ‘œğ‘›ğ‘‘):ğ‘ğ‘œğ‘›ğ‘‘âˆ§
ğ‘†={(ğ‘£ğ‘,ğ‘âˆ§ğ‘ğ‘œğ‘›ğ‘‘)| (ğ‘£ğ‘,ğ‘)âˆˆğ‘†}.
(3)/dotaccâˆªunionstwoguardedvaluesets ğ‘†1,ğ‘†2âˆˆP(ğ‘‰ğ‘ğ‘™Ã—ğ¶ğ‘œğ‘›ğ‘‘)and
combinesguardingconditionsforthesamevalue: ğ‘†1/dotaccâˆªğ‘†2=
{(ğ‘£ğ‘,ğ‘1âˆ§ğ‘2)|(ğ‘£ğ‘,ğ‘1)âˆˆğ‘†1,(ğ‘£ğ‘,ğ‘2)âˆˆğ‘†2}âˆª(ğ‘†1\ğ‘†2)âˆª(ğ‘†2\ğ‘†1).
Figure5liststheinferencerulesforgeneratingconstraintsfor
Î“based on G.W eu s eğ‘†1â†â†ªğ‘†2to denote a weak update to the
guarded value set ğ‘†1(i.e.,ğ‘†1=ğ‘†1/dotaccâˆªğ‘†2), andğ‘ğ‘œğ‘›ğ‘‘âˆ’âˆ’âˆ’âˆ’â†’to denote data
dependenceedges(c.f.Definition 4.1).ThefirstfiverulesinFigure 5
translate the data dependence relations in Gto constraints for Î“.
Ruleinit-varand Rule init-opindicate that every node ğ‘›âˆˆğ‘‰ğ‘›âˆªğ‘‰ğ‘œ
is associated with an unknown symbolic value Ë†ğ‘›, meaning that the
valueforğ‘›isinitiallyunknown.Ontheotherhand,constantnodes
have fixed values (Rule init-cst). For node encoding operations, the
operator /tildewideropis applied to the guarded symbolic value sets for the
incomingnodes(Rule operation)1.Foravariablenode ğ‘›âˆˆğ‘‰ğ‘›,w e
aggregatetheguardedsymbolicvaluesetsforallthenodesthat ğ‘›is
datadependenton,andtracktheappropriatepathconditions(Rule
1For brevity, the rule only lists the case when both operand nodes are from ğ‘‰ğ‘›. Other
cases can be transformed to it by introducing temporary variables.
1723
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:32:16 UTC from IEEE Xplore.  Restrictions apply. Precise Divide-By-Zero Detection with Affirmative Evidence ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
init-varğ‘›âˆˆğ‘‰ğ‘›,ğ¿ğ‘‰(ğ‘›)=(ğ‘£,ğ‘ğ‘œğ‘›ğ‘‘)
Î“(ğ‘›)â†â†ª{(Ë†ğ‘›,ğ‘ğ‘œğ‘›ğ‘‘)}
init-opğ‘›âˆˆğ‘‰ğ‘œ
Î“(ğ‘›)â†â†ª{(Ë†ğ‘›,ğ‘¡ğ‘Ÿğ‘¢ğ‘’)}
init-cstğ‘›âˆˆğ‘‰ğ‘,ğ¿ğ‘‰(ğ‘›)=ğ‘ğ‘ ğ‘¡
Î“(ğ‘›)â†â†ª{(ğ‘ğ‘ ğ‘¡,ğ‘¡ğ‘Ÿğ‘¢ğ‘’)}
operationğ‘›âˆˆğ‘‰ğ‘œ,ğ¿ğ‘‰(ğ‘›)=ğ‘£1opğ‘£2
ğ‘œğ‘1â†’ğ‘›,ğ¿ğ‘‰(ğ‘œğ‘1)=(ğ‘£1,ğ‘1)
ğ‘œğ‘2â†’ğ‘›,ğ¿ğ‘‰(ğ‘œğ‘2)=(ğ‘£2,ğ‘2)
Î“(ğ‘›)â†â†ªÎ“(ğ‘œğ‘1)/tildewideropÎ“(ğ‘œğ‘2)
variableğ‘œğ‘1ğ‘ğ‘œğ‘›ğ‘‘1âˆ’âˆ’âˆ’âˆ’âˆ’â†’ğ‘›,...,ğ‘œğ‘ ğ‘˜ğ‘ğ‘œğ‘›ğ‘‘ ğ‘˜âˆ’âˆ’âˆ’âˆ’âˆ’â†’ğ‘›
ğ‘›âˆˆğ‘‰ğ‘›,ğ¿ğ‘‰(ğ‘›)=(ğ‘£@ğ‘™,ğ‘ğ‘œğ‘›ğ‘‘)
ğ‘£ğ‘ğ‘ =ğ‘¡ğ‘Ÿğ‘ğ‘›ğ‘ ([(Î“(ğ‘œğ‘1),ğ‘ğ‘œğ‘›ğ‘‘1),...,(Î“(ğ‘œğ‘ğ‘˜),ğ‘ğ‘œğ‘›ğ‘‘ ğ‘˜)])
Î“(ğ‘›)â†â†ªğ‘ğ‘œğ‘›ğ‘‘âˆ§ğ‘£ğ‘ğ‘ 
bound-eviğ‘£1ğ‘ğ‘šğ‘ğ‘£2occurs in the program
Î“(ğ‘£ğ‘–)â†â†ªÎ“(ğ‘£1)/dotaccâˆªÎ“(ğ‘£2),ğ‘–âˆˆ{1,2}
Figure 5: Rules for generating constraints from G.ğ‘†1â†â†ªğ‘†2
abbreviates ğ‘†1=ğ‘†1/dotaccâˆªğ‘†2, andğ‘–ğ‘ğ‘œğ‘›ğ‘‘âˆ’âˆ’âˆ’âˆ’â†’ğ‘—abbreviates ğ‘’=(ğ‘–,ğ‘—)âˆˆ
ğ¸,ğ¿ğ¸(ğ‘’)=ğ‘ğ‘œğ‘›ğ‘‘.
variable). Theğ‘¡ğ‘Ÿğ‘ğ‘›ğ‘ function is used for this reason and defined as:
ğ‘¡ğ‘Ÿğ‘ğ‘›ğ‘ ([(Î“(ğ‘œğ‘1),ğ‘1),...,(Î“(ğ‘œğ‘ğ‘˜),ğ‘ğ‘˜)])def=/dotacc/uniondisplay.1ğ‘˜
ğ‘–=1(ğ‘ğ‘–âˆ§Î“(ğ‘œğ‘ğ‘–))
Finally, the condition associated with ğ‘›inğ¿ğ‘‰(ğ‘›)is added to Î“(ğ‘›).
Example 4.2. ForGshown in Figure 4, we can apply the above
inferencerulestobuildthefollowingconstraints(theconstraints
for temporary variables are left out for brevity):
Î“(step_size)â† â†ªÎ“(diff)/dotaccâˆªÎ“(dx)/dotaccâˆªÎ“(dy)/dotaccâˆªÎ“(dz) (1)
Î“(diff)â†â†ªğ‘¡ğ‘Ÿğ‘ğ‘›ğ‘ ([(Î“(âˆ’1),dx<dy), (2)
(Î“(1)/tildewide+(Î“(dx)/tildewideâˆ’Î“(dy)),dxâ‰¥dy)])(3)
Î“(dz)â†â†ªÎ“(2)/tildewideÃ—Î“(dx)/tildewideâˆ’(Î“(dy)/tildewide+Î“(d)) (4)
Î“(ğ‘£)â†â†ª{(Ë†ğ‘£,ğ‘¡ğ‘Ÿğ‘¢ğ‘’)},ğ‘£âˆˆ{step_size,dx,dz,diff,dy,d}(5)
Sincewe buildthe constraintsfrom theaugmented datadepen-
dencegraphshowninFigure 4,onlyrelevantpathconditionsareen-
codedintheconstraintrepresentation.Forinstance,nobranchcon-
ditioninFigure 1canaffectthevalueof dz,i.e.,dz=2Ã—dxâˆ’(dy+d)
holdsonalleightexecutionpaths.Theaboveconstraint(4)effec-
tivelycapturesthisfact,indicatingthat Î“(dz)isdependenton Î“(dx),
Î“(dy), and Î“(d)without distinguishing among different execution
paths, which are irrelevant in this case.
GeneratingBoundEvidence .Althoughwehaveshownhow
to generate constraints for Î“according to the data dependence
relationson G, thepresenceof under-constrainedvariables inthe
analysis can still lead to imprecision, as illustrated in Â§ 1. The
key challenge is to infer additional information for these under-
constrained variables when solely relying on the data dependence
relations gives imprecise results.As motivated in Â§ 1, a bound checking statement if(ğ‘£1ğ‘ğ‘šğ‘ ğ‘£2)
reveals programmerâ€™sbeliefs about the valuesof the checkedvari-
ables: acomparison between ğ‘£1andğ‘£2suggests thatthe program-
mermaybelievethat ğ‘£1=ğ‘£2,whichwecalla boundevidence.Bound
evidence can aid in providing additional information for the under-constrained variables, e.g., it is used to infer 0
âˆˆÎ“(dz)as discussed
in Â§3. Therefore, we propose to generate additional constraints on
Î“forboundevidence.Specifically,Rule bound-evi ofFigure 5will
unifytheguardedsymbolicvaluesetsforthecomparedvariables
ğ‘£1andğ‘£2toÎ“(ğ‘£1)/dotaccâˆªÎ“(ğ‘£2).Theseadditionalevidenceconstraints,
together with the data dependence constraints generated before
willberesolvedlatertopropagateevidenceaccordingtothedata
dependence relations.
Example 4.3. In our motivating example of Figure 1, the two
bound checking statements at Line 15 and Line 21 will cause the
analysis to generate bound evidence. Applying Rule bound-evi,w e
obtain the additional constraints:
Î“(dx),Î“(dy)â†â†ªÎ“(dx)/dotaccâˆªÎ“(dy) (6)
Î“(dx),Î“(d)â†â†ªÎ“(dx)/dotaccâˆªÎ“(d) (7)
Î“(dy),Î“(d)â†â†ªÎ“(dy)/dotaccâˆªÎ“(d) (8)
Weknowfromtheaboveconstraintsthatthesymbolicvaluesfor dx,
dy, anddare unified. As we will see later, this information refines
theconstraintsgeneratedinExample 4.2andhelpsustoinferthe
evidence for dzto be zero.
On-demandConstraintsGeneration .InAlgorithm 1,thepro-
cedureğ‘”ğ‘’ğ‘›ğ¶ğ‘œğ‘›ğ‘ ğ‘¡ğ‘Ÿğ‘ğ‘–ğ‘›ğ‘¡ğ‘  generatesasystemofconstraints ğ¶ğ‘œğ‘›ğ‘ (Î“)
on-demand from Gand a given node ğ‘›. Specifically, we perform a
backwarddepth-firsttraversalon Gstartingfrom ğ‘›(Line9).This
effectivelycomputesasliceof Gaffectingthevalueof ğ‘›.Following
the reverse node order of this DFS traversal, we collect constraints
using the rules in Figure 5(Lines 10-12) and finally return these
constraints at Line 13. The order ensures that the rules for ğ‘£1come
beforeğ‘£2ifğ‘£1is used to define ğ‘£2â€™s value, thus speeding up the
convergence ofthe solving processintroduced later, similarto data
flow analysis [2].
4.2.2 Constraint Resolution. Given a set of constraints ğ¶ğ‘œğ‘›ğ‘ (Î“),
the procedure ğ‘ ğ‘œğ‘™ğ‘£ğ‘’in Algorithm 1computes its solution, which
is a mapping Î“from nodes to guarded symbolic value sets. At a
high level, Î“starts with an initial state mapping any node to the
empty set (Line 15) and is iteratively updated according to the
constraints ğ¶ğ‘œğ‘›ğ‘ (Î“).Noticethateachconstraintin ğ¶ğ‘œğ‘›ğ‘ (Î“)isbuilt
fromtherulesinFigure 5and,thus,hasthesyntacticform Î“(ğ‘œ)â†â†ª
ğ‘†. For updating Î“(ğ‘œ), we calculate the result of the set operation
encoded by ğ‘†, denoted by ğ‘’ğ‘£ğ‘ğ‘™(ğ‘†,Î“)at Line 18. The calculation
result is combined with the old value Î“(ğ‘œ)using the /dotaccâˆªoperator
(c.f. Definition 4.3) to produce the updated value set ğ‘†/primeforğ‘œ(Lines
18-19), since â†â†ªrepresents a weak update. The algorithm finishes
when no constraint causes an update to Î“anymore (Lines 16-21).
Example 4.4. For the constraints (4)-(5) shown in Example 4.2,
Lines 18-19 of the ğ‘ ğ‘œğ‘™ğ‘£ğ‘’procedure compute the guarded symbolic
1724
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:32:16 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Yiyuan Guo, Jinguo Zhou, Peisen Yao, Qingkai Shi, and Charles Zhang
value set for dzas follows:
Î“(dz)={(Ë†dz,ğ‘¡ğ‘Ÿğ‘¢ğ‘’)}/dotaccâˆª
{(2,ğ‘¡ğ‘Ÿğ‘¢ğ‘’)}/tildewideÃ—{(Ë†dx,ğ‘¡ğ‘Ÿğ‘¢ğ‘’)}/tildewideâˆ’({(Ë†dy,ğ‘¡ğ‘Ÿğ‘¢ğ‘’)}/tildewide+{(Ë†d,ğ‘¡ğ‘Ÿğ‘¢ğ‘’)})
={(2Ã—Ë†dxâˆ’(Ë†dy+Ë†d),ğ‘¡ğ‘Ÿğ‘¢ğ‘’),(Ë†dz,ğ‘¡ğ‘Ÿğ‘¢ğ‘’)}
Constraints (6)-(8) from Example 4.3further refines the result to:
Î“(dz)={(2Ã—Ë†ğ‘âˆ’(Ë†ğ‘+Ë†ğ‘),ğ‘¡ğ‘Ÿğ‘¢ğ‘’),(Ë†dz,ğ‘¡ğ‘Ÿğ‘¢ğ‘’)|ğ‘,ğ‘,ğ‘âˆˆ{dx,dy,d}}
Since(0,ğ‘¡ğ‘Ÿğ‘¢ğ‘’)âˆˆÎ“(dz),wehavefoundtheevidenceforthevariable
dzto trigger divide-by-zero.
Theaboveexampleshowstheadvantageofgeneratingandre-
solving constraints from Gaccording to the data dependence rela-
tions.Ourconstraintsarecompact,i.e.,resolvingtheconstraints
does not require reasoning about the irrelevant control flow paths.
In contrast, an exhaustive approach such as symbolic execution
needstoenumeratealleightpathsinthefunction moveofFigure 1,
just to figure out the guarded symbolic value set for dz:
Path dz
ğ‘1=ğ‘‘ğ‘¥â‰¥ğ‘‘ğ‘¦âˆ§ğ‘‘ğ‘¥â‰¥ğ‘‘âˆ§ğ‘‘ğ‘¦â‰¥ğ‘‘2Ã—ğ‘‘ğ‘¥âˆ’(ğ‘‘ğ‘¦+ğ‘‘)
Â·Â·Â· Â·Â·Â·
ğ‘8=ğ‘‘ğ‘¥<ğ‘‘ğ‘¦âˆ§ğ‘‘ğ‘¥<ğ‘‘âˆ§ğ‘‘ğ‘¦<ğ‘‘2Ã—ğ‘‘ğ‘¥âˆ’(ğ‘‘ğ‘¦+ğ‘‘)
Theconstraintsbuiltbytheexhaustivepathenumerationwould
have been overly redundant:
Î“(dz)â†â†ªğ‘¡ğ‘Ÿğ‘ğ‘›ğ‘ ([(Î“(2)/tildewideÃ—Î“(dx)/tildewideâˆ’(Î“(dy)/tildewide+Î“(d)),ğ‘1)])
Â·Â·Â·
Î“(dz)â†â†ªğ‘¡ğ‘Ÿğ‘ğ‘›ğ‘ ([(Î“(2)/tildewideÃ—Î“(dx)/tildewideâˆ’(Î“(dy)/tildewide+Î“(d)),ğ‘8)])
Sinceğ‘1âˆ¨Â·Â·Â·âˆ¨ğ‘8â‰¡ğ‘¡ğ‘Ÿğ‘¢ğ‘’,theaboveconstraintsareequivalentto
our generated constraint (4) in Example 4.2.
Onenoteworthypointaboutthe ğ‘ ğ‘œğ‘™ğ‘£ğ‘’procedureisthatitcanpro-
duce a value set ğ‘†/primewith a large size. To keep the analysis tractable,
we join the additional values for variable ğ‘£to its sound abstraction
Ë†ğ‘£when the size of Î“(ğ‘£)has reached a predefined threshold. In this
work, we choose the threshold to be 20 by experience.
4.3 Divide-by-Zero Bug Detection
Our system, Wit, for precise divide-by-zero detection is shown
inAlgorithm 2.Specifically,givenaprogram ğ‘ƒ,adivisorvariable
ğ‘£, and the location ğ‘™of the division instruction, Algorithm 2re-
turnswhethera divide-by-zerobugmayhappen at ğ‘™.Wefirstcall
ğ‘ ğ‘¦ğ‘šğ‘ğ‘œğ‘™ğ‘–ğ‘ğ´ğ‘›ğ‘ğ‘™ğ‘¦ğ‘ ğ‘–ğ‘  ofAlgorithm 1usingğ‘ƒandğ‘£asargumentstoob-
tain the guarded symbolic value set ğ‘†forğ‘£(Line 2). Divide-by-zero
detectionisachievedbyenumeratingeachguardedvalue (ğ‘£ğ‘,ğ‘ğ‘œğ‘›ğ‘‘)
inğ‘†to check for the bug condition.
To report a divide-by-zero bug, we adhere to the criteria C1* -
C2* mentioned in Â§ 1. First, according to C1*, the conjunction of
the path condition and the error condition should be satisfiable.
In Algorithm 2, the path condition is denoted by ğ‘ğ‘, consisting
of the condition ğ¶for reaching the division instruction and the
guarding condition ğ‘ğ‘œğ‘›ğ‘‘for the checked value ğ‘£ğ‘(Line 5). The
error condition is simply ğ‘£ğ‘=0. Therefore, Line 6 checks the
satisfiability of ğ‘ğ‘âˆ§ğ‘£ğ‘=0 for determining C1*. Second, according
toC2*,theconcernedsymbolicvalue ğ‘£ğ‘shouldhavetheaffirmative
evidence to be zero:Algorithm 2: Divide-by-zero bug detection by Wit.
Input:A program ğ‘ƒ.
Input:A divisor variable ğ‘£and the location ğ‘™for the
division instruction.
Output:Whether divide-by-zero may happen at ğ‘™
1defdecideBug(P, ğ‘£,ğ‘™):
2ğ‘†â†symbolicAnalysis (ğ‘ƒ,ğ‘£)
3ğ¶â†path condition for reaching ğ‘™
4foreach(ğ‘£ğ‘,ğ‘ğ‘œğ‘›ğ‘‘)âˆˆğ‘†do
5ğ‘ğ‘â†ğ¶âˆ§ğ‘ğ‘œğ‘›ğ‘‘
6 ifğ‘†ğ´ğ‘‡(ğ‘ğ‘âˆ§ğ‘£ğ‘=0)then
7 ifğ‘¡ğ‘ğ‘–ğ‘›ğ‘¡ğ‘’ğ‘‘(ğ‘£ğ‘)then
8 returnğ‘¡ğ‘Ÿğ‘¢ğ‘’
9 else ifğ‘ˆğ‘ğ‘†ğ´ğ‘‡(ğ‘ğ‘âˆ§ğ‘£ğ‘â‰ 0)then
10 returnğ‘¡ğ‘Ÿğ‘¢ğ‘’
11end
12returnğ‘“ğ‘ğ‘™ğ‘ ğ‘’
taint-eviğ‘£âˆˆğ‘‰ğ‘¡,ğ‘£ğ‘ğ‘œğ‘›ğ‘‘âˆ’âˆ’âˆ’âˆ’â†’âˆ—ğ‘£/prime,ğ‘†ğ´ğ‘‡(ğ‘ğ‘œğ‘›ğ‘‘)
ğ‘¡ğ‘ğ‘–ğ‘›ğ‘¡ğ‘’ğ‘‘(ğ‘£/prime)=ğ‘¡ğ‘Ÿğ‘¢ğ‘’
Figure 6: Criteria for propagating the tainted flag.
â€¢Source evidence :Ifğ‘£ğ‘comesfromthetaintedinput,wecan
reportadivide-by-zerobug(Lines7-8).Fortaintdetection,
we can apply any existing taint analysis to compute the
tainted nodes on G. Specifically, we use Rule taint-evi in
Figure6: a node is tainted if it is data dependent on the
taintedinputandtheconditionofthevalueflowissatisfiable.
â€¢Bound evidence :Otherwise,wereportadivide-by-zerobug
ifğ‘£ğ‘must be zero under the condition ğ‘ğ‘(Lines 9-10). This
can happen for two reasons: either the symbolic value ğ‘£ğ‘
is literally constant zero, or it is forced to be zero by thecondition
ğ‘ğ‘(e.g., when ğ‘ğ‘=âˆ’1<ğ‘£ğ‘<1). Recall that
theboundevidenceisencodedasadditionalconstraintsin
ğ¶ğ‘œğ‘›ğ‘ (Î“)duringtheanalysisandcanimplicitlyenforce ğ‘£ğ‘to
be zero, it is thus more likely to satisfy the must query.
FortheprograminFigure 1,Algorithm 1deducesthat (0,ğ‘¡ğ‘Ÿğ‘¢ğ‘’)âˆˆ
Î“(dz)asillustratedbyExample 4.4.Thus,Lines9-10ofAlgorithm 2
report a divide-by-zero bug for the variable dz.
5 EVALUATION
WeimplementWitbasedonLLVM[ 20].Similartopreviousworks
onstatic bugdetection[ 3,29,30,32],we unrolleachloop oncein
controlflowgraphsandcallgraphs.Ourexperimentalevaluation
is designed to answer the following research questions:
â€¢RQ3: The effectiveness of Wit. Particularly,
â€“ RQ3.1: How does our intuition of evidence-based reason-
ing affect the analysis precision?
â€“ RQ3.2: Compared to the conventional evidence agnostic
method, how many bugs are missed by Wit? What are
the reasons for missing them?
â€“ RQ3.3: Can Wit detect real-world divide-by-zero bugs?
1725
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:32:16 UTC from IEEE Xplore.  Restrictions apply. Precise Divide-By-Zero Detection with Affirmative Evidence ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
Table 2: Selected projects for evaluation.
Project Loc #Div/KLoC
masscan 34k 5.4
goaccess 53k 1.1
libuv 59k 0.8redis 131k 5.0git 226k 4.5
vim 354k 1.8
ImageMagick 382k 6.6openssl 465k 4.1systemd 600k 5.0php 1,012k 1.3
gdb 1,932k 1.6
Linux kernel 15,164k 2.1
â€¢RQ4:HowdoesWitperformcomparedwithexistingdivide-
by-zero detectors?
5.1 Experimental Setup
Subjects. We have selected 12 open source C/C++ projects to
performtheevaluation,showninTable 2.Ourselectioncriteriaare
as follows:
â€¢Popularity:Theselectedprojectsarepopular(e.g.,haveat
least 10K stars on GitHub) and actively maintained.
â€¢Generality: The projects cover different sizes (ranging from
tens of thousands to tens of millions of lines of code) and
functionalities (including operating system, image process-
ing, database system, network library, etc.)
â€¢Intensiveuseofdivisioninstruction:Theprojectsperform
division operation intensively, e.g., they contain 3.3 division
instructions every 1k lines of code on average.
Environment . The experiments were performed on a com-
puterwithtwo20coreprocessorsIntel(R)Xeon(R)CPUE5-2698
v4@2.20GHz and 256GB physical memory running Ubuntu-16.04.
Open Data . The results of our empirical study and confirmed
bugs detected by Wit are available at the link: https://github.com/
yiyuaner/ICSE-2022-Wit-data.
5.2 Effectiveness of Divide-by-Zero Detection
To study the effectiveness of the evidence-based symbolic analysis
algorithm, we compare Wit with its variant Witâˆ’.Witâˆ’is the
evidenceagnosticpath-sensitivemethod.In Witâˆ’,weremoveRule
bound-evi fromFigure 5andreportanerrorwheneverthecondition
issatisfiable,i.e.,wheneverthecheckatLine6ofAlgorithm 2passes.
All other aspects of Witâˆ’are the same as Wit.
Table3showstheexperimentresult.Wecomparethetotalnum-
ber of bug reports, the false positive rate, and the analysis time for
Wit and Witâˆ’. For each variant on a specific project, we examine
its list of output reports and stop if the number of false positiveshas exceeded 200 (when this happens, we use â€œNAâ€ to denote its
false positive rate). Wit effectively reports 95 divide-by-zero bugs
(72 of them are true positives) among 12 real-world applications,Table 3: Divide-by-zero detection on real-world projects.
Witâˆ’represents a variant of Wit unaware of evidence.
Project# of reports FP rate Analysis time
Wit Witâˆ’Wit Witâˆ’Wit Witâˆ’
masscan 3 10 30% 80% 4m24s 6mgoaccess 2 15 0 80% 1m38s 1m33slibuv 1 3 0 67% 1m32s 1m29sredis 1 20 0 95% 23m12s 23m9sgit 10 29 40% 79% 38m3s 34m34s
vim 4 32 25% 88% 109m55s 109m12s
ImageMagick 5 47 20% 89% 196m39s 189m10sopenssl 2 18 0 89% 31m55s 31m48ssystemd 5 20 60% 90% 202m8s 183m21sphp 4 17 50% 88% 104m38s 94m21s
gdb 5 213 20% 96% 248m28s 299m1s
Linux kernel 53 2839 19% NA 425m35s 452m12s
Table 4: Distribution of true positives reported by Wit (the
column â€œTotalâ€) into Class Src and Class Bd. The column
â€œMissedâ€ shows the number of true positives reported by
Witâˆ’but missed by Wit.
Project Total Src Bd Missed
masscan 2 2 0 0goaccess 2 2 0 1libuv 1 0 1 0redis 1 1 0 0git 6 4 2 0
vim 3 1 2 1
ImageMagick 4 3 2 1openssl 2 1 1 0systemd 2 1 1 0php 2 0 2 0
gdb 4 3 1 4
Linux kernel 43 36 10 NA
Table 5: Divide-by-zero bugs confirmed by developers.
gitLinux gdbImageMagickgoaccess libuv openssl vim systemd
141 2 2 1 1 1 1
withalowaveragefalsepositiverateof22%.Incontrast, Witâˆ’has
an average false positive rate of 86%.
Answer to RQ3.1: The precision of Wit greatly outperforms
its no-evidence counterpart, proving the significance of affir-
mative evidence for precise divide-by-zero detection.
Table4shows the distribution of true positives reported by Wit
and thenumber oftrue positives detectedby Witâˆ’but missedby
Wit.Fromthetable,weconcludethatbothsourceandboundevi-
denceareusefulinpreciselydetectingdivide-by-zerobugs.Besides,
Wit misses 12% of the true positives detected by Witâˆ’on average,
1726
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:32:16 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Yiyuan Guo, Jinguo Zhou, Peisen Yao, Qingkai Shi, and Charles Zhang
1intblk_mq_map_queues(blk_mq_queue_map âˆ—qmap) {
2unsigned âˆ—map = qmapâˆ’>mq_map;
3unsigned nr_queues = qmapâˆ’>nr_queues;
4unsigned cpu, first_sibling;
5unsigned q=0 ;
6for_each_possible_cpu(cpu) {
7if(q < nr_queues) {
8 map[cpu] = queue_index(qmap, nr_queues, q++);
9}else{
10 if(first_sibling == cpu)
11 map[cpu] = queue_index(qmap, nr_queues, q++);
12 ...
13 }
14}
15}
16intqueue_index(blk_mq_queue_map âˆ—qmap,
17 unsigned nr_queues, const int q)
18{
19returnqmapâˆ’>queue_offset + (q % nr_queues);
20}
Figure 7: A confirmed divide-by-zero bug in Linux kernel.
which isrelatively low consideringits drastic precisionimprove-
ment. Most of the missed bugs are due to the incomplete modeling
ofthetaintsources,i.e.,theanalysisfailstoidentifycertainAPIs
as the taint sources, thus missing the source evidence and fails
toreportcertain bugs.Witcurrentlymodelssome commontaint
sourcesfromthestandardClibrarybuteachtargetprogrammay
contain its specific taint sources that we do not know beforehand.
AnswertoRQ3.2:Witonlymissesasmallproportionofbugs
compared with its no-evidence counterpart Witâˆ’, mainly
due to its incomplete modeling of the taint sources.
We report the detected true positives and 14 bugs have been
confirmedbythedevelopers,asshowninTable 5.Figure7showsa
realdivide-by-zerobugWitdiscoveredfromtheLinuxkernel.The
function queue_index uses nr_queues asadivisor,whichcomes
from the unknown input argument qmap->nr_queues . Since the
analysisgeneratesaboundevidence q=nr_queues fromLine7of
Figure7and qis assigned zero value in Line 5, it deduces that
nr_queues may be zero and reports a divide-by-zero bug.
Answer to RQ3.3: Wit is capable of detecting real divide-by-
zerobugs:ithasfound72divide-by-zerobugs,14ofwhich
have been confirmed by the developers.
5.3 Comparison with Existing Detectors
We compare Wit with three competing tools, namely Crab [ 18],
Infer [5], and Clang Static Analyzer (CSA). Crab adopts numeri-
cal abstract interpretation, Infer takes the bi-abduction theorem
proving technique, and CSA performs local symbolic execution.
Comparingwith Crab . We instrument the program by assert-
ingthedivisorvariabletobenon-zeroanduseCrabtoverifythe
inserted assertions with the interval domain [ 8]2. When Crab fails
to verify the safety of a division instruction, it emits a warning
as apotential divide-by-zero bug.We cannot directly evaluatethe
2Wehavetriedmoreexpressivedomains.Thezonedomain[ 26]failson6ofthe12
projectsdue totimeoutor memoryoutina 12hoursexperiment,while theoctagon
domain [25] fails on 8 of the 12 projects.Table 6: Analysis results for Crab.
Project #Warnings Warning ratio Time
massscan 74 66% 1m43s
goaccess 9 53% 0m34s
libuv 6 27% 0m15s
redis 542 36% 200m30s
git 128 58% 175m49s
vim 174 42% 111m29s
ImageMagick 102 27% 389m49s
openssl 111 60% 5m26s
systemd 925 43% 68m41s
php 101 13% 141m30s
gdb 165 57% 20m10s
Linux kernel OOM OOM OOM
Table 7: Divide-by-zero detection results for Infer and CSA.
NA denotes the false positive rate when no bug is reported.
Project# of reports FP rate Analysis time
Infer CSA Infer CSA Infer CSA
masscan 0 0 NA NA 1m4s 4m8sgoaccess 1 0 0 NA 3m27s 10m59slibuv 0 0 NA NA 3m13s 4m47sredis 4 1 50% 0 8m47s 15m37sgit 7 0 100% NA 8m55s 15min5s
vim 0 2 NA 50% 24m21s 17m47s
ImageMagick 7 2 71% 100% 16m7s 25m24sopenssl 0 1 NA 0 49m2s 9m43ssystemd 1 0 100% NA 31m21s 11m45sphp 0 2 NA 100% 20m23s 57m28s
gdb 0 6 NA 83% 41m59s 81m17s
Linux kernel Crash 63 Crash 51% Crash 281m4s
precisionofCrabbecauseitcurrentlydoesnotprovideaninterface
to map its verification result to source code location for reports ex-
amination. Instead, we record the number of warnings it generates
and the ratio of its generated warnings over the total number of
checked assertions. Intuitively, a tool reporting warnings too often
(e.g., consider a tool that reports a bug for half of the division in-
structionsintheprogram)maybeunusableintheindustrialsetting
[4,7]. However, it should be noted that this only loosely relates
to the precision and our comparison has the caveat of possibly
underestimating the effectiveness of Crab.
The analysis result for Crab is shown in Table 6. On average,
Crab produces 212 bug reports per project, failing to verify 44%
of thechecked assertions onaverage. Such alarge number ofbug
reportswillimpedetheuserfromadoptingthetoolindivide-by-
zero detection. In contrast, Wit reports 95 divide-by-zero bugs for
the 12 projects in total, with an average false positive rate of 22%.
ComparingwithInferandCSA . Table7shows the results of
Infer and CSA. From the data, we conclude that:
(1)Infer generates zero reports on six projects and fails on one
project,while CSAgenerates zeroreports onfive projects.
Thus,theybothhavemissedmanytruepositivesdetected
1727
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:32:16 UTC from IEEE Xplore.  Restrictions apply. Precise Divide-By-Zero Detection with Affirmative Evidence ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
by Wit. The relatively low recall is due to practical con-
siderations for the tools, such as the limited capability fordetecting cross-file bugs and inherent approximations in
their algorithms.
(2)Overtheprojectswherethenumberofbugreportsisnon-
zero,Inferhasanaveragefalsepositiverateof64%,andCSA
has an average false positive rate of 55%.
(3)WitrunsslowerthanInferandCSAinprojectswithlarge
sizes. This is mainly because we utilize SMT solving to be
fully path-sensitive. However, Wit finishes within 7.5 hours
in all projects, which is an acceptable performance given its
precision improvement.
AnswertoRQ4:comparedwithexistingdivide-by-zerodetec-
tors,Witissignificantlymorepreciseandsometimeseven
detects more divide-by-zero bugs.
6 RELATED WORK
Abstract Interpretation . In abstract interpretation [ 8], many
abstractdomainshavebeendesignedtoverifynumericalproper-
ties, such as the octagon [ 25] and polyhedra domain [ 9]. Recent
workshavetriedtobalancebetweentheprecisionandcostofab-
stract interpretation. Oh et al .[27]utilize an impact pre-analysis
toapplycontext-sensitivityselectively,whileLAIT[ 19]identifies
and removes redundant constraints in numerical analysis to im-prove speed without hurting precision too much. Mansur et al
.
[24]proposetoautomaticallytailortheconfigurationsofabstract
interpretersaccordingtothecodeunderanalysisandresourcecon-straints.Ourworkimprovestheprecisionfromadifferentangleby
finding the affirmative evidence for triggering the bug.
Symbolic Analysis for Numerical Bug Detection . To the
bestofourknowledge,wearethefirsttodesignasymbolicanalysis
algorithmtargetingtheproblemofdivide-by-zerodetection.Pre-
viousworksmainlyfocusonapplyingsymbolicanalysisinstatic
bufferoverflowdetectionandintegeroverflowdetection.Lietal .
[22]adopt a simple symbolic value representation and filter out
irrelevant dependencies during the symbolic value computation.Marple [
21] performs on-demand backward symbolic execution,
startingfromabufferaccessstatementandcategorizingprogram
pathstoprioritizebugreports.SIFT[ 23]utilizespreconditionin-
ferenceincomputingsoundinputfilterstonullifyintegeroverflowerrorsassociatedwithcriticalprogramsitessuchasmemoryalloca-tionorblockcopysites.Theseworksadoptpath-sensitivesymbolicdomainssimilartooursbutdonotdiscusstheimprecisionproblem
brought by the under-constrained variables or how to address it,
which is the key contribution of this work.
Reasoning About Programmerâ€™s Beliefs . Engler et al .[16]
first propose to infer from code about the programmersâ€™ beliefs
and detect potential bugs by spotting inconsistency of such beliefs.
Dilligetal .[12]formalizetheintuitionof[ 16]inaframeworkfor
detecting semantic inconsistency, where they design a null pointer
dereference checker. The belief propagation is carried out using
type inference: e.g., a pointer inferred with a â€œpossibly NULLâ€ type
should not be used in a context that requires a â€œnot NULLâ€ type.However, divide-by-zero detection requires an infinite analysisdomainandexistingapproachesfortype-statepropertiesarenot
applicable.
Inspired by the success of utilizing beliefs in previous works on
static analysis, we firstly introduce the use of beliefs to address
theimprecisionproblembroughtbyunder-constrainedvariablesin
divide-by-zero detection. We generalize the idea of â€œprogrammerâ€™s
beliefâ€inanalyzingnumericalcomputationbygeneratingbound
evidence from the bound checking statements in the program. Al-
thoughwedonotdirectlyinferinconsistency,theevidencewegen-
erateservesasadditionalconstraints,whichgreatlyimprovesthe
overall precision of the analysis. The imprecision problem caused
byunder-constrainedvariablesinstaticanalysisisobservedin[ 13],
where they tackle the problem with constraints rewriting. Since
they do not consider numerical property in the constraints and
assumeafiniteanalysisdomain,theirapproachisnotapplicablein
our scenario.
7 CONCLUSION
We have proposed Wit, a static analysis method to find divide-by-
zero bugs with affirmative evidence. The analysis looks for affir-
mativeevidence,namelysourceevidenceandboundevidence,to
finddivide-by-zerobugswithhighconfidence.Ithasbeenshown
effectiveindetectingdivide-by-zerobugspreciselyinlarge-scale
real-world software.
8 ACKNOWLEDGMENTS
We thank the anonymous reviewers for their insightful comments.
The authors are supported by the RGC16206517, ITS/440/18FP and
PRP/004/21FXgrantsfromtheHongKongResearchGrantCoun-
cil and the Innovation and Technology Commission, Ant Group,and the donations from Microsoft and Huawei. Peisen Yao is the
corresponding author.
REFERENCES
[1] [n.d.]. The Economics of Static Analysis Tool Usage. https://blogs.grammatech.
com/the-economics-static-analysis-tool-usage. Online; accessed 12-August-
2021.
[2]Alfred V. Aho, Ravi Sethi, and Jeffrey D. Ullman. 1986. Compilers: Principles,
Techniques,andTools. Addison-Wesley. https://www.worldcat.org/oclc/12285707
[3]Domagoj Babic and Alan J. Hu. 2008. Calysto: Scalable and Precise Extended
StaticChecking.In Proceedingsofthe30thInternationalConferenceonSoftware
Engineering (Leipzig,Germany) (ICSEâ€™08).AssociationforComputingMachinery,
New York, NY, USA, 211â€“220. https://doi.org/10.1145/1368088.1368118
[4]AlBessey,KenBlock,BenChelf,AndyChou,BryanFulton,SethHallem,Charles
Henri-Gros, Asya Kamsky, Scott McPeak, and Dawson Engler. 2010. A Few
BillionLines ofCode Later:UsingStatic AnalysistoFind Bugsinthe RealWorld.
Commun.ACM 53,2(Feb.2010),66â€“75. https://doi.org/10.1145/1646353.1646374
[5]CristianoCalcagno,DinoDistefano,PeterOâ€™Hearn,andHongseokYang.2009.
CompositionalShape Analysisby MeansofBi-Abduction.In Proceedingsof the
36th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming
Languages (Savannah, GA, USA) (POPL â€™09). Association for Computing Machin-
ery, New York, NY, USA, 289â€“300. https://doi.org/10.1145/1480881.1480917
[6]SigmundCherem,LonniePrincehouse,andRaduRugina.2007. PracticalMemory
LeakDetectionUsingGuardedValue-FlowAnalysis.In Proceedingsofthe28th
ACMSIGPLANConferenceonProgrammingLanguageDesignandImplementation
(San Diego,California, USA) (PLDI â€™07).Associationfor ComputingMachinery,
New York, NY, USA, 480â€“491. https://doi.org/10.1145/1250734.1250789
[7]Maria Christakis and Christian Bird. 2016. What Developers Want and Need
from Program Analysis: An Empirical Study. In Proceedings of the 31st IEEE/ACM
InternationalConferenceonAutomatedSoftwareEngineering (Singapore,Singa-
pore)(ASE 2016). Association for Computing Machinery, New York, NY, USA,
332â€“343. https://doi.org/10.1145/2970276.2970347
1728
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:32:16 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Yiyuan Guo, Jinguo Zhou, Peisen Yao, Qingkai Shi, and Charles Zhang
[8]Patrick Cousot and Radhia Cousot. 1977. Abstract Interpretation: A Unified
Lattice Model for Static Analysis of Programs by Construction or Approxi-mation of Fixpoints. In Proceedings of the 4th ACM SIGACT-SIGPLAN Sympo-
sium on Principles of Programming Languages (Los Angeles, California) (POPL
â€™77). Association for Computing Machinery, New York, NY, USA, 238â€“252.
https://doi.org/10.1145/512950.512973
[9]Patrick Cousot and Nicolas Halbwachs. 1978. Automatic Discovery of Linear
Restraints among Variables of a Program. In Proceedings of the 5th ACM SIGACT-
SIGPLAN Symposium on Principles of Programming Languages (Tucson, Arizona)
(POPLâ€™78).AssociationforComputingMachinery,NewYork,NY,USA,84â€“96.
https://doi.org/10.1145/512760.512770
[10]Ron Cytron, Jeanne Ferrante, Barry K. Rosen, Mark N. Wegman, and F. Kenneth
Zadeck. 1991. Efficiently Computing Static Single Assignment Form and the
ControlDependenceGraph. ACMTrans.Program.Lang.Syst. 13,4(1991),451â€“490.
https://doi.org/10.1145/115372.115320
[11]BarthÃ©lÃ©my Dagenais and Laurie Hendren. 2008. Enabling Static Analysis forPartial Java Programs. In Proceedings of the 23rd ACM SIGPLAN Conference on
Object-OrientedProgrammingSystemsLanguagesandApplications (Nashville,TN,
USA)(OOPSLA â€™08). Association for Computing Machinery, New York, NY, USA,
313â€“328. https://doi.org/10.1145/1449764.1449790
[12]Isil Dillig, Thomas Dillig, and Alex Aiken. 2007. Static Error Detection UsingSemantic Inconsistency Inference. In Proceedings of the 28th ACM SIGPLAN
Conference on Programming Language Design and Implementation (San Diego,
California,USA) (PLDIâ€™07).AssociationforComputingMachinery,NewYork,
NY, USA, 435â€“445. https://doi.org/10.1145/1250734.1250784
[13]Isil Dillig, Thomas Dillig, and Alex Aiken. 2010. Reasoning about the Unknown
in Static Analysis. Commun. ACM 53, 8 (Aug. 2010), 115â€“123. https://doi.org/10.
1145/1787234.1787259
[14]Isil Dillig, Thomas Dillig, and Alex Aiken. 2012. Automated Error DiagnosisUsing Abductive Inference. SIGPLAN Not. 47, 6 (June 2012), 181â€“192. https:
//doi.org/10.1145/2345156.2254087
[15]DinoDistefano,ManuelFÃ¤hndrich,FrancescoLogozzo,andPeterW.Oâ€™Hearn.
2019. Scaling Static Analyses at Facebook. Commun. ACM 62, 8 (July 2019),
62â€“70.https://doi.org/10.1145/3338112
[16]Dawson Engler, David Yu Chen, Seth Hallem, Andy Chou, and Benjamin Chelf.
2001. Bugs as Deviant Behavior: A General Approach to Inferring Errors inSystems Code. In Proceedings of the Eighteenth ACM Symposium on Operating
SystemsPrinciples (Banff,Alberta,Canada) (SOSPâ€™01).AssociationforComputing
Machinery, New York, NY, USA, 57â€“72. https://doi.org/10.1145/502034.502041
[17]Jeanne Ferrante, Karl J. Ottenstein, and Joe D. Warren. 1987. The Program
DependenceGraphandItsUseinOptimization. ACMTrans.Program.Lang.Syst.
9, 3 (July 1987), 319â€“349. https://doi.org/10.1145/24039.24041
[18]Arie Gurfinkel, Temesghen Kahsai, Anvesh Komuravelli, and Jorge A. Navas.2015. The SeaHorn Verification Framework. In Computer Aided Verification -
27th International Conference, CAV 2015, San Francisco, CA, USA, July 18-24, 2015,
Proceedings,PartI (LectureNotesinComputerScience,Vol.9206),DanielKroening
and CorinaS.Pasareanu (Eds.).Springer,343â€“361. https://doi.org/10.1007/978-
3-319-21690-4_20
[19]JingxuanHe,GagandeepSingh,MarkusPÃ¼schel,andMartinVechev.2020. Learn-
ing Fast and Precise Numerical Analysis. In Proceedings of the 41st ACM SIG-
PLANConferenceonProgrammingLanguageDesignandImplementation (London,
UK)(PLDI 2020). Association for Computing Machinery, New York, NY, USA,
1112â€“1127. https://doi.org/10.1145/3385412.3386016
[20]C. Lattner and V. Adve. 2004. LLVM: a compilation framework for lifelongprogram analysis amp; transformation. In International Symposium on Code
Generation and Optimization, 2004. CGO 2004. 75â€“86.https://doi.org/10.1109/
CGO.2004.1281665[21]Wei Le and Mary Lou Soffa. 2008. Marple: A Demand-Driven Path-Sensitive
Buffer Overflow Detector. In Proceedings of the 16th ACM SIGSOFT International
SymposiumonFoundations ofSoftwareEngineering (Atlanta,Georgia) (SIGSOFT
â€™08/FSE-16). Association for Computing Machinery, New York, NY, USA, 272â€“282.
https://doi.org/10.1145/1453101.1453137
[22]Lian Li, Cristina Cifuentes, and Nathan Keynes. 2010. Practical and Effective
SymbolicAnalysisforBufferOverflowDetection.In ProceedingsoftheEighteenth
ACMSIGSOFTInternationalSymposiumonFoundationsofSoftwareEngineering
(SantaFe,NewMexico,USA) (FSEâ€™10).AssociationforComputingMachinery,
New York, NY, USA, 317â€“326. https://doi.org/10.1145/1882291.1882338
[23]Fan Long, Stelios Sidiroglou-Douskos, Deokhwan Kim, and Martin Rinard. 2014.
Sound Input Filter Generation for Integer Overflow Errors. In Proceedings of the
41st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages
(San Diego, California, USA) (POPL â€™14). Association for Computing Machinery,
New York, NY, USA, 439â€“452. https://doi.org/10.1145/2535838.2535888
[24]MuhammadNumairMansur,BenjaminMariano,MariaChristakis,JorgeA.Navas,
andValentinWÃ¼stholz.2021. AutomaticallyTailoringAbstractInterpretation
toCustomUsageScenarios.In ComputerAidedVerification-33rdInternational
Conference, CAV 2021, Virtual Event, July 20-23, 2021, Proceedings, Part II (Lecture
NotesinComputerScience,Vol.12760) ,AlexandraSilvaandK.RustanM.Leino
(Eds.). Springer, 777â€“800. https://doi.org/10.1007/978-3-030-81688-9_36
[25]Antoine MinÃ©. 2006. The Octagon Abstract Domain. Higher Order Symbol.
Comput.19, 1 (March 2006), 31â€“100. https://doi.org/10.1007/s10990-006-8609-1
[26]AntoineMinÃ©.2007. ANewNumericalAbstractDomainBasedonDifference-
Bound Matrices. CoRRabs/cs/0703073. arXiv:cs/0703073 http://arxiv.org/abs/cs/
0703073
[27]HakjooOh,WonchanLee,KihongHeo,HongseokYang,andKwangkeunYi.2014.SelectiveContext-SensitivityGuidedbyImpactPre-Analysis.In Proceedingsofthe
35th ACM SIGPLAN Conference on Programming Language Design and Implemen-
tation(Edinburgh,UnitedKingdom) (PLDIâ€™14).AssociationforComputingMa-
chinery, New York, NY, USA, 475â€“484. https://doi.org/10.1145/2594291.2594318
[28]David A. Ramos and Dawson Engler. 2015. Under-Constrained Symbolic Ex-ecution: Correctness Checking for Real Code. In 24th USENIX Security Sym-
posium (USENIX Security 15). USENIX Association, Washington, D.C., 49â€“64.https://www.usenix.org/conference/usenixsecurity15/technical-sessions/
presentation/ramos
[29]Qingkai Shi, Xiao Xiao, Rongxin Wu, Jinguo Zhou, Gang Fan, and CharlesZhang. 2018. Pinpoint: Fast and Precise Sparse Value Flow Analysis for Mil-
lionLinesofCode.In Proceedingsofthe39thACMSIGPLANConferenceonPro-
grammingLanguageDesignandImplementation (Philadelphia,PA,USA) (PLDI
2018). Association for Computing Machinery, New York, NY, USA, 693â€“706.
https://doi.org/10.1145/3192366.3192418
[30]Yulei Sui, Ding Ye, and Jingling Xue. 2012. Static Memory Leak Detection Us-ing Full-Sparse Value-Flow Analysis. In Proceedings of the 2012 International
Symposium on Software Testing and Analysis (Minneapolis, MN, USA) (ISSTA
2012). Association for Computing Machinery, New York, NY, USA, 254â€“264.
https://doi.org/10.1145/2338965.2336784
[31]OmerTripp,MarcoPistoia,StephenJ.Fink,ManuSridharan,andOmriWeisman.2009. TAJ:EffectiveTaintAnalysisofWebApplications.In Proceedingsofthe30th
ACMSIGPLANConferenceonProgrammingLanguageDesignandImplementation
(Dublin,Ireland) (PLDIâ€™09).AssociationforComputingMachinery,NewYork,
NY, USA, 87â€“97. https://doi.org/10.1145/1542476.1542486
[32]Yichen Xie and Alex Aiken. 2005. Scalable Error Detection Using BooleanSatisfiability. In Proceedings of the 32nd ACM SIGPLAN-SIGACT Symposium
on Principles of Programming Languages (Long Beach, California, USA) (POPL
â€™05). Association for Computing Machinery, New York, NY, USA, 351â€“363.
https://doi.org/10.1145/1040305.1040334
1729
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:32:16 UTC from IEEE Xplore.  Restrictions apply. 