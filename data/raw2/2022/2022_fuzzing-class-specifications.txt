Fuzzing Class Specifications
Facundo Molina
University of Rio Cuarto and
CONICET
Argentina
fmolina@dc.exa.unrc.edu.arMarcelo d‚ÄôAmorim
Federal University of Pernambuco
Brazil
damorim@cin.ufpe.brNazareno Aguirre
University of Rio Cuarto and
CONICET
Argentina
naguirre@dc.exa.unrc.edu.ar
ABSTRACT
Expressing class specifications via executable constraints is impor-
tant for various software engineering tasks such as test generation,
bug finding and automated debugging, but developers rarely write
them.Techniquesthatinferspecificationsfromcodeexisttofillthis
gap,buttheyaredesignedtosupportspecifickindsofassertions
andaredifficulttoadapttosupportdifferentassertionlanguages,
e.g., to add support for quantification, or additional comparison
operators, such as membership or containment.
To address the above issue, we present SpecFuzzer, a novel
technique that combines grammar-based fuzzing, dynamic invari-
ant detection, and mutation analysis, to automatically produce
class specifications. SpecFuzzer uses: (i)a fuzzer as a generator
of candidate assertions derived from a grammar that is automat-ically obtained from the class definition; (ii)a dynamic invariant
detector ‚ÄìDaikon‚Äì to filter out assertions invalidated by a testsuite; and (iii)a mutation-based mechanism to cluster and rank
assertions, so that similar constraints are grouped and then the
stronger prioritized. Grammar-based fuzzing enables SpecFuzzer
tobestraightforwardlyadaptedtosupportdifferentspecification
languages,bymanipulatingthefuzzinggrammar,e.g.,toinclude
additional operators.
We evaluate our technique on a benchmark of 43 Java meth-
odsemployedintheevaluationofthestate-of-the-arttechniques
GAssertandEvoSpex.OurresultsshowthatSpecFuzzercaneas-
ily support a more expressive assertion language, over which is
moreeffectivethanGAssertandEvoSpexininferringspecifications,
according to standard performance metrics.
CCS CONCEPTS
‚Ä¢Theory of Computation ‚ÜíProgram specifications ;‚Ä¢Soft-
wareanditsengineering ‚ÜíDynamicanalysis ;Softwaretest-
ing and debugging.
KEYWORDS
Oracle problem, specification inference, grammar-based fuzzing.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACMmustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA
¬© 2022 Association for Computing Machinery.
ACM ISBN 978-1-4503-9221-1/22/05...$15.00
https://doi.org/10.1145/3510003.3510120ACM Reference Format:
Facundo Molina, Marcelo d‚ÄôAmorim, and Nazareno Aguirre. 2022. Fuzzing
ClassSpecifications.In 44thInternationalConferenceonSoftwareEngineering
(ICSE ‚Äô22), May 21‚Äì29, 2022, Pittsburgh, PA, USA. ACM, New York, NY, USA,
13 pages. https://doi.org/10.1145/3510003.3510120
1 INTRODUCTION
Softwarespecificationsareabstractdescriptionsofthesoftware‚Äôs
intendedbehavior.Theyservetwomainpurposes:toexplicitlystate
the userneeds and tocheck implementation conformance[ 23]. In
Object-Oriented (OO) design, where software is organized as a set
ofclasses,aclassspecificationdescribestheintendedbehaviorof
the class methods and the constraints on the state of the class‚Äô
objects. While the specification of a class is typically described
informally,throughnaturallanguagedocumentationofitsAPI,the
specification becomes significantly more useful when expressedformally, through constraints known as contracts
1[36,46]. Con-
tractsenabletechniquesof variouskinds,includingtestgeneration
[6,13,33,48], automated debugging [ 16,34,43,44], bug finding
[30,41], and verification [ 17,21,22,30]. Despite the benefits of
formal contracts, developers rarely write them.
To aid developers in equipping implementations with contracts,
techniques for inferring class specifications have been proposed [ 9,
18,38,47].However,thespecificationexpressivenessoftheseap-
proachesislimited.Daikon[ 18],thebaselinethatothertechniques
use,supportsarestrictedsetoftemplates,fromwhichassertions
are generated. It is then limited to simple assertions (e.g., no direct
support for quantification), or requires the developer to manu-
ally extend the assertion language. GAssert [ 47] and EvoSpex [ 38],
two recently proposed techniques for contract inference, try toaddress this limitation of Daikon by supporting more expressive
assertion languages, but their extensions focus on specific kinds of
constraints: GAssert focuses on logical/arithmetic constraints(no
quantified expressions) and EvoSpex focuses on object navigation
constraints (only very simple logical and arithmetic operators are
supported).Moreover,asbothtechniquesarebasedonevolution-
ary search, they are difficult to extend or adapt to support further
expressions, as the evolutionary algorithms are targeted for the
specific languages supported by the corresponding tools.
To overcome the limitations of existing approaches, we pro-
pose SpecFuzzer, atechnique for generatinglikely specifications
byfuzzingpotential specifications associated with a given class.
SpecFuzzerusesgrammar-basedfuzzingtoautomaticallygener-
ateconstraintsthatcanbeusedascandidatespecificationsbyan
invariant detection tool (in our case, we use Daikon). Fuzzing [ 50],
1In the context of this paper, we will interchangeably use the terms contractandspeci-
fication. A contract is typically composed of different assertions for various program
points, such as method preconditions and postconditions.
10082022 IEEE/ACM 44th International Conference on Software Engineering (ICSE)
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:20:26 UTC from IEEE Xplore.  Restrictions apply. ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA F. Molina, M. d‚ÄôAmorim and N. Aguirre
traditionallyusedtoefficientlyproducestructuredrandomdatafor
testing, has two key advantages in this context: (1) it eliminates
theneedofdeveloperstomanuallydefinecandidateassertionsand
(2)itenablesdeveloperstostraightforwardlyadaptthelanguageof
assertions by manipulating the fuzzing grammar.
Fuzzing can quickly produce very large sets of assertions to
be fed to a dynamic detection tool. However, as the assertions
are generated randomly, and dynamic invariant detection only
filters out assertions that can be invalidated by a given test suite, a
substantial number of candidate specification expressions may be
reported by the dynamic detector, when fed with fuzzed assertions.
Toaddressthisproblemandbetterassistdevelopersindrivingtheir
attention to the likely most relevant specifications, SpecFuzzeruses an assertion reduction mechanism based on clustering and
mutationtesting[ 7,42].Aftergeneratingthousandsofcandidate
specificationswithfuzzing,SpecFuzzerusestheoutputofacustommutationanalysistoclustercandidatespecifications.Moreprecisely,
it partitions the set of specifications according to the mutants they
kill, and within each partition, the assertion that is falsified the
most number of times when running the test suite on the mutants,
is picked as the representative. Notice that, even though all the
assertionsinthesamepartitionkillthesamemutants,somemay
be falsified more than others, as a same mutant may be killedby multiple tests. The rationale for the mutation based partitionis that assertions that kill different mutants are non-equivalent
(or, alternatively, that assertions that kill the same mutants are
‚Äúsimilar‚Äù); the rationale for ranking assertions according to the
number of failures is that assertions that are falsified a greater
number of times are ‚Äústronger‚Äù.
We compared SpecFuzzer with GAssert [ 47] and EvoSpex [ 38],
two state-of-the-art techniques in specification inference. To eval-
uate SpecFuzzer, we used the same benchmarks from the evalu-
ationofGAssertandEvoSpex,carefullystudiedthesubjects,and
manuallyproducedcorresponding‚Äúgroundtruth‚Äùassertionscap-
turing the intended behavior of the subjects. We then used thisground truth to accurately assess precision and recall of Spec-Fuzzer, GAssert, and EvoSpex. It is worth noting that (1) prior
work used indirectmetrics to compute precision andrecall (as op-
posed to the direct usage of ground truth) and (2) prior work used
subsetsofthesubjectsweconsider(ourbenchmarkisthecombina-
tion of the GAssert and EvoSpex benchmarks). Our results showthat SpecFuzzer increases the expressiveness over GAssert and
EvoSpex,beingabletoexpress ‚àº45%moreassertionsintheground
truththanthesetools.SpecFuzzerwasalsoabletodetect75%of
allassertionsinthegroundtruth,showingabetteroverallperfor-
mancecomparedtoprevioustechniques.Theresultsweobtained
provide initial, yet strong evidence that SpecFuzzer is effective.
In summary, this paper makes the following contributions:
‚Ä¢SpecFuzzer,anoveltechniqueforassertioninferencethat
combines grammar-based fuzzing and dynamic invariant
detection.
‚Ä¢An efficient mechanism for grouping similar assertions and
for ranking assertions based on their strength.
‚Ä¢AthoroughevaluationofourtechniqueagainstGAssertand
EvoSpex, in which performance metrics are computed in
relation to manually written assertions (ground truth).The evaluation artifacts of SpecFuzzer are publicly available [5].
2 BACKGROUND
Thissectionpresentsbackgroundmaterialthatisimportantforthe
rest of the paper.
2.1 Specification Inference
Specification inference is the problem of generating a formal de-
scription of the software behavior from existing software artifacts,
e.g., documentation, source code, etc. Specification inference isclosely related to the oracle problem [
8], which is the problem of
decidingwhetherornotaprogramexecutionisconsistentwiththe
desiredbehavioroftheprogram.Specificationinferenceprovides
a means to create oracles[8]. For regression testing purposes, it
sometimessufficestoproducespecificationsofexpectedproperties
as assertions for the context of a given test case [ 20]. However,
moregeneralassertionsthatcaptureproperties atgivenlocations
withintheprogram(notthetest)foranyinput haveotherapplica-
tions, including testing. This is the problem we study in this paper,
defined as follows.
Definition2.1. Givenatargetprogram P,andaprogrampoint
of interest ùúåinP, infer a specification ùúôthat captures the states at
ùúå, i.e., for every state ùë†ofP,ùúôholds inùë†if and only if there exists
an execution ùë°ofPsuch that ùë†is the state of ùë°at program point ùúå.
2.2 Grammar-based Fuzzing
Fuzzing is a very active topic both in research [ 1] and practice [ 2‚Äì
4]. Fuzzing is a technique to automatically produce large sets of
(oftenstructured)data,fortestingatargetprogram.Thegeneration
process typically involves randomness and the rationale is thattesting on (large sets of) quasi-valid data can reveal subtle bugs,
suchaswronglyhandledinputsandcornercases.Awell-known
usecaseoffuzzingisdetectionofsecurityvulnerabilities,suchas
buffer overflows [35, 37].
Differentfuzzingstrategiesexist[ 35].Grammar-basedfuzzing
uses an input grammar to produce syntactically-valid inputs by
traversingtheproductionrulesofthegrammar.Initssimplestform,theinputgenerationprocesscanbeimplementedasanincrementalexpansionofastringstartingfromtheinitialgrammarsymbol,and
replacingnon-terminalsymbolsbytheapplicationofarandomly-
chosen production rule of the correspondingnon-terminals, until
thestringconsistsofterminalsonly;aboundonthenumberofnon-
terminals enables this process to handle recursion, which would
otherwiseleadtoinfiniteloops.Asanexample,considerascenario
where the program to test takes as input a propositional logic (PL)
formula, characterized by the grammar from Figure 1. To generate
testingdata,thePLgrammarcanbefedtoagrammar-basedfuzzer
(e.g.,Grammarinator[ 25])toefficientlyobtainaverylargesetof
well-formedtestdata(PLformulas,inthiscase).Togenerateinputs,
thefuzzerexplorespathsinducedbythegrammarproductionrules.
For instance, the input neg(p and q) can be obtained through
the following derivation: start/leadstoformula/leadstonegformula/leadstoneg
(formulaandformula)/leadstoneg (p and formula)/leadstoneg (p and
q). It is worth noticing that a great advantage of fuzzing in this
case is that the input language can be easily adapted by modifying
the grammar. For instance, our fuzzer would be able to generate
1009
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:20:26 UTC from IEEE Xplore.  Restrictions apply. Fuzzing Class Specifications ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA
/angbracketleftstart/angbracketright::=/angbracketleftformula/angbracketright
/angbracketleftformula/angbracketright::=/angbracketleftatomic/angbracketright| neg/angbracketleftformula/angbracketright|(/angbracketleftformula/angbracketrightand/angbracketleftformula/angbracketright)
/angbracketleftatomic/angbracketright::= true | false|p|q|r|. . .
Figure 1: Propositional Logic grammar.
formulaswithdisjunctionsifweaddacorrespondingproduction
rule to the non-terminal formula.
Theaboveexampleisrelevantbecausethetechniquewepropose
inthispaperusesgrammar-basedfuzzingasalightweightapproach
to produce assertions (such as the PL formulas above) as candidate
specificationsforprogrampoints.Thesimplicitywithwhichthe
grammar can be adapted or extended will be one of the advantages
of the approach, compared with related techniques.
2.3 Assertion Language
An assertion is a logical expression associated with a program
point expressing an expected property at that location. The use
of assertions has wide-spread applications in software design [ 36],
software testing [7], and verification [12, 24].
OurassertionlanguageissimilarinexpressivepowertoJML,and
features first-order quantification ( \forall,\exists), arithmetic
andlogicaloperators,andreachabilityexpressions(thereachop-
erator \reach(x, f1, ..., fk) denotes the smallest set of objects
reachablefrom x,throughfields f1,...,fk).Additionally,postcon-
ditionassertionsmightusethe \old(expr) notation,torefertothe
value of expression exprat the precondition. For simplicity, we
drop the backslashes, shorten the quantifier names, and replace
thesemicolonnotationinJMLquantificationbytheimplication(in
thecase ofuniversal quantification)or conjunction(inthe caseof
existentialquantification).Asanexample,thefollowingexpression
all SortedList l:
reach(this, next).has(l) ==> l.elem == old(l.elem)
states that the integer field elemof the list nodes reachable from
this(hasistheJMLoperatorformembership)remainsunchanged.
This expression corresponds to the following JML expression:
\forall SortedList l;
\reach(this, next).has(l); l.elem == \old(l.elem)
Our assertion language is motivated by the expressive power of
the languages in related work, and in contract languages [ 11,18,
19,36,38,47]. This is a generallanguage, that includes the usual
relational, arithmetic and logical operators, but no domain specific
functions (e.g., trigonometric functions, that would be relevant
only for some analysis subjects, are not considered). The assertion
languageenablesonetorefertoclass/objectfields,butnottothe
resultsofmethodcalls.Thatwouldrequireustodeclaremethodsas
‚Äúpure‚Äù to use them in assertions, which is beyond what our current
implementationsupports.
3 ILLUSTRATIVE EXAMPLES
ThissectionillustratesSpecFuzzerontwosimpleexampleswith
the purpose of (1) highlighting limitations of state-of-the-art speci-
fication inference techniques and (2) illustrate SpecFuzzer.
Examples. Figure 2 shows min, a Java method to compute the mini-
mumoftwointegers,whereasFigure3shows SortedList ,aJava/* Returns the minimum of two integers */
public static int min(int x,inty) {
if(x <= y) return x;
else return y;
}
Figure 2: Method to get the minimum of two values.
public class SortedList {
private int elem;
private SortedList next;
private static final int SENTINEL = Integer.MAX_VALUE;
/* Constructors */
public SortedList() { this(SENTINEL, null); }
private SortedList(int elem, SortedList next) {
this.elem = elem;
this.next = next;
}
/* Method to insert an element in the list */
void insert(int data) {
if(data > elem) {
next.insert(data);
}else {
next = newSortedList(elem, next);
elem = data;
}
}
}
Figure 3: Class SortedList implements an ordered list of in-
tegers.
classimplementinganorderedlistofintegers.The minmethodis
straightforward.Class SortedList isslightlymoreelaborate.Ithas
two instance fields, elemandnext, that represent the value of a
linked list node and the reference to the next node, respectively.
Italsohasaclassfield( SENTINEL)thatstoresaspecialvalue‚Äìthe
maximum Java integer value‚Äì as a mark for the end of the list. The
sentinel should be placed at the end of the list and should not be
repeated.Thedefaultconstructorcreatesanodemarkingtheend
of the list. The insertmethod takes the integer dataas parameter
and inserts it in its correct sorted position in the linked list. As it is
notpossibleforanyintegervaluetobegreaterthanthesentinel,
the search is guaranteed to insert the element before the sentinel.
Relevant Properties. Theintendedbehaviorofmethod ministhat
itcomputestheminimumbetween xandy.Aspecificationofthe
postcondition of minin our assertion language is as follows:
(result == x || result == y) &&
(result <= x) && (result <= y)
The postcondition of method SortedList.insert involves vari-
ousproperties:thelistisacyclicandsortedincreasingly,thesen-
tinelisinthelist(attheend),andthe dataelementisinserted.This
postcondition can be specified as follows:
all SortedList l:
reach(this, next).has(l) ==> !reach(l.next, next).has(l)
all SortedList l:
reach(this, next).has(l) ==> l.elem <= l.next.elem
1010
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:20:26 UTC from IEEE Xplore.  Restrictions apply. ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA F. Molina, M. d‚ÄôAmorim and N. Aguirre
Table 1: GAssert and EvoSpex on the running examples.
GAssert EvoSpex
min(int x,int y) - postcondition
1(x > result && y == result) || (result <= y && result == x) result <= x
2 result <= y
SortedList.insert(intdata) - postcondition
1elem-(data-elem) <= old(elem) exists SortedList l: reach(this, next).has(l) && l.elem == data
2 old(elem) <= next.elem
exists SortedList l:
reach(this, next).has(l) && l.elem == SENTINEL
exists SortedList l:
reach(this, next).has(l) && l.elem == data
We may consider these assertions to be the ground truth post-
conditionspecificationsofthecorrespondingmethods,andwhat
we would ideally expect specification inference tools to produce.
3.1 Techniques for Specification Inference
Daikon.Daikon[18]isdynamictechniquethatinfersspecifications
by monitoring test executions. Considering Definition 2.1, besides
the program P, Daikon requires a test suite TforPto infer speci-
fications. Daikon uses Tto exercise P; it monitors program states
at various program points of P; it considers a set of assertions
obtained by instantiating assertion patterns, and those that are not
invalidated by any test at a given program point are reported to
the user as likely invariants at the program point.
GAssert and EvoSpex. GAssert[ 47]andEvoSpex[ 38]arerecently
proposedspecificationinferencetechniques.AsDaikon,thesetools
execute a test suite of the program under analysis and observe
executionsto inferspecificationsthatareconsistentwiththeob-
servations. While Daikon requires the test suite to be provided,GAssertandEvoSpexusetheirowntestgenerationmechanisms
(third-partytestgenerationtoolsinthecaseofGAssert,acustom
testgenerationapproachinthecaseofEvoSpex).Althoughbothtechniques are based on evolutionary search, they have key dif-ferences. GAssert implements a co-evolutionary algorithm thatexplores the space of possible assertions (the co-evolution deals
with false-positives and false-negatives via two cooperating evolu-
tionary processes)and usesthe OASIs[26] oracle assessmenttool
to iteratively improve the assertions. EvoSpex implements a classi-
calgeneticalgorithmtoexplorethesearchspace,andusesastate
mutationtechniquetogeneratepostconditionstatesinwhichthe
assertionsbeingsoughtforshouldfail.GAssert‚Äôsevolutionaryoper-ationsfocusonlogicalandarithmeticassertionswhereasEvoSpex‚Äôs
focusesonobjectnavigationalproperties.Forthesetools,chang-
ingtheassertionlanguagesimpliesredefiningthecorresponding
evolutionaryoperatorsandotherparametersoftheevolutionary
algorithms, which is non-trivial.
Tables1and2showhowDaikon,GAssert,andEvoSpexperform
on the examples (for brevity, we have removed thisfrom non-
quantifiedexpressionsinthe insertexample).GAssertperforms
perfectly on the minexample, but poorly on SortedList (it does
not capture most of the ground truth); EvoSpex infers one complex
assertion for SortedList.insert (that the element is inserted) and
missestheremainingthreeinthecorrespondinggroundtruth;it
also infers part of the ground truth for min. Daikon infers the sameasEvoSpexinthecaseof min,andinthecaseof SortedList.insert ,
it only infers specific sortedness instances between the first fewelements of the list, but it fails to generalize this relationship for
the whole structure. It fully misses the remaining assertions in the
ground truth.
3.2 SpecFuzzer
SpecFuzzerusesacombinationof staticanalysis,grammar-based
fuzzing,and mutationanalysis toinferspecifications. SpecFuzzer
proceeds as follows. First, it uses a lightweight static analysis to
produce agrammar forthe specificationlanguage, whichis tuned
to the software under analysis. Then, it uses a grammar-based
fuzzertogeneratecandidatespecificationsfromthatgrammar.A
dynamic detector then determines which of those specifications
are consistent with the behavior exhibited by a provided test suite.
Finally, SpecFuzzer eliminates irrelevant and equivalent specifica-
tionsusingamechanismbasedonmutationanalysisandclustering.
Asalientfeatureof SpecFuzzeristhatdeveloperscanadjustthe
setofspecificationsproducedbytuningthegrammarasopposed
to making changes in the tool.
Table 2 shows the assertions that SpecFuzzer infers as post-
conditions for methods minandSortedList.insert . Recall that
SpecFuzzer uses fuzzing and reports a higher number of asser-
tionscomparedtotheothertechniques.Weconfiguredthefuzzer
toproduce2000candidateassertionspersubject,andfoundthat,
out of those generated, 51 and 437 were confirmed as likely invari-
ants by the dynamic detector for minandinsert, respectively. The
mutation-based partition strategy enabled SpecFuzzer to consider-
ably reduce the reported assertions to 9 and 16, respectively.
In the case of min, the 9 inferred assertions are valid and their
conjunctionisequivalenttothecorrespondinggroundtruth.For
SortedList.insert ,thefirst3assertionsalreadycover3outof4
assertions in the ground truth (the only missing one is list acyclic-
ity). The other inferred assertions are either valid but less relevant
(4-13), or invalid (14-16). The invalid ones are specifications that
were true in the provided test suite, but there exist some unseen
scenarios in which they are falsified. Notice that this also affectsthe other techniques, even though GAssert and EvoSpex includecostly mechanisms to reduce invalid assertions (the assertion in-
ferredbyGAssertfor SortedList.insert ,inparticular,isaninvalid
property).
4 APPROACH
This section presents SpecFuzzer, a technique for specification
inferencethatusesacombinationofstaticanalysis,grammar-based
fuzzing, and mutation analysis.
1011
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:20:26 UTC from IEEE Xplore.  Restrictions apply. Fuzzing Class Specifications ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA
Table 2: Daikon and SpecFuzzer on the running examples.
Daikon SpecFuzzer
min(int x,int y) - postcondition
1result <= x x >= result
2result <= y x < result ==> result <= 1
3 x >= y ==> y == result
4 x >= y || y != result
5 x <= y || y <= result
6 x <= y || y >= result
7 x >= y <==> y == result
8 x == y ==> y <= result
9 x <= y <==> x == result
SortedList.insert(intdata) - postcondition
1elem <= next.elem exists SortedList l: reach(this, next).has(l) && l.elem == SENTINEL
2elem <= next.next.elem all SortedList l: reach(this, next).has(l) ==> l.elem <= l.next.elem
3next.elem <= next.next.elem exists SortedList l: reach(this, next).has(l) && l.elem == data
4next != null next != null
5elem <= old(elem) elem != old(elem) + 1
6elem <= old(next.elem) next.elem >= old(elem)
7elem <= old(next.next.elem) data >= next.elem || next.elem = old(elem)
8elem <= data elem == data xor data > old(elem)
9next.elem >= old(elem) elem > data ==> data = next.elem
10next.elem <= old(next.elem) exists SortedList l: reach(this.next, next).has(l) && l.elem != 1
11next.elem <= old(next.next.elem) exists SortedList l: reach(this, next).has(l) && l.elem > this.elem
12next.next.elem >= old(elem) exists SortedList l: reach(this, next).has(l) && l.elem <= l.next.elem
13next.next.elem >= old(next.elem) all SortedList l: reach(this.next, next).has(l) ==> l.elem >= this.next.elem
14next.next.elem <= old(next.next.elem) elem <= old(elem) ==> old(elem) < old(next.next.elem)
15 elem != next.next.elem + old(next.next.elem)
16 data >= next.next.elem || next.next.elem == old(next.elem)
Figure4showstheworkflowofthetechnique.SpecFuzzertakes
asinputaJava2classùê∂,andproducesassertionsthatseektocharac-
terize properties of different execution points in ùê∂, such as method
preconditionsandpostconditions.FollowingtheDaikonterminol-
ogy, we will generally refer to assertions that hold on specific pro-
gram points as invariants. The technique is organized as a pipeline
of five components: (1) a Tests and Mutants Generation compo-
nent that produces tests and mutants for other components of the
pipeline, (2) a Grammar Extractor that analyzes ùê∂to generate a
specification grammar for that class, (3) a Grammar Fuzzer, which
produces candidate assertions by exploring the production rules
fromtheextractedgrammar,(4)a DynamicInvariantDetector,r e-
sponsible for inferring likely invariants from the fuzzed assertions
via observations made with the executions of an input test suite,
and(5)an InvariantSelector component,whichpartitionsthelikely
invariants produced by the previous component to discard useless
(weak)assertions,groupstogethersimilarassertions,andreports
a reduced set of assertions, prioritizing the stronger ones. The fol-
lowing sections discuss these components in greater detail.
4.1 Tests and Mutants Generation
The first step of our process to infer specifications for a class ùê∂
consistsof (i)generatingatestsuite ùëáexercisingthemethodsof
thetargetclass ùê∂,and(ii)producingaset ùëÄ1,...,ùëÄ ùëõofmutants
ofùê∂,representingsyntheticfaultsintheclass.AsFigure4shows,
theseartifactsareusedatdifferentstagesofthetechnique.Weused
2Although our approach is general and language independent, some parts of our
current prototype, such as the grammar extraction and the evaluation of candidate
(fuzzed)specifications,arecurrentlyimplementedforJava.Supportingotherlanguages
that Daikon can handle, like C, would require the implementation of such parts.Randoop [ 41] for test generation and Major [ 27] for mutant gener-
ation.Althoughweusedthesetoolsinourcurrentimplementation,
the user may replace them with other tools or even provide her
own test suite and mutated versions of the target class ùê∂.
4.2 Grammar Extractor
TheGrammarExtractor takesasinputaclass ùê∂andcreatesagram-
marùê∫ùê∂expressingthelanguageofcandidateassertionsfor ùê∂.Those
assertions denote method preconditions, postconditions, and class
invariants.Theextractorinstantiatesourbasegrammar,referred
toasùêµ,withinformationthatisspecificto ùê∂,e.g.,attributetypes,
legally typed navigational expressions involving the attributes, etc.
Figure5showsafragmentofthebasegrammar ùêµ,capturingthe
fixedpartsofthespecificationlanguage,i.e.,thepartsthatarecom-
montoanyinputclassofinterest.Forthispaper,thegrammar ùêµsup-
ports numerical comparisons, logical expressions, membership ex-
pressions, and quantified expressions. Numerical comparisons and
SpecFuzzer
(4) Dynamic
Invariant Detector
Specs 
GrammarFuzzed 
SpecsLikely
InvariantsTarget class Test suite
(3) Grammar 
Fuzzer
(2) Grammar 
Extractor
Target class mutants
(5) Invariant 
Collector
Inferred
Invariants
(1) Test Generation (Randoop) 
+
Mutation Tool (Major)+
Figure 4: The SpecFuzzer workflow.
1012
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:20:26 UTC from IEEE Xplore.  Restrictions apply. ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA F. Molina, M. d‚ÄôAmorim and N. Aguirre
/angbracketleftFuzzedSpec /angbracketright::=/angbracketleftQuantifiedExpr /angbracketright|/angbracketleftBooleanExpr /angbracketright
/angbracketleftQuantifiedExpr /angbracketright::=/angbracketleftQuantifier /angbracketright/angbracketleftTyped_Var /angbracketright‚Äò:‚Äô/angbracketleftBooleanExpr /angbracketright
/angbracketleftQuantifier /angbracketright::= ‚Äòall‚Äô|‚Äò exists‚Äô
/angbracketleftBooleanExpr /angbracketright::=/angbracketleftNumCmpExpr /angbracketright|/angbracketleftLogicCmpExpr /angbracketright|
/angbracketleftMembershipExpr /angbracketright|‚Äò!‚Äô/angbracketleftBooleanExpr /angbracketright
/angbracketleftNumCmpExpr /angbracketright::=/angbracketleftNumExpr /angbracketright/angbracketleftNumCmpOp /angbracketright/angbracketleftNumExpr /angbracketright
|/angbracketleftNumExpr /angbracketright/angbracketleftNumCmpOp /angbracketright/angbracketleftNumExpr /angbracketright/angbracketleftNumBinOp /angbracketright
/angbracketleftNumExpr /angbracketright
/angbracketleftNumExpr /angbracketright::=/angbracketleftNumVar /angbracketright|/angbracketleftNumConst /angbracketright
/angbracketleftLogicCmpExpr /angbracketright::=/angbracketleftBooleanExpr /angbracketright/angbracketleftLogicOp/angbracketright/angbracketleftNumCmpExpr /angbracketright
|‚Äò(‚Äô/angbracketleftBoolVar/angbracketright/angbracketleftLogicOp/angbracketright/angbracketleftBoolVar/angbracketright‚Äò)‚Äô/angbracketleftLogicOp/angbracketright
/angbracketleftNumCmpExpr /angbracketright
|‚Äò(‚Äô/angbracketleftNumCmpExpr /angbracketright‚Äò)‚Äô/angbracketleftLogicOp/angbracketright‚Äò(‚Äô/angbracketleftNumCmpExpr /angbracketright‚Äò)‚Äô
/angbracketleftMembershipExpr /angbracketright::=/angbracketlefttype_SetExpr /angbracketright.has(/angbracketlefttype_Var /angbracketright)
/angbracketleftNumCmpOp /angbracketright::= ‚Äò==‚Äô|‚Äò !=‚Äô|‚Äò>‚Äô|‚Äò<‚Äô|‚Äò<=‚Äô|‚Äò>=‚Äô
/angbracketleftNumBinOp /angbracketright::= ‚Äò+‚Äô|‚Äò -‚Äô|‚Äò*‚Äô|‚Äò/‚Äô|‚Äò%‚Äô
/angbracketleftLogicOp/angbracketright::= ‚Äò||‚Äô|‚Äò xor‚Äô|‚Äò ==>‚Äô|‚Äò <==>‚Äô
Figure 5: Fragment of the base grammar ùêµ.
logicalexpressionsarethesimplestconstructsofthelanguage.They
relatenumericalexpressionsandbooleanexpressionsbyusingtradi-
tional numerical operators and logical connectives‚Äî /angbracketleftNumCmpOp /angbracketright
and/angbracketleftLogicOp/angbracketright, respectively. Membership expressions allow one to
expresswhetherornotatypedelementbelongstoaset(collection)
of the corresponding type. The grammar fragment uses the has
notationfromJML,andshowsaproductionrulefortypedvariables.
Althoughitisnotexplicitlyshowninthegrammarfragment,the
reachoperator is a way of building a typed set expression. A con-
creteexampleof amembershipexpressionfrom aformulashown
in Section 3 is the following:
reach(this, next).has(l)
expressingthatlist lbelongstothesetofobjectsreachablefrom
thisbynavigations(zeroormore)through next.Finally,thegram-
marallowsforexistentialanduniversalquantification.Again,an
example of a quantified expression from Section 3 is the following:
exists SortedList l:
reach(this, next).has(l) && l.elem == SENTINEL
whoseintuitivereadingisthatthereexistsalistobjectreachable
fromthiswith the field elemholding the SENTINEL.
Toobtainthegrammar ùê∫ùê∂,thegrammarextractortakes ùêµand
addsordeletessymbolsandproductionrules,basedonthestruc-
ture ofùê∂. The process basically depends on ùê∂‚Äôs direct and indirect
fields (fields declared in ùê∂itself or in a class reachable from ùê∂).
Intuitively,fromeveryfield/navigation,aterminalsymbolofthe
corresponding type is defined (e.g., this.next will be a terminal of
typeSortedList ).
Set expressions deserve a more detailed description. Firstly, if
a field fis of a Collection type, then fwill be a terminal of
(typed) SetExpr. For instance, if SortedList were an implemen-
tationof Collection ,then thisandthis.next wouldbeterminals
oftype SortedList_SetExpr .Secondly,the reachoperatorisalso
involved in building set expressions. For expression eand recur-
sive field f(a field is recursive if it is defined in a class Cand has/angbracketleftFuzzedSpec /angbracketright
/angbracketleftQuantiÔ¨ÅedExpr /angbracketright
/angbracketleftQuantiÔ¨Åer /angbracketright/angbracketleftTyped Var /angbracketright /angbracketleftBooleanExpr /angbracketright
/angbracketleftNumExpr/angbracketright‚ÄòSortedList l ‚Äô‚Äò:‚Äô
‚Äòexists‚Äô /angbracketleftLogicCmpExpr/angbracketright
/angbracketleftBooleanExpr /angbracketright/angbracketleftLogicOp /angbracketright/angbracketleftNumCmpExpr /angbracketright
/angbracketleftMembershipExpr/angbracketright ‚Äò==>‚Äô
‚Äòreach(this, next).has(l)‚Äô/angbracketleftNumExpr/angbracketright /angbracketleftNumCmpOp /angbracketright
‚Äòl.elem‚Äô ‚Äò==‚Äô ‚ÄòSENTINEL‚Äô
Figure 6: A derivation tree produced by our GrammarFuzzer for the expression
exists SortedList l: reach(this,
next).has(l) && l.elem == SENTINEL .
typeC) of class C, a production rule allows expression reach(e, f)
tohavetype C_SetExpr .Thus,expression reach(this, next) has
typeSortedList_SetExpr .
4.3 Grammar Fuzzer
The goal of the Grammar Fuzzer component is to produce can-
didate assertions. It uses a standard generative grammar-based
fuzzertoachievethisgoal[ 25,50].Thiscomponentproducesderiva-
tions ofùê∫ùëê‚Äîi.e., strings in L(ùê∫ùëê)‚Äîto obtain assertions for ùê∂.I tbe -
gins with the start symbol /angbracketleftFuzzedSpec /angbracketrightand keeps expanding non-
terminal symbols until no more non-terminals are present. Eachnon-terminal symbol is expanded based on a non-deterministic
choiceand,toavoidexpansionsleadingtoinfinitederivationpaths,alimitof5onthenumberofnon-terminalsisdefined.Furthermore,
to avoid getting stuck in a situation where the number of symbols
cannotbereducedanyfurther,thetotalnumberofexpansionsteps
is also limited to 100. The rationale for this choice is that com-
plex class assertions can be created by combining small assertions,
ratherthan longerones.Figure 6showsthederivation treeofthe
property used in our illustrative example: exists SortedList l:
reach(this, next).has(l) && l.elem == SENTINEL .
Byusingthisderivationmechanism,our GrammarFuzzer pro-
ducescandidatepredicatesveryefficiently.Inallofourexperiments
we generated up to 2,000 different candidates every time we ex-
ecuted SpecFuzzer. Furthermore, as the grammar ùê∫ùê∂has been
specifically extracted for a class ùê∂, all the specifications generated
bythefuzzerareguaranteedtoexpresspropertiesover ùê∂.Weimple-
mentedourfuzzerinJava,reproducingageneralgrammar-based
fuzzer written in Python [50].
4.4 Dynamic Invariant Detector
Thegoalofthe DynamicInvariantDetector istoevaluatetheplausi-
bilityofthecandidateassertionsproducedbythefuzzer.AsFigure4
shows,thedynamicinvariantdetectortakesasinputatestsuite,produced by the test generator, and a set of assertions, produced
bythefuzzer.Thiscomponentinstrumentstheprogramwiththe
assertionsgeneratedbythefuzzerandrunstheteststoverifywhich
assertionsholdacrossallexecutions.Theresultingassertionsare
reported as likely invariants.
1013
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:20:26 UTC from IEEE Xplore.  Restrictions apply. Fuzzing Class Specifications ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA
ThedynamicinvariantdetectorisbuiltontopofDaikon,3astate-
of-the-art toolfor likely invariantdetection [18]. We usedDaikon
as follows. We configured Daikon to include the assertions we
provided‚Äîi.e.,theexpressionsproducedbythefuzzer‚Äîintheinitial
pool of candidate assertions it uses. For that, we used a mechanism
provided by Daikon to incorporate new constraints.4Furthermore,
we included, along with the new constraints, a component that
allows the tool to interpret and evaluate the assertions at run-time.
4.5 Invariant Selector
The goal of the Invariant Selector is to partition the assertions that
were deemed valid by the dynamic invariant detector, grouping
together similar assertions, and taking a single representative from
each partition. At the same time, this component discards asser-
tionsthat,althoughwereconfirmedbytheinvariantdetector,are
consideredweakandthuslessrelevant.Thiscomponenttakesas
inputthesetoflikelyinvariantsobtainedfromthepreviousstep,
andthesetofmutantsoftheinputclass C(obtainedfromamutation
tool). This component reports a subset of the likely assertions it re-ceives as input, ranking the invariants by the number of failures in
corresponding code assertions. The Invariant Selector reduces the
numberofreportedassertions.Tosumup,thiscomponentdiscards
an assertion because of one of two reasons:
(1)theassertionisconsidered weak,andnottocapturerelevant
properties of the target class;
(2)theassertionis(semantically) similartoanotherproduced
assertion.
Inthefollowing,wedescribehowweapproximatethedetection
of weak and equivalent specifications via mutation analysis.
4.5.1 Detecting weak specifications with Mutation Analysis. Recall
thatthefuzzerreportsthousandsofconstraintsandthedynamic
invariant detector (in our case, Daikon) can only discard specifica-
tions invalidated by the tests. Several constraints can still ‚Äúsurvive‚Äù
the filtering process described on Section 4.4. Even with bettertest suites some assertions would still "survive" that process. Forexample a tautology, such as
x> =y| |x< =y , wouldnotbe in-
validated by Daikon as it is a valid proposition, but it is unlikely to
be useful. Being syntactically driven, the fuzzer can produce valid
assertions that do not provide any interesting information. The
assumptionisthatitalsogeneratesinterestingones.SpecFuzzer
usesmutationanalysistodiscarduninterestingassertions.Theideais
the following: if a likely invariant ‚Äìan assertion that is not falsified
by the test suite of C‚Äì cannot be falsified by any mutant of C, then
itisapropertythatnotonlyholdson C,butalsoonallsynthetic
buggy versions of C. We will then consider it a weakassertion,
and discard it as being irrelevant. This approach of using mutation
analysistoinducemoreeffective(stronger)oracleshasbeenused
inpriorwork,notablybyFraserandZeller [20],aswellasinrecent
work on oracle improvement [ 47] and specification inference [ 38].
4.5.2 Clustering similar specifications with Mutation Analysis. It
ispossiblethatSpecFuzzerproducessyntacticallydifferentasser-
tions that are semantically equivalent (or similar with respect to
3http://plse.cs.washington.edu/daikon/
4http://plse.cs.washington.edu/daikon/download/doc/developer.html#New-
invariants24%72.4%
3.6%Irrelevant
Equivalent
Reported
Figure7:Breakdownofreasonsfordiscardingspecificationson
SortedList.insert . Only 3.6% of the specifications that
‚Äúsurvive‚Äù the invariant detection stage are reported.
a distance metric). SpecFuzzer tries to identify and removesuch
assertions.Asanexample,considerthefollowingassertionsthat
are produced by SpecFuzzer on our SortedList example:
all SortedList l: reach(this, next).has(l) ==>
l.elem <= l.next.elem
all SortedList l: !(reach(this, next).has(l) &&
l.elem > l.next.elem)
Both these assertions express the sortedness property on lists. The
equivalenceoftheseassertionsfollowsfromDeMorgan‚Äôslaws[ 40],
algebraic properties of integers, and the equivalence of boolean
connectives.Toidentifyequivalentassertionsandassertionsthat
aresimilarwithrespecttotheirabilitytocapturesyntheticfaults,
SpecFuzzeragainusesmutationanalysis.Twoassertionswillbe
considered similar if they kill the same set of mutants, i.e., if theare falsified on the same set of program faults. For example, the
two assertions above kill the same set of 2 mutants, together with
74otherassertions.SpecFuzzerusesthismutation-basednotion
of assertion equivalence to partition the set of likely assertions
accordingtothemutantstheykill.Moreover,fromeachpartition,
SpecFuzzerselectsarepresentativeassertion.Todoso,itproceeds
with the following heuristic: the assertions in each partition are
ranked by the number of times they fail when running the testsuite on the mutants (while they all kill the same mutants, someassertions may fail a greater number of times, i.e., for more tests
in the test suite). The rationale is that assertions that fail the most
represent stronger properties, and thus they may subsume other
assertions in the partition. Considering the SortedList.insert ex-
ample,thismechanismenabledSpecFuzzertoreducethenumberofreportedspecificationsfrom437specificationsto16.Figure7shows
the breakdown of assertions classified as irrelevant (Section 4.5.1),
equivalent (Section 4.5.2), and reported, for the example.
Artifact.SpecFuzzer is publicly available for download [5].
5 EVALUATION
To evaluate SpecFuzzer, we performed a series of experiments
focused on the following research questions:
RQ1Isgrammar-basedfuzzingeffectiveatgeneratingrelevantas-
sertions?
1014
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:20:26 UTC from IEEE Xplore.  Restrictions apply. ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA F. Molina, M. d‚ÄôAmorim and N. Aguirre
RQ2Isthemutation-basedselectorsuccessfulforremovingredun-
dant/irrelevant assertions?
RQ3How does SpecFuzzer compare with alternative techniques?
RQ1 analyzes the effectiveness of using grammar-based fuzzing
asatechniquetogeneratecandidateassertions,withrespecttoa
groundtruth.RQ2evaluatesthesuitabilityofthemutation-based
assertionselectioncomponentof SpecFuzzer,atdiscardingweak
assertions,andprioritizingthemostrelevant.Finally,RQ3compares
theeffectivenessof SpecFuzzerwiththestate-of-the-arttechniques
GAssert [47] and EvoSpex [38].
5.1 Evaluation Subjects
Theperformanceevaluationinpreviousworkusedindirectmetrics
to compute precision and recall [ 38,47]. In this paper, we compute
thesemeasuresdirectly,whichrequireshavingagroundtruthfor
comparison, for each evaluation subject. We took all the 34 Java
methodsthatwerepartoftheevaluationofGAssert[ 47],andall23
methodsinthecontractreproducibilityevaluationofEvoSpex[ 38],
obtainingadatasetcomposedof57subjectmethods.Westudied
eachmethod,andmanuallyproducedcorresponding‚Äúgroundtruth‚Äù
assertions capturing the intended behavior of the corresponding
method.Wemadeourbestefforttobefairintheconstructionof
thisgroundtruth,bothincapturingasmuchofthegroundtruth
as possible, and in how the ground truth is modularized as a set of
properties(eachgroundtruthspecificationisexpressedasacon-
junctionofassertions).Theywereallcross-checkedbyauthors,and
when possible, their validity was verified using SMT (via Microsoft
IntelliTest). With this process, we obtained a total of 80 groundtruthassertions,forthe57methods.Eachobtainedgroundtruth
specificationhasbetween1and3conjuncts.Thedetailsaboutthese
assertions can be found in our replication package.
Notice that, since previous work focuses only on inferring post-
conditions,ourevaluationalsofocusesontheseprogrampoints,al-thoughSpecFuzzercaninferassertionsforvariousprogrampoints.
After obtaining the ground truth composed of 80 assertions, we
carefullyexaminedeachgroundtruthassertion,todetermineifit
can be expressed in the assertion language of at least one of the
evaluatedtools.Since15ofthe80assertionswerenotsupportedbyanyofthesetools,wediscardedthem
5.Afterthat,wealsoremoved
methods that ended up without ground truth postconditions. This
results in 65 postcondition assertions, for 43 Java methods.
Each assertion within the 65 in the ground truth could be ex-
pressed in the assertion language of at least one tool. GAssert‚Äôs
language can express 28 of the 65; EvoSpex‚Äôs language can express
29ofthe65;andSpecFuzzercanexpress41ofthe65.Althoughourgrammarsupportsall65assertions,whenimplementingsupportfor
the grammar into Daikon‚Äôs assertion template instantiation, some
expressions are ignored by Daikon‚Äôs infrastructure (e.g., expres-
sions that require instantiating templates with objects of different
classes).Thereisnofundamentalreasonwhytheseissuescannot
be resolved,but they demandsubstantial modificationsin Daikon.
5Discarded assertions include complex trigonometric properties, vector cross product
constraints, assertions involving characters and strings, and conversions between
characters and hexadecimal encodings.Table 3: Inferring assertions with grammar-based fuzzing.
Ground-truth #Reported #Detected %Detected
65 20,277 40 61.5
41 15,555 40 97.5
5.2 Experimental Setup
SpecFuzzerrequiresatestsuitefortheclassunderanalysis,and
asetofmutantsforthisclass.Thetestsuitewasgeneratedusing
Randoop [ 41], and the tool was instructed to generate a maximum
of 500 test sequences. Mutants were generated using Major [ 27],
with all supported mutation operators enabled. The fuzzer was run
until 2,000 different candidate assertions were generated (syntactic
duplicates were removed), for each subject class.
Regarding GAssert and EvoSpex, we followed the same method-
ology described in the corresponding papers [ 38,47], using exactly
the same configuration parametersfor the evolutionary processes
ofeachtechnique.Moreover,toaccountfortherandomnessofeachapproach, for each of the 43 Java methods, we ran each of the tools
toinferpostconditionsatotalof10times.Alltheresultsreported
in this section correspond to the averages of the executions.
We seta timeout of 90minutes, for each executionof each tool.
AlltoolswererunonanIntelCorei73.2Ghz,with16GbofRAM,
running GNU/Linux (Ubuntu 18.04). The detailed description of
how to reproduce the experiments in this paper is available in the
replication package site.
5.3 Effectiveness of Grammar-based Fuzzing
The effectiveness of grammar-based fuzzing in producing relevant
assertions is measuredagainst assertions in theground truth. The
experiment for RQ1 consisted in running SpecFuzzer on each sub-
ject, and analyzing the percentage of those assertions that the tool
wasabletoinfer.Recallthattheinvariantselectorusesa(mutation-
based) heuristic to discard assertions. As such, it may wrongly
discard relevant assertions. For that reason, to answer RQ1, we ran
SpecFuzzer with the invariant selector disabled.
We manually inspected the output of SpecFuzzer. More pre-
cisely, we manually analyzed the assertions that SpecFuzzer re-
portsto verifyif theywere presentin theground truth(and ifthe
groundtruthassertionswerepresentintheoutputaswell).Insome
cases, it was difficult to determine if a given assertion was equiva-
lent to a certain assertion in the ground truth. When the obtained
expressions allowed for it, we used an SMT solver via Microsoft
IntelliTesttocheckexpressionequivalence.Moreprecisely,wepro-
duced C# programs whose branch conditions captured implication
andequivalencebetweenoutputcandidateassertionsandground
truth assertions, and used the dynamic symbolic execution tool
IntelliTest to check whether such expressions could be falsified.
Table3summarizesthe resultsof theexperimentsforRQ1,with
respecttotheoverallgroundtruth(65assertions)andthesubset
ofthegroundtruththatisactuallysupportedbySpecFuzzer(as
we explained before, 41 out of the 65 are currently supported by
our implementation). We report the number of reported assertions,
the number of ground truth assertions detected by the tool, and
the percentage of ground truth assertions that were detected. If we
consider thelanguage supported byour implementation, ourtool
1015
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:20:26 UTC from IEEE Xplore.  Restrictions apply. Fuzzing Class Specifications ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA
Table 4: Performance of the Invariant Selector reducing as-
sertions.
Subject #G#Reported Detected(%)Red. (%)Before After Before After
oasis.SimpleMethods 4 115 31 75 75 73
daikon.StackAr 8 2067 70 87.5 62.5 96.6daikon.QueueAr 8 4699 152 50 50 96.7math.ArithmeticUtils 1 4 2 100 100 50math.FastMath 2 60 31 100 100 48.3math.MathUtils 1 19 4 0 0 78.9lang.BooleanUtils 5 49 12 100 100 75.5guava.IntMath 1 314 46 0 0 85.3tsuite.Angle 2 3 0 50 0 100
tsuite.MathUtil 3 22 13 33.3 33. 3 40.9tsuite.Envelope 1 1094 27 0 0 97.5
eiffel.Composite 4 8696 42 75 0 99.5eiffel.DLLN 3 137 29 100 100 78.8
eiffel.Map 6 140 22 16.6 16.6 84.2
eiffel.RingBuffer 5 1947 269 20 20 86.1cozy.Polyupdate 3 382 119 66.6 66.6 68.8cozy.Structure 2 153 21 100 100 86.2cozy.ListComp02 2 62 5 0 0 91.9cozy.MinFinder 1 17 2 100 100 88.2cozy.MaxBag 3 297 78 100 100 73.7
TOTAL 65 20277 975 61.5 52.3 95.1
41 15555 618 97.5 82.9 96
correctly detects 97.5% of the assertions in the ground truth; if we
considerthelanguagesupportedbyatleastoneofthespecification
inference tools, SpecFuzzer correctly detects 61.5%of the ground
truthassertions.Theseresultsconfirmthatgrammar-basedfuzzing
is effective in generating relevant assertions (as shown later on,
evenwhenconsideringthe65assertionsinthegroundtruth,the
performance of fuzzing is comparable with state-of-the-art tools).
5.4 Performance of Invariant Selection
The invariant selector component of SpecFuzzer implements a
mutation-based heuristics to reduce the number of reported as-
sertions,discarding‚Äúweak‚Äùassertions(assertionsthatsurviveall
mutants), and selecting representatives among ‚Äúsimilar‚Äù assertions
(assertionsthatkillthesamemutants).RQ2evaluatestheperfor-
mance of this stage. The experiment in this case compares the
assertions obtained after invariant detection, with the assertions
that are preserved after running the invariant selection. The com-
parison measures assertion reduction, and the percentage of the
ground truth that is covered prior and after assertion selection.
Table 4 shows these results for all subjects, grouped by class
name. In each case we report assertions in the ground truth, re-
ported assertions before and after invariant selection, and percent-
age of the ground truth that is covered, again, before and after
invariant selection. Finally, we indicate the reduction rate obtained
byinvariantselection(numberofassertionsafterselection,with
respect to the number of assertions before selection).
The invariant selection results show that the mutation-based
heuristicsinSpecFuzzereffectivelyreducesthenumberofreported
assertions, with a relatively small loss in property detection (with
respecttothegroundtruth).Moreprecisely,thereportedassertionsarereducedby
‚àº95%,and6outofthe40correctlyfuzzedassertions
arediscarded (covering ‚àº52%of thegroundtruth of65 assertions,
‚àº83% of the 41 ground truth assertions that the tool supports).Table5:ValidassertionsdiscardedbytheInvariantSelector.
Subject Assertion
StackAr.pop theArray[old(top)] == null
StackAr.topAndPop theArray[old(top)] == null
Angle.getTurn abs(res) <= 1
Composite.addChild c.value == old(c.value))
children == old(children)ancestors == old(ancestors)
Tounderstandthereasonswhywemiss6groundtruthassertions
duringinvariantselection,weanalyzedhowtheseassertionsare
classified by the detector. In all cases, the assertions are deemed as
irrelevant,i.e.,theyarenotkilledbyanymutant.Whiletheproblem
may be a weak test suite, it becomes clear, when observing the
assertions, that there is no mutation operator able to kill theseassertions (the assertions are shown in Table 5). The problem is
not specificto Major (themutation tool that weused); other tools
such as PIT do not have mutants able to kill these assertions either.
Letus providetwo concreteexamples. Assertion abs(res) <= 1 for
Angle.getTurn correspondstoamethodwhose resultiseither0,
-1or1;nomutantmakesthismethodreturnavalueotherthanthese.
In the Composite.addChild subject, assertion c.value == old(c.value)
wouldbeviolatedifamutantchangedthevalueof c,aparameterof
the method; a mutation operator achieving this effect would have
to add a new sentence.
Theseobservationssuggestthatwemayimprovetheeffective-
ness of our heuristics by extending Major with support for addi-
tional mutation operators, specific to our purposes.
5.5 Comparison of GAssert, EvoSpex and
SpecFuzzer
RQ3 compares SpecFuzzer with the state-of-the-art tools GAssert
andEvoSpex.Thecomparisonisbasedonstandardperformance
metrics: precision, recall and f1-score. These metrics are computed
withrespecttothegroundtruththatweproducedfortheevaluation
subjects, as follows. Given a set ùê∫of ground truth formulas, the
precisionofaset ùê¥ofassertionsproducedbyatooliscomputed
by determining the number of assertions in ùê¥that are implied
byùê∫. Many assertions were trivially incorrect (not implied by the
groundtruth),andweremanuallyidentified.Inmorecomplexcases,
(in)correctness was determined using IntelliTest. Once the set ùêºof
incorrect assertions in ùê¥was determined, precision is computed
with the formula (#ùê¥‚àí#ùêº)/#ùê¥. To compute recall, we check the
number of formulas in ùê∫that are implied by (ùê¥‚àíùêº). Again, while
some cases were trivial to check manually, for instance, when a
ground truth formula was directly present in ùê¥‚àíùêº, more complex
ones were confirmed using IntelliTest. Recall is then computed by
the formula # ùëÅ/#ùê∫, whereùëÅis the set of ground truth properties
implied by ùê¥‚àíùêº.
Toolswereruntoinferassertionsasdescribedearlierinthissec-
tion, and the results are shown in Table 6, grouped by subject class.Columns#Mand#Gshowthenumberofmethodsinthesubjectandthenumberofassertionsinthegroundtruth,respectively.Foreachtechniqueweshowthenumberofinferredassertions,theprecision
and recall with respect to the ground truth, and the f1-score. We
1016
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:20:26 UTC from IEEE Xplore.  Restrictions apply. ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA F. Molina, M. d‚ÄôAmorim and N. Aguirre
Table 6: Precision, Recall and F1-Score of GAssert, EvoSpex and SpecFuzzer on the data set.
Subject #M #G#Inferred Precision(%) Recall(%) F1-Score
GAssert EvoSpex SpecFuzzer GAssert EvoSpex SpecFuzzer GAssert EvoSpex SpecFuzzer GAssert EvoSpex SpecFuzzer
oasis.SimpleMethods 4 4 7 4 31 100 75 100 50 25 75 0.66 0.37 0.85
daikon.StackAr 5 8 5 6 70 100 83.3 87.1 37.5 37.5 62.5 0.54 0.51 0.72daikon.QueueAr 5 8 8 12 152 100 91.6 61.1 37.5 25 50 0.54 0.39 0.54math.ArithmeticUtils 1 1 1 0 2 100 100 50 100 0 100 1 0 0.66math.FastMath 1 2 3 1 31 100 0 61.2 100 0 100 1 0 0.75math.MathUtils 1 1 1 1 4 100 0 100 0 0 0 0 0 0lang.BooleanUtils 2 5 2 2 12 50 100 83.3 0 0 100 0 0 0.9guava.IntMath 1 1 3 3 46 100 66.6 97.8 100 0 0 1 0 0tsuite.Angle 1 2 3 1 0 100 100 100 0 0 0 0 0 0
tsuite.MathUtil 1 3 3 1 13 100 100 84.6 33.3 0 33.3 0.49 0 0.47tsuite.Envelope 1 1 3 4 27 100 100 18.5 0 0 0 0 0 0
eiffel.Composite 1 4 0 7 42 100 100 50 0 50 0 0 0.66 0eiffel.DLLN 2 3 0 4 29 100 100 89.6 0 66.6 100 0 0.79 0.94
eiffel.Map 3 6 4 10 22 50 100 81.8 16.6 66.6 16.6 0.24 0.79 0.27
eiffel.RingBuffer 5 5 9 31 269 88.8 87 64.6 20 40 20 0.32 0.54 0.3cozy.Polyupdate 2 3 3 3 119 66.6 100 1.6 33.3 66.6 66.6 0.44 0.79 0.03cozy.Structure 2 2 2 2 21 100 100 95.2 100 100 100 1 1 0.97cozy.ListComp02 2 2 0 4 5 100 100 83.3 0 100 0 0 1 0cozy.MinFinder 1 1 0 2 2 100 100 100 0 100 100 0 1 1cozy.MaxBag 3 3 8 33 78 100 84.8 94.8 0 66.6 100 0 0.74 0.97
Total-65 43 65 65 131 975 92.3 88.5 65.8 27.6 38.4 52.3 0.42 0.53 0.57
Total-SpecFuzzer 30 41 43 76 618 95.3 88 62.4 41.4 43.9 82.9 0.57 0.58 0.71Total-GAssert 23 28 39 54 615 94.8 85.1 63.4 64.2 46.4 71.4 0.76 0.60 0.67Total-EvoSpex 24 29 34 82 624 91.1 92.8 59.9 44.8 86.2 72.4 0.60 0.89 0.65
summarizetheperformancemetricsfortheoverallgroundtruth
of 65 assertions, as well as in the context of assertions that are
supportedbyeachparticulartool(recallthatGAssertsupportsin
its language 28 of the 65, EvoSpex 29 of the 65, and SpecFuzzer 41
of the 65). That is, rows Total-SpecFuzzer, Total-GAssert and Total-
EvoSpexshowtheperformanceofthetechniquesontheportionof
thegroundtruththat SpecFuzzer,GAssertandEvoSpex support,
respectively.
Inferred Assertions. Ifwefocusonthenumberofinferredassertions,
GAssert and EvoSpex report fewer assertions than SpecFuzzer.
Thisisanadvantageoftheprevioustechniques,sincetheproduced
output is easier to interpret. The main reason here is that both
techniques feature evolutionary processes, that aim at minimizing
the size of the assertions (this is an objective of both evolution
processes). SpecFuzzer is in this respect a simpler technique. Still,
the invariant selector component allows our tool to report a rea-sonable number of assertions (22 per method, on average). Thisnumber is still large, and calls for future work to further reduce
thenumberofassertionsthatSpecFuzzerreports.Apossibleap-
proachistoexploitthemutationkillinginformationtoidentifysub-
sumption/implicationrelationsacrossassertions,sothatonlythe
stronger assertions are reported. More precisely, a mutation-based
notionofimplication wouldconsiderthatan assertion ùõº1implies
anotherùõº2ifthesetofmutantskilledby ùõº1includesthosekilled
byùõº2. It is important to notice that as our assertion equivalence
definition and mutation-based identification of weak assertions areapproximate,soourcurrentassertionreductionmechanismalreadyaffectsrecall(Table4showssomeconcreteexamples).Moreaggres-
sivereductionmechanisms,suchastheabovedescribedbasedon
subsumption/implication, may affect recalleven further. A way of
reducingreportedassertionswithoutcompromisingrecallwould
require precise equivalence/implication checking across assertions
(e.g., using SAT or SMT). Although this is a viable option, it may
considerably affect both efficiency and scalability, and thus the
generality of the technique.
Precision. Precision is the aspect in which GAssert and EvoSpex
outperformSpecFuzzer.Again,thishastodowiththefactthatboth
GAssertandEvoSpexincorporatemechanismstoactivelyreduce
the number of false positives (understood as invalid properties).In particular, GAssert iteratively improves assertions using OA-
SIs [26], launching EvoSuite instances to search and detect defects
in the candidate assertions. EvoSpex uses a bounded-exhaustive
testgenerationtechniquewiththeaimofbuildingamorethorough
test suite, able to discard more false positives. Both techniques
have disadvantagesassociated with theseprocesses. GAssert pays
apriceinefficiency(itisthemostcostlyofthethree);EvoSpex‚Äôs
boundedexhaustivetestgenerationhasscalabilityissues(dueto
its bounded exhaustive test generation, it has difficulties scaling to
larger subjects).
SpecFuzzerborrowsfromDaikonthemechanismtodealwith
precision. This issue can be dealt with by improving test suite
quality. We used Randoop in our experiments, which may be com-
plemented by additional automated test generation techniques.
Recall.RecallistheaspectwhereSpecFuzzeroutperformsGAssert
and EvoSpex. This is the case for the overall ground truth, and for
1017
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:20:26 UTC from IEEE Xplore.  Restrictions apply. Fuzzing Class Specifications ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA
mosttool-specificgroundtruthsubsets.EvoSpexhasbetterrecall
thanSpecFuzzerforitsspecificlanguage;itinfers5assertionsthat
SpecFuzzercannot.Outofthese5,2assertionsarediscardedbytheinvariant selector (we described the reasons above). The remainingthreearesupportedbythegrammar,butDaikoniscurrentlyunable
toinstantiatetheseassertions(wealsodescribedthisissueearlier
inthepaper);thatis,thesethreeassertionsarenotpartofthe41
that our prototype currently supports.
Therecallimprovementof SpecFuzzerovertheothertechniques
makes our tool more effective overall, as summarized by the f1-
scores.NoticethatSpecFuzzerhasabetterf1-scorecomparedwith
previous techniques, for the overall ground truth, i.e., even taking
intoaccountitsprecisionlimitations,andthecurrentissueswith
support for assertions.
5.6 Threats to Validity
Ourexperimentalevaluationwasperformedonadatasetbuiltwith
subjects from previous works. We needed to manually study these
subjects in order to define the ground truth assertions. To mitigate
the risk of errors, we checked these assertions using Microsoft
IntelliTest (previously named Pex [48]).
Threatstointernalvaliditymayarisefromtherandomnessofthe
eachtechnique.Toaccountforthisissue,weevaluatedSpecFuzzer,
GAssertandEvoSpexover multiple runsoneachsubjectmethod,
and reported the averages. As further work, we plan to extend the
experimental evaluation to larger-scale Java projects, which will
likelyimplyabandoningthecomputationofperformancemetrics
overgroundtruths,duetotheeffortthatwouldinvolvestudying
larger projects and manually writing correct assertions.
6 RELATED WORK
Theuseofassertionsinprogramshasalongtradition.Originally,
assertionswereusedaspartofapproachesforsoftwareverification[
24], and soon were incorporated into programming languages, for
run-time checking [ 12]. Assertions are currently used for multiple
softwaredevelopmentactivities:programverification[ 11,17,19,21,
22,30],softwaredesign [ 36],bugfinding [ 30,31,41,48],program
comprehensionandmaintenance[ 45],programrepair[ 16,34,43,
44], among others.
Specification inference is an active area of research. Besides the
techniques that infer contract assertions, with which we have com-paredourtechniqueinthispaper[
38,47],otherrelatedapproaches
exist,inparticularforinferringtestoracles[ 20,49](thatis,asser-
tionsthatarevalidonlyforspecificunittests),andotherkindsof
specifications,suchasbehavioraldescriptions[ 14,28,29].These
techniques seek related but different objectives, and thus can com-
plement each other. In relation to test assertion inference, tools
andtechniques forinferring testassertionsproduce specificationsthat are difficultto generalize as contracts;contract specifications,
ontheotherhand,canbeinstantiatedastestassertions,butmay
captureweakerproperties,comparedtotheirtestassertioncoun-
terparts. Other related techniques attempt to produce assertions
fromothersources,suchascomments[ 9],orweakerformsofspec-
ifications, notably metamorphic relations [ 10]. Other related forms
of specification inference focus on different properties, e.g., behav-
ioral properties in linear-time temporal logic [ 32], or propertiesthatdescribethetemporalrelationshipsbetweendifferentmethods
in an API [ 15]. As described in [ 32], these techniques that infer
behavioral properties can be complemented by Daikon [ 18] (the
dynamic invariant detection technique that our work is based on),
and therefore they can also profit from more expressive assertions.
Previous approaches have worked on improving Daikon‚Äôs effec-
tiveness. In particular, the work reported in [ 39] combines Daikon
withstaticverification,inawaythatcanbeunderstoodasanim-
provementtoprecision(staticverificationisemployedtoconfirm
assertion validity). Our approach, on the other hand, is largely mo-
tivatedbyautomaticallyequippingDaikonwithmoreexpressive
assertions, an issuenot tackled in [ 39]. We are not awareof other
approaches that automatically address the expressiveness limita-
tionsofDaikon.Fuzzing[ 50]isalsoaveryactivetopic,withknown
applications in security vulnerability discovery, and bug finding in
general.Tothebestofourknowledge,ourapproachisthefirstto
employ fuzzing to produce candidate formal specifications.
7 CONCLUSION AND FUTURE WORK
Formal class specifications have applications in various areas of
software development, including software design, bug finding, and
programcomprehension.Techniquestoautomaticallyinferclass
specificationshavebeenproposed,butarelimited,e.g.,theysupport
a limited number of assertion types and are inflexible to change.
To fill this gap, we presented SpecFuzzer, a technique to infer
likelyclassspecificationsthatcombinesstaticanalysis,grammar-
basedfuzzing,andmutationanalysis.Ourevaluationshowsthat
SpecFuzzerhassuperiorperformanceincomparisonwiththestate-
of-the-art tools GAssert and EvoSpex, especially considering recall.
Furthermore,theuseofgrammar-basedfuzzingenablesSpecFuzzer
to be easily adapted to different assertion languages.
Thispaperalsoopensvariouslinesforimprovement,aswehave
identifiedsomeconcretelimitationsofourapproach.Themutation-basedmechanismstoclusterequivalentassertionsanddiscardweak
assertionsareaffectedbytheabsenceofmutationoperators,that
would allow our tool to detect some specific constraints. Other
moresophisticatedmechanismstodealwithassertionsnotkilled
by any mutant may also be incorporated (e.g., constraint-basedtechniques). In general, the modular structure of our techniqueenables us to improve specific components, e.g., test generation
(to improve precision), fuzzing (to consider more effective/efficient
fuzzing techniques), etc. Finally, implementation limitations in the
dynamic detection phase constitute a bottleneck for SpecFuzzer‚Äôs
assertioninferencecapabilities,thatweplantoaddressinfuture
extensions of our tool.
ACKNOWLEDGEMENTS
This work is partially supported by INES (www.ines.org.br); CNPq
grant 465614/2014-0; CAPES grant 88887.136410/2017-00; FACEPE
grants APQ-0399-1.03/17 and PRONEX APQ/0388-1.03/14; and AN-PCyTgrantsPICT2017-2622andPICT2019-2050.FacundoMolina‚Äôs
work is also supported by Microsoft Research, through a Latin
America PhD Award.
Any opinions, findings, and conclusions or recommendations
expressedinthispublicationarethoseoftheauthors,anddonot
necessarily reflect the views of the sponsoring entities.
1018
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:20:26 UTC from IEEE Xplore.  Restrictions apply. ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA F. Molina, M. d‚ÄôAmorim and N. Aguirre
REFERENCES
[1]2021. Fuzzing Research Tools and their Relatedness. https://fuzzing-survey.org/
[2] 2021. Google‚Äôs AFL. https://github.com/google/AFL
[3] 2021. Google‚Äôs ClusterFuzz. https://github.com/google/clusterfuzz[4] 2021. Google‚Äôs OSS-Fuzz. https://github.com/google/oss-fuzz[5]
2022. SpecFuzzer implementation and replication package. https://sites.google.
com/view/specfuzzer
[6]Pablo Abad, Nazareno Aguirre, Valeria S. Bengolea, Daniel Alfredo Ciolek,
MarceloF.Frias, JuanP.Galeotti,Tom Maibaum,MarianoM.Moscato,Nicol√°s
Rosner,andIgnacioVissani.2013. ImprovingTestGenerationunderRichCon-
tracts by Tight Bounds and Incremental SAT Solving. In Sixth IEEE Interna-
tional Conference on Software Testing, Verification and Validation, ICST 2013,Luxembourg, Luxembourg, March 18-22, 2013. IEEE Computer Society, 21‚Äì30.
https://doi.org/10.1109/ICST.2013.46
[7]Paul Ammann and Jeff Offutt. 2008. Introduction to Software Testing. Cambridge
University Press. https://doi.org/10.1017/CBO9780511809163
[8]Earl T. Barr, Mark Harman, Phil McMinn, Muzammil Shahbaz, and Shin Yoo.
2015. TheOracleProbleminSoftwareTesting:ASurvey. IEEETrans.Software
Eng.41, 5 (2015), 507‚Äì525. https://doi.org/10.1109/TSE.2014.2372785
[9]AriannaBlasi,AlbertoGoffi,KonstantinKuznetsov,AlessandraGorla,MichaelD.
Ernst, Mauro Pezz√®, and Sergio Delgado Castellanos. 2018. Translating code
comments toprocedure specifications. In Proceedings ofthe 27th ACM SIGSOFT
InternationalSymposiumonSoftwareTestingandAnalysis,ISSTA2018,Amsterdam,TheNetherlands,July16-21,2018 ,FrankTipandEricBodden(Eds.).ACM,242‚Äì253.
https://doi.org/10.1145/3213846.3213872
[10]AriannaBlasi,AlessandraGorla,MichaelD.Ernst,MauroPezz√®,andAntonioCarzaniga. 2021. MeMo: Automatically identifying metamorphic relations in
Javadoc comments for test automation. J. Syst. Softw. 181 (2021), 111041. https:
//doi.org/10.1016/j.jss.2021.111041
[11]PatriceChalin,JosephR.Kiniry,GaryT.Leavens,andErikPoll.2005. Beyond
Assertions: Advanced Specification and Verification with JML and ESC/Java2. In
Formal Methods for Components and Objects, 4th International Symposium, FMCO
2005, Amsterdam, The Netherlands, November 1-4, 2005, Revised Lectures. 342‚Äì363.
https://doi.org/10.1007/11804192_16
[12]LoriA.ClarkeandDavidS.Rosenblum.2006. Ahistoricalperspectiveonruntime
assertion checking in software development. ACM SIGSOFT Softw. Eng. Notes 31,
3 (2006), 25‚Äì37. https://doi.org/10.1145/1127878.1127900
[13]Marcelo d‚ÄôAmorim, Carlos Pacheco, Tao Xie, Darko Marinov, and Michael D.
Ernst. 2006. An Empirical Comparison of Automated Generation and Classifica-
tionTechniquesforObject-OrientedUnitTesting.In 21stIEEE/ACMInternational
Conference on Automated Software Engineering (ASE 2006), 18-22 September 2006,
Tokyo,Japan.IEEEComputerSociety,59‚Äì68. https://doi.org/10.1109/ASE.2006.13
[14]Guido de Caso, V√≠ctor A. Braberman, Diego Garbervetsky, and Sebasti√°n Uchitel.
2013. Enabledness-based program abstractions for behavior validation. ACM
Trans. Softw. Eng. Methodol. 22, 3 (2013), 25:1‚Äì25:46. https://doi.org/10.1145/
2491509.2491519
[15]Guido de Caso, V√≠ctor A. Braberman, Diego Garbervetsky, and Sebasti√°n Uchitel.
2013. Enabledness-based program abstractions for behavior validation. ACM
Trans. Softw. Eng. Methodol. 22, 3 (2013), 25:1‚Äì25:46. https://doi.org/10.1145/
2491509.2491519
[16]Brian Demsky, Michael D. Ernst, Philip J. Guo, Stephen McCamant, Jeff H.Perkins, and Martin Rinard. 2006. Inference and Enforcement of Data Struc-ture Consistency Specifications. In Proceedings of the 2006 International Sym-
posium on Software Testing and Analysis (Portland, Maine, USA) (ISSTA ‚Äô06).
Association for Computing Machinery, New York, NY, USA, 233‚Äì244. https:
//doi.org/10.1145/1146238.1146266
[17]Greg Dennis, Felix Sheng-Ho Chang, and Daniel Jackson. 2006. Modular
verification of code with SAT. In Proceedings of the ACM/SIGSOFT Interna-
tionalSymposium onSoftware Testingand Analysis,ISSTA 2006,Portland,Maine,
USA, July 17-20, 2006, Lori L. Pollock and Mauro Pezz√® (Eds.). ACM, 109‚Äì120.
https://doi.org/10.1145/1146238.1146251
[18]Michael D. Ernst, Jeff H. Perkins, Philip J. Guo, Stephen McCamant, CarlosPacheco, Matthew S. Tschantz, and Chen Xiao. 2007. The Daikon system for
dynamicdetectionoflikelyinvariants. Sci.Comput.Program. 69,1-3(2007),35‚Äì45.
https://doi.org/10.1016/j.scico.2007.01.015
[19]ManuelF√§hndrich.2010. StaticVerificationforCodeContracts.In StaticAnalysis
- 17th International Symposium, SAS 2010, Perpignan, France, September 14-16,
2010. Proceedings. 2‚Äì5. https://doi.org/10.1007/978-3-642-15769-1_2
[20]Gordon Fraser and Andreas Zeller. 2010. Mutation-driven generation of unit
tests and oracles. In ISSTA. ACM, 147‚Äì158.
[21]CarloA.Furia,MartinNordio,NadiaPolikarpova,andJulianTschannen.2017.
AutoProof:auto-activefunctionalverificationofobject-orientedprograms. Int.J.
Softw.ToolsTechnol.Transf. 19,6(2017),697‚Äì716. https://doi.org/10.1007/s10009-
016-0419-0
[22]Juan P. Galeotti, Nicol√°s Rosner, Carlos L√≥pez Pombo, and Marcelo F. Frias. 2010.
Analysis of invariants for efficient bounded verification. In Proceedings of the
Nineteenth International Symposium on Software Testing and Analysis, ISSTA 2010,Trento, Italy, July 12-16, 2010, Paolo Tonella and Alessandro Orso (Eds.). ACM,
25‚Äì36. https://doi.org/10.1145/1831708.1831712
[23]CarloGhezzi,MehdiJazayeri,andDinoMandrioli.2002. FundamentalsofSoftware
Engineering (2nd ed.). Prentice Hall PTR, Upper Saddle River, NJ, USA.
[24]C.A.R.Hoare.2003. Assertions:APersonalPerspective. IEEEAnn.Hist.Comput.
25, 2 (2003), 14‚Äì25. https://doi.org/10.1109/MAHC.2003.1203056
[25]Ren√°ta Hodov√°n, √Åkos Kiss, and Tibor Gyim√≥thy. 2018. Grammarinator: AGrammar-Based Open Source Fuzzer. In Proceedings of the 9th ACM SIGSOFT
InternationalWorkshoponAutomatingTESTCaseDesign,Selection,andEvaluation
(LakeBuenaVista,FL,USA) (A-TEST2018).AssociationforComputingMachinery,
New York, NY, USA, 45‚Äì48. https://doi.org/10.1145/3278186.3278193
[26]GunelJahangirova,DavidClark,MarkHarman,andPaoloTonella.2016. Testoracle assessment and improvement. In Proceedings of the 25th International
Symposium on Software Testing and Analysis, ISSTA 2016, Saarbr√ºcken, Germany,
July 18-20, 2016, Andreas Zeller and Abhik Roychoudhury (Eds.). ACM, 247‚Äì258.
https://doi.org/10.1145/2931037.2931062
[27]Ren√©Just,FranzSchweiggert,andGregoryM.Kapfhammer.2011. MAJOR:An
efficient and extensible tool for mutation analysis in a Java compiler. In 26th
IEEE/ACMInternationalConferenceonAutomatedSoftwareEngineering(ASE2011),
Lawrence,KS,USA,November6-10,2011,PerryAlexander,CorinaS.Pasareanu,
and John G. Hosking (Eds.). IEEE Computer Society, 612‚Äì615. https://doi.org/10.
1109/ASE.2011.6100138
[28]HongJinKangandDavidLo.2021. AdversarialSpecificationMining. ACMTrans.
Softw. Eng. Methodol. 30, 2 (2021), 16:1‚Äì16:40. https://doi.org/10.1145/3424307
[29]Tien-Duy B. Le and David Lo. 2018. Deep specification mining. In Proceedings of
the27thACMSIGSOFTInternationalSymposiumonSoftwareTestingandAnalysis,
ISSTA 2018, Amsterdam, The Netherlands, July 16-21, 2018, Frank Tip and Eric
Bodden (Eds.). ACM, 106‚Äì117. https://doi.org/10.1145/3213846.3213876
[30]GaryT.Leavens,YoonsikCheon,CurtisClifton,ClydeRuby,andDavidR.Cok.
2005. HowthedesignofJMLaccommodatesbothruntimeassertioncheckingand formal verification. Sci. Comput. Program. 55, 1-3 (2005), 185‚Äì208. https:
//doi.org/10.1016/j.scico.2004.05.015
[31]Andreas Leitner, Ilinca Ciupa, Manuel Oriol, Bertrand Meyer, and Arno Fiva.2007. Contract driven development = test driven development - writing test
cases.InProceedingsofthe6thjointmeetingoftheEuropeanSoftwareEngineering
Conference and the ACM SIGSOFT International Symposium on Foundations of
SoftwareEngineering,2007,Dubrovnik,Croatia,September3-7,2007,IvicaCrnkovic
andAntoniaBertolino(Eds.).ACM,425‚Äì434. https://doi.org/10.1145/1287624.
1287685
[32]Caroline Lemieux, Dennis Park, and Ivan Beschastnikh. 2015. General LTL
SpecificationMining(T).In 30thIEEE/ACMInternationalConferenceonAutomated
SoftwareEngineering,ASE2015,Lincoln,NE,USA,November9-13,2015,MyraB.
Cohen,LarsGrunske,andMichaelWhalen(Eds.).IEEEComputerSociety,81‚Äì92.
https://doi.org/10.1109/ASE.2015.71
[33]Lisa (Ling) Liu, Bertrand Meyer, and Bernd Schoeller. 2007. Using Contracts and
BooleanQueries toImprovethe QualityofAutomatic TestGeneration.In Tests
and Proofs - 1st International Conference, TAP 2007, Zurich, Switzerland, February
12-13, 2007. Revised Papers (Lecture Notes in Computer Science, Vol. 4454), Yuri
Gurevich and Bertrand Meyer (Eds.). Springer, 114‚Äì130. https://doi.org/10.1007/
978-3-540-73770-4_7
[34]Francesco Logozzo and Thomas Ball. 2012. Modular and verified automatic
programrepair.In Proceedingsofthe27thAnnualACMSIGPLANConferenceon
Object-Oriented Programming, Systems, Languages, and Applications, OOPSLA
2012, part of SPLASH 2012, Tucson, AZ, USA, October 21-25, 2012, Gary T. Leavens
and Matthew B. Dwyer (Eds.). ACM, 133‚Äì146. https://doi.org/10.1145/2384616.
2384626
[35]Valentin J. M. Man√®s, HyungSeok Han, Choongwoo Han, Sang Kil Cha, Manuel
Egele, Edward J. Schwartz, and Maverick Woo. 2021. The Art, Science, and
Engineering of Fuzzing: A Survey. IEEE Trans. Software Eng. 47, 11 (2021), 2312‚Äì
2331. https://doi.org/10.1109/TSE.2019.2946563
[36]Bertrand Meyer. 1997. Object-Oriented Software Construction, 2nd Edition.
Prentice-Hall.
[37]BartonP.Miller.2021. FuzzTestingofApplicationReliability. http://pages.cs.
wisc.edu/~bart/fuzz/
[38]Facundo Molina, Pablo Ponzio, Nazareno Aguirre, and Marcelo F. Frias. 2021.EvoSpex: An Evolutionary Algorithm for Learning Postconditions. In 43rd
IEEE/ACMInternationalConference onSoftwareEngineering,ICSE2021,Madrid,
Spain, 22-30 May 2021. IEEE, 1223‚Äì1235. https://doi.org/10.1109/ICSE43902.2021.
00112
[39]JeremyW.NimmerandMichaelD.Ernst.2002. Automaticgenerationofprogram
specifications. In Proceedings of the International Symposium on Software Testing
and Analysis, ISSTA 2002, Roma, Italy, July 22-24, 2002, Phyllis G. Frankl (Ed.).
ACM, 229‚Äì239. https://doi.org/10.1145/566172.566213
[40]P.S.Novikov.1964. ElementsofMathematicalLogic. Reading,Mass.,Addison-
Wesley Pub. Co.
[41]Carlos Pacheco, Shuvendu K. Lahiri, Michael D. Ernst, and Thomas Ball. 2007.
Feedback-Directed Random Test Generation. In 29th International Conference on
1019
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:20:26 UTC from IEEE Xplore.  Restrictions apply. Fuzzing Class Specifications ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA
SoftwareEngineering(ICSE2007),Minneapolis,MN,USA,May20-26,2007.IEEE
Computer Society, 75‚Äì84. https://doi.org/10.1109/ICSE.2007.37
[42]Mike Papadakis, Marinos Kintis, Jie Zhang, Yue Jia, Yves Le Traon, and Mark
Harman.2019. ChapterSix-MutationTestingAdvances:AnAnalysisandSurvey.
Adv. Comput. 112 (2019), 275‚Äì378. https://doi.org/10.1016/bs.adcom.2018.03.015
[43]Yu Pei, Carlo A. Furia, Martin Nordio, Yi Wei, Bertrand Meyer, and Andreas
Zeller.2014. AutomatedFixingofProgramswithContracts. IEEETrans.Software
Eng.40, 5 (2014), 427‚Äì449. https://doi.org/10.1109/TSE.2014.2312918
[44]Jeff H. Perkins, Sunghun Kim, Samuel Larsen, Saman P. Amarasinghe, Jonathan
Bachrach, Michael Carbin, Carlos Pacheco, Frank Sherwood, Stelios Sidiroglou,
Greg Sullivan, Weng-Fai Wong, Yoav Zibin, Michael D. Ernst, and Martin C.
Rinard. 2009. Automatically patching errors in deployed software. In Proceedings
of the 22nd ACM Symposium on Operating Systems Principles 2009, SOSP 2009, Big
Sky,Montana,USA,October11-14,2009,JeannaNeefeMatthewsandThomasE.
Anderson (Eds.). ACM, 87‚Äì102. https://doi.org/10.1145/1629575.1629585
[45]Manoranjan Satpathy, Nils T. Siebel, and Daniel Rodr√≠guez. 2004. Assertions
in Object Oriented Software Maintenance: Analysis and a Case Study. In 20th
InternationalConferenceonSoftwareMaintenance(ICSM2004),11-17September
2004,Chicago,IL,USA .IEEEComputerSociety,124‚Äì135. https://doi.org/10.1109/
ICSM.2004.1357797
[46]ToddW.Schiller,KellenDonohue,ForrestCoward,andMichaelD.Ernst.2014.
Case Studies and Tools for Contract Specifications. In Proceedings of the 36thInternational Conference on Software Engineering (Hyderabad, India) (ICSE 2014).
Association for Computing Machinery, New York, NY, USA, 596‚Äì607. https:
//doi.org/10.1145/2568225.2568285
[47]Valerio Terragni, Gunel Jahangirova, Paolo Tonella, and Mauro Pezz√®. 2020.
Evolutionary Improvement of Assertion Oracles. In Proceedings of the 28th ACM
JointMeetingonEuropeanSoftwareEngineeringConferenceandSymposiumon
the Foundations of Software Engineering (Virtual Event, USA) (ESEC/FSE 2020).
AssociationforComputingMachinery,NewYork,NY,USA,1178‚Äì1189. https:
//doi.org/10.1145/3368089.3409758
[48]NikolaiTillmannandJonathandeHalleux.2008. Pex-WhiteBoxTestGeneration
for .NET. In Tests and Proofs - 2nd International Conference, TAP 2008, Prato,
Italy,April9-11,2008.Proceedings (LectureNotesinComputerScience,Vol.4966) ,
Bernhard Beckert and Reiner H√§hnle (Eds.). Springer, 134‚Äì153. https://doi.org/
10.1007/978-3-540-79124-9_10
[49]Cody Watson, Michele Tufano, Kevin Moran, Gabriele Bavota, and Denys Poshy-
vanyk.2020. Onlearningmeaningfulassertstatementsforunittestcases.In ICSE
‚Äô20: 42nd International Conference on Software Engineering, Seoul, South Korea, 27
June-19July,2020,GreggRothermelandDoo-HwanBae(Eds.).ACM,1398‚Äì1409.
https://doi.org/10.1145/3377811.3380429
[50]AndreasZeller,RahulGopinath,MarcelB√∂hme,GordonFraser,andChristianHoller. 2019. The Fuzzing Book. In The Fuzzing Book. Saarland University.
https://www.fuzzingbook.org/ Retrieved 2019-09-09 16:42:54+02:00.
1020
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:20:26 UTC from IEEE Xplore.  Restrictions apply. 