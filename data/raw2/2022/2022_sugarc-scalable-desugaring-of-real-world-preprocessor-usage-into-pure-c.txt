2022 IEEE/ACM 44th International Conference on Software Engineering (ICSE) 
   
SugarC: Scalable Desugaring of Real-World Preprocessor Usage 
into Pure C 
Zachary Patterson 
The University of Texas at Dallas 
USA 
Zach.Patterson@utdallas.edu 
Shiyi Wei 
The University of Texas at Dallas 
USA 
swei@utdallas.edu 
ABSTRACT 
Variability-aware analysis is critical for ensuring the quality of con- 
figurable C software. An important step toward the development of 
variability-aware analysis at scale is to transform real-world C soft- 
ware that uses both C and preprocessor into pure C code, by replac- 
ing the preprocessor’s compile-time variability with C’s runtime- 
variability. In this work, we design and implement a desugaring 
tool, SugarC, that transforms away real-world preprocessor usage. 
SugarC augments C’s formal grammar specification with transla- 
tion rules, performs simultaneous type checking during desugar- 
ing, and introduces numerous optimizations to address challenges 
that appear in real-world preprocessor usage. The experiments on 
DesugarBench, a benchmark consisting of 108 manually-created 
programs, show that SugarC supports many more language fea- 
tures than two existing desugaring tools. When applied on three 
real-world configurable C software, SugarC desugared 774 out of 
813 files in the three programs, taking at most ten minutes in the 
worst case and less than two minutes for 95% of the C files. 
CCS CONCEPTS 
- Software and its engineering — Preprocessors; Source code 
generation; Software product lines. 
KEYWORDS 
C preprocessor, syntax-directed translation, desugaring 
ACM Reference Format: 
Zachary Patterson, Zenong Zhang, Brent Pappas, Shiyi Wei, and Paul Gazz- 
illo. 2022. SugarC: Scalable Desugaring of Real-World Preprocessor Usage 
into Pure C. In 44th International Conference on Software Engineering (ICSE 
°22), May 21-29, 2022, Pittsburgh, PA, USA. ACM, New York, NY, USA, 12 pages. 
https://doi.org/10.1145/3510003.3512763 
  
Permission to make digital or hard copies of all or part of this work for personal or 
classroom use is granted without fee provided that copies are not made or distributed 
for profit or commercial advantage and that copies bear this notice and the full cita- 
tion on the first page. Copyrights for components of this work owned by others than 
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re- 
publish, to post on servers or to redistribute to lists, requires prior specific permission 
and/or a fee. Request permissions from permissions@acm.org. 
ICSE ’22, May 21-29, 2022, Pittsburgh, PA, USA 
© 2022 Association for Computing Machinery. 
ACM ISBN 978-1-4503-9221-1/22/05...$15.00 
https://doi.org/10.1145/3510003.3512763 Zenong Zhang 
The University of Texas at Dallas 
USA 
zenong@utdallas.edu Brent Pappas 
University of Central Florida 
USA 
pappasbrent@Knights.ucf.edu 
Paul Gazzillo 
University of Central Florida 
USA 
paul.gazzillo@ucf.edu 
1 INTRODUCTION 
The preprocessor is widely used when developing real-world C pro- 
grams to enable flexible configuration and reuse of the software. Its 
extensive usage has significant impacts on the performance and re- 
liability of C software. Past studies have shown that bugs exist only 
under some configurations of the software (i.e., variability bugs) 
[1], and the preprocessor makes bug detection challenging since 
only one configuration can be tested at a time [34]. 
Most research on bug detection in configurable C software fo- 
cuses on a combinatorial testing approach [9, 14, 33, 47], which 
samples the large software configuration spaces, and then applies 
the testing and analysis techniques on each of the samples. How- 
ever, the sampling-based approach lacks the guarantee of program 
correctness under all configurations. This limitation makes a sound 
static analysis more desirable in many applications. 
Variability-aware analyses have been developed to detect pars- 
ing errors [16, 24], type errors [26], and run-time defects such as 
double free errors [42]. Viewing real-world C programs as being 
written in two languages (i.e., C and preprocessor), the variability- 
aware analyses analyze C software as a whole using data structures 
that represent the combined language. However, the development 
of the variability-aware analyses as specialty analyses of the two 
languages makes it infeasible to reuse many existing C static analy- 
sis tools which focus on analyzing only C (i.e., variability-oblivious 
tools). This explains the large gap in terms of bug detection capabil- 
ities between the state-of-the-art variability-oblivious tools (which 
can perform inter-procedural analysis using techniques such as 
separation logic [20] and model checking [7]) and variability-aware 
tools [42]. As research on variability-oblivious analysis marches 
on, variability-aware analyses lag behind, because they have to 
constantly maintain parity with the state-of-the-art, while support- 
ing the preprocessor, which amplifies the engineering effort. 
Our goal is to close the gap by transforming real-world C soft- 
ware that uses both C and preprocessor into pure C code, ie., to 
desugar unpreprocessed C into a simpler subset of the language. 
Desugaring converts the preprocessor’s difficult-to-analyze compile- 
time variability into run-time variability represented in pure C. 
This desugared code can then be analyzed by existing variability- 
oblivious tools which do not support unpreprocessoed C, or it can 
be used as a common intermediate representation for developing 
new variability-aware analyses. 
2056Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:53:04 UTC from IEEE Xplore.  Restrictions apply. ICSE ’22, May 21-29, 2022, Pittsburgh, PA, USA 
The key challenge to our approach is that preprocessor usage of- 
ten has no direct equivalence in C. The transformation tool needs 
to account for all interactions of the preprocessor with C usage 
and scale to all variations of the source code created by these in- 
teractions. Moreover, real-world C programs are not ideal, having 
syntactic and type errors in untested configurations [1], an obsta- 
cle to correct and complete transformation. 
Prior work on the desugaring approach has limited support for 
real-world C. C RECONFIGURATOR [21] is an effort to conduct variability- 
aware verification by transforming a subset of unpreprocessed C 
constructs. But it specifies its transformation on an idealized lan- 
guage instead of C; as such its implementation lacks support for 
many common C constructs including structs and some function 
definitions. Hercules [12, 41, 43] handles unpreprocessed C by travers- 
ing abstract syntax trees (ASTs) produced by the TypeChef [25] 
variability-aware C parser and type checker. Hercules’ transfor- 
mation is informally described and is also not over the complete 
C grammar; thus, its implementation has unsound support for C 
constructs, including structs, functions, and some expressions [41]. 
Moreover, it relies on the strict assumption that no type errors are 
present in any configuration, limiting its capability on real-world 
C. 
In this paper, we introduce a newly designed desugaring trans- 
formation and implement it in a new tool called SugarC that is 
capable of desugaring real-world C programs. Because real-world 
Cis not guaranteed to be type-safe or even syntactically valid in all 
configurations, our desugarer performs simultaneous type check- 
ing and transformation and preserves syntactic and type errors in 
the desugared output as run-time errors. SugarC is specified as a 
novel syntax-directed translation of unpreprocessed C to pure C, 
where we augment C’s formal grammar specification with transla- 
tion rules. This approach combines both the soundness of a formal 
grammar specification and the realism of using C’s actual gram- 
mar specification. Using C’s own grammar makes our support for 
C constructs explicit, as well as for those constructs we intention- 
ally omit, such as the now-uncommon K&R-style functions [22]. 
SugarC’s translation is defined by annotating each grammar con- 
struct’s production with a semantic action that specifies the trans- 
lation of that construct and by associating each construct with a 
semantic value. We represent semantic values in a data structure, 
called a multiverse, that has several generic operators, including 
the product operator. Product simplifies the specification of many 
transformation rules by encapsulating variation, with some con- 
structs, such as statements, representable as identity transforma- 
tions over multiverse values. However, naive desugaring of more 
complex C syntax, such as user-defined types, can cause exponen- 
tial explosion in the desugared output. To realize SugarC as a prac- 
tical tool, we employ novel optimizations that improve scalabil- 
ity for constructs such as structs, unions, and enums declarations, 
which can have multiple variations in real-world C. 
To evaluate support for desugaring C constructs, we develop a 
benchmark we call DesugarBench. It consists of 108 hand-created 
programs, covering a wide range of constructs drawn from C’s 
grammar specification. We evaluate SugarC as well as C REcon- 
FIGURATOR and Hercules, to compare support for unpreprocessed 
C. While no tool supports all constructs, we show that SugarC sup- 
ports many more constructs, especially the kinds of challenging 
2057 Zachary Patterson, Zenong Zhang, Brent Pappas, Shiyi Wei, and Paul Gazzillo 
1 const bool __UINT, __CHAR; 
2 
3 int __x_1; 
4 char 2; 
1 #ifdef UINT : enar —-x-<; 
2 7 7 . 
unsigned int x; 6 if (__UINT 8& ! __CHAR) { 
5 endif 7 printf("%u\n", __x_1); 
4 #ifdef CHAR : _ MUA y =X N75 
5 ch ; 
6 fendie 9 if (!__UINT && __CHAR) { 
3 10. printf("%u\n", __x_2); 
11 
8 printf("%u\n", x); 3 
if ((__UINT && __CHAR) || 
(!__UINT && ! __CHAR)) { 
__type_error(); 
} (a) Unpreprocessed C code. 
(b) Desugared code. 
Figure 1: An example of desugaring unpreprocessed C code. 
cases found in real-world C. In addition, we perform an empirical 
evaluation of SugarC’s scalability to desugar three real-world con- 
figurable programs (axTLS, Toybox, and BusyBox). SugarC desug- 
ared 774 out of 813 files in the three programs, taking at most ten 
minutes in the worst case and less than two minutes for 95% of the 
C files. 
This paper makes the following contributions: 
e The design and specification of a syntax-directed transla- 
tion that simultaneously type checks and desugars unpre- 
processed C. (Section 2) 
e The realization of our desugarer in a new tool called SugarC 
that incorporates optimizations for scaling to real-world us- 
age of C constructs. (Section 3) 
e A new benchmark suite, DesugarBench, that measures sup- 
port for desugaring unpreprocessed C. (Section 4) 
e An evaluation that compares SugarC with prior work on 
DesugarBench, and on three real-world C programs that 
demonstrates the scalability of SugarC. (Section 5) 
Significance. Some of the most critical software infrastructures 
are implemented as highly-configurable C programs, and this con- 
figurability increases the challenges of maintaining software qual- 
ity while also rendering traditional bug detection and testing infea- 
sible. SugarC is an important step in developing automated analy- 
ses that are capable of scaling variability-aware analyses to large, 
real-world programs. It creates the foundation for both leveraging 
existing variability-oblivious analysis tools and accelerating the de- 
velopment of new variability-aware analyses to increase the relia- 
bility and security of our software infrastructures. 
We have made our SugarC specification and implementation, 
DesugarBench, and all experimental data available [36]. 
2 DESIGN OF SUGARC 
The preprocessor adds several constructs to C: macro defini- 
tion (#define) and expansion, header inclusion (#include), and condi- 
tional compilation (#ifdef). These constructs have subtle semantics 
when combined with C. For instance, making multiple declarations 
of the same symbol is not possible in C, but is legal in unprepro- 
cessed C. Figure 1a has two declarations of x (lines 2 and 5). SinceAuthorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:53:04 UTC from IEEE Xplore.  Restrictions apply. SugarC: Scalable Desugaring of Real-World Preprocessor Usage into Pure C 
these declarations are guarded by preprocessor conditionals, this 
program is legal as long as only one of the macros UNIT or CHAR is 
defined. Otherwise, there will be a type error, either an undeclared 
symbol error on line 8 (if neither macro is defined) or redeclaration 
error (if both macros are defined). 
Figure 1b shows the desugared code. In general, SugarC repre- 
sents C constructs affected by the preprocessor’s compile-time be- 
havior as equivalent run-time C behavior. Configuration macros 
(such as UNIT and cHaR) are represented as const bool C variables (line 
1), and preprocessor conditionals are desugared depending on their 
context. The multiple declarations of x in the unpreprocessed code 
cannot be within C conditionals because of C’s scoping rules and 
because there is no C syntax for conditionals outside of function 
bodies. Instead, we desugar these declarations of the same symbol 
as single declarations of different symbols, __x_1 and __x_2 (lines 3 
and 4). Then the use of the original symbol x is multiplexed into 
all of its possible variations, guarded by C conditionals (lines 6- 
15). Note that our desugarer also represents compile-time errors 
at run-time, via calls to a __parse_error or __type_error function that 
only applies to the errant set of configurations, ensuring all varia- 
tions of the unpreprocessed source are preserved (line 14). 
We specify the desugaring as a syntax-directed translation of the 
unpreprocessed source to pure C. Syntax-directed translation is a 
classic transformation technique that works by augmenting a for- 
mal grammar with rules guiding the translation [2]. The transla- 
tion is defined by (1) annotating each grammar construct’s pro- 
duction with a semantic action governing the translation of the 
construct and (2) associating a semantic value that holds the result 
of the translation of that construct. In our case, each C construct’s 
semantic action produces a pure C version of all variations of the 
unpreprocessed construct, storing the pure C code as a semantic 
value. This approach allows us to use a formal grammar specifi- 
cation to model the effects of the preprocessor, while still follow- 
ing the actual grammar of C. Our syntax-directed translation is 
specified as a bison grammar [17] with semantic actions. These se- 
mantic actions are read by the underlying parsing framework (we 
use SuperC [16] in our implementation) to generate a parser that 
dispatches control to the semantic actions after parsing each con- 
struct. 
SugarC also performs simultaneous type checking during the 
transformation to preserve type and syntactic errors in the desug- 
ared output as run-time errors. Doing this is important for han- 
dling real-world code, because unpreprocessed source code is not 
guaranteed to be type-safe in all configurations. By type checking 
during desugaring, SugarC is able to weaken the assumption of 
type correctness for all configurations that prior works (Hercules 
and C RECONFIGURATOR) rely on, while still desugaring the type- 
safe variations of the unpreprocessed source. Preserving these er- 
rors in the desugared output ensures that type-unsafe configura- 
tions are not silently transformed into valid variations of the source 
code. 
2.1 Representing Semantic Values 
To record all variations of a desugared construct, we use a mul- 
tiverse object for semantic values. Similar to prior work on varia- 
tional data structures [44], choice calculus [11], and Makefile static 
2058 ICSE 22, May 21-29, 2022, Pittsburgh, PA, USA 
analysis [15], SugarC’s multiverse holds a set of values, each tagged 
with a presence condition, i.e., a logical expression that represents 
the configurations in which the value appears. 
We define a multiverse M as a set of n pairs of a source code 
construct s and presence condition p. 
M = {(s1, p1), (S2, p2), «5 (Sns Pn) } 
M is always a finite set, because there are a finite number of possi- 
ble variations of unpreprocessed source code due to preprocessor 
conditionals. For example, the multiverse for all variations of the 
variable usage of x in Figure 1a on line 8 would be: 
{(<_x_1’,__UINT A 3_CHAR), 
(‘_x_2’,4._UINT A _CHAR), 
(‘__type_error()’,__UINT A __CHAR v =__UINT A =__CHAR) } 
To ensure all possible variations of each construct are captured, 
SugarC maintains two invariants of the presence conditions in the 
multiverse. First, the presence conditions must be disjoint, i.e., each 
pair of presence conditions should be mutually exclusive. This re- 
flects the determinism of the preprocessor: one configuration yields 
one variation of the source code. Second, the presence conditions 
must be covering, i.e., the union of the presence conditions is logi- 
cal True. This ensures that the transformation will record all varia- 
tions of the input source code. The above multiverse satisfies these 
two invariants because a type error is present if __UINT and __CHAR 
are both defined or undefined, and a variation of x is present when 
only one of the macros is defined; the presence conditions are dis- 
joint and cover all four interactions between the two conditions. 
We define several generic operations on multiverses to ease the 
specification of transformation rules. The product operator lifts any 
binary operator, such as string concatenation, to multiverse opera- 
tor by taking the cartesian product of all elements in the multiverse. 
For instance, as part of the transformation for the declarations on 
lines 2 and 5 in Figure 1a, the semantic action needs to concatenate 
the resulting desugarered declarations that are emitted on lines 3- 
4 in Figure 1b. Since there are two variations each, there are four 
possible variations of their concatenation. 
The product of two multiverses A and B over a scalar operator 
o is defined as follows: 
Ax° B= {(aob,pAq) |V(ap) € A, V(b, q) € B} 
This formal definition can be found in [15] in the context of Make- 
file analysis, albeit it was only implemented for string concatena- 
tion in that context. SugarC, however, embodies the generic ver- 
sion of this operator, automatically lifting string concatenation, list 
concatenation, declarator construct composition (used when col- 
lecting declarations), among other operators. The product operator 
allows for many semantic actions to be specified as a straightfor- 
ward identity transform, with the multiverse encapsulating correct 
handling of multiple variations (see Section 2.3). 
In addition, we define new operators including scalar product, 
which allows for one operand to be a scalar value instead of a mul- 
tiverse; filter for trimming elements that have infeasible presence 
conditions; deduplicate for unioning elements with identical val- 
ues; and transfom, a unary operator, which is effectively a map.Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:53:04 UTC from IEEE Xplore.  Restrictions apply. ICSE 22, May 21-29, 2022, Pittsburgh, PA, USA 
2.2 Representing the Symbol Table 
SugarC maintains a symbol table for all variations for two reasons. 
First, it stores the renamings of identifiers, since multiple declara- 
tions of the same symbol may legally occur in unpreprocessed C 
code. Second, it stores type information so that the desugarer can 
also perform type checking. While configuration-aware symbol ta- 
bles [13] and type checking [24] have been addressed in prior work, 
SugarC is the first to perform type checking and desugaring simul- 
taneously, which addresses the challenge of handling real-world 
code that has no guarantee of type safety in all configurations. 
Since we need to preserve all variations of the unpreprocessed 
source, we resolve this by generating a unique renaming for each 
variation of the symbol. This enables SugarC to choose the right 
renaming for the symbol wherever it is used. In the case of multiple 
possible renamings, SugarC generates a C conditional to ensure 
each variation of the identifier use is preserved (lines 6-11 in Figure 
1b). 
We define symbol table S as a structure that maps m identifiers 
v; (from the unpreprocessed source code) to a multiverse of pairs 
of type ri and renaming ri for each identifier. 
S = {or + (2,72), pr), (e818), pads) 
v2 > (177, 175”), Pr) (057, 175”), P2)s +++) 
ey 
vm > (ry, ri), Pi)» (75, 75"), P2)s dS 
A typical type checker will use the lack of an entry in the sym- 
bol table to determine whether a symbol has not yet been declared, 
e.g., to prevent multiple declarations, and use-before-declaration. 
Our configuration-aware symbol table, however, may have an en- 
try in some configurations while the symbol has not been declared 
in others. To account for this, we add special type entries to each 
symbol’s multiverse, called undeclared and error. With these en- 
tries, the symbol table captures in which configurations the sym- 
bol is defined or has a type error. This ensures that each symbol’s 
associated multiverse of definitions meets the covering invariant. 
2.3 Semantic Actions for Desugaring 
We use pseudo-code to show the semantic actions. An action’s 
function is named after the grammar construct, e.g., WhileLoop or 
Declaration, while its parameters are the components of the gram- 
mar rule. For instance, a WhileLoop construct has the following 
context-free grammar rule: 
WhileLoop — ‘while’ Expression Statement 
Its semantic action function thus has the following pseudo-code 
signature: 
WuiILELoop(Expression, Statement) 
Semantic actions in our implementation have access to global 
parsing state. In particular, this includes the symbol table for the 
current scope, which is called symtab in the semantic actions below. 
We now highlight a few illustrative semantic actions from a vari- 
ety of constructs. The complete grammar with all semantic actions 
can be found in the anonymized, released artifact. Zachary Patterson, Zenong Zhang, Brent Pappas, Shiyi Wei, and Paul Gazzillo 
  
Algorithm 1 The semantic action for transforming while loops.   
Input: Multiverse values for the Expression and Statement. 
Output: A desugared while loop as a multiverse. 
1: function WuILeLoop(Expression, Statement) 
2: return (‘while’ x* Expression) x* Statement   
2.3.1 Statements. Desugaring statements in the unpreprocessed 
C language involves no more than taking the cross-product of all 
variations of the components of statements. This is possible be- 
cause transforming a multiverse of statements only requires sur- 
rounding each multiverse element with a C conditional. 
Algorithm 1 shows the semantic action for while loops. Line 1 
defines the semantic action function WHILELoop which takes Ex- 
pression, a multiverse of conditional expressions, and Statement, a 
multiverse of C statements. Line 2 is the cross-product of all com- 
ponent symbols of the WhileLoop construct, including the ‘while’ 
keyword and semi-colon. The x* product operator lifts the string 
concatenation scalar operation to all pairs of multiverse elements, 
updating the presence conditions accordingly. Note that scalar se- 
mantic values such as ‘while’ are not multiverses and we use a 
special scalar product operator to take the product of a scalar and 
multiverse. 
The representation and preservation of all variations of the source 
program is encapsulated by the multiverse, enabling a straightfor- 
ward definition of the translation rule. For instance, if the Expres- 
sion construct has two variations due to a preprocessor conditional, 
while all other constructs have only one variation. The repeated 
applications of the product operator will yield two complete vari- 
ations of the entire WhileLoop which are stored as a single multi- 
verse object. 
The desugaring of compound statements can be expressed sim- 
ilarly using a lifted concatenation. In practice, this can yield an 
exponential explosion of variations. This explosion can be avoided 
by simply swapping out the semantic value of the compound state- 
ment. Instead of using a string, our specification using a list of 
strings and lifts list concatenation instead of string concenation. 
This allows for the translation rule to remain simple, while improv- 
ing performance in practice. 
2.3.2 Declarations. Handling declarations is more complicated than 
statements, because (1) preprocessor conditionals around declara- 
tions are not equivalent to C conditionals due to scoping rules, (2) 
multiple declarations of the same symbol are prohibited, and (3) 
there is no language support for conditionals outside of function 
bodies. Instead, SugarC produces one, unconditional declaration 
for each variation, but renames the symbol. In order to ensure the 
renaming is applied to all uses of the symbol, the symbol table 
records all variations of the symbol simultaneously. 
Algorithm 2 shows the semantic action for declarations. C dec- 
larations contain a type specifier, which can be primitive types, 
structs, unions, etc., and a declarator, which can both give the sym- 
bol its name as well as declare compound types such as functions 
and pointers. The semantic action takes a multiverse of values for 
the type specifier and declarator. Line 2 first combines the two mul- 
tiverses into all possible pairs of type specifiers and declarators by 
2059Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:53:04 UTC from IEEE Xplore.  Restrictions apply. SugarC: Scalable Desugaring of Real-World Preprocessor Usage into Pure C 
  
Algorithm 2 The semantic action for transforming declarations.   
Input: Multiverse values for the TypeSpec and Declarator. 
Output: Desugared declarations, ie., multiverse of declaration renamings. 
1: function DECLARATION(TypeSpec, Declarator) 
2: D-=TypeSpec xP#** Declarator 
for each ((name;, 7; ), pi) € D do 
symtab|name;] <— UppaTE(symtab[name; J, 7;, pi) 
A = RENAME(symtab, TypeSpec) 
B = RENAME(symtab, Declarator) 
return A x* B xt ‘?   
lifting an operator that creates a pair of two elements, i.e., 
AXP" B = {((a,b),p Aq) | V(ap) € A,V(b.q) € B} 
Lines 3 and 4 update the configuration-aware symbol table with 
each declaration. Conceptually, the update operation replaces the 
prior multiverse entry for the given (name;, 7;) pair. This update 
needs to account for both redeclaration errors and also ensure that 
each declaration only affects the configuration defined by the pres- 
ence condition p;. The function ensures this by conjoining the pres- 
ence condition p; of the new declaration with that of the old, pojg. 
The UppatE function is defined as follows: 
UppatTeE(M, 7j, pi) = 
{(error, Pola) } if Told = error 
{(Ti Pola A Pi), 
(undeclared, poig A =pi)} 
(Toa Pod) €M | { (error, Poig A Pi), 
(Told Pola A =Pi)} ift>jq = undeclared 
if otherwise 
There are three cases to consider when updating a symbol table 
entry: (1) If the previous entry was a type error, then the entry re- 
mains a type error. (2) If the entry was undeclared, then the entry is 
replaced with the newly-given type. Since there may still be some 
configurations left undeclared, the undeclared entry remains un- 
der the configurations where the new entry does not overlap, i.e., 
Pola A 7pi. (3) If the entry was already declared, the entry becomes 
an error in the configurations that overlap between the old and 
new declarations. For non-overlapping configurations, the entry 
remains the same. C’s type checker has subtle rules for redeclara- 
tion not reflected in this pseudo-code but are present in our im- 
plementation: redeclarations are prohibited in the function-local 
scopes but are permitted in the global scope as long as the types 
are identical (which C allows to support having separate function 
definitions from function declarations in headers). 
Once the symbol table is updated for all variations of the decla- 
ration, the action produces the desugared version of each variation 
(lines 5-7). Our actual implementation creates a new identifier for 
each new variation of a symbol’s declaration and stores it along- 
side the type in the symbol table. We abbreviate the symbol table 
here for brevity, and instead use RENAME in place of the process of 
looking up the renamings in the table. 
The TypeSpecifier also needs renaming because of user-specified 
type names. Declaration syntax in C is complicated, supporting 
not only variable declarations, but also additional specifier syn- 
tax for structures, unions, and enums, user-defined types (typedef), ICSE 22, May 21-29, 2022, Pittsburgh, PA, USA 
separate declarator syntax specifying compound types (functions, 
pointers, and arrays), lists of declarators in one declaration, dif- 
ferences between locally- and globally-scoped symbols, and more. 
User-defined structures and types have consequences for the scal- 
ability of desugaring, and we leave a discussion of our optimized 
handling of these in Section 3.1. 
2.3.3 Expressions. Like statements, expression translations are also 
specified with an identity transform. For instance, a binary C ex- 
pressions take the cross-product of each element of the multiverses 
from the left and right expressions, i.e., Left x°P Right. Unlike state- 
ments, however, expressions have type. In order to perform type- 
checking and desugaring simultaneously, the semantic value of an 
expression is a multiverse of pairs (s, 7) to hold both the desug- 
ared expression s and its type t. The product Xx°P lifts the C con- 
struct’s operator itself, both concenating the desugared expression 
and checking type compatibility, ie., A x°P B= 
{((a+op+b, Top (Ta: Th))s PAG) | V((a; Ta), p) € A, V((b, Th), q) € BY 
This desugaring operation is particularly subtle, because the opera- 
tor is used both as a string value for producing a source translation 
a+op+ bandas a function type Top (Ta, Tp). Essentially, this prod- 
uct operation takes each combination of variations of the left side 
and the right side, then for each combination produces both the 
desugared string translation and the result of checking the type 
compatibility of the operands for the operator. Observe that this 
formulation gracefully handles type errors, since the error type is 
carried along just for the type-unsafe configurations until it can be 
replaced at the statement-level with a __type_error() call. 
3 REALIZING SUGARC IN PRACTICE 
Using cross products from the ground up and killing parsing error 
branches would create a correct output. But this approach would 
lead to incredibly large desugared source files. To reduce the result- 
ing size of the transformation and create output that is amenable to 
static analysis, we perform several novel optimizations that make 
desugaring feasible with real-world code. These optimizations in- 
volve the user-defined types created by structs, unions, and enums 
as well as our design choices for error representation. 
3.1 Handling Struct, Union, and Enum 
C allows for user-defined types in the forms of struct, union, and 
enum (SUE) constructs. The preprocessor usage inside and outside 
of SUE definitions cause complex interactions which have not been 
properly addressed by past works, as they either ignore SUE con- 
structs or transform them with the naive combinatorial approach. 
But using the strategy of taking a cross-product of all possible 
struct definitions creates a large explosion of desugared variations, 
since real-world structs commonly use configurable data types as 
well as have structs as field members that may themselves have 
multiple definitions. As an optimization, we represent the fields 
from all variations of an input struct using a single combined SUE 
specifier when possible. In Figure 2a, the preprocessor usage in 
lines 1-5 defines two possible types of thisSize. Using thisSize to 
declare the field f in struct x, the type of f depends on the value of 
the preprocessor condition worDsi1ze. Figure 2b shows the result of 
applying SugarC on the code. Because each struct stores its fields 
2060Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:53:04 UTC from IEEE Xplore.  Restrictions apply. ICSE ’22, May 21-29, 2022, Pittsburgh, PA, USA 
1 #if WORDSIZE == 32 1 typedef long int thisSize_1; 
2 typedef long int thisSize; 2 typedef int thisSize_2; 
3 #else 3 struct X_3 { 
4 typedef int thisSize; 4 thisSize_1 f_4; 
5 #endif 5 thisSize_2 f_5; 
6 struct X { 6 }; 
7 thisSize f; 7 void foo_4 () { 
8 35 8 struct X_3 data_5; 
9 void foo () { 9 if (WORDSIZE == 32) 
struct X data; 
data.f = 3; data_5.f_4 = 3; 
if (!(WORDSIZE == 32)) 
} data_5.f_5 = 3; 
(a) Struct with a configurable 
field. (b) Desugared code. 
Figure 2: Desugaring struct with a configurable field. 
in the symbol table presented in Section 2.2, getting a member for 
f would only return mutually exclusive conditions for each possi- 
ble definition. This can be seen in Figure 2b where data. f expands 
into an if statement representing the presence conditions associ- 
ated with f_4 and f_5 respectively. 
Multiple conditional SUE definitions and forward references. How- 
ever, it is not always possible to use one object to represent every 
SUE definition. For instance, a flexible array is an array with no 
defined size value, but upon memory allocation through malloc, 
the array can use any number of elements as any extra memory is 
attributed to the size of that array. Due to this unique property, a 
flexible array must be the last element of a struct, and each struct 
may only have one flexible array. This specific instance can be seen 
in Toybox as structs used for status messages, as shown in Figure 
3a. If we were to desugar this in the same manner that we handled 
the code in Figure 2a, then the result would violate the one flexible 
array per struct rule. So as Figure 3b demonstrates, we are forced 
to split struct optval_status into two separate structs. 
This makes forward references to SUE objects challenging since 
now the declaration could refer to any of the definitions. In ad- 
dition, they are also forcibly pointers, since otherwise their size 
cannot be determined. As we continue parsing the code, we post- 
hoc add the SUE definitions to the union, and print it at the top of 
the scope, but below the moved up SUE definitions as displayed in 
Figure 3b. 
Anonymous Objects. It is common for real-world SUE objects to 
contain unnamed SUE objects as fields, or for variables to be de- 
fined with a struct or union without naming the structure. We 
give every anonymous object a name, which is ”anonymous_#” 
and additionally a renaming ”anonymous_#_#”. This is so that later 
symbol table accesses can find the specific renamings that may be 
linked to an anonymous object without running into renamings 
from a different anonymous object. Since anonymous nested SUE 
objects can have their fields referenced by their parent, we print 
an additional field access when encountered, which is necessary 
since the inner object may have to be split into multiple objects. 
The types associated with the variables themselves become impor- 
tant as we get into sizeof and typeof operations. 
2061 Zachary Patterson, Zenong Zhang, Brent Pappas, Shiyi Wei, and Paul Gazzillo 
1 typedef long int thisSize_1; 
2 typedef int thisSize_2; 
3 struct optval_status _5{ 
4 unsigned int status_3; 
5 thisSize_1 message_4[]; 
6 3; 
7 struct optval_status _7 
1 #if WORDSIZE == 32 P y : “ t 
: soe 8 unsigned int status_3; 
2 typedef long int thisSize; woe 
9 thisSize_2 message_6[]; 
3 #else 0}: 
4 typedef int thisSize; , 
- 11 struct 
5 #endif __forward_tag_reference_8 
6 struct optval_status *status; { 
7 struct optval_status { . 
8 unsigned int status; u union { 
oe , 13 struct optval_status_5 
9 thisSize message[]; 0h optval_status_5; 
, 14 struct optval_status_7 
+ . optval_status_7; (a) Struct with a flexible array Is }: P 
16 }; 
17. struct 
__forward_tag_reference_8 
xstatus_9; 
(b) Desugared code. 
Figure 3: A simplified excerpt from Toybox where flexible 
arrays requires the transformation to separate the structs. 
Sizeof. Sizeof becomes problematic with our method of com- 
bining SUE object fields, as the size of the transformed SUE ob- 
ject no longer represents the size of what any given configuration 
may have. In Figure 4a, fields of struct y are conditionally defined. 
Specifically, if a is defined, then y contains an int field b; if a is not 
defined, the field b is a short. As discussed above, this struct is trans- 
formed into lines 6-11 in Figure 4b by representing all fields in one 
object. If no special treatment is given to the sizeof, sizeof(struct 
X_4)-sizeof(struct Y_9) will result in a negative value (the size of 
three ints in x_4 minus the size of three ints and a short in y_9) and 
therefore cause a type error. 
Our solution, shown in lines 12-24 in Figure 4b, is to create a 
standin struct for what the definition would be under each pres- 
ence condition. Then in lines 25-30, we make two versions of the 
array; array_20 is associated with a being defined, and array_21 is as- 
sociated with a being undefined. Therefore, the standin structs used 
in expressions at lines 27 and 30 correlate with __sizeofStandin_16 
and __sizeofStandin_19, respectively. This approach allows us to ac- 
count for whatever padding that might be incurred by the compiler 
to make the size as accurate as possible. While this introduces over- 
head, it is practical because the use of sizeof on conditional defined 
structs does not appear frequently in real code. We handle a union 
object similarly when sizeof is used. 
Initialization. Struct objects are initialized with an initializer list 
consisting of constant values (line 17 in Figure 4a). This brings two 
challenges to SugarC. First, if there are different presence condi- 
tions within the initializer list, multiple definitions need to be cre- 
ated. Second, depending on which preprecessor condition is used, 
different fields could be assigned to, as shown in Figure 4b. To han- 
dle these challenges, we define the struct as a standalone definition, 
and then assign each value individually, as shown in lines 32-40 inAuthorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:53:04 UTC from IEEE Xplore.  Restrictions apply. SugarC: Scalable Desugaring of Real-World Preprocessor Usage into Pure C 
1 struct X_4 { 
2 int a_1; 
3 int b_2; 
4 int c_3; 
5 3; 
6 struct Y_9 { 
7 int a_5; 
8 int b_6; 
9 int a_7; 
10 short b_8; 
11 3; 
12 struct { 
13 typeof (int) __tmp_10; 
14 typeof (int) __tmp_11; 
15 typeof(int) __tmp_12; 
1 struct X { . . 
2 int a; 16 } __sizeofStandin_13; 
3 int b; 17 struct { 
4 int c; 18 typeof (int) __tmp_14; 
5 }; 19 typeof (int) __tmp_15; 
6 struct Y { 20 } __sizeofStandin_16; 
7 #ifdef A 21 struct { 
8 int a; 22. typeof (int) __tmp_17; 
9 int b; 23 typeof (short) __tmp_18; 
10 #else 24 +} __sizeofStandin_19; 
iW int a; 25 int array_20[ 
12 short b; 26 sizeof (typeof ( 
13. #endif __sizeofStandin_13 
14 3; . = 
15 int array[sizeof(struct X)- 7 sizeof (typeof ( ; 
sizeof(struct Y)]; __SizeofStandin_16 
16 void foo() { ; I; 
7 struct Y y = {4,2}; 28 int array_21[ 
18 } 29 sizeof (typeof ( 
__sizeofStandin_13 
(a) Example of initialization Do 
: 30 sizeof (typeof ( and sizeof usage on structs. - SizeofStandin.19 
4; 
31 void foo_23() { 
32 struct Y_9 y_22; 
33 if (A) 
34 y_22.a_5 = 4 
35 if (!A) { 
36 y_22.a_7 = 4; 
37 if (A) 
38 y_22.b_6 = 2; 
39 if (!A) 
40 y_22.b_8 = 2; 
41 } 
(b) Desugared code. 
Figure 4: Desugaring sizeof when used on structs, and initial- 
izing struct variables. 
Figure 4b. If the struct or list is constant, or in the global scope, we 
have no choice but to duplicate the definitions and correct which 
values are assigned to what fields. 
3.2 Emitting Errors and Line Numbers 
As shown in Figure 1b, we represent type errors at the statement 
level alongside type-safe variations of the code, which allows static 
analyses to identify and terminate these control flows. If one or 
more of the expressions in a statement contain type errors, then the 
error is lifted to the statement level for representation as an error ICSE 22, May 21-29, 2022, Pittsburgh, PA, USA 
1 IP_UDP_DHCP_SIZE = sizeof(struct ip_udp_dhcp_packet) - 
CONF IG_UDHCPC_SLACK_FOR_BUGGY_SERVERS, 
2 char c[LIP_UDP_DHCP_SIZE == 576 ? 1: -1]; 
Figure 5: Excerpt from BusyBox for illustrating SugarC’s ex- 
pression evaluation limitation. 
function call; the entire configuration is invalidated by a type error, 
which would halt compilation if selected as a single variation of the 
unpreprocessed C. Since our desugarer performs type-checking 
during transformation, we can express type error handling in our 
translation rules. SugarC represents presence conditions in the out- 
put by creating a variable for each Boolean predicate in the pres- 
ence condition, declared as const bool. It records presence condi- 
tions as symbolic formulas, using z3 [10] and BDDs [45]. When 
emitting any presence condition, we replace the Boolean predicate 
with its corresponding variable name. 
Syntactic errors in a configuration, however, represent viola- 
tions of the grammar on which we specify our translation rules. 
Since there is no way to identify what illegal syntax was supposed 
to mean, and branches may fork across different scopes, there is 
no consistent way to correctly display the error alongside valid 
code; instead we collect the presence conditions of all branches 
with syntactic errors into a single unioned presence condition. We 
then emit the union as a run-time conditional check that results 
in a runtime error if triggered. By guaranteeing this check is per- 
formed at runtime, the remainder of the desugared output can elide 
run-time checks for configurations that have syntactic errors. This 
significantly reduces the number of static conditionals that need 
to be emitted during desugaring; we have observed desugared out- 
puts reduced to less than 10% of their previous sizes without this 
optimization in syntactic error handling due to the reduction in 
the size of output presence conditions. 
In addition, the underlying parser generation was modified to 
emit line numbers in the output that correspond to the unprepro- 
cessed source line numbers. This enables us to automatically map 
the desugared output back to the unpreprocessed input, which we 
use to automatically map alarms in desugared output to their un- 
preprocessed counterparts. 
3.3 Limitations 
There are several limitations in the current implementation of Sug- 
arC. First, because SugarC does not take any system configura- 
tion as input, it cannot properly evaluate the value of the size of 
types. This results in improper sizes or unexpected calculations 
in some configurations. In Figure 5, for SugarC to determine if 
IP_UDP_DHCP_SIZE == 576 requires evaluating the size of each field of 
the struct ip_udp_dhcp_packet. This means that SugarC needs to make 
judgments about the size of types such as int or long, which it 
cannot do without using additional system configuration as inputs. 
Similarly, SugarC cannot validate the names of registers for assem- 
bly statements. In terms of nonequivalent output, there may be 
different values associated with enum values than expected. Since 
each subsequent value increases, combining the lists of enums to- 
gether could make expressions evaluate differently. 
2062Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:53:04 UTC from IEEE Xplore.  Restrictions apply. ICSE ’22, May 21-29, 2022, Pittsburgh, PA, USA 
Table 1: DesugarBench.   
          Category Abbr. # of Programs 
(Declarations) basic BASIC 18 
(Declarations) struct, union andenum_ |SUE 16 
(Declarations) typedef TYPEDEF 5 
(Declarations) external EXTERN 4 
(Function definitions) ANSI ANSI 7 
(Function definitions) K&R K&R 6 
(Function definitions) variadic VARG 4 
(Expressions) function call and identifier | FCI 10 
(Expressions) unary, binary and ternay |UBT 7 
(Statements) control-flow CTRL 6 
Semantic error SEM 21 
Syntactic error SYN 4       
Second, variadic arguments are only partially supported in Sug- 
arC. While ellipsis can be parsed, and is supported when used in 
functions and type checking, usage of va_args is not identified as a 
type and therefore will result parsing errors as attempting to parse 
as a new identifier. 
Third, our handling of sizeof in structs may cause memory is- 
sues when executing the desugared code. This could happen when 
sizeof is used in the context of malloc, which requires the actual size 
of a desugared struct. 
Lastly, the implementation of the language is not complete. Fea- 
tures introduced in later versions of C, such as declarations leading 
switch cases, are not supported by our parser. Extensions provided 
by compilers may also not be supported such as _builtin_offset_. 
There are also a few obsolete representations, such as K&R style 
function definitions, that we do not support. 
4 DESUGARBENCH 
We present DesugarBench, a benchmark that allows for compar- 
isons between desugaring tools in terms of their support for C fea- 
tures. DesugarBench consists of 108 configurable C files under 12 
categories to represent language features that are important for 
desugaring tools to handle. Table 1 shows the categories, abbrevi- 
ations and number of programs of DesugarBench. We will refer to 
the categories by their abbreviations in the rest of the paper. 
We define the following principles for generating DesugarBench 
programs. First, the benchmark programs should cover many C 
language and program features. We first inspect the grammar dis- 
cussed in Section 2, and identify four high-level constructs: dec- 
larations, expressions, function definitions, and statements. These 
constructs are further divided into the first 10 categories in Table 
1 that cover different language features. For example, standard C 
compilers still support the original K&R C functions declaration as 
well as the now-common ANSI C functions, which have very dif- 
ferent syntax [22]. We therefore include K&R and ANSI as two cate- 
gories of function definitions. As discussed above, syntactic and/or 
semantic errors may exist in some configurations in real programs. 
Thus, we include cases of these in two categories, SEM and SYN of 
DesugarBench. Each benchmark program is manually created and 
is meant to test a specific feature. Some programs are created to 
test common features. For example, the program function_pointer 
2063 Zachary Patterson, Zenong Zhang, Brent Pappas, Shiyi Wei, and Paul Gazzillo 
in the ANSI category is designed to test if a function pointer de- 
fined in a static branch can be correctly transformed. Others simu- 
late corner cases. For example, function_no_param_dec in the K&R 
category describes an unusual situation where a function can be 
legally declared without parameters and defined with parameters 
in ANSI style, as the declaration can be interpreted as K&R style. 
Second, the benchmark programs are created with small sizes 
and not biased toward certain features. The small sizes make it eas- 
ier to reason about the expected results of the desugaring tools (i.e., 
the program semantics should be preserved), since we manually 
check for semantic equivalence. The sizes of programs in Desugar- 
Bench range from 3 to 37 lines of code. In addition, we make sure 
that there are not redundant benchmark programs for the same fea- 
ture by checking the syntax. Category BASIC, SUE and SEM cover 
more C syntax than other categories. Thus, they contain more pro- 
grams, as shown in Table 1. 
Third, each benchmark program should include at least one static 
conditional. This ensures that each program is the appropriate tar- 
get of the desugaring tools, which transform the unpreprocessed 
C program into an equivalent program represented in C. In Desug- 
arBench, all programs in the declarations, expressions, function 
definitions, and statements categories do not contain errors in any 
static branch, while each program in the semantic and parsing er- 
ror categories contains an error in one of its static branches. 
5 EVALUATION 
We conducted experiments to answer two research questions on 
SugarC’s practicality of desugaring real-world preprocessor usage. 
e RQ1: Does SugarC support more language features than ex- 
isting desugarers? 
e RQ2: Can SugarC desugar real-world C programs? 
To answer RQ1, we compare SugarC with C RECONFIGURATOR 
and Hercules on DesugarBench. We check if these tools can trans- 
form the benchmark programs into semantically equivalent pro- 
grams. Using this result, we discuss how well the features in each 
benchmark category are supported by each tool. We also compare 
the execution results of the original files and the SugarC-desugared 
files under same static conditionals to check implementation cor- 
rectness. To answer RQ2, we run SugarC to desugar three real- 
world programs, and report its performance. In addition, we com- 
pile and apply an off-the-shelf static analysis tool on the trans- 
formed programs. 
5.1 Experimental Setup 
5.1.1 Running desugaring tools on DesugarBench. We implemented 
a script to run SugarC, C RECONFIGURATOR, and Hercules on all 
DesugarBench programs and semi-automatically diagnose the out- 
puts by compiling each desugared file using GCC to check if the 
tools produce valid C programs. If a tool fails to generate a desug- 
ared file (e.g., tool crashes)! or if the desugared file does not com- 
pile with GCC, we report that the tool fails on this benchmark pro- 
gram. Otherwise, one author performed manual review to decide 
1Recall that Hercules relies on TypeChef to catch type errors and does not transform 
any programs with such errors. C RECONFIGURATOR uses a similar strategy for syn- 
tactic errors. For the SEM and SYN categories in DesugarBench, we treat C RECON- 
FIGURATOR and Hercules as passing these programs if the correct errors are caught.Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:53:04 UTC from IEEE Xplore.  Restrictions apply. SugarC: Scalable Desugaring of Real-World Preprocessor Usage into Pure C ICSE 22, May 21-29, 2022, Pittsburgh, PA, USA 
Table 2: SugarC, C RECONFIGURATOR, and Hercules results on DesugarBench. 
Declarations 
Tool BASIC TYPEDEF|EXTERN| ANSI Function Defintions Statements 
CTRL Expressions 
FCI | UBT SEM SYN | Total K&R   
SugarC 
C RECONFIGURATOR 
EGE 
BE E/ 
BE: eas           Hercules   EE: BEE es: ae BE: ae 
                
if each desugared file is semantically equivalent to its original pro- 
gram. 
To check if SugarC-desugared files can produce equivalent re- 
sults as the original files under the same configuration, we update 
each benchmark program in all categories except SEM and SYN 
to return different values from the main function under different 
static conditionals. We then use a file with external declarations 
of the static conditionals in each original file as Booleans. These 
Booleans are evaluated to true or false to execute the desugared 
file. This allow us to compare the results obtained from executing 
the desugared files with the results obtained from executing the 
original files under the same configurations. 
In our experiments, we used the latest versions of Hercules [19] 
and C RECONFIGURATOR [28] as of August 2021. We observed out- 
of-memory when running C RECONFIGURATOR (implemented in 
Java) with its default configuration. Therefore, we assigned JVM 
options -Xms64g -Xmx64g to allocate enough memory. Default con- 
figurations of SugarC and Hercules were used. We also had to make 
all macro names in the benchmark to start with ENABLED_ for C RE- 
CONFIGURATOR to work properly. All three tools took less than 5 
minutes to run on all DesugarBench programs. 
5.1.2. Running SugarC on real-world programs. We evaluated Sug- 
arC on three real-world programs, axTLS 2.1.4 [4], Toybox 0.7.5 
[39], and BusyBox 1.28.0 [6]. We chose these programs because 
they are common targets in the past evaluations of variability-aware 
analyses [1, 21, 26, 33, 35, 37], and contain large numbers of con- 
figuration options (94, 316, and 998 in axTLS, Toybox, and Busy- 
Box, respectively). We ran SugarC on all the .c files in each pro- 
gram. Any header inclusions, included directories, or macro defini- 
tions given by the build system were automatically extracted from 
the output of running make. Since hand-verifying semantic equiv- 
alence for the entire programs was cost prohibitive, we say that 
the desugarer produced a compilable output if the output can be 
compiled by GCC without error. We also applied an off-the-shelf 
static analysis tool, Clang Static Analyzer, on all the compilable 
desugared outputs to further validate if this tool can produced bug 
reports using the desguared results as inputs. 
Setting system macros. Most real-world C programs make use of 
Standard Library headers, which contain large number of system 
macros. These headers need to be desugared along with each .c file 
that includes them, but much of the code does not apply to our sys- 
tem. To address this, we identify a set of macros that models the 
behavior of our system, assuming only GCC 9.4.0 [18] and Ubuntu 
16.04 [40] (the environment in which we ran SugarC). This set of 
macros has all the default macros of GCC 9.4.0 turned on, and all 
macros that are associated with other system environments turned off, which were identified over six weeks by 4 computer science 
student workers with C development experience. This resulted in 
129 macros either being defined or undefined. When desugaring a 
.c file, we run SugarC with the -nostdinc option to prevent desugar- 
ing any files outside our set. Additionally, we replace GCC-specific 
code with an equivalent macro. For example, builtin_offset() func- 
tion is replaced by the macro definition #define __builtin_offsetof( 
st,m)((size_t)&(((st *)@)->m)). 
Setting guard macros. We also predefine the marcros that are 
not intended for use as configuration macros and instead are un- 
defined by default; we call those guard macros. Such macros are 
commonly used as header inclusion guards to prevent files from 
being included multiple times and to mark typedefs as being de- 
fined to avoid redefinition. In total, there were 257 guard macros 
in the standard libraries, 1 in axTLS, 1 in BusyBox, and 454 in Toy- 
box as it has flags for each file to turn on cleanup statements. 
Experimental environment. All experiments were conducted on 
a server with 192GB of RAM and 48 CPUs running Ubuntu 16.04. 
To measure SugarC performance, it was run three times on each 
file in the real-world programs, and we report the median. We set 
a 1-hour timeout for each file. 
5.2 RQ1: Does SugarC support more language 
features than existing desugarers? 
5.2.1. Semantic Equivalence. Table 2 shows the results of SugarC, 
C RECONFIGURATOR, and Hercules, organized by the categories of 
DesugarBench. Each cell of the table reports the number of bench- 
mark programs passed and failed, respectively, with green and red 
bars that represent the proportion of passed and failed benchmarks 
for each category and tool. We observe that SugarC supports many 
more features than C RECONFIGURATOR and Hercules. Specifically, 
SugarC passed all benchmark programs in 8 out of 12 categories, 
while C RECONFIGURATOR and Hercules only passed all programs 
in 0 and 1 categories, respectively. 
For SugarC, all but one program in the K&R and VARG cate- 
gories failed. As discussed in Section 3.3, SugarC currently does not 
support K&R style function definitions and va_list used in variadic 
functions. The one program in the VARG category passed because 
this program only defines a variadic function using ellipsis, which 
SugarC supports, but does not use va_list. SugarC failed on 1 out 
of 10 programs in the FCI category. The failing program involves 
the operator offset, a compiler extension provided by GCC. It is 
also a limitation of SugarC as discussed in Section 3.3. Finally, Sug- 
arC failed on one program in the SEM category. This program has 
a type error in one configuration by declaring an array with neg- 
ative size. SugarC does not evaluate expressions and check array 
2064Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:53:04 UTC from IEEE Xplore.  Restrictions apply. ICSE ’22, May 21-29, 2022, Pittsburgh, PA, USA 
bounds, and so produces a program that retains the negative array 
size type error. For the 2 programs that SugarC failed on FCI and 
SEM category, C RECONFIGURATOR and Hercules also did not pass. 
C RECONFIGURATOR and Hercules failed on 76 and 35 out of 108 
benchmark programs, respectively. We observed several common 
reasons for these failures. First, C RECONFIGURATOR and Hercules 
failed on 12 and 5 programs, respectively, due to mistakes in renam- 
ing multiply-declared symbols. For example, in one program in 
the BASIC category, Hercules renames the multiple declarations of 
variable x inside of preprocessor conditionals but does not rename 
a subsequent use of x, causing a type error in its desugared code. 
Second, Hercules failed on 5 programs due to incomplete desugar- 
ing, ie., missing variations from the original program. C RECon- 
FIGURATOR did not fail on any program for this reason. One pro- 
gram in the SYN category has two static branches, one with valid 
syntax (int «x) and the other not (int *). Hercules preserved the 
valid declaration but omitted the invalid one in its resulting trans- 
formation, representing an invalid configuration as valid. Third, 
the error handling mechanisms in both tools are incomplete. C RE- 
CONFIGURATOR in particular failed on all programs with type error 
(SEM), because it does not perform any type checking. While C 
RECONFIGURATOR reports some syntactic errors, it still missed one 
from the SYN category. Hercules, which relies on a separate tool— 
TypeChef—for type checking, failed to identify type errors in four 
programs in the SEM category. Hercules also missed all programs 
in the SYN category. 
Other programs reveal additional reasons of failure. For C RE- 
CONFIGURATOR, it incorrectly handles C’s “most closely nested” 
scoping rule to transform a reference to a local variable into a 
reference to a global variable in two BASIC programs. Forward 
references, structs with a flexible array, sizeof, and struct initial- 
ization are not supported by C RECONFIGURATOR, since by design 
it supports a restricted subset of C. Additionally, the benchmark 
evaluation shows that it misses most function calls. Hercules had 
partial support for structs, unions, and enums, but it missed sizeof 
and struct initialization. 
When executing SugarC-desugared files, we found that for all 
but 2 files, they produced the equivalent outputs as the original pro- 
grams under the same configurations. One was the result of a bug 
in SugarC in handling a static conditional that exists between the 
function declaration and body, and another was due to mistyping 
of an enum initialized with a large value, making it long long. 
In summary, SugarC’s formal approach to specifying desugar- 
ing rules enables it to support a wide-range of real-world C fea- 
tures correctly, in contrast to the informal approaches of prior 
work. 
5.3 RQ2: Can SugarC Desugar Real Programs? 
Table 3 shows the results of running SugarC on axTLS, Toybox, 
and BusyBox. The first row shows the number of C files in each 
program that SugarC produced a compilable output and those that 
it did not. The second row is the median running time in seconds 
SugarC took to desugar the files with the semi-interquartile range 
(SIQR) in a smaller font. Overall, for 774 out of 813 files SugarC 
produced an output that when compiled by GCC had no errors, and 
for 95% of these files, SugarC took less than 2 minutes per file. Zachary Patterson, Zenong Zhang, Brent Pappas, Shiyi Wei, and Paul Gazzillo 
Table 3: SugarC results on axTLS, Toybox, and BusyBox. 
    axTLS | Toybox | BusyBox 
# of files “compilable | uncompilable” | 28 | 0 230 | 0 516 | 39 
Median runtime (sec) and SIOR 77 31 47 14 512 
        
In Table 3, the median desugaring times across all three pro- 
grams are between 47 and 77 seconds, showing that SugarC is ef- 
ficient in desugaring many programs. The two files that took the 
longest time to complete were both from Toybox (posix/ps.c and 
pending/traceroute.c), which took 586 and 614 seconds, respectively. 
The longest running times for a file on axTLS and BusyBox were 
302 seconds and 484 seconds, respectively. After manual investiga- 
tion, we conjecture that the overhead in ps.c was likely due to a 
constant array of structs defined in the global scope named typos 
, which is referenced frequently throughout the remainder of the 
code. The array uses va_args, which causes a series of type errors 
that have a multitude of type errors in many variations. The over- 
head in traceroute.c was likely due to a 60 line switch statement 
where every case is a macro definition. 
Among the 39 files that SugarC could not desugar or had errors 
in its output, SugarC did not produce desugared results in 20 files, 
and the desugared files could not be compiled by GCC in 19 Busy- 
Box files. For the 19 files not desugared in BusyBox, 15 files used 
statements unsupported by SugarC, while the remaining 4 either 
took longer than an hour to execute or ran out of memory. Manual 
investigation of the 4 files that ran into timeout or memory issues 
revealed two issues. Either the file had a large series of consecutive 
#ifdef statements which led to a large multitude of parser branches, 
or the file had a long list of conditional values inside of an enum 
or list, which caused exponential explosion. 
For the 20 desugared files that could not be compiled, the recur- 
ring errors were (1) an inability to evaluate expressions, which led 
to negative-sized arrays, and (2) assembly statements looking for 
registers that did not exist; both issues were discussed in Section 
3.3. The other encountered issues are: (1) the inability to differen- 
tiate between constant variables and constant numbers when get- 
ting addresses; (2) external declarations showing up later as static 
declarations; (3) an unidentified instance where field names in a 
struct initialization were not renamed; (4) incomplete struct types 
not being marked as errors. Future updates to our data structures 
for representing types would allow us to correct the first issues, 
and further work is needed to reconcile the cause of the third is- 
sue with the implementation. 
The median size of the original files was 3KB, while the median 
size of the desugared files was 1.2MB. However, the sizes between 
the original file and the desugared file do not have a linear rela- 
tionship. When fitting the linear regression with original file size 
as the independent variable and the desugared file size as the de- 
pendent variable, the R2 value was 0.155. On the other hand, the 
R? of the number of static conditionals (as independent variable) to 
the desugared file size (as dependent variable) was 0.511. We also 
find the largest desugared files were not the files with the most 
conditions, but files which featured a complex struct or global list 
with multiple static conditionals inside. 
2065Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:53:04 UTC from IEEE Xplore.  Restrictions apply. SugarC: Scalable Desugaring of Real-World Preprocessor Usage into Pure C 
We ran Clang Static Analyzer on the 774 desugared files across 
three programs. Clang Static Analyzer reported 336, 1122, and 3255 
alarms running on the desugared code of axTLS, Toybox, and Busy- 
Box, respectively. When performing its static analysis, Clang Static 
Analyzer checks for certain function names (e.g., malloc) to find all 
errors besides those of the type Dead store and Logic error. Since 
SugarC renames all functions and variables during the desugaring 
process, Clang Static Analyzer was only able to produce bug re- 
ports of these two types in the desugared code. Nonetheless, this 
provides further evidence that SugarC produced meaningful trans- 
lations. 
6 THREATS TO VALIDITY 
There are two potential threats to the validity of our evaluation. 
First, DesugarBench may not represent all language features and 
could introduce bias toward SugarC. To mitigate this, we constructed 
the benchmark programs to cover the grammar, including cases 
currently not supported by SugarC (e.g., K&R). In addition, the au- 
thor who constructed DesugarBench did not have knowledge of 
SugarC’s implementation. Second, the three real-world programs 
used in the evaluation may not represent all C features and pre- 
processor usage. Indeed, we improved the SugarC implementation 
while desugaring these programs; we expect that other programs 
also have features SugarC currently does not support. Still, these 
programs are common targets of variability analysis [1, 21, 26, 33, 
35, 37], suitable for evaluating SugarC’s scalability. 
7 RELATED WORK 
Hercules and C RECONFIGURATOR. C RECONFIGURATOR [21] uses 
SuperC [16] to parse the code, and then uses Xtend [46] to perform 
the transformation. The transformation rules of C RECONFIGURA- 
TOR were only specified and proven on the idealized imperative 
language IMP. The prototype implementation was evaluated on 
simplified excerpts from BusyBox and the Linux kernel, as well 
as Libssh files [29]. As shown in Section 5.2, C RECONFIGURATOR 
has limited supported for many C features. SugarC, in constrast, 
specifies its transformation rules on a formal C grammar, and im- 
plements optimizations to support real-world C usage. 
Hercules [12, 41, 43] presents a tree transformation on Type- 
Chef’s variational AST [26]. Hercules also relies on TypeChef’s 
type checker to find type errors, which halts if it finds a type er- 
ror in any configurations, preventing Hercules from being able to 
transform such cases. Hercules transformed SQLite and BusyBox, 
albeit when provided with a feature model for the software. Unlike 
SugarC, Hercules’ transformation only has an informal descrip- 
tion, and thus only partial support for many C language features 
as shown in Section 5.2. Moreover, SugarC’s simultaneous type 
checking and desugaring approach allows for transforming pro- 
grams that are not type-safe in all configurations while preserving 
the compile-time errors as run-time errors. 
Variability-aware analysis and parsing. Different variability-aware 
static analyses have been developed in the past [3, 5, 8, 23, 27, 30, 32, 
38, 42]. These approaches often perform special-purpose analyses 
on variational data structures that represent both the preprocessor 
and C. For example, Rhein et al. [42] built data- and control-flow 
analyses on top of the variational ASTs and control flow graphs 
2066 ICSE ’22, May 21-29, 2022, Pittsburgh, PA, USA 
to detect bugs. SugarC takes a direction complementary to these 
variability-aware analyses, desugaring preprocessor usage into C 
to allow the desugared results to be used as a common intermediate 
language for variability-oblivious and variability-aware analyses. 
It is significant that our evaluation demonstrates that the desugar- 
ing approach is scalable because this may significantly reduce the 
engineering efforts to develop new variability-aware analyses. 
SugarC, as a syntax-directed translation, is closely related to 
past works on variability-aware parsing. TypeChef [25] performs 
both variability-aware parsing and type checking on a specified 
configuration space for a given file. The tool creates an AST that 
holds variability-aware information inside of it, which has been 
used as the basis for several variability-aware works, including 
variability-aware static analysis [37] and refactoring [31]. SuperC 
[16], which SugarC uses as the underlying parser, takes a differ- 
ent approach to also create a variational AST which uses several 
optimizations to improve the process. 
8 CONCLUSIONS 
This paper presented SugarC, a novel desugaring tool that uses a 
syntax-directed translation to transform preprocessor usage into 
pure C. SugarC performs type checking and desugaring simulta- 
neously to allow programs with syntactic and type errors in some 
configurations to be desugared, and these compile-time errors to 
be preserved as run-time errors. SugarC specifies its translation 
rules on real C grammar and includes novel optimizations to han- 
dle the challenging, real-world user-defined types. We create Desug- 
arBench to compare existing desugaring tools, Hercules and C RE- 
CONFIGURATOR, with SugarC. The results show that SugarC sup- 
ports many more C language features than past tools. Our evalua- 
tion also shows that SugarC is scalable to desugar three real-world 
programs and demonstrates the applicability of these results as in- 
puts to the Clang Static Analyzer. 
In the future, we plan to build an analysis framework that uses 
SugarC-desugared results as the intermediate language and develop 
new variability-aware analyses for bug detection. We will continue 
improving and maintaining SugarC to efficiently desguar many 
more real-world code and support complete language features. 
ACKNOWLEDGMENTS 
This work is supported by NSF grants CCF-1840934 and CCF- 1816951. 
REFERENCES 
[1] Iago Abal, Jean Melo, Stefan Stanciulescu, Claus Brabrand, Marcio Ribeiro, and 
Andrzej Wasowski. 2018. Variability Bugs in Highly Configurable Systems: A 
Qualitative Analysis. ACM Trans. Softw. Eng. Methodol. 26, 3, Article 10 (Jan. 
2018), 34 pages. https://doi.org/10.1145/3149119 
AV. Aho, AV. Aho, R. Sethi, J.D. Ullman, and J.D. Ullman. 1986. Compilers, Prin- 
ciples, Techniques, and Tools. Addison-Wesley Publishing Company. 
Sven Apel, Christian Kastner, Armin Gréflinger, and Christian Lengauer. 2010. 
Type safety for feature-oriented product lines. Automated Software Engineering 
17, 3 (2010), 251-300. 
axTLS. 2016. axTLS Embedded SSL. http://axtls.sourceforge.net 
Eric Bodden, Tarsis Tolédo, Marcio Ribeiro, Claus Brabrand, Paulo Borba, and 
Mira Mezini. 2013. SPLLIFT: Statically Analyzing Software Product Lines in 
Minutes Instead of Years (PLDI ’13). Association for Computing Machinery, New 
York, NY, USA, 355-364. https://doi.org/10.1145/2491956.2491976 
[6] Busybox. 2021. BUSYBOX. https://busybox.net 
[7] CBMC. 2021. C Bounded Model Checker. https://github.com/diffblue/cbmc 2sAuthorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:53:04 UTC from IEEE Xplore.  Restrictions apply. ICSE ’22, May 21-29, 2022, Pittsburgh, PA, USA 
[8] 
xs 
[10 
{11 
[12 
[13 
[14 
[15] 
[16] 
[23 
[24 
[25 
[26 
[27] 
[28] 
[31] 
[32] Andreas Classen, Patrick Heymans, Pierre-Yves Schobbens, Axel Legay, and 
Jean-Frangois Raskin. 2010. Model checking lots of systems: efficient verifica- 
tion of temporal properties in software product lines. In Proceedings of the 32nd 
ACM/IEEE International Conference on Software Engineering-Volume 1. ACM, 
335-344. 
Myra B. Cohen, Peter B. Gibbons, Warwick B. Mugridge, and Charles J. Col- 
bourn. 2003. Constructing test suites for interaction testing. In Proceedings of the 
25th International Conference on Software Engineering (Portland, Oregon) (ICSE 
03). IEEE Computer Society, Washington, DC, USA, 38-48. http://dl.acm.org/ 
citation.cfm?id=7768 16.776822 
Leonardo De Moura and Nikolaj Bjgrner. 2008. Z3: An Efficient SMT Solver. In 
Proceedings of the Theory and Practice of Software, 14th International Conference 
on Tools and Algorithms for the Construction and Analysis of Systems (Budapest, 
Hungary) (TACAS’08/ETAPS’08). Springer-Verlag, Berlin, Heidelberg, 337-340. 
Martin Erwig and Eric Walkingshaw. 2011. The Choice Calculus: A Represen- 
tation for Software Variation. ACM Trans. Softw. Eng. Methodol. 21, 1, Article 6 
(Dec. 2011), 27 pages. https://doi.org/10.1145/2063239.2063245 
Florian Garbe. 2017. Performance Measurement of C Software Product Lines. Mas- 
ter’s thesis. 
Alejandra Garrido and Ralph Johnson. 2005. Analyzing Multiple Configurations 
of a C Program. In ICSM. 379-388. 
Brady J Garvin, Myra B Cohen, and Matthew B Dwyer. 2009. An improved meta- 
heuristic search for constrained interaction testing. In 2009 1st International Sym- 
posium on Search Based Software Engineering. IEEE, 13-22. 
Paul Gazzillo. 2017. Kmax: Finding All Configurations of Kbuild Makefiles Stat- 
ically. In Proceedings of the 2017 11th Joint Meeting on Foundations of Software 
Engineering (Paderborn, Germany) (ESEC/FSE 2017). ACM, New York, NY, USA, 
279-290. https://doi.org/10.1145/3106237.3106283 
Paul Gazzillo and Robert Grimm. 2012. SuperC: Parsing All of C by Taming the 
Preprocessor. In Proceedings of the 33rd ACM SIGPLAN Conference on Program- 
ming Language Design and Implementation (Beijing, China) (PLDI ’12). ACM, 
New York, NY, USA, 323-334. https://doi.org/10.1145/2254064.2254103 
gnu. 2014. GNU Bison. https://www.gnu.org/software/bison/ 
gnu. 2019. Using the GNU Compiler Collection (GCC). _ https://gcc.gnu.org/ 
onlinedocs/gec-9.4.0/gec/ 
Hercules. 2017. Hercules. https://github.com/joliebig/Hercules 
Infer. 2021. Infer static analyzer. https://github.com/facebook/infer 
Alexandru Florin Iosif-Lazar, Jean Melo, Aleksandar S. Dimovski, Claus 
Brabrand, and Andrzej Wasowski. 2017. Effective Analysis of C Programs by 
Rewriting Variability. CoRR (2017). 
ISO. 2011. ISOAEC 9899:2011 Information technology — Programming languages 
— C. International Organization for Standardization, Geneva, Switzerland. 
683 (est.) pages. http://www. iso.org/iso/iso_catalogue/catalogue_tc/catalogue_ 
detail.htm?csnumber=57853 
Christian Kastner, Sven Apel, Thomas Thiim, and Gunter Saake. 2012. Type 
checking annotation-based product lines. ACM Transactions on Software Engi- 
neering and Methodology (TOSEM) 21 (2012). 
Christian Kastner, Paolo G Giarrusso, Tillmann Rendel, Sebastian Erdweg, Klaus 
Ostermann, and Thorsten Berger. 2011. Variability-aware parsing in the pres- 
ence of lexical macros and conditional compilation. In ACM SIGPLAN Notices, 
Vol. 46. ACM, 805-824. 
Christian Kastner, Paolo G. Giarrusso, Tillmann Rendel, Sebastian Erdweg, 
Klaus Ostermann, and Thorsten Berger. 2011. Variability-Aware Parsing in the 
Presence of Lexical Macros and Conditional Compilation. SIGPLAN Not. 46, 10 
(Oct. 2011), 805-824. https://doi.org/10.1145/2076021.2048128 
Christian Kastner, Klaus Ostermann, and Sebastian Erdweg. 2012. A Variability- 
aware Module System. In OOPSLA. ACM, 773-792. 
Kim Lauenroth, Klaus Pohl, and Simon Toehning. 2009. Model checking of do- 
main artifacts in product line engineering. In 2009 IEEE/ACM International Con- 
ference on Automated Software Engineering. IEEE, 269-280. 
Alex Lazar and Jean Melo. 2017. C Reconfigurator. _ https://github.com/itu- 
square/c-reconfigurator 
libssh. 2021. The SSH library! https://www.libssh.org/ 
Jorg Liebig, Sven Apel, Christian Lengauer, Christian Kastner, and Michael 
Schulze. 2010. An analysis of the variability in forty preprocessor-based soft- 
ware product lines. In Proceedings of the 32nd ACM/IEEE International Conference 
on Software Engineering-Volume 1. ACM, 105-114. 
Jorg Liebig, Andreas Janker, Florian Garbe, Sven Apel, and Christian Lengauer. 
2015. Morpheus: Variability-Aware Refactoring in the Wild. In 2015 IEEE/ACM 
37th IEEE International Conference on Software Engineering, Vol. 1. 380-391. 
https://doi.org/10.1109/ICSE.2015.57 
Jorg Liebig, Alexander von Rhein, Christian Kastner, Sven Apel, Jens Dérre, and 
Christian Lengauer. 2013. Scalable Analysis of Variable Software. In Proceed- 
ings of the 2013 9th Joint Meeting on Foundations of Software Engineering (ES- 
EC/FSE 2013). ACM, New York, NY, USA, 81-91. https://doi.org/10.1145/2491411. 
2491437 event-place: Saint Petersburg, Russia. 
2067 [33 
[34 
[35 
[36 
[37 
[43] 
[44 STS aae Zachary Patterson, Zenong Zhang, Brent Pappas, Shiyi Wei, and Paul Gazzillo 
Flavio Medeiros, Christian Kastner, Marcio Ribeiro, Rohit Gheyi, and Sven Apel. 
2016. A comparison of 10 sampling algorithms for configurable systems. In Pro- 
ceedings of the 38th International Conference on Software Engineering. ACM, 643- 
654. 
Jean Melo, Claus Brabrand, and Andrzej Wasowski. 2016. How Does the Degree 
of Variability Affect Bug Finding?. In Proceedings of the 38th International Con- 
ference on Software Engineering (Austin, Texas) (ICSE ’16). ACM, New York, NY, 
USA, 679-690. https://doi.org/10.1145/2884781.2884831 
Austin Mordahl. 2019. Toward Detection and Characterization of Variability 
Bugs in Configurable C Software: An Empirical Study. In 2019 IEEE/ACM 41st 
International Conference on Software Engineering: Companion Proceedings (ICSE- 
Companion). 153-155. https://doi.org/10.1109/ICSE-Companion.2019.00064 
Zachary Patterson, Zenong Zhang, Brent Pappas, Shiyi Wei, and Paul Gazzillo. 
2021. SugarC: Scalable Desugaring of Real-World Preprocessor Usage into Pure 
C. https://doi.org/10.528 1/zenodo.5915048. 
Alexander Von Rhein, JORG Liebig, Andreas Janker, Christian Kastner, and Sven 
Apel. 2018. Variability-Aware Static Analysis at Scale: An Empirical Study. ACM 
Trans. Softw. Eng. Methodol. 27, 4, Article 18 (Nov. 2018), 33 pages. https://doi. 
org/10.1145/3280986 
Thomas Thiim, Sven Apel, Christian Kastner, Martin Kuhlemann, Ina Schaefer, 
and Gunter Saake. 2012. Analysis strategies for software product lines. School 
of Computer Science, University of Magdeburg, Tech. Rep. FIN-004-2012 (2012). 
Toybox. 2021. Toybox. https://github.com/landley/toybox 
ubuntu. 2018. Ubuntu 16.04.7 LTS (Xenial Xerus). https://releases.ubuntu.com/ 
16.04/ 
Alexander von Rhein. 2016. Analysis strategies for configurable systems. Ph.D. 
Dissertation. Universitat Passau. 
Alexander von Rhein, Jérg Liebig, Andreas Janker, Christian Kastner, and Sven 
Apel. 2018. Variability-Aware Static Analysis at Scale: An Empirical Study. ACM 
Transactions on Software Engineering and Methodology 27, 4 (2018), Article No. 
18. https://doi.org/10.1145/3280986 
Alexander von Rhein, Thomas Thiim, Ina Schaefer, Jorg Liebig, and Sven Apel. 
2016. Variability encoding: From compile-time to load-time variability. J. Log. Al- 
gebraic Methods Program. 85, 1 (2016), 125-145. https://doi.org/10.1016/j.jlamp. 
2015.06.007 
Eric Walkingshaw, Christian Kastner, Martin Erwig, Sven Apel, and Eric Bodden. 
2014. Variational Data Structures: Exploring Tradeoffs in Computing with Vari- 
ability. In Proceedings of the 2014 ACM International Symposium on New Ideas, 
New Paradigms, and Reflections on Programming & Software (Portland, Oregon, 
USA) (Onward! 2014). Association for Computing Machinery, New York, NY, 
USA, 213-226. https://doi.org/10.1145/2661136.2661143 
John Whaley. 2007. JavaBDD. http://javabdd.sourceforge.net/. 
xtend. 2021. Java with spice! http://www.eclipse.org/xtend/ 
C. Yilmaz, M. B. Cohen, and A. A. Porter. 2006. Covering arrays for efficient fault 
characterization in complex configuration spaces. IEEE Transactions on Software 
Engineering 32, 1 (Jan. 2006), 20-34. https://doi.org/10.1109/TSE.2006.8Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:53:04 UTC from IEEE Xplore.  Restrictions apply. 