Learning and Programming Challenges of Rust:
A Mixed-Methods Study‚àó
Shuofei Zhu
Pennsylvania State University
USAZiyi Zhang‚Ä†
University of Wisconsin-Madison
USABoqin Qin
China Telecom Cloud Computing
China
Aiping Xiong
Pennsylvania State University
USALinhai Song
Pennsylvania State University
USA
ABSTRACT
Rustisayoungsystemsprogramminglanguagedesignedtoprovide
boththesafetyguaranteesofhigh-levellanguagesandtheexecu-
tion performance of low-level languages. To achieve this design
goal, Rust provides a suite of safety rules and checks against those
rules at the compile time to eliminate many memory-safety and
thread-safety issues. Due to its safety and performance, Rust‚Äôs pop-
ularityhasincreasedsignificantlyinrecentyears,andithasalready
been adopted to build many safety-critical software systems.
Itiscriticaltounderstandthelearningandprogrammingchal-
lenges imposed by Rust‚Äôs safety rules. For this purpose, we first
conducted an empirical study through close, manual inspection of
100 Rust-related Stack Overflow questions. We sought to under-
stand (1) what safety rules are challenging to learn and program
with, (2) under which contexts a safety rule becomes more difficult
toapply,and(3)whethertheRustcompilerissufficientlyhelpful
in debugging safety-rule violations. We then performed an online
surveywith101Rustprogrammerstovalidatethefindingsofthe
empiricalstudy. Weinvited participantstoevaluate programvari-
antsthatdifferfromeachother,eitherintermsofviolatedsafety
rulesorthecodeconstructsinvolvedintheviolation,andcompared
the participants‚Äô performance on the variants. Our mixed-methods
investigationrevealedarangeofconsistentfindingsthatcanbenefit
Rust learners, practitioners, and language designers.
CCS CONCEPTS
‚Ä¢Software and its engineering ‚ÜíGeneral programming lan-
guages;Development frameworks and environments.
KEYWORDS
Rust; Programming Challenges; Empirical Study; Online Survey
‚àóThis work was supported in part by NSF grants CNS-1955965 and CCF-2145394 and
an IST seed grant from Pennsylvania State University.
‚Ä†Ziyi Zhang contributed equally with Shuofei Zhu in this work.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
onthe firstpage.Copyrights forcomponentsof thisworkowned byothersthan the
author(s)mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,or
republish,topostonserversortoredistributetolists,requirespriorspecificpermission
and/or a fee. Request permissions from permissions@acm.org.
ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA
¬© 2022 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ACM ISBN 978-1-4503-9221-1/22/05...$15.00
https://doi.org/10.1145/3510003.3510164ACM Reference Format:
Shuofei Zhu, Ziyi Zhang, Boqin Qin, Aiping Xiong, and Linhai Song. 2022.
LearningandProgrammingChallengesofRust:AMixed-MethodsStudy.
In44th International Conference on Software Engineering (ICSE ‚Äô22), May
21‚Äì29, 2022, Pittsburgh, PA, USA. ACM, New York, NY, USA, 13 pages. https:
//doi.org/10.1145/3510003.3510164
1 INTRODUCTION
Rust is a new programming language designed to build safe and
efficientsystemssoftware[ 31,36].ThekeyinnovationofRustis
its suite of safety rules that are checked against during compila-tion to catch memory-safety and thread-safety issues. Alongside
the language‚Äôs safety mechanism, Rust maintains its compiled exe-
cutable programs to be as efficient as C programs. Due to its safety
andefficiency,Rusthasbecomeincreasinglypopular;ithasbeen
rated the most beloved programming language every year since2016 [
55‚Äì59,61] and was the fifth fastest growing language on
GitHub in 2018 [ 37]. Rust has already been adopted by many open-
sourceprogrammersandbigtechcompaniestobuildsafety-critical
software [28, 34, 41, 42, 45, 54].
Rust‚Äôssafetymechanismcentersaroundtwoimportantconcepts:
ownership andlifetime. The basic safety rule requires each value to
have exactly one owner variable, and the value is freed when its
owner variable ends its lifetime. T o improve pr ogramming flexibil-
ity, Rust extends this basic rule to a suite of extended rules, such
as allowing ownership to be moved to another owner or to be bor-
rowedusingareference,andstillguaranteesmemorysafetyand
threadsafety.Rust‚Äôssafetymechanismiselegantandeffective.It
essentially prohibits programs from having mutability and alias-
ingatthesametime,andinherentlyavoidsmanyseverememory
bugs(e.g.,useafterfree)andconcurrencybugs( e.g.,datarace).A
recent empirical study reports that if a program is written solely in
safeRustcode,thenitwillhavenomemorybugs,confirmingthe
effectiveness of Rust‚Äôs safety mechanism in practice [43].
Unfortunately, Rust is known to have a steep learning curve
and is difficult to program in practice [ 1,73]. The ease with which
programmerscanwritecodethatviolatesRust‚Äôssafetyrulesand
is rejected by the Rust compiler comes down to two reasons. First,
Rust‚Äôssafetymechanismisunique,andtherelatedgrammarand
semanticsareverydifferentfromtraditionalsystemsprogramminglanguages(e.g.,C/C++)[
30].Thus,itisdifficultforprogrammersto
migrate the programming experience they have gained from other
languages to coding in Rust [ 51]. Second, the design philosophy
of Rust is to reject all suspicious code and force programmers to
12692022 IEEE/ACM 44th International Conference on Software Engineering (ICSE)
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:26:40 UTC from IEEE Xplore.  Restrictions apply. ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA Shuofei Zhu, Ziyi Zhang, Boqin Qin, Aiping Xiong, and Linhai Song
1
234567
89
10
11
1213
14
1516171819 let r1 = &mut out1.a[0];
20 let r3 = &mut out2.a.0;
21 let r2 = &out1.a[1];
22 let r4 = &out2.a.1;
23 *r1 += 1;
24 *r3 += 1;
25 println!("{:?}", r2);
26 println!("{:?}", r4);
PC-1 changes to PC-3 #![allow(unused_variables)]
   struct Inner { inner: u8 } struct Outer1 { a: [Inner; 2] } struct Outer2 { a: (Inner, Inner) }
 fn test(in1: &mut Inner, in2: &Inner){} fn main() {
   let mut out1 = Outer1 { a:     [Inner {inner: 1}, Inner {inner: 3}]};   let mut out2 = Outer2 { a:      (Inner {inner: 1}, Inner {inner: 3})};-  test(&mut out1.a[0], &out1.a[1]);+  let (first, rest) = out1.a.split_first_mut().unwrap();+  test(first, &rest[0]);   test(&mut out2.a.0, &out2.a.1); }
(a) Rust programerror[E0502] : cannot borrow `out1.a[_]` as immutable because it is also 
borrowed as mutable 
  --> demo-snippet3.rs:14:24    | 
14 |   test(&mut out1.a[0], &out1.a[1]); 
   |   ---- --------------   ^^^^^^^^^^ immutable borrow occurs here  
   |   |    |    |   |    mutable borrow occurs here 
   |   mutable borrow later used by call    | note: `a` is an array and can only be borrowed as a whole 
   |  4 | struct Outer1 { a: [Inner; 2] } 
   |                 ^  
 error: aborting due to previous error 
 For more information about this e rror, try `rustc --explain E0502`.  
(b) Compiler error messages
Figure 1: A Rust program and its compile error. In Figure 1a, the program is PC-1 in the survey; the red-colored tokens violate a safety rule;
and ‚Äú+‚Äù and ‚Äú-‚Äù denote code added and deleted to fix the violation. We replaced lines 14 and 17 with the code in the cyan-colored rectangle to create
PC-3inthesurvey.InFigure1b,thepartinthegreen-coloredrectangledoesnotbelongtotheoriginalerrormessages,andweaddeditinthesurvey.
prove their code follows all safety rules. Rust‚Äôs safety checks are
strict, sometimes overly so, making Rust code hard to be compiled.
A piece of Rust code is shown in Figure 1a. Structs Outer1and
Outer2are declared atlines 4 and 5,respectively.The two structs
aresimilartoeachotherinthesensethatbothofthemonlycontain
one field with the same name and the same contents (two Inner
objects). However, the field of Outer1is an array, while the field
ofOuter2isatuple.Function test()takestwo Innerobjectsas
inputs. It uses a mutable reference to borrow the first Innerobject
and an immutable reference to borrow the second one. Function
test()iscalledatline14usingthetwo Innerobjectsinan Outer1
object as inputs. However, the Rust compiler reports an error on
thisline(Figure1b).Thereasonfortheerroristhattheelementsof
an array must be borrowed altogether in Rust (or after an element
isborrowed,allotherelementsinthesamearrayarealsoconsid-
ered as being borrowed), since the Rust compiler conservatively
assumesanindexcanaccessanyelementinanarray.Rustdoesnot
allowamutablereferencetocoexistwithotherreferencestothe
sameobjecttopreventsimultaneousmutabilityandaliasing.Array
out1.ahas already been mutably borrowed as the first parameter.
Thus, it cannot be borrowed again as the second parameter. Coun-
terintuitively, line 17is allowedby the compilerbecause different
tuple fields can be borrowed separately.
Figure1bshowstheerrormessagesreportedbytheRustcom-
piler. The compiler points out which ownership rule is violated,
where it is violated, and how it is violated, but it fails to provide
the most important information for the programmer that array
elements areborrowed together in Rust,causing the programmer
to go to Stack Overflow to ask for more explanations about the
code and the error messages [62].
The above case demonstrates the complexity of applying Rust‚Äôs
safety mechanism under concrete coding scenarios and the diffi-
cultyinwritingprogramsacceptedbytheRustcompiler.Besides
the safety rule that a mutable reference cannot coexist with an-
otherreferencetothesameobject,programmersmustalsoknow
how array (and tuple) elements are borrowed to avoid similar mis-
takes.Moreover,thecompilermaynotalwaysprovideallnecessary
information for programmers to understand and fix the errors.
Our ultimate goal is to facilitate the learning and programming
of Rust. We take the identification of the challenges imposed byRust‚Äôs safety rules as the first step. Those rules are unique and
complex.AsshownbytheempiricalstudyinSection3,theyindeed
cause challenges to Rust programmers in the real world. Rust is
stillevolving[ 10,67].LearningRustisacontinuousprocess,and
programmingRustinpracticeofteninvolvesstudyinghowtoapply
a safety rule under a particular coding context. Thus, we do not
differentiate learning from programming in this paper. Overall, we
aim to answer the following research questions (RQs):
‚Ä¢RQ-1:Which Rust safety rules are difficult to understand?
‚Ä¢RQ-2:Under which programming contexts is a safety rule more
challenging to apply?
‚Ä¢RQ-3:How helpful is the Rust compiler in resolving program-
ming errors due to safety-rule violations?
We adopted two approaches to answer these questions. We first
conducted anempiricalstudy onRust-related StackOverflowques-
tions, since programmers usually seek technical advice on Stack
Overflowforissuestheycannotresolveontheirown[ 2,14,69,74].
We then performed an online survey to validate the findings of
theempirical studyby closelyexamining howRust programmers
answer carefully designed survey questions.
We built two datasets for the empirical study. The larger one
contains 15,509 Rust-related Stack Overflow questions, and the
smalleronecontains100questionscausedbyviolationsofRust‚Äôs
safety rules. To answer RQ-1, we built a taxonomy for safety-rule
violations in the small dataset. The taxonomy contains two major
categories: complex lifetime computation andviolating ownership
rules. Each of these contains several sub-categories. To answer RQ-
2,weappliedtheLDAmodel[ 9]tothelargedataset,andcomputed
the correlation between violated safety rules and involved code
constructsforthesmalldataset.Wemanuallyinterpretedtheresults
toidentifyscenarioswhereasafetyruleismorechallengingtoapply.
Toanswer RQ-3,weexaminedwhethertheRustcompilerprovides
allnecessaryinformationfordebuggingsafety-ruleviolationsin
the small dataset.
The empirical study yielded several important findings. First,
Rust‚Äôssafetyrulesaredifficultforprogrammerstoapplyinpractice,andcomputingalifetimeismorechallengingthanapplyinganown-
ership rule. Moreover, some safety-rule violations are highly corre-
lated with particular code constructs, indicating the corresponding
rules are more challenging to apply to those code constructs. In
1270
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:26:40 UTC from IEEE Xplore.  Restrictions apply. Learning and Programming Challenges of Rust: A Mixed-Methods Study ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA
Table 1: Our findings in the empirical study and how the findings are validated in the online survey.
Findings in Empirical Study (Section 3) Validation in Online Survey (Section 4)
(1) Rust‚Äôs complex safety rules indeed bring unique challenges to its
programmers.(1) A large portion of participants at least ‚Äúsometimes‚Äù felt confused
about Rust‚Äôs lifetime (or ownership) rules.
RQ-1:Which Rust safety rules are difficult to understand?
(2) A Rust safety rule may be difficult to apply in concrete scenarios.(2) The average scores in marking program tokens that violated Rust‚Äôs
safety rules ranged from 0 .39 to 0.75.
(3)Programmersaskmorelifetime-relatedquestionsonStackOverflow
thanownership-relatedquestions,suggestingthatlifetimecomputation
is more difficult than applying ownership rules.(3) Participantswho‚Äúalways‚Äù understoodcompiler errorsfor lifetime-
ruleviolations(10.0%)weresignificantlyfewerthanthosewho‚Äúalways‚Äù
understood compiler errors for ownership-rule violations (39.6%).
(4)ProgramsPD-1andPD-2sharedthesamecodeconstructs,butPD-1
due to errors in lifetime computation was reported with a significantly
higherdifficultylevelthanPD-2causedbyviolatinganownershiprule.
(4)Themajority(91.8%)ofsafety-ruleviolationscanbefixedusingsafe
code or well-encapsulated interior unsafe libraries.N.A.
RQ-2:Under which programming contexts is a safety rule more challenging to apply?
(5)ThesameRustsafetyrulehasdifferentdifficultylevelswhenapplied
to different code constructs, and different safety rules have different
difficulty levels when applied to the same code construct.(5) Participants performed significantly better in labeling error tokens
for program PC-1 than for program PC-2, where PC-1 and PC-2 shared
the same code constructs but violated different safety rules.
(6)Anon-negligibleportionofparticipantswereconfusedbyhowto
apply the same rule to two different code constructs (array and tuple).
RQ-3:How helpful is the Rust compiler in resolving safety-rule violations?
(6) The Rust compiler may not provide all information necessary to
understand and fix violations of Rust‚Äôs safety rules.(7) Participants shown with enhanced compiler error messages per-formed significantly better than those with the original messages in
explaining how safety rules are violated for program PC-1.
addition,theRustcompilermaynotprovideallthenecessaryinfor-
mationforcomprehendingsafety-ruleviolations.Wesummarize
our findings in Table 1.
Intheonlinesurvey,wefirstaskedforparticipants‚Äôdemographic
information, technical background, and previous experience in
interacting with Rust‚Äôs safety mechanism and the Rust compiler.
WethenshowedthemfoursmallRustprograms,namedPA,PB,PC,
andPD.WeonlyaskedparticipantswhetherPAandPBcouldbe
compiledtotesttheirRustknowledge.WesampledPCandPDfromtwosetsofsimilarprogramvariants.Allvariantscontainedasafety-
rule violation; ho wever, they wer e different from each other either
in the safety rules they violated or in the code constructs those
violations involved. For both PC and PD, we asked participants to
(1) pinpointerror rootcauses by highlightingprogram tokens,(2)
evaluatehowdifficultitwastocomprehendtheerrorsbeforeand
afterseeingtheerrormessages,(3)selecttheviolatedrules,(4)ratethehelpfulnessoftheRustcompiler,and(5)describetheerrorroot
causes in their own words. We received 101 valid responses and
conductedextensivedataanalysisontheresponses.Asshownin
Table1,weconfirmedmanyfindingsoftheempiricalstudywith
significant confidence.
Overall, our mixed-methods investigation reveals what to learn
about Rust, how to learn it, and how to interpret compiler error
messages, all of which can benefit Rust learners and programmers.
Moreover,ourinvestigationpinpointsinformationmissedbythe
Rustcompilerwhenreporting safety-ruleviolationsandthuspro-
vides valuable guidance for the evolution of the Rust compiler.
In sum, this paper makes the following key contributions.
‚Ä¢We performed the first empirical study on Stack Overflow ques-
tions related to violations of Rust‚Äôs safety mechanism.
‚Ä¢Wegainedsixfindingsregardingtheprogrammingchallenges
caused by Rust‚Äôs safety rules and the helpfulness of the Rustcompiler in debugging safety-rule violations. Those findings can
be useful references for Rust learners and programmers.
‚Ä¢We conducted an online survey and confirmed our findings with
statistical significance.
All our study and survey results can be found at bit.ly/3uNAe88.
2 BACKGROUND
This section gives some background for this project, including
Rust‚Äôs safety mechanism and the information provided by the Rust
compiler for safety-rule violations.
2.1 Rust‚Äôs Safety Mechanism
Rust‚Äôssafetymechanismcentersaroundtwocriticalconcepts, own-
ershipandlifetime.Thebasicrulerequiresthatavalueisassociated
withoneandonlyone ownervariable,andthatthevalueisdropped
(freed) when its owner variable‚Äôs lifetime ends. Sometimes, the
place where a variable‚Äôs lifetime ends is easy to determine, such as
at the end of a function or at a matched curly bracket. However,
there are cases where lifetime computation is much more complex
than inspecting avariable‚Äôs lexical scope.To improve itsprogram-
ming flexibility, Rust extends its basic safety rule into a suite of
rules, while still guaranteeing memory safety and thread safety.
Ownership Move. Rust allows a value‚Äôs ownership to be moved to
a different owner variable or to a different scope (e.g., a function, a
closure), but it prohibits any access to the previous owner variable
after the move. For example, array foois moved to function max()
at line 6 in Figure 2, since the parameter type of function max()is
‚ÄúVec<i8>‚Äù, not ‚Äú& Vec<i8> ‚Äù like the function at line 2. Thus, the
Rust compiler reports an error at line 7, since foohas already been
moved and it cannot be accessed anymore.
OwnershipBorrow. Rustallowstotemporarilyborrowavariable‚Äôs
ownershipusingareference,whichcanbeimmutableforread-only
1271
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:26:40 UTC from IEEE Xplore.  Restrictions apply. ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA Shuofei Zhu, Ziyi Zhang, Boqin Qin, Aiping Xiong, and Linhai Song
1fn max(array: Vec<i8>) -> i8 { 71 }
2// fn max(array: &Vec<i8>) -> i8 { 71 }
3fn min(array: Vec<i8>) -> i8 { 8 }
4fn main() {
5let foo = vec![71, 23, 8];
6let max_val = max(foo);
7let min_val = min(foo);
8println!("{} {}", max_val, min_val);
9}
Figure 2: An example of ownership move. The program cannot
becompiled,since fooismovedatline6anditcannotbeusedatline7.1fn bar(x: &mut i32) {
2println!("{}", x);
3}
4fn main() {
5let mut a = 100;
6let y = &a;
7println!("{}", y);
8bar(&mut a);
9}
Figure3:Anexampleofownershipborrowing. Theprogram
can be compiled.
accesses or mutable for read-write accesses. A borrow ends at the
lastusagesiteofthereference.Rustrequiresthatareferencecan
only be used within its borrowed variable‚Äôs lifetime. Rust permits
multiple immutable references to a variable to exist at the same
time, but it only allows at most one mutable reference to a variable
at any time. These rules essentially guarantee all accesses to a
variable arewithin itslifetime and forbidsimultaneous mutability
and aliasing, avoiding many severe memory and concurrency bugs.
For example, in Figure 3, variable ais immutably borrowed by yat
line6andmutablyborrowedwhencalling bar()atline8.Although
thelexicalscopeof ydoesnotenduntiltheendoffunction main()
atline9,because yisnotusedafterline7,theRustcompilerdecides
that the borrow ends at line 7 and that it does not overlap with the
mutableborrowatline8.Thus,thecompilercompilestheprogram.
LifetimeAnnotation. Rustallowsprogrammerstoexplicitlyanno-
tateavariable‚Äôslifetimewithanapostrophefollowedbyanannota-
tionname.Lifetimeannotationscanbeusedatfunctiondeclaration
sites to specify the lifetime relationship among parameters and the
return value, and at struct declaration sites to describe the lifetime
requirement between a struct object and its reference fields. When
checkingafunctionorastruct,thecompilerreportserrorswhen
safety-ruleviolationsareinferredbasedonthelifetimeannotations
of the function or the struct. When calling a function, the compiler
inspects whether the real parameters satisfy the corresponding
annotations. Rustallows lifetimeelision to reducethe annotation
burden,andthecompilerautomaticallyinferselidedannotations
during safety checks.
Safe vs. Unsafe. AllcodediscussedsofarhasbeensafeRustcode.
Rust permits programmers to use the ‚Äú unsafe‚Äù keyword to bypass
some safety checks and conduct unsafe operations (e.g., pointer
operations,callinganunsafefunction).Unsafecodeissimilartothe
traditional C programming language. A piece of code or a function
can be unsafe. A function can also be interior unsafe by containingunsafecodeinternallybutexposingasafeAPIexternally,anditcanbeusedasasafefunction.Inthispaper,wefocusonunderstanding
programming challenges when coding safe code, since safe code
muststrictlyfollowRust‚Äôssafetymechanism,anditisusedmuch
more often than unsafe code in Rust programs [43].
2.2 Rust‚Äôs Compiler Error Messages
TheRustcompilerservesastheprimarycommunicationchannelbe-
tweenprogrammersandRust‚Äôssafetymechanism.Itchecksagainst
the aforementioned safety rules and reports an error when detect-
ingaruleviolation.Typically,apieceoferrormessagescontains
threecomponents:(1)theviolatedsafetyruleanditscorresponding
error code, (2) the lines of code or program tokens that violate therule,and(3)someexplanationsabouttheviolation.Forexample,
Figure1bshowstheerrormessagesfortheprograminFigure1a,
which present the error code (‚ÄúE0502‚Äù) and the violated rule (‚Äúcan-
not borrow ... as mutable‚Äù) at the beginning, underline program
tokens violating the rule in red, and underline several other tokens
in blue to provide more information. Sometimes error messages
contain suggestions about how to fix an error or even directly give
aconcretepatch.Moreover,theRustcompilerprovidesageneric
explanationforeacherrorcode,whichcanbeobtainedbyexecuting
rustc (e.g.,‚Äú rustc --explain E0502‚Äù in Figure 1b).
Unfortunately,Rust‚Äôssafetyrulesarecomplex[ 13,52]andsome
arecounterintuitive[43].Moreover,compilererrormessagesmay
be imprecise [ 21] or even contain misleading information [ 19,20].
Thus,compilererrormessagesmaynotbegoodenoughforRust
programmers to debug and fix safety-rule violations. In Section 3.4,
we combine cognitive task analysis [ 32] and manual inspection
of safety-rule violations in real Rust programs to systematically
evaluate error messages reported by the Rust compiler.
3 STUDYING STACK OVERFLOW QUESTIONS
This section presents our empirical study on Stack Overflow ques-
tions. Our study aims to answer the research questions previously
presented.ItsresultscanguidethelearningprocessofRustandim-
prove the interaction between programmers and the Rust compiler.
3.1 Methodology
We construct a large dataset and a small dataset for statistical anal-
ysis and manual inspection, respectively.
3.1.1 Large Dataset. The large dataset contains all Stack Overflow
questionsthatarelabeledwithtag‚ÄúRust‚Äù,haveascoregreaterthan
or equal to zero, and have at least one answer as of February 17,
2021. In total, there are 15,509 questions in the large dataset.
We randomly sampled 100 questions from the large dataset and
manuallyinspectedwhyprogrammers askedthemonStackOver-
flow.Commonreasonsincludenotknowinghowtousealibrary
function(26%),beingunabletounderstandRust‚Äôssafetyrules(23%),
being confused by type conversions and type checks in Rust (14%),
notknowinghowtoimplementoruseatrait(similartoaninterface
in Java) (9%), and failing to use FFI properly (7%).
Finding 1: Rust shares many programming challenges with tra-
ditional programming languages, but its complex safety rules pose
unique difficulties.
3.1.2 Small Dataset. We randomly sampled 100 questions related
to Rust‚Äôs safety mechanism from the large dataset to build the
smalldataset.Westudiedthesequestionsbyreadingtheirquestion
texts,answers,anddiscussions.Moreover,eachsampledquestion
1272
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:26:40 UTC from IEEE Xplore.  Restrictions apply. Learning and Programming Challenges of Rust: A Mixed-Methods Study ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA
Table 2: Root causes and fixes of violations in the small
dataset. Safe/Unsafe: directly writing safe/unsafe code; SL: safe li-
braries;IUL:interiorunsafelibraries;UL:unsafelibraries;andNo:
eight violations do not have fixes.
Root Causes Safe Unsafe SL IUL UL No Total
Complex Lifetime Computation
Intra-procedural 31 0 1 10 0 2 44
Inter-procedural 19 2 1 4 0 4 30
SimpleSyntax Error 3 0 0 0 0 0 3
Violating Ownership Rules
Move Rule 12 0 1 5 0 0 18
Borrowing Rule 9 1 3 8 0 2 23
Total 74 3 6 27 0 8 118
containsacodesnippetfordescribingtheproblem.Basedonthe
snippets,wesuccessfullyimplementedstandaloneprogramsand
reproduced all problems offline. For eight questions, the programs
canbecompiled,butthecompilationcontradictsthequestioners‚Äô
understanding. We consider each of these questions to be a case
wheretheprogrammer‚Äôsunderstandingviolatesasafetyrule.Forall
otherquestions,theprogramscannotbecompiled.Amongthese,76
programscontainoneviolationofasafetyrule,14programscontain
two violations, and the remaining two contain three violations. In
total, there are 118 safety-rule violations in the small dataset.
3.2 Which Safety Rules Are Difficult?
To determine which safety rules are difficult and are more likely
to cause usage violations, we build a taxonomy for the root causes
of the violations in the small dataset. As shown in Table 2, we
first divide the root causes into complex lifetime computation and
violating ownership rules, as they are the two core concepts of
Rust‚Äôssafetymechanism.Wethenseparateeachofthesecategories
into several sub-categories.
3.2.1 ComplexLifetimeComputation. Lifetimecomputationmay
be much more complicated than referring to a variable‚Äôs lexical
scope.Seventy-sevenviolationsareduetocomplexlifetimecompu-tation.Formostofthem,programmersestimateavariable‚Äôslifetimetobelongerorshorterthanitactuallyis,thusviolatingasafetyrule.
Wefurtherdividetheseviolationsintothoseduetointra-procedural
lifetimecomputation,thoseduetointer-procedurallifetimecompu-
tation,andthosecausedbysyntaxerrorswhendeclaringastruct.
These sub-categories do not overlap with each other and cover all
cases of lifetime computation.
Intra-procedural Lifetime Computation. Lifetimecomputationmay
bedifficult evenfor caseswithin asingle function.Forty-fourvio-
lationsarein thiscategory,32ofwhichare caseswhereprogram-
mers miscompute variable lifetimes when using particular codeconstructs, including control flow constructs (e.g., if, loop), data
structures(e.g.,hashmap,vector),temporaryvariables,andprogram
constants. For example, SO#65682678 (Stack Overflow question65682678 [
63]) is caused by miscomputing the lifetime of a refer-
ence held by a closure, while both SO#63428868 and SO#51044568
are caused by errors when computing a lifetime inside a match
block. Eleven out of the 44 violations are due to unsatisfied life-
time requirements at a function declaration or a struct declaration.
Forexample,whendeclaringan asyncfunction,Rustrequiresan
explicit lifetime annotation for each input object. Violating this1struct Foo {}
2struct Bar2<'b> { x: &'b Foo,}
3
4impl<'b> Bar2<'b> {
5- fn f(&'b mut self)-> &'b Foo {
6+ fn f(&mut self)-> &'b Foo {
7 self.x
8}
9}10fn f4() {
11let foo = Foo {};
12let mut bar2 = Bar2 {
13 x: &foo };
14bar2.f();
15let z = bar2.f();
16}
Figure4:Anexampleofcomplexinter-procedurallifetime
computation. Thered-coloredtokensaretheroot-causetokens.‚Äú+‚Äù
and ‚Äú-‚Äù denote code added and deleted to fix the violation.
requirementistheroot causeofSO#62440972.Theremainingvio-lation is due to a lack of basic understanding of Rust.
Inter-procedural Lifetime Computation.
Thirtyviolationsaredue
to lifetime computation across function boundaries. Among them,
22 are cases where a real parameter does not satisfy the lifetimerequirement of its corresponding formal parameter. The remain-
ingeightarecausedbyunexpectedlifetimeextensionsthrougha
function call. Figure 4 shows one such example from SO#39827244.
Function f()is implemented for struct Bar2at line 5. It borrows a
Bar2object and returns its field x. Lifetime annotation 'bis speci-
fied for both input reference selfand the return value, so that the
questionerthoughttheborrowingofa Bar2objectendedwhenthe
correspondingreturnterminateditslifetime.Thequestioneralso
believed that since the return value at line 14 is not saved to any
variable, both the lifetime of the return and the borrow of bar2
ended at line 14. He was confused about how the function still
borrowed bar2afterline14andwhythecompilercomplainedthat
two mutable references to bar2exist at line 15. The reason is that
lifetime annotation 'bis also applied to struct Bar2at line 4, so
that the borrow conducted by function f()does not stop until the
borrowed object ends its lifetime. Thus, the borrow of bar2at line
14 ends at line 16, which is out of the questioner‚Äôs expectation.
Whendeclaringafunctionoravariable,programmersmayex-
plicitly specify all lifetime annotations or choose to elide some
annotations.Amongthe30violationsinthiscategory,16onlyin-
volveexplicitlifetimeannotations(e.g.,Figure4),andthelifetime
miscomputation or mismatchhappens at an elided annotation for
the remaining 14 cases (e.g., SO#40053550).
Simple Syntax Errors. Three violations are caused by the misuse
oflifetimeannotationswhendeclaringorimplementingastruct.For
example,thequestionerofSO#62422857onlyusedanapostrophe
to annotate a struct field without providing an annotation name.
3.2.2 Violating Ownership Rules. Ownership rules can be divided
intomoverulesandborrowingrules[ 50].Amongthe41ownership-
rule violations in the small dataset, 18 of them violate a move rule,
and the remaining 23 do not comply with a borrowing rule.
Move Rule Violations. A variable cannot be accessed after it is
moved.Non-compliancewiththisrequirementcauses18violations.
Of these,16 violationsinvolve (complex) programconstructs. For
example, SO#65873356 is caused by accessing an object that has
alreadybeenmovedtoacalledfunction.Asanotherexample,when
an object is moved to a closure, it may be unclear to programmers
whetherthemovehappensattheclosure‚Äôscreationsiteoratthe
locationwheretheclosureisfirstlyused,whichistherootcause
of SO#62125100. The remaining two cases are very simple, and
1273
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:26:40 UTC from IEEE Xplore.  Restrictions apply. ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA Shuofei Zhu, Ziyi Zhang, Boqin Qin, Aiping Xiong, and Linhai Song
we speculate the questioners asked the corresponding questions
because they did not know the move rule.
Borrowing Rule Violations. Misuseofreferencesleadsto23vio-
lations. Two of them are due to mistakenly borrowing a collection
of objects altogether, instead of a single element (e.g., Figure 1a).
Another two are cases where programmers intended to copy an
object using a reference but mistakenly copied the reference itself.
Moreover, 11 cases are due to using a reference to move an object,
which is not allowed in Rust. For example, ‚Äú a=* x‚Äù moves the ob-
jectreferencedby xiftheobjectdoesnotimplementthe Copytrait,
which confused the questioner of SO#35649968. In addition, mu-
tabilitymismatches(e.g.,changingavariableusinganimmutable
reference) cause two violations. Rust prohibits a closure from re-
turningamutablereferencesinceitleadstwomutablereferences
existingsimultaneously(oneisreturnedandtheotherisheldbythe
closure). Not complying with this rule causes three violations. The
remaining threeare due tonot knowinghow to usethe reference
counted library (Rc) or library APIs that take a reference as input.
Finding 2: Rust‚Äôs safety mechanism may be difficult to apply in
concrete usage scenarios.Finding 3:
More lifetime-related questions are asked on Stack Over-
flow than ownership-related questions, indicating lifetime computa-
tion is more challenging in Rust programming.
3.2.3 HowViolationsAreFixed? Weexaminewhetherunsafecode
isusedintheviolationpatchestounderstandwhetherprogrammers
can achieve the desired functionalities while complying with all
safetyrules.Sinceeightviolationsarecaseswhereprogrammers‚Äô
understanding (not implementation) conflicts with the safety rules
and therefore have no fix, we focus on the remaining 110 cases.
AsshowninTable2,onlythreeviolationsarefixedbywriting
unsafecodedirectly(column‚ÄúUnsafe‚Äù).Forexample,thequestioner
of SO#64274964 wants to use two editor objects to modify the
same image at the same time. Since the two editors change two
different parts of the image, there is no bug logically. However, the
Rust compiler does not allow the two editors to have two mutable
referencestotheimageatthesametime.Thepatchusespointersinunsafecodetohavetwowritersforthesameimagesimultaneously.
Another27violationsarepatchedwithinteriorunsafelibrary
functions (column ‚ÄúIUL‚Äù in Table 2). Although the interfaces ofthose functions are safe and programmers can use them as safe
functions,theyactuallycontainunsafecodeinternally.Forexam-
ple, SO#57766918 is patched by calling interior unsafe function
into_iter() [48].
All other violations are fixed by writing safe code directly or
using safe library functions (columns ‚ÄúSafe‚Äù and ‚ÄúSL‚Äù in Table 2).For example, SO#39827244 in Figure 4 is fixed by removing the
lifetimeannotation of selfto breakthelifetime bindingbetween
the borrow conducted by function f()and the borrowed Bar2
object,andSO#62491845inFigure1aisfixedbycallingsafestandard
libraryfunction split_first_mut() [49],whichreturnsthefirst
element of the input array. These patches only involve safe code.
Finding 4: The majority of safety-rule violations are fixed with
safe code, and a small portion of violations are patched using well-
encapsulatedinteriorunsafelibraries.Programmersusuallydonot
have to write unsafe code by themselves to fix safety-rule violations.3.3 When Is a Safety Rule More Confusing?
Todetectwhenasafetyruleismoredifficult,wefirstapplytheLDA
model [9] to the large dataset. We then follow existing empirical
studiesonsoftwareartifacts[ 26,29,68]andcomputeastatistical
metriclifttomeasurethecorrelationbetweenroot-causecategories
and involved code constructs for the small dataset.
3.3.1 LDA Model. The LDA model can pinpoint the hidden topics
ofanalyzeddocuments,andthehiddentopicsofRust-relatedStack
Overflowquestions describewhen programmersfeel Rustis more
challenging. We take two steps to apply LDA. We first identify
questionsrelatedtosafetyrules.WethenrunLDAonthequestions
and manually interpret the identified topics.
WeuseStackOverflowtagstoidentifyquestionsrelatedtosafety
rules.FollowingthetaxonomyinSection3.2,wedividesafetyrulesintothreegroups:lifetime-relatedrules,moverules,andborrowingrules. We find 790, 28, and 848 questions respectively for these rule
groups in the large dataset.
For each group of rules, we use the Gensim package [ 46] to run
bigramLDAonallitsidentifiedquestions.WeremoveRustcodeinthose questions and consider only question titles, descriptions, and
answers in theanalysis. We preprocess the texts usingNLTK [ 7]
tolemmatizewordsandtoremovestopwordsandpunctuations.
We try each of the numbers from 5 to 30 as the topic number to
configure the model. We manually inspect the results for the topic
numberwithcoherencevalue[ 33]closesttozero,sinceacoherence
value closer to zero represents a better clustering result. The topic
numberswiththebestcoherencevalueforlifetime,borrowing,and
move are 5, 5, and 9, respectively.
After reading the top words and representative questions re-
ported by LDA, we identify several challenging scenarios for each
groupofrules.Forexample,204questionscontainthetopicofhowto use lifetime annotations in a trait, 32 questions contain the topicofhowtoborrowanelementfromacontainer,andthreequestions
are about moving an object in a matchblock. Rust programmers
can refer to our identified topics to enhance their understanding of
Rust‚Äôs safety rules.
3.3.2 Lift Correlation. We use the lift metric to measure the corre-
lation between the root-cause categories in Section 3.2 and code
constructs.TheliftofcategoryAandcodeconstructBiscomputed
aslift(ùê¥ùêµ)=ùëÉ(ùê¥ùêµ)
ùëÉ(ùê¥)ùëÉ(ùêµ), whereùëÉ(ùê¥ùêµ)represents the probability
of a violation that is due to A and also involves B, ùëÉ(ùê¥)means
the probability of a violation caused by A, and ùëÉ(ùêµ)denotes the
probabilityofaviolationinvolvingB.If lift(ùê¥ùêµ)equals1,Aisin-
dependentof ùêµ.Iflift(ùê¥ùêµ)islargerthan1,AandBarepositively
correlated, indicating when A is applied to B, it is more likely to
cause problems and it is more challenging. The larger the lift value
is, the more positively A and B are correlated. If lift(ùê¥ùêµ)is smaller
than 1, A and B are negatively correlated.
Among all code constructs with at least ten violations, root
cause ‚Äúinter-procedural lifetime computation‚Äù is most correlated
withthe'static codeconstruct.Theliftvalueis2 .36.Self-defined
annotations and generics are ranked as the second and the thirdmost correlated code constructs with ‚Äúinter-procedural lifetime
computation.‚ÄùTheirliftvaluesare2 .32and2.14,respectively.‚ÄúIntra-
procedural lifetime computation‚Äù is most correlated with standard
1274
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:26:40 UTC from IEEE Xplore.  Restrictions apply. Learning and Programming Challenges of Rust: A Mixed-Methods Study ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA
libraryBox, function declarations, and returnstatements, with
lift values 2 .19, 1.89, and 1 .87, respectively. The top three code
constructscorrelated with‚Äúmove rule violations‚Äùare loops(1 .96),
vectors (1 .38), and function calls (1 .19). The largest three lift values
for ‚Äúborrowing rule violations‚Äù are 1 .57 for hashmaps, 1 .35 for
iterators, and 1 .31 for closure declarations.
Many of those widely used code constructs have different lift
valueswith differentroot-cause categories.Forexample,function
declarations are positively correlated with ‚Äúintra-procedural life-
time computation‚Äù, but they are negatively correlated with the
other three categories. As another example, generics are positively
correlatedwith‚Äúinter-procedurallifetimecomputation‚Äù;however,
they are roughly independent of ‚Äúborrowing rule violations.‚Äù
Finding 5: Thesamerulehasdifferentdifficultylevelswhenapplied
todifferentcodeconstructs,anddifferentruleshavedifferentdifficulty
levels when applied to the same code construct.
3.4 Evaluating Compiler Error Messages
As we discussed earlier, 110 rule violations in the small dataset can
trigger compiler errors1. The Rust compiler associates 20 different
error codes to 103 of the 110 violations. Error code ‚ÄúE0382‚Äù (i.e.,
accessing a variable after it is moved) appears most frequentlyat 19 times. The compiler does not provide an error code for theremaining seven violations, which are caused by four different
uncommon problems.
We leverage the 110 violations to evaluate whether the compiler
providesallnecessaryinformationforprogrammerstocomprehend
safety-rule violations. This evaluation comes in two steps. We first
conduct cognitive task analysis [ 15] to identify the steps taken by
Rust experts to comprehend error messages. We then follow those
stepstoanalyzewhethertheinformationrequiredateachstepis
provided in the error messages for each violation.
Cognitive Task Analysis (CTA). ACTAtypicallyinterviewsthree
to five experts for a subject [ 11]. Our CTA aims to identify how
expertscomprehendRust‚Äôscompilererrormessages,ratherthantosampletheiropinionsonparticularcompilererrors.Thus,wechose
three paper authors as the CTA participants and another author as
the CTA analyst. All the CTA participants have at least one year‚Äôs
experience in programming Rust and use Rust on a weekly basis.
OurCTAcontainsathink-aloudobservationandasemi-structured
interview[ 12].Inthethink-aloudobservation,participantswere
asked about their general impression of Rust‚Äôs compiler errors and
their steps to understand compiler error messages. The analyst
recordedeachparticipant‚Äôsthink-aloudandanalyzedtherecordingtoidentifykeystepsincomprehendingerrormessages.Inthesemi-structuredinterview,theanalystaskedparticipantsquestionsabout
the key steps for the purpose of validation. The three participantsare interviewed separately to avoid premature consensus.
Both the think-aloud observation and the semi-structured in-
terviewwereaudio-recordedandautomaticallytranscribed.Each
participant was required to inspect another participant‚Äôs response.
The analyst combined all responses into a description of the proce-
dures,decisions/actions,concepts,andconditions/situationsused
by experts to comprehend Rust‚Äôs compiler error messages.
1The compiler version we evaluate is 1.50.0, which was released in February 2021.We further invited three externalexperts to evaluate the de-
scription.Werecruitedtheexpertsusingthesnowballmethod[ 22].
Specifically,weaskedourfriendstohelpfindacademicresearchers
whohadpublishedpapersonRustrecently,andourfriendsinturn
askedtheirfriendsforhelp.Allexternalexpertshaveatleasttwo
years‚Äô Rust experience and use Rust on a daily basis. We believe
theyhavesufficientexpertisetovalidatethedescriptionoftheerror
comprehension steps. The initial average proportion of agreement
was 0.7, a satisfactory agreement level [ 27], indicating our method
issufficient to capture how programmers comprehend Rust‚Äôs com-
piler errors. We updated a few description components based onthe external experts‚Äô comments. In the end, the description was
agreed upon by both internal and external experts.
Studying Violations. Wethenfollowthedescriptiontoexamine
whether error messages contain all the needed information for
comprehendingeachviolation.For59outofthe110violations,their
error messages contain all necessary information. Programmerscan use the highlighted code and the compiler‚Äôs explanations to
determine why the Rust compiler rejects the code. Error messages
misssomeimportantinformationfortheremaining51violations;
these fall into three categories.
First, fornine violations, theRust compiler failsto explain how
asafetyruleworksonaparticularcodeconstruct.Forexample,the
error messages in Figure 1b do not mention that elements of an
array cannot be borrowed individually in Rust.
Second, for 32 violations, the compiler fails to explain the key
stepsincomputingalifetimeoraborrowingrelationship.Forex-
ample,theerrormessagesassociatedwithSO#39827244inFigure4donotexplainwhytheborrowof
bar2atline14doesnotenduntil
the borrowed object terminates its lifetime at line 16.
Third,intheremainingtencases,thecompilerfailstoexplainthe
relationshipbetweentwolifetimeannotations,makingitdifficult
to understand the annotation mismatch in the error messages. For
example,SO#53835730isduetousingtworeferenceswithdifferentlifetimestocallafunctionthatrequirestwoinputstohavethesame
lifetime. The compiler simply complains that the second reference
does not live as long as the elided lifetime annotation of the first
reference.However,itdoesnotexplainthatthefirstreferenceistheinputofthecallerfunctionandhasalifetimelongerthanthecaller.
Incontrast,thesecondreferenceisareferencetoalocalvariable
and has a lifetime shorter than the caller.
Finding 6: The Rust compiler may not provide all information nec-
essary to comprehend violations of Rust‚Äôs safety rules.
4 SURVEYING RUST PROGRAMMERS
We conducted an online survey on Qualtrics [ 44] to validate the
findingspresentedinSection3.Thesurveywasapprovedbythe
institutional review board (IRB) office at the authors‚Äô university.
This section gives the survey details and survey results.
4.1 Methodology
4.1.1 Recruitment. Werequiredparticipantstobeatleast18years
old,notberesidingintheEuropeanEconomicArea,andhavesome
Rust coding experience. To recruit participants, we distributed our
survey by posting threads on Rust-specific forums and newsletters,
1275
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:26:40 UTC from IEEE Xplore.  Restrictions apply. ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA Shuofei Zhu, Ziyi Zhang, Boqin Qin, Aiping Xiong, and Linhai Song
Table 3: Program variants of PC and PD. PC-1 in Figure 1a
and PD-1 in Figure 4 are the two base programs. ( ùë•,ùë¶) represents
thatùë•participantswereassignedtheoriginalerrormessagesand ùë¶
participants were assigned the enhanced messages.
IDRoot Cause Code Construct Err.C od e #Responses
PC-1borrowing function, array E0502 34(16,18)
PC-2move function, array E0508 31
PC-3borrowing local variable, array E0502 32
PD-1interlifetime function, annotation E0499 36(19,17)
PD-2move function, annotation E0382 29
PD-3intralifetime closure, annotation E0499 32
sendingemailstoprogrammerswhorecentlycommittedcodeto
open-source Rust projects, and contacting industrial collaborators.
4.1.2 Stimuli. We presented four Rust programs (PA, PB, PC, and
PD) to each participant. All the programs were designed based
on the studied Stack Overflow questions in Section 3. PB can be
compiled,whiletheotherthreeallcontainsafety-ruleviolations.
PA is shown in Figure 2 and PB is shown in Figure 3. They areidentical for all participants. PC and PD are sampled from two
programsets.Eachsetcontainsabaseprogram(PC-1orPD-1)and
two variant programs that are synthesized by changing either the
baseprogram‚Äôsviolatedsafetyrule(PC-2orPD-2)orinvolvedcode
constructs (PC-3 or PD-3). Thus, we can compare survey resultsbetween a base program and its variants (e.g., PC-1 vs. PC-3) to
validate Finding 5 in Section 3.3.
Table3showstheinformationofprogramvariantsinthetwo
sets. PC-1 is the program in Figure 1a and it is the base program in
thePCset.TheRustcompilercomplainsthatamutablereference
toout1coexists with an immutable reference to out1with error
code ‚ÄúE0502.‚Äù We created PC-2 by changing function test()to
moveitsfirstparameter.Thenadifferentsafetyrulethatstatesthat
an array element cannot be moved out of its array was violated
(errorcode‚ÄúE0508‚Äù).AsshowninFigure1a,wechangedthecode
constructsinvolvedintheerrortocreatePC-3.Wereplacedthetwo
function calls at lines 14 and 17 with several borrowing operations
andassignments,withthepurposebeingtohave out1‚Äôsmutable
reference r1to coexist with out1‚Äôs immutable reference r3.I n
addition, we enhanced the compiler error messages of PC-1 by
explicitlyexplainingthatanarraycanonlybeborrowedasawhole
in Rust (the green-colored rectangle in Figure 1b).
PD-1 in Figure 4 is the base program of the PD set. How we
createdPD-2and PD-3issimilartohowwe created PC-2andPC-3.
See Table 3 for the violated rules and involved code constructs.
4.1.3 Procedure. Oursurveyconsistedofthreephases.Wediscuss
their details as follows.
Phase 1: Demographics and On-Board Experience in Rust. Wecol-
lected demographic information at the beginning of the survey to
validatewhetherparticipantswerequalified.Weaskedparticipants
toprovidetheiragegroups,locations,andyearsofRustexperience.
If a participant did not satisfy any recruitment requirement, our
surveyautomaticallyterminated.Wethenaskedparticipantsabout
their genders, races, and ethnic groups.
We gauged participants‚Äô expertise levels in Rust by asking them
how long they have learned Rust, how often they program withRust, how many lines of code are in the largest Rust programsthey have written, and whether Rust is their most frequently used
language. We also asked participants to self-rate their expertise on
a 10-point scale ranging from 1 (‚Äúbeginner‚Äù) to 10 (‚Äúexpert‚Äù).
Toexamineparticipants‚ÄôpreviousRustcodingexperience,we
askedparticipantshowoftentheyfeelconfusedaboutRust‚Äôsowner-ship/lifetimerulesandhowoftentheycanunderstandthecompiler
error messages whentheir code violates the safety rules.Possible
optionsinclude‚Äúnever‚Äù,‚Äúsometimes‚Äù,‚Äúmostofthetime‚Äù,and‚Äúal-
ways.‚Äù We also asked whether Rust has other language features
they consider challenging.
Phase 2: Evaluating Rust Programs. Weshowedparticipantsthe
four programsat thisphase. We firstasked themwhether PA and
PBcouldbecompiled.WethenexplicitlytoldthemthatbothPCand PD contained a safety-rule violation, and we asked them to
answer the following six questions.
‚Ä¢Q1:We asked participants to highlight the program tokens that
weretheerror‚Äôsrootcause(i.e.,tokenswheresafetyruleswere
violated). Figure 1a and Figure 4 show our expected highlighting
for PC-1 and PD-1, respectively.
‚Ä¢Q2:Werequestedparticipantstoratethedifficultyofidentifying
therootcauseona10-pointscale,where‚Äú1‚Äùmeans‚Äúveryeasy‚Äù
and ‚Äú10‚Äù means ‚Äúvery difficult.‚Äù
‚Ä¢Q3:Weaskedparticipantstochoosetheviolatedruleamongten
options, which included the correct answer, four rules similar to
the violated one, and five rules different from the violated one.
The similarity between two safety rules was computed as the
absolute value between their error codes [35].
‚Ä¢Q4:Weaskedparticipantstoratethedifficultyofrootcauseiden-
tification again after showing them the compiler error messages.
IfPC-1orPD-1wassampled,eithertheoriginalerrormessagesor
the enhanced version would be presented with equal probability.
‚Ä¢Q5:We requested participants to gauge the helpfulness of the
errormessagesona10-pointscale,where‚Äú1‚Äùmeans‚Äúnothelpful‚Äù
and ‚Äú10‚Äù means ‚Äúextremely helpful.‚Äù
‚Ä¢Q6:In this open-ended question, we asked participants to de-
scribehowthesafetyrulewasviolated.Wesuggestedtheyshould
consider in their answers the involved program constructs, how
therulewasappliedtothecodecontext,andwhythecompiler
highlighted some code.
Of the six questions, Q1, Q3, and Q6 had objectively correct
answers,whiletheotherthreeweresubjectiveinnature.Q4‚ÄìQ6
wereaskedaftershowingparticipantscompilererrormessages,and
their results can reveal the effects of viewing the error messages.
Phase 3: Post-Session Questions. Weaskedaboutparticipants‚Äôover-
all technical background at this stage, including years of program-
ming, favorite programming languages, self-rated programming
expertiselevels,howmanylinesofcodeareinthelargestprograms
theyhaveeverworkedon,andjobtitles.Wealsoaskedparticipants
why they learn or use Rust.
4.2 Survey Results
We distributed the survey from March 12 to April 6, 2021, and
received502completedresponses.Threepaperauthorsinspected
the responses together and identified 101 of them as valid. We
focused our data analysis on the valid responses. Invalid responses
includedthosethatwerefinishedinaveryshorttime(e.g.,fe w er
1276
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:26:40 UTC from IEEE Xplore.  Restrictions apply. Learning and Programming Challenges of Rust: A Mixed-Methods Study ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA
thanfiveminutes),hadopen-endedquestionanswersidenticalto
other responses, or came from unwanted sources.
4.2.1 Phase 1. The majority of the 101 participants were male
(91.1%) and in the 18‚Äì34 age range (85.1%). The top two most com-
mon locations were the U.S. (53.5%) and China (9.0%). Most par-
ticipants were White (47.5%) or Asian (27.7%). There were alsoresponses from Hispanics (5.9%) and African Americans (2.0%).
Overall,thedemographicsofourparticipantsrevealedconsiderable
diversityand reflectedthedemographicdistribution ofreal-world
Rust programmers [52, 53].
The participants were relatively experienced in Rust (69.3% had
learnedRustformorethanoneyearand63.3%hadimplemented
aRustprogramwithmorethan 1 ,000linesofcode).Rustwasthe
most frequently used language for 48.5% of the participants, and64.4% used Rust on a daily or weekly basis. The average level of
self-rated Rust expertise was 5 .3 out of 10, and the median was 6.
Most participants (85.1%) were at least ‚Äúsometimes‚Äù confused
by lifetime rules, but only 52.4% of them held the same feeling for
ownershiprules.Achi-squaredtestconfirmedthedifferencewas
significant ( ùúí2
(1)=23.6,p<0.001). Moreover, the proportion of
participants who could ‚Äúalways‚Äù understand compiler errors for
lifetime-ruleviolations(10.0%)wassignificantlysmallerthanthe
proportionofparticipantswhocould‚Äúalways‚Äùunderstandcompiler
errors for ownership-rule violations (39.6%, ùúí2
(1)=22.4,p<0.001).
These results are consistent with Finding 3 in Section 3.2.
Besides ownership and lifetime, other challenging language fea-
tures mentioned by more than ten participants were Rust‚Äôs typesystems (26), asynchronous programming (25), trait bounds and
generics (22), and macros (12).
4.2.2 Phase 2. Most (83.2%) of the participants correctly answered
thatPAcouldnotbecompiled,77.2%correctlyansweredthatPB
couldbecompiled,and70.3%correctlyansweredbothofthetwo
questions. These results show the participants had reasonably ade-
quate knowledge of Rust.
AsdiscussedinSection4.1.2,PCandPDweresampledfromtwo
different program sets. Each set contained three program variants.
Table3showsthenumberofparticipantsassignedwitheachvariant.
Weconducted aone-wayANOVAtestfor eachcombinationofa
program set and a research question (Q1‚ÄìQ6). The null hypothesis
wasthattherewasnodifferenceamongtheresultsobtainedfrom
thethreevariants.Thesignificancelevelwas0 .05.Sincetherewere
three pairwise comparisons in each program set, we adjusted allcomputedpairwise
ùëù-valuesusingBonferronicorrection[ 8].We
denotedadjusted ùëù-valuesusing ùëùùëéùëëùëó..Wemainlyfocusedon(PC-1,
PC-2), (PC-1, PC-3), (PD-1, PD-2), and (PD-1, PD-3), since variants
inthesepairsaredifferentfromeachotherintermsofeitherthe
violated rules or the involved code constructs (see Table 3).
Q1: Error Token Highlighting. We categorized program tokens
intothreetypesforgrading:root-causetokens,relevanttokens,andirrelevanttokens.Root-causetokensrepresentedwheresafetyrules
wereviolated(e.g.,thered-coloredtokensinFigure1aandFigure4).
Relevanttokenswerethoseclosetoorrelatedtorootcauses,but
that did not directly cause programming errors (e.g., the uncolored
tokens at line 14 in Figure 1a). Considering participants mightaccidentally highlight extra tokens close to the root causes, weTable4:Averagescoresandstandarderrors.
Q1andQ6were
manually graded with scores ranging from 0to1. Q3 was scored 0 or
1oncorrectness.Q2,Q4,andQ5are10-pointrating-scalequestions.
Standarderrorsareinparentheses. ùëú(ùëí)inasubscriptdenotesoriginal
(enhanced) error messages. Error messages were shown in between Q3
and Q4, and thus they did not impact Q1‚ÄìQ3.
ID Q1 Q2 Q3 Q4 Q5 Q6
PC-10.74 (0.06) 6.12 (0.44) 0.76 (0.07) 3.71 (0.47) 8.50 (0.32) 0.69 (0.05)
PC-1 ùëú- - -3.46 (0.74) 8.93 (0.32) 0.56 (0.08)
PC-1 ùëí- - -3.89 (0.62) 8.15 (0.51) 0.78 (0.07)
PC-20.39 (0.08) 5.27 (0.40) 0.48 (0.09) 4.03 (0.44) 7.45 (0.44) 0.56 (0.05)
PC-30.63 (0.06) 6.32 (0.37) 0.84 (0.06) 3.34 (0.41) 7.76 (0.40) 0.74 (0.03)
PD-10.53 (0.09) 7.63 (0.47) 0.22 (0.07) 5.28 (0.56) 7.19 (0.42) 0.66 (0.04)
PD-1 ùëú- - -4.67 (0.86) 7.33 (0.63) 0.68 (0.04)
PD-1 ùëí- - -5.82 (0.72) 7.06 (0.59) 0.65 (0.06)
PD-20.75 (0.07) 5.59 (0.51) 0.59 (0.09) 3.24 (0.46) 8.24 (0.38) 0.74 (0.05)
PD-30.46 (0.09) 7.09 (0.43) 0.37 (0.08) 4.57 (0.47) 6.83 (0.41) 0.58 (0.04)
did not penalize the selection of relevant tokens. Irrelevant tokens
had nothing to do with the root causes. Highlighting irrelevant
tokens indicated participants‚Äô misunderstanding of programming
errors, and thus we penalized the marking of irrelevant tokens.
Wecomputedascoreforeachanswerbydividingthenumberof
highlightedroot-causetokensbythenumberof highlightedroot-
causetokensandirrelevanttokens.Scoresrangedfrom0to1,with
larger scores representing better answers.
Theaveragehighlightingscoresfellintherangefrom0 .39to0.75
inTable4,implyingthatapplyingRust‚Äôssafetyrulesandidentifying
error tokens are challenging in general (Finding 2 in Section 3.2).
The ANOVAs confirmed that the main effect of program variant
was significant for both the PC set ( ùëù=0.004) and the PD set
(ùëù=0.030).Amongthefourcomparisonpairs,PC-1andPC-2were
the only pair to have a significant difference with ùëùùëéùëëùëó.equal to
0.003. Since PC-1 and PC-2 shared the same code constructs but
violateddifferentsafetyrules(seeTable3),thisresultrevealsthat
different safety rules can have different difficulty levels when applied
to the same code construct (Finding 5 in Section 3.3).
To understand how different code constructs impacted root-
causehighlighting,wefurtherexaminedthehighlightingresults
forthePCvariants,sincePC-1,PC-2,andPC-3allcontainedtwo
similar code constructs: array out1.aand tuple out2.a. For all
ofthesevariants,tokensrelatedtothearrayweretheroot-cause
tokens,whiletokensrelatedtothetuple(e.g.,thetokensatline17in
Figure 1a) were irrelevant and misleading. We counted how many
participants selected tuple-related tokens. The results for PC-1, PC-
2, and PC-3 were 10, 9, and 14, respectively. Such results suggestthatprogrammers can be confused when applying the same safety
rule to different code constructs, explaining Finding 5 in Section 3.3.
Q2 & Q4: Difficulty Ratings. Column ‚ÄúQ2‚Äù in Table 4 shows the
average difficulty ratings before participants saw the error mes-
sages.Themaineffectofprogramvariantwassignificantforthe
PDset(p=0.009)only.ForthetwocomparisonpairsinthePDset,
PD-1wassignificantlymoredifficultthanPD-2( ùëùùëéùëëùëó.=0.01),indi-
catingthatparticipantsperceivedtheerrordueto‚Äúinter-procedural
lifetime computation‚Äù to be more difficult to comprehend than the
errorcausedby‚Äúviolatingamoverule‚Äùonthesamecodeconstruct
(Finding3inSection3.2andFinding5inSection3.3).Therewas
no significant difference between PD-1 and PD-3.
1277
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:26:40 UTC from IEEE Xplore.  Restrictions apply. ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA Shuofei Zhu, Ziyi Zhang, Boqin Qin, Aiping Xiong, and Linhai Song
The average difficulty ratings showed the same pattern after
participants viewed the error messages (column ‚ÄúQ4‚Äù in Table 4).
Q3: Violated Rule Selection. Column ‚ÄúQ3‚Äù in Table 4 shows the
correctanswerratesforselectingviolatedsafetyrules.Themain
effect of program variant was significant for both PC variants ( p=
0.003) and PD variants ( p=0.008). Among the four comparison
pairs, only the correct answer rate of PD-1 was significantly lower
than that of PD-2 ( ùëùùëéùëëùëó.=0.008), demonstrating PD-1‚Äôs violated
safety rule was more difficult to identify than PD-2‚Äôs (Finding 5).
To understand the difficulty in identifying violated rules, we
inspected the wrongly selected options. In total, there were four
wrong options chosen by at least five participants, one for PC-2,
two for PD-1, and one for PD-3. PC-2 violated a move rule, but
six participants thought an object was borrowed again after being
mutablyborrowed inPC-2,violatingaborrowing rule.Thosepar-
ticipantsdidnotnoticethatfunction test()moved(notborrowed)
its input in PC-2. The lifetime computation of a mutable reference
in PD-1 was complex, and the lifetime overlapped with another
mutable reference to the same object. However, seven participants
thought the rule that had been violated was that an owner variable
cannot be used after the ownership is borrowed. This rule was also
violated in PD-1, but it was not as precise as the correct answer.
Five participants thought a reference was used beyond the bor-
rowedobject‚Äôslifetime.Theparticipantsnoticedthatthelifetime
computationwascomplex,sotheyguessedthislifetimerulewas
violated.ForPD-3,sixparticipantssaidthattheviolatedrulewas
the one that forbids moving an object through a reference, but the
program actually conducted a copy (not move). These results show
thatwithoutknowingthecorrectviolatedsafetyrule,programmers
easily inspected a programming error in a wrong direction.
Q5: Helpfulness of Compiler Error Messages. Column‚ÄúQ5‚ÄùinTa-
ble 4 shows theaverage helpfulness ratings of the errormessages.
PC-1hadthehighestaveragerating(8 .50),andPD-3hadthelowest
averagerating (6 .83).The maineffectofprogramvariant wassig-
nificantforthePDset( ùëù=0.039)only,andtherewasnosignificant
difference for the four comparison pairs.
Q6: Error Description in Programmers‚Äô Own Words. Wefirstdevel-
opedascoringrubricforgrading.Weidentifiedtwoscoringschemes
representingthe‚Äúwhat‚Äùaspectandthe‚Äúhow‚Äùaspectoferrorroot
causes.Wegavemoreweighttothe‚Äúhow‚Äùaspect(60%).Foreach
theme, we defined three score levels (30%, 60%, and 100%) and for-
malized the criteria at each level. Based on the rubric, two paper
authors graded participants‚Äô responses independently. The average
percentage of agreement between the two graders was 50%. The
two graders resolved the discrepancies between them by revisiting
the criteria over multiple discussions.
Column‚ÄúQ6‚ÄùinTable4showstheaveragescoreforeachpro-
gram variant. The highest score was 0 .74 for PD-2, and the lowest
score was 0 .56 for PC-2. The main effect of program variant was
significant for both the PC set ( ùëù=0.03) and the PD set ( ùëù=0.03),
but there was no significant difference for any comparison pairs.
We further inspected how participants answered Q6 together
with their answers to previous questions to deeply understand par-
ticipants‚Äôerrorcomprehensionprocess.ForPC-2,sixparticipants
selectedthataborrowingrulewasviolatedinQ3,whichwaswrong,
butfiveofthemcorrectlymentionedmoveorownershipintheirQ6answers.Weanticipatedthattheerrormessageshelpedthefiveparticipantsfigureoutthecorrectrootcause.ForPD-1,fivepartici-pants noticed the violation was due to the lifetime extension of the
borrow of bar2at line 14 (Figure 4). However, they thought the
extensionwas causedbythereturn atline7, asindicatedbytheir
explanations of Q6. This understanding was wrong; the extension
wasactuallycausedbythelifetimeannotations(i.e., 'b)atlines4
and 5. This result demonstrates that Rust‚Äôs safety rules are complex
inpracticeandthatalthoughprogrammersknowthatasafetyrule
hasbeenviolated,theymaynotknowthetruereasonfortheviolation.
Effect of Enhanced Error Messages. Wecreatedenhancedversions
of compiler error messages for PC-1 and PD-1. Since the error mes-sageswereshowntoparticipantsafterQ3,wecomparedtheeffects
of the enhanced version and the original version on Q4‚ÄìQ6 us-ing two-sample t-tests. The enhanced version of PC-1 showed a
significantlybetteraveragescorethantheoriginalversiononthe
objectivequestionQ6( ùëù=0.015).Moreover,fourparticipantsex-
plicitly mentioned the extra information we provided in PC-1‚Äôs
errormessagesintheirQ6answers.Theseresultsconfirmthat com-
piler error messages may not contain all necessary information for
Rust programmers to debug safety-rule violations and that providing
morefacilitatinginformationcanimproveprogrammers‚Äôperformance
(Finding 6 in Section 3.4).
Theenhancederrormessagesdidnotsignificantlyimpactpar-
ticipants‚Äô responses for either PC-1 or PD-1 on the two subjective
questions (Q4 and Q5) or for PD-1 on Q6.
4.2.3 Phase3. About75.2%oftheparticipantshadatleastthree
years‚Äôprogrammingexperience.Theaverageself-ratedprogram-
mingexpertisewas6 .3andthemedianwas 7.Abitlessthanhalf
(46.5%)oftheparticipantshadworkedonaprogramwithmorethan
10,000linesofcode.Thegeneraltechnicalbackgroundofthepar-
ticipants was consistent with their Rust background as surveyed in
Phase 1. The top two most common job titles/roles were ‚Äúsoftware
engineers‚Äù (43.6%) and ‚Äústudents‚Äù (31.2%). Besides Rust, the top
three programming languages with which the participants had the
mostexperiencewerePython,C/C++,andJavaScript.ThetopthreemostfavoriteRustfeaturesweresafety,performance,andlanguage
features (e.g., functional programming styles, pattern matching).
These results match our expectations of Rust programmers.
5 DISCUSSION
This section discusses the implications of our studies, threats to its
validity, and our procedures to reduce those threats‚Äô influence.
Implications to the Rust Community. Our findings can bene-
fittheRustcommunityfromfouraspects.First, Rustlearners can
spendmoreeffortonthepinpointedprogrammingscenarioswhere
a safety rule is especially challenging to gain a deeper understand-
ing of the rule. Second, for Rust programmers , our findings can re-
mindthemnottorelysolelyoncompilerfeedbackwhendebugging
safety-rule violations, since the error messages may miss essential
information to comprehending the violations. Third, Rust language
designers canimprovetheRustcompilerbyprovidingthemissed
information when reporting safety-rule violations. Fourth, Rust re-
searchers canleverageourfindingstobuildIDEtoolsandautomated
compiler-error fixing tools to improve Rust‚Äôs programmability.
1278
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:26:40 UTC from IEEE Xplore.  Restrictions apply. Learning and Programming Challenges of Rust: A Mixed-Methods Study ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA
Values Beyond Rust. Our work can benefit other programming
languagesintwoways.First,wedemonstratehowtostatisticallyan-
alyzeStackOverflowquestionstoidentifyprogrammingchallenges
forRustandusecodeconstructstodescribewhenasafetyruleis
especially confusing. Future work can leverage similar methods to
detect programming difficulties for other languages. Second, we
constructpairsofprogramvariantsbychangingcodeconstructsor
involved grammar to compare survey participants‚Äô performance in
a controlled manner. Researchers and practitioners can use similar
methodstobuildprogramvariantsinotherprogramminglanguages
for testing and learning purposes.
ThreatstoValidity. Similartopreviousempiricalstudiesanduser
studies, ourfindings needto beconsidered withour methodology
in mind. They have several potential threats to their validity.
Forinternalvalidity threats,oursurveyparticipantsmightnot
have been representative enough, they might have referred to Rust
tutorials in the survey, malicious persons or online bots might
havesubmittedresponses,andboththestudyonStackOverflow
questions and the grading of open-ended questions were basedon subjective assessments. We took several methods to ensureinternal validity. First, we recruited a relatively large number of
participantsfrommultiplechannels.Second,weexplicitlyrequired
participants not to refer to external resources multiple times in the
survey.Third,threeauthorsinspectedallresponsesandfilteredout
the invalid ones together. Fourth, at least two authors studied each
Stack Overflow question and graded each open-ended question.
There are two possible external threats to our study‚Äôs validity.
First,wemainlyleveragedStackOverflowquestionsforidentifying
programming challenges of Rust. Those questions could not be re-
solvedbythequestioners,andthustheymaybemoredifficultthan
programming errors in daily practice. We also acknowledge that
someoftheprogrammingchallengesofRustareneversubmitted
toStack Overflowand thuscannot beidentified throughstudying
Stack Overflow questions. Second, our survey was conducted onQualtrics. Reading Rust code on Qualtrics is different from cod-ing Rust in a real development environment. Thus, participants‚Äô
performance in our study may not reflect their common behaviors.
6 RELATED WORK
User Studies on Rust. The Mozilla Rust team conducts annual
surveys to understand Rust programmers‚Äô backgrounds and fig-ure out ways to improve Rust. The survey in 2020 reported that
lifetimeandownership arethetwomostdifficulttopicsforprogram-
merstograsp[ 53],whichalignswithourobservationsinSection3.
Zeng and Crichton [73]analyzed Rust-related posts and comments
collectedfromonlineRustcommunitiesandidentifiedseveralobsta-clestotheadoptionofRust.Crichton
[13]conductedacasestudyto
showthechallengesofinterpretingRust‚Äôscompilererrormessages.
Abtahi and Dietz [1]conducted a laboratory study to examine the
methods employed by programmers when they learned Rust. They
found that online code examples and compiler errors were helpful
to Rust learners. They also reported that sometimes Rust learn-ers found compiler error messages hard to interpret because themessages were full of terminologies. Fulton et al
. [18]identified
benefitsandchallengesofadoptingRustthroughasemi-structured
interview and an online survey.Ourstudydiffersfromthoseexistingonesinstudygoals.Specif-
ically, we aim to identify programming challenges incurred byRust‚Äôs safety rules and pinpoint scenarios where a safety rule is
more difficult to understand.
Empirical Studies on Rust Code. Researchers have conducted
empiricalstudiestounderstandreal-worldRustcodefromdiffer-
ent points of view, like how unsafe code is used [ 3,17,40], how
manyRustlibrariesdependonexternalC/C++libraries[ 65],and
thebuggycodepatternsofsafetyissuesthatbypassRust‚Äôscompiler
checks [43,71]. Those empirical studies focus on Rust programs
that can be compiled. However, we focus on Rust programs that
arerejectedbytheRust compiler,becauseweaimto identifypro-
gramming challenges imposed by Rust‚Äôs compile-time checks.
Usability Studies on Programming Languages. Researchers
conducted studies to understand how different factors (e.g., syntax,
APIs)impactprogrammers‚Äôlearningandcodingforotherprogram-
ming languages (e.g., Java, C) [ 16,23,38,39,64]. These studies
provide valuable findings and insightsin improvingsoftwarede-
velopment processes. However, Rust is very different from those
languages due to its unique grammar and its strict safety checks.
For example, the majority of the confusing C code snippets studied
by Gopstein et al . [23]cannot be compiled by the Rust compiler
andthuscannotcauseproblemsforRustprogrammersanymore.Due to the difference, we believe a usability study (like ours) tounderstandhowRust‚Äôsgrammaranditssafetychecksimpactits
learning and programming is solely desired.
ComprehendingCompilerErrors. Researchersperformedseveral
studiestounderstandhowprogrammersinterpretcompilererror
messagesfortraditionalprogramminglanguages(e.g.,C/C++)[ 4,5].
However, there is no similar study for Rust. Rust features strict
compile-timechecksthatdependoncomplexsafetyrules.Compiler
error messages are critical feedback for programmers, especially
when it comes to safety-rule violations. Thus, it is particularly
importanttostudyhowRustprogrammerscomprehendcompiler
error messages and to improve error messages accordingly.
Leveraging and Improving Stack Overflow. Stack Overflow is
anopencommunityfor developerstoasktechnicalquestionsand
sharetheirknowledge[ 60].PreviousresearchersleveragedStack
Overflow data to understand real-world development problems [ 2,
14,25,66,72,74] and built tools to improve the usages of Stack
Overflow [ 6,24,47,70,75]. However, there is no prior work on
studyingRust-relatedStackOverflowquestionsandourstudyin
Section 3 is the first one to examine those questions.
7 CONCLUSION
Rust conducts extensive static checks at the compile time to catch
memory-safety and thread-safety issues. Given the increasing pop-
ularityofRust,itiscriticaltounderstandthelanguage‚Äôslearningandprogrammingchallenges,especiallythoseposedbyitssafety
checks and the underlying safety mechanism. For this purpose, we
conductthefirstcomprehensive,empiricalstudyonRust-related
StackOverflowquestions.Weexpectthatourfindingscanguide
the learning, programming, and compiler evolution of Rust. In ad-
dition, we further perform a survey with 101 Rust programmers
and confirm many of our findings with significant confidence.
1279
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:26:40 UTC from IEEE Xplore.  Restrictions apply. ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA Shuofei Zhu, Ziyi Zhang, Boqin Qin, Aiping Xiong, and Linhai Song
REFERENCES
[1]Parastoo Abtahi and Griffin Dietz. 2020. Learning Rust: How Experienced
Programmers Leverage Resources to Learn a New Programming Language.In
Extended Abstracts ofthe2020CHIConference onHumanFactorsin
Computing Systems(CHIEA‚Äô20).Honolulu,HI,USA. https://doi.org/10.1145/
3334480.3383069
[2]EmadAghajani,CsabaNagy,OlgaLuceroVega-M√°rquez,MarioLinares-V√°squez,
Laura Moreno, Gabriele Bavota, and Michele Lanza. 2019. Software docu-mentation issues unveiled. In
Proceedings ofthe41stIEEE/ACM International
Conference onSoftware Engineering (ICSE‚Äô19).Montreal,QC,Canada. https:
//doi.org/10.1109/ICSE.2019.00122
[3]VytautasAstrauskas,ChristophMatheja,FedericoPoli,PeterM√ºller,andAlexan-
der J Summers. 2020. How do programmers use unsafe rust? Proceedings ofthe
ACMonProgramming Languages 4, OOPSLA (2020). https://doi.org/10.1145/
3428204
[4]Titus Barik, Denae Ford, Emerson Murphy-Hill, and Chris Parnin. 2018. Howshould compilers explain problems to developers?. In
Proceedings ofthe
26thACMJointMeetingonEuropean Software Engineering Conference and
Symposium ontheFoundations ofSoftware Engineering (FSE‚Äô18).LakeBuena
Vista, FL, USA. https://doi.org/10.1145/3236024.3236040
[5]Titus Barik, Justin Smith, Kevin Lubick, Elisabeth Holmes, Jing Feng, Emer-son Murphy-Hill, and Chris Parnin. 2017. Do developers read compiler errormessages?. In
Proceedings ofthe39thIEEE/ACM International Conference on
Software Engineering (ICSE‚Äô17). Buenos Aires, Argentina. https://doi.org/10.
1109/ICSE.2017.59
[6]Stefanie Beyer, Christian Macho, Massimiliano Di Penta, and Martin Pinzger.
2018. Automatically classifying posts into question categories on stack overflow.
InProceedings ofthe2018IEEE/ACM International Conference onProgram
Comprehension (ICPC‚Äô18). Gothenburg, Sweden. https://doi.org/10.1145/
3196321.3196333
[7]Steven Bird, Ewan Klein, and Edward Loper. 2009. NaturalLanguage Processing
withPython (1st ed.). O‚ÄôReilly Media, Inc.
[8]J Martin Bland and Douglas G Altman. 1995. Multiple significance tests: the
Bonferroni method. BMJ310, 6973 (1995). https://doi.org/10.1136/bmj.310.6973.
170
[9]David M. Blei, Andrew Y. Ng, and Michael I. Jordan. 2003. Latent Dirichlet
Allocation. J.Mach.Learn.Res.3 (March 2003), 993‚Äì1022. https://doi.org/10.
5555/944919.944937
[10]MaraBos.2021. ThePlanfortheRust2021Edition|RustBlog. https://blog.rust-
lang.org/2021/05/11/edition-2021.html (Accessed on 09/01/2021).
[11]RichardEClark,CarlaMPugh,KennethAYates,KenjiInaba,DonaldJGreen,
and Maura E Sullivan. 2012. The use of cognitive task analysis to improveinstructional descriptions of procedures.
JournalofSurgicalResearch 173, 1
(2012), e37‚Äìe42. https://doi.org/10.1016/j.jss.2011.09.003
[12]NancyJCooke.1994. Varietiesofknowledgeelicitationtechniques. International
JournalofHuman-Computer Studies41, 6 (1994). https://doi.org/10.1006/ijhc.
1994.1083
[13] Will Crichton. 2020. The Usability of Ownership. arXiv:2011.06171 [cs.PL][14]
AlexCummaudo,RajeshVasa,ScottBarnett,JohnGrundy,andMohamedAb-delrazek. 2020. Interpreting Cloud Computer Vision Pain-Points: A MiningStudy of Stack Overflow. In
Proceedings ofthe42ndIEEE/ACM International
Conference onSoftware Engineering (ICSE‚Äô20). Seoul, South Korea. https:
//doi.org/10.1145/3377811.3380404
[15]Dan Diaper. 2004. Understanding task analysis for human-computer interaction.
Thehandbook oftaskanalysisforhuman-computer interaction (2004), 5‚Äì47.
[16]J.J.Dolado,M.Harman,M.C.Otero,andL.Hu.2003. Anempiricalinvestigation
of the influence of a type of side effects on program comprehension. IEEE
Transactions onSoftware Engineering 29, 7 (2003). https://doi.org/10.1109/TSE.
2003.1214329
[17]AnaNoraEvans,BradfordCampbell,andMaryLouSoffa.2020. Isrustusedsafely
by software developers?. In Proceedings ofthe42ndIEEE/ACM International
Conference onSoftware Engineering (ICSE‚Äô20). Seoul, South Korea. https:
//doi.org/10.1145/3377811.3380413
[18]Kelsey R Fulton, Anna Chan, Daniel Votipka, Michael Hicks, and Michelle LMazurek. 2021. Benefits and Drawbacks of Adopting a Secure Programming
Language:RustasaCaseStudy.In Proceedings ofthe17thUSENIXSymposium
onUsablePrivacyandSecurity(USENIX SOUPS‚Äô2021). Virtual Event, USA.
[19]GitHub#67651. 2019. Confusing/incorrect error message with incoherent imple-
mentationsandasyncblocks. https://github.com/rust-lang/rust/issues/67651
(Accessed on 09/01/2021).
[20]GitHub#71584. 2020. Wrong error message for missed type inference. https:
//github.com/rust-lang/rust/issues/71584 (Accessed on 09/01/2021).
[21]GitHub#79429.2020.Inaccurateerrormessageforconstoperationsintypeparam-
eters. https://github.com/rust-lang/rust/issues/79429 (Accessed on 09/01/2021).
[22]Leo A. Goodman. 1961. Snowball Sampling. TheAnnalsofMathematical
Statistics 32, 1 (1961).[23]Dan Gopstein, Jake Iannacone, Yu Yan, Lois DeLong, Yanyan Zhuang, Mar-tin K.-C. Yeh, and Justin Cappos. 2017. Understanding Misunderstandingsin Source Code. In
Proceedings ofthe11thJointMeetingonFoundations of
Software Engineering (ESEC/FSE ‚Äô17).Paderborn, Germany. https://doi.org/10.
1145/3106237.3106264
[24]Yi Huang, Chunyang Chen, Zhenchang Xing, Tian Lin, and Yang Liu. 2018. Tell
Them Apart: DistillingTechnology Differencesfrom Crowd-Scale Comparison
Discussions.In Proceedings ofthe33rdIEEE/ACM International Conference on
Automated Software Engineering (ASE‚Äô18). Montpellier, France. https://doi.
org/10.1145/3238147.3238208
[25]NargizHumbatova,GunelJahangirova,GabrieleBavota,VincenzoRiccio,Andrea
Stocco, and Paolo Tonella. 2020. Taxonomy of Real Faults in Deep LearningSystems. In
Proceedings ofthe42ndIEEE/ACM International Conference on
Software Engineering (ICSE‚Äô20). Seoul, South Korea. https://doi.org/10.1145/
3377811.3380395
[26]Guoliang Jin, Linhai Song, Xiaoming Shi, Joel Scherpelz, and Shan Lu. 2012.Understanding and Detecting Real-world Performance Bugs. In
Proceedings
ofthe33rdACMSIGPLAN Conference onProgramming Language Designand
Implementation (PLDI‚Äô12). Beijing, China. https://doi.org/10.1145/2254064.
2254075
[27]JRichardLandisandGaryGKoch.1977.Themeasurementofobserveragreement
for categorical data. Biometrics (1977), 159‚Äì174.
[28]AmitLevy,BradfordCampbell,BrandenGhena,DanielB.Giffin,PatPannuto,
Prabal Dutta, and Philip Levis. 2017. Multiprogramming a 64kB Computer
SafelyandEfficiently.In Proceedings ofthe26thACMSymposium onOperating
SystemsPrinciples (SOSP‚Äô17).Shanghai,China. https://doi.org/10.1145/3132747.
3132786
[29]ZhenminLi,LinTan,XuanhuiWang,ShanLu,YuanyuanZhou,andChengxiang
Zhai. 2006. Have Things Changed Now? An Empirical Study of Bug Character-
istics in Modern Open Source Software. In Proceedings ofthe1stWorkshop on
Architectural andSystemSupportforImproving Software Dependability (ASID
‚Äô06). San Jose, CA, USA. https://doi.org/10.1145/1181309.1181314
[30]AlexeyLozovsky.2018. RustvsC++Comparison. https://www.apriorit.com/dev-
blog/520-rust-vs-c-comparison (Accessed on 09/01/2021).
[31]NicholasDMatsakisandFelixSKlock.2014. TheRustLanguage.In Proceedings
ofthe2014ACMSIGAdaAnnualConference onHighIntegrity Language
Technology (HILT‚Äô14). Portland, Oregon, USA. https://doi.org/10.1145/2663171.
2663188
[32]Laura G Militello and Robert JB Hutton. 1998. Applied cognitive task analy-sis (ACTA): a practitioner‚Äôs toolkit for understanding cognitive task demands.
Ergonomics 41, 11 (1998). https://doi.org/10.1080/001401398186108
[33]David Mimno, Hanna M. Wallach, Edmund Talley, Miriam Leenders, and An-drew McCallum. 2011. Optimizing Semantic Coherence in Topic Models. In
Proceedings oftheConference onEmpirical Methods inNaturalLanguage
Processing (EMNLP ‚Äô11). Punta Cana, Dominican Republic. https://doi.org/
10.5555/2145432.2145462
[34]Mozilla. 2017. Quantum - MozillaWiki. https://wiki.mozilla.org/Quantum
(Accessed on 09/01/2021).
[35]Mozilla. 2020. Rust Compiler Error Index. https://doc.rust-lang.org/error-
index.html (Accessed on 09/01/2021).
[36]Mozilla.2021. RustProgrammingLanguage. https://www.rust-lang.org/ (Ac-
cessed on 09/01/2021).
[37]Nick Kolakowski. 2019. 10 Fastest-Growing Programming Languages on GitHub.
https://insights.dice.com/2019/11/11/10-github-programming-languages/. (Ac-
cessed on 09/01/2021).
[38]Marie-H√©l√®neNienaltowski,MichelaPedroni,andBertrandMeyer.2008. Com-
piler Error Messages: What Can Help Novices?. In Proceedings ofthe39th
SIGCSETechnical Symposium onComputer ScienceEducation (SIGCSE ‚Äô08).
Portland, OR, USA. https://doi.org/10.1145/1352135.1352192
[39]DanielaSeabraOliveira,TianLin,MuhammadSajidurRahman,RadAkefirad,
Donovan Ellis, Eliany Perez, Rahul Bobhate, Lois A. DeLong, Justin Cappos, and
YuriyBrun.2018. APIBlindspots:WhyExperiencedDevelopersWriteVulnerable
Code. In Proceedings ofthe14thSymposium onUsablePrivacyandSecurity
(SOUPS‚Äô18). Baltimore, MD, USA. https://doi.org/10.5555/3291228.3291253
[40]Alex Ozdemir. 2019. Unsafe in Rust: Syntactic Patterns. https://cs.stanford.edu/
~aozdemir/blog/unsafe-rust-syntax (Accessed on 09/01/2021).
[41]Parity Technologies. 2021. Parity Bitcoin Client. https://www.parity.io/bitcoin/
(Accessed on 09/01/2021).
[42]Parity Technologies. 2021. The Parity Ethereum Client. https://www.parity.io/
ethereum/ (Accessed on 09/01/2021).
[43]BoqinQin,YilunChen,ZemingYu,LinhaiSong,andYiyingZhang.2020. Un-derstanding Memory and Thread Safety Practices and Issues in Real-WorldRust Programs. In
Proceedings ofthe41stACMSIGPLAN Conference on
Programming Language DesignandImplementation (PLDI‚Äô20). London, UK.
https://doi.org/10.1145/3385412.3386036
[44]Qualtrics. 2021. Qualtrics XM // The Leading Experience Management Software.
https://www.qualtrics.com/ (Accessed on 09/01/2021).
1280
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:26:40 UTC from IEEE Xplore.  Restrictions apply. Learning and Programming Challenges of Rust: A Mixed-Methods Study ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA
[45]Redox. 2020. Redox - Your Next(Gen) OS. https://www.redox-os.org/ (Accessed
on 09/01/2021).
[46]Radim ≈òeh≈Ø≈ôek and Petr Sojka. 2010. Software Framework for Topic Mod-
elling with Large Corpora. In Proceedings oftheLREC2010Workshop onNew
Challenges forNLPFrameworks. https://doi.org/10.13140/2.1.2393.1847
[47]Anastasia Reinhardt, Tianyi Zhang, Mihir Mathur, and Miryung Kim. 2018.
Augmenting Stack Overflow with API Usage Patterns Mined from GitHub. In
Proceedings ofthe26thACMJointMeetingonEuropean Software Engineering
Conference andSymposium ontheFoundations ofSoftware Engineering
(ESEC/FSE ‚Äô18). Lake Buena Vista, FL, USA. https://doi.org/10.1145/3236024.
3264585
[48]Rust. 2020. IntoIterator. https://doc.rust-lang.org/std/vec/struct.Vec.html#impl-
IntoIterator-1 (Accessed on 09/01/2021).
[49]Rust.2020. split_first_mut. https://doc.rust-lang.org/std/primitive.slice.html#
method.split_first_mut (Accessed on 09/01/2021).
[50]Rust. 2020. Understanding Ownership. https://doc.rust-lang.org/book/ch04-00-
understanding-ownership.html
[51]RustForum.2017.QuickintroductiontoRustforC++programmers. https://users.
rust-lang.org/t/quick-introduction-to-rust-for-c-programmers/13769 (Accessed
on 09/01/2021).
[52]RustSurveyTeam.2019. RustSurvey2019Results. https://blog.rust-lang.org/
2020/04/17/Rust-survey-2019.html (Accessed on 09/01/2021).
[53]RustSurveyTeam.2020. RustSurvey2020Results. https://blog.rust-lang.org/
2020/12/16/rust-survey-2020.html (Accessed on 09/01/2021).
[54] Servo. 2020. Servo. https://servo.org/ (Accessed on 09/01/2021).
[55]Stack Overflow. 2016. Stack Overflow Developer Survey 2016.https://insights.stackoverflow.com/survey/2016#technology-most-loved-
dreaded-and-wanted (Accessed on 09/01/2021).
[56] Stack Overflow.2017. StackOverflow DeveloperSurvey2017. https://insights.
stackoverflow.com/survey/2017#most-loved-dreaded-and-wanted (Accessedon
09/01/2021).
[57] Stack Overflow.2018. StackOverflow DeveloperSurvey2018. https://insights.
stackoverflow.com/survey/2018/#most-loved-dreaded-and-wanted (Accessed on
09/01/2021).
[58] Stack Overflow.2019. StackOverflow DeveloperSurvey2019. https://insights.
stackoverflow.com/survey/2019#most-loved-dreaded-and-wanted (Accessedon
09/01/2021).
[59] Stack Overflow.2020. StackOverflow DeveloperSurvey2020. https://insights.
stackoverflow.com/survey/2020#most-loved-dreaded-and-wanted (Accessedon
09/01/2021).
[60]Stack Overflow. 2021. Stack Overflow - Where Developers Learn, Share, & Build
Careers. https://stackoverflow.com/ (Accessed on 09/01/2021).
[61]Stack Overflow. 2021. Stack Overflow Developer Survey 2021.https://insights.stackoverflow.com/survey/2021#section-most-loved-dreaded-and-wanted-programming-scripting-and-markup-languages (Accessed on
09/01/2021).
[62]StackOverflow62491845.2020.Ownership:differencesbetweentuplesandarrays
inRust. https://stackoverflow.com/questions/62491845/ownership-differences-
between-tuples-and-arrays-in-rust (Accessed on 09/01/2021).
[63]StackOverflow65682678.2021. RustClosuresconcept. https://stackoverflow.
com/questions/65682678/rust-closures-concept (Accessed on 09/01/2021).
[64]Andreas Stefik and Susanna Siebert. 2013. An Empirical Investigation intoProgramming Language Syntax.
ACMTransactions onComputing Education
13, 4 (2013). https://doi.org/10.1145/2534973
[65]MingshenSun,YulongZhang,andTaoWei.2018. WhenMemory-SafeLanguages
Become Unsafe. In DEFCONChina(DEFCONChina‚Äô18). Beijing, China.
[66]Mohammad Tahaei, Kami Vaniea, and Naomi Saphra. 2020. UnderstandingPrivacy-Related Questions on Stack Overflow. In
Proceedings ofthe2020CHI
Conference onHumanFactorsinComputing Systems(CHI‚Äô20). Honolulu, HI,
USA. https://doi.org/10.1145/3313831.3376768
[67]The Rust Core Team. 2021. Planning the 2021 Roadmap | Rust Blog. https:
//blog.rust-lang.org/2020/09/03/Planning-2021-Roadmap.html (Accessed on
09/01/2021).
[68]Tengfei Tu, Xiaoyu Liu, Linhai Song, and Yiying Zhang. 2019. Under-standing Real-World Concurrency Bugs in Go. In
Proceedings ofthe24th
International Conference onArchitectural SupportforProgramming Languages
andOperating Systems(ASPLOS ‚Äô19). Providence, RI, USA. https://doi.org/10.
1145/3297858.3304069
[69]Jinfeng Wen, Zhenpeng Chen, Yi Liu, Yiling Lou, Yun Ma, Gang Huang, Xin
Jin, and Xuanzhe Liu. 2021. An empirical study on challenges of application
development in serverless computing. In Proceedings ofthe29thACMJoint
MeetingonEuropean Software Engineering Conference andSymposium onthe
Foundations ofSoftware Engineering (ESEC/FSE ‚Äô21).VirtualEvent,USA. https:
//doi.org/10.1145/3468264.3468558
[70]Bowen Xu, Zhenchang Xing, Xin Xia, and David Lo. 2017. AnswerBot: Au-tomatedGenerationofAnswerSummarytoDevelopers‚ÄôTechnicalQuestions.In
Proceedings ofthe32ndIEEE/ACM International Conference onAutomatedSoftware Engineering (ASE‚Äô17).Urbana-Champaign,IL,USA. https://doi.org/
10.5555/3155562.3155650
[71]Hui Xu, Zhuangbin Chen, Mingshen Sun, Yangfan Zhou, and Michael Lyu. 2020.
Memory-Safety Challenge Considered Solved? An In-Depth Study with All Rust
CVEs.ACMTrans.Softw.Eng.Methodol. 31,1(2020). https://doi.org/10.1145/
3466642
[72]Xin-LiYang,DavidLo,XinXia,ZhiyuanWan,andJian-LingSun.2016. What
Security Questions Do Developers Ask? A Large-Scale Study of Stack Overflow
Posts.JournalofComputer ScienceandTechnology 31(092016),910‚Äì924. https:
//doi.org/10.1007/s11390-016-1672-0
[73]AnnaZengandWillCrichton.2018. IdentifyingBarrierstoAdoptionforRust
through Online Discourse. In PLATEAU@SPLASH ‚Äô18. Boston, MA. https:
//doi.org/10.4230/OASIcs.PLATEAU.2018.5
[74]Yuhao Zhang, Yifan Chen, Shing-Chi Cheung, Yingfei Xiong, and Lu Zhang.
2018. AnEmpiricalStudyonTensorFlowProgramBugs.In Proceedings ofthe
27thInternational Symposium onSoftware TestingandAnalysis (ISSTA‚Äô18).
Amsterdam, Netherlands. https://doi.org/10.1145/3213846.3213866
[75]JingZhouandRobertJ.Walker.2016. APIDeprecation:ARetrospectiveAnalysis
and Detection Method for Code Examples on the Web. In Proceedings ofthe
24thInternational Symposium onFoundations ofSoftware Engineering (FSE
‚Äô16). Seattle, WA, USA. https://doi.org/10.1145/2950290.2950298
1281
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:26:40 UTC from IEEE Xplore.  Restrictions apply. 