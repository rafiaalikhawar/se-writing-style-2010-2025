DeJITLeak : Eliminating JIT-Induced Timing Side-Channel Leaks
QiQin
qinqi@shanghaitech.edu.cn
ShanghaiTechUniversity
Shanghai,ChinaJulianAndres JiYang
jlandres@shanghaitech.edu.cn
ShanghaiTechUniversity
Shanghai,ChinaFu Songâˆ—
songfu@shanghaitech.edu.cn
ShanghaiTechUniversity
Shanghai,China
Taolue Chen
t.chen@bbk.ac.uk
Birkbeck, University ofLondon
London,UKXinyuXing
xinyu.xing@northwestern.edu
NorthwesternUniversity
Evanston, Illinois,USA
ABSTRACT
Timingside-channelscanbeexploitedtoinfersecretinformation
when the execution time of a program is correlated with secrets.
Recent work has shown that Just-In-Time (JIT) compilation can
introducenewtimingside-channelsinprogramseveniftheyare
time-balanced at the source code level. In this paper, we propose a
novelapproachtoeliminateJIT-inducedleaks.Wefirstformalise
timingside-channelsecurityunderJITcompilationviathenotionof
time-balancing,layingthefoundationforreasoningaboutprograms
with JIT compilation. We then propose to eliminate JIT-induced
leaks via a fine-grained JIT compilation. To this end, we provide
an automated approach to generate compilation policies and a
novel type system to guarantee itssoundness.We develop a tool
DeJITLeak for real-world Java and implement the fine-grained
JITcompilationinHotSpotJVM.Experimentalresultsshowthat
DeJITLeak can effectively and efficiently eliminate JIT-induced
leaks on three widely adopted benchmarks in the setting of side-
channeldetection.
CCSCONCEPTS
â€¢Softwareanditsengineering â†’Formalsoftwareverifica-
tion;â€¢Theoryofcomputation â†’Programanalysis ;â€¢Security
and privacy â†’Formal security models ;Logic and verifica-
tion.
KEYWORDS
JIT compilation, timing side-channel, formal semantics, type infer-
ence,detection,mitigation
ACM Reference Format:
Qi Qin, JulianAndresJiYang,Fu Song, Taolue Chen, and Xinyu Xing. 2022.
DeJITLeak : Eliminating JIT-Induced Timing Side-Channel Leaks. In Pro-
ceedingsofthe30thACMJointEuropeanSoftwareEngineeringConference
andSymposiumontheFoundationsofSoftwareEngineering(ESEC/FSEâ€™22),
November 14Å›18, 2022, Singapore, Singapore. ACM, New York, NY, USA,
13pages.https://doi.org/10.1145/3540250.3549150
âˆ—Corresponding author
ESEC/FSE â€™22, November 14Å›18,2022, Singapore, Singapore
Â©2022 Copyright heldby theowner/author(s).
ACM ISBN 978-1-4503-9413-0/22/11.
https://doi.org/10.1145/3540250.35491501 INTRODUCTION
Timing side-channel vulnerabilities in programs arise when the
executiontimeofaprogramiscorrelatedwithsecrets,thuspose
a serious threat to secure systems. One notorious example is the
Lucky 13 attack that can remotely recover plaintext from the CBC-
modeencryptioninTLSduetoanunbalancedbranchstatement[ 3].
Constant-time and time-balancing are two programming princi-
ples to mitigate timing side-channel vulnerabilities [ 7]. The former
ensuresthatsecretsdonotinfluencecontrol-flowpaths,memory
access patterns, etc., thus requires significant changes to programs
(e.g., complicated bitwise-operations). The latter ensures that each
secret branching statement has balanced execution time, and is
mucheasierto achieve inpractice.Developing constant-timeand
time-balanced programs [ 2] is not easy. Even worse, in practice,
theymaystillbevulnerableiftheruntimeenvironmentisnotfully
captured by constant-time or time-balancing models. For instance,
static compilation from programs to low-level counterparts can
compromise constant-time security [ 11Å›13,25]; constant-time exe-
cutable programs are vulnerable in modern processors due to, e.g.,
speculative or out-of-order execution [ 21,26,42,46]; Just-In-Time
(JIT) compilation may undermine time-balanced programs [ 17,19].
In this work, we focus on JIT compilation induced leaks (JIT-
induced leaks) which could be exploited remotely in real-world
applications[ 17],butcurrentlynorigorousapproachcaneliminate
themotherthan tuningoff JIT compilation [ 16].
We first lay the foundations for timing side-channel security
underJITcompilationbypresentingaformaloperationalsemantics.
With this, we present the first formalism of timing side-channel
securityunderJITcompilationviathenotionoftime-balancing.To
be generic, we donot model concrete JIT compilation asin [ 8,31]
whichaimedtoprovethecorrectnessofJITcompilation.Instead,we
leaveJITcompilationabstractinourmodel,whichisformalizedvia
compilationdirectivesandallowstoconsiderpowerfulattackers
who have control over JIT compilation. This approach can also
enable reasoning about bytecode running with JIT compilation
anduncoverhowcodecanleaksecretsduetoJITcompilationin
a principled way. We then propose to prevent JIT-induced leaks
via a fine-grained JIT compilation and present a type system for
staticallyinferringeffective compilation policies.
Basedontheseresults,wepresent DeJITLeak ,apracticaltool
for generating compilation policies of Java programs that can be
proven to completely eliminate JIT-induced leaks, while still bene-
fitingfromtheperformancegainsofJITcompilation;inaddition,
Thiswork islicensedunderaCreativeCommonsAttribution4.0Interna-
tional License.
872
ESEC/FSE â€™22, November14Å›18, 2022,Singapore, Singapore Qi Qin,JulianAndresJiYang,FuSong,TaolueChen, Xinyu Xing
a lightweight variant of DeJITLeak ,DeJITLeak light, can elimi-
nate most of the leaks with a low overhead for more performance-
consciousapplicationsandisstillsoundifmethodsinvokedinboth
sides of each secret branching statement are the same. We also
implementthefine-grained JITcompilationinHotSpotJVMfrom
OpenJDK. We conduct extensive experiments on three widely used
datasetsinrecentside-channeldetection:Blazer[ 6],Themis[ 23],
CoCo-Channel [ 18], DifFuzz [ 51], and JVMFuzz [ 19]. Experimental
results show that DeJITLeak significantly outperformsthe strate-
giesproposedin[ 16].Wereportinterestingcasestudieswhichshed
light onfurther research. In summary,our contributionsare:
â€¢AformaltreatmentofJIT-inducedleaksincludinganoperational
semantics andatime-balancingnotionunderJIT compilation;
â€¢A protection mechanism against JIT-induced leaks via a fine-
grained JIT compilation and an efficient approach to generate
JIT compilation policies for fine-grained JIT compilation with
security guarantees;
â€¢A practical tool that implements our approach and extensive
experiments to demonstratethe efficacy ofour approach.
Structure. Section2brieflyintroducesJIT-inducedleaksandpresents
an overview of our approach. Section 3formalises timing side-
channel security under JIT compilation. In Section 4, we propose a
protection mechanism and a type system to guarantee its sound-
ness. Section 5presents an implementation of our approach for
real-worldJava.Section 6reportsan extensiveevaluation. Wedis-
cuss related work in Section 7and conclude this work in Section 8.
2 OVERVIEW
In this section, we first give a brief introduction of JIT-induced
leaks [17]. We will exemplify these leaks usingthe HotSpot JVM
(HotSpotforshort)onOpenJDK1.8.Wethengiveanoverviewof
our approach to identifyandeliminatethe JIT-inducedleaks.
2.1 JIT-InducedLeaks
JIT-induced leaks could be caused by at least the following three
JITcompilation techniques [ 17].
Optimistic compilation ( Topti).Optimistic compilation is a
typeofspeculationoptimizations[ 8].DuringtheJITcompilation
ofamethod,thecompilerspeculatesonthemostlikelyexecuted
branches by pruning rarely executed branches. As a result, it re-
duces the amount of time required to compile methods at runtime
and space to store the native code. However, there might be a sub-
sequent execution where the speculation fails and the execution
must fall back to bytecode in the interpreted mode. To handle this
issue,adeoptimizationpoint(a.k.a.uncommontrap)isaddedtothe
nativecodeand,whenencountered,deoptimizationisperformed
which recovers the program state and resumes execution using
bytecode. Clearly, executing the native code after compilation is
muchmoreefficientifnodeoptimizationoccurs.However,when
deoptimizationoccurs,itwilltakelongertimetodeoptimizeand
rollbackto thebytecode. This differenceinexecutiontimeinduces
atiming side-channel even if branches are balancedinbytecode.
As an example, consider the pwdEqmethod shown in Figure 1a,
whichisextractedandsimplifiedfromtheDARPASpace/TimeAnal-
ysisforCybersecurity(STAC)engagementprogram gabfeed_1 [58].
It takes the strings ğ‘andğ‘with length 8as inputs denoting theuser-entered and correct passwords respectively. It checks if the
twostringsareidentical(theforloop).Theflag equalisassignedby
falseiftwocharsmismatch.Tobalanceexecutiontime,thedummy
flagshmequal isintroduced.
ThepwdEqmethodismarkedassafeinSTACandwouldbever-
ified as safe by the timing side-channel verification tools Blazer [ 6]
and Themis [ 23] which do not consider JIT compilation. However,
indeeditisvulnerableto Topti.Totrigger Topti,weexecute pwdEq
50,000timesusingtwostringsÅ‚PASSWORDÅ¾andÅ‚passwordÅ¾.After
that,the else-branchisreplacedbythecorrespondinguncommon
trap,sothecostlydeoptimizationwillperformlater.Totriggerthis,
we use two strings ğ‘¥andğ‘¦with length 8 such that ğ‘¥[0]is â€˜pâ€™,ğ‘¦[0]
is not â€˜pâ€™, and the rest is the same. We collect the execution time of
pwdEqwithinputs (ğ‘¥,Å‚passwordÅ¾ )and(ğ‘¦,Å‚passwordÅ¾ )respectively.
The distribution of the execution time is shown in Figure 1b. In
comparison,Figure 1cshowsthedistributionofexecutiontimewith
JIT compilation disabled. We can observe that the difference in the
executiontimebetweentwobranchesismuchlargerwhenJITcom-
pilation isenabled,allowinganattacker toinferif thefirstcharis
correctlyguessed.Ourapproachpreventsthisleakbydisablingthe
optimisticcompilationoptimizationoftheconditionalstatement
inpwdEqratherthandisablingJITcompilation.Theeffectiveness
isjustifiedbytheexecutiontimedepictedinFigure 1d.Itismore
efficient than natively disabling JIT compilation(e.g., Figure 1cvs.
Figure1d).
Branch prediction ( Tbran).Branch prediction is a conservative
optimizationofconditionalstatements.Insteadofpruningrarely
executed branches, branch prediction generates native code by
reorderingthebasicblockstoavoidjumpsoverfrequentlyexecuted
branchesandthusimprovesthespatiallocalityofinstructioncache.
However,thereorderingofbasicblocksunbalancestheexecution
timeofbranchesevenifitisbalancedinbytecode.Althoughthe
difference in the execution time between branches via Tbranis
small for a single conditional statement, it may be amplified by
repeatedexecutions(e.g.,enclosedinaloop).
Method compilation ( Tmeth).The most fundamental feature
ofJITcompilationismethod compilation,whichcanbe triggered
if a method is frequently invoked or some backward jumps are
frequentlyperformed.Meanwhile,duringcompilationfrequently
invokedsmallmethodscouldbeinlinedtospeedupexecution.Ifan
attacker can enforce some methods in a branch to be frequently in-
vokedinadvancesothatthosemethodsare(re)compiledorinlined,
the execution time of this branch may be shortened. This differ-
ence in execution time between branches would induce a timing
side-channel.
Concrete demonstrationsof TbranandTmethrefer to [56].
2.2 Eliminating JIT-InducedLeaks
Assuming that a program in bytecode is time-balanced, our goal is
toautomaticallypreventitfromtheJIT-inducedleaks.Onepossible
way is to adopt constant-time programming principle (e.g., [ 1,6,
22,22,23,49,66]). However, there are two limitations: (i) signifi-
cantchangeshavetobemade(e.g.,complicatedbitwise-operations),
makingreasoningaboutfunctional-correctnessharder.Forinstance,
OpenSSL applied a >500 LOC patch to perform constant-time ci-
pherblock chaining (CBC)decoding, the complexityof which led
873DeJITLeak : Eliminating JIT-InducedTiming Side-Channel Leaks ESEC/FSE â€™22, November14Å›18, 2022,Singapore, Singapore
boolean pwdEq( char [] a , char [] b ){
boolean equal = true ;
boolean shmequal = true ;
for ( int i = 0; i < 8; i ++) {
if (a[ i ] != b[ i ])
equal = false ;
else shmequal = false ;
}
return equal ; }
(a)ThepwdEqmethod
x[0] == 'p' y[0] != 'p'010000200003000040000Execution time (ns) (b) JIT enabled
x[0] == 'p' y[0] != 'p'15002000250030003500Execution time (ns) (c) JIT disabled
x[0] == 'p' y[0] != 'p'0100020003000Execution time (ns) (d)Mitigated
Figure 1:The pwdEqmethod andits execution timewith JITenabled and disabled under Topti
to subsequent issues [ 7]. To the best of our knowledge, no tool
canautomaticallyrewriteaJavaprogramtoaconstant-timeone.
(ii) Different from programs written in static programming lan-
guages [22,66] for which constant-time written is done once for
eachprogram, forprogramsthatcanbe JIT compiled,ascompila-
tionmaydestructconstant-timesecurity[ 11Å›13,25],constant-time
security should be enforced during each JIT compilation, incurring
large overheadto JITcomplication.
Another straightforward way to prevent JIT-induced leaks is
to simply disable JIT compilation completely or JIT compilation
of the chosen methods. Indeed, [ 16] proposed three compilation
strategies: NOJIT, DisableC2 and MExclude. (i) The NOJIT strategy
directlydisablesJITcompilation(e.g.,boththeC1andC2compilers
in HotSpot), so no method will be JIT compiled. This strategy is
effective and convenient to deploy, but could lead to significant
performance loss. (ii) The DisableC2 strategy only disables the C2
compilerinstead ofthe entire JITcompilation, by whichtheleaks
induced by the C2 compiler (e.g., Topti) can be prevented, but not
forTbranorTmeth. This strategy also sacrifices the more ag-
gressiveC2optimizationandhencemay sufferfromperformance
loss. (iii) The MExclude strategy disables JIT compilation for the
user-chosen methods instead of the entire program. Its main short-
coming is that non-chosen methods may be still vulnerable, and it
isalsounclearhowtochoosemethodstodisable.In[ 16],MExclude
isappliedtothemethodsthatcontainsecretbrancheswhichcan
preventTbranandToptileaks, but not Tmethleaks. In summary,
thesecompilationstrategieseitherincurahighperformancecost
orfail to preventallthe knownJIT-inducedleaks.
Inthiswork,wefirstlaythefoundationsfortimingside-channel
securityunderJITcompilation by presentinga formal operational
semanticsanddefininganotionoftime-balancingforafragment
of the JVM under JIT compilation. It allows us to reason about
timingside-channelsecurityofbytecodeprogramsrunningwith
JITcompilationinaprincipledway.Basedonourformalism,we
observe that secret information can only be leaked when there is a
conditional statement whose condition relies on secret data, and at
leastone ofthe following casesoccurs,namely,
(1)(Tmethleaks) a method invoked in a branch is JIT compiled or
inlined;
(2)(Tbranleaks) the conditional statement is optimized with the
branchprediction optimization;
(3)(Toptileaks)theconditionalstatementisoptimizedwiththe
optimistic optimization;Therefore, disabling JIT compilationat the method level is indeed
unnecessary for preventing JIT-induced leaks, instead, we only
need to ensure that secret information will not be leaked when the
methodsare JIT compiledorinlined.
Basedontheaboveobservation,weproposeanovelapproach
DeJITLeak to automatically eliminate JIT-induced leaks. To the
bestofourknowledge,thisisthefirstworktopreventalltheabove
JIT-inducedleakswithoutdisablinganycompilerinHotSpot,which
is in a sharp contrast with the existing compilation strategies [ 16].
In a nutshell, DeJITLeak automatically locates secret branch
points(programpointswithconditionalstatementswhosecondi-
tionsrelyonsecretdata)byaflow-,object-andcontext-sensitive
information flow analysis of Java bytecode [ 62]. The conditional
statementsatthosesecretbranchpointsshouldnotbeoptimized
viabranchpredictionoroptimisticcompilations.Itthenextractsall
themethodsinvokedinthoseconditionalstatementsandidentifies
thosemethodsthatshouldnotbeJITcompiledorinlined.Basedon
these, we put forward a fine-grained JIT compilation and present a
type systemto prove the soundness of the fine-grained JIT compi-
lation,i.e.,atime-balanced program remains time-balanced under
ourfine-grainedJITcompilationiftheprogramiswell-typedunder
ourtypesystem.Notethatourapproachdoesnotguaranteethat
alltheidentifiedbranchpointsormethodsarenecessary,butthe
precision ofour approach isassured by the advanced information
flowanalysisandisindeedvalidatedbyexperiments inSection 6.
Finally,thefine-grainedJITcompilationisimplementedbymod-
ifyingHotSpot.Ourexperimentalresultsshowthatourapproach
issignificantlymoreeffectivethanDisableC2andMExclude,and
issignificantly more efficient thanNOJIT.
3 FORMALISMOFSECURITY
Inthissection,wepresentafragmentofJVMandformalizetiming
side-channel security viathe notionof time-balancing.
3.1 The JVMSubmachine
WedefineafragmentJVM JITofJVMwithconditionalanduncon-
ditional jumps, operations to manipulate the operand stack, and
methodcalls.Forthesakeofpresentation,bothbytecodeandnative
codearepresentedinJVM JIT.Notethatourmethodologyisgeneric
andcouldbeadaptedtorealinstructionsetsofbytecodeandnative
code.
Syntax.LetLVar(resp.GVar)bethefinitesetoflocal(resp.global)
variables, Valbe the set of values, Mbe a finite set of methods.
A program ğ‘ƒcomprises a set of methods and each method is a
874ESEC/FSE â€™22, November14Å›18, 2022,Singapore, Singapore Qi Qin,JulianAndresJiYang,FuSong,TaolueChen, Xinyu Xing
ğ‘š[pc]=pushğ‘£
âŸ¨pc,ğ‘š,ğœŒ,osâŸ©/leadstoâŸ¨pc+1,ğ‘š,ğœŒ,ğ‘£Â·osâŸ©ğ‘š[pc]=pop
âŸ¨pc,ğ‘š,ğœŒ,ğ‘£Â·osâŸ©/leadstoâŸ¨pc+1,ğœŒ,osâŸ©ğ‘š[pc]=binopğ‘œğ‘ ğ‘£ =ğ‘£1ğ‘œğ‘ ğ‘£2
âŸ¨pc,ğ‘š,ğœŒ,ğ‘£ 1Â·ğ‘£2Â·osâŸ©/leadstoâŸ¨pc+1,ğ‘š,ğœŒ,ğ‘£Â·osâŸ©
ğ‘š[pc]=ifeqğ‘—pcâ€²=(ğ‘£=0)?ğ‘—:pc+1
âŸ¨pc,ğ‘š,ğœŒ,ğ‘£Â·osâŸ©/leadstoâŸ¨pcâ€²,ğ‘š,ğœŒ,osâŸ©ğ‘š[pc]=ifneqğ‘—pcâ€²=(ğ‘£â‰ 0)?ğ‘—:pc+1
âŸ¨pc,ğ‘š,ğœŒ,ğ‘£Â·osâŸ©/leadstoâŸ¨pcâ€²,ğ‘š,ğœŒ,osâŸ©ğ‘š[pc]=swap
âŸ¨pc,ğ‘š,ğœŒ,ğ‘£ 1Â·ğ‘£2Â·osâŸ©/leadstoâŸ¨pc+1,ğœŒ,ğ‘£2Â·ğ‘£1Â·osâŸ©
ğ‘š[pc]=storeğ‘¥ ğ‘¥âˆˆdom(ğœŒ)
âŸ¨pc,ğ‘š,ğœŒ,ğ‘£Â·osâŸ©/leadstoâŸ¨pc+1,ğ‘š,ğœŒ[ğ‘¥â†¦â†’ğ‘£],osâŸ©ğ‘š[pc]=loadğ‘¥
âŸ¨pc,ğ‘š,ğœŒ,osâŸ©/leadstoâŸ¨pc+1,ğ‘š,ğœŒ,ğœŒ(ğ‘¥) Â·osâŸ©ğ‘š[pc]=gotoğ‘—
âŸ¨pc,ğ‘š,ğœŒ,osâŸ©/leadstoâŸ¨ğ‘—,ğ‘š,ğœŒ,osâŸ©
ğ‘ /leadstoğ‘ â€²
(ch,h,ğ‘ ,cs) â†’ (ch,h,ğ‘ â€²,cs)ğ‘š[pc]=putğ‘¦ ğ‘¦âˆˆdom(ğœŒ)ğ‘ =âŸ¨pc+1,ğ‘š,ğœŒ,osâŸ©
(ch,h,âŸ¨pc,ğ‘š,ğœŒ,ğ‘£Â·osâŸ©,cs) â†’ (ch,h[ğ‘¦â†¦â†’ğ‘£],ğ‘ ,cs)ğ‘š[pc]=getğ‘¦ ğ‘ =âŸ¨pc+1,ğ‘š,ğœŒ,h(ğ‘¦) Â·osâŸ©
(ch,h,âŸ¨pc,ğ‘š,ğœŒ,osâŸ©,cs) â†’ (ch,h,ğ‘ ,cs)
ğ‘š[pc]=return ğ‘ =âŸ¨pcâ€²,ğ‘šâ€²,ğœŒâ€²,ğ‘£Â·osâ€²âŸ©
(ch,h,âŸ¨pc,ğ‘š,ğœŒ,ğ‘£Â·osâŸ©,âŸ¨pcâ€²,ğ‘šâ€²,ğœŒâ€²,osâ€²âŸ© Â·cs) â†’ (ch,h,ğ‘ ,cs)ğ‘š[pc]=deoptmdVğ‘š>0O((ch,h,âŸ¨pc,ğ‘š,ğœŒ,osâŸ©,cs),md)=(hâ€²,ğ‘ ,csâ€²)
(ch,h,âŸ¨pc,ğ‘š,ğœŒ,osâŸ©,cs) â†’ (ch[ğ‘šâ†¦â†’base_version (ğ‘š)],hâ€²,ğ‘ ,csâ€²Â·cs)
ğ‘š[pc]=return
(ch,h,âŸ¨pc,ğ‘š,ğœŒ,ğ‘£Â·osâŸ©,ğœ–) â†’ (h,ğ‘£)ğ‘š[pc]=invokeğ‘šâ€²argv(ğ‘šâ€²)=ğ‘¥0,Â·Â·Â·,ğ‘¥ğ‘˜d=dâˆ…ğ‘ =âŸ¨0,ch(ğ‘šâ€²),[ğ‘¥0â†¦â†’ğ‘£0,Â·Â·Â·,ğ‘¥ğ‘˜â†¦â†’ğ‘£ğ‘˜],ğœ–âŸ©
(ch,h,âŸ¨pc,ğ‘š,ğœŒ,ğ‘£ ğ‘˜Â· Â·Â·Â· Â·ğ‘£0Â·osâŸ©,cs) â†’d(ch,h,ğ‘ ,âŸ¨pc+1,ğ‘š,ğœŒ,osâŸ© Â·cs)
ğ‘š[pc]=invokeğ‘šâ€²argv(ğ‘šâ€²)=ğ‘¥0,Â·Â·Â·,ğ‘¥ğ‘˜dâˆˆDğ‘šdâ‰ dâˆ…ğ‘šâ€²â€²=d(ğ‘šâ€²) V ğ‘šâ€²â€²>Vğ‘šâ€²
(ch,h,âŸ¨pc,ğ‘š,ğœŒ,ğ‘£ ğ‘˜Â· Â·Â·Â· Â·ğ‘£0Â·osâŸ©,cs) â†’d(ch[ğ‘šâ€²â†¦â†’ğ‘šâ€²â€²],h,âŸ¨0,ğ‘šâ€²â€²,[ğ‘¥0â†¦â†’ğ‘£0,Â·Â·Â·,ğ‘¥ğ‘˜â†¦â†’ğ‘£ğ‘˜],ğœ–âŸ©,âŸ¨pc+1,ğ‘š,ğœŒ,osâŸ© Â·cs)
Figure 2:Operational semanticsofJVM JIT,wheredom(ğœŒ)denotes thedomainofthe partialfunction ğœŒ
inst::=binopğ‘œğ‘binary operation ontheoperandstack
|pushğ‘£pushvalueğ‘£ontop of theoperandstack
|pop popvalue from top of theoperandstack
|swap swapthetop twooperandstackvalues
|loadğ‘¥loadvalue of ğ‘¥ontotheoperandstack
|storeğ‘¥popand storetop of theoperandstackin ğ‘¥
|getğ‘¦loadvalue of ğ‘¦ontotheoperandstack
|putğ‘¦popand storetop of theoperandstackin ğ‘¦
|ifeqğ‘—conditionaljump
|ifneqğ‘—conditionaljump
|gotoğ‘—unconditional jump
|invokeğ‘šinvokethemethod ğ‘šâˆˆM
|return return thetop value of theoperandstack
|deoptmddeoptimizewithmeta data md
Figure3:InstructionsetofJVM JIT,whereğ‘¥âˆˆLVarisalocal
variable and ğ‘¦âˆˆGVarisaglobalvariable
list of instructions taken from the instruction set in Figure 3. All
theseinstructionsarestandardexceptfor deoptmdwhichmodels
uncommontraps (cf.Section 2).
Foreachmethod ğ‘š,ğ‘š[ğ‘–]denotestheinstructionattheprogram
pointğ‘–andargv(ğ‘š)denotes the formal arguments of ğ‘š. When
a method is invoked, the execution starts with the first instruc-
tionğ‘š[0]. We also denote by ğ‘š[ğ‘–,ğ‘—]forğ‘—â‰¥ğ‘–the sequence of
instructions ğ‘š[ğ‘–]ğ‘š[ğ‘–+1]Â·Â·Â·ğ‘š[ğ‘—].
Compilationdirective. Tomodelmethodcompilationwithpro-
cedure inline, branch prediction and optimistic compilation opti-
mizations,weuse(compilation)directiveswhichspecifyhowthe
method should be (re)compiled and optimized at runtime. Let Dğ‘š
bethesetofdirectivesofthemethod ğ‘š,andd(ğ‘š)themethodafter
JITcompilationaccordingtothedirective d.Inparticular,weuse
dâˆ…âˆˆDğ‘što denote no (re)compilation. The formal definition of
directives isgiven inthe following subsection.
In general, a method in bytecode is compiled into native code
which may be iteratively recompiled later. Hence we assign to
each method ğ‘ša version number Vğ‘š, where the bytecode has the
versionnumber 0,andVmax>0isthe highestversionnumber. A
directivedâˆˆDğ‘šisvalidifğ‘šâ€²=d(ğ‘š)andVğ‘šâ€²>Vğ‘š,otherwise d
isaninvaliddirective.Intuitively,theversionnumber Vğ‘šindicates
theoptimizedlevelofthemethod ğ‘š.JITrecompilationonlyusesincreasinglyaggressive optimizationtechniques,and rolls backto
the bytecode versionotherwise.
State.Astateis a tuple âŸ¨pc,ğ‘š,ğœŒ,osâŸ©, wherepcâˆˆNis the program
counter pointing to the next instruction, ğ‘šâˆˆMis the current
executingmethod, ğœŒ:LVarâ†’Valisapartialfunctionfromlocal
variables to values,and osâˆˆValâˆ—isthe operand stack. We denote
byStatesthe set of states. For each function ğ‘“:ğ‘‹â†’ğ‘‰, variable
ğ‘¥âˆˆğ‘‹and valueğ‘£âˆˆğ‘‰, letğ‘“[ğ‘¥â†¦â†’ğ‘£]be the function where
ğ‘“[ğ‘¥â†¦â†’ğ‘£](ğ‘¥â€²)=ğ‘“(ğ‘¥â€²)ifğ‘¥â€²â‰ ğ‘¥,andğ‘“[ğ‘¥â†¦â†’ğ‘£](ğ‘¥â€²)=ğ‘£otherwise.
For two operand stacks os1,os2âˆˆValâˆ—, letos1Â·os2denote their
concatenation. The emptyoperand stack isdenotedby ğœ–.
Configuration. Aconfiguration isoftheform (ch,h,ğ‘ ,cs)or(h,ğ‘£),
wherechis a code heap storing the latest version of methods;
h:GVarâ†’Valis a (data) heap, i.e., a partial function from global
variables to values; ğ‘ âˆˆStatesis the current state; csâˆˆStatesâˆ—is
the call stack, and ğ‘£âˆˆValis a value. Configurations of the form
(h,ğ‘£)are final configurations, reached after the return of the entry
point.Aconfiguration (ch,h,âŸ¨pc,ğ‘š,ğœŒ,osâŸ©,cs)isinitialifpc=0,ğ‘š
is the entry point of the program, and os=cs=ğœ–.Confdenotes
thesetofconfigurations; cs1Â·cs2denotestheconcatenationoftwo
callstacks cs1andcs2;ğœ–denotesthe emptycallstack.
Operationalsemantics. Thesmall-stepoperationalsemanticsof
JVMJITis givenin Figure 2as arelation â†’âŠ†ConfÃ—Conf, where
/leadstoâŠ†StatesÃ—Statesis anauxiliary relation. Note that the directive
dapplies to methodinvocations only.
Instruction pushğ‘£,pushesthevalue ğ‘£ontopoftheoperandstack.
Instruction pop, just pops the top of the operand stack. Instruction
binopğ‘œğ‘pops the top two operands from the operand stack and
pushestheresult ofthebinary operation ğ‘œğ‘using theseoperands.
Instruction ifeqğ‘—(resp.ifneqğ‘—) pops the top ğ‘£of the operand
stack and transfers of control to the program point ğ‘—ifğ‘£=0(resp.
ğ‘£â‰ 0), otherwise to the next instruction, i.e., the program point
ğ‘—+1. Instruction swap, swaps the top two values of the operand
stack. Instruction storeğ‘¥(resp.putğ‘¦) pops the topofthe operand
stack and stores it in the local variable ğ‘¥(resp. global variable ğ‘¦).
Instruction loadğ‘¥(resp.getğ‘¦)pushesthevalueofthelocalvariable
ğ‘¥(resp. global variable ğ‘¦), on top of the operand stack. Instruction
gotoğ‘—unconditionallyjumpsto program point ğ‘—.
875DeJITLeak : Eliminating JIT-InducedTiming Side-Channel Leaks ESEC/FSE â€™22, November14Å›18, 2022,Singapore, Singapore
â€¦
i:    ifeq j
i+1:       â€¦
j-1:    goto j
j:      â€¦
j-1:    inst 2
â€¦j :      Method m
Bf
BtMethod m 1
â€™
â€™â€™
â€¦
i:    ifeq |m|- j +j-1:      
|m|- j +j-1:           â€¦i+1:           â€¦
j-2:     inst 1
â€¦j-1:           
BtBf
â€™â€™Branch 
prediction 
optimization
to i: ifeq j j-2:    inst 1
|m|-2:    inst 2â€™
|m|-1:           |m|-1:    goto j-1â€™
Figure 4:Branch prediction optimization
Instruction returnendstheexecutionofthecurrentmethodand
returns the top value ğ‘£of the current operand stack. If the current
methodisnottheentrypoint, ğ‘£ispushedasthetopoftheoperand
stack of the caller and the caller is resumed from the return site;
otherwise,thefinalconfiguration (h,ğ‘£)isreached.Weassumethat
eachmethodhasaunique returninstructionwhichdoesnotappear
inconditionalstatements, asearlyreturnoftenintroducestiming
side-channel leakseven withoutJITcompilation.
Instruction deoptmddeoptimizes the current executing method
androllsbacktothebytecodeintheinterpretedmode.Thisinstruc-
tion is only used in native code and inserted by JIT compilers. Our
semantics does not directly model a deoptimization implementa-
tion. Instead, we assumethere isa deoptimization oracle Owhich
takes the current configuration and the meta data mdas inputs,
and reconstructs the configuration (i.e., heap hâ€², stateğ‘ and the
call stack csâ€²). Furthermore, the bytecode version base_version (ğ‘š)
of the method ğ‘šis restored into the code heap ch. The oracle O
results in the same heap hâ€², stateğ‘ and call stack csâ€²Â·csas if the
methodğ‘šwere not JITcompiled.
Thesemanticsof invokeğ‘šâ€²dependsonthedirective d.Ifd=dâˆ…,
theversionof ğ‘šâ€²inthecodeheap chremainsthesame.If disvalid,
i.e., the version number Vğ‘šâ€²â€²of the optimized version ğ‘šâ€²â€²=d(ğ‘šâ€²)
is larger than that of the current one Vğ‘šâ€²,ğ‘šâ€²â€²is stored in the code
heapch.Afterthat,itpopsupthetop |argv(ğ‘šâ€²)|valuesfromthe
currentoperandstack,passesthemastheformalargumentsto ğ‘šâ€²â€²,
pushes the calling context on top of the call stack and starts to
executeğ‘šâ€²â€²inthe code heap.
To define a JIT-execution, we introduce the notion of schedules.
Avalid schedule dâ˜…for a configuration ğ‘is a sequence of valid
directivessuchthattheprogramwillnotgetstuckwhenstarting
fromğ‘andfollowing dâ˜…formethodinvocations. Avalidschedule
dâ˜…yields aJIT-execution ğ‘0â‡“dâ˜…ğ‘ğ‘›that is a sequence ğ‘0ğ‘1Â·Â·Â·ğ‘ğ‘›
ofconfigurationssuchthat ğ‘0isaninitialconfiguration, ğ‘ğ‘›isthe
final configuration, and for every 0â‰¤ğ‘–<ğ‘›, eitherğ‘ğ‘–â†’ğ‘ğ‘–+1
orğ‘ğ‘–â†’dğ‘–ğ‘ğ‘–+1. We require that dâ˜…is equal to the sequence of
directives along the JIT-execution, i.e., the concatenation of dğ‘–â€™s. A
JIT-free execution is thus a JIT-execution ğ‘0â‡“dâ˜…
âˆ…ğ‘ğ‘›. In this work,
we only considerprograms that alwaysterminate.
3.2 JITOptimization ofJVM JIT
We first define branch predictionand optimisticcompilation, then
definemethodcompilation as well as compilation directives.Method m 1
â€¦
i:    ifeq |m|- j +j-1:           
|m|- j +j-1:           i+1:           
â€¦
j-2:     inst 1
â€¦j-1:           Bfâ€™
To if-branch of i : ifeq j â€™uncommon
 trapâ€™Method m 2
â€¦
i:   ifneq |m|- j +i-1:    
|m|-j+i+1:           i+1:           
â€¦
j -j+i:   inst 2
â€¦j -j+i+1:           Btâ€™
uncommon
 trap
To else-branch of i : ifeq j â€™
â€™
Figure 5:Optimisticcompilation optimization
Branch prediction. Fix a method ğ‘šand an instruction ğ‘š[ğ‘–]=
ifeqğ‘—. (ifneqis handled accordingly. ) Let ğµt(resp.ğµf) be the in-
structionsappearingintheif-(resp.else-)branchof ğ‘š[ğ‘–],andthe
lastinstruction ğ‘š[ğ‘–â€²]ofğµfisgotoğ‘—â€².Thefirstandlastinstructions
ofğµfareğ‘š[ğ‘–+1]andğ‘š[ğ‘—âˆ’1]respectively.
Iftheprofilingdatashowthattheprogramfavorstheelse-branch,
thebranchpredictionoptimizationtransformsthemethod ğ‘šintoa
newmethod ğ‘š1forğ‘š[ğ‘–]=ifeqğ‘—(cf.Figure 4).Theformaldefinition
andan illustrating example are given inthe technical report [ 56].
If the profiling data show that the program favors the if-branch,
thebranchpredictionoptimizationtransformsthemethod ğ‘šinto
a new method ğ‘š2, similar to ğ‘š1, except that (1) the conditional
instruction ifeqğ‘—is replaced by ifneq|ğ‘š| âˆ’ğ‘—+ğ‘–âˆ’1which is
immediately followed by the if-branch ğµğ‘¡; (2) the else-branch ğµğ‘“is
movedtotheendofthemethodstartingatthepoint |ğ‘š|âˆ’ğ‘—+ğ‘–âˆ’1
and the target point of the last instruction gotoğ‘—â€²is revised to
ğ‘—â€²âˆ’ğ‘—+ğ‘–+1.
Wedenoteby Tbp(ğ‘š,ğ‘–,else-b)andTbp(ğ‘š,ğ‘–,if-b)themethods ğ‘š1
andğ‘š2respectively.Obviously,thebranchpredictionoptimization
transformsthe originalprogram to asemantically equivalentone.
Optimistic compilation. Again, consider the conditional instruc-
tionğ‘š[ğ‘–]=ifeqğ‘—with the if-branch ğµtand else-branch ğµf. (ifneq
can be dealt withaccordingly.)
Iftheprofilingdatashowthattheif-branchrarelygetsexecuted,
the optimistic compilation optimization transforms the method ğ‘š
intoanewmethod ğ‘š1inasimilarwayto Tbp(ğ‘š,ğ‘–,else-b)except
thattheif-branch ğµtisreplacedbyanuncommontrap,asshown
in Figure 5(left-part). The method ğ‘š2is defined similarly if the
else-branch rarely gets executed, as shown in Figure 5(right-part).
We denoteby Toc(ğ‘š,ğ‘–,else-b)andToc(ğ‘š,ğ‘–,if-b)the newmeth-
odsğ‘š1andğ‘š2after transformation. It is easy to see that the op-
timisticcompilationoptimizationisanequivalentprogramtrans-
formationundertheinputsthatdoesnottriggeranyuncommon
traps.
Method compilation. At runtime, frequently executed, small
methods may be inlined to reduce the time required for method
invocations. After that, both branch prediction and optimistic com-
pilation optimizations could be performed. Thus, a compilation
directive of a method should take into account procedure inline,
branchprediction andoptimistic compilation optimizations.
We define a compilation directive dof a method ğ‘šas a pair
(ğ‘¡,ğœ”),whereğ‘¡isalabeledtreespecifyingthemethodinvocations
876ESEC/FSE â€™22, November14Å›18, 2022,Singapore, Singapore Qi Qin,JulianAndresJiYang,FuSong,TaolueChen, Xinyu Xing
tobeinlined,and ğœ”isasequencespecifyingtheoptimizationsof
branches.Formally,thelabeledtree ğ‘¡isatuple (ğ‘‰,ğ¸,ğ¿),whereğ‘‰is
afinitesetofnodessuchthateachnode ğ‘›âˆˆğ‘‰islabeledbyamethod
ğ¿(ğ‘›)and the root is labeled by ğ‘š;ğ¸is a set of edges of the form
(ğ‘›1,ğ‘–,ğ‘›2)denotingthatthemethod ğ¿(ğ‘›2)isinvokedatthecallsite
ğ‘–ofthemethod ğ¿(ğ‘›1).Wedenoteby ğ‘¡(ğ‘š)thenewmethodobtained
fromğ‘šby iteratively inlining method invocations in ğ‘¡. We assume
the operand stack of each inlined method is balanced, otherwise
theadditionalpopinstructionsareinserted.Thesequence ğœ”isof
the form (T1,ğ‘–1,ğ‘1),Â·Â·Â·,(Tğ‘˜,ğ‘–ğ‘˜,ğ‘ğ‘˜), where for every 1â‰¤ğ‘—â‰¤ğ‘˜,
Tğ‘—âˆˆ {Tbp,Toc}denotestheoptimizationtobeappliedtothebranch
pointğ‘–ğ‘—in the method ğ‘¡(ğ‘š)with the branch preference ğ‘ğ‘—. We
assume that an index ğ‘–ğ‘—occurs at most once in ğœ”, as at most one
optimization can be appliedto one branchpoint.
3.3 ConsistencyandTime-Balancing
Asusual,weassumethateachprogramisannotatedwithasetof
publicinputvariables,whiletheotherinputsareregardedassecret
inputvariables.Wedenoteby ğ‘0â‰ƒpubğ‘â€²
0iftwoconfigurations ğ‘0
andğ‘â€²
0agree on the public input variables, and denote by ğ‘0â‰ƒchğ‘â€²
0
ifğ‘0andğ‘â€²
0have the same code heap.
Consistency . It is easy to deduce the following theorem which
ensurestheequivalenceofthefinalmemorystoreandreturnvalue
from the JIT-free executionandJIT-execution.
Theorem3.1. Foreachinitialconfiguration ğ‘0oftheprogram ğ‘ƒ
and each valid schedule dâ˜…forğ‘0,wehave:ğ‘0â‡“dâ˜…
âˆ…ğ‘iffğ‘0â‡“dâ˜…ğ‘â€².
If the output variables are partitioned into public and secret, we
denotebyğ‘â‰ƒpubğ‘â€²thattwoconfigurations ğ‘andğ‘â€²agreeonthe
publicoutputvariables.
Theorem3.2. Foreachpairofinitialconfigurations (ğ‘0,ğ‘â€²
0)ofthe
programğ‘ƒwithğ‘0â‰ƒpubğ‘â€²
0andeachpairofvalidschedules dâ˜…
1and
dâ˜…
2forğ‘0andğ‘â€²
0respectively,wehave: ğ‘0â‡“ğ‘,ğ‘â€²
0â‡“ğ‘â€²andğ‘â‰ƒpubğ‘â€²
iffğ‘0â‡“dâ˜…
1ğ‘,ğ‘â€²
0â‡“dâ˜…
2ğ‘â€²andğ‘â‰ƒpubğ‘â€².
Thetheoremstatesthatobservingpublicoutputvariablescannot
distinguish secret inputs without JIT compilation iff observing
public output variables cannot distinguish secret inputs with JIT
compilation.
Time-balancing. To model execution time, we define cost func-
tions for bytecode and native code. Let cfbcandcfncbe the cost
functions for instructions from the bytecode and native code, re-
spectively. We denote by cf(inst)the cost of the instruction inst,
which is cfbc(inst)if it is running in bytecode mode, otherwise
cfnc(inst). We lift the function cfto states and configurations as
usual, e.g., cf(âŸ¨pc,ğ‘š,ğœŒ,osâŸ©)=cf(ğ‘š[pc]). The cost cf(ğ‘0â‡“dâ˜…ğ‘ğ‘›)of
aJIT-execution ğ‘0â‡“dâ˜…ğ‘ğ‘›isthesumofallthecostsoftheexecuted
instructions,i.e.,/summationtext.1ğ‘›âˆ’1
ğ‘–=0cf(ğ‘ğ‘–).
Definition3.3. Aprogramğ‘ƒistime-balanced (withoutJITcompi-
lation)ifforeachpairofinitialconfigurations (ğ‘0,ğ‘â€²
0)ofğ‘ƒsuchthat
ğ‘0â‰ƒpubğ‘â€²
0and the code heaps of ğ‘0andğ‘â€²
0have the same bytecode
instructions,we have: cf(ğ‘0â‡“dâ˜…
âˆ…ğ‘)=cf(ğ‘â€²
0â‡“dâ˜…
âˆ…ğ‘â€²).
Intuitively,thetime-balancingrequiresthattwoJIT-freeexecu-
tions have the same cost if their public inputs are the same andcodeheapshavethesamebytecodeinstructions,thuspreventing
timing side-channel leakswhen JIT compilation isdisabled.
JIT-time-balancing. To define time-balancing under JIT compila-
tion,calledJIT-time-balancing,we firstintroduce somenotations.
Consider a JIT-execution ğ‘0â‡“dâ˜…ğ‘ğ‘›and a method ğ‘š. We denote
byprojğ‘š(ğ‘0â‡“dâ˜…ğ‘ğ‘›)the projection of the sequence of executed in-
structionsin ğ‘0â‡“dâ˜…ğ‘ğ‘›ontothepairs (ğ‘–,ğ‘šâ€²)eachofwhichconsists
ofaprogrampoint ğ‘–andaversion ğ‘šâ€²ofthemethod ğ‘š.Aproper
prefixğœ‹ofprojğ‘š(ğ‘0â‡“dâ˜…ğ‘ğ‘›)canbeseenastheprofilingdataofthe
methodğ‘šafterexecutingtheseinstructions,whichdeterminesa
uniquecompilationdirectiveofthemethod ğ‘šafterexecuted ğœ‹.We
leaveruntimeprofilingabstractinordertomodelalargevarietyof
JITcompilationsanduse /hatwideğœ‹todenotetheprofilingdataof ğ‘šafter
executedinstructions ğœ‹ofğ‘šorits compiledversions.
Fixaprofiler pfthatprovidesonecompilationdirective pfğ‘š(/hatwideğœ‹)of
amethodğ‘šusingtheprofilingdata /hatwideğœ‹.Theschedule dâ˜…iscalleda pf-
scheduleif,foreachmethod ğ‘šandproperprefix ğœ‹ofprojğ‘š(ğ‘0â‡“dâ˜…
ğ‘ğ‘›),the nextcompilation directive of ğ‘šindâ˜…afterğœ‹ispfğ‘š(/hatwideğœ‹).
Lemma3.4. Foreachpairofinitialconfigurations (ğ‘0,ğ‘â€²
0)ofğ‘ƒwith
ğ‘0â‰ƒchğ‘â€²
0,andeachpairofvalid pf-schedules dâ˜…
1anddâ˜…
2forğ‘0and
ğ‘â€²
0respectively, we have: for every method ğ‘š, every pair (ğœ‹1,ğœ‹2)of
properprefixesof projğ‘š(ğ‘0â‡“dâ˜…
1ğ‘)andprojğ‘š(ğ‘â€²
0â‡“dâ˜…
2ğ‘â€²)respectively,
ifğœ‹1=ğœ‹2thenpfğ‘š(/hatwideğœ‹1)=pfğ‘š(/hatwideğœ‹2).
Thelemmaensuresthatthecompilationdirectivesofeachmethod
inJIT-executionsare the same underthe same profiling data.
We assume that, for each time-balanced branching statement in
bytecode, the corresponding branching statement in native code is
stilltime-balancedifnoJIToptimizationisapplied.Thisassumption
isreasonableinpractice,asbothsidesofatime-balancedbranching
statement in bytecode tend to have similar functionality and in-
struction sequences, thus, time-balanced branches are often nearly
balancedaftercompilationifnoJIToptimizationisapplied.Remark
thatourformalismisgeneralinprinciple,assuitablecostfunctions
could be adoptedif one prefers to modelthemprecisely.
Definition3.5. Aprogramğ‘ƒisJIT-time-balanced if,foreverypair
of initial configurations (ğ‘0,ğ‘â€²
0)ofğ‘ƒwithğ‘0â‰ƒpubğ‘â€²
0andğ‘0â‰ƒchğ‘â€²
0,
everypairofvalid pf-schedules dâ˜…
1anddâ˜…
2forğ‘0andğ‘â€²
0respectively
satisfiescf(ğ‘0â‡“dâ˜…
1ğ‘)=cf(ğ‘â€²
0â‡“dâ˜…
2ğ‘â€²).
Intuitively,theJIT-time-balancingensuresthattwoJIT-executions
havethesamecostiftheirpublicinputsandinitialcodeheapare
the same and the valid schedules have the same profiler pffor
JIT compilation, so it prevents JIT-induced leaks even if the JIT
compilation is enabled. Remark that our definition considers pow-
erful attackers who can control executing instructions with chosen
inputs before launching attacks so that the code heaps in ğ‘0and
ğ‘â€²
0maybemixedwithbytecodeandnativecodeandcompilation
directives are controlled during attacking, which is common in
the study of detection and mitigation. In practice, the feasibility of
compilation directives depends on various parameters in VM, e.g.,
whetheramethodinvocationshouldbeinlineddependsonitscode
size,invocation frequency,methodmodifier,etc.
4 PROTECTMECHANISMAND TYPE SYSTEM
In this section, based on the above formalism, we first propose a
two-level protection mechanism to prevent JIT-induced leaks and
877DeJITLeak : Eliminating JIT-InducedTiming Side-Channel Leaks ESEC/FSE â€™22, November14Å›18, 2022,Singapore, Singapore
ğ‘š[ğ‘–]=pushğ‘£stâ€²=ptÂ·st
ğ‘š,ğ‘–âŠ¢ (pt,ht,lt,st) â‡’ (pt,ht,lt,stâ€²)T-Pushğ‘š[ğ‘–]=binopğ‘œğ‘stâ€²=(ğœ1âŠ”ğœ2âŠ”pt) Â·st
ğ‘š,ğ‘–âŠ¢ (pt,ht,lt,ğœ1Â·ğœ2Â·st) â‡’ (pt,ht,lt,stâ€²)T-Bopğ‘š[ğ‘–]=storeğ‘¥ltâ€²=lt[ğ‘¥â†¦â†’ğœâŠ”pt]
ğ‘š,ğ‘–âŠ¢ (pt,ht,lt,ğœÂ·st) â‡’ (pt,ht,ltâ€²,st)T-Str
ğ‘š[ğ‘–]=popst=ğœÂ·stâ€²
ğ‘š,ğ‘–âŠ¢ (pt,ht,lt,st) â‡’ (pt,ht,lt,stâ€²)T-Popğ‘š[ğ‘–]=swapğœâ€²
1=ğœ1âŠ”ptğœâ€²
2=ğœ2âŠ”pt
ğ‘š,ğ‘–âŠ¢ (pt,ht,lt,ğœ1Â·ğœ2Â·st) â‡’ (pt,ht,lt,ğœâ€²
2Â·ğœâ€²
1Â·st)T-Swapğ‘š[ğ‘–]=loadğ‘¥stâ€²=(lt(ğ‘¥) âŠ”pt) Â·st
ğ‘š,ğ‘–âŠ¢ (pt,ht,lt,st) â‡’ (pt,ht,lt,stâ€²)T-Load
ğ‘š[ğ‘–]=putğ‘¦htâ€²=ht[ğ‘¦â†¦â†’ğœâŠ”pt]
ğ‘š,ğ‘–âŠ¢ (pt,ht,lt,ğœÂ·st) â‡’ (pt,htâ€²,lt,st)T-Putğ‘š[ğ‘–]=ifeqğ‘—ptâ€²=ğœâŠ”ptptâ€²=Hâ†’ğ‘–âˆˆPM2(ğ‘š)
ğ‘š,ğ‘–âŠ¢ (pt,ht,lt,ğœÂ·st) â‡’ (ptâ€²,ht,lt,st)T-Ifğ‘š[ğ‘–]=gotoğ‘—
ğ‘š,ğ‘–âŠ¢ (pt,ht,lt,st) â‡’ (pt,ht,lt,st)T-Goto
ğ‘š[ğ‘–]=getğ‘¦stâ€²=(ht(ğ‘¥) âŠ”pt) Â·st
ğ‘š,ğ‘–âŠ¢ (pt,ht,lt,st) â‡’ (pt,ht,lt,stâ€²)T-Getğ‘š[ğ‘–]=ifneqğ‘—ptâ€²=ğœâŠ”ptptâ€²=Hâ†’ğ‘–âˆˆPM2(ğ‘š)
ğ‘š,ğ‘–âŠ¢ (pt,ht,lt,ğœÂ·st) â‡’ (ptâ€²,ht,lt,st)T-Ifnğ‘š[ğ‘–]=return(ht,ğœ) |=sigğ‘ƒ(ğ‘š)
ğ‘š,ğ‘–âŠ¢ (pt,ht,lt,ğœÂ·st) â‡’ (ht,ğœ)T-Ret
ğ‘š[ğ‘–]=invokeğ‘šâ€²argv(ğ‘šâ€²)=ğ‘¥0,Â·Â·Â·,ğ‘¥ğ‘˜(pt1,ht1,lt1)â†©â†’ğ‘šâ€²(ht2,ğœ)ptâŠ‘pt1htâŠ‘ht1ğœ0âŠ‘lt1(ğ‘¥0) Â·Â·Â·ğœğ‘˜âŠ‘lt1(ğ‘¥ğ‘˜)ğœâ€²=ğœâŠ”pt
ğ‘š,ğ‘–âŠ¢ (pt,ht,lt,ğœğ‘˜Â· Â·Â·Â· Â·ğœ0Â·st) â‡’ (pt,ht2,lt,ğœâ€²Â·st)T-Call
Figure 6:Typing rules
thenpresentaninformation-flowtypesystemforprovingJIT-time-
balancing underour protectedJITcompilation.
4.1 ProtectionMechanism
ThefirstlevelofourprotectionmechanismistodisableJITcom-
pilation and inlining of methods which potentially induce leaks.
Wedenoteby PM1thesetofmethodsthatcannotbeJITcompiled
or inlined, while methods ğ‘šâ€²âˆˆM\PM1can be JIT compiled or
inlined.The secondlevelisto disableJIT optimization ofbranch
points in methods M\PM1, whose optimization will potentially
induceleaks.We denote by PM2themappingfrom M\PM1to sets
ofbranchpointsthatcannotbeJIToptimized.Whenthemethod
ğ‘šisJITcompiled, PM2(ğ‘š)willbe updatedaccordingly.
FromtheperspectiveofJVM JITsemantics,thecompilationdirec-
tiveofanymethodfrom PM1islimitedto dâˆ…,andthecompilation
directivesofanymethod ğ‘šâ€²âˆˆM\PM1canneitherinlineamethod
fromPM1noroptimize the branchat aprogram pointin PM2(ğ‘šâ€²).
Acompilationpolicy ofaprogram ğ‘ƒisgivenbyapair (PM1,PM2).
Apf-schedule dâ˜…thatiscomplianttothecompilationpolicy (PM1,PM2)
iscalleda (PM1,PM2)-schedule.
4.2 TypeSystemandInference
Weproposeaninformation-flowtypesystemforprovingthattime-
balancedprogramsare JIT-time-balancedundera fine-grainedJIT
compilation withacompilation policy (PM1,PM2).
Latticeforsecuritylevels. Weconsideralatticeofsecuritylevels
L={H,L}withLâŠ‘L,LâŠ‘H,HâŠ‘HandH/nsubsetsqequalL. Initially, all the
public inputs have the low security level Land the other inputs
havethehighsecuritylevel H.Wedenoteby ğœ1âŠ”ğœ2theleastupper
bound of two security levels ğœ1,ğœ2âˆˆL, namely,ğœâŠ”H=HâŠ”ğœ=H
forğœâˆˆLandLâŠ”L=L.
Typingjudgments. Ourtypesystemsupportsprogramswhose
control flow depends on secrets. Thus, the typing rules for in-
structions rely on its path context pt, which indicates whether
an instruction is contained in a secret branch. We use functions
ht:GVarâ†’Landlt:LVarâ†’Lwhich map global and local
variables to security levels. We also use a stack type (i.e., a stack
of security levels) stfor typing operand stack. The order âŠ‘is lifted
to the functions and the stack type as usual, e.g., ht1âŠ‘ht2if
ht1(ğ‘¦) âŠ‘ht2(ğ‘¦)for eachğ‘¦âˆˆGVar.
Atyping judgment for non-return instructions is of the form
ğ‘š,ğ‘–âŠ¢ (pt1,ht1,lt1,st1) â‡’ (pt2,ht2,lt2,st2),whereğ‘šisthemethod
under typing, ğ‘–is a program point in ğ‘š. This judgment states that,given the typing context (pt1,ht1,lt1,st1), the instruction ğ‘š[ğ‘–]
yieldsanewtypingcontext (pt2,ht2,lt2,st2).Atypingjudgment of
thereturnisoftheform ğ‘š,ğ‘–âŠ¢ (pt,ht,lt,st) â‡’ (ht,ğœ),wherehtis
the security levels of the global variables and ğœis the security level
ofthe return value.
Asecurityenvironment seğ‘šofamethod ğ‘šisafunctionwhere
for every program point ğ‘–ofğ‘š,seğ‘š(ğ‘–)is a typing context (ht,ğœ)if
ğ‘š[ğ‘–]isareturn instruction,and (pt,ht,lt,st)otherwise.
Method signature. A (security) signature of a method ğ‘šis of the
form(pt,ht1,lt1)â†©â†’ğ‘š(ht2,ğœ),which states that, given the typing
context(pt,ht1,lt1),eachglobalvariable ğ‘¦âˆˆGVarhasthesecurity
levelht2(ğ‘¦)and the return value of the method ğ‘šhas the security
levelğœ.Eachinvocationof ğ‘šshouldrespectthesignatureof ğ‘š.The
signature of the program ğ‘ƒ, denoted by sigğ‘ƒ, is a mapping from
themethodsoftheprogram ğ‘ƒtotheirsignatures.Sinceamethod
invoked in any secret branch cannot be JIT compiled or inlined,
we require that, forany ğ‘šâˆˆM,ğ‘šâˆˆPM1if the path context ptin
sigğ‘ƒ(ğ‘š)isthe high security level H.
Typingrules. ThetypingrulesareshowninFigure 6,wherethe
key premises are highlighted and (ht,ğœ) |=sigğ‘ƒ(ğ‘š)means that
htâŠ‘htâ€²andğœâŠ‘ğœâ€²forsigğ‘ƒ(ğ‘š)=(pt,ht1,lt1)â†©â†’ğ‘š(htâ€²,ğœâ€²).
Thetypesystemonlychecksbytecodeprograms,thusthereis
notypingruleforthedeoptimizationinstruction deoptmd.Rules
(T-Push), (T-Pop), (T-Bop) and (T-Swap) track the flow of the secret
data via the operand stack. Rules ( T-Str), (T-Load), (T-Put) and (T-
Get) track the flow of the secret data via local and global variables.
Rule(T-Goto) does not changethe typing context.
Rules (T-If) and (T-Ifn) require that the path context ptâ€²of each
branch has a security level no less than the current path context
andthesecuritylevelofthebranchingconditionontopofthestack.
This allowsustotrackimplicitflowsduring typing.Furthermore,
thebranchpoint ğ‘–shouldnotbeoptimizedbyrequiring ğ‘–âˆˆPM2(ğ‘š)
ifptâ€²has the high security level H, otherwise the branches may
become unbalanced,resultinginJIT-inducedleaks.
Rule (T-Ret) requires (ht,ğœ) |=sigğ‘ƒ(ğ‘š)that avoids the security
levels of the global variables in htand the security level ğœof the
returnvaluearegreaterthantheseinthemethodsignature sigğ‘ƒ(ğ‘š).
Rule (T-Call) ensures that the context of invokeğ‘šâ€²meets the
signature sigğ‘ƒ(ğ‘šâ€²)=(pt1,ht1,lt1)â†©â†’ğ‘šâ€²(ht2,ğœ), e.g.,ptâŠ‘pt1
avoidingthatthecurrentpathcontext pthasasecuritylevelgreater
thantheexceptedone pt1,andğœ0âŠ‘lt1(ğ‘¥0)Â·Â·Â·ğœğ‘˜âŠ‘lt1(ğ‘¥ğ‘˜)avoid-
ingthatactualargumentshavethesecuritylevelsgreaterthanthat
offormalarguments.
878ESEC/FSE â€™22, November14Å›18, 2022,Singapore, Singapore Qi Qin,JulianAndresJiYang,FuSong,TaolueChen, Xinyu Xing
Typablemethods. TheJIT-time-balancingisverifiedbytypein-
ference.Toformalize this, we firstintroduce somenotations [ 14].
Letusfixamethod ğ‘š.Foreachprogrampoint ğ‘–,letnxtğ‘š(ğ‘–)bethe
setofsuccessorsof ğ‘–w.r.t.thecontrolflow.Formally, nxtğ‘š(ğ‘–)={ğ‘—}
ifğ‘š[ğ‘–]isgotoğ‘—,nxtğ‘š(ğ‘–)={ğ‘–+1,ğ‘—}ifğ‘š[ğ‘–]isifeqğ‘—orifneqğ‘—,
nxtğ‘š(ğ‘–)=âˆ…ifğ‘š[ğ‘–]isreturn,andnxtğ‘š(ğ‘–)={ğ‘–+1}otherwise.
Foreachbranchpoint ğ‘–,letjunc(ğ‘–)denoteitsjunctionpoint,i.e.,
theimmediatepost-dominatorof ğ‘–.(Recallthatwe assumedthere
is no early return in branches, thus junc(ğ‘–)is well-defined.) We
denoteby region(ğ‘–)thesetofprogrampoints ğ‘—thatcanbereached
from the branch point ğ‘–and are post-dominated by junc(ğ‘–). We
denoteby maxBP(ğ‘—)thesetofbranchpoints ğ‘–suchthatğ‘—=junc(ğ‘–)
andregion(ğ‘–)âŠ„region(ğ‘–â€²)for anyğ‘–â€²âˆˆmaxBP(ğ‘—). Intuitively,
maxBP(ğ‘—)contains the branch points ğ‘–with the junction point
ğ‘—andregion(ğ‘–)is not contained by region(ğ‘–â€²)of any other branch
pointğ‘–â€²with the same junction point ğ‘—, namely, nested branch
pointsğ‘–â€²ofthe branchpoint ğ‘–are excluded.
The method ğ‘šistypablew.r.t.sigğ‘ƒand(PM1,PM2), denoted by
(PM1,PM2,sigğ‘ƒ)â–·ğ‘š,ifthereexistsasecurityenvironment seğ‘šsuch
thatseğ‘š(0)=(pt,ht,lt,ğœ–)forsigğ‘ƒ(ğ‘š)=(pt,ht,lt)â†©â†’ğ‘š(htâ€²,ğœ)
andoneofthefollowingconditionsholdsforeachprogrampoint ğ‘–:
â€¢ifğ‘–isnotajunctionpoint,then ğ‘š,ğ‘—âŠ¢seğ‘š(ğ‘—) â‡’seğ‘š(ğ‘–)forthe
program point ğ‘—such that nxtğ‘š(ğ‘—)={ğ‘–};
â€¢ifğ‘–isajunctionpoint,suppose seğ‘š(ğ‘–)=(pt,ht,lt,st),thenthe
following twoconditions hold:
Å›there exists some ğ‘—âˆˆmaxBP(ğ‘–)withptâ€²âŠ‘ptandseğ‘š(ğ‘—)=
(ptâ€²,htâ€²,ltâ€²,stâ€²);
Å›htâŠ‘htâ€²,ltâŠ‘ltâ€²andstâŠ‘stâ€²fornxt(ğ‘—)=ğ‘–andseğ‘š(ğ‘—)=
(ptâ€²,htâ€²,ltâ€²,stâ€²).
Intuitively, (PM1,PM2,sigğ‘ƒ)â–·ğ‘šrequires that (i) secret branches
areforbidden tobeoptimizedby PM2and(ii) methods ğ‘šâ€²invoked
inregion(ğ‘–)of any secret branches ğ‘š[ğ‘–]are forbidden to be JIT
compiled and inlined. Recall that we have assumed ğ‘šâ€²âˆˆPM1if the
pathcontext ptinsigğ‘ƒ(ğ‘šâ€²)has the high security level H.
A program ğ‘ƒistypablew.r.t.sigğ‘ƒand(PM1,PM2), denoted by
(PM1,PM2,sigğ‘ƒ)â–·ğ‘ƒ, if (i) the signature sigğ‘šof the entry point ğ‘šis
(L,ht,lt)â†©â†’ğ‘š(htâ€²,ğœ)such that ht(ğ‘¦)=Handlt(ğ‘¥)=Hfor any
secretinputs ğ‘¥,ğ‘¦; and(ii)(PM1,PM2,sigğ‘ƒ)â–·ğ‘šfor everyğ‘šâˆˆM.
Theorem4.1. Ifprogramğ‘ƒistime-balancedand (PM1,PM2,sigğ‘ƒ)â–·
ğ‘ƒ,thenğ‘ƒis JIT-time-balanced under (PM1,PM2)-schedules.
The proof is provided in the technical report [ 56]. Note that the
native code in the code heap of each initial configuration can only
be compliedfrom bytecode following the policy (PM1,PM2).
5 IMPLEMENTATION FORPRACTICALJAVA
Wehaveimplementedourapproachasatool DeJITLeak forreal-
worldJavabytecode(Jarpackages). DeJITLeak consistsoftwomain
components: type inference for computing a signature sigğ‘ƒand
apolicy(PM1,PM2)suchthat (PM1,PM2,sigğ‘ƒ)â–·ğ‘ƒ,andaprotection
mechanisminHotSpot from OpenJDK [ 53].
5.1 TypeInference
OurtypeinferenceisbuiltonJOANA[ 40],asound,flow-,context-,
andobject-sensitiveinformationflowframeworkbasedonprogram
dependence graphs (PDGs). Given a program ğ‘ƒannotated withpublic inputs, we first identify secret inputs and then leverage
JOANA to compute a security environment seğ‘šand a signature
sigğ‘ƒ(ğ‘š)for each method ğ‘švia solving flow equations. We then
locate all the branch points in each method ğ‘šwhose path context
orbranchingconditionhasthehighsecuritylevel H,namely,allthe
secret branches. These branch points are added in PM2(ğ‘š), as they
can potentially induce ToptiandTbranleaks when JIT optimized.
Fromthebranchpoints PM2(ğ‘š),weidentifyandextractallthe
methods invoked within region(ğ‘–)for all the branch points ğ‘–âˆˆ
PM2(ğ‘š). These methods can potentially induce Tmethleaks when
JIT compiled or inlined, thus, are added in PM1. According to our
typesystemandthesoundnessofJOANA,theprogram ğ‘ƒistypable
w.r.t.sigğ‘ƒand(PM1,PM2),i.e.,(PM1,PM2,sigğ‘ƒ)â–·ğ‘ƒholds.
5.2 ProtectionMechanism in HotSpot
To enforce a compilation policy (PM1,PM2)during JIT compilation,
we modify HotSpot to demonstrate our approach. To prevent a
methodğ‘šâˆˆPM1from being compiled and inlined, we use the
optionCompileCommand supportedbyHotSpot [ 52], namely,
-XX:CompileCommand=exclude, signature_of_the_method
-XX:CompileCommand=dontinline, signature_of_the_method
where theoption excludedisables JITcompilation ofthemethod
signature_of_the_method ,anddontinline preventsthemethod
signature_of_the_method from procedure inline.
Unfortunately, HotSpot does not provide any option that can
beusedtospecifybranchpointswherebranchpredictionand/or
optimistic compilation can be disabled. Therefore, we modified
HotSpot to support an additional command dontprune that allows
us to specify branch points. The command dontprune is used sim-
ilar toexclude, but with an additional list of branch points for
the specifiedmethod. DuringJIT compilation,bothbranchpredic-
tion and optimistic compilation are prohibited for all these branch
points,even if the methodisrecompiled.
5.3DeJITLeak light
Toreduceperformanceoverhead,wealso proposeand implement
analternativeprotectionmechanism DeJITLeak light.Itonlydis-
ables the inlining of the methods ğ‘šâˆˆPM1whereas DeJITLeak
disables both JIT compilation and inlining of the methods ğ‘šâˆˆPM1.
Thisweakerprotectionmechanismisstillsoundundertheassump-
tion that the methods invoked on both sides of each secret branch
point are the same. This assumption is reasonable in practice, as it
isastraightforwardfordeveloperstoimplementatime-balanced
program by invoking same methods in both sides of each secret
branchpoint.Remarkthatinliningmethodshouldbedisabledeven
ifamethodisinvokedonbothsidesofasecretbranchpoint,asthe
methodmaybe inlinedonly inone branch,inducingleaks.
6 EVALUATION
We first evaluate the efficiency of the type inference and then
compare our approach with other strategies: NOJIT, DisableC2,
andMExclude(cf. Section 2.2). Accordingto[ 16], weonlydisable
JIT compilation of the methods that contain some secret branch
pointsfor MExclude.Finally,we conduct acasestudy.
Experimentsetup . We evaluate DeJITLeak andDeJITLeak light
onthebenchmarksusedinrecentside-channeldetection:Blazer[ 6],
879DeJITLeak : Eliminating JIT-InducedTiming Side-Channel Leaks ESEC/FSE â€™22, November14Å›18, 2022,Singapore, Singapore
Themis [23], CoCo-Channel[ 18], DifFuzz [ 51], and JVMFuzz [ 19],
including real-world programs from well-known Java applications
such as Apache FtpServer, micro-benchmarks from DARPA STAC
and classic examples from the literature [ 36,43,54]. Recall that we
target time-balanced Java bytecode. Thus, we only consider the
Å‚safe" versions, i.e., programs that are leakage-free or only have
slight leaks under their leakage models without JIT compilation.
We also exclude the benchmarks tomcat,pac4j, andtourplanner
from Themis, as tomcatandpac4jhave significant leakages [ 19]
whiletourplanner istime-consuming(0.5hourperexecutionandwe
shall runeach benchmark 1,000 timesperbranch). The remaining
benchmarks are shown in Table 1, whereâ™¯LOC shows the number
of lines in the Java source code counted by cloc [ 24]. Note that for
the purpose of experiments, k96*,modpow1* andmodpow2* are
patchedversionsof k96,modpow1 andmodpow2 ,andunixlogin is
apatchedversionbyDifFuzztoresolvetheNullPointerException
errorinits originalversionfrom Blazer.
AllexperimentsareconductedonanIntelNUCrunningUbuntu
18.04 with Intel Core I5-8259U CPU @ 2.30GHz and 16GB of mem-
ory. To be practical, we do not disable CPU-level and other JIT
optimizations when JITcompilation isenabled.
Insummary,theresultsshowthat(1) DeJITLeak ismoreeffective
thanDisableC2andMExcludeonalmostallthebenchmarks,and
(2)DeJITLeak lightisabletoachievecomparableeffectivenessas
DeJITLeak andinducessignificantly less performance loss.
6.1 Results ofTypeInference
Table1showstheresults,wherecolumns â™¯Nodeand â™¯Edgeshow
thenumberofnodesandedgesinthecorrespondingPDGonwhich
type inference is performed, column ğ‘‡ğ‘¡ğ‘ğ‘–ğ‘›ğ‘¡(ms) shows the exe-
cution time of type inference, column ğ‘‡ğ‘¡ğ‘œğ‘¡ğ‘ğ‘™(s) gives the overall
execution time and column Mem (Mb) gives the overall memory
consumption. We observe that these benchmarks can be solved
efficiently.Ittakes1.99secondsonaverage(upto5.52seconds)and
254Mbforonebenchmark.Notethattheoveralltimeandmemory
consumption does not necessarily correlate with â™¯LOC (e.g., on
gpt14vs.k96), because we only counted the number of lines in
the Java source code but excluded the code of invoked methods
from libraries which were also analyzed during type inference. We
notethatthetimeandmemoryofanalyzingahelloworldprogram
withouttaint sourceis0.93secondsand161Mb.
6.2 Effectiveness andEfficiency
Weevaluatetheeffectivenessbyquantifyingtheamountofleak-
ages in practice using mutual information [ 47], a widely used met-
ric for side channel analysis [ 44,45,48,59]. The mutual informa-
tion of a program containing a vulnerable conditional statement
with the secret condition ğ¾and execution time ğ‘‡is defined as
I(ğ¾;ğ‘‡)=H(ğ¾)âˆ’H(ğ¾|ğ‘‡),whereH(ğ¾)isclassicalShannonentropy
measuringuncertaintyabout ğ¾,andH(ğ¾|ğ‘‡)istheconditionalShan-
nonentropyof ğ¾givenğ‘‡.I(ğ¾;ğ‘‡)measurestheuncertaintyabout ğ¾
afteranattackerhaslearnedtheexecutiontime ğ‘‡.Wecreateattacks
to explore the maximum amount of leakages according to [ 17]. To
discretize the execution time ğ‘‡, we split it into a 20 bins. Note that
the closer the mutual information value is to 1, the stronger the
relationship between the branch condition ğ¾and execution time ğ‘‡.Table 1:Results oftype inference
Name â™¯LOCâ™¯Nodeâ™¯Edgeğ‘‡ğ‘¡ğ‘ğ‘–ğ‘›ğ‘¡(ms)ğ‘‡ğ‘¡ğ‘œğ‘¡ğ‘ğ‘™(s) Mem(Mb)
clear 1311 20 20.24 1.63 242
md5 13 46 67 24.47 2.58 249
salted 1351 82 26.13 2.59 259
stringutils 194 15 25 21.52 1.66 244DifFuzz
authmreloaded 1945 62 23.91 4.02 396
array 35 2 1 16.21 1.00 164
gpt14 5117 22 38.15 2.01 317
k96 40 21 33 51.43 2.16 331
login 53 2 1 17.33 0.99 164
loopbranch 48 2 1 16.55 0.97 160
modpow1 141 23 35 49.54 2.13 294
modpow2 106 14 23 31.80 2.00 312
passwordEq 38 5 6 18.81 1.55 237
sanity 30 2 1 16.36 0.96 160
straightline 32 2 1 16.72 1.01 163Blazer
unixlogin 45 21 29 22.65 1.26 193
bootauth 125 21 34 23.89 3.80 340
jdk 23 2 1 16.66 0.99 164
jetty 32 4 5 18.40 1.54 233
orientdb 211 61 97 39.01 5.52 453
picketbox 47 6 7 18.57 1.58 238Themis
spring 39 7 7 19.90 1.75 277
The results are reported in Table 2in the average of 1,000 exper-
iments for eachbenchmark, where the bestresults among different
methods are in bold face . The second and third columns show the
leakageandexecutiontimewithoutanydefense.Theothercolumns
showtheleakagewiththecorrespondingdefenseandtheoverhead
(calculated as the ratio: execution time with the defense/execution
time withoutdefense) inducedbythe defense.
Effectiveness . Overall, we can observe that (1) all these Å‚safe"
programs are vulnerable (i.e., nonnegligible leakage) due to JIT
compilation;(2)disablingJITcompilation(NOJIT)caneffectively
reduce JIT-induced leakages for most programs except for array,
login,loopbranch ,straightline andunixlogin ; (3)DeJITLeak and
DeJITLeak lightperformsignificantlybetterthanDisableC2and
MExculde, even better than NOJIT on some benchmarks (e.g., md5,
array,login,loopbranch ,sanityjdk andjetty); (4)DeJITLeak and
DeJITLeak lightare almostcomparable.
Efficiency .Wemeasuretheefficiencyofrespectiveapproachby
the times the execution time is increased. In general, (1) NOJIT
incursthe highestperformancecost;(2)DisableC2and MExclude
leadtonearly2Å›7timesruntimeoverhead;(3) DeJITLeak incurs
moreoverheadthanDisableC2andMExclude,butstilloutperforms
DisableC2andMExcludeonmanybenchmarks;(4) DeJITLeak light
bringsthe leastruntimeoverhead(upto 1.82times).
On some benchmarks (e.g., authmreloaded ,array,login,loop-
branch,sanityandjdk),DeJITLeak performsbetterthanDisableC2.
ItisbecauseDisableC2completelydisablesC2modecompilation
forallthemethods,whereas DeJITLeak disablesJITcompilation
and procedure inline of methods invoked in secret branches. Thus,
DeJITLeak performsbetterthanDisableC2whenmanymethods
canbecompiledintheC2modeatruntime.WenotethatMExclude
allowsJITcompilationandinliningofmethodsinvokedinsecret
branches, thus outperforms DeJITLeak in general. When many
methods contain secret branches but few methods are invoked
therein,DeJITLeak performs betterthanMExclude.
880ESEC/FSE â€™22, November14Å›18, 2022,Singapore, Singapore Qi Qin,JulianAndresJiYang,FuSong,TaolueChen, Xinyu Xing
Table 2:Evaluationresults of DeJITLeak andDeJITLeak light
Benchmark NOJIT DisableC2 MExclude DeJITLeak DeJITLeak light
Name Leakage Time( Âµs)Leakage Overhead Leakage Overhead Leakage Overhead Leakage Overhead Leakage Overhead
clear 1.00 4.846 0.02 49.40 0.02 3.47 0.02 12.95 0.01 25.22 1.00 1.00
md5 1.00 6.526 0.19 47.81 0.09 4.13 0.01 10.00 0.01 19.51 0.01 1.82
salted 1.00 6.711 0.02 47.80 0.17 3.93 0.20 9.69 0.03 18.99 0.17 1.77
stringutils 0.97 0.559 0.10 11.90 0.59 1.57 1.00 2.64 0.77 8.92 1.00 1.35
authmreloaded 1.00 8.696 0.01 34.89 0.05 4.46 0.03 1.28 0.03 1.00 0.03 1.00DifFuzz
Average 0.99 5.468 0.07 38.36 0.18 3.51 0.25 7.31 0.17 14.73 0.44 1.39
array 1.00 0.229 1.00 2.00 0.64 1.21 1.00 2.61 0.23 1.00 0.25 1.00
gpt14 1.00 2.157 0.01 45.11 0.01 3.06 0.20 1.80 0.01 15.95 0.01 1.47
k96 1.00 2.414 0.02 42.69 1.00 3.04 0.79 1.83 1.00 18.50 1.00 1.46
k96* 1.00 2.372 0.02 42.93 0.02 3.09 0.59 1.90 0.02 18.99 0.52 1.48
login 1.00 0.266 0.79 2.05 0.67 1.17 0.91 2.68 0.54 1.05 0.54 1.05
loopbranch 1.00 0.243 0.86 5.57 0.80 3.15 0.33 15.34 0.01 0.98 0.01 0.98
modpow1 1.00 78.615 0.02 0.36 1.00 0.21 1.00 0.65 1.00 0.16 1.00 0.95
modpow1* 1.00 78.542 0.01 0.36 0.02 0.23 1.00 0.65 0.01 0.16 0.01 0.94
modpow2 1.00 0.789 0.01 36.92 1.00 2.78 1.00 2.27 1.00 15.61 1.00 1.57
modpow2* 1.00 0.945 0.01 42.15 0.07 2.93 1.00 2.12 0.01 17.55 0.00 1.55
passwordEq 1.00 0.262 0.13 6.61 0.17 1.53 0.56 3.74 0.01 5.39 0.01 1.15
sanity 1.00 0.234 0.25 5.83 0.97 2.82 0.07 16.02 0.01 0.99 0.01 1.00
straightline 1.00 0.231 0.80 2.03 0.07 1.07 0.90 2.16 0.00 1.00 0.01 1.00
unixlogin 1.00 0.316 1.00 8.51 1.00 1.96 1.00 3.03 1.00 10.09 1.00 1.37Blazer
Average 1.00 11.973 0.35 17.37 0.53 2.02 0.74 4.06 0.35 7.67 0.38 1.21
bootauth 1.00 2.793 0.02 106.98 0.01 4.53 0.03 1.53 0.84 1.47 0.04 1.05
jdk 1.00 0.236 0.16 2.15 0.05 1.14 0.19 2.68 0.01 1.01 0.01 1.01
jetty 1.00 0.254 0.11 6.49 0.17 1.51 0.50 3.51 0.01 5.48 0.01 1.14
orientdb 0.99 1.942 0.01 78.48 0.01 3.47 0.33 1.39 0.01 1.28 0.01 0.99
picketbox 1.00 0.252 0.04 7.23 0.02 1.54 1.00 1.82 0.06 7.85 0.01 1.30
spring 1.00 0.509 0.01 14.16 0.02 2.10 0.04 2.63 0.01 1.71 0.01 1.06Themis
Average 1.00 0.998 0.06 35.92 0.05 2.38 0.35 2.26 0.16 3.13 0.02 1.09
6.3 CaseStudy
We discuss someinterestingcasestudiesbelow.
array,login,loopbranch,straightline,unixlogin: Resultsshow
that their leakages are significant in practice, although they are
Å‚safe"benchmarkswithoutJITcompilation[ 6,23,51].Wefoundthat
array,login,loopbranch , andstraightline have balanced branches
in terms of the number of instructions at the source code level.
However, a branch with a balanced number of instructions does
notnecessarilyhavebalancedexecutiontimeevenifJITisdisabled.
Thisindicatesthatmodelingtime-balancingusingthenumberof
instructions may not be precise. Interestingly, both DeJITLeak
andDeJITLeak lightare able to significantly reduce the leakage
ofarray,login,loopbranch , andstraightline . This is because the
percentage of timing difference is fixed, the program speeds up
withtheJITcompilation(i.e.,loweroverhead),makingsidechannel-
unstable and difficult to observe due to the fixed noise. The case
forunixlogin is slightly different. Recall that unixlogin is a patched
version by DifFuzz to resolve the NullPointerException error in
its originalversion fromBlazer.However,thispatch introduceda
leakage whichisalwayssignificantly observable.
stringutils: We observe that only NOJIT effectively reduces the
JIT-inducedleakageof stringutils .Wefoundthat stringutils evalu-
ates a method in Apache FtpServer that pads a string to a specified
length,whereaninsecureversionwouldleakinformationaboutthe
originalstringâ€™slength. DeJITLeak andDeJITLeak lightsuccess-
fully eliminated the JIT-induced leak in this method, guaranteeing
the balance of secret branches in the native code. However, due toCPU-leveloptimizations(e.g.,speculativeexecution),theexecution
time ofdifferentbranches varieswithsecretinputs.
k96, modpow1, modpow2: Similar to stringutils , we observe that
onlyNOJITeffectivelyreducestheirJIT-inducedleakages.These
programs implement various components of the RSA cryptosys-
temâ€™smodularexponentiationusingtheclassicsquare-and-multiply
algorithm, thus their leakages would result in key recovery at-
tacks [43].DeJITLeak andDeJITLeak lightindeed canguarantee
that no leaks are induced by JIT compilation in the native code.
However, due to CPU-level optimizations, the execution time of
the branches varies with secret inputs. To reduce such noise, we
createdpatchedversions k96*,modpow1* andmodpow2* bymoving
thetime-consumingoperationsfrombranchestooutsideoftheir
branching point. After patching, most defense solutions are able to
reduce the JIT inducedleakages.
bootauth: DeJITLeak isnoteffectiveon bootauth,duetoanunbal-
anced branching statement in bytecode. According to our policy,
we need to disable JIT compilation for methods (i.e., fromJSON ,
getTimeandgetExpires ) invoked in secret-dependent branches, but
other methods can be JIT complied including the C2 mode com-
pilation.Butthisunfortunatelyamplifiesthetimingdifferenceof
the existing leak, compared over the entire execution time. Remark
that our approach is designed for programs that are time-balanced
at the bytecode level.
6.4 Discussion
Limitations. First, the execution of JVM profiling, JIT compila-
tionandgarbagecollectionthatmayaffecttheoverallexecution
881DeJITLeak : Eliminating JIT-InducedTiming Side-Channel Leaks ESEC/FSE â€™22, November14Å›18, 2022,Singapore, Singapore
time.Wedidnotformalizethem,astheyareoftenexecutedasyn-
chronously in different threads and are difficult to be exploited.
To our knowledge, no attack leverages them. Second, we did not
formalismCPU-level(suchasspeculativeexecutionandcache)and
other JIT optimizations (e.g., constant propagation, loop unfolding
anddeadelimination)thatmayinducetimingside-channelleaks.
Such leaks have been considered for statically compiled binary
code [25]. To our knowledge, no existing attack leverages those
optimizationsfor Javaprograms. JIT-inducedleaksare significant
to be exploited remotely in real-world applications, thus, for the
sake of separating concerns, we do not consider other leakages. To
detectandmitigatetimingside-channelleaksinducedbyCPU-level
optimizations,onemaycombineourapproachwithexistingones,
e.g., [25,26,41,61,63,68,69]. This is a future work to be explored.
Threats. The first main threat to our evaluation is the noise of
execution time introduced by the compiler (e.g., JVM profiling, JIT
compilation, and garbage collection) and hardware (e.g., CPU-level
optimizations).Tomitigatethethreat,weruneachbenchmark1,000
times per branch in real-world JVM HotSpot without disabling
CPU-level and other JIT optimizations. The second main threat
to our evaluation is the small benchmarks and non-interference
from other users. In this setting, the attacks are more powerful,
namely,the adversaryisable tomeasureand prime accurately,and
thus are more difficult to defeat. We do not impose a bound on the
attackerâ€™sability,thereforeprovidetheoreticsecurityguarantees.In
practice, the timing measurement would be lessundistinguishable
andtheprimewouldbemoredifficultduetosignificantinterference
from other users or the JIT itself on large programs. Therefore, the
evaluation results insuch asettingshould be validatedinfuture.
7 RELATED WORK
Timing side-channel attacks have attracted many attentions, with
a significant amount of work devoted to its detection [ 18,48,51,
54], verification [ 4,6,10,15,23,25,27,28] and mitigation [ 1,22,
27,49,65,66], which vary in targeted programs, leakage models,
techniques,efficiency andprecision, etc.
Morerecentworkfocusesonothersourcesoftimingside-channels,
inducedbymicro-architecturalfeatures(e.g.,Spectre[ 42]andMelt-
down[46])orcompilation(e.g.,JIT-inducedleaks[ 17])whereprov-
ablyleakage-freeprograms(orwithslightleakages)maybecome
vulnerablewhentheyaretakenintoaccount.Ourworkiswithin
this category.
Micro-architecturalfeaturesallownewtimingside-channelat-
tacks such as Spectre, Meltdown and variants thereof [ 20,21,50,
57,60].Thisproblemhasbeenrecentlystudied[ 21,26,37Å›39,41,
61,63,67Å›69],wherespeculativeexecutionsemantics,notionsof
constant-timeunder thenewsemantics,detection andmitigation
approaches, etc, have been proposed. Among them, Blade [ 61] is
theclosesttoourwork,whichaimstoensurethatconstant-time
programsareleakage-freeunderspeculativeandout-of-orderex-
ecution.Ourworkissimilarinspirit,butastheleaksinducedby
JITcompilationandmicro-architecturefeaturesaredifferent,the
concretetechnology(e.g.,securitynotions,detectionandmitiga-
tionapproaches)inthispaperisnew.Moreover,asdiscussedinour
experiments, native code compiled from bytecode may suffer from
leakages induced by micro-architectural features. Such leakagescouldpotentiallybeeliminatedbyintegratingexistingmitigation
approaches(e.g.,Blade) intoJIT compilation.
Besides JIT compilation, static compilation can also introduce
timingleakages.Toaddressthisproblem,constant-timepreserving
compilationhasbeenstudied[ 13]andsubsequentlyimplementedin
theverifiedcompilerCompCert[ 11].However,theydisallowsecret
branches,increasingthedifficultyofimplementingconstant-time
programs.Follow-upworkincludesconstant-resourcepreserving
compilation[ 12]andtimingside-channelsecurityanalysisofbinary
code[25].However,noneofthemconsideredJITcompilationwhich
isfarmore complex thanthe staticcompilation.
TheworkonJIT-inducedtimingchanneliscurrentlyverylim-
ited.Theworkclosetooursis[ 16,17,19].TheJIT-inducedleaks
proposedin[ 17]demonstratedhowJITcompilationcanbelever-
agedtomounttimingside-channelattacks.Afuzzingapproachwas
proposedtodetectJIT-inducedleaks[ 19].However,itmayreport
false negatives and cannot mitigate JIT-induced leaks. The three
strategies(i.e.,NOJIT,DisableC2andMExclude)proposedin[ 16]
have been discussedandcomparedinSection 2.2andSection 6.2.
Inadditiontodetectingandmitigatingtimingside-channelat-
tacks, there are techniques for detecting and mitigating power
side-channel attacks [ 9,29,32Å›35,64,70] and attacks against se-
curemulti-partycomputation[ 5,30]wheretheadversaryisable
to observe all the public information during computation. Each
type of attack has unique characteristics, in general, these existing
techniques are orthogonalto our work.
8 CONCLUSION
In this paper, we formalized time-balancing under JIT compilation,
based on which we proposed an automated approach to eliminate
JIT-induced leaks. Our approach systematically detects potential
leaks via a precise information flow analysis and eliminates poten-
tialleaksvia afine-grainedJIT compilation.We implementedour
approach in the tool DeJITLeak for real-world Java programs. The
evaluationshowed that DeJITLeak ismore effective thanexisting
solutions and provides a trade-off between security and perfor-
mance. The lightweight variant DeJITLeak lightofDeJITLeak
further reduces the overheadbut withcomparable effectiveness.
In future, we plan to improve our approach by taking into ac-
count other JIT optimizations and CPU-level optimizations that
alsointroduce timing side-channels inpractice.
DATA-AVAILABILITYSTATEMENT
To foster further research, benchmarks, experimental data and the
prototypingtoolare releasedat [ 55].
ACKNOWLEDGMENTS
ThisworkissupportedbytheNationalNaturalScienceFoundation
ofChina(NSFC) underGrantsNo.62072309and No.61872340,an
oversea grant from the State Key Laboratory of Novel Software
Technology, Nanjing University (KFKT2018A16), and Birkbeck BEI
SchoolProject(EFFECT).
REFERENCES
[1]JohanAgat.2000.TransformingOutTimingLeaks.In Proceedingsofthe27thACM
SIGPLAN-SIGACTSymposiumonPrinciplesofProgrammingLanguages(POPL) .
40Å›53.https://doi.org/10.1145/325694.325702
882ESEC/FSE â€™22, November14Å›18, 2022,Singapore, Singapore Qi Qin,JulianAndresJiYang,FuSong,TaolueChen, Xinyu Xing
[2]Martin R. Albrecht and Kenneth G. Paterson. 2016. Lucky Microseconds: A
TimingAttackonAmazonâ€™ss2nImplementationofTLS.In Proceedingsofthe35th
Annual International Conference on the Theory and Applications of Cryptographic
Techniques (EUROCRYPT) . 622Å›643. https://doi.org/10.1007/978-3-662-49890-
3_24
[3]NadhemJ.AlFardanandKennethG.Paterson.2013. LuckyThirteen:Breaking
the TLSandDTLSRecord Protocols.In Proceedingsofthe2013 IEEE Symposium
onSecurityand Privacy (S&P) . 526Å›540. https://doi.org/10.1109/SP.2013.42
[4]JosÃ©BacelarAlmeida,ManuelBarbosa,GillesBarthe,FranÃ§oisDupressoir,and
Michael Emmi. 2016. Verifying Constant-Time Implementations. In Proceedings
ofthe 25thUSENIXSecuritySymposium(USENIXSecurity) . 53Å›70.
[5]JosÃ©BacelarAlmeida,ManuelBarbosa,GillesBarthe,HugoPacheco,VitorPereira,
andBernardoPortela.2018. EnforcingIdeal-WorldLeakageBoundsinReal-World
SecretSharingMPCFrameworks.In Proceedingsofthe31stIEEEComputerSecurity
FoundationsSymposium(CSF) . 132Å›146.
[6]TimosAntonopoulos,PaulGazzillo,MichaelHicks,EricKoskinen,TachioTer-
auchi, and Shiyi Wei. 2017. Decomposition Instead of Self-Composition for
ProvingtheAbsenceofTimingChannels.In Proceedingsofthe38thACMSIG-
PLANConferenceonProgramming LanguageDesign andImplementation(PLDI) .
362Å›375. https://doi.org/10.1145/3062341.3062378
[7]Konstantinos Athanasiou, Byron Cook, Michael Emmi, Colm MacCÃ¡rthaigh,
Daniel Schwartz-Narbonne, and Serdar Tasiran. 2018. SideTrail: Verifying Time-
Balancing of Cryptosystems. In Proceedingsofthe 10thInternationalConference
on Verified Software. Theories, Tools, and Experiments - . 215Å›228. https://doi.org/
10.1007/978-3-030-03592-1_12
[8]AurÃ¨le BarriÃ¨re, Sandrine Blazy, Olivier FlÃ¼ckiger, David Pichardie, and Jan
Vitek. 2021. Formally Verified Speculation and Deoptimization in a JIT Compiler.
Proceedings of the ACM on Programming Languages 5, POPL (2021), 1Å›26. https:
//doi.org/10.1145/3434327
[9]Gilles Barthe, Sonia BelaÃ¯d, FranÃ§ois Dupressoir, Pierre-Alain Fouque, Benjamin
GrÃ©goire,Pierre-YvesStrub,andRÃ©beccaZucchini.2016.StrongNon-Interference
andType-DirectedHigher-OrderMasking.In Proceedingsofthe2016ACMSIGSAC
Conference onComputer and Communications Security(CCS) . 116Å›129.
[10]GillesBarthe,GustavoBetarte,JuanDiegoCampo,CarlosDanielLuna,andDavid
Pichardie.2014. System-LevelNon-InterferenceforConstant-TimeCryptography.
InProceedingsofthe2014ACMSIGSACConferenceonComputerandCommunica-
tions Security(CCS) . 1267Å›1279. https://doi.org/10.1145/2660267.2660283
[11]Gilles Barthe, Sandrine Blazy, Benjamin GrÃ©goire, RÃ©mi Hutin, Vincent Laporte,
DavidPichardie,andAlixTrieu.2020. FormalVerificationofaConstant-Time
Preserving C Compiler. Proceedings of the ACM on Programming Languages 4,
POPL(2020), 7:1Å›7:30. https://doi.org/10.1145/3371075
[12]Gilles Barthe, Sandrine Blazy, RÃ©mi Hutin, and David Pichardie. 2021. Secure
Compilation of Constant-Resource Programs. In Proceedings of the 34th IEEE
Computer Security Foundations Symposium (CSF) . 1Å›12.https://doi.org/10.1109/
CSF51468.2021.00020
[13]GillesBarthe,BenjaminGrÃ©goire,andVincentLaporte.2018. SecureCompilation
of Side-Channel Countermeasures: The Case of Cryptographic "Constant-Time".
InProceedingsofthe31stIEEEComputerSecurityFoundationsSymposium(CSF) .
328Å›343. https://doi.org/10.1109/CSF.2018.00031
[14]Gilles Barthe, David Pichardie, and Tamara Rezk. 2013. A Certified Lightweight
Non-InterferenceJavaBytecodeVerifier. MathematicalStructuresinComputer
Science23,5 (2013), 1032Å›1081. https://doi.org/10.1017/S0960129512000850
[15]Sandrine Blazy, David Pichardie, and Alix Trieu. 2019. Verifying Constant-Time
ImplementationsbyAbstract Interpretation. Journal ofComputer Security 27,1
(2019), 137Å›163. https://doi.org/10.3233/JCS-181136
[16]Tegan Brennan. 2020. Static and Dynamic Side Channels in Software . Ph.D.
Dissertation. UC SantaBarbara.
[17]Tegan Brennan, NicolÃ¡s Rosner, and Tevfik Bultan. 2020. JIT Leaks: Inducing
TimingSideChannelsthroughJust-In-TimeCompilation.In Proceedingsofthe
2020 IEEE Symposium on Security and Privacy (S&P) . 1207Å›1222. https://doi.org/
10.1109/SP40000.2020.00007
[18]Tegan Brennan, Seemanta Saha, and Tevfik Bultan. 2018. Symbolic Path Cost
Analysis for Side-channel Detection. In Proceedings of the 40th International
Conference on Software Engineering: Companion Proceeedings (ICSE) . 424Å›425.
https://doi.org/10.1145/3183440.3195039
[19]TeganBrennan,SeemantaSaha,andTevfikBultan.2020. JVMFuzzingforJIT-
inducedSide-ChannelDetection.In ProceedingsoftheACM/IEEE42ndInterna-
tional Conference on Software Engineering (ICSE) . 1011Å›1023. https://doi.org/10.
1145/3377811.3380432
[20]JoVanBulck,MarinaMinkin,OfirWeisse,DanielGenkin,BarisKasikci,Frank
Piessens, Mark Silberstein, Thomas F. Wenisch, Yuval Yarom, and Raoul Strackx.
2018. Foreshadow:ExtractingtheKeystotheIntelSGXKingdomwithTransient
Out-of-Order Execution. In Proceedings ofthe 27thUSENIXSecuritySymposium
(USENIXSecurity) . 991Å›1008.
[21]Sunjay Cauligi, Craig Disselkoen, Klaus von Gleissenthall, Dean M. Tullsen,
Deian Stefan, Tamara Rezk, and Gilles Barthe. 2020. Constant-Time Foundations
fortheNewSpectreEra.In Proceedingsofthe41stACMSIGPLANInternational
ConferenceonProgrammingLanguageDesignandImplementation(PLDI) .913Å›926.https://doi.org/10.1145/3385412.3385970
[22]SunjayCauligi,GarySoeller,BrianJohannesmeyer,FraserBrown,RiadS.Wahby,
JohnRenner,BenjaminGrÃ©goire,GillesBarthe,RanjitJhala,andDeianStefan.
2019. FaCT: a DSL for Timing-Sensitive Computation. In Proceedings of the 40th
ACMSIGPLANInternationalConferenceonProgrammingLanguageDesignand
Implementation(PLDI) . 174Å›189. https://doi.org/10.1145/3314221.3314605
[23]Jia Chen, Yu Feng, and Isil Dillig. 2017. Precise Detection of Side-Channel
VulnerabilitiesusingQuantitativeCartesianHoareLogic.In Proceedingsofthe
2017ACMSIGSACConferenceonComputerandCommunicationsSecurity(CCS) .
875Å›890. https://doi.org/10.1145/3133956.3134058
[24] AlDanial. 2021. Count Lines of Code. https://github.com/AlDanial/cloc .
[25]Lesly-AnnDaniel,SÃ©bastienBardin,andTamaraRezk.2020. Binsec/Rel:Efficient
RelationalSymbolicExecutionforConstant-TimeatBinary-Level.In Proceedings
of the 2020 IEEE Symposium on Security and Privacy . 1021Å›1038. https://doi.org/
10.1109/SP40000.2020.00074
[26]Lesly-AnnDaniel,SÃ©bastienBardin,andTamaraRezk.2021.HuntingtheHaunter
- Efficient Relational Symbolic Execution for Spectre with Haunted RelSE. In Pro-
ceedings of the 28th Annual Network and Distributed System Security Symposium .
[27]Goran Doychev, Dominik Feld, Boris KÃ¶pf, Laurent Mauborgne, and Jan Reineke.
2013. CacheAudit: A Tool for the Static Analysis of Cache Side Channels. In
Proceedings of the 22th USENIX Security Symposium (USENIX Security) . 431Å›446.
[28]Goran Doychev and Boris KÃ¶pf. 2017. Rigorous Analysis of Software Coun-
termeasures against Cache Attacks. In Proceedings of the 38th ACM SIGPLAN
InternationalConferenceonProgrammingLanguageDesignandImplementation
(PLDI). 406Å›421. https://doi.org/10.1145/3062341.3062388
[29]Hassan Eldib, Chao Wang, and Patrick Schaumont. 2014. Formal Verification
ofSoftwareCountermeasuresagainstSide-ChannelAttacks. ACMTrans.Softw.
Eng.Methodol. 24,2 (2014), 11:1Å›11:24.
[30]Yuxin Fan, Fu Song, Taolue Chen, Liangfeng Zhang, and Wanwei Liu. 2022.
PoS4MPC: Automated Security Policy Synthesis for Secure Multi-Party Com-
putation.In Proceedingsofthe34thInternationalConferenceonComputerAided
Verification (CAV) .
[31]Olivier FlÃ¼ckiger, Gabriel Scherer, Ming-Ho Yee, Aviral Goel, Amal Ahmed,
and Jan Vitek. 2018. Correctness of Speculative Optimizations with Dynamic
Deoptimization. Proceedings of the ACM on Programming Languages 2, POPL
(2018), 49:1Å›49:28. https://doi.org/10.1145/3158137
[32]PengfeiGao,HongyiXie,FuSong,andTaolueChen.2021. AHybridApproachto
Formal Verification of Higher-OrderMasked Arithmetic Programs. ACM Trans.
Softw.Eng.Methodol. 30,3 (2021), 26:1Å›26:42.
[33]PengfeiGao,HongyiXie,PuSun,JunZhang,FuSong,andTaolueChen.2022.
Formal Verification of Masking Countermeasures for Arithmetic Programs. IEEE
Trans. SoftwareEng. 48,3 (2022), 973Å›1000.
[34]Pengfei Gao, Hongyi Xie, Jun Zhang, Fu Song, and Taolue Chen. 2019. Quantita-
tive Verification of Masked Arithmetic Programs Against Side-Channel Attacks.
InProceedingsofthe25thInternationalConferenceonToolsandAlgorithmsforthe
ConstructionandAnalysisofSystems,HeldasPartoftheEuropeanJointConfer-
ences onTheoryand Practice ofSoftware(TACAS) . 155Å›173.
[35]PengfeiGao,JunZhang,FuSong,andChaoWang.2019. VerifyingandQuantify-
ing Side-channelResistanceofMaskedSoftware Implementations. ACMTrans.
Softw.Eng.Methodol. 28,3 (2019), 16:1Å›16:32.
[36]DanielGenkin, Itamar Pipman, and EranTromer.2014. Get Your Hands Off My
Laptop: Physical Side-Channel Key-Extraction Attacks on PCs. In Proceedings
of the 16th International Workshop on Cryptographic Hardware and Embedded
Systems(CHES) ,Vol.8731.242Å›260. https://doi.org/10.1007/978-3-662-44709-
3_14
[37]Marco Guarnieri, Boris KÃ¶pf, JosÃ© F. Morales, Jan Reineke, and AndrÃ©s SÃ¡nchez.
2020. Spectector: Principled Detection of Speculative Information Flows. In
Proceedings of the 2020 IEEE Symposium on Security and Privacy (S&P) . 1Å›19.
https://doi.org/10.1109/SP40000.2020.00011
[38]Shengjian Guo,Yueqi Chen,Peng Li,Yueqiang Cheng, Huibo Wang, Meng Wu,
andZhiqiangZuo.2020. SpecuSym:SpeculativeSymbolicExecutionforCache
TimingLeakDetection.In ProceedingsoftheACM/IEEE42ndInternationalConfer-
ence on Software Engineering (ICSE) . 1235Å›1247. https://doi.org/10.1145/3377811.
3380428
[39]ShengjianGuo,YueqiChen,JiyongYu,MengWu,ZhiqiangZuo,PengLi,Yue-
qiangCheng,andHuiboWang.2020.ExposingCacheTimingSide-ChannelLeaks
Through Out-Of-Order Symbolic Execution. Proceedings of the ACM on Program-
mingLanguages 4,OOPSLA(2020),147:1Å›147:32. https://doi.org/10.1145/3428215
[40]Christian Hammer and Gregor Snelting. 2009. Flow-Sensitive, Context-Sensitive,
andObject-SensitiveInformationFlowControlBasedonProgramDependence
Graphs.International Journal of Information Security 8, 6 (2009), 399Å›422. https:
//doi.org/10.1007/s10207-009-0086-1
[41]Zecheng He, Guangyuan Hu, and Ruby B. Lee. 2021. New Models for Under-
standingand ReasoningaboutSpeculativeExecutionAttacks.In Proceedingsof
the IEEE International Symposium on High-Performance Computer Architecture
(HPCA). 40Å›53.https://doi.org/10.1109/HPCA51647.2021.00014
[42]PaulKocher,JannHorn,AndersFogh,DanielGenkin,DanielGruss,WernerHaas,
MikeHamburg,MoritzLipp,StefanMangard,ThomasPrescher,MichaelSchwarz,
883DeJITLeak : Eliminating JIT-InducedTiming Side-Channel Leaks ESEC/FSE â€™22, November14Å›18, 2022,Singapore, Singapore
and Yuval Yarom. 2019. Spectre Attacks: Exploiting Speculative Execution. In
Proceedings of the 2019 IEEE Symposium on Security and Privacy (S&P) . 1Å›19.
https://doi.org/10.1109/SP.2019.00002
[43]Paul C. Kocher. 1996. Timing Attacks on Implementations of Diffie-Hellman,
RSA, DSS, and Other Systems. In Proceedings of the 16th Annual International
Cryptology Conference on Advances in Cryptology (CRYPTO) . 104Å›113. https:
//doi.org/10.1007/3-540-68697-5_9
[44]Boris KÃ¶pf and David A. Basin. 2007. An Information-Theoretic Model for
Adaptive Side-Channel Attacks. In Proceedings of the 2007 ACM Conference on
Computer and Communications Security (CCS) . 286Å›296. https://doi.org/10.1145/
1315245.1315282
[45]BorisKÃ¶pf,LaurentMauborgne,andMartÃ­nOchoa.2012. AutomaticQuantifi-
cation of Cache Side-Channels. In Proceedings of the 24th International Con-
ference on Computer Aided Verification (CAV) , Vol. 7358. 564Å›580. https:
//doi.org/10.1007/978-3-642-31424-7_40
[46]Moritz Lipp, Michael Schwarz, Daniel Gruss, Thomas Prescher, Werner Haas,
Anders Fogh, Jann Horn, Stefan Mangard, Paul Kocher, Daniel Genkin, Yuval
Yarom, and Mike Hamburg. 2018. Meltdown: Reading Kernel Memory from User
Space.In Proceedingsof the27th USENIX Security Symposium(USENIX Security) .
973Å›990.
[47]PasqualeMalacariaandJonathanHeusser.2010.InformationTheoryandSecurity:
QuantitativeInformationFlow.In The10thInternationalSchoolonFormalMethods
for the Design ofComputer, CommunicationandSoftware Systems(SFM) . 87Å›134.
https://doi.org/10.1007/978-3-642-13678-8_3
[48]PasqualeMalacaria,M.H.R.Khouzani,CorinaS.Pasareanu,Quoc-SangPhan,
and Kasper SÃ¹e Luckow. 2018. Symbolic Side-Channel Analysis for Probabilistic
Programs.In Proceedings of the31st IEEEComputer SecurityFoundations Sympo-
sium (CSF) . 313Å›327. https://doi.org/10.1109/CSF.2018.00030
[49]Heiko Mantel and Artem Starostin. 2015. Transforming Out Timing Leaks, More
or Less. In Proceedings of the 20th European Symposium on Research in Computer
Security(ESORICS) . 447Å›467. https://doi.org/10.1007/978-3-319-24174-6_23
[50]MarinaMinkin,DanielMoghimi,MoritzLipp,MichaelSchwarz,JoVanBulck,
DanielGenkin,DanielGruss,FrankPiessens,BerkSunar,andYuvalYarom.2019.
Fallout: Reading Kernel Writes From User Space. CoRRabs/1905.12701 (2019).
http://arxiv.org/abs/1905.12701
[51]Shirin Nilizadeh, Yannic Noller, and Corina S. Pasareanu. 2019. DifFuzz: Dif-
ferential Fuzzing for Side-Channel Analysis. In Proceedings of the ACM/IEEE
41st International Conference on Software Engineering (ICSE) . 176Å›187. https:
//doi.org/10.1109/ICSE.2019.00034
[52]Oracle. 2021. HotSpot VM. https://docs.oracle.com/javase/8/docs/technotes/
tools/unix/java.html .
[53]Oracle.2021.OpenJDK:JDK8sourcecode(Mercurialrepository),tagjdk8u292-ga.
https://hg.openjdk.java.net/jdk8u/jdk8u/jdk .
[54]Corina S. Pasareanu, Quoc-Sang Phan, and Pasquale Malacaria. 2016. Multi-run
Side-Channel Analysis Using Symbolic Execution and Max-SMT. In Proceedings
ofthe29thIEEEComputerSecurityFoundationsSymposium(CSF) .387Å›400. https:
//doi.org/10.1109/CSF.2016.34
[55]QiQin,JulianAndresJiYang,FuSong,TaolueChen,andXinyuXing.2022. De-
JITLeak: v1.1 .https://doi.org/10.5281/zenodo.7080369
[56]Qi Qin,JulianAndres JiYang, FuSong,TaolueChen,andXinyuXing.2022. Pre-
venting Timing Side-Channels via Security-Aware Just-In-Time Compilation.
CoRRabs/2202.13134 (2022).
[57]Michael Schwarz, Moritz Lipp, Daniel Moghimi, Jo Van Bulck, Julian Steck-
lina, Thomas Prescher, and Daniel Gruss. 2019. ZombieLoad: Cross-Privilege-
Boundary Data Sampling. In Proceedings of the 2019 ACM SIGSAC Confer-
ence on Computer and Communications Security (CCS) . ACM, 753Å›768. https://doi.org/10.1145/3319535.3354252
[58]STAC. 2017. DARPA space/time analysis for cybersecurity (STAC) program.
http://www.darpa.mil/program/space-time-analysis-for-cybersecurity .
[59]FranÃ§ois-XavierStandaert,TalMalkin,andMotiYung.2009.AUnifiedFramework
fortheAnalysisofSide-ChannelKeyRecoveryAttacks.In Proceedingsofthe28th
Annual International Conference on the Theory and Applications of Cryptographic
Techniques(EUROCRYPT) ,Vol.5479.443Å›461. https://doi.org/10.1007/978-3-642-
01001-9_26
[60]StephanvanSchaik,AlyssaMilburn,SebastianÃ–sterlund,PietroFrigo,Giorgi
Maisuradze, Kaveh Razavi, Herbert Bos, and Cristiano Giuffrida. 2019. RIDL:
RogueIn-FlightDataLoad.In Proceedingsofthe2019IEEESymposiumonSecurity
and Privacy (S&P) . 88Å›105. https://doi.org/10.1109/SP.2019.00087
[61]Marco Vassena, Craig Disselkoen, Klaus von Gleissenthall, Sunjay Cauligi,
Rami GÃ¶khan Kici, Ranjit Jhala, Dean M. Tullsen, and Deian Stefan. 2021. Au-
tomatically eliminatingspeculativeleaksfromcryptographiccode withblade.
Proceedings of the ACM on Programming Languages 5, POPL (2021), 1Å›30. https:
//doi.org/10.1145/3434330
[62]DennisM. Volpano, Cynthia E.Irvine, andGeoffreySmith. 1996. A Sound Type
System for Secure Flow Analysis. Journal of Computer Security 4, 2/3 (1996),
167Å›188. https://doi.org/10.3233/JCS-1996-42-304
[63]Guanhua Wang, Sudipta Chattopadhyay, Ivan Gotovchits, Tulika Mitra, and
Abhik Roychoudhury. 2019. oo7: Low-overhead Defense against Spectre Attacks
via Program Analysis. IEEE Transactions on Software Engineering (2019), 1Å›1.
https://doi.org/10.1109/TSE.2019.2953709
[64]Jingbo Wang, Chungha Sung, and Chao Wang. 2019. Mitigating power side
channelsduringcompilation.In ProceedingsoftheACMJointMeetingonEuropean
SoftwareEngineeringConferenceandSymposiumontheFoundationsofSoftware
Engineering (ESEC/FSE) . 590Å›601.
[65]ConradWatt,JohnRenner,NataliePopescu,SunjayCauligi,andDeianStefan.
2019. CT-Wasm: Type-Driven Secure Cryptography for the Web Ecosystem.
ProceedingsoftheACMonProgrammingLanguages 3,POPL(2019),77:1Å›77:29.
https://doi.org/10.1145/3290390
[66]MengWu,ShengjianGuo,PatrickSchaumont,andChaoWang.2018. Eliminating
TimingSide-ChannelLeaksusingProgramRepair.In Proceedingsofthe27thACM
SIGSOFTInternationalSymposiumonSoftwareTestingandAnalysis(ISSTA) .15Å›26.
https://doi.org/10.1145/3213846.3213851
[67]Meng Wu and Chao Wang. 2019. Abstract Interpretation under Speculative
Execution. In Proceedings of the 40th ACM SIGPLAN International Conference
onProgrammingLanguageDesignandImplementation(PLDI) .802Å›815. https:
//doi.org/10.1145/3314221.3314647
[68]Mengjia Yan, Jiho Choi, Dimitrios Skarlatos, Adam Morrison, Christopher W.
Fletcher, and Josep Torrellas. 2018. InvisiSpec: Making Speculative Execution
Invisible in the Cache Hierarchy. In Proceedings of the 51st Annual IEEE/ACM
InternationalSymposiumonMicroarchitecture(MICRO) .428Å›441. https://doi.org/
10.1109/MICRO.2018.00042
[69]Jiyong Yu, Mengjia Yan, Artem Khyzha, Adam Morrison, Josep Torrellas, and
Christopher W. Fletcher. 2020. Speculative Taint Tracking (STT): A Comprehen-
siveProtectionforSpeculativelyAccessedData. IEEE Micro 40,3 (2020),81Å›90.
https://doi.org/10.1109/MM.2020.2985359
[70]JunZhang,PengfeiGao,FuSong,andChaoWang.2018. SCInfer:Refinement-
Based Verification of Software Countermeasures Against Side-Channel Attacks.
InProceedingsofthe30thInternationalConferenceonComputerAidedVerification
(CAV). 157Å›177.
884