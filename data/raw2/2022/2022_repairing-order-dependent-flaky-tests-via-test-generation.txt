Repairing Order-Dependent Flaky Tests via Test Generation
Chengpeng Li
The University of Texas at Austin
Austin, TX, USA
chengpengli@utexas.eduChenguang Zhu
The University of Texas at Austin
Austin, TX, USA
cgzhu@utexas.edu
Wenxi Wang
The University of Texas at Austin
Austin, TX, USA
wenxiw@utexas.eduAugust Shi
The University of Texas at Austin
Austin, TX, USA
august@utexas.edu
ABSTRACT
Flaky tests are tests that pass or fail nondeterministically on the
same version of code. These tests can mislead developers concern-
ingthequalityoftheircodechangesduringregressiontesting.A
common kind of flaky tests are order-dependent tests, whose pass/
fail outcomes depend on the test order in which they are run. Such
testshavedifferentoutcomesbecauseothertestsrunningbefore
thempollutesharedstate.Priorworkhasproposedrepairingorder-
dependenttestsbysearchingforexistingtests,knownas‚Äúcleaners‚Äù,thatresetthesharedstate,allowingtheorder-dependenttesttopass
whenrunafterapollutedsharedstate.Thecodewithinacleaner
representsapatchtorepairtheorder-dependenttest.However,this
technique requires cleaners to already exist in the test suite.
We propose ODRepair, an automated technique to repair order-
dependent tests even without existing cleaners. The idea is to first
determine the exact polluted shared state that results in the order-
dependenttest tofail andthen generatecodethat canmodify and
resetthesharedstatesothattheorder-dependenttestcanpass.We
focus on shared state through internal heap memory, in particular
sharedstatereachablefromstaticfields.Onceweknowwhichstaticfieldleadstothepollution,wesearchforreset-methodsinthecode-
base that can potentially access and modify state reachable from
thatstaticfield.Wethenapplyanautomatictest-generationtooltogeneratemethod-callsequences,targetingthesereset-methods.Our
evaluationon327order-dependenttestsfromapubliclyavailable
dataset shows that ODRepair automatically identifies the polluted
staticfieldfor181tests,anditcangeneratepatchesfor141ofthese
tests. Compared against state-of-the-art iFixFlakies, ODRepair can
generate patches for 24 tests that iFixFlakies cannot.
CCS CONCEPTS
‚Ä¢Softwareanditsengineering ‚ÜíSoftwaretestinganddebug-
ging.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
onthe firstpage.Copyrights forcomponentsof thisworkowned byothersthan the
author(s)mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,or
republish,topostonserversortoredistributetolists,requirespriorspecificpermission
and/or a fee. Request permissions from permissions@acm.org.
ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA
¬© 2022 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ACM ISBN 978-1-4503-9221-1/22/05...$15.00
https://doi.org/10.1145/3510003.3510173KEYWORDS
flaky test, order-dependent test, test generation, automated repair
ACM Reference Format:
Chengpeng Li, Chenguang Zhu, Wenxi Wang, and August Shi. 2022. Re-
pairing Order-Dependent Flaky Tests via Test Generation. In 44th Inter-
national Conference on Software Engineering (ICSE ‚Äô22), May 21‚Äì29, 2022,
Pittsburgh, PA, USA. ACM, New York, NY, USA, 12pages.https://doi.org/10.
1145/3510003.3510173
1 INTRODUCTION
Regression testing is an important part of the software develop-
ment process, but it suffers from the presence of flaky tests. Flaky
tests are tests that nondeterministically pass or fail when run on
the same version of code [ 37]. A flaky test failure can mislead a
developer about their recent code changes, leading them to debug
theirchangeswhentheproblemsareelsewhere.Previousstudies
have identified a number of root causes for flakiness [ 23,37], with
test-order dependence as a common cause.
Test-order dependence results in order-dependent tests, whose
pass/fail outcomes depend on the test order in which they are run.
Anorder-dependenttestalwayspassesinonetestorder,its passing
test order; but fails when run in another order, its failing test order.
Unfortunately,the testorderisnot guaranteed.Forexample,Java
developersusingJUnitforunittestingfoundtheirtestsfailingafter
a change from Java 6 to Java 7 [ 1,2,31]. After the Java upgrade,
JUnitstartedrunningtestsindifferenttestorders,exposingexisting
test-order dependence in the test suite that only now manifests
after the Java version change (and not due to code changes). There
hasalsobeenmuchpriorresearchondevelopingtechniquesthat
can automatically detect order-dependent tests [27, 28,32,48].
Shietal.previouslyproposediFixFlakies[ 43]toautomatically
repairorder-dependenttests.Theycategorizeorder-dependenttests
into two types: (1) A brittleis a test that fails when run on its own
butpasseswhensomeothertestsrunbefore;theseteststhatrun
beforesetupthestateforthebrittletopass.(2)A victimisatest
that passes when run on its own but fails when some other tests
runbefore;theseteststhatrunbeforeare‚Äúpolluting‚Äùthestatethey
share with the victim, leading to the victim‚Äôs failure. iFixFlakies‚Äôinsight is that these tests that set the state when run before thebrittle contain code that can be made into a patch to repair thebrittle. For victims, iFixFlakies can look for cleaners, which are
teststhat,whenrunbetweenapollutingtestandthevictim,canreset the shared state to allow the victim to pass. iFixFlakies can
createapatchoutofthesecleanersastorepairthevictim.However,
18812022 IEEE/ACM 44th International Conference on Software Engineering (ICSE)
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:52:10 UTC from IEEE Xplore.  Restrictions apply. ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA Chengpeng Li, Chenguang Zhu, Wenxi Wang, and August Shi
iFixFlakies relies on developers having already written cleaners; if
they do not exist, iFixFlakies cannot generate patches.
We propose ODRepair, a technique to repair order-dependent
tests without requiring the existing test suite to contain clean-
ers. ODRepair first identifies the polluted state in-between tests.
ODRepairthengeneratesmethod-callsequencesthatmodifythe
polluted state, resetting it for the order-dependent test. In other
words, ODRepair aims to automatically generate the cleaners that
iFixFlakiesneedstogeneratepatchesfortheorder-dependenttests.
ODRepairfindsthepollutedstatebetweentestsbycapturingthe
state between the polluter and the victim order-dependent test (we
only focus on victims because brittles are guaranteed to have tests
thatsetthestatebefore).Wefocusonin-memoryheap-stateshared
between tests, as prior work found test-order dependence to come
from shared heap-state, specifically reachable from static fields [ 28,
37,48]. The goal is to determine which static field is ‚Äúpolluted‚Äù,
i.e., the heap-state reachable from that field right before the order-
dependent test runs differs between the passing and failing test
orders, andthe differenceresults ina failing order-dependenttest.
Giventhepollutedstaticfield,ODRepairgeneratesamethod-call
sequence that can modify the heap-state reachable from that static
field to reset the shared state. ODRepair first searches through the
codebaseforreset-methodsthatcanaccessthepollutedstaticfieldandeitherchangethestaticfieldvaluedirectlyormodifystatethatthestaticfieldreaches.Foreachreset-method,ODRepairconfiguresRandoop [
10], an automatic test-generation tool, to ‚Äútest‚Äù the reset-
method by generating method-call sequences that utilize the reset-
method in various ways. Our goal of using the test-generationtool is not the standard goal of covering code and finding bugs,
butrathertohaveitgenerateteststhatarecleanersfortheorder-
dependenttest.ODRepairsendsthesegeneratedteststoiFixFlakiestocheckifanyofthemareactuallycleaners,whichiFixFlakiesthen
uses to generate patches for order-dependent tests.
WeevaluateODRepairon327order-dependenttestsobtained
from IDoFT [ 6], a public dataset of flaky tests. ODRepair auto-
matically identifies the polluted static field for 181 of these tests.Furthermore, ODRepair automatically generates a patch for 141order-dependent tests. Compared against iFixFlakies, iFixFlakiescan generate a patch for 135 of those 181 order-dependent tests.
We find 24 tests (13.3%) where ODRepair generates a patch but
iFixFlakiescannot.Ontheotherhand,iFixFlakiesgeneratesapatch
for 18 tests that ODRepair cannot (9.9%). Based on our findings,
we recommend that ODRepair and iFixFlakies be used together
in a complementary way. A developer can first apply iFixFlakiesto check whether the existing tests already contain cleaners. If
iFixFlakies is unsuccessful, the developer can then apply ODRepair
to generate a cleaner for repairing the order-dependent test.
This paper makes the following contributions:
‚Ä¢Automated pollution detection. ODRepair automatically
identifies the polluted state by comparing heap-state be-
tween different test orders and loading state captured from
the passing test order as to isolate the actual polluted state.
‚Ä¢Generatingpatchesviatestgeneration. ODRepairguides
the use of a test-generation tool to create method-call se-quences that invoke reset-methods for the polluted state,
creatingteststhatcontainpatchesfororder-dependenttests.‚Ä¢Evaluation. WeevaluateODRepairon327order-dependent
tests,wherewesuccessfullyidentifythepollutedstatefor
181 and could generate a patch for 141 of those tests.
2 BACKGROUND AND EXAMPLE
Anorder-dependent test is a flaky test whose pass/fail outcome
depends on the test order in which it runs. In other words, there
exists a test order where the order-dependent test passes (we refer
toitasapassingtestorder )andanotherdifferenttestorder where
the order-dependent test fails(we refer to it as a failing test order ).
Furthermore, to be qualified as an order-dependent test, the testorder is the only determining factor for whether the test passesor fails when run on the same code, i.e., running the same test
ordermultipletimes alwaysresultsinthe samepass/failoutcome;
otherwise,whilethetestisstillflaky,itwouldbeanon-order-depen-
dent test [32].
Shi et al. [ 43] previously categorized order-dependent tests into
two types: brittles and victims. A brittlehas a failing test order
where the test runs by itself, and it hasa passing test order where
someothertestsrunbeforeit.Conceptually,theseothertestswhen
run before are ‚Äúsetting‚Äù up the correct initial state for the brittle
test; Shi et al. referred to such tests as ‚Äústate-setters‚Äù. On the other
hand, avictimhas a passing test order where the test runs by itself,
and it has a failing test order where some other tests run before
it. Conceptually, these othertests when run before are‚Äúpolluting‚Äù
some shared state between the tests, leading the victim test to run
in a polluted state that results in a test failure; Shi et al. referred to
such tests as ‚Äùpolluters‚Äù.
Shi et al. further developed a technique, iFixFlakies, that auto-
matically repairs order-dependent tests. First, iFixFlakies‚Äô Mini-mizer component finds the state-setters and polluters per brittle
andvictim,respectively,byusingdelta-debugging[ 46]onthegiven
passing test order or failing test order for the order-dependent test.
Next, for brittles, the insight is that state-setters must exist by def-
inition, and these tests contain code that would set up the statefor the brittle to pass. For victims, the insight is that there existother tests, which Shi et al. termed ‚Äúcleaners‚Äù, that, when run in-between a polluter and its corresponding victim, would result in
the victim passing. Unfortunately, unlike brittles, such cleaners are
notguaranteedtoexist.Essentially,iFixFlakiesreliesondevelopers
to have already written such tests that contain the needed logicfor cleaning the polluted state. Once the state-setter/cleaner has
been identified,iFixFlakies‚Äô Patcher componentgenerates a patch
per order-dependent test by minimizing the statements within the
identified state-setter/cleaner (also through delta-debugging), re-sulting in the minimal set of statements that can be added to the
order-dependent test so it passes even in the failing test order.
Giventhatbrittlesareguaranteedtohavestate-setters,wefocus
solely on generating patches for victims. Moreover, Shi et al. found
that victims constitute a much larger proportion of order-depen-
denttestscomparedagainstbrittles[ 43],soitismorereasonable
to focus on repairing these types of order-dependent tests. For the
restofthispaper,theorder-dependenttestswerefertoaremore
precisely victims unless otherwise noted.
Example.ConsidertheexamplecodeandtestsillustratedinFig-
ure1, taken from open-source project elasticjob/elastic-job-lite,
1882
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:52:10 UTC from IEEE Xplore.  Restrictions apply. Repairing Order-Dependent Flaky Tests via Test Generation ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA
1// polluter/vic tim test class
2public final class ShutdownListenerManagerTest {
3@Mock private SchedulerFacade sf;
4private ShutdownListenerManager slm;
5
6@Before
7public void setUp() {
8JobRegistry.getInstance()
9 .addJobInstance( "test_job" , ...);
10slm =
11 newShutdownListenerManager(..., "test_job" );
12ReflectionUtils
13 .setFieldValue(slm, "schedulerFacade" ,s f ) ;
14}
1516
// polluter
17@Test public void assertRemoveLocalInstancePath() {
18JobRegistry.getInstance()
19 .registerJob( "test_job" , ...);
20slm.newListener().dataChanged(...);
21verify(sf).shutdownInstance();
22}
2324
// victim
25@Test public void assertIsShutdownAlready() {
26slm.newListener().dataChanged(...);
27verify(sf, times(0)).shutdownInstance();
28}
29}
3031
public final class ShutdownListenerManager {
32private final String jobName;
33private final SchedulerFacade schedulerFacade;
3435
classListener {
36protected voiddataChanged(...) {
37 if(!JobRegistry.getInstance()
38 .isShutdown(jobName)) {
39 schedulerFacade.shutdownInstance();
40 }
41}
42}
43}
4445
// class with polluted state
46public final class JobRegistry {
47private static volatile JobRegistry instance;
48private final Map<...> schedulerMap;
4950
public static JobRegistry getInstance() {
51return instance;
52}
53public void registerJob( finalString jobName, ...) {
54schedulerMap.put(jobName, ...);
55}
56public void shutdown( finalString jobName) {
57... = schedulerMap.remove(jobName);
58}
59public boolean isShutdown( finalString jobName) {
60return !schedulerMap.containsKey(jobName);
61}
62}
Figure 1: Example order-dependent test from
elasticjob/elastic-job-lite.whichweuseinourevaluation.Theorder-dependenttestinthis
example is ShutdownListenerManagerTest.assertIsShutdown-
Already. This test is a victim that passes when run on its own
butfailswhenrunafterthepolluter ShutdownListenerManager-
Test.assertRemoveLocalInstancePath.
Thepolluterinvokesthe registerJob() method(Line 19),which
adds a new entry to the schedulerMap (Line54) contained within
theshared JobRegistry.instance staticfield(obtainedusing Job-
Registry.getInstance() ).ThisnewentryismappedtotheString
key"test_job" ,usedasinputto registerJob() bythepolluter.
Thepolluterinvokes dataChanged() (Line20),whichinturnchecks
whetherthejobname(setto "test_job" inthesetUp()method
thatrunsbefore,Line 11)isshutdownalready.Thejobnameiscon-
sideredshutdownifthe schedulerMap doesnotcontainanentry
for the job name (Line 60). Since the schedulerMap indeed con-
tainsanentryfor "test_job" ,themethod shutdownInstance()
is invoked on the schedulerFacade field (Line 39).
Whenthevictimrunsafterwards,italsoinvokes dataChanged()
(Line26). However, the victim expects that the method shutdown-
Instance() is not invoked on the mock object schedulerFacade
(Line27). Since the victim did not register any job for "test_job" ,
the execution shouldnot result in shutdownInstance() being in-
voked. However, because the polluter ran beforehand and regis-
tered"test_job" without removing it from the schedulerMap in
the shared JobRegistry.instance , the check for the presence of
"test_job" in the map returns true, and shutdownInstance() is
still invoked once, resulting in the victim failing.
Torepairthevictiminthisexample,wewouldneedtoremove
the"test_job" entry from the shared schedulerMap after the
polluter finishes and before the victim starts. Fortunately, there is
a method, shutdown() , that can be invoked to remove the entry
(Line57). In fact, just adding the statement
JobRegistry.getInstance().shutdown("test_job");
to run after the polluter can ensure the victim passes regardless
of its order relative to the polluter. (It is interesting to note that
schedulerFacade.shutdownInstance() normally does remove
the entry from the shared map, but because schedulerFacade is a
mock object, it actually does not do that.)
3 ODREPAIR
We propose ODRepair to automatically repair order-dependent
tests.ODRepairhastwomaincomponents.Thefirstcomponent,
Debugger,takesanidentifiedorder-dependenttestanditsidentified
polluter, and it automatically detects the polluted state that causes
theorder-dependenttesttofail.Thesecondcomponent,Generator,
uses the polluted state identified by the Debugger to generate a
patchthatwillresetthatpollutedstate.Thegoalisthatapplying
thepatchwillmaketheorder-dependenttestalsopasswhenrun
in its original failing test order.
3.1 Debugger
TheDebuggertakesasinputaknownorder-dependenttest tand
its corresponding polluter p. Figure 2shows the overallalgorithm
for Debugger. The polluter pcan be obtained using the Minimizer
component of iFixFlakies (Section 2). Note that ODRepair is meant
toonlyhandlevictimorder-dependenttests,sotheremustexista
1883
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:52:10 UTC from IEEE Xplore.  Restrictions apply. ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA Chengpeng Li, Chenguang Zhu, Wenxi Wang, and August Shi
1# Input: order -dependent test t,
2# polluter p
3# Output: polluted field
4defiFixPlus(t, p):
5# Capture state of t in failing test order using p
6xmls_f = state_capture([p, t])
7
8# Capture state of t in passing test order
9test_result = run_tests([t, t])
10iftest_result == PASS:
11 xmls_p = state_capture([t, t])
12else:
13 xmls = state_capture([t, t])
14 xmls_p = state_capture_eager([t], xmls.keys())
1516
# Find fields where xmls differ
17diff_fields = diffing(xmls_f, xmls_p)
1819
# Try to set each diff field in the failing order
20forfieldindiff_fields:
21 test_result = run_and_set_field([p, t],
22 field, xmls_p[field])
23 iftest_result == PASS:
24 return field
2526
return NOTFOUND
Figure 2: Algorithm for the Debugger.
&I
&FODVVORDGHU&I&I&I&I2EM
2EM2EM 2EM 2EM
Figure 3: Object graph rooted at static field C0.f.
polluter. The goal of the Debugger is then to identify the shared
state that the polluter modifies in such a way that the order-depen-
dent test fails in the failing test order. While there can be many
types of shared state, such as heap-state, file system, databases,etc., heap-state was found to be one of the most common shared
statethatleadstotest-orderdependencies[ 37].Furthermore,much
priorworkhasfocusedonorder-dependenttestsduetopolluted
heap-state[ 15,17,18,28].Assuch,wefocusonpollutedheap-state,
particularly pollution reachable from static fields in Java, whichprior work found to be the main means for JUnit tests to share
heap-state with each other [17, 28].First, we capture the heap-state right before the order-depen-
dent test tin a failing test order (Line 6). We use the minimal
failing test order that consists of just the polluter prunning before
t, i.e.,[p, t]. To capture the heap-state, we use the same logic
from PolDet [ 28]. PolDet is a technique that captures and saves
heap-stateatpointsduringtestexecutiontolatercomparewhether
the execution modified the heap-state. PolDet captures heap-state
in Java by first finding all the classes loaded at the capture point.
PolDetthenfindsallthestaticfieldscontainedwithintheseclasses.
Thesestaticfieldsformtherootsofanobjectgraphrepresenting
thecurrentheap-state.Figure 3illustratesanobjectgraphrootedat
staticfield C0.f,where nodesareobjectsand theedgesrepresent
instance fields that point to other objects; the edges are labeled
bytheirfieldname(includingtheclassname).Forexample,ifwe
follow fields C0.f->C1.f3, we would reach the object Obj4.
PolDetefficientlycreatesarepresentationofthisobjectgraph
by serializing the objects the static fields reference into an XML
format. We use the same approach for our state_capture() func-
tion, where we put the capture point right before the running of
the last test in the test order, namely the order-dependent test. We
store the serialized forms of the object states in the failing test
order into xmls_f, which is a map from the static field name to its
corresponding object‚Äôs XML representation.
We also capture the heap-state right before the order-depen-
dent test in a passing test order. While there can be many possible
passingtestorders,wewanttoavoidrunningtoomanyothertests
before the order-dependent test, because these other tests may not
be using anyclasses or static fieldsthat are shared withthe order-
dependenttest.Assuch,thereisnopointincapturingheap-state
rooted from these static fields, because they should not have an
effectontheorder-dependenttestoutcome.Anotheroptionisto
use the minimal passing test order, i.e., running just the order-dependent test by itself. However, we cannot use this test ordereither, due to Java‚Äôs lazy classloading [
36]. In lazy classloading,
classesarenotloadeduntiltheyareusedforthefirsttime.Assuch,
whentrunswithoutanytestsbeforeit,noclasseswouldbeloaded
right before it runs, meaning there would also be no static fields
from which to capture heap-state. To overcome this challenge, we
instead use a different passing test order consisting of running the
order-dependenttesttwiceinarow,i.e., [t, t].Afterrunning t
thefirsttime,alltheclassesituseswouldbeloaded.Wecanthen
capturethestateafterthefirst trunsbutbeforethesecond tstarts.
However,we needto check whetherthe order-dependenttest
still passes after running it twice (Line 10). There is the risk that
the order-dependent test tis also a polluter for itself, meaning the
order-dependent test fails when run the second time; Wei et al.
termed these tests as non-idempotent-outcome tests [45]. The state
after a non-idempotent-outcome test run would not be the correct
state,forithas‚Äúpolluted‚Äùitself.Forthesenon-idempotent-outcometests,westillcapturethestateatthesamepoint,butweonlyrecord
the static fields available at that capture point (the keys in the
returned map from field to XML representation, Line 13). We then
use those fields as reference and do a form of eager classloading,
similar to as proposed in PolDet to overcome challenges from lazy
classloading [ 28]. Namely, werecord the classes that areused and
forcefullyloadthematthecapturepointduringtheminimalpassingtestorder,
[t](Line14).Eagerclassloadingdoesnotadheretohow
1884
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:52:10 UTC from IEEE Xplore.  Restrictions apply. Repairing Order-Dependent Flaky Tests via Test Generation ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA
Javabydefaultloadsclasses,whichcancauseunexpectedbehavior,
e.g.,aclassmayhavestaticstatewhoseinitializationdependson
the order in which the classes are loaded. As such, we only rely on
thisapproachwhenwecannotsimplyrunthetesttwicewithout
it polluting itself. Fortunately, we did not encounter many non-
idempotent-outcome tests in our evaluation, with only 33 out of
327 order-dependent tests being non-idempotent-outcome tests.
With both the static fields and serialized heap-state from the
failing test order and passing test order, we proceed to diff the
XML serialized form of the objects rooted at each field shared in
commonbetweenthethetwotestorders(Line 17).However,not
allstaticfieldswithdifferentobjectstatesnecessarilyleadtothefailing order-dependent test. To isolate the true static field thatreferencesthe polluted heap-state,weiterateover eachdiffering
field and deserialize the XML representation corresponding to that
static field from the passing test order back into an object. We thenloadthisdeserializedobjectintoitscorrespondingstaticfieldwhen
runninginthefailingtestorder [p, t],loadingitinrightbefore
the order-dependent test runs (Line 21). If the test passes now in
thefailingtestorderaftersettingthestaticfieldstatetoitsoriginal
value from the passing test order, we identify that field to be the
rootofthepollution,whichwerefertoasthe pollutedstaticfield.If
we cannot use any of the static fields to make the order-dependent
testpass,wesimplyreturn NOTFOUND (Line26)andcannotproceed
further with repairing this order-dependent test.
3.1.1 Reusing State for Deserialization. Deserializing XML back
intoobjectspresentsadditionalchallenges.Theobjectgraphrooted
at a static field can eventually reach objects unique to the run-ning JVM at the capture point, e.g., reaching the classloader or
dynamically-generated proxy objects. While the entire state can be
serialized into an XML format, that same XML cannot be deserial-
izedbackintoaviableobjectinadifferentrunningJVM.Aslong
asanypartoftheXMLrepresentingheap-staterootedatastatic
field cannot be deserialized, we fail to deserialize that entire object
graph for the static field.
Toovercomethischallenge,weintroduceameanstoreuseheap-
state from the currently running JVM. The insight is that we aretrying to deserialize XML representing an object graph that isthe same structure as the object graph currently loaded in mem-ory. For example, in Figure 3, the object referenced by following
fields
C0.f->C1.f3->C2.classloader is actually an instance
of aClassLoader . While this object can be serialized into XML,
that same XML representation cannot be safely deserialized into
anotherrunningJVM.Whenweencountersuchanobjectduring
deserialization,weinsteadnavigatethroughtheobjectgraphinthecurrentlyrunningJVM(duringthefailingtestorder)andfollowthesamefieldstructure,i.e.,byfollowingthehighlightedredarrowsin
Figure3.Weeventuallyreachwhatobjectiscurrentlyreferenced
bythatchainoffields,i.e., Obj5.Wethenusethatcurrentobjectin
place of what objectthe deserialization process was planning on
creating, essentially allowing that object to be loaded back in place.
Note that while we can use this process to avoid issues where
wecannotsafelydeserializepartsofthecapturedheap-statefrom
a previous JVM run, there is the risk that the actual pollution in
theheap-stateisexactlyinthepartwearereusing.However,given
the typical types of objects we cannot deserialize, namely internalJava classes, it is unlikely that changes to these objects result in
pollutionthatmakesanorder-dependenttesttofail.Furthermore,
we wouldnot have beenable todeserialize them anywaywithout
this additional recovery attempt.
3.2 Generator
The Generator takes as input the order-dependent test and its pol-
lutedstaticfieldasidentifiedbythepreviousDebugger.ThegoaloftheGeneratoristogenerateapatchthat,whenappliedrightbefore
the order-dependent test,can make the order-dependent testpass
when run after the polluter in the failing test order.
The Generator itself consists of three sub-components: Reset-
Method Finder, Test Generator, and Patch Generator.
3.2.1 Reset-Method Finder. Giventhethepollutedstaticfield,Reset-
Method Finder scans the bytecode of the code under test (plus any
additional third-party libraries) to find potential methods that can
reset the state forthat polluted static field. We refer tosuch meth-
ods asreset-methods. Reset-Method Finder determines potential
reset-methods based on the following heuristics.
First,ifamethodusesthe PUTSTATIC bytecodeinstructionwhere
theoperandisthepollutedstaticfield,thenReset-MethodFinder
considersthe methodas apotential reset-method.The reasoningis
thatthemethodisdirectlysettingthevalueofthepollutedstatic
field.Assuch,themethodmayeitherdirectlyresetthefieldbackto
a default state, or sets that state based on some input arguments.
Second,fromourinitialinspectionoforder-dependenttestsin
our dataset, we found a substantial ratio of them (27 out of 68 tests
from 8 projects) involve pollution of fields of a Java Collection
data structure type, e.g., type Map. For example, the polluter would
add entries to a shared Mapwhile the order-dependent test expects
that map to be empty when it starts to run (similar to the example
illustrated in Figure 1). The way to reset these data structures is
to use its API methods that modify the data structure state, e.g.,
clear(),put(),putAll() ,putIfAbsent() , andremove() for a
Map.Wethereforelookformethodsthatinvokethesepredetermined
data-structure-modifyingmethodswhileoperatingonfields(which
can now be instance fields) defined within the type of the polluted
static field. The reasoning is that these methods can be invokedin ways such that they can eventually modify the polluted data
structures back to the correct state.
3.2.2 Test Generator. Given the set of potential reset-methods,
the Test Generator aims to generate tests that invoke the reset-methods in ways that can potentially reset the state referenced
bythepollutedstaticfieldwhenrunafterthepolluterandbefore
the order-dependent test. For this task, we leverage automatic test-
generationtools.Anautomatictest-generationtoolwouldgeneratemethod-call sequences, focused on a specific part of the code being
tested,with thegoaltocover thecodeunder testandfindbugs in
thecode.ForourimplementationofTestGenerator,wespecifically
use Randoop [ 10,39], a tool that generates unit tests effectively
and efficiently by randomly constructing method-call sequences.
Randoop needs as input the method it should focus on testing. We
therefore pass each reset-method found from the Reset-MethodFinder as an input method to Randoop. Randoop then generates
1885
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:52:10 UTC from IEEE Xplore.  Restrictions apply. ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA Chengpeng Li, Chenguang Zhu, Wenxi Wang, and August Shi
a test class per each reset-method, where individual tests within
invoke the reset-method in various ways.
However,weneedtoconfigureRandoopinadditionalwaysso
it can effectively generate useful method-call sequences.
Mining literals from the code under test. A reset-method may
needtobeinvokedwithinputarguments.Randoophasadefault
constants pool it uses to provide the input arguments, but often
thesedefaultsareinsufficientforthereset-methodtoactuallyreset
thepollutedstaticfield.Tohelpprovidemoremeaningfulinputs,
Test Generator mines literals, such as String constants, from the
bytecode of the code under test. The insight is that these literals
arelikelyalreadyusedbythepollutertomodifythesharedstate.
Consider the example code in Figure 1, where the polluter calls
registerJob() with the literal String "test_job" , which is used
as a key to a Mapin the backend. A reset-method that we found,
shutdown() ,takesaStringinput,whichinthiscasehastomatch
withthesameliteralthepolluterusedtomodifythesharedstate,
re-using that literal as a key for resetting the Map.
We limit the scope of this literal mining to the code in the order-
dependent test class and the class that contains the polluted static
fieldastorestrictthesearchspaceofpossibleinputsRandoopwould
use when creating method-call sequences. We pass these literals to
theconstantspoolofRandoop,whichareutilizedtogenerateinput
values of method-call sequences (through its literals file [11]).
Additional helper methods. Besides reset-methods needing spe-
cific literal inputs to reset the polluted static field, they may also
need more complex inputs. Forexample,if the reset-method is an
instancemethod,thereset-methodwouldneedacalleeinstanceon
whichitcanbeinvoked.Assuch,Randoopneedstoinvokeother
methods that return the callee instances on which to invoke the
reset-method.However,lettingRandooptryallpossiblemethodsin
the project isnot a good idea, as itbecomesless likely for Randoop
to generate the right method-call sequence to reset the state.
Foreachreset-methodprovidedbytheReset-MethodFinder,Test
GeneratorconfiguresRandooptouseonlythatreset-methodalong
withotherhelpermethodsthatreturnrelevantvaluesthatRandoop
should use along with the reset-method. These helper methods
includethosethatreturnthecalleetypeofthereset-methodandanymethodsthatuse
GETSTATIC ofthepollutedstaticfield.Theselatter
methods are potentially getter methods that return the polluted
static field, which the reset-method may need access to as to reset
statereachablefromthatsamepollutedstaticfield.Theoutputis
a test class for each reset-method, containing test methods that
invoke the reset-method along with the helper methods.
Coarse-grained test generation. Randoop can also receive as
input entire classes for testing, where it would then generate tests
thatinvokecombinationsofmethodsfromtheprovidedclasses.We
thereforealsotryusingRandooptogeneratetestsbasedonlikely
relevantclasses.Theintuitionisthatwemaystillmissimportant
methods through the more fine-grained search on reset-methodand helper methods, so letting Randoop use all methods in rele-
vantclassesmaybeenoughtocoverallimportantmethods.This
alternateapproachprovidestoRandoopalltheclassesreferenced
within the class that contains the polluted static field and all the
classes that are transitively referenced by the class type of the pol-
lutedstaticfield.Theapproachthenfocusesonthetop ùêæclasses¬≥WHVWBMRE¬¥
¬≥¬¥
¬´
5DQGRRS
L)L[)ODNLHVVKXWGRZQ -RE5HJLVWU\JHW,QVWDQFH
JHQHUDWHGWHVWKHOSHU
JHQHUDWHGSDWFKHVOLWHUDOV
*HQ7HVW
^
-RE5HJLVWU\M -RE5HJLVWU\JHW,QVWDQFHMVKXWGRZQWHVWBMRE`DVVHUW,V6KXWGRZQ$OUHDG\ YLFWLP
DVVHUW5HPRYH/RFDO,QVWDQFH3DWKSROOXWHUUHVHWPHWKRG
Figure 4: Overview of Generator.
among this set of classes, where the classes are ranked by their
distance from the polluted static field type, i.e., the classes directly
referenced by the polluted static field type are ranked first, and
otherclassesthattheseclassesinturnreferencearerankedsecond,
and so on. Heuristically, we choose 10 as the value of ùêæ, restricting
the search space as to avoid generating tests that use too manydifferent methods, especially as the ones ‚Äúfurther away‚Äù are less
likely to have an effect on the pollution. Randoop takes as input all
these classes for which to generate tests.
Ultimately, Test Generator outputs a separate test class for each
reset-method, along with an additional test class generated by Ran-
doop using the classes relevant to the polluted static field.
3.2.3 Patch Generator. Finally, Patch Generator aims to check
whether any of the generated tests from Test Generator contain
codethat actuallyresets theshared state,essentially consistingof
a patch for the order-dependent test. Patch Generator leverages
iFixFlakies [ 43] to do the check and generate the patch. Patch Gen-
eratorsetsupiFixFlakiestorunjusttheorder-dependenttest,its
polluter, and the set of generated tests to determine if any of those
generatedtestsareactuallycleanersfortheorder-dependenttest
and polluter pair. For each generated test class, we run iFixFlakies
withthetestmethodswithinthatgeneratedtestclassalongwith
the polluter and order-dependent test to see whether any of those
generated test methods can reset the shared state and make theorder-dependent test pass when run after the polluter. If one of
them does turn out to reset the shared state, then iFixFlakies mini-
mizes the statements within the test, producing a patch that, when
appliedatthebeginningoftheorder-dependenttest,allowsitto
pass even when run after the polluter.
Figure4illustratestheoverallGeneratorprocess(usingprovided
reset-methods),onceagainfollowingtheexamplefromSection 2,
Figure1.Theinputsarethereset-method(inthiscase shutdown() ),
literals mined from the code (including String "test_job" ), and
1886
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:52:10 UTC from IEEE Xplore.  Restrictions apply. Repairing Order-Dependent Flaky Tests via Test Generation ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA
alistofhelpermethods(including JobRegistry.getInstance()
that returns the relevant polluted static field). These inputs are
passed to Randoop, which in turn generates a test class ( GenTest).
This test class is passed as input to iFixFlakies to try and generate
a patch out of the test methods from that test class, finally pro-
ducing a patch that repairs the order-dependent test, using both
JobRegistry.getInstance() andshutdown().
4 EVALUATION SETUP
We evaluate ODRepair on a large set of order-dependent tests. We
start with the flaky tests contained within IDoFT [ 6], a publicly
availabledatasetofflakytestsfoundinopen-sourceGitHubJava
projects,detectedusingautomatedflaky-testdetectiontoolssuch
asiDFlakies[ 4]orNonDex[ 3].Weareonlyinterestedinthe598
flaky tests marked as order-dependent tests in this dataset. We ran
iDFlakies[ 4],atooltodetectorder-dependenttestsbyrerunning
testsindifferenttestorders,toobtainthepassingandfailingtest
orders per order-dependent test (we configured iDFlakies to run
100 random test orders, as Lam et al. did in prior work [ 32]). We
found one test‚Äôs project to no longer exist, and we found 211 tests
to be non-order-dependent, i.e., their flaky pass/fail outcome is not
completelyduetotestorder,orwecouldnotobtainbothpassing
and failing test orders; we exclude these tests from our evaluation.
We ran each order-dependent test in isolation to determine brit-
tles and victims (Section 2). We found that 59 of these tests are
brittlesand327arevictims,inlinewithShietal.‚Äôspriorfindings
thatthemajorityoforder-dependenttestsarevictims[ 43].Given
thatiFixFlakiescanrepairbrittlesbutnotalwaysvictims,weuse
for our evaluation only the 327 victims, spread across 42 projects.
FortheDebuggercomponentofODRepair,weuseXStream[ 13]
toserializeobjectsintoXMLformanddeserializethembackinto
objects.WefurthermodifyXStreamtoimplementourtechnique
of reusing existing state when we are unable to deserialize objects
from a previous JVM run (Section 3.1.1). To compare the XML
representationsofobjects,weuseXMLUnit[ 12].Weincorporate
thestatecapturelogicintoiDFlakiesastoensurewecancontrol
thetestorderandtocapturestateattherightpoint,rightbeforethe order-dependent test. We also set a timeout of 24 hours per
order-dependent test for identifying the polluted static field.
For the Generator component of ODRepair, we use Apache
BCEL [5] to analyze the Java bytecode, both for finding reset-
methods and to mine the literals from the project code. When
configuringtheautomatictest-generationtoolRandoop,welimit
the maximum number of test methods per test class to 500, and we
limitthemaximumlinesofcodepertestmethodtobe100.Wealso
allocate at most 60 seconds for Randoop to generate tests. We use
amuchsmallertimeoutforRandoop,becausewefoundRandoop
would actually terminate much earlier, on average 28 seconds per
use, meaning 60 seconds is typically more than enough.
5 EVALUATION
ToevaluateODRepair,weaddressthefollowingresearchquestions:
‚Ä¢RQ1:HoweffectiveisODRepairatautomaticallyidentifying
the polluted static field for order-dependent tests?
‚Ä¢RQ2:HoweffectiveisODRepairatgeneratingpatchesfor
repairing order-dependent tests?5.1 Identifying Polluted Static Fields
Table1shows the results of running the Debugger component on
the327order-dependenttestsfromourdataset.Thetableshowsper
project the number of order-dependent tests, average number of
staticfieldsatthecapturepoint,theaveragenumberofstaticfields
referencing state that differed between the passing and failing test
ordersatthecapturepoint,andthenumberoforder-dependenttests
for which we could successfully identify the polluted static field.
The table also shows the average time for the Debugger per order-
dependent test (successful or not). While order-dependent tests
access a large number of static fields (average 2149.9), not many of
them reference differing state between the passing and failing test
orders(average30.8).Overall,ODRepaircanautomaticallyidentify
the polluted static field for 181 order-dependent tests. The overall
average timeto runis 1820.9seconds (median33.4 seconds).This
large time is mostly from projects with a large number of static
fields per order-dependent test, e.g., spring-projects/spring-boot or
vmware/admiral.Furthermore,thereareseveraloutliertestswhose
overalltimeismuchhigherthantheothers(morethan1.5timesthe
interquartilerangehigherthanthethirdquartile). Ifweexclude
these outlier tests, the average time drops down to 51.5 seconds.
Thereare146order-dependenttestswhereODRepairdoesnot
identifythepollutedstaticfield.Fromourinspection,thereasons
thatODRepairdoesnotidentifythepollutedstaticfieldforthese
tests can be broken down into three main categories.
Out-of-Resources. ODRepairhadout-of-memoryerrorsfor46
tests and timed out for 2 tests. We note that all these tests are from
thesameproject,apache/hadoop, oneofthelargestprojectsfrom
our dataset. While apache/hadoop does not have the most number
ofstaticfieldsperorder-dependenttest,thereachablestatefrom
each of the static fields is very large, and our approach to serialize
all that state in XML form results in the numerous out-of-memory
errors. The timeouts also occur due to having to process this large
state(notethatODRepairdoesnottimeoutforanyotherproject,
suggesting our preset timeout value is reasonable).
Serialization/DeserialzationErrors.For46tests,ODRepairdoes
not identify the polluted static field but also encounters errorsfrom using XStream and cannot proceed with serializing/deseri-alizing the state. The polluted static field could be among these
fields where XStream cannot serialize/deserialize properly, but we
cannot identify it automatically due to those errors. We encounter
serialization errors for 13 tests and deserialization errors for 33tests. In the case of serialization errors, we find the serialization
would interact poorly with the underlying test running process,
preventing the process to exit properly. Note that a serializationerrorwouldactuallypreventODRepairfromproceedingtodese-rialization (there is no captured state to deserialize). Concerning
deserialization errors, some examples include trying to deserialize
instances of anonymous lambda classes or proxy classes, where
these types are dynamically generated during the execution of the
passingtestorder.Assuch,wecannotdeserializeinstancesofthese
classes in a new JVM execution, and we also cannot re-use anyobject state from the current running JVM for these parts of the
heap-state (Section 3.1.1).
Miscellaneous. The remaining 52 tests are such that there are
no errors from serializing/deserializing, but still ODRepair cannot
1887
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:52:10 UTC from IEEE Xplore.  Restrictions apply. ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA Chengpeng Li, Chenguang Zhu, Wenxi Wang, and August Shi
Table 1: Breakdown of debugging polluted state on order-dependent tests.
Project # OD Tests Avg Avg Avg # Successfully
# Static Fields # Static Fields w/ Diff Time (s) Debugged Tests
Activiti/Activiti 11 5616.8 0.0 95.3 0
alibaba/fastjson 1 487.0 4.0 6.3 1
alibaba/Sentinel 3 879.0 9.0 356.9 3
apache/cayenne 1 2969.0 49.0 592.9 0
apache/geronimo-batchee 1 123.0 16.0 22.4 1
apache/hadoop 74 3533.8 39.3 891.7 26
apache/hbase 1 802.0 21.0 115.4 0
apache/incubator-dubbo 19 1215.8 45.7 499.0 12
apache/incubator-ratis 1 650.0 15.0 45.1 0
apache/jackrabbit-oak 1 727.0 14.0 22.3 1
apache/karaf 1 1048.0 17.0 401.5 1
apache/shardingsphere-elasticjob 2 2054.0 13.0 325.9 1
apache/skywalking 1 38.0 3.0 19.6 1
c2mon/c2mon 1 9078.0 0.0 107.8 0
CloudSlang/cloud-slang 3 620.0 21.0 27.6 0
ConsenSys/tessera 6 1760.2 15.7 90.3 3
ctco/cukes 1 1599.0 779.0 1406.9 0
danfickle/openhtmltopdf 1 1220.0 30.0 129.5 0
dropwizard/dropwizard 1 1673.0 5.0 23.4 0
elasticjob/elastic-job-lite 4 784.0 12.8 30.4 4
google/java-monitoring-client-library 1 493.0 9.0 115.1 1
jenkinsci/remoting 9 42.9 11.7 14.0 0
jitsi/jicofo 1 3356.0 0.0 32.1 0
jnr/jnr-posix 4 1438.0 30.0 32.8 0
kevinsawicki/http-request 28 439.0 16.6 24.9 28
ktuukkan/marine-api 12 485.0 3.0 6.9 12
networknt/light-4j 14 1647.5 12.5 86.1 10
openpojo/openpojo 5 351.8 20.8 38.0 5
rest-assured/rest-assured 1 3613.0 105.0 1026.0 1
spring-projects/spring-boot 11 17456.9 237.5 43046.1 8
spring-projects/spring-data-envers 2 4251.0 69.5 302.8 0
spring-projects/spring-ws 2 96.0 4.0 5.1 2
tbsalling/aismessages 2 81.0 5.0 7.0 0
Thomas-S-B/visualee 46 33.5 3.0 3.9 46
tools4j/unix4j 1 1477.0 2.0 12.3 0
undertow-io/undertow 1 2133.0 23.0 50.2 1
vaadin/flow 1 821.0 7.0 33.6 1
vmware/admiral 1 6980.0 120.0 32078.8 1
wikidata/wikidata-toolkit 2 29.0 3.0 2.9 2
wildfly/wildfly 37 636.4 17.0 22.4 0
winder/Universal-G-Code-Sender 6 2454.5 24.7 372.9 5
yangfuhai/jboot 6 869.7 17.3 62.6 4
Sum | Mean x3 | Sum 327 2149.9 30.8 1820.9 181
automatically identify the static field where using its value from
thepassingtestordercanmaketheorder-dependenttestpassinthe failing test order. From our inspection, first, two tests access
files outside the heap-state, and changes to these shared files result
in failed order-dependent tests. We currently do not track state
outside the heap. Second, 48 tests initialize variables that reference
servicesthattheystartup.Forexample,order-dependenttestsin
projectwildfly/wildflyallrelyontheunderlyingJNDIservice[ 7].
Tests interact with these services and their own shared state not
throughstaticfieldsbutratherthroughspecificAPIcalls.Currently,weonlytrackchangestoheap-stateaccessiblethroughstaticfields.
Third, one test from danfickle/openhtmltopdf changes the warning
level of global logging by modifying environment variables that
wedonottrack.Finally,foronetestindropwizard/dropwizard,the
polluter changes a static field to reference a new output stream
instead of the default System.out . The later order-dependent test
specifically checks if that static field references System.out , not
just whether the two streams are equivalent in state or not. Ourapproachonlychecksifstatesareequivalentanddoesnottryto
match the same field references as in the passing test order.
1888
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:52:10 UTC from IEEE Xplore.  Restrictions apply. Repairing Order-Dependent Flaky Tests via Test Generation ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA
RQ1:Overall,ODRepaircanautomaticallyidentifythepolluted
staticfieldfor181outofthe327order-dependenttests.ODRepair
takes on average 1820.9 seconds to analyze all 327 order-depen-
dent tests. However, excluding the order-dependent tests with
outlier times makes the average drop to 51.5 seconds.
5.2 Generating Patches
Weusethe181order-dependenttestsforwhichweidentifiedthe
polluted static field as input to the Generator. Table 2shows the
results of running the Generator on these tests. For each project,
we show the number of order-dependent tests for which we could
findthepollutedstaticfield(takenfromTable 1)andtheaverage
numberoftestclassesandtestmethodsgeneratedperorder-depen-
denttestinthatproject.Notethatwegenerateonetestclassper
reset-methodand thenone additionaltest classbyanalyzing therelated classes (Section 3.2.2). There may only be one test class
generatediftheGeneratorcannotidentifyanyreset-methodsfor
the polluted static field. We see on average 3.0 test classes and679.0 test methods generated per order-dependent test. We alsoshow the number of order-dependent tests for which we could
generateapatch.Overall,wegeneratepatchesfor141order-depen-
dent tests. We also show the time to prepare inputs for Randoop
(identifyreset-methods,helpermethods,andliterals)undercolumn
‚ÄúPreproc‚Äù (average14.3 seconds)andfor iFixFlakies toproduce a
patch under column ‚ÄúPatch Gen‚Äù (average 99.6 seconds).
WecompareagainstpriorworkiFixFlakies[ 43]forgenerating
patches,alsoshowninTable 2underthe‚Äú#Fixed‚Äùcolumn.Overall,
iFixFlakiescouldgenerateapatchfor135order-dependenttests.In
comparison with ODRepair, both ODRepair and iFixFlakies could
generate a patch for 117 (64.6%) in-common order-dependent tests.
ODRepairexclusivelyrepairs24tests(13.3%),andiFixFlakiesexclu-
sively repairs 18 tests (9.9%). We inspect more into the tests where
neitherODRepairnoriFixFlakiescangenerateapatchandwhere
the two differ in being able to generate a patch for the test.
Neither technique can generate a patch. There are 22 order-
dependent tests from six projects that cannot be repaired by eithertechnique. There are two main reasons for these cases. (1) The pol-
luted static field is not directly accessible outside its defining class
(e.g., a private field) and there are no public (or protected) meth-
ods that modify the field. For example, for order-dependent test
MainTest.executions in project apache/geronimo-batchee, the
pollutedstaticfield SingletonLocator.MANAGER isprivate,andthe
onlyPUTSTATIC instructionforthefieldisina staticblock,i.e.,
the<clinit> of its defining class. We cannot invoke <clinit> as
itshouldonlybeinvokedoncewhentheclassisfirstloaded.There-fore,anytechniquethatdoesnotchangethecodeundertestcannot
repair this order-dependent test. (2) Although there exists a public
method that can modify the field, calling that method does not
reset the state. For example, for the order-dependent test Request-
BrokerKubernetesServiceTest.testRequestStateHasK8sInfo
inprojectvmware/admiral,thepollutedstaticfieldisthe ListMock-
KubernetesApplicationAdapterService.CREATED_DEPLOYMENT
_STATES. There is a method addDeploymentState in its defining
class that can add more elements to the List, but it cannot resetthe state back to how it would be in the passing test order. For this
test,ODRepairgeneratedfourdifferenttestmethodsthatinvoke
this method, but none of them repair the order-dependent test.
OnlyODRepaircangenerateapatch.Thereare24order-depen-
dent tests that can be repaired using ODRepair but not iFixFlakies.
The main reason for such cases is that there is no existing test
methodthatiFixFlakiescanuseasacleaner.Howev er,ODRepair
is not limited to just the developers‚Äô test suite, as it can search the
codeundertestaswellforthepotentialreset-methods.Fromour
empirical results, we see that ODRepair can find reset-methodsto repair 141/181 tests with known polluted static fields. We in-spected the remaining 40 order-dependent tests that ODRepair
could not repair, and 14 of them can also be repaired using a reset-
method.However,ODRepaircouldnotgeneratethepropermethod-
call sequence that uses the reset-method correctly. For example,for the order-dependent test
TestTimelineReaderWebServices
.testAbout inprojectapache/hadoop,thepollutedfield Timeline-
ReaderMetrics.instance is an instance of class MetricSystem .
Whilethepublicmethod DefaultMetricsSystem.shutdown() can
resetthestaticfield,noexistingtestinvokesthismethod,soiFixFlakies
cannot find any cleaners and cannot generate any patch. However,
ODRepair successfully generates 13 different tests that invoke this
method, and all of them can reset the polluted state. This example
demonstrates theadvantage ofODRepair over iFixFlakies:it does
not rely on the developers‚Äô test suite and can also be applied to
projects with lower-quality test suites or a small number of tests.
OnlyiFixFlakiescangenerateapatch.Thereare18order-depen-
dent tests that can be repaired by iFixFlakies but not ODRepair.
Therearetwomainreasonsfor suchcases.(1)Thepatchrequires
complexmethod-callsequencesthatinvolvesmultipleclasses,even
including classes from third-party libraries. For example, the patch
thatiFixFlakiesgeneratesfororder-dependenttest NpmTemplate-
ParserTest.should_FindCorrectDataInStats in project vaad-
in/flow involves 17 different method calls, including methods from
the Mockito mocking library [ 8]. Note that this method-call se-
quenceisalreadyminimizedbyiFixFlakies,sothereisnoshorter
method-call sequence that constitute a patch. iFixFlakies can re-
pair this order-dependent test because developers happen to have
written a test that contains such a method-call sequence. Gener-
ating such a complex method-call sequence is difficult for a ran-dom test generator like Randoop. Therefore, when running OD-Repair, Randoop did not generate this method-call sequence ora similar method-call sequence. (2) The patch requires complex,hard-to-generate inputs to a method. For example, for the order-
dependenttest DirectoryManagerFactoryTest.createDefault-
DirectoryManagerPath intheprojectwikidata/wikidata-toolkit,
thecorrectpatchincludesacallto DirectoryManagerFactory.set-
DirectoryManagerClass with the argument DirectoryManager-
Impl.class . In this case, the argument to the method is a class
literal.Duringthetestgeneration,Randoopcouldtryalltheclass
literalsofalltheclassesthatitcanaccess(i.e.,alltheclassesontheclasspath),sothesearchspaceisextremelylarge,makingitdifficult
to stumble upon the relevant class literal.
We also sent one pull request per each of the two projects
(apache/hadoop and apache/incubator-dubbo) where ODRepair
could repair the order-dependent tests but iFixFlakies could not
1889
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:52:10 UTC from IEEE Xplore.  Restrictions apply. ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA Chengpeng Li, Chenguang Zhu, Wenxi Wang, and August Shi
Table 2: Results of generating tests that can reset polluted static fields.
Project # OD Tests # Gen Tests Time (s) # Fixed
# Test Classes # Test Methods Preproc Patch Gen ODRepair iFixFlakies
alibaba/fastjson 1 1.0 325.0 41.7 0.0 01
alibaba/Sentinel 3 4.0 701.0 67.0 10.7 11
apache/geronimo-batchee 1 2.0 373.0 23.8 0.0 00
apache/hadoop 26 2.0 328.0 53.0 49.8 23 1
apache/incubator-dubbo 12 3.0 211.0 21.3 49.4 61 1
apache/jackrabbit-oak 1 1.0 263.0 9.5 0.0 00
apache/karaf 1 1.0 360.0 2.3 0.0 00
apache/shardingsphere-elasticjob 1 2.0 2.0 4.6 0.0 01
apache/skywalking 1 1.0 196.0 2.9 0.0 00
ConsenSys/tessera 3 1.0 2.0 0.6 0.0 03
elasticjob/elastic-job-lite 4 8.0 1320.0 6.2 154.8 44
google/java-monitoring-client-library 1 4.0 240.0 1.1 245.9 11
kevinsawicki/http-request 28 2.0 465.0 0.9 68.8 28 28
ktuukkan/marine-api 12 6.0 1330.0 3.2 164.6 12 12
networknt/light-4j 10 6.0 1206.0 2.9 89.8 99
openpojo/openpojo 5 1.0 314.0 1.6 33.5 55
rest-assured/rest-assured 1 8.0 372.0 8.6 0.0 01
spring-projects/spring-boot 8 1.0 298.0 13.3 0.0 00
spring-projects/spring-ws 2 1.0 345.0 2.8 0.0 02
Thomas-S-B/visualee 46 4.0 892.0 1.2 219.4 46 46
undertow-io/undertow 1 4.0 8.0289.7 38.3 11
vaadin/flow 1 3.0 276.0 8.0 0.0 01
vmware/admiral 1 5.0 351.0 21.0 0.0 00
wikidata/wikidata-toolkit 2 4.0 320.0 0.6 0.0 02
winder/Universal-G-Code-Sender 5 5.0 2500.0 3.4 28.3 55
yangfuhai/jboot 4 4.0 467.0 7.9 0.0 00
Sum | Mean x2 | Mean x2 | Sum x2 181 3.0 679.0 14.3 99.6 141 135
(we avoid sending more than one pull request per project un-
til first hearing back from its developers, as to avoid bothering
themuntilweknowtheyareinterested).Sofar,thedevelopersof
apache/incubator-dubbo accepted our pull request [9].
RQ2:Overall, ODRepair generates patches for 141 order-depen-
dent tests out of 181 for which it could identify the polluted
static field. Compared against prior work iFixFlakies, both tech-
niquescangenerateapatchfor117(64.6%)in-commonorder-
dependent tests. ODRepair exclusively repairs 24 tests (13.3%),and iFixFlakies exclusively repairs 18 tests (9.9%). We believeODRepair and iFixFlakies can be used complementary to oneanother. The envisioned use scenario is that a developer runs
iFixFlakies first, and if it cannot generate patch, they can apply
ODRepair to generate amethod-call sequence that can beused
to generate a new patch.
6 THREATS TO VALIDITY
ODRepairmaynotapplytoallorder-dependenttestsforallprojects.
Weevaluateonalarge,publiclyavailabledatasetoforder-depen-
dent tests collected from open-source GitHub projects, detected
usingautomateddetectiontooliDFlakies[ 4].WealsouseiDFlakies
to confirm test-order dependencies and build upon iDFlakies.Forourexperiment,weallocated60secondsforRandoop.The
same budget may not be generalizable to all Java projects, but it
issufficientinourcase.Given60seconds,Randooptookonly28
secondsonaverage(15secondsmedian),terminatingearlyformost
(94/141)subjects.Inaddition,wetriedincreasingthetimebudget
fortheteststhatRandoopdidnotgenerateavalidcleanertest,and
Randoopwouldonaverageterminatewithin5minutes(without
generating a valid cleaner test).
Ourimplementationmaycontainbugs.Tomitigatethisthreat,
we build upon existing and mature toolsets, including XStream,
XMLUnit,andRandoop.Furthermore,wereviewedcodeandexe-
cution logs to confirm that data processing was done correctly.
7 RELATED WORK
Luoetal.performedthefirstempiricalstudyonflakytestsbystudy-ingbugreportsfromopen-sourceprojects[
37].Ecketal.conducted
anotherempiricalstudyfocusingondevelopers‚Äôperspectivesonflaky tests [
23]. There has also been extensive work on automat-
ically detecting different kinds of flaky tests [ 21,27,32,42,48],
mitigatingtheeffectsofflakytestsontestingtasks[ 15,33,41],or
even to automatically repairing flaky tests [22, 43,47].
Luo et al. foundthat order-dependent tests are one of the most
commonkindsofflakytestsintheirempiricalstudy[ 37],andmuch
workhasfollowedthatfocusesonsuchflakytests[ 27,28,32‚Äì35,43‚Äì
45,48]. Our work is most similar in nature to iFixFlakies [ 43], with
1890
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:52:10 UTC from IEEE Xplore.  Restrictions apply. Repairing Order-Dependent Flaky Tests via Test Generation ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA
the common goal to automatically repair order-dependent tests.
iFixFlakies relies on the insight that developers may have writ-tentests,termedcleaners,thatresetpollutedstateforthefailingorder-dependent test. iFixFlakies searches for these cleaners and
minimizesthecodewithinanyfoundcleanertogenerateapatch.
However,cleanersarenotguaranteedtoexist,soiFixFlakiesmay
notbeabletorepairallorder-dependenttests.ODRepairfirstidenti-fiesthepollutedstateandthenguidesanautomatictest-generation
tooltospecificallygeneratecleanersthatlikelyresetthepolluted
state. We then leverage iFixFlakies on these generated cleaners.
Gyorietal.previouslyproposedPolDet[ 28]asameanstoproac-
tively identify potential polluters, even without a order-dependent
testthatwouldfailduetoitspollution.PolDetcapturestheheap-
statereachablefromstaticfieldsbeforeandaftereachindividual
test run and compares the captured states. If the states differ, then
PolDet reports the test as a potential polluter that leaves behindsome polluted state. We use the similar state-capturing logic by
serializingthestateintoanXMLrepresentationfirstandthencom-paringtheXMLrepresentations.However,wedonotaimtosimply
detect whether pollution happened, because we are already aware
ofanexistingpolluterandorder-dependenttest.Weinsteadcom-
parethestatescapturedrightbeforetheorder-dependenttestisrun
inboththepassingandfailingtestordersastoidentifypotential
polluted static fields. We later deserialize the XML representations
for these static fields back into objects to be loaded in during a
failing test order right before the order-dependent test is run as to
check ifchanging thatpart ofthe heap-state towhat itwas inthe
passing test order makes the order-dependent test pass.
Weietal.recentlystudiednon-idempotent-outcometeststhat
fail when run twice in the same JVM [ 45]. Their goal is similar
tothatofGyorietal.withPolDet,toproactivelydetectpolluters
beforeapotentialorder-dependenttestfailure.Infact,thesenon-
idempotent-outcome tests clearly demonstrate a potential problem
with polluted state that results in a test failure (since the test itself
fails!). We also encounter non-idempotent-outcome tests when we
attempt to run the same order-dependent test twice to capture the
correctstatebeforethetestruns.Weencounterrelativelyfewcases
(33/327), and we mitigate the issue by only collecting the loaded
classes and static fields and then eagerly loading the classes.
Automaticunittestgeneration[ 19,24,25,39]aimstogenerate
test inputs and method-call sequences that can execute code under
testtofindbugsinexistingcode.Randoop[ 39]performsrandom
unittestgeneration.Itrandomlycallsmethodsfromthecodeunder
test, where the method-call sequences can result in objects thatit can further use as inputs for other methods that it randomly
calls.EvoSuite[ 24‚Äì26]leveragesevolutionaryalgorithmstoevolve
and search for method-call sequences that optimize for a fitness
function, such as branch coverage. In this work, we use automatic
test generation for its ability to generate method-call sequences as
opposed to its goal of achieving high coverage or finding bugs. We
use Randoop, and we focus it on generating method-call sequences
forpotentialreset-methodsthatmayresetthepollutedstate.We
useRandoopbecausepriorworkshoweditsrandomalgorithmis
both fast and effective at generating method-call sequences, and
we do not have any effective fitness function to guide the search.
Jaygarletal.[ 29]proposedanobjectcapture-basedautomated
testingtechnique,whichusesdynamicallycapturedobjectinstancesfromprogramexecutionstoimprovecodecoverageofexistingtest-generationtools.Zhangetal.[
49]useddynamicanalysistoextract
informationforguidinglegalmethod-callsequencegenerationand
used static analysis to improve the diversity of the generated tests.
Babiƒá et al. [ 16] used dynamic analysis to revolve around a visibly
pushdown automaton (VPA) for representing the programs global
control flow structure and used static analysis to assist symbolicexecution to explore vulnerabilities based on the shortest paths
and loop pattern heuristics. Ma et al. [ 38] proposed GRT, a guided
random testing technique that uses static analysis to extract in-
formation on program types, data, and dependencies to guide test
generation.Kechagiaetal.[ 30]proposedCatcher,atoolthatutilizes
static exception propagation analysis to guide search-based test
generation, effectively pinpointing crash-prone API misuses. Der-
akhshanfar et al. [ 20] proposed behavioural model seeding, which
synthesizes a behavioural model using the class usage information
from the system under test and existing test cases; the model is
used to guide search-based test generation. In our work, ODRepairprovides guidance to test-generation tool Randoop to focus on pre-
viously identified reset-method that are likely to modify and reset
pollutedstate. Ourstaticanalysis tomine literalswasinspired by
previouswork[ 14,38,40]withtheinsightthatmethodsmayuse
these literals, especially those in test code, to reset polluted state.
8 CONCLUSION
Flakytestsmisleaddevelopersconcerningtheresultsoftheirregres-sion testing, and order-dependent tests are a common kind of flaky
tests. Prior work iFixFlakies can automatically repair order-depen-
dent tests, but it is limited by requiring developers to have already
written tests that reset the polluted state for an order-dependent
test. We propose ODRepair to automatically repair order-depen-dent tests by first identifying the exact state that becomes pol-
luted,leadingtoafailingorder-dependenttest,andthengeneratingmethod-callsequencesthatcallreset-methodstoresetthatpolluted
state by leveraging a test-generation tool. Our evaluation on 327order-dependent tests from a public dataset of order-dependenttests shows that we can automatically identify the polluted state
for181order-dependenttestsandgeneratepatchesfor141ofthem.ComparedagainstiFixFlakies,wecangenerateapatchfor24order-
dependent tests that iFixFlakies cannot generate a patch for. Webelieve the two techniques can be complementary; if iFixFlakies
doesnotapply,adevelopercanthenuseODRepair.Inthefuture,
weplantoimproveODRepairfurtherthroughmoreefficientsearch
of heap-state for pollution as well as generating the reset-methods
fromscratchinsteadofsearchingforexistingonesinthecodebase.
9 DATA AVAILABILITY
Our evaluation data and scripts are available at https://github.com/
UT-SE-Research/ODRepair.
ACKNOWLEDGEMENTS
We would like to acknowledge NSF Grant No. CCF-1718903 for
supporting Chenguang Zhu and Wenxi Wang.
1891
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:52:10 UTC from IEEE Xplore.  Restrictions apply. ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA Chengpeng Li, Chenguang Zhu, Wenxi Wang, and August Shi
REFERENCES
[1]2012. JUnitandJava7. http://intellijava.blogspot.com/2012/05/junit-and-java-
7.html.
[2]2013. Maintaining the order of JUnit3 tests with JDK 1.7. https://coderanch.com/
t/600985/engineering/Maintaining-order-JUnit-tests-JDK.
[3] 2016. NonDex. https://github.com/TestingResearchIllinois/NonDex.
[4] 2019. iFixFlakies Framework. https://github.com/idflakies/iDFlakies.
[5]2020. ApacheCommonsBCEL. https://commons.apache.org/proper/commons-
bcel/.
[6] 2021. IDoFT. http://mir.cs.illinois.edu/flakytests.
[7]2021. JNDI Overview. https://docs.oracle.com/javase/jndi/tutorial/getStarted/
overview/index.html.
[8] 2021. Mockito framework site. https://site.mockito.org.
[9]2021. Pull Request ‚ÄúIncluding setup method to clean state between tests". https:
//github.com/apache/dubbo/pull/9265.
[10]2021. Randoop: Automatic unit test generation for Java. https://randoop.github.
io/randoop/.
[11]2021. Randoopliteralsfile. https://github.com/randoop/randoop/blob/master/
src/systemTest/resources/literalsfile.txt.
[12] 2021. XMLUnit. https://www.xmlunit.org/.
[13] 2021. XStream. https://x-stream.github.io/.
[14]Mohammad Alshraideh and Leonardo Bottaci. 2006. Search-based software test
datagenerationforstringdatausingprogram-specificsearchoperators. Software
Testing, Verification and Reliability 16, 3 (2006).
[15]AndreaArcuri,GordonFraser,andJuanPabloGaleotti.2014. Automatedunit
test generation for classes with environment dependencies. In International
Conference on Automated Software Engineering.
[16]Domagoj Babiƒá, Lorenzo Martignoni, Stephen McCamant, and Dawn Song. 2011.
Statically-directed dynamic automated test generation. In International Sympo-
sium on Software Testing and Analysis.
[17]Jonathan Bell and Gail Kaiser. 2014. Unit test virtualization with VMVM. In
International Conference on Software Engineering.
[18]Jonathan Bell, Gail Kaiser, Eric Melski, and Mohan Dattatreya. 2015. Efficient
dependency detection for safe Java test acceleration. In International Symposium
on Foundations of Software Engineering.
[19]Yanping Chen, Robert L. Probert, and Hasan Ural. 2007. Model-based regres-sion test suite generation using dependence analysis. In Proceedings of the 3rd
international workshop on Advances in model-based testing.
[20]PouriaDerakhshanfar,XavierDevroey,GillesPerrouin,AndyZaidman,andArie
vanDeursen.2020. Search-basedcrashreproductionusingbehaviouralmodel
seeding.Software Testing, Verification and Reliability 30, 3 (2020).
[21]Saikat Dutta, August Shi, Rutvik Choudhary, Zhekun Zhang, Aryaman Jain, and
SasaMisailovic.2020. Detectingflakytestsinprobabilisticandmachinelearning
applications. In International Symposium on Software Testing and Analysis.
[22]SaikatDutta,AugustShi,andSasaMisailovic.2021. FLEX:Fixingflakytestsin
machine-learningprojectsbyupdatingassertionbounds.In EuropeanSoftware
Engineering Conference and Symposium on the Foundations of Software Engineer-
ing.
[23]Moritz Eck, Fabio Palomba, Marco Castelluccio, and Alberto Bacchelli. 2019.
Understanding flaky tests: The developer‚Äôs perspective. In European Software En-
gineering Conference and Symposium on the Foundations of Software Engineering.
[24]GordonFraserandAndreaArcuri.2011. EvoSuite:Automatictestsuitegenera-
tion for object-oriented software. In International Symposium on Foundations of
Software Engineering.
[25]Gordon Fraser and Andrea Arcuri. 2012. Whole test suite generation. IEEE
Transactions on Software Engineering 39, 2 (2012).
[26]Gordon Fraser and Andreas Zeller. 2010. Mutation-driven generation of unit
tests and oracles. In International Symposium on Software Testing and Analysis.
[27]Alessio Gambi, Jonathan Bell, and Andreas Zeller. 2018. Practical test depen-
dency detection. In International Conference on Software Testing, Verification, and
Validation.
[28]Alex Gyori, August Shi, Farah Hariri, and Darko Marinov. 2015. Reliable test-
ing:Detectingstate-pollutingteststopreventtestdependency.In International
Symposium on Software Testing and Analysis.[29]HojunJaygarl,SunghunKim,TaoXie,andCarlKChang.2010. OCAT:Object
capture-based automated testing. In International Symposium on Software Testing
and Analysis.
[30]Maria Kechagia, Xavier Devroey, Annibale Panichella, Georgios Gousios, and
ArievanDeursen.2019. EffectiveandefficientAPImisusedetectionviaexception
propagationandsearch-basedtesting.In InternationalSymposiumonSoftware
Testing and Analysis.
[31]Biju Kunjummen. 2013. JUnit test method ordering. http://www.java-
allandsundry.com/2013/01/junit-test-method-ordering.html.
[32] Wing Lam,ReedOei, AugustShi,Darko Marinov,andTao Xie.2019. iDFlakies:
Aframeworkfordetectingandpartiallyclassifyingflakytests.In International
Conference on Software Testing, Verification, and Validation.
[33]WingLam,AugustShi,ReedOei,SaiZhang,MichaelD.Ernst,andTaoXie.2020.Dependent-test-aware regression testing techniques. In International Symposium
on Software Testing and Analysis.
[34]WingLam,StefanWinter,AngelloAstorga,VictoriaStodden,andDarkoMarinov.
2020. Understandingreproducibilityandcharacteristicsofflakyteststhrough
testrerunsinJavaprojects.In InternationalSymposiumonSoftwareReliability
Engineering.
[35]Wing Lam,Stefan Winter, AnjiangWei, Tao Xie,Darko Marinov, andJonathan
Bell.2020. Alarge-scalelongitudinalstudyofflakytests. ProceedingsoftheACM
on Programming Languages 4, OOPSLA (2020).
[36]Tim Lindholm, Frank Yellin, Gilad Bracha, and Alex Buckley. 2015. The Java
VirtualMachineSpecification. https://docs.oracle.com/javase/specs/jvms/se8/
html/.
[37]Qingzhou Luo, Farah Hariri, Lamyaa Eloussi, and Darko Marinov. 2014. An
empiricalanalysisofflakytests.In InternationalSymposiumonFoundationsof
Software Engineering.
[38]Lei Ma, Cyrille Artho, Cheng Zhang, Hiroyuki Sato, Johannes Gmeiner, andRudolf Ramler. 2015. GRT: Program-analysis-guided random testing (T). In
International Conference on Automated Software Engineering.
[39]Carlos Pacheco, Shuvendu K. Lahiri, Michael D. Ernst, and Thomas Ball. 2007.
Feedback-directedrandomtestgeneration.In InternationalConferenceonSoftware
Engineering.
[40]Jos√©MiguelRojas,GordonFraser,andAndreaArcuri.2016. Seedingstrategiesin
search-basedunittestgeneration. SoftwareTesting,VerificationandReliability
26, 5 (2016).
[41]AugustShi,JonathanBell,,andDarkoMarinov.2019. Mitigatingtheeffectsofflakytestsonmutationtesting.In InternationalSymposiumonSoftwareTesting
and Analysis.
[42]August Shi, Alex Gyori, Owolabi Legunsen, and Darko Marinov. 2016. Detecting
assumptionsondeterministicimplementationsofnon-deterministicspecifica-
tions.InInternationalConferenceonSoftwareTesting,Verification,andValidation .
[43]August Shi, Wing Lam, Reed Oei, Tao Xie, and Darko Marinov. 2019. iFixFlakies:
Aframeworkforautomaticallyfixingorder-dependentflakytests.In European
SoftwareEngineeringConferenceandSymposiumontheFoundationsofSoftware
Engineering.
[44]Anjiang Wei, Pu Yi, Tao Xie, Darko Marinov, and Wing Lam. 2021. Probabilistic
and systematic coverage of consecutive test-method pairs for detecting order-
dependentflakytests.In ToolsandAlgorithmsfortheConstructionandAnalysis
of Systems.
[45]Anjiang Wei, Pu Yi, Tao Xie, Darko Marinov, and Wing Lam. 2022. Preempting
flaky tests via non-idempotent-outcome tests. In International Conference on
Software Engineering.
[46]Andreas Zeller and Ralf Hildebrandt. 2002. Simplifying and isolating failure-
inducing input. IEEE Transactions on Software Engineering 28, 2 (2002).
[47]Peilun Zhang, Yanjie Jiang, Anjiang Wei, Victoria Stodden, Darko Marinov, and
August Shi. 2021. Domain-specific fixes for flaky tests with wrong assump-
tions on underdetermined specifications. In International Conference on Software
Engineering.
[48]Sai Zhang, Darioush Jalali, Jochen Wuttke, Kƒ±van√ß Mu≈ülu, Wing Lam, Michael D.
Ernst, and David Notkin. 2014. Empirically revisiting the test independence
assumption. In International Symposium on Software Testing and Analysis.
[49]SaiZhang,DavidSaff,YingyiBu,andMichaelDErnst.2011. Combinedstatic
and dynamic automated test generation. In International Symposium on Software
Testing and Analysis.
1892
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:52:10 UTC from IEEE Xplore.  Restrictions apply. 