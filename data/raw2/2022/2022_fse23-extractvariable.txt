An Automated Approachto Extracting LocalVariables
Xiaye Chi
Beijing Institute of Technology
Beijing, China
chixiaye@icloud.comHui Liu∗
Beijing Institute of Technology
Beijing, China
liuhui08@bit.edu.cnGuangjie Li
National Innovation Institute of
DefenseTechnology
Beijing, China
WeixiaoWang
Beijing Institute of Technology
Beijing, China
1120191931@bit.edu.cnYunni Xia
ChongqingUniversity
Chongqing,China
xiayunni@hotmail.comYanjieJiang
Beijing Institute of Technology
Beijing, China
yanjiejiang@bit.edu.cn
Yuxia Zhang
Beijing Institute of Technology
Beijing, China
yuxiazh@bit.edu.cnWeixingJi
Beijing Institute of Technology
Beijing, China
jwx@bit.edu.cn
ABSTRACT
Extract local variable is a well-known and widely used refac-
toring.Itisfrequentlyemployedtoreplaceoneormoreoccurrences
of a complex expression with simple accesses to a newly added
variable. Although most IDEs provide tool support for extract local
variables, such tools without deep analysis of the refactorings may
resultinsemanticerrors.Tothisend,inthispaper,weproposea
novelandmorereliableapproach,called ValExtractor ,toconduct
extract variable refactorings automatically. The major challenge of
automatedextractlocalvariablerefactoringsishowtoeﬃciently
and accurately identify the side eﬀect of the extracted expressions
andthepotentialinteractionbetweentheextractedexpressionsand
theircontextswithouttime-consumingdynamicexecutionofthein-
volvedprograms.Toresolvethischallenge,ValExtractorleveragesa
lightweight static source code analysis to validate the side eﬀect of
theselectedexpression,andtoidentifywhichoccurrencesofthese-
lectedexpressioncouldbeextractedtogetherwithoutchangingthe
semantics of the program or introducing potential new exceptions.
Our evaluation results on open-source Java applications suggest
that Eclipse and IntelliJ IDEA, the state-of-the-practice refactoring
engines, resulted in a large number of faulty extract variable refac-
toringswhereasValExtractorsuccessfullyavoidedallsucherrors.
Theproposedapproachhasbeenmergedinto(anddistributedwith)
Eclipseto improve the safetyofextractlocal variable refactoring.
CCS CONCEPTS
•Softwareanditsengineering →Softwaremaintenancetools ;
Integrated andvisual development environments .
∗Corresponding author
Permissionto make digitalor hard copies of allorpart ofthis work for personalor
classroom use is granted without fee provided that copies are not made or distributed
forpro/f_itorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
onthe/f_irstpage.Copyrights forcomponentsofthisworkownedbyothersthanthe
author(s)mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,or
republish,topostonserversortoredistributetolists,requirespriorspeci/f_icpermission
and/or a fee. Request permissions from permissions@acm.org.
ESEC/FSE ’23, December 3–9, 2023, San Francisco, CA,USA
©2023 Copyright heldby the owner/author(s). Publicationrightslicensed to ACM.
ACM ISBN 979-8-4007-0327-0/23/12...$15.00
https://doi.org/10.1145/3611643.3616261KEYWORDS
Software Refactoring, ExtractLocal Variable,Reliable,Bugs
ACMReference Format:
Xiaye Chi, Hui Liu, Guangjie Li, Weixiao Wang, Yunni Xia, Yanjie Jiang,
Yuxia Zhang, and Weixing Ji. 2023. An Automated Approach to Extracting
Local Variables. In Proceedings of the 31st ACM Joint European Software
Engineering Conference and Symposium on the Foundations of Software Engi-
neering(ESEC/FSE’23),December3–9,2023,SanFrancisco,CA,USA. ACM,
NewYork, NY, USA, 13pages.https://doi.org/10.1145/3611643.3616261
1 INTRODUCTION
Theterm" softwarerefactoring "wascoinedbyOpdyke[ 29],refer-
ringtotheobject-orientedvariantofrestructuring[ 1].Ingeneral,
software refactoring could be de/f_ined as " the process of changing
a [object-oriented] software system in such a way that it does not
altertheexternalbehaviorofthecode,yetimprovesitsinternalstruc-
ture"[11].Recently,softwarerefactoringhasbeenwellstudiedasan
eﬃcientwaytoimprovesoftwarequality[ 6,20]aswellasaneﬀec-
tive wayto facilitate software maintenanceand evolution [ 21,50].
RefactoringtoolslikeJDeodorant[ 43],ReSharper[ 32],andbuilt-in
refactoringenginesinIDEs(includingEclipse[ 7],IntelliJIDEA[ 16],
NetBeans [ 27], and Visual Studio [ 49]) have been widely used to
facilitate software refactoring.
Extractlocalvariable (orextractvariable forshort)isoneofthe
most popular refactorings. Notably, dozens of software refactor-
ings have been proposed, ranging from low-level refactorings like
renamingvariable tohigh-levelrefactoringslike teasingapartinher-
itance[11].Bytrackingtherefactoringhistoriesofprogrammers,
Murphy-Hilletal.[ 25]foundthat extractvariable wasthesecond
mostpopularsoftwarerefactoring. Extractlocalvariable istocreate
a local variable, initialize it with a selected expression, and replace
oneormoreoccurrencesoftheexpressionwithdirectaccesstothe
newvariable.Thebene/f_itsoftherefactoringaretwofold[ 10].On
oneside,replacingcomplexexpressionswithanamedvariablemay
increase the readability of the program because variable names are
oftenmorereadablethancomplexexpressions.Ontheotherside,
replacing multiple occurrences of the same expression with simple
313ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA Xiaye Chi,HuiLiu, Guangjie Li, Weixiao Wang,YunniXia,YanjieJiang,YuxiaZhang,andWeixing Ji
accessestoavariablemayavoidrepetitivecomputationandthus
reduce code complexity.
Manuallyextractinglocalvariablescouldbetedious,time-consu-
minganderror-prone.Ithasbeenwellknownthatchangingsource
code of complex software systems could be risky [ 37]. The same is
trueforsoftwarerefactoring[ 3].Tothisend,mainstreamIDEshave
provided automated tool support for this refactoring. According to
the survey by Golubev et al. [ 15], 54.7% of the surveyed developers
use the IDE support to conduct Extractrefactorings, e.g., extract
variables. The empirical study conducted by Negara et al. [ 26] sug-
gests that extract variable is frequently performed with automated
toolsupport.Developerspfermover80%ofextractvariablerefac-
torings with automated tool support. However, such refactoring
toolsoftensimplyreplaceallexpressionsthatarelexicallyidentical
to the selected one without in-deep analysis on the safety of the
refactoring. As a result, even with such tool support, extracting
local variables could be error-prone, resulting in exceptions and
semantic errors. In Section 2, we explain with motivating exam-
ples why the state-of-the-practice refactoring tools may introduce
semantic errorswhileextracting local variables.
Tothis end, in this paper, we propose anovel and more reliable
approach,called ValExtractor ,toconductextractvariablerefactor-
ings automatically. The major challenge of automated extract local
variablerefactoringsishowtoeﬃcientlyandaccuratelyidentifythe
sideeﬀectoftheextractedexpressionsandthepotentialinteraction
between the extracted expressions and their contexts (i.e., state-
mentsaroundthem)withouttime-consumingdynamicexecution
oftheinvolvedprograms.Toresolvethischallenge,ValExtractor
leveragesalightweightstaticsourcecodeanalysistovalidatethe
side eﬀect of the selected expression, and to identify which oc-
currences of the selected expression could be extracted together
without changing the semantics of the program or introducing
potential new exceptions. We evaluated the proposed approach
on open-source applications by applying it and the baseline ap-
proaches (Eclipse and IntelliJ IDEA) to extract expressions in such
applications.Our evaluation results suggested that the state-of-the-
practicebaselinesdidresultinhundredsofsemanticerrorswhile
conductingextractvariablerefactorings.Ourapproach,however,
successfullyavoidedallsucherrors.Besidesthat,wealsoevaluated
theproposedapproachandEclipsewith253real-worldextractvari-
able refactorings discovered from 10 open-source applications. Our
evaluationresultssuggestedthatEclipseresultedinsemanticerrors
in19outofthe253cases,andanothermainstreamIDE IntilliJIDEA
resulted in semantic errors on all such 19 cases as well. In contrast,
ourapproachsucceededinconductingallsuchrefactoringswithout
introducing any semantic errors.
The paper makesthe following contributions:
•Anautomatedandmorereliableapproachtoextractinglocal
variables inJava applications.
•Abenchmarkconsistingof253real-worldextractlocalvariable
refactorings.
•An evaluation of the proposed approach on the benchmark,
whosereplicationpackage,includingdetailedinstruction for
replication,ispubliclyavailable [ 31].1private static String parseToken(String pattern, int[] indexRef) {
2...
3if (pattern == null || pattern.length() > MAX_LEN) {
4return null;
5}
6while (i + 1 < pattern.length()) {
7...
8}
9...
10char lastChar = pattern.charAt ( pattern.length() −1);
11pattern = "Default_" + pattern;
12int j = indexRef[0];
13while (j < pattern.length()) {
14...
Listing 1:MotivatingExample
2 MOTIVATING EXAMPLE
In this section, we explain with a motivating example the po-
tential risks in extract variable refactorings, and how we min-
imize such risks. The motivating example is presented in List-
ing1. Suppose that a developer realizes that there are many in-
stances of expression " pattern.length() " in the motivating ex-
ample (as shown in colors), and would like to replace such in-
stances with a local variable. To this end, the developer selects the
expression " pattern.length() " at Line 6 within Eclipse1, right-
clicks it, and selects menu item " refactoring -extract local
variable " as well as the checkbox " replace all occurrences
of the selected expression with references to the local
variable ".Asaresponsetothecommand,EclipseinvokesJDT[ 8]
to conduct the extract variable refactoring. The resulting source
code is presented in Listing 2. Notably, conducting the same refac-
toringwith IntilliJ IDEA wouldresult inthe same code.
TherefactoringsconductedautomaticallybyEclipseandIDEA
are questionable. By comparing the code before and after the refac-
toring, we notice that Eclipse and IDEA declare a new variable
(length)atLine3inListing 2andinitializesitwiththeextracted
expression" pattern.length() ".Italsoreplaces allof the fourin-
stances of the expression with the newly added variable length
at Lines 4, 7, 11, and 14, respectively. However, the replacement
is incorrect and it results in serious bugs that change the seman-
tics of the enclosing software application. First, the newly added
declaration at Line 3 is questionable. In case the input parame-
terpattern equalsnull, the declaration would result in a null
pointer exception .Incontrast,thesourcecodebeforerefactor-
ingcanavoidtheexceptionbecauseitcarefullycheckswhetherthe
patternequalsnull(Line3ofListing 1)beforethevariableisused
to access any of its properties. Second, replacing the expression
"pattern.length() " with variable lengthat Lines 14 of Listing 2
is incorrect. The variable pattern has been updated at Line 12.
Consequently, at Line 14 the variable length(initialized at Line 3)
is not equivalent to the original expression " pattern.length() ".
Asaresult,replacingtheexpressionwithvariable lengthatLine
14 isincorrect,whichmayresult infewer iterations at Line14.
To avoid such errors, in this paper, we propose an automated
approach ValExtractor toconductextractvariablerefactorings.It
successfully conducts the refactoring as shown in Listing 3and
avoids all bugs introduced by the state-of-the-practice IDEs (i.e.,
1Do not useversion 4.26.0 orlaterwhereourapproach has been integrated.
314AnAutomatedApproachto ExtractingLocalVariables ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA
1private static String parseToken(String pattern, int[] indexRef) {
2...
3intlength =pattern.length();
4if (pattern == null || length > MAX_LEN) {
5return null;
6}
7while (i + 1 < length) {
8...
9}
10...
11char lastChar = pattern.charAt ( length−1);
12pattern = "Default_" + pattern;
13int j = indexRef[0];
14while (j < length) {
15...
Listing 2:After Refactoring(by Eclipse orIDEA)
1private static String parseToken(String pattern, int[] indexRef) {
2...
3if (pattern == null || pattern.length() > MAX_LEN) {
4return null;
5}
6intlength =pattern.length();
7while (i + 1 < length) {
8...
9}
10...
11char lastChar = pattern.charAt ( length−1);
12pattern = "Default_" + pattern;
13int j = indexRef[0];
14while (j < pattern.length()) {
15...
Listing 3:After Refactoring(by ValExtractor )
Eclipse and IDEA). ValExtractor works as follows. First, given
the selected expression " pattern.length() " at Line 6 in Listing 1,
ValExtractor infersthatthenewvariabledeclarationshouldbe
added between Line 5 and Line 6 in Listing 1if the selected ex-
pression alone should be extracted as a new variable. After that,
ValExtractor validatesthatthevariableandtheexpression(tobe
replacedwithaccesstothevariable)areequivalentatLine6,and
theexpressionitselfdoesnothaveanysideeﬀect.Consequently,
the selected expression (at Line 6) is extractable, and it is added as
anextractable expression .
ValExtractor keeps /f_inding more extractable expressions that
could be extracted together with the selected expression. To this
end, it turns to the expression " pattern.length() " at Line 10 of
Listing1because it is the closest expression to the selected expres-
sionatLine6anditisliterallyidenticaltotheselectedexpression.It
repeats the inference in suggesting where the new variable should
bedeclaredaswellasthevalidationofpotentialsideeﬀectasin-
troduced in the preceding paragraph. This time, ValExtractor
suggests that the new variable could be declared between Line 5
andLine6inListing 1andthatreplacingbothoftheexpressions
(at Lines 6and 10) issafe. Consequently, theexpressionat Line 10
isalsoaddedas an extractable expression .
ValExtractor comes to the next expression " pattern.lengt-
h()"at Line13ofListing 1.Whilevalidatingthe sideeﬀectofthe
expressionsbetweenLine10andLine13,ValExtractor/f_indsthatthe
statement at Line 11 has side eﬀect on the selected expression (i.e.,
it may change the value of the expression " pattern.length() ").
As a result, executing the same expression appearing before andSelected Expression
Retrieval of 
Candidate 
Expressions
RefactoringRefactored
ProjectCandidate 
Expressions
LocationExpression
Validation
Side 
Effect
No
Searching for 
Extractable 
ExpressionsExtractable
ExpressionsYes
Extract
able
YesNo
Figure 1:Overview of ValExtractor
after Line 11 may result in diﬀerent values, and thus we cannot
extract the expressions at Line 6 (before Line 11) and Line 13 (after
Line 11) together. To this end, ValExtractor discards the expression
at Line13 as well as otherexpressionsbeyondit.
Finally,itreversesthesearchingdirection,andturnstotheex-
pression" pattern.length() "atLine3.Itinfersthatthenewvari-
able should be declared and initialized before Line 3 in Listing 1.
However, the initialization of the new variable with the expression
"pattern.length() "before Line 3may result ina null pointer
exception (whenpatternequalsnull)thatmaynothappenbe-
foretherefactoring.Consequently,ValExtractordiscardsthisex-
pressionas well as otherexpressionsbefore it(if any).
As a result of the preceding static analysis, ValExtractor ex-
tracts two extractable expressions at Lines 6 and 10 of Listing 1,
avoidingallbugsintroducedbyEclipseJDT.
3 APPROACH
3.1 Overview
An overview of the proposed approach ( ValExtractor ) is pre-
sentedinFig. 1.Ittakesasinputaselectedexpressionanditsenclos-
ing project. With such input, ValExtractor validates whether the
selectedexpressionhassideeﬀectandvalidatesiterativelywhether
other literally identical expressions within the same method could
be extractedtogether.Overall,ValExtractor works as follows:
•Expression validation: It adds the selected expression as a can-
didateexpression ,andvalidateswhethertheselectedexpression
has sideeﬀect.If yes, itskips the nextstep.
315ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA Xiaye Chi,HuiLiu, Guangjie Li, Weixiao Wang,YunniXia,YanjieJiang,YuxiaZhang,andWeixing Ji
•Retrieval of candidate expressions: It retrieves all expressions
withintheenclosingmethodthatareliterallyidenticaltothe
selectedexpression,taking themas candidate expressions .
•Searchforextractableexpressions:Ittakesagreedystrategy
to search for candidate expressions that could be extracted to-
getherwiththeselectedone(called extractableexpressions ),and
suggestswherethenewvariableshouldbedeclared.Ifnoneof
thecandidateexpressionscouldbeextracted, ValExtractor
terminatesandnorefactoringwouldbeconducted.Otherwise,
ValExtractor turns to the nextstep.
•Refactoring: Finally, ValExtractor conducts extract variable
refactoring by declaring and initializing a new variable and
replacing all of the extractable expressions with accesses to
the variable.
Details of the key steps are presented in the following sections,
and the full list of preconditions when a set of literally identical
expressions could be extracted by an extract variable refactoring is
presentedas an onlineappendix [ 12].
3.2 Expression Validation
The validation of the selected expression is composed of two parts.
The /f_irst part validates whether the selected expression is suitable
for extraction.Not allexpressionscould be extractedas local vari-
ables.Forexample," this.length "inassignment" this.length=5 ",
"ArrayList<String>() " in statement " list= new ArrayList<S-
tring>() ", and "id.isEmpty() " in statement " st.id.isEmpty() "
cannotbeextractedasvariables.ValExtractorterminates(i.e.,re-
fusestoconducttherefactoring)iftheselectedexpressionisone
ofthefollowingexpressions:parameters,leftvalues,declarations,
singlenullliteral,expressionsinannotations,incompleteexpres-
sions,voidexpressions,enumerationexpressionsinswitchcases,
expressionsusedininitializerorupdaterof forstatements,name
properties,andexpressionsoutsidemethods.
Inthesecondpart,ValExtractorvalidateswhethertheselected
expressionhassideeﬀect.Anexpressionhas a side effect ifexe-
cuting the same expression (one or more times) is not semantically
equivalenttoasingleexecutionoftheexpression.Forexample,the
expression stack.pop() hassideeﬀectbecauserepeatingit ntimes
mayremoveadditional nelementsfromthestack.Consequently,
the following code
Print(stack.pop());
Print(stack.pop());
isnot equivalentto the following code:
value=stack.pop()
Print(value);
Print(value);
If the selected expression has side eﬀect, we cannot extract it to-
gether with other expressions that are literally identical to it. In
this case, the selected expression is taken as the only candidate ex-
pression,i.e.,ValExtractorwillextractnomorethanoneexpression.
ValExtractor validatestheside eﬀect ofthe selectedexpression
bycheckingwhether theexpression hasupdated states of the sys-
tem,generatedoutputs,orconsumedsysteminputs.Anexpression
hasupdatedthestatesofthesystemifandonlyiftheexpression
(including methodscalled directly or indirectlyby it) has updated1InstantConverter conv =
ConverterManager.getInstance() .getInstantConverter (lhsObj);
2ChronologylhsChrono=conv.getChronology(lhsObj, (Chronology) null);
3long lhsMillis = conv.getInstantMillis (lhsObj, lhsChrono);
4conv =ConverterManager.getInstance() .getInstantConverter (rhsObj);
5
6public static ConverterManagergetInstance() {
7if (INSTANCE==null) {
8INSTANCE=newConverterManager();
9}
10return INSTANCE;
11}
Listing 4:Expressions Updating Empty Fields Only
anysoftware entitieswhoselifetimeis beyondthe executionof the
selectedexpression.ValExtractoridenti/f_iesgenerationofoutputs
andconsumptionofsysteminputsbycomparingtheexecutedstate-
ments against a list of manually marked Java input/output APIs.
Ifany ofthemarked APIs is executed directly or indirectlyby the
selectedexpression,ithas sideeﬀect.
An exception to the preceding rules is that we allow the se-
lectedexpressiontoinitialize/f_ieldsthatareinitially null.Listing4
presentsatypicalexampleofsuchinitialization.Theselectedexpres-
sion "ConverterManager.getInstance() " is to retrieve the static
/f_ieldmanager ofclassConverterManager .However,ifthevariable
equalsnull(i.e., it has not yet been initialized), the expression
wouldinitializeitwithabrandnewobject(Line 8).Consequently,
althoughtheselectedexpressionhasthepossibilitytoupdatethe
/f_ieldmanager,repeatingtheexpressionmultipletimesissemanti-
cally equivalentto asingleexecutionof the same expression.
3.3 Retrieval ofCandidate Expressions
First, ValExtractor automatically infers the scope of the selected
expression,notedas ScopeExp.Thescopeoftheexpressionspeci/f_ies
where the expression is syntactically accessible. Consequently, the
scopeistheintersectionofthescopesofallelementsinvolvedinthe
expression.Forexample,thescopeoftheexpression" list.add(it-
em)" is the intersection of the scope of the variable " list" and the
scope ofthe parameter" item".
Toretrievecandidateexpressionsthatmaybeextractedtogether
withtheselectedexpression,ValExtractorsearchesforallexpres-
sions within ScopeExp that are lexically identical to the selected
expression. For each of the retrieved expressions, ValExtractor also
validates whether it is suitable for extraction in the same way as
itvalidatestheselectedexpressioninSection 3.2.Allexpressions
passingthe validation are addedas candidate expressions .
3.4 Searching forExtractableExpressions
Foraselectedto-be-extractedexpressionandasequenceofcandi-
date expressions, ValExtractor searches for extractable expressions
by Algorithm 1. The output of the algorithm is a suggested loca-
tion for declaring and initializing the new variable (that should
be introducedby extract variable refactoring), and a sequence of
extractable expressions that could be replaced with accesses to the
newvariable.
3.4.1 Iteration. On each iteration (Lines 5-16 in Algorithm 1),
ValExtractorvalidateswhether an additionalcandidateexpression
316AnAutomatedApproachto ExtractingLocalVariables ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA
Algorithm1:: Searching for Extractable Expressions
Input:/u1D460/u1D452/u1D459/u1D438/u1D465/u1D45D; // selectedexpression
/u1D450/u1D44E/u1D45B/u1D438/u1D465/u1D45D/u1D460// candidate expressions
Output:/u1D452/u1D465/u1D461/u1D438/u1D465/u1D45D/u1D460; // extractable expressions
/u1D43F/u1D45C/u1D450/u1D44E// location for variable declaration
1/u1D460/u1D452/u1D44E/u1D45F/u1D450/uni210E/u1D437/u1D456/u1D45F =2
2/u1D452/u1D465/u1D461/u1D438/u1D465/u1D45D/u1D460=∅
3/u1D43F/u1D45C/u1D450/u1D44E=−1
4/u1D450/u1D438/u1D465/u1D45D=/u1D460/u1D452/u1D459/u1D438/u1D465/u1D45D
5while/u1D450/u1D438/u1D465/u1D45D!= null&& /u1D460/u1D452/u1D44E/u1D45F/u1D450/uni210E/u1D437/u1D456/u1D45F >0do
6/u1D452/u1D465/u1D45D/u1D460={/u1D450/u1D438/u1D465/u1D45D}∪/u1D452/u1D465/u1D461/u1D438/u1D465/u1D45D/u1D460
7/u1D450/u1D44E/u1D45B/u1D438/u1D465/u1D45D/u1D460.remove(/u1D450/u1D438/u1D465/u1D45D)
8/u1D43F/u1D45C/u1D450=InferBestLoc( /u1D452/u1D465/u1D45D/u1D460)
9ifChangeExpValue( /u1D43F/u1D45C/u1D450,/u1D452/u1D465/u1D45D/u1D460,/u1D460/u1D452/u1D459/u1D438/u1D465/u1D45D)OR
AdditionalException( /u1D43F/u1D45C/u1D450,/u1D452/u1D465/u1D45D/u1D460)then
10 /u1D460/u1D452/u1D44E/u1D45F/u1D450/uni210E/u1D437/u1D456/u1D45F =/u1D460/u1D452/u1D44E/u1D45F/u1D450/uni210E/u1D437/u1D456/u1D45F - 1
11else
12 /u1D452/u1D465/u1D461/u1D438/u1D465/u1D45D/u1D460=/u1D452/u1D465/u1D45D/u1D460
13 /u1D43F/u1D45C/u1D450/u1D44E=/u1D43F/u1D45C/u1D450
14end
15/u1D450/u1D438/u1D465/u1D45D=getNext( /u1D450/u1D44E/u1D45B/u1D438/u1D465/u1D45D/u1D460,/u1D452/u1D465/u1D461/u1D438/u1D465/u1D45D/u1D460,/u1D460/u1D452/u1D44E/u1D45F/u1D450/uni210E/u1D437/u1D456/u1D45F ,/u1D460/u1D452/u1D459/u1D438/u1D465/u1D45D)
16end
/u1D450/u1D438/u1D465/u1D45Dcould be extracted together with other extractable expres-
sions in/u1D452/u1D465/u1D461/u1D438/u1D465/u1D45D/u1D460. For convenience, we de/f_ine a new set /u1D452/u1D465/u1D45D/u1D460=
{/u1D450/u1D438/u1D465/u1D45D} ∪/u1D452/u1D465/u1D461/u1D438/u1D465/u1D45D/u1D460at Line 6. The validation is composed of two
steps. On the /f_irst step (Line 8), ValExtractor infers the best lo-
cation for declaring and initializing the new variables in case all
expressionsin /u1D452/u1D465/u1D45D/u1D460couldbeextractedtogetherasasinglevariable.
On the second step (Line 9), with methods ChangeExpValue and
AdditionalException ,ValExtractor validates:
(1)Whetheranystatementsbetween /u1D43F/u1D45C/u1D450(wherethenewvariable
would be initialized)and the expressions in /u1D452/u1D465/u1D45D/u1D460(where the
variable would be accessed) would change the value of the
selectedexpression,i.e.,wouldupdateanyvariablesthatare
read by the expression. Notably, direct and indirect method
invocations are analyzedas well.
(2)Whether therefactoring could resultin additionalexceptions
that maynot be raisedbefore the refactoring.
Ifeitherofthevalidationfails(i.e.,returning true),thecandidateex-
pression cannot be extracted together with the selected expression.
Otherwise, thecurrent expression /u1D450/u1D438/u1D465/u1D45Dis added as anextractable
expression(Lines6and12).Methods InferBestLoc ,ChangeExpValue ,
andAdditionalException areexplainedindetailsinSection 3.4.2and
Section3.4.3.
Notably, the algorithm validates the selected expression itself
on the /f_irst iteration (Line 4 and Lines 5-14). If the selected ex-
pression passes the validation, the algorithm would leverage the
methodgetNext (Line 15) to retrieve the next candidate expres-
sionin/u1D450/u1D44E/u1D45B/u1D438/u1D465/u1D45D/u1D460thatmaybeextractedtogetherwiththeselected
expression. On each iteration, the algorithm may add an additional
candidate expression to the extractable expressions (Lines 6 and
12). The algorithm /f_irst searches for extractable expressions by
scanning statements following the selected expression ( /u1D460/u1D452/u1D459/u1D438/u1D465/u1D45D).Algorithm2:: Auxiliary Functions
1Function InferBestLoc( /u1D452/u1D465/u1D45D/u1D460):
2/u1D443/u1D44E/u1D45F/u1D452/u1D45B/u1D461=CommonParentNode( /u1D452/u1D465/u1D45D/u1D460)
3if/u1D443/u1D44E/u1D45F/u1D452/u1D45B/u1D461instanceofBlock then
4 nodes =Parent.getChildren();
5 for(/u1D456=0;/u1D456</u1D45B/u1D45C/u1D451/u1D452/u1D460./u1D460/u1D456/u1D467/u1D452 ;/u1D456++)do
6 ifnodes[i].contain( /u1D452/u1D465/u1D45D/u1D460)then
7 /u1D43F/u1D45C/u1D450=StmtBasedLoc( /u1D45B/u1D45C/u1D451/u1D452/u1D460[/u1D456]./u1D43F/u1D45C/u1D450)
8 break
9 end
10 end
11else
12 /u1D43F/u1D45C/u1D450=StmtBasedLoc( /u1D443/u1D44E/u1D45F/u1D452/u1D45B/u1D461.Loc)
13end
14return/u1D43F/u1D45C/u1D450
15Function ChangeExpValue( /u1D43F/u1D45C/u1D450,/u1D452/u1D465/u1D45D/u1D460,/u1D460/u1D452/u1D459/u1D438/u1D465/u1D45D):
16/u1D463/u1D44E/u1D45F/u1D460_/u1D45F_/u1D452/u1D465/u1D45D=VariablesReadby( /u1D460/u1D452/u1D459/u1D438/u1D465/u1D45D)
17/u1D460/u1D461/u1D460=StatementsWithinScope( /u1D43F/u1D45C/u1D450,/u1D452/u1D465/u1D45D/u1D460)
18foreach/u1D460/u1D461/u1D44E/u1D461/u1D452/u1D45A/u1D452/u1D45B/u1D461 in/u1D460/u1D461/u1D460do
19 /u1D463/u1D44E/u1D45F/u1D460_/u1D464_/u1D460/u1D461=VariablesWrittenby( /u1D460/u1D461/u1D44E/u1D461/u1D452/u1D45A/u1D452/u1D45B/u1D461 )
20 if/u1D463/u1D44E/u1D45F/u1D460_/u1D464_/u1D460/u1D461∩/u1D463/u1D44E/u1D45F/u1D460_/u1D45F_/u1D452/u1D465/u1D45D!=∅then
21 return true
22 end
23end
24return false
25Function AdditionalException( /u1D43F/u1D45C/u1D450,/u1D452/u1D465/u1D45D/u1D460):
26foreach/u1D452/u1D465/u1D45Din/u1D452/u1D465/u1D45D/u1D460do
27 /u1D441/u1D450/u1D451/u1D460=/u1D441/u1D462/u1D459/u1D459/u1D436/uni210E/u1D452/u1D450/u1D458/u1D436/u1D45C/u1D45B/u1D451/u1D456/u1D461/u1D456/u1D45C/u1D45B/u1D460 (/u1D459/u1D45C/u1D450,/u1D452/u1D465/u1D45D)
28 /u1D441/u1D456/u1D45B/u1D460=/u1D441/u1D450/u1D451/u1D460./u1D436/uni210E/u1D452/u1D450/u1D458/u1D452/u1D451/u1D43C/u1D45B/u1D460/u1D461/u1D44E/u1D45B/u1D450/u1D452/u1D460 ∩
/u1D452/u1D465/u1D45D./u1D434/u1D450/u1D450/u1D452/u1D460/u1D460/u1D452/u1D451/u1D43C/u1D45B/u1D460/u1D461/u1D44E/u1D45B/u1D450/u1D452/u1D460
29 /u1D447/u1D450/u1D451/u1D460=/u1D447/u1D466.alt/u1D45D/u1D452/u1D436/uni210E/u1D452/u1D450/u1D458/u1D436/u1D45C/u1D45B/u1D451/u1D456/u1D461/u1D456/u1D45C/u1D45B/u1D460 (/u1D459/u1D45C/u1D450,/u1D452/u1D465/u1D45D)
30 /u1D447/u1D456/u1D45B/u1D460=/u1D447/u1D450/u1D451/u1D460./u1D436/uni210E/u1D452/u1D450/u1D458/u1D452/u1D451/u1D43C/u1D45B/u1D460/u1D461/u1D44E/u1D45B/u1D450/u1D452/u1D460 ∩
/u1D452/u1D465/u1D45D./u1D447/u1D466.alt/u1D45D/u1D452/u1D436/u1D44E/u1D460/u1D461/u1D452/u1D451/u1D43C/u1D45B/u1D460/u1D461/u1D44E/u1D45B/u1D450/u1D452/u1D460
31 if/u1D441/u1D456/u1D45B/u1D460≠∅OR/u1D447/u1D456/u1D45B/u1D460≠∅then
32 return true
33 end
34end
35return false
Afterthat,itrevertsthesearchingdirectionandscansstatements
before the selected expression. It leverages the /f_lag " searchDir " to
controlthesearchingdirection.If" searchDir==2 ",getNext would
returnthecandidateexpressionin /u1D450/u1D44E/u1D45B/u1D438/u1D465/u1D45D/u1D460thatis1)notincludedin
/u1D452/u1D465/u1D461/u1D438/u1D465/u1D45D/u1D460and 2) appears in the source code /f_ile after all expressions
in/u1D452/u1D465/u1D461/u1D438/u1D465/u1D45D/u1D460but before other expressionsin /u1D450/u1D44E/u1D45B/u1D438/u1D465/u1D45D/u1D460(candidate ex-
pressions).If " searchDir==1 ",getNextwould reversethe search
direction:returning thecandidateexpressionthatappearsinthe
sourcecode/f_ilebeforeallexpressionsin /u1D452/u1D465/u1D461/u1D438/u1D465/u1D45D/u1D460butafterotherex-
pressionsin /u1D450/u1D44E/u1D45B/u1D438/u1D465/u1D45D/u1D460.When"searchDir==0 "istrue,thealgorithm
stops searching for more extractable expressions.
317ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA Xiaye Chi,HuiLiu, Guangjie Li, Weixiao Wang,YunniXia,YanjieJiang,YuxiaZhang,andWeixing Ji
3.4.2 InferringtheBestLocationforVariableDeclaration. Thefunc-
tionInferBestLoc in Algorithm 2shows how to infer the best lo-
cationforvariabledeclaration.ValExtractorleveragestheASTof
theenclosingmethodto/f_indthelowestcommonparentnodefor
all of the expressions in /u1D452/u1D465/u1D45D/u1D460(Line 2). If the parent node is not a
block[2],ValExtractorsuggestsinsertingthevariabledeclaration
immediatelybeforetheparentnode(Line12).Otherwise,ValExtrac-
tor suggests inserting the declaration as a child node of the parent
node(block)andthis childnodeshould be de/f_inedjust before the
/f_irstchild nodeoftheblock that contains anyexpressions in /u1D452/u1D465/u1D45D/u1D460
(Lines4-10).Notably,weleveragethemethod StmtBasedLoc (Lines
7and12)toavoidinsertingthevariabledeclarationwithinanex-
isting statement. It automatically returns the /f_irst place where a
variable declaration could be inserted before the given absolute
location.
3.4.3 CheckingPreconditions. ValExtractoremploystwofunctions
ChangeExpValue andAdditionalException inAlgorithm 2to check
preconditionsfortherefactoring.Function ChangeExpValue vali-
dates whether any statement between /u1D43F/u1D45C/u1D450(where the new variable
wouldbeinitialized)andtheexpressionsin /u1D452/u1D465/u1D45D/u1D460(wherethevari-
able would be accessed) would change the value of the selected
expression. If yes, extracting all expressions in /u1D452/u1D465/u1D45D/u1D460together could
resultinsemanticerrors,andthusthecurrentexpression /u1D450/u1D438/u1D465/u1D45Dis
discardedforsafety(Lines9-10inAlgorithm 1).ChangeExpValue
identi/f_ies all variables that are accessed by the selected expres-
sion (Line 16). All statements between /u1D43F/u1D45C/u1D450and the expressions
in/u1D452/u1D465/u1D45D/u1D460are retrieved and noted as /u1D460/u1D461/u1D460(Line 17). For each of the
statements in /u1D460/u1D461/u1D460, ValExtractor validates whether it updates any
elementthathasbeenreadbytheselectedexpression(Lines20-22).
If yes,ChangeExpValue terminates the validation and returns true
(i.e.,the precondition isnot satis/f_ied).
Besides the variable access-based precondition checking, ValEx-
tractoralsoleveragesfunction AdditionalException toconductan
exception-based precondition checking (Lines 25-35). It is likely
that the execution of the same expression in some places would
resultinexceptionswhereastheexecutioninotherplaceswould
not result in such exceptions. A typical example is presented in
Listing2.Thesameexpression" pattern.length() "atLine3may
result in a null pointer exception whereas the same expression at
Line 4 (before it is replaced by variable length) will not. The latter
avoids the null pointer exception because of the preceding con-
dition ("pattern==null "): ifpattern equalsnull, the expression
at Line 4 would not be executed, which avoids the null pointer
exception.Consequently,extractingtheexpressionatLine4asa
new variable (at Line 2) as presented in Listing 2may result in
additionalexceptions,whichiscalledexception-basedsideeﬀect.
Of the current version, we focus on null pointer exceptions and
class cast exceptions only, and thus we only check 1) whether any
instancesaccessedbytheselectedexpressionhavebeenchecked
againstnull(Lines27,28,31),and2)whetheranyinstancestype-
casted by the selected expression have been checked against the
given types (Lines 29, 30, 31).
3.5 Refactoring
SupposethatValExtractoridenti/f_iesasequenceofextractableex-
pressions ( /u1D452/u1D465/u1D461/u1D438/u1D465/u1D45D/u1D460) and suggests declaring the new variable on1//Before Refactoring
2for(Good g:goodlist)
3if(g.getPrice() > 0)
4sum +=g.getPrice() ∗discount;
5−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
6//After Extract Variable Refactoring
7for(Good g:goodlist) {
8double price =g.getPrice();
9if(price > 0)
10sum +=price∗discount;
11}
Listing 5:Inserting into Single-Statement For-Iteration
location/u1D43F/u1D45C/u1D450/u1D44E, ValExtractor would conduct the suggested extract
variable refactoring as follows.
•First, ValExtractor infers the data type of the new variable by
exploiting TypeBinding ofJDT[17].
•Second,ValExtractorinsertsthedeclarationofthenewvari-
able and initializes it with the selected expression on loca-
tion/u1D43F/u1D45C/u1D450/u1D44E. If it is inserted into a single-statement complex
structural node, like if-else-statement ,while-iteration ,
lambda-statement ,andfor-iteration ,ValExtractorwould
insert"{"and"}"tomarkthewholecodeblock.Atypicalex-
ample is presented in Listing 5. Without the newly inserted
"{"atLine7and" }"atLine11,the if-statement (Lines9-10)
wouldbemovedoutofthe for-statement ,whichwouldre-
sultinsemanticerrorsbecausetheif-statementconstitutesthe
body ofthe for-statement inthe originalcode.
•Finally, ValExtractor replaces all extractable expressions in
/u1D452/u1D465/u1D461/u1D438/u1D465/u1D45D/u1D460with direct access to the new variable. Notebly, we
leverages the API provided by JDT to recommend variable
name basedonthe selectedexpressionandits expectedtype.
4 EVALUATION
4.1 Research Questions
The evaluation investigates the following research questions:
•RQ1:Does ValExtractor improve thestate ofthe practicein
automating extract variable refactorings?
•RQ2:WhydoEclipseandIDEAresultinfaultyextractvariable
refactorings andhowdoes ValExtractor avoid such errors?
•RQ3:Does ValExtractor outperform the state of the art in
precondition checking for extract local variable refactorings?
RQ1 concerns the comparison among ValExtractor, Eclipse, and
IntelliJ IDEA. Eclipse (version 4.23.0 released in 2022) and IDEA
(2022-03 release) were selected for comparison because they rep-
resent the state of the practice, and they are widely used in the
industry.Notably,wedidnotemploythelatestversionofEclipse
because the proposed approach has been integrated into Eclipse
sinceversion4.26.0.RQ2concernsthereasons/mechanismforintro-
ducing/avoidingerrorsinautomatedextractvariablerefactorings.
RQ3concernsthepreconditioncheckingofextractlocalvariable
refactorings. To answer RQ3, we compare ValExtractor against
JRRT[35]thatrepresentsthestateoftheartinpreconditioncheck-
ing for software refactorings. Notably, while investigating RQ1, we
do not compare ValExtractor against JRRT because JRRT has its
specialstrategy:Italwaysextractstheselectedexpressiononly(not
withany otherlexically identical expressions)[ 35]. It is completely
318AnAutomatedApproachto ExtractingLocalVariables ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA
diﬀerent from ValExtractor, Eclipse and IDEA, making it hard to
compare themdirectlyconcerning the overallperformance.
4.2 Subject Applications
We leveraged all applications in the well-known bug repository
Defects4J [ 5](version 1.1.0) for the evaluation. In total, Defects4J
contains 6 Java applications, as speci/f_ied in the /f_irst column of
Table1. The size (LOC) of the applications varied from 61,298 to
230,135.Wereusedsuchapplicationsbecausewewerefamiliarwith
thisrepository,whichmightfacilitatemanualvalidation/analysisof
theevaluationresults.Besidesthat,theapplicationsarewidelyused
open-sourceapplicationsfromdiﬀerentdomains,whichmighthelp
reduce potentialbiasandfacilitate replication ofthe evaluation.
4.3 Process
Oneachsubjectapplication,theevaluationwasconductedasfol-
lows. First, we retrieved all expressions that appeared multiple
timeswithinthesamemethod.Eachoftheretrievedexpressions
could be represented /u1D452/u1D465/u1D45D/u1D456=</u1D461/u1D465/u1D461,/u1D43F/u1D45C/u1D450/u1D460 >where/u1D461/u1D465/u1D461is the text
of the expression whereas /u1D43F/u1D45C/u1D450/u1D460is a sequence of locations where
the expression appears. Notably, expressions (e.g., expression " a.b"
instatement" a.b=4")thatEclipseJDTrefusestoextracthadbeen
excluded. We leveraged the APIs of JDT to automate the exclusion.
Second, for eachexpression /u1D452/u1D465/u1D45D/u1D456,we randomlyselected one ofits
occurrencesasthe selectedexpression andfedthisselectedexpres-
sion to the evaluated approaches (ValExtractor, Eclipse, and IDEA)
toconductextractvariablerefactoring.Iftheapproachesgenerated
diﬀerentoutputs,wemarkedtherefactoringsasatripleof incon-
sistent refactorings . Third, from the resulting triples of inconsistent
refactorings,we randomlysampled /u1D45Btriplesformanual checking.
The size of the sample (i.e., /u1D45B) guarantees an error margin of 5%
and a con/f_idence level of 95% [ 34]. We also sampled /u1D45Atriples of
consistent refactorings in the same way. Finally, three highly expe-
rienceddeveloperswithoverthreeyearsofJavaexpertisemanually
checked the sampled triples of inconsistent/consistent refactorings.
They discussed together and classi/f_ied the refactorings as one of
the followings:
•Buggy: The refactoring was incorrect because it introduced
semantic errors.
•Correct: The refactoring wasconductedcorrectly.
•Imperfect : The refactoring did not introduce any semantic
errors,but itmissedsomeextractable expressions.
4.4 RQ1: ImprovingtheState ofthePractice
The evaluation results are presented in Table 1.#Casesin Ta-
ble1speci/f_ies how many cases have been used for the evalua-
tion, i.e., how many times the proposed approach (and the baseline
approaches)havebeenappliedtoextractvariables. #Consistent
speci/f_ies how many times the evaluated approaches resulted in
identical results. #Inconsistent speci/f_ies how many times they
resultedindiﬀerent(inconsistent) refactorings.
From Table 1,we make the following observations:
•First, more than 11 thousand cases have been involved in the
evaluation. Such a large number of cases enables a thorough
evaluation ofthe approaches.Table 1:EvaluationResults
Applications #Cases #Consistent #Inconsistent
Closure 2,465 1,957 508
Jfreechart 3,831 3,292 539
Joda 510 335 175
Lang 565 388 177
Math 3,516 3,084 432
Mockito 135 118 17
Total 11,022 9,174 1,848
•Second,theevaluatedapproachesfrequentlyresultedininconsis-
tentrefactorings.Theinconsistentcasesaccountfor16.8%=1,8-
48/11,022 of the evolved cases. Such a non-trivial ratioof incon-
sistent casesmay suggest that extract variables automatically is
error-prone,whichfurthermotivatestheresearchpresentedin
this paper.
•Third, on all of the six subjection applications, the three ap-
proachesreportedinconsistentcases.
According to the process introduced in Section 4.3, we ran-
domly sampled 318 inconsistent cases and 369 consistent cases,
and requested three developers to manually check the samples.
The evaluation results suggested that all refactorings on the 369
consistentcaseswerecorrect.Themanualcheckingresultsonin-
consistent cases are presented in Table 2. The columns " #correct ",
"#imperfect " and "#buggy" present the numbers of correct, im-
perfect,andbuggyextractvariablerefactoringsconductedbythe
evaluatedapproaches,respectively.Fromthistable,wemakethe
following observations:
•Eclipse resulted in a large number of buggy extract variable
refactorings. On 243 out of the 318 inconsistent cases, Eclipse
resultedinbuggyrefactorings.Itresultedinerrorsonallofthe
evaluatedapplications.
•IDEAresultedinthelargestnumber(263)offaultyrefactoringsin
the sampled 318 inconsistent cases. IDEA and Eclipse frequently
failed on the same cases. On 233 out of the 318 cases, both IDEA
andEclipseresultedinerrors.
•ValExtractor avoided all of the bugs introduced by Eclipse or
IDEA. Itdidnot result inany faultyrefactorings.
•All of the evaluated approaches resulted in imperfect extract
variablerefactorings,i.e.,missingsomeextractableexpressions.
The major reason for such imperfect refactorings is that they
employ conservative tactics to avoid errors, and thusany poten-
tiallyunsafeexpressionswouldbe ignored.Wealsonoticethat
ValExtractorreportedmoreimperfectrefactoringsthanEclipse
andIDEAbecauseitpaysmoreattentiontosafetyandthusits
tactic ismore conservative.
We also assessed the eﬃciency of ValExtractor. On a personal
computer with 8 GB memory and Intel i7-8550U CPU, 91.6% of
the refactorings were /f_inished by ValExtractor within 2 seconds,
96.5% within5 seconds, and98.3% within 10seconds. The median
execution time for a single refactoring was 0.20 seconds, compara-
bletothat(0.13seconds)ofEclipse.Themaximalexecutiontime
(390 seconds) is substantially larger than that (1 second) of Eclipse.
ValExtractor is more time-consuming because it leverages more
complexcodeanalysistodetectpotentialerrors.Toreducethemax-
imaltime,wemaypresentamaximaltimeslot.WhenValExtractor
319ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA Xiaye Chi,HuiLiu, Guangjie Li, Weixiao Wang,YunniXia,YanjieJiang,YuxiaZhang,andWeixing Ji
Table 2:Inconsistent Refactorings
ApplicationsValExtractor Eclipse IntellijIDEA
#Correct #Imperfect #Buggy #Correct #Imperfect #Buggy #Correct #Imperfect #Buggy
Closure 83 4 0 23 1 63 14 0 73
Jfreechart 93 4 0 28 1 68 25 0 72
Joda 29 1 0 3 0 27 2 0 28
Lang 25 3 0 8 2 18 6 1 21
Math 70 2 0 8 1 63 7 0 65
Mockito 4 0 0 0 0 4 0 0 4
Total 304 14 0 70 5 243 54 1 263
Table 3:Reasons forBuggyRefactorings
ApplicationsExceptionin
InitializationChanged
ValuesSide
Eﬀect
Closure 18(23.7%) 30(39.5%) 28(36.8%)
Jfreechart 5(6.5%) 29(37.7%) 43(55.8%)
Joda 5(18.5%) 14(51.9%) 8(29.6%)
Lang 7(29.2%) 10(41.7%) 7(29.2%)
Math 9(13.8%) 33(50.8%) 23(35.4%)
Mockito 2(50.0%) 2(50.0%) 0(0.0%)
Total 46(16.8%) 118(43.2%) 109(39.9%)
1public void predict( /f_inal RealVector u)
2 throws DimensionMismatchException {
3...
4intvar_948 =u.getDimension();
5if (u != null &&
6u.getDimension() var_948 != controlMatrix.getColumnDimension()) {
7 thrownewDimensionMismatchException( u.getDimension() var_948,
8 controlMatrix.getColumnDimension());
9}
10}
Listing 6:Faulty Refactoring(ExceptionsinInitialization)
runs out of the slot, it stops searching for additional extractable
expressions, and extracts all extractable expressions at hand. Note
thatsuchastrategydoesnotincreasetheriskoffaultyrefactorings.
We conclude that extract variable refactoring is error-prone
evenwiththestate-of-the-practicerefactoringtools.ValExtractor
ismuchmore reliable thanthe widely usedEclipseandIDEA.
4.5 RQ2: ReasonsforFaulty Refactorings
According to the errors introduced by such refactorings, We col-
lectedfaultyextractvariablerefactoringsconductedbyIDEAand/or
Eclipse, resulting in a total of 273 cases, and classi/f_ied them into
threecategories.Theresultsoftheclassi/f_icationarepresentedinTa-
ble3.Onthistable,thenumbersoutsideparenthesisaretheabsolute
numbers of buggy refactorings falling into given categories. The
percentageinparenthesisequalstotheabsolutenumberdivided
by the total number of buggy refactorings on the given application.
Thecategory" exception in initialization "referstosuch
refactoringswheretheinitializationofthenewvariablesmayre-
sult in exceptions that may not be raised before the refactorings. A
typical example is presented in Listing 6. The example code comes
fromtheopen-sourceproject Math.Eclipseextractedtheexpression
"u.getDimension() "atLine6andLine7asanewvariableandinitial-
izeditatLine4.However,theinitializationmightraisenullpointer
exceptions when uequalsnull. In contrast, even if uequalsnull,
the source code before refactoring can avoid the exception because1private RuleSet getLastRuleSet () {
2intvar_656 =iRuleSets.size();
3if (iRuleSets.size() var_656 == 0) {
4 addCutover(Integer.MIN_VALUE, ... 0);
5}
6return iRuleSets.get ( iRuleSets.size() var_656−1);
7}
8public DateTimeZoneBuilderaddCutover(int year, ... , int millisOfDay){
9if ( iRuleSets.size () > 0) {
10 ...
11}
12iRuleSets.add (newRuleSet());
13return this;
14}
Listing 7:Faulty Refactoring(Changed Values)
itleveragesthecondition" u!=null"atLine5toavoidtheexecution
oftheexpression" u.getDimension() "incaseuequalsnull.ValEx-
tractoravoidedthiserrorbyextractingonlythesecondoccurrence
oftheexpression(Line7)andinitializingthenewvariablewithin
thebodyofthe ifstatement .AsshowninTable 3,16.8%ofthefaulty
extractvariablerefactoringsconductedbyEclipse/IDEAfallinto
this category.
Thesecondcategory," changed values ",referstoextractvari-
able refactorings where the expressions replaced with the same
variable have diﬀerent values although they are literally identi-
cal.Listing 7presentsareal-worldexampleconductedbyEclipse
andIdeaonproject Joda.Eclipseextractedtheexpression" iRule-
Sets.size() "atLine3and6asanewvariable var_656 andinitialized
thenewvariableatLine2.However,themethodinvocationatLine
4 would change the set iRuleSets , and thus would change the
size of the set. As a result, at Line 6, the original expression " iRule-
Sets.size() " is not equal to the value of var_656 that is initialized at
Line2.Asaresult,replacingtheexpressionwiththevariableatLine
6 as Eclipse did result in semantic errors. ValExtractor avoided this
errorbyreplacingthe/f_irstexpressionatLine3only.Theprecon-
ditions in Section 3.4.3successfully prevented ValExtractor from
extractingtheexpressionatLine6togetherwiththeselectedone
(Line3).Notably,suchkindoferrorsishardto/f_indbecausetheydo
not raise any exceptions or warning. However, as suggested in Ta-
ble3,aroundhalfthefaultyextractvariablerefactoringsconducted
by Eclipse and IDEA would result in such kind of hard-to-detect
errors. It may suggest how dangerous extract variable refactorings
could be.
Thelastcategory," side effect ",referstosuchextractvariable
refactoringswhereexecutionoftheselectedexpressionshasside
eﬀect, i.e., executing multiple times the same expression is not
semanticallyequivalenttoasingleexecutionofthesameexpression.
320AnAutomatedApproachto ExtractingLocalVariables ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA
1private String format(JSError error, boolean warning) {
2SourceExcerptProvider source = getSource() ;
3intvar_333 =error.lineNumber;
4String sourceExcerpt = source == null ? null :
5 excerpt.get (source, error.sourceName,
6 error.lineNumber var_333, excerptFormatter);
7...
8}
Listing 8:Safe RefactoringRejected by JRRT
For space limitation, we present a typical example of this category
online [28]. Note that the selected expression in this example is
amethodinvocation parseEscapeChar() thatretrievesacharfrom
/f_ieldpattern. It has side eﬀect because the method returns diﬀerent
char on each invocation: The method moves a pointer on each
invocation so that each char in patternis read once and for all.
ValExtractor identi/f_ies the side eﬀect with the validation of selected
expressions as introducedinSection 3.2.
we conclude that extract variable refactorings may result in
variouscategoriesoferrors,andValExtractor avoidedthem.
4.6 RQ3: ComparingagainstJRRT
To compare ValExtractor against JRRT concerning their perfor-
mance in precondition checking, we applied both ValExtractor and
JRRT to the 11,022 expressions that had been randomly selected in
Section4.3. Their checking results were inconsistent if and only
if one agreedtoextracttheselectedexpression whereastheother
rejected it. In total, for 2,273 out of the 11,022 expressions, they
ledto inconsistentresults. We randomly sampled 329 inconsistent
casesand368consistentcasesformanualchecking.Thesizesofthe
samplesguaranteedanerrormarginof5%andacon/f_idencelevelof
95%[34].WerequestedthesameparticipantsinSection 4.3toman-
ually validate whether the selected expressions could be extracted
(aslocalvariables)safely.Theevaluationresultssuggestedthatboth
of them were correct in all of the 368 consistent cases. However,
JRRT made incorrect decisions on all of the 329 inconsistent cases.
On 317 out of the 329 inconsistent cases, JRRT suggested not to
refactor whereas ValExtractor suggested that the refactorings were
safe. Manual checking suggested that all of the 317 refactorings
suggestedbyValExtractor(butforbiddenbyJRRT)weresafeand
correct.AtypicalexampleispresentedinListing 8.JRRTsuggested
nottorefactorbecausetherefactoringmay" unlockdependencies "
that means JRRT mistakenly assumes that the refactoring may
breakexistingdependenciesinprogramandpotentiallyresultin
errors orunpredictable behavior. However, theextract refactoring
(inListing 8) suggestedbyValExtractor issafe andcorrect.
On 12 out of the 329 inconsistent cases, JRRT suggested refac-
toring whereas ValExtractor suggested not refactoring. Manual
checking con/f_irmed that all of the 12 refactoirngs suggested by
JRRTwere faulty.A typicalexample ispresentedinListing 9.The
refactoring suggested by JRRT as shown in Listing 9may result in
null pointer exception if infoequalsnull. ValExtractor rejected the
refactoring because it realized the potential exception caused by
the refactoring.1public ImmutableList<String> getTemplateTypeNames() {
2ImmutableList<String> var_2522=info.templateTypeNames;
3if(info == null || info.templateTypeNames var_2522 == null) {
4 return ImmutableList.of () ;
5}
6return info.templateTypeNames;
7}
Listing 9:Faulty RefactoringSuggested by JRRT
5 CASE STUDY
Intheprecedingsection,weevaluatedValExtractorbyrandomly
applyingittoexpressionsinreal-world open-sourceapplications.
However,suchrandomlyselectedrefactoringscouldbediﬀerent
fromwhatdevelopersdidintheindustry.Tothisend,inthissection,
we further evaluated ValExtractor with real-world extract variable
refactorings that had been actually conducted by developers on
open-sourceapplications.
5.1 Subject Applications
Tocollectalargenumberofreal-worldextractvariablerefactorings,
we should select such applications with rich evolution histories.
To thisend, we selected subject applicationscollected by the well-
known bug repository GrowingBugs [18].GrowingBugs contains
morethanonethousandbugsautomaticallydiscoveredfromthe
evolution histories of open-source applications. In total, it involves
80well-knownopen-sourceapplicationsfromdiﬀerentdomains,
andsuchapplicationsaredevelopedandmaintainedbydiﬀerent
teams.Alloftheapplicationscontainrichevolutionhistories,which
makesthemsuitable for discoveringextract variable refactorings.
5.2 Process
To discover extract variable refactorings that have been conducted
bytheoriginaldevelopers,weapplied RefactoringMiner [46]to
the evolution histories of the selected applications. Refactoring-
Miner was selected because it represents the state of the art in
discovering refactoring activities. Notably, we ignored all refactor-
ings except for extract local variable refactorings. Besides, we also
ignoredthe following extract local variable refactorings:
•Extractvariable refactorings where thenewvariables are not
initializedontheirdeclaration.Theproposedapproach(and
thebaselineapproach)aredoomedtoinitializethenewvari-
ablesintroducedbyextractvariablerefactorings,whichmay
con/f_lictwiththe discoveredrefactorings.
•Extractvariablerefactoringswheretheselectedexpressions
are composed of constants only. In this case, ValExtractor is
alwaysequivalenttothebaselineapproaches,andthusthere
isnoneedto compare thembasedonsuch refactorings.
Foreachofthecollectedrefactorings,wetriedtore-applythe
refactoring with the evaluated approaches independently. Notably,
RefactoringMinercannottelluswhichexpressionhadbeenselected
whenthediscoveredrefactoringwasconductedmanuallybythede-
velopers.Tothisend,werandomlyselectedoneoftheextractedex-
pressions to invoke the evaluated approaches. In case a refactoring
conducted by the evaluated approaches was identical to the discov-
eredone,therefactoringwasclassi/f_iedas #correct .Otherwise,we
requestedthreedeveloperstomanuallychecktherefactoring(noted
321ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA Xiaye Chi,HuiLiu, Guangjie Li, Weixiao Wang,YunniXia,YanjieJiang,YuxiaZhang,andWeixing Ji
Table 4:Comparisonagainst Real-World Extract Variable Refactorings
ApplicationsValExtractor Eclipse IntellijIDEA
#Correct #Imperfect #Buggy #Correct #Imperfect #Buggy #Correct #Imperfect #Buggy
Codec 12 0 0 10 0 2 10 0 2
Compress 37 0 0 35 0 2 35 0 2
Jackrabbit 54 0 0 53 0 1 53 0 1
Joda 4 0 0 2 0 2 2 0 2
Johnzon 7 0 0 6 0 1 6 0 1
Jsoup 4 0 0 3 0 1 3 0 1
Math 72 0 0 71 0 1 71 0 1
Ni/f_i 32 0 0 27 0 5 27 0 5
Storm 8 0 0 7 0 1 7 0 1
Tinkerpop 23 0 0 21 0 2 21 0 2
Total 253 0 0 234 0 19 234 0 19
1public void luDecompose()throws InvalidMatrixException {
2...
3for (int row= 0; row< col; row++) {
4BigDecimal[]luRow=lu[row];
5sum =luRowlu[row][col];
6for (int i = 0; i < row; i++)
7 sum = sum.subtract( luRowlu[row][i].multiply (lu[i][col]));
8luRowlu[row][col] = sum;
9}
10...
11for (int row= col; row< nRows;row++) {
12BigDecimal[]luRow=lu[row];
13sum =lu[row][col];
14for (int i = 0; i < col; i++)
15sum = sum.subtract( luRowlu[row][i].multiply (lu[i][col]));
16luRowlu[row][col] = sum;
17...
18}
Listing 10:IncorrectGroundTruth
aspotential faulty refactoring ) against the ground truth (i.e., the
discoveredrefactoring).Themanualcheckingmayresultinthree
diﬀerent conclusions: Buggy refactorings ,imperfect refactorings , or
incorrect ground truth . In case of incorrect ground truth (generated
automatically by RefactoringMiner), the developers manually /f_ixed
the ground truth and re-evaluated the approaches with the /f_ixed
groundtruth.Intotal,wefoundand/f_ixed85incorrectgroundtruth.
Listing10is an example of incorrect ground truth. The extract
variable refactoring at Lines 4-8 is independent of that at Lines 12-
16 althoughthey are highly similar.However, RefactoringMiner
reportedthetwoindependentrefactoringsasasinglerefactoring
bymistake.
The three participants had rich experience in software devel-
opmentandsoftwarerefactoring.Theycollaboratedtogetherand
discussed to reach agreements on all of the cases. To minimize the
costofthemanualchecking,weonlycheckedthetop10applica-
tionswiththemostpotentialfaultyrefactorings(i.e.,refactorings
that were diﬀerentfrom the ground truth).
5.3 Results
Intotal,253real-worldextractvariablerefactoringswereemployed
for the evaluation whose results are presented in Table 4. From the
table,we make aseries ofobservations.
First,Eclipse(andIDEA)resultedinsemanticerrorson19outof
the 253cases, withan errorrate of 7.5%=19/253. Note that Eclipseand IDEA failed on exactly the same cases, and thus in Table 4
Columns5-7areexactlythesameasColumns8-10.Wealsoobserve
that they resultedinerrorsonallof the 10 subjectapplications.
Second, we observe that ValExtractor did not result in any se-
mantic errors. It succeeded in all of the 253 cases without missing
any extractable expressions or introducing any semantic errors. It
maysuggestthatValExtractorismuchmorereliablethanEclipse
andIDEA inextracting variables.
Finally, we observe from the table that none of the evaluated
approaches resulted in any imperfect extract variable refactorings
where some extractable expressions were missed. It is diﬀerent
from what we found in the random evaluation in Section 4where
all of the evaluated approaches resulted in dozens of imperfect
refactorings. One possible reason is that refactorings conducted by
developersintheindustrycouldbeessentiallydiﬀerentfromran-
domlyconstructedrefactorings.Anotherpossiblereasonisthatthe
numberof refactorings involved in thiscase study issubstantially
smaller than that involved in Section 4. Besides that, in practice,
developers have unit tests that may prevent faulty refactorings
from being committedto repositories.
Based on the preceding analysis, we conclude that developers
have a non-negligible possibility to introduce semantic errors in
conducting extract variable refactorings even equipped with the
state-of-the-practicerefactoringtools.Theproposedapproach,how-
ever,can successfully avoid such errors.
5.4 Threatsto Validity
A threat to external validity is that only a limited number (253)
of real-world refactorings were used for the case study. Because
building the benchmark involved intensive human intervention,
itishardtoenlargethebenchmark.Toreducethethreat,wealso
leveragedmorethantenthousandrandomlysampledrefactoring
opportunitiesinSection 4for the evaluation.
Athreattoconstructvalidityisthattherequestedmanualcheck-
ing could be inaccurate. In both the evaluation in Section 4and
the case study in Section 5, manual checking served as the ground
truth for the evaluation. However, manual checking could be inac-
curate, which might in turn result in an inaccurate measure of the
performance of the evaluated approaches. To reduce the threat, we
requested multiple participants to check the refactorings, and they
reachedagreements onallof the cases.
322AnAutomatedApproachto ExtractingLocalVariables ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA
6 DISCUSSIONS
ItremainschallengingtodeterminethesideeﬀectofAPIswhose
sourcecodeisnotavailable.Inthispaper,weonlyanalyzetheAPIs
in Java 8 standard library, resulting in a list of methods marked as
"may result in side eﬀect ".ValExtractor compares method invo-
cationsagainstthelisttoidentifywetherthemethodinvocations
have side eﬀect. However, such approach may not work for non-
Java APIs, local system classes or third-party library classes. In
future,weshouldinvestigategenericsolutionforsuchcases,and
the slicing-based approach proposed by Tsantalis and Chatzige-
orgiou[45]couldbepromising.Wealsonoticethattheproposed
approach depends on type biding provided by Eclipse, and thus
if the source code cannot be parsed by Eclipse (e.g., because of
incompleteness), itmayfail to recognizemethodinvocations.
Theproposedapproachconductsstaticanalysistoidentifypo-
tentialexceptionscausedbyextractlocalvariablerefactorings.The
featureishighlydesirablebecauseadditionalexceptionsmayresult
incrashofthesoftwaresystems.However,thecurrentimplementa-
tionof the proposedapproach covers only nullpointer exceptions
andclass cast exceptions. In future, we should cover additional
exceptions such as arithmetic exceptions.
Recommendinganameforthenewlyintroducedvariableisan
indispensablepartofextractlocalvariable refactoring.However,
theproposedapproachsimplyreusestheimplementationofEclipse
JDT. In future, we would like to improve the accuracy in name
recommendation for extractlocal variable refactorings.
7 RELATED WORK
7.1 ImprovingReliability ofRefactorings
Software refactoring, as well as other changes on complex soft-
ware applications, is often error-prone. Consequently, researchers
have proposed approaches to reduce, avoid, or detect errors intro-
duced by refactorings. For example, to improve the reliability of
generalization-relatedrefactorings,Tipetal.[ 41,42]leveragedtype
constraintstoverifythepreconditionsofrefactorings,andtodeter-
minesafeeditionsofsourcecode.Schäferetal.[ 36]andJongeet
al.[4]focusedonthereliabilityofthemostwidelyusedrefactoring,
renamingsoftwareentities.Thekeyoftheirapproachesistocreate
symbolic names that are bound to the renamed software entities
by inverting the lookup function of compilers (or by reusing the
name analysis provided by compilers), which helps avoid updating
(bymistake)referencestountouchedsoftwareentities.Researchers
have also provided static analysis-based approaches to improve
thereliabilityofothertypesofrefactorings,includingmemoriza-
tionrefactorings[ 51],mergingofduplicatedcode[ 47],asynchrony
refactorings [ 13,22], andrefactoring for parallelization[ 19].
Asagenericmechanismtoimprovethereliabilityofrefactorings,
preconditions have been widely used to prevent unsafe refactor-
ings[33].Forexample,Opdyke[ 29],oneofthebest-knownpioneers
insoftwarerefactoring,speci/f_iedpreconditionsforvarioustypesof
refactorings.Tsantalisetal.[ 44]speci/f_iedpreconditionsformove
method refactorings.Ubayashietal.[ 48]proposedrefactoringby
contract to verify refactorings based on contracts that are com-
posed of preconditions, postconditions, and invariants described
in Contract Writing Language (COW) [ 38]. Overbey et al. [ 30] pro-
posediﬀerentialpreconditioncheckingtoverifypreconditionsofrefactorings. Refactoring Browser [ 33] is one of the premiere refac-
toringtoolsthatsupportpreconditionsofrefactorings.JRRT[ 35]
is a refactoring engine for JastAddJ. It is well-known for its unique
safetychecking for software refactorings.
7.2 Detecting Faulty Refactorings
Detecting faulty refactorings is an important and practical way
to minimize the risk of software refactorings. Soares et al. [ 40]
proposed SafeRefactor thatchecksfor compilationerrorsinthe
refactoredversion/f_irstandthengeneratesunittestsforbothver-
sions. If any unit test results in con/f_licting results before and after
the refactorings, errors are reported. SafeRefactorImpact , pro-
posed by Mongiovi [ 24], improves SafeRefactor by focusing on
only such methods that are impacted by the refactorings. Soares
etal.[39]andMelinaMongiovietal.[ 23]proposedtechniquesto
identifyoverlyweak(semanticerrors)andoverlystrongconditions
(imperfect transformations)in refactoringimplementations using
SafeRefactor. They identi/f_ied a number of faulty or imperfect refac-
toringsinEclipse,NetBeansandotherrefactoringengines.Gligoric
et al. [14] proposed an approach to testing refactoring engines. Us-
ingrealprogramsasinput,theyidenti/f_iedanumberofcompilation
errorscausedbyrefactoring engines of IDEs.
Toidentifyfaultyextractvariablerefactorings,Eilertsenetal.[ 9]
proposed an assertion-based approach. It inserts assertions into
refactoredprogramstovalidatewhetherthereplacedexpressions
are equivalent to the variables (that are used to replace the expres-
sions)atthelocationwheretheexpressionsare.Ourapproachis
complementary to theirs in that we prevent unsafe extract variable
refactorings whereas they detectfaultyrefactorings.
8 CONCLUSIONSAND FUTUREWORK
Extract local variable is one of the most popular refactorings. How-
ever,manualrefactoringisbothtime-consuminganderror-prone.
To thisend,in thispaper, weproposeanovel approach ValExtrac-
tor to conduct extract local variable refactorings automatically and
safely. Our evaluation results on open-source applications suggest
that automated extract variable refactorings could be risky, and
the state-of-the-practice refactoring tools (both Eclipse and IntelliJ
IDEA) did result in a large number of faulty extract variable refac-
toringsthatintroducedsemanticerrors.Incontrast,ValExtractor
successfullyavoidedallsucherrors.OurbugreportstoEclipsecom-
munityhavebeencon/f_irmedandthepullrequestsimplementing
our approach have been approvedandmergedintoEclipse.
It is potentially fruitful to adapt the proposed approach to other
programminglanguagesbesidesJava.Itisalsopracticaltoparal-
lelize ValExtractor, especially the search algorithm in Algorithm 1
for further speedup.
9 DATA AVAILABILITY
The replication package ispubliclyavailable [ 31].
ACKNOWLEDGMENTS
The authors would like to thank the anonymous reviewers from
ESEC/FSE’2023fortheirinsightfulcommentsandconstructivesug-
gestions.ThisworkwaspartiallysupportedbytheNationalNatural
ScienceFoundationofChina (62232003 and62172037).
323ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA Xiaye Chi,HuiLiu, Guangjie Li, Weixiao Wang,YunniXia,YanjieJiang,YuxiaZhang,andWeixing Ji
REFERENCES
[1]Robert S Arnold. 1986. An introduction to software restructuring. Tutorial on
SoftwareRestructuring (1986), 1–11.
[2]Block (Eclipse JDT API Speci/f_ication). 2023. https://help.eclipse.org/topic/org.e
clipse.jdt.doc.isv/reference/api/org/eclipse/jdt/core/dom/Block.html .
[3]Brett Daniel, Danny Dig, Kely Garcia, and Darko Marinov. 2007. Automated
testingofrefactoringengines.In Proceedingsofthethe6thjointmeetingofthe
EuropeansoftwareengineeringconferenceandtheACMSIGSOFTsymposiumon
The foundations of software engineering (ESEC/FSE) . 185–194. https://doi.org/10.
1145/1287624.1287651
[4]Maartje De Jonge and Eelco Visser. 2012. A language generic solution for name
bindingpreservationinrefactorings.In ProceedingsoftheTwelfthWorkshopon
LanguageDescriptions,Tools,andApplications(LDTA) .1–8.https://doi.org/10.
1145/2427048.2427050
[5] Defects4J – version 1.1.0. 2023. https://github.com/rjust/defects4j/tree/v1.1.0 .
[6]B.DuBois,S.Demeyer,andJ.Verelst.2004. Refactoring-improvingcoupling
andcohesionofexistingcode.In 11thWorkingConferenceonReverseEngineering
(WCRE). 144–151. https://doi.org/10.1109/WCRE.2004.33
[7] Eclipse. 2023. http://www.eclipse.org/ .
[8] EclipseJavadevelopmenttools (JDT).2023. https://www.eclipse.org/jdt/ .
[9]AnnaMariaEilertsen,AnyaHeleneBagge,andVolkerStolz.2016. Saferrefactor-
ings.InInternationalSymposiumonLeveragingApplicationsofFormalMethods
(ISoLA). Springer, 517–531. https://doi.org/978-3-319-47166-2_36
[10]Extract/Introduce variable. 2023. https://www.jetbrains.com/help/idea/extract-
variable.html .
[11] Martin Fowler. 2018. Refactoring . AddisonWesley.
[12]FullListofPreconditions.2023. https://github.com/liuhuigmail/ValExtractor/
#Preconditions .
[13]KeheliyaGallaba,QuinnHanam,AliMesbah,andIvanBeschastnikh.2017. Refac-
toringAsynchronyinJavaScript.In 2017IEEEInternationalConferenceonSoftware
MaintenanceandEvolution(ICSME) .353–363. https://doi.org/10.1109/ICSME.
2017.83
[14]Milos Gligoric, Farnaz Behrang, Yilong Li, Jeﬀrey Overbey, Munawar Ha/f_iz, and
Darko Marinov. 2013. Systematic testing of refactoring engines on real software
projects. In ECOOP 2013 - Object-Oriented Programming - 27th European Confer-
ence,Montpellier,France,July1-5,2013.Proceedings(LectureNotesinComputerSci-
ence,Vol.7920) .Springer,629–653. https://doi.org/10.1007/978-3-642-39038-8_26
[15]Yaroslav Golubev, Zarina Kurbatova, Eman Abdullah AlOmar, Timofey Bryksin,
andMohamedWiemMkaouer.2021. OneThousandandOneStories:ALarge-
Scale Survey of Software Refactoring. In Proceedings of the 29th ACM Joint
Meeting on European Software Engineering Conference and Symposium on the
Foundations of Software Engineering (Athens, Greece) (ESEC/FSE 2021) . Asso-
ciation for Computing Machinery, New York, NY, USA, 1303–1313. https:
//doi.org/10.1145/3468264.3473924
[16] IntelliJ IDEA. 2023. http://www.jetbrains.com/idea/ .
[17]ITypeBinding (Eclipse JDT API Speci/f_ication). 2023. https://help.eclipse.org/top
ic/org.eclipse.jdt.doc.isv/reference/api/org/eclipse/jdt/core/dom/ITypeBinding
.html.
[18]Yanjie Jiang, Hui Liu, Xiaoqing Luo, Zhihao Zhu, Xiaye Chi, Nan Niu, Yuxia
Zhang, Yamin Hu, Pan Bian, and Lu Zhang. 2023. BugBuilder: An Automated
Approachto BuildingBug Repository. IEEETransactionsonSoftwareEngineering
(2023), 1–1. https://doi.org/10.1109/TSE.2022.3177713
[19]Raﬃ Khatchadourian, Yiming Tang, Mehdi Bagherzadeh, and Syed Ahmed. 2019.
Safe Automated Refactoring for Intelligent Parallelization of Java 8 Streams.
In2019IEEE/ACM41stInternationalConferenceonSoftwareEngineering(ICSE) .
619–630. https://doi.org/10.1109/ICSE.2019.00072
[20]Miryung Kim, Thomas Zimmermann, and Nachiappan Nagappan. 2014. An
Empirical Study of Refactoring Challenges and Bene/f_its at Microsoft. IEEE
TransactionsonSoftwareEngineering 40,7(2014),633–649. https://doi.org/10.
1109/TSE.2014.2318734
[21]Raula Gaikovina Kula, Ali Ouni, Daniel M German, and Katsuro Inoue. 2018.
An empirical study on the impact of refactoring activities on evolving client-
used APIs. Information and Software Technology 93 (2018), 186–199. https:
//doi.org/10.1016/j.infsof.2017.09.007
[22]Yu Lin, Semih Okur, and Danny Dig. 2015. Study and refactoring of Android
asynchronous programming (t). In 2015 30th IEEE/ACM International Conference
on Automated Software Engineering (ASE) . IEEE, 224–235. https://doi.org/10.
1109/ASE.2015.50
[23]MelinaMongiovi,RohitGheyi,GustavoSoares,MárcioRibeiro,PauloBorba,and
LeopoldoTeixeira.2017. Detectingoverlystrongpreconditionsinrefactoring
engines. IEEE Transactions on Software Engineering 44, 5 (2017), 429–452.
https://doi.org/10.1109/TSE.2017.2693982
[24]Melina Mongiovi, Rohit Gheyi, Gustavo Soares, Leopoldo Teixeira, and Paulo
Borba. 2014. Making refactoring safer through impact analysis. Science of
Computer Programming 93 (2014), 39–64. https://doi.org/10.1016/j.scico.2013.11.
001
[25]EmersonMurphy-Hill,ChrisParnin,andAndrewPBlack.2011. Howwerefactor,
and how we know it. IEEE Transactions on Software Engineering 38, 1 (2011),5–18.https://doi.org/10.1109/TSE.2011.41
[26]Stas Negara, Nicholas Chen, Mohsen Vakilian, Ralph E Johnson, and Danny Dig.
2013. A comparative study of manual and automated refactorings. In ECOOP
2013–Object-OrientedProgramming:27thEuropeanConference,Montpellier,France,
July 1-5,2013. Proceedings 27 . Springer, 552–576. https://doi.org/10.1007/978-3-
642-39038-8_23
[27] NetBeans.2023. http://netbeans.org/ .
[28]Online Safe EﬀectExample and Explanation. 2023. https://github.com/liuhuig
mail/ValExtractor/blob/main/Example.md .
[29]WilliamFOpdyke.1992. Refactoringobject-orientedframeworks . Universityof
Illinois at Urbana-Champaign.
[30]JeﬀreyLOverbeyandRalphEJohnson.2011. Diﬀerentialpreconditionchecking:
A lightweight, reusable analysis for refactoring tools. In 2011 26th IEEE/ACM
International Conference on Automated Software Engineering (ASE 2011) . IEEE,
303–312. https://doi.org/10.1109/ASE.2011.6100067
[31] Replication Package.2023. https://doi.org/10.5281/zenodo.8276904
[32] ReSharper.2023. https://www.jetbrains.com/resharper/ .
[33]Don Roberts, John Brant, and Ralph Johnson. 1997. A refactoring tool for
Smalltalk. Theory and Practice of Object systems 3, 4 (1997), 253–263.
https://doi.org/10.1002/(SICI)1096-9942(1997)3:4<253::AID-TAPO3>3.0.CO;2-T
[34] Sample Size Calculator.2023. https://www.surveysystem.com/sscalc.htm/ .
[35]MaxSchäferandOegedeMoor.2010. Specifyingandimplementingrefactorings.
InProceedingsofthe25thAnnualACMSIGPLANConferenceonObject-Oriented
Programming, Systems, Languages, and Applications, OOPSLA 2010, October 17-21,
2010, Reno/Tahoe, Nevada, USA . ACM, 286–301. https://doi.org/10.1145/1869459.
1869485
[36]MaxSchäfer,TorbjörnEkman,andOegeDeMoor.2008. Soundandextensible
renaming for Java. In Proceedings of the 23rd ACM SIGPLAN conference on Object-
oriented programming systemslanguagesand applications (OOPSLA) . 277–294.
https://doi.org/10.1145/1449764.1449787
[37]EmadShihab,AhmedEHassan,BramAdams,andZhenMingJiang.2012. An
industrial study on the risk of software changes. In Proceedings of the ACM
SIGSOFT20thInternationalSymposiumontheFoundationsofSoftwareEngineering
(FSE). 1–11.https://doi.org/10.1145/2393596.2393670
[38]Suguru Shinotsuka, Naoyasu Ubayashi, Hideaki Shinomi, and Tetsuo Tamai.
2006. An extensible contract veri/f_ier for AspectJ. In Proceedings of the 2nd Asian
Workshop on Aspect-Oriented Software Development (AOAsia 2)(Workshop at ASE
2006). 35–40.
[39]GustavoSoares,RohitGheyi,andTiagoMassoni.2012. Automatedbehavioral
testingofrefactoringengines. IEEETransactionsonSoftwareEngineering 39,2
(2012), 147–162. https://doi.org/10.1109/TSE.2012.19
[40]Gustavo Soares, Rohit Gheyi, Dalton Serey, and Tiago Massoni. 2010. Making
Program Refactoring Safer. IEEE Software 27, 4 (2010), 52–57. https://doi.org/10.
1109/MS.2010.63
[41]FrankTip,RobertMFuhrer,AdamKieżun,MichaelDErnst,IttaiBalaban,and
Bjorn De Sutter. 2011. Refactoring using type constraints. ACM Transactions on
Programming Languages and Systems 33, 3 (2011), 1–47. https://doi.org/10.1007/
978-3-540-74061-2_1
[42]Frank Tip, Adam Kiezun, and Dirk Bäumer. 2003. Refactoring for generalization
using type constraints. ACM SIGPLAN Notices 38, 11 (2003), 13–26. https:
//doi.org/10.1145/949305.949308
[43]NikolaosTsantalis,TheodorosChaikalis,andAlexanderChatzigeorgiou.2008.
JDeodorant: Identi/f_ication and removal of type-checking bad smells. In 2008 12th
European conference on software maintenance and reengineering (CSMR) . IEEE,
329–331. https://doi.org/10.1109/CSMR.2008.4493342
[44]NikolaosTsantalis andAlexanderChatzigeorgiou.2009. Identi/f_icationofmove
method refactoring opportunities. IEEE Transactions on Software Engineering 35,
3 (2009), 347–367. https://doi.org/10.1109/TSE.2009.1
[45]Nikolaos Tsantalis and Alexander Chatzigeorgiou. 2011. Identi/f_ication of extract
method refactoring opportunities for the decomposition of methods. Journal of
SystemsandSoftware 84,10(2011),1757–1782. https://doi.org/10.1016/j.jss.2011.
05.016
[46]Nikolaos Tsantalis, Matin Mansouri, Laleh Eshkevari, Davood Mazinanian, and
Danny Dig. 2018. Accurate and eﬃcient refactoring detection in commit history.
In2018IEEE/ACM40thInternationalConferenceonSoftwareEngineering(ICSE) .
IEEE,483–494. https://doi.org/10.1145/3180155.3180206
[47]NikolaosTsantalis,DavoodMazinanian,andGiriPanamoottilKrishnan.2015.
Assessingtherefactorabilityofsoftwareclones. IEEETransactionsonSoftware
Engineering 41, 11 (2015), 1055–1090. https://doi.org/10.1109/TSE.2015.2448531
[48]Naoyasu Ubayashi, Jinji Piao, Suguru Shinotsuka, and Tetsuo Tamai. 2008.
Contract-based veri/f_ication for aspect-oriented refactoring. In 2008 1st Inter-
national Conference on Software Testing, Veri/f_ication, and Validation (ICST) . IEEE,
180–189. https://doi.org/10.1109/ICST.2008.36
[49] Visual Studio. 2023. https://visualstudio.microsoft.com/ .
[50]Michael Wahler, Uwe Drofenik, and Will Snipes.2016. Improving Code Main-
tainability: A Case Study on the Impact of Refactoring. In 2016 IEEE Interna-
tional Conference on Software Maintenance and Evolution (ICSME) . 493–501.
324AnAutomatedApproachto ExtractingLocalVariables ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA
https://doi.org/10.1109/ICSME.2016.52
[51]Jiachen Yang, Keisuke Hotta, Yoshiki Higo, and Shinji Kusumoto. 2015. Towards
purity-guidedrefactoringinJava.In 2015IEEEInternationalConferenceonSoft-
wareMaintenanceandEvolution(ICSME) .521–525. https://doi.org/10.1109/ICSM.2015.7332506
Received 2023-03-02; accepted 2023-07-27
325