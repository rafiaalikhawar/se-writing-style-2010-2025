Detecting Atomicity Violations in Interrupt-Driven Programs via
Interruption Points Selecting and Delayed ISR-Triggering
Bin Yu
School of Computer Science and
Technology, Xidian University
Xiâ€™an, P.R. ChinaCong Tian
School of Computer Science and
Technology, Xidian University
Xiâ€™an, P.R. ChinaHengrui Xing
School of Computer Science and
Technology, Xidian University
Xiâ€™an, P.R. China
Zuchao Yang
School of Computer Science and
Technology, Xidian University
Xiâ€™an, P.R. ChinaJie Su
School of Computer Science and
Technology, Xidian University
Xiâ€™an, P.R. ChinaXu Lu
School of Computer Science and
Technology, Xidian University
Xiâ€™an, P.R. China
Jiyu Yang
School of Computer Science and
Technology, Xidian University
Xiâ€™an, P.R. ChinaLiang Zhao
School of Computer Science and
Technology, Xidian University
Xiâ€™an, P.R. ChinaXiaofeng Li
Beijing Institute of Control
Engineering
Beijing, P.R. China
Zhenhua Duan
School of Computer Science and
Technology, Xidian University
Xiâ€™an, P.R. China
ABSTRACT
Interrupt-driven programs have been widely used in safety-critical
areas such as aerospace and embedded systems. However, uncertain
interleaving execution of interrupt service routines (ISRs) usually
causes concurrency bugs. Specifically, when one or more ISRs at-
tempt to preempt a sequence of instructions which are expected
to be atomic, a kind of concurrency bugs namely atomicity vio-
lation may occur, and it is challenging to find this kind of bugs
precisely and efficiently. In this paper, we propose a static approach
for detecting atomicity violations in interrupt-driven programs.
First, the program model is constructed with interruption points
being selected to determine the possibly influenced ISRs. After that,
reachability computation is conducted to build up a whole abstract
reachability tree, and a delayed ISR-triggering strategy is employed
to reduce the state space. Meanwhile, unserializable interleaving
patterns are recognized to achieve the goal of atomicity violation
detection. The approach has been implemented as a configurable
tool namely CPA4AV. Extensive experiments show that CPA4AV is
much more precise than the relative tools available with little extra
time overhead. In addition, more complex situations can be dealt
with CPA4AV.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior specific permission
and/or a fee. Request permissions from permissions@acm.org.
ESEC/FSE â€™23, December 3â€“9, 2023, San Francisco, CA, USA
Â©2023 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ACM ISBN 979-8-4007-0327-0/23/12. . . $15.00
https://doi.org/10.1145/3611643.3616276CCS CONCEPTS
â€¢Theory of computation â†’Verification by model checking .
KEYWORDS
interrupt-driven programs, interrupt service routines, atomicity
violation, static analysis, concurrency bugs
ACM Reference Format:
Bin Yu, Cong Tian, Hengrui Xing, Zuchao Yang, Jie Su, Xu Lu, Jiyu Yang,
Liang Zhao, Xiaofeng Li, and Zhenhua Duan. 2023. Detecting Atomicity
Violations in Interrupt-Driven Programs via Interruption Points Selecting
and Delayed ISR-Triggering. In Proceedings of the 31st ACM Joint European
Software Engineering Conference and Symposium on the Foundations of Soft-
ware Engineering (ESEC/FSE â€™23), December 3â€“9, 2023, San Francisco, CA, USA.
ACM, New York, NY, USA, 12 pages. https://doi.org/10.1145/3611643.3616276
1 INTRODUCTION
Interrupt-driven programs are usually programmed with interrupt
service routines (ISRs) to interact with hardware and respond to
external stimuli in a timely manner [ 28]. This kind of software is
widely used in safety-critical areas, such as automotive electronics
and aerospace [ 38]. Nevertheless, since ISRs can preempt normal
executions at any time non-deterministically, it is quite difficult for
software developers to understand interrupt-driven programs com-
pletely [ 22]. Uncertain interleaving execution of ISRs is regarded
as a kind of concurrency bugs, possibly leading to serious safety
problems such as logic defects or even system crash. Although
interrupt-driven programs are usually tested before application,
ISR-related concurrency bugs are still one of the most challenging
software vulnerabilities since they are quite sensitive to execution
interleavings [20, 23].
1153
ESEC/FSE â€™23, December 3â€“9, 2023, San Francisco, CA, USA Yu, Tian, Xing, Yang, Su, Lu, Yang, Zhao, Li, Duan
As a kind of hazardous concurrency bugs in interrupt-driven
programs, atomicity violations occur if one or more ISRs attempt to
preempt a sequence of instructions which are ideally expected to
be atomic [ 25]. As a matter of fact, in an interrupt-driven program,
a sequence of instructions which is atomic could be broken by
an ISR with higher priority. For instance, for an atomic sequence
with two consecutive read accesses to a same variable in the main
task or an ISR (either a main task or an ISR is regarded as a task),
the variable could be written by another ISR with higher priority
between the two read accesses. That is, the atomic assumption of
this sequence is broken, which leads to a concurrency bug namely
atomicity violation [12].
Although several approaches [ 1,7,9,11,14,25,34,35] have been
proposed to detect atomicity violations in multi-threaded programs,
they cannot be directly applied to interrupt-driven programs due
to the different synchronization mechanisms and preemption rela-
tionships [ 22]. Currently, state-of-the-art approaches for detecting
atomicity violations in interrupt-driven programs include bounded
model checking and staged static analysis. As a representative of
bounded model checking, Rchecker [ 10,12] constructs local control-
flow graphs of programs to perform flow-sensitive analysis on top
of the model checker CBMC [ 21] to detect potential atomicity vio-
lations. Whereas, false positives are inevitable due to the nature of
path constraint solving in bounded model checking. Besides, since
no effective strategy is considered to reduce the explored state space
during the detection, it is challenging in scalability to deal with real-
world interrupt-driven programs. In order to avoid the explicit state
exploration, a static analysis approach is proposed in intAtom [ 22]
which employs a staged design for atomicity violation detection
by first identifying all potential violations and then filtering out
infeasible candidates. However, precise reachability analysis is still
lacking for complicated situations caused by uncertain interleaving
execution of the main task and ISRs with different priorities.
In this paper, we propose a static approach to precisely detect
atomicity violations in interrupt-driven C programs. In our ap-
proach, control-flow graphs (CFGs) of the main task and ISRs are
constructed. On this basis, the program locations which may be
influenced by an ISR are selected as interruption points for trigger-
ing ISRs. Further, by unwinding the obtained CFGs and performing
reachability computation, a whole abstract reachability tree (ART)
is built up, with the infeasible paths being pruned automatically.
Throughout this process, when an interruption point is reached,
the control-flows of the enabled ISRs are not introduced at once
as in the model checking approaches available [ 10,12]. Instead, a
delayed-preemption strategy is proposed to allow an enabled ISR
to preempt as late as possible, so that the size of the constructed
ART is reduced. Besides, the initial and final locations of a task are
also allowed to be preempted. This is to take into account mutual
influence of different tasks and potential atomicity violations occur-
ring in two nested ISRs, which are not considered in the existing
static analysis approaches [ 22]. To achieve the above goal, when
exploring an ART, a data access table is maintained dynamically to
record the operation states of shared variables. Meanwhile, specific
access sequences are recognized to match the patterns of atomicity
violations on-the-fly.
We have implemented the approach as a tool named CPA4AV
(Configurable Program Analysis for Atomicity Violation) uponthe open-source model checker CPAchecker [ 3]. Experimental ex-
periments on benchmark Racebench 2.1 show that CPA4AV is
much more precise than the relative tools available with little extra
time overhead. Further experiments on the extended version of
Racebench 2.1 show that CPA4AV can deal with more complex
situations. In addition, experiments on the three packages in the
concurrency track of SV-COMP benchmark suite indicate that the
proposed interruption points selecting and delayed ISR-triggering
strategies can reduce the explored state space and detection time by
93.4% and 87.0%, respectively. Finally, the empirical evaluation on
18 real-world embedded programs shows the scalability of CPA4AV.
The main contributions of the paper are summarized as follows:
(1) A model checking approach based on interruption points
selecting and delayed ISR-triggering strategies is proposed to detect
atomicity violations in interrupt-driven programs precisely and
efficiently.
(2) An atomicity violation detection tool namely CPA4AV is
developed for interrupt-driven C programs.
(3) Extensive experiments show that CPA4AV is much more pre-
cise than the relative tools available with little extra time overhead.
In addition, more complex situations can be dealt with CPA4AV.
The remainder of the paper is organized as follows. Section 2
gives the preliminaries and Section 3 presents a motivating example.
The proposed detecting approach is described in Section 4 and
configurable strategies to increase the precision are addressed in
Section 5. Section 6 presents the implementation and evaluation.
Section 7 discusses the soundness, completeness and limitations of
our approach, and Section 8 reviews the related work. Finally, the
conclusion is drawn in Section 9 with a discussion of future work.
2 PRELIMINARIES
This section briefly presents the preliminaries and useful notations
involved in this paper.
2.1 Interrupt-Driven Programs
As an essential design primitive for embedded softwares which
interact closely with hardware, interrupts are common in most
computing platforms such as low-power mobile systems and safety-
critical embedded softwares. The interrupt mechanism enables
these platforms to timely respond to outside stimuli in a power-
efficient way [ 27,28]. A program is regarded as interrupt-driven
if most of the key functions are initiated or processed through
interrupts.
An interrupt-driven program can be formally defined with a main
task and a finite number of ISRs that communicate by performing
operations on shared variables: ğ‘ƒ=Mainâˆ¥ISR. Here, Main is
the main task, and ISR=isr1âˆ¥...âˆ¥isrğ‘›represents the ISRs. For
simplicity, we call Main and all the ISRs in a program ğ‘ƒas tasks,
denoted by Task(ğ‘ƒ)={Main,isr1,...,isrğ‘›}. Note that, the subscript
ofğ‘–ğ‘ ğ‘Ÿğ‘–indicates the priority number, with a larger priority number
indicating a higher priority. For convenience, we use the function
Pri(Â·)to return the priority number. Note that Pri(ğ‘€ğ‘ğ‘–ğ‘›)is defined
to be zero (i.e., the lowest priority).
In the aspect of the preemption relationship, ISRs are allowed
to preempt the main task, and one ISR with higher priority is able
to preempt another ISR with lower priority, but not vice versa.
1154Detecting Atomicity Violations in Interrupt-Driven Programs via Interruption ... ESEC/FSE â€™23, December 3â€“9, 2023, San Francisco, CA, USA
That is, the preemption relationship between ISRs is asymmetric in
interrupt-driven programs. It should also be noted that, different
from the execution of a thread in multi-threaded programs, an ISR
cannot be blocked once it begins to execute in interrupt-driven pro-
grams. Besides, an ISR with lower priority will be suspended until
the ISRs with higher priority are completed, which is considered as
interrupt nesting.
2.2 Atomicity Violation
In interrupt-driven programs, programmers often assume that some
statements are atomic during the design process [ 10,25]. However,
in the actual execution environment, this assumption cannot be
guaranteed if these statements are interrupted in an unexpected
way, resulting in the occurrence of unintended program behaviors.
Two local reads expect
to get the same valueA local read expects to
get the result of a localwriteTemporary results between
local writes are notaccessed by other interruptsThe local write relies on
a value from thepreceding local readPattern:(R,W,R) Pattern:(W,W,R) Pattern:(R,W,W) Pattern:(W,R,W)
The interleaving writemakes the two readshave different valuesThe local read does not
get the local result itexpectsThe interrupt write
breaks the preconditionof the local writeA temporary result, which
may be incomplete, is readby an interruptPattern
Expectation
Problemâ€¦a1:R(x) a3:R(x)
a2:W(x)â€¦a1:W(x) a3:R(x)
a2:W(x)â€¦a1:R(x) a3:W(x)
a2:W(x)â€¦a1:W(x) a3:W(x)
a2:R(x)
Fig.Â 1
Figure 1: Four unserializable interleaving patterns.
A sequence of statements is referred to as an atomicity if the val-
ues of variables in a concurrent execution have no difference from
those in a serialized execution. An atomicity violation is triggered
when an unserializable interleaving pattern occurs [ 25]. Formally,
an unserializable interleaving pattern is a triple (ğ‘1,ğ‘2,ğ‘3), where
each ofğ‘1,ğ‘2andğ‘3âˆˆ{ğ‘…,ğ‘Š}(ğ‘…/ğ‘Šdenotes the read/write access
to a shared variable). In addition, ğ‘1andğ‘3are two consecutive
accesses in a low-priority task ğ‘ƒğ‘–âˆˆTask(ğ‘ƒ), andğ‘2is from an ISR
ğ‘ƒğ‘—âˆˆTask(ğ‘ƒ)\{Main,ğ‘ƒğ‘–}with higher priority, i.e., ğ‘—>ğ‘–. Unserial-
izable interleaving patterns can be summarized into four types as
is shown in Fig. 1:
â€¢Pattern:(R,W,R) : Two local reads ğ‘1andğ‘3expect to get the
same value, while the write ğ‘2makes the two reads have different
values.
â€¢Pattern:(W,W,R) :ğ‘3is expected to read the assignment result
ofğ‘1. When the variable is modified by ğ‘2,ğ‘3reads an unintended
value written by ğ‘2.
â€¢Pattern:(R,W,W) :ğ‘3is a write access along a branch with ğ‘1
being the branch condition. The write ğ‘2may make the pre-
condition of ğ‘3unsatisfied.
â€¢Pattern:(W,R,W) : The result between two writes ğ‘1andğ‘3is
possibly incomplete and not expected to be accessed, while ğ‘2
just reads the temporary result.
We refer to the set of these four types of unserializable interleaving
patterns as Patterns . Inspired by the work of [ 33] which presents
the notion of â€œunit of workâ€, atomicity can be confined within the
boundary of such units of work. Besides, the empirical research
carried out in [ 22] for interrupt-driven programs shows that two
consecutive accesses to a shared variable expected to be atomic
usually occur in a same function. With this basis, the atomicity of
ğ‘1andğ‘3is confined in the same function in this paper.2.3 Control-Flow Graph and Abstract
Reachability Tree
For an interrupt program ğ‘ƒ=Mainâˆ¥ISRwith ISR=isr1âˆ¥...âˆ¥
isrğ‘›, the control-flow graph (CFG)ğºğ‘ƒ=(ğ¿ğ‘ƒ,ğ‘™0ğ‘ƒ,ğ‘‡ğ‘ƒ)ofğ‘ƒis the
union of all the sub-CFGs of the tasks in ğ‘ƒ, i.e.,ğºğ‘€ğ‘ğ‘–ğ‘›âˆªğºğ‘–ğ‘ ğ‘Ÿ 1...âˆª
ğºğ‘–ğ‘ ğ‘Ÿğ‘›. Note that, the sub-CFG for each task ğ‘ƒğ‘–is also a triple GPi=
(ğ¿ğ‘ƒğ‘–,ğ‘™0ğ‘ƒğ‘–,ğ‘‡ğ‘ƒğ‘–), withğ¿ğ‘ƒğ‘–denoting the set of all locations, ğ‘™0ğ‘ƒğ‘–the
initial location, and ğ‘‡ğ‘ƒğ‘–the transitions in ğ‘ƒğ‘–.
By unwinding a CFG ğºğ‘ƒ, an abstract reachability tree (ART)
can be obtained for reachability computation. Formally, an ART
ğ´ğ‘ƒ=(ğ‘†,ğ¸)consists of a set ğ‘†of abstract states and a set ğ¸of edges.
Each stateğ‘ âˆˆğ‘†is a tripleğ‘ =(ğ‘™ğ‘ ,ğ‘ğ‘ ,ğ‘ğ‘ ), whereğ‘™ğ‘ âˆˆğ¿ğ‘ƒrepresents
the current location, ğ‘ğ‘ is the call stack that models a sequence of
return addresses, and ğ‘ğ‘ is a first-order formula that confines the
reachable region of the program variables. Each edge ğ‘’âˆˆğ¸is also
a tripleğ‘’=(ğ‘ ,ğ‘¡,ğ‘ â€²), whereğ‘ andğ‘ â€²are abstract states in ğ‘†, and
ğ‘¡âˆˆğ‘‡ğ‘ƒis a transition. We use ğ‘¡ğ‘“to represent the encoded formula
according to the operation of the transition ğ‘¡.
When exploring an ART ğ´ğ‘ƒ, the reachability of the successor
stateğ‘ â€²of an edgeğ‘’=(ğ‘ ,ğ‘¡,ğ‘ â€²)can be determined according to
the reachable region ğ‘ğ‘ of the precursor state ğ‘ . Specifically, the
successorğ‘ â€²is unreachable if ğ‘ğ‘ Ì¸|=ğ‘¡ğ‘“(i.e.,ğ‘ğ‘ does not model ğ‘¡ğ‘“);
otherwise,ğ‘ â€²is reachable, and the reachable region ğ‘ğ‘ â€²is updated
as follows:
ğ‘ğ‘ â€²=ğ‘ğ‘ âˆ§ğ‘¡ğ‘“ ift=(l,cond,lâ€²)
(âˆƒğ‘£:ğ‘ğ‘ )âˆ§ğ‘¡ğ‘“ift=(l,v:=exp,lâ€²)
Here, cond represents a conditional branch, and v:=expan assign-
ment operation. We point out that, âˆƒğ‘£:ğ‘ğ‘ removes the variable
ğ‘£fromğ‘ğ‘ , andğ‘¡ğ‘“re-evaluates ğ‘£. Intuitively, for an assignment
operation, the reachable region ğ‘ğ‘ â€²is obtained by replacing the
assignment expression of variable ğ‘£inğ‘ğ‘ .
3 MOTIVATING EXAMPLE
In this section, we use an example program Exa.c shown in Fig. 2
to illustrate atomicity violations in interrupt-driven programs intu-
itively. This example is also used throughout the paper to illustrate
our approach. In this program, an atomicity violation is caused
by nested ISRs. This program first initializes two shared variables
ğ‘¦andğ‘§to be 0. In the main task, the local variables ğ‘šandğ‘›are
assigned as 1. The ISR isr_2is disabled by the main task and enabled
by the ISR isr_1. The priority of isr_2is higher than that of isr_1,
and the main task has the lowest priority.
ğ’Šğ’ğ’• ğ’š,ğ’›àµŒğŸğ’ğŸ
ğ’ğŸ
ğ’…ğ’Šğ’”ğ’‚ğ’ƒğ’ğ’† _ğ’Šğ’”ğ’“áˆºğŸáˆ»
ğ’ğŸ
ğ’Šğ’ğ’• ğ’‘,ğ’’,ğ’àµŒğ’“ ğ’‚ ğ’ ğ’… áˆº áˆ» ,ğ’àµŒğ’“ ğ’‚ ğ’ ğ’… áˆº áˆ»
ğ’ğŸ‘
ğ’ğŸ’
áˆ¾ğ’àµ…ğ’ àµ ğ’šáˆ¿ğ’ğŸ“
ğ’ğŸ”ğ’‘àµŒğ’
ğ’ğŸğŸ
ğ’ğŸ—ğ’’àµŒğ’áˆ¾!áˆºğ’àµ…ğ’ àµ ğ’šáˆ»áˆ¿
ğ’ğŸ• ğ’ğŸ–ğ’”ğŸ
ğ’”ğŸ
ğ’”ğŸ
ğ’”ğŸ‘
ğ’”ğŸ’
ğ’”ğŸ“ğ’”ğŸ—
ğ’”ğŸğŸ
ğ’”ğŸğŸğ’”ğŸğŸ‘ğ’”ğŸğŸ“
ğ’Šğ’”ğ’“_ğŸ
ğ’”ğŸ–ğ’ğŸğŸ‘
ğ’ğŸ—ğ’”ğŸğŸ’int y,Â z=Â 0;Â 
voidÂ main ()Â {
disable_isr (2);Â 
int p,Â m=Â 1,n=Â 1;Â 
if(m +Â n>Â y)Â 
p=Â m;Â 
if(m +Â n<Â y)Â 
p=Â n;Â 
}Â void isr_1 ()Â {Â 
y=Â 0;Â 
z=Â 1;Â 
enable_isr (2);Â 
}Â 
void isr_2 ()Â {Â 
if(z > 0)Â {Â 
y=Â 11;Â 
z=Â 0;Â 
}Â 
}1
2345678910
11
12
1314
15
1617
18
1920
ğ’ğŸ”ğ’”ğŸ”ğ’Šğ’”ğ’“_ğŸ ğ’“ğ’†ğ’•ğ’–ğ’“ğ’
ğ’ğŸ”ğ’ğŸ”
ğ’ğŸğŸ
ğ’ğŸ—ğ’’àµŒğ’ğ’ğŸ• ğ’ğŸ–ğ’”ğŸ“ğ’”ğŸ—
ğ’”ğŸğŸ
ğ’”ğŸğŸğ’”ğŸğŸ‘ğ’Šğ’”ğ’“_ğŸ
ğ’ğŸ—ğ’”ğŸğŸ’ğ’”ğŸ–ğ’ğŸğŸ‘ğ’ğŸ”ğ’”ğŸ”ğ’Šğ’”ğ’“_ğŸ ğ’“ğ’†ğ’•ğ’–ğ’“ğ’
ğ’ğŸ”áˆ¾ğ’àµ…ğ’ àµ ğ’šáˆ¿ áˆ¾!áˆºğ’àµ…ğ’ àµ ğ’šáˆ»áˆ¿
Figure 2: Program Exa.c : one atomicity violation caused by
two nested ISRs.
Considering the statements in Lines 2-4 of the main task, their
execution will not be impacted by the preemption of ğ‘–ğ‘ ğ‘Ÿ_1orğ‘–ğ‘ ğ‘Ÿ_2,
since these statements have no operations on any shared variables.
Then, the condition statement â€˜ ğ‘š+ğ‘›>ğ‘¦â€™ in Line 5 is satisfied.
1155ESEC/FSE â€™23, December 3â€“9, 2023, San Francisco, CA, USA Yu, Tian, Xing, Yang, Su, Lu, Yang, Zhao, Li, Duan
Source
CodeART
(y: R#5, W#17, R#7)
â€¦
ReportCFG
âœ“
âœ“
âœ“Pattern
DIT
Reachability 
Computing
ART ConstructingDelayed 
ISR-Triggering UIPM
Data Access Table 
MaintainingDynamic Pattern 
Matching
Atomicity Violation
DetectingIPS
CFG 
Constructing
Interruption Point
SelectingInterruption Points Selecting Delayed ISR-Trigge ring Unserializable Interleaving Patterns Matching
Figure 3: Framework for detecting atomicity violations of interrupt-driven programs.
However, in the case that an ISR changes the value of the variable
ğ‘¦and preempts between Lines 5 and 7, the conflicting condition
â€˜ğ‘š+ğ‘›<ğ‘¦â€™ in Line 7 can also be satisfied. Besides, it should be noted
thatğ‘–ğ‘ ğ‘Ÿ_1in this example does not change the value of ğ‘¦, while
ğ‘–ğ‘ ğ‘Ÿ_2does. Therefore, only the preemption of ğ‘–ğ‘ ğ‘Ÿ_2can make the
conditions in Lines 5 and 7 both satisfied. Since ğ‘–ğ‘ ğ‘Ÿ_2is disabled
in the main task (by disable _ğ‘–ğ‘ ğ‘Ÿ(2)in Line 3) and only enabled in
ğ‘–ğ‘ ğ‘Ÿ_1(byenable _ğ‘–ğ‘ ğ‘Ÿ(2)in Line 13), this example refers to the nested
execution of two ISRs.
For the shared variable ğ‘¦, the consecutive accesses in Lines 5
and 7 are considered to be atomic and the values at these two
locations are expected to be the same. However, when the main
task is preempted by ğ‘–ğ‘ ğ‘Ÿ_1and the latter is further preempted by
ğ‘–ğ‘ ğ‘Ÿ_2, this expectation is violated. This is an atomicity violation
with three accesses to ğ‘¦fitting Pattern:(R,W,R) .
From this example, we observe that in order to detect atomicity
violations effectively, two points should be addressed:
(1) Precise inter-procedural analysis. In each unserializable in-
terleaving pattern, the first and last items (i.e., ğ‘1andğ‘3) come
from a task with lower priority, while the middle item (i.e., ğ‘2)
comes from another task with higher priority. Considering the non-
deterministic preemption and asymmetric relationship between
different tasks, it is necessary to perform precise inter-procedural
analysis for detecting atomicity violations effectively. To achieve
this, a flexible reachability analysis based on model checking is
performed in this paper.
(2) Effective state space reduction. Although ISRs can preempt at
any time, only the representative interruption points are required
to be checked. Thus, the selection of representative interruption
points can reduce the interaction frequency between different tasks.
Further, at each selected interruption point, it is not necessary to
trigger the enabled ISRs at once. Instead, under the precondition of
the same influence, these enabled ISRs at each selected interruption
point should be triggered as late as possible, so as to reduce the
explored state space during the reachability analysis. To this end, we
propose the interruption points selection and delayed preemption
strategies in this paper.
4 ATOMICITY VIOLATION DETECTION
In this section, we propose a framework to statically detect atom-
icity violations of interrupt-driven programs. As shown in Fig. 3,
there are three modules in this framework: IPS,DIT, and UIPM . In
the module IPS(Section 4.1), the sub-CFGs of all tasks are con-
structed to build up the CFG of an interrupt-driven program. These
sub-CFGs are further utilized to select representative interruptionpoints, which are locations possibly influenced by ISRs with higher
priority. In the module DIT(Section 4.2), an ART is generated by
unwinding the CFG obtained in IPS. During the generation, when
reaching an interruption point, the correspondingly enabled ISRs
are not triggered at once by introducing their control-flows. Instead,
their triggering is postponed as much as possible by the proposed
delayed ISR-triggering strategy. Along with DIT, the module UIPM
(Section 4.3) maintains the data access table at each newly generated
state in the ART. On this basis, unserializable interleaving patterns
are matched on-the-fly to detect atomicity violations.
4.1 Interruption Points Selecting
For an interrupt-driven program ğ‘ƒ, we first construct the sub-CFG
of each task. As an example, the sub-CFGs GMain andGISRofExa.c
in Fig. 2 are depicted in Fig. 4. Different from concurrent programs
which introduce control-flows of tasks by creating threads explic-
itly, interrupt-driven programs do not create ISRs. Instead, a task
is passively interrupted by an ISR with higher priority. Thus, it is
insufficient to just construct the sub-CFG of each task, since inde-
pendent sub-CFGs cannot reflect the interactions between different
tasks. To solve this, we introduce the control-flow of each ISR at
specific program locations (i.e., treat ISRs as special function calls).
In this way, the triggering of an ISR at a location can be simulated.
Due to the reason that an ISR can be triggered anytime, almost
all program locations are required to be considered during a naive
detection approach. However, this will be prohibitively expensive
even for a simple interrupt-driven program. In fact, it is unnecessary
to consider all the program locations since not all statements would
influence or be influenced by other ISRs. For instance, the ISRs ğ‘–ğ‘ ğ‘Ÿ_1
andğ‘–ğ‘ ğ‘Ÿ_2in Fig. 2 do not have direct relation with the value of the
local variable ğ‘šin the statement â€˜ ğ‘š=1â€™ (Line 4). That is, we do
not need to introduce the control-flows of ğ‘–ğ‘ ğ‘Ÿ_1andğ‘–ğ‘ ğ‘Ÿ_2when
the main task reaches the program location ğ‘™3in Fig. 4.
Based on the above analysis, we observe that the control-flows
of ISRs just need to be introduced at specific program locations,
which are referred to as interruption points .
Definition 1 (Interruption Points). Letğºğ‘ƒ=(ğ¿ğ‘ƒ,ğ‘™0ğ‘ƒ,ğ‘‡ğ‘ƒ)be
the CFG of an interrupt-driven program ğ‘ƒ=Mainâˆ¥isr1âˆ¥...âˆ¥isrğ‘›.
According to the operation ğœin a transition ğ‘¡=(ğ‘™,ğœ,ğ‘™â€²)âˆˆğ‘‡ğ‘ƒof a
task PiâˆˆTask(P), the location ğ‘™â€²is an interruption point if ğœmay
potentially have an influence on or be influenced by other ISR tasks
PjâˆˆTask(P)(iâ‰ j)with higher priority. That is, the operation ğœ
reads from or writes into a shared variable.
To determine whether a location in the CFG of an interrupt-
driven program ğ‘ƒis an interruption point, we further define a
1156Detecting Atomicity Violations in Interrupt-Driven Programs via Interruption ... ESEC/FSE â€™23, December 3â€“9, 2023, San Francisco, CA, USA
ğ’Šğ’ğ’• ğ’š,ğ’›àµŒğŸğ’ğŸ
ğ’ğŸ
ğ’…ğ’Šğ’”ğ’‚ğ’ƒğ’ğ’† _ğ’Šğ’”ğ’“áˆºğŸáˆ»
ğ’ğŸ
ğ¢ğ§ğ­ ğ’‘,ğ’àµŒğŸ ,ğ’àµŒğŸ
ğ’ğŸ‘
ğ’ğŸ’
ğ’ğŸ”áˆ¾ğ’àµ…ğ’ àµ ğ’šáˆ¿
ğ’‘àµŒğ’
ğ’‘àµŒğ’ğ’ğŸ•
ğ’ğŸ—áˆ¾ğ’àµ…ğ’ àµ ğ’šáˆ¿ğ’ğŸ“
ğ’ğŸ–
ğ‘®ğ‘´ğ’‚ğ’Šğ’ğ’ğŸğŸ’
ğ’ğŸğŸ“
ğ’ğŸğŸ•áˆ¾ğ’› àµ ğŸáˆ¿
ğ’šàµŒğŸ ğŸ
ğ’ğŸğŸ–ğ’›àµŒğŸğ’ğŸğŸ”
isr_2ğ’ğŸğŸ
ğ’šàµŒğŸ
ğ’ğŸğŸ
ğ’ğŸğŸ
ğ’ğŸğŸ‘ğ’›àµŒğŸ
ğ’†ğ’ğ’‚ğ’ƒğ’ğ’† _ğ’Šğ’”ğ’“áˆºğŸáˆ»isr_1
ğ‘®ğ‘°ğ‘ºğ‘¹Interruption Point Common Location
Figure 4: The sub-CFGs of program Exa.c in Fig. 2.
functionM:ğ¿ğ‘ƒâ†’2Task(P)which maps a location ğ‘™â€²to a set of
tasks. Intuitively, the returned tasks are the ISRs which may be
triggered at the location ğ‘™â€².
Specifically, each transition ğ‘¡=(ğ‘™,ğœ,ğ‘™â€²) âˆˆğ‘‡ğ‘ƒğ‘–of a taskğ‘ƒğ‘–âˆˆ
Task(P)is considered to obtain the relevant ISRs of all the locations
inğ‘ƒğ‘–:
1)If there exists a task ğ‘ƒğ‘—âˆˆTask(P)(ğ‘–â‰ ğ‘—)containing one or more
shared variables with operation ğœandPri(Pi)<Pri(Pj), then we
includeğ‘ƒğ‘—inM(ğ‘™â€²).
2)Ifğœ:enable _isr(j)is an ISR enabling operation, then we include
ISRğ‘ƒğ‘—with Pri(Pj)=ğ‘—intoM(ğ‘™â€²).
As a result, a location ğ‘™â€²âˆˆğ¿ğ‘ƒis an interruption point if M(ğ‘™â€²)â‰ 
âˆ…. For convenience, we call M(ğ‘™â€²)â‰ âˆ…therelevant-ISRs at the
interruption point ğ‘™â€².
In the sub-CFGs shown in Fig. 4 for the example program Exa.c ,
we can obtain thatM(ğ‘™3)=âˆ…as the operation â€˜int ğ‘,ğ‘š=1,ğ‘›=1â€™ con-
tains no shared variables. Similarly, M(ğ‘™4)=M(ğ‘™5)={ğ‘–ğ‘ ğ‘Ÿ_1,ğ‘–ğ‘ ğ‘Ÿ_2},
since the operation â€˜ ğ‘š+ğ‘›>ğ‘¦â€™ reads the shared variable ğ‘¦which is
written byğ‘–ğ‘ ğ‘Ÿ_1andğ‘–ğ‘ ğ‘Ÿ_2. Forğ‘–ğ‘ ğ‘Ÿ_1, we haveM(ğ‘™11)=M(ğ‘™12)=
{ğ‘–ğ‘ ğ‘Ÿ_2}. In addition, by applying the second rule above, we have
M(ğ‘™13)={ğ‘–ğ‘ ğ‘Ÿ_2}. Moreover, there are no interruption points for
ğ‘–ğ‘ ğ‘Ÿ_2since it has the highest priority in this program. Compared
with the naive approach that requires to trigger each ISR at almost
all program locations, we just need to consider 7 program locations
to trigger the relevant-ISRs.
4.2 Delayed ISR-Triggering
After the CFG ğºğ‘ƒis built and interruption points are selected for
an interrupt-driven program ğ‘ƒ, the possible behaviors of ğ‘ƒcan be
explored by constructing an ART. Throughout this process, the
control-flows of the relevant-ISRs are required to be introduced in
conditionally for each reachable interruption point.
Specifically, for any state ğ‘ âˆˆğ‘†in an ART, in the case that ğ‘™ğ‘ 
is an interruption point, the control-flow of an ISR ğ‘ƒğ‘–âˆˆM(ğ‘™ğ‘ )
will be introduced in if ğ‘ƒğ‘–is enabled at the current state ğ‘ and the
priority ofğ‘ƒğ‘–is higher than that of the task in progress. We call the
stateğ‘ ğ‘¡ğ‘Ÿwhere the relevant-ISRs ğ‘ƒğ‘–âˆˆM(ğ‘™ğ‘ )are actually triggered
when constructing an ART the triggering state and assume that the
corresponding program location is ğ‘™ğ‘ ğ‘¡ğ‘Ÿ. Then, for each successor
transitionğ‘¡=(ğ‘™ğ‘ ğ‘¡ğ‘Ÿ,ğœ,ğ‘™â€²)âˆˆğ‘‡ğ‘ƒenabled atğ‘ ğ‘¡ğ‘Ÿ, two different direct
successor states will be generated:(1)ğ‘ â€²=(ğ‘™â€²,ğ‘ğ‘ â€²,ğ‘ğ‘ â€²), meaning that the successor state ğ‘ â€²does not
turn to the control-flow of task ğ‘ƒğ‘–after executing the transition ğ‘¡.
(2)ğ‘ â€²â€²=(ğ‘™0ğ‘ƒğ‘–,[ğ‘ğ‘ ğ‘¡ğ‘Ÿ,ğ‘ƒğ‘–],ğ‘ğ‘ ğ‘¡ğ‘Ÿ), meaning that the state ğ‘ â€²â€²turns to
the entry of the task ğ‘ƒğ‘–. In this transition, no actual statement is
executed and the reachable region keeps the same as the state ğ‘ ğ‘¡ğ‘Ÿ.
The call stack[ğ‘ğ‘ ğ‘¡ğ‘Ÿ,ğ‘ƒğ‘–]indicates that when ğ‘ƒğ‘–finishes, the control-
flow of the whole program will turn back to the original location
from which it is introduced in.
Intuitively, at the state ğ‘ ğ‘¡ğ‘Ÿbefore the operation ğœ, more than one
branch can be explored. One is the original execution without being
preempted by any relevant-ISR, while the others (one or more) are
the executions preempted by different relevant-ISRs. When the
execution of each relevant-ISR finishes, it turns back to the state
ğ‘ ğ‘¡ğ‘Ÿto resume the original execution.
It should be noted that, a triggering state ğ‘ ğ‘¡ğ‘Ÿcan be the same as or
different from the state ğ‘ with the interruption point ğ‘™ğ‘ . Concretely,
if the stateğ‘ ğ‘¡ğ‘Ÿis justğ‘ , it means that relevant-ISRs are triggered
at once for the interruption point ğ‘™ğ‘ . In this case, the original and
interrupted branches have no shared states from the interruption
point. On the other hand, if the state ğ‘ ğ‘¡ğ‘Ÿis different from ğ‘ , these
states between ğ‘ andğ‘ ğ‘¡ğ‘Ÿcan be shared by the original and inter-
rupted branches. Therefore, without changing the mutual influence
between different tasks, M(ğ‘™ğ‘ )for the interruption state ğ‘™ğ‘ should
be triggered as late as possible, i.e., the triggering state ğ‘ ğ‘¡ğ‘Ÿshould
be as deep as possible in the explored ART. To achieve this, for
different kinds of operations on a shared variable ğ‘£at a stateğ‘ ,
we dynamically determine the triggering state ğ‘ ğ‘¡ğ‘Ÿaccording to the
operationğœwhich follows ğ‘ :
â€¢[Rule 1-D ]ğ‘…(ğ‘£)at the state ğ‘ : for a task ğ‘ƒğ‘–containing ğ‘£, if
there is a variable ğ‘£â€²withğ‘Š(ğ‘£â€²)inğ‘ƒğ‘–andğ‘£â€²also occurs in ğœ,
orğœ:ğ‘‘ğ‘–ğ‘ ğ‘ğ‘ğ‘™ğ‘’ _ğ‘–ğ‘ ğ‘Ÿ(ğ‘–)withğ‘ƒğ‘Ÿğ‘–(ğ‘ƒğ‘–)=ğ‘–,ğ‘ ğ‘¡ğ‘Ÿis the triggering state
whereğ‘ƒğ‘–is triggered.
â€¢[Rule 2-D ]ğ‘Š(ğ‘£)at the stateğ‘ : for a taskğ‘ƒğ‘–containingğ‘£, if there
is a variable ğ‘£â€²inğ‘ƒğ‘–andğ‘£â€²also occurs in ğœ, orğœ:ğ‘‘ğ‘–ğ‘ ğ‘ğ‘ğ‘™ğ‘’ _ğ‘–ğ‘ ğ‘Ÿ(ğ‘–)
withğ‘ƒğ‘Ÿğ‘–(ğ‘ƒğ‘–)=ğ‘–,ğ‘ ğ‘¡ğ‘Ÿis the triggering state where ğ‘ƒğ‘–is triggered.
â€¢[Rule 3-D ]enable _isr(i)at the state ğ‘ : if there exists ğ‘…(ğ‘£)or
ğ‘Š(ğ‘£)after the previous disable _isr(i), refer to 1) or 2), respec-
tively; otherwise, no relevant-ISRs will be triggered.
Through the above delayed ISR-triggering strategy, another pos-
itive effect can be achieved. For the final interruption location ğ‘™
of a shared variable in one task, there is no triggering state ğ‘ ğ‘¡ğ‘Ÿto
trigger relevant-ISRs, since no operation ğœexists before the current
task finishes. This is quite reasonable in the atomicity violation de-
tection. Corresponding to the unserializable interleaving patterns
shown in Fig. 1, even if a relevant-ISR is triggered for the final
interruption location ğ‘™of a variable ğ‘£, the missing of ğ‘3makes it
impossible to form an atomicity violation ( ğ‘1,ğ‘2,ğ‘3).
Fig. 5 shows the ART of the example program Exa.c . The green
nodes represent the interruption points, while the yellow ones are
the triggering states where relevant-ISRs are actually triggered. To
save space, squares represent ISRs with omitting internal states.
Note that, the control-flow of ğ‘–ğ‘ ğ‘Ÿ_2is not introduced in at the state
ğ‘ 5since it has already been disabled by the main task. At the state
ğ‘ 7,ğ‘–ğ‘ ğ‘Ÿ_2is triggered, where one successor ğ‘ 8turns the control-flow
fromğ‘–ğ‘ ğ‘Ÿ_1toğ‘–ğ‘ ğ‘Ÿ_2, while the other returns to the main task.
1157ESEC/FSE â€™23, December 3â€“9, 2023, San Francisco, CA, USA Yu, Tian, Xing, Yang, Su, Lu, Yang, Zhao, Li, Duan
ğ’Šğ’ğ’• ğ’š,ğ’›àµŒğŸğ’ğŸ
ğ’…ğ’Šğ’”ğ’‚ğ’ƒğ’ğ’† _ğ’Šğ’”ğ’“áˆºğŸáˆ»
ğ’Šğ’ğ’• ğ’‘,ğ’àµŒğŸ ,ğ’àµŒğŸ
ğ’ğŸ‘
ğ’ğŸ’áˆ¾ğ’àµ…ğ’ àµ ğ’šáˆ¿
áˆ¾ğ’àµ…ğ’ àµ ğ’šáˆ¿ğ’ğŸ“áˆ¾!áˆºğ’àµ…ğ’ àµ ğ’šáˆ»áˆ¿
ğ’ğŸ”ğ’‘àµŒğ’
ğ’ğŸğŸ
ğ’ğŸ—ğ’‘àµŒğ’áˆ¾!áˆºğ’àµ…ğ’ àµ ğ’šáˆ»áˆ¿
ğ’ğŸ• ğ’ğŸ–ğ’”ğŸ
ğ’”ğŸ‘
ğ’”ğŸ’
ğ’”ğŸ”ğ’”ğŸ“
ğ’”ğŸğŸ
ğ’”ğŸğŸ‘ğ’”ğŸğŸ’ğ’”ğŸğŸ”
ğ’Šğ’”ğ’“_ğŸ
ğ’”ğŸ–ğ’ğŸğŸ’
ğ’ğŸ—ğ’”ğŸğŸ“void isr_1 ()Â {Â 
y=Â 0;Â 
z=Â 1;Â 
enable_isr (2);Â 
}Â 
void isr_2 ()Â {Â 
if(z > 0)Â {Â 
y=Â 11;Â 
z=Â 0;Â 
}Â 
}10
11
12
1314
15
1617
18
1920
ğ’ğŸ”ğ’”ğŸ•ğ’Šğ’”ğ’“_ğŸ ğ’“ğ’†ğ’•ğ’–ğ’“ğ’ğ’ğŸğŸ‘
ğ’”ğŸ—ğ’ğŸğŸ–
ğ’ğŸ”ğ’”ğŸğŸğ’“ğ’†ğ’•ğ’–ğ’“ğ’áˆ¾ğ’àµ…ğ’ àµ ğ’šáˆ¿ğ’ğŸ”
ğ’ğŸğŸ
ğ’ğŸ—ğ’‘àµŒğ’áˆ¾!áˆºğ’àµ…ğ’ àµ ğ’šáˆ»áˆ¿
ğ’ğŸ• ğ’ğŸ–ğ’”ğŸğŸ–ğ’”ğŸğŸ•
ğ’”ğŸğŸ’
ğ’”ğŸğŸ“ğ’”ğŸğŸ”ğ’Šğ’”ğ’“_ğŸ
ğ’”ğŸğŸğ’ğŸğŸ’
ğ’ğŸ—ğ’”ğŸğŸ•ğ’ğŸ”ğ’”ğŸğŸ—ğ’Šğ’”ğ’“_ğŸ ğ’“ğ’†ğ’•ğ’–ğ’“ğ’ğ’ğŸğŸ‘
ğ’”ğŸğŸğ’ğŸğŸ–
ğ’ğŸ”ğ’”ğŸğŸğ’“ğ’†ğ’•ğ’–ğ’“ğ’ğ’”ğŸğŸ ğ’”ğŸğŸ‘Interruption Point
ISR Triggering State
ISRs Omitting Internal States
No ISRs are 
TriggeredNo ISRs are 
TriggeredNo ISRs are 
TriggeredNo ISRs are 
Triggered
Figure 5: The ART for Exa.c in Fig. 2 with the interruption
points selecting and delayed ISR-triggering strategies.
In Fig. 5, we can see that, although ğ‘™4andğ‘™5are two interrupted
points, the corresponding triggering states are ğ‘ 5andğ‘ 17, instead
ofğ‘ 4andğ‘ 16, respectively. In this way, the transition (ğ‘™4,ğ‘=ğ‘š,ğ‘™ 6)
can be shared by the original and interrupted branches. Besides,
since no triggering state exists for interruption locations ğ‘™7andğ‘™8,
no ISR is actually triggered in the corresponding four branches,
which can greatly reduce the explored state space.
4.3 Unserializable Interleaving Patterns
Matching
When constructing an ART, unserializable interleaving patterns are
matched at the same time. To achieve this, for each access to a shared
variableğ‘£on an edge of the ART, a tuple ğ‘œ=(ğ‘£,ğ‘“,ğ‘™,ğ‘), namely
operation state , is used to record the detailed access information.
Here,ğ‘“âˆˆTask(ğ‘ƒ)is the task where ğ‘œlocates,ğ‘™is the line number
of the corresponding statement, and ğ‘âˆˆ{ğ‘…,ğ‘Š}is the access type
forğ‘£. We call a triple(ğ‘œ1,ğ‘œ2,ğ‘œ3)as acandidate atomicity-violation ,
ifğ‘œ1andğ‘œ3are two consecutive operation states in a low-priority
taskğ‘ƒğ‘–âˆˆTask(ğ‘ƒ), andğ‘œ2is from an ISR ğ‘ƒğ‘—âˆˆTask(ğ‘ƒ)\{Main,ğ‘ƒğ‘–}
with priority higher than that of ğ‘ƒğ‘–. A candidate atomicity-violation
(ğ‘œ1,ğ‘œ2,ğ‘œ3)is regarded as an atomicity violation if the corresponding
access triple(ğ‘œ1.ğ‘,ğ‘œ 2.ğ‘,ğ‘œ 3.ğ‘)matches any unserializable interleav-
ing pattern in Patterns in Fig. 1.
To keep tracking operation states which may comprise a candi-
date atomicity-violation during the ART exploration, a data access
tableğ·ğ‘£=(ğ‘™ğ‘œğ‘£,ğ‘‚ğ‘£)is defined as a basic structure to store relevant
operation states for each shared variable ğ‘£. Specifically, ğ‘™ğ‘œğ‘£is the
last operation state of ğ‘£in a preempted task, and ğ‘‚ğ‘£is the set of
partitions of operation states divided by different ISRs. Here, a par-
titionğ‘œğ‘of operation states is defined as ğ‘œğ‘=(ğ‘“â€²,ğ‘ ğ‘’ğ‘), in which
ğ‘“â€²âˆˆTask(ğ‘ƒ)\{Main}, andğ‘ ğ‘’ğ‘is a sequence of operation states
sorted by the order they are obtained in task ğ‘“â€². During the detec-
tion,ğ‘™ğ‘œğ‘£andğ‘‚ğ‘£are utilized to track ğ‘œ1andğ‘œ2, respectively. Further,
each operation state acquired from the newly generated edge in the
ART is regarded as ğ‘œ3. After that, it can be determined whether the
candidate atomicity-violation (ğ‘œ1,ğ‘œ2,ğ‘œ3)is an atomicity violation
by checking whether (ğ‘œ1.ğ‘,ğ‘œ 2.ğ‘,ğ‘œ 3.ğ‘)âˆˆPatterns .
The above process is formally presented in Algorithm 1, where
the newly obtained operation state ğ‘œ3is taken as the input, and
the set AVSet acting as the output is used to store all the detected
atomicity violations. When providing ğ‘œ3, the algorithm first ac-
quires the corresponding data access table ğ·ğ‘£according to theAlgorithm 1: PatternMatching(ğ‘œ3)
Input : A newly obtained operation state ğ‘œ3.
Output: The set AVSet of atomicity violations.
1begin
2 Getğ·ğ‘£=(ğ‘™ğ‘œğ‘£,ğ‘‚ğ‘£)for variableğ‘£inğ‘œ3;
3 Patternsâ†{(ğ‘…,ğ‘Š,ğ‘…),(ğ‘Š,ğ‘Š,ğ‘…),(ğ‘…,ğ‘Š,ğ‘Š),(ğ‘Š,ğ‘…,ğ‘Š)};
4 AVSetâ†âˆ… ;
5 ifğ‘™ğ‘œğ‘£=ğ‘›ğ‘¢ğ‘™ğ‘™ orğ‘‚ğ‘£=âˆ…then
6 ğ‘™ğ‘œğ‘£=ğ‘œ3;
7 return AVSet ;
8 end
9ğ‘œ1=ğ‘™ğ‘œğ‘£;
10 foreachğ‘œğ‘âˆˆğ‘‚ğ‘£do
11 foreachğ‘œâˆˆğ‘œğ‘.ğ‘ ğ‘’ğ‘ do
12 ğ‘œ2=ğ‘œ;
13 if(ğ‘œ1.ğ‘,ğ‘œ 2.ğ‘,ğ‘œ 3.ğ‘)âˆˆPatterns then
14 AVSet.ğ‘ğ‘‘ğ‘‘((ğ‘œ1,ğ‘œ2,ğ‘œ3));
15 end
16 end
17 end
18ğ‘™ğ‘œğ‘£=ğ‘œ3;ğ‘‚ğ‘£=âˆ…;
19 return AVSet ;
20end
name ofğ‘£recorded in ğ‘œ3(Line 2), and initializes the sets Patterns
andAVSet (Lines 3-4). Next, the algorithm checks whether ğ‘™ğ‘œğ‘£is
ğ‘›ğ‘¢ğ‘™ğ‘™, i.e., whether there exists an ğ‘œ1that could lead to an atomicity
violation. Also, it checks whether ğ‘‚ğ‘£is empty, i.e., whether there is
anğ‘œ2acting as the second item in a candidate atomicity-violation
to form an atomicity violation. If ğ‘™ğ‘œğ‘£isğ‘›ğ‘¢ğ‘™ğ‘™ orğ‘‚ğ‘£is empty, there
is no need to perform a further pattern matching. In this case, we
updateğ‘™ğ‘œğ‘£toğ‘œ3, and return the set AVSet (Lines 5-8). Otherwise,
ğ‘™ğ‘œğ‘£is assigned to ğ‘œ1(Line 9) and all the operation states ğ‘œtaken
fromğ‘œğ‘.ğ‘ ğ‘’ğ‘ in eachğ‘œğ‘âˆˆğ‘‚ğ‘£are iterated to act as the middle item
ğ‘œ2of a candidate atomicity-violation (Lines 10-12). Then, with the
newly obtained operation state ğ‘œ3, a candidate atomicity-violation
(ğ‘œ1,ğ‘œ2,ğ‘œ3)is formed and whether (ğ‘œ1.ğ‘,ğ‘œ 2.ğ‘,ğ‘œ 3.ğ‘)âˆˆPatterns is
further checked (Line 13). If so, an atomicity violation is found and
(ğ‘œ1,ğ‘œ2,ğ‘œ3)is added into AVSet (Line 14). Otherwise, Algorithm 1
keeps traversing ğ‘œğ‘.ğ‘ ğ‘’ğ‘ andğ‘‚ğ‘£. Eventually, the algorithm returns
AVSet after updating ğ‘™ğ‘œğ‘£andğ‘‚ğ‘£(Lines 18-19).
For the example program Exa.c , one feasible path in the gener-
ated ART in Fig. 5 is shown in Fig. 6, along which pattern matching
is performed. According to the triple (ğ‘œ1,ğ‘œ2,ğ‘œ3)=((y,main,5,R),
(y,isr_2,17,W),(y,main,7,R)), one atomicity violation is detected
for the variable ğ‘¦.
ğ‘ à¬´
ğ‘ à¬·ğ‘™à¬·ğ‘‘ğ‘–ğ‘ ğ‘ğ‘ğ‘™ğ‘’ _ğ‘–ğ‘ ğ‘Ÿáˆº 2áˆ»
int ğ‘,ğ‘šàµŒ 1,ğ‘›àµŒ 1
áˆ¾ğ‘šàµ…ğ‘› àµ ğ‘¦áˆ¿
ğ‘ à¬¸ğ‘™à¬¸
ğ‘§àµŒ 0
ğ‘ à¬·à¬¹ğ‘™à¬µà¬¼ğ‘ à¬·à¬¸ğ‘™à¬µà¬»áˆ¾ğ‘§ àµ 0áˆ¿
ğ‘¦àµŒ 11ğ’Šğ’”ğ’“_ğŸ
ğ‘ à¬·à¬·ğ‘™à¬µà¬¹ğ’Šğ’”ğ’“_ğŸ
ğ‘ à¬·à¬´ğ‘™à¬µà¬¶ğ‘ à¬¶à¬½ğ‘™à¬µà¬µğ‘ à¬¶à¬¼ğ‘™à¬µà¬´
ğ‘¦àµŒ 0
ğ‘§àµŒ 1
ğ‘ à¬·à¬ºğ‘ à¬·à¬¶ğ‘™à¬µà¬¸int ğ‘¦,ğ‘§àµŒ 0
ğ‘ à¬·à¬¼ğ‘™à¬»áˆ¾ğ‘šàµ…ğ‘› àµ ğ‘¦áˆ¿
ğ‘àµŒğ‘›
ğ‘ à¬·à¬½ğ‘™à¬½ğ‘’ğ‘›ğ‘ğ‘ğ‘™ğ‘’ _ğ‘–ğ‘ ğ‘Ÿáˆº 2áˆ»ğ‘ à¬·à¬»ğ‘™à¬´
ğ‘™à¬º
ğ‘™à¬µà¬·ğ‘ à¬·à¬µğ‘™à¬µà¬·ğ‘àµŒğ‘š
ğ‘ à¬¹ğ‘™à¬ºAtomicity Violation:
(y: R#5, W#17, R#7)
Fig.6
Figure 6: A feasible path in the generated ART of Exa.c with
one atomicity violation.
1158Detecting Atomicity Violations in Interrupt-Driven Programs via Interruption ... ESEC/FSE â€™23, December 3â€“9, 2023, San Francisco, CA, USA
5 CONFIGURABLE STRATEGIES TO
INCREASE PRECISION
Although the proposed approach discussed in the previous section
is able to deal with all the situations considered in the state-of-
the-art tools intAtom and Rchecker, the cases that relevant-ISRs
are triggered at the initial or final location have not been taken
into account yet. To address them, we further put forward initial
ISR-triggering and final ISR-triggering strategies as configurable
options to handle more complex situations.
5.1 Initial ISR-Triggering
Since interruption points are selected after each operation which
is related to shared variables, the influence of tasks with higher
priority on the task with lower priority at its initial location has
not been considered. Thus, atomicity violations occurring in the
influenced branches will escape from being captured. For example,
for the program Exa_I.c in Fig. 7 which is a slight modification
of the motivating example Exa.c , without the triggering of ğ‘–ğ‘ ğ‘Ÿ_1
before Line 4, the condition â€˜ ğ‘š+ğ‘›>ğ‘¦â€™ in Line 4 cannot be satisfied,
leading to the non-execution of the branch in Line 5. In this case,
the potential atomicity violation (two reads of variable ğ‘¦in Lines 4
and 5 are interrupted by the write in Line 13) cannot be found.
To solve this problem, we propose an initial triggering strat-
egy of relevant-ISRs. Specifically, for each successor transition
ğ‘¡=(ğ‘™ğ‘ ğ‘¡ğ‘Ÿ,ğœ,ğ‘™â€²)âˆˆğ‘‡ğ‘ƒenabled at a state ğ‘ ğ‘¡ğ‘Ÿ,ğ‘ ğ‘¡ğ‘Ÿis regarded as a
triggering state according to the operation ğœwhich follows it:
â€¢[Rule 1-I ] a variable ğ‘£occurs inğœ: ifğ‘£also occurs in ğ‘ƒğ‘–which
has yet not been triggered, ğ‘ ğ‘¡ğ‘Ÿis the triggering state where ğ‘ƒğ‘–is
triggered.
â€¢[Rule 2-I ]ğœ:disable _isr(i): ifğ‘ƒğ‘–withğ‘ƒğ‘Ÿğ‘–(ğ‘ƒğ‘–)=ğ‘–has yet not
been triggered, ğ‘ ğ‘¡ğ‘Ÿis the triggering state where ğ‘ƒğ‘–is triggered.
int y,Â z=Â 0;Â 
voidÂ main ()Â {
int p,Â m=Â â€1,n=Â â€1;Â 
if(m +Â n>y)Â 
p=Â y;Â 
}Â void isr_1 ()Â {Â 
y=Â â€3;Â 
z=Â 1;
}Â 
void isr_2 ()Â {Â 
if(z > 0)Â {Â 
y=Â 11;Â 
z=Â 0;Â 
}Â 
}7
8
9
1011
12
1314
15
16int y,Â z=Â 0;Â 
voidÂ main ()Â {
int p,Â m=Â 1,n=Â 1;Â 
if(m +Â n>y )Â 
z=Â m;Â 
}Â void isr_2 ()Â {Â 
y=Â â€3;Â 
z=Â â€1;Â Â 
}Â 
void isr_1 ()Â {Â 
if(z>0)Â {Â 
y=Â 11;Â 
z=Â 0;Â 
}Â 
}1
2
34
5
67
8
9
10
11
1213
14
1516
1
2
34
5
6int y,Â z=Â 0;Â 
voidÂ main ()Â {
int p,Â m=Â â€1,n=Â â€1;Â 
if(m +Â n>y)Â 
p=Â y;Â 
}Â void isr_1 ()Â {Â 
y=Â â€3;Â 
z=Â 1;
}Â 
void isr_2 ()Â {Â 
if(z > 0)Â {Â 
y=Â 11;Â 
z=Â 0;Â 
}Â 
}7
8
9
1011
12
1314
15
161
2
34
5
6Initial Triggering
Atomicity Violation:
(y: R#4, W#13, R#5)
Final Triggering
Atomicity Violation:
(z: R#12, W#9, W#14)
Figure 7: Program Exa_I.c : one atomicity violation detected
by the initial ISR-triggering strategy.
With this strategy, for program Exa_I.c shown in Fig. 7, with
the initial triggering of ğ‘–ğ‘ ğ‘Ÿ_1, the assignments of variables ğ‘¦andğ‘§
make it possible for ğ‘–ğ‘ ğ‘Ÿ_2to preempt between Lines 4-5 in the main
task. Thus, an atomicity violation (ğ‘¦:ğ‘…#4,ğ‘Š#13,ğ‘…#5)is detected.
5.2 Final ISR-Triggering
With the delayed ISR-triggering strategy, no ISR is triggered for the
final interruption location of each variable, since it is impossible to
form an atomicity violation without the existence of ğ‘3as shown in
Fig. 1. However, the final operation ğ‘3has a possible influence on
other tasks which may contain atomicity violations. For example,
in program Exa_F.c shown in Fig. 8 as another slight modification
of the motivating example Exa.c , the shared variable ğ‘§is assigned
as a new value at the last statement of the main task. Coincidentally,this new value has a direct impact on the executions of ISRs ğ‘–ğ‘ ğ‘Ÿ_1
andğ‘–ğ‘ ğ‘Ÿ_2, making that the write of variable ğ‘§in Line 9 can preempt
between Lines 12 and 14.
To handel this problem, at the exit state of each task, if there
still exist un-triggered relevant-ISRs ğ‘ƒğ‘–âˆˆM(ğ‘™)for some previous
interruption point ğ‘™, andğ‘ƒğ‘Ÿğ‘–(ğ‘ƒğ‘–)is not the highest, the exit state is
regarded as the triggering state where ğ‘ƒğ‘–is triggered.
int y,Â z=Â 0;Â 
voidÂ main ()Â {
int p,Â m=Â â€1,n=Â â€1;Â 
if(m +Â n>y)Â 
p=Â y;Â 
}Â void isr_1 ()Â {Â 
y=Â â€3;Â 
z=Â 1;
}Â 
void isr_2 ()Â {Â 
if(z > 0)Â {Â 
y=Â 11;Â 
z=Â 0;Â 
}Â 
}7
8
9
1011
12
1314
15
16int y,Â z=Â 0;Â 
voidÂ main ()Â {
int p,Â m=Â 1,n=Â 1;Â 
if(m +Â n>y )Â 
z=Â m;Â 
}Â void isr_2 ()Â {Â 
y=Â â€3;Â 
z=Â â€1;Â Â 
}Â 
void isr_1 ()Â {Â 
if(z>0)Â {Â 
y=Â 11;Â 
z=Â 0;Â 
}Â 
}1
2
34
5
67
8
9
10
11
1213
14
1516
1
2
34
5
6int y,Â z=Â 0;Â 
voidÂ main ()Â {
int p,Â m=Â â€1,n=Â â€1;Â 
if(m +Â n>y)Â 
p=Â y;Â 
}Â void isr_1 ()Â {Â 
y=Â â€3;Â 
z=Â 1;
}Â 
void isr_2 ()Â {Â 
if(z > 0)Â {Â 
y=Â 11;Â 
z=Â 0;Â 
}Â 
}7
8
9
1011
12
1314
15
161
2
34
5
6Initial Triggering
Atomicity Violation:
(y: R#4, W#13, R#5)
Final Triggering
Atomicity Violation:
(z: R#12, W#9, W#14)
Figure 8: Program Exa_F.c : one atomicity violation detected
by the final ISR-triggering strategy.
Through this strategy, for the program Exa_F.c shown in Fig.
8, with the final triggering of ğ‘–ğ‘ ğ‘Ÿ_1before the main task returns,
the condition â€˜ ğ‘§>0â€™ in Line 12 can be satisfied. Thus, when
ğ‘–ğ‘ ğ‘Ÿ_2preempts between Lines 12-13, an atomicity violation (ğ‘§:
ğ‘…#12,ğ‘Š#9,ğ‘Š#14)is detected.
6 EXPERIMENT AND EVALUATION
We have implemented the proposed approach as a configurable tool
called CPA4AV1(Configurable Program Analysis for Atomicity
Violation) upon the open-source model checker CPAchecker [ 3],
which supports reachability computation based on binary decision
diagram (BDD) [ 4]. CPAchecker provides an efficient configurable
analyzing framework for verifying C and Java programs without
ISRs. CPA4AV extends it with additional modules for selecting
interruption points, triggering enabled ISRs, and detecting atomicity
violations in interrupt-driven C programs. Besides, the internal
library JavaBDD is invoked to compute the reachable region of
each abstract state in an ART. All experiments are performed on a
computer running the Ubuntu 20.04 LTS system with an Intel(R)
Xeon(R) E5-2620 CPU and 32 GB RAM, which is the same with that
utilized to evaluate intAtom [ 22]. Our experiments are designed to
answer the following research questions:
RQ1 : How efficient and precise is CPA4AV compared with the
state-of-the-art tools such as intAtom [22] and Rchecker [10, 12]?
RQ2 : How much contribution on efficiency is made by the inter-
ruption points selecting and delayed ISR-triggering strategies?
RQ3 : How can the precision be improved with the configurable
strategies?
RQ4 : How is the scalability of CPA4AV for real-world programs?
6.1 Comparison with State-of-the-art Tools
To examine the performance, we compare CPA4AV with the state-of-
the-art tools intAtom [ 22] and Rchecker [ 10,12]. It should be noted
that, in this experiment, CPA4AV just contains the interruption
points selecting and delayed ISR-triggering strategies, without the
initial ISR-triggering and final ISR-triggering strategies, since this
is sufficient to achieve the desired precision.
1https://github.com/BinYu-Xidian-University/CPA4AV
1159ESEC/FSE â€™23, December 3â€“9, 2023, San Francisco, CA, USA Yu, Tian, Xing, Yang, Su, Lu, Yang, Zhao, Li, Duan
Table 1: Comparing CPA4AV with state-of-the-art tools on Racebench 2.1
#ID #LoC #ISR #SV #VioCPA4AV intAtom Rchecker
#WN #TP #FP #Time (ms) #WN #TP #FP #Time (ms) #WN #TP #FP #Time (ms)
Ex3 74 2 4 1 1 1 0 1504 1 1 0 484 2 1 1 510
Ex4 69 2 9 1 1 1 0 60 1 1 0 375 3 1 2 310
Ex5 47 1 2 1 1 1 0 244 1 1 0 125 3 1 2 5200
Ex6 54 1 3 1 1 1 0 343 1 1 0 266 2 1 1 310
Ex15 41 1 2 1 1 1 0 51 1 1 0 94 1 1 0 310
Ex16 34 1 1 3 3 3 0 33 3 3 0 63 3 3 0 360
Ex17 42 1 2 4 4 4 0 317 5 4 1 109 5 4 1 1810
Ex21 81 1 6 3 3 3 0 125 3 3 0 578 3 3 0 350
Ex22 67 1 4 4 4 4 0 157 4 4 0 219 6 4 2 340
Ex23 40 1 1 2 2 2 0 42 2 2 0 63 2 2 0 300
Ex26 44 2 1 1 1 1 0 49 2 1 1 62 1 1 0 290
Ex27 49 3 1 2 2 2 0 42 5 2 3 78 2 2 0 320
Ex28 54 3 2 1 1 1 0 41 1 1 0 109 1 1 0 410
Ex30 57 3 2 1 1 1 0 56 1 1 0 109 2 1 1 350
Total 753 23 40 26 26 26 0 3064 31 26 5 2734 36 26 10 11170
TP Rate 100% 83.9% 72.2%
FP Rate 0 16.1% 27.8%
Average Time 219 195 798
Because neither intAtom nor Rchecker is openly available, the
experiments are conducted over the benchmark Racebench 2.12
which has been evaluated by both of the tools. Racebench 2.1 con-
sists of 31 interrupt-driven C programs with handmade atomicity
violation bugs, and takes into account different scenarios where
atomicity violations may happen, which helps in making a compre-
hensive evaluation over different tools. Considering the inherent
weaknesses of CPAchecker that the BDD-based reachability com-
putation does not support complex data types (e.g., struct, pointer,
and array), we select 14 cases to ensure that each comparison tool
could execute normally and output valid detection results.
Table 1 shows the overall experimental results, in which #ID
represents the index of each program in Racebench 2.1, #LoC in-
dicates the lines of code, #ISR denotes the number of ISRs, #SV
represents the number of shared variables, #Vio is the number of
true violations, #WN denotes the number of the reported violations,
#TP/#FP is the number of true/false positives, and #Time is the time
for detection. Besides, we also evaluate the TP rate (TP/WN), FP
rate (FP/WN), and average detection time of each tool.
It should be pointed that, the preemption of an ISR at one location
may result in the detection of different unserializable interleaving
patterns, considered as different atomicity violations. We observe
that intAtom and Rchecker respectively report 31 and 36 atomicity
violations, but only 26 of them are correct. The FP rate and TP
rate of intAtom are respectively 16.1% (5/31) and 83.9% (26/31),
while the FP rate and TP rate of Rchecker are respectively 27.8%
(10/36) and 72.2% (26/36). CPA4AV reports 26 violations, and all of
them are proved to be real (i.e., the FP rate and TP rate of our tool
are respectively 0% (0/26) and 100% (26/26)). Obviously, CPA4AV
achieves a higher accuracy than intAtom and Rchecker. This is
because we perform a more precise reachability analysis based
on exploring ARTs, while intAtom adopts a coarser one based on
analyzing CFGs and Rchecker does not prune infeasible branches.
In terms of efficiency, it takes a relatively longer time to finish
the atomicity violation detection tasks with CPA4AV (3064 ms) than
that with intAtom (2734 ms). This is reasonable and inevitable since
a more accurate reachability analysis usually requires details about
the original program, which may cause an increase in the overhead.
2https://github.com/chenruibuaa/racebench/tree/master/2.1_remarksHowever, compared with Rchecker, which is also a model checker
but without effective optimization strategy, CPA4AV is much more
efficient (219/798â‰ˆ27.4% time cost) with the proposed interruption
points selecting and delayed ISR-triggering strategies.
6.2 Contribution of the Proposed Strategies
To further evaluate the effectiveness of the proposed interruption
points selecting and delayed ISR-triggering strategies, we imple-
ment two variants of CPA4AV: Naive and Naive+IPS (interruption
points selecting). Naive can be seen as a baseline approach, which
triggers enabled ISRs after each statement without any strategy.
Naive+IPS means relevant-ISRs are triggered immediately at each
interruption point without the delayed ISR-triggering strategy.
In addition to Racebench 2.1, three benchmarks are chosen from
the concurrency track of SV-COMP3. We totally select 92 programs
in the packages â€œldv-racesâ€, â€œgoblint-regressionâ€, and â€œpthreadâ€.
It is worth pointing out that these programs are originally multi-
threaded, and need to be transformed into interrupt-driven pro-
grams. To achieve this, we treat thread functions as different ISRs
and remove thread-related statements (e.g., â€œpthread_createâ€ and
â€œpthread_joinâ€) in each program. Besides, we also add the prior-
ity information for each obtained ISR. Although the semantics of
these programs are changed, basic data and control-flow structures
maintain the same. Besides, more randomness is introduced due to
the preemption of different ISRs. In practice, such randomness is
helpful to evaluate our tool comprehensively.
As is shown in Table 2, totally 106 programs are considered, and
CPA4AV reports that 28 of them have 200 atomicity violations in
total. By further analysis, we find out that all the reported pro-
grams indeed have the chance to trigger these violations. More
importantly, we compare the explored state space and time cost of
CPA4AV with those of Naive and Naive+IPS on these 4 benchmarks.
It can be seen that Naive+IPS provides an average reduction of
78.3% on state space and 72.7% on time cost over Naive. Further,
CPA4AV is able to provide an average reduction of 93.4% on state
space and 87.0% on time cost over Naive. As a result, both of the
proposed interruption points selecting and delayed ISR-triggering
strategies are significantly effective in improving efficiency.
3https://gitlab.com/sosy-lab/benchmarking/sv-benchmarks
1160Detecting Atomicity Violations in Interrupt-Driven Programs via Interruption ... ESEC/FSE â€™23, December 3â€“9, 2023, San Francisco, CA, USA
Table 2: The state space and time cost of CPA4AV compared with Naive and Naive+IPS
#Packages #Files #LoC #WNNaive Naive+IPS CPA4AV
#State
Number#Time
(ms)#State
Number#Reduction
Rate#Time
(ms)#Reduction
Rate#State
Number#Reduction
Rate#Time
(ms)#Reduction
Rate
racebench 14 753 26 76728 30159 14414 81.2% 6035 80.0% 3591 95.3% 3064 89.8%
ldv-races 5 211 55 17139 1974 5482 68.0% 801 59.4% 4023 76.5% 549 72.2%
goblint-regression 77 2066 91 49330 10501 6300 87.2% 3971 62.1% 4448 91.0% 1590 84.9%
pthread 10 486 28 167003 31052 41137 75.4% 9309 70.0% 8391 95.0% 4399 85.8%
Total 106 3516 200 310200 73686 67333 78.3% 20116 72.7% 20453 93.4% 9602 87.0%
Table 3: Precision improvement with configurable strategies on Racebench 2.1+
#ID #LoC #ISR #SV #VioCPA4AV CPA4AV+I CPA4AV+F CPA4AV+IF
#WN#State
Number#Time
(ms)#WN#State
Number#Time
(ms)#WN#State
Number#Time
(ms)#WN#State
Number#Time
(ms)
Ex3+I 98 3 4 2 0 291 210 2 2576 818 0 459 249 2 5764 1641
Ex4+I 78 2 9 1 0 76 42 1 150 90 0 134 82 1 235 111
Ex5+I 66 2 2 5 4 535 278 5 662 358 4 579 289 5 769 401
Ex26+I 64 2 1 3 0 16 21 3 91 81 0 20 49 3 123 93
Ex27+I 67 2 1 2 0 16 22 2 73 70 0 27 40 2 116 92
Ex6+F 79 2 4 2 1 465 357 1 823 404 2 495 347 2 863 511
Ex15+F 70 3 3 2 1 58 69 1 81 84 2 612 205 2 1573 392
Ex16+F 66 3 2 4 3 42 58 3 42 65 4 316 158 4 492 212
Ex23+F 61 2 2 2 1 60 56 1 70 57 2 129 85 2 163 111
Ex28+F 63 3 3 4 3 59 77 3 115 107 4 255 192 4 375 221
Total 712 24 31 27 13 1618 1190 22 4683 2134 18 3026 1696 27 10473 3785
6.3 Improvement with Configurable Strategies
As Section 5 presents, the initial or final ISR-triggering can act as
two configurable strategies to deal with more complex situations. To
evaluate the effectiveness, we implement three variants of CPA4AV:
CPA4AV+I (initial ISR-triggering), CPA4AV+F (final ISR-triggering),
and CPA4AV+IF (initial and final ISR-triggering).
Since Racebench 2.1 is designed under the assumption that ISRs
are not triggered at the initial or final location of a task, 10 selected
programs are modified slightly based on their original versions. In
this new benchmark, named Racebench 2.1+, one or more atomicity
violations occur just as ISRs are triggered at the initial or final
location of a task. It should be noted that, although intAtom and
Rchecker are not openly available, neither of them is able to detect
this kind of atomicity violations [10, 22].
Racebench 2.1+is evaluated to show the precision improvement
with different configurable strategies. The experimental results
are presented in Table 3. For the first 5 programs, more atomicity
violations can be found with the initial ISR-triggering strategy,
while for the last 5 programs, more atomicity violations can be
found with the final ISR-triggering strategy. Meanwhile, in terms of
efficiency, we can see that the initial ISR-triggering strategy has an
average increase of 1.9x on the state space and 0.8x on the time cost,
and the final ISR-triggering strategy has an average increase of 0.9x
on the state space and 0.4x on the time cost. In addition, if these
two strategies are employed at the same time, the explored state
space and time cost will increase by 5.5x and 2.2x, respectively.
6.4 Evaluation on Real-world Programs
CPA4AV is further evaluated on 6 packages including 18 real-world
interrupt-driven programs verified in [ 23,31]. Specifically, â€œloggerâ€
models parts of the firmware for a temperature logging device,
â€œblinkâ€ controls LED lights connected to MSP430 microcontrollers,
â€œbrakeâ€ is generated from the Simulink model of the embedded
BBW system developed by Volvo Technology AB, and â€œi2c_pca_isaâ€,â€œi8xx_tcoâ€, and â€œwdt_pciâ€ are from Linux kernel drivers to support
the hardware ISA boards, TCO timer for i8xx chipsets, and watch
dog, respectively.
Table 4: Real-world interrupt-driven programs results
#Packages #LoC #ISR #SVNaive CPA4AV CPA4AV+IF
#WN #Time(s) #WN #Time(s) #WN #Time(s)
logger 578 8 46 5 1801.8 21 16.2 21 20.4
blink 373 9 57 0 2700.0 26 4.1 26 15.3
brake 1975 8 130 7 1800.7 7 1800.6 7 1801.3
i2c_pca_isa 1063 9 20 0 2700.0 12 926.4 12 947.7
i8xx_tco 2671 9 60 0 2700.0 1 1.0 2 5.9
wdt_pci 3513 8 61 6 1802.1 15 6.9 19 48.7
Total 10173 51 374 18 13504.6 82 2755.2 87 2839.3
For each program, the atomicity violations are detected by Naive,
CPA4AV, and CPA4AV+IF, respectively. Since the BDD structure
cannot fully support complex data types (e.g., struct, pointer, and
array), explicit-value analysis is invoked for the reachability com-
putation. This configuration is mainly to evaluate the scalability of
our tool, although the efficiency may be influenced. The experiment
is conducted on the same platform with previous experiments and
timeout is set to 900 s. When the detection time is larger than 900
s, it is recorded as 900 s and the number of detected violations is
regarded as 0. The result for each package. In total, 15 programs are
reported as timeouts by Naive, and 3 programs are reported as time-
outs by CPA4AV and CPA4AV+IF. Since the reason of more timeouts
in Naive, CPA4AV is able to detect more violations than Naive (82
ğ‘£ğ‘ 18) with less time (2755.2 s ğ‘£ğ‘ 13504.6 s), and CPA4AV+IF can
further detect more violations than CPA4AV (87 ğ‘£ğ‘ 82).
int y,Â z=Â 0;Â 
voidÂ main ()Â {
int p,Â m=Â â€1,n=Â â€1;Â 
if(m +Â n>y)Â 
p=Â y;Â 
}Â void isr_1 ()Â {Â 
y=Â â€3;Â 
z=Â 1;
}Â 
void isr_2 ()Â {Â 
if(z > 0)Â {Â 
y=Â 11;Â 
z=Â 0;Â 
}Â 
}7
8
9
1011
12
1314
15
16int y,Â z=Â 0;Â 
voidÂ main ()Â {
int p,Â m=Â 1,n=Â 1;Â 
if(m +Â n>y )Â 
z=Â m;Â 
}Â void isr_2 ()Â {Â 
y=Â â€3;Â 
z=Â â€1;Â Â 
}Â 
void isr_1 ()Â {Â 
if(z>0)Â {Â 
y=Â 11;Â 
z=Â 0;Â 
}Â 
}1
2
34
5
67
8
9
10
11
1213
14
1516
1
2
34
5
6int y,Â z=Â 0;Â 
voidÂ main ()Â {
int p,Â m=Â â€1,n=Â â€1;Â 
if(m +Â n>y)Â 
p=Â y;Â 
}Â void isr_1 ()Â {Â 
y=Â â€3;Â 
z=Â 1;
}Â 
void isr_2 ()Â {Â 
if(z > 0)Â {Â 
y=Â 11;Â 
z=Â 0;Â 
}Â 
}7
8
9
1011
12
1314
15
161
2
34
5
6Initial Triggering
Atomicity Violation:
(y: R#4, W#13, R#5)
Final Triggering
Atomicity Violation:
(z: R#12, W#9, W#14)
int main ()Â {
...
closer3();
returnÂ 0;
}Â void closer1_isr ()Â {Â 
...
wdtpci_write_buf =Â 'Vâ€™;
...if(wdtpci_write_buf !=Â â€˜Vâ€™)Â {
...
}...
}Â 1121
...
1126
11271128954
...
957
...967
...
969...
984Final TriggeringAtomicity Violation: ( wdtpci_write_buf : W#957, W#989, R#967)
void closer2_isr ()Â {Â 
...
wdtpci_write_buf =Â â€˜Wâ€™;
...
}986...
989
...
1016Nested Interrupt
Figure 9: One atomicity violation detected in wdt_pci.
As an example, Fig. 9 shows one atomicity violation in package
wdt_pci. Since there is no shared variable in the main task, with
1161ESEC/FSE â€™23, December 3â€“9, 2023, San Francisco, CA, USA Yu, Tian, Xing, Yang, Su, Lu, Yang, Zhao, Li, Duan
the final ISR-triggering strategy, ğ‘ğ‘™ğ‘œğ‘ ğ‘’ğ‘Ÿ 1_ğ‘–ğ‘ ğ‘Ÿis triggered before the
main task returns. Further, in the case that ğ‘ğ‘™ğ‘œğ‘ ğ‘’ğ‘Ÿ 2_ğ‘–ğ‘ ğ‘Ÿis triggered
before line 967, an atomicity violation is detected. This detection is
meaningful, since the value change of ğ‘¤ğ‘‘ğ‘¡ğ‘ğ‘ğ‘– _ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’ _ğ‘ğ‘¢ğ‘“caused by
the preemption of ğ‘ğ‘™ğ‘œğ‘ ğ‘’ğ‘Ÿ 2_ğ‘–ğ‘ ğ‘Ÿmakes that the condition originally
expected to be unsatisfied in line 967 turns to be satisfied eventually.
From Tables 3 and 4, we can see that more atomicity violations
can be detected with the initial or final ISR-triggering strategy at
the cost of relatively longer runtime. This is understandable since
more cases should be considered and larger state space need to be
explored. In practice, we can initially refrain from utilizing these
two strategies for efficient detection. When no atomicity violation
is detected, we can further employ them for precise detection.
7 DISCUSSION
7.1 Soundness and Completeness
Theoretically, the reachability computation is supposed to be precise
during the ART generation for an interrupt-driven program. In
addition, considering most practical situations, each ISR is limited to
be triggered at most once along one path. Based on these premises,
we illustrate that our detection approach is sound and complete.
Fact 1. For a given path of the constructed ART of an interrupt-
driven program ğ‘ƒ, the proposed delayed ISR-triggering strategy iden-
tifies exactly each kind of unserializable interleaving pattern.
Proof. During the exploration of a given path of the ART, the de-
layed ISR-triggering strategy is employed for each selected interrup-
tion point. Specially, [Rule 1-D] is utilized to recognize Pattern:
(R,W,R) andPattern:(R,W,W) , while [Rule 2-D] is utilized to rec-
ognize Pattern:(W,R,W) andPattern:(W,W,R) , as shown in Fig.
10. With the delayed ISR-triggering strategy, once an unserializable
interleaving pattern is formed, the Algorithm PatternMatching is
invoked to detect the atomicity violation in time. [Rule 3-D] to
deal with enable_isr anddisable_isr can be illustrated similarly and
omitted here due to space consideration. â–¡
Pattern:(R,W,R)
Rule 1-Da1:R(x)a3:R(x)
a2:W(x)
Fig.Â 9Interruption 
PointTriggering 
State
â€¦Pattern:(R,W,W)
a1:R(x)a3:W(x)
a2:W(x)Interruption 
PointTriggering 
State
â€¦
Rule 2-DPattern:(W,R,W)
a1:W(x)a3:W(x)
a2:R(x)Interruption 
PointTriggering 
State
â€¦Pattern:(W,W,R)
a1:W(x)a3:R(x)
a2:W(x)Interruption 
PointTriggering 
State
â€¦
Figure 10: Delayed ISR-triggering strategy for each unserial-
izable interleaving pattern.
Fact 2. During the ART construction, the delayed ISR-triggering,
initial ISR-triggering and final ISR-triggering strategies can exactly
cover all kinds of cases that may result in atomicity violations.
Proof. Under the condition that each ISR is triggered at most
once in each path, we consider the atomicity violation cases caused
by two or three tasks ğ‘ƒğ‘–,ğ‘ƒğ‘—, andğ‘ƒğ‘˜âˆˆTask(ğ‘ƒ)with Pri(ğ‘ƒğ‘–)<
Pri(ğ‘ƒğ‘—)<Pri(ğ‘ƒğ‘˜). The schematic illustration of the utilized strategy
for each case is shown in Fig. 11.
(1) For tasks ğ‘ƒğ‘–andğ‘ƒğ‘—, there is only one case that may result in
atomicity violations as shown in Fig. 11(a).(2) For tasks ğ‘ƒğ‘–,ğ‘ƒğ‘—, andğ‘ƒğ‘˜, the following two cases may result
in atomicity violations: (2.1) Sequential interrupt. ğ‘ƒğ‘–is interrupted
byğ‘ƒğ‘—(orğ‘ƒğ‘˜) before the first access of the shared variable. After
this first access, ğ‘ƒğ‘–is again interrupted by ğ‘ƒğ‘˜(orğ‘ƒğ‘—) as shown in
Fig. 11(b). Other cases can be handled by the delayed ISR-triggering
strategy. (2.2) Nested interrupt. ğ‘ƒğ‘–is interrupted by ğ‘ƒğ‘—, andğ‘ƒğ‘—is
further interrupted by ğ‘ƒğ‘˜. Three possible cases are presented in
Fig. 11(c): (I) ğ‘ƒğ‘–is interrupted by ğ‘ƒğ‘—before the first access of the
shared variable; (II) ğ‘ƒğ‘–is interrupted by ğ‘ƒğ‘—after the last access of
the shared variable; (III) ğ‘ƒğ‘–is interrupted by ğ‘ƒğ‘—between the first
and final accesses of the shared variable. These cases can be dealt
with by the initial ISR-triggering, the final ISR-triggering, and the
delayed ISR-triggering strategies, respectively.
The cases for more tasks can be inferred in a similar way. â–¡
Pia1 a3
a2
Fig.Â 10â€¦
PjPia3
Pk Pjâ€¦a1
â€¦Pi a3
PkPja1Delayed ISR-triggering Delayed ISR-triggering Initial ISR-triggering
Delayed ISR-triggering(I) If this state is the first access:
Initial ISR-triggering(II) If this state is the last access:
Final ISR-triggering
(III) Other cases:
Delayed ISR-triggering(a) Atomicity violation caused by two tasks (b) Atomicity violation cause d by sequential interrupt 
of three tasks
(c) Atomicity violation caused by nested interrupt of three tasksa2
a2
Figure 11: Each possible atomicity violation case and the
corresponding strategy.
Facts 1 and 2 respectively state that our approach is sound and
complete to detect atomicity violations for each given path and
cover all cases possibly containing atomicity violations in the con-
structed ART. With this basis, on the premise of the precise reacha-
bility computation during the ART construction, it is straightfor-
ward to infer that our approach is sound and complete to detect
atomicity violations for an interrupt-driven program.
7.2 Limitations
In the above, we illustrate the soundness and completeness of our
approach under some prerequisites, which are also the limitations
possibly hindering the widespread application.
(1)Support for more complex ISR-triggering cases. Consid-
ering most practical situations, each ISR is limited to be triggered
at most once along each path in our approach. Although CPA4AV
is able to find all pre-set atomicity violations for the benchmark,
to deal with more complex ISR-triggering cases such as unlimited
interrupt times or interrupt reentry, effective strategies are required
to reduce the possible huge state space in future work.
(2)Precise and efficient analysis for complex data types.
During the implementation, CPA4AV is developed upon CPAchecker
where the inherent reachability computation is based on BDD or
explicit-value analysis. Although BDD is more efficient, complex
data types (e.g., struct, pointer, and array) are not fully supported
currently, making that 17 programs in Racebench 2.1 except those
shown in Table 1 cannot be detected. On the contrary, explicit-value
analysis ensures the scalability of our tool for real-world embedded
programs, but it is not efficient enough, resulting in 3 timeouts in
the experiment. In the future, reachability computation needs to be
further improved to support complex data types both precisely and
efficiently.
1162Detecting Atomicity Violations in Interrupt-Driven Programs via Interruption ... ESEC/FSE â€™23, December 3â€“9, 2023, San Francisco, CA, USA
8 RELATED WORK
As a kind of concurrency bugs, atomicity violations usually occur
in multi-threaded and interrupt-driven programs.
8.1 Atomicity Violation Detection in
Multi-threaded Programs
A considerable number of static and dynamic approaches have been
put forward to detect atomicity violations in multi-threaded pro-
grams. Among static approaches, Von Praun et al. [ 34] develop a
framework based on an abstract model of threads and data, and
Dias et al. [ 9] present a algorithm by statically analyzing the depen-
dency graph of program variables to detect atomicity violations.
Combining the source code analysis and data-mining techniques,
Lu et al. [ 24] automatically infer variable access correlations and
detect related atomicity violations. Flanagan et al. [ 15,16] and Sas-
turkar et al. [ 29] present different type systems for specifying the
atomicity of methods and uncovering atomicity violations for multi-
threaded Java programs. Huang et al. [ 18] model the access anomaly
prediction as a graph pattern search to predict possible atomicity
violations. Model checking methods are also proposed to check
atomicity. For example, with the partial order reduction strategy,
Hatcliff et al. [ 17] utilize Bogor to provide an effective means of
checking atomicity violations. Also, Flanagan [ 13] employs SPIN to
explore non-serial and serial executions simultaneously to detect
atomicity violations for a number of irreducible procedures.
In terms of dynamic detection, inspired from the Liptonâ€™s theory
of reduction and earlier dynamic race detectors, Flanagan et al.
[14] present a dynamic analysis for detecting errors caused by
unintended interactions between threads. Eslamimehr et al. [ 11]
describe a technique that directly searches three-access pattern
instances in the dynamic analysis. Ma et al. [ 26] maintain a reduced
set of increasing dependency sequences for each active transaction
to detect all atomicity violations in a trace. Based on happens-
before relations among events in an execution trace, Chang et al.
[5] identify pairs of events designed to be atomically processed, and
use predefined patterns to detect atomicity violations. By combining
static and dynamic analyses, Chen et al. [ 7] obtain summaries in
the static analysis and instantiate them with runtime values. Using
the coarse interleaving hypothesis, Kasikci et al. [ 19] develop a
hybrid dynamic-static interprocedural pointer and type analysis to
diagnose the root causes of concurrency bugs.
Due to the inevitable state-space explosion problem incurred by
possible interleaving of different threads, the static approaches to
detect atomicity violations in multi-threaded programs progress
much more slowly than dynamic approaches. Among these static
approaches, though some space reduction strategies, such as partial
order, have been proposed, the characteristics between the inter-
leaving of different threads have not been captured effectively. As
a result, there exist obstacles to conducting static analysis to detect
atomicity violations for multi-threaded programs. Compared with
multi-threaded programs, interrupt-driven programs have a rela-
tively smaller state space, which makes static analysis able to play
a role for interrupt-driven programs. However, interrupt-driven
programs differ from multi-threaded programs in the synchroniza-
tion mechanism and preemption relationship. It is still challenging
to apply the above approaches for multi-threaded programs to
interrupt-driven programs directly.8.2 Concurrency Bug Detection in
Interrupt-driven Programs
Several approaches have been proposed to detect concurrency bugs,
mainly data races, in interrupt-driven programs. For instance, based
on the disjoint blocks to define the synchronization with relation,
Chopra et al. [ 8] propose lockset-based analysis for race detection
in interrupt-driven kernels. Similarly, Tulsyanc et al. [ 32] introduce
the â€œoccurs-in-betweenâ€ relation to capture the interplay of various
synchronization mechanisms. In dynamic approaches, Chen et al.
[6] propose a runtime analysis approach to detect data races caused
by inconsistent lock protection. Sun et al. [ 30] present a set of
dynamic bug patterns to locate data races caused by buggy access
to shared resources. As a hybrid approach, Wang et al. [ 36,37,39]
combine static analysis and symbolic execution to generate input
data for exposing potential races. Bai et al. [ 2] utilize a static lockset
analysis to detect data races based on the runtime results.
In recent years, other kinds of severe concurrency bugs have
begun to be concerned in interrupt-driven programs. Among them,
atomicity violation is one of the most representatives. Du et al.
[10,12] propose a static analyser Rchecker on top of the bounded
model checker CBMC to search atomicity violations. However, false
positives are inevitable due to the nature of path constraint solving.
Besides, because of lacking effective strategies for pruning paths,
the extremely large state space makes it challenging in scalability. In
order to avoid the explicit-state exploration, intAtom [ 22] employs
a staged design for atomicity violation detection. It first identifies all
potential atomicity violations based on the data-flow analysis, and
then filters out those infeasible candidates. In this method, there
are still false positives due to the imprecise reachability analysis.
In addition, it can not deal with complex situations such as ISR-
triggering at the initial or final location of a task.
Different from Rchecker and intAtom, our approach first con-
structs the program model with the interruption points selected in
CFGs. Then, the reachability computation is performed to prune
infeasible paths and build up a whole abstract reachability tree, dur-
ing which the delayed ISR-triggering strategy is employed to trigger
enabled ISRs as late as possible. As a result, the state space can be
reduced significantly, meanwhile the precision can be guaranteed.
9 CONCLUSION AND FUTURE WORK
In this paper, we focus on the problem of detecting whether there
exist atomicity violations in interrupt-driven programs. With the
interruption point selecting strategy of our approach, redundant
ISR control-flows can be avoided from being introduced. In addition,
the explored state space of an ART can be greatly reduced with the
proposed delayed ISR-triggering strategy. The approach is evaluated
through extensive experiments.
In the near future, we will consider more complex ISR-triggering
cases such as unlimited interrupt times or interrupt reentry. More-
over, we plan to extend our tool to support more complex data
types for interrupt-driven programs both precisely and efficiently.
ACKNOWLEDGEMENT
This research is supported by the National Natural Science Foun-
dation of China with Grant No. 62192734, 62202361, 61972301 and
62172322, Science and Technology Plan Project of Xiâ€™an with Grant
No. 2022JH-RYFW-0010. Cong Tian is the corresponding author.
1163ESEC/FSE â€™23, December 3â€“9, 2023, San Francisco, CA, USA Yu, Tian, Xing, Yang, Su, Lu, Yang, Zhao, Li, Duan
REFERENCES
[1]Rahul Agarwal, Amit Sasturkar, Liqiang Wang, and Scott D Stoller. 2005. Opti-
mized run-time race detection and atomicity checking using partial discovered
types. In Proceedings of the 20th IEEE/ACM International Conference on Automated
Software Engineering (ASE) . 233â€“242. https://doi.org/10.1145/1101908.1101944
[2]Jiaju Bai, Qiuliang Chen, Zuming Jiang, Julia Lawall, and Shimin Hu. 2021. Hybrid
Static-Dynamic Analysis of Data Races Caused by Inconsistent Locking Discipline
in Device Drivers. IEEE Transactions on Software Engineering 48, 12 (2021), 5120â€“
5135. https://doi.org/10.1109/TSE.2021.3138735
[3]Dirk Beyer and M Erkan Keremoglu. 2011. CPAchecker: A tool for configurable
software verification. In Proceedings of the 23rd International Conference on Com-
puter Aided Verification (CAV) . Springer, 184â€“190. https://doi.org/10.1007/978-3-
642-22110-1_16
[4]Randal E Bryant. 1986. Graph-based algorithms for boolean function manipu-
lation. IEEE Trans. Comput. 100, 8 (1986), 677â€“691. https://doi.org/10.1109/TC.
1986.1676819
[5]Xiaoning Chang, Wensheng Dou, Yu Gao, Jie Wang, Jun Wei, and Tao Huang.
2019. Detecting atomicity violations for event-driven Node.js applications. In
Proceedings of the 41st International Conference on Software Engineering (ICSE) .
IEEE, 631â€“642. https://doi.org/10.1109/ICSE.2019.00073
[6]Qiuliang Chen, Jiaju Bai, Zuming Jiang, Julia Lawall, and Shimin Hu. 2019. De-
tecting data races caused by inconsistent lock protection in device drivers. In
Proceedings of the 26th IEEE International Conference on Software Analysis, Evolu-
tion and Reengineering (SANER) . IEEE, 366â€“376. https://doi.org/10.1109/SANER.
2019.8668017
[7]Qichang Chen, Liqiang Wang, Zijiang Yang, and Scott D Stoller. 2009. HAVE:
Detecting atomicity violations via integrated dynamic and static analysis. In
Proceedings of the 12th International Conference on Fundamental Approaches to
Software Engineering (FASE) . Springer, 425â€“439. https://doi.org/10.1007/978-3-
642-00593-0_30
[8]Nikita Chopra, Rekha Pai, and Deepak Dâ€™Souza. 2019. Data races and static anal-
ysis for interrupt-driven kernels. In Proceedings of the 28th European Symposium
on Programming (ESOP) . Springer, 697â€“723. https://doi.org/10.1007/978-3-030-
17184-1_25
[9]Ricardo J Dias, Vasco Pessanha, and JoÃ£o M LourenÃ§o. 2012. Precise detection
of atomicity violations. In Proceedings of the 8th International Haifa Verification
Conference on Hardware and Software (HVC) . Springer, 8â€“23. https://doi.org/10.
1007/978-3-642-39611-3_8
[10] Xiang Du, Liangze Yin, Haining Feng, and Wei Dong. 2021. Program verification
enhanced precise analysis of interrupt-driven program vulnerabilities. In Pro-
ceedings of the 28th Asia-Pacific Software Engineering Conference (APSEC) . IEEE,
253â€“263. https://doi.org/10.1109/APSEC53868.2021.00033
[11] Mahdi Eslamimehr, Mohsen Lesani, and George Edwards. 2018. Efficient detection
and validation of atomicity violations in concurrent programs. Journal of Systems
and Software 137 (2018), 618â€“635. https://doi.org/10.1016/j.jss.2017.06.001
[12] Haining Feng, Liangze Yin, Wenfeng Lin, Xudong Zhao, and Wei Dong. 2020.
Rchecker: A CBMC-based data race detector for interrupt-driven programs. In
Proceedings of the 20th International Conference on Software Quality, Reliability
and Security Companion (QRS-C) . IEEE, 465â€“471. https://doi.org/10.1109/QRS-
C51114.2020.00084
[13] Cormac Flanagan. 2004. Verifying commit-atomicity using model-checking. In
Proceedings of the 11th International SPIN Workshop (SPIN) . Springer, 252â€“266.
https://doi.org/10.1007/978-3-540-24732-6_18
[14] Cormac Flanagan and Stephen N Freund. 2004. Atomizer: A dynamic atomicity
checker for multithreaded programs. ACM SIGPLAN Notices 39, 1 (2004), 256â€“267.
https://doi.org/10.1145/982962.964023
[15] Cormac Flanagan, Stephen N Freund, Marina Lifshin, and Shaz Qadeer. 2008.
Types for atomicity: Static checking and inference for Java. ACM Transactions on
Programming Languages and Systems 30, 4 (2008), 1â€“53. https://doi.org/10.1145/
1377492.1377495
[16] Cormac Flanagan and Shaz Qadeer. 2003. A type and effect system for atomicity.
ACM SIGPLAN Notices 38, 5 (2003), 338â€“349. https://doi.org/10.1145/781131.
781169
[17] John Hatcliff and Matthew B Dwyer. 2004. Verifying atomicity specifications
for concurrent object-oriented software using model-checking. In Proceedings
of the 5th International Conference on Verification, Model Checking, and Abstract
Interpretation (VMCAI) . Springer, 175â€“190. https://doi.org/10.1007/978-3-540-
24622-0_16
[18] Jeff Huang and Charles Zhang. 2011. Persuasive prediction of concurrency access
anomalies. In Proceedings of the 20th International Symposium on Software Testing
and Analysis (ISSTA) . 144â€“154. https://doi.org/10.1145/2001420.2001438
[19] Baris Kasikci, Weidong Cui, Xinyang Ge, and Ben Niu. 2017. Lazy diagnosis of in-
production concurrency bugs. In Proceedings of the 26th Symposium on Operating
Systems Principles (SOSP) . 582â€“598. https://doi.org/10.1145/3132747.3132767
[20] Daniel Kroening, Lihao Liang, Tom Melham, Peter Schrammel, and Michael
Tautschnig. 2015. Effective verification of low-level software with nested inter-
rupts. In Proceedings of the 2015 Design, Automation & Test in Europe Conference& Exhibition (DATE) . IEEE, 229â€“234. https://doi.org/10.7873/DATE.2015.0360
[21] Daniel Kroening and Michael Tautschnig. 2014. CBMCâ€“C bounded model checker.
InProceedings of the 20th International Conference on Tools and Algorithms for
the Construction and Analysis of Systems (TACAS) . Springer, 389â€“391. https:
//doi.org/10.1007/978-3-642-54862-8_26
[22] Chao Li, Rui Chen, Boxiang Wang, Tingting Yu, Dongdong Gao, and Mengfei
Yang. 2022. Precise and efficient atomicity violation detection for interrupt-
driven programs via staged path pruning. In Proceedings of the 31st ACM SIGSOFT
International Symposium on Software Testing and Analysis (ISSTA) . 506â€“518. https:
//doi.org/10.1145/3533767.3534412
[23] Lihao Liang, Tom Melham, Daniel Kroening, Peter Schrammel, and Michael
Tautschnig. 2017. Effective verification for low-level software with competing
interrupts. ACM Transactions on Embedded Computing Systems 17, 2 (2017), 1â€“26.
https://doi.org/10.1145/3147432
[24] Shan Lu, Soyeon Park, Chongfeng Hu, Xiao Ma, Weihang Jiang, Zhenmin Li,
Raluca A Popa, and Yuanyuan Zhou. 2007. MUVI: Automatically inferring multi-
variable access correlations and detecting related semantic and concurrency bugs.
InProceedings of 21st ACM SIGOPS Symposium on Operating Systems Principles
(SOSP) . 103â€“116. https://doi.org/10.1145/1323293.1294272
[25] Shan Lu, Joseph Tucek, Feng Qin, and Yuanyuan Zhou. 2006. AVIO: Detecting
atomicity violations via access interleaving invariants. ACM SIGOPS Operating
Systems Review 40, 5 (2006), 37â€“48. https://doi.org/10.1145/1168917.1168864
[26] Xiaoxue Ma, Imran Ashraf, and W. K. Chan. 2022. Davida: A Decentralization
Approach to Localizing Transaction Sequences for Debugging Transactional
Atomicity Violations. IEEE Transactions on Reliability (2022), 1â€“19. https:
//doi.org/10.1109/TR.2022.3176680
[27] Minxue Pan, Shouyu Chen, Yu Pei, Tian Zhang, and Xuandong Li. 2019. Easy
modelling and verification of unpredictable and preemptive interrupt-driven
systems. In Proceedings of the 41st IEEE/ACM International Conference on Software
Engineering (ICSE) . IEEE, 212â€“222. https://doi.org/10.1109/ICSE.2019.00037
[28] John Regehr. 2005. Random testing of interrupt-driven software. In Proceedings of
the 5th ACM International Conference on Embedded Software (EMSOFT) . 290â€“298.
https://doi.org/10.1145/1086228.1086282
[29] Amit Sasturkar, Rahul Agarwal, Liqiang Wang, and Scott D Stoller. 2005. Auto-
mated type-based analysis of data races and atomicity. In Proceedings of the 10th
ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming
(PPoPP) . 83â€“94. https://doi.org/10.1145/1065944.1065956
[30] Yuxia Sun, Shing-Chi Cheung, Song Guo, and Ming Cheng. 2019. Disclosing and
Locating Concurrency Bugs of Interrupt-Driven IoT Programs. IEEE Internet of
Things Journal 6, 5 (2019), 8945â€“8957. https://doi.org/10.1109/JIOT.2019.2925291
[31] Chungha Sung, Markus Kusano, and Chao Wang. 2017. Modular verification
of interrupt-driven software. In Proceedings of the 32nd IEEE/ACM International
Conference on Automated Software Engineering (ASE) . IEEE, 206â€“216. https:
//doi.org/10.1109/ASE.2017.8115634
[32] Rishi Tulsyan, Rekha R. Pai, and Deepak Dâ€™Souza. 2020. Static Race Detection
for RTOS Applications. In Proceedings of the 40th IARCS Annual Conference on
Foundations of Software Technology and Theoretical Computer Science (FSTTCS) ,
Vol. 182. 57:1â€“57:20. https://doi.org/10.48550/arXiv.2010.02642
[33] Mandana Vaziri, Frank Tip, and Julian Dolby. 2006. Associating synchronization
constraints with data in an object-oriented language. ACM SIGPLAN Notices 41,
1 (2006), 334â€“345. https://doi.org/10.1145/1111320.1111067
[34] Christoph Von Praun and Thomas R Gross. 2004. Static Detection of Atomicity
Violations in Object-Oriented Programs. Journal of Object Technology 3, 6 (2004),
103â€“122. https://doi.org/10.5381/jot.2004.3.6.a5
[35] Liqiang Wang and Scott D Stoller. 2006. Accurate and efficient runtime detection
of atomicity errors in concurrent programs. In Proceedings of the 11th ACM
SIGPLAN Symposium on Principles and Practice of Parallel Programming (PPoPP) .
137â€“146. https://doi.org/10.1145/1122971.1122993
[36] Yu Wang, Junjing Shi, Linzhang Wang, Jianhua Zhao, and Xuandong Li. 2015.
Detecting data races in interrupt-driven programs based on static analysis and
dynamic simulation. In Proceedings of the 7th Asia-Pacific Symposium on Internet-
ware (Internetware) . 199â€“202. https://doi.org/10.1145/2875913.2875943
[37] Yu Wang, Linzhang Wang, Tingting Yu, Jianhua Zhao, and Xuandong Li. 2017.
Automatic detection and validation of race conditions in interrupt-driven embed-
ded software. In Proceedings of the 26th ACM SIGSOFT International Symposium on
Software Testing and Analysis (ISSTA) . 113â€“124. https://doi.org/10.1145/3092703.
3092724
[38] Mengfei Yang, Bin Gu, Zhenhua Duan, Zhi Jin, Naijun Zhan, Yunwei Dong, Cong
Tian, Ge Li, and Xiaogang Dong. 2022. Intelligent program synthesis framework
and key scientific problems for embedded software. Chinese Space Science and
Technology 42, 4 (2022), 1â€“6. https://doi.org/10.16708/j.cnki.1000-758X.2022.0046
[39] WANG Yu, Fengjuan Gao, Linzhang Wang, Tingting Yu, Jianhua Zhao, and
Xuandong Li. 2022. Automatic detection, validation and repair of race conditions
in interrupt-driven embedded software. IEEE Transactions on Software Engineering
48, 2 (2022), 346â€“363. https://doi.org/10.1109/TSE.2020.2989171
Received 2023-03-02; accepted 2023-07-27
1164