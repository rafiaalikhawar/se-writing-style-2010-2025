Crystallizer : A HybridPath Analysis FrameworktoAidin
Uncovering DeserializationVulnerabilities
Prashast Srivastava
PurdueUniversity
UnitedStatesFlavioToﬀalini
EPFL
SwitzerlandKostyantynVorobyov
OracleLabs
Australia
FrançoisGauthier
OracleLabs
AustraliaAntonioBianchi
PurdueUniversity
UnitedStatesMathiasPayer
EPFL
Switzerland
ABSTRACT
Applications use serialization and deserialization to exchange data.
Serializationallowsdeveloperstoexchangemessagesorperform
remotemethodinvocationindistributedapplications.However,the
application logic itself is responsible for security. Adversaries may
abuse bugs inthe deserializationlogicto forciblyinvoke attacker-
controlledmethods bycraftingmalicious bytestreams (payloads).
Crystallizer presentsanovelhybridframeworktoautomati-
callyuncoverdeserializationvulnerabilitiesbycombiningstaticand
dynamic analyses. Our intuition is to ﬁrst over-approximate possi-
ble payloads through static analysis (to constrain the search space).
Then, we use dynamic analysis to instantiate concrete payloads as
aproof-of-conceptofavulnerability(givingtheanalystconcrete
examplesofpossibleattacks).Ourproof-of-conceptfocusesonJava
deserialization as the imminent domain ofsuch attacks.
WeevaluateourprototypeonsevenpopularJavalibrariesagainst
state-of-the-artframeworksforuncoveringgadgetchains.Incon-
trast to existing tools, we uncovered 41 previously unknown ex-
ploitable chains. Furthermore, we show the real-world security
impact of Crystallizer by using it to synthesize gadget chains to
mountRCEandDoSattacksonthreepopularJavaapplications.We
have responsibly disclosedallnewlydiscoveredvulnerabilities.
CCSCONCEPTS
•Security andprivacy →Software andapplication security .
KEYWORDS
Deserialization vulnerabiltiies, Java,hybridanalysis
ACM Reference Format:
PrashastSrivastava,FlavioToﬀalini,KostyantynVorobyov,FrançoisGau-
thier,AntonioBianchi,andMathiasPayer.2023. Crystallizer :AHybrid
Path Analysis Framework to Aid in Uncovering Deserialization Vulnera-
bilities. In Proceedings of the 31st ACM Joint European Software Engineering
ConferenceandSymposium on the Foundations of SoftwareEngineering (ES-
EC/FSE’23),December3–9,2023,SanFrancisco,CA,USA. ACM,NewYork,
NY, USA, 12pages.https://doi.org/10.1145/3611643.3616313
ESEC/FSE ’23, December 3–9, 2023, San Francisco, CA,USA
©2023 Copyright heldby theowner/author(s).
ACM ISBN 979-8-4007-0327-0/23/12.
https://doi.org/10.1145/3611643.36163131 INTRODUCTION
Serialization is a key feature in modern languages ( e.g.,Java, C#, or
PHP) that enables cross-platformcommunication,remotemethod
invocations, and object persistence. Serialization converts object
graphsintobytestreams.Symmetricallytoserialization,deserial-
ization rebuilds the original object graph from the bytestream. By
default, deserialization ensures that the deserialized objects are
valid but it does not enforce security constraints. Security (both
during and after deserialization) is the sole responsibility of the
application logic. Incomplete security checks allow attackers to
bendthecontrol-ﬂow/data-ﬂowofaprogram.Theseattackscanhi-
jack the deserialization process, granting the attacker remote code
execution(RCE),denialofservice(DoS),orinformationpersistence
capabilities such as Arbitrary File Writes (AFW). Deserialization
vulnerabilitieshave showncatastrophic security impact[ 24].E.g.,
the Equifax data breach [ 16] was caused by a deserialization vul-
nerability enabling RCE in the [ 36]. More recently, the Log4Shell
vulnerability in the widely used Log4j2library can be exploited
in newer versions of the JDK that were previously thought safe by
leveragingdeserialization-basedattackvectors [ 28].
Payloadsfordeserializationattacksarecomposedofnestedob-
jects that, when deserialized, force the application to invoke an
attacker-controlledsequenceofmethods,alsocalleda gadgetchain.
The last gadget of the chain is usually called sinkand may invoke
system functions, e.g.,Runtime.exec() with attacker-speciﬁed ar-
guments, allowing the attacker to execute arbitrary system com-
mands. The gadgets in the deserialization domain are conceptually
similar to gadgets in Return-Oriented Programming (ROP) [ 48,51]
for binary exploitation: small pieces of code in the vulnerable pro-
gramthatarestitchedtogetherbyanattacker.However,deserial-
izationgadgetsdonotoperateatthemachinecodelevel,instead,
they bend the serialization logic to express malicious actions.
Attackchainsheavilydependontheapplicationlogic.Therefore,
ﬁnding such gadget combinations that bypass the application logic
iscrucialtoﬁxvulnerabilities.Asofnow,discoveringdeserializa-
tion vulnerabilities is predominantly manual and requires solving
three main challenges:
C1. Sink Gadgets Identiﬁcation: New sink gadgets that are use-
fultotheattackerarecurrentlyidentiﬁedthroughheuristics, e.g.,
marking calls to Runtime.exec() . However, we observe this ap-
proachoverlooksnon-trivialsinksandinhibitsdiscoveringother
interesting types ofattacks ( e.g.,DoS).
Thiswork islicensedunderaCreativeCommonsAttribution4.0Interna-
tional License.
1586
ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA PrashastSrivastava, Flavio Toﬀalini, KostyantynVorobyov, François Gauthier, Antonio Bianchi, andMathiasPayer
C2. Large State Space: The search space for gadget chains in
current applications is massive with thousands of gadget combina-
tions.Thismakesﬁndingagadgetchainthatcanbeusedtomount
adeserializationattackisakinto ﬁndinganeedleinahaystack.
C3.ComplexPayloadCreation: Deserializationpayloadsrequire
careful instantiation of classes and arguments that obey the execu-
tionconstraintsofthegadgetchain.Consequently,validbytestream
creation becomes exceedingly complex due to the large number of
possible combinationsthat nestedobjectscan assume.
To overcome the aforementioned challenges, we design Crys-
tallizer: a hybrid framework that combines static and dynamic
analysistosynthesizeconcretepayloadsforgadgetchainsandﬁnd
deserialization vulnerabilities automatically. First, our framework
identiﬁes new sink gadgets in an application. Then, it uses static
analysis to construct a gadget graph : a data structure that encodes
all possible gadget chains within a target software (up to a certain
length). This greatly reduces the explorable state space for gadget
chains.Crystallizer creates payloads as bytestreams out of the
reduced state space dynamically. Ourframework synthesizes pay-
loadsinachain-awaremanner:itkeepstrackoftheexecutionchain
orderandperformsabest-eﬀortapproachtocreatewell-formedar-
gumentsforeachofthegadgetswhileobeyinglanguagesemantics.
We implement our proof-of-concept tool for Java as it is widely
adoptedas the backbone for software development[ 9,50].
We evaluate Crystallizer on seven librariesand three applica-
tions. Across theseven libraries, it ﬁnds 41 new chains in addition
tosevenpreviouslyknowngadgetchains[ 22].Thisdemonstrates
Crystallizer ’s ability to ﬁnd both existing and new gadget chains
automatically.Furthermore,wecompare Crystallizer againsttwo
state-of-the-art tools [ 26,47] for ﬁnding Java-based deserialization
vulnerabilities and showcase that Crystallizer drastically out-
performs existing state-of-the-art in terms of ﬁnding exploitable
gadget chains. Finally, we showcase the real-world security impact
ofCrystallizer bysynthesizingpayloadsthatweusetodemon-
strateDoSandRCEattacksonthreepopularJavaapplications.The
correspondingproof-of-conceptexploitswereresponsiblydisclosed.
In summary,this paper makesthe following contributions:
•We perform a systematic analysis of how deserialization
vulnerabilities manifest themselves in the form of gadget
chains, including challenges to uncover them automatically.
•We present Crystallizer , a hybrid framework to automati-
cally uncover deserialization vulnerabilities by crafting pay-
loads that exercise gadgetchains inthe target.
•Weevaluateitagainstsevenlibrariesandﬁnd41newchains
inadditionto seven previously knownchains.
•Crystallizer outperforms state-of-the-art tools for ﬁnding
Java-baseddeserializationvulnerabilitiesanddemonstrate
real-world security impact by using it to mount DoS and
RCEattacksonthree popular real-world applications.
•All our evaluation artifacts along with the source code of
our framework are made available at https://github.com/
HexHive/Crystallizer .
2 DESERIALIZATION ATTACKS
WediscussthebasicsofJavaserialization.Then,weestablishtermi-
nologyrelevanttodeserializationattacksandshowcaseanexampleattack on a popular Java-based library Apache Commons Collec-
tions[1]. Finally,we discuss domain-speciﬁc challenges.
2.1 SerializationandDeserialization
Serializationistheactionoftransformingobjectsintoabytestream.
Deserialization later rebuildsthe objectsfrom the received stream.
Serialization for Java employs the Serializable interface [ 38].
Serialized objects of classes that implement this interface can be
createdusingthe writeObject methodprovidedbytheJDK[ 40].
The method encodes the object’s ﬁelds into a bytestream to, e.g.,
senditacrossthenetworkorstoreitintoaﬁle.Ontheotherend,
the method readObject [39] deserializes the byte stream and re-
builds the original object automatically. Note that the deserialized
object’sclassmustbeinthe classpath [42],otherwisedeserializa-
tion fails. Javaallows specifyingcustomserializationanddeserial-
izationroutinestoinstructthereceiverapplicationaboutcustom
dataprocessing, i.e.,post-processingdatawhileﬁllinganobject’s
ﬁelds.Asthese mechanismsallow greatﬂexibility,theyalsoleave
alarge exploitableattacksurface.
2.2 Payload Formalization
Letusestablishterminologyrelevanttodeserializationattacks.A
gadgetisanyinvokedmethodduringdeserialization.Itformsthe
basic building block for an attack. A gadget chain corresponds to a
sequenceofmethodinvocationstriggeredupondeserializationof
apayload.Payloadrefers to a bytestream corresponding to a set of
serializednestedobjects.Apayloadthatexploitsadeserialization
vulnerability forces the application to call an attacker-speciﬁed
gadgetchainwhichcanbeusedtomountanattack, e.g.,RCE.In
general, a deserialization attack is possible because the deserializa-
tion process automatically rebuilds the received object from the
attacker-speciﬁed bytestream and, in doing so, potentially enables
attacker-speciﬁedcode to be executed.
Gadgetsfallintothreecategories[ 35]:(i)TriggerGadgets are
theﬁrstelementsinvokedduringdeserializationandserveasthe
attack’s entry points. In Java, such gadgets are usually classes that
overridespeciﬁcmagicmethods( e.g.,readObject() ).Customdese-
rializationroutinesoperateondatathatmaybeattacker-controlled
allowingthetriggergadgetstokickstartachain,(ii) LinkGadgets
orchestrate the ﬂow of attacker-controlled data from a trigger to a
sinkgadget,and(iii) SinkGadgets launchtheattackbyrunning
attacker-speciﬁedmalicious actions.
OurGadget Graph represents an over-approximation of all the
possiblegadgets chains in a program. Hence, a payload exercises
onlyaspeciﬁcpathinthegraphbetweenthetriggergadgetandthe
sinkgadget.Sincegadgetsarethemethodsexecutedthroughthe
standarddeserializationprocess,wemodelthegadgetgraphasa
subcomponentoftheapplicationcallgraphwhosenodesaremarked
as gadgets (trigger, link, or sink). §3.1describes our approach to
extracting the gadgetgraph.
2.3 Payload Example
We present a known deserialization attack on Apache Commons
Collections libraryexplaining:(i)executionﬂowofagadgetchain
vulnerable to a deserialization attack, and (ii) the creation of a
payloadthat exercises this vulnerable chain.
1587Crystallizer : A Hybrid Path Analysis Framework to Aid in UncoveringDeserialization Vulnerabilities ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA
 BadAttributeValueExpException {
 
   void readObject(ObjectInputStream ois) { // trigger gadget
     Object valObj = ois.readField("val");
  valObj.toString();  // valObj instance of TiedMapEntry
   }
} TiedMapEntry {
   String toString() { // link gadget
  this.getValue();
   }
   Object getValue() { // link gadget
  // this.map instance of LazyMap
  // this.key instance of String ("foo")
  this.map.get(this.key);                              
   }
} LazyMap {
   Object get(Object key) { // sink gadget
     // the transformer triggers a command
  Object val = this.factory.transform(this.key);
   }
 } // An application invokes .readObject() 
 // to deserialize the byte stream ois
 BadAttributeValueExpException.readObject(ois);
➊
➋
➌
➍
➎
Figure1:Asimpliﬁedexampleforthegadgetchainexecuted
upon thepayload( Listing 1 ) being deserialized.
Figure 1shows the vulnerable gadget chain. The readObject()
(1) method of the BadAttributeValueExpException class is ex-
ecuted ﬁrst, making it the trigger gadget. This gadget rebuilds
the object (instance of BadAttributeValueExpException ) from
the bytestream and invokes a toString() method on one of its
ﬁeldmembers( val). The object valObjis an instanceoftheclass
TiedMapEntry ,thenitstoString() methodiscalled( 2)whichin
turncallsits getValue() method.The getValue() methodretries
akeyfromamap( 3).Ifthemapisaninstanceof LazyMap,itwill
trytobuildanitemcorrespondingtothekeyparameter “foo”(4)
by using a Transformer class whose object can be instantiated in
such a way that the item building performs RCE ( 5). Since exe-
cuting the gadget get()method inside the LazyMap can lead to
RCE [32], we categorize it as a sink gadget. The gadgets belonging
toTiedMapEntry are referred to as link gadgets since they chain
the invocation from the trigger gadgetto the sink gadget.
Thegadgetchainhighlightstwokeyobservations:(i)thegadget
chain is a subgraph of the application callgraph, and (ii) exercising
this gadget chain requires a bytestream that is crafted from a set of
nestedobjectsinsuchawaythattheabovegadgetchainisinvoked.
Thepayloadthatexercisestheabove-mentionedgadgetchain
to achieve RCE is shown in Listing 1. The ﬁrst step is to instantiate
aTransformer that executes exec("/bin/bash") (Line8). The
Transformer isthenusedtoinstantiatea LazyMap object(Line 12).
TheLazyMapautomatically instantiates any missing entry using
theTransformer class instance; thus invoking exec(). We then
usetheLazyMap tobuilda TiedMapEntry (Line14)andbindittoa
BadAttributeValueExpException instance(Line 17).Speciﬁcally,
this class overrides the readObject() method and acts as our trig-
ger gadget. valis the ﬁnal payload which is serialized (Line 21) to
abytestream,ready to be sentto avulnerable application.1// command to execute
2finalString[]execArgs = {"/bin/bash" };
3
4// Preparing object for Transformer which
5// is used inside the sink gadget to grant RCE to an attacker
6finalTransformer []transformers =newTransformer [] {
7 newInvokerTransformer ("exec",newClass[]
8 {String.class},execArgs ),/*...*/ };
9
10finalMap innerMap =newHashMap();
11// Preparing object for LazyMap which acts as the sink gadget
12finalMap lazyMap =newLazyMap(innerMap ,transformers );
13// Prepraring object corresponding to a link gadget
14TiedMapEntry entry =newTiedMapEntry (lazyMap,"foo");
15
16// Preparing object corresponding to the trigger gadget
17BadAttributeValueExpException val =newBadAttributeValueExpException (val);
18
19ObjectOutputStream os =newObjectOutputStream (new
FileOutputStream ("payload.bin" )); ↩→
20// Writing the object into serialized bytestream (payload)
21os.writeObject (val);
Listing1:SimpliﬁedJavacodecreatingthepayloadtargeting
Apache Commons Collection .Figure 1 describes the observed
controlﬂow execution upon deserializing thispayload.
2.4 Challenges
Recallingtheexamplein Listing1,weidentifythreemainchallenges
forautomatingchaincreation:sinkgadgetidentiﬁcation,largestate
space,andcomplex payloadgeneration.
C1Sink GadgetsIdentiﬁcation. Whiletrigger gadgetsare easy
to locate( i.e.,they are overrides of known magic methods such as
readObject() ),linkgadgetsaregenericnodesinagadgetgraph.
Identifying sink gadgets requires non-trivial code knowledge. Pre-
vious works use heuristics [ 26] to locate the usage of speciﬁc func-
tions (e.g.,Runtime.exec() ). However, we observe that they over-
lookalargegroupofalternatesinks.Therefore,weadoptabroader
deﬁnition:agadgetisconsideredasinkifitmayoperateonobjects
ofanytype. We identify such gadgets by checking if they may use
objectsoftype Object[41]. SinceObjectcorrespondsto the root
of the class object hierarchy, a gadget operatingon this type can
operate on objects of any class. We chose this deﬁnition because
(i)itmayresultinahigherchanceofmanipulatingthegadgetto
perform attacker-speciﬁed functionality, and (ii) it allows Crystal-
lizertotargetandﬁndawidespectrumofthreats( e.g.,logic-based
DoS chains) that were missedbyprevious works.
C2 Large State Space. To estimate the explorable state space of
gadgetchains,weconductapreliminaryanalysisin ApacheCom-
mons Collections . First, we extract a callgraph through Soot [ 52]
and then build a gadget graph on top of it (see §3.1). The callgraph
consistsof 2,009gadgetsand 38,579edges.Ouranalysisreduces
thislargespaceto 295gadgetsand 2,168edgesinourgadgetgraph.
Even within agadgetgraph, the number ofcandidate chains to
be explored is still large, thus necessitating automated exploration.
Wequantiﬁedcandidategadgetchainsinthisgadgetgraphfrom
trigger to sink gadgets using a Djikstra-like algorithm [ 23]. To
keeptheanalysis concise,we upper-boundthe maximum length
of discovered candidate chains. For a maximum path length of 5,
there are 25,866candidate chains to be explored.
C3 Complex Payload Generation. Payloads are composed of
well-formed objects that obey the execution constraints of the gad-
getchain.In Listing1,aLazyMapobjectrequiresinstancesof Map
1588ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA PrashastSrivastava, Flavio Toﬀalini, KostyantynVorobyov, François Gauthier, Antonio Bianchi, andMathiasPayer
andTransformer to be passed to its constructor (Line 14). More-
over,weneedtoobeythelanguagesemanticsandpassobjectsas
arguments that implement the respective MapandTransformer
interfaces. Next, as we create the object for the predecessor gadget
(TiedMap), we must ensure that the previously created object for
LazyMapis correctly passed as an argument. Therefore, building
concretepayloadsthatexercisegadgetchainsischallengingbecause
it requires: (i) inference of correct parameters and (ii) instantiation
ofvalid connections between objects.
3CRYSTALLIZER DESIGN
Crystallizer isahybridpathanalysisframeworktoautomatically
uncover deserialization vulnerabilities by ﬁnding gadget chains
intargets.Givenagadgetgraph,ourintuitionistoautomatically
identify the sink gadgets and then ﬁnd possible paths leading to
sinks that can be instantiatedas asetofconnectedobjects( §2.3).
Crystallizer produces payloads as long as there exists a se-
quenceofgadgetsthatreachasink. Crystallizer takesinforma-
tion about trigger gadgets and a target as input, then it outputs
concrete payloads that execute the gadget chain, demonstrating
potentiallyexploitablegadgetchains.Developerscanusethisinfor-
mationtopatchdeserializationbugs;attackerscanuseadjustthe
parameters to ﬁne-tune the execution of the chain. Figure 2shows
an overview of Crystallizer ’s three components: Static Analysis
Module ( 1inFigure 2), Sink Identiﬁcation ( 2inFigure 2), and
the ProbabilisticConcretizationphase( 3inFigure 2).
3.1 Static Analysis Module
This module takes a library and information about trigger gadgets
asinputandproducesagadgetgraph.Theinformationprovided
abouttriggergadgetsisintheformofmethodsinvokedbyatrigger
gadget.Crystallizer usesthis information to automatically infer
which methods in a library can be used as entry points. Looking
at our example in §2.3, alltoString methods present in the target
libraryaretreatedasentrypointsintothetargetlibrary.Leveraging
thisabstractedviewofthetriggergadgetsisinlinewithpriorworks
for automateddiscovery ofdeserializationattacks[ 11,47].
We buildthegadgetgraph infoursteps.(i)We extractanover-
approximatedcallgraphusingClassHierarchyAnalysis(CHA)[ 18]
from the target software using the entry points described above,
(ii) In the callgraph, we select all classes that implement the Se-
rializable interface directly or through one of their ancestors
(§2.1),andmarkalltheirmethodsasgadgets,(iii)Weusethetrigger
gadgetinformationtomarktheentrypointsinthegadgetgraph
accordingly,whilewemarkalltheothernodesaslinkgadgets,and
(iv) Finally, we discard all nodes that are unreachable from trigger
gadgets.Thegadgetgraphproducedbythismodulehasonlythe
entrypointsand linkgadgetsmarked,whilewemark thesinksin
this gadgetgraph withthe helpofthe SinkIdentiﬁcationmodule.
3.2 SinkIdentiﬁcation
Startingfromthe StaticAnalysisModule’sgadgetgraph,we infer
which gadgets can be used as sinks. Here, we describe the sink def-
inition in §2.4: gadgets that use arbitrary class objects. Our module
enablesCrystallizer to identify sinks for RCE, DoS, or AFW. We
ﬁnally markthe sink gadgetsinthe gadgetgraph accordingly.Toinfersinkgadgets, Crystallizer performsatwo-stepprocess.
First,itdynamicallyinferscandidategadgetsthatmayusearbitrary
objects. Second, a set of static ﬁlters validates if the candidate gad-
gets use arbitrary objects. The candidate gadgets not ﬁltered out
areﬂaggedassinkgadgets.Thedynamicinferencegivesinitialevi-
dence of whether a gadget may perform malicious actions and the
staticinference incorporatesaccess patterns to increaseprecision.
DynamicInference .Crystallizer ﬂagsgadgetsthatmayuse
an arbitrary object either as one of its declaring classes’ ﬁelds or
as a method parameter passed to the gadget itself. It performs this
dynamic inference with the help of a honeypot class—a serializable
classthatraisesanexceptionwheninstantiated. Crystallizer ran-
domly picks one of the reachable gadgets from the gadget graph
and ﬂags it as a candidate for static ﬁltering if it can instantiate an
object of the honeypot class into (i) one of the ﬁeld members of
thedeclaring class, or (ii) one ofthe method parameterscan be in-
stantiated with the honeypot class. Crystallizer ﬂags a candidate
gadget,ifone ofthe previoustwo conditionsis fulﬁlled. Crystal-
lizeralso logs the argument type through which the honeypot
class was instantiated (referred to as the taintedargument type).
Thisinformationisusedduringthestaticﬁlteringphaseformaking
Crystallizer more precise inidentifying sink gadgets.
StaticFiltering .Theﬂaggedcandidatesmustpassasetofstatic
ﬁlters.Thesestaticﬁltersarenecessarytoweedoutgadgetsthatdo
not usetaintedarguments. The ﬁlters are based on the characteris-
ticsofknownsinks.Weusetheargumenttypeinsteadoftheactual
argumentthroughwhichthehoneypotclasswasinstantiatedfor
ﬁlteringsincetherecanexistmultiplearguments(ﬁeldmembersor
method parameters) of the same type. If a candidate gadget passes
throughanyofthestaticﬁltersthenitisﬂaggedasasinkgadget.
Incaseaﬁeldmemberwasusedtoloadinthehoneypotclass,we
applyasetofthreeﬁlters:(i)Weﬂaggadgetsthatdirectlyrefertoa
ﬁeld having the same type as the tainted argument. (ii) We extend
thepreviousanalysistoallreachablemethodsusingaﬁeldwiththe
sametaintedargumenttype.(iii)Wealsoﬂaggadgetsthatindirectly
usethetaintedargument.Weidentifyindirectusagebycheckingif
thetaintedargumentiscasttoanothertypeintheclassconstructor
and then see usage for this new type in the gadget. However, in
casetheargumentisloadedinthroughamethodparameterthen
we ﬂag the gadget if any of the method parameters corresponding
to the taintedargument were usedinamethodinvocation.
3.3 ProbabilisticConcretization
Leveraging the gadget graph, we propose a probabilistic method to
generatepayloadsthattriggerdeserializationvulnerabilities.We
achieve this goal by using three modules. First, we use a Candi-
dateChainExtractormoduletoﬁndagadgetchainthatconnects
a trigger and a sink. Second, we feed the candidate chains to a
Dynamic Analysis Module, which attempts to create a payload for
the corresponding chains. Finally, we submit the payload to the
DeserializationProbingmodulethatdeserializesthepayloadand
returnsfeedbacktotheDynamicAnalysisModule.Thefeedback
canbeadjustedaccordingtothethreatmodelandrecognizechains
exhibiting the intended behavior. Speciﬁcally, we show how adopt-
ing diﬀerent heuristics enables us to identify RCE, AFW, or DoS
1589Crystallizer : A Hybrid Path Analysis Framework to Aid in UncoveringDeserialization Vulnerabilities ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA
Static Analysis 
Module
Payload FeedbackDeserialization 
Vulnerability➊
Probabilistic ConcretizationDeserialization 
ProbingDynamic Analysis 
ModuleCandidate Chains 
ExtractionlibraryTrigger 
Gadgets
➌Gadget Graph
Gadget Graph Legend:
Trigger Sink LinkSink 
Identification➋Gadget Graph
Figure 2:Architectural overview of Crystallizer .
chains.Crystallizer adopts a dynamic approach to concretiza-
tion to ensure that it only reports chains for which it can create
payloads that exercise them. This is in stark contrast to purely
static approaches that are plagued with falsepositives, i.e.,report-
ing chains that cannot really be exercised due to not taking into
considerationtheexecutionconstraintsofthechainorthelanguage
semantics (discussedin §5.3)
Candidate Chain Extractor .This module uses a Djikstra-like
algorithm [ 23]to identifycandidategadgetchains that mappaths
from entry points to sink gadgets. We further deﬁne a threshold to
upper-boundthelengthofcandidatechains.Withoutthisthreshold,
thestatespaceofcandidategadgetchainswouldbecomeintractable
foranexhaustiveexploration.Inourexperiments,wesetathreshold
ofuptoﬁvegadgetsasinspiredbyknownexploitablegadgetchains.
DynamicAnalysisModule .Agadgetchainisfullyconcretized
if there exists an input payload that exercises the gadget chain
whenpassedtoadeserializationentrypoint.Toconcretizeagadget
chain,weinstantiateobjectsforeachofthegadgetsinthechain.The
objectsmustprovidetwoprerequisites:language-speciﬁc(inour
caseJava): createwell-formedfor declaringclassesofthegadgets,
and chain-speciﬁc: instantiate the objects in such a way that the
executionﬂowssuccessfully from one gadgetto another.
Basedontheinsightdescribedabove,wepresentourconcretiza-
tion methodology for gadget chains in Algorithm 1 . The procedure
takes as input a candidate gadget chain and outputs a payload
that can be tested by the Deserialization Probing module. The con-
cretizationprocessinstantiatesthenodesinreverseorder, i.e.,from
sink to target (Line 4). We adopt this strategy to fulﬁll the chain-
speciﬁc prerequisite described previously. Furthermore, this allows
the algorithm to terminateearly if noobjectscan be instantiated.
To satisfy chain-speciﬁc prerequisites, Crystallizer uses an
objectcache tostorepreviouslyinstantiatedobjects.Whenanodeis
passedtothe ObjectFactory forinstantiation(Line 11),itchecksif
the object cache contains an object of the same type, or can be cast
into,therequestednode.Iftheseconditionsaremet,wedistinguish
twocases.(i)Theobjecthasthesametypeastherequestednode.
Thus, we reuse it as is (Line 15). (ii) The object can be cast into
therequestednodetype.Thus,werandomlycreateanewobject
or return the existing one from the cache (Line 17). We perform
thisactionrandomlyinsteadofinaguidedmannersincereason-
ingaboutthesemanticsismoreexpensivethanjustexercisingall
possiblecombinations.Iftheobjectcachedoesnotcontainsuitable
objects, then we instantiate a new node (Line 20) by satisfyingAlgorithm1 DynamicAnalysisModule
Input:Candidate GadgetChain G
Output: Payloadfor concretized gadget chain P
1:procedure ConcretizeChain (/u1D43A)
2:/u1D45C/u1D44F/u1D457/u1D452/u1D450/u1D461/u1D436/u1D44E/u1D450ℎ/u1D452←∅
3:/u1D45F/u1D452/u1D463/u1D43C/u1D461/u1D452/u1D45F/u1D44E/u1D461/u1D45C/u1D45F←/u1D43A./u1D45B/u1D45C/u1D451/u1D452/u1D460./u1D45F/u1D452/u1D463/u1D43C/u1D461/u1D452/u1D45F/u1D44E/u1D461/u1D45C/u1D45F ()
4:while/u1D45F/u1D452/u1D463/u1D43C/u1D461/u1D452/u1D45F/u1D44E/u1D461/u1D45C/u1D45F.ℎ/u1D44E/u1D460/u1D443/u1D45F/u1D452/u1D463/u1D456/u1D45C/u1D462/u1D460 ()do
5: /u1D45B/u1D45C/u1D451/u1D452←/u1D45F/u1D452/u1D463/u1D43C/u1D461/u1D452/u1D45F/u1D44E/u1D461/u1D45C/u1D45F./u1D45D/u1D45F/u1D452/u1D463/u1D456/u1D45C/u1D462/u1D460 ()
6: /u1D45C/u1D44F/u1D457/u1D452/u1D450/u1D461←/u1D442/u1D44F/u1D457/u1D452/u1D450/u1D461/u1D439/u1D44E/u1D450/u1D461/u1D45C/u1D45F/u1D466.alt(/u1D45B/u1D45C/u1D451/u1D452,/u1D45C/u1D44F/u1D457/u1D452/u1D450/u1D461/u1D436/u1D44E/u1D450ℎ/u1D452 )
7: /u1D45C/u1D44F/u1D457/u1D452/u1D450/u1D461/u1D436/u1D44E/u1D450ℎ/u1D452./u1D45D/u1D462/u1D461(/u1D45C/u1D44F/u1D457/u1D452/u1D450/u1D461)
8:end while
9:return/u1D443←/u1D45C/u1D44F/u1D457/u1D452/u1D450/u1D461/u1D436/u1D44E/u1D450ℎ/u1D452./u1D454/u1D452/u1D461/u1D447/u1D45C/u1D45D/u1D441/u1D45C/u1D451/u1D452 ()
10:end procedure
11:procedure ObjectFactory (/u1D45B/u1D45C/u1D451/u1D452,/u1D45C/u1D44F/u1D457/u1D452/u1D450/u1D461/u1D436/u1D44E/u1D450ℎ/u1D452 )
12:/u1D450/u1D459/u1D460←/u1D45B/u1D45C/u1D451/u1D452./u1D454/u1D452/u1D461/u1D437/u1D452/u1D450/u1D459/u1D44E/u1D45F/u1D456/u1D45B/u1D454/u1D436/u1D459/u1D44E/u1D460/u1D460 ()
13:if/u1D45C/u1D44F/u1D457/u1D452/u1D450/u1D461/u1D436/u1D44E/u1D450ℎ/u1D452./u1D456/u1D460/u1D443/u1D45F/u1D452/u1D43C/u1D45B/u1D460/u1D461/u1D44E/u1D45B/u1D461/u1D456/u1D44E/u1D461/u1D452/u1D451 (/u1D45B/u1D45C/u1D451/u1D452)then
14: if/u1D45C/u1D44F/u1D457/u1D452/u1D450/u1D461/u1D436/u1D44E/u1D450ℎ/u1D452.ℎ/u1D44E/u1D460/u1D438/u1D465/u1D44E/u1D450/u1D461/u1D447/u1D466.alt/u1D45D/u1D452 (/u1D45B/u1D45C/u1D451/u1D452)then
15: /u1D45A/u1D462/u1D460/u1D461/u1D445/u1D452/u1D461/u1D462/u1D45F/u1D45B(/u1D45C/u1D44F/u1D457/u1D452/u1D450/u1D461/u1D436/u1D44E/u1D450ℎ/u1D452,/u1D45B/u1D45C/u1D451/u1D452 )
16: else
17: /u1D45A/u1D44E/u1D466.alt/u1D445/u1D452/u1D461/u1D462/u1D45F/u1D45B(/u1D45C/u1D44F/u1D457/u1D452/u1D450/u1D461/u1D436/u1D44E/u1D450ℎ/u1D452,/u1D45B/u1D45C/u1D451/u1D452 )
18: end if
19:end if
20:/u1D450/u1D459/u1D460/u1D442/u1D44F/u1D457←/u1D450/u1D459/u1D460./u1D45D/u1D456/u1D450/u1D458/u1D436/u1D45C/u1D45B/u1D460/u1D461/u1D45F/u1D462/u1D450/u1D461/u1D45C/u1D45F ()./u1D456/u1D45B/u1D460/u1D461/u1D44E/u1D45B/u1D461/u1D456/u1D44E/u1D461/u1D452();
21:return/u1D450/u1D459/u1D460/u1D442/u1D44F/u1D457
22:end procedure
the language-speciﬁc prerequisites. For primitive data types, we
use a pre-deﬁned ﬁnite set created from commonly-used values in
knownvulnerabilitiessourcedfromYsoserial[ 22].Foruser-deﬁned
data types, we instantiate using a randomly chosen constructor
synthesizing the requiredparametersrecursivelyif necessary.
DeserializationProbing .Onceapayloadissuccessfullyinstan-
tiated, we submit it to the Deserialization Probing to test if the
payload expresses the intended behavior, i.e.,RCE, AFW, or DoS.
We use diﬀerent feedback according to the attack we detect. For
RCE and AFW, Crystallizer reports a payload if it can execute
eachgadgetinthechainfromthetriggertothesink.Totrackgadget
chain execution, we use method-level coverage feedback. However,
totransformthechaininaconcreteexploit,humanassistanceis
neededtoﬁne-tunetheconcretizedpayload(discussedin §5.1).For
theDoSchains,instead,weareinterestedinpayloadsthatkeepthe
CPUbusyforalongtime,therefore,weconsiderthedeserialization
execution time as feedback. Speciﬁcally, we consider possible DoS
chainsthatrequiretimemorethanagiventhresholdtobeexecuted
(5s inour experiments). In contrast to RCE/AFW payloads, no hu-
man intervention is needed since the synthesized payload by itself
exhibitsthe intendedbehavior.
We,onpurpose,usethesamesinkgadgetsforRCE,AFWand
DoS chains. Our intuition is that a sink operating on arbitrary
classescanbeeasilytunedtoexpressdiﬀerentattacksbycombining
heuristics anddiﬀerentfeedback.
1590ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA PrashastSrivastava, Flavio Toﬀalini, KostyantynVorobyov, François Gauthier, Antonio Bianchi, andMathiasPayer
4 IMPLEMENTATION
Here, we describe the static analyzer, Dazzer—our Probabilistic
ConcretizationtoolbuiltontopofJazzer[ 12],andthemethod-level
instrumentation.
Static analyzer. We develop ourstatic analyzer on topof Soot
version4.2.1[44]. Soot is the standard tool for analyzing Java byte-
codeandprovidesbuilt-inanalysisforcallgraphandclasshierar-
chy[18]. Our analyzerconsists of 1.1KJava LoC.
Dazzer.To assist the object creation, we develop Dazzer. Our
tool aids the payload synthesis in Dynamic Analysis Module ( §3.3)
andtheidentiﬁcationofsinkgadgetsinSinkIdentiﬁcation( §3.2).
DazzerextendsJazzer,whichisoriginallydesignedtofuzzmethods
inisolationbycreatingconcreteargumentsforthem.Incontrast,
Dazzerisdesignedtoperformeﬀectivegadgetchainconcretization
whichrequiresadoptinguniqueandgeneralizedstrategiesforob-
jectcreation.Wedevisethethreestrategiesbasedonouranalysis
of numerous previously known deserialization-based vulnerabil-
ities and deriving commonalities in terms of how they manifest
themselves.First,wemaketheobjectcreationchainawarebyin-
troducing the concept of a probabilistic object cache. Second, in
additionto regularinstantiation,Dazzer employs reﬂection-based
strategiestoforceobjectcreationifnopublicconstructorsareavail-
able,whichweemployduringpayloadcreationofagadgetchain.
Finally,weimprovethecapabilitiesoftheobjectcreationmodule
tohandlethegenerationof“genericobjects”oftype Object[41].
Jazzer only returns null objects when requested objects of type Ob-
ject. In contrast, Dazzer not only returns commonly-used objects
in chain executions such as strings and hashmaps but more impor-
tantly extends it to use the object cache which was instrumental
inhelping Crystallizer toconcretizegadgetchains.Overall,we
added2KJava LoContop ofthe originalJazzer.
Method-levelFeedback. Crystallizer createsaninstrumented
version of the target library by adding method-level coverage feed-
backatthebytecodelevel.WeuseSoottoinsertinstrumentation
atthestartofeachmethodtologitsexecution.Weusethisfeed-
backduringProbabilisticConcretizationforidentifyingconcretized
gadget chains( §3.3). The method-level feedback and deserialization
tracing support were implementedin 470Java LoC.
5 EVALUATION
Ourevaluationof Crystallizer revolvesaround ﬁveresearchques-
tions.
RQ1:CanCrystallizer ﬁnd deserialization vulnerabilities in pre-
viously well-testedlibraries? ( §5.1)
RQ2:How does Crystallizer perform against state-of-the-art
tools?(§5.2)
RQ3:How doCrystallizer ’s components inﬂuence the gadget
chain discovery? ( §5.3)
RQ4:Whatsinks does Crystallizer ﬁnd?(§5.4)
RQ5:CanCrystallizer detectnoveldeserializationvulnerabili-
ties inenterprise software? ( §5.5)
Environment .We evaluate Crystallizer on seven popular
Java-based libraries ( Table 1) and three popular enterprise applica-
tions (§5.5). These cover a diverse range of functionality and haveTable 1: Evaluation Benchmarks paired with their ground
truth chains.
Benchmark Version(s) Description GTVuln
Apache CommonsCollections (ACC3.1) 3.1 Data StructureManipulation [ 32]
Apache CommonsCollections (ACC4.0) 4.0 Data StructureManipulation [ 33]
Aspectjweaver 1.9.2 Language FeatureExtension [ 27]
Beanshell 2.05b Embeddable interpreter [ 34]
Beanutils 1.9.2 UtilityLibrary [ 20]
Groovy 2.3.9 Object-orientedLanguage [ 21]
Vaadin 7.7.14 Web ApplicationDevelopment [ 31]
beenpreviouslywell-testedfordeserializationvulnerabilities.More-
over,wecompare Crystallizer againsttworelatedtools:Gadget
Inspector [ 26] and Rasheed et al. tool [ 47]. We evaluate on an Intel
Xeon E5-2450 2.1GHz processor with 47G RAM running Ubuntu
20.04.Crystallizer isconﬁguredtoberuninsingle-threadedmode
andwascompiledwith javacversion11.0.11.
5.1 RQ1: Library-basedevaluation
We assess the eﬀectiveness of Crystallizer atuncovering deseri-
alizationvulnerabilitiesbyrunningitonthepreviouslywell-tested
seven libraries described in Table 1. To runCrystallizer on these
libraries, we followthe methodology in Figure 2.
First,Crystallizer creates gadget graphs as a part of the Static
AnalysisModule.Weprovideinformationaboutaknowntrigger
gadget (sourced from Ysoserial [ 22]) for each of the libraries to
Crystallizer (§3.1).Crystallizer employsfouruniquemethods
(toString ,compare,hashCode ,invoke) to automatically identify
entrypointsintothelibrary. Table2detailsthesizeofthegraphs
for each target library as well as the time taken to create them
alongwiththenumberofentrypointsused.Afterthegadgetgraph
iscreated,weperformSinkIdentiﬁcationforwhichweallocatea
time budget ofone hour since itisadynamic process.
In theProbabilisticConcretizationphase, Crystallizer identi-
ﬁes candidate gadget chains and thenattempts to concretize them.
We allocate a time budget of up to24hoursfor thisphase. Table3
providesanoverviewofthisphase.Acrossallsevenlibraries, Crys-
tallizer concretizes 837gadgetchains. We manuallydeemed 604
chains as being interesting , i.e., the sink gadgets in these chains
performsemanticfunctionalitythatcouldbepotentiallyexploitable.
Fromthese 604chains,48weremanuallyvalidatedtobeexploitable.
Thesink gadgetsininterestingchains performawiderange of
potentially exploitable semantic functionality. Certain sink gadgets
perform traditionally vulnerable functionality like using reﬂection
to invoke arbitrary methods or writing arbitrary bytestreams to
ﬁles.However,thereisalsoasubsetofsinksthatareperforming
functionality that would not be categorized as traditionally vulner-
ablebutwhencoupledwithotherprimitivesprovidedbythetarget,
theybecomeexploitable.Arepresentativeexampleofsuchasinkis
LazyMap.get() (shownin Figure1).Thissinkgadgetallowsusing
classes called Transformers that allow transformationsto be per-
formed on the key that is being inserted into the map. It is possible
touseasetof Transformers whichwhenexecutedmountanRCE
attack.Crystallizer owingtoitsSinkIdentiﬁcationcanidentify
not only the LazyMap.get() method but also all Transformers
that are instrumentalinmounting the RCEattack.
1591Crystallizer : A Hybrid Path Analysis Framework to Aid in UncoveringDeserialization Vulnerabilities ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA
27.84%of the concretized chains are not deemed interesting
since the sinks do not perform exploitable functionality. This in-
cluded functionalitysuch as wrapping objects into containers like
hashmaps. These sinks are ﬂaggedbecause our current methodol-
ogyfor SinkIdentiﬁcationonlyinfers whetherasinkgadget may
operate on potentially attacker-controlled objects but does not rea-
son about the semantic functionality performed on such objects.
Weplantointegratethissemanticfunctionalityreasoningasapart
offuture work to make our SinkIdentiﬁcationmore precise.
Toassesstheexploitabilityofthegadgetchainsconcretizedby
Crystallizer , we manually see if the payload for a concretized
gadgetchainshowcasingapotentialdeserializationvulnerability
that can be tweaked to mount an exploit. The exploitability is
assessedwiththehelpofasyntheticapplicationthatdeserializes
user-provideddataandhasthevulnerablelibraryonitsapplication
classpath. Thismethodologyis inline withtheapproachadopted
by Park et al. [ 46] to perform their library-based evaluation. Using
the methodology outlined above, we conﬁrm exploitablity of 48
chainsconcretizedby Crystallizer bysuccessfullymountingRCE
attacksforsixoutofthesevenlibrariesandanArbitraryFileWrite
attackfor the remaining library ( Aspectjweaver ).
The amount of manual eﬀort required to convert a payload syn-
thesized by Crystallizer into a working payload varies. The pay-
loadssynthesizedfor Vaadin,Beanutils ,andACC4.0byCrystal-
lizerdid not require any further manual tweaking to mount an ex-
ploit.For Aspectjweaver andGroovy,weperformminimaltweak-
ing where only the Stringparameters used in the sink gadget are
adjustedtomounttheexploit.Theremainingtwolibraries, ACC3.1
andBeanshell requireadditionalreasoningaboutthelibraryse-
manticstoconvertthesynthesizedpayloadby Crystallizer intoa
payload that mounts an exploit. Speciﬁcally, we have to infer what
primitivesprovidedbythelibrarycouldbeusedasparametersin
thesinkgadgettocall exec()withanattacker-controlledstring.
§6providesadetaileddiscussionofmanual eﬀort.
Finally, we perform a deeper analysis of the chains that are
concretizedby Crystallizer .Theﬁrstobservationisthat Crystal-
lizersuccessfully discovers thesevenknowngroundtruthchains
(listedin Table1)acrossallourevaluationtargets.Inadditionto
ﬁndingthesegroundtruthchains, Crystallizer concretizesnew
gadgetchainsaswell. Figure3showsthetimetakenby Crystal-
lizerto create payloadsfor exploitablegadgetchains.
Table4summarizesourﬁndingswithrespecttothenovelchains
uncovered: Crystallizer automatically concretizes up to 17previ-
ouslyundiscoveredchainsperlibrary,thatarecomposedofupto six
gadgets.Wequantifythecomplexityofthenovelchainsbymeasur-
ing theunique classes theyare composed of.Intuitively, the more
uniqueinstantiatedclassesachaincontains,themorelanguageand
chain-speciﬁcprerequisites Crystallizer fulﬁlls(§3.3).Ourresults
showthenovelchainsaremorecomplexthanthegroundtruthones,
containingtwiceasmanyuniqueclasses.Wepresentanexample
ofanovelgadgetchainin Listing2.Asdemonstrated,throughits
automated reasoning about gadget chains, Crystallizer uncovers
gadgetchains corresponding to complex paths.
Takeaway: Crystallizer can both synthesize payloads for pre-
viouslyknownchainsinlibraries,aswellascreateconcretepay-
loads for novel gadget chains in well-tested libraries in an eﬃcient
manner.Table 2:Gadget graphsize ofthe targetlibrariesand the
timetaken by Crystallizer to create italong with the
numberofentry points used to create the graph.
Benchmark# Entry GadgetGraphTime (s)Points #gadgets #edges
ACC3.1 41 295 2,168 73
ACC4.0 12 573 4,069 40
Aspectjweaver 174 440 3,108 112
Beanshell 8 357 1,882 86
Beanutils 13 73 490 80
Groovy 1,170 110 271 113
Vaadin 34 2,119 8,378 153
Average 207 567 2,909 94
Table 3:Candidate chains explored by Crystallizer along
with chains that were successfullyconcretized,chains that
were deemed to be interesting, and chains that were
manually validated to be exploitable.
Benchmark GadgetChains
Candidates Concretized InterestingConﬁrmed
Exploitable
ACC3.1 25,866 689 479 7
ACC4.0 2,23,367 4 4 4
Aspectjweaver 794 74 74 17
Beanshell 915 6 4 1
Beanutils 629 32 32 16
Groovy 1,146 7 3 1
Vaadin 31,095 25 8 2
Average 40,544 120 86 7
Table 4:Novelgadgetchains foundby Crystallizer along
with their average gadgetfrequencyand acomparison of
theuniqueclasses present inthe discovered groundtruth
chain and the novel chains.
Benchmark#Novel Avg Unique Classes
Chains Gadgets #Known #Novel
ACC3.1 6 5 2 4
ACC4.0 3 4 2 4
Aspectjweaver 16 6 3 5
Beanshell 0 — 1 —
Beanutils 15 4 1 3
Groovy 0 — 1 —
Vaadin 1 3 2 3
Average 6 4 2 4
1// trigger
2BadAttributeValueExpException .readObject ();
3// links
4TiedMapEntry .toString ();
5TiedMapEntry .getValue ();
6SingletonMap .get();
7SingletonMap .isEqualKey ();
8 FastArrayList .equals();
9 // sink
10 LazyMap.get();
Listing2:Asimpliﬁedexampleofagadgetchaincorrespond-
ingto anovelpath foundby Crystallizer .
1592ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA PrashastSrivastava, Flavio Toﬀalini, KostyantynVorobyov, François Gauthier, Antonio Bianchi, andMathiasPayer
0.016 0.062 0.250 1.000 4.000 16.000
Time (h)246810121416Confirmed Exploitable ChainsACC 3.1
VaadinAspectjweaver
ACC 4.0Beanutils
GroovyBeanshell
Figure 3:Time required by Crystallizer to discoverthe
exploitable gadgetchains.
5.2 RQ2: Comparisonagainststate-of-the-art
tools
We compare Crystallizer against two state-of-the-art tools for
ﬁndingJava-baseddeserializationvulnerabilities:
(i)GadgetInspector [26]is apure static analysis tool that,given
a library as input, uses a set of heuristics to report potential gadget
chains. This tooldoes not create concrete payloads.
(ii)Rasheedetal. [47]employheapabstractions[ 29]toidentify
gadgetchainscorrespondingtodeserialization-basedvulnerabili-
ties. This toolcreates concrete payloads,similar to Crystallizer .
Crystallizer v/s Gadget Inspector .We compare Crystal-
lizeragainstGadgetInspectorbyrunningbothtoolsonthelibrary
datasetspeciﬁedin Table1andevaluatethereportedgadgetchains.
For this experiment, we run Crystallizer end-to-end on the li-
braries (illustrated in Figure 2). Furthermore, we conﬁgure both
toolstouncovergadgetchainscorrespondingtoattackpatternsthat
havebeenpreviouslyfoundintheselibraries(RCEinalllibraries
exceptfor aspectjweaver ,inwhichanArbitraryFileWrite(AFW)
exists). The reason behind this conﬁguration is two-fold. First, this
conﬁgurationensuresfeatureparitywith GadgetInspector,since
the latter cannot detect DoS chains like Crystallizer . Second,
it allows us to use known chains from available datasets [ 22] to
validate false negatives, i.e.,exploitable chains that exist but are
undiscovered.For Crystallizer ,weexecutetheSinkIdentiﬁcation
for 1-hour and Probabilistic Concretization for 24hours. Gadget
Inspector terminatesinafewminutes.
Table5showsourﬁnding. Crystallizer usesitshybridanalysis
methodology to ﬁnd conﬁrmed exploitable chains for mounting
the targeted attack in alllibraries in our dataset. Speciﬁcally, Crys-
tallizer ﬁnds previously known exploitable chains in addition to
previously unknown ones. Conversely, Gadget Inspector discovers
only one exploitablechain for the ACC 3.1library and missesthe
previously known exploitable chains in the remaining six libraries.
We investigate the exploration methodology adopted by Gadget
Inspectortounderstandwhyitdoesnotﬁndthepreviouslyknown
exploitable chains. One of the reasons was that, as a part of its
exploration methodology, once it deems a gadget as exploredbased
on its set of employed heuristics, it does not try to uncover any
chainsfurtherusingthesamegadget.ThisstrategypreventsGadget
Inspector from reporting certain gadget chains. We ﬁnd a concreteTable5:ComparisonofGadgetInspectoragainst Crystal-
lizerin terms of gadget chains reported for libraries and
theones which were conﬁrmed to be exploitable.
BenchmarkGadgetInspector Crystallizer
Reported Exploitable Concretized Exploitable
ACC3.1 2 1 689 7
ACC4.0 3 0 4 4
Aspectjweaver 3 0 74 17
Beanshell 0 0 4 1
Beanutils 0 0 32 16
Groovy 2 0 7 1
Vaadin 3 0 25 2
Average 1.9 0.1 120 6.9
exampleofthisin Vaadin.Thisshowstheimportanceofexercising
and exploring alternative paths while performing gadget chain
discovery,as done by Crystallizer .
We investigate if we can create exploitable payloads for any
ofthechainsreportedbyGadgetInspector.First,threechainsre-
portedby GadgetInspectorinthreeoutof the 7 libraries( ACC 3.1,
Aspectjweaver , andACC 4.0) are not exploitable due to incorrect
reasoning about Java language semantics. For example, in some
chains,GadgetInspectorincorrectlyassumesthatclassmembers
declared as transient [8] are attacker-controlled. Second, since
Gadget Inspector is a static tool, it does not give any guarantees
aboutwhether it is possibleto create a concrete payload.This dras-
tically inhibited the ability to build exploitable payloads for the
remainingeightoutofthe13reportedchains.Asanexample,all
thethree reportedchains in Vaadinuse agadget that requiredan
HTTP servlet session to be setup upon instantiation and hence
wasbeyondthescopeofourassessmentsincethechainreliedon
externalfactors.Incontrast, Crystallizer doesnotfacesuchissues
since the dynamic approach of Crystallizer ensures a chain is
pairedwithconcrete payloads.
Crystallizer v/s Rasheed et al. Here, we compare Crystal-
lizeragainst the results presented in the paper by Rasheed et al.
Ideally,wewouldperformacomparativeevaluationsimilartoGad-
get Inspector, but were unable to do so. Speciﬁcally, it failed while
running the pathanalysisalgorithm onour evaluation dataset.
Consequently,wecompareagainsttheirreportedresultsfor ACC
3.1andACC 4.0 since these are the only two libraries in their
dataset for whichthey were ableto create aconcrete payload.
For each of these libraries, their tool only found one path corre-
sponding to a known ground truth chain for which they manually
created a concrete payload. In contrast, Crystallizer not only
concretizedpayloadstothetwogroundtruthchains butalso nine
new gadget chains (shown in Table 5). This drastic performance
diﬀerence can be attributed to our hybrid analysis methodology.
Insteadofrelyingonheavyweightvalue-ﬂowanalysistobuildheap
accesspaths,whichcanbepronetoimprecision,ouruseoflight-
weightstaticanalysistobuildthegadgetgraphcoupledwithour
dynamic analysis module that performs path concretization allows
usto uncover andconcretize more gadget chains.
Takeaway: Crystallizer ismoreeﬀectiveatuncoveringand
creatingconcretepayloadsforgadgetchainsthantheexistingstate-
of-the-arttoolsusing its hybridanalysismethodology.
1593Crystallizer : A Hybrid Path Analysis Framework to Aid in UncoveringDeserialization Vulnerabilities ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA
Table6:Comparisonof Crystallizer againstCrystallizer-
NGintermsofgadgetchainsreportedforlibrariesandthe
ones which were conﬁrmed to be exploitable.
BenchmarkCrystallizer-NG Crystallizer
Reported Exploitable Concretized Exploitable
ACC3.1 4 0 689 7
ACC4.0 0 0 4 4
Aspectjweaver 0 0 74 17
Beanshell 6 1 6 1
Beanutils 1 1 32 16
Groovy 9 1 7 1
Vaadin 20 0 25 2
Average 5.7 0.4 120 6.9
5.3 RQ3: ComparativePerformance Evaluation
SinceCrystallizer employsahybrid pathanalysismethodology,
we evaluate the relative importance of its static and dynamic com-
ponents. We create a variant of Crystallizer that attempts to
synthesizeconcretepayloadsforagadgetchainwithoutagadget
graph(Crystallizer-NG ).However, weequip Crystallizer-NG
withtheknowledgeoftriggergadgetsandserializablegadgetsto
createastrongerbaselineforcomparison.Giventhisknowledge,
Crystallizer-NG uses the same Probabilistic Concretization mod-
uleasusedin Crystallizer andattemptstouncoverexploitable
gadgetchains bycreating concrete payloadsfor them.
This approach is an appropriate evaluation candidate since turn-
ingoﬀanyoftheothercomponentswouldcreatevariantsthathave
aweakercapabilityset:(i)disablingSinkIdentiﬁcationwouldcreate
avariantthatmarks allgadgetsassinksleadingtoapathexplosion
problem making the results meaningless, (ii) replacing our path
concretizationmodule witha vanilla fuzzerwould also be weaker
since it would not know how to generate objects. By comparing
Crystallizer againstCrystallizer-NG ,wecangetanaccurate
estimateofthebeneﬁtsofbuildingagadgetgraphandusingitto
uncover gadget chains. Similar to our evaluation of Crystallizer ,
we deploy Crystallizer-NG on seven target libraries for 24 hours.
Table 6presents an overview of the results. First, Crystallizer
is21.1xand17.3xmoreperformantonaveragethan Crystallizer-
NGinconcretizinggadgetchainsanduncoveringexploitablechains
respectively.Second,asevident,thethreeexploitablegadgetchains
thatCrystallizer-NG uncovers are in three libraries ( Beanshell ,
Beanutils , andGroovy) each of which are (i) previously known,
and(ii)simplesttoconstructrequiringonlyoneclasstobeinstanti-
atedcorrectly.Inadditiontopreviouslyknownones, Crystallizer
canuncovernovelgadgetchainsthatareexploitableanddrastically
more complex (as shownpreviously in Table4).
Takeaway: With the help of a gadget graph, Crystallizer
reducesthestatespacethatitexplorescreating 21.1Xmoreconcrete
payloadsforgadgetchainsandﬁnding 17.3Xmoreexploitableones.
5.4 RQ4: SinkIdentiﬁcation Evaluation
We perform an in-depth analysis of the sinks detected with our
frameworkas apartofthelibrary-based evaluation( §5.1).We also
evaluatetheeﬃcacyofthestaticﬁltersusedby Crystallizer at
improvingthe precision ofSinkIdentiﬁcation(discussedin §3.2).Table7:“Pre-ﬁltering”referstothesetofsinkgadgetsﬂagged
by Sink Identiﬁcation’s oracle. “Post-ﬁltering” shows the
numberofremainingsinkgadgetsafterapplyingthestatic
ﬁlters. These are the sinks that Crystallizer tries to con-
cretize paths to. “% reduction” refers to the diﬀerence be-
tween thenumberofpre- and post-ﬁltered sinks.
BenchmarkPre-ﬁltering Post-ﬁltering % reduction
(Sinks) (Sinks) (Sinks)
ACC3.1 403 148 63.3
ACC4.0 647 221 65.8
Aspectjweaver 72 11 84.7
Beanshell 116 83 28.4
Beanutils 44 5 88.6
Groovy 152 36 76.3
Vaadin 681 326 52.1
Average 302 119 65.6
1// previous gadgets
2...
3// sink
4FastArrayList .equals();
5// JDK method
6java.util.AbstractMap .equals();
7// link
8LazyMap.get();
Listing3:Asimpliﬁedchainshowinghowanexploitablepay-
load wascreated bycreating aroute through aJDK function.
We detect two new sinks in ACC 3.1 that led to six new ex-
ploitable chains missed by Gadget Inspector. For one of the ex-
ploitable chains, Crystallizer markedFastArrayList.equals()
as a sink and created a concrete payload to reach this sink from
a trigger gadget. Upon tinkering with this payload, we noticed
that ifFastArrayList were to be instantiated with a LazyMap,
wemanuallyfoundawaytoexerciseknowndangerousfunction-
ality (factory.transform ) by routing it through a JDK function
(AbstractMap.equals )asshownin Listing3.Thisparticularchain
wasnotreportedbyGadgetInspector,becauseaccordingtoitsanal-
ysis,itdidnotinferthat FastArrayList.equals() couldberouted
todangerousfunctionalitywhichasweshowedisnotthecase.This
example showsour approach can ﬁnd non-trivialsinks.
Filters are useful when performing sink identiﬁcation We evalu-
atetheeﬀectivenessofstaticﬁltersinmakingtheSinkIdentiﬁcation
moreprecise.Speciﬁcally,theﬁltersensurethetaintedarguments
thatcanbeattacker-controlledareusedbythegadgetundercon-
sideration (discussed in §3.2). Precision while performing Sink
Identiﬁcationis importantsinceitdirectly impactsthenumberof
gadgetchainsexplored.Theresultsofthisevaluationarepresented
inTable 7. We see that the ﬁltering is highly eﬀective in drastically
reducing the state space to be explored by removing 66%of the
sinks that are not using the taintedargument.
Takeaway: The Sink Identiﬁcation is suitable for discovering
non-trivialsinkgadgetsandthestaticﬁltersitemploysareeﬀective
at ﬁltering false positive candidate sink gadgets.
5.5 RQ5: Crystallizer in-the-wild
Toshowcasetheeﬀectivenessof Crystallizer atﬁndingdeseri-
alization vulnerabilities in the wild, we deploy it on two popular
1594ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA PrashastSrivastava, Flavio Toﬀalini, KostyantynVorobyov, François Gauthier, Antonio Bianchi, andMathiasPayer
1// trigger
2BadAttributeValueExpException .readObject ();
3// links
4TiedMapEntry .toString ();
5TiedMapEntry .getValue ();
6LazyMap.get();
7 ClosureTransformer .transform ();
8 // sink
9 WhileClosure .execute();
10 // links
11 TruePredicate .evaluate ();
12 NOPClosure .execute();
Listing 4:Gadget chain showcasingDoSbehavior.
Apache applications: Pulsar[6] andKafka[4] and mount two
novel attacks. Speciﬁcally, we mount a RCE attack against Pulsar
and a DoS attack against Kafka. These vulnerabilities are responsi-
bly disclosed and acknowledged by the maintainers. Furthermore,
to show generalizability, Crystallizer rediscovers a previously
known RCE vulnerability (CVE-2020-2555) [ 37] in a vulnerable
versionofthe Oracle Coherence library [ 43].
Kafka.Kafkaisaframeworkthatenablesbuildingdataprocess-
ingpipelines[ 7].Itprovidestheabilitytocapturedatafromvarying
sourceswhichinturncanthenbestoredandprocessed.Kafkauses
entities called connectors that move data in and out of Kafka as
serialized bytestreams [ 14]. Consequently, the deserialization of
untrusteddatathatmaybeattacker-controlledopens upKafkato
attacksmountedusing deserialization-basedvulnerabilities.
KafkausesJava-basedserializationanddeserializationtostore
andretrievedatafromaﬁleonalocalﬁlesystem.Sincetheﬁlethat
it uses for storage could be manipulated by an attacker, it employs
aﬁltering-basedmechanismtopreventdeserializationofasetof
speciﬁcclasses[ 2].Theprimaryinsightwehadfromthedenylist
is that it did not prevent deserialization of allclasses belonging to
known gadget chains but only classes that were instrumental in
mounting knownattacksfor RCEspeciﬁcally.
Based on the above insight, we deploy Crystallizer to synthe-
size gadget chains to mount DoS attacks instead. Crystallizer
found a chain in the Apache Commons Collections library that
exhibits DoS behavior. Speciﬁcally, Crystallizer synthesized a
chain that upon deserialization performs the semantic action of
executing an inﬁnite loop ( while(1) ). The gadgets employed in
the chain are shown in Listing 4. Evidently, none of the gadgets
usedinthechainareapartofthedenylistemployedbyKafka.This
in turn allowed us to mount a DoS attack on the latest release of
Kafka (as ofFebruary 2023)withthe helpofthis chain.
Pulsar.Pulsarprovides aframeworkfor server-to-servermes-
saging. As a part of its messaging subsystem, it provides extended
functionality using light-weight processes to process messages.
These compute processes allow for employing Java-based serial-
ization and deserialization for message handling [ 3]. Processing
messages that point to untrusted data makes Pulsar prone to dese-
rialization attacks. There is no serialization ﬁltering performed by
the deserialization APIusedbyPulsar [ 5].Therefore,itispossible
to mount a deserialization-based attack using any of the classes
present in the application’s classpath. For Pulsar (v2.2.0), we no-
ticed that the classpath includes the Commons Collections library.1// trigger
2BadAttributeValueExpException .readObject ();
3// links
4LimitFilter .toString ();
5ChainedExtractor .extract();
6 // sink
7 ReflectionExtractor .extract();
Listing5:VulnerablegadgetchaininCoherenceuncovered
andconcretized by Crystallizer
Crystallizer discovered a gadget chain in this library with which
we mountedan RCEattackagainst Pulsar.
Coherence .Coherenceisanin-memorydatastoragethatallows
fast access to key-value data. It is integrated as part of Oracle
Weblogicwhichisapopularapplicationserver.Weblogicinterfaces
with user-provided data, so a vulnerability found in this library
allowsmounting an attackthroughthe Weblogic server.
Owing to the large size and the underlying complexity of the
Coherencelibrary(13M),theinitialgadgetgraphconstructedby
Crystallizer is large containing 19,734gadgets and 143,357
edges.Crystallizer thenrunsthesinkidentiﬁcationphaseover
thisgadgetgraphforonehour.Attheendofthisphase,itidentiﬁes
57 potential sinks and 103,598 candidate gadget chains for con-
cretization.Fromthesecandidatechains,itconcretizes19unique
chainsoverﬁvedaysacross20campaigns.Fromthese19unique
chains, one is manually validated to be a previously known vulner-
abilityin theCoherence library (CVE-2020-2555) [ 37]. In addition,
sevenofthesechainsareconﬁrmedtobealternativepathstothe
samevulnerablesinkincludingmorecomplexpathsaswell.Finally,
theremaining11arepathsconcretizedtothreeuniquesinksthat
we deemedas not performinginteresting semantic functionality.
Thechainconcretizedby Crystallizer ispresentedin Listing5.
Crystallizer identiﬁes ReflectionExtractor.extract asasink
since it has a reference to an array of type java.lang.Object
which isinstantiated with our honeypotclass during itsdeclaring
class instantiation. The payload which Crystallizer constructs to
concretizethecandidatechainispresentedin Listing6.Crystal-
lizerbyuseofitschainconcretizationstrategyaugmentedwith
an object cache ( Algorithm 1 ) enables it to concretize this chain
without manual adjustment. Speciﬁcally, while invoking the setter
methods for LimitFilter , instead of generating a new object, it
retrievesanobject( cObj)fromitsobjectcache( cObj).Additionally,
Crystallizer didnotinstantiatea ReflectionExtractor object
explicitlysinceitinferredhowtobuilditindirectlybyinstantiating
aChainedExtractor objectwitha String.
Takeaway: Crystallizer eﬀectively leverages the complete
applicationclasspathtolaunchattacksagainstreal-worldenterprise
applicationseven inthe presenceof speciﬁc bypassprotections.
6 DISCUSSION
The manual eﬀort required to analyze concretized chains by Crys-
tallizer islowerthanexpected.Thereasonisthatwecanreuse
knowledge acrosschains inthe formof the unique sinksthat they
target. For Aspectjweaver (§5.1), instead of analyzing 74con-
cretized chains, we only had to examine 2sinks manually. This
strategyworksbecausetheexploitabilityofaconcretizedgadget
chain hinges on whether the sink gadget can be repurposed to
1595Crystallizer : A Hybrid Path Analysis Framework to Aid in UncoveringDeserialization Vulnerabilities ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA
1ChainedExtractor cObj =newChainedExtractor ("execute" );
2LimitFilter lObj =newLimitFilter ();
3lObj.setBottomAnchor (cObj);
4lObj.setComparator (cObj);
5
6// Preparing object corresponding to the trigger gadget
7BadAttributeValueExpException val =newBadAttributeValueExpException (lObj);
8
9ObjectOutputStream os =newObjectOutputStream (new
FileOutputStream ("payload.bin" )); ↩→
10// Writing the object into serialized bytestream (payload)
11os.writeObject (val);
.
Listing6:SimpliﬁedJavacodeshowcasingthepayloadcre-
ated byCrystallizer which uncovers the deserialization
vulnerabilityinCoherence
mountanattack.Oncetheexploitationstrategyforasinkisﬁgured
out,thisinformationcanthenbereusedinalltheotherconcretized
chains that are targeting thesamesink. Onaverage, ittook an ex-
periencedJavadeveloperwithknowledgeofdeserializationattacks
lessthan 5minutesperchaintovalidatetheirexploitabilityonce
the conditions for exploitation were identiﬁed.
The hybrid analysis methodology adopted by Crystallizer can
suﬀer from false negatives, i.e.,not creating payloads for certain
vulnerablechainsthatexistinatarget.Thesefalsenegativesmay
creep infromtwomainsources. First,boundedsearch upto auser-
conﬁgurable maximum length inherently misses longer gadget
chains.However,thiscanbeaddressedbyincreasingthemaximum
path length and allocating more computation time. Second, the
capabilityof Crystallizer toconcretizeagadgetchaindependson
the concretization module capabilities in solving chain constraints.
In some instances (as shown for Vaadin), these constraints may
correspondtothesetupoftheenvironment.Weplantoinvestigate
the concretizationofsuch chains as apart offuture work.
Uncoveringadeserializationvulnerabilityinanapplicationre-
quiresnotonly thepresenceofavulnerablegadget chainbutalso
anentrypointwheretheapplicationisdeserializinguntrusteddata.
We acknowledge that in the context of discoveringvulnerabilities
in an application, Crystallizer is semi-automated. While it can
ﬁndvulnerablegadgetchains automatically, itstill requiresa user
to identify anend-point intheapplication deserializingdata where
thepayloadcanbedelivered.However,inthecontextoflibraries,
Crystallizer can automatically create payloads that trigger the
vulnerability. While exploiting this vulnerability, requires an ap-
plicationto be usingthatlibrary,it does notchangethe factthat
the vulnerability in the library still exists. This view is in line with
prior responses from library developers [ 13].
7 RELATED WORK
Rasheedetal.[ 47]leveragepartialinstantiationofgadgetchainsby
relying on heap abstraction,and using a ﬁxed set of sinks. Similar
hybrid approaches were proposed by Cao et al (ODDFUZZ [ 10]
and GCMiner [ 11]) to identify deserialization vulnerabilities in
Java applications. A key diﬀerence with these works is that they
require a pre-deﬁned set of sinks as compared to Crystallizer ,
whichautomaticallyidentiﬁessinks.Speciﬁcally,certainchainslike
those exhibiting DoS ( Listing 4) or using unconventional sinks for
RCE(Listing3)cannotbefoundbyODDFuzzandGCMiner.Thecorresponding sinks for these chains are not treated as security-
sensitivebasedontheirpredeﬁnedlist.Unfortunately,atthetime
of writing, ODDFUZZ is not open-sourced and we were unable to
reproduce results from GCMiner.
Pacheco et al. propose automatic techniques to instantiate ob-
jects[45]whichcanbeneﬁt Crystallizer initsobjectinstantiation.
We plan to explore them as future work. Gauthier et al. [ 25] pro-
pose an active mitigation to recognize malicious chains through
Markov-basedmodeling,while Crystallizer isatestingtooltoﬁnd
deserializationvulnerabilities.Cristallietal.[ 15]discussedother
dynamic mitigation policies. Regarding DoS, Dietrech et al. [ 19]
manually create a payload that, upon deserialization, triggers large
call trees recursively leading to resource exhaustion. In contrast,
Crystallizer automaticallydiscovers DoS-likegadget chains.
DeserializationattacksalsoimpactotherlanguageslikePHPand
.NET. Dahse et al. [ 17] employ a static analysis-based method to
detectPHPobjectinjection(POI)chains,andParketal.[ 46]extend
POI construction with an automatic exploit generation technique,
both yielding impressive outcomes. However, these approaches
arecloselytiedtoPHPand,relyonpredeﬁnedsinks.Incontrast,
Crystallizer identiﬁessinksautomatically.Moreover,Java’sstatic
typing imposes more stringent constraints on gadget chain con-
cretization compared to PHP’s dynamic typing. Shcherbakov et
al.[49]uncover.NET-baseddeserializationvulnerabilities.bylever-
agingknownvulnerablechains.Incontrast Crystallizer ’sfocus
is new gadget chains. ObjectMap [ 30] is designed to identify de-
serializationerrorsinPHPandJavaapplications.Itidentiﬁesthe
entrypointsofanHTTPrequest,thenprobesdiﬀerentinputsuntil
adeserializationerrorarises.ObjectMap,however,exploresmali-
ciousinputwithoutmodelingtheinputspacesasagadgetgraph
norincludingthe notionof source/sinkgadgets.
8 CONCLUSION
Deserialization vulnerabilities are common in complex distributed
applications. We introduce a hybrid approach to automatically dis-
cover such deserialization vulnerabilities, highlighting incomplete
checks when objects are deserialized in target applications. Our
method uses static analysis to identify candidate gadget chains
and dynamic analysis to generate concrete payloads to exercise
gadgetchainsshowingproofofadeserializationvulnerability. Crys-
tallizer outperforms existing state-of-the-art tools in uncovering
Java-baseddeserializationvulnerabilities and is showncapableof
mounting attacksonpopular real-world applications.
ACKNOWLEDGEMENTS
Wethanktheanonymousreviewersfortheirpreciseanddetailed
feedbackandChibinZhangforhishelpwithanalyzingrelatedwork.
This project has received funding from the European Research
Council (ERC) under the European Union’s Horizon 2020 research
andinnovationprogram(grantagreementNo.850868),AFRLunder
FA8655-20-1-7048, SNSF under PCEGP2_186974, and a generous
giftfrom Oracle Labs.
REFERENCES
[1]Apache.2022. ApacheCommonsCollectionsLibrary. https://commons.apache.
org/index.html .
1596ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA PrashastSrivastava, Flavio Toﬀalini, KostyantynVorobyov, François Gauthier, Antonio Bianchi, andMathiasPayer
[2]Apache. 2022. Denylist for Java-based deserialization. https:
//github.com/apache/kafka/blob/trunk/connect/runtime/src/main/java/
org/apache/kafka/connect/util/SafeObjectInputStream.java .
[3]Apache.2022. JavadeserializationinApachePulsar. https://pulsar.apache.org/
docs/v2.0.1-incubating/functions/api/#java-serde .
[4]Apache. 2022. Kafka—Distributed event streaming platform. https://github.com/
apache/kafka .
[5]Apache. 2022. Lack of serialization ﬁltering in Apache Pulsar.
https://github.com/apache/pulsar/blob/master/pulsar-functions/api-
java/src/main/java/org/apache/pulsar/functions/api/utils/JavaSerDe.java .
[6]Apache.2022. Pulsar—Distributedpub-submessagingplatform. https://github.
com/apache/pulsar .
[7] AWS. 2022. What is Kafka? https://aws.amazon.com/msk/what-is-kafka .
[8]Baldeung. 2022. transient keyword in Java. https://www.baeldung.com/java-
transient-keyword .
[9]Alexander Belokrylov. 2022. Java—popular enterprise coding language.
https://www.forbes.com/sites/forbestechcouncil/2022/04/06/why-and-how-
java-continues-to-be-one-of-the-most-popular-enterprise-coding-languages .
[10]S. Cao, B. He, X. Sun, Y. Ouyang, C. Zhang, X. Wu, T. Su, L. Bo, B. Li, C. Ma, J. Li,
and T. Wei. 2023. ODDFuzz: Discovering Java Deserialization Vulnerabilities via
Structure-Aware Directed Greybox Fuzzing. In 2023 IEEE Symposium on Security
and Privacy (SP) . IEEE Computer Society.
[11]Sicong Cao, Xiaobing Sun, Xiaoxue Wu, Lili Bo, Bin Li, Rongxin Wu, Wei Liu,
Biao He, Yu Ouyang, and Jiajia Li. 2023. Improving Java Deserialization Gadget
Chain Mining via Overriding-Guided Object Generation. In Proceedings of the
45thInternationalConference onSoftwareEngineering (ICSE’23) .
[12]CodeIntelligenceTesting. 2022. Jazzer — AutoFuzz mode. https://www.code-
intelligence.com/blog/autofuzz .
[13]Apache Commons Collections. 2023. Apache Commons Collections secu-
rityreport. https://commons.apache.org/proper/commons-collections/security-
reports.html .
[14]Conﬂuent. 2022. Kafka connectors serialization. https://www.conﬂuent.io/blog/
kafka-connect-deep-dive-converters-serialization-explained/ .
[15]Stefano Cristalli, Edoardo Vignati, Danilo Bruschi, and Andrea Lanzi. 2018.
Trusted Execution Path for Protecting Java Applications Against Deserialization
ofUntrustedData.In ResearchinAttacks,Intrusions,andDefenses ,MichaelBailey,
Thorsten Holz, Manolis Stamatogiannakis, and Sotiris Ioannidis (Eds.). Springer
International Publishing,Cham,445–464.
[16]CyNation.2017. EquifaxDataBreach. https://cynation.com/the-equifax-data-
breach/.
[17]Johannes Dahse, Nikolai Krein, and Thorsten Holz. 2014. Code Reuse Attacks in
PHP: Automated POP Chain Generation. In Proceedings of the 2014 ACM SIGSAC
Conference on Computer and Communications Security (Scottsdale, Arizona, USA)
(CCS ’14) . Association for Computing Machinery, New York, NY, USA, 42–53.
https://doi.org/10.1145/2660267.2660363
[18]JeﬀreyDean,DavidGrove,andCraigChambers.1995. Optimizationofobject-
orientedprogramsusingstatic classhierarchy analysis.In EuropeanConference
onObject-OrientedProgramming . Springer, 77–101.
[19]JensDietrich,KamilJezek,ShawnRasheed,AmjedTahir,andAlexPotanin.2017.
Evil pickles: DoS attacks based on object-graph engineering. In 31st European
Conference on Object-Oriented Programming (ECOOP 2017) . Schloss Dagstuhl-
Leibniz-ZentrumfuerInformatik.
[20]Frohoﬀ. 2018. Beanutils GT chain. https://github.com/frohoﬀ/ysoserial/blob/
master/src/main/java/ysoserial/payloads/CommonsBeanutils1.java .
[21]Frohoﬀ. 2018. Groovy GT chain. https://github.com/frohoﬀ/ysoserial/blob/
master/src/main/java/ysoserial/payloads/Groovy1.java .
[22]Chris Frohoﬀ. 2022. ysoerial : A collection of known gadget chains found in
java-based software. https://github.com/frohoﬀ/ysoserial .
[23]Andrew Gainer-Dewar. 2022. Djikstra-like path enumeration algorithm for
directed graphs. https://jgrapht.org/javadoc/org.jgrapht.core/org/jgrapht/alg/
shortestpath/AllDirectedPaths.html .
[24]CarlosCardosoGalhardo,PeterMell,IrenaBojanova,andAssaneGueye.2020.
Measurementsofthemostsigniﬁcantsoftwaresecurityweaknesses.In Annual
Computer SecurityApplicationsConference . 154–164.
[25]François Gauthier and Sora Bae. 2022. Runtime Prevention of Deserialization
Attacks.In ProceedingsoftheACM/IEEE44thInternationalConferenceonSoftware
Engineering: NewIdeas and EmergingResults (ICSE-NIER’22) .
[26]Ian Haken. 2021. Gadget Inspector: Static discovery of gadget chains. https:
//github.com/JackOfMostTrades/gadgetinspector .[27]Jang. 2021. AspectJWeaver GT chain. https://github.com/frohoﬀ/ysoserial/blob/
master/src/main/java/ysoserial/payloads/AspectJWeaver.java .
[28]JFrog. 2022. Log4Shell vulnerability mounted using java deserializa-
tion.https://jfrog.com/blog/log4shell-0-day-vulnerability-all-you-need-to-
know/#appendix-b .
[29]ViniKanvarandUdayP.Khedker.2016. HeapAbstractionsforStaticAnalysis.
ACMComput. Surv. (2016).
[30]NikolaosKoutroumpouchos,GeorgiosLavdanis,EleniVeroni,ChristoforosNtan-
togian, and Christos Xenakis. 2019. ObjectMap: Detecting insecure object de-
serialization. In Proceedings of the 23rd Pan-Hellenic Conference on Informatics .
67–72.
[31]Kullrich. 2018. Vaadin GT chain. https://github.com/frohoﬀ/ysoserial/blob/
master/src/main/java/ysoserial/payloads/Vaadin1.java .
[32]Kaiser Mathias and Jasinner. 2019. Apache Commons Collections GT
chain.https://github.com/frohoﬀ/ysoserial/blob/master/src/main/java/ysoserial/
payloads/CommonsCollections5.java .
[33]Kaiser Mathias and Jasinner. 2019. Apache Commons Collections GT
chain.https://github.com/frohoﬀ/ysoserial/blob/master/src/main/java/ysoserial/
payloads/CommonsCollections2.java .
[34]Alvaro Munoz and Schneider. 2018. Beanshell GT chain. https:
//github.com/frohoﬀ/ysoserial/blob/master/src/main/java/ysoserial/payloads/
BeanShell1.java .
[35]Alvaro Munoz and Christian Schneider. 2016. Serial Killer: Silently Pwning
YourJavaEndpoints. https://paper.bobylive.com/Security/asd-f03-serial-killer-
silently-pwning-your-java-endpoints.pdf .
[36]NVD.2017.ApacheStrutsRCEvulnerability. https://nvd.nist.gov/vuln/detail/cve-
2017-9805 .
[37] NVD. 2023. CVE-2020-2555. https://nvd.nist.gov/vuln/detail/CVE-2020-2555 .
[38]Oracle.2021. InterfaceSerializable. https://docs.oracle.com/javase/7/docs/api/
java/io/Serializable.html .
[39]Oracle. 2022. Java Deserialization using readObject. https://docs.oracle.com/
javase/7/docs/api/java/io/ObjectInputStream.html#readObject() .
[40]Oracle.2022. JavaSerializationusingwriteObject. https://docs.oracle.com/javase/
7/docs/api/java/io/ObjectOutputStream.html#writeObject() .
[41]Oracle.2022. ObjectclassinJava. https://docs.oracle.com/javase/8/docs/api/java/
lang/Object.html .
[42]Oracle. 2023. classpath in Java. https://docs.oracle.com/javase/tutorial/essential/
environment/paths.html .
[43] Oracle. 2023. Coherencelibrary. https://www.oracle.com/java/coherence/ .
[44] Soot Oss. 2022. Soot. https://github.com/soot-oss/soot .
[45]Carlos Pacheco and Michael D Ernst. 2007. Randoop: feedback-directed random
testingforJava.In Companiontothe22ndACMSIGPLANconferenceonObject-
orientedprogrammingsystemsand applications companion . 815–816.
[46]Sunnyeo Park, Daejun Kim, Suman Jana, and Sooel Son. 2022. {FUGIO}: Au-
tomaticExploitGenerationfor {PHP}ObjectInjectionVulnerabilities.In 31st
USENIXSecuritySymposium(USENIXSecurity22) . 197–214.
[47]Shawn Rasheed and Jens Dietrich. 2020. A Hybrid Analysis to Detect Java
SerialisationVulnerabilities.In Proceedingsofthe35thIEEE/ACMInternational
ConferenceonAutomatedSoftwareEngineering (VirtualEvent,Australia) (ASE
’20). Association for Computing Machinery, New York, NY, USA, 1209–1213.
https://doi.org/10.1145/3324884.3418931
[48]HovavShacham.2007. TheGeometryofInnocentFleshontheBone:Return-into-
libcWithoutFunctionCalls(onthex86).In Proceedingsofthe14thACMConference
on Computer and Communications Security (Alexandria, Virginia, USA) (CCS ’07).
ACM,NewYork, NY, USA,552–561. https://doi.org/10.1145/1315245.1315313
[49]Mikhail Shcherbakov and Musard Balliu. 2021. Serialdetector: Principled and
practicalexplorationofobjectinjectionvulnerabilitiesfortheweb.In Network
and DistributedSystemsSecurity(NDSS) Symposium202121-24 February2021 .
[50]TIOBE.2022. Popularprogramminglanguagesfordevelopment. https://www.
tiobe.com/tiobe-index/ .
[51]Flavio Toﬀalini, Mariano Graziano, Mauro Conti, and Jianying Zhou. 2021.
SnakeGX: a sneaky attack against SGX Enclaves. In International Conference
onAppliedCryptographyand Network Security . Springer, Cham,333–362.
[52]RajaVallée-Rai,PhongCo,EtienneGagnon,Laurie Hendren,PatrickLam,and
Vijay Sundaresan. 2010. Soot: A Java bytecode optimization framework. In
CASCON First Decade HighImpactPapers . 214–224.
Received 2023-02-02; accepted 2023-07-27
1597