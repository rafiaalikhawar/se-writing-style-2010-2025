PUS: A Fast and Highly Efficient Solver for Inclusion-based
Pointer Analysis
Peiming Liu
Texas A&M University
College Station, USA
peiming@tamu.eduYanze Li
Texas A&M University
College Station, USA
yanzeli@tamu.edu
Brad Swain
Texas A&M University
College Station, USA
brad@tamu.eduJeff Huang
Texas A&M University
College Station, USA
jeff@cse.tamu.edu
ABSTRACT
A crucial performance bottleneck in most interprocedural static
analyses is solving pointer analysis constraints. We present Pus,
a highly efficient solver for inclusion-based pointer analysis. At
the heart of Pus is a new constraint solving algorithm that signifi-
cantly advances the state-of-the-art. Unlike the existing algorithms
(i.e., wave and deep propagation) which construct a holistic con-
straintgraph,ateachstagePusonlyconsiders partialconstraints
that causally affect the final fixed-point computation. In each itera-
tion Pus extracts a small causality subgraph and it guarantees that
only processing the causality subgraph is sufficient to reach the
same global fixed point. Our extensive evaluation of Pus on a wide
range of real-world large complex programs yields highly promis-
ingresults.Pusisabletoanalyzemillionsoflinesof codesuchas
PostgreSQLin10minutesonacommoditylaptop.Onaverage,Pus
is more than 7 Ã—faster in solving context-sensitive constraints, and
more than 2 Ã—faster in solving context-insensitive constraints com-
pared tothe stateof theart waveand deep propagationalgorithms.Moreover,Pushasbeenusedtofindtensofpreviousunknownbugs
inhigh-profile codebasesincluding Linux,Redis, andMemcached.
KEYWORDS
Static Analysis, Pointer Analysis, Causality Subgraph
ACM Reference Format:
Peiming Liu, Yanze Li, Brad Swain, and Jeff Huang. 2022. PUS: A Fast
and Highly Efficient Solver for Inclusion-based Pointer Analysis. In 44th
InternationalConferenceonSoftwareEngineering(ICSEâ€™22),May21â€“29,2022,
Pittsburgh, PA, USA. ACM, New York, NY, USA, 12 pages. https://doi.org/10.
1145/3510003.3510075
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACMmustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
Â© 2022 Association for Computing Machinery.
ACM ISBN 978-1-4503-9221-1/22/05...$15.00
https://doi.org/10.1145/3510003.35100751 INTRODUCTION
Pointeraliasanalysisisafundamentaltechniqueinanenormous
amountofprogramanalysisapplications,suchasvalue-flowanaly-
ses [4,26,32], deep bug detectors [ 13,16,18,20], memory leak de-
tectors[6,8,33,35],etc.Itisalsotheprerequisiteofmanycompiler
optimizations suchas loop optimization and deadcode elimination.
Althoughpointeranalysishasbeenafocusofresearchfordecades,
it remains an open challenge to scale pointer analysis to large com-
plex codebases. A crucial performance bottleneck is in solving
the pointer analysis constraints. While precise pointer analysisis known to be undecidable [
12,24], any practical solution must
over-approximate the exact answer. A state-of-the-art approach is
theAndersen-style[ 1],inclusion-basedpointeranalysis,inwhich
pointer assignments are constrained by inclusive relations. For ex-
ample, a simple assignment ğ‘=ğ‘from pointer ğ‘toğ‘produces
the contraint ğ‘ğ‘¡ğ‘ (ğ‘)âŠ†ğ‘ğ‘¡ğ‘ (ğ‘), meaning that the points-to set of
ğ‘, denoted as ğ‘ğ‘¡ğ‘ (ğ‘), is a subset of points-to set of ğ‘. For a com-
plex assignment involving pointer dereference, ğ‘=âˆ—ğ‘, it produces
âˆ€ğ‘£âˆˆğ‘ğ‘¡ğ‘ (ğ‘):ğ‘ğ‘¡ğ‘ (ğ‘£)âŠ†ğ‘ğ‘¡ğ‘ (ğ‘). These inclusive constraints, while
ensuring valid may-alias results, provide significantly higher preci-
sionthanunification-basedapproaches(e.g.,Steensgaard-style[ 31]).
As real-world programs often produce a huge number of con-
straints, quadratic to the number of pointers, the key challenge re-
mainedishowtoefficientlysolvetheseconstraints.Therewasasig-
nificant effort over a decade ago by Pereira, Hardekopf, Pearce [ 10,
22,23]. In their work, a naÃ¯ve fixed-point algorithm is improved by
separatingcomplexconstraintsandpropagatingthepoints-toin-
formationintotwostages;byapplyingdifferentstronglyconnected
component (SCC) detection strategies, e.g.,lazy cycle detection
and hybrid cycle detection, to reduce the size of the constraintgraph [
10]; or by sorting the constraint graph topologically to
avoidredundantcomputation[ 10,22].Morerecently,Leietal.[ 15]
proposeanefficientalgorithm(Dea)forhandlingpositiveweight
cycles in field-sensitive pointer analysis. Liu et al. [ 18] propose an
incrementalpointeranalysis(D4)thatonlyanalyzestheupdated
code changes tododge the performance overhead introduced by a
whole-programpointeranalysis.Whiletheseapproachesfurther
improvethestate-of-the-artinsomespecificaspects,theirfunda-
mental solving algorithm remains the same ( e.g.,Dea still relies on
Wp [23] to solve the constraints).
17812022 IEEE/ACM 44th International Conference on Software Engineering (ICSE)
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:34:15 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Peiming Liu, Yanze Li, Brad Swain, and Jeff Huang
A
C B{o1, o2}
{o1, o2, z} {o1, o2}Causal  
NodeA
C B{o1, o2}
{z} {o1, o2}Iteration n - 1 Iteration nb
Figure 1: An example to illustrate the causality subgraph:
with new edge inserted after iteration ğ‘›âˆ’1, node C is iden-
tified as a causal node in iteration ğ‘›.
Inthispaper,wetacklethistremendouschallengewithanew
fundamental solving algorithm. Unlike previous algorithms, our
new algorithm, Partial Update Solver (Pus), only processes a partial
constraint graph in each iteration, yet still guarantees the same
globalfixed point. The key insight behind our approach is that dur-
ingtheconstraintsolvingprocessineachiteration,onlyaverysmall
causality subgraph is subject to change due to the updates made in
previousiterations.Withthecausalitysubgraph,Pusprunesthe
constraintgraphtoonlyoperateonasmallsubsetoftheconstraints
in each iteration, which eliminatesredundant computation across
iterations, resulting in a much faster algorithm.
Compared to prior approaches [ 10,20,23] that apply general
graphprocessingtechniquestopointeranalysis,Pusismoreeffi-
cientbecauseitleveragestwouniquepropertiesofpointeranalysis:
â€¢First,thesparsityoftheconstraintgraph,whichleadstoour
definition of causality subgraph;
â€¢Second, the interconnections between different solving iter-
ations provide the necessary information to minimize the
set of causal constraints in the next iteration.
AsillustratedinFig.1,supposeanewedge ğ´â†’ğ¶isinsertedin
the previous iteration (due to complex constraints), ğ¶is identified
as acausalnode because the points-to information carried by ğ´
willtakeeffect onğ¶inthecurrentiterationinordertosatisfythe
inclusiveconstraints.However, ğµisnotacausalnodebecauseits
points-to information is not affected by the new edge. Our empiri-
calresultsshowthat,onaverage,thecausalitysubgraphincludes
less than 4%of the nodes and edges in the full constraint graph,
indicatingadramaticperformanceoptimizationopportunity(the
formaldefinitionofcausalitysubgraphisgivenby Definition4.3 ).
Fig. 2 shows an overview of Pus. At a high level, Pus adopts
a similar workflow to the existing two-phase constraint solving
algorithms [ 23], in which the constraints are processed iteratively
betweentwostages(forprocessingsimpleconstraintsandcomplex
constraints, respectively). Ho wever,unlike the existing algorithms,
whichrepeat thecomputationoverthewhole graphineach iter-
ation, Pus interactively invokes the two processing phases such
that the first phasecomputes a causality subgraph and selectively
propagatesthepoints-toinformationwithinthecausalitysubgraph
(based on the information provided by the second phase). Mean-
while,asnewpoints-toinformationispropagated,thefirstphase
also collects a subset of all the complex constraints to be processed
inthesecondphase.Ineachiterationof Pus,onephaseprovidesCausal Complex  
ConstraintsCausal Copy b 
ConstraintsCausal Graph
ComputationPoints-to
PropagationProcess Simple Constraints
Process Complex ConstraintsSelective
Complex Edges
ProcessingInserting new
Edges
Figure 2: An overview of Pus: partial update solver.
necessary information for the other to infer a small set of causal
constraints to be processed.
In principle, the time complexity of Andersen-stype pointer
analysis is bounded by ğ‘‚(ğ‘2ğ‘šğ‘ğ‘¥ ğ‘¥ğ·(ğ‘¥)+ğ‘ğ¸)on ak-sparsepro-
gram [30], whereğ‘šğ‘ğ‘¥ ğ‘¥ğ·(ğ‘¥)is the maximal number of statements
dereferencingapointer ğ‘¥,ğ‘/ğ¸isthenumberofnodes/edgesinthe
constraintgraph.Thevalueof ğ‘šğ‘ğ‘¥ ğ‘¥ğ·(ğ‘¥)isboundedbyaconstant
ğ‘˜(i.e.,ğ‘šğ‘ğ‘¥ ğ‘¥ğ·(ğ‘¥)â‰¤ğ‘˜)forreal-worldapplications.Thefirstportion,
ğ‘‚(ğ‘2ğ‘šğ‘ğ‘¥ ğ‘¥ğ·(ğ‘¥)), summarizes the complexity for handling com-
plexconstraintsandthesecondportion, ğ‘‚(ğ‘ğ¸),summarizesthe
complexityforpropagatingpoints-toinformationontheconstraintgraph.AsPuspropagatespoints-toinformationonlyonthecausal-
ity subgraph, it reduces the second portion to ğ‘‚(ğ‘2ğ‘šğ‘ğ‘¥ ğ‘¥ğ·(ğ‘¥)+
ğ‘âˆ—ğ¸âˆ—), whereğ‘âˆ—/ğ¸âˆ—is the number of nodes/edges in the causality
subgraph. In practice, this reduction leads to significant perfor-mance improvements because typically
ğ‘âˆ—/lessmuchğ‘andğ¸âˆ—/lessmuchğ¸in
real-world programs.
In summary, this paper makes the following contributions:
â€¢We propose Pus, a novel constraint solving algorithm forinclusion-based pointer analysis. Pus identifies a minimal
causalitysubgraphtomaximizeperformancewhileensuring
that the same global fixed point is reached.
â€¢Wehaveprovedthecorrectnessof Pus.Formalproofsare
provided in the supplementary materials.
â€¢We conduct extensive experiments and show that Pus ismore than 7
Ã—faster than the state-of-the-art Wp (Wave
Propagation) and Dp (Deep Propagation) algorithms [ 23]i n
solvingcontext-sensitivepointeranalysis,andmorethan2 Ã—
faster in solving context-insensitive pointer analysis.
â€¢Pushasenabledacommercialstaticanalyzerandusedin[ 19]
to find tens of previous unknown bugs in large complex
systemsincludingLinux,RedisandMemcached(seehttps:
//coderrect.com/openscan/).
2 BACKGROUND
In this section, we introduce the background of inclusion-based
pointer analysis.
Inclusion-based Pointer Analysis. The inter-procedural inclusion-
based pointer analysis abstracts different program statements into
the constraints listed in Table 1. It first scans the target program
1782
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:34:15 UTC from IEEE Xplore.  Restrictions apply. PUS: A Fast and Highly Efficient Solver for Inclusion-based Pointer Analysis ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
Table 1: Constraints for inclusion-based pointer analysis
Category Type Statement Constraints
Base Address Taken ğ‘£1â†&ğ‘œ ğ‘™ğ‘œğ‘(ğ‘œ)1âˆˆğ‘ğ‘¡ğ‘ (ğ‘£1)
Simple Assignment ğ‘£1â†ğ‘£2 ğ‘ğ‘¡ğ‘ (ğ‘£1)âŠ‡ğ‘ğ‘¡ğ‘ (ğ‘£2)
Simple Phi Assignment ğ‘£â†ğœ™(ğ‘£1,ğ‘£2, ...)ğ‘ğ‘¡ğ‘ (ğ‘£)âŠ‡(ğ‘ğ‘¡ğ‘ (ğ‘£1)âˆªğ‘ğ‘¡ğ‘ (ğ‘£2)âˆª...)
Simple Call Assignment ğ‘Ÿâ†ğ‘“(ğ‘£1,ğ‘£2,...)âˆ€returnğ‘£ğ‘– ğ‘›ğ‘“(ğ‘¥1,ğ‘¥2,...):ğ‘ğ‘¡ğ‘ (ğ‘Ÿ)âŠ‡ğ‘ğ‘¡ğ‘ (ğ‘£)âˆ§
ğ‘ğ‘¡ğ‘ (ğ‘¥1)âŠ‡ğ‘ğ‘¡ğ‘ (ğ‘£1)âˆ§ğ‘ğ‘¡ğ‘ (ğ‘¥2)âŠ‡ğ‘ğ‘¡ğ‘ (ğ‘£2)âˆ§...
Complex Load ğ‘£1â†âˆ—ğ‘£2 âˆ€ğ‘£âˆˆğ‘ğ‘¡ğ‘ (ğ‘£2):ğ‘ğ‘¡ğ‘ (ğ‘£1)âŠ‡ğ‘ğ‘¡ğ‘ (ğ‘£)
Complex Store âˆ—ğ‘£1â†ğ‘£2 âˆ€ğ‘£âˆˆğ‘ğ‘¡ğ‘ (ğ‘£1):ğ‘ğ‘¡ğ‘ (ğ‘£)âŠ‡ğ‘ğ‘¡ğ‘ (ğ‘£2)
Complex Offset ğ‘£â†&ğ‘ .ğ‘“ğ‘–ğ‘’ğ‘™ğ‘‘ âˆ€ğ‘£âˆˆğ‘ğ‘¡ğ‘ (ğ‘ ):ğ‘™ğ‘œğ‘(ğ‘£.ğ‘“ğ‘–ğ‘’ğ‘™ğ‘‘)âˆˆğ‘ğ‘¡ğ‘ (ğ‘£)
1ğ‘™ğ‘œğ‘(ğ‘œ)denotes the memory location of object ğ‘œ.
2
5
7 81
6
9 102
5
7 81
6
(a) WPvisited  
node
skipped node
preexisting edge
new 
edgex y
V1
Vnx y
V1
Vnâ¶â·
â¸â¶â·
(b) PUS (c) DP (d) PUSupdated 
node
traversing order
9 10
Figure 3: The comparison between Pus, WpandDp. (a) the solving process of Wp(the entire graph need to be revisited) (b)
the solving process of Pus (only marked node need to be visited) (c) the solving process of Dp(ğ‘‰1...ğ‘‰ğ‘›are visited twice) (d) the
solving process of Pus ( ğ‘‰1...ğ‘‰ğ‘›are only visited once).
and generates three types of constraints: base,simpleandcom-
plex[10]. It then abstracts the target program into a constraint
graph(Definition.2.1).Inclusion-basedpointeranalysiscanthen
be solved by computing the transitive closure of the constraint
graph such that for every pair of nodes ğ‘£1,ğ‘£2âˆˆV, if there is an
edgeğ‘’={ğ‘£1â†’ğ‘£2}âˆˆE, thenğ‘ğ‘¡ğ‘ (ğ‘£1)andğ‘ğ‘¡ğ‘ (ğ‘£2)are the minimal
points-to sets that ensure ğ‘ğ‘¡ğ‘ (ğ‘£1)âŠ†ğ‘ğ‘¡ğ‘ (ğ‘£2).
Theglobal fixedpoint isreached whenall complexconstraints
and simple constraints are satisfied (complex constraints are sat-
isfiedbyinsertingnewedgesintotheconstraintgraph):Foreach
load constraint ( ğ‘£1â†âˆ—ğ‘£2) and every ğ‘£âˆˆğ‘ğ‘¡ğ‘ (ğ‘£2), we added a new
edgeğ‘£â†’ğ‘£1into the constraint graph; for each store constraint
(âˆ—ğ‘£1â†ğ‘£2)andevery ğ‘£âˆˆğ‘ğ‘¡ğ‘ (ğ‘£1),weaddedanewedge ğ‘£2â†’ğ‘£into
the constraint graph; and for each offset constraint ( ğ‘£â†&ğ‘ .ğ‘“ğ‘–ğ‘’ğ‘™ğ‘‘)
and every ğ‘£âˆˆğ‘ğ‘¡ğ‘ (ğ‘ ), we insert ğ‘™ğ‘œğ‘(ğ‘£.ğ‘“ğ‘–ğ‘’ğ‘™ğ‘‘)intoğ‘ğ‘¡ğ‘ (ğ‘£).
Definition. 2.1: The constraint graph (CG) of a program is an
attributedgraph G={V,E,ğ‘ğ‘¡ğ‘ },inwhich Visasetofvertices,each
ofwhichcorrespondstoavariable ğ‘£intheprogram; EâŠ†( VÃ— V ) isa
setofdirectededges(constraints)betweenverticesin V,eachofwhich
represents a simple constraint between two nodes (in the following
text, the word â€˜edgeâ€™ and â€˜constraintâ€™ are used interchangeably); and
ğ‘ğ‘¡ğ‘ :Vâ†’ğ‘ƒ(O)(whereğ‘ƒ(O)is the power set of the set of objects
createdbymemoryallocationoperationsintheprogram)isafunction
fromğ‘£âˆˆVtoğ‘ âˆˆğ‘ƒ(O)that maps a node (pointer) to its points-to
set.3 LIMITATION OF THE EXISTING METHODS
We divide the existing constraint solving algorithms for inclusion-
based pointer analysis roughly into two categories and summarize
their limitations as follows respectively.
Methods that process constraints in topological order: Performing
a topological sorting on the constraint graph ensures that con-straints are processed in the optimal order by guaranteeing thatthe points-to sets of all the predecessors of a node
ğ‘›have been
updatedbeforeprocessing ğ‘›.Inthisway,thepoints-tosetsofthe
predecessorsarethemostrecentlyupdatedbeforepropagatingto
the nodeğ‘›. Many algorithms [ 7,11,21,22] adopt the topological
sortingapproachtoboosttheconstraintsolvingtime.Despiteof
the benefits,performing SCCdetection and topologicalsorting on
largeconstraintgraphsitselfistime-consumingandcouldeasily
become a bottleneck that slows down the solving process.
Fig. 3 (a) and Fig. 3 (b) shows the solving process of Wp and
Pusontheexampleconstraintgraphrespectively,asanewedge
(2â†’5)isinserted,Wprevisitstheentiregraphagainintopological
order, on the other hand, Pus computes the same result by only
visiting the three nodes in the causal subgraph (marked in grey).
Methods that process constraints in undetermined order: Methods
that do not enforce SCC detection and topological order on theconstraint graph (e.g., Deep Propagation (DP) [
23], Lazy Cycle
Detection(LCD)andHybridCycleDetection(HCD)[ 10])ateach
1783
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:34:15 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Peiming Liu, Yanze Li, Brad Swain, and Jeff Huang
iteration unavoidablywaste resources on redundantcomputation
due to a suboptimal order of constraint processing.
Fig.3(c)andFig.3(d)showthesolvingprocessofDpandPus
on the example constraint graph respectively. When both ğ‘ğ‘¡ğ‘ (ğ‘¥)
andğ‘ğ‘¡ğ‘ (ğ‘¦)areupdated,Dpadoptsadepth-firstsearchtopropagate
fromğ‘¥â†’Â· Â· Â·â†’ ğ‘£ğ‘›and from ğ‘¦â†’Â· Â· Â·â†’ ğ‘£ğ‘›separately. As a
result, the nodes and constraints between ğ‘£1â†’Â· Â· Â·â†’ ğ‘£ğ‘›are
visited twice. However, Pus shows that when analyzing the graph
in topological order (i.e., ğ‘¥â†’ğ‘£1,ğ‘¦â†’ğ‘£1and thenğ‘£1â†’Â·Â·Â·â†’ ğ‘£ğ‘›),
every constraint only needs to be visited once.
The comparison between the existing two categories of algo-
rithms reveals the dilemma of current algorithms: On one hand,
full SCC detection and topological sorting are desired to eliminate
redundant computation and to reduce the number of nodes by col-
lapsingnodesinthesameSCCintheconstraintgraph;ontheother
hand, applying a complete SCC detection on a large graph itself
can introduce an unbearable overhead.
We found that the common problem for those works is that
they all take a holistic view towards constraint graphs. Instead,
Pus works on causality subgraphs. By only working on a small
subgraph ineach iteration, Pus can enjoythe benefitbroughtbytopological sorting without introducing too much performance
overhead.Therationalebehindcausalitysubgraphsandtheuniqueinterconnectionbetweendifferentphasesofthesolvingprocessare
summarized as follows:
â€¢Constraint graphs for real programs are, by nature, sparsely
connected. The sparsity of constraint graphs is a result of
modularization of modern software (thus fewer connections
betweendifferentmodules)aswellasthe locality1ofpro-
gram statements (thus fewer connections between different
statements).Asconstraintgraphsareabstractedfrompro-
grams,anupdateononespecificnodeintheconstraintgraph
willlikelyonlyaffectalimitednumberofneighboringnodes.
Thus, in each iteration during the solving process and with
limited nodes whose points-to sets are updated, only a very
small subset (usually â‰¤4% according to our experiments) of
thenodes(casualnodes)arerequiredtobeprocessed,whichmeansthattopologicalsortingandpoints-tosetpropagation
only need to be done on a small causality subgraph of the
entire constraint graph in each iteration.
Being ableto precisely infer a smallsubgraph in each iteration,
Pusdiscoversanothermemoryoptimizationopportunity:Oneof
the most widely adopted optimization techniques used in existing
methods and frameworks (e.g., WALA [34]) is to maintain a cached
points-to set for every node in the constraint graph (Wave Prop-agation [
23] even requires an additional cached points-to set for
everyedgeinthegraph).Thecachedpoints-tosetisusedtofilter
outnon-causalnodes whosepoints-tosetsdonotgetupdatedinthe
currentiteration andtoonlyprocess diffedpoints-toinformation.
However,if the causality subgraph can beaccurately inferred and
most of the constraints in the subgraph are effective, i.e.,by pro-
cessingwhich,thepoints-tosetwillgetupdated,thenthecached
1The locality here has different meaning from the spatial/temporal locality in
computerarchitecture.Here,itisusedtoexplainthatmostofthestatementsinthe
program are irrelevant (e.g., a++;andb++;).points-to set can be optionally eliminated to improve the memory
efficiency without causing significant performance overhead.
4 ALGORITHM
In this section, we describe the detailed algorithm for Pus. We first
presenttheoverallstructureof PusinAlgorithm1,wethenexplain
eachcomponentseparatelyindetailinAlgorithm2,Algorithm3
and Algorithm 4. For simplicity, we describe Pus under the context
offield-insensitive pointeranalysis.Puscanbeextendedforfield-
sensitive pointer analysis (as we implemented for experiments) by
adding another type of constraint, i.e., the offsetconstraint, into
complex constraints similar to the previous work [22].
4.1 Structure of the Algorithm
Atahighlevel,PushasasimilarstructuretoWp[ 23]thatseparates
the insertion of new constraints (handling complex constraints)
fromthepropagationofpoints-tosets(handlingsimpleconstraints).However, Pus distinguishes itself by connecting the two constraint
solving phases using two separate work lists:
â€¢ğ¿ğ‘ğ‘œğ‘ğ‘¦:{E}â€“ A subset of simple constraints that is used to
compute the causality subgraph used in following stages.
Algorithm 1: Partial Update Solver
Input :A unsolved constraint graph G={V,E,ğ‘ğ‘¡ğ‘ }
Result:The points-to information for every pointer in theprogram
1ğ¿ğ‘ğ‘œğ‘šğ‘â†âˆ…;
2ğ¿ğ‘ğ‘œğ‘ğ‘¦â†âˆ…;
3for each ğ‘£âˆˆVdo
4ifğ‘ğ‘¡ğ‘ (ğ‘£)â‰ âˆ…then
// Nodes with address taken constraints
have non-empty points-to set
5ğ¶ğ‘ğ‘œğ‘ğ‘¦â†ğ‘£.getCopyConstraints();
// get simple constraints started from the
node and insert them into ğ¿ğ‘ğ‘œğ‘ğ‘¦
6ğ¿ğ‘ğ‘œğ‘ğ‘¦.insert(ğ¶ğ‘ğ‘œğ‘ğ‘¦);
// insert the node into ğ¿ğ‘ğ‘œğ‘šğ‘
7ğ¿ğ‘ğ‘œğ‘šğ‘.insert(ğ‘£);
8end
9end
10whileğ¿ğ‘ğ‘œğ‘ğ‘¦â‰ âˆ…do
// SCC collapse on subgraphs of Gbased on
ğ¿ğ‘ğ‘œğ‘ğ‘¦
11SCC Collapse and TopoSort on subgraphs of G
(Algorithm 2 );
12ğ¿ğ‘ğ‘œğ‘šğ‘â†Partially Process Simple Constraints
(Algorithm 3 );
13ğ¿ğ‘ğ‘œğ‘ğ‘¦.ğ‘ğ‘™ğ‘’ğ‘ğ‘Ÿ();
14ğ¿ğ‘ğ‘œğ‘ğ‘¦â†Partially Process Complex Constraints
(Algorithm 4 );
15ğ¿ğ‘ğ‘œğ‘šğ‘.ğ‘ğ‘™ğ‘’ğ‘ğ‘Ÿ();
16end
1784
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:34:15 UTC from IEEE Xplore.  Restrictions apply. PUS: A Fast and Highly Efficient Solver for Inclusion-based Pointer Analysis ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
â€¢ğ¿ğ‘ğ‘œğ‘šğ‘:{V}â€“A subset ofnodes onwhich thecomplex con-
straints need to be recomputed.
At a high level, Algorithm 1 can be divided into initialization
phase(fromline 3to9),SCC detectionandtopologicalsortphase
(line 11), Simple constraint processing phase (line 12) and Complex
constraint processing phase (line 14), which are explained in detail
inthefollowingsections.Wealsoreliesonthefollowingconven-
tions to describe our algorithm: We refer to any edge ğ‘’âˆˆğ¿ğ‘ğ‘œğ‘ğ‘¦
used in Algorithm 1 as an essential edge and refer to any node
ğ‘£âˆˆğ¿ğ‘ğ‘œğ‘šğ‘used in Algorithm 1 as an unsaturated node .W eu s e
ğ‘‘ğ‘ ğ‘¡(E)to denote the set of destination nodes for all edges ğ‘’âˆˆE;
we useğ‘ ğ‘Ÿğ‘(E)to denote the set of source nodes for all ğ‘’âˆˆE;w e
useğ‘–ğ‘›(ğ‘›)to denote the set of incoming edges to node ğ‘›;w eu s e
ğ‘œğ‘¢ğ‘¡(ğ‘›)todenotethesetofoutgoingedgefrom ğ‘›;w euseğ‘ğ‘Ÿğ‘’ğ‘‘(ğ‘›),
whereğ‘›isanode, todenotethe setofpredecessornodes of ğ‘›;w e
useğ‘ ğ‘¢ğ‘ğ‘(ğ‘›)to denote the set of the successor nodes of ğ‘›.
4.2 Detailed Algorithm
In this section, we describe the detailed algorithms of all sub-
components that are used in Algorithm 1.
Algorithm 2: SCCCollapseandTopoSortonSubGraphs
ofG
Input :A constraint graph G={V,E,ğ‘ğ‘¡ğ‘ }
A list of starting edges ğ¿ğ‘ğ‘œğ‘ğ‘¦={E}
Output:A toposorted vector Vof SCCs that are reachable
from at least one of ğ‘’âˆˆğ¿ğ‘ğ‘œğ‘ğ‘¦
1V/primeâ†âˆ…;
2E/primeâ†âˆ…;
3ğ‘ğ‘¡ğ‘ /primeâ†ğ‘ğ‘¡ğ‘ ;
4G/primeâ†{ V/prime,E/prime,ğ‘ğ‘¡ğ‘ /prime};
// prune the graph Gto a subgraph G/prime
5whileğ¿ğ‘ğ‘œğ‘ğ‘¦â‰ âˆ…do
6ğ‘’â†ğ¿ğ‘ğ‘œğ‘ğ‘¦.pop();
7ifvisited(ğ‘’)then
8 continue ;// skip covered edges
9end
10setVisited( ğ‘’);
11E/prime.insert(ğ‘’);
// add source and destination nodes of ğ‘’into
G/prime
12V/prime.insert({ğ‘’.ğ‘ ğ‘Ÿğ‘,ğ‘’.ğ‘‘ğ‘ ğ‘¡ });
13E/prime.insert({ğ‘’/prime|ğ‘’/primeâˆˆ
ğ‘£.ğ‘œğ‘¢ğ‘¡ğ‘”ğ‘œğ‘–ğ‘›ğ‘” _ğ‘’ğ‘‘ğ‘”ğ‘’ğ‘ ()âˆ§ğ‘Ÿğ‘’ğ‘ğ‘â„ğ‘ğ‘ğ‘™ğ‘’ (ğ‘’.ğ‘‘ğ‘ ğ‘¡,ğ‘£)=ğ‘¡ğ‘Ÿğ‘¢ğ‘’});
14V/prime.insert({ğ‘£/prime|ğ‘Ÿğ‘’ğ‘ğ‘â„ğ‘ğ‘ğ‘™ğ‘’ (ğ‘’.ğ‘‘ğ‘ ğ‘¡,ğ‘£)=ğ‘¡ğ‘Ÿğ‘¢ğ‘’});
15end
// perform SCC detection on the subgraph G/prime
// also sort the graph internally
16Vâ†Tarjan(G/prime);
// return the toposorted vector V
17return V;Subgraph SCC Detection: AsshowninAlgorithm2,theSCC
detection is performed on the subgraph G/primeinstead of the original
graphG. The set of edges and nodesin G/primeis computed according
to the reachability from the constraints in ğ¿ğ‘ğ‘œğ‘ğ‘¦.
The node set N/primeofG/primeconsists of (1) the sourceanddestination
nodes of every constraints in ğ¿ğ‘ğ‘œğ‘ğ‘¦and (2) all the nodes that are
reachableforatleastoneofthe destination nodesoftheconstraints
inğ¿ğ‘ğ‘œğ‘ğ‘¦.Theedgeset E/primeofG/primeconsistsof(1)alltheedgesin ğ¿ğ‘ğ‘œğ‘ğ‘¦
and (2) all the outgoing edge of node ğ‘›that are reachable from a
least one of the destination nodes of the constraints in ğ¿ğ‘ğ‘œğ‘ğ‘¦.
After SCC detection, a vector of nodes in topological order is
returned by Algorithm 2 and used as one of the inputs for Algo-
rithm 3. Note that although Algorithm 2 presents the computation
ofG/primeasaseparatestep, G/primecanbecomputedalongwithSCCde-
tectionutilizingtheDFStraversalperformedbyTarjanâ€™salgorithm
internally.
Propagatingpoints-tosetonthecausalitysubgraph: Algo-
rithm3describestheprocedureforprocessingsimpleconstraints.
Algorithm3takesasubgraph G/primeofGandatopologicallysorted
Algorithm 3: Partially Process Copy Constraints
Input :A constraint graph: G/prime={V/prime,E/prime,ğ‘ğ‘¡ğ‘ /prime}
A sorted vector of SCCs: V={N}
A list of effective copy constraints: ğ¿ğ‘ğ‘œğ‘ğ‘¦
Output:A set of node Swhose complex constraints need
to be processed
1ğ¿ğ‘ğ‘œğ‘šğ‘â†âˆ…;
2while V.isNotEmpty() do
3ğ‘›â†V.pop();
4for eachğ‘’={ğ‘ ğ‘Ÿğ‘,ğ‘‘ğ‘ ğ‘¡}âˆˆğ‘›.ğ‘”ğ‘’ğ‘¡ğ¶ğ‘œğ‘ğ‘¦ğ¶ğ‘œğ‘›ğ‘ ğ‘¡ğ‘Ÿğ‘ğ‘–ğ‘¡ğ‘  ()do
5 ifğ‘’={ğ‘ ğ‘Ÿğ‘,ğ‘‘ğ‘ ğ‘¡}âˆˆğ¿ğ‘ğ‘œğ‘ğ‘¦âˆ¨ğ‘ ğ‘Ÿğ‘âˆˆğ¿ğ‘ğ‘œğ‘šğ‘then
6 ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ğ‘‘â†PropagatePointsTo(src, dst);
7 ifchangedthen
8 ğ¿ğ‘ğ‘œğ‘šğ‘.insert(dst);
9 end
10 else
// Prune the graph, skip unchanged
subgraph
11 continue;
12 end
13end
14end
15returnğ¿ğ‘ğ‘œğ‘šğ‘;
/* Process a simple constraint between src and
dst, return true if the points-to information
is updated */
16Function PropagatePointsTo( ğ‘ ğ‘Ÿğ‘,ğ‘‘ğ‘ ğ‘¡ ):
17ğ‘ğ‘¡ğ‘ (ğ‘‘ğ‘ ğ‘¡)â†ğ‘ğ‘¡ğ‘ (ğ‘‘ğ‘ ğ‘¡)âˆªğ‘ğ‘¡ğ‘ (ğ‘ ğ‘Ÿğ‘);
18ifğ‘‘ğ‘ ğ‘¡.changed then
19 returntrue;
20end
21return false;
22End Function
1785
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:34:15 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Peiming Liu, Yanze Li, Brad Swain, and Jeff Huang
Figure4:Furtherpruneontheconstraintgraphduringsim-
ple constraints processing phase.
vector of nodes as the inputs. The topologically sorted vector of
nodes ensures that simple constraints are processed in the optimal
order to avoid redundant computation. ğ¿ğ‘ğ‘œğ‘ğ‘¦is also passed in and
usedatline5toperformfurtherpruningonthecausalitysubgraph.
TherearetwoimportantdetailsthatareworthnotinginAlgo-
rithm 3:
(1)During the points-to set propagation, the algorithm also
computesandeventuallyoutputsalistofnodes, ğ¿ğ‘ğ‘œğ‘šğ‘,to
be used in Algorithm 4, which contains all the nodes on
which the complex constraints need to be processed.
(2)Atline11,thealgorithmperformsanotherpruningonthe
causality subgraph to further reduce the number of con-
straints processed by Pus.
The computation on ğ¿ğ‘ğ‘œğ‘šğ‘is straightforward, Algorithm 3 sim-
ply inserts a node into ğ¿ğ‘ğ‘œğ‘šğ‘if the points-to set of the node has
been updated during the current iteration.
ThegraphprocessedbyAlgorithm3definesthecausalitysub-
graphsineachiteration.Inaddition,weintroducedthefollowing
definition to formally define the causality subgraph.
Algorithm 4: Partially Process Complex Constraints
Input :The constraint graph: G={V,E,ğ‘ğ‘¡ğ‘ }
Nodes with effective complex constraints: ğ¿ğ‘ğ‘œğ‘šğ‘
Output:A set of processed: ğ¿ğ‘ğ‘œğ‘ğ‘¦
1whileğ¿ğ‘ğ‘œğ‘šğ‘.isNotEmpty() do
2ğ‘‰â†ğ¿ğ‘ğ‘œğ‘šğ‘.pop();
3foreach{ğ‘™â†âˆ—ğ‘‰}âˆˆV.getLoadConstraints() do
// process load constraints
4ğ‘›ğ‘’ğ‘¤ğ¸ğ‘‘ğ‘”ğ‘’ğ‘  â†processLoad( ğ‘™,ğ‘‰);
5ğ¿ğ‘ğ‘œğ‘ğ‘¦.insert(ğ‘›ğ‘’ğ‘¤ğ¸ğ‘‘ğ‘”ğ‘’ğ‘  );
6end
7foreach{âˆ—ğ‘‰â†ğ‘Ÿ}âˆˆV.getStoreConstraints() do
// process store constraints
8ğ‘›ğ‘’ğ‘¤ğ¸ğ‘‘ğ‘”ğ‘’ğ‘  â†processStore( ğ‘‰,ğ‘™);
9ğ¿ğ‘ğ‘œğ‘ğ‘¦.insert(ğ‘›ğ‘’ğ‘¤ğ¸ğ‘‘ğ‘”ğ‘’ğ‘  );
10end
11end
12returnğ¿ğ‘ğ‘œğ‘ğ‘¦;Definition. 4.1: Given a constraint graph G={V,E,ğ‘ğ‘¡ğ‘ }and
asetofessentialedges E+âŠ†E,theessential-edge-covered graph
G/prime={V/prime,E/prime,ğ‘ğ‘¡ğ‘ /prime}isasubgraphof G,whereV/prime=V1âˆªğ‘ ğ‘Ÿğ‘(E+)
andV1={ğ‘£|âˆƒğ‘ âˆˆğ‘‘ğ‘ ğ‘¡(E+),visreachablefroms };E/prime=E+âˆª{ğ‘’|ğ‘’=
ğ‘œğ‘¢ğ‘¡(ğ‘›)âˆ§ğ‘›âˆˆV1}andğ‘ğ‘¡ğ‘ /prime=ğ‘ğ‘¡ğ‘ .
Definition 4.2: Given an essential-edge-covered graph G/prime=
{V/prime,E/prime,ğ‘ğ‘¡ğ‘ /prime}anditscorrespondingessential edge set E+âŠ†E/prime,the
setofineffectiveedges Eâˆ’andthesetof ineffectivenodes Vâˆ’are
determined dynamically during the points-to set propagation process.
For nodeğ‘›,i fâˆ€ğ‘âˆˆğ‘ğ‘Ÿğ‘’ğ‘‘(ğ‘›),ğ‘ğ‘¡ğ‘ (ğ‘)does not get updated in the
currentiteration,then ğ‘›âˆˆVâˆ’.Similarly, Eâˆ’={ğ‘’|ğ‘’âˆˆğ‘œğ‘¢ğ‘¡(ğ‘›)âˆ§ğ‘›âˆˆ
Vâˆ’âˆ§ğ‘’âˆ‰E+}.
Definition 4.3: Given an essential-edge-covered graph G/prime=
{V/prime,E/prime,ğ‘ğ‘¡ğ‘ /prime}and a setof ineffective edges Eâˆ’, thecausality sub-
graphGâˆ—={Vâˆ—,Eâˆ—,ğ‘ğ‘¡ğ‘ âˆ—},whichisprocessedbyPus,isasubgraph
ofG/prime, whereVâˆ—=V/primeâˆ’Vâˆ’,Eâˆ—=E/primeâˆ’Eâˆ’, andğ‘ğ‘¡ğ‘ âˆ—=ğ‘ğ‘¡ğ‘ /prime.
Intuitively, definition 4.2 defines the set of nodes and edges
that are pruned in Algorithm 3 at line 11, and the causality sub-
graphisdefinedbyexcludingtheprunednodesandedgesfromthe
essential-edge-covered graph. Fig. 4 offers an example that explains
therationalebehindthegraphpruning.InFig.4,thegreynodesand
solid edges are within the essential-edge-covered graph G/primefor the
currentiteration.Thecorrespondingpoints-tosetismarkedbesideeach node. In this example, the incoming update (
{ğ‘‚1})t obep r o p -
agated within the causality subgraph is already included in ğ‘ğ‘¡ğ‘ (ğ¶)
duetoğµâ†’ğ¶.Tofurtherpropagatethepoints-tosetfrom ğ¶does
not make any update to ğ¶â€™s successors ( ğ·andğ¸in the example),
thus the causality subgraph can be pruned by skipping ğ¶â†’ğ·and
ğ¶â†’ğ¸. In Algorithm 3, since nodes are processed in topological
order and all the nodes whose points-to sets have been updatedin the current iteration are in
ğ¿ğ‘ğ‘œğ‘šğ‘, the test on ğ‘ ğ‘Ÿğ‘âˆˆğ¿ğ‘ğ‘œğ‘šğ‘at
line 5 returns true only when ğ‘ğ‘¡ğ‘ (ğ‘ ğ‘Ÿğ‘)gets updated in the current
iteration.Fornode ğ‘‘ğ‘ ğ‘¡,ifallthepredecessorsof ğ‘‘ğ‘ ğ‘¡arenotincluded
inğ¿ğ‘ğ‘œğ‘šğ‘and thus have not been updated, the outgoing edges of
ğ‘‘ğ‘ ğ‘¡will be pruned.
By the end of the computation, Algorithm 3 outputs ğ¿ğ‘ğ‘œğ‘šğ‘after
drainingtheinputtednodevectorandpasses ğ¿ğ‘ğ‘œğ‘šğ‘toAlgorithm4.
Processingcomplexconstraints: Algorithm4providesdetailed
information on how Pus handles complex constraints. The algo-
rithmtakes ğ¿ğ‘ğ‘œğ‘šğ‘,the listofnodes providedbyAlgorithm 3,and
locatesallthe nodesonwhichthecomplex constraintsneedtobeprocessed.
The processing of the complex constraints follows a standard
procedureasdescribedinSection2byinsertingnewedgesintothe
constraint graph. Algorithm 4 inserts all the newly added edges
intotheğ¿ğ‘ğ‘œğ‘ğ‘¦andeventuallypasses ğ¿ğ‘ğ‘œğ‘ğ‘¦tobothAlgorithm2and
Algorithm 3.
Note that whether or not a cached points-to set should be main-
tainedsothatPusisabletoprocessonlythediffedpoints-toset[ 23]
for complex constraints can be optionally applied. We omit thecached points-to set in our algorithm description as well as our
implementationforbettermemoryefficiencyandourexperimental
results show that Pus is still much faster than techniques which
apply the cached points-to set optimization.
1786
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:34:15 UTC from IEEE Xplore.  Restrictions apply. PUS: A Fast and Highly Efficient Solver for Inclusion-based Pointer Analysis ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
4.3 Proof of Correctness
WeprovethatPuswillreachtheglobalfixedpointbytheendof
the computation in this section.
Definition.4.4: Wesaythataconstraintgraph G={V,E,ğ‘ğ‘¡ğ‘ }is
points-tosaturated orreachesa points-tosaturatedstate ifffor
anypairof nodes ğ‘£1,ğ‘£2âˆˆV,if there isapathfrom ğ‘£1toğ‘£2,wehave
the minimal sets for ğ‘ğ‘¡ğ‘ (ğ‘£1)andğ‘ğ‘¡ğ‘ (ğ‘£2)andğ‘ğ‘¡ğ‘ (ğ‘£1)âŠ†ğ‘ğ‘¡ğ‘ (ğ‘£2).
Definition.4.5: Wesaythataconstraintgraph G={V,E,ğ‘ğ‘¡ğ‘ }
isconstraint saturated or reaches a constraint saturated state
iff for any node ğ‘£âˆˆV, if there is a load constraint ( p=* v)o nğ‘£
then there is an edge ğ‘’={ğ‘£/primeâ†’ğ‘}âˆˆEfor everyğ‘£/primeâˆˆğ‘ğ‘¡ğ‘ (ğ‘£); and
if there are store constraints ( * v=p) on v, then there is an edge
ğ‘’={ğ‘â†’ğ‘£/prime}âˆˆEfor everyğ‘£/primeâˆˆğ‘ğ‘¡ğ‘ (ğ‘£).
By definition, the global fixed point is reached when the con-
straint graph is both points-to saturated and constraints saturated.
Lemma 4.1: Given an acyclic constraint graph, it will reach a
points-to saturated state after processing the nodes once in topolog-
ical order. /square
Lemma4.2: Theineffectiveedgeset Eâˆ’isemptyduringthefirst
iteration in Algorithm 1. /square
Theorem 4.1: At every iteration in Algorithm 1, the constraint
graphÂ‚ispoints-tosaturated afterprocessingsimpleconstraints
(line 13) and Âƒisconstraint saturated after processing complex
constraints on unsaturated nodes (line 14). /square
Proof:We prove the theorem by induction.
For the first iteration. Â‚:B yLemma 4.2 , the first iteration
processestheentire essential-edge-coveredgraph G/prime={V/prime,E/prime,ğ‘ğ‘¡ğ‘ /prime}
withanessentialedgeset E+={ğ‘’|ğ‘’âˆˆğ‘œğ‘¢ğ‘¡(ğ‘›)âˆ§ğ‘ğ‘¡ğ‘ (ğ‘›)â‰ âˆ…}.By
Lemma 4.1 , the subgraph G/primewill reach a points-to saturated state
after simple constraints processing. To prove the whole graph G
will also be points-to saturated, it is equivalent to show that for
nodesğ‘›âˆ‰V/prime,ğ‘ğ‘¡ğ‘ (ğ‘›)=âˆ…: Bycontradiction, ifthere existsa node
ğ‘›âˆ‰V/primeâˆ§ğ‘œâˆˆğ‘ğ‘¡ğ‘ (ğ‘›), by the transitivity of constraint graph [ 18],
thereexistsapathfromaddresstakennodeof ğ‘œtonodeğ‘›.However,
sinceE+includesalltheaddresstakennodesâ€™outgoingedges,node
ğ‘›should also be included in V/primeby definition, which contradicts
withğ‘›âˆ‰V/prime.Âƒ: According to Algorithm 1, the unsaturated node
setV+={ğ‘£|ğ‘ğ‘¡ğ‘ (ğ‘£)â‰ âˆ…}after processing simple constraints at
line13.Itisobviousthatthegraphreachesa constraintsaturated
stateafter processing complex constraints on V+as no edge needs
to be inserted for node ğ‘›whose points-to set is empty.
Combining Â‚andÂƒ, theorem 5.1 holds at the first iteration.
Suppose theorem 4.1 holds for the n-th iteration.
For then+1-th iteration. We denote the constraint graph at
n-thiterationbeforeinsertingnewedgesas Gğ‘›={Vğ‘›,Eğ‘›,ğ‘ğ‘¡ğ‘ ğ‘›},
theconstraintgraphatcurrentiterationbeforeinsertingnewedges
asGğ‘›+1={Vğ‘›+1,Eğ‘›+1,ğ‘ğ‘¡ğ‘ ğ‘›+1}andthecausalitygraph processed
at current iteration as Gâˆ—
ğ‘›+1={Vâˆ—
ğ‘›+1,Eâˆ—
ğ‘›+1,ğ‘ğ‘¡ğ‘ âˆ—
ğ‘›+1}
Â‚:AccordingtoAlgorithm1andAlgorithm4,theessentialedge
setE+
ğ‘›+1=Eğ‘›+1âˆ’Eğ‘›. To prove that a points-to saturated state will
be reached, we prove the following two conditions hold:(1)for nodeğ‘£âˆˆV ğ‘›+1âˆ’Vâˆ—
ğ‘›+1,ğ‘ğ‘¡ğ‘ ğ‘›(ğ‘£)=ğ‘ğ‘¡ğ‘ ğ‘›+1(ğ‘£)and thus
need not to be processed, and
(2)the pruning on Gâˆ—
ğ‘›+1by removing ineffective constraints in
Eâˆ’
ğ‘›+1is sound.
For(1),assumethereexistsanode ğ‘£âˆˆVğ‘›+1âˆ’Vâˆ—
ğ‘›+1andÎ”ğ‘›+1=
ğ‘ğ‘¡ğ‘ ğ‘›+1(ğ‘£)âˆ’ğ‘ğ‘¡ğ‘ ğ‘›(ğ‘£)â‰ âˆ…. By the transitivity of constraint graph,
forğ‘œâˆˆÎ”ğ‘›+1, there exists a path from the address taken node ğ‘œ/primeto
ğ‘£(denoted as a set P={ğ‘œ/primeâ†’ğ‘£1,ğ‘£1â†’ğ‘£2,...,ğ‘£ ğ‘¥â†’ğ‘£ğ‘¦,ğ‘£ğ‘¦â†’ğ‘£}).
Case 1:Ifforevery ğ‘’âˆˆP,ğ‘’âˆ‰E+
ğ‘›+1,thenğ‘’âˆˆEğ‘›.Byinduction
hypothesis, the ğ‘›-th iteration reached the points-to saturated state,
thusğ‘œâˆˆğ‘ğ‘¡ğ‘ ğ‘›(ğ‘£)sincethereisapath Pbetweenğ‘œ/primeandğ‘£,whichis
contradictory to the assumption ğ‘œâˆˆÎ”ğ‘›+1.
Case 2:If there exists a ğ‘’âˆˆP, andğ‘’âˆˆE+
ğ‘›+1, then by definition
ğ‘£âˆˆVâˆ—
ğ‘›+1andğ‘£is in the causality graph, which is contradictory to
the assumption ğ‘£âˆˆVğ‘›+1âˆ’Vâˆ—
ğ‘›+1.
For (2), assume there exists an edge ğ‘’âˆˆEâˆ’
ğ‘›+1and by processing
it,whichistocompute ğ‘ğ‘¡ğ‘ ğ‘›+1(ğ‘’.ğ‘‘ğ‘ ğ‘¡)=ğ‘ğ‘¡ğ‘ ğ‘›+1(ğ‘’.ğ‘ ğ‘Ÿğ‘)âˆªğ‘ğ‘¡ğ‘ ğ‘›(ğ‘’.ğ‘‘ğ‘ ğ‘¡),
Î”ğ‘›+1=ğ‘ğ‘¡ğ‘ ğ‘›+1(ğ‘’.ğ‘‘ğ‘ ğ‘¡)âˆ’ğ‘ğ‘¡ğ‘ ğ‘›(ğ‘’.ğ‘‘ğ‘ ğ‘¡)â‰ âˆ…. Since, by definition,
ğ‘ğ‘¡ğ‘ ğ‘›+1(ğ‘’.ğ‘ ğ‘Ÿğ‘)âˆ’ğ‘ğ‘¡ğ‘ ğ‘›(ğ‘’.ğ‘ ğ‘Ÿğ‘)=âˆ…asğ‘’is an ineffective edge. To
satisfy Î”ğ‘›+1â‰ âˆ…, we have ğ‘ğ‘¡ğ‘ ğ‘›(ğ‘’.ğ‘ ğ‘Ÿğ‘)/notsubseteqlğ‘ğ‘¡ğ‘ ğ‘›(ğ‘’.ğ‘‘ğ‘ ğ‘¡). However,
sinceğ‘’âˆˆEâˆ’
ğ‘›+1, by definition ğ‘’âˆ‰E+
ğ‘›+1, which equals Eğ‘›+1âˆ’Eğ‘›.
We can conclude that ğ‘’âˆˆEğ‘›. By induction hypothesis, we have
ğ‘ğ‘¡ğ‘ ğ‘›(ğ‘’.ğ‘ ğ‘Ÿğ‘)âŠ†ğ‘ğ‘¡ğ‘ ğ‘›(ğ‘’.ğ‘‘ğ‘ ğ‘¡)andğ‘’.ğ‘‘ğ‘ ğ‘¡is reachable from ğ‘’.ğ‘ ğ‘Ÿğ‘by
ğ‘’âˆˆE ğ‘›andGis points-to saturated, which is contradictory to
the assumption ğ‘ğ‘¡ğ‘ ğ‘›(ğ‘’.ğ‘ ğ‘Ÿğ‘)/notsubseteqlğ‘ğ‘¡ğ‘ ğ‘›(ğ‘’.ğ‘‘ğ‘ ğ‘¡).
Âƒ:AccordingtoAlgorithm3andAlgorithm1,thesetof unsatu-
ratednodes V+
ğ‘›+1={ğ‘£|ğ‘ğ‘¡ğ‘ ğ‘›+1(ğ‘£)âˆ’ğ‘ğ‘¡ğ‘ ğ‘›(ğ‘£)â‰ âˆ…}.Itisobviousthat
the algorithm will reach constraint saturated state after processing
ğ‘£âˆˆV+
ğ‘›+1.Byinductionhypothesis,inthepreviousiterationafter
inserting new edges, the constraint graph is constraint saturated
and thus for ğ‘£/primeâˆˆ{ğ‘£|ğ‘ğ‘¡ğ‘ ğ‘›+1(ğ‘£)=ğ‘ğ‘¡ğ‘ ğ‘›(ğ‘£)}, they need not to be
processed in the current iteration.
Combining Â‚andÂƒ, Theorem 4.1 holds at the ğ‘›+1-th iteration
provided that Theorem 4.1 holds in ğ‘›-th iteration.
Theorem 4.2: Algorithm 1 guarantees the global fix point. /square
Proof:Wedenotetheconstraintgraphinthefinaliterationbefore
inserting new edges as Gğ‘“={Vğ‘“,Eğ‘“,ğ‘ğ‘¡ğ‘  ğ‘“}and the constraint
graph in the final iteration after inserting new edges as G/prime
ğ‘“=
{Vğ‘“,E/prime
ğ‘“,ğ‘ğ‘¡ğ‘  ğ‘“}SinceAlgorithm1returnswhenthe essentialedge
setE+
ğ‘“=E/prime
ğ‘“âˆ’Eğ‘“=âˆ…, no edge is inserted by processing new
complex constraints. Thus Gğ‘“=G/prime
ğ‘“. By Theorem 4.1, Gğ‘“ispoints-
to saturated andG/prime
ğ‘“isconstraint saturated and since Gğ‘“=G/prime
ğ‘“,
the final output G/prime
ğ‘“are both points-to saturated and constraint
saturated.
5 EVALUATION
Wehaveimplementeda context-sensitive,field-sensitive pointeranal-
ysis for C/C++. The implementation is based on the LLVM [ 14]
frameworkandworksatLLVMIRlevel.Inourevaluation,wecom-
pared Pus with Wave Propagation (Wp) and Deep Propagation
(Dp)[23].Thetwostate-of-the-artalgorithmsarewidelyadopted
in the most recent pointer analysis works [2, 3, 9].
In our implementation, we adopted the sparse bitvector to store
points-tosetinformation.WedidnotcomparePuswithsomeother
1787
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:34:15 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Peiming Liu, Yanze Li, Brad Swain, and Jeff Huang
Table 2: Benchmarks and the constraint graph metrics
(#Pointer, #Object and #Assign shows the number of point-
ers, objects and assignment statements in the tested pro-
gram respectively)
.Benchmark #LoC #Pointer #Object #Assign
memcached 18.9K 15.2K 3.8K 6.0K
darknet 30.1K 91.3K 26.0K 44.1K
flatbuffers 156.1K 210.2K 83.5K2659.5K
nfs-ganesha 251.5K 114.1K 33.5K 768.6K
curl 142.2K 70.0K 14.1K 578.5K
sqlite3 245.4K 129.3K 23.6K1024.4K
keydb-server 259.1K 78.9K 20.0K 230.1K
vim 334.9K 267.9K 51.1K1826.9K
cpython 564.9K 171.5K 52.2K1770.0K
postgreSQL 1.0M 496.7K 106.3K 4677.6K
recent techniques (e.g., D4 [18] and Dea [ 15]) in our evaluation as
theyaresolvingorthogonalissuestoPus.Infact,webelievethat
Pus can be incorporated with these techniques to provide a faster
underlying solving algorithm. For instance, Dea used Wp in its
implementation, which can be directly replaced with Pus.
Thegoalofourevaluationistoanswerthefollowingresearch
questions.
â€¢RQ1:How much reduction can Pus achieve by only pro-
cessing the causality subgraph in each iteration? In other
words, how large is the causality subgraph for real-world
applications when compared to the entire constraint graph?
â€¢RQ2:Intermsofperformance,howmuchfasterisPuswhen
comparedwithstate-of-the-artalgorithms,namelyWpand
Dp?
All our experiments are conducted on a commodity personal
desktopembeddedwithanInteli7-9750Hprocessorwith6cores
@ 2.6GHz and 128GB RAM.
Benchmarks: Weselected10representativeopen-sourcedreal-
worldlargeprojectsasthebenchmarkstoevaluatePus.Manyof
them have also been studied for the similar purpose in previouspublications [
23]. And they are all popular open-source projects
varyinginsize.Metricsofthosebenchmarksandtheirconstraint
graphs are listed in Table 2. The selected benchmarks are medium-
to large-sized projects with sizes ranging from 18.9K to 1.0M lines
of code.
5.1 RQ1: Reduction Achieved by Pus
To answer the first research question, we ran context-insensitive
PusonthebenchmarksinTable2andcollectedstatisticsaboutthe
sizeofthecausalitysubgraphprocessedbyPusineachiteration.
The detailed report is listed in Table 3. Table 3 compares the size of
different causality subgraphs and analyzes the relative sizes of the
causality subgraphs compared with the entire constraint graph.
We report the minimal, maximum andaveragenumber of nodes
and edges processed by Pus to summarize the characteristics ofthe causality subgraph because a different causality subgraph is
computed by Pus in each iteration.As shown in Table 3, on average a causality subgraph only con-
tainsaround3%ofthenodesand2 .7%oftheedgesintherespective
whole constraint graph. For most of the benchmarks, the size of
the causality subgraph can be as small as just 1 or 2 nodes and
edges,evenforlargebenchmarks(e.g., cpythonandpostgreSQL)
withmorethan500Knodesand300Kedges.Theminimalcausal-
ity subgraph is usually observed in the last few iterations whenthe points-to sets of most of the nodes in the constraint graphare saturated. The result gives us more confidence on the perfor-
manceimprovementcanbeachievedbyPus,asalgorithmslikeWp
wouldstillneedtore-sorttheentireconstraintgraphevenwhen
the number of effective nodes can be as low as 1.
The result also shows that for most of the benchmarks, even the
largest causality subgraph usually contains no more than 30% of
thenodesand30%oftheedgesinthecompleteconstraintgraph.
More importantly, according to our observation, large causality
subgraphs do not occur frequently, which is also why the average
Table3:ThesizeofthecausalitysubgraphsprocessedbyPus
(%Ratiocomparesthesizeofthecausalitysubgraphwiththe
whole constraint graph)
.Benchmarkcausality Subgraph
#Node %Ratio #Edge %Ratio
memcachedmin 1 0.01% 20.02%
max 3,538 18.59% 11,17575.53%
avg. 197 1.04% 7034.74%
darknetmin 1 0.00% 10.00%
max 15,365 13.10% 34,40631.10%
avg. 1,990 1.70% 7,171 6.48%
flatbuffersmin 7 0.00% 110.00%
max 48,533 16.52% 230,758 2.54%
avg. 6,679 2.27%16,212 0.18%
nfs-ganeshamin 1 0.00% 20.00%
max 28,865 20.07% 62,49116.61%
avg. 726 0.50% 2,590 0.69%
curlmin 2 0.00% 20.00%
max 14,743 17.48% 51,365 7.95%
avg. 3,341 3.96%17,688 2.74%
sqlite3min 1 0.00% 20.00%
max 34,642 23.32% 120,412 10.79%
avg. 9,113 5.97%30,938 2.77%
keydb-servermin 2 0.00% 20.00%
max 21,147 21.36% 44,99316.60%
avg. 4,865 4.91%12,229 4.51%
vimmin 2 0.00% 60.00%
max 68,600 21.50% 235,240 12.42%
avg. 10,512 3.29%39,570 2.09%
cpythonmin 16 0.00% 160.00%
max 52,424 23.44% 139,810 7.53%
avg. 9,885 4.42%33,676 1.81%
postgreSQLmin 1 0.00% 10.00%
max 114,410 18.97% 333,764 6.90%
avg. 13,241 2.20%46,621 0.96%
avg. -3.02% -2.69%
1788
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:34:15 UTC from IEEE Xplore.  Restrictions apply. PUS: A Fast and Highly Efficient Solver for Inclusion-based Pointer Analysis ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
(a) The footprint of curl 
(b) The footprint of sqlite3  New Indirect 
Targets Resolved
New Indirect 
Targets Resolved
Figure5:Thefootprintofthesizeofthecausalitysubgraphs
processed by Pus at each iteration when analyzing curland
sqlite3.
numberofnodesandedgesinthecausalitygraphisstilllowdespite
the existence of some relatively large subgraphs. Our experiments
showsthatlargecausalitygraphsnormallyoccurinthefirstfew
iterationsatthebeginningofthecomputationand/orafterindirect
calls areresolvedand newnodes areinserted. Theseobservations
are validated in Fig. 5 and will be elaborated in the following para-
graphs.
Inordertogaininsightsintotheentireâ€˜lifetimeâ€™ofthecausality
subgraphsandtounderstandhowitâ€˜evolvesâ€™astheanalysispro-
ceeds, we include two complete (also typical) footprints that show
how the sizes of causality subgraphs fluctuate in each iterationof the whole solving process. The two data sets are collected byevaluating Pus on curlandsqlite3and are visualized in Fig. 5 (a)
and Fig. 5 (b) respectively. It is clear that Fig. 5 (a) and Fig. 5 (b)
exhibit several common patterns:
â€¢The size of the causality graph normally increases greatly
as new indirect calls are resolved. This is because each time
when an indirect call is resolved, the newly resolved tar-
getfunctionsintroducemanyunprocessednodesandcon-
straints into the constraint graph. Those unprocessed nodes
arelikelytoinvalidatealargeportionoftheconstraintgraph,
which in turn increases the size of the causality subgraph
for the next iteration.
â€¢Afternewnodesareinserted,thesizeofthecausalitysub-
graph normally reduces sharply after several iterations. The
size then remains small until another set of new indirectcalls get resolved. This indicates that the solving process
convergesquicklyafterafewiterationsonmostofthenodes,Table4:Performanceof Puscomparingwithwavepropaga-
tion(WP)anddeeppropagation(DP)whenrunningcontext-insensitive pointer analysis (% â†‘shows the speedup).
Benchmark PUSWP DP
time %â†‘time %â†‘
memcached 0.04s 0.35s775.00% 0.1s150.45%
darknet 0.34s 1.82s435.29% 1.00s194.12%
flatbuffers 95.9s195.72s 104.08% 124.87s 30.28%
nfs-ganesha 11.17s 48.83s327.15% 26.48s137.06%
curl 18.45s 29.45s 59.62% 28.29s 53.27%
sqlite3 46.48s 98.77s125.50% 128.73s 176.96%
keydb-server 4.84s 7.58s56.61% 5.76s19.00%
vim 81.17s 183.81s 126.41% 193.70s 138.55%
cpython 400.66s 619.55s 54.61% 655.91s 63.70%
PostgreSQL 1,381.2s 1,757.9s 27.27% 2,001.6s 44.91%
avg. - -3.09Ã— -2Ã—
andthengraduallyapproachthefixedpointbyonlyprocess-
ing a very small number of nodes at each iteration.
Table 3 and Fig. 5 provide strong evidence to support our key
observation:Thesizeofcausalitysubraphsaresmallandupdateson
the points-to information of certain nodes only affect very limited
setofneighboringnodes.Fromtheseexperiments,wecaneasily
understandwhyPusisabletoachievesuchadramaticreductionbyanalyzingsmallcausalitysubgraphsinsteadoftheentireconstraint
graph at each iteration.
5.2 RQ2: The Performance Improvement
Achieved by Pus
Puswasevaluatedinbothcontext-insensitiveandcontext-sensitive
(ğ‘˜-callsite, with ğ‘˜=1) settings. and compared with Wp and Dp.
The experimental results are elaborated in Section 5.2.1 (when run-
ning context-insensitive analysis) and Section 5.2.2 (when running
context-sensitive analysis).
5.2.1 Improvement when Running Context-Insensitive Pointer Anal-
ysis.Inthe context-insensitivesetting, theexecution timeof each
algorithm when running on different benchmarks is given in Ta-
ble 4.
In summary, Pus achieves a significant performance improve-
ment compared to Wp and Dp, with more than 2 Ã—speedup on
average. For certain benchmarks, namely memcached anddarknet,
Puscanbe4Ã— asfasterthan Wp.Whencomparedwith Dp,Pusis
2Ã—fasteronmorethanhalfofthetestedbenchmarks(namely mem-
cached,darknet,nfs-ganesha, vimandsqlite3). Even in the worst
cases, Pus can still be more than 20% faster than Dp and Wp.
To understand how long ittakes for Pus to finish one iteration,
wealsocollectedtheanalyzingtimespentbyPusandWponevery
iteration.Thevisualizedgraph(whenanalyzing curl)isshownin
Fig. 6. From Fig. 6, it is clear that Pus is faster than Wp in every
iterationas Pus only processes a small causality subgraph. Note
that Dp is omitted in Fig. 6. It is because while Pus and Wp usea similar two-phases structure and their solving processes can be
easilyalignedandcompared.Dpadoptsadifferentsolvingstrategy
1789
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:34:15 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Peiming Liu, Yanze Li, Brad Swain, and Jeff Huang
:3 386
Figure 6: Comparison between the running time (in ms) of
Pus and WP that is spent on every iteration when runningoncurl.
386
'3
:3
    3RLQWVWR6HW &RQVWUDLQWV 2EMHFWV 3RLQWHUV
Figure7:ThememoryusagebreakdownforPus,DpandWponflatbuffers (inğ‘€ğµ).
which makes the comparison between Pus and Dp meaningless
when just looking at one iteration.
Inourexperiments,wealsomadeasimilarobservationasfound
in the original Wp and Dp paper [ 23]. The original paper observes
that Wp has an advantage over Dp when analyzing relatively large
programasWpisfasterthanDpon sqlite3,vim andcpythonandDp
isfasterthanWponrelativelysmallerprogramssuchas memcached,
redis-server andnfs-ganesha. The one exception is flatbuffer, which
has a relatively small number of lines of code (48.9K) while itscorresponding constraint graph is nearly as big as that of largeprograms such as vim. However, unlike Wp and Dp, which have
different advantages when analyzing programs of different scales,
PusoutperformsbothWpandDponallthetestedbenchmarkswiththesizesrangingfrom18
ğ¾toover1ğ‘€linesofcode.Puscanbe8 Ã—
faster and achieves at least a 19% speedup. The fact that Pus is able
to outperform both Wp and Dp on benchmarks of varying sizes
(both large and small) indicates that Pus is a much more general
algorithm that can be applied to all kinds of programs.
Inadditiontotheperformance,wealsoevaluatedthememory
efficiencyof PuswhencomparedtoDpandWp.Fig.7showstypical
memory usage breakdowns for Pus, Dp and Wp.
As mentioned in Section 3, Pus can greatly reduce the memory
consumptionbecausePusdoesnotrelyonacachedpoints-toset
toavoidredundantcomputation.Thememoryusagebreakdown
in Fig. 7 indicates that for both Wp and Dp, the memory used to
storepoints-tosets(includingcachedpoints-tosets)accountsforTable 5: Performance of Pus comparing with wave propa-
gation (WP) and deep propagation (DP) when running ğ‘˜-
callsite sensitive ( ğ‘˜=1) pointer analysis (% â†‘shows the
speedup).
Benchmark PUSWP DP
time %â†‘time %â†‘
memcached 0.08s 0.68s708.33% 0.26s210.71%
darknet 1.09s 6.36s484.30% 5.33s389.81%
flatbuffer 673.39s 4580.5s 580.22% 2542.8s 277.62%
nfs-ganesha 33.28s367.97s 1005.82% 459.54s 1281.0%
curl 37.58s266.98s 610.40% 258.3s587.31%
sqlite3 112.44s 639.64s 468.88% 961.3s754.96%
keydb-server 20.38s 77.51s 280.42% 79.66s290.98%
vim 367.62s 2587.1s 603.75% 3647.1s 892.09%
cpython 367.33s 3358.9s 814.43% 9559.7s 2502.5%
PostgreSQL OOM OOM -%OOM -%
avg. - -7.17Ã— -8.99Ã—
themajorityofthememoryusedtoanalyzeaprogram.SinceWp
requiresanextracopyofthepoints-tosetforeverynode andevery
edge, it requires the largest-sized memory to analyze the same
program. Dp is more memory efficient when compared to Wp as it
only requires an extra cached points-to set for each node, but even
for Dp, the memory used to store the points-to set still accountsfor the largest portion of entire used memory. Interestingly, the
memoryusedbyDptostorethepoints-tosetaloneislargerthan
the entire memory consumption needed by Pus. This shows the
greatadvantageof Pusovercomparedmethodsasitcanachieve
significant performance improvement while consuming much less
memory.
5.2.2 Improvement when Running Context-Sensitive Pointer Anal-
ysis.In the context-sensitive setting ( ğ‘˜-callsite, with ğ‘˜=1), the
executiontimeofeachalgorithmwhenrunningondifferentbench-
marks is given in Table 4.
Surprisingly, Pus even achieved much higher speedups when
solving context-sensitive constraints when compared to context-
insensitiveconstraints.Theresultsshowsthatonaverage,Pusis
almost7Ã—and9Ã—fasterthan Wp and Dprespectively. Forcertain
benchmarks, Pus can be more than 10 Ã—faster than Wp and Dp
(ganesha)and more than25 Ã—fasterthan Dp(python).On allbench-
marks, Pus is at least2Ã—faster than both Wp and Dp. The result
indicates that Pus has a great potential to be adopted widely as thecomputingpowerbecomesstrongerandstrongerandmoreprecise
pointer analysis is desired in the future.
ThereasonwhyPusisabletosignificantlyoutperformthestate-
of-the-art algorithms, especially when solving context-sensitivepointer analysis, is still rooted in our key insight that constraint
graphsare sparselyconnected.Thispropertybecomesevenmorees-
sential in context-sensitive pointer analysis as one node in context-
insensitive pointer analysis can correspond to multiple nodes in
context-sensitivepointeranalysisbecausethesamevariableisnow
analyzed separately under different contexts. This makes the con-
straint graph sparser. Thus, the effect brought by the update of one
node becomes more localas it can only affect nodes under some
1790
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:34:15 UTC from IEEE Xplore.  Restrictions apply. PUS: A Fast and Highly Efficient Solver for Inclusion-based Pointer Analysis ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
particularcontextswhereasonenodecanaffectmanyneighborsin
context-insensitive pointer analysis, even when the neighboring
nodes represent variables in a mismatched context.
DespiteallkindsofoptimizationsmadewhendesigningPus,we
stillfounditchallengingtoruncontext-sensitivepointeranalysis
onextremelylargebenchmarksusingonlycommodityhardware.
Astheğ‘˜-limitingforcontext-sensitivepointeranalysisincreases,
thecomplexityofthealgorithmandthesizeoftheconstraintgraph
grows exponentially, which makes the algorithm hard to scale
on large benchmarks. During the experiments, we observed that
more than 5 million nodes were created in the constraint graph for
PostgreSQL inthefirst5minutes,whichrapidlydrainsthememory
ofourmachine.Amorepowerfulmachineisneededforevaluating
Pus onPostgreSQL.
6 RELATED WORK
Pointer analysis is a fundamental building block for static program
analyses and compiler optimizations. As such, precise and scalable
pointeranalysishaslongbeensoughtafterasaholygrailthatmight
unlock all secrets in the program analysis universe. Unfortunately,
such apointer analysis algorithm hasyet to befound. All existing
implementation of pointer analysis must make some trade off.
Across the decades, Andersenâ€™s inclusion based pointer analysis
hasemergedasthemostpopularpointeranalyses[ 1].Manyworks
have been proposed to improve the base Andersenâ€™s analysis. Most
ofthe previousresearchabstractspointer analysisasaconstraint
graphandpropagatesthepoints-toinformationuntilaglobalfixed
point. Heintze et al. [ 11] introduced a way to avoid the cost of
computingthefulltransitiveclosureoftheconstraintgraph.Instead
a dynamic transitive closure is computed on demand and graph
reachabilityqueriesareusedtoresolvepoints-tosets.Asaresult,
cycle detection is achieved essentially for free as a result of the
graph reachability queries. However this technique also introduces
the potential for redundant work across reachability queries. Later
works [10,21,22] topologically sort the constraint graph to reduce
redundant points-to set propagation. Pereira et al. [ 23]p r o po s eda
newconstraintsolvingalgorithm,wavepropagation,byseparating
the algorithm into three phases; collapsing of cycles, points-topropagation and insertion of new edges. These three phases areperformed as a wave and repeated until a fixed point is reached.
Pusadvancesthestate-of-the-artbyperformingSCCdetectionand
points-to set propagation on the causality subgraph, thus avoiding
redundant computation in each iteration.
As the difficulty in developing an efficient constraint solving
algorithmremains,researchersrecentlyturnedtheirattentionto
tackle the problem at new angles. D4 [ 18] first introduced an in-
cremental algorithm for inclusion-based pointer analysis to enable
differential pointer analysis on code changes. The algorithm of D4
is orthogonal to ours and Pus can be efficiently integrated with D4
to speed up its bootstrapping constraint solving process. DEA [ 15]
introduced a faster algorithm to deal with positive-weight cycle in
field-sensitivepointeranalysis,whileitstillreliesonwavepropa-
gation to compute the fixed point.
AnotherlineofresearchformulatespointeranalysisasaCFL-
reachability problem. Reps et al. [ 25] modelled the flow-insensitive
pointeranalysisintoaCFL-reachabilityproblem.Spathetal.[ 29]proposedaflow-andcontext-sensitivedemand-drivenpointeranal-
ysis that models the pointer analysis as an IFDS problem, whichthen can be solved by CFL-reachability. This line of research isorthogonal to Pus, and Pus is more efficient when applications
frequently query pointer analysis results.
Graphsimplificationtechniquescanbeappliedtobothconstraint-
graph-based and CFL-reachability-based approaches to improve
theirscalability.Fahndrichetal.[ 7]firstshowedthatcollapsingSCC
components in the constraint graph can significantly improve the
performance of inclusion based pointer analysis. Pearce et al. [ 21]
introduced an algorithm for online cycle detection. By keeping the
constraint graph topologically sorted, cycle detection need only
be run when a new edge violates the existing topological ordering.
Since detecting cycles upon edge insertion was proven to be too
costly, Pearce et al. [ 22] introduced an efficient field sensitive PTA
thatoccasionallychecksforandcollapsescyclesintheconstraint
graph.Hardekopfetal.[ 10]introducedLazyCycleDetection(LCD)
andHybridCycleDetection(HCD).LCDreducesruntimeoverhead
even further by selectively triggering cycle detection only whenidentical points-to sets are discovered during transitive closure
computation. HCD introduces an offline linear-time graph prepro-
cessingstagethatallowstheonlinepointeranalysistodetectcycles
withouttheneedforgraphtraversalatall.Pusextendstheabove
techniquesbynotonlyapplyinggeneralgraphoptimizationtech-
niques but also leveraging unique properties of constraint graph to
only performing the SCC detection on causality subgraph. Thus,
Puscandynamically pruneoff themostineffective edgestoavoid
redundant points-to set propagation.
Recent work by Li et al. [ 17] proposed to simplify the input
labeled graph in a CFL-reachability problem by eliminating use-less graph edges. Pus is similar to this work from a very high-
level.However,thisworkprimarilyoptimizethelabeledgraphin
CFL-reachability problems while Pus focuses on simplifying the
constraint graphs in pointer analysis.
Besides improving the solving algorithm, researchers have also
proposedtouseDatalog[ 5,27,28]forfastandeasypointeranal-
ysis implementation. While the experimental result indicates a
greatpotentialalongthedirection,fullycustomizedpointeranal-
ysissolversarestilldesiredandusedbymanyofthemostrecent
works [18,26,32] as they are easier to be extended and tailored for
different needs.
7 CONCLUSION
We have presented Partial Update Solver (Pus), a new constraint
solving algorithm for inclusion-based pointer analysis. Pus signifi-
cantlyadvancesthestate-of-the-artinreducingthetimecomplexitybyaquadraticfactor.Thekeyinsightisthatonlyasmallportionof
theconstraintgraphiseffectiveforthepoints-tosetpropagation,
which can be extracted efficiently into a subgraph, called causality
subgraph. We have formally proved the correctness of Pus and
extensivelyevaluatedtheperformanceof Pusonawiderangeof
real-world large complex programs. Our experimental results indi-
cate that Pus is high scalable and significantly more efficient than
the state-of-the-art Wp/Dp algorithms. Pus achieves more than
7Ã—(2Ã—) speedups when comparing to Wp/Dp in solving context-
sensitive and context-insensitive pointer analyses respectively.
1791
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:34:15 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Peiming Liu, Yanze Li, Brad Swain, and Jeff Huang
REFERENCES
[1]Lars Ole Andersen. 1994. Program analysis and specialization for the C program-
ming language. Ph.D. Dissertation. University of Cophenhagen.
[2]Mohamad Barbar, Yulei Sui, and Shiping Chen. 2020. Flow-sensitive type-based
heap cloning. In 34th European Conference on Object-Oriented Programming
(ECOOP 2020). Schloss Dagstuhl-Leibniz-Zentrum fÃ¼r Informatik.
[3]MohamadBarbar,YuleiSui,andShipingChen.2021. ObjectVersioningforFlow-
Sensitive Pointer Analysis. In 2021 IEEE/ACM International Symposium on Code
Generation and Optimization (CGO). IEEE, 222â€“235.
[4]Rastisalv BodÃ­k and Sadun Anik. 1998. Path-sensitive value-flow analysis. In
Proceedingsofthe25thACMSIGPLAN-SIGACTsymposiumonPrinciplesofpro-
gramming languages. 237â€“251.
[5]Martin Bravenboer and Yannis Smaragdakis. 2009. Strictly declarative specifica-
tionofsophisticatedpoints-toanalyses.In Proceedingsofthe24thACMSIGPLAN
conferenceonObjectorientedprogrammingsystemslanguagesandapplications.
243â€“262.
[6]SigmundCherem,LonniePrincehouse,andRaduRugina.2007. Practicalmemory
leak detection using guarded value-flow analysis. In Proceedings of the 28th ACM
SIGPLANConferenceonProgrammingLanguageDesignandImplementation.480â€“
491.
[7]Manuel FÃ¤hndrich, Jeffrey S Foster, Zhendong Su, and Alexander Aiken. 1998.
Partial online cycle elimination in inclusion constraint graphs. In Proceedings of
theACMSIGPLAN1998conferenceonProgramminglanguagedesignandimple-
mentation. 85â€“96.
[8]GangFan,RongxinWu,QingkaiShi,XiaoXiao,JinguoZhou,andCharlesZhang.
2019. Smoke: scalable path-sensitive memory leak detection for millions of lines
of code. In 2019 IEEE/ACM 41st International Conference on Software Engineering
(ICSE). IEEE, 72â€“82.
[9]SeyedhamedGhavamnia,TaptiPalit,ShacheeMishra,andMichalisPolychronakis.
2020. Temporalsystemcallspecializationforattacksurfacereduction.In 29th
{USENIX}Security Symposium ( {USENIX}Security 20). 1749â€“1766.
[10]Ben Hardekopf and Calvin Lin. 2007. The ant and the grasshopper: fast and
accurate pointer analysis for millions of lines of code. In Proceedings of the 28th
ACMSIGPLANConferenceonProgrammingLanguageDesignandImplementation.
290â€“299.
[11]Nevin Heintze and Olivier Tardieu. 2001. Ultra-fast aliasing analysis using CLA:
AmillionlinesofCcodeinasecond. ACMSIGPLANNotices 36,5(2001),254â€“263.
[12]Susan Horwitz. 1997. Precise flow-insensitive may-alias analysis is NP-hard.
ACMTransactionsonProgrammingLanguagesandSystems(TOPLAS) 19,1(1997),
1â€“6.
[13]Vineet Kahlon, Yu Yang, Sriram Sankaranarayanan, and Aarti Gupta. 2007. Fast
and accurate static data-race detection for concurrent programs. In International
Conference on Computer Aided Verification. Springer, 226â€“239.
[14]Chris Lattner and Vikram Adve. 2004. LLVM: A compilation framework for
lifelong program analysis & transformation. In International Symposium on Code
Generation and Optimization, 2004. CGO 2004. IEEE, 75â€“86.
[15]Yuxiang Lei and Yulei Sui. 2019. Fast and precise handling of positive weight cy-
clesforfield-sensitivepointeranalysis.In InternationalStaticAnalysisSymposium.
Springer, 27â€“47.
[16]YanzeLi,BozhenLiu,andJeffHuang.2019. Sword:Ascalablewholeprogram
racedetectorforjava.In 2019IEEE/ACM41stInternationalConferenceonSoftware
Engineering: Companion Proceedings (ICSE-Companion). IEEE, 75â€“78.
[17]YuanboLi,QirunZhang,andThomasReps.2020. Fastgraphsimplificationfor
interleavedDyck-reachability.In Proceedingsofthe41stACMSIGPLANConference
on Programming Language Design and Implementation. 780â€“793.
[18]BozhenLiuandJeffHuang.2018. D4:FastConcurrencyDebuggingwithParallel
Differential Analysis. In Proceedings of the 39th ACM SIGPLAN Conference on
ProgrammingLanguageDesignandImplementation (Philadelphia,PA,USA) (PLDI
2018). Association for Computing Machinery, New York, NY, USA, 359â€“373.
https://doi.org/10.1145/3192366.3192390
[19]BozhenLiu,PeimingLiu,YanzeLi,Chia-CheTsai,DilmaDaSilva,andJeffHuang.
2021. When threads meet events: efficient and precise static race detection with
origins. In Proceedings of the 42nd ACM SIGPLAN International Conference on
Programming Language Design and Implementation. 725â€“739.
[20]Mayur Naik, AlexAiken,and John Whaley. 2006. Effective static racedetection
forJava.In Proceedingsofthe27thACMSIGPLANConferenceonProgramming
Language Design and Implementation. 308â€“319.
[21]DavidJPearce,PaulHJKelly,andChrisHankin.2003. Onlinecycledetectionand
differencepropagationforpointeranalysis.In ProceedingsThirdIEEEInternational
Workshop on Source Code Analysis and Manipulation. IEEE, 3â€“12.
[22]DavidJPearce,PaulHJKelly,andChrisHankin.2007. Efficientfield-sensitive
pointeranalysisofC. ACMTransactionsonProgrammingLanguagesandSystems
(TOPLAS) 30, 1 (2007), 4â€“es.
[23]Fernando Magno Quintao Pereira and Daniel Berlin. 2009. Wave propagation
anddeeppropagationforpointeranalysis.In 2009InternationalSymposiumon
Code Generation and Optimization. IEEE, 126â€“135.[24]GanesanRamalingam.1994. Theundecidabilityofaliasing. ACMTransactions
on Programming Languages and Systems (TOPLAS) 16, 5 (1994), 1467â€“1471.
[25]ThomasReps.1998. Programanalysisviagraphreachability. Informationand
software technology 40, 11-12 (1998), 701â€“726.
[26]QingkaiShi,XiaoXiao,RongxinWu,JinguoZhou,GangFan,andCharlesZhang.
2018. Pinpoint: Fast and precise sparse value flow analysis for million linesof code. In Proceedings of the 39th ACM SIGPLAN Conference on Programming
Language Design and Implementation. 693â€“706.
[27]YannisSmaragdakisandGeorgeBalatsouras.2015. Pointeranalysis. Foundations
and Trends in Programming Languages 2, 1 (2015), 1â€“69.
[28]Yannis Smaragdakis and Martin Bravenboer. 2010. Using Datalog for fast and
easyprogramanalysis.In InternationalDatalog2.0Workshop.Springer,245â€“251.
[29]Johannes SpÃ¤th, Lisa Nguyen Quang Do, Karim Ali, and Eric Bodden. 2016.
Boomerang: Demand-driven flow-and context-sensitive pointer analysis for java.
In30th European Conference on Object-Oriented Programming (ECOOP 2016).
Schloss Dagstuhl-Leibniz-Zentrum fuer Informatik.
[30]ManuSridharanandStephenJFink.2009. ThecomplexityofAndersenâ€™sanalysis
in practice. In International Static Analysis Symposium. Springer, 205â€“221.
[31]Bjarne Steensgaard. 1996. Points-to analysis in almost linear time. In Proceedings
of the 23rd ACM SIGPLAN-SIGACT symposium on Principles of programming
languages. 32â€“41.
[32]YuleiSuiandJinglingXue.2016.SVF:interproceduralstaticvalue-flowanalysisinLLVM.In Proceedingsofthe25thinternationalconferenceoncompilerconstruction.
265â€“266.
[33]YuleiSui,DingYe,andJinglingXue.2012. Staticmemoryleakdetectionusing
full-sparsevalue-flowanalysis.In Proceedingsofthe2012InternationalSymposium
on Software Testing and Analysis. 254â€“264.
[34]WALA. 2017. T. J. Watson Libraries for Analysis (WALA).
http://wala.sourceforge.net/.
[35]Yichen Xie and Alex Aiken. 2005. Context-and path-sensitive memory leakdetection. In Proceedings of the 10th European software engineering conference
heldjointlywith 13thACMSIGSOFTinternational symposiumonFoundationsof
software engineering. 115â€“125.
1792
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:34:15 UTC from IEEE Xplore.  Restrictions apply. 