Classifying Edits toVariabilityin Source Code
Paul MaximilianBittner
paul.bittner@uni-ulm.de
University ofUlm
Ulm, GermanyChristofTinnes
christof.tinnes@siemens.com
Siemens AG
MÃ¼nchen, GermanyAlexander SchultheiÃŸ
alexander.schultheiss@hu-berlin.de
HumboldtUniversity ofBerlin
Berlin, Germany
SÃ¶ren Viegener
soeren.viegener@uni-ulm.de
University ofUlm
Ulm, GermanyTimo Kehrer
timo.kehrer@inf.unibe.ch
University ofBern
Bern, SwitzerlandThomasThÃ¼m
thomas.thuem@uni-ulm.de
University ofUlm
Ulm, Germany
ABSTRACT
Forhighlyconfigurablesoftwaresystems,suchastheLinuxkernel,
maintaining and evolving variability information along changes
to source code poses a major challenge. While source code itself
maybeedited,alsofeature-to-codemappingsmaybeintroduced,
removed, or changed. In practice, such edits are often conducted
ad-hoc and without proper documentation. To support the mainte-
nance and evolution of variability, it is desirable to understand the
impactofeacheditonthevariability.Weproposethefirstcomplete
andunambiguousclassificationofeditstovariabilityinsourcecode
by means of a catalog of edit classes. This catalog is based on a
schemethatcanbeusedtobuildclassificationsthatarecomplete
andunambiguousbyconstruction.Tothisend,weintroduceacom-
plete and sound model for edits to variability. In about 21.5msper
commit,wevalidatethecorrectnessandsuitabilityofourclassifi-
cationbyclassifyingeacheditin1.7millioncommitsinthechange
historiesof44open-sourcesoftwaresystemsautomatically.Weare
abletoclassifyalleditswithsyntacticallycorrect feature-to-code
mappings andfindthat alloureditclasses occurin practice.
CCSCONCEPTS
â€¢Software and its engineering â†’Software configuration
managementandversioncontrol systems ;Softwareevolution .
KEYWORDS
softwareevolution,softwarevariability,featuretraceability,soft-
ware product lines,miningversion histories
ACM Reference Format:
Paul Maximilian Bittner, Christof Tinnes, Alexander SchultheiÃŸ, SÃ¶ren
Viegener, Timo Kehrer, and Thomas ThÃ¼m. 2022. Classifying Edits to Vari-
abilityinSourceCode. In Proceedingsofthe30thACMJointEuropeanSoft-
ware Engineering Conference and Symposium on the Foundations of Software
Engineering (ESEC/FSE â€™22), November 14Å›18, 2022, Singapore, Singapore.
ACM,NewYork,NY,USA, 13pages.https://doi.org/10.1145/3540250.3549108
ESEC/FSE â€™22, November 14Å›18,2022, Singapore, Singapore
Â©2022 Copyright heldby theowner/author(s).
ACM ISBN 978-1-4503-9413-0/22/11.
https://doi.org/10.1145/3540250.35491081 INTRODUCTION
In configurable software systems, such as the Linux kernel, certain
code should only be present in certain variantsof the software. For
instance, parts of the code base may be platform dependent or a
featureshouldonlybeavailabletoasubsetofcustomers.Maintain-
ingandevolvingvariabilityinformationalongchangestosource
codeposesamajorchallengefordevelopers[ 77,78,89].Oneaspect
thereofiskeepingtrackofchangestovariablepartsofthecodebase
that implement different featuresor feature interactions of the con-
figurable software. While source code itself may be edited, feature-
to-codemappings may alsobe introduced,removed,orchanged.
Awarenessofeditstovariabilityiscrucialinthedevelopment
of configurable software. For instance, edits to software product
linesmightintroducetypeerrorsincertainvariants[ 40]oralter
thesetofavailablevariantsinanunintendedway[ 69,71,84,91].
Inclone-and-owndevelopment,whereeachvariantofasoftware
is developed as a separate copy ofthe software (e.g., using branch-
ing or forking), changes to variants have to be tracked to update
other variants accordingly [ 45,50,51,53,102]. Variation control
systems [ 59,60,90] and managed clone-and-own methods [ 45,63]
inspect edits paired with information on edited features [ 10,37]
to recover knowledge about variability incrementally [ 61] or to
reintegrateedits toahidden unifiedcode base[ 90].
In practice, however, the variability of the code base is often
editedad-hocandwithoutproperdocumentation.Whilechanges
aretechnicallycapturedintermsofcommitstoaversioncontrol
system,theirimpactonthevariabilityisnotexplicitlyaccountedfor
and mostly opaque to developers and tools [ 34]. Instead of dealing
withpurelysyntacticalchangesonthegranularitylevelofcommits,
it is desirable to describe the difference between two versions of
the code base as edits for which the effect on the variability is
known. For example, one important class of edits to variability are
refactorings,whichchangethestructurebutnotthesemanticsof
variabilityinformation.Knowingsucheffectsisusefulasfurther
maintenanceandevolutiontaskscanbesimplified[ 11,70,71],such
asadaptingthetestsuiteofasoftwareproductline[ 1,62]orthe
propagation of changes between cloned variants or forks [ 45,102].
Although the literature has recognized the need for characteriz-
ing variability evolution, a complete, unambiguous, and automated
classificationofeditsdoesnotyetexist.Studiesonsoftwareproduct
lines focus on specific scenarios such as variability-aware muta-
tion testing [ 2] or safe evolution [ 69,87,88], or cover only edits
tovariabilitymodels[ 3,95,95]orconfigurationsofvariants[ 71].
ThisworkislicensedunderaCreativeCommonsAttribution-ShareAlike4.0
InternationalLicense.
196
ESEC/FSE â€™22, November14Å›18, 2022,Singapore, Singapore P. M. Bittner, C.Tinnes, A.SchultheiÃŸ, S.Viegener, T. Kehrer, T. ThÃ¼m
Classifications of co-evolution of variability models and source
code make no claims on completeness (i.e., there may be edits
that cannot be classified) and require a manual identification of
edits[11,78,89].Similarly,classificationsofeditsinmanagedclone-
and-owneitherrequireamanualeditinvestigation[ 37],orsuffer
from ambiguity [ 90], andincompleteness [ 37,90].
Tothisend,wepresentacomplete,unambiguous,andautomatic
classificationofeditstovariabilityinsourcecode.Wefirstintroduce
variation trees as a formalization for variability in source code. We
thenintroduce variationdiffs asaformalizationforeditstovariation
trees, thus describingedits to variability in source code. We prove
that variation diffs are complete and sound regarding variation
trees,meaningthatanypossibleedittoavariationtreeisdescribed
byavariationdiffandthateveryvariationdiffrepresentsanactual
edittovariationtrees.Byclassifyingallstructureswithinvariation
diffs,weareabletoclassifyalleditstovariabilityinsourcecode.
We present a set of edit classes which we prove to be complete and
unambiguousonvariationdiffs.Insummary,ourcontributionsare:
Formalization We present variation trees and variation diffs as
formalizationsforvariabilityinsourcecodeandeditstoit.We
prove that variation diffsare sound andcomplete.
Classification Wepresentacatalogofclassesforeditstovariabil-
ity in source code and prove its completeness and unambiguity.
Automation We present DiffDetective , a tool to automatically
classify edits in histories of software in which variability is
implementedwiththe C preprocessor.
Validation We validate that our concepts and classes are suitable
to describe andclassifyeditsto variability insourcecode.
2 VARIABILITYINSOURCECODE
In this section, we first give an intuitive answer to what variability
insourcecodeis.Second,weproposeaformalizationforvariability
insourcecode,whichwe use toclassifyeditstovariability inthis
work. Third,we discuss the suitabilityofour formalization.
2.1 WhatIsVariabilityin SourceCode?
Variabilityinsourcecodemeansthatcertaincodeshouldonlybe
presentincertain variantsofthesoftware.Yet,specifyingvariability
of source code by listing the respective set of variants for each
source code fragment is usually infeasible for tools and developers
because configurable software may induce millions of variants [ 68,
92].Instead, distinguishingvariants in termsof featuresproved to
be successful in software product-line engineering [ 4,16,39,81]
andclonemanagement[ 28,37,63,90],afeaturebeinginformally
defined as a variable characteristic of the software. Each variant of
asoftwaresystemisthenspecifiedbyafeatureselection,usually
referredtoas configuration [4],statingwhichfeaturesthevariant
implements.Eachsourcecodefragmentinturn,isassociatedtothe
featuresitimplements.Ascommonintheliterature[ 4,15,18,58,
63,67,90,99], we refer to this association as the presence condition
ofthecode.Sourcecodeisthusincludedinexactlythosevariants
whose configurationssatisfy the codeâ€™spresencecondition.
In practice, conditional compilation is a widely adopted strategy
toinducepresenceconditions.ProminentexamplesaretheLinux
kernel, Busybox, and Vim that use the C preprocessor. Source code
canbemappedtoanypropositionalformulaoverfeatureswiththe4202#ifdef FEAT_GUI
4203 if(gui.in_use)
4204 gui_mch_set_foreground();
4205#else
4206# ifdef MSWIN
4207 win32_set_foreground();
4208# endif
4209#endif
Listing 1:Variabilityspecified withconditional compilation
insrc/evalfunc.c inVim at commit ab4cece.
Cpreprocessordirectives #if,#ifdef,and#ifndef,where#ifdef
and#ifndef checkwhetheracertainmacronameisdefinedornot
defined,respectively.Hence, #ifdefand#ifndefcanbeusedto
checkwhetherafeatureisselectedordeselected,while #ifcantest
complexconditions. Listing1 showsanexcerptofgraphicaluser
interfacecodefromVimwithpreprocessorannotations.IfVimis
compiledwiththefeature FEAT_GUI selected,lines4203and4204
areincludedinthecompiledvariant.Ifthefeature FEAT_GUI isnot
selectedandVimiscompiledfortheWindowsoperatingsystem(i.e.,
MSWINisselected),Line4207isincludedinstead.Inthiscodesnippet,
lines 4203 and 4204 thus share the presence condition FEAT_GUI
but Line 4207 has the presence condition Â¬FEAT_GUI âˆ§MSWIN. Yet,
Listing 1 is just an excerpt that is again surrounded by further
preprocessorannotations,notshownhere.Consequently,theactual
presenceconditions are even more complex.
As illustrated in this example, there is a difference between the
presenceconditionofacodechunkanditsdirectannotation,which
werefertoasthecodeâ€™s featuremapping .Inparticular,thepresence
condition may be composed of one or more feature mappings, aris-
ing from nesting. As shown in Listing 1, Line 4207 is only mapped
toMSWINwhile its presence condition is also determined by the
selection of FEAT_GUI . A presence condition thus is a conjunction
offeature mappings.
In essence, feature mappings and presence conditions are a
means to describe variability in source code because they allow to
defineanysubsetofvariantsastargetforeachimplementationarti-
fact.Byinspectingfeaturemappingsandeditstofeaturemappings,
we can thus observe editsto variability insourcecode.
2.2 Formalizationas VariationTrees
To inspect possible edits to feature mappings, we define feature
mappingsandpresenceconditionsformally.Wefirstdefinewhat
can be mapped to features and how elements can be mapped to
featuresandfeatureinteractions.Wethenintroducevariationtrees
as aformalizationto represent nestinghierarchies.
Apartfromsourcecode,variabilitymightalsoaffectotherim-
plementationartifacts(e.g.,documentation,buildfiles,modelele-
ments) [5,41,60]. Even the granularity of implementation artifacts
mayvary indifferentcontexts.Forinstance, one might interpret
sourcecodeaslinesoftextorasanabstractsyntaxtree[ 39]:Ver-
sion control systems, such as Git, usually regard source code as
linesoftextwhiledevelopersandcompilersareawareofthecodeâ€™s
structure. For our tooling and empirical validation, we focus on
197Classifying Edits to Variabilityin Source Code ESEC/FSE â€™22, November14Å›18, 2022,Singapore, Singapore
linesofsourcecodeandpreprocessor-basedvariability.Neverthe-
less,wedesignourconceptstocoveramultitudeofimplementation
artifacts andimplementationtechniques for feature mappings:
Definition 2.1 (Implementation Artifact). An implementation ar-
tifact is an identifiable unit of any granularity within a software
project(e.g.,tokens, linesofcode,modelelements, orentire files).
Mappinganartifacttothefeaturesitimplementscanbedonein
several ways.Forexample,eachartifact can be mappedto exactly
one feature [ 94], a set of features [ 39], or to exactly one proposi-
tional formula over the set of features [ 10,67,90]. In this work, we
map artifacts to propositional formulas, also covering mappings to
single features (as formulas consisting of a single variable) or sets
offeatures(asconjunctionsofvariables).Anartifactmappedtoa
formulağ‘“isthenincludedinexactlythosevariantsunderwhose
configuration ğ‘“evaluates to true.
As illustrated in the previous Section 2.1 , an artifactâ€™s presence
conditiondependsontheartifactâ€™slocationwithinanestinghier-
archyoffeaturemappings,whichexhibitsatreestructure.Wethus
introduce variation trees as a formal model for nesting hierarchies:
Definition2.2(VariationTree). Avariationtree (ğ‘‰,ğ¸,ğ‘Ÿ,ğœ,ğ‘™ )isa
treewithnodes ğ‘‰,edgesğ¸âŠ†ğ‘‰Ã—ğ‘‰,androotnode ğ‘Ÿâˆˆğ‘‰.Eachedge
(ğ‘¥,ğ‘¦) âˆˆğ¸connectsa child node ğ‘¥withits parentnode ğ‘¦,denoted
byğ‘(ğ‘¥)=ğ‘¦. The node type ğœ(ğ‘£) âˆˆ {artifact ,mapping,else}
identifiesanode ğ‘£âˆˆğ‘‰eitherasrepresentinganimplementation
artifact, a feature mapping, or an else branch. The label ğ‘™(ğ‘£)is a
propositional formula if ğœ(ğ‘£)=mapping, a reference to an imple-
mentation artifact if ğœ(ğ‘£)=artifact , or empty if ğœ(ğ‘£)=else.
The rootğ‘Ÿhas typeğœ(ğ‘Ÿ)=mapping and label ğ‘™(ğ‘Ÿ)=true. Anelse
nodecanonlybeplaceddirectlybelowanon-root mappingnode
andamappingnode has at mostone childoftype else.
Nodesinavariationtreeeitherrepresentimplementationarti-
factsorfeaturemappingsonallitschildren.Theroot ğ‘Ÿissynthetic
togroupallartifactsandmappings,andmayrepresentanentirefile
for example. Itâ€™sformula truedenotes that it ispart of all variants,
justas an annotation #iftrue does.
As an example, Figure 1shows the variation tree induced by
the annotations in Listing 1. Each node is labeled with its line
numberfrom Listing1 aswellasitscodeorformula,respectively.
Annotationsaredrawnwithablueborder,whilenodesreferencing
linesofcodearedrawnwithablackborder.Consecutivelinesof
code within the same annotation, are grouped as a single node and
labeled with the first lineâ€™s number; in particular, lines 4,203 and
4,204 are grouped. Note that #endifdirectives are part of their
corresponding mapping nodes by determining which nodes are
children andwhichnodes are siblings ofthe respective mapping.
To model preprocessor-based variability more accurately and
because of our running example, we treat elsestatements as first-
classcitizensinvariationtrees.Notallkindsofannotationsdohave
anelseconstructthough[ 36,37],inwhichcase elsenodescan
simplybeomitted.Inourappendix,1weshowthatwecaninfact
parameterize a variationtree in theset of its node types such that
variation trees can support further language constructs for specify-
ingvariability,suchassyntacticsugarlike elif.Infact,weconsider
1https://github.com/VariantSync/DiffDetective/raw/esecfse22/appendix.pdfr4202
#if FEAT_GUI
4203
if (gui.in_use)4205
#else4206
#if MSWIN4207
win32_set_foreground();
Figure 1:Variationtree of Listing 1 .
elifdirectivesexplicitlyinourvalidationin Section5.Yet,such
extensionsarecosmeticanddonotimpactthevalidityofourresults
aselseandelifnodes can also be expressed as mappingnodes
(e.g., lines 4,205 and 4,206 in Listing 1 actually describe an elif).
Thesetofnodetypesmustatleastcontain artifact andmapping
andmightbe extendedbyfurther types to increasegranularity.
Variationtreesfacilitatenestingnodesbelow artifact nodes.
While such nesting never occurs for annotating lines of code (as
lines cannot be nested in lines), other artifacts, such as abstract
syntaxtrees[ 39]ormodels,mayexhibitnesting.Forexample,when
annotatingaCstructanditâ€™sfieldsinanabstractsyntaxtree,the
fieldsâ€™mappingnodeswouldbeplacedbelowthe artifact nodeof
thestruct.Yet,inourexamplesandourvalidation artifact nodes
are line-based,sonodes willnever occur below artifact nodes.
Variationtreesdirectlyreflectthenestinghierarchyemployed
by developers and thus also reflect any individual feature mapping
(e.g.,#ifannotations) that is assigned to a group of artifacts. From
avariationtree,wecancomputethefeaturemappingofanartifact
given its corresponding node ğ‘›:
F(ğ‘›)â‰”ï£±ï£´ï£´ï£´ ï£²
ï£´ï£´ï£´ï£³F(ğ‘(ğ‘›)), ğœ(ğ‘›)=artifact ,
ğ‘™(ğ‘›), ğœ(ğ‘›)=mapping,
Â¬F(ğ‘(ğ‘›)), ğœ(ğ‘›)=else.(1)
First, the feature mapping of an artifact node is given by the
annotationaboveit.Second,a mappingnoderepresentsafeature
mappingandhasitsformulastoredinitslabelthatisobtainedby ğ‘™.
Finally, for elsebranches, we have to negate the feature mapping
ofthe corresponding mapping.
Basedonvariationtrees,wecanalsodefinepresenceconditions.
Asforfeaturemappings,thepresenceconditionofanimplemen-
tationartifactcanbecomputedfromitscorrespondingnode ğ‘›in
thevariationtree.Computingthepresenceconditionofanodeis
similartocomputingitsfeaturemapping,exceptthatwehaveto
inspecteveryancestorabovethenode,insteadofjustthenearest
mapping node. Given a variation tree with root ğ‘Ÿ, we define the
presencecondition ofanode ğ‘›recursivelyas:
PC(ğ‘›)â‰”ï£±ï£´ï£´ï£´ï£´ï£´ ï£²
ï£´ï£´ï£´ï£´ï£´ï£³PC(ğ‘(ğ‘›)), ğœ(ğ‘›)=artifact ,
F(ğ‘›) âˆ§PC(ğ‘(ğ‘›)), ğœ(ğ‘›)=mapping,ğ‘›â‰ ğ‘Ÿ,
F(ğ‘›) âˆ§PC(ğ‘(ğ‘(ğ‘›))), ğœ(ğ‘›)=else,
F(ğ‘›), ğ‘› =ğ‘Ÿ.(2)
First, as the feature mapping of an artifact nodeğ‘›is given by
itsparent,alsoitspresenceconditionisdeterminedbyitsparent
ğ‘(ğ‘›). Second, the presence condition of a mappingnode is given
by its own formula in conjunction with the presence condition
of its parent because any feature mapping may itself be nested
198ESEC/FSE â€™22, November14Å›18, 2022,Singapore, Singapore P. M. Bittner, C.Tinnes, A.SchultheiÃŸ, S.Viegener, T. Kehrer, T. ThÃ¼m
withinfurther mappings. Third, alsothepresence conditionof an
elsenodeisgivenbyitsownfeaturemappinginconjunctionwith
the presence condition of any outer nodes. However, to access the
outernodesofan else,wehavetoretrievetheparent ğ‘(ğ‘(ğ‘›))of
itscorresponding mappingnodeğ‘(ğ‘›).Fourth,the rootâ€™spresence
condition is solely determined by its own formula F(ğ‘Ÿ)=ğ‘™(ğ‘Ÿ)=
truebecause the root is not nested. Note that trueacts neutral
on conjunctions âˆ§, and thus the synthetic root has no effect on
computing presenceconditions.
2.3 Discussion ofCompletenessandSoundness
The key property of variation trees isto distinguish presencecon-
ditionsfromfeaturemappings.Variationtreesdirectlyreflectthe
nestinghierarchyemployedbydevelopersandthusalsoreflectany
individualfeaturemappingthatis assignedtoagroupofartifacts.
Inthissection,wediscuss ourdesigndecisionsfor definingvaria-
tiontreesandwhyweconsidervariationtreestobeanadequate
modelfor variability insourcecode.
Completeness . We first discuss design decisions regarding the
completenessofvariationtrees.Thatis,theirsuitabilityforexpress-
ing feature mappings and presence conditions, independent of the
underlying implementationstrategyfor variability.
Variationtreesaredirectlyinspiredbyannotativeapproaches,in
particular preprocessor directives. Yet ingeneral, feature mappings
are specified either by annotating source code, as shown in our
example, orby composition ofmodules[ 39].In annotation-based
strategies,sourcecodeisannotatedwiththefeaturesitimplements,
for example with comments [ 12,37], external metadata [ 39], or
conditional compilation as shown in Listing 1. These strategies
annotatesourcecodewithfeaturesorfeatureformulasandbecause
ourformalizationdoesnotmentionanyconcretemacros,weargue
thatmappingnodesaregeneralenoughtocoveranykindofcon-
ditionalannotation.Moreover, whenentire filesor directoriesare
annotated(e.g.,withbuildsystems[ 20])alsothedirectorystructure
withitsannotationcanbedescribedwithcorresponding artifact
andmappingnodesabovetheactualfilecontents.Compositional
strategies group artifacts in modules (e.g., plugins or packages)
and inturnmapmodulesto features.Compositionalstrategiesusu-
ally do not exhibitnestinghierarchies,so presenceconditionsare
usuallyequaltofeaturemappings.Nevertheless,wearguethatvari-
ation trees are general enough to also reflect compositional feature
mappings, in particular by representing a module ğ‘šassigned to
featureğ‘“by a node ğ‘£with type ğœ(ğ‘£)=mapping and label ğ‘™(ğ‘£)=ğ‘“
andgroupingtheimplementationartifactsof ğ‘šincorresponding
childnodes.Inconclusion,whileimplementationstrategiesforvari-
abilitydiffervastlyintheirtechnicalrealization,allofthemyield
thesameconceptualresult:aspecificationoffeaturemappingsand
presence conditions to determine which code fragments should be
present inwhichvariants,the key purpose ofvariation trees.
With variation trees, we map artifacts to propositional formu-
las. In practice though, artifacts might also be mapped to formu-
las including non-boolean expressions (e.g., arithmetics such as
#ifğ‘¥==3). Indeed, our concepts also support more sophisticated
theories than propositional logic(e.g., higher-orderlogic) because
we only require the propositional operators conjunction âˆ§and1#ifdef FEAT_GUI
2if (gui.in_use)
3+ {
4gui_mch_set_foreground();
5-#else
6-# ifdef MSWIN
7+ return;
8+ }
9+#endif
10+#if defined(MSWIN) && (!defined(FEAT_GUI) || defined(VIMDLL))
11 win32_set_foreground();
12-# endif
13#endif
Listing 2: Edits made to Listing 1 in commit afde13b in Vim.
negationÂ¬,aswellastheatom truewiththeirusualsemanticsand
do not impose any otherrestrictionsonthe logic.
To the best of our knowledge, we thus believe that variation
trees are general enough to cover all strategies known to us for
specifying feature mappings andpresenceconditions.
Soundness . We now discuss design decisions regarding the
soundnessofvariationtrees,meaningthatvariationtreesindeed
describe feature mappings andpresenceconditions.
OurDefinition2.2 ofvariationtrees ensures thatfeature map-
pingsandpresenceconditionsarealwaysdefined.Eachnodehas
exactly one parent, except for the root, because variation trees are
trees.Hence,theparent ğ‘isalwaysdeterminedintherespective
casesofFandPC.Bydefinition,every elsehasacorresponding
non-root mapping nodeasitsparent,hence(1)thefeaturemapping
Fofanelseisindeedthenegationofitscorresponding mapping
node, and (2) also the grandparent ğ‘(ğ‘(ğ‘›))exists for each else
node, which is accessed for computing the presence condition. Fur-
ther, trees and thus variation trees contain no cycles meaning that
anyrecursivecomputationof feature mapping Forpresencecondi-
tionsPCeventuallyendsattherootandthusterminates.Therefore,
bothfeaturemapping Fandpresencecondition PCcanalwaysbe
computed, meaning that variation trees are always a description of
variability inimplementationartifacts, andthus sound.2
Conclusion . Having laid the formal foundations for variability
in source code, we inspect how the variability may be edited in
the remainderof this paper.What kinds ofedits couldbe made to
Listing1?Howwouldsucheditsaffectthecorrespondingvariation
tree shownin Figure 1?
3 EDITS TO VARIABILITYINSOURCECODE
Whilesourcecodeitselfmaybeedited,alsothesetofvariantsof
one or more code fragments may be altered [ 49,71]. This means
edits may introduce, remove, or change the feature mapping or
presence condition of code fragments. For example, it might be
necessarytoaddnewcodetoafeaturetoextendit,ortoremove
parts of a feature mappingâ€™s formula when the formula was wrong.
2Variationtreesmaystilldescribeillegalvariantswithrespecttotheannotatedlan-
guage. For example, annotated code in Listing 1 could be syntactically incorrect, yield-
inginvalidCprogramsforsomeconfigurations.Whilecorrectnessmaybeobtainedby
making annotations aware of the annotated language (e.g., regarding syntax- [ 39,41]
ortype-correctness [ 38,40,47]), the variability specified by variation treesis sound.
199Classifying Edits to Variabilityin Source Code ESEC/FSE â€™22, November14Å›18, 2022,Singapore, Singapore
r1
#if FEAT_GUI5
#else66
#if MSWIN1111
win32_set_foreground();10
#if MSWIN âˆ§(Â¬FEAT_GUI âˆ¨VIMDLL)
22
if (gui.in_use) 33
{ 44
gui_mch_set_foreground(); 77
return;
Figure 2:Variationdiff ofedits madein Listing 2 .
Listing2 showschangesthatweremadetoVimâ€™scodein List-
ing 1in commit afde13b. The edit is displayed in the universal
diffformat,knownfromversioncontrolsystems:Addedlinesare
markedgreenandprecededby +;removedlinesaremarkedorange
andprecededby -.In thisedit,sourcecode wasinserted(lines3,
7, and 8), annotationsgotdeleted (lines 5, 6, and 12), and replaced
(lines 9 and 10). While the existing Line 11 remains untouched,
its annotation was replaced. In particular, Line 11 had the pres-
ence condition Â¬FEAT_GUI âˆ§MSWINbefore the edit but is assigned
MSWINâˆ§ (Â¬FEAT_GUI âˆ¨VIMDLL)afterwards. The set of variants in-
cluding Line 11 thus grows as FEAT_GUI does not necessarily have
tobedeselectedforLine11tobeincludedinavariantanymore. In
this section, we propose a formalism for representing such edits to
variability which we use in Section 4 to classify edits to variability.
3.1 Formalizationas VariationDiffs
Toclassifychangestovariabilityinsourcecode,wemayinspect
changestosourcecodeanditsfeaturemappings,asexplainedin
Section 2 . To inspect changes, we need a model that captures (1)
whichelements were edited, (2) howelements were edited, and (3)
how the variability of each element changed. While universal diffs,
asshownin Listing2,arewidelyadoptedforexpressing whichand
howelements got edited,they do not reflect changesto variability
well. In particular, to classify edits to variability, developers and
toolshavetoknowhowfeaturemappingsaswellasentirepresence
conditions changed.
Basedonourvariationtrees,wethuspropose variationdiffs asa
modeltodescribeeditstofeaturemappings.Analogoustouniversal
diffs, which describe which lines of text were inserted or removed,
variationdiffsdescribewhichnodesgotaddedtoorremovedfroma
variationtree.Thus,avariationdiffdescribesexactlytwovariation
treesatonce,onebeingvalidbeforetheeditandonebeingvalid
aftertheedit.Thekeyideaofvariationdiffsistomodeleditstothe
hierarchy of feature mappings agnostic of the actual underlying
implementationartifacts.
As an example, Figure 2 shows the variation diff of the edit
fromListing2.Thevariationdiffrepresentstheeditsmadetothe
variationtreeshownin Figure1correspondingtotheeditedsource
codefrom Listing1.Analogousasforvariationtrees,wecollapse
continuouslinesofsourcecodewiththesametypeofchangeintoa
singleartifact node(e.g.,lines7and8).Greennodesareinserted
into the variation tree, orange nodes with a dashed border are
removed, and gray nodes remain unchanged. Orange edges are
present before the edit, and green edges exist after the edit. Forexample, Line 11 (on the right in Figure 2) is nested below the
annotations at lines 6 and 5 before the edit but is placed within the
newannotation at Line10 after the edit.
As variation diffsdescribe edits to variationtrees, we formalize
variation diffs as an extension (i.e., a generalization) of variation
trees to graphs inwhichnodes andedges mayalsobe edited:
Definition 3.1 (Variation Diffs). A variation diff is a rooted di-
rected connected acyclic graph ğ·=(ğ‘‰,ğ¸,ğ‘Ÿ,ğœ,ğ‘™, Î”)with nodes ğ‘‰,
edgesğ¸âŠ†ğ‘‰Ã—ğ‘‰, root node ğ‘Ÿâˆˆğ‘‰, node types ğœ, node labels ğ‘™, and
a function Î”:ğ‘‰âˆªğ¸â†’ {+,â€“,â€¢}that defines if a node or edge was
added+, removed â€“, or unchanged â€¢, such that project(ğ·,ğ‘¡)is a
variation tree for alltimes ğ‘¡âˆˆ {b,a}.
We refer to the variation trees before and after the edit induced
by a variation diff as the projections of the variation diff. To reason
aboutprojections, we usethe time values b(before) and a(after).
Wemayobtaintheprojectionofavariationdiff (ğ‘‰,ğ¸,ğ‘Ÿ,ğœ,ğ‘™, Î”)at
timeğ‘¡âˆˆ {b,a}byincludingonlythosenodesandedgesthatexist
at timeğ‘¡:
project((ğ‘‰,ğ¸,ğ‘Ÿ,ğœ,ğ‘™, Î”),ğ‘¡)â‰”({ğ‘£âˆˆğ‘‰|exists(ğ‘¡,Î”(ğ‘£))},
{ğ‘’âˆˆğ¸|exists(ğ‘¡,Î”(ğ‘’))},
ğ‘Ÿ,ğœ,ğ‘™).
A node or edge exists before ( b) the edit if it was not added, and
existsafter( a)theeditifitwasnotremoved.Formally,anodeor
edgeğ‘¥âˆˆğ‘‰âˆªğ¸withdiff type ğ‘‘=Î”(ğ‘¥)exists at time ğ‘¡âˆˆ {b,a}if:
exists(ğ‘¡,ğ‘‘)â‰”(ğ‘¡=bâˆ§ğ‘‘â‰ +) âˆ¨ (ğ‘¡=aâˆ§ğ‘‘â‰ â€“).
We can obtain the feature mapping and presence condition of a
node in avariation diffbefore or after the editfrom the respective
projection.Foravariationdiff ğ·,werefertothefeaturemapping
F(ğ‘›)of a node ğ‘›in the projection project(ğ·,ğ‘¡)at timeğ‘¡âˆˆ {b,a}
asFğ‘¡(ğ‘›). Analogously, we abbreviate the presence condition of the
nodeğ‘›inthe respective projection as PCğ‘¡(ğ‘›).
Anexampleforaprojectioncanbefoundin Figure1whichis
theprojectionofthevariationdifffrom Figure2beforetheedit(i.e.,
Figure 1=project(Figure 2,b)).Thevariationtreecontainsexactly
theunchanged( â€¢)andremoved( â€“)nodesandedgesfromthediff.
Inserted( +) nodes andedges are only present after the edit.
3.2 CompletenessandSoundness
We prove that variation diffs are complete and sound with respect
to possible editsto variation trees.
Completeness. Weprovethatvariationdiffsare complete,mean-
ingthattheycandescribeanyedittoanyvariationtree.Everyedit
toavariationtreetransformsitfromanoldstatetoanewstate.By
considering the old state to be removed entirely, and the new state
to be inserted, any edit can be expressed solely using insertions
and deletions. Variation diffs allow to mark any subset of nodes
andedgestobeaddedorremovedvia Î”.Naively,wecandifftwo
variation trees by defining Î”(ğ‘œ)=â€“for all nodes and edges ğ‘œof
the old variation tree and Î”(ğ‘›)=+for all nodes and edges ğ‘›of
the new variation tree. Therefore, variation diffs are complete with
respecttovariationtrees.Formally,wealsohavetoprovethatwhen
buildingavariationdiffthisway,theprojectionsofthevariation
diff yield exactly the original two variation trees. This proof is part
ofour appendix inour replication package.1
200ESEC/FSE â€™22, November14Å›18, 2022,Singapore, Singapore P. M. Bittner, C.Tinnes, A.SchultheiÃŸ, S.Viegener, T. Kehrer, T. ThÃ¼m
Soundness. Variation diffs are soundby construction, meaning
thatanyvariationdiffdescribesanactualedittoavariationtree.By
definition,wecanobtainbothprojectionsfromavariationdiffto
ensure that the diff holds enough information to actually represent
alldifferencesbetweentwovariationtrees.Thus,anyvariationdiff
describes an editto avariation tree.
Conclusion. We proposed variation diffs as a complete and
sound model for edits to variability of implementation artifacts.
Whilevariationtreesmodelnestinghierarchiesemployedbydevel-
opersortoolstostructurefeaturemappings,variationdiffsidentify
changes to individual feature mappings within the nesting hier-
archies. To this end, variation diffs do not only cover changes to
source code but also to feature mappings. In thefollowing, we use
variation diffsto classifyedits.
4 CLASSIFYINGEDITS TO VARIABILITY
Our main goal is to classify every edit to variability in source code.
Withvariationdiffsasacompletemodel,classifyingeditstovari-
abilityreducestoinspectingpossiblestructuresinvariationdiffs.
The key observation is that we can classify the edit made to the
variability of an artifact, by inspecting its diff type Î”and the lo-
cation of its corresponding node in the variation diff. Hence, edits
made to an artifact can be described locally. To classify edits, we
proposenineeditclassesthatinspectthevariationdifflocally,from
theperspectiveofan artifact node.Weprovethatourclassesare
complete (i.e., every node is in at least one class) and unambiguous
(i.e.,every node isinat mostone class).
Avariationdiffmaydescribechangestomanyartifactssimul-
taneously,suchasin Figure2.Acompositionofinstancesofedit
classesinturn,mayemergeintoamoremeaningfulchange,that
we refer to as composite edit. We show that our class definitions
areindeedbasicbuildingblockstodescribemorecomplexchanges.
Key to our classification is its customizability. While we pro-
pose a catalog of classes based on use cases from variation control-
systems[ 90],managed clone-and-own [ 10], and variability-aware
mutationtesting[ 2],otherclassificationsmightsuitotherusecases.
We show that our classification scheme easily allows to define
alternative classifications that remain complete and unambiguous.
4.1 CatalogofEditClasses
Our definition of edit classes is inspired by the edit patterns by
StÄƒnciulescu et al . [90]that are designed to reflect relevant edits
for variation control systems [ 59]. Their patterns are regular ex-
pressions over C preprocessor annotated code, which we found to
be incomplete (i.e., some edits cannot be classified) and ambiguous
(i.e.,someeditsmatchmore thanone pattern).
Wedescribeeachclassasapropositionalpredicateon artifact
nodes within a variation diff. The formalization as propositional
predicates has the benefits that (1) it is easily reproducible (e.g., no
sophisticatedgraph matchingisrequired),(2)satisfiabilitysolvers
areveryeffectivereasoningenginesandpartofmanyanalysistools
already, and (3) completeness and unambiguitycan be ensured by
construction.Notethattheclassesonlyclassify artifact nodesas
theserepresentactualimplementationartifactsofwhichwewant
to observe howtheirvariability has changed.We distinguish edit classes for added,removed, andunchanged
artifacts.Whileanartifactitselfmightbeunchanged,itsvariabil-
ity might have changed, described by its ancestors in the corre-
sponding variation diff. For further use, we define three predi-
catesadded(ğ‘£)â‰”(Î”(ğ‘£)=+),removed(ğ‘£)â‰”(Î”(ğ‘£)=â€“), and
unchanged (ğ‘£)â‰”(Î”(ğ‘£)=â€¢)that each evaluate to trueif a given
nodeğ‘£has the corresponding diff type.
We present the formal definition of each edit class, as well as
an example edit to preprocessor-based source code and a sketch of
itscorrespondingvariationdiffin Table1.Theshowntext-based
diff and variation diff serve as examples and are not part of a classâ€™
definition.In the following, we discuss eachclass.
AddWithMapping and AddToPC. Our first two classes cover
theinsertionofsourcecode.Dependingonwhetherthecodewas
insertedwithorwithoutanewfeaturemapping,weidentifythe
edit as an instance of the AddWithMapping orAddToPC class re-
spectively. Distinguishing insertion with orwithout a new feature
mappingisrelevantforvariationcontrolsystemsinwhichanewly
introducedfeaturemappingisusedtointegratetheeditedsource
code into an internal representation of the code base [ 28,90].Add-
WithMapping classifiesan artifact nodeğ‘thatwasinsertedto-
gether with a new mapping nodeğ‘€a(ğ‘), where the function ğ‘€ğ‘¡(ğ‘)
returns the node that defines the feature mapping of an artifact
nodeğ‘at timeğ‘¡(i.e.,ğ‘€ğ‘¡(ğ‘)â‰”ğ‘€ğ‘¡(ğ‘ğ‘¡(ğ‘))iffğœ(ğ‘)=artifact and
otherwise ğ‘€ğ‘¡(ğ‘)â‰”ğ‘).Wehavetouse ğ‘€ğ‘¡becauseartifact nodes
may benestedbelow artifact nodesandthusjustinspecting par-
ent nodes is insufficient. In conditional compilation, AddWithMap-
pingcorresponds to inserting code with preprocessor annotations.
ForAddToPC , inserted code is not associated with a new feature
mapping but isplacedbelowan already existing mapping ğ‘€a(ğ‘).
RemWithMapping and RemFromPC. Our classes for dele-
tionsofsourcecodearedualtoourclassesforaddition:Forremoved
code, we also distinguish whether thecodeâ€™s feature mapping was
removed or not. Dual to AddWithMapping , the class RemWithMap-
pingcontainsremoved artifact nodesğ‘whosefeaturemapping
ğ‘€b(ğ‘)wasalsoremoved.Dualto AddToPC,theclass RemFromPC
containsplaindeletionsofsourcecodewithoutmodificationtoa
nodeâ€™sfeature mapping.
GeneralizationandSpecialization. Forunchangedcode,we
investigate if and how its variability changed. In particular, un-
changed code has a presence condition PCbbefore the edit and
apresencecondition PCaaftertheedit.Dependingonhowthese
presence conditions relate, the set of variants of the source code
might have changed in different ways. For example, Node 11in
Figure 2is unchanged but its presence condition changed from
Â¬FEAT_GUI âˆ§MSWINtoMSWINâˆ§(Â¬FEAT_GUI âˆ¨VIMDLL).Thus,the
set ofvariants of Node 11grew because FEAT_GUI does not neces-
sarilyhavetobedeselectedanymore.Werefertosuchanedit,as
aGeneralization .Formally,thesetofvariantsofthenode ğ‘grows
iff its set of variants before the edit is a subset of the variants after
theeditandnotviceversa.Thesetofvariantsof ğ‘beforetheedit
is a subset of the variants after the edit if and only if PCb(ğ‘) â‡’
PCa(ğ‘)is a tautology, which we write as PCb(ğ‘) |=PCa(ğ‘). We
can check whether this formula is a tautology with a SAT solver
viaÂ¬SAT(Â¬(PCb(ğ‘) â‡’PCa(ğ‘))).The intuitionbehind requiring
a tautology is that ğ‘should remain in allvariants it was previously
included in. When instead, the set of variants of an unchanged
201Classifying Edits to Variabilityin Source Code ESEC/FSE â€™22, November14Å›18, 2022,Singapore, Singapore
Table 1:Editclassification.
EditClassDefinition Example Diff Example Var. Diff EditClassDefinition Example Diff Example Var. Diff EditClassDefinition Example Diff Example Var. Diff
AddWithMapping (ğ‘)â‰”
added(ğ‘) âˆ§added(ğ‘€a(ğ‘))+#ifğ‘š
+c
+#endif#ifğ‘š
cAddToPC(ğ‘)â‰”
added(ğ‘) âˆ§Â¬added(ğ‘€a(ğ‘))#ifğ‘š
+c
#endif#ifğ‘š
cSpecialization (ğ‘)â‰”unchanged (ğ‘)
âˆ§Â¬(PCb(ğ‘) |=PCa(ğ‘))
âˆ§ (PCa(ğ‘) |=PCb(ğ‘))+#ifğ‘š
c
+#endifr
c#ifğ‘š
RemWithMapping (ğ‘)â‰”
removed(ğ‘) âˆ§removed(ğ‘€b(ğ‘))-#ifğ‘š
-c
-#endifIFm#ifğ‘š
cRemFromPC (ğ‘)â‰”
removed(ğ‘) âˆ§Â¬removed(ğ‘€b(ğ‘))#ifğ‘š
-c
#endif#ifğ‘š
cGeneralization (ğ‘)â‰”unchanged (ğ‘)
âˆ§ (PCb(ğ‘) |=PCa(ğ‘))
âˆ§Â¬(PCa(ğ‘) |=PCb(ğ‘))-#ifğ‘š
c
-#endifr
c#ifğ‘š
Reconfiguration (ğ‘)â‰”unchanged (ğ‘)
âˆ§Â¬(PCb(ğ‘) |=PCa(ğ‘))
âˆ§Â¬(PCa(ğ‘) |=PCb(ğ‘))-#ifğ‘š
+#ifğ‘šâ€²
c
#endifr
c#ifğ‘šâ€²#ifğ‘šRefactoring (ğ‘)â‰”unchanged (ğ‘)
âˆ§(PCb(ğ‘) |=PCa(ğ‘))
âˆ§(PCa(ğ‘) |=PCb(ğ‘))
âˆ§(ğ‘ğ‘ğ‘¡â„b(ğ‘)â‰ ğ‘ğ‘ğ‘¡â„a(ğ‘))-#if A || (B && !A)
+#if A || B
c
#endifr
c#ifğ‘š#ifğ‘šUntouched (ğ‘)â‰”unchanged (ğ‘)
âˆ§(PCb(ğ‘) |=PCa(ğ‘))
âˆ§(PCa(ğ‘) |=PCb(ğ‘))
âˆ§(ğ‘ğ‘ğ‘¡â„b(ğ‘)=ğ‘ğ‘ğ‘¡â„a(ğ‘))r
c
artifact nodeğ‘shrinks, we refer to the change as a Specializa-
tion.ASpecialization occurs,whenthepresenceconditionbecomes
more restrictive. A simple example in conditional compilation is
the insertion of a non-superfluous3directive whose condition ğ‘š
hastobesatisfiedforthecode ğ‘tobeincluded.Inthevariationdiff,
thisexamplecorrespondstotheinsertionofanew mappingnode
somewhere above the artifact nodeğ‘.
Reconfiguration. Incasethesetofvariantsisinnosubsetrela-
tion,wespeakofa Reconfiguration ,asthesetofvariantschangedin
anarbitraryway.Thishappensforexample,whenanon-superfluous
conditionisreplacedbyadifferentnon-superfluouscondition,or
when different directives are added or removed simultaneously,
such thatthesetof variantsafter theeditisneitherasubsetnor a
superset ofthe previous setofvariants.
Refactoring. Besides,thesetofvariantsmightnothavechanged
atall.Inthis case,thepresence conditionsmighthavebeenrefac-
tored (e.g., an annotation ğ´âˆ¨ (ğµâˆ§Â¬ğ´)was simplified to ğ´âˆ¨ğµ) or
notchangedatall.Incasethepresenceconditionwasrefactored,it
remained semantically equivalent but its ancestors in the variation
diffhavechanged.Iftheancestorschanged,thepaths ğ‘ğ‘ğ‘¡â„b(ğ‘)and
ğ‘ğ‘ğ‘¡â„a(ğ‘)from a node ğ‘to the root before and after the edit are
different, where ğ‘ğ‘ğ‘¡â„ğ‘¡(ğ‘)describes the path from the node ğ‘to the
root of the variation diff at time ğ‘¡âˆˆ {b,a}(i.e.,ğ‘ğ‘ğ‘¡â„ğ‘¡(ğ‘)=ğ‘iffğ‘is
the root, and ğ‘ğ‘ğ‘¡â„ğ‘¡(ğ‘)=(ğ‘,ğ‘ğ‘ğ‘¡â„ğ‘¡(ğ‘ğ‘¡(ğ‘)))otherwise).
Untouched. The variability of a piece of source code might
neither be changed semantically nor syntactically. This means, the
presenceconditionremainedequivalentregarding â‡’andthepaths
before and after the edit from a node to the root did not change
(e.g.,Line1in Listing2 isUntouched ).Whilenoeditoccurredfor
anartifact inthis case,we include Untouched to be complete.
4.2 CompletenessandUnambiguity
Our edit classes are complete (i.e., every artifact node is in at
least one class) and unambiguous (i.e., every artifact node is
in at most one class). Our classes are unambiguous as they are
3A superfluous condition does not influence the variability [ 4,93], such as #if true .mutually exclusive, and they are complete as at least one predicate
evaluates to truefor eachpossibleevaluation (i.e.,thedisjunction
of the predicates is a tautology). We prove the completeness and
unambiguityofour classesinour appendix.1
Giventhatourclassesarecompleteonvariationdiffsandthat
variationdiffsarecompletewithrespecttopossibleeditstovari-
ation trees (cf. Section 3.2 ), we conclude that our classes are a
completeclassification of edits to variationtrees. In Section 2.3 , we
discussed our design decision for variation trees to be as complete
as possible in representing variability, in particular of source code.
Thus, assuming that variation trees are complete, our classes are a
completeclassificationofeditstovariabilityinsourcecode.Further,
whenevera class occurs inavariation diff, that occurrenceindeed
classifies an edit to variability because variation diffs and variation
trees are sound.
4.3 DefiningOtherClassifications
A key benefit of classifying edits via predicates over artifact
nodes in variation diffs is that we can build other classifications,
while proving completeness and unambiguity requires only minor
adaptions to existing proofs. We constructed our catalog of classes
basedonusecasesinsomevariationalsystems[ 2,10,90],butother
classifications maybe requiredto serve otheruse cases.
In particular, classifying edits based on predicates, gives rise to
infinitelymanypossibleclassifications,eachbasedonanotherset
of predicates. We can always split a class, defined by a predicate
ğœ“(ğ‘),intotwonewclasses ğœ“1(ğ‘)â‰”ğœ“(ğ‘)âˆ§ğœ‘(ğ‘)andğœ“2(ğ‘)â‰”ğœ“(ğ‘)âˆ§
Â¬ğœ‘(ğ‘)byaddinganewclause ğœ‘thatdistinguishesafurthercase.
Such a predicate ğœ‘always exists, because there are infinitely many
variation diffs and each predicate may inspect another property of
the diff. As an example, we could split the Refactoring class to also
inspectwhetherthetwopresenceconditionsaresyntacticallyequal
to see whether only the presence conditionâ€™s distribution across
feature mappings waschangedorif the formula wasaltered.
In our appendix, we first describe a proof scheme for proving
the completeness or unambiguity of any given classification that is
202ESEC/FSE â€™22, November14Å›18, 2022,Singapore, Singapore P. M. Bittner, C.Tinnes, A.SchultheiÃŸ, S.Viegener, T. Kehrer, T. ThÃ¼m
basedonasetofpredicates.Wethenapplytheseschemestoour
catalog of edit classes to prove it to be complete and unambiguous.
Thus,for anewclassification,the schemescanbe reusedtoprove
the respective properties, while the proofsfor our catalog serve as
examplesonhowto apply the schemes.
4.4 Discussion
Whileourclassesareunambiguousfor artifact nodesinvariation
diffs,diffsingeneralareambiguousastheycanbeconstructedin
multipleways.Forexample,itmighthavebeenmoreintuitiveto
showtheremovedlines5and6aftertheinsertionoflines9and10
to group related changes in Listing 2. We identified two sources of
ambiguity: propositional formulas andthe specification ofdiffs.
Ambiguityin Feature Mappings. Aconjunction ğ´âˆ§ğµoftwo
featuremappingscanbestoredinasingle mapping nodewithlabel
ğ´âˆ§ğµor in two nested nodes labeled with ğ´andğµ, respectively.
This ambiguityis subject tothe developerâ€™schoice. Forexample, in
conditionalcompilationdevelopers are free to annotate a piece of
code with #if defined(A) && defined(B) or with two nested
annotations #ifdef A and#ifdef B .Yet,thisambiguityisnota
limitationbutakeyquality ofvariation diffs. In fact,we designed
variation diffs to reflect hierarchies of annotations to retain the
ontologicalinformationgivenbydeveloperstobetterunderstand
howvariability isdescribedinpractice.
AmbiguityinDiffing. While variationdiffs are complete and
sound regarding variation trees, they remain ambiguous. For ex-
ample, as discussed in Section 3.2 , one could describe an edit to
a variation tree as a variation diff in which all nodes and edges
of the old tree are removed and all new nodes and edges are in-
serted. Such a description of an edit is rarely useful though, and so
nodesand edges beingpresentbeforeand aftertheeditshould be
consideredunchanged.However,detectingwhetheranodeisun-
changedisnotunambiguouslydetermined(e.g.,whenlinesofcode
aremoved).Infact,ambiguityinexpressingeditstoimplementation
artifacts is a limitation of any differencing technique in general,
sometimes requiring advanced matching heuristics [ 25,44,74]. We
thussharethislimitationwithexistingresearchondifferencingand
edit classification. Yet, we can control this ambiguity by employing
a deterministic diffing technique, that yields the same variation
diff for the same two input revisions of a source code file. We have
implemented a deterministic parser for constructing variation diffs
from aunixdiff for our validation in Section 5.
4.5 Composite Edits
Althoughourclassificationiscomplete,variabilityinsourcecode
mightwitnessmorecomplexchanges.Forinstance,StÄƒnciulescu
et al.[90]observed that when adding code with a feature mapping,
developers sometimes simultaneously add code to variants not
including the feature with an #elsebranch (called AddIfdefElse ).
While such an edit is classified by our catalog as a simultaneous
application of two AddWithMapping edits, this classification loses
theirconnectioninthegraphstructure.Inparticular,earlierstudies
observe or investigate different kinds of complex patternsto in-
crease the accuracy when evaluating research [ 2,10,90]. However,
existing studies face overlaps (i.e., an edit might be matched by
more thanone pattern)leadingto ambiguity.Variation diffs enable us to systematically derive complex pat-
terns by interpreting them as a composition of class definitions.
Wethusrefertosuchcomplexpatternsas composite editpatterns.
Whilecompositepatternsmightoverlap,theoverlapisexplicitly
accountedfor bytheircomposition of classesthat do not overlap.
As our classes are complete, unambiguous, and fine-grained,
we argue that they indeed serve as a set of building blocks for
complexpatterns.Inour appendix,weshowthatall editpatterns
reported in previous studies [ 2,90] are either a composite edit
patternorequivalenttooneofourclasses.1Acatalogofcomposite
editpatterns can be useful but isoutof scope of this paper.
5 VALIDATION
In thissection, we validatethat ourtheoreticalresults can betrans-
ferred to practice. Therefore, we classify the edits made in the
development histories of 44 real-world software product lines. Our
theory is based on the assumptions that (1) variation trees are
complete andsound (cf. Section 2.3 ), and(2) feature mappings are
syntactically correct. To determine whether these assumptions are
valid in practice, we validate the completeness of variation diffs,
byverifyingthateverypatchwithsyntacticallycorrectmappings
can be parsed to a variation diff, and by inspecting how often map-
pings are syntactically correct (RG1). We validate the proofs for
completenessandunambiguityofourclassification,byverifying
thateacheditedlineofsourcecodeisinexactlyoneeditclass(RG2).
Moreover,weinspecttherelevanceofeachclassbyobservingits
occurrenceinpractice(RG3).Finally,wevalidatethatourclassifi-
cation can be automated andscales such that variation diffs could
be parsed and our classes could be detected by future variability
managementtools(RG4). In summary,our research goalsare:
RG1Validatethecompletenessofvariationdiffsasarepresenta-
tionfor editsto variability insourcecode.
RG2Validate that our edit classes are complete and unambiguous.
RG3Validatethatoureditclassesarerelevant(i.e.,allclassesoccur
inpractice).
RG4Validatethat editclassification canbeautomated andscales.
5.1 Subject Systems
For our validation, we analyze 44 open-source software product
lines from different domains. We include all 40 software product
lines whose variability was analyzed by Liebig et al . [56]regard-
ingtheircomplexity,granularityandtypesofextensionsapplied
by preprocessor directives. Fortunately, all systems are still pub-
licly available, and we provide updated links in our replication
package. While these 40 systems already cover a wide spectrum
of domains Å› including but not limited to webservers, operating
systems, database systems, antivirus, media players, and editors
Å› we decided to also include four other systems to further in-
creaseexternalvalidity:Busybox,acollectionoftoolsforembedded
systems that is widely studied in research on configurable soft-
ware [20,31,35,43,46,58,79,83]; Marlin, a 3D printer firmware
from which edit patterns were retrieved semi-automatically by
StÄƒnciulescu et al . [90](cf.Section 6 ); libssh, an SSH library also
studiedinthecontextofconfigurablesystems[ 67];andthegame
engine Godot as a new domain. In Table 2, we present an overview
of the four subject systems with the longest revision history as
203Classifying Edits to Variabilityin Source Code ESEC/FSE â€™22, November14Å›18, 2022,Singapore, Singapore
Table 2:Overview andresults ofthefour largest andfour new subjectsystemsofthe 44analyzed systems.
Name Domain
#total
commits#processedcommits#diffs#artifactnodesAddToPC AddWithMapping RemFromPC RemWithMapping Specialization Generalization Reconfiguration Refactoring runtimeavg. run-timeperprocessedcommitmedian
runtimeperprocessedcommit
linux operating system 1,072,601 870,429 1,875,864 12,483,635 51.5% 0.9% 45.8% 0.9% 0.2% 0.3% 0.2% 0.1% 10,829.9s 12.2ms 6ms
freebsd operating system 272,207 179,753 729,831 9,747,920 49.4% 2.7% 43.2% 2.3% 0.7% 0.8% 0.6% 0.3% 5,418.2s 29.6ms 5ms
gcc compiler framework 191,405 122,777 416,750 3,040,492 50.1% 1.6% 45.9% 1.3% 0.4% 0.4% 0.3% 0.1% 6,023.5s 47.4ms 21ms
emacs text editor 154,155 37,943 71,321 571,109 47.6% 3.3% 43.5% 2.7% 1.0% 1.0% 0.5% 0.5% 1,349.1s 33.0ms 14ms
...36other systems...
godot gameengine 40,944 18,867 107,845 1,267,555 48.4% 3.3% 42.7% 3.0% 0.5% 0.4% 1.4% 0.3% 2,687.2s 141.8ms 7ms
marlin 3dprinting 19,260 14,607 84,332 567,164 38.0% 12.2% 35.0% 8.7% 0.6% 1.6% 2.9% 1.0% 549.0s 37.4ms 10ms
busybox embeddedsystems 17,447 14,485 41,146 393,324 45.8% 3.7% 43.4% 3.6% 1.0% 0.7% 1.2% 0.5% 244.8s 16.8ms 6ms
libssh network 5,352 4,439 8,465 56,440 52.0% 2.5% 41.9% 1.7% 1.1% 0.4% 0.2% 0.2% 21.3s 4.8ms 3ms
total Å› 2,594,912 1,708,111 4,900,820 45,413,708 49.8% 2.1% 44.7% 1.7% 0.5% 0.5% 0.4% 0.2% 37,558.1s 21.5ms 7ms
well as the four new subject systems (we omit the remaining 36
systems for brevity). The full results for all systems are part of our
appendix.1Notably,weanalyzetheentirerevisionhistoryofthe
Linux kernel which to the best of our knowledge has the largest
history in the domain of configurable systems with more than one
millioncommits.Allsubjectsystemsaremanagedwiththeversion
controlsystemgit.
5.2 Experiment Setup
Topursueourresearchgoals,webuilt DiffDetective ,4alibrary
and command-line tool to retrieve variation diffs from git histories
ofpreprocessor -basedproductlines.Eachcommitinagitrepository
consists of a set of patches, where each patch comprises all edits
made to exactly one file, as shown in Listing 2.DiffDetective
extractsallpatchesthatarevalidforourvalidation.Apatchisvalid
if it modified a source code file ( .c,.cpp,.h, or.hpp) with at least
one non-whitespace change, and stems from a non-merge commit
because merge commits do not have a single parent. Each valid
patchisthen parsedtoavariationdiff. We thereforeconvertlocal
patchestofullpatches(i.e.,weusetheentirefileascontextandnot
justthechangedfractionasshownin Listing2),toaccountforanno-
tationsthatsurroundedits.TopursueRG1, DiffDetective reports
thecausewheneverapatchcannotbeparsed.Inthe"#processed
commits" column of Table 2, we show how many commits contain
atleastonevalidpatchthatcouldbeparsed,about1.7millionin
total.Ineachparsedvariationdiff,wethenremoveallnon-edited
subtreesasthesesubtreesdonotrepresentedits. DiffDetective
then determines the edit class of each artifact node of each vari-
ationdifftovalidatethateverynodeisinexactlyoneclass(RG2)
and counts their occurrences (RG3). For RG4, we measure the time
ittakes to processeachcommit andrepository.
DiffDetective uses the FeatureIDE library [ 48] to reason on
propositional formulas paired with the Sat4j SAT solver [ 55] to
classify edits. We implemented the Tseytin transformation [ 52,97]
for larger SAT queries. To interact with git, we use the JGit library.
DiffDetective â€™s parser forpatches tovariation diffsisexplained
inabachelorâ€™sthesis[ 98].
We perform our validation on an Ubuntu 20.04.3 LTS system
with64-bitarchitectureandanIntel Â®XeonÂ®CPUE5-260v3with
2.40Ghzclockrate.Thesystemhas32threadsthatweusetoprocess
4GitHub:https://github.com/VariantSync/DiffDetective/tree/esecfse22
DOI:10.5281/zenodo.7110095parts of each history in parallel but a single commit is always
processedinasinglethread.Toreducetheimpactofotherprocesses,
the machine wasnot inuse for othertasksinparallel.
5.3 Results andDiscussion
Wesummarizeourresultsin Table2.Intotal,weprocessedabout
1.7 millioncommits containing about4.9 million variation diffs in
about10.4hwith a speed of 21.5msper commit on average and
7msas median. Because of multithreading, we had an effective
runtimeofabout 70minyieldinganeffectiveaverageruntimeof
about2.4msper commit. We classified about 45 million edits to
source code (i.e., artifact nodes in variation diffs). For each edit
class, we listits relative share of the artifact nodes.
RG1: Variation Diff Validity. Whenever DiffDetective can-
not parse a patch to a variation diff, it reports an error and its
reason. We found the only reported errors to be syntax errors in
preprocessor annotations. In particular, we found 4,393 patches
in which an #endifwas missing, 1,336 patches with conditional
directives without an expression, 2,732 patches with an #endif
without an #if, 483 patches with an #elseor#elifwithout a
corresponding #if, 62 patches with an #elsefollowing another
#else,and7patcheswithsyntax errorsinthe definitionof multi-
line macros. In total, 0.18% of all patches were syntactically invalid.
Uponamanualinvestigationofsomeofthesefailures,wefound
thatthepreprocessordirectiveswereindeedinvalidandwereoften
fixed in the following commit. Thus,we find that we canparse all
syntax-correctpatchesto variation diffs.
RG2:ValidityofEditClasses. DiffDetective determinesthe
edit class for each line of code in the parsed variation diffs. In case,
anartifact node is an instance of no or more than one class,
DiffDetective crashes by design and reports that node. Yet, no
crash occurred for any of the 44 input repositories, thus validating
our proofs for completeness and unambiguity in Section 4.2 and
the correctness ofour implementation.
RG3: Relevance of Edit Classes. We report the occurrence
counts for each class in Table 2. We omit Untouched as it never
occurred. This is (1) expected because we removed non-edited sub-
trees from all variation diffs, and (2) desired because we aim to
inspect edits to variability and Untouched describes an artifact that
experiencesnochanges. AddToPC andRemFromPC arebyfarthe
most frequent edit classes with 49.8% and 44.7% of edits, respec-
tively. Here, it is important that we collapse subsequent lines of
204ESEC/FSE â€™22, November14Å›18, 2022,Singapore, Singapore P. M. Bittner, C.Tinnes, A.SchultheiÃŸ, S.Viegener, T. Kehrer, T. ThÃ¼m
sourcecodewith thesamedifftypeto asingle artifact node(cf.
Section3.1 )toconsiderthelineeditsasasingleedit,ratherthan
oneeditperline.Inlinewithpreviousresearch[ 37,49,90],wethus
find that edits to source code are much more frequent than edits
toannotations.Theremainingeditclassesmakeupforonly5.5%
of the edits, which are still 2.5 million edits. Insertion and deletion
ofcodewithafeaturemapping( AddWithMapping andRemWith-
Mapping)are morefrequentthaneditstothefeature mappingsof
existing source code. Edits to the variability of existing code are
about equally distributed with Refactoring being the least common.
WhileaRefactoring istherarestedititstill occurs ~91K times. We
conclude that alleditclassesare relevantinpractice.
RG4: Automation and Scalability. DiffDetective runs fully
automaticallyandtookabout 10.4htoprocessallcommitsbutonly
70minin total because of multithreading. Classifying all edits in a
commitrequires 21.5msonaverageand 7msasmedian.Wefind
that99.89%ofcommitswereprocessedinlessthanasecond.All
remainingcommits,apartfromthreeoutliers,wereprocessedinless
than one minute. The three outliers stem from Godot and required
5, 6 and27min, respectively. The longest to process commit was
8c1731b. We found a single of its 65 patches to be responsible:
Thegeneratedfile tools/editor/doc_data_compressed.h with
about 100K lines of code experienced 127,704 changes according to
Github.Thesamefilewaseditedintheothertwocommits.Such
filescouldbeexcludedfromanalysesandwesupposealongprocess
time for huge changes to be reasonable. We thus conclude that
classifying editscan be automatedandscaleswell.
5.4 Threatsto Validity
OurtoolDiffDetective couldhavebugsthatimpactourresults.
Wetestedallcrucialfunctionalitywithunittestsandstructuredour
development alongissuesandmergerequests.Tovalidatethecor-
rectness of our variation diff parser, we performed manual testing
and implemented a consistency check that is performed on each
parseddiff. This checkreportednoinconsistencies.
Our approach to measure relevance by counting class occur-
rencescouldbeinsufficient.Yet,wefindthateachsystemwithat
least108processedcommitscontainsallofourclasses.Onlyinfive
systemssomeclassesareabsent,threeofwhichhadsmallhistories
(<total125commits)withoutany valid patches.
We parseconditions to booleanlogicalthoughalso non-boolean
formulas occur (cf. Section 2.3 ) which would require more sophisti-
catedreasoningenginesthanSATsolvers(e.g.,SMTsolvers),which
mayimpactourperformanceresults.Uponparsing,wereplacenon-
booleansub-expressionsbyuniquevariables,atechniqueknown
asbooleanabstraction ,employed inSMTsolving [ 9],andstate-of-
the-artwhen analyzing variability at alarge scale[ 32,42,58].
Ourparserdoesnotexpandmacroinvocationsandincludedi-
rectiveswhichmightimpairthesoundnessofourresults.Yet,so-
phisticatedvariability-awareparsingmaytakeseveralminutesand
uptomultiplehoursforasingleversion[ 32,42,66]andrequiresto
tree-differencetwoparsedversions,whichalsoisnotyetvariability-
aware (cf. Section 6). As in existing research [ 58], we thus abstract
macro invocationsas constantvalues (e.g., wetreat FOO(3, 4) as
a constant FOO_3_4). We found parsing Unix diffs to variation diffs
to be the besttrade-offbetween scalability andaccuracy.Oursubjectsystemsmaynotberepresentativefortheevolution
of variability in source code. In particular, all subjects are open-
sourceC/C++repositories.Toaddressthisthreat,wechosesystems
thatwere previouslystudied[ 56]and extendedthemby fournew
systems to cover a wide spectrum of about 30 different domains.
Moreover, ourvalidationfocusedonpreprocessor-basedvariability
bydesignwhichisinherently mostly usedinC/C++ software.
6 RELATED WORK
OurworkisinspiredbytheworkofStÄƒnciulescuetal .[90],who
empirically and semi-automatically extracted a set of edit patterns
from the history of two software product lines, to evaluate their
model of a variation control system. When inspecting the patterns,
wefoundthemtobe(1)ambiguousastheylackaformaldescription
or tooling, (2) incomplete because some patterns miss their inverse
operation, and (3) overlapping (i.e., an edit may belong to multiple
patterns). To address ambiguity and incompleteness, we refined
and extended their patterns with formal definitions in terms of
classes. To address the overlap, we distinguish between classes and
compositeeditpatterns.Moreover,weprovideopen-sourcetooling
toautomaticallyclassifyeditsandourvalidationcovers44systems
instead oftwo.
Complete and unambiguous classifications of edits to vari-
abilityareonlyavailableforthe problemspace sofar(e.g.,forfeature
modelsdefiningthesetofvalidconfigurations)butnotthesolution
space (i.e., source code and feature mappings). ThÃ¼m et al . [95]
introduce four groups of edits to feature models. Interestingly, our
classesSpecialization ,Generalization ,Reconfiguration , andRefac-
toringacting on source code correspond to these groups. This is
not surprising because feature models and feature mappings both
describe a set of valid configurations but for the entire product line
oracertainimplementationartifact ,respectively.Inspiredbythis
analogy,wedecidedtopartlyadoptthenamingschemeof ThÃ¼m
et al.for the above mentioned classes. BÃ¼rdek et al . [13]extend
the work by ThÃ¼m etal .with concreteeditoperations.Analogous
to our work, BÃ¼rdek et al .distinguish between elementary edits
andcomplex,compositeedits.Thus,theclassificationby BÃ¼rdek
etal.canbeseenasthecounterpartforfeaturemodelstoourwork
on source code. Patterns for refactorings and generalizations [ 3]
or specializations [ 17] tofeaturemodelsdo not classifyedits. The
complete and unambiguous classifications for edits to feature mod-
elsserveasinspirationforourworkbutcannotbeusedforeditsto
sourcecode andfeature mappings.
Automatic analyses of edits to source code do not facilitate
acompleteclassification.Withanautomaticanalysiswhetheredits
inLinuxaffectthefeaturemodel,featuremappings,orsourcecode,
KrÃ¶heretal .[49]inspectthatbutnothowvariabilityinformation
was edited. Dintzner et al . [21]present FEVER which parses the
historyofproductlinesautomatically.WhileFEVERretrievesex-
tensive data and metadata for co-evolution of variability, it does
notprovideaclassificationofedits.Basedontherefinementthe-
ory [11,27], safe-evolution templates [ 69,84] describe possible
scenarioshowfeaturemodel,featuremappings,andsourcecode
canbechangedwithoutalteringthesetofvalidproducts.Whilethe
refinement theorycanmodelanyedit tovariability,thedescribed
templates are incomplete by design because they target (partial)
205Classifying Edits to Variabilityin Source Code ESEC/FSE â€™22, November14Å›18, 2022,Singapore, Singapore
refactorings.Moreover,thereisnodistinctionbetweenfeaturemap-
pingsandpresenceconditions.Niekeetal .[71]extendthenotionof
refinements to guide the adaption of configurations upon complex
edit scenarios, such as feature merges. Nieke et al .identify three
exemplary (i.e., incomplete) evolution templates. Further analyses
oftheevolutionofproductlines[ 96]donotclassifyedits.Opposed
to the state of the art, we performed a large-scale validation by
classifying 45 million edits from 1.7 million commits in 44 systems.
Wecouldclassifyalleditsandprovedthatourclassesarecomplete.
Semi-automatic analyses of edits to source code do not
facilitateacompleteclassification.Withamanualanalysisof657
commits,Passosetal .[78]extractededitpatternsfromtheevolution
ofLinux,butremainincompleteastheyreporteditsthatdidnot
match any pattern. Seidl et al . [89]propose evolution operators
for model-based product lines that have to be employed manually
duringdevelopmentandmakenoargumentsoncompleteness.Due
to the fact that our analysis is fully automated, we could classify
farmore commits andsystemsfrom differentdomains.
Editspecificationsforotherpurposes thanaclassification
of edits are incomplete or ambiguous. To evaluate the benefits
of recording feature mappings, Ji et al . [37]provide an extensive
catalog including macroscopic edits such as cloning whole code
bases. Yet, their patterns are given in natural language and thus
matchingpatternscannotdirectlybeautomated.Whiledesignedfor
testing, the mutation operators by Al-Hajjaji et al .[2]exhibit some
similarity with our classes. Yet, the operators remain incomplete
(e.g.,AddWithMapping andtherebyatruesubsetofeditsismissing).
Further work on refactorings [ 26,57] presents proactive evolution
operators similar to Seidl et al . [89]but without classifying edits.
Potentially,our classescan alsobe usedfor the above purposes.
The choice calculus [23] is a formal language for variation
andcloselyrelated toourvariationtrees.Whilechoicesmodelal-
ternative variation (i.e., exactly one of a set of alternatives must
bechosen),variationtreesmodeloptionalvariation(i.e.,subtrees
can be in- or excluded). While choice calculus was applied in prac-
tice[8,90,100,101],itwasneverappliedtoevolutionandwefound
optional variation to model preprocessor-based variability more
naturally.Inthefuture,weaimtostudytherelationshipbetween
choicecalculus andvariation trees.
Differencing techniques describe changes to data, such as
source code in concrete [ 7,14,74] or abstract syntax [ 19,22,24,
29,30,33], but are unaware of variability. Our theory and our tool
DiffDetective makediffsvariability-awarebyparsingageneric
diff (e.g., Unix diffs) into a variation diff, which explicitly mod-
els edited variability. Thus, any diff tool may be used to obtain a
generic, intermediate diff in DiffDetective . Semantic differenc-
ing[6,54,64,72,73,75,76]reliesonoperationalsemantics(e.g.,con-
trolflow[ 6])ofsingle-variantsystemsandisoblivioustovariability.
Variability-awareparsing[ 32,42]forconditionalcompilationyields
a singleabstract syntax tree withvariability information butdoes
not consider edits. Medeiros et al . [65]semi-automatically apply
variability-aware parsing to the versions of eight systems across
~51K commits but do not inspect edits to variability. To inspect ed-
its,treediffingcould be employedbutisnotyetvariability-aware.
Moreover, whileMedeirosetal . [65]reportnotimingresults, itis
known[32,42]thatparsingasingleversionofLinuxtakesmorethan ten hours, while we extract all relevant information from a
singlecommit in 21.5msonaverage.
UseCases. Ourvariationtreesanddiffsserveasaunified,for-
mallanguagetoexpress, communicate,andreasonaboutvariabil-
ity and edits to it. Research and tools on evolution of variation
basedonourclassificationareguaranteedtobecompleteregard-
ing edits. For instance, our catalog increases the applicability of
variability-aware mutation testing [ 2] by completing their existing
setofmutationoperators.Forvariation-controlsystems[ 59,60,90]
andmanagedclone-and-own[ 45,63],whichinspectandoperate
primarily on edits, our classes can serve as a design reference
and evaluation dataset [ 10,90]. Methods for synchronizing vari-
ants[45,63,80,85,86]inmanagedclone-and-own[ 82]areguaran-
teed to be able to deal with any input edit from users, when based
on our complete variation diffs and classes. Moreover, software
developerscanobservetheeffectoftheireditsonvariabilityto,for
example,validatethataneditwasarefactoringorspecialization,
such thatno further testcaseshave tobeintroduced.As alibrary,
DiffDetective enables researchers and practitioners to study the
evolution of variability in source code by retrieving variation diffs
anddetecting editclassesautomatically.
7 CONCLUSION
We propose a classification of edits to variability in source code
thatweprovetobecomplete(i.e.,everyeditisclassifiedbyatleast
one class) and unambiguous (i.e., every edit is classified by at most
oneclass).Weintroducevariationtrees,aformalmodeltodescribe
variability in source code, and variation diffs, a formal model to
describechangestovariationtrees,whichweprovetobecomplete
andwhichissound byconstruction.
To validate the suitability and potential for automation of our
concepts andclassification,we classifiedabout45millioneditsto
sourcecodefullyautomatically.Ineffectively 70min,weprocessed
about 1.7 million commits from the histories of 44 open-source
softwaresystems.99.89%oftheconsideredcommitswereprocessed
in less than a second, making our method feasible in practical
scenarios, such as continuous integration. We found that 0.2% of
thepatchessubmittedbydeveloperscontainsyntacticallyincorrect
preprocessorannotations.Allother editswere classifiedand each
ofour editclassesoccurs inpractice.
Oureditclassescanbeusedtogaininsightsintotheevolutionof
configurablesoftwaresystemsandtheeffectsofeditsonvariabil-
ity. In the future, we plan to derive composite edit patterns from
frequent compositions of instances of our edit classes which serve
as buildingblocksto describe more complex changes.
ACKNOWLEDGMENTS
We thank our reviewers for their constructive feedback. We thank
BenjaminMoosherr,KevinJedelhauser,andTobiasHeÃŸfortheir
help with the experimental setup and artifact. We thank Chico
SundermannandJeffreyM.YoungforadviceonSATsolvingand
our proofs. We thank Alexander Boll and Sebastian Krieter for
proof-reading, and Sven Apel for helpful discussions. This work
hasbeenpartiallysupportedbytheGermanResearchFoundation
within the project VariantSync (TH 2387/1-1 andKE 2267/1-1).
206ESEC/FSE â€™22, November14Å›18, 2022,Singapore, Singapore P. M. Bittner, C.Tinnes, A.SchultheiÃŸ, S.Viegener, T. Kehrer, T. ThÃ¼m
REFERENCES
[1]Iago Abal, Jean Melo, Stefan StÄƒnciulescu, Claus Brabrand, MÃ¡rcio Ribeiro, and
AndrzejWÄ…sowski.2018. VariabilityBugsinHighlyConfigurableSystems:A
QualitativeAnalysis. TOSEM26,3,Article10(2018), 10:1Å›10:34pages.
[2]MustafaAl-Hajjaji,FabianBenduhn,ThomasThÃ¼m,ThomasLeich,andGunter
Saake. 2016. Mutation Operators for Preprocessor-Based Variability. In VaMoS.
ACM,81Å›88.
[3]Vander Alves, Rohit Gheyi, Tiago Massoni, UirÃ¡ Kulesza, Paulo Borba, and
Carlos JosÃ© Pereira de Lucena. 2006. Refactoring Product Lines. In GPCE. ACM,
201Å›210.
[4]Sven Apel, Don Batory, Christian KÃ¤stner, and Gunter Saake. 2013. Feature-
OrientedSoftwareProductLines . Springer.
[5]Sven Apel, Christian KÃ¤stner, and Christian Lengauer. 2013. Language-
Independent and Automated Software Composition: The FeatureHouse Ex-
perience. TSE39,1 (2013), 63Å›79.
[6]Taweesup Apiwattanapong, Alessandro Orso, and Mary Jean Harrold. 2007.
JDiff:ADifferencingTechniqueandToolforObject-OrientedPrograms. 14,1
(2007), 3Å›36.
[7]Muhammad Asaduzzaman, Chanchal K. Roy, Kevin A. Schneider, and Massim-
ilianoDiPenta.2013. LHDiff:ALanguage-IndependentHybridApproachfor
Tracking Source CodeLines. In ICSM. IEEE,230Å›239.
[8]Parisa Ataei, Fariba Khan, and Eric Walkingshaw. 2021. A Variational Database
ManagementSystem.In GPCE. ACM,29Å›42.
[9]Clark Barrett, Pascal Fontaine, and Cesare Tinelli. 2017. The SMT-LIB Standard:
Version 2.6 . Technical Report. Department of Computer Science, The University
of Iowa.
[10]PaulMaximilianBittner,AlexanderSchultheiÃŸ,ThomasThÃ¼m,TimoKehrer,Jef-
freyM.Young,andLukasLinsbauer.2021. FeatureTraceRecording.In ESEC/FSE .
ACM,1007Å›1020.
[11]PauloBorba,LeopoldoTeixeira,andRohitGheyi.2012. ATheoryofSoftware
ProductLineRefinement. TCS455, 0 (2012), 2Å›30.
[12]QuentinBoucher,AndreasClassen,PatrickHeymans,ArnaudBourdoux,and
Laurent Demonceau. 2010. Tag and Prune: A Pragmatic Approach to Software
ProductLineImplementation. In ASE. ACM,333Å›336.
[13]Johannes BÃ¼rdek, Timo Kehrer, Malte Lochau, Dennis Reuling, Udo Kelter, and
AndySchÃ¼rr.2015. ReasoningAboutProduct-LineEvolutionUsingComplex
FeatureModelDifferences. AUSE23,4 (2015), 687Å›733.
[14]Gerardo Canfora, Luigi Cerulo, and Massimiliano Di Penta. 2009. Ldiff: An
Enhanced LineDifferencing Tool. In ICSE. IEEE,595Å›598.
[15]KrzysztofCzarneckiandMichalAntkiewicz.2005. MappingFeaturestoModels:
A Template Approach Based on Superimposed Variants. In GPCE. Springer,
422Å›437.
[16]Krzysztof Czarnecki and Ulrich Eisenecker. 2000. Generative Programming:
Methods,Tools,and Applications . ACM/Addison-Wesley.
[17]KrzysztofCzarnecki,SimonHelsen,andUlrichEisenecker.2005. Formalizing
Cardinality-Based Feature Models and Their Specialization. SPIP10 (2005),
7Å›29.
[18]KrzysztofCzarneckiandKrzysztofPietroszek.2006. VerifyingFeature-Based
ModelTemplatesAgainstWell-FormednessOCLConstraints.In GPCE.ACM,
211Å›220.
[19]Michael John Decker, Michael L. Collard, L. Gwenn Volkert, and Jonathan I.
Maletic.2020. srcDiff:ASyntacticDifferencingApproachtoImprovetheUn-
derstandability of Deltas. JSEP32,4 (2020).
[20]Christian Dietrich, Reinhard Tartler, Wolfgang SchrÃ¶der-Preikschat, and Daniel
Lohmann.2012. A Robust Approachfor Variability Extraction fromthe Linux
Build System.In SPLC. ACM,21Å›30.
[21]Nicolas Dintzner, Arie van Deursen, and Martin Pinzger. 2018. FEVER: An
Approach to Analyze Feature-Oriented Changes and Artefact Co-Evolution in
Highly ConfigurableSystems. EMSE23,2 (2018), 905Å›952.
[22]Georg Dotzler and Michael Philippsen. 2016. Move-Optimized Source Code
TreeDifferencing.In ASE. ACM,660Å›671.
[23]Martin Erwig and Eric Walkingshaw. 2011. The Choice Calculus: A Representa-
tionfor SoftwareVariation. TOSEM21,1,Article6 (2011), 6:1Å›6:27pages.
[24]Jean-RÃ©myFalleri,FlorÃ©alMorandat,XavierBlanc,MatiasMartinez,andMartin
Monperrus.2014. Fine-GrainedandAccurateSourceCodeDifferencing.In ASE.
313Å›324.
[25]Yuanrui Fan,Xin Xia,DavidLo,AhmedE.Hassan, Yuan Wang, andShanping
Li.2021. ADifferentialTestingApproachforEvaluatingAbstractSyntaxTree
Mapping Algorithms.In ICSE. IEEE,1174Å›1185.
[26]Wolfram Fenske, Thomas ThÃ¼m, and Gunter Saake. 2014. A Taxonomy of
SoftwareProductLineReengineering.In VaMoS. ACM,4:1Å›4:8.
[27]Felype Ferreira, Rohit Gheyi, Paulo Borba, and Gustavo Soares. 2014. A Toolset
for Checking SPL Refinements. J.UCS20,5 (2014), 587Å›614.
[28]Stefan Fischer, Lukas Linsbauer, Roberto E. Lopez-Herrejon, and Alexander
Egyed. 2015. The ECCO Tool: Extraction and Composition for Clone-and-Own.
InICSE. IEEE,665Å›668.[29]BeatFluri,MichaelWuersch,MartinPinzger,andHaraldGall.2007. Change
Distilling:Tree Differencingfor Fine-Grained SourceCodeChangeExtraction.
TSE33,11(2007), 725Å›743.
[30]VeitFrick,ThomasGrassauer,FabianBeck,andMartinPinzger.2018. Gener-
ating Accurate and Compact Edit Scripts Using Tree Differencing. In ICSME.
IEEE,264Å›274.
[31]Paul Gazzillo. 2017. Kmax: Finding All Configurations of Kbuild Makefiles
Statically. In ESEC/FSE . ACM,279Å›290.
[32]Paul Gazzillo and Robert Grimm. 2012. SuperC: Parsing All of C by Taming the
Preprocessor. In PLDI. ACM,323Å›334.
[33]MasatomoHashimotoandAkiraMori.2008. Diff/TS:AToolforFine-Grained
StructuralChange Analysis. In WCRE. 279Å›288.
[34]Wolfgang Heider, Rick Rabiser, Paul GrÃ¼nbacher, and Daniela Lettner. 2012. Us-
ing Regression Testing to Analyze the Impact of Changes to Variability Models
onProducts. In SPLC. ACM,196Å›205.
[35]Tobias HeÃŸ, Chico Sundermann, and Thomas ThÃ¼m. 2021. On the Scalability of
Building Binary Decision Diagrams for Current Feature Models. In SPLC. ACM,
131Å›135.
[36]PatrickHeymans,QuentinBoucher,AndreasClassen,ArnaudBourdoux,and
LaurentDemonceau.2012. ACodeTaggingApproachtoSoftwareProductLine
Development. STTT14(2012), 553Å›566. Issue 5.
[37]Wenbin Ji, Thorsten Berger, Michal Antkiewicz, and Krzysztof Czarnecki. 2015.
Maintaining FeatureTraceabilitywith Embedded Annotations. In SPLC. ACM,
61Å›70.
[38]ChristianKÃ¤stnerandSvenApel.2008. Type-CheckingSoftwareProductLinesÃ
AFormal Approach.In ASE. IEEE,258Å›267.
[39]Christian KÃ¤stner, Sven Apel, and Martin Kuhlemann. 2008. Granularity in
SoftwareProductLines. In ICSE. ACM,311Å›320.
[40]Christian KÃ¤stner, Sven Apel, Thomas ThÃ¼m, and Gunter Saake. 2012. Type
Checking Annotation-Based ProductLines. TOSEM21,3 (2012), 14:1Å›14:39.
[41]ChristianKÃ¤stner,SvenApel,SalvadorTrujillo,MartinKuhlemann,andDon
Batory. 2009. Guaranteeing Syntactic Correctness for All Product Line Vari-
ants: A Language-Independent Approach. In TOOLS Europe , ManuelOriol and
Bertrand Meyer (Eds.).Springer, 175Å›194.
[42]Christian KÃ¤stner, Paolo G. Giarrusso, Tillmann Rendel, Sebastian Erdweg,
Klaus Ostermann, and Thorsten Berger. 2011. Variability-Aware Parsing in the
Presence of Lexical Macros and Conditional Compilation. In OOPSLA. ACM,
805Å›824.
[43]ChristianKÃ¤stner,KlausOstermann,andSebastianErdweg.2012. AVariability-
AwareModuleSystem.In OOPSLA. ACM,773Å›792.
[44]TimoKehrer,UdoKelter,PitPietsch,andMaikSchmidt.2012. Adaptabilityof
ModelComparison Tools. In ASE. ACM,306Å›309.
[45]TimoKehrer,ThomasThÃ¼m,AlexanderSchultheiÃŸ,andPaulMaximilianBittner.
2021. BridgingtheGapBetweenClone-and-OwnandSoftwareProductLines.
InICSE. IEEE,21Å›25.
[46]Alexander KnÃ¼ppel, Thomas ThÃ¼m, Stephan Mennicke, Jens Meinicke, and Ina
Schaefer.2017. IsThereaMismatchBetweenReal-WorldFeatureModelsand
Product-Line Research?. In ESEC/FSE . ACM,291Å›302.
[47]SergiyKolesnikov,AlexandervonRhein,ClausHunsen,andSvenApel.2013. A
ComparisonofProduct-Based,Feature-Based,andFamily-BasedTypeChecking.
InGPCE. ACM,115Å›124.
[48]SebastianKrieter,MarcusPinnecke,JacobKrÃ¼ger,JoshuaSprey,Christopher
Sontag, Thomas ThÃ¼m, Thomas Leich, and Gunter Saake. 2017. FeatureIDE:
Empowering Third-PartyDevelopers.In SPLC. ACM,42Å›45.
[49]ChristianKrÃ¶her,LeaGerling,andKlausSchmid.2018. IdentifyingtheInten-
sity of Variability Changes in Software Product Line Evolution. In SPLC. ACM,
54Å›64.
[50]JacobKrÃ¼gerandThorstenBerger.2020. ActivitiesandCostsofRe-Engineering
Cloned Variants Into an Integrated Platform. In VaMoS. ACM, Article 21,
10pages.
[51]Jacob KrÃ¼ger and Thorsten Berger. 2020. An Empirical Analysis of the Costs of
Clone-and Platform-Oriented SoftwareReuse. In ESEC/FSE . ACM,432Å›444.
[52]Elias Kuiter, Sebastian Krieter, Chico Sundermann, Thomas ThÃ¼m, and Gunter
Saake. 2022. Tseitin or not Tseitin? The Impact of CNF Transformations on
Feature-ModelAnalyses. In ASE. ACM. Toappear.
[53]Elias Kuiter, JacobKrÃ¼ger, SebastianKrieter, ThomasLeich, and Gunter Saake.
2018. GettingRidofClone-and-Own:MovingtoaSoftwareProductLinefor
TemperatureMonitoring.In SPLC. ACM,179Å›Å›189.
[54]ShuvenduK.Lahiri,ChrisHawblitzel,MingKawaguchi,andHenriqueRebÃªlo.
2012. SYMDIFF:ALanguage-AgnosticSemanticDiffToolforImperativePro-
grams. In CAV. Springer, 712Å›717.
[55]Daniel Le Berre and Anne Parrain. 2010. The Sat4j Library, Release 2.2. JSAT7,
2-3 (2010), 59Å›64.
[56]JÃ¶rg Liebig, Sven Apel, Christian Lengauer, Christian KÃ¤stner, and Michael
Schulze. 2010. An Analysis of the Variability in Forty Preprocessor-Based
SoftwareProductLines. In ICSE. IEEE,105Å›114.
[57]JÃ¶rg Liebig, Andreas Janker, Florian Garbe, Sven Apel, and Christian Lengauer.
2015. Morpheus: Variability-Aware Refactoring in the Wild. In ICSE. IEEE,
207Classifying Edits to Variabilityin Source Code ESEC/FSE â€™22, November14Å›18, 2022,Singapore, Singapore
380Å›391.
[58]JÃ¶rgLiebig,AlexandervonRhein,ChristianKÃ¤stner,SvenApel,JensDÃ¶rre,and
ChristianLengauer.2013. ScalableAnalysis ofVariableSoftware.In ESEC/FSE .
ACM,81Å›91.
[59]Lukas Linsbauer, Thorsten Berger, and Paul GrÃ¼nbacher. 2017. A Classification
of VariationControlSystems. In GPCE. ACM,49Å›62.
[60]Lukas Linsbauer, Alexander Egyed, and Roberto Erick Lopez-Herrejon. 2016. A
VariabilityAwareConfigurationManagementandRevisionControlPlatform.
InICSE. ACM,803Å›806.
[61]Lukas Linsbauer, Roberto Erick Lopez-Herrejon, and Alexander Egyed. 2017.
VariabilityExtractionandModelingforProductVariants. SoSyM16,4(2017),
1179Å›1199.
[62]SaschaLity,ManuelNieke,ThomasThÃ¼m,andInaSchaefer.2019. RetestTestSe-
lectionforProduct-LineRegressionTestingofVariantsandVersionsofVariants.
JSS147(2019), 46Å›63.
[63]Wardah Mahmood, Daniel Strueber, Thorsten Berger, Ralf Laemmel, and Muke-
labai Mukelabai. 2021. Seamless Variability Management With the Virtual
Platform. In ICSE. IEEE,1658Å›1670.
[64]Shahar Maoz, Jan Oliver Ringert, and Bernhard Rumpe. 2010. A Manifesto for
Semantic ModelDifferencing. MODELS, 194Å›203.
[65]FlÃ¡vio Medeiros, MÃ¡rcio Ribeiro, and Rohit Gheyi. 2013. Investigating
Preprocessor-Based Syntax Errors. In GPCE. ACM,75Å›84.
[66]Gabriela K. Michelon, Wesley K. G. AssunÃ§Ã£o, David Obermann, Lukas Lins-
bauer, Paul GrÃ¼nbacher, and Alexander Egyed. 2021. The Life Cycle of Features
inHighly-ConfigurableSoftwareSystemsEvolvinginSpaceandTime.In GPCE.
ACM,2Å›15.
[67] GabrielaKaroline Michelon,David Obermann, Lukas Linsbauer, WesleyKlew-
erton GuezAssunÃ§Ã£o,Paul GrÃ¼nbacher,and AlexanderEgyed. 2020. Locating
Feature Revisions in Software Systems Evolving in Space and Time. In SPLC.
ACM,Article14,11pages.
[68]Daniel-Jesus Munoz, Jeho Oh, MÃ³nica Pinto, Lidia Fuentes, and Don Batory.
2019. Uniform Random Sampling Product Configurations of Feature Models
That HaveNumerical Features. In SPLC. ACM,289Å›301.
[69]LaÃ­s Neves, Paulo Borba, Vander Alves, LucinÃ©ia Turnes, Leopoldo Teixeira,
DemÃ³stenesSena,andUirÃ¡Kulesza.2015.SafeEvolutionTemplatesforSoftware
ProductLines. JSS106(2015), 42Å›58.
[70]LaÃ­sNeves,LeopoldoTeixeira,DemÃ³stenesSena,VanderAlves,UirÃ¡Kulesza,
and Paulo Borba. 2011. Investigating the Safe Evolution of Software Product
Lines. InGPCE. ACM,33Å›42.
[71]Michael Nieke, Gabriela Sampaio, Thomas ThÃ¼m, Christoph Seidl, Leopoldo
Teixeira, and Ina Schaefer. 2022. Guiding the Evolution of Product-Line Config-
urations. SoSyM21(2022), 225Å›247. Issue 1.
[72]Yannic Noller, Hoang Lam Nguyen, Minxing Tang, Timo Kehrer, and Lars
Grunske. 2021. Complete Shadow Symbolic Execution with Java PathFinder.
SEN44,4 (2021), 15Å›16.
[73]Yannic Noller, Corina S. PÄƒsÄƒreanu, Marcel BÃ¶hme, Youcheng Sun, Hoang Lam
Nguyen,andLarsGrunske.2020. HyDiff:HybridDifferentialSoftwareAnalysis.
InICSE. ACM,1273Å›1285.
[74]Yusuf Sulistyo Nugroho, Hideaki Hata, and Kenichi Matsumoto. 2020. How
DifferentareDifferentDiff Algorithms in Git? EMSE25,1 (2020), 790Å›823.
[75]Hristina Palikareva, Tomasz Kuchta, and Cristian Cadar. 2016. Shadow of a
Doubt: Testing for Divergences Between Software Versions. In ICSE. ACM,
1181Å›1192.
[76]Nimrod Partush and Eran Yahav. 2014. Abstract Semantic Differencing via
SpeculativeCorrelation. In OOPSLA. ACM,811Å›828.
[77]LeonardoPassos,KrzysztofCzarnecki,SvenApel,AndrzejWÄ…sowski,Christian
KÃ¤stner,andJianmeiGuo.2013. Feature-OrientedSoftwareEvolution.In VaMoS.
ACM,1Å›8.
[78]Leonardo Passos, Leopoldo Teixeira, Nicolas Dintzner, Sven Apel, Andrzej WÄ…-
sowski, Krzysztof Czarnecki, Paulo Borba, and Jianmei Guo. 2016. Coevolution
of Variability Models and Related SoftwareArtifacts. EMSE21,4 (2016).[79]Tobias Pett, Sebastian Krieter, Tobias Runge, Thomas ThÃ¼m, Malte Lochau, and
InaSchaefer.2021. StabilityofProduct-LineSamplinginContinuousIntegration.
InVaMoS. ACM,Article18,9 pages.
[80]TristanPfofe,ThomasThÃ¼m,Sandro Schulze,WolframFenske,andInaSchae-
fer.2016. SynchronizingSoftwareVariantswithVariantSync.In SPLC.ACM,
329Å›332.
[81]Klaus Pohl, GÃ¼nter BÃ¶ckle, and Frank J. van der Linden. 2005. Software Product
LineEngineering: Foundations,Principles and Techniques . Springer.
[82]Julia Rubin, Krzysztof Czarnecki, and Marsha Chechik. 2013. Managing Cloned
Variants: AFrameworkand Experience. In SPLC. ACM,101Å›110.
[83]SebastianRuland,LarsLuthmann,JohannesBÃ¼rdek,SaschaLity,ThomasThÃ¼m,
Malte Lochau, and MÃ¡rcio Ribeiro. 2018. Measuring Effectiveness of Sample-
Based Product-Line Testing.In GPCE. ACM,119Å›133.
[84]Gabriela Sampaio, Paulo Borba, and Leopoldo Teixeira. 2019. Partially Safe
Evolutionof SoftwareProductLines. JSS155(2019), 17Å›42.
[85]Thomas Schmorleiz and Ralf LÃ¤mmel. 2016. Similarity Management of â€™Cloned
and Ownedâ€™Variants.In SAC. ACM,1466Å›1471.
[86]AlexanderSchultheiÃŸ,PaulMaximilianBittner,ThomasThÃ¼m,andTimoKehrer.
2022. QuantifyingthePotentialtoAutomatetheSynchronizationofVariantsin
Clone-and-Own.In ICSME. IEEE. Toappear.
[87]Sandro Schulze, Oliver Richers, and Ina Schaefer. 2013. Refactoring Delta-
Oriented SoftwareProductLines. In AOSD. ACM,73Å›84.
[88]Sandro Schulze, Thomas ThÃ¼m, Martin Kuhlemann, and Gunter Saake. 2012.
Variant-PreservingRefactoring in Feature-Oriented Software Product Lines. In
VaMoS. ACM,73Å›81.
[89]Christoph Seidl, Florian Heidenreich, and Uwe AÃŸmann. 2012. Co-Evolution of
Models and Feature Mapping in Software Product Lines. In SPLC. ACM, 76Å›85.
[90]StefanStÄƒnciulescu,ThorstenBerger,EricWalkingshaw,andAndrzejWÄ…sowski.
2016. Concepts, Operations, and Feasibility of a Projection-Based Variation
ControlSystem.In ICSME. IEEE,323Å›333.
[91]Chico Sundermann, Michael Nieke, Paul Maximilian Bittner, Tobias HeÃŸ,
ThomasThÃ¼m,andInaSchaefer.2021. Applicationsof#SATSolversonFeature
Models. In VaMoS. ACM,Article12,10pages.
[92]ChicoSundermann,ThomasThÃ¼m,andInaSchaefer.2020. Evaluating#SAT
SolversonIndustrial FeatureModels. In VaMoS. ACM,Article3,9 pages.
[93]Reinhard Tartler, Daniel Lohmann, Julio Sincero, and Wolfgang SchrÃ¶der-
Preikschat.2011. FeatureConsistencyinCompile-Time-ConfigurableSystem
Software: Facing the Linux 10,000 FeatureProblem.In EuroSys. ACM,47Å›60.
[94]Sahil Thaker, Don Batory, David Kitchin, and William Cook. 2007. Safe Compo-
sition of ProductLines. In GPCE. ACM,95Å›104.
[95]ThomasThÃ¼m,DonBatory,andChristianKÃ¤stner.2009. ReasoningAboutEdits
to FeatureModels. In ICSE. IEEE,254Å›264.
[96]Thomas ThÃ¼m, Leopoldo Teixeira, Klaus Schmid, Eric Walkingshaw, Mukelabai
Mukelabai,MahsaVarshosaz,GoetzBotterweck,InaSchaefer,andTimoKehrer.
2019. TowardsEfficientAnalysisofVariationinTimeandSpace.In VariVolution .
ACM,57Å›64.
[97]GrigoriS.Tseytin.1983. OntheComplexityofDerivationinPropositionalCalculus .
Springer, 466Å›483.
[98]SÃ¶ren Viegener. 2021. Empirical Evaluation of Feature Trace Recording on the
EditHistoryofMarlin . Bachelorâ€™sThesis. Universityof Ulm.
[99]AlexandervonRhein,AlexanderGrebhahn,SvenApel,NorbertSiegmund,Dirk
Beyer, and Thorsten Berger. 2015. Presence-Condition Simplification in Highly
ConfigurableSystems. In ICSE. IEEE,178Å›188.
[100]EricWalkingshawandKlausOstermann.2014. ProjectionalEditingofVaria-
tionalSoftware. In GPCE. ACM,29Å›38.
[101]Jeffrey M. Young, Paul Maximilian Bittner, Eric Walkingshaw, and Thomas
ThÃ¼m.2022. VariationalSatisfiabilitySolving:EfficientlySolvingLotsofRelated
SATProblems. EMSE(2022). Toappear.
[102]ShuruiZhou,ÅtefanStÄƒnciulescu,OlafLeÃŸenich,YingfeiXiong,AndrzejWÄ…-
sowski, and Christian KÃ¤stner. 2018. Identifying Features in Forks. In ICSE.
ACM,105Å›116.
208