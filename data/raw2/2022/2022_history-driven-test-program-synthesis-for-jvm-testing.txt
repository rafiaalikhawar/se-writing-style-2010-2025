History-Driven Test Program Synthesis for JVM Testing
Yingquan Zhao
College of Intelligence and
Computing, Tianjin
University
China
zhaoyingquan@tju.edu.cnZan Wang
College of Intelligence and
Computing, Tianjin
University
China
wangzan@tju.edu.cnJunjie Chen‚àó
College of Intelligence and
Computing, Tianjin
University
China
junjiechen@tju.edu.cnMengdi Liu
College of Intelligence and
Computing, Tianjin
University
China
liumengdi@tju.edu.cn
Mingyuan Wu
Southern University of
Science and Technology
China
11849319@mail.sustech.edu.cnYuqun Zhang
Southern University of
Science and Technology
China
zhangyq@sustech.edu.cnLingming Zhang
University of Illinois
Urbana-Champaign
United States
lingming@illinois.edu
ABSTRACT
Java Virtual Machine (JVM) provides the runtime environment for
Javaprograms,whichallowsJavatobe‚Äúwriteonce,runanywhere‚Äù.
JVM plays a decisive role in the correctness of all Java programs
running on it. Therefore, ensuring the correctness and robustness
of JVM implementations is essential for Java programs. To date,
various techniques have been proposed to expose JVM bugs via
generating potential bug-revealing test programs. However, the
diversity and effectiveness of test programs generated by existing
researcharefarfromenoughsincetheymainlyfocusonminorsyn-
tactic/semantic mutations. In this paper, we propose JavaTailor ,
the first history-driven test program synthesis technique, which
synthesizesdiversetestprogramsbyweavingtheingredientsex-
tracted from JVMhistorical bug-revealingtest programsinto seed
programsforcoveringmoreJVMbehaviors/paths.Morespecifically,
JavaTailor first extracts five types of code ingredients from the his-
toricalbug-revealingtestprograms.Then,tosynthesizediversetest
programs, it iteratively inserts the extracted ingredients into the
seedprogramsandstrengthenstheirinteractionsviaintroducing
extradatadependenciesbetweenthem.Finally,JavaTailoremploys
these synthesized test programs to differentially test JVMs. Our ex-
perimentalresultsonpopularJVMimplementations(i.e.,HotSpot
and OpenJ9) show that JavaTailor outperforms the state-of-the-art
techniqueingeneratingmorediverseandeffectivetestprograms,
e.g.,testprogramsgeneratedbyJavaTailorcanachievehigherJVM
code coverage and detect many more unique inconsistencies than
thestate-of-the-arttechnique.Furthermore,JavaTailorhasdetected
10previouslyunknownbugs,6ofwhichhavebeenconfirmed/fixed
by developers.
‚àóJunjie Chen is the corresponding author.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACMmustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA
¬© 2022 Association for Computing Machinery.
ACM ISBN 978-1-4503-9221-1/22/05...$15.00
https://doi.org/10.1145/3510003.3510059CCS CONCEPTS
‚Ä¢Software and its engineering ‚ÜíSoftware testing and de-
bugging; Compilers.
KEYWORDS
JavaVirtualMachine,ProgramSynthesis,JVMTesting,Compiler
Testing
ACM Reference Format:
YingquanZhao,ZanWang,JunjieChen,MengdiLiu,MingyuanWu,Yuqun
Zhang, and Lingming Zhang. 2022. History-Driven Test Program Synthesis
forJVMTesting.In 44thInternationalConferenceonSoftwareEngineering
(ICSE ‚Äô22), May 21‚Äì29, 2022, Pittsburgh, PA, USA. ACM, New York, NY, USA,
12 pages. https://doi.org/10.1145/3510003.3510059
1 INTRODUCTION
Java Virtual Machine (JVM) is the fundamental infrastructure to
supporttherunningofJavaprogramsandtheprogramsthatare
written in other programming languages but can be compiled to
Java bytecode [ 18,34,35,42,45]. Over the years, many JVMs have
been developed by various organizations or companies, such as
HotSpot from Oracle [ 6], OpenJ9 from IBM [ 9], GIJ from GNU [ 5],
andZulufromAzul[ 10].Althoughmanyofthemhavebeenelab-
orately maintained for many years, like other software systems,
JVMalsocontainsbugs[ 44].Duetoitsfundamentalrole,JVMbugs
couldleadtounexpectedbehaviors(evendisastersinsafety-critical
domains) of any programs running on top of it. Therefore, it is
crucial to ensure JVM‚Äôs quality.
In recent years, some JVM testing techniques have been pro-
posedtoguaranteethequalityofJVM,including classfuzz [31]and
classming [30].Thesetechniquesdesignvariousmutationoperators
to generate a large number of Java classfiles ( *.class) based on
real-world classfiles (also called seed classfiles) as test inputs for
JVMtesting.Inthispaper,wecallJVM‚Äôstestinputs testprograms
andseed classfiles seedprograms followingthe existingwork[ 23].
Specifically, classfuzz [31]designsaseriesofsyntacticmutationop-
erators (e.g., changing the modifier or type of a variable). However,
itsgeneratedtestprogramsareusuallyinvalid,causingthatthey
are rejected at the JVM‚Äôs startup stage (i.e., loading, linking, and
initialization) and thus cannot reach the follow-up verification and
executionstages.Togetridofthislimitation,thestate-of-the-art
11332022 IEEE/ACM 44th International Conference on Software Engineering (ICSE)
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:21:07 UTC from IEEE Xplore.  Restrictions apply. ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA Yingquan Zhao, Zan Wang, Junjie Chen, Mengdi Liu, Mingyuan Wu, Yuqun Zhang, and Lingming Zhang
technique, i.e., classming , was proposed [ 30], which designs some
mutation operators (e.g., inserting gotoorreturninstructions)
to alter the control- and data- flow of seed programs instead of
syntactic mutation.
Althoughthesetechniqueshavebeendemonstratedtobeableto
detect some new JVM bugs, they still suffer from the effectiveness
problem.Specifically,theyjustaimtogeneratethetestprograms
with diverse control- and data- flow by accumulating minor muta-
tions, rather than bug-revealing test programs. That is, their goal is
notdirectlyalignedwiththetestinggoal,leadingtospendingplenty
of time on generating and executing the test programs without the
bug-revealing capability and thus hindering their effectiveness.
Moreover, the great control- and data- flow diversity of test pro-
gramsdoesnotmeandiversetestingcapabilitiesfortheJVMunder
test. In particular, their minor mutations (e.g., mutating some key-
words) actually limit the space for constructing new test programs
andthuslimittheirtestingcapabilities.Forexample,inourstudy
(to be presented in Section 4) the state-of-the-art technique (i.e.,
classming ) only increases 1.30% JVM line coverage compared with
theseedprogram(i.e.,avrora)afterexecuting3,765itsgenerated
test programs. Therefore, more effective JVM testing techniques
are still desirable.
TofurtherimprovetheeffectivenessofJVMtesting,inthiswork
we propose a novel technique, called JavaTailor , which aims to
generate bug-revealing test programs as much as possible in order
toapproachtheidealtestinggoal.Toachievethisgoal,JavaTailor
investigatesthetestprogramsrevealinghistoricalJVMbugsand
then extracts bug-revealing ingredients from them to facilitate the
generation of new bug-revealing test programs. The key insight
liesinthateachhistoricallybug-revealingtestprogramcontains
the ingredients facilitating the detection of the bug, which may
involvecomplicatedcodelogicorcovercornercases.Ifwecombine
theingredientsextractedfromvarioushistoricallybug-revealing
test programs orput these ingredients into different contexts, it is
verylikelytogeneratethetestprogramsthatcancovermoreinter-
ested JVM‚Äôsbehaviors/paths,leading todetecting newbugs. With
this intuition, we design JavaTailor consisting of three steps: First,
JavaTailorextractstheingredientsfromourcollectedhistorically
bug-revealing test programs to form an ingredient pool. In particu-
lar, we systematically extract five types of ingredients at the block
level, to balance extraction efficiency and effectiveness. Second, Ja-
vaTailor generates a new test program by synthesizing a randomly
selectedingredientfromthepoolandareal-worldclassfile(i.e.,a
seedprogram).Theseedprogramisresponsibletoprovidedifferentcontextsfortheextractedingredient.Themaintechnicalchallenge
of JavaTailor lies in this step since it is necessary to guarantee
thesynthesizedtestprogramtobevalid.Here,JavaTailordesigns
two strategies (i.e., reusing variables in the seed program and con-
structing new definitions) to fix the broken syntactic and semantic
constraintsin theextracted ingredient.In particular,JavaTailoral-
lowssynthesizingtheseedprogramwithmultipleingredientsinan
iterativeway,whichishelpfultocombinedifferentbug-revealing
ingredients for JVM testing. Third, JavaTailor adopts differential
testingtocheckwhetherthegeneratedtestprogramcanreveala
JVM bug or not.
To evaluate the effectiveness of JavaTailor, we conducted ex-
tensive experiments on two popular JVM implementations (i.e.,HotSpotandOpenJ9)involving5OpenJDKversions,bytaking8
real-world benchmarks as seed programs and collecting 630 his-torically bug-revealing test programs. Our experimental resultsdemonstrate that JavaTailor is able to detect much more unique
inconsistenciesthanthestate-of-the-artJVMtestingtechnique(i.e.,classming [
30]),achieving792.31% ‚àº1742.86%improvementsacross
alltheOpenJDKversionsexceptOpenJDK14(onlyJavaTailorde-
tects inconsistencies on this version, and thus we cannot calculate
theimprovementonit).Also,onthebasisoftestcoverageachieved
bytheseedprograms,JavaTailorisabletofurtherimprovemuch
morelinecoverage,branchcoverage,andfunctioncoveragethan
classming . In particular, JavaTailor detects 10 unknown bugs in the
latest HotSpot and OpenJ9, among which 6 has been confirmed or
fixedbydevelopersaftersubmittingthemtothecorrespondingbugrepositories.Thoseresultsdemonstratethesignificanteffectiveness
of JavaTailor.
Tosumup, thisworkmakesthe followingmajorcontributions:
‚Ä¢Direction. We open a new direction for JVM testing: while
priorworkonJVMtestingfocusedonminorsyntactic/semantic
mutations,ourworkopensanewdimensionforJVMtest-
ing via history-driven test program synthesis to cover more
diverse JVM paths/behaviors.
‚Ä¢Technique. We propose a novel JVM testing technique,
called JavaTailor, which aims to generate bug-revealing test
programs as much as possible by elaborately utilizing his-
torically bug-revealing test programs.
‚Ä¢Implementation. Wedevelopandreleaseatooltoimple-
ment JavaTailor [ 7], including systematically extracting in-
gredients from historically bug-revealing test programs and
synthesizingtheingredientswithagivenseedprogramto
produce a valid test program.
‚Ä¢Study.WeconductanextensivestudytoevaluateJavaTailor
based on popular JVM implementations(i.e., HotSpot andOpenJ9), demonstrating the significant superiority of Ja-
vaTailor overthe state-of-the-artJVM testingtechnique. In
particular, JavaTailor has detected 10 unknown bugs, 6 of
which have been confirmed or fixed by developers.
2 MOTIVATION AND CHALLENGES
Here, we use an example to illustrate the motivation of JavaTailor
and its major challenges.
Figure1ashowsatestprogramgeneratedbyJavaTailor,which
detectsanunknownOpenJ9bug.Thisbugiscausedduetomissing
nullchecks for the parameters in MemoryNotificationInfo in
theOpenJ9implementation. MemoryNotificationInfo isaninter-
nal class under java.lang.management package, which is used to
notifywhenthememoryusageexceedsathreshold.Thenotifiedin-
formation is vital for debugging when error occurs. When running
this test program with a nullparameter (i.e., usage) on OpenJ9, it
isexecuted normallywithoutany exception.However, whenrun-
ningthesametestprogramonHotSpot,a NullPointerException
is thrown since its implementation contains nullchecks for the
parameters in MemoryNotificationInfo . The different behavior
exhibitedbythemindicatestheexistenceofabuginatleastone
ofthem.Throughourmanualinvestigationandsubmittingabug
report to the bug repository of OpenJ9, the bug was confirmed
1134
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:21:07 UTC from IEEE Xplore.  Restrictions apply. History-Driven Test Program Synthesis for JVM Testing ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA
 1 public static void  main(String[] args) {
 2   String str = "anystring" ;
 3
 4 String name = str;
 5 MemoryUsage usage = null;
 6 long count = 999;  //generate by random
 7 MemoryNotificationInfo mn; 8 mn = new MemoryNotificationInfo(name, usage, count);
 9 count = mn.getCount();
1011 System. out.println(str);
12 }
(a) Test program 1 public static int  run(String[] argv, PrintStream out) {
 2   MemoryUsage mu = new MemoryUsage( 1, 2, 3, 4);                
 3 
 4 // Check negative count
 5 mn = new MemoryNotificationInfo( "poolName" , mu, -1);
 6   count = mn.getCount(); 7 if (count != -1) {
 8     out.println( "FAILURE 2." );
 9     out.println( "Wrong count: "  + count + ", expected: -1" );
10     testFailed = true;
11 }
12 ...
13 }
(b) Historical test program
Figure 1: Motivating example
  public  MemoryNotificationInfo (String poolName , 
MemoryUsage  usage, long count) {
    super ();
+  if (poolName  == null ) {
+     /*[MSG "K0D02", "Null poolName"]*/
+ throw new NullPointerException(*** .getString( "K0D02"));
+  }
++  if (usage == null) {
+ /*[MSG "K0D03", "Null usage"]*/
+ throw new  NullPointerException(*** .getString( "K0D03"));
+  }
  this.poolName = poolName;
  this.usage = usage;
  this.count = count;
 }
Figure 2: OpenJ9 Bug#12552
and fixed by OpenJ9‚Äôs developers (Bug ID: 12552 [ 2]). The patch
provided by them is shown in Figure 2, in which nullchecks have
been added for MemoryNotificationInfo‚Äôs parameters.
Thisbug-revealingtestprogramisgeneratedbysynthesizingthe
ingredientextractedfromahistoricalbug-revealingtestprogram
(asshowninFigure1b)andanarbitrarilyselectedseedprogram(as
showninFigure1awithoutthecodemarkedinred).Pleasenote
thatthehistoricaltestprogramcannottriggertheabovedetected
bug since no parameters in MemoryNotificationInfo are set to
null. Specifically, we extract Lines 5-6 from the historical test
programastheingredientandtheninsertittotheseedprogram.
As shown in Figure 1a, we insert the ingredient at Lines 4-9 to
produceatestprogram.Here,directlyinsertingtheingredientto
the seed program cannot make the synthesized test program valid
due to lack of definition of some variables (such as mnand the
parametersof MemoryNotificationInfo ),andwehavetoconduct
extra operations to make it valid.
To better integrate the ingredient and seed program for the trig-
gering of interesting/corner-case interactions between them, we
prefer to replace the undefined variables in the ingredient with
the existing variables satisfying type compatibility in the seed pro-
gram. Thus, we assign strdefined at Line 2 to the first parameter
ofMemoryNotificationInfo (as shown at Line 4). If the seed pro-
gramalsodoesnotcontainsuchtype-compatiblevariables,wehavetogeneratedefinitionsforthecorrespondingvariables.Forexample,thesecondparameterof
MemoryNotificationInfo belongstothe
type ofMemoryUsage and thus we generate its definition as shown
at Line 5. Since the second parameter is initialized to be null, the
synthesized test program is able to trigger the bug.WefurtheranalyzedwhetherexistingJVMtestingtechniques
can detect this bug. Regardless of classming orclassfuzz, they just
conduct minor mutations (e.g., changing the modifier of a vari-able or inserting the
gotokeyword) on the seed program in an
iterative way, which aims to change the data- and control- flowinside the seed program. If the seed program does not contain
MemoryNotificationInfo like the one used in the example (i.e.,
the seed program contains only Lines 2 and 11 as shown in Fig-
ure 1a), thesetechniques cannot generate testprograms revealing
thebugnomatterhowtochangeitsdata-andcontrol-flow.Aspre-sentedabove,however,synthesizingtheingredientsfromhistorical
testprogramsismorelikelytointroducebug-revealingprogram
features,indicatingthepromisingdirectionofminingtheingredi-
ents accumulated in a large number of historical bug-revealing test
programs for constructing better JVM test programs.
Whileitisapromisingdirection,synthesizingnewbug-revealing
test programs based on historically bug-revealing test programs is
not trivial, which suffers from two major challenges:
Challenge 1 :Howto measureandextractingredients inhistori-
cally bug-revealing test programs? A test program tends to contain
various language structures, which can be represented at different
granularities (such as variables, blocks, or files). If we measure and
extract ingredients at a very fine-grained granularity (e.g., variable
granularity), the process of ingredient extraction could become
costly and the whole syntactic or semantic features relevant to bugdetectionmaybedamaged.Ifthegranularityistoocoarse(e.g.,file
granularity), the interaction between the extracted ingredients and
theseedprogramcouldbeweak,whichaffectstheintegrationof
theingredientswithnewcontextsandthusimpairsthetestingper-
formanceof synthesizedtest programs.Therefore, measuringand
extractingingredientsatanappropriategranularityisimportant
and non-trivial.
Challenge 2 :Howtoguaranteethatasynthesizedtestprogram
is valid? A test program usually involves various syntactic and
semanticconstraints.Violatingthemcanmakeitbecomeinvalid,
and an invalid test program will be rejected by the JVM under
test,thusimpairingthetestingperformance.Whensynthesizing
the ingredients extracted from one test program with another test
program, it is scarcely possible to produce a valid test program by
directly combiningthem since theytend to involve verydifferent
syntactic and semantic constraints. Therefore, it is very important
but challenging to make the different constraints from the two test
1135
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:21:07 UTC from IEEE Xplore.  Restrictions apply. ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA Yingquan Zhao, Zan Wang, Junjie Chen, Mengdi Liu, Mingyuan Wu, Yuqun Zhang, and Lingming Zhang
programscompatibleduringthesynthesisprocess,sothatavalid
test program can be produced.
3 APPROACH
In this paper, we propose a novel JVM testing technique, called Ja-
vaTailor ,whichaimstogeneratenewbug-revealingtestprograms
by synthesizing the code ingredients extracted from historically
bug-revealing test programs with given seed programs. The keyinsightbehindJavaTailoristhat1)existingtestprogramsreveal-ing historical bugs contain the code ingredients facilitating thedetection of bugs, which tend to contain more complicated code
logic or cover various corner cases, and 2) combining various such
code ingredients and/or putting them into different code contexts
canpotentiallycoverevenmoreinterestingJVMbehaviors/paths
important for new JVM bug detection.
Figure 3 shows the overview of JavaTailor, which consists of
three stages. First, JavaTailor extracts the ingredients from thecollected test programs revealing historical bugs to construct an
ingredient pool (Section 3.1). More specifically, we systematically
designvarioustypesofcodeingredientsattheblockgranularity
inJavaTailortobalancebotheffectivenessandefficiency.Second,
JavaTailor synthesizes a randomly selected ingredient from the
ingredient pool with a given seed program to generate a valid test
program (Section 3.2). Meanwhile, JavaTailor fixes the broken syn-
tactic and semantic constraints in the code ingredient (i.e., missing
variables‚Äôdefinitions)byeitherutilizingthetype-compatiblevari-
ablesintheseedprogramorautomaticallyconstructingthemissingdefinitions.Third,JavaTailorexecutesthesynthesizedtestprogram
for JVM testing (Section 3.3). It adopts differential testing basedon different JVM implementations (e.g., HotSpot and OpenJ9) tocheck whether the test program reveals a bug or not. If there is
noinconsistenciesidentifiedbythesynthesizedtestprogram,the
test program will be put into the pool of seed programs for further
combining with more ingredients.
3.1 Ingredient Extraction
AsdiscussedinSection2,theeffectivenessofextractedingredients
could be affected by its extraction granularity. In JavaTailor, weadopt the block granularity as the trade-off between extraction
efficiencyandeffectiveness.Specifically,wesystematicallydeign
fivetypesofblocksforingredientextractionasfollows.Inparticular,
ourimplementationforJavaTailorisbasedonSoot[ 47],awidely-
used tool for analyzing Java classfiles, and our five types of blocks
can cover all the types of instructions supported by Soot. Based
on Soot, JavaTailor extracts ingredients from the Java classfile (i.e.,
Jimple code transformed by Soot) level rather than the source code
level, which can acquire the following benefits: 1) There are a
numberofoperationsonJimplecodesupportedbySoot,facilitating
the implementation of JavaTailor; 2) It facilitates to generate more
testprogramswithrichersemanticsbygettingridoftheconstraints
from front-end compilers (e.g., javac).
‚Ä¢SequentialIngredient(SEQ) .ASEQreferstoablockcon-
taining a sequence of instructions without any branches.
‚Ä¢IfIngredient(IF) :AIFcouldhaveseveralbranches(i.e., if,
else if, andelse), and it includes the conditions of all the
branches and the corresponding bodies.‚Ä¢LoopIngredient(LOOP) :ALOOPcouldbe while,do-while ,
orforLOOP. It includes the loop condition and the corre-
sponding body.
‚Ä¢Switch Ingredient (SWITCH) : A SWITCH includes the
conditionandallthecases.InSoot,itcontainsboth lookupswitch
andtableswitch.
‚Ä¢Try-Catch Ingredient (TRAP) : It includes the trybody
and the statements used for handling the caught exception.
To implement the extraction of ingredients, JavaTailor trans-
formsahistoricalbug-revealingtestprogramintoaControl-Flow
Graph (CFG) based on the Jimple code obtained after Soot‚Äôs pro-cessing.InaCFG,anodereferstoabasicblockincludingoneor
moreinstructions, andan edgerepresentsthe codelogicbetween
two basic blocks. An ingredient in JavaTailor includes one or more
basic blocks in a CFG.
Based on the CFG of a test program, JavaTailor first identifies
the starting points (i.e., basic blocks) of the latter four types of
ingredients according to the types of instructions included in each
basic block. For example, if a basic block contains a switchin-
struction, it can be regarded as the starting point of a SWITCH
ingredient.Then,foreachstartingpointofaningredient,JavaTailor
searches for its dependent basic blocks to form a whole ingredient.
For example, after identifying a basic block including a switch
instruction,JavaTailorsearchesforthebasicblocksforallthecases
ofthisswitchcondition,andfinallyallthesebasicblocksforma
SWITCH ingredient. There is a special case in implementations
and we further illustrate it in detail: If a basic block contains an if
instruction,it ishard todeterminewhether itisthe startingpoint
ofanIFingredient.ThisisbecauseinSoot,loopsarerepresented
asthecombinationof ifandgotoinstructions.Thus,weneedto
checkwhetheritssuccessorbasicblockscontaina gotoinstruction.
If agotoinstruction is found and its target is the starting point,
this basic block is actually the starting point of a LOOP ingredient;
otherwise, it is the starting point of an IF ingredient. For a basic
blockthatcannotbeidentifiedasthestartingpointofanyofthe
latter four types of ingredients, JavaTailor treats the basic block as
a SEQ ingredient.
To further illustrate the extraction process, we take an example
showninFigure4,whichisaCFGofnested for-if.Foreachbasic
block in the CFG, JavaTailor checks whether it is the starting point
of one of the ingredients. For example, for the block labeled as 2
(alsocalledblock2),itcontainsan ifinstruction,indicatingthat
itmaybethestartpointofanIFingredientoraLOOPingredient.
Tofigureoutitstype,JavaTailorrecursivelygetsallitssuccessor
blocks,andfindsthatthereisa gotoinstructionthatpointstoblock
2inblock5,indicatingthatthisisaLOOPingredient.Itcorresponds
to the part labeled as FOR in this figure. For block 3, there is no
gotoinstruction pointing to it in all its successor blocks, and thus
it is an If Ingredient, corresponding to the part labeled as IF in this
figure. When the extraction process is completed, JavaTailor canextract 4 ingredients in this example, as shown at the bottom of
Figure4.NotethatthestartandendblocksofCFGarefilteredhere,
due to its simple code logic.
Through extracting the five types of ingredients from all the
collectedhistoricalbug-revealingtestprograms,aningredientpool
can be built by JavaTailor.
1136
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:21:07 UTC from IEEE Xplore.  Restrictions apply. History-Driven Test Program Synthesis for JVM Testing ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA
RAW
Historical 
Test Programs
Ingredient Pool
Seed PoolNo Difference FoundStep2:
Ingredient
ExtractionStep3:
Ingredient
Selection
Difference
Report
Failing
Synthesized 
ProgramsNormal 
Synthesized ProgramStep4:
Seed SelectionStep5: Insertion
Step1:
Seed 
Initialization
Seed Programs
Input Synthesis Phase Execution Phase OutputOther JVMs‚Ä¶
Figure 3: Overview of JavaTailor
label 1: 
if i0>=10 goto label 3
label 3:
returnif i0>=6 goto label 2FOR
IF
$r1=java.lang.System.out
$r1.println(i0)
label 2:
i0 = i0 + 1
goto label1r0:=@parameter()
i0=01
2
43
5
6
Extracted Ingredients: IF: {3,4,5} SEQ: {4}, {5} LOOP: { 2,3,4,5} 
Figure 4: Control flow graph of nested For-If
3.2 Test Program Synthesis
To generate a new test program, JavaTailor randomly selects an
ingredient from the ingredient pool as well as a seed program,
andthensynthesizestheingredientwiththeseedprogram.Also,
JavaTailorrandomlyselectsaprogrampointintheseedprogram
for inserting the extracted ingredient (we call it synthesis point
in this paper). Such random operations are helpful to generate
diversesynthesizedtestprograms.AsdiscussedinSection2,itis
challenging to ensure that the synthesized test program is validdue to breaking the original syntactic and semantic constraints
oftheingredient(i.e.,missingvariabledefinitions).Therefore,to
obtain a valid synthesized test program, JavaTailor has to fix those
broken constraints during the synthesis process. To achieve this
goal,JavaTailorhastwostrategies,i.e.,reusingvariablesintheseed
program and constructing new definitions.
Reusing variables in the seed program .Foravariable missing
itsdefinitionintheingredient,JavaTailorpreferstofindwhether
thereisavariableintheseedprogramthatcanbeusedtoreplacethe
variable in the ingredient. In this way, the interaction between the
ingredient and the seed program can be stronger, enabling the new
context to produce larger impact on the historical bug-revealing
ingredient, which in turn is more likely to trigger different JVM
behaviorsandrevealnewbugs.Specifically,JavaTailorsearchesforthetype-compatible variablesintheseedprogramwiththevariableIngredient
Depth 1
Depth 2
Seed Variable:
String s0 = ‚Äús‚Äù;Class1(String str, Class2 c2)
…†
…°Class2(int i, float f)
int i=1; float f=1.0;String str = s0;invoke Method fun(Class1 c1)
…¢…£…§
Reusing seed variable: Creating new variables: …†…° …¢…£…§
Figure 5: Fix broken constraints
missingitsdefinitionintheingredientfromthecodebeforethesyn-thesispoint.Ifsuchavariableisfound,JavaTailorthenreplacesthe
ingredient‚Äôsvariable withthe identifiedtype-compatiblevariable,
in order to recover the broken constraints.
Constructingnewdefinitions .Notallthevariablesmissingdefi-
nitionsintheingredientcanfindsuchtype-compatiblevariablesin
theseedprogram,especiallywhenthevariabletypeisan Object
type. At this time, JavaTailor has to construct definitions for those
variables in order to fix the broken constraints. Algorithm 1 for-
mally illustrates the definition construction process. Regarding the
primitivetypes,JavaTailordirectlyconstructsthecorresponding
typesofvariableswitharandominitializationatLine5.Otherwise,
ifavariable‚Äôstypeisan Objecttype,wecaninvokethecorrespond-
ingconstructortodefinethevariableatLine9,butitisalsovery
likely to come across the parameters with other Objecttypes in
the constructor as shown in Lines 10-15. Then, JavaTailor is also
required to define these parameters by invoking their constructors
at Line 14. That is, this process is recursive until all the requiredparameters are primitive types. In particular, to avoid costly or
evenendlessrecursion,JavaTailorsetsamaximalrecursiondepth
(denoted as D) as the terminating condition in Lines 2-3. If the
recursion depth exceeds D, JavaTailor directly initializes the corre-
sponding parameters as null.
Figure 5 shows a simple example to further illustrate the pro-
cessoffixingbrokenconstraintsinJavaTailor,wheretheselected
ingredient is a function call with a parameter c1of theClass1
type. To create the definition of c1, JavaTailor first needs to create
variables for the parameters of its constructor (i.e., String str
1137
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:21:07 UTC from IEEE Xplore.  Restrictions apply. ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA Yingquan Zhao, Zan Wang, Junjie Chen, Mengdi Liu, Mingyuan Wu, Yuqun Zhang, and Lingming Zhang
Algorithm 1: Constructing new definitions
Input: ùë°ùë¶ùëùùëí: the missing type, ùëëùëíùëùùë°‚Ñé: current iteration depth
Output: ùë£: newly generated variable
1Function CreateVarWithType( ùë°ùë¶ùëùùëí,ùëëùëíùëùùë°‚Ñé):
2ifùëëùëíùëùùë°‚Ñé>Dthen
3 return ùëõùë¢ùëôùëô;
4iftype( ùë°) is primitive type or String then
5 ùë£‚Üêrandomly create variable with type( ùë°);
6else
7 ùëêùë†‚Üêidentify all constructors of ùë°ùë¶ùëùùëí;
8 ifùëêùë†contains non-parameter constructor then
9 ùë£‚Üêcreate variable with non-parameter constructor;
10 else
11 ùëê‚Üêrandomly select a constructor in ùëêùë†;
12 ùë°ùë†‚Üêidentify all parameter types of ùëê;
13 foreach ùë°‚ààùë°ùë†do
14 ùëùùë°‚Üêùëùùë°‚à™CreateVarWithType (type( ùë°),ùëëùëíùëùùë°‚Ñé+1);
15 ùë£‚Üêcreate variable with ùëêandùëùùë°;
16return ùë£;
andClass2 c2 ). Since there is a Stringtype variable defined in
seed program, we reuse it at 1/circlecopyrt. However, there is no variable of
typeClass2defined in the seed program, JavaTailor needs to re-
cursively create variables of Class2and its parameters of types
intandfloatin the next recursion. Since the missing dependent
variablesof Class2areallprimitivetypes,werandomlycreatea
value for them at 2/circlecopyrtand3/circlecopyrt. Then, the variable of Class2can be
created at 4/circlecopyrtand finally create the definition of Class1 c1 at5/circlecopyrt.
After fixing those broken constraints, JavaTailor inserts the pro-
cessedingredientintothesynthesispoint.PleasenotethatJavaTai-
lorreplacesthe returninstructionswith gotoinstructionsinorder
to avoid terminating the synthesized test program prematurely.
Also, it is necessary to assign a labelfor eachgotoinstruction.
Toboosttheinteractionbetweentheingredientandtheseedpro-
gram, JavaTailor inserts the labelto the code belonging to the
seed program.
3.3 Synthesized Program Execution
After generating a new test program via synthesis, JavaTailor then
executesitandcheckswhetheritrevealsaJVMbugornot.Here,
JavaTailor adopts differential testing as the test oracle, which com-
parestheoutputsofdifferentJVMimplementations(suchasHotSpot
and OpenJ9) with regard to this test program. Since a test program
mayproducealargeamountofoutputs,whichmayincludenon-
deterministicoutputs(suchastime-relatedoutputs),itmayincur
theinaccuracywhendetermininganinconsistency.Moreover,faced
with the same exception, different JVM implementations may also
produce different stack traces, further aggravating the difficulty of
determining an inconsistency.
JavaTailorrelievesthischallengefromthefollowingthreescenar-
ios: 1) If one JVM terminates normally while another JVM crashes,
JavaTailor regards it as an inconsistency without doubts; 2) If both
JVM implementations crash during the execution of the same syn-
thesizedtest program,JavaTailor extractsthe exceptionmessagesfrom the producedstack traces by employingregular expressions
(such as identifying the lines including the keywords of Exception,
ErrorandFailure), in order to reduce the influence of different
stylesofstacktracesproducedbydifferentJVMimplementations.
Then, if the extracted exception messages are different, JavaTailor
regards it as an inconsistency. 3) If both JVM terminates normally,
the outputs are also produced by the synthesized test program. To
reducethenoiseofdetermininganinconsistency,JavaTailorfirst
filters out some non-deterministic messages by employing regular
expressions(suchasincludingthekeywordsof time,randomand
thread,andsomecommontimeformats),andthenfiltersoutthe
messagesproducedbythethird-partylibraries(suchasJUnitand
Log4J)usedbythetestprogram.Then,iftheremainingoutputsarestilldifferent,weregardsitasaninconsistency.Regardingthelatter
twoscenarios,wefurthermanuallycheckwhethertheidentified
inconsistencyisareallybugorafalsepositivebeforereportingit
to the JVM‚Äôs developers. In particular, if an inconsistency is a false
positive,we furtherdesign arule withregardto itand thenincor-
porate it in JavaTailor to further boost the accuracy of determining
an inconsistency.
Pleasenotethatifthereisnoinconsistencyidentifiedbyasynthe-
sizedtestprogram,JavaTailorputsitintothepoolofseedprograms.
In this way, it can be used as a seed program for the following syn-
thesis,andthusatestprogramcombiningmultipleingredientsfromdifferenthistoricalbug-revealingtestprogramscouldbegenerated,
which may be more helpful to reveal new JVM bugs.
4 EVALUATION
In the study, we aim to address the following research questions:
‚Ä¢RQ1: How does JavaTailor perform in detecting JVM incon-
sistencies?
‚Ä¢RQ2: Can JavaTailor achieve higher JVM coverage?
‚Ä¢RQ3: Are the ingredients extracted from historically bug-
revealingtestprogramsmoreeffectivethanexistingmuta-
tion operators for JVM testing?
‚Ä¢RQ4:CanJavaTailordetectpreviouslyunknownbugsinthe
latest JVM implementations?
4.1 Evaluation Settings
Subjects. Following the existing work [ 30], we adopted two popu-
larJVMs,i.e.,HotSpot[ 6]andOpenJ9[ 9],assubjects.Table1shows
thesubjectsusedinourstudy.WedidnotuseOpenJDK9andOpen-
JDK10 since they are no longer maintained in OpenJ9. We can find
thatforeachOpenJDKversion,weusedonerelativelyoldbuildandone latest build for each JVM. Here, to investigate the effectivenessofJavaTailorbasedonmoresignificantresultsinstatistics,weusedtheserelativelyoldJVMbuildsasthesubjectsundertestsincethey
tend to contain more bugs. We call an experiment based on therelatively old HotSpot build and the relatively old OpenJ9 build
ofoneOpenJDKversion adifferential-testingexperiment.Intotal,
we have five differential-testing experiments due to evaluating on
five OpenJDK versions. Regarding these latest JVM builds, they areusedtodeterminewhetheraninconsistencydetectedbyJavaTailor
on the relatively old builds in a differential-testing experiment is a
real one by checking whether the inconsistency has been fixed by
the latest JVM builds (more details about it will be presented in the
1138
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:21:07 UTC from IEEE Xplore.  Restrictions apply. History-Driven Test Program Synthesis for JVM Testing ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA
Table 1: Studied JVM implementations for differential testing
OpenJDK
VersionJVM
ImplementationJVM Version
build 25.0-b70
HotSpotbuild 25.292-b10
build openj9-0.8.0 OpenJDK8
OpenJ9build openj9-0.26.0
build 11+2
HotSpotbuild 11.0.11+9
build openj9-0.12.0 OpenJDK11
OpenJ9build openj9-0.26.0
build 12+33
HotSpotbuild 12.0.2+10
build openj9-0.13.0 OpenJDK12
OpenJ9build openj9-0.15.1
build 13+33
HotSpotbuild 13.0.2+8
build openj9-0.16.0 OpenJDK13
OpenJ9build openj9-0.18.0
build 14+36-1461
HotSpotbuild 14.0.2+12
build openj9-0.20.0 OpenJDK14
OpenJ9build openj9-0.21.0
part ofevaluation metrics ). In particular, we also applied JavaTailor
to test the latest JVM builds to investigate whether it can detect
previously unknown JVM bugs.
HistoricalBug-RevealingTestPrograms. Wecollectedthetest
programsrevealinghistoricalbugsfromtheHotSpottestsuite.This
isbecauseitwellintegratesthebug-revealingtestprogramsfrom
its bug repositories, and each bug-revealing test program in its test
suiteisequippedwiththecorrespondingbugdescription,which
isconvenientforustodistinguishwhetheratestprograminthe
test suite is bug-revealing or just a normal test. In particular, we
removed the test programs that can reveal bugs directly on the
subjects under test in order to clearly investigate the effectiveness
of JavaTailor. Moreover, we filtered out the test programs that
cannot run successfully in our experimental environment. Finally,
we collected 630 bug-revealing test programs in total. Based on
them,JavaTailorextractsalargenumberofingredients(i.e.,33,002),including17,716SEQingredients,8,914IFingredients,6,122LOOP
ingredients, 236 TRAP ingredients and 14 SWITCH ingredients.
Seed Programs. Wecollectedthebenchmarksthatwereusedin
the existing JVM testing study [ 30] and the test programs from
the test suites of HotSpot and OpenJ9 as seed programs. Table 2
showsthebasicinformationofourusedseedprograms.Theformer
six benchmarks are selected from the existing study [ 12], and only
one classfile (the one including mainfunction) in each of them
is used as the seed program following the study [ 30]. There are
someotherbenchmarksusedintheexistingstudy[ 12,30],butthey
cannot run successfullyin our experimental environment due to
their old/outdated versions. The fourth column shows the number
of Jimple instructions in the seed programs for each benchmark.Table 2: Benchmarks description
IDProject #size #inst #iter
P1 avrora 1 302 5000
P2 eclipse 1 2061 20000P3 pmd 1 840 10000
P4 jython 1 377 6000P5 fop 1 187 3000
P6 sunflow 1 308 4000
P7 HotSpot-tests 630 136823 3 daysP8 Openj9-tests 1616 273710 3 days
Besides,weconstructedtwointerestingscenariosbyusingthe
test programs from the test suite of HotSpot and OpenJ9 as seed
programs.First,weusedtheabove630historicallybug-revealing
test programs from HotSpot as seed programs, which is helpful to
investigatethepowerofintegratingvarioushistoricalbug-revealing
test programs. Second, we also collected the test programs from
the test suite of OpenJ9 as seed programs, which is interestingto investigatewhether the ingredientsfrom thetest programs inone JVM (i.e., HotSpot) can augment the effectiveness of the test
programsintheotherJVM(i.e.,OpenJ9).Similarly,wediscarded
the test programs that can reveal bugs on our used subjects or
cannot run successfully in our experimental environment. In total,
we obtained 1,616 test programs from the test suite of OpenJ9 as
seed programs.
Compared Approaches. In the study, we compared JavaTailor
with the state-of-the-art JVM testing approach, i.e., classming [30].
classming designs several mutation operators to minorlymodify
a seed program, aiming to alter the control- and data- flow of
theseedprogram,whichincludestheinsertionoffivekeywords:
goto,return,throw,lookupswitch ,andtableswitch .Different
from the testing process of JavaTailor (i.e., for generating each test
program, it randomly selects an ingredient and a seed program
forsynthesis), classming incorporatestheMCMC(MarkovChain
MonteCarlo)algorithmtoguidetheselectionofmutationoperators
in order to iteratively mutate a given test program for generating a
series of mutated test programs.
To further evaluate the contribution of our ingredient synthesis
method, we mitigate the difference of the testing process between
JavaTailor and classming . Specifically, we constructed a variant of
JavaTailorbyreplacingouringredientsynthesismethodwiththe
minormutationoperatorsproposedin classming ,whichiscalled
Javaming . That is, for generating each test program, Javaming
randomly selectsamutationoperatorandaseedprogram,andthen
applies the mutation operator to the seed program to produce a
newtestprogram.IfitdoesnotrevealaJVMbug,thistestprogram
will be placed into the pool of seed programs for future selections.
Implementation and Environment. We implemented JavaTai-
lor based on OpenJDK8 (a popular OpenJDK version) and Soot
(a mature program analysis tool for Java classfiles that has been
widely used in the existing work [ 30,31,41]). Regarding using
Soot in implementing JavaTailor, it definitely can be replaced with
other libraries, but we chose Soot for a fair comparison with the
state-of-the-art classming (whichis also implemented on Soot). In
JavaTailor, the maximal recursion depth (i.e., D) of constructing
1139
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:21:07 UTC from IEEE Xplore.  Restrictions apply. ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA Yingquan Zhao, Zan Wang, Junjie Chen, Mengdi Liu, Mingyuan Wu, Yuqun Zhang, and Lingming Zhang
newdefinitionsissetto5.Sincetheimplementationfor classming is
not available, we carefully re-implemented it based on the descrip-
tionintheexistingwork[ 30].Allthesettingsareconsistentwith
theexistingwork[ 30].Inparticular,weranourre-implementation
ofclassming accordingtothestudydesignofitsoriginalwork[ 30],
andindeedobtainedverysimilarresults,whichdemonstratesthe
validity of our re-implementation.
All our experiments are conducted on a sever with two dodeca-
coreCPUsIntel(R)Xeon(R)Silver4214CPU@2.20GHzand251GB
RAM, running Ubuntu 18.04.4 LTS (64 bit). The implementation
of JavaTailor and our datasets can be found at our project home-
page [7] for future usage and replication.
Evaluation Metrics. We considered three metrics to measure the
effectiveness of JavaTailor. The first one is the number of unique
inconsistencies. To answer RQ1, we applied each JVM testing ap-
proachtoeachpairofJVMbuilds(i.e.,thepairofrelativelyoldJVM
buildsofHotSpotandOpenJ9)ineachdifferential-testingexperi-
ments. During the given testing period, each approach may detect
anumberofinconsistenciesbetweeneachpairofJVMbuilds.As
presented in Section 3.3, an inconsistency may be a real bug or
a false positive, and we further ran each approach on the corre-
spondingpairofthelatestbuildsofHotSpotandOpenJ9inorder
to check whether the inconsistency still exists or not. If the incon-
sistency disappears, we regarded it as a bug and this bug has been
fixedinthelatestbuilds;Otherwise,wefurthermanuallyinvesti-
gatedittoobtaintheconclusionoftheinconsistency.Also,some
inconsistenciesmaybeduplicatedduetothesamebug,andthus
we further de-duplicated them according to the crash messages
sincemostofinconsistenciesinvolvedthecrashesofatleastone
JVM implementation in each pair in our study. We call the num-
ber of inconsistencies after de-duplication the number of unique
inconsistencies. Relying on crash messages may not achieve perfect
de-duplication, but it is the most widely-used automatic method
to identify unique failures in the existing work [ 29]. Indeed, it is a
potential threat and we will design more accurate metrics in the
future.
Since we also applied JavaTailor to test the latest JVM builds
in RQ4, we cannot use the above method to automatically deter-
minewhethereachdetectedinconsistencyisarealbugorafalse
positive. Here, we manually investigated them, and then created
andsubmittedabugreporttothecorrespondingbugrepositoryforeachpotentialbugafterourmanualinvestigation.Then,wecanob-
tainthe number of detected unknown bugs according to developers‚Äô
feedback, which is the second metric in our study.
Furthermore,wefurthermeasured thetestcoverageofJVM (that
is the third metric in our study) achieved by each approach, inorder to deeply understand the effectiveness difference between
JavaTailor and classming . Here, we measured the widely-used line
coverage, branch coverage, and function coverage, respectively.
4.2 Process
ToanswerRQ1,ineachdifferential-testingexperiment,weraneach
approachforthesametestingperiodoneachbenchmark.Forthe
formersixbenchmarks,theexistingworkproposing classming pro-
vides the number of iterations for each of them. Here, we kept the
samesettingfor classming toshowitsexpectedeffectivenessandrecordedthetestingtimespentoncompletingthecorresponding
iterationsoneachbenchmark,thenranJavaTailorforthesametest-ingtimeonthecorrespondingbenchmarkforfaircomparisonwith
classming . For the latter two benchmarks, we ran each approach
forthreedaysrespectively.Since classming isaniterativeprocess
on a seed program, it is required to set the number of iterationson each seed program in the two benchmarks. According to the
formersixbenchmarks,wecanobtainthatoneinstructionrequires
14 iterations on average. Thus, for the latter two benchmarks, after
selectingaseedprogram,wesetthenumberofiterationsonitto
14‚àóthe number of instructions of the seed program forclassming .
The testing process of each approach terminates after running for
threedaysforfaircomparison.ToanswerRQ3,weran Javaming
following the same setting of RQ1.
To answer RQ2, we tookHotSpot build 11-internal+0 for Open-
JDK11astherepresentative,fortestcoveragecollection.Therun-
ning process of each approach is consistent with the setting of
RQ1.TocollectthecoverageofHotSpot,wecompileditwiththe
flag‚Äìenable-native-coverage , and then adopts Gcov [ 4] and
Lcov [8] to collect and analyze the line coverage, branch coverage,
andfunctioncoverageachievedbyeachapproach.Inparticular,we
consider all the source code irrelevant to the underlying platforms
in HotSpot for coverage collection. In total, there are 331,978lines
of code,199,173branches, and 95,351functions.
ToanswerRQ4,weappliedJavaTailortothelatestJVMbuilds,
and ran it on each differential-testing experiment for a longer test-
ing time (i.e., five days). Since manually analyzing and reportingeach unknown bug is time-consuming, especially the process ofreducing a bug-revealing test program into a small but still bug-
revealingone,wechoseOpenJDK8andOpenJDK11astherepre-
sentatives for testing in this experiment.
4.3 Results and Analysis
4.3.1 RQ1: Effectivenessof JavaTailor. Table3 showsthe compari-
son results among JavaTailor, classming , andJavaming in terms of
the number of detected unique inconsistencies.
BycomparingJavaTailorand classming ,wefoundthatJavaTailor
is able to detect much more unique inconsistencies than classming
foreachdifferential-testingexperimentoneachbenchmark.Bytak-ingthedifferential-testingexperimentforOpenJDK8asanexample,
classming detectsunique inconsistencieson fourbenchmarksand
thetotalnumberofuniqueinconsistenciesis35,whileJavaTailor
detects unique inconsistencies on all the eight benchmarks and the
totalnumberofuniqueinconsistenciesisupto377.Theimprove-
ments ofJavaTailor over classming rangefrom 792.31%to 1742.86%
acrossallthedifferential-testingexperimentsexceptOpenJDK14
(onlyJavaTailordetectsinconsistenciesonthisversionandthuswe
cannot calculate the improvement on it) in terms of the total num-
ber of unique inconsistencies on all the benchmarks. The results
demonstratethesignificantsuperiorityofourproposedapproach
JavaTailor over the state-of-the-art approach classming .
WefurtheranalyzedthereasonwhyJavaTailorsignificantlyout-
performsthestate-of-the-artapproach classming .Thelatterfocuses
onexploringvariouscontrol-anddata-flowoftheseedprogram
based on the ingredients itself in an iterative way, which actu-
ally limitsthe spaceof constructing testprograms. Differentfrom
1140
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:21:07 UTC from IEEE Xplore.  Restrictions apply. History-Driven Test Program Synthesis for JVM Testing ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA
Table 3: JVM inconsistencies detection effectiveness comparison
IDOpenJDK8 OpenJDK11 OpenJDK12 OpenJDK13 OpenJDK14
C.M. J.T. J.M. C.M. J.T. J.M. C.M. J.T. J.M. C.M. J.T. J.M. C.M. J.T. J.M.
P 1080030030010000
P 201 4 2080020060000P 3092060010030010P 4080020120110000P 5 31 20 41 74 41 80 010 000P 622 0 0080050140010P7 4 143 7 1 122 3 2 48 3 2 30 0 0 16 0P8 26 163 10 9 92 8 10 95 8 9 70 4 0 70 0
Total 35 377 21 14 258 15 17 174 11 13 116 4 0 88 0
C.M. and J.T. are the abbreviations of classming and JavaTailor respectively6(4,)/22375$3
6:,7&+



Figure 6: Inconsistency distribution
by ingredient types
Table 4: Confirmed/Fixed unknown bugs
Bug ID JVM Affected Versions Status
Bug#12819 OpenJ9 OpenJDK 8, 11, 16 FixedBug#12992 OpenJ9 OpenJDK 8, 11, 16 FixedBug#12552 OpenJ9 OpenJDK 8, 9, 10, 11 FixedBug#12815 OpenJ9 OpenJDK 8, 11, 16 ConfirmedBug#13242 OpenJ9 OpenJDK 8, 11, 16 Confirmed
JDK-8271457 HotSpot OpenJDK 9, 11, 17 Confirmed
classming ,JavaTailorincorporatesvariousbug-revealingingredi-
entsfromhistorical testprogramstogeneratenewtest programs,
which not only can construct the test programs with diverse (even
bug-revealing) control- and data- flow but also enlarges the test
programspacetoincreasethechanceofproducingbug-revealing
testprograms. Besides,accordingto theresultson thebenchmark
of HotSpot‚Äôs test programs, JavaTailor detects much more unique
inconsistenciesthan classming ,demonstratingthatcombiningvari-
ousingredientsfromdifferenthistoricallybug-revealingtestpro-
gramsismoreeffectivethanjustindividuallyexploringeachhis-
toricallybug-revealingtestprogram.Accordingtotheresultson
the benchmark of OpenJ9‚Äôs test programs, JavaTailor also detects a
largenumberofuniqueinconsistencies,showingthatthetesting
capability of one JVM‚Äôs test suite can be augmented by another
JVM‚Äôs test suite.
We also investigated whether each type of ingredients can help
detect some unique inconsistencies, whose results are shown in
Figure 6. This figure presents the percentage of each type of ingre-
dients resulting in the detection of unique inconsistencies. Here,
we integrated the results of all the differential-testing experiments.
Wefoundthateverytypeofingredientsareabletodetectunique
inconsistencies.Inparticular,thereareasmallnumberofSWITCH
ingredientsinourdataset(i.e.,14),buttheyalsorevealedunique
inconsistencies.Thatdemonstratesthecontributionofeachtype
of ingredients. As expected, for each type of ingredients, the num-
ber of detected unique inconsistencies is strongly correlated to
the number of thetype of ingredients in our dataset.For example,
weextractedthelargestnumberofSEQingredientsandindeedit
detected the largest number of unique inconsistencies.4.3.2 RQ2: JVM‚Äôs Coverage Comparison. We compared JavaTailor
andclassming in terms of JVM‚Äôs coverage (including line cover-
age, branch coverage, and function coverage) achieved by them
respectively,inordertofurtherexplainwhyJavaTailorperforms
better than classming . Figure 7 shows the coverage comparison
results, wherethe graylines presentthe coverage achievedby the
seedprograms,andthegreenandyellowlinespresentthecover-
ageachievedbyJavaTailorand classming onthebasisoftheseed
programsrespectively.Wefoundthatregardlessoflinecoverage,
branchcoverage,orfunctioncoverage,theimprovedcoverageby
classming overtheseedprogramsisverysmalloneachbenchmark,
indicating that just altering control- and data- flow of the seed
programs based on their own ingredients is hard to bring large
JVM coverage increments. Regarding JavaTailor, its improved JVM
coverage over both classming and the seed programs is obvious
on all the benchmarks (except P7). The results demonstrate that
incorporatingmoreingredientsfromothertestprogramsintothe
seedprogramsaremorehelpfultoimproveJVMcoverage,resulting
in the detection of more unique inconsistencies than classming .
The reason for P7 is that both the ingredient pool and the seed
programs are from the same test programs in the HotSpot‚Äôs test
suite,leadingtothesmallcoverageincrements.However,wecan
observethattheimprovementintermsofbranchcoverageonP7is
larger than that in terms of line coverage and function coverage,
indicating thatcombining variousingredients from differentbug-
revealingtestprogramsfacilitatestocoveragemoreinterestingJVM
branches/paths and thus can reveal more unique inconsistencies.
4.3.3 RQ3:ComparisonbetweenJavaTailorandJavaming. Wefur-
thercomparedouringredientsynthesismethodandexistingminor
mutationoperatorsbymitigatingtheinfluenceofthetestingpro-
cessbycomparingJavaTailorand Javaming .Thecolumns‚ÄùJ.T.‚Äùand
‚ÄùJ.M.‚ÄùinTable3showthecomparisonresults.Weobtainedthesimi-
larconclusionswithRQ1,i.e.,JavaTailordetectsmuchmoreunique
inconsistencies than Javaming . The improvements of JavaTailor
overJavaming range from 1482.82% to 2800.00% across all the
differential-testingexperimentsexceptOpenJDK14(onlyJavaTailordetect inconsistencies on this version) in terms of the total numberofuniqueinconsistenciesonallthebenchmarks,demonstratingthe
significant superiority of our ingredient synthesis method over the
existingelaboratelydesignedminormutationoperators.Inaddition,classming performsbetterthan Javaming ingeneral,demonstrating
1141
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:21:07 UTC from IEEE Xplore.  Restrictions apply. ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA Yingquan Zhao, Zan Wang, Junjie Chen, Mengdi Liu, Mingyuan Wu, Yuqun Zhang, and Lingming Zhang
Figure 7: JVM code coverage comparison
 1 public static Method main: "([Ljava/lang/String;)V"
 2 stack 5 locals 6
 3 {
 4       new class  java/util/ArrayList;
 5       dup;
 6       invokespecial Method java/util/ArrayList. "<init>" :"()V";
 7       astore_0;                               // stores ArrayList
 8       ...
 9  L13: stack_frame_type full;10       aload_0;                                // loads ArrayList
11       checkcast class java/util/List; //compares String[] with List
12       ...
13  if_icmplt L13;
14       getstatic Field ≈è/System.out: "Ljava/io/PrintStream;" ;
15       ldc String "Success" ;
16       invokevirtual Method ‚Ä¶println: "(Ljava/lang/String;)V" ;
17       return;
18 }
Figure 8: OpenJ9 Bug#12819
the effectivenessof the MCMC-based testingprocess in classming .
That further motivates a promising direction of improving JavaTai-
lorthroughdesigningmoreeffectivestrategiestoguidetheprocess
of test program synthesis, which will be discussed in Section 5.
4.3.4 RQ4: Unknown Bugs detected by JavaTailor. We also applied
JavaTailortotestthelatestbuildofbothHotSpotandOpenJ9fortwo
most popular OpenJDK versions (i.e., OpenJDK8 and OpenJDK11).
During the test time of five days, JavaTailor detects 10 unknown
bugsand6havebeenconfirmedorfixedbydevelopers,whileclass-
mingandJavamingdidnotdetectanyunknownbugs.OnepossiblereasoncouldbethatclassminghasappliedagainsttheJVMsbefore,
making them immune to the classming-like approaches. Table 4
showsthedetailedinformationfortheconfirmed/fixedunknown
bugs detected by JavaTailor. In particular, all these bugs cannot be
detectedby classming andJavaming basedonourusedbenchmarks
duringthegiventestingperiod.Wethenusedoneunknownbug
as en example for further illustration.
Figure8showsanOpenJ9bug(Bug#12819[ 3])detectedbyJa-
vaTailor,whichisrepresentedbyJasm(abytecode-likeassembly
language that allows testers to reorganize bytecode order in a spe-
cific way [ 1]). In this example, Lines 14-16 corresponding to the
System.out.println("Success") statementintheseedprogram,
which should be executed and output "Success" . However, this
statementwasnotexecutedonthelatestOpenJ9(forbothOpen-
JDK8andOpenJDK11)duetoabugintheOpenJ9‚Äôsoptimizer.Lines
9-13oftheinsertedcodecontainacomplexnestedloop.Duetothe
space limit, we only showed the outermost loop. OpenJ9 optimizes
this complex loop for better execution performance. Specifically,
JVM stores the first parameter (if exists) of the staticfunction(i.e.,String[] in themainfunction at Line 1) to the local variable
table at index 0, and then this local variable is overwritten by an
ArrayList atLine7.SincetheoptimizerofOpenJ9assumesthat
the types of these parameters in the local variable table will not
change during execution, it compares String[] withListat Line
11 but actually should compare ArrayList withList. Then, the
optimizer believes that the checkcast must fail due to impossi-
ble conversion between String[] andList, and thus removes all
theinstructionsafterthe outermostloop,causingthat "Success"
cannot be outputted. The developers of OpenJ9 fixed this bug by
makingthefunction‚Äôsparametersinthelocalvariabletablebecome
changeable during the optimization process, since these types may
bechangedduringexecution.Notethat classming failedtodetect
thisbug, since1) classming cannotintroducesuch acomplicated
loop into the seed program; 2) it cannot introduce the instructions
that overwrite the local variable table into the seed program.
5 DISCUSSION
5.1 Future Work
First, as presented in Section 4.3.3, regarding classming , MCMC-
basedmutationismoreeffectivethanrandommutation,andthusit
maybehelpfultoimprovetheperformanceofJavaTailorbydesign-
ing an effective strategy for guiding synthesis. The strategy should
guidetoselectbothaningredientandaseedprogram,aswellas
thesynthesispointintheseedprogram.Second,inourstudywe
cameacrossonecommonbutinterestingtypeoffalsepositives,i.e.,
HotSpot and OpenJ9 have different implementations for the same
OpenJDK specification, but both of them believe they conform the
specification.Therootcausemaylieinthatthespecificationisabit
general. In the future, we may report such kind of inconsistencies
to OpenJDK for further understanding. Third, although we eval-uatedJavaTailoronJVMimplementations,theideaofJavaTailoris actually general. This idea could be generalized to other soft-
waretakingprogramsastestinputs,suchascompilers,symbolic
executors, and database, as long as there are a large number of test
programs revealing historical bugs that can be collected.
5.2 Threats to Validity
Theinternalthreattovaliditymainlyliesintheimplementationsof
JavaTailorand classming .Toreducethiskindofthreat,twoauthors
carefully checked all code and we implemented them based on the
mature tool Soot. Regarding the re-implementation of classming ,
1142
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:21:07 UTC from IEEE Xplore.  Restrictions apply. History-Driven Test Program Synthesis for JVM Testing ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA
we implemented it according to the description in its paper and
checked its correctness by reproducing its original evaluation.
The external threat to validity mainly lies in the benchmarks
andhistoricallybug-revealingtestprogramsusedinourstudy.In
ourstudy,weusedsixbenchmarksfromtheexistingstudy[ 30]and
constructedtwobenchmarksbasedonthetestsuitesofHotSpotand
OpenJ9.Also,wecollected630testprogramsrevealinghistorical
HotSpot‚Äôs bugs from its test suite. To further reduce this kind of
threat, we will evaluate JavaTailor on more benchmarks and the
test programs revealing other JVM‚Äôs bugs.
The construct threat to validity mainly in the randomness in-
volved in those approaches. To reduce this threat, we conducted
fivedifferential-testingexperimentsinsteadofrepeatingoneexper-imentseveraltimes.Indeed,ourresultsdemonstratethatJavaTailor
stably outperforms classming in all the five experiments.
6 RELATED WORK
Since the first work on fuzzing [ 40], various techniques have been
proposedforfuzzingsoftwaresystemsfromdifferentapplication
domains[ 13,32,49,51,52,55].Whileallsuchtechniquesarerelated
tothiswork,wemainlytalkaboutthemostcloselyrelatedworkin
the areas of JVM testing and compiler fuzzing in this section.
JVM Testing. Due to the crucial role of JVM, both industry and
academiaproposedvarioustestingtechniquestoensureJVM‚Äôsqual-
ity [11]. Besides classming andclassfuzz introduced before, Sirer
et al.[44] proposed lava, whichgenerates test programs basedon
the production grammar. Yoshikawa et al. [ 54] proposed a random
testprogramgeneratortotesttheJITcompiler.Freundetal.[ 33]
developedaspecificationtoverifybytecodeverifiersintheformof
atypesystem.Calvagnaetal.[ 15‚Äì17]usedafinitestatemachine
modelofthe JVMspecificationtoassesstheconformance ofJVM.
Hwang et al. [ 36] proposed JUSTGen, which designs a set of do-
mainspecificlanguagesandgeneratestestprogramsbyidentifying
unspecified cases from the JNI specification.
All of them except classming andclassfuzz target one compo-
nentinJVM.Differentfromthem,JavaTailorisindependentofacertain component in JVM. For example, our collected historicalbug-revealing test programs for ingredient extraction cover the
testingofawiderangeofJVMcomponents,suchasC1(clientcom-
piler), C2(server compiler) andGC (garbage collection).Different
fromclassming andclassfuzz,JavaTailorsynthesizestheingredients
extractedfrom historicalbug-revealing testprograms withaseed
programtoproducevalidnewtestprograms,andourexperimental
resultshaveshownthatJavaTailorsignificantlyoutperformsthestate-of-the-art classming . In actual, JavaTailor can be combined
with existing research, such as concurrency testing [
48,50], to
target different components in JVM.Compiler Testing.
Similar to JVM, the test inputs of compilers
are also programs [ 14,21,24], andthus we also brieflyintroduce
the related work on compiler testing [ 19,20,22,25,27,28,43]. For
example, Yang et al. [ 53] proposed Csmith, which generates C pro-
grams based on the grammar of the C language. Lidbury et al. [ 39]
proposed CLsmithonthebasisofCsmithforOpenCLcompilertest
program generation. Chen et al. [ 26]. proposed HiCOND, which
useshistoricaldatatoinferasetofbug-revealingtestconfigurations
foreffectivetestprogramgeneration.Leetal.[ 37]proposed EMI,whichgeneratesaprogramvariantequivalenttotheoriginaltest
program under the given test inputs, and then uses these program
pairstotestcompilers.BasedontheideaofEMI,researchersfur-
therproposedAthena[ 38]andHermes[ 46].Differentfromthem,
JavaTailor targets JVM testing by mining the ingredients in his-
torical bug-revealing test programs and then inserting them to a
seedprogramfortestprogramgeneration.Suchhistory-driventest
program synthesis is also novel in the area of compiler testing and
could be generalized to this area as discussed in Section 5.1.
7 CONCLUSION
Inthispaper,weproposeahistory-driventestprogramsynthesis
approach, called JavaTailor. It first tackles the challenge of extract-
ingingredientsfrombug-revealingtestprogramsbydesigningfive
types of ingredients. Then, it inserts these extracted ingredients
intoseedprograms,andautomaticallyfixesthebrokensyntactic
and semantic constraints in the ingredients in order to produce
valid synthesized programs. Finally, these synthesized programs
areusedtodifferentiallytestJVMs.Weconductedextensiveexperi-
ments on popular JVM implementations (i.e., HotSpot and OpenJ9)
toevaluatetheeffectivenessofJavaTailor.Theexperimentalresults
demonstrate that JavaTailor significantly outperforms the state-of-the-art technique. That is, JavaTailor can achieve higher JVM
code coverage and expose more unique inconsistencies. Moreover,
JavaTailor found 6 unknown bugs that have been confirmed or
fixed by developers.
ACKNOWLEDGMENT
WethankalltheICSEanonymousreviewersfortheirvaluablecom-
ments. We also thank all the JVM developers for analyzing andreplying to the bugs we reported. This work is partially fundedby the National Natural Science Foundation of China Grant No.
62002256, 61872263, and the Tianjin Intelligent Manufacturing Spe-
cial Fund Project Grant No. 20201180. This work is also partially
supported by National Science Foundation under Grant Nos. CCF-
2131943 and CCF-2141474, as well as Ant Group.
REFERENCES
[1] 2021. ASMTools. https://wiki.openjdk.java.net/display/CodeTools/asmtools.
[2] 2021. Bug-12552. https://github.com/eclipse-openj9/openj9/issues/12552.[3] 2021. Bug-12819. https://github.com/eclipse-openj9/openj9/issues/12819.[4] 2021. Gcov. https://gcc.gnu.org/onlinedocs/gcc/Gcov.html.[5]
2021. GIJ. https://web.archive.org/web/20070509055923/http://gcc.gnu.org/java.
[6] 2021. Hotspot. http://openjdk.java.net.[7] 2021. JavaTailor. https://github.com/JavaTailor/CFSynthesis[8] 2021. Lcov. http://ltp.sourceforge.net/coverage/lcov.php.[9] 2021. OpenJ9. https://www.eclipse.org/openj9.
[10] 2021. Zulu. https://www.azulsystems.com/products/core.[11]
BowenAlpern,TonNgo,Jong-DeokChoi,andManuSridharan.2000. DejaVu:
deterministic Java replay debugger for Jalape√±o Java virtual machine. In Object
Oriented Programming Systems Languages and Applications Conference. 165‚Äì166.
[12]StephenM.Blackburn,RobinGarner,ChrisHoffmann,AsjadM.Khan,KathrynS.
McKinley, Rotem Bentzur, Amer Diwan, Daniel Feinberg, Daniel Frampton,Samuel Z. Guyer, Martin Hirzel, Antony L. Hosking, Maria Jump, Han Bok
Lee, J. Eliot B. Moss, Aashish Phansalkar, Darko Stefanovic, Thomas VanDrunen,
Daniel von Dincklage, and Ben Wiedermann.2006. The DaCapo benchmarks:
java benchmarking development and analysis. In Proceedings of the 21th Annual
ACM SIGPLAN Conference on Object-Oriented Programming, Systems, Languages,
and Applications. 169‚Äì190.
[13]MarcelB√∂hme,CristianCadar,andAbhikRoychoudhury.2020. Fuzzing:Chal-
lenges and Reflections. IEEE Software (2020).
[14]AbdulazeezS.BoujarwahandKassemSaleh.1997. Compilertestcasegeneration
methods: a survey and assessment. Inf. Softw. Technol. 39, 9 (1997), 617‚Äì625.
1143
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:21:07 UTC from IEEE Xplore.  Restrictions apply. ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA Yingquan Zhao, Zan Wang, Junjie Chen, Mengdi Liu, Mingyuan Wu, Yuqun Zhang, and Lingming Zhang
[15]Andrea Calvagna, Andrea Fornaia, and Emiliano Tramontana. 2014. Combinato-
rialInteractionTestingofaJavaCardStaticVerifier.In SeventhIEEEInternational
Conference on Software Testing, Verification and Validation. 84‚Äì87.
[16]Andrea Calvagna and Emiliano Tramontana. 2013. Automated Conformance
TestingofJavaVirtualMachines.In SeventhInternationalConferenceonComplex,
Intelligent, and Software Intensive Systems. 547‚Äì552.
[17]AndreaCalvagnaandEmilianoTramontana.2013. CombinatorialValidationTest-
ingofJavaCardByteCodeVerifiers.In 2013WorkshopsonEnablingTechnologies:
Infrastructure for Collaborative Enterprises. 347‚Äì352.
[18]Felipe Canales, Geoffrey Hecht, and Alexandre Bergel. 2021. Optimization of
Java Virtual Machine Flags using Feature Model and Genetic Algorithm. In ICPE
‚Äô21: ACM/SPEC International Conference on Performance Engineering. 183‚Äì186.
[19]Junjie Chen, Yanwei Bai, Dan Hao, Yingfei Xiong, Hongyu Zhang, and Bing Xie.
2017. Learning to prioritize test programs for compiler testing. In Proceedings of
the 39th International Conference on Software Engineering. 700‚Äì711.
[20]Junjie Chen, Yanwei Bai, Dan Hao, Yingfei Xiong, Hongyu Zhang, Lu Zhang,
and Bing Xie. 2016. Test Case Prioritization for Compilers: A Text-Vector Based
Approach. In 2016 IEEE International Conference on Software Testing, Verification
and Validation. 266‚Äì277.
[21]Junjie Chen, Jiaqi Han, Peiyi Sun, Lingming Zhang, Dan Hao, and Lu Zhang.
2019. Compilerbugisolationviaeffectivewitnesstestprogramgeneration.In
ProceedingsoftheACMJointMeetingonEuropeanSoftwareEngineeringConference
and Symposium on the Foundations of Software Engineering. 223‚Äì234.
[22]Junjie Chen, Wenxiang Hu, Dan Hao, Yingfei Xiong,Hongyu Zhang, Lu Zhang,
and Bing Xie. 2016. An empirical comparison of compiler testing techniques. In
Proceedingsofthe38thInternationalConferenceonSoftwareEngineering.180‚Äì190.
[23]Junjie Chen, Haoyang Ma, and Lingming Zhang. 2020. Enhanced Compiler Bug
Isolation via Memoized Search. In 35th IEEE/ACM International Conference on
Automated Software Engineering. 78‚Äì89.
[24]JunjieChen,JibeshPatra,MichaelPradel,YingfeiXiong,HongyuZhang,Dan
Hao, and Lu Zhang. 2020. A Survey of Compiler Testing. ACM Comput. Surv. 53,
1 (2020), 4:1‚Äì4:36.
[25]Junjie Chen and Chenyao Suo. 2022. Boosting Compiler Testing via Compiler
Optimization Exploration. In TOSEM. to appear.
[26]Junjie Chen, Guancheng Wang, Dan Hao, Yingfei Xiong, Hongyu Zhang, and Lu
Zhang.2019. History-GuidedConfigurationDiversificationforCompilerTest-
Program Generation.In 34thIEEE/ACMInternationalConferenceonAutomated
Software Engineering. 305‚Äì316.
[27]Junjie Chen, Guancheng Wang, Dan Hao, Yingfei Xiong, Hongyu Zhang, LuZhang, and Bing Xie. 2021. Coverage Prediction for Accelerating Compiler
Testing.IEEE Trans. Software Eng. 47, 2 (2021), 261‚Äì278.
[28]JunjieChen,NingxinXu,PeiqiChen,andHongyuZhang.2021.EfficientCompiler
AutotuningviaBayesianOptimization.In 43rdIEEE/ACMInternationalConference
on Software Engineering. 1198‚Äì1209.
[29]Lingchao Chen, Foyzul Hassan, Xiaoyin Wang, and Lingming Zhang. 2020. Tam-
ing BehavioralBackward Incompatibilitiesvia Cross-Project Testing andAnal-
ysis.InProceedingsoftheACM/IEEE42ndInternationalConferenceonSoftware
Engineering. 112‚Äì124.
[30]Yuting Chen, Ting Su, and Zhendong Su. 2019. Deep differential testing of JVM
implementations. In Proceedings of the 41st International Conference on Software
Engineering. 1257‚Äì1268.
[31]Yuting Chen, Ting Su, Chengnian Sun, Zhendong Su, and Jianjun Zhao. 2016.Coverage-directed differential testing of JVM implementations. In 37th ACM
SIGPLAN Conference on Programming Language Design and Implementation. 85‚Äì
99.
[32]Jaeseung Choi, Kangsu Kim, Daejin Lee, and Sang Kil Cha. 2021. NTFUZZ:
Enabling Type-Aware Kernel Fuzzing on Windows with Static Binary Analysis.
(2021).
[33]Stephen N. Freund and John C. Mitchell. 2003. A Type System for the Java
Bytecode Language and Verifier. J. Autom. Reason. 30, 3-4 (2003), 271‚Äì321.
[34]VincenzoGervasi andRoozbehFarahbod. 2009. JASMine: AccessingJavaCode
fromCoreASM.In RigorousMethodsforSoftwareConstructionandAnalysis,Essays
DedicatedtoEgonB√∂rgerontheOccasionofHis60thBirthday,Vol.5115.170‚Äì186.
[35]Matthias Grimmer, Manuel Rigger, Roland Schatz, Lukas Stadler, and Hanspeter
M√∂ssenb√∂ck. 2014. TruffleC: dynamic execution of C on a Java virtual machine.
In2014 International Conference on Principles and Practices of Programming on
the Java Platform Virtual Machines, Languages and Tools. 17‚Äì26.[36]SungjaeHwang,SunghoLee,JihoonKim,andSukyoungRyu.2021. JUSTGen:Ef-fectiveTestGenerationforUnspecifiedJNIBehaviorsonJVMs.In 43rdIEEE/ACM
International Conference on Software Engineering. 1708‚Äì1718.
[37]Vu Le, Mehrdad Afshari, and Zhendong Su. 2014. Compiler validation via equiv-
alencemoduloinputs.In ACMSIGPLANConferenceonProgrammingLanguage
Design and Implementation. 216‚Äì226.
[38]Vu Le, Chengnian Sun, and Zhendong Su. 2015. Finding deep compiler bugs via
guidedstochasticprogrammutation.In Proceedingsofthe2015ACMSIGPLAN
InternationalConferenceonObject-OrientedProgramming,Systems,Languages,
and Applications. 386‚Äì399.
[39]ChristopherLidbury,AndreiLascu,NathanChong,andAlastairF.Donaldson.
2015. Many-core compiler fuzzing. In Proceedings of the 36th ACM SIGPLAN
Conference on Programming Language Design and Implementation. 65‚Äì76.
[40]Barton P Miller, Louis Fredriksen, and Bryan So. 1990. An empirical study of the
reliability of UNIX utilities. Commun. ACM 33, 12 (1990), 32‚Äì44.
[41]Mayur Naik, Chang-Seo Park, Koushik Sen, and David Gay. 2009. Effective
staticdeadlockdetection.In 31stInternationalConferenceonSoftwareEngineering .
386‚Äì396.
[42]Manuel Rigger, Matthias Grimmer, Christian Wimmer, Thomas W√ºrthinger, and
Hanspeter M√∂ssenb√∂ck. 2016. Bringing low-level languages to the JVM: efficient
executionofLLVMIRonTruffle.In Proceedingsofthe8thInternationalWorkshop
on Virtual Machines and Intermediate Languages. 6‚Äì15.
[43]Qingchao Shen, Haoyang Ma, Junjie Chen, Yongqiang Tian, Shing-Chi Cheung,
and Xiang Chen. 2021. A comprehensive study of deep learning compilerbugs.
In29th ACM Joint European Software Engineering Conference and Symposium on
theFoundationsofSoftwareEngineering,DiomidisSpinellis,GeorgiosGousios,
Marsha Chechik, and Massimiliano Di Penta (Eds.). 968‚Äì980.
[44]Emin G√ºn Sirer and Brian N. Bershad. 1999. Using production grammars insoftware testing. In Proceedings of the Second Conference on Domain-Specific
Languages. 1‚Äì13.
[45]James E. Smith and Ravi Nair. 2005. Virtual machines - versatile platforms for
systems and processes. Elsevier.
[46]ChengnianSun,VuLe,andZhendongSu.2016. Findingcompilerbugsvialive
code mutation. In Proceedings of the 2016 ACM SIGPLAN International Conference
onObject-OrientedProgramming,Systems,Languages,andApplications .849‚Äì863.
[47]Raja Vall√©e-Rai, Phong Co, Etienne Gagnon, Laurie J. Hendren, Patrick Lam, and
Vijay Sundaresan. 1999. Soot - a Java bytecode optimization framework. In Pro-
ceedings of the 1999 conference of the Centre for Advanced Studies on Collaborative
Research. 13.
[48]Haichi Wang, Zan Wang, Jun Sun, Shuang Liu, Ayesha Sadiq, and Yuan-Fang Li.
2020. Towards Generating Thread-Safe Classes Automatically. In 35th IEEE/ACM
International Conference on Automated Software Engineering. 943‚Äì955.
[49]ZanWang, MingYan,Junjie Chen,ShuangLiu,and DongdiZhang.2020. Deep
learning library testing via effective model generation. In 28th ACM Joint Eu-
ropean Software Engineering Conference and Symposium on the Foundations of
SoftwareEngineering,PremDevanbu,MyraB.Cohen,andThomasZimmermann
(Eds.). 788‚Äì799.
[50]ZanWang,YingquanZhao,ShuangLiu,JunSun,XiangChen,andHuaruiLin.
2019. MAP-Coverage: A Novel Coverage Criterion for Testing Thread-Safe
Classes. In 34th IEEE/ACM International Conference on Automated Software Engi-
neering. 722‚Äì734.
[51]Anjiang Wei, Yinlin Deng, Chenyuan Yang, and Lingming Zhang. 2022. Free
LunchforTesting:FuzzingDeep-LearningLibrariesfromOpenSource.In 2022
IEEE/ACM 44th International Conference on Software Engineering (ICSE).
[52]Ming Yan, Junjie Chen, Xiangyu Zhang, Lin Tan, Gan Wang, and Zan Wang.
2021. Exposing numerical bugs in deep learning via gradient back-propagation.
InESEC/FSE‚Äô21: 29thACM JointEuropean SoftwareEngineeringConference and
Symposium on the Foundations of Software Engineering. 627‚Äì638.
[53]XuejunYang,YangChen,EricEide,andJohnRegehr.2011. Findingandunder-
standingbugsinCcompilers.In Proceedingsofthe32ndACMSIGPLANConference
on Programming Language Design and Implementation. 283‚Äì294.
[54]Takahide Yoshikawa, Kouya Shimura, and Toshihiro Ozawa. 2003. Random Pro-
gramGeneratorforJavaJITCompilerTestSystem.In 3rdInternationalConference
on Quality Software. 20.
[55]MengshiZhang,YuqunZhang,LingmingZhang,CongLiu,andSarfrazKhurshid.2018. Deeproad:Gan-basedmetamorphictestingandinputvalidationframeworkforautonomousdrivingsystems.In 201833rdIEEE/ACMInternationalConference
on Automated Software Engineering (ASE). 132‚Äì142.
1144
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:21:07 UTC from IEEE Xplore.  Restrictions apply. 