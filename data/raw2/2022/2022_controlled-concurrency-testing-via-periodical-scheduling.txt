Controlled Concurrency Testing via Periodical Scheduling
Cheng Wen
CSSE, Shenzhen University
Shenzhen, ChinaMengda Heâˆ—
SCEDT, Teesside University
Tees Vally, UKBohao Wu
CSSE, Shenzhen University
Shenzhen, China
Zhiwu Xu
CSSE, Shenzhen University
Shenzhen, ChinaShengchao Qinâˆ—
Huawei Hong Kong Research Center
Hong Kong, China
ABSTRACT
Controlledconcurrencytesting(CCT)techniqueshavebeenshown
promising for concurrency bug detection. Their key insight is to
control the order in which threads get executed, and attempt to
explorethespaceofpossibleinterleavingsofaconcurrentprogramtodetectbugs.However,variouschallengesremainincurrentCCT
techniques, rendering them ineffective and ad-hoc. In this paper,
we propose a novel CCT technique Period. Unlike previous works,
Period models the execution of concurrent programs as periodical
execution,andsystematicallyexploresthespaceofpossibleinter-
leavings, where the exploration is guided by periodical scheduling
andinfluencedbypreviouslytestedinterleavings.Wehaveevalu-
atedPeriodon10real-worldCVEsand36widely-usedbenchmark
programs, and our experimental results show that Period demon-
stratessuperiorityoverotherCCTtechniquesinbotheffectiveness
and runtime overhead. Moreover, we have discovered 5 previously
unknown concurrency bugs in real-world programs.
CCS CONCEPTS
â€¢Softwareanditsengineering â†’Softwaretestinganddebug-
ging;Formalsoftwareverification ;â€¢Securityandprivacy â†’
Formal methods and theory of security.
KEYWORDS
ConcurrencyTesting,ConcurrencyBugsDetection,Multi-threaded
Programs, Systematic Testing, Stateless Model Checking
ACM Reference Format:
Cheng Wen, Mengda He, Bohao Wu, Zhiwu Xu, and Shengchao Qin. 2022.
Controlled Concurrency Testing via Periodical Scheduling. In 44th Inter-
national Conference on Software Engineering (ICSE â€™22), May 21â€“29, 2022,
Pittsburgh, PA, USA. ACM, New York, NY, USA, 13 pages. https://doi.org/10.
1145/3510003.3510178
*Corresponding authors: Shengchao Qin and Mengda He.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACMmustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
Â© 2022 Association for Computing Machinery.
ACM ISBN 978-1-4503-9221-1/22/05...$15.00
https://doi.org/10.1145/3510003.35101781 INTRODUCTION
To make the best of the computing power brought with modern
multiprocessorhardware,concurrent programmingisnow preva-
lent. However, it is difficult to ensure that a concurrent program is
bug-free, as unlike sequential programs whose behavioural nonde-
terminism mainly comes from their input. The behavior of concur-
rent programs isalso subjectto howtheir threadsinterleave, thus
leavingmoreopeningsforconcurrencybugs[ 5,6,44].Testingis
usuallyaneffectivewaytoensuresoftwarequality;howeverthe
same issue of scheduling nondeterminism renders naÃ¯ve concur-
rencytestinginsufficientinpractice[ 39,43,81].Indeed,testinga
concurrentprogramwithoutanyschedulingcontroloftencovers
onlyaportionoftheschedulespace,failingtoexploretheothersin
whichthe bugsmayreside,even iftheprogramis testedoverand
overagain.Noticethatdetectingdataraceisanotherwidelyused
solution to find concurrency bugs [ 23,26,36,71], as data races are
widely considered as a cause of concurrency bugs. But a data race
may not be sufficient or necessary to trigger a concurrency bug.
As shown in [ 15], 90% of data races are benign. And a concurrency
bug can happen in a concurrent program that is race-free [42].
Therefore, controlled concurrency testing (CCT) techniques uti-
lizingcontrolled scheduling have been intensively studied [ 4,12,26,
45,64,69]. CCT usually inserts â€œscheduling pointsâ€ in the target
program in front of some key points/steps (i.e., instructions that are
key to the programâ€™s observable behavior, such as the instructions
accessing shared memory locations or synchronization primitives)
and controls these key points from various threads to execute in
different orders. When a bug is triggered during execution, thescheduling decisions (i.e., the order in which instructions from
various threads are executed) can be logged and used to determin-
istically reproduce the buggy execution [53, 54, 77].
A key practical challenge for CCT is how to achieve controlled
scheduling. Usually, the target program is put in a serialized execu-
tion,thatis,onlyonethreadispickedtoexecuteatatime;when
the execution hits a scheduling point, the scheduler may decide to
carryonthecurrentexecutionortopickanotherthreadtoexecute
(i.e., a context switch is made). Existing works tend to enforce con-
text switches via preemptions [ 48], sleeping delay [ 39,71], or even
dynamic thread priority modifications [ 11,18,42]. However, these
scheduling techniques can have pathological interactions with the
synchronization operations in the target program. For example,introducing preemptive synchronization (e.g., preemption, lock)
mayleadtoafalsedeadlockthatwasnotoriginallyexhibitedinthetarget programs [
49], and injecting different sleeping delays before
any key point may have unpredictable results and significantly
4742022 IEEE/ACM 44th International Conference on Software Engineering (ICSE)
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 07:54:11 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Cheng Wen et al.
slowdowntheexecutions peed.Moreove r,simplyserializingthe
executionofthetargetprogram(e.g.,disallowingparallelism)could
introduceundesirablyhighoverhead.Thismotivatesustofinda
more efficient and effective solution to control scheduling.
Anotherkeychallengeis howtoeffectivelyexploretheschedule
space.Noticethatthesizeofaprogramâ€™sschedulespacegrowsexpo-
nentiallywiththenumberofschedulingpointsinitsthreads.Itisof-
ten practically infeasible to exhaustively iterate the schedule space
for real-world programs. Schedule bounding techniques [ 63,64]
are often employed. The idea behind schedule bounding is that
many real-world concurrency bugs have a small bug depth, that is,
the number of context switches needed to expose the bug [ 22,46].
Therefore, controlled scheduling techniques could bound the num-
beroftheirschedule-interferingactivitiesandtremendouslyshrink
the schedule space to (ideally) a space composed of only schedules
with context switches no more than a designated number. Existing
works explore the schedule space in either a randomized orsys-
tematicway. Randomized testing (e.g., PCT [ 11] and PPCT [ 50])
employ a randomizer to generate schedules, but they could only
provideprobabilisticguaranteesoffindingbugs.Systematictesting
(e.g.,IPB[ 48,64]andIDB[ 22,64]),alsoknownasstatelessmodel
checking [ 27], explore all possible schedules within a limited num-
ber ofpreemptions or delays,but they tendto go througha larger
schedulespacethanneeded,requiringmoreoverheadormissing
somebugs.Therefore,amoreeffectivewaytoexploretheschedule
space is still badly needed.
Inthispaper,weproposeanovelcontrolledconcurrencytesting
technique,called Period,to achievecontrolled schedulingand to
effectivelyexplorethespaceofpossibleinterleavings.InPeriod,
the execution of a concurrent program is modeled as periodical
execution, wherein context switches can be achieved via period
switchesnaturally.Thatis,Periodusesaseriesofexecutionperiodstohosttheexecutionofthetargetprogramandkeypointsassigned
to anexecution periodonly getto beexecuted whenthe previous
periodisfinished.Periodicalexecutioncanbeenforcedbydeadline
task scheduling [ 3], without any preemption or sleeping delay.
Parallelization(i.e.,concurrentexecution)canbereadilyachieved
byallocatingkeypointsfromdifferentthreadsintothesameperiod
(in our implementation,we put them in the last period).
Period employs a period-bounding technique to explore the
possibleinterleavings.Ittakesapresetperiod-numberupperbound
ğ‘ƒandaimstodetectbugswithbug-depthlessthan ğ‘ƒ.Theschedule
explorationprocessworksasfollows.Itstartswiththesmallestpos-
sible period-number 2 (i.e., for bugs with bug-depth 1). For a given
period-number ğ‘, Period explores schedules systematically in a
quasi-lexicographicalorderonthecorrespondingthreadidentifiers.
Once all schedules of the current period-number ğ‘are explored,
itincreasestheperiod-number ğ‘by1tocarryonexploring,until
eitherallpossibleschedulesareexploredortheperiod-number ğ‘
reachesthepresetbound ğ‘ƒ.Meanwhile,weexploretheschedule
space gradually, targeting at feasible interleavings. For that, weintroduce dynamic key point slice to represent the key points of
each thread that are covered by a dynamic run of the target pro-
gram. Specifically, we statically generate all possible schedules for
astartingdynamickeypointslice,whereinonlyonekeypointis
assumedto be coveredfor eachthread. Duringtheexecutions of
thegeneratedschedules,somenewdynamickeypointsliceswouldbefound,onwhichtheexplorationcontinues.Toguidetheexplo-
ration on the newly found slices, schedule prefixes are constructed
based on historical executions. In addition, allowing parallelism
enablesustohugelyreducetheschedulespacetoexploreandboost
the performance.
We have implemented Period and performed a thorough evalu-
ation of Period on 10 real-world CVEs and 36 widely-used bench-
markprograms.Forcomparison,wehaveselected6well-known
andrepresentativeCCTtechniques(i.e.,IPB[ 46],IDB[22],DFS[63],
PCT[11],Maple[ 75]andthecontrolledrandomscheduling[ 64]).
Our experimental results demonstrate that Period substantially
outperformsexistingCCTtechniquesintermsofbugfindingability
and runtime overhead. Moreover, we have discovered 5 previously
unknown concurrency bugs in real-world programs. Notice that
Period focuses mainly on bugs caused by thread interleavings, e.g.
user-specifiedassertionfailure(AF),use-after-free(UAF),double-
free (DF), null-pointer-dereference (NPD), deadlock (DL), etc.
Our main contributions are summarized as follows:
â€¢Wemodeltheexecutionofconcurrentprogramsasperiodicalex-
ecution, which uses non-preemptive synchronization to achieve
controlled scheduling and allows parallelism.
â€¢We propose a novel systematic schedule generator that works
for eachdynamic key pointsslice of aconcurrent program.The
proposed schedule generator allows parallelism and is equipped
with a feedback analyzer that uses schedule prefixes to guide
further schedule generation, hugely reducing the schedule space
needed to explore.
â€¢We have implemented Period and our experimental evaluation
confirmsthesuperiorityof PeriodoverexistingCCTtechniques.
2 OVERVIEW
In this section, we give a high level overview of Period through a
simple motivating example selected from the CVEs [20].
2.1 Motivating Example
To illustrate our technique, Fig. 1 shows an example simplified
fromCVE-2016-1972 [ 21]. Two threads ğ‘‡0,ğ‘‡1concurrentlyinvoke
thefunction once(),andaresynchronizedwiththehelpofthree
variables (i.e., lock,done,waiters). The variable lock, allocated
inthemainthread(Ln.20)andreleasedinthechildthread(Ln.15),
isusedtoprotect the criticalsection(Ln.9-13).Thevariable done
will be set to 1 once the critical section is completed (Ln. 11-12).
Threads created after a thread finishes the critical section would
returndirectly(Ln.6-7).Thevariable waitersindicatesthenumber
ofthreadswaitingtoenterthecriticalsection(Ln.8).Theexpectedbehavioristhatonlythelastthreadshouldrelease
lock(Ln.14-16).
Note that all statements except for â€œ return 0 â€œ in function once()
either access shared memory locations or contain synchronization
primitives, therefore are considered as key points.
This program demonstrates three kinds of concurrency bugs,
namely, null-pointer-dereference (NPD), use-after-free (UAF), and
double-free (DF), all of which have been detected by Period. In
moredetail,ifthe lockissettonullin ğ‘‡0atLn.16before ğ‘‡1uses
thelockatLn.9,aNPDwilloccur.AUAFcanbetriggeredatLn.9
where thread ğ‘‡0releases the lockat Ln. 15 andthread ğ‘‡1uses the
lockatLn.9.ADFcanbetriggeredatLn.15whereboththreads
475
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 07:54:11 UTC from IEEE Xplore.  Restrictions apply. Controlled Concurrency Testing via Periodical Scheduling ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
1static pthread_mutex_t *lock;
2static long waiters =0;
3static int done =0;
4
5void *once(void *){
6 if(done)
7 return 0;
8 ++waiters;
9 pthread_mutex_lock(lock);
10 // do some thing ...
11 if(!done)
12 done =1;
13 pthread_mutex_unlock(lock);
14 if(!--waiters) {
15 free(lock);
16 lock =NULL;
17 }
18}
19void main() {
20 lock =malloc(sizeof(pthread_mutex_t));
21 pthread_t T0, T1;
22 pthread_create(&T0, NULL, once, NULL );
23 pthread_create(&T1, NULL, once, NULL );
24 pthread_join(T1, NULL );
25 pthread_join(T0, NULL );
26}
Figure 1: An example simplified from CVE-2016-1972.
ğ‘‡0andğ‘‡1trytoreleasethe lock.Allthesebugsareactuallyhard
totrigger,astheyeachrequireaspecificsequenceofoperationson
variable done, waiter, and lock.
We have tested this example with several existing CCT tech-
niques. Maple [ 75] can detect NPD but misses UAF and DF, as it
heuristically steers thread scheduling to attempt to force a set of
predefinedinterleavingidioms,whichdoesnotincludetherequired
interleaving idioms of such UAF and DF in the example. PCT [ 11]
reliesonarandomizertoexploretheschedulespaceoftheexample.
The probability for finding NPD is high, but the probabilities for
finding UAF and DF are very low, which are respectively about
0.15% and 0% in our experiment. IPB [ 46] and IDB [ 22] are two
representative systematic techniques. Both IPB and IDB can detect
NPD and UAF, but miss DF, whose bug depth is 5 (i.e., requiringat least 5 context switches to expose the bug). The reason is that
theytrytoiteratetheschedulingdecisiononeachkeypoint,going
through a largeschedule space. Moreover, their bounds couldnot
faithfully reflect the context switch bounds in that they often re-
quire(potentiallyalot)morecontextswitchesthanthedepthofthe
bugs they try to expose. These results demonstrate the limitations
of current CCT techniques as shown in Â§1.
Letusnowillustrateourapproachwiththisexampleandexplain
how Period detects all three bugs.
2.2 Approach Overview
Theworkflowofourproposedcontrolledconcurrencytestingtech-
nique Period is shown in Fig. 2. It comprises three main compo-
nents:schedulegenerator (1/circlecopyrt),periodicalexecutor (2/circlecopyrt)andfeedback
analyzer (3/circlecopyrt). The schedule generator systematically generates
schedules for a dynamic key point slice of the target program and
feeds them to the periodical executor. The periodical executor con-
trolsthethreadinterleavingsofthetargetprogramthroughperiod-
icalexecution,followingtheschedulesgeneratedbytheschedule
generator.Theperiodicalexecutorisalsoresponsibleforcollecting
Figure 2: The workflow of Period.
the runtime information, such as the error information and the
activatedkeypoints.Thefeedbackanalyzermakesuseofhistoricalexecutioninformationtoguidetheschedulegeneratortoeffectively
generate legal schedules to cover more untested interleavings.
ConsideringthemotivatingexampleinFig.1,letusstartwith
the period-num 2 and the starting dynamic key point slice (DKPS)
ğ‘ 0=[ğ‘‡0:[6],ğ‘‡1:[6]], where the integers denote the line numbers
ofthestatementsinFig.1andonlythefirstkeypointisassumed
to be covered. The first step is to generate the schedules with 2
periodsforthisDKPS.Ascheduleisaseriesofexecutionperiods
andisrepresentedas {...}Â·{...}...Â·{...},where{...}represents
aperiodcontainingthekeypointsthatwouldbeexecutedinthis
period.Byassigningonethreadtoaperiod,weobtaintwoschedules:
{ğ‘‡0:6}Â·{ğ‘‡1:6}and{ğ‘‡1:6}Â·{ğ‘‡0:6}. Indeed, a scheduler is concerned
onlywiththenumberofkeypointsfromvariousthreadsandthe
ordertheyinterleavein.Sowecanomitkeypointssafelyandordertheabovetwoscheduleslexicographically:
{ğ‘‡0}Â·{ğ‘‡1}and{ğ‘‡1}Â·{ğ‘‡0}.
Inthesecondstep,guidedbytheabovetwoschedules,wewould
like to control the thread interleavings via periodical execution.Fig. 3(a) gives the execution guided by the first schedule, wherethe extra key points of thread
ğ‘‡0are put in the last period of
threadğ‘‡0(in this case, there is only one period, namely period
1, allocated for ğ‘‡0, hence all key points of ğ‘‡0are put in period
1).Byanalyzingtheruntimeinformation,weobtainanewDKPS
ğ‘ 1=[ğ‘‡0:[6,8,9,11,12,13,14,15,16],ğ‘‡1:[6]](new key points are
colored gold in Fig. 3(a)). Likewise, we obtain another different
DKPSğ‘ 2=[ğ‘‡0:[6],ğ‘‡1:[6,8,9,11,12,13,14,15,16]](seeFig.3(b))for
the second schedule.
If a DKPS obtained by an execution is previously uncovered, we
consider the DKPS as an interesting new behavior. A new DKPS
indicates there may be some other uncovered feasible schedules of
the target program. To explore these schedules, we create a new
explorationjobtohandleit.Sotwoschedulejobs1arecreatedfor
the above newly obtained DKPSs ğ‘ 1andğ‘ 2, respectively. Moreover,
to guide the target program running into the new behavior, we
introduce scheduleprefixes.Intuitively,aprefixisapartialschedule
thatcontainscontextswitchesneededtoreachanewDKPS.The
1Actually,ğ‘ 1andğ‘ 2are symmetric, to explore one of them would be sufficient. In the
following, we omit the exploration on ğ‘ 2.
476
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 07:54:11 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Cheng Wen et al.
if(done);
++waiters;
mutex_lock(lock);
if(!done)
done=1;
mutex_unlock(lock);if(!--waiters) {
free(lock);lock = NULL; }
if(done)
return 0;Period 1 Period 2
(a){ğ‘‡0}Â·{ğ‘‡1}if(done);++waiters;
mutex_lock(lock);
if(!done)
done=1;
mutex_unlock(lock);if(!--waiters) {
free(lock);lock = NULL; }
if(done)
return 0;
(b){ğ‘‡1}Â·{ğ‘‡0}if(done);
++waiters;
mutex_lock(lock);if(!done)
done=1;
mutex_unlock(lock);if(!--waiters) {
free(lock);
if(done)
return 0;
lock = NULL;
}Period 3
(c){ğ‘‡0Ã—8}Â·{ğ‘‡1}Â·{ğ‘‡0}if(done);
++waiters;
mutex_lock(lock);if(!done)
done=1;
mutex_unlock(lock);if(!--waiters) {
if(done)
return 0;
free(lock);lock = NULL;
}
(d){ğ‘‡0Ã—7}Â·{ğ‘‡1}Â·{ğ‘‡0Ã—2}if(done);
++waiters;
mutex_lock(lock);if(!done)
done=1;
mutex_unlock(lock);
if(done)
return 0;
if(!--waiters) {
free(lock);lock = NULL;
}
(e){ğ‘‡0Ã—6}Â·{ğ‘‡1}Â·{ğ‘‡0Ã—3}
if(done);
++waiters;
mutex_lock(lock);
if(!done)
if(done)
++waiters;
done=1;
mutex_unlock(lock);if(!--waiters)
mutex_lock(lock);if(!done)mutex_unlock(lock);if(!--waiters) {
free(lock);lock = NULL;
}
(f){ğ‘‡0Ã—4}Â·{ğ‘‡1}Â·{ğ‘‡0Ã—5}if(done);
if(done)++waiters;mutex_lock(lock);if(!done)
done=1;
mutex_unlock(lock);if(!--waiters) {
free(lock);lock = NULL; }
++waiters;
mutex_lock(lock);if(!done)mutex_unlock(lock);if(!--waiters) {
free(lock);lock = NULL;
}
(g){ğ‘‡0}Â·{ğ‘‡1}Â·{ğ‘‡0Ã—8}if(done);
++waiters;
mutex_lock(lock);if(!done)
if(done)
done=1;
mutex_unlock(lock);
if(!--waiters) {
++waiters;
mutex_lock(lock);if(!done)mutex_unlock(lock);if(!--waiters) {
free(lock);lock = NULL;
}
lock=NULL;free(lock);
}
(h){ğ‘‡0Ã—4}Â·{ğ‘‡1}Â·{ğ‘‡0Ã—3}Â·{ğ‘‡1Ã—7}if(done);
++waiters;
mutex_lock(lock);if(!done)
if(done)
done=1;
mutex_unlock(lock);if(!--waiters) {
free(lock);
++waiters;mutex_lock(lock);if(!done)mutex_unlock(lock);
if(!--waiters) {
free(lock);
lock = NULL;
}
lock = NULL;
}
(i){ğ‘‡0Ã—4}{ğ‘‡1}{ğ‘‡0Ã—4}{ğ‘‡1Ã—7}{ğ‘‡0}if(done);
++waiters;
mutex_lock(lock);if(!done)
if(done)
done=1;
mutex_unlock(lock);if(!--waiters) }
++waiters;mutex_lock(lock);
if(!done)
mutex_unlock(lock);if(!--waiters) {
free(lock);
free(lock);lock = NULL;
}
lock = NULL;
}
(j){ğ‘‡0Ã—4}{ğ‘‡1}{ğ‘‡0Ã—3}{ğ‘‡1Ã—6}...
Figure3:Eachsub-figureisanexecutionoftheCVE-2016-1972program,andtheircaptionsarethegeneratedscheduletheyattempttofollow.
schedule prefixes for the ğ‘ 1andğ‘ 2are respectively [ğ‘‡0](indicating
thattheğ‘‡0mustbechosentorunfirst)and [ğ‘‡1].Ingeneral,asched-
uleâ€™s prefix is in the form of {...}...Â·{...}Â·[ğ‘‡ğ‘–], where the periods
incurlybracketswillbeliterallypreservedintheexplorationjob
following this prefix. The prefixâ€™s last period in square brackets
indicates that only key points from ğ‘‡ğ‘–can be scheduled to this
period while the key pointsâ€™ number can be changed.
Afterexploringtheonly2schedulesfor ğ‘ 0theexplorationjob
forğ‘ 0is concluded. However, we still need to explore the job for
ğ‘ 1with prefix [ğ‘‡0]. We omit its less interesting 2-period schedules
and jump to the 3-period phase, where there are 8 schedules toexplore, namely
{ğ‘‡0Ã—8}Â·{ğ‘‡1}Â·{ğ‘‡0},...,a n d {ğ‘‡0}Â·{ğ‘‡1}Â·{ğ‘‡0Ã—8}.The
executionsofthefirstthreeschedulesareshowninFig.3(c),Fig.3(d)
and Fig. 3(e), respectively.
On the fifth 3-period schedule for ğ‘ 1, we find a new DKPS ğ‘ 3
(seeFig.3(f)),whichcontains7keypointsin ğ‘‡0and8keypoints
inğ‘‡1. A new exploration job will be created for ğ‘ 3associated with
the prefix {ğ‘‡0Ã—4}Â·[ğ‘‡1]needed to lead us to ğ‘ 3. Meanwhile, we con-
tinuewiththejobfor ğ‘ 1andeventuallywhenwegettoschedule
{ğ‘‡0}Â·{ğ‘‡1}Â·{ğ‘‡0Ã—8}, the NPD bug will be triggered (see Fig. 3(g)).
Now we focus on the exploration job for ğ‘ 3with the prefix
{ğ‘‡0Ã—4}Â·[ğ‘‡1].Weskiptheinconsequentialschedulesandhaveaclose
lookattheschedule {ğ‘‡0Ã—4}Â·{ğ‘‡1}Â·{ğ‘‡0Ã—3}Â·{ğ‘‡1Ã—7}(Fig.3(h)),wherea
newDKPS ğ‘ 4isdiscoveredanditsprefixis {ğ‘‡0Ã—4}Â·{ğ‘‡1}Â·[ğ‘‡0].Again,weskipsomeschedulesandconsidertheexplorationonthenewly-
found DKPS ğ‘ 4. As shown in Fig. 3(i) one of its 5-period schedules
{ğ‘‡0Ã—4}Â·{ğ‘‡1}Â·{ğ‘‡0Ã—4}Â·{ğ‘‡1Ã—7}Â·{ğ‘‡0}triggers the UAF bug. Next, we
continue the exploration on ğ‘ 4with period-number 6. By using the
schedule{ğ‘‡0Ã—4}Â·{ğ‘‡1}Â·{ğ‘‡0Ã—3}Â·{ğ‘‡1Ã—6}Â·{ğ‘‡0Ã—2}Â·{ğ‘‡1},weareableto
triggertheDFbug,asshowninFig.3(j). Thesefindingsillustrate
the effectiveness of Period.
Finally,westoptheexplorationwhenalltheobtainedDKPSsare
explored within the preset period-number bound. In this example,
theperiod-numberboundissettobe6(oranylargernumber)so
that the NPD, UAF, and DF can be found.
3 METHODOLOGY
Wehave illustratedhow Periodworkswith anexample.We shall
now present some essential technical details.
3.1 The Top-level Algorithm
Given a concurrent program ğ‘ƒğ‘Ÿğ‘œğ‘”withğ‘›threads2, we assume the
inputofthetargetprogramisgiven,sotheonlynondeterminism
in execution would be caused by thread interleaving. Differentinterleavings may lead the execution to divergent paths, that is,different parts of the program get executed/activated. Only the
interleavingsofthekeypointsareinteresting,soweabstractthe
2Weassumethenumberofactivethreads ğ‘›doesnotchangeindifferentexecutions
for simplicity, though our model allows changing number of threads.
477
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 07:54:11 UTC from IEEE Xplore.  Restrictions apply. Controlled Concurrency Testing via Periodical Scheduling ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
active parts of the program as a dynamic key point slice (DKPS
or slice for short), which is represented as a list with ğ‘›elements,
whereinthe ğ‘–thelementisalistconsistingofeveryencounteredkey
pointsinthread ğ‘‡ğ‘–â€™sexecutioninthechronologicalorder.Sincea
DKPS naturally reflects that there must be some feasible schedules
to activate it, Period aims to systematically detect all slices and
test each of them with all possible schedules.
Periodmodelstheexecutionofconcurrentprogramsasperiodi-
cal execution, wherein context switches can be achieved via periodswitchesnaturally(seeÂ§3.3formoredetail).Motivatedbythestudy
[11,44]thatshowsmanyreal-worldconcurrencybugshaveshal-
low depths, Period employs schedule bounding techniques as well
and requires the period numbers of the generated schedules to be
withinapresetbound ğ‘ƒ,targetingatallpotentialbugswithdepths
less than ğ‘ƒ.
The top-level algorithm of Period is illustrated in Alg. 1, which
takesaninstrumentedprogram ğ‘ƒğ‘Ÿğ‘œğ‘”withğ‘›threadsandapreset
period bound ğ‘ƒas input, and returns a set of bugs and their corre-
sponding schedules. Note that the target program is instrumented
so that it follows our schedules and we can collect the runtime
information.Wecreateâ€œjobsâ€forslicestobeexploredin ğ‘ƒğ‘Ÿğ‘œğ‘”,with
each job represented by a pair consisting of a DKPS and a scheduleprefix.ThescheduleprefixisusedtoleadtheexecutionofthetargetprogramtotheDKPSaspossible.Theinitialjobisdenotedasapairconsistingofthesmallestapproximationassumingthereisonlyone
activekeypointineachthreadandanemptyscheduleprefix(Ln.
2). Indeed, this smallest approximation is used to allow different
possible orders for various threads to start running. Each schedule
job is performed with the period-number from 2 (i.e., 1 context
switchtargetingatthebugdepth1)tothepresetperiodbound ğ‘ƒ
(Ln. 4-17). Specifically, for each job ğ‘—ğ‘œğ‘and each period-number
ğ‘, we fisrt generate all schedules (Ln. 6) by invoking our sched-
ulegenerator (Â§3.2).Notethataschedulerisconcernedonlywith
the number of key points from various threads and the order they
interleave. We test the target program guided by each generatedschedule (Ln. 11) via our periodical executor (Â§3.3), and log bugs
captured by our executor (Ln. 12) . Our executor also captures the
dynamic key point slice of the execution (Ln. 11). Therefore, thefeedbackanalyzer (Â§3.4)candecidewhetheranewjobshouldbe
createdtoexplorethenewlyfoundsliceornot(Ln.14).Noticethat
wemaybeunabletogenerateschedulesforsomejob(Ln.7).For
instance, if ğ‘were greater thana jobâ€™s total number of key points,
thensomeperiodswouldbeleftemptyandwasted.Inthiscase,wesay the job is finished, that is, the exploration of the corresponding
slice is done, and we remove it from ğ½ğ‘œğ‘ğ‘ (Ln. 8).
3.2 Schedule Generator
Our schedule generator focuses on scheduling key points of a slice.
To seehow our periodical schedule generatoris designed, we first
introduce the serialized scheduler which lays the foundation ofour method, and then present the key optimization that allows
concurrency in our schedules and that greatly reduces the number
of schedules needed to expose bugs. Without loss of generality, we
name the threads in a DKPS as ğ‘‡0,ğ‘‡1,...ğ‘‡ğ‘›âˆ’1, whereğ‘›=|ğ·ğ¾ğ‘ƒğ‘†|.
3.2.1 Serialized Scheduler. Periodmodelsprogramexecutionin
aseriesofexecutionperiods,thatis,aschedule,andrepresentsitAlgorithm 1: Period Systematic Concurrency Testing
Input : an instrumented program ğ‘ƒğ‘Ÿğ‘œğ‘”, number of worker threads ğ‘›,
and a bound ğ‘ƒfor the maximum periods
Output : a setğ¿ğ‘œğ‘”recording bugs and their corresponding schedules
1ğ¿ğ‘œğ‘”â†âˆ…
2ğ½ğ‘œğ‘ğ‘ â†{ ([1]Ã—ğ‘›,ğœ–)}
3ğ‘=2 // the period-number, starting from 2
4whileğ‘â‰¤ğ‘ƒdo
5foreachğ‘—ğ‘œğ‘inğ½ğ‘œğ‘ğ‘ do
/*schedule generator generates all schedules for â€˜jobâ€™
with the current period-number p */
6 ğ‘†ğ‘â„ğ‘’ğ‘‘ğ‘¢ğ‘™ğ‘’ğ‘  â†ğ‘†ğ‘â„ğ‘’ğ‘‘ğºğ‘’ğ‘› (ğ‘—ğ‘œğ‘.ğ‘‘ğ‘˜ğ‘ğ‘ ,ğ‘,ğ‘—ğ‘œğ‘.ğ‘ğ‘Ÿğ‘’ğ‘“ğ‘–ğ‘¥ )
7 ifğ‘†ğ‘â„ğ‘’ğ‘‘ğ‘¢ğ‘™ğ‘’ğ‘  =âˆ…then // the current job is done
8 ğ½ğ‘œğ‘ğ‘ â†ğ½ğ‘œğ‘ğ‘ \{ğ‘—ğ‘œğ‘} // remove it from the Jobs
9 continue
10 foreachğ‘ âˆˆğ‘†ğ‘â„ğ‘’ğ‘‘ğ‘¢ğ‘™ğ‘’ğ‘  do
11 ğ‘‘ğ‘˜ğ‘ğ‘ ,ğ¸ğ‘Ÿğ‘Ÿğ‘œğ‘Ÿğ‘  â†ğ‘…ğ‘¢ğ‘›(ğ‘ƒğ‘Ÿğ‘œğ‘”,ğ‘ )//periodical executor
/* log the bugs and the current schedule */
12 ğ¿ğ‘œğ‘”â†ğ¿ğ‘œğ‘”âˆª{(ğ‘ ,ğ‘’)|ğ‘’âˆˆğ¸ğ‘Ÿğ‘Ÿğ‘œğ‘Ÿğ‘ }
/*feedback analyzer */
13 ğ‘ğ‘Ÿğ‘’ğ‘“ğ‘–ğ‘¥ =ğºğ‘’ğ‘¡ğ‘ƒğ‘Ÿğ‘’ğ‘“ğ‘–ğ‘¥ (ğ‘ )
14 ğ½ğ‘œğ‘ğ‘ â†ğ‘ˆğ‘ğ‘‘ğ‘ğ‘¡ğ‘’(ğ½ğ‘œğ‘ğ‘ ,ğ‘‘ğ‘˜ğ‘ğ‘ ,ğ‘ğ‘Ÿğ‘’ğ‘“ğ‘–ğ‘¥ );
15ifğ½ğ‘œğ‘ğ‘  =âˆ…then // all feasible schedules explored
16 break
17ğ‘â†ğ‘+1 // to explore schedules with one more period
as{...}Â·{...}...Â·{...}, where{...}denotes an execution period
and is a multi-set that contains thread identifiers. Note that keypoints are omitted, as our scheduler is concerned only with thenumber of key points from various threads and the order they
interleave. For example, the schedule with three execution periods
{ğ‘‡0,ğ‘‡0}Â·{ğ‘‡1}Â·{ğ‘‡0}indicatesthatthread ğ‘‡0cantaketwokeysteps
inthefirstexecutionperiod;thenitis ğ‘‡1â€™sturntotakeonekeystep
in the second execution period, before ğ‘‡0takes another key step in
the last execution period. We use {ğ‘‡ğ‘¥Ã—ğ‘›}forğ‘›occurrences of ğ‘‡ğ‘¥
appearing in a period.
ForanyDKPS,wecancreateserializedschedulesbyimposing
the following rules:
â€¢Rule 1.Each period only hosts key points from the same thread.
â€¢Rule2.Keypointsintwoadjacentperiodsshouldbelongtodif-
ferent threads.
â€¢Rule 3.No execution period is left empty.
â€¢Rule 4.Threadğ‘‡ğ‘–appears exactly |ğ·ğ¾ğ‘ƒğ‘†[ğ‘–]|times in a schedule.
These rules define the space of serialized periodical schedules
fortheslice.ConsideraschedulejobonasliceDKPSwithaperiod-
numberğ‘. To iteratively generate schedules within the space of
DKPS with ğ‘, we first introduce schedule patterns: skeletons of
schedulesandrepresentedas [ğ‘‡ğ‘–ğ‘‘0]Â·[ğ‘‡ğ‘–ğ‘‘1]...Â·[ğ‘‡ğ‘–ğ‘‘ğ‘],where[ğ‘‡ğ‘–ğ‘‘ğ‘–]
denotes that only ğ‘‡ğ‘–ğ‘‘ğ‘–can be scheduled into the corresponding
period. All the possible patterns would be generated in a lexico-
graphical order on the thread identifiers. Then for each possiblepattern, we generate all schedules in order by allocating the key
points to their corresponding periods. In this way, we can system-
atically explore all schedules on DKPS with period-number ğ‘in
a quasi-lexicographical order. In the following, we illustrate our
explorationof4-periodschedulesfortheslice ğ·ğ¾ğ‘ƒğ‘†thathas3key
points in ğ‘‡0, 2 key points in ğ‘‡1and 1 key point in ğ‘‡2.
478
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 07:54:11 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Cheng Wen et al.
Thread Ü¶à¬´ Thread Ü¶à¬µThread Ü¶à¬¶ThreadÜ¶à¬·â€¦  Thread Ü¶9
a = 1;
if ((! (a==0 && b==0) 
|| (a == 1 && b == -1))
assert(0);
b = -1; a = 1; a = 1; a = 1;
b = - b = 1; -1; b = -1;
Figure 4: A buggy interleaving of program reorder_10_bad.
Firstly,letusconsiderthefirstpossiblepattern,wetake ğ‘‡0for
the first period. Due to Rule 2, we could not use ğ‘‡0again for the
second period. By lexicographical order, we take ğ‘‡1for the second
period and then ğ‘‡0again for the third period. For the last period,
wenotice ğ‘‡1isthesmallestcandidate.Buttaking ğ‘‡1wouldmake ğ‘‡2
leftunscheduled,violatingRule4.Sowehavetotake ğ‘‡2forthelast
period,yieldingthefirstpattern [ğ‘‡0]Â·[ğ‘‡1]Â·[ğ‘‡0]Â·[ğ‘‡2].Byreplacing
some period with a (next) larger one and reinitializing the periods
after it,we can constructthe other patternsin order. Forexample,
the next pattern after the first one would be [ğ‘‡0]Â·[ğ‘‡1]Â·[ğ‘‡2]Â·[ğ‘‡0].
Oncethepatternsaredecided,wecanthenallocatethekeypoints
totheircorrespondingperiods.Firstofall,byRule3,weputonekey
point into each period. We only need to arrange the remaining key
points,whichmighthavedifferentways.Taking [ğ‘‡0]Â·[ğ‘‡1]Â·[ğ‘‡0]Â·[ğ‘‡2]
forexample,theremaining ğ‘‡1canonlybeputinthesecondperiod,
while the ğ‘‡0could be put in either the first or the third period,
yielding two different schedules {ğ‘‡0}Â·{ğ‘‡1Ã—2}Â·{ğ‘‡0Ã—2}Â·{ğ‘‡2}and
{ğ‘‡0Ã—2}Â·{ğ‘‡1Ã—2}Â·{ğ‘‡0}Â·{ğ‘‡2}.Likewise,wecangenerateallschedules
inorderforagivenpatternbyexploringallpossiblewaystoarrange
the key points.
3.2.2 The Parallel Scheduler. Althoughitsystematicallyexplores
theschedulespaceofaslice,ourserializedschedulercouldbecostly
forsliceswithmanythreads.Intheworstcasescenario,toexposea
ğ‘‘-depth bug in an ğ‘›-thread slice DKPS, we will have to explore the
serializedschedulespacewith ğ‘‘+ğ‘›âˆ’1periods.Wecanalsoestimate
the size of the space as (ğ‘›Ã—ğ‘˜)ğ‘‘+ğ‘›âˆ’1, whereğ‘˜is the maximum
number of key points in a thread in DKPS. Apparently, it couldbe too huge if
ğ‘›is big. For instance, the program in Fig. 4 takes
2 context switches between ğ‘‡0and any another thread to trigger
the assertion error. But our serialized scheduler has to generate
scheduleswith11periodsduetoRule1andisunabletotriggerthis
error within 10,000 schedules (see Table 2).
In our definitive scheduler (which is termed as â€œthe parallel
schedulerâ€),weaddressthisproblemelegantlybyallowingsome
threadstobeexecuted inparallel.Specifically,ata timewepicka
setofthreadsundersurveillance.Weonlyserializetheseâ€œchosenâ€
threadssowecancheckhowtheyinteract.Alltheotherthreadsare neglected for now and left to run freely in the last period.
Forinstance,assuming ğ‘‡0andğ‘‡1arechosen,a3-periodschedule
{ğ‘‡1}Â·{ğ‘‡0}Â·{ğ‘‡1,ğ‘‡2,...,ğ‘‡10}is able to trigger the assertion error in
Fig. 4. So to allow parallelism, we loosen Rule 1:
â€¢Rule1â€™.Eachperiod(apartfromthelastone)onlyhostskeypoints
from the same thread.
Note that we do not impose any controls over the threads sched-
uled in the last period, but for consistency, we write them in the
lexicographical order.Itispossiblethatsomebugsmaybeintheneglectedthreads.This
isnotan issueaswesystematically(following thelexicographical
order) choose threads and would eventually reveal bugs caused by
anythreadcombination.Particularly,whenproducingthe ğ‘-period
schedules, we choose all 2 to ğ‘šğ‘–ğ‘›(ğ‘,ğ‘›)-thread combinations. For
every thread combination, using only the chosen threads and their
keypoints,wefirstgenerateserializedschedulesasthemid-product,
andthenforeverysuchserializedscheduleweaddtheneglected
key points in its last period to produce a complete schedule.
Allowingparallelismputseveryperiodinusetocreatemeaning-
ful contextswitches.With theparallel schedulerfor any ğ‘›-thread
program/slice ( ğ‘›â‰¥2), no matter how big ğ‘›is, we can always start
with period-number 2 (instead of ğ‘›), and can trigger a ğ‘‘-depth bug
withnomorethan ğ‘‘+1periods(insteadof ğ‘‘+ğ‘›âˆ’1intheworst
case).
Thisprocesscanbefurtherguidedbyaschedule prefix(seeÂ§3.4).
Aprefixisintheform {ğ‘‡ğ‘–ğ‘‘0Ã—ğ‘›0}...Â·{ğ‘‡ğ‘–ğ‘‘ğ‘–Ã—ğ‘›ğ‘–}Â·[ğ‘‡ğ‘–ğ‘‘ğ‘–+1]...Â·[ğ‘‡ğ‘–ğ‘‘ğ‘—].
We say a schedule satisfies such a prefix if its first ğ‘–periods are
exactlythesameastheprefixâ€™sfirst ğ‘–periodsanditsnext ğ‘—periods
havethesamepatternasthatisgivenintheprefix.Ourschedule
generator function SchedGen (ğ·ğ¾ğ‘ƒğ‘†,ğ‘, pfx)generates all ğ‘-period
schedules for a slice DKPS satisfying the prefix pfx.
3.3 Periodical Executor
After schedule generation, we would like to enforce the schedules
intheexecutionsofthetargetprogram.Specially,weuseaseriesofexecutionperiodstohosttheexecutions,called periodicalexecution,
and impose the following rules: ( ğ‘–) key points assigned to a period
only get to be executed when the previous period is completed; ( ğ‘–ğ‘–)
eachperiodhasalifetime,whichshouldbelongenoughtocover
the key points hosted in any period assuming they are executable;
and (ğ‘–ğ‘–ğ‘–) a period is completed if the lifetime is over.
WeimplementtheperiodicalexecutorbasedonLinuxâ€™sdeadline
task scheduling [ 3], which isoriginally designed for real-time sys-
tems thatneed tasksto be done periodically. For our purpose,we
adapt deadline task scheduling for our use by putting all threads
under the deadline tasking scheduling with the same period length
andstarttime;sotheexecutionperiodsforallthreadsarealways
synchronized and can be used to fulfill our period based controlled
execution.Wealsoinstrumentthetargetprogramwithascheduling
point in front of every key points.
Fig.5givestheperiodicalexecutionfortheschedule {ğ‘‡1}Â·{ğ‘‡0}Â·
{ğ‘‡1,ğ‘‡2,...,ğ‘‡10}, where sched_yield() is triggered at the sched-
uling point to hang the current threadâ€™s execution until the next
period.Let Run(ğ‘ƒ,ğ‘ )denotetheperiodicalexecutionofthetarget
programğ‘ƒguided by a periodical schedule ğ‘ .
Ourperiodicalexecutorisalsoresponsibleforcollectinginfor-
mationfromtheexecution:( ğ‘–)theerrorinformation ğ¸ğ‘Ÿğ‘Ÿğ‘œğ‘Ÿğ‘ ,fr om
which we can know if a bug is triggered, and ( ğ‘–ğ‘–) the activated
sliceDKPS,whichisfedtoourfeedbackanalyzer(Â§3.4)todecide
whether a new schedule job should be created. In other words, our
periodical executor returns a pair (ğ·ğ¾ğ‘ƒğ‘†,ğ¸ğ‘Ÿğ‘Ÿğ‘œğ‘Ÿğ‘  ). Note that, the
slicenewlyactivatedbyaschedulemaynotbethesametotheone
that generates the schedule. This is due to the fact that differentinterleavings may cause conditional key points to take different
branches.Forinstance,theschedulesshowninFig.3(e)andFig.3(f)
479
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 07:54:11 UTC from IEEE Xplore.  Restrictions apply. Controlled Concurrency Testing via Periodical Scheduling ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
CM@<?Â»CM@<?Â¼CM@<?Â¼Â»
ÃÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÃÃÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÃÃÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÃÂšN>C@?Â­TD@G?ÂŸÂ ÂšÂšF@TKJDIOÂ¼Â‰Â»ÂšÂšN>C@?Â­TD@G?ÂŸÂ ÂšK@MDJ?Â¼ÂšÂšÂšN>C@?Â­TD@G?ÂŸÂ ÂšÂšÂšÂšÂšÂšÂšÂšÂšÃÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÃÃÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÃÃÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÃÂšF@TKJDIOÂ»Â‰Â»ÂšÂšN>C@?Â­TD@G?ÂŸÂ ÂšÂšN>C@?Â­TD@G?ÂŸÂ ÂšK@MDJ?Â½ÂšÂšÂšÂšÂ‰Â‰Â‰ÂšÂšÂšÂšÂšÂšÂšÂšÃÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÃÃÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÃÃÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÃÂšÂšÂšF@TKJDIOÂ¼Â‰Â¼ÂšÂšF@TKJDIOÂ¼Â»Â‰Â»ÂšK@MDJ?Â¾ÂšÂšÂšÂšÂšF@TKJDIOÂ¼Â»Â‰Â¼ÂšÂšÂšÂšÂšÂšÂšÃÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÃÃÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÃÃÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÂŠÃ
Figure 5: The execution of {ğ‘‡1}Â·{ğ‘‡0}Â·{ğ‘‡1,ğ‘‡2,...,ğ‘‡10}
aregeneratedfrom thesameDKPS,but theycauseâ€œ if(done) â€in
threadğ‘‡1to take different branches, yielding two different DKPSs.
3.4 Feedback Analyzer
As explained in Â§3.3, the newly activated slice may be different
from the original one. Our feedback analyzer can handle this situa-
tion. For that, we introduce the supported relation between DKPSs:
ğ·ğ¾ğ‘ƒğ‘†1issupported byğ·ğ¾ğ‘ƒğ‘†2if the number of key points for
each thread in ğ·ğ¾ğ‘ƒğ‘†1is not larger than the corresponding one
inğ·ğ¾ğ‘ƒğ‘†2. From the periodical executorâ€™s point of view, ğ·ğ¾ğ‘ƒğ‘†1
is supported by ğ·ğ¾ğ‘ƒğ‘†2, indicates that the schedules generated by
ğ·ğ¾ğ‘ƒğ‘†2provide enough â€œspaceâ€ of periods to hold their key points
fromğ·ğ¾ğ‘ƒğ‘†1for each thread. Considering the motivating example,
theğ‘ 4is supported by the ğ‘ 3, just skipping unneeded key points or
periods.
When a previously uncovered slice DKPS is discovered, our
feedback analyzer first checks if it is supported by the original one.
If not, we will consider to create a new job for it. To guide the
exploration on DKPS, we make full use of the history execution
information. We compare the current schedule with its immediate
previous schedule3and locate the first different key point; let us
say it is a key point from ğ‘‡ğ‘–. We can assume the difference here
leads us to the new slice, so we construct a schedule prefix bykeeping everything before it literally, and then adding a pattern
period[ğ‘‡ğ‘–].Forinstance,theschedule {ğ‘‡0Ã—4}Â·{ğ‘‡1}Â·{ğ‘‡0Ã—5}inthe
motivating example (Fig. 3(f)) gives us a new slice. To calculateits prefix, we compare it with its immediate previous schedule,
{ğ‘‡0Ã—5}Â·{ğ‘‡1}Â·{ğ‘‡0Ã—4},andlocatethefirstdifferentkeypoint,which
isthefifthkeypoint ğ‘‡1ofthescheduleinFig.3(f),whereitsprevious
schedule has ğ‘‡0.S ow ek ee pt h e {ğ‘‡0Ã—4}before this key point and
connectitwitha [ğ‘‡1]togettheprefix: {ğ‘‡0Ã—4}Â·[ğ‘‡1].Notethatthere
mayalreadyexistajobonthissliceDKPS.Ifso,weupdatetheprefix
of the existingjob as the common prefixof the newly constructed
one and the original one. Otherwise, a new job consisting of DKPS
andthenewlyconstructedprefixiscreatedandputintothejoblist
ğ½ğ‘œğ‘ğ‘ . The procedure is denoted as Update(ğ½ğ‘œğ‘ğ‘ ,ğ·ğ¾ğ‘ƒğ‘†,ğ‘ğ‘Ÿğ‘’ğ‘“ğ‘–ğ‘¥ ).
Intuitively, one could explore the schedule space on the slice
containingallthekeypointsofthetargetprograminstead.How-
ever,thisspacecouldbetoohugeandsuffersfromlotsofuseless
schedules.Consideringthemotivatingexampleagain,anyschedule
satisfyingthatatleast5keypointsfromthread ğ‘‡0havebeenexe-
cutedpriortotheexecutionofthefirstkeypointofthread ğ‘‡1would
make thread ğ‘‡1return directly. There are too many such schedules
3Ifitisthefirstscheduleinourexploration,wesayitsimmediatepreviousscheduleis
an empty schedule {}.but only one is sufficient. Moreover, during our exploration, thenumber of generated schedules grows rapidly, as the size of theslice increases. Thanks to the schedule prefix again, it helps us
significantly reducing the schedule space via avoiding some dupli-
catedschedules.Asinthemotivatingexample,whenexploring ğ‘ 3
weusetheprefix {ğ‘‡0Ã—4}Â·[ğ‘‡1]whichwillguidetheexecutionto
ğ‘ 3. Without prefix, schedules like {ğ‘‡0Ã—5}...would be allowed
leading the execution back to ğ‘ 1instead of ğ‘ 3(Fig.3(c)-3(e)). Finally,
concerningthecompleteness,sinceourschedulersystematically
exploresallschedulesonallinterestingDKPSswithperiod-number
from 2 to ğ‘ƒ, we argue that most of the possible interleavings of
various threads bounded by ğ‘ƒcontext switches will be touched by
Period.AsillustratedinFig.3,allthebranchesofthreeconditional
statementscanbecoveredandeachconditionalstatementcanbe
shuffled in any possible position if period-number ğ‘is enough.
4 EVALUATION
WehavebuiltaprototypeforPeriodupontheLLVMframework[ 37],
SVF[62]andSCHED_DEADLINE [9].Inparticular,theperiodical
executor and the feedback analyzer rely on instrumentation based
on the LLVM framework. We have implemented a static analy-
siscomponent,whichstaticallyidentifiedkeypointsofthegiven
concurrentprogram,ontopofSVF[ 62].Theunderlyingimplemen-
tation of the periodical execution uses the existing CPU scheduler
SCHED_DEADLINE available in the Linux kernel, as the implemen-
tation vehicle.
WehaveconductedthoroughexperimentstoevaluatePeriod
withasetofwidely-usedbenchmarks,andcompareditwithvarious
existingtechniques. Withtheseexperiments, weaimto answerthe
following research questions:
RQ1.How capable is our proposed parallel scheduler in reducing
the schedule space, compared to the serialized scheduler?
RQ2.HowcapableisPeriodintermsoffindingconcurrencybugs,
compared to other techniques?
RQ3.What runtime overhead is incurred by Period?
4.1 Evaluation Setup
4.1.1 Benchmark Programs. ToevaluatePeriod,wemakeuseof
asetofwidely-usedbenchmarksandreal-worldCVEs,writtenin
C/C++ for the Linux/Pthreads platform, including 36 programsfrom SCTBench [
1] and all 10 programs from the CVE bench-
mark [2]. The CVE benchmark contains 10 programs that have
various concurrency bugs, and each program corresponds to a
real-world CVE. The SCTBench collects 52 concurrency bugs from
previousparallelworkloads[ 10,70]andconcurrencytesting/verifi-
cation works [ 19,48,73,74]. Note that we exclude 16 programs in
SCTBench as 5 of them fail to compile on the LLVM platform and
the bugs in the other 11 programs can be exposed 100% of the time.
4.1.2 Baselines. Weusedexistingimplementationsofcompared
baselines when available. Based on the category of CCT tech-
niques, we select 3 systematic CCT techniques: IPB[ 46], IDB [22],
and DFS [ 64], and 3 non-systematic CCT techniques: PCT [ 11],
Maple[75]andacontrolled random scheduler(Random)thatran-
domlychoosesathreadtoexecuteatatime.Forcomparison,we
480
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 07:54:11 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Cheng Wen et al.
Table 1: Descriptive statistics and detection results on CVE benchmark
Systematic Testing Non-systematic TestingCon. Bug
DetectorData Race
Detector
Period/ Serial IPB IDB DFS Native PCT Random Maple
Bug ID ProgramsBug
TypeBug
Depth
schedules to bug (1st)
schedules
buggy schedules
schedules to bug (1st)
schedules
buggy schedules
schedules to bug (1st)
schedules
buggy schedules
schedules to bug (1st)
schedules
buggy schedules
runs to 1st bug
buggy runs
schedules to bug (1st)
buggy schedules
schedules to bug (1st)
buggy schedules
founds?
schedules
ConVul
UFO / UFO NPD
FastTrack
Helgrind
TSAN
CVE-2009-3547 Linux-2.6.32-rc6 NPD 1 26 3 33 65 53 34 41 01 249 3 5 3333 8 2506 /enc-3330/enc-33/enc-33/enc-33/enc-33/enc-33
CVE-2011-2183 Linux-2.6.39-3 NPD 2 3 906 130 89 81 1 68 59 53 13 681 10 5 394 8 3745 /enc-3360/enc-37/enc-37/enc-37/enc-37/enc-37
CVE-2013-1792 Linux-2.8.3 NPD 2 13 179 6 15 321 18 22 260 14 15 88 5 /enc-37061 124 8 741 /enc-33165/enc-33/enc-37/enc-37/enc-37/enc-37
CVE-2015-7550 Linux-4.3.4 NPD 2 31 4 6 87 31 1 66 49 52 23 /enc-3703 394 1 3745 /enc-33160/enc-33/enc-33/enc-37/enc-37/enc-37
NPD 2 32 0 16 881 11 472 228 90 /enc-3703 731 55 430 /enc-33 /enc-37/enc-37/enc-37/enc-37(/triangle)/enc-37(/triangle)
UAF 4 159 11 91 918 66 663 229 337 /enc-370134 15 1 1539 /enc-37 /enc-33/enc-37/enc-37/enc-37(/triangle)/enc-37(/triangle) CVE-2016-1972 Firefox-45.0
DF 5 447573
1/enc-37L
0/enc-376176
0/enc-37L
0/enc-370/enc-370/enc-370/enc-37144
/enc-37/enc-37/enc-37/enc-37(/triangle)/enc-37(/triangle)
NPD 2 52 /enc-37 0/enc-37 0/enc-37 01415 3 /enc-370/enc-370/enc-33 /enc-37/enc-37/enc-37/enc-37/enc-37
CVE-2016-1973 Firefox-45.0UAF 3 17315/enc-37L0/enc-37L0/enc-37L0/enc-370/enc-370/enc-370/enc-37157/enc-33/enc-37/enc-37/enc-37/enc-37
CVE-2016-7911 Linux-4.6.6 NPD 2 31 9 8 8 204 66 6 170 54 55 82 1 799 15 5 511 5 3733 /enc-33143/enc-33/enc-37/enc-37(/triangle)/enc-37(/triangle)/enc-37(/triangle)
CVE-2016-9806 Linux-4.6.3 DF 2 64 2 4 9 226 84 7 193 65 67 12 8 /enc-3703 1135 1 2353 /enc-3336/enc-33-/enc-37(/triangle)/enc-37/enc-37(/triangle)
CVE-2017-15265 Linux-4.9.13 UAF 2 11 96 1 /enc-3788 0 /enc-3783 0 /enc-3731 0 /enc-370/enc-370/enc-370/enc-3373/enc-33/enc-33/enc-37/enc-37/enc-33
NPD 2 56 0 /enc-37 0/enc-37 0/enc-37 0/enc-370/enc-370/enc-370/enc-33 /enc-37/enc-37/enc-37(/triangle)/enc-37(/triangle)/enc-37(/triangle)
UAF 3 47 6 /enc-37 0/enc-37 0/enc-37 0/enc-370/enc-370/enc-370/enc-37 /enc-33/enc-37/enc-37(/triangle)/enc-37(/triangle)/enc-37(/triangle) CVE-2017-6346 Linux-4.13.8
DF 2 46182
14/enc-37L
0/enc-37L
0/enc-37L
0/enc-370/enc-37020 1625 /enc-33118
/enc-33-/enc-37(/triangle)/enc-37(/triangle)/enc-37(/triangle)
Total bugs found (Buggy Programs) 15 (10) 8 (7) 8 (7) 8 (7) 4 (3) 8 (7) 9 (7) 11 (7)10 (9)3 (3)1 (1)1 (1)2 (2)
*Allthesub-threadnumbersofprogramsare2.NPD,UAF,andDFareshortfornull-pointer-deference,use-after-free,anddouble-free,respectively.â€˜Lâ€™denotesourschedulelimit10,000isreached.â€˜ /enc-37â€™
denotes that no bug was found. "-" denotes an inapplicable case. /triangledenotes that a race detector reports a race on the related variables of the concurrency bug.
also include the version of Period equipped with our serialized
scheduler (we call this version of Period as Serial) and the native
execution (Native) wherein schedules are uncontrolled.
4.1.3 Configuration Parameters. In our experiments, the schedule
bounds for all the CCT techniques are set to check bugs with bug-
depthnomorethan5ontheCVEBenchmark(resp.3onSCTBench),
asthemaximumbug-depthforknownbugsintheCVE-benchmark
(resp. SCTbench) is 5 (resp. 3). Each invocation of a CCT technique
has a budget of exploring up to 10 ,000 schedules. For the other
non-CCTtechniques, weadoptedtheirdefault configurations.For
each compared technique, we invoke tests run for each program
10 times and collect their results. All our experiments have been
performedonaworkstationwithanIntel(R)Xeon(R)Silver4214
processor, installed with Ubuntu 18.04, GCC 7.5, LLVM 10.0.
4.2 Improvement of Parallel Scheduler (RQ1)
ThedescriptivestatisticsanddetectionresultsontheCVEbench-
mark [2] and SCTBench [ 1] are shown in Table 1 and Table 2,
respectively. Each column denotes the experimental results of atechnique. The schedules to bug (1st), schedules, and buggy sched-
ulesdenote the number of schedules that were explored up to and
including the detection of a bug for the first time, the total number
ofschedules exploredby atechnique,and thenumberof explored
schedules that exhibited the bug. These figures can demonstratehow capable and how quickly each technique finds the bugs on
these benchmark programs.
As shown in Table 1, the results for Period (which uses the par-
allel scheduler) and Serial on the CVE benchmark are exactly the
same.Thisisbecause,asdiscussedinÂ§3.2.2,theschedulespacesizes
for Serial and Period to explore on programs with ğ‘›threads and
ağ‘‘-depthbugarerespectivelyover-approximatedas (ğ‘›Ã—ğ‘˜)ğ‘›+ğ‘‘âˆ’1
and(ğ‘›Ã—ğ‘˜)ğ‘‘+1, and all the thread numbers of programs in the CVE
benchmark are 2 so that both space sizes are exactly the same.
WhiletheirresultsonSCTBencharedifferentandhighlightedinblueinTable2.Allthedifferencesareduetothethreadnumbers
arelargerthan2.Infact,whentestingprogramswithalargethread
number, Serial could require a larger schedule space than needed
to detect bugs, resulting in missing some bugs, even the ones with
depth2.While,thankstoparallelization,Periodcanalwaystrigger
ağ‘‘-depth bug with no more than ğ‘‘+1 periods. Table 2 shows that
Period reports 8 more bugs than Serial, with an improvement
about 26.67%.
Moreover, allowing parallelism greatly improves the schedule
space.Forexample,Serialgenerates30,384and5040schedulesfor
the3-threads,4-threads,and5-threadsversionsof CS.reorder_bad
(CS.reorder_3_bad, CS.reorder_4_bad andCS.reorder_5_bad ), respec-
tively.Whenthethreadnumbergrowsto10(CS.reorder_10_bad ),
Serial requires a particularly large number of schedules, which
quicklyexceedsthebudgetlimit.WhilePeriodrespectivelygen-
erates27,100, and225schedulesforthe3-threads, 4-threads,and
5-threads versions and still performs well (2350 schedules, still lots
ofremainingbudgets)onthe10-threadsversion.Thisindicatesthat,
as the thread number increases, the improvement of the parallel
schedulerwouldbemoresubstantial.Inaddition,allowingparal-
lelismalso enablesPeriodtodetect bugsmore quickly.Asshown
in Table 2, Period always requires fewer schedules to detect the
same bug for the first time, compared with Serial.
Ourparallelschedulersignificantlyimprovesserializedonein
terms of the schedule space, enabling us to detect more bugs.
4.3 Bug-finding Ability Evaluation (RQ2)
In Table 1, Period has successfully identified all 10 programs from
the CVE benchmark as buggy ones, while other CCT techniques
(i.e., IPB, IDB, DFS, PCT, Random, Maple) have identified only 7
buggy ones. Notice that the native execution ( i.e., no control on
schedules), could identify only 3 buggy programs. In terms of bugs,
481
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 07:54:11 UTC from IEEE Xplore.  Restrictions apply. Controlled Concurrency Testing via Periodical Scheduling ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
Table 2: Descriptive statistics and detection results on SctBench
Systematic Testing Non-systematic Testing
Period Serial IPB IDB DFS Native PCT Random Maple
ProgramsSub
ThreadsBug
TypeBug
Depth
schedules to bug (1st)
schedules
buggy schedules
schedules to bug (1st)
schedules
buggy schedules
schedules to bug (1st)
schedules
buggy schedules
schedules to bug (1st)
schedules
buggy schedules
schedules to bug (1st)
schedules
buggy schedules
runs to 1st bug
buggy runs
schedules to bug (1st)
buggy schedules
schedules to bug (1st)
buggy schedules
founds?
schedules
CS.account_bad 3 AF 1 26 52 6 4 136 56 37 01 3 44 36 32 84 2903 1 5 2396 8 1177 /enc-3380
CS.bluetooth_driver_bad 2 AF 2 9 205 9 9 205 9 79 29 79 29 36 177 10 /enc-370700 85 8 648 /enc-3757
CS.carter01_bad 2 DL 2 54 21 1 54 21 1 11 396 38 9 250 18 8 1708 49 555 1 3 608 1 4750 /enc-336
CS.circular_buffer_bad 2 AF 2 17 871 207 17 871 207 26 806 363 42 623 219 20 3991 2043 /enc-37011 842 1 9110 /enc-3758
CS.deadlock01_bad 2 DL 2 31 46 31 46 11 81 8 86 56 10 46 3 4353 2 38 174 1 3745 /enc-3789
CS.lazy01_bad 3 AF 1 33 91 2 46 02 0 1 208 13 18 76 2 1 118 81 2 6631 1 5128 2 6092 /enc-331
CS.queue_bad 2 AF 2 25 998 119 25 998 119 101 L 7275 106 8310 3768 43 L 6405 7993 1 6 984 1L /enc-3364
CS.reorder_10_bad 10 AF 2 27 2350 89 /enc-37L0 /enc-37L0 /enc-377406 0 /enc-37L0 /enc-37085 9 /enc-370/enc-3756
CS.reorder_20_bad 20 AF 2 39 L 2870 /enc-37L0 /enc-37L0 /enc-37L0 /enc-37L0 /enc-370891 18 /enc-370/enc-3756
CS.reorder_3_bad 3 AF 2 62 76 10 30 10 50 1192 25 33 205 6 126 2494 23 /enc-370192 54 39 237 /enc-3756
CS.reorder_4_bad 4 AF 2 9 100 12 37 384 90 393 L 31 262 518 7 6409 L 4 /enc-370164 40 68 86 /enc-3756
CS.reorder_5_bad 5 AF 2 12 225 20 283 5040 816 3587 L 3 /enc-37996 0 /enc-37L0 /enc-370355 28 68 23 /enc-3756
CS.stack_bad 2 AF 2 3 918 144 3 918 144 25 2429 318 23 1595 273 22 L 512 /enc-37015 6 3 6189 /enc-332
CS.token_ring_bad 4 AF 1 2 232 58 7 2424 401 8 503 114 15 113 13 8 280 57 /enc-37011 6 9 1293 /enc-3345
CS.twostage_100_bad 100 AF 2 690 L 141 /enc-37L0 /enc-37L0 /enc-37L0 /enc-37L0 /enc-37013453 11 /enc-370/enc-3756
CS.twostage_bad 2 AF 2 43 33 43 33 /enc-37L0 /enc-37L0 /enc-37L0 /enc-370/enc-370/enc-370/enc-338
CS.wronglock_3_bad 4 AF 2 6 172 42 26 1320 265 277 L 1227 16 1568 197 3233 L 94 7212 1 7 313 1 3197 /enc-3319
CS.wronglock_bad 8 AF 2 10 1464 210 /enc-37L0 /enc-37L0 32 L 710 /enc-37L0 /enc-37044 307 1 3286 /enc-3319
CB.aget-bug 3 AF 2 9 3279 679 12 L 1900 1 4359 2903 1 292 194 1 2847 1814 2 3341 7 3202 4 4853 /enc-331
CB.stringbuffer 2 AF 2 12 163 16 12 163 16 13 38 2 13 38 2 83 02 /enc-3703555 5 23 673 /enc-3340
BOF 2 41 14 578 27 /enc-37 0/enc-37 0/enc-37 0/enc-370/enc-370/enc-370/enc-37
NPD 2 52 41 82 427 16 36 4 1733 12 573 /enc-37062 136 1 2545 /enc-33 CB.pbzip2 4
UAF 1 531626
2483L
4982L
49023L
30532L
1267/enc-3707 2193 5 1594 /enc-3742
Chess.WSQ 3 AF 3 105 434 15 574 5175 117 4502 L 306 845 L 270 /enc-37L0 /enc-3702 1118 392 10 /enc-3349
Chess.IWSQ 3 AF 3 108 711 17 836 L 138 /enc-37L0 3554 L 192 /enc-371503 0 /enc-3705 1173 443 24 /enc-3710
BOF 3 1628 11 /enc-37 0/enc-37 0/enc-37 0/enc-37 0/enc-370/enc-370/enc-370/enc-37Chess.SWSQ 3AF 3 1630L13/enc-37L0284L1222L1/enc-37L0/enc-37068 257 17 1078 /enc-3760
BOF 3 1661 11 /enc-37 0/enc-37 0/enc-37 0/enc-37 0/enc-370/enc-370/enc-370/enc-37Chess.IWSQWS 3AF 3 1663L13/enc-37L0284L1222L1/enc-37L0/enc-37068 261 3 1918 /enc-3770
Inspect.qsort_mt 3 AF 2 27 8643 135 30 L 96 33 L 365 20 3882 158 /enc-37L0 /enc-37044 194 72 100 /enc-37115
Inspect.boundedbuffer 4 AF 2 20 L 1514 39 L 1382 /enc-37L0 608 L 103 /enc-37L0 15 294 27 109 8 2808 /enc-37158
Misc.safestack 3 AF - /enc-376519 0 /enc-37L0 /enc-37L0 /enc-37L0 /enc-37L0 /enc-370/enc-370/enc-370/enc-3759
Splash2.barnes 2 AF 1 2 L 1186 2 L 1186 3 L 1006 3 L 741 2 L 2202 7 1251 2 5013 2 4893 /enc-331
Splash2.fft 2 AF 1 2 L 3963 2 L 3963 3 L 9221 3 L 9221 2 L 7210 1 6862 2 5047 2 6241 /enc-332
Splash2.lu 2 AF 1 2 6129 2848 2 6129 2848 3 L 6900 3 L 6900 2 L 5560 12 2177 2 5724 2 9714 /enc-334
RADBench.bug2 2 AF 3 1985 L 9 1985 L 9 /enc-37L0 /enc-37L0 /enc-37L0 /enc-3701813 10 /enc-370/enc-37264
RADBench.bug3 2 AF 2 42 L 3478 42 L 3478 /enc-37L0 /enc-37L0 /enc-37L0 /enc-3701 489 /enc-370/enc-37227
RADBench.bug4 2 AF 3 259 L 6 259 L 6 /enc-37L0 /enc-37L0 /enc-37L0 4 2013 /enc-3701275 13 /enc-331
RADBench.bug5 2 DL 2 /enc-37L0 /enc-37L0 /enc-37L0 /enc-37L0 /enc-37L0 /enc-370/enc-370/enc-370/enc-37224
RADBench.bug6 2 DL 2 24 2950 340 24 2950 340 30 8327 112 27 4039 70 /enc-37L0 236 7 484 34 3 855 /enc-3314
Total bugs found (Buggy Programs) 38 (34) 30 (28) 25 (24) 27 (26) 19 (18) 13 (13) 33 (32) 29 (28) 18 (18)
*AF, BOF, and DL are short for assertion failure, buffer-overflow, and deadlock, respectively. The marker â€˜Lâ€™ and â€˜/enc-37â€™ respectively denote our schedule limit 10,000 is reached (except program
CS.twostage_100_bad using 100,000 as schedule limit) and that no bug was found.
PeriodandSerialidentified15bugsintheCVEbenchmark,per-
formingthebest.IntheprogramofCVE-2017-6346,Periodreports
anull-pointer-dereference(NPD)bug,ause-after-free(UAF)bug
andadouble-free(DF)bug.WhileallothersystematicCCTtech-
niquesfailtoreportthesethreebugs,andonlytwonon-systematic
CCT techniques(i.e., Randomand Maple) can identifyNPD or DF.
In particular, the DF bug in the program of CVE-2016-1972 canbe found only by Period, which is also an undocumented bug.
Moreover, two concurrency vulnerabilities detectors (i.e., UFO [ 30]
and ConVul [ 15]) and three data race detectors (i.e., FastTrack [ 24],
Helgrind [ 35] and TSAN [ 59]) are considered, whose results are
includedinTable1aswell.However,mostoftheirperformances
(exceptforConVul)areworsethanCCTtechniques:ConVuland
UFOidentify9and3buggyprograms,respectively,andthethree
dataracedetectorscanidentifyatmost2bugs.Theaboveresults
Figure 6: The number of bugs found after ğ‘¥schedule.
demonstrate the effectiveness of our systematic schedule explo-
ration in terms of execution periods for both Period and Serial.
OnSCTBench,asshowninTable2, Periodidentified38bugs
and 30 buggy programs in total, performing the best. In particular,
Periodperformsthebestonabouthalf(20outof40)bugsinterms
482
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 07:54:11 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Cheng Wen et al.
ofschedulestobug(1st),andrequiresfewer schedules thanothersys-
tematictestingtechniquesonabout83.33%(30outof36)programs,
due to our efficient exploration of schedule space. Moreover, our
Serial identified 30 bugs, performing better than the other CCTtechniques (except for PCT). Due to the larger thread numbers,
Serial still missed 10 bugs, 7 of which are also missed by IPB and
IDB. However, about 80% of these missed bugs can be identified by
our parallel version Period. The last two lucky bugs missed by all
the techniques are Misc.SafeStack andRADBench.bug5. We had a
manualinspectiononthesetwobugs. Misc.SafeStack isanimple-
mentationofalock-freestack[ 67],whichrequiresatleast5context
switches.While theschedule boundfor theCCT techniques isset
to3.Inaddition,asshowninapriorevaluation[ 64],Misc.SafeStack
isverydifficulttodetect,sincealltechniquesin[ 64]failtodetect
it.RADBench.bug5 was unable to reproduce in our experiments,
despite that we followed the instructions in the document.
TofurthercomparetheCCTtechniques,wepresentacumula-
tiveplotinFig.6withaschedulelimitof10,000,whereeachline
represents a technique and is labeled by the name of the technique
andthenumberofbugsfoundbythetechnique,andapoint( ğ‘¥,ğ‘¦)
representsthat ğ‘¦concurrencybugsareexposedbythetechnique
usingğ‘¥schedules.Onthewhole,Periodhasalargergrowthtrend,
indicatingthatPeriodrequiresfewerschedulestofindthesame
numberofbugsorcanfindmorebugsinthesamenumberofsched-
ules. Forexample, more than 40bugs could beexposed by Period
using lower than 100 schedules, while the others would require
1,000 to 10,000 schedules.
The above results signify that Period is more effective than the
other techniques. There are two main factors that contribute to
theeffectiveness.Firstly,asdemonstratedbytheperformancesof
our Serial and Period, the proposed gradual exploration in terms
of execution periods guided by schedule prefixes is effective in
detectingconcurrencybugs.Secondly,asshowninÂ§4.2,allowing
parallelism can significantly improve our serialized scheduler.CaseStudies
.TodemonstratethereasonsbehindPeriodâ€™ssuperi-
ority, we present two case studies. The first case is the program in
CVE-2016-1972,whichsuffersfromtheNPD,UAFandDFbugs.Withthehelpoffeedbackanalyzer,Periodonlygenerates573schedules
and successfully finds all the bugs. A brief introduction for howPeriod find the UAF and DF bugs have been given in Â§2, which
demonstrates our effective exploring strategies. However, both IPB
andDFSgeneratedmorethan10 ,000schedulesbutfailedtofindthe
DF bug. The program CS.reorder_10_bad from SCTBench contains
an assertion error. As illustrated in Fig. 4, two context switchesbetween
ğ‘‡0and any other thread can trigger the error. But most
of the CCT techniques, except for our technique Period and PCT,
were unable to detect it. Similar to Serial, with no supports of
parallelization, existing systematic techniques have to explore a
much larger schedule space than needed, causing schedule budget
runningout quickly,especially forprograms witha largenumber
of threads. On the other hand, although PCT can expose this error,
theprobabilitytotriggeritisextremelylow(about9/10000=0.09%
in our experiment).
Period significantly outperforms existing CCT techniques in
terms of concurrency bug finding ability.
Figure7:Averageexe cutionspeedof CCTtechniquesrelativetona-
tive execution. Lower is better.
4.4 Overhead Evaluation (RQ3)
Toevaluatetheruntimeoverheadrequiredforachievingcontrolled
scheduling, we use programs from the SCTbench with various
numbersofthreadsandalltheprogramsfromtheCVEbenchmark.Fig.7showstheaverageexecutionspeedduringtestingachievedby
Period,IPB,IDBandPCTrelativetonativeexecution,wherethe
numberinsidetheprogramnamerepresentsthenumberofthreads.
On all benchmark programs, the runtime overhead incurred by
Period is lower than other techniques (i.e., IPB, IDB, and PCT). In
detail,Periodrequiresonly2to30timesofexecutionslowdown
over native execution, while the others require 10 to 500 times.
As the number of threads increases, the effect of execution slow-
down can be weakened for all techniques. The reasons for the low
overhead of Period could be: ( ğ‘–) the periodical execution achieves
control scheduling with non-preemptive synchronizations, thusavoiding false deadlocks and starvation; and (
ğ‘–ğ‘–) Period allows
parallelism inperiodicalexecution, instead of serializing execution,
which can boost the performance.
Period incurs some noticeable runtime overhead, which is
significantly lower than that of IPB, IDB, and PCT.
4.5 Discussion
Additional Experiments. TheaboveexperimentsshowthatPe-
riod is effective and efficient in finding concurrency bugs. Notethat it is possible that a technique â€œgets luckyâ€ and finds a bug
quicklyduetothesearchorder.Forthat,weconsiderthe worst-case
bug-findingability intermsofthetotalnumberofnon-buggysched-
uleswithinthebound,thatis,thedifferencebetween schedules and
buggyschedules.TheresultshowsthatPeriodperformsthebest
in 33 out of all 46 programs. Since Period allows parallelism in
periodical execution, which could be accelerated by multi-cores,w e
also evaluate the runtime speedup with different CPU cores. For aprogram with 10, 20, 50, and 100 threads, Period respectively pro-
vides 8Ã—,1 1Ã—,1 7Ã—, and 34Ã—speedups on the 8-cores configuration,
compared to the single-core one. In addition, we have tested 20
open-source programs, with source lines of code ranging from 325
to233,431lines.Periodsuccessfully identified5previouslyunknown
concurrency bugs (e.g.,aU A Fi n lrzip, buffer-overflow in pbzip2, in-
valid address dereference in ctrace). These concurrency bugs were
notpreviouslyreportedandwehaveinformedthemaintainers.All
extra experimental results are available on our website4.
ThreatstoValidity. Weselectedavariantofexistingbenchmarks
andreal-worldprogramstoshowthecapabilitiesof Period,and
4Periodâ€™s website: https://sites.google.com/view/period-cct/
483
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 07:54:11 UTC from IEEE Xplore.  Restrictions apply. Controlled Concurrency Testing via Periodical Scheduling ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
compareditagainstotherCCTtechniques.However,ourevaluation
datasetmaystillincludeacertainsamplebias.Furtherstudieson
morereal-worldprogramscanhelptobetterevaluatePeriod.Pe-
riod uses static analysis to identify key points. In practice, if some
key points are missed, it could result in some bugs being missed.
Thus the static analysis for identifying key points should be an
over-approximation. Our static analysis is currently built on top of
SVF [62], and it works well for all the benchmark programs in our
evaluation.Amorepowerfulstaticanalysismayhelptoimprove
Period further. Moreover, this work assumes that the inputs to
the program are predetermined, for example, by an existing test
suite,anddonotvarybetweenruns,asitistypicalinotherwork
in the literature on CCT. Adopting some test case generation tech-
niques(e.g .,fuzzingandsymbolicexecution)mighthelpmitigate
this threat. Finally, this work doesnâ€™t handle weak memory models
(WMMs) [ 7] and probabilistic programming models [ 56]. We are
seeking solutions to further improve Period.
5 RELATED WORK
Thereisawiderangeofresearchproposedintheliteratureontest-
ing and analysis of concurrent programs. Here we briefly describe
the related work and compared it to Period.Concurrency Testing.
Controlledconcurrencytestinghasbeen
thesubjectofextensiveresearch,giventheelusivenatureofcon-
currency bugs. Chess [ 22,48] showed the effectiveness of itera-
tivepreemption-bounding(IPB),andlateriterativedelay-bounding
(IDB),forfindingbugsinmulti-threadedsoftware.PCT[ 11]andits
parallelized variation PPCT [ 50] set thread priorities that are used
by the scheduler of the underlying operating system or runtimeto schedule the threads exactly as required by the testing algo-
rithm, showcasing the power of randomized scheduling [ 4,17,69].
Maple[75]employsacoverage-drivenapproach,basedonageneric
set of interleaving idioms, for testing multi-threaded programs.
RPro[12]isaradius-awareprobabilistictestingfortriggeringdead-
locks,whereitselectsprioritychangingpointswithintheradiusofthetargeteddeadlocksbutnotamongallevents.TSVD[
39]dynam-
icallyidentifiespotentialthread-safetyviolationsandinjectsdelays
todrivetheprogramtowardsunsafebehaviors.QL[ 45]improves
CCT by leveraging classical Q-learning algorithm to explore the
spaceofpossibleinterleavings.Severaltechniquesarealsodevel-
oped for distributed systems, including dBug [ 60], MoDist [ 72],
Samc [38], Spider [ 52] andMorpheus [ 79]. The presenceof such a
largenumberoftechniquesclearlyindicatestheimportanceofCCT.OurproposedPeriodachievecontrolledschedulingbyanovelperi-
odical executions which is non-preemptive and allows parallelism,
anditsystematicallyexploretheschedulespaceofeachDKPSwith
the guidance of schedule prefixes.
Dynamic partial-order reduction (DPOR) [ 25,47] computes per-
sistent sets during testing to identify equivalent interleavings so
someinterleavingscanbeskippediftheirequivalentsarealready
tested. Some recent research has achieved considerable improve-
mentsoverDPOR[ 16,34,58,80].Itwouldbeinterestingforfuture
work to combine DPOR techniques into Period.
Several other techniques leverage fuzzing [ 40,41] to find test
inputs exposing bugs in concurrent programs [ 18,36,42,65,71].
Challenges caused by test inputs are orthogonal to this work as we
focus on finding buggy interleavings.StaticAnalysisApproaches. Staticanalysisaimstoapproximate
concurrentprogramsâ€™behaviorswithoutactuallyexecutingthem[ 8,
13,55,61,66]. For example, LOCKSMITH [ 55] uses existential
types to correlate locks and data in dynamic heap structures forrace detection. Goblint [
66] relies on a thread-modular constant
propagation and points-to analysis for detecting concurrency bugs
byconsidering conditionallocking schemes.DCUAF[ 8]statically
detects concurrency use-after-free bugs in Linux device driversthrough a summary-based lockset analysis. FSAM [
61,62]p r o -
poses a sparse flow-sensitive pointer analysis for C/C++ programs
usingcontext-sensitivethread-interleavinganalysis.Canary[ 13]
conductsinterference-awarevalue-flowanalysisforcheckinginter-threadvalue-flowbugs,achievingbothgoodprecisionandscalabil-ityformillionsoflinesofcode.Thestaticapproachesmayproducefalsepositives.InPeriod,thestaticanalysiscomponentiscurrently
builtontopofSVF,butcanbereplacedbyamorepowerfulstatic
analysis if available.Dynamic Analysis Approaches.
There is a line of work using
dynamicanalysistofindconcurrencybugs[ 14,28,51,76,76,78].
The two fundamentalsare happens-before model [24]and lockset
model [57]. The happens-before model reports a race condition
when two threads read/write a shared memory arena in a causally
unordered way, while at least one of the threads writes into this
arena. The lockset model conservatively considers a potential race
if two threads read/write a shared memory arena without lock-
ing.FT[24]andHelgrind[ 35]aretwowell-knownhappens-before
basedracedetectors.ModerndetectorssuchasTSan[ 59]applya
hybridstrategytocombineboththehappens-beforemodel[ 24]and
thelocksetmodel[ 57].Predictiveanalysis[ 14,15,30,31,68]collects
tracesconsistingofdifferenttypesofeventsandthenpredictsbugsoffline based on the dependencies of events or known bug patterns.
UFO [30] applies an extended maximal causality model [ 29,32,33]
topredictconcurrencyUAFsbasedonasingleexecutiontrace,even
though the UAFs may not happen in the observed execution. Con-
Vul [15]predictsconcurrencyvulnerabilitiesbyjudgingwhether
twoeventsareexchangeablebasedonthehappens-beforemodel.
ConVulPOE [ 76] enhances ConVul by introducing partial-order
reduction.Periodâ€™sfocusisnotonimprovingdynamicdetection
ofconcurrencyviolation;instead,itcanemploythesetechniques
as bug detectors to work with the periodical scheduling.
6 CONCLUSION
In this paper, we present a novel controlled concurrency testing
technique Period. Period models the execution of concurrent pro-
gramsasperiodicalexecution,andsystematicallyexploresthespace
ofpossibleinterleavings, guidedbyperiodicalschedulingandthe
historyexecutioninformation.Ourevaluationhasdemonstrated
Period shows superiority over state-of-the-art CCT techniques in
terms of both bug-finding effectiveness and runtime overhead.
ACKNOWLEDGEMENTS
This work was supported in part by the National Natural Sci-
ence Foundation of China (Nos. 61972260, 61772347, 61836005),
the Guangdong Basic and Applied Basic Research Foundation (No.
2019A1515011577)andtheStableSupportProgramsofShenzhen
City (No. 20200810150421002).
484
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 07:54:11 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Cheng Wen et al.
REFERENCES
[1]2016. SCTBench:asetofC/C++pthreadbenchmarksforevaluatingconcurrency
testing techniques. Retrieved August 20, 2021. https://github.com/mc-imperial/
sctbench [online].
[2]2019. CVEBenchmark. RetrievedAugust20,2021. https://github.com/mryancai/
ConVul [online].
[3]2021. Deadline Task Scheduling. The Linux kernel userâ€™s and administratorâ€™s
guide. https://www.kernel.org/doc/html/latest/scheduler/sched-deadline.html
[online].
[4]Mahmoud Abdelrasoul. 2017. Promoting secondary orders of event pairs in
randomized scheduling using a randomized stride. In 2017 32nd IEEE/ACM Inter-
national Conference on Automated Software Engineering (ASE). IEEE, 741â€“752.
[5]Sara Abbaspour Asadollah, Daniel Sundmark, Sigrid Eldh, and Hans Hansson.
2017. Concurrencybugsinopensourcesoftware:acasestudy. JournalofInternet
Services and Applications 8, 1 (2017), 1â€“15.
[6]SaraAbbaspourAsadollah,DanielSundmark,SigridEldh,HansHansson,and
WasifAfzal.2017. 10Yearsofresearchondebuggingconcurrentandmulticore
software: a systematic mapping study. Software quality journal 25, 1 (2017),
49â€“82.
[7]MohamedFaouziAtig,AhmedBouajjani,SebastianBurckhardt,andMadanlal
Musuvathi. 2010. On the verification problem for weak memory models. In
Proceedingsofthe37thannualACMSIGPLAN-SIGACTsymposiumonPrinciples
of programming languages. 7â€“18.
[8]Jia-JuBai,JuliaLawall,Qiu-LiangChen,andShi-MinHu.2019. Effectivestatic
analysis of concurrency use-after-free bugs in Linux device drivers. In 28th
USENIX Annual Technical Conference (USENIX ATC 19). USENIX, 255â€“268.
[9]Alessio Balsini. 2014. SCHED DEADLINE. In Workshop on Real-Time Scheduling
in the Linux Kernel.
[10]Christian Bienia. 2011. Benchmarking modern multiprocessors. Princeton Univer-
sity.
[11]SebastianBurckhardt,PraveshKothari,MadanlalMusuvathi,andSantoshNa-
garakatte.2010. Arandomizedschedulerwithprobabilisticguaranteesoffinding
bugs.ACM SIGARCH Computer Architecture News 38, 1 (2010), 167â€“178.
[12]Yan Cai and Zijiang Yang. 2016. Radius aware probabilistic testing of deadlocks
withguarantees.In 201631stIEEE/ACMInternationalConferenceonAutomated
Software Engineering (ASE). IEEE, 356â€“367.
[13]YuandaoCai,PeisenYao,andCharlesZhang.2021. Canary:practicalstaticde-
tectionofinter-threadvalue-flowbugs.In Proceedingsofthe 42ndACMSIGPLAN
InternationalConferenceonProgrammingLanguageDesignandImplementation .
1126â€“1140.
[14]Yan Cai, Hao Yun, Jinqiu Wang, Lei Qiao, and Jens Palsberg. 2021. Sound and
Efficient Concurrency Bug Prediction. In Proceedings of the 2021 29th ACM Joint
Meeting on European Software Engineering Conference and Symposium on the
Foundations of Software Engineering. ACM.
[15]YanCai,BiyunZhu,RuijieMeng,HaoYun,LiangHe,PuruiSu,andBinLiang.
2019. Detecting concurrency memory corruption vulnerabilities. In Proceedings
of the 2019 27th ACM Joint Meeting on European Software Engineering Conference
andSymposiumontheFoundationsofSoftwareEngineering.ACM,Paris,France,
706â€“717.
[16]MarekChalupa,KrishnenduChatterjee,AndreasPavlogiannis,NishantSinha,
andKapilVaidya.2017. Data-centricdynamicpartialorderreduction. Proceedings
of the ACM on Programming Languages 2, POPL (2017), 1â€“30.
[17]Dongjie Chen, Yanyan Jiang, Chang Xu, Xiaoxing Ma, and Jian Lu. 2018. Testing
multithreaded programs via thread speed control. In Proceedings of the 2018 26th
ACM Joint Meeting on European Software Engineering Conference and Symposium
on the Foundations of Software Engineering. 15â€“25.
[18]Hongxu Chen, Shengjian Guo, Yinxing Xue, Yulei Sui, Cen Zhang, Yuekang
Li,HaijunWang,andYangLiu.2020. MUZZ:Thread-awareGrey-boxFuzzing
forEffectiveBugHuntinginMultithreadedPrograms.In 29thUSENIXSecurity
Symposium (USENIX Security 20). USENIX, Virtual, 2325â€“2342.
[19]Lucas Cordeiro and Bernd Fischer. 2011. Verifying multi-threaded software
using SMT-based context-bounded model checking. In 2011 33rd International
Conference on Software Engineering (ICSE). IEEE, 331â€“340.
[20] The MITRE Corporation. 1999. Common Vulnerabilities and Exposures.[21]
CVE-2016-1972. 2016. Available from MITRE. https://cve.mitre.org/cgi-bin/
cvename.cgi?name=CVE-2016-1972.
[22]Michael Emmi, Shaz Qadeer, and Zvonimir RakamariÄ‡. 2011. Delay-bounded
scheduling. In Proceedings of the 38th annual ACM SIGPLAN-SIGACT symposium
on principles of programming languages. ACM, 411â€“422.
[23]Haining Feng, Liangze Yin, Wenfeng Lin, Xudong Zhao, and Wei Dong. 2020.Rchecker: A CBMC-based Data Race Detector for Interrupt-driven Programs.In2020 IEEE 20th International Conference on Software Quality, Reliability and
Security Companion (QRS-C). IEEE, Macau, China, 465â€“471.
[24]CormacFlanaganandStephen NFreund.2009. FastTrack:efficientandprecise
dynamic race detection. ACM Sigplan Notices 44, 6 (2009), 121â€“133.
[25]Cormac Flanagan and Patrice Godefroid. 2005. Dynamic partial-order reduction
for model checking software. ACM Sigplan Notices 40, 1 (2005), 110â€“121.[26]PedroFonseca,RodrigoRodrigues,andBjÃ¶rnBBrandenburg.2014. SKI:Exposing
Kernel Concurrency Bugs through Systematic Schedule Exploration. In 11th
USENIX Symposium onOperating Systems Design and Implementation (OSDI14).
415â€“431.
[27]Patrice Godefroid. 1997. Model checking for programming languages using
VeriSoft. In Proceedings of the 24th ACM SIGPLAN-SIGACT symposium on Princi-
ples of programming languages. 174â€“186.
[28]Shin Hong and Moonzoo Kim. 2015. A survey of race bug detection techniques
formultithreadedprogrammes. SoftwareTesting,VerificationandReliability 25,3
(2015), 191â€“217.
[29] Jeff Huang. 2015. Stateless model checking concurrent programs with maximal
causality reduction. ACM SIGPLAN Notices 50, 6 (2015), 165â€“174.
[30]JeffHuang.2018. UFO:predictiveconcurrencyuse-after-freedetection.In 2018
IEEE/ACM 40th International Conference on Software Engineering (ICSE). IEEE,
Gothenburg, Sweden, 609â€“619.
[31]Jeff Huang, Qingzhou Luo, and Grigore Rosu. 2015. GPredict: Generic predictive
concurrencyanalysis.In 2015IEEE/ACM37thIEEEInternationalConferenceon
Software Engineering, Vol. 1. IEEE, 847â€“857.
[32]Jeff Huang, Patrick Oâ€™Neil Meredith, and Grigore Rosu. 2014. Maximal sound
predictive race detection with control flow abstraction. In Proceedings of the 35th
ACM SIGPLAN conference on programming language design and implementation.
337â€“348.
[33]ShiyouHuangandJeffHuang.2016. MaximalcausalityreductionforTSOand
PSO.ACM SIGPLAN Notices 51, 10 (2016), 447â€“461.
[34]ShiyouHuangandJeffHuang.2017. Speedingupmaximalcausalityreduction
with static dependency analysis. In 31st European Conference on Object-Oriented
Programming(ECOOP2017).SchlossDagstuhl-Leibniz-ZentrumfuerInformatik.
[35]AliJannesari,KaibinBao,VictorPankratius,andWalterFTichy.2009. Helgrind+:
An efficient dynamic race detector. In 2009 IEEE International Symposium on
Parallel & Distributed Processing. IEEE, Chengdu, China, 1â€“13.
[36]Dae R Jeong, Kyungtae Kim, Basavesh Shivakumar, Byoungyoung Lee, and Insik
Shin. 2019. Razzer: Finding kernel race bugs through fuzzing. In 2019 IEEE
SymposiumonSecurityandPrivacy(SP).IEEE,HyattRegency,SanFrancisco,CA,
754â€“768.
[37]Chris Lattner and Vikram Adve. 2004. LLVM: A compilation framework for
lifelong program analysis & transformation. In International Symposium on Code
Generation and Optimization,2004. CGO 2004. IEEE, 75â€“86.
[38]Tanakorn Leesatapornwongsa, Mingzhe Hao, Pallavi Joshi, Jeffrey F Lukman,and Haryadi S Gunawi. 2014. SAMC: Semantic-Aware Model Checking for
FastDiscoveryofDeepBugsinCloudSystems.In 11thUSENIXSymposiumon
Operating Systems Design and Implementation (OSDI 14). 399â€“414.
[39]Guangpu Li, Shan Lu, Madanlal Musuvathi, Suman Nath, and Rohan Padhye.
2019. Efficientscalablethread-safety-violationdetection:findingthousandsof
concurrency bugs during testing. In Proceedings of the 27th ACM Symposium on
Operating Systems Principles. ACM, Huntsville, Ontario, Canada, 162â€“180.
[40]Jun Li, Bodong Zhao, and Chao Zhang. 2018. Fuzzing: a survey. Cybersecurity 1,
1 (2018), 6.
[41]HongliangLiang,XiaoxiaoPei,XiaodongJia,WuweiShen,andJianZhang.2018.Fuzzing:Stateoftheart. IEEETransactionsonReliability 67,3(2018),1199â€“1218.
[42]ChangmingLiu,DeqingZou,PengLuo,BinBZhu,andHaiJin.2018. Aheuristicframeworktodetectconcurrencyvulnerabilities.In Proceedingsofthe34thAnnual
Computer Security Applications Conference. ACM, San Juan, PR, USA, 529â€“541.
[43]Ziheng Liu, Shuofei Zhu, Boqin Qin, Hao Chen, and Linhai Song. 2021. Au-tomatically detecting and fixing concurrency bugs in go software systems. In
Proceedings of the 26th ACM International Conference on Architectural Support for
Programming Languages and Operating Systems. 616â€“629.
[44]ShanLu,SoyeonPark,EunsooSeo,andYuanyuanZhou.2008. Learningfrom
mistakes: a comprehensive study on real world concurrency bug characteristics.
InProceedings of the 13th international conference on Architectural support for
programming languages and operating systems. 329â€“339.
[45]Suvam Mukherjee, Pantazis Deligiannis, Arpita Biswas, and Akash Lal. 2020.
Learning-basedcontrolledconcurrencytesting. ProceedingsoftheACMonPro-
gramming Languages 4, OOPSLA (2020), 1â€“31.
[46]Madanlal Musuvathi and Shaz Qadeer. 2007. Iterative context bounding for
systematic testing of multithreaded programs. ACM Sigplan Notices 42, 6 (2007),
446â€“455.
[47]MadanlalMusuvathiand ShazQadeer.2007. Partial-orderreduction forcontext-
bounded state exploration. Technical Report. Citeseer.
[48]Madanlal Musuvathi, Shaz Qadeer, Thomas Ball, Gerard Basler, Pira-
manayagamArumugaNainar,andIulianNeamtiu.2008.FindingandReproducing
Heisenbugs in Concurrent Programs.. In OSDI, Vol. 8. USENIX, USA, 267â€“280.
[49]Madanlal Musuvathi, Shaz Qadeer, Thomas Ball, Madanlal Musuvathi, ShazQadeer, and Thomas Ball. 2007. Chess: A systematic testing tool for concurrent
software. TechnicalReport.TechnicalReportMSR-TR-2007-149,MicrosoftRe-
search.
[50]Santosh Nagarakatte, Sebastian Burckhardt, Milo MK Martin, and MadanlalMusuvathi. 2012. Multicore acceleration of priority-based schedulers for con-currency bug detection. In Proceedings of the 33rd ACM SIGPLAN Conference
on Programming Language Design and Implementation. ACM, Beijing, China,
485
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 07:54:11 UTC from IEEE Xplore.  Restrictions apply. Controlled Concurrency Testing via Periodical Scheduling ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
543â€“554.
[51]Jihyun Park, Byoungju Choi, and Seungyeun Jang. 2020. Dynamic analysis
methodforconcurrencybugsinmulti-process/multi-threadenvironments. Inter-
national Journal of Parallel Programming 48 (2020), 1032â€“1060.
[52]JoÃ£oCarlosPereira,NunoMachado,andJorgeSousaPinto.2020. TestingforRace
Conditions in Distributed Systems via SMT Solving. In International Conference
on Tests and Proofs. Springer, 122â€“140.
[53]Ernest Pobee and Wing Kwong Chan. 2019. Aggreplay: Efficient record and
replay of multi-threaded programs. In Proceedings of the 2019 27th ACM Joint
Meeting on European Software Engineering Conference and Symposium on the
Foundations of Software Engineering. ACM, Paris, France, 567â€“577.
[54]ErnestPobee,XiupeiMei,andWingKwongChan.2019. Efficienttransaction-
based deterministic replay for multi-threaded programs. In 2019 34th IEEE/ACM
International Conference on Automated Software Engineering (ASE) . IEEE, San
Diego, California, USA, 760â€“771.
[55]Polyvios Pratikakis, Jeffrey S Foster, and Michael Hicks. 2011. LOCKSMITH:
PracticalstaticracedetectionforC. ACMTransactionsonProgrammingLanguages
and Systems (TOPLAS) 33, 1 (2011), 1â€“55.
[56]AndrÃ¡s PrÃ©kopa. 2003. Probabilistic programming. Handbooks in operations
research and management science 10 (2003), 267â€“351.
[57]StefanSavage,MichaelBurrows,GregNelson,PatrickSobalvarro,andThomas
Anderson.1997.Eraser:Adynamicdataracedetectorformultithreadedprograms.
ACM Transactions on Computer Systems (TOCS) 15, 4 (1997), 391â€“411.
[58]Daniel Schemmel, Julian BÃ¼ning, CÃ©sar RodrÃ­guez, David Laprell, and Klaus
Wehrle.2020. Symbolicpartial-orderexecutionfortestingmulti-threadedpro-
grams. In International Conference on Computer Aided Verification. Springer, 376â€“
400.
[59]KonstantinSerebryanyandTimurIskhodzhanov.2009. ThreadSanitizer:Data
racedetectioninpractice.In Proceedingsoftheworkshoponbinaryinstrumentation
and applications. ACM, New York, NY, USA, 62â€“71.
[60]JiÅ™Ã­ Å imÅ¡a, Randy Bryant, and Garth Gibson. 2011. dBug: Systematic Testingof Unmodified Distributed and Multi-threaded Systems. In International SPIN
Workshop on Model Checking of Software. Springer, 188â€“193.
[61]Yulei Sui,Peng Di, andJingling Xue.2016. Sparseflow-sensitive pointeranalysis
for multithreaded programs. In Proceedings of the 2016 International Symposium
on Code Generation and Optimization. 160â€“170.
[62]YuleiSuiandJinglingXue.2016.SVF:interproceduralstaticvalue-flowanalysisinLLVM.In Proceedingsofthe25thinternationalconferenceoncompilerconstruction.
265â€“266.
[63]PaulThomson,AlastairFDonaldson,andAdamBetts.2014. Concurrencytesting
using schedule bounding: An empirical study. In Proceedings of the 19th ACM
SIGPLAN symposium on Principles and practice of parallel programming. 15â€“28.
[64]PaulThomson,AlastairFDonaldson,andAdamBetts.2016. Concurrencytesting
usingcontrolledschedulers:Anempiricalstudy. ACMTransactionsonParallel
Computing (TOPC) 2, 4 (2016), 1â€“37.
[65]Nischai Vinesh and M Sethumadhavan. 2020. Confuzzâ€”a concurrency fuzzer.
InFirstInternationalConferenceonSustainableTechnologiesforComputational
Intelligence. Springer, Jaipur, Rajasthan, India, 667â€“691.
[66] Vesal Vojdani and Varmo Vene. 2009. Goblint: Path-sensitive data race analysis.
InAnnales Univ. Sci. Budapest., Sect. Comp, Vol. 30. Citeseer, 141â€“155.[67]DmitryVyukov.2010. Bugwithacontextswitchbound5.In MicrosoftCHESS
Forum.
[68]Chao Wang, Sudipta Kundu, Malay Ganai, and Aarti Gupta. 2009. Symbolicpredictive analysis for concurrent programs. In International Symposium on
Formal Methods. Springer, 256â€“272.
[69]ZanWang,DongdiZhang,ShuangLiu,JunSun,andYingquanZhao.2019. Adap-
tive randomized scheduling for concurrency bug detection. In 2019 24th Interna-
tionalConferenceonEngineeringofComplexComputerSystems(ICECCS).IEEE,
Nansha, Guangzhou, China, 124â€“133.
[70]StevenCameron Woo,MoriyoshiOhara, EvanTorrie,Jaswinder PalSingh,and
Anoop Gupta. 1995. The SPLASH-2 programs: Characterization and method-
ological considerations. ACM SIGARCH computer architecture news 23, 2 (1995),
24â€“36.
[71]Meng Xu, Sanidhya Kashyap, Hanqing Zhao, and Taesoo Kim. 2020. Krace: Data
RaceFuzzingforKernelFileSystems.In 2020IEEESymposiumonSecurityand
Privacy (SP). IEEE, Virtual, 1643â€“1660.
[72]Junfeng Yang, Tisheng Chen, Ming Wu, Zhilei Xu, Xuezheng Liu, HaoxiangLin, Mao Yang, Fan Long, Lintao Zhang, and Lidong Zhou. 2009. MODIST:
Transparent model checking of unmodified distributed systems. (2009).
[73]YuYang,XiaofangChen, andGaneshGopalakrishnan. 2008. Inspect:A runtime
model checker for multithreaded C programs. Technical Report. Citeseer.
[74]Jie Yu and Satish Narayanasamy. 2009. A case for an interleaving constrained
shared-memory multi-processor. ACM SIGARCH Computer Architecture News 37,
3 (2009), 325â€“336.
[75]JieYu,SatishNarayanasamy,CristianoPereira,andGillesPokam.2012. Maple:
A coverage-driven testing tool for multithreaded programs. In Proceedings of the
ACM international conference on Object oriented programming systems languages
and applications. ACM, Tucson, Arizona, USA, 485â€“502.
[76]Kunpeng Yu, Chenxu Wang, Yan Cai, Xiapu Luo, and Zijiang Yang. 2021. De-tecting Concurrency Vulnerabilities Based on Partial Orders of Memory and
ThreadEvents.In Proceedingsofthe202129thACMJointMeetingonEuropean
SoftwareEngineeringConferenceandSymposiumontheFoundationsofSoftware
Engineering. ACM.
[77]Tingting Yu, TarannumS Zaman,and ChaoWang.2017. DESCRY:reproducing
system-levelconcurrencyfailures.In Proceedingsofthe201711thJointMeeting
on Foundations of Software Engineering. ACM, Paderborn, Germany, 694â€“704.
[78]MingYuan,YeseopLee,ChaoZhang,YunLi,YanCai,andBodongZhao.2021.
RAProducer:efficientlydiagnoseandreproducedataracebugsforbinariesvia
trace analysis. In Proceedings of the 30th ACM SIGSOFT International Symposium
on Software Testing and Analysis. 593â€“606.
[79]Xinhao Yuan and Junfeng Yang. 2020. Effective Concurrency Testing for Dis-
tributed Systems. In Proceedings of the Twenty-Fifth International Conference on
ArchitecturalSupportforProgrammingLanguagesandOperatingSystems.1141â€“
1156.
[80]Xinhao Yuan, Junfeng Yang, and Ronghui Gu. 2018. Partial order aware con-
currencysampling.In InternationalConferenceonComputerAidedVerification.
Springer, 317â€“335.
[81]ShixiongZhao,RuiGu,HaoranQiu,TszOnLi,YuexuanWang,HemingCui,and
JunfengYang.2018. Owl:Understandinganddetectingconcurrencyattacks.In
201848thAnnualIEEE/IFIPInternationalConferenceonDependableSystemsand
Networks (DSN). IEEE, Luxembourg City, Luxembourg, 219â€“230.
486
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 07:54:11 UTC from IEEE Xplore.  Restrictions apply. 