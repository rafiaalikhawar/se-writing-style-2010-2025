CodeCoverageCriteriaforAsynchronous Programs
Mohammad Ganji
SimonFraserUniversity
Canada
m_ganji@sfu.caSaba Alimadadi
SimonFraserUniversity
Canada
saba@sfu.caFrank Tip
NortheasternUniversity
USA
f.tip@northeastern.edu
ABSTRACT
Asynchronous software often exhibits complex and error-prone
behaviorsthatshouldbetestedthoroughly.Codecoveragehasbeen
themostpopularmetrictoassesstestsuitequality. However,tradi-
tional code coverage criteria do not adequately re/f_lect completion,
interactions, anderrorhandling ofasynchronous operations.
This paper proposes novel test adequacy criteria for measur-
ing: (i) completion of asynchronous operations in terms of both
successful and exceptional execution, (ii)registration ofreactions
for handling both possible outcomes, and (iii) execution of said
reactionsthroughtests. Weimplement JScope,atoolforautomati-
callymeasuringcoverageaccordingtothesecriteriainJavaScript
applications,as an interactive plug-infor VisualStudioCode.
Anevaluationof JScopeon20JavaScriptapplicationsshowsthat
theproposedcriteriacanhelpimproveassessmentoftestadequacy,
complementing traditional criteria. According to our investigation
of 15 real GitHub issues concerned with asynchrony, the new crite-
riacanhelprevealfaultyasynchronousbehaviorsthatareuntested
yet are deemed covered by traditional coverage criteria. We also
reportonacontrolledexperimentwith12participantstoinvesti-
gatetheusefulnessof JScopeinrealisticsettings, demonstrating
itseﬀectivenessinimprovingprogrammers’abilitytoassesstest
adequacyanddetectuntestedbehaviorofasynchronous code.
CCS CONCEPTS
•Softwareanditsengineering →Softwaretestinganddebug-
ging.
KEYWORDS
Code coverage,Dynamicanalysis,Asynchronous JavaScript
ACMReference Format:
Mohammad Ganji, Saba Alimadadi, and Frank Tip. 2023. Code Coverage
CriteriaforAsynchronousPrograms.In Proceedingsofthe31stACMJoint
European Software Engineering Conference and Symposium on the Foun-
dations of Software Engineering (ESEC/FSE ’23), December 3–9, 2023, San
Francisco, CA, USA. ACM, New York, NY, USA, 13pages.https://doi.org/10.
1145/3611643.3616292
Permissionto make digitalor hard copies of allorpart ofthis work for personalor
classroom use is granted without fee provided that copies are not made or distributed
forpro/f_itorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
onthe/f_irstpage.Copyrights forcomponentsofthisworkownedbyothersthanthe
author(s)mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,or
republish,topostonserversortoredistributetolists,requirespriorspeci/f_icpermission
and/or a fee. Request permissions from permissions@acm.org.
ESEC/FSE ’23, December 3–9, 2023, San Francisco, CA,USA
©2023 Copyright heldby the owner/author(s). Publicationrightslicensed to ACM.
ACM ISBN 979-8-4007-0327-0/23/12...$15.00
https://doi.org/10.1145/3611643.36162921 INTRODUCTION
Asynchronousprogrammingisextensivelyused forwebdevelop-
mentandiscrucialforprovidingbene/f_itssuchasnon-blockingI/O,
seamless and real-time user interactions, and eﬃcient client-server
communications. JavaScript is single-threaded, and asynchronous
execution of potentially long-running tasks is what enables the ap-
plications to remain responsive while processing events. In recent
years,JavaScript’sPromises[ 1,Section27.2]and async/await[1,Sec-
tion15.6]haverapidlybecomethemostpopularmechanismsfor
supportingasynchrony,supplantingthepreviouserror-proneap-
proachbasedonevent-basedprogrammingandcallbacks. However,
understanding the /f_low of asynchronous execution and identifying
and/f_ixingfaultsremainchallengingfordevelopers[ 15,47,72,77].
Developers typically rely on an application’s tests to identify
faults and verify the application’s behavior. They often use code
coverage criteria such as statement and branch coverage to assess
the adequacy of their tests throughout the process, and to identify
and address the shortcomings of existing tests in order to improve
their quality [ 41,80]. However, traditional coverage criteria are
unable to examine various scenarios of exercising asynchronous
code in terms of eventual completion of asynchronous operations,
theirinteractions,andtheirerrorhandling.Despitetheimportance
of testing asynchronous programs and the severity of the issues
that occur in such programs, there are currently no code coverage
criteriathattargettheadequacyoftestswithregardtoexploring
scenarios that occur inasynchronous code.
This paper presents new coverage criteria for assessing the ade-
quacyoftestsinexercisingtheasynchronousbehaviorofJavaScript
applications. These criteria quantify the adequacy of tests in cover-
ing eventual successful or exceptional completion of asynchronous
operations,associatingreactionswiththeoutcomesofasynchro-
nousoperations,andexecutionof(chainsof)reactionsbytheap-
plication’s tests. These criteria target the semantics of JavaScript’s
promises and async/awaitfeatures, and are meant to complement
existing coveragemetrics such as statementandbranchcoverage.
We implement our approach in a plugin for Visual Studio Code
namedJScope, which presents coverage results as a textual report,
andthroughaninteractivevisualization. JScopeautomaticallyin-
strumentsan application’scodetocalculate andreportcoverage
according to three criteria, namely settlement coverage ,reaction
registration coverage ,andreaction executioncoverage .
Anevaluationof JScopeon20JavaScriptapplicationsshowsthat
theproposedcriteriacanhelpimproveassessmentoftestadequacy,
complementing traditional criteria. Furthermore, an investigation
of 15 real GitHub issues concerned with asynchrony demonstrates
thatthenewcriteriacanhelprevealfaultyasynchronousbehaviors
thatareuntestedyetaredeemedcoveredbytraditionalcoverage
criteria. We also report on a controlled experiment with 12 partici-
pantstoinvestigatetheusefulnessof JScopeinrealisticsettings,
1307
ESEC/FSE ’23, December 3ś9, 2023, San Francisco, CA, USA Mohammad Ganji, Saba Alimadadi, and Frank Tip
demonstratingthatitiseﬀectiveinimprovingprogrammers’ability
to assesstest adequacyanddetectuntestedandbuggy behavior.
In summary,this paper makesthe following contributions:
•Newcoveragecriteriathatquantifythedegreetowhichkey
scenarios are exercisedinasynchronous code,
•Aninstrumentation-basedtechniqueformeasuringcoverage
according to thesecriteria,
•Implementation of the technique in an interactive VS Code
extension named JScopethat computes a coverage report
andprovidesan interactive visualization[ 35], and
•Anempiricalevaluation,demonstratingtheabilityofthepro-
posed criteria to identify test inadequacies in asynchronous
code. We also report on a user study showing that JScope
improvestheeﬀectivenessofprogrammerswhentestingand
debuggingasynchronous code.
2 BACKGROUND
Inrecentyears,manyprogramminglanguageshavebeenextended
with support for asynchrony. For example, Java and Dart now sup-
port Futures [ 5,6], C# and Python support async/await[2,3], and
JavaScript /f_irst added promises, and then de/f_ined an async/await
feature intermsof promises. Thesenewfeatures inJavaScriptare
usedpervasivelyandpose signi/f_icant newchallenges for testing.
In this section, we provide an overview of promises and async
/await, two features that have supplanted event-driven asynchro-
nousprogramminginJavaScript.Whileourtechniquesdonotapply
directlytothelatter,anyevent-drivenAPIcanbe“promisi/f_ied”into
an equivalent promise-based one using standard library functions.
Creatingpromises. Apromiserepresentsthevalueofanasynchro-
nouscomputation, andis inone ofthree states:pending, ful/f_illed,
orrejected.Thestateofapromisecanchangeatmostonce:from
pendingtoful/f_illed,orfrompendingtorejected.Wewillsaythat
apromiseis settledifitsstateisful/f_illedorrejected.Promisesare
created by invoking the Promiseconstructor, and are initially in
the pending state. Promises come equipped with two methods,
resolve andreject, for ful/f_illing or rejecting the promise with
a particular value, respectively. For example, the following code
assigns a promise to a variable p1that is either ful/f_illed with the
value"hello"orrejectedwithan Errorobject.
1const p1 =new Promise( ( resolve , reject ) => {
2if(Math.random() > 0.5) { resolve ( " hello " ) ; }
3else { reject ( new Error('oops') ) ; }
4}) ;
Promisescanalsobeconstructedusingthefunctions Promise.
resolveandPromise.reject . Each of these functions takes a single
argument, i.e., the value that the promise should be ful/f_illed or
rejected with. The following example creates a promise that is
ful/f_illedwiththe value 3:
5const p2 = Promise. resolve (3) ;
Synchronizationfunctionssuchas Promise.all andPromise.race
areotherwaystocreatepromises.Theywaitonasetofpromises
to be settledinany order,returningasinglepromise.
Registeringreactionsonpromises. Thethenandcatchmethods
enableprogrammerstoregister reactionsonpromises,i.e.,functions
that are executed asynchronously when a promise is ful/f_illed orrejected.Thevaluereturnedbyareactioniswrappedinanother
promise,thusenablingprogrammersto chainasynchronouscom-
putations and propagate errors. For example, the following code
fragment shows the creation of a promise chain that starts with p1:
6p1.then (function f1(v) { console . log (v + " ␣world" ) ; } )
7 .catch ( f3 ( err ) { console . log ( " error ␣occurred: ␣ " + err ) ; }
Ifp1was ful/f_illed with the value "hello", the reaction that is regis-
teredbycalling thenonp1online6concatenatesthatvaluewith
anotherstring "␣world" andprintsittotheconsole,Line 7registers
arejectreactiononthepromisethatiscreatedbycalling thenon
line6. It prints an error message if any of the previous promises in
thechainisrejected.Therefore,theabove codesnippetwilleither
print"hello␣world" or"error␣occurred:␣oops" .
Linkingpromises. Invokingthe Promiseconstructorandthe then
andcatchmethodscreatesanewpromise /u1D45D.However,ifthe resolve
associated with the Promiseconstructor is invoked with an argu-
ment that evaluates to a promise /u1D45D′, or when a reaction that is reg-
isteredbycalling thenorcatchreturnsapromise /u1D45D′,thepromise
/u1D45D′becomes linkedwith/u1D45D. Assuch,if /u1D45D′isresolved with a value /u1D463,
then/u1D45Disalsoresolvedwith /u1D463,and if/u1D45D′isrejectedwith a value /u1D452,
then sois /u1D45D,andif/u1D45D′remainspending,sodoes /u1D45D.This example:
8const p3 = Promise. resolve ( " hello " )
9const p4 = Promise. resolve ( "there" )
10p3.then ( () => p4 ) // establish link with p4
11 .then ( (v) => console . log (v) ) // prints "there"
creates promises and assigns them to variables p3andp4. Given
thatp3is ful/f_illed, its reaction is executed and returns p4, sop4
andthepromisereturnedby p3.then() online10becomelinked.
Sincep4resolvesto "there", the promisereturnedby p3.then() on
line10resolves to "there"as well, causingthe reaction registered
online11to executeandprint this value.
async/await.JavaScript’s async/awaitfeatureprovidesasyntactic
enhancementontopofpromises.Afunctiondeclaredas asyncre-
turns apromise that isful/f_illedwiththe function’s return value.
In anasyncfunction, await-expressions may be used to wait for a
promise settle. If an expression /u1D452evaluates to a promise /u1D45D, then an
expression await/u1D452evaluates to /u1D463; if it is rejected with a value err,
erristhrownas an exception that can be caught using try/catch .
12async function f () {
13try {
14letv =await e;
15/∗1∗/
16 }catch (e) {/∗2∗/}
Intheaboveexample, eisanexpressionthatevaluatestoapromise
/u1D45D. The execution of the code fragment /* 1 */depends on ful/f_ill-
mentof/u1D45D.Soonemaythinkof /* 1 */asaful/f_illreactionassociated
with/u1D45D, and similarly the fragment /* 2 */as a reject reaction of /u1D45D.
3 MOTIVATION AND CHALLENGES
This section elaborates on some challenges in identifying parts
ofasynchronouscodethatdespitebeingcoveredbytests,arenot
tested“suﬃciently”andthusmayincludebugs. Weuserealbug
reports from Figures 1–2toillustrate thechallenging nature oflo-
cating bugs in asynchronous code. These challenges are intensi/f_ied
by developers’ con/f_idence in correctness of the code, when their
testsexercisethatcode.Whileexistingcoveragemetricsmayshow
1308Code Coverage Criteria for Asynchronous Programs ESEC/FSE ’23, December 3ś9, 2023, San Francisco, CA, USA
17 remove:async (req) => {
18 const dbRepo = await repo.remove(req.args)
19 if(dbRepo && dbRepo.gist) {
20 try {
21 ś webhook.remove(req)
22 + await webhook.remove(req)
23 }catch ( error ) { // handle the error } }
24 return dbRepo
25 }
Figure 1:Implementation of RepoService.remove .
fullcoverageofthesecodesegments,thesemetricsareunableto
examine the execution of scenarios speci/f_icto asynchronous code.
3.1 UnhandledExceptions
An asynchronous operation can eventually terminate successfully,
or it may fail. While a successful completion is usually the desired
outcome, the failures or exceptional cases should be tested thor-
oughly to assess the applications’ robustness and error recovery.
Exceptional scenarios are often not thoroughly tested by many
applications,whichcanleadtobugsandunexpectedbehaviorsdur-
ingexecutionshouldan exception occur [ 15]. For instance, await
expressions may be surrounded by try/catch for handling a failed
completion of the async function. However, many applications do
not have adequate exception handling in place and do not suﬃ-
cientlytestexceptionalandfailurecasesintheirasynchronouscode.
Inthefollowingexample,wediscusshowfailuretoproperlyhandle
the rejection of an asynchronous operation results in the whole
system crashing. The bug occurs despite code coverage reports
showing that the relatedpart ofthe code wasinfact covered.
3.1.1 Example 1. CLA Assistant is aweb servicethat streamlines
theprocessofsigningContributorLicenseAgreements(CLAs).1
ThisprojectisbuiltbySAPSE2developersandhasmorethan1000
stars.Thecodein Figure1showstheasyncfunction RepoService
.remove, which is responsible for removing a repository from CLA
Assistant (using repo.remove on line18) and removing all of its
webhooks ( webhook.remove ,line21).
Tohandleunexpectederrors,thecallto webhook.remove isplaced
inside a try/catch (lines20–23), which assures programmers of
the robustness of this code segment. Programmer con/f_idence in
thiscodesegmentisreinforcedbycoveringandexercisingallits
statements through the tests. Despite this, a bug was reported
whereanunhandledrejectioninthismethodresultedinthehard
shutdownoftheservice.Furtherinvestigationshowedthatwhile
thereisa try/catch inplacetohandleerrorsinremovingwebhooks,
the developers failed to awaitthe asynchronous webhook.remove
method. Without an awaitstatement, the program does not wait
for theasyncfunction to complete its execution. The execution
ofRepoService.remove could end before webhook.remove is rejected
withanerrorasynchronously.Theexceptionwasthrownoutside
the scope of RepoService.remove and thus the catchclause could
not have caughtit,causing an unhandledrejection.
The/f_ixaddsan awaitbeforewebhook.remove tomakeRepoService
.removewaituntil its completion (line 22).
1https://github.com/cla-assistant/cla-assistant
2https://sap.com26async function visibility (preview, widgetValue, params) {
27ś await new Promise(resolve = >{
28+ await new Promise((resolve, reject) = >{
29 this. trigger_up ( 'action_demand ', {
30 onSuccess: () => resolve () ,
31+ onFailure: () = >reject(),// ADDEDINFIX.
32 }) ; }) ;
33this. trigger_up ( 'option_visibility_update ', {show});
34}
Figure 2:Implementation ofasync function visibility .
3.2 Pending AsynchronousOperations
Anasynchronousoperationremainspendinguntilitis“settled”suc-
cessfullyorthroughafailure,i.e.,ful/f_illedorrejected.Itiscommon
tochainasynchronousoperationstoimposeanorderingontheir
execution. In such cases, successful and exceptional completion of
anasynchronousoperationeachtriggerrespectivereactions,and
the execution of the program continues. It is typically expected for
allasynchronousoperationsto“settle.”Incaseswherethisdoesnot
happen,theappropriatereactionsarenotinvoked,andthechain
ofexecutionisinterrupted.Thefollowingexampledemonstrates
a real bug where a pending asynchronous operation causes the
program to freeze in a loading state, preventing the users from
further interactionswiththe system.
3.2.1 Example 2. Figure 2shows changes related to a bug /f_ix from
Odoo,asuiteofweb-basedopensourcebusinessapps,including
Marketing,eCommerce,andWebsiteBuilderapps.3Ithasnearly
25K stars on GitHub and is forked over 16K times. The async func-
tionvisibility isresponsibleforupdatingthevisibilityofa/f_ield
insideawidgetinthesidebarmenuofthewebsitebuilder.Theexe-
cution of this method depends on the completion of a promise that
noti/f_ies the parent widget to toggle its visibility (lines 27–32). The
noti/f_icationoccursthrough trigger_up onlines29–32.Areaction
is assigned to this operation that is invoked upon its successful
completion,ful/f_illingthepromise(line 30).Thevisibility method
then makes the /f_ield on the widget visible, allowing the user to
interact withthe editor (line 33).
Thebugreportindicatesascenariowhereawidgetisfrozen,with
aspinnerspinningforever.Theissueoccurswhentheevent/f_iredby
trigger_up ends withan exception. Hence, the onSuccess callback
is not called to ful/f_ill the promise. As there is no reject reaction
devisedforunsuccessfulcompletionofthepromise,itneversettles.
Astheexecutionoftheremainingpartofthe visibility method
depends on the settlement of the promise, the pending promise
prevents the execution of line 33. This causes the widget to get
stuckinaloadingstate,makingthe applicationdysfunctional.
The /f_ixrejects the promise upon failure of trigger_up (line31),
whichsettlesthe promise andallowsthe executionto continue.
4 ASYNCHRONOUS COVERAGECRITERIA
Ourgoalistode/f_inecoveragecriteriathatre/f_lecttowhatextentthe
possible asynchronous behaviors of an application are exercised,
focusing on promise-based asynchrony. Figure 3illustrates the
lifecycleofapromise:Uponcreation,apromiseisinthe pending
statefromwhenceitmaytransitiontothe settledstatewhenitis
3https://github.com/odoo/odoo/pull/87123
1309ESEC/FSE ’23, December 3ś9, 2023, San Francisco, CA, USA Mohammad Ganji, Saba Alimadadi, and Frank Tip
Pendingnew Promise(…) Settledfulfill
reject
.then/.catch
register reaction .then/.catch
register reaction execute reaction 
Figure 3:Illustrationofthelifecycleofapromise.
ful/f_illed or rejected. Reactions may be registered on a promise at
anytimeinthependingorsettledstate.Suchreactionswillexecute
whenthepromiseissettled.Ourcoveragecriteriare/f_lectthekey
steps of promise settlement, promise registration, and promise
execution.Itis noteworthythatnoneof thesestepssubsumesthe
others because: (i) settlement of a promise does not imply that
reactions are registered on it, (ii) registration of a reaction of a
promise does not imply that the promise will be settled (and hence
that the reaction will execute), and (iii) execution of a reaction of a
promiserequires bothsettlementofthepromiseandregistration
ofthereaction.Further,reactionsmayberegisteredonpromises
afterthey have settled. By proposing distinct criteria for each step,
issuesthatresultinfailuretoful/f_illapromiseandfailuretoregister
areactionwillmanifestthemselves throughlackofcoverage.
We de/f_ine our criteria in terms of events in execution traces
thatpertaintotheuseofasynchronousfeatures.Wede/f_inethree
coverage criteria that target the completion of all asynchronous
operations (successful and exceptional), registration of reactions
for both outcomes of the operations, and the execution of said
reactions, respectively. We begin by de/f_ining coverage notions for
JavaScript applications that use promises, and will then explain
informally how these notions extend to async/await. Finally, we
willdiscuss the feasibilityofthesecriteria.
4.1 EventsandTraces
Table1de/f_inesthepromise-relatedeventsthatmayoccurduring
execution.Here,weassumethateachpromisethatiscreatedatrun
time hasaunique promise identi/f_ier(pid) .Further,let Sde/f_inethe
set of source locations where promises are created, including: (i)
calls to the Promiseconstructor, (ii) calls to Promise.resolve() and
Promise.reject() , (iii) calls to then,catch, andfinallyon promise
objects, (iv) calls to Promise.all ,Promise.race ,Promise.any , and
Promise.allSettled , and (v) the end of execution of an asyncfunc-
tion(eithernormal orexceptionalexit).
Createevents occur when any of situations (i)-(v) occurs. Link
eventsoccurwhenthe resolvefunctionassociatedwithacalltothe
Promiseconstructor or Promise.resolve is invoked with an argu-
mentthatisapromise.A Linkeventisalwaysimmediatelypreceded
byaCreateevent.
Ful/f_illedeventsoccurwhenthe resolvefunctionassociatedwith
aPromiseisinvokedwithanargumentthatisnotapromise,and
when a reaction returns a value that is not a promise. Likewise,
Rejectedeventsoccurwhenthe rejectfunctionassociatedwitha
Promiseisinvoked,andwhenareactionthrowsanexception.Note
thatthetraceonlyrecords Ful/f_illedandRejectedeventsforpromises
thatareexplicitlyful/f_illedorrejected(andnotforlinkedpromises).
Regful/f_illevents happen when thenis used to register a ful/f_ill-
reactiononapromise,and Regrejecteventshappenwhen catchorthe second argument of thenis used to register a reject-reaction.
Lastly,Execful/f_illandExecrejectevents happen when a previously
registeredful/f_ill-reactionorreject-reactionstartsexecuting.
4.2 Coverage CriteriaforPromise-BasedCode
In the de/f_initions that follow, pid,pid′,···represent promise iden-
ti/f_iers,/u1D453,/u1D453′,···denote functions, and loc,loc′,···denote source
locations. De/f_inition 1de/f_ines a trace as a sequence of trace events
(see Table 1). We willuse /u1D70F,/u1D70F′,···to refer to executiontraces.
Definition 1 (trace). Atraceis an ordered sequence of trace
events as speci/f_ied in Table 1.
Foreachpromise pidthatoccursinatrace /u1D70F,thereisaunique
trace element Create(pid,loc) corresponding to its creation. We
de/f_ineloc(pid)as the location locthat is referenced in this trace
element.The/f_irstcoveragecriterionwede/f_ineis settlementcover-
age.This measures the fractionof promises de/f_inedbyan applica-
tion that are settled (i.e., ful/f_illed or rejected). Here, we consider
a promise pidoriginating from location locto be fully covered if
the trace contains both Ful/f_illedandRejectedevents for pid, which
requireslocation loctobeexecutedatleasttwice.Moreover,whena
Ful/f_illedorRejectedeventisobservedforapromise pid,allpromises
directly or indirectly linked with pidare settled as well. To capture
this,we/f_irstde/f_ine L(pid,/u1D70F)todenotethesetofpromiseslinked
topidintrace/u1D70F.
Definition2(linkedpromises). Letpidbethepromiseidenti/f_ier
for a promise. Then, the set of promises linked to pidin a trace /u1D70F,
denoted by L(pid,/u1D70F), is de/f_ined as:
L(pid,/u1D70F)={pid′|pid′=pid or
∃loc:Link(pid,pid′,loc)∈/u1D70F,pid′∈ L(pid,/u1D70F)}
Notethat piditself isalsoan element of L(pid,/u1D70F).
Using De/f_inition 2, we now de/f_ine the notion of settlement cov-
erage as stated in De/f_inition 3. Informally, the de/f_inition computes
the number of locations loc′of promises pid′that are linked to a
promisepidforwhicha Ful/f_illedoraRejectedeventoccursinthe
trace/u1D70F.Itthendividesthesumoftheseby 2∗ |S|,whereSisthe
number oflocations where apromise iscreated.
Definition 3 (settlement coverage). Let program Pcreate
promisesatlocationsin S,andlet/u1D70Fbethetraceforanexecutionof
P.Wede/f_inethe settlement coverage of/u1D70Fas:
|{loc′|Ful/f_illed(pid,loc) ∈/u1D70F,pid′∈ L(pid,/u1D70F),loc′=loc(pid′)}|+
|{loc′|Rejected(pid,loc) ∈/u1D70F,pid′∈ L(pid,/u1D70F),loc′=loc(pid′)}|
2∗ |S|
Ournextgoalistomeasurethepercentageofpromisesonwhich
reactions are registered. Here, we consider a promise fully covered
if both a ful/f_ill reaction and a reject reaction are registered on it.
However, we need to consider that the rejection of a promise /u1D45D
maybehandledbyarejectreactionthatisnotregistereddirectly
on/u1D45Ditself,but at the end of apromise chain that starts with /u1D45D.To
capture this, we de/f_ine the set of dependent promises pidthat occur
at the end of a chain of ful/f_ill-reactions that starts at pid. In such
cases,we willwrite pid⇝pid′,as de/f_inedbelowinDe/f_inition 4.
1310Code Coverage Criteria for Asynchronous Programs ESEC/FSE ’23, December 3ś9, 2023, San Francisco, CA, USA
Table 1:Traceevents forasynchronousoperations.
Create(pid,loc) creationofpromise pidat location loc
Ful/f_illed(pid, loc) promisepidis ful/f_illed at location loc
Rejected(pid, loc) promisepidis rejected at location loc
Link(pid,pid′,loc) promisepidbecomeslinked to promise pid′at location loc
Regful/f_ill(pid,/u1D453,loc, [pid′])register ful/f_ill reaction /u1D453on promise pidat location loc, whichmay chain it to promise pid′
Regreject(pid,/u1D453,loc, [pid′])register rejectreaction /u1D453on promise pidat location loc, whichmay chain it to promise pid′
Execful/f_ill(pid,/u1D453, loc) execute ful/f_ill reaction /u1D453on promise pidat location loc
Execreject(pid,/u1D453, loc) execute rejectreaction /u1D453on promise pidat location loc
Definition 4 (dependent promises). Let program Pcreate
promisesatlocationsin S,andlet/u1D70Fbethetraceforanexecutionof
P.Then:
pid⇝pid′if/braceleftbiggpid≡pid′or
pid⇝pid′′andRegful/f_ill(pid′′,loc,/u1D453,pid′)
UsingDe/f_inition 4,De/f_inition 5belowcomputesreactionregistra-
tion coverage through the following steps: (i) compute the number
oflocations loc′whereaRegful/f_illeventoccursonapromise pidfor
whichaCreateeventoccursinthetrace,(ii)computethenumber
of locations loc′where aRegrejectevent occurs on a promise pid′,
wherepid⇝pid′,andwherea Createeventfor pidoccursinthe
trace,and(iii) compute the sum ofthese,anddivide itby 2∗ |S|.
Definition5(reactionregistrationcoverage). Letprogram
Pcreate promises at locations in S, and let/u1D70Fbe the trace for an
executionof P.Wede/f_inethe reactionregistrationcoverage of/u1D70Fas:
|{loc′|Create(pid,loc) ∈/u1D70F,Regful/f_ill(pid,/u1D453,loc′,pid′) ∈/u1D70F}| +
|{loc′|Create(pid,loc) ∈/u1D70F,pid⇝pid′,Regreject(pid′,/u1D453,loc′,pid′′) ∈/u1D70F}|
2∗ |S|
Lastly, we de/f_ine the notion of reaction execution coverage , mea-
suring the percentage of promises with executed reactions. This is
expressedbyDe/f_inition 6below,whichissimilartoDe/f_inition 5,
except that it checks for the presence of Execful/f_illandExecreject
events in the trace instead of Regful/f_illandRegrejectevents. Achiev-
ing full reaction execution coverage for a promise created at loc
requires that locisexecutedat leasttwice.
Definition6(reactionexecutioncoverage). Letprogram P
createpromiseatlocationsin S,andlet/u1D70Fbethetraceforanexecution
ofP.Wede/f_inethe reactionexecutioncoverage of/u1D70Fas:
|{loc′|Create(pid,loc) ∈/u1D70F,Execful/f_ill(pid,/u1D453,loc’) ∈/u1D70F}| +
|{loc′|Create(pid,loc) ∈/u1D70F,pid⇝pid′,Execreject(pid′,/u1D453,loc’) ∈/u1D70F}|
2∗ |S|
4.3 async/await
The semantics of JavaScript’s async/awaitis de/f_ined in terms of
promises, and provides a more convenient syntax that is highly
similar to that of sequential code. An asyncfunction always re-
turnsapromise,thusuponcallsto asyncfunctionsa Createevent
is included in the trace. When an asyncfunction returns a value
that is not a promise, a Ful/f_illedevent is included in the trace to re-
/f_lect its ful/f_illment. A Rejectedevent is emitted if an asyncfunction
throwsanexceptionthatisnotcaughtwithinitsbody. Thecode
fragmentfollowingan awaitstatementwillbeconsideredaful/f_ill
reactionforthepromise /u1D45Dreturnedbythe asyncfunction,andthus
aRegful/f_illevent will be added to the trace. If the await-expressionis in atry/catch , thecatchstatement will be the reject reaction,
i.e.,aRegrejectevent.If/u1D45Disful/f_illed,thenan Execful/f_illeventisemit-
ted. Otherwise, the catchstatement executes and an Execrejectis
recorded in the trace. Assuming these trace elements, the same
coveragede/f_initionsapply.
4.4 Example
Consider thefollowing codedisplaying function funand itstests.
35function fun(inputStr ) {
36 const p1 =new Promise((resolve) => {
37 resolve (JSON.parse(inputStr ) ) ;
38 }) .then (function f1(data) {
39 console . log (data.foo .bar)
40 }) ; }
41// Tests :
42 test ( "T1: ␣ inputStr ␣ is ␣ valid ␣JSON" , () => {
43 fun('{" foo ": ␣ {" bar ": ␣ "Hello ."}} ') ; })
44 test ( "T2: ␣ inputStr ␣ is ␣not␣a␣ valid ␣JSON" , () => {
45 fun('Hello .') ; })
In orderto measure fun’s asynccoverage criteria,we /f_irstobtain
the following trace.
46Create (/u1D45D/u1D456/u1D451/u1D45D1, L36:L38) // Start of T1
47Ful/f_illed (/u1D45D/u1D456/u1D451/u1D45D1, L37:L37)
48Create (/u1D45D/u1D456/u1D451/u1D461/uni210E/u1D452/u1D45B , L38:L40) // Promise.then() returns a promise
49Regful/f_ill(/u1D45D/u1D456/u1D451/u1D45D1, f1, L38:L38, /u1D45D/u1D456/u1D451/u1D461/uni210E/u1D452/u1D45B )
50Ful/f_illed (/u1D45D/u1D456/u1D451/u1D461/uni210E/u1D452/u1D45B , L38:L40)
51Execful/f_ill(/u1D45D/u1D456/u1D451/u1D45D1, f1, L38:L40)
52Create (/u1D45D/u1D456/u1D451′
/u1D45D1, L36:L38) // Start of T2
53Rejected (/u1D45D/u1D456/u1D451′
/u1D45D1, L37:L37) // Error thrown by JSON.parse() rejects p1.
54Create (/u1D45D/u1D456/u1D451′
/u1D461/uni210E/u1D452/u1D45B, L38:L40)
55Regful/f_ill(/u1D45D/u1D456/u1D451′
/u1D45D1, f1, L38:L38, /u1D45D/u1D456/u1D451′
/u1D461/uni210E/u1D452/u1D45B)
We then identify two unique promises from the traces obtained
fromT1andT2.The promisecreatedatL36:L38achieves full(2/2)
settlementcoveragewitha Ful/f_illedeventinT1anda Rejectedevent
inT2.However,thepromisecreatedatL38:L40achievespartial(1/2)
settlementcoveragewithonlyone Ful/f_illedeventinT1.Basedon
theobserved Regful/f_illandRegrejectevents,thetwopromisesachieve
partial (1/2) and minimal (0/2) reaction registration coverage, re-
spectively. reaction execution coverage can also be measured in
a similar manner. Overall, we calculate a total of 75% settlement
coverage, 25% reaction registration coverage, and 25% reaction exe-
cution coverage for function fun. To achieve full coverage, a reject
reactionneedstoberegisteredtobothpromises(e.g.,addinga catch
at the end of the chain). The reaction then needs to be executed
throughanewly-writtentest that rejectsthe promise at L38:L40.
1311ESEC/FSE ’23, December 3ś9, 2023, San Francisco, CA, USA Mohammad Ganji, Saba Alimadadi, and Frank Tip
Figure 4: JScopecoverage results forCLAAssistant. The open editorshows RepoService.remove inrepo.js.
4.5 Feasibility ofAsynchronousCoverage
Criteria
The proposed coverage criteria for asynchronous programs are
similartotraditionalcoveragecriteriainthesensethat100%cov-
erage,whiledesirable,isnotalwaysattainable.Forexample,ina
conditionalstatement if/u1D438then/u1D4461else/u1D4462,ifthecondition /u1D438always
evaluates to true, then the else-branch and all the statements in
/u1D4462areunreachable,andbranchcoverageandstatementcoverage
willbe less than100%.
Analogously,inacodefragment e.then(···),whereeisanex-
pressionthat evaluates to apromise /u1D45D,the promise createdbythe
calltothenwillremainpendingif /u1D45Disneverful/f_illedcausingsettle-
mentcoverage toremain lessthan 100%,andreactionregistration
coverage and reaction execution coverage may remain below 100%
for similar reasons. Similar scenarios arisefor asyncfunctions.
5 APPROACH
In this section, we describe our approach and our tool, JScope, for
automaticallymeasuringandvisualizingasynchronouscoverage
criteriaas de/f_inedin section4.2 .Wewill usetheterm“asynccov-
erage” to refer to the results of settlement, reaction registration,
and reaction execution coverage combined, as JScopecalculates
and reports them collectively. Our approach relies on the instru-
mentationofasynchronousbehaviorsofaJavaScriptapplication
onthe/f_ly. JScopeexecutes theinstrumented codethroughthe ap-
plication’s test suite to collect execution traces. Next, it utilizes the
traces to locate promises, their reactions, and relations between
them such as chains as means to calculate async coverage. Finally,
JScopepresents the results and relevant warnings in terms of a
textual report and an interactive visualization, embedded within
the developmentenvironment ofVisualStudioCode.4
5.1 InstrumentationandTraceCollection
To automatically collect trace events described in Table 1for a
program,weinstrumentthebehaviorofJavaScriptpromisesand
asyncfunctionsonthe/f_ly.Executingtheinstrumentedcodethrough
runningtheprogram’stestsuite,weobtainatraceofeventscreated
as discussedin section 4.1 .
4https://code.visualstudio.com5.2 MeasuringAsynchronousCoverage
Aspromisescanonlybesettledonce,atleasttwotestsarerequired
to achieve full async coverage for a promise. As such, we uniquely
identify a promise based on its static creation location in the code.
Multiple Createevents with the same location across several test
executionsinatestsuitewillbeconsideredasthesamepromise.
Insuchcases,coveragereportedby JScopeshouldbeinterpreted
accordingly. In particular, if full settlement coverage is reported
for a promise created at location /u1D43F, then this means that at least
one promise created at /u1D43Fwas ful/f_illed, and at least one promise
created at /u1D43Fwas rejected, meaning that both possible outcomes
were observed.
Wethenintegratediﬀerentexecutionpathscorrespondingtothe
same promise to locate its various settlements, registered reactions
andexecutionofsuchreactions. Ouranalysismaymisspromisesin
unexercised parts of code due to the incomplete nature of dynamic
analysis. However, the low traditional coverage of these parts will
warnthedevelopers/f_irst.Assuch,asynccoverageismosteﬀective
when usedcomplementary to the existing coveragecriteria.
Next, we detect relations between promises such as promise
chainsandlinkedpromises.Byde/f_inition,arejectreactionatthe
endofachainiscapableofcatchingallexceptionscausedbyany
promiseinthatchain.Inordertohaveamorepreciserepresenta-
tion of suﬃcient error handling, our algorithm propagates a reject
reaction in a chain to all of its ancestor promises. Additionally, for
promisesreturnedby catch,weonlyrequire Ful/f_illedevent,andthe
rest are considered covered. This implies that registering reactions
forcatchisoptional,asendingchainswitha catchisagenerally
acceptedwayofusingpromises.Similarly,toavoidunresolvable
missingcoveragewarnings, Regful/f_illeventsareoptionalfor then.
Without these heuristics achieving 100% async coverage would be
impossible,astherewillalwaysbeonepromisewithoutanyhan-
dlersattheendofanychain.Ouralgorithmalsodetectspromise
linksbylocatingwhereapromise /u1D45D1isful/f_illedwithpromise /u1D45D2,
andapplies all Ful/f_illedandRejectedeventsof /u1D45D2to/u1D45D1as well.
Finally, we calculate and visualize the overall async coverage
bycombiningasynccoverageofallpromises,andreportalistof
warnings for allpromises’ missingreactions.
1312Code Coverage Criteria for Asynchronous Programs ESEC/FSE ’23, December 3ś9, 2023, San Francisco, CA, USA
Table 2:Summary ofdiﬀerentcoverage metrics reported by JScopeandtraditionalcoverage.
Application Objects Traditional Coverage AsychronousCoverage
Name LOC #Tests #Promises Statement(%) Function(%) Branch(%) Settlement(%) Registration(%) Execution(%)
1. NodeFetch 2475 392 12 97 100 94 74 68 59
2. CLAAssistant 20406 315 225 94 94 84 59 76 56
3. MinipassFetch 1523 57 20 100 100 100 69 53 53
4. Cacache 1878 95 99 100 100 100 66 66 55
5. GithubActionMergeDependabot 485 42 10 100 100 100 100 100 100
6. Co 470 43 10 99 100 98 84 94 94
7. DeleteEmpty 272 20 8 91 100 80 47 77 46
8. JSON Schema RefParser 3070 256 34 88 88 78 80 92 78
9. AsyncCacheDedupe 1476 120 13 100 100 100 56 83 57
10. Environment 4374 328 64 81 76 72 51 70 51
11. SocketClusterServer 2044 72 52 82 70 70 62 50 41
12. SocketClusterClient 10648 37 13 73 54 53 68 45 36
13. Minipass 840 131 10 100 100 100 87 50 25
14. Grant 2756 495 29 98 97 89 58 70 56
15. ExpressHTTPProxy 798 106 57 96 97 87 70 100 80
16. Install 556 31 7 98 98 95 46 100 78
17. Cachegoose 224 27 8 91 92 79 43 80 30
18. Enquirer 10491 179 88 68 63 61 51 49 43
19. Avvio 5460 180 13 94 95 91 50 56 37
20. Matched 274 30 9 96 100 78 60 100 64
AVERAGE 3385 144 39 92 91 85 64 74 57
5.3 VisualizingtheAsynchronousCoverage
WedesignedaninteractivevisualizationintegratedinVSCode,a
widelyuseddevelopmentenvironment,basedondatagatheredfrom
apreliminaryuserstudyweconducted.Userscaninvoke JScope
ondemand( Figure4,A)topresenttheresultsasatextualreport
(Figure 4, B&C) and visual cues overlayed on the code ( Figure 4,
D–F).JScopesummarizesasynccoverageresultsinthe Coverage
Overview panel to help with overall understanding of async cov-
erage(Figure4,B&C).Theoverviewincludesclickablewarnings,
linkedtothelocationsoftheirrespectivepromises. JScopeoverlays
relevantvisualcuesonthecodeintheeditor.Ithighlightspromises
using a red-yellow-green “color spectrum” to determine their level
ofasynccoverage( Figure4,D).Assuch,thepromiseinline82is
markedred,indicatingminimalasynccoverage.Similarly,thegreen
and yellow highlights on line 92 and 87 indicate fully and partially
covered promises, respectively. Users can obtain more details on
the warnings on demand, by hovering the mouse over warning
cues (Figure 4, E&F). By leveraging the integration of focus within
the context [ 25], we help maintain programmers’ mentalmodel of
the overallprogram whileworkingwithindividualpromises.
5.4 Implementation
We used NodeProf.js [ 71] for instrumentation and used JavaScript
Proxiestointercepttheexecutionofbuilt-infeaturesforsettling
promises and registering their reactions [ 10]. We utilized program-
matic APIs of Mocha [ 8] and Tap [ 9] testing frameworks for au-
tomatic execution of apps and VSCode’s extension development
APIto integrate JScopeinto its editor. In ourimplementationof
coverage criteria as per section 4, functions /u1D453that create and re-
turnanewpromiseobject(similarto util.promisify )aretreated
specially: When a call to /u1D453is encountered, a Createevent is gen-
erated for that call and the promise creation inside /u1D453is ignored.
This custom notion of context-sensitivity [ 43,79] during identi-
fying promise-creation sites generally results in lower coverage.
However,theresults are more actionable as theyenabledetecting
lackofcoveragewhenpromisesarecreatedusinghelperfunctions.6 EVALUATION
In order for our new coverage criteria to be useful, they should
be able to reveal untested asynchronous behaviors that are not de-
tectedbytraditionalcoveragecriteria.Tothisend,we/f_irstmeasure
coverageaccordingtothenewcriteriafor20JavaScriptapplications,
and study correlations with traditional coverage criteria. Next, we
reportonexperimentsthataimtodetermine(i)whetherthenew
coveragecriteriaidentifyuncoveredcodethatcontainsbugs,and(ii)
whether using JScopecan improve developers’ performance when
performing tasks related to assessing test adequacy and debugging.
Our evaluation targets the following research questions:
RQ1.Does having high traditional coverage imply adequate
testingofasynchronous code?
RQ2.Howcanasynchronouscoveragecriteriafacilitateidenti-
fyingtest inadequaciesregarding faultyasynchronous code?
RQ3.Howdoesusing JScopehelpimprovedevelopers’perfor-
mance inassessing test adequacyanddebugging?
RQ4.Whatisthe performance overheadof JScope?
6.1 AsynchronousCoverage
To answer RQ1, weranJScopeon 20web applications,measured
three types of asynchronous coverage criteria and studied their
correlations withtraditional coveragemetrics.
6.1.1 Experimental Design and Procedure. We adopted a similar
approach to Zhou et al. [ 81] and Davis et al. [ 27] in selecting 20
open-sourceJavaScriptapplicationsfromGitHub.Theseprojects
used promises and/or async/awaitconsiderably, were accompanied
by reasonable test suites, and were compatible with Graal.js [ 7].
They represented various sizes, domains, and architectures and the
average statement coverage of the benchmark applications was
92%. We ran JScopeon the subjects by automatically exercising
them through their tests. We measured the results of the three
asynchronouscoveragemetrics,andcalculatedstatement,function,
andbranchcoverageusingIstanbul,5apopularJavaScriptcoverage
5https://istanbul.js.org/
1313ESEC/FSE ’23, December 3ś9, 2023, San Francisco, CA, USA Mohammad Ganji, Saba Alimadadi, and Frank Tip
Table 3: Correlation coeﬃcients for asynchronous and tradi-
tionalcoverage criteria.
Statement Function Branch Settlement Registration Execution
Settlement 0.20 0.10 0.26 1 0.11 0.48
Registration 0.49 0.56 0.35 0.11 1 0.79
Execution 0.31 0.33 0.29 0.48 0.79 1
tool.Wethenexaminedthepossiblecorrelationsofourproposed
asynchronous coveragecriteriawiththesetraditional criteria.
6.1.2 Results andDiscussion. The results are displayed in Table 2.
The /f_irstfourcolumnsshow anapplication’sname, LOC,number
of tests, and number of promise objects observed in the analysis,
respectively.Thenextthreecolumnsdepicttheresultsoftraditional
coveragecriteria,i.e.,statement,function, andbranchcoverage.
Overall,thebenchmarkshadrelativelyhightraditionalcoverage
scores,withanaverageof92%,91%,and85%statement,function,
and branch coverage, respectively. However, it can be seen that
settlement,reaction registration,and reaction execution coverage
scores were much lower, with an average of 64%, 74%, and 57%,
respectively. This means that, on average, the test suite of a typical
JavaScriptapplication /u1D44Eexercises92%ofthestatementsbutabout
65% of the expected outcomes of its promises and async functions.
/u1D44Emaynot even register over25% of necessaryreactionsfor async
operations. Even fewer reactions are actually exercised through
tests.
Next, we examined the potential correlations between asyn-
chronousandtraditionalcoverage.WeusedtheKendallrankcorre-
lationcoeﬃcient,whichdoesnotassumeanormaldistribution.The
results,depictedin Table3,shownostrongcorrelationsbetween
traditional and asynchronous coverage metrics. This indicates that
traditional coverage metrics are not necessarily equipped for iden-
tifying the suﬃcient execution of asynchronous scenarios through
tests. In other words, covering more lines or functions does not im-
ply covering more of the asynchronous behavior of an application.
Overall,whilethehightraditionalcoveragescoresraisecon/f_idence
insuﬃcienttestingofthecode,theyarenotequippedwithidentifying
shortcomings of the tests in asynchronous scenarios. For instance,
while 92% of the statements are exercised on average, only 57% of the
expected reactionsofasynchronousoperations areinvoked.
6.2 AsynchronousCoverage andTest
Eﬀectiveness
Toaddress RQ2,weused JScopeandIstanbultoexaminebothtypes
of coverage for code snippets related to previously resolved issues
onGitHub. Amainapplicationofcoveragecriteriaisidentifying
code segments that may contain bugs due to insuﬃcient coverage,
which can be helpful during debugging. As such, given a set of
known bugs, we investigated (1) if traditional coverage criteria
raise warnings about inadequate testing of faulty asynchronous
code and(2) if JScopecould have helpeddiscover thesebugs.
6.2.1 Experimental Design and Procedure. We searched the reposi-
tories of the projects in Table 2for issues that 1)involvedpromises
and/or async/await, 2) were closed with the /f_ixes linked to the
relevantcommits,and3)hadcompletestatementcoverageintheTable 4:Asynchrony-related JavaScript issues fromGithub.
CommitAppCategory Settlement RegistrationExecution Statement
1.#f56491a express-http-proxy Unhandled Exp. 63 96 74 95
2.#d902776 cla-assistant Unhandled Exp. 58 75 55 94
3.#8ﬀ7de7 streamroller Unhandled Exp. 60 81 67 100
4.#8e94a60 eslint_d.js Unhandled Exp. 70 65 65 89
5.#6bcf8ca check/f_ire Unhandled Exp. 40 55 40 -
6.#ﬀf6640 postgres Unhandled Exp. 71 83 60 91
7.#2fc9693 haraka Unhandled Exp. 25 33 33 -
8.#e5615da ioredis Unhandled Exp. 76 69 55 95
9.#146bb3b install Unhandled Exp. 50 100 62 98
10.#0dﬀf52 json-schema-ref-parserUnhandled Exp. 80 91 81 94
11.#cbcdfc6 socketcluster-server Unhandled Exp. 63 50 43 79
12.#dfbafbf clamscan PendingOp. 58 89 62 40
13.#48a2ddf cla-assistant BrokenChain 58 75 55 94
14.#b0a86d4 avvio BrokenChain 38 58 38 93
15.#68342f8 libnpmteam Unnecessary Async. 40 83 61 100
version before the /f_ix. We found seven bugs in six of the reposi-
tories. We expanded our search to real bugs from other projects
on GitHub that met our requirements. We selected a total of 15
bugs. We then ran JScopeon two versions of each project, one
immediately before and one immediately after each bug /f_ix. We
usedJScope’s output to investigate the inadequacies of the tests in
exercising the asynchronous behavior in code segments related to
eachbug.
6.2.2 ResultsandDiscussion. Table4displaystheresults.Columns
1–3 show the commit pertaining to the bug /f_ix, the application
name,andthebugcategory,respectively.Thenextthreecolumns
displaytheasynccoveragenumbersbeforethe/f_ix.Thelastcolumn
showsstatementcoveragebefore the /f_ix, reportedbyIstanbul.js.
Overall,JScopereportedinsuﬃcientcoverageandrelevantwarn-
ingsforallbugs,addressingwhichcouldhavehelpeddetectand/f_ix
thebugsbeforedeployment.Statementcoverage,however,showed
nosignofwarningorinsuﬃcienttestingforanyofthebugsortheir
relevant code segments. Next, we discuss the main categories of
studiedbugsanddescribehow JScope’sreportsandwarningscould
have bene/f_itedthe bug/f_indingprocessthroughtwoexamples.
Unhandled Exceptions. Developers often neglect to test excep-
tionalexecutionsofasynchronousoperations[ 15].Whilecurrent
coverage criteria can indicate insuﬃcient testing of conditions and
branches,theyareunabletodetectinsuﬃcienttestingofalternative
scenariosforasynchronousoperations,suchasmissingreactions
for rejectedasynchronous operations ormissingerrorhandling.
(Example A) Eslint_d.js is an application that daemonizes ES-
Lint[4]forhigherperformanceandhas>30kweeklydownloads
on the NPM registry ( Table 4, row4). It caches a single linter ob-
ject to reduce overhead. Line 272 of the left code snippet in Fig-
ure5-Ashowshowtheasyncfunction getCache isinvokedtoasyn-
chronouslyretrieveacachedESLintlinterobjectfromagivenpath.
The program, using await, waits until this promise ful/f_ills. A bug
wasreportedinthismethoddespitethefullcoverageofthiscode
segmentbythetests,asdepictedbythegreenmarkingsbytheline
numbers.Itstatedthattheapplicationcrasheswithanunhandled
promiseexceptionifthepathgivento getCache cannotberesolved.
The proposed /f_ix added a try/catch around the call to getCache
toallowhandlingexceptionscausedbytherejectedpromiseand
preventfurthercrashes( Figure5-A,rightsnippet,lines273–278).
1314Code Coverage Criteria for Asynchronous Programs ESEC/FSE ’23, December 3ś9, 2023, San Francisco, CA, USA
Figure 5: JScoperesults (highlightsandwarnings overlayed on code) vs.Istanbulresults (markingsby the line numbers).
Acorrespondingtestwasalsoaddedtothetestsuitethatsimulates
the exception andexercises the catchblock(lines275-278).
Thisbughadremainedundetectedinproductionforfourmonths.
However,running JScopeonthefaultyversionofthecodereported
insuﬃcientcoverageintermsofamissingrejectreactionforthe
promisereturnedby getCache,shownasthe highlightedcodeon
line 272 and the "Missing error handler" warning message box
(Figure5-A).Havinghadaccessto JScopeduringtestingcouldhave
helpedreveal this bugbefore production.
Ourresultsin Table4showedmultipleinstancesofunhandled
exceptions, similarly missed by the applications’ tests. Row 3is
an example where developers managed to achieve 100% statement
coverage, while still failing to detect a missing reject reaction caus-
ingacrash.Considerour/f_irstmotivatingexamplefrom section3.1 .
Ambiguousreports mentionthe sameissuetwoyearsbeforethe
/f_ix. The issue persisted to a point where it had damaged the users’
trust, withausercallingCLAAssistantaphishingtool.6
BrokenPromiseChains. JavaScriptprogramswillnotwaitforthe
completion of asynchronous operations, unless explicitly speci/f_ied.
Inotherwords,theexecutionofoperationsthatdependonthecom-
pletionofapromiseisreliantonproperlychainingthemthrough
promisereactionsor awaitstatements. Developerscan mistakenly
break the chain of asynchronousoperationsby not awaitingtheir
completion [ 47]. This may alter the /f_low of execution leading to
undesired outcomes. Moreover, the outcome of the promise will
not be used, and potential exceptions will not be caught, which
can lead to a myriad of issues in programs. Our /f_irst motivating
exampledisplayedacasewerethismistakeledtotheCLAAssistant
application crashing, caused by an unhandled exception thrown by
an un-awaitedpromise ( section 3.1 ).
(Example B) Row13ofTable 4shows another issue in CLA
Assistant.RepositoriesthatuseCLAAssistantmayrequirecontrib-
utorstosignaContributorLicenseAgreement(CLA)throughCLA
Assistant’swebinterface.WhenausersignsaCLAthroughCLAAs-
sistant’swebinterface, handleWebhook is invoked(partiallyshown
inFigure5-B).Uponinvocationofthe asyncfunction updateForCla-
NotRequired (line146),apromiseisreturnedthatasynchronously
communicatesthestatusupdateonthesignaturetoGitHubservers.
Itthen sends acon/f_irmationto the user(line153).
6https://github.com/cla-assistant/cla-assistant/issues/[561,691, and 822]Users had reported issues where the web interface shows an
updatedstatusforapullrequest,whereasonGitHub,therepository
isstillpendingCLAAssistant’supdate.Twootherprecedingissues
vaguely report the same bugbut were unable to reproduce it.7
JScopereported low async coverage for the promise on line 146
beforethe/f_ix( Figure5-B).Thewarningstatesthatthepromisehas
notsettledandhasnoreactions,suggestinga/f_ixthroughadding
athenorawaitstatement.This matches the /f_ix providedby the de-
velopers for the original issue, which added an awaitbefore the call
toupdateForClaNotRequired towaitforthefunction’scompletion
before sendingaresponse to user(line146).
Pending Operations. If not explicitly settled, asynchronous oper-
ationsremain pending,causing nonterminationormemoryleaks.
Suchproblemsoftenhappenasaresultofdeveloperstreatingasyn-
chronous code similar to synchronous code, such as incorrectly
callingreturninside the promise executor function to denote its
completion instead of calling resolveas is the case in Table 4,
row12. For these cases, JScopereports missing ful/f_illment and low
settlement coveragefor the pendingpromise.
Unnecessary Asynchrony. Developers may complicate code by
usingpromiseswhereasynchronyisnotrequired.Theymayalso
nestpromises,causingunanticipatedbrokenpromisechains.While
generally less severe, JScopewarns abouttheir missing rejections.
Overall,asynccoveragecriteriacaneﬀectivelyexposetestinad-
equacies related to asynchrony that are not detected by traditional
coverage metrics. As such, JScopecan help identify parts of code that
contain asynchrony-related bugs in practice despite being covered by
traditional coverage.
6.3 Usefulness ofAsynchronousCoverage to
Developers
To address RQ3, we conducted a controlled user experiment to
investigate the eﬀectiveness of JScopein helping programmers
identifyanddebug (un)coveredJavaScript code.
6.3.1 ExperimentalDesignandProcedure. Ourexperimenthada
“between-subject” design to avoid the carryover eﬀect. We divided
ourparticipantsintotwo groups: controlandexperimental groups.
Theexperimental grouphadaccessto asimpli/f_iedand web-based
7https://github.com/cla-assistant/cla-assistant/issues/[520, 697]
1315ESEC/FSE ’23, December 3ś9, 2023, San Francisco, CA, USA Mohammad Ganji, Saba Alimadadi, and Frank Tip
Table 5:Tasks used intheuserstudy.
Task Description
T1.A Identifying suﬃciently tested functions
T1.B Identifying less robust functions(i.e.not suﬃciently tested)
T2.A Locating all promises created duringtesting
T2.B Identifying promises thatare not properlytested
T3.A Identifying theunderlying causes ofa failure
T3.B Findingthe/f_ixto thefailure
version of JScoperesults. Both groups had access to the code, as
wellasstatementcoverageresultsfromIstanbul,loadedonourweb-
baseduserinterfacewithastyle similar to JScopefor consistency.
Variables. OurIndependent Variable is the type of tool used,
referredtoas Toolfromhereon,whichisanominalvariablewith
twolevels: JScopeandIstanbul.Wehavetwocontinuous Dependent
Variables thatrepresentthedevelopers’performanceincompleting
the tasks: taskcompletion duration(seconds) andaccuracy(%).
Participants. Wesentoutrecruitmentemailstograduatestu-
dents’mailinglists.Fromthereplies,weselectedtheoneswhomet
ourknowledgerequirementsofJavaScriptdevelopmentandtesting.
Themajorityofourparticipantshadamedium-levelexpertisein
JavaScriptprogramming,andfamiliaritywithtesting. Werecruited
sixmaleandsixfemaleparticipants,aged21–35,consistingof10
graduatestudentsandtwosoftwareengineers,with1–5yearsofex-
perience in software development. We assigned them randomly to
experimental and control groups. We balanced the expertise based
onourparticipants’responsestoapre-questionnaire( section6.3.1 ).
Experimental Object. We used a simpli/f_ied version of the
body.js/f_ilefromNodeFetch,8alibraryimplementingbrowsers’
window.fetch inNode.js.Forthedebuggingtask,wechosea/f_ixed
bug from Docusaurus, a website building application.9The unhan-
dledrejectreactionbug,coveredbythetests,ledtosilentfailureof
the wholeapplication.
Tasks.We designed three tasks that pertained to test adequacy
andqualityassessment( Table5).T1andT2weredesignedtoassess
eﬀectivenessoftoolinhelpingprogrammersidentifywell-tested
and insuﬃciently tested functions and promises. T3 was designed
toinvestigatetheusefulnessof Toolinhelpingparticipantsidentify
the underlying causes ofthe bug(T3.A) andpropose a/f_ix(T3.B).
Pre-study. All participants /f_illed a pre-questionnaire form prior
totheirsession,indicatingtheirdemographicinformationandtheir
experienceinprogramming,JavaScriptdevelopment,andtesting,
and self-assessed pro/f_iciency levels. We used this data to fairly
balance the participants between groups. All participants signed a
consent formedprior to starting the study.
Training. The participants were given refresher tutorials on
main concepts of asynchronous JavaScript, coverage , and Istanbul,
to ensure consistency in the knowledge required for completing
thetasks..Theexperimentalgroupalsoreceivedatutorialonusing
JScope. Bothgroupsweregivensometimetofamiliarizethemselves
withthe toolsandthe setupofthe experiment.
TaskCompletion. Next,theparticipantsstartedperformingthe
tasks (Table5). The participants were allowed to interact with the
codeandthetoolsandwritetheiranswersonaGoogleDocshared
withtheexaminer.Wemeasuredthe durationduringthesession
8https://github.com/node-fetch/node-fetch
9https://github.com/facebook/Docusaurus/issues/238by providing each task to the participants individually, which they
returnedaftercompletingthetask.Tomeasure accuracy,weused
pre-de/f_inedrubricsto markthe responses later.
Post-study. Afterthesession,theparticipantsrespondedtoa
post-questionnaire form with qualitative data on usefulness of the
Toolusedandits limitations.
6.3.2 Results and Discussion. We ran the Shapiro-Wilk normality
testonthe data,and sincethe distributions werenot normal, we
used Mann-Whitney U tests to analyze the results. The results
showed a statistically signi/f_icant diﬀerence (28% on average) on
thetotalaccuracyofresponsesfortheexperimentalgroupusing
JScope(Mean=95%,STDDev=9%),comparedtothecontrolgroup
(Mean=74%,STDDev=12%).
Theresultsalsoshowedthecontrolgroupspentslightlylesstime
intotal(Mean=33:56,STDDev=4:35),comparedtotheexperimental
group(Mean=36:29,STDDev=5:01),althoughthediﬀerencewasnot
statistically signi/f_icant. Theexperimentalgroupspent an average
of 12:43, 7.58, and 7:54 minutes for completing T1, T2, and T3,
respectively. Thecontrolgroupspent6:42, 11:58, 9:12minutes for
performingthesametasks,onaverage. Theresultsofindividual
tasksshowedthatalthoughtheexperimentalgroupspentmoretime
for completing T1 compared to the control group, they performed
all other tasks faster (14%–33% on average). It was expected for the
experimentalgrouptospendmoretimeonT1duetotheadditional
learning curve incurred by their unfamiliarity with JScope, and
theystillachievedanaverageof33%higheraccuracyforT1.Forthe
remaining tasks, the experimental group performed consistently
fasterthanthe controlgroup,whileachievinghigher accuracy.
More Accurate Assessment of Test Eﬀectiveness. The tasks
involvedperformingvariousactivitiesincludinggeneralfunction
coveragetomorespeci/f_icpromisecoverage,forallofwhich JScope
showedtoimprovetheaccuracyoftheparticipants.Wehadhypoth-
esizedthat JScopewouldbemostusefulfortasksdirectlyinvolving
asynchronous interactions. For instance, T2 involved examining
promisesandasync/awaitstatements,whereweexpected JScope
tobehelpful.Using JScopehelpedtheexperimentalgroupperform
signi/f_icantly better for T2. They completed this tasks 33% faster
(p=0.02) and30%more accurately (p=0.04) onaverage.
Debugging. Theeﬀectivenessoftestsisdirectlydependentonits
bug/f_indingcapability.Coveragemetricsdonotdirectlyattributeto
identifyingand/f_ixingbugs.However,theycanfacilitatetheprocess
byguidingprogrammerstowardsthelesstestedportionsofthecode
thatmaycontainbugs.Using JScopehelpedtheexperimentalgroup
indebuggingtoachievemoreaccurateanswerswhilespendingless
timelocatingtheunderlyingcausesofafailure(T3.A)and/f_indinga
/f_ix (T3.B). The results were statistically signi/f_icant for the accuracy
oftheproposed/f_ix(T3.B)whereexperimentalgroupachievedan
averageof37%higher accuracy(p=0.03).
Participants feedback. Overall, the experimental group found
JScopeuseful.Inparticular,theylikedtheoverviewofthecoverage
report,interactionswiththeoverlayedvisualcues,andthewarning
messagesthat guidedthemtowardsmissingfunctionalityortests.
Overall,participantsusing JScopeperformed28%moreaccurately
in testingand debuggingasynchronouscode.
1316Code Coverage Criteria for Asynchronous Programs ESEC/FSE ’23, December 3ś9, 2023, San Francisco, CA, USA
6.4 Performance
Wemeasuredtheperformanceof JScopeintermsofitsoverhead
of instrumentation and test suite execution time by averaging /f_ive
executionsofeachtestsuite,withandwithout JScope.Ouranalysis
for the applicationsin Table2indicates amedian of31 secondsof
instrumentation(23–97seconds).Theslowdownfactorforexecu-
tionoftheinstrumentedcodegenerallyranges2x–100x(median:
15.5x). The slowdown is similar to other instrumentation-based
dynamicanalysesfor JavaScript [ 15,38,72].
6.5 Threatsto Validity
Therearethreatspertainingtotherepresentativenessofourpar-
ticipants, benchmark projects, or issues. We addressed these by
randomly selecting participants who met the minimum experience
requirements and projects of diﬀerent sizes from diﬀerent domains
that met the prerequisites for using JScope. To mitigate the ex-
aminer’sbiasinouruserstudy,wedelegatedthetimekeepingto
the participants, allowing them to decide the start and end time of
eachtaskbyhandingthemthetasksseparatelyandaskingthem
to return it afterwards. We de/f_ined detailed rubrics for grading the
accuracyoftheresultspriortothestudytoaddressasimilarbiasin
measuringparticipants’accuracy.Wetriedtoalleviatetheimpactof
expertiselevelinourstudybybalancingtheparticipants’expertise
levels based on their responses to our pre-questionnaire. We made
JScopeandourexperimentaldataavailabletoallowreproducibility.
7 RELATED WORK
While being the most prominent test quality assessment technique
[82],code coverage criteria have always been under scrutiny
abouttheireﬀectiveness[ 31,39–41].Thegenericnatureoftradi-
tionalcoveragecriteriahasledtotheemergenceofvariousdomain-
speci/f_ic coverage criteria [ 16,44,51,68,69,74]. Several coverage
metricshavebeenintroducedusingdata-/f_lowtotargetconcurrency
in actor-based [ 75], concurrent [ 67], and distributed programs [ 62].
Researchers have proposed novel criteria for dynamic web applica-
tions[49,58,83,84],orlooselytypednatureofJavaScript [ 22],or
DOM elements [ 56]. None of these techniques, however, address
the asynchronous executionandits respective challenges.
Event-dependentandasynchronouscallbacksformamajorityof
untested code in JavaScript [ 31]. Prior work has used static analy-
sisto modelevent-drivenJavaScript[ 47,48,70].Otherworkhasfo-
cusedonconstructingpromisegraphsthatexpresstherelationships
between promises and relevant code [ 47] and detecting promise
anti-patternsbasedonpromisegraphs[ 15].toidentifyperformance-
related anti-patterns involving promises [ 77] . Arteca et al. [ 20]
presentarefactoringforenablingadditionalconcurrencybysplit-
tingandmoving awaitexpressions,andGokhaleetal.[ 37]presenta
refactoringformigratingapplicationsfromtheuseofsynchronous
APIs to equivalent asynchronous APIs. Moreover, dynamic anal-
ysishas been popularly used in JavaScript [ 13,14,45,60,76] to
address the imprecision of static analysis in analyzing JavaScript’s
inherent dynamism [ 17]. Much research in this area targets un-
derstanding, debugging, and testing techniques for programs in
general[15,24,30,38,57,64,72][21,28,32,46,52,53,73],andmore
recently for asynchronous JavaScript in particular [ 15] [72][64]. A
long line of research projects has focused on the detection andremediationofeventraces[ 11,12,29,61],concurrencybugs[ 78],
andschedulefuzzersforevent-drivenprograms[ 26]. Theextensive
research on bug detection and comprehension of asynchrony con-
/f_irms our argument for the necessity of test adequacy criteria that
takeintoaccounttheasynchronyinJavaScriptandotherlanguages.
Visualization has been eﬀectively used for comprehension and
modelingevent-drivenandasynchronousprograms[ 13–15,76,77].
SimilartoSeifertetal.[ 64],weleveragededitorintegrationtofa-
cilitatethecomprehensionofasynchronouscoveragethroughan
interactive interface.
Codecoverageiscrucialinevaluatingtheeﬀectivenessof test
generation techniquessuchasfeedback-directedrandomtesting
[19,59,65], dynamic symbolic execution [ 23,36,66], and search-
basedandevolutionarytechniques[ 33,34].Nessie[ 19]isafeedback-
directedtestgenerationtoolforJavaScriptthattargetsevent-driven
asynchrony. Event-driven asynchrony is rapidly being supplanted
bypromisesand async/awaitbecausethesefeaturesleadtoamore
readable and less error-prone code. However, Nessie does not pro-
videspecialsupport for promises and async/await.
Mutation testing is also used as an alternative approach for
measuringtestquality[ 42,50].Despitetheireﬀectiveness,mutation
testing for JavaScript is typically very costly, and has yet to gain
the popularity ofcode coverage[ 18,54,55,63].
8 CONCLUDINGREMARKS
Inthispaper,weproposedasetofcoveragecriteriaforassessingthe
adequacy of tests with respect to asynchronous program behavior.
Wedesignedaninteractivevisualizationandimplementedatoolto
allow programmersto viewasync coverage resultsin a typicalde-
velopment environment. The results of our evaluation showed that
asynccoveragemetricsarecomplementarytotraditionalmetrics
andcanhelpprogrammersdetectinsuﬃcienciesoftestsandrelated
bugsinasynchronouscodewheretraditionalmetricscannot.Our
user experiment also demonstrated that our tool helps improve
developers’performanceintasksrelatedtoassessingtestquality
anddebuggingofasynchronous code.
The coverage criteria presented in this paper are designed for
JavaScript.Aswaspointedoutin section2,similarfeatureshave
been added to various programming languages [ 2,3,5,6], and
adaptingthecoveragecriteriatotheselanguagesisaninteresting
futuredirection.Anotheravenueforfutureworkisthedevelopment
of test generation techniques that aim to improve asynchronous
coverage. For example, one could imagine extending Nessie [ 19]
to register reactions on promises returned by function calls in
previously generatedtests.
9 DATA AVAILABILITY
JScopeandour experimental data are publiclyavailable [ 35].
ACKNOWLEDGMENTS
ThisworkwassupportedinpartbyanNSERCDiscoveryGrantand
NationalScienceFoundationgrantCCF-1907727.Wearegrateful
to the participants ofour controlledexperiments.
1317ESEC/FSE ’23, December 3ś9, 2023, San Francisco, CA, USA Mohammad Ganji, Saba Alimadadi, and Frank Tip
REFERENCES
[1]2021. ECMAScript2021LanguageSpeci/f_ication. https://www.ecma-international.
org/ecma-262/ .
[2]2022. AsynchronousprogrammingwithAsyncandAwait. https://docs.microsoft.
com/en-us/dotnet/visual-basic/programming-guide/concepts/async/ Accessed
Aug-2022.
[3]2022. Awaitables, python documentation. https://docs.python.org/3/library/
asyncio-task.html#awaitables Accessed Jan-2023.
[4]2022. Eslint:PluggableJavaScriptLinter. https://www.npmjs.com/package/eslint
Accessed Jan-2023.
[5]2022. Future(JavaPlatformSE8). https://docs.oracle.com/javase/8/docs/api/
java/util/concurrent/Future.html Accessed Aug-2022.
[6]2022. Future<T> class. https://api.dart.dev/stable/2.18.7/dart-async/Future-
class.html Accessed Jan-2023.
[7] 2022. GraalvmNode.js Runtime. https://istanbul.js.org/ Accessed Aug-2023.
[8]2022. Mocha,thefun,simple,/f_lexibleJavaScripttestframework. https://mochajs.
orgAccessed Sep-2022.
[9] 2022. NodeTap. https://node-tap.org Accessed Sep-2022.
[10]2022. Proxy - JavaScript. https://developer.mozilla.org/docs/Web/JavaScript/
Reference/Global_Objects/Proxy Accessed Sep-2022.
[11]Christoﬀer Quist Adamsen, Anders Møller, Saba Alimadadi, and Frank Tip. 2018.
Practical AJAX race detection for JavaScript web applications. In Proceedings of
the 2018 ACM Joint Meeting on European Software Engineering Conference and
Symposium on the Foundations of Software Engineering, ESEC/SIGSOFT FSE 2018,
LakeBuenaVista,FL,USA,November04-09,2018 ,GaryT.Leavens,Alessandro
Garcia, and Corina S. Pasareanu(Eds.).ACM,38–48.
[12]Christoﬀer Quist Adamsen, Anders Møller, Rezwana Karim, Manu Sridharan,
Frank Tip, and Koushik Sen. 2017. Repairing event race errors by controlling
nondeterminism. In Proceedings of the 39th International Conference on Software
Engineering,ICSE2017,BuenosAires,Argentina,May20-28,2017 ,SebastiánUchitel,
AlessandroOrso, and Martin P. Robillard (Eds.).IEEE / ACM,289–299.
[13]Saba Alimadadi, Ali Mesbah, and Karthik Pattabiraman. 2016. Understanding
AsynchronousInteractions in Full-StackJavaScript. In 2016 IEEE/ACM 38th Inter-
nationalConference onSoftwareEngineering (ICSE) . 1169–1180.
[14]Saba Alimadadi, Sheldon Sequeira,Ali Mesbah,and Karthik Pattabiraman. 2014.
Understanding JavaScript Event-Based Interactions. In Proceedings of the 36th
International Conference on Software Engineering (Hyderabad, India) (ICSE 2014) .
Associationfor Computing Machinery, NewYork, NY, USA,367–377.
[15]SabaAlimadadi,DiZhong,MagnusMadsen,andFrankTip.2018. FindingBroken
Promises in Asynchronous JavaScript Programs. Proc. ACM Program. Lang. 2,
OOPSLA, Article162(oct 2018),26pages.
[16]P. Ammann, J. Oﬀutt, and Hong Huang. 2003. Coverage criteria for logical
expressions. In 14th International Symposium on Software Reliability Engineering,
2003. ISSRE 2003. 99–107.
[17]Esben Andreasen, Liang Gong, Anders Møller, Michael Pradel, Marija Selakovic,
KoushikSen,andCristian-AlexandruStaicu.2017. ASurveyofDynamicAnalysis
and Test Generation for JavaScript. ACM Comput. Surv. 50, 5, Article 66 (sep
2017),36pages.
[18]J.H.Andrews,L.C.Briand,andY.Labiche.2005. IsMutationanAppropriateTool
for TestingExperiments?.In Proceedingsof the 27thInternational Conference on
Software Engineering (St. Louis, MO, USA) (ICSE ’05) . Association for Computing
Machinery, NewYork, NY, USA,402–411.
[19]Ellen Arteca, Sebastian Harner, Michael Pradel, and Frank Tip. 2022. Nessie:
Automatically Testing JavaScript APIs with Asynchronous Callbacks. In 44th
IEEE/ACM44thInternationalConferenceonSoftwareEngineering,ICSE2022,Pitts-
burgh,PA, USA, May 25-27, 2022 . ACM,1494–1505.
[20]Ellen Arteca, Frank Tip, and Max Schäfer. 2021. Enabling Additional Parallelism
in Asynchronous JavaScript Applications (Artifact). Dagstuhl Artifacts Series 7, 2
(2021), 5:1–5:6.
[21]Shay Artzi, Julian Dolby, Simon Holm Jensen, Anders Møller, and Frank Tip.
2011. AFrameworkforAutomatedTestingofJavascriptWebApplications.In
Proceedings ofthe33rdInternationalConferenceonSoftware Engineering (Waikiki,
Honolulu, HI, USA) (ICSE ’11) . Association for Computing Machinery, New York,
NY, USA,571–580.
[22]Sora Bae, Joonyoung Park,and Sukyoung Ryu. 2017. Partition-Based Coverage
Metrics and Type-Guided Search in Concolic Testing for JavaScript Applica-
tions.InProceedingsofthe5thInternationalFMEWorkshoponFormalMethods
inSoftwareEngineering (BuenosAires,Argentina) (FormaliSE’17) .IEEEPress,
72–78.
[23]Cristian Cadar, Vijay Ganesh, Peter M. Pawlowski, David L. Dill, and Dawson R.
Engler. 2006. EXE: automaticallygeneratinginputs ofdeath.In Proceedingsof
the13thACMConferenceonComputerandCommunicationsSecurity,CCS2006,
Alexandria,VA,USA,October30-November3,2006 ,AriJuels,RebeccaN.Wright,
and Sabrina DeCapitani di Vimercati (Eds.).ACM,322–335.
[24]XiaoningChang,WenshengDou,JunWei,TaoHuang,JinhuiXie,YuetangDeng,
JianboYang,andJiahengYang.2021. RaceDetectionforEvent-DrivenNode.js
Applications. In 2021 36th IEEE/ACM International Conference on Automated
SoftwareEngineering (ASE) . 480–491.[25]Andy Cockburn, Amy Karlson, and Benjamin B. Bederson. 2009. A review of
overview+detail, zooming, and focus+context interfaces. Comput.Surveys 41,1,
Article2 (2009), 31pages.
[26]James C. Davis, Arun Thekumparampil, and Dongyoon Lee. 2017. Node.fz:
Fuzzing the Server-Side Event-Driven Architecture. In Proceedings of the Twelfth
EuropeanConference on Computer Systems, EuroSys 2017,Belgrade, Serbia,April
23-26, 2017 , Gustavo Alonso, Ricardo Bianchini, and Marko Vukolic (Eds.). ACM,
145–160.
[27]JamesC.Davis,EricR.Williamson,andDongyoonLee.2018. ASenseofTime
for JavaScript and Node.js: First-Class Timeouts as a Cure for Event Handler
Poisoning. In 27th USENIX Security Symposium (USENIX Security 18) . USENIX
Association, Baltimore, MD, 343–359.
[28]MonikaDhok,MuraliKrishnaRamanathan,andNishantSinha.2016.Type-Aware
Concolic Testing of JavaScript Programs. In Proceedings of the 38th International
Conference on Software Engineering (Austin, Texas) (ICSE ’16) . Association for
Computing Machinery, NewYork, NY, USA,168–179.
[29]André Takeshi Endo and Anders Møller. 2020. NodeRacer: Event Race Detection
forNode.jsApplications.In 13thIEEEInternationalConferenceonSoftwareTesting,
ValidationandVeri/f_ication,ICST2020,Porto,Portugal,October24-28,2020 .IEEE,
120–130.
[30]Amin Milani Fard and Ali Mesbah. 2013. JSNOSE: Detecting JavaScript Code
Smells.In 2013IEEE13thInternationalWorkingConferenceonSourceCodeAnalysis
and Manipulation (SCAM) . 116–125.
[31]AminMilaniFardandAliMesbah.2017. JavaScript:The(Un)CoveredParts.In
2017IEEEInternationalConferenceonSoftwareTesting,Veri/f_icationandValidation
(ICST). 230–240.
[32]Amin MilaniFard, Ali Mesbah, and Eric Wohlstadter. 2015. Generating Fixtures
for JavaScript Unit Testing. In Proceedings of the 30th IEEE/ACM International
Conference on Automated Software Engineering (Lincoln, Nebraska) (ASE ’15) .
IEEE Press,190–200.
[33]Gordon Fraser and Andrea Arcuri. 2011. Evolutionary Generation of Whole Test
Suites. In Proceedings of the 11th International Conference on Quality Software,
QSIC 2011, Madrid, Spain, July 13-14, 2011 , Manuel Núñez, Robert M. Hierons,
and Mercedes G.Merayo(Eds.).IEEE Computer Society, 31–40.
[34]GordonFraserandAndreaArcuri.2011. EvoSuite:automatictestsuitegeneration
for object-oriented software. In SIGSOFT/FSE’11 19thACM SIGSOFT Symposium
on the Foundations of Software Engineering (FSE-19)and ESEC’11: 13th European
Software Engineering Conference (ESEC-13), Szeged, Hungary, September 5-9, 2011 ,
TiborGyimóthyand Andreas Zeller (Eds.).ACM,416–419.
[35]MohammadGanji,SabaAlimadadi,andFrankTip.2023. [Artifact]CodeCoverage
Criteria for Asynchronous Programs (JScope) .https://doi.org/10.5281/zenodo.
8271643
[36]PatriceGodefroid,NilsKlarlund,andKoushikSen.2005. DART:directedauto-
matedrandomtesting.In ProceedingsoftheACMSIGPLAN2005Conferenceon
Programming Language Design and Implementation, Chicago, IL, USA, June 12-15,
2005, VivekSarkar and MaryW. Hall (Eds.).ACM,213–223.
[37]SatyajitGokhale,AlexiTurcotte,andFrankTip.2021. Automaticmigrationfrom
synchronous to asynchronous JavaScript APIs. Proc. ACM Program. Lang. 5,
OOPSLA (2021), 1–27.
[38]Liang Gong, Michael Pradel, Manu Sridharan, and Koushik Sen. 2015. DLint:
Dynamically Checking Bad Coding Practices in JavaScript. In Proceedings of the
2015InternationalSymposiumonSoftwareTestingandAnalysis (Baltimore,MD,
USA)(ISSTA 2015) . Association forComputing Machinery, New York, NY, USA,
94–105.
[39]Hadi Hemmati.2015. HowEﬀective Are Code Coverage Criteria?. In 2015 IEEE
InternationalConference onSoftwareQuality, Reliability and Security . 151–156.
[40]Michael Hilton, Jonathan Bell, and Darko Marinov. 2018. A Large-Scale Study of
TestCoverageEvolution . AssociationforComputingMachinery,NewYork,NY,
USA,53–63.
[41]Laura Inozemtseva and Reid Holmes. 2014. Coverage is Not Strongly Correlated
withTestSuiteEﬀectiveness.In Proceedingsofthe36thInternationalConferenceon
Software Engineering (Hyderabad, India) (ICSE 2014) . Association for Computing
Machinery, NewYork, NY, USA,435–445.
[42]YueJiaandMarkHarman.2011. AnAnalysisandSurveyoftheDevelopment
of Mutation Testing. IEEE Transactions on Software Engineering 37, 5 (2011),
649–678.
[43]VineethKashyap,KyleDewey, EthanA.Kuefner,JohnWagner,KevinGibbons,
JohnSarracino,BenWiedermann,andBenHardekopf.2014. JSAI:AStaticAnaly-
sisPlatformforJavaScript.In Proceedingsofthe22ndACMSIGSOFTInternational
Symposium on Foundations of Software Engineering (Hong Kong, China) (FSE
2014). Associationfor Computing Machinery, NewYork, NY, USA,121–132.
[44]Kenneth Koster and David Kao. 2007. State coverage: A structural test adequacy
criterionfor behaviorchecking. 541–544.
[45]DingLi,JamesMickens,SumanNath,andLeninRavindranath.2015. Domino:
Understanding Wide-Area, Asynchronous Event Causality in Web Applications.
InProceedingsof the Sixth ACM Symposiumon CloudComputing (Kohala Coast,
Hawaii)(SoCC ’15) . Association for Computing Machinery, New York, NY, USA,
182–188.
1318Code Coverage Criteria for Asynchronous Programs ESEC/FSE ’23, December 3ś9, 2023, San Francisco, CA, USA
[46]GuodongLi,EsbenAndreasen,andIndradeepGhosh.2014. SymJS:Automatic
SymbolicTestingofJavaScriptWebApplications.In Proceedingsofthe22ndACM
SIGSOFT International Symposium on Foundations of Software Engineering (Hong
Kong,China) (FSE2014) .Associationfor Computing Machinery,NewYork, NY,
USA,449–459.
[47]MagnusMadsen,OndřejLhoták,andFrankTip.2017. AModelforReasoning
about JavaScript Promises. Proc. ACM Program. Lang. 1, OOPSLA, Article 86 (oct
2017),24pages.
[48]MagnusMadsen,Frank Tip,andOndřejLhoták.2015. StaticAnalysisofEvent-
DrivenNode.jsJavaScript Applications.In Proceedings ofthe2015ACMSIGPLAN
InternationalConferenceonObject-OrientedProgramming,Systems,Languages,
and Applications (Pittsburgh, PA, USA) (OOPSLA 2015) . Associationfor Comput-
ingMachinery, NewYork, NY, USA,505–519.
[49]Alberto Martin-Lopez, Sergio Segura, andAntonio Ruiz-Cortés.2019. TestCover-
ageCriteriaforRESTfulWebAPIs . AssociationforComputingMachinery,New
York, NY, USA,15–21.
[50]author.Memon,Atif.2019. MutationTestingAdvances:AnAnalysisandSurvey .
Advances in Computers, Vol. 112. Academic Press„ Cambridge, MA :.
[51]Atif M. Memon, Mary Lou Soﬀa, and Martha E. Pollack. 2001. Coverage Criteria
for GUI Testing. SIGSOFTSoftw. Eng.Notes 26,5 (sep 2001),256–267.
[52]AminMilaniFard,MehdiMirzaaghaei,andAliMesbah.2014. LeveragingExisting
Tests in Automated Test Generation for Web Applications. In Proceedings of
the29thACM/IEEE InternationalConference onAutomated SoftwareEngineering
(Vasteras, Sweden) (ASE ’14). Association for Computing Machinery, New York,
NY, USA,67–78.
[53]Shabnam Mirshokraie and Ali Mesbah. 2012. JSART: JavaScript Assertion-Based
Regression Testing. In Web Engineering , Marco Brambilla, Takehiro Tokuda, and
RobertTolksdorf(Eds.).SpringerBerlinHeidelberg,Berlin,Heidelberg,238–252.
[54]ShabnamMirshokraie,AliMesbah,andKarthikPattabiraman.2013. PYTHIA:
Generating test cases with oracles for JavaScript applications. In 2013 28th
IEEE/ACM International Conference on Automated Software Engineering (ASE) .
610–615.
[55]Shabnam Mirshokraie, Ali Mesbah, and Karthik Pattabiraman. 2014. Guided
mutationtesting for JavaScript webapplications. IEEE Transactions on Software
Engineering 41,5 (2014), 429–444.
[56]MehdiMirzaaghaeiandAliMesbah.2014. DOM-BasedTestAdequacyCriteria
for Web Applications. In Proceedings of the 2014 International Symposium on
SoftwareTesting and Analysis (San Jose, CA, USA) (ISSTA 2014) .Association for
Computing Machinery, NewYork, NY, USA,71–81.
[57]ErdalMutlu,SerdarTasiran,andBenjaminLivshits.2015. DetectingJavaScript
RacesThatMatter.In Proceedingsofthe201510thJointMeetingonFoundationsof
Software Engineering (Bergamo, Italy) (ESEC/FSE 2015) . Association for Comput-
ingMachinery, NewYork, NY, USA,381–392.
[58]HungNguyen,HungPhan,ChristianKästner,andNguyenTien.2019. Exploring
output-based coverage for testing PHP web applications. Automated Software
Engineering 26(03 2019).
[59]Carlos Pacheco, Shuvendu K. Lahiri, Michael D. Ernst, and Thomas Ball. 2007.
Feedback-Directed Random Test Generation. In 29th International Conference on
SoftwareEngineering(ICSE2007),Minneapolis,MN,USA,May20-26,2007 .IEEE
Computer Society, 75–84.
[60]OhadRau,Caleb Voss,andVivek Sarkar.2021. LinearPromises: TowardsSafer
ConcurrentProgramming.In 35thEuropean Conferenceon Object-OrientedPro-
gramming(ECOOP2021) (LeibnizInternationalProceedings inInformatics(LIPIcs),
Vol. 194), Anders Møller and Manu Sridharan (Eds.). Schloss Dagstuhl – Leibniz-
Zentrumfür Informatik, Dagstuhl,Germany, 13:1–13:27.
[61]Veselin Raychev, Martin T. Vechev, and Manu Sridharan. 2013. Eﬀective race
detectionforevent-drivenprograms.In Proceedingsofthe2013ACMSIGPLAN
InternationalConferenceonObjectOrientedProgrammingSystemsLanguages&
Applications,OOPSLA2013,partofSPLASH2013,Indianapolis,IN,USA,October
26-31, 2013 , Antony L. Hosking, Patrick Th. Eugster, and Cristina V. Lopes (Eds.).
ACM,151–166.
[62]Christopher Robinson-Mallett,RobertM.Hierons, and PeterLiggesmeyer.2006.
Achieving Communication Coverage in Testing. SIGSOFT Softw. Eng. Notes 31, 6
(nov2006),1–10.
[63]DiegoRodríguez-BaqueroandMarioLinares-Vásquez.2018. Mutode:Generic
JavaScript and Node.Js Mutation Testing Tool. In Proceedings of the 27th ACM
SIGSOFT International Symposium on Software Testing and Analysis (Amsterdam,
Netherlands) (ISSTA2018) .AssociationforComputingMachinery,NewYork,NY,
USA,372–375.
[64]DominikSeifert,MichaelWan,JaneHsu,andBensonYeh.2022.AnAsynchronous
Call Graph for JavaScript. In 2022 IEEE/ACM 44th International Conference on
SoftwareEngineering: SoftwareEngineering inPractice (ICSE-SEIP) . 29–30.
[65]Marija Selakovic, Michael Pradel, Rezwana Karim, and Frank Tip. 2018. Test
generationforhigher-orderfunctionsindynamiclanguages. Proc.ACMProgram.
Lang.2,OOPSLA (2018), 161:1–161:27.
[66]Koushik Sen, Darko Marinov, and Gul Agha. 2005. CUTE: a concolic unit testing
engineforC.In Proceedingsofthe10thEuropeanSoftwareEngineeringConferenceheldjointlywith13thACMSIGSOFTInternationalSymposiumonFoundationsof
Software Engineering, 2005, Lisbon, Portugal, September 5-9, 2005 , Michel Wer-
melinger and HaraldC. Gall (Eds.).ACM,263–272.
[67]Elena Sherman, Matthew B. Dwyer, and Sebastian Elbaum. 2009. Saturation-
Based Testing of Concurrent Programs. In Proceedings of the 7th Joint Meeting of
the European Software Engineering Conference and the ACM SIGSOFT Symposium
onTheFoundationsofSoftwareEngineering (Amsterdam,TheNetherlands) (ES-
EC/FSE ’09) . Association for Computing Machinery, New York, NY, USA, 53–62.
[68]S. Sinha and M.J. Harrold. 1999. Criteria for testing exception-handling con-
structsinJavaprograms.In ProceedingsIEEEInternationalConferenceonSoftware
Maintenance-1999 (ICSM’99).’SoftwareMaintenanceforBusinessChange’(Cat.
No.99CB36360) . 265–274.
[69]KhashayarEtemadiSomeoliayi,SajadJalali,MostafaMahdieh,andSeyed-Hassan
Mirian-Hosseinabadi. 2019. Program State Coverage: A Test Coverage Metric
Based on Executed Program States. In 2019 IEEE 26th International Conference on
SoftwareAnalysis, Evolutionand Reengineering (SANER) . 584–588.
[70]Thodoris Sotiropoulos and Benjamin Livshits. 2019. Static Analysis for Asyn-
chronousJavaScriptPrograms.In 33rdEuropeanConferenceonObject-Oriented
Programming, ECOOP 2019, July 15-19, 2019, London, United Kingdom (LIPIcs,
Vol. 134), Alastair F. Donaldson (Ed.). Schloss Dagstuhl - Leibniz-Zentrum für
Informatik,8:1–8:30.
[71]Haiyang Sun, Daniele Bonetta, Christian Humer, and Walter Binder. 2018. Ef-
/f_icient Dynamic Analysis for Node.Js. In Proceedings of the 27th International
Conference on Compiler Construction (Vienna, Austria) (CC 2018) . Association for
Computing Machinery, NewYork, NY, USA,196–206.
[72]HaiyangSun,DanieleBonetta,FilippoSchiavio,andWalterBinder.2019. Rea-
soning about the Node.Js Event Loop Using Async Graphs. In Proceedings of the
2019IEEE/ACMInternationalSymposiumonCodeGenerationandOptimization
(Washington, DC, USA) (CGO 2019) . IEEE Press,61–72.
[73]Haiyang Sun, Andrea Rosà, Daniele Bonetta, and Walter Binder. 2021. Auto-
maticallyAssessingandExtendingCodeCoverageforNPMPackages.In 2021
IEEE/ACM International Conference on Automation of Software Test (AST) . 40–49.
[74]YouchengSun,XiaoweiHuang,DanielKroening,JamesSharp,MatthewHill,and
RobAshmore.2019. StructuralTestCoverageCriteriaforDeepNeuralNetworks.
ACMTrans. Embed.Comput. Syst. 18,5s,Article94(oct 2019),23pages.
[75]SamiraTasharo/f_i,MichaelPradel,YuLin,andRalphJohnson.2013.Bita:Coverage-
guided,automatictestingofactorprograms.In 201328thIEEE/ACMInternational
Conference onAutomatedSoftwareEngineering (ASE) . 114–124.
[76]EnaTominaga,YoshitakaArahori,andKatsuhikoGondow.2019. AwaitViz:A
Visualizer of JavaScript’s Async/Await Execution Order. In Proceedings of the
34thACM/SIGAPP SymposiumonAppliedComputing (Limassol, Cyprus) (SAC
’19). Associationfor Computing Machinery, NewYork, NY, USA,2515–2524.
[77]AlexiTurcotte,MichaelD.Shah,MarkW.Aldrich,andFrankTip.2022. DrAsync:
Identifying and Visualizing Anti-Patterns in Asynchronous JavaScript. In Pro-
ceedings of the 44th International Conference on Software Engineering (Pittsburgh,
Pennsylvania) (ICSE’22) . Association for ComputingMachinery, NewYork, NY,
USA,774–785.
[78]Jie Wang, Wensheng Dou, Yu Gao, Chushu Gao, Feng Qin, Kang Yin, and Jun
Wei.2017. AcomprehensivestudyonrealworldconcurrencybugsinNode.js.In
Proceedingsofthe32ndIEEE/ACMInternationalConferenceonAutomatedSoftware
Engineering,ASE2017, Urbana,IL,USA,October 30-November03, 2017 ,Grigore
Rosu,MassimilianoDiPenta,andTienN.Nguyen(Eds.).IEEEComputerSociety,
520–531.
[79]ShiyiWeiand BarbaraG.Ryder. 2015. Adaptive Context-sensitive Analysisfor
JavaScript.In 29thEuropeanConferenceonObject-OrientedProgramming(ECOOP
2015) (LeibnizInternationalProceedingsin Informatics(LIPIcs), Vol.37) ,JohnTang
Boyland (Ed.). Schloss Dagstuhl–Leibniz-Zentrum fuer Informatik, Dagstuhl,
Germany, 712–734.
[80]Yucheng Zhang and Ali Mesbah. 2015. Assertions Are Strongly Correlated
with Test Suite Eﬀectiveness. In Proceedings of the 2015 10th Joint Meeting on
FoundationsofSoftwareEngineering (Bergamo,Italy) (ESEC/FSE2015) .Association
for Computing Machinery, NewYork, NY, USA,214–224.
[81]Jingyao Zhou, Lei Xu, Gongzheng Lu,WeifengZhang, andXiangyu Zhang. 2023.
NodeRT:DetectingRacesinNode.JsApplicationsPractically.In Proceedingsof
the32ndACMSIGSOFTInternationalSymposiumonSoftwareTestingandAnalysis
(Seattle, WA, USA) (ISSTA 2023) . Association for Computing Machinery, New
York, NY, USA,1332–1344.
[82]Hong Zhu, Patrick A. V. Hall, and John H. R. May. 1997. Software Unit Test
Coverageand Adequacy. ACMComput. Surv. 29,4 (dec1997),366–427.
[83]YunxiaoZou,ZhenyuChen,YunhuiZheng,XiangyuZhang,andZebaoGao.2014.
VirtualDOMCoverageforEﬀectiveTestingofDynamicWebApplications.In
Proceedings of the 2014 International Symposium on Software Testing and Analysis
(SanJose,CA,USA) (ISSTA2014) .AssociationforComputingMachinery,New
York, NY, USA,60–70.
[84]YunxiaoZou,ChunrongFang,ZhenyuChen,XiaofangZhang,andZhihongZhao.
2013. AHybrid CoverageCriterion for DynamicWeb Testing (S). In SEKE.
1319