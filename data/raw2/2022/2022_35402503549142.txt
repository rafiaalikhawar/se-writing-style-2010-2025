Cross-Language Android Permission Specification
Chaoran Li
Swinburne University of Technology
Australia
chaoranli@swin.edu.auXiao Chenâˆ—
Monash University
Australia
xiao.chen@monash.eduRuoxi Sun
The University of Adelaide
Australia
ruoxisun278@gmail.com
Minhui Xue
CSIROâ€™s Data61
Australia
minhuixue@gmail.comSheng Wenâˆ—
Swinburne University of Technology
Australia
swen@swin.edu.auMuhammad Ejaz Ahmed
CSIROâ€™s Data61
Australia
ejaz629@gmail.com
Seyit Camtepe
CSIROâ€™s Data61
Australia
seyit.camtepe@data61.csiro.auYang Xiang
Swinburne University of Technology
Australia
yxiang@swin.edu.au
ABSTRACT
The Android system manages access to sensitive APIs by permission
enforcement. An application (app) must declare proper permissions
before invoking specific Android APIs. However, there is no official
documentation providing the complete list of permission-protected
APIs and the corresponding permissions to date. Researchers have
spent significant efforts extracting such API protection mapping
from the Android API framework, which leverages static code analy-
sis to determine if specific permissions are required before accessing
an API. Nevertheless, none of them has attempted to analyze the
protection mapping in the native library ( i.e., code written in C
and C++), an essential component of the Android framework that
handles communication with the lower-level hardware, such as
cameras and sensors. While the protection mapping can be utilized
to detect various security vulnerabilities in Android apps, such
as permission over-privilege, imprecise mapping will lead to false
results in detecting such security vulnerabilities. To fill this gap,
we thereby propose to construct the protection mapping involved
in the native libraries of the Android framework to present a com-
plete and accurate specification of Android API protection. We
develop a prototype system, named NatiDroid , to facilitate the
cross-language static analysis and compare its performance with
two state-of-the-practice tools, termed Axplorer andArcade . We
evaluate NatiDroid on more than 11,000 Android apps, includ-
ing system apps from custom Android ROMs and third-party apps
from the Google Play. Our NatiDroid can identify up to 464 new
API-permission mappings, in contrast to the worst-case results de-
rived from both Axplorer andArcade , where approximately 71%
âˆ—Corresponding authors: Sheng Wen and Xiao Chen.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior specific permission and/or a
fee. Request permissions from permissions@acm.org.
ESEC/FSE â€™22, November 14â€“18, 2022, Singapore, Singapore
Â©2022 Association for Computing Machinery.
ACM ISBN 978-1-4503-9413-0/22/11. . . $15.00
https://doi.org/10.1145/3540250.3549142apps have at least one false positive in permission over-privilege.
We have disclosed all the potential vulnerabilities detected to the
stakeholders.
CCS CONCEPTS
â€¢Security and privacy â†’Mobile platform security .
KEYWORDS
Android, permission, cross-language analysis, native code
ACM Reference Format:
Chaoran Li, Xiao Chen, Ruoxi Sun, Minhui Xue, Sheng Wen, Muhammad
Ejaz Ahmed, Seyit Camtepe, and Yang Xiang. 2022. Cross-Language Android
Permission Specification. In Proceedings of the 30th ACM Joint European
Software Engineering Conference and Symposium on the Foundations of Soft-
ware Engineering (ESEC/FSE â€™22), November 14â€“18, 2022, Singapore, Singapore.
ACM, New York, NY, USA, 12 pages. https://doi.org/10.1145/3540250.3549142
1 INTRODUCTION
Android protects access to restricted data ( e.g., the device identifier)
and actions ( e.g., making phone calls) through permission enforce-
ment [ 12]. Such an access control model can protect users against
snooping and protect the stability and security of the operating
system [ 31]. When an Android app attempts to access the restricted
resources, a security check is triggered to inspect whether proper
permissions are granted. Lack of permission request will prevent
access to the resource and further cease the corresponding function-
ality or even crash the app. Therefore, it is essential for developers
to know the permissions required of the invoked API. Unnecessary
required permissions can pose three threats: ( i) Too many required
permissions may confuse users. Users suspect that the app has
unexpected behaviors, which leads to users uninstalling or unwill-
ing to install the app; ( ii) The permissions required by an app is
an important feature in detecting Android malware. Unnecessary
permissions will fool the detector and cause a false alarm; ( iii) The
app will incur security risks with unnecessary permissions. Once
the app contains vulnerabilities that can be injected with tampered
code, it is easy for an attacker to thwart user privacy or invoke
sensitive APIs. Moreover, requesting unnecessary permissions may
772
ESEC/FSE â€™22, November 14â€“18, 2022, Singapore, Singapore C. Li, X. Chen, R. Sun, M. Xue, S. Wen, M. E. Ahmed, S. Camtepe, Y. Xiang
Figure 1: Android software stack
expand the attack surface and expose the Android operating sys-
tem to a host of attacks, especially privilege escalation attacks [ 17].
Therefore, to safeguard usersâ€™ privacy and protect the Android
ecosystem, Android app developers are suggested to follow the
principle of least privilege ,i.e., requesting a minimum set of per-
missions required to fulfill the appsâ€™ functionality. Unfortunately,
Android does not provide official documentation for the permis-
sion specifications ( i.e., a mapping between APIs and the required
permissions), making it difficult for app developers to follow the
least privilege rule, and further lead to security vulnerabilities such
as permission over-privilege [17].
To address this problem, researchers have been working on de-
veloping methods that generate an accurate list, called a protection
map, that maps Android APIs to the required permissions. The
previous works that provide such protection maps include Stow-
away [17],PScout [12],Axplorer [13],Arcade [9],PSGen [42],
and most recently, Dynamo [15].Stowaway empirically determines
the permissions required in Android APIs using feedback-directed
testing. PScout andAxplorer leverage control-flow reachability
analysis on the source code of the Android framework to gener-
ate the mapping between APIs and permissions. Arcade proposes
a path-sensitive method based on graph abstraction techniques
to generate a more precise mapping. PSGen statically generates
the protection map for Android NDK. Dynamo extracts the pro-
tection mapping through dynamic test. Dynamic testing methods
(e.g.,Stowaway andDynamo ) can accurately map the required
permissions to API invocations that they have tested; however,
such dynamic approaches suffer from an intrinsic shortcoming of
low coverage. The existing static analysis based approaches ( e.g.,
PScout ,Axplorer , and Arcade ) have better coverage but may
lead to imprecise results because of improper modeling of the com-
plicated Android communication mechanisms. PSGen extracts pro-
tection mapping for Android NDK ( i.e., both protected APIs and per-
mission checks are in the Native code), which has a different scopeto our approach ( i.e., the protected APIs are in the Java framework,
while the permission checks are in the Native code).
Specifically, existing works only analyzed the Java API frame-
work in the Android API Framework , but overlooked the C/C++
Native Library that consists of core Android system components
and services ( e.g., Camera service, Sensor service). For example,
the public method openCamera() inCameraManager.java class
implements its permission check (â€œandroid.permission.CAMERAâ€)
in the native library CameraService.cpp . Missing native library
analysis will mistakenly conclude that the API openCamera() does
not require any permissions (one example is detailed in Section 2).
While the API-permission protection mapping contributes to
identifying security vulnerabilities in Android apps, such as per-
mission over-privilege [17] ( i.e., an app requests additional permis-
sions that are not required), the imprecise mapping will lead to
false results on detecting such vulnerabilities. Taking the afore-
mentioned case as an example, an app invokes the API open-
Camera() will need to request the corresponding permission an-
droid.permission.CAMERA ; however, existing works that do not
analyze the native libraries will identify it as a permission over-
privilege case, and henceforce, a false positive.
Static analysis is widely used in code analysis due to its fast
speed and high code coverage, especially in the field of Android
security analysis [ 11,14,22,24,27,32,37,38,40]. There are also
many works on vulnerability identification of Android operation
systems and apps [ 10,16,18,23,25,26,28â€“30,33,35,41]. In this
research, to address the shortcomings of the existing works, we
leverage the cross-language analysis on the overall Android system,
including both the Java API Framework and the C/C++ Native Li-
braries . To this end, we analyze the cross-language communication
mechanisms on five Android Open Source Projects (AOSP) and sum-
marize two communication models to facilitate the cross-language
analysis. We develop a prototype system, NatiDroid , and gener-
ate Native-triggered ( i.e., an Android API whose permission check
is implemented in the native library) API-permission mappings
in AOSP versions 7.0, 7.1, 8.0, 8.1, and 10.0, which were chosen
to benchmark against prior works [ 9,13] (see detailed discussion
in Section 5). In addition to the mappings generated by previous
works, Axplorer andArcade (2,115 and 1,585, respectively, in
AOSP 7.0), NatiDroid can successfully discover 449 mappings that
are not covered previously. Note that while most Android APIs are
Java methods, few of them are C/C++ methods. Nevertheless, these
native methods play indispensable roles in the Android system,
such as interacting with the hardware layer. We further use the
new mappings to detect permission over-privilege vulnerabilities
on a large dataset containing more than 11,000 Android apps, in-
cluding system apps from custom Android ROMs and third-party
apps from the Google Play. We identify the worst-case scenario,
where approximately 71% apps with permission over-privilege de-
tected by Axplorer andArcade are false positives. In summary,
we make the following contributions:
â€¢We design and implement a prototype system, NatiDroid , to
facilitate cross-language control-flow analysis on the Android
framework. To the best of our knowledge, this is the first work
to enable cross-language analysis on the Android framework.
By incorporating NatiDroid with existing Java-side permission
773Cross-Language Android Permission Specification ESEC/FSE â€™22, November 14â€“18, 2022, Singapore, Singapore
mappings ( e.g.,Axplorer orArcade ), we obtain a complete per-
mission mapping that covers the entire Android system. We make
our system and results publicly available to benefit researchers
and practitioners.1
â€¢We apply NatiDroid to extract the permission-API protection
mappings from the native libraries on five AOSP versions (7.0,
7.1, 8.0, 8.1, and 10.0). We show that 12 permissions, including
8 signature and 2 dangerous permissions, are determined to be
enforced in native libraries, which are not covered by two state-
of-the-practice benchmarks, Axplorer andArcade .
â€¢We analyze Android apps for permission over-privilege. Our
results show that NatiDroid is effective in identifying vulner-
able Android apps. We have identified approximately 71% false
positives in terms of the number of the apps with at least one
permission over-privileged.
We hope that the proposed system, NatiDroid in this paper
could bridge the gap between Java- and Native-sides analysis (see
Figure 1), rendering the static analysis of the overall Android frame-
work to be complete and accurate.
2 BACKGROUND AND MOTIVATION
This section provides background information on how Android
OS operates and explains the limitations of the existing static API
protection mapping generation techniques that motivate our work.
Android framework. Android framework consists of the Java API
Framework layer and C/C++ Native Library layer ( i.e., the second and
the third layers from the top in Figure 1). The Java API Framework
layer offers Application Programming Interfaces (APIs) written in
the Java language for Android app developers to access Android
features and functionalities. The Java framework accesses the device
hardware capabilities, such as the camera and sensors, via the C/C++
Native Library layer. When a Java framework API ( e.g., the Camera
Manager in Figure 1) invokes a call to access device hardware,
the Android system loads corresponding library module ( e.g., the
Camera Service) for that hardware component.
Android permission model. When an app needs to use any
of the protected features of an Android device ( e.g., accessing the
camera, sending an SMS, making a phone call), it must obtain the
appropriate permission(s) from the user. When an Android API is
called, the Android framework checks whether it is protected by
any permission. Most of such permission checks are defined in the
Java API Framework layer in the Android system, while there are
yet a number of them defined in the C/C++ Native Library layer.
Existing works [ 9,12,13] leverage static analysis on the Java API
Framework layer of the Android framework to extract the mapping
between APIs and corresponding permission checks. Ignoring the
invocation of native libraries miss the permission checks in the
native libraries, leading to incomplete mapping results.
Motivating example. We further elaborate on our motivation
with a real-world example illustrated in Figure 2. The code from
lines 1 to 10 is derived from a popular photography app vStu-
dio.Android.Camera360 [8] on Google Play. The app initialises a
CameraManager instance (line 4), and opens the camera instance
by invoking openCamera() method (line 8). The invocation chain
then traverses along the call path through an Android SDK class
1The source code is available at https://natidroid.github.io/.
Figure 2: Motivation example derived from a real-world An-
droid app vStudio.Android.Camera360 . The code is simplified
for better illustration.
CameraManager.java (lines 11 to 18) and a native library Cam-
eraService.cpp (lines 19 to 32), and finally triggers a permission
check in the native library (line 28). Note that the cameraSer-
vice.connectDevice() (line 18) communicates with the CameraSer-
vice::connectDevice() (line 20) in a cross-language way (marked
as purple). The security check examines if the method is called by its
own process ( i.e.,cameraservice , hence, no permission is required)
or the corresponding permission android.permission.CAMERA is
granted. If neither it is called from its own process, nor the an-
droid.permission.CAMERA permission is granted, a permission
denied error is returned (line 30), which will further prevent open-
Camera() to be executed. This example implies a protection map-
ping from the Android API, CameraManager.openCamera() , to its
permission protection check, {android.permission.CAMERA ||
callingPid == getpid()} .2
Unfortunately, as existing works only analyzed the Java source
code in the Android framework, they miss the permission checks
implemented in the native libraries. For instance, the mapping
2Some if-then-else statements are omitted in line 27 of Figure 2 for better illustration;
consequently, the protection mapping only reflects the simplified code as shown in
Figure 2. The complete protection mapping for openCamera() can be found in our
open source repository.
774ESEC/FSE â€™22, November 14â€“18, 2022, Singapore, Singapore C. Li, X. Chen, R. Sun, M. Xue, S. Wen, M. E. Ahmed, S. Camtepe, Y. Xiang
of the API CameraManager.openCamera() to the permission an-
droid.permission.CAMERA , as shown in the example, does not
exist in the state-of-the-practice works, such as PScout [12],Ax-
plorer [13], or Arcade [9]. The incompleteness of the mapping
results further introduces false results in detecting security vulner-
abilities, such as permission over-privilege [ 17] (detailed in Sec-
tion 4.3).
3 APPROACH
We propose and implement a prototype system, NatiDroid , to ad-
dress the cross-language protection mapping problem that has long
been overlooked in previous works. Figure 3 illustrates the overall
design of NatiDroid . As depicted, NatiDroid contains three mod-
ules. The Pre-processing module prepares the intermediate artifacts
for analyzing the Android framework and native libraries, such as
intermediate .jar files (for Java-side analysis) and clang compile
commands (for Native-side analysis). The Entry-points identification
module summarizes two cross-language communication models
used in the Android framework, and identifies the entry-points
for both Java- and Native-sides analysis. The Cross-language Inter-
procedural Control Flow Graph (ICFG) analysis module constructs
the cross-language ICFG and extracts the permission mapping.
We propose a complete solution for extracting Native-triggered
permission mapping from the Android system. We leverage Soot
[1] and Clang [2] static analysis frameworks, although our solution
is also applicable to other static analysis frameworks. Soot is a pop-
ular Java optimization framework for analyzing and visualizing Java
and Android apps, which has been widely used in various projects
for static analysis [ 12,19,20].Clang is a lightweight compiler for
C language family. We use Clang to transform C/C++ code to the
Abstract syntax tree (AST) [ 3]. Additional code for implementing
NatiDroid consists of approximately 7kLOC. We detail the design
and implementation of each module in the following subsections.
3.1 Pre-processing
Due to the complexity and cross-language nature of the Android
framework, there is no off-the-shelf tool for static analysis of the
Android framework ( i.e.,Java API Framework andNative Library )
as a whole. NatiDroid leverages the divide-and-conquer strategy
to facilitate the Java- and Native-sides analysis. However, there
are still non-trivial tasks to prepare the AOSP codebase for the
static analysis. Hence, in this module, we prepare the intermediate
artifacts from the AOSP codebase, which are required to enable
the Java- and Native-sides analysis. Note that the pre-processing
module includes most engineering works, which is not considered
our technical contribution. However, it is essential to facilitate the
proposed cross-language analysis.
Java-side analysis preparation. NatiDroid â€™s Java-side analysis
takes compiled .jar file as input. However, to maintain the stability
of the Android system, some non-SDK class and method bodies are
hidden using the @hidden Javadoc tag ( e.g., non-SDK Android APIs
that may be changed in the future versions without noticing the app
developer) during the building of android.jar from source code.
The hidden classes and methods only expose the method name,
parameters, return values, and minimum set of statements required
to handle the invocation, which is not sufficient for constructing acomplete ICFG. We therefore retain the intermediate output during
the compilation, i.e., the intermediate .jar files that have not been
combined as android.jar . These intermediate .jar files, such as
services.com.intermediates.jar , have the complete class and
method information sufficient for facilitating static analysis.
Native-side analysis preparation. Before we build the cross-
language ICFG (cf. Section 3.3), we leverage clang to transform
C/C++ source code to AST. A complete set of clang compile com-
mand is required to enable the static analysis, however, is not
provided in Android documentation. Android uses the ninja to
build system [ 6]. During the compilation process, the .ninja files
containing ninja build commands are generated by the compiler.
However, the commands obtained from .ninja files consist of file
operations and a mixture of GNU Compiler Collection (GCC) and
clang commands, which are not compatible with the off-the-shelf
clang -based analyzer. We then develop a system (to 500 LOC) to ex-
tract and pre-process the required commands from these files. The
functions of the system include merging separated ninja commands
and replacing the Clang++ commands with clang commands ( i.e.,
adding C++ headers in clang commandâ€™s parameters).
3.2 Entry-Points Identification
Recall that the overall idea of generating a protection mapping is to
examine whether the invocation of an API will trigger a permission
check in the Android framework ( i.e., if there is a permission check
node in the ICFG starting from the API call). Due to the complexity
of the Android framework, building an ICFG of the overall frame-
work is neither practical nor efficient. As NatiDroid â€™s goal is to
complement the existing mappings, such as Axplorer andArcade ,
by adding the protections whose permission checks are located in
the native libraries, we only generate sub-ICFGs for the Android
APIs that involve cross-language communication. The first step to
generate sub-ICFGs is to identify the entry-points of the graphs
(for both Java- and Native-sides). To this end, we first summarize
two cross-language communication mechanisms used by Android.
AIDL-based communication model. The Android operating sys-
tem (OS) is based on Linux but does not inherit the Inter-Process
Communication (IPC) mechanism of Linux. In Android, resources
between processes are not shared. Android Interface Definition Lan-
guage (AIDL) is one of the IPC mechanisms that Android adopted
to enable communication for remote invocation, providing cross-
process or even cross-language communication. Figure 4 depicts
the workflow of AIDL-based client-service model, where the Java
framework works as a client requesting service from the native
library. AIDL utilizes a pair of Stub/Proxy classes on Java-side to
communicate with native libraries. The Proxy is responsible for
sending requests to native service and implementing the remote
method which invokes the transact() method and communicates
with Native-side, while the Stub class, inheriting the Binder class,
transforms service Binder and receives the reply from native ser-
vice using the method onTransact() . Thetransact() andon-
Transact() are synchronous, such that a call to transact() does
not return until the target has returned from onTransact() .
On Native-side, it is unnecessary to generate Stub/Proxy pairs,
but directly implements the remote method (using the name as
same as the remote method on Java-side) to handle the request from
775Cross-Language Android Permission Specification ESEC/FSE â€™22, November 14â€“18, 2022, Singapore, Singapore
Figure 3: An overview of NatiDroid system
Figure 4: AIDL communication model. The Java-side caller
invokes remote method from Native-side.
Java-side, so that we can always find the receiver onTransact()
and the same name remote method as the AIDL sender. Through
using pairs of onTransact() andtransact() methods as sender
and receiver on both sides, the communication between Java- and
Native-sides is established. Therefore, cross-language interaction
can be detected via matching the use of AIDL on Java- and Native-
sides ( e.g., the Stub/Proxy pair, the onTransact() methods, and
the implementation of the remote methods and the transact()
methods). We can then determine the entry-points for static analysis
accordingly.
An example of AIDL mechanism is shown in Figure 5, where
the method getCameraInfo() uses AIDL to implement the com-
munication between Java and C++. A pair of a sender and a re-
ceiver on each side of AIDL ( i.e., the client and the service) han-
dles the cross-language communication. The caller (line 3) invokes
the method getCameraInfo() which is firstly defined as an in-
terface in line 6 and then implemented in line 14 (the detailed
implementation is omitted). In the corresponding native library
(lines 16 to 24), the receiver onTransact() handles the request and
further invokes the method getCameraInfo() (line 23). The get-
CameraInfo() method then executes the method implementation
and sends the execution result back to the Java-side onTransact()
method (line 9), which is further passed back to the caller (line 3).
Note that the getCameraInfo() in line 6 and the getCameraInfo()
in line 18 are the two interface methods that both invoke the trans-
act() method (omitted) to establish the communication between
Java- and Native-sides. The NatiDroid will match the pair of such
Figure 5: An example of AIDL-based cross-language commu-
nication model. The code snippets are simplified for better
illustration.
remote methods and recognize them as a pair of Java entry-point
and native entry-point. Note that, for the inner-language AIDL
communication on both Java- and Native-sides, NatiDroid gener-
ates ICFG with a similar approach, except for the identification of
entry-points.
JNI-based communication model. Java Native Interface (JNI)
provides a cross-language interface between Java and Native code
(written in C/C++). This enables developers to write native methods
to handle situations when an app cannot be written entirely in the
Java programming language, e.g., when the standard Java class
library does not support the platform-specific features or program
library, such as communication with the underlying hardware. In
the JNI framework, native functions are implemented in .cor.cpp
776ESEC/FSE â€™22, November 14â€“18, 2022, Singapore, Singapore C. Li, X. Chen, R. Sun, M. Xue, S. Wen, M. E. Ahmed, S. Camtepe, Y. Xiang
Figure 6: JNI communication model. Java- and Native-sides
communicate with JNI.
files. When invoking the function, it passes a JNIEnv pointer, a
jobject pointer, and any Java arguments declared by the Java
method.
Figure 6 shows the JNI-based communication model adopted
by Android. Android uses the JNI Dynamic Register to link native
methods. Different from the AIDL model, the JNI-based commu-
nication starts from a registration process. When Android starts
running, the AndroidRuntime class uses the startReg() method
to start the registration of JNI methods, which will further invoke
all JNI registration functions implemented in the native libraries.
The registration functions will register native methods with the cor-
responding Java class specified by an array of JNINativeMethod
structures that contains the Java method name, Java method sig-
nature, and pointers to the native function. After the registration
process, all the JNINativeMethod (on Native-side) is registered
and linked to the corresponding Java method in the Java Virtual
Machine (JVM).
We further explain the JNI-based communication mechanism
with an example given in Figure 7, which is derived from an-
droid_hardware_Radio.cpp in AOSP 8.0. The method regis-
ter_android_hardware_Radio() (line 13) is called to register the
JNI methods for Radio, with the JNI method information provided
in line 14. Specifically, the kRadioModuleClassPathName variable
(line 5) declares the containing class name of the Java method, and
gModuleMethods (line 7) declares the correspondence between the
Java method and the C++ function. The variable gModuleMeth-
odsis defined to contain groups of the Java method name (line
8), parameter and returned types (lines 9 to 10), and the pointer
of C++ method (line 11). All the information will be dynamically
registered in JVM during run-time. Finally, the C++ method in-
volved in the cross-language communication is declared in line
12, while the involving Java method can be found in the java file
RadioModule.java in package android.hardware.radio (lines 2
to 3).
According to the JNI-based communication mechanism, we ex-
tract pairs of entry-points from Java- and Native-sides. Specifi-
cally, the JNI methods and the corresponding native methods are
vaguely identified by a linear sweep searching of keyword Regis-
terMethodsOrDie ,registerNativeMethods andjniRegister-
NativeMethods over the.cpp files at first. Then we extract the class
path name ( e.g., thekRadioModuleClassPathName in Figure 7) and
the array of JNINativeMethod structures, from which a pair of
Figure 7: An example of JNI-based cross-language communi-
cation. The code snippets are simplified for better illustra-
tion.
Algorithm 1 Constructing Cross-language ICFG
Input: Android native code and intermediate jar ğ‘.
Output: Cross-language ICFG ğº.
1:ğº=âˆ…
2:(ğ‘ğ‘’ğ‘ ğ‘—,ğ‘ğ‘’ğ‘ğ‘)â†ğ‘ ğ‘ğ‘ğ‘›ğ¸ğ‘›ğ‘¡ğ‘Ÿğ‘¦ğ‘ƒğ‘œğ‘–ğ‘›ğ‘¡ğ‘ (ğ‘)
3:forğ‘’ğ‘ğ‘â„(ğ‘›ğ‘’ğ‘ ğ‘—,ğ‘›ğ‘’ğ‘ğ‘)âˆˆ(ğ‘ğ‘’ğ‘ ğ‘—,ğ‘ğ‘’ğ‘ğ‘)do
4:(ğ‘ğ‘,ğ¸ğ‘)â†ğ‘ğ‘ğ‘¡ğ‘–ğ‘£ğ‘’ğ¼ğ¶ğ¹ğºğºğ‘’ğ‘›ğ‘’ğ‘Ÿğ‘ğ‘¡ğ‘œğ‘Ÿ (ğ‘›ğ‘’ğ‘ğ‘)
5: ifâ„ğ‘ğ‘ ğ‘†ğ‘’ğ‘ğ‘¢ğ‘Ÿğ‘–ğ‘¡ğ‘¦ğ¶â„ğ‘’ğ‘ğ‘˜(ğ‘ğ‘)then
6: forğ‘’ğ‘ğ‘â„(ğ‘›ğ‘,ğ‘’ğ‘)âˆˆ(ğ‘ğ‘,ğ¸ğ‘)do
7: ğºâ†ğºâˆª(ğ‘›ğ‘,ğ‘’ğ‘)
8:(ğ‘ğ‘—,ğ¸ğ‘—)â†ğ½ğ‘ğ‘£ğ‘ğ¼ğ¶ğ¹ğºğºğ‘’ğ‘›ğ‘’ğ‘Ÿğ‘ğ‘¡ğ‘œğ‘Ÿ (ğ‘›ğ‘’ğ‘ ğ‘—)
9: forğ‘’ğ‘ğ‘â„(ğ‘›ğ‘—,ğ‘’ğ‘—)âˆˆ(ğ‘ğ‘—,ğ¸ğ‘—)do
10: ğºâ†ğºâˆª(ğ‘›ğ‘—,ğ‘’ğ‘—)
11:ğ‘’â†ğ‘™ğ‘–ğ‘›ğ‘˜(ğ‘›ğ‘’ğ‘ ğ‘—,ğ‘›ğ‘’ğ‘ğ‘)
12:ğºâ†ğºâˆª(ğ‘›ğ‘’ğ‘ ğ‘—,ğ‘’)
13:ğºâ†ğºâˆª(ğ‘›ğ‘’ğ‘ğ‘,ğ‘’)
entry-points can be located and recognized ( e.g., the pair of na-
tive_setup() andandroid_hardware_Radio_setup() ).
3.3 Cross-Language Protection Mapping
Extraction
After the entry-points on both Java- and Native-sides are identified,
we further extract the protection mappings from AOSPs. In this
section, we first introduce how NatiDroid generates ICFG from
both sides. Based on the ICFG, NatiDroid then traverses the cross-
language Android API call paths and corresponding security checks
(e.g., permission checks) to generate the API-permission protection
mappings.
3.3.1 Cross-Language ICFG Generation. Algorithm 1 elaborates
the detailed steps involved in generating cross-language ICFGs.
After obtaining the entry-point pairs from both Java- and Native-
sides (line 2, as detailed in Section 3.2), NatiDroid first leverages a
forward analysis to generate an ICFG on the native side from each
identified native entry-point (line 4). If the native-side ICFG does not
contain any security checkpoint ( e.g., permission check, UIDcheck,
andPIDcheck), we discard the ICFG for computational efficiency
777Cross-Language Android Permission Specification ESEC/FSE â€™22, November 14â€“18, 2022, Singapore, Singapore
Figure 8: An example of using strong pointer in native library
(line 5). Otherwise, NatiDroid further utilizes a backward analysis
to build a Java-side ICFG starting from the paired Java-side entry-
point to an Android API. If the reached Android API is further
invoked by other Android APIs, we extend the ICFG until the API
is not called by any other APIs (lines 6 to 10). The ICFGs generated
from both sides are then connected with the communication models
identified in Section 3.2 (lines 11 to 13).
Handling the service identifier. The aforementioned AIDL is of-
ten used to invoke remote methods in service. Before the invocation,
the service is usually pointed by passing a string to the getService
orcheckService method, for example, the string â€œmedia.playerâ€
in line 19 of Figure 8. When building the call graph, we need to
handle such remote invocation and identify which class is the iden-
tifier string actually pointed to. These services are registered to
the system through an addService method (either on Java-side
or Native-side). Therefore, we can automatically collect the corre-
spondences between these identifiers and service classes from it.
First, we scan the Java and C++ files looking for addService meth-
ods. Then the program confirms whether the method is ServiceM-
anager.addService ordefaultServiceManager->addService ,
separately. Once confirmed, the program extracts a pair of ser-
vice class and the corresponding identifier from the parameters; for
example, the string identifier â€œmedia.playerâ€ in Figure 8 will be
paired with its service class MediaPlayerService .
Handling Android strong pointer. Although the strong pointer
defines the type variable, the type is not necessary to be restricted.
Therefore, we need additional efforts to get what type the strong
pointer actually points to from the context. According to the strong
pointer mechanism, when we find that a member function is called,
if the object is declared as a strong pointer, the invocation of the
member function will be determined automatically. The NatiDroidAlgorithm 2 Protection Maps Extraction
Input: The cross-language ICFG generated in Algorithm 1 ğº.
Output: The protection mapping ğ‘€.
1:ğ‘€=ğ‘šğ‘ğ‘(ğ‘ğ‘œğ‘‘ğ‘’, ğ¶ğ‘œğ‘›ğ‘‘ğ‘–ğ‘¡ğ‘–ğ‘œğ‘›)
2:ğ‘â†ğ·ğ¹ğ‘†(ğº)
3:forğ‘’ğ‘ğ‘â„ğ‘›âˆˆğ‘do
4: ifğ‘–ğ‘ ğ½ğ‘ğ‘£ğ‘ğ´ğ‘ƒğ¼ğ‘ğ‘œğ‘‘ğ‘’(ğ‘›)then
5:ğ¾â†ğ‘”ğ‘’ğ‘¡ğ´ğ‘™ğ‘™ğ‘ğ‘ğ‘¡ğ‘–ğ‘£ğ‘’ğ¶â„ğ‘–ğ‘™ğ‘‘ğ‘Ÿğ‘’ğ‘› (ğ‘›)
6: forğ‘’ğ‘ğ‘â„ğ‘˜âˆˆğ¾do
7: ifâ„ğ‘ğ‘ ğ‘†ğ‘’ğ‘ğ‘¢ğ‘Ÿğ‘–ğ‘¡ğ‘¦ğ¶â„ğ‘’ğ‘ğ‘˜(ğ‘˜)then
8: ğ¶â†ğ¶âˆªğ‘”ğ‘’ğ‘¡ğ‘†ğ‘’ğ‘ğ‘¢ğ‘Ÿğ‘–ğ‘¡ğ‘¦ğ¶â„ğ‘’ğ‘ğ‘˜ğ‘  (ğ‘˜)
9: ğ‘€â†ğ‘€âˆª(ğ‘›,ğ¶)
will first trace the statement where an object is assigned to the
strong pointer. If it is assigned through method getService() , the
type of the object will be determined by the passed service identifier;
otherwise, NatiDroid will determine the type of strong pointer
according to the variable type returned by the function.
Handling member variables. A class member variable is also
possibly assigned by a strong pointer. For example, in line 7 of
Figure 8, the setAudioSource() method of the mMediaRecorder
object is invoked, but from this line of code we cannot determine
the type of variable mMediaRecorder so that we cannot determine
whichsetAudioSource() method has been invoked. By looking
up in the referenced header file (from line 23), we find that this
variable is a member variable of class MediaRecorder . Therefore,
to find out the type of this variable, we can search the entire class
looking for the assignment or initialization statement. Note that the
assignment should be ignored if the assignment releases the pointer,
e.g., pointing the variable to a null pointer. In this case, the variable
mMediaRecorder is initialized as the return value of createMedi-
aRecorder in the class constructor (line 12). We have explained
how to determine the return type of createMediaRecorder in the
previous paragraph, handling Android strong pointers. To imple-
ment the process automatically, if a variable cannot be tracked in
the local scope, NatiDroid will point to the header file to check
whether it is a member variable, and thus the tracking scope will
be expanded to the entire class.
Handling particular access control. Binder transaction executes
with the identity ( i.e., PID and UID) of a caller. If a transaction needs
to run with calleeâ€™s identity, Binder.clearCallingIdentity()
can temporarily clear the callerâ€™s identity, so that the calleeâ€™s iden-
tity will be checked during the transaction. Then the callerâ€™s iden-
tity can be restored by Binder.restoreCallingIdentity() . To
handle such intervened access control, NatiDroid uses calleeâ€™s
identity for security control for all methods between the two Binder
methods.
3.3.2 Protection Mapping Extraction. Algorithm 2 shows the pseudo-
code of extracting the protection mapping of Android APIs. After ob-
taining the cross-language ICFG, we resort to a Depth-First Search
(DFS) strategy (line 2) to check if there are call paths between An-
droid APIs in the Java API Framework layer and security checks
in the Native Library layer. For each node in the ICFG, if it is a
Java node, we will collect all its native children (lines 3 to 5) and
obtain the security checks defined in its children nodes (lines 7 to
8). If there are more than one checkpoint on the call trace ( e.g., an
778ESEC/FSE â€™22, November 14â€“18, 2022, Singapore, Singapore C. Li, X. Chen, R. Sun, M. Xue, S. Wen, M. E. Ahmed, S. Camtepe, Y. Xiang
Table 1: Permission-API protection mappings extracted by NatiDroid . The results of Axplorer andArcade are generated
from the Android Java Framework, while the results of NatiDroid are generated from Android Native Libraries.
SourceNative Library (C/C++) API Framework (Java)
NatiDroid Axplorer Arcade
# Permission# API Affected# Permission# API Affected# Permission# API Affected
# S1# D # N # Total # S # D # N # Total # S # D # N # Total
AOSP 7.0 5 2 2 9 449 145 12 27 184 2,115 152 11 30 193 1,585
AOSP 7.1 6 2 2 10 449 145 12 27 184 2,153 152 11 30 193 1,585
AOSP 8.0 8 2 2 12 464 / / / / / / / / / /
AOSP 8.1 7 2 2 11 461 / / / / / / / / / /
AOSP 10.0 5 2 2 9 282 / / / / / / / / / /
1S: Signature permission; D: Dangerous permission; N: Normal permission.
Android API is protected by multiple permissions), we concatenate
them with AND operation. As inspired by Aafer et al. [9], we also
include security checks other than permission enforcement, such
as UID and PID checks. If there is more than one Android API
along the track, we create a mapping entry for each of them ( i.e.,
all Android APIs along the track have the same security check).
Finally, each pair of Java API node and its corresponding security
check(s) in Native-side will be added into the protection mapping
(line 9).
4 EVALUATION
The main contribution of this work, NatiDroid , is to enable the
cross-language static analysis of the Android framework. Since
there is a number of existing tools [ 4,39] and works [ 9,13] well
handling the static analysis of the Java-side of Android frame-
work, NatiDroid specifically focuses on the analysis of the cross-
language part of the Android framework. In this section, we run
experiments to verify the performance of NatiDroid and to answer
the following research questions:
â€¢RQ1 : How effective is NatiDroid in identifying permission en-
forcement in Native libraries?
â€¢RQ2 : How many permission mappings can our tool identify that
are not recognized by the state-of-the-practice approaches?
â€¢RQ3 : How can our tool contribute to real-world security evalua-
tion?
We use NatiDroid to extract the API protection mapping for 5
AOSP versions â€“ 7.0, 7.1, 8.0, 8.1, and 10.0. We obtained the source
code from the official AOSP repository [ 7]. The experiment ran on
a Linux server with Intel (R) Core (TM) i9-9920X CPU @ 3.50GHz
and 128 GB RAM.
4.1 RQ1: The Performance of NatiDroid
We present the statistics of Permission-API protection mapping
extracted from the Native libraries in Table 1 (columns 1 to 6). It
takes 16 hours on average to extract the protection mapping from
each AOSP version. In each of AOSP 7.0, 7.1, 8.0, and 8.1, our tool
identified more than 440 APIs whose permission enforcement take
place in the Native code, while in AOSP 10.0, NatiDroid detected
282 APIs containing permission enforcement on the Native side.
In Table 2, we list the permissions that have permission checks
in native libraries, including 2 dangerous permissions, 8 signature
permissions, and 2 normal permissions. Signature permissions areonly granted if the requesting app is signed with the same certifi-
cate as the app that declared the permission. Normal permissions
refer to the permissions with minimal risk to the system and the
usersâ€™ private data. Dangerous permissions are those higher-risk
permissions that would give access to private user data or control
over the device that can negatively impact the users.
Due to the lack of ground truth for the permission protection
mappings, it is difficult to evaluate the overall accuracy of the
extracted mappings. We therefore resort to a manual process to
examine the correctness of our mappings. To this end, we manually
inspect the involved source code in the AOSP codebase to confirm if
the APIs will go through the corresponding security check(s) and if
the condition(s) in the security check(s) is(are) consistent with the
condition(s) in the mappings. we randomly selected 20% of the total
mappings ( i.e., 421 mappings) for manual inspection and found no
missing or redundant protection conditions in our mappings.
We further looked into the results on the affected API in each
AOSP. In AOSP 10.0, the number of affected APIs decreased signifi-
cantly, compared to other versions (282 in AOSP 10.0 vs.456.5Â±7.5
in AOSP 7.1 to 8.1). Through the manual code review, we found
that two signature permissions, ACCESS_DRM_CERTIFICATES and
CONTROL_WIFI_DISPLAY , have been removed in AOSP 10.0. At the
same time, the code related to the audio service was refactored and
simplified, which greatly reduced the number of exposed methods.
Answer to RQ1. NatiDroid identified more than 440 APIs
that are protected by permission enforcement in the Native
code in AOSP 7.1-8.1, and 282 APIs in AOSP 10.0, which are
verified by manual inspection (20% sampling).
4.2 RQ2: Comparison with Other Mappings
State-of-the-art works use static and dynamic analysis approaches
to extract the API-permission protection mapping from the Android
framework. For instance, Axplorer [13] and Arcade [9] use static
methods to retrieve the protection mapping. Dynamo [15], on the
other hand, extracts the mapping by leveraging dynamic analysis.
This RQ compares our results with the mappings derived from
these approaches. Unfortunately, the mapping from Dynamo lacks
method signature information ( e.g., class name, return type, and
parameter list), which is required to identify a method (e.g., there
could be methods with identical names in different classes). We
cannot accurately compare our mapping with Dynamo â€™s mapping.
779Cross-Language Android Permission Specification ESEC/FSE â€™22, November 14â€“18, 2022, Singapore, Singapore
Table 2: Permissions with permission checks in native li-
braries
PermissionsAOSP Protection
Level 7.0 7.1 8.0 8.1 10.0
ACCESS_DRM_CERTIFICATES Signature
ACCESS_FM_RADIO Signature
ACCESS_SURFACE_FLINGER Signature
CAPTURE_AUDIO_HOTWORD Signature
CONTROL_WIFI_DISPLAY Signature
LOCATION_HARDWARE Signature
MODIFY_AUDIO_ROUTING Signature
READ_FRAME_BUFFER Signature
RECORD_AUDIO Dangerous
CAMERA Dangerous
INTERNET Normal
MODIFY_AUDIO_SETTINGS Normal
: The permission exists in AOSP; : The permission does not exist in AOSP.
Therefore, in this RQ, we compare our work with Axplorer and
Arcade . The mappings of Axplorer andArcade are derived from
their public repositories3Note that since both works only released
their mapping results (for AOSP version 7.1 and under) in lieu of
the tools, we are unable to obtain the mappings on AOSP 8.0, 8.1,
and 10.0.
Table 1 presents the comparison of permission-API protec-
tion mappings on the five AOSP versions. Unsurprisingly, since
NatiDroid only focuses on the permission checks in the Android
Native libraries, while Axplorer andArcade only work on the
Android Java framework, there is no overlap between NatiDroid
and the two works, respectively. As shown in the first two columns
of Table 1, the number of newly identified permissions that are
missed in previous works ranges from 9 to 12 in the five AOSP
versions. There are 282 to 464 Android APIs associated with these
permissions ( i.e., invoking these APIs requires the corresponding
permissions to be granted), counting up to approximate 30% of the
mappings reported in the previous study, which are overlooked in
the previous work that only analyzed the Java-side of the Android
framework. Table 1 reports the breakdown of the mappings based
on the permission protection levels. The mapping results contain
the permissions in signature ,dangerous , and normal levels. Missing
these mappings, especially the ones for the dangerous permissions,
will lead to false results in detecting security issues of Android apps,
such as permission over-privilege (detailed in Section 4.3). Thus,
the main security and privacy threats to the majority of Android
apps ( i.e., third-party apps, which usually have no access to signa-
turepermissions) are caused by inaccurate mapping of dangerous
permissions. It is therefore worth highlighting that NatiDroid
has identified the mappings for two additional dangerous permis-
sionsCAMERA andRECORD_AUDIO , which are closely related to userâ€™s
privacy.
Answer to RQ2. NatiDroid is able to identify 2 dangerous
permission, 8 signature permissions, and 2 normal permis-
sions that previous works have missed. Approximate 30% of
the mappings reported in the previous study are related to
these permissions.
3https://github.com/reddr/axplorer/ and https://arcade-android.github.io/arcade/.Table 3: Experimental dataset
Set Source # Apps
Custom ROM AppsXiaomi (7.0) 398
LG (7.0) 220
Samsung (7.0) 302
Huawei (7.0) 115
Third-party Apps Google Play Store 10,000
Total 11,035
4.3 RQ3: Applications of Protection Mappings
The protection mappings can be leveraged to detect security issues
of Android apps, such as permission over-privilege . In this subsec-
tion, we evaluate the effectiveness of our extracted mappings in
identifying the security vulnerabilities.
We include two categories of Android apps in our experiments:
the custom ROM apps that are pre-installed on the devices, such
asCamera andCalendar , as well as the third-party apps that users
can download from official or alternative app stores ( e.g., social
networking apps, banking apps). The experimental dataset contains
1,035 custom ROM apps extracted from five Android custom ROMs
of four vendors ( i.e., Samsung, LG, Huawei, and Xiaomi) and 10,000
third-party apps randomly downloaded from the Google Play store.
Table 3 shows an overview of the dataset in use.
We use the permission protection mappings extracted from AOSP
to detect security vulnerabilities in both the custom ROM apps
and third-party apps. The AOSP mapping may miss some vendor-
customized permissions ( e.g.,huawei.permission.SET_SMSC_AD-
DRESS ), which may be used in the custom ROM apps. Nevertheless,
we argue that using the AOSP mapping may miss some vulnerabili-
ties caused by the misuse of vendor-customized permissions but
will not affect the results corresponding to the official permissions,
serving as the main scope of our study.
Permission Over-privilege Detection. Android app developers
access Android framework functionalities by invoking Android
APIs. Some APIs have access to sensitive information, such as read-
ing the contact list, are protected by permissions. Developers need
to request such permissions from the Android system before access-
ing the sensitive resources. Specifically, a list of required permis-
sions need to be declared in the AndroidManifest.xml file, and
the corresponding permissions protected APIs are to be invoked in
the appâ€™s implementation. According to the Android developersâ€™
documentation [ 5], app developers should request a minimum set
of permissions required to complete the appâ€™s functionality, as intro-
ducing additional permissions will increase the risk of privacy leak.
However, developers usually (either intentionally or unintention-
ally) request permissions that are not related to the functionalities
actually implemented in the app, and hence, not necessary [17].
To detect apps with the permission over-privilege issue, we ex-
tract the reachable APIs of the app with a 30-min timeout for all
approaches ( i.e., NatiDroid, Arcade, and Axplorer), and retrieve
its protection conditions ( e.g., permission, UID,PID) according to
the mappings. For instance, when invoking an Android API, it
may check the UID (e.g.,uid == AID_SYSTEM checks if the app
has system privilege) and the PID(e.g.,callingPid == getpid()
examines if the method is called by its own process) along with
permission enforcement. While the UIDcan be retrieved statically,
780ESEC/FSE â€™22, November 14â€“18, 2022, Singapore, Singapore C. Li, X. Chen, R. Sun, M. Xue, S. Wen, M. E. Ahmed, S. Camtepe, Y. Xiang
Table 4: Permission over-privilege detection results
Data Set SourceAnalyzable
AppsAvg # Unneeded Permissions per App# of False Positive
Permissions% of Apps that
Have False Positives
Nati + Ar1Ar Nati + Ax Ax Nati + Ar Nati + Ax Nati + Ar Nati + Ax
Custom ROM AppsXiaomi (7.0) 345 13.41 13.7 10.94 11.18 102 84 19.13% 17.97%
LG (7.0) 215 12.76 13.17 10.24 10.6 88 77 25.12% 24.19%
Samsung (7.0) 266 11.58 12.0 9.44 9.82 113 101 22.93% 21.8%
Huawei (7.0) 111 13.53 14.02 11.14 11.56 54 47 24.32% 22.52%
Total (7.0) 937 12.75 13.14 10.38 10.71 357 309 22.2% 21.02%
Third-party Apps Google Play Store 9,475 6.03 6.88 3.52 4.36 8,063 7,894 71.5% 71.38%
1Nati :NatiDroid ;Ar:Arcade ;Ax:Axplorer ;+: merge the two mappings.
thePIDhas to be determined at run-time, thereby cannot be ob-
tained through static analysis. Nevertheless, the apps included in
the experiment are custom ROM apps and third-party apps, which
cannot possess PIDof Android system services. Therefore, it is
safe to assume that callingPid == getpid() will always return
false in our tested apps. Finally, if the app declares permission (in
theAndroidManifest.xml file) that is not required ( i.e., no APIs
associated with the permissions found in the app), we flag it as an
over-privilege case.
Results. The over-privilege detection costs 15 seconds per app
on average. The most time-consuming step ( i.e., extracting reach-
able APIs in the apps) is the same in each benchmark approach.
Hence, time-overhead has negligible difference after integrating
NatiDroid into the benchmark approaches. Table 4 presents the
over-privilege detection results. To demonstrate the effectiveness
of our mappings in pinpointing the permission over-privilege issue,
we compare previous worksâ€™ results with our results. Recall that
NatiDroid only extracts protection mappings from the Native li-
braries, in our results ( i.e.,Nati + Ar andNati + Ax ), the Java-side
mappings are derived from Arcade andAxplorer . We identify
95.8% and 95.5% apps with a permission over-privilege issue using
Arcade â€™s and Axplorer â€™s mappings, respectively. Among their
results, we identify that 66.85% and 67.06% (in Arcade â€™s and Ax-
plorer â€™s results, respectively) contain false-positive results caused
by missing Native-triggered permission mappings. Specifically, as
shown in the last four columns of Table 4, there are 8,063 and 357
permissions that are erroneously identified as over-privilege by
Axplorer in 71.5% third-party apps and 22.2% custom ROM apps,
respectively; for Axplorer , 7,894 permissions in 71.38% third-party
apps and 309 permissions in 21.02% custom ROM apps are found to
be false-positive.
Interestingly, both Arcade andAxplorer report that a signif-
icantly high proportion of apps (approximately 96%) suffer from
a permission over-privilege issue. We therefore take an in-depth
look into their detection results and observe that the majority of
their false positives are caused by missing native triggered INTER-
NETpermission mappings. As illustrated in Figure 9, we further
present the breakdown of permissions that cause the false positive
results in the comparing methods. Specifically, missing INTERNET
permission mappings leads to 6,661 and 6,660 false positives in Ar-
cade â€™s and Axplorer â€™s results. Other missing permission mappings
that contribute to the false positives include RECORD_AUDIO (623
false positives in both Arcade andAxplorer ),MODIFY_AUDIO_-
SETTINGS (424 and 256 false positives in Arcade andAxplorer ,
Figure 9: False-positive over-privileged permissions in previ-
ous works detected by NatiDroid .
respectively), and CAMERA (355 false positives in both Arcade and
Axplorer ).
Manual inspection. Due to the lack of ground truth, we manu-
ally inspect if the over-privileged permissions detected are indeed
unneeded by the containing apps. The first two authors of this
paper and three security researchers are involved in the manual
inspection. The result is determined via majority voting. For each
app, we decompile the APK file and locate the relevant APIs. Then,
we manually check the appâ€™s context and determine whether the
invocation of the APIs meet the conditions in the protection map-
pings. As this process involves immense manual efforts, it cannot
scale to cover a large number of apps. Hence, we manually verified
100 randomly selected apps. Our manual analysis indicates that
most of the cases are true positives (95%). The remaining five apps
contain implicit parameters passed to the APIs to be examined,
which cannot be precisely inferred via static analysis. Neverthe-
less, we resort to a dynamic approach to verify the remaining five
apps. Specifically, we remove the permissions in question from the
AndroidManifest.xml file and repackage the app. Then, we manu-
ally test the app on an emulator to confirm if the app crashes or the
corresponding functions are disabled. As a result, the removal of
the permissions in question has no impact on the apps, suggesting
that these permissions are indeed unneeded.
Answer to RQ3. Our tool identified that more than half of
the over-privilege results from state-of-the-practice tools are
false-positives, which is caused by missing Native-triggered
permission mappings.
5 THREATS TO VALIDITY
Android versions. In this paper, we propose a solution to facili-
tate cross-language static analysis of the Android framework and
781Cross-Language Android Permission Specification ESEC/FSE â€™22, November 14â€“18, 2022, Singapore, Singapore
build a prototype system, NatiDroid, to extract API-permission
mapping from the Android operating system. To compare with the
state-of-the-practice works Axplorer andArcade , which are close
sourced and only generated the mappings up to Android 7.1, in
our experiment, we extract the mappings from the latest versions
they have ( i.e., 7.0 and 7.1) and three newer versions ( i.e., 8.0, 8.1
and 10.0). Nevertheless, the proposed solution can apply to any
Android version, with further engineering works to be done in the
pre-processing module.
Custom ROMs. Android smartphones such as Samsung, Huawei
and Xiaomi, are shipped with vendor-customized Android systems
(i.e., custom ROMs) rather than the AOSP. Unfortunately, these
custom ROMs are not open-source. The proposed solution takes
the source code as input; therefore, it cannot extract permission
mappings from these close sourced custom ROMs. However, smart-
phone vendors can use our solution to analyze their customized
Android versions based on their source code. Nevertheless, to main-
tain the compatibility of running third-party apps, such custom
ROMs are not likely to modify the normal anddangerous level per-
mission specifications of AOSP that third-party apps can access, but
rather add a few signature level permissions for their own system
apps. Therefore, the results derived from AOSP will not affect the
security analysis of third-party apps, which are the majority in the
Android ecosystem. On the other hand, with NatiDroid , third-
party vendors can perform an inner security analysis on custom
ROM source code, determine whether there are errors in the imple-
mentation of permission mappings, and further detect permission
over-privilege before releasing an app.
Static analysis. When extracting the protection mapping, our
approach may suffer from the inherent limitations in generating
static ICFGs from both Java ( Soot ) and Native ( clang ) side. More-
over, some values and properties can only be obtained at runtime,
including runtime variables that may affect the conditional branch
and functions that can only be analyzed at runtime (e.g., memory
operations). When detecting over-privilege issues in Android apps,
we may suffer from the intrinsic vulnerability of static code analysis
when encountering code obfuscation and reflection, which may
lead to the unsoundness of our results. When building the appsâ€™ call
graph, our method may yield unsound results because it may miss
the context and the parameters that can only be obtained at run-
time. For example, the API android.media.MediaPlayer: void
setDataSource requires the Internet permission when the data
source is online media. The source is not always a static string so
that it may be assigned at run-time. Nevertheless, these challenges
are regarded as well known and non-trivial issues to overcome in
the research community [34].
6 RELATED WORK
Android API protection mapping. Stowaway [17] initially ex-
plored and analyzed the Android permission specification. They
extracted API mappings based on the feedback directed fuzz testing,
and dynamically recorded the permission checks of APIs. The map-
pings they extracted are accurate, but the code coverage is limited.
To address the limitations of low code coverage, PScout [12] uses
static analysis to extract the API protection mapping. However,
they did not consider the context of the API invocation, and thusmay produce false positive mappings. Axplorer [13] leverages
more accurate static analysis on the SDK and Android framework,
and generates more precise permission specifications. Arcade [9]
conducts a similar static analysis, with additional attention paid
to extract other security mechanisms, such as UIDandPIDchecks.
While these works only analyzed the Java-side of the Android, none
of the works has looked into the native libraries within the Android
framework. In order to overcome the limitations of static analy-
sis,Dynamo [15] uses dynamic analysis, aiming to obtain more
accurate mapping. PSGen [42] conducts an analysis permission
specification for Android NDK ( i.e., both protected APIs and per-
mission checks are in the Native code), which has a different scope
to our approach ( i.e., protected APIs are in the Java framework,
while the permission checks are in the Native code). Our work fills
the research gap by analyzing the native libraries and their commu-
nications with the Java framework to produce more comprehensive
permission protection mappings.
Cross-language analysis on Android. A plethora of works have
proposed to solve the analysis of cross-language code. Fourtou-
niset al. [21] scan the binary libraries and cross-referenced the
information to search the call-backs from Native code to Java. Their
work focuses on the JNI mechanism alone. However, the Android
framework provides IPC mechanisms, such as AIDL, which are not
considered. Wei et al. [40] propose a static analysis framework that
focuses on performing cross-language modeling and generating
call graphs for the analyzed apps. Jucify [36] conducts a static
analysis approach which extends the app analysis to native codes.
Zhou et al. [43] provide a hardware-assisted analyzer to solve the
issue that the native code analysis for native code in apps is in-
complete. Nevertheless, these works are only applicable to Android
apps, which are far less complicated than the Android framework
we analyzed. Specifically, the cross-language analysis approaches
analyze the communication between the appsâ€™ native libraries and
their Java-side components. The main technical challenge is Inter-
Component Communication handling, for example, the invocation
between Java and Native side methods through JNI. Our work an-
alyzes the communication between system components. One of
the main technical challenges is inter-procedural communication
between system components, such as AIDL/Binder.
7 CONCLUSION
We proposed a novel approach, NatiDroid , to facilitate the cross-
language analysis of the Android framework. NatiDroid identifies
the entry-point pairs of both Java- and Native-sides of the Android
framework, where both sides are communicated through JNIand
AIDL based mechanisms, so NatiDroid builds the cross-language
ICFG on the overall Android framework (Java + Native code). Based
on the cross-language ICFG, we extracted Native-triggered permis-
sion specifications and created the protection mappings in the
native code to complement existing Java-based mappings. We fur-
ther applied our new mappings to detect permission over-privilege
vulnerabilities in a large dataset consisting of more than 11,000
Android apps. We finally show that using the mapping derived
byNatiDroid can identify a significant number of false results
existing in the state of the art, such as Axplorer andArcade .
782ESEC/FSE â€™22, November 14â€“18, 2022, Singapore, Singapore C. Li, X. Chen, R. Sun, M. Xue, S. Wen, M. E. Ahmed, S. Camtepe, Y. Xiang
REFERENCES
[1] 1999. Soot - Java Analysis Framework. http://sable.github.io/soot/.
[2] 2000. Clang: A C language family frontend for LLVM. https://clang.llvm.org.
[3]2000. Introduction to the Clang AST. https://clang.llvm.org/docs/
IntroductionToTheClangAST.html.
[4]2006. WALA: T.J. Watson Libraries for Analysis. https://github.com/wala/WALA.
[5]2008. Developer Guides | Android Developers. https://developer.android.com/
guide.
[6] 2012. Soong Build System. https://source.android.com/setup/build.
[7] 2021. Android Open Source Project. https://source.android.com.
[8]2021. Google Play - Camera360 Photo Editor + Camera & Beauty Selfies. https:
//play.google.com/store/apps/details?id=vStudio.Android.Camera360.
[9]Yousra Aafer, Guanhong Tao, Jianjun Huang, Xiangyu Zhang, and Ninghui Li.
2018. Precise Android API protection mapping derivation and reasoning. In
Proceedings of the 2018 ACM SIGSAC Conference on Computer and Communications
Security . 1151â€“1164. https://doi.org/10.1145/3243734.3243842
[10] Yousra Aafer, Nan Zhang, Zhongwen Zhang, Xiao Zhang, Kai Chen, XiaoFeng
Wang, Xiaoyong Zhou, Wenliang Du, and Michael Grace. 2015. Hare hunting
in the wild Android: A study on the threat of hanging attribute references. In
Proceedings of the 22nd ACM SIGSAC Conference on Computer and Communications
Security . 1248â€“1259. https://doi.org/10.1145/2810103.2813648
[11] Steven Arzt, Siegfried Rasthofer, Christian Fritz, Eric Bodden, Alexandre Bar-
tel, Jacques Klein, Yves Le Traon, Damien Octeau, and Patrick McDaniel. 2014.
Flowdroid: Precise context, flow, field, object-sensitive and lifecycle-aware
taint analysis for Android apps. ACM SIGPLAN Notices 49, 6 (2014), 259â€“269.
https://doi.org/10.1145/2666356.2594299
[12] Kathy Wain Yee Au, Yi Fan Zhou, Zhen Huang, and David Lie. 2012. Pscout:
analyzing the Android permission specification. In Proceedings of the 2012 ACM
conference on Computer and Communications Security . 217â€“228. https://doi.org/
10.1145/2382196.2382222
[13] Michael Backes, Sven Bugiel, Erik Derr, Patrick McDaniel, Damien Octeau,
and Sebastian Weisgerber. 2016. On Demystifying the Android Application
Framework:{Re-Visiting}Android Permission Specification Analysis. In 25th
USENIX security symposium (USENIX security 16) . 1101â€“1118.
[14] Xiao Chen, Wanli Chen, Kui Liu, Chunyang Chen, and Li Li. 2021. A comparative
study of smartphone and smartwatch apps. In Proceedings of the 36th Annual
ACM Symposium on Applied Computing . 1484â€“1493. https://doi.org/10.1145/
3412841.3442023
[15] Abdallah Dawoud and Sven Bugiel. 2021. Bringing balance to the force: Dynamic
analysis of the android application framework. In NDSS . https://doi.org/10.14722/
ndss.2021.23106
[16] Manuel Egele, David Brumley, Yanick Fratantonio, and Christopher Kruegel.
2013. An empirical study of cryptographic misuse in android applications. In
Proceedings of the 2013 ACM SIGSAC conference on Computer & communications
security . 73â€“84. https://doi.org/10.1145/2508859.2516693
[17] Adrienne Porter Felt, Erika Chin, Steve Hanna, Dawn Song, and David Wagner.
2011. Android permissions demystified. In Proceedings of the 18th ACM conference
on Computer and Communications Security . 627â€“638. https://doi.org/10.1145/
2046707.2046779
[18] Xiaotao Feng, Ruoxi Sun, Xiaogang Zhu, Minhui Xue, Sheng Wen, Dongxi Liu,
Surya Nepal, and Yang Xiang. 2021. Snipuzz: Black-box fuzzing of iot firmware
via message snippet inference. In Proceedings of the 2021 ACM SIGSAC Conference
on Computer and Communications Security . 337â€“350. https://doi.org/10.1145/
3460120.3484543
[19] Yu Feng, Saswat Anand, Isil Dillig, and Alex Aiken. 2014. Apposcopy: Semantics-
based detection of Android malware through static analysis. In Proceedings of
the 22nd ACM SIGSOFT International Symposium on Foundations of Software
Engineering . 576â€“587. https://doi.org/10.1145/2635868.2635869
[20] Earlence Fernandes, Jaeyeon Jung, and Atul Prakash. 2016. Security analysis
of emerging smart home applications. In 2016 IEEE symposium on security and
privacy (SP) . IEEE, 636â€“654. https://doi.org/10.1109/SP.2016.44
[21] George Fourtounis, Leonidas Triantafyllou, and Yannis Smaragdakis. 2020. Iden-
tifying Java calls in native code via binary scanning. In Proceedings of the 29th
ACM SIGSOFT International Symposium on Software Testing and Analysis . 388â€“400.
https://doi.org/10.1145/3395363.3397368
[22] Michael I Gordon, Deokhwan Kim, Jeff H Perkins, Limei Gilham, Nguyen Nguyen,
and Martin C Rinard. 2015. Information flow analysis of Android applications in
DroidSafe. In NDSS , Vol. 15. 110. https://doi.org/10.14722/ndss.2015.23089
[23] Michael C Grace, Yajin Zhou, Zhi Wang, and Xuxian Jiang. 2012. Systematic
detection of capability leaks in stock Android smartphones. In NDSS , Vol. 14. 19.
[24] Jianjun Huang, Xiangyu Zhang, and Lin Tan. 2016. Detecting sensitive data dis-
closure via bi-directional text correlation analysis. In Proceedings of the 2016 24th
ACM SIGSOFT International Symposium on Foundations of Software Engineering .
169â€“180. https://doi.org/10.1145/2950290.2950348
[25] Soo Hyeon Kim, Daewan Han, and Dong Hoon Lee. 2013. Predictability of
android OpenSSLâ€™s pseudo random number generator. In Proceedings of the2013 ACM SIGSAC conference on Computer & Communications Security . 659â€“668.
https://doi.org/10.1145/2508859.2516706
[26] Chaoran Li, Xiao Chen, Derui Wang, Sheng Wen, Muhammad Ejaz Ahmed,
Seyit Camtepe, and Yang Xiang. 2021. Backdoor attack on machine learning
based android malware detectors. IEEE Transactions on Dependable and Secure
Computing (2021). https://doi.org/10.1109/TDSC.2021.3094824
[27] Li Li, Alexandre Bartel, Jacques Klein, Yves Le Traon, Steven Arzt, Siegfried
Rasthofer, Eric Bodden, Damien Octeau, and Patrick Mcdaniel. 2014. I know
what leaked in your pocket: Uncovering privacy leaks on Android Apps with
Static Taint Analysis. arXiv preprint arXiv:1404.7431 (2014).
[28] Tongxin Li, Xiaoyong Zhou, Luyi Xing, Yeonjoon Lee, Muhammad Naveed, Xi-
aoFeng Wang, and Xinhui Han. 2014. Mayhem in the push clouds: Understanding
and mitigating security hazards in mobile push-messaging services. In Proceedings
of the 2014 ACM SIGSAC Conference on Computer and Communications Security .
978â€“989. https://doi.org/10.1145/2660267.2660302
[29] Baozheng Liu, Chao Zhang, Guang Gong, Yishun Zeng, Haifeng Ruan, and
Jianwei Zhuge. 2020. {FANS}: Fuzzing Android Native System Services via
Automated Interface Analysis. In 29th USENIX Security Symposium (USENIX
Security 20) . 307â€“323.
[30] Kangjie Lu, Zhichun Li, Vasileios P Kemerlis, Zhenyu Wu, Long Lu, Cong Zheng,
Zhiyun Qian, Wenke Lee, and Guofei Jiang. 2015. Checking more and alerting
less: Detecting privacy leakages via enhanced data-flow analysis and peer voting.
InNDSS . https://doi.org/10.14722/ndss.2015.23287
[31] Mohammad Nauman, Sohail Khan, and Xinwen Zhang. 2010. Apex: Extending
Android permission model and enforcement with user-defined runtime con-
straints. In Proceedings of the 5th ACM symposium on Information, Computer and
Communications Security . 328â€“332. https://doi.org/10.1145/1755688.1755732
[32] Damien Octeau, Patrick McDaniel, Somesh Jha, Alexandre Bartel, Eric Bodden,
Jacques Klein, and Yves Le Traon. 2013. Effective {Inter-Component}Communi-
cation Mapping in Android: An Essential Step Towards Holistic Security Analysis.
In22nd USENIX Security Symposium (USENIX Security 13) . 543â€“558.
[33] Rahul Pandita, Xusheng Xiao, Wei Yang, William Enck, and Tao Xie. 2013.
{WHYPER}: Towards automating risk assessment of mobile applications. In
22nd USENIX Security Symposium (USENIX Security 13) . 527â€“542.
[34] Felix Pauck, Eric Bodden, and Heike Wehrheim. 2018. Do android taint analysis
tools keep their promises?. In Proceedings of the 2018 26th ACM Joint Meeting on
European Software Engineering Conference and Symposium on the Foundations of
Software Engineering . 331â€“341. https://doi.org/10.1145/3236024.3236029
[35] Zhengyang Qu, Vaibhav Rastogi, Xinyi Zhang, Yan Chen, Tiantian Zhu, and
Zhong Chen. 2014. Autocog: Measuring the description-to-permission fidelity
in Android applications. In Proceedings of the 2014 ACM SIGSAC Conference on
Computer and Communications Security . 1354â€“1365. https://doi.org/10.1145/
2660267.2660287
[36] Jordan Samhi, Jun Gao, Nadia Daoudi, Pierre Graux, Henri Hoyez, Xiaoyu Sun,
Kevin Allix, and BissyandÃ©. 2022. JuCify: A Step Towards Android Code Unifica-
tion for Enhanced Static Analysis. In 2022 IEEE/ACM 44th International Conference
on Software Engineering (ICSE) . https://doi.org/10.1145/3510003.3512766
[37] Ruoxi Sun, Wei Wang, Minhui Xue, Gareth Tyson, Seyit Camtepe, and Damith C
Ranasinghe. 2021. An empirical assessment of global COVID-19 contact tracing
applications. In 2021 IEEE/ACM 43rd International Conference on Software Engi-
neering (ICSE) . IEEE, 1085â€“1097. https://doi.org/10.1109/ICSE43902.2021.00101
[38] Xiaoyu Sun, Xiao Chen, Kui Liu, Sheng Wen, Li Li, and John Grundy. 2021.
Characterizing Sensor Leaks in Android Apps. In 2021 IEEE 32nd International
Symposium on Software Reliability Engineering (ISSRE) . IEEE, 498â€“509. https:
//doi.org/10.1109/ISSRE52982.2021.00058
[39] Raja VallÃ©e-Rai, Phong Co, Etienne Gagnon, Laurie Hendren, Patrick Lam, and
Vijay Sundaresan. 2010. Soot: A Java bytecode optimization framework. In
CASCON First Decade High Impact Papers . 214â€“224. https://doi.org/10.1145/
1925805.1925818
[40] Fengguo Wei, Sankardas Roy, and Xinming Ou. 2018. Amandroid: A precise and
general inter-component data flow analysis framework for security vetting of
Android apps. ACM Transactions on Privacy and Security (TOPS) 21, 3 (2018),
1â€“32. https://doi.org/10.1145/3183575
[41] Kunpeng Zhang, Xi Xiao, Xiaogang Zhu, Ruoxi Sun, Minhui Xue, and Sheng
Wen. 2022. Path transitions tell more: Optimizing fuzzing schedules via runtime
program states. In 2022 IEEE/ACM 43rd International Conference on Software
Engineering (ICSE) . https://doi.org/10.1145/3510003.3510063
[42] Hao Zhou, Haoyu Wang, Shuohan Wu, Xiapu Luo, Yajin Zhou, Ting Chen, and
Ting Wang. 2021. Finding the Missing Piece: Permission Specification Analysis
for Android NDK. In 2021 36th IEEE/ACM International Conference on Automated
Software Engineering (ASE) . 505â€“516. https://doi.org/10.1109/ASE51524.2021.
9678843
[43] Hao Zhou, Shuohan Wu, Xiapu Luo, Ting Wang, Yajin Zhou, Chao Zhang, and
Haipeng Cai. 2022. NCScope: Hardware-Assisted Analyzer for Native Code
in Android Apps. In Symposium on Software Testing and Analysis (ISSTAâ€™22) .
https://doi.org/10.1145/3533767.3534410
783