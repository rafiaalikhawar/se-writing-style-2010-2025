DeclarativeSmartContracts
Haoxian Chen
Universityof Pennsylvania
USA
hxchen@seas.upenn.eduGeraldWhitters
Universityof Pennsylvania
USA
whitters@seas.upenn.eduMohammad Javad Amiri
Universityof Pennsylvania
USA
mjamiri@seas.upenn.edu
Yuepeng Wang
SimonFraserUniversity
Canada
yuepeng@sfu.caBoonThauLoo
Universityof Pennsylvania
USA
boonloo@seas.upenn.edu
ABSTRACT
Thispaperpresents DeCon,adeclarativeprogramminglanguage
for implementing smart contracts and specifying contract-level
properties. Driven by the observation that smart contract opera-
tions and contract-level properties can be naturally expressed as
relationalconstraints,DeConmodelseachsmartcontractasaset
of relational tables that store transaction records. This relational
representation ofsmart contracts enables convenient specification
ofcontract properties,facilitatesrun-timemonitoringofpotential
property violations, and brings clarity to contract debugging via
data provenance. Specifically, a DeCon program consists of a set
of declarative rules and violation query rules over the relational
representation, describing the smart contract implementation and
contract-level properties, respectively. We have developed a tool
that can compile DeCon programs into executable Solidity pro-
grams, with instrumentation for run-time property monitoring.
OurcasestudiesdemonstratethatDeConcanimplementrealistic
smartcontractssuchasERC20andERC721digitaltokens.Oureval-
uation results reveal the marginal overhead of DeCon compared to
theopen-sourcereferenceimplementation,incurring 14%median
gas overhead for execution, and another 16%median gas overhead
for run-time verification.
CCS CONCEPTS
¬∑Software and its engineering ‚ÜíDomain specific languages .
KEYWORDS
Smartcontracts, Declarative programming, Run-time verification
ACMReference Format:
HaoxianChen,GeraldWhitters,MohammadJavadAmiri,YuepengWang,
andBoonThauLoo.2022.DeclarativeSmartContracts.In Proceedingsofthe
30th ACM Joint European Software Engineering Conference and Symposium
on the Foundations of Software Engineering (ESEC/FSE ‚Äô22), November 14≈õ
18,2022,Singapore,Singapore. ACM,NewYork,NY,USA, 13pages.https:
//doi.org/10.1145/3540250.3549121
Permissionto make digitalor hard copies of allorpart ofthis work for personalor
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
onthefirstpage.Copyrights forcomponentsofthisworkownedbyothersthanthe
author(s)mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,or
republish,topostonserversortoredistributetolists,requirespriorspecificpermission
and/or a fee. Request permissions from permissions@acm.org.
ESEC/FSE ‚Äô22, November 14≈õ18,2022, Singapore, Singapore
¬©2022 Copyright heldby the owner/author(s). Publicationrightslicensed to ACM.
ACM ISBN 978-1-4503-9413-0/22/11...$15.00
https://doi.org/10.1145/3540250.35491211 INTRODUCTION
Smart contracts are programs stored and executed on blockchains.
They have been used in a wide range of blockchain-enabled dis-
tributedapplicationstomanagedigitalassets,includingauctions
[35], financial contracts [ 23], elections [ 47], trading platforms [ 50],
and permission management [ 19]. Unfortunately, today‚Äôs smart
contractsareerror-prone,andthishasledtosignificantfinancial
losses resultingfrom attackssuch asDice2win[ 51], Kingof Ether
[2], Parity Multisig Bug [ 61], Accidental[ 24]andDAO[ 1,58].
Over the past few years, different analysis and verification tech-
niques have been proposed for known vulnerabilities of smart
contracts, such as re-entrancy attacks and transaction-order de-
pendency[ 17,32,52,56,63].However,whenitcomestohigh-level
properties specific to individual smart contracts, programmers typ-
icallyhavetorelyonhand-writtenassertions[ 10],whichishard
tomaintainanderror-prone.Forexample,givenasmartcontract
that manages digital tokens, one may want to ensure that all ac-
count balances add up to the total supply of tokens. To monitor
thispropertyduringrun-time,onehastoinstrumentthecodeto
maintainastatethatkeepstrackofthesumofallaccountbalances,
andaddassertionsabouttheirequivalencewherevereitheraccount
balances or token supplies are updated. There are third-party tools
thatsupporthigh-levelproperty specificationand verification for
Solidity, e.g., temporal logic [ 52] and formula with extended opera-
tors[44].However,counter-examplesarereturnedintheformof
Ethereumbytecodetracesortransactionsequences,whichmaynot
be easy for programmers to understand and localize bugs in the
originalimplementation.
To make smart contracts easier to analyze and verify, this paper
presentsDeCon,adeclarativeprogramminglanguageforsmartcon-
tractimplementationandpropertyspecification.DeConisbased
on Datalog [ 15], a declarative logic programming language that
syntacticallyisasubsetofProlog.Datalogfreesprogrammersfrom
low-levelimplementationdetails,e.g.,datastructures,algorithms,
etc., and allows them to reason about the contract on the speci-
ficationlevelviainferencerules[ 22].Inaddition,suchrelational
representation serves as a high-level abstraction of the contract,
whichenables efficient formalanalysisandverification [ 59,64].
A typical smart contract provides two kinds of interfaces: trans-
actionsandviews. Transactions are function calls that alter the
contract states, e.g.,a token transferthatupdates bothsenderand
recipientbalances.Viewsareread-onlyfunctionsthatreturnpar-
ticularstates ofthe contract, e.g.,the balanceof an account.
281
ESEC/FSE ‚Äô22, November14≈õ18, 2022,Singapore, Singapore HaoxianChen, GeraldWhitters,Mohammad Javad Amiri, Yuepeng Wang,andBoonThauLoo
Smartcontractpropertiesandoperationscanbenaturallymapped
torelationallogic.Forexample,transactions,themainelementin
smartcontracts,canbemodeledasrelationaltables,wherethetable
schemacontainstransactionparameters,e.g.,sender,recipient,and
amount. Similarly, the balance of each account can be expressed as
sum aggregation on transaction records and lookingup an account
balance can be expressed as a constraint on the address column of
the balancetable.
Given this relational view of transactions, committing a transac-
tion can be interpreted as appending a new row to the correspond-
ingtable. The commit andabortion logicof apendingtransaction
isspecifiedbyDatalog-baseddeclarativerules.Viewscanthenbe
specified as declarative queries on these tables. For example, an
account balance is the total income of the account subtracted by
itstotalexpense,eachofwhichisa query onrelevanttransaction
records.
Contractpropertiesarealsospecifiedasinferencerules.Theyare
interpretedaspropertyviolationqueries,aspecialkindofviews,
and are expected to be always empty during correct executions.
Forexample,ifasmartcontractforbidsoverspending,thenaquery
on accounts withnegative balancesshould always be empty. Such
unification of implementation and property specification language
saves programmers‚Äô effort to learn another language to formally
specifyproperties.
DeCon complies declarative specifications into executable So-
lidity[11]programsthatrunonblockchains,e.g.,Ethereum,and
monitor the specified properties at run-time. When a property
(violation) view is derived non-empty after executing a pending
transaction,thetransactionisaborted.Suchautomaticcodegen-
erationnotonlysavesimplementationeffort,butalsoeliminates
the gap between the program specification and implementation,
providingastronger guarantee ofthe verification result.
Thekeyinsighttogenerateefficientexecutablecodefromdeclar-
ativespecificationsisthatsmartcontracttransactionsareexecuted
insequence.Inotherwords,newrowsareappendedtothetrans-
actiontablesoneatatime.Therefore,DeConborrowstheideaof
incremental view maintenance in databases [ 34] to generate effi-
cientupdateprocedures.Oncommittinganewtransaction,instead
of evaluating the queries on the whole tables, only the differences
inquery results are computedandappliedto existing views.
In addition,DeCon is easyto debug withdata provenance [ 25].
Provenance is a mechanism for explaining how certain tuples or
factsarederived,rightdowntotheinputvalues.Inanimperative
languagelikeSolidity[ 11],dependencyinformationisdifficultto
becapturedautomatically(throughdata-flowanalysis).Incontrast,
inference rules in DeCon give explicit dependency information,
where each tuple can be directly attributed to one rule, thus pro-
vidingmore clarity to the executionprocess.
The key contributionsofthe paper are as follows:
‚Ä¢We design DeCon, a declarative language that unifies smart
contract implementation and specification. We demonstrate
itsexpressivenessviacasestudiesonrepresentativesmart
contracts andtheirhigh-level correctness properties.
‚Ä¢Wedesign analgorithmtocompilethesehigh-level specifi-
cationsintoexecutableSolidityprograms,withinstrumen-
tation for run-time verification.‚Ä¢We implement and experimentally evaluate DeCon. Our
evaluation shows that the generated executable code has
comparableefficiencywiththeequivalentopen-sourceim-
plementation of the same contract ( 14%median gas over-
head),andtheoverheadofrun-timeverificationismoderate
(16%median gas overhead). The prototype implementation
and evaluation benchmarks are open-sourced [ 5] for future
studiesandcomparisons.
Therestofthispaperisorganizedasfollows.Section 2motivates
DeCon using a Wallet example. The declarative smart contract
language is presented in Section 3. Section 4demonstrates the
translationofdeclarativerulesintoanexecutableSolidityprogram.
TheexpressivenessofDeConispresentedinSection 5usingtwo
casestudies.Section 6experimentallyevaluatesDeCon.Section 7
discussesrelatedwork, andSection 8concludes the paper.
2 ILLUSTRATIVE EXAMPLE
Inthissection,weshowhowtouseDeContoimplementasmart
contract, specify itsproperties, anddebug via provenance using a
Walletsmart contract that manages digital tokens.
2.1 Contract Implementation
A smart contract offers two kinds of interfaces: transactions and
views. Transactions are the function calls that update the contract
states.Ontheotherhand,viewsareread-onlyfunctionsthatreturn
one ormore contract states.
Indeclarativesmartcontracts,transactionrecordsaretheonly
states. Transactions are modeled as relational tables. A new row is
appended to the table when a new transactionis committed, with
column entries storing the transaction parameters. Transaction
rules,i.e.,theconditiononwhichanewtransactioncanbecommit-
ted,arespecifiedasdeclarativerules.Finally,viewsarespecifiedas
declarative queriesover the transaction tables.
WeusetheWalletexample,showninListing 1,toexplainhow
relationaltablesanddeclarative rulescanbespecified. TheWallet
contract manages token transactions between Ethereum addresses,
where the contract owner can mint or burn tokens to addresses,
anddifferentaddresses can transfer tokens to eachother.
Relationsandinterfaces. Lines1to14declaretherelations,with
schemaintheparenthesis,and,optionally,primarykeyindicesin
thebracket(e.g., balanceOfonline8).Primarykeysuniquelyidentify
arowinthetable.Forinstance, balanceOfrecordsthebalanceofeach
account,andthushasauniqueaccountcolumn.Withoutexplicit
specification, all columns are treated as primary keys. Relation
totalSupply (line 7) is a singleton relation, a kind of relation that
contains only one rowandisannotatedbyastar symbol.
Given these relation declarations, transaction and view inter-
facesaregenerated.First,transactioninterfacesaregeneratedfrom
relationswith recv_prefix,wheretheinputparametersdefinethe
schema and a Boolean return value indicates the success of the
transaction. For example, relation recv_mintis translated into the
following interfaceinSolidity,the target executablelanguage.
function mint(address p,intamount) returns (bool);
Second,viewfunctionsaregeneratedfromtherelationsthatappear
inthepublicinterfaceannotations(line9).Theinputparameters
282Declarative SmartContracts ESEC/FSE ‚Äô22, November14≈õ18, 2022,Singapore, Singapore
1// Transaction event triggers
2.declrecv_mint(p: address , amount: int)
3.declrecv_burn(p: address , amount: int)
4.declrecv_transfer(from: address ,to:address ,n:int)
5
6// Views
7.decl*totalSupply(n: int)
8.declbalanceOf(p: address , n:int)[0]
9.public totalSupply,balanceOf
10
11// Transaction rules
12.declmint(p: address , amount: int)
13.declburn(p: address , amount: int)
14.decltransfer(from: address , to:address , n:int)
15r1: mint(p,n):-recv_mint(p,n),msgSender(s),owner(s),
16 n>0.
17r2: burn(p,n):-recv_burn(p,n),msgSender(s),owner(s),
18 balanceOf(p,m), n<=m.
19r3: transfer(s,r,n) :- recv_transfer(s,r,n),
20 balanceOf(s,m),m>=n, n>0.
21
22// View rules
23r4: totalSupply(n):-allMint(m),allBurn(b),n:=m-b.
24r5: balanceOf(p,s):-totalOut(p,o),totalIn(p,i),s:=i-o.
25
26// Auxiliary relations and rules ...
27.decltotalMint(p: address , n:int)[0]
28.decltotalBurn(p: address , n:int)[0]
29r6: transfer(0,p,n) :- mint(p,n).
30r7: transfer(p,0,n) :- burn(p,n).
31r8: totalOut(p,s):-transfer(p,_,_),
32 s=sumn:transfer(p,_,n).
33r9: totalIn(p,s):-transfer(_,p,_),
34 s=sumn:transfer(_,p,n).
35.decl*allMint(n: int)
36.decl*allBurn(n: int)
37r10: allMint(s) :- s = sumn: mint(_,n).
38r11: allBurn(s) :- s = sumn: burn(_,n).
Listing 1:Walletsmart contract
are the primary keys, and the output is the remaining values. Note
that since a singleton relation, e.g., totalSupply , has no primary
keys,it becomes a function withoutparameters. If all columnsare
primary keys, then the function returns a Boolean value indicating
theexistenceoftherow.Forexample, balanceOf(p:address, n:int)[0]
istranslatedintothe following functioninterface.
function balanceOf( address p)returns (int);
Rules and functions. The rest of the program shows the rules
thatprocesstransactionsanddefinetheviews.Eachruleisofthe
form<head> :- <body> , interpreted as follows. For all valuation of
the variables that satisfy all constraints in the body, generate a
row as specified in the head. For example, r1on line 15 says that
aminttransactioncanonly besent bythe contract owner,and the
amount should always greater than 0. This rule is compiled into
the following Soliditycode (withsimplification).
function mint(address p,intn) (returns bool) {
boolret =false;
if(msg.sender == owner && n>0) {
// call functions to update dependent views...
ret =true;
}
return ret;
}
Whena minttransactioniscommitted, r5willbetriggeredthrough
achainofrules( r1->r6->r9->r5 ).Itspecifiesthebalanceofanaccount
p,asthetotalincome totalIn(p,i) subtractedbythetotalexpense
totalOut(p,o) , withtotalInandtotalOutfurther defined by r8andr9,respectively.ThisruleiscompiledintotwoSolidityfunctions,each
updates balanceOf[p] when either totalInortotalOutisupdated.
function updateBalanceOfOnTotalIn( address p,inti) {
into = totalOut[p];
balanceOf[p] = i-o;
}
function updateBalanceOfOnTotalOut( address p,into) {
inti = totalIn[p];
balanceOf[p] = i-o;
}
To get the balance of a given account, one could call balanceOf, a
viewfunctionthattakestheaccountaddressasaparameter,and
returnsanintegervalueastheaccountbalance.InDeCon,relational
tablesarestoredinmaps,mappingprimarykeystovaluesinthe
remaining columns. This viewfunction isgeneratedas follows.
function balanceOf( address p)public view returns (int)
{
// Read the row by primary key p
BalanceOfTuple memory balanceOfTuple = balanceOf[p];
// Return the value
return balanceOfTuple.n;
}
2.2 SpecificationandRun-Time Verification
In DeCon, properties are specified the same way as views, but
with additional annotation. For example, in the Wallet contract,
one may want to make sure that all account balances are always
non-negative,whichcan be specifiedas follows.
.declnegativeBalance(p: address ,n:int)[0]
.violation negativeBalance
r14: negativeBalance(p,n) :- balanceOf(p,n), n < 0.
Ruler14specifiestheviolationinstanceoftheproperty:foreach
row inbalanceOf table with n<0, insert a row (p,n)innegativeBalance
table.Duringtheexecutionofthetransaction,the negativeBalance
table is incrementally updated when its dependent relations are
updated,the same as otherviews.
The keyword .violation annotates that every row in the table is
a property violation instance. A property is satisfied if and only
if its corresponding violation table is empty. Given such annota-
tions,DeConinstrumentstheprogramtochecktheemptinessof
allviolation tables before eachtransaction iscommitted.
Notethatpropertiesaremonitoredonthegranularityoftrans-
actions. As we show in Section 4, due to the underlying update
procedure, transient violations could occur during the execution
of a transaction, but disappear at the end. Therefore, instead of
abortingrightafteraviolationtupleisderived,atransactionisonly
abortedif,attheendofitsexecution,anyviolationtableremains
non-empty.Suchinterpretationallowsprogrammerstoreasonat
thetransactionlevel,withoutworryingabouttheunderlyingup-
dateprocedure.
Theviolationcheckingprocedureisgeneratedandperformed
attheendofeachtransaction.Inthisexample,the negativeBalance
violation ischeckedas follows.
function checkViolations() {
ifnegativeBalance isnot empty:
revert("Negative‚ê£balance." )
// check other violations ...
}
283ESEC/FSE ‚Äô22, November14≈õ18, 2022,Singapore, Singapore HaoxianChen, GeraldWhitters,Mohammad Javad Amiri, Yuepeng Wang,andBoonThauLoo
balanceOf(0x01,-20)
totalIn(0x01,100) totalOut(0x01,120)r5
r8
burn(0x01,50) totalOut(0x01,70)
r2'
recv_burn(0x01,50)
Figure 1:Provenance ofaviolation ofnegative balance
2.3 DebuggingviaProvenance
Data provenance is afeature ofdeclarative programs that records
thedataflowfrominputtooutputandenablesrule-wisedebugging.
Itallows counter-exampletraces tobe presentedin thecontext of
theoriginalspecification,insteadofthelow-levelEVMinstructions,
thus makingthe debuggingprocessmore intuitive.
Suppose the original program has an incorrect r2, which misses
a predicate to check that the account has enough balance to be
burnt.The incorrect version of r2isshown as r2'in the following.
r2': burn(p,n):-recv_burn(p,n),msgSender(s),owner(s).
An account with a balance of ùëõwould have a negative balance
if more than ùëõtokens are burnt. Suppose during execution, the
account 0x01isdetectedtohaveanegativebalanceof ‚àí20.Toun-
derstandwhythisviolationhappens,onecouldquerytheviolation
tuple‚Äôs provenance tree, as shown in Figure 1. The provenance tree
is read from topto bottom. Onthe topis a tuple balanceOf(0x01,-20)
that triggers the violation in negativeBalance . Below shows that it
is derived by r5, based on totalIn(0x01,100) andtotalOut(0x01,120) ,
whicharethetotaltokensreceivedandsentbyaddress 0x01.The
tupletotalOut(0x01,120) isfurtherderivedby r8.Thisback-tracing
continues for another step until one finds the derivation of r2'
isincorrect,whichsuggeststhatthecondition balanceOf(p,m),m>=n
shouldbeadded.Withthisprovenance,programmerscan debug
contracts inavisual andinteractive manner.
3 LANGUAGE
ADeConcontractconsistsofthreeelements:relations,rules,and
relationannotations.A relationdeclarationspecifiesthenameof
a relational table and its schema. Each relational table can store
eithertransactionrecords,withthetransactionparametersbeing
the column values, or views, the summary information of these
transaction records. A rulespecifies either the conditions on which
anewtransactiongetsapprovedorthederivationofaviewfromthe
transactionrecords.Finally, relationannotations specifywhether
a relational table is a public view or a violation. Public views are
compiledintopublicinterfacesthattaketherelation‚Äôsprimarykeys
asparametersandreturntheremainingvaluesinthematchingrow.
Violations will be monitored during run-time, and a transaction is
reverted if the violation relation is non-empty after the transaction
execution.(ùëáùë¶ùëùùëí)ùëá:=ùëñùëõùë°|ùë¢ùëñùëõùë°|ùëèùëúùëúùëô|ùëéùëëùëëùëüùëíùë†ùë†
(ùëÜùëê‚Ñéùëíùëöùëé)ùëÜ:=ùëê1 :ùëá1,ùëê2 :ùëá2,...
(ùëÉùëüùëñùëöùëéùëüùë¶ùëòùëíùë¶ùë† )ùêæ:=ùëò1,ùëò2,...
(ùëÖùëíùë†ùëíùëüùë£ùëíùëëùëüùëíùëôùëéùë°ùëñùëúùëõ )ùëÖùëÜ
(ùëÜùëñùëõùëîùëôùëíùë°ùëúùëõùëüùëíùëôùëéùë°ùëñùëúùëõ )ùëÜùê∫:=.ùëëùëíùëêùëô‚àóùëü(ùëÜùëê‚Ñéùëíùëöùëé)
(ùëÜùëñùëöùëùùëôùëíùëüùëíùëôùëéùë°ùëñùëúùëõ )ùëÜùëÉ:=.ùëëùëíùëêùëô ùëü(ùëÜùëê‚Ñéùëíùëöùëé)[ùêæ]
(ùëáùëüùëéùëõùë†ùëéùëêùë°ùëñùëúùëõùëüùëíùëôùëéùë°ùëñùëúùëõ )ùëáùëÖ:=.ùëëùëíùëêùëô ùëüùëíùëêùë£ _[ùëü](ùëÜùëê‚Ñéùëíùëöùëé)
(ùëÖùëíùëôùëéùë°ùëñùëúùëõ)ùëÖ:=ùëÖùëÜ|ùëÜùê∫|ùëÜùëÉ
(ùê¥ùëõùëõùëúùë°ùëéùë°ùëñùëúùëõ )ùê¥:=.ùëùùë¢ùëèùëôùëñùëê ùëÖ |.ùë£ùëñùëúùëôùëéùë°ùëñùëúùëõùëÖ
Figure 2:Syntax ofrelation declarations and annotations
3.1 Relation DeclarationsandAnnotations
Theformalsyntaxofrelationdeclarationsandannotationsisde-
finedinFigure 2.
Schema. Schema of a relation is specified as a list of ùëêùëñ:ùëáùëñ, where
ùëêùëñisthe column name for the ùëñ-th column, and ùëáùëñisthe data type.
Primary keys. Primary keys ùêæare a list of indices in the relation
schema. Specifying Primary keys is optional. If a simple relation
isspecifiedwithoutprimarykeys,thenallcolumnsaretreatedas
primarykeys.Primarykeysuniquelyidentifya rowineachtable.
Oninsertinganewrow,ifanexistingrowhasthesameprimary
key,the existing rowisreplacedbythe newrow.
Singleton relations are relations with only one row, which are
annotated with ‚àóinthespecification. Whena new row is inserted
intoasingleton relation,itreplaces the existing row.
Transactionrelations arerelationswithprefix recv_.Asexplained
inthenextsection,theserelationsaretreatedaseventtriggerswhen
used in a rule, and are compiled into smart contract interfaces that
handle incomingtransaction requests.
Reservedrelations. Thefollowingrelationsarereservedtohandle
smart contract-specific constructs:
‚Ä¢msgSender(a:address) stores the address of messagesender.
‚Ä¢msgValue(v:uint) stores the values of Ethers sent along a message.
‚Ä¢send(to:address, n:uint32) triggersatransactionthatsends ùëõEthers
to anotheraccount.
‚Ä¢constructor(*) is translated into the constructor function, with
schemabeing function parameters.
3.2 Rules
AsshowninFigure 3,wedistinguishtwokindsofrules:transac-
tion rules and view rules. A transaction rule contains a transaction
relationinitsbody.Transactionrelationsarerelationswithaprefix
ùëüùëíùëêùë£_innames.Theserulesareonlyfiredonreceivingthecorre-
spondingtransactionrequest,andthetransactionisapprovedifthe
restoftheconstraintsintherulebodyaresatisfied.Ontheother
hand,aviewrule doesnotcontainanytransactionrelations.Itis
evaluatedwhenever one of the relations inthe body isupdated.
Syntaxrestrictions. DeCondoesnotsupportrecursions.Thatis,
no dependency loop exists between any two relations. The depen-
dencyrelationship inDeCon isdefinedas follows.
Definition3.1 (Relationdependency) .RelationùëÖùëéisdependent
onrelation ùëÖùëè,if there existsa view rule where ùëÖùëéis inthe head
284Declarative SmartContracts ESEC/FSE ‚Äô22, November14≈õ18, 2022,Singapore, Singapore
(ùëâùëéùëüùëñùëéùëèùëôùëí)ùë•
(ùê¥ùëîùëîùëüùëíùëîùëéùë°ùëñùëúùëõ )ùê¥ùëîùëî:=ùë†ùë¢ùëö|ùëöùëéùë•|ùëöùëñùëõ|ùëêùëúùë¢ùëõùë°
(ùêπùë¢ùëõùëêùë°ùëñùëúùëõ)ùêπ:=+| ‚àí | √ó |√∑
(ùê∂ùëúùëõùëëùëñùë°ùëñùëúùëõ )ùê∂:=>|<|>=|<=|==|!=
(ùëáùëüùëéùëõùë†ùëéùëêùë°ùëñùëúùëõùëüùëíùëôùëéùë°ùëñùëúùëõ )ùëáùëÖ:=ùëüùëíùëêùë£_[ùëü]
(ùëÇùë°‚Ñéùëíùëü ùëüùëíùëôùëéùë°ùëñùëúùëõ )ùëÖ
(ùêªùëíùëéùëëùëôùëñùë°ùëíùëüùëéùëô )‚Ñé:=ùëÖ(¬Øùëã)
(ùêµùëúùëëùë¶ùëôùëñùë°ùëíùëüùëéùëô )ùëè:=ùëÖ(¬Øùëã) |ùê∂(¬Øùëã) |ùë¶=ùêπ(¬Øùëã)
|ùë¶=ùê¥ùëîùëîùë•:ùëÖ(¬Øùëã)
(ùëáùëüùëéùëõùë†ùëéùëêùë°ùëñùëúùëõùëÖùë¢ùëôùëí )ùëáùë•:=‚Ñé:‚àíùëáùëÖ(¬Øùëã),ùëè1,...,ùëèùëõ
(ùëâùëñùëíùë§ ùëÖùë¢ùëôùëí )ùëâ:=‚Ñé:‚àíùëè1,...,ùëèùëõ
Figure 3:Syntax ofrules
andùëÖùëèis in the body, or a transaction rule where ùëÖùëéis in the head,
andùëÖùëèisatransactionrelation (withaprefix recv_) inthe body.
Rule semantics. A rule is evaluated as follows. For each variables
valuationùúãthat satisfies the rule constraint , generate the head
tuplewithallvariablesassignedtoitscorrespondingvaluesin ùúã.
Avariablevaluationisamappingfromthesetofvariablenames
ùëâto the variable domain ùê∑(ùúã:ùëâ‚Üíùê∑). Rule constraint is a
conjunction of all body literal constraints. As described in Figure 3,
there are four kinds of body literals. For literals in the form of
relational tuples ùëÖ(¬Øùëã), the constraint is satisfied if row ¬Øùëãexists
in the relational table ùëÖ. Other kinds of literals (i.e., conditions,
functions, and aggregations) are directly interpreted as constraints
onthe variables.
Consider r5inthe Walletexample (listing 1).
r5: balanceOf(p,s):-totalOut(p,o),totalIn(p,i),s:=i-o.
Thisruleisinterpretedasfollows:"forallvaluesofvariable p,o,i
suchthatthereexistsatuple totalOut(p,o) andtotalIn(p,i) ,derive
the head tuple balanceOf(p,s) ,where s = i-o".
Aggregationliteral ùê¥ùëîùëîùë•:ùëÖ(¬Øùëã)computestheaggregate forall
rowsinrelation ùëÖthatsatisfytheruleconstraint.Forexample,in
theWalletexample(listing 1),line31showsarulewithaggregation.
r8:totalOut(p,s) :- transfer(p,_,_),
s=sumn:transfer(p,_,n).
For each unique value of pin the first column of transfertable, this
rulecomputesthesumofthethirdcolumnforrowsin transfertable
that has the value pin the first column. In other words, this rule
groupsthetablebythefirstcolumn,andthencomputesthesumof
the thirdcolumn within eachgroup.
Limitationsinexpressiveness. DeConforbidsrecursionsinorder
to keep the gas consumption predictable and affordable. In fact,
recursionisnotrecommendedbytheSoliditydocumentationfor
stack spaceissues[ 7].
Inaddition,therearefunctionsthatlieoutsideofrelationallogic,
e.g.cryptographicoperations,randomizedfunctions,etc.Suchfunc-
tionscanbeimplementedinDeConbylinkingthecontractwithexternallibraries.However,analyzingsuchfunctionsischallenging
andwouldneedsubstantialfutureresearch.DeConalsodoesnot
supportcontractinheritance,dynamicdispatching,andchecking
interfaces of another contract. These features can be incorporated
intoDeCon infuture compilerdesigns.
4 COMPILATION TO SOLIDITY
DeCon translates a set of declarative rules into an executable Solid-
ityprogramthat(1)processestransactionsfollowingtheconditions
intransaction rules,(2)updates views incrementally as new trans-
actions are committed,and(3) monitors property violations.
The compilation processinvolves three majorsteps.
(1)Abstractupdatefunctions. First,eachruleistranslatedintoa
set of abstract update functions, each of which performs incremen-
talupdatestotheheadrelationwhenoneofthebodyrelationsis
updated.Thesefunctionsareabstractinthattheydonotimplement
concretedatastructures.Forexample,intheWalletcontract,the
following ruleprocesses minttransactions.
r1: mint(p,n):-recv_mint(p,n),msgSender(s),owner(s),n> 0.
This ruleistranslatedintothe following abstract updatefunction.
1on insert recv_mint(p,n) {
2 search ownerwhere {
3 address s = owner;
4 search msgSender wheres==msg.sender {
5 if(n>0) {
6 insert mint(p,n)
7 }}}}
Thisupdatefunctionistriggeredwhena minttransactionisreceived,
asindicatedbytheeventtriggertuple recv_mint(p,n) .Theremaining
two relational literals, owner(s)andmsgSender(s) , are translated into
nestedsearchstatements(line2andline4).Asearchstatementhas
the form (search R where C do S) , where Ris the relational table, Cis
the set of constraints on rows, and Sis the statement to execute for
each row that satisfies the constraints in C. The condition literal
(n>0)istranslatedintoan ifstatement(line5).Ifallpriorconditions
are satisfied,we arrive at line6, where the rulehead isinserted.
(2) Data structures. Theseabstractfunctionsare then translated
intoconcreteSoliditystatements,wherethe searchstatementsbe-
come efficient join algorithms on concrete data structures, and
update functions for dependent views are called after an insert
statement.
(3)Instrumentation. Inthelaststep,theSolidityprogramisinstru-
mentedtomonitorpropertyviolations,andabortthetransactionif
anyviolationhasbeendetectedbytheendoftransactionexecution.
4.1 AbstractUpdate FunctionGeneration
There are two kinds of updates that could trigger a rule: tuple
insertionandtupledeletion.Weuse Insert(e)andDelete(e)todenote
the update trigger on inserting and deleting a tuple ùëí, respectively.
Note that both a tuple and a literal have the form ùëÖ(¬Øùëã). It is called
atuplewhen ¬Øùëãhasconcretevalues,andiscalledliteralinarule,
where¬Øùëãissymbolic.Weuseliteralandtupleinterchangeablyin
the following discussionof updatetriggers.
Givenarule ùëü,letùêµ(ùëü)bethesetofallrelationalliteralsin ùëü‚Äôs
body, andùëíbe the transactionrelation in ùëüifùëüis atransaction rule,
285ESEC/FSE ‚Äô22, November14≈õ18, 2022,Singapore, Singapore HaoxianChen, GeraldWhitters,Mohammad Javad Amiri, Yuepeng Wang,andBoonThauLoo
the setofupdatetriggers ùëá(ùëü)are definedas:
ùëá(ùëü)‚âîÔ£±Ô£¥Ô£¥ Ô£≤
Ô£¥Ô£¥Ô£≥/uniontext.1
ùëô‚ààùêµ(ùëü){ùêºùëõùë†ùëíùëüùë°(ùëô),ùê∑ùëíùëôùëíùë°ùëí(ùëô)}ùëüisView
{ùêºùëõùë†ùëíùëüùë°(ùëí)} ùëüisTx rule(1)
Ifùëüisaviewrule,thenitcanbetriggeredbyupdatesofanyrelation
initsbody.Otherwise, ùëüisa transactionrule triggeredonlywhen
receivingatransactionrequest.
Algorithm 1 UpdateFunction (ùëü,ùë°). Given a rule ùëü, and a trigger ùë°,
returns an updateobject.
(1) Initialize the setofgroundedvariables ùê∫‚âîùë°.ùë£ùëéùëüùëñùëéùëèùëôùëíùë† .
(2) Literalsotherthanthe trigger ùêø‚âî{ùëü.ùëèùëúùëëùë¶\ùë°}.
(3) Updateprocedure ùëÜ‚âîUpdate(ùëü.‚Ñéùëíùëéùëë,ùêø,ùë°,ùê∫ ).
(4) Return (ont doS)
For each rule ùëü, and for each update triggers in ùëá(ùëü), an abstract
update function is generated by UpdateFunction (r,t), presented
in algorithm 1. It first initializes the set of grounded variables by
variablesinthetriggerliteral.Groundedvariablesarevariablesthat
are constrained to a constant value. Variables in a trigger literal
are considered grounded because the update function is always
triggered by the insertion or deletion of a concrete tuple. In step(3),
update procedure ùëÜis generated by a sub-routine Update, which
ispresentedinalgorithm 2.Finally,itreturnstheabstractupdate
functionintheformof( on t do S),whereùë°istheupdatetriggerand
ùëÜisthe updateprocedure.
Algorithm 2 Update(‚Ñé,ùêø,ùë°,ùê∫). Given a rule head ‚Ñé, a list of body
literalsùêø, anupdate trigger ùë°, andthesetof groundedvariables ùê∫,
return statements that perform the incrementalupdate.
matchùêø:
caseùëÅùëñùëô=>matcht
caseInsert => returnInsert(h)
caseDelete => returnDelete(h)
case‚Ñéùëíùëéùëë::ùë°ùëéùëñùëô=>
Add groundedvariables ùê∫‚Ä≤‚âîùê∫‚à™{ùë•|ùë•‚àà‚Ñéùëíùëéùëë}
Innerstatements ùëÜ‚âîUpdate(h,tail,t,G‚Äô)
matchhead:
caseùëÖ(¬Øùëã)=>
Derive constraints ùê∂‚âîConstraint (ùëÖ(¬Øùëã),ùê∫)
return(SearchRwhere C do S)
caseùê∂(¬Øùëã)=>return(If C Then S)
caseùë¶=ùêπ(¬Øùëã)=>return(ùë¶=ùêπ(¬Øùëã)::ùëÜ)
caseùë¶=ùê¥ùëîùëîùë•:ùëÖ(¬Øùëã)=>
return(ùë¶=ùê¥ùëîùëîùë•:ùëÖ(¬Øùëã)::ùëÜ)
Asshownin Algorithm 2,Update(h,L,t,G)performsrecursion
onùêø, the list of literals in the rule body, with every recursion
translating one literal to a layer of code block, nested within the
code blockgeneratedbythe previous literals.
Inparticular,itperformspatternmatchingoninput ùêø,alistof
literalstobetranslated.If ùêøisempty,whichmeansallbodyliterals
havebeentranslated,anupdatestatementthatisconsistentwiththe
updatetriggerisreturned.Otherwise, ùêøhastheform ‚Ñéùëíùëéùëë::ùë°ùëéùëñùëô.Itfirstaddsallvariablesin ‚Ñéùëíùëéùëëintothesetofgroundedvariables,and
then generates the inner code blocks ùëÜby recursively calling itself
onùë°ùëéùëñùëôandtheupdatedsetofgroundedvariables ùê∫‚Ä≤.Depending
on the form of ‚Ñéùëíùëéùëë, the current layer of code block is generated
in different ways. By the syntax of the language in Section 3,‚Ñéùëíùëéùëë
could take one ofthe following forms:
‚Ä¢A relational literal ùëÖ(¬Øùëã). Given the set of grounded variables ùê∫,
the searchconstraintsfor rowsin ùëÖisgeneratedas follows.
ùê∂ùëúùëõùë†ùë°ùëüùëéùëñùëõùë°ùë† (ùëÖ(¬Øùëã),ùê∫)‚âî/logicalanddisplay.1
{(ùëÖ[ùëñ]==ùë£)|ùë£‚ààùê∫,ùë£‚àà¬Øùëã,
ùëñ=¬Øùëã.indexOf(ùë£)}
whereùëÖ[ùëñ]==ùë£means filtering rows in table ùëÖwhoseùëñ-th
column equals to ùë£.
‚Ä¢A condition literal ùê∂(¬Øùëã), in which case, the condition is directly
used in the same way as an Ifcondition, with the inner code
blockùëÜplacedwithin the Ifstatement.
‚Ä¢A function or aggregation. In either case, the literal is directly
translatedintoanassignmentstatement,followedbytheinner
code blockùëÜ.
Aggregations. The evaluation results of aggregation functions are
maintained incrementally. Sums are incremented by ùëõwhen a row
with aggregate value ùëõis inserted, and decremented by ùëõwhen
a row is deleted. Similarly, counts are incremented by 1on row
insertionanddecrementedby 1onrowdeletion.Maximumsand
minimums are slightly different. When a new row is inserted with
valueùëõ, ifùëõis greater than the current maximum, the maximum is
updatedtoùëõ.Whenthecurrentmaximumrowisdeleted,themaxi-
mum is updated as the second maximum value. Thus, it requires
maintaining a sorted list of values. Minimum is maintained in a
similar fashion.
4.2 Concrete Data StructuresandInstructions
Given the abstract functions generated from each rule, the next
stepistogenerateconcreteandefficientdatastructuresandsearch
algorithms inthe Soliditylanguage.
Datastructures. Eachrelationaltable R,exceptsingletonrelations,
is translated into a mapping from its primary keys to a structure
that stores the restofthe column values:
struct RTuple {
boolvalid;
T1 field1;
T2 field2;
...
};
mapping (k1 => k2 => ... => kn => RTuple) R;
Bydefault,hash-mapsinSoliditymapallkeystozero.Therefore,
avalid bit ( valid)is introducedto indicate theexistence of atuple.
Columns other than primary keys are the structure members. If all
columns are primary keys, its structure only contains avalid bit.
Singletonrelationsaredirectlystoredinastructurewithcolumns
being the structure members.
Join index. Join index is built for each search statement in the
abstractupdate program. Given a searchstatement Search R where
C do Sintheabstractupdateprogram,ifallprimarykeysof Rare
constrained to constant values, no join index is generated. The
matching entry can be directlylookedupbyprimary keys.
286Declarative SmartContracts ESEC/FSE ‚Äô22, November14≈õ18, 2022,Singapore, Singapore
On the other hand, if, in some rules, not all primary keys of R
are constrained to constant values, a join index is built as a map
from the constrainedkeys to alistofunconstrainedkeys.
Suppose relation R1(k1,k2,v1) has primary keys k1andk2. As de-
scribed above, table R1is stored as a map from primary keys to
remaining values ( mapping(k1=>k2=>R1Tuple) ). Given a search state-
mentSearch R1 where R1[0]==k1 do S ,whereonlyoneprimarykey k1
isconstrained,the joinindex for R1isbuiltas the following.
struct R1KeyTuple {
boolvalid;
T2 k2;
}
mapping (k1 => R1KeyTuple[]) R1Index;
whereR1Indexmapsk1to a list of R1KeyTuple , which stores the
value of the other primary key k2. During the join execution, to
iterateallrowsin R1thatsatisfy R1[0] == k1 ,itfirstlooksupall k2
inR1KeyTuple[k1] ,andthen for each k2,getthe valuein R1[k1][k2] .
Update dependent views. An insert or delete statement in the
abstractupdatefunctionistranslatedintotwosetsofSolidityin-
structions.Thefirstsetupdatesthecorrespondingdatastructure,
and the second set calls the update functions for the dependent
relations (Definition 3.1).
Insertingarelationaltuple ùë°1directlyupdatesthemap,aswell
asthejoinindexifoneexists.Ifatuple ùë°0withthesameprimary
keysexists,alldependentviewsareupdatedbyfirstcallingdeletion
updatesonùë°0,andthentheinsertionupdateson ùë°1.Insertionupdate
referstofunctionstriggeredbytupleinsertion,anddeletionupdate
referstofunctionstriggeredbytupledeletion.Otherwise,insertion
updates are directly called. Since a Solidity mapping maps all keys
to valuezerobydefault,atuple existsif its valid bit issetto true.
Deleting a relational tuple resets its valid bit to false. Then dele-
tionupdatesare calledfor alldependent relations.
In this way, when a new transaction is committed, all depen-
dentviewsareupdatedthroughthischainofupdatepropagation.
Sincethereisnorecursion,i.e.,dependencyloopbetweenrelations,
allowedin DeCon, update propagation isguaranteedtoterminate.
Logging. CommittedtransactionsareloggedasSolidityEvents[ 12],
amoregasefficientstoragethanglobalmemory,butcanonlybe
read offline. These events constitute all states of a DeCon contract,
whichenableofflineanalysisforfurtherinsightsandpotentialbugs.
4.3 Run-Time Verification
Properties are specified as declarative rules that derive violation
instances. Such relations are annotated with the keyword violation.
As introduced in Section 2.2, transient violations that occur dur-
ingthetransactionexecutionarenotcounted.Toseewhytransient
violationscanoccur, consideragaintheWalletcontractinSection 2,
andapropertythatrequiresallaccountbalancestoadduptothe
totalsupply.The property can be specifiedas showninListing 2.
.violation unequalTotalSupply
r12: totalBalance(s) :- sumn: balanceOf(_,n).
r13: unequalTotalSupply(n,m):-totalSupply(n),
totalBalance(m),n!=m.
Listing 2:All account balances add upto total supply.During the execution of a minttransaction, the totalSupply and
thetotalBalance areupdatedinsequence,whichleadstoaviolation
whenoneisupdatedbeforeanother,buttheviolationdisappears
when both are updated.
Given this notion of transient violations, instead of aborting the
transaction right after a violation tuple is derived, the checking
procedure is deferred to the end of transaction. If any violation
view is non-empty, the transaction is aborted. Note that a Solidity
mapping does not record its domain. Hence, a separate array of
mappingkeysaremaintainedanditeratedforvalidviolationtuples.
4.4 ProvenanceGeneration
To debug a violation, programmers can use data provenance to
visualizethederivationprocessofaviolationtuple.Asshownin
Figure1, provenance is a directed graph with two kinds of vertices:
tuples and rules. Edges from a tuple vertex to a rule vertex denote
tuplereads,andedgesfromarulevertextoatuplevertexdenote
tuple derivations.
To generate this provenance graph during the rule evaluation
procedure,twokindsofadditionalrecordsarelogged:tupleread
Read(tuple, rid) andtuplederivation Write(rid,tuple) ,where ridis
a uniqueidentifierfor eachrule.The Read(tuple,rid) is interpreted
as an edge from tupleto the rule indexed by rid, and, conversely,
Write(rid,tuple) isan edge from rule ridtotuple.
Note that in Solidity, a failed transaction reverts all instructions,
includinglogging.Whenatransactionisrevertedduetoaproperty
violation,theprovenancelogswouldalsobereverted.Therefore,
to generate provenance for a violation tuple, the transaction needs
to be executed in a local debugging environment instead of the
deploymentblockchain.Thispracticealsosavesstoragespaceon
the publicblockchain.
4.5 Optimizations
Toimprovegasandstorageefficiency,twooptimizationshavebeen
appliedto the generatedcodes.
Join order. Body literals in a rule are sorted by their iteration cost
in an increasing order. First are reserved relations and singleton
relations, since they need no iteration. Second are the relations
whoseprimarykeyshaveallappearedinproceedingliterals.These
literalscanbesearchedviaadirectmappinglook-up,thusrequiring
no iterations either. Next are the rest of the relations, which are
translatedintoloops.Finally come condition andfunction literals.
Storage space. Storage space on a blockchain is precious due to
the high synchronization cost. Deriving relations on-demand, that
is,delayingevaluatinganinferenceruleuntilitisused,cansave
storagespace,butmayincurperformanceoverhead. Toachieve a
balancedtrade-offbetweentimeandspace,DeCononlyproactively
derivesandstoresrelationsannotatedaspublicviewsorviolations,
as well as relations that are read during their derivation. Other
relationsarederivedon-demand.Forexample,intheWalletcon-
tract in Section 2, relation mintonly serves as an update trigger for
dependentrules,whichisneverqueriedduringtheupdateofpublic
viewsorviolations.Therefore,whena minttupleisgeneratedby r1,
it only triggers the update for dependent rules, but it is not written
to the persistent storage.
287ESEC/FSE ‚Äô22, November14≈õ18, 2022,Singapore, Singapore HaoxianChen, GeraldWhitters,Mohammad Javad Amiri, Yuepeng Wang,andBoonThauLoo
5 CASE STUDIES
This section demonstrates the expressiveness of DeCon and the
explainabilityofdataprovenanceviacasestudiesontwopopular
smart contracts: ERC20 and ERC721. For the sake of brevity, only a
subsetofrulesisdiscussed.Allcontracts are available online[ 4].
5.1 ERC20
ERC20[29]isatokenstandardforfungibletokens.Similartothe
Wallet contract in Section 2, it also supports token transfers be-
tween users. In addition, it has an allowance mechanism, where
users can allow other users to transfer their tokens, up to a certain
amountcalled allowance.Theallowancemechanismcanbespecified
as follows.
r1: transferFrom(sender,receiver,spender,n) :-
recv transferFrom(sender, receiver, n),
/* Sender has enough balance. */
balanceOf(sender,m), m>=n,
/* Operator has enough allowance. */
msgSender(spender),
allowance(sender,spender,l),l>=n.
Onreceivinga transferFrom transaction,inadditiontochecking
that the senderhas enough balance ( m>=n), the rule also requires the
spendertohaveenoughallowancetospendtokenson sender‚Äôsbehalf
(l>=n).Therelation transferFrom representstransactionswherethe
spendersendsntokens from the senderto thereceiver.
The allowance of a spenderon an account is specified as follows.
r2: spentTotal(o,s,m) :- transferFrom(o,_,s,_),
m =sumn: transferFrom(o,_,s,n).
r3: allowance(o,s,n) :- allowanceTotal(o,s,m),
spentTotal(o,s,l), n := m-l.
Therelation spentTotal accountstheamountoftokens mthatspender
shas spent on behalf of the sender o. Andallowanceis derived by
subtracting the total spending from the total allowance, an amount
approvedbythe sender(definedinanotherrule).
Given the definition of allowance and the spentTotal , we can spec-
ifyaproperty that aspendernever overspends as the following:
.violation overSpent
overSpent(o,s,n,m) :- allowanceTotal(o,s,n),
spentTotal(o,s,m), m>n.
DeCon then generates instrumentation to monitor this property at
run-time.
Explain allowance changes via data provenance. Suppose the
programmer madeamistakeinspecifying spentTotal :
r2': spentTotal(r,s,m):-transferFrom(_,r,s,_),
m =sumn: transferFrom(_,r,s,n).
The error in r2'is that the transferFrom table is grouped by the
receiver ( r) and spender ( s) column, instead of the sender ( o) and
spender ( s) column (as in r2).
When a spender account swants to transfer 20tokens from
account atoaccount b,bysubmittingatransaction transferFrom(a,b,
s,20), it is reverted. DeCon explains that it is because the condition
l >= ninr1is false, which means the spender sdoes not have suffi-
cientallowance to transfer tokens on a‚Äôsbehalf.
To understand why the spenderonly has 10allowance to a‚Äôs ac-
count,onecouldgettheprovenanceofthetuple allowance(a,s,10) ,allowance(a,s,10)
r3
allowanceTotal(a,s,100)
spentTotal(a,s,90)
r2'
transferFrom(b,a,s,90)
(a)allowance(a,s,10)transferFrom(a,s,r,tokenId)
r4
ownerOf(tokenId,a)
approved(tokenId,a)
r5'
approve(b,s,tokenId)
(b) transferFrom(a,s,r,tokenId)
Figure 4:Provenance tree fortuples.
asshowninFigure 4a.Ontopoftheprovenancetree, allowance(a,
s,10)isderivedby r3,fromthefactthatthetotalallowanceis 100
(allowanceTotal(a,s,100) ), andthat ahasspent 90already( spentTotal
(a,s,90)). To see why spentTotal(a,s,90) is derived, the programmer
continuesexpanding itsprovenancetree.Abug isrevealed atthis
step, where a transaction from address btoais accounted for s‚Äôs
allowance onaddress a,whichpointsto the bugin r2'.
5.2 ERC721
ERC721[ 28]isasmartcontractstandardfornon-fungibletokens
(NFTs). A main transaction for ERC721 tokens is transfer, which
recordsthetransferofatokenfrom sendertorecipientataparticular
time.Thetransactiontimeisincludedtospecifythefollowingviews.
Firstistheviewfunction ownerOf.Giventhe transferrelation,the
ownerofatoken isdefinedas follows.
latestTransfer(tokenId,s,r,t):-transfer(tokenId,s,r ,t),
t =maxi: transfer(tokenId,_,_,i).
ownerOf(tokenId, p):-latestTransfer(tokenId,_,p,_),p !=0.
Thefirstruleselectsthelatesttransferrecordfor tokenId,andthe
next rule specifies that if the recipient of the latest transfer is non-
zero,itisthe ownerofthe token.
Nextisthe existrelation.Atokenexistsifitismintedandisnot
burnt.InERC721contracts,burningatokenemitsatransferrecord
from its ownerto zeroaddress. Hence, existisdefinedas follows.
exists(tokenId, true) :-
latestTransfer(tokenId,_,to,_), to!=0.
Therulechecksthatatoken‚Äôslatesttransferrecipientisanon-zero
address, whichmeans itisnot burnt.
Toensureeveryexistingtokenhasanowner,wecouldspecify
the following property.
.violation tokenNoOwner
tokenNoOwner(tokenId) :-
ownerOf(tokenId,0),exists(tokenId,true).
This rule defines a property violation as an entry in the ownerOf
table,where owneraddress is 0andtokenIdexists.
Explainanunexpectedtokentransferviadataprovenance.
Supposetheownerwantstounderstandwhyoneofhertokenshas
beentransferredawayinatransaction transferFrom(a,s,r,tokenId) ,
288Declarative SmartContracts ESEC/FSE ‚Äô22, November14≈õ18, 2022,Singapore, Singapore
whereais the operator, sis the sender, and ris the receiver, she
expandstheprovenancetreeforthetransaction,whichisshownin
Figure4b.Ontopoftheprovenancetreeisa transferFrom tranaction,
approvedbythe following rule:
r4: transferFrom(operator, sender, receiver, tokenId) :-
recv transferFrom(operator, sender, receiver,
tokenId),
/* Sender owns the token. */
ownerOf(tokenId, sender),
/* Operator is approved to move the token. */
msgSender(operator), approved(tokenId,operator).
whereapproved(tokenId,operator) means that the token tokenIdhas
been approved to use by operator. This approval is set by the token
owner. Suspicious about the approved(tokenId,a) tuple, the owner
continuestoexpandtheprovenancetree,andfindsthatitisderived
from the following rule.
r5': approved(tokenId,operator) :-
approve(_,operator,tokenId).
and the tuple approve(b,s,tokenId) , which means account b, a previ-
ousowner,hasapprovedthistokentooperator sbeforetransferring
thistokento a.Here,shefinds thebug; r5doesnotcheckthatthe
address that approves the token should be the token owner. The
ruleshould have been updatedas followsinstead.
r5: approved(tokenId,operator):-ownerOf(tokenId,owner) ,
approve(owner,operator,tokenId).
6 EVALUATION
We implement a prototype compiler [ 5] for DeCon in Scala that
generates Solidity programs with instrumentation for run-time
verification.Wefirstevaluatethecompilerbycomparingitsoutput,
withoutinstrumentation,withreferencecontractwritteninSolidity.
Next,weevaluatetheoverheadofrun-timeverificationonthese
contracts andtheirproperties.
6.1 Overhead to Reference Implementations
Reference smart contracts. We collectfive reference smart con-
tractimplementationsfrompublic repositoriesand priorresearch.
Walletis the example shown inSection 2. CrowdSale is from prior
research paper [ 52]. SimpleAuction is from Solidity documenta-
tion[9].ERC20(fungibletokens)andERC721(non-fungibletokens)
aretwoofthemostpopularsmartcontractsdeployedonEthereum
1,andweusetheimplementationfromtheOpenZepplinlibrary[ 6].
Declarative smart contract implementation. We implement
declarative counter-parts for all reference contracts with the same
interfacesandfunctionalitieswithoutinstrumentationforrun-time
verificationorprovenance.Thesecontractsconsistof10to18rules
(column#RulesinTable1).
Although DeCon can specify all the high-level logic of the these
contracts,wenotethatthegeneratedSoliditycodehasthefollowing
difference from the reference implementations. First, the reference
CrowdSalecontractisimplementedastwoseparatecontracts.As
DeCon does not yet support contract composition, the compiler
1Accordingto https://etherscan.io ,atthetimeofwritingthispaper,thereareabout
502,000 ERC20tokens and 50,000 ERC721 tokens onEthereum.outputs a stand-alone smart contract with all the functionalities.
FortheERC721contract,thereisa safeTransferFrom interface,which
wrapsthe transferFrom functionwithacheck:iftherecipientisalso
asmartcontract,itshouldimplementthe onERC721Received interface.
ThecurrentimplementationofDeCondoesnotyetsupportsuch
checkingprocedure,whichreliesoncallingthebuilt-infunctions
ofSolidity,sothis interfaceisomitted.
Measurementmetrics. Wemeasuretwometrics:(1)thesizeof
EVMbyte-codedeployedontheblockchain;and(2)thegascostfor
eachtransaction.EVMbyte-codeisgeneratedbytheTruffle[ 13]
compiler.Tomeasuregascost,wefirstdeploythesmartcontract
on Truffle‚Äôs local blockchain, and then populate the smart contract
states by sending transactions from ùëÅtest accounts, which results
inùëÅentriesinthecontractstates.Thenwecalleachtransaction
interfaceagainandrecordgascostreportedbyTruffle.Wefindthat
ùëÅ(10to1000)doesnotimpactgascost.Thisisbecauseallcontracts
use hash-maps to store contract states. If the hash-collision rate
is low, the number of instructions is constant to the size of the
hash-map,andthusthegascostremainsconstant.Therefore,we
report the gas costmeasuredwith ùëÅ=10.
Results.AsshowninTable 1,themediangasoverheadtoreference
implementation is 14%across 16 transactions, with 3 of them have
evenlowergascostbetween ‚àí28%to‚àí12%.Intheextremecase,the
withdrawtransaction from SimpleAuction shows 101%gas overhead.
Weidentifytwosourcesofextragascost:(1)longfunctioninvo-
cation chain, and (2) inefficient use of data structures. For example,
in the Wallet example (Section 2), mint transaction updates the
variable totalMint, which further updates totalSupply , thus adding
extra cost than directly incrementing totalSupply as done by the
reference implementation. For data structures, relational tables are
directly maintained as arrays of tuples, with extra information like
valid bits and timestamps. Such extra information takes up addi-
tional space than their counterparts in Solidity implementations.
MitigatingsuchoverheadborrowingideasinSQLexecutionplan
optimizationwould be an interestingdirection forfuture research.
DeCon consumes less gas in some transactions. In Wallet, the
DeConcontracthaslessread/writetotheglobalmemory.InCrow-
funding, the reference contract invokesan external call toanother
contract,whereasDeConimplementseverythinginonemonolithic
contract, thus eliminating the inter-contract transaction cost. In
ERC721,DeConhasfewerconditionchecksbecausesomecondi-
tions are specified as rules and therefore automatically maintained
bythe contract.
Intermsofbyte-codesize,DeCon‚Äôscompileroutputisslightly
greaterthan thereference programs, with a 2 KB (SimpleAuction)
maximum increase. Note that on CrowSale, DeCon‚Äôs output is
smallerthanthereferencecontract.Thisisbecausethereference
implementstwoseparatecontracts,whiletheprogramgenerated
by DeConcompiler has all functions implemented inone contract.
Contractfeaturesthatarenotyetsupported. Duringthesearch
ofbenchmarks,wefindsomecontractsusefeaturesthatarenotyet
supported by DeCon. For example, the votingcontract from Solid-
itydocumentation[ 14]checksvotingloopinarecursivemanner.
Although recursion can be naturally expressed in DeCon language,
the execution of recursion functions requires non-trivial reasoning
289ESEC/FSE ‚Äô22, November14≈õ18, 2022,Singapore, Singapore HaoxianChen, GeraldWhitters,Mohammad Javad Amiri, Yuepeng Wang,andBoonThauLoo
Table1:OverheadofSolidityprogramsgeneratedbyDeCon,comparedtoreferenceimplementations.Column #ùëÖùë¢ùëôùëíùë†shows
thenumberofrulesinthedeclarative smart contracts.
Contract LOC #Functions #RulesByte-code size (KB)TransactionGas cost(K)
Reference DeCon Reference Compiled Diff
Wallet 57 6 12 3 3mint 36 62 70%
burn 36 47 29%
transfer 52 38 -26%
Crowdsale 70 5 11 4 3invest 38 33 -12%
close 38 47 25%
withdraw 26 29 14%
claimRefund 29 33 13%
SimpleAuction 139 3 13 2 4bid 69 115 66%
withdraw 24 47 101%
auctionEnd 54 56 4%
ERC721 447 9 13 10 11transferFrom 59 42 -28%
approve 49 75 53%
setApprovalForAll 27 27 2%
ERC20 383 6 18 5 6transfer 52 55 6%
approve 47 50 7%
transferFrom 43 50 15%
median: 14%
Table 2: Run-time verification overhead. Column ùëÜùëñùëßùëíand
ùê∫ùëéùë†show the overhead in byte-code size (KB) and gas cost
(K) respectively, compared to the DeCon contract without
instrumentation.
Contract Property Size Transaction Gas
WalletNonegative
balance2mint 14%
burn 14%
transfer 17%
CrowdsaleNomissing
funds2invest 50%
close 24%
withdraw 22%
claimRefund 33%
Simple
AuctionRefund once 2bid 2%
withdraw 60%
auctionEnd 4%
ERC721Every token
has owner1transferFrom 5%
approve 3%
setApprovalForAll 8%
ERC20Account
balancesaddup
to totalsupply1transfer 96%
approve 13%
transferFrom 109%
median: 16%
toensureterminationandgasefficiency,andisthereforenotyet
supported by DeCon. In addition, certain functions that lie outside
ofrelationallogic,includingcheckinginterfacesofanothercontract
(e.g.safeTransferFrom in ERC721), and cryptographic functions[ 8],
arenotyetsupported,buttheycanbeincorporatedintoDeConvia
user-definedfunctionsinthe future.6.2 Run-Time Verification Overhead
Wemeasurerun-timeverificationoverheadbyfirstspecifyingprop-
erties for each contract, which are generated as instrumentation
intheoutputSolidityprogram.Theseinstrumentedprogramsare
then comparedto DeConprograms without instrumentation,on
byte-code size andgas usage.
Contractpropertiesarespecifiedasfollows.First,asshowninthe
example in Section 2, the Wallet contract is monitored for negative
account balances. The Crowdsale contract allows participants to
invest in a crowd funding project with a particular funding target.
The property specifies that the total amount of raised fund should
equal to all participants‚Äô investments. In SimpleAuction, bidders
transfer their fund on every bid, and get refunds when the auction
isended.Apropertyspecifiesthateverybiddercanclaimrefund
at most once. In ERC721, the property specifies that all existing
tokens should have a valid owner (non-zero address). In ERC20, all
account balancesshould add upto the total supply of tokens.
Results. Table2showstheoverheadofrun-timeverification.Byte-
codesizesareincreasedbynomorethan2KB.Gasusageoverhead
varies across different transactions, with the median being 16%.
Wallet and ERC721 contracts show small overhead, where trans-
action gas consumption increases by no more than 17% and 8%,
respectively. Crowdsale and SimpleAuction contract come with
largeroverhead.Thehighestincreaseintheirtransactiongasusage
are 50% and 60%. The ERC20 contract incurs the highest overhead,
where the transferFrom transaction shows109% increase.
7 RELATED WORK
In this section, we survey several lines of research that are related
to our work.
Run-time verification. Similar to DeCon, Solythesis [ 44] also
specifies properties as invariants and generates instrumentation
290Declarative SmartContracts ESEC/FSE ‚Äô22, November14≈õ18, 2022,Singapore, Singapore
forrun-timemonitoring.Itappliestogeneralsmartcontractsim-
plementedinSolidity,whereasDeContargetsdeclarativecontracts
only.Byrestrictingthescopeondeclarativecontracts,bothspec-
ification and monitoring can be performedina more straightfor-
ward manner. Invariants become violation queries, where joins are
analogous to existential quantifiers, and aggregations to universal
quantifiers. Detection becomes query evaluation, which reuses the
same procedure for contract execution.
SODA [27] is a framework forimplementing generic attackde-
tection algorithms. Unlike DeCon where the monitoring procedure
isautomaticallygeneratedfromspecification,thedetectionalgo-
rithmsinSODA are implementedmanually.
Sereum[54]monitorsreentrancyattacksonlineviataintanalysis.
Azzopardi et al. [ 20] monitors contract execution against legal
contract logic. These two worktargets specific vulnerabilities and
propertiesonSoliditysmartcontracts,whereasDeConmonitors
user-specifiedpropertiesondeclarative contracts.
Static analysis and verification. Static analysis has been applied
todetectgenericvulnerabilitiessuchasreentrancyattacks[ 33,45],
integerbugs[ 60,62],tracevulnerability[ 49],andevent-ordering
bugs [42]. Securify [ 63] translates the EVM byte-code into strati-
fied Datalog, andchecks vulnerability patterns using off-the-shelf
Datalogsolvers.
Alt et al. [ 18] translate Solidity program into SMT formulas and
useoff-the-shelfSMTsolvertoverifycontractproperties.Zeus[ 41]
leverages abstract interpretations and symbolic model checking to
verifycorrectness andfairnessofsmart contracts.
Symbolic execution [ 16,17,26,43,46,48,52,63] is another pop-
ular techniqueforsmartcontract verification.Oyente[ 46]detects
generic predefined vulnerabilities including reentrancy, transac-
tionorderdependency,mishandledexceptions,etc.Verx[ 52],on
the other hand, allows programmers to specify contract-specific
propertiesintemporal logic.
Fuzzinghasalsobeenappliedtosmartcontracts.Forexample,
ContractFuzzer[ 38]testssmartcontractsforsecurityvulnerabili-
ties. Echidna [ 31] generates tests that triggers assertion violations.
ILF[36]andHarvey [ 65]focusonimprovingcode coverage.
Unlike these work, DeCon monitors properties online, which
incurs run-timeoverhead,butdoesnot suffer fromfalse-positives
or false-negatives. In addition, DeCon targets declarative smart
contracts, while these tools analyze Solidity or EVM byte-code.
Although targeting different languages, the underlying verification
techniquescanalsobeappliedtoDeConandbenefitfromitshigher-
level abstraction. We believe this is an exciting direction for future
research.
Domain-specific languages for financial contracts. Scilla [57]
is a intermediate-level language for smart contracts that offers
type safety and support for verification. KEVM [ 37] defines the
formal semantics of EVM, and has been used to verify contracts
against ERC20 standards. These languages provides precise formal
specificationofsmartcontractdowntothebyte-codelevel,andare
good for verifying low-level properties. In contrast, DeCon focuses
onthehighlevelabstractionofsmartcontractsandspecification
of contract-specific properties. Jones et al. [ 39] uses functional
programminglanguage to writefinancialcontracts.BitML [ 21] isa
high-levellanguageforBitcoinsmartcontracts.Basedonprocesscalculus, it translates contracts into Bitcoin transactions. DeCon,
ontheotherhand,isbasedonrelationallogicandtargetsEthereum
smart contracts.
Datalog languages. DeCon shares similar syntax with general
Datalog languages like Souffle [ 40], and is inspired by incremental
evaluationtechniquesinsystemslikeDDlog[ 55].DeCon,however,
is specific to Ethereum smart contracts in the following aspects.
First, DeCon has a number of domain-specific language extensions
necessary for capturing execution semantics in Smart Contracts
(Section3).Second,DeConcompiles DatalogtoSolidity,withsev-
eral domain-specific optimizations (Section 4.5). Finally, DeCon
offers a property specification and run-time monitoring feature
(Section4.3),whichisessentialsincesmartcontractsaremanaging
alot ofdigital assets.
Deontic logic for normative knowledge. Gabbay et al. [ 30]
present a historical overview of deontic logic for normative knowl-
edge. Based on similar principles, Prakken et al. [ 53] overview
logic-based approaches for legal applications. DeCon is a logical
systemrepresentingknowledgeinthedomainofsmartcontracts,
whichenables efficient communicationandautomaticreasoning.
8 CONCLUSION AND FUTUREWORK
We present DeCon, a declarative programming language for smart
contract implementation and property specification. In DeCon,
smartcontractsarespecifiedinahigh-levelandexecutablemanner,
thus providing opportunities for efficient analysis and verification,
bringing clarity to transaction execution via data provenance. Con-
tractsimplementedinDeCondemonstratecomparableefficiency
toopen-sourcereferenceimplementation.Furthermore,run-time
verification adds moderategas overhead.
OurinitialexperiencewithDeConsuggestsafewexcitingfuture
directions. First, we find interesting contracts that require addi-
tionallanguagefeatures,includingcontractcomposition,recursion,
user-defined functions, etc. Second, there are extreme cases where
DeCon compiler generates contracts with non-negligible overhead
to the reference hand-written code. DeCon compiler needs further
optimizationtogeneratemoreefficientexecutablecode.Third,to
save the overhead of run-time verification, we can leverage the
high-level abstraction of DeCon programs to perform static verifi-
cation.
9 DATA-AVAILABILITYSTATEMENT
The software and scripts for reproducing the experiment results
are available online[ 3].
ACKNOWLEDGEMENTS
WethanktheanonymousreviewersofFSE‚Äô22fortheirinsightful
feedback and suggestions. This work is supported by NSF CNS-
2104882, NSF CNS-2107147, NSERC Discovery Grant, and Office of
NavalResearchgrantonSecurityforresourcelimitednetworked
Cyber-physical systems.
291ESEC/FSE ‚Äô22, November14≈õ18, 2022,Singapore, Singapore HaoxianChen, GeraldWhitters,Mohammad Javad Amiri, Yuepeng Wang,andBoonThauLoo
REFERENCES
[1]2016. The DAO. https://etherscan.io/address/
0xbb9bc244d798123fde783fcc1c72d3bb8c189413 .
[2]2016. King of the Ether Throne √ê Post-Mortem Investigation. https://www.
kingoftheether.com/postmortem.html .
[3]2022. Artifacts for reproducing experiment results. https://doi.org/10.5281/
zenodo.7080252
[4]2022. Declarative smart contract benchmarks. https://github.com/HaoxianChen/
declarative-smart-contracts/tree/master/benchmarks .
[5]2022. Declarative smart contracts. https://github.com/HaoxianChen/declarative-
smart-contracts .
[6]2022. Openzeppelin contracts. https://github.com/OpenZeppelin/openzeppelin-
contracts/tree/master/contracts/token .
[7]2022. Recursions in Solidity. https://docs.soliditylang.org/en/v0.8.13/control-
structures.html?highlight=recursion .
[8]2022. Saferemotepurchase. https://docs.soliditylang.org/en/v0.5.3/solidity-by-
example.html#safe-remote-purchase .
[9]2022. Simpleauction. https://docs.soliditylang.org/en/v0.5.3/solidity-by-example.
html#simple-open-auction .
[10]2022. SMTCheckerandFormalVerification. https://docs.soliditylang.org/en/v0.8.
12/smtchecker.html#assert .
[11] 2022. Solidity. https://docs.soliditylang.org .
[12]2022. Solidity events. https://docs.soliditylang.org/en/v0.8.13/abi-spec.html?
highlight=events#events .
[13] 2022. Truffle. https://trufflesuite.com .
[14]2022. Voting. https://docs.soliditylang.org/en/v0.5.3/solidity-by-example.html#
voting.
[15]Serge Abiteboul, Richard Hull, and Victor Vianu. 1994. Foundations of Databases:
The Logical Level (1sted.). Pearson.
[16]ElviraAlbert, Jes√∫sCorreas,PabloGordillo,GuillermoRom√°n-D√≠ez,andAlbert
Rubio. 2019. SAFEVM: a safety verifier for Ethereum smart contracts. In Int.
SymposiumonSoftwareTestingand Analysis(ISSTA) . ACM SIGSOFT, 386≈õ389.
[17]ElviraAlbert,PabloGordillo,BenjaminLivshits,AlbertRubio,andIlyaSergey.
2018. Ethir:Aframeworkforhigh-levelanalysisofethereumbytecode.In Int.
symposiumonautomatedtechnologyforverificationandanalysis(ATVA) .Springer,
513≈õ520.
[18]LeonardoAltandChristianReitwiessner.2018. SMT-basedverificationofsolidity
smart contracts. In Int. Symposium on Leveraging Applications of Formal Methods .
Springer, 376≈õ388.
[19]Asaph Azaria, Ariel Ekblaw, Thiago Vieira, and Andrew Lippman. 2016. Medrec:
Using blockchain for medical data access and permission management. In Int.
Conf.onOpenand Big Data (OBD) . IEEE,25≈õ30.
[20]ShaunAzzopardi,GordonJPace,andFernandoSchapachnik.2018. Onobserving
contracts: deontic contracts meet smart contracts. In Legal Knowledge and
InformationSystems . IOS Press,21≈õ30.
[21]MassimoBartolettiandRobertoZunino.2018. BitML:acalculusforBitcoinsmart
contracts. In CCS. 83≈õ100.
[22]Aaron Bembenek, Michael Greenberg, and Stephen Chong. 2020. Formulog:
Datalog for smt-based static analysis. Object-Oriented Programming Systems,
Languages, and Applications(OOPSLA) 4 (2020), 1≈õ31.
[23]AlexBiryukov,DmitryKhovratovich,andSergeiTikhomirov.2017.Findel:Secure
derivativecontractsforEthereum.In Int.Conf.onFinancialCryptographyand
DataSecurity(FC) . Springer, 453≈õ467.
[24]Ryan Browne. 2017. ‚ÄôAccidental‚Äô bug may have frozen $ 280 million worth of
digital coin ether in a cryptocurrency wallet. https://www.cnbc.com/2017/11/08/
accidental-bug-may-have-frozen-280-worth-of-ether-on-parity-wallet.html .
[25] Peter Buneman, Sanjeev Khanna, and Tan Wang-Chiew. 2001. Why and where:
A characterization of data provenance. In International conference on database
theory. Springer.
[26]Jialiang Chang, Bo Gao, Hao Xiao, Jun Sun, Yan Cai, and Zijiang Yang. 2019.
sCompile: Critical path identification and analysis for smart contracts. In Int.
Conf.onFormal Engineering Methods . Springer, 286≈õ304.
[27]TingChen,RongCao,TingLi,XiapuLuo,GuofeiGu,YufeiZhang,ZhouLiao,
Hang Zhu, Gang Chen, Zheyuan He, et al .2020. SODA: A Generic Online
DetectionFrameworkfor SmartContracts..In NDSS.
[28]WilliamEntriken,DieterShirley,JacobEvans,andNastassiaSachs.2022. EIP-721:
Non-FungibleTokenStandard. https://eips.ethereum.org/EIPS/eip-721 .
[29]VitalikButerinFabianVogelsteller.2022. EIP-20:TokenStandard. https://eips.
ethereum.org/EIPS/eip-20 .
[30]DovGabbay,JeffHorty,XavierParent, RonvanderMeyden, andLeonvander
Torre. 2013. Handbook of deonticlogic and normativesystems. (2013).
[31]Gustavo Grieco, Will Song, Artur Cygan, Josselin Feist, and Alex Groce. 2020.
Echidna:effective,usable,andfastfuzzingforsmartcontracts.In Int.Symposium
onSoftwareTestingand Analysis(ISSTA) . ACM SIGSOFT, 557≈õ560.
[32]Ilya Grishchenko, Matteo Maffei, and Clara Schneidewind. 2018. Foundations
and tools for the static analysis of ethereum smart contracts. In Int. Conf. on
Computer AidedVerification (CAV) . Springer, 51≈õ78.[33]Shelly Grossman, Ittai Abraham, Guy Golan-Gueta, Yan Michalevsky, Noam
Rinetzky, Mooly Sagiv, and Yoni Zohar. 2017. Online detection of effectively call-
back free objectswith applications tosmartcontracts. Programming Languages
(POPL)2 (2017), 1≈õ28.
[34]Ashish Gupta, Inderpal Singh Mumick, and Venkatramanan Siva Subrahmanian.
1993. Maintaining views incrementally. ACM SIGMOD Record 22, 2 (1993),
157≈õ166.
[35]AdamHahn,RajveerSingh,Chen-ChingLiu,andSijieChen.2017.Smartcontract-
based campus demonstration of decentralized transactive energy auctions. In
Power&energysocietyinnovativesmartgridtechnologiesConf.(ISGT) .IEEE,1≈õ5.
[36]JingxuanHe,MislavBalunoviƒá,NodarAmbroladze,PetarTsankov,andMartin
Vechev. 2019. Learning to fuzz from symbolic execution with application to
smart contracts. In Conf. on Computer and Communications Security (CCS) . ACM
SIGSAC, 531≈õ548.
[37]EverettHildenbrandt,ManasviSaxena, NishantRodrigues, XiaoranZhu, Philip
Daian,DwightGuth,BrandonMoore,DaejunPark,YiZhang,AndreiStefanescu,
and Grigore Rosu. 2018. KEVM: A Complete Formal Semantics of the Ethereum
Virtual Machine. In Computer Security Foundations Symp. (CSF) . 204≈õ217. https:
//doi.org/10.1109/CSF.2018.00022
[38]BoJiang,YeLiu,andWKChan.2018. Contractfuzzer:Fuzzingsmartcontracts
forvulnerabilitydetection.In Int.Conf.onAutomatedSoftwareEngineering(ASE) .
IEEE/ACM,259≈õ269.
[39]SL Peyton Jones and Jean-Marc Eber. 2003. How to write a financial contract.
(2003).
[40]Herbert Jordan, Bernhard Scholz, and Pavle Subotiƒá. 2016. Souffl√©: On synthesis
of program analyzers. In International Conference on Computer Aided Verification .
Springer, 422≈õ430.
[41]Sukrit Kalra, Seep Goel, Mohan Dhawan, and Subodh Sharma. 2018. Zeus:
analyzing safetyof smartcontracts..In Network andDistributed SystemSecurity
Symposium(NDSS) . 1≈õ12.
[42]AashishKolluri,IvicaNikolic,IlyaSergey, AquinasHobor, andPrateekSaxena.
2019. Exploiting the laws of order in smart contracts. In Int. symposium on
softwaretestingand analysis (ISSTA) . ACM SIGSOFT, 363≈õ373.
[43]Johannes Kruppand Christian Rossow. 2018. {teEther}: Gnawingat Ethereum
toAutomaticallyExploitSmartContracts.In SecuritySymposium .USENIX,1317≈õ
1333.
[44]AoLi,JeminAndrewChoi,andFanLong.2020. Securingsmartcontractwith
runtime validation. In ACM SIGPLAN Conference on Programming Language
Designand Implementation .
[45]ChaoLiu,HanLiu,ZhaoCao,ZhongChen,BangdaoChen,andBillRoscoe.2018.
Reguard: finding reentrancy bugs in smart contracts. In Int. Conf. on Software
Engineering: Companion (ICSE-Companion) . IEEE,65≈õ68.
[46]Loi Luu, Duc-Hiep Chu, Hrishi Olickel, Prateek Saxena, and Aquinas Hobor.
2016. Making smart contracts smarter. In Conf. on computer and communications
security(CCS) . ACM SIGSAC, 254≈õ269.
[47]Patrick McCorry, Siamak F Shahandashti, and Feng Hao. 2017. A smart contract
for boardroom voting with maximum voter privacy. In Int. Conf. on financial
cryptographyand datasecurity(FC) . Springer, 357≈õ375.
[48]Mark Mossberg, Felipe Manzano, Eric Hennenfent, Alex Groce, Gustavo Grieco,
Josselin Feist, Trent Brunson, and Artem Dinaburg. 2019. Manticore: A user-
friendlysymbolicexecutionframeworkforbinariesandsmartcontracts.In Int.
Conf.onAutomatedSoftwareEngineering (ASE) . IEEE/ACM,1186≈õ1189.
[49]IvicaNikoliƒá,AashishKolluri,IlyaSergey, PrateekSaxena,and AquinasHobor.
2018. Findingthegreedy,prodigal,andsuicidalcontractsatscale.In computer
securityapplications Conf. 653≈õ663.
[50]Benedikt Notheisen, Magnus G√∂dde, and Christof Weinhardt. 2017. Trading
stocks on blocks-engineering decentralized markets. In Int. Conf. on Design
ScienceResearch inInformationSystemand Technology . Springer, 474≈õ478.
[51]ZhiniangPeng.2018. NotAFairGame≈õFairnessAnalysisofDice2win. https:
//blogs.360.net/post/Fairness_Analysis_of_Dice2win_EN.html .
[52]Anton Permenev, Dimitar Dimitrov, Petar Tsankov, Dana Drachsler-Cohen, and
Martin Vechev. 2020. Verx: Safety verification of smart contracts. In symposium
onsecurityand privacy(S&P) . IEEE,1661≈õ1677.
[53]Henry Prakken and Giovanni Sartor. 2015. Law and logic: A review from an
argumentationperspective. Artificial intelligence 227(2015), 214≈õ245.
[54] Michael Rodler, Wenting Li, Ghassan O Karame, and Lucas Davi. 2019. Sereum:
ProtectingExistingSmartContractsAgainstRe-EntrancyAttacks.In Network
and DistributedSystemsSecurity(NDSS) .
[55]Leonid Ryzhyk and Mihai Budiu. 2019. Differential Datalog. Datalog2 (2019),
4≈õ5.
[56]Clara Schneidewind, Ilya Grishchenko, Markus Scherer, and Matteo Maffei. 2020.
ethor: Practical and provablysound static analysis of ethereumsmartcontracts.
InConf.onComputer and Communications Security(CCS) . ACM,621≈õ640.
[57]IlyaSergey,VaivaswathaNagaraj,JacobJohannsen,AmritKumar,AntonTrunov,
andKenChanGuanHao.2019. SafersmartcontractprogrammingwithScilla.
Proceedingsofthe ACMonProgrammingLanguages 3,OOPSLA (2019), 1≈õ30.
[58]DavidSiegel.2016. UnderstandingTheDAOAttack. https://www.coindesk.com/
learn/2016/06/25/understanding-the-dao-attack/ . (2016).
292Declarative SmartContracts ESEC/FSE ‚Äô22, November14≈õ18, 2022,Singapore, Singapore
[59]Yannis Smaragdakis and Martin Bravenboer. 2010. Using Datalog for fast and
easyprogramanalysis.In InternationalDatalog2.0Workshop .Springer,245≈õ251.
[60]SunbeomSo,MyunghoLee,JisuPark,HeejoLee,andHakjooOh.2020. VeriSmart:
A highly precisesafety verifier forEthereum smart contracts. In Symposium on
Securityand Privacy (S&P) . IEEE,1678≈õ1694.
[61]Parity Technologies. 2017. Parity Security Alert. https://www.parity.io/blog/
security-alert-2/ . (2017).
[62]Christof Ferreira Torres, Julian Sch√ºtte, and Radu State. 2018. Osiris: Hunt-
ingforintegerbugsinethereumsmartcontracts.In AnnualComputerSecurity
ApplicationsConf. 664≈õ676.[63]PetarTsankov,AndreiDan,DanaDrachsler-Cohen,ArthurGervais,FlorianBuen-
zli,andMartinVechev.2018. Securify:Practicalsecurityanalysisofsmartcon-
tracts. In Conf. on Computer andCommunications Security(CCS) . ACM SIGSAC,
67≈õ82.
[64]JohnWhaley,DzintarsAvots,MichaelCarbin,andMonicaSLam.2005. Using
Datalogwithbinarydecisiondiagramsforprogramanalysis.In AsianSymposium
onProgrammingLanguages and Systems . Springer, 97≈õ118.
[65]Valentin W√ºstholz and Maria Christakis. 2020. Harvey: A greybox fuzzer for
smart contracts. In Joint Meeting on European Software Engineering Conf. and
SymposiumontheFoundationsofSoftwareEngineering(ESE/SFSE) .ACM,1398≈õ
1409.
293