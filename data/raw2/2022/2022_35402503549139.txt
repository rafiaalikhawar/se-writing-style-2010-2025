InputInvariants
DominicSteinhÃ¶fel
CISPA Helmholtz Center forInformationSecurity
SaarbrÃ¼cken, Germany
dominic.steinhoefel@cispa.deAndreasZeller
CISPA Helmholtz Center forInformationSecurity
SaarbrÃ¼cken, Germany
zeller@cispa.de
ABSTRACT
Howcanwegeneratevalidsysteminputs?Grammar-basedfuzzers
are highly efficient in producing syntactically valid system inputs.
However, programs will often reject inputs that are semantically
invalid.We introduceISLa,a declarativespecificationlanguagefor
context-sensitive properties of structured system inputs based on
context-free grammars. With ISLa, it is possible to specify input
constraints like Å‚a variable has to be defined before it is used,Å¾ Å‚the
â€˜filenameâ€™blockmustbe100byteslong,Å¾orÅ‚thenumberofcolumns
in allCSVrows mustbe identical.Å¾
Such constraints go into the ISLa fuzzer,which leverages the
power of solvers like Z3 to solve semantic constraints and, on top,
handles quantifiers and predicates over grammar structure. We
show that afew ISLaconstraints suffice toproduce100% semanti-
callyvalidinputswhilestillmaintaininginputdiversity.ISLacan
alsoparseandprecisely validateinputsagainstsemanticconstraints.
ISLaconstraintscanbe minedfromexistinginputsamples.For
this, our ISLearn prototype uses a catalog of common patterns,
instantiatestheseoverinputelements,andretainsthosecandidates
thatholdfortheinputsobservedandwhoseinstantiationsarefully
acceptedbyinput-processing programs.The resultingconstraints
can then againbe usedfor fuzzingandparsing.
CCSCONCEPTS
â€¢Softwareanditsengineering â†’Softwaretestinganddebug-
ging;Specificationlanguages ;Constraintandlogiclanguages ;
Syntax;Semantics ;Parsers;Softwarereverseengineering ;Documen-
tation;â€¢Theory of computation â†’Grammars and context-
free languages ;Formalisms .
KEYWORDS
fuzzing,specification language,grammars,constraintmining
ACM Reference Format:
DominicSteinhÃ¶fel andAndreasZeller.2022.Input Invariants.In Proceed-
ingsofthe30thACMJointEuropeanSoftwareEngineeringConferenceand
Symposium onthe FoundationsofSoftware Engineering (ESEC/FSEâ€™22),No-
vember14Å›18,2022,Singapore,Singapore. ACM,NewYork,NY,USA, 12pages.
https://doi.org/10.1145/3540250.3549139
ESEC/FSE â€™22, November 14Å›18,2022, Singapore, Singapore
Â©2022 Copyright heldby theowner/author(s).
ACM ISBN 978-1-4503-9413-0/22/11.
https://doi.org/10.1145/3540250.35491391 INTRODUCTION
Automatedsoftwaretestingwithrandominputs( fuzzing)[20]effec-
tively finds bugs in programs. Pure random inputs can quickly dis-
cover errors in input processing. Yet, if a program expects complex
structured inputs (e.g., C programs, JSON expressions, or binary
formats),the chancesof randomlyproducing validinputs thatare
acceptedbythe parserandreach deeperfunctionalityare low.
Language-based fuzzers [9,13,14] overcome this limitation by
generating inputs from a specification of a programâ€™s expected
inputlanguage,frequentlyexpressedasa Context-FreeGrammar
(CFG).Thisconsiderablyincreasesthechanceofproducinganinput
passingtheprogramâ€™sparsingstageandreachingitscorelogic.Yet,
whilebeinggreatfor parsing,CFGsareoftentoocoarsefor producing
inputs. Consider, e.g., the language of XML documents (without
document type). In XML, the identifiers of opening and closing
tags have to match each other, as in Å‚ <name>text</name> .Å¾ Such
matchingcannotbeexpressedinaCFG.EventhoughaCFGcan
be used for parsing (cf. Fig. 1), using it as a producer for fuzzing
willtypicallyyieldnon-matchinginputslikeÅ‚ <O L="cmV">B7</P> .Å¾
Such invalid inputs are still useful for testing the parser, but hardly
everreach functionalitybeyondinputrejection.
To allow for precise production, we can switch to a different
formalism . However, existing solutions all have their drawbacks.
Usinggeneral purpose code to produce inputs or enriching gram-
mars with such code is closely tied to an implementation language,
anddoes notallow for parsingandrecombining inputs,whichisa
commonfeatureof modernfuzzers. Unrestricted grammars canin
principlespecifyany computable inputproperty, but we see them
asÅ‚Turingtar-pits,Å¾inwhichÅ‚everythingispossible,butnothing
of interest is easyÅ¾ [ 23]Ãjust try, for instance, to express that some
numberis the sum oftwoinputelements.
In this paper, we bring forward a different solution by introduc-
ing a(programming andtarget) language-independent ,declarative
specification language named ISLa(InputSpecification Language)
forexpressing semanticconstraintsoverCFGs .Byenrichingexisting
grammars with constraints, we leverage the simplicity of CFGs,
while significantly extending their expressiveness. ISLa is designed
as ageneral-purpose formalism to specify the format even of highly
complex program inputs. It can be used to producesuch inputs
automatically, making ISLa a highly effective fuzzer that can pass
all validation steps ; and it can be used to parseinputs and validate
constraints, makingISLaan effective validator of inputs.
To formalize an input format in and for ISLa, one starts with
the definitionofaCFG. If agrammaris not alreadyavailable, itis
possibletoextractitfrominputs[ 18]andprograms[ 10].Then,one
iteratively strengthens the definition by adding more and more ISLa
constraints until the represented language is a sufficiently close
approximation of the target languageÃan invariant over all inputs.
Thiswork islicensedunderaCreativeCommonsAttribution4.0Interna-
tional License.
583
ESEC/FSE â€™22, November14Å›18, 2022,Singapore, Singapore Dominic SteinhÃ¶fel andAndreas Zeller
âŸ¨xml-treeâŸ©/ColonequalâŸ¨xml-openclose-tagâŸ©
| âŸ¨xml-open-tagâŸ© âŸ¨inner-xml-treeâŸ© âŸ¨xml-close-tagâŸ©
âŸ¨inner-xml-treeâŸ©/ColonequalâŸ¨TEXTâŸ© | âŸ¨xml-treeâŸ©
| âŸ¨inner-xml-treeâŸ© âŸ¨inner-xml-treeâŸ©
âŸ¨xml-open-tagâŸ©/Colonequalâ€˜<â€™âŸ¨idâŸ©â€˜>â€™|â€˜<â€™âŸ¨idâŸ©â€˜â£â€™âŸ¨xml-attributeâŸ©â€˜>â€™
âŸ¨xml-close-tagâŸ©/Colonequalâ€˜</â€™âŸ¨idâŸ©â€˜>â€™
âŸ¨xml-openclose-tagâŸ©/Colonequalâ€˜<â€™âŸ¨idâŸ©â€˜/>â€™|â€˜<â€™âŸ¨idâŸ©â€˜â£â€™âŸ¨xml-attributeâŸ©â€˜/>â€™
âŸ¨xml-attributeâŸ©/ColonequalâŸ¨idâŸ©â€˜="â€™âŸ¨TEXTâŸ©â€˜"â€™
| âŸ¨xml-attributeâŸ©â€˜â£â€™âŸ¨xml-attributeâŸ©
âŸ¨idâŸ©/ColonequalâŸ¨id-no-prefixâŸ© | âŸ¨id-with-prefixâŸ©
âŸ¨id-no-prefixâŸ©/ColonequalâŸ¨ID-START-CHARâŸ© âŸ¨ID-CHARâŸ©âˆ—
âŸ¨id-with-prefixâŸ©/ColonequalâŸ¨id-no-prefixâŸ©â€˜:â€™âŸ¨id-no-prefixâŸ©
Figure1:Acontext-free grammarforXML.Lexerrules(for
thecapitalized nonterminals) are omitted.
<xml-tree> .<xml-open-tag> .<id>=<xml-tree> .<xml-close-tag> .<id>
Listing 1:ISLa constraintforwell-balanced XML.
forall<xml-tree> tree="<{ <id>opid}[<xml-attribute> ]><inner-xml-
â†©â†’tree></{<id>clid}>" instart:
(= opid clid)
Listing 2:Core-ISLa constraintforwell-balanced XML.
TogetanideaofISLaconstraints,considerListing 1,referring
to the grammar in Fig. 1. The constraint expresses that the âŸ¨idâŸ©s
of opening and closing tagsÃin allXML trees that are not self-
closingÃare equal. Programmers write such constraints in the sim-
plifiedlayer of the ISLa language. Our solver translates it to the
Å‚Core-ISLaÅ¾constraintinListing 2.TheCore-ISLaversion explicitly
quantifies over allâŸ¨xml-treeâŸ©elements, binds its constituents to
variables using patternmatching and expressesthe equalityusing
theSMT-LIB formula [1] Å‚(= opid clid) .Å¾ This is typical for an
ISLa constraint: It first identifies derivation tree elements, and then
posesconstraints over these elements. During fuzzing, ISLa then
wouldproduce matching pairsofopening andclosing âŸ¨idâŸ©s.
Theresultingvalidinputscanbeusedas seedinputs formuta-
tionalfuzzerslikeAFL.TheISLasolvercanbeintegratedintothe
fitness function of evolutionary fuzzers, guiding their mutations to-
wardsemanticallyvalidinputs;thesolvercanquicklyrejectinvalid
inputswithouthavingto run actual tests.
Yet, where would ISLa constraints come from? Testers can write
ISLa constraints manually, thus ensuring input validity, and add
additionalconstraintstofurthercontroltheinputsgenerated.How-
ever, they can also mine constraints from existing inputs. To this
end, ourISLearntool uses a catalog of common constraint patterns ,
instantiatestheseoverallinputsandinputelements,andretains
those constraint candidates that hold for all inputs. The catalog
holdspatternstoidentifymatchingelements,lengthrelations,arith-
meticrelations,checksums,andmore.ISLearnissimilarinspiritto
theDaikonfunction-level invariant detector [ 7]. On top, ISLearn
canverifyandrefineconstraint candidatesbyhavingthe program
undertest checkwhether derivedconcrete inputsare valid.
After illustrating ISLa by example (Section 2), this paper makes
the following contributions:Aspecification language forinput constraints. Weproposea
formalism (ISLa) for augmenting existing context-free gram-
mars with context-sensitive constraints. ISLa has a rich declar-
ativelayer,separatingsemanticproperties(constraints)from
syntactic properties (the grammar). We formally define its syn-
taxandsemanticsinSection 3.Tothebestofourknowledge,
ISLaisthe firstformalismtoexpresscontext-sensitiveconstraints
forthegeneration ofsysteminputs.
Semanticfuzzing. We describe an efficient procedure to gener-
ate inputs satisfying ISLa constraints (and their grammars),
and discuss our implementation (Section 4). To the best of our
knowledge, ISLais the first fuzzer(and checker) to make use of
suchconstraints, givingusersunprecedentedmeanstospecify
whichsysteminputsshould be generated.
Mining input constraints. We introduce ISLearn, a system for
automatically mining input constraints in conjunctive normal
form based on a configurable pattern catalog (Section 5). To
thebestofourknowledge,ISLearnisthefirstapproachto infer
suchinvariantsfrom givensysteminputs.
ISLaanditsconstraintsareeffective.Inourevaluation(Section 6),
weformalizesemanticpropertiesfromdiverselanguages,namely
XML, a subset of C, reStructuredText, CSV files, and TAR archives.
Our results demonstrate that already a few lines of ISLa specifi-
cationssufficetogenerate 100%precise inputswhilemaintaining
diversity.Ontop,ourconstraintminer ISLearncan extract precise
invariants about ICMP packets, DOT graphs, and Racket programs.
After discussing related work (Section 7), Section 8closes with
conclusion and future work. Our electronic appendix [ 25] provides
further formalizations,explanations, examples, andproofs.
2 ISLA BY EXAMPLE
Let us illustrate the expressive power of ISLa by detailing our XML
example.WhenrandomlyfeedinganXMLprocessor(e.g.,Pythonâ€™s
xml.etree package)withinputsgeneratedfromtheXMLgrammar
in Fig.1using a grammar fuzzer, we obtain not only one, but three
kindsoferrors:(1)Å‚Mismatchedtag,Å¾(2)Å‚duplicateattribute,Å¾and
(3) Å‚unbound prefix.Å¾ By adding ISLa specifications to the XML
grammar,wecansubstantiallyincreasetheportionofvalidXML
we pass to the processor. Moreover, these specifications document
XMLfeatures relevantto the parser of our test target.
Since ISLa is closed under conjunction, we can incrementally re-
finethespecificationsimplybyaddingindividualinputconstraints
until we are satisfied with the quality of the generated inputs or
the valueofthe specification as adocumentation measure.
FromtheinvalidinputsgeneratedfromtheXMLgrammar,about
52% are invalid due to a mismatched tag, and about 22% because of
an unbound prefix.Letusaddress these.
2.1 MatchingTags
TheISLaconstraintsinListings 1and2addressestheproblemof
mismatched tags by enforcing that the two IDs match. The Core-
ISLa version (Listing 2) uses auniversal quantifier (forall) over
allsubexpressionsoftype âŸ¨xml-treeâŸ©,whichisthespecifiedtype
oftheboundvariable tree.Typesarenonterminalsfromtheref-
erencegrammar(heretheXMLgrammarinFig. 1)orthespecial
typeintfor quantifiers over numbers. The present quantifier uses
584Input Invariants ESEC/FSE â€™22, November14Å›18, 2022,Singapore, Singapore
patternmatching .ISLaonlyconsidersmatchesconformingtothe
pattern (in quotation marks); in the case of a successful match,
not only the quantified variable treebut also the variables opid
andclidin the pattern (in curly braces) are boundto the corre-
spondingpartsofthematchedinputsegment.Matchexpressions
may contain optional elements in square brackets to capture multi-
ple expansion alternatives. The core of the forallformula is an
SMT-LIB S-expression stating that opidandclidare equal. Since
ISLaextendstheSMT-LIBlanguage[ 29],itsupportsallitsstring
constraints.A Core-ISLaconstraint containsexactlyone constant
symbol, which determines the type of described inputs. By default,
this is a symbol startof typeâŸ¨startâŸ©, which can be customized by
adeclarationÅ‚ constname: type; Å¾before the actual constraint.
Simplified ISLa. ISLaâ€™s simplified language layer allows us to
writethisconstraintmuchmoreconcisely.Listing 1isthesimpli-
fiedversionoftheCore-ISLaconstraintinListing 2.Insimplified
ISLa, we can use the more common,mathematical infixsyntax for
binaryexpressions,i.e.,Å‚ x = yÅ¾insteadofÅ‚ (= x y).Å¾Furthermore,
theforallquantifiercanbeomitted.Instead,wedirectlyuseits
typeâŸ¨xml-treeâŸ©intheequation.Thisimplicitlyaddsa forallquan-
tifier over âŸ¨xml-treeâŸ©elements. To access immediate children of
âŸ¨xml-treeâŸ©elements, we use a notation inspired by the XPath ab-
breviatedsyntax[ 3].Forexample, <xml-tree> .<xml-open-tag>
referstothe firstâŸ¨xml-open-tagâŸ©elementamongthechildrenofan
âŸ¨xml-treeâŸ©element inaderivationtree,if any.
InsimplifiedISLa,Å‚ instartÅ¾inquantifiersisadefaultandcan
beomitted.Furthermore,variablenamesinquantifiers,suchas var
in Å‚forall<type>var="...": ... ,Å¾ can be omitted if we are
onlyinterestedinthevariablesboundbythematchpattern.Sim-
plifiedandCore-ISLasyntaxcanbe mixedinthesameconstraint.
In the end, allconstraintsare translated to Core-ISLa .
Since ISLa constraints are closed under conjunction ( and) and
disjunction ( or), it is easy to refine (or relax) constraints. ISLa is
thuswellsuitedfor targetedtesting,or,e.g.,fordescribinga specific
classofinputs thattriggerabuginadebuggingscenario.Thanks
toitsdeclarativenature,itcanalsobeusedforformulatinghuman-
readablespecifications ofthe expectedinputsofasystem.
2.2 BindingPrefixes
Next,wespecifyapropertyavoidingÅ‚unboundprefixÅ¾errors.An
Å‚unbound prefixÅ¾ error is raised when tag or attribute identifiers in
XMLdocumentscontaina namespaceprefix ,suchasns1andns2in
Å‚<ns1:tag ns2:attr=" ..."/>,Å¾whichisnot declaredinthesame
or an outer tag. This is an example of a def-useproperty that is
alsocommoninprogramminglanguages:A usedidentifiermustbe
definedinsomeouterscopeoratsomeprecedingposition.Oneadds
theattributeÅ‚ xmlns:ns1="someâ£text" Å¾todeclarenamespace ns1,
where frequently, the quoted text contains a URL. The property
we aimfor isexpressedmoreprecisely as: Å‚ Forallidentifiers with
a prefixğ‘,there isasurrounding XML tree ğ‘¡such that there is
an attribute xmlns:ğ‘inthe attributes list of ğ‘¡â€™s opening tag.Å¾ We
emphasizedwordscorrespondingtoISLalanguageelements.There
isonesubtlety,though:Wehavetodistinguishprefixesinattribute
and tag identifiers, since the special attribute xmlnsdoesnothave
to be declared,as itisusedprecisely to declare othernamespaces.Again,wecanexpressbothcasesinisolationtoincrementally
refine thespecification.Here, we regardthe slightly more compli-
cated case of prefixes in attribute identifiers. Listing 3shows the
ISLaspecification for this case.
1forall<xml-attribute> attr="{<id-no-prefix> prefix_use}:{ <id-no-
â†©â†’prefix> maybe_def}=\" <text>\"": (
2notprefix_use = "xmlns" implies
3exists<xml-tree> outer_tag=
4"<<id>{<xml-attribute> a_cont}> <inner-xml-tree></<id> >": (
5inside(attr, outer_tag) and
6exists<xml-attribute> =
7 "xmlns:{ <id-no-prefix> prefix_def}=\" <text>\""ina_cont:
8(notprefix_def = "xmlns" andprefix_use = prefix_def)))
Listing 3: ISLa constraint for binding prefixes in attribute
identifiers(referencegrammar:Fig. 1)
The ISLa code closely resembles the natural language specifica-
tionwedescribedpreviously,exceptthatwespecializedittoonly
quantify over attributes (Line1) and generally permit the xmlns
prefix(Line 2)usingan implication :Onlyiftheprefixis notxmlns,
itmustbe explicitly defined.
2.3 Targeted Testing
WithISLaspecifications,wecangobeyondconstraintsforsemantic
validity for application-specific, targeted testing . Imagine an XML
processor that allows associating tags with URLs defined using
dedicated attributes web:baseurl andweb:query for base URLs
andquerystrings.Wecanenforcetheexistenceofatagusingboth
oftheseattributes somewhere inany producedsysteminput:
exists<xml_attribute> attributes: (
exists<xml-attribute> attrinattributes:
attr.<id>= "web:baseurl" and
exists<xml-attribute> attrinattributes:
attr.<id>= "web:query")
The XML processor performs some input validation and rejects
allinputswherethevaluesoftheseattributesexceedalengthof100
characters. We force all generated inputs to respect this constraint
byaddingthe following specification:
forall<xml-attribute> ="web:<id-no-prefix> ={<text>text}":
str.len(text) <= 100
AfterparsinganXMLfile,theprocessorassemblesacomplete
URL by joining the base URL and the query string. However, let
us assume its input validation is buggy: The result is stored in a
character array of length 150, and we thus get a buffer overflow
whenthebaseURLandthequerystring togetherexceedalength
of 150 characters. We can then explicitly generate inputs triggering
this bug by encoding this property as an ISLa constraint. Such
inputs would be valuable for developers or security researchers, as
aregressiontest validating afixfor apotentialexploit:
forall<xml-attribute> attrs:
forall<xml-attribute> attr_1="web:baseurl={ <text>t1}"inattrs:
forall<xml-attribute> attr_2="web:query={ <text>t2}"inattrs:
str.len(t1) + str.len(t2) > 150
2.4 MiningConstraints
Constraints like the ones described above can alsobe minedfrom
existing inputs. To mine constraints such as the XML constraint in
585ESEC/FSE â€™22, November14Å›18, 2022,Singapore, Singapore Dominic SteinhÃ¶fel andAndreas Zeller
Listing2, we create a schematic version of itthat is independentof
thechoiceofaparticulargrammar:
forall<?NONTERMINAL> ="{<?MATCHEXPR(opid, clid)> }": opid = clid
This pattern can be added to the catalog of our ISLearn system,
enablingthesystemtoinfersimilarconstraintsforadifferentgram-
mar. The placeholder <?NONTERMINAL> represents any nontermi-
nal in that grammar; <?MATCHEXPR(opid, clid)> represents any
suitable match expression for an instantiation of <?NONTERMINAL> ,
containingtwononterminaloccurrencesthatareboundtovariables
opidandclid. ISLearn generates candidate instantiations from
suchpatternsandthenfiltersthosethatholdforasetofgivenor
automatically generated sample inputs. Hence, given a set of XML
inputs,ISLearn can easily learn the constraintinListing 2.
Toavoidoverspecializationtowardasmallsetofinputs,ISLearn
can automatically validateconstraint candidatesÃby generating
furtherinputsfromthemandcheckingwhethertheseinputswould
beacceptedbytheprogram.Thisalsoworksin debugging scenarios:
Ifwehaveasetofinputsforwhichaspecificpropertyholds(say,
the length of some input element exceeds some constant), ISLearn
will not only learn that constraint, but can also ensure that further
instantiationsofthe constraintreproduce the failure.
2.5 Summary
With these examples, we have demonstrated how ISLaconstraints
precisely characterize input classes associated to some program be-
havior.Developerscanusethesedescriptionstoobtain semantically
validinputs,describethe conditions of discovered bugs, and for
targetedtriggering ofsuchbugs.Givenexistinginputs,ISLearncan
determine constraintsthat precisely characterize input properties
andprogram behavior.
Note that withoutISLa and ISLearn, implementing any of these
constraintscanbeatiresomeexperience.Whileahandwrittengen-
erator can easily ensure matching XML tags or usage of tags from
a dictionary, proper handling of namespaces is already a challenge
andsolvingarithmeticconstraintsovermultipleelementswillbe
increasingly difficult. Extending such a generator to be compos-
ableandusable as a parser for checking or mutating inputs will
requireaneffortcomparabletoimplementingmostof ISLa,but the
resultingtoolwillnot be nearly as versatile.
3 ISLA SYNTAX AND SEMANTICS
ISLaconstraintsarebuiltfroma signature ofgrammar,predicate,
and variable symbols. We first formally define CFGs, following [ 15,
Chapter 5]; afterward,we introduce ISLasignatures.
Definition3.1(Context-FreeGrammar). AContext-FreeGrammar
(CFG)isatuple ğº=(ğ‘,ğ‘‡,ğ‘ƒ,ğ‘†)of(1)asetof nonterminalsymbols ğ‘,
(2)asetof terminalsymbols ğ‘‡disjointfrom ğ‘,(3)asetof productions
ğ‘ƒmapping nonterminals ğ‘›âˆˆğ‘to an(expansion) alternative . An
alternativeisastringofterminalornonterminalsymbols.Formally,
ğ‘ƒâŠ†ğ‘Ã— (ğ‘âˆªğ‘‡)âˆ—; and(4) adesignated startsymbol ğ‘†âˆˆğ‘.
By convention, we surround nonterminal symbols with angular
brackets (e.g., âŸ¨startâŸ©). Signatures contain a special nonterminal
symbolÅ‚intÅ¾fornumericvariablesrepresentingderivationtrees
whose stringrepresentations correspondto anaturalnumber.Definition 3.2 (ISLa Signature). Asignature is a tuple Î£=
(ğº,PSym,VSym)ofagrammar ğº=(ğ‘,ğ‘‡,ğ‘ƒ,ğ‘†),asetofpredicate
symbolsPSymof strictly positive arity, and a set of typed vari-
able symbols VSym. The type vtype(ğ‘£)ofğ‘£âˆˆVSymis a symbol
ğ‘›âˆˆğ‘âˆª{int},intâˆ‰ğ‘.
WenowdefinethesyntaxofCore-ISLaformulas.Weassumeun-
derspecifiedsets Trmbool(vars)ofBooleanSMT-LIBtermswithfree
variables vars. These sets contain the constants trueandfalse,
and S-expressions (fğ‘1... ğ‘ğ‘›), wherefis anğ‘›-ary function
symbol of Boolsort and the ğ‘ğ‘–are SMT expressions of suitable
sort.Formulas in Trmbool(vars)may contain uninterpretedstring
constants whose names coincide with the names in vars. For the
precise definition of SMT-LIB terms, we refer to the SMT-LIB stan-
dard[1]andtherepositoryofSMT-LIBtheories[ 28].Apartfrom
SMT-LIBexpressions,quantifiers,andBooleancombinators,ISLa
usespredicate formulas with predicate symbols from PSym. While
ourdefinitionofCore-ISLaformulasisparametricin PSym,theISLa
solver comes with a set of predefined predicates such as inside
fromListing 3.ForalistofISLaâ€™sbuilt-inpredicates,werefertoour
electronicappendix [ 25]andthe ISLalanguagespecification [ 24].
Definition3.3(Core-ISLaFormulas). ThesetFmlofISLaformulas
for a signature Î£=(ğº,PSym,VSym), withğº=(ğ‘,ğ‘‡,ğ‘ƒ,ğ‘†), is
inductivelydefinedas:
(1)ğœ‘âˆˆFmlifğœ‘âˆˆTrmbool(VSym).
(2)ğ‘(ğ‘£1,...,ğ‘£ğ‘›) âˆˆFmlfor each predicate symbol ğ‘âˆˆPSym
witharity ğ‘›andğ‘£ğ‘–âˆˆVSym.
(3)(notğœ‘),(ğœ‘andğœ“),(ğœ‘orğœ“)are inFmlforğœ‘,ğœ“âˆˆFml.
(4)foralltypeğ‘¥inğ‘¦:ğœ‘andexiststypeğ‘¥inğ‘¦:ğœ‘areinFml
forğ‘¥,ğ‘¦âˆˆVSym,vtype(ğ‘¥)=typeâˆˆğ‘âˆª{int},andğœ‘âˆˆFml.
(5)foralltypeğ‘¥=Å‚mexpÅ¾inğ‘¦:ğœ‘anditsexistentialcounterpart
existstypeğ‘¥=Å‚mexpÅ¾inğ‘¦:ğœ‘are inFmlifğ‘¥,ğ‘¦âˆˆVSym,
vtype(ğ‘¥)=typeâˆˆğ‘, andğœ‘âˆˆFml, andmexpis a string
consistingofsymbolsin ğ‘âˆªğ‘‡,non-nestedlistsÅ‚ [Â·Â·Â·]Å¾of
such symbols ( optionalsymbols), and variables references
Å‚{ğ‘¡ ğ‘£},Å¾whereğ‘£âˆˆVSymandğ‘¡=vtype(ğ‘£).
We use Å‚ğœ‘implies ğœ“Å¾as ashorthand for Å‚ (notğœ‘)orğœ“.Å¾
ThesetFmlisrelativetoasignature Î£,leftimplicitforsimplicity.
Parentheses can be omitted according to the following precedence
rules:Quantifiersbindstrongerthannegation,whichbindsstronger
thanconjunction, whichbindsstronger thandisjunction.
We only consider (Å‚top-levelÅ¾) ISLa formulas containing exactly
oneunboundvariable, whichis thedefault startconstant, or the
one specifiedinthe optional constdeclaration.
SimplifiedISLa. ThesimplifiedISLalanguagefeaturesaredefined
in terms of a translation to Core-ISLa. We briefly list these features
andsketchhowtheyaremapped;foramoredetaileddiscussion,
we refer to the ISLalanguagespecification [ 24].
Generalized SMT-LIBexpressions. ISLaallowswritingbinary
SMT-LIB expressions in infix syntax Å‚ x op yÅ¾ and all other
expressionsinstandardmathematicalprefixsyntaxÅ‚ f(...).Å¾
They are mappedto SMT-LIB S-expressions.
Omission ofÅ‚ instart.Å¾OmittingtheÅ‚ in...Å¾partinaquanti-
fiedexpressionispermitted.ItdefaultstoÅ‚ instart,Å¾where
startisreplacedbyan explicitly specifiedconstant, if any.
586Input Invariants ESEC/FSE â€™22, November14Å›18, 2022,Singapore, Singapore
ğ‘£1:âŸ¨xml-treeâŸ©
ğ‘£2:âŸ¨xml-open-tagâŸ©
ğ‘£6:â€˜<â€™ğ‘£7:âŸ¨idâŸ©
ğ‘£13:â€˜aâ€™ğ‘£8:â€˜>â€™ğ‘£3:âŸ¨inner-xml-treeâŸ©
ğ‘£5:âŸ¨textâŸ©
ğ‘£9:â€˜xâ€™ğ‘£4:âŸ¨xml-close-tagâŸ©
ğ‘£10:â€˜</â€™ğ‘£11:âŸ¨idâŸ©
ğ‘£14:â€˜aâ€™ğ‘£12:â€˜>â€™
Figure 2:Example XML derivationtree.
Omission ofboundvariable names. Variablenamesinquanti-
fiers,such asÅ‚ varÅ¾inÅ‚forall<type>var: ... ,Å¾areop-
tional. The Core-ISLa translation introduces a fresh variable.
Free nonterminals. Nonterminal types can be used instead of
variables in atomic formulas and Å‚ in...Å¾ expressions. The
mappingtoCore-ISLaaddsanew,top-level forallquanti-
fier binding a fresh variable, and replaces occurrences of the
nonterminalinthe originalformula withthat variable.
Å‚X-PathÅ‚expressions. ThenotationÅ‚ parent.<child>[i]Å¾(child
axis) allows addressing the ğ‘–-thimmediate <child> element
ofparent; Å‚[i]Å¾ is optional and defaults to Å‚ [1].Å¾ The de-
scendant axis expression Å‚ parent.. <child>Å¾ refers to all
<child> elementsinthesubtreeof parent(i.e.,notonlyim-
mediatechildren).Childanddescendantaxisexpressionscan
be chained tolonger expressions. They canbe used instead
of variables in atomic formulas and Å‚ in...Å¾ expressions.
Child axis expressions translate to match expressions; de-
scendant axis expressionsto universal quantifiers.
Semantics. The semantics of an ISLa constraint are all strings
derivablefromthereferencegrammarthatsatisfytheconstraint.
To make thisprecise, we first definederivationtrees. Then, we fix
the meaning of ISLa constraints by defining a validation judgment.
Definition 3.4 (DerivationTree). Aderivation tree fora CFG ğº=
(ğ‘,ğ‘‡,ğ‘ƒ,ğ‘†)is arooted ordered tree such that (1) all vertices ğ‘£are
labeledwith symbols label(ğ‘£) âˆˆğ‘âˆªğ‘‡, where the root is labeled
withğ‘†, (2) ifğ‘£1,...,ğ‘£ğ‘˜are the children of a node labeled with ğ‘›,
thenthereisaproduction (ğ‘›,(ğ‘ 1,...,ğ‘ ğ‘˜)) âˆˆğ‘ƒsuchthatforall ğ‘£ğ‘–,
label(ğ‘£ğ‘–)=ğ‘ ğ‘–. For a derivation tree ğ‘¡, we write leaves(ğ‘¡)for the set
of its leaves, and label(ğ‘¡)for the label of its root. A derivation tree
isclosedifğ‘™âˆˆğ‘‡forallğ‘™âˆˆleaves(ğ‘¡),andopenotherwise. T(ğº)is
the setofall(closedandopen)derivationtrees for ğº.
Example3.5. Fig.2visualizesthederivationtreeoftheXMLdoc-
ument Å‚<a>x</a> Å¾ for the XML grammar in Fig. 1: The treeâ€™s root,
ğ‘£1, is labeled with the grammarâ€™s start symbol âŸ¨xml-treeâŸ©; its edges
conformtothepossiblegrammarderivations.Consider,e.g.,node ğ‘£2
anditsimmediatechildren ğ‘£6,ğ‘£7,andğ‘£8.AccordingtoDefinition 3.4,
there has to be a production (âŸ¨xml-open-tagâŸ©,(â€˜<â€™,âŸ¨idâŸ©,â€˜>â€™))in the
grammar,whichisindeedthecase,since â€˜<â€™âŸ¨idâŸ©â€˜>â€™isanexpansion
alternative (the first one) for the nonterminal âŸ¨xml-open-tagâŸ©. The
leavesleaves(ğ‘¡)are{ğ‘£6,ğ‘£13,ğ‘£8,ğ‘£9,ğ‘£10,ğ‘£14,ğ‘£12}. The tree ğ‘¡isclosed,
since all leaves are labeled with terminalsymbols. It would be open
if we removedthe subtree rootedinany tree node (but the root).We convert a derivation tree to a string (written Å‚ str(ğ‘¡)Å¾) by
concatenating its leaves in order of their occurrence. If ğ‘¡is the tree
from Fig. 2,we have str(ğ‘¡)=Å‚<a>x</a> Å¾.
Match Expressions. For evaluating ISLa formulas, we have to
match quantified formulas with match expressions against deriva-
tiontrees.Tothatend,weuseapartialfunction match(ğ‘¡,mexpr)
from trees ğ‘¡andmatchexpressions mexprto mappingsfrom vari-
ables to subtrees. We say that there is a match ğ‘šforğ‘¡andmexprif
matchreturns a such a mapping. Our implementation parses the
matchexpressionandrecursivelymatches the result against ğ‘¡.
Validation. We define the semantics of Core-ISLa formulas (the
semantics of the simplified ISLa language features follows from
theirtranslationtoCore-ISLa)bya validationjudgment ğœ‹,ğœ,ğ›½|=ğœ‘,
whereğœ‹andğœareinterpretationsofpredicatesymbolsandSMT
expressions, and the variable assignment ğ›½is a substitution of
derivationtreesforvariables.Theintuitionofthisjudgmentisthat
ğœ‘holds (evaluates to true) when instantiating free variables in ğœ‘
according to ğ›½under the interpretations of predicates and SMT
expressionsasprovidedby ğœ‹andğœ.Wewrite ğ›½(ğœ‘)forthesubstitu-
tion of free variables in ğœ‘by their assignments in ğ›½, andğ›½[ğ‘£â†¦â†’ğ‘¡]
for the updated assignment where the variable ğ‘£is now mapped
to the tree ğ‘¡. For a match ğ‘š=match(ğ‘¡,mexpr,), we write ğ›½[ğ‘š]for
ğ›½[ğ‘£1â†¦â†’ğ‘¡1]Â·Â·Â·[ğ‘£ğ‘›â†¦â†’ğ‘¡ğ‘›],whereğ‘£ğ‘–â†¦â†’ğ‘¡ğ‘–areallassignmentsin ğ‘š.
Theprimitivesubstitutionof ğ‘¡forğ‘£isdenotedby {ğ‘£â†¦â†’ğ‘¡}.Byğ›½â†“
we denote the assignment of variables to stringsinstead of trees: If
ğ›½associates ğ‘£withğ‘¡,ğ›½â†“associates ğ‘£withstr(ğ‘¡).
Inthe definitionofthe validationjudgment, âŠ¤andâŠ¥represent
semantic truth and falsity, resp. Note that we expect ğœto always
returnâŠ¤orâŠ¥. Timeouts, not uncommon for SMT solvers, are usu-
ally no problem for closed formulas without free variables. Should
the solver time outanyway,we interpretthis as âŠ¥.
Definition 3.6 (ISLa Validation). LetÎ£=(ğº,PSym,VSym)be a
signature, ğœ‹:PSymâ†’ T(ğº)âˆ—â†’ {âŠ¤,âŠ¥}an interpretation of
predicate symbols, ğœ:Trmbool(âˆ…) â†’ {âŠ¤ ,âŠ¥}an interpretation
of closed SMT S-expressions, and ğ›½a variable assignment. We
inductivelydefinethe judgment ğœ‹,ğœ,ğ›½|=ğœ‘as
(1)ğœ‹,ğœ,ğ›½|=ğœ‘iffğœ‘âˆˆTrmbool(âˆ…)andğœ(ğ›½â†“(ğœ‘))=âŠ¤.
(2)ğœ‹,ğœ,ğ›½|=ğ‘(ğ‘£1,...,ğ‘£ğ‘›)iffğœ‹(ğ‘)(ğ›½(ğ‘£1),...,ğ›½(ğ‘£ğ‘›))=âŠ¤.
(3)ğœ‹,ğœ,ğ›½|=notğœ‘iffnotğœ‹,ğœ,ğ›½|=ğœ‘.
(4)ğœ‹,ğœ,ğ›½|=ğœ‘andğœ“iffğœ‹,ğœ,ğ›½|=ğœ‘andğœ‹,ğœ,ğ›½|=ğœ“.
(5)ğœ‹,ğœ,ğ›½|=ğœ‘orğœ“iffğœ‹,ğœ,ğ›½|=ğœ‘orğœ‹,ğœ,ğ›½|=ğœ“.
(6)ğœ‹,ğœ,ğ›½|=foralltypeğ‘£inğ‘¤:ğœ‘iffğœ‹,ğœ,ğ›½[ğ‘£â†¦â†’ğ‘¡] |=ğœ‘holds
for allsubtrees ğ‘¡inğ›½(ğ‘¤)whose root islabeledwith typeâˆˆğ‘.
(7)ğœ‹,ğœ,ğ›½|=forall int ğ‘›inğœ‘:iffğœ‹,ğœ,ğ›½[ğ‘›â†¦â†’ğ‘¡] |=ğœ‘holds for
alltreesğ‘¡such that str(ğ‘¡)represents anumber in {0,1,2,...}.
(8)ğœ‹,ğœ,ğ›½|=existstypeğ‘£inğ‘¤:ğœ‘iffğœ‹,ğœ,ğ›½[ğ‘£â†¦â†’ğ‘¡] |=ğœ‘holds
forsomesubtree ğ‘¡inğ›½(ğ‘¤)whoserootislabeledwith typeâˆˆğ‘.
(9)ğœ‹,ğœ,ğ›½|=exists int ğ‘›inğœ‘:iffğœ‹,ğœ,ğ›½[ğ‘›â†¦â†’ğ‘¡] |=ğœ‘holds for
sometree ğ‘¡suchthat str(ğ‘¡)representsanumberin {0,1,2,...}.
(10)ğœ‹,ğœ,ğ›½|=foralltypeğ‘£=Å‚mexprÅ¾inğ‘¤:ğœ‘iffğœ‹,ğœ,ğ›½[ğ‘£â†¦â†’
ğ‘¡][ğ‘š] |=ğœ‘holds for all subtrees ğ‘¡with root ğ‘Ÿinğ›½(ğ‘¤)such
thatlabel(ğ‘Ÿ)=typeandthere isamatch ğ‘š=match(ğ‘¡,mexpr).
(11)ğœ‹,ğœ,ğ›½|=existstypeğ‘£=Å‚mexprÅ¾inğ‘¤:ğœ‘iffğœ‹,ğœ,ğ›½[ğ‘£â†¦â†’
ğ‘¡][ğ‘š] |=ğœ‘holds for a subtree ğ‘¡with root ğ‘Ÿinğ›½(ğ‘¤)such that
label(ğ‘Ÿ)=typeandthere isamatch ğ‘š=match(ğ‘¡,mexpr).
587ESEC/FSE â€™22, November14Å›18, 2022,Singapore, Singapore Dominic SteinhÃ¶fel andAndreas Zeller
Figure3:ISLasolverschema.Boldarrowlinesdepictthemain
solverloop.Lightgrayrectanglesaremainconstraint-solving
components; the remaining ones are auxiliary components.
Example 3.7. Consider the constraint for well-balanced XML
trees from Listing 2, and the XML tree ğ‘¡from Fig. 2for the doc-
umentÅ‚<a>x</a> .Å¾Weevaluatewhetherthistreeiswell-formed,
starting from an initial assignment ğ›½={startâ†¦â†’ğ‘¡}. Since the
outermost element of the constraint is a universal formula with
matchexpression,Item (10)ofDefinition 3.6applies.Thus,wehave
to prove that ğœ‹,ğœ,{startâ†¦â†’ğ‘¡}[ğ‘£â†¦â†’ğ‘¡][ğ‘š] |=ğœ‘holds for all in-
stantiations,i.e.,treeelementswithroot âŸ¨xml-treeâŸ©matchingthe
matchexpression(i.e.,notaself-closingtag).Thereisamatch ğ‘šin
ğ‘¡,instantiating opidtoaandclidtoa.Thus,itremainstoshow
thatğœ((= "a" "a") )=âŠ¤,whichisthe case.
Definition3.8 (ISLaSemantics). Letğœ‘âˆˆFmlbean ISLaformula
withthesinglefreevariable ğ‘forthesignature (ğº,PSym,VSym),
andğœ‹,ğœbeinterpretationsforpredicatesandSMTformulas.We
definethe semantics âŸ¦ğœ‘âŸ§ofğœ‘as
âŸ¦ğœ‘âŸ§â‰”{str(ğ‘¡) |ğ‘¡âˆˆ T(ğº) âˆ§closed(ğ‘¡) âˆ§ğœ‹,ğœ,{ğ‘â†¦â†’ğ‘¡} |=ğœ‘}.
4 SOLVING ISLA CONSTRAINTS
Our ISLa solver stepwise expands elements from a queue of Condi-
tionedDerivationTrees(CDTs) .ACDTisapair Î¦âŠ²ğ‘¡,whereÎ¦isa
setof ISLaformulasand ğ‘¡aÃpossiblyopenÃderivationtree. Intu-
itively,theconjunctionoftheformulasin Î¦constrainstheinputs
representedby ğ‘¡,similarlyas âŸ¦ğœ‘âŸ§constrainsthelanguageofthe
grammar.Opentreesrepresentthepossiblyinfinitesetofderiva-
tiontreesthatcanbederivedfromthembyexpansionaccordingto
the grammar rules; imposing constraints potentially reduces the
set ofapplicablerulesandthusthe representedconcretetrees. On
theotherhand, closedderivationtreesonlystandforthemselves.If
aconstraintisaddedtoaclosedtree,theresultiseitherempty(if
thetree doesnot satisfythe constraint)orconsists ofthe treeitself.
To enable references to trees in constraints, we assign unique,
numericidentifiers to derivation tree nodes.These identifiersmay
be used instead of freevariables in ISLa formulas (variables bound
byquantifiers maynot be replacedwithtree identifiers).
Consider,for example,the ISLaconstraint
ğœ‘=forallâŸ¨idâŸ©idinstart:str.len( id) = 3
constraining the XML grammar in Fig. 1to identifiers of length
3.Letğ‘¡beatreeconsistingofasingle(root)nodewithidentifier1, and labeled with âŸ¨startâŸ©. Then,âŸ¦ğœ‘âŸ§is identical to the strings
representedbythe CDT
{forallâŸ¨idâŸ©idin1:str.len( id) = 3)}âŠ²ğ‘¡.
Fig.3schematically represents the ISLa constraint solver. We
formalizedthesolverasaCDT transitionsystem inourelectronic
appendix[ 25].StartingwiththeCDTabove,thesolverexpandsthe
opentree ğ‘¡accordingtothegrammarand addstheresulting CDT
into the queue. The queue itself is a priority queue . The order of
CDTsinsidethequeueisdeterminedbyaconfigurable costfunction .
Expansion continues as long as it gets us nearer to matching
the universalquantifier (in the example, until an âŸ¨idâŸ©nonterminal
symbol is contained in the trees resulting from the expansion).
Eventually,the following state willbe addedto the queue:
{forallâŸ¨idâŸ©idin1:str.len( id) = 3)}âŠ²<âŸ¨idâŸ©/>
Now,theuniversal quantifiermatches andisinstantiated.Let 4
betheidentifierofthesubtreelabeledwiththe âŸ¨idâŸ©nonterminal.
Then, we obtain (using bold font forthe tree identifier in the SMT
formula resultingfrom the instantiation):
{str.len( 4) = 3,
forallâŸ¨idâŸ©idin1:str.len( id) = 3)}âŠ²<âŸ¨idâŸ©/>
The solver now removes the quantified formula from the con-
straint set, since there is no chance of obtaining anotherâŸ¨idâŸ©by
further expansion. Next, it invokes the SMT solver to obtain a solu-
tionfortheformula str.len( 4) = 3.Ifwesimplyaskedthesolver
forastringoflength3,wewouldnotnecessarilyreceiveananswer
matching the language of the âŸ¨idâŸ©nonterminal; for example, the
solver could produce a sequence of three space characters. Thus,
weusetheÅ‚GrammartoregexÅ¾componenttoproducearegularex-
pression describing the desired syntax, which we add to the solver
query. While generally, it is not possible to precisely transform a
CFG into a regular expression, it is often feasible for small sub
grammars, like the one for the âŸ¨idâŸ©nonterminal. Otherwise, we
createanapproximateregularexpressionbyunfoldingproblematic
recursions upto afixedbound.
Thesolutionreturnedbythesolverisparsedintoaderivation
tree and substituted for the subtree with identifier 4; the SMT
formula is removed from the constraint set. This results in a set of
CDTs(thenumberofsolutionsrequestedfromtheSMTsolveris
configurable)withemptyconstraintsetsandclosedtreessuchas
{}âŠ²<abc/>. Since there are no constraints and open tree leaves
left,<abc/>isimmediately outputas asolution of the constraint.
Thesolvernotonlystopstreeexpansionifitcanbesurethatno
universal quantifier can eventually be matched by doing so; it also
onlyexpandsopensubtreesforwhichthisisthecase.Consequently,
there are situations where the constraint set is empty, and the
associated derivation tree still open. In that case, anyexpansion
of the tree is admissible. The solver then calls a standard grammar
fuzzertoclosethetreeusingrandomexpansions(again,thenumber
ofrequestedsolutionsisconfigurable).Thisprocedureensuresthat
the solver does not generate too many solutions that look alike by
considering allpossible grammarexpansions inallcases.
Therearetwomoreconstraintsolvercomponents,whichprovide
solutions for existential quantifiers andsemantic predicates .
588Input Invariants ESEC/FSE â€™22, November14Å›18, 2022,Singapore, Singapore
ExistentialQuantifiers. Existentialquantifiers(e.g.,Å‚thereisan
outer XML tag defining a given namespaceÅ¾) not matching the cur-
rentderivationtreeareeliminatedusingtheÅ‚treeinsertionÅ¾com-
ponent, which searches for opportunities to insert the requested
tree into the existing constrained derivation tree. The inserted tree
containsanodelabeledwiththenonterminaltypeofthevariable
boundbythequantifier,andoptionallycontainssubtreesformatch
expression elements. For the XML namespace example, the compo-
nentwill,e.g., replaceanexisting âŸ¨xml-treeâŸ©subtreewiththetree
to insert, and in turn add the replaced tree as a subtree of the in-
sertedtree .Treeinsertioncancauseviolationsof alreadyeliminated
constraints. Thus, the original constraint is re-inserted afterward.
Ifnoneofthealreadysolvedconstraintswereviolated,theadded
constraintisquicklyeliminatedagain.Alternatively,theaddedCDT
isdiscarded,orfurther insertionsare performed
SemanticPredicates. ISLadistinguishes structural andsemantic
predicates.Structuralpredicates,likeÅ‚ insideÅ¾inListing 3,evalu-
atetotrueorfalse.Semantic predicates,forwhichspecificsolvers
havetobeimplemented,canadditionallyevaluatetoan assignment ,
similarlytoSMTformulas,or Å‚notreadyÅ¾ iftheresultdiffersfordif-
ferent expansions of open argument derivation trees. We use them
to address shortcomings of SMT solvers or the SMT-LIB language.
Classic use cases are checksum predicatesÃencoding checksums
in SMT-LIB is cumbersome at leastÃand structure-aware predi-
cateslikethe countpredicateusedinourCSVcasestudy,which
produces rowswithaspecific number ofcolumns.
QuantifiersoverIntegers. Existential numericquantifiersareelim-
inated by introducing fresh numeric constants. Universal quan-
tifiers are more complicated. If their core restricts the range
of the quantified variable, ISLa enumerates all possible values.
Additionally, the solver implements transformations for formu-
las of a specific structure. For example, formulas of the shape
Å‚forall int i:exists<A>elem:notA(elem, i) Å¾get
exists int i: (
exists<A>elem': phi(elem ', i)and
exists<A>elem:notphi(elem, i))
ifA(elem, i) holds for exactly one iwhenelemis fixed. The
result can be solvedbyfreshconstant introduction.
Conjunctions,Disjunctions,Negations. Thesolverpushesnega-
tionsinsideformulas,splitsconjunctionsintoseveralelementsof
the constraint set of one CDT,and disjunctions into severalCDTs.
Cost Function. The choice of the cost function impacts the
solverâ€™s performance, both in terms of efficiency (generated in-
puts per second) and diversity (input features covered). Our cost
functioncomputestheweightedgeometricmeanofdifferent cost
factors.Weprovideasensibledefaultweightvector.Furthermore,
weights can be manually configured, and we provide an optimizer
using an evolutionary algorithm for choosing good weights. We
currentlyconsiderfivecostfactors:(1) Treeclosingcost. Weapprox-
imatethecosttocloseaderivationtreebythesumoftheestimated
instantiation effort for all leaf nonterminal symbols. (2) Constraint
cost.Thisassignshighercosttoconstraintsthataremoreexpensive
tosolve,notablyexistentialquantifiersthathavetobeeliminated
by tree insertion. (3) Derivation depth. Assigning higher costs toCDTsgeneratedlaterintheprocesscanpreventstarvationofstates
added earlier. (4) k-path coverage. We use the k-path coverage met-
ric[11]todeterminethecontext-sensitiveinputfeaturecoverage
of derivation trees. We penalize trees covering only few k-paths.
The concretevalue of kis configurable; thedefaultis 3. (5) Global
k-path coverage. This factor assigns a higher cost to trees whose kÅ›
pathshavealreadybeencoveredbyexistingtreesinthequeue.The
history of covered paths is reset once all paths have been covered.
5 MININGISLA CONSTRAINTS
TheISLacomponentsintroducedsofarenabledevelopersto manu-
allyspecifyinputconstraintsbasedonananalysisofinputformats,
andusetheconstraintsforinputvalidationandgeneration.With
theseconstraints,developersdonothavetocodedomain-specific
input generators or checkers; furthermore, ISLa constraints can
easily be refined and specialized, e.g., by adding another constraint
for targeted testing. Yet, the full potential of such a declarative
specification language materializes when we automatically mine
inputconstraintsfromsamplesandautomaticexperiments.This
enables us to connect any observable program behavior with con-
straints on system inputs . Example behaviors of interest include
normal completion,reaching somepointincode,orcrashing.
To that end, we developed ISLearn, a miner for input constraints.
ISLearn isinspiredby Daikon[ 7], atool for learningunit-level pro-
gram invariants from dynamic execution traces. Daikon checks for
invariantsfromapredefinedsetof patterns(e.g., valueranges,sort-
edness).ISLearnalsousespatterns.ThemaindifferencestoDaikon
are: (1) ISLearn mines and combines quantified ,structure-aware
formulas;Daikongeneratesinvariantsoverliteralsorsimplecollec-
tions, (2) Daikon requires a meaningful test suiteto obtain feasible
unit-levelexecutiontraces.ISLearncan automaticallygeneratemore
inputssatisfying a program property, and reducethose inputs to
theiressential features , (3) ISLearn also considers negativeinputs
(not satisfyinga property)to estimatethe specificity of invariants,
and(4)ISLearncaneasilybe extendedwithmorepatterns byadding
them to a human-readable configuration file. Manual extensions
may not be required , though: ISLearn comes with a default catalog
populated withgeneral patterns and patterns inspired by our ISLa
casestudies.Alltheseare unique features of ISLearn.
ThemaininputstotheISLearnsystem,apartfroma grammar of
theinputlanguage(possiblyminedbyothertools[ 10,18]),aresets
ofpositiveandnegative sampleinputs ,andaprogramproperty (e.g.,
the program terminates normally). Both are optional: Invariants
can be mined from inputs only, and inputs can be automatically
generatedfrom only the property.
Patterns are defined ina superset of the ISLa language, enriched
withplaceholders fornonterminaltypes (<?NONTERMINAL> ),match
expressions (<?MATCHEXPR(params)> ,whereparamsisalistofvari-
ables that should be bound in the instantiated match expression,
andstring constants (<?STRING> ). The<?DSTRINGS> placeholder
can be instantiated by multiplestrings; the surrounding, atomic
ISLaformula isexpandedfor allinstantiations.
Consider the constraint for prefix bindings in XML attributes
from Listing 3. We abstract this constraint to an ISLearn pattern
byreplacingallnonterminaltypesandmatchexpressionsbycor-
responding placeholders. The constant "xmlns" is abstracted by
589ESEC/FSE â€™22, November14Å›18, 2022,Singapore, Singapore Dominic SteinhÃ¶fel andAndreas Zeller
forall<?NONTERMINAL> attribute="{ <?MATCHEXPR(prefix_use)> }"
instart: ( notprefix_use = <?DSTRINGS> implies
exists<?NONTERMINAL> outer_tag="{ <?MATCHEXPR(cont_attribute)> }"
instart: (inside(attribute, outer_tag) and
exists<?NONTERMINAL> def_attribute=
"{<?MATCHEXPR(prefix_def)> }"incont_attribute:
prefix_use = prefix_def))
Listing 4:ISLearnpattern obtained fromListing 3
a<?DSTRINGS> placeholder to permit instantiations by multiple
keywords.The resultingpattern isshowninListing 4.
Thisisnotthe onlypossibleabstraction. Infact,to recoveran
equivalentinvariantforthe originalXML constraint,weneedto
introduce another variable ns_prefix in the match expression
fordef_attribute for binding the constant xmlns, along the con-
straint Å‚ns_prefix = <?STRING> .Å¾ However, the pattern in List-
ing4is already useful. In our evaluation (Section 6), we applied
ISLearn to languages that did not inform our pattern catalog. One
of our evaluation targets is the Racket language from the Lisp fam-
ily. Since Racket programs are, similarly to XML, tree structures,
the first abstraction of the XML pattern can be instantiated to a
definition-use invariant for Racket. The <?DSTRINGS> placeholder
isinstantiatedbyallfunctionsusedinthelearningsamples,such
as*,+, andsqrt. The constraint prefix_use = <?DSTRINGS> is
expandedto multiple equalities, one for eachusedfunction.
We explain how ISLearn works along the example of the
Graphviz DOT language from our evaluation (Section 6.3). We
aim for the invariant that edges in directed graphs (Å‚ digraphÅ¾) are
directed (Å‚ ->Å¾), and edges in undirected graphs (Å‚ graphÅ¾) are undi-
rected (Å‚--Å¾). ISLearn operates in three phases. The input augmen-
tationphase generatesmoreinputsamplessatisfying(positive)and
violating (negative) the program property using a grammar fuzzer
and a grammar-, property-, and k-path-aware mutation fuzzer . The
obtainedinputsareoptionallyreducedafterward.Then,learning
samplesareselectedfromthepositiveinputs,minimizingtheirsize
whilemaximizingtotalk-pathcoverage.ForDOT,examplelearn-
inginputsareÅ‚ graph { a -- b; } Å¾andÅ‚digraph { a -> b; } .Å¾
An example ofa negativeinputisÅ‚graph { a -> b; } .Å¾
Thecandidate generation phase instantiates selected patterns
fromthecatalogbasedonthegivenlearninginputsinseveralsteps.
For DOT,we can instantiatethe pattern Å‚String Existence:Å¾
exists<?NONTERMINAL> elemin<?NONTERMINAL> :
elem =<?STRING>
Forexample,thefirststepinstantiatesnonterminalplacehold-
ers in quantifiers and match expression placeholder arguments.
Theresultsaftereachinstantiationphaseare approximatelyfiltered
using an ISLa checker for schematicformulas. Thefiltering is con-
servative:Whenever somelearninginput mightsatisfyapartially
instantiatedpattern,thatpatternisretained.Twousefulinstantia-
tionsofÅ‚String ExistenceÅ¾for DOTare
Å‚exists<GRAPH> elemin<graph>: elem = "graph" Å¾and
Å‚exists<edgeop> elemin<edge_stmt> : elem = "->" .Å¾
Finally,the filteringandcombination phase combinescandidate
invariants to conjunctions of disjunctions satisfying configurable
target values for recall and specificity . First, we evaluate for each
candidatewhichofthepositiveandnegativeinputsitsatisfies.From
thetwolearninginputsshownabove,thefirstonesatisfiesthefirst
constraint, and the second one the second constraint. Then, wecombine candidates to disjunctions up to a configurable size, such
thatthepercentageofpositiveinputssatisfyingthecombination
exceeds the recall threshold and the recall estimate is greater than
that of both candidates alone. For example, we would combine
the candidate instantiations above, such that the result satisfies
bothlearning inputs. In the next step, we combine the disjunctions
to conjunctions to maximize the amount of negative inputs not
satisfyingtheresultingcombinations(specificity).Forinstance,the
negativeinputÅ‚ graph { a -> b; } Å¾satisfiesournewlyformed
disjunction.Thus,wecombineittoa conjunctionwithasimilarly
shapeddisjunction,onlywithÅ‚ digraphÅ¾andÅ‚--Å¾insteadofÅ‚ graphÅ¾
andÅ‚->.Å¾Theresulthas100%recallandspecificity.ISLearnranks
invariantsaccording to their recallandspecificityestimates.
Implementation. TheISLasolverandISLearnareimplemented
inPython.1WeusetheZ3SMTsolverandagrammarfuzzerbased
on the Fuzzing Book [ 33] for finishing unconstrained trees. We im-
plementedadditional libraries forgrammar graphoperations(e.g.,
k-paths) andapproximatinggrammars withregularexpressions.
6 EVALUATION
Toevaluate ISLaandISLearn,we pose three research questions:
RQ1TowhichdegreedoISLaconstraintscontributetothe
efficiency andprecision of the input generator? With
this question, we evaluate how much benefitone gets (in
termsofmorevalidinputs)forhowmuch cost(intermsof
havingto specifyISLaconstraints).
RQ2HowdiverseareinputsgeneratedfromISLaconstraints?
Here,wewanttoensurethatISLadoesnot overspecialize (for
instance,byproducing only asmall setof concrete inputs).
RQ3What are the recall and specificity of invariants mined
byISLearn? Weevaluate howusefulthe invariantsmined
byISLearn,andspecificallythedefaultpatterns,aretode-
scribe the circumstancesof normalprogram behavior.
Evaluation Subjects. To evaluate RQ1 and RQ2, we identified
frequentlyoccurringcontext-sensitivelanguageproperties:(1)Dec-
larationofidentifiers( def-use),(2)redefinitionÃidentifiersmustnot
bedeclaredmorethanonce( redef),and(3)lengthorcountingprop-
erties(len-cnt).Forspecificlanguages,weaddressed(4)well-bal-
anced XML expressions (Å‚BalanceÅ¾), (5) correct TAR checksums
(Å‚ChecksumÅ¾),and(6) consecutive listnumbering(Å‚NumberingÅ¾).
To cover these properties, we chose input languages of differ-
entcharacter:(1)Onehighlystructured(XML)andonemorehu-
man-readable(reStructuredText(reST)) markuplanguage ,(2)adata
exchange format (CSV), (3) a programming language (Scriptsize-C),
and(4)a binaryformat (TAR).Scriptsize-CextendsTiny-C[ 8]by
explicitvariabledeclarations.Foreachoftheselanguages,weex-
tractedgrammars fromtheirspecifications;forXML,weextendeda
pre-existing grammar from the Fuzzing Book [ 33] with namespace
prefixes. We then addedISLasemantic constraintsto allof these.
The TAR archive format represents properties of binary inputs;
it comes with strict length constraints (block sizes) and requires
the computation of a checksum. Checksums are generally out of
1ISLaand ISLearnare available at https://github.com/rindPHI/isla andhttps://github.
com/rindPHI/islearn . They also are published in the Python Package Index (PyPI), see
https://pypi.org/project/isla-solver/ andhttps://pypi.org/project/islearn/ .
590Input Invariants ESEC/FSE â€™22, November14Å›18, 2022,Singapore, Singapore
Table 1: Overview of evaluation targets and their properties.
Propertiesinitalicfontarenotcoveredbyourspecifications.
Language TestTarget def-use redeflen-cnt other
Scriptsize-C clang âœ“ âœ“ âœ—Nontermination
Overflow
XML xml.etree âœ“ âœ“ âœ—Balance
TAR tar âœ“ âœ“ âœ“Checksum
reST rst2html âœ“ âœ“ âœ“Numbering
CSV csvlint âœ— âœ— âœ“ âœ—
Racket racket
DOT dot To be mined inSection 6.3
ICMP Echo pythonping
Table 2:ISLa Efficiency,precision,andinput diversity
Constraints LOCEfficiency Precision Diversity Length
Inputs/min Inputs/min(%) %k-paths #Chars
(none) Ã470 113(24) 53 2(1)
+ def-use 6963 136(14) 51 28(28)C
+ no-redef 4387 387(100) 58 26(27)
(none) Ã809 140(17) 66 10(5)
+ balance 2452 95(21) 85 41(35)
+ def-use 11435 60(14) 78 42(44)XML
+ no-redef 5126 126(100) 91 44(48)
(none) Ã572 0(0) 0 0
+ length 4420 0(0) 0 0
+ checksum 318 4(22) 86 3,700(4,096)TAR
+ reference 1419 19(100) 87 4,121(4,096)
(none) Ã258 88(34) 100 13(10)
+ reference 6492 393(80) 100 32(32)
+ length 7404 379(94) 100 33(33)
+ numbering 7547 534(98) 100 32(33)reST
+ no-redef 4404 404(100) 100 31(31)
(none) Ã804 490(61) 100 9(8)CSV+ columns 4127 127(100) 100 1,103(828)
TheÅ‚EfficiencyÅ¾columnconsiders allproducedinputs;Å‚Precision,Å¾Å‚Diversity,Å¾and
Å‚LengthÅ¾only valid(accepted)inputs.Å‚LengthÅ¾isthemean(median)lengthofallvalid
inputs.Weevaluated k-pathcoveragefor both k=3 and k=4.
thescopeofSMT-LIB,whichiswhyweimplementedadedicated
semantic predicate for TAR checksums (15 linesofcode).
For ISLearn, we chose three additional languages to evaluate
how well patterns from our catalog transfer to new application
scenarios.Again,weaimedatchoosingadiverserangeofevaluation
targets:(1)a functionalprogramminglanguage (Racket),(2)a graph
descriptionlanguage (DOT),and(3)a binaryformat (ICMPpackets).
Table1gives an overview of languages, test targets, and proper-
tiesusedinourevaluation.FortheISLearnsubjects,weleavethe
propertiesopen,sincethegoalisto discovertheirinvariants.For
ground truth, we chosetest targets processing eachlanguage.
6.1 RQ1: Precision
ISLaaimstoproducemorevalidinputs,attheeffortofspecifying
input constraints. Since ISLa is closed under conjunction, specifica-
tionscanbeaddeduntilasatisfyingprecisionisreached.Table 2
relatesthelinesofISLacodeforasemanticpropertyandtheresult-
ingprecision.TheÅ‚(none)Å¾rowsstandforÅ‚noconstraintÅ¾added.
Here, we ran the grammar fuzzer ISLa uses to close unconstrained
open derivation trees. For each language, the rows below Å‚(none)Å¾
showtheresultsoftheISLageneratorwhenaddingthespecified
constraint on topof the ones appearing above. The first constraint
istheonewiththemostpositiveeffectonprecision;similarlyfor
theothers.TheÅ‚PrecisionÅ¾columnshowsthenumberof validin-
putsgeneratedperminute,withthepercentageofvalidinputsin
parentheses.Only17%ofgenerated XMLinputsare validwithoutconstraints;140validXMLdocumentsaregeneratedperminute.For
TAR,notasingleinputisvalid.TheÅ‚EfficiencyÅ¾columndisplaysthe
generationspeedirrespectivelyofvalidity.Withtheexceptionof
TAR, we observe that ISLa generates dozens to hundreds of inputs
per minute, including a high number of valid ones.2All values are
obtainedfrom the averageof twoone-hour runs of the generator.
For every constraint added, we provide its length in lines of
Core-ISLacode.For Listing 2(balanceinTable2), the length is2.
Mostly, precision increases with each additional constraint. A
typicalexampleisreST,wherethefirstconstraintalreadyincreases
precisionfrom34%to80%.ForXML,18linesofconstraintsachieve
100% precision. Without constraints, the 17% of valid inputs are al-
mostexclusivelymadeof âŸ¨xml-openclose-tagâŸ©elementsonly.Ofthe
inputs containing an âŸ¨xml-open-tagâŸ©element, only 0.03% are valid.
A few ISLaconstraintssufficeto drasticallyincrease
thepercentageofvalid inputs.
Interestingly, relative precision declineswhen adding the def-
useproperty to XML. This stems from the fact that the solver is
now directed toward introducing more attributes with namespace
prefixes, which introduces more (invalid) attribute repetitions. The
no-redefconstraintincreasesprecisionupto100%.A similarphe-
nomenoncanbeobservedforScriptsize-C.Still,forallsubjects,a
fewconstraintsincreasethe precision to 100%.
ISLaconstraintscanensure that allinputsare valid.
Wewouldliketoemphasizethat100%precisionisnotanecessary
goal.If80%validreSTdocumentsaresufficientfortestingareST
processor,onemaydecidetostopaddingconstraintsafter reference.
The most verbose property is the Å‚lengthÅ¾ property for TAR,
where each field of the archive has to conform to strict length
bounds. Yet, the constraint consists of a conjunction of simple
constraints (most of them two lines only). If we do notprovide
length and checksum constraints, we cannot produce even a single
valid TAR file.
6.2 RQ2: Diversity
A test generator should produce inputs exercising different lan-
guagefeatures, by which onecan expect to reach differentpaths
inthelanguageprocessor[ 11].Essentially,100%precisioncanbe
reached by always producing the same, small input. To validate
that ISLagenerates diverseand thusinteresting inputs, we compute
theiraccumulated k-path coverage [11], assessing how many paths
of length ğ‘˜in the grammar are present in a derivation tree. The
higher the ğ‘˜-path coverage,the higher the diversity.
TheÅ‚DiversityÅ¾columninTable 2showsthepercentageofac-
cumulated 3-and4-paths duringaone-hourrunperall3/4-paths
inthegrammar.Forexample,generatingXMLdocumentsfromthe
grammar only achieves 66% coverage, while we cover 91% of all
3/4-pathswhenaddingallthreeconstraints.Weonlycountvalid
inputsacceptedbythe program undertest.
Generally, inputs produced by ISLa have better diversity than
inputsproducedwithoutconstraints.OnlyforScriptsize-C,there
2There is much potential in optimizing ISLa for speed; e.g., parallel processing of the
solver queue and solving simple formulas such as equations without SMT solver calls.
591ESEC/FSE â€™22, November14Å›18, 2022,Singapore, Singapore Dominic SteinhÃ¶fel andAndreas Zeller
isasmalldecreaseindiversityafteraddingthe firstconstraint;this
iscompensatedafter the additionofthe second.
To shed some light on the solverâ€™s behavior for CSV and
Scriptsize-C,wecollectedinformationaboutinput length.Lengthis
not a particularly good coverage measure: One can always choose,
e.g., long identifiers. However, we observe that, in particular for
CSV and C, most inputs generated by the grammar fuzzer are triv-
ial;themostcommonvalid Cprogramgeneratedbythegrammar
fuzzer is Å‚ ;Å¾. In general, the ISLa solver clearly outperforms the
grammar fuzzer in terms of the complexity of the generated inputs.
ISLacoversthediversityoftheunderlyinggrammar.
6.3 RQ3: ISLearn
WepopulatedthepatterncatalogforISLearnwithabstractionsof
the patterns used for the ISLa evaluation targets. In addition, we
added some simple properties about magic constants, most notably
Å‚String ExistenceÅ¾ from Section 5. In this research question, we
assess how well ISLearn can be used to mine invariants describing
circumstances of normal program behavior (i.e., whether an input
is accepted by the program under test) with these patterns. We
are particularly interested in two questions: (1) If an input is valid
(acceptedbytheprogram),whatistheprobabilitythatthemined
invariant classifies the input as such (i.e., the ISLa solver reports
that the inputsatisfies the invariant)?This is capturedby the recall
of the invariant. (2) Conversely, if an input is invalid, what are the
chancesthattheminedinvariantclassifiesitaccordingly?Thisis
assessedbythe specificity ofthe invariant.
To evaluate recall and specificity, we chose seed sets of training
andvalidation inputs.ForRacketandDOT,weobtainedvalidRacket
and DOT files from GitHub. We separated those inputs into sets
of training and validation inputs of equal size. Subsequently, we
expandedthetrainingandvalidationsetsto50inputseachusing
both a mutation-based and a grammar fuzzer. Similarly, we collect
negative inputs (not accepted by the programs under test) into sets
ofnegativetrainingandvalidationinputs,eachofsize50.ForICMP
Echo, our thirdevaluation target, we generated random, valid echo
requestandreplypacketsusingtheÅ‚pythonpingÅ¾library.Toobtain
negativesamples,wecreatedarbitrary(notnecessarilyEcho)ICMP
packets,20%ofthosewithan incorrectchecksum value.
ISLearn already estimates recall and specificity of invariant can-
didates based on the supplied sample inputs and returns the top-
rankedresult.Weassessedthequalityofthatinvariantusingthe
validation sets.If,e.g.,aninputfromthepositivevalidationsetdoes
notsatisfy the invariant, the inputisa false negative (FN).
Table3presentsthe confusionmatrices forourevaluation.For
DOT,ISLearndiscoveredtheinvariantthatedgesindirectedgraphs
are directed ( ->), and undirected ( --) for undirected graphs. The
invariantisslightlytooweak,asitonlyrequires onecorrectedgein
each Å‚edge statement,Å¾ which, however, can contain multiple (right
orwrong)edges.InthecaseofICMPEchopackets,thesystemlearns
thatthevalueoftheÅ‚typeÅ¾is0(reply)or8(response).Itwrongly
classifies three packets with wrong checksums as valid. Adding
a pattern for a semantic predicate computing internet checksum
achieves 100% specificity. Both of these invariants are obtained
from combined instantiations of the Å‚string existenceÅ¾ pattern. WeTable 3:Confusion matricesforRQ3
(a)DOT
Classifiedas
Input True False Total
TrueTP =50FN =050
False FP =8TN =4250
Total 58 42100
Recall= 100%,Specificity = 84%
Precision = 86%,Accuracy = 92%(b) ICMPEcho
Classifiedas
Input True False Total
TrueTP =50FN =050
False FP =3TN =4750
Total 53 47100
Recall= 100%,Specificity = 94%
Precision = 94%,Accuracy = 97%
(c) Racket (XMLpattern)
Classifiedas
Input True False Total
TrueTP =36FN =1450
False FP =8TN =4250
Total 44 56100
Recall= 72%,Specificity = 84%
Precision = 82%,Accuracy = 78%(d)Racket (XML+ reST pattern)
Classifiedas
Input True False Total
TrueTP =36FN =1450
False FP =5TN =4550
Total 41 59100
Recall= 72%,Specificity = 90%
Precision = 88%,Accuracy = 81%
alreadymentionedthata def-useinvariantforvariablesinRacket
canbeobtainedfromapatternderivedfromanXMLinvariant;this
leadsto72%recalland84%specificity.Onemissingsemanticfeature
isadef-usepropertyfor functions.Wediscoveredthatbyweakening
thedef-usepattern obtained from reST, taking into account pre-
definedfunctionsymbolsthathavenotbeen defined,weobtaina
suitableinvariantforthisproperty.TheconfusionmatrixinTable 3d
demonstrates that this increases specificity to 90%. TheÃcompared
toDOTandICMPÃlowrecallstemsfromthefactthatnotallpre-
definedfunctionsappear inthe training set.
ISLearn minesinvariantsofhighrecall and specificitybased on
patternsforre-occurringinputproperties.
6.4 Threatsto Validity
We supported our claim that ISLais a useful specification language
by expressing context-sensitive properties of five subject input
languages.WhetherindeedISLaissufficientlyexpressiveandits
solversufficientlyprecisedependsonwhetherourchoiceofsubjects
is representative. There is a potential threat of overfitting, i.e., that
we designed ISLa and ISLearn to exactly fit the test subjects. We
mitigate this threat by choosing diverse languages, i.e., not only
programmingormarkuplanguages,orbinaryformats,buta mixture
ofthose.Furthermore,weidentifiedandclusteredcontext-sensitive
propertiesofthetestsubjects.Thissupportstheclaimthatthose
are representative and can be transferred to different targets, as
does the fact that an XMLpattern could be usedfor Racket.
7 RELATED WORK
ParserSpecifications. ISLaprovidesaframeworktospecify input
requirements , or preconditions, of a program. It targets the sys-
tem level, where inputs are generally strings. Parser generators like
ANTLR3and the pioneer yacc [ 16] promoted CFGs for specify-
ingcomplexstructuredinputs.However,specificationsdesigned
forparsinginputs are rarely specific enough to also be used for
producing valid inputs,whichisthe gap that ISLafills.
3https://www.antlr.org/
592Input Invariants ESEC/FSE â€™22, November14Å›18, 2022,Singapore, Singapore
AttributeGrammars. Attributegrammars[ 17]associategram-
mar symbols with synthesized and derived attributes. This allows
checkingsemanticproperties;ifattributesuseageneral-purpose
programminglanguage,onecanexpressarbitrarilycomplexseman-
ticproperties.Themeta-compilerJastAdd[ 12],forinstance,sup-
portsimperative specifications in Java;the same holdsfor ANTLR
(Java) and yacc (C). ISLaâ€™s mix of quantifiers, structural predicates,
and SMT-LIB assertions allows expressing important input proper-
ties andcan be usedfor parsingandproducing inputsalike.
Grammar-Based Test Generation. Context-Free Grammars are
wellsuitedforsyntax-awaretestinputgeneration.CSmith[ 31]and
LangFuzz [ 14] use CFGs as a basis to randomly create syntactically
valid C and JavaScript programs, respectively; Grammarinator [ 13]
produces inputs from ANTLR grammars. The underlying gram-
mars are typically handwritten, but can also be minedfrom pro-
grams[10]andinputs[ 18].ISLafitsbetweenGrammarinatorand
CSmith:Itcanproduceinputsfrom differentlanguagemodels like
Grammarinator,butfulfills semanticproperties likeCSmith.Yet,the
probability that Grammarinator will create a valid TAR file from a
CFG approaches zero, and CSmith can only generateÃwellÃC files.
Test Generation with Semantic Properties. FormatFuzzer [ 6] is
a fuzzer for binary formats. It is parameterized with binary tem-
platesaslanguagemodels.ThoseresembleCstructs,butcomewith
addedcode forsatisfying semantic constraints, includingcomplex
expressions,controlstatements,andfunctions.Theseconstraints
are strictly local,though, mainly supporting checksums and length
fields for binary formats. Non-local and complex constraints, such
asdef-useproperties, have to be programmatically implemented.
ISLaâ€™sconstraints,incontrast,aredeclarative,canapplytoarbitrary
elements inthe derivationtree,andare easily solvedusing Z3.
Panetal.[ 22]useHigher-OrderAttributeGrammars[ 30]forfuzz
testing, providing custom predicates for parse tree manipulation
(e.g.,lengthconstraintsandchecksumcomputation)inageneral-
purpose programming language. The approach neither supports
parsingnorgenerationfrom scratch.
Deweyetal. [ 5]proposetoprogram grammarsand constraints
inPrologusingitsConstraintLogicProgramming(CLP)libraryfor
language-basedtestgeneration.Alltheirpredicatesareapplication-
specific,whichistheexceptionforISLa.Thereisnotoolsuchas
ISLearn to infer Prolog programs. ISLa supports all Z3 theories,
whereas CLPonly supportsintegerarithmetic.Finally, CLP-based
languagefuzzerscannotbe usedfor parsing.
Property-Based Testing. Pioneered by QuickCheck [ 2], Property-
BasedTesting(PBT)produces datastructuresofthehostlanguage
to test individual functions against user-defined properties. This al-
lowsexpressingfeaturesinthehostprogramminglanguage,which
is not available when working with unstructured system inputs.
ProSyT[4]andLuck[ 19]generatedatastructuresforErlangand
Haskell,resp.,separating semantic constraintsfrom data types.
Generally,theconcept of parsingandmutating existingdatais
not present in PBT. One exception is Zest [ 21], which leverages
program feedback to create syntactically valid input mutants exer-
cisinginterestingprogrampaths.Thecentraldifferencebetween
ISLa and all PBT approaches is that ISLa operates at the system
level, producing systeminputs rather than internal data structures.MiningInvariants. Daikon[7]istheseminalworkforextracting
invariantcandidates fromprogramexecutionsÃpre-andpostcon-
ditions as well as data invariants; its pattern matching approach
is the inspiration for ISLearn. Recent advances in the field focus
onprogramverification,loopinvariants,andtheusageofneural
networks[ 32].Unlike ISLearn, all these approaches operateatthe
unitlevel,andcannotgeneratetargetedexecutions torefineinvari-
ants. To the best of our knowledge, ISLearn is the first approach to
specify,determine,andrefine invariantsat the systemlevel.
8 CONCLUSION AND FUTUREWORK
We proposed ISLa, a declarative specification language for context-
sensitive constraints of system inputs. In our framework, syntactic
languageconstraintsarespecifiedusingContext-FreeGrammars
(CFGs), which are great for parsing, but often too coarse for gener-
atinginputs.Context-sensitiverefinementsareexpressedbyISLa
constraints, using the vocabulary defined by the CFG. We formally
definedISLaâ€™ssyntaxandsemanticsanddemonstratedthatourISLa
solvercanbeusedtogeneratesemanticallycorrectinputssignifi-
cantlyfasterthanbygeneratingfromaCFGalone.Furthermore,we
introduced the ISLearn input invariant miner, which automatically
producesusefulISLaspecificationsbasedonaprogramproperty
and/orsample inputs.
BesidesfurtherrefiningtheISLaandISLearnimplementation,
our future work willfocusonthe following topics:
Fuzzerintegration. ISLa-generated inputs can serve as high-
qualityseedinputs forgrayboxfuzzerslikeAFL;ISLaâ€™scheck-
erscanquicklyfilteroutinvalidgeneratedinputs.Further-
more, ISLa could improve the performance of hybrid fuzzers
byservingasalanguageforexchangingconstraintsbetween
thesymbolicexecutionand fuzzingcomponents.This idea
hasbeenputforwardbytheauthorsoftheDriller[ 27]paper,
but has not yetbeen put intopractice.
Testing strategies. AprobabilisticvariantofISLearncouldquickly
learnwhich input features correlatewith program behaviors
(includingfailuresor specificcoverage); thisallows for test
generationtechniques exploringsyntax andsemantics.
Constraint synthesis. Besideschecking patterns,techniquesfrom
program synthesis would have great potential for generating
constraintsfrom examples.
Constraints as oracles. AsISLaallowsextractingandassessing
arbitraryinputelements,itcanalsocheck outputsforcon-
straints.ThisallowsusingISLaconstraintsas oracles(that
could alsobe learnedviaISLearn).
Detecting anomalies. Decomposinginputsandoutputsprovides
plenty of syntactical and semantic featuresthat can be used
forlearningcommonalitiesandanomalies;learnedcorrela-
tionscan be reinforcedbyISLa-generatedtests.
DATA AVAILABILITYSTATEMENT
OurevaluatedISLaandISLearnartifactsarepubliclyavailable[ 26].
The currentversionsofthe prototypes can be downloadedfrom
https://github.com/rindPHI/isla
https://github.com/rindPHI/islearn
593ESEC/FSE â€™22, November14Å›18, 2022,Singapore, Singapore Dominic SteinhÃ¶fel andAndreas Zeller
REFERENCES
[1]ClarkBarrett,PascalFontaine,andCesareTinelli.2017. TheSMT-LIBStandard:
Version 2.6 . Technical Report. Department of Computer Science, The University
of Iowa. Available at www.SMT-LIB.org .
[2]Koen Claessen and John Hughes. 2000. QuickCheck: A Lightweight Tool for
RandomTestingof HaskellPrograms. In ProceedingsoftheFifthACM SIGPLAN
International Conference on Functional Programming (ICFP) , Martin Odersky and
PhilipWadler(Eds.).ACM,268Å›279. https://doi.org/10.1145/351240.351266
[3]James Clark and Steve DeRose. 1999. XML Path Language (XPath), 2.5: Abbrevi-
atedSyntax. https://www.w3.org/TR/1999/REC-xpath-19991116/#path-abbrev
Accessed:2022-08-23.
[4]Emanuele De Angelis, Fabio Fioravanti, AdriÃ¡n Palacios, Alberto Pettorossi, and
MaurizioProietti.2019. Property-BasedTestCaseGeneratorsforFree.In Tests
and Proofs - 13th International Conference, TAP@FM 2019, Porto, Portugal, October
9-11, 2019, Proceedings (Lecture Notes in Computer Science, Vol. 11823) , Dirk Beyer
and Chantal Keller (Eds.). Springer, 186Å›206. https://doi.org/10.1007/978-3-030-
31157-5_12
[5]KyleDewey,JaredRoesch,andBenHardekopf.2014. LanguageFuzzingUsing
ConstraintLogicProgramming. In ACM/IEEEInternationalConference onAuto-
matedSoftwareEngineering,ASE2014 ,IvicaCrnkovic,MarshaChechik,andPaul
GrÃ¼nbacher (Eds.).ACM,725Å›730. https://doi.org/10.1145/2642937.2642963
[6]Rafael Dutra, Rahul Gopinath, and Andreas Zeller. 2021. FormatFuzzer: Effective
FuzzingofBinaryFileFormats. CoRRabs/2109.11277(2021). arXiv: 2109.11277
https://arxiv.org/abs/2109.11277
[7]MichaelD.Ernst,JakeCockrell,WilliamG.Griswold,andDavidNotkin.1999.
Dynamically Discovering Likely Program Invariants to Support Program Evolu-
tion. InProceedings ofthe1999InternationalConference on Software Engineering,
(ICSE), Barry W. Boehm, David Garlan, and Jeff Kramer (Eds.). ACM, 213Å›224.
https://doi.org/10.1145/302405.302467
[8]Marc Feeley. 2001. Tiny-C Compiler. https://www.iro.umontreal.ca/~felipe/
IFT2030-Automne2002/Complements/tinyc.c . Accessed:2021-10-06.
[9]PatriceGodefroid,AdamKiezun,andMichaelY.Levin.2008. Grammar-Based
WhiteboxFuzzing.In ProceedingsoftheACMSIGPLAN2008ConferenceonPro-
grammingLanguageDesignandImplementation(PLDI) ,RajivGuptaandSamanP.
Amarasinghe(Eds.).ACM,206Å›215. https://doi.org/10.1145/1375581.1375607
[10]RahulGopinath,BjÃ¶rnMathis,andAndreasZeller.2020. MiningInputGrammars
fromDynamicControlFlow.In Proceedings28thACMJointEuropeanSoftware
EngineeringConferenceandSymposiumontheFoundationsofSoftwareEngineering
(ESEC/FST) , Prem Devanbu, Myra B. Cohen, and Thomas Zimmermann (Eds.).
ACM,172Å›183. https://doi.org/10.1145/3368089.3409679
[11]Nikolas Havrikov and Andreas Zeller. 2019. Systematically Covering Input
Structure. In 34th IEEE/ACM International Conference on Automated Software
Engineering (ASE) . IEEE,189Å›199. https://doi.org/10.1109/ASE.2019.00027
[12]GÃ¶rel Hedin and Eva Magnusson. 2001. JastAddÃA Java-Based System for
Implementing Front Ends. Electron. Notes Theor. Comput. Sci. 44, 2 (2001), 59Å›78.
https://doi.org/10.1016/S1571-0661(04)80920-4
[13]RenÃ¡ta HodovÃ¡n, Ãkos Kiss, and Tibor GyimÃ³thy. 2018. Grammarinator: A
Grammar-Based Open Source Fuzzer. In Proceedings of the 9th ACM SIGSOFT
InternationalWorkshoponAutomatingTESTCaseDesign,Selection,andEvaluation ,
Wishnu Prasetya, Tanja E. J. Vos, and Sinem Getir (Eds.). ACM, 45Å›48. https:
//doi.org/10.1145/3278186.3278193
[14]Christian Holler, Kim Herzig, and Andreas Zeller. 2012. Fuzzing with Code
Fragments. In Proceedings of the 21th USENIX Security Symposium , Tadayoshi
Kohno(Ed.).USENIXAssociation,445Å›458. https://www.usenix.org/conference/
usenixsecurity12/technical-sessions/presentation/holler
[15]JohnE.Hopcroft,RajeevMotwani,andJeffreyD.Ullman.2007. Introductionto
AutomataTheory, Languages, and Computation, 3rdEdition . Addison-Wesley.
[16]StephenCJohnson.1979. Yacc:YetAnotherCompiler-Compiler. https://www.
cs.utexas.edu/users/novak/yaccpaper.htm . Accessed:2021-11-19.[17]DonaldE.Knuth.1990. TheGenesisofAttributeGrammars.In Proceedingsofthe
InternationalConferenceonAttributeGrammarsandtheirApplications (Lecture
Notes in Computer Science, Vol. 461) , Pierre Deransart and MartinJourdan (Eds.).
Springer, 1Å›12. https://doi.org/10.1007/3-540-53101-7_1
[18]NeilKulkarni,CarolineLemieux,andKoushikSen.2021. LearningHighlyRecur-
sive InputGrammars. In 36thIEEE/ACMInternationalConference onAutomated
SoftwareEngineering,ASE2021,Melbourne,Australia,November15-19,2021 .IEEE,
456Å›467. https://doi.org/10.1109/ASE51524.2021.9678879
[19]Leonidas Lampropoulos, Diane Gallois-Wong, Catalin Hritcu, John Hughes, Ben-
jaminC.Pierce,andLi-yaoXia.2017. Beginnerâ€™sLuck:ALanguageforProperty-
BasedGenerators.In Proceedingsofthe44thACMSIGPLANSymposiumonPrinci-
ples of Programming Languages (POPL) 2017 , Giuseppe Castagna and Andrew D.
Gordon (Eds.).ACM,114Å›129. https://doi.org/10.1145/3009837.3009868
[20]Barton P. Miller, Lars Fredriksen, and Bryan So. 1990. An Empirical Study of
the Reliability of UNIX Utilities. Commun. ACM 33, 12 (1990), 32Å›44. https:
//doi.org/10.1145/96267.96279
[21]Rohan Padhye, Caroline Lemieux, Koushik Sen, Mike Papadakis, and Yves Le
Traon.2019. SemanticFuzzingwithZest.In Proceedingsofthe28thACMSIGSOFT
International Symposium on Software Testing and Analysis (ISSTA) , Dongmei
ZhangandAndersMÃ¹ller(Eds.).ACM,329Å›340. https://doi.org/10.1145/3293882.
3330576
[22]Fan Pan, Ying Hou, Zheng Hong, Lifa Wu, and Haiguang Lai. 2013. Efficient
Model-based Fuzz Testing Using Higher-order Attribute Grammars. J. Softw.8, 3
(2013), 645Å›651. https://doi.org/10.4304/jsw.8.3.645-651
[23]Alan J. Perlis. 1982. Epigrams on Programming. ACM SIGPLAN Notices 17, 9
(1982), 7Å›13. https://doi.org/10.1145/947955.1083808
[24]Dominic SteinhÃ¶fel. 2022. The ISLa Language Specification. https://rindphi.
github.io/isla/islaspec/ Accessed:2022-08-23.
[25]Dominic SteinhÃ¶fel and Andreas Zeller. 2022. Electronic Appendix to Å‚Input
InvariantsÅ¾. CoRRabs/2208.12049 (2022). https://doi.org/10.48550/arXiv.2208.
12049arXiv:2208.12049
[26]Dominic SteinhÃ¶fel and Andreas Zeller. 2022. Replication Package for Å‚Input
InvariantsÅ¾. https://doi.org/10.1145/3554336
[27]NickStephens,JohnGrosen,ChristopherSalls,AndrewDutcher,RuoyuWang,
Jacopo Corbetta, YanShoshitaishvili, Christopher Kruegel, and Giovanni Vigna.
2016. Driller: Augmenting Fuzzing Through Selective Symbolic Execution. In
23rdAnnualNetworkandDistributedSystemSecuritySymposium,NDSS2016,San
Diego,California, USA, February21-24, 2016 . The Internet Society.
[28]The SMT-LIB Initiative. 2021. SMT-LIB Theories. http://smtlib.cs.uiowa.edu/
theories.shtml . Accessed:2021-10-19.
[29]CesareTinelli,ClarkBarrett,andPascalFontaine.2020. TheoryStrings(SMT-LIB
Version2.6). http://smtlib.cs.uiowa.edu/theories-UnicodeStrings.shtml . Accessed:
2021-10-07.
[30]Harald Vogt, S. Doaitse Swierstra, and Matthijs F. Kuiper. 1989. Higher-Order
AttributeGrammars.In ProceedingsoftheACMSIGPLANâ€™89ConferenceonPro-
gramming Language Design and Implementation (PLDI) , Richard L. Wexelblat
(Ed.). ACM,131Å›145. https://doi.org/10.1145/73141.74830
[31]Xuejun Yang, Yang Chen, Eric Eide, and John Regehr. 2011. Finding and Un-
derstanding Bugs in C Compilers. In Proceedings of the 32nd ACM SIGPLAN
Conference on Programming Language Design and Implementation (PLDI) 2011 ,
MaryW.HallandDavidA.Padua(Eds.).ACM,283Å›294. https://doi.org/10.1145/
1993498.1993532
[32]JiananYao,GabrielRyan,JustinWong,SumanJana,andRonghuiGu.2020. Learn-
ingNonlinearLoopInvariantswithGatedContinuousLogicNetworks.In Pro-
ceedings of the 41st ACM SIGPLAN Conference on Programming Language Design
andImplementation (London,UK) (PLDI2020) .AssociationforComputingMa-
chinery, New York, NY, USA, 106Å›120. https://doi.org/10.1145/3385412.3385986
[33]AndreasZeller,RahulGopinath,MarcelBÃ¶hme,GordonFraser,andChristian
Holler. 2021. Grammar Coverage. In The Fuzzing Book . CISPA Helmholtz Center
for Information Security. Accessed:2021-11-13.
594