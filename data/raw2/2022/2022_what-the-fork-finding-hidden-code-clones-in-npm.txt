What the Fork? Finding Hidden Code Clones in npmElizabeth WyssUniversity of KansasLawrence, KS, USAElizabethWyss@ku.eduLorenzo De CarliWorcester Polytechnic InstituteWorcester, MA, USAldecarli@wpi.eduDrew DavidsonUniversity of KansasLawrence, KS, USADrewDavidson@ku.eduABSTRACTThis work presents/f_indings and mitigations on an under-studied issue, which we term shrinkwrapped clones, that isendemic to the npm software package ecosystem. A shrink-wrapped clone is a package which duplicates, or near-duplicates,the code of another package without any indication or refer-ence to the original package. This phenomenon represents achallenge to the hygiene of package ecosystems, as a clonepackage may siphon interest from the package being cloned,or create hidden duplicates of vulnerable, insecure code whichcan/f_ly under the radar of audit processes.Motivated by these considerations, we propose#/n.sc%/r.sc/a.sc()(/e.sc/r.sc, a mechanism to programmatically detect shrinkwrappedclones and match them to their source package.#/n.sc%/r.sc/a.sc()(/e.sc/r.scuses a package di+erence metric based on directory treesimilarity, augmented with a pre/f_ilter which quickly weedsout packages unlikely to be clones of a target. Overall, ourprototype can compare a given package within the entirenpm ecosystem (1,716,061packages with20,190,452di+er-ent versions) in72.85seconds, and it is thus practical forlive deployment. Using our tool, we performed an analysisof a subset of npm packages, which resulted in/f_inding up to6,292previously unknown shrinkwrapped clones, of whichup to207carried vulnerabilities from the original packagethat had already been/f_ixed in the original package. None ofsuch vulnerabilities were discoverable via the standard npmaudit process.ACM Reference Format:Elizabeth Wyss, Lorenzo De Carli, and Drew Davidson. 2022. Whatthe Fork? Finding Hidden Code Clones in npm. In44th InternationalConference on Software Engineering (ICSE ‚Äô22), May 21‚Äì29, 2022, Pitts-burgh, PA, USA.ACM, New York, NY, USA, 12 pages. https://doi.org/10.1145/3510003.35101681 INTRODUCTIONThe security and correctness of code stored in package reposi-tories is an important concern because such repositories arecrucial to modern software infrastructure. Indeed, language-based package repositories such as npm, pypi, and RubyGemscollectively serve billions of packages each week [39]. Muchof the popularity of package repositories is due to the pack-age manager frontend, which allows a user to easily import apackage by issuing a simple install directive on the commandPermission to make digital or hard copies of part or all of this work for personalor classroom use is granted without fee provided that copies are not made ordistributed for pro/f_it or commercial advantage and that copies bear this noticeand the full citation on the/f_irst page. Copyrights for third-party components ofthis work must be honored. For all other uses, contact the owner/author(s).ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA¬© 2022 Copyright held by the owner/author(s).ACM ISBN 978-1-4503-9221-1/22/05.https://doi.org/10.1145/3510003.3510168line. While seamless import of external code is convenient,it also creates problems: developers tend to assume code tobe reliable rather than vetting prior to import [6], and once apackage is imported, latent bugs and vulnerabilities becomepart of the/f_inal application. Importing the ‚Äúwrong‚Äù packagemay cause signi/f_icant supply-chain security issues [17].This work presents/f_indings and mitigations on an under-studied issue within the npm package repository1, which wetermshrinkwrapped clones. We use this term to refer to pack-ages which are uploaded to a package repository and containcode that is identical, or nearly-identical, to that of an existing(legitimate) package. Speci/f_ically, we discover two types ofclones: (i) identical clones, which contain source code that isidentical to that of an existing package, and (ii) close clones,which make potentially signi/f_icant syntactic/semantic changesto the code, but generally localized to a small number of/f_iles(we re/f_ine this de/f_inition in the following). This phenomenonis characteristic to npm, as this ecosystem lacks the notionof forks, by which we mean copied code repositories that ex-plicitly link back to their source repositories (as is commonfor example in GitHub [2]). Instead, shrinkwrapped clones innpm cannot be explicitly linked back their source packagessince npm lacks o,cial mechanisms for forking packages.The phenomenon of shrinkwrapped clones represents achallenge to the hygiene of package repositories; in particular,it contributes to the problem ofconfusabilityof npm packages.npm contains more than 1.7 million packages, and while theecosystem provides a robust search interface, it provides noassistance in choosing the most appropriate package to pro-vide a desired functionality. Previous work on typosquattingattacks [39] suggests that it is fairly common for developersto install a package di+erent from the one they intended.Clones exacerbate these problems. Most obviously, a clonepackage causes confusion, as clone packages are oftentimesnamed similarly to the original package, and in many occasionsthey also reuse their metadata (such as the package descrip-tion). Users of the package repository may thus misattributethe provenance of a package, giving credit to the wrong de-veloper for creating a particular codebase. However, we also/f_ind that a non-trivial number of clone packages are rarelymaintained and fail to include updates to the package beingcopied. The users of the clone are thereby locked into olderversions of functionality and, crucially, forgo any bug/f_ixesthat are applied to the package being cloned. In e+ect, the usersof the clone are subject to vulnerabilities which have alreadybeen patched. Moreover, clones can exist deep within pack-age dependency trees, which means that installing a packagethat (transitively) depends on a clone also implicitly installs1We choose npm as our repository of interest because it is the largest and mostpopular.24152022 IEEE/ACM 44th International Conference on Software Engineering (ICSE)
ICSE ‚Äô22, May 21‚Äì29, 2022, Pi/t_tsburgh, PA, USAElizabeth Wyss, Lorenzo De Carli, and Drew Davidsonthat clone via npm‚Äôs automated dependency resolution mech-anism. For these reasons, a user may be unaware that theyhave downloaded a clone, wherein vulnerabilty disclosuresfail to propagate, because there is no facility in npm to link aclone to the package that has been cloned.In this work, we study the scope and impact of shrink-wrapped clones. Detecting shrinkwrapped clones presentsseveral challenges. First, there is no agreed-upon standard onwhat extent of code-reuse constitutes a code clone [21,22,25,29,30,38]. Second, close clones - i.e., clones that makechanges to the original package - exhibit local but complexsyntactic modi/f_ications (e.g. translating CommonJS syntax toES6). Thus, they are incompatible with many existing clonedetectors, which focus on the insertion and deletion of state-ments [25,29] (we further review related work in Section 6).Finally, in order to determine whether a package clones anyother, the package must be compared to the entirety of npm,which leaves limited to no time for any form of code analysis.We address these challenges with a parametrizable heuris-tic designed for pairwise package comparison. The heuristicde/f_ines shrinkwrapped clones via a tunable/f_ile-granularitysyntactic distance threshold. With this approach, any twopackages whose distance is below the threshold are consid-ered close clones, or identical clones if the distance equals one2(we discuss strategies for tuning the threshold in Section 3).The heuristic only considers whole-/f_ile hashes and eschewstokenization and any form of lexical analysis, making it com-putationally e,cient - a package can be matched for clonesagainst the entirety of npm in a matter of seconds. Based onthis heuristic, we propose#/n.sc%/r.sc/a.sc((/e.sc/r.sc: a mechanism to detectwhen a package is a clone of another more popular package.Explicitly linking a clone to the package from which it camehas several bene/f_its. It enhances the provenance informationof packages, restoring the connection to the originators of thepackage. Furthermore, it allows users to avoid clone packages,preventing them from unwittingly using a less-maintainedcopy of a codebase and directing them to the original. Finally,users can be made aware of any vulnerabilities that may havebeen reported in the original version of the package. Thus, ourapproach constitutes a turnkey solution, suitable for operatingover the package repository with no manual intervention.Overall, our work makes the following contributions:‚Ä¢We identify and characterize the problem of shrink-wrapped clones in the npm package repository.‚Ä¢We propose#/n.sc%/r.sc/a.sc((/e.sc/r.sc, a technique to check when apackage is a shrinkwrapped clone of any other package.‚Ä¢We evaluate#/n.sc%/r.sc/a.sc((/e.sc/r.scand/f_ind that it is e+ective inpractice to identify shrinkwrapped clones with reason-able time and space overhead (the majority of packagescan be compared to the existing20Mpackage set forclones in72.85 secondsusing o+-the-shelf hardware).‚Ä¢We report our/f_indings based on the analysis of a subsetof npm. Our analyses identi/f_ied up to6,292clones. Upto2159relied on vulnerable, outdated dependencies.Furthermore, up to207clones directly incorporated2npm packages contain a unique-per-package metadata/f_ile which limits packagedistance to a minimum of 1.vulnerabilities which were not discoverable via the npmaudit process.Additionally, we publicly release our code and supportingdata, freely distributed via the Open Science Framework [5]:https://osf.io/jfk3n/?view_only=6f930d1de8704a26903540f75982bffbThe remainder of our paper is structured as follows. Sec-tion 2 reviews background material. Section 3 provides tech-nical details of the clone detection methodology. We describeresults of our experiments in Section 4, and discuss our/f_ind-ings in Section 5. We review related work in Section 6, andconclude in Section 7.2 BACKGROUND2.1 npmnpm consists of a package manager and a repository for soft-ware developed for the Node.js environment. npm is the largestonline language-based software ecosystem [41]; it containsmillions of publicly available packages and weekly downloadcounts range from hundreds of millions to billions. Similar toother package management tools, the primary goal of npmis to simplify third-party code reuse by managing softwaredependencies. When a user issues thenpm installcommand,the front-end constructs a tree of all required dependenciesand then installs each package within the tree without theneed for user involvement. npm allows packages to be down-loaded freely (either directly or as dependencies of anotherpackage), and allows new packages to be uploaded withoutany external moderation. However, the maintainers have asecurity team whose goal is to detect and remove explicitly ma-licious packages, either via internal analysis or by collectingexternal reports [31].2.2 Versioning and ForkingDevelopment in npm is characterized by fast-evolving codeand extensive code reuse via import of external dependencies,even for trivial functionality [6]. To help prevent breakage in apackage due to the evolution of its dependencies, npm automat-ically freezes dependencies within a compatible version range,and further allows developers to specify exact dependencyversions via a process known asshrinkwrapping. Using thisfeature guarantees that dependencies will always be fetchedat the version they were originally imported. However, npmo+ers no o,cial support for developers wishing to modify athird-party package prior to importing it. In other words, thereis no explicit concept of aforkas in other ecosystems such asGitHub [2]. As such, developers seeking to modify an existingpackage must download, alter, and then republish the modi/f_iedpackage under a new name. For this reason, modi/f_ied packageson npm are di,cult to detect; to make matters worse, when apackage is manually duplicated, information attached to thatpackage is lost. Critically, this lost information includes boththe original version history and any known vulnerabilities as-sociated to the original package (typically retrievable vianpmaudit). Thus, the act of duplicating a package implicitly hides2416What the Fork? Finding Hidden Code Clones in npmICSE ‚Äô22, May 21‚Äì29, 2022, Pi/t_tsburgh, PA, USAopts.log.http(/quotesingle.Varfetch/quotesingle.Var,/grave.ts1${method.toUpperCase()} ${res.status}${res.url} ${elapsedTime}ms${attemptStr}${cacheStr}/grave.ts1)Listing 1: Vulnerable code snippet present in unpatchedversions ofnpm-registry-fetchand in the most up-to-date version of@evocateur/npm-registry-fetchleturlStrtry{const{ URL } = require(/quotesingle.Varurl/quotesingle.Var)consturl =newURL(res.url)if(url.password)url.password =/quotesingle.Var***/quotesingle.VarurlStr = url.toString()}catch(er) {urlStr = res.url}opts.log.http(/quotesingle.Varfetch/quotesingle.Var,/grave.ts1${method.toUpperCase()} ${res.status}${urlStr} ${elapsedTime}ms${attemptStr}${cacheStr}/grave.ts1)Listing 2: Nonvulnerable code snippet present inpatched versions ofnpm-registry-fetchimportant information including authorship, whether morerecent versions of the same package exist, and any knownsecurity issues.2.3 Shrinkwrapped ClonesThe goals of our work are (i) to measure how frequently de-velopers duplicate‚Äîand potentially modify‚Äî third-party pack-ages into one of their packages; (ii) to determine whether thisprocess can have negative security implications; and (iii) todevise techniques for identifying the ‚Äúmissing link‚Äù betweenduplicate npm packages and the original package. One ques-tion wedo notinvestigate iswhydevelopers perform suchduplication; as this would require making inferences or as-sumptions about developers‚Äô intentions and goals. However,we did observe that in many cases duplicates are exact copiesof the original package; therefore, including a duplicate ac-complishes the same result as shrinkwrapping the originalpackage at the duplicated version. It is for this reason that werefer to these packages asshrinkwrapped clones. An exampleincludes the package redux-form-v6, which is an exact copyof redux-form at version6.4.3.While we use shrinkwrapped clones as an umbrella term forall duplicates, we also note that in some cases developers makeMetricnpmTotal Unique Packages1,716,061Total Unique Package Versions20,190,452Total Size (Compressed)13 TBTable 1: Statistics related to the size of the npm packagerepositorysmall functional changes to duplicate code prior to republish-ing. A manual review of such cases reveal that in the largemajority of cases the developer intends to remove function-ality (as in the case of@cypress/listr-verbose-renderer,which is near-identical tolistr-verbose-rendererbut dis-ables logging) or to implement programmer preferences (@xtuc/ieee754is a clone ofiee754but reconstructed using Com-monJS syntax rather than ES2015 syntax).The observation above warrants further analysis: to whatextentshouldmodi/f_ications made to a package cause a dupli-cate to not be considered a clone? Rather than addressing thequestion above‚Äîwhich cannot be answered quantitatively‚Äîwe empirically de/f_ine a di+erence metric and a threshold belowwhich two packages are labeled as clones. We provide detailson metric and threshold in Section 3, and further discuss our/f_indings in Section 4.2.4 Vulnerabilities Introduced by ClonesAs described in Section 1, shrinkwrapped clones can carrylatent vulnerabilities from the time of their creation. One suchexample is present in the@evocateur/npm-registry-fetchpackage, which is a clone of thenpm-registry-fetchpack-age. Versions ofnpm-registry-fetchprior to version 4.0.5contain a sensitive data exposure vulnerability in which pri-vate information such as password values are written to stdoutand log/f_iles [?]. The vulnerable code snippet is depicted inListing 1, and the relevant patched code snippet that/f_ixesthe vulnerability is depicted in Listing 2.@evocateur/npm-registry-fetchcopied the codebase ofnpm-registry-fetchat version 3.9.1, which contains the known sensitive data ex-posure vulnerability. Although@evocateur/npm-registry-fetchhas received two minor updates since it was/f_irst pub-lished, none of these updates/f_ix the sensitive data exposurevulnerability that still remains in the package‚Äôs codebase.2.5 Scale of npm AnalysisTable 1 describes the total size of npm in terms of packages,versions, and storage. It is a nontrivial problem to individuallyanalyze millions of package versions, accounting for over 13terabytes of package data in total. As such, we focus our e+ortson caching metadata and applying heuristics to analyze suchmetadata at scale. This metadata-based approach is consis-tent with ongoing industry e+orts to analyze large-scale opensource package repositories such as the Package Feeds [4]and Kritis [3] projects. We believe that our metadata-basedapproach is e,cient and su,cient in detecting shrinkwrappedclones; we describe our approach in detail in Section 3, and2417ICSE ‚Äô22, May 21‚Äì29, 2022, Pi/t_tsburgh, PA, USAElizabeth Wyss, Lorenzo De Carli, and Drew Davidson

	

		
					

	
	


Figure 1: Work/f_low of/u.sc/n.sc/w.sc%&/p.sc/p.sc(%from collection ofpackages to classi)cationwe provide justi/f_ication for the e+ectiveness of this approachin Section 4.3 UNWRAPPER DESIGNBased on our observations described in Section 2, we design#/n.sc%/r.sc/a.sc((/e.sc/r.scto identify instances of shrinkwrapped clonesthat exist within npm. In this section, we describe our goalsfor this tool and how our design meets those goals.3.1/u.sc/n.sc/w.sc%&/p.sc/p.sc(%Assumptions and GoalsAt a high level, we are interested in identifying instances ofpackages that aresimilarto another known package. Fur-thermore, we also intend to propose practical techniques toidentify these objects at ecosystem scale. We assume that whilea developer may fail to explicitly acknowledge the source of ashrinkwrapped clone, no attempt is made to obfuscate similar-ity at the code level. This assumption is based on the lack ofincentive to do so; most npm package code is provided underpermissive licenses which allow reuse [24], and there is nodirect negative consequences for code duplication.We envision#/n.sc%/r.sc/a.sc((/e.sc/r.scbeing used toretroactivelydetectshrinkwrapped clones that are already present in npm, restor-ing the provenance of the package code. Using#/n.sc%/r.sc/a.sc((/e.sc/r.scin this way allows users of npm to detect whether packagesthat they depend on are shrinkwrapped clones and to suggestthe original package that they may prefer. We also envision#/n.sc%/r.sc/a.sc((/e.sc/r.scbeing used toproactivelydetect if a new packagebeing added to npm is a clone at the time it is published.The popularity of npm makes analysis challenging ‚Äì thenumber of existing packages already in the repository is sig-ni/f_icant. Furthermore, we observe that a key problem withshrinkwrapped clones is that they are clones of non-currentversions of other packages. Thus,#/n.sc%/r.sc/a.sc((/e.sc/r.scneeds to matchany package of interest against the entirety of the npm ecosys-tem, including all versions of all packages. Additionally, ap-proximately 850 new packages are uploaded daily to npm [15].#/n.sc%/r.sc/a.sc((/e.sc/r.scmust remain able to process all new packageswithout slowing down their deployment.3.2 Design OverviewBased on the discussion above, we design#/n.sc%/r.sc/a.sc((/e.sc/r.scwiththe goal of being able to scale with the growth of a repository;it must be relatively fast and lightweight in its analysis and becapable of running in an environment separate from the repos-itory itself. The overall#/n.sc%/r.sc/a.sc((/e.sc/r.scpipeline is depicted inFigure 1. Packages are initially acquired using an npm crawlerand listener (module1in Figure 1). The task of determiningwhether a package is a clone of another is primarily carried bythe Clone Detector component (module3). Our approach toshrinkwrapped clone detection leverages the identi/f_ication ofdi+erences between directory trees of candidate original-clonepairs‚Äìwhere each/f_ile node is labeled by its name and check-sum, and no other information about the/f_ile is considered.This approach does not require performing any code analysisother than checksum computation and is consistent with theassumption of non-adversarial settings.However, we found that while this approach is e,cient,it is too time-intensive for live analysis of new package up-loads. Thus, we augmented it with a pre/f_iltering step (module2). This pre/f_ilter sits between the package dataset and theclone detector, and quickly weeds out packages unlikely tobe shrinkwrapped clones. In the following, we describe eachcomponent in detail.3.3 npm InterfaceThe frontend of#/n.sc%/r.sc/a.sc((/e.sc/r.scinterfaces with npm to collectinformation from every version of every package that is cur-rently available and analyzes new packages in a timely fash-ion. We accomplished package collection by implementingan npm crawler which downloads and stores each packageversion locally. This approach allows packages to be accessedrapidly and without burdening the repository with analysisrequests. Since changes to packages are necessarily made asnew versions, the package database remains accurate for allexisting package versions and only needs to be updated withnew versions as they are added to the repository. To supportupdates, we implement an npm listener that triggers when-ever a new package ‚Äì or a new version of an existing package‚Äì is added to the repository. New entries are automaticallyadded to the local package database and queued for detectionas shrinkwrapped clones. The listener uses the npm webhooksystem and is automatically noti/f_ied of updates without theneed for polling. Using this system means that new packagesand versions are added to the analysis queue in real-time.3.4 Clone DetectorThis component takes in a shrinkwrapped clone package can-didate pair, and evaluates their similarity by computing adomain-speci/f_ic pairwise di+erence metric which we term2418What the Fork? Finding Hidden Code Clones in npmICSE ‚Äô22, May 21‚Äì29, 2022, Pi/t_tsburgh, PA, USACandidate Clone Package ‹≤Checksum computation›Ä-score Calculation
›ÄP, Q  = ‹´ +2(‹∑P +‹∑Q) ‚â§ TD?
Clone IdentificationCandidate Original Package ‹≥Checksum computationFigure 2: Operation of the Clone Detector/u1D451-score. More precisely, the di+erence between two packages/u1D443and/u1D444is de/f_ined as:/u1D451/u1D443,/u1D444=/u1D43C+2(/u1D448/u1D443+/u1D448/u1D444)where/u1D43Cis the number of identically named/f_iles with dif-ferent checksums amongst both packages, and/u1D448/u1D443,/u1D448/u1D444are thenumber of/f_iles unique (name-wise) to only one of the pack-ages. As such, packages with a lower di+erence score are moresimilar than packages with a higher di+erence score, and pack-ages with a di+erence score of one are semantically identical,di+ering only in their package.json metadata/f_ile which is guar-anteed to be unique to each package. A candidate package isconsidered to be a clone of the input package if their pairwise/u1D451-score is less than a given threshold/u1D447/u1D437acrossanyversionof either package. We present the design of our clone detectorin Figure 2.3.4.1 DiÔ¨Äerence Threshold.We determine an appropriate dif-ference threshold by manually building an initial dataset ofclone packages. To do so, we analyze the extent to which repos-itory URLs3are duplicated across the 10,000 most popular npmpackages. The initial analysis returned thousands of hits; thelarge majority of such hits are caused by packages which aresub-modules to other packages (e.g. thelodash._getarraypackage is a sub-module of thelodashpackage which exportsthegetArrayfunction fromlodash). To/f_ilter out these sub-module packages, we removed packages that shared maintain-ers with the packages that duplicated their repository URLs.Applying this/f_ilter left 38 packages, and manual review ofthese packages empirically showed all of them to contain code-bases that were initially copied over from the packages thattheir duplicated repository URLs originate from.We then examined the distribution of/u1D451-scores within thesample of 38 packages (plotted in Figure 3).34 out of 38cloneshave/u1D451-scores at or below 11. Conversely, analysis of a set ofpackage pairs which do not include clones reveal/u1D451-scores inthe tens or hundreds. The four identi/f_ied clone packages with/u1D451-scores greater than 11 all made substantial changes to thecore functionality of the packages that they cloned and had/u1D451-scores no less than 17. Thus, to minimize false positives, we3npm packages can optionally express a source repository URL, such as a GitHubpage, as metadata (we further analyze the e+ectiveness of source repositoryURL duplication as a clone detection signal in Section 4.3).Figure 3: Distribution of diÔ¨Äerence scores across a sam-ple of 38 manually identi)ed clone packagesClone File Tree Size/u1D451-score Threshold11223446586107+11Table 2:/u1D451-score threshold by clone)le tree sizeempirically choose11as the/u1D451-score threshold below whichtwo packages are labeled as shrinkwrapped clones.This/u1D451-score threshold is further tightened in cases wherepackages have very few/f_iles as to prevent small packagesfrom being falsely over-reported as shrinkwrapped clones ofother small packages. Table 2 depicts our determined/u1D451-scorethreshold as a function of/f_ile tree size. These thresholds wereselected empirically by measuring the/u1D451-scores in cases wheresmall packages were falsely identi/f_ied as shrinkwrapped clonesof other small packages.3.5 Clone Pre)lterOur design goal of supporting real-time detection of shrink-wrapped clones requires a scalable analysis that accounts forthe size and rapid growth of npm. Handling the scale of npmis a technical challenge in its own right. Our core similaritymetric requires a pairwise comparison against each packageversion, of which there are over 20 million at the time of thiswriting. In recognition of this scalability challenge, we imple-ment a clone pre/f_ilter mechanism which rapidly determines ifa package is a candidate for pairwise similarity metric check-ing.The/f_irst design goal for the pre/f_ilter is to speed up match-ing against the pre-existing package dataset. Furthermore, itshould eliminate packages from consideration that are unlikelyto be marked as clones during the full clone detection pass.2419ICSE ‚Äô22, May 21‚Äì29, 2022, Pi/t_tsburgh, PA, USAElizabeth Wyss, Lorenzo De Carli, and Drew Davidson	
							
 
 
		 


		
		Figure 4: Functioning of the Clone Pre)lterIn service of speeding up matching in the pre/f_ilter, we aimto precompute as much information as possible about knownpackages in the repository. However, given the scale of thenpm ecosystem, it is also necessary to ensure that: (i) precom-puting the necessary information for the entire set of existingpackages does not become a signi/f_icant bottleneck; and (ii)precomputed information has a memory footprint compati-ble with o+-the-shelf hardware. We present a pre/f_ilter designmeeting those conditions below; the approach is also depictedin Figure 4.Like the clone detector, the pre/f_ilter uses folder structuresimilarity to identify potential clones; however, the similaritymetric is purely based on/f_ile names (i.e. it uses no informationconcerning/f_ile content). Speci/f_ically, a package/u1D443is repre-sented as a/f_ingerprint/u1D439/u1D443de/f_ined as/u1D439/u1D443={/uni210E(/u1D45D1),. . . ,/uni210E(/u1D45D/u1D45B)},where each of/u1D45D1,. . . ,/u1D45D/u1D45Bis a package/f_ile path and/uni210E(/u1D45D)=/u1D460/uni210E/u1D44E256(/u1D45D)1,32, i.e., the 32-bit pre/f_ix of the sha256 hash of thepath4. Computing/f_ingerprints for 20M npm packages takes29.4 hours. The resulting/f_ingerprint set requires80.2 GBofin-memory storage. Therefore, this design meets our practi-cality requirements above.Given a set of package/f_ingerprints, the pre/f_ilter determineswhether a target package,is a candidate clone for an existingpackage/u1D443as follows. First, it computes|#/u1D439/u1D436‚àí#/u1D439/u1D443|, i.e., thedi+erence in number of/f_iles in each packages. If the result isabove a threshold/u1D447/u1D446, the candidate is dropped. Second, it com-putes #(/u1D439/u1D436‚à©/u1D439/u1D443)/#/u1D439/u1D436, i.e., the overlap between/f_ingerprintsnormalized by the number of/f_iles in the candidate clone. Ifthe result is below a threshold/u1D447/u1D442, the candidate is dropped.Additionally, any packages that share maintainers with pack-age,are dropped (this is to prevent submodule packages andmaintainer-intended duplicate packages from falsely beingidenti/f_ied as clones), and further, if package,contains nosource code/f_iles, it is excluded from consideration (this isto prevent trivial packages with no code from falsely beingidenti/f_ied as clones); otherwise, the candidate is forwarded tothe clone detector as depicted in Figure 1. Based on ROC curveanalysis, we found that setting/u1D447/u1D446=2 and/u1D447/u1D442=0.8 results in agood balance of minimizing false negatives and false positives.In a production deployment, these parameters can be furthertuned to satisfy the desired ROC characteristic of the pre/f_ilter.4We use this hash function for convenience in our Python prototype; the func-tioning of the pre/f_ilter is largely orthogonal to the choice of function.Table 3.1Pre)lter PerformanceMetricMin TimeMax TimeAvg TimeAdd a Packageto Pre/f_ilter0.566 ms442 ms5.24 msTest a PackageAgainst Pre/f_ilter54.22 s203.79 s70.81 sTable 3.2Clone Detector PerformanceMetricMin TimeMax TimeAvg TimeFirst Test174 ms5,820 ms319 msAdditional Tests168 ms3,840 ms255 msTable 3: Performance metrics related to our shrink-wrapped clone detector and pre)lterThe rationale for choosing this particular combination oftests is based on the goal of approximating the/u1D451-score compu-tation, which identi/f_ies packages as similar if they have mostof their/f_iles in common. At the same time, the pre/f_ilter ignores/f_ile content, resulting in a vastly more e,cient computation.4 EVALUATIONTo evaluate the practicality and e+ectiveness of our shrink-wrapped clones detection pipeline, we focus on answeringthree research questions:‚Ä¢RQ1:Is the pipeline‚Äôs performance satisfactory in gen-erating pre/f_ilter/f_ingerprints for the entire npm packagerepository?‚Ä¢RQ2:Does the pipeline o+er real-time performancecapable of scaling with the growth rate of npm?‚Ä¢RQ3:Is the pipeline e+ective in discriminating shrink-wrapped clones from novel packages?In the remainder of this section, we detail our methodologyused to answer these research questions, we discuss our results,and we present an analysis of detected clone packages.4.1 PerformanceWe measure the minimum, maximum, and average time thatour shrinkwrapped clone detector and pre/f_ilter require to per-form their operations, and we present the measured perfor-mance metrics in Table 3. All measurements are collectedacross 1,000 independent trials on a CentOS Linux 8 serverwith an Intel Xeon Gold processor operating at 2.1 GHz.The rest of this subsection discusses the online and o-ineperformance of our shrinkwrapped clone detection pipelineas laid out in RQ1 and RQ2.Pre)lter Fingerprint Generation: Since shrinkwrapped clonedetection relies on information about the/f_ile structure of ev-ery version of every npm package, our pipeline must be ableto retro/f_it the entire npm package repository with reasonableperformance. From analyzing every package publicly availableon npm, we/f_ind that there exists 20,190,452 unique versions ofpackages on npm. All of these unique package versions mustbe added to our pre/f_ilter‚Äôs/f_ingerprint database in order for2420What the Fork? Finding Hidden Code Clones in npmICSE ‚Äô22, May 21‚Äì29, 2022, Pi/t_tsburgh, PA, USAour shrinkwrapped clone detection pipeline to function. Ta-ble 3.1, row 3, details the time to add a package to the pre/f_ilter.Given that our pre/f_ilter can add a single package version to its/f_ingerprint database in an average time of 5.24 ms, generatinga/f_ingerprint database that contains every unique package ver-sion across npm requires 29.39 hours of CPU time. To lessenthe required time, this process of adding packages to our pre-/f_ilter‚Äôs/f_ingerprint database can be parallelized across multipleCPU cores to reduce the required time to a mere fraction of29.39 hours. With parallelization in mind, we believe that thisperformance in generating pre/f_ilter/f_ingerprints for the entirenpm package repository is reasonable since retroactively gen-erating the pre/f_ilter‚Äôs/f_ingerprint database is a process thatonly needs to be done once.Real-time Clone Detection: Because of npm‚Äôs rapid growthin packages per day, real-time shrinkwrapped clone detectionrequires performance that scales with the growth rate of npm.At the time of writing, npm is growing at rate of just over850 new packages per day [15]. In order to keep up with anew package uploaded to npm, our pipeline requires that thenew package is added to the pre/f_ilter and tested against thepre/f_ilter (ref. to Table 3.1), and then any positives reported bythe pre/f_ilter must be veri/f_ied with the clone detector. Table 3.2details the time for the clone detector to determine whethera package is a clone of another. Since a candidate clone istypically matched against multiple potential matches from thepre/f_ilter, we report analysis times both for the/f_irst test andsubsequent ones. Subsequent tests are typically faster as/f_ilehashes for the candidate clone need only to be computed once.Given the performance results listed in Table 3, our shrink-wrapped clone detection pipeline can perform its requiredoperations on just a single CPU core within 1/850th of a dayas long as the pre/f_ilter reports fewer than 122 positives onaverage. In practice, we/f_ind that the majority of packages canbe tested against our entire shrinkwrapped clone detectionpipeline within 72.85 seconds. We note that our shrinkwrappedclone detection process is highly parallelizable and could eas-ily utilize multiple CPU cores if the growth rate of npm or thetotal positives reported by the pre/f_ilter were to increase. Assuch, we consider the real-time performance of our pipeline tobe more than reasonable with respect to the scale and growthrate of npm.4.2 EÔ¨Äectiveness of Clone DetectionWe now analyze the e+ectiveness of our tools in detectingshrinkwrapped clones as described in RQ3.Clone Detector: Due to the inherent lack of ground truthregarding whether a package is a clone of another package,we rely on random sampling and manual vetting to verify thee+ectiveness of our shrinkwrapped clone detector. Our truepositive veri/f_ication process is as follows: We/f_irst collect arandom sample of packages that our clone detector positivelyidenti/f_ies as (non-identical) clones of another package. Then,both packages in the identi/f_ied original-clone relationship aremanually examined in terms of their/f_ile tree structures and/f_ile contents. Lastly, we mark identi/f_ied clone packages as falsepositives if their clone relationship cannot clearly be identi/f_iedFigure 5: Distribution of pre)lter false positives acrossall tested clone packagesfrom their package/f_iles. In a random sample of one hundredpackages that our detector reports as clones, We/f_ind a totalof 94 true positives and 6 false positives.We/f_ind that the false positives reported by our clone detec-tor share a set of common properties that increase the di,cultyof clone detection. They are all small packages with limitedfunctionality, they contain very few/f_iles, and they have shortand nondescriptive names‚Äìsuch as copy, merge, and capitalize.As such, these packages are similar to other small packagesthat provide independent implementations of similar function-ality, and our clone detector can misreport them as clones.Despite the existence of these few false positives, we believethat our clone detector‚Äôs precision of 94% is satisfactory inaccurately detecting shrinkwrapped clones.Pre)lter: We utilize clone packages identi/f_ied by our detectoras the basis for ground truth in evaluating the e+ectiveness ofour pre/f_ilter. We randomly sample 1,000 identi/f_ied clone pack-ages, test them against our pre/f_ilter, and then record the totalnumber and kind of positives reported by the pre/f_ilter. Fromthis experiment, we/f_ind that the recall of our pre/f_ilter (i.e., thepercentage of correctly identi/f_ied known clone relationships)is 95.3%. We present the cumulative distribution function ofobserved false positives identi/f_ied by our pre/f_ilter in Figure 5.From this distribution, we/f_ind that the median number offalse positives reported by our pre/f_ilter is 8, although thereexists a small portion of input packages that generate falsepositive quantities in the thousands. This is consistent withthe pre/f_ilter design goal of maximizing recall at the cost ofprecision. Given that the pre/f_ilter is merely the/f_irst step in ourshrinkwrapped clone detection pipeline which involves veri-fying positives using our clone detector, we believe that thequality and quantity of reported positives is quite reasonable,especially with the parallelizable performance of our clonedetector.2421ICSE ‚Äô22, May 21‚Äì29, 2022, Pi/t_tsburgh, PA, USAElizabeth Wyss, Lorenzo De Carli, and Drew Davidson
Figure 6: Distribution of total weekly downloads overall identi)ed clone packages. The 6.7% of clone pack-ages right of the red line have more than 350 weeklydownloads and are likely installed by real users4.3 Analysis of Clone PackagesLastly, we analyze packages that our pipeline identi/f_ies asclones in order to quantify and categorize the posture of shrink-wrapped clones across the npm package ecosystem.Quantifying Total Clones Across the npm Registry:T oquantify how many clones potentially exist within the entirenpm package registry, we collect a random sample of 6,000npm packages and test our shrinkwrapped clone detectionpipeline against those packages to estimate an upper boundof how many clones exist in the entirety of the npm packageregistry. Out of the 6,000 randomly sampled packages, ourdetection pipeline identi/f_ies 626, or roughly 10.4% of analyzedpackages, to be clones of another npm package. By extrapolat-ing this ratio to the entire npm package ecosystem (1,716,061packages), we estimate that as many as 178,470 npm packagescould be shrinkwrapped clones of other packages or be clonedby other packages. This sheer quantity of packages only am-pli/f_ies the impact and dangers imposed by the existence ofshrinkwrapped clones.We further analyze the 626 packages positively identi/f_iedas shrinkwrapped clones by our detection pipeline to quantifythe extent to which name-similar clones likely exist withinthe npm package ecosystem. Clones that are similar in nameto the packages that they clone pose a more serious threatto the health of npm given that they lead to much greaterconfusability in package provenance. We/f_ind that 175 out ofthe 626 identi/f_ied shrinkwrapped clones, or approximately 28%,have package names such that the cloned package‚Äôs name is asubstring of the clone package‚Äôs name. While there certainlyexists shrinkwrapped clones with dissimilar names, we believethat focusing our analysis on the clones with the most potentialto cause harm is the right direction for this work.Identical Clones and Close Clones: In this analysis, wedistinguish between two distinct subsets of clones that ourpipeline detects:identical clonesandclose clones. IdenticalTable 4.1Clone Dependents on npmDependent TypeIdentical (348)Close (5,944)Total Dependents3976,496Dependents bySame Maintainers1602,588Dependents byDi+erent Maintainers2373,908Table 4.2Clone Repository URLsURL TypeIdentical (348)Close (5,944)Copied URL2103,153Unique URL1212,602No URL17189Table 4: Statistics categorizing identical clones and closeclonesclones are identical in contents‚Äìcharacter by character‚Äìtoa speci/f_ic version of another package (although they may dif-fer in metadata). In contrast, close clones make some sort ofmodi/f_ication or extension to the packages that they clone.From analyzing similarly named packages across the entirenpm package registry, our shrinkwrapped clones detectionpipeline identi/f_ies 348 identical clones and 5,944 close clonesthat are publicly available on npm.Clone Popularity: The relative popularity of packages canbe inferred from npm since the registry publicly provides theweekly download counts of all packages; Figure 6 depicts thedistribution of weekly download counts across all identi/f_iedclone packages. However, weekly download counts do notaccurately represent the quantity of real users of a packagesince npm mirrors and bots routinely download packages forstorage and analysis. The npm development team estimatesthat packages with fewer than/f_ifty downloads per day arelikely never installed by a real user [?]. From this metric of/f_ifty downloads per day, we identify clones that have weeklydownload counts greater than 350 as likely installed by realusers, and clones that have fewer than 350 weekly downloadsas low-impact packages that are likely never installed by realusers. We/f_ind that 21 out of the identi/f_ied 348 identical clonesand 399 out of the identi/f_ied 5,944 close clones have more than350 weekly downloads (ranging from a few hundred to morethan ten million) and are very likely to impact real users.Clone Dependents: Due to package dependencies acrossnpm, it is possible that packages are indirectly installed andutilized as part of other packages. As such, we analyze the ex-tent to which packages across npm depend on identi/f_ied clonepackages to further quantify the use of shrinkwrapped clones.Table 4.1 details npm packages that depend on identi/f_ied clonepackages. We/f_ind that a total of 397 packages depend on one ormore of the identi/f_ied 348 identical clones, and a total of 6,496packages depend on one or more of the identi/f_ied 5,944 closeclones. Upon further examination, we/f_ind that 160 out of the397 identical clone dependents are packages that are addition-ally developed by the same maintainers as the identical clone,2422What the Fork? Finding Hidden Code Clones in npmICSE ‚Äô22, May 21‚Äì29, 2022, Pi/t_tsburgh, PA, USATable 5Clone Vulnerability & PopularityClone TypeIdentical (348)Close (5,944)Likely Downloaded21399More Vulnerable622,304Likely Downloaded AND More Vulnerable4148More Vulnerable AND Vulnerabilities Undetected by Audit17190Likely Downloaded AND More Vulnerable AND Vulnerabilities Undetected by Audit08Table 5: Measured popularity and vulnerability statistics of identical clones and close clones
Figure 7: Distribution of total package updates over allidenti)ed clone packagesand 2,588 out of the 6,496 close clone dependents are packagesthat are also developed by the same maintainers as the closeclone. This tendency for package maintainers to utilize theirown shrinkwrapped clone packages as dependencies in addi-tional packages that they develop could suggest one reason asto why package maintainers create clone packages‚Äìthey in-tend to use their functionality for development purposes. Dueto the existence of a large quantity of shrinkwrapped clonedependents, the total impact of clone packages is increased,since clone packages are installed unknowingly whenever auser installs a package that depends on a clone.Clone Maintenance: Packages that are rarely or never main-tained pose issues of health to the npm package ecosystembecause it is less likely that their bugs and security vulnerabili-ties are ever addressed. We examine the update history of clonepackages to determine if these packages are well-maintainedor published yet forgotten. Figure 7 illustrates the distributionof total package updates across all identi/f_ied clone packages.We/f_ind that 209 out of the identi/f_ied 348 identical clones and2,744 out of the identi/f_ied 5,944 close clones have never re-ceived a single package update. This lack of maintenance posesa serious threat to the health of the npm registry.Latent Vulnerabilities in Clones: The greatest danger thatshrinkwrapped clones pose is that they can contain old vul-nerabilities with known exploits that used to be present inthe packages that they clone. We analyze the extent to whichclones contain latent vulnerabilities by scanning the npm ad-visory database for vulnerabilities in the clone‚Äôs dependencies,in the relevant version of the cloned package, and in the cloneitself. We/f_ind that 62 out of the identi/f_ied 348 identical clonesand 2,304 out of the identi/f_ied 5,944 close clones contain vul-nerabilities that are not present in the most up-to-date versionof the cloned package. Most of the identi/f_ied vulnerabilitiesare located in outdated versions of clone dependencies, andthese kinds of vulnerabilities could be resolvedifa user exe-cutes an npm audit to/f_ix known vulnerabilities within theirinstalled packages. However, vulnerabilities that exist directlyin the code of a cloned package version will also exist in thecode of the corresponding clone, and even an npm audit can-not detect these vulnerabilities since the npm frontend lacksawareness of clone relationships. We/f_ind that 17 out of the 62more vulnerable identical clones and 190 out of the 2,304 morevulnerable close clones potentially contain these kinds of la-tent vulnerabilities that are undetectable by standard auditingprocedure.Because it is possible that a close clone package maintainercould independently discover and/f_ix a vulnerability copiedover from a cloned package, we randomly sample 20 of the 190close clones containing potentially unreported vulnerabilities,and we manually verify whether the vulnerability found in thecloned package is still present in the clone package. We/f_indthat in 18 cases, the vulnerability is present in the clone andundetected by an npm audit, and we/f_ind that in 2 cases, thepackage identi/f_ied as a clone was falsely identi/f_ied as a clone.Hence, these previously undetected vulnerabilities are quiteprevalent, and even a security-conscious npm user cannot/f_ixthem with the auditing tools provided by npm.We also examine the intersection between clone packagepopularity and clone package vulnerabilities to determinewhether real users are likely impacted by these vulnerabilities.These intersecting subsets of identi/f_ied clones are describedin Table 5. We/f_ind that 4 out of the 21 identical clones withmore than 350 weekly downloads and 148 out of the 399 closeclones with more than 350 weekly downloads contain latentvulnerabilities not present in the most up-to-date version ofthe cloned package. We further discovered that 8 of the 148vulnerable close clones likely downloaded by real users alsocontain vulnerabilities that are not detected by an npm audit,and one of these 8 clones,@evocateur/npm-registry-fetch,has more than one million weekly downloads. As such, weconclude that clone vulnerabilities pose an imminent threatto the npm package ecosystem because they are exposing real2423ICSE ‚Äô22, May 21‚Äì29, 2022, Pi/t_tsburgh, PA, USAElizabeth Wyss, Lorenzo De Carli, and Drew Davidsonusers to known exploits of old vulnerabilities and are evadingreasonable detection by security-conscious users.Clone Repositories: In npm, package metadata often con-tains a repository URL pointing to where the package coderesides, typically in the form of a GitHub URL. We analyzewhether identi/f_ied clones copy the repository URL of the pack-age that they clone to determine if repository URLs couldserve as a su,cient signal in detecting shrinkwrapped clones.The breakdown of repository URLs across identi/f_ied clonepackages is detailed in Table 4.2. Because identical clones cande/f_ine their own distinct metadata, we/f_ind that out of theidenti/f_ied 348 identical clones, 210 copy the repository URL ofthe cloned package, 121 have a unique repository URL, and 17do not provide a repository URL. Out of the 5,944 identi/f_iedclose clones, we/f_ind that 3,153 copy the repository URL of thecloned package, 2,602 have a unique repository URL, and 189do not provide a repository URL. We compare these URL ratiosto the npm registry as a whole, where 65% of packages providea repository URL and 35% of packages do not. Hence, packagerepository URLs can provide some good insight into validatingpackage clone relationships, but they are not su,cient as aclone detection signal.5 DISCUSSION5.1 Disadvantages and Bene)ts of ClonesThe existence of identical clones o+ers no bene/f_it to the npmecosystem since npm already allows shrinkwrapping depen-dencies, where speci/f_ic versions of packages can be speci/f_iedas dependencies. Identical clones simply introduce more po-tentially vulnerable and less-documented packages to npm,and in particular, identical clones o+er no functional bene/f_itover using a shrinkwrapped version of the cloned package.The existence of close clones o+ers some bene/f_it to de-velopers requiring modi/f_ied packages, but npm lacks directsupport for this, such as through forking packages. This leadsto clones on npm being poorly documented, prone to latentvulnerabilities, and lacking maintenance.In both cases, having a technique which can identify clonescan o+er bene/f_its. Creators of identical clones can be redi-rected to use the npm shrinkwrap feature instead. Clones withfunctional di+erences can be explicitly linked to their originalpackages so that an auditing team discovering a vulnerabilityin one package can check whether the same exists in the other.5.2 Future WorkWhile this work focuses on the detection and classi/f_ication ofshrinkwrapped clones, we identify several directions for fu-ture work, most notably in mitigating the dangers that shrink-wrapped clones pose.Registry Integration of Forking.We note that registry sup-port for forking packages and tracking fork relationshipswould help to mitigate many of the ecosystem health con-cerns introduced by shrinkwrapped clones. With explicitlylabeled fork relationships, package confusability would be re-duced, the update history and authorship of fork packageswould be transparent, and vulnerabilities discovered in forkedpackages would also be detectable in fork packages.Forking integration could be implemented directly into npmwith the assistance of registry maintainers, or it could be im-plemented independently in a mirror of the npm registry. Thegreatest challenge posed in accomplishing this integrationis in manually retro/f_itting existing clone packages as o,cialforks. We believe that our clone detection pipeline,#/n.sc%/r.sc/a.sc()(/e.sc/r.sc, would aid greatly in this process, although it is still achallenging problem of scale to tackle given the total size ofthe npm package registry.Clone Update Patching.We consider the implementation ofpatching tools capable of applying security critical updates toclone packages to be another worthwhile direction for futurework. With knowledge of clone relationships and critical up-dates to cloned packages, code patches for old vulnerabilitiesand bugs are identi/f_iable. These patches can then be appliedto clone packages, thus resolving critical issues that have pre-viously been/f_ixed in their corresponding cloned packages.The greatest challenge posed by this approach is that pro-gramatically altering code, especially in highly dynamic pro-gramming languages such as JavaScript, is notoriously di,cult.Although many patches applied to packages are very straight-forward in nature, a patching tool will likely encounter manypatches that are di,cult or impossible to programatically re-solve. As such, we leave navigating this challenge as an avenuefor future work.6 RELATED WORKDetection of Code Clones: There is a signi/f_icant body ofwork on the detection of code clones, i.e., instances where asoftware is duplicated without maintaining clear attribution ofthe original source code. Early e+orts were based on extractionof lexical features as/f_ingerprints. Moss [37], by Schleimer etal., is based on a winnowing algorithm to select small sectionsof source code, which are then used as/f_ingerprints. Many sim-ilar approaches utilize n-grams to extract/f_ingerprints. Smithand Horwitz [38] propose a clone detection algorithm basedon the identi/f_ication of least-frequent n-grams. Kim et al. [25]use similarities in locality-disjoint n-grams for clone detec-tion. Ishio et al. [21] propose a clone detection approach basedon identi/f_ication of minimum-valued sets of n-gram hashes.NIL [29], by Nakagawa et al., utilizes the longest commonsubsequence of n-grams to detect clones with extensive modi-/f_ications.Deckard [22], by Jiang et al., uses a novel AST clusteringalgorithm for identi/f_ication of similar code. CLEVER [30], byNayrolles and Hamou-Lhadj, detects clones based on simi-larities within code blocks modi/f_ied by commits in versioncontrol systems. For a review of other similar works, we referthe reader to Merlo et al. [9]. More recent work investigatesthe application of modern machine learning techniques to theproblem [42, 45].Many of the above techniques focus on clones that insertand delete statements of code, yet within the domain of npmwe observe signi/f_icant clones that exhibit complex syntacticmodi/f_ications that lie outside the models of existing clone2424What the Fork? Finding Hidden Code Clones in npmICSE ‚Äô22, May 21‚Äì29, 2022, Pi/t_tsburgh, PA, USAdetectors. In our work, we eschew code-based features formetadata analysis due to these domain-speci/f_ic challengesand performance requirements in order to operate at scale.E,ciently and e+ectively integrating the techniques above forclone detection is an interesting direction for future work.Provenance Inference: Our work speci/f_ically attempts toaddress which package has been cloned, as opposed to simplyclassifying a package as a clone. In this regard, our work hassome similarities to previous works that attempt to infer theprovenance of code. A related problem in provenance inferenceis that of authorship attribution [23]: mapping a softwaresample, either in binary [7,12] or source code [10], to thedeveloper who created it. Our work explicitly considers thee+ect of similarity on the security and stability of the language-based ecosystem in which the clone appears. Furthermore,authorship information alone is not su,cient to detect clones,since an author may create numerous legitimate packages, andmany packages are the result of many distinct contributors.Characterization of Package Repositories: Previous re-search has investigated the structure and evolution of variouspackage repositories [19,36,43]. However, these works do notspeci/f_ically analyze or discuss their security. Unlike these pastworks, our work seeks to characterize and address a speci/f_icsecurity-relevant phenomenon present in the npm packagerepository (which we believe generalizes to other repositoriesas well).Security and Stability of Package Repositories: A numberof previously published works have investigated the e+ect ofdependencies on the security and stability of software stored inpackage repositories, chie/f_ly npm [6,14,16,20,26,34,41,46].Other package managers have also been an object of study [8,13,28]. More generally, poorly vetted dependencies representan example of supply-chain security issue, a topic that hasbeen discussed extensively [11,27,35,40,44] and has recentlyreceived renewed attention [1]. Finally, some recently pro-posed techniques aim at directly identifying malicious pack-ages via code and/or metadata analysis [17,18,39]. Ratherthan analyzing existing dependencies and vulnerabilities, ourwork focuses on identifying hidden relationships‚Äîand thuspotential security issues‚Äîbetween packages. To our knowl-edge, our work is the/f_irst to identify the shrinkwrapped clonephenomenon as a cause of security and stability issues.7 CONCLUSIONThe hygiene of package repositories is an important concernfor the usability of language ecosystems. Programmers rely onthe ecosystem to discern which packages are appropriate fortheir requirements, to deliver patches to package code, and tocommunicate vulnerabilities or bugs. Package maintainers relyon the ecosystem to credit their contributions appropriately.Maintaining package provenance is key to these capabilities.In this work, we describe a phenomenon that we call shrink-wrapped clones. This phenomenon threatens the hygiene ofthe repository by obscuring the provenance of individual pack-ages, weakening the security and usability of the entire lan-guage ecosystem. We analyze npm, and show that shrink-wrapped clones are observable. We show the harms of shrink-wrapped clones by reporting on instances that we found ofclone packages that present older, vulnerable versions of otherpackages. Furthermore, we discover cases in which obscur-ing the provenance of these packages limits the reporting ofsecurity/f_laws and the deployment of patches in practice.To address these issues, we have developed an analysis thatis capable of detecting shrinkwrapped clones and restoringthe provenance of a package. We implemented our analysisin a prototype tool we call#/n.sc%/r.sc/a.sc((/e.sc/r.sc, which is capable ofoperating e,ciently, in real-time at the scale of the entirenpm repository. Tools such as#/n.sc%/r.sc/a.sc((/e.sc/r.scare a step towardsmitigating the threat of shrinkwrapped clones and improvingthe hygiene of language ecosystems.8 ACKNOWLEDGEMENTSWe thank the anonymous reviewers for their insightful feed-back that greatly aided us in improving this work. This workwas partially supported by a generous gift from the GoogleOpen Source Security Team.REFERENCES[1]2021. Executive Order on Improving the Nation‚Äôs Cybersecu-rity. https://www.whitehouse.gov/brie/f_ing-room/presidential-actions/2021/05/12/executive-order-on-improving-the-nations-cybersecurity/.[2]2021. Fork a Repo.https://docs.github.com/en/get-started/quickstart/fork-a-repo[3] 2021. Grafeas Kritis.https://github.com/grafeas/kritis[4] 2021. OSSF Package Feeds.https://github.com/ossf/package-feeds[5] 2022. Open Science Framework.https://osf.io[6]Rabe Abdalkareem, Olivier Nourry, Sultan Wehaibi, Suhaib Mujahid, andEmad Shihab. 2017. Why Do Developers Use Trivial Packages? An Empiri-cal Case Study on Npm. InProceedings of the 2017 11th Joint Meeting onFoundations of Software Engineering(Paderborn, Germany)(ESEC/FSE 2017).Association for Computing Machinery, New York, NY, USA, 385‚Äì395.[7]Saed Alrabaee, Paria Shirani, Lingyu Wang, Mourad Debbabi, and AimanHanna. 2018. On Leveraging Coding Habits for E+ective Binary AuthorshipAttribution. InESORICS.[8]Anish Athalye, Rumen Hristov, Tran Nguyen, and Qui Nguyen. 2014.Package Manager Security. Technical Report.https://pdfs.semanticscholar.org/d398/d240e916079e418b77ebb4b3730d7e959b15.pdf[9]Stefan Bellon, Rainer Koschke, Giulio Antoniol, Jens Krinke, and EttoreMerlo. 2007. Comparison and Evaluation of Clone Detection Tools.IEEETransactions on Software Engineering33, 9 (Sept. 2007), 577‚Äì591.[10]Steven Burrows, Alexandra L. Uitdenbogerd, and Andrew Turpin. 2009. Ap-plication of Information Retrieval Techniques for Source Code AuthorshipAttribution. InDASFAA.[11]Mircea Cadariu, Eric Bouwers, Joost Visser, and Arie van Deursen. 2015.Tracking known security vulnerabilities in proprietary software systems.InSANER.[12]Aylin Caliskan, Fabian Yamaguchi, Edwin Dauber, Richard Harang, KonradRieck, Rachel Greenstadt, and Arvind Narayanan. 2018. When Coding StyleSurvives Compilation: De-Anonymizing Programmers from ExecutableBinaries. InNDSS.[13]Justin Cappos, Justin Samuel, Scott Baker, and John H Hartman. 2008. Alook in the mirror: Attacks on package managers. InProceedings of the15th ACM conference on Computer and communications security. 565‚Äì574.[14]Kyriakos Chatzidimitriou, Michail Papamichail, Themistoklis Diaman-topoulos, Michail Tsapanos, and Andreas Symeonidis. 2018. Npm-miner:An infrastructure for measuring the quality of the npm registry. In2018IEEE/ACM 15th International Conference on Mining Software Repositories(MSR). IEEE, 42‚Äì45.[15] Erik DeBill. 2021. Modulecounts.http://www.modulecounts.com/[16]Alexandre Decan, Tom Mens, and Eleni Constantinou. 2018. On the im-pact of security vulnerabilities in the npm package dependency network.2425ICSE ‚Äô22, May 21‚Äì29, 2022, Pi/t_tsburgh, PA, USAElizabeth Wyss, Lorenzo De Carli, and Drew DavidsonInProceedings of the 15th International Conference on Mining SoftwareRepositories. 181‚Äì191.[17]Ruian Duan, Omar Alrawi, Ranjita Pai Kasturi, Ryan Elder, BrendanSaltaformaggio, and Wenke Lee. 2021. Towards Measuring Supply ChainAttacks on Package Managers for Interpreted Languages. InProceedingsof the 28th Annual Network and Distributed System Security Symposium.Internet Society.[18]Kalil Garrett, Gabriel Ferreira, Limin Jia, Joshua Sunshine, and ChristianK√§stner. 2019. Detecting suspicious package updates. In2019 IEEE/ACM41st International Conference on Software Engineering: New Ideas and Emerg-ing Results (ICSE-NIER). IEEE, 13‚Äì16.[19]Daniel M German, Bram Adams, and Ahmed E Hassan. 2013. The evolutionof the R software ecosystem. InCSMR.[20]Joseph Hejderup. 2015.In Dependencies We Trust: How vulnerable aredependencies in software modules?Master‚Äôs thesis. Delft University ofTechnology.[21]Takashi Ishio, Yusuke Sakaguchi, Kaoru Ito, and Katsuro Inoue. 2017.Source File Set Search for Clone-and-Own Reuse Analysis. In2017IEEE/ACM 14th International Conference on Mining Software Repositories(MSR). 257‚Äì268.https://doi.org/10.1109/MSR.2017.19[22]Lingxiao Jiang, Ghassan Misherghi, Zhendong Su, and Stephane Glondu.2007. DECKARD: Scalable and Accurate Tree-Based Detection of CodeClones. InICSE. 96‚Äì105.[23]Vaibhavi Kalgutkar, Ratinder Kaur, Hugo Gonzalez, Natalia Stakhanova,and Alina Matyukhina. 2019. Code Authorship Attribution: Methods andChallenges.Comput. Surveys52, 1 (Feb. 2019), 1‚Äì36.[24]Dulanka Karunasena. 2021. How I Analyzed All NPM Dependency Licensesin One Go.https://blog.bitsrc.io/how-i-analyzed-all-npm-dependency-licenses-in-one-go-18de0f7244bc[25]Miryung Kim, Vibha Sazawal, David Notkin, and Gail Murphy. 2005. AnEmpirical Study of Code Clone Genealogies. InProceedings of the 10thEuropean Software Engineering Conference Held Jointly with 13th ACMSIGSOFT International Symposium on Foundations of Software Engineering(Lisbon, Portugal)(ESEC/FSE-13). Association for Computing Machinery,New York, NY, USA, 187‚Äì196.https://doi.org/10.1145/1081706.1081737[26]Igibek Koishybayev and Alexandros Kapravelos. 2020. Mininode: Reducingthe Attack Surface of Node.js Applications. In23rd International Sympo-sium on Research in Attacks, Intrusions and Defenses (RAID 2020). USENIXAssociation, San Sebastian, 121‚Äì134.https://www.usenix.org/conference/raid2020/presentation/koishybayev[27]R. G. Kula, C. D. Roover, D. German, T. Ishio, and K. Inoue. 2014. Visual-izing the Evolution of Systems and Their Library Dependencies. InIEEEVISSOFT.[28]Trishank Karthik Kuppusamy, Santiago Torres-Arias, Vladimir Diaz, andJustin Cappos. 2016. Diplomat: Using delegations to protect communityrepositories. In13th{USENIX}Symposium on Networked Systems Designand Implementation ({NSDI}16). 567‚Äì581.[29]Tasuku Nakagawa, Yoshiki Higo, and Shinji Kusumoto. 2021. NIL: Large-Scale Detection of Large-Variance Clones. InProceedings of the 29th ACMJoint Meeting on European Software Engineering Conference and Symposiumon the Foundations of Software Engineering(Athens, Greece)(ESEC/FSE2021). Association for Computing Machinery, New York, NY, USA, 830‚Äì841.https://doi.org/10.1145/3468264.3468564[30]Mathieu Nayrolles and Abdelwahab Hamou-Lhadj. 2018. CLEVER: Com-bining Code Metrics with Clone Detection for Just-in-Time Fault Preven-tion and Resolution in Large Industrial Projects. InProceedings of the 15thInternational Conference on Mining Software Repositories(Gothenburg, Swe-den)(MSR ‚Äô18). Association for Computing Machinery, New York, NY, USA,153‚Äì164.https://doi.org/10.1145/3196398.3196438[31]NPM Blog Archive 2020. Npm Blog Archive: A Day in the Life of NpmSecurity.https://blog.npmjs.org/post/190665497245/a-day-in-the-life-of-npm-security.html[33]]npm-registry-fetch-advisory npmjs.com. [n. d.]. npm advisory 1544.https://www.npmjs.com/advisories/1544.[33]]npm-download-count npmjs.org. [n. d.]. numeric precision matters: hownpm download counts work (accessed 02/2021).https://blog.npmjs.org/post/92574016600/numeric-precision-ma/t_ters-how-npm-download-counts-work.[34]Brian Pfretzschner and Lot/f_iben Othmane. 2017. Identi/f_ication ofDependency-based Attacks on Node.Js. InARES.[35]H. Plate, S. E. Ponta, and A. Sabetta. 2015. Impact assessment for vulnera-bilities in open-source software libraries. InICSME.[36]Steven Raemaekers, Arie van Deursen, and Joost Visser. 2013. The mavenrepository dataset of metrics, changes, and dependencies. InMSR.[37]Saul Schleimer, Daniel S Wilkerson, and Alex Aiken. 2003. Winnowing:Local Algorithms for Document Fingerprinting. InSIGMOD. 10.[38]Randy Smith and Susan Horwitz. 2009. Detecting and Measuring Similarityin Code Clones. InIWSC. 7.[39]Matthew Taylor, Ruturaj Vaidya, Drew Davidson, Lorenzo De Carli, andVaibhav Rastogi. 2020. Defending Against Package Typosquatting. InInternational Conference on Network and System Security. Springer, 112‚Äì131.[40]J√∏rgen Tellnes. 2013.Dependencies: No Software is an Island. Master‚Äôsthesis. The University of Bergen.[41]Ruturaj K. Vaidya, Lorenzo De Carli, Drew Davidson, and Vaibhav Rastogi.2019. Security Issues in Language-based Sofware Ecosystems.CoRRabs/1903.02613 (2019). arXiv:1903.02613http://arxiv.org/abs/1903.02613[42]Wenhan Wang, Ge Li, Bo Ma, Xin Xia, and Zhi Jin. 2020. Detecting CodeClones with Graph Neural Network and Flow-Augmented Abstract SyntaxTree. InIEEE SANER. 261‚Äì271.[43]Erik Wittern, Philippe Suter, and Shriram Rajagopalan. 2016. A look at thedynamics of the JavaScript package ecosystem. InMSR.[44]A. A. Younis, Y. K. Malaiya, and I. Ray. 2014. Using Attack Surface EntryPoints and Reachability Analysis to Assess the Risk of Software Vulnera-bility Exploitability. InHASE.[45]Hao Yu, Wing Lam, Long Chen, Ge Li, Tao Xie, and Qianxiang Wang. 2019.Neural Detection of Semantic Code Clones Via Tree-Based Convolution.InIEEE/ACM ICPC. 70‚Äì80.[46]Markus Zimmermann, Cristian-Alexandru Staicu, Cam Tenny, and MichaelPradel. 2019. Small world with high risks: A study of security threats inthe npm ecosystem. In28th{USENIX}Security Symposium ({USENIX}Security 19). 995‚Äì1010.
2426