Peahen: Fast and Precise Static Deadlock Detection
via Context Reduction
Yuandao Cai
The Hong Kong University of Science
and Technology
Hong Kong, China
ycaibb@cse.ust.hkChengfeng Ye
The Hong Kong University of Science
and Technology
Hong Kong, China
cyeaa@cse.ust.hk
Qingkai Shi
Ant Group
Shenzhen, China
qingkai.sqk@antgroup.comCharles Zhang
The Hong Kong University of Science
and Technology
Hong Kong, China
charlesz@cse.ust.hk
ABSTRACT
Deadlocks still severely inflict reliability and security issues upon
software systems of the modern age. Worse still, as we note, in
prior static deadlock detectors, good precision does not go hand-in-
hand with high scalability â€” their approaches are either context-
insensitive, thereby engendering many false positives, or suffer
from the calling context explosion to reach context-sensitive, thus
compromising good efficiency. In this paper, we advocate Peahen ,
geared towards precise yet also scalable static deadlock detection.
At its crux, Peahen decomposes the computational effort for em-
bracing high precision into two cooperative analysis stages: (i)
context-insensitive lock-graph construction, which selectively en-
codes the essential lock-acquisition information on each edge, and
(ii) three precise yet lazy refinements, which incorporate such edge
information into progressively refining the deadlock cycles in the
lock graph only for a few interesting calling contexts.
Our extensive experiments yield promising results: Peahen dra-
matically out-performs the state-of-the-art tools on accuracy with-
out losing scalability; it can efficiently check million-line systems
at a low false positive rate; and it has uncovered many confirmed
deadlocks in dozens of mature open-source systems.
CCS CONCEPTS
â€¢Software and its engineering â†’Software verification and
validation .
KEYWORDS
Concurrency, static analysis, deadlock detection, context-sensitivity
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior specific permission and/or a
fee. Request permissions from permissions@acm.org.
ESEC/FSE â€™22, November 14â€“18, 2022, Singapore, Singapore
Â©2022 Association for Computing Machinery.
ACM ISBN 978-1-4503-9413-0/22/11. . . $15.00
https://doi.org/10.1145/3540250.3549110ACM Reference Format:
Yuandao Cai, Chengfeng Ye, Qingkai Shi, and Charles Zhang. 2022. Peahen:
Fast and Precise Static Deadlock Detection via Context Reduction. In Pro-
ceedings of the 30th ACM Joint European Software Engineering Conference
and Symposium on the Foundations of Software Engineering (ESEC/FSE â€™22),
November 14â€“18, 2022, Singapore, Singapore. ACM, New York, NY, USA,
13 pages. https://doi.org/10.1145/3540250.3549110
1 INTRODUCTION
Deadlocks continue to scourge modern software systems with a
denial of service or even malicious attacks [ 46]. Just in 2021, more
than sixty open issues in Firefox andLinux Kernel were associated
with deadlocks [ 18,40]. Over the last decade, many famous sys-
tems (e.g., Apache ,Android ,TensorFlow ) have also fallen victims;
more than eighty CVE IDs have been assigned to the uncovered
deadlock vulnerabilities therein [ 13]. Thus, it is still increasingly
urgent to hunt deadlocks before the production runs. This paper
focuses on resource deadlocks , arising when each thread in a set
circularly waits for another thread to release an acquired lock or a
single thread attempts to reacquire a non-reentrant lock.
Static analysis [ 1,7,44,55,64] has the advantage of penetrating
obscure program paths harboring deadlocks, which, however, are
difficult for dynamic analysis to reach [ 4,5,11,33,34,39,61,67].
Yet, despite the impressive strides for decades, the fast and pre-
cise static deadlock detection for million-line systems remains far
from satisfactory. Specifically, past research [ 2,16,42,49,62] has
strongly indicated that context-sensitive deadlock detectors can
suppress false positives against the context-insensitive ones. On the
downside, as we note, the context-sensitive detectors [ 16,42] suffer
considerably from the scalability penalties induced by the calling
context explosion . For instance, the state-of-the-art context-sensitive
detector [ 42] even failed to analyze a few thousand lines of code
within half an hour or 24 GB of memory.
A crucial reason, as we observe, is that the traditional context-
sensitive deadlock detection constructs a context-sensitive lock
graph through a pre-computed context-sensitive lockset analy-
sis [16,36,38,42], computing the locks held at each program loca-
tion under different calling contexts. A node in the graph represents
a lock object while a directed edge, labeled by the string of call-
ing contexts, indicates the order of lock acquisitions under certainESEC/FSE â€™22, November 14â€“18, 2022, Singapore, Singapore Yuandao Cai, Chengfeng Ye, Qingkai Shi, and Charles Zhang
calling contexts. To disclose deadlocks, the prior approaches tra-
verse the lock graph to discover cycles that characterize cyclic
lock-acquisition orders. Again, the results of the lockset analysis
are leveraged to refine the detected cycles to check if the related
lock acquisitions under the specific calling contexts can be executed
concurrently, i.e., a common lock does not protect them. Yet, we no-
tice that the explosive calling contexts can exceedingly slow down
the pre-computed lockset analysis and blow up the lock graph with
acquired edges, thereby inevitably impeding the graph construction
and deadlock-cycle discovery.
To address the problem, our key insight is that only a minority
of the calling contexts are associated with deadlocks in practical
programs. As a result, a conventional context-sensitive detector
could cause a great deal of redundancy in the pre-computed context-
sensitive lockset analysis, which is oblivious of the related contexts
around the deadlock cycles. In this work, to reduce the irrelevant
calling contexts, Peahen decomposes the cost of reaching high-
fidelity by first efficiently constructing a context-insensitive and
smaller lock graph. With the lock graph in hand, Peahen can focus
on the context-sensitive refinement effort around only a few calling
contexts that are related to the deadlock cycles, whereby saving
much cost to deadlock-irrelevant computation.
More specifically, given the initially detected cycles in the context-
insensitive lock graph, Peahen employs three precise yet lazy re-
finements that effectively approximate three different necessary
conditions of a deadlock:
â€¢A thread identification analysis to examine whether a dead-
lock is induced by a single thread or multiple threads.
â€¢A context-sensitive non-concurrency analysis to identify
whether a multi-threaded deadlock may concurrently occur.
â€¢A constraint solving process to validate the path feasibility
of a deadlock with a costly SMT solver.
Surprisingly, the refinement process itself is also efficient because
the more precise refining results contribute to fewer deadlock cycles
as well as less lazy computation.
One salient feature underpinning our context reduction is that
our lock-graph construction infers and offers the lock-acquisition
information to bootstrap the lazy refinements in close cooper-
ation. First, our lock-graph construction algorithm is composi-
tional and faster than the previous context-sensitive lockset anal-
ysis [ 16,38,42], because it does not enumerate any exponentially
possible calling contexts spanning across the lock acquisitions. Sec-
ond, our algorithm foreseeingly reasons and encodes the essential
edge information on which threads acquire the locks and where
the lock acquisitions take place, which is integrated into the lazy
deadlock refinements to be efficiently leveraged.
We have implemented Peahen for C/C++ systems, where the
non-nested locks (e.g., Pthread APIs) are extensively exploited.
Like many modern static bug-finding tools [ 55,57],Peahen is
soundy [ 45], sacrificing soundness in a few common cases for high
fidelity. The experimental results are highlighted below:
â€¢Advancing the state-of-the-art : we compared Peahen to two
recent detectors, CBMC [42] (context-sensitive) and Infer [2,
22] (context-insensitive) under the benchmarks [ 42]. It is
noted that we refer to the static deadlock detector [ 42] asCBMC throughout because it is maintained in a git branch
of the CBMC project [41].
â€“Peahen achieves 136Ã—speed-up versus CBMC and, rea-
sonably, is slightly slower than Infer .
â€“Peahen can reduce around 73.45% and 90.0% false posi-
tives against CBMC andInfer , respectively. In addition,
Peahen can detect all the intentionally planted deadlocks
in their benchmarks [42].
â€“Our context-insensitive lock graph can reduce about 95.5%
acquired edges that are otherwise identified and added
to a context-sensitive graph. Moreover, our lock-graph
construction and cycle-detection process are about 231 Ã—
and 46Ã—faster than the ones in CBMC , respectively.
â€¢Effective on large systems : we have used Peahen to capture
deadlock issues on a diverse set of real-world, widely-used
open-source C/C++ software systems.
â€“Peahen can effectively finish the checking of multi-MLOC
code bases (e.g., Firefox around 2 hours) at a relatively low
false-positive rate (30.43% on average).
â€“Peahen has detected more than eighty confirmed dead-
locks from dozens of famous open systems, all told [50].
To sum up, our contributions are as follows:
â€¢We advocate Peahen , a context-reduction technique for fast
and precise deadlock detection in large software systems.
â€¢We present a compositional algorithm to construct a context-
insensitive lock graph for non-nested locks, which is also
collaborative with lazy deadlock refinements.
â€¢We conduct substantial experiments to show Peahen â€™s good
scalability and precision versus the previous work.
2PEAHEN IN A NUTSHELL
We first utilize a buggy program in Figure 1 to clarify the concept of
deadlock (Â§ 2.1). We then illustrate the shortcomings of the previous
context-sensitive solutions (Â§ 2.2). Finally, we highlight the essence
of our more effective context-reduction approach (Â§ 2.3).
2.1 Example Illustration
Let the symbol ğ‘ğ‘¡ğ‘¥represent the calling context and ğ‘ ğ‘–denote the
statement at Line ğ‘–. For the code snippet shown in Figure 1, there are
two concurrent threads ğ‘¡1andğ‘¡2, running the functions ğ‘¡â„ğ‘Ÿğ‘’ğ‘ğ‘‘ 1()
andğ‘¡â„ğ‘Ÿğ‘’ğ‘ğ‘‘ 2(), respectively. Specifically, the thread ğ‘¡1first executes
the function ğ‘“ğ‘œğ‘œ()holding a lock ğ‘œ1and then executes the function
ğ‘“ğ‘œğ‘œ()again with the lock ğ‘œ1released before. Similarly, the thread
ğ‘¡2executes the function ğ‘ğ‘ğ‘Ÿ()twice, one of which is protected by
the common lock ğ‘œ1.
If we take a close look at the functions ğ‘“ğ‘œğ‘œ()andğ‘ğ‘ğ‘Ÿ(), there is
an order inversion between the locks ğ‘œ2andğ‘œ3. That is, a deadlock
may be triggered when the thread ğ‘¡1acquires the lock ğ‘œ2atğ‘ 8,
waiting atğ‘ 9forğ‘œ3to be released, but thread ğ‘¡2acquires the lock ğ‘œ3
atğ‘ 21, waiting atğ‘ 22forğ‘œ2to be released, and neither can progress.
However, the function ğ‘“ğ‘œğ‘œ()under the calling context ğ‘ğ‘¡ğ‘¥1and the
functionğ‘ğ‘ğ‘Ÿ()under the calling context ğ‘ğ‘¡ğ‘¥3cannot be executed
concurrently, because they are protected by a common lock ğ‘œ1(also
called a gate lock [ 23,49]). Thus, the two functions ğ‘“ğ‘œğ‘œ()andğ‘ğ‘ğ‘Ÿ()
under other compositional calling contexts, such as ğ‘“ğ‘œğ‘œ()atğ‘ğ‘¡ğ‘¥1Peahen: Fast and Precise Static Deadlock Detection via Context Reduction ESEC/FSE â€™22, November 14â€“18, 2022, Singapore, Singapore
Context-insensitiveLock Graph Construction1.   void thread1( ){ // Thread t12.         lock(v1); // o13.         foo(); // ctx14.         unlock(v1);5.  foo(); //ctx26.   }7.   void foo( ){8.         lock(v2); // o29.         lock(v3); // o310.       x++;11.       unlock(v2);12.       unlock(v3);13.  }14.  void thread2( ){// Thread t215.     lock(v1);// o116.     bar(); // ctx317.     unlock(v1);18.bar(); //ctx419.  }20.  void bar( ){21.      lock(v3);// o322.      lock(v2);// o223.      x++;24.      unlock(v3);25.      unlock(v2);26.  }o1ÂŒÂÂÂÂÂ‘Â’Â“o2o3IDConditionÂŒ(ctx1,s8)Â(ctx1,s9)Â(ctx2,s9)Â(ctx1,s9)Â(ctx3,s22)Â‘(ctx3,s22)Â’(ctx4,s22)Â“(ctx3,s21)IDCondition ÂŒ(t1,s8)Â(t1,s9)Â(t1,s9)Â(t2,s22)Â(t2,s22)Â‘(t2,s21)(a)
(b)
o2o3Â‘Âo2o3Â‘Âo2o3Â’Âo2o3Â’Â
o2o3ÂÂ
Might s9and s22not be guarded by a common lock? o1ÂŒÂÂÂÂÂ‘o2o3Context-sensitiveLockset AnalysisContext-sensitiveLockset Analysis
Context-sensitiveLazy Refinement
Figure 1: Figure(a) shows the previous context-sensitive approach, which uses a dual-purpose, context-sensitive lockset analy-
sis for both constructing a lock graph and identifying the gate lock. Figure(b) shows the context reduction approach, which first
constructs a context-insensitive, smaller graph and detects fewer cycles, followed by the context-sensitive lazy refinements.
andğ‘ğ‘ğ‘Ÿ()atğ‘ğ‘¡ğ‘¥4, can be executed concurrently and a deadlock bug
could surface to â€œbitâ€, bringing the program to a grinding halt.
To sum up, there are two key steps for static deadlock detection.
First, the lock-acquisition orders in each thread should be identified
to derive cyclic orders among locks. Second, the initial results on re-
versed orders of lock acquisitions should be further refined, such as
context-sensitively identifying the gate-lock scenarios. Importantly,
the solutions should both be precise and highly scalable, sieving
through millions of lines of code in just a few hours.
2.2 The State-of-the-Art
However, to go for high precision, the prior approaches could not
scale up to large systems. An essential reason is that, they commonly
employ a flow-, context-sensitive lockset analysis, which computes
the locks held at each program point [ 38,42,62]. The precise pre-
computed lockset analysis can kill two birds with one stone; it is
capable of context-sensitively identifying the lock acquisitions and
the gate locks. On the downside, the explosive calling contexts in
large programs can drastically slow down the lockset analysis and
blow up the lock graph with acquired edges.
To illustrate, in Figure 1(a), the approach first constructs a context-
sensitive lock graph using a context-sensitive lockset analysis. For
instance, the lockset analysis can tell that the lock ğ‘œ1is held at the
statementğ‘ 8under the calling context ğ‘ğ‘¡ğ‘¥1. Therefore, the thread ğ‘¡1
can hold the lock ğ‘œ1and acquire the lock ğ‘œ2atğ‘ 8underğ‘ğ‘¡ğ‘¥1, result-
ing in a context-sensitive acquired edge from ğ‘œ1toğ‘œ2. Every edge
condition, shown in the right table, consists of the correspondingcalling context ğ‘ğ‘¡ğ‘¥of the lock statement ğ‘ that refers to the desti-
nation lock. For example, the condition on the edge â¶is(ğ‘ğ‘¡ğ‘¥1,ğ‘ 8),
indicating that a thread ( ğ‘¡1) holds lock ğ‘œ1and then acquires lock ğ‘œ2
atğ‘ 8under the calling context ğ‘ğ‘¡ğ‘¥1.
Based on the context-sensitive lock graph, a cycle detection is
performed to identify the context-sensitive cycles on the graph.
As shown in Figure 1(a), four context-sensitive cycles are detected.
Again, the technique uses the context-sensitive results of the lock-
set analysis to identify the gate-lock scenarios. For the detected
cycle with the edges â·andâ», theğ‘ 9under the calling context
ğ‘ğ‘¡ğ‘¥1and theğ‘ 22underğ‘ğ‘¡ğ‘¥3are protected by a gate lock ğ‘œ1, so the
statementsğ‘ 9andğ‘ 22cannot be reached simultaneously under the
corresponding calling contexts. On the other hand, the remaining
three â€œungatedâ€ cycles are reported to the developers, warning of
the calling contexts of ğ‘“ğ‘œğ‘œ()andğ‘ğ‘ğ‘Ÿ()to trigger a deadlock bug.
We notice that the context-sensitive acquired edges are unnec-
essary for identifying the lock-acquisition orders in each thread.
For example, the four detected context-sensitive cycles indicate the
same case, i.e., there is a cyclic-waiting condition between lock ğ‘œ2at
ğ‘ 22in threadğ‘¡2and lockğ‘œ3atğ‘ 9in threadğ‘¡1. On the other hand, the
refinements only target and identify whether statements ğ‘ 9andğ‘ 22
(related to a deadlock cycle) can be concurrently executed, which
is oblivious to the pre-computed lockset analysis.
2.3 Our Context-Reduction Approach
To ameliorate the aforementioned problems, we introduce a context-
reduction approach, breaking down the prohibitive cost of beingESEC/FSE â€™22, November 14â€“18, 2022, Singapore, Singapore Yuandao Cai, Chengfeng Ye, Qingkai Shi, and Charles Zhang
context-sensitive for all sub-tasks. That is, Peahen uses a fast algo-
rithm to construct a context-insensitive lock graph and the cycle
detection to find the fewer context-insensitive deadlock cycles. The
cycles are then successively and lazily refined for a few deadlock-
related calling contexts.
To illustrate, in Figure 1(b), Peahen begins by constructing a
smaller context-insensitive lock graph. Apparently, our lock graph
saves two unnecessary edges. The edge conditions are shown in the
right-hand table with the calling context removed (Extra edge infor-
mation is introduced later). In other words, all the different calling
contexts are reduced or merged into one. Armed with this smaller
graph, Peahen efficiently performs a cycle-detection algorithm to
detect only one deadlock cycle. The context-insensitive cycle with
edgesâ·andâºindicates that there is a cyclic waiting-condition
between lock ğ‘œ3atğ‘ 9and lockğ‘œ2atğ‘ 22without any known calling
context information. Then, a context-sensitive gate-lock analysis
is queried by the question, â€œMight ğ‘ 9andğ‘ 22not be guarded by a
common lock?â€ The answer is â€œYesâ€, flagging they are not protected
by lockğ‘œ1under three compositional calling contexts, ğ‘ 9atğ‘ğ‘¡ğ‘¥1
andğ‘ 22atğ‘ğ‘¡ğ‘¥4,ğ‘ 9atğ‘ğ‘¡ğ‘¥2andğ‘ 22atğ‘ğ‘¡ğ‘¥3, as well asğ‘ 9atğ‘ğ‘¡ğ‘¥2andğ‘ 22
atğ‘ğ‘¡ğ‘¥4. The context-sensitive report is identical to the one in the
previous approach by courtesy of the context-sensitive refinements.
It is worth emphasizing that, the final gate-lock analysis, in
either the previous methods or Peahen , computes four conditions
of calling contexts to identify the gate locks. However, we argue
that the pre-computed, exhaustive lockset analysis, unaware of any
potential program points that might lead to deadlocks, could miss
many opportunities to avoid futile context-sensitive computation.
Comparatively, our lazy refinements can work efficiently on the
calling contexts around the identified deadlock cycles of interest.
This example briefly illustrates the distinction between the prior
work and Peahen . In Â§ 3, we further introduce the notion of our
lock graph and the varieties of the deadlock cycles, emphasizing
which lock-acquisition information is encoded in the lock graph
cooperatively for the deadlock cyclesâ€™ refinements.
3 PRELIMINARIES
In this section, we elucidate the basic terminologies and notations,
and state the key technical challenges we aim to conquer.
Language and Abstract Domain. Let the symbolV(ğ‘£âˆˆV)
denote pointer variables while O(ğ‘œâˆˆO) indicate memory objects
such as lock objects. A thread ID ğ‘¡(ğ‘¡âˆˆT) represents a thread,
which corresponds to a context-sensitive fork site and, thus, denotes
a unique runtime thread. Following the common practice, we use
the method ğ‘“ğ‘œğ‘Ÿğ‘˜(ğ‘¡,ğ‘“)to uniformly represent the creation of the
threadğ‘¡executing a procedure ğ‘“(ğ‘“âˆˆF), and the method ğ‘—ğ‘œğ‘–ğ‘›(ğ‘¡)
to denote the destruction site of the thread ğ‘¡. Meanwhile, we create
two threads with identical attributes but different thread IDs for a
fork site allocated in a loop. We assume the locks are non-nested
and are not necessarily released in the reverse order in which they
are acquired. The implementation of pointer analysis is discussed
in Â§ 5. Henceforth, without losing generality, we use method ğ‘ğ‘¡(ğ‘£)
to indicate the points-to set of the pointer variable ğ‘£.
Lock Graph. Against the prior context-sensitive lock graph [ 42],
we design a context-insensitive lock graph to characterize the lock-
acquisition orders and to facilitate the cooperation with the lazyrefinements. Notably, an identified cycle in the lock graph exposes
the cyclic lock acquisitions, manifesting a potential deadlock.
Definition 1. A context-insensitive lock graph (LG) is a directed
graphG=(N,E,C), where
â€¢N is a set of nodes, each of which, ğ‘›, corresponds to a lock
objectğ‘œ,ğ‘œâˆˆO. Thus, we also use ğ‘œto denote a node.
â€¢E âŠ† NÃ—N is a set of edges. The direction of an edge
indicates the lock-acquisition order. An edge (ğ‘œ1,ğ‘œ2)means
that a thread holds a lock ğ‘œ1, the source-lock node, and then
acquires another lock ğ‘œ2, the destination-lock node.
â€¢C maps each edge, ğ‘’âˆˆ E, to a tuple(ğ‘¡,ğ‘ 1,ğ‘ 2), the edge
condition, indicating that the thread ğ‘¡holds the source lock
ğ‘œ1atğ‘ 1and then acquires the destination lock ğ‘œ2atğ‘ 2.
There are two noteworthy points. First, the above lock graph is
context-insensitive in the sense that each edge is no longer encoded
with the corresponding call strings. Second, to provide the crucial
lock-acquisition information for lazily refining the deadlock cycles,
for each edge(ğ‘œ1,ğ‘œ2), two types of information are memorized.
Particularly, each edge condition (ğ‘¡,ğ‘ 1,ğ‘ 2)includes (i) the thread
information , the thread ID ğ‘¡, about which thread acquires the locks
ğ‘œ1andğ‘œ2and (ii) the program location information , statements ğ‘ 1
andğ‘ 2, where the acquisitions of locks ğ‘œ1andğ‘œ2take place. We
show later how to leverage this information for refining deadlock
cycles discovered in the lock graph.
Deadlock Cycle. With the lock graph, we define four varieties
of deadlock cycles. In a single-threaded deadlock due to reacquir-
ing a non-reentrant lock, a thread ğ‘¡1acquires a lock ğ‘œ1atğ‘ 1and
proceeds to acquire the same lock ğ‘œ1atğ‘ 2. Thus, it suffices to iden-
tify whether there is a detected cycle with only one edge and the
number of involved nodes equal to one (reacquiring the same lock).
Such cycles are called single-threaded cycles .
In a multi-threaded deadlock, in the case of two threads, a thread
ğ‘¡1first acquires a lock ğ‘œ1atğ‘ 1and waits for another lock ğ‘œ2to
be released at ğ‘ 2while a thread ğ‘¡â€²first acquires the lock ğ‘œ2at
ğ‘ â€²
1and waits for the lock ğ‘œ1to be released at ğ‘ â€²
2. More complex
cases involving more than two threads resemble the above. Thus,
it suffices to identify the cycles with all the acquired edges labeled
with different thread IDs, which we call multi-threaded cycles .
Definition 2. A deadlock cycle discovered in an LG is termed
a single-threaded cycle if the cycle has only one edge and one node.
Meanwhile, a cycle is termed a multi-threaded cycle if the cycle has
multiple edges labeled with distinctive thread IDs.
In addition, for the above example of a multi-threaded cycle,
whether the lock statements ğ‘ 2andğ‘ â€²
2can be concurrently executed
by the threads ğ‘¡1andğ‘¡2should be precisely identified to eschew
any bogus deadlock warnings. Such a multi-threaded cycle is called
a concurrent cycle . Note that a single-thread cycle has no use for
accounting for the concurrency semantics.
Definition 3. A multi-threaded cycle is termed a concurrent
cycle if the related statements referring to the destination-lock
nodes in different threads can be concurrently executed.
Finally, for both single-threaded and multi-threaded cycles, they
should be path-feasible, i.e., the related statements should be path-
reachable simultaneously, which we call path-feasible cycles .Peahen: Fast and Precise Static Deadlock Detection via Context Reduction ESEC/FSE â€™22, November 14â€“18, 2022, Singapore, Singapore
Stage twoStage oneLock Graph ConstructionSingle-, Multi-threaded CyclesConcurrent CyclesPath-FeasibleCyclesProgram IR
Reports
Figure 2: The workflow of Peahen .
Definition 4. A single-threaded or multi-threaded cycle is
termed a path-feasible cycle if the related statements involving
the cycle are path-reachable with the feasible path conditions.
There are three points to note. First, concurrent cycles and path-
feasible cycles are the stronger conditions than single-threaded
cycles or multi-threaded cycles to be genuine deadlocks. Second,
identifying path-feasible cycles is generally more expensive than
identifying concurrent cycles, because the former should validate
the path conditions via constraint solving. Third, to our knowledge,
thus far, no prior deadlock detector has taken the non-nested locks,
statementsâ€™ concurrent execution relations, and statementsâ€™ path-
feasibility into account at once [2, 41, 49].
Problem Statement . After introducing the basic notions, we
next state two technical challenges we aim to address.
(1)How to design an efficient algorithm for constructing the
context-insensitive lock graph and, in the meantime, encod-
ing the lock-acquisition information on related edges.
(2)How to synergize multiple lazy analyzes to incorporate such
edge information into progressively refining the discovered
deadlock cycles to regain high precision.
Before introducing our algorithms in Â§ 4, we give an outline of
our solutions against the above two challenges.
(1)We present an inter-procedural compositional algorithm for
constructing the context-insensitive lock graph. It is sensitive
to threads and encodes the lock-acquisition information on
edges for the coming refinements. (Â§ 4.1)
(2)We present three precise yet lazy refinements to progres-
sively improve the precision of the initially detected deadlock
cycles by successively identifying single-, multi-threaded cy-
cles, concurrent cycles, and path-feasible cycles. (Â§ 4.2)
4PEAHEN IN DETAIL
In this section, we follow the Peahen â€™s workflow as illustrated
in Figure 2 to unravel our algorithms. Peahen has two symbiotic
stages subsuming the context-insensitive lock-graph construction
(Â§ 4.1) and three precise yet lazy deadlock-cycle refinements (Â§ 4.2).
4.1 Context-Insensitive LG Construction
This part delves into our inter-procedural algorithm to construct
the context-insensitive lock graph defined in Â§ 3.
Constructing the context-insensitive lock graph is non-trivial.
First, in the non-nested locks, the loose correlation between the
lock statements and unlock statements across complex, deep calling
contexts makes inter-procedural analysis hard. Many detectors for
Java programs are limited to the nested locks [ 2,49]. Second, despite
not being sensitive to the different call sites, encoding the threadinformation on edges should characterize different threads so as to
distinguish which threads acquire the locks.
To conquer the first challenge, a context-independent function
summary is devised particularly for the decoupling non-nested
locks, which enables compositional analysis and avoids repetitive
functional computation. Second, to distinguish which threads ac-
quire the locks, we create clones of the lock acquisitions in the
related functions that are invoked by different threads, and encode
the related edges with the different thread identification.
Lock Summary. Our idea of a function summary is to capture
the additional locks at the exit relative to the entry that are acquired
and released therein in sequence. While analyzing any of its callers
for identifying the lock acquisitions, the reusable summary can
thus tell which locks can be additionally acquired and which locks
can be released therein in the control-flow orders.
Example 4.1. Figure 3 shows a buggy program. There are two
concurrent threads ğ‘¡1andğ‘¡2, both running the function ğ‘“ğ‘œğ‘œ()and
ğ‘ğ‘ğ‘Ÿ(). Intuitively, a function summary for ğ‘ğ‘ğ‘Ÿ()should indicate
that, at the exit relative to the entry, the lock ğ‘œ1is first released at
ğ‘ 7and, subsequently, the lock ğ‘œ1is acquired at ğ‘ 10. When analyzing
any callers of ğ‘ğ‘ğ‘Ÿ(), we do not need to analyze ğ‘ğ‘ğ‘Ÿ()anymore.
Formally, a summary for a function ğ‘“, called a lock summary,
denoted asğ¿ğ‘†(ğ‘“), is a finite sequence, i.e.,
ğ¿ğ‘†(ğ‘“):=(ğ¿0,Â·Â·Â·,ğ¿ğ‘˜),
each of which is a set ğ¿ğ‘–(ğ‘–âˆˆ[0,ğ‘˜]). All the lock summaries can be
denoted as a set LS, i.e.,âˆ€ğ‘“âˆˆF :ğ¿ğ‘†(ğ‘“)âˆˆLS.
Notably, first, each element ğ¿ğ‘–in the sequence ğ¿ğ‘†(ğ‘“)is a set, be-
cause each statement, ğ‘™ğ‘œğ‘ğ‘˜(ğ‘£), may refer to more than one lock, and
the lock behaviors on different branches are joined flow-sensitively.
In other words, the lock summaries are path-insensitive. Second,
the order between ğ¿ğ‘–âˆ’1andğ¿ğ‘–indicates the control-flow orders,
which matters for analyzing the non-nested locks.
Formally, for each element ğ¿ğ‘–,
ğ¿ğ‘–:=RÃ—OÃ—SÃ—B ,
whereğ¿ğ‘–:={âŸ¨ğ‘Ÿ,ğ‘œ,ğ‘ ,ğ‘âŸ©|ğ‘Ÿâˆˆ{+,âˆ’},ğ‘âˆˆ{0,1}}. First, every â€œplusâ€
tupleâŸ¨+,ğ‘œ,ğ‘ ,ğ‘âŸ©inğ¿ğ‘–denotes that lock ğ‘œmay be acquired via exe-
cuting a statement ğ‘ ,ğ‘™ğ‘œğ‘ğ‘˜(ğ‘£). Whether the lock ğ‘œhas been released
in the current function ğ‘“is indicated by a boolean value ğ‘. Sec-
ond, every â€œminusâ€ tuple âŸ¨âˆ’,ğ‘œ,ğ‘ ,ğ‘âŸ©inğ¿ğ‘–indicates that the lock ğ‘œ
would definitely be released via executing a statement ğ‘ ,ğ‘¢ğ‘›ğ‘™ğ‘œğ‘ğ‘˜(ğ‘£).
Whether the unlock statement ğ‘ has released the lock ğ‘œ, previously
acquired in the current function ğ‘“, is also indicated by ğ‘. Below is
an example for readers to comprehend the domain B. Note that a
lock may be acquired at statement ğ‘ while a lock must be released
atğ‘ , which are resolved by the pointer information. This manner isESEC/FSE â€™22, November 14â€“18, 2022, Singapore, Singapore Yuandao Cai, Chengfeng Ye, Qingkai Shi, and Charles Zhang
1.   void thread1(){// t!2.      fork(ğ‘¡",thread2);3.      foo();4.      join(ğ‘¡");5.  }6.   void bar(){7.      unlock(v!);//o!8.      x++;10.    lock(v!);11.  }12.  void thread2(){ // t"13.     foo();14.  }15.  void foo(){ 16.     lock(v!); 17.     lock(v"); //o"18.     bar();19.     unlock(v");20.     unlock(v!);21.  }(a)(b)(c)IDConditionÂŒ(ğ‘ !",ğ‘ !#)Â(ğ‘ !#,ğ‘ !$)o2o1
o2o1ğ‘¡%ğ‘¡%ğ‘¡!ğ‘¡!CloningÂŒÂ
thread1thread2foobar
Figure 3: Figure (a) is a buggy code using non-nested locks,
(b) is its call graph, and (c) illustrates the cloning process.
identical to the prior work for identifying all the lock acquisitions
in common practice [36, 38, 41].
Example 4.2. Back to Figure 3, the lock summary ğ¿ğ‘†(ğ‘ğ‘ğ‘Ÿ)
is computed as({âŸ¨âˆ’,ğ‘œ1,ğ‘ 7,0âŸ©},{âŸ¨+,ğ‘œ1,ğ‘ 10,0âŸ©}). First, the tuple
âŸ¨âˆ’,ğ‘œ1,ğ‘ 7,0âŸ©indicates that the lock ğ‘œ1must be released at ğ‘ 7, and its
value ofğ‘is 0, implying that the lock ğ‘œ1is acquired from callers,
not therein. Second, the tuple âŸ¨+,ğ‘œ1,ğ‘ 10,0âŸ©shows that the lock ğ‘œ1
may be acquired at ğ‘ 10(in fact in this case, it is definitely acquired)
and has not been released in the function ğ‘ğ‘ğ‘Ÿ()indicated by ğ‘=0.
Compositional Algorithm. At a high level, Algorithm 1 identi-
fies the acquisitions and releases of locks in a bottom-up fashion by
tracking and updating the lock summary for each function. During
the process, the lock graph is incrementally constructed.
The intra-procedural analysis is fairly standard dataflow analysis
that explores every statement of the intra-procedural control-flow
graph (CFG) in the reversed post-order. At callsites, the calleesâ€™
summaries are used to answer which locks are acquired and released
therein. The dataflow result, the lock summary, at the exit of the
function is recorded and other intermediate results are removed.
For handling loops, we devise the join operators to handle merge
nodes in CFG to guarantee termination. Recursive functions are
iteratively recomputed to reach fixed-point results. There are three
key intra-procedural steps for computing ğ¿ğ‘†(ğ‘“)and updating ğ¿ğº.
Handling a lock statement ğ‘ :ğ‘™ğ‘œğ‘ğ‘˜(ğ‘£)(Lines 12 - 16):
â€¢First, the produced acquired edges at ğ‘ should be identified.
Peahen connects an edge(ğ‘œâ€²,ğ‘œ)toğ¿ğºfrom each previously
acquired yet not released lock, i.e., âŸ¨+,ğ‘œâ€²,ğ‘ â€²,ğ‘=0âŸ©inğ¿ğ‘†(ğ‘“),
to each lock that may be acquired at ğ‘ .
â€¢Second, the possible acquired locks at ğ‘ should be tracked
in the summary ğ¿ğ‘†(ğ‘“). Thus, Peahen adds each lock ğ‘œthat
may be acquired at ğ‘™ğ‘œğ‘ğ‘˜(ğ‘£), i.e.,âŸ¨+,ğ‘œ,ğ‘ , 0âŸ©, toğ¿ğ‘†(ğ‘“).
Handling an unlock statement ğ‘ :ğ‘¢ğ‘›ğ‘™ğ‘œğ‘ğ‘˜(ğ‘£)(Lines 17 - 23):
â€¢First, Peahen obtains the definitely released lock ğ‘œby iden-
tifying the variable ğ‘£from the pointer information. If there
is no must information, it skips the next steps.
â€¢Second, whether the lock, previously acquired in ğ‘“, is re-
leased atğ‘ should be tracked in ğ¿ğ‘†(ğ‘“). That is, if there is alockâŸ¨+,ğ‘œâ€²,ğ‘ â€²,0âŸ©inğ¿ğ‘†(ğ‘“)(ğ‘œâ€²=ğ‘œ), that is released at ğ‘ , we
update the tupleâŸ¨+,ğ‘œâ€²,ğ‘ â€²,0âŸ©toâŸ¨+,ğ‘œâ€²,ğ‘ â€²,1âŸ©.
â€¢Third, the summary ğ¿ğ‘†(ğ‘“)should track the released lock at ğ‘ .
That is, ifğ‘ has released the lock ğ‘œpreviously acquired in the
ğ‘“on the last step,âŸ¨âˆ’,ğ‘œ,ğ‘ , 1âŸ©is added to ğ¿ğ‘†(ğ‘“). Otherwise,
âŸ¨âˆ’,ğ‘œ,ğ‘ , 0âŸ©is added toğ¿ğ‘†(ğ‘“).
Example 4.3. We haveğ¿ğ‘†(ğ‘ğ‘ğ‘Ÿ)=({âŸ¨âˆ’,ğ‘œ1,ğ‘ 7,0âŸ©})atğ‘ 7. Atğ‘ 10,
because there is no previously acquired lock ğ‘œ1indicated in ğ¿ğ‘†(ğ‘ğ‘ğ‘Ÿ),
we directly have ğ¿ğ‘†(ğ‘ğ‘ğ‘Ÿ)=({âŸ¨âˆ’,ğ‘œ1,ğ‘ 7,0âŸ©},{âŸ¨+,ğ‘œ1,ğ‘ 10,0âŸ©}). When
analyzingğ‘“ğ‘œğ‘œ()atğ‘ 16, we haveğ¿ğ‘†(ğ‘“ğ‘œğ‘œ)=({âŸ¨+,ğ‘œ1,ğ‘ 16,0âŸ©}). Next,
atğ‘ 17, we haveğ¿ğ‘†(ğ‘“ğ‘œğ‘œ)=({âŸ¨+,ğ‘œ1,ğ‘ 16,0âŸ©},{âŸ¨+,ğ‘œ2,ğ‘ 17,0âŸ©}). There
is a previously acquired lock ğ‘œ1inğ¿ğ‘†(ğ‘“ğ‘œğ‘œ), so we need to add
an edgeğ‘’:(ğ‘œ1,ğ‘œ2),â¶, toğ¿ğº, which is initially encoded with ğ‘:
(ğ‘ 16,ğ‘ 17).
Handling a call site ğ‘ :ğ‘¦=ğ‘ğ‘ğ‘™ğ‘™ğ‘“ğ‘œğ‘œ(ğ‘¥)(Lines 24 - 32)
â€¢First, the inter-procedural acquired edges produced should be
identified. It connects an edge (ğ‘œâ€²â€²,ğ‘œâ€²)inğ¿ğºfrom each cur-
rently acquired yet not released lock, âŸ¨+,ğ‘œâ€²â€²,ğ‘ â€²â€²,0âŸ©inğ¿ğ‘†(ğ‘“),
to each acquired lock, âŸ¨ğ‘Ÿâ€²,ğ‘œâ€²,ğ‘ â€²,ğ‘âŸ©inğ¿ğ‘†(ğ‘“ğ‘œğ‘œ).
â€¢Second, the summary ğ¿ğ‘†(ğ‘“)should track whether some
locks would be released in ğ‘“ğ‘œğ‘œ. Therefore, it updates the
valueğ‘of the locks, acquired in ğ‘“but released in ğ‘“ğ‘œğ‘œ, from
0 to 1. Finally, it updates ğ¿ğ‘†(ğ‘“)by including the calleeâ€™s
ğ¿ğ‘†(ğ‘“ğ‘œğ‘œ)in the control-flow order.
Other kinds of statements do not affect the acquisitions and
releases of locks and, thus, are not analyzed.
Example 4.4. In Figure 3, recall that the computed ğ¿ğ‘†(ğ‘“ğ‘œğ‘œ)
atğ‘ 17is({âŸ¨+,ğ‘œ1,ğ‘ 16,0âŸ©},{âŸ¨+,ğ‘œ2,ğ‘ 17,0âŸ©})andğ¿ğ‘†(ğ‘ğ‘ğ‘Ÿ)is computed
as({âŸ¨âˆ’,ğ‘œ1,ğ‘ 7,0âŸ©},{âŸ¨+,ğ‘œ1,ğ‘ 10,0âŸ©}). When analyzing the callsite
ğ‘ğ‘ğ‘Ÿ()atğ‘ 18, the analysis enumerates the ğ¿ğ‘†(ğ‘ğ‘ğ‘Ÿ)to check each
tuple. When it is a released lock like âŸ¨âˆ’,ğ‘œ1,ğ‘ 7,0âŸ©and the lock ğ‘œ1
also exists in ğ¿ğ‘†(ğ‘“ğ‘œğ‘œ), the analysis sets its boolean value to 1,
i.e.,âŸ¨+,ğ‘œ1,ğ‘ 16,0âŸ©becomesâŸ¨+,ğ‘œ1,ğ‘ 16,1âŸ©to indicate that the lock
ğ‘œ1has been released in ğ‘ğ‘ğ‘Ÿ(). When it is an acquired lock like
âŸ¨+,ğ‘œ1,ğ‘ 10,0âŸ©, the analysis adds an edge to the lock graph from the
acquired but unreleased lock in the current ğ¿ğ‘†(ğ‘“ğ‘œğ‘œ), i.e., from
ğ‘œ2inğ¿ğ‘†(ğ‘“ğ‘œğ‘œ)toğ‘œ1inğ¿ğ‘†(ğ‘ğ‘ğ‘Ÿ). We thus succeed in identifying
an inter-procedural acquired edge (ğ‘œ2,ğ‘œ1)(â·). Finally, we add
the summary ğ¿ğ‘†(ğ‘ğ‘ğ‘Ÿ)toğ¿ğ‘†(ğ‘“ğ‘œğ‘œ), soğ¿ğ‘†(ğ‘“ğ‘œğ‘œ)atğ‘ 18becomes
({âŸ¨+,ğ‘œ1,ğ‘ 16,1âŸ©},{âŸ¨+,ğ‘œ2,ğ‘ 17,0âŸ©},{âŸ¨âˆ’,ğ‘œ1,ğ‘ 7,1âŸ©},{âŸ¨+,ğ‘œ1,ğ‘ 10,0âŸ©}).
Note that locks ğ‘œ2acquired at ğ‘ 17andğ‘œ1acquired at ğ‘ 10would be
released atğ‘ 19andğ‘ 20, respectively.
Selective Cloning. After analyzing each function ğ‘“, if the func-
tionğ‘“is invoked by different threads and is a root function, Peahen
clones the acquired edges created in ğ‘“and distinguishes which
threads acquire the locks by encoding the thread identification on
edge conditions. (Lines 7 - 9) For example, in Figure 3, the two
threadsğ‘¡1andğ‘¡2both run the function ğ‘“ğ‘œğ‘œ()that callsğ‘ğ‘ğ‘Ÿ(), and
ğ‘“ğ‘œğ‘œ()is the root shared function. We only need to clone the edges
in the root function like ğ‘“ğ‘œğ‘œ()to avoid repeated edges, because the
edges ofğ‘ğ‘ğ‘Ÿ()are included in the ones of ğ‘“ğ‘œğ‘œ(). For the non-sharing
functions, we encode the edges with a unique thread ID.
Example 4.5. Following the bottom-up order of the call graph
in Figure 3(b), our algorithm first analyzes the ğ‘ğ‘ğ‘Ÿ()as well asğ‘“ğ‘œğ‘œ()Peahen: Fast and Precise Static Deadlock Detection via Context Reduction ESEC/FSE â€™22, November 14â€“18, 2022, Singapore, Singapore
Algorithm 1: Context-Insensitive LG Construction
1ğ¶ğºâ†â†ªconstruct a call graph for a multi-threaded program ğ‘ƒ;
2foreach unvisitedğ‘“in reverse topological order of CG do
3(âˆ…)â† â†ªinitializeğ¿ğ‘†(ğ‘“);
4 foreachğ‘ in reverse post-order of CFG of ğ‘“do
5 HandleEachInstAndPropagate (ğ‘ );
6 Addğ¿ğ‘†(ğ‘“)at the exit program point of ğ‘“toLS;
7 foreachğ‘¡, the threadğ‘¡invokingğ‘“,ğ‘¡âˆˆTdo
8 foreachğ‘’, the edgeğ‘’created inğ‘“do
9 (cloneğ‘’) update its condition ğ‘with thread ID ğ‘¡;
10return A context-insensitive lock graph ğ¿ğº;
11Procedure HandleEachInstAndPropagate( ğ‘ ):
12 ifğ‘ :ğ‘™ğ‘œğ‘ğ‘˜(ğ‘£)then
13 foreachâŸ¨+,ğ‘œâ€²,ğ‘ â€²,ğ‘=0âŸ©âˆˆğ¿ğ‘–,ğ‘–âˆˆ[0,|ğ¿ğ‘†(ğ‘“)|)do
14 foreachğ‘œâˆˆğ‘ğ‘¡(ğ‘£)do
15 Add an edge ğ‘’:(ğ‘œâ€²,ğ‘œ)withğ‘:(ğ‘ â€²,ğ‘ ) toğ¿ğº;
16 Add{âŸ¨+,ğ‘œ,ğ‘ , 0âŸ©|ğ‘œâˆˆğ‘ğ‘¡(ğ‘£)}toğ¿ğ‘†(ğ‘“);
17 else ifğ‘ :ğ‘¢ğ‘›ğ‘™ğ‘œğ‘ğ‘˜(ğ‘£)then
18ğ‘œâ†â†ªğ‘ğ‘¡(ğ‘£);
19 ifğ‘œ=ğ‘œâ€²,âŸ¨+,ğ‘œâ€²,ğ‘ â€²,ğ‘â€²=0âŸ©âˆˆğ¿ğ‘–,ğ‘–âˆˆ[0,|ğ¿ğ‘†(ğ‘“)|)then
20âŸ¨+,ğ‘œâ€²,ğ‘ â€²,1âŸ©â† â†ªâŸ¨+,ğ‘œâ€²,ğ‘ â€²,0âŸ©;
21 Add{âŸ¨âˆ’,ğ‘œ,ğ‘ , 1âŸ©}toğ¿ğ‘†(ğ‘“);
22 else
23 Add{âŸ¨âˆ’,ğ‘œ,ğ‘ , 0âŸ©}toğ¿ğ‘†(ğ‘“);
24 else ifğ‘ :ğ‘¦=callğ‘“ğ‘œğ‘œ(ğ‘¥)then
25 Retrieveğ¿ğ‘†(ğ‘“ğ‘œğ‘œ):=(ğ¿â€²
0,...)fromLS;
26 foreachâŸ¨+,ğ‘œâ€²â€²,ğ‘ â€²â€²,0âŸ©âˆˆğ¿ğ‘–,ğ‘–âˆˆ[0,|ğ¿ğ‘†(ğ‘“)|)do
27 foreachâŸ¨ğ‘Ÿâ€²,ğ‘œâ€²,ğ‘ â€²,ğ‘âŸ©âˆˆğ¿â€²
ğ‘—,ğ‘—âˆˆ[0,|ğ¿ğ‘†(ğ‘“ğ‘œğ‘œ)|)do
28 ifğ‘Ÿâ€²=+then
29 Add edgeğ‘’:(ğ‘œâ€²â€²,ğ‘œâ€²),ğ‘:(ğ‘ â€²â€²,ğ‘ â€²)toğ¿ğº;
30 else ifğ‘Ÿâ€²=âˆ’âˆ§ğ‘œâ€²â€²=ğ‘œâ€²then
31 âŸ¨+,ğ‘œâ€²â€²,ğ‘ â€²â€²,1âŸ©â† â†ªâŸ¨+,ğ‘œâ€²â€²,ğ‘ â€²â€²,0âŸ©;
32 Addğ¿ğ‘†(ğ‘“ğ‘œğ‘œ)toğ¿ğ‘†(ğ‘“);
and updates the lock graph with two corresponding acquired edges,
(ğ‘œ1,ğ‘œ2)and(ğ‘œ2,ğ‘œ1). Then, since the ğ‘“ğ‘œğ‘œ()is the root function
invoked by two different threads, ğ‘¡1andğ‘¡2, the analysis clones
the two edges with two different thread identifiers ğ‘¡1andğ‘¡2to
distinguish which threads acquire these locks. Armed with the lock
graph, Peahen can start by detecting the deadlock cycle.
Remark. In Algorithm 1, a key step that is omitted to reach
context-insensitive is aggressively cloning the edges of lock ac-
quisitions in a function on all its call sites and labeling the edges
with the respective calling contexts. Instead, we selectively clone
for a function invoked by different threads and encode the lock-
acquisition information on each edge. This is because Peahen is
only concerned with the cyclic lock acquisitions in each thread.
This way, the lazy refinement can incorporate such information
into lazily refining deadlock cycles around a few calling contexts
of interest, thereby bypassing premature calling context explosion.
Summary. The effectiveness of our LG construction is two-
fold. First, it is compositional, efficiently analyzing each functionindependently of its callers and bypassing the enumeration of all
the calling contexts. The context-insensitive lock graph is smaller
yet characterizes threads, which is judiciously encoded with the
essential lock-acquisition information for lazy refinements. Second,
the smaller graph empowers fast cycle detection and less memory
space to store. In the subsequent phase, our refinements can focus
on the computation effort around the fewer calling contexts related
to the context-insensitive cycles to regain high precision.
4.2 Collaborative Lazy Deadlock Refinements
Once the lock graph is in hand, Peahen conducts a cycle-detection
algorithm [ 31] to identify an initial over-approximation set of dead-
lock cycles. Then, it performs the following three analyses that
approximate the different necessary conditions of being deadlocks,
dedicatedly refining these initial cycles. Readers can review the
cycle definitions in Â§ 3.
(1) Single-, Multi-threaded Cycle Computation (Â§ 4.2.1)
(2) Concurrent Cycle Computation (Â§ 4.2.2)
(3) Path-Feasible Cycle Computation (Â§ 4.2.3)
Note that every stage exploits the edge information on each
cycle, refines the cycles from the preceding one in a lazy fashion,
and avoids any futile computation to acyclic edges.
4.2.1 Single-, Multi-threaded Cycle Computation .At this
stage, the set of the initial cycles, denoted as C(â—¦ âˆˆC), is re-
fined as the set C1, the union of single-threaded cycles C1
1and
multi-threaded cycles C1
2. Let the function ğ‘‡(â—¦)return the set of all
thread IDs on edges in a cycle â—¦,ğ‘(â—¦)return the set of all nodes
involved in a cycle â—¦, andğ¸(â—¦)return all the edges in a cycle â—¦.
C1
1={â—¦|âˆƒâ—¦âˆˆ C:|ğ¸(â—¦)|=1âˆ§|ğ‘(â—¦)|=1}
C1
2={â—¦|âˆƒâ—¦âˆˆ C,âˆ€ğ‘¡1,ğ‘¡2âˆˆğ‘‡(â—¦):ğ‘¡1â‰ ğ‘¡2}
C1=C1
1âˆªC1
2
Indeed, owing to the encoded thread information on edges fore-
seeingly by the LG construction, this first refinement is simple by
efficiently checking the edge conditions (and the number of nodes).
4.2.2 Concurrent Cycle Computation .At this stage, the multi-
threaded cycles, C1
2, are refined by identifying and retaining con-
current cycles, which, together with C1
1, are denoted as C2.
We perform non-concurrency analysis to reveal, given a multi-
thread cycle, whether the statements that refer to the destination-
lock nodes can be executed concurrently, arising from the fork/join
and lock/unlock synchronizations. At a high level, our basic idea
is to lazily collect the thread IDs referred by the join statements
and the unreleased locks referred by the lock statements before an
interesting statement ğ‘ under the related calling contexts.
Specifically, each join statement, ğ‘—ğ‘œğ‘–ğ‘›(ğ‘¡), witnesses the destruc-
tion of thread ğ‘¡beforeğ‘ , and, thus, any other statements in the
threadğ‘¡cannot be concurrent with ğ‘ . Similarly, an unreleased lock
ğ‘œreferred by a lock statement, ğ‘™ğ‘œğ‘ğ‘˜(ğ‘£), reveals that the lock ğ‘œpro-
tects the statement ğ‘ . Therefore, any other statements also protected
by the common lock ğ‘œcannot be concurrent with ğ‘ .
Peahen performs a backward search from any interesting state-
mentğ‘ , following the inter-procedural context-sensitive control-
flow graph to collect the set of joined thread IDs,ğ½ğ‘‡(ğ‘ ,ğ‘ğ‘¡ğ‘¥), and theESEC/FSE â€™22, November 14â€“18, 2022, Singapore, Singapore Yuandao Cai, Chengfeng Ye, Qingkai Shi, and Charles Zhang
13.  void thread2(){ // t214.     lock(ğ‘£!);15.     lock(ğ‘£");16.     if (Â¬ğœƒ!){17.lock(ğ‘£#);18.        x++;19.        unlock(ğ‘£#);20.}21.unlock(ğ‘£");22.     unlock(ğ‘£!);23.  }1.void thread1(){ // t12.      fork(ğ‘¡#, thread2);3.      lock(ğ‘£!); //o14.      lock(ğ‘£#); //o25.      if (ğœƒ!){6.         lock(ğ‘£"); //o37.         x++;8.         unlock(ğ‘£");}9.      unlock(ğ‘£#);10.    unlock(ğ‘£!);11.join(ğ‘¡#);12.  }IDConditionÂŒ(ğ‘¡!,ğ‘ ",ğ‘ #)Â(ğ‘¡$,ğ‘ !%,ğ‘ !&)(a)(b)
ÂŒÂo2o3
Figure 4: An example for the three lazy refinements.
set of unreleased locks,ğ‘ˆğ¿(ğ‘ ,ğ‘ğ‘¡ğ‘¥), reachable from the related call-
ing contexts ğ‘ğ‘¡ğ‘¥. The search and collection processes themselves
are similar to the previous lockset analysis [ 38,48,49], but are
performed lazily. This is because we are aware of the related state-
ments, where the destination locks are acquired, owing to the edge
information. Formally, let the ğ·(â—¦)return all the lock statements
that refer to the d estination locks in a cycle â—¦.
C2
1={â—¦|âˆƒğ‘ 1âˆˆğ·(â—¦),âˆ€ğ‘ğ‘¡ğ‘¥ 1,âˆƒğ‘¡1âˆˆğ½ğ‘‡(ğ‘ 1,ğ‘ğ‘¡ğ‘¥ 1):ğ‘¡1âˆˆğ‘‡(â—¦)}
C2
2={â—¦|âˆ€ğ‘ 1,ğ‘ 2âˆˆğ·(â—¦),âˆ€ğ‘ğ‘¡ğ‘¥ 1,ğ‘ğ‘¡ğ‘¥ 2:ğ‘ˆğ¿(ğ‘ 1,ğ‘ğ‘¡ğ‘¥ 1)âˆ©ğ‘ˆğ¿(ğ‘ 2,ğ‘ğ‘¡ğ‘¥ 2)â‰ âˆ…}
C2={â—¦|â—¦âˆˆ C1
2âˆ§â—¦âˆ‰C2
1âˆ§â—¦âˆ‰C2
2}âˆªC1
1
SetC2
1indicates that at least a thread ğ‘¡1involved in a multi-
threaded cycle is destroyed. The set C2
2indicates that at least two
statements ğ‘ 1andğ‘ 2(refer to the destination locks) involved in
a multi-threaded cycle are guarded by a common lock. A multi-
threaded cycle with either of these circumstances is then removed.
4.2.3 Path-Feasible Cycle Computation .Finally, Peahen per-
forms path validation to identify path-feasible deadlock cycles. Our
basic idea is to validate whether the related statements involved in
a cycle are path-feasible simultaneously. Let P(ğ‘ )(ğ‘âˆˆP) be all the
intra-procedural paths leading to a statement ğ‘ andÎ¦(ğ‘)indicate
the path conditions on ğ‘. Let function ğ‘†(â—¦)return the encoded lock
statements, referring to the source lock and the destination lock,
on acquired edges in an interesting cycle â—¦.
C3={â—¦|âˆƒâ—¦âˆˆ C2,âˆ€ğ‘ âˆˆğ‘†(â—¦),âˆƒğ‘âˆˆP(ğ‘ ):Î¦(ğ‘)=ğ‘‡ğ‘Ÿğ‘¢ğ‘’}
While validating path feasibility is expensive in general due
to the need for SMT solving [ 65], we observe that, for deadlock
detection, it can be efficient because of the following observations.
First, the number of deadlock cycles to be proved path-feasible
is much fewer, owing to the successive sieving by the previous
two stages. Second, we observe that expensive solving for the full
program paths is not necessary for practical deadlock detection, so
Peahen only solves the intra-procedural paths for high efficiency
(also discussed in the evaluation Â§ 5).
Example 4.6. Figure 4 shows an initially detected cycle with
edgesâ¶andâ·, because there is a reversed order between the locks
ğ‘œ2andğ‘œ3. It is a multi-threaded cycle since it is induced by different
threadsğ‘¡1andğ‘¡2through analyzing the conditions on edges. In non-
concurrency analysis, Peahen starts to collect the join statements
before statements ğ‘ 6andğ‘ 17to find the joined threads, which areempty. Then, Peahen collects the common unreleased lock before
statementsğ‘ 6andğ‘ 17that isğ‘œ1. Thus, the cycle is not a concurrent
cycle. It is also not a path-feasible cycle due to the contradicted
path conditions between ğ‘ 6andğ‘ 17. However, we do not solve the
constraints, thanks to the preceding non-concurrency analysis.
Summary. Our refinements confer two salient advantages to our
deadlock detection. First, our refinements are lazy, which are aware
of the interesting calling contexts around the initially detected
cycles and thus avoid performing pre-computed whole-program
context-sensitive computation. Note that it is the result of the syn-
ergy between the LG construction and the lazy refinements that en-
sures the effectiveness of Peahen . Second, our refinements are pre-
cise, regaining the high precision for the initial context-insensitive
deadlock cycles. More importantly, as the refining deadlock cycles
become more and more precise, fewer cycles lead to less lazy com-
putation. Previous work [ 16,42,43,49,62] does not consider the
path-feasible deadlocks, which is taken into account by Peahen .
5 EVALUATION
To evaluate Peahen , we consider the following research questions:
Q1How efficient and effective is Peahen compared to the pre-
vious static deadlock detectors? (Â§ 5.1)
Q2CanPeahen scale up to million-line systems? Can Peahen
detect genuine deadlocks? (Â§ 5.2)
All the experiments are performed on a computer with two 20
core Intel (R) Xeon (R) CPU E5-2698 v4 @ 2.20GHz and 256GB
physical memory running Ubuntu-16.04.
Implementation. Peahen is implemented for C/C++ programs
on top of the LLVM compiler infrastructure and the Z3 SMT solver.
For precision, we implemented on-demand field-, flow-, and context-
sensitive pointer analysis [ 55]. Following many well-known bug
finding tools [ 34,48,55,57,64], our implementation is soundy [ 45],
which means that our tool is mostly sound, aside from a few well-
identified reasonable unsound choices for achieving higher pre-
cision. Particularly, there are two sources of the unsoundness in
our implementations. First, our pointer analysis shares the same
unsoundness sources as the one we use. For instance, it does not
correctly handle the pointer arithmetic, array accesses, containers,
and so on. Second, our lock graph construction ignores the locks
that are inside blocks of the assembly code as the prior deadlock
detectors [2, 41, 49].
5.1 Q1: Comparing with Previous Techniques
This experiment aims to show that the prior context-sensitive ap-
proach is unscalable while the context-insensitive one is imprecise.
Comparatively, Peahen provides a better sweet spot in the trade-off
between precision and performance.
We compared Peahen against two recent and relevant tools for
the non-nested, non-reentrant locks: CBMC [42] and Infer .
â€¢CBMC is context-sensitive, constructing a context-sensitive
lock graph through a pre-computed context-sensitive lockset
analysis and using the results of the lockset analysis again
to refine the deadlock cycles discovered in the lock graph.Peahen: Fast and Precise Static Deadlock Detection via Context Reduction ESEC/FSE â€™22, November 14â€“18, 2022, Singapore, Singapore
PeahenCBMC10-310-1Time(logscale)102
Subject ID (order by time of CBMC)30PeahenInfer10110-210-3Time(logscale)Subject ID (order by time of Infer)Peahen-PeahenCBMC10-3Subject ID (order by time of CBMC)Time(logscale)10-110130Peahen--Memory(logscale)Peahen-PeahenCBMCSubject ID (order by memory of CBMC)10-310-110124Peahen--PeahenInfer10-110-2101Memory(logscale)Subject ID (order by memory of Infer)PeahenCBMCMemory(logscale)10210-1Subject ID (order by memory of CBMC)10-324(a)(c)(e)
(b)(d)(f)
Figure 5: (a)(b)(c)(d) shows the time (min) and memory (GB) comparison in entire deadlock detection among Peahen ,CBMC ,
andInfer . (e)(f) shows the time (min) and memory (GB) comparison in LG construction among Peahen ,CBMC , andPeahenâˆ’.
â€¢Infer is an abstract-interpretation-based context-insensitive
deadlock detector, reasoning locks by syntactic expressions.
We use this version [22, 26] for supporting Pthread APIs.
Benchmark. To reduce the subjectivity, the chosen benchmarks
are collected from CBMC [41]. The benchmarks consist of 1005
diverse programs from the Debian GNU/Linux distribution (e.g.,
Fuse,Glfw ,Libmicrohttpd ), ranging in size from a few KLoC to 52
KLoC with a total of 11.3 MLOC . Additionally, they intentionally
planted eight programs with deadlocks [42].
Following their evaluation [ 42], memory and time are restricted
to 24 GB and 30 minutes per program, respectively.
5.1.1 Scalability. We check whether each tool can successfully
analyze all programs within the time and memory budget. First,
CBMC spent about 16297.27 minutes (around 272 hours) with
526 programs out of time and 78 programs out of memory. Com-
paratively, Peahen succeeded in checking within 119.36 min-
utes (around 2 hours), achieving 136 Ã—speed up. Second, Infer
finished checking all these programs within 73.11 minutes (around
1.2 hours), which is slightly faster than Peahen .
In detail, shown in Figure 5 (a)(b), for the programs analyzed by
CBMC with more than one minute and one GB, Peahen signifi-
cantly outperforms CBMC . It demonstrates our approach is efficient
for large programs. Shown in Figure 5 (c)(d), compared to Infer ,
Peahen is also competitive, with many projects finished at slightly
more memory and time cost. This cost is reasonable since Peahen
is more precise with context-sensitivity, as shown below.
5.1.2 Precision. The experimental results show that Infer ,
CBMC , and Peahen report 301, 113, and 30 issues, respectively.
To sum up, Peahen can reduce around 73.45% and 90.0% of false
positives compared to CBMC andInfer , respectively.In detail, we manually checked each generated report and made
three conclusions. First, we found that the bugs flagged by Peahen
are also detected by CBMC andInfer . Second, CBMC andInfer
generate excessive spurious bugs. Specifically, after checking the
bugs generated by CBMC andInfer that are not detected by Pea-
hen, we found that they are false positives. For 30 bugs generated
byPeahen , only 8 of them are deemed to be false after manual
confirmation. Third, Peahen can detect the eight intentionally-
introduced deadlocks, which suggests that the precision of Peahen
is achieved without sacrificing the recall.
Peahen is more precise owing to two reasons. First, Peahen
conducts more precise refinements against Infer andCBMC . For
example, Figure 6 shows a false positive in PDSH detected by Infer
andCBMC , where the cyclic lock acquisitions between the locks ğ‘ ğ‘Ÿğ‘
andğ‘‘ğ‘ ğ‘¡are on the contradictory paths and cannot be simultaneously
path-feasible. Hence, when multiple threads execute the function
ğ‘ğ‘ğ‘¢ğ‘“ _ğ‘ğ‘œğ‘ğ‘¦ , a deadlock could not occur. Second, in practice, the
lock objects could be derived from structures as fields, passed in
as parameters, and reassigned at different locations of control flow.
The pointer analysis we implemented is field-, flow- and context-
sensitive, which can aid in preventing certain false positives.
5.1.3 Effectiveness on Two Collaborative Stages. Compared
toCBMC , we study the effectiveness of Peahen to reach context-
sensitive through two collaborative stages - the context-insensitive
lock graph construction and the precise yet lazy refinements.
Lock Graph Construction. First, we compare each programâ€™s
time and memory cost to construct the lock graph. To evaluate
our context-reduction technique and exclude the side effects from
different implementations of pointer analyses, we implemented
Peahenâˆ’, which constructs a context-sensitive lock graph byESEC/FSE â€™22, November 14â€“18, 2022, Singapore, Singapore Yuandao Cai, Chengfeng Ye, Qingkai Shi, and Charles Zhang
1012intcbuf_copy(cbuf_tsrc, cbuf_tdst, intlen, int*ndropped) { 1034// Lock cbufsin order of lowest memory address to prevent deadlock.1035if(src< dst) {1036cbuf_mutex_lock(src); 1037cbuf_mutex_lock(dst); 1038} else { 1039cbuf_mutex_lock(dst); 1040cbuf_mutex_lock(src); 1041}1057}
Figure 6: A false positive detected by other tools.
cloning the acquired edges for all the calling contexts during our
compositional algorithm (Algorithm 1).
The results are illustrated in Figure 5 (e)(f), with the programs
running out of time during the pointer analysis of CBMC removed.
Figure 5 (e) shows that the proposed algorithm in Peahen is consis-
tently faster than Peahenâˆ’andCBMC , achieving about 230 Ã—and
231Ã—speed-up on average, respectively. For this reason, Peahen
does not enumerate any exponentially possible calling contexts
spanning across the lock acquisitions.
Figure 5 (f) illustrates that, dealing with the programs analyzed
byCBMC andPeahenâˆ’with more than one GB, Peahen signifi-
cantly outperforms Peahenâˆ’andCBMC in terms of memory cost,
saving about 23 GB memory at most. We manually checked these
programs and found they intensively use locks so that a context-
sensitive LG is expensive to construct.
Finally, we studied the number of acquired edges on the buggy
programs. This reveals that our context-insensitive lock graph can
merge about 95.5% edges on average that would otherwise be identi-
fied and added to the context-sensitive ones of Peahenâˆ’andCBMC .
Moreover, the results also reveal that the cycle-detection algorithm
ofPeahen working on the context-insensitive lock graph achieves
about 46Ã—speed-up on average.
Lazy Refinements. Next, we study the effectiveness of the re-
finements. It is disclosed that our refinements can prune away 43
deadlock cycles in about 65 minutes, reducing about 58.9% of false
warnings. Three refinements can progressively prune away about
35%, 40%, and 25% false warnings, respectively.
Answer to Q1: Armed with our context-reduction approach,
Peahen achieves higher precision without sacrificing good
scalability versus the state-of-the-art approaches.
5.2 Q2: Checking Large-Scale Projects
We evaluate the effectiveness of Peahen for large programs. We set
a high bar and selected four additional real-world projects based on
two principles. First, the project should be million-line and widely-
used in practice. Second, the projects should be using mutex locks
intensively. As a result, the projects we chose comprise four real-life
open-source C/C++ projects shown in Table 1, ranging in size from
around 1.75 MLoC to nearly 9 MLoC.
5.2.1 Scalability and Precision .For evaluating the scalability,
we checked how much time and memory is spent conducting the
entire deadlock detection. The results are shown in Table 1, sug-
gesting that Peahen succeeded in checking Firefox (with nearly 9
MLoC) in around two hours and within 50 of GB memory.IDProject
NameSize
(KLoC)Deadlock Detection Bug Report
Memory (GB) Time (min) #All #TP
1 MariaDB 1,753 27.97 34.85 11 8
2 FFmpeg 2,065 37.41 39.75 5 4
3 MySQL 3,185 31.17 34.17 3 2
4 Firefox 8,910 45.90 120.30 4 2
Table 1: Q2: Experimental results on large programs.
For precision, we manually checked each error generated by
Peahen and then identified its false positive rate. The results show
thatPeahen generated 23 deadlock warnings with 7 false positives,
resulting in a 30.43% false-positive rate. This process may be sub-
jective and pose threats to the validity of its precision. Therefore,
we also sought the confirmation from the original developers and
sent the patches to ease their work. At the time of writing, seven
of the bugs have been confirmed by them.
Thanks to its precise refinements, Peahen can prune away nu-
merous false warnings. For false positives, a portion of them is
induced by the imprecise pointer alias relations (e.g., infeasible
paths, function pointers), inducing the imprecise lock acquisitions.
Another source comes from ignoring other uninterpreted synchro-
nizations (e.g., waits/notifies, ad-hoc synchronizations), inducing
the imprecise concurrent execution relations. To overcome these
limitations, Peahen needs to adopt more precise pointer analysis
and characterize more synchronizations.
5.2.2 Confirmed Real-World Deadlocks .We have been using
Peahen to scan open-source projects extensively and continuously.
At the time of writing, there were already more than eighty con-
firmed deadlock bugs from dozens of the famous systems [ 50],
despite many of which are consistently and intensively undergoing
bug checking. Most of the bugs have been fixed in the recent release
versions of the software, making them more reliable and robust.
Next, we study two real deadlocks in Figure 7.
A deadlock is detected in FreeIPA , the upstream project for Red
Hat Identify Management. If we take a closer look, the bug pattern is
quite simple, where the statement at Line 2199 should be an unlock
statement. However, this bug has been missed by the developers,
users as well as dynamic testing and has existed for about eight
months. The developers were very concerned with this bug, noting
that â€œThis code is used quite frequently by FreeIPA. Why have we
not seen a problem with it until now.â€ It demonstrates that static
analysis matters, and, of course, scaling up to this large program is
also critical, which is addressed in this paper.
A deadlock is uncovered in AML , a memory management library
for high-performance computing applications. A deadlock occurs
when a thread ğ‘¡1reaches Line 93 while another thread ğ‘¡2reaches
Line 264, relating to the path conditions of lock statements. With
the path-sensitive analysis, Peahen can precisely uncover it.
Answer to Q2: Peahen is efficient for million-line systems,
flagging deadlocks at a low false positive rate. In terms of
real-world impacts, it has found many confirmed deadlocks.Peahen: Fast and Precise Static Deadlock Detection via Context Reduction ESEC/FSE â€™22, November 14â€“18, 2022, Singapore, Singapore
82intaml_active_sched_num_tasks(structaml_sched*sched){      91          if(Condition1){92    pthread_mutex_lock(&s->workq_lock);93 pthread_mutex_lock(&s->doneq_lock);105  }106}253 structaml_task*aml_active_sched_wa(structaml_sched_data*data){258 pthread_mutex_lock(&(sched->doneq_lock));  263if(Condition2){264pthread_mutex_lock(&(sched->workq_lock)); 270}272}2149staticvoidcheck_replicas_are_done_cleaning(cleanruv_data*data) { 2193        if(!slapi_is_shutting_down()) 2197 pthread_mutex_lock(&notify_lock); . . .          2199          pthread_mutex_lock(&notify_lock); 2208}
Figure 7: Real deadlocks in FreeIPA and AML, respectively.
6 RELATED WORK
Ensuring the reliability of concurrent programs is an important
problem [ 9,24,27,43,51,52,63]. As integral parts, deadlock de-
tection, prevention [ 20,29,30,35,60], and fixing [ 3] are diverse
directions, among which we focus on surveying detection.
6.1 Static Deadlock Detection
Detectors for Java code typically rely on balanced locking. This
work [ 62] targets Java libraries and constructs a global context-
sensitive lock graph. In general, their tool can report the false
positives due to the non-concurrency and path-infeasible dead-
locks. JADE [49] is object-sensitive, which breaks down the prob-
lem into several context-sensitive sub-tasks, including reachability,
may-happen-in-parallel, non-reentrant, and non-guarded analyses.
JADE focuses on two-thread deadlocks and could report spurious
path-infeasible deadlocks. Brotherston et al . [2] propose a context-
insensitive incremental detector for Android Java, detecting dead-
locks in an abstract-interpretation style and analyzing code changes
with respect to the unchanged portions. Their tool may induce ex-
cessive false positives without context-insensitive analyses.
Detectors for C code do not expect balanced locking, which
significantly complicates static deadlock detection [ 14,36,37,56].
LockLint [12] is not fully-automatic such that it requires annota-
tions from users to specify the lock acquisition orders. RacerX [16]
reaches context-sensitive by caching lockset results at the func-
tion level, which may lead to ill scalability in large systems. In
addition, compared to Peahen ,RacerX uses the syntactic and type
information to reason pointer aliasing, require annotations, and em-
ploys some unsound heuristics to reduce false positives. Kroening
et al. [42] proposes a detector for Pthread APIs, which conducts the
context- and thread-sensitive lockset analysis for the lock-graph
construction and the cycle refinements. However, as mentioned be-
fore, context-sensitive exhaustive lockset analysis and lock-graph
construction are expensive.
Some work [ 47] targets for the programs using data-centric
synchronizations [ 15,21] and requires the manual annotations to
identify the ordering between atomic-sets.6.2 Dynamic Deadlock Detection
Many testing approaches and model checkers can manifest dead-
locks [ 10,11,19,28,59,61]. We focus on investigating recent predic-
tive analysis, which has been applied to detect a variety of concur-
rency bugs such as data races [ 25,53,58] and deadlocks. Specifically,
deadlock prediction can be categorized into two classes in terms of
soundness (i.e., the absence of false positives).
Unsound deadlock prediction may induce false positives due to,
for instance, ignoring happens-before relations. Thus, they com-
monly need to be integrated with other techniques via scheduling a
real deadlock [ 32,34,54] or identifying and solving execution con-
straints [ 6,17]. At the core of the prediction, they construct a lock
graph by tracking the lock-acquisition history from just a single
execution, and identify the cycles. To relax the deadlock-prediction
overhead, many seminal approaches [ 4,5,66] have been proposed.
The latest one, AirLock [5], speeds up the online cycle discovery
via first finding â€œsimple cyclesâ€ without considering any execution
information (e.g., threads) and then constructing deadlock cycles
by taking full execution information into account.
Note that, Peahen andAirLock have similar flavors in the sense
of reducing lock graphs by simplifying the edges and efficiently dis-
covering cycles. Nevertheless, Peahen addresses many challenges
that are unique to static deadlock detection, thereby differing in
many aspects. For example, instead of constructing the lock graph
from one execution, Peahen addresses the calling context explo-
sion induced by over-approximating all possible executions. In
addition, unlike AirLock ,Peahen is armed with the refinement
process to validate the feasibility of deadlocks (e.g., considering the
happens-before relation), whereby embracing high fidelity.
Another category of sound work never induces false positives
with the theoretical guarantees. Specifically, Dirk [39] uses request
events and a new form of execution constraints to disclose real
deadlocks via solving all these constraints. SeqCheck [8] models
the program branches in the execution traces and predicts the
feasibility of event sequences for sound deadlock detection.
7 CONCLUSION
We have introduced Peahen , a context-reduction technique, mak-
ing static deadlock detection more scalable and precise. Peahen
is quite promising, having already pinpointed many previously-
unknown deadlocks on a dozen of well-known software systems.
We believe that context reduction is a big step forward in static
deadlock detection, which ameliorates the major current pain point
in the practical deployment of deadlock detectors. We expect that
Peahen can provide interesting insights into aiding in other static
analyses to become more scalable with high precision for industrial-
strength software. Finally, we plan to extend our approach to com-
munication deadlock detection.
ACKNOWLEDGMENTS
We thank the anonymous reviewers for their insightful comments.
This work was partially funded by PRP/004/21FX, ITS/440/18FP
grants, and the donations from Microsoft and Huawei. Qingkai Shi
is the corresponding author of this paper. This work was finished
when Qingkai Shi was with Ant Group. He is currently with Purdue
University and is available via email at shi553@purdue.edu.ESEC/FSE â€™22, November 14â€“18, 2022, Singapore, Singapore Yuandao Cai, Chengfeng Ye, Qingkai Shi, and Charles Zhang
REFERENCES
[1]Steven Arzt, Siegfried Rasthofer, Christian Fritz, Eric Bodden, Alexandre Bartel,
Jacques Klein, Yves Le Traon, Damien Octeau, and Patrick D. McDaniel. 2014.
FlowDroid: precise context, flow, field, object-sensitive and lifecycle-aware taint
analysis for Android apps. In ACM SIGPLAN Conference on Programming Lan-
guage Design and Implementation, PLDI â€™14, Edinburgh, United Kingdom - June
09 - 11, 2014 , Michael F. P. Oâ€™Boyle and Keshav Pingali (Eds.). ACM, 259â€“269.
https://doi.org/10.1145/2594291.2594299
[2]James Brotherston, Paul Brunet, Nikos Gorogiannis, and Max Kanovich. 2021.
A Compositional Deadlock Detector for Android Java. In Proceedings of ASE-36 .
ACM.
[3]Yan Cai and Lingwei Cao. 2016. Fixing deadlocks via lock pre-acquisitions. In
Proceedings of the 38th International Conference on Software Engineering, ICSE 2016,
Austin, TX, USA, May 14-22, 2016 , Laura K. Dillon, Willem Visser, and Laurie A.
Williams (Eds.). ACM, 1109â€“1120. https://doi.org/10.1145/2884781.2884819
[4]Yan Cai and W. K. Chan. 2012. MagicFuzzer: Scalable deadlock detection for
large-scale applications. In 34th International Conference on Software Engineering,
ICSE 2012, June 2-9, 2012, Zurich, Switzerland , Martin Glinz, Gail C. Murphy, and
Mauro PezzÃ¨ (Eds.). IEEE Computer Society, 606â€“616. https://doi.org/10.1109/
ICSE.2012.6227156
[5]Yan Cai, Ruijie Meng, and Jens Palsberg. 2020. Low-overhead deadlock prediction.
InICSE â€™20: 42nd International Conference on Software Engineering, Seoul, South
Korea, 27 June - 19 July, 2020 , Gregg Rothermel and Doo-Hwan Bae (Eds.). ACM,
1298â€“1309. https://doi.org/10.1145/3377811.3380367
[6]Yan Cai, Shangru Wu, and W. K. Chan. 2014. ConLock: a constraint-based
approach to dynamic checking on deadlocks in multithreaded programs. In 36th
International Conference on Software Engineering, ICSE â€™14, Hyderabad, India -
May 31 - June 07, 2014 , Pankaj Jalote, Lionel C. Briand, and AndrÃ© van der Hoek
(Eds.). ACM, 491â€“502. https://doi.org/10.1145/2568225.2568312
[7]Yuandao Cai, Peisen Yao, and Charles Zhang. 2021. Canary: practical static
detection of inter-thread value-flow bugs. In PLDI â€™21: 42nd ACM SIGPLAN In-
ternational Conference on Programming Language Design and Implementation,
Virtual Event, Canada, June 20-25, 20211 , Stephen N. Freund and Eran Yahav
(Eds.). ACM, 1126â€“1140. https://doi.org/10.1145/3453483.3454099
[8]Yan Cai, Hao Yun, Jinqiu Wang, Lei Qiao, and Jens Palsberg. 2021. Sound and
efficient concurrency bug prediction. In ESEC/FSE â€™21: 29th ACM Joint European
Software Engineering Conference and Symposium on the Foundations of Software
Engineering, Athens, Greece, August 23-28, 2021 , Diomidis Spinellis, Georgios
Gousios, Marsha Chechik, and Massimiliano Di Penta (Eds.). ACM, 255â€“267.
https://doi.org/10.1145/3468264.3468549
[9]Milind Chabbi and Murali Krishna Ramanathan. 2022. A Study of Real-World
Data Races in Golang. In Proceedings of the 43rd ACM SIGPLAN International
Conference on Programming Language Design and Implementation (San Diego,
CA, USA) (PLDI 2022) . Association for Computing Machinery, New York, NY,
USA, 474â€“489. https://doi.org/10.1145/3519939.3523720
[10] Dongjie Chen, Yanyan Jiang, Chang Xu, Xiaoxing Ma, and Jian Lu. 2018. Testing
multithreaded programs via thread speed control. In Proceedings of the 2018 ACM
Joint Meeting on European Software Engineering Conference and Symposium on the
Foundations of Software Engineering, ESEC/SIGSOFT FSE 2018, Lake Buena Vista,
FL, USA, November 04-09, 2018 , Gary T. Leavens, Alessandro Garcia, and Corina S.
Pasareanu (Eds.). ACM, 15â€“25. https://doi.org/10.1145/3236024.3236077
[11] Hongxu Chen, Shengjian Guo, Yinxing Xue, Yulei Sui, Cen Zhang, Yuekang
Li, Haijun Wang, and Yang Liu. 2020. MUZZ: Thread-aware Grey-box Fuzzing
for Effective Bug Hunting in Multithreaded Programs. In 29th USENIX Secu-
rity Symposium, USENIX Security 2020, August 12-14, 2020 , Srdjan Capkun and
Franziska Roesner (Eds.). USENIX Association, 2325â€“2342. https://www.usenix.
org/conference/usenixsecurity20/presentation/chen-hongxu
[12] Oracle Corporation. [n.d.]. LockLint Overview. https://docs.oracle.com/cd/
E19059-01/wrkshp50/805-4947/6j4m8jrng/index.html.
[13] CVE. [n.d.]. CVE List. https://cve.mitre.org/cve/search_cve_list.html.
[14] Peng Di, Yulei Sui, Ding Ye, and Jingling Xue. 2015. Region-Based May-Happen-
in-Parallel Analysis for C Programs. In 44th International Conference on Parallel
Processing, ICPP 2015, Beijing, China, September 1-4, 2015 . IEEE Computer Society,
889â€“898. https://doi.org/10.1109/ICPP.2015.98
[15] Julian Dolby, Christian Hammer, Daniel Marino, Frank Tip, Mandana Vaziri, and
Jan Vitek. 2012. A data-centric approach to synchronization. ACM Trans. Program.
Lang. Syst. 34, 1 (2012), 4:1â€“4:48. https://doi.org/10.1145/2160910.2160913
[16] Dawson Engler and Ken Ashcraft. 2003. RacerX: Effective, Static Detection of
Race Conditions and Deadlocks. In Proceedings of the Nineteenth ACM Symposium
on Operating Systems Principles (Bolton Landing, NY, USA) (SOSP â€™03) . Association
for Computing Machinery, New York, NY, USA, 237â€“252. https://doi.org/10.
1145/945445.945468
[17] Mahdi Eslamimehr and Jens Palsberg. 2014. Sherlock: scalable deadlock detection
for concurrent programs. In Proceedings of the 22nd ACM SIGSOFT International
Symposium on Foundations of Software Engineering, (FSE-22), Hong Kong, China,
November 16 - 22, 2014 , Shing-Chi Cheung, Alessandro Orso, and Margaret-
Anne D. Storey (Eds.). ACM, 353â€“365. https://doi.org/10.1145/2635868.2635918[18] Firefox. [n.d.]. Bugzilla. https://bugzilla.mozilla.org/home.
[19] Patrice Godefroid. 1997. Model Checking for Programming Languages using
Verisoft. In Conference Record of POPLâ€™97: The 24th ACM SIGPLAN-SIGACT Sympo-
sium on Principles of Programming Languages, Papers Presented at the Symposium,
Paris, France, 15-17 January 1997 , Peter Lee, Fritz Henglein, and Neil D. Jones
(Eds.). ACM Press, 174â€“186. https://doi.org/10.1145/263699.263717
[20] Mark Grechanik, B. M. Mainul Hossain, Ugo Buy, and Haisheng Wang. 2013.
Preventing database deadlocks in applications. In Joint Meeting of the European
Software Engineering Conference and the ACM SIGSOFT Symposium on the Foun-
dations of Software Engineering, ESEC/FSEâ€™13, Saint Petersburg, Russian Federation,
August 18-26, 2013 , Bertrand Meyer, Luciano Baresi, and Mira Mezini (Eds.). ACM,
356â€“366. https://doi.org/10.1145/2491411.2491412
[21] Christian Hammer, Julian Dolby, Mandana Vaziri, and Frank Tip. 2008. Dynamic
detection of atomic-set-serializability violations. In 30th International Conference
on Software Engineering (ICSE 2008), Leipzig, Germany, May 10-18, 2008 , Wilhelm
SchÃ¤fer, Matthew B. Dwyer, and Volker Gruhn (Eds.). ACM, 231â€“240. https:
//doi.org/10.1145/1368088.1368120
[22] Dominik Harmim, Vladimir Marcin, and Ondrej Pavela. 2019. Scalable Static
Analysis Using Facebook Infer.
[23] Klaus Havelund. 2000. Using Runtime Analysis to Guide Model Checking of Java
Programs. In SPIN Model Checking and Software Verification, 7th International
SPIN Workshop, Stanford, CA, USA, August 30 - September 1, 2000, Proceedings
(Lecture Notes in Computer Science, Vol. 1885) , Klaus Havelund, John Penix, and
Willem Visser (Eds.). Springer, 245â€“264. https://doi.org/10.1007/10722468_15
[24] Jeff Huang. 2018. UFO: predictive concurrency use-after-free detection. In
Proceedings of the 40th International Conference on Software Engineering, ICSE
2018, Gothenburg, Sweden, May 27 - June 03, 2018 , Michel Chaudron, Ivica
Crnkovic, Marsha Chechik, and Mark Harman (Eds.). ACM, 609â€“619. https:
//doi.org/10.1145/3180155.3180225
[25] Jeff Huang, Patrick Oâ€™Neil Meredith, and Grigore Rosu. 2014. Maximal sound
predictive race detection with control flow abstraction. In ACM SIGPLAN Confer-
ence on Programming Language Design and Implementation, PLDI â€™14, Edinburgh,
United Kingdom - June 09 - 11, 2014 , Michael F. P. Oâ€™Boyle and Keshav Pingali
(Eds.). ACM, 337â€“348. https://doi.org/10.1145/2594291.2594315
[26] Infer. [n.d.]. Scalable Static Analysis Using Facebook Infer. https://github.com/
vmarcin/L2D2.
[27] Dae R. Jeong, Kyungtae Kim, Basavesh Shivakumar, Byoungyoung Lee, and Insik
Shin. 2019. Razzer: Finding Kernel Race Bugs through Fuzzing. In 2019 IEEE
Symposium on Security and Privacy (SP) . 754â€“768. https://doi.org/10.1109/SP.
2019.00017
[28] Dae R. Jeong, Kyungtae Kim, Basavesh Shivakumar, Byoungyoung Lee, and Insik
Shin. 2019. Razzer: Finding Kernel Race Bugs through Fuzzing. In 2019 IEEE
Symposium on Security and Privacy, SP 2019, San Francisco, CA, USA, May 19-23,
2019. IEEE, 754â€“768. https://doi.org/10.1109/SP.2019.00017
[29] Guoliang Jin, Linhai Song, Wei Zhang, Shan Lu, and Ben Liblit. 2011. Automated
atomicity-violation fixing. In Proceedings of the 32nd ACM SIGPLAN Conference
on Programming Language Design and Implementation, PLDI 2011, San Jose, CA,
USA, June 4-8, 2011 , Mary W. Hall and David A. Padua (Eds.). ACM, 389â€“400.
https://doi.org/10.1145/1993498.1993544
[30] Guoliang Jin, Wei Zhang, and Dongdong Deng. 2012. Automated Concurrency-
Bug Fixing. In 10th USENIX Symposium on Operating Systems Design and Imple-
mentation, OSDI 2012, Hollywood, CA, USA, October 8-10, 2012 , Chandu Thekkath
and Amin Vahdat (Eds.). USENIX Association, 221â€“236. https://www.usenix.
org/conference/osdi12/technical-sessions/presentation/jin
[31] Donald B. Johnson. 1975. Finding All the Elementary Circuits of a Directed
Graph. SIAM J. Comput. 4, 1 (1975), 77â€“84. https://doi.org/10.1137/0204007
[32] Pallavi Joshi, Mayur Naik, Chang-Seo Park, and Koushik Sen. 2009. CalFuzzer:
An Extensible Active Testing Framework for Concurrent Programs. In Computer
Aided Verification, 21st International Conference, CAV 2009, Grenoble, France, June
26 - July 2, 2009. Proceedings (Lecture Notes in Computer Science, Vol. 5643) , Ahmed
Bouajjani and Oded Maler (Eds.). Springer, 675â€“681. https://doi.org/10.1007/978-
3-642-02658-4_54
[33] Pallavi Joshi, Mayur Naik, Koushik Sen, and David Gay. 2010. An effective
dynamic analysis for detecting generalized deadlocks. In Proceedings of the 18th
ACM SIGSOFT International Symposium on Foundations of Software Engineering,
2010, Santa Fe, NM, USA, November 7-11, 2010 , Gruia-Catalin Roman and AndrÃ©
van der Hoek (Eds.). ACM, 327â€“336. https://doi.org/10.1145/1882291.1882339
[34] Pallavi Joshi, Chang-Seo Park, Koushik Sen, and Mayur Naik. 2009. A randomized
dynamic program analysis technique for detecting real deadlocks. In Proceedings
of the 2009 ACM SIGPLAN Conference on Programming Language Design and
Implementation, PLDI 2009, Dublin, Ireland, June 15-21, 2009 , Michael Hind and
Amer Diwan (Eds.). ACM, 110â€“120. https://doi.org/10.1145/1542476.1542489
[35] Horatiu Jula, Daniel M. Tralamazza, Cristian Zamfir, and George Candea. 2008.
Deadlock Immunity: Enabling Systems to Defend Against Deadlocks. In 8th
USENIX Symposium on Operating Systems Design and Implementation, OSDI 2008,
December 8-10, 2008, San Diego, California, USA, Proceedings , Richard Draves and
Robbert van Renesse (Eds.). USENIX Association, 295â€“308. http://www.usenix.
org/events/osdi08/tech/full_papers/jula/jula.pdfPeahen: Fast and Precise Static Deadlock Detection via Context Reduction ESEC/FSE â€™22, November 14â€“18, 2022, Singapore, Singapore
[36] Vineet Kahlon, Nishant Sinha, Erik Kruus, and Yun Zhang. 2009. Static data race
detection for concurrent programs with asynchronous calls. In Proceedings of
the 7th joint meeting of the European Software Engineering Conference and the
ACM SIGSOFT International Symposium on Foundations of Software Engineering,
2009, Amsterdam, The Netherlands, August 24-28, 2009 , Hans van Vliet and ValÃ©rie
Issarny (Eds.). ACM, 13â€“22. https://doi.org/10.1145/1595696.1595701
[37] Vineet Kahlon and Chao Wang. 2010. Universal Causality Graphs: A Precise
Happens-Before Model for Detecting Bugs in Concurrent Programs. In Computer
Aided Verification, 22nd International Conference, CAV 2010, Edinburgh, UK, July
15-19, 2010. Proceedings (Lecture Notes in Computer Science, Vol. 6174) , Tayssir
Touili, Byron Cook, and Paul B. Jackson (Eds.). Springer, 434â€“449. https://doi.
org/10.1007/978-3-642-14295-6_39
[38] Vineet Kahlon, Yu Yang, Sriram Sankaranarayanan, and Aarti Gupta. 2007. Fast
and Accurate Static Data-Race Detection for Concurrent Programs. In Computer
Aided Verification, 19th International Conference, CAV 2007, Berlin, Germany, July
3-7, 2007, Proceedings (Lecture Notes in Computer Science, Vol. 4590) , Werner Damm
and Holger Hermanns (Eds.). Springer, 226â€“239. https://doi.org/10.1007/978-3-
540-73368-3_26
[39] Christian Gram Kalhauge and Jens Palsberg. 2018. Sound deadlock prediction.
Proc. ACM Program. Lang. 2, OOPSLA (2018), 146:1â€“146:29. https://doi.org/10.
1145/3276516
[40] Linux Kernel. [n.d.]. Bugzilla. https://bugzilla.kernel.org/.
[41] D. Kroening, D. Poetzl, P. Schrammel, and B. Wachter. [n.d.]. Sound Static Deadlock
Analysis for C/Pthreads . http://www.cprover.org/deadlock-detection/
[42] Daniel Kroening, Daniel Poetzl, Peter Schrammel, and BjÃ¶rn Wachter. 2016. Sound
Static Deadlock Analysis for C/Pthreads. In Proceedings of the 31st IEEE/ACM In-
ternational Conference on Automated Software Engineering (Singapore, Singapore)
(ASE 2016) . Association for Computing Machinery, New York, NY, USA, 379â€“390.
https://doi.org/10.1145/2970276.2970309
[43] Bozhen Liu and Jeff Huang. 2018. D4: fast concurrency debugging with parallel
differential analysis. In Proceedings of the 39th ACM SIGPLAN Conference on
Programming Language Design and Implementation, PLDI 2018, Philadelphia, PA,
USA, June 18-22, 2018 , Jeffrey S. Foster and Dan Grossman (Eds.). ACM, 359â€“373.
https://doi.org/10.1145/3192366.3192390
[44] Bozhen Liu, Peiming Liu, Yanze Li, Chia-Che Tsai, Dilma Da Silva, and Jeff Huang.
2021. When Threads Meet Events: Efficient and Precise Static Race Detection
with Origins. In Proceedings of the 42nd ACM SIGPLAN International Conference
on Programming Language Design and Implementation (Virtual, Canada) (PLDI
2021) . Association for Computing Machinery, New York, NY, USA, 725â€“739.
https://doi.org/10.1145/3453483.3454073
[45] Benjamin Livshits, Dimitrios Vardoulakis, Manu Sridharan, Yannis Smaragdakis,
OndÅ™ej LhotÃ¡k, JosÃ© Amaral, Bor-Yuh Chang, Samuel Guyer, Uday Khedker, and
Anders MÃ¸ller. 2015. In Defense of Soundiness: A Manifesto. Commun. ACM 58
(01 2015), 44â€“46. https://doi.org/10.1145/2644805
[46] Shan Lu, Soyeon Park, Eunsoo Seo, and Yuanyuan Zhou. 2008. Learning from
mistakes: a comprehensive study on real world concurrency bug characteristics.
InProceedings of the 13th International Conference on Architectural Support for
Programming Languages and Operating Systems, ASPLOS 2008, Seattle, WA, USA,
March 1-5, 2008 , Susan J. Eggers and James R. Larus (Eds.). ACM, 329â€“339. https:
//doi.org/10.1145/1346281.1346323
[47] Daniel Marino, Christian Hammer, Julian Dolby, Mandana Vaziri, Frank Tip,
and Jan Vitek. 2013. Detecting deadlock in programs with data-centric synchro-
nization. In 35th International Conference on Software Engineering, ICSE â€™13, San
Francisco, CA, USA, May 18-26, 2013 , David Notkin, Betty H. C. Cheng, and Klaus
Pohl (Eds.). IEEE Computer Society, 322â€“331. https://doi.org/10.1109/ICSE.2013.
6606578
[48] Mayur Naik, Alex Aiken, and John Whaley. 2006. Effective static race detection
for Java. In Proceedings of the ACM SIGPLAN 2006 Conference on Programming
Language Design and Implementation, Ottawa, Ontario, Canada, June 11-14, 2006 ,
Michael I. Schwartzbach and Thomas Ball (Eds.). ACM, 308â€“319. https://doi.org/
10.1145/1133981.1134018
[49] Mayur Naik, Chang-Seo Park, Koushik Sen, and David Gay. 2009. Effective static
deadlock detection. In 31st International Conference on Software Engineering, ICSE
2009, May 16-24, 2009, Vancouver, Canada, Proceedings . IEEE, 386â€“396. https:
//doi.org/10.1109/ICSE.2009.5070538
[50] Pinpoint Platform. [n.d.]. Confirmed Bug List. https://whichbug.github.io/.
[51] Boqin Qin, Yilun Chen, Zeming Yu, Linhai Song, and Yiying Zhang. 2020. Un-
derstanding memory and thread safety practices and issues in real-world Rust
programs. In Proceedings of the 41st ACM SIGPLAN International Conference
on Programming Language Design and Implementation, PLDI 2020, London, UK,
June 15-20, 2020 , Alastair F. Donaldson and Emina Torlak (Eds.). ACM, 763â€“779.
https://doi.org/10.1145/3385412.3386036
[52] Jake Roemer, Kaan GenÃ§, and Michael D. Bond. 2020. SmartTrack: efficient
predictive race detection. In Proceedings of the 41st ACM SIGPLAN International
Conference on Programming Language Design and Implementation, PLDI 2020,
London, UK, June 15-20, 2020 , Alastair F. Donaldson and Emina Torlak (Eds.).ACM, 747â€“762. https://doi.org/10.1145/3385412.3385993
[53] Mahmoud Said, Chao Wang, Zijiang Yang, and Karem A. Sakallah. 2011. Gener-
ating Data Race Witnesses by an SMT-Based Analysis. In NASA Formal Methods
- Third International Symposium, NFM 2011, Pasadena, CA, USA, April 18-20, 2011.
Proceedings (Lecture Notes in Computer Science, Vol. 6617) , Mihaela Gheorghiu
Bobaru, Klaus Havelund, Gerard J. Holzmann, and Rajeev Joshi (Eds.). Springer,
313â€“327. https://doi.org/10.1007/978-3-642-20398-5_23
[54] Koushik Sen. 2008. Race directed random testing of concurrent programs. In
Proceedings of the ACM SIGPLAN 2008 Conference on Programming Language
Design and Implementation, Tucson, AZ, USA, June 7-13, 2008 , Rajiv Gupta and
Saman P. Amarasinghe (Eds.). ACM, 11â€“21. https://doi.org/10.1145/1375581.
1375584
[55] Qingkai Shi, Xiao Xiao, Rongxin Wu, Jinguo Zhou, Gang Fan, and Charles Zhang.
2018. Pinpoint: fast and precise sparse value flow analysis for million lines
of code. In Proceedings of the 39th ACM SIGPLAN Conference on Programming
Language Design and Implementation, PLDI 2018, Philadelphia, PA, USA, June
18-22, 2018 , Jeffrey S. Foster and Dan Grossman (Eds.). ACM, 693â€“706. https:
//doi.org/10.1145/3192366.3192418
[56] Yulei Sui, Peng Di, and Jingling Xue. 2016. Sparse flow-sensitive pointer analysis
for multithreaded programs. In Proceedings of the 2016 International Symposium
on Code Generation and Optimization, CGO 2016, Barcelona, Spain, March 12-18,
2016, BjÃ¶rn Franke, Youfeng Wu, and Fabrice Rastello (Eds.). ACM, 160â€“170.
https://doi.org/10.1145/2854038.2854043
[57] Yulei Sui, Ding Ye, and Jingling Xue. 2012. Static memory leak detection using
full-sparse value-flow analysis. In International Symposium on Software Testing
and Analysis, ISSTA 2012, Minneapolis, MN, USA, July 15-20, 2012 , Mats Per Erik
Heimdahl and Zhendong Su (Eds.). ACM, 254â€“264. https://doi.org/10.1145/
2338965.2336784
[58] Chao Wang, Sudipta Kundu, Rhishikesh Limaye, Malay K. Ganai, and Aarti Gupta.
2011. Symbolic predictive analysis for concurrent programs. Formal Aspects
Comput. 23, 6 (2011), 781â€“805. https://doi.org/10.1007/s00165-011-0179-2
[59] Chao Wang, Mahmoud Said, and Aarti Gupta. 2011. Coverage guided system-
atic concurrency testing. In Proceedings of the 33rd International Conference on
Software Engineering, ICSE 2011, Waikiki, Honolulu , HI, USA, May 21-28, 2011 ,
Richard N. Taylor, Harald C. Gall, and Nenad Medvidovic (Eds.). ACM, 221â€“230.
https://doi.org/10.1145/1985793.1985824
[60] Yin Wang, Terence Kelly, Manjunath Kudlur, StÃ©phane Lafortune, and Scott A.
Mahlke. 2008. Gadara: Dynamic Deadlock Avoidance for Multithreaded Programs.
In8th USENIX Symposium on Operating Systems Design and Implementation,
OSDI 2008, December 8-10, 2008, San Diego, California, USA, Proceedings , Richard
Draves and Robbert van Renesse (Eds.). USENIX Association, 281â€“294. http:
//www.usenix.org/events/osdi08/tech/full_papers/wang/wang.pdf
[61] Cheng Wen, Mengda He, Bohao Wu, Zhiwu Xu, and Shengchao Qin. 2022.
Controlled Concurrency Testing via Periodical Scheduling. In Proceedings of
the ACM/IEEE 4th International Conference on Software Engineering (Pittsburgh,
USA) (ICSE â€™22) . Association for Computing Machinery, New York, NY, USA.
https://doi.org/10.1145/3510003.3510178
[62] Amy L. Williams, William Thies, and Michael D. Ernst. 2005. Static Deadlock
Detection for Java Libraries. In ECOOP 2005 - Object-Oriented Programming,
19th European Conference, Glasgow, UK, July 25-29, 2005, Proceedings (Lecture
Notes in Computer Science, Vol. 3586) , Andrew P. Black (Ed.). Springer, 602â€“629.
https://doi.org/10.1007/11531142_26
[63] Meng Xu, Sanidhya Kashyap, Hanqing Zhao, and Taesoo Kim. 2020. Krace: Data
Race Fuzzing for Kernel File Systems. 2020 IEEE Symposium on Security and
Privacy (SP) (2020), 1643â€“1660.
[64] Hua Yan, Yulei Sui, Shiping Chen, and Jingling Xue. 2018. Spatio-temporal
context reduction: a pointer-analysis-based static approach for detecting use-
after-free vulnerabilities. In Proceedings of the 40th International Conference on
Software Engineering, ICSE 2018, Gothenburg, Sweden, May 27 - June 03, 2018 ,
Michel Chaudron, Ivica Crnkovic, Marsha Chechik, and Mark Harman (Eds.).
ACM, 327â€“337. https://doi.org/10.1145/3180155.3180178
[65] Peisen Yao, Qingkai Shi, Heqing Huang, and Charles Zhang. 2020. Fast bit-vector
satisfiability. In ISSTA â€™20: 29th ACM SIGSOFT International Symposium on Software
Testing and Analysis, Virtual Event, USA, July 18-22, 2020 , Sarfraz Khurshid and
Corina S. Pasareanu (Eds.). ACM, 38â€“50. https://doi.org/10.1145/3395363.3397378
[66] Jinpeng Zhou, Sam Silvestro, Hongyu Liu, Yan Cai, and Tongping Liu. 2017.
UNDEAD: detecting and preventing deadlocks in production software. In Pro-
ceedings of the 32nd IEEE/ACM International Conference on Automated Software
Engineering, ASE 2017, Urbana, IL, USA, October 30 - November 03, 2017 , Grigore
Rosu, Massimiliano Di Penta, and Tien N. Nguyen (Eds.). IEEE Computer Society,
729â€“740. https://doi.org/10.1109/ASE.2017.8115684
[67] Jinpeng Zhou, Hanmei Yang, John Lange, and Tongping Liu. 2022. Deadlock
Prediction via Generalized Dependency. In Proceedings of the 31st ACM SIGSOFT
International Symposium on Software Testing and Analysis (Virtual, South Korea)
(ISSTA 2022) . Association for Computing Machinery, New York, NY, USA, 455â€“466.
https://doi.org/10.1145/3533767.3534377