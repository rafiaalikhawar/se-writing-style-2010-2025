Aper: Evolution-Aware Runtime Permission Misuse Detection
for Android Apps
Sinan Wang∗
Southern University of Science and
Technology
Shenzhen, China
wangsn@mail.sustech.edu.cnYibo Wang
Northeastern University
Shenyang, China
yibowangcz@outlook.comXian Zhan
The Hong Kong Polytechnic
University
Hong Kong, China
chichoxian@gmail.com
Ying Wang†
Northeastern University
Shenyang, China
wangying@swc.neu.edu.cnYepang Liu‡
Southern University of Science and
Technology
Shenzhen, China
liuyp1@sustech.edu.cnXiapu Luo
The Hong Kong Polytechnic
University
Hong Kong, China
csxluo@comp.polyu.edu.hk
Shing-Chi Cheung
The Hong Kong University of Science
and Technology, and Guangzhou
HKUST Fok Ying Tung Research
Institute
Hong Kong, China
scc@cse.ust.hk
ABSTRACT
The Android platform introduces the runtime permission model
inversion6.0.Thenewmodelgreatlyimprovesdataprivacyand
user experience, but brings new challenges for app developers.
First,itallowsuserstofreelyrevokegrantedpermissions.Hence,
developers cannot assume that the permissions granted to an app
would keep being granted. Instead, they should make their apps
carefullycheckthepermissionstatusbeforeinvokingdangerous
APIs.Second,thepermissionspecificationkeepsevolving,bringing
newtypesofcompatibilityissuesintotheecosystem.Tounderstand
the impact of the challenges, we conducted an empirical study
on 13,352 popular Google Play apps. We found that 86.0% apps
useddangerousAPIsasynchronouslyafterpermissionmanagement
and61.2%appsusedevolvingdangerousAPIs.Ifanappdoesnot
properly handle permission revocations or platform differences,
unexpectedruntimeissuesmayhappenandevencauseappcrashes.
∗Sinan Wang is affiliated with the Research Institute of Trustworthy Autonomous
Systems and Department of Computer Science and Engineering of SUSTech.
†Ying Wang is also affiliated with Hong Kong University of Science and Technology.
‡Yepang Liu is the corresponding author. He is affiliated with the Research Insti-
tute of Trustworthy Autonomous Systems, Guangdong Provincial Key Laboratory of
Brain-inspired Intelligent Computation, and Department of Computer Science and
Engineering of SUSTech.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACMmustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ICSE ’22, May 21–29, 2022, Pittsburgh, PA, USA
© 2022 Association for Computing Machinery.
ACM ISBN 978-1-4503-9221-1/22/05...$15.00
https://doi.org/10.1145/3510003.3510074We call such Android Runtime Permission issues as ARP bugs.
Unfortunately, existing runtime permission issue detection tools
cannoteffectivelydealwiththeARPbugsinducedbyasynchronous
permission management and permission specification evolution.
Tofillthegap,wedesignedastaticanalyzer,Aper,thatperforms
reaching definition and dominator analysis on Android apps to
detect thetwo types ofARP bugs.To compare Aper with existing
tools,webuiltabenchmark,ARPfix,from60realARPbugs.Our
experiment results show that Aper significantly outperforms two
academictools,ARPDroidandRevDroid,andanindustrialtool,
Lint, on ARPfix, with an average improvement of 46.3% on F1-
score.Inaddition,Apersuccessfullyfound34ARPbugsin214open-
source Android apps, most of which can result in abnormal app
behaviors(suchasappcrashes)accordingtoourmanualvalidation.
We reported these bugs to the app developers. So far, 17 bugs have
been confirmed and seven have been fixed.
KEYWORDS
Android Runtime Permission, Compatibility Issues, Static Analysis
ACM Reference Format:
Sinan Wang, Yibo Wang, Xian Zhan, Ying Wang, Yepang Liu, Xiapu Luo,
and Shing-Chi Cheung. 2022. Aper: Evolution-Aware Runtime Permission
Misuse Detection for Android Apps. In 44th International Conference on
Software Engineering (ICSE ’22), May 21–29, 2022, Pittsburgh, PA, USA. ACM,
New York, NY, USA, 13 pages. https://doi.org/10.1145/3510003.3510074
1 INTRODUCTION
ThepermissionmechanismontheAndroidplatformservesasan
essentialguardtousers’dataprivacy.Inordertoaccesssensitive
data or critical system functions, an Android app should obtain
correspondingpermissionsfromtheuserbeforeinvokingrelated
1252022 IEEE/ACM 44th International Conference on Software Engineering (ICSE)
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 07:51:54 UTC from IEEE Xplore.  Restrictions apply. ICSE ’22, May 21–29, 2022, Pittsburgh, PA, USA Sinan Wang, Yibo Wang, Xian Zhan, Ying Wang, Yepang Liu, Xiapu Luo, and Shing-Chi Cheung
permission-protectedAPIs.PriortoAndroid6.0(i.e.,APIlevel22or
earlier, which we call “legacy platforms ”), the permission granting
process happens when an app is installed [ 62]. After the app is
granted with its required permissions and gets installed, users can
no longer revoke the permissions1. Such a static permission model
was considered to be vulnerable, as the installation-time permis-
sion warnings cannot effectively help users make their security
decisions [ 43]. To address this weakness, in Android 6.0 (API level
23), theruntime permission model was introduced. The new model
brought several changes: 1) dangerous permissions are requested
duringanapp’sexecution;2)userscaneithergrantordenysuch
requests; 3) users can also revoke granted permissions from the
systemsettingsatanytime.Thesechangesgreatlyimprovedataprivacy and users’ experience with Android apps [
28]. However,
this Android runtime permission (ARP) mechanism also brings
technical challenges to developers:
•As users can freely revoke granted permissions starting from
Android 6.0, developers cannot guarantee that the required per-
missions are always held by their apps. To avoid app crashes,
they need to properly insert permission check and request state-
mentstoensureeverydangerousAPIusedbytheirappsisnever
invoked without the required permissions [ 22]. This is a non-
trivial task, even for experienced developers. For example, in
issue 2110 [ 13]o fK-9 Mail, a famous email client for Android,
the developers had discussed how to support runtime permis-
sions for almosttwo years, until they “functionally covered the
user experience of requesting (runtime) permissions”.
•Apart from moving the permission granting process to run-time, the Android platform has also changed the behavior of
permissiongroups[ 36],alteredmanyAPIs’correspondingper-
missions[ 12],andsupportedone-timepermissions[ 20].Without
trackingandproperlyhandlingsuchchanges,appdeveloperscan-
not easily implement permission-protected functionalities [63].
Previousworkmostlystudiedhowtoadaptappstargetinglegacy
platforms to the new platforms [ 34,40,45], or detect ARP issues
fromthesecurityperspective[ 57].Theproposedtoolscannoteffec-
tively detect ARP-induced functional bugs [ 41,58] for two reasons:
•Permission-protected APIs and their permission specification
keepevolving,whichisoverlookedbyalmostallexistingtools,
causing many ARP-related compatibility issues undiscovered.
•Most existing tools, like ARPDroid [ 40] and RevDroid [ 41],
leverage FlowDroid’s dummy main classes [ 29] to model the
implicit control flows within each component of an Android
app.However,asdevelopersmaymanageruntimepermissions
asynchronously across app components, performing such an
intra-component analysis would produce false alarms.
Tofurtherunderstandthelimitationsoftheexistingtoolsand
thepracticesofARPmanagement,weconductedanempiricalstudy
byanalyzingthesourcecodeoftheAndroidplatformand13,352
popularAndroidapps.Theresultsshowthatalargenumberofapps
may be affected by the active changes of dangerous permissions
and dangerous APIs, and asynchronous permission management is
common in real-world apps.
1Afewcustomizedlegacyplatformsallowuserstorevokepermissionsafterinstalla-
tion [6]. They are out of the scope of this work.@RequiresPermission(anyOf={ACCESS_COARSE_LOCATION,
ACCESS_FINE_LOCATION})
public void requestLocationUpdates(...) { ... }
Figure 1: Permission specification of a dangerous API
Drivenbyourempiricalfindings,wedesignedandimplemented
Aper,anAndroidruntime Permissionmisus Ebugdetecto R.Aperis
anevolution-andasynchrony-awareARPbugdetector.Itperforms
both intra- and inter-component static analyses to find missing
permissionandruntimeversionchecks.ToevaluateAper,webuilt
a benchmark from 60 real ARP bugs. The experiment results on
thebenchmarkshowthatAperoutperformsexistingtoolsbyan
average improvement of 46.3% on F1-score. To further evaluate the
usefulness of Aper, we applied it to analyze 214 open-source apps.
Itsuccessfullyfound34realARPbugs.Wesubmittedbugreportsto
the app developers. At the time of paper acceptance, 17 submitted
bugshavebeenconfirmedbythedevelopersandsevenhavealready
been fixed. In summary, we make the following contributions:
•To the best of our knowledge, we conducted the first empiri-
cal study on the evolution of ARP specification and real-world
developers’ practices in runtime permission management.
•Weproposeda staticanalyzer ,Aper,fordetectingARPbugsin
Android apps, with a special focus on evolution-induced issues.
•We performed an evaluation of Aper, including both control
experiments on our prepared benchmark and an in-the-wild
study on real-world open-source apps. The results show that
Aper can significantly outperform existing tools.
•We provided a reproduction package for future research at
https://aper-project.github.io/, which includes: 1) Aper’s source
code, 2) the benchmark of 60 ARP bugs and their patches, and 3)
34realARPbugsdetectedbyAper,alongwithourissuerepro-
ducing videos, detailed descriptions, and developers’ feedback.
2 PRELIMINARIES
2.1 Permission Specification
Android framework provides APIs to perform sensitive operations,
suchasaccessingcontactsorusingthecamera.TheseAPIsarepro-
tectedbycorresponding dangerouspermissions,andwecallthem
dangerous APIs. For instance, to open the camera, an app should re-
quest the user to grant the CAMERApermission before invoking the
dangerous API CameraManager.openCamera() . Unlike danger-
ous permissions, normal permissions (e.g., network, vibration) can
be automatically granted when the app is installed [ 57]. Generally,
Androidpermissionshavefourprotectionlevels[ 71]:normal≺dan-
gerous≺signature ≺signatureOrSystem,where a≺bmeansthat
the permission with a protection level bhas a higher risk than that
ofa, and thus granting them should follow different procedures.
InAndroidframework,startingfrom6.0,apermission-protected
APIcanusethe @RequiresPermission annotationtospecifyits
requiredpermissions.Figure1showstheAPI requestLocation
Updates() , and its annotation-based permission specification. Ac-
cording to this annotation, any of the ACCESS_COARSE_LOCATION
or the ACCESS_FINE_LOCATION permission should be granted be-
foreinvokingthisdangerousAPI.Similarly,ifalllistedpermissions
arerequiredbytheAPI,theywillbespecifiedbytheelement allOf,
instead of anyOf. Such annotations can help developers and static
126
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 07:51:54 UTC from IEEE Xplore.  Restrictions apply. Aper: Evolution-Aware Runtime Permission Misuse Detection for Android Apps ICSE ’22, May 21–29, 2022, Pittsburgh, PA, USA
if(checkSelfPermission( "ACCESS_FINE_LOCATION" ) == GRANTED)
doLocationingActions(...); // calls dangerous API
else
requestPermissions( new String[]{ "ACCESS_FINE_LOCATION" });
Figure2:Permissioncheckandrequestexample(simplified)
checkers (e.g., Lint [ 64]) to determine whether an API is protected
by any permissions. Besides the annotation, the permissions can
alsobeimplicitlyspecifiedusingthe {@link android.Manifest.
permission#...} tag in an API’s Javadoc.
2.2 Runtime Permission Management
To acquire a permission, an Android app should declare it in the
manifest file using the <uses-permission> XML element. This,
however, does not guarantee that the permission can always be
grantedaftertheappisinstalled.ThelegacyplatformsprovideAPIs
forappstochecktheirpermissionstatusesatruntime.Underthe
runtime permission model, users are allowed to dynamically grant
andrevokedangerouspermissions.Thus,thenewplatforms(API
level23andabove)provideadditionalAPIstohandleusers’runtime
behaviors. Figure 2 shows an example from the official documenta-
tion [22], which involves permission check and request. Generally,
the permission management APIs fall into four categories:
(a)Checking permission status :Beforeinvokingapermission-
protectedAPI,anappwillcheckwhetherithastherequiredpermis-
sionsbyinvokingthe CHECKAPIs(e.g., ContextCompat.check
SelfPermission() ). These APIs typically accept a permission
string and return whether the permission is granted or not.
(b)Requesting for dangerous permissions : To request dan-
gerous permissions at runtime, an app will call REQUEST APIs
likeActivityCompat.requestPermissions() .Thiswilltrigger
a pop-up dialog that prompts the user to either grant/deny the per-
missionrequest,orblocksubsequentpermissionrequests.Unlike
CHECKAPIs, the REQUEST APIs accept an array of permission
strings to spawn multiple permission request dialogs.
(c)Handling user response : TheHANDLE API, onRequest
PermissionsResult(int,String[],int[]) , is an empty call-
back defined in the base GUI classes. It is invoked by the system
after the user reacts to the permission request, and its parame-
ters store the user’s granting results. Developers can override this
callback to check the user’s decisions and take actions accordingly.
(d)Explaining permission usage :TheEXPLAIN API, should
ShowRequestPermissionRationale() , returns a boolean value
of whether the user has denied the permission request and se-
lectedthe“Neveraskagain”option.Developersmayuseittocheck
whether the permission requests are blocked, and explain to the
user why the requested permission is essential, accordingly.
3 EMPIRICAL STUDY
To understand the practices of runtime permission management
and the limitations of existing work, we conducted an empirical
study to investigate the following three research questions:
•RQ1 (Evolution of Permission Specification) : How do the
permission-protected APIs and their permission specification
evolve in the Android platform?
•RQ2 (Impact of Evolution) : How many Android apps may be
affected by the evolution of API-permission specification?Figure 3: Category distribution of the Google Play apps
•RQ3 (Permission Management Practices) : How many An-
droid apps implement asynchronous permission managements?
Inthefollowing,wepresentourdatacollectingprocedures,anal-
ysis methods, and results.
3.1 Dataset Construction
3.1.1 Collecting API-Permission Mappings. ForRQ1,wecollected
the API-permission mappings from the Android framework [ 34].
ForeachAPIlevel,wetraversedallJavafilestofindthoseAPImeth-
ods that have @RequiresPermission annotations or use @link
tags to specify their permission requirements (§ 2). The declared
permissions are extracted from the framework’s manifest file. We
did not adopt the existing mappings [ 25,30,31,34,42], because
their released datasets are outdated, or the mapping extraction
tools are unavailable or cannot be easily applied to analyze the
new Android versions. More importantly, as discussed in a recent
work [38], these mappings are neither precise nor complete. Since
ourstudyneedsthelatestandpreciseAPI-permissionmappings,
we decided to extract mappings from the source code and docs.
3.1.2 Collecting Android Apps. RQ2andRQ3investigatetheper-
mission management practices in real-world apps. To this end, we
crawled Google Play [ 4] apps from Androzoo [27] according to two
criteria: 1) ranking at top-500 in each of the 32 categories indexed
byAppBrain[ 10](i.e.,theappsshouldbepopular);2)containing
call sites of both dangerous API(s) and permission management
API(s).AsweimplementedouranalyzerontopofSoot[ 48],awell-
maintainedJavaprogramanalysisframework,weexcludedallapps
in the game category because they are mostly built using game
engines that are not developed in Java [55].
Finally,wecollected13,352popularappsthatinvolvedangerous
permissionusages.Thecategorydistributionoftheseappsisshown
in Figure 3. In general, our collected apps are evenly distributed
among different categories, thus studying them can reveal develop-
ers’ practices of ARP management without bias toward certain app
categories.
It is worth noting that we only focus on dangerous APIs in RQ2
andRQ3.Thereasonisthatnormalandsignaturepermissionsdo
not require runtime management since they are granted at thetime of installation. An app can use any API protected by such
permissionswithoutusers’explicitapprovals.Inthiscase,thesafety
ofanAPIcallcanbeguaranteedbysimplycheckingwhetherthe
required permissions are declared in the manifest file of the app.
3.2 RQ1: Evolution of Permission Specification
3.2.1 Analysis Method. Westudiedpermissionsandpermission-
protectedAPIs,byinvestigatingtheirdistributionsandhowthey
have changed across Android versions from 6.0 to 11. We grouped
127
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 07:51:54 UTC from IEEE Xplore.  Restrictions apply. ICSE ’22, May 21–29, 2022, Pittsburgh, PA, USA Sinan Wang, Yibo Wang, Xian Zhan, Ying Wang, Yepang Liu, Xiapu Luo, and Shing-Chi Cheung
Table 1: Distribution and evolution of permission specification
APIlevel
(version number)#Permissions #APIs protected by permissions #Evolved APIs Change of permissions
normal dangerous signature total normal dangerous signature added deleted changed†restricted relaxed same-level
23(6.0) 55 25 235 452 260 71 127 - - - - - -
24 (7.0) 55 25 270 540 269 108 172 98 10 0 0 0 0
25 (7.1) 55 25 271 547 269 110 177 10 3 0 0 0 0
26 (8.0) 57 27 303 822 303 146 400 290 15 6 1 1 4
27 (8.1) 57 27 323 889 309 152 446 75 8 5 3 1 1
28 (9) 60 28 369 1,094 345 162 620 230 25 12 3 2 7
29 (10) 63 31 441 1,523 359 195 1,011 467 38 31 12 3 16
30 (11) 63 31 497 2,036 364 218 1,504 580 67 86 24 10 52
†We say a permission-protected API is changedif its required permissions are changed.
the APIs according to their required permissions’ protection levels.
Wealsomerged signature andsignatureOrSystem permissions(§2.1)
into one protection level, because they are restrictively used by
specific apps and cannot be accessed by all developers [71].
3.2.2 Results. Table 1 summarizes the evolution of permission
specification from Android 6.0 to 11. Columns 2-4 show that the
numberofpermissionsgenerallyincreasesastheAndroidplatform
evolves,regardlessoftheirprotectionlevels.Signaturepermissionsgrowthefastest,whichisinlinewithpreviouswork[
71].Columns
5-8 show how many API methods are protected by permissions
ofspecificprotectionlevels.NotethatthemappingbetweenAPI
methods and permissions is not bijection. It is possible that an API
requiresmultiplepermissions[ 30],orapermissionisboundtoa
constantfieldratherthananymethods.Columns9-11reportthe
evolution of permission-protected APIs in consecutive versions,
interms oftheiraddition,deletion, andmodification.AsAndroid
platformevolves,morepermission-protectedAPIsareadded.Mean-
while, the numbers of deleted/changed APIs are also increasing.
ThepermissionchangesofAPIsareshowninthelastthreecolumns.
WesayachangedAPIbecomes restricted ifitrequiresapermission
withahigherprotectionlevelinnewversions,and relaxedonthe
contrary.Besides,anAPIcanalsoswitchtoanotherpermissionwith
thesameprotectionlevel(thelastcolumn).Asshownincolumns
12-14,thechangedAPIstendtorestricttheirpermissionsinnew
versions, or change to other permissions with the same protection
level. Only a few require permissions with lower protection levels.
Fromtheresults,wecanseethat dangerouspermissionsand
APIsconstantlyevolvealongwiththeAndroidplatform .For
example,29outofthe580newAPIsrequiredangerouspermissionsinAndroid11,andsevendangerousAPIsaredeletedfromAndroid
10.ForthoseAPIsthatchangetheirrequiredpermissions,20are
related to dangerous permissions (becoming either restricted or
relaxed). As dangerous APIs are commonly used to implement sen-
sitive features, their usages and compatibilities should be carefully
checked to avoid unexpected runtime behaviors.
3.3 RQ2: Impact of Evolution
3.3.1 Analysis Method. TostudyRQ2,wefirstanalyzedalldanger-
ousAPIssinceAPIlevel23.Intotal,therewere246dangerousAPIs
withdifferentmethodsignatures(uptoAPIlevel30).Wefoundthat
188 of them have undergone changes, which account for a large
proportion.Whenusingsuch evolvingdangerousAPIs,developers
shouldcarefullyexaminetherunningdeviceversionsanddealwithTable 2: Top-10 commonly used evolving dangerous APIs
RankDangerous API Used appsDangerous API
(AppId-only)Used apps
(AppId-only)
1 getDeviceId() 4,020 getDeviceId() 592
2 getSerial 3,922 getLine1Number 163
3 setRequireOriginal 2,305 getAccounts 157
4 getCellLocation 1,980 getSubscriberId 139
5 getLine1Number 1,792 onCallStateChanged 91
6 getSubscriberId 1,714 getSimSerialNumber 90
7 getSimSerialNumber 1,257 getSerial 72
8 getImei 1,245 getImei 59
9 getAccounts 968 getCellLocation 54
10 getDeviceId(int) 913 getGpsStatus 44
the permission changes to avoid unexpected program behaviors
(e.g.,crash)[ 40].RQ2aimstoquantifythepotentialimpactofthe
evolving dangerous APIs on real-world apps.
Given an Android app, for each call site of the evolving dan-
gerousAPI,weextractedallpossiblecallingcontexts[ 60],which
are paths in the call graph (CG) starting from an entry method, in-
cluding lifecycle callbacks (e.g., onCreate() ), event handlers (e.g.,
onClick() ),threads’ Runnable.run() ,etc.,andendingwiththat
API.WeusedFlowDroid[ 29]toconstructCGsandidentifyentry
methods. If an app contains calling contexts to an evolving dan-
gerousAPI, wesay theapp usestheAPI. Thisstatic analysismay
produceover-estimated results with infeasible calling contexts.
In particular, the dangerous APIs may be called from third-party
libraries(TPLs)butarenotusedbythehostapps[ 52,54,68,69].To
eliminate the influence of TPLs, we dropped those contexts whose
entry methods lie in packages that are different from the app’s
package ID [ 65]. This strict condition may filter out more contexts
thannecessary(e.g.,whenpackagenamesareobfuscated),hence
producing under-estimated results. To answer RQ2, we analyzed
both the over-estimated and under-estimated results.
3.3.2 Results. Table 2 lists the top-10 commonly used evolving
dangerousAPIs.Theleftpartpresentsthe over-estimatedresults .
Under this setting, the API getDeviceId() is used by 4,020 apps,
rankingatthefirstplace.ThisAPIrequiresadangerouspermission
READ_PHONE_STATE inAPIlevel23to28.Since29,itshouldbeused
with the signature permission READ_PRIVILEGED_PHONE_STATE ,
and thus can no longer be used by general apps. As described inthe documentation [
23], for apps targeting 29 or above, calling
this API will result in a SecurityException . In our dataset, we
found that each app has a median number of three calling contexts
that can reach this API. If developers do not carefully deal with
128
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 07:51:54 UTC from IEEE Xplore.  Restrictions apply. Aper: Evolution-Aware Runtime Permission Misuse Detection for Android Apps ICSE ’22, May 21–29, 2022, Pittsburgh, PA, USA
Figure4:Fourtypesofpermissionmanagements(∗twoentry
methods are distinct callbacks in the same component)
the permission changes in API level 29, the affected apps may
encountercrashesatruntime.Intotal,weobservedthat69outof
the 188 evolving dangerous APIs are used in our dataset and 8,166
(61.2%) of the 13,352 apps use at least one of these APIs.
TherightpartofTable2presentsthe under-estimatedresults .
Even with our strict filtering condition, we still found that 5,387
apps invoke dangerous APIs, while 1,051 (19.5%) of them invoke at
least one evolving dangerous API. In addition, getDeviceId() is
still the most commonly used evolving dangerous API.
In summary, we can see that a largenumber of apps maybe
affected by the evolution of permission specification.
3.4 RQ3: Permission Management Practices
3.4.1 Analysis Method. Ideally, an app should always check the
permissionstatusbeforecallingdangerousAPIs,andrequestthe
permissionsiftheyarenotgranted.Thiscanbeaccomplishedby
callingCHECKandREQUEST APIssynchronouslybeforeeachdan-
gerousAPIcall,asshowninFigure2.TheAndroiddeveloperguide
alsosuggestssucha synchronous permission management [22].
However,synchronouspermissionmanagementcanbeimpeded
by many factors, e.g., developers’ maintaining effort or user experi-enceconcern[
35].Inpractice,developersmaychoosetoimplement
permission management beyond the synchronous way.
Figure 4 illustrates four types of permission managements. In
Figure 4(a) and 4(b), the dangerous API and the corresponding
permissionmanagement APIareinvoked synchronously.The only
differencebetweenthetwocasesisthatthe CHECK/REQUEST is
wrapped in another method call in Figure 4(b). It is noteworthy
that we only consider CHECKandREQUEST APIs here because
they are indispensable for runtime permission management (theother two types of APIs mentioned in § 2.2 are optional). Apart
fromthesynchronousway,developerscancalldangerousAPIsandpermissionmanagementAPIsasynchronouslyindifferentcallbacks
[67],sinceAndroidprogramsareevent-driven[ 44].Forexample,
adangerousAPIandthecorrespondingpermissionmanagement
APIcanbeinvokedfromdifferentcallbacksinthesameappcom-
ponent (Figure 4(c)). It is also possible that dangerous API and the
corresponding permission management API are invoked from the
entrymethodsin twodistinctcomponents withinter-component
communication(ICC)(Figure4(d)).Werefertothelasttwocases
asasynchronous permission management.To study RQ3, wefirst extracted the calling contexts ofdanger-
ous APIs (dangerous contexts ) and permission management APIs
(check/request contexts ) from each of the 13,352 apps. Then we cat-
egorized these contexts into the above-mentioned four types of
permissionmanagements.Forexample,adangerouscontextand
a check context will be considered as the intra-procedure case, if
bothcontextshaveidenticalprefixesexcepttheirlastnodes.Dueto
pagelimit,wedonotfurtherelaborateonothercases.Itisworth
explainingthatadangerouscontextmayhavemultiplematching
checkcontexts.Imaginingthatthereisanothercalltoa CHECKAPI
inside doLocationingActions() inFigure2,thenthedangerous
API called in doLocationingActions() would match both the
intra-proceduralandinter-proceduralchecks.Inthiscase,wewould
match the dangerous API with the closest one, according to theprinciple of locality [
66]. Also note that the same dangerous API
may have different permission mappings in different Android ver-
sions. Here we only consider the mapping in the app’s target SDK
version, which is specified in its manifest file.
Ourstaticanalysisalsoneedstoinferstringvalues.Forexam-
ple, when analyzing the code in Figure 2, we should know the
stringarguments( "ACCESS_FINE_LOCATION" )oftheCHECKand
REQUEST API calls to match the permission management API
calls with the dangerous API call in doLocationingActions() .
Such string analysis is difficult in general [ 37]. However, we ob-
served that developers often employ permission string literals (e.g.,
those defined in the class android.Manifest.permission ) for
permissionmanagements,withoutperformingcomplexstringoper-
ations [49]. Hence, we modeled our string analysis task as a classic
reaching-definition dataflowanalysisproblem[ 26](sisastatement;
Pred(s)returns the predecessor statements of s;gen(s)andkill(s)
are the dataflow facts generated or killed by s, respectively):
IN(s)=/uniondisplay.1
p∈Pred(s)OUT(p) (1)
OUT(s)=gen(s)∪(IN(s)−kill(s)) (2)
When the iterative equation solving converges, the possible string
values on a call site ccan be retrieved from the set IN(c).T oa v o i d
unnecessarycomputation,weonlypropagatedataflowfactsrelated
to string and string array variables.
Most Android-specific analyses, such as identifying app compo-
nents and building intra-component CGs, rely on FlowDroid. To
analyzeICC,weusedtheICClinkextractionrulesintroducedin
IccTA [50]. We did not directly apply the IccTA tool as it relies on
IC3,whichisoutdatedandfailedtoanalyzemostofourapps.To
realize inter-procedural reaching definition analysis, we employed
theIFDSsolverHeros[ 33].Toensurethatthepermissionusages
are implemented in the apps rather than TPLs, we only considered
the calls to dangerousand permission management APIs from the
apps’ packages. 2,402 apps in our dataset satisfy this condition.
3.4.2 Results. Figure5presentsthedangerousAPIcallingcontexts
with respectto the four types of permissionmanagements using
violin plots. For better visualization, we excluded 34 apps with
an extremely large number (over 100) of dangerous API calling
contexts. For ease of understanding, we explain the first violin plot.
The left part of the violin has a median of three, the right part has
a median of two, and the violin is labeled with 465. This means
129
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 07:51:54 UTC from IEEE Xplore.  Restrictions apply. ICSE ’22, May 21–29, 2022, Pittsburgh, PA, USA Sinan Wang, Yibo Wang, Xian Zhan, Ying Wang, Yepang Liu, Xiapu Luo, and Shing-Chi Cheung
Figure 5: Distribution of dangerous API calling contexts
with respect to the four types of permission managements
thatthereare465appsthatimplementintra-proceduralpermission
checksorrequests.Amongtheseapps,amediannumberofthree
dangerousAPIcallingcontextsareprotectedbyintra-procedural
permissionchecks,whileamedianoftwodangerousAPIcalling
contexts have intra-procedural permission requests.
Intuitively, the area of each violin reflects the adoption of the
corresponding permission management practice. For instance, the
right part of the first violin is the smallest, meaning that only a
fewappsrequestpermissionsinsidethesamemethodwherethedangerous APIs are called. In fact, only 114 apps contribute to
this part. The intra-procedural permission checks are also the least
commonasshownintheleftpart.Incontrast,1,621appsadoptinter-
procedural permission managements, which usually happen when
developers wrap the CHECK/REQUEST API calls in self-defined
methods for code reuse (e.g., in Syncthing issue 1575 [21]).
Asynchronous permission managements are more com-
mon than synchronous permission managements : Accord-
ing to the results, 1,813 of the 2,402 apps perform inter-callbackpermissionmanagementand899appsperforminter-componentpermission management. In total, 2,065 out of the 2,402 (86.0%)apps adopt asynchronous permission management. We further
investigated the calling contexts of asynchronous CHECKs andRE-
QUESTs,andfoundthatmostoftheirentrymethodsare onClick()
and onCreate() . There is a large number of REQUEST calls start-
ing from onStart() , in which UI elements are suggested to be
drawn [2]. In these scenarios, users usually receive permission
request dialogs after they click a button that performs sensitiveoperations, or switch to a new activity that requires dangerouspermissions.Notethattheseresultswereobtainedfollowingthe
under-estimation setting discussed in § 3.3.1. We also did the same
analysisfollowingtheover-estimationsettingandobservedsimilar
context distributions. Due to page limit, we omit the details.
Discussions. Asynchronouspermissionmanagementcanavoid
redundant CHECKs andREQUEST s. However, it brings challenges
to developers as they should examine both the dangerous API call
sitesandallrelatedappcomponentstoseewhethertherequired
permissions are already requested and granted. Moreover, they
shouldcarefullyhandlethecasewhentheusersrevokeaparticular
permission required by the dangerous API, since asynchronous
permission requests may be unavailable in this scenario.
Asynchronous permission management practices also compli-
cate ARP bug detection. A conservative detector that considersan app buggy whenever a synchronous CHECKorREQUEST is
missing at a dangerous API call site (e.g., RevDroid [ 41]) may pro-
duce many false alarms, if asynchronous permission management
Figure 6: Overview of Aper
canalreadyprotectthedangerousAPIcall.Furthermore,asusers
mayrevokepermissionsbetweentwoasynchronousevents,howto
determinewhethera CHECKcanprotectasubsequentdangerous
API call is also a technical challenge for static bug detectors. As we
willsee in§5.3, asynchronouspermission managementscanlead
tobothsafepermissionusagesandappcrashes,whichcannotbe
distinguished by existing tools.
4 APER
4.1 Overview
Our empirical study reveals that a large number of real-world apps
perform asynchronous permission managements, which compli-
cates permission checking and may lead to subtle ARP bugs. More-
over,compatibilityissuesmayariseduetotheactivechangesofthe
mappingsbetweendangerousAPIsandtheirrequireddangerous
permissions (API-DP mappings ). To ease subsequent discussion, we
first define two common types of ARP bugs :
•Type-1(MissingPermissionCheck) :AdangerousAPIiscalled
without a permission check on the target Android version.
•Type-2 (Incompatible Permission Usage) :AdangerousAPI
can be called on incompatible platforms, or the evolution of
permission specification is not fully handled.
Accordingto[ 63],thesetwotypesofbugscorrespondtothenon-
library-interfered ARP issues except those caused by device manu-
facturers’customization, whichaccount for60.8% oftheir studied
realARPissues.Existingtoolscannoteffectivelydetectthesetwo
types of common ARP bugs in Android apps. This motivates us to
design a new approach to detect these bugs.
Figure6showstheoverviewofourtool,Aper.IttakesanAn-
droid application package (APK) file and the API-DP mappings as
input,andoutputsthecallingcontextsofdangerousAPIsthathave
potential Type-1 or Type-2 bugs. Its analysis procedure consists of
three components:
(1)TheContext Extractor traverses the CG of an app and per-
forms backward analysis from the call sites of dangerous APIs
andCHECKAPIstoextractallpossiblecallingcontextsofthese
APIs. Similar to our approach in the empirical study, a danger-
ous context will be matched with CHECKcontexts (Figure 4)
according to the API-DP mappings. The only difference here
is that the mappings for all Android versions will be used, in
ordertodetectType-2bugs.Theprocessedcallingcontextswill
be analyzed by the Misuse Detector to locate ARP bugs.
130
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 07:51:54 UTC from IEEE Xplore.  Restrictions apply. Aper: Evolution-Aware Runtime Permission Misuse Detection for Android Apps ICSE ’22, May 21–29, 2022, Pittsburgh, PA, USA
if(Build.VERSION.SDK_INT >= 29 &&
checkSelfPermission(ACCESS_FINE_LOCATION) != GRANTED){
requestPermissions( new String[]{ACCESS_FINE_LOCATION});
return ;
}
p2pManager.createGroup(...); // evolving dangerous API
Figure 7: An Example of Handling API Evolution
(2)In order to know which permissions are checked at each call
site of the CHECKAPI, the Dataflow Analyzer conducts a
reaching definition analysis on the inter-procedural control-
flow graph (ICFG) of the app to infer the possible string values
passedtothe CHECKAPI(§3.4.1).ThishelpsContextExtractor
to match a dangerous context with the CHECKcontexts that
possiblyprotectthedangerousAPIcalls.TodetectType-2bugs,
theDataflowAnalyzeralsoanalyzestheruntimeversion(RV)
checks that guard dangerous API calls to infer reachable RVs
on which the dangerous APIs can be invoked.
(3)TheMisuse Detector leverages the API calling contexts and
dataflowfactsgeneratedbytheothercomponentstolocatebugs.
Theideais:AdangerousAPIcontextwithoutproperpermission
checksmaycontainType-1bugs;AnevolvingdangerousAPI
context without proper RV checks may contain Type-2 bugs.
It is worth noting that Aper does not analyze the usages of
theREQUEST APIs, as the request process is asynchronous and
cannot guard the calls to dangerous APIs. Nonetheless, the Misuse
DetectorwillconsiderthedangerousAPIcallswithinthe HANDLE
callback (§ 4.3), which handles the request results. Most of theanalysesperformedbyAperhavebeendetailedinourempirical
study (§ 3.4.1). In the following, we explain how Aper analyzes RV
checks and detects Type-1/Type-2 bugs.
4.2 Analyzing Reachable Runtime Versions
Figure7showshowthedevelopersofapopularapp, VPNHotSpot [19],
handledtheevolutionofadangerousAPI.StartingfromAPIlevel29,
the API WifiP2pManager.createGroup() requires the danger-
ouspermission ACCESS_FINE_LOCATION ,whileitdoesnotrequire
permissionsinthepreviousAPIlevels.Astheexampleshows,to
invoke the dangerous API on compatible Android versions, theapp first checks the value of the field
Build.VERSION.SDK_INT ,
which is widely used to handle incompatible API usages [51].
Todetectincompatiblepermissionusages,Aperneedstoinfer
thepossibleRVsonwhichadangerousAPIcanbeinvoked.Forthis
purpose, Aper performs dominator analysis [59]. In a flow graph, a
nodeddominates another node nifdexists on every path starting
fromtheentrynodeto n(i.e.,toreach n,itsdominator dmustbe
gone through). In an Android app, if a dangerous API call site is
dominatedbysomeRVchecks,thesechecksthenconstraintheRVs
on which the API can be invoked. We call such RVs reachable RVs.
Algorithm1explainshowAperanalyzesreachableRVs.Givena
dangerous context, Aper analyzes all methods invoked prior to thedangerousAPI(lines2-9)tolookfordominatingRVchecks(line6).
A statement is an RV check if it is a conditional statement and the
conditionreferstotheconstantfield Build.VERSION.SDK_INT2.
WhenanRVcheckisfound,Aperwillsolvetheconstraintinvolved
2This approach may miss some runtime version checks. However, such cases are rare
in practice [51].Algorithm 1: Analyzing reachable RVs
Input:Dangerous API calling context p1/shortrightarrowp2/shortrightarrow···/shortrightarrowpn
(piare call sites, and pncalls a dangerous API)
Output:Set of reachable RVs ⊆{23, ...,LAV†}
1reachableRV /shortleftarrow{23, ...,LAV}
2fori/shortleftarrow1...n-1do
3m/shortleftarrowgetBodyOfCalledMethod( pi)
4dominators /shortleftarrowm.findDominatorsOf( pi+1)
5forstmt∈dominators do
6ifisRvCheck(stmt) then
7 rvs/shortleftarrowsolveAllSatisfiable(stmt)
8 reachableRV /shortleftarrowreachableRV ∩rvs
9returnreachableRV
†: “LAV” stands for the Latest Android Version.
in the condition to find all reachable RVs (line 7). If there exist
multipledominatingRVchecks,Aperwillcomputetheconjunction
of the reachable RVs constrained by each check (line 8).
It should be pointed out that, RV checks may not necessarily
dominate a dangerous API call site in order to protect it. Consider
twoseparateRVchecksintwoparallelprogrambranchesandboth
branchescanleadtothesamedangerousAPIcall.Insuchacase,
neither check dominates the dangerous API call, although it is
guaranteedtobecalledsafely.Toreducealgorithmiccomplexity,
Aper does not take such unusual cases into account.
4.3 Detecting ARP Bugs
TheMisuseDetectordetectsARPbugsbyanalyzingeachdangerous
contextandtwootherpiecesofinformation:1)asetofmatching
CHECKcontexts provided by the Context Extractor, and 2) all
reachableRVsprovidedbytheDataflowAnalyzer.Inthefollowing,
we describe how Aper detects Type-1 and Type-2 bugs in detail.
4.3.1 Detecting Type-1 Bugs. A Type-1 bug occurs when a danger-
ous API is called without permission checks on the target Android
version.Inthemosttrivialcase,aType-1bugcanbereportedwhen
thesetofmatching CHECKcontextsisempty.Ifthesetisnotempty,
we need to analyze whether the CHECKcontexts could safely pro-
tect the dangerous context. There are three cases to consider:
(1)If theCHECKAPI and the dangerous API are synchronously
called,Aperwillexaminewhethertheformer’scallsitedomi-
natesthelatter’sontheICFGandwhetherthedangerousAPI
is reachable from the CHECKAPI’s positive branch.
(2)If theCHECKand dangerous APIs are called in different call-
backs of an app component, Aper will examine whether theCHECKcontext’s entry method precedes the dangerous con-
text’s(e.g., onCreate() mustprecede onStart() ,onResume()
mustprecede onClick() ).IfadangerousAPIiscalledincall-
backAwhilea CHECKiscalledincallbackBthatmustprecede
A, such a permission check is safe. To analyze the execution
order of callbacks, we used the temporal constraints defined by
Liuetal.[ 53]todistinguisherroneousasynchronouspermission
checks from safe cases.
(3)If theCHECKAPI is called in a component c, while the danger-
ousAPIiscalledinanothercomponent c/prime,Aperwillexamine
131
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 07:51:54 UTC from IEEE Xplore.  Restrictions apply. ICSE ’22, May 21–29, 2022, Pittsburgh, PA, USA Sinan Wang, Yibo Wang, Xian Zhan, Ying Wang, Yepang Liu, Xiapu Luo, and Shing-Chi Cheung
whetherthe CHECKAPI’scallsite(morespecifically,itsposi-
tive branch) in cdominates the call site of the ICC method that
launches c/prime.
Ineachcase,ifadangerouscontexthasnodominating CHECKs,
AperwillreportaType-1bug.Toavoidfalsealarms,Aperwillnot
reportbugsin twocases:1)The dangerousAPIcalliswrapped in
atry-catch blockthathandlesthe SecurityException .Some
developersmayusesuchaworkaroundtoavoidappcrashes,instead
ofexplicitlyperformingpermissionchecksbeforecallingdangerous
APIs.2)Insidethe HANDLE callback,thedangerousAPIiscalled
after checking the permission request results. Since the permission
requestresultsarepassedasaparametertothiscallback,developers
canchecktheparametervaluetolearnthepermissionstatusand
invoke dangerous APIs when the permission is granted.
4.3.2 Detecting Type-2 Bugs. A Type-2 bug can occur when a dan-
gerousAPIiscalledonincompatibleAndroidversions(callingnew
APIs on old platforms, or removed APIs on new platforms), or the
permissions required on different versions are not fully handled.
Aper detects Type-2 bugs by examining whether a dangerous API
can be safely called on all reachable RVs, except the app’s targetSDK version, which is already analyzed when detecting Type-1
bugs.Givenadangerouscontext,withacorrespondingreachable
RVv, if the dangerous API does not exist in the API-DP mappings
of the Android version v, then a Type-2 bug can be reported. This
can happen if the API has been deleted or not yet introduced. Ifthe API exists in the mappings, then Aper will analyze whether
theAPIisinvokedwithadominatingcheckofthecorresponding
permission required on the Android version v, which is essentially
thesame asdetecting Type-1bugs. Aperwillreport aType-2 bug
when there are no dominating permission checks.
5 EVALUATION
Our evaluation aims to answer two research questions:
•RQ4(Effectivenessof Aper) :HoweffectiveisAperindetect-
ing ARP bugs, compared with the existing tools?
•RQ5 (Usefulness of Aper) : Can Aper detect unknown ARP
bugs in real-world apps and help developers diagnose them?
Inthefollowing,wepresentourexperimentsandanalyzetheresults
in detail. We also discuss some real ARP bugs detected by Aper.
5.1 RQ4: Effectiveness of Aper
5.1.1 Constructing Benchmark. To study RQ4, our evaluation sub-
jects should contain both Type-1 and Type-2 bugs. More impor-
tantly, to understand how the tools report false alarms, we need
subjectsthatusedangerousAPIscorrectly.Forthispurpose,wecon-
structedabenchmark, ARPfix,leveragingrealARPbugsinopen-
source apps and their patches. Specifically, we collected projectsfrom GitHub [
9] that have both 1) issues related to CHECKAPIs
and dangerous APIs (to identify ARP bugs), and 2) commits or pull
requests that fix the issues (to locate the bug fixes). We found 61
suchprojectswithatotalof71ARPissues,whichcorrespondto71
ARP bugs. For each bug, we then applied the following procedure
on both the buggy version and the patched version: 1) Locating
the related dangerous API; 2) Finding the API’s corresponding per-
mission management code via manual inspection; 3) RemovingTable 3: Comparison results with the existing tools
Type-1 Type-2
LintARPDroid RevDroid Aper Lint Aper
TP 16 13 15 26 14 23
TN 22 22 26 32 15 19
FP 13 13 6 3 10 6
FN 19 22 17 9 11 2
Failed - - 6∗---
Precision (%) 55.17 50.00 71.43 89.6658.3379.31
Recall (%) 45.71 37.14 46.88 74.2956.0092.00
F1-score (%) 50.00 42.62 56.61 81.2557.1485.19
∗RevDroid fails on both versions of the three subjects.
irrelevantappclasses,methods,attributes,andTPLs,untilamin-
imal compilable APK remains. For the ease of experiments, each
APK has only one dangerous API, and thus a buggy APK contains
only one ARP bug. If we could not build an APK, we simply dis-carded that bug. Finally, 60 buggy APKs were successfully built,
among which 35 contain Type-1 bugs and 25 contain Type-2 bugs.
Correspondingly, each buggy APK has its patched version.
5.1.2 Baselines and Metrics. Tothebestofourknowledge,there
are three available static analysis tools that can find ARP bugs:
•Lint [11] is a built-in checker in Android Studio, which is the
officialIDEfordevelopingAndroidapps.Itcanreportmissing
permission checks and RV checks, and we treat these two types
of warnings as Type-1 and Type-2 bugs, respectively.
•ARPDroid[ 40]isanacademictoolforautomaticruntimeper-
mission management. If it inserts permission management state-
ments on any calling context of a dangerous API, we consider
that it detects a Type-1 bug.
•RevDroid [ 41] is also an academic tool, which can detect un-
handled permission revocation on a dangerous API call, and we
treat its warnings as Type-1 bugs.
For fair comparisons, we did not consider testing-based tools (e.g.,
PATDroid[ 58]orSetDroid[ 61])becausetheirperformancesheav-
ily rely on the underlying tests’ coverages.
To answer RQ4, we applied Aper and the three tools on ARP-
fix and compared their performance using the following metrics:•True positives (TP ): # buggy versions that have warnings
•True negatives (TN ): # patched versions that have no warnings
•False positives (FP ): # patched versions that have warnings
•False negatives (FN ): # buggy versions that have no warnings
Basedonthem,wecanfurthercalculate Precision(TP
TP+FP),Recall
(TP
TP+FN), andF1-score (2·P·R
P+R) to measure their effectiveness.
5.1.3 Results and Analyses. Table 3 shows the comparison results.
We can see that Aper outperforms the baselines on all metrics.
For Type-1 bugs, Aper achieves an F1-score of 81.25%, with an im-
provement of 43.5% ( =(81.25-56 .61)/56.61) over RevDroid, which
performedthebestamongthebaselines.AsforType-2bugs,the
improvement of Aper over Lint, which is the only baseline tool
that supports detecting Type-2 bugs, on F1-score is 49.1%. On aver-
age, Aper outperforms existing tools by 46.3% ( =(43.5+49 .1)/2) on
F1-score, indicating its effectiveness on ARP bug detection.
132
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 07:51:54 UTC from IEEE Xplore.  Restrictions apply. Aper: Evolution-Aware Runtime Permission Misuse Detection for Android Apps ICSE ’22, May 21–29, 2022, Pittsburgh, PA, USA
For Type-1bugs, the baselinetools suffer from lowprecisions.
We manually investigated these tools and figured out the main rea-
sons.First,Lintperformsflow-insensitiveanalysisandonlydetects
the presence of CHECKwithout considering the API-DP mappings
orthereturnvalueof CHECK.ForARPDroid,wefoundthatitonly
insertsCHECKs andREQUEST s without properly dealing with the
existingcallstotheseAPIs.Thebestbaseline,RevDroid,leverages
FlowDroidtogenerateanalysisentrypointsandcannothandleICC
well[56].Aswewillseein§5.3,onlyperformingintra-component
analysismayproducemanyfalsealarms.Incomparison,Aperex-
plicitly models both synchronous and asynchronous permission
checks, which greatly improves the precision.
Thebaselinetoolshavelowrecallsonbothtypesofbugs.The
primary reason is the incompleteness of the API-DP mappings,
which is also a major reason for Aper’s low recall on Type-1 bugs.
Forexample,theAPI Camera.open() doesnotspecifyanypermis-
sioninthedocumentation,andthusisnotcoveredinourmappings.However, in practice, apps would request the user to grant
CAMERA
permission before invoking it [ 14]. Another reason is that some
issuesinourbenchmarkarerelatedtocontentproviders.Currently,neither the baselines nor Aper can analyze the behavior of content
providers. We will address the limitations of Aper in the future.
5.2 RQ5: Usefulness of Aper
5.2.1 Collecting Real-World Apps. ToanswerRQ5,wecollected214
appsfromF-Droid[ 7],awidelyusedopen-sourceappcatalogue,to
seewhetherApercandetectARPbugsfromreal-worldapps.Theseappswereselectedfollowingthreecriteria:1)invokingatleastone
dangerousAPI,2)containingidentifiable CHECKsorREQUEST s,
and 3) having commit records in the recent three years in their
coderepository.Weonlyperformedexperimentsonopen-source
apps because we need the source code to verify the detected bugs,
manuallyreproduceappcrashes,andcommunicatewiththeapp
developerstoinvestigatewhetherAperisuseful.Itshouldbenoted
that Aper can also help detect bugs in closed-source apps.
5.2.2 Study Method. We ran Aper on the 214 apps, and manually
verifieditsreportedARPbugs.Wefirstinvestigatedthereported
contexts to see if Aper was functionally correct. Then, we tried
toreproduceabnormalbehaviorsbasedonthegivencontext.For
example, if Aper reports a Type-1 bug on BackupActivity ,w e
would launchthe app, goto its backup page,then revoke thecon-
cerned permission(s) in the system settings, and go back to theapp. Typically the app would crash (or behave abnormally) after
were-enteringit.However,ifwecouldnotfindthedesiredpage
(e.g.,the BackupActivity )afterthoroughlyexploringtheapp,we
treatedthiscaseasunverified.AsforType-2bugs,wewouldverify
them under a similar procedure with Type-1 bugs, but on multiple
Android devices. Our main focus was whether their runtime be-
haviorswereconsistentacrossdifferentAndroidversions.Weused
13 Android devices, most of which run the stock Android systems
with API levels ranging from 23 to 30.
OnceweverifiedanARPbug,wereportedittothedevelopers
via the issue tracking system links provided on F-Droid. To help
developersdiagnosethebugs,werecordedvideosandappended
themtothebugreports,ifwecouldreproducethem.Forsomebugs,
we also sent our suggested patches to the developers to fix them.Table 4: Summary of detected ARP bugs
Detected Verified Reported Confirmed Fixed # Videos
Type-1 66 23 20 12 3 21
Type-2 18 11 10 5 4 3
Ethical Considerations .Toavoidspammingtheopen-source
community and the developers, we reported an issue only when it
couldbereproducedonatleastthreedifferentAndroiddevices,and
submitted pull requests only after we had thoroughly tested the
patched code.All issuereports andpull requestsweresubmitted in
compliance with the projects’ contributing guidelines and licenses.
5.2.3 Results. Table4summarizestheARPbugsdetectedbyAper.
Among the 84 detected ARP bugs, we identified 23 true Type-1
bugs and11 trueType-2 bugs.Wereported 30of the34 truebugs.
We did not report the other four bugs because the issue tracking
systemsofthecorrespondingappswereclosedatthetimewhen
we conducted the experiments. Nonetheless, we still put the bug
reproductionvideosonourprojectsite.Atthetimeofour paper
acceptance,17ofourreportedbugshavebeenconfirmedandseven
bugs have been fixed. Specifically, three bugs were fixed by our
suggested patches. Interestingly, two of the fixed bugs are in TPLs:
ACRA[1] andKAHelpers [8]. Both of them are popular on GitHub
(with 5.7k and 520 stars, respectively). During our manual bug
verification, we found that Aper reported ARP bugs in them when
analyzing the host apps. After analyzing the root causes of the
bugs,wedecidedtoreportthemtothelibrarydevelopers,rather
than the app developers. Such a case will be discussed in § 5.3.3.In total, 24 videos were successfully recorded. Among them, 20
videos recorded test cases that trigger app crashes, two were about
program stuck and the remaining two were inconsistent behaviors
on different Android devices. Each test case was constructed by us
intypicallylessthantenminutes,afterexaminingAper’soutput
andtheapp’ssourcecode.TheseresultsshowthatApercandetect
real ARP bugs and produce useful debugging information.
21detectedbugsarefalsealarms.Amajorityofthemarecaused
by specific API usages. For example, 13 bugs are related to the dan-
gerous API getExternalStorageDirectory() , which returns a
directorypathintheexternalstorage.Arecommendedwaytoexam-inethispath’sreadabilityistocheckthe
READ_EXTERNAL_STORAGE
permission[ 3].However,developersmayalsouseotherAPIsforthe
samepurpose,suchas file.canRead() inJDK.Inthissituation,
AperwillreportaType-1bugforlackof CHECKAPIs,althoughthe
fileaccessissafe.Wefailedtoverifytheremainingbugsbecause
triggeringthemrequirescomplicatedsetupsorinteractions(e.g.,
triggeringa bugin Kore[ 24]requires aconnected Kodiplayer).It
is worth noting that these unverified bugs are not necessarily false
alarms.
5.3 Case Studies
Inthissubsection,wediscussseveraltypicalcasesobservedduring
our study to facilitate the design of future tools.
5.3.1 A Type-1 ARP Bug. Figure8 showsaType-1bugcaused by
inter-component permission usage. It was found in ML Manager
[15],anopen-sourceappmanagerwith100K+installsonGoogle
133
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 07:51:54 UTC from IEEE Xplore.  Restrictions apply. ICSE ’22, May 21–29, 2022, Pittsburgh, PA, USA Sinan Wang, Yibo Wang, Xian Zhan, Ying Wang, Yepang Liu, Xiapu Luo, and Shing-Chi Cheung
request storage permission
click “allow”
click “delete files”
success
Revoke storage permission
success
alt
click “delete files”
crashŚ ś Ŝ
ŚMainActivity
śSettingsActivity
ŜSystem settings
Figure 8: An inter-component Type-1 bug in ML Manager
void onCreate(Bundle bundle){
// ...
if(isSdCardPermissionNotGranted())
requestSdCardPermissions();
else {
intent = new Intent(DirectoryPickerActivity);
startActivity(intent);
}
}
Figure9:Asafeinter-componentARPusageinTrickyTrip-
per (in class SaveToSdCardActivity, simplified)
Play. Normally, the user grants the storage permission in the app’s
MainActivity , and then the app can delete cached files when the
user operates in the SettingsActivity . However, because the
lattercomponentdoesnotinvolve CHECKsorREQUEST s,oncethe
userrevokesthestoragepermissionafterenteringit,theappcan
nolongeraccessthedevice’sexternalstorage.Insuchascenario,
deleting files will result in a crash. This bug was fixed in the app’s
2.5.2 version. Developers added CHECKin the button click listener
to avoid unprotected storage access. We found that three out of
the four tools could detect this bug, except Lint, since the app has
CHECKstatements in other unrelated components.
5.3.2 A Safe Inter-Component ARP Usage. Static analyzers may
reportfalsealarmsonsafeinter-componentARPusages.Figure9
shows such an example from the app Tricky Tripper [16]. The
DirectoryPickerActivity displays the file directory and thus
needsstoragepermission.Thisactivitycanonlybelaunchedwhenthe permission is granted, so the usage is safe. However, both ARP-DroidandRevDroidwouldreportthelackofpermissionmanage-mentin
DirectoryPickerActivity .Incontrast,Apercanavoid
thisFPby resolving the ICC between the two components.
5.3.3 A Type-2 Bug in TPLs. Aswediscussed,somebugscanoccur
in TPLs. Instead of blaming the host apps, we reported these issues
tothelibrarydevelopers.Figure10showsourpullrequestinthe
libraryACRA, written in Kotlin language, which fixes the issue
caused by the evolution of the dangerous API getDeviceId() .override fun collect(...) {
// ...
− target.put(ReportField.DEVICE_ID, telephonyManager.deviceId)
+ val deviceId = if(SDK_INT<=28) telephonyManager.deviceId else null
+ target.put(ReportField.DEVICE_ID, deviceId)
}
Figure 10: Pull request #890 in ACRA library (simplified)
After compilation, the expression telephonyManager.deviceId
istransformedintothisdangerousAPI.TheAPI getDeviceId()
is commonly used in real-world apps, as shown in Table 2. Since
API level 29, many apps may throw a SecurityException when
invokingthisAPIbecauseitstartstorequireasignaturepermission,
which is not available to general apps. To avoid app crashes, we
enforce the API to be called under API level 29, and the API will
return a nullvalue on newer Android versions. This patch has
beenapprovedbytheprojectmaintainer,andwillbemergedtothe
next release of the library.
5.3.4 An Intended Permission Misuse. In fact, not all detected bugs
areconsideredharmfulfromthedevelopers’perspectives.Forex-
ample, the API getConfiguredNetworks() starts to require fine-
locationpermissionsinceAPIlevel29.In NetGuard [17],anInternet
firewall app with over five million installs, Aper reported that this
APIcalllackspermissionchecksonAPIlevel29andabove.Theapp
developerconfirmedthisistrue[ 5].However,forprivacyconcerns,
theydonotwanttheirapptorequestthelocationpermission.They
would rather disable the related features.
6 THREATS TO VALIDITY
The validity of our study results is subject to the following threats:
•Incomplete API-permission mappings. We built the map-
pings between APIs and permissions via analyzing the annotationsand Javadocs in the source code of the Android framework. We didnotdirectlyusemappingsfrompreviousworkduetothefollowing
reasons: 1) As the Android platform constantly evolves, existing
mappings can quickly become outdated. For example, Arcade [ 25]
only released the mappings up to API level 25, while the mostrecent work, Dynamo [
38], only released mappings for two API
levels,23and29.2)Themappingextractiontoolsareunavailable
or difficult to use. 3) The existing mappings are either imprecise
orincomplete,aspointedoutby[ 38].AnexampleisPScout[ 30],
which was claimed to contain at most 7% incorrect mappings. In
contrast, although our approach may extract incomplete mappings,
theyarepreciseand,moreimportantly,up-to-datewiththelatest
Android version.
•False positives in the extracted contexts. Extractingalldan-
gerousAPI callingcontextstounderstand theARPpracticesmay
leadtofalsepositives.Tomitigatethethreat,weproposedtheunder-
estimation setting which only considers entry methods within the
app’s package. We also performed manual validation by sampling
appsfromF-Droidandinspectingtheirextractedcontextstoensure
the precision of our analysis.•Benchmark may not be comprehensive.
It is hard to thor-
oughly understand the buggy code and the patches in our selected
open-sourceapps.Thus,ourbenchmarkmaynotfullyreflectthede-
velopers’usagesofdangerousAPIsortheirpracticesofpermission
management. To address the threat, two authors worked together
to understand the bugs/patches and built ARPfix. We also made it
134
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 07:51:54 UTC from IEEE Xplore.  Restrictions apply. Aper: Evolution-Aware Runtime Permission Misuse Detection for Android Apps ICSE ’22, May 21–29, 2022, Pittsburgh, PA, USA
publiclyavailable.Wehopethatfutureresearcherscanhelpfurther
improve ARPfix, which may benefit the whole community.
7 RELATED WORK
We discuss three categories of related work in this section.
•Mining Permission Specification. Building reliable Android
permission specification has been extensively studied for many
years [25,30–32,34,38,42,47]. Most existing studies employed
either dynamic analyses (e.g., Stowaway [ 42]) or static analyses
(e.g., PScout [ 30]) to find API-permission mappings. Among them,
Stowaway, Copes [ 32], PScout and Axplorer [ 31] were proposed
before the adoption of the runtime permission model. Arcade [ 25]
is a static approach proposed in 2018 for extracting permission
specification.Itaddressed theissueof imprecisemappingbyhan-
dlingpath-sensitivityintheAPIs.Itsmappingconsidersnotjust
thepermissionprotection,butothersecurityattributes(e.g.,API
caller’s UID/PID). Dynamo [ 38] is a dynamic approach that ex-
tracts permission mappings through API fuzzing. In their paper,
theauthorsstatedthatonly76.1%ofthecommonAPIsreportedbyDynamoandArcadehavematchingsecuritychecks.SinceDynamo
buildspermissionmappingsthroughdynamictesting,itsresultis
supposedtobemoreprecise.However,theseexistingmappingsare
either outdated or incomplete: Arcade released the mappings upto API level 25, Dynamo only released the mappings in two API
levels, 23 and 29.
OurmappingextractionwasinspiredbyDPSpec[ 34],whichalso
extracts mappings from the annotations and Javadocs of the An-
droid framework APIs. However, their mappings were unavailable,
and that was the reason we extracted the mappings by ourselves.•Runtime Permission Migration.
Since the emergence of An-
droid6.0,manyattemptshavebeenmadetomigratelegacyapps
to the new runtime permission model. Most of them applied static
analysis on an app’s ICFG (or other variants) to decide proper
programlocationstoinsertcallstopermissionmanagementAPIs.
ARPDroid[ 40]insertscallstothe CHECK,REQUEST,and HANDLE
APIs into its identified incompatible permission-responsible callers.
However,itdoesnotproperlydealwiththeexisting CHECKand
REQUEST API call sites, and thus suffers from low precision and
recall. Gasparis et al.[ 45] pointed out that most developers consid-
eredmigratingtotheruntimepermissionmodeltobelaborious.To
easemigration,theyproposedDroidM+tomigratelegacyapps
with comprehensive runtime permission managements.
Previous methods were proposed under the assumption that the
apps under processing target legacy platforms, thus they chose
to actively insert calls to permission management APIs whenever
a dangerous API call site lacks permission management. In com-
parison,Aperonlyreportsthosedangerouscontextsthatarenot
dominated by permission or RV checks. It helps developers findpotential ARP bugs in their apps and avoid unexpected runtime
behaviors, such as crashes.•ARPBugDetection.
Runtimepermissionmigrationhasbecome
less important in recent years as most apps have targeted new
Android versions [ 18]. However, various ARP bugs are still lurking
inappsanddifferenttechniqueshavebeenproposedtodetectthem.
RevDroid[ 41]appliesreachabilityanalysisontheCGofanapp
to detect unexpected consequences after permission revocations.Huangetal.proposedastaticmethodtodetectstubbornpermission
request [46], which repeatedly spawns a request dialog until the
usergrantsthatpermission.TheyalsoappliedreachabilityanalysisontheCGtodetectsuchbehaviors.UnlikeAper,thesestaticmeth-
odsdonotfullyconsiderasynchronouspermissionmanagement,
which is a common practice for app developers as revealed by our
empiricalstudy.RTPDroid[ 70]candetectthelackofpermission
checksbeforesensitiveoperations.However,thework’smainfocus
is onmodelingand detectingimplicitly maliciousbehaviors, thus
falls into the security perspective. We did not compare Aper with
RTPDroid because the tool is not publicly available.
PATDroid [58] applies hybrid analysis on an app to find crash-
triggering test cases and permission combinations. Terminator
[57]alsodetectspermissionmisusesviahybridanalysis,butitfo-
cuses onsecurity issues. SetDroid [ 61] candetect system setting-
relatedbugsbyinjectingsetting-alteringactionsinthetestevent
sequences. It is capable of finding bugs caused by permission revo-
cation. However, the performances of these test-driven approaches
heavily rely on the underlying tests’ coverage. Aper, as a static
detector, models the permission usages and managements as four
types of API invocation relations and comprehensively analyzes
the existences of two types of ARP bugs.
Tothebestofourknowledge,Aperisthefirsttoolthatisable
to detect ARP bugs caused by evolving permission specification.
Moreover, its modeling of the dangerous API calls and permission
managementshelpsreducefalsealarmsandprovideeffectivede-
bugging information, as we have shown in the experiments.
8 CONCLUSION AND FUTURE WORK
In this paper, we studied the evolution of Android permission spec-
ification and real-world developers’ permission management prac-
tices, via analyzing the Android framework source code and 13,352
top-ranked Android apps. We found that both evolving dangerous
APIs and asynchronous permission managements are widely used
byreal-worldapps,whichpotentiallybringARPbugsbutcannot
be detected by existing tools. To detect the two types of ARP bugs,
we proposed Aper, a new static analysis-based permission misuse
analyzer. We evaluated Aper with control experiments on a bench-mark prepared by us, and an in-the-wild study on 214 open-source
Android apps. The results show that Aper can significantly outper-
form existing tools, and find real bugs in popular Android projects
withusefuldebugginginformation.Inthefuture,weplantoextend
Apertosupportmoretypesofruntimepermissionbugs,suchas
library-induced [39] or device-specific [65] bugs.
ACKNOWLEDGMENTS
We would like to thank ICSE 2022 reviewers for their comments
and suggestions, which helped improve this paper. This work is
partially supported by the National Natural Science Foundation of
China(GrantNos.61932021,61802164,61902056),GuangdongBasic
and Applied Basic Research Fund (Grant No. 2021A1515011562),
GuangdongProvincialKeyLaboratory(GrantNo.2020B121201001),
HongKongGRFProject(No.16211919),HongKongRGCProject
(No. PolyU15223918), the Innovation and Technology Commis-
sion of Hong Kong (Innovation and Technology Fund MHP/055/19,
PiH/255/21).
135
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 07:51:54 UTC from IEEE Xplore.  Restrictions apply. ICSE ’22, May 21–29, 2022, Pittsburgh, PA, USA Sinan Wang, Yibo Wang, Xian Zhan, Ying Wang, Yepang Liu, Xiapu Luo, and Shing-Chi Cheung
REFERENCES
[1]2021.ACRA/acra. RetrievedAugust23,2021fromhttps://github.com/ACRA/acra
[2]2021. Activity | Android Developers. Retrieved August 16, 2021 from https:
//developer.android.com/reference/android/app/Activity#onStart()
[3]2021. android-AccessinggetExternalStorageDirectory-StackOverflow. Re-
trieved August 27, 2021 from https://stackoverflow.com/questions/34865206/
[4]2021. Android Apps on Google Play. Retrieved January 29, 2021 from https:
//play.google.com/store/apps
[5]2021. [APP][6.0+] NetGuard - No-root firewall | Page 635 | XDA Forums. Re-
trieved July 8, 2021 from https://forum.xda-developers.com/t/app-6-0-netguard-
no-root-firewall.3233012/post-85296183
[6]2021. below 23 android xiaomi devices permission - Stack Overflow. Retrieved
July 2, 2021 from https://stackoverflow.com/a/39655365/14233132
[7]2021. F-Droid - Free and Open Source Android App Repository. Retrieved
January 28, 2021 from https://f-droid.org/
[8]2021. FunkyMuse/KAHelpers. Retrieved September 1, 2021 from https://github.
com/FunkyMuse/KAHelpers
[9] 2021. GitHub. Retrieved August 3, 2021 from https://github.com/
[10]2021. Google Play Ranking | AppBrain. Retrieved July 27, 2021 from https:
//www.appbrain.com/stats/google-play-rankings/
[11]2021. Improve your code with lint checks | Android Developers. Retrieved
August 23, 2021 from https://developer.android.com/studio/write/lint
[12]2021. Issue #202 of project WiFiAnalyzer. Retrieved July 5, 2021 from https:
//github.com/VREMSoftwareDevelopment/WiFiAnalyzer/issues/202
[13]2021. Issue #2110 of project k-9. Retrieved July 25, 2021 from https://github.
com/k9mail/k-9/issues/2110
[14]2021. java-cannotopencamera"0"withoutcamerapermission-StackOverflow.
Retrieved August 23, 2021 from https://stackoverflow.com/questions/67553067
[15] 2021. javiersantos/MLManager. Retrieved August 23, 2021 from https://github.
com/javiersantos/MLManager
[16]2021. koelleChristian/trickytripper. Retrieved August 23, 2021 from https:
//github.com/koelleChristian/trickytripper
[17]2021. M66B/NetGuard. Retrieved August 23, 2021 from https://github.com/
M66B/NetGuard
[18]2021. Meet Google Play’s target API level requirement | Android Developers.
Retrieved Decemeber 29, 2021 from https://developer.android.com/google/play/
requirements/target-sdk
[19]2021. Mygod/VPNHotspot. Retrieved August 22, 2021 from https://github.com/
Mygod/VPNHotspot
[20]2021. PermissionsupdatesinAndroid11|AndroidDevelopers. RetrievedJuly5,
2021 from https://developer.android.com/about/versions/11/privacy/permissions
[21]2021. Pull request #1575 of project syncthing-android. Retrieved August 16,
2021 from https://github.com/syncthing/syncthing-android/pull/1575/files
[22]2021. Requestapppermissions|AndroidDevelopers. RetrievedJuly28,2021
from https://developer.android.com/training/permissions/requesting
[23]2021. TelephonyManager | Android Developers. Retrieved Au-
gust16,2021fromhttps://developer.android.com/reference/android/telephony/
TelephonyManager#getDeviceId()
[24]2021. xbmc/Kore. RetrievedSeptember 2,2021from https://github.com/xbmc/
Kore
[25]YousraAafer,GuanhongTao,JianjunHuang,XiangyuZhang,andNinghuiLi.
2018. Precise Android API Protection Mapping Derivation and Reasoning. In
Proceedingsofthe2018ACMSIGSACConferenceonComputerandCommunications
Security(Toronto, ON, Canada). ACM, 1151–1164.
[26]AlfredV.Aho,MonicaS.Lam,RaviSethi,andJeffreyD.Ullman.2007. Compilers:
Principles,Techniques,andTools (2ndEdition). Pearson Education,Inc.Addison-
Wesly, New York, NY, USA.
[27]Kevin Allix, Tegawendé F. Bissyandé, Jacques Klein, and Yves Le Traon. 2016.
AndroZoo: Collecting Millions of Android Apps for the Research Community. In
Proceedingsofthe13thInternationalConferenceonMiningSoftwareRepositories
(Austin, TX, USA). ACM, 468–471.
[28]PanagiotisAndriotis,MartinaAngelaSasse,andGianlucaStringhini.2016. Per-
missionsSnapshots:AssessingUsers’AdaptationtotheAndroidRuntimePer-
mission Model. In 2016 IEEE International Workshop on Information Forensics and
Security (WIFS) (Abu Dhabi, United Arab Emirates). IEEE, 1–6.
[29]Steven Arzt, Siegfried Rasthofer, Christian Fritz, Eric Bodden, Alexandre Bartel,
Jacques Klein, Yves Le Traon, Damien Octeau, and Patrick D. McDaniel. 2014.
FlowDroid: Precise Context, Flow, Field, Object-sensitive and Lifecycle-aware
Taint Analysis for Android Apps. In Proceedings of the 35th ACM SIGPLAN Con-
ferenceonProgrammingLanguageDesignandImplementation (Edinburgh,United
Kingdom). ACM, 259–269.
[30]Kathy Wain Yee Au, Yi Fan Zhou, Zhen Huang, and David Lie. 2012. PScout:
analyzingthe Androidpermission specification.In Proceedingsof the2012 ACM
Conference on Computer and Communications Security (Raleigh, NC, USA). ACM,
217–228.
[31]MichaelBackes,SvenBugiel,ErikDerr,PatrickMcDaniel,DamienOcteau,and
SebastianWeisgerber.2016. OnDemystifyingtheAndroidApplicationFrame-
work: Re-Visiting Android Permission Specification Analysis. In 25th USENIXSecurity Symposium (Austin, TX, USA). USENIX Association, 1101–1118.
[32]AlexandreBartel,JacquesKlein,YvesLeTraon,andMartinMonperrus.2012. Au-
tomaticallySecuringPermission-basedSoftwarebyReducingtheAttackSurface:
An Application to Android. In Proceedings of the 27th IEEE/ACM International
ConferenceonAutomatedSoftwareEngineering (Essen,Germany).ACM,274–277.
[33]EricBodden.2012. Inter-ProceduralData-FlowAnalysiswithIFDS/IDEandSoot.
InProceedings of the ACM SIGPLAN International Workshop on State of the Art in
Java Program Analysis (Beijing, China). ACM, 3–8.
[34]Denis Bogdanas. 2017. Dperm: Assisting the Migration of Android Apps to
Runtime Permissions. CoRRabs/1706.05042 (2017). arXiv:1706.05042
[35]BramBonné,SaiTejaPeddinti,IgorBilogrevic,andNinaTaft.2017. Exploring
Decision Making with Android’s Runtime Permission Dialogs Using In-context
Surveys.In ThirteenthSymposiumonUsablePrivacyandSecurity (SantaClara,
CA, USA). USENIX Association, 195–210.
[36]PaoloCalciati,KonstantinKuznetsov,AlessandraGorla,andAndreasZeller.2020.
Automatically Granted Permissions in Android Apps: An Empirical Study on
TheirPrevalence andonthe PotentialThreatsforPrivacy.In Proceedingsof the
17thInternationalConferenceonMiningSoftwareRepositories (Seoul,Korea).ACM,
114–124.
[37]Aske Simon Christensen, Anders Møller, and Michael I. Schwartzbach. 2003.Precise Analysis of String Expressions. In Static Analysis, 10th International
Symposium (San Diego, CA, USA). Springer, 1–18.
[38]AbdallahDawoudandSvenBugiel.2021. BringingBalancetotheForce:Dynamic
Analysis of the Android Application Framework. In 28th Annual Network and
Distributed System Security Symposium (virtually). The Internet Society.
[39]MichalisDiamantaris,EliasP.Papadopoulos,EvangelosP.Markatos,SotirisIoan-nidis,andJasonPolakis.2019. REAPER:Real-timeAppAnalysisforAugmenting
the Android Permission System. In Proceedings of the Ninth ACM Conference on
Data and Application Security and Privacy (Richardson, TX, USA). ACM, 37–48.
[40]Malinda Dilhara, Haipeng Cai, and John Jenkins. 2018. Automated Detectionand Repair of Incompatible Uses of Runtime Permissions in Android Apps. InProceedings of the 5th International Conference on Mobile Software Engineering
and Systems (Gothenburg, Sweden). ACM, 67–71.
[41]Zheran Fang, Weili Han, Dong Li, Zeqing Guo, Danhao Guo, Xiaoyang Sean
Wang,ZhiyunQian,andHaoChen.2016. RevDroid:CodeAnalysisoftheSide
EffectsafterDynamicPermissionRevocationofAndroidApps.In Proceedings
ofthe11thACMonAsiaConferenceonComputerandCommunicationsSecurity
(Xi’an, China). ACM, 747–758.
[42]AdriennePorterFelt,ErikaChin,SteveHanna,DawnSong,andDavidA.Wagner.2011.AndroidPermissionsDemystified.In Proceedingsofthe18thACMConference
onComputerandCommunicationsSecurity (Chicago,Illinois,USA).ACM,627–
638.
[43]Adrienne Porter Felt, Elizabeth Ha, Serge Egelman, Ariel Haney, Erika Chin, and
David Wagner. 2012. Android Permissions: User Attention, Comprehension, and
Behavior. In Proceedings of the Eighth Symposium on Usable Privacy and Security
(Washington, DC, USA). ACM, 1–14.
[44]Joshua Garcia, Mahmoud Hammad, Negar Ghorbani, and Sam Malek. 2017. Au-
tomaticGenerationofInter-ComponentCommunicationExploitsforAndroid
Applications. In Proceedings of the 2017 11th Joint Meeting on Foundations of
Software Engineering (Paderborn, Germany). ACM, 661–671.
[45]Ioannis Gasparis, Azeem Aqil, Zhiyun Qian, Chengyu Song, Srikanth V. Krishna-
murthy,RajivGupta,andEdwardColbert.2018. DroidM+:DeveloperSupport
forImbibingAndroid’sNewPermissionModel.In Proceedingsofthe2018onAsia
ConferenceonComputerandCommunicationsSecurity (Incheon,Korea).ACM,
765–776.
[46]Jianmeng Huang, Wenchao Huang, Fuyou Miao, and Yan Xiong. 2018. Detecting
Stubborn Permission Requests in Android Applications. In 2018 4th International
ConferenceonBigDataComputingandCommunications (Chicago,IL,USA).IEEE,
84–89.
[47]Md Yasser Karim, Huzefa H. Kagdi, and Massimiliano Di Penta. 2016. Mining
Android Apps to Recommend Permissions. In IEEE 23rd International Conference
on Software Analysis, Evolution, and Reengineering (Suita, Osaka, Japan). IEEE,
427–437.
[48]PatrickLam,EricBodden,OndrejLhoták,andLaurieHendren.2011. TheSoot
Framework for Java Program Analysis: A Retrospective. In Cetus Users and
Compiler Infastructure Workshop (CETUS 2011).
[49]DingLi,YingjunLyu,MianWan,andWilliamG.J.Halfond.2015. StringAnalysis
for Java and Android Applications. In Proceedings of the 2015 10th Joint Meeting
on Foundations of Software Engineering (Bergamo, Italy). ACM, 661–672.
[50]LiLi,AlexandreBartel,TegawendéF.Bissyandé,JacquesKlein,YvesLeTraon,
Steven Arzt, Siegfried Rasthofer, Eric Bodden, Damien Octeau, and Patrick D.
McDaniel.2015. IccTA:DetectingInter-ComponentPrivacyLeaksinAndroid
Apps.In37thIEEE/ACMInternationalConferenceonSoftwareEngineering,ICSE
2015, , May 16-24, 2015, Volume 1 (Florence, Italy). IEEE, 280–291.
[51]Li Li, Tegawendé F. Bissyandé, Haoyu Wang, and Jacques Klein. 2018. CiD:
Automating the Detection of API-Related Compatibility Issues in Android Apps.
InProceedings of the 27th ACM SIGSOFT International Symposium on Software
136
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 07:51:54 UTC from IEEE Xplore.  Restrictions apply. Aper: Evolution-Aware Runtime Permission Misuse Detection for Android Apps ICSE ’22, May 21–29, 2022, Pittsburgh, PA, USA
Testing and Analysis (Amsterdam, Netherlands). ACM, 153–163.
[52]Menghao Li, Wei Wang, Pei Wang, Shuai Wang, Dinghao Wu, Jian Liu, Rui Xue,
and Wei Huo. 2017. LibD: Scalable and Precise Third-Party Library Detection in
Android Markets. In Proceedings of the 39th International Conference on Software
Engineering (Buenos Aires, Argentina). IEEE, 335–346.
[53]YepangLiu,ChangXu,Shing-ChiCheung,andValerioTerragni.2016. Under-
standing and Detecting Wake Lock Misuses for Android Applications. In Pro-
ceedings of the 2016 24th ACM SIGSOFT International Symposium on Foundations
of Software Engineering (Seattle, WA, USA). ACM, 396–409.
[54]Ziang Ma, Haoyu Wang, Yao Guo, and Xiangqun Chen. 2016. LibRadar: Fast and
Accurate Detection ofThird-party Libraries in Android Apps.In Proceedings of
the38thInternationalConferenceonSoftwareEngineeringCompanion (Austin,TX,
USA). ACM, 653–656.
[55]MeiyappanNagappanandEmadShihab.2016. FutureTrendsinSoftwareEngi-
neering Research for Mobile Apps. In 2016 IEEE 23rd International Conference on
Software Analysis, Evolution, and Reengineering (Osaka, Japan). IEEE, 21–32.
[56]Lina Qiu, Yingying Wang, and Julia Rubin. 2018. Analyzing the Analyzers:
FlowDroid/IccTA, AmanDroid, and DroidSafe. In Proceedings of the 27th ACM
SIGSOFT International Symposium on Software Testing and Analysis (Amsterdam,
Netherlands). ACM, 176–186.
[57]Alireza Sadeghi, Reyhaneh Jabbarvand, Negar Ghorbani, Hamid Bagheri, andSam Malek. 2018. A Temporal Permission Analysis and Enforcement Frame-
work for Android. In Proceedings of the 40th International Conference on Software
Engineering (Gothenburg, Sweden). ACM, 846–857.
[58]Alireza Sadeghi, Reyhaneh Jabbarvand, and Sam Malek. 2017. PATDroid:
Permission-Aware GUITesting ofAndroid. In Proceedingsof the2017 11thJoint
Meeting on Foundations of Software Engineering (Paderborn, Germany). ACM,
220–232.
[59]Wei Song, JingZhang, andJeff Huang. 2019. ServDroid: DetectingServiceUsage
Inefficiencies in Android Applications. In Proceedings of the 2019 27th ACM Joint
Meeting on European Software Engineering Conference and Symposium on the
Foundations of Software Engineering (Tallinn, Estonia). ACM, 362–373.
[60]WilliamN.Sumner,YunhuiZheng,DasarathWeeratunge,andXiangyuZhang.
2012. Precise Calling Context Encoding. IEEE Transactions on Software Engineer-
ing38, 5 (2012), 1160–1177.
[61]Jingling Sun, Ting Su, Junxin Li, Zhen Dong, Geguang Pu, Tao Xie, and Zhen-dong Su. 2021. Understanding and Finding System Setting-Related Defects in
Android Apps. In Proceedings of the 30th ACM SIGSOFT International Symposium
on Software Testing and Analysis (Virtual, Denmark). ACM, 204–215.[62]Haoyu Wang, Yao Guo, ZihaoTang, Guangdong Bai, and Xiangqun Chen. 2015.
Reevaluating Android Permission Gaps with Static and Dynamic Analysis. In
2015 IEEE Global Communications Conference (San Diego, CA, USA). IEEE, 1–6.
[63]Ying Wang, Yibo Wang, Sinan Wang, Yepang Liu, Chang Xu, Shing-Chi Che-ung, Hai Yu, and Zhiliang Zhu. 2021. Runtime Permission Issues in Android
Apps: Taxonomy, Practices, and Ways Forward. CoRRabs/2106.13012 (2021).
arXiv:2106.13012
[64]Lili Wei, Yepang Liu, and Shing-Chi Cheung. 2017. OASIS: Prioritizing Static
AnalysisWarningsforAndroidAppsBasedonAppUserReviews.In Proceedings
of the 2017 11th Joint Meeting on Foundations of Software Engineering (Paderborn,
Germany). ACM, 672–682.
[65]LiliWei,Yepang Liu,andShing-Chi Cheung.2019. Pivot: LearningAPI-Device
Correlations to Facilitate Android Compatibility Issue Detection. In Proceed-
ings of the 2019 IEEE/ACM 41st International Conference on Software Engineering
(Montreal, QC, Canada). IEEE, 878–888.
[66]YingfeiXiong,JieWang,RunfaYan,JiachenZhang,ShiHan,GangHuang,andLu
Zhang.2017. PreciseConditionSynthesisforProgramRepair.In Proceedingsof
the2017IEEE/ACM39thInternationalConferenceonSoftwareEngineering (Buenos
Aires, Argentina). IEEE, 416–426.
[67]ShengqianYang,DacongYan,HaoweiWu,YanWang,andAtanasRountev.2015.
Static Control-Flow Analysis of User-Driven Callbacks in Android Applications.
In2015IEEE/ACM37thInternationalConferenceonSoftwareEngineering (Florence,
Italy). IEEE, 89–99.
[68]XianZhan,LinglingFan,SenChen,FengWu,TianmingLiu,XiapuLuo,andYang
Liu. 2021. ATVHUNTER: Reliable Version Detection of Third-Party Libraries
for Vulnerability Identification in Android Applications. In 2021 IEEE/ACM 43rd
International Conference on Software Engineering (Madrid, Spain). IEEE, 1695–
1707.
[69]Xian Zhan, Lingling Fan, Tianming Liu, Sen Chen, Li Li, Haoyu Wang, Yifei Xu,
Xiapu Luo, and Yang Liu. 2020. Automated Third-Party Library Detection for
AndroidApplications:AreWeThereYet?.In 202035thIEEE/ACMInternational
Conference on Automated Software Engineering (Virtual Event, Australia). ACM,
919–930.
[70]Jie Zhang, Cong Tian, Zhenhua Duan, and Liang Zhao. 2021. RTPDroid: De-
tectingImplicitlyMaliciousBehaviorsUnderRuntimePermissionModel. IEEE
Transactions on Reliability 70, 3 (2021), 1295–1308.
[71]Yury Zhauniarovich and Olga Gadyatskaya. 2016. Small Changes, Big Changes:
An Updated View on the Android Permission System. In 19th International Sym-
posium on Research in Attacks, Intrusions, and Defenses (Paris, France). Springer,
346–367.
137
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 07:51:54 UTC from IEEE Xplore.  Restrictions apply. 