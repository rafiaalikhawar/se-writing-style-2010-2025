Hiding Critical Program Components via Ambiguous
Translation
Chijung Jung
University of Virginia
Charlottesville, VA
cj5kd@virginia.eduDoowon Kim
University of Tennessee,
Knoxville, Knoxville, TN
doowon@utk.eduAn Chen
University of Georgia
Athens, GA
ac24057@uga.eduWeihang Wang
University at Buffalo, SUNY
Buffalo, NY
weihangw@buffalo.edu
Yunhui Zheng
IBM Research
Yorktown Heights, NY
zhengyu@us.ibm.comKyu Hyung Lee
University of Georgia
Athens, GA
kyuhlee@uga.eduYonghwi Kwon
University of Virginia
Charlottesville, VA
yongkwon@virginia.edu
ABSTRACT
Softwaresystemsmaycontaincriticalprogramcomponentssuchas
patented program logic or sensitive data. When those components
are reverse-engineered by adversaries, it can cause significantly
damage(e.g.,financiallossoroperationalfailures).Whileprotecting
critical program components (e.g., code or data) in software sys-
temsisof utmostimportance,existingapproaches,unfortunately,
havetwomajorweaknesses:(1)theycanbereverse-engineeredvia
various program analysis techniques and (2) when an adversary
obtains a legitimate-looking critical program component, he or she
canbe sure that it is genuine.
In this paper, we propose Ambitr, a novel technique that hides
critical program components. The core of Ambitr is Ambiguous
Translator thatcangeneratethecriticalprogramcomponentswhen
theinputisacorrectsecretkey.Thetranslatorisambiguousasit
canacceptanyinputsandproducesanumberoflegitimate-looking
outputs, making it difficult to know whether an input is correct
secretkeyornot.Theexecutionsofthetranslatorwhenitprocesses
thecorrectsecretkeyandotherinputsarealsoindistinguishable,
makingtheanalysisinconclusive.Ourevaluationresultsshowthat
static,dynamicandsymbolicanalysistechniquesfailtoidentifythe
hiddeninformationinAmbitr.Wealsodemonstratethatmanual
analysisof Ambitris extremely challenging.
CCSCONCEPTS
‚Ä¢Securityandprivacy ‚ÜíSoftwaresecurityengineering ;Soft-
ware reverse engineering.
KEYWORDS
program translation, software protection, reverse engineering
1 INTRODUCTION
Software systems often contain critical program components such
asclassified,sensitive,orproprietarycodeordata,whichwecall
This work is licensed under a Creative Commons Attribution International 4.0 
License.
ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA
¬© 2022 Copyright held by the owner/author(s).
ACM ISBN 978-1-4503-9221-1/22/05.
https://doi.org/10.1145/3510003.3510139Critical Program Components (orCPC). For example, patented pro-
gram logic is an example of CPC. If an adversary steals or copies a
competitor‚Äôssoftwaresystem‚Äôspatentedtechnology,itwouldcause
significant financial loss. Similarly, in a warfare software system
(e.g., software in a drone), a CPC can be a piece of code containing
itsoperationalprocedures,includingthetargetsandplans.Since
an adversary can reverse-engineer a software system to reveal var-
ious critical operational secrets (e.g., targets of the military system
and target operation date) which can be used against the victim,
protecting CPCs is an essential requirement.
There are a few techniques that can be leveraged to hide critical
program components: obfuscation [ 5,12,37,61], packing [ 14,38,
40], and encryption [ 66,75]. Code obfuscation techniques syntacti-
callytransformtheoriginalprogram‚Äôscodeintoanotherformof
code,makingitdifficulttobeanalyzedmanually. Dataobfuscation
techniques[ 3,18,30]changethevalueofdatainawaythatdoesnot
changetheoriginalsemanticofthedatawhilemakingitdifficulttoknowtheoriginalvalue.However,bothobfuscationtechniquespre-
serve critical semantics, meaning that they only delay the analysis
butcannotprotectthecriticalcomponents.Apackercompresses
orencryptstheprogramcodeanddata,andstorestheminadata
section of the packer‚Äôs loader program. However, it is not suitable
for hiding CPCsbecause it always decompresses (or decrypts) the
originalprogram code and data at runtime.
Tounderstandtheeffectivenessoftheexistingtechniquesinhid-
ingcriticalprogramcomponents,weanalyzeapproachesthatcanbe
used against theobfuscation, packing, and encryptiontechniques.
Specifically,weobservethatobfuscationtechniquesandpackers
canbeeasilytracedandanalyzedbydynamicanalysis[ 9,41,68].
Whileencryption-basedtechniquesarechallengingtobreakcrypto-
graphically, the execution of the decryption function can be traced
to extract the decrypted data (i.e., the genuine critical program
components).Tothisend,weconcludethatwhilethetechniques
certainly raise the bar in analysis (i.e., making the analysis chal-lenging),it is practically feasible for a persistent and determined
adversarytoobtainthecriticalprogramcomponentprotectedby
existing techniques. More importantly, since there is no ambiguity
in decoding and uncompression processes, the adversary knows
thattheCPCis undoubtedly correct when obtained.
Inthispaper,weproposeanoveltechnique,Ambitr,thataimsto
hide critical program components against adversaries with access
11202022 IEEE/ACM 44th International Conference on Software Engineering (ICSE)
ICSE‚Äô22,May21‚Äì29,2022,Pittsburgh,PA,USA ChijungJung,DoowonKim,AnChen,WeihangWang,YunhuiZheng,KyuHyungLee,andYonghwiKwon
tothetargetprogram.Specifically,wehidecriticalprogramcom-
ponents(e.g.,program codeordata)byencodingthe components
toacomplexstate-machine.Givenacorrectsecretkey,thestate-
machinegenerates thegenuinecritical program components (e.g.,
program code or data). The key difference between Ambitr and
existingtechniquesisthatAmbitrcantaketheincorrectsecretkey
asinput andgeneratelegitimate-lookingCPCs,making itdifficult
todeterminewhetherthegiveninputisthecorrectsecretkeyor
not.Unlikeatypicalstate-machine,Ambitr‚Äôsstate-machineallows
a transition on any inputs even if it does not match the transition‚Äôs
input(i.e.,atypicalstate-machinewillraiseanerrorifitdoesnot
match). The differences between the state transition‚Äôs input and
the given input are then used to generate output different from the
statetransition‚Äôs output.This significantly enlarges theinput/out-
putspaceofastatetransitioninAmbitr.Withthestate-machine,
Ambitr introduces a unique challenge to the adversary, Ambiguity ,
meaningthateveniftheadversaryidentifiesalegitimate-looking
outputfromAmbitr,theadversarydoesnotknowwhethertheout-
putisthegenuinecriticalprogramcomponent.Tothisend,with
the sophisticated construction of our state-machine, the critical
programcomponenthiddenbyAmbitrisextremelychallenging
to be identified. Moreover, even when some possible outputs are
identified, one cannot know which output is the genuine CPC.
Ourcontributionsare summarized as follows:
‚Ä¢Weanalyzelimitationsofexistingtechniquesaimingtohidepro-
gramcode,andinvestigateapossibilityofaddinganewchallenge:
ambiguity.
‚Ä¢WeproposeAmbitr,whichcanhidecriticalprogramcomponents
(CPCs)throughasophisticatedtranslationtechniquethataccepts
any inputs and generates multiple plausible CPCs that are not
distinguishablefrom the genuine CPC.
‚Ä¢We perform a thorough evaluation using state-of-the-art dy-
namic, static, and symbolic analysis tools to demonstrate Am-
bitr‚Äôs resilience to reverse-engineering attempts.
2 POSITIONING AND BACKGROUND
2.1 Definition
Critical Program Component (CPC). We define Critical Pro-
gramComponentasapieceofcodeordatathatcontainscritical
programlogicorinformation,whichisnotdesirabletobeknownto
theadversary.Itisimportanttomentionthat,inourcontext,while
the adversary knows that there is a CPC hidden in the program,
he or she does not know what the CPC should be. In other words,
givenasetofplausibleCPCexamples,theadversarydoesnotknow
which one is the correct CPC. In this paper, we aim to prevent the
adversary from identifying and pinpointing the correct CPC.
2.2 Positioning
Typical Usage Scenario. Figure 1 illustrates how Ambitr oper-
ates under a typical usage scenario of our research. Specifically, in
a target program, we use our Ambiguous Translator to hide a criti-
calprogramcomponent.Atruntime,itreceivesaninputfroman
externalsourcesuchasnetwork( 1),andfeedsittotheambiguous
translator( 2)whichgeneratesoutputsaccordingtotheinput.If
the input is the correct secret key, the genuine CPC is generated(3). On other inputs, our ambiguous translator still produces valid
outputs without failing. In particular, on certain specialized inputs,
decoyCPCsthatareindistinguishablefromthegenuineCPCare
generated ( 4). Finally, the outputs (i.e., CPCs) are processed or
executed, if its type is an executable code ( 5).
Ambiguous 
Translator
Secret Input
Non-secret Input 1
Genuine CPC
(Critical Program Comp.)
 g
Decoy CPC 1
Target Program
Secret I
Adversary
Network Inputs
Non-secret Input 2
Decoy CPC 2
access to 
inputsaccess to 
program codeindistinguishable 
outputs
‚Ä¶ ‚Ä¶6
6 7
123
4
4
Processing or 
Executing58indistinguishable     
execution
Figure 1: Assumed Scenario and Scope of the Research.
AdversaryModelandScope. In this work, we assume the adver-
saryhasaccesstopreviousinputsandthetargetprogram‚Äôscode,
including our ambiguous translator‚Äôs logic ( 6). The adversary can
also run the program with any inputs including the obtained previ-
ousinputs.Thegoalof Ambitristo preventthe adversaryfrom
identifying the secret input that can generate the genuine CPC
without a doubt ( 3). To achieve the goal, Ambitr can generate
outputs including the genuine CPC and decoy CPCs that are indis-
tinguishable from each other ( 7). The execution of the ambiguous
translator when it generates the original or decoy CPCs is also
indistinguishable, as well as the processing or execution of the
generated CPCs ( 8).
Weassumethatthepreviousinputsmightexistinanetworklog
and are available to the adversary. However, the adversary does
not know what is the secret input, from the obtained previous
input.Someof the inputs may generate decoy CPCs. We assume
that target program‚Äôs behaviors and execution for processing and
executing the CPCs are not distinguishable. Otherwise, the code
canbetracedtoidentifywhichinputgeneratesthegenuineCPC.If
the original target program should execute different program code,
suchcode shouldbeincludedin theexecutableCPC. We assume
the adversary can leverage various static and dynamic analysis
techniquestoanalyzeourambiguoustranslator.Weconsiderour
approach is successful if the adversary fails to pinpoint the genuine
CPC,even if many (or even all) valid CPCs are identified .
2.3 Existing Techniques for Hiding CPC
A few techniques can be leveraged to hide a CPC in a program.
Specifically,thecolumnsinTable1presentthetechniqueswhile
each row of the table shows program analysis approaches that can
be used to identify CPCs. Symbols represent the effectiveness of
theprogram analysis approaches against each technique.
1121HidingCriticalProgramComponentsviaAmbiguousTranslation ICSE‚Äô22,May21‚Äì29,2022,Pittsburgh,PA,USA
Table 1: Effectiveness of Existing Techniques and Ambitr
againstProgram Analysis Approaches.
Obfuscators Packers/Crypters Protectors Ambitr
Static Analysis1 2 2
SymbolicAnalysis1
DynamicAnalysis
Forced Execution
: Ineffective, : Lesseffective, : Effective (against analyses).
1: Static/symbolic analysis techniques have difficulty handling advanced
obfuscators(with multiple layers of obfuscations) due to state explosion,
whilethey can handle simple obfuscators.
2: Static analysis may handle known crypto algorithms while it may not
genericallyhandlethem(hence half-filled circled, meaning that effective
on some but not all).
2.3.1 Obfuscators. Obfuscation techniques [ 3,5,12,16,18,24,
30,37,47,54,61,64,67,76] aim to make the original code diffi-
culttoanalyzebyleveragingtechniquesincludingopaquepredi-
cates [16,47,67], code insertion/replacement [ 5,24,37,54,61,76],
andhardware primitives [12, 64].
Limitations. Obfuscation techniques that transform code into se-
manticallyequivalentformsoraddnon-essentialcode(e.g.,opaque
predicatesanddummycode)[ 5,16,24,37,47,54,61,67,76]canbe
handledbyautomaticallyrevertingorremovingthemodified/added
code via program analysis techniques [ 33,44,49,53,80,81]. De-
pendingontheobfuscationtechniquesused,staticandsymbolic
analysismaysufferfromthecomplexityoftheanalysis,meaning
that they might not be always effective, as described in Table 1.
Typically, dynamic analysis (including forced execution [ 57]) tech-
niques are highly effective in handling the obfuscation techniques.
While data obfuscation techniques [ 3,18,30] change the values of
data,theircriticalsemanticsarepreservedandcanbetracedand
identified by both static and dynamic analysis [46, 79].
2.3.2 Packers/Crypters. Packers[14,38,40]primarilyaimtohinder
static analysis. Specifically, they create a program containing com-
pressed original program asdata, that uncompresses and executes
the original program at runtime. Crypters [ 2,6,29] are essentially
advancedpackersusingcryptotechniquestohidetheprogramdata
and code. Due to the complexity of compression and encryption,
staticandsymbolicanalysisarenoteffectiveasshowninTable1.
In particular, symbolic analysis suffers from state explosion due to
thecomplex computations of encryption schemes.
Limitations. Since a packer generated program seamlessly un-
packs and executes the original code at runtime, dynamic analysis
(i.e., executing the binary and extracting the uncompressed pro-
gram)[13,34,62] canobtaintheoriginalprogram.
2.3.3 Protectors. Protectors[ 59,69,82,83]areessentiallyadvanced
packers/cryptersequippedwithevasiveanti-analysistechniques
suchasterminatingtheexecutioniftheydetectreverse-engineering
attempts (e.g., running the program with a debugger). Similar to
packers/crypters, since the program itself is compressed and en-
crypted,staticandsymbolicanalysesarenoteffective,asdescribed
in Table 1. Specifically, symbolic and concolic analyses can be used
to avoid the evasive techniques by extracting and solving the eva-
sivepredicateconditions.However,theyaredifficulttoscaletothe
programsgenerated byprotectors.Moreover,dynamicanalysis is
ineffective because of the evasive techniques.Limitations. Forcedexecutiontechniques[ 19,32,35,57,78]aim
tohandleevasivetechniquesbyforciblyexecutingbranchesregard-
less of the predicate conditions. Most protectors can be handled
by the forced execution techniques. Note that since the forced exe-
cution techniques forcibly execute program code regardless of the
predicateconditions,theymayfailtohandleanadvancedprotec-
tor which uses predicate conditions for both evasive techniques
and decryption (i.e., decryption logic is dependent on the predicate
conditions).However,byobservingthepredicateconditionsand
executions of the program, it is straightforward to tune the anal-
ysis technique to handle such advanced protectors (e.g., one can
selectivelysolvesuchacriticalpredicatewithsymbolicexecution
to handle the limitation) [70].
2.4 DesirableProperties
WepresentfourdesirablepropertiesofaCPChidingtechniques:
Evasiveness ,Complexity ,Context-Sensitivity , andAmbiguity .
FromExistingLiterature. For the first three properties, we iden-
tifyandsummarizethemfromexistingliterature.Notethatprior
literature does not explicitly present the properties. They are only
implicitlymentionedindividually(e.g.,evasivenessin[ 80],complex-
ityin[5],context-sensitivityin[ 40,44]).Wesystematicallystudied
priorliteraturetoestablishthedesirableproperties.Inparticular,
from program analysis papers [ 33,44,80], we mainly focus on the
challenges,e.g.,state-explosioncausedbycomplexity,theypointed
out.Fromanti-programanalysistechniques[ 5,24,40,54,64],we
pay attention to the approaches proposed by them to hinder the
analysis(e.g.,evasivetactics[ 54]).Webelievethefourproperties
thoroughlycover the core properties across the literature.
New Desired Property: Ambiguity. We introduce a new desir-
ablecharacteristic: Ambiguity (details in Section 2.4.4).
2.4.1 Evasiveness. Programsthatarehighlyevasive(e.g.,programs
with a number of evasive predicates) impose significant challenges
to symbolic and dynamic analysis. For dynamic analysis, knowing
a number of concrete inputs that can cover all the evasive predi-
cates is challenging. For symbolic analysis, an excessive number
of predicates and complex predicate conditions cause the scala-
bility problem (i.e., taking too much time making the technique
practicallyunusable).
2.4.2 Complexity. Static and symbolic analyses have difficulty
analyzing programs with complex operations. Typical examples
arepacked/encryptedprograms.Staticandsymbolicanalysescan
reverse-engineer the uncompression/decryption process. However,
they fail to scale complex algorithms (e.g., a crypto algorithm).
2.4.3 Context-sensitivity. Someprogramshavecontext-sensitive
code, meaning that their behaviors are dependent on a particu-
lar program execution path. Since there are a large number of
program paths, it is common for static analysis to conduct context-
insensitive analysis. Symbolic analysis aims to discover various
execution contexts; hence often suffers from the excessive number
of program execution paths, causing the path explosion. Forced
execution solvesthe pathexplosion problemby forcibly executing
code guarded by branches . However, due to the ignored branch out-
comes which lead to incorrect context, the results of the execution
may notbe precise.
1122ICSE‚Äô22,May21‚Äì29,2022,Pittsburgh,PA,USA ChijungJung,DoowonKim,AnChen,WeihangWang,YunhuiZheng,KyuHyungLee,andYonghwiKwon
Decoding/
Decryption
Error
Decrypted Key 1
Key 2
Error Key 3
Adversary
Error
ErrorThere is only one correct key that can successfully decrypt
Wrong keys always lead to errors
Figure 2: Existing Techniques are NOTAmbiguous.
2.4.4 Ambiguity. When an adversary obtains a successfully de-
coded/decryptedCPC,iftheadversarycancertainlysaytheCPC
isgenuine,weconsiderthetechniqueis notambiguous.Inother
words, if the adversarycannot determine whether the CPC iscor-
rect or not, we consider the technique has the ambiguity property.
Specifically, obfuscators do not go through a decoding process,
meaning that executing the obfuscated program would expose the
criticalprogramcomponents.Packers/crypters/protectorstypically
storethecompression/encryptionkeyforthecriticalprogramcom-
ponent in the programs. Hence, running the program, without any
particular input, would expose the CPC. Advanced crypters/pro-
tectors often store the key for CPC in a separate place, making
it challenging to decrypt. Similar to Ambitr, an application may
receive the key via the Internet.
Assume that an adversary obtains a few keys from the network
traffic logs, and try them to the program. Figure 2 describes an
example scenario with three different keys, where Key 1 is correct
andKey2and3areincorrect.UnlikeAmbitr,existingcrypters/pro-
tectors are not ambiguous, meaning that the decoding/decryption
will be only successful with Key 1 and all other keys (e.g., Key 2
and 3) will result in errors. As a result, observing any successful
decryption with a key implies that the decrypted CPC are genuine.
Table 2: Properties in Existing Techniques and Ambitr.
Obfuscators Packers/Crypters Protectors Ambitr
Evasiveness1
Complexity2 2 2
Context-Sensitivity3
Ambiguity
:High,:Medium, :Low,:No.
1: Protectors have medium evasiveness because while they detect the environment
to avoid (e.g., VM/debugger), their detection is not sophisticated.
2: Obfuscators/Packers/Crypters/Protectors use various encoding/crypto algorithms
with varying complexity, determining the complexity property. Both simple and
complex algorithms are used, leading to the medium.
3: Very few protectors are context-sensitive: e.g., using a (context-sensitive)
variable as a decryption key.
Summary of Desirable Properties. Table 2 shows the de-
sirable properties in existing techniques and Ambitr. As dis-
cussed,noneofexistingtechniqueshastheambiguityprop-
erty.Moreover,Ambitrismoreevasive,complex,andcontext-
sensitive than existing techniques.3 DESIGN
3.1 Overview and Intuition
Ambitr leverages a specialized state machine to translate input to
CPCs.Thestatemachineisdesignedtoacceptanyinputvaluesand
generatethegenuineCPCor decoy CPCs depending on the input.
The state machine achieves Evasiveness andContext Sensitivity
since without knowing the particular secret key (i.e., the secret
input)forthegenuineCPC,executingthestatemachinewithother
inputs does not produce the genuine CPC.The state machine con-
tains a number of states for decoy CPCs, achieving Complexity .
Finally,thedecoyCPCsandtheexecutionof Ambitrarenotdis-
tinguishableto the genuine CPC, achieving Ambiguity .
3.1.1 AmbitrversusaTypicalStateMachine. Atypicalstatema-
chineonlyacceptsinputthatcanmakestatetransitionsfromthe
currentstate.Hence,tounderstandallpossibleinputs(andcorre-
spondingoutputs),onecancollectallthestatetransitions‚Äôinputs
andcomeupwiththepermutationsofthem. Unliketraditionalstate
machinethatshouldhaveanacceptingstate,Ambitrdoesnothave
the acceptation state. It terminates when it has consumed all the
inputs.Note thatAmbitr‚Äôsoutput isgeneratedwhena transition
happens,notattheacceptingstateasatraditionalstate-machine
does.
Figure 3-(a) shows an example state-machine. Circles and ar-
rows represent states and state transitions including input and
output of each transition (‚ÄòIn‚Äô and ‚ÄòOut‚Äô). A traditional state ma-
chinecanonlyacceptinputsthatmatchthestatetransitions‚Äôinputs.
For instance, from A, it only accepts two inputs ‚Äúblinding‚Äù and
‚ÄúReference‚Äù that make transitions to BandC, respectively. The
restrictiononacceptedinputsessentiallylimitstheinputandout-
put space. Figure 3-(b) shows all possible inputs and outputs of the
traditionalstatemachinefrom AtoDandE.Thiscanbedone
by identifying all possible state transitions and inputs because any
otherinputs(e.g., the last row of Figure 3-(b)) result in errors.
Inputs for CPCs is Implicit in Ambitr. Figure 3-(c) shows in-
puts and outputs that can be handled by Ambitr using the state
machine in Figure 3-(a). Note that it can handle all the inputs in
the same way the traditional state machine handles. The first row
shows an example.
AmbitrallowsaCPCtobedecodedbyinputsthatdonotmatch
thestatetransitions‚Äôinputs.Thesecondrowshowsanexample.The
firstinput‚Äúpywudh"‚Äùdoesnotmatchanytransitioninputsfrom
A: ‚Äúblinding‚Äù for Band ‚ÄúReference‚Äù for C. However, as shown in
the third column, it makes a transition to B, since the distance (in
ASCIIcodevalueofeachbyte)betweenthegiveninputandthestate
transition‚Äôs input of Bis closer than the state transition‚Äôs input of
C. When it produces an output, it also uses the measured distance
between the input and the state transition‚Äôs input to compute a
newoutputvaluethatisdifferentfromthestatetransition‚Äôsoutput.
By doing so, Ambitr‚Äôs state machine does not have restrictions on
the inputs it can take, meaning that any inputs can be accepted.
Moreover, outputs that Ambitr‚Äôs state machine can produce are
notrestricted as well.
Thesecond,third,andfourthrowsinFigure3-(c)showexamples
of legitimate-looking decoy CPCs (i.e., meaningful executable code
but not the genuine CPC) from inputs that do not match any state
1123HidingCriticalProgramComponentsviaAmbiguousTranslation ICSE‚Äô22,May21‚Äì29,2022,Pittsburgh,PA,USA
ABIn: ‚Äòblinding‚Äô
Out: ‚Äòelements‚Äô
C
(a) State Machine  (‚Äò ...‚Äô represents omitted states)
Input Output State Transitions
blinding control-codes ele ments extended-code A /g198B /g198D
blinding corresponding elements interchanging A /g198B /g198E
Reference illustration materials manipulation A /g198C /g198E
Reference bell control-code s materials ring extended-code A /g198C /g198B /g198D
Reference bell corresponding materials ring interchanging A /g198C /g198B /g198E
Reference Code materials <Error> A /g198C /g198<Error>
(b) Traditional State Machine‚Äôs State TransitionsD
E‚Ä¶
‚Ä¶In: ‚ÄòReference‚Äô
Out: ‚Äòmaterials‚ÄôIn: ‚Äòcontrol-codes‚Äô
Out: ‚Äòextended-code‚Äô
In: ‚Äòcorresponding‚Äô
Out: ‚Äòinterchanging‚Äô
In: ‚Äòillustration‚Äô
Out: ‚Äòmanipulation‚ÄôIn: ‚Äòbell‚Äô
Out: ‚Äòring‚Äô
Input Output State Transitions
blinding control-codes ele ments extended-code A /g198B /g198D
pywudh" "VATXf.AR3R*I system($_GET['xx']); A /g198B /g198D
rnpjmf" "]c{i4B unlink($file); A /g198B /g198D
Re[l $1kb, !*0prm,$h); mail ($to, $t,$msg,$h); A /g198C /g198E
(c) A MBITR ‚Äôs State Transitions
Figure 3: Traditional State Machine vs. Ambitr.
transitions‚Äôinputs.Thethreeinputshavedifferentsizes,andthe
fourth row‚Äôs input leads to different state transitions ( AtoCand
E)fromtheothertwo.Notethatmanymoreinputscangenerate
legitimate-looking outputs, and one can brute-force inputs (e.g.,
tryingallpossiblestringsforinput)toenumeratethem.Weexplain
thedetailsof the state machine in Section 3.2.1.
3.1.2 AmbiguityinAmbitr. Ambitrintroducesambiguityintwo
aspects: ambiguity in input/output and execution.
Ambiguous Input/Output. The input of Ambitr is ambiguous
becauseitcantakeanyinputsevenifitdoesnotmatchanystate
transition inputs, as shown in Figure 3-(c). When the input does
not match any state transitions, Ambitr finds a transition that has
the closest input to the provided input (in terms of ASCII code
valueofeachbyteofinput).ObservethatAmbitr‚Äôsoutputcanalso
differ from the state transition‚Äôs output and is dependent on input,
meaningthattheoutputis also ambiguous.
Theambiguityoftheoutputsmakestheanalysisinconclusive.
For example, in Figure 3-(c), the second, third, and fourth rows‚Äô
outputs are all legitimate executable code. Hence, it is challenging
to conclude which one is the genuine CPC.
Ambiguous Execution. One may use dynamic analysis to trace
the execution of Ambitr to understand whether there are any
execution differences while processing different inputs. If such a
differenceexists,itcanbeusedtoinferthegenuineCPC.Asshown
in Algorithm 1 that describes the algorithm of Ambitr‚Äôs state ma-
chine (will be explained in Section 3.2.1), there are no predicates
and computations that behave distinctively. Hence, tracing the exe-
cutionof Ambitrdoes not help to identify the genuine CPC.Algorithm1: Algorithmof Ambiguous Translator
Input : InStr:Arrayof Tokenized Input String.
Output: OutStr:OutputString.
1procedure StateMachine( InStr )
// Assign the Initial State (i.e., INIT).
2Statecur‚ÜêINIT
3whileuntilit consumes all the tokens of InStr; the current token
is InStrcurdo
// Find the matching (or closest) transition from the current state.
4 Statenext,Tran_InŒî,Tran_Out‚ÜêFindTransition
(Statecur,InStrcur)
// Change the current state
5 Statecur‚ÜêStatenext
6 Outcur‚Üê‚àÖ
// Compute Output according to the distance between the input and
transition‚Äôsinput
7 foreach byte ùë°ùëñand ùë°ùëúinTran_In ŒîandTran_Out do
// ‚Äò‚ãÖ‚Äô is a string concatenation operator.
8 Outcur‚ÜêOutcur‚ãÖRound( ùë°ùëú‚àíùë°ùëñ)
9 OutStr‚ÜêOutStr‚ãÖOutcur
10returnOutStr
11procedure FindTransition( Statecur, InStrcur)
12MinScore ‚Üê‚àí1
13foreach transition ùë°ùëüfrom State curdo
14 Score‚Üê0
15 trŒî‚Üê‚àÖ
16 foreach byte ùëèùë°of input of transition ùë°ùëü, and each byte ùëèùëñ
from InStr curdo
17 Score‚ÜêScore+|ùëèùë°‚àíùëèùëñ|
// char() converts a number to a string, ‚Äò ‚ãÖ‚Äô concatenates strings.
18 trŒî‚ÜêtrŒî‚ãÖchar( ùëèùë°‚àíùëèùëñ)
// Finding the matching (or closest) transition.
19 ifMinScore is ‚àí1or min>scorethen
20 MinScore ‚ÜêScore
21 Tran_InŒî‚ÜêtrŒî
//trnextrepresents the next state of the transition tr
22 Statenext‚Üêtrnext
//troutrepresents the output of the transition tr
23 Tran_Out‚Üêtrout
24returnStatenext,Tran_InŒî,Tran_Out
3.2 Composing Ambitr
Ambitr consists of two components: (1) Ambiguous Translator ,
whichisapieceofsoftwarethatprocessesinputaccordingtothe
statemachinedefinitiontogenerateaCPC(Section3.2.1)and(2)
definition of the state machine that the Ambiguous Translator
operates (Section 3.2.2).
3.2.1 AmbiguousTranslatorRuntime. Thecoreof Ambitristhe
runtimeofAmbiguousTranslator.Ithastwouniquecharacteristics.
First, regardless of the current state and input, it always transits to
anotherstate eventheinputdoesnotmatchanytransitions( C1).
Notethat,inatypicalstatemachine,astatetransitiononlyhappens
whenthereisatransitionthatcanacceptthecurrentinput.Second,
when Ambitr takes inputs that do not match the existing transi-
tions, the output generated by Ambitr is also different from the
transitions‚Äô outputs ( C2). Specifically, the final output is computed
1124ICSE‚Äô22,May21‚Äì29,2022,Pittsburgh,PA,USA ChijungJung,DoowonKim,AnChen,WeihangWang,YunhuiZheng,KyuHyungLee,andYonghwiKwon
AB
CIn: ‚Äúunemploymentbenefit‚Äù
Out: ‚Äúreassuringinvestors‚Äù
(a) Automaton
(b) Output Translation Results‚Ä¶
‚Ä¶
Input Output State Trans.
'l18mibthay.G1'#T < $c->predict([1,2]); A /g198B
sjwmq_o{'"hsP)6 passthru ($cmd); A /g198B
x{p^bZltd&)y`r$, urldecode ($str); A /g198B
swvq1G# -{ $\hn) fwrite ($f,$cnt) A /g198C
phvw,V #-y]r"5 chroot($ dir); A /g198C
ozhm QhyyYsl"^) bzdecompress (d) A /g198C
(d) Output Computation'l18m ibthayunemploymen
78 25253 3313 554-11
(c) Input Delta Computation-In: ‚ÄúTerm/Conditions‚Äù
Out: ‚ÄúGenerateOutputs‚Äù
.G1'#tbene
7027527166T <fit
187356
$c->predictreassuringi
78 25253 3313 554-11 -
([1,2nvest
7027527166
]);ors
187356
Figure4:ExamplesofDynamicOutputTranslation.Compu-
tations,i.e., (b) and (c), are on ASCII Code Values.
basedonaconcreteinputatruntime.Thissignificantlyenlargesthe
search space of input and output. Algorithm 1 shows its algorithm,
andwe will use it to explain the details of the two characteristics.
MakingTransitionsonAnyInputs(C1). AmbiguousTranslator
makestransitionsfromanystatesonanyinputs.Specifically,forall
nextreachablestatesfromthecurrentstate,itcalculatesthedistance
(by subtracting values from each byte offset and accumulating the
results as shown in Figure 4) between the current input and the
transitions‚Äô inputs ( FindTransition in Algorithm 1). Lines 16-18
inAlgorithm1essentiallycomputethedistance( Score).Then,it
selects a transition with the smallest distance (if there are multiple
ties, we pick the first one to make it deterministic) as shown in
lines19-23in Algorithm 1.
DynamicOutputTranslation(C2). WhenAmbiguousTranslator
makes a transition on an input that is not exactly matched with
the transition‚Äôs input, it generates output that is different from the
currentstatetransition‚Äôsoutput. Specifically, it computes the new
outputby applyingthedifferences betweenthecurrent inputand
the current state transition‚Äôs input. This makes the output space
significantly large as the output can vary as much as the input
varies.
In Algorithm 1, one of the return values of FindTransition
(line4)is Tran_InŒî,whichrepresentsthedistancebetweenthecur-
rentinputandthecurrentstatetransition‚Äôsinput. FindTransition
alsoreturnsthecurrent(i.e.,selected)transition‚Äôsoutputas Tran_Out.
Then, at lines 7-8, it computes the new output by subtracting each
byteofTran_InŒî(i.e.,ùë°ùëñ)fromthetransition‚Äôsoutput Tran_Out(i.e.,
ùë°ùëú).Notethatthereisthe Roundfunctionatline8,whichessentiallyrounds the computed value to be in the visible ASCII code value
range(i.e., 32 ‚àº126).
Example. Figure 4-(a) shows an automaton of a state machine
whereinputsandoutputsoftransitionsareillustratedaboveand
below the arrows. Figure 4-(c) describes an example computa-
tion of distances (i.e., delta) between the transition‚Äôs input (e.g.,
‚Äúunemploymentbenefit ‚Äù) and the given input at runtime (e.g.,
‚Äú‚Äôl18mibthay.G1‚Äô#T < ‚Äù).Specifically,foreachcharacter,itsub-
tractsASCIIcodevaluesofthecharacters.Theresultsareshownat
thebottomlineofFigure4-(c).Wethensubtractthevaluestothe
transition‚Äôs output to derive the final output (i.e., ‚Äú $c->predict(
[1,2]);‚Äù) as shown in Figure 4-(d).
Figure4-(b)presentssixexamplesofinputandoutputpairsfrom
A(three for A‚Ü¶Band the other three for A‚Ü¶C). The first
example is the one that is illustrated in Figure 4-(c) and (d). The
second and third examples show inputs for generating function
calls passthru and urldecode .Thethreeexamplesshowthatthe
same state transition, A‚Ü¶B, (with different inputs) can generate
completely different outputs (i.e., CPCs), making the translation
ambiguous.
Thenextthreeexamplesaregeneratedviathetransition A‚Ü¶
C.Again,dependingonthegiveninput,itgeneratescompletely
different outputs, and those outputs are all legitimate executable
code, making it difficult to know which one is the genuine CPC.
3.2.2 Composing Automaton. Ambitr‚Äôs Ambiguous Translator op-
erateson anautomaton,wherethe definitionofautomaton isnot
particularly different from the traditional automaton. The automa-
ton consists of states and transitions between the states, where the
transitionshave inputs and outputs.
States and Transitions for the Genuine CPC. We first create
statesandtransitionsthatcangeneratethegenuineCPC.Specif-
ically,givenaCPC,wetokenizetheCPCtoobtainasequenceof
shortstrings(e.g.,stringsof5 ‚àº10lengths).Thenweaddastatethat
can translate each token, and connect the individual states. The
resulting automaton is the minimum automaton that can generate
aCPC.Wechoosetheinput/outputofstatetransitionsbyusinga
dictionary(e.g.,anEnglishdictionary).Specifically,werandomly
pick two words for input ( ùëäin) and output ( ùëäout) of a transition.
Then,tomakesurethatthetransitioncangenerateadesiredtoken
of CPC (tokencur), we obtain an input candidate for CPC by com-
puting ( ùëäin‚àí(ùëäout‚àítokencur)), which is essentially rev ersing the
translationprocess.
Figure5showsanexample.Giventhesamestatetransitionused
inFigure4,wechooseinputandoutputfromadictionary.Inthis
example,weconcatenatetwowords,‚Äúunemployment‚Äùand‚Äúbenefit‚Äù
for input and ‚Äúreassuring‚Äù and ‚Äúinvestors‚Äù for output, as shown
in Figure 5-(a). Then, given a token string, to translate shown in
Figure5-(b),wefirstcompute ùëäout‚àítokencurasshowninFigure5-
(c). We compute ( ùëäin‚àí(ùëäout‚àítokencur)) as shown in (d). The
outcomeisthesecretkeythatcangeneratetheCPCtokenstring
(tokencur).Finally,wealsorunourambiguoustranslatortocheck
whetherthesecretinputcangeneratetheCPCtoken.Notethatdue
totheroundinginthetranslationprocess(line8inAlgorithm1),
somesecretkeysobtainedbytheaboveprocesscannotgeneratethe
CPC token string. If this happens, we choose another input/output
pairand repeat the process until it succeeds.
1125HidingCriticalProgramComponentsviaAmbiguousTranslation ICSE‚Äô22,May21‚Äì29,2022,Pittsburgh,PA,USA
A BIn (Win): ‚Äúunemploymentbenefit‚Äù
Out (Wout): ‚Äúreassuringinvestors‚Äù
(a) Automaton
(d) Secret Input Computation'l18m ibthayunemploymen78 25253 3313 554-11
(c) Delta Computation-
.G1'#tbene7027527166
T <fit187356$c->predictreassuringi
78 25253 3313 554-11 -([1,2nvest
7027527166]);ors
187356(b) CPC Token String$c->predict([1,2]);
Figure 5: Identifying Secret Key for a CPC Token.
Unnecessary States and Transitions. We then add extra states
and transitions between all states to hinder analysis attempts of
thestatemachine.Dummytransitionsconnect allstates(notonly
dummy states) , making Ambitr more difficult to analyze. Note
thatthedummystatesandtransitionsareusedtotranslatedecoy
(i.e., fake) CPCs. Inputs/outputs of the transitions to the dummy
states are chosen in a way that the inputs of all transitions look
similar,makingitchallengingtoknowwhichtransitionsareforthe
genuineCPC.Specifically,foreachnewlyaddedtransition,itsinput
is derived by choosing a similar word (i.e., synonyms/antonyms in
dictionaries[22,58])to its neighboring transition‚Äôs input.
4 EVALUATION
In this section, we present various experimental results to show
theeffectivenessof Ambitrincomparisonwithexistingstate-of-
the-art techniques and analysis tools. In particular, we evaluate
Ambitr in terms of evasiveness (via dynamic analysis tools in
Section 4.3.1),complexity (via static analysistools in Section 4.3.2
andSection 4.3.3), and the context-sensitivity (Section 4.3.4).
Implementation. We implement our Ambitr creator in Python
(1,322 LOC). It generates Ambitr, written in PHP (2,314 LOC ex-
cludinglinesforthetransitioninputsand outputs).
Ambiguous Translator Configuration. For the evaluation, Am-
biguousTranslator isconfiguredtocreatebinarysampleswithat
leastmore than 300 nodes and each node has at least 5 edges.
Table 3: AmbitrInstancesStatistics.
Sizeof # of Avg. Size of Avg. # of Avg. # of
CPCs (Avg.) Samples Ambitr States Transitions
0‚àº10KB (2.7 KB) 345 27.36 KB 603.6 4,843.4
10‚àº20 KB (14.5 KB) 99 77.72 KB 2,476.1 19,194.7
20‚àº30 KB (24.0 KB) 39 130.15 KB 4,012.8 32,334.9
30‚àº40 KB (34.7 KB) 56 175.81 KB 5,671.7 45,659.0
40‚àº50 KB (43.7 KB) 34 209.71 KB 7,209.5 58,124.1
4.1 Applicability
TounderstandwhetherAmbitrcanbecreatedbyvariousinput/out-
put pairs, we collect 573 code snippets and programs from popular
repositories [ 7,8,23,51,74]. Note that for Ambitr, those inputCPCs are simply strings, and values of the inputs do not affect
Ambitr‚Äôs performance.
We successfully generate Ambitr instances for all 573 collected
samplesasshowninTable3.Giventhesecretinput,theyallsuc-
cessfully generate CPCs as expected. We categorize them by the
samples‚Äôsizes(withanintervalvalueof10KB).Thesizesof Am-
bitrarelargerthantheoriginalsamples(weapplycompression,
e.g., gzip, to reduce the size of Ambitr). Except for the first group,
the size of Ambitr is about 5 times larger than the original sample.
4.2 Automated Analysis of Ambitr
We compare Ambitr with state-of-the-art obfuscation/protector
techniquestoshowAmbitreffectivelyhidesCPCs.Inparticular,we
use a forced execution technique MalMax [ 48] as it can effectively
expose CPCs hidden by existing techniques (see Table 1).
Obfuscators/ProtectorsSelection. Fourstate-of-the-artPHPob-
fuscators and two crypters/protectors are chosen based on their
popularity.ObfusactorsincludePHPObfuscator[ 26],YAKPro[ 36],
Best PHP Obfuscator [ 60], and Simple Online PHP Obfuscator [ 39].
Crypters/protectorsincludeZendGuard[ 83]andPHPEncoder[ 59].
Result.AsdiscussedinSection1,obfuscatorsdonotrequireany
particularinputorenvironmenttodecodeandrunthegenuineCPC.
Evenwithouttheforcedexecutiontechnique(MalMax),weobserve
the CPC‚Äôs execution by simply running them. For Zend Guard and
PHP Encoder, it requires the encryption key to be accessible via
network.Weuse MalMaxtorun theprogramsprotected byZend
GuardandPHPEncoder,withoutencryptionkeyaccess.Initially,
theyallfailtoexecute.Then,wetryanincorrectkeybycreating
anotherkey fromZendGuard andPHPEncoder.The wrongkey
isessentiallyakeyforanotherprogram.Asexpected,thewrong
key results in failed executions for all samples because the existing
techniques are not ambiguous (as shown in Figure 2).
Then,weuseacorrectkey(obtainedbytracingnetworkcom-
municationswhenitrunswithouterrors).WerunMalMaxagain
with the correct key, and all samples are successfully decrypted
and expose CPCs. As discussed in Section 2.4.4, the fact that it can
successfully execute indicates that the identified CPCs are genuine.
WealsouseMalMaxtoanalyzeAmbitrprotectedsamples.How-
ever,MalMaxfailstoexposeanyofCPCsfromthesamples.This
is because MalMax focuses on executing all statements without
precisely identifying the key secret inputs. Simply executing all
statements of a target is not sufficient for analyzing Ambitr. More-
over, while the execution of Ambitr under MalMax is incorrect,
Ambitr does not cause any errors or observable behavior differ-
ences. Some generated outputs are not valid while there are still
many seemingly valid outputs looks like CPCs, causing ambiguity
in analysis. Even one can observe the genuine CPC (e.g., having a
networktraceoftheinputleadingtothegenuineCPC),knowing
whethertheobserved CPC is the original is not verifiable.
4.3 Reverse Engineering Ambitr
We evaluate Ambitr from a reverse-engineer‚Äôs perspective in
terms of how difficult to reveal the genuine CPC using various
program analysis tools manually. In the following subsections, we
1126ICSE‚Äô22,May21‚Äì29,2022,Pittsburgh,PA,USA ChijungJung,DoowonKim,AnChen,WeihangWang,YunhuiZheng,KyuHyungLee,andYonghwiKwon
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20for($i=0;$i< ...; $ i++)
define("ST$i", $i);
define("CUR_STATE ",0);
define("INPUT", 1);
define("OUTPUT",2);
define("NEXT_STATE ",3);
$state_tbl =array(
/* array(CURRENT_STATE,
INPUT OF THE TRANSITION,
OUTPUT OF THE TRANSITION,
NEXT STATE) */
array(ST0,"states", "urdonk",ST1),
array(ST0,"prince", "drunks",ST2),
array(ST1,"celestiala ", "7GZ~mp3.es ",ST3),
array(ST1,"systematia ", "83s|png.ez ",ST3),
array(ST3,"costinfisco ", "wxp.zwl*30 ",ST2),
array(ST2,"fiscaltable ", "ubuntu|+0F ",ST3),
...
);$cur_state =ST0;
while(1){
$tran=find_transition ($state_tbl ,$cur_state ,$input);
$cur_state =$state_tbl [$tran][NEXT_STATE ];
$result.=dynamic_translate ($state_tbl [$tran][INPUT],
$state_tbl [$tran][OUTPUT],
$input);
}
function dynamic_translate ($in,$out,$cur_in) {
for($i=0;$i<strlen($cur_in); $i++)
$ret.=chr(ord($out[$i]) -
(ord($in[$i]) - ord($cur_in[$i])));
return$ret;
}
function find_transition ($state_tbl ,$cur_state ,$in) {
foreach ($state_tbl [...]as $next_transition )
for($j=0;$j<strlen($in);$j++ ) 
$d[...]+ = abs(ord($state_tbl [...][$j]) - ord($in[$j]));
return index(min($delta) );
}21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40ST0 ST1
ST2 ST3In: ‚Äústates‚Äù
Out: ‚Äúurdonk‚Äù
In: ‚Äúprince‚Äù
Out: ‚Äúdrunks‚ÄùIn: ‚Äúsystematia‚Äù
Out: ‚Äú83s|png.ez‚ÄùIn: ‚Äúcelestiala‚Äù
Out: ‚Äú7GZ~mp3.es‚Äù
In: ‚Äúcostinfisco‚Äù
Out: ‚Äúwxp.zwl*30‚Äù
In: ‚Äúfiscaltable‚Äù
Out: ‚Äúubuntu|+0F‚Äù
(b) State Machine 
(Red arrows are the  transitions generate 
the genuine CPC. ST0 is an initial state) (a) Source Code of the Exam ple Ambiguous Translator
Figure 6: Simplified Source Code of Ambiguous Translator (in PHP).
assumethatthereverserobtainsasampleof Ambitrwithoutknow-
ingtheintended input that generates output.
4.3.1 DynamicAnalysis. Weassumeascenariothatthereverser
attempts to use Xdebug[21] to monitor its execution. Xdebugis a
PHP debugging extension, providing various debugging primitives
such as step-debugging (i.e., single-stepping), variable dumps, and
stacktraces.Specifically,ittracesvariablesthatareusedtocompute
outputsfrom inputs [20], similar to program slicing [1, 77].
Analyzing Executed Statements. The reverser traces all state-
ments that read and write inputs and values that are computed
from inputs (i.e., values that are data dependent on the inputs).
Unfortunately, as a state machine is implemented as a loop that
makes transitions according to the current input (e.g., as shown in
Figure 6-(a)), the resulting traces include most of the statements
regardless of whether the execution delivers an attack or not.
AnalyzingValuesfromExecutedStatements. Thereverseralso
dumps all the values of the variables used in the executed state-
ments.However,astheexecutiondoesnotdeliverthegenuineCPC,
analyzingthevaluesdoes not help.
4.3.2 StaticAnalysis. Staticanalysistoolscanbeusedtoanalyze
Ambitr to identify possible output values that can be generated
byAmbiguous Translator . Specifically, the reverser uses static taint
analysis tools to find out the data flow of Ambiguous Translator .
Further,staticanalysistoolsthatcanconductavalue-setanalysis
(e.g., [4]) are used to infer possible values of a few key variables.
Simplified Source Code of Ambiguous Translator .Figure 6-
(a)showsasimplifiedversionof AmbiguousTranslator writtenin
PHP. Lines 1-6 define constants. Lines 8-20 build a state transition
tablethatis essentially an array of state transition rules including
current state, input/output of the transition, and next state (line
13-18).It hasaloop (lines22-28)thatrepeatedly findsatransition
according to the input (line 23), makes the transition (line 24), and
dynamically creates an output according to the input (line 25). The
dynamictranslationisdoneinafunction(lines29-34).Theresult
is essentially a concatenated string of the dynamic outputs (line
31).Figure6-(b)showstheground-truthof AmbiguousTranslator
showninFigure6-(a).Ithasfourstates( ST0‚àºST3)andthereare
multipletransitionsamong ST1,ST2and ST3.Figure 7: Data Dependency Graph by Taint Analysis.
Backward Data Slicing via Taint Analysis. There are several
PHP static analysis tools that support taint analysis: Pixy [ 33],
Eir [27], Taint‚Äôem All [ 81], and TaintPHP [ 53]. Note that most of
them do not properly propagate taint tags through array and ar-
ray index operations. Hence, we reimplement Figure 6 without
usingarrayssothattheycaneffectivelyanalyzeAmbitr.Moreover,
TaintPHP[ 53]doesnotsupportinter-procedureanalysis;hencewe
inlineallfunctions(e.g., dynamic_translate() )inAmbitrand
feedittoTaintPHP.Tothisend,thereverserleveragestheabove
four taint analysis tools to obtain a data dependency graph shown
inFigure7.Itessentiallyshowsthatthevalueof $result iscom-
putedby $outthatisagain dependentonallthevariables including
$input,$state_tbl arrays, $tran, and $cur_state . While this
isaccurate,theresultistoocoarse-grained.Specifically,itshows
allthe $state_tbl arraysarecontributingthevalueof $result.
Itdoesnotprovideaparticularorderofstatetransitionswhichis
critical in revealing attack delivering inputs. Note that one may
improvetheanalysistobettersupportarrays(i.e.,array-sensitive
analysis). However, while array-sensitive analysis can improve the
granularity of the analysis (i.e., identifying data-dependencies at
anelementlevel),itstillprovidesthesameinformationanddoes
nothelp identifythereal CPC.
Value-set Analysis. Thereverserusesthreestaticanalysistools
for PHP: PHPStan [ 45], Psalm [ 73], and WeVerca [ 28]. The tools
1127HidingCriticalProgramComponentsviaAmbiguousTranslation ICSE‚Äô22,May21‚Äì29,2022,Pittsburgh,PA,USA
Table 4: Value-set Analysis Result for Key Variables.
Variable Value-Set
$tran {0, 1, 2, 3, ... }
$cur_state {ST0, ST1, ST2, ST3, ... }
$ret{"urtonk", "drunks", "7GZ ‚àºmp3.gs", "83s|png.gz"
"wxp.zy|*3F", "ubuntu|+0F", ... }
$result Combinations of values of $ret
implement a data flow analysis technique that can be used to build
value-setanalysis,whichidentifiesasetofpossiblevaluesavari-
able can have during the execution [ 4]. The reverser leverages
them to infer potential values that each variable can hold in the
Ambitr instance shown in Figure 6-(a). Table 4 shows the result
of the value-set analysis on each key variable in Figure 6-(a). In
short, the result is not an effective way to expose the genuine CPC
due to two reasons. First, while the analysis reveals all possible
inputsfor$retand $result, it simply dumps all the outputs of
the transitions in Ambiguous Translator . To analyze Ambiguous
Translator ,onehastounderstandtheorderofoutputsgenerated
by transitions rather than a set of outputs. Second, even for the
revealed outputs stated in Ambiguous Translator as shown in Ta-
ble 4, they are misleading. Those outputs are not the ones that
will be generated when an attack delivering input is provided. For
instance,theAmbitrinstanceinFigure6-(a)candeliveracodesnip-
pet unlink(‚Äò/tmp/.found.txt‚Äô); when a sequence of inputs
spines,TEA[steam] ,and aegtconfine areprovided.Theinputs
dynamically transform the outputs annotated on the transitions
(i.e., urdonk,7GZ‚àºmp3.es, and wxp.zwl*30 ) into the code snip-
pets (i.e., unlink,(‚Äò/tmp/.fo , and und.txt‚Äô); respectively).
4.3.3 SymbolicExecutionTools. Inthissection,thereverseruses
symbolic execution tools to reverse-engineer the genuine CPC
translation logic of Ambitr. Specifically, four symbolic execution
tools,THAPS[ 31],PHPScan[ 72],KPHP[ 25],andSymex[ 50]ar e
used. The tools aim to identify all possible inputs that can lead
tonewprogramexecutionpathsorstates.Notethatanon-array
versionof Ambitrisused,asthesymbolicexecutionsfailtosupport
arrayproperly.
State Explosion. None of the symbolic execution tools we used
finishes the analysis in a week due to state explosion [ 10,15,71].
Specifically, for each state, Ambiguous Translator has multiple tran-
sitions to the next states. Hence, the number of possible transition
pathsgrowsexponentially.Forinstance,supposetheinputhas ùë•
wordsrequiring ùë•statetransitions,therewillbe5ùë•possibletran-
sition paths, leading to state explosion. KPHP [ 25] crashed after
running7hours17minutesduetoinsufficientmemory.Further,we
createasimplifiedversionof Ambitrthathasasingletransition
witha4-byteinputforeachtransition.Thefoursymbolicexecution
tools failed to finish the analysis within a week as well.
Experiments with Enhanced PHPScan. Since the vanilla ver-
sions of symbolic execution tools failed to analyze a very small
instance of Ambitr (with a single transition), we manually opti-
mizePHPScan[ 72]anduseittoanalyzeAmbitr.Specifically, we
modifyPHPScansothatitcan(1) cacheandreusesolvedconstraints ,
and (2)merge and reduce multiple constraints into fewer constraints .
We use a machine with Intel i7-8550U 4.0 GHz and 16 GB RAMto run this experiment. We conduct two experiments. We prepare
Ambitrinstanceswith(1)differentnumbersoftransitionswhere
eachtransitionwilltake3-byteinputand(2)asingletransitionbut
withdifferentinputlengths.
1) Different numbers of transitions: As the number of transitions
increases,thenumberofstatestoexploreisincreasedexponentially.
For instance, with a single additional transition, the number of
statesbecomes10timeslarger.Wepreparesimplifiedversionsof
Ambitr that have 4, 5, and 6 transitions where each transition
takes 3 characters long input. We use PHPScan to analyze them. It
takesabout3hours,2days,and4weekstofinishtheanalysisof
AmbiguousTranslator with4,5,and6transitions,respectively.Note
that the input length (currently 3) is a root cause of state explosion.
In this example, we set it 3 for each transition.
2)Differentinputlengths: Dynamicoutputtranslationalsocauses
the state explosion. To understand its impact on the number of
statesduringthesymbolicexecution,wecreateasimplifiedversion
of Ambitr with input lengths of 6, 7 and 8. Analyzing a single
transitionfortheinputlength6(i.e.,6charactersinput)takesabout
15hours30minutes.Inputlengths7and8,whicharetypicallengths
of inputs in our samples, take more than 2.9 days and 13 days to
finishthe analysis,respectively. This shows that analyzing even a
singletransition is time-consuming.
Optimization Causing Under-approximation. Symbolic anal-
ysis,inpractice,usesanoptimizationstrategythataimstofind one
input that drives the execution to a particular point instead of enu-
meratingallpossibleinputs.Asaresult,ev enthereverserreachesa
particular state, the identified input is unlikely an attack delivering
input.Forexample, inFigure 8-(a), the array $fnrepresents a func-
tion name. Before it‚Äôs invoked at line 6, it is constructed at lines
3‚Äì5 after satisfying multiple path conditions at line 2. Symbolic
analysis encodes the pathconditions and gets one solution shown
inFigure8-(b)fromtheunderlyingconstraintsolver.Theexecution
successfully goes into the truebranch and invokes the function $f.
However,itinvokesfunction uniqidinsteadoffunction unlink
thatconstitutesthegenuineCPCasshowninFigure8-(c).Given
thisbranchhasbeensuccessfullyexplored,thesymbolicanalysis
will not try other solutions satisfying the path condition and thus
cannotdiscover the genuine CPC.
1
2
3
4
5
6
7
(a) Source Code(b) Resolved $fn[] and $f
(c) Intended $fn[] and $f$fn=array(...);
if($fn[0]> =85&&$fn[1]> =78&&
$fn[2]> =73&&$fn[3]> =81&&
$fn[4]> =73&&$fn[5]> =68){
foreach($fn as $c )
$f=$f.chr($c);
$f=strtolower ($f);
$f(...);
}Variable Value
$fn[] {85,78,73,81,73,68}
$f ‚Äúuniqid‚Äù
Variable Value
$fn[] {117,110,108,105,110,107}
$f ‚Äúunlink‚Äù
Figure 8: Symbolic Execution Exploring a Single Input.
DescribingConstraints. Althoughthereversercanuse symbolic
analysistomodelthepathpredicatesasconstraintsanddrivethe
execution to a particular program location, it is challenging to
explicitlyencodethe criteriaofthegenuine CPCasconstraints (e.g.,
constraints that describe the CPC). In other words, he may not
even know what exactly he is looking for and how to describe the
logicinawaytheunderlyingconstraintsolvercanunderstand.For
1128ICSE‚Äô22,May21‚Äì29,2022,Pittsburgh,PA,USA ChijungJung,DoowonKim,AnChen,WeihangWang,YunhuiZheng,KyuHyungLee,andYonghwiKwon
example,itischallengingbecauseanyvalidstatementsandfunction
names can be potentially CPC. As a result, the satisfiable solutions
to the incomplete constraints may lead to a place of interest but
willnotreveal the genuine CPC.
EmpiricalExperimenton the State Explosion. To understand
how difficult to analyze Ambitr with symbolic execution tech-
niques in detail, we run experiments with PHPScan [ 72] which
usesthez3solver[ 43]forconstraintsolving.Notethattheorigi-
nal version of PHPScan was too inefficient. It failed to finish the
analysis on a very small Ambitr sample (e.g., a single transition of
4characterslonginput/output)in24hours.Hence,wemanually
improvethePHPScan‚Äôsperformancebymodifyingitto(1)cache
and reuse already solved constraints, and (2) merge and reduce
multiple identical constraints into fewer constraints. We run the
enhancedversionofPHPScanonamachinewithInteli7-8550U4.0
GHzand16 GB RAM.
Table 5 shows the experiment results. As shown in the ‚ÄúAu-
tomaton Size‚Äù columns, we created 16 different sizes Ambiguous
Translator . The size is defined as a pair of the length of input char-
actersandthenumberofthetransition.Forinstance,‚Äú6chars.,1
trans.‚Äùmeansa AmbiguousTranslator thathasasingletransition
between two states, and the transition input/output is 6 characters
long.Anexamplecanbeasubstate-machineofFigure9between
ST_0and ST_1(Input:‚Äústates‚Äù,Output:‚Äúurdonk‚Äù).The‚Äú#Const.‚Äù
columnspresentthenumberofconstraintsthatshouldbeexplored
byPHPScan.The‚ÄúTime‚Äùcolumnsshowtherequiredtimeforthe
analysis. Note that as the Ambiguous Translator gets bigger, the
number of constraints increases exponentially. In many cases (i.e.,
the gray cells), the experiments did not finish even after 10 days.
Forthosecases,weestimatetherequiredtimebasedonthenumber
ofprocessedconstraintsandremaining(alsoestimated)constraints.
Observe that the enhanced version of PHPScan takes more than
10 days to analyze Ambiguous Translator instances with more than
3transitionsof5charactersinput/output(whichismuchsmaller
thantypical Ambiguous Translator we generated and used).
Figure 9 consists of 17 transitions and its average input/out-
putsizeis9.64,whichismuchlargerthanthelargest Ambiguous
Translator presentedinTable5(4transitionsof7characterslong
input/output).Notethateveniftheanalysissuccessfullyfinishes,
the analysis results (e.g., inputs to make all possible transitions) do
notexpose the genuine CPC.
Table 5: PHPScan on Different Sizes of Ambitr
AutomatonSize #ofTimeAutomaton Size # ofTime(Input,Trans.) Const. (Input,Trans.) Const.
4chars.,1 trans. 35 K 31.5 m 6 chars., 1 trans. 10 M 14.8 h
4 chars., 2 trans. 386 K 4.3 h 6 chars., 2 trans. 112 M 4.7 d
4 chars., 3 trans. 6 M 8.1 d 6chars.,3 trans. 1.2B 149.3d
4chars.,4 trans. 61M121d6chars.,4 trans. 12B 5.7y
5chars.,1 trans. 181 K 2.9 h 7 chars., 1 trans. 4 M 3.5 d
5 chars., 2 trans. 1.9 M 19.8 h 7chars.,2 trans. 4.5B 26.3d
5chars.,3 trans. 31M37.8d7chars.,3 trans. 49B 1.6y
5chars.,4 trans. 315M1.4y7chars.,4 trans. 498B 20y
Graycellsindicatethattheexperiments did not finish in 10 days. The times presented
forthemare estimated based on the performance measured in the first ten days of
execution.
4.3.4 Source Code and Input Analysis. We aim to show how the
reverser would make manual reverse-engineering attempts to findST_0 ST_1
ST_2In: ‚Äústates‚Äù
Out: ‚Äúurdonk‚ÄùIn: ‚Äúprince‚Äù
Out: ‚Äúdrunks‚Äù
ST_3In: ‚Äúcelestiala‚Äù
Out: ‚Äú7GZ~mp3.es‚ÄùST_4
In: ‚Äúfiscaltable‚Äù
Out: ‚Äúubuntu|+0F‚Äù
In: ‚Äúfinancially‚Äù
Out: ‚Äúlinuxmint|‚ÄùIn: ‚Äúcostinfisco‚Äù
Out: ‚Äúwxp.zwl*30‚ÄùIn: ‚Äúcontingent‚Äù
Out: ‚Äúprovisional‚ÄùIn: ‚Äúpigeonhole‚Äù
Out: ‚Äúdiscompose‚Äù
In: ‚Äúastronomia‚Äù
Out: ‚Äúw95.vb|abc‚Äù
ST_5In: ‚Äúspeeds‚Äù
Out: ‚Äúugrind‚ÄùIn: ‚Äúsecurityprivacy‚Äù
Out: ‚Äúresponsibility‚Äù
In: ‚Äúreality‚Äù
Out: ‚Äúmage|rv‚ÄùST_6In: ‚Äúconstant-value‚Äù
Out: ‚Äúdefinite|-tonk‚Äù
Figure9:Simplified Ambiguous Translator usedintheInput
Analysis.
Input Output Transitions
Initial Inputstates celestials cost-
effective fiscal-yearurdonk 7GZ~mp3.e 
wxp.>nl‚Äô%0ive ubuntu5C3;ST_0/g198ST_1/g198ST_3 
/g198ST_2/g198ST_3
First Trialrealm;celestials cost-
effective fiscal-yearsWgmmP4TZ~mp4.g  dekj‚ÄômlWl
ok  +#sklm33azrST_0/g198ST_5/g198ST_6 
/g198ST_1/g198ST_2
Second Trialprovincecelestials cost-
effective fiscal-yeardr{vq| iely}~int  boo*jeVWZw\{  
Zaak5ylarST_0/g198ST_2/g198ST_5 
/g198ST_4/g198ST_1
Third Trialstates planetarycost-
effective fiscal-yearurdonk 5&avpug,u  ios7ofsmsive 
ei^^q,iWXuST_0/g198ST_1/g198ST_2 
/g198ST_5/g198ST_4
Fourth Trialstates astronomical 
cost-effective fiscal- yearurdonk w95.vb|abeal  prtv-jhpe
PiveZcizearST_0/g198ST_1/g198ST_4 
/g198ST_0/g198ST_2
Figure 10: Inputs used during the Input Analysis.
out the secret input leading to the genuine CPC in Ambitr by
manuallyinspectingsourcecodeandguessinginputs.Weassume
the reverser obtained a sample of Ambitr and reverse-engineered
Ambiguous Translator as shown in Figure 9. Then, the reverser
executesthe sampleand identifiesinput thatthe sampleretrieves.
The input are shown in the first row of Figure 10 (Initial Input).
As expected, the input does not lead to the genuine CPC. To this
end,thereversertriestoguessinputsleveragingknowledgegained
from manual source code inspection.
Thereversermodifiesthefirstinputbyguessingapossibleal-
ternative word. Specifically, realm;is chosen as it is a synonym
forstates, the original input. Note that all other inputs remain
unchanged.However,sincethefirstinputleadstoadifferenttransi-
tion ( ST_0‚ÜíST_5),all the subsequent transitions (shown in the last
column)are different from the transitions for the initial input , result-
inginacompletelydifferentoutput.Inthesecondtrial,thereverser
changes the first input to province , which is another synonym
forstates. Again, the output and the transitions are changed sig-
nificantly, leaving no particular hints for the next trial. From the
thirdtrial,thereverserstartstoguessthesecondinput.Specifically,
planetary isused.Observethatthefirstoutputwordremainsthe
same,whileallthesubsequentoutputsandtransitionsarechanged.
While this shows that the first input is related to the first output, it
is not useful in reverse-engineering the attack delivering the input.
Thefourthtrialissimilar.Changingasinglewordintheinputleads
to all subsequent output words, and transitions being changed.
1129HidingCriticalProgramComponentsviaAmbiguousTranslation ICSE‚Äô22,May21‚Äì29,2022,Pittsburgh,PA,USA
5 DISCUSSION
Generality. WhileweimplementourprototypeinPHP,theideais
general and can be implemented in other programming languages.
To support executable CPCs, one needs to implement dynamic
codegenerationandexecutionprimitivessuchas eval().Script
languages such as JavaScript and Python support them by default.
In other programming languages such as C/C++, one may leverage
JIT compilation techniques [11].
HandlingNon-ASCII InputsandOutputs. Forbetterreadabil-
ity, we only discuss example cases when inputs and outputs are
ASCIIcharacters.However,Ambitrseamlesslysupportsnon-ASCII
inputsandoutputs.Specifically,iftheinputisoutofrangeofASCII
characters,Ambitrcalculatesthedistanceofprovidedinputand
the state transition‚Äôs input without converting them to ASCII code
value. Similarly, Ambitr computes the output directly from the
distance values and state transition output without considering
theirASCIIvalues.
ThreatstoValidity. TheexperimentsinSection4.2areconducted
by two individuals who have sufficient background in computer
science using state-of-the-art open-source tools. Specifically, the
experimentpresentedinSection4.3.3isconductedbyacomputer
science Ph.D. student with sufficient program analysis and secu-
rity background. The work in Section 4.3.4 is done by an expert in
software engineering and security (holding a Ph.D. in Computer
Science).Inaddition,twoundergraduatestudentsmajoringinCom-
puterScience(focusingoncomputer security)have repeated the
experimentsandreachedthesameconclusions.Notethatallpartic-
ipantsdidnotknowtheproposedapproachpriortotheexperiment.
Theanalysisresultsmaydifferdependingonthetools‚Äôcapability
andtheanalysts‚Äôexpertise.
6 RELATED WORK
HidingProgramCode. Thereexistsalineofworkinobfuscation
tohideprogramcodeleveragingopaquepredicates[ 16,47,67],code
insertion/replacement [ 5,37,54,61,76], encryptions [ 66,75], hard-
ware primitives [ 12,64], and sub-tree embedding [ 24]. However,
opaquepredicates can be detected and removed via advanced pro-
gram analysis techniques [ 44]. Dummy code snippets inserted into
anexistingprogramcanbeidentifiedandremovedviadependency
analysissuchastaintanalysis[ 17,27,33,42,52,53,55,56,63,65,81].
Anti-analysis Techniques. Recently,[ 54]presentsasystematic
studyofmultiplemethodstohindersymbolicexecutiontechniques.
Specifically, it inserts additional code to increase the number of
feasible paths.Ambitr‚Äôs Ambiguous Translator not onlyincreases
the number of feasible paths but also provides many more addi-
tionalchallengessuchasambiguityviadynamicoutputtranslation.
[24]transformsprogramcodesnippetsintoasubabstractsyntax
tree (AST), and injects the tree into the AST of a program. How-
ever, dynamic analysis and symbolic analysis tools can detect such
injected code. Data obfuscations (e.g., encrypting code sections
and decryption them at runtime) are easily handled by dynamic
analysis [ 9,41,68]. Approaches that require particular hardware
support are difficult to be used in real-world program, as many
systemsmaynotsatisfythehardwarerequirement.Unlikethem,
Ambitrischallengingtobeanalyzedbystatic,symbolic,anddy-
namic analysis tools as shown in Section 4. It does not require any
particularhardware or software.7 CONCLUSION
Protecting critical program components (e.g., patented program
logic or sensitive data) is an important requirement in software
systems.Inthis paper,we present Ambitr, anovel technique that
hidescriticalprogramcomponentsviaasophisticatedstatemachine
basedtranslatorcalled AmbiguousTranslator .Itimposesfundamen-
talchallengestostate-of-the-artprogramanalysistechniquesby
addinganewdimensionofthechallenge:ambiguity.Ourevaluation
ofthecomparisonwithadiversesetofstate-of-the-artanalysistech-
niques,includingdynamic,static,andsymbolicexecution,shows
that Ambitris effective in hiding critical program components.
ACKNOWLEDGMENTS
Wethanktheanonymousrefereesfortheirconstructivefeedback.
TheauthorsgratefullyacknowledgethesupportofNSF1916499,
1908021,2047980,1850392,1853374,1924777,2145616,and2047980.
ThisresearchwasalsopartiallysupportedbyaMozillaResearch
Award, a Facebook Research Award, and a gift from Cisco Sys-
tems.Anyopinions,findings,andconclusionsorrecommendations
expressed in this material are those of the authors and do not nec-
essarilyreflect the views of the sponsor.
REFERENCES
[1]HiralalAgrawalandJosephR.Horgan.1990. DynamicProgramSlicing. SIGPLAN
Not.25, 6 (June 1990), 246‚Äì256. https://doi.org/10.1145/93548.93576
[2] ChristianAmmann.2012. Hyperion:Implementationof a PE-Crypter.
[3]DavidEBakken,RRarameswaran,DouglasMBlough,AndyAFranz,andTyJ
Palmer.2004. Dataobfuscation:Anonymityanddesensitizationofusabledata
sets.IEEESecurity & Privacy 2, 6 (2004), 34‚Äì41.
[4]GogulBalakrishnanandThomasReps.2004. AnalyzingMemoryAccessesinx86
Executables.In CompilerConstruction , Evelyn Duesterwald (Ed.). SpringerBerlin
Heidelberg,Berlin,Heidelberg, 5‚Äì23.
[5]SebastianBanescu,ChristianCollberg,VijayGanesh,ZackNewsham,andAlexan-
der Pretschner. 2016. Code Obfuscation against Symbolic Execution Attacks. In
Proceedingsofthe32ndAnnualConferenceonComputerSecurityApplications (Los
Angeles,California,USA) (ACSAC‚Äô16) .AssociationforComputingMachinery,
New York, NY, USA, 189‚Äì200. https://doi.org/10.1145/2991079.2991114
[6]Cristian Barr√≠a, David Cordero, Claudio Cubillos, and Robinson Osses. 2016.
Obfuscation procedure based in dead code insertion into crypter. In 2016 6th
International Conference on Computers Communications and Control (ICCCC) .
IEEE,23‚Äì29.
[7]BDLeet. 2016. GitHub - BDLeet/public-shell: Some Public Shell. https://github.c
om/BDLeet/public-shell.
[8]Bart Blaze. 2019. GitHub - bartblaze/PHP-backdoors: A collection of PHP back-
doors. https://github.com/bartblaze/PHP-backdoors.
[9]DavidBrumley,CodyHartwig,ZhenkaiLiang,JamesNewsome,DawnSong,and
HengYin.2008. Automaticallyidentifyingtrigger-basedbehaviorinmalware.
InBotnetDetection . Springer, 65‚Äì88.
[10]JerryRBurch,EdmundMClarke,KennethLMcMillan,DavidLDill,andLain-
JinnHwang.1992. Symbolicmodelchecking:1020statesandbeyond. Information
and computation 98, 2 (1992), 142‚Äì170.
[11]Juan Manuel Martinez Caama√±o and Serge Guelton. 2018. Easy::Jit: Compiler
AssistedLibrarytoEnableJust-in-TimeCompilationinC++Codes.In Conference
Companionofthe2ndInternationalConferenceonArt,Science,andEngineering
of Programming (Nice, France) (Programming‚Äô18 Companion) . Association for
ComputingMachinery,NewYork,NY,USA,49‚Äì50. https://doi.org/10.1145/3191
697.3191725
[12]Haibo Chen, Liwei Yuan, Xi Wu, Binyu Zang, Bo Huang, and Pen-chung Yew.
2009. Control flow obfuscation with information flow tracking. In Proceedings of
the 42nd Annual IEEE/ACM International Symposium on Microarchitecture . ACM,
391‚Äì400.
[13]Binlin Cheng, Jiang Ming, Jianmin Fu, Guojun Peng, Ting Chen, Xiaosong
Zhang, and Jean-Yves Marion. 2018. Towards Paving the Way for Large-
ScaleWindowsMalwareAnalysis:GenericBinaryUnpackingwithOrders-of-
Magnitude Performance Boost. In Proceedings of the 2018 ACM SIGSAC Con-
ference on Computer and Communications Security (Toronto, Canada) (CCS
‚Äô18). Association for Computing Machinery, New York, NY, USA, 395‚Äì411.
https://doi.org/10.1145/3243734.3243771
1130ICSE‚Äô22,May21‚Äì29,2022,Pittsburgh,PA,USA ChijungJung,DoowonKim,AnChen,WeihangWang,YunhuiZheng,KyuHyungLee,andYonghwiKwon
[14]Binlin Cheng, Jiang Ming, Erika A Leal, Haotian Zhang, Jianming Fu, Guojun
Peng, and Jean-Yves Marion. 2021. Obfuscation-Resilient Executable Payload
ExtractionFrom Packed Malware. In 30th USENIX Security Symposium (USENIX
Security 21) .
[15]Edmund M Clarke, William Klieber, Milo≈° Nov√°ƒçek, and Paolo Zuliani. 2011.
Model checking and the state explosion problem. In LASERSummer School on
Software Engineering . Springer, 1‚Äì30.
[16]ChristianCollberg,ClarkThomborson, andDouglasLow.1998. Manufacturing
cheap, resilient,and stealthyopaque constructs. In Proceedings ofthe 25thACM
SIGPLAN-SIGACT symposium on Principles of programming languages . ACM,
184‚Äì196.
[17]Johannes Dahse and J√∂rg Schwenk. 2010. RIPS-A static source code analyser for
vulnerabilitiesin PHP scripts. Retrieved: February 28 (2010), 2012.
[18]BiniamFissehaDemissie,MarianoCeccato,andRobertoTiella.2015. Assessment
of Data Obfuscation with Residue Number Coding. In Proceedings of the 1st
International Workshop onSoftware Protection (Florence,Italy) (SPRO‚Äô15) . IEEE
Press, 38‚Äì44.
[19]Zhui Deng, Brendan Saltaformaggio, Xiangyu Zhang, and Dongyan Xu. 2015.
iris: Vetting private api abuse in ios applications. In Proceedings of the 22nd ACM
SIGSAC Conference on Computer and Communications Security . 44‚Äì56.
[20]DerickRethans.2009. VariabletracingwithXdebug‚ÄîDerickRethans. https:
//derickrethans.nl/variable-tracing-with-xdebug.html.
[21]Derick Rethans. 2020. Xdebug - Debugger and Profiler Tool for PHP. h ttps:
//xdebug.org/.
[22]dwyl. 2019. A text file containing 479k English words. https://github.com/dwyl/
english-words.
[23] Evi1cg.2019. GitHub- Ridter/Pentest. https://github.com/Ridter/Pentest.
[24]AuroreFass,MichaelBackes,andBenStock.2019. Hidenoseek:Camouflaging
malicious javascript in benign asts. In Proceedings of the 2019 ACM SIGSAC
Conferenceon Computer and Communications Security . 1899‚Äì1913.
[25]Daniele Filaretti and Sergio Maffeis. 2014. An executable formal semantics of
PHP. InEuropean Conference on Object-Oriented Programming . Springer.
[26]Maurice Fonk. 2019. GitHub - naneau/php-obfuscator: an "obfuscator" for
PSR/OOpPHPcode. https://github.com/naneau/php-obfuscator.
[27]Heilan Yvette Grimes. 2015. Eir - Static Vulnerability Detection in PHP Applica-
tions. (2015).
[28]David Hauzar and Jan Kofro≈à. 2014. WeVerca: Web Applications Verification for
PHP. InInternational Conference on Software Engineering and Formal Methods .
Springer, 296‚Äì301.
[29]Cristian Barr√≠a Huidobro, David Cordero, Claudio Cubillos, H√©ctor Allende Cid,
andClaudioCasadoBarrag√°n.2018. Obfuscationprocedurebasedontheinser-
tionofthedeadcodeinthecrypterbybinarysearch.In 20187thInternational
Conference on Computers Communicationsand Control (ICCCC) . IEEE, 183‚Äì192.
[30]Imperva. 2021. Data Obfuscation. https://www.imperva.com/learn/data-
security/data-obfuscation/.
[31]Torben Jensen, Heine Pedersen, Mads Chr Olesen, and Ren√© Rydhof Hansen.
2012. Thaps: automated vulnerability scanning of php applications. In Nordic
conferenceon secure IT systems . Springer, 31‚Äì46.
[32]Ryan Johnson and Angelos Stavrou. 2013. Forced-path execution for android
applicationsonx86platforms.In 2013IEEESeventhInternationalConferenceon
Software Security and Reliability Companion . IEEE, 188‚Äì197.
[33]NenadJovanovic,ChristopherKruegel,andEnginKirda.2006. Pixy:Astaticanal-
ysistoolfordetectingwebapplicationvulnerabilities.In 2006IEEESymposium
on Security and Privacy (S&P) . IEEE, 6‚Äìpp.
[34]Min Gyung Kang, Pongsin Poosankam, and Heng Yin. 2007. Renovo: A Hidden
CodeExtractorforPackedExecutables.In Proceedingsofthe2007ACMWorkshop
onRecurringMalcode (Alexandria,Virginia,USA) (WORM‚Äô07) .Associationfor
ComputingMachinery,NewYork,NY,USA,46‚Äì53. https://doi.org/10.1145/1314
389.1314399
[35]Kyungtae Kim, I Luk Kim, Chung Hwan Kim, Yonghwi Kwon, Yunhui Zheng,
XiangyuZhang,andDongyanXu.2017.J-force:Forcedexecutiononjavascript.In
Proceedings of the 26th international conference on World Wide Web . International
World Wide Web Conferences Steering Committee, 897‚Äì906.
[36]PascalKissian.2019. YAKPro:PhpObfuscator. https://www.php-obfuscator.c
om/.
[37]Byoungyoung Lee, Yuna Kim, and Jong Kim. 2010. binOb+: a framework for
potentandstealthybinaryobfuscation.In Proceedingsofthe5thACMSymposium
on Information, Computer and Communications Security . ACM, 271‚Äì281.
[38]YoungBiLee,JaeHyukSuk,andDongHoonLee.2021. BypassingAnti-Analysis
ofCommercialProtectorMethods UsingDBITools. IEEEAccess 9(2021),7655‚Äì
7673.
[39]Robert Lie. 2019. Simple online PHP obfuscator: encodes PHP code into random
letters, numbers and/or characters. https://www.mobilefish.com/services/php _o
bfuscator/php_obfuscator.php.
[40]Alessandro Mantovani, Simone Aonzo, Xabier Ugarte-Pedrero, Alessio Merlo,
and Davide Balzarotti. 2020. Prevalence and Impact of Low-Entropy Packing
Schemes in the Malware Ecosystem. In Network and Distributed System Security
(NDSS)Symposium,NDSS , Vol. 20.[41]JianMao,JingdongBian,GuangdongBai,RuilongWang,YueChen,YinhaoXiao,
andZhenkaiLiang.2018.Detectingmaliciousbehaviorsinjavascriptapplications.
IEEEAccess 6 (2018), 12284‚Äì12294.
[42]Ib√©ria Medeiros, Nuno F Neves, and Miguel Correia. 2014. Automatic detection
andcorrectionofwebapplicationvulnerabilitiesusingdataminingtopredict
falsepositives.In Proceedingsofthe23rdinternationalconferenceonWorldwide
web. ACM, 63‚Äì74.
[43]Microsoft. 2020. Z3Prover/z3: The Z3 Theorem Prover. https://github.com/Z3P
rover/z3.
[44]JiangMing,DongpengXu,LiWang,andDinghaoWu.2015. Loop:Logic-oriented
opaque predicate detection in obfuscated binary code. In Proceedings of the 22nd
ACM SIGSAC Conference on Computer and Communications Security . ACM, 757‚Äì
768.
[45]OndÀòrejMirtes.2019. GitHub-phpstan/phpstan:PHPStaticAnalysisTool. https:
//github.com/phpstan/phpstan.
[46]Shoya Morishige, Shuichiro Haruta, Hiromu Asahina, and Iwao Sasase. 2017.
Obfuscated malicious javascript detection scheme using the feature based on
dividedurl.In 201723rdAsia-PacificConferenceonCommunications(APCC) .IEEE,
1‚Äì6.
[47]Andreas Moser, Christopher Kruegel, and Engin Kirda. 2007. Limits of static
analysis for malware detection. In Twenty-Third Annual Computer Security Appli-
cationsConference(ACSAC 2007) . IEEE, 421‚Äì430.
[48]Abbas Naderi-Afooshteh, Yonghwi Kwon, Anh Nguyen-Tuong, Ali Razmjoo-
Qalaei, Mohammad-Reza Zamiri-Gourabi, and Jack W Davidson. 2019. MalMax:
Multi-Aspect Execution for Automated Dynamic Web Server Malware Analysis.
InProceedingsofthe2019ACMSIGSACConferenceonComputerandCommunica-
tionsSecurity . 1849‚Äì1866.
[49]JamesNewsomeandDawnXiaodongSong.2005. DynamicTaintAnalysisforAu-
tomaticDetection,Analysis,andSignatureGenerationofExploitsonCommodity
Software.. In NDSS, Vol. 5. Citeseer, 3‚Äì4.
[50]HungVietNguyen,HoanAnhNguyen,TungThanhNguyen,andTienNNguyen.
2011. Auto-locating and fix-propagating for HTML validation errors to PHP
server-sidecode.In Proceedingsofthe201126thIEEE/ACMInternational Confer-
enceon Automated Software Engineering . IEEE Computer Society, 13‚Äì22.
[51]nixawk. 2018. GitHub - nixawk/fuzzdb: Web Fuzzing Discovery and Attack
PatternDatabase. https://github.com/nixawk/fuzzdb.
[52]Paulo Jorge Costa Nunes, Jos√© Fonseca, and Marco Vieira. 2015. phpSAFE: A
security analysis tool for OOP web application plugins. In 2015 45th Annual
IEEE/IFIPInternationalConferenceon Dependable Systems and Networks .
[53]Oswaldo Olivo. 2016. GitHub - olivo/TaintPHP: Static Taint Analysis for PHP
web applications. https://github.com/olivo/TaintPHP.
[54]Mathilde Ollivier, S√©bastien Bardin, Richard Bonichon, and Jean-Yves Marion.
2019. How to Kill Symbolic Deobfuscation for Free (or: Unleashing the Potential
ofPath-OrientedProtections).In Proceedingsofthe35thAnnualComputerSecurity
ApplicationsConference (SanJuan,PuertoRico,USA) (ACSAC‚Äô19) .Association
for Computing Machinery, New York, NY, USA, 177‚Äì189. https://doi.org/10.114
5/3359789.3359812
[55]OneSourceCat. 2015. GitHub - OneSourceCat/phpvulhunter: A tool that can
scan php vulnerabilities automatically using static analysis methods. https:
//github.com/OneSourceCat/phpvulhunter.
[56]IoannisPapagiannis, MatteoMigliavacca, andPeter Pietzuch.2011. PHPAspis:
usingpartialtainttrackingtoprotectagainstinjectionattacks.In 2ndUSENIX
Conferenceon Web Application Development , Vol. 13.
[57]FeiPeng,ZhuiDeng,XiangyuZhang,DongyanXu,ZhiqiangLin,andZhendong
Su. 2014. X-force: force-executing binary programs for security applications. In
23rd USENIX Security Symposium . 829‚Äì844.
[58]PHP. 2019. PHP: Pspell Functions. https://www.php.net/manual/en/ref.pspell.p
hp.
[59]phpencoder2021. PHPEncoder,protectPHPscriptswithSourceGuardianand
bytecode. https://www.sourceguardian.com/.
[60]Pipsomania. 2018. Best PHP Obfuscator. http://www.pipsomania.com/best _php
_obfuscator.do
[61]IgorV Popov, Saumya K Debray, and Gregory R Andrews. 2007. Binary Obfusca-
tionUsingSignals.In USENIXSecurity Symposium . 275‚Äì290.
[62]Paul Royal, Mitch Halpin, David Dagon, Robert Edmonds, and Wenke Lee. 2006.
PolyUnpack:AutomatingtheHidden-CodeExtractionofUnpack-ExecutingMal-
ware.In200622ndAnnualComputerSecurityApplicationsConference(ACSAC‚Äô06) .
289‚Äì300. https://doi.org/10.1109/ACSAC.2006.38
[63]DewhurstRyan.2011. Implementingbasicstaticcodeanalysisintointegrated
developmentenvironments(ides)toreducesoftwarevulnerablitilies. AReport
submitted in partial fulfillment of the regulations governing the award of the
DegreeofBSc(Honours)EthicalHackingforComputerSecurityattheUniversityof
Northumbriaat Newcastle 2012(2011).
[64]SebastianSchrittwieser,StefanKatzenbeisser,PeterKieseberg,MarkusHuber,
ManuelLeithner,MartinMulazzani,andEdgarWeippl.2013. Covertcomputation:
Hiding code in code for obfuscation purposes. In Proceedings of the 8th ACM
SIGSAC symposium on Information, computer and communications security . ACM,
529‚Äì534.
1131HidingCriticalProgramComponentsviaAmbiguousTranslation ICSE‚Äô22,May21‚Äì29,2022,Pittsburgh,PA,USA
[65]Design Security. 2016. GitHub - designsecurity/progpilot: A static analysis tool
forsecurity. https://github.com/designsecurity/progpilot.
[66]MonirulISharif,AndreaLanzi,JonathonTGiffin,andWenkeLee.2008. Impeding
Malware Analysis Using Conditional Code Obfuscation.. In NDSS.
[67]BrendanSheridanandMicahSherr.2016. OnManufacturingResilientOpaque
Constructs Against Static Analysis. In European Symposium on Research in Com-
puterSecurity . Springer, 39‚Äì58.
[68]GuillermoSuarez-Tangil,JuanETapiador,FlavioLombardi,andRobertoDiPietro.
2014. Thwartingobfuscatedmalwareviadifferentialfaultanalysis. Computer 47,
6 (2014), 24‚Äì31.
[69] themida2021. Oreans Technologies. https://www.oreans.com/Themida.php.
[70]XabierUgarte-Pedrero,DavideBalzarotti,IgorSantos,andPabloBringas.2016.
RAMBO: Run-Time Packer Analysis with Multiple Branch Observation. 186‚Äì206.
https://doi.org/10.1007/978-3-319-40667-1_10
[71]AnttiValmari.1998. TheStateExplosionProblem.In LecturesonPetriNetsI:Basic
Models, Advances in Petri Nets, the Volumes Are Based on the Advanced Course on
PetriNets .Springer-Verlag,London,UK,UK,429‚Äì528. http://dl.acm.org/citation.
cfm?id=647444.727054
[72]Bart van Arnhem. 2017. GitHub - bartvanarnhem/phpscan: Symbolic execution
inspired PHP application scanner for code-path discovery. https://github.com/b
artvanarnhem/phpscan.
[73]Vimeo.2019. GitHub-vimeo/psalm:Astaticanalysis tool forfindingerrorsin
PHPapplications. https://github.com/vimeo/psalm.
[74] VirusShare. 2019. VirusShare.com. https://virusshare.com/.
[75]ZhiWang,JiangMing,ChunfuJia,andDebinGao.2011. Linearobfuscationto
combat symbolic execution. In European Symposium on Research in ComputerSecurity. Springer, 210‚Äì226.
[76] Zhi Wang, JiangMing, Chunfu Jia,and Debin Gao.2011. LinearObfuscation to
CombatSymbolicExecution.In Proceedingsofthe16thEuropeanConferenceon
Research in Computer Security (Leuven, Belgium) (ESORICS‚Äô11) . Springer-Verlag,
Berlin,Heidelberg,210‚Äì226.
[77]Mark Weiser. 1981. Program Slicing. In Proceedings of the 5th International
Conference on Software Engineering (San Diego, California, USA) (ICSE ‚Äô81) . IEEE
Press, 439‚Äì449.
[78]JeffreyWilhelmandTzi-ckerChiueh.2007. Aforcedsampledexecutionapproach
to kernel rootkit identification. In International Workshop on Recent Advances in
IntrusionDetection . Springer, 219‚Äì235.
[79]Dongpeng Xu, Jiang Ming, and Dinghao Wu. 2017. Cryptographic function
detection in obfuscated binaries via bit-precisesymbolic loop mapping. In 2017
IEEESymposiumon Security and Privacy (SP) . IEEE, 921‚Äì937.
[80]BabakYadegariandSaumyaDebray.2015. SymbolicExecutionofObfuscated
Code. InProceedings of the 22nd ACM SIGSAC Conference on Computer and Com-
municationsSecurity (Denver,Colorado,USA) (CCS‚Äô15).AssociationforCom-
puting Machinery, New York, NY, USA, 732‚Äì744. https://doi.org/10.1145/281010
3.2813663
[81]Quan Yang. 2019. GitHub - quanyang/Taint-em-All: A taint analysis tool for the
PHPlanguage. https://github.com/quanyang/Taint-em-All.
[82] yodap 2021. Yoda‚Äôs Protector. https://sourceforge.net/projects/yodap/.
[83]zendguard 2021. Protect PHP Code With Zend Guard. https://www.zend.com/p
roducts/zend-guard.
1132