PReach: A Heuristic for Probabilistic Reachability to Identify
Hard to Reach Statementsâˆ—
Seemanta Saha
University of California, Santa Barbara
Santa Barbara, CA, USA
seemantasaha@cs.ucsb.eduMara Downing
University of California, Santa Barbara
Santa Barbara, CA, USA
maradowning@cs.ucsb.edu
Tegan Brennan
University of California, Santa Barbara
Santa Barbara, CA, USA
tegan@cs.ucsb.eduTevfik Bultan
University of California, Santa Barbara
Santa Barbara, CA, USA
bultan@cs.ucsb.edu
ABSTRACT
Wepresentaheuristicforapproximatingthelikelihoodofreaching
agivenprogramstatementusing1)branchselectivity(representing
the percentage of values that satisfy a branch condition), which
we compute using model counting, 2) dependency analysis, which
we use to identify input-dependent branch conditions that influ-
ence statement reachability, 3) abstract interpretation, which we
use to identify the set of values that reach a branch condition,and 4) a discrete-time Markov chain model, which we construct
to capture the control flow structure of the program together with
theselectivityofeachbranch.Ourexperimentsindicatethatour
heuristic-based probabilistic reachability analysis tool PReach can
identifyhard to reach statements with high precision and accuracy
inbenchmarksfromsoftwareverificationandtestingcompetitions,
ApacheCommonsLang,andtheDARPASTACprogram.Wepro-
videadetailedcomparisonwithprobabilisticsymbolicexecution
and statistical symbolic execution for the purpose of identifying
hardtoreachstatements.PReachachievescomparableprecision
andaccuracytobothprobabilisticandstatisticalsymbolicexecu-
tionforboundedexecutiondepthandbetterprecisionandaccuracy
whenexecutiondepthisunboundedandthenumberofprogram
pathsgrowsexponentially.Moreover,PReachismorescalablethan
both probabilistic and statistical symbolic execution.
CCS CONCEPTS
â€¢Software and its engineering â†’Software testing and de-
bugging;Software verification ;Automated static analysis ;â€¢
Theory of computation â†’Program analysis.
âˆ—This material is based on research sponsored by NSF under grants CCF-2008660,
CCF-1901098 and CCF-1817242. The U.S. Government is authorized to reproduce
and distribute reprints for Governmental purposes notwithstanding any copyrightnotation thereon. The views and conclusions contained herein are those of the au-
thors and should not be interpreted as necessarily representing the official policies or
endorsements, either expressed or implied, of the U.S. Government.
This work is licensed under a Creative Commons Attribution International 4.0 
License.
ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
Â© 2022 Copyright held by the owner/author(s).
ACM ISBN 978-1-4503-9221-1/22/05.
https://doi.org/10.1145/3510003.3510227ACM Reference Format:
SeemantaSaha,MaraDowning,TeganBrennan,andTevfikBultan.2022.
PReach: A Heuristic for Probabilistic Reachability to Identify Hard to
Reach Statements . In 44th International Conference on Software Engineering
(ICSE â€™22), May 21â€“29, 2022, Pittsburgh, PA, USA. ACM, New York, NY, USA,
12 pages. https://doi.org/10.1145/3510003.3510227
1 INTRODUCTION
Software quality assurance is one of the most fundamental prob-
lems in computing. The most common software quality assurance
techniqueissoftwaretesting.Althoughtherehasbeenasurgeof
progress in automated software testing techniques such as random
testing,fuzzingandsymbolicexecutioninrecentyears,thereare
remaining challenges. On one hand, fuzzing and random testing
techniques are comparatively scalable, but have difficulty in ex-
ploringhard to reach program paths. On the other hand, symbolic
executionbasedtechniquescanexplore hardtoreach programpaths
by solving path constraints, but are not as scalable.
Hybridtestingtechniques[ 16,26,38,39,42]combineconcrete
(e.g., random testing, fuzzing) and symbolic techniques in order
toimprovetestingeffectiveness.Typically,astrategyfunctionfor
hybridtestingdecideswhentoapplyconcretetechniquesandwhen
toapplysymbolictechniquestoachievescalableandeffectiveex-
ploration of the program behaviors. In order to choose between
concreteandsymbolicapproaches,mostexistingstrategiesassess
the difficulty of concrete testing based on the saturation of randomtesting[
26,38]orprobabilisticprogramanalysis[ 39,42].Determin-
ing the likelihood (or, conversely, difficulty) of reaching a program
statement is critical for assessing the difficulty of concrete testing,
and hence developing an effective hybrid testing strategy. There
aretwoexistingapproachesthataddressthisproblem:probabilistic
and statistical symbolic execution.
Probabilisticsymbolicexecution[ 20]isanextensionofsymbolic
execution that computes probabilities of program paths. However,
probabilistic symbolic execution suffers from the same limitations
assymbolicexecution:1)Itcanonlyanalyzeprogrambehaviorsuptoacertainfixedexecutiondepth,henceitcannotanalyzebehaviorsofarbitrarilylargeprogrampaths.2)Duetoexponentialincreasein
numberofpathswithincreasingexecutiondepth(pathexplosion
problem),thecostofsymbolicexecutionincreasesexponentially
with increasing execution depth. 3) Although the sizes of path con-
straints generated by symbolic execution increase linearly with
the execution depth, since the worst case complexity of constraint
17062022 IEEE/ACM 44th International Conference on Software Engineering (ICSE)
ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Seemanta Saha, Mara Downing, Tegan Brennan, and Tevfik Bultan
solversisexponential,thelinearincreaseinpathconstraintsizes
can lead to exponential increase in analysis cost. Hence, path ex-
plosioncombinedwithincreasingsizesofpathconstraintscanlead
to double exponential blow up in the cost of symbolic execution,
limiting its practical applicability.
Statistical symbolic execution [ 18] is more efficient and scalable
compared to probabilistic symbolic execution [ 20]. However, it
cannot compute precise reachability probabilities, rather provides
approximate reachability probabilities with statistical guarantee.
Statisticalsymbolicexecutionsuffersfromsimilarissuesasprob-
abilistic symbolic execution. There are two variants of statistical
symbolic execution: 1) statistical analysis based on Monte Carlo
samplingofsymbolicpaths,and2)hybridanalysiscombiningboth
statisticalandexactanalysisbasedoninformedsampling.Oneof
thedrawbacksofpurestatisticalsamplingisthatitneedstosample
alargenumberofpathstoachievehighstatisticalconfidence.In-
formed sampling obtains more precise results and converges faster
than a purely statistical analysis, but its effectiveness suffers when
the number of program paths grows exponentially.
Inthispaper,wepresentaheuristicforprobabilisticreachability
analysistoidentify hardtoreach programstatementsthataddresses
the above shortcomings of probabilistic symbolic execution and
statistical symbolic execution. In particular, 1) our approach can
model behaviors of arbitrarily long paths, 2) it does not suffer from
path explosion, i.e., the cost of our analysis increases polynomially
withthesizeoftheprogram(anddoesnotdependontheexecution
depth) [23], and finally, 3) it solves constraints arising from branch
conditionsratherthanpathconstraintswhichreducesthecostof
constraint solving.
Ourapproach,whichweimplementedinourtoolPReach,works
asfollows(Figure1).Inordertocomputereachabilityprobability
of statements, we introduce a concept called branch selectivity that
determines the proportion of values satisfying a given branch con-
dition. A branch is very selective if only a few values satisfy the
branchcondition.Ontheotherhand,ifalotofvaluessatisfythe
branchcondition,thenthebranchisnotveryselective.Givenatar-
get statement in a program, PReach identifies the input dependent
branchconditionsthatinfluencethereachabilityprobabilityofthat
statement using dependency analysis. Then, PReach constructs
adiscrete-timeMarkovchainmodelfromthecontrolflowgraph
of the program by computing branch selectivity of each branch
condition that influences the reachability probability of the target
statement. PReach uses abstract interpretation to determine the
set of values that reach each branch condition and model counting
to compute the branch selectivity value for each branch in the pro-
gram that influences statement reachability. Finally, PReach uses a
probabilisticmodelcheckertocomputethereachabilityprobabil-
ity of the target statement based on the constructed discrete-time
Markov chain model.
Oneshortcomingofourapproachisthatitisnotasoundpro-
gram analysis technique and hence, it does not provide guarantees
intermsoftheprecisionoraccuracyofthereachabilityprobabilities
it reports. On the other hand, though, bounded symbolic execution
is theoretically sound up to the execution bound, and probabilistic
symbolic execution can quantify how much of the execution space
is not explored due to the execution bound [ 18], for unboundedexecutions, both probabilistic symbolic execution and statistical
symbolic execution are not sound either.
We experimentallyevaluate PReachonprograms fromtheSV-
COMP benchmark set used in Competition on Software Verifica-
tion [8] and Competition on Software Testing [ 9]. Each program
inthisbenchmarksetcontainsanassertstatement.Weusethese
assert statements as the target of our probabilistc reachability anal-
ysis.Weevaluatetheeffectivenessofourtechniqueinseparating
hard to reach assert statements (i.e., assert statements with low
reachability probability) from easy to reach assert statements (i.e.,
assert statements with high reachability probability) using a proba-
bility threshold (i.e., if the reachability probability of a statement is
below the given threshold we classify it as hard to reach ).
Inordertodeterminethegroundtruth,weuseageneratorbased
random fuzzer that is based on JQF [ 28] and ZEST [ 29]. We set a
time limit for the random fuzzer, and the assert statements that
arenotreachedwithinthegiventimeoutaremarkedasthe hard
to reachassert statements. Of the 142 programs we used in our
experiments,therandomfuzzertimesouton51programs.PReach
classifiestheprogramsthattherandomfuzzertimesoutonashard-
to-reach,with95.8%precisionand95.1%accuracy.Inparticular,our
techniquecorrectlyclassifies135outof142programsandgenerates
only2falsepositives(reports hardtoreach althoughthefuzzerdoes
not time out) and 5 false negatives (reports easy to reach although
the fuzzer times out).
In order to further evaluate the effectiveness of our probabilistic
reachability analysis, we provide a detailed experimental compari-
sonwiththeprobabilisticsymbolicexecution(PSE)[ 20]andstatisti-
calsymbolicexecution(SSE)[ 18]extensionstoSymbolicPathFinder
(SPF) [30] tool. Experimental resultsshow that for programs with
bounded execution depth, PSE achieves very high precision and
accuracy to identify hard to reach cases. However , PReach out-
performs PSE for programs with unbounded execution depth in
termsofprecision,accuracyandaverageanalysistime.Forlarge
search depths PSE is unable to analyze 38% of the target programs
demonstrating its limitations in terms of applicability and scala-
bility, whereas PReach can analyze 100%. We compare PReach
withSSEonthesetofprogramsthatPSEperformspoorly.SSEwas
unable to analyze 27% of these programs and PReach outperforms
SSE in terms of precision, accuracy, and average analysis time.
Finally, we analyze 24 target statements in 18 methods from
Apache Commons Lang [ 1] and DARPA STAC Benchmarks [ 4].
PReachcanclassify19ofthe24targetstatementscorrectlydemon-
strating its effectiveness on real world programs, whereas PSE and
SSE were able to successfully analyze and classify only one.
2 OVERVIEW
Weformalizeprobabilisticreachabilityanalysisasfollows.Given
aprogram ğ‘,letğ‘–denotetheinputfortheprogram,and ğ¼denote
the domain of inputs (i.e., ğ‘–âˆˆğ¼). Note that ğ‘–can be a scalar value, a
tuple,oralistofvalues.Givenatargetstatement ğ‘¡inprogram ğ‘,
thegoalofprobabilisticreachabilityanalysisistodeterminehow
likelyitistoreachtargetstatement ğ‘¡.Wedothisbydetermining
how likely it would be to pick inputs that result in an execution
that reaches ğ‘¡. In order to determine how likely it would be to pick
1707PReach: A Heuristic for Probabilistic Reachability to Identify Hard to Reach Statements ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
3URJUDP
S
7DUJHW
6WDWHPHQW
W%UDQFK
6HOHFWLYLW\
8VLQJ0RGHO
&RXQWLQJDQG
$EVWUDFW
,QWHUSUHWDWLRQ7DUJHW
6WDWHPHQW
6XEJUDSK
([WUDFWLRQ
8VLQJ
&RQWURO)ORZ
$QDO\VLV'70&
&RQVWUXFWLRQ
8VLQJ
'HSHQGHQF\
$QDO\VLVDQG
4XHU\
)RUPXODWLRQ5HDFKDELOLW\
$QDO\VLV
8VLQJ
3UREDELOLVWLF
0RGHO
&KHFNLQJ Q&6EZ*SWQ50SW
Q3 "
>)Ä³@3SW 3SW7+3SW7+KDUGWRUHDFK
HDV\WRUHDFK<(6
12
Figure 1: Probabilistic Reachability Heuristic in PReach
1public class Main {
2 public static void main(String[] args) {
3 intarg = Verifier.nondetInt();
4 if(a r g<0)
5 return;
6 intx = arg / 5;
7 inty = arg / 5;
8 Main inst = newMain();
9 inst.test(x, y);
10 }
11 public void test( intx,intz) {
12 System.out.println("Testing ExSymExe7");
13 inty=3 ;
1 4 z=x-y-4 ;
15 if(z! =0)
16 System.out.println("branch FOO1");
17 else{
18 System.out.println("branch FOO2");
19 assert false;
20 }
21 if(y! =0)
22 System.out.println("branch BOO1");
23 else
24 System.out.println("branch BOO2");
25 }
26 }
Figure 2: An example based on SV-COMP benchmark
such inputs, we determine the probability of picking such inputs if
inputs are chosen randomly. We define P(ğ‘,ğ‘¡)as:
P(ğ‘,ğ‘¡)denotes the probability of reaching statement
ğ‘ duringthe executionofprogram ğ‘oninputğ‘–ifğ‘–is
selected randomly from the input domain ğ¼.
Weassumeuniformdistributionofinputsinourcurrentimplemen-
tation.However,ourtechnique canbeeasilyextendedto support
any input distribution by integrating usage profiles [ 18] used in
other probabilistic analysis techniques.
It is well-known that determining reachability of a statement
in a program is an uncomputable problem. Hence, determining
P(ğ‘,ğ‘¡)preciselyisalsoanuncomputableproblem.Inthispaperwe
present a heuristic approach that approximates P(ğ‘,ğ‘¡). We report
the reachability probability as a real number between 0 and 1.
Branch Selectivity. Our heuristic approximation of P(ğ‘,ğ‘¡)relies
on a concept we call branch selectivity . Given a branch ğ‘, branch
selectivity S(ğ‘)isproportionaltotheratioofthenumberofvalues
thatsatisfytheconditionforbranch ğ‘tothetotalnumberofvalues
inthedomainofconditionforbranch ğ‘.Formally,givenabranch ğ‘,
letğ·ğ‘denotetheCartesianproductofthedomainsofthevariables
thatappearin ğ‘,andletğ‘‡ğ‘âŠ†ğ·ğ‘denotethesetofvaluesforwhichbranchğ‘evaluates to true. Let |ğ·ğ‘|and|ğ‘‡ğ‘|denote the number of
elements in these sets, respectively. Then, S(ğ‘)=|ğ‘‡ğ‘|
|ğ·ğ‘|.
So, the selectivity of a branch gets closer to 0 as the number
of values that satisfy the branch condition decreases, and it gets
closer to 1 as the number of values that satisfy the branch condi-
tion increases. If we think of branch as a sieve, when S(ğ‘)=0
branchğ‘does not allow any value to pass, and when S(ğ‘)=1
branchğ‘allows all values to pass. Note that, if we pick values
from the domain ğ·randomly with a uniform distribution, then
|ğ‘‡ğ‘|/|ğ·ğ‘|corresponds to the probability of picking a value that
satisfies the branch condition. The branch becomes more selective
as the probability of picking a value decreases.
An Example. Consider the integer-manipulating program in Fig-
ure2.Thisprogramisamodifiedversionofanexamplefromthe
jpf-regression directoryoftheSV-COMPbenchmarkusedforsoft-
wareverificationandtestingcompetitions[ 8].Thetargetstatement
istheassertionstatementinline19.The argvariableâ€™svalueisa
randomlygenerated integervalueand itdenotesthe inputtothis
program. The question we want to answer for this program is: how
likely it is to reach the assertion statement at line 19 if we randomly
generate values for the ğ‘ğ‘Ÿğ‘”variable?
The first conditional statement at line 4 ignores all the negative
values. At line 15, possible values for ğ‘§can be any randomly gener-
atedpositivevalue,dividedby5,minus7.Now,theassertionatline
19 is reachable when value of ğ‘§is equal to 0. The likelihood of the
valueofğ‘§beingequalto0islowiftheinputisarandomnumber
generatedfromauniformdistribution.Therefore,theprobability
of reaching the assert statement in this program is low.
Our analysis uses branch selectivity based on model counting
to successfully determine the reachability probability of the assert
statement in this program. We inspect each branch condition lead-
ing to the assertion to determine how selective the branch is (i.e.
what ratio of input values satisfy the branch). If we assume a do-
main of integer values, then for the conditional statement ğ‘ğ‘Ÿğ‘”<0,
branchselectivityiscalculatedashalfofthedomain.Therefore,the
possiblevaluesreachingtheassertionisreducedtohalf.Next,for
the next conditional statement, ğ‘§â‰ 0, branch selectivity is close to
1.Mostvaluessatisfythisconstraintandconversely,only1value
ofğ‘§satisfiesitsnegation.Theassertionliesontheelsebranchof
this condition, making it reachable only for one value of ğ‘§.
Using the branch selectivity values computed at these branches,
weconvertthecontrolflowgraphoftheprogramtoadiscretetime
Markov chain as shown in Figure 4c. We use a probabilistic model
checker to analyze the Markov chain and obtain a probabilistic
1708ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Seemanta Saha, Mara Downing, Tegan Brennan, and Tevfik Bultan
measureforassertionreachability.Fortherunningexample,this
reachability probability is computed as 0 .5Ã—(2.32ğ‘’âˆ’10). The value
0.5 arises from the branch selectivity for the branch condition
ğ‘ğ‘Ÿğ‘”<0 and 2.32ğ‘’âˆ’10arises from the branch selectivity for the
branchcondition ğ‘§â‰ 0.Thereachabilityprobabilityoftheassertion
statement is then reported as 1 .16ğ‘’âˆ’10, hence this statement would
be classified as a hard to reach statement by our analysis since it
has a low reachability probability.
To assess the success of our analysis for this example, we run a
generatorbasedrandomfuzzerwithatimeoutof1hour.Wefind
that the fuzzer cannot generate an input to reach the assertion.
Thefuzzergenerates 4,103,625inputsandnoneof themreachthe
assertion, which supports the result of our analysis.
Sinceouranalysisdoesnotpreciselyrepresenttheoriginalse-
manticsoftheprogram,wecannotmakesoundnessclaimsabout
theprobabilitycomputedbyourheuristic.Ingeneralcase,ouranal-
ysis may over or under approximate the reachability probability.
Byintegratingabstractinterpretationtechniquestoouranalysis,
we achieve better precision which we will discuss in section 3.2.
Inthefollowingsectionswediscusshowwecomputeanduse
branchselectivityvaluestogetherwithcontrolflow,dependency
analysisandabstractinterpretationtoextractadiscrete-timeMarkov
chain and then use probabilistic model checking to compute ap-
proximations of reachability probability.
3 A PROBABILISTIC REACHABILITY
HEURISTIC
We approximate P(ğ‘,ğ‘¡)using a combination of control flow, de-
pendency analysis, abstract interpretation, model-counting and
probabilisticmodelchecking.First,wediscusshowmodelcounting
constraint solvers and abstract domains can be used to compute
branch selectivity. Then, we use control flow and dependency anal-
ysis and branch selectivity to transform the programâ€™s control flow
graph into a Markov chain. We form queries on this Markov chain
solvable by probabilistic model checking whose solutions approx-
imateP(ğ‘,ğ‘¡).I fP(ğ‘,ğ‘¡)is less than a given threshold ğ‘‡ğ», target
statementispredictedas hardtoreach .Wediscussthesestepsbelow.
3.1 Branch Selectivity
Theenablingtechnologyforcomputingbranchselectivityismodel
counting.Modelcountingistheproblemofdeterminingthenumber
of satisfying solutions to a set of constraints. A model counting
constraintsolverisatoolwhich,givenaconstraintandabound,
returns the number of satisfying solutions to the constraint within
thebound.Forabranchcondition ğ‘,recallthat S(ğ‘)=|ğ‘‡ğ‘|
|ğ·ğ‘|,where
ğ·ğ‘is the Cartesian product of the domains of the variables that
appear in ğ‘andğ‘‡ğ‘is the set of values in ğ·ğ‘for which ğ‘evaluates
totrue.Foragiven ğ‘andğ·ğ‘,amodel-countingconstraintsolver
computes |ğ‘‡ğ‘|. Then, using |ğ‘‡ğ‘|we compute S(ğ‘).
WeusetheAutomata-BasedModelCounter(ABC)tool,whichis
a constraintsolver forstringand numericconstraints withmodel
countingcapabilities[ 2].TheconstraintlanguageforABCsupports
linear arithmetic constraints as well as typical string operations.
In order to compute S(ğ‘)we first extract the branch condition
from the program and then generate a formula in the SMT-LIB1public void test( intx) {
2 if(x >= 0) {
3 inty=- x ;
4 if(y > 0) {
5 assert false;
6}
7}
8}
(a) Using interval analysis1public void test( intx,
2 intz,intr) {
3 inty=3 ;
4 r=x+z ;
5 z=x-y-4 ;
6 if(x < z)
7 assert false;
8}
(b) Using relational analysis
Figure 3: Refined branch selectivity
format that corresponds to the branch condition. Then, we send
the formula to ABC as model counting query.
3.2 Refined Branch Selectivity
Abstractinterpretationtechniquesoverapproximateprogrambe-
haviorsbyinterpretingprogramsoverabstractdomains.Ourkey
insight here is that it is possible to use abstract interpretation to
refineandrestrictthesetofvaluesthatvariablescantakeateach
branch in order to better approximate the branch selectivity. Given
a branchğ‘, using abstract interpretation we generate a refinement
condition ğ‘…ğ‘tooverapproximatethesetofvaluesthatthevariables
can take at that branch. ğ‘…ğ‘is then conjoined with ğ‘‡ğ‘andğ·ğ‘to
compute refined branch selectivity RS(ğ‘). For a branch condition
ğ‘, refined branch selectivity is defined as RS(ğ‘)=|ğ‘‡ğ‘âˆ§ğ‘…ğ‘|
|ğ·ğ‘âˆ§ğ‘…ğ‘|.
To implement the refined branch selectivity, we use state-of-
the-artJavanumericanalysistoolJANA[ 41]whichsupportstwo
differentabstractdomains,intervals[ 21]andpolyhedra[ 37],where
polyhedradomainleadstomorepreciseresultshoweveritisless
scalable.Weexperimentedwithbothofthesedomainstoextractthe
refinementconditions ğ‘…ğ‘foreachbranchusingintervalanalysis
and relational (using polyhedra domain) analysis. We call these
implementations PReach-I and PReach-P, respectively.
Consider the two code snippets from Fig. 3a and 3b. At line 4
in Fig. 3a, ğ‘‡ğ‘andğ·ğ‘areğ‘¦>0 andTruerespectively. S(ğ‘)com-
putedbyPReachis0 .25predictingincorrectlythattheassertion
isreachable.Applyingeitherintervalorrelationalanalysis, ğ‘…ğ‘is
extractedas ğ‘¦<0(atline4,possiblereachablevaluesof ğ‘¥isgreater
than 0 and hence possible reachable values for ğ‘¦is less than 0 due
to the update on variable ğ‘¦at line 3). ğ‘‡ğ‘andğ·ğ‘are updated as
ğ‘¦>0âˆ§ğ‘¦<0 andğ‘¦<0 respectively using ğ‘…ğ‘andRS(ğ‘)com-
puted by PReach is 0 predicting correctly that the assertion is not
reachable. Similarly, at line 6 in Fig. 3b, ğ‘‡ğ‘andğ·ğ‘areğ‘¥<ğ‘§and
Truerespectively. S(ğ‘)is computed as 0 .5 predicting incorrectly
that the assertion is reachable. Applying an interval analysis, there
will be no refinement conditions as it is not possible to catch the
relationbetweenthevariables ğ‘¥andğ‘§usingtheintervaldomain.
But,applyingrelationalanalysisusingthepolyhedradomain, ğ‘…ğ‘
is extracted as ğ‘¥>ğ‘§(possible reachable values of ğ‘§is equal to
ğ‘¥âˆ’7).ğ‘‡ğ‘andğ·ğ‘are then updated as ğ‘¥<ğ‘§âˆ§ğ‘¥>ğ‘§andğ‘¥>ğ‘§
respectively and RS(ğ‘)is computed as 0, correctly predicting that
the assertion is not reachable.
Notethat,forgeneralfunctioninvocationincludingrecursion,
it may be expensive to obtain precise interprocedural analysis,
reducing the effectiveness of refinement.
1709PReach: A Heuristic for Probabilistic Reachability to Identify Hard to Reach Statements ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
DUJ
] 
\ 
(a) Control
flow graphDUJ
] 
\ 
(b) Target state-
ment subgraphDUJ
] 
\ 
 HÃ­
 


(c) Markov chain construc-
tion
Figure4:TargetstatementsubgraphextractionandMarkov
chain construction for the running example
3.3 Target Statement Subgraph Extraction
Thecontrolflowgraphofaprogramisarepresentationofallpaths
thatmaybetraversedduringexecution.Givenaprogram ğ‘,atarget
statement ğ‘¡inğ‘and the input domain ğ¼, we extract the control
flowgraphof ğ‘,G(ğ‘),andmarkthenodeofthecontrolflowgraph
containing the target statement ğ‘¡as the node ğ‘›ğ‘¡.
We expedite our analysis by extracting the target statement sub-
graph,G(ğ‘,ğ‘¡)ofG.G(ğ‘,ğ‘¡)containsallthecontrolflowgraphin-
formationneededtoperformouranalysis.Wedefinethissubgraph
using standard concepts from control flow analysis. We define a
branchnode ğ‘inacontrolflowgraphtobeanynodewithmorethan
oneoutgoingedge.Thecorresponding mergenode ğ‘šofabranch
nodeğ‘is its immediate post-dominator. The component ğ¶defined
byğ‘is the union of branch node ğ‘, its merge node ğ‘šand all nodes
of the control flow graph reachable from ğ‘without going through
ğ‘š. Themaximal component of a node is the largest component
containing that node. Any non-maximal component containing
this node will be contained in this maximal component.
To extract G(ğ‘,ğ‘¡), we first find the maximal component of ğ‘›ğ‘¡.I f
ğ‘›ğ‘¡is not contained in any component, then ğ‘›ğ‘¡must lie on every
path through G(ğ‘). Therefore, it is reached with certainty, P(ğ‘,ğ‘¡)
=1, andouranalysis canbeterminated.Otherwise,the maximal
component of ğ‘›ğ‘¡is themaximal statement subgraph .
G(ğ‘,ğ‘¡)is a subgraph of the maximal statement subgraph. To
obtainG(ğ‘,ğ‘¡),weremoveanycomponentofthemaximalstatement
subgraph that does not contain the statement node ğ‘›ğ‘¡. The branch
andmergenodesofthesecomponentsremaininthesubgraphwith
oneoutgoingedgefromthebranchnodetothemergenode. G(ğ‘,ğ‘¡)
results from this procedure.
Figure 4 shows the process of the target statement subgraph ex-
traction on the running example from Figure 2. Figure 4a gives the
control flow graph G(ğ‘)with the statement node ğ‘›ğ‘¡highlighted
inred.Figure4bshowsthetargetstatementsubgraph G(ğ‘,ğ‘¡)ex-
tracted from G(ğ‘). In this example, the branch corresponding to
ğ‘¦â‰ 0isremovedfromthecontrolflowgraphstructure.Thedeci-
sionmadeatthisbranchdoesnotimpacttheprobabilityofreaching
the target statement node.
Note that the target statement subgraph extraction phase is a
heuristic to s peed up our analysis. The subsequent stages can beperformedontheentirecontrolflowgraphbutthiswouldresultin
unnecessaryworkincludingextramodelcountingquerieswhich
would slow down the analysis.
3.4 Markov Chain Construction
Wedefineaweightforeachedgeof G(ğ‘,ğ‘¡).Theseweightstrans-
formG(ğ‘,ğ‘¡)into a Discrete Time Markov Chain (DTMC), M(ğ‘,ğ‘¡).
A DTMC is a tuple (ğ‘†,Â¯ğ‘ ,ğ‘ƒ,ğ¿)whereğ‘†is a finite set of states, Â¯ğ‘ âˆˆğ‘†
is the initial state, ğ‘ƒ:ğ‘†Ã—ğ‘†â†’[0,1]is the transition probability
matrix where/summationtext.1
ğ‘ /primeâˆˆğ‘†ğ‘ƒ(ğ‘ ,ğ‘ /prime)=1 for allğ‘ âˆˆğ‘†. Each element ğ‘ƒ(ğ‘ ,ğ‘ /prime)
of the transition probability matrix gives the probability of making
a transition from state ğ‘ to stateğ‘ /prime.
We use dependency analysis in the construction of the Markov
Chainaswewanttoidentifythebranchesdependentoninputto
set the weights of the edges accordingly.
DependencyAnalysis. Abranchconditionisinputdependentif
the evaluation of the condition depends on the value of the pro-
graminput.Givenaprogramanditsmarkedinput,weusestatic
dependency analysis to identify the input dependent branches. De-
pendency analysis provides an over approximation of the set of
branchconditionswhoseevaluationdependsontheinputs.Weuse
Janalyzer [ 5], an existing static analysis tool, to perform the depen-
dency analysis. Janalyzer is implemented on top of the WALA [ 40]
program analysis framework.
Then,weconstructtheMarkovchainbyassigningweightsto
eachedge of G(ğ‘,ğ‘¡).G(ğ‘,ğ‘¡)isa directedgraph:each edgebegins
at a source node ğ‘ and ends at a destination node ğ‘‘. Given an edge
ğ‘’:ğ‘ â†’ğ‘‘:Ifğ‘’istheonlyedgebeginningat ğ‘ ,theweightof ğ‘’is1.
Else,ğ‘ isabranchnodebydefinition.Todetermineitsweightwe
useacombinationofdependencyanalysisandbranchselectivity.
Sinceğ‘is a branch node, there is a branch condition associated.
â€¢If the branch condition is independent from the program
input, we weigh edge ğ‘’as follows. Let ğ¸be the number of
edges originating at ğ‘ andğ¸ğ‘¡â‰¤ğ¸be the number of edges
originatingat ğ‘ whichlieonapathtothetargetstatement
nodeğ‘›ğ‘¡.I fğ¸ğ‘¡=0, then the weight of ğ‘’is 1/ğ¸. Otherwise, if
ğ‘’lies on a path to ğ‘›ğ‘¡weight of ğ‘’is 1/ğ¸ğ‘¡.I fğ‘’does not lie on
a path to ğ‘›ğ‘¡, weight of ğ‘’is 0.
â€¢If thebranch condition is dependenton the program input,
we compute the weight of the edge ğ‘’as follows. We use a
model-countingconstraintsolvertodeterminethebranch
selectivity of ğ‘,S(ğ‘).I fğ‘’is the edge corresponding to the if
condition, the weight of ğ‘’isS(ğ‘). Else, 1âˆ’S(ğ‘).
Attheendofthisphase, G(ğ‘,ğ‘¡)hasbeentransformedintoMarkov
chainM(ğ‘,ğ‘¡)wheretheprobabilityoftransitioningfromonestate
to the next is given by the edge weight.
Figure4cshows M(ğ‘,ğ‘¡)fortherunningexample.Thetransition
probabilities are given as edge weights. The two branch conditions
yieldtheonlynon1edgeweightsinthegraph.Bothofthesebranch
conditions are input dependent as determined by the dependency
analysis.Foreachbranchcondition,themodel-countingconstraint
solver ABC was used to find its branch selectivity. This selectivity
wasused tocompute theweightof theedgecorresponding tothe
ifbranchanditscomplementwasusedtocomputetheweightof
the edge corresponding to the else branch.
Note that, the first-order Markov chains do not encode any con-
text sensitivity; thus branch probabilities, e.g., loop conditions,
1710ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Seemanta Saha, Mara Downing, Tegan Brennan, and Tevfik Bultan
would always result in the same selectivity measure regardless
of the call site or iteration number.
3.5 PCTL Query Formulation
Weautomaticallysynthesizequeriesover M(ğ‘,ğ‘¡),whosesolutions
yield an approximation of P(ğ‘,ğ‘¡). The query we synthesize is:
â€¢What is the probability that the target node ğ‘›ğ‘¡is reached at
least once?
The answer to this query approximates P(ğ‘,ğ‘¡). We use a proba-
bilisticmodelcheckerPRISM[ 22],atoolthatanalyzessystemsthat
exhibitprobabilisticbehavior,toanswerthisquery.Wegenerate
adiscretetimeMarkovchain(DTMC)modelbasedonthesyntax
supported by the PRISM tool. We can synthesize queries like what
is the probability of reaching a state in the Markov chain eventually? .
In PRISM, a PCTL formula is interpreted over the DTMC model.
Two types offormulas are supported:state formulas and pathfor-
mulaswherepathformulasoccuronlywhenthereisaprobabilistic
measure that needs to be included in the specification. For our
analysis, the queries we synthesize are path formulas and are of
theform ğ‘ƒâˆ¼ğ‘[ğœ™]whichistheprobabilistic analogueofthepath
quantifiers of CTL. For example, the PCTL formula P=?[F ğœ™] states
what is the probability of reaching state ğœ™.
The complexity of PCTL query verification for DTMC is polyno-
mial in the number of states [ 23]. Since the number of states of the
DTMC is linear in the size of the program, overall complexity of
PCTL query verification is polynomial of program size.
Loop Analysis. In analyzing programs which contain back edges
(either from loops or from recursion), we consider two different
queries for programs with loops.
â€¢Whatistheprobabilitythattargetnode ğ‘›ğ‘¡isreachedatleast
once within a given loop bound?
â€¢Whatistheprobabilitythattargetnode ğ‘›ğ‘¡isreachedatleast
once?
Thefirstqueryenablesustomodelboundedloopexecutions.To
answer this query, we fix a loop bound and unroll any loops in the
Markovchain.Ifthetargetnode ğ‘›ğ‘¡isduplicatedduringthisloop
unrolling process, then the query becomes
â€¢What is the probability that any target node ğ‘›ğ‘¡is reached at
least once?
OncetheloopsintheMarkovChainareunrolled,thefirstquery
becomestheinitialqueryontheunrolledMarkovchainexceptthat
there might be multiple instances of the target node.
In answering the second query, we leave the Markov chain as is
includinganybackedgesandgeneratetheDTMCmodelforPRISM
as it is. PRISM calculates a steady state probability for unbounded
loop scenario. Bounding the loop and asking the bounded version
of the reachability query under approximates the unbounded case.
As the loop bound increases, the solution for the bounded case ap-
proachesthatoftheunboundedcaseandinsomecasesitispossible
toreachthesteadystateprobability,i.e.,toreachafixpoint.Note
that, in PRISM, we are able to compute the steady state probabil-
ity, so it is not necessary to compute the fixpoint by increasing
loop bounds. This is one of the advantages of our approach over
probabilistic symbolic execution.4 IMPLEMENTATION
We have implemented our technique in a tool called PReach (Prob-
abilistic Reachability Analyzer) targeting programs written in Java
programming language.
Using the static analysis tool Janalyzer [ 5] we first extract the
control flow graph from the given program. After marking inputs
for which we want to calculate reachability probability, we use
dependencyanalysisforthemarkedinputsandidentifyallinput-
dependent branches. We identify the target statement node and
dodominatorandpost-dominatoranalysisinordertoextractthe
target statement subgraph.
Forcalculatingbranchselectivityofinput-dependentbranches
we first translate the branch conditions to SMT-LIB format con-
straintsusingSpoon[ 31]andthenweuseABC[ 2]formodelcount-
ing. To compute refined branch selectivity we applied two abstract
domains, interval and polyhedra using Jana [ 41], a numeric analy-
sis tool for Java. We call these implementations as PReach-I and
PReach-Prespectively.Wedefinethedomainsizeforintegersas
signed 31 bit, for strings as length of 16 with all printable ASCII
characters, for char as unsigned 8 bit integers. Once we get the
model count from ABC, we calculate the branch selectivity. To
compute bounded reachability of a target statement, we look for
back-edgesandifthereisone,weunrollthelooptoacertainbound.
For unbounded cases, we compute the steady state probability.
Once we have all the branch selectivity values, we construct
the discrete time Markov chain (DTMC). Using the target state-
mentnode,weformulatethequeriestocalculatethereachability
probability. We use the probabilistic model checker PRISM [ 22] for
computingthetargetstatementreachabilityprobability.Weconvert
theMarkovchaintoaDTMCmodelinPRISMsyntaxandsynthe-
sizequeries.Then,weexecutePRISMtocomputetheprobability.
We use PRISM as it provides features to reduce the reachability
checking of a statement in a program with unbounded loops to
reachabilitycheckingofastateinDTMC.Ourcurrentimplementa-
tion determines reachability probability for each target statement
separately.Wecanextendourapproachtohandlereachabilityof
multiple statements by synthesizing slightly more complex queries.
Forcollectinggroundtruthvaluesof hardtoreach statements,
weruna generatorbasedrandomfuzzerforalltheprograms.We
useJQF[28]toolwhichisafeedbackdirectedfuzztestingplatform
for Java. JQFincorporates coverage-guidedfuzz testingtechnique
ZEST[29].Weusegenerator-basedrandomfuzzingoptionprovided
by ZEST. We set a timeout of one hour and if the fuzzer fails to
generateinputstoreachthetargetstatement,wedeterminethat
the target statement is hard to reach .
Note that, the PReach approach can be extended to support
alternativeconcretetestingtechniquesandthedefinitionof hard
to reachstatements can be adapted accordingly. For example, for a
randomtestingtoollikeRandoop[ 27](usedinthehybridtesting
tool JDoop [ 16]), the definition of hard to reach can be changed
by considering an input distribution that is different from uniform
distribution, by using different usage profiles [18].
5 EXPERIMENTAL EVALUATION
To evaluate PReach, we experimented on benchmark programs
from the Competition on Software Verification (SV-COMP) [ 8] and
1711PReach: A Heuristic for Probabilistic Reachability to Identify Hard to Reach Statements ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
theCompetitiononSoftwareTesting(Test-Comp)[ 9],whichwe
calltheSV-COMPbenchmark.Sofar,Test-Comphaveonlyused
C programs from the SV-COMP benchmark. Among the bench-
marksusedforJavainSV-COMP2021,Weuse4modules(jayhorn-
recursive,jbmc-regression,jpf-regression,algorithms)forevalua-
tion. We mark all the non-deterministic inputs in the SV-COMP
benchmarksasinputsforreachabilityanalysis.Weusetheassert
statements in these programs as target statements. We use two
criteriatoselecttheprogramsfromthesedirectoriesforourexperi-
ments.Weexcludeprogramsifoneofthefollowingtwoconditions
hold:
(1)Targetstatementreachabilitydoesnotdependontheinputs:
PReach is not applicable for these programs as it assesses
reachability probability with respect to inputs.
(2)Verification tasks are specific to floating point arithmetic:
The model-counting constraintsolver we use does notsup-
port constraints generated from such programs.
Basedontheabovecriteria,ourfinaldatasetconsistsofatotal
of142programs.Wemodifytheseprogramsinordertoallowus
to run both our analysis and the generator based random fuzzer
whilekeeping theprogram semanticsunchanged. Thesemodified
programs are available at [35].
We run experiments on a virtual box equipped with an Intel
Corei7-8750HCPUat2.20GHzand16GBofRAMrunningUbuntu
Linux18.04.3LTSandtheJava8PlatformStandardEdition,version
1.8.0_232, from OpenJDK 64-Bit Server VM.
5.1 Results for the SV-COMP benchmark
Reachability probability computed by PReach is a value between 0
and 1. In order to assess how good PReach is to identify hard to
reachstatements, we classify program statements to two groups:
hard to reach andeasy to reach . As ground truth, we classify the
programsforwhichtherandomfuzzerisunabletoreachthetarget
statement within the given time bound as hard to reach . We list
the number of true positives (TP: ground truth is hard to reach and
PReach predicts hard to reach ); false positives (FP: ground truth is
easytoreach andPReachpredicts hardtoreach );truenegatives(TN:
ground truth is easy to reach and PReach predicts easy to reach );
false negatives (FN: ground truth is hard to reach and PReach
predictseasy to reach ). Ahard to reach threshold ( ğ‘‡ğ») value 0.05
meansstatementshavingreachabilityprobabilitylessthan0.05are
classified as hard to reach . Then, we evaluate PReach with respect
to the ground truth.
Table1showstheoverallprecision,recallandaccuracyresults
of PReach-P.Precision,recallandaccuracyfordifferentimplemen-
tations of PReach is shown in Table 4. We demonstrate results for
multiplevaluesof ğ‘‡ğ»toanalyzechangesinprecision,recallandac-
curacy across the benchmarks. Reducing ğ‘‡ğ»from 0.05 to 0.01 does
notchangetheresultsatall.Increasing ğ‘‡ğ»to0.1leadstointeresting
changes in the results: some of the true negative cases are updated
tofalsepositives,reducingprecisionandaccuracy.Increasing ğ‘‡ğ»
to 0.25 changes the results further: the number of false positive
casesareincreasedandnumberoftruenegativecasesaredecreased.
Increasing the value of ğ‘‡ğ»changes the prediction of more cases
fromeasy to reach tohard to reach and hence, the overall precision
is reduced from 95.8% to 79.3% and the overall accuracy is reducedfrom 95.1% to 88.0%. The ability of using different threshold values
demonstrates the quantitative nature of our analysis rather than
being a fixed binary classification.
Accuracyof PReach-Psetting ğ‘‡ğ»as0.05or0.01is95.1%.Across
allthebenchmarks,accuracyisgreaterthanorequalto87.0%,re-
flectingtheeffectivenessofourheuristic.PReach-Pfailstoidentify
5o ft h ehard to reach program statements having a recall of 90.2%,
butitisverypreciseinidentifying hardtoreach programstatements
with a precision of 95.8%.
Among 142 cases, only 2 cases are false positives and 5 cases
arefalsenegatives.Theremaining135casesarecorrectlyclassified
byPReach.Thereasonsbehindthe2falsepositivecasesandthe
5 false negative cases are: 1) most of the input values generated
by the fuzzer lead to exceptions and the fuzzer cannot generate
enough valid inputs, 2) the numeric analysis tool cannot handle
complexoperationssuchasmultiplication,divisionandmodulus
between more than one variables using the abstract domains.
Experimental results show that among the 3 variations of the
tools, PReach-P performs the best with a precision, recall and
accuracy of 95.8%, 90.2% and 95.1% respectively. Without applying
refinedbranchselectivity,PReachcannotcatchtwoscenarios:1)
two dependent branch conditions cancel out each other, 2) input
values are updated in a way that the branch condition becomes
alwaystrueorfalse.Hence,thenumberoffalsenegativesincreases
from5to13.PReach-Iusesintervaldomainforrefinementanalysis
which is not as precise as PReach-P using a plyhedra domain. As a
result, 2 extra false negatives are introduced by PReach-I.
5.2 Probabilistic Symbolic Execution (PSE)
Weprovideanexperimentalcomparisonof PReachwithprobabilis-
tic symbolic execution (PSE) [ 20]. We use SPF [ 30] as the symbolic
execution engine for PSE. PSE is unable to analyze some of the
target programs due to unsupported constraints such as non-linear
path constraints, PReach does not face this issue as much since
itonlyconsidersbranchconditions.Therestoftheprogramsare
markedasanalyzablebyPSE,asshowninTable2.Forprograms
wherethenumberofrecursivecallsorloopiterationsdependon
theinput,PSEcannotexploreallpossiblepathssinceitcanonly
searchprogramsbehaviorsuptoaboundedexecutiondepth(search
depth), and since the number of program paths grows exponen-
tially.Therefore,wesetatimeoutof1hourforPSEandevaluate
fordifferentsearchdepths.SincePSEisunabletocoverallprogram
paths,theprobabilisticmeasurementcomputedbyPSEisnotexact.
Increasing the search depth allows PSE to obtain more accurate re-
sultsbutalsoincreasesthenumberofprogrampathsexponentially.
This leads PSE to time out for some programs, as shown in Ta-
ble2.Thisisnotthecaseforthejpf-regressionandjbmc-regression
benchmarks,asthereisnoinputdependentrecursivecallsorloops.
We show the comparison of reachability probabilities computed
by PReach and PSE in Table 3. As we do not have any ground
truth for the probability measurement, we calculate probability
differences between these two techniques and analyze the differ-
ences in case of agreement and disagreement for hard to reach
statementassessment.PReachandPSEagreeiftheirpredictions
match, disagree otherwise. Based on agreement and disagreement,
wedivideallthecasesinto3groups:1)agreement,2)disagreement
1712ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Seemanta Saha, Mara Downing, Tegan Brennan, and Tevfik Bultan
Table 1: Effectiveness of PReach-P in terms of precision, recall and accuracy scores for sv-comp benchmarks
BenchmarksThreshold ( ğ‘‡ğ»)
0.25 0.1 0.05/0.01
TP FP TN FN Precision Recall Accuray TP FP TN FN Precision Recall Accuracy TP FP TN FN Precision Recall Accuracy
jayhorn-recursive 9 1 10 3 90.0 75.0 82.6 9 0 11 3 100.0 75.0 87.0 9 0 11 3 100.0 75.0 87.0
jpf-regression 25 7 43 2 78.1 92.6 88.3 25 2 48 2 92.6 92.6 94.8 25 2 48 2 92.6 92.6 94.8
jbmc-regression 8 1 12 0 88.8 100.0 100.0 8 0 13 0 100.0 100.0 100.0 8 0 13 0 100.0 100.0 100.0
algorithms 4 3 14 0 57.1 100.0 85.7 4 3 14 0 57.1 100.0 85.7 4 0 17 0 100.0 100.0 100.0
Total 46 12 79 5 79.3 90.2 88.0 46 5 86 5 90.2 90.2 93.0 46 2 89 5 95.8 90.2 95.1
Table2:NumberofprogramsanalyzedbyPReachandProb-
abilistic Symbolic Execution within 1 hour timeout
BenchmarksNumber of programs analyzed
PReachProbabilistic Symbolic Execution
Analy-
zableAnalyzable with Search Depth
10 20 30 100 500 1000 âˆ
jayhorn-recursive 23 2121 17 11 6 5 1 1
jpf-regression 77 6969 69 69 69 69 69 69
jbmc-regression 21 1616 16 16 16 16 16 16
algorithms 21 999998 6 2
Total 142 115115 111 105 100 98 92 88
Table 3: Probabilistic measurement differences and hard to
reachstatementpredictiondisagreementsbetweenPReach
(PR) and PSE
Bench-
marksSearch
Depth#Cases
Analy-
zableToolAgreement Disgreement All
Cases
Average
Diff.PSE/checkPReach /check
#Avg.
Diff.#Avg.
Diff.#Avg.
Diff.
jayhorn-
recursive10 21PR16 0.086 2 1.000 3 0.420 0.270
PR-I16 0.086 2 1.000 3 0.420 0.270
PR-P16 0.086 2 1.000 3 0.420 0.270
jpf-
regressionâˆ 69PR58 0.050 10 0.550 1 0.250 0.083
PR-I62 0.049 6 0.542 1 0.250 0.095
PR-P64 0.035 4 0.625 1 0.250 0.072
jbmc-
regressionâˆ 16PR14 0.040 2 0.250 0- 0.066
PR-I16 0.031 0- 0- 0.031
PR-P16 0.031 0- 0- 0.031
algorithms 100 9PR3 0.087 0- 6 0.390 0.317
PR-I3 0.087 0- 6 0.390 0.317
PR-P 3 0.087 0- 6 0.390 0.317
and PSE is correct, 3) disagreement and PReach is correct. The
average difference in probability is low for the cases of agreement.
Thedifferenceisevenlowerforjpf-regressionandjbmc-regression
benchmarks as PSE achieves very high precision and accuracy (see
Table 5) and PReach agrees with the predictions. For the cases
ofdisagreement,thedifferenceisveryhighformostofthecases
whenPSEpredictscorrectlybutPReachdoesnot.Oneofthemain
reasons for this is variable updates making some of the program
pathsinfeasible.PSEcancatchtheinfeasiblepathswhereasPReach
givesanapproximateresultforthesecasesusingbranchselectivity.
Both PReach-I and PReach-P can address this issue. Using refined
branch selectivity, the number of agreement cases are increased
and average probability difference is reduced for jpf-regression
andjbmc-regressionbenchmarks.AnotherreasonisPReachpre-
dicting aprogram statement as easy toreach but theground truth
ishard to reach as fuzzer cannot reach the target statement due
torecursionstackoverflowerror.Averagedifferenceisalsohigh
forjayhorn-recursiveandalgorithmsbenchmarkswhenPReachpredictscorrectlybutPSEdoesnot,asthereisanexponentialin-
crease in the number of paths and PSE poorly approximates the
probability.
We now compare these two techniques in terms of hard to reach
statementprediction accuracyandprecision.To compare PReach
andPSE,weset the hardto reach thresholdto0.05. Table4shows
precision, recall and accuracy for PReach and PSE with search
depth 10 and 1000. We evaluate all 142 programs analyzable by
PReach. The programs for which PSE times out are marked as
easy to reach as our target is to identify the hard to reach program
statements.Differentsearchdepthsdonotchangeresultsforjpf-
regression and jbmc-regression benchmarks as these programs are
freeofrecursivecallsandloopsthatdependoninputs.Thepreci-
sion and accuracy values for PReach are comparable to PSE for
these benchmarks. The prediction results are improved a lot using
PReach-IandPReach-P.Forjpf-regressionandjbmc-regression
benchmarks,precision,recallandaccuracyareincreased.Forjbmc-
regression benchmarks, both PReach-I and PReach-P performs
betterthanPSEandforjpf-regressionbenchmarks,overallscores
achieved by PReach-P are better than PReach-I and very close
to the scores achieved by PSE. For jayhorn-recursive and algo-
rithmsbenchmarks,PSEcannotachieveasgoodresultsasPReach,
PReach-I or PReach-P since these programs need to deal with
inputdependent recursivecallsand loops.Forlower searchdepth
(10), PSE can not explore all the program paths and as a result
thecomputedprobabilityisanunder-approximation(worsethan
a heuristics-based approach used in PReach). For higher search
depth (1000), most of the programs time out and hence are marked
aseasytoreach .Asaresulttherearenotrue-positivecasesmaking
precisionandrecallvalues0aswellasnofalse-positivecaseskeep-
ingthetotalprecisionhigh(96.9).Forthealgorithmsbenchmark,
even with search depth 10, the precision and recall is 0 as PSE can
notsupportmostoftheprograms(markedas easytoreach )asar-
raysizeisinputdependentand marked assymbolic,whichisnot
analyzableby SPF.Though forprogramswith boundedexecution
depth due to the absence of loop and recursion (jpf-regression and
jbmc-regressionbenchmarks),PSEperformsbetterthanPReach
but PReach-P is as good as or even better in some cases than PSE.
Weshowprecisionandaccuracyforthe85programsinthesetwo
benchmarksthatareanalyzablebyPSEinTable5.Thescoresfor
PSE are not 100% due to situations like integer arithmetic overflow
thatarenotcaughtbysymbolicexecution.Theprecision(95.7)and
accuracy (87.1) for PReach is comparable to PSE and is impressive
giventhatitisascalableheuristicapproach.Theprecision(96.8)
andaccuracy(96.5)byPReach-Pisveryclosetothescoresachieved
by PSE. Moreover, PSE performs very poorly on programs with
unbounded execution depth (jayhorn-recursive and algorithms
1713PReach: A Heuristic for Probabilistic Reachability to Identify Hard to Reach Statements ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
benchmarks) whereas PReach, PReach-I and PReach-P have high
precision and accuracy.
Table6showstheaverageanalysistimerequiredandpercentage
ofcasesanalyzedbybothofthesetechniques.Evenforalowsearch
depth (10) the analysis time of PSE is higher than PReach. Note
that,lowersearchdepthsinPSEpoorlyapproximatetheprobability.
However,increasingthesearchdepthincreasestheanalysistime
byordersofmagnitude.Forbothjayhorn-recursiveandalgorithms
benchmarks, the average analysis time increases and percentage
of analyzed cases within the time bound decreases as the search
depth is increased. For the jayhorn-recursive benchmark, even
for a search depth of 30 the average analysis time increases by
an order of magnitude. This is because the number of recursive
functioncallsareinputdependent.Theaverageanalysistimeshown
in the table is less than or equal to 3600 seconds since we set
thetimeoutto1hour(i.e.,3600secondsisthemaximumanalysis
time). The time for jayhorn-recursive benchmarks with search
depth greater than or equal to 30 would be very high without this
timeout. Average analysis time also increases for the algorithms
benchmarks when the search depth is increased as number of loop
iterations depend on the inputs. These results show that PSE is not
scalable for unbounded execution depth whereas PReach is.
PReach-IandPReach-Prequiremoreanalysistimecompared
to PSE for jpf-regression and jbmc-regression benchmarks. As pro-
gramsinthesebenchmarksareloopandrecursionfree, PSEruns
fast whereas PReach-I and PReach-P perform abstract interpre-
tation for branch selectivity refinement. H owever, as the search
depth of the programs increases, the branch selectivity refinement
analysis time becomes less significant compared to the exponential
time increase due to path constraint solving performed by PSE,
reflected in the jayhorn-recursive and algorithms benchmarks. For
thesebenchmarks,asthesearchdepthincreasesto100,theanalysis
timebyPSEisordersofmagnitudehigherthantheanalysistime
requiredbyPReach-IorPReach-P.Theseresultsclearlyindicate
thatPReach,PReach-IandPReach-Pmaintainabalancedtradeoff
betweenprecisionandscalabilityforprobabilisticreachabilityanal-
ysis and amongthese three implementations, PReach-P performs
the best considering its high precision and accuracy.
5.3 Statistical Symbolic Execution (SSE)
Inthissection,weprovideanexperimentalcomparisonof PReach-
P with statistical symbolic execution (SSE). Prior work has demon-
stratedthatSSEismorepreciseandfasterthanPSEwhenlargeexe-
cutionboundsarenecessary,preventingPSEfromterminating[ 18].
SSE uses SPF [ 30] as the symbolic execution engine similar to PSE.
We compare PReach-P and SSE only for the jayhorn-recursive
and algorithmsbenchmarks fromSV-COMP,as PSE achievesvery
highprecisionandaccuracyforjpf-regressionandjbmc-regression
benchmarks, and we have already compared the performance of
PReach-P and PSE on those benchmarks.
SSE is unable to analyze 12 out of 44 target programs due to
inabilitytohandlenon-linearpathconstraintsorsymbolicarray
indexing during symbolic execution. As before, we set a timeout of
1hourforSSEandevaluatefordifferentsearchdepths.LikePSE,
SSE is also unable to explore all program paths within an hour, but
it can provide statistical guarantees for the computed probabilitieswith respect to accuracy ( ğœ–) and confidence ( ğ›¿) parameters [ 18].
SSE has two different sampling approaches: 1) Monte Carlo and
2) Informed sampling. We compare PReach-P to both of these
sampling techniques in SSE. In both cases, we set ğœ–to be 10âˆ’5and
targetğ›¿to be 0.99 following the experimental setup in [ 18]. For
Monte Carlo sampling, we set the maximum sample size ( ğ‘1)a s
100,000andforinformedsampling,weset ğ‘1as100andmaximum
number of iterations as 100.
Precision, recall and accuracy for SSE is presented in Table 7.
SSE has better precision, recall and accuracy compared to PSE but
notcomparedtoPReach-P.RecallandaccuracyforSSEdropswith
increasing search depth. For algorithms, precision and recall is 0 .0
(markedwitha*),astherewerenotruepositivecasesamongthe
analyzable programs by SSE. Similar to the experimental setup for
the comparison to PSE, we mark a program statement as easy to
reachif it times out.
We do not take the reported statistical confidence into account
to determine which program statements should be marked as hard
toreachoreasytoreach bySSE.Onecoulduseathresholdvaluefor
thestatisticalconfidence,andacceptonlythepredictionsachiev-
ing a certain confidence. In that case, the precision and accuracy
of SSE would drop further. Instead, we present average confi-
dence achieved by SSE in Table 8 separately. Statistical confidence
achievedby SSE drops asthe search depthfor symbolicexecution
is increased and more programs time out. Even though we set a
large maximum number of samples (100,000) for Monte Carlo sam-
pling, SSE can not achieve a high confidence. On the other hand,
informedsamplingcanachievehighconfidencewithsearchdepths
10or100forsomecases.But,withaninfinitesearchdepth,none
of the sampling techniques can achieve high confidence.
AverageanalysistimeforSSEispresentedinTable8.Ingeneral,
PReach-P is orders of magnitude faster than SSE. Monte Carlo
samplingisconsistentlyslowerforalltheprogramscomparedto
PReach-P.InformedsamplingperformsmuchbetterthanMonte
Carlo sampling. Analysis time of SSE with informed sampling is
closetoPReach-Pforsomeprogramswhenashortsearchdepth
value is used. But, irrespective of search depth, for a good number
ofprograms,informedsamplingisalsoordersofmagnitudeslower
than PReach-P, and hence its average analysis time is significantly
higher than PReach.
These results demonstrate that PReach-P is more scalable com-
pared to SSE and achieves better precision and accuracy, especially
for programs containing large number of paths.
5.4 Case Studies
Inthissection,weevaluatetheeffectivenessof PReachtodetect
hard to reach program statements in larger projects. We are par-
ticularly interested in program points where inputs need to pass
through numerous branches to reach. We selected a set of methods
fromApacheCommonsLang[ 1]andDARPASTACBenchmarks[ 4]
and identified target program statements. We have analyzed 24
programstatementsin12methodsfromApacheCommonsLang
projectand12programstatementsfrom6methodsacross5projects
from DARPA STAC Benchmarks.
Table 9 shows PReach results for the selected 24 cases. First,
werun PSEtocompute reachabilityprobabilityonall thesecases.
1714ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Seemanta Saha, Mara Downing, Tegan Brennan, and Tevfik Bultan
Table4:Precision,RecallandAccuracyof PReach(PR)andPSE,computedfor142programs,programismarked easy to reach
if analysis times out
Bench-
marksPrecision Recall Accuracy
PR PR-I PR-PPSE with
Search
Depth PR PR-I PR-PPSE with
Search
Depth PR PR-I PR-PPSE with
Search
Depth
10 1000 10 1000 10 1000
jayhorn-recursive 100.0 100.0 100.0 76.9 *0.0 75.0 75.0 75.0 83.3 *0.0 87.0 87.0 87.0 78.3 47.8
jpf-regression 90.5 92.0 92.6 96.2 96.2 70.4 85.2 92.6 96.2 96.2 87.0 92.2 94.8 97.4 97.4
jbmc-regression 100.0 100.0 100.0 100.0 100.0 75.0 100.0 100.0 75.0 75.0 90.5 100.0 100.0 90.5 90.5
algorithms 100.0 100.0 100.0 *0.0 *0.0 100.0 100.0 100.0 *0.0 *0.0 100.0 100.0 100.0 52.4 61.9
Total 95.0 95.7 95.8 80.4 96.9 74.5 86.3 90.2 82.0 62.0 89.4 93.7 95.1 79.6 85.9
Table 5: Precision, Recall and Accuracy of PSE and PReach
(PR),outof85programscomputedwithin1hourforjpf-and
jbmc-regression benchmarks
Bench-
marksPrecision Recall Accuracy
PR PR-I PR-P PSE PR PR-I PR-P PSE PR PR-I PR-P PSE
jpf-regression 94.7 95.7 96.0 96.2 69.2 84.6 92.3 100.0 87.0 92.8 95.7 98.6
jbmc-regression 100.0 100.0 100.0 100.0 66.7 100.0 100.0 100.0 87.5 100.0 100.0 100.0
Total 95.7 96.6 96.8 96.9 68.8 87.5 93.8 100.0 87.1 94.1 96.5 98.8
Table 6: Average Analysis Time for PReach (PR) and PSE,
maximum average analysis time is limited to 3600 seconds,
cases with timeout are included
Bench-
marksAverage Analysis time in seconds (% Cases Analyzed in 1 hour)
PRPR-IPR-PProbabilistic Symbolic Execution
Search Depth
10 30 100 1000
jayhorn-
recusrive2.434.356.165.34 (91%) 2048.33 (52%) 2583.22 (29%) 3428.67 ( 5%)
jpf-
regression0.813.114.861.51 (91%) 1.51 (91%) 1.5 (91%) 1.51 (91%)
jbmc-
regression0.694.906.103.32 (76%) 3.32 (76%) 3.32 (76%) 3.32 (76%)
algorithms 0.996.389.692.25 (43%) 3.98 (43%) 79.76 (43%) 2399.94 (29%)
Total 1.084.085.972.51 (82%) 372.50 (75%) 475.21 (71%) 808.28 (65%)
Among 18 methods we analyze we find that PSE is not able to
handle 9 methods due to either variable type conversion or lack
ofsupportforsomeStringlibraryfunctions. PSEfailson2other
methods due to incapability to model count for non-linear path
constraints and another 4 methods due to lack of support for trans-
lationofexpressionstostringpathconstraints.PReachdoesnot
haveanyoftheseissuesastheunderlyingtechniqueissimplerthan
symbolically executing a program, and it can avoid dealing with
non-linear path constraints and complex string path constraints as
it needs to consider individual branch conditions only. Finally, PSE
successfully runs on 3 methods but for 2 of the methods it times
out, predicting only 1 case correctly as hard to reach . These results
demonstrate the limitations and poor scalability of probabilistic
symbolic execution on realistic programs. We also cannot analyze
these cases using PReach-I and PReach-P as the programs per-
form string operations and the abstract interpretation tool [ 41]w e
use for computing refined branch selectivity is limited to numeric
analysis.Evenwithoutrefiningthebranchselectivity,ourresults
for these case studies demonstrate that even the base technique
(PReach)usingbranchselectivityiscapableofpredicting hardto
reachprogram statements efficiently for sizable programs.PReachcanpredict19outof24casescorrectlywithanaccuracy
of79.2%setting ğ‘‡ğ»as0.001.Weusedthesamevalueof ğ‘‡ğ»acrossall
domains.Differentvaluesof ğ‘‡ğ»forInteger/mixeddomain(0.01)and
String domain (0.001) increases the accuracy to 83.33% supporting
the quantitative nature of our analysis. 5 of the cases that PReach
can not predict correctly is due to the similar reasons as SV-COMP
benchmarks. The value of the input is updated inside the program
and as a result the following branches do not depend on the initial
input value anymore.
6 RELATED WORK
Therehasbeenanincreasingamountofresearchonquantitative
programanalysistechniquesbasedonmodelcountingconstraint
solvers,andtherehasbeenasurgeofprogressinmodelcounting
constraint solvers [ 2,11,13,14,24,25]. Model counting constraint
solvers have been used in a variety of quantitative program analy-
sistaskssuchasprobabilisticanalysis[ 10,18,20],reliabilityanal-
ysis [17], estimating performance distribution [ 15], quantitative
information flow [ 3,6,19,33,34], and side-channel attack syn-
thesis[7,32,36].Branchselectivityandprobabilisticreachability
heuristic we introduce in this paper are fundamental quantitative
program analysis techniques and rely on the recent developments
in model counting constraint solvers.
Probabilistic symbolic execution [ 20] and statistical symbolic
execution [ 18] can be used for probabilistic reachability analysis
problem we study in this paper . However pr obabilistic symbolic
executionsuffersfrompathexplosion[ 12]andincreasingsizeof
pathconstraintswithincreasingexecutiondepth,whichcanleadto
double exponential blow up. Moreover, probabilistic symbolic exe-
cution can only analyze program behaviors up to a fixed execution
depth. Statistical symbolic execution is more efficient compared
to probabilistic symbolic execution but still suffers with increas-
ing executiondepth. The approach wepresent in thispaper using
branch selectivity addresses these issues since it does not suffer
frompathexplosionanditanalyzesbranchconditionsinsteadof
path constraints modeling behaviors of arbitrarily long paths.
Hybridtestingtechniques[ 16,26,38,39,42]combineconcrete
andsymbolictechniquesinordertoimproveeffectivenessoftest-
ing. Strategy function for hybrid testing need to decide when to
apply concrete techniques and when to apply symbolic. Existing
techniquesassessthedifficultyofconcretetestingtodomakethe
decisionbasedonthesaturationofrandomtesting[ 26,38]orusing
apredefinedconfigurationoftimetorunforconcreteandsymbolic
techniques [ 16] or probabilistic program analysis [ 39,42]. Markov
decision process construction extracting control flow graph and
1715PReach: A Heuristic for Probabilistic Reachability to Identify Hard to Reach Statements ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
Table 7: Precision, Recall and Accuracy of PReach-P (PR-P) and SSE, computed for 44 programs from jayhorn-recursive and
algorithms benchmarks, program is marked easy to reach if analysis times out(1 hour), both Monte Carlo and informed sam-
pling has same precision, recall and accuracy
BenchmarksPrecision Recall Accuracy
PR-PSSE with
Search DepthPR-PSSE with
Search DepthPR-PSSE with
Search Depth
10 100 âˆ 10 100 âˆ 10 100 âˆ
jayhorn-recursive 100.0 100.0 100.0 100.0 75.0 75.0 75.0 58.3 87.0 87.0 87.0 78.3
algorithms 100.0 0.0* 0.0* 0.0* 100.0 0.0* 0.0* 0.0* 100.0 71.4 71.4 71.4
Total 100.0 100.0 100.0 100.0 83.3 50.0 50.0 38.9 93.2 79.5 79.5 75.0
Table8:AverageAnalysisTimeandstatisticalConfidence( ğ›¿)forPReach-P(PR-P)andSSEMonteCarlo(MCS)andinformed
(IS)sampling,maximumaverageanalysistimeislimitedto3600seconds,caseswithtimeoutareincluded,confidenceissetto
0.0 for timeout cases
Bench-
marksAverage Analysis Time Statistical Confidence ( ğ›¿)
PR-PSSE-MCS with
Search DepthSSE-IS with
Search DepthSSE-MCS with
Search DepthSSE-IS with
Search Depth
10 100 âˆ 10 100 âˆ 10 100 âˆ 10 100 âˆ
jayhorn-recursive 6.161495.60 2117.46 2530.45 165.71 362.36 2038.48 0.061 0.039 0.032 0.957 0.913 0.435
algorithms 9.692558.30 3066.67 3071.77 2004.41 2008.00 2802.04 0.016 0.016 0.016 0.444 0.444 0.222
Total 7.842002.91 2577.38 2786.37 1046.43 1150.83 2406.93 0.040 0.028 0.025 0.712 0.690 0.333
Table 9: Case study of PReach on Apache Commons Lang and DARPA STAC Benchmarks. PReach predicts a statement as
hard to reach if reachability probability is less than 0.001. 19 out of 24 cases are predicted correctly
Project Class Name Method NameTarget
Statement
Line
NumberNumber
of Branches
in MethodMax
#Branches
to Target
StatementReachability
ProbabilityRandom
Fuzzer
Ground
TruthPReach
PredictionPrediction
Match
apache-commons-langFraction greatestCommonDivisor 595 11 7 0.00% Yes Yes 
NumberUtilscreateNumber 759 31 25 0.00% No Yes 
isCreatable 1690 25 23 0.33% No No 
FastDatePrinter parseToken 363 7 7 7.32% No No 
StrTokenizer readWithQuotes 804 8 8 0.00% Yes Yes 
StrSubstitutor substitute 837 17 13 0.00% Yes Yes 
NumericEntityUnescaper translate 107 9 4 0.08% No Yes 
ArrayUtils shift 6994 9 9 0.00% No Yes 
BooleanUtils toBooleanObject 650 15 15 0.00% Yes Yes 
RandomStringUtils random 427 16 16 0.00% Yes Yes 
StringUtils containsAny 1248 8 7 0.00% Yes Yes 
CharSequenceUtils regionMatches 377 7 7 0.00% Yes Yes 
calculator_3 RomanNumeralFormatter parseObject130
3417 0.15% No No 
152 11 49.44% No No 
170 34 0.59% Yes No 
calculator_4Arithmetizer assessParentheses21394 0.19% No No 
245 9 93.75% No No 
ImperialFormatter parseObject70
114 1.37% No No 
96 9 24.63% No No 
103 11 13.99% No No 
emu6502 Assembler assembleLine214229 0.00% No Yes 
207 8 0.15% No No 
linear_algebra_platform MatrixSerializer readMatrixFromCSV 51 13 9 7.30% No No 
rsa_commander DecInputStream read 99 19 12 0.08% Yes Yes 
putting probabilities as edge weight has been used to find optimal
strategyforconcolictesting[ 39].Probabilisticpathprioritization
is used in [ 42] to decide when to invoke symbolic execution in
hybrid fuzzing. Our approach focuses on identifying hard to reach
statements based on probabilistic reachability heuristic.
7 CONCLUSIONS
Wepresentedanovelheuristicforprobabilisticreachabilityanalysis
to identify hard to reach program statements that uses dependency
analysis, model counting, abstract interpretation, and probabilis-
ticmodelcheckingtocomputeprobabilityofreachingaprogram
statementgivenrandominputs.Weexperimentallyevaluatedour
approachonasetofbenchmarkprogramsanddemonstratedthat
our approach can identify statements that are hard to reach withreasonableprecisionandaccuracy.Weprovideddetailedcompari-
sonofourapproachagainstprobabilisticsymbolicexecutionand
statistical symbolic execution, demonstrating that our approach is
more efficient and scalable.
ACKNOWLEDGEMENT
We would like to thank all the reviewers for their useful technical
commentsandinsightfulsuggestionstowardsimprovingthispaper.
REFERENCES
[1]ApacheCommonsLang.2020. https://commons.apache.org/proper/commons-
lang/.
[2]Abdulbaki Aydin, Lucas Bang, and Tevfik Bultan. 2015. Automata-Based Model
CountingforStringConstraints.In Proceedingsofthe27thInternationalConference
on Computer Aided Verification (CAV) . 255â€“272.
1716[3]MichaelBackes,BorisKÃ¶pf,andAndreyRybalchenko.2009.AutomaticDiscovery
and Quantification of Information Leaks. In 30th IEEE Symposium on Security
and Privacy (S&P 2009), 17-20 May 2009, Oakland, California, USA . 141â€“153.
[4]DanielBalasubramanian,KasperLuckow,CorinaPÄƒsÄƒreanu,AbdulbakiAydin,
Lucas Bang, Tevfik Bultan, Miroslav Gavrilov, Temesghen Kahsai, Rody Kersten,
DmitriyKostyuchenko,Quoc-SangPhan,ZhenkaiZhang,andGaborKarsai.2017.
ISSTAC: Integrated Symbolic Execution for Space-Time Analysis of Code.
[5]Daniel Balasubramanian, Zhenkai Zhang, Dan McDermet, and Gabor Karsai.
2017. Janalyzer: A Static Analysis Tool for Java Bytecode. ISIS17 (2017), 104.
[6]Lucas Bang, Abdulbaki Aydin, Quoc-Sang Phan, Corina S. PÄƒsÄƒreanu, and Tevfik
Bultan. 2016. String Analysis for Side Channels with Segmented Oracles. In
Proceedings of the 24th ACM SIGSOFT International Symposium on Foundations of
Software Engineering (Seattle, WA, USA) (FSE 2016) . ACM, New York, NY, USA.
[7]LucasBang,NicolasRosner,andTevfikBultan.2018.OnlineSynthesisofAdaptive
Side-ChannelAttacksBasedOnNoisyObservations.In ProceedingsoftheIEEE
European Symposium on Security and Privacy .
[8]Dirk Beyer. 2021. Software verification: 10th comparative evaluation (SV-COMP
2021). In International Conference on Tools and Algorithms for the Construction
and Analysis of Systems . Springer, 401â€“422.
[9]Dirk Beyer. 2021. Status report on software testing: Test-Comp 2021. In Interna-
tionalConferenceonFundamentalApproachestoSoftwareEngineering .Springer,
Cham, 341â€“357.
[10]MateusBorges,AntonioFilieri,Marcelodâ€™Amorim,andCorinaS.PÄƒsÄƒreanu.2015.
Iterative distribution-aware sampling for probabilistic symbolic execution. In
Proceedings of the 2015 10th Joint Meeting on Foundations of Software Engineering,
ESEC/FSE 2015, Bergamo, Italy, August 30 - September 4, 2015 . 866â€“877.
[11]Mateus Borges, Quoc-Sang Phan, Antonio Filieri, and Corina S. PÄƒsÄƒreanu. 2017.
Model-CountingApproachesforNonlinearNumericalConstraints.In Proceedings
of the 9th International NASA Formal Methods Symposium . 131â€“138.
[12]Cristian Cadar and Koushik Sen. 2013. Symbolic execution for software testing:
three decades later. Commun. ACM 56, 2 (2013), 82â€“90.
[13]Supratik Chakraborty, Daniel J. Fremont, Kuldeep S. Meel, Sanjit A. Seshia, and
Moshe Y. Vardi. 2014. Distribution-Aware Sampling and Weighted Model Count-
ingforSAT.In ProceedingsoftheTwenty-EighthAAAIConferenceonArtificial
Intelligence . 1722â€“1730.
[14]SupratikChakraborty,KuldeepS.Meel,RakeshMistry,andMosheY.Vardi.2016.
Approximate Probabilistic Inference via Word-Level Counting. In Proceedings of
the Thirtieth AAAI Conference on Artificial Intelligence . 3218â€“3224.
[15]Bihuan Chen, Yang Liu, and Wei Le. 2016. Generating performance distributions
via probabilistic symbolic execution. In Proceedings of the 38th International
Conference on Software Engineering, ICSE 2016, Austin, TX, USA, May 14-22, 2016 .
49â€“60.
[16]Marko DimjaÅ¡eviÄ‡, Falk Howar, Kasper Luckow, and Zvonimir RakamariÄ‡. 2018.
Studyofintegratingrandomandsymbolictestingforobject-orientedsoftware.
InInternational Conference on Integrated Formal Methods . Springer, 89â€“109.
[17]AntonioFilieri,CorinaS.Pasareanu,andWillemVisser.2013. Reliabilityanalysis
in symbolic pathfinder. In 35th International Conference on Software Engineering,
ICSE â€™13, San Francisco, CA, USA, May 18-26, 2013 . 622â€“631.
[18]AntonioFilieri, CorinaS. PÄƒsÄƒreanu,WillemVisser, andJacoGeldenhuys. 2014.
StatisticalSymbolicExecutionwithInformedSampling.In Proceedingsofthe22nd
ACMSIGSOFTInternationalSymposiumonFoundationsofSoftwareEngineering
(HongKong,China) (FSE2014) .AssociationforComputingMachinery,NewYork,
NY, USA, 437â€“448. https://doi.org/10.1145/2635868.2635899
[19]DanielJ.FremontandSanjitA.Seshia.2014.SpeedingUpSMT-BasedQuantitative
Program Analysis. In In 12th International Workshop on Satisfiability Modulo
Theories (SMT) .
[20]Jaco Geldenhuys, Matthew B. Dwyer, and Willem Visser. 2012. Probabilistic
symbolicexecution.In InternationalSymposiumonSoftwareTestingandAnalysis,
ISSTA 2012, Minneapolis, MN, USA, July 15-20, 2012 . 166â€“176.
[21]Bertrand Jeannet and Antoine MinÃ©. 2009. Apron: A library of numerical ab-
stract domains for static analysis. In International Conference on Computer Aided
Verification . Springer, 661â€“667.
[22]Marta Kwiatkowska, Gethin Norman, and David Parker. 2004. Probabilistic
symbolic model checking with PRISM: A hybrid approach. International Journal
on Software Tools for Technology Transfer 6, 2 (2004), 128â€“142.
[23]Marta Kwiatkowska, Gethin Norman, and David Parker. 2007. Stochastic model
checking.In InternationalSchoolonFormalMethodsfortheDesignofComputer,
Communication and Software Systems . Springer, 220â€“270.
[24]JesÃºsA.DeLoera,RaymondHemmecke,JeremiahTauzer,andRurikoYoshida.
2004. Effective lattice point counting in rational convex polytopes. Journal of
Symbolic Computation 38, 4 (2004), 1273 â€“ 1302. https://doi.org/10.1016/j.jsc.
2003.04.003
[25]Loi Luu, Shweta Shinde, Prateek Saxena, and Brian Demsky. 2014. A model
counterforconstraintsoverunboundedstrings.In ProceedingsoftheACMSIG-
PLAN Conference on Programming Language Design and Implementation (PLDI) .
57.
[26] Rupak Majumdar and Koushik Sen.2007. Hybrid concolic testing.In 29th Inter-
national Conference on Software Engineering (ICSEâ€™07) . IEEE, 416â€“426.[27]CarlosPachecoandMichaelD.Ernst.2007. Randoop:Feedback-directedRandom
Testing for Java. In OOPSLA 2007 Companion, Montreal, Canada . ACM.
[28]RohanPadhye,CarolineLemieux,andKoushikSen.2019. JQF:Coverage-Guided
Property-Based Testing in Java. In Proceedings of the 28th ACM SIGSOFT In-
ternational Symposium on Software Testing and Analysis (ISSTAâ€™19). https://doi.
org/10.1145/3293882.3339002 .
[29]Rohan Padhye, Caroline Lemieux, Koushik Sen, Mike Papadakis, and Yves
Le Traon. 2019. Semantic Fuzzing with Zest. In Proceedings of the 28th ACM SIG-
SOFT InternationalSymposium on SoftwareTesting andAnalysis (Beijing, China)
(ISSTA2019) .AssociationforComputingMachinery,NewYork,NY,USA,329â€“340.
https://doi.org/10.1145/3293882.3330576
[30]Corina S PÄƒsÄƒreanu and Neha Rungta. 2010. Symbolic PathFinder: symbolic exe-
cution of Java bytecode. In Proceedings of the IEEE/ACM international conference
on Automated software engineering . ACM, 179â€“180.
[31]RenaudPawlak,MartinMonperrus,NicolasPetitprez,CarlosNoguera,andLionel
Seinturier.2016. Spoon:Alibraryforimplementinganalysesandtransformations
of java source code. Software: Practice and Experience 46, 9 (2016), 1155â€“1179.
[32]Quoc-Sang Phan, Lucas Bang, Corina S. Pasareanu, Pasquale Malacaria, and
TevfikBultan.2017. SynthesisofAdaptiveSide-ChannelAttacks.In 30thIEEE
Computer SecurityFoundations Symposium,CSF 2017,Santa Barbara, CA,USA,
August 21-25, 2017 . 328â€“342.
[33]Quoc-Sang Phan, Pasquale Malacaria, Corina S. PÄƒsÄƒreanu, and Marcelo
dâ€™Amorim. 2014. Quantifying information leaks using reliability analysis. In
Proceedings oftheInternational Symposiumon ModelChecking ofSoftware, SPIN
2014, San Jose, CA, USA . 105â€“108.
[34]Quoc-SangPhan,PasqualeMalacaria,OksanaTkachuk,andCorinaS.PÄƒsÄƒreanu.
2012.Symbolicquantitativeinformationflow. ACMSIGSOFTSoftwareEngineering
Notes37, 6 (2012), 1â€“5.
[35]SeemantaSaha.2022. PReach:Aprobabilisticreachabilityanalyzertoidentify
hard to reach program statements. https://zenodo.org/record/5915206.
[36]Seemanta Saha, William Eiers, Ismet Burak Kadron, Lucas Bang, and Tevfik
Bultan. 2019. Incremental Attack Synthesis. ACM SIGSOFT Software Engineering
Notes44, 4 (2019), 16â€“16.
[37]Gagandeep Singh, Markus PÃ¼schel, and Martin Vechev. 2017. Fast polyhedra
abstractdomain.In Proceedingsofthe44thACMSIGPLANSymposiumonPrinciples
of Programming Languages . 46â€“59.
[38]NickStephens,JohnGrosen,ChristopherSalls,AndrewDutcher,RuoyuWang,
Jacopo Corbetta, Yan Shoshitaishvili, Christopher Kruegel, and Giovanni Vigna.
2016. Driller: Augmenting Fuzzing Through Selective Symbolic Execution. In
23rdAnnualNetworkandDistributedSystemSecuritySymposium,NDSS2016,San
Diego, California, USA, February 21-24, 2016 .
[39]Xinyu Wang, Jun Sun, Zhenbang Chen, Peixin Zhang, Jingyi Wang, and Yun Lin.
2018. Towardsoptimalconcolictesting.In Proceedingsofthe40thInternational
Conference on Software Engineering . 291â€“302.
[40]IBM Watson. 2006. Watson libraries for analysis. wala. sourceforge. net/wiki/in-
dex. php. Main Page (2006).
[41]Shiyi Wei, Piotr Mardziel, Andrew Ruef, Jeffrey S Foster, and Michael Hicks.
2018. Evaluatingdesign tradeoffs in numeric staticanalysis for java. In European
Symposium on Programming . Springer, Cham, 653â€“682.
[42]LeiZhao,YueDuan,HengYin,andJifengXuan.2019. SendHardestProblems
My Way: Probabilistic Path Prioritization for Hybrid Fuzzing.. In NDSS.
1717