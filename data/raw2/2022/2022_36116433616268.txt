Statistical ReachabilityAnalysis
SeongminLee
Max Planck InstituteforSecurity and Privacy
Bochum,Germany
seongmin.lee@mpi-sp.orgMarcel Böhme
Max Planck InstituteforSecurity and Privacy
Bochum,Germany
marcel.boehme@acm.org
ABSTRACT
Given a target program state (or statement) /u1D460, what is the proba-
bility that an inputreaches /u1D460?This is the quantitative reachability
analysisproblem.Forinstance,quantitativereachabilityanalysis
can be used to approximate the reliability of a program (where /u1D460
is a bad state). Traditionally, quantitative reachability analysis is
solved as a model counting problem for a formal constraint that
represents the (approximate) reachability of /u1D460along paths in the
program,i.e.,probabilisticreachabilityanalysis.However,inpre-
liminaryexperiments,wefailedtorunstate-of-the-artprobabilistic
reachability analysis on reasonablylarge programs.
Inthispaper,weexplorestatisticalmethodstoestimatereach-
ability probability. An advantage of statistical reasoning is that
thesizeandcompositionoftheprogramareinsubstantialaslong
astheprogramcanbeexecuted.Weareparticularlyinterestedin
theerrorcomparedtothestate-of-the-artprobabilisticreachabil-
ityanalysis.Werealizethatexistingestimatorsdonotexploitthe
inherent structure of the program and develop structure-aware
estimators to further reduce the estimation error given the same
number of samples. Our empirical evaluation on previous and new
benchmarkprogramsshowsthat(i)ourstatisticalreachabilityanal-
ysis outperforms state-of-the-art probabilistic reachability analysis
tools in terms of accuracy, eﬃciency, and scalability, and (ii) our
structure-aware estimators further outperform (blackbox) estima-
tors that do not exploit the inherent program structure. We also
identify multiple program properties that limit the applicability of
the existingprobabilisticanalysis techniques.
CCSCONCEPTS
•Theoryofcomputation →Programanalysis ;•Mathematics
of computing →Bayesian computation .
KEYWORDS
Quantitativereachabilityanalysis,Statisticalreachabilityanalysis,
Reaching probability,Markov chain
ACM Reference Format:
SeongminLeeandMarcelBöhme.2023.StatisticalReachabilityAnalysis.In
Proceedings of the 31st ACM Joint European Software Engineering Conference
andSymposiumontheFoundationsofSoftwareEngineering(ESEC/FSE’23),
December 3–9, 2023, San Francisco, CA, USA. ACM, New York, NY, USA,
12pages.https://doi.org/10.1145/3611643.3616268
ESEC/FSE ’23, December 3–9, 2023, San Francisco, CA,USA
©2023 Copyright heldby theowner/author(s).
ACM ISBN 979-8-4007-0327-0/23/12.
https://doi.org/10.1145/3611643.36162681 INTRODUCTION
Thetraditionalassessmentofthereachabilityofaprogramstate
provides only a true-false answer: either the state is reachable
(e.g.,theprogrammaycrashforsomeinput)ornot(e.g.,itnever
crashes for any input). Due to the undecidability of the analysis
problem[ 16]andtherestrictedexpressivenessoftheanalysisresult,
such a binary answer provides only limited information. Instead
ofabinaryanswer, quantitativereachabilityanalysis providesthe
probability of how likely acertain program state is reached given
theworkloadoftheprogram.Sucha quantitative measureofreach-
ability can provide more comprehensive information about the
programsemantics.Forinstance,itcanestimatehowprobableis
to reach a crashing state under normal workload, which can be
criticalinformation for software reliability/security/maintenance.
Thetypicalmethodconsideredforquantitativereachabilityanal-
ysisiscalled probabilisticreachabilityanalysis [27],whichanalyt-
icallycomputes the reaching probability directly from the source
code. Probabilistic Symbolic Execution (PSE), the pioneering work
byGeldenhuysetal.[ 12],computesthereachingprobabilityofa
programstatebyﬁndingallthepathconditionstoreachthestate
usingsymbolicexecutionandcountingthenumberofinputssatisfy-
ingthepathconditionsusingmodelcounting;thesumoftheproba-
bilitiesbecomestheexactreachingprobabilityoftheprogramstate.
AsPSEmaysuﬀerfromscalabilityissuesforalargeandcomplex
program,manyfollow-upworkshavebeenproposedtoimprove
thescalabilityofprobabilisticreachabilityanalysis[ 11,13].Most
recently,Sahaetal.proposedPReachwhichcomputesthereaching
probability usingbranch-levelprobability information [ 27].
Whenfacingaproblemtoocomplexfortheanalyticalmethod,
especially when it is unmanageable to compute a quantity exactly,
asampling-basedstatisticalmethodcanbeusedtoovercomethe
limitation [ 4]. It is well-known that Monte Carlo methods have
been successfully applied to numerous problems across various
ﬁelds, including natural sciences [ 10] and engineering [ 23], where
the solution is intractable for analytic computation. Recently, in
the context of program analysis, Liyanage et al. [ 21] proposed a
statistical method to approximate the number of elements that can
be reached by actual program execution, which, previously, can
only be upper-boundedbystatic analysis.
This work explores how the statistical method can be applied to
quantitative reachability analysis. We propose a statistical reach-
abilityanalysis ,whichtacklesthequantitativereachabilityanaly-
sis problem with random sampling and statistical modeling. The
main issue of statistical reachability analysis is how to estimate
the reaching probability of a certain program state that has not
yet been observed in the sampling process. To overcome this issue,
we ﬁrst suggest a naive approach of using two well-known esti-
mators,LaplacesmoothingandGood-Turingestimator[ 15],that
can estimate the non-zero probability of unseen events from the
Thiswork islicensedunderaCreativeCommonsAttribution4.0Interna-
tional License.
326
ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA Seongmin Lee andMarcelBöhme
frequency of the seen events in a blackbox manner, i.e., without
considering the structural aspect of the program. Then, we further
investigate how the intrinsic structural property of the program,
thedependencybetweenprogramstates,canbeusedtoimprove
theestimationaccuracyofthestatisticalreachabilityanalysis,espe-
cially when the number of samples is small: the classic problem of
sampling-basedblackboxestimation.Weclaimthatthestructural
relation between program states can be an essential ingredient
to improving estimation accuracy. Consequently, we propose a
structure-aware estimator , a novel statistical reachability estimator
that considersthe structuralrelation between program states.
Toevaluatetheperformanceofthestatisticalreachabilityanal-
ysis,weuseasetofprogramsthathavebeenusedforevaluating
thestate-of-the-artprobabilisticreachabilityestimator,andcom-
parethestatisticalreachabilityestimatoragainsttworepresentative
probabilisticreachabilityanalysis,PSE[ 12]andPReach[ 27].Our
evaluation shows that the statistical reachability estimator can pre-
cisely estimate the reaching probability for all subject programs,
mostly in less than 0.1 seconds, while probabilistic reachability
analyzers fail or take a signiﬁcantly longer time to estimate for
a considerable amount of programs. In addition, we investigate
theeﬀectofusingstructuralinformationontheestimationaccu-
racyandtheeﬃciencyofthequantitativereachabilityanalysis.We
evaluatethestructure-awareestimatoragainstblackboxestimators
withtheSiemenssuiteandopen-sourcesoftwares.Ourempirical
resultsshowthat,within10%oftheexpectednumberofsamples
needed to reach the target state, the structure-aware estimator can
estimate the reaching probability with less than one magnitude
of error, while Laplace and Good-Turing estimator produces the
estimates with1.28and2.41magnitudes oferror,respectively.
The contributionsofthis paper are as follows:
•We propose statistical reachability analysis, a novel sampling-
based quantitative reachability analysis that estimates the reach-
ingprobability ofprogram states from astatisticalperspective.
•OurempiricalevaluationforasetofprogramsfromSV-COMP
benchmarks shows that the statistical reachability estimator can
preciselyestimatethereachingprobabilitywithsmallsamples
forallsubjects.Incontrast,probabilisticreachabilityanalyzers
applicablilty andperformance are limited.
•Wedesignastructure-awarereachabilityestimatorthatleverages
thedependenceinformationbetweenprogramstatesto provide
amore accurateestimationwithasmall number ofsamples.
•We evaluate the (blackbox and structure-aware) statistical reach-
abilityestimators onalarge andcomplex real-world software.
•Our empirical results show that the structure-aware estimator is
more accurate with a small number of samples than the black-
box estimators,indicating the advantage of using the structural
information ofthe program.
2 BACKGROUND
2.1 QuantitativeReachability Analysis
QuantitativeReachabilityAnalysis isanextensionofreachability
analysisthatcomputestheprobabilityofwhetheracertainprogram
stateisreachedforarbitraryprogramexecution.Givenaprogram /u1D443,
asetofprogramstates /u1D446,andanarbitraryoperationaldistributionofprogramexecution /u1D438,thereachingprobability Pr(/u1D460)ofaprogram
state/u1D460∈/u1D446is deﬁned as the probability of a random program
execution /u1D452∈/u1D438reachingthe state /u1D460:
Pr(/u1D460)=/summationdisplay.1
/u1D452∈/u1D438Pr(/u1D452) ·1(/u1D460isreachedby /u1D452), (1)
where 1(/u1D460isreachedby /u1D452)is an indicator function that returns
1if/u1D460isreachedby /u1D452and0otherwise.
Quantitative reachabilityanalysiscanbeaprimarygoalof pro-
gram analysis for ﬁguring out the reaching probability of a certain
critical program state. For example, it can provide how likely a
crashing program state is reached in a normal workload of pro-
gram execution. Such a crashing state could be an assertion that
the developer placed in the program, assuming it is always true, or
a recently discovered bug that is not yet ﬁxed. It can also estimate
for load testing a server-client program quantifying how often a
certain queryis sentto the serverinvariousworkloadsindiﬀerent
stagesofsoftwaredeployment.Suchaninformationcouldbeuseful
fortheserviceprovidertodecidethehowmanyserversareneeded
to handle the workload. Theresult of the quantitative reachability
analysiscanfurtherbeusedforthedownstreamsoftwaretesting
tasks. One can use it to design an optimal concolic testing strategy
by balancing the cost for the concrete execution and the symbolic
execution[ 29,31].
2.2 ProbabilisticReachabilityAnalysis
Probabilisticreachabilityanalysis[ 11–13,27],theprimaryapproach
forquantitativereachabilityanalysis,hasbeenwidelystudiedin
the last few decades. Based on the symbolic execution and the
modelcounting[ 14],probabilisticreachabilityanalysiscomputes
thereachingprobabilityofaprogramstatedirectlyfromthesource
code.Probabilistic Symbolic Execution (PSE) [12] is a pioneering
techniquethatcomputestheprobabilityofexecutingportionsof
theprogramtoperformaquantitativereasoningforsymbolicex-
ecution. Given a path condition for executing a portion of a pro-
gram, PSE computes the probability by counting the number of
inputsthat satisfythe condition using modelcounting. PSEsolves
the probabilistic reachability analysis problem by adding up all
the probabilities of the paths that reach the target program state.
Geldenhuys et al. show that PSE can estimate the probability of
triggering a bug in the program with high accuracy. As the path
explosionproblemisawell-knownobstacleforsymbolicexecution
to analyze a practical program, several subsequent works went on
toimprovethescalabilityofPSE:Filierietal.[ 11]proposedStatisti-
cal Symbolic Execution that still runs the model counting but only
for subset of paths sampled from all existing paths and uses the
informationforBayesianEstimationtoestimatethegrossprobabil-
ity. Gerrard et al. [ 13] proposed Conditional Quantitative Program
Analysis,whichblendsevidencefrommultiplestaticanalysesto
reduce the search space of the input reaching a target program
statement.
Most recently, PReach has been proposed to overcome the path
explosionproblem[ 27].Toavoiddirectlydealingwiththeprobabili-
tiesofexecutionpaths,PReachchoosestocomputetheprobabilities
of satisfying branch conditions in the program and use them to
estimatethe reachingprobability ofaprogramstatement.Branch
selectivity,whichdenotesthepercentageofvaluessatisfyingthe
327StatisticalReachability Analysis ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA
branch condition, is calculated using model counting as the ra-
tio of the number of values in the domain to the domain size of
the variable type satisfying the branch condition. Then, PReach
constructs a discrete-time Markov chain model representing the
transitionprobabilitiesofthestatementexecutionusingthecon-
trol ﬂowgraphtogether withthebranch selectivity.Thereaching
probability of a program statement is computed by solving the
Markov chain model. While PReach reduces the cost of the model
counting, it can only approximate the reaching probability of a
program statement since it does not consider the context of the
program execution. The domain of the variable can be changed by
the other statements executed before. Thus, thebranch selectivity
may signiﬁcantly diﬀer from the actual probability of satisfying
the branch condition in the program execution. To overcome such
animprecision,PReachsuggestsapplyingabstractinterpretation
to infer the domain of the variable. There are two variations of
PReach:PReach-I,whichusestheintervaldomain,andPReach-P,
whichuses the polyhedradomain.
2.3 Statistical EstimatorforUnseenEvents
In statistics, while allobservableeventsinthedomain space have
non-zero probability, some rare events may not be observed in the
sample space. Estimating the probability of an unobserved event is
thesunrise problem . To avoid assigning zero probability to unob-
servedevents,several statisticalestimators have been proposed.
Laplace smoothing , also known as additive smoothing, isone of
thepopularestimatorsforestimatingthenon-zeroprobabilityofan
unobserved event by adding a small positive smoothing parameter
/u1D6FCto all the events. The Laplace smoothing estimator estimates the
probability of the /u1D456-th category as/u1D450/u1D456+/u1D6FC
/u1D45B+/u1D6FC/u1D451, where/u1D450/u1D456is the number of
/u1D456-th category samples,and /u1D6FC>0isasmoothing parameter.
Another well-known estimator for estimating the probability
of an unseen event is the Good-Turing estimator [15]. The Good-
Turing estimator estimates the probability of discovering an object
ofhithertounseenspeciesfromthenumberofalreadyseenspecies.
It ﬁrst deﬁnes the incidence frequency /u1D44C/u1D456for a species /u1D437/u1D456as the
number of times that the species /u1D456is observed in the sample /u1D442/u1D45B.
Then, the number of singleton species /u1D4531is deﬁned as the num-
ber of species that are observed only once, i.e., |{/u1D44C/u1D456=1}/u1D456|. The
Good-Turingestimatorestimatestheprobabilityofdiscoveringany
unseen species in the next sampling as: /u1D4531//u1D45B. The probability of
discovering a certain unseen species /u1D437/u1D456is/u1D4531/(/u1D4530/u1D45B), where/u1D4530is
the number of unseen species within /u1D442/u1D45B. However, in general, it is
unknownhowmanyspeciesexistand,therefore,howmanyunseen
speciesare inthesample /u1D442/u1D45B.Therefore,GoodTuringprovides an
upper bound on the probability of discovering a certain unseen
species/u1D437/u1D456.
3 STATISTICAL REACHABILITYANALYSIS
Whileprobabilisticreachabilityanalysiscomputesthetruereaching
probability of a program state,1one canapproximate the reaching
probability using stochastic sampling. Let us say we want to es-
timate the reaching probability Pr(/u1D460)of a program state /u1D460in a
1While they aim to compute the true probability, often the analysis outcome is also an
approximation due to theoreticallimitationsand impractical computational cost.program /u1D443underacertainworkload,where wecansamplearan-
domprogramexecutionfrom.Assumingwehavesuﬃcientnumber
/u1D45Bof program execution samples /u1D442/u1D45B, the ratio of the number of
samples that reach /u1D460to the total number of samples(i.e., empirical
probability ˆPr(/u1D460)) willbe aclose approximation of Pr(/u1D460):
ˆPr(/u1D460)=/u1D44B/u1D460
/u1D45B/u1D45B→∞= ====⇒Pr(/u1D460), (2)
where/u1D44B/u1D460isthe number of executionsin /u1D442/u1D45Bthat reach /u1D460.
However,foracertainprogramstatethatisextremelyraretoob-
serve,theempiricalprobabilityestimatorcangenerateasubstantial
bias:
E/parenleftbigg/u1D44B/u1D460
/u1D45B|/u1D44B/u1D460>0/parenrightbigg
=Pr(/u1D460)
1− (1−Pr(/u1D460))/u1D45B,E/parenleftbigg/u1D44B/u1D460
/u1D45B|/u1D44B/u1D460=0/parenrightbigg
=0;(3)
if the reaching probability Pr(/u1D460)is very small, the empirical proba-
bilitybecomessigniﬁcantlylargerthanthetrueprobabilityifitis
observed (the left equation), and underestimated to zero if it is not
observed (the right equation). Especially, suchan underestimation
can be detrimental in the program reliability analysis: the analysis
mayconcludethattheprogramisreliableeventhoughthereisa
reachable erroneous state in the program. Therefore, the statistical
reachability analysis should always deal with the sunrise problem.
3.1 Blackbox ReachabilityEstimators
Toestimatethereachingprobabilityforbothobservedandunob-
served program states, we employ the Laplace estimator and the
Good-Turing estimator , which can deal with the sunrise problem.
For given executions /u1D442and the target program state /u1D460, theLaplace
estimator (Lap) estimates the probability of reaching /u1D460as:
Lap(/u1D460)=/u1D450/u1D460+/u1D6FC
/u1D45B+2/u1D6FC, (4)
where/u1D450/u1D460isthenumberofexecutionsthatreach /u1D460,consideringthere
aretwocategories:theexecutionsthatreach /u1D460andtheexecutions
thatdonotreach /u1D460.Forthesamesetting,the Good-Turingestimator
(GoTu) estimates the probability of reaching /u1D460as:
GoTu(/u1D460)=/braceleftBigg
/u1D450/u1D460//u1D45B,if/u1D450/u1D460>0,
/u1D4531//u1D45B,otherwise ,(5)
where/u1D4531is the number of singleton program states in /u1D45C; it gives
the empirical probability if the target program state is observed in
the executions /u1D442; otherwise,itgives the Good-Turing estimation.
DrawbacksofBlackboxEstimators. Atypicaldrawbackofsampling-
based estimators is that they may not be accurate for small sample
sizes.Forexample,thetheoreticalbackgroundoftheLaplaceesti-
mator lies in the normal approximation of binomial distribution,
which is sensible if the number of samples is large. Similarly, Good
also described that the estimation is expected to be good if the
number ofsample /u1D45Bislarge and /u1D4531isnot toosmall [ 15].
Another limitation of the above estimators is that they do not
exploit the dependencies between the program states. For example,
if a statement /u1D4602is the statement under the true branch of the if
statement /u1D4601,thenthereachingprobability Pr(/u1D4602)isalwayssmaller
than (or equal to) Pr(/u1D4601). However, if they are not reached in the
sample executions, none of the above estimators can distinguish
between the reachingprobability of /u1D4601and/u1D4602.
328ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA Seongmin Lee andMarcelBöhme
3.2 StructuralRelation forBetter Estimation
Program execution is a sequence of program state transitions, and,
therefore, there existsa hierarchical dependencerelation between
thestates.Oftenarareevent,suchasacrash,ofaprogramexecution
is placed deeplyin the program’s state hierarchy;they mayoccur
only if severalpreconditions are satisﬁedduringtheexecution.In
such a case, the hierarchical relation between program states until
reaching the rare event becomes a vital factor in estimating the
probability ofthe rare event.
(a)
 (b)
 (c)
Figure 1: Hierarchical structures of states. Each solid and
dashed edges represent the given executions have reached
andunreached thetransition,respectively.
Structural relations between program states can be an indicator
distinguishingthereachabilityprobabilityofmultipleunreached
programstates.Figure 1a,forinstance,representsthattheprogram
state/u1D4601is the direct predecessor of /u1D4602, similar to the if statement
anditstruebranchwediscussedinSection 3.1.Since/u1D4602canonly
be reached only if /u1D4601is reached, the reaching probability of /u1D4602is
less thanorequal to that of /u1D4601.
Usingthegivenexecutionsandthestructuralinformation,we
can even quantify the reaching probabilities of diﬀerent unreached
states. In Figure 1b, we assume that states /u1D4601and/u1D4603are reached
1,000 times and three times, respectively, from 1,000 executions,
and those executions never reached their direct successor states /u1D4602
and/u1D4604.Then,weconsiderapplyingLaplaceestimationoneach /u1D4601
and/u1D4603to estimatethe reachingprobability of /u1D4602and/u1D4604:
Pr(/u1D4602)=Pr(/u1D4601) ×/u1D6FC
1,000+2×/u1D6FC/u1D6FC=2=1×2
1,004≈0.0020,
Pr(/u1D4604)=Pr(/u1D4603) ×/u1D6FC
3+2×/u1D6FC/u1D6FC=2=0.003×2
10=0.0006.
The equation represents that there are more chances to reach /u1D4602
by reaching /u1D4601than/u1D4604by reaching /u1D4603, yet, if they reach their direct
predecessors, /u1D4604ismore likely to be reachedthan /u1D4602.
Now, we can estimate the reaching probability of an unreached
state,whichexistsdeepinthestructure,usingthereachingprob-
abilities of its predecessors and the path probability that lead to
theunreachedstate.Givenastructureandtheexecutions,thestate
reachedbytheexecutionsconstructsthe frontierofthereaching
region. The frontier consists of states that have an unreached di-
rect successor. For instance, the state /u1D445in Figure 1cbelongs to
the frontier. Then, there could be a hypothetical execution that
can reach the unreached hidden state /u1D43Bfrom/u1D445following the path/u1D445→/u1D4602→/u1D4605→/u1D43B. We call this path a hypothetical path ora
hy-pathof/u1D43B.Thereachingprobabilityof /u1D43Bbyfollowingthehy-
pothetical path /u1D445→/u1D4602→/u1D4605→/u1D43Bis the product of the reaching
probabilityof /u1D445andthetransitionprobabilityateachstateinthe
path.Assumingthatthereisnopriorinformationontheunreached
state,wemayestimatethetransitionprobabilityoneachstateas
the reciprocal of the number of its direct successors. Then, the
probability ofexecutingthe hypothetical pathis
Pr(/u1D445) ×/u1D6FC
#(/u1D445) +2×/u1D6FC×1
3×1
2.
Notethatanunreachedstatecanhavemultiplehy-paths.Ingeneral,
we can estimate the reaching probability of an arbitrary unreached
stateℎby summing up all the probability of executing the hypo-
thetical path of ℎ. Based on this motivation, we formally deﬁne the
structure-aware reachabilityestimator inthe nextsection.
3.3 Structure-AwareReachabilityEstimator
Notations & Hy-Path. Structure-aware reachability estimation is
basedonagivendirectedgraph /u1D43A=(/u1D449,/u1D438),calledastructuregraph ,
representingthedependencerelationbetweentheprogramstates
intheprogram /u1D443.Nodes/u1D449isasetofdiscreteprogramstates,and
/u1D438isasetof edgesrepresentingtheviablestatetransitionsduring
the program execution. A typical example of such a graph can be a
control-ﬂow graph,a data-ﬂow graph,ora call-graph,etc.,which
are widely used in program analysis, but, not limited to these, it
canbeanygraphthat approximates thedependencyoftheprogram
states. We will further discuss the precision of the graph at the
end of this section. A pathp=(/u1D4631,/u1D4632,...,/u1D463/u1D45B)in/u1D43Ais a sequence
of nodes such that (/u1D463/u1D456,/u1D463/u1D456+1) ∈/u1D438for1≤/u1D456≤/u1D45B−1. We call a path
starting from an entry node (a node having no predecessor in /u1D43A)
and ending at the exit node (a node having no successor in /u1D43A) a
completepath ,oranexecution asasingleprogramexecutioncanbe
treatedas sampling acomplete pathfrom /u1D43A.
Givenasetofexecutions O,wepartition /u1D449intotwosets:aset
of reached nodes /u1D449/u1D45Fand a set of unreached nodes /u1D449/u1D462. Then, the
deﬁnitionofahy-pathisas follows:
Definition 3.1 (Hy-Path ( hp)).Assume a node ℎ∈/u1D449is not
reached for a given set of executions /u1D442;ℎ∈/u1D449/u1D462. A pathhp={/u1D45D1,/u1D45D2,
···,/u1D45D/u1D45B=ℎ}is ahypothetical path or ahy-pathofℎif/u1D45D1∈/u1D449/u1D45F,
{/u1D45D2,···/u1D45D/u1D45B} ⊂/u1D449/u1D462,and∃/u1D45C∈ O,whose executionis
o={entry=/u1D45C1,/u1D45C2,···,/u1D45C/u1D45B=/u1D45D1,···,exit},
suchthat
he={entry=/u1D45C1,/u1D45C2,···,/u1D45C/u1D45B=/u1D45D1,/u1D45D2,···,/u1D45D/u1D45B=ℎ,···,exit}
isacompletepath.Wecallnode /u1D45D1acriticalnode andcompletepath
heahypothetical execution ofhp.
Probability Estimation. Our estimator estimates the reaching prob-
ability of an unreached node ℎ∈/u1D449/u1D462bythe sum of the reaching
probability of all hy-paths of ℎ. The estimator theoretically over-
approximatesthe reachingprobabilityof ℎsince every(hypothet-
ical) execution reaching ℎcontains at least one non-overlapping
hy-path of ℎ: for any hypothetical execution, one can consider the
lastreached node /u1D45D1in the execution before reaching ℎ. Then, the
sub-pathfrom /u1D45D1toℎisahy-pathof ℎ.Now,thediﬀerencebetween
theestimateandtheestimandistheprobabilityofthehypothetical
329StatisticalReachability Analysis ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA
executionthatcontainsmorethanonenon-overlappinghy-path
ofℎ. We claim that the bias is negligible in practice since the node
ℎwewanttoestimateisalreadyahard-to-reachnodeforalarge
number of executions. Considering a hy-path instead of a whole
(hypothetical) execution can signiﬁcantly reduce the graph traver-
sal space and thus the estimation time as the majority of reachable
program states can be reached with a relatively small number of
executions[ 5].
Path Probability. The key idea to estimate Pr(p), the probability
of executing the path pin/u1D43A, is to consider a path as the state
transitionofthe discrete-timeMarkovchain deﬁnedontopof /u1D43A.The
probability of hp={/u1D45D1,/u1D45D2,···,/u1D45D/u1D45B=ℎ}is the reaching probability
of node/u1D45D1multiplied by the product of the transition probabilities
ofalledges inthe hy-path:
Pr(hp)=Pr(/u1D45D1) ×Pr(/u1D45D1→/u1D45D2) ×/u1D45B−1/productdisplay.1
/u1D456=2Pr(/u1D45D/u1D456→/u1D45D/u1D456+1),(6)
wherePr(/u1D465→/u1D466.alt)denotethestatetransitionprobabilityfromstate /u1D465
tostate/u1D466.altintheMarkovchain.In hp,onlytheﬁrstnode /u1D45D1isreached
by executions, and the restof the nodes /u1D45D2,···,/u1D45D/u1D45Bare not reached.
Weusetheempiricalprobabilityforestimatingtheprobabilityof
the ﬁrst node /u1D45D1:ˆPr(/u1D45D1)=|{o∈ O →/u1D45D1∈o}|/|O|. We estimate
the transition probability Pr(/u1D45D2→/u1D45D1)using Laplace smoothing
for the local executions that reach /u1D45D1: given that none of the /u1D45B1
number of executions that reach /u1D45D1move to/u1D45D2,ˆPr(/u1D45D2→/u1D45D1)=
(/u1D45B1+/u1D6FC)/(/u1D45B1+2×/u1D6FC).Then,fortheremainingtransitionprobability,
we used the reciprocal of the number of children of the previous
node as the transitionprobability: ˆPr(/u1D45D/u1D456+1→/u1D45D/u1D456)=1/|/u1D45D/u1D456.succ|.
Cycles.Ifthestructurehascycles,therecouldbeaninﬁnitenumber
of hy-paths of ℎ. Such a cycle can be dealt with a stationary proba-
bilitydistributioncalculationforthediscrete-timeMarkovchain
(e.g., the PageRank [ 7] or the random walk [ 8]), which is a well-
knowntechniqueintheﬁeldofstochasticprocesses.Inaddition,
basedonthe features ofthe given graph structure,we can further
reduce the search space of the hy-paths, which will be discussed in
Section3.4withaconcretizedanalysistaskfor our evaluation.
ApproximationofStructureGraph. Itisworthnotingthatastructure-
aware estimator can provide the reaching probability even if the
given structure graph is abstracted or less precise compared to the
graph with the exact dependence information of the program. Due
to the dynamic nature of the program (e.g., dynamic function call),
obtaining the exact dependence information between the program
states is not always possible. Nonetheless, as the execution set size
increases,thefrontierofthereachingregiongetsclosertothetarget
state, which means the distance between the critical node and the
targetstategetssmaller.Thus,thebiasduetotheimprecisionof
thestructuregraphreduces,i.e.,theestimationresultisgenerally
getting more accurate as the execution set size increases. Such a
property of structure-aware estimation makes itself more robust to
the imprecision ofthe given structure graph.
3.4OptimizationusingtheStructuralProperties
We evaluate our structure-aware and blackbox reachability esti-
mators on the statement reachability estimation problem, a typical
problemforevaluatingthereachabilityanalysismethods[ 12,27].Forthestructuregraph,weusetheinter-proceduralcontrol-ﬂow
graph (InterCFG) as it represents the order of reaching the pro-
gram statements during execution. We ﬁrst set our assumption
that the program has a single exit point while we argue about this
assumption at the end ofthis section.
Thepropertyofthestructuregraphcanbeusedtoavoidunneces-
sary computation for the structure-aware estimator. In this section,
wesuggestthreeoptimizationsusingthestructuralpropertiesof
the InterCFG: 1) terminating inter-procedural call, 2) modularizing
the hy-path,and3)loophandling.
TerminatingInter-proceduralCall. Aprogramexecutionmay con-
tain zero or more inter-procedural transitions. Given a path in
InterCFG, one can identify the terminating inter-procedural call by
matchingthefunction-calledgeandcorrespondingfunction-return
edge in the path.Then,the wholesub-path underthe terminating
inter-procedural call can be replaced with a single edge connect-
ingthecallingnode andthenextnode inthecallerfunction;the
transitionprobabilityofthisedgeisonebecausetheexecutionwill
alwaysreturn to the next node after the function call.
ModularizingtheHy-path. Afterremovingtheterminatinginter-
procedural calls, we can modularize the reduced hy-path into a
sequenceofintra-proceduralpaths,called pathunits ;theprobability
of the hy-path becomes the product of the probabilities of the path
units:
Pr(hp)=/productdisplay.1
pu⊂rhpPr(pu), (7)
wherepudenotesapathunitinareducedhy-path rhp.Theadvan-
tage of modularization is that the estimator can reuse the proba-
bility of the path units for multiple hy-paths. For example, if the
function /u1D453, where the target statement /u1D460is located, has not been
reachedyet,everylastpathunitofthehy-path hpwillbethesame
aspu=[entry→ ··· → /u1D460]/u1D453, where[···]funcindicates the path
unitbelongstothefunction func.Therefore,untilthefunction /u1D453
is reached, the probability of the path unit pucan be eﬃciently
reused. Our empirical evaluation shows that modularization can
signiﬁcantly reduce the estimationtime.
Loop Handling. The cycle in an inter-procedural path occurs either
by a loop appearing at a path unit-level or a cyclic call sequence
appearing at a modularized hy-path-level. Using the feature of the
inter-proceduralcontrol-ﬂowgraph, we can avoidcomputing the
stationary probability distribution of the Markov process to deal
withthe cyclesinthe hy-path.
When estimating the probability of a path unit, the structure-
awareestimatorcanonlyconsidertheacyclicpathunitbyadjusting
the transition probability so that the probability of an acyclic path
includes the chances of the cyclic path. There are two cases: 1) the
path unit passes a loop (it does not end in the loop), 2) the path
unitendsintheloop.Ifapathunitpassesaloop,theadjustment
tothetransitionprobability Pr(loop-entry→loop-exit)=1since
every loop entrance must reach the loop exit if there is a single
program exit. Assume the path unit’s last node /u1D452is in the loop,
and let us denote the true branch of the loop a loop-start . The
original transition probability Pr(loop-start→loop-entry)before
adjustment is 1/|loop-entry.succ|=1/2. Let us say the reaching
probability of /u1D452after entering the loop is /u1D45E;Pr(loop-start→+/u1D452)=
330ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA Seongmin Lee andMarcelBöhme
/u1D45E.2Then,the reachingprobability of /u1D452inany loopiterationafter
reachingthe loopentry is:
/u1D45E
2+1−/u1D45E
2·/u1D45E
2+/parenleftbigg1−/u1D45E
2/parenrightbigg2
·/u1D45E
2+···=/u1D45E
1+/u1D45E=/u1D45E×1
1+/u1D45E.(8)
Thus, the probability of a path unit can be estimated by 1) starting
from the last node of the path unit, 2) multiplying the transition
probabilityinthereversedirectionofthepathunit,and3)ifitmeets
theloopentry,adjustthetransitionprobabilityto Pr(loop-entry→
loop-start)=1
1+/u1D45E, where/u1D45Eis the probability computed until the
currentprocess. Asthecycliccallsequence works similarly inthe
path-level, we can make the sameadjustment to avoid computing
the stationary probability distributionofthe Markov process.
We ﬁnally mention the single exit assumption. In the general
case, aprogram canhave multipleexits. Whenthere isa program
exitbetweenthefrontierofthereachingprogramstatementsand
the target statement, our estimator may overestimate the reaching
probability of the target statement. The bias dueto the imprecision
of the single exit assumption will decrease as the sample size in-
creases since there will be less chance of having a program exit
between the frontier andthe target statement.
4 EXPERIMENTALSETUP
4.1 Research Questions
We mainly ask two research questions to evaluate the performance
ofthe statisticalreachabilityanalysis.
RQ1: How does the statistical reachability analysis perform
compared to the probabilistic reachability analysis? In this
research question, we investigate the limitation of existing ana-
lyticmethodsandhowthestatisticalreachabilityanalysisperforms
comparedtotheprobabilisticreachability analysis.Ourinvestiga-
tion considers both the accuracy of the estimation for the program
with nontrivial semantics, and the scalability of the method. We
use PSEand PReachas baselineprobabilistic reachability analyzers
forcomparisonwiththestatisticalreachabilityestimatorsonthe
benchmarkprograms usedinthe PReach work.
RQ2:Howdothestructure-awareandtheblackboxreachabil-
ity estimators perform on hard-to-reach states in a complex
program? We claim that the statistical reachability estimators are
scalable regardless of how complex the program semantic is. To
verifythis claim,we investigatetheperformanceofthestatistical
reachabilityestimatorsforestimatingthereachingprobabilityof
hard-to-reach states in the program with bigger sizes and much
more complex semantics than the benchmark programs used in
RQ1. We also investigate the eﬃciency of the structure-aware
modelcomparedto the blackbox model.
4.2 Subject ProgramsandTargetStatements
Toevaluatetheperformanceofstatisticalreachabilityestimators
compared to probabilistic reachability analyzers, we concretize
the problem of quantitative reachability analysis into the problem
ofstatement reachability analysis and use the same benchmark
programsusedinthePReachwork[ 26]:142javaprogramsfrom
Competition on Software Veriﬁcation 2021 (SV-COMP). The target
2Pr(/u1D465→+/u1D466.alt)isthesumoftheprobabilitiesoftheintra-proceduralpathsfrom /u1D465to/u1D466.altTable 1:RQ1subject programs fromSV-COMP[ 26].
jpf-regress. (26) ExMIT-T, Exe1-F, Exe2-F, Exe4-F, Exe6-F, Exe8-
F, Exe10-F, Exe10-T, Exe12-F, Exe12-T, Exe13-T,
Exe14-T, Exe15-T, Exe18-F, Exe19-T, Exe20-F, Exe20-
T, Exe26-F, Exe27-F, FNEG-T, LCMP-T, Simple-F,
Simple-T, Suzette-F, Suzette-T, Assign-T
jbmc-regress. (4) assert3,if_icmp1, switch1, Token2
algorithms (2) InsertSort2, RBTree1
Table 2: Statistics of RQ2 subject programs from Siemens
suite (above ﬁve)andthe real-world programs (below ﬁve)
Program NCLOC #Func #BB GT
tcas 146 9 63 5.37E-04
schedule2 332 17 138 3.99E-04
totinfo 349 7 132 9.2E-04
printtokens2 438 19 198 7.82E-03
replace 534 21 228 2.73E-04
gif2png* 988 27 700 2.95E-04
jsoncpp 7,251 1,328 5,938 2.28E-03
jasper* 17,385 720 14,417 2.48E-04
readelf 22,347 477 18,578 1.99E-07
freetype2 44,686 1,635 27,521 8.25E-08
statements arethe assertionsin theprograms. Most142programs
have very primitive semantics to reach the assertion; a single com-
parison ( <,>,==,!=) to an input is the only condition for the
controlﬂowtotheassertion.Asourinterestisinmorerealisticpro-
grams,weﬁlteredoutthoseprogramswithprimitivesemanticsand
leftonly theprogramswhose semantics have meaningfulchanges
to the reachingprobability. Our selection criterion is that thepro-
gram semantics should update the domain of the value used in
the comparison for reaching the assertion and aﬀecting the branch
probability.Wemanuallyinvestigateall142programsandselect
32 programs after ﬁltering. Table 1shows the selected programs.3
The averagenon-comment-line-of-code (NCLOC) is35.2.
Sincetheprogramsizeisrelativelysmall,thereisnosingleton
afterafewiterationsofthesamplingprocess.Therefore,weonly
use the Laplace estimator for the statistical reachability analysis
methodin RQ1.Togettheground-truthreachingprobabilityofthe
assertion,wecheckthesemanticsofeachprogramandmanually
compute the reaching probability; we consider the same domain
(a signed 31-bit for an integer input and a length of 16 with all
printable ASCII characters for a string input) and assuming the
uniformdistributionoftheinputdomainasthePReachwork.To
validate the ground-truth, we seperately run a suﬃciently large
number of iterations of the sampling process and compare the
ground-truth withthe empirical reaching probability.
Subjects usedin RQ1are relatively small-sizedwith lesscom-
plexity. To evaluate the performance of statistical reachability esti-
matorsinrealisticprograms,wechooseﬁvemiddle-sizedprograms
3The programnamesareabstracted for the space issue.
331StatisticalReachability Analysis ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA
from the Siemens suite [ 9]4and several large-sized free and open-
source(FOS)C/C++applicationsandlibraries.Table 2showsthe
selectedprograms, number oflines,functions, andbasic blocks.
To remove the selective bias as well as to evaluate estimators
with a suﬃciently challenging task, we select the statement that
is most-frequently lastly-found while running multiple greybox
fuzzing on each subject program. For the Siemens suite subjects,
we run greybox fuzzing for six minutes with 990 repetitions and
recordthestatementcoveragehit-countsateachsecond.Forthe
FOSsubjects, weruntenrepetitionsofone-week greyboxfuzzing
taking more than one CPU year and record the statement coverage
hit-countsateach15minutes.Ifthefuzzingﬁndsthecrashinginput
duringthe campaignfor FOSsubject, we use the last statementof
the crashing path as the target statement considering the practical
reliabilityanalysisscenario.5
4.3 Sampling Process
Weusethegreyboxfuzzingdatatogeneraterandomsamplesforthe
statistical reachability analysis. Instead of using the raw statement
coverage hit-count from the fuzzing campaign, which contains the
adaptivebiasduetotheguidanceofthegreyboxmanner,wecreate
a simulated random sampling that is representative of theaverage
behavior of multiple greybox fuzzing campaigns. The simulated
randomsamplingprocessisasfollows:foreachgreyboxfuzzing
campaignthatdiscoversthetargetstatementinitscampaign,we
record the hit-count of the statement coverage at the timestamp
wherethetargetstatementisreachedﬁrst.Thehit-countdatadi-
vided by the number of samples until the timestamp (i.e., empirical
probability) becomes the expected coverage per sample of the cer-
tain fuzzing campaign. By averaging the expected coverage per
sampleforallthecampaigns,wegettheaverageexpectedcoverage
persampleofthesimulatedrandomsampling.Weusethetarget
statement’sground-truthreachingprobability,GT,astheempirical
probabilityofthisaverageexpectedcoverage,whichispresentedin
Table2.Then,wecansimulatethehit-countdataforanarbitrary
numberofsamplesby multiplying theaverageexpected coverage
persamplebythenumberofsamples.Forexample,thehit-countof
astatementwhoseaverageexpectedcoveragepersampleis0.372
with 100 samples is ⌊0.372×100⌋=37. The implementation of the
simulatedrandomsamplingcanbefoundinthepublicrepository.
ForRQ2evaluation,wegenerate10%ofthesamplesexpectedto
reachthe target statement: GT−1/10per subjectprogram.
There are two main advantages of using simulated random sam-
pling. First, it can be a representative of the average behavior of
multiple fuzzing campaigns. Diﬀerent fuzzing campaigns can have
diﬀerent hitting behaviordueto randomness. Sucha randomness
highlyaﬀectstheGood-Turingestimator,whichusesthenumber
ofsingletons,andthestructure-awareestimator,whichconsiders
whatthecriticalnodeisandhowmanytimesitishit.Therefore,
representative of the average behavior is needed to remove the
random bias for the evaluation. Second, random sampling from
an expected coverage per execution can simulate the hit-count
datafor anarbitrarysamplesize. Sincerecordingeveryhit-count
4we remove ‘schedule’ and ‘printtokens’ as they have the same semantics with ‘sched-
ule2’ and ‘printtokens2’butdiﬀerentimplementation
5‘*’ next to the subject name indicates the target node of the subject is the ﬁnal
statement of the crashing path.data for each new sample for a long fuzzing campaign of large
programsisnotfeasible,thehit-countdataforourﬁveopen-source
programsareonlyavailableevery15minutes.Therefore,thedatais
coarse-grained as the total number of data points is limited, which
deteriorates the statistical reachability analysis evaluation. Con-
versely,hit-countdataforanarbitrarysamplesizecanprovidea
ﬁne-grainedevaluation of the statisticalreachabilityanalysis.
4.4 EvaluationMetric& Environment
ForRQ1, we record the wall-clock time taken to measure the scala-
bilityofthemethods. The wall-clocktimetaken forthestatistical
reachabilityestimatoralsoincludesthe timeforthesamplingpro-
cess,asthecomputingcostofLaplaceestimatorispracticallynegli-
gible.Whileitisclearthattheaccuracyofthestatisticalreachability
estimatorwould increase as thesamplesize increases, we deﬁne a
thresholdofthesuccessfulestimationtomeasurehowmuchcostis
needed to get an accurate estimation. We say the statistical reacha-
bilityestimatorsucceedsintheestimationwith /u1D441/u1D460executionsifall
the errorsof tencontinuing estimates until /u1D441/u1D460-thestimation (e.g.,
Lap(/u1D460,/u1D441/u1D460−9),···,Lap(/u1D460,/u1D441/u1D460)forLaplaceestimator)fallbetween
99% and 101% of the ground-truthprobability in logarithmic scale.
0.99×/barex/barexlog10(GT)/barex/barex</barex/barexlog10(e)/barex/barex<1.01×/barex/barexlog10(GT)/barex/barex,
where/u1D452is the estimated probability and /u1D43A/u1D447is the ground-truth
probability.Weuselogarithmicscalesinceitismoresensitiveto
theestimationerrorwhentheprobability issmall.Thewall-clock
time takenfor the statistical reachability estimator in RQ1is then
thetimetakenuntilthe /u1D441/u1D460-thestimation.Ourtimeoutthreshold
fortheestimationis15minutes.Iftheestimationdoesnotﬁnish
within 15 minutes,we considerthe estimationas failed.
ForRQ2, we compute the accuracy of the estimated probability
bycomputingthelogarithmicerrorbetweentheestimatedproba-
bilityandthe ground-truth probability:
log-err(/u1D452,/u1D43A/u1D447)=|log10(e) −log10(GT)|.
If the log-err is 1, it means that the estimated probability is one
orderofmagnitudediﬀerentfromtheground-truthprobability.We
measure the time taken for both the sampling process and esti-
mation in RQ2. In addition, we also record the time taken of the
estimation for the structure-aware estimator explicitly to compare
thescalabilityofthestructure-awareestimatoritselfwiththeblack-
boxestimatorwhosetimetakenfortheestimationisnegligible.For
all the experiments, including the greybox fuzzing campaigns and
the estimation process, we repeat the process ten times and report
the averagevalueto reduce the random bias.
For the experiments, we use the PSE implementation in [ 22],
which is implemented on top of Symbolic PathFinder (SPF) [ 25]
as the original work does, and uses LattE [ 28] model counting
tool. Since the implementation does not support a signed 32-bit
domain, we use a signed 31-bit domain for PSE. For the Laplace
and the structure-aware estimator, we use the smoothing factor
/u1D6FC=2as it is the representative value driven from the mid-point
of the Wilson interval with 95% conﬁdence [ 30]. We use PReach
implementationprovidedbytheauthors[ 26]withthepolyhedra
domainasthedefaultabstractinterpretationdomain(PReach-P).All
the experiments are performed in a Ubuntu 18.04 docker container
with64coresof AMDEPYC7713P@2.0GHz and251GB memory.
332ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA Seongmin Lee andMarcelBöhme
5 RESULT
5.1RQ1: Analytic Method vs. Statistical Method
Table3:QuantitativereachabilityestimationforSV-COMP
2021benchmarks.Esti( ·)andT(·)aretheprobabilityestimate
andthetimespentfortheestimator;(TO,NL,DTMC)arethe
failure states of the estimation. O/X in the parenthesis after
thevalue representswhether theestimator succeeds.
Program GTEsti(PSE) T(PSE) Esti(PR) T(PR) Esti(Lap) T(Lap)
ExMIT-T ∼04.7E-10 (O) .866s 7.6E-06 (O) 14.9s 1.0E-06 (O) 0.044s
Exe1-F 0.49 NL(X) - 0.500(O) 13.5s 0.489(O) 0.006s
Exe2-F 0.2 NL(X) - 0.125(X) 14.6s 0.199(O) 0.003s
Exe4-F 0.25 NL(X) - 0.125(X) 14.7s 0.248(O) 0.014s
Exe6-F 1.0 NL(X) - 2.3E-10 (X) 14.8s 0.990(O) 0.001s
Exe8-F 0.3 NL(X) - 0.500(X) 14.7s 0.300(O) 0.005s
Exe10-F 0.25 NL(X) - 0.250(O) 14.5s 0.250(O) 0.005s
Exe10-T ∼0NL(X) - 1.2E-10 (O) 14.5s 1.0E-06 (O) 0.085s
Exe12-F 0.50.500(O) .934s 0.500(O) 14.6s 0.501(O) 0.004s
Exe12-T 0.375 0.250(X) .966s 0.375(O) 14.6s 0.376(O) 0.007s
Exe13-T ∼0 0(O) .909s 5.0E-11 (O) 13.7s 1.0E-06 (O) 0.087s
Exe14-T 0.25 0.5 (X) .860s 0.25(O) 11.9s 0.251(O) 0.018s
Exe15-T 0.250.125(X) .910s 0.25(O) 13.1s 0.251(O) 0.011s
Exe18-F 0.5 NL(X) - 0.500(O) 14.5s 0.502(O) 0.011s
Exe19-T 0.250.375(X) .950s 0.245(O) 14.5s 0.251(O) 0.015s
Exe20-F 0.25 NL(X) - 0.125(X) 13.6s 0.249(O) 0.008s
Exe20-T 0.50.500(O) .903s 0.5 (O) 14.5s 0.500(O) 0.008s
Exe26-F 0.5 NL(X) - 0.245(X) 14.7s 0.500(O) 0.006s
Exe27-F 0.50.500(O) .849s 0.500(O) 14.7s 0.500(O) 0.004s
FNEG-T 0 0(O) .850s 0.25(X) 14.5s 1.0E-06 (O) 0.045s
LCMP-T 0 0(O) .832s 0.5 (X) 14.9s 1.0E-06 (O) 0.044s
Simple-F 0 0(O) .854s TO(X) - 1.0E-06 (O) 0.048s
Simple-T 0 0(O) .844s TO(X) - 1.0E-06 (O) 0.047s
Suzette-F 0.250.250(O) .910s 4.7E-10 (X) 13.8s 0.249(O) 0.030s
Suzette-T ∼02.6E-9(O) .926s 2.6E-09 (O) 14.4s 1.0E-06 (O) 0.084s
Assign-T 0 0(O) .841s 0.25(X) 14.6s 1.0E-06 (O) 0.045s
InsertSort2 2.1E-02 TO(X) - 2.5E-11 (X) 15.8s 2.1E-02 (O) 4,904s
RBTree1 0.125 TO(X) - DTMC (X) 14.4s 0.124(O) 0.002s
assert3 ∼04.7E-10 (O) .847s 2.3E-10 (O) 10.6s 1.0E-06 (O) 0.044s
if_icmp1 0 0(O) .856s 5.0E-11 (O) 10.5s 1.0E-06 (O) 0.045s
switch1 ∼02.8-09(O) 1.03s 0.0 (O) 11.9s 1.0E-06 (O) 0.044s
Token2 4.8E-04 NL(X) - TO(X) - 5.2E-04 (O) 0.545s
/Q_uantitative Results. Table3shows the quantitative reachability
estimation result for the programs we select from the SV-COMP
benchmark. The ﬁrst and second columns show the program name
and the ground truth reaching probability of the target assertions.
Each (3rd, 4th), (5th, 6th), and (7th, 8th) column represents the
result from PSE, PReach, and Laplace estimator. Esti( ·) and T(·) are
estimator’sprobability estimateandtime spent.
Among 32 subject programs, PSE successfully estimates the
reachingprobabilityof15programs.Thesymbolicexpressionof
thepathconditiontoreachthetargetassertioncontainsnon-linear
termsin11programs(NLinthetable),whichisnotsupportedby
PSE implementation. PSE timeouts (TO in the table) for the two
programs, which are the exact two programs containing a loop.
PSEestimatesthewrongprobabilityfortheotherfourprograms
because the implementation does not consider the overﬂow/under-
ﬂowoftheintegervariables.Onaverage,PSEspends ∼1secondon
the estimation. In the case of PReach, the estimation succeeds only
for17outof32programs.For15failingestimations,thereisone
timeoutduringtheabstractinterpretation,twotimeoutsduringthe
model counting (TO in the table), and one divergence of DTMC
(DTMC).Fortheremainings,PReachestimatedfarsmaller/larger
probabilitiesthanthegroundtruth.Withoutthecaseswherethe
estimationfails, the time spentfor estimationisover tenseconds.1voidtest(String line) {
2String[] toks =
line.split(" ");
3inti = 0;
4for(String t : toks) {
5if(i == 3)
6 assert false ;
7++i;
8}
9}
(a)TokenTest021voidtest(intx,intz) {
2if(z < 0) return;
3// instead of int y = 3;
4inty =call("./ret3.sh");
5z = x - y - 4;
6if(x < z)
7assert false ;
8else
9print("b4");
10}
(b) Exe13-T
1voidtest(inti) {
2if(i >= 1000)
3if(!(i > 1000))
4 assert false ;
5}
(c) assert31voidtest(intz) {
2z = z % 5 - 2;
3if(z < 0) print("b1");
4else assert false ;
5}
(d)Exe8-F
Figure 2:Simpliﬁed pseudocodes ofRQ1subjects.
On the other hand, the Laplace estimator successfully estimates
the reaching probability for all 32 programs. Except InsertSort ,
thetimespentisstrictlylessthanonesecond,includingthetime
for the sampling (program executions). Among the 31 programs,
the average time spent estimating the assertion statements with
feasiblereachingprobabilities(GT >10−6)is0.039seconds(median:
0.007), and the average number of samples needed ( /u1D441/u1D460) is 9,615
(median: 1,531). To achieve an estimated probability of 10−6for
thestatementsinfeasibletoreach,theLaplaceestimatorrequires
2×106samples, and the average time spent for it is 0.055 seconds
(median:0.045).Only InsertSort2 takes4,904seconds,mostlyon
thesamplingprocess,nottheestimation.Thisisbecause InsertSort
runs the insertion sort in the worst-case scenario ( /u1D442(/u1D45B2)) for a
random positive integernumber length ([1, 231−1])array.
Our result shows that the Laplace estimator can successfully
estimate the reaching probability of all subjects in Table 3with
highprecision,generally,inashortperiodoftime.Ontheother
hand, PSE and Preach fail to estimate the accurate reaching
probability ofnearly halfof the subjects.
/Q_ualitative Analysis. We further investigate the properties of the
programsthatpreventtheanalyticapproachfromestimatingthe
correctreachingprobability of the program state.
Token2(Figure2a) epitomizesthe limitationof the previously
proposed probabilistic reachability analysis. An arbitrary size of
the array signiﬁcantlyincreases the domain space(Line 1), whose
complexity becomes squared after the String API splitis applied
(Line 2). It is non-trivial and requires manual eﬀort to interpret the
semanticsofanyAPIcall(Line2).TheloopinLines4-9areatypical
example of the path explosion problem; the number of paths to
consider would grow exponentially with the size of the array if the
true branch were not terminating the loop. The non-deterministic
loop iterations (Line 4) also obstructs the scalability/precision of
theanalysis asitneeds to consider themaximumnumber ofitera-
tions. Finally, the domain of variable iin Line 6 keeps changing at
each loop iteration, which makes branch selectivity-based analysis
diﬃcult to compute the correct probability. According to the result,
333StatisticalReachability Analysis ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA
PSE fails to estimate the reaching probability for Token2due to
thelimitedsupportfortheStringAPI.EveniftheStringAPIissup-
ported,thepathexplosionproblemwouldstillmaketheanalysis
hardly feasible, as we have seen for the programs InsertSort2 and
RBTree1 inTable3.Bothoftheabstractinterpretation(interval
and polyhedra) of PReach reaches the timeout limit for Token2.
The ground truthreachingprobability of Token2is
1−/parenleftbigg94
95/parenrightbigg15
−15/u1D43611
95/parenleftbigg94
95/parenrightbigg14
−15/u1D4362/parenleftbigg1
95/parenrightbigg2/parenleftbigg94
95/parenrightbigg13
=4.8267/u1D452−04,
whichistheprobabilityoftheinputstringhavingmorethan two
spaces. The vanilla PReach without the abstract interpretation fails
to estimate ( ˆPr=0.333) the correct reaching probability to the
assertion. Conversely, the Laplace estimator successfully estimates
theprobabilitywithlessthan1%oflog-scaleerrorinahalf-second.
By computing the branch selectivity probability and inducing
thepathprobabilityusingDTMC,PReachavoidsthepathexplosion
problem. However, applying the model counting to each branch
ignores the domain change of variables during execution, which
mayleadtoasigniﬁcantinaccuracyintheprobabilityestimation.
For instance, without abstract interpretation, PReach computes
thereachingprobabilityoftheassertionin assert3(Figure2c)as
0.25=1/2×1/2, where1/2stands for the branch selectivity for
each branch, yet the true probability is 1/232. Abstract interpre-
tation,thesolutionbyPReach,canpartiallysolvetheproblemof
domainchange.Whileitcanassisttheprogramlike assert3,which
stillhas auniformdistributionafterthedomainchange, itfailsto
handle the case of Exe8-F(Figure2d), where the domain space
becomesnon-uniform;thevaluedistributionofvariable zatLine3
inFigure 2disanon-uniformdistributionbetween [-6, 2],where
-2 has a double probability (2/10) than other values (1/10) due to
thepreviousinstructions.Therefore,whilethetrueprobabilityof
reachingtheassertionstatementatline9is 3/10=0.3,themodel
counting method computes 3/9=0.333, ignoring the non-uniform
distribution of the domain space.6In addition, a disjoint domain
spaceoradomainspacethatrequiresacomplexdomainabstraction
existsinthe real world, whichalsohindersthe analytic approach.
Finally, we mention the opaque code problem. By simply chang-
ingtheexpression‘3’ontherighthandsideofLine3in Exe13-T
(Figure2b)toanexternalcalltoashellscriptthatreturns3,sothat
the semantics of the program remains unchanged, PSE and PReach
failtodeterminetheinfeasibilitytoreachtheassertion,returning
0.25ofreachingprobability,becausethecodeisunavailable.Forthe
same program with the shell script, the Laplace estimator correctly
estimates that the assertion statementisinfeasibleto reach.
Our qualitative investigation illustrates the limitation of the
probabilistic reachability analysis to scale to real-world pro-
grams.Ontheotherhand,thestatisticalreachabilityanalysis
can scale independently of the complexity of the program se-
mantics, as it requiresonly thesamples ofprogram executions.Table 4: The average estimation time and the total time to
produce the estimated probability /u1D452oflog-err(/u1D452,/u1D43A/u1D447)<2. ‘-
’ denotes that the estimator cannot produce the estimated
probabilityoflog-err (/u1D452,/u1D43A/u1D447)<2within 10% ofthe samples.
Program Esti(Struct) Total(Lap) Total(GoTu) Total(Struct)
tcas 2.14e-04s 1.53e-01s 6.04e-01s 3.63e-02s
schedule2 2.43e-04s 2.54e-01s 4.75e-01s 4.88e-02s
totinfo 9.20e-04s 1.18e-01s - 9.30e-02s
printtokens2 1.28e-04s 4.54e-03s - 4.67e-03s
replace 2.74e-04s 3.07e-01s 1.32e+00s 4.65e-03s
gif2png 6.06e-03s 4.03e-01s 1.07e+00s 1.24e-02s
jsoncpp 7.30e-04s 1.83e-02s - 4.39e-03s
jasper 2.48e-04s 3.37e-01s - 1.40e-01s
readelf 8.56e-02s 4.82e+02s - 4.83e+02s
freetype2 2.77e-02s 7.04e+02s - 4.41e+00s
5.2 RQ2: EvaluationofStructuralInformation
Figure3ashowstheestimationresultsofthethreestatisticalreach-
abilityestimatorsontheprogramsfromtheSiemenssuiteandFOS
C/C++ programs/libraries.The upperside ofthe ﬁgure shows the
raw estimated reaching probability of the target statements, and
the below side shows the log-err compared to the ground-truth
reaching probability. For all the subject programs, the result shows
that the structure-aware estimator is the most accurate, and the
Good-Turing estimator is the least accurate across the diﬀerent
sample size; the structure-aware estimator is always better than
or equal to the Laplace estimator and so is to the Good-Turing
estimatorexceptforveryfewcasesduetotheunpreciseestimation
withaverysmallsamples.Duetothenon-existence ofthesingle-
ton,theGood-Turingestimatorproducesnoestimationforsome
sample size. For instance, it does not produce any estimation for
the ‘Printtokens2’ and‘Jsoncpp.’
Figure3bpresents the average log-err of the three statistical
reachability estimators across the programs in the log-scale. In
general,theerrorofallthreeestimatorsdecreasesasthenumber
of samples increases. Each Laplace, Good-Turing, and structure-
awareestimatorhasthelog-errorof3.00,4.67,and1.77,respectively,
when 0.1% of the expected number of samples needed to reach the
targetstatementisprovided.Onlythestructure-awareestimator
reaches a log-error below 1 (0.91), while Laplace and Good-Turing
estimators get to 1.28 and 2.41, respectively. The below side of
Figure3bpresents the diﬀerence in the average log-err between
the structure-aware estimator and the other twoestimators. The
maximumdiﬀerencebetweenLaplace(Good-Turing)andstructure-
aware estimator until 10% of the samples is 1.99 (4.08), and the
diﬀerence decreasesas the number of samples increases.
Itisworthnotingthatthestructure-awareestimatorisalsocost-
eﬃcient. Table 4shows the average time spent by the structure-
aware estimator across the programs; on average, it took 0.012
seconds for the estimation (median: 5e-04s), which is compara-
ble to the two other estimators, whose computation formula is
6In Table3, PReach-Pestimated 0.5due to missmanagingthe ‘%’ operator.
7The horizontal dashed lines in the estimation plots represent the ground-truth reach-
ingprobabilityofthe targetstatements.They-axisscaleof‘Readelf’and ‘Freetype2’
estimationplotsislogarithmic.
334ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA Seongmin Lee andMarcelBöhme
(a)Individual plotsfor each subject7(y:#of samples (%) )
 (b) Averagelog-err and diﬀerences
Figure 3: Three statistical reachability estimators’ (Good-Turing: orange, Laplace: blue, Structure-aware: green) reaching
probabilityestimationandtheerroroftargetstatementsintheprogramsfromSiemenssuiteandFOSC/C++programs/libraries.
rudimentary.ThelastthreecolumnsofTable 4showthetotal(sam-
pling + estimation) time spent by the three estimators to reach
the estimated probability of log-err(/u1D452,/u1D43A/u1D447)<2within 10% of the
executions, where the bold values denotes the least time among
the three estimators. ‘To reach’ means that everyestimate after
the shown time is within the error bound. The structure-aware
estimator requires the least time for most programs. In contrast,
the Good-Turing estimatorcould not produce the estimatewithin
the error bound using 10% of the executions for several programs.
Since the structure-aware estimator gives a more accurate esti-
mationgiventhesamenumberofsamples,oftentheoveralltime
spentbythestructure-awareestimatorislessthantheothertwo
estimators.
Thestatisticalreachabilityestimatorsareabletoestimatethe
reachingprobabilityforpractical-sizedprograms.Ourstructure-
awareestimatoristhemostaccurateamongthethreeestimators:
within 10% of the expected number of executions needed to
reach the target statement, the the estimate is less than one
order ofmagnitude awayfrom the ground-truth probability.
6 THREATS TO VALIDITY
Various threats to the validity need to be concerned about as we
evaluatetheperformanceofthereachabilityestimatorsempirically.
Externalvalidity concernswhethertheresultsfromthestudycan
be generalized. To mitigate this concern, we use various programswith diﬀerent sizes and complexity: SV-COMP 2021, Siemens suite,
andFOSsoftware.In RQ1,weusethesamebenchmarkusedbythe
formerstudyforafaircomparisonandchoosethesubjectsbasedon
the selection criteria. We extend our investigation to the programs
withalargersizeandcomplexityin RQ2foramoregeneraleval-
uation.Internalvalidity concernsthedegreeofconﬁdenceofour
study,havingnotbeen inﬂuencedbyanyfactorbeyondthescope
ofthestudy.First,tomitigatetherandomnessoftheexperiment,
weusenumerousrepetitionsofgreyboxfuzzingcampaignsandrun
every estimator with ten repetitions. Second, to avoid missing any
potential error in our evaluation and to facilitate the reproduction
ofour study,we make our scripts anddata publiclyavailable.
7 RELATED WORK
Beyondthequantitativereachabilityanalysis,Böhmeandcolleagues
studytheempiricalmethodandthestatisticalframeworkforpro-
gramanalysisingeneral[ 4,24]andforsoftwaretestingspeciﬁcally
[3,5,6].Forinstance,theyappliedthestatisticalapproachtoana-
lyzevariouspropertiesofblackboxfuzzingcampaigns,including
thetotalfeasiblebranchcoverage,theadditionaltimerequiredto
cover 10% more branches, and the residual risk that a vulnerability
exists when no vulnerability has been discovered so far. Later, they
extended the approach to greybox fuzzing, where the sampling
distribution is updated during the testing process, suggesting a
methodology to avoid the adaptive bias in the statistical model [ 6].
335StatisticalReachability Analysis ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA
Another line of work that exploits the observation-based sta-
tistical approach to estimating the program properties has been
explored in the program dependency analysis [ 17]. Binkley et al.
ﬁrst proposed an Observation-based Slicing (ORBS) [ 1], a program
slicingtechniquethatcanbeappliedtoaprogramwritteninmulti-
pleprogramminglanguages.Ithasshownthat,regardlessofhow
actuallytheprogramisimplemented,iftheruntimebehaviorofa
programstateischangedafterperturbinganotherprogramstate,
thereisadependencybetweenthetwostates.Usingthisobserva-
tion, ORBS can approximate the program dependency even for the
dependencythatcannotbecapturedbythestaticanalysis[ 2].Later,
Leeetal.adoptedstatisticalmodelingandextendedthisslicingtech-
niquetoageneralprogramdependencyanalysistechnique[ 19,20].
8 DISCUSSION & FUTUREWORK
Throughouttheevaluation,wehaveshownthatthestatisticalreach-
ability analysis is a promising approach to estimating the reaching
probability of a program. Not only is it scalable, but it can also
provide probability estimation with high precision for programs
thatarenotamenabletotheprobabilisticreachabilityanalysis.Fur-
thermore,ournovelstructure-awareestimatordemonstratesthe
beneﬁtofincorporatingstructuralinformationintothestatistical
reachability analysis. The structure-aware estimator can provide a
moreaccurateestimationevenwithasmallnumberofexecution
samples.
The main advantage of our structure-aware reachability estima-
toristhatitsystematicallyconsidersthehierarchicalrelationbe-
tween the reached and unreached states. Therefore, the estimation
is well-grounded interms ofthegivenstructure (as we illustrated
in Figure 1) and expected to be more accurate than the existing sta-
tistical estimators thatconsider the program asa blackbox. At the
sametime,thestructure-awarereachabilityestimatorismuchmore
scalable than the probabilistic reachability analysis. Our estimator
canemployanystructuralinformationthatcanbedrivenfroma
light-weighted static analysis, which is more applicable than the
symbolicexecutionandthemodelcounting.Forthefuturework,we
willinvestigatehowthoseadvantagesofstatistical/structure-aware
reachability analysis can actually beneﬁt the concrete downstream
applicationsonsoftware testingandmaintenance.
The probability distribution of reaching the successor program
statesfromtheunreachedprogramstateshasbeenapproximated
bytheuniformdistributioninourstructure-awareestimator.While
thisapproximationisreasonablewhenthereisnopriorknowledge,
any prior knowledge can be integrated into the structure-aware
estimatorbymodifyingtheprobabilitydistribution.Forinstance,
the branch selectivity from PReachcan be usedfor the probability
distributionofreachingthesuccessorprogramstates.Employing
theinformationfromthestaticanalysiscanalsobehelpfultoim-
provetheprecision/soundnessoftheestimationresult.Forinstance,
some statistical estimator (e.g., Laplace) may assign nonzero prob-
ability to the unreachable program states, which can be avoided
by using the information from the static analysis. Nonetheless, we
avoid using the model counting-based methods in this study since
it still requires considerable computational eﬀort to run the model
counting for every branch in a large program, and it will restrict
the domain of the variable to the integer domain. In the future, wewill investigate the beneﬁcial integration of analytic and statistical
methods.
9 DATA-AVAILABILITYSTATEMENT
All data & scripts are publicly available through Zenodo: https:
//doi.org/10.5281/zenodo.8267404 [18].
ACKNOWLEDGEMENTS
ThisworkwaspartiallyfundedbytheDeutscheForschungsgemein-
schaft(DFG,GermanresearchFoundation)aspartoftheExcellence
StrategyoftheGermanFederalandStateGovernments-EXC2092
CASA- 390781972.
REFERENCES
[1]DavidBinkley,NicolasGold,MarkHarman,SyedIslam,JensKrinke,andShin
Yoo. 2014. ORBS: Language-independent Program Slicing. In Proceedings of
the 22Nd ACM SIGSOFT International Symposium on Foundations of Software
Engineering (Hong Kong, China) (FSE 2014) . ACM, New York, NY, USA, 109–120.
https://doi.org/10.1145/2635868.2635893
[2]D. Binkley, N. Gold, M. Harman, S. Islam, J. Krinke, and S. Yoo. 2015. ORBS and
the limits of static slicing. In 2015 IEEE 15th International Working Conference on
SourceCodeAnalysisandManipulation(SCAM) .1–10.https://doi.org/10.1109/
SCAM.2015.7335396
[3]Marcel Böhme. 2018. STADS: Software Testing as Species Discovery. ACM
TransactionsonSoftwareEngineeringandMethodology 27,2,Article7(June2018),
52pages. https://doi.org/10.1145/3210309
[4]MarcelBöhme.2022. StatisticalReasoningAboutPrograms.In Proceedingsofthe
44th International Conference on Software Engineering (Pittsburgh, USA) (ICSE
2022). 5 pages. https://doi.org/10.1145/3510455.3512796
[5]Marcel Böhme and Brandon Falk. 2020. Fuzzing: On the Exponential Cost of
VulnerabilityDiscovery.In Proceedingsofthe28thACMJointMeetingonEuropean
SoftwareEngineeringConferenceandSymposiumontheFoundationsofSoftware
Engineering (VirtualEvent,USA) (ESEC/FSE2020) .AssociationforComputingMa-
chinery, New York, NY, USA, 713–724. https://doi.org/10.1145/3368089.3409729
[6]Marcel Böhme, Danushka Liyanage, and Valentin Wüstholz. 2021. Estimat-
ing Residual Risk in Greybox Fuzzing. In Proceedings of the 29th ACM Joint
Meeting on European Software Engineering Conference and Symposium on the
Foundations of Software Engineering (Athens, Greece) (ESEC/FSE 2021) . As-
sociation for Computing Machinery, New York, NY, USA, 230–241. https:
//doi.org/10.1145/3468264.3468570
[7]SergeyBrinandLawrencePage.1998. Theanatomyofalarge-scalehypertextual
Web search engine. Computer Networks and ISDN Systems 30, 1 (1998), 107–
117.https://doi.org/10.1016/S0169-7552(98)00110-X Proceedings of the Seventh
International WorldWideWeb Conference.
[8]Michael B. Cohen, Jonathan Kelner, John Peebles, Richard Peng, Aaron Sid-
ford, and Adrian Vladu. 2016. Faster Algorithms for Computing the Station-
ary Distribution, Simulating Random Walks, and More. In 2016 IEEE 57th An-
nual Symposium on Foundations of Computer Science (FOCS) . 583–592. https:
//doi.org/10.1109/FOCS.2016.69
[9]HyunsookDo, SebastianElbaum,and GreggRothermel. 2005. SupportingCon-
trolled Experimentation with Testing Techniques: An Infrastructure and Its
Potential Impact. Empirical Softw. Engg. 10, 4 (Oct. 2005), 405–435. https:
//doi.org/10.1007/s10664-005-3861-2
[10]R. Dum, P. Zoller, and H. Ritsch. 1992. Monte Carlo simulation of the atomic
masterequationforspontaneousemission. Phys.Rev.A 45(Apr1992),4879–4887.
Issue 7.https://doi.org/10.1103/PhysRevA.45.4879
[11]AntonioFilieri, CorinaS.Păsăreanu,WillemVisser,andJacoGeldenhuys.2014.
StatisticalSymbolicExecutionwithInformedSampling.In Proceedingsofthe22nd
ACMSIGSOFTInternationalSymposiumonFoundationsofSoftwareEngineering
(HongKong,China) (FSE2014) .AssociationforComputingMachinery,NewYork,
NY, USA,437–448. https://doi.org/10.1145/2635868.2635899
[12]Jaco Geldenhuys, Matthew B. Dwyer, and Willem Visser. 2012. Probabilis-
tic Symbolic Execution. In Proceedings of the 2012 International Symposium
on Software Testing and Analysis (Minneapolis, MN, USA) (ISSTA 2012) . As-
sociation for Computing Machinery, New York, NY, USA, 166–176. https:
//doi.org/10.1145/2338965.2336773
[13]MitchellGerrard,MateusBorges,MatthewB.Dwyer,andAntonioFilieri.2022.
Conditional Quantitative Program Analysis. IEEE Transactions on Software Engi-
neering48,4 (2022), 1212–1227. https://doi.org/10.1109/TSE.2020.3016778
[14]Carla P Gomes, Ashish Sabharwal, and Bart Selman. 2021. Model counting.
InHandbook of satisﬁability . IOS press, 993–1014. https://doi.org/10.3233/
FAIA201009
336ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA Seongmin Lee andMarcelBöhme
[15]I. J. Good. 1953. The Population Frequencies of Species and the Estimation of
Population Parameters. Biometrika 40, 3/4 (1953), 237–264. http://www.jstor.
org/stable/2333344
[16]WilliamLandi.1992. UndecidabilityofStaticAnalysis. ACMLett.Program.Lang.
Syst.1,4 (dec1992),323–337. https://doi.org/10.1145/161494.161501
[17]SeongminLee.2022. Statisticalprogramdependenceapproximation . Ph.D.Disser-
tation. KoreaAdvanced Instituteof Scienceand Technology (KAIST), Daejeon.
[18]SeongminLee.2023. Artifactfor"StatisticalReachabilityAnalysis" .https://doi.
org/10.5281/zenodo.8267404
[19]S. Lee, D. Binkley, R. Feldt, N. Gold, and S. Yoo. 2019. MOAD: Modeling
Observation-BasedApproximateDependency.In 201919thInternationalWorking
Conference on Source Code Analysis and Manipulation (SCAM) . 12–22. https:
//doi.org/10.1109/SCAM.2019.00011
[20]Seongmin Lee, David Binkley, Robert Feldt, Nicolas Gold, and Shin Yoo. 2021.
Observation-basedapproximatedependencymodelingandits useforprogram
slicing.JournalofSystemsandSoftware 179(2021),110988. https://doi.org/10.
1016/j.jss.2021.110988
[21]DanushkaLiyanage,MarcelBöhme,ChakkritTantithamthavorn,andStephan
Lipp. 2023. Reachable Coverage: Estimating Saturation in Fuzzing. In 2023
IEEE/ACM 45th International Conference on Software Engineering (ICSE) . 371–
383.https://doi.org/10.1109/ICSE48619.2023.00042
[22]KasperLuckow,CorinaS.Păsăreanu,andWillemVisser.2018. MonteCarloTree
SearchforFindingCostlyPathsinPrograms.In SoftwareEngineeringandFormal
Methods, Einar Broch Johnsen and Ina Schaefer (Eds.). Springer International
Publishing,Cham,123–138. https://doi.org/10.1007/978-3-319-92970-5_8
[23]Metodi Mazhdrakov, Dobriyan Benov, and Nikolai Valkanov. 2018. The Monte
Carlo method:engineering applications . ACMO Academic Press.
[24]NikhilParasaram,EarlT.Barr,SergeyMechtaev,andMarcelBöhme.2023. Precise
Data-Driven Approximation for Program Analysis via Fuzzing. In Proceedings ofthe38thIEEE/ACMInternationalConference onAutomated SoftwareEngineering
(ASE 2023) . Associationfor Computing Machinery, 1–12.
[25]Corina S. Păsăreanu and Neha Rungta. 2010. Symbolic PathFinder: Symbolic
ExecutionofJavaBytecode.In ProceedingsoftheIEEE/ACMInternationalCon-
ference on Automated Software Engineering (Antwerp, Belgium) (ASE ’10). As-
sociation for Computing Machinery, New York, NY, USA, 179–180. https:
//doi.org/10.1145/1858996.1859035
[26]Seemanta Saha. 2022. PReach: A probabilistic reachability analyzer to identify
hardtoreachprogramstatements .https://doi.org/10.5281/zenodo.5915206
[27]SeemantaSaha,MaraDowning,TeganBrennan,andTevﬁkBultan.2022. PReach:
A Heuristicfor Probabilistic Reachability to Identify Hardto Reach Statements.
InInternational Conference on Software Engineering (ICSE) .https://doi.org/10.
1145/3510003.3510227
[28]MathematicsUCDavis.[n.d.]. Latteintegrale .http://www.math.ucdavis.edu/
~latte
[29]Xinyu Wang, Jun Sun, Zhenbang Chen, Peixin Zhang, Jingyi Wang, and Yun Lin.
2018. Towardsoptimalconcolictesting.In Proceedingsofthe40thInternational
ConferenceonSoftwareEngineering .291–302. https://doi.org/10.1145/3180155.
3180177
[30]Edwin B Wilson. 1927. Probable inference, the law of succession, and statistical
inference. J.Amer.Statist.Assoc. 22,158(1927),209–212. https://doi.org/10.1080/
01621459.1927.10502953
[31]LeiZhao,YueDuan,HengYin,andJ.Xuan.2019.SendHardestProblemsMyWay:
ProbabilisticPathPrioritizationforHybridFuzzing. Proceedings2019Network
andDistributedSystemSecuritySymposium (2019).https://doi.org/10.14722/ndss.
2019.23504
Received 2023-02-02; accepted 2023-07-27
337