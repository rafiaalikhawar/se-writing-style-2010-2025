Fault Localization via Efficient Probabilistic Modeling of
Program Semantics
Muhan Zeng, Yiqian Wu, Zhentao Ye, Yingfei Xiong, Xin Zhang, Lu Zhang
Key Laboratory of High Confidence Software Technologies, Ministry of Education (Peking University)
School of Computer Science, Peking University
Beijing, PR China
{mhzeng,wuyiqian,ztye,xiongyf,xin,zhanglucs}@pku.edu.cn
ABSTRACT
Testing-based fault localization has been a significant topic in soft-
ware engineering in the past decades. It localizes a faulty program
element based on a set of passing and failing test executions. Since
whether a fault could be triggered and detected by a test is related
to program semantics, it is crucial to model program semantics
in fault localization approaches. Existing approaches either con-
siderthefullsemanticsoftheprogram(e.g.,mutation-basedfault
localization and angelic debugging), leading to scalability issues,
or ignore the semantics of the program (e.g., spectrum-based fault
localization),leadingtoimpreciselocalizationresults.Ourkeyidea
is: by modeling only the correctness of program values but not
their full semantics, a balance could be reached between effective-
ness and scalability. To realize this idea, we introduce a probabilis-
ticapproachtomodelprogramsemanticsandutilizeinformation
from static analysis and dynamic execution traces in our model-
ing.Ourapproach,SmartFL( SeManticsbAsedpRobabilisTicFault
Localization),isevaluatedonareal-worlddataset,Defects4J.The
top-1 statement-level accuracy of our approach is 21%, which isthe best among state-of-the-art methods. The average time costis 210 seconds per fault while existing methods that capture full
semantics are often 10x or more slower.
CCS CONCEPTS
‚Ä¢Software and its engineering ‚ÜíSoftware testing and de-
bugging.
KEYWORDS
fault localization, semantics, probabilistic modeling
ACM Reference Format:
Muhan Zeng, Yiqian Wu, Zhentao Ye, Yingfei Xiong, Xin Zhang, Lu Zhang.
2022. Fault Localization via Efficient Probabilistic Modeling of Program Se-
mantics. In 44th International Conference on Software Engineering (ICSE ‚Äô22),
May 21‚Äì29, 2022, Pittsburgh, PA, USA. ACM, New York, NY, USA, 12 pages.
https://doi.org/10.1145/3510003.3510073
Yingfei Xiong is the corresponding Author. Muhan Zeng and Yiqian Wu are equal
contributors to the paper and their names are sorted alphabetically.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACMmustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA
¬© 2022 Association for Computing Machinery.
ACM ISBN 978-1-4503-9221-1/22/05...$15.00
https://doi.org/10.1145/3510003.35100731 INTRODUCTION
In the last two decades, testing-based fault localization, or fault
localization in short, has been a research focus in software engi-
neering[ 2,11,23,33,38].Givenaprogramandasetoftestswith
at least one failing test, a fault localization approach computes the
suspiciousness score of each program element to determine which
one is the most suspicious to be faulty. Here the program elements
can be statements, methods, files, or at any needed granularity.
Among the large body of fault localization research, a central
focus is coverage-based fault localization. Coverage-based fault
localizationinfersthesuspiciousnessscoresofprogramelements
based on the coverage information, and the basic idea is that an
elementcoveredmorebyfailingtestsratherthanpassingtestsis
morelikelytobefaulty.Forexample,spectrum-basedfaultlocal-
ization (SBFL) [ 13], one of the most well-known fault localization
families, calculates the suspiciousness score of a program element
based on the number of passing tests and the number of failing
tests covering the element.
However,whetherabuggyprogramelementcausesthefailureof
a test is determined by four conditions [ 30,32,37]: (1) whether the
test coversthe buggy program element,(2) whether the execution
ofthebuggyprogramelementresultsinanerrorintheprogramstate,(3)whethertheerrorintheprogramstateispropagatedto
theoutputand(4)whethertheerrorintheoutputiscapturedby
anassertionornot.Coverage-basedfaultlocalizationignoresthe
semanticsofthetargetprogramandthusonlyconsidersthefirst
condition. A test may cover a buggy program element but still
pass because the latter three conditions are not satisfied, leading to
inaccuracies in coverage-based fault localization.
To overcome this problem, different approaches have been pro-
posed to take the latter three conditions also into consideration.
Forexample,mutation-basedfaultlocalization(MBFL)[ 21,23]gen-
eratesmanymutationsoneachelementandwatcheswhetherthe
program output or the test result (i.e., the pass/fail status) changes.
If a change in a statement is more likely to change the programoutput or the test result in the failing tests, and less likely in thepassing tests, the statement is likely to be faulty. Angelic debug-
ging [6,7] uses symbolic analysis to determine whether the result
of an expression can be modified to reverse the results of failing
testswhilemaintainingtheresultsofthepassingtests,andsuchan
expressionisconsideredmorelikelytobefaulty.However,these
approachestakethefullprogramsemanticsintoconsideration,and
thus the analysis is inevitably heavy. As an existing study [ 38]
reveals,mutation-basedfaultlocalizationoftenrequireshoursto
localize a single fault. As far as we are aware, there is so far no
successful application of angelic debugging to large programs.
9582022 IEEE/ACM 44th International Conference on Software Engineering (ICSE)
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:19:36 UTC from IEEE Xplore.  Restrictions apply. ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA Muhan Zeng, Yiqian Wu, Zhentao Ye, Yingfei Xiong, Xin Zhang, Lu Zhang
In this paper, we propose a novel approach to fault localization,
SmartFL,thatconsidersthefourfactorsviaefficientprobabilistic
modeling of the program semantics. Our approach considers a
sample space of all possible faults and analyzes which program
elementismorelikelytobefaultybasedoncurrenttestresults.Ourcoreinsightisthattheprobabilityofafaultinthecurrentprogramelementleadstothecurrenttestresultscanbeefficientlyestimated
by analyzing the following:
‚Ä¢theprobabilityofeachinstructioninthetracesoftestexe-
cutions to introduce an error into the system state.
‚Ä¢the probability of each instruction to propagate an error.
Inthisway,wedonotneedtoconsiderthefullsemanticsand
can abstract each value into two possibilities: faulty or not. Conse-
quently,theanalysisissignificantlysimplifiedandcanbeefficientlyapproached.Alongwiththisinsight,webuildaprobabilisticmodel
based on the test execution traces and calculate the posterior prob-
abilities of whether a statement is faulty based on the test result.
However,realizingthisideastillhastwomainchallenges.The
first one is how to model the effect from the control statements. If
theresultofaconditionalexpressionisfaulty,theexecutedstate-
mentsmayhavebeenchangedandthusanalyzingonlytheexecuted
instructions in the trace is insufficient. To overcome this challenge,
we statically analyze the impact of each conditional expression
and combine the static impact with the dynamically obtained trace.
The second one is scalability. Though our modeling is significantly
simpler than a model from the full semantics, the probabilisticmodel may still be large as the test execution traces can be long.
To overcome this challenge, we have introduced methods to select
andcompresstracesandutilizeanefficientprobabilityinference
algorithm [16, 25].
Wehaveevaluatedourapproachonthewidely-usedDefects4J
benchmark[ 15].Theresultsshowthatourapproachsignificantly
outperforms MBFL, the representative approach that leverages full
program semantics, in terms of both efficiency (210s per fault avg.)
and effectiveness (21% Top-1 accuracy). Our approach is also com-
plementary to existing approaches: while combining our approach
with existing approaches using the CombineFL framework [ 38],
the performance of the combined approach is further significantly
boosted by 26(12%) on Top-1 accuracy.
In summary, this paper makes the following main contributions.
‚Ä¢A fault localization approach by efficient modeling of pro-
gram semantics
‚Ä¢Noveltechniquesformodelingthecontrolstatementsand
for addressing scalability.
‚Ä¢AnevaluationontheDefects4Jdatasettoshowtheeffective-
ness and the efficiency of our approach.
Therestofthepaperisorganizedasfollows.Section2motivates
ourapproachwithexamples.Section3presentsbasicmathematical
background about factor graphs. Section 4 describes our approach
indetail,withanemphasisonhowtobuildtheprobabilisticmodel.
Section5showstheexperimentresultsandanswerstheresearch
questions. Section 6 discusses related research. Section 7 concludes
the paper.
2 OVERVIEW
In this section, we motivate our approach using an example.1public class CondTest {
2 public static int foo(int a){
3 if(a<= 2) { // buggy, should be a < 2
4 a=a+1 ;
5 }
6 return a;
7 }
8
9 @Test
10 void pass () {
11 assertEquals (2, foo(1));
12 }
13
14 @Test
15 void fail () {
16 assertEquals (2, foo(2));
17 }
18}
Figure 1: A Motivating Example for Condition Modeling
Motivating Example. Figure 1 (a) is a simple program for illus-
tration purpose. The buggy condition a< =2at line 3 replaced
the correct condition a<2. There are two test cases to find the
fault.Fortest pass,thefaultdoesnotinfluencetheevaluationof
the condition so the result is correct. However, in test fail, the
faultmisleadsthetesttothewrongbranchandgetsawrongresult.
Here we assume statement-level fault localization, and a desirable
approach should rank line 3 at the top.
Coverage-basedApproaches. Wefirstdemonstratewhycoverage-
based approaches such as SBFL fail to discover this bug. Coverage-
basedapproachesutilizecodecoverageinformationtocalculatesus-
piciousness scores. In SBFL approaches, the suspiciousness scores
ofanelement ùëíarecalculatedfromfournumbers:thenumberof
passing tests covering ùëí, the number of failing tests covering ùëí, the
total number of passing tests, and the total number of failing tests.
However, intheabove case,the coverageofpassing testsandfail-
ing tests are completely identical, resulting in equal suspiciousness
scores for every statement regardless of specific SBFL formulas.
As analyzed in the introduction, SBFL formulas cannot distin-
guish the suspicious degrees of different statements because cover-
ageisonlyoneoutofthefourconditionsthatleadtotestfailure.
Intest pass,thoughthefaultyexpressioniscovered,theresulted
runtime state is still correct, and thus calculating suspiciousness
with only coverage cannot distinguish each statement.
Other Existing Approaches. To address the above challenge,
manyexistingapproachestrytoanalyzealsothelatterthreecondi-
tions,i.e.,whethertheexecutionofastatementproducesafaulty
state, whether the faulty state is propagated to the output, and
whetherthetestcapturesthefaultinthestate.However,toanalyze
the three conditions precisely, we need to consider the full seman-
tics of the program, which is difficult to achieve efficiently. Here
we analyze two families of approaches.
A typical family is MBFL. MBFL mutates each statement to gen-
erate multiple mutants, and check whether the output of each
testexecution[ 23]orthetestresult(i.e.,thepass/failstatus)[ 21]
changes. In this case, mutating the statement at line 4 or the state-
mentatline6hasahighprobabilitytofailtest pass,whilemutating
the statement at line 3 has a much smaller probability to fail test
pass. In this way, we know that the statement at line 3 has a weak
959
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:19:36 UTC from IEEE Xplore.  Restrictions apply. Fault Localization via Efficient Probabilistic Modeling of Program Semantics ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA
correlation to the test result of passand is more likely to be faulty.
However, to obtain statistically significant information, we need to
generateanumberofmutantsforeachstatement,andalltestsneed
tobeexecutedoneachmutant,whichtakesasignificantamount
oftime.Inanexistingempiricalstudy[ 38],mutation-basedfault
localization requires hours to localize a single fault.
Another example family is angelic debugging [ 6,7]. Angelic
debugging analyzes, for each expression, whether its result can be
modified to reverse the results of failing tests while maintaining
theresultsofthepassingtests.Inthisexample,changingtheresult
of expression a+1at line 4 or the result of expression aat line 6
to any value different from 2 would fail test pass, and thus the
two expressions are not considered to be buggy. However, such an
analysis requires symbolic reasoning, which is known to be heavy
and has limited scalability. So far there is no successful application
of angelic debugging to large programs within our knowledge.
Our Approach. Different from the above approaches, our ap-
proachtakesaprobabilisticviewonfaultlocalization.Letuscon-
sider a sample space of all possible faults that the current program
couldpotentiallycontain.Giventhecurrenttestresultsasanob-
servation, our approach estimates the probability of each program
elementbeingfaulty.Toefficientlyestimatetheprobabilities,our
approach builds a probabilistic model based on the probability that
each statement produces and propagates faulty values.
Concretely, we introduce a set of Bernoulli random variables to
represent whether a statement is correct, denoted by ùëÜùëñ, whereùëñis
the line number of the statement. We also introduce another set of
Bernoullirandomvariablestorepresentwhethertheoutputvalueof
anexpressionexecutioniscorrect.Inthisexample,weuse ùëâùëù,ùëñ(ùëâùëì,ùëñ)
to denote the value produced by the expression execution at line ùëñ
intest pass(fail).Similarly, ùëâùëù,2andùëâùëì,2denotesthecorrectness
ofthetestinputsand ùëâùëù,6andùëâùëì,6denotesthecorrectnessofthe
test outputs.
Sincetheinputvaluesofthetestsarecorrect,wehavethefol-
lowing probabilities.
ùëÉ(ùëâùëù,2=1)=ùëÉ(ùëâùëì,2=1)=1
Please note that since the Bernoulli random variables are binary,
wealsoknow ùëÉ(ùëâùëù,2=0)=ùëÉ(ùëâùëì,2=0)=0.To easepresentation,
we will only present one of the two probabilities.
Since passpassesand failfails,wehavethefollowingproba-
bilities.
ùëÉ(ùëâùëù,6=1)=1‚àßùëÉ(ùëâùëì,6=1)=0
Now let us further consider the probabilities that the statements
produceandpropagatethefaultyvalues.First,wenoticethatifthestatementmustbeexecutedduringthetestexecution,thestatementitself is correct, and the input values are all correct, the result must
be correct. Then we have the following conditional probability
ùëÉ(ùëâùë°,3=1|ùëÜ3=1‚àßùëâùë°,2=1)=1
ùëÉ(ùëâùë°,6=1|ùëÜ6=1‚àßùëâùë°,4=1)=1whereùë°‚àà{ùëù,ùëì}
Then,we noticethat whetherthe statementatline 4should be
executed depends on the result of the expression at line 3. That
is,iftheexpressionproducesthecorrectresult,theexecutionsof
thestatementatline4inthetwotestsarecorrect.Thenwehave
the following conditional probability by considering both data andcontrol dependencies.
ùëÉ(ùëâùë°,4=1|ùëÜ4=1‚àßùëâùë°,2=1‚àßùëâùë°,3=1)=1whereùë°‚àà{ùëù,ùëì}
Next,weconsiderthecasewherefaultyvaluesmaybeproduced
or propagated. If an expression may produce a faulty result, any
ofthethreefollowingconditionsmusthold:theexpressionitself
iswrong,theinputoftheexpressioniswrong,ortheexpressionshould not be executed. To simplify our probabilities model, wedo not distinguish the three cases, and uniformly consider theprobability that an expression returns a faulty value when some
source is wrong.
Wenoticethatdifferenttypesofoperationsbehavedifferently.
Some are very sensitive to the faults: when something goes wrong,
the result is highly likely to be wrong. In our example, a+1is such
anoperation.Someareinsensitivetothefaults:whensomething
goeswrong,theresultcould still becorrect. Inour example, a< =
2issuchanoperation.Asaresult,wegiveahighprobabilitytothe
sensitive operations of returning a faulty value when something is
wrong and give a lower probability to the insensitive operations.
As a result, we have the following probabilities.
ùëÉ(ùëâùë°,3=0|ùëÜ3=0‚à®ùëâùë°,2=0)=0.5
ùëÉ(ùëâùë°,4=0|ùëÜ4=0‚à®ùëâùë°,2=0‚à®ùëâùë°,3=0)=0.99
ùëÉ(ùëâùë°,6=0|ùëÜ6=0‚à®ùëâùë°,4=0)=0.99whereùë°‚àà{ùëù,ùëì}
Based on the above probabilities, we build a factor graph [ 16]
using these probabilities as references. Factor graph is a probabilis-
tic graphmodeling technique where constraintsover the random
variablescouldbeeasilyadded.Finally,weuseaprobabilisticin-
ference algorithm named loopy belief propagation [ 25] to infer
ùëÉ(ùëÜùëñ=0)foreachùëñ.Theseprobabilitiesreflectthesuspiciousness.
In this example, we would successfully infer ùëÉ(ùëÜ3=0)‚âà0.707,
ùëÉ(ùëÜ4=0)‚âà0.270, and ùëÉ(ùëÜ6=0)‚âà0.223.ùëÜ3has the highest
probability to be faulty, i.e, successfully localizing the fault.
Challenges. Whilethebasicideaisstraightforward,realizingthis
idea needs to address multiple challenges. The first challenge is
modelingtheeffectsofcontrolstatements.InFigure2,thefailing
test goes through the elsebranch, leaving line 5 unexecuted, and
thus fails the assertion. In this case, the value of ais incorrect, but
the current modeling cannot relate this fault to the conditional
expression at line 4 because ais not changed by any statement
during the test execution.
To overcome this problem, we need to model the effect of the
unexecuted branch: the value of ùëécould be faulty when the con-
ditionisfaulty.Weperformstaticanalysistoobtainthevariables
changed by the unexecuted branch, i.e., a, and then add statement
a=aafter line 7 (denoted as line 7.1), i.e., the end of the executed
branch.Thenfollowingthesameprocedure,wewouldobtainthe
following conditional probability from the newly added statement:
ùëÉ(ùëâùë°,7.1=0|ùëÜ7.1=0‚à®ùëâùë°,4=0‚à®ùëâùë°,2=0)=0.99 where ùë°‚àà{ùëù,ùëì}
Inthisway,thevalueof ùëéandthevalueoftheconditionalexpression
are related. Finally, the suspiciousness score of the conditional
expression at line 4 is assumed to be the maximum value of ùëÉ(ùëÜ4=
0)andùëÉ(ùëÜ7.1=0).
Thesecondchallengeisscalability.Thischallengecomesfrom
two aspects: (1) a project may contain many tests, and modeling
960
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:19:36 UTC from IEEE Xplore.  Restrictions apply. ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA Muhan Zeng, Yiqian Wu, Zhentao Ye, Yingfei Xiong, Xin Zhang, Lu Zhang
1public class Unexecuted {
2 public static int foo(int a){
3 int b=0 ;
4 if(a< 10) // buggy, should be a<=10
5 a+= 2;
6 else
7 b++;
8 return a;
9 }
10
11 @Test
12 void pass () {
13 assertEquals (11, foo(9));
14 }
15
16 @Test
17 void fail () {
18 assertEquals (12, foo(10));
19 }
20}
Figure 2: An Example of Unexecuted Branch
all of them may lead to a very large model, while many tests are
unrelated to the current fault; (2) a test execution trace may be
extremelylongduetotheexistenceofloops,whilesuchlongloopsproviderepeatedinformationandmodelingsuchatracealoneleads
to a very large model. To address the first issue, we introduce a
two-phase instrumentation, and use a coarse-grained instrumenta-
tion to filter out tests unrelated to the failing ones. To address the
second issue, we introduce a loop compression algorithm to select
typical iterations such that all control/data dependencies between
statements and variables within any iteration are covered by at
least one selected iteration. In this way, we model the main effects
of the loop execution with a small number of iterations. We alsointroduce a compression method to compress the methods only
covered by the passing tests as one node. The details can be found
in Sections 4.4 and 4.6.1.
3 BACKGROUND
Beforeintroducingourapproach,wedescribebackgroundinforma-
tion about factor graph [ 16], which our probability model is based
on.
Afactorgraphisabipartitegraphrepresentingthefactorization
of a probability distribution. The two parts of vertices are node
vertices and factor vertices. Given a factor graph ùê∫=(ùëã,ùêπ,ùê∏)
consistsofanodevertexset ùëã={ùë•1,ùë•2,...,ùë•ùëõ},afactorvertexset
ùêπ={ùëì1,ùëì2,...,ùëìùëö}andanedgeset ùê∏.Eachnode ùë•ùëñ‚ààùëãrepresents
arandomvariableinthedistribution.Eachfactor ùëìùëó‚ààùêπrepresents
amultivariatefunction,mappingfromsomeoftherandomvariables
toarealvaluerepresentingtherelativelikelihoodoftheevent.If
there is an edge from ùë•ùëñtoùëìùëó,ùë•ùëñis an input variable of ùëìùëó. Let
ùëÜùëó‚äÜùëãbe the set of the input variables of ùëìùëó. The production of
all factors represents the probabilistic weight.Therefore, the jointprobability distribution can be defined as
ùëù(ùë•
1,ùë•2,...,ùë•ùëõ)=/producttext.1ùëö
ùëó=1ùëìùëó(ùëÜùëó)
/summationtext.1
ùë•1,ùë•2,...,ùë•ùëõ/producttext.1ùëö
ùëó=1ùëìùëó(ùëÜùëó)
Notice that the denominator representing the total probabilistic
weight from the entire sample space is used to normalize the prob-
ability.
Figure 3: Approach Workflow.
Multiple algorithms exist to infer the marginal distribution of
therandomvariables.Forexample,loopybeliefpropagation[ 25]is
an efficient approximating algorithm to infer the marginal distribu-
tions.
4 OUR APPROACH
In this section, we first describe our approach in detail and then
describevariousoptimizationsweappliedtoscaleit.Figure3shows
the workflow of our approach. First, our approach instruments
the subject program to generate execution traces of the test cases.
Then,ourapproachappliesstaticanalysisonthewholeprogram
and dynamic analysis on the execution traces to extract control
dependency and data dependency respectively. Next, our approach
builds a probabilistic graphical model (i.e., a factor graph) based onthisinformationthatdescribeshowthecorrectnessofeachprogramelementaffectseachother.Finally,ourapproachaddsresultsofthetestcasesasevidencetothemodelandperformsmarginalinference
conditioning on them. Our approach ranks the statements based
on their marginal probabilities and outputs this ranking.
4.1 Instrumentation
Ourapproachinstrumentstestrunsatthebytecodelevelandcol-
lectstracesthatarefurtherusedindependencyanalysis.Concretely,ourtraceincludesasequenceofinstructionexecutions,whereeachinstructionexecutionincludestheIDoftheinstruction,thetypeof
the instruction, the values read/written by this instruction, and the
changetotheprogramcounter.Tofacilitateunderstanding,wewill
describe our approach at the Java source code level, and use ‚Äústate-
ment‚Äù and ‚Äúinstruction‚Äù interchangeably. Yet the readers should be
aware that the collected traces are at the level of bytecode.
4.2 Dependency Analysis
Modelingdynamicdatadependencycaneasilybedonebyutilizing
theinformationfromcollectedtraces.Foranyreadoperationona memory location, the most recent write and its corresponding
instructioncanberesolvedbysequentiallyiteratinginstructionsinthetracewhilekeepingtrackofallmemorywrites.Thisinformation
is used in building the probabilistic graph described in Section 4.3.
Besides data dependencies, we also need to consider control
dependencies to precisely model how errors are introduced and
propagated.Unlikemodelingdatadependencies,weneedtocon-
siderinformationfromthewholeprogramratherthanonlyfrom
961
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:19:36 UTC from IEEE Xplore.  Restrictions apply. Fault Localization via Efficient Probabilistic Modeling of Program Semantics ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA
1public int foo(...) {
2 if(condition )
3 return a;
4 ...
5 return b;
6}
Figure 4: Example Program Demonstrating Control Depen-
dencies.
traces.Todecidewhetherabranchingstatementcontrolsanother
statement in execution, one needs to investigate whether the state-
ment would still be executed if the branching statement turns to a
differentbranchotherthantheonetakenintheexecution.Thiscan
only be achieved with the information of program fragments en-
closed in the unexecuted branch. Consider the program in Figure 4.
Suppose in a concrete run, the program takes the false branch, and
thus the trace is if(false) ... return b. The trace does not include the
information of the true branch and it remains unclear whether line
5 would be executed if the true branch was taken. However, by
investigating the program, we know that the dependency holds as
the method will return at line 3 if the branching statement takes
thetruebranch.Asaresult,thebranchingstatementcontrolsall
otherstatementsinthemethod,asitsbranchingstatusaffectsall
other statements being executed or not.
To precisely model control dependencies, we apply a static anal-
ysis[8]thatcalculatesdominancerelations[ 3]betweenstatements
on control flow graphs. Intuitively, a control statement controls all
its subsequent statements in its control flow graph until it reaches
statements that post-dominate it.
4.3 Building the Probabilistic Graph
After dependency analysis, our approach builds a factor graph
(described in Section 3) that models how errors are introduced
and propagated based on dependency information and programsemantics. In the graph, a node denotes a random variable that
representsthecorrectnessofastatementorarun-timevariable‚Äôs
value; edges are added based on control and data dependencies;
factors describe how likely errors can be introduced or propagated
inacertainway.AnexamplefactorgraphisshowninFigure5.We
next describe each component in detail.
Nodes.AnodeisaBernoullirandomvariablethatrepresentsthe
correctnessofarun-timevalueorastatement.Theformeriscalled
a value-node, and the latter is called a statement-node.
Ourapproachaddsavalue-nodetothegraphwheneveranassign-
mentoccursonavariableorafieldinthetrace.Thusavariable/field
correspondstomultiplenodesinthegraph,eachofwhichcorre-
sponds to a value it holds during executions. As for statements, we
create only one statement-node for each statement in the program
as a statement‚Äôs correctness should be consistent among all test
executions. Thus, sub-graphs constructed from different test cases
are connected through statement-nodes.
Edges.Edges are added based on the control and data depen-
dencies. In a factor graph, nodes are not directly connected, andan edge always connects a node to a factor. There are two typesof factors in our model: semantics-factors and evidence-factors.
Figure 5: Generated factor graph for Figure 1.
Semantics-factorsandevidence-factorsaddprogramsemanticsand
observation evidence to our model respectively, which we will
discuss later.
Foranodewhosecorrectnessisknown(e.g.fromthetestoracle),
we introduce an evidence-edge to link it with a corresponding
evidence-factor.
For each statement, we introduce a semantics-factor and cor-
responding edges to describe how errors can be introduced byit or propagated through it. Concretely, the following nodes are
connected to the semantics-factor:
(1) The statement-node itself.(2)
Avalue-nodethatrepresentsthevaluethatiswrittenbythe
statement.
(3)Value-nodes that represent values that are read in the state-
ment.
(4)Value-nodes that represent the condition values that control
the current statement.
The corresponding edges that connect to these nodes are called:
statement-edge, define-edge, use-edge, and control-edge, respec-
tively.Theseedgestogetherlinkavalue-nodedenotingtheresult
of the statement ((2)) with its possible immediate sources of errors
((1)(3)(4)).
Factors.As described in Section 3, each factor represents a mul-
tivariate function. In our model, the function of a semantics-factor
evaluates how likely a value can become erroneous after executing
a statement. The main idea is that if any of the following:
(1) The current statement(2) All values it uses(3) All condition values that controls it
iserroneous,thenthereisapossibilitythatthevalueitdefinesis
erroneous.Werefertoallthethreeformerelementsas‚Äúsources‚Äù,
and the last one as ‚Äúresult‚Äù in the rest of this section.
Table 1 shows the function of semantics-factors. The column
‚ÄúSources‚Äùindicateswhetherallthesourcesarecorrect,whilethe
962
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:19:36 UTC from IEEE Xplore.  Restrictions apply. ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA Muhan Zeng, Yiqian Wu, Zhentao Ye, Yingfei Xiong, Xin Zhang, Lu Zhang
Table 1: The truth table of a semantics-factor.
Sources ResultFactor Value
Insensitive Sensitive
11 11
10 00
01 0.5 0.01
00 0.5 0.99
column‚ÄúResult‚Äùindicateswhethertheresultiscorrect.The‚ÄúFac-
tor Value‚Äù column indicates the likelihood of different correctness
states of sources and the result. Note the factor values cannot be
directlyinterpretedasprobabilities,butasawaytocomparethe
likelihoodbetweendifferentstatesofsourcesandtheresult.Further,
we observe that statements whose operators are ‚Äú <‚Äù, ‚Äú>‚Äù, ‚Äú==‚Äù, ‚Äú!=‚Äù
or‚Äú%‚Äùarelesssensitivetothecorrectnessofthesourcesthanother
operators(e.g.‚Äú+‚Äù,‚Äú √ó‚Äù).Forexample,when ùë•containsanincorrect
value, there is a higher chance for ùë•>0 to produce a correct value
thanùë•+1, as the prior has a much smaller value domain {True,
False}. Following this intuition, we divide the ‚ÄúFactor‚Äù column into
‚ÄúInsensitive‚Äù and ‚ÄúSensitive‚Äù for these two types of statements.
We now explain the meaning of each row in the table. The first
tworowsmeanthatwhenallthesourcesarecorrect,thestatement
should always produce a correct result. The last two rows mean
thatwhenthesourcesarenotfullycorrect,thereisstillachancefor
theresulttobecorrect.Forinsensitivestatements,suchachance
is moderate (0.5), which is the same as the chance for the result to
be incorrect. While for sensitive statements, such a chance is very
low(0.01),andthechancefortheresulttobeincorrectisveryhigh
(0.99). We refer to parameters 0.5, 0.01, and 0.99 as moderate, very
low, and very high factor values in Section 5, and the impact of
different parameter values is further discussed in RQ3.
Finally, we can infer the correctness of some program elements
from test inputs and test assertions. Most notably, we have the
followings:
(1) Test inputs should be correct.(2)
The Boolean value produced by passing assertions should
be correct.
(3)The Boolean value produced by failing assertions should be
incorrect.
Weaddtheseinformationtoourmodelasfollows:foreachevidence
(ùë•=ùëí),anevidence-factorlinkingtothecorrespondingprogram
elementisaddedtothegraph,withthefactorfunctiondefinedas
follows:ùëì(ùë•=ùëí)=1 andùëì(ùë•‚â†ùëí)=0.
4.4 Capturing Semantic Effect of Unexecuted
Statements
So far, we have introduced how to model the data dependenciesand control dependencies between statements that are executedin test cases. However, this information is not enough to locatefaults precisely because an error can be introduced if necessary
statementsarenotexecuted.ConsidertheexampleinFigure2again.
The assertion on line 18 fails because the statement on line 5 is
notexecuted,whichisfurthercausedbytheincorrectbranchingstatementonline4.However,onecannotcapturethisconnectionby
only reasoning about control dependencies and data dependencies
recovered from the trace.
To model this information precisely, one needs to also reason
about data dependencies and control dependencies between ex-ecuted code and unexecuted c ode. However , a full-fledged static
analysisthatconsidersallpossiblebehaviorsoftheprogramwould
be too expensive. Instead, we take a lightweight approach that ab-
stractstheeffectofunexecutedcodebytransformingtheoriginal
program.Briefly,foracondition ùëê,letSbethesetofallvariables
defined by the statements controlled by ùëê. For each variable ùë£inùëÜ,
thetransformationaddsacomplementarystatement ùë£=ùë£atthe
endofeachbranch.Thecomplementarystatementisregardedas
the branching statement in the result, as the incorrectness of ùë£=ùë£
means the program has taken the wrong branch. For simplicity, we
only consider variables on the stack in our implementation. Such a
transformationdoesnotchangetheprogram‚Äôssemanticsbutallows
ourcontroldependency analysisanddatadependencyanalysisto
abstract the effect of unexecuted code automatically.
4.5 Getting the Final Result
Thefactorgraphthatisbuiltusingtheabovestepsdefinesajoint
distribution of the correctness of all program elements. We nowcan perform a marginal inference on the graph, which produces
theprobabilityofaprogramelement beingincorrect.Thisinturn
is used to produce the final ranking of fault localization. We im-
plement the inference using an efficient iterative algorithm called
loopy belief propagation [ 25]. Finally, we perform dynamic slicing
to filter elements irrelevant to the fault.
4.6 Scaling Our Approach
Instrumenting program runs can produce enormous execution
traces. These can lead to gigantic factor graphs which cannot even
bestoredinphysicalmemory,letaloneperforminginference.To
addressthischallenge,weapplyseveraltechniquestoreducethe
trace sizes within and across test cases.
4.6.1 Reducing Sizes of Traces. We apply two techniques to re-
ducethesizeofagiventrace:compressingloops,andselectively
instrumenting methods.
AspointedoutinSection2,heavyloopsmayleadtolongtraces,
resultinginaverylargemodel.Inaddition,italsocontainsrepeated
code patterns, which provides very little information to our proba-
bilisticmodel.Toreducethetracecausedbytheloops,wewould
like to select a key subsequence of the trace containing some of
the iterations. Here we define a subsequence as a key subsequence
if all control/data dependencies between statements and variables
within any iteration are covered by at least an iteration in the sub-
sequence. In this way, we can model the main effect of the loop
while significantly reducing its size.
Toselectthekeysubsequence,wecheckeachpairofadjacent
iterations. If the sequences of statements executed in the two it-
erationsareidentical,weonlykeepthefirstiterationinthefinal
trace. As for nested loops, we first compress the inner loops andthen compress the outer loops. As a result, for any sequence ofstatementsexecuted,atleastaniterationiskepttorepresentthe
963
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:19:36 UTC from IEEE Xplore.  Restrictions apply. Fault Localization via Efficient Probabilistic Modeling of Program Semantics ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA
sequence. Accordingly, all control/data dependencies are kept with
respect to the key subsequence.
Second, weobserve that parts ofthe passing tracescan be sum-
marizedintoatomicstatements.Thekeyinsightisthattheincorrect
statements that are responsible forthe failuremust becovered by
atleastoneofthefailingtestcases.Asaresult,forasequenceof
statementsthatareonlycoveredinpassingtestcases,weonlycare
aboutthedependenciesbetweenthemandotherstatementsbutnotthe dependencies between statements inside the sequence, because
none of them can be the faulty statement our approach is trying to
locate.Thissequenceinturncanbetreatedasoneatomicstatement.
Weperformsuchcompressionatmethodlevelsasstatementsinside
themusuallyhavelimiteddependencieswithstatementsoutside
them.Forexample,whenamethoddoesnotaccesstheheap,itcanbesummarizedasastatementthatcalculatesitsreturnvaluebased
on the parameters. Concretely, we also consider field access of the
callee object when the method is non-static, as setters and getters
are very common practices in Java that involve field access.
4.6.2 SelectingTestCases. Whileourtechniquesareeffectivein
reducing trace sizes, some of the traces can be still too large to
beincluded.Therefore,weintroduceseveraltechniquestoselect
a subset of test cases whose information will be included in our
modeling.
First, we observe that while all failing test cases usually carry
usefulinformationaboutfaults,notallpassingtestcasesareuseful.
Inparticular,ifapassingtesthasacompletelydifferentcoverage
compared to failing tests, it carries no information for localization
as it does not cover any suspicious location. Similarly, if a passing
test case covers a very different set of methods compared with the
failing test cases, it is unlikely it is useful in locating the faults. To
realizethisidea,wefirstrunacoarse-grainedinstrumentationto
get method-level coverage. The tests are ranked by the numberof commonly covered methods with failing tests. Except for thetop 50 tests, the remaining tests are excluded from fine-grained
instrumentation,which is often costly because of heavy I/O.
Second,duetopracticalconcerns,weexcludeverylongtraces
and some traces when the probabilistic graph becomes too large.
To handle the former case, we set a hard limit on the size of any
given trace and discard traces whose size has reached this limit. Tohandlethesecondcase,wesetalimitonthesizeoftheprobabilistic
graphunderconstruction.Moreconcretely,whenconstructinga
graph,weconsiderallfailingtestcases.Asforpassingtestcases,
we sort their traces by the size in ascending order and add their
informationone-by-onetothegraphuntilthegraphsizereaches
the limit.
5 EVALUATION
5.1 Research Questions
‚Ä¢RQ1:EffectivenessofSmartFL. HoweffectiveisSmartFL
compared to other techniques?
‚Ä¢RQ2:EfficiencyofSmartFL. WhatisthetimecostofSmartFL
compared to other techniques?
‚Ä¢RQ3: Influence of Different Factor Values. To what ex-
tentdomoderate,verylow,andveryhighfactorvaluesin
both sensitiveand insensitive statements affectthe results?Table 2: Projects from Defects4j dataset, version 1.0.1.
Project Faults LoC
Apache Commons Math 106 103.9k
Apache Commons Lang 64 49.9k
Joda-Time 26 105.2k
JFreeChart 26 132.2k
Total 222 91.7k
‚ÄôFaults‚Äô denotes the number of defective versions of the project, ‚ÄôLoC‚Äô
denotes the average lines of code of each project. Bold denotes the
abbreviation for the project.
‚Ä¢RQ4: Effectiveness of Different Components. What is
the contribution of each component to the overall effective-
ness?
‚Ä¢RQ5: Combining with other Techniques. Can SmartFL
improve the effectiveness of combination methods?
5.2 Benchmark and Measurements
We take the projects from Defects4j [ 15] version 1.0 as our bench-
mark, so as to compare with the results of other approaches in
existing studies [ 26,38]. We exclude the Closure project because
itcontainsmanyadvancedlanguagefeaturesasacompilerimple-
mentation, which our current implementation does not support.
We also exclude bugs ‚ÄúLang-2‚Äù and ‚ÄúTime-21‚Äù because they are no
longer reproducible due to deprecation. As a result, our dataset
includes four projects, 222 faults, as shown in Table 2.
Our evaluating metric is top-k where ùëòis 1, 3, 5, or 10. Top-k
countsthenumberoffaultsthataresuccessfullylocatedwithinthe
top k entries of the ranked suspicious candidate list. An existing
study[24]suggestedthatdeveloperswouldonlycheckafewentries
in the ranked list, which is consistent with the top-k metric. We
follow the measurement rules provided in a previous study [38].
Regarding thegranularity of faultlocalization, we chooseboth
statement-level and method-level granularity, the two most fre-
quentlyusedlevels.Asformethod-levelevaluation,wecalculate
the suspicious score of a method as the maximum suspicious score
ofitsstatements,e.g.themethod‚Äôsrankingisequaltoitshighest-
ranking statement.
5.3 Experiment Setup
5.3.1 Implementation. We have implemented our approach for
JavausingtheinstrumentationframeworkJavassist1.Theinstru-
mentationcausesJVMcrashesonsomeofthesubjectsinourex-
periments,andwedeemthatourapproachfailstolocalizethefault
for these subjects.
AsdescribedinSection4.6,weselectupto50testmethodsfor
tracing and limit the maximum number of lines to be less than 1.2
million for each trace. Upon building the graph, we limit the maxi-
mumnumberoflinestobelessthan1millionforallcompressed
traces. Please note that this selection only applies to our approach
but not any other baseline approach. Our implementation may still
1https://github.com/jboss-javassist/javassist
964
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:19:36 UTC from IEEE Xplore.  Restrictions apply. ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA Muhan Zeng, Yiqian Wu, Zhentao Ye, Yingfei Xiong, Xin Zhang, Lu Zhang
run out of memory after the selection on some subjects, and we
treat these cases as failures of our approach to localize the fault.
Our currentimplementationdoesnot support some advanced
Java features such as reflection and may miss data and control
dependenciesintroducedbythesefeatures.Thisincompletemod-
eling may reduce the performance, yet our approach still shows
significant advantages over existing approaches despite this imple-
mentation issue.
5.3.2 RQ1: Effectiveness of SmartFL. To test the effectiveness of
SmartFL,wecomparethe resultofSmartFLwithSBFL,represent-
ing coverage-based approaches, and MBFL, representing the ap-
proaches modeling semantics. We do not compare with angelicdebugging because there is no implementation scalable to largeprogramsasfarasweknow.Accordingtoexistingresearch[
38],
we select Ochiai [ 2] and DStar [ 33] from SBFL, Metallaxis [ 23] and
MUSE [21] from MBFL for comparison, and the performance data
of these approaches are obtained from an existing study [38].
5.3.3 RQ2:EfficiencyofSmartFL. Wecomparetherun-timecost
of SmartFL with the four baseline approaches described in RQ1.
AsFigure3shows,SmartFLconsistsoftwosteps:(a)tracingand
(b) modeling (including probabilistic inference). In the tracing step,
tracingeachtestcanberuninparallelexceptprojectTimebecause
the tests of Time do not support parallel execution. As a result, we
runtestsinparallelwith16threadsfortheotherthreeprojectsand
run tests with a single thread for Time. In the modeling step, we
run modeling and probabilistic inference in a single thread.
5.3.4 RQ3:InfluenceofDifferentFactorValues. Weassign0.5-0.5to
the factor values of insensitive operations and 0.01-0.99 to those of
sensitiveoperationsinourdefaultapproach.InthisRQweevaluate
the performance of other possible values. We evaluate 9 pairs of
factorvaluesforinsensitiveoperations:0 .1‚àí0.9,0.2‚àí0.8,...,0.9‚àí
0.1,and4pairsofthoseforsensitiveoperations:0 .001‚àí0.999,0.01‚àí
0.99,0.05‚àí0.95,0.1‚àí0.9. This experiment is taken only on project
Lang rather than the whole dataset to save time.
5.3.5 RQ4: Effectiveness of Different Components . We design two
ablationstudiestoevaluatetheeffectivenessoftwocomponents.In
the first study, we discard the modeling of unexecuted statements
described in Section 4.4 and compare the results on all 222 cases.In the second study, we discard loop compression described in
Section4.6.1andcomparetheresultsandtimecostonthemodeling
step withthe original version,on the casesthat do not triggerthe
limit of total trace lines when discarding loop compression. The
selection ensures all added traces are identical in both versions.
5.3.6 RQ5:CombiningwithotherTechniques. CombineFL[ 38]is
the state-of-the-art fault localization technique on statement-level.
We combine SmartFL with other methods under the framework of
CombineFL on all 222 cases. CombineFL requires a suspiciousness
scoreforeachstandalonetechniquetoperformlearning.InSmartFL,
the suspiciousness score of an ùëñùë°‚Ñé‚àíùëüùëéùëõùëòùëíùëëstatement is defined as
follow:
ùëÜùë¢ùë†ùëùùëñùëêùëñùëúùë¢ùë†ùëõùëíùë†ùë† (ùëñ)=ùëõ‚àíùëñ+1
ùëõ
Whereùëõis the number of all suspicious candidates.Table 3: Statement-level Performance
Project Technique Top-1 Top-3 Top-5 Top-10
TotalOchiai 11(5%) 64(29%) 86(39%) 118(53%)
DStar 12(5%) 65(29%) 86(39%) 117(53%)
Metallaxis 21(9%) 69(31%) 89(40%) 111(50%)
MUSE 17(8%) 35(15%) 45(20%) 50(23%)
SmartFL 47(21%) 80(36%) 97(44%) 118(53%)
Table 4: Sign Test Result
Method Positive Negative P-value
vs. Ochiai 87 580.01974
vs. DStar 88 590.02061
vs. Metallaxis 80 64 0.2112
vs. Muse 100 363.72e-08
Table 5: Method-level Performance
Project Technique Top-1 Top-3 Top-5 Top-10
TotalOchiai 73(33%) 138(62%) 156(70%) 176(79%)
DStar 75(34%) 140(63%) 155(70%) 177(80%)
Metallaxis 70(31%) 129(58%) 149(67%) 166(75%)
MUSE 44(20%) 71(32%) 83(37%) 91(41%)
SmartFL 96(43%) 136(61%) 155(70%) 176(79%)
5.4 Experiment Results
5.4.1 RQ1:EffectivenessofSmartFL. Table3showsthenumbers
andpercentagesoffaultslocalizedbydifferentapproachesatstatement-
level. Here, we describe a fault is successfully localized by an ap-
proachiftheactualfaultpositioncanbefoundinthetopkprogram
elements returned by the approach. We display the results with
differentvaluesofkinthetop-kmetric.Thebestresultsundereach
category are in bold fonts. On all the 222 faults, SmartFL performs
best among all values of k. At top-1, 3, and 5, SmartFL improves
114%, 16%, and 9% over the second-best approach, respectively. At
top-10, SmartFL has the same performance as Ochiai.
We also perform a sign test on each pair of techniques consider-
ingfaultswhereatleastonetechniquehasatop-10resultonit,and
theresultisshowninTable4.Weconfinethetesttothesefaults
becauseadifferencebetweenrank100and1000wouldnotmake
a great difference in actual use cases. The result implies that our
methodsignificantlyoutperformsOchiai,DStar,andMuse,while
stillhavingmorepositivethannegativecasescomparedwithMetal-laxis.Still,thenegativecasesinthesigntestshowthatourmethod
could be complementary to others, which is further discussed in
RQ5.
Table5showstheperformanceofeachapproachatmethodlevel.
SmartFL performs better than Metallaxis and MUSE using all top-k
metrics. SmartFL has an advantage over Ochiai and Dstar at top-1
and roughly the same effect as they have at top-3,5 and 10.
965
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:19:36 UTC from IEEE Xplore.  Restrictions apply. Fault Localization via Efficient Probabilistic Modeling of Program Semantics ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA
Table 6: Average Time Consumption of each Technique (in
seconds, to 2 digits of precision)
Technique Average Lang Math Chart Time CPU
Ochiai 64 26 86 44 85
2.40GHzDStar 64 26 86 44 85
Metallaxis 3500 270 3000 5400 12000
MUSE 3500 270 3000 5400 12000
SmartFL 210 511402808302.10GHz
Table7:DifferentModerateFactorValuesforInsensitiveOp-
erations
ValueTotalTop-1 Top-3 Top-5 Top-10
0.1-0.9 13319(30%) 32(50%) 37(58%) 45(70%)
0.2-0.8 13821(33%) 35(55%) 39(61%) 43(67%)
0.3-0.7 13921(33%) 35(55%) 39(61%) 44(69%)
0.4-0.6 14121(33%) 35(55%) 39(61%) 46(72%)
0.5-0.5 14021(33%) 34(53%) 39(61%) 46(72%)
0.6-0.4 14121(33%) 34(53%) 39(61%) 47(73%)
0.7-0.3 14222(34%) 34(53%) 38(59%) 48(75%)
0.8-0.2 13922(33%) 32(50%) 39(61%) 46(72%)
0.9-0.1 13822(33%) 32(50%) 38(59%) 46(72%)
SmartFLfocusesonstatement-levelfaultlocalizationandSmartFL
performs better than all other techniques on statement-level. At
method-level, SmartFL still significantly outperforms others interms of Top-1 accuracy. The above results demonstrate the ef-
fectiveness of SmartFL.
5.4.2 Efficiency of SmartFL. Table 6 shows the time costs of all
techniques. The performance data of the baselines are obtained
fromanexistingstudy byZouetal .[38].The executiontimeisnot
directly comparable because the two experiments are on different
hardware platforms. However, we cannot reproduce the experi-
mentsbyZouetal .[38]becausetheimplementationonlysupports
an old version of Defects4J, which is no longer available. Neverthe-
less,thehardwareplatformsforthetwosetsofexperimentshave
CPUswith similar lockspeed2,and thussignificanttime difference
still matters.
AsmentionedinSection5.3,weruntestswithasinglethread
on benchmark Time so the time cost for Time is much longer than
thoseofotherprojects.TheaveragetimeofSmartFLis210seconds,
whichisanorderofmagnitudesmallerthanMBFLmethods.The
resultshowsSmartFLmodelsthesemanticsoftheprograminan
efficient way.
2IntelXeonE5-2640v4@2.40GHz-12cores([ 38])vs.IntelXeonGold6230@2.10GHz-20
cores (ours)Table8:DifferentVerylow/VeryhighFactorValuesforSen-
sitive Operations
Value TotalTop-1 Top-3 Top-5 Top-10
0.001-0.999 13922(34%) 34(53%) 37(58%) 46(72%)
0.01-0.99 14021(33%) 34(53%) 39(61%) 46(72%)
0.05-0.95 14421(33%) 35(55%) 41(64%) 47(73%)
0.1-0.9 14421(33%) 33(52%) 42(66%) 48(75%)
Table 9: Effect of Modeling Unexecuted Statements.
Technique Top-1 Top-3 Top-5 Top-10
Origin 47 80 97 118
w/o Unexecuted 48 80 95 118
Table 10: Effect of Loop Compression (on 93 selected cases).
Technique TimeTop-1 Top-3 Top-5 Top-10
Origin 30s33 50 57 65
w/o Compression 49s31 49 56 64
5.4.3 RQ3: Influence of Different Factor Values. We re-run our ap-
proach on project Lang with different factor parameters (moderate,
very low, and very high) for both sensitive and insensitive state-
ments. The result is shown in Table 7 and Table 8.
In the first column, the former number denotes the factor value
of getting the correct result when receiving wrong sources and the
latter number denotes the factor value of getting the wrong result.
Wecanseethatthechoiceofparametershasonlyasmallimpact
on the results. This suggests that our model is robust with respect
to different parameters, and could still work without fine-tuning.
5.4.4 RQ4: Effectiveness of Different Components. We perform sev-
eral ablation studies to evaluate the effect of different components
of our approach.
Table 9 shows the effect of modeling unexecuted statements.
Without considering the effect of unexecuted statements, the top-1
and top-5 results receive a small change. In general, the effect ofmodeling unexecuted statements is not significant. However, we
notice that the results on 63 out of 222 cases changed, and particu-
larly, ‚ÄúLang 53‚Äù and ‚ÄúMath 79‚Äù failed when unexecuted statements
are not modeled. The two newly introduced failures suggest some
Defects4J cases can be successfully localized by SmartFL only with
the help of modeling unexecuted statements.
Following the rules described in Section 5.3.5, we select 93 cases
thatdonotexceedthelimitoftotaltracelinesinthebenchmark.
Table 10 shows that the default approach performs slightly better,
whichsuggestsremovingredundantsequencesfromtracescould
effectively reduce execution time while preserving effectiveness.
966
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:19:36 UTC from IEEE Xplore.  Restrictions apply. ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA Muhan Zeng, Yiqian Wu, Zhentao Ye, Yingfei Xiong, Xin Zhang, Lu Zhang
Table 11: Integrating SmartFL with CombineFL
Technique Top-1 Top-3 Top-5 Top-10
CombineFL Level-2 32(14%) 93(42%) 116(52%) 144(64%)
SmartFL with Level-2 58(26%) 102(47%) 124(56%) 144(64%)
CombineFL Level-4 45(20%) 95(43%) 121(55%) 143(64%)
SmartFL with Level-4 53(24%) 97(44%) 127(57%) 149(67%)
5.4.5 RQ5:CombiningwithotherTechniques. CombineFLisatech-
nique for combining different fault localization methods. Com-
bineFL has four levels, each consists of standalone techniques with
timecostunderacertainlevel.Level-2containsonlylightweight
methodsthatrequireminutestorun,includinghistory-based,stack
trace-based,IR-based,slicing,andSBFLmethods.Comparedwith
level-2, level-4 further includes predicates switching and MBFL,
which usually requires more than an hour to localize the faults.
By excludingheavy-weight approachesand including SmartFL
in CombineFL, the time cost is greatly reduced as SmartFL only
requires minutes to localize one fault. We also combine SmartFL
with Level-4 CombineFL to show our full potential. The result
is shown in Table 11. The top-1 accuracy raises to 58 (26%) byreplacing MBFL methods with SmartFL, while combining with
Level-4resultsinbetterTop-10accuracy.WenoticethatcombiningmoretechniquestoSmartFLwithCombineFLLevel-2maydropTop-
1 accuracy. The reason could be that SmartFL‚Äôs result is correlated
to MBFL‚Äôs result butstill has a difference. The result also showsa
new learning method may better combine SmartFL and MBFL, and
calls for further research.
6 RELATED WORK
Fault localization has been intensively studied during the pastdecades.Hereweleaveafullsummaryoffaultlocalizationtore-
spectivelysurveys[ 4,28,34]andempiricalstudies[ 38],anddiscuss
only the most related work.
6.1 Probabilistic Approaches
Fault localization is inherently a probabilistic analysis process, and
many existing approaches resort to probabilistic modeling. Similar
to our approach, these modeling approaches also treat the sample
space as all possible faultsor all possible fault locations and try to
identify the element that has the highest conditional probability
tobefaultybasedontheobservedtestresults.Differentfromour
approach that extract the probabilities from the semantics of theprogram, most probabilistic approaches either consider only the
coverageanddonotmodelthesemanticsoftheprogram[ 10,27],
or learn the probabilities from test executions [5, 9].
TheonlyexceptionisXuetal . [35]‚Äôsapproach.Thisapproach
solvesadifferentproblem,namelyinteractivefaultlocalization:how
to support the developer when he faces one failing test. Similar to
our approach, their approach also uses probabilistic modeling and
introducesBernoulliprobabilisticvariablestorepresentwhether
the runtime values and statements are faulty or not. Our approachis also inspired by their work, but there are multiple fundamen-tal differences: (1) To easily integrate the developers‚Äô feedback,
their approach uses two-level reasoning, first calculating the faulty
probabilitiesoftheruntimevaluesandthencalculatingthefaulty
probabilities of the statement. As a result, different test executions
are isolated and thus their approach cannot support fault local-ization from multiple tests. (2) Their approach does not consider
the effect of the unexecuted branches. (3) Their approach does not
select nor compress test executions.
Difference (1) is essential in our problem, as the passing tests
provide critical information for fault localization and cannot be
ignored.Inthe examplein1,withoutthe passingtests,wecannot
localizecorrectly.Differences(2)and(3)areevaluatedinRQ4,which
indicates that removing them leads to a performance drop.
6.2 Spectrum-based Fault Localization
Asmentionedbefore,themaintypeofcoverage-basedfaultlocaliza-
tion is SBFL approaches, which calculates the suspicious scores of
program elements based on the numbers of pass/fail tests covering
the element using different formulas [1, 12, 22].
As mentioned, coverage is only one of the four conditions for a
testtofailonafault,andthusthecoverage-basedapproachesdo
not consider the latter three conditions. To overcome this problem,
some existing approaches combine SBFL with program slicing [ 14,
20,29],inthesensethatonlythestatementsintheslicecanproduce
and propagate the faults. For example, Mao et al . [20]proposed
SSFL(slice-basedstatisticalfaultlocalization).Bycalculatingthe
suspiciousnessscoreonanapproximatedynamicbackwardslice,
SSFL significantly boosts all 16 formulas of SBFL. However, slicing
onlyreveals thepossibilitybutnot theprobabilitythata program
elementproducesorpropagatesfault,andthusisaveryinaccurate
modeling of semantics.
6.3 Approaches Modeling Semantics
AswehavecarefullydiscussedinSections1and2,MBFL[ 21,23]
and angelicdebugging [ 6,7] arethe two main familiesthat model
semantics for fault localization, but both have scalability issues
due to their precise modeling of the semantics. Our evaluation also
shows that our approach is about 10X faster than MBFL and is
much more effective.
6.4 Combination Approaches
Multiple approaches try to combine existing approaches or dif-
ferentinformationsources.XuanandMonperrus [36]proposeda
learning-to-rankapproachtointegratethesuspiciousnessscoresof
25 existing SBFL formulae. Zou et al . [38]further extended this ap-
proachtointegratethesuspiciousnessscoresproducedbydifferent
familiesoffaultlocalizationfamilies.Ourapproachcouldalsobe
integratedusingtheseapproaches.Asourevaluationshows,ourap-
proach could significantly boost the performance of the combined
approaches.
Otherapproachestrytousemachinelearningtechniquestocom-
binedifferentinformationsources.Forexample,SohnandYoo [31]
use the learning-to-rank technique to combine the suspiciousness
scores of existing SBFL formulae, code complexity metrics, and
codehistorymetrics;Lietal . [18]useneuralnetworktocombine
967
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:19:36 UTC from IEEE Xplore.  Restrictions apply. Fault Localization via Efficient Probabilistic Modeling of Program Semantics ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA
suspiciousness scores of SBFL and MBFL, code complexity metrics,
andtextsimilaritymetrics;K√º√ß√ºketal . [17]usecausalinference
techniquesandmachinelearningtointegratepredicateoutcomes
and runtime values; Lou et al . [19]use neural network to embed
boththesyntaxoftheprogramandthecoverageinformation.How-
ever,noneoftheseapproachesareabletointegratethesemantic
information, which is the focus of this paper.
7 CONCLUSION
This paper proposes a novel fault-localization method based on
probabilistic graph model. Specifically, we utilize semantic infor-
mation of different statements, while combining both dynamic and
staticinformationintoourmodel.Weconductanexperimenton
a real-world dataset, Defects4J. Our technique is evaluated to be
complementary to existingtechniques as it couldfurther improve
state-of-the-artby combining with existing techniques.
To facilitate research, our tool and the fault localization data are
available at https://github.com/toledosakasa/SMARTFL.
ACKNOWLEDGMENTS
We acknowledge Jingjing Liang and Daming Zou for sharing their
experiment data [ 38]. This work is sponsored by National Natural
Science Foundation of China under Grant No. 61922003 and No.
62172017.
REFERENCES
[1]Rui Abreu, Peter Zoeteweij, and Arjan JC Van Gemund. 2006. An evaluation
of similarity coefficients for software fault localization. In 2006 12th Pacific Rim
International Symposium on Dependable Computing (PRDC‚Äô06). IEEE, 39‚Äì46.
[2]RuiAbreu,PeterZoeteweij,andArjanJCVanGemund.2007. Ontheaccuracyof
spectrum-based fault localization. In Testing: Academic and industrial conference
practice and research techniques-MUTATION (TAICPART-MUTATION 2007) . IEEE,
89‚Äì98.
[3]Alfred V. Aho, Ravi Sethi, and Jeffrey D. Ullman. 1986. Compilers: Principles,
Techniques,andTools. Addison-Wesley. https://www.worldcat.org/oclc/12285707
[4]Mohammad Amin Alipour. 2012. Automated fault localization techniques: a
survey.Oregon State University 54, 3 (2012).
[5]GeorgeK.Baah,AndyPodgurski,andMaryJeanHarrold.2010. TheProbabilistic
Program Dependence Graph and Its Application to Fault Diagnosis. IEEE Trans.
Software Eng. 36, 4 (2010), 528‚Äì545. https://doi.org/10.1109/TSE.2009.87
[6]Satish Chandra, Emina Torlak, Shaon Barman, and Rastislav Bodik. 2011. An-
gelicdebugging.In Proceedingsofthe33rdInternationalConferenceonSoftware
Engineering. 121‚Äì130.
[7]MariaChristakis,MatthiasHeizmann,MuhammadNumairMansur,Christian
Schilling,andValentinW√ºstholz.2019. SemanticFaultLocalizationandSuspi-
ciousnessRanking.In ToolsandAlgorithmsfor theConstructionandAnalysisof
Systems - 25th International Conference, TACAS 2019, Held as Part of the Euro-
pean Joint Conferences on Theory and Practice of Software, ETAPS 2019, Prague,Czech Republic, April 6-11, 2019, Proceedings, Part I (Lecture Notes in ComputerScience, Vol. 11427), Tom√°s Vojnar and Lijun Zhang (Eds.). Springer, 226‚Äì243.
https://doi.org/10.1007/978-3-030-17462-0_13
[8]Keith D Cooper, Timothy J Harvey, and Ken Kennedy. 2001. A simple, fast
dominance algorithm. Software Practice & Experience 4, 1-10 (2001), 1‚Äì8.
[9]LauraDietz,ValentinDallmeier,AndreasZeller,andTobiasScheffer.2009. Lo-
calizing Bugs in Program Executions with Graphical Models. In Advances in
Neural Information Processing Systems 22: 23rd Annual Conference on Neural
InformationProcessingSystems2009.Proceedingsofameetingheld7-10Decem-
ber 2009, Vancouver, British Columbia, Canada, Yoshua Bengio, Dale Schuur-mans, John D. Lafferty, Christopher K. I. Williams, and Aron Culotta (Eds.).Curran Associates, Inc., 468‚Äì476. https://proceedings.neurips.cc/paper/2009/
hash/f64eac11f2cd8f0efa196f8ad173178e-Abstract.html
[10]Alberto Gonz√°lez-Sanchez, Rui Abreu, Hans-Gerhard Gro√ü, and Arjan J. C. van
Gemund. 2011. Spectrum-Based Sequential Diagnosis. In Proceedings of the
Twenty-Fifth AAAI Conference on Artificial Intelligence, AAAI 2011, San Francisco,
California, USA, August 7-11, 2011, Wolfram Burgard and Dan Roth (Eds.). AAAI
Press. http://www.aaai.org/ocs/index.php/AAAI/AAAI11/paper/view/3565[11]Jiajun Jiang, Ran Wang, Yingfei Xiong, Xiangping Chen, and Lu Zhang. 2019.
Combiningspectrum-basedfaultlocalizationandstatisticaldebugging:anempir-icalstudy.In 201934thIEEE/ACMInternationalConferenceonAutomatedSoftware
Engineering (ASE). IEEE, 502‚Äì514.
[12]JamesAJonesand Mary JeanHarrold.2005. Empiricalevaluationofthetaran-
tula automatic fault-localization technique. In Proceedings of the 20th IEEE/ACM
international Conference on Automated software engineering. 273‚Äì282.
[13]JamesAJones,MaryJeanHarrold,andJohnStasko.2002. Visualizationoftest
information to assist fault localization. In Proceedings of the 24th International
Conference on Software Engineering. ICSE 2002. IEEE, 467‚Äì477.
[14]XiaolinJu,ShujuanJiang,XiangChen,XingyaWang,YanmeiZhang,andHeling
Cao. 2014. HSFal: Effective fault localization using hybrid spectrum of full slices
and execution slices. Journal of Systems and Software 90 (2014), 3‚Äì17.
[15]Ren√©Just,DarioushJalali,andMichaelDErnst.2014. Defects4J:Adatabaseofex-istingfaultstoenablecontrolledtestingstudiesforJavaprograms.In Proceedings
of the 2014 International Symposium on Software Testing and Analysis. 437‚Äì440.
[16]Frank R Kschischang, Brendan J Frey, and H-A Loeliger. 2001. Factor graphs and
the sum-product algorithm. IEEE Transactions on information theory 47, 2 (2001),
498‚Äì519.
[17]Yigit K√º√ß√ºk, Tim A. D. Henderson, and Andy Podgurski. 2021. Improving Fault
Localization by Integrating Value and Predicate Based Causal Inference Tech-
niques. In 43rd IEEE/ACM International Conference on Software Engineering, ICSE
2021, Madrid, Spain, 22-30 May 2021. IEEE, 649‚Äì660. https://doi.org/10.1109/
ICSE43902.2021.00066
[18]XiaLi,WeiLi,YuqunZhang,andLingmingZhang.2019. DeepFL:integrating
multiple fault diagnosis dimensions for deep fault localization. In Proceedings of
the28thACMSIGSOFTInternationalSymposiumonSoftwareTestingandAnalysis,
ISSTA 2019, Beijing, China, July 15-19, 2019, Dongmei Zhang and Anders M√∏ller
(Eds.). ACM, 169‚Äì180. https://doi.org/10.1145/3293882.3330574
[19]Yiling Lou, Qihao Zhu, Jinhao Dong, Xia Li, Zeyu Sun, Dan Hao, Lu Zhang, and
Lingming Zhang. 2021. Boosting coverage-based fault localization via graph-
basedrepresentationlearning.In ESEC/FSE‚Äô21:29thACMJointEuropeanSoftware
EngineeringConferenceandSymposiumontheFoundationsofSoftwareEngineering,
Athens, Greece, August 23-28, 2021, Diomidis Spinellis, Georgios Gousios, Marsha
Chechik,andMassimilianoDiPenta(Eds.).ACM,664‚Äì676. https://doi.org/10.
1145/3468264.3468580
[20]Xiaoguang Mao, Yan Lei, Ziying Dai, Yuhua Qi, and Chengsong Wang. 2014.
Slice-basedstatisticalfaultlocalization. JournalofSystemsandSoftware 89(2014),
51‚Äì62.
[21]Seokhyeon Moon, Yunho Kim, Moonzoo Kim, and Shin Yoo. 2014. Ask themutants:Mutatingfaultyprogramsforfaultlocalization.In 2014IEEESeventh
International Conference on Software Testing, Verification and Validation. IEEE,
153‚Äì162.
[22]LeeNaish,HuaJieLee,andKotagiriRamamohanarao.2011. Amodelforspectra-basedsoftwarediagnosis. ACMTransactionsonsoftwareengineeringandmethod-
ology (TOSEM) 20, 3 (2011), 1‚Äì32.
[23]MikePapadakisandYvesLeTraon.2015. Metallaxis-FL:mutation-basedfault
localization. Software Testing, Verification and Reliability 25, 5-7 (2015), 605‚Äì628.
[24]Chris Parnin and Alessandro Orso. 2011. Are automated debugging techniques
actuallyhelpingprogrammers?.In Proceedingsofthe2011internationalsymposium
on software testing and analysis. 199‚Äì209.
[25]JudeaPearl.1982. ReverendBayesonInferenceEngines:ADistributedHierarchi-
calApproach.In ProceedingsoftheNationalConferenceonArtificialIntelligence,
Pittsburgh,PA,USA,August18-20,1982,DavidL.Waltz(Ed.).AAAIPress,133‚Äì136.
http://www.aaai.org/Library/AAAI/1982/aaai82-032.php
[26]Spencer Pearson, Jos√© Campos, Ren√© Just, Gordon Fraser, Rui Abreu, Michael D
Ernst, Deric Pang, and Benjamin Keller. 2016. Evaluating & improving fault
localizationtechniques. UniversityofWashingtonDepartmentofComputerScience
and Engineering, Seattle, WA, USA, Tech. Rep. UW-CSE-16-08-03 (2016), 27.
[27]Alexandre Perez, Rui Abreu, and Arie van Deursen. 2021. A Theoretical and
Empirical Analysis of Program Spectra Diagnosability. IEEE Trans. Software Eng.
47, 2 (2021), 412‚Äì431. https://doi.org/10.1109/TSE.2019.2895640
[28]Alexandre Perez, Rui Abreu, and Eric Wong. 2014. A survey on fault localization
techniques. (2014).
[29]Sofia Reis, Rui Abreu, and Marcelo d‚ÄôAmorim. 2019. Demystifying the Com-binationof DynamicSlicingand Spectrum-basedFault Localization..In IJCAI.
4760‚Äì4766.
[30]David Schuler and Andreas Zeller. 2011. Assessing Oracle Quality with Checked
Coverage.In FourthIEEEInternationalConferenceonSoftwareTesting,Verification
and Validation, ICST 2011, Berlin, Germany, March 21-25, 2011. IEEE Computer
Society, 90‚Äì99. https://doi.org/10.1109/ICST.2011.32
[31]Jeongju Sohn and Shin Yoo. 2017. FLUCCS: using code and change metrics to
improve fault localization. In Proceedings of the 26th ACM SIGSOFT International
SymposiumonSoftwareTestingandAnalysis,SantaBarbara,CA,USA,July10-
14,2017,TevfikBultanandKoushikSen(Eds.).ACM,273‚Äì283. https://doi.org/
10.1145/3092703.3092717
[32]Jeffrey M. Voas. 1992. PIE: A dynamic failure-based technique. IEEE Transactions
on software Engineering 18, 8 (1992), 717.
968
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:19:36 UTC from IEEE Xplore.  Restrictions apply. ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA Muhan Zeng, Yiqian Wu, Zhentao Ye, Yingfei Xiong, Xin Zhang, Lu Zhang
[33]WEricWong,VidrohaDebroy,RuizhiGao,andYihaoLi.2013. TheDStarmethod
for effective software fault localization. IEEE Transactions on Reliability 63, 1
(2013), 290‚Äì308.
[34]W Eric Wong, Ruizhi Gao, Yihao Li, Rui Abreu, and Franz Wotawa. 2016. A
survey on software fault localization. IEEE Transactions on Software Engineering
42, 8 (2016), 707‚Äì740.
[35]Z. Xu, S. Ma, X. Zhang, S. Zhu, and B. Xu. 2018. Debugging with Intelligence
via Probabilistic Inference. In 2018 IEEE/ACM 40th International Conference on
SoftwareEngineering(ICSE).1171‚Äì1181. https://doi.org/10.1145/3180155.3180237
[36]Jifeng Xuan and Martin Monperrus. 2014. Learning to combine multiple ranking
metrics for fault localization. In Software Maintenance and Evolution (ICSME),2014 IEEE International Conference on. IEEE, 191‚Äì200.
[37]YuchengZhangandAliMesbah.2015.Assertionsarestronglycorrelatedwithtest
suiteeffectiveness.In Proceedingsofthe201510thJointMeetingonFoundations
of Software Engineering, ESEC/FSE 2015, Bergamo, Italy, August 30 - September
4, 2015, Elisabetta Di Nitto, Mark Harman, and Patrick Heymans (Eds.). ACM,
214‚Äì224. https://doi.org/10.1145/2786805.2786858
[38]D.Zou,J.Liang,Y.Xiong,M.D.Ernst,andL.Zhang.2021. AnEmpiricalStudy
of Fault Localization Families and Their Combinations. IEEE Transactions on
Software Engineering 47, 2 (2021), 332‚Äì347. https://doi.org/10.1109/TSE.2019.
2892102
969
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:19:36 UTC from IEEE Xplore.  Restrictions apply. 