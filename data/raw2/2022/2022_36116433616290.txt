Engineering a FormallyVerified AutomatedBugFinder
Arthur Correnson
DominicSteinhöfel
arthur.correnson@cispa.de
dominic.steinhoefel@cispa.de
CISPA Helmholtz Center forInformationSecurity
Saarbrücken, Germany
ABSTRACT
Symbolic execution is a program analysis technique executing pro-
grams with symbolic instead of concrete inputs. This principle
allows for exploring many program paths at once. Despite its wide
adoption—inparticularforprogram testing–littleeﬀortwasdedi-
cated to studying the semantic foundations of symbolic execution.
Without these foundations, critical questions regarding the cor-
rectness of symbolic executors cannot be satisfyingly answered:
Canareportedbugbereproduced,orisita falsepositive (sound-
ness)? Can we be sure to ﬁnd all bugsif we let the testing tool
run long enough (completeness)? This paper presents a systematic
approachforengineeringprovablysoundandcompletesymbolic
execution-based bug ﬁnders by relating a programming language’s
operational semantics with a symbolic semantics. In contrast to
priorworkonsymbolicexecutionsemantics,weaddressthecor-
rectness of critical implementation details of symbolic bug ﬁnders,
includingthesearchstrategyandtheroleofconstraintsolversto
prune the search space. We showcase our approach by implement-
ing WiSE, a prototype of a veriﬁed bug ﬁnder for an imperative
language, in the Coq proof assistant and proving it sound and com-
plete.WedemonstratethatthedesignprinciplesofWiSEsurvive
outsidetheecosystemofinteractiveproofassistantsby(1)automat-
icallyextractinganOCamlimplementationand(2)transforming
WiSEtoPyWiSE,afunctionally equivalentPython version.
CCSCONCEPTS
•Theory of computation →Program veriﬁcation ;Operational
semantics ;Higherorderlogic; Automatedreasoning ;•Softwareand
its engineering →Semantics ;Software testing and debugging ;
Formalsoftwareveriﬁcation ;Softwareveriﬁcation ;Automated
staticanalysis .
KEYWORDS
Symbolic Execution, Testing, Program Veriﬁcation, Symbolic Se-
mantics,ProofAssistants
ACM Reference Format:
ArthurCorrensonandDominicSteinhöfel.2023.EngineeringaFormally
VeriﬁedAutomatedBugFinder.In Proceedingsofthe31stACMJointEuropean
ESEC/FSE ’23, December 3–9, 2023, San Francisco, CA,USA
©2023 Copyright heldby theowner/author(s).
ACM ISBN 979-8-4007-0327-0/23/12.
https://doi.org/10.1145/3611643.3616290Software Engineering Conference and Symposium on the Foundations of Soft-
wareEngineering(ESEC/FSE’23),December3–9,2023,SanFrancisco,CA,USA.
ACM,NewYork,NY,USA, 12pages.https://doi.org/10.1145/3611643.3616290
INTRODUCTION
Itisnowtwodecades sinceitwas pointed out thatprogram
testing may convincingly demonstratethe presenceofbugs,
butcan neverdemonstratetheirabsence. Afterquoting this
well-publicized remark devoutly, the software engineer returns
to the order ofthe day andcontinues toreﬁnehistesting
strategies, justlikethe alchemistofyore, whocontinued to
reﬁnehischrysocosmic puriﬁcations.
E.W.Dijkstra , 1988[14]
A bridge that works ﬁne for a year but collapses during a windy
day is considered a failure. A program that works ﬁne for a year
but crashes for a certain input is considered buggy. This ridiculous
analogy reﬂects the reality of software engineering: While civil
engineers carefully identify loads and associated stresses on the
structures they build and create their designs accordingly, prevent-
ing tragic crashes upfront, “bugs” in software are most frequently
reportedby usersonlyafterdeployment[ 30].However,software
engineers are in a fortunate position: They can stress-test the ﬁnal
productbefore it is shipped to users. This becomes an opportu-
nityonlyifprogrammerspossessadequateveriﬁcationtools.The
predominant veriﬁcation discipline today is testing, which aims
toﬁndbugsthatare actionable inthesensethatrunningthepro-
gramundertestwithan inputprovidedbythetestingtoolresults
inanerrorstate.Forexample, evolutionarygrayboxfuzzers (such
asAFL++[ 15])mutate inputsfrom an initialpopulationand add
mutants covering new parts in the program. While modern fuzzers
workexceptionallywellinmanycases,theeﬀectivenessofevolu-
tionary fuzzersstronglydepends onthe quality of theinitialseed
inputs[27]. Furthermore, they struggle tocovercode guardedwith
complex constraints. Considerthe Python program
ifx == hash((y, z)): fail()
Findingatripleofvaluessatisfyingthe ifconditionrandomlyor
bymutatingpreviousinputsisextremelydiﬃcult.Indeed,Bundt
et al. [9] demonstrated that graybox fuzzers are “mostly useless”
for certain bugs. However, they state that integrating symbolic
execution with graybox fuzzers to so-called hybrid fuzzers ishighly
eﬀective,aresult alsoconﬁrmedbyotherstudies (e.g.,[ 8]).
Symbolic Execution (SE) builds on the principle of declaring
some (or all) inputs to a program to be symbolic. While concrete
execution maintains states mapping variables to values, SEuses
symbolicstates consistingofa pathcondition andasymbolicstore.
This work is licensed under a Creative Commons Attribution-
NonCommercial-ShareAlike 4.0 InternationalLicense.
1165
ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA Arthur CorrensonandDominic Steinhöfel
Atbranchingpoints such as the ifstatement fromabove, SEgener-
atesmultiplesuccessorstatesdistinguishedbydiﬀerentconstraints
added to their path condition. As usual, assignments update the
symbolic store, which can map to symbolic values. SEwas con-
ceived almost simultaneously as a bug ﬁnding [ 24] and program
proving technique [ 10] and is still actively used in both areas. It is
more popular in testing, though, due to its precise nature: Under
idealassumptions ,SEyieldsnofalsepositivesandcanbeusedin
automated testing campaigns; on the other hand, program proving
withSErequires expensive auxiliary speciﬁcations [ 4].
So,whatarethese“idealassumptions?”First, SEisawhitebox
technique:Itrequires accessto the sourcecode ofthe testedpro-
gram, interpreting its structure to drive the search for bugs. While
thispermitsbetterresults,implementingasymbolicexecutorre-
quires a precise understanding of the semantics of the targeted
language.Forexample,asymbolicexecutorforPythonprograms
mustrespectPython’sinteger ﬂoordivision semantics:Thedivision
expression x // ycorresponds to floor(x / y) , where “ /” is
division on reals. Other interpretations can result in false positives
(spuriousbugs) or false negative (missedbugs). In the program
ifx // y == - 2: fail()
a wrong interpretation of integer division might lead a symbolic
bug ﬁnder to believe that /u1D465=−5, /u1D466.alt=2triggersfail(). However,
in Python, the result of -5 // 2 is−3, while in other languages
such as Java itevaluates to −2.
Second,SEdiscardsunreachableerroneousstatesbychecking
whether their path conditions are satisﬁable. In our examples from
above, it must decide if “ x == hash((y, z)) ” or “x // y == -2 ”
are consistent with the previously collected constraints. To that
end, theSEengines use constraint solvers to determine whether
a set of constraints is satisﬁable ( SAT) or unsatisﬁable ( UNSAT).
However,insteadofreturning SATorUNSAT,solversfrequently
timeoutprovidingnoanswers;inthatcase,blindlyreportingabug
could result ina false positive.
Consequently,an SEengineismorediﬃculttoimplementcor-
rectlythanafuzzer.Whilethesemanticsandcorrectnessof SEhave
beenstudiedindiﬀerentcontexts[ 13,25,28,33],thecorrectness
of symbolic bug ﬁnders remains an open research topic. In particu-
lar,toourknowledge,thereexistsnorigorousdeﬁnitionofwhat
constitutes atrustworthysymbolic bugﬁnder.
Themaincorrectnesscriterionfortestingtoolsisthe“soundness
ofbugs”[ 18]:Ifthetoolanswers Isthereabuginmyprogram? with
yes, there must exist a bug witness (an actionable input). We call
thispropertysoundnessfortesting( T-soundness ).Fuzztesters (short
fuzzers)generateinputsthattheyfeedtotheprogramundertest
and report a bug if the program crashes. Such tools are T-sound by
construction.However,T-soundnessaloneisaninsuﬃcientquality
measureforbugﬁnders.Indeed,atesterneverreporting anybugis
triviallyT-sound.Thus,the converseofsoundnessisanadditionally
desirableproperty:Ifabugwitnessexists,atestershouldeventually
answerthequestion Isthereabuginmyprogram? withyes.This
property,whichwenamecompletenessfortesting( T-completeness ),
is generally out of reach for fuzzers. The best option is to estimate
theresidual risk that an ongoing fuzzing campaign would discover
an errorif itonly ranfor abit longer [ 7].Contrary, building a T-sound and T-complete symbolic executor
ispossible.Inthispaper,weproposeageneralapproachtobuild-
ing provably sound and complete bug ﬁnders based on symbolic
execution.Weimplementedaprototypicalbugﬁnderbasedonthis
approachintheCoqproofassistanttogetherwithanend-to-end
proofofitscorrectness.Tothebestofourknowledge,oursisthe
ﬁrst endeavor to explicitly specify the meaning of correctness in the
contextofsymbolicbugﬁnders inaproofassistantandtouse formal
veriﬁcationtechniques to prove the correctness of abugﬁnder.
Research Questions. Precisely, we answer the following main
questions:(1) Whatconstitutesareliabletestingtool? ,and(2)How
can we engineer such a tool? These questions cannot be answered
experimentally. FollowingtheterminologyofShaw[ 31],theybe-
longtothecategories“MethodforEvaluation”(Question (1))and
“Method/Means of Development” (Question (2)) of software en-
gineering research questions. Our answer to Question (1)is the
precise deﬁnition of T-soundness and T-completeness. Addressing
Question (2), we explain the characteristics of a T-sound and T-
complete bug ﬁnder and expound a methodology to implement
suchatool.Followingthismethodology,weimplementedSE-based
testingtoolsinCoqandPython.FortheCoqprototype,wederived
aformal,mechanizedcorrectness proof.
RelatedWork. KapusandCadar[ 22]combinecompilertesting
techniques and diﬀerent oracles to test three symbolic bug ﬁnders.
They reported 20 distinct bugs “exposing a variety of important
errors”—e.g.,relatedtodivision.Thisistheonlyworkonthecor-
rectnessof(symbolic)bugﬁnders(Question (1))weareawareof.
Otherworkmainlystudieshow SEcanbeappliedforautomated
testing. The strongest oracle used by Kapus and Cadar, the “output
oracle,”comparestheresultsofaconcreteexecutionandasymbolic
onefollowingthesamepath.Thisoracleonlyworksiftheinitial
path condition uniquely describes the inputs used for concrete
execution, but is, at the same time, “obfuscated” to prevent the ex-
ecutorfromdroppingto“concretemode.”Whentesting SEengines
with less constrained inputs, such that multiple paths are explored,
KapusandCadarusecoarseroracles.Incontrast,wedevelopeda
veriﬁedsymbolic bug ﬁnder based on carefully designed semantic
foundationsinresponsetoQuestion (2).Likely,KapusandCadar
wouldhavefoundmorebugswheninvestingevenmoreworkon
testcasesandoracles;ourbugﬁnderisguaranteedtobebug-free.
Informalprogramveriﬁcation,itismuchmorecommontoad-
dress the soundness of veriﬁcation tools and their underlying theo-
reticalunderpinnings.Thegoalofformalveriﬁcationisnottoshow
the presence but prove the absence of bugs. Consequently, the main
correctness criterion is the soundness of proofs (P-soundness): If a
veriﬁer answers Is my program safe to execute? withyes, then there
existsaproofoftheprogram’scorrectness.AswithT-completeness,
P-completenessistheconverseofP-soundness.Sincecheckinga
complexprogramproofisarguablymorecomplexthenchecking
whether an input causes a bug, the formal veriﬁcation community
put signiﬁcant eﬀort into justifying their tools and foundations.
For example, Abstract Interpretation (AI) [12] is a mathematical
framework for designing and implementing correct static analy-
sis. Following the AIframework, Jourdan et al. [ 21] proved the
soundness of an abstract interpreter for C programs in the Coq
proof assistant. This project is strongly related to the development
1166EngineeringaFormallyVerifiedAutomatedBugFinder ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA
of CompCert [ 26], a C compiler also proven correct in Coq. Coq
itselfisbasedonanestablishedmetalogic;itskernelwasproven
correct[32].
Closingthecircletosymbolicexecution,therehavebeenvarious
eﬀortstoshow P-soundness ofSE-basedveriﬁers[ 1,23,34].Further-
more, the semantics of SEwas addressed in the past [ 13,25,28,33]
in a more general context. The symbolic semantics used in this
paperisinspiredbythesemanticsproposedbydeBoerandBon-
sangue[13].Buildingonthesefoundations,wedeﬁnesoundness
andcompletenessinthecontextofsymbolicbugﬁndingandpro-
videaformally veriﬁedimplementation.
Contributions. FollowingtheCompCertapproach[ 5,29]tobuild
veriﬁedprogramanalyzersinaproofassistant,wedevelopaproto-
typeofaformallyveriﬁedsymbolicbugﬁnderinCoq.Weformalize
the concrete operational semantics of a small imperative program-
minglanguageandderiveasymbolicoperationalsemanticsinspired
bydeBoerandBonsangue[ 13](Sect.1).Then,weextensivelyex-
plore the relations between concrete and symbolic semantics by
proving that SEis a sound and complete method for reachability
analysisandvariousbug-ﬁndingtasks(Sect. 2).Buildingonthese
theoreticalresults,wederiveaT-soundandT-completesymbolic
bugﬁnder(Sect. 3).Inthecourseofthis,weformallyaddressseveral
practical questions such as path selection andsearch space prun-
ingusingconstraintsolversandtheirinﬂuenceon exhaustiveness
(i.e., T-completeness) and precision (i.e., T-soundness) of SE. All
implementations, deﬁnitions, theorems, and proofs in this paper
are realized in Coq. Thus, if our speciﬁcations convince you, you
canblindlytrusttheproofs. Wecallourprototypicalsymbolicbug
ﬁnderWiSE(“WhatisSymbolicExecution”).Todemonstratethe
practicability of our SEengine’s design principles, we (1) extract
an executable OCaml implementation fully automatically from the
Coq code and (2) manually transform WiSE to PyWiSE, a WiSE
implementation written in Python (Sect. 4). Both extracted bug
ﬁnders can be invoked on the command line. To provide hands-on
evidencethatWiSEworks—additionallytoourformalproofs—we
apply itto ﬁnd bugsinsertedintonumeric algorithms.
1 CONCRETEAND SYMBOLIC SEMANTICS
We study symbolic execution along the example of IMP, a small
imperative programming language with loops and integer arith-
metic. In this section, we introduce the IMP language (Sect. 1.1)
and describe its operational semantics (Sect. 1.2). Afterward, we
equipIMPwithasymbolicoperationalsemanticsfollowingdeBoer
and Bonsangue [ 13] (Sect.1.3). The symbolic semantics will be the
formalbasisto justify the correctness ofour SEengine.
Notation. Weusethefollowingnotationalconventionstoclarify
the domainsofidentiﬁers inour formalizations.
•/u1D45D,/u1D45E,... forprograms
•/u1D449forconcreteenvironments ,/u1D446forsymbolicstores
•/u1D711forpath conditions orLTLformulas
•/u1D70Eforconcretestates ⟨/u1D449,/u1D45D⟩,ˆ/u1D70Eforsymbolicstates ⟨/u1D711,/u1D446,/u1D45D⟩
•/u1D6FCforstreams(e.g.,ofsymbolic states)Statements stmt/Colonequalskip
|fail
|VAR=aexpr
|stmt;stmt
|whilebexprdostmtod
|ifbexprthenstmtelsestmtfi
Expressions bexpr/Colonequaltrue|false
|bexpr (and|or)bexpr
|notbexpr
|aexpr (==|<=|<|>=|>)aexpr
aexpr/ColonequalINT|VAR
|aexpr (+|-)aexpr
Figure 1:Syntax ofIMP
1.1A Small Imperative Programming Language
IMP is an imperative programming language with assignments,
whileloops,andconditionals.Figure 1containsagrammarofIMP’s
concrete syntax; VARdenotes a variable identiﬁer and INTan inte-
ger. We integrate a failstatement signaling an error. Using fail,
one can instrument source code to, e.g., mark supposedly unreach-
ablesectionsormodelrun-timeassertions.IMPdoesnotnatively
support multiplication and division; these operators can be imple-
mentedinterms ofadditionandsubtraction.
⟨/u1D449,/u1D465=/u1D452⟩ → ⟨/u1D449[/u1D465:=⟦/u1D452⟧/u1D449],skip⟩
⟦/u1D44F⟧/u1D449=true
⟨/u1D449,if/u1D44Fthen/u1D4601else/u1D4602fi⟩ → ⟨/u1D449,/u1D4601⟩
⟦/u1D44F⟧/u1D449=false
⟨/u1D449,if/u1D44Fthen/u1D4601else/u1D4602fi⟩ → ⟨/u1D449,/u1D4602⟩
⟨/u1D4491,/u1D4601⟩ → ⟨/u1D4492,/u1D4602⟩
⟨/u1D4491,/u1D4601;/u1D4603⟩ → ⟨/u1D4492,/u1D4602;/u1D4603⟩
⟨/u1D449,skip;/u1D460⟩ → ⟨/u1D449,/u1D460⟩
⟦/u1D44F⟧/u1D449=true
⟨/u1D449,while/u1D44Fdo/u1D460od⟩ → ⟨/u1D449,/u1D460;while/u1D44Fdo/u1D460od⟩
⟦/u1D44F⟧/u1D449=false
⟨/u1D449,while/u1D44Fdo/u1D460od⟩ → ⟨/u1D449,skip⟩
⟦/u1D465⟧/u1D449:=/u1D449(/u1D465), /u1D465∈Vars
⟦true⟧/u1D449:=true ⟦false⟧/u1D449:=false
⟦/u1D4521+/u1D4522⟧/u1D449:=⟦/u1D4521⟧/u1D449+⟦/u1D4522⟧/u1D449⟦/u1D44F1and/u1D44F2⟧/u1D449:=⟦/u1D44F1⟧/u1D449∧⟦/u1D44F2⟧/u1D449
...
Figure 2:Operational Semantics ofIMP
1167ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA Arthur CorrensonandDominic Steinhöfel
⟨/u1D711,/u1D446,/u1D465=/u1D452⟩ →sym⟨/u1D711,/u1D446[/u1D465:=⟦/u1D452⟧/u1D446],skip⟩
⟨/u1D711,/u1D446,if/u1D44Fthen/u1D4601else/u1D4602fi⟩ →sym⟨/u1D711and⟦/u1D44F⟧/u1D446,/u1D446,/u1D4601⟩
⟨/u1D711,/u1D446,if/u1D44Fthen/u1D4601else/u1D4602fi⟩ →sym⟨/u1D711and(not⟦/u1D44F⟧/u1D446),/u1D446,/u1D4602⟩
⟨/u1D7111,/u1D4461,/u1D4601⟩ → ⟨/u1D7112,/u1D4462,/u1D4602⟩
⟨/u1D7111,/u1D4461,/u1D4601;/u1D4603⟩ →sym⟨/u1D7112,/u1D4462,/u1D4602;/u1D4603⟩
⟨/u1D711,/u1D446,skip;/u1D460⟩ →sym⟨/u1D711,/u1D446,/u1D460⟩
⟨/u1D711,/u1D446,while/u1D44Fdo/u1D460od⟩ →sym⟨/u1D711and⟦/u1D44F⟧/u1D446,/u1D446,/u1D460;while/u1D44Fdo/u1D460od⟩
⟨/u1D711,/u1D446,while/u1D44Fdo/u1D460od⟩ →sym⟨/u1D711and(not⟦/u1D44F⟧/u1D446),/u1D446,skip⟩
Figure 3:SymbolicSemantics ofIMP
1.2 Concrete Operational Semantics
IMP programs are executed in an environment /u1D449:Vars→Zrepre-
senting the values assigned to each program variable. Execution
states are pairs ⟨/u1D449,/u1D45D⟩of an environment and a program that re-
mainstobeexecuted.Thesmall-stepoperationalsemanticsforIMP
(Fig.2) is a relation between execution states. We use the notation
⟨/u1D449,/u1D45D⟩ → ⟨/u1D449′,/u1D45D′⟩to state that executing program /u1D45Din environ-
ment/u1D449foronestepproducesanewenvironment /u1D449′togetherwith
a program /u1D45D′that remains to be executed. The relation “ →∗” is
thereﬂexive,transitiveclosureof“ →.”Weusethenotation ⟦/u1D452⟧/u1D449
to denote the value of the expression /u1D452in environment /u1D449. The
operationalsemantics ispresentedinFig. 2.
1.3 Symbolic Operational Semantics
Informally,a program is symbolically executedby using symbolic
placeholdersinsteadofconcretevaluesasinputs.Whenastatement
with diﬀerent possible outcomes is reached (in IMP, this can be
anifstatement or a loop), bothpossibilities are independently
exploredin diﬀerentexecution branches. Symbolic execution thus
producesina treerepresentingallpossibleexecutionpaths.Each
treenodeislabeledwithaformula(calledthe pathcondition ),which
characterizes the condition on the program inputs that needs to be
metfor the program to reachthe associatedstate.
More formally, we regard SEas a type of program execution
respecting a symbolic operational semantics “ →sym” (Fig.3). InSE,
symbolic stores/u1D446:Vars→exprtake the role of environments.
Contrarytothelatter,symbolicstoresmapvariablestosymbolic
expressionsandnotnumericvalues.Thedualtoconcreteexecution
statesare symbolicstates ,triples⟨/u1D711,/u1D446,/u1D45D⟩ofaformula /u1D711(thepath
condition),asymbolicstore /u1D446,and aprogram tobeexecuted /u1D45D(the
program counter ). We extend the concrete evaluation of an expres-
sion/u1D452inastore /u1D449toasymbolicevaluation ⟦/u1D452⟧/u1D446.Theresultof ⟦/u1D452⟧/u1D446
is again a symbolic expression obtained by replacing variables in /u1D452
withtheirassociatedexpressionsin /u1D446,if any.
Thesymbolicexecutionofaprogram /u1D45Dusuallystartsintheinitial
state⟨true,/u1D456/u1D451,/u1D45D⟩, where/u1D456/u1D451:=/u1D465↦→/u1D465is an “empty” symbolic store
assigningtoeachprogramvariableasymbolofthesamename.The
initial path condition trueindicates that we make no assumptionsabouttheprograminputs.Wewrite ⟨true,/u1D456/u1D451,/u1D45D⟩ →∗sym⟨/u1D711,/u1D446,/u1D45D′⟩to
denotethatthesymbolicstate ⟨/u1D711,/u1D446,/u1D45D′⟩canbereachedbysymbolic
execution of /u1D45D. Figure4shows a symbolic execution tree for the
executionofaconditional statementinthe defaultinitialstate.
⟨true,/u1D465↦→/u1D465,ifx<0thenfailelse x=x-1fi⟩
⟨x<0,/u1D465↦→/u1D465,fail⟩ ⟨x>=0,/u1D465↦→/u1D465,x=x-1⟩
⟨x>=0,/u1D465↦→/u1D465−1,skip⟩sym sym
sym
Figure 4:Example SymbolicExecution Tree
2 FINDING BUGSSYMBOLICALLY
Asymbolicexecutor simulates manyconcrete executionsofa pro-
gram simultaneously. From this, we can obtain a bug ﬁnder by
reportinganerrorwheneveronesimulatedexecutionreachesaner-
rorstate.Everyreportedbugmustcomewithan witness.Infuzzing,
this is a bug-triggering input; in the case of SE, it is frequently a
more abstract witness in theform of a boolean formula describing
allinputs triggering the bug. Additionally, we would like to ensure
that any bug in the program will eventually be detected during SE.
Inthissection,formallyconnectbugﬁndingandsymbolicexecu-
tion.In particular,weliftthesymbolicsemanticsfromSect. 1.3to
asound andcomplete methodto ﬁnd bugs.
2.1 Sound& Complete Reachability
Our ﬁrst step toward a symbolic bug ﬁnder is to connect symbolic
and concrete executions. The glue we use to establish this connec-
tion isreachability. A correct symbolic executor should onlyreach
symbolic states representing reachable concrete states. Conversely,
we would like it toreach anyreachable concretestate intheform
ofasymbolic state representing it.
We write Reach(/u1D45D,/u1D70E)andReachsym(/u1D45D,/u1D70E)to express that con-
crete state /u1D70Ecan be reached by concrete and symbolic execution
oftheprogram /u1D45D.Then,weexpresssoundnessandcompleteness
concerning reachabilityas asimpleequivalence:
Theorem 2.1 (Soundness and Completeness for Reachability).
Reachsym(/u1D45D,/u1D70E) ⇔Reach(/u1D45D,/u1D70E)
Reach(/u1D45D,/u1D70E)canbeexpressedusingtheconcreteoperationalse-
mantics. A state /u1D70Eis reachable for a program /u1D45Dif executing /u1D45Din
someinitialstore /u1D4490eventually leads to /u1D70E.
Definition 2.1 (Concrete Reachability).
Reach(/u1D45D,/u1D70E)≜∃/u1D4490,⟨/u1D4490,/u1D45D⟩ →∗/u1D70E
Symbolic states reached during SErepresent manyconcrete
states. To make Reachsym(/u1D45D,/u1D70E)precise, we relate them to their
“concretizations.” Theconcretizationoperation ◦turns asymbolic
store/u1D446intoaconcretestore /u1D449′=/u1D449◦/u1D446byreplacingallfreevariables
in/u1D446bytheirassociatedvaluesin /u1D449.Forexample,if /u1D446={/u1D465↦→/u1D466.alt,/u1D466.alt↦→
/u1D466.alt}and/u1D449={/u1D465↦→1,/u1D466.alt↦→2},we obtain /u1D449′={/u1D465↦→2,/u1D466.alt↦→2}.
Definition 2.2 .
(/u1D449◦/u1D446)(/u1D465):=⟦/u1D446(/u1D465)⟧/u1D449
1168EngineeringaFormallyVerifiedAutomatedBugFinder ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA
We lift the storeconcretization “ ◦” to the concretization of sym-
bolicstates.Toexpressthatasymbolicstate ˆ/u1D70Erepresentsaconcrete
state/u1D70Evia an initial store /u1D4490, we write /u1D70E≃/u1D4490ˆ/u1D70E. Any concretiza-
tion/u1D70Eofˆ/u1D70Emust have the same program counter as/u1D70E. Furthermore,
theinitialstore /u1D4490mustsatisfythe path condition ofˆ/u1D70E.Finally,/u1D70E’s
environment mustbe aconcretizationof ˆ/u1D70E’sstore via /u1D4490.
Definition 2.3 .
⟨/u1D449,/u1D45D⟩ ≃/u1D4490⟨/u1D711,/u1D446,/u1D45D′⟩≜/u1D45D=/u1D45D′∧/u1D449=/u1D4490◦/u1D446∧⟦/u1D711⟧/u1D4490=true
Now, allconcretizations of reachable symbolic states are symboli-
cally reachable.Formally:
Definition 2.4 .
Reachsym(/u1D45D,/u1D70E)≜∃/u1D4490,∃ˆ/u1D70E,⟨true,/u1D456/u1D451,/u1D45D⟩ →∗symˆ/u1D70E∧/u1D70E≃/u1D4490ˆ/u1D70E
Intheremainderofthissection,we describetheproofsofboth
directionsofTheorem2.1fortheinterestedreader.Followingthe
proofs, Sect. 2.2addresses the detection of bugs, which involves
makingprecise what constitutes an “errorstate.”
PROOFOFSOUNDNESS
Subsequently, we derive the proof of “sound reachability,” i.e., that
all states reachable by SEare also reachable by concretely exe-
cutingaprogram.Thisproofrequiressomeintermediatelemmas.
Lemma2.1is a compositionality result on the interplay of con-
cretizationandsymbolic store updates.
Lemma2.1 .
/u1D449◦ (/u1D446[/u1D465:=⟦/u1D452⟧/u1D446])=(/u1D449◦/u1D446)[/u1D465:=⟦/u1D452⟧/u1D449◦/u1D446]
Proof.By structuralinduction on /u1D452. □
DuringSE,pathconditionsgetonlyever morespeciﬁc byaccu-
mulatingadditionconstraints.ThisisassertedinLemma 2.2.We
note/u1D711⊨/u1D711′≜∀/u1D449,⟦/u1D711⟧/u1D449=true⇒ ⟦/u1D711′⟧/u1D449=true.
Lemma2.2 .
⟨/u1D711,/u1D446,/u1D45D⟩ →∗sym⟨/u1D711′,/u1D446′,/u1D45D′⟩ ⇒/u1D711′⊨/u1D711
Proof.By induction on the length of the →∗symderivation and by
induction onthe last →symstep. □
Whenever the path condition after a symbolic step is satisﬁable,
we can make acorresponding concrete step.
Lemma2.3 .
⟨/u1D711,/u1D446,/u1D45D⟩ →sym⟨/u1D711′,/u1D446′,/u1D45D′⟩ ∧/u1D449⊨/u1D711′⇒ ⟨/u1D449◦/u1D446,/u1D45D⟩ → ⟨/u1D449◦/u1D446′,/u1D45D′⟩
Proof.By inductionover thesymbolicderivation andbycompo-
sition (2.1) inthe caseofvariable assignments /u1D465=/u1D452.□
WeextendLemma 2.3tothetransitivereﬂexiveclosurebyap-
plyingmonotonicity(Lemma 2.2).
Lemma2.4 .
⟨/u1D711,/u1D446,/u1D45D⟩ →∗sym⟨/u1D711′,/u1D446′,/u1D45D′⟩∧/u1D449⊨/u1D711′⇒ ⟨/u1D449◦/u1D446,/u1D45D⟩ →∗⟨/u1D449◦/u1D446′,/u1D45D′⟩
Proof.By iterating Lemma 2.3andbyLemma 2.2.□
Soundreachabilityfollowsfrom the (more general)Lemma 2.4.
Theorem 2.2 (SoundReachability).
Reachsym(/u1D45D,/u1D70E) ⇒Reach(/u1D45D,/u1D70E)Proof.ByimmediateapplicationofLemma 2.4andthefactthat
⟨/u1D4490,/u1D45D⟩ ≃/u1D4490⟨true,/u1D456/u1D451,/u1D45D⟩. □
PROOFOFCOMPLETENESS
Weaddresstheconversedirection:Allconcretelyreachablestates
are symbolically reachable. The idea is to show that for any exe-
cutionstepthatcanbetakenaccordingtotheconcretesemantics,
there existsasymbolic step to simulate it.
Lemma2.5 .
(/u1D70E≃/u1D4490ˆ/u1D70E∧/u1D70E→/u1D70E′) ⇒ ∃ˆ/u1D70E′,ˆ/u1D70E→symˆ/u1D70E′∧/u1D70E′≃/u1D4490ˆ/u1D70E′
Proof.By induction on the derivation /u1D70E→/u1D70E′and selecting the
appropriate symbolic rulefor eachcase. □
We extend Lemma 2.5to the reﬂexive transitive closure.
Lemma2.6 .
(/u1D70E≃/u1D4490ˆ/u1D70E∧/u1D70E→∗/u1D70E′) ⇒ ∃ˆ/u1D70E′,ˆ/u1D70E→∗symˆ/u1D70E′∧/u1D70E′≃/u1D4490ˆ/u1D70E′
Proof.By iterating Lemma 2.5. □
The completeness of Reachsymfollows directly from Lemma 2.6.
Theorem 2.3 (Complete Reachability).
Reach(/u1D45D,/u1D70E) ⇒Reachsym(/u1D45D,/u1D70E)
Proof.It is easy to see that ⟨/u1D4490,/u1D45D⟩ ≃/u1D4490⟨true,/u1D456/u1D451,/u1D45D⟩. The result
immediately followsfrom this observationandLemma 2.6.□
2.2 Sound& Complete Bug Finding
In the previous section, we proved that the states reachable by SE
are the same as those reachable by concrete execution. Building on
that,weestablishthat SEcanalsobeusedasasoundandcomplete
bug-ﬁnding method. First, however,we must address the question
What does it mean to ﬁnd bugs? We present diﬀerent views on this
questionandprove that SEanswers eachcase.
DetectingBuggyPrograms. Anaturalviewonbugﬁndingisto
ask—and answer—the question Does my program contain a bug?
Weintroducearelation HasBug(/u1D45D)characterizingbuggyprograms.
This predicate is central to our deﬁnition of T-soundness and T-
completeness (Sect. 3.5). Astate/u1D70E=⟨/u1D449,/u1D45D⟩“has a bug” if /u1D45Dis
stuck, i.e., has no semantic successor state. However (in the case
of IMP), this would also hold if /u1D45Dwasskip, although we were
morethinkingof fail.Weexplicitlyexcludethe skipcaseinthe
followingdeﬁnitionsof“notstuck”(i.e.,“canprogress”)and“stuck.”
Definition 2.5 (Progress).
Progress(⟨/u1D449,/u1D45D⟩)≜/u1D45D=skip∨∃/u1D70E,⟨/u1D449,/u1D45D⟩ →/u1D70E
Definition 2.6 (StuckStates).
Stuck(/u1D70E)≜¬Progress(/u1D70E)
A buggy program has areachable,stuckstate.
Definition 2.7 (Havinga Bug).
HasBug(/u1D45D)≜∃/u1D70E,Reach(/u1D45D,/u1D70E) ∧Stuck(/u1D70E)
As the question Does my program contain a bug? can be reduced
to reachability,we can answer itsymbolically.
1169ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA Arthur CorrensonandDominic Steinhöfel
Definition 2.8 .
HasBugsym(/u1D45D)≜∃/u1D70E,Reachsym(/u1D45D,/u1D70E) ∧Stuck(/u1D70E)
Theequivalenceof HasBugsymandHasBugfollowsimmediately
from the equivalence of ReachsymandReach.
Theorem 2.4 (SoundandComplete BugDetection(1)).
HasBugsym(/u1D45D) ⇔HasBug(/u1D45D)
Proof.By soundness of Reachsymin the “⇒” direction and by
completenessof Reachsyminthe “⇐”direction. □
Finding Erroneous Execution States. HasBug(/u1D45D)asserts that some
bugexists.Alternatively,wecanspeciﬁcallyaskwhethera given
stateiserroneousandwhether SEcanﬁndit.Thepredicate IsBug(/u1D45D,/u1D70E)
asserts that /u1D70Eis an error state of /u1D45D. In Sect.3.4, we derive a reﬁned
“relative”versionofT-soundnessandT-completenessfornontermi-
nating symbolic executors using IsBug(/u1D45D,/u1D70E).
Definition 2.9 .
IsBug(/u1D45D,/u1D70E)≜Reach(/u1D45D,/u1D70E) ∧Stuck(/u1D70E)
Similarlytoabove,wederivea symbolicpredicate IsBugsym(/u1D45D,/u1D70E).
Theorem 2.5 (SoundandComplete BugDetection(2)).
IsBugsym(/u1D45D,/u1D70E) ⇔IsBug(/u1D45D,/u1D70E)
FindingErroneousInputs. Ourﬁnalviewistoaskfor“bad,”i.e.,
bug-triggering, inputs. The predicate BadInput(/u1D45D,/u1D4490)characterizes
those(where the environment /u1D4490represents an input):
Definition 2.10 .
BadInput(/u1D45D,/u1D4490)≜∃/u1D70E,⟨/u1D4490,/u1D45D⟩ →∗/u1D70E∧Stuck(/u1D70E)
The symbolic equivalent is more subtle since →∗symranges over
symbolic states. We must concretize the reached symbolic state
before checking whether itdenotesabug.
Definition 2.11 .
BadInputsym(/u1D45D,/u1D4490)≜∃/u1D70E∃ˆ/u1D70E,
⟨true,/u1D446,/u1D45D⟩ →∗symˆ/u1D70E∧/u1D70E≃/u1D4490ˆ/u1D70E∧Stuck(/u1D70E)
The equivalence of BadInputsymandBadInput follows fromthe
deﬁnition of Reachsymand the proof of Theorem 2.2and Theo-
rem2.3.
Theorem 2.6 (SoundandComplete BugDetection(3)).
BadInputssym(/u1D45D,/u1D4490) ⇔BadInputs (/u1D45D,/u1D4490)
This view bridges the gap between SEand fuzzing: What is
neededtoreporta bug-triggeringinput is(1)abug oracle(asymbolic
equivalent of Stuck(/u1D70E)) and (2) a constraint solver extracting a
solution/u1D4490from a path constraint. Subsequently, we describe how
tobuildatestingtoolbasedonourinsightson SE,includingabrief
discussion of “crash oracles.” Constraint solving is not in our scope.
3 A TRUSTWORTHYSYMBOLIC BUG FINDER
Section2demonstratedthefeasibilityofﬁndingbugswith SEbased
onthesymbolicoperationalsemantics.Now,weturntheseinsights
into an executable correct symbolic bug ﬁnder. First, we discuss
howtodetecterrors,resolvethenondeterminismofthesymbolic
semantics,anddealwithdivergingexecutions(Sect. 3.1).Second,
we provide relevant implementation details of our WiSE prototype(Sect.3.2). Third, we introduce “relative” notions of soundness and
completenessandrelatethemtothesymbolicexecutor(Sect. 3.3)
and bug ﬁnder (Sect. 3.4). Finally, we bridge the (already tiny) gap
towardaT-soundandT-complete bugﬁnder (Sect. 3.5).
3.1 From theSymbolic Semantics to an
Executable Symbolic Executor
Oursymbolicoperationalsemanticsisasolidbasisforsymbolicbug
ﬁnding.Yet,itsdesignleavessomecrucialquestionsopenthatneed
tobeaddressedwhendevelopinganexecutable SE-basedtesting
tool. These are: (1) The symbolic semantics is nondeterministic .
Wheneveran iforwhilestatementisreached, SEcanchoosewhich
branchtoexecutenext.(2)Weneedaneﬀectivewaytodetecterror
states. The previously regarded predicates HasBugsym,IsBugsym,
andBadInputsymare adequate formalizations for bug detection but
are not executable because they live on the semantic level. Finally,
(3) the symbolic semantics does not terminate for programs with
loops,whichwecannotsolveingeneral,butmustfacenonetheless.
HasBugsym(/u1D45D)
⇔
∃/u1D70E,Reachsym(/u1D45D,/u1D70E) ∧Stuck(/u1D70E)
⇔
∃/u1D70E,(∃/u1D4490,∃ˆ/u1D70E,⟨true,/u1D456/u1D451,/u1D45D⟩ →∗
symˆ/u1D70E∧/u1D70E≃/u1D4490ˆ/u1D70E) ∧Stuck(/u1D70E)
⇔
∃/u1D4490,∃⟨/u1D711,/u1D446,/u1D45E⟩,
⟨true,/u1D456/u1D451,/u1D45D⟩ →∗
sym⟨/u1D711,/u1D446,/u1D45E⟩ ∧⟦/u1D711⟧/u1D4490=true∧Stuck(⟨/u1D4490◦/u1D446,/u1D45E⟩)
⇔
∃⟨/u1D711,/u1D446,/u1D45E⟩,⟨true,/u1D456/u1D451,/u1D45D⟩ →∗sym⟨/u1D711,/u1D446,/u1D45E⟩
(1)∧
∃/u1D4490,⟦/u1D711⟧/u1D4490=true
(2)∧Stuck(⟨/u1D4490◦/u1D446,/u1D45E⟩)
(3)
Figure5:Decompositionofsymbolicbugﬁndingintochecks
for(1) reachability,(2) satisﬁability,and (3) “stuckness.”
Resolving Nondeterminism. While in theory, we could spawn
independent processes whenever SEperforms a case distinction
whenfacingan iforwhilestatement,thiscannotcontinueforever.
Thenumberofbranchesinasymbolicexecutiontreeisexponential
inthenumberofsuchbranchingpoints;eventually,wewill have
todecide which branches to follow ﬁrst. This process is known
aspathselection inSE[3].Usually,pathselectionisregardedasa
“heuristics,”merelyanartifactofeﬃciencyconsiderations.However,
theexplorationorderhassolidconsequencesonthe T-completeness
of the resulting bug ﬁnder. Early dynamic symbolic executors such
as DART [ 19] explored programs using a Depth-First Search (DFS).
Thisapproachis incomplete ingeneral:Suchexecutorslikelyget
lostineverdeeperiterationsofloopsatthebeginningofaprogram,
neglecting any states that follow. Instead, we choose a Breadth-
FirstSearch(BFS)approach.InSect. 3.3,weprovethecompleteness
of BFS-based path selection, which requires estimating where a
successor state isaddedinthe stream of states to explore.
1170EngineeringaFormallyVerifiedAutomatedBugFinder ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA
Detecting Errors. Any bug ﬁnder depends on a bug oracle to
determine when a program state constitutes a bug. Predicates such
asHasBugsymarenon-executable semanticnotions.Moreover,they
aredeﬁnedusingsymbolicreachability,whichrequireschecking
if a path condition is satisﬁable (see Fig. 5). Fuzzers commonly
classifyprogram runs as erroneous if theyend witha crashofthe
program. We use a similar approach: We classify a program as
buggy or crashing if it is stuck.In our case, it can be shown that
a state is stuck if and only the next statement to be executed is
fail.Thissimplesolutionisalreadyquitepowerful.Forexample,
toextendIMPwithfailing expressions, onecanuse failtomodel
theexceptionalcases.Considerintegerdivision:Foranyexpression
x / y,weaddaprecedingstatement ify == 0then fail else
d = div(x,y) , replacing x / ywith the fresh variable d. The
functiondivwouldimplementdivisionusingrepeatedsubtraction,
assuming thatyisnonzero.
AddressingTermination. Asamethodsimulatingconcreteexecu-
tions,SEdoesnotterminateformostloopingorrecursiveprograms.
Derivationsinoursymbolicsemantics(Fig. 3)areinﬁnitefor any
program with a loop. In Sect. 3.5, we integrate pruning of unsat-
isﬁable states, which solves that issue for loops with concrete or
unsatisﬁableguards.Evenso,loopswithunderconstrainedsymbolic
guardsinducean inﬁnite amount ofreachable successor states.
There are two main options for dealing with nontermination in
SE. The ﬁrst option is to impose an upper bound on the number of
timesaloopisunwound.Thisapproachhastheadvantagethatitis
easytoimplement.However,itpreventsusfromreasoningabout
theT-completeness of a symbolic executor, since the chosen bound
mightbetoosmalltodetectsuﬃcientlydeepbugs.Theapproachwe
choseinsteadis toimplementthesymbolic executoras agenerator
of aninﬁnite stream of states. A user of a stream-based executor
can only ever inspect ﬁnitely many states from the stream, which
correspondstoboundedexecution;yet,we canobtainacompleteness
result.OurOCamlandPythonimplementations(Sect. 4)retrieve
elements from the stream upto auser-speciﬁedbound.
Thus, we view automated bug ﬁnders as producers of lazily
evaluated inﬁnite sequences of status messages reporting on the
progress of the bug ﬁnding process. There are various ways of
implementing inﬁnite streams depending on the capabilities of the
programming languagea symbolicexecutor is implemented in. In
proofsystemsbasedonpurelyfunctionallanguagessuchasCoq,
inﬁnitesequencescanbemodeledby co-induction [16,17].Inlan-
guageswithlazyevaluationsuchasHaskell,suchinﬁnitesequences
canbeimplementedusingstandard lists.Inthecaseofeagerlyeval-
uated functional languages such as OCaml, the implementation
can resort to explicit suspensions . Otherwise, we can model streams
withgenerators àla Python.
In Sect.3.3, we show that the stream-based approach permits
elegant speciﬁcations ofcorrectness basedontemporal logic.
3.2 FunctionalImplementation
After many dry discussions, we provide some implementation
details of our proven-correct symbolic executor. As discussed in
Sect.3.1,theexecutorusesabreadth-ﬁrstgoalselectionandpro-
ducesa“lazy”inﬁnitestreamofstatusmessages.WeuseanOCaml-
ﬂavoredsyntaxinallcodesnippets;wefounditeasytotranslateletrun/u1D459=
match/u1D459with
| [] ->
yield None
run []
|⟨/u1D711,/u1D446,/u1D45D⟩::/u1D459->
yield⟨/u1D711,/u1D446,/u1D45D⟩
run (/u1D459+expand⟨/u1D711,/u1D446,/u1D45D⟩)
Figure 6:Main Entry Pointofthe SymbolicExecutor
letexpand⟨/u1D711,/u1D446,/u1D45D⟩=
match/u1D45Dwith
|skip|fail-> [ ]
|skip ;c ->
[⟨/u1D711,/u1D446,/u1D450⟩]
| x=e ->
[⟨/u1D711,/u1D446[x:=⟦/u1D452⟧/u1D446],skip⟩]
|/u1D4501;/u1D4502->
[⟨/u1D711′,/u1D446′,/u1D4501;/u1D4502⟩for⟨/u1D711′,/u1D446′,/u1D4501⟩inexpand/u1D4501]
|whileconddocod->
[⟨/u1D711andcond,/u1D446,/u1D450;/u1D45D⟩,⟨/u1D711and(andcond),/u1D446,skip⟩]
|if/u1D450/u1D45C/u1D45B/u1D451then/u1D4501else/u1D4502fi->
[⟨/u1D711and/u1D450/u1D45C/u1D45B/u1D451,/u1D446,/u1D450 1⟩,⟨/u1D711and(not/u1D450/u1D45C/u1D45B/u1D451),/u1D446,/u1D4502⟩]
Figure 7:ComputingSuccessorsofSymbolicStates
this syntax to,e.g.,Python. Everythingdiscussedinthis section is
implementedinCoq, provencorrect,andautomatically extracted
to an executableOCaml executableversion.
Symbolic Evaluator and Symbolic Stores. Implementing a sym-
bolic executor requires an eﬃcient implementation of symbolic
storesandafunctiontoevaluatesymbolicexpressions.Oneway
to implement symbolic stores is using hash tables with variable
namesaskeysandexpressionsasvalues.Updatingastore /u1D446with
anassignment /u1D465≔/u1D452,written /u1D446[/u1D465≔/u1D452],returnsanupdatedcopy
ofthehashtable.Thesymbolicevaluation ⟦/u1D452⟧/u1D446ofanexpression
/u1D452in a store /u1D446can be performed by a simple recursive function.
Weabstractfromtheseimplementationdetailsandusethemath-
ematicalnotations /u1D446[/u1D465:=/u1D452]and⟦/u1D452⟧/u1D446incodesnippetstodenote
assignments andsymbolic evaluations.
ALazySymbolicExecutor. Themaincomponentofthesymbolic
executorisafunction expand(Fig.7)computingthesuccessorsofa
symbolic state, implementing the symbolic semantics in Fig. 3. The
executor’sentrypointisafunction run(Fig.6)takingaFIFOqueue
ofsymbolicstatesandreturningastreamof(optional)reachable
symbolic states. At every iteration, it yields the ﬁrst state from the
queue.Then,thedirectsuccessorsofthecurrentstatearecomputed
usingexpandand enqueued in the task queue (with the lowest
priority, realizing a breadth-ﬁrst search). Finally, runcalls itself
recursively on the updated queue. If the queue is empty, a None
token isyieldedindicating that nostates are left for expansion.
1171ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA Arthur CorrensonandDominic Steinhöfel
letdisplay state =
ifstate is None then
Finished
else if is_stuck state then
BugFound(state)
else
Pending
letbug_finder /u1D45D=
map display (run [ ⟨true,/u1D456/u1D451,/u1D45D⟩])
Figure8:StatusMessageConversion,BugFinderEntryPoint
letis_stuck ⟨/u1D711,/u1D446,/u1D45D⟩=
match/u1D45Dwith
|fail-> True
|/u1D45D;_ -> is_stuck /u1D45D
| _ -> False
Figure 9:Classifying ErrorStates
Reporting Bugs. The function runimplements a symbolic execu-
tor. We obtain a bug ﬁnder by turning symbolic states from the
stream intoadequate statusmessages:
(1)BugFound (⟨/u1D711,/u1D449,/u1D45D⟩)informs the user that a bug has been
detectedandreturns the associatedsymbolic state.
(2)Pendinginformsthe userthat the SEisinprogress.
(3)Finished informstheuserthatthe SEterminated.Nofur-
ther symbolic state willbe discovered.
The conversion from symbolic states to status messages is ac-
complishedbythefunction display(Fig.8).Theﬁnalbugﬁnder
(bug_finder inFig.8)startsSEwithasingletontaskqueueconsist-
ing of an initial symbolic state andapplies display on the results.
Detecting Bugs. The function display usesis_stuck (Fig.9) to
ﬁltererrorstates.AsdiscussedinSect. 2.2,is_stuck considersa
symbolic state ⟨/u1D711,/u1D446,/u1D45D⟩an errorstate if /u1D45Dstartswith fail.
3.3 RelativeSoundness andCompletenessof
theSymbolic Executor
T-soundnessandT-completenessareexpressedassuminga“yes/no”
oracle.Forexample,aT-soundbugﬁnderonlyrespondswith yes
toIs there a bug in my program? if thereisa bug that manifests
for a concrete input. However, fuzzers and symbolic bug ﬁnders
generally do not terminate unless interrupted, as in the case of
our symbolic bug ﬁnder from the previous section. Thus, we adapt
thesenotionstotestersproducinga streamofresults.Wecallthe
resulting concepts relativesoundness/completeness. They address
the questionofwhether aninputin astream exposes abug.
More precisely, a bug ﬁnder is relatively sound if any bug report
in the generated stream corresponds to bug-exposing input(s). It is
relativelycomplete ifitwilleventuallyreportabugforanygiven
bug-triggering input. In other words, both terms are relative to thetimeprovidedtothebugﬁnder.Moreover,relativecompleteness
isparametric in a concrete bug-triggering input. Thoughformally
weaker than T-completeness due to the additional precondition,
it provides the strong guarantee a speciﬁcbug will be found, not
justanybug.Inthecontextof SE,relative soundness additionally
permitsconveyingfalsepositiveswith unsatisﬁablepathconstraints;
excludingtheserequiresacompleteconstraintsolverthatcorrectly
classiﬁesallunsatisﬁablepathconditions.Providedsuchasolver,it
isaneasyexercisetoconstructaT-soundandT-completebugﬁnder
from arelativelysound/complete one,as describedinSect. 3.5.
In this section, we investigate SE-speciﬁc notions of relative
soundness and completeness, asserting that a symbolic executor
exploresonlyreachable symbolic states(soundness) and allreach-
able states (completeness). The subsequent Sect. 3.4formalizes the
more general notions of relative soundness and completeness and
applies the results from this section to prove that the bug ﬁnder
from Sect. 3.2satisﬁestheseproperties.
To conveniently express predicates over streams of symbolic
statesorstatusmessages,weuse LinearTemporalLogic(LTL) [2,
Chapter 5] notation. LTLformulas describe inﬁnite streams of
elementsofsomecarrierset /u1D434.AtomicLTLformulasarepredicates
over/u1D434-elements, or, equivalently, subsets of /u1D434. For example, the
LTLformula/u1D443={/u1D45B|∃/u1D45A,2·/u1D45A=/u1D45B}is satisﬁed by the stream
4,5,6,...sinceitsﬁrstelementiseven.Theformula □/u1D443(“globally”)
describes streams in which allelements are even; ♢/u1D443(“eventually”)
matches streams with someeven number. The property □♢/u1D443holds
for streams with inﬁnitely many even numbers (“every position in
thestream musteventually besucceededbyaneven number”).In
additionto“□”and“♢,”weuselogicalimplication“ →.”Forexample,
{42}→(♢{0,1})means that any stream whose ﬁrst element is 42
mustcontain either0or1at alaterposition.
We write /u1D6FC⊨/u1D711if the stream /u1D6FC=/u1D6FC0,/u1D6FC1,...satisﬁes the LTL
formula/u1D711;/u1D6FC⊭/u1D711means that /u1D6FCdoesnotsatisfy/u1D711. Formally, the
semantics ofLTLformulas isinductivelydeﬁnedas follows:
/u1D6FC⊨/u1D443⇔/u1D443(/u1D6FC0)
/u1D6FC⊨□/u1D711⇔∀/u1D456≥0,/u1D6FC/u1D456/u1D6FC/u1D456+1...⊨/u1D711
/u1D6FC⊨♢/u1D711⇔ ∃/u1D456≥0,/u1D6FC/u1D456/u1D6FC/u1D456+1...⊨/u1D711
/u1D6FC⊨/u1D7111→/u1D7112⇔/u1D6FC⊭/u1D7111or/u1D6FC⊨/u1D7112
Oursymbolicexecutorproducesastreamofoptional(possibly
None)symbolicstatesfromalist /u1D459ofinputstates.Tobesound,every
symbolic state in the stream must be reachable from some state in
/u1D459. TheLTLformulaReachableFrom (/u1D459)asserts that the ﬁrst element
inastream is Noneorasymbolic state reachable from astate in /u1D459.
Definition 3.1 (Reachable From).
ReachableFrom (/u1D459):={ˆ/u1D70E′| ∃ˆ/u1D70E∈/u1D459,ˆ/u1D70E→∗symˆ/u1D70E′}∨{None}
Ourbugﬁnder’ssoundnessdependsonthesingle-stepexecution
functionexpandcorrectlyimplementingthe relation →sym:
Theorem 3.1 (Correct expansion).
ˆ/u1D70E→symˆ/u1D70E′⇔ˆ/u1D70E′∈expand(ˆ/u1D70E)
Proof.By induction on(1) the →sym-derivation (direction “ ⇒”)
and(2) the structure of ˆ/u1D70E’sprogram counter (“ ⇐”).□
Now we can state the relative soundness theorem, whose proof
followsdirectlyfrom Theorem 3.1:
1172EngineeringaFormallyVerifiedAutomatedBugFinder ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA
Theorem 3.2 (Relative Soundnessof Symbolic Execution).
run(/u1D459)⊨□ReachableFrom (/u1D459)
By outputting a Nonevalue in the stream, runsignals that all
reachable states have been exhaustively explored. Consequently,
the stream should only consist of Noneafter the ﬁrst issued one,
guaranteeing that we can safelyterminate SEafter the ﬁrst None.
Theorem 3.3 (SoundTerminationof Symbolic Execution).
run(/u1D459)⊨□(None→□None)
Weconsiderthesymbolicexecutor relativelycomplete if,forany
initial symbolic state ˆ/u1D70E, it generates at leastall→∗sym-successors
ofˆ/u1D70Ewhen started on the list [ˆ/u1D70E]. We ﬁrst state a more general
theorem (Lemma 3.1) from which we then conclude the relative
soundness.Lemma 3.1assertsthatforanystate ˆ/u1D70Ediscoveredduring
SE,its(directorindirect)successorswilleventuallybefound.Its
proofrequiresustopredict whenexactly thedirectsuccessorsof
anystate ˆ/u1D70Ewillbe discovered byour breadth-ﬁrstsearchstrategy.
Lemma3.1 (Reachability of Successors).
ˆ/u1D70E→∗symˆ/u1D70E′⇒ ∀/u1D459,run(/u1D459)⊨□(ˆ/u1D70E→♢ˆ/u1D70E′)
Proof.By induction on the length of the derivation ˆ/u1D70E→∗symˆ/u1D70E′. If
ˆ/u1D70E′=ˆ/u1D70E,thenthetheoremisobvious.Otherwise,wehave /u1D460→sym
ˆ/u1D70E′′andˆ/u1D70E′′→∗symˆ/u1D70E′forsomeintermediatestate ˆ/u1D70E′′.Nowsuppose
thatˆ/u1D70Eoccursatagivenposition /u1D456ˆ/u1D70Einthestream run(l),thedirect
successor of ˆ/u1D70E′′necessarily occurs at index /u1D456ˆ/u1D70E′′=/u1D456ˆ/u1D70E+ |/u1D459| +1or
/u1D456ˆ/u1D70E′′=/u1D456ˆ/u1D70E+|/u1D459|+2becauserunextendsthe tasklist byaddingallthe
successors(see Theorem 3.1) ofthecurrent state attheend ofthe
tasklistandthereareatmosttwosuccessorsforanystate.Since
ˆ/u1D70E′′occursatposition /u1D456ˆ/u1D70E′′,weknowbyinductionhypothesisthat
ˆ/u1D70E′occurs at someindex /u1D456ˆ/u1D70E′′+/u1D45Bfor/u1D45B≥0. □
From Lemma 3.1,we conclude the completenessresult.
Theorem 3.4 (Relative Completeness of Symbolic Execution).
ˆ/u1D70E→∗symˆ/u1D70E′⇒run([ˆ/u1D70E])⊨♢ˆ/u1D70E′
Proof.Itsuﬃcestoseethattheﬁrstelementofthestream run([ˆ/u1D70E])
isˆ/u1D70Eandthen to apply Lemma 3.1at position 0. □
3.4 RelativeSoundness andCompletenessof
theSymbolic Bug Finder
In theprevious section,we established therelative soundnessand
completenessofthesymbolicexecutorregardingthesymbolicse-
mantics.Now, wedeﬁne relativelysound bugdiscovery ,aproperty
relevant to bug ﬁnders in general, including fuzzers. We assume
the interface of the function find_bugs from Sect. 3.2. That is,
a bug ﬁnder outputs a stream of status messages that are either
Pending,Finished , orBugFound . For a status message to be valid,
aBugFound messagemustreportasymbolicstatecorresponding
to a concrete set of bug-triggering states. The following deﬁni-
tion ofValidStatus uses a function Concrete(ˆ/u1D70E)mapping from a
symbolicstatetothesetofconcretestatesitrepresents.Formally,
Concrete(ˆ/u1D70E)={/u1D70E|∃/u1D4490,/u1D70E≃/u1D4490ˆ/u1D70E}.
Definition 3.2 (Valid Status).
ValidStatus (/u1D45D):=
{BugFound (ˆ/u1D70E) | ∀/u1D70E,/u1D70E∈Concrete(ˆ/u1D70E) ⇒IsBug(/u1D45D,/u1D70E)}
∨Pending ∨FinishedAccording to this deﬁnition, a bug report is always valid for
symbolic states with unsatisﬁable path conditions since these have
anempty Concrete(ˆ/u1D70E).HowtogetfromtheretorealT-soundness
isthefocusofSect. 3.5.Thedeﬁnitionofrelativesoundnessiseasy:
A relativelysound bugﬁnder only outputs valid status messages.
Theorem 3.5 (Relatively SoundBug Discovery).
find_bugs (/u1D45D)⊨□ValidStatus (/u1D45D)
Proof.DirectapplicationofLemma 3.1,andthefactthat display
ﬁltersonly stuckstates. □
Completeness. Relative completeness means that any given bug
will eventually be reported in the stream of status messages. As
mentioned before, this property is both weaker—due to the precon-
dition of providing a concrete bug-triggering input—and stronger—
since it guarantees that a pre-chosen bug will be found—than T-
completeness.Thesubsequentcompletenesstheoremusesafunc-
tionSymbolic(/u1D70E)mapping from a concrete state to the set of sym-
bolic states representing it (the inverse of Concrete). More formally,
Symbolic(/u1D70E)={ˆ/u1D70E|∃/u1D4490,/u1D70E≃/u1D4490ˆ/u1D70E}.
Theorem 3.6 (Relatively Complete Bug Discovery).
IsBug(/u1D45D,/u1D70E) ⇒find_bugs (/u1D45D)⊨♢Symbolic(/u1D70E)
Proof.SupposeIsBug(/u1D45D,/u1D70E). By completeness of bug ﬁnding, we
haveIsBugsym(/u1D45D,/u1D70E).Theresultfollowsbythecompletenessof run
andthe fact that displaykeepsallstuckstates inthe stream. □
Termination. Implementing a complete and yet always terminat-
ingbug ﬁnder is impossible as it would solve the Halting problem.
Yet,thereareprogramsforwhich SEcanbeexhaustive(e.g.,pro-
gramswithoutloopsnorrecursion).Wedeﬁne“soundtermination”
as the property that whenever a bug ﬁnder emits a Finished mes-
sage,itwillnotreportanythingelsefromthatpointon.Ifasoundly
terminating,relativelycompletebugﬁnderdoesnotreportabug
andsays Finished ,we can be sure that the tested programis safe.
Theorem 3.7 (SoundTerminationof theBug Finder).
find_bugs (/u1D45D)⊨□(Finished →□Finished )
Proof.Directconsequenceof Theorem 3.3. □
3.5 A T-Sound andT-Complete Bug Finder
A T-sound and T-complete bug ﬁnder is a binary oracle answering
yesif,andonlyif,thetestedprogramisfaulty.Sofar,weconsidered
bugﬁndersproducinginﬁnitestreamsofstatusmessages,towhich
T-soundnessandT-completenessdonotdirectlyapply.Yet,relative
soundness and completeness (Theorem 3.6, Theorem 3.5) are suﬃ-
ciently strong to derive such an oracle. Relative soundness ensures
forevery BugFound (ˆ/u1D70E)messagethatall /u1D70E∈Concrete(ˆ/u1D70E)areerror
states. The only obstacle in the way toward T-soundness is that
Concrete(ˆ/u1D70E)could be empty, i.e., ˆ/u1D70E’s path condition unsatisﬁable.
Otherwise,a BugFound messagefromthe streamcorrespondstoa
soundbug.SEengines typically use oﬀ-the-shelf constraint solvers
suchasZ3orCVC5todetermineifapathconditionisunsatisﬁable.
Relativecompleteness,ontheotherhand,ensuresthatforany
error state /u1D70E, the stream contains a message BugFound (ˆ/u1D70E)with
ˆ/u1D70E∈Symbolic(/u1D70E). The latter condition implies that ˆ/u1D70E’s path con-
dition is satisﬁable. Inconveniently, a terminating bug ﬁnder can
1173ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA Arthur CorrensonandDominic Steinhöfel
exception Bug
exception Termination
letreport msg =
matchmsgwith
| BugFound (path, _, _) ->
ifis_sat path then raise Bug
| Finished -> raiseTermination
| _ -> ()
typeanswer = YES | NO
lethas_bug p =
tryiter report (find_bugs p)
with
| Bug -> YES
| Termination -> NO
Figure 10:AT-soundandT-complete Bug Finder
neverbecompleteingeneral;thebugcouldalwaysbehiddeninthe
nextstate.Oursolutiontothisproblemistoimplementa nontermi-
nating butcomplete symbolic tester. Our implementation, shown in
Figure10,buildson find_bugs andusesaconstraintsolver is_sat
andafunction iterforiteratingoverallelementsofastream.It
only outputs “sound” bugs, terminates for ﬁnite symbolic execu-
tions, and continues SEas long as no bug is found or the process is
interrupted. Since only terminating functions can be implemented
in Coq, we have to resort to a “pen-and-paper” proof of has_bug’s
T-soundness andT-completeness.
Theorem 3.8 (T-soundnessandT-completeness).
has_bug(/u1D45D)=/u1D44C/u1D438/u1D446⇔HasBug(/u1D45D)
Proof.The answer is YESiﬀ there is a BugFound (⟨/u1D711,/u1D446,/u1D45D′⟩)mes-
sage in the stream find_bugs (/u1D45D)such that /u1D711is satisﬁable. The
result followsfrom relative soundness/completeness. □
4 IMPLEMENTATIONSAND CASE STUDIES
Inthissection,weconnecttoQuestion (2)fromtheintroduction:
How can we engineer a reliable symbolic testing tool? We aim to
proposeadesignforsymbolicexecutorsindependentlyoftheim-
plementation language; for the solution to be of general interest,
it should be able to “live” outside an interactive theorem prover.
Thus, we derived two executable implementations from the Coq
implementation of WiSE. First, we automatically extracted OCaml
code, wrapped in a command line interface with a parser for IMP’s
concretesyntax.Second,wedevelopedafunctionallyequivalent
Python implementation, PyWiSE, again with a usable command-
line frontend. We used Python generators to implement streams
wheretheCoqversionusesco-inductionandre-implementedthe
Coqcode withonly small, purelysyntactical changes.
Since the transformations from Coq to executable programs
are not formally proven correct, we evaluated them with three
numeric algorithms. We chose the computation of a number’s fac-
torialandintegersquarerootandthegreatestcommondivisoroftwo numbers. We annotated each program with assertions of their
correctness;e.g.,foranintegersquareroot /u1D45Fofanumber /u1D45B,/u1D45Bmust
bein theclosedinterval [/u1D45F2;(/u1D45F+1)2].Next, wederived a“buggy”
mutation of each program, e.g., turning while_s > x dointo
while_s<xdoin the square root example. Finally, we asserted
that our symbolic executors ﬁnd the inserted bug but report no
bugfor theoriginalprograms. Inaddition,weveriﬁed that SEter-
minateswitha Finished messageforthecorrectprogramswhen
we restrict the domain of the input number(s) to a ﬁnite range. To
demonstratethatabreadth-ﬁrstpathselectionissuperiortodepth-
ﬁrst(asintheoriginalDARTsymbolicexecutor[ 19])inﬁnding any
buginaprogram,weaddeda --depth-first optiontoPyWiSEto
transition to depth-ﬁrst search. As a result, the bug in the factorial
implementationisnotuncoveredsince SEgets“trapped”ininﬁnite
iterations ofan early loop.
EngineeringTasks. Themainnoveltyofthispaperisthepresenta-
tionofamechanized speciﬁcationofthecorrectnessoftestingtools
and the implementation of a mechanically veriﬁed symbolic testing
toolinaproofassistant.Weabstractedtheaddressedproblemin
twonoteworthywaysto facilitate this project.
(1)Our target programming language IMP is a simple WHILE
language. Extending our framework to a richer language
requiresthespeciﬁcationofarichersemantics.Forexample,
thesemanticsofES5JavaScriptintheJSCertproject[ 6]is
implementedinabout3,000linesofCoqcode.Thecorrect-
nessproofofJSRef,anexecutablereferenceinterpreterfor
JSCert,spans 3,500 linesof code.
(2)We disregard the question of eﬃciency, which is orthogonal
to our Questions (1)and(2). Yet,eﬃciency is crucial for the
competitivenessof SE-basedtestingtoolscomparedtoran-
domtesting[ 8].Aneﬃcientsymbolicexecutormightreplace
the breadth-ﬁrst path selection with, e.g., a coverage-guided
generationalsearch[ 20].Aconsiderablebodyofliterature
on eﬃcient symbolic execution exists (cf. the survey by Bal-
doni et al. [ 3] for an overview). The role of our contribution
is to show how the correctness of an SEsystem can be re-
tained in the face of eﬃciency optimizations. Exchanging
path selection, for example, requires provingthat allreach-
able symbolic states are eventually considered by the new
selection mechanism(Lemma 3.1).
Extending our foundational work to eﬃcient systems for richer
languagesispossible.Ofcourse,thatsteprequiressigniﬁcant(proof)
engineeringwork. This paper showsthe way.
5 CONCLUSION AND FUTUREWORK
Consideringthattestingisthepredominantprogramveriﬁcation
technique, it may seem surprising that the correctness of bug
ﬁndershasnotreceivedmoreattention.Probably,thisisbecause
fuzzers, the most popular automated testing tools, are naturally
“bug-sound”—theyonlyreportinputsthat havealready madethe
program under test crash. However, fuzzers only ﬁnd shallow bugs
forprogramswithcomplexdemandsontheirinputsorwithcode
guardedbycomplexconstraints. SymbolicExecution(SE) isawhite-
box technique simulating multiple program executions at once. As
such, this technique can handle complex input constraints fully
1174EngineeringaFormallyVerifiedAutomatedBugFinder ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA
automatically.Comparedtoafuzzer,correctlyimplementingasym-
bolicexecutorconstitutesamuchmoresigniﬁcantchallenge.We
deﬁned when a tester is “bug-sound” and “bug-complete” (i.e., a
program is buggy if, and only if, a bug is reported), resulting in the
notions of T-soundness and T-completeness. We chose a semantics
forSEanddemonstratedthatitcanbeusedasafoundationforsym-
bolicbugﬁnding.Finally,weimplementedasymbolicbugﬁnder
(WiSE) in Coq, proved it T-sound and T-complete, and extracted
executableimplementations inOCaml andPython.
The resulting symbolic executors interpret programs in the sim-
pleprogramminglanguageIMP.Connectingtoourfoundational
work,weplantosupportadditionalIMPfeatures,suchasfunctions
and pointers, in our symbolic executor. Thus, we could discover
common pitfalls in implementing their symbolic evaluation. More
generally,WiSEconstitutesasolidbasisforstudyingmoreadvanced
SEfeatures, such as diﬀerent path selection algorithms, constraint
representations, orconstraint-solving approaches.
Is it realistic to expect a fully veriﬁed symbolic executor for
anindustrialprogramminglanguage?Wethinkitis—considering
the existence of fully veriﬁed C compilers . In any case, blackbox
testing will never ﬁnd all the errors in existing symbolic executors;
butinsightsfromimplementingdiﬀerentprogramminglanguage
features inaframework willpositivelyinﬂuencetheirdesign.
DATA AVAILABILITY
OurWiSEandPyWiSEprototypesandthedocumentationofthe
Coqsourcescan be accessedat
https://github.com/acorrenson/WiSE/
https://acorrenson.github.io/WiSE/
PyWiSEisalsoavailable onPyPIandcan be installedvia
pip install wise-se
An artifact with a Docker container comprising WiSE, PyWiSE,
andourexampleprogramsinaworkingenvironmentispublicly
available [ 11].
ACKNOWLEDGMENTS
This work was supported by the European Research Council (ERC)
GrantHYPER(No.101055412)andbyDFG grant389792660 aspart
of TRR 248. Views and opinions expressed are however those of
theauthorsonlyanddonotnecessarilyreﬂectthoseoftheEuro-
peanUnionortheEuropeanResearchCouncilExecutiveAgency.
Neither the European Union nor the granting authority can be
held responsible for them. A. Correnson carried out this work as a
member of the Saarbrücken Graduate School of Computer Science.
REFERENCES
[1]Wolfgang Ahrendt, Andreas Roth, and Ralf Sasse. 2005. Automatic Validation
of Transformation Rules for Java Veriﬁcation Against a Rewriting Semantics. In
LogicforProgramming,ArtiﬁcialIntelligence,andReasoning,12thInternational
Conference (LPAR’05), Proceedings (LectureNotes inComputer Science,Vol.3835) ,
GeoﬀSutcliﬀeandAndreiVoronkov(Eds.).Springer,412–426. https://doi.org/
10.1007/11591191_29
[2]ChristelBaierandJoost-PieterKatoen.2008. PrinciplesofModelChecking . The
MIT Press. http://www.amazon.com/Principles-Model-Checking-Christel-
Baier/dp/026202649X%3FSubscriptionId%3D13CT5CVB80YFWJEPWS02%
26tag%3Dws%26linkCode%3Dxm2%26camp%3D2025%26creative%3D165953%
26creativeASIN%3D026202649X[3]Roberto Baldoni, Emilio Coppa, Daniele Cono D’Elia, Camil Demetrescu, and
IreneFinocchi.2018. ASurveyofSymbolicExecutionTechniques. ACMComput.
Surv.51,3 (2018), 50:1–50:39. https://doi.org/10.1145/3182657
[4]ChristophBaumann,BernhardBeckert,HolgerBlasum,andThorstenBormer.
2012. Lessons Learned From Microkernel Veriﬁcation – Speciﬁcation is the New
Bottleneck.In ProceedingsSeventhConferenceonSystemsSoftwareVeriﬁcation,
(SSV’12) (EPTCS, Vol. 102) , Franck Cassez, Ralf Huuck, Gerwin Klein, and Bastian
Schlich(Eds.).18–32. https://doi.org/10.4204/EPTCS.102.4
[5]Sandrine Blazy, Vincent Laporte, André Maroneze, and David Pichardie. 2013.
FormalVeriﬁcationofaCValueAnalysisBasedonAbstractInterpretation.In
StaticAnalysis ,FrancescoLogozzoandManuelFähndrich(Eds.).Springer,324–
344.
[6]MartinBodin,ArthurCharguéraud,DanieleFilaretti,PhilippaGardner,Sergio
Maﬀeis, Daiva Naudziuniene, Alan Schmitt, and Gareth Smith. 2014. A Trusted
Mechanised JavaScript Speciﬁcation. In The 41st Annual ACM SIGPLAN-SIGACT
Symposium on Principles of Programming Languages, POPL ’14 , Suresh Jagan-
nathanandPeterSewell(Eds.).ACM,87–100. https://doi.org/10.1145/2535838.
2535876
[7]MarcelBöhme,DanushkaLiyanage,andValentinWüstholz.2021. Estimating
Residual Risk in Greybox Fuzzing. In ESEC/FSE ’21: 29th ACM Joint European
SoftwareEngineeringConferenceandSymposiumontheFoundationsofSoftware
Engineering ,DiomidisSpinellis,GeorgiosGousios,MarshaChechik,andMassi-
miliano Di Penta (Eds.). ACM, 230–241. https://doi.org/10.1145/3468264.3468570
[8]Marcel Böhme and Soumya Paul. 2016. A Probabilistic Analysis of the Eﬃciency
of Automated Software Testing. IEEE Trans. Software Eng. 42, 4 (2016), 345–360.
https://doi.org/10.1109/TSE.2015.2487274
[9]JoshuaBundt,AndrewFasano,BrendanDolan-Gavitt,WilliamRobertson,and
TimLeek.2021. EvaluatingSyntheticBugs.In ASIACCS’21:ACMAsiaConference
on Computer and Communications Security , Jiannong Cao, Man Ho Au, Zhiqiang
Lin, and MotiYung (Eds.).ACM. https://doi.org/10.1145/3433210.3453096
[10]Rod M. Burstall. 1974. Program Proving as Hand Simulation With a Little Induc-
tion.InInformationProcessing,Proceedingsofthe6thIFIPCongress1974 ,JackL.
Rosenfeld(Ed.). North-Holland,308–312.
[11]Arthur Correnson and Dominic Steinhöfel. 2023. Artifact for "Engineering a
Formally Veriﬁed Automated Bug Finder". https://doi.org/10.5281/zenodo.
8269801
[12]P. Cousot and R. Cousot. 1977. Abstract Interpretation: A Uniﬁed Lattice Model
forStaticAnalysisofProgramsbyConstruction orApproximation of Fixpoints.
InConference Record of the Fourth Annual ACM SIGPLAN-SIGACT Symposium on
Principles ofProgrammingLanguages . ACM Press,238–252.
[13]FrankS.deBoerandMarcelloM.Bonsangue.2019. OntheNatureofSymbolic
Execution. In Formal Methods - The Next 30 Years - Third World Congress, FM
2019,Proceedings (LectureNotesinComputer Science,Vol.11800) , Maurice H. ter
Beek, Annabelle McIver, and José N. Oliveira (Eds.). Springer, 64–80. https:
//doi.org/10.1007/978-3-030-30942-8_6
[14]Edsger W. Dijkstra. 1988. On the cruelty of really teaching computing science .
Center for American History, University of Texas at Austin. http://www.cs.
utexas.edu/users/EWD/ewd10xx/EWD1036.PDF EWD-1036.
[15]AndreaFioraldi,DominikChristianMaier,HeikoEißfeldt,andMarcHeuse.2020.
AFL++:CombiningIncrementalStepsofFuzzingResearch.In 14thUSENIXWork-
shoponOﬀensiveTechnologies ,YuvalYaromandSarahZennou(Eds.).USENIX
Association. https://www.usenix.org/conference/woot20/presentation/ﬁoraldi
[16]EduardoGiménez.1996. Anapplicationofco-inductivetypesinCoq:Veriﬁcation
of the alternating bit protocol. In Types for Proofs and Programs , Stefano Berardi
andMarioCoppo(Eds.).SpringerBerlinHeidelberg,Berlin,Heidelberg,135–152.
[17]Eduardo Giménez and Pierre Castéran. 2007. A Tutorial on (Co-)Inductive Types
in Coq. Available at https://www.labri.fr/perso/casteran/RecTutorial.pdf .
[18]Patrice Godefroid. 2005. The Soundness of Bugs is What Matters (Position
Statement).In PLDI’05WorkshopontheEvaluationofSoftwareDefectDetection
Tools(BUGS’05),Proceedings .https://patricegodefroid.github.io/public_psﬁles/
bugs2005.pdf
[19]Patrice Godefroid, Nils Klarlund, and Koushik Sen. 2005. DART: Directed Auto-
mated Random Testing. In Proceedings of the ACM SIGPLAN 2005 Conference on
ProgrammingLanguageDesign andImplementation(PLDI’05) ,VivekSarkar and
MaryW. Hall (Eds.).ACM,213–223. https://doi.org/10.1145/1065010.1065036
[20]Patrice Godefroid, Michael Y. Levin, and David A. Molnar. 2008. Automated
Whitebox Fuzz Testing. In Proceedings of the Network and Distributed Sys-
tem Security Symposium (NDSS’08) . The Internet Society. https://www.ndss-
symposium.org/ndss2008/automated-whitebox-fuzz-testing/
[21]Jacques-HenriJourdan,VincentLaporte,SandrineBlazy,XavierLeroy,andDavid
Pichardie. 2015. A Formally-Veriﬁed C Static Analyzer. In Proceedings of the
42ndAnnualACMSIGPLAN-SIGACTSymposiumonPrinciplesofProgramming
Languages(POPL’15) ,SriramK.RajamaniandDavidWalker(Eds.).ACM,247–259.
https://doi.org/10.1145/2676726.2676966
[22]TimotejKapusandCristianCadar.2017.AutomaticTestingofSymbolicExecution
EnginesviaProgramGenerationandDiﬀerentialTesting.In Proceedingsofthe
32nd IEEE/ACM International Conference on Automated Software Engineering
(ASE’17), Grigore Rosu, Massimiliano Di Penta, and Tien N. Nguyen (Eds.). IEEE
1175ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA Arthur CorrensonandDominic Steinhöfel
Computer Society. https://doi.org/10.1109/ASE.2017.8115669
[23]Steven Keuchel, Sander Huyghebaert, Georgy Lukyanov, and Dominique De-
vriese. 2022. Veriﬁed Symbolic Execution with Kripke Speciﬁcation Monads
(and no Meta-Programming). Proc. ACM Program. Lang. 6, ICFP (2022), 194–224.
https://doi.org/10.1145/3547628
[24]James C. King. 1976. Symbolic Execution and Program Testing. Commun. ACM
19,7 (1976). https://doi.org/10.1145/360248.360252
[25]Ralf Kneuper. 1991. Symbolic Execution: A Semantic Approach. Sci. Comput.
Program. 16,3 (1991), 207–249. https://doi.org/10.1016/0167-6423(91)90008-L
[26]XavierLeroy.2009. AFormallyVeriﬁedCompilerBack-end. J.Autom.Reason.
43,4 (2009). https://doi.org/10.1007/s10817-009-9155-4
[27]DanushkaLiyanage,MarcelBöhme,ChakkritTantithamthavorn,andStephan
Lipp. 2023. Reachable Coverage: Estimating Saturation in Fuzzing. In 45th
IEEE/ACMInternationalConferenceonSoftwareEngineering(ICSE’23),Proceedings .
ACM.https://mboehme.github.io/paper/ICSE23.Eﬀectiveness.pdf to appear..
[28]Dorel Lucanu, Vlad Rusu, and Andrei Arusoaie. 2017. A Generic Framework
forSymbolicExecution:ACoinductiveApproach. J.Symb.Comput. 80(2017),
125–163. https://doi.org/10.1016/j.jsc.2016.07.012[29]Valentin Robert and Xavier Leroy. 2012. A Formally-Veriﬁed Alias Analysis.
InCertiﬁedProgramsandProofs(CPP2012) (LectureNotesinComputerScience,
Vol.7679) . Springer, 11–27.
[30]Rollbar.2021. TheStateofSoftwareCodeReport. https://content.rollbar.com/
hubfs/State-of-Software-Code-Report.pdf . Accessed:2023-01-24.
[31]Mary Shaw. 2003. Writing Good Software Engineering Research Papers. In
Proceedings of the 25th International Conference on Software Engineering, May
3-10, 2003, Portland, Oregon, USA , Lori A. Clarke, Laurie Dillon, and Walter F.
Tichy(Eds.).IEEEComputerSociety,726–737. https://doi.org/10.1109/ICSE.2003.
1201262
[32]MatthieuSozeau,SimonBoulier,YannickForster,NicolasTabareau,andThéo
Winterhalter. 2020. Coq Coq correct! Veriﬁcation of Type Checking and Erasure
for Coq, in Coq. Proc. ACM Program. Lang. 4, POPL (2020), 8:1–8:28. https:
//doi.org/10.1145/3371076
[33]Dominic Steinhöfel. 2020. Abstract Execution: Automatically Proving Inﬁnitely
ManyPrograms . Ph.D.Dissertation.DarmstadtUniversityofTechnology,Ger-
many.http://tuprints.ulb.tu-darmstadt.de/8540/
[34]FrédéricVogels,BartJacobs,andFrankPiessens.2015. FeatherweightVeriFast.
Log.MethodsComput.Sci. 11,3(2015). https://doi.org/10.2168/LMCS-11(3:19)2015
Received 2023-02-02; accepted 2023-07-27
1176