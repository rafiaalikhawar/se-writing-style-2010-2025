Inferring and Applying Type Changes
Ameya Ketkarâˆ—
Uber Technologies Inc.
USA
ketkara@uber.comOleg Smirnov
JetBrains Research
St Petersburg University
Russia
oleg.smirnov@jetbrains.comNikolaos Tsantalis
Concordia University
Canada
nikolaos.tsantalis@concordia.ca
Danny Dig
University of Colorado Boulder
USA
danny.dig@colorado.eduTimofey Bryksin
JetBrains Research
HSE University
Russia
timofey.bryksin@jetbrains.com
ABSTRACT
Developersfrequentlychangethetypeofaprogramelementand
update all its references to increase performance, security, or main-
tainability. Manually performing type changes is tedious, error-
prone,anditoverwhelmsdevelopers.Researchersandtoolbuilders
have proposed advanced techniques to assist developers when per-
forming type changes. A major obstacle in using these techniques
is that the developer has to manually encode rules for defining the
typechanges.Handcraftingsuchrulesisdifficultandofteninvolves
multiple trial-error iterations. Given that open-source repositories
containmanyexamplesoftype-changes,ifwecouldinfertheadap-
tations,wewouldeliminatetheburdenondevelopers.Weintroduce
TC-Infer,anoveltechniquethatinfersrewriterulesthatcapture
the required adaptations from the version histories of open source
projects.Wethenusetheserules(expressedintheCombylanguage)
as input to existing type change tools. To evaluate the effective-ness of TC-Infer, we use it to infer 4,931 rules for 605 popular
typechangesinacorpusof400Kcommits.Ourresultsshowthat
TC-Inferdeducedrewriterulesfor93%ofthemost populartype
changepatterns.Ourresultsalsoshowthattherewriterulespro-
ducedbyTC-Inferarehighlyeffectiveatapplyingtypechanges
(99.2% precision and 93.4% recall). To advance the existing tooling
we released IntelliTC, an interactive and configurable refactoring
plugin for IntelliJ IDEA to perform type changes.
KEYWORDS
Refactoring, source code mining, type change, type migration
ACM Reference Format:
Ameya Ketkar, Oleg Smirnov, Nikolaos Tsantalis, Danny Dig, and Tim-
ofey Bryksin. 2022. Inferring and Applying Type Changes. In 44th Inter-
national Conference on Software Engineering (ICSE â€™22), May 21â€“29, 2022,
âˆ—Ameya Ketkar performed this work as part of his PhD at Oregon State University.
This work is licensed under a Creative Commons Attribution International 4.0 
License.
ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
Â© 2022 Copyright held by the owner/author(s).
ACM ISBN 978-1-4503-9221-1/22/05.
https://doi.org/10.1145/3510003.3510115Pittsburgh, PA, USA. ACM, New York, NY, USA, 13 pages. https://doi.org/10.
1145/3510003.3510115
1 INTRODUCTION
As programs evolve, the types of program elements are changed
for several reasons, such as improving performance [13â€“15] (e.g.,
Stringâ†’StringBuilder ),maintainability [9] (e.g.,Stringâ†’Path ), in-
troducing concurrency [10](e.g.,HashMapâ†’ConcurrentHashMap ),han-
dlingdeprecation orperforming librarymigration [1,29,55](e.g.,
org.apache.commons.logging.Logâ†’org.slf4j.Logger ).Sucharefactor-
ing where the type of a program element (i.e., variable, field, or
method) is updated, and then type constraints of the new type are
propagated to the code base by adapting the code referring to this
element, is called a type change.
Despite that developers perform type changes more fre-
quently[31]thanpopularrefactoringssuchas rename,toolsupport
for type changes is negligible compared to refactoring automation.
Developerspredominantlyperformtypechangesbyhand[ 31].This
can be tedious, error-prone and it can easily overwhelm the devel-
opers. Researchers [ 5,22,30,36,41,54,58,59] and tool builders
[2,16,28,43] have proposed techniques that assist developers in
performing these type changes.
The Achilles heel of these techniques is that the user has to
manually encode the syntactic transformations required to per-
formthedesiredtypechanges.Whilethesetechniquesallowthe
transformations to be expressed as rewrite rules over templates of
Javaexpressions,theyarestillmanualandlabourintensivebecause
itrequiresdeveloperstoencodethetransformations.Whenade-
veloper is unfamiliar with some types, they would have to ask a
co-developer or look up the documentation (which could be out-
dated or unavailable), release notes, or Q&A forums to understand
how to correctly adapt the code to perform the type change. Even
whendevelopersarefamiliarwiththetypesinvolvedinthetype
change,usingsuchprogramtransformationsystemsisnotstraight-
forward (their learning is measured in weeks or months [ 7,32]).
This introduces a barrier to the adoption of these techniques.
Giventhatmanysoftwareevolutiontasksarerepetitivebyna-
ture [23,45,46], our key insight is that developers from multiple
open-sourceprojectsapplysimilartypechangesintheirprojects.
Inourpreviousstudy[ 31]overacorpusof400,000typechanges
performed in 130 open source projects, we observed that 68% of
12062022 IEEE/ACM 44th International Conference on Software Engineering (ICSE)
ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Ameya Ketkar, Oleg Smirnov, Nikolaos Tsantalis, Danny Dig, and Timofey Bryksin
Table 1: Motivating Examples
Element Before Element After Usages Before Usages After RewriteRule
1.int x; longx ; x=0 ; x=0 L; :[nâˆ¼\d+]â†’:[n]L
2.File x; Pathx; x.exists() Files.exists (x) :[r].exists() â†’Files.exists( :[r])
3.new FileOutputStream(
new File(x, fName))Files. newOutputStream (
x.resolve(fName))new FileOutputStream(
new File( :[a],:[b]))â†’
Files.newOutputStream(
:[a].resolve( :[b]))
4.boolean x; AtomicBoolean x;x = true; x.set(true); :[l]=:[râˆ¼true]â†’:[l].set(:[râˆ¼true])
5.:[t]x; Optional <:[t]> x; x.substring(1,5) x.get().substring(1,5) :[r]â†’:[r].get()
6. x = null; x = Optional.empty(); nullâ†’Optional.empty()
7. Optional.of(Utils.trx(x)) x. map(Utils ::trx)Optional.of( :[r].:[m](:[a]))â†’
:[a].map(:[r] :::[m])
8.Optional<Integer> x; OptionalInt x; x = Optional.empty(); x = OptionalInt .empty(); Optional.empty() â†’OptionalInt.empty()
9.AtomicLong x; LongAdder x; x.get() x. sum() :[r].get()â†’:[r].sum()
10. x.set(0) x.reset() :[r].set(0)â†’:[r].reset()
11.List<:[t]> xs; Set<:[t]> xs; xs = new ArrayList<>(items); xs = new HashSet<>(items);new ArrayList<>( :[a])â†’
new HashSet<>( :[a])
12. xs.get(0) xs.iterator().next() :[r].get(0) â†’:[r].iterator().next()
them were performed in more than one commit. If we could har-
ness this rich resource of type change examples, we could infer
the adaptations and reduce the burden on the developers. This will
improve the applicability and utility of the current type change
techniques.
In this paper we introduce a technique, TC-Infer, that learns
the task of performing type changes by analyzing several exam-
ples of how other open source developers have performed the
same type change previously. First, TC-Infer mines the commit
historyofprojectsandidentifiestypechangesandotherrefactor-
ingsperformed.Then,TC-Inferanalyzesthemtodeducerewrite
rules that capture the required adaptations to perform the type
change.Therulesproducedbyourtechniquecanbereadilyused
byexistingstate-of-the-practicetypemigrationtoolslikeIntelliJ
Platformâ€™s Type Migration[ 28], or state-of-the-art tools that use
typeconstraints[ 5]ortype-factgraphs[ 30].Weleveragetwostate-
of-the-arttechniques:(i)RefactoringMiner[ 31,56]toidentify
refactorings and (ii) Comby [ 57] to represent and perform light-
weightsyntaxtransformationsasrewriterulesovertemplatesof
Java expressions. Particularly, our technique TC-Infer accepts the
typechangesreportedbyRefactoringMinerasinputandreturns
rewrite rules for these type changes as Comby templates.
To evaluate the applicability of TC-Infer, we applied it to infer
rewrite rules for the most popular type changes applied in our
corpus of 400K commits from 130 projects. We found that TC-
Infer reported 4,931 rewrite rules for 522 popular type changes
from our corpus. These type changes are diverse in nature: they
comprised (1) varied type kinds (e.g., primitives, paramterized
types), (2) varied namespaces (e.g. JDK, project specific types or
external third-party library types), (3) interoperable types (e.g.,
StringBuffer â†’StringBuilder ), and non-interoperable types (e.g.,
Stringâ†’List<String> ).Further,todemonstratethe effectiveness of
TC-Inferintherealworld,weevaluateitsaccuracyonadatasetof
245commitscontaining3,060instancesof60diversetypechange
patterns. We manually validated the changes, and our results showthatrulesproducedbyTC-Inferhaveprecisionof99.2%andrecall
ranging from 60% upto 100%.
Wealsodemonstratetheutilityof TC-Inferbydevelopingaplu-
gin for the IntelliJ IDEA that provides assistance to developers to
performtypechanges.Toevaluatetheutilityof IntelliTC[ 53],we
runIntelliTConfourperformance-criticalopen-sourceprojects.
IntelliTCgenerated98typechangeswhichcompileandpasstests
successfully.Atthetimeofwriting,theoriginaldevelopershave
already accepted 43 of them.
In summary the paper makes the following contributions:
(1)TC-Infer analyses the previously performed type changes and
deduces the required adaptations as rewrite rules.
(2)IntelliTC assists developers at performing type changes by
surfacing the rules produced by TC-Infer in an IDE.
(3)We empirically evaluated our TC-Infer to demonstrate its ap-
plicability ,effectiveness ,trustworthiness ,andutility,andmake
our tools and data publicly available [52].
2 MOTIVATING EXAMPLES
Table 1 showcases a few scenarios that highlight the intricacies
associatedwith inferringthe rewriterules. Thefirst twocolumns
(Elements Before/After ) show the element whose type was changed,
the next two columns ( Usages Before/After ) present the adapted
usageoftheelement,andthelastcolumnpresentsthe RewriteRules
encoding the adapted usages using Comby template syntax[ 8]. For
instance, in row 9, the type change from AtomicLong toLongAdder
involves renaming the call site from gettosum. This adaptation
is represented by the rewrite rule :[r].get()â†’:[r].sum(). The
left side of the rule is an arbitrary Java expression with a template
variable ( :[r]binds the source code to template variable r), which
is matched to a program AST. The right side of the expression is
also a Java expression with holes, where each template variable
denotesasubstitutionwithanappropriatefragmentoftheprogram
AST, as matched on the left side.
1207Inferring and Applying Type Changes ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
Developers apply a wide variety of edit patterns to adapt the
usagesoftheelementtothetypechange:Addingthe Lsuffix(Ta-
ble 1, row 1), replacing an instance method with a static method
invocation (Table 1, row 2), updating a static method invocation
(Table 1, row 8), or updating a class instance creation (Table 1, row
11). Often theseedits adapt a commonly used idiomof a type. For
instance, in Table 1, row 12, when the type change from Listto
Setisperformed,theidiom xs.get(0) isreplacedwiththeidiom
xs.iterator().next() . Similarly in Table 1, row 7, when the vari-
ableiswrappedwiththe Optional datatype,theidiomthatinvolves
invokingastaticmethod Utils.trx(x) getsconvertedtousingthe
map()methodwithamemberreferencetothemethod Utils::trx .
Theadaptationscanalsoinvolveacompositionoftwoedits.Forin-
stance,inTable1,row3,thetypechangefrom FiletoPathrequires
the nested call to two constructors new FileOutputStream( ...)
andnew File( ...)to be converted to a static method invoca-
tionFiles.newOutputStream() andaninstancemethodinvocation
resolve() .Itcanreadilybeseenthatconstructingtheserulesby
hand can be cumbersome. However, all the current type migration
techniques require the user to do so.
Whilesometypechangesareperformedbetweeninter-operable
types(e.g., Fileâ†’PathorStringBuffer â†’StringBuilder ),otherscan
alter semantics (e.g. List<String> â†’Set<String ). Each type change
could have its own set of preconditions, apart from the gen-
eral ones described by Balaban et al. [ 5]. For instance, Dig et
al. [10] proposed special preconditions for introducing concur-
rency (Mapâ†’ConcurrentMap ), and Ketkar et al. [ 30] proposed special
preconditions for eliminating boxing. One can imagine that type
changeslike Listâ†’Set,LinkedList â†’Deque,orStringâ†’List<String>
will have their own set of specialized preconditions. Therefore,
proposingageneraltechniquethatcancompletelyautomatethe
application of any type change is extremely challenging. However,
giventhatadeveloperwantstoperformaparticulartypechange
(alteringsemanticsornot),itcanbeusefulifatoolcansuggest(and
apply) the transformations needed to adapt common idioms. For
instance, when performing a type change Listâ†’Set, developers
usually adapt the idiom new ArrayList<>() tonew HashSet<>() and
adaptxs.get(0) toxs.iterator().next() .Thegoalof TC-Inferisto
inferrewriterulesfortheadaptationsappliedtocommonsyntactic
idioms in previously performed type changes, and suggest these
rules to the user when performing the same type change.
3 TECHNIQUE
TC-Infer is a technique that produces the rewrite rules applied for
adaptingthesourcecodetoparticulartypechangepatterns(e.g.,
Stringâ†’Path) in the input commits. Figure 1 gives an overview
oftheTC-Inferpipeline.First,TC-Infercollectsalltypechange
instances and other refactorings identified by RefactoringMiner
in each input commit. RefactoringMiner uses its state-of-the-art
statement matching algorithm to match statements across com-
mits that accounts for refactorings like move class or method that
rearrange the statements in the program. It then groups the re-
portedtypechangeinstancesbythetypechangepatterntheyrelate
to. Note that each type change instance contains the associated
statement adaptations from the input commits. TC-Infer then pre-
processes each type change instance to account for overlappingrefactorings,suchasrenamingandextractingvariablesontopof
thestatementadaptations.Finally,TC-Inferinferstherewriterules
capturing each adaptation, and identifies relevant and safe edits
(seeSection3.4.4andSection3.4.5).Thefinalsetofrewriterulesex-
presses thesyntactic transformations required toadapt the source
code elements to perform a particular type change.
At the heart of TC-Infer is the AST differencing algorithm
InferRules (introduced in Algorithm 2) which involves two main
steps: (i)establishing themapping betweenmost similarnodes in
the AST, and (ii) deducing rewrite rules that if performed on the
former AST produces the later one.
3.1 Basic Concepts
We will now describe some basic concepts.
Definition 3.1 (AbstractSyntaxTree,AST) .Letğ‘‡beanğ´ğ‘†ğ‘‡.
Thetreeğ‘‡hasonerootnode.Eachnode ğ‘¡âˆˆğ‘‡,hasaparentğ‘âˆˆğ‘‡
(except for the root). Each node ğ‘¡âˆˆğ‘‡, has a list of children. Each
nodeğ‘¡âˆˆğ‘‡,hasanassociated label(i.e.,ASTnodekind)anda value,
which is a string.
Definition3.2 (Template) .Alightweightwayofmatchingsyn-
tactic structures of a programâ€™s parse tree, like expressions and
functionblocks.ForJava,itisbasicallyanarbitraryJavaexpression
with template variables (or holes), that is matched to a program
AST.
Recently, researchers van Tonder and Le Goues [57]proposed
Comby, a multi-language syntax transformation technique for
declaratively rewriting syntax with templates. We use the Java
instantiation of Comby as our templating engine. Details of the
syntax and matching behavior can be found on its website [8].
Definition3.3 (TemplateVariable) .AccordingtoCombyâ€™ssyn-
tax,:[n]bindsthesourcecodetoatemplatevariable n.Atemplate
variable can match all characters(including whitespace) lazily up
to its suffix (like .*? in regex) within its level of balanced delimiters.
The code snippet is matched to these kinds of template variables:
â€¢:[[a]]â€” matches identifiers, analogous to \w+ in regex.
â€¢:[nâˆ¼[+-]?(\d*\.)?\d+\$] and:[nâˆ¼\d+]â€” matches numbers.
â€¢:[hâˆ¼0[xX][0-9a-fA-F]+] â€” matches hexadecimals.
â€¢:[[excâˆ¼([A-Z][a-z0-9]+)+]] â€” matches class names.
â€¢:[[excâˆ¼\â€œ(.*)\â€œ]] â€” matches string literals.
â€¢:[câˆ¼[A-Z]+(_[A-Z]+)*] â€” matches constants.
â€¢:[n]â€” if none of the above.
Thesespecifickindsoftemplatevariablescapturerichercontext
wheninferringrewriterules,andminimizethespuriousapplication
of a rewrite rule.
Definition 3.4 (RewriteRule, ğ¿â†’ğ‘…).The left side of
RewriteRule is a Template that is matched to a program AST,
while the Template on the right side contains TemplateVariable
thatdenotethe substitutionwithanappropriatefragment ofthe
program AST, as matched on the left side. For instance, the rule
:[v].exists() â†’Files.exists( :[v])will match concrete instances
f.exists() andmngr.getResource().exists() , and rewrite them to
Files.exists(f) andFiles.exists(mngr.getResource()) ,respectively.
1208ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Ameya Ketkar, Oleg Smirnov, Nikolaos Tsantalis, Danny Dig, and Timofey Bryksin
Final set of rulesFinal set of rules
Type Change  
Instances & AdaptationsType Change  
Instances & AdaptationsType Change  
Instances & AdaptationsType Change  
Instances & AdaptationsType Change  
Instances & AdaptationsType Change  
Instances & Adaptations    Commit
Refactoring 
Miner
 e.g., Renaming  and Extract/Inline Variable  Other refactoringsType Change Instances &
Respective Adaptations...
......
InferRules RuleRule
Rule...Relevant &
Safe?Final set of
rewrite rulesPreprocessing     Commit
    Commit Filter & Group by corresponding pattern Type Change Pattern 
(e.g., String  to Path )
Type Change Instances &
Respective AdaptationsType Change Instances &
Respective Adaptations
...
......
Final set of rulesFinal set of rulesFinal set of
rewrite rulesFinal set of rulesFinal set of rulesFinal set of
rewrite rules...
...
Figure 1: The high-level overview of the TC-Infer pipeline.
Definition 3.5 (GetTemplateFor) .Given a codesnippet ğ‘, this
operationreturnsatemplatethatcapturesthestructureofanentire
code snippet. To generate such a template, the source code snippet
is parsed asAST, and each childof the root of theAST is replaced
with a template variable, iffthe child is not a special Java token(s)
(e.g.,keywordslike neworreturn,orspecialcharacterslike ,or;)(as
shown in Example 3.1). This idea of inferring structural templates
for code snippets is inspired from recent work by Luan et al. [38].
Definition 3.6 (Match).Givenatemplate ğ‘‡andacodesnippet
ğ‘,MatchreturnsamappingbetweentheTemplateVariablesin
ğ‘‡and syntactically valid sub-expressions of ğ‘iff the template ğ‘‡
matchestheentiresnippet ğ‘(asshowninExample3.1).Thisideaof
using templates to infer edit patterns is inspired from recent work
by Bader et al. [4].
Definition 3.7 (Substitute) .Given a Template ğ‘‡and mappings
fromTemplateVariablesin ğ‘‡tosyntacticallyvalidJavaexpres-
sions, Substitute returns the template ğ‘‡/primewhere the Template-
Variables in ğ‘‡are replaced with the corresponding expressions
(as shown in Example 3.1).
Definition 3.8 (Rewrite) .Given a rewrite rule ğ¿â†’ğ‘…or a list of
rulesğ¿1â†’ğ‘…1,...ğ¿ğ‘›â†’ğ‘…ğ‘›and a code snippet ğ‘, this operation
applies (sequentially) the input rewrite rule on ğ‘.
Definition 3.9 (Intersect( âˆ©)).Given two matches ğ‘š1 andğ‘š2
(i.e., the output of the Match operation), this operation returns
a mapping between TemplateVariables across ğ‘š1 andğ‘š2 that
bind to the same value. In other words, it is a set intersection
over the values the TemplateVariables are bound to (as shown in
Example 3.1).
Definition 3.10 (Intersect-isSubtree( âˆ©ğ‘ )).Given two matches
ğ‘š1andğ‘š2thisoperationreturnsamappingbetweenTemplate-
VariablessuchthatthethevalueboundtotheTemplateVariables
ofğ‘š2 is a subtree of the values bound to TemplateVariables of
ğ‘š1 (as shown in Example 3.1).
Definition3.11 (Difference( âˆ’)).Giventwomatches ğ‘š1andğ‘š2,
the operation ğ‘š1âˆ’ğ‘š2 would return TemplateVariables from
ğ‘š1 that are bound to a value that no variable in ğ‘š2 binds to. In
other words, it is a set difference operation over the value that
the TemplateVariables are bound to. This operation returns a
list of TemplateVariables sorted by size of its value (as shown in
Example 3.1).Example 3.1. Some basic operations with Templates:
c1=x.substr(1)
c2=x.get().substr(1)
t1=GetTemplateFor (c1)#:[r].:[m](:[aâˆ¼\d+])
t2=GetTemplateFor (c2)#:[râ€™].:[mâ€™](:[aâ€™âˆ¼\d+])
m1=Match(c1,t1) #{r:x,m:substr,a:1}
m2=Match(c2,t2) #{râ€™:x.get(),mâ€™:substr,aâ€™:1}
s1=Substitute (t1,{r:foo()} )#foo().:[m](:[a])
m1âˆ©m2â†’{m:mâ€™, a:aâ€™}
m2âˆ©ğ‘ m1â†’{râ€™:r}
m1âˆ’m2â†’[r]
RenameTemplateVars (t1,{r:x}) â†’:[x].:[m](:[a])
3.2 Input
WeuseRefactoringMinertocollecttypechangesandotherrefac-
toringsperformed.RecentlyTsantalisetal . [56]haveshownthat
RefactoringMiner can detect type changes with 99 .7% precision
and94.8%recall.Inparticular,itreportsfourkindsoftypechanges:
Change Variable Type ,Change Parameter Type ,Change Return Type ,
andChange Field Type , along with the relevantstatements up-
dated across the commits that refer to the element whose type
has changed, i.e., statements in the def-use chain (Figure 2). These
matched statements could be a subset of all the statements that
wereactuallyadaptedtoperformthetypechange.Identifyingall
adaptedstatementswouldrequireadditionaltype-bindinginforma-
tion and call-graph analysis, but RefactoringMiner works purely
on syntax. As input, our technique accepts a set of type change
instances reported by RefactoringMiner.
3.2.1Pre-processing .It has been observed by previous re-
searchers [ 31] that type changes are often complemented with
otherrefactoringslike renaming andextract/inlinevariable .Ho w-
ever, these refactorings are not mandatory to be performed when a
typechangeisperformed.Therefore,wenormalizethecollected
adaptationsbyundoingtherenamingandextract/inlinevariable
refactoring in the snippets. These key insights reduce the delta
between the statement mappings reported by RefactoringMiner,
thus reducing the number of noisy rewrite rules produced.
3.3 Output
For each type change pattern (i.e., intâ†’longor
Stringâ†’Optional<String> ) performed in the input type
1209Inferring and Applying Type Changes ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
1-Filefldr;
2+Pathfldr;
3-readfldr (fldr,mode,extensions )
4+readfldr (fldr.toFile(),extensions .toString ())
5-newResourceHandler (dir,newHandler (
6- newFile(fldr)))
7+newResourceHandler ().set(newHandler (
8+ Paths.get(fldr)),dir)
9-newFileOutputStream (newFile(fldr,"test.txt"))
10+Files.newOutputStream (fldr.resolve ("test.txt"))
Figure 2: Type Change Instance reported by Refactoring-
Miner for the type change pattern Fileâ†’Path
change instances, our technique will produce a set of rewrite rules
that can adapt the usages (type dependent idioms) to the new type.
TransformationSpec ::=TypeChangePattern RewriteRules
TypeChangePattern :: =RewriteRule
RewriteRules :: =RewriteRule GuardsRewriteRules |âˆ…
Guards::=TemplateVariable Guard Guards |âˆ…
Guard::=Type Guard |regex Guard |âˆ…
As shown above, TransformationSpec contains a Type-
ChangePattern which is basically a RewriteRule like intâ†’long
orList<:[t]>â†’Set<:[t]>,andtheRewriteRulesthatcapturethe
necessary adaptation. In RewriteRules, each RewriteRule is as-
sociated to Guards, where these guards constrain the code snippet
thatbindstotheTemplateVariables,eitherbasedon regularex-
pressions and/or the return type of the code snippet. We obtain
thisinformationfromthetypeinferenceprovidedin EclipseJDT.
For instance, for the rule :[r].exists() â†’Files.exists( :[r])
from Table 1, row 2, we record that the return type of risFile.
Similarly in the rule :[nâˆ¼\d+]â†’:[n]L, we infer twoguards â€” re-
turn type of nisintand that :[n]is a number literal. While the
regexGuardis expressed using the Comby language itself, we sepa-
rately record the Typeguard. These Guardsminimize the spurious
matcheswhenapplyingtherewriterules. TransformationSpec is
basically an adaptation of the Twining syntax proposed by Nita
andNotkin [48]totheCombylanguagewithadditional regexbased
guards.TherewriterulesencodedintheCombysyntaxcanbeloss-
lessly translated to the IntelliJ Platformâ€™s structural replacement
templates [ 27] or to the DSL proposed by Balaban et al. [ 5] and
Ketkaretal.[ 30],sinceallofthesearecloselyrelatedtotheTwining
syntax. For each rewrite rule, TC-Infer also reports the real-world
instances where the rewrite rule were performed.
3.4 TC-Infer
3.4.1Generating the RewriteRules .Given two versions of a
codesnippet,thegoalof GenerateRewriteRuleinAlgorithm1
is to deduce the rewrite rule applied across them. The higher level
intuitionisthefollowing:(1)capturethestructureofthebeforeand
after code snippets as templates ( ğ‘‡1andğ‘‡2), and (2) infer rewrite
rules by mapping the holes of ğ‘‡1to the holes of ğ‘‡2, if possible.
Example 3.2. Lets consider a simple example (Table 1, row 4).
1-x=true;
2+x.set(true);
AsdescribedinAlgorithm1,wefirstconstructastructuraltemplate
(Definition 3.5) that matches the two code snippets: :[lh]=:[rh]
and:[r].:[m](:[a])(Line 10). The two structural templates andAlgorithm 1 Generate Rewrite Rules
1:function RefineRule( LHS,RHS)
2:RHSâ†RenameTemplateVars (RHS,LHSâˆ©RHS)
3:if any(LHSâˆ©ğ‘†RHS)or any(RHSâˆ©ğ‘†LHS)then
4: LHS,RHSâ†Decompose( LHS,RHS)
5: LHS,RHSâ†/anticlockwiseRefineRule( LHS,RHS)
6:LHSâ†Substitute (LHS,LHSâˆ’RHS)
7:RHSâ†Substitute (RHS,RHSâˆ’LHS)
8:returnRHS,LHS
9:function generateRewriteRule( c1,c2)
10:LHS,RHSâ†[Match(c,GetTemplateFor (c))forcin[c1,c2]]
11:returnRefineRule (LHS,RHS)
theirrespectivematches( {lh:x, rh:true} and{r:x, m:set, a:true} )
are passed to RefineRule. Then the TemplateVariables that
map across the two templates ( LHSâˆ©RHSfrom Definition 3.9),
are consistently renamed (Line 2), i.e., lhâ†’randrhâ†’a. Fi-
nally, the TemplateVariables that do not map across the two
templates ( LHSâˆ’RHS/RHSâˆ’LHS) are substituted with their
concrete values (Line 6 & Line 7), resulting in the rewrite rule
:[lh]=:[rh]â†’:[lh].set(:[rh]).
Example3.3. Letâ€™sconsidertheadaptation(Table1,row7)ap-
plied to perform the type change from :[t]â†’Optional< :[t]>.
1-Utils.trx(s)
2+s.map(Utils::trx)
The structural template capturing the structure of these snip-
petsare :[r].:[m](:[a])and:[râ€™].:[mâ€™](:[aâ€™]) respectively.Con-
sequently, the matches produced are LHS={r:Utils, m:trx, a:s}
andRHS={râ€™:s, mâ€™:map, aâ€™:Utils::trx} . SinceLHSâˆ©RHS=
{a:râ€™}, we update the RHSto:[[a]].:[[mâ€™]](:[[aâ€™]])in Line 2
(i.e.,r/primerenamed to a. In Line 3 we check if any template vari-
ablesneedtobefurtherdecomposed( LHSâˆ©SRHS={r:aâ€™, m:aâ€™} ).
Next, the source code bound to the variables ğ‘/primeis decomposed
into the template ( :[x] :::[y]) and is substituted into the RHS
:[[a]].:[mâ€™](:[[x]]:::[y]).Intherecursivecallthecommonvari-
ables are consistently renamed, i.e., ğ‘¥â†’ğ‘Ÿ,ğ‘¦â†’ğ‘šand the
unmatched template variables are substituted with their con-
crete values, resulting in the rewrite rule :[[r]].:[m](:[a])â†’
:[a].map(:[[r]]:::[m]).
3.4.2Establishing Mappings .As described in Section 3.2, for
eachelementwhosetypehaschanged,RefactoringMinerreports
therelevantcode snippets that are adapted, but it does not capture
the exact editsthat are performed across thetwo snippets. In this
section we will explain Algorithm 2, that looks for mappings be-
tweenthetwomatchedstatementsreportedbyRefactoringMiner.
ThisAlgorithm2isbasedonhowdeveloperswouldnaturallyat-
tempt to construct rewrite rules â€” search for unmodified pieces
of code, then from the remaining figure out which containers of
source code can be mapped to each other and then finally look for
the precise mappings between the code snippets in the mapped
containers. InferRules produces a flattened list of rewrite rules
that capture the atomic edits and composite edits.
Example 3.4. Letâ€™s consider the following statement from Fig-
ure 2 adapted to perform the type change Fileâ†’Path.
1-newResourceHandler (dir,newHandler (newFile(fldr)))
1210ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Ameya Ketkar, Oleg Smirnov, Nikolaos Tsantalis, Danny Dig, and Timofey Bryksin
Algorithm 2 The InferRules procedure
1:function getWeights( n1,n2):
2:Rulesâ†InferRules (n1,n2)
3:returnMax(NumberOfTokensBoundToVars (Rules))
4:function getOptimalPairs( ns1,ns2)
5:returnHungarianMethod (ns1,ns2,getWeights )
6:function InferRules( n1,n2)
7:if notisIsomorphic (n1,n2)then
8: (LHS,RHS)â†GenerateRewriteRule (n1,n2)
9: subRules â†[ ]
10: forc1,c2 ingetOptimalPairs (n1.children,n2.children)do
11: subRules.ğ‘’ğ‘¥ğ‘¡ğ‘’ğ‘›ğ‘‘(InferRules (c1.value,c2.value))
12: coarsestEdits =largestNonOverlapping (subRules)
13: ifRewrite (coarsestEdits ,n1)==n2then
14: ifRewrite ((LHS,RHS),n1)==n2then
15: returnsubRules.ğ‘ğ‘ğ‘ğ‘’ğ‘›ğ‘‘((LHS,RHS))
16: returnsubRules
17: else
18: (LHS,RHS)â†Merge(subRules,(LHS,RHS))
19: ifRewrite ((LHS,RHS),n1)==n2then
20: return[(LHS,RHS)]
21:return[]
2+newResourceHandler ().set(newHandler (
3+ Paths.get(fldr)),dir)
Forthegiveninputnodes ğ‘›1andğ‘›2,TC-Inferfirstcomputesthe
rewritetemplate new:[c](:[s],new Handler(new File(fldr))) â†’new
:[c]().set(new Handler(Paths.get(fldr), :[s])byinvokingGener-
ateRewriteRule (Algorithm 1). The variable fldrwas not gen-
eralized here because generateRewriteRule only decomposes
thetwotemplatevariables LHSandRHSiftheyintersect(Defini-
tion3.9)orintersect-subtree(Definition3.10).Todeducemorefine-
grainedmappings,TC-Inferattemptstooptimallypairthechildren
ofthenodes ğ‘›1andğ‘›2.Naively,pairingthechildrenintheorder
they appear is not a sound approach for two main reasons: (i) AST
kind ofğ‘›1 may not be same as ğ‘›2 (in this example ğ‘›1 is of the kind
class instance creation andğ‘›2 is ofthe kind method invocation ), (ii)
childrenmightbereordered,addedorremoved(inthisexample,the
method setaccepts the arguments in the reverse order). Therefore,
inourexample,TC-Inferwillpair new Handler(new File(fldr)) with
new Handler(Paths.get(fldr)) andsourceDir withsourceDir (Line10).
Consequently, it will pair new File(fldr) withPaths.get(fldr) , and
produce the rewrite rule new File( :[a])â†’Paths.get( :[a]).
To find optimal pairs, we implemented and applied the Hun-
garianmethod [34]thattacklesthe assignmentproblem (Line10).
Thisproblemconsistsoffinding,inaweightedbipartitegraph,a
matching of a given size, in which the sum of weights of the edges
isaminimum(ormaximum).Wetreatthetwolistsofchildrenas
thepartitionandmaximizethenumberoftokensboundtotemplate
variables in the rewrite rules inferred between the paired nodes.
The optimal pairing not only allows us to continue finding more
fine grained rules when the root node kinds do not match, but also
accounts for reordering or alteration of the children list. The meth-
ods getWeights and InferRules invoke InferRules (Line 11).
TC-Infer tabulate the inferred templates against the offsets of the
updated location to prevent this redundant computation.3.4.3Inferring Composite Rewrite Rules .
Example3.5. LetsconsidertheadaptationfromTable1,row3.
1-newFileOutputStream (newFile(fldr,"test.txt"))
2+Files.newOutputStream (fldr.resolve ("test.txt"))
WhiletheoperationgenerateRewriteRule candeducethetem-
plate variables for generalizing source code that is equal across the
edit,itcannotdeducecompositerewriterules.Inthisexample,first
TC-Infer computesthe rewriterule R1=new FileOutputStream(new
File(fldr,"test.txt")) â†’Files.newOutputStream(fldr.resolve("test
.txt")). At this step no template variables were inferred. Next,
it deduces finer mappings from new File(fldr,"test.txt") to
fldr.resolve("test.txt") . For this mapping, the template R2=new
File(:[a1],:[a2])â†’:[a1].resolve( :[a2])is deduced. After it has
collected the inferred rules for the optimal pairs of children nodes,
it identifies the largest non-overlapping rules (Line 12). It then
applies these edits to the input node ğ‘›1 and checks if it yields node
ğ‘›2. It can be observed that, in our example, applying the template
R2uponnew FileOutputStream(new File(fldr,"test.txt")) will not
yieldFiles.newOutputStream(fldr.resolve("test.txt")) . Therefore,
TC-Infer now attempts to merge the rewrite rules inferred for
the children R2into the rewrite rule learnt for the parent node
R1to produce R3-new FileOutputStream(new File( :[a1],:[a2]))â†’
Files.newOutputStream( :[a1].resolve( :[a2]))(Line 18). TC-Infer
will also report R2because it correctly captures the edit applied
between new File(fldr,"test.txt") â†’fldr.resolve("test.txt") .
The function InferRules returns a flattened tree of edits, where
thechildreneditsaremorefine-grainedthantheparentedit.There-
fore, in Line 13 when we check if subRules transform node ğ‘›1t o
nodeğ‘›2, we consider the coarsestsubrules (Line 12 largest non-
overlappingedits)becausetheselargerruleswillbemergedinto
composite rewrite rules of the fine-grained rules.
3.4.4Identifying relevant edits .The updated statements re-
portedbyRefactoringMinerforeachtypechangeinstancecan
also contain edits (some updated literals or expressions) that are
not type dependent upon the root of type change. We consider an
edit rewrite rule relevant to the type change from type ğ‘†to type
ğ‘‡,(i)ifthereturntypeoftheconcreteexpressioncapturedbythe
LHSof the rewrite rule is ğ‘†(e.g., object creation or literals), and
(ii) if the rewrite rule contains template variables that match an
expression (e.g., variable reference) of type ğ‘†.
3.4.5Eliminating UnsafeRewriteRules .Theproblemofex-
pressingachangeasarewriteruleisthatanytoken(s)thatdoes
not appear in the before input code snippet ( n1) but appears in
the after code snippet ( n2) will not be generalized as a hole. There-
fore, if the adaptation involves usage of a new variable or a new
string,TC-Infercannotgeneralizetheadaptationwithrespectto
thelargercontextbecauseithasaccesstotheASTthatmatchedthe
leftside.Growingthesizeofthematchtoincludethedeclaration
ofthevariablewillmaketherulecontextspecific.Moreover,itis
unclear how these scenarios could be expressed as rewrite rules.
TC-Infer eliminates such unsaferules from the output.
3.5 Comparison with Previous Work
Insteadof InferRules(i.e.Algorithm2), TC-Infer couldalsouse
othertechniquesthatapplyhierachicalorgreedyclusteringtech-
niques (Bader et al . [4], Rolim et al . [51]) suggested for inferring
1211Inferring and Applying Type Changes ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
recurring edit patterns. For instance, for a type change pattern we
could have (1) clustered all the corresponding adaptations from
our dataset and generalize the tree patterns, (2) then applied an-
ti-unification to generalize edit patterns, (3) then cluster the edit
patterns, and (4) finally identify the relevantedit patterns. This
would produce rewrite rules required for the TransformationSpec .
However,wedidnotadoptthisstrategybecause(1)clustering
tree patterns is an overkill for our problem which is constrained
to expression- and statement-level transformations, (2) we have to
account for overlapping refactorings and unrelated changes, (3) an-
ti-unificationfortermsmaynotinfercompositerules,and(4)many
instancesforeacheditpatternappliedtoadaptatypechangeare
unavailable (in most cases we have at most two examples).
4 EVALUATION
Tounderstand theeffectiveness, thereal-worldrelevance, andthe
utility of our technique, we answer four research questions:
RQ1.HowapplicableisTC-Infer? UsingTC-Inferisbeneficial
if rewrite rules inferred for a particular type change from one
commitcouldbeappliedinanothercommittoperformthesame
type change. Are such scenarios common?
RQ2.Can we trust the existing practices for performing type
changes? We investigate if manually performing type changes
could unknowingly introduce idioms for which there are better
alternatives. This will highlight the importance of standardizing
type changes with tools.
RQ3.How effective are the RewriteRules for performing type
changes? We compare the application of rewrite rules inferred by
TC-Infertothechangesperformedbyreal-worlddevelopers,to
highlight the benefits and the pitfalls of TC-Infer.
RQ4.Did developers find the RewriteRules useful? We inves-
tigate whether the rules produced by TC-Infer are useful to the
developers to perform type changes in their IDEs.
4.1 Dataset
Previously, we conducted the first large-scale and the most fine-
grainedempiricalstudy[ 31]ontypechangesperformedinopen
sourceJavarepositoriesonGithub.Inthispreviouswork[ 31]w e
mined297,543typechangesandtheirsubsequentcodeadaptations
from a diverse corpus of 129 Java projects containing 416,652 com-
mits. With this rich dataset we answered research questions about
the practice of type changes. This dataset contains instances of
types with diverse characteristics with respect to their visibility
(public, private), namespace (internal or application-specific, ex-
ternal,orJDK),kind(array,parameterized,simple,wildcard),and
the relationship between the source and target types. We base our
evaluation on thesame dataset, because the diversityof the types
involved in the type changes of this dataset will help to generalize
ourfindings.Wehadidentified605 populartypechanges performed
in our dataset1. We considered a type change popularif it was per-
formedinatleasttwouniqueprojects.Inthisstudy,weevaluate
theapplicabilityandeffectivenessof TC-Inferatinferringrules
for these popular605 type changes.
1https://zenodo.org/record/3906503#.Yfbnyy-B3T84.2 RQ1: How applicable is TC-Infer?
In this question we explore the type changes that can benefit from
TC-Infer,theirvariouscharacteristicsandhowapplicableisTC-
Infer for these type change patterns. We first applied TC-Infer
uponallinstancescorrespondingtothe605 populartypechange
patterns and collected 4,931 saferewrite rules for 522 type change
patterns (86.28%). Further, we identified 274 (52.49%) type changes
forwhichTC-Inferreportedatleastone prevalentrule .Weconsider
a ruleprevalent if it is applied to adapt to the same type change in
more than one commit. We identified 832 prevalent rules for the
274 type changes. By investigating the remaining 13.72% of type
changeswithnoreportedrule,wefound:(1)thesourceandthetar-
gettypes weresemantically sodifferent (e.g. Stringâ†’Map<Integer,
String>)thatnosaferewriterulecouldbeinferred;(2)thesource
andthetargettypeweresointer-operablethatitneedednoupdate
(e.g. replacing with super type, primitive widening, or boxing).
0 5 10 15 20 25 30 35# Popular RulesMinimum Commitsp-value=5.59e-01  H(2)=3.41e-01
Mean
Median
Figure3:Distributionofthenumberof prevalent rulesreportedfor
each type change and the minimum number of commits required
to infer the prevalent rules for each type change.
Figure 3 plots the distribution of the number of prevalent rules
reportedforthe274typechanges.Themean prevalent rulesinferred
foreachtypechangeis3.48. TC-Inferproducedone prevalent rule
for the type change Function<X,Integer> â†’ToIntFunction<X> , while
forlongâ†’intit produced 34 prevalent rules.
Analyzing a single commit where a particular type change is
performed will not surface all prevalent rules, because the updated
code may not use all corresponding APIs. The number of commits
requiredtoinferallprevalentruleshasadirectimpactontheappli-
cabilityof TC-Infer,becausesometypechangesmaynot beper-
formedinmanycommits.Toevaluatethis,weidentifythesmallest
setofcommitsthatcontainall prevalent rulesforeachtypechange.
Computingthissmallestsetofcommitscanbeviewedasa SetCover
problem.Givenasetofelements {1,2,...,ğ‘›}(calledtheuniverse,
in our case, all prevalent rewrite rules for each type change) and a
collection ğ‘šofsets(inourcase,thesearethe prevalent rewriterules
appliedinthecommits)whoseunionequalstheuniverse,theset
cover problem is to identify the smallest sub-collection of ğ‘†whose
union equals the universe with the minimum weight. While this
problem is NP-Complete , its greedyapproximationalgorithm [ 61]
suffices for our purpose, since the cardinality of our universe is
not very large ( â‰¤34). Figure 3 plots the distribution of the cardi-
nality of the minimum set for each of the 274 type changes. On
average, TC-Infer required approximately two commits to infer
all prevalent rewrite rules for a type change, and required at most
18 commits to infer the 34 rules for the intâ†’longtype change.
Thenumberof prevalent rulesdependonvariousfactors,such
as the source and target type, the availability of examples, and the
1212ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Ameya Ketkar, Oleg Smirnov, Nikolaos Tsantalis, Danny Dig, and Timofey Bryksin
ability of TC-Infer to infer rules from the previously applied type
changes.Itisnotpossibletodetermineif TC-Inferhasinferredall
possiblerewriterulesforaparticulartypechange.Intuitively,all
possible rewrite rules for a type change are complete when they
cover all the instance methods/constructors/fields in the source
type. Previous researchers Li et al . [37]adopt this convention in
their formalization of API migrations. However, this is not applica-
bletotypechanges,sincetypechangeshavetoconsider allpossible
usagesofaparticulartype.Forinstance,whenupdatingwrapper
methods( Integer.toString(x) â†’Long.toString(x) ),itisnotpos-
sibletoenumerateallcommonstaticmethodinvocationsthatcould
act as such wrappers. Type changes can be semantics altering and
sometimesnomappingsarefoundforanymembermethodorfield
(e.g.,x.trim()â†’x.get().trim() ).
TC-Infer deduced rules for diverse type change patterns:
(1)Involvedvarietyof AST Node Kinds likeprimitive,simple,pa-
rameterized, or array types (e.g., intâ†’long,intâ†’OptionalInt ), or
byte[]â†’ByteBuffer )
(2)Involved JDKtypes,project-specific Internal typesorExternal
third party library types (e.g., Predicate â†’IntPredicate , Javaâ€™s
Listâ†’Guavaâ€™s ImmutableList ,o rStringâ†’hadoop.Path )
(3)Involved Interoperable (e.g.,Fileâ†’Path) andnon-Interop-
erable(e.g.,Listâ†’Set) type changes.
4.3 RQ2: Can we trust the existing practices for
performing type changes?
In this question we want to understand if the current practice of
performingtypechangesisreliableenoughtolearnfrom.Dode-
velopers introduce bugs, inconsistencies, or commonly disregarded
code idioms when performing type changes? This will highlight
the importance of standardizing type changes via tools.
Wefirstidentify populartypechangesfromourdataset,suchthat
the authors of the paper can easily find documentation and discus-
sions related to these types. For this purpose, we randomly sample
85 (approximately one-third) type change patterns from the 274
patternsforwhicha prevalent rulewasreported.Wethenexlude
allpatternsinvolving Internalorprojectspecifictypes,andidentify
60 type change patterns for which documentation and discussions
are publicly available. To answer this question, we manually inves-
tigate each ofthe 191 prevalent rewrite rules correspondingto the
60 type changes. The two authors that investigated these have five
and two years of professional software development experience,
respectively.Wecheckwhether(1)theruleiscorrect(i.e.,similarto
whatahumanwouldproduce)basedonthecorrespondingconcrete
examplesfromwheretherulewasinferred,(2)therulepreserves
the semantics, and (3) the rule does not introduce a commonly dis-
regardedcodeidiom.ThislistwasobtainedfromtheIntelliJIDEAâ€™s
Java Code Inspections [26].
Wefoundthatall191ruleswerecorrect,i.e.,similartowhata
humanwouldproducefromtheconcreteexample.Furtheranaly-
sis of the 191 rules revealed sixnonconforming rewrite rules, as
shown in Table 2 for four type changes. The first two rewrite rules
in the second column of Table 2 are semantically not the same,
because getCanonicalPath resolves the path by accessing the local
filesystem,whilethemethods getAbsolutePath andtoStringdonot.
Casting a longvalue to an inttype is an unsafe practice becauseitdoesnothandlethepossiblenumberoverflow,insteadJava8â€™s
Math.toIntExact isrecommended.Wenoticedthatintherealworld,
developers sometimes apply some nonconforming rules that intro-
duce unnecessary inconsistencies, performance, or maintainability
overheads. However, in the majority of cases the developers fol-
lowed the best practices, thus we can learn from the wisdom of
the crowd. This highlights the importance of standardizing the
adaptation for type changes using rewrite rules that are verified by
domain experts.
4.4 RQ3: How effective are the RewriteRules
for performing type changes?
Toevaluatatethe effectiveness ofrewriterulesinferredbyTC-Infer,
we replicate some type changes performed in our corpus and semi-
automatically compare them to the changes applied by the original
developer.Forthispurposewedeveloped IntelliTC,thatisbuilt
uponIntelliJâ€™sTypeMigration framework[ 28],andcanbeconfig-
ured via the TransformationSpec produced by TC-Infer. We then
compare the changes performed by IntelliTC to those performed
by the original developers.
4.4.1IntelliTC .This is our industry-strength tool [ 52] to per-
formtypechangesbyleveraging IntelliJâ€™sTypeMigrationframework .
ItallowsthedeveloperstoexpressrewriterulesasIntelliJPlatformâ€™s
structural replacement templates. Moreover, it operates in multiple
modalities: (1) the inspection mode suggests the user to perform
typechangesbasedontherecommendationsfromEffectiveJava
and other popular developer forums, (2) in the classic mode , devel-
oper can invoke IntelliTC as an intention action [25] (like rename
refactoring),and(3)IntelliTCovercomesthe discoverability and
late awareness [18,19] problem by surfacing certain type change
refactoringsthroughthe SuggestedRefactoring interface[ 24].Italso
collectsdetailed telemetry informationcapturinghowthedeveloper
is using IntelliTC. More details about IntelliTC and its usability
can be found in our accompanying tool demonstration paper.
4.4.2Identifying Test Scenarios .Choosing commits for evalu-
ating the effectiveness of our technique is not as straightforward as
in the case of API Migration [ 35,60], because randomly selected
commits might not be using all corresponding APIs and operators.
Therefore, for each type change pattern we identify the set of com-
mits that at leastcontains all popularadaptations from our dataset,
based on the minimum sets of commits identified in Section 4.2.
Toreplicatethetypechanges,weinvokedIntelliTCforeachin-
stance in the 245 commits and manually compare the replicated
type changes to the ones applied by the original developers.
4.4.3Validating the Edits .For each statement ğ‘ ğ‘containing
these type dependent idioms ( ğ‘’) in the parent commit ( ğ‘), we find
its matched statement ğ‘ ğ‘in the child commit ( ğ‘). To obtain the real
mapping (i.e., the adaptation applied by the original developer), we
search RefactoringMinerâ€™s reported statement mappings to find
amappingcontainingstatement ğ‘ ğ‘.If RefactoringMinerdoesnot
haveamapping for ğ‘ ğ‘,weget thisinformationfromthemapping
storeobtainedbyapplyingthe GumTree algorithm[ 17]uponthe
files containing ğ‘ ğ‘andğ‘ ğ‘. If any rewrite rule from our dataset
transforms ğ‘ ğ‘intoğ‘ ğ‘,weconsideritasa Truepositive .Otherwise,
werunInferRules(Algorithm2)uponthe realmapping andcollect
1213Inferring and Applying Type Changes ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
Table 2: Identified spurious rewrite rules introducing commonly disregarded idioms and the corresponding recommended rewrite rule
(ğ‘›: number of type change instances, ğ¶: number of commits, ğ‘ƒ: number of projects each rule is found in)
Type Change Spurious Rule n/C/P Recommended Rule n/C/P
Fileâ†’Path:[v].getCanonicalPath() â†’:[v].toString()
:[v].getCanonicalPath() â†’:[v].toAbsolutePath().toString()12/7/5
8/6/3:[v].getCanonicalPath()
â†’:[v].toRealPath().toString()15/8/3
Fileâ†’Path :[v].getAbsolutePath() â†’:[v].toString() 60/8/6:[v].getAbsolutePath()
â†’:[v].toAbsolutePath().toString()57/7/3
intâ†’long :[v]â†’(int):[v] 58/51/25:[v]â†’Math.toExactInt( :[v]) 8/4/4
:[t]â†’List<:[t]>:[v]â†’Arrays.asList( :[v]) 10/5/2:[v]â†’Collections.singletonList( :[v])9/5/2
:[t]â†’Optional< :[t]>:[v]== nullâ†’!:[v].isPresent() 2/2/1:[v]â†’:[v].isEmpty() 3/2/1
therewriterules( ğ‘…).Wethenapply ğ‘…(ifğ‘…â‰ âˆ…)upontheidentified
idioms in commit ğ‘, and manually validate:
(1)True Positive: the rule(s) ğ‘…applied on ğ‘ ğ‘correctly adapts to the
type change. In some scenarios, despite applying the correct
change,ğ‘ ğ‘cannot be transformed to ğ‘ ğ‘, because the original
developer had applied other unrelated overlapping changes.
(2)False Positive: the rule(s) in ğ‘…produces incorrect code, because
the rewrite rule mismatched when applied in context.
(3)NotApplicable: ğ‘…=âˆ…andtheperformedadaptationinvolvesus-
age of new additional functionality or other unrelated changes.
(4)FalseNegative: ğ‘…=âˆ…buttheperformedchangeis Applicable ,
implyingInfer couldnotcapturetheadaptationasarewriterule .
Note that running InferRules again on the real mapping pre-
vents us from counting a scenario false negative even when the
correctrewriterulewasunavailableinourdataset.Thesescenarios
occurbecauseRefactoringMinerâ€™sstatementmatchingalgorithm
fails to match and report these cases. We believe that Refactor-
ingMiner can be further fine tuned to handle these scenarios. Our
goal is to highlight the capabilities and expose the limitations of
TC-Infer at deducing rewrite rules, for further improvement.
4.4.4Results .In Table 3 we summarize the results of our ex-
periment, which evaluated 245 instances of type changes be-
longing to 60 diverse kinds. It can be seen that in almost all
the cases the precision is 100%. However, this is unsurprising
since TC-Infer is very conservative when producing rewrite rules
(pre-processing the snippets, and identifying relevant and safe
rules). Investigating the false positives revealed that other over-
lappingrefactoringsandsemanticnon-alteringchangesconfused
our technique (Algorithm 2). For instance, for the adaptation
(Long)Utilities.getRow() â†’(long)getRow() , InferRules could pro-
duced the rule (Long)Utilities. :[v]â†’(long):[v]because our tech-
nique does not account for Import as Static Method refactoring.
We are more interested in the recall of the rules produced by
our technique, i.e., the instances where our technique was not able
to produce any rule for a particular adaptation. It can be seen that
wehaverecallrangingfrom67%for java.io.File â†’fs.hadoop.Path
to 100% for AtomicLong â†’LongAdder . We manually investigated each
false negative and found three main reasons leading to them:
(1)Additional context is required . The most common reason
forTC-Infertoproducenorulesacrossagivenstatementmapping
(ğ‘ ğ‘â†’ğ‘ ğ‘) is that the adaptation requires more information from the
context than what was captured by the statement mappings. We
observedthat adaptationsuse elements (likevariables) existingin
the context or require new elements to be created in the context.
In the below example, the adaptation requires an instance variableTable 3: Evaluated type changes
Type Change n #A #UR TP NA P R
:[v0]â†’List<:[v0]> 95 43 15 27 9 1.00 0.79
:[v0]â†’Optional<:[v0]> 30 51 11 49 2 1.00 1.00
:[v0]â†’AtomicReference<:[v0]> 6 19 7 14 5 1.00 1.00
:[v0]â†’Supplier<:[v0]> 8 12 7 12 0 1.00 1.00
Entry<:[v1],:[v0]> â†’Entry<:[v0],:[v1]> 7 19 8 19 0 1.00 1.00
booleanâ†’AtomicBoolean 4 11 5 10 1 1.00 1.00
byte[]â†’ByteBuffer 36 51 15 49 2 1.00 1.00
ImmutableList<:[v0]> â†’ImmutableSet<:[v0]> 2 5 1 5 0 1.00 1.00
Mongoâ†’MongoClient 9 23 9 23 0 1.00 1.00
doubleâ†’int 4 16 4 8 8 1.00 1.00
floatâ†’double 124 49 17 48 1 1.00 1.00
intâ†’Duration 15 29 9 25 1 0.89 1.00
intâ†’AtomicInteger 4 15 5 15 0 1.00 1.00
intâ†’long 552 108 14 108 0 1.00 1.00
BufferedOutputStream â†’OutputStream 2 2 1 2 0 1.00 1.00
Fileâ†’Path 18 35 16 33 0 1.00 0.95
Fileâ†’hadoop.fs.Path 8 23 9 13 1 1.00 0.59
FileInputStream â†’InputStream 8 12 2 12 0 1.00 1.00
Booleanâ†’boolean 9 19 10 19 0 1.00 1.00
Integerâ†’int 190 48 39 45 1 1.00 0.96
Longâ†’long 24 61 20 58 1 0.95 1.00
Stringâ†’byte[] 38 10 4 7 3 1.00 1.00
Stringâ†’int 6 7 7 7 0 1.00 1.00
Stringâ†’File 26 33 8 31 2 1.00 1.00
Stringâ†’InetSocketAddress 2 6 2 6 0 1.00 1.00
Stringâ†’Path 11 18 5 16 2 1.00 1.00
Stringâ†’UUID 5 4 2 4 0 1.00 1.00
Stringâ†’regex.Pattern 18 12 7 12 0 1.00 1.00
StringBuffer â†’StringBuilder 517 105 4 103 2 1.00 1.00
Pathâ†’File 8 14 7 14 0 1.00 1.00
SimpleDateFormat â†’DateTimeFormatter 9 22 8 20 2 1.00 1.00
Dateâ†’Instant 15 25 7 21 3 1.00 0.95
Dateâ†’LocalDate 19 32 13 24 8 1.00 1.00
LinkedList<:[v0]> â†’Deque<:[v0]> 9 16 7 16 0 1.00 1.00
List<:[v0]> â†’ImmutableList<:[v0]> 15 12 4 11 0 0.92 1.00
List<:[v0]> â†’LinkedList<:[v0]> 9 24 4 22 1 1.00 0.96
List<:[v0]> â†’Set<:[v0]> 50 91 37 83 6 1.00 0.98
Map<:[v1],:[v0]> â†’ConcurrentMap<:[v1],:[v0]> 7 16 8 15 1 1.00 1.00
Map<String,String> â†’Properties 2 10 4 9 0 1.00 0.90
Optional<Integer> â†’OptionalInt 45 10 2 10 0 1.00 1.00
Queue<:[v0]> â†’Deque<:[v0]> 3 17 7 14 3 1.00 1.00
Queue<:[v0]> â†’BlockingQueue<:[v0]> 2 13 5 11 0 1.00 0.85
Randomâ†’SecureRandom 19 21 3 21 0 1.00 1.00
Stack<:[v0]> â†’Deque<:[v0]> 3 32 17 32 0 1.00 1.00
AtomicInteger â†’LongAdder 23 124 17 124 0 1.00 1.00
AtomicLong â†’AtomicInteger 2 11 3 6 5 1.00 1.00
AtomicLong â†’LongAdder 186 1026 22 1025 1 1.00 1.00
Function<:[v0],Boolean> â†’Predicate<:[v0]> 14 11 3 11 0 1.00 1.00
Function<:[v0],Integer> â†’ToIntFunction<:[v0]> 18 22 5 21 1 1.00 1.00
Supplier<Integer> â†’IntSupplier 8 15 2 15 0 1.00 1.00
longâ†’BigInteger 17 4 2 4 0 1.00 1.00
TemporaryFolder â†’File 9 34 2 14 8 1.00 0.54
longâ†’Duration 10 15 4 14 1 1.00 1.00
longâ†’Instant 7 13 13 13 0 1.00 1.00
longâ†’AtomicLong 3 9 4 8 1 1.00 1.00
GetMethod â†’HttpGet 15 45 7 40 5 1.00 1.00
Logâ†’Logger 424 300 6 295 5 1.00 1.00
ChannelBuffer â†’ByteBuf 39 59 12 32 15 1.00 0.93
DateTime â†’ZonedDateTime 283 256 25 249 3 1.00 0.98
CompositeSubscription â†’CompositeDisposable 9 33 10 28 5 1.00 1.00
n: Number of type change instances A: Number of type dependent idioms
UR: Number of unique rewrite rules applied TP: True Positives NA: Not
Applicable P:Precision R:Recall Notethat n,Aandtheratio n/Avary
based on the usage of the elements in the program
1214ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Ameya Ketkar, Oleg Smirnov, Nikolaos Tsantalis, Danny Dig, and Timofey Bryksin
of the type Channelfrom the context to replace the static method
invocation with instance method invocation.
1-finalChannelBuffer buffer=ChannelBuffers .buffer(6)
2+finalByteBuf buffer=channel .alloc().buffer(6)
Capturing such edits will require comparing the changed
data/control-flowacrossthecommitorreasonaboutmoresource
code surrounding the applied edit. Previous researchers [ 4,35,60]
havedevelopedtechniquesthatcancapturesuchcontexttoperform
library migrations and bug fixes. It is unclear how to declaratively
express and apply them as rewrite rules.
(2)Additional knowledge about the types is required .W e
foundthatadaptingstatementsforcertaintypechangesrequires
deep understanding about the difference between the semantics of
thebeforeandaftertype.Theseadaptationsinvolveidentifyingthe
mapping between the APIs, checking preconditions, and adapting
the current program to leverage the properties offered by the new
type.Inthisbelowexample,thedeveloperreplacedthecallto add
with a custom logic that added a new functionality to leverage the
constant time insertion that LinkedList offers via its addFirstand
addLastmethod.However,inferringtheadditionofnewfunction-
ality as a rewrite rule is currently out of the scope of TC-Infer.
1-List<String>ls
2-ls.add(e);
3+LinkedList <String>ls
4+if(pred)ls.addFirst (e);
5+elsels.addLast (e);
Similarly,weobservedthatwhendeveloperschangetypefrom List
toSet, they adapt the strategy that traverses the collection â€” from
iteratingoverthecollectionwithanindextousingthe Iterator.
Withlatestdevelopmentsin languageserverprotocols thischallenge
is surmountable.
(3)Additional inference is required . In many cases, only rea-
soning about the syntactic transformations is not enough, because
theadaptationalsoinvolvesadaptingthestringliterals.Inthebelow
example,theliteralisupdatedfrom â€œ/status.txtâ€ toâ€œstatus.txtâ€ ,
because the resolvemethod internally resolves the file separator.
Programsynthesistechniquesforstringmanipulationscaneasily
overcome this challenge [21].
1-Filef=newFile(projectFldr +"/status.txt")
2+Pathf=projectFldr .resolve ("status.txt")
Asanextremecaseinthiscategoryweobservedthatwhenthetype
change from StringBuilder to the new Java 8 type StringJoiner is
performed, the adaptation may require data flow and control flow
analysistounderstandhowthestringisbuilt,andthenencoding
this into the StringJoiner API.
4.5 RQ4: Did developers find the
RewriteRules useful?
To answer this question, we perform popular type changes from
our corpus that are also recommended by Effective Java [6], us-
ingIntelliTCinfourlargeopensourceprojects:ApacheFlink,
ElasticSearch,IntelliJ-CommunityandCassandra.Inpartic-
ular, we perform type changes that eliminate the misuse of Java
8â€™sFunctionalInterfaceAPI,e.g., Supplier<Long> â†’LongSupplier and
Optional API, e.g., Optional<Integer> â†’OptionalInt (Items 44 & 61
from [6]). We obtain the required specifications for eliminating
these misuses from the rewrite rules collected in RQ1 (Section 4.2).Finding any missed opportunity to specialize interfaces in such
projects is an important contribution because it eliminates boxing
(un-boxing), thus improving the performance.
IntelliTC performed 98 instances of type changes belonging
to 14 type change patterns that eliminate misuses of the Java 8
interfaces. These type changes updated 46 source code files and
affected 213 SLOC. After IntelliTC applied the type changes in
each project, we built it to ensure that the source code compiled
successfullyandalltestcasespassed.Fortwotypechanges,wehad
to manually perform edits to update the signature of overriding
methods (limitation of the current implementation). Next, we sent
out these type changes as pull requests to the maintainers of the
projects. At the time of writing the paper, twoPRs containing 43
type changes were accepted, and the rest are still under review.
5 LIMITATIONS AND THREATS TO VALIDITY
(1)Preconditions : Balaban et al . [5]laid out the basic pre-
conditions for safely performing a type change involving inter-
changeabletypes(e.g., Vectorâ†’ArrayList).However,theyarenot
alwaysenough.Digetal .[10]proposedadditionalpreconditionsto
safely update HashMaptoConcurrentHashMap . While TC-Infer effec-
tivelyinferstherewriterulesforadaptingthecommonsyntactic
idioms,itdoesnotinferpreconditionsforapplyingtherules.We
believe this isa very challenging problem that couldbe addressed
by capturing more context and analyzing dynamic traces. In our
proposed workflow, we tradeoff safety for broader applicability by
relying on the developerâ€™s wisdom in determining whether it is
safe to update the type.
(2)Version Awareness: For safely suggesting and applying type
changes in the real-world, the rewrite rules should be version spe-
cificsincetypesthemselvesevolveovertime(APIevoluton).This
limitationcanbeeasilyovercomebyanalyzingbuildsystemconfig-
uration files (like pom.xmlandbuild.gradle ) to identify the required
version of Java and other third party libraries.
(3)Language Independence: Currently TC-Infer is targetting
theJavalanguage,howeverconceptuallyitislanguageindependent
(notethatCombyisalsoamulti-languagesyntaxtransformation
technique).Theonlylanguagedependentmodulesare(a)Refac-
toringMiner and (b) GetTemplateFor (Definition 3.5). While
developing GetTemplateFor for other languages is straightfor-
ward, language-agnostic refactoring detection is also tractable. For
example,recentlyresearchersAtwietal .[3]reimplementedRefac-
toringMinerinPythontosupportthePythonlanguageaccounting
for its dynamic nature, whereas Dilhara [11]proposed a technique
thatJava-fiesPythonprogramsandenablesJavabasedASTanalysis
tools to process Python.
(4)External Validity: Do our results generalize? We studied 130
projects on Github from a wide range of application domain, mak-
ingtheresultsofthestudy generalizable tootherprojects.Moreover,
thetypechangesweusedforevaluatingtheapplicabilityandthe
effectivenessofourtechniquearediverseinnature(w.r.t.syntac-
tic category, name space or inter-operability). We show that the
produced rules can achieve high precision and recall.
(5)Internal Validity: Does our tool produce valid results? We
thoroughly evaluate the accuracy of the rewrite rules produced
by TC-Infer. To understand if the inferred rules can be trusted,
1215Inferring and Applying Type Changes ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
theauthorsmanuallyvalidatethe prevalent rulestoidentifynon-
conformingones.Moreover,wecreateanextensivesetupthatsemi-
automaticallyvalidatestheapplicationofrewriterulesforalarge
and diverse variety of type change patterns.
(6)Verifiability: Thecollecteddata,sourcecode,andexecutable
of TC-Infer and IntelliTC are publicly available [52].
6 FUTURE WORK
As seen in Section 4.2, TC-Infer could infer at least one rule for
86% of the popular type changes applied in the open source Java
repositories.InSection4.3,wereplicatethetypechangesperformed
by developers, and show that the rules produced by TC-Infer are
very effective (99.2% precision and 93.4% recall). While Section 4.4
shows that these applicable and effective rules should undergo
manual vetting, because they cannot be blindly trusted. For TC-
Infer to make impact in the real world it is important to reason
about (1) storing and accessing the inferred rules, (2) policies for
contributing new rules, and (3) maintainence of these rules.
We envision that our central database will contain two views:
(1) a general view that contains rules inferred for the common and
popular type changes performed in the version history of all the
participating projects, (2) a project-specific view that contains the
rulesinferredforthetypechangesperformedintheversionhistory
of a particular project. This database can be continuously updated
with each new commit. Each rule will be associated with the exact
location in the version history where it was performed, along with
someconfidencemetricsbasedonthenumberofprojects,commits
anddeveloperswhoperformedit.Theuserscouldalsomanually
submitnewrulestothedatabaseandbeabletoupvoteordownvote
rewriterulesbasedontheirunderstandingoftheAPIs/operators
(i.e., community-driven confidence). The majority of type changes
intheproject-specificviewwillbeapplicationspecifictypechanges
thatwillbeusefultothedevelopersoftheprojectandtheotherde-
pendentprojects(incaseofbreakingchanges).Incaseofcompeting
rules(i.e.,sameLHS,differentRHS),theusercanranktheserules
based on the communityâ€™s perspective and empirical evidence.
The most crucial aspect of maintaining and evolving rules is the
versionawareness. Tomake therules versionaware,we couldtake
a conservative approach by annotating the rules with the versions
intheassociatedrealworldexample.However,thiswillthoroughly
reduce the applicability of these type change rules. We believe we
needfurther researchtoinfer iftherewriterulesare backwardor
forward compatible.We believe human insightwill berequired to
maintain the quality of the rules. Therefore, our envisioned tool
leverages the communityâ€™s perspective and empirical evidence.
7 RELATED WORK
(1)Program Transformation Systems: Researchers have pro-
posedanarrayofadvancedprogramtransformationsystemsand
impressive meta-programming languages: (a) JunGL[58]i sa n
ML-style functional programming language that facilitates AST
manipulation with higher order functions and tree matching,
(b)Refcola[54] is a constraint language where refactorings are
specifiedbyconstraintrules,(c) Wrangler [36]providesrefactoring
commands to locate program elements and a DSL to execute the
commandsinthecontext,(d) Rascal[22]isascriptinglanguageto execute Eclipse JDT refactorings, and (e) Error-Prone [20]i s
astaticanalysistooltocatchandfixcommonprogrammingmis-
takesatcompiletime.Whiletheseadvancedsystemscanbeused
to encode type changes, Kim et al . [32]have shown that encoding
refactoringsinthese domainspecificlanguages hasanunncessary
overheadand asteeplearningcurve (weekstomonths).Other re-
searchers Balaban et al . [5], Ketkar et al . [30], Wright [59]have
developed frameworks specificallyto perform type changes based
on input transformation specifications. In contrast to all these sys-
tems,thegoalofourworkistoremovetheburdenonthedevelopers
to encode type changes in these DSLs.
(2)Inferring and Applying Edit patterns: Researchers have
proposedaplethoraoftechniquesthatcaninferandapplyavari-
ety of edit patterns from commit-level changes and finer IDE-level
changes:(a) GetAFix[4],Revisar[51],andDeepDelta [42]infer
fixes for bugs and compilation errors from commit histories of the
projectusingclustering, anti-unification ordeeplearningtech-
niques, (b) Refazer [50] applies program synthesis to fix incorrect
student assignments, while BluePencil [44] learns repetitive code
changeson-the-flyinanIDE,(c) CPATMiner andPy-CPATminer [12]
identify the repetitive andfrequent applied edit patterns in a code
reposiory (d) LibSync [47],A3[35] andMEditor [60] infer the
adaptationsrequiredtoperformlibrarymigrationbyanalyzingthe
changed control/data flow across the commit, (e) Kim et al . [33]
discoverandrepresentsystematicchangesaslogicruleswiththe
goal to enhance developerâ€™s understanding about the programâ€™s
evolution, and (f) Sydit[39],LASE[40],Repertoire [49] perform
systematic code changes by creating a context-aware edit script,
findingpotentiallocationsandtransformingthecode.Incontrast
to these works, the TC-Infer deduces rewrite rules for adapting
common syntactic idioms and IntelliTC automates them in the
IDE.
8 CONCLUSIONS
Type change is a crucial activity in evolving code bases. While
performing type changes manually is tedious, using the current
state-of-the-art type change automation techniques is not straight-
forward because it requires the developer to encode the adapta-
tionsinaDSL.Thispapereliminatesthisburdenonthedevelopers.
We present TC-Infer that deduces the rewrite rules required to
perform the type change from the version history. We evaluate
the TC-Inferâ€™s applicability for inferring rules for populartype
changes,andshowtheeffectivenessoftheserulesatperforming
3,060instancesof60diversetypechangepatterns.Wealsodevel-
opedIntelliTCandapplieditto eliminate98misusesoftheJava
8 APIs in four large open source projects.
9 ACKNOWLEDGEMENT
We would like to thank Rijanrd van Tonder, Martin Erwig, Ali
Mesbah, the CUPLV group at CU Boulder and other anonymous
reviewersfortheirinsightfulandconstructivefeedbacktoimprove
the work. This research was partially supported by NSF grants
CCF-1553741andCNS-1941898,NSERCgrantRGPIN2018-05095,
and by the Industry-University Cooperative Research Center on
Pervasive Personalized Intelligence.
1216ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Ameya Ketkar, Oleg Smirnov, Nikolaos Tsantalis, Danny Dig, and Timofey Bryksin
REFERENCES
[1]HusseinAlrubaye,DeemaAlShoaibi,MohamedWiemMkaouer,andAliOuni.
2019. HowDoesAPIMigrationImpactSoftwareQualityandComprehension?
An Empirical Study. (Jul 2019). https://arxiv.org/abs/1907.07724
[2] Apache. 2019. Netbeans Refactoring .
[3]HAtwi,BLin,NTsantalis,YKashiwa,YKamei,NUbayashi,GBavota,andM.
Lanza. SCAM. PyRef: Refactoring Detection in Python Projects. In SCAM, 2021 .
https://doi.org/PyRef/PyRef
[4]JohannesBader,AndrewScott,MichaelPradel,andSatishChandra.2019. Getafix:
LearningtoFixBugsAutomatically. Proc.ACMProgram.Lang. 3,OOPSLA,Article
159 (Oct. 2019), 27 pages. https://doi.org/10.1145/3360585
[5]Ittai Balaban, Frank Tip, and Robert Fuhrer. 2005. Refactoring Support for Class
LibraryMigration.In Proceedingsofthe20thAnnualACMSIGPLANConferenceon
Object-orientedProgramming,Systems,Languages,andApplications (SanDiego,
CA, USA) (OOPSLA â€™05) . ACM, New York, NY, USA, 265â€“279. https://doi.org/10.
1145/1094811.1094832
[6]Joshua Bloch. 2018. Effective Java (3 ed.). Addison-Wesley, Boston, MA. https://
www.safaribooksonline.com/library/view/effective-java-third/9780134686097/
[7]Marat Boshernitsan, Susan L. Graham, Susan L. Graham, and Marti A. Hearst.
2007. Aligning Development Tools with the Way Programmers Think About
Code Changes. In Proceedings of the SIGCHI Conference on Human Factors in
ComputingSystems (SanJose,California,USA) (CHIâ€™07).ACM,NewYork,NY,
USA, 567â€“576. https://doi.org/10.1145/1240624.1240715
[8]Comby.2021. CombySyntaxReference . https://comby.dev/docs/syntax-reference
Accessed: 3 Sep 2021.
[9]SantanuKumarDash,MiltiadisAllamanis,andEarlT.Barr.2018. RefiNym:Using
Names to Refine Types. In Proceedings of the 2018 26th ACM Joint Meeting on
European Software Engineering Conference and Symposium on the Foundations of
SoftwareEngineering (LakeBuenaVista,FL,USA) (ESEC/FSE2018) .ACM,New
York, NY, USA, 107â€“117. https://doi.org/10.1145/3236024.3236042
[10]DannyDig,JohnMarrero,andMichaelD.Ernst.2009. RefactoringSequential
JavaCodeforConcurrencyviaConcurrentLibraries.In Proceedingsofthe31st
International Conference on Software Engineering (ICSE â€™09) . IEEE Computer
Society, Washington, DC, USA, 397â€“407. https://doi.org/10.1109/ICSE.2009.
5070539
[11]Malinda Dilhara. 2021. Discovering Repetitive Code Changes in ML Systems.
InProceedingsofthe29thACMJointMeetingonEuropeanSoftwareEngineering
ConferenceandSymposiumontheFoundationsofSoftwareEngineering (Athens,
Greece)(ESEC/FSE 2021) . Association for Computing Machinery, New York, NY,
USA, 1683â€“1685. https://doi.org/10.1145/3468264.3473493
[12]MalindaDilhara,AmeyaKetkar,NikhithSannidhi,andDannyDig.2022. Discov-
eringRepetitiveCodeChangesinPythonMLSystems.In InternationalConfer-
enceonSoftwareEngineering (Pittsburgh,UnitedStates) (ICSEâ€™22) .ACM/IEEE.
https://doi.org/10.1145/3510003.3510225 To appear.
[13] Java Platform Documentation. 2019. Autoboxing and unboxing .
[14] Java Platform Documentation. 2019. StringBuffer .
[15] Java Platform Documentation. 2019. StringBuilder .
[16] Eclipse. 2019. Refactoring Actions .
[17]Jean-RÃ©my Falleri, FlorÃ©al Morandat, Xavier Blanc, Matias Martinez, and Martin
Monperrus.2014. Fine-grainedandAccurateSourceCodeDifferencing.In Pro-
ceedingsofthe29thACM/IEEEInternationalConferenceonAutomatedSoftware
Engineering (Vasteras,Sweden) (ASEâ€™14).ACM,NewYork,NY,USA,313â€“324.
https://doi.org/10.1145/2642937.2642982
[18]S.R.Foster, W.G.Griswold,and S.Lerner.2012. WitchDoctor:IDEsupportfor
real-timeauto-completionofrefactorings.In 201234thInternationalConferenceon
Software Engineering (ICSE) . 222â€“232. https://doi.org/10.1109/ICSE.2012.6227191
[19]Xi Ge, Quinton L. DuBose, and Emerson Murphy-Hill. 2012. Reconciling Manual
and Automatic Refactoring. In Proceedings of the 34th International Conference on
Software Engineering (Zurich, Switzerland) (ICSE â€™12) . IEEE Press, 211â€“221.
[20] Google. 2011. Error Prone . https://github.com/google/error-prone
[21]Sumit Gulwani. 2011. Automating String Processing in Spreadsheets us-
ing Input-Output Examples. In PoPLâ€™11, January 26-28, 2011, Austin, Texas,
USA. https://www.microsoft.com/en-us/research/publication/automating-
string-processing-spreadsheets-using-input-output-examples/
[22]Mark Hills, Paul Klint, and Jurgen J. Vinju. 2012. Scripting a Refactoring with
Rascal and Eclipse (WRT â€™12) . Association for Computing Machinery, New York,
NY, USA, 40â€“49. https://doi.org/10.1145/2328876.2328882
[23]AbramHindle,EarlT.Barr,MarkGabel,ZhendongSu,andPremkumarDevanbu.
2016. OntheNaturalnessofSoftware. Commun.ACM 59,5(April2016),122â€“131.
https://doi.org/10.1145/2902362
[24]IntelliJ. 2021. IntelliJ Inplace Rename . https://www.jetbrains.com/help/idea/
rename-refactorings.html#inplace_rename Accessed: 3 Sep 2021.
[25]IntelliJ. 2021. IntelliJ Intention Actions . https://www.jetbrains.com/help/idea/
intention-actions.html Accessed: 3 Sep 2021.
[26]IntelliJ. 2021. IntelliJ Java Inspections . https://www.jetbrains.com/help/idea/list-
of-java-inspections.html#probable-bugs Accessed: 3 Sep 2021.[27]IntelliJ. 2021. IntelliJ: Structural Search and Replace . https://www.jetbrains.com/
help/idea/structural-search-and-replace.html Accessed: 3 Sep 2021.
[28] JetBrains. 2019. Type Migration .
[29]Suhas Kabinna, Cor-Paul Bezemer, Weiyi Shang, and Ahmed E. Hassan. 2016.
Logging Library Migrations: A Case Study for the Apache Software Foundation
Projects. In Proceedings of the IEEE/ACM 13th Working Conference on Mining
SoftwareRepositories .154â€“164. https://doi.ieeecomputersociety.org/10.1109/MSR.
2016.025
[30]Ameya Ketkar, Ali Mesbah, Davood Mazinanian, Danny Dig, and Edward Af-
tandilian.2019. TypeMigrationinUltra-large-scaleCodebases.In Proceedings
of the 41st International Conference on Software Engineering (Montreal, Que-
bec, Canada) (ICSE â€™19) . IEEE Press, Piscataway, NJ, USA, 1142â€“1153. https:
//doi.org/10.1109/ICSE.2019.00117
[31]Ameya Ketkar, Nikolaos Tsantalis, and Danny Dig. 2020. Understanding Type
Changes in Java . Association for Computing Machinery, New York, NY, USA,
629â€“641. https://doi.org/10.1145/3368089.3409725
[32]Jongwook Kim, Don Batory, and Danny Dig. 2015. Scripting parametric refactor-
ingsinJavatoretrofitdesignpatterns.In 2015IEEEInternationalConferenceon
SoftwareMaintenanceandEvolution(ICSME) .211â€“220. https://doi.org/10.1109/
ICSM.2015.7332467
[33]MiryungKim,DavidNotkin,DanGrossman,andGaryWilson.2013. Identifying
andSummarizingSystematicCodeChangesviaRuleInference. IEEETransactions
on Software Engineering 39, 1 (Jan 2013), 45â€“62. https://doi.org/10.1109/TSE.
2012.16
[34]H. W. Kuhn. 1955. The Hungarian method for the as-
signment problem. Naval Research Logistics Quarterly 2,
1-2 (1955), 83â€“97. https://doi.org/10.1002/nav.3800020109
arXiv:https://onlinelibrary.wiley.com/doi/pdf/10.1002/nav.3800020109
[35]MaximeLamothe,WeiyiShang,andTse-HsunPeterChen.2020. A3:Assisting
Android APIMigrationsUsing CodeExamples. IEEETransactionson Software
Engineering (2020), 1â€“1. https://doi.org/10.1109/TSE.2020.2988396
[36]Huiqing Li and Simon Thompson. 2012. A Domain-Specific Language for Script-
ingRefactoringsinErlang.In FundamentalApproachestoSoftwareEngineering ,
Juan de Lara and Andrea Zisman (Eds.). Springer Berlin Heidelberg, Berlin, Hei-
delberg, 501â€“515.
[37]JunLi,ChenglongWang,YingfeiXiong,andZhenjiangHu.2015. SWIN:Towards
Type-Safe Java Program Adaptation Between APIs. In Proceedings of the 2015
WorkshoponPartialEvaluationandProgramManipulation (Mumbai,India) (PEPM
â€™15).ACM,NewYork,NY,USA,91â€“102. https://doi.org/10.1145/2678015.2682534
[38]Sifei Luan, Di Yang, Celeste Barnaby, Koushik Sen, and Satish Chandra. 2019.
Aroma: Code Recommendation via Structural Code Search. Proc. ACM Program.
Lang.3, OOPSLA, Article 152 (Oct. 2019), 28 pages. https://doi.org/10.1145/
3360578
[39]Na Meng, Miryung Kim, and Kathryn S. Mckinley. [n.d.]. Sydit: Creating and
applying a program transformation from an example. In in ESEC/FSEâ€™11, 2011 .
440â€“443.
[40]Na Meng, Miryung Kim, and Kathryn S. McKinley. 2013. LASE: Locating and
ApplyingSystematicEditsbyLearningfromExamples.In Proceedingsofthe2013
International Conference on Software Engineering (San Francisco, CA, USA) (ICSE
â€™13). IEEE Press, 502â€“511.
[41]T. Mens and T. Tourwe. 2001. A declarative evolution framework for object-
orienteddesignpatterns.In ProceedingsIEEEInternationalConferenceonSoftware
Maintenance. ICSM 2001 . 570â€“579. https://doi.org/10.1109/ICSM.2001.972774
[42]AliMesbah,AndrewRice,EmilyJohnston,NickGlorioso,andEdwardAftandilian.
2019.DeepDelta:LearningtoRepairCompilationErrors.In Proceedingsofthe2019
27thACMJointMeetingonEuropeanSoftwareEngineeringConferenceandSympo-
siumontheFoundationsofSoftwareEngineering (Tallinn,Estonia) (ESEC/FSE2019) .
ACM, New York, NY, USA, 925â€“936. https://doi.org/10.1145/3338906.3340455
[43] Microsoft. 2021. Visual Studio. (2021). At https://www.visualstudio.com.
[44]AndersMiltner,SumitGulwani,VuLe,AlanLeung,ArjunRadhakrishna,Gustavo
Soares, Ashish Tiwari, and Abhishek Udupa. 2019. On the Fly Synthesis of Edit
Suggestions. Proc. ACM Program. Lang. 3, OOPSLA, Article 143 (Oct. 2019),
29 pages. https://doi.org/10.1145/3360569
[45]H.Nguyen,T.N.Nguyen,D.Dig,S.Nguyen,H.Tran,andM.Hilton.2019. Graph-
Based Mining of In-the-Wild, Fine-Grained, Semantic Code Change Patterns. In
2019IEEE/ACM41stInternationalConferenceonSoftwareEngineering(ICSE) .IEEE
Computer Society, Los Alamitos, CA, USA, 819â€“830. https://doi.org/10.1109/
ICSE.2019.00089
[46]HoanAnhNguyen,AnhTuanNguyen,TungThanhNguyen,TienN.Nguyen,
and Hridesh Rajan. 2013. A Study of Repetitiveness of Code Changes in Soft-
ware Evolution. In Proceedings of the 28th IEEE/ACM International Conference on
Automated Software Engineering (Silicon Valley, CA, USA) (ASEâ€™13). IEEE Press,
180â€“190. https://doi.org/10.1109/ASE.2013.6693078
[47]HoanAnhNguyen,TungThanhNguyen,GaryWilsonJr.,AnhTuanNguyen,
Miryung Kim, and Tien N. Nguyen. 2010. A graph-based approach to API
usageadaptation.In Proceedingsofthe25thAnnualACMSIGPLANConference
on Object-Oriented Programming, Systems, Languages, and Applications, OOPSLA
2010, October 17-21, 2010, Reno/Tahoe, Nevada, USA . 302â€“321. https://doi.org/10.
1217Inferring and Applying Type Changes ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
1145/1869459.1869486
[48]Marius Nita and David Notkin. 2010. Using Twinning to Adapt Programs to
AlternativeAPIs.In Proceedingsofthe32ndACM/IEEEInternationalConference
onSoftwareEngineering-Volume1 (CapeTown,SouthAfrica) (ICSEâ€™10) .ACM,
New York, NY, USA, 205â€“214. https://doi.org/10.1145/1806799.1806832
[49]Baishakhi Ray, Christopher Wiley, and Miryung Kim. 2012. REPERTOIRE:
A Cross-System Porting Analysis Tool for Forked Software Projects. In Pro-
ceedings of the ACM SIGSOFT 20th International Symposium on the Founda-
tions of Software Engineering (Cary, North Carolina) (FSE â€™12). Association
for Computing Machinery, New York, NY, USA, Article 8, 4 pages. https:
//doi.org/10.1145/2393596.2393603
[50]ReudismamRolim,GustavoSoares,LorisDâ€™Antoni,OleksandrPolozov,Sumit
Gulwani,RohitGheyi,RyoSuzuki,andBjÃ¶rnHartmann.2017. LearningSyntactic
ProgramTransformationsfromExamples.In Proceedingsofthe39thInternational
ConferenceonSoftwareEngineering (BuenosAires,Argentina) (ICSEâ€™17) .IEEE
Press, Piscataway, NJ, USA, 404â€“415. https://doi.org/10.1109/ICSE.2017.44
[51]ReudismamRolim,GustavoSoares,RohitGheyi,andLorisDâ€™Antoni.2018. Learn-
ing Quick Fixes from Code Repositories. (2018). http://arxiv.org/abs/1803.03806
[52]OlegSmirnov,AmeyaKetkar,TimofeyBryksin,NikolaosTsantalis,andDanny
Dig. 2021. IntelliTC: Automating Type Changes in IntelliJ IDEA . https://type-
change.github.io/index.html Accessed: 10 Feb 2022.
[53]OlegSmirnov,AmeyaKetkar,TimofeyBryksin,NikolaosTsantalis,andDanny
Dig. 2022. IntelliTC: Automating Type Changes in IntelliJ IDEA. In 44th In-
ternational Conference on Software Engineering Companion (ICSE â€™22 Compan-
ion)(Pittsburgh, United States) (ICSE â€™22 Companion) . ACM/IEEE. https:
//doi.org/10.1145/3510454.3516851
[54]Friedrich Steimann, Christian Kollee, and Jens von Pilgrim. 2011. A Refactoring
Constraint Language and Its Application to Eiffel. In ECOOP 2011 â€“ Object-
Oriented Programming , Mira Mezini (Ed.). Springer Berlin Heidelberg, Berlin,Heidelberg, 255â€“280.
[55]CÃ©dric Teyton, Jean-RÃ©my Falleri, Marc Palyart, and Xavier Blanc. 2014. A Study
ofLibraryMigrationsinJava. J.Softw.Evol.Process 26,11(Nov.2014),1030â€“1052.
https://doi.org/10.1002/smr.1660
[56]NikolaosTsantalis,AmeyaKetkar,andDannyDig.2020. RefactoringMiner2.0.
IEEE Transactions on Software Engineering (2020), 1â€“21. https://doi.org/10.1109/
TSE.2020.3007722
[57]Rijnard van Tonder and Claire Le Goues. 2019. Lightweight Multi-Language
SyntaxTransformationwithParserParserCombinators.In Proceedingsofthe40th
ACMSIGPLANConferenceonProgrammingLanguageDesignandImplementation
(Phoenix, AZ, USA) (PLDI 2019) . Association for Computing Machinery, New
York, NY, USA, 363â€“378. https://doi.org/10.1145/3314221.3314589
[58]MathieuVerbaere,ArnaudPayement,andOegedeMoor.2006. Scriptingrefac-
torings with JunGL. In Companion to the 21th Annual ACM SIGPLAN Conference
on Object-Oriented Programming, Systems, Languages, and Applications, OOPSLA
2006,October22-26,2006,Portland,Oregon,USA ,PeriL.TarrandWilliamR.Cook
(Eds.). ACM, 651â€“652. https://doi.org/10.1145/1176617.1176656
[59]HyrumK.Wright.2020. IncrementalTypeMigrationUsingTypeAlgebra.In 2020
IEEE International Conference on Software Maintenance and Evolution (ICSME) .
756â€“765. https://doi.org/10.1109/ICSME46990.2020.00085
[60]ShengzheXu,ZiqiDong,andNaMeng.2019. Meditor:InferenceandApplica-
tionofAPIMigrationEdits.In Proceedingsofthe27thInternationalConference
onProgramComprehension (Montreal,Quebec,Canada) (ICPCâ€™19) .IEEEPress,
Piscataway, NJ, USA, 335â€“346. https://doi.org/10.1109/ICPC.2019.00052
[61]Guangtun Zhu. 2016. A New View of Classification in Astronomy with the
Archetype Technique: An Astronomical Case of the NP-complete Set Cover
Problem. arXiv:1606.07156 [astro-ph.IM]
1218