SnR: Constraint-Based Type Inference for Incomplete Java Code
Snippets
Yiwen Dong
David R. Cheriton School of Computer Science
University of Waterloo
Waterloo, Ontario, Canada
y225dong@uwaterloo.caTianxiao Gu
Alibaba Group
China
tianxiao.gu@gmail.com
Yongqiang Tian
David R. Cheriton School of Computer Science
University of Waterloo
Waterloo, Ontario, Canada
yongqiang.tian@uwaterloo.caChengnian Sun
David R. Cheriton School of Computer Science
University of Waterloo
Waterloo, Ontario, Canada
cnsun@uwaterloo.ca
ABSTRACT
Code snippets are prevalent on websites such as Stack Overflow
and are effective in demonstrating API usages concisely. However
theyareusuallydifficulttobeuseddirectlybecausemostcodesnip-
petsnotonlyaresyntacticallyincompletebutalsolackdependency
information,andthusdonotcompile.Forexample,Javasnippets
usuallydonothaveimportstatementsorrequiredlibrarynames;
only6.88%ofJavasnippetsonStackOverflowincludeimportstate-
ments necessary for compilation.
Thispaperproposes SnR,aprecise,efficient,constraint-based
technique to automatically infer the exact types used in code snip-
pets and the libraries containing the inferred types, to compile and
thereforereusethecodesnippets.Initially, SnRbuildsaknowledge
base of APIs, i.e., various facts about the available APIs, from a
corpus of Java libraries. Given a code snippet with missing import
statements, SnRautomatically extracts typing constraints from the
snippet, solves the constraints against the knowledge base, andreturns a set of APIs that satisfies the constraints to be imported
into the snippet.
We have evaluated SnRon a benchmark of 267 code snippets
fromStackOverflow. SnRsignificantlyoutperformsthestate-of-the-
arttoolCoster. SnRcorrectlyinfers91.0%oftheimportstatements,
which makes73.8% of the snippetscompile, compared to36.0% of
the import statements and 9.0% of the snippets by Coster.
CCS CONCEPTS
â€¢Software and its engineering â†’Automated static analysis ;
Software notations and tools ;â€¢Theory of computation â†’
Type structures .
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
onthe firstpage.Copyrights forcomponentsof thisworkowned byothersthan the
author(s)mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,or
republish,topostonserversortoredistributetolists,requirespriorspecificpermission
and/or a fee. Request permissions from permissions@acm.org.
ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
Â© 2022 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ACM ISBN 978-1-4503-9221-1/22/05...$15.00
https://doi.org/10.1145/3510003.3510061KEYWORDS
type inference, constraint satisfaction, automated repair, datalog
ACM Reference Format:
Yiwen Dong, Tianxiao Gu, Yongqiang Tian, and Chengnian Sun. 2022. SnR:
Constraint-Based Type Inference for Incomplete Java Code Snippets. In
44thInternationalConferenceonSoftwareEngineering(ICSEâ€™22),May21â€“
29, 2022, Pittsburgh, PA, USA. ACM, New York, NY, USA, 12 pages. https:
//doi.org/10.1145/3510003.3510061
1 INTRODUCTION
A code snippet is a small region of source code, which is usually
incomplete and thus not compilable, e.g., a list of statements alone
inJavawithoutbeingputinamethodorclass.Codesnippetsare
useful, and commonly found from well used Q&A websites like
StackOverflow(SO)wheresmallcodesnippetsareoftenusedto
ask questions or illustrate answers concisely.
However,whendevelopersfindacodesnippetonSOtobeuseful
andwouldliketouseitintheirprojects,itisnoteasytodirectlyuse
thecodesnippet.InFigure1,aJavacompilersuchas javaccannot
resolvethetypesusedinthesnippet( e.g.,Date,Days,DateFormat )
to their definitions which can be from third-party libraries. It takes
developersboth timeand effortsto manuallyrepair codesnippets
to be compilable, a challenging task which requires the developers
to figure out the exact types used in the code snippet ( e.g., what
exact types do DateandDateTime refer to) and the exact libraries
that provide the definitions of the used types.
A techniqueto automatically repaircode snippets byrecovering
the missing types and dependent libraries for compilation will
greatly save developers time; compilable code snippets carry more
semanticinformationthanuncompilableonesandthereforesuch
atechniquecanpotentiallyenableresearcherstoextendexisting
research on SO [1, 14, 17, 21, 26â€“28, 41â€“44].
TechnicalChallenges. Generally,therearethreetechnicalchal-
lenges of automatically repairing and compiling code snippets.
Challenge 1: Lack of Import Statements. In Java, a class type has
asimplename( e.g.,Date)andapackagename( e.g.,java.util );its
fully qualified name (FQN) is the combination of its package name
andsimplename( e.g.,java.util.Date ),whichuniquelyidentifies
the class type. To make Java code concise, the simple name of a
19822022 IEEE/ACM 44th International Conference on Software Engineering (ICSE)
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:53:04 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Yiwen Dong, Tianxiao Gu, Yongqiang Tian, and Chengnian Sun
1DateFormat formatter = newSimpleDateFormat("mm/dd/ yyyy");
2Date some Date = newDate();
3Date today = Calendar.getInstance().getTime();
4try{
5someDate = formatter.parse("06/22/2010");
6}catch(ParseException pe) {
7System.out.println("Parser Exception");
8}
9intdays = Days.daysBetween( newDateTime(someDate), new
DateTime(today)).getDays();
10System.out.println (" Days Betw een " + someDate +":"+
today + " - " + days);
Figure 1: Formatted code snippet in SO post #3329469.
class type can be used in Java code directly, and the class typeâ€™s
FQNisdeclaredbyanimportstatement.Withthehelpofimport
statements a Java compiler can identify the exact class type from a
simple name during compilation. Previous work [36] showed that
only 6.88% of Javacodesnippets on SO included import statements
that specified the FQNs of the types used in the code snippets.
OneexampleisFigure1;theJavacompilerisnotabletoinferthe
FQNs from the simple names such as Date,DaysandDateFormat ,
because the code snippet does not have any import statements.
Challenge 2: Lack of Library Dependencies. Acodesnippetusu-
ally does not carry information about the libraries. These libraries
are needed for the Java compiler to compile the code snippet as
they contain the type definitions used in the snippet. The example
inFigure1requiredtheJoda-Timelibrary.Notethatevencorrect
FQNs do not guarantee that we can find the correct library to
depend on, because different libraries of different purposes may
containtypeswiththesameFQN.Forexample,theAndroidrun-
time library and the Java runtime library both define a class for
java.text.DateFormat.
Challenge 3: Combinatory Candidates. To compile a code snip-
pet,weneedtohavethecorrectFQNforeachsimplename,andthe
correct library for each FQN. However, A simple name may corre-
spond to multiple different FQN, and each FQN may correspond to
multipledifferentlibraries.Thesearchspaceisallthecombinations
of candidates for each simple name, which defines a computation-
ally expensive problem. For example, in Figure 1, the simple name
Datehas five matching classes in the Java Development Kit (JDK)
alone;intotal,thesearchspaceforthiscodesnippetis384different
combinationsofclassesfromtheJDKandfiveotherpopularJava
libraries used in our benchmarks.
Priorwork. Existingtechniquesattemptedtoaddresstypeinfer-
enceforcodesnippetsindifferentmanners:CSNIPPEXisbasedona
setofheuristics[ 36];Bakerextractsconstraintsfromcodesnippets
andusesanaiveconstraintsolvingalgorithmtoinferFQNs[ 35];
both StatType [ 25] and Coster [ 32] build statistical models from
existingcompilablesourcecodetopredictFQNforcodesnippets.
However, these techniques do not address all three challenges and
suffer from inherent imprecision of the used heuristics [ 36], pro-
posedconstraintsolvingalgorithm[ 35],orthetrainedstatistical
models [25,32];especially neither of them tackles Challenge 2 when
multiple libraries contain different types with the same simple names.
Our approach. Wepropose SnR,anovel,constraint-basedap-
proachtoautomatically,preciselyinferFQNsandrequiredlibrariestocompileandreusecodesnippets. SnRbuildsaknowledgebase
fromavailablelibraries byextractingfactsofthetypesdefinedin
these libraries, e.g., fields, methods, signatures, inheritance rela-
tions. Given an incomplete code snippet, SnRextracts constraints
fromthecodesnippetthatcapturetherelationbetweentypesusedin the snippet; then SnRresolves these constraints by querying the
knowledgebase,and outputs arankedlist ofsolutions whereeach
solutionisasetoftypesthatsatisfytheconstraintsandlikelymake
the code snippet compile.
Compared to the prior work based on either heuristics or sta-
tistics,SnRleverages the type system built into programming
languages and models the problem of inferring types for incom-plete code snippets as a constraint satisfaction problem (CSP).
Without being affected by the randomness, approximation and
un-interpretability from which prior work suffer, SnRcan deter-
ministically, precisely infer types with explicit explanation how
and why the types are inferred.
Wethoroughlyevaluated SnRagainstthestate-of-the-arttool,
Coster [32]. We used an established benchmark called StatType-
SOconsistingof267codesnippetsmanuallycollectedfromStack
Overflowposts[ 25].SnRsignificantlyoutperformedCosterinterms
ofaccuracyoftypeinferenceandlibraryrecommendation: 1/circlecopyrtInthe
taskofinferringtypesforAPIelements(includingsimplenames,
field accesses and method calls as defined in [ 32]),SnRachieves
highprecisionof98.20%andrecallof79.66%comparedtoprecision
of 66.35% and recall of 66.35% by Coster. 2/circlecopyrtIn the task of inferring
theimportstatementsrequiredforcompilingcodesnippets, SnR
is able to correctly infer 91.0% of the import statements compared
to 36.0% by Coster. 3/circlecopyrtSnRcan accurately recommend libraries for
snippets with ğ¹1score of 0.82 compared to 0.53 by Coster. Notably,
SnRrecommendedtheexactlibrariesfor183ofthe267snippets,
compared Coster with 34. 4/circlecopyrtAs a result of the high accuracy in
typeinferenceandlibraryrecommendation, SnRcanmake73.8%of
the code snippets compilable in total compared to 9.0% by Coster.
Contribution. This paper makes the following contributions:
â€¢Novelty Weproposed SnR,anovelconstraint-basedapproach
to automatically, precisely infer FQNs, recommend libraries, and
create import statements for code snippets.
â€¢Soundness andSignificance We conducted extensive evalua-
tions on real-world code snippets in StatType-SO and the results
demonstrate that SnRsignificantly outperforms the state of the
art in various type inference tasks.
â€¢Verifiability We made a replication package available at
https://doi.org/10.5281/zenodo.5843327
2 BACKGROUND
2.1 Motivating Example
We use the code snippet in Figure 1 as a motivating example to
illustrate main shortcomings of existing techniques, particularly in
addressing Challenges 2 and 3.
Eclipse, a prevalent integrated development environment, has a
powerful utility Quick Fix to fix common syntactical errors, repair
partial statements and insert missing import statements. However,
Quick Fix is inadequate for inferring the types in Figure 1:
1/circlecopyrtIt is imprecise due to its heuristic-based nature. For example,
bothjava.sql.Date andjava.util.Date arerecommended
1983
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:53:04 UTC from IEEE Xplore.  Restrictions apply. SnR: Constraint-Based Type Inference for Incomplete Java Code Snippets ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
Table1:Thetop-3candidatesoutputby SnRforFigure1.The
first row is the correct solution. The FQNs in italics are im-
plemented in multiple libraries.
# Name Library Fully Qualified Name
DateFormat jdk java.text.DateFormat
SimpleDateFormat jdk java.text.SimpleDateFormat
Date jdk java.util.Date
ParseException jdk java.text.ParseException
DateTime joda org.joda.time.DateTime1
Days joda org.joda.time.Days
2DateFormat android java.text.DateFormat
SimpleDateFormat android java.text.SimpleDateFormat
Date android java.util.Date
ParseException android android.net.ParseException
DateTime joda org.joda.time.DateTimeDays joda org.joda.time.Days
3DateFormat jdk java.text.DateFormat
SimpleDateFormat jdk java.text.SimpleDateFormat
Date jdk java.util.Date
ParseException gwt org.w3c.flute.parser.ParseExceptionDateTime joda org.joda.time.DateTimeDays joda org.joda.time.Days
byQuickFixeventhough Calender.getInstance().getTime()
only returns the latter.
2/circlecopyrtIt only works with libraries and types on the class path, and
cannot fix errors related to unknown types. For example, if the
Joda-Timelibraryisnotontheclasspath,thenQuickFixcannot
create import statements for DateTime which is a type defined
in Joda-Time.
3/circlecopyrtItcannotrecommendnewlibrariestobeaddedtotheclasspath.
Therefore, Quick Fix cannot recommend the Joda-Time library
to developers.
Recent research attempted to address 1/circlecopyrtand2/circlecopyrtusing simple
constraints[ 35]ormorerecently,statistics[ 25,32].Weaimedtoim-
proveuponprevioustechniquesandtackle 3/circlecopyrt.Previoussolutions
did not consider the same FQN being implemented by multiple
libraries and did not recommend libraries as part of their inference.
In the StatType-SO benchmark of six libraries alone, both the JDK
andandroidlibrariesprovideimplementationformanystandard
APIs. In the real world, we may want to include different versions
of the same library e.g.for supporting both Java 8 and 12 APIs.
InTable1,weshowasamplesolutionby SnRforthemotivating
problem Figure 1. The large number of FQNs with multiple im-
plementation (shown in italics) demonstrates the need for a new
techniquethatcanrecommendcorrectlibraries.Includingmultiple
librariescanleadtodependencyconflictsandcreateseriousrun-
time bugs [ 39]. To address the shortcomings of prior solutions, we
strive to devise a technique to infer the correct FQNs from code
snippetswhileminimizingtheconflictofrecommendedlibraries.
ThisisincontrasttoCosterwhichrecommendsalllibrariescontaining
the inferred FQNs.Expr/ColonequalName|Literal|this|Expr Op Expr
|(Type)Expr|Expr[Expr]
|Expr.SimpleName
|Exprinstanceof ReferenceType
|Expr.SimpleName ({ğ¸ğ‘¥ğ‘ğ‘Ÿ})
|newClassType ({ğ¸ğ‘¥ğ‘ğ‘Ÿ})
|newType[Expr]
Name/ColonequalFQN|SimpleName
FQN/ColonequalName.SimpleName
Literal /Colonequalnull|NumberLiteral |StringLiteral
Op/Colonequal+|-|*|/|%|>|==|>=|!=
Type/ColonequalPrimitiveType |ReferenceType
ReferenceType /ColonequalClassType |ArrayType
|ParameterizedType
PrimitiveType /Colonequalint|float|boolean
ClassType/ColonequalName
ArrayType /ColonequalType[]
ParameterizedType /ColonequalClassType <{ClassType }>
Figure2:Partofasimplifiedgrammaroftheexpressionsin
Java. {*} denotes that the enclosed term occurs zero or more
times.
2.2 Java Program
This paper specifically works for Java, but the proposed method-
ologyisgeneralizabletootherstatically-typedprogramminglan-
guages.ThissectionlistsminimalJavaconceptswhichareneces-
sary to illustrate our approach. A Java program consists of a set of
compilation units each of which is a Java source file and defines
one class along with any number of inner classes.
Generally, a Java class has the following components which are
used bySnRfor type inference.
NameEach type ( e.g., class, interface, annotations) has a fully
qualified name, which is the combination of its package name (may
be empty) and simple name . Syntactically, an FQN is a sequence of
simple names joined by dots.
Super Class Each class has a single super class except the class
java.lang.Object (Objectforshort).Thedefaultsuperclassof
a class is Objectif theextendsdeclaration is absent.
Interfaces Each class can have a set of interfaces as supertypes.
Annotations Each class can have a set of annotations.
FieldsEach class can have a set of fields. Each field has a type and
a name, and can be optionally initialized with an expression.Methods
Eachclasshasasetof methods.Eachmethodhasa name,
an optional sequence of parameters and a return type. Methods
contain statements and expressions in them.
Figure 2 shows a simplified version of the grammar of expressions
inJava.Wewillusethisgrammarandthelanguageconstructslisted
abovetoillustratehow SnRinfersrequiredtypesandlibrariesfor
incomplete Java code snippets.
1984
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:53:04 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Yiwen Dong, Tianxiao Gu, Yongqiang Tian, and Chengnian Sun
Program /ColonequalFact Program |Rule Program |ğœ€
Fact/Colonequalrelation({constant}).
Rule/ColonequalAtom:-NAtom{NAtom}.
NAtom /ColonequalAtom|!Atom
Atom/Colonequalrelation({Term})
Term/Colonequalconstant |variable
(a) Simplified Datalog grammar. The terms relation andvariable
arenamesfordefiningrelationshipsdeclaringandreferencingvari-
ables.constant iseitheranumericalorstringliteral.{*}denotesthat
the enclosed term occurs zero or many times.
a b c
(b) Dependency graph
1reachable(s,t) :- node(s) node(t)
2 edge(s, t).
3reachable(s,t) :- node(s) node(m) node(t)
4 edge(s, m)
5 reachable(m ,t).
(c) Datalog program
1node("a").
2node("b").
3node("c").
4edge("a","b").
5edge("b","c").
(d) Datalog program input
representing the dependencygraph1reachable ("a","b").
2reachable ("a","c").
3reachable ("b","c").
(e) Successful query for the
reachablerulegiventheinputin Figure 3d
Figure3:DataloggrammarandaDatalogexampleprogram.
2.3 Datalog
Our technique leverages Datalog, a declarative logic programming
languagewhichemergedfromdatabasesystemsin1980s[ 34].In
recent years, Datalog has found use in a whole range of applica-
tions [9, 12] in particular program analysis [3, 5, 8, 20].
A simplified version of the Datalog grammar is shown in Fig-
ure 3a. A Datalog program consists of a list of facts and rules,
representingsetsofrelations.Factsareknownrelationsgivento
a Datalog program and rules are used to derive relations using
facts and other rules as specified by the program. Relations can be
queried to return all satisfying constants.
Figures3bâ€“3euseadependencygraphasanexampletoillustrate
the various facets of a Datalog program. The dependency graph in
Figure3bhasthreenodes a,b,andcwhereadependson bandb
depends on c. The information of this dependency graph can be
representedastheDatalogfactsshowninFigure3d.Torecursively
query the reachable node pairs in this dependency graph, we write
ademonstrationDatalogprogramconsistingoftworulesasshown
in Figure 3c. When we query for the reachable relation, all the
reachable node pairs are returned by a Datalog solver as seen in
Figure 3e, i.e.,(a,b),(a,c), and (b,c).3 METHODOLOGY
Template-Based
Repair
Type
Inference
Import
Repair
Snippet AST AST+TypesCompilation
Unit+Libraries
Figure4:Theoverallworkflowof SnRtorepairacodesnip-
pet to a compilable compilation unit.
Figure 4 shows the overview of SnR. Given an incomplete code
snippet as input, SnRaims to output a compilable compilation unit
which is the input to a Java compiler ( i.e., a Java source file) and
contains 1/circlecopyrtthecodesnippet, 2/circlecopyrtthenecessaryskeletoncode( e.g.,a
classdefinitionandamethoddefinitiontoenclosethecodesnippet)
to make the compilation unit syntactically valid, and 3/circlecopyrtinferred
required import statements together with the libraries defining the
imported types. To achieve this objective, the workflow of SnRhas
the following three major procedures.
Template-Based Repair. Given a code snippet ğ‘consisting of
a list of statements, SnRfirst attempts to create a minimal code
skeleton based on pre-defined templates to enclose ğ‘, so that the
skeletonand ğ‘togetherformsasyntacticallyvalidcompilationunit.
OurapproachissimilartothatoutlinedbyTerragnietal .[36].After
the repair, the Abstract Syntax Tree (AST) of the unit is generated
for the following procedures.TypeInference.
GiventheAST, SnRleveragesthetypeinference
engine to analyze and extract the constraints. These constraints
encode the typing relations among types used in the AST. ThenSnRrefines the knowledge base, pre-built from a set of libraries,
with concrete types to replace the generic types previously stored.
Lastly, the refined knowledge base and constraints are given to
Datalog to solve, giving us a list of solutions for the next step.
ImportRepair. Inthethirdstep, SnRinterpretsthelistofconstraint-
satisfying solutions, creates import statements and inserts them
into the code skeleton. To validate the results SnRleverages the
Javacompilertocompilestheresultingcompilationunit.Ifthecom-
pilation succeeds, the compilation unit together with the import
statements and the required libraries are output as the final result.
Typeinferenceisthemostcriticalstepin SnR.Figure5describes
the internal components in the type inference engine. In the re-
mainder of this section, we describe these components in detail.
3.1 Knowledge Base
Given a set of libraries, we build the knowledge base which can be
queried to resolve ambiguities (Â§3.3) when gathering constraints
and solving constraints (Â§3.4).
3.1.1 Content. A simplified schema for our knowledge base is
described in Figure 6. For each type, the knowledge base stores the
FQN,supertype,super-interfaces,fieldsandmethods.Generictypes
are stored as is in the knowledge base. For example, List.get()
in theknowledge basehas thetype Twhichwill be refinedbefore
being given to Datalog when solving constraints, discussed in Â§3.4.
NotethattheschemainFigure6issimplifiedtoeasepresentation
withtheassumptionthattherearenomultipleclasseswiththesame
1985
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:53:04 UTC from IEEE Xplore.  Restrictions apply. SnR: Constraint-Based Type Inference for Incomplete Java Code Snippets ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
Gather
Constraints
Solve
Constraints
Knowledge BaseAST AST+Types
Figure 5: Type Inference Process in SnR.
class
FQN
supertype
generics
field
(FQN)
name
typesuper-interface
(FQN)
interface name
method
(FQN)
name
return type
argument typesnumber of arguments
Figure 6: Simplified version of the knowledge base schemaassuming there are no classes with the same FQN. Each boxrepresents a table with a table name (in blue) and a numberof column names. The underline denotes the primary keyor keys that uniquely identify a row of data. The columnnames in parenthesis are foreign keys which are linked toprimarykeysinanothertable.Anedge
representsaone-
to-many relationship between the two connected tables.
FQN.Moreover,libraryinformation( e.g.,whichlibrarydefinesa
type)isalsoomittedinFigure6.Therealknowledgebasein SnR
handles both with additional database table columns.
3.1.2 QueryFunctions. Wedefinethefollowingqueryfunctions
to retrieve information from the knowledge base. Each function
representsaretrievalcriterionandtheparametersparameterizethecriterion.Eachfunctionreturnsasetoftypes(
i.e.,classes,interfaces
andannotations)thatsatisfythespecifiedretrievalcriterion.Table2
lists the query functions used in this paper.
Table 2: Query functions to retrieve types from knowledge
base.
Query Function Description
Î©simplename (name) Returns the types with the given simple name
Î©fqn(name) Returns the types with the given fully qualified name
Î©field(name) Returns the types that have a field called the given name
Î©method(name, num_args) Returns the types defining a method with the given name
which takes num_args number of parameters
Besides querying normal types, Î©simplename has specialized sup-
port forquerying inner types ( e.g., innerclasses, inner interfaces).Note that an inner type can have multiple simple names. Consider
aninnerclass Builderwithanouterclass java.util.Calendar .
It is possible to reference this type with either of the two simplenames
Calendar.Builder orBuilder using import statements
java.util.Calendar orjava.util.Calendar.Builder respec-
tively.
Î©simplename supportsquerieswithdifferentformsofsimplenames.
In the example above, this query function can be called with either
Î©simplename ("Calendar.Builder") orÎ©simplename ("Builder") .
3.2 Type Inference: Extracting Constraints
Given an AST, SnRtraverses it and extracts the constraints captur-
ingtherelationsamongthetypesusedintheAST.Specifically, SnR
concentrates on type elements defines as below,
Definition 3.1 (Type Elements). Type elements in an AST refer
to the nodes that define new types or use types, i.e., type declarations
(e.g., class, interface and annotation declarations), explicitly used
types, statements and expressions.
Note that prior work [ 25,32] uses a different term API elements,
whichisasubsetoftypeelementsandfocusesononlyexplicitly
used types i.e.simple names, field accesses, method calls. For high-
precision type inference, SnRinfers not only explicitly usedtypes
but also implicitly used types in expressions, e.g.variables, method
arguments, method returns. All the AST nodes used by SnRfor
type inference constitute type elements in this paper.
3.2.1 Creating Type Variables. For each type element, SnRfirst
createsoneormore typevariables torepresentthetypesdefinedor
used in the type element or in the components of the type element
Forsimplicity,weuse ğœtodenoteatypevariable.Giventhetype
element (a statement) below,
Date today = Calendar.getInstance().getTime();
SnRcreates four type variables
Type Variable Description
ğœ1 the type of Date
ğœ2 the type of Calendar
ğœ3 the return type of Calendar.getInstance()
ğœ4 the return type of Calendar.getInstance.getTime()
3.2.2 ExtractingConstraints. Basedon thetypevariablescreated
fromatypeelement, SnRfurtherextractsconstraintsfromthetype
element to capture the relations among the type variables. Table 3
listsallthetypesofconstraintsusedin SnR,andTable4liststhe
concrete rules to create type variables and constraints for type
elements.
Take the class declaration for an example. The rule with the
name â€˜Declarationâ€™ in Table 4 specifies that for a class declaration
ğ‘,SnRgeneratesatleasttwotypevariables( ğœforğ‘andğœ1forthe
super class of ğ‘), and a list of type variables /vecğœ2(/vecğœ2can be empty)
for the interfaces /vecğ‘¡2ofğ‘with each type variable ğœğ‘–in/vecğœ2repre-
senting the type of one interface. Then SnRcreates one constraint
extend(ğœ,ğœ1)to capture the typing relation between ğ‘andğ‘¡1, and
oneinterface (ğœ,ğœğ‘–)for each implemented interface.
SnRmakes extensive uses of the subtype constraint in order to
model implicit type conversions of both primitive and reference
1986
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:53:04 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Yiwen Dong, Tianxiao Gu, Yongqiang Tian, and Chengnian Sun
Table3:Constraintsusedinthispaper.Eachconstraintspec-
ifies some property that a type variable ğœshould have, or
some relation among multiple type variables.
Constraint Description
simplename( ğœ, name) ğœhas the given simple name
fqn(ğœ, name) ğœhas the given FQN name
field(ğœ, name, ğœfield) ğœhas a field with given nameof the type ğœfield
method(ğœ, name, /vecğœarg,ğœret)ğœhasamethod withgiven name,argumenttypes
/vecğœargand return type ğœret
paramtype( ğœ,/vecğœarg,ğœparam)ğœwith parameter /vecğœargbuilds the parameterized
typeğœparam
arraytype( ğœ,ğœarr) An array of ğœis typeğœğ‘ğ‘Ÿğ‘Ÿ
subtype( ğœparent,ğœchild) ğœchildcan be implicitly converted to ğœparent
extend(ğœ,ğœsuper) ğœextendsğœsuper
interface( ğœ,ğœinterface)ğœimplements the interface of ğœinterface
annotation( ğœ) ğœis an annotation type
innerclass( ğœ,ğœinner) ğœis has an inner class type of ğœinner
types allowed in Java ( e.g.in assignments or when passing method
arguments)andtoconstraincertainknowntypesintheAST( e.g.
the conditional in an if statement is a boolean).
AnExample. FollowingtherulesoutlinedinTable4, SnRcreates
thefollowingconstraintsoverthetypevariables ğœ1,ğœ2,ğœ3andğœ4of
the example statement in Â§3.2.1.
Constraints Description
simplename( ğœ1,"Date") ğœ1has the simple name Date
simplename( ğœ2,"Calendar") ğœ2has the simple name Calendar
method(ğœ2,"getInstance",[], ğœ3)ğœ2hasamethodnamed getInstance thattakes
no arguments with the return type of ğœ3
method(ğœ3,"getTime",[], ğœ4)ğœ3has a method named getTime that takes no
arguments with the return type of ğœ4
subtype( ğœ1,ğœ4) ğœ1has a subtype ğœ4because of the assignment
3.3 Type Inference: Resolving Ambiguities
From the constraint generation rules laid out in Table 4, inner
classes,qualifiednamesandfieldexpressionscanbringambiguities
into the process of extracting constraints. For example,
java.util.Collections.EMPTY_LIST
for the first identifier javain this expression, there are four broad
categories of possible interpretations,
1/circlecopyrtjavais a variable defined locally in the current code snippet,
e.g., a local variable, a method parameter, a class field.
2/circlecopyrtjavaisaclassdefinedlocallyinthecurrentcodesnippet, e.g.,
an inner class.
3/circlecopyrtjavaisthenameofatype( e.g.,aclassoraninterface)which
is defined externally but not in the current code snippet.
4/circlecopyrtjavaisapartofapackagename,andthepackagenameisused
to form a FQN.
Theremainingidentifiersarethenpotentiallyamixofpackages,
classes, inner classes and field references. It is impossible at the
parsing time to determine which of these cases the current code
snippet refers to without import statements.
SnRverifies these interpretations in the order they are listed. 1/circlecopyrt
and2/circlecopyrtcanbeverifiedthroughexaminingthecodesnippetforlo-
callydefinedvariablesandtypes.Ontheotherhand,withoutimportstatements, 3/circlecopyrtand4/circlecopyrtcannot be verified. SnRovercomes this chal-
lengebyleveragingtheknowledgebase.Fortheexampleabove,byperforming a knowledge base look up
Î©simplename ("java"),3/circlecopyrtcan
be ruled out. Similarly by performing multiple Î©fqnqueries to find
thelongestmatchingFQN,wefindthat 4/circlecopyrtjava.util.Collections
is the best possible interpretation to resolve the ambiguity.
InnerClassandFieldConstraints. Thesubsequentunmatched
parts could be inner classes or fields. Inner classes can be found by
performingadditionallookupstotheknowledgebase( Î©simplename ).
The rest of the identifiers are considered to be fields.
In the event that the knowledge base is not complete, i.e., the
knowledge base does not have information about the symbol, then
SnRmaygenerateincorrectconstraints.However,thiscanbeeasily
addressed by incorporating more libraries into the knowledge base.
3.4 Type Inference: Solving Constraints
Given a code snippet ğ‘ , the setğ¶of the constraints extracted from
ğ‘ by the rules in Table 4 can be directly solved by a Datalog solver
against the knowledge base, if ğ‘ does not define or use any generic
methods or types.
However,if ğ‘ usesgenericsinside,duetothecomplexitiesofJava
genericsandthelimitedexpressivenessofDatalog,weproposea
two-stepprocesstosolve ğ¶.Generallyspeaking,for ğ‘ andğ¶,SnR
first generates a new, possibly smaller knowledge base from the
original knowledge base Î©by replacing generic types in Î©with
concrete types, and then uses the small knowledge base as Datalog
facts to solve ğ¶.
Thesmallknowledgebasecanbeviewedasa refinement ofÎ©
with more concrete type information, and thus is referred to as
arefinedknowledge base. The main reason of introducing this
refinement step is that Î©only has signatures of generic types and
methodsanditisnoteasytoencodethetypingrulesofJavagenerics
completely in Datalog.
3.4.1 Example. We use the following code snippet as an example
to demonstrate how refined knowledge bases are generated.
1List<Date> lod = newArrayList<>();
2lod.get(0);
The following table shows the constraints extracted from the code
snippet above. There are five type variables in total. The pur-poses of
ğœ1,ğœ2andğœ3are forList,DateandArrayList respec-
tively;ğœ4represents the type of List<Date> via the constraint
paramtype (ğœ1,ğœ2,ğœ4), whileğœ5is the return type of lod.get(0).
Constraint Constraint
simplename (ğœ1,"List") paramtype (ğœ1,ğœ2,ğœ4)
simplename (ğœ2,"Date") subtype(ğœ4,ğœ3)
simplename (ğœ3,"ArrayList") method(ğœ4,"get",["int"],ğœ5)
QueryingTypeCandidates. Toinstantiatethegenerictypesin
the original knowledge base Î©, we need to retrieve all the types
from Î©that are relevant to the constraints. Therefore for each
typevariable ğœandeach simplename ,fqn,fieldandmethodcon-
straints on ğœ, we use the corresponding query functions defined in
Table2toretrieveallpossiblecandidatetypesfor ğœ.Forexample,for
thesimplename constraintsof ğœ1,ğœ2andğœ3wecanuse Î©simplename
1987
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:53:04 UTC from IEEE Xplore.  Restrictions apply. SnR: Constraint-Based Type Inference for Incomplete Java Code Snippets ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
Table 4: A subset of rules to extract constraints from type elements. Î“denotes an environment that maps an expression, ğ‘’,t o
a type variable, ğœ;/vecğ‘¥denotes a vector of ğ‘¥whereğ‘¥can be an expression ğ‘’, a type variable ğœ, or type ğ‘¡;ğ‘âˆˆ/vecğ‘¥denotes the check
whether ğ‘isanelementinthevector /vecğ‘¥.Î“(/vecğ‘’)denotesalookupofeveryelementin /vecğ‘’ontheenvironment Î“,andreturnsavector
of type variables with each variable corresponding to an expression in /vecğ‘’.1
Category Name Code Type Variables Constraint
Class Declaration ğ‘ğ‘™ğ‘  ğ‘ ğ‘’ğ‘¥ğ‘¡ ğ‘¡ 1ğ‘–ğ‘šğ‘ğ‘™/vecğ‘¡2ğ‘:ğœ,ğ‘¡1:ğœ1,/vecğ‘¡2:/vecğœ2 extend(ğœ,ğœ1)
âˆ€ğœğ‘–âˆˆ/vecğœ2,interface (ğœ,ğœğ‘–)
Type Type ğ‘¡ ğ‘¡:ğœ simplename (ğœ,ğ‘¡)
Array Type ğ‘¡[] ğ‘¡:ğœ1,Î“(ğ‘¡[])=ğœ2 arraytype (ğœ1,ğœ2)
Paramed Type ğ‘¡1/angbracketleft/vecğ‘¡2/angbracketright ğ‘¡1:ğœ1,/vecğ‘¡2:/vecğœ2,Î“(ğ‘¡1/angbracketleft/vecğ‘¡2/angbracketright)=ğœ3 paramtype (ğœ1,/vecğœ2,ğœ3)
Statement If if(ğ‘’){ /vecğ‘ } Î“(ğ‘’):ğœ subtype(ğœ,"boolean")
While while(ğ‘’){ /vecğ‘ } Î“(ğ‘’):ğœ subtype(ğœ,"boolean")
Expression Assignment ğ‘’1=ğ‘’2 Î“(ğ‘’1)=ğœ1,Î“(ğ‘’2)=ğœ2 subtype(ğœ1,ğœ2)
Annotation @ğ‘¡ ğ‘¡:ğœ annotation (ğœ)
Inner Class ğ‘¡.ğ‘ ğ‘¡ ğ‘¡:ğœ1,Î“(ğ‘¡.ğ‘ğ‘¡)=ğ‘ğ‘¡:ğœ2 simplename (ğœ2,ğ‘ğ‘¡)
innerclass (ğœ1,ğœ2)
Qualified Name ğ‘›.ğ‘  ğ‘› ğ‘ ğ‘›:ğœ fqn(ğœ,ğ‘›.ğ‘ ğ‘›)
Field ğ‘’.ğ‘“ Î“(ğ‘’)=ğœ1,Î“(ğ‘’.ğ‘“)=Î“(ğ‘“)=ğœ2 field(ğœ1,ğ‘“,ğœ2)
Method ğ‘’1.ğ‘š(/vecğ‘’2) Î“(ğ‘’1)=ğœ1,Î“(/vecğ‘’2)=/vecğœ2,Î“(ğ‘’1.ğ‘š(/vecğ‘’2))=ğœ3method(ğœ1,ğ‘š,/vecğœ4,ğœ3)
/vecğœ4=[createğœğ‘forğœğ‘ in/vecğœ2] âˆ€/angbracketleftğœğ‘ ,ğœğ‘/angbracketrightâˆˆ/angbracketleft/vecğœ2,/vecğœ4/angbracketright,subtype(ğœğ‘,ğœğ‘ )
New Instance newğ‘¡(/vecğ‘’) ğ‘¡:ğœ1,Î“(/vecğ‘’)=/vecğœ2,Î“(newğ‘¡(/vecğ‘’))=ğœ3 method(ğœ1,"<init>" ,/vecğœ4,ğœ3)
/vecğœ4=[createğœğ‘forğœğ‘ in/vecğœ2] âˆ€/angbracketleftğœğ‘ ,ğœğ‘/angbracketrightâˆˆ/angbracketleft/vecğœ2,/vecğœ4/angbracketright,subtype(ğœğ‘,ğœğ‘ )
Instance Of ğ‘’instanceof ğ‘¡ğ‘¡=ğœ1,Î“(ğ‘’instanceof ğ‘¡)=ğœ2 subtype(ğœ2,"boolean")
Array Access ğ‘’1[ğ‘’2] Î“(ğ‘’1)=ğœ1,Î“(ğ‘’2)=ğœ2 subtype(ğœ2,"int")
to retrieve the following type candidates for each type variable
(Note that the candidates are pruned for illustration purpose.).
Constraint Query Candidates
simplename (ğœ1,"List") Î©simplename("List")java.util.List
java.awt.List
simplename (ğœ2,"Date") Î©simplename("Date")java.util.Datejava.sql.Date
simplename (ğœ3,"ArrayList" )Î©simplename("ArrayList" )java.util.ArrayList
Building Refined Knowledge Bases. Based on the informa-
tionof thetype candidates,we nextbuild therefined knowledge
base. We first look into ğ¶to findparamtype constraints which
represent instantiations of generic types in code snippets. It is
paramtype (ğœ1,ğœ2,ğœ4)in this example. From this constraint, we
know that ğœ1should be a generic type, and therefore we remove
java.awt.List from the candidate set of ğœ1as this class is not
generic;ğœ2canbeeither java.util.Date orjava.sql.Date ;there-
fore,ğœ4can be either of the following two concrete types
â€¢java.util.List<java.util.Date>
â€¢java.util.List<java.sql.Date>
Fromtheconstraint subtype(ğœ4,ğœ3),weneedtofurtherinstantiate
two concrete classes of java.util.ArrayList as follows,
â€¢java.util.ArrayList<java.util.Date>
â€¢java.util.ArrayList<java.sql.Date>Next,wecreatearefinedknowledgebase Î©/primebycombiningthese
fourconcreteclassesand Î©.Themethod T java.util.List.get(int)
inÎ©becomes the following two methods in Î©/prime,
â€¢java.util.Date java.util.List<java.util.Date>.get(int)
â€¢java.sql.Date java.util.List<java.sql.Date>.get(int)
ConstraintSolving. Intheend,weuseaDatalogsolvertosolve
ğ¶by using Î©/primeas the Datalog facts. The benefit of using Î©/primeis
obvious: when the Datalog solver sets ğœ2to either concrete Date
type,ğœ5â€”the return type of the method call get(0)â€”will have the
same type as ğœ2, thanks to the specialized get(int) methods in
Î©/prime. In contrast, if we use Î©as the Datalog facts, the Datalog solver
cannot infer that ğœ5should always be the same as ğœ2.
3.5 Type Inference: Candidate Prioritization
Given a code snippet ğ‘ and the set of type variables ğ‘‡extracted
fromğ‘ , the type inference engine in Â§3.4 outputs a set of FQNs for
eachğœâˆˆğ‘‡as well as sets of libraries defining each FQN.
Solution Candidates. ThenSnRprocesses the type inference
result ofğ‘and outputs a list of solution candidates. Each candidate
1Vector/vecğœ4iscreatedformethodandnewinstanceexpressionwherenewtypevariables
ğœğ‘iscreatedforeachtypevariablein /vecğœ2;foreachpairoforiginalandnewlycreated
type variable /angbracketleftğœğ‘ ,ğœğ‘/angbracketrightfrom the two vectors /angbracketleft/vecğœ2,/vecğœ4/angbracketright, generate a subtypeconstraint.
1988
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:53:04 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Yiwen Dong, Tianxiao Gu, Yongqiang Tian, and Chengnian Sun
Table 5: Statistics of the StatType-SO benchmark.
(a) The number of public or pro-
tected, classes, fields, and methods
for each library in StatType-SO.
Library Classes Fields Methods
Android 2,357 8,943 22,933
JDK 11,881 28,443 105,807JodaTime 143 166 3,053GWT 1,518 542 9,288Hibernate 2,356 1,681 18,749XStream 628 146 3,855
Total 18,883 39,921 163,685(b) Top 5 simple class
names in the StatType-
SO dataset with their re-spectivenumberofoccur-rences.
Class Name Occurrences
Builder 71
EntrySet 40
Type 38
Entry 30
PropertyKeys 29
is a set of triples in the form
{/angbracketleftğœ,fqn,lib/angbracketright|ğœâˆˆğ‘‡,fqnis a FQN for ğœ,libis a library defining fqn}
PrioritizationHeuristic. Tomake SnRusefulandaccurateat
repairing code snippets, we design a simple yet effective prior-
itization heuristic to rank these solution candidates so that the
candidatesatthetopoftherankinglistaremorelikelytobecorrect
than those atthe bottom. The general principle ofthis heuristic is
to minimize the number of unique libraries in a candidate. Take
Table 1 for an example. The third candidate is ranked after the
first twobecause the thirdone hasone more library, i.e.,gwt. The
intuitionbehindourheuristicissimilartotheclusteringhypothesis
proposed in [36].
4 EVALUATIONS
Wehaveconductedextensiveevaluationsof SnRindifferentaspects
to answer the following research questions.
RQ1:How does SnRperform at type inference?
RQ2:How does SnRperform at resolving import statements
RQ3:DoesSnRrecommend the correct libraries?
RQ4:Howdoes SnRperformatmakingcodesnippetscompilable?
RQ1 to RQ4 evaluate the performance of SnRcompared to the
state-of-the-art type inference tools. Since Coster has been shown
tomatchoroutperformpriortechniques[ 32];thusinthispaperwe
onlycompare SnRwithCoster.ThesourcecodeofCoster,along
with their model, was obtained from its github repository [29].
Weuseprecision,recall,and ğ¹1scoretomeasuretheperformance
ofSnRconsidering only the top candidate, as used by Coster.
Precision =recommendations made âˆ©relevant
recommendations made
Recall =recommendations made âˆ©relevant
recommendations requested
F1=2Ã—PrecisionÃ—Recall
Precison+Recall
Dataset. We use an existingdataset referred toas StatType-SO,
which was used in [ 25,32]. The dataset consists of 267 snippets
fromsixpopularlibraries.Table5listsvariousstatisticsofStatType-
SO. All the public classes, fields, and methods are counted not
includinginheritedfieldsandmethods.Thisdatasetrepresentshowdevelopers use a wide variety of real Java libraries in practice, and
evaluations using this dataset demonstrate that our technique is
sound for libraries ranging from small to large. This benchmark
which consists of the code snippets and the libraries was obtained
from the original benchmark authors Phan et al. [25].
Implementation. SnRis a single-threaded Java application and
uses MariaDB to serve as the knowledge base. The constraints
are solved using SoufflÃ©[13] Datalog solver. We use Eclipse Java
Compiler to create and traverse ASTs. A replication package is
available at https://doi.org/10.5281/zenodo.5843327.
HardwareConfiguration. All experiments were conducted on
aneight-year-oldlaptopwithIntelCorei5-4300mCPU2.60GHz
and 16GB RAM. The operating system is Linux.
4.1 RQ1: How does SnRperform at type
inference?
We measured SnRâ€™s and Costerâ€™s performance in recommending
FQNsforAPIelements( i.e.,simplenames,fieldaccessesandmethod
callsasdefinedin[ 32])inStatType-SO.Theresultsaresummarized
inTable6. SnRsignificantlyoutperformsCosterinprecision(98.20%
vs 66.35%) and recall (79.66% vs 66.35%). Coster often incorrectly
recommend the more popular Apache commons logging library as
opposedto android.util.Log ,despitethefacttheyhavedifferent
logging methods. SnRon the other hand is able to achieve 100%
precision for three out of the six libraries in the dataset.
Table 6: Performance of type inference for API elements.
Coster SnR
Precision Recall Precision Recall
Android 43.28% 43.28% 100.00% 93.64%
JDK 56.24% 56.24% 97.37% 71.12%JodaTime 57.14% 57.14% 100.00% 89.47%GWT 90.75% 90.75% 96.68% 75.84%Hibernate 90.38% 90.38% 99.32% 94.81%XStream 88.41% 88.41% 100.00% 100.00%
Total 66.35% 66.35% 98.20% 79.66%
Table 7: Performance of type inference for type elements.
Total Analyzed Correct Precision Recall
Android 1,690 1,452 1,308 90.08% 77.40%JDK 12,450 10,245 9,166 89.47% 73.62%JodaTime 1,283 1,051 1,013 96.38% 78.96%GWT 2,273 1,951 1,679 86.06% 73.87%Hibernate 1,583 1,496 1,407 94.05% 88.88%XStream 864 864 804 93.06% 93.06%
Total 20,143 17,059 15,377 90.14% 76.34%
1989
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:53:04 UTC from IEEE Xplore.  Restrictions apply. SnR: Constraint-Based Type Inference for Incomplete Java Code Snippets ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
To further understand the performance of SnR, we applied SnR
to infer FQNs for all type elements (defined in Definition 3.1) in
StatType-SO, which is a much more difficult task than inferring
FQNs for API elements because type elements are a large super set
of API elements. Note that Coster is not capable of doing this task.
Tocomputethegroundtruth,foreachcodesnippetweprovided
theproperlibrariestoEclipseandusedEclipsetofindandcomputetypesforthetypeelementsinthedataset.Intheend,Eclipsefound
20,143 type elements along with their types in total.
Table7showstheperformanceof SnRonthistask.Amongthose
type elements, SnRanalyzed 17,059 ones and 15,377 were correctly
inferred, achieving precision of 90.14% and recall of 76.34%. This
highprecisionandrecallforalltypeelementsfurtherdemonstrates
the advantages of SnRover the state of the art, which also enables
SnRto accurately, reliably repair incomplete code snippets.
4.2 RQ2: How does SnRperform at resolving
import statements?
We useSnRand Coster to resolve import statements for all code
snippets. Because Coster was not explicitly designed to support
catchandannotationexpressions,weautomaticallycompleted56
of those import statements for Coster.
Table8summarizestheresults.Overall, SnRcorrectlyresolved
91.0% of the import statements, whereas Coster could only resolve
36% though 56 import statements were resolved by us.
Table 8: Performance of inferring import statements.
Total Imports SnRCompleted Coster Completed
Android 220 205 (93.2%) 18 (8.2%)
JDK 332 294 (88.6%) 174 (52.4%)
JodaTime 134 118 (88.1%) 35 (26.1%)
GWT 301 265 (88.0%) 90 (29.9%)
Hibernate 159 149 (93.7%) 101 (63.5%)
XStream 152 150 (98.7%) 49 (32.2%)
Total 1,298 1,181 (91.0%) 467 (36.0%)
01234567891 0 1 1 1 2 1 3 1 4 1 5 1 6020406080100120140160180# of snippetsCoster SnR
Figure 7: The distribution of code snippets w.r.t.number
of missing import statements after repair using SnRand
Coster. Points with ğ‘¦=0are not plotted.
Different from Table 8 which shows the information on com-
pleted import statements, Figure 7 shows the information on miss-
ing import statements. The x-axis is the number of missing importstatements ranging from 0, and the y-axis is the number of code
snippetswiththe xnumberofmissingimportsafterbeingrepaired
by either SnRor Coster. SnRcan completely repair 198 code snip-
petswithoutmissingimportstatements,comparedtoonly35by
Coster; for SnR, most of the rest code snippets have one or two
missing imports, while for Coster, most of the rest have one to
sevenmissingimports.Thisfiguredemonstratesthat SnRisableto
resolvemoreimportstatementsaccuratelythanCoster,andthus
can potentially save more developersâ€™ time.
Real world example. Recently,Costerhasbeenreleasedasan
Eclipseplugin[ 31]forfindingFQNsincodesnippets.Theauthor
produced a demonstration video [ 30] illustrating the new inte-
gration with Eclipse to fix import statements. In the video, the
authors attempted to repair the code snippet from Stack Overflow
post [6] for which Coster failed to create import statements for
DateTimeZone andDateTimeFormat .Weapplied SnRonthesame
code snippet, and SnRprecisely resolved allimport statements.
4.3 RQ3: Does SnRrecommend the correct
libraries?
Weevaluatedtheaccuracyof SnRâ€™slibraryrecommendation.We
manually examined each code snippet in the dataset to find all the
dependentlibraries,notjustthesixusedinthepreviousevaluations.
There were 33 unique libraries in total.
We compared SnRagainst a naive (SnR Naive) approach where
libraries are sorted alphabetically and taken greedy until all the
missing libraries are satisfied, to validate whether our candidateprioritization heuristic detailed in Â§3.5 is effective. We also com-
paredagainstCosterwhichrecommendsalllibrariescontainingthe
inferredFQNs.Foreachcodesnippet,therecommendationresult
is classified into one of the following categories.Sameif the tool recommends the exact expected libraries.
Different
if the tool recommends one or more alternatives for
some expected libraries.
Extraif the tool recommends a superset of the expected libraries.
Missing if the tool recommends a subset of the expected libraries.
Noneif the tool incorrectly recommends no libraries.
Table 9: SnRlibrary recommendation compared to a naive
candidate prioritization SnR Naive, and Coster.
Same Different Extra Missing None Precision Recall ğ¹1
SnR 183 62 11 4 7 0.82 0.83 0.82
SnRNaive 118 75 64 3 7 0.68 0.81 0.72
Coster 34 36 129 8 60 0.47 0.68 0.53
Table9liststheclassificationresult. SnRcorrectlyrecommended
theexactlibrariesfor183codesnippets,comparedto118for SnRNaive
and 34for Coster. SnRalso achievedthe highestprecision andre-
call, and thus we concluded that SnRperformed the best among
the three tools, which further demonstrates that our candidate pri-
oritizationstrategyinÂ§3.5iseffectiveinimprovingtheaccuracyof
type inference.
1990
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:53:04 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Yiwen Dong, Tianxiao Gu, Yongqiang Tian, and Chengnian Sun
4.4 RQ4: How does SnRperform at making
code snippets compilable?
4.4.1 Efficacy. To evaluate the efficacy of SnRat automatically
makingcodesnippetscompilable,wecompiledtherepairedcode
snippets and recorded the remaining errors. SnRachieved an aver-
ageof73.8%where197outof267snippetswerecompilableafter
therepair.Costerontheotherhandcouldmakeonly9.0%(24outof
267)ofsnippetscompilable.Ourhigh-precisiontypeinferencetech-niqueallowsforhigher-qualityrepairandresultsinalargernumberofcompilablecodesnippetsthusallowsformoreinformationtobe
recovered from each code snippet.
4.4.2 Efficiency. SnRis efficient enough to be used in practice.
Averagedoverfiveruns, SnRâ€™srepairprocessfinishedinanaverage
of 11.7 seconds for each snippet and half the snippets finished
within8.4seconds.AsseeninFigure8,thetime SnRtakestorepair
asnippetincreasesas thenumberofimports inasnippetincreases.
But even for a very complex code snippet, the slowest one finished
in 82.2 seconds on an eight-year-old laptop.
0 5 10 15 20020406080
Number of ImportsTime (s)
Figure8:Thetimeittakestorepairasnippetwith Xnumber
of imports. Each Ã—represents a snippet.
Costercanfinishrepairingacodesnippetveryfastinseconds,de-
spiteitslowefficacyinrepairingcodesnippetsforcompilation.On
the other hand, Coster is based on machine learning, and requires
training a model, which can take days to finish.
5 DISCUSSION
Inthissection,wewilldiscusspotentialapplicationsofourwork(Â§5.1),
along with the limitations of our technique (Â§5.2) and potential
threats to validity (Â§5.3).
5.1 Application
SnRhas immediate applications for software engineering.
IDEImprovement. Theconstraint-basedtechniqueusedin SnR
can be readily used by existing IDEs to provide accurate code com-
pletion suggestions. For example, given the code snippet shown
inFigure1,currentlyEclipsedoesnotproperlyleveragetherela-
tion between Dateand the other APIs, and thus may incorrectly
rankjava.sql.Date beforejava.util.Date . With the help of
SnR,Eclipsecanpreciselyrecommendimporting java.util.Date .
Anothersalientapplicationof SnRistoautomaticallyimportde-
pendenciesforpastedcodesnippets.CosterhasprovidedanEclipse
pluginofasimilarpurpose[ 31].AsdemonstratedinÂ§4, SnRout-
performs Coster and can effectively improve the performance ofsuchanIDEfeature.Ascodesnippetsaregenerallysmallanddevel-
opers infrequently copy large chunks of code from SO, thus SnRâ€™s
inference time is sufficient for real world use.
Dependency Repair. Dependency-related issues account for a
large number of build failures at Google [ 19]. The state-of-the-art
tool for fixing dependency issues is DeepDelta, which leverages
adeeplearningmodeltolearnhowdevelopersfixsuchissuesin
the past, and apply the model for new build failures. SnRcan com-
plement DeepDelta, as SnRmakes full use of type systems built
inprogramminglanguages,overlookedbyDeepDelta.With SnR,
failed compilation due to missing libraries can be automatically re-
paired by running the inference and adding the suggested libraries.
StackOverflowStudy. SnRcanincreasetheprecisionandscope
ofanalysisononlinecodesnippets[ 4,21,27,41,44].Itcanbeused
to fix the incomplete code snippets, and the followed analysescan take advantage of the compilable snippets which can offermore semantic information about the snippets; to provide better
metriconwhatmakesagoodcodesnippet[ 21];toaidtrainingof
algorithmsthatuseSOsnippets[ 41];tobetterexistingIDESOcode
recommendation tools [27].
5.2 Limitation
Certain code snippets reference classes not in the knowledge base
andthuscannotbeinferred e.g.fromaclasswritteninatutorial.
This limitation impacts the efficacy of both SnRand previous solu-
tionsalike.Weaddressthislimitationbyprovidingpartialsolutionsbyignoringthetypevariableswithoutcandidateswhichmayintro-
duceinaccuracies.However,ascanbeseenfromRQ1-4, SnRstill
outperforms the state-of-the-art tool.
5.3 Threats to Validity
Internal. Wedidourbesttominimizepotentialinternalvalidity
issues. Our SnRimplementation may contain bugs leading to in-
correct repair. We mitigated this by reviewing the instances where
SnRisunabletoperformrepairsteps.Toensuretheintegrityofour
evaluations,weexternalizedtheevaluationscriptstoensurebothSnRand Coster areevaluated in the same manner. ForCoster, we
pulled the code and model from their public Github repository and
followed their instruction to set up their tool. These mitigations
ensure weâ€™re presenting a fair comparison for SnR.
External. Intermsofexternalvalidity,thereisariskourwork
may not generalize to other programming languages. The con-
straints are fairly universal and can apply to other object oriented
languages.Mostlanguageshavefieldsandmethods.Genericsare
common in other typed languages, e.g.C#, Rust, Swift, TypeScript.
Theconstraintsolvingstageislanguageagnostic.Thusourtech-
nique does not rely on Java specific constructs and can be adapted
for other programming languages.
6 RELATED WORK
TypeInference. Theareaoftypeinferencehavearichhistoryin
programminglanguagesspeciallyobject-orientedlanguages[ 10,22,
23,33,38].Constraintshavealsobeenusedfortypeanalysis[ 2,38].
Ourworkdepartsfromexistingworksinthisareabyworkingwith
incomplete code and leveraging a knowledge base.
1991
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:53:04 UTC from IEEE Xplore.  Restrictions apply. SnR: Constraint-Based Type Inference for Incomplete Java Code Snippets ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
Typeinferenceonincompletecodehasseensomerecentinter-
ests[25,32,35].Ourworkissimilartosomeoftheearlierworks
from Subramanian et al . [35]in the use of constraints but differ in
somekeywayssuchas,(1)generictypehandling,(2)methodofsolv-
ing, and (3) selection of multiple compatible candidates. Their tool
Bakerreliedonsimpleconstraintsanddoesnotprovidelibraryrec-
ommendations. More recent works surpassed Bakerâ€™s performance
using statistical models to improve inference accuracy [ 25,32].
These models are trained using alarge set of existing [ 18] or col-
lected popular Github projects and are evaluated using hand col-
lectedSOpostsincludingStatType-SO.Saifullahetal .[32]improved
uponthemodelbyPhanetal . [25]byleveraginglocalandglobal
context.Ourworkimprovesuponthestateoftheartandcompli-
ment the existing techniques. Future techniques can incorporate
the accuracy of constraint based techniques with the performance
of statistics based ones.
Deep learning models [ 11,16] has been used to conduct type
inference on dynamically typed languages. Unlike SnR, these tech-
niques often use additional sources of information such as com-
ments, method and variable naming to conduct their inference.
Partial Program Analysis. RecoDoc [ 7] is a tool for analyzing
partialprogramswhicharesubsetsoftheprogramsourcefiles.Code
snippetsontheotherhandcanbeconsideredtobesubsetsofpartial
programs. Thus, the techniques for analyzing partial programs are
insufficient for analyzing code snippets.
StackOverflow Snippet. Past research have leveraged SO snip-
petstobuildbetterdevelopmenttools[ 27,41],tostudyusagesin
open source projects [ 4,17,43,44], and more [ 25,32,36,40]. Re-
cent work have used heuristics based approaches to automatically
synthesiscompilablecodesnippets[ 36,37].Ourworkfocuseson
typeinferenceandgreatlyimprovesuponprecisioncomparedto
the existing state of the art solution.Automated Repair.
In the area of automated repair, prior re-
searchhasattemptedtoaddresscompilererrorsusingneuralnet-
works [19], semantic errors leveraging test cases [ 15], or specifi-
cations(pre-andpostconditions)[ 24].Ourworkfocusesoncode
snippets which are incomplete code, without tests or specifications
inmostcases.Ourtechniqueneedtobemoreflexibleandcannot
rely on having test code or specifications.
7 CONCLUSION
This paper proposes SnR, a novel, effective, constraint-based tech-
nique to automatically infer missing import statements and depen-
dent libraries for Java code snippets. Given an incomplete snippet,
SnRfirst automaticallygathers constraintsfrom thesnippet, then
solvestheseconstraintsbyqueryingaknowledgebasebuiltfrom
a large collection of Java libraries, and finally transforms the so-
lutions to the constraints to import statements and dependency
libraries.Ourcomprehensiveevaluationof SnRontheStatType-SO
benchmarkconsistingof267snippetsdemonstratesthat SnRsig-
nificantly outperforms the state of the art: SnRcompleted 91.0% of
theimportstatements,andcompiled73.8%ofthesnippets.Evenfor
thefail-to-repair snippets,ourbest-effortrepair leftmostofthem
withonlyonemissingimportstatement.Thehighinferencepre-
cision of SnRopens up new opportunities of boosting developersâ€™
productivity with code snippets.ACKNOWLEDGMENTS
Wewouldliketothankalltheanonymousreviewersfortheirin-
sightfulcomments.WewouldliketothanktheauthorsofStatType
for providing their benchmark and authors of COSTER for helping
us run their tool. This work was funded by the Natural Sciences
andEngineeringResearchCouncilofCanada(NSERC)throughthe
Discovery Grant.
REFERENCES
[1]Rabe Abdalkareem, Emad Shihab, and Juergen Rilling. 2017. On code reuse from
StackOverflow:AnexploratorystudyonAndroidapps. InformationandSoftware
Technology 88 (2017), 148â€“158. https://doi.org/10.1016/j.infsof.2017.04.005
[2]Alexander Aiken and Edward L. Wimmers. 1993. Type Inclusion Constraints
and Type Inference. In Proceedings of the Conference on Functional Program-
ming Languages and Computer Architecture (Copenhagen, Denmark) (FPCA â€™93).
Association for Computing Machinery, New York, NY, USA, 31â€“41. https:
//doi.org/10.1145/165180.165188
[3]Nicholas Allen, Padmanabhan Krishnan, and Bernhard Scholz. 2015. Combining
Type-Analysis with Points-to Analysis for Analyzing Java Library Source-Code.
InProceedingsofthe4thACMSIGPLANInternationalWorkshoponStateOftheArt
inProgramAnalysis (Portland,OR,USA) (SOAP2015).AssociationforComputing
Machinery,NewYork,NY,USA,13â€“18. https://doi.org/10.1145/2771284.2771287
[4]SebastianBaltesandStephanDiehl.2019.UsageandattributionofStackOverflow
code snippets in GitHub projects. Empirical Software Engineering 24, 3 (2019),
1259â€“1295.
[5]Martin Bravenboer and Yannis Smaragdakis. 2009. Strictly Declarative Specifica-
tionofSophisticatedPoints-toAnalyses.In Proceedingsofthe24thACMSIGPLAN
Conference on Object Oriented Programming Systems Languages and Applications
(Orlando, Florida, USA) (OOPSLA â€™09). Association for Computing Machinery,
New York, NY, USA, 243â€“262. https://doi.org/10.1145/1640089.1640108
[6]cianBuckley. 2013. java - Joda Time converting time zoned date timeto milliseconds - Stack Overflow. Retrieved December 22, 2020from https://web.archive.org/web/20170227042935/http://stackoverflow.com/
questions/18274902/jodatime-converting-time-zoned-date-time-to-millis
[7]BarthÃ©lÃ©my Dagenais and Martin P. Robillard. 2012. Recovering TraceabilityLinks between an API and Its Learning Resources. In Proceedings of the 34th
International Conference on Software Engineering (Zurich, Switzerland) (ICSE â€™12).
IEEE Press, 47â€“57.
[8]Steven Dawson, C. R. Ramakrishnan, and David S. Warren. 1996. Practical
ProgramAnalysisUsing GeneralPurposeLogicProgrammingSystemsâ€”aCase
Study. In Proceedings of the ACM SIGPLAN 1996 Conference on Programming
LanguageDesignandImplementation (Philadelphia,Pennsylvania,USA) (PLDI
â€™96).AssociationforComputingMachinery,NewYork,NY,USA,117â€“126. https:
//doi.org/10.1145/231379.231399
[9]OegeDeMoor,GeorgGottlob,TimFurche,andAndrewSellers.2012. Datalog
Reloaded: First International Workshop, Datalog 2010, Oxford, UK, March 16-19,
2010. Revised Selected Papers. Vol. 6702. Springer.
[10]DavidGreenfieldboyceandJeffreyS.Foster.2007. TypeQualifierInferencefor
Java. InProceedings of the 22nd Annual ACM SIGPLAN Conference on Object-
OrientedProgrammingSystems,LanguagesandApplications (Montreal,Quebec,
Canada)(OOPSLA â€™07). Association for Computing Machinery, New York, NY,
USA, 321â€“336. https://doi.org/10.1145/1297027.1297051
[11]Vincent J. Hellendoorn, Christian Bird, Earl T. Barr, and Miltiadis Allamanis.
2018. DeepLearningTypeInference.In Proceedingsofthe201826thACMJoint
Meeting on European Software Engineering Conference and Symposium on theFoundations of Software Engineering (Lake Buena Vista, FL, USA) (ESEC/FSE
2018). Association for Computing Machinery, New York, NY, USA, 152â€“162.
https://doi.org/10.1145/3236024.3236051
[12]ShanShanHuang,ToddJeffreyGreen,andBoonThauLoo.2011. Datalogand
EmergingApplications:AnInteractiveTutorial.In Proceedingsofthe2011ACM
SIGMOD International Conference on Management of Data (Athens, Greece) (SIG-
MODâ€™11).AssociationforComputingMachinery,NewYork,NY,USA,1213â€“1216.
https://doi.org/10.1145/1989323.1989456
[13]Herbert Jordan, Bernhard Scholz, and Pavle SubotiÄ‡. 2016. SoufflÃ©: On Synthesis
of Program Analyzers. In Computer Aided Verification, Swarat Chaudhuri and
Azadeh Farzan (Eds.). Springer International Publishing, Cham, 422â€“430.
[14]Iman Keivanloo, Juergen Rilling, and Ying Zou. 2014. Spotting Working Code
Examples.In Proceedingsofthe36thInternationalConferenceonSoftwareEngi-
neering(Hyderabad,India) (ICSE2014).AssociationforComputingMachinery,
New York, NY, USA, 664â€“675. https://doi.org/10.1145/2568225.2568292
[15]C.LeGoues,T.Nguyen,S.Forrest,andW.Weimer.2012. GenProg:AGeneric
MethodforAutomaticSoftwareRepair. IEEETransactionsonSoftwareEngineering
38, 1 (2012), 54â€“72. https://doi.org/10.1109/TSE.2011.104
1992
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:53:04 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Yiwen Dong, Tianxiao Gu, Yongqiang Tian, and Chengnian Sun
[16]R. S.Malik, J. Patra, andM. Pradel. 2019. NL2Type: Inferring JavaScriptFunction
Types from Natural Language Information. In 2019 IEEE/ACM 41st International
Conference on Software Engineering (ICSE). 304â€“315.
[17]S. S. Manes and O. Baysal. 2019. How Often and What StackOverflow Posts
Do Developers Reference in Their GitHub Projects?. In 2019 IEEE/ACM 16th
International Conference on Mining Software Repositories (MSR). 235â€“239. https:
//doi.org/10.1109/MSR.2019.00047
[18]PedroMartins,RohanAchar,andCristinaV.Lopes.2018. 50K-C:ADatasetof
Compilable, and Compiled, Java Projects. In Proceedings of the 15th International
Conference on Mining Software Repositories (Gothenburg, Sweden) (MSR â€™18).
Association for Computing Machinery, New York, NY, USA, 1â€“5. https://doi.
org/10.1145/3196398.3196450
[19]Ali Mesbah, Andrew Rice, Emily Johnston, Nick Glorioso, and Eddie Aftandilian.
2019. DeepDelta: Learning to Repair Compilation Errors.
[20]Mayur Naik, Alex Aiken, and John Whaley. 2006. Effective Static Race De-tection for Java. In Proceedings of the 27th ACM SIGPLAN Conference on Pro-
gramming Language Design and Implementation (Ottawa, Ontario, Canada)
(PLDI â€™06). Association for Computing Machinery, New York, NY, USA, 308â€“319.
https://doi.org/10.1145/1133981.1134018
[21]S. M. Nasehi, J. Sillito, F. Maurer, and C. Burns. 2012. What makes a goodcode example?: A study of programmingQAi nStackOverflow. In 2012 28th
IEEE International Conference on Software Maintenance (ICSM). 25â€“34. https:
//doi.org/10.1109/ICSM.2012.6405249
[22]Nicholas OxhÃ¸j, Jens Palsberg, and Michael I. Schwartzbach. 1992. Making
typeinferencepractical.In ECOOPâ€™92EuropeanConferenceonObject-Oriented
Programming,OleLehrmannMadsen(Ed.).SpringerBerlinHeidelberg,Berlin,
Heidelberg, 329â€“349.
[23]JensPalsbergandMichaelI.Schwartzbach.1991. Object-OrientedTypeInference.
InConferenceProceedingsonObject-OrientedProgrammingSystems,Languages,
andApplications (Phoenix,Arizona,USA) (OOPSLAâ€™91).AssociationforCom-
putingMachinery,NewYork,NY,USA,146â€“161. https://doi.org/10.1145/117954.
117965
[24]Y. Pei,C. A.Furia,M. Nordio,Y. Wei, B.Meyer,and A.Zeller. 2014. Automated
FixingofProgramswithContracts. IEEETransactionsonSoftwareEngineering
40, 5 (2014), 427â€“449. https://doi.org/10.1109/TSE.2014.2312918
[25]H.Phan,H.A.Nguyen,N.M.Tran,L.H.Truong,A.T.Nguyen,andT.N.Nguyen.
2018. Statistical Learning of API Fully Qualified Names in Code Snippets ofOnline Forums. In 2018 IEEE/ACM 40th International Conference on Software
Engineering (ICSE). 632â€“642.
[26]Luca Ponzanelli, Alberto Bacchelli, and Michele Lanza. 2013. Seahawk: Stack
overflowin theide. In 2013 35thInternational Conferenceon SoftwareEngineering
(ICSE). IEEE, 1295â€“1298.
[27]Luca Ponzanelli, Gabriele Bavota, Massimiliano Di Penta, Rocco Oliveto, and
MicheleLanza.2014. Miningstackoverflowtoturntheideintoaself-confident
programming prompter. In Proceedings of the 11th Working Conference on Mining
Software Repositories. 102â€“111.
[28]C. Ragkhitwetsagul, J. Krinke, M.Paixao, G. Bianco, and R. Oliveto. 2019. Toxic
Code Snippets on Stack Overflow. IEEE Transactions on Software Engineering
(2019), 1â€“1. https://doi.org/10.1109/TSE.2019.2900307
[29]C. M.K. Saifullah.2020. COSTER. RetrievedMay 18,2020 fromhttps://github.
com/khaledkucse/COSTER
[30]C. M. K. Saifullah. 2020. COSTER: A Tool for Finding Fully Qualified Names
ofAPIElementsinOnlineCodeSnippets. RetrievedDecember22,2020from
https://youtu.be/oDZtw9MzUWM?t=208
[31]C M Khaled Saifullah, Muhammad Asaduzzaman, and Chanchal Roy. 2021.
COSTER:AToolforFindingFullyQualifiedNamesofAPIElementsinOnlineCode Snippets (ICSE â€™21 DEMO).
[32]C.M.K.Saifullah,M.Asaduzzaman,andC.K.Roy.2019. LearningfromExamples
to Find Fully Qualified Names of API Elements in Code Snippets. In 2019 34th
IEEE/ACM International Conference on Automated Software Engineering (ASE).
243â€“254.
[33]DanielSmithandRobertCartwright.2008. JavaTypeInferenceisBroken:Can
WeFixIt?.In Proceedingsofthe23rdACMSIGPLANConferenceonObject-Oriented
ProgrammingSystemsLanguagesandApplications (Nashville,TN,USA) (OOPSLA
â€™08).AssociationforComputingMachinery,NewYork,NY,USA,505â€“524. https:
//doi.org/10.1145/1449764.1449804
[34]Michael Stonebraker. 1988. Readings in database systems. Morgan Kaufmann
Publishers Inc.
[35]SiddharthSubramanian,LauraInozemtseva,andReidHolmes.2014. LiveAPI
Documentation.In Proceedingsofthe36thInternationalConferenceonSoftwareEn-
gineering (Hyderabad, India) (ICSE 2014). Association for Computing Machinery,
New York, NY, USA, 643â€“652. https://doi.org/10.1145/2568225.2568313
[36]Valerio Terragni, Yepang Liu, and Shing-Chi Cheung. 2016. CSNIPPEX: Auto-
mated Synthesis of Compilable Code Snippets from Q&A Sites. In Proceedings of
the 25th International Symposium on Software Testing and Analysis (SaarbrÃ¼cken,
Germany) (ISSTA2016).AssociationforComputingMachinery,NewYork,NY,
USA, 118â€“129. https://doi.org/10.1145/2931037.2931058
[37]Valerio Terragni and Pasquale Salza. 2021. APIzation: Generating Reusable
APIsfromStackOverflowCodeSnippets.In 202136thIEEE/ACMInternational
ConferenceonAutomatedSoftwareEngineering(ASE).542â€“554. https://doi.org/
10.1109/ASE51524.2021.9678576
[38]Tiejun Wang and Scott F. Smith. 2001. Precise Constraint-Based Type Infer-
enceforJava. In ECOOP2001â€” Object-OrientedProgramming,JÃ¸rgenLindskov
Knudsen (Ed.). Springer Berlin Heidelberg, Berlin, Heidelberg, 99â€“117.
[39]Ying Wang, Ming Wen, Zhenwei Liu, Rongxin Wu, Rui Wang, Bo Yang, Hai
Yu, Zhiliang Zhu, and Shing-Chi Cheung. 2018. Do the Dependency Conflicts
in My Project Matter?. In Proceedings of the 2018 26th ACM Joint Meeting on
European Software Engineering Conference and Symposium on the Foundations of
SoftwareEngineering (LakeBuenaVista,FL,USA) (ESEC/FSE2018).Association
for Computing Machinery, New York, NY, USA, 319â€“330. https://doi.org/10.
1145/3236024.3236056
[40]A. W. Wong, A. Salimi, S. Chowdhury, and A. Hindle. 2019. Syntax and StackOverflow:AMethodologyforExtractingaCorpusofSyntaxErrorsandFixes.In2019 IEEE International Conference on Software Maintenance and Evolution
(ICSME). 318â€“322.
[41]E. Wong, Jinqiu Yang, and Lin Tan. 2013. AutoComment: Mining questionand answer sites for automatic comment generation. In 2013 28th IEEE/ACM
InternationalConferenceonAutomatedSoftwareEngineering(ASE).562â€“567. https:
//doi.org/10.1109/ASE.2013.6693113
[42]Di Yang, Aftab Hussain, and Cristina Videira Lopes. 2016. From Query to Usable
Code:AnAnalysisofStackOverflowCodeSnippets.In Proceedingsofthe13th
International Conference on Mining Software Repositories (Austin, Texas) (MSR
â€™16).AssociationforComputingMachinery,NewYork,NY,USA,391â€“402. https:
//doi.org/10.1145/2901739.2901767
[43]D. Yang, P. Martins, V. Saini, and C. Lopes. 2017. Stack Overflow in Github:
Any Snippets There?. In 2017 IEEE/ACM 14th International Conference on Mining
Software Repositories (MSR). 280â€“290. https://doi.org/10.1109/MSR.2017.13
[44]T. Zhang, D. Yang, C. Lopes, and M. Kim. 2019. Analyzing and Supporting Adap-
tation of Online Code Examples. In 2019 IEEE/ACM 41st International Conference
onSoftwareEngineering(ICSE).316â€“327. https://doi.org/10.1109/ICSE.2019.00046
1993
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:53:04 UTC from IEEE Xplore.  Restrictions apply. 