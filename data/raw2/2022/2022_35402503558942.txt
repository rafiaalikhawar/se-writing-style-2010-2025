Discovering FeatureFlag Interdependencies in MicrosoftOffice
MichaelSchrÃ¶der
TUWien
Vienna, Austria
michael.schroeder@tuwien.ac.atKatja Kevic
Microsoft
Cambridge, UK
Katja.Kevic@microsoft.comDanGopstein
Microsoft
New York, USA
Dan.Gopstein@microsoft.com
BrendanMurphy
Microsoft
Cambridge, UK
Brendan.Murphy@microsoft.comJennifer Beckmann
Microsoft
Redmond, USA
Jennifer.Beckmann@microsoft.com
ABSTRACT
Feature flags are a popular method to control functionality in re-
leasedcode.Theyenablerapiddevelopmentanddeployment,but
canalsoquicklyaccumulatetechnicaldebt.Complexinteractions
between feature flags can go unnoticed, especially if interdepen-
dent flags are located far apart in the code, and these unknown
dependencies could become a source of serious bugs. Testing all
possible combinations of feature flags is infeasible in large sys-
tems like Microsoft Office, which has about 12000active flags. The
goalofourresearchistoaidproductteamsinimprovingsystem
reliability by providing an approach to automatically discover fea-
ture flag interdependencies. We use probabilistic reasoning to infer
causalrelationshipsfromfeatureflagquerylogs.Ourapproachis
language-agnostic,scaleseasily tolargeheterogeneouscodebases,
and is robust against noise such as code drift or imperfect log data.
Weevaluatedourapproachonreal-worldquerylogsfromMicrosoft
Office and are able to achieve over 90% precision while recalling
non-trivialindirectfeatureflagrelationshipsacrossdifferentsource
files.Wealsoinvestigatedre-occurringpatternsofrelationshipsand
describe applications for targeted testing, determining deployment
velocity,errormitigation,anddiagnostics.
CCSCONCEPTS
Â·Software and its engineering â†’Software configuration
management and version control systems ;Â·Mathematics of
computingâ†’Probabilistic inference problems .
KEYWORDS
feature flags,loganalysis,causalinference,combinatorialtesting
ACM ReferenceFormat:
MichaelSchrÃ¶der,KatjaKevic,DanGopstein,BrendanMurphy,andJennifer
Beckmann.2022.Discovering Feature FlagInterdependenciesinMicrosoft
Office. In Proceedingsofthe 30thACM Joint European Software Engineering
Conferenceand Symposium on theFoundations of SoftwareEngineering (ES-
EC/FSEâ€™22),November14Å›18,2022,Singapore,Singapore. ACM,NewYork,
NY, USA, 11pages.https://doi.org/10.1145/3540250.3558942
ESEC/FSE â€™22,November 14Å›18, 2022, Singapore, Singapore
Â©2022 Copyright held bytheowner/author(s).
ACM ISBN978-1-4503-9413-0/22/11.
https://doi.org/10.1145/3540250.3558942if(NEW_DESIGN &&DARK_MODE ) {
reduceBrightness();
}else{
showWhiteBackground();
if(!RIPCORD_3456 ) {
playAnimation();
}
}
(a) Sourcecode
NEW_DESIGN DARK_MODE
RIPCORD_3456
(b) Interdependencies
Figure 1: Example of feature flag usage
1 INTRODUCTION
Feature flags, also known as Å‚feature toggles,Å¾ Å‚feature switches,Å¾
Å‚feature gates,Å¾ or Å‚change gates,Å¾ are a design pattern to condition-
ally enable a code path [ 12]. They are a popular method within the
software industry to provide the capability to control functionality
inreleasedcode.Developerscanwrapnewcodewithafeatureflag
which can then be dynamically toggled even after the software has
beendeployed.Thevalueofafeatureflagisevaluatedatruntime
anditiseitherqueriedfromaremotelocationordeterminedbased
on parameters in the source code. Feature flags are used to run
experimentsinproduction(e.g.,forA/Btesting),torolloutfeatures
inastagedmanner,orforemergencybugmitigation(Å‚e-brakesÅ¾).
In the case of an e-brake, a feature flag is toggled when faulty
behaviourisobservedsuchthatthebugcanbemitigatedrapidly
without releasing a new version of the software. For an example of
howfeature flags are usedin source code,see figure 1a.
Whilefeatureflagsenablerapiddevelopmentanddeployment
of software systems, they can also accumulate technical debt. Man-
aging many feature flags is complex and conflicts can result in
unexpectedandsometimesdisastrousbehaviour,asillustratedby
the failure at Knight Capital Group [ 15], where reusing an old
feature flag created erroneous trades in the stock market over a
45-minuteperiodandresultedinthecompanygoingfromoneof
Thiswork islicensedunderaCreativeCommonsAttribution4.0Interna-
tional License.
1419
ESEC/FSE â€™22, November14Å›18, 2022,Singapore, Singapore MichaelSchrÃ¶der,Katja Kevic, Dan Gopstein, BrendanMurphy,andJennifer Beckmann
the largest traders in US equities to becoming bankrupt. The man-
agementandcomplexityoffeatureflagsincreaseswhenflagsare
interdependent(figure 1b).Interdependenciesarise anytimeflags
arenested,whenthedynamicruntimevalueofoneflagdetermines
whether or not another flag is queried. In this way, code that is
far downstream from the Å‚parentÅ¾ flag can be affected, and the
inclusionofadditionalfeatureflagswillcauseyetmoreinterdepen-
dencies. The farther apart interdependent flags are in the source
code, the more indirect their relationship can be. Developers might
not even be aware that some flags are interdependent, especially if
the relationship extends beyond function, module, or even process
boundaries.Suchunknowndependenciescanbe(andhavebeen)
asourceofseriousbugsthattakeasignificantamountoftimeto
resolve.Onewaytomitigatethesebugswouldbetotestallpossible
combinationsoffeatureflags,butthisquicklybecomesinfeasible:
forthe12000feature flags currently active in the Microsoft Office
codebase,thiswouldamountto~ 7.2Ã—107testablecombinations,
assumingtheseare allsimpleboolean flagsÃwhichthey are not.
Thegoalofthisresearchistoaidproductteamstoimprovetheir
systemâ€™s reliability by providing a way to automatically determine
featureflaginterdependenciesinalargesoftwaresystem.Knowing
the relationships between feature flags that exist in a codebase
providesadiversityoftangiblebenefits:
â€¢Wecanreduceourtestburdenbytargetingonlyknownsets
ofinterdependent feature flags for combinatorial testing.
â€¢We can use the knowledge of feature flag relationships to
determine the ideal deployment velocity, the speed at which
changes controlledbyfeature flags can be rolledout.
â€¢We can save time diagnosing failures involving feature flags
by followingtheir transitive dependenciesand recognizing
common interdependency patterns.
â€¢Wecanpreventerrorsbyenablingdeveloperstocheckfor
risky dependencies before togglingafeature flag.
To this end, we developed a novel approach to analyze the fea-
ture flags that are currently active within the desktop Microsoft
Office Suite. As stated, Microsoft Office currently contains around
12000feature flags with different life spans. Every day feature
flags are being added and removed. A challenge in studying fea-
ture flag interdependencies in a large and mature system is that
feature flags can occur in code written in many different program-
ming languages. Furthermore, over the years, numerous APIs have
been written to wrap the official feature flag SDK for additional
requirements. The many different ways of defining feature flags
in the source code, across many different programming languages,
makesithardtousestaticordynamiccodeanalysistodetermine
interdependencies. The novelty of our approach is that we analyze
the logs that are emitted every time a feature flag is queried in a
runningMicrosoftOfficeapplication.Assumingfeatureflagqueries
arealreadybeinglogged,thepassivenatureofouranalysisrequires
no changes to the surrounding configuration infrastructure and is
completely decoupledfrom the sourcecode itself.
We investigate the following researchquestions:
RQ1Howcan we inferfeature flag interdependencies at scale?
RQ2What is the accuracy of our method in a real-world setting?
RQ3Do re-occurring patterns of feature flag relationships exist?2 RELATED WORK
Interdependent Feature Flags. The problem of interdependent
feature flags is one that has existed for several decades, beginning
in the world of telecommunication switching [ 2,9]. The modern
conundrum is well described by Rahman et al .[14], Å‚every change
totrunkshouldbetestedacrossallpossiblecombinationsofenabled
featuretoggles.Thisofcourseintroducesanexplosionofteststo
run.Å¾There isacommonposition that inpractice, featureflags do
not need to be exhaustively tested. Fowler [5]recommends to test
onlytwo combinations,Å‚allthetoggles onthat are expected tobe
on in the next releaseÅ¾ and Å‚all toggles on,Å¾ and Neely and Stolt
[13]suggest that combinatorial testing can largely be ignored if
theflagsareindependent,andtheseareoftenjustifiedbytheclaim
thatÅ‚mostfeatureflagswillnotinteractwitheachotherÅ¾[ 8].Inthe
case of Microsoft Office, however, the reality is quite the opposite.
There are hundreds of interdependent feature flags, and in the
courseofoureverydayjobswe haveencounteredmanyscenarios
whereundocumentedanduntestedinteractionsbetweenfeature
flagsresultedinundesirablebehavior.Thisunfortunatesituation
lead us to try to build an understanding of which feature flags
wereintertwinedwithothers.Thisgoalisdifficultthough,asnoted
by Meinicke et al . [12]who explain Å‚finding and understanding
interactionsisnontrivial,especiallywhenfeaturesaredeveloped
separately andthere are noclear specifications.Å¾
Moreover the types of interaction among feature flags are com-
plex as well. There are many ways for configuration data to be
dependentoneachother.Chenetal .[3]defineataxonomyofthese
dependenciesincluding Control,DefaultValue ,OverwriteValue ,and
Behavior dependencies. Our investigation focuses only on the Con-
troldependency, where the value of one feature flag determines
whether asecondfeature flag isorisnot executed.
Mechanism of Determining Interdependency. Before studying the
properties of interdependent feature flags, we first had to iden-
tify the relationships between each of the flags in Microsoft Office.
Some systems, such as the one used at Facebook [ 16] Å‚expresses
configurationdependencyassourcecodedependency,Å¾whichen-
tirelysolvestheproblemofdetermininginterdependency,however
itdependsonaspecificinfrastructurethatisnâ€™tavailableinmost
systems,includingours.
For many more systems, if interdependency relationships are
tobeestablished,itmustbedonebyinference,afterthecodehas
beenwritten.Medeirosetal . [10]proposedaconfiguration-space
sampling methodwhere they useda combination of samplingalgo-
rithmstofindconfigurationsthatresultedinruntimefaultssuch
as memory leaks and uninitialized variables. While they showed
thistechniquetobevaluable,itbecomeseitherlessaccurateorless
computationallyfeasibleifconfigurationspaceisverylarge,which
isthe casewithMicrosoftOffice.
A common method to analyse feature flags in the literature is to
havehumansvalidatewherefeatureflagsexistandwhattheyâ€™re
usedfor.Thisislikelyasymptomofresearchersneedingtooper-
ate overmanydisparatesystems thathaveheterogeneousfeature
flagging mechanisms as well as not having the same long-term
incentivestoautomatethediscoveryprocessthatthemaintainerof
anindividualsystemmighthave.Oneexampleofmanualflagdis-
cover is Meinicke et al . [11], who performed an automated search
1420DiscoveringFeature FlagInterdependenciesin MicrosoftOffice ESEC/FSE â€™22, November14Å›18, 2022,Singapore, Singapore
Log Time Feature Value
1 14:18:27 A False
1 14:18:27 C False
2 09:10:38 B False
2 09:10:38 C False
3 23:53:04 A True
3 23:53:04 B False
3 23:53:04 C False
(a)AF CF
(b)BF
ğ´ğ¹ CF
(c)AT BF
ğ´ğ¹ CF
(d)
ğ´ğ‘‡ ğµğ¹
ğ´ğ¹ ğ¶ğ¹
(e)ğ´ğ‘‡ ğµğ¹
ğ´ğ¹ ğ¶ğ¹
(f)ğ´ğ‘‡ ğµğ¹
ğ´ğ¹ ğ¶ğ¹
(g)
Figure 2:Usingquery logs (a) to discoverco-occurrences (bÅ›d) andinfercausalities (eÅ›g)
throughGitcommitmessagestofindrepositorieswhichlikelycon-
tained feature flags,but then used manualinspectionto verify the
flagsexisted. Asystemthesizeof MicrosoftOfficeis toolargefor
this approach, and instead the relationship between configuration
valuesmustbe discoveredas an automatedprocess.
The bulk of research on feature flag or configuration interde-
pendencyisdoneinastaticanalysiscontext.Forexample,Zhang
etal.[17]usestaticanalysistoanalyzewhichregionsofcodeare
effectedbyconfigurationoptions,andfromthat determinewhich
configurations depend on each other. Their goal was specifically to
findÅ‚silentmisconfigurations,Å¾configurationvalueswhichhaveno
effectontherunningprogram,oftenduetointeractionsbetween
configuration settings. Static analysishas many benefits including
well-definedcorrectnessguaranteesandtheabilitytofindpotential
future problems beforetheyâ€™re executed. Conversely, it is difficult
to have a static analysis system that can seamlessly process un-
conventional systems such as dynamically generated/loaded code,
programs that use multiple languages, and even large projects in a
singlelanguagethatareonlyabletobebuiltusingcomplexcompiler
configurationthat isdifficult to replicate inan external system.
Despite not being popular for investigating interdependency,
runtime analysis has proven useful in many contexts related to
independentconfigurations. Forexample, AttariyanandFlinn [1]
usedynamicinformationflowanalysistotracedatacomingfrom
configurationfilestoeventualerrorsasatoolforautomatedcon-
figuration debugging. Given the complexity of the Microsoft Office
engineering ecosystem, we opted for the more robust option of
dynamicanalysisonwhichto baseour investigation.
3 INFERRING RELATIONSHIPS
Foranytwofeatureflags ğ´andğµ,wewanttodeterminewhether
the value of ğ´determines if ğµis queried. In particular, we want to
determine if Å‚ ğ´causesğµ,Å¾ i.e.,ğ´â†’ğµ, or if the value of ğ´has no
effectonwhether ğµisqueried,i.e., ğ´â†›ğµ.
Forexample,the DARK_MODE flaginfigure 1isonlyqueriedifthe
value of the NEW_DESIGN flag is true (assuming short-circuitingof logical operators), so NEW_DESIGNâ†’DARK_MODE . However,
whetherornot DARK_MODE isqueriedisindependentofthevalue
oftheRIPCORD_3456 flag,soRIPCORD_3456â†›DARK_MODE .
Sometimes,featureflagrelationshipsareeasilyinferablefromthe
sourcecodeitself.Ingeneral,however,theheterogeneousnatureof
a large codebase makes static analysis difficult, especially for non-
localrelationships.Featureflagsmightbespreadacrossdifferent
compilation units or be only very indirectly related. In these cases,
we have to resort to dynamic analysis of the codeâ€™s actual runtime
behaviour.Fortunately,itispossibletodothisinanentirelypassive
manner, without changes to the source code. In Microsoft Office,
any timea feature flagisqueried during therunofanapplication,
the query is logged, together with the current value of the flag.
Figure2apresents a simplified example of such query logs. By
combining the logs from multiple runs exercising different parts of
anapplication,wecangainbroadinsightintoglobalfeatureflag
activation patterns.
3.1 Co-Occurrence Discovery
Ifğ´â†’ğµ, then we would expect the timespan Î”ğ´ğµ=ğ‘¡ğµâˆ’ğ‘¡ğ´
betweenanyparticularqueryof ğ´(attimeğ‘¡ğ´)andthefollowing
query of ğµ(at timeğ‘¡ğµ) to always be roughly the same, for all in-
stancesof ğ´andğµthatoccur inthe logs.Theactual valueof Î”ğ´ğµ
will be different for every pair of related feature flags and could
rangeanywhere from a few nanoseconds (e.g., forflags thatoccur
on the same line of code) to even a few seconds (e.g., for flags that
are relatedviasomeasynchronous operation, like copy-paste).
We can view Î”ğ´ğµas a relative measure of similarity between
the contexts in which flags ğ´andğµare evaluated. For example,
twoflagsthatarequeriedinasingleexpressiononthesamelineof
sourcecodehaveverysimilarevaluationcontexts,andthusasmall
Î”ğ´ğµ,aswilltwoflagsthatarelocatedinentirelydifferentsource
filesbutconnectedviaafunctioncall;however,twoflagsthatare
queried at entirely different points during an applicationâ€™s run will
havealarge Î”ğ´ğµ,regardlessofwhethertheyarespreadfarapart
inthe sourcecode orappear within afewlinesof eachother.
1421ESEC/FSE â€™22, November14Å›18, 2022,Singapore, Singapore MichaelSchrÃ¶der,Katja Kevic, Dan Gopstein, BrendanMurphy,andJennifer Beckmann
Wecancollectall co-occurring featureflagsbydraggingasliding
windowofsomeempiricallydeterminedsize Î”overthequerylogs,
selecting all feature flag pairs with Î”ğ´ğµâ‰¤Î”. Figures 2bto2d
demonstrate this process (with Î”=1s) and show how a graph
representationofthediscoveredco-occurrencesissuccessivelybuilt
up. In this co-occurrence graph, each vertex represents a feature
flagquerythatreturnedaparticularvalue( ğ´ğ¹meaningflag ğ´with
valueFalse) and each edge signifies that the two connected queries
co-occurredwithinthesametimewindow Î”.Notethattheedges
are directed: we take the temporal order of queries into account to
avoidaddingobviouslyparadoxicalrelationshipsÃifAisqueried
before B,then ğµâ†›ğ´.
Algorithm 1showstheco-occurrencediscoveryprocessindetail.
Althoughtheresultingco-occurrencegraphalreadysignificantly
reducesthestatespaceofpossiblerelationships(cf.section 4.1),itof
course includes many co-occurrences that are merely coincidental
andnotactualcausalrelationships.Todiscoverthose,weneedto
employ causalreasoning.
Algorithm1: Co-Occurrence Discovery
Input:setoffeature query logfiles ğ¿; time windowsize Î”
Output:co-occurrence graph ğº=(ğ‘‰,ğ¸)
letğº=(ğ‘‰,ğ¸)be an emptydirectedgraph;
foreach logfileğ¿do
foreach slidingtime window ğ‘ŠofsizeÎ”inğ¿do
foreach feature query ğ‘inğ‘Šdo
ifğ‘âˆˆğ‘‰then
increasethe ğ‘ğ‘œğ‘¢ğ‘›ğ‘¡ofğ‘inğ‘‰by1;
else
addğ‘toğ‘‰withan initial ğ‘ğ‘œğ‘¢ğ‘›ğ‘¡of1;
foreach 2-combination(ğ‘1,ğ‘2)inğ‘Šdo
if(ğ‘1,ğ‘2)âˆˆğ¸then
increasethe ğ‘ğ‘œğ‘¢ğ‘›ğ‘¡of(ğ‘1,ğ‘2)inğ¸by1;
else
add(ğ‘1,ğ‘2)toğ¸withan initial ğ‘ğ‘œğ‘¢ğ‘›ğ‘¡of1;
3.2 NaiveCausal Reasoning
Toturnaco-occurrencegraphintoa causalgraph ,whosevertices
represent single feature flags and whose directed edges indicate
causal parent-child relationships, we must look at the valuesof
prospectiveparentflags.Themain intuitionisthatif ğµisqueried
regardless ofthe valueof ğ´,thenğ´â†›ğµ.
To illustrate this, figures 2eto2gproceed with the running
exampleand successivelyeliminatenon-causaledges fromtheco-
occurrence graph. First, the edges ğ´ğ‘‡â†’ğ¶ğ¹andğ´ğ¹â†’ğ¶ğ¹are
removed(figure 2e),becauseifboth ğ´ğ‘‡andğ´ğ¹co-occurwith ğ¶ğ¹,
then neither can actually be a causal factor for ğ¶; the value of ğ´is
clearlyimmaterialto whether ornot ğ¶isqueried.
Next,ğµğ¹â†’ğ¶ğ¹is removed (figure 2f), because even though
we do not see ğµğ‘‡â†’ğ¶ğ¹, we also do not have any knowledge of
ğµğ‘‡â†›ğ¶ğ¹, asğµğ‘‡does not occur at all. Merely knowing of a co-
occurrence ( ğµğ¹â†’ğ¶ğ¹) is not enough evidence for us to assume
a causal relationship ( ğµâ†’ğ¶), we also require evidence of the
absence of counter-evidence ( ğµğ‘‡â†›ğ¶ğ¹). Put another way: in orderto determine that some feature flag is the parent of another, we
needtoseeboththecaseswheretheflagis(orcouldbe)theparent,
and the cases where it is not. It is only by contrasting these two
scenarios that we can gain information.
Finally,only ğ´ğ‘‡â†’ğµğ¹remains(figure 2g)andthusthecausal
graph issimply ğ´â†’ğµ.
3.3 Noise
Figure3shows a typical instance of a real-world co-occurrence
graph. Naive causal reasoning would require us to eliminate all of
itsedges,becausetheyclearlycontradictoneanother.Butnotallof
the(co-)occurrencesin thisgraphare equally valid; someofthem
are purely noise,whichcan appear for anumber of reasons:
BugsLogging feature flag queries happens in a variety of het-
erogeneous environmentsand involves local caching, asyn-
chronous batched network transmissions, and server-side
logprocessing.Bugscananddohappen:queriesgetdropped
or logged in duplicate, time-ordering gets mixed up, and so
on.Whilewecouldworkundertheassumptionthatbugsare
relativelyrareandcouldbemitigatedbyrigorouslycleaning
our input data, we would much prefer to be able to draw
valid conclusions from data that occasionally includes small,
inexplicableamountsofnoise.Suchisthenatureofindustrial
software engineering.
Crossed Signals Ourlogs containfeatureflag queriesacross
a variety of apps on a variety of platforms. Some of these
share the same featureflags butusethemin differentways,
exhibiting different interdependencies. It certainly makes
sense to process some subsets of our logs separately, e.g.,
partitioned by platform. On the other hand, since apps do
communicatewitheachotherandtherearelegitimatefea-
ture relationships that cross app boundaries, we would also
like to capture those.
CodeDrift Asthesourcecodechangesovertime,andfeature
flags are addedand removed, the relationshipsbetweenfea-
ture flags change as well. The query logs are like a slow
moving window sliding over the released app versions, cap-
turing multiple versions at once and slightly lagging behind
thelatestchangesinthesourcecode,butsteadilycatching
up. As most relationships between feature flags remain rela-
tivelystable,however,limitingourselvestoonlylogsfrom
the very latest (released or unreleased)app versions would
severelylimit the amount of data available for analysis.
Coincidences Sometimes the data justlines up in a way that
isindistinguishablefromarealsignal.Inprinciple,wewill
never be able to entirely rule out this kind of noise. In
practice,wewouldlikeouranalysismethodtobesensitive
enough to discardmany,if not most,such coincidences.
While some sources of noise can be mitigated, we would like to
deal with most data as-is. How can we infer causal relationships
in the presence of noise? And how can we be confident that our
inferences are correct, given that one small change in signal could
completely changethe result?
1422DiscoveringFeature FlagInterdependenciesin MicrosoftOffice ESEC/FSE â€™22, November14Å›18, 2022,Singapore, Singapore
ğ´ğ¹5152
ğ´ğ‘‡10089
ğµğ¹
3674ğµğ‘‡
147833051339
210 28
23ğ´?â†’ğµ
ğ‘ƒ(ğµ|ğ´ğ‘‡)=10/10089â‰ˆ0.00
ğ‘ƒ(ğµ|ğ´ğ¹)=(3305+1339)/5152â‰ˆ0.90
ğ‘ƒ(ğ´ğ‘‡|ğµ)=10/(3674+1478)â‰ˆ0.00
ğ‘ƒ(ğ´ğ¹|ğµ)=(3305+1339)/(3674+1478)â‰ˆ0.90
ğ¸ğ‘‡=((1âˆ’0.00)+0.90+(1âˆ’0.00)+0.90)/4=0.95
ğ¸ğ¹=(0.00+(1âˆ’0.90)+0.00+(1âˆ’0.90))/4=0.05ğµ?â†’ğ´
ğ‘ƒ(ğ´|ğµğ‘‡)â‰ˆ0.02
ğ‘ƒ(ğ´|ğµğ¹)â‰ˆ0.01
ğ‘ƒ(ğµğ‘‡|ğ´)â‰ˆ0.00
ğ‘ƒ(ğµğ¹|ğ´)â‰ˆ0.00
ğ¸ğ‘‡â‰ˆ0.50
ğ¸ğ¹â‰ˆ0.50
Figure 3: Causal inference on a noisy real-world co-occurrence graph. The scenario ğ´ğ¹â†’ğµis the most likely one, because its
errorvalue ğ¸ğ¹=0.05isthesmallest,indicating theleast deviationofits probabilities fromthe expected pattern.
3.4 Causal Reasoningwith Probabilities
Todealwithnoisydatawecanborrowsomenotionsfromproba-
bilitytheory.Wecanviewafeatureflagqueryasa randomevent
thateitheroccurswithinsometimewindowordoesnot.Wecan
alsoviewthevalueofthefeatureflagasthe outcomeoftheevent.
The probability that some feature flag ğµco-occurs with another
feature flag ğ´when the value of ğ´isğ‘¥can then be described by
theconditionalprobability
ğ‘ƒ(ğµ|ğ´ğ‘¥)=ğ‘ƒ(ğ´ğ‘¥âˆ©ğµ)
ğ‘ƒ(ğ´ğ‘¥)=co-occurrences of ğ´ğ‘¥withğµ
totaloccurrences of ğ´ğ‘¥.
Assumingthatweknow ğ´ğ‘¥occursbefore ğµ,thiscanbeinterpreted
as: Å‚How likely is it that ğµwill be queried if ğ´has the value ğ‘¥?Å¾
The inverseÃÅ‚How likely is it that ğ´had the value ğ‘¥if we know
thatğµwasqueried?Å¾Ãisgiven by
ğ‘ƒ(ğ´ğ‘¥|ğµ)=ğ‘ƒ(ğ´ğ‘¥âˆ©ğµ)
ğ‘ƒ(ğµ)=co-occurrences of ğ´ğ‘¥withğµ
totaloccurrences of ğµ.
Ifğ´hasğ‘˜possible (observed) values, then there are 2ğ‘˜such proba-
bilitiesbetween ğ´andğµ,assumingweknowthat ğ´comesbefore
ğµ(and thus the value of ğµis not relevant). But how do these proba-
bilitieshelpusdeterminewhether ğ´â†’ğµorğ´â†›ğµ?
Letusconsiderthe platonic ideal ofacausalrelationship:
if (A) {B}
Here,ğ´isassumedtobe abooleanflagandthisis theonlyoccur-
rence of both ğ´andğµin the source code. Clearly, the likelihood
thatğµwill be queried if ğ´is true is100%, while the likelihood that
ğµwill be queried if ğ´is false is 0%. Similarly, the likelihood that ğ´
was true if ğµis queried is 100%and the likelihood that ğ´was false
ifğµis queried is 0%. We observe ğ‘ƒ(ğµ|ğ´ğ‘‡)=1,ğ‘ƒ(ğµ|ğ´ğ¹)=0,
ğ‘ƒ(ğ´ğ‘‡|ğµ)=1,andğ‘ƒ(ğ´ğ¹|ğµ)=0.
Realistically, ğ´orğµmight occur multiple times in the source
code,possiblyinrelation withotherfeature flags:
if (A) {X} if (A && X) {B}
if (X) {B} if (X || A) {B}
The probabilities between ğ´andğµwill then be affected by some
valuesproportional tothenumberof additionalchildrenof ğ´and
additionalparentsof ğµ.Inparticular,wenowhave ğ‘ƒ(ğµ|ğ´ğ‘‡)=1âˆ’ğ›¼,
whereğ›¼is some term proportional to the number of additional
children of ğ´, andğ‘ƒ(ğ´ğ‘‡|ğµ)=1âˆ’ğ›½, whereğ›½is some term
proportional to the number ofadditionalparentsof ğµ.The table below gives the expected probabilities for the three
possiblescenarios: ğ´ğ‘‡â†’ğµ,whichwejustdiscussed;thecomple-
mentaryğ´ğ¹â†’ğµ,i.e.,replacing Aby!Ainthecode;andthecase
when neither ğ´ğ‘‡norğ´ğ¹are acause of ğµandthusğ´â†›ğµ.
ğ´ğ‘‡â†’ğµ ğ´ğ¹â†’ğµ ğ´â†›ğµ
ğ‘ƒ(ğµ|ğ´ğ‘‡)1âˆ’ğ›¼ 0 ğœ€1
ğ‘ƒ(ğµ|ğ´ğ¹)0 1âˆ’ğ›¼ ğœ€ 2
ğ‘ƒ(ğ´ğ‘‡|ğµ)1âˆ’ğ›½ 0 ğœ€3
ğ‘ƒ(ğ´ğ¹|ğµ)0 1âˆ’ğ›½ ğœ€ 4
In the case of ğ´â†›ğµ, the probabilities are unknown random
valuesğœ€1toğœ€4, about which we know nothing, except that they
are very unlikely to match the probabilities we expect in the other
two cases. The exact values of ğ›¼andğ›½are also unknown, and they
aredifferentforeachparticularcombinationoffeatureflags ğ´,ğµ,
andğ‘‹,butitisreasonabletoassumethatformostfeatureflagsthe
number of parents and children will be much closer to one than,
forexample,ten.Both ğ›¼andğ›½arethusexpectedtobesignificantly
smallerthanone onaverage.
Knowingwhichprobabilitiestoexpectfor ğ´ğ‘‡â†’ğµandğ´ğ¹â†’
ğµ, we can calculate two error values ğ¸ğ‘‡andğ¸ğ¹, indicating how
much reality deviates from the expectations for each scenario. The
smaller the error, the more likely the scenario; if both errors are
too large, then ğ´â†›ğµ. Figure3demonstrates these calculations on
anoisygraphbasedonrealdata.Intheremainderofthissection,
we formalize this ideaandgeneralize itto non-boolean flags.
ProbabilisticCausalInference. Assumethat ğ´andğµarefeature
flags, with ğ´havingğ‘˜observed values, and that ğ´occurs before ğµ.
Asashorthand,wewillwrite ğ´ğ‘–forthetotalnumberofoccurrences
ofğ´that return value ğ‘–,ğµfor the total number of occurrences of ğµ
(returninganyvalue),and ğ´ğ‘–ğµforthenumberofco-occurrences
ofğ´ğ‘–andğµ. For each of the ğ‘˜possible scenarios ğ´ğ‘–â†’ğµ, we can
compute an errorvalue
ğ¸ğ‘–=1
ğ‘˜+2/parenlefttpA/parenleftexA
/parenleftbtA/parenleftbigg
1âˆ’ğ´ğ‘–ğµ
ğ´ğ‘–/parenrightbigg
+ğ‘˜âˆ‘ï¸
ğ‘—â‰ ğ‘–ğ´ğ‘—ğµ
ğ´ğ‘—+/parenleftbigg
1âˆ’ğ´ğ‘–ğµ
ğµ/parenrightbigg
+ğ‘˜âˆ‘ï¸
ğ‘—â‰ ğ‘–ğ´ğ‘—ğµ
ğµ/parenrighttpA/parenrightexA
/parenrightbtA.
The overallerrorfor the possibility ğ´â†’ğµisthen given by
ğ¸=ğ‘˜
min
ğ‘–ğ¸ğ‘–.
1423ESEC/FSE â€™22, November14Å›18, 2022,Singapore, Singapore MichaelSchrÃ¶der,Katja Kevic, Dan Gopstein, BrendanMurphy,andJennifer Beckmann
Becauseğ¸only captures the relativeproportions between ğ´and
ğµ, we assess our confidence in ğ¸by computing the least absolute
number ofcontributingobservations
ğ‘=min(ğ´1,...,ğ´ğ‘˜,ğµ).
Then, for empirically determinedthresholds Ë†ğ¸andË†ğ‘,
ğ´â†’ğµifğ‘˜â‰¥2andğ¸â‰¤Ë†ğ¸andğ‘â‰¥Ë†ğ‘,
ğ´â†›ğµotherwise .
We are thus able to infer interdependence between feature flags
basedonobserved(co-)occurrences.
RQ1.Howcanweinferfeatureflaginterdependencies
at scale? Looking solely at query logs , we are able to discover
feature flags that repeatedly co-occurwithin certain time win-
dows.Basedonintuitionsaboutcodestructureandemploying
notions from probability theory, we developed a method of
probabilistic causal reasoning that is robust tonoise by calcu-
latinghowcloselyapairofco-occurringfeatureflagsmatches
an ideal causalrelationship.
4 EVALUATION
We implementedourinference mechanismin Pythonand applied
ittoreal-worldfeatureflagquerylogsfromMicrosoftOffice.We
chose a sub-sample of query logs restricted to a single release
platform and code fork, which made it easier to cross-reference
potential findings with the codebase. For a period of one week,
wecollectedabout2.5millionfeaturequeriesperday,fromabout
80000dailyappsessions.Weperformedco-occurrencediscovery
every day, with a time window size Î”=1Âµs, incrementally up-
dating our database of co-occurrences and re-calculating all causal
probabilities afterwards. At the end of the collection period, we
haddiscovered 5946317 pairsof12791co-occurringfeatureflags.
Of these, 326418pairs of5724feature flags are potentially causally
related(ğ¸â‰¤0.50)and593pairsof612featureflagswereconsidered
to be likely causally related ( ğ¸â‰¤0.25). Figure 5presents some
concrete examplesoffoundrelationships.
4.1 Precision
Toevaluatethe precision ofourapproachÃhowmanyoftherela-
tionships we uncover are actuallytrue causal relationships?Ãwe
cross-checkedtheresultsofourinferencealgorithmwiththeMi-
crosoft Office source code. We selected 200 pairs of 327 feature
flagsinapurposivesamplecoveringtherangeof ğ¸andğ‘values
returned by our algorithm. The sample is balanced, with 107of
thesamplepairsexhibitingarealcausalrelationshipinthecode-
base, and 93of no discernible causality. We manually inspected the
sourcecodelocationsofeachselectedfeatureflagpairtodetermine
causality. This was a time-consuming process, as it is often not im-
mediately apparent whether a causal relationship exists, especially
for relationships that would be rather indirect. We erred on the
sideofcaution,andonlyreportedtruepositiveswhenthecausal
relationship wasclear beyond doubt;if the examinerwas not able
toestablishacausalrelationshipaftersometime(typicallyabout
15 minutes), the feature flag pair in question was marked as a false0.50.60.70.80.91.0
0.0 0.1 0.2 0.3 0.4 0.5
E^PrecisionN^
100
10
1
Figure 4: Precision for different values of Ë†ğ¸andË†ğ‘. As our
willingnesstoacceptunlikelycandidatesincreases,sodothe
rates offalsepositive parent-child relationships.
Table 1:Precision for Ë†ğ‘=100and differentvaluesof Ë†ğ¸
Discovered Verified Falsified
Ë†ğ¸Pairs Flags Pairs Flags Pairs Flags Precision
0.01 16 31 7 14 0 0 1.00
0.05 98 167 28 50 0 0 1.00
0.10 149 231 41 72 1 2 0.98
0.15 214 296 50 87 2 4 0.96
0.20 305 372 53 92 3 6 0.95
0.25 593 612 56 96 6 12 0.90
0.30 941 901 56 96 9 18 0.86
0.35 2358 1791 57 98 12 24 0.83
0.40 7130 3012 58 99 12 24 0.83
0.4510247 3430 58 99 13 26 0.82
0.50326418 5724 59 99 30 57 0.66
positiveÃthus it is possible that the number of true positives is
actually higher thanwhat we report.
Figure4showstheprecision(true positivesdividedbysample)
plotted against Ë†ğ¸, for different choices of Ë†ğ‘. We are able to achieve
100%precisionwith Ë†ğ¸=0.05(regardlessof Ë†ğ‘),and90%precision
withË†ğ¸=0.25andË†ğ‘=100.Theexactnumbersofmanuallyverified
(truepositive)andfalsified(falsepositive)pairsaregivenintable 1,
which alsoshows how many pairsof feature flags we are ableto
discover at differentlevels of Ë†ğ¸.
Choosing Ë†ğ¸=0.50andË†ğ‘=100,i.e.,classifyingratherunlikely
pairstoberelated,westillachieveaprecisionof66%Ãsignificantly
betterthanchance.Thismakessense,becausetheco-occurrence
discoverystepalreadyreducesthesetofpossiblerelationshipsin
a major way, filtering out those pairs of feature flags which are
definitely not related. Adding probabilistic causal reasoning on
top, i.e., only counting pairs with a ğ¸â‰¤0.50, naturally increases
precision further.
1424DiscoveringFeature FlagInterdependenciesin MicrosoftOffice ESEC/FSE â€™22, November14Å›18, 2022,Singapore, Singapore
AugLoopRuntime.cpp
boolFSimilarityEnabled() {
static const FeatureFlag EduEnabled {...};
static const FeatureFlag ConEnabled {...};
static const FeatureFlat EntEnabled {...};
return (EduEnabled ||ConEnabled ||EntEnabled );
}
(a)Triangular relationshipEduEnabled
ConEnabled
EntEnabled
EntityManager.cpp
voidEntityManager::Init() {
if(FeatureFlags::Instance(m_pWorkbook). AutoRefresh ()) {
RefreshManager::CreateSharedInstance(m_pWorkbook);
}
}
RefreshManagerImpl.cpp
voidRefreshManagerImpl::CreateSharedInstance(Workbook* p Workbook) {
try{
refreshManager = GetApi<RefreshManager>(NEWSHAREDOBJ(
RefreshManagerImpl, pWorkbook));
} CATCH_HANDLER
}
RefreshManagerImpl::RefreshManagerImpl(Workbook* pWo rkBook) :
m_pWorkbook(pWorkbook),
m_fRefreshBar(FeatureFlags::Instance(pWorkbook). ShowRefreshBar ()),
...
(b) Indirectrelationship across multiple filesAutoRefresh
ShowRefreshBar
Word.xml
<FSDropGallery Id="flyoutInsertPics" FeatureFlag=" PictureRibbon ">
<Commands>
<FSMenuCategory Class="StandardItems">
<Items>
<FSExecuteAction Id="insertPicFromFile" />
<FSExecuteAction Id="insertOnlinePic" FeatureFlag=" OnlinePics " />
<FSExecuteAction Id="clipArtDialog" />
</Items>
</FSMenuCategory>
</Commands>
</FSDropGallery>
(c) Relationship inresourcefilePictureRibbon
OnlinePics
Figure 5: Real causal relationships between feature flags found in the Microsoft Office codebase. The source code has been
simplified forpresentational purposes.
1425ESEC/FSE â€™22, November14Å›18, 2022,Singapore, Singapore MichaelSchrÃ¶der,Katja Kevic, Dan Gopstein, BrendanMurphy,andJennifer Beckmann
4.2 Recall
Since our goal is to find relationships between feature flags that
are as-of-yet unknown, we do not have a prioriground truth. This
makes it difficult to establish recallÃhow many of the relation-
ships between feature flags that are hidden in the codebase can
our method uncover? We are unable to answer this question di-
rectly. However, we can make inferences based on the quality of
our results;inparticular,the types ofrelationships we are seeing.
Figure5aisanexampleofanÅ‚obviousÅ¾relationship:threefea-
tureflagsarequeriedtogetheraspartofabooleanpredicate,giv-
ing rise to a triangular interdependency; only if the EduEnabled
flagisfalsewillthe ConEnabled flagbequeried,andonlyifboth
EduEnabled andConEnabled arefalsewill EntEnabled bequeried.
This relationship is manifested entirely in a single line of source
code,producingastrongsignalinthequerylogsthatoursystem
can easily detect.
Figure5bshows a much more indirect relationship, spanning
multiple source files. Here, the parent ( AutoRefresh ) and child
(ShowRefreshBar ) flags are queried indifferent program modules
and are separated in the control flow by a number of function calls
involvingmacroexpansions,classconstructors,andC++templates.
Apurelystaticapproachmighthavesomedifficultieswiththis,but
ourlog-basedanalysisnaturallycapturesthedynamiccontrolflow;
the surroundingsyntactic complexityisentirelyirrelevant.
Figure5cdemonstrates that our approach is also completely
language-agnostic. In additionto flag usage inC++, C#,andother
programminglanguages,weareabletofinddependenciesbetween
featureflagsusedsolelyinnon-coderesourcefiles,asinthepresent
caseofthe PictureRibbonâ†’OnlinePics pairfoundinanXML
configurationfile usedto constructan applicationUI.
Given the diversity of relationship types we are able to find (see
also section 5), including very indirect relationships, we believe
that our results are indicative ofnon-trivialrecall.
RQ2.Whatistheaccuracyofourmethodinareal-world
setting?To determine the precisionof our approach, we man-
ually evaluated a subset of discovered relationships in a large-
scalereal-worldcodebaseandfoundthatweareabletoachieve
90%precisionforlikelypairs( ğ¸â‰¤0.25),withanabsolutemin-
imumprecisionof66%.Whileweareunabletopreciselyquan-
tifyrecallduetoalackofgroundtruth,weseeevidenceofnon-
trivialrecallintheindirectnatureofsomeofthediscovered
relationships,whichcanspanmultiplefilesandprogramming
languages.
5 INTERDEPENDENCY PATTERNS
Sofar, wehavediscussed featureflagrelationshipsmostlyaspair-
wise parent-child relationships between two flags. As figure 5a
demonstrates,morecomplexpatternscanemergeoncetransitive
dependencies are taken into account. Each of the two flags in a
parent-child relationship can themselves be in further parent-child
relationships with other flags (which is reflected in the values of ğ›¼
andğ›½in section 3.4). To investigate the extent of such transitive
interdependenciesandwhetherornottheygiverisetore-occurring
patterns,wecanstudythe globalcausalgraph offeatureflags,as
Figure 6: Causal graph of all feature flags (90% precision),
showing 146 feature clusters: 79 simple pairs , 35outward
stars,5inward stars ,4chains,4triangles ,19other kinds.
seen in figure 6. Here, we plotted the 612 feature flags from our
evaluation (section 4) that were considered to be likely causally re-
lated(ğ¸â‰¤0.25).Nodescorrespondtofeatureflagsandthedirected
edgesrepresentparent-childrelationships.Theweaklyconnected
componentsofthisgraphare featureclusters ,i.e.,subsetsoffeature
flagsthatareonly(indirectly)connectedtoeachotherbutnotto
flags from any other subset. The layout was achieved using the
Fruchterman-Reingoldalgorithm[ 6],whichnaturallybringsout
independentclusters.Thelocationanddistanceofnodesholdno
further meaning.
Based on visual inspection of this graph, we identified five basic
patternsof feature flaginterdependencies.The identifiedpatterns,
the rules used to determine if a feature flag cluster belongs to a
specificpattern,aswellasexamplesofcodestructuresthatcould
give riseto eachpattern, are given intable 2.
The most common pattern is the simple pair of parent-child
flags, occurring 79 times in our sample and involving 158 flags
(25.8%ofallflagsinthesample).Thesecondmostcommonisthe
outward star pattern, involving 122 flags (19.9%), where one parent
flag is at the center of numerous parent-child relationships, but the
childrenarethemselvesnotinterconnected.Thissituationarises
when a single flag guards a large section of code containing many
independent flags, or when a (often non-boolean) feature flag acts
asaconfigurationparameterthatisrepeatedlyusedinscenarios
involving other flags. Less common, involving only 15 flags (2.5%),
istheinwardstar ,whereachildflaghasmultipleparentflags,which
canoccurwhenthechildflagisreusedindifferentcodecontexts.
Triangleandchainpatterns each only occur 4 times in our sample,
1426DiscoveringFeature FlagInterdependenciesin MicrosoftOffice ESEC/FSE â€™22, November14Å›18, 2022,Singapore, Singapore
Table 2:Identified patternsoffeature flag interdependencies
Pattern Description Code Example Occurrence InvolvedFlags
Chain
â€¢â†’â€¢â†’Â·Â·Â·â†’â€¢At least three nodes that are in consecutive parent-child
relationships.if (A) {B}
...
if (B) {C}4(2.7%) 12 (2%)
Triangle
â€¢ â€¢ â€¢Atleastthreenodesinachain,withthefirstnodealsobeing
the parentofthe last node.(A && B && C) 4(2.7%) 12 (2%)
InwardStar
â€¢â†’â€¢â†â€¢One node is the child of at least two parents, which are not
themselves connected.if (A) {C}
if (B) {C}5(3.4%) 15 (2.5%)
OutwardStar
â€¢â†â€¢â†’â€¢â†’â€¢One node istheparentofat leasttwochildren, which are
not themselves connected.f(A,B);
g(A,C);35 (24%) 122(19.9%)
Simple Pair
â€¢â†’â€¢Twonodes that are inaparent-child relationship. if (A) {B} 79 (54.1%) 158(25.8%)
Other Unclassifiable; often basic patterns with slight deviations,
orsuperclustersofmultiple patterns.19 (13%) 293(47.9%)
andarecloselyrelated:triangleformationsareusuallyduetoshort-
circuiting boolean predicates or closely nested if statements, while
chains arise either when consecutive parent-child relationships are
notnestedbutpurelysequential,orwhentherelationshipsarevery
indirect,withenoughdistancebetweenparentandgrandchildto
not be recognizedas atriangle.
Inadditiontothesebasicpatterns,anumberofclustersremained
unclassifiable (19out of146,involving293 flagsintotal).Of these,
many are essentially one of the basic patterns with slight devia-
tions preventing easy classification. For example, one large cluster
involving102flags(theÅ‚starburstÅ¾inthelowercenteroffigure 6)
isalmostapureoutwardstarpattern,saveforafewinterconnected
children. Other unclassifiable patterns arise when two or more
basicpatternsareconnectedbya bridgenode ,formingasingular
supercluster. Bridge nodescould indicate two otherwiseunrelated
application components that are linked by a common feature flag,
increasing software coupling and perhaps introducing a hidden
interdependency. Inability to assign one of the basic classifications
may well be an indicator of unusual complexity and therefore risk.
RQ3.Dore-occurringpatternsoffeatureflagrelation-
shipsexist? Wefoundfivere-occurringpatternsoffeature
flag interdependency relationships: simple pairs, outward
stars,inwardstars,triangles,andchains.Othertypesoffea-
tureflagclustersareoftendeviationsfromthesebasicpatterns.
Wecanuseinterdependencypatternstoidentifyunusualor
risky code structures.
6 THREATS TO VALIDITY
While our work is based on real world data of a large-scale and
mature software system, there are threats to the generalizability of
ofour approach.Idealized Assumptions. If the relationships between feature flags
areactuallysignificantlydifferentthantheplatonicideal if(A){B} ,
or the average number of children and parents per feature flag
(reflectedinthevaluesof ğ›¼andğ›½)muchhigherthanweassume,
then our probabilistic method might have a hard time inferring
relationships. However, we based our assumptions on our direct
experience with actual code containing feature flags and empirical
evaluation confirmsthe effectiveness of our approach.
Lack of Ground Truth. We have mentioned the difficulty of es-
tablishing recall, as we lack ground truth. It is possible that our
approach, while able to find some relationships, is still missing a
significant number. But based on our findings, which doinclude
non-trivial indirect relationships, we are confident of achieving
reasonablerecall. Theparameters( Î”,Ë†ğ¸,Ë†ğ‘), which influencerecall,
need to be chosen empirically andwe believe we made reasonable
choices for the purposes of this paper; we have limited evidence
that byincreasing Î”we can further improve recall(see section 7).
Cold Start Problem. Our approach is fundamentally data-driven:
inordertomakeinferencesaboutpossiblerelationshipsbetween
featureflags,thedataneedstocontainevidenceoftheserelation-
ships,intheformofsequentialfeaturequeries;togeneratethese
feature queries, the applications need to run with certain combina-
tionsoffeatureflagsenabled;withoutknowingtherelationships
between feature flags beforehand, we would need to test all pos-
sible combinations of flags, with all possible values, in order to
generatethedatanecessarytomakecompleteinferencesÃthisis
computationallyinfeasible.Inreality,forourapplications,wedo
not actually need to have perfect recall. Being able to infer a sig-
nificant amount of interesting relationships is enough to make the
systemuseful.Furthermore,preliminaryinferenceresultscanbe
usedtoselectivelygeneratemissingdata,enablingmoreinferences
andimprovingrecall(see section 7).
1427ESEC/FSE â€™22, November14Å›18, 2022,Singapore, Singapore MichaelSchrÃ¶der,Katja Kevic, Dan Gopstein, BrendanMurphy,andJennifer Beckmann
CodebaseBias. Iftheinferencemechanismistoocloselytailored
to the particularities of a single codebase (i.e., that of Microsoft
Office) and the uses of feature flags therein, then it might not be
transferable to other applications. However, we believe that the
foundations of our approach are entirely application-agnostic and
that it is sufficiently general to be applicable to other codebases.
Moreover, Microsoft Office itself consists of a heterogeneous set
of applications, with massive differences between their individual
core components.
7 FUTUREWORK
In the future, we aim to improve both precision and recall by com-
pleting our dataset and investigating larger time windows; and
wewanttofurtherexplorepatternsofinterdependenciesamong
feature flag clusters.
Completing the Dataset. The probabilistic causal discovery ap-
proach works best with complete data, i.e., a dataset in which both
booleanfeatureflagvaluesarepresent.Asthedatasetinpracticeis
oftentimes incomplete, i.e., only one feature flag value is present
as opposed to both, we plan to systematically run an automated
test suite [ 7] on Microsoft Office applications with different sets of
feature flag values. The output that is logged by the simulator in
our test suite is exactly the same as when real users would use a
MicrosoftOffice application.
Investigating Larger Time Windows. We plan to evaluate our
approach using larger co-occurrence time windows ( Î”), which
couldallowustocapturefeatureflagpairsthatarebeingqueried
further apart. We hypothesize that more nested feature flags might
be discovered in features that take longer to fully execute due to
userinteractions, e.g.,copyingandpasting.
Exploring More Interdependency Patterns. Feature flag pattern
recognition could be improved by tolerating slight deviations from
existingpatternsandbyrecognizingmorecomplexcombinations,
identifying bridge nodes and superclusters. We also want to better
understand what code structures give rise to which interdepen-
dencypatterns, andhowsuch patterns are linkedto faults.
8 APPLICATIONS
Weperformedthisresearchinresponsetoseveralpracticalprob-
lemsweregularlyfaceinourorganization.Oneofthemostvaluable
outcomesofthisworkisthediversityoftangiblebenefitswecan
receivebyapplyingourfindings.Theseissuesspantheentirelife-
cycle of our product, from automated testing to client-side error
mitigation.Further,thechallengeswehopetoaddresshaveimpacts
that range from increased organizational efficiency to simplified
developmentpractices.
TargetedTesting .Testingallpossiblecombinationsoffeature
flag valuesbecomessubstantiallyharder asmore featureflags are
used.Thecombinatorialexplosionthatoccurswhenusingmany
featureflagsmakesitimpossibletotestallcombinations.Fowler [5]
recommends to test the feature flags that are known to be enabled
in the next release. However, large projects can contain thousands
of feature flags where every flag can be toggled. Therefore, it is
importanttoenabletoolingthathelpstosystematicallytestonlytherelevantcombinations.Ourresearchonfeatureflagco-occurrences
can be applied to substantially decrease the number of feature flag
valuecombinationstotest,asonlytheco-occurringfeatureflagsâ€™
combinationsneedtobetargetedforcombinatorialtesting.Flags
thatarenotco-occurringcanbetestedindependentlyofeachother.
Conversely,flagswhicharediscoveredtobeinvolvedincomplex
relationships can be highlightedfor additionalscrutiny.
Deployment Velocity .We plan to use the knowledge of feature
flag dependenciestodetermine thevelocity withwhicha flagcan
be rolled out. Feature flags, by their design, indicate the usage
ofuniquemodulesofcode.Interdependentfeaturesthenindicate
interdependent modules, which is the main factor in coupled code.
It is well studied that software coupling is correlated with negative
quality indicators, such as vulnerabilities [ 4]. Consequently, we
extrapolate that interdependent flags are more at risk of admitting
vulnerabilities. We can use this information to roll out changes
slower to ensure that theyâ€™re thoroughly understood and tested
before being fully deployed.
Diagnostics .Failures rooted in feature flags can be tedious and
time-consuming to diagnose. Troubleshooting failures when multi-
ple feature flags are involved can incur substantial costs [ 1]. Show-
ing explicitly which feature flags are interdependent has the po-
tentialtodecreasethetimetomitigatetheproblem,anditmight
uncover previously unknownrelationships as the cause of failure.
Error Mitigation .Many features are developed behind feature
flags, such that the flag can be toggled in case of a failure [ 14]. The
typical response to discovering an error behind a feature flag is to
mitigate the error by immediately disabling the flag. In the case
of interdependent flags, however, this can have unintended side
effects.Itcoulddisablemorefeaturesthanintended,orleavethe
systemconfigurationinanunexpected anduntested state. Ourre-
searchcanenabledeveloperstocheckifthereareanydependencies
before togglinga featureflag, whichcan helpto preventa further
regression.
9 CONCLUSION
In this paper, we described an approach for automatically discover-
inginterdependenciesbetweenfeatureflagsinordertoaidproduct
teams inimproving theirsystemâ€™sreliability.Unknown dependen-
ciesbetweenfeatureflagscanbeasourceofseriousbugsbuttesting
allpossibleflagcombinationsisinfeasibleforlargeprojects.Our
approachisbasedsolelyonanalyzingfeatureflagquerylogsandis
especially suited for large heterogeneous codebases. We developed
amethodofprobabilisticcausalreasoningthatislanguage-agnostic
androbustagainstnoise.WeappliedourapproachontheMicrosoft
Office codebase and achieved high precision and non-trivial recall.
In analysing the results, we found patterns of feature flag relation-
ships that can be indicators for the amount of risk associated with
certain flags.Ourworkcan beapplied inreducingthetest burden
forcombinatorialtesting,indeterminingdeploymentvelocityfor
safe rollouts, in diagnostics of faults involving feature flags, and in
errormitigationbypreventingregressions.Inthefuture,wewill
useautomatedtestingtoincreaseandimprovethedataavailable
foranalysisandweplantoexperimentwithdifferenttimewindows
to discover awider range of possible relationships.
1428DiscoveringFeature FlagInterdependenciesin MicrosoftOffice ESEC/FSE â€™22, November14Å›18, 2022,Singapore, Singapore
REFERENCES
[1]Mona Attariyan and Jason Flinn. 2010. Automating Configuration Troubleshoot-
ingwith Dynamic Information FlowAnalysis. In OSDI, Vol. 10.1Å›14.
[2]MuffyCalder,MarioKolberg,EvanH.Magill,andStephanReiff-Marganiec.2003.
Featureinteraction:acriticalreviewandconsideredforecast. ComputerNetworks
41,1 (2003), 115Å›141. https://doi.org/10.1016/S1389-1286(02)00352-3
[3]QingrongChen,TengWang,OwolabiLegunsen,ShanshanLi,andTianyinXu.
2020. Understanding and Discovering Software Configuration Dependencies in
Cloud and DatacenterSystems. In Proceedings of the 28th ACM Joint Meeting on
European Software Engineering Conference and Symposium on the Foundations
of Software Engineering (Virtual Event, USA) (ESEC/FSE 2020) . Association for
ComputingMachinery,NewYork,NY,USA,362Å›374. https://doi.org/10.1145/
3368089.3409727
[4]Istehad Chowdhury and Mohammad Zulkernine. 2010. Can Complexity, Cou-
pling,andCohesionMetricsBeUsedasEarlyIndicatorsofVulnerabilities?.In
Proceedingsofthe2010ACMSymposiumonAppliedComputing (Sierre,Switzer-
land)(SAC â€™10) . Association for Computing Machinery, New York, NY, USA,
1963Å›1969. https://doi.org/10.1145/1774088.1774504
[5]Martin Fowler. 2010. FeatureToggle .https://martinfowler.com/bliki/
FeatureToggle.html
[6]Thomas M. J. Fruchterman and Edward M. Reingold. 1991. Graph Drawing
byForce-DirectedPlacement. Softw.Pract.Exper. 21,11(nov1991),1129Å›1164.
https://doi.org/10.1002/spe.4380211102
[7]Luke Harries, Rebekah Storan Clarke, Timothy Chapman, Swamy V. P. L. N.
Nallamalli, Levent Ã–zgÃ¼r, Shuktika Jain, Alex Leung, Steve Lim, Aaron Dietrich,
JosÃ©MiguelHernÃ¡ndez-Lobato,TomEllis,ChengZhang,andKamilCiosek.2020.
DRIFT: Deep Reinforcement Learning for Functional Software Testing. CoRR
abs/2007.08220 (2020). arXiv: 2007.08220 https://arxiv.org/abs/2007.08220
[8]PeteHodgson.2017. FeatureToggles(akaFeatureFlags) .https://martinfowler.
com/articles/feature-toggles.html
[9]M.JacksonandP.Zave.1998. Distributedfeaturecomposition:avirtualarchitec-
ture for telecommunications services. IEEE Transactions on Software Engineering
24,10(1998), 831Å›847. https://doi.org/10.1109/32.729683[10]FlÃ¡vio Medeiros, MÃ¡rcio Ribeiro, Rohit Gheyi, Larissa Braz, Christian KÃ¤stner,
SvenApel,andKleberSantos.2020.AnEmpiricalStudyonConfiguration-Related
Code Weaknesses. In Proceedings of the 34th Brazilian Symposium on Software
Engineering (Natal, Brazil) (SBES â€™20) . Association for Computing Machinery,
NewYork, NY, USA,193Å›202. https://doi.org/10.1145/3422392.3422409
[11]Jens Meinicke, Juan Hoyos, Bogdan Vasilescu, and Christian KÃ¤stner. 2020. Cap-
turetheFeatureFlag: Detecting FeatureFlagsin Open-Source. In Proceedings of
the17thInternationalConferenceonMiningSoftwareRepositories (Seoul,Republic
of Korea) (MSR â€™20) . Association for Computing Machinery, New York, NY, USA,
169Å›173. https://doi.org/10.1145/3379597.3387463
[12]JensMeinicke,Chu-PanWong,BogdanVasilescu,andChristianKÃ¤stner.2020.
Exploring Differences and Commonalities between Feature Flags and Configura-
tionOptions.In ProceedingsoftheACM/IEEE42ndInternationalConferenceon
SoftwareEngineering:SoftwareEngineeringinPractice (Seoul,SouthKorea) (ICSE-
SEIPâ€™20).AssociationforComputingMachinery,NewYork,NY,USA,233Å›242.
https://doi.org/10.1145/3377813.3381366
[13]Steve Neely and Steve Stolt. 2013. Continuous Delivery? Easy! Just Change
Everything (Well, Maybe It Is Not That Easy). 2013 Agile Conference (2013),
121Å›128. https://doi.org/10.1109/AGILE.2013.17
[14]MdTajmilurRahman,Louis-PhilippeQuerel,PeterC.Rigby,andBramAdams.
2016. Feature Toggles: Practitioner Practices and a Case Study. In Proceedings of
the 13th International Conference on Mining Software Repositories (Austin, Texas)
(MSR â€™16) . AssociationforComputingMachinery, NewYork,NY, USA,201Å›211.
https://doi.org/10.1145/2901739.2901745
[15]Doug Seven. 2014. Knightmare: A DevOps Cautionary Tale. https://dougseven.
com/2014/04/17/knightmare-a-devops-cautionary-tale/
[16]Chunqiang Tang, Thawan Kooburat, Pradeep Venkatachalam, Akshay Chander,
ZheWen,AravindNarayanan,PatrickDowell,andRobertKarl.2015. Holistic
ConfigurationManagementatFacebook.In Proceedingsofthe25thSymposium
onOperatingSystemsPrinciples (Monterey,California) (SOSPâ€™15) .Associationfor
ComputingMachinery,NewYork,NY,USA,328Å›343. https://doi.org/10.1145/
2815400.2815401
[17]JialuZhang,RuzicaPiskac,EnnanZhai,andTianyinXu.2021. Staticdetectionof
silent misconfigurations with deep interaction analysis. PACM on Programming
Languages 5,OOPSLA (2021), 1Å›30. https://doi.org/10.1145/3485517
1429