Change Is the Only Constant: Dynamic Updates for Workflows
Daniel Sokolowski
daniel.sokolowski@unisg.ch
University of St. Gallen
SwitzerlandPascal Weisenburger
pascal.weisenburger@unisg.ch
University of St. Gallen
SwitzerlandGuido Salvaneschi
guido.salvaneschi@unisg.ch
University of St. Gallen
Switzerland
ABSTRACT
Softwaresystemsmustbeupdatedregularlytoaddresschanging
requirementsandurgentissueslikesecurity-relatedbugs.Tradition-
ally,updatesareperformedbyshuttingdownthesystemtoreplace
certain components. In modern software organizations, updatesare increasingly frequentâ€”up to multiple times per dayâ€”hence,shutting down the entire system is unacceptable. Safedynamic
softwareupdating(DSU)enablescomponentupdateswhilethesys-
tem is running by determining whenthe update can occur without
causingerrors.SafeDSUiscrucial,especiallyforlong-runningor
frequently executed asynchronous transactions ( workflows ), e.g.,
user-interactive sessions or order fulfillment processes. Unfortu-nately, previous research is limited to synchronous transaction
models and does not address this case.
In this work, we propose a unified model for safe DSU in work-
flows.Wediscusshowstate-of-the-artDSUsolutionsfitintothis
model andshow that theyincur significant overhead.Toimprove
theperformance,weintroduce EssentialSafety,anovelsafeDSU
approach that leverages the notion of non-essential changes, i.e.,
semantics preserving updates. In 106 realistic BPMN workflows,Essential Safety reduces the delay of workflow completions, on
average,by47 .8%comparedtothestateoftheart.Weshowthat
thedistinctionofessentialandnon-essentialchangesplaysacru-
cial role in this reduction and that, as suggested in the literature,non-essential changes are frequent: at least 60% and often more
than 90% of systemsâ€™ updates in eight monorepos we analyze.
CCS CONCEPTS
â€¢Software and its engineering â†’Software evolution;â€¢Ap-
plied computing â†’Business process modeling.
KEYWORDS
Software Evolution, Dynamic Software Updating, Workflows
ACM Reference Format:
Daniel Sokolowski, Pascal Weisenburger, and Guido Salvaneschi. 2022.
Change Is the Only Constant: Dynamic Updates for Workflows. In 44th
International Conference on Software Engineering (ICSE â€™22), May 21â€“29,2022, Pittsburgh, PA, USA. ACM, New York, NY, USA, 13pages.https:
//doi.org/10.1145/3510003.3510065
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
onthe firstpage.Copyrights forcomponentsof thisworkowned byothersthan the
author(s)mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,or
republish,topostonserversortoredistributetolists,requirespriorspecificpermission
and/or a fee. Request permissions from permissions@acm.org.
ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
Â© 2022 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ACM ISBN 978-1-4503-9221-1/22/05...$15.00
https://doi.org/10.1145/3510003.35100651 INTRODUCTION
Updating long-running software systems is essential to address
changing requirements and mitigate security vulnerabilities in a
timelymanner.Updatesbecomemorefrequentinmodernsoftware
development following agile methods and DevOps principles [ 19],
requiring automation of updates and low impact on the running
system to prevent frequent interruptions.
Traditionally, software updates are performed by shutting down
software systems and restarting them after replacing some com-ponents with new versions. While this approach is simple, it isdisruptive and infeasible for larger systems, where a full restart
maytakealongtime.Asaresult,researchershaveinvestigatedless
disruptive dynamic software updating (DSU) [52], i.e., updates that
occurwhilethesystemisrunning.Thereby,acomponentupdate
in the middle of a transaction must not result in inconsistencies.
For example, if a client requires a security token to access a server
and the server is updated to a new token scheme in a naÃ¯ve way,
verifying a previously generated token could fail [ 8]. Safe DSU
determines whenanupdatecanbeperformedwithoutincurringse-
mantic inconsistenciesâ€”the so-called update condition. It leverages
various information, such as the system topology and the progress
of transactions.
Acommonsolutiontoimplementlong-running,frequent,and
expensivetransactionsare workflows,sometimesreferredtoas long-
running transactions [27,40]. Workflows are extremely common
in modern software applications to express a sequence of tasksand the data flow between them, decoupling process flows from
applicationlogicandenablingautomation.Workflowshavebeen
used for a long time and recently gained popularity to orchestrate
weakly coupled components. For instance, workflow engines have
been adopted at modern software companies (e.g., Conductor at
Netflix[42])andaresupportedbymajorcloudproviders(e.g.,AWS
StepFunction [4] and Google Cloud Workflows [26]).
Safe DSUis crucial forworkflows:Ignoring update safetyand
retryingthetransactionsthatwerebrokenbyanupdatemaybeac-ceptableforapplicationswithinexpensive,short-livedtransactions,
but the cost of repeating broken transactions increases with the
transactionsâ€™amount,duration,andresourceconsumption.Thus,es-peciallyforlong-runningorfrequentlyexecutedworkflows,delays
or retries after failure on component updates potentially require
large amounts of additional resources and introduce severe delays.
ThisissueisevenmorerelevantinCI/CDpipelines,wherechanges
are small and frequently deployed [15].
Unfortunately,existingsafeDSUsolutionshavenotbeenstudied
inthecontextofreal-worldworkflows.Crucially,previousresearch
only considers synchronous transactions and cannot be directly
transferredtoworkflows,whichareasynchronous.Toclosethisgap,
we investigate a new formal model for safe DSU suitable for work-
flows. We show how our new model can capture state-of-the-art
3502022 IEEE/ACM 44th International Conference on Software Engineering (ICSE)
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 07:52:58 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Daniel Sokolowski, Pascal Weisenburger, and Guido Salvaneschi
DSU approaches and analytically compare them within the model,
setting the conceptual ground for the performance differences that
we later inspect empirically.
Another challenge in using safe DSU for workflows is that exist-
ing approaches introduce significant performance overhead. They
either do not reach their update condition in a timely manner
(Version Consistency (VC)[8,38]) or make strong assumptions
sacrificing safety if the assumptions are not satisfied (Tranquil-
ity(TQ)[60]). To reduce the performance overhead compared to
thestateoftheart andretainsafety,weproposethesafeDSUap-
proachEssential Safety. Its updatecondition Essential Freeness is
based on the observation that a significant amount of updates are
non-essential changes, i.e., they never interfere with running trans-
actionsbecausetheydonotintroducesemanticchanges.Thanksto
identifying non-essential changes, Essential Safety reduces delays
andinterruptionsduetoupdatesinworkflow-basedapplications
and retains strong guarantees on correct system operation.
ThisworkpavesthewaytoapplysafeDSUtomodernworkflow
architectures, e.g., in cloud applications [ 4,26]. In addition, the
identification of non-essential changesâ€”updates without semantic
changesâ€”canberefinedusinginsightsfromtheapplicationandthe
developers.Thisinsightopensanopportunityforfutureresearch
to provide more precise characterizations of non-essential changes,
reducingthenumberofexpensiveupdatesandfurtherimproving
DSU performance.
Allourevaluationdataandthesoftwaredevelopedforthispa-
perarepubliclyavailable[ 56].Insummary,thispapermakesthe
following contributions:
(1)We propose a new formal model for DSU supporting asyn-
chronousworkflows.Weshowthatstate-of-the-artDSUap-
proaches,aswellasourapproach,fitintosuchamodel,en-
abling a direct comparison.
(2)We propose Essential Safety as a novel approach for safe
DSU,whichleveragesthe identificationofwhetheranupdate
introduces a semantic change, i.e., is essential.
(3)We analytically compare Essential Safety to previous DSU
approaches, show that Version Consistency is a conserva-
tiveover-approximationof Tranquility andEssentialSafety,
and highlight the different information taken into account,
explaining the performance difference among such solutions.
(4)We empirically confirm by simulating 106 realistic collabora-
tive BPMN workflows and analyzing eight monorepos thatEssential Safety provides the best performance among safe
DSU approaches, that identifying non-essential changes iseffective to improve safe DSUâ€™s performance, and that, in
practice,atleast60%andoftenmorethan90%oftheupdates
are non-essential changes.
Thepaperisorganizedasfollows.Section 2outlinestheissue
of safe DSU for workflows. Section 3presents related work. Sec-
tion4describes our model for safe DSU in workflows and intro-
ducesourapproach EssentialSafety.Section 5presentsEssential
Safetyâ€™spracticalrealization.Section 6analyticallycompares Es-
sentialSafety withpreviousDSUsolutions.Section 7empirically
evaluates our contribution, and Section 8concludes.%RRNKRWHO %RRNÃLJKW %RRNFDU
&DQFHOKRWHO &DQFHOFDU &DQFHOÃLJKW6XFFHVV" 6XFFHVV" 6XFFHVV"
\HV
QR QR QR7ULS
UHTXHVWHG7ULS
ERRNHG
\HV \HV
7ULS
ERRNLQJ
IDLOHG
Figure 1: BPMN workflow of the trip booking saga.
2 THE DYNAMIC UPDATE PROBLEM
Inthissection,weintroduceaworkflowasarunningexampleto
explaintheproblemofsafeDSU.Workflowsareusedextensively
in software systems to express the execution of interrelated tasks.
2.1 The Trip Booking Saga
The running example is the trip booking case study [ 48], shown
as BPMN workflow [ 45] in Figure 1. A hotel, a car, and a flight
are booked sequentially. Each of these steps may fail, triggering
compensatingactionsforthebookingsperformeduptothecurrent
execution pointâ€”a design pattern referred to as â€œsagaâ€ [22].
Eachtaskintheworkflowisimplementedasaserverlessfunc-
tion. Some of the functions are coupled through a shared database
on which they operate, constituting components. In our exam-
ple,the carbooking andcancelfunctions constitutethe carrental
component, and the remaining four functions are the holidaycom-
ponent. These components are the smallest unit of updates, e.g.,
whenthecarrentalcomponentisupdated,theserverlessfunctions
for both â€œbook carâ€ and â€œcancel carâ€ are replaced by a new version.
Figure2showsthetripbookingcasestudyasaUMLsequence
diagram. We added the labels AtoEand btodto reference points
in time during the execution. If there is no error, only AtoEoccur
and not btod, because they are on the paths that only occur on
the failure of a booking task, executing the compensation tasks.
2.2 The Need for Safe Dynamic Updates
Updating a component in a workflow may break the correct execu-
tionintwocases.Thefirstcaseistheupdateofacomponentwhile
it is currently executing a task, i.e., it is active. For example, if a
workflowinstancerunstheâ€œbookhotelâ€task,updatingtheholiday
component can cause incorrect behavior. In line with the literature
on dynamic updates, we consider updating an active component
(i.e.,onethatexecutesatask)alwaysunsafeâ€”thisproblemisstudied
inadifferentresearchline[ 18,58,59]andrequires hot-swapping
code as well as migrating the state representation across versions.
Thesecondcaseiswhenacomponentperformstwotaskswithin
the same transaction and an update introduces a semantic change
inbetween.Forexample,inthetripbookingsaga,afterâ€œbookhotelâ€
completes(after BinFigure 2),ifâ€œbookcarâ€isnotsuccessfuland
the holiday component is updated with a new version that usesa different format for hotel booking IDs, â€œcancel hotelâ€ does notbehave correctly: either it does not find the correct booking to
cancel orâ€”even worseâ€”it finds the wrong one. Thus, the workflow
instancefailstorevokethehotelbooking.Toavoidsucherrors,safe
DSUapproachesspecify updateconditions.Theydetermine when
anupdatecanbeperformedsuchthatitdoesnotcausesemantic
mismatches.
351
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 07:52:58 UTC from IEEE Xplore.  Restrictions apply. Change Is the Only Constant: Dynamic Updates for Workflows ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
+ROLGD\ &DU5HQWDO
FDQFHOFDUFDQFHOÃLJKW>VXFFHVV@
>IDLOXUH@
>IDLOXUH@
>IDLOXUH@$
%
&
'
EFG
(>VXFFHVV@ ERRNFDUERRNKRWHO
FDQFHOKRWHOFDQFHOKRWHO
FDQFHOKRWHOFDQFHOFDU>VXFFHVV@DOW
ERRNÃLJKW
DOWW
DOW
Figure 2: Sequence diagram of the trip booking saga.
2.3 The Role of Non-Essential Changes
Toreachtheupdateconditionforasafeupdateandtoupholdituntil
theupdatecompletes,safeDSUapproachesrequiremonitoringand
may block tasks. For instance, to update the car rental component,
aDSUapproachmightblockall calls tothecarrentalcomponent
until the update completes. Once all running tasks on car rental
terminate, a safe update condition is met and upheld until theupdate is completed. Both reaching and upholding a safe updatecondition lead to significant overhead and delay. The overheadgrows with the amount, duration, and resource consumption of
the transactions, which results in considerable overhead for highly
frequent,expensivetransactionsthatcanbefoundinworkflows.
DSU approaches should block tasks as little and short as possible.
ForexistingDSUapproaches[ 32,38,60],theoverheadishigh
in long-running, frequently executing workflows (cf. Section 7),
prohibitingtheiruseforthesafecontinuousdeploymentofsuch
applications. However, in practice , a substantial fraction of the
changesrunningthroughacontinuousdeploymentpipelinetend
tobesmallanddonotintroducesemanticchanges,i.e., non-essential
changesâ€”a reality ignored by previous work on DSU. Thus, we can
applyalessdisruptiveupdateconditiontomostupdates.Itrequires
less task blocking to be reached and upheld and greatly reduces
unnecessary overhead.
Essential Safety (ES), our novel safe DSU approach for work-
flows,leveragesthedistinctionbetweenessentialandnon-essential
changes. Essential Safety reduces DSU disruption to a minimum
whileprovidingthesamesafetyasthestateoftheart,enablingsafe
DSU in real-world, long-running, frequently executed workflows.
InTable1,wecompare,forexistingDSUapproaches[ 32,38,60]
and forEssential Safety, whenupdating the components in the
trip booking case study (cf. Section 2.1) is safe. Checkmarks corre-
spond to safe update time intervals. The highlighted cells indicate
intervalswherethecomponentisactiveâ€”theseintervalsareunsafe
under all update conditions. If an update is an essential change,
Essential Safety provides the same safe update intervals as Version
Consistency (VC), which is generally safeâ€”in contrast to Tranquil-
ity(TQ).Fornon-essentialchanges,theintervalsindicatedby( /check)
are additional safe intervals and, thus, Essential Safety provides
the highest number of safe update intervals.Table1:Updateconditionsoverthetime ğ‘¡inthetripbooking
saga for Quiescence (Q),Tranquility (TQ),Version Consis-
tency(VC), andEssential Safety (ES).
Holiday Car Rental
ğ‘¡QT QV CE S QT QV CE S
A /check/check/check /check/check/check
B /check/check/check
C /check (/check)
D (/check)
d (/check)
c /check (/check)
b /check/check /check /check
E /check/check /check /check /check/check /check /check
3 RELATED WORK
ClosesttoourworkispreviousresearchonopaqueboxsafeDSU[ 8,
32,38,60], which we compare with in detail in Section 6. In con-
trast, transparent box approaches [ 29,57] leverage formal models
of the programs to identify points in time when it is safe to update.
Whiletransparentboxmethodsallowmorefine-grainedanalyses,
theyrelyonstrongassumptionsontheimplementationtechnology,
making them hard to apply to general distributed systems, sup-
porting components implemented using heterogeneous paradigms,
languages, and technologies. The survey of Seifzadeh et al .[52]
discussesseveralplatformswithDSU.Wenowdiscussrelatedre-
search on (1) updating software in running processes, (2) software
reconfiguration,(3)workflowevolution,and(4)continuousdelivery.
Finally, we provide an insight into (5) DSU in practice.
DynamicCodeReplacement. Inthiswork,wefocusonsafedy-
namicupdatesofcomponentsthatare notcurrentlyexecutingcode.
Complementary to our work, there are approaches for updating
runningcomponents.Updatingthecodeofarunningprogramwas
investigated already in the 1970s [ 18]. Later, Erlang [ 6] has been
oneofthefirstprogramminglanguagestoenable hotswapping,i.e.,
modules can be replaced at run time (the new version is loaded
when the next invocation occurs), and programmers can specify
state transfer between modules. A similar solution for dynamiccode replacement is also available in the Ada programming lan-
guage [59]. Morerecently,dynamic codereplacement on theJava
VirtualMachinehasbeensupportedintheJvolve[ 58]andinthe
DCE VMs [61] as a modification to the Java HotSpot VM.
These approaches focus on the technical realization of code
replacement while the system is running and assume that devel-
opers correctly handle transferring the state of components across
updates. Another line of work focuses on ensuring that state trans-
formations are correct, e.g., using type systems [ 30]. Gu et al .[28]
replay the sequence of invocations performed on the old object on
the new one to ensure that it reaches the same state.
Software Reconfiguration. Dynamic software reconfiguration is
aboutchangingtheconfigurationofasoftwareproductatruntime
whilethesystemisoperational.Researchfocusesonreconfigura-
tion models ensuring the preservation of consistency propertiesand minimizing system disruption [
11]. Adapta [ 49] is a reflec-
tivemiddlewareforself-adaptive,component-basedapplications.It
aimstodecoupletheapplicationlogicfromthecodethathandles
352
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 07:52:58 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Daniel Sokolowski, Pascal Weisenburger, and Guido Salvaneschi
the adaptation, and it requires run-time monitoring and trigger-
ing mechanisms. Software reconfiguration has been applied to
distributed execution, where remote system nodes interpret recon-
figuration scripts [ 10]. Software self-adaptivity is a research line
on switching the behavior of applications at run time, for example,
usingmetaprogrammingorreconfigurationofcomponent-based
systems [39].
UpdatingWorkflows. Researchershaveexaminedhowexisting
workflowscanbemodeledtosupportchangeswhiletheyareex-
ecuted.Casatietal .[13]addresstheproblembydefiningasetof
transformation rules and dividing the state space into parts that
are terminated or handled by different process definitions. Geiger
et al.[23,24]present a detailed review of the current state and
evolution of BPMN 2.0 support and implementation, finding a lack
of standard compliance in current implementations.
UpdatesinContinuousDelivery. Arecentoverviewoftheimpact
ofcontinuousdelivery(CD)byLwakatareetal .[37]investigatesCD
implementations in five different development contexts. Laukka-nen et al
.[34]provide an overview of adoption problems of CD
and show that most research work focuses on issues that devel-opers face, but developers usually consider release and software
updateproblemstobeexternalfactors.UpdatingcomponentsinCDposesaprobleminreal-worldsettingsaccordingtosemi-structured
interviews conducted by Claps et al .[14]at Atlassian. At least
7 out of 10 interviews highlight that seamless upgrades are hard
to implement in large systems and potentially consume signifi-cant amounts of resources. Gallaba et al
.[21]infer dependencies
between components using build execution tracing to accelerate
CI/CDpipelinesâ€”informationthatcouldbeusedtoidentifynon-
essential changes. Infrastructure as code (IaC) has been adopted to
increase automation in modern development pipelines [ 41]. Tra-
ditionally, IaC solutions in CD are executed as one-off tasks and
treatwhentoupdateasexternaldecision.However,therecentin-
troduction of long-running, reactive deployment scripts [ 55] blurs
the line between application and infrastructure code, enabling the
required monitoring and logic for safe DSU.
DSUinPractice. Today,safeDSUreliesoncomplexworkarounds,
avoiding the need for safe update intervals. Cloud vendors and
deploymentplatforms,e.g.,Kubernetes[ 1],providevariationsof
blue-green [ 20] and canary [ 50] deployment strategies. Parallel
change [51] is a pattern for safe interface updates that replaces un-
safe changes with a sequence of safe ones. These solutions provide
safeDSUforsoftwarewherethecomponentsfortheapplicationlogic are stateless and a (transactional) database holds the state.
However, this hypothesis does not always apply, e.g., in the case of
workflowsinvolvingcomponentsthatbelongtovariousauthorities.
In such a case, using a central database is infeasibleâ€”a codified
principleinmicroservicearchitectures[ 43].Inmanyscenarios,e.g.,
Web applications for social networks, it is accepted that updates
maybreakmulti-requesttransactionsâ€”retryischeap,butitham-
pers user experience. In other scenarios, retry is not acceptable
becauseitrequirestoomuchtimeorresources,whereforesafeDSU
is needed to minimize the updatesâ€™ impact.4 EFFICIENT, SAFE DYNAMIC UPDATES OF
WORKFLOW COMPONENTS
In this section, we present a formal model for workflow execution.
We propose Essential Safety as a safe and efficient updating ap-
proach. We then show how Essential Safetyâ€™s update condition
Essential Freeness can be reached and upheld during an update.
4.1 Workflow Execution Model
Variousworkflowmodelinglanguagesexist,includingstandards
like BPMN [ 45] and BPEL [ 44], as well as vendor-specific DSLs
liketheAmazonStatesLanguage[ 3]forAWSStepFunctions[ 4].
Thoughthesemodelinglanguagesdifferinfeaturesandexpressivity,
they all organize consecutively executed tasks in a graph structure.
We formally model their shared core concepts.
Weconsiderthesystemlandscape ğ¿=(R,W,T,C,ğ‘–)consisting
of workflow engines R, workflows W, and tasks T, which are
implementedbycomponents C,relatedby ğ‘–:Tâ†’C.W emodel
a workflow ğ‘Š=(ğ‘‡,ğ‘ƒ,ğµ,ğ¸)âˆˆWwith a directed graph of tasks
ğ‘‡âŠ†Tthatareconnectedtothetaskswhichcanbeexecutednextâ€”
thesucceeding tasksâ€”by arcs ğ‘ƒâŠ†ğ‘‡Ã—ğ‘‡. A workflowâ€™s initial tasks
areğµâŠ†ğ‘‡and the end tasks ğ¸âŠ†ğ‘‡. All non-end tasks must have
at least one succeeding task. Thus, a task ğ‘¡âˆˆğ‘‡is either in ğ¸or
there exists at least one edge (ğ‘¡,ğ‘¡/prime)âˆˆğ‘ƒ. Workflows are executed
as workflow instances ğ¼=(ğ‘Ÿ,ğ‘Š,ğ´,ğ‘‰,ğ¹,ğ‘†)âˆˆI in the workflow
engineğ‘ŸâˆˆRwhereğ´âŠ†ğ‘‡istheactivetasks,initializedas ğ´=ğµ.
The workflow engine updates ğ´during the execution of ğ¼. The
workflow instanceterminates once notask is activeanymore, i.e.,
ğ´=âˆ….ğ‘†istheworkflowinstanceâ€™sstate.Alltasks ğ‘‡ofğ¼canread
fromitatthebeginningoftheirexecutionandwritetoitaftertheirexecution.
ğ‘‰âŠ†ğ‘‡arethevisitedtasks,i.e.,thesetisinitiallyempty,
and all tasks that are removed from ğ´during the execution are
addedtoğ‘‰.ğ¹âŠ†ğ‘‡arethepotentialfuturetasks,i.e.,alltasksthat
are reachable in the directed graph (ğ‘‡,ğ‘ƒ)from a task in ğ´. Note
thatğ¹is a conservative over-approximation of the future tasks, i.e.,
notalltasksin ğ¹havetobeexecuted.Forinstance,considerBPMN
exclusivegateways,asincludedthreetimesinFigure 1,whichhave
multiple outgoing paths, but only exactly one will be executed. All
tasksonapathafteraBPMNexclusivegatewayareinitiallyin ğ¹
andalltasksonthepathsnottakenareremovedfrom ğ¹without
being executed once the gateway is processed.
Basedonthedefinitionofactivetasks ğ´,wedefineacomponent
ğ‘âˆˆCis active if it executes any active task:
Definition 4.1 (Active Component). A component ğ¶âˆˆCis called
activeif it currently executes a task in any workflow instance:
âˆƒğ¼=(ğ‘Ÿ,ğ‘Š,ğ´,ğ‘‰,ğ¹,ğ‘† )âˆˆI,ğ‘¡âˆˆğ´:ğ‘–(ğ‘¡)=ğ¶.
4.2Essential Safety
Wedefineasafeandefficientupdateconditionforlong-running,
frequentlyexecutedworkflows.Aworkflowinstancealwaysexe-
cutescorrectlyifeverycomponentisonlyupdated(1)afterithas
executed its last task, (2) before it executes its first task, or (3) if
itdoes notexecute anytask inthe workflowinstance. Incontrast
to previous work, our approach also allows a component to be
updated if it already executed a task andmay execute a task in the
future if the update does not introduce a semantic change. We call
353
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 07:52:58 UTC from IEEE Xplore.  Restrictions apply. Change Is the Only Constant: Dynamic Updates for Workflows ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
such updates non-essential changes, in contrast to essential changes,
which introduce a semantic modification:
Definition 4.2 (Essential Change). An update of a component
ğ¶âˆˆCfrom version ğ‘£toğ‘£/primeis an essential change for workflow
instanceğ¼=(ğ‘Ÿ,ğ‘Š,ğ´,ğ‘‰,ğ¹,ğ‘† )âˆˆI,ifthepossibleexecutionofany
futuretask ğ‘¡âˆˆğ¹|ğ‘–(ğ‘¡)=ğ¶onğ‘£/primeisnotguaranteedtoproducethe
same resulting state ğ‘†and side effects as executing ğ‘¡onğ‘£.
Everyotherchange(giventhedefinitionabove)isanon-essential
change. Identifying whether a change is non-essential is not decid-
ableingeneralasitboilsdowntotheprogramequivalenceprob-
lem. Since misclassifying essential changes as non-essential breaks
safety,weconservativelyunder-approximatenon-essentialchanges
withacatalogofknownnon-essentialchangesthatcanbefound
throughefficientanalyses.KawrykowandRobillard [31]describe
non-essential changes as (1) cosmetic, (2) behavior-preserving, and
(3) unlikely to provide further insight into component relation-
ships. This includesâ€”but is not limited toâ€”trivial type updates,
local variable extractions, rename-induced modifications, trivial
keywordmodifications,localvariablerenames,andwhitespaceand
documentation-relatedupdates.Definition 4.2leavesopenadding
more sophisticated analyses to find non-essential changes, includ-ing application-specific ones. Identifying non-essential changes isimportant in practice but orthogonal to our contribution.
Updatingacomponentwithnon-essentialchangesisalwayssafe
whilethecomponentisnotactive.Weintroduce EssentialSafety
(ES): only updating components when they are essentially free.
Definition4.3(EssentialFreeness). Acomponent ğ¶âˆˆCisessen-
tially free,i fi t
(1) is not active and(2) a.
willnotbeactiveinaworkflowinstanceinwhichitalready
executed a task ( /nexistsğ¼=(ğ‘Š,ğ´,ğ‘‰,ğ¹,ğ‘† )âˆˆI,ğ‘¡âˆˆğ‘‰,ğ‘¡/primeâˆˆğ¹:
ğ‘–(ğ‘¡)=ğ¶âˆ§ğ‘–(ğ‘¡/prime)=ğ¶)o r
b.its update is a non-essential change for all workflow in-
stancesğ¼=(ğ‘Š,ğ´,ğ‘‰,ğ¹,ğ‘† )âˆˆI,ğ‘¡âˆˆğ‘‰|ğ‘–(ğ‘¡)=ğ¶in which it
already processed a task.
Consideringasingleworkflowinstanceofthetripbookingsaga,
updates with non-essential changes can always be performed with-
out violating the workflowâ€™s correctness if the respective com-ponent is not currently executing a task. For instance, using the
intervals marked in Figure 2, the car rental component can always
be updated except within Cand c. If the update is an essential
change, the update must not occur between a componentâ€™s first
and last task execution in the workflow instance.For example, an
essentialchangeofthecarrentalcomponentmaynotoccurwithin
B,d,and cbecauseitmightbethecasethatâ€œcancelcarâ€isexecuted
inthefutureafterthatâ€œbookcarâ€hasbeenalreadyexecutedonthe
current version of the component.
4.3 Reaching Essential Freeness
StrategiestoreachsafeDSUupdateconditionstrade-offbetween
updatetimeliness andinterruption.Timelinessisthelengthofthe
intervalbetweenrequestingtheupdateandthebeginningofthe
componentexchange,i.e.,thepointintimewhenthecomponent
stops executing tasks. Interruption is how long a workflow in-stanceâ€™s completion is delayed due to the update. The followingreaching strategies from the literature [
32,38,60] can be used to
reachEssential Freeness.
Waiting (W). The update waits for Essential Freeness. The inter-
ruptionislimitedbecauseonlyworkflowinstancesthatstartedaftertheupdatebeginsaredelayedandtheupdateâ€™sdurationboundsthe
interruption. Yet, the update is not guaranteed to start in bounded
time, i.e., timeliness is unpredictable. Thus, this approach is not
suitable where Essential Freeness rarely occurs by chance.
BlockingTasks(BT). Thestartingoftaskson thecomponentto
update is delayed until after the update. This strategy ensures that
Essential Freeness is reached in bounded time, but it may cause
more interruption than Waiting.
BlockingInstances(BI). Thestrategyissimilarto BlockingTasks,
but instead of delaying tasks, the start of new workflow instances
thatneedthecomponentisdelayeduntilaftertheupdate.While
thisstrategyalsoguaranteestheupdateisreached,itmighttake
longer.Theinterruptionisexpectedtobesimilarto BlockingTasks
but is reduced if multiple updates occur in parallel.
ConcurrentVersions(CV). Fornon-essentialchanges,allnewtask
executions are served by the new version running in parallel tothe old version, which completes the already running tasks. For
essentialchanges, theoldversionalso executesnewtasks belong-
ingtoworkflowinstancesthatalreadyexecutedatleastonetask
on it. Thus, the old version remains available until no workflow
instance needs it anymore. This strategy provides good timeliness
andnointerruption,butitrequiresrunningtwoparallelversions
of a component, significantly increasing complexity, especially for
stateful components.
Except for Concurrent Versions, all reaching strategies require
EssentialFreeness toholduntiltheupdateiscompleted.Thiscan
be achieved by applying Blocking Tasks to a component during its
update,delayingthestartofnewtasksuntiltheupdateiscompleted.
5 REALIZING SAFE DYNAMIC UPDATES
Determining and reaching the update condition is trivial with a
singlecentralizedworkflowengine.Suchacentralentity(1)knowsthestateofallworkflowinstances
I,and(2)candelaytheexecution
of tasks and whole workflow instances. However, the system land-
scapeLmay comprise multiple workflow engines R, each hosting
a subset of workflow instances I. Hence, no centralized view ex-
ists on all workflow instances. Modern, scalable workflow engines,
e.g., Zeebe [ 12], areby default decentralized over multipleseparate
workflow engines to improve scalability and fault tolerance.
Toensuretheirsafeupdate,allworkflowenginesinvokingtasks
on asharedcomponent have to coordinate. Hence, reaching Essen-
tial Freeness for a component requires considering all workflow
instances Ithatusethecomponent.Weproposeadissemination
algorithm that the workflow engines use to notify componentsof their workflow instancesâ€™ status. The algorithm ensures that
components are aware of their role in all workflow instances using
them. Each component can then locally decide whether it reached
the update condition and can be safely updated.
354
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 07:52:58 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Daniel Sokolowski, Pascal Weisenburger, and Guido Salvaneschi
5.1 Dissemination Algorithm
Algorithm 1shows the dissemination algorithm that workflow
enginesexecute foreachworkflowinstance.Thefourcallbackpro-
cedures in Algorithm 1are called reactively based on the events in
the workflow execution, e.g., before a task is started, the procedure
in Line1.5is called. Using the procedures, the workflow engine
(1)announces to components that they might be used, (2) marks
componentsthatwereused,and(3) lockscomponents(notexclu-
sively)whiletheyareused.Everycomponentstoresitsstatusinthe
workflowinstances,i.e.,everycomponentmaintainsforeachwork-
flowinstancetheinformationwhetheritreceivedanannouncement
or a marking, which was not revoked yet, and a lock counter.
BeforeWorkflow,AfterWorkflow,BeforeEachTask,and
AfterEachTask are executed on the workflow engine before/after
aworkflowinstanceisexecutedandbefore/aftereachtaskisrun.
TheAnnounce,RevokeAnnouncement,Mark,RevokeMarking,
Lock,andUnlockproceduresarecalledremotelyonthecompo-
nent passed as their first argument. Remote calls are asynchronous
unless the execution blocks to get the return value using await.
Componentscandelaytheirresponseatthe awaitsynchronization
points to interrupt the workflow instanceâ€™s execution until they
can accept the announcement, marking, or lock.
The BeforeWorkflow procedure (Line 1.2) announces to com-
ponentsğ‘(Line1.4) from the set of potential future tasks (Line 1.3)
of the workflow instance ğ¼thatğ‘might participate in ğ¼. Announce-
ments are revoked after completing tasks (Lines 1.11to1.14) if the
component will not be used (again).
Beforetheworkflowinstanceinvokesataskonacomponentfor
the first time, the engine marks the component (Lines 1.6to1.8).
Markings remain for the rest of the workflow instanceâ€™s execution
and are revoked after its completion (Line 1.17).
Every time a workflow instance invokes a task, the engine locks
the component (Line 1.9) and unlocks it after the task is completed
(Line1.15).Aworkflowinstancemightlockthesamecomponent
multiple times beforeunlocking due to paralleltask execution. The
componentsinternallyincreaseacounterwitheverylockingand
decrease it with every unlocking. If the counter is positive, the
workflow instance runs tasks on the component.
Thepresentation ofAlgorithm 1is simplifiedfor clarity.Our im-
plementation includes some optimizations, e.g., it sends announce-
ments(Line 1.4)inparallel,andthemessagesto ğ‘–(ğ‘‡ğ‘ğ‘ ğ‘˜)inLines1.5
to1.9are packed into a single multipurpose message.
5.2 Handling Essential Freeness
Algorithm 1disseminates the necessary information to the compo-
nents to determine, reach, and uphold Essential Freeness. When
performingan updatethatintroducesessential changes,acompo-
nentisessentiallyfreeifitholdsfornoworkflowinstanceanan-
nouncement anda marking, i.e., no workflow instance that already
used the component will use it again. For non-essential changes, a
componentisessentiallyfreeifitisnotlocked,i.e.,fornoworkflow
instance, the lock counter is greater than zero.
Usingthe BlockingInstances strategy,acomponentdelaysthe
confirmation of announcements until the update has been com-
pleted, blocking all new workflow instances that will call the com-
ponent in BeforeWorkflow and delaying their start. BlockingAlgorithm1 Modulardisseminationalgorithmonworkflowengine
ğ‘Ÿfor workflow instance (ğ‘Ÿ,ğ‘Š,ğ´,ğ‘‰,ğ¹,ğ‘†) with unique identifier ğ¼.
Announcements Markings Locks .
1:Announcements ,Markings â†âˆ…
2:procedure BeforeWorkflow
3:Announcements â†{ğ‘âˆˆC|âˆƒğ‘¡âˆˆğ¹:ğ‘–(ğ‘¡)=ğ‘}
4:for allğ‘âˆˆAnnouncements do await Announce( ğ‘,ğ¼)
5:procedure BeforeEachTask(Task)
6:ifğ‘–(Task)âˆ‰Markings then
7: awaitMark(ğ‘–(Task),ğ¼)
8: Markings â†Markings âˆªğ‘–(Task)
9:awaitLock(ğ‘–(Task),ğ¼)
10:procedure AfterEachTask(Task)
11:PreviousAnnouncements â†Announcements
12:Announcements â†{ğ‘âˆˆC|âˆƒğ‘¡âˆˆğ¹:ğ‘–(ğ‘¡)=ğ‘}
13:for allğ‘âˆˆPreviousAnnouncements \Announcements do
14: RevokeAnnouncement( ğ‘,ğ¼)
15:Unlock(ğ‘–(Task),ğ¼)
16:procedure AfterWorkflow
17:for allğ‘âˆˆMarkings doRevokeMarking( ğ‘,ğ¼)
Tasksuses a similar approach with locks for non-essential changes
andmarkingsforessentialchanges.Locksblockallworkflowin-
stances, markings only the ones that did not use the componentyet.Blocking Tasks does not generally block all task invocations
by delaying locks because this could lead to a deadlock in case
ofessentialchanges:Thenot-blockedworkflowinstancesalready
usedthecomponentandmayprevent EssentialFreenessâ€”which
would cause a deadlockâ€”or do not use it anymore. For this reason,
BlockingTasks canonlybeactivatedatonecomponentatatime
to ensure deadlock-freeness.
For both strategies above, once reached, the update condition
must be uphelduntil the update completes. Foressential changes,
delayingtheconfirmationofmarkingsupholdstheupdatecondi-
tion. For non-essential changes, locks are delayed.
WaitingandConcurrentVersions donotrequireanyaspectof
Algorithm 1fortheirupdateconditionbecausetheydonotinfluence
the execution of workflow instances.
6 WORKFLOW UPDATES IN CONTEXT
In this section, we show how Essential Safety relates to existing
solutions for safe dynamic software updating.
6.1 From Transactions to Workflows
PreviousworkonDSU[ 8,32,38,60]focusedonsynchronousdis-
tributedtransactionsincomponent-basedsystems.Theyassume
thatexternalclientstriggerso-calledroottransactions,which,in
turn, can run other (sub-)transactions on the same or other compo-
nents. The execution blocks until a sub-transaction completes with
areturnvalue.InFigure 3a,component Arunsasub-transaction
on B, which runs a sub-transaction on C. Afterward, Creturns
a value to B,Bone to A, and new sub-transactions are run on B
and C.Figure3bshowsthesameinteractionpatternbutsynchro-
nous transactions are nested differently: Instead of ending the first
transaction on B,Bruns a sub-transaction on A.
355
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 07:52:58 UTC from IEEE Xplore.  Restrictions apply. Change Is the Only Constant: Dynamic Updates for Workflows ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
& % $
(a) Synchronous
transaction.& % $
(b) Alternative
synchronous
transaction.$ % &
(c) Asynchronous
workflow.
Figure 3: Modeling a synchronous transaction as workflow.
In this work, we model the system as asynchronous workflows.
Tasksarestartedbasedontheirorderasdefinedintheworkflow
after the previous task(s) are completed. The tasks are coordinated
by the workflow engine, which acts as an event-based middle-
ware. Thus, upon completion, tasks send their results as an update
of the state ğ‘†to the workflow engine, which then starts the suc-
ceeding task(s) with ğ‘†. Modern cloud-based systemsâ€”also beyond
workflowsâ€”adopttheasynchronousmodel.Typically,suchsystems
use asynchronous, decoupled communication patterns, e.g., event-
based microservice choreographies or serverless computing [ 7,35].
Ourasynchronousworkflowmodelcanemulatethesynchronous
model.Forinstance,thetransactioninFigure 3acanbemodeledas
inFigure 3c:thesynchronousparenttransactionsaresplitintotwo
tasks(beforeandafterthesubtransaction).Statecanbeconveyed
viathe workflowinstanceâ€™sstate ğ‘†.This transformationisneither
injective norsurjective: Not every asynchronousworkflow can be
translatedtoasynchronoustransaction,andmultipledifferently
nestedsynchronoustransactionsmightbetransformedtothesame
workflow, e.g., both Figures 3aand3bresult in Figure 3c.
6.2 Existing Safe DSU Approaches
We now present three update conditions from the literature and
show how they fit into our asynchronous workflow model.
KramerandMagee [32]proposed Quiescence (Q),whichdoes
notrelyonruntimeinformationofworkflowinstances.Instead,the
workflowsâ€™ structure, which is known at design time, and whether
a new workflow instance will be started suffice. If necessary, all
future workflow instances are blocked to enforce Quiescence.
Definition6.1(Quiescence). Acomponentis quiescent ifit(1)is
not active and (2) will not be active in a workflow instance.
Ma et al.[38]proposed Version Consistency (VC) and evaluated
it with a simulation which was later extended with a system im-
plementation and evaluation based on Apache Tuscany [ 8]. The
update condition of Version Consistency is calledFreeness.
Definition6.2(Freeness). Acomponentis freeifit(1)isnotactive
and(2)willnotbeactiveinaworkflowinstanceinwhichitalready
executed a task.
VersionConsistency issimilartoourapproachbutitdoesnot
distinguishbetweendifferenttypesofupdates,whichareallcon-
servatively over-approximated to an essential change.
Vandewoude et al. proposeTranquility (TQ)[60].Definition6.3(Tranquility). Acomponentis tranquilifit(1)is
notactiveand(2)willnotbeactiveinaworkflowinstanceinwhich
it might execute a succeeding task for a component for which it
already executed a succeeding task.
Though proposed before Version Consistency, Tranquility ef-
fectivelycorrespondsto VersionConsistency withtheadditional
assumption that components follow a â€œblack-box principleâ€ [ 60].
For systems satisfying this principle, Tranquility assumes that ver-
sionconsistencydoes nothavetobeenforcedbetweentheinternals
ofdifferentsub-transactions.Forinstance,ifwithinthesameroot
transactionaclientusesanauthenticationcomponentandcallsthe
server, which uses authentication internally, too, client and server
may safely use different versions of the authentication component.
Leveraging the black-box principle, Tranquility results in bet-
ter update timeliness and less interruption than Version Consis-
tency[38]. However, Tranquility is unsafe for systems that do not
follow the black-box principle, as Ma et al .[38]already noticed. It
is generally questionable whether workflows follow the black-box
principlebecausetheirtasksoftendependoneachother,leading
to a violation of the principle.
Quiescence andVersionConsistency mapdirectlytoourasyn-
chronous workflow model (Section 4.1), i.e., Definitions 6.1and6.2
canbetriviallyverifiedbyinspectingthepotentialfuturetasks ğ¹
and thevisited tasks ğ‘‰.Tranquility (Definition 6.3), however, dis-
tinguishes between sub-transactions that are called from the same
transaction and ones that are called from a different transaction.
For example, component Cis tranquil between its two executions
in Figure 3a, and it is not tranquil between its two task executions
inFigure 3b.Yet,thereisnosuchdistinctionintheasynchronous
modelinFigure 3ccomparedtothesynchronousmodel(Section 6.1).
Embracing Tranquilityâ€™s black-box principle, we assume that all
taskexecutionsofacomponentwithprecedingtasksfromthesame
component belong to a single, synchronous transaction, i.e., for
eachcomponent,thesameversionofanothercomponentisusedfor
each of its succeeding tasks. With this definition, in the asynchro-
nousworkflowinFigure 3c,component Cisonlytranquilbefore
the first and after the second task. Component A, however, may be
updated after its first task, i.e., Tranquility is unsafe if components
do not respect the black-box principle.
6.3 Update Conditions, Operationally
Differentsubsetsofourdisseminationalgorithm(Algorithm 1)pr o-
vide the necessary data to a component to (1) determine that an
updateconditionforthecomponentisreached,(2)reachthecon-
dition (quicker), and (3) uphold the condition once reached. Our
algorithmisinspiredbythecontrolalgorithmproposedfor Version
Consistency, which is based on graph transformations [ 38] and
verified to be correct [ 8].Announcements are similar to their future
edgesandmarkings topast edges ; there is no counterpart for locks.
However, their transaction model lacks a holistic view of trans-
actionswithinthesameroottransactionbecausecomponentsdo
not share their internal logic. In our workflow model, such a view
on workflow instances is available in their workflow engine. We
leverage this holistic view to reduce communication. Table 2sum-
marizesthe partsofAlgorithm 1requiredbythe updateconditions
and reaching strategies. We now provide more detailed insights.
356
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 07:52:58 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Daniel Sokolowski, Pascal Weisenburger, and Guido Salvaneschi
ABCDd c bE
Q
+ROLGD\ &DU5HQWDO,RQU
+ROLGD\ &DU5HQWDO,RQU
+ROLGD\ &DU5HQWDO,RQU
+ROLGD\ &DU5HQWDO,RQU
+ROLGD\ &DU5HQWDO,RQU
+ROLGD\ &DU5HQWDO,RQU
+ROLGD\ &DU5HQWDO,RQU
+ROLGD\ &DU5HQWDO,RQU
TQ
+ROLGD\ &DU5HQWDOÂ‘
&5+
+,RQU
+ROLGD\ &DU5HQWDOÂ‘Â‘
&5+
+,RQU
+ROLGD\ &DU5HQWDOÂ‘&5+
++,RQU
+ROLGD\ &DU5HQWDOÂ‘&5&5
++,RQU
+ROLGD\ &DU5HQWDOÂ‘&5
+&5+
++,RQU
+ROLGD\ &DU5HQWDOÂ‘ +&5&5 ,RQU
+ROLGD\ &DU5HQWDOÂ‘++,RQU
+ROLGD\ &DU5HQWDO,RQU
VC
+ROLGD\ &DU5HQWDO,RQU
+ROLGD\ &DU5HQWDO,RQU
+ROLGD\ &DU5HQWDO,RQU
+ROLGD\ &DU5HQWDO,RQU
+ROLGD\ &DU5HQWDO,RQU
+ROLGD\ &DU5HQWDO,RQU
+ROLGD\ &DU5HQWDO,RQU
+ROLGD\ &DU5HQWDO,RQU
ES
+ROLGD\ &DU5HQWDO,RQU
+ROLGD\ &DU5HQWDO,RQU
+ROLGD\ &DU5HQWDO,RQU
+ROLGD\ &DU5HQWDO,RQU
+ROLGD\ &DU5HQWDO,RQU
+ROLGD\ &DU5HQWDO,RQU
+ROLGD\ &DU5HQWDO,RQU
+ROLGD\ &DU5HQWDO,RQU
Figure 4: Announcements, markings, and locks at intervals in Figure 2during the execution of the trip booking saga with Algo-
rithm1forallupdateconditions( announcement, marking, lock,update safe ,non-essential update safe ,update unsafe ).
Table 2: Elements of Algorithm 1for updating approaches
andreachingstrategies: /checknecessary, /checkCperprecedingcom-
ponent, /check*sufficientfornon-ess.changes, /trianglesolidupholdcondi-
tion (ess. changes), /squaresoliduphold condition (non-ess. changes).
Approach / Strategy Announcements Markings Locks
Quiescence /check/trianglesolid /squaresolid
Tranquility /checkC/checkC/trianglesolid/squaresolid
Version Consistency /check/check /trianglesolid/squaresolid
Essential Safety /check/check /trianglesolid /check /squaresolid
Waiting
Blocking Instances /check
Blocking Tasks /check/check *
Concurrent Versions /check
InQuiescence, announcements are sufficient to check if compo-
nentsarequiescent:Theyareiftheyhavenoannouncements.To
reachQuiescence,KramerandMagee [32]onlydiscuss Blocking
Instances as â€œpassivationâ€ of components, i.e., ensuring that no
transactionsareinvokedonthecomponentinthefuture.Theother
threereachingstrategiesarealsoapplicablebutrequireruntime
information, which Kramer and Magee do not consider.
VersionConsistency requiresannouncementsandmarkings,but
no locks. A component is free if it has for no workflow instance
an announcement anda marking. Ma et al .[38]discussWaiting,
Blocking Tasks, and Concurrent Versions forVersion Consistency,
concluding that the last one should be the preferred strategy if
applicable, otherwise Blocking Tasks. Essential Safety andVersion
Consistency are equivalent if all updates are essential changes.
Tranquility alsorequiresannouncementsandmarkings.Yet,both
need to be per workflow instance andper component of the pre-
cedingtask(s)â€”notonlyperworkflowinstanceasinAlgorithm 1.
The condition is then similar to Version Consistency: The com-
ponent is tranquil if it has for no pair of workflow instance and
preceding tasksâ€™ component an announcement anda marking. For
Blocking Tasks, this may deadlock workflow instances, makingBlocking Tasks forTranquility generally unsafeâ€”also for single
updates. Vandewoude et al
.[60]useWaitingforTranquility and
resort toBlocking Instances if the update point is not reached.6.4 Comparing the Update Conditions
Figure4showstheexecutionofAlgorithm 1inthetripbookingsaga
(Section2.1)forthediscussedupdateconditions.Thecolumnsshow
thetimeintervalsfromFigure 2(aligningwithTable 1).Therows
showtheupdateconditions.Eachcelldepictstheannouncements ,
markings ,andlocks storedonbothcomponentsatthegiven
time interval when using the respective update condition. They
further show whether a component can be updated safely, only for
non-essential changes, or the update is unsafe.
Timeinterval AstartsafterBeforeWorkflowcompletesand
ends before BeforeEachTask starts for the first time. All other
time intervals are during the execution of the respective task.
As an example, the bottom row shows Essential Safety. The
firstentryillustratesthatattimeinterval A,boththeholidayand
the car rental component hold an announcement for the workflow
instanceğ¼executedonworkflowengine ğ‘Ÿ.Bothcomponentscanbe
safely updated. In the second entry at time interval B, the holiday
component is additionally marked and locked. Hence, it cannot
besafelyupdated.Attimeinterval C,theholidaycomponentcan
be updated in case the update is a non-essential change becauseit holds no lock. However, an essential update would be unsafe
because it holds a marking andan announcement of ğ¼.
Quiescence exhibits the fewest safe update intervals because
itdoesnotconsiderruntimeinformationonworkflowinstances.
We assume that no new workflow instance is started after the one
in Figure 2. Otherwise, there would be no safe update interval for
Quiescence atall.Incontrast,thesafeupdateintervalsfortheother
approaches remain unchanged without such an assumption.
Tranquility features all safe update intervals of Version Consis-
tency. Plus, it permits intervals Cand cfor the holiday component
(/checkin Table1), which cannot be considered generally safe if the
componentdoesnot respecttheblack-boxprinciple.For instance,
iftheholidaycomponentisupdatedattheseintervalsinawaythat
it writes and reads the hotel booking id in another format to/from
workflows state ğ‘†, â€œcancel hotelâ€ could fail.
Essential Safety features all safe update intervals of Version
Consistency for essential changes. For non-essential changes, it
provides the most safe update intervals of all approaches.
357
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 07:52:58 UTC from IEEE Xplore.  Restrictions apply. Change Is the Only Constant: Dynamic Updates for Workflows ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
Table 3:Construction statistics of therealistic collaborative
BPMN workflows dataset based on RePROSitory [17].
Workflow Collection Size Recovered Unchanged
RePROSitory 572
Collaborative workflows 135
Stuck 37 22
Endless loop 96
Incomplete 10
Missing internals 10 0
Evaluation dataset 106 28 78
7 EVALUATION
Inthissection,weempiricallyevaluatedynamicsoftwareupdating
forlong-runningandhighly-frequentworkflows.Weaimtoanswer
the following research questions.
RQ1: Can safe DSU be adopted in real-world collaborative
workflow applications? With this question, we empirically in-
vestigate whether, with our model for safe DSU in workflows (Sec-
tion4.1), the approaches discussed in Section 4.2and6.2can be
applied to real-world collaborative workflow applications.
RQ2: Does Essential Safety significantly reduce the perfor-
manceoverheadofsafeDSUinrealisticworkflows? Thisques-
tionempiricallyinvestigatestheperformancedifferencesamong
theDSUapproachesdiscussedanalyticallyinSection 6.4.Specifi-
cally, we assesswhether Essential Safety significantly reduces the
impact of updating realistic workflow applications.
RQ3: How does the share of non-essential changes impactthe performance of Essential Safety? This question investi-
gates to which degree Essential Safetyâ€™s performance depends on
the amount of non-essential changes, estimating the share of non-
essentialchangesthatissufficienttoachievebetterperformance
thanthepreviousapproaches.With RQ4,RQ3validatestheassump-
tionsmotivating the EssentialSafetyâ€™sperformance improvement.
RQ4: How frequent are non-essential changes in software
systems with multiple components? This question verifies the
hypothesis behind Essential Safetyâ€”that most updates are non-
essentialâ€”ensuring the generalizability of our results. Such evi-
dence is required to determine the significance and applicability of
our approach to real-world workflows.
7.1 Applicability of Safe DSU to Workflows
We now evaluate whether our model and the safe DSU approaches
are applicable to workflows. For this, we constructed a dataset
of real-world BPMN workflows and implemented a discrete event-
basedsimulationforsafeDSUinworkflowsusingthedissemination
algorithm (Section 5.1). We assess Essential Safety (Section4) and
theothersafeDSUapproaches(Section 6.2).Thesimulationandall
scripts and data are publicly available [56].
No standard benchmark for realistic workflow models exists,
possibly due to their complexity and business relevance [ 53,54].
RePROSitory[ 17]isadatabaseofrealisticBPMNworkflows.Based
onafullcopyfromAugust3,2021,weconstructedanevaluation
dataset containing 106 collaborative BPMN workflows (Table 3).
WeselectedallcollaborativeworkflowswithtwoormoreBPMNTable 4: Simulation parameter distributions.
Parameter Distribution
Network latency Weibull: ğ›¼=1.5,ğ›½=30ms (ğœ‡=27.1ms, sd=18.4ms)
Instances per workflow Weibull: ğ›¼=1.5,ğ›½=20160(ğœ‡=18199,s d=12357)
Avg. task duration Weibull: ğ›¼=1.5,ğ›½=2min (ğœ‡=108.3s, sd=73.6s)
Task duration Gaussian: sd =10%âˆ—ğœ‡
Avg. update interval Gaussian: ğœ‡=12h, sd=4h, min=1h, max=24h
Avg. update duration Weibull: ğ›¼=1.5,ğ›½=5min (ğœ‡=4.5min, sd=3.1min)
Update duration Gaussian: sd =20%âˆ—ğœ‡
lanesorpoolsâ€”theBPMNelementsthatassignprocesselementstocollaborationparticipantsâ€”whichweinterpretasworkflowcompo-nents.Everythingoutsideanylaneorpoolisaseparatecomponent.
Accordingly,allworkflowshavetasksonatleasttwodifferentcom-
ponents.57workflowsarenotexecutablebecausetheygetstuck,
include endless loops, are incomplete, or only contain the internal
workflowofonelaneorpool.Wemanuallyrecovered28ofthese
with minimal changes.1
Table4providesthesimulation parameterdistributions.All pa-
rameters are chosen with the intent to be as realistic as possible.
Interarrival parameters and durations are Weibull-distributed with
ğ›¼=1.5,commonlyusedforInternet-basedtrafficsimulations[ 5].
UpdateintervalsandtaskdurationsareGaussian-distributed,simu-latingregularCI/CDexecutionsandtaskswithpredictable,roughlyconstantexecutiontime,whichiscommoninbusinessapplications.
The workflow instances are distributed over ten workflow engines.
For each workflow, the number of instances is Weibull-distributed
with, on average, one invocation every 66s. 99 .7% of the compo-
nents are updated between once per day and once per hour, which
are fixed limits of the mean update frequency. We draw the points
in time for startingworkflow instances and triggering componentupdates from a uniform distribution over the simulation timespan
of two weeks. 90% of the updates are non-essential changes. We
performedasensitivityanalysiswithbothdoubleandhalfthevalueofeachparameterusingthetripbookingsaga(Section 2.1).Weomit
the plots (reported in [ 56]), as they do only confirm obvious corre-
lations,e.g.,halvingthetaskdurationmeansincreasesupdatability
and decreases workflow duration and update time.
We successfully simulated all 106 workflows for the safe DSU
approaches in Section 4.2and6.2and the reaching strategies (Sec-
tion4.3).Thisresultpositivelyanswers RQ1,showingthatsafeDSU
can be applied to real-world collaborative workflow applications.
7.2 Performance of Essential Safety
We now investigate the performance differences of the DSU ap-
proaches in the simulation introduced before. Table 5and Figure 5
comparetheupdatingapproaches(Section 4.2and6.2)andreaching
strategies (Section 4.3) with the baseline â€œNo Updatesâ€ where no
updatesareperformed.Allsimulationsareexecutedonthesame
trace of workflow instance executions and updates. Updatability is
theoveralltimeinwhichtheupdateconditionismetatthecompo-
nents(i.e.,whenupdatingissafe).The updatetime measuresthe
timespan from triggering to completing a component update. It is
splitintothe updatetimeliness (untiltheupdateconditionismet)
and theupdate duration (after the update condition is met). The
1All exclusions and adjustments are documented in the datasetâ€™s build script [56].
358
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 07:52:58 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Daniel Sokolowski, Pascal Weisenburger, and Guido Salvaneschi
Table5:Performancemetricmeansforallupdateapproaches
and reaching strategies over all simulations in minutes.
Approach / Strategy UpdatabilityUpdate Workflow
Duration Timeliness Duration Delay
No Updates (Baseline) 15.90.0
Quiescence 2228.79 .1 1384 .41 6 .60.7
Version Consistency 4510.58 .2 518 .01 6 .70.8
Tranquility 902.78 .1 184 .71 5 .50.5
Essential Safety (ES) 4870.65 .1 409 .51 6 .30.4
ES: essential changes 4384.78 .0 541 .8
ES: non-ess. changes 4924.64 .8 395 .4
Blocking Instances 4219.34 .31 1 .41 7 .41.5
Blocking Tasks (BT) 5309.24 .4 785 .21 6 .10.7
BTw/oTranquility 4651.54 .46 .31 6 .70.8
Concurrent Versions 3744.61 6 .30 .51 5 .90.0
Waiting 4330.04 .3 2402 .31 6 .10.2
workflowduration isthetimespanbetweenworkflowinstancestart
andcompletion.The workflowdelay isthedifferenceofthework-
flow instancesâ€™ start to its start in the baseline. Analogously, the
workflow interruption is the difference of the instancesâ€™ completion
times, measured by the sum of the instancesâ€™ delay and duration
differences.For EssentialSafety,wealsoreportthemetricssepa-
rately for essential and non-essential changes, a distinction that
does not lead to different results for the other approaches.
Among all approaches, we find the least performance impact
on updates and workflow instances with Tranquility. However,
Tranquility is generally unsafeâ€”in contrast to all other approaches.
Further,Tranquility withBlockingTasks istheonlysimulationwith
deadlockedworkflowinstances(47 .2%),preventingtheircomple-
tion.Thesedeadlockspositivelyskewtheaveragesofallmetricsfor
Tranquility2because deadlocked workflow instances are excluded
from the measurement data. We observe that Essential Safety has
similarperformanceto VersionConsistency foressentialchanges
and slightly better performance than Tranquility for non-essential
changes. Overall, Essential Safetyâ€™s performance is similar to Tran-
quility, but retains update safety. On average, Essential Safetyâ€™s
workflow interruption is 5 .0%, and it provides 8 .0% higher updata-
bility,21.2%lessupdatetime,and47 .8%lessworkflowinterruption
thanVersion Consistencyâ€”the best, safe competitor.
The reaching strategiesâ€™ relative performance trends are similar
among the updating approaches. All strategies add only a small
delaytotheworkflows. VersionConsistency exhibitsnodelayat
all.BlockingInstances entailsthehighestdelays.For Concurrent
Versions, the update timeliness is similarly low for all updating
approaches, whereas the update duration exhibits some variabil-
ity. Viceversa, allother reachingstrategies exhibitsimilar update
durations but variableupdate timeliness. This differenceis due to
Concurrent Versions running two component versions in paral-
lel, eliminating the workflow interruption because workflow in-
stancesneverwaitforcomponentupdates.However, Concurrent
Versions requiresthatthecomponentsâ€™implementationssupport
running two different versions in parallel, which our simulation
assumesispossible.Ifnotsupportedbythecomponentsâ€™implemen-
tations,ConcurrentVersions mustnotbeused.Instead, Blocking
2Due to the deadlock skew, Table 5also reports Blocking Tasks withoutTranquility.	
 	 	 

	
				
	 	
!"	#$%
#$%&	'(
	
 	 	 
		
	
 	 	 
		
	
 	 	 
		
Figure 5: Performance of the safe DSU approaches.
Taskscauses the least impact on component updates in such cases.
ThoughWaitingdelays workflow instances to a lesser extent, it
heavily delays updatesâ€”on average by 40 .0 hours.
Ourresultsanswer RQ2andshowthattheimpactofsafeDSU
can be significant. For Essential Safety, the impact of non-essential
changesiscompletelynegligible,andtheimpactofessentialchanges
isnothigherthanwithpreviousapproaches.Forarealisticchange-
set,Essential Safety significantly decreases the overhead of safe
DSU compared to the state of the art.
7.3 Effect of Non-Essential Updates
To evaluate whether distinguishing essential and non-essential
changesiseffectiveâ€”theassumptionbehind EssentialSafetyâ€”we
repeattheprevioussimulationwithdifferentratiosofnon-essential
toessentialchanges.Figure 6showsthemetricsfromSection 7.2
forEssential Safety with only essential changes (0%), only non-
essential changes (100%), and all ratios in between in steps of 20%
points. The results are presented separately for essential (ess.) and
non-essential changes (non-ess.) as well as combined (total).
Intotal,theupdatabilityincreaseswiththeshareofnon-essential
changes; on average, 9 .5% from 0% to 100% non-essential changes.
Theupdatetimereduces,onaverage,byupto52 .2%andthework-
flow interruption by 54 .8%.
Wenowconsideressentialandnon-essentialchangesseparately.
For all metrics and approaches, the results are similar, i.e., inde-pendent from the share of non-essential changes, except for thefollowing cases: For Blocking Instances andBlocking Tasks, the
updatabilities slightly decrease with the increasing share of non-
essential changes because the likelihood that multiple updates are
reached jointly and executed as a batch is lower. This increases
blocking times to reach safe update intervals. For the same reason,
the timeliness of essential change updates gets worse for Waiting.
359
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 07:52:58 UTC from IEEE Xplore.  Restrictions apply. Change Is the Only Constant: Dynamic Updates for Workflows ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
	
 	 	 
               !"#	$%&
	
 	 	 
        		 !
	
 	 	 
            		 
Figure6:Performanceof EssentialSafety fordifferentshares
of non-essential changes (ess.: essential changes; non-ess.:
non-essential changes; total: all changes).
Theresultsanswer RQ3:Thehighertheshareofnon-essential
changes, the smaller Essential Safetyâ€™s overall performance impact.
Thus, considering non-essential changes is crucial and effective to
reduce the overhead of safe DSU for workflows.
7.4 Frequency of Non-Essential Updates
To answer RQ4, we focus on open-source software repositories
and assume that they use a continuous deployment pipeline. In
continuousdeployment,everycommitmaytriggerthedeployment
ofanupdate.Identifyingwhichcomponentsareaffectedbyeach
commit requires application knowledge and cannot be easily au-
tomated.Hence, forsimplicity, acommonpracticeis toredeployall components, even though one can easily hypothesize that a
subset suffices. To assess this hypothesis, we focus on repositories
that aggregate various software components. Such â€œmonoreposâ€
arewidelyused[ 25,33,36,46,47].Typically,thedegreetowhich
componentsinthemdependoneachothervaries,allowingusto
identify the subset of components that a commit changed.
We investigated eight monorepos that are publicly available on
GitHubanddescribedin[ 16].Inthemonorepos,eachcomponent
is encapsulated in its own directory. We identify the directories
that contain a component based on the repository description. We
explore the most recent 10000 commits of each repository to de-
terminehowmanycomponentsareaffectedbyeachcommit.We
assumethatacomponentchangedifacommitmodifiesafileinthe
componentâ€™s directory. For commits that change files not associ-
ated to any component, we consider a conservative approximation
(upperbound),thatthecommitsaffecteverycomponent,andaspec-
ulativeapproximation(lowerbound),thattheydonotaffectany.
We ignore changes to tests, documentation, and hidden directories.
Table6showsforeachmonorepotheabsolutenumberandthe
percentage of affected components (mean over all commits). Onaverage, even under the conservative approximation, a commitaffects less than half of the components. Under the speculative
approximation, commits affect less than 10% of the components in
mostmonorepos.Accordingly,atleast60% âˆ’90%ofthecomponent
updates are non-essential changes.Table6:Affectedcomponentspercommitinmonorepos[ 16].
Average number of components Average share of components
Monorepo affected by a commit affected by a commit
StartupOS 13 13%âˆ’41%
Foursquare Fsq.io 13 8%âˆ’38%
M3 22 8%âˆ’20%
Celo 23 7%âˆ’10%
Berty 31 8%âˆ’32%
Stellar Go 41 3%âˆ’4%
Habitat 49 5%âˆ’12%
Nixpkgs 810 <1%âˆ’15%
Sofarwehavedemonstratedhowoftencommitsarenon-essential
component changes because the commits do not change a compo-
nentâ€™s code. Additionally, not all code changes introduce semantic
changes, i.e., they are non-essential for allcomponents. Such com-
mits further reduce the observed numbers in Table 6. Previous
studies provide evidence that the amount of such non-essential
changesissignificant:(1)KawrykowandRobillard [31]analyzed
seven open-source Java systems, finding that up to 15 .5% of the
methodupdatesarecosmetic,behavior-preserving,orunlikelyto
provide further insight into component relationships. (2) Based on
the TravisTorrent dataset [ 9], Abdalkareem et al .[2]found that
10%ofthecommitsdevelopersmanuallyskipinCI/CDpipelines
are skipped because they are non-essential changes, i.e., they only
touch documentation, source code comments, formatting of source
code, meta files, or are code release preparations.
Theseresultsanswer RQ4:Onaverage,60%ofthecomponent
changes are non-essential as a lower bound, while we realistically
assume a considerably higher percentage of over 90%.
8 CONCLUSION
Traditionally, software updates require shutting down the system
beforereplacinganycomponent.Toavoidservicedisruption, dy-
namicsoftwareupdating (DSU)techniquesensurethatcomponents
can safely be replaced while the application is running. Unfortu-
nately, existing safe DSU approaches introduce a significant perfor-
mance overhead, and it is unclear how to apply them to workflows,
i.e.,long-running,asynchronoustransactions.Toclosethisgap,we
proposeaunifiedformalmodelforsafeDSUinworkflows,show
howstate-of-the-artDSUapproachesarecapturedbyit,andcom-
parethemanalyticallywith EssentialSafety,ournovelsafeDSU
solution. Essential Safety leverages the identification of updates
that have no semantic changesâ€”non-essential changesâ€”effectively
reducing the performance overhead of DSU. The empirical eval-uation on 106 realistic collaborative BPMN workflows and eight
monoreposconfirmsthatweenableefficient,safedynamicsoftware
updating in long-running and frequently executed workflows.
ACKNOWLEDGMENTS
We thank the anonymous reviewers for their valuable feedback
and all students at the Technical University of Darmstadt who
contributed to the discussion on safe DSU. This work has been co-
fundedbytheSwissNationalScienceFoundation(SNSF,No.200429),
by the German Research Foundation (DFG, SFB 1119), by the Hes-
sian LOEWE initiative (emergenCITY and Software-Factory 4.0),
and by the University of St. Gallen (IPF, No. 1031569).
360
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 07:52:58 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Daniel Sokolowski, Pascal Weisenburger, and Guido Salvaneschi
REFERENCES
[1] 2021. Kubernetes. https://kubernetes.io/, last accessed on 2021-10-22.
[2]Rabe Abdalkareem, Suhaib Mujahid, Emad Shihab, and Juergen Rilling. 2021.
Which Commits Can Be CI Skipped? IEEE Transactions on Software Engineering
47, 3 (March 2021), 448â€“463. https://doi.org/10.1109/TSE.2019.2897300
[3]AmazonWebServices.2021. AmazonStatesLanguage. https://docs.aws.amazon.
com/step-functions/latest/dg/concepts-amazon-states-language.html , last ac-
cessed on 2021-07-30.
[4]AmazonWebServices.2021. AWSStepFunctions. https://aws.amazon.com/step-
functions, last accessed on 2021-08-20.
[5]Muhammad Asad Arfeen, Krys Pawlikowski, Don McNickle, and Andreas
Willig. 2013. The role of the Weibull distribution in Internet traffic model-
ing.InProceedingsofthe201325thInternationalTeletrafficCongress(ITC) .1â€“8.
https://doi.org/10.1109/ITC.2013.6662948
[6]Joe Armstrong. 2010. Erlang. Commun. ACM 53, 9 (Sept. 2010), 68â€“75. https:
//doi.org/10.1145/1810891.1810910
[7]Ioana Baldini, Paul Castro, Kerry Chang, Perry Cheng, Stephen Fink, Vatche
Ishakian,NickMitchell,VinodMuthusamy,RodricRabbah,AleksanderSlominski,
andPhilippeSuter.2017. ServerlessComputing:CurrentTrendsandOpenProblems.
Springer, Singapore, 1â€“20. https://doi.org/10.1007/978-981-10-5026-8_1
[8]Luciano Baresi, Carlo Ghezzi, Xiaoxing Ma, and Valerio Panzica La Manna.
2017. EfficientDynamicUpdatesofDistributedComponentsThroughVersion
Consistency. IEEE Transactions on Software Engineering 43, 4 (2017), 340â€“358.
https://doi.org/10.1109/TSE.2016.2592913
[9]Moritz Beller, Georgios Gousios, and Andy Zaidman. 2017. TravisTorrent:Synthesizing Travis CI and GitHub for Full-Stack Research on Continuous In-tegration. In Proceedings of the 14th International Conference on Mining Soft-
ware Repositories (Buenos Aires, Argentina) (MSR â€™17). IEEE Press, 447â€“450.
https://doi.org/10.1109/MSR.2017.24
[10]BoutheinaBennour,LudovicHenrio,andMarcelaRivera.2009.AReconfiguration
Framework for Distributed Components. In Proceedings of the 2009 ESEC/FSE
Workshop on Software Integration and Evolution @ Runtime (Amsterdam, The
Netherlands) (SINTER â€™09). Association for Computing Machinery, New York,
NY, USA, 49â€“56. https://doi.org/10.1145/1596495.1596509
[11]ChristopheBidan,ValÃ©rieIssarny,TitosSaridakis,andApostolosZarras.1998.
A Dynamic Reconfiguration Service for CORBA. In Proceedings of the Fourth
InternationalConferenceonConfigurableDistributedSystems(Cat.No.98EX159)
(CDSâ€™98).IEEEComputerSociety,USA,35â€“42. https://doi.org/10.1109/CDS.1998.
675756
[12]Camunda. 2016. Zeebe â€“ Workflow Engine for Microservices Orchestration.
https://zeebe.io/, last accessed on 2021-09-02.
[13]F. Casati, S. Ceri, B. Pernici, and G. Pozzi. 1998. Workflow evolution. Data &
Knowledge Engineering 24, 3 (1998), 211â€“238. https://doi.org/10.1016/S0169-
023X(97)00033-5 ER â€™96.
[14]Gerry Gerard Claps, Richard Berntsson Svensson, and AybÃ¼ke Aurum. 2015. On
the journey to continuous deployment: Technical and social challenges along
the way. Information and Software Technology 57 (2015), 21â€“31. https://doi.org/
10.1016/j.infsof.2014.07.009
[15]Gerry Gerard Claps, Richard Berntsson Svensson, and AybÃ¼ke Aurum. 2015.On the Journey to Continuous Deployment: Technical and Social Challengesalong the Way. Information and Software Technology 57 (2015), 21â€“31. https:
//doi.org/10.1016/j.infsof.2014.07.009
[16]UrielCorfa.2017.AwesomeMonorepo:Notablepublicmonorepos. https://github.
com/korfuri/awesome-monorepo#notable-public-monorepos ,lastaccessedon
2021-09-02.
[17]Flavio Corradini, Fabrizio Fornari, Andrea Polini, Barbara Re, and Francesco
Tiezzi. 2019. RePROSitory: a Repository Platform for Sharing Business PROcess
modelS.BPM (PhD/Demos) (2019), 149â€“153.
[18]R.S.Fabry.1976. HowtoDesignaSysteminWhichModulesCanBeChanged
ontheFly.In Proceedingsofthe2ndInternationalConferenceonSoftwareEngi-
neering(SanFrancisco,California,USA) (ICSEâ€™76) .IEEEComputerSocietyPress,
Washington, DC, USA, 470â€“476.
[19]Nicole Forsgren, Dustin Smith, Jez Humble, and Jessie Frazelle. 2019. 2019 Accel-
erateStateofDevOpsReport. TechnicalReport. https://services.google.com/fh/
files/misc/state-of-devops-2019.pdf , last accessed on 2021-05-05.
[20]MartinFowler.2010. BlueGreenDeployment. https://martinfowler.com/bliki/
BlueGreenDeployment.html, last accessed on 2021-07-22.
[21]Keheliya Gallaba, Yves Junqueira, John Ewart, and Shane Mcintosh. 2020. Accel-
erating Continuous Integration by Caching Environments and Inferring Depen-
dencies.IEEE Transactions on Software Engineering (2020).https://doi.org/10.
1109/TSE.2020.3048335
[22]HectorGarcia-MolinaandKennethSalem.1987. Sagas.In Proceedingsofthe1987
ACMSIGMODInternationalConferenceonManagementofData (SanFrancisco,
California,USA) (SIGMODâ€™87) .AssociationforComputingMachinery,NewYork,
NY, USA, 249â€“259. https://doi.org/10.1145/38713.38742
[23]Matthias Geiger, Simon Harrer, JÃ¶rg Lenhard, and Guido Wirtz. 2016. On the
EvolutionofBPMN2.0SupportandImplementation.In 2016IEEESymposiumonService-OrientedSystemEngineering (SOSEâ€™16).101â€“110. https://doi.org/10.
1109/SOSE.2016.39
[24]Matthias Geiger, Simon Harrer, JÃ¶rg Lenhard, and Guido Wirtz. 2018. BPMN 2.0:
Thestate ofsupportandimplementation. FutureGeneration ComputerSystems
80 (2018), 250â€“262. https://doi.org/10.1016/j.future.2017.01.006
[25]Durham Goode and Rain. 2014. Scaling Mercurial at Facebook. https:
//engineering.fb.com/2014/01/07/core-data/scaling-mercurial-at-facebook/, last
accessed on 2021-09-02.
[26]Google Cloud. 2021. Workflows. https://cloud.google.com/workflows, last
accessed on 2021-08-20.
[27]PaulGrefen,JochemVonk,andPeterApers.2001. GlobalTransactionSupport
for Workflow Management Systems: From Formal Specification to Practical
Implementation. TheVLDBJournal 10,4(Dec.2001),316â€“333. https://doi.org/
10.1007/s007780100056
[28]Tianxiao Gu, Xiaoxing Ma, Chang Xu, Yanyan Jiang, Chun Cao, and Jian Lu.
2018. AutomatingObjectTransformationsforDynamicSoftwareUpdatingvia
Online Execution Synthesis. In 32nd European Conference on Object-Oriented Pro-
gramming (ECOOP2018) (LeibnizInternational Proceedings inInformatics (LIPIcs),Vol.109),ToddMillstein(Ed.).SchlossDagstuhlâ€“Leibniz-ZentrumfuerInformatik,
Dagstuhl, Germany, 19:1â€“19:28. https://doi.org/10.4230/LIPIcs.ECOOP.2018.19
[29]Deepak Gupta, Pankaj Jalote, and Gautam Barua. 1996. A formal framework for
on-line software version change. IEEE Transactions on Software Engineering 22, 2
(1996), 120â€“131. https://doi.org/10.1109/32.485222
[30]Michael W. Hicks and Scott Nettles. 2005. Dynamic software updating. ACM
Trans. Program. Lang. Syst. 27, 6 (2005), 1049â€“1096. https://doi.org/10.1145/
1108970.1108971
[31]DavidKawrykowandMartinP.Robillard.2011.Non-EssentialChangesinVersion
Histories. In Proceedings of the 33rd International Conference on Software Engi-
neering(Waikiki, Honolulu, HI, USA) (ICSE â€™11). Association for Computing Ma-
chinery, New York, NY, USA, 351â€“360. https://doi.org/10.1145/1985793.1985842
[32]Jeff Kramer and Jeff Magee. 1990. The evolving philosophers problem: dynamic
change management. IEEE Transactions on Software Engineering 16, 11 (1990),
1293â€“1306. https://doi.org/10.1109/32.60317
[33]Frederic Lardinois. 2017. Microsoft now uses Git and GVFS to develop Win-
dows.https://techcrunch.com/2017/05/24/microsoft-now-uses-git-and-gvfs-to-
develop-windows/, last accessed on 2021-09-02.
[34]EeroLaukkanen,JuhaItkonen,andCasperLassenius.2017. Problems,causesand
solutions when adopting continuous deliveryâ€”A systematic literature review.
Information and Software Technology 82 (2017), 55â€“79. https://doi.org/10.1016/j.
infsof.2016.10.001
[35]James Lewis and Martin Fowler. 2014. Microservices: a definition of this newarchitectural term. http://martinfowler.com/articles/microservices.html , last
accessed on 2021-09-02.
[36]Aimee Lucido. 2017. Monorepo to Multirepo and Back Again. Presentation
at theUberTechnology Day, https://www.youtube.com/watch?v=lV8-1S28ycM,
last accessed on 2021-09-02.
[37]Lucy Ellen Lwakatare, Terhi Kilamo, Teemu Karvonen, Tanja Sauvola, Ville
HeikkilÃ¤,JuhaItkonen,PasiKuvaja,TommiMikkonen,MarkkuOivo,andCasper
Lassenius. 2019. DevOps in practice: A multiple case study of five companies.Information and Software Technology 114 (2019), 217â€“230. https://doi.org/10.
1016/j.infsof.2019.06.010
[38]Xiaoxing Ma, Luciano Baresi, Carlo Ghezzi, Valerio Panzica La Manna, and Jian
Lu. 2011. Version-Consistent Dynamic Reconfiguration of Component-BasedDistributed Systems. In Proceedings of the 19th ACM SIGSOFT Symposium and
the 13th European Conference on Foundations of Software Engineering (Szeged,
Hungary) (ESEC/FSE â€™11). Association for Computing Machinery, New York, NY,
USA, 245â€“255. https://doi.org/10.1145/2025113.2025148
[39]Philip K. McKinley, Seyed Masoud Sadjadi, Eric P. Kasten, and Betty H.C. Cheng.
2004. Composing adaptive software. Computer 37, 7 (2004), 56â€“64. https:
//doi.org/10.1109/MC.2004.48
[40]Frederic Montagut, Refik Molva, and Silvan Tecumseh Golega. 2008. The Per-
vasive Workflow: A Decentralized Workflow System Supporting Long-Running
Transactions. IEEE Transactions on Systems, Man, and Cybernetics, Part C (Appli-
cations and Reviews) 38, 3 (2008), 319â€“333. https://doi.org/10.1109/TSMCC.2008.
919184
[41]Kief Morris. 2021. Infrastructure as Code: Dynamic Systems for the Cloud Age
(second ed.). Oâ€™Reilly Media, Inc., Sebastopol, CA, USA.
[42]Netflix.2021. Conductor. https://netflix.github.io/conductor/ ,lastaccessedon
2021-08-20.
[43] Sam Newman. 2021. Building Microservices (second ed.). Oâ€™Reilly Media, Inc.
[44]OASIS. 2007. Web Services Business Process Execution Language Version 2.0.OASIS Standard, http://docs.oasis-open.org/wsbpel/2.0/wsbpel-v2.0.html, last
accessed on 2021-07-30.
[45]Object Management Group. 2014. Business Process Model and Notation Version
2.0.2.https://www.omg.org/spec/BPMN, last accessed on 2021-07-30.
[46]Dorothy Ordogh. 2018. Pants and Monorepos. Presentation at the Typelevel
SummitBoston, https://www.youtube.com/watch?v=IL6LBWNi3fE,lastaccessed
on 2021-09-02.
361
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 07:52:58 UTC from IEEE Xplore.  Restrictions apply. Change Is the Only Constant: Dynamic Updates for Workflows ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
[47]Rachel Potvin and Josh Levenberg. 2016. Why Google Stores Billions of Lines
of Code in a Single Repository. Commun. ACM 59, 7 (June 2016), 78â€“87. https:
//doi.org/10.1145/2854146
[48]Bernd RÃ¼cker. 2019. trip-booking-saga-serverless. GitHub repository, https:
//github.com/berndruecker/trip-booking-saga-serverless, last accessed on 2021-
07-27.
[49]Marcio Augusto Sekeff Sallem and Francisco Jose da Silva e Silva. 2006. Adapta:
AFrameworkforDynamicReconfigurationofDistributedApplications.In Pro-
ceedings of the 5th Workshop on Adaptive and Reflective Middleware (ARM â€™06)
(Melbourne,Australia) (ARMâ€™06).AssociationforComputingMachinery,New
York, NY, USA, 10. https://doi.org/10.1145/1175855.1175865
[50]Danilo Sato. 2014. Carnary Release. https://martinfowler.com/bliki/
CanaryRelease.html, last accessed on 2021-07-22.
[51]Danilo Sato. 2014. Parallel Change. https://martinfowler.com/bliki/
ParallelChange.html , last accessed on 2021-07-22.
[52]Habib Seifzadeh, Hassan Abolhassani, and Mohsen Sadighi Moshkenani.
2013. A survey of dynamic software updating. Journal of Software: Evo-
lution and Process 25, 5 (2013), 535â€“568. https://doi.org/10.1002/smr.1556
arXiv:https://onlinelibrary.wiley.com/doi/pdf/10.1002/smr.1556
[53]Marigianna Skouradaki, Vasilios Andrikopoulos, and Frank Leymann. 2016.Representative BPMN 2.0 Process Model Generation from Recurring Struc-tures. In 2016 IEEE International Conference on Web Services (ICWS). 468â€“475.
https://doi.org/10.1109/ICWS.2016.67
[54]Marigianna Skouradaki, Dieter H. Roller, Frank Leymann, Vincenzo Ferme, and
CesarePautasso.2015. OntheRoadtoBenchmarkingBPMN2.0WorkflowEn-
gines.InProceedingsofthe6thACM/SPECInternationalConferenceonPerformance
Engineering (Austin, Texas, USA) (ICPE â€™15). Association for Computing Machin-
ery, New York, NY, USA, 301â€“304. https://doi.org/10.1145/2668930.2695527
[55]Daniel Sokolowski, Pascal Weisenburger, and Guido Salvaneschi. 2021. Au-tomating Serverless Deployments for DevOps Organizations. In Proceedingsof the 29th ACM Joint Meeting on European Software Engineering Conferenceand Symposium on the Foundations of Software Engineering (Athens, Greece)
(ESEC/FSE 2021). Association for Computing Machinery, New York, NY, USA,
57â€“69.https://doi.org/10.1145/3468264.3468575
[56]DanielSokolowski,PascalWeisenburger,andGuidoSalvaneschi.2022.Evaluation
ofSafeDynamic UpdatingonCollaborativeBPMNWorkflowsWithaDiscrete-
event Simulation: Dataset, Implementation, Measurements, and Analysis. https:
//doi.org/10.5281/zenodo.5864684
[57]Gareth Stoyle, MichaelHicks, Gavin Bierman, Peter Sewell, andIulian Neamtiu.
2007. Mutatis Mutandis: Safe and Predictable Dynamic Software Updating. ACM
Trans. Program. Lang. Syst. 29, 4 (Aug. 2007), 22â€“es. https://doi.org/10.1145/
1255450.1255455
[58]SuriyaSubramanian,MichaelHicks,andKathrynS.McKinley.2009. Dynamic
Software Updates: A VM-Centric Approach. In Proceedings of the 30th ACM SIG-
PLAN Conference on Programming Language Design and Implementation (Dublin,
Ireland)(PLDIâ€™09).Association forComputingMachinery, NewYork,NY,USA,
1â€“12.https://doi.org/10.1145/1542476.1542478
[59]Ken Tindell. 1990. Dynamic Code Replacement and Ada. Ada Lett. X, 7 (Aug.
1990), 47â€“54. https://doi.org/10.1145/101120.101133
[60]Yves Vandewoude, Peter Ebraert, Yolande Berbers, and Theo Dâ€™Hondt. 2007.
Tranquility:ALowDisruptiveAlternativetoQuiescenceforEnsuringSafeDy-
namic Updates. IEEE Transactions on Software Engineering 33, 12 (2007), 856â€“868.
https://doi.org/10.1109/TSE.2007.70733
[61]Thomas WÃ¼rthinger, Christian Wimmer, and Lukas Stadler. 2010. DynamicCode Evolution for Java. In Proceedings of the 8th International Conference on
thePrinciplesandPracticeofProgramminginJava (Vienna,Austria) (PPPJâ€™10).
Association for ComputingMachinery, New York, NY, USA, 10â€“19. https://doi.
org/10.1145/1852761.1852764
362
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 07:52:58 UTC from IEEE Xplore.  Restrictions apply. 