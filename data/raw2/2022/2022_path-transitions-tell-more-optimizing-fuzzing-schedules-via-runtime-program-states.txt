Path Transitions Tell More:
Optimizing Fuzzing Schedules via Runtime Program States
Kunpeng Zhang
Tsinghua Shenzhen International
Graduate School, Tsinghua University
zkp21@mails.tsinghua.edu.cnXi Xiao
Tsinghua Shenzhen International
Graduate School, Tsinghua University
xiaox@sz.tsinghua.edu.cnXiaogang Zhuâˆ—
Swinburne University of Technology
xiaogangzhu@swin.edu.au
Ruoxi Sun
The University of Adelaide
ruoxi.sun@adelaide.edu.auMinhui Xue
The University of Adelaide
jason.xue@adelaide.edu.auSheng Wenâˆ—
Swinburne University of Technology
swen@swin.edu.au
ABSTRACT
Coverage-guided Greybox Fuzzing (CGF) is one of the most suc-
cessful and widely-used techniques for bug hunting. Two major
approachesareadoptedtooptimizeCGF: (i)toreducesearchspace
of inputsby inferring relationshipsbetween input bytesand path
constraints; (ii)to formulate fuzzing processes (e.g., path transi-
tions) and build up probability distributions to optimize power
schedules, i.e.,the number of inputs generated per seed. However,
the former is subjective to the inference results which may include
extra bytes for a path constraint, thereby limiting the efficiency of
path constraints resolution, code coverage discovery, and bugs ex-
posure; the latter formalization, concentrating on power schedules
for seeds alone, is inattentive to the schedule for bytes in a seed.
Inthispaper,weproposealightweightfuzzingapproach,Truzz,
to optimize existing Coverage-guided Greybox Fuzzers (CGFs). To
address two aforementioned challenges, Truzz identifies the bytes
related to the validation checks (i.e., the checks guarding error-
handling code), and protects those bytes from being frequentlymutated, making most generated inputs examine the functional-ities of programs, in lieu of being rejected by validation checks.
The byte-wise relationship determination mitigates the problem
ofloadingextrabyteswhenfuzzersinferthebyte-constraintrela-
tion. Furthermore, the proposed path transition within Truzz can
efficiently prioritize the seed as the new path, harvesting many
newedges,andthenewpathlikelybelongstoacoderegionwith
manyundiscoveredcodelines.Toevaluateourapproach,weim-
plemented6state-of-the-artfuzzers,AFL,AFLFast,NEUZZ,MOPT,FuzzFactoryandGreyOne,inTruzz.Theexperimentalresultsshow
thatonaverage,Truzzcangenerate16.14%moreinputsflowing
intofunctionalcode,inadditionto24.75%morenewedgesthanthe
vanilla fuzzers. Finally, our approach exposes 13 bugs in 8 target
programs, and 6 of them have not been identified by the vanilla
fuzzers.
âˆ—Corresponding authors: Sheng Wen and Xiaogang Zhu
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
onthe firstpage.Copyrights forcomponentsof thisworkowned byothersthan the
author(s)mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,or
republish,topostonserversortoredistributetolists,requirespriorspecificpermission
and/or a fee. Request permissions from permissions@acm.org.
ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
Â© 2022 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ACM ISBN 978-1-4503-9221-1/22/05...$15.00
https://doi.org/10.1145/3510003.3510063CCS CONCEPTS
â€¢Security and privacy â†’Software security engineering ;â€¢
Fuzz Testing;
KEYWORDS
Fuzzing, Software Security, Path Transition, Mutation
ACM Reference Format:
Kunpeng Zhang, Xi Xiao, Xiaogang Zhu, Ruoxi Sun, Minhui Xue, and
ShengWen.2022.PathTransitionsTellMore:OptimizingFuzzingSchedules
viaRuntimeProgramStates.In 44thInternationalConferenceonSoftware
Engineering (ICSE â€™22), May 21â€“29, 2022, Pittsburgh, PA, USA. ACM, New
York, NY, USA, 11 pages. https://doi.org/10.1145/3510003.3510063
1 INTRODUCTION
Fuzzing is a widely-used technique to expose security issues in
software,andhasidentifiedthousandsofbugsandvulnerabilitiesin
real-world programs [ 7,11,22]. Coverage-guided Greybox Fuzzing
(CGF) is one of the most successful solutions in fuzzing [ 2,5,12,
20,27,39,41].CGFusuallymaintainsaninfiniteloop,wherenew
inputs are generated by mutating seeds. If a new input explores
new code coverage (e.g., new edges), the input will be retained as a
newseedandmutatedinfurtherrounds.Thisevolutionarysolution
effectively guides fuzzing towards exploring more code coverage.
Existing solutions to improve the efficiency of CGF are two-fold.
The first category intends to reduce search space of inputs [ 2,8,
12,20,27,31]. The state-of-the-art solution to reduce the input
space is to infer the relationships between the input bytes and the
path constraints [ 12,31],i.e.,the byte-constraint relation, which
significantly improves the possibility of resolving path constraints.
Forexample,aninputincludes8bytesbutonly1byteisrelatedtoa
constraint, if(x[5]==0xee) . If CGFs can infer the byte-constraint
relation,themutationcouldbefocusedontherelatedbyte, x[5],
only. As a result, instead of trying 2568new inputs, CGFs only
needtogenerateatmost 256newinputstoresolve theconstraint.
However,areal-worldprogramcouldbefarmorecomplicatedas
thebyte-constraintrelationcouldexistbetweenmultiplebytesand
multipledifferentconstraints,orevennested.Fromourexperience,
theexistinginferenceapproachescannotdistinguishbetweenthe
outerconditionandtheinnerconditionofanestedone.Forexample,
theinferredbytesarelikelyrelatedtoanentirenestedcondition
(e.g., if(x[5]==0xee) {if(x[6]==0xff) {...} } ).Thatis,when
the inference process intends to infer the related bytes for the
inner condition (i.e., x[6]), the result will erroneously include the
16582022 IEEE/ACM 44th International Conference on Software Engineering (ICSE)
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:32:16 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Kunpeng Zhang, et al.
bytesrelatedtotheentirecondition(i.e., x[5],x[6] ).Asaresult,
whenfuzzingintendstoresolvetheinnercondition,fuzzingmay
mutatethebyte x[5],whichwillalterthebranchofoutercondition.
Thus, the generated input will never reach the inner condition
if(x[6]==0xff) because the mutation of x[5]breaches the outer
condition.
On the other hand, another category of solutions optimizes
power schedule via formulating fuzzing processes [ 3â€“5,30,39].
Because CGFs aim to discover more code coverage, one state-of-
the-art solution to optimize power schedule is to model the path
transitionsasMarkovchain[ 5]orMulti-ArmedBandit[ 39].The
power schedule determines the number of mutations assigned to
eachseed.Anewinput ğ‘ /prime,whichexercisesthepath ğ‘ƒğ‘ /prime,isgenerated
by mutating a seed ğ‘ , which exercises the path ğ‘ƒğ‘ . Then, there is
a path transition between the path ğ‘ƒğ‘ andğ‘ƒğ‘ /prime. The models build
probability distributions of path transitions, and optimize power
schedule based on the distributions. A basic motivation is to assign
more power to seeds that are more likely to discover new cover-
age,i.e.,theypreferthepathtransitionsincludingnewpaths.For
example, based on Markov chain, AFLFast [ 5] prefers seeds that
exercise less frequent paths, i.e.,the seeds with lower transition
probabilities. However, the existing models only focus on power
schedule for seeds but ignore the power schedule for bytes. In fact,
the transitions contain more information of the execution states,
which can be utilized to optimize power schedule for bytes.
We observe that the differences between two execution paths
of a transition imply properties of programs under test (PUTs).
Specifically,ifapathtransitionresultsinasignificantlyshorterpath,thetransitionislikelyrelatedtoavalidationcheck.Inthisresearch,
wefollowthedefinitioninYou etal.[
37]:ifapathconstraintguards
error-handling code, then it is a validation check; otherwise, it is a
non-validation check. The execution paths that examine the error-
handlingcodeareusuallymuchshorterthanthepathsthatexamine
functional code. The reason lies in the fact that the error-handling
code usually leads to the termination of a program. As shown in
Fig.1,ifaninputfailsthe validationcheckI,theinputwillflowinto
theerror-handling code I, whose length is 10 edges. On the other
hand,if anotherinputpassesthe validationcheckI andvalidation
check II, the length of the execution path is at least 100 edges.
Moreover,ifapathtransitiondiscoversanexecutionpaththat
includesnewedges,itislikelytoexploreanundiscoveredregion.
Intuitively, more new edges covered in a path may lead us to more
undiscovereddescendantsasitmayhavetouchedmorenewcode
areas, so that we should focus more on such seeds that discovered
more new edges until they have been thoroughly tested. Consider-
ingthelimitedtimebudgetoffuzzingcampaigns,theprioritization
ofseedsthatexercisepathswithmoreundiscovereddescendantscanfurtherimprovetheefficiencyofcodediscovery.Weshowin
Fig.1thatifthenewedgesinthepath ğ´ğ¶ğ¹ğ½ğ¿ğ‘ areğ¶ğ¹,ğ¹ğ½,ğ½ğ¿,and
ğ¿ğ‘,theundiscoveredbasicblocksthatthepath ğ´ğ¶ğ¹ğ½ğ¿ğ‘ canreach
areğ¼,ğ¾,ğ‘€,ğ‘‚, andğ‘ƒ; on the other hand, if another path ğ´ğµğ·ğº
includes new edges ğµğ·andğ·ğº, the undiscovered basic block that
the path ğ´ğµğ·ğºcan reach is ğ». Therefore, the input that exercises
thenewpath ğ´ğ¶ğ¹ğ½ğ¿ğ‘ ismorelikelytoexplorelargerundiscovered
code regions.
In this paper, we propose a lightweight approach, Truzz,t o
improve the performance of CGFs. Different from other existing
Figure 1: An example of validation checks and code cover-age. The execution paths containing error-handling code islikely to be shorter than the paths of functionalities. As forcode coverage, a newly discovered path that includes morenewedgesislikelytohavemoreundiscovereddescendants.
CGFs,ourTruzzdeterminesthevalidation-relatedbyteswithout
complexstaticanalysisanddynamicanalysis.Concretely,Truzz
intendstoprotectbytesrelatedtovalidationchecks,andprioritizes
seeds that are more likely to explore larger new code regions. Itinfers the relations between input bytes and validation checks.Based on the aforementioned observation, if mutation of certainbytes results in exercising a significantly shorter path, then the
bytes are likely related to a validation check. In order to determine
sucharelationship,Truzzcomputesascalar,the fitness,foreach
byte,measuringhowlikelyabyteisrelatedtoavalidationcheck.
Based on the fitness score, Truzz then assigns lower mutationprobabilities to the validation-related bytes, locking them frombeing mutated. Furthermore, in order to prioritize seeds, Truzzranks each seed based on the number of newly discovered edges
when a seed is first retained. The top seed will be selected to be
mutated in the next fuzzing round.
The experimental results indicate that the integration of our
approach and the existing CGFs can further improve the perfor-
manceofCGFs.Ourapproachcanhelpmitigatetheaforementioned
problemoftheimpreciseinferenceofbyte-constraintrelations.It
focusesonthefinegranularityofbyteschedule,whichcanimprove
the performanceof coverage discovery.Meanwhile, our approach
steers computing resources towards functional code rather than
error-handlingcode.Duetothelimitedtimebudget,theSeedPri-
oritization in our approach further improves the performance of
power schedule.
We evaluate the performance of Truzz by applying it onto 6
state-of-the-artfuzzers, i.e.,NEUZZ[ 31],GreyOne [ 12],AFL [41],
1659
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:32:16 UTC from IEEE Xplore.  Restrictions apply. Path Transitions Tell More:
Optimizing Fuzzing Schedules via Runtime Program StatesICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
MOPT [21], FuzzFactory[ 23], and AFLFast [ 5], and conduct fuzz
testingon8targetprograms.Theexperimentalresultsshowthat
Truzz-equippedfuzzersdiscovermorecodecoverageandbugsthan
the vanilla fuzzers. We summarize our contributions as follows.
â€¢Wefirstpropose a lightweight generalized framework of byte
scheduleandSeedPrioritization,Truzz,toimprovetheperfor-
manceofCGFs,utilizingthedifferencesofpathsinpathtransi-
tions, as such differences can indicate properties of target pro-
grams,e.g.,the validation checks and the undiscovered code
regions.
â€¢Weevaluateourapproachwithrespecttovalidinputgeneration.
Theexperimentalresultsindicatethat,withthehelpof Truzz,
16.14% on average more inputs can pass the validation checks
and flow into functional code.
â€¢We implement our framework with 6 state-of-the-art fuzzers,
AFL,AFLFast,NEUZZ,MOPT,FuzzFactory,andGreyOne,and
comparetheperformancewithvanillafuzzers.Onaverage24.75%moreedgecoveragehasbeenidentified.Moreover,Truzz-equipped
fuzzers expose 13 bugs in 8 target programs, and 6 of them have
not been identified by the vanilla fuzzers.
2 RELATED WORK AND MOTIVATION
In this section, we introduce the related work of Coverage-guided
GreyboxFuzzing(CGF).Wethenattempttomotivateourapproach
by demonstrating the weaknesses of current CGFs.
2.1 Coverage-guided Greybox Fuzzing
ThebasicideaofCGFistoexploremorecodecoveragesothatitmay
triggerabughidingincertaincoderegions[ 1,13,19,25,35,38,43].
A general CGF has a seed corpus which contains the initial inputs
andâ€œinterestingâ€inputsthatareretainedfromthegeneratedinputs
during fuzzing. The initial inputs are usually manually created
according to the input specifications of PUTs or collected from the
Internet.Theâ€œinterestingâ€inputsaretheonesthattrytodiscover
new code coverage during fuzzing. Specifically, during each round
of fuzzing, CGF selects a seed from the seed corpus and generates
new inputs by performing mutations on the bytes in the seed [ 6,
9,15]. Most CGFs randomly select byte(s) to be mutated [ 5,41]o r
selectbyte(s)thatarerelatedtoacertainpathconstraint[ 8,12,31].
When a generated input discovers new code coverage (e.g., new
edges), CGF will retain the input as a new seed. The loop that
includesselection,mutation,andretentionensurestheeffectiveness
of code coverage discovery [5, 41, 42].
MostCGFsobtainthecoverageinformationviainstrumenting
a bitmap to indicate new edges. A bitmap is a compact vectorthat records the discovered edges in the current execution. Eachedge is assigned with an identifier which is also the index of the
bitmap. When an edge is examined, the corresponding element of
thebitmapwillincreasethevaluebyone.Asaresult,ifthevalueofanelementis0,thecorrespondingedgeisnotexamined;otherwise,
if the value of an element is non-zero, the corresponding edge is
examined.Therefore,anewedgeisdeterminedifthecorrespondingelementofthebitmaphasflippedfrom0tonon-zerointhecurrent
execution.
2.1.1 Path Constraints. A major roadrock of fuzzing efficiency im-
provement is the path constraints, especially the tight constraints,
Figure 2: Validation check. If an input fails the validationcheck, it will be trapped in the error-handling code.
such as if(x[5]==0xee) . Many fuzzers utilize symbolic execution
toresolvepathconstraints,butsufferfromsignificantlyslowexe-
cutionspeed[ 32,40].Becausethebytesrelatedtoapathconstraint
are usually a small portion of an input, some other fuzzers uti-lize taint analysis to build the relationships between input bytesand path constraints [
8,17,20,27,36]. Taint tracking can iden-
tify promising input bytes that affect programâ€™s certain opera-tions [
10,14,16,26,29,33]. When resolving a path constraint,
fuzzingonlyneedstomutatetherelatedbytessothattheyimprove
the efficiency of passing raodrocks. However, taint analysis stillintroduces high overhead that limits the improvement of perfor-
mance.T-Fuzz[ 24]utilizesprogramtransformationtoremovepath
checks so that fuzzing can explore deep code, but it requires many
engineering efforts to transform programs.
More lightweight approaches areproposed to resolve path con-
straints,whichinfertherelationshipsbetweeninputbytesandpath
constraints based on the changes of execution states [ 2,12,30,31].
Forinstance,NEUZZ[ 31]buildsupdeeplearningmodelsforthere-
lationships between input bytes and branch behaviors. The branch
behaviors indicate the execution states of satisfied or unsatisfiedpath constraints. The models have a high chance to include ex-
tra bytes for a certain path constraint because they approximately
build the relationships [ 31]. Similarly, the inference approach of
GreyOne [12]is that,if mutation ofa byteresults in changingthe
valueofavariable,thenthebyteisrelatedtothevariable.When
the variable is checked in a path constraint, the byte is also related
to the path constraint. However, the change of bytes related to the
outer conditions can also influence the value of variables relatedto the inner conditions (see Fig. 2). Therefore, the related bytesfor inner conditions will include extra bytes. Due to extra bytes,
fuzzing may mutate the bytes related to the outer condition, which
will alter the branch of outer condition, resulting in decreasing the
effectiveness of resolving the path constraint of inner condition.
2.1.2 Power Schedule Optimization. Another way to improve the
performance of CGF is to optimize fuzzing schedules via formulat-
ingfuzzingprocesses[ 3,5,21,39].ForgeneralCGFs(e.g., AFL[41]),
they assign almost the same energy for each seed. However, dif-ferent seeds have different potentials to discover new coverage.
Therefore, based on formulating fuzzing processes, CGFs [
5,39]
assignmoreenergytoseedsthataremorelikelytodiscovernew
1660
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:32:16 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Kunpeng Zhang, et al.
coverage.Aoptimizationforpowerscheduleisbasedontheformu-
lationofpathtransitions. CGFsbuildtheprobabilitydistributions
of path transitions via observing the result of each mutation. More
energy will be assigned to the seeds that have higher probabilities
to transition to an undiscovered path. However, they only focus on
the power schedule for seeds but ignore the schedule for bytes.
2.2 Motivating Example
Truzz improves the performance of CGFs based on the differences
between path transitions. In this section, we show an example that
motivates this research, i.e.,the requirement for the byte schedule.
As shown in Fig. 2, line 2 is a validation check because it guards
the error-handling code in line 8. In order to test the functional
code (lines 4 and 6), fuzzing has to satisfy the validation checkin line 2. On the other hand, if a seed has already satisfied the
condition in line 2, the later fuzzing campaigns should not mutate
the bytes related to the condition. Therefore, some state-of-the-art
fuzzers [12,30,31] improve the efficiency of resolving the path
constraints via inferringthe byte-constraint relation. Forexample,
the length of input in Fig. 2 is 5 bytes and a random mutation may
generate 2565new inputs and most of them will be rejected by the
validation check in line 2. However, if a fuzzer can infer that the
first byte is the only byte related to the constraint, it only needs at
most 256 mutations to bypass the constraint.
The problem is that the inference may include extra bytes for
a path constraint. The reason lies in the fact that the inference
reliesonthechangesofexecutionstates,andthechangesmaybe
explicitlyorimplicitlyinfluencedbycertainbytes.Forexample,the
constraint of line 3 in Fig. 2 is explicitly influenced by variable ğ‘
and implicitly influenced by variable ğ‘. Therefore, for both NEUZZ
and GreyOne, the bytes related to line 3 are ğ‘–ğ‘›ğ‘ğ‘¢ğ‘¡[0:4],i.e.,the
bytesrelatedtoboth ğ‘andğ‘.Asaresult,fuzzersmaymutatethe
byteğ‘–ğ‘›ğ‘ğ‘¢ğ‘¡[0]whenresolvingtheconstraintofline3,andgenerate
many inputs that examine the code error_handler() rather than the
functionalities.Therefore,inordertoexaminethefunctionalities,
the byteğ‘–ğ‘›ğ‘ğ‘¢ğ‘¡[0]that satisfies the check should not be mutated.
OurTruzzmitigatestheaforementionedproblemviaidentifying
the bytes related to validation checks based on path transition.
When Truzz mutates the related bytes, it will protect the bytes
related to the validation checks (e.g., the byte ğ‘–ğ‘›ğ‘ğ‘¢ğ‘¡[0]in Fig. 2).
Therefore,mostofthegeneratedinputsexaminethefunctionalcode
and avoid being trapped in the error-handling code. Meanwhile,
the path transitions are also utilized to prioritize seeds, which can
further improve the efficiency of CGFs.
3 METHODOLOGY OF TRUZZ
Motivated by the aforementioned observation that the differences
inpathtransitionsimplyinternalstatesofprograms,wedesignthe
Truzzasalightweightframeworktoimprovethecodecoverage
andefficiencyofCGFs.OurTruzzislightweightbecauseitdoes
not utilize complex taint analysis [ 8,20] to obtain related bytes
or approaches to pinpoint the error-handling code regions [ 18].
AsshowninFig.3,Truzzconsistsoftwocorecomponents,Byte
Analysis and Seed Prioritization.
TruzzperformsByteAnalysisoneachseedtoidentifythebytes
related to validation checks. It determines the validation-relatedbytesifmutation ofthosebytesresults insignificantlyshorterex-
ecutionpaths.Sincevalidation-relatedbytesaresparseininputs,
Truzzutilizesdichotomytoimprovetheefficiencyoftheprocess.
Note thatthe ByteAnalysis isonly performedonce foreach seed,
whichintroducessmalloverhead.Duringthemutationstage,the
validation-relatedbytesareprotectedsothatmostofthegenerated
inputsexaminethefunctionalcode,insteadofbeingrejectedbythe
validationchecks.Then,inSeedPrioritization,Truzzrankseach
seed when they are added to the seed corpus. The seeds with more
newly discovered edges are tagged with higher rankings, whichare utilized to prioritize seeds. The combination of Byte Analy-
sisandSeedPrioritizationintendstooptimizepowerschedulein
fuzzingviathebalanceofâ€œexploitation vs.exploration â€.ByteAnaly-
sisfocuses moreon theâ€œexploitation â€because itputs moreefforts
onfuzzingfunctionalitycode.Ontheotherhand,SeedPrioritiza-
tion intends to â€œexplore â€ because it prefers seeds that have more
potential to discover more code regions.
3.1 Byte Analysis
Inthisstage,Truzzbuildsupaprobabilitydistributionforinput
bytes, and selects bytes to be mutated based on the distribution.
The probabilities are gained based on the differences between two
executionpathsinapathtransition.Essentially,ifabyteismore
likely related to validation checks, the byte will be selected with
asmallerprobability.Asaresult,thevalidation-relatedbytesare
protected during fuzzing, and the generated inputs are more likely
to explore the functionalities of programs. Truzz first measureshow likely a byte is related to a validation check as a scalar, the
fitness, and further assigns a mutation probability to the byte.
3.1.1 Fitness for Bytes. In order to measure how likely a byte is
related to validation checks, Truzz first mutates each byte andcomputes the fitnessbased on the differences in the path transi-
tion.Equation1definesthefitness ğ‘“(ğ‘–,ğ‘š)fortheğ‘–ğ‘¡â„to(ğ‘–+ğ‘š)ğ‘¡â„
bytes. Specifically, let ğ‘ be a seed, and ğ‘ /primebe the generated input
obtainedbymutatingthe ğ‘–ğ‘¡â„to(ğ‘–+ğ‘š)ğ‘¡â„bytesoftheseed.Suppose
that the seed ğ‘ exercises the path ğ‘ƒğ‘ and the input ğ‘ /primeexercises the
pathğ‘ƒğ‘ /prime. Note that, a path consists of a set of edges in this context.
In the equation, ğ‘ƒğ‘ âˆ©ğ‘ƒğ‘ /primeis the subsetof edges that belong to both
pathsğ‘ƒğ‘ andğ‘ƒğ‘ /prime,and|âˆ—|presentsthenumberofedgesinaset.For
example, |ğ‘ƒğ‘ âˆ©ğ‘ƒğ‘ /prime|indicatesthenumberofedgesthatbelongtothe
intersection of paths ğ‘ƒğ‘ andğ‘ƒğ‘ /prime.
Recall that, if an input exercises an execution path that contain
error-handlingcode,thelength(i.e., thenumberofedges)maybe
significantly shorter than the path exercised by the corresponding
seed.InEquation1,|ğ‘ƒğ‘ |âˆ’|ğ‘ƒğ‘ /prime|
|ğ‘ƒğ‘ |indicateshowsignificantlythelength
of path has been shortened. Further,|ğ‘ƒğ‘ âˆ©ğ‘ƒğ‘ /prime|
|ğ‘ƒğ‘ |measures the inter-
section of the execution paths ğ‘ƒğ‘ andğ‘ƒğ‘ /prime,i.e.,the edges changed in
the path transition. The reason we not only consider the length of
paths is that, when the difference of length and the intersection of
paths are both small, the two paths will be quite different but have
similarlengths.Insuch(rare)cases,thebyteshavingbeenmutated
are more likely to be related to a validation check and the fitness
should be large. Therefore, Equation 1 measures the differences
inapathtransitionpertainingtothechangesofbothlengthand
1661
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:32:16 UTC from IEEE Xplore.  Restrictions apply. Path Transitions Tell More:
Optimizing Fuzzing Schedules via Runtime Program StatesICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
Figure 3: Overview of Truzz. Truzz ranks each seed and prioritizes seeds with higher ranks. When a seed is selected, Truzz
will perform Byte Analysis to identify the bytes related to validation checks. Then, during the mutation stage, it will avoid
mutating the protected bytes with a high probability.
individual edges.
ğ‘“(ğ‘–,ğ‘š)=â§âªâªâªâªâªâª â¨
âªâªâªâªâªâªâ©1
2Ã—[|ğ‘ƒğ‘ |âˆ’|ğ‘ƒğ‘ /prime|
|ğ‘ƒğ‘ |+(1âˆ’|ğ‘ƒğ‘ âˆ©ğ‘ƒğ‘ /prime|
|ğ‘ƒğ‘ |)]
=1âˆ’|ğ‘ƒğ‘ /prime|+|ğ‘ƒğ‘ âˆ©ğ‘ƒğ‘ /prime|
2|ğ‘ƒğ‘ |,|ğ‘ƒğ‘ |>|ğ‘ƒğ‘ /prime|
0, |ğ‘ƒğ‘ |â‰¤|ğ‘ƒğ‘ /prime|(1)
Here we take Fig. 1 as an example for computing fitnessğ‘“(ğ‘–,ğ‘š).
Suppose that a valid seed examines the functional code III and
explores ğ‘ƒğ‘ =20+60+40=120 edges. If mutating the ğ‘ğ‘¡â„byte of
theseedgeneratesaninputthatflowsinto error-handlingcodeII,
theinputexplores ğ‘ƒğ‘ /prime=20+10=30edges.BasedonEquation1,the
fitnessiscalculatedas ğ‘“(ğ‘,0)=1
2Ã—[120âˆ’30
120+(1âˆ’20
120)] â‰ˆ0.79.Ifwe
mutatethe ğ‘ğ‘¡â„to(ğ‘+ğ‘)ğ‘¡â„bytesandthegeneratedinputexamines
thefunctional code VI, the new input explores 20 +60+20=100
edges.Then,thefitnessis ğ‘“(ğ‘,ğ‘)=1
2Ã—[120âˆ’100
120+(1âˆ’80
120)]=0.25.
Thus, Truzz infers that the ğ‘ğ‘¡â„byte is more likely to be related to
validation checks than the ğ‘ğ‘¡â„to(ğ‘+ğ‘)ğ‘¡â„bytes.
3.1.2 Dichotomy for Byte Analysis. The calculation of fitness byte
by byte is time-consuming, especially when an input includes a
large number of bytes. Fortunately, validation checks are sparse
in programs, i.e.,only a small portion of input bytes are related to
validation checks. Most of the input bytes flow into the code of
functionalities. With this in mind, we utilize a dichotomy method
to improve the computing efficiency. If mutation of the bytes be-
longingtothecurrentsegmentresultsinafitnesslowerthanthe
threshold or the size of the segment is small enough, all bytes in
thesegmentaresettothesamefitness;otherwise,Truzzcontinues
the dichotomy until the validation-related bytes are identified.AsshowninAlgorithm1,Truzzfirstcreatesanarray ğ¹present-
ing thefitnessvalue for each byte (line 1) and initializes a set ğ·
with the left and right half intervals of a seed (lines 2-4). Then the
dichotomystarts.Duringtheloop,if ğ·isnotempty,Truzzobtains
anintervaldenotedbythestartingandendingindexes,mutatesthebytes,anddeterminesthepath
ğ‘ƒğ‘ /prime,whichiscoveredbythemutated
inputğ‘ /primevia the bitmap ğµ/prime(lines 5-9). With the paths ğ‘ƒğ‘ andğ‘ƒğ‘ /prime,
according to Equation 1, Truzz computes the fitnessfor bytes in
the current interval (line 10). If the ğ‘“ğ‘–ğ‘¡ğ‘›ğ‘’ğ‘ ğ‘ is smaller than a pre-
defined thresholdor the length ofthe current interval isless than
the predefined minimum length, all the bytes in the interval are
assigned with the value of ğ‘“ğ‘–ğ‘¡ğ‘›ğ‘’ğ‘ ğ‘ (lines 11-12). Otherwise, Truzz
continues the dichotomy by creating new intervals and appends
themintotheset ğ·(lines14-15).Consideringthatineachroundof
dichotomy, Truzz is able to handle at most half of the bytes within
one mutated input, so the assignment of fitness for bytes performs
in an efficient manner.
For example, as shown in Fig. 3, the seed for the target program
is03AC. During the stage of Byte Analysis, Truzz mutates the first
twobytes 03,andgeneratestheinput 3AAC.Becausetheexecution
pathsexercisedby 03ACand3AACdonotchange,Truzzassigns
fitnesstothefirsttwobytesas0,whichisdefinitelysmallerthan
the threshold. On the contrary, when mutating the other half bytes
AC, the execution path is significantly shorter and the fitnessvalue
is 0.83, which is larger than the threshold, so that the dichotomycontinues. Then, Truzz continues to split the bytes
ACinto two
halvesAandC. Finally, Truzz infers that the last byte Cis related
to the validation check. Based on dichotomy, Truzz only needs
toconductroughly2 Ã—ğ‘™ğ‘œğ‘”2(ğ‘)mutations,where ğ‘isthelength
of an input. Note that a larger threshold of fitness and a larger
1662
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:32:16 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Kunpeng Zhang, et al.
Algorithm 1: Dichotomy for Byte Analysis
Input:The current seed, ğ‘ . The path exercised by ğ‘ ,ğ‘ƒğ‘ . The minimum length
of interval, ğ‘™. The threshold of fitness, ğ‘¡.
Variables : A Bitmap that determines code coverage, ğµ. The start index of
an interval, ğ‘. The end index of an interval, ğ‘’. A set of (ğ‘,ğ‘’)
intervals, ğ·. The fitness, ğ‘“.
Output:An array of ğ‘“for each byte, ğ¹.
1ğ‘ ğ‘–ğ‘§ğ‘’â†length(ğ‘ )âˆ’1;
2ğ¹[0:ğ‘ ğ‘–ğ‘§ğ‘’]â†0;
3ğ·â†ğ·âˆª(0,ğ‘ ğ‘–ğ‘§ğ‘’/2);
4ğ·â†ğ·âˆª(ğ‘ ğ‘–ğ‘§ğ‘’/2+1,ğ‘ ğ‘–ğ‘§ğ‘’);
5whilehas_next(ğ·)do
6(ğ‘,ğ‘’)â†pop(ğ·);
7ğ‘ /primeâ†mutate_bytes(ğ‘ ,ğ‘,ğ‘’);
8ğµ/primeâ†execute(ğ‘ /prime);
9ğ‘ƒğ‘ /primeâ†get_path(ğµ/prime);
10ğ‘“â†calculate_fitness(ğ‘ƒğ‘ ,ğ‘ƒğ‘ /prime);
11ifğ‘“<ğ‘¡ğ‘œ ğ‘Ÿğ‘’âˆ’ğ‘<ğ‘™then
12 ğ¹[ğ‘:ğ‘’]â†ğ‘“;
13else
14 ğ·â†ğ·âˆª(ğ‘,(ğ‘+ğ‘’)/2);
15 ğ·â†ğ·âˆª((ğ‘+ğ‘’)/2+1,ğ‘’);
thresholdofintervalsizewillreducethecomputingcostbutlead
to a coarse-grained result.
3.1.3 Probability for Bytes Mutation. To protect bytes related to
validation checks, based on the fitness, Truzz decides whether a
byte can be mutated or not when generating a new input. The
purposeofassigningamutationprobabilitytoeachbyteistoavoid
mutatingthevalidation-relatedbyteswithahighprobability.Truzz
assigns the mutation probability according to Equation 2.
ğ‘(ğ‘–,ğ‘š)=ğ‘šğ‘ğ‘¥(1âˆ’ğ‘“(ğ‘–,ğ‘š),ğ¿ğ‘), (2)
whereğ‘“(ğ‘–,ğ‘š)isthefitnessofğ‘–ğ‘¡â„to(ğ‘–+ğ‘š)ğ‘¡â„bytes.Alargerfitness
of a byte will lead to a smaller probability to be mutated, so that
avalidation-relatedbytecouldbeprotectedfrommutation.Note
that we also set a lower bound of the probability ğ¿ğ‘to ensure that
fuzzingwillstillgenerateinputstofailthevalidationchecksand
cover the error-handling code, instead of ignoring it at all.
3.2 Seed Prioritization
Most CGFs sequentially select seeds to be mutated [ 2,5,20,27,30,
31,41],i.e.,they select seeds based on the order of the seeds added
to the seed corpus. However, seeds differ from their potential to
explore undiscovered code regions. Due to the limited time budget,
thisschememaymissopportunitiestodiscovermorecodecover-
age. In order to improve the efficiency of code discovery, Truzzheuristically determines the potential for each seed to discover
morecodecoverage.Intuitively,ifanewlydiscoveredpathincludes
more new edges, the path is likely to explore a code region withmore undiscovered code lines. That is, a new path that includes
more new edges has a higher chance to have more descendants of
undiscoveredblocks( e.g.,theblocks ğ¼,ğ¾,ğ‘€,ğ‘‚,ğ‘ƒ inFig.1).There-
fore, Truzz ranks each seed based on the number of new edgesin a newly discovered execution path. The larger the number ofnew edges, the higher priority to select the corresponding seed.
Note that, Truzz updates the rankings of each seed during fuzzingAlgorithm 2: Seed Prioritization
Input:Seed Corpus, ğ‘†. The number of mutations, ğ‘’ğ‘›ğ‘’ğ‘Ÿğ‘”ğ‘¦.
Variables : The number of new edges, ğ‘›. The number of new edges found
by mutating one seed, ğ‘›ğ‘ğ‘™ğ‘™. A set of (seed, # new_edges)
tuples,ğ‘€. A generated input, ğ‘–. A bitmap that tracks code
coverage, ğµ.
1ğµğ‘œğ‘£ğ‘’ğ‘Ÿğ‘ğ‘™ğ‘™â†âˆ…;
2forğ‘ âˆˆğ‘†do
3ğµâ†execute(ğ‘ );
4ğ‘›â†count_map(ğµ\(ğµğ‘œğ‘£ğ‘’ğ‘Ÿğ‘ğ‘™ğ‘™âˆ©ğµ));
5ifğ‘›>0then
6 ğ‘€â†ğ‘€âˆª(ğ‘ ,ğ‘›);
7ğµğ‘œğ‘£ğ‘’ğ‘Ÿğ‘ğ‘™ğ‘™â†ğµğ‘œğ‘£ğ‘’ğ‘Ÿğ‘ğ‘™ğ‘™âˆªğµ;
8ğ‘€â†sort(ğ‘€);
9whileğ‘‡ğ‘Ÿğ‘¢ğ‘’do
10ğ‘ â†select_seed(ğ‘€);
11ğ‘›ğ‘ğ‘™ğ‘™â†0;
12whileğ‘’ğ‘›ğ‘’ğ‘Ÿğ‘”ğ‘¦>0do
13 ğ‘–â†mutate(ğ‘ ); âŠ²Based on Byte Analysis
14 ğµ/primeâ†execute(ğ‘–);
15 ğ‘›/primeâ†count_map(ğµ/prime\(ğµğ‘œğ‘£ğ‘’ğ‘Ÿğ‘ğ‘™ğ‘™âˆ©ğµ/prime));
16 ifğ‘›/prime>0then
17 ğ‘€â†ğ‘€âˆª(ğ‘–,ğ‘›/prime);
18 ğ‘’ğ‘›ğ‘’ğ‘Ÿğ‘”ğ‘¦â†ğ‘’ğ‘›ğ‘’ğ‘Ÿğ‘”ğ‘¦âˆ’1;
19 ğµğ‘œğ‘£ğ‘’ğ‘Ÿğ‘ğ‘™ğ‘™â†ğµğ‘œğ‘£ğ‘’ğ‘Ÿğ‘ğ‘™ğ‘™âˆªğµ/prime;
20 ğ‘›ğ‘ğ‘™ğ‘™â†ğ‘›ğ‘ğ‘™ğ‘™+ğ‘›/prime;
21ğ‘€â†update(ğ‘ ,ğ‘› ğ‘ğ‘™ğ‘™);
22ğ‘€â†sort(ğ‘€);
campaigns. If a seed discovers only a few new edges after being
fuzzed many times, Truzz decreases the ranking of the seed.
AsshowninAlgorithm2,Truzzfirstperformsadryruntoassign
rankings for initial seeds (lines 1-8). The bitmap ğµğ‘œğ‘£ğ‘’ğ‘Ÿğ‘ğ‘™ğ‘™tracks all
history edge coverage, and is set to empty at the beginning (line
1). For all the initial seeds, Truzz tests all of them and adds the
seeds to the set ğ‘€if they discover new coverage (lines 2-6). Along
with the seed, the set ğ‘€also includes the number of new edges
discoveredbytheseed.Then, Truzzmergesthecurrentbitmap ğµ
intotheoverallbitmap ğµğ‘œğ‘£ğ‘’ğ‘Ÿğ‘ğ‘™ğ‘™(line7).Basedontherankingsof
seeds,Truzzselectsatopseedfromtheseedcorpus(line10).After
assigning the energy (i.e., the number of mutations) to the selected
seed(line12),Truzzmutatestheseedbasedonthe fitnesscomputed
inByteAnalysisphaseandgeneratesanewinput(line13).Afterthe
programisexecutedwiththenewinput,fuzzingcheckswhether
the corresponding bitmap has at least a non-zero element that has
never been covered before (lines 14-15). If so, Truzz counts thenumber of such non-zero elements, and retains the new input asa new seed (lines 16-17). Then, the energy decreases by one and
thecurrentbitmapismergedintotheoverallbitmap(lines18-19).
According to the number of new edges discovered by mutating the
seedğ‘ ,ğ‘›will be updated with ğ‘›ğ‘ğ‘™ğ‘™. Truzz sorts the seeds in the
seed corpus based on the number of new edges found (lines 22).
3.3 Application
OurapproachcanbeappliedtootherCGFswithoutmuchefforts.
Theimprovementisaddedtothestageswhenfuzzingselectsaseed
and when fuzzing selects a byte. The seed corpus is ordered based
on seed rankings so that other fuzzers select seeds from the topof the ordered sequence. Most CGFs randomly select bytes to be
mutated or select bytes that are related to certain path constraints.
1663
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:32:16 UTC from IEEE Xplore.  Restrictions apply. Path Transitions Tell More:
Optimizing Fuzzing Schedules via Runtime Program StatesICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
Table 1: Target programs.
Target Source file Input format Test instruction
tiff2bwlibtiff-4.0.9 tifftiff2bw @@1/dev/null
tiffsplit tiffsplit @@ /dev/null
nm
binutils-2.30 ELFnm -C @@
objdump objdump -D @@
readelf readelf -a @@
size size @@
strip strip -o tmp_file @@
djpeg libjpeg-9c jpeg djpeg @@
1@@:A placeholder indicating that the input is a file.
After other CGFs select a byte, our Truzz will accept or reject the
selectionbasedontheprobabilitydistributionsofbytes.Inorder
toobtaintheprobabilitydistributions,TruzzintegratesourByte
Analysisintothedeterministicstageifotherfuzzershavethestage.
This stage mutates seeds byte by byte based on the determined
mutation strategy. If a fuzzer does not perform the deterministic
stage, Truzz conducts a pre-mutation to obtain probabilities.
4 EVALUATION
In this section, we run experiments to verify the performance of
Truzz and to answer the following research questions:
â€¢RQ1:How effective is Byte Analysis to guide more generated
inputs flow into functional code?
â€¢RQ2:Towhatextentcanavoidingmutatingvalidation-related
bytes andhow can Seed Prioritizationimprove the efficiency of
fuzz testings?
â€¢RQ3:Howmanybugscanbe(uniquely)discoveredbythepro-
posed framework?
4.1 Experimental Setup
In order to evaluate our Truzz, we implemented Truzz with 6state-of-the-art fuzzers and compared the performance with the
correspondingvanillafuzzers.Specifically,weraneachfuzzeron
8target programsfor24 hours,and thenrepeatedthe experiment
for 5 times. All our measurements were performed on a system
runningUbuntu18.04withIntel(R)Xeon(R)Gold6230RCPUand
4 NVIDIA GeForce RTX 2080 Ti GPUs.
Benchmark Fuzzers. As mentioned earlier, we select 6 fuzzers to
evaluate our approach. NEUZZ [ 31] and GreyOne [ 12] are selected
becausetheyinferbyte-constraintrelationtoresolveconstraints.
We choose AFL [ 41] because it is a general CGF. We also choose
someextensionsofAFL.AFLFast[ 5]improvesAFLviaformulating
path transitions. MOPT [ 21] optimizes AFLâ€™s mutation operator
schedule. FuzzFactory [ 23] generalizes coverage-guided fuzzing to
domain-specific testing goals.
â€¢NEUZZmodelsrelationsbetweeninputbytesandbranchbehav-
iorsbyutilizingneuralnetworks.InordertoapplyByteAnalysis
to NEUZZ, Truzz (NEUZZ) performs a pre-mutation before the
mutation strategy proposed by NEUZZ.
â€¢GreyOneFTI utilizes a lightweight and sound fuzzing-driven
taint inference (FTI) to infer the relations between input bytesandvariablesinpathconstraints.WenamethefuzzerasGrey-
OneFTI because GreyOne does not release its code and we try
ourbesteffortstoimplementitscoreofFTI.Truzz(GreyOneFTI)
improves GreyOneFTI via protecting the bytes related to the
outer conditions.
â€¢AFL, the American Fuzzy Lop, is a widely-used CGF, which has
discovered many bugs in real-world applications. Truzz(AFL)
infers the validation-related bytes during its deterministic stage,
andselectsbytesbasedonthebyteprobabilitydistributionduring
its havoc stage.
â€¢AFLFast is developed based on AFL and optimizes power sched-
ule via formulating path transitions. As a result, AFLFast prefers
assigningmorecomputingresourcestothepathsthatareexer-
cisedwithlowfrequency.SimilartoTruzz(AFL),Truzz(AFLFast)
applies byte probability to select bytes.
â€¢MOPTutilizes Particle Swarm Optimization (PSO) algorithm
toachievemutationoperatorschedule.Truzz(MOPT)applies
Byte Analysis in all types of fuzzing modes to protect the bytes
relatedtovalidationchecks.wesettheparameter -Las60.MOPT
provides two types of pacemaker fuzzing modes and we choose
MOPT-AFL-tmp for the experiments.
â€¢FuzzFactory [23]savesintermediateinputsiftheymakeprogress
in domain-specific states. The implementation of Truzz (Fuz-
zFactory) is similar to that of Truzz (AFL).
TargetPrograms. WeevaluatedTruzzon8differentreal-world
programs (as shown in Table 1), which we adopted from the evalu-
ation of NEUZZ [ 31] and MOPT [ 21].nmlists the symbols from ob-
ject files. objdump displays informationabout object files. readelf
displaysinformationaboutELFformatobjectfiles. sizeliststhe
section sizes for each of the binary files. stripdiscards all sym-
bols from object files. djpegis a widely-used tool for handling
JPEGimagefiles. tiff2bw convertsacolorTIFFimagetogreyscale.
tiffsplit splits a multi-image TIFF into single-image TIFF files.
Initial Seeds. To make the comparison fair, we run each fuzzer
on each target application with the same initial seeds collected
fromtargetprogramâ€™stestsuiteandpublicseedcorpus(NEUZZ[ 31]
and MOPT[ 21]). NEUZZ is different from other fuzzers because
it requires an initial dataset. According to the setup described in
NEUZZ[ 31],werunAFLforanhourtocollectaninitialtraining
set(ğ‘‹,ğ‘Œ), whereğ‘‹is a set of input bytes and ğ‘Œrepresents the
correspondingedgecoveragebitmap.Theaveragesizeof8initial
training set is 1,005.
4.2 RQ1: Effectiveness of Byte Analysis
As described in the methodology, Truzz uses Byte Analysis to
identify bytes associated with validation checks. Then, we will mu-
tatethevalidation-relatedbytesmuchlessoftenthanotherbytes.
Therefore,TruzzreliesheavilyontheaccuracyofByteAnalysis.
As such, this subsection analyzes such accuracy of Truzzâ€™s Byte
Analysis.Wemanuallyanalyzefiveprogramsutilizedintheexperi-
menttomarkallerror-handlingpathsintheseprograms,including
nm,objdump,readelf,size, and strip. For the analysis methods,
we adopt the manual analysis method used by FIFUZZ [ 18]. We
scan the definition of each error function, and check whether it
can trigger an error by returning an error code or a null pointer.
Eachtimeamutatedinputisgeneratedandexecuted,wedetermine
1664
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:32:16 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Kunpeng Zhang, et al.
Table 2: Original vs. Truzz-equipped fuzzers on the percentage of valid input generated.
Program# of validation
checksNEUZZ Truzz (NEUZZ)1
Improvement of
Valid Ratio# of inputs generated Valid
Ratio# of inputs generated Valid
Ratio Valid2Invalid3Total Valid Invalid Total
nm 41 266,119 6,689,897 6,956,016 3.82% 2,531,141 4,424,875 6,956,016 36.38% 32.56%â†‘
objdump 46 537,032 6,566,985 7,104,017 7.55% 1,957,187 5,146,830 7,104,017 27.55% 20.00%â†‘
readelf 183 528,506 6,645,851 7,174,357 7.36% 866,535 6,307,822 7,174,357 12.07% 4.71%â†‘
size 11 543,830 6,396,120 6,939,950 7.83% 1,576,477 5,363,473 6,939,950 22.71% 14.88%â†‘
strip 150 460,160 6,783,308 7,243,468 6.35% 1,079,114 6,164,354 7,243,468 14.90% 8.55%â†‘
1Truzz (NEUZZ): an implementation of Truzz framework using NEUZZ as the fuzzer.
2Valid: indicates that the inputs pass all validation checks.
3Invalid: indicates that the inputs flow into error-handling code.
Figure 4: The edge coverage of different fuzzers running for 24 hours.
whether the input exercises the error-handling path and count the
numberofthosepathsduringfuzzing.Aninputisconsideredâ€œvalidâ€
ifitpassesallvalidationchecksandtriggersnoerror-handlingcode.
To avoid the impact of Seed Prioritization, we implement the
Truzz only with Byte Analysis in this experiment. Finally, we take
NEUZZandTruzz(NEUZZ)asanexampletoillustratetheaccuracyofByteAnalysis.InNEUZZâ€™smutationstrategy,itrandomlyselects500edgesandtakesthederivativeoftwoseedsforeachedge.Then
the gradient information obtained by derivation is recorded in the
gradient file. Finally, NEUZZ will mutate based on this gradient
file.Inordertoensurethefairnessoftheexperiment,1,000seeds
are randomly selected and the same model is used for both fuzzers.
Both NEUZZ and Truzz(NEUZZ) mutate inputs based on the samegradientfile,andbothofthemhavethesamenumberofmutations.
Wecalculatetheproportionofvalidinputsintheirgeneratedmu-
tated inputs, as shown in Table 2. Truzz(NEUZZ) generates onaverage 16.14% more valid samples than NEUZZ. Especially for
nmandobjdump, Truzz(NEUZZ) generates over 20% more valid
samples than NEUZZ.Answer to RQ1. Under the same experimental conditions,
Truzzcangeneratemorevalidsamplesthanthevanillafuzzers.
4.3 RQ2: Code Coverage Discovery
A bug is triggered only when the related code regions are explored.
Therefore, code coverage is an important metric for coverage-
guided fuzzers. We run two versions of fuzzers on eight programs
for 24 hours (repeated five times) and leverage AFLâ€™s afl-showmap
tool[41] to compute the code coverage. Then we compared the
average performance with respect to edge coverage. We first evalu-
ated the growth trend of edge coverage by two versions of fuzzers.
As shown in Fig. 4, Truzz-equipped fuzzers have a steady and
strongergrowthtrendonalltargetprogramsexceptfor tiff2bw
andtiffsplit . Note that, for NEUZZ, as there are 1,000 initial
seeds involved, the edge coverage at the starting point is much
higher than other fuzzers with only one initial seed.
Specifically,Truzz-equippedfuzzersachievebetternewedges
coverage, for most of the programs than the vanilla versions as
1665
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:32:16 UTC from IEEE Xplore.  Restrictions apply. Path Transitions Tell More:
Optimizing Fuzzing Schedules via Runtime Program StatesICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
Table 3: Original vs. Truzz-equipped fuzzers on the number of new edges found in 24 hours.
Program# of New Edges
AFLTruzzAFLFastTruzzNEUZZTruzzMOPTTruzzFuzzFactor yTruzzGreyoneFTITruzz
(AFL) (AFLFast) (NEUZZ) (MOPT) (FuzzFactory) (GreyoneFTI)
nm 3,6904,828(30.84% â†‘) 3,694 4,620(25.07% â†‘) 1,477 1,989(34.66% â†‘) 3,829 5,219(36.30% â†‘) 3,109 4,970(59.86% â†‘) 1,417 1,845(30.20% â†‘)
objdump 2,779 3,622(30.33% â†‘) 2,682 3,707(38.22% â†‘) 1,875 2,092(11.57% â†‘) 3,041 3,929(29.20% â†‘) 2,808 3,822(36.11% â†‘) 2,747 3,025(10.12% â†‘)
readelf 3,906 7,147(82.97% â†‘) 4,521 6,778(49.92% â†‘) 2,166 2,707(24.98% â†‘) 4,513 7,231(60.23% â†‘) 3,866 5,522(42.83% â†‘) 3,545 4,302(21.35% â†‘)
size 2,789 3,394(21.69% â†‘) 3,142 3,583(14.04% â†‘) 985 1,048(6.40% â†‘) 2,994 3,793(26.69% â†‘) 3,239 3,245(0.19% â†‘) 1,333 2,186(63.99% â†‘)
strip 3,821 5,444(42.48% â†‘) 4,140 5,086(22.85% â†‘) 2,804 2,861(2.03% â†‘) 4,270 5,989(40.26% â†‘) 3,620 5,331(47.27% â†‘) 2,961 4,360(47.25% â†‘)
libjpeg 2,122 3,145(48.21% â†‘) 2,808 3,240(15.38% â†‘) 755 844(11.79% â†‘) 2,862 3,254(13.70% â†‘) 1,384 1,602(15.75% â†‘) 1,000 1,031(3.10% â†‘)
tiff2bw 3,572 3,597(0.70% â†‘) 3,090 2,819(8.77% â†“) 1,098 1,192(8.56% â†‘) 3,582 3,627(1.26% â†‘) 2,017 2,168(7.49% â†‘) 1,212 1,674(38.12% â†‘)
tiffsplit 2,844 2,886(1.48% â†‘)2,592 2,545(1.81% â†“) 845 1,130(33.73% â†‘) 3,005 2,869(-4.53% â†“) 1,763 1,582(-10.27% â†“) 1,473 1,833(24.44% â†‘)
Table4:Thenumberofnewedgesfoundcomparedtovanilla
fuzzers in 12 hours.
Fuzzer Average Min. Max. Median
BA-equipped1NEUZZ +14.84% +8.06% +27.34% +12.79%
SP-equipped2NEUZZ +11.51% -2.97% +33.05% +8.63%
BA-equipped GreyOne +17.43% +1.72% +42.73% +17.96%
SP-equipped GreyOne +52.16% +13.91% +147.45% +42.07%
BA-equipped AFL +0.58% -0.77% +1.65% +0.71%
SP-equipped AFL +30.83% -3.95% +55.56% +40.44%
BA-equipped AFLFast -0.39% -4.06% +6.07% -0.7%
SP-equipped AFLFast +16.90% -16.51% +44.42% +18.29%
BA-equipped MOPT -1.20% -2.75% +1.67% -1.58%
SP-equipped MOPT +27.31% +1.03% +49.39% +31.47%
BA-equipped FuzzFactory -1.84% -4.50% +0.10% -1.82%
SP-equipped FuzzFactory +33.42% +16.69% +66.91% +26.74%
1BA-equipped: Use Byte Analysis to optimize the vanilla fuzzer only.
2SP-equipped: Use Seed Prioritization to optimize the vanilla fuzzer only.
Table 5: Results of Vargna and Delaneyâ€™s Ë†ğ´12scoring.
Program Truzz Truzz Truzz Truzz Truzz Truzz
(AFL) (AFLFast) (GreyOneFTI) (NEUZZ) (MOPT) (FuzzFactory)
nm 1.00 1.00 1.00 1.00 1.00 1.00
objdump 1.00 1.00 1.00 1.00 1.00 1.00
readelf 1.00 1.00 1.00 0.94 1.00 1.00
size 1.00 1.00 1.00 0.81 1.00 0.33
strip 1.00 1.00 1.00 0.66 1.00 1.00
libjpeg 1.00 0.94 1.00 0.69 1.00 1.00
tiff2bw 0.62 0.00 1.00 0.88 0.58 1.00
tiffsplit 0.73 0.42 1.00 1.00 0.13 0.00
shown in Table 3. On average, Truzz-equipped fuzzers discovered
24.75% more new edge coverage than vanilla fuzzers. For example,
Truzz(AFL)discoversmorethan20%edgesthanAFLin6target
programs. However, due to AFL and AFLFast do not infer the byte-
constraint relation, the reason why the code coverage decreases
in some cases is still not clear. To reveal a possible root cause,
we provide a case study in Section ??. It would be interesting to
ascertain the root cause in the future work.
We further evaluate the performance of Truzz using Vargha-
Delaney A Measurement [ 34], where Ë†ğ´12âˆˆ[0,1]denotes the mea-
sure ofstochastic superiority thatpopulation 1is superior topop-
ulation 2. If the two populations are equivalent, then Ë†ğ´12=0.5.
AnË†ğ´12largerthan0.5indicatesthatthepopulation1is stochasti-
cally larger than the population 2, and vice versa. For example, the
difference between Truzz-equipped fuzzer and vanilla fuzzer is de-
termined as (1) big when Ë†ğ´12â‰¥0.71; (2) medium when Ë†ğ´12â‰¥0.64;
and (3) small when Ë†ğ´12â‰¥0.56. Specifically, we test the numbers
ofnewedgesandpathcoveragecollectedfromthefiveroundsofexperiments by vanilla and Truzz-equipped fuzzers after 24 hours.
As shown in Table 5, the percentage of the results that Ë†ğ´12â‰¥0.71
is81.25%.Especially,70.83%oftheresultsachievethehighestscore
ofË†ğ´12=1.00. Therefore, we conclude that the difference in new
edgeandpathcoveragebetweenvanillafuzzerandTruzz-equipped
fuzzer is statistically large.
Further, We conducted separate experiments on Byte Analy-
sis and Seed Prioritization in Truzz, as shown in Table 4. Byte
Analysis equipped fuzzers (NEUZZ and GreyOne) and Seed Priori-
tization equipped fuzzers (all fuzzers) discovered 16.13 Â±10.25% and
28.68Â±25.85% more new edges than vanilla fuzzers, respectively.
The performance of Byte Analysis equipped AFL, AFLFast, MOPT,
and FuzzFactory does not improve much. We believe the reason is
that those fuzzers randomly select mutation positions, resulting in
a low selection probability of mutating validation-related bytes.
Inference-based fuzzers such as NEUZZ and Greyone will firstly
mutate interesting bytes(e.g., the bytes related to edges). However,
based on their inference strategy, validation-related bytes are often
consideredas"interesting".Ifvalidation-relatedbytesarenot pro-
tectedduringthemutationphase,mutatedinputswillflowintothe
error-handling code. Therefore, Byte Analysis is more suitable for
inference-basedfuzzers, i.e.,,thefuzzersthatinfertherelationships
between input bytes and path constraints.
Answer to RQ2. Truzz can significantly improve the cov-
eragediscovery(onaverage24.75%moreedgecoverage).In
44 out of 48 program-fuzzer pairs, Truzz-equipped fuzzers
achieve more code coverage than their vanilla fuzzers.
4.4 RQ3: Bug Discovery
We compare Truzz-equipped fuzzers with vanilla fuzzers in terms
of the number of real-world bugs.
WeuseGDBandafl-collect[ 28]toanalyzethenumberofbugs
discovered by a fuzzer. First, we use afl-collect to remove invalidcrash samples and achieve crash sample de-duplication. Second,
weuseGDBtomanuallyanalyzetheprogramlogicforeachbug,
removing bugs that have the same root cause. Table 6 shows the
number of unique bugs (accumulated in 5 runs) found in the eight
real-world applications.
In total, vanilla fuzzers and Truzz-equipped fuzzers find 10 and
13vulnerabilitiesinfourapplications,respectively.Intheremaining
four programs, all the fuzzers do not identify bugs in 24 hours.
Specially, stripis reported as vulnerable only by Truzz-equipped
fuzzers. For tiff2bw, it converts an RGB or Palette color TIFF
1666
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:32:16 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Kunpeng Zhang, et al.
Table6:Bugsdiscoveredbyvanillafuzzers(Orig.)andTruzz-
equipped fuzzers (Truzz(*)).
Program Vulnerability Type# of Vulnerabilities
Orig. Truzz(*)
readelf AbortSignal 1 1
sizeAbortSignal 1 0
DestAvNearNull 1 0
stripAbortSignal 0 1
DestAvNearNull 0 1
SourceAv 0 1
tiff2bwAccessViolation 2 1
BlockMoveAv 1 1BadInstruction 0 1SourceAv 2 3
HeapError 2 3
imagetoa greyscaleimageby combiningpercentagesofthe red,green, and blue channels. We discover 9 bugs in
tiff2bw.I nt h e
caseof readelf,wefoundonebugwhenitdisplaysinformation
fromanyELFformatobjectfile. stripdisplaysalistshowingall
architectures and objectformats available, and we identify3 bugs.
ForthethreeTruzz-missedbugs(twoin sizediscoveredbyAFL
and MOPT, and one in tiff2bwdiscovered by MOPT), we found
thattheexecutions peedsofMOPT(in sizeandtiff2bw)andAFL
insizedropped10%and13.55%,respectively,whichmayleadto
themissingofbugs.Further,therandomnessoffuzzingmayalso
contributetotheresults.Werepeatedexperiments5timesforeach
fuzzer, but the Truzz-missed bugs were only discovered by AFL or
MOPT in 1 trial.
Answer to RQ3. Truzz-equippedfuzzersoutperformtheir
vanilla fuzzers in terms of bug discovery, identifying 13 bugs
in 8 target programs and 6 of them cannot be identified by
vanilla fuzzers.
5 DISCUSSION
Complexity of programs. Our Truzz infers the relations be-
tween input bytes and validation checks, but the inference may
erroneouslyrecognizenon-validationchecksasvalidationchecks.
That is, Truzz may protect bytes that are related to non-validation
checks. However, our Truzz still allows fuzzing to examine the
â€œshorterâ€pathwithalowprobability, i.e.,thecoderegionsbelonging
to the â€œshorterâ€ path are still examined. One possible improvement
is to optimally switch between the vanilla strategy and our Byte
Analysis for selecting bytes. Anotherthreat to Truzz is that some
longerpathsmayhavesmallernumberofdescendants.Thus,the
priorities of some seeds may be erroneously assigned. Truzz miti-
gatesthisproblemviadecreasingtherankingsofseedsifmutations
of them do not identify more new edges.Overhead of exe cution speed.
Truzz will decrease the execu-
tion speed because it leads fuzzing to focus more on the execu-
tion of functionality code, which usually cost more computational
time than error-handling code. The execution speed of Byte Analy-
sisequippedGreyOneandNEUZZdroppedby23.55 Â±30.86%and
2.50Â±1.94%, separately. The execution speedofSeed Prioritizationequipped AFL and AFLFast dropped by 12.22% and 22.52%, respec-
tively.Specifically,theexecution speedofAFLFastdecreasedsig-
nificantlyon tiff2bwandtiffsplit (59.74%and38.47%,respec-
tively). This could be the reason why Truzz(AFLFast) discover less
newcoverage.Webelievethatsuchatrade-offisworthybecause
focusing on exploring functionality code will lead to more new
code coverage and bugs finding.Limitationsof Truzz.
Truzz has limitations in handling the sce-
narios that targeting input bytes that may take on a variety of con-
stants.Forexample,ifthe defaultbranchof switch-case branches
isanerror-handlingcode,ourTruzzcannotdistinguishbetween
differentcases.Thesituationcanbemitigatedbysettingahigher ğ¿ğ‘
in Equation (2). Another way to mitigate the situation is to involve
more seeds, which may cover different branches in a switch-case.
Our Truzz also has limitations when inferring bytes for checksum.
A slight change of checksum-related data will fail the check of
checksum,andTruzzwillavoidmutatingchecksum-relateddata.
This hinders the exploration of different data values for checksum.
As a future work, it is interesting to investigate on how to protect
a block of contiguous bytes and how to actively solve constraints.
6 CONCLUSION
Theinferenceapproachesmayincludeextrabytesthatbelongto
validation checks. This will reduce the performance of fuzzing and
assign too many computing resources to error-handling code. We
mitigate the problem by inferring the validation-related bytes and
protect the bytes from being frequently mutated. The inferenceis based on the observation that the difference of paths in pathtransitions imply the properties of programs. As a result, mostof the generated inputs will examine the functional code, in lieu
oferror-handlingcode.Thissolutionincreasestheprobabilityof
identifying more code coverage and bugs in functional code. We
designandimplementTruzzbasedonouridea,whichincreasesthe
probability of generating valid inputs, i.e.,the inputs that flow into
functionalcodeonly.Ourevaluationoneightopen-sourceprograms
showsthat Truzz-equipped fuzzerssignificantly outperformtheir
vanilla versions. We hope the optimization developed in this paper
could advance the coverage-guided greybox fuzzing domain.
DATA AVAILABILITY
Toenablereproducibility,weprovideareplicationpackagepublicly
available at https://github.com/truzz-fuzz/truzz-fuzz.
ACKNOWLEDGMENTS
ThisworkwassupportedinpartbytheNationalNaturalScience
FoundationofChina(61972219),theResearchandDevelopmentPro-gramofShenzhen(JCYJ20190813174403598,SGDX20190918101201696),theNationalKeyResearchandDevelopmentProgramofChina
(2018YFB1800601),andtheOverseasResearchCooperationFundof
Tsinghua Shenzhen International Graduate School (HW2021013).
REFERENCES
[1]Cornelius Aschermann, Tommaso Frassetto, Thorsten Holz, Patrick Jauernig,
Ahmad-Reza Sadeghi, and Daniel Teuchert. 2019. NAUTILUS: Fishing for Deep
Bugs with Grammars.. In NDSS.
1667
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:32:16 UTC from IEEE Xplore.  Restrictions apply. Path Transitions Tell More:
Optimizing Fuzzing Schedules via Runtime Program StatesICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
[2]Cornelius Aschermann, Sergej Schumilo, Tim Blazytko, Robert Gawlik, and
Thorsten Holz. 2019. REDQUEEN: Fuzzing with Input-to-State Correspondence..
InNDSS, Vol. 19. 1â€“15.
[3]Marcel BÃ¶hme, Valentin JM ManÃ¨s, and Sang Kil Cha. 2020. Boosting fuzzer
efficiency: An information theoretic perspective. In Proceedings of the 28th ACM
JointMeetingonEuropeanSoftwareEngineeringConferenceandSymposiumon
the Foundations of Software Engineering. 678â€“689.
[4]MarcelBÃ¶hme,Van-ThuanPham,Manh-DungNguyen,andAbhikRoychoud-
hury.2017. Directedgreyboxfuzzing.In TheACMConferenceonComputerand
Communications Security (CCS). ACM, 2329â€“2344.
[5]Marcel BÃ¶hme, Van-Thuan Pham, and Abhik Roychoudhury. 2017. Coverage-
basedgreyboxfuzzingasmarkovchain. IEEETransactionsonSoftwareEngineering
45, 5 (2017), 489â€“506.
[6]Sang Kil Cha, Maverick Woo, and David Brumley. 2015. Program-adaptive
mutational fuzzing. In 2015 IEEE Symposium on Security and Privacy. IEEE, 725â€“
741.
[7]OliverChang,JonathanMetzman,MaxMoroz,MartinBarbella,andAbhishek
Arya. 2016. OSS-Fuzz: Continuous Fuzzing for Open Source Software. https:
//github.com/google/oss-fuzz [Online; accessed 19-August-2021].
[8]Peng Chenand HaoChen. 2018. Angora: Efficientfuzzing byprincipled search.
In2018 IEEE Symposium on Security and Privacy (SP). IEEE, 711â€“725.
[9]DustinDuran,DavidWeston,andMattMiller.2011. Targetedtaintdrivenfuzzing
using software metrics. Proceedings of the CanSecWest (2011), 246â€“261.
[10]William Enck, Peter Gilbert, Seungyeop Han, Vasant Tendulkar, Byung-Gon
Chun, Landon P Cox, Jaeyeon Jung, Patrick McDaniel, and Anmol N Sheth. 2014.
Taintdroid:aninformation-flowtrackingsystemforrealtimeprivacymonitoring
on smartphones. ACM Transactions on Computer Systems (TOCS) 32, 2 (2014),
1â€“29.
[11]XiaotaoFeng,RuoxiSun,XiaogangZhu,MinhuiXue,ShengWen,DongxiLiu,
Surya Nepal, and Yang Xiang. 2021. Snipuzz: Black-box Fuzzing of IoT Firmware
via Message Snippet Inference. The ACM Conference on Computer and Communi-
cations Security (CCS), 337â€“350.
[12]ShuitaoGan,ChaoZhang,PengChen,BodongZhao,XiaojunQin,DongWu,and
ZuoningChen.2020. GREYONE:DataFlowSensitiveFuzzing.In 29thUSENIX
Security Symposium (USENIX Security 20). 2577â€“2594.
[13]ShuitaoGan,ChaoZhang,XiaojunQin,XuwenTu,KangLi,ZhongyuPei,and
ZuoningChen.2018. CollAFL:Pathsensitivefuzzing.In 2018IEEESymposium
on Security and Privacy (SP). IEEE, 679â€“696.
[14]VijayGanesh,TimLeek,andMartinRinard.2009. Taint-baseddirectedwhitebox
fuzzing. In 2009 IEEE 31st International Conference on Software Engineering. IEEE,
474â€“484.
[15]Google. 2021. Honggfuzz. https://github.com/google/honggfuzz Accessed:
11-December-2021.
[16]IstvanHaller,AsiaSlowinska,MatthiasNeugschwandtner,andHerbertBos.2013.
Dowsing for Overflows: A Guided Fuzzer to Find Buffer Boundary Violations. In
22nd USENIX Security Symposium (USENIX Security 13). 49â€“64.
[17]Vivek Jain, Sanjay Rawat, Cristiano Giuffrida, and Herbert Bos. 2018. TIFF:
using input type inference to improve fuzzing. In Proceedings of the 34th Annual
Computer Security Applications Conference. 505â€“517.
[18]Zu-Ming Jiang, Jia-Ju Bai, Kangjie Lu, and Shi-Min Hu. 2020. Fuzzing error
handlingcodeusingcontext-sensitivesoftwarefaultinjection.In 29thUSENIX
Security Symposium (USENIX Security 20). 2595â€“2612.
[19]Caroline Lemieux and Koushik Sen. 2018. Fairfuzz: A targeted mutation strategyforincreasinggreyboxfuzztestingcoverage.In Proceedingsofthe33rdACM/IEEE
International Conference on Automated Software Engineering. 475â€“485.
[20]Yuekang Li, Bihuan Chen, Mahinthan Chandramohan, Shang-Wei Lin, Yang Liu,
and Alwen Tiu. 2017. Steelix: program-state based binary fuzzing. In Proceedings
of the 2017 11th Joint Meeting on Foundations of Software Engineering. 627â€“637.
[21]ChenyangLyu,ShoulingJi,ChaoZhang,YuweiLi,Wei-HanLee,YuSong,and
Raheem Beyah. 2019. MOPT: Optimized mutation scheduling for fuzzers.In 28th
USENIX Security Symposium (USENIX Security 19). 1949â€“1966.
[22]Microsoft. 2021. OneFuzz: A self-hosted Fuzzing-As-A-Service platform. https:
//github.com/microsoft/onefuzz Accessed: 21-January-2021.[23]Rohan Padhye, Caroline Lemieux, Koushik Sen, Laurent Simon, and Hayawardh
Vijayakumar.2019. Fuzzfactory:domain-specificfuzzingwithwaypoints. Pro-
ceedings of the ACM on Programming Languages 3, OOPSLA (2019), 1â€“29.
[24]Hui Peng, Yan Shoshitaishvili, and Mathias Payer. 2018. T-Fuzz: fuzzing by
programtransformation.In 2018IEEESymposiumonSecurityandPrivacy(SP).
IEEE, 697â€“710.
[25]Van-Thuan Pham, Marcel BÃ¶hme, Andrew Edward Santosa, Alexandru Razvan
Caciulescu, and Abhik Roychoudhury. 2019. Smart greybox fuzzing. IEEE Trans-
actions on Software Engineering (2019).
[26]GeorgiosPortokalidis,AsiaSlowinska,andHerbertBos.2006. Argos:anemulator
for fingerprinting zero-day attacks for advertised honeypots with automatic
signaturegeneration. ACMSIGOPSOperatingSystemsReview 40,4(2006),15â€“27.
[27]Sanjay Rawat, Vivek Jain, Ashish Kumar, Lucian Cojocar, Cristiano Giuffrida,and Herbert Bos. 2017. VUzzer: Application-aware Evolutionary Fuzzing.. In
NDSS, Vol. 17. 1â€“14.
[28]rc0r. 2021. Utilities for automated crash sample processing and analysis. https:
//github.com/rc0r/afl-utils Accessed: 11-December-2021.
[29]DongdongShe,YizhengChen,AbhishekShah,BaishakhiRay,andSumanJana.
2020. Neutaint:Efficientdynamictaintanalysiswithneuralnetworks.In 2020
IEEE Symposium on Security and Privacy (SP). IEEE, 1527â€“1543.
[30]Dongdong She, Rahul Krishna, Lu Yan, Suman Jana, and Baishakhi Ray. 2020.MTFuzz: fuzzing with a multi-task neural network. In Proceedings of the 28th
ACM Joint Meeting on European Software Engineering Conference and Symposium
on the Foundations of Software Engineering. 737â€“749.
[31]DongdongShe,KexinPei,DaveEpstein,JunfengYang,BaishakhiRay,andSuman
Jana.2019. NEUZZ:Efficientfuzzingwithneuralprogramsmoothing.In 2019
IEEE Symposium on Security and Privacy (SP). IEEE, 803â€“817.
[32]NickStephens,JohnGrosen,ChristopherSalls,AndrewDutcher,RuoyuWang,
Jacopo Corbetta, Yan Shoshitaishvili, Christopher Kruegel, and Giovanni Vigna.
2016. Driller:AugmentingFuzzingThroughSelectiveSymbolicExecution..In
NDSS, Vol. 16. 1â€“16.
[33]Mingshen Sun, Tao Wei, and John CS Lui. 2016. Taintart: A practical multi-level
information-flow tracking system for android runtime. In Proceedings of the 2016
ACM SIGSAC Conference on Computer and Communications Security. 331â€“342.
[34]AndrÃ¡s Vargha and Harold D Delaney. 2000. A critique and improvement of
the CL common language effect size statistics of McGraw and Wong. Journal of
Educational and Behavioral Statistics 25, 2 (2000), 101â€“132.
[35]Junjie Wang, Bihuan Chen, Lei Wei, and Yang Liu. 2019. Superion: Grammar-
aware greybox fuzzing. In 2019 IEEE/ACM 41st InternationalConference on Soft-
ware Engineering (ICSE). IEEE, 724â€“735.
[36] Tielei Wang,TaoWei,GuofeiGu,and WeiZou.2010. TaintScope: Achecksum-
aware directed fuzzing tool for automatic software vulnerability detection. In
2010 IEEE Symposium on Security and Privacy. IEEE, 497â€“512.
[37]WeiYou,XueqiangWang,ShiqingMa,JianjunHuang,XiangyuZhang,XiaoFeng
Wang,andBinLiang.2019. Profuzzer:On-the-flyinputtypeprobingforbetter
zero-dayvulnerabilitydiscovery.In 2019IEEESymposiumonSecurityandPrivacy
(SP). IEEE, 769â€“786.
[38]TaiYue,YongTang,BoYu,PengfeiWang,andEnzeWang.2019.Learnafl:Greybox
fuzzing with knowledge enhancement. IEEE Access 7 (2019), 117029â€“117043.
[39]Tai Yue, Pengfei Wang, Yong Tang, Enze Wang, Bo Yu, Kai Lu, and Xu Zhou.2020. EcoFuzz: Adaptive Energy-Saving Greybox Fuzzing as a Variant of the
AdversarialMulti-ArmedBandit.In 29thUSENIXSecuritySymposium.USENIX
Association, Boston, MA, 1â€“18.
[40]Insu Yun, Sangho Lee, Meng Xu, Yeongjin Jang, and Taesoo Kim. 2018. QSYM: A
practicalconcolicexecutionenginetailoredforhybridfuzzing.In 27thUSENIX
Security Symposium (USENIX Security 18). 745â€“761.
[41]MichaÅ‚Zalewski.2021. AFL(americanfuzzylop). https://github.com/google/AFL
accessed 21-January-2021.
[42]Xiaogang Zhu and Marcel BÃ¶hme. 2021. Regression Greybox Fuzzing. In Pro-
ceedings ofthe 28thACM Conferenceon Computerand CommunicationsSecurity
(CCS). 2169â€“2182.
[43]XiaogangZhu,XiaotaoFeng, XiaozhuMeng,ShengWen, SeyitCamtepe,Yang
Xiang, and Kui Ren. 2020. CSI-Fuzz: Full-speed Edge Tracing Using Coverage
SensitiveInstrumentation. IEEETransactionsonDependableandSecureComputing
(2020), 1â€“12.
1668
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:32:16 UTC from IEEE Xplore.  Restrictions apply. 