Datalog-Based Language-Agnostic Change Impact
Analysis for Microservices
Qingkai Shi1, Xiaoheng Xie2, Xianjin Fu2, Peng Di2, Huawei Li3, Ang Zhou2, Gang Fan2
1The State Key Laboratory for Novel Software Technology, Nanjing University, Nanjing, China
2Ant Group, Hangzhou, China3Alibaba Inc., Hangzhou, China
qingkaishi@nju.edu.cn, {xiexie, fuxianjin.fxj, dipeng.dp, zhouang.za, fangang }@antgroup.com, huawei.lihw@alibaba-inc.com
Abstract —The shift-left principle in the industry requires us
to test a software application as early as possible. In particular,
when code changes in a microservice application are committed
to the code repository, we have to efficiently identify all public
microservice interfaces affected by the changes so that the
impacted interfaces can be tested as soon as possible. However,
developing an efficient change impact analysis is extremely
challenging in microservices due to the multilingual problem:
microservice applications are often implemented using varying
programming languages and involve diverse frameworks and
configuration files. To address this issue, this paper presents
MICROSCOPE , a language-agnostic change impact analysis that
uniformly represents code, configuration files, frameworks, and
code changes by relational Datalog rules. M ICROSCOPE then
benefits from an efficient Datalog solver to identify impacted
interfaces. Experiments based on the use of M ICROSCOPE in
Ant Group, a leading software vendor, demonstrate that M I-
CROSCOPE is both effective and fast, as it successfully identifies
interfaces affected by 112 code commits, with moderate time
overhead, and could reduce 97% of interfaces to test and save
73% of testing time after code changes.
Index Terms —change impact analysis, Datalog-based analysis,
microservices
I. I NTRODUCTION
The microservice architecture has experienced a steady in-
crease in popularity in recent years. In a real-world production
environment, multiple microservices interact as a cohesive
system, each responsible for a specific and well-defined func-
tionality. This development model enables software devel-
opers to focus on realizing the requirements of individual
microservices independently from each other. However, the
increased complexity of the interaction among microservices
has concurrently escalated the potential for the introduction of
bugs. The inherent dynamism of microservices-based systems,
which are continuously modified and deployed to adapt to
evolving business requirements or to address bugs, creates
an environment prone to significant disruptions. Recent re-
ports indicate that changes are a major cause of incidents,
with approximately 50% at China Guangfa Bank [1], 54%
at Baidu [2], and 70% at Google [3] being change-related.
Further evidence from 2022 indicates that 55% of online
incidents were due to code changes [4], underscoring the
impact of system modifications.
This work was partially supported by Ant Group. Peng Di and Gang Fan
are the corresponding authors.To deal with the dynamism of microservices and avoid
bugs introduced by code changes, change impact analysis
(CIA) [5], [6] is widely used throughout the software industry
to assess the potential impact of code changes. However,
a few significant challenges affect the deployment of CIA
for microservice applications. On the one hand, the first
major challenge is the multilingual problem ( Challenge 1 ).
Specifically, microservices are often implemented in diverse
programming and configuration languages, and on top of
varying programming frameworks, which are hard to describe
uniformly. While there have been a few existing works on
CIA, e.g., [7]–[9], they often work for a single programming
language or framework, thus falling short of addressing the
multilingual problem.
On the other hand, an additional complication is presented
by the shift-left principle in the industry, which induces
performance-related issues ( Challenge 2 ). That is, the shift-
left principle in the industry requires us to test a software
application as early as possible. As such, we have to identify
the impact of code changes early so that the impacted software
components can be tested as soon as the changes are made.
The substantial program size of microservices in the industry
poses significant challenges for the CIA, complicating the task
of conducting analyses within a reasonable time frame while
upholding the shift-left strategy.
This paper presents a Datalog-based CIA for microservice
applications in response to these challenges. Our key insight
is that code elements, such as classes, interfaces, functions,
expressions, and their relationships, can be uniformly repre-
sented via relational data models, regardless of what specific
programming or configuration languages are used. As such,
our approach, agnostic to specific languages via a layer of rela-
tional data abstraction, is devised based on Datalog techniques
to adeptly maneuver the complexities of identifying change-
impacted microservice interfaces. Particularly, our approach
has two promising features. First, we suggest a uniform
Datalog-based representation that standardizes how different
languages or frameworks are interpreted, thereby mitigating
Challenge 1. Second, the Datalog-based representation allows
us to benefit from modern Datalog solvers to deal with
industrial-sized microservices, exhibiting a high efficiency to
identify change impacts and alleviating Challenge 2.Our approach to CIA has been implemented as a tool named
MICROSCOPE , which currently supports microservices written
innine programming or configuration languages, including
Java, XML, JavaScript/TypeScript, Go, C/C++, Python, Swift,
SQL, and Properties. This tool automatically parses microser-
vices’ source code and configuration files into uniform Datalog
representations. When a developer commits code changes
into the code repository, M ICROSCOPE automatically iden-
tifies the changes and translates the changes into Datalog
representations, too. M ICROSCOPE then invokes a Datalog
solver, namely Souffle [10], to identify the interfaces impacted
by code changes. We evaluated M ICROSCOPE using real-
world code changes from both the open-source community
and Ant Group, a leading software vendor. For each commit,
MICROSCOPE can identify the impacted interfaces using only
1/4 of the time for building (or compiling) a microservice
project. Among 112 examined commits, M ICROSCOPE con-
firmed the code changes influenced 338 (3%) out of 11,458
interfaces used in upstream or downstream applications, with
manageable false positive and negative rates (17% and 6%).
In contrast, we may miss 4 ×impacted interfaces even if we
remove the support for only one language. These results un-
derscore M ICROSCOPE ’s effectiveness and the importance of
addressing the multi-lingual problem in real-world scenarios.
In conclusion, this paper makes the following contributions:
•We introduce a Datalog-based CIA approach that is
language-agnostic and adaptable to the evolving needs
of different projects.
•We implement the Datalog-based approach as a tool,
namely M ICROSCOPE , which supports nine languages
and has been made publicly available.1
•We extensively evaluate our approach in a real and indus-
try setting, demonstrating the efficiency and effectiveness
of the tool, M ICROSCOPE .
II. M OTIVATION AND OVERVIEW
This section presents the background of microservices,
motivates the problem of identifying change impacts, and pro-
vides an overview of our approach with an example simplified
from a real and severe change-related vulnerability.
A. Necessity of CIA in Industry
Recent reports indicate that code changes are a major
cause of incidents, with approximately 50% at China Guangfa
Bank [1], 54% at Baidu [2], and 70% at Google [3] being
change-related, causing security issues such as Broken Ob-
ject Level Authorization and Excessive Data Exposure, two
OWASP Top 10 API security issues [11]. These statistics
underscore the importance of CIA in industrial settings, but we
often encounter difficulties managing large, complex systems
that constantly change. The difficulties are even amplified
within microservices, which feature a high degree of inter-
service communication and dependency.
1https://github.com/codefuse-ai/CodeFuse-Query.To ensure software quality after code changes, running the
entire test suite after every code change is inefficient, let alone
when the changes are frequent. CIA allows us to determine
the interfaces impacted by code changes, allowing software
engineers to selectively execute tests covering these interfaces.
Undoubtedly, such a selective test execution will save consid-
erable time and resources. According to our evaluation, as
change-related interfaces only account for 3% of the total
interfaces, we can save 97% of testing efforts in terms of
reducing the number of interfaces to test and save 73% of
testing time on average every time code changes happen.
B. Motivating Example
Microservice is a software architecture that decomposes
an application into small and self-contained services. Each
microservice is developed, deployed, and maintained inde-
pendently. In practice, microservices are typically deployed
in separate containers, with communication occurring through
lightweight mechanisms such as remote procedural calls. Such
communications can be viewed as a series of invocations
between the caller and callee services, where the caller service
relies on the functionality offered by the callee to achieve
certain objectives. In this paper, we formulate microservices
and service interfaces as follows.
Definition 1: (Microservice) A microservice is denoted by
(V, E ), where Vis a set of functions in the service, and E
contains the caller-callee relationship over V.
Definition 2: (Service Interface) An interface of a microser-
vice (V, E )is a function f∈Vpublished to and invoked by
clients or other microservices.
Given the distributed and interconnected nature of mi-
croservice applications, changes within one service can ripple
across the entire system, causing significant consequences
as evidenced by a recent report [4]. For example, the one-
line code change discussed below leads to the inconsistency
between the front end (client) and the back end (server) of
Alipay, a mobile app from Ant Group. The inconsistency has
caused Alipay to crash and affect over 20 million users.
Basically, this microservice application manages the infor-
mation of clients and bills from an e-commerce website. Fig-
ure 1 shows a few source code files, including four program-
ming or configuration languages, i.e., Java, XML, Javascript,
and Typescript. The green and boxed line in Figure 1(a)
indicates the one-line code change that adds a phone-number
field into the Java class ClientInfo .
The code snippets can be segregated into two sections:
the back and the front ends. The back end comprises
ClientInfo ,BillInfo ,BillFacade , and service.xml . They
manage server-side operations, including client data manage-
ment, bill data management, and system configuration. On the
other side, the front end, i.e., the client app, includes proxy.js
andgenericOrder.ts . The former facilitates the communica-
tion between the front-end and the back-end components. The
latter implements client-side business logic. Let us discuss a
bit more about what the six files do.•The Java classes, ClientInfo and BillInfo in Fig-
ures 1(a) and 1(b), encapsulate a customer’s profile data
(id, name, and phone number) and the billing details.
•The Java interface, BillFacade in Figure 1(c), is a public
interface that allows clients to retrieve BillInfo via a
method, namely load .
•The configuration file, service.xml in Figure 1(d), pub-
lishes the interface com.store.BillFacade , i.e., the Java
interface in (c), to clients such that a client can invoke
its methods via a remote procedure call.
•The Javascript, proxy.js in Figure 1(e), is a client-side
configuration file. Line 19 declares a remote object named
billFacade , which is of the type com.store.BillFacade
and can be used in the application named OrderCenter .
•The Typescript, order.ts in Figure 1(f), implements a
front-end function in the application OrderCenter . Line
24 invokes a remote method load via the remote object
billFacade .
When upgrading the microservice, developers implement
the one-line change in Figure 1(a), which restructures the
client information. However, developers fail to recognize that
this change will affect the front end, i.e., the function invoca-
tion in Figure 1(f), which queries a client’s order information
but does not provide the phone number as a query condition.
Consequently, this inconsistency crashes the microservice app
and affects 20 million users.
It is challenging to identify such inconsistencies in mi-
croservices manually. Dependencies among functions are often
implicitly encoded, e.g., via configuration files, and involve
multiple languages. Overlooking any single dependency may
cause significant issues, such as in the case of the motivating
example. Unfortunately, few existing techniques can automati-
cally analyze such implicit and cross-language change impacts,
which is the problem this paper aims to address. In short, we
state the problem to address as below.
Given a code change in microservices, identify the serv-
ice interfaces (see Definition 2) impacted by the change.
C. Microscope in a Nutshell
Our key idea is to provide a language-agnostic layer over
programs in different languages, such that we have a uniform
representation to ease program analysis. As shown in Figure 2,
the first step is to build such a layer using a Datalog-
style representation, which we refer to as the code facts and
the change facts. We then define Datalog rules to establish
relationships among these facts. Finally, a Datalog engine
infers service interfaces impacted by changes.
1) Notations: We use a predicate in the form of predicate(x,
y, . . . ), where black letters in the Times New Roman font, x,
and y, are formal parameters, to describe a dataset satisfying
the relationship named predicate. Datalog facts are instantiated
predicates, e.g., predicate( a,b, . . . ) where red letters in the
typewriter font, aand b, are string or numeric constants,
1.public class ClientInfo {
2. private Integer id;
3. private String name;
4. + private String phoneNumber;
5. }(a) ClientInfo.java
6.public class BillInfo {
7. private ClientInfo clientInfo;
8. private BillData billData;
9. ...
10.} (b) BillInfo.java
11. interface BillFacade {
12. BillInfo load(BillRequest request);
13. }
(c) BillFacade.java
14. <sofa:service
15. interface=“com.store.BillFacade” >
16. </sofa:service> (d) service.xml
17. { appname: /quotesingle.ts1OrderCenter /quotesingle.ts1,
18. api: {
19. billFacade: /quotesingle.ts1com.store.BillFacade /quotesingle.ts1
20. }
21. }
(e) proxy.js
22. function queryOrder(orderId:any,
23. context:any): any {
24. return billFacade.load(
25. {context.userId, orderId}));
26. } (f) order.ts
Fig. 1: Motivating example.
representing a concrete entry in the dataset. For instance, we
can use parent(x, y) and grandparent(x, y) to describe the
parent-child and grandparent-grandchild relationships between
x and y, respectively. The fact, parent( Alice ,Bob), says that
Alice is a parent of Bob.
Datalog rules state how we deduce new facts from known
facts. For example, a Datalog rule in the form of grandpar-
ent(x, y) :- parent(x, z) parent(z, y) means that if x is a parent
of z and z is a parent of y, then x is a grandparent of y. Given
all parent-child facts, this rule returns all (x, y) satisfying
the grandparent-grandchild relationship. For instance, if we
have two facts, parent( Alice ,Bob) and parent( Bob,Charlie ),
this rule deduces a new fact grandparent( Alice ,Charlie ) to
describe their grandparent-grandchild relationship.
2) Code Facts: As the first step, M ICROSCOPE translates
all source files in Figure 1 into Datalog facts. The code in
Figure 1(a) is translated into three facts:
1) field( Integer ,id,ClientInfo ,(a):2:2 );
2) field( String ,name ,ClientInfo ,(a):3:3 );
3) field( String ,phoneNumber ,ClientInfo ,(a):4:4 ).
Each of Facts 1-3 describes a class field, including its type
and name, as well as the class where the field is declared. The
last argument of these facts is the location where a field is
declared, including the source file, the start line number, and
the end line number. Similarly, we can translate the Java code
in Figures 1(b), 1(c), and 1(d) into the following facts. Facts
4-5 are similar to Facts 1-3. Fact 6 describes a function named
load in the class BillFacade . Its return type is BillInfo . We
omit the function parameters to ease the explanation. Fact 7
is extracted from the XML file, which states the elements and
attributes in the XML file:
4) field( ClientInfo ,clientInfo ,BillInfo ,(b):7:7 );
5) field( BillData ,billData ,BillInfo ,(b):8:8 );
6) function( BillInfo ,load ,BillFacade ,(c):12:12 );
7) xml attr(interface ,BillFacade ,sofa:service ,
aaaaaaa (d):15:15 ).
While Facts 1-7 are extracted from the back-end code,
the following are from the front end, i.e., (e) and (f) in
Figure 1. Fact 8 is from Figure 1(e), describing the key-
value pairs in the JS file, i.e., the remote object billFacadeTABLE I: Relationship rules for the motivating example.
imp field(fname, cname) :- change(loc) field( , fname, cname, floc) in(floc, loc)
imp class(cname) :- imp field(fname, cname)
imp class(cname) :- imp class(fclass) field(fclass, fname, cname, )
imp function(fname, cname) :- imp class(fclass, ) function(fclass, fname, cname, )
pub function(fname, cname) :- xml attr(interface , cname, sofa:service ,) function( , fname, cname, )
reffunction(callee, refclass, loc) :- call(ref, callee, caller, loc) function( , caller, app, ) api(ref, refclass, app, )
ciaresult(callee, refclass, loc) :- imp function(callee, refclass) pub function(callee, refclass) ref function(callee, refclass, loc)
and its class BillFacade that can be used in the front-end
app OrderCenter . Facts 9-10 are extracted from (f). Fact 9
says that there is a function named queryOrder returning a
BillInfo in the app OrderCenter . Fact 10 describes a call
expression invoked by the remote object billFacade .
8) api( billFacade ,BillFacade ,OrderCenter ,(e):18:19 );
9) function( BillInfo ,queryOrder ,OrderCenter ,
aaaaaaa (f):22:26 );
10) call( billFacade ,load ,queryOrder ,(f):24:25 ).
3) Change Facts: The fact of code changes is straight-
forward, describing which line in a file is changed, i.e.,
change( (a):4:4 ) — line 4 in Figure 1(a) is changed. The
next section will discuss more details about change facts.
Note that we focus on code changes in both source code and
configuration files. Changes not in the code are out of the
scope of this paper.
4) Relationship Rules: We establish the Datalog rules in
Table I to build the relationships among these facts. The
rules are general for different microservices and are not
changed once defined. They can be divided into four parts:
identifying functions impacted by code changes, identifying
functions published to clients, identifying functions referenced
by clients, and finding the final solution of CIA.
(i) Identifying Impacted Functions. The first four rules in
Table I find the fields, classes, and functions impacted by
the code change. The first rule identifies a field impacted
by code changes. It says that, given a code change like
change( (a):4:4 ), if a field is in the same location, the code
change impacts the field. In the rules, the underscore symbol is
an argument that a rule does not care about, and in(loc 1, loc 2)
is an auxiliary predicate that checks if two locations overlap.
The 2nd rule states that a class is impacted by code changes
if the class contains an impacted field. The 3rd rule recursively
finds classes impacted by code changes. For example, since
the class BillInfo in Figure 1(b) contains a field of class
ClientInfo , which contains a change-impacted field, the class
BillInfo is also impacted by the changes. The 4th rule
identifies change-impacted functions, which use an impacted
class as the return type. The predicate imp function(fname,
cname) includes the function name, i.e., fname, and the class
where the function is declared, i.e., cname.
(ii) Identifying Published Functions. The motivating exam-
ple uses SOFAStack [12] as the microservice framework,
which publishes a function to clients via an XML file likeFigure 1(d). The fifth rule in Table I defines the published
functions. It states that a published function is in a Java class
declared in the XML attribute interface of the XML element
named sofa:service . Due to Fact 7, this rule yields that all
functions in the class BillFacade are published and can be
invoked by clients. Since Fact 6 indicates that the function
load is in the class BillFacade , it is a published function.
(iii) Identifying Referenced Functions. As discussed, Fig-
ure 1(e) defines a remote object, billFacade of class
BillFacade . The client app OrderCenter can use it to invoke
a remote function. Figure 1(f) is a function in the client
app that uses the remote object, billFacade , and invokes the
remote function named load . As such, we identify functions
referenced by the client app via the sixth rule. The left-hand
side of this rule returns a function (i.e., callee), the class
where it is declared (i.e., refclass), and the location where
the function is invoked (i.e., loc). The right-hand side states
that such a function should be invoked by a remote object
declared in Figure 1(e).
(iv) Putting the Facts and Rules Together. Finally, we use
the final rule in Table I to get a set of functions that are
impacted by code changes, published to the external world,
and, meanwhile, used by clients. The result includes the
function name, the class where the function is declared, and
the location where the function is invoked.
III. A PPROACH
MICROSCOPE supports nine programming or configuration
languages to address the multi-lingual problem in microser-
vices. However, we cannot discuss all of them due to the page
limits. Instead, we discuss the design using a widely used
microservice framework, SOFAStack, and assume both the
back-end (server) and the front-end (client) of a microservice
application are written in Java and XML. In this section,
after introducing the basic concepts in SOFAStack (§III-A),
we discuss the technical design following the workflow in
Figure 2, including the extraction of Datalog facts (§III-B)
as well as the definition of Datalog rules for change impact
analysis (§III-C).
A. SOFAStack for Microservices
SOFAStack [12] extends Spring Boot [13] and provides a
flexible framework for developing microservices in different
languages, such as in the motivating example discussed. On
the server side, an XML file declares implicit dependenciesMicroservices
Code Facts(built incrementally when change happens)Change Facts
Code Changes
Change-ImpactedInterfaces 
RelationshipRules
(1)(2)(3)DatalogEngine(4)
(They are not changed once defined)Fig. 2: Workflow of M ICROSCOPE .
in the Java code and publishes functions that a remote client
can invoke. As shown in Figure 3(a), the server-side XML file
often includes a list of beans and SOFA services to publish.
For each bean, the underlying SOFA framework creates a Java
object of the specified Java class at runtime. We can also
declare dependencies among these beans. For instance, the
class BillInfo has a field named clientInfo . Line 4 in the
XML file states that this field is initialized with the object
whose bean ID is _clientInfo . That is, in Line 4, the attribute
name specifies the field name; the attribute refspecifies the
ID of the bean to initialize the field.
Line 6 declares a bean of Java class BillFacadeImpl ,
which, as shown in Figure 3(b), implements the Java interface
BillFacade . The Java class implements the function load .
Line 7 in the XML file declares that all functions in the Java
interface BillFacade are published to the clients. The object
of Java class BillFacadeImpl will be used to invoke these
functions from a remote client because the attribute refrefers
to the bean ID defined at Line 6.
We assume that the client side is also implemented in
Java and XML. The XML element sofa:reference at Line
9 states that it uses a remote object, namely _billFacade
due to the attribute id, of the class BillFacade to invoke
remote functions. As shown by Lines 10-12 in Figure 3(a)
and the Java code in Figure 3(b), a client Java class, named
OrderCenter , is initialized by assigning the remote object
_billFacade to its field billFacade . The underlying SOFA
framework automatically performs this initialization. As such,
in the function queryOrder , we can invoke the remote function
load using the remote object.
B. Extracting Facts
We extract facts from code changes as well as code in Java
and XML. At a high level, facts from code changes directly
reflect where the changes occur; facts from code are extracted
during the code-parsing procedure via syntax-directed transla-
tion [14] combined with lightweight dependency analysis.
1) Workflow Revisit: Code changes may not simply add a
line of code as the motivating example. However, any code
changes can be decomposed into code deletion and code
addition. For example, Figure 4 shows that a code change
11.<!-- Server Side (server/service.xml)-->22.<beanid="_clientInfo"class="com.store.ClientInfo"></bean>33.<beanid="_billInfo"class="com.store.BillInfo">44.<propertyname="clientInfo"ref="_clientInfo"></property>55.</bean>66.<beanid="_billFacade"class="com.store.BillFacadeImpl"></bean>77.<sofa:serviceref="_billFacade"interface="com.store.BillFacade"/>898.<!-- Client Side in Java (client/service.xml) -->109.<sofa:referenceid="_billFacade"interface="com.store.BillFacade"/>1110.<beanid="_orderCenter"class="com.store.OrderCenter">1211.<propertyname="billFacade"ref="_billFacade"></property>1312.</bean>(a) service.xml on the server and the client sides.
/* Server Side */publicclassBillFacadeImplimplementsBillFacade{BillInfoload(BillRequestreq){...;return...;}}/* Client Side */publicclassOrderCenter{BillFacadebillFacade;BillInfoqueryOrder(Mgro,...){o.f=this.billFacade;returno.f.load(...);}}a remote procedure call
(b) Additional Java source code.
Fig. 3: Illustration of SOFAStack.
1. a = b + c;
2. d = a * 2;
3. e = d + 1;
3
(a) Original code
1. a = b + c;
2. - d = a * 2;
3. e = d + 1;
3 (b) Code deletion
1. a = b + c;
2. + d = a * 3;
3. + d = d + 1;
4. e = d + 1; (c) Code addition
Fig. 4: Dealing with code changes.
that replaces the second line in (a) with lines 2-3 in (c) can
be decomposed into two steps: code deletion, which removes
the second line as shown in (b), and code addition, which
adds two new lines as shown in (c). M ICROSCOPE separately
deals with code deletion and code addition in two steps, i.e.,
performing the workflow in Figure 2 twice.
First, M ICROSCOPE finds service interfaces impacted by the
code deletion. Use the example in Figure 4 as an example. In
this step, we specify change( (a):2:2 ), which says that line
2 in the original code will be changed, and input the code
facts extracted from the original code. In practice, if we have
stored the code facts in a database, we do not re-extract facts
from the original code. This step then outputs all interfaces
impacted by the deletion of line 2.
Second, M ICROSCOPE finds service interfaces impacted by
the newly added code. Use the example in Figure 4 as an
example. In this step, we specify change( (c):2:3 ), which says
that lines 2-3 in (c) are changed and input the code facts
extracted from the new code in (c). In practice, we do not re-
extract code facts from all files but only re-extract code facts
from files containing additional code. This step then outputs
all interfaces impacted by the newly added code.
Next, we discuss the Datalog facts extracted from the code
and the changes in detail.
2) Facts from Code Changes: We elaborate a bit more on
the facts extracted from code changes. Previously, a code-
change fact is specified in the form of change(loc), where loc
is a string in the form “path:startline:endline”, which reflects
what lines of code are changed. We predefined an auxiliary
predicate in(loc 1, loc 2) to check if the two locations overlap.TABLE II: Translating XML into Datalog facts by syntax-directed translation.
ID XML Grammar Action for Translating XML to Datalog Facts
1 xml := elmt 0elmt 1. . . xml.facts = elmt 0.facts◦elmt 1.facts◦···
2elmt := <name elmt.id = id(); attr i.parent = elmt.id;
elmt := ¡ attr 0attr1. . . /> elmt.facts = xml elmt(elmt.id, name, elmt.parent, elmt.loc) ◦attr0.facts◦attr1.facts◦···
elmt := <name elmt.id = id(); attr i.parent = elmt.id; elmt i.parent = elmt.id;
3 elmt := ¡ attr 0attr1. . .>elmt 0elmt 1. . . elmt.facts = xml elmt(elmt.id, name, elmt.parent, elmt.loc) ◦
elmt := </name > attr0.facts◦attr1.facts◦···◦ elmt 0.facts◦elmt 1.facts◦···
4 attr := key = value attr.facts = xml attr(key, value, attr.parent, attr.loc)
To specify code changes more precisely, the location string
can be easily extended to include both line and column
numbers. In what follows, all Datalog facts are ended with
a location, which may be omitted to keep the text clean.
3) Facts from XML Files: Facts extracted from an XML
file describe XML elements, attributes, and their containment
relationship. Table II formally defines how an XML file is
translated into Datalog facts. The second column is the XML
grammar, and the third defines the actions to take when a
production rule in the grammar is applied for parsing. The
grammar contains three non-terminal symbols: xml, elmt,
and attr. The non-terminal, xml, represents the whole XML
file. The non-terminals, elmt and attr, mean XML elements
and XML attributes being parsed. The first production rule
in the grammar states that an XML file is a list of XML
elements. The second and the third state that an element has a
name and may contain attributes and sub-elements. The fourth
production states that each attribute is a key-value pair.
To translate an XML file into Datalog facts, we associate
each non-terminal symbol with some fields. Each non-terminal
has a field, e.g., xml.facts, representing the string of Datalog
facts generated after using the corresponding production rules
for parsing. For example, after the first production rule is used
to parse the XML file, we have already parsed each elmt i, and
elmti.facts have been generated. As such, the facts we generate
for the whole XML file, i.e., xml.facts, is the concatenation of
all elmt i.facts (see the 2nd row and 3rd column of Table II).
Each non-terminal, elmt or attr, is associated with a field,
e.g., elmt.parent, initialized as 0. Each non-terminal, elmt,
is also associated with a field, e.g., elmt.id, to distinguish
different XML elements with the same name. As shown in
Table II, whenever the second or the third production rules
are applied to parse an XML element, and after the parser
visits the element’s name, we create a unique and positive
ID for the XML element and assign the ID to the attributes’
and subelements’ parent field, meaning that their parent is
the current XML element. After the parser parses all XML
attributes and subelements, the facts of an XML element are
generated, including the fact xml elmt, which contains the ID,
name, parent, and the element’s location, and the facts of its
attributes and subelements.
The final row of Table II explains how we translate an XML
attribute into the fact xml attr: after the final production rule
is applied, we create the fact xml attr for the XML attribute
being parsed, including the key and value of the attribute, its
parent XML element, and the attribute’s location.Example 1 (XML Facts): The client’s XML configuration
file in Figure 3 can be translated into the three xml elmt facts,
where ‘...’ means an omitted location. The third arguments of
the first two facts are 0because they do not belong to any
parent XML elements. The third argument of the third fact is
2because it is in the XML element of Fact 2.
1) xml elmt( 1,sofa:reference ,0, . . . )
2) xml elmt( 2,bean ,0, . . . )
3) xml elmt( 3,property ,2, . . . )
The facts for attributes are like xml attr(id,billFacade ,1,
. . . ). The first two arguments form a key-value pair, and the
third is 1because it belongs to the element of Fact 1. □
We can then use the following Datalog rules, where un-
derscore means a don’t-care argument, to define beans and
properties in the XML files. Each bean includes its ID, class
name, and location. Each property includes an ID, its name,
the bean it references, its parent bean, and its location.
1. bean(bean id, class name, bean loc) :-
2. xml elmt(elmt id,bean ,, bean loc)
3. xml attr(id, bean id, elmt id, )
4. xml attr(class , class name, elmt id, )
5. prop(prop id, prop name, ref bean id, bean id, prop loc) :-
6. xml elmt(prop id,property , bean id, prop loc)
7. xml attr(name , prop name, prop id, )
8. xml attr(ref, ref bean id, prop id, )
4) Facts from Java Files: We follow a similar syntax-
directed translation method to translate Java code into Datalog
facts, so that the translation procedure can be integrated into
Java parsers. Due to the space limit, we omit the formal
description, which is similar to that for XML. Similarly, we
translate Java into facts for Java classes, Java interfaces, fields,
functions, expressions, call statements, and their containment
relationship. These facts use Predicates 1-6 in Table III. For
practical purposes, these predicates differ from those in the
motivating example in two aspects. First, each predicate is
assigned a unique ID. Second, the predicate function uses
a mangled function name [15] so that we can distinguish
functions with the same name but different parameter types
(see Fact 3 in Example 2).
The second group of facts uses Predicate 7-8 in Table III
to record the inheritance relationships among Java classes and
interfaces. The following rules define indirect inheritance.
1. inherits(id, pid) :- implments(id, pid)
2. inherits(id, pid) :- extends(id, pid)
3. inherits(id, pid) :- extends(id, xid) inherits(xid, pid)TABLE III: Facts generated from Java code.
ID Predicates Description
1 class(id, name, loc) Java class with a unique id, the class name, and where it is defined
2 interface(id, name, loc) Java interface with a unique id, the interface name, and where it is defined
3 field(id, cid, name, pid, loc) A field assigned a unique id; cid indicates the Java class or interface, i.e., type, of the field;
pid is the Java class where the field is declared
4 function(id, cid, name, pid, loc) A function assigned a unique id, cid indicates the return type of the function,
and name is the mangled function name
5 expr(id, cid, expr, pid, loc) An expression that is either a variable or in the form of o.f.g.. . . , which accesses a Java object’s field;
it is of the type identified by cid and is defined or used in a function with pid as the unique ID
6 call(id, eid, fid, pid, loc) Using a Java expression whose unique ID is eid to invoke a function whose unique ID is fid;
pid indicates the caller function where the call occurs
7 extends(id, pid, loc) Java class with id extends the Java class with pid
8 implements(id, pid, loc) Java class with id implements the Java interface with pid
9 dep(id 1, id2) An expression or a class field with id 1data-depends on the other with id 2
10 alias(id 1, id2) An expression or a class field with id 1data-is an alias of the other with id 2
Additionally, we use a lightweight must alias analysis [16],
which is also based on Datalog, to build alias and data
dependency facts among variables or expressions (Predicates
9-10 in Table III). The Datalog rules for the alias analysis are
omitted as they are not our contribution and can be found
in the previous work [16]. Since the alias analysis is also
Datalog-based, they can seamlessly work with M ICROSCOPE .
As explained in §III-A, SOFAStack’s XML files may introduce
extra aliases if two bean properties reference the same bean.
These extra alias rules can be found below, where Lines 2-
3 and Lines 6-7 find the properties that reference the same
bean ID, ref bean id. Other lines find the corresponding class
member fields in the Java source files.
1. alias(field id1, field id2) :-
2. bean(bean id1, class name 1,)
3. prop( , prop name 1, ref bean id, bean id1,)
4. class(class id1, class name 1,)
5. field(field id1,, prop name 1, class id1,)
6. bean(bean id2, class name 2,)
7. prop( , prop name 2, ref bean id, bean id2,)
8. class(class id2, class name 2,)
9. field(field id2,, prop name 2, class id2,)
The data dependency facts include direct def-use relations
and indirect data dependencies hidden behind pointer aliases.
Although a must-alias analysis helps improve M ICROSCOPE ’s
precision, we acknowledge that its unsoundness may lead to
false positives or negatives in the change-impact analysis. Nev-
ertheless, our experiments (see §V-C) show that M ICROSCOPE
reports only a moderate number of false positives and false
negatives, which are manageable in practice.
Example 2 (Java Facts): Consider the client’s Java code
in Figure 3(b). We will have the following facts, where ‘. . . ’
means an omitted argument, such as the locations.
1) class( 1,OrderCenter , . . . )
2) field( 2, . . . , billFacade ,1, . . . )
3) function( 3, . . . , queryOrder(Mgr) ,1, . . . )
4) expr( 4, . . . , o,3, . . . )
5) expr( 5, . . . , o.f,3, . . . ) /*defined in the assignment*/
6) expr( 6, . . . , o.f,3, . . . ) /*used in the call*/
7) expr( 7, . . . , this.billFacade ,3, . . . )
8) call( 8,6, . . . , 3, . . . )Facts 1-3 describe the class, as well as the fields and func-
tions of the class. The function uses a mangled name that
includes the parameter types. Facts 4-7 describe the variables
or expressions defined or used in the function. We have two
predicates for the expression o.fas it is defined and used in
different locations. Fact 8 describes the call, which uses the
expression (ID=6, i.e., o.f) to invoke the callee named load .
In addition, via a lightweight pointer analysis, the following
predicates are held to be true: dep( 5,7); dep( 6,7); alias( 5,
7); alias( 5,6); alias( 6,7). We do not need to enumerate these
dependency/alias facts before the change impact analysis but
query the underlying pointer analysis on demand. □
C. Defining Relationship Rules
Datalog rules define the relationships among the facts and
allow us to reason functions impacted by code changes, pub-
lished to clients, and referenced by clients. While different mi-
croservice frameworks, which may not use XML like Figure 3,
may require us to define different relationship rules, we argue
that Datalog provides an easy manner to describe relationships
and, once defined, the relationships are not changed due to
their generality for a microservice framework.
1) Identifying Published Functions: SOFAStack publishes
functions via XML elements named sofa:service as shown
in Figure 3(a). The complete Datalog rule for identifying
published functions is listed below.
1. pub function(func id, func name, class id, func loc) :-
2. function(func id, , func name, class id, func loc)
3. class(class id, class name, )
4. bean(bean id, class name, )
5. xml elmt(elmt id,sofa:service ,,)
6. xml attr(ref, bean id, elmt id, )
Lines 2-3 state that a published function is defined in a Java
class named class name. Line 4 states that the class is declared
as a bean in the configuration file. Lines 5-6 state that the bean
is referenced by an XML element named sofa:service .
2) Identifying Referenced Functions: SOFAStack allows a
client to use a remote function that is declared in an XML
element named sofa:reference , as exemplified in Figure 3(a).
The rule for identifying referenced functions is listed below.1. ref function(func id, func name, pid, func loc) :-
2. function(func id, , func name, pid, func loc)
3. inherits(pid, interface id)
4. interface(interface id, interface name, )
5. xml elmt(elmt id,sofa:reference ,,)
6. xml attr(id, remote obj, elmt id, )
7. xml attr(interface , interface name, elmt id, )
8. bean(bead id, class name, )
9. prop(prop id, prop name, remote obj, bead id, )
10. field name = prop name
11. class(class id, class name, )
12. field(field id, , field name, class id, )
13. alias(eid, field id)
14. call( , eid, func id, ,)
The rule can be understood in three parts: Lines 2-7, 8-
10, and 11-14. Line 2 says that a referenced function is a
function. Line 3 says that the Java class where the function
is defined inherits a Java interface. Line 4 finds this Java
interface, namely interface name. Lines 5-7 state that the Java
interface and its corresponding remote object are declared in
an XML element named sofa:reference .
Lines 8-10 state that the remote object, remote obj, is
assigned to a field, field name, of a Java class, class name.
Consider Figure 3. This is to find the bean and the prop-
erty XML elements on the client side, where remote obj
=_billFacade , field name = billFacade , class name =
com.store.OrderCenter .
Line 11 finds the Java class according to the class name.
Line 12 finds the field that receives the remote object in the
Java class. Line 13 finds the field’s aliases, i.e., aliases of the
remote object, which invoke the remote function at Line 14.
3) Identifying Impacted Functions: We then identify func-
tions impacted by code changes in a few steps. First, we
identify Java classes and functions impacted by code changes.
We say code changes impact a Java class if one of its fields
or parent classes is impacted by code changes (Lines 1-4).
Similarly, a function is impacted by code changes if one
variable or expression it defines or uses is impacted by code
changes (Lines 5-6).
1. imp class(id, name, loc) :-
2. class(id, name, loc) imp field( ,,, id, )
3. imp class(id, name, loc) :-
4. class(id, name, loc) inherits(id, pid) imp class(pid, ,)
5. imp function(fid, fname, pid, floc) :-
6. function(fid, , fname, pid, floc) imp expr( ,,, id, )
The rules above depend on imp field() and imp expr(),
which specify a class field or an expression impacted by code
changes. The rules for imp expr() are listed below, which are
put into four cases. The first case states that if an expression
is defined or used at a location where the changes occur, the
expression is impacted by code changes. The second case
states that if an expression is of a type (i.e., a Java class)
impacted by code changes, it is also impacted. The third
and the fourth state that if an expression depends on another
expression or a field impacted, it is also impacted.1. imp expr(id, cid, expr, pid, loc) :-
2. expr(id, cid, expr, pid, loc) change(cloc) in(loc, cloc)
3. imp expr(id, cid, expr, pid, loc) :-
4. expr(id, cid, expr, pid, loc) imp class(cid, ,)
5. imp expr(id, cid, expr, pid, loc) :-
6. imp expr(eid, ,,,) dep(id, eid)
7. imp expr(id, cid, expr, pid, loc) :-
8. imp field(fid, ,,,) dep(id, fid)
The rules that define imp field() are listed below. Lines 1-2
state that a field is impacted if it is declared at the location
where code changes occur. Lines 3-4 state that a field is
impacted if it is of a type, i.e., a Java class, impacted by code
changes. Lines 5-6 state that a field is impacted if it depends
on an expression impacted.
1. imp field(id, cid, name, pid, loc) :-
2. field(id, cid, name, pid, loc) change(cloc) in(loc, cloc)
3. imp field(id, cid, name, pid, loc) :-
4. field(id, cid, name, pid, loc) imp class(cid, ,)
5. imp field(id, cid, name, pid, loc) :-
6. imp expr(eid, ,,,) dep(id, eid)
7. imp field(id, cid, name, pid, loc) :-
8. field(id, cid, name, pid, loc) class(pid, pname, )
9. bean(bid, pname, ) imp prop( , name, , bid, )
Lines 7-9 above are a bit different. Recall the XML config-
uration file in Figure 3(a) — SOFAStack allows us to initialize
a class field using the XML element named property . Thus,
Lines 7-9 above state that code changes impact a class field if
the corresponding XML element named property is impacted
by code changes, denoted by the predicate imp prop() and
defined below. The idea is similar: an XML element named
property is impacted by code changes if the changes happen
there (Lines 1-3 below) or the property element references an
impacted bean (Lines 4-6 below).
1. imp prop(prop id, prop name, ref bean id, bean id, loc) :-
2. prop(prop id, prop name, ref bean id, bean id, loc)
3. change(cloc) in(cloc, prop loc)
4. imp prop(prop id, prop name, ref bean id, bean id, loc) :-
5. prop(prop id, prop name, ref bean id, bean id, loc)
6. imp bean(ref bean id, ,)
The above rules then depend on the predicate imp bean(),
representing the beans impacted by code changes. As listed
below, a bean is impacted by code changes if the changes
happen at the location where the bean is declared (Lines 1-2),
the bean references another impacted bean (Lines 3-5), or the
bean references a class impacted by code changes (Lines 6-7).
1. imp bean(bid, cname, loc) :-
2. bean(bid, cname, loc) change(cloc) in(cloc, loc)
3. imp bean(bid, cname, loc) :-
4. bean(bid, cname, loc) prop( ,, ref bean id, bid, )
5. imp bean(ref bean id, ,)
6. imp bean(bid, cname, loc) :-
7. bean(bid, cname, loc) imp class( , cname, )
4) Summary: All the above rules are finally reduced to
facts extracted from code changes and source code. Thus, by
combining all code and change facts with the above rules, aSOURCEREPOSITORYCOMMIT CHANGES
CI SERVERBUILDCIATESTRESULTFig. 5: M ICROSCOPE working with CI.
Datalog engine can then reason functions (i.e., microservice
interfaces) impacted by code changes, published to clients, and
referenced by clients.
D. Extending to Other Languages and Frameworks
Recall that we translate both Java and XML into basic
elements in their languages and the containment relation-
ship among the elements. Such code elements (e.g., classes,
functions, expressions, etc) and containment relationships are
shared by common programming languages and microservice
frameworks such as Spring Boot and Apache Dubbo, to name
a few. Thus, we argue that our Datalog-based approach dis-
cussed above can be easily extended to other languages. Due
to the space limits, we discuss a subset of them. Datalog rules
for nine common programming and configuration languages
can be found in our artifact.
IV. I MPLEMENTATION
We implement our approach as a tool named M ICROSCOPE
to support CIA. The tool is now open-sourced and publicly
available. In M ICROSCOPE , the components of extracting facts
from the source code are implemented as plugins of each
language parser. With the facts extracted from the source code,
we use Souffle [10], a state-of-the-art Datalog engine, to infer
impacted microservice interfaces. In what follows, we discuss
a few important details of the implementation.
Continuous Integration . M ICROSCOPE is now working as
a critical phase in the continuous integration (CI) system, as
illustrated in Figure 5. In the CI system, M ICROSCOPE works
after developers commit an update of the code to help identify
impacted service interfaces. Without M ICROSCOPE , the CI
system is unaware of what service interfaces are affected by
code changes and, thus, has to invoke regression testing to
run all test cases. By contrast, M ICROSCOPE allows the CI
system to identify interfaces impacted by the code changes,
thus running only a small subset of test cases and speeding
up the CI procedure.
Incremental Building . Due to the frequent code changes in
the industry, it is not efficient and also not necessary to re-
extract the facts from all source code or configuration files.
Instead, due to the integration of M ICROSCOPE and the CI
system, M ICROSCOPE benefits from the incremental strategy
of common build systems, e.g., Maven and Gradle, which only
rebuild code containing changes. As such, M ICROSCOPE alsoTABLE IV: Microservice applications for evaluation.
Apps KLoC #F #I Java XML JS TS Others
Monitor 127 1,220 703
Ledger 104 927 428
Authorization 296 2,535 613
TradeCenter 160 1,364 216
ClearingCenter 604 4,501 4,036
SmartEngine 366 3,440 725
PriceCenter 72 668 776
TransferCenter 233 2,176 430
RejectPayment 102 975 243
Regression 90 818 1,288
TCC-Transaction 26 438 233
Incubator-Seata 287 2,042 80
Shenyu 300 2,930 1,420
OpenSPG 94 1,019 267
only re-extracts facts from files containing changes and, thus,
is highly efficient even in the face of frequent changes in
industrial settings.
V. E VALUATION
As shown in Figure 5, M ICROSCOPE helps identify im-
pacted service interfaces after developers commit an update of
the code into the repository. As such, we only need to focus
on impacted interfaces in regression testing. In particular, we
evaluate the effectiveness and efficiency of M ICROSCOPE by
investigating the following three research questions:
•RQ1: How efficient is M ICROSCOPE in extracting the
relational representation from multilingual microservices?
•RQ2: What is the overhead of M ICROSCOPE in identi-
fying impacted microservice interfaces for a commit?
•RQ3: How effective is M ICROSCOPE in identifying im-
pacted microservice interfaces?
We aim to evaluate M ICROSCOPE ’s performance in real
industry settings, thus using ten most frequently updated core
applications from Ant Group, a Global 500 company, as well
as four open-sourced applications [17]–[20]. The details of
these applications are listed in Table IV. Their sizes range
from 26 to 600 KLoC (Kilo Lines of Code), containing up
to 4,501 source code files (#F) and hundreds to thousands of
interfaces (#I) exposed to the external world. On average, each
application involves at least four languages.
For RQ1, we translate all applications’ source files into
our cross-language representation and record the time cost
for evaluation. Note that each experiment is conducted twenty
times, and the average time cost is reported. To assess the
change impact analysis, i.e., RQ2 and RQ3, we select the
main development branch of each application and extract
the code changes from the latest eight commits, yielding a
total of 112 commits or code changes. Of the 112 code
changes, 67 are considered significant as they involve semantic
changes to Java code or configuration files. These significant
changes are then fed to the evaluation of RQ2 and RQ3,
which evaluate the efficiency and effectiveness in identifying
impacted microservice interfaces.01002003004005001234567891011121314(a) Clean build
0501001502002503001234567891011121314 (b) Incremental build
Fig. 6: Time overhead of extracting facts (RQ1). The X-
axis lists the microservice applications. The Y-axis is time
in seconds. ■: build time; ■: extraction time.
In our experiments, we failed to find any existing technique
supporting so many programming or configuration languages.
In other words, this is the first static CIA for multilingual
microservices. Thus, we cannot compare it to other similar
tools. To show the efficiency of our approach (RQ1 and
RQ2), we compare the time cost of CIA with the building
time of each application, which we believe is sufficient to
show M ICROSCOPE ’s efficiency. To show the effectiveness
(RQ3), we discuss the false positives and negatives reported
by M ICROSCOPE . Also, to show the necessity of the language-
agnostic solution, we compare the false positive and false
negative rates to the solution where we remove the support
for some languages. Putting all experiment results together,
we can make the conclusion below.
By spending a very short time, i.e., about 38% of the
time for a common incremental build (RQ1 and RQ2),
MICROSCOPE can precisely identify change-impacted
interfaces and reduce 97% of regression test cases and
save 73% of testing time (RQ3).
All experiments are conducted on a laptop with a 6-core
Intel i7-9750H CPU @ 2.60GHz and 16GB of RAM.
A. RQ1: Efficiency of Fact Extraction
As shown in Figure 2, the first step of M ICROSCOPE is
to extract facts from the code and the code changes, which
are implemented as a part of the code parser. Figure 6(a)
displays the overhead of M ICROSCOPE compared to a clean
build. A clean build means that the code is built from scratch.
Thus, we re-extract all facts from the code. As shown in the
figure, extracting the facts exhibits a moderate, i.e., 46% on
average, time overhead compared to a clean build. In other
words, extracting code and code-change facts takes less than
half the time for a clean build.
In practice, we often do not build a software project from
scratch but leverage a build system’s capability of incremental
building. That means we only rebuild files containing changes.
MICROSCOPE , as a part of the parser, only re-extracts the facts
from the files with changes. Figure 6(b) displays the time over-
head of fact extraction in an incremental build. The overhead
ranges from 3% to 15%, 8% on average, which is quite low
and often imperceptible. For the largest project with over half
a million lines of code, i.e., ClearingCenter, M ICROSCOPE
exhibits an average overhead of 8%, demonstrating that the
040801201602002402801234567891011121314(a) Reasoning overhead
0501001502002503001234567891011121314 (b) Total overhead
Fig. 7: Time overhead of change impact analysis (RQ2). The
X-axis lists the microservice applications. The Y-axis is time
in seconds. ■: time of incremental build; ■: overhead of (a)
Datalog reasoning and (b) fact extraction + Datalog reasoning.
scalability of M ICROSCOPE is graceful and M ICROSCOPE is
practical even for large codebases.
Answer to RQ1 : M ICROSCOPE can extract code facts
with an average overhead of 8% in a common incremen-
tal build, showing its graceful scalability for CIA.
B. RQ2: Efficiency of CIA
As shown in Figure 2, after extracting facts from the code
and the code changes, we use a Datalog engine to reason the
impacted interfaces. The time overhead of reasoning change
impacts over an incremental build — which is more common
in practice than a clean build — is shown in Figure 7(a).
As plotted, the reasoning procedure exhibits 11% to 55%
overhead, 23% on average, over an incremental build.
Figure 7(b) shows the time cost of the whole CIA procedure,
including the fact extraction time discussed in RQ1 and the
reasoning time. The evaluation results show that the total time
cost of a change impact analysis usually takes 23% to 62%
(38% on average) of the build time, demonstrating a moderate
and manageable overhead in practice.
Answer to RQ2 : On average, M ICROSCOPE can identify
change-impacted interfaces by 38% of the incremental
build time, showing a moderate time overhead.
C. RQ3: Effectiveness of CIA
As shown in Table V, among the 112 examined commits
(or code changes), M ICROSCOPE finds that 338 out of 11,458
microservice interfaces in either upstream or downstream
applications are impacted, with 59 false positives and 20 false
negatives. On average, the false positive rate is 17%, and
the false negative rate is 6%. However, given a solution that
does not address the multilingual problem, the false negative
rate may significantly be increased. For instance, as shown
in Table V, even if we remove the support for only one
language, say XML, we will miss about 4 ×impacted inter-
faces, demonstrating the necessity and value of our language-
agnostic approach.
Consider that the impacted interfaces only account for 3%
of the total. Compared to the situation where we do not have
a CIA for multilingual microservices and have to test all
interfaces, our CIA lets the subsequent testing procedure focusTABLE V: The number of all interfaces (#AI), impacted
interfaces (#II), false positives (#FP) and negatives (#FN), as
well as the impacted interfaces (#II’), the false positives (#FP’)
and negatives (#FN’) if we do not support XML.
Apps #AI #II #FP #FN #II’ #FP’ #FN’
1 703 50 7 9 41 9 20
2 428 0 0 0 0 0 0
3 613 9 1 0 9 1 0
4 216 0 0 0 0 0 0
5 4,036 0 0 0 0 0 0
6 725 60 10 4 54 10 10
7 776 117 18 0 97 18 20
8 430 0 0 0 0 0 0
9 243 17 2 1 11 2 7
10 1,288 50 16 4 42 16 12
11 233 5 0 1 6 1 1
12 80 3 0 0 2 0 1
13 1,420 18 3 1 14 4 6
14 267 9 2 0 6 2 3
Total 11,458 338 59 20 282 63 80
% - - 17% 6% - 22% 27%
on a small number of impacted interfaces, reducing 97% of
interfaces to test. As for how much testing time we can save, it
may differ a lot in different applications because the test suite
may contain different numbers of test cases for each interface.
According to our statistics, for the fourteen microservices, our
CIA lets us save 73% of testing time on average every time a
code change is committed to the code repository.
Answer to RQ3 : M ICROSCOPE can effectively iden-
tify change-impacted interfaces, allowing the subsequent
testing procedure to focus only on 3% out of all inter-
faces, saving 73% of testing time.
D. Discussion on False Positives and Negatives
False positives mean we misreport service interfaces un-
affected by code changes. Regression testing then has to
test interfaces that have been misreported to be impacted by
changes. Testing more interfaces does not affect the testing
effectiveness but the efficiency. We have shown that our ap-
proach can reduce the testing efforts significantly. Thus, false
positives are less important in our application scenario and are
mainly attributed to the imprecision of the underlying alias
and dependence analysis. As discussed before, M ICROSCOPE
applies existing alias and dependence analysis, thus inheriting
their imprecision.
False negatives mean that we may miss change-impacted
interfaces such that regression testing will also not test them.
This situation, in theory, may degrade the effectiveness of
regression testing, leaking bugs into the product. However,
we observed few such issues in practice. Currently, false
negatives are mainly attributed to engineering issues, e.g.,
currently, M ICROSCOPE does not support anonymous Java
classes. Figure 8 shows an example where Line 2 creates an
anonymous Java class that overrides and implicitly invokes the
1.booleanupdateInfo(Operatoroperator){2.varresult=template.execute(Result.class,newCallback(){3.@Override4.publicResultexecuteService(){...}5.});6.thrownewException(result.getCode());7.}Fig. 8: The cause of false negatives.
function executeService . Our Datalog rules currently do not
capture such implicit calls. This problem can be addressed by
integrating more advanced call graph analysis, which is left as
our future work.
VI. R ELATED WORK
Program analysis in enhancing microservices has gained
significant recognition in recent years [21]–[25]. Datalog-
based program analysis has also increased interest over the
past decade, with many noteworthy examples [26]–[32]. De-
spite a lot of progress, the capability of handling multiple
languages is still limited. This underscores the need for our
multi-lingual solution, where not only do the Datalog rules
provide the capability of reasoning change impacts, but the
Datalog representation also provides an abstraction layer over
diverse languages.
Traditional CIAs utilize program slicing to identify program
locations potentially influenced by code changes [7], [33].
They typically work on graphical representations of the pro-
gram, such as program or system dependency graph [34], [35],
determining the impacted program locations through specific
graph reachability problems. In contrast, M ICROSCOPE main-
tains only the syntactical constructs in its relational represen-
tation and uses Datalog solvers to derive semantic properties,
providing a more adaptable and comprehensive approach to
change impact analysis.
VII. C ONCLUSION
This paper introduces a language-agnostic change impact
analysis via Datalog, namely M ICROSCOPE , to pinpoint mi-
croservice interfaces exposed to the external world and im-
pacted by code changes. Through our evaluation of a leading
software company, we conclude that M ICROSCOPE can effi-
ciently and precisely identify change-impacted interfaces, with
the potential of saving testing efforts.
REFERENCES
[1] N. Zhao, J. Chen, Z. Yu, H. Wang, J. Li, B. Qiu, H. Xu, W. Zhang,
K. Sui, and D. Pei, “Identifying bad software changes via multimodal
anomaly detection for online service systems,” in Proceedings of the
29th ACM Joint Meeting on European Software Engineering Confer-
ence and Symposium on the Foundations of Software Engineering , ser.
ESEC/FSE’21. ACM, 2021, pp. 527–539.
[2] S. Zhang, Y . Liu, D. Pei, Y . Chen, X. Qu, S. Tao, and Z. Zang, “Rapid
and robust impact assessment of software changes in large internet-based
services,” in Proceedings of the 11th ACM Conference on Emerging
Networking Experiments and Technologies , ser. CoNEXT’15. ACM,
2015, pp. 2:1–2:13.
[3] B. Beyer, C. Jones, J. Petoff, and N. R. Murphy, Site Reliability
Engineering: How Google Runs Production Systems . O’Reilly Media,
Inc., 2016.[4] Y . Wu, B. Chai, Y . Li, B. Liu, J. Li, Y . Yang, and W. Jiang, “An empirical
study on change-induced incidents of online service systems,” in 2023
IEEE/ACM 45th International Conference on Software Engineering:
Software Engineering in Practice , ser. ICSE-SEIP’23. ACM, 2023,
pp. 234–245.
[5] R. S. Arnold, Software Change Impact Analysis . Washington, DC,
USA: IEEE Computer Society Press, 1996.
[6] S. Lehnert, “A taxonomy for software change impact analysis,” in Pro-
ceedings of the 12th International Workshop on Principles of Software
Evolution and the 7th Annual ERCIM Workshop on Software Evolution ,
ser. IWPSE-EVOL’11. ACM, 2011, pp. 41–50.
[7] M. Acharya and B. Robinson, “Practical change impact analysis based
on static program slicing for industrial software systems,” in Proceedings
of the 33rd International Conference on Software Engineering , ser.
ICSE’11. ACM, 2011, pp. 746–755.
[8] H. Cai and R. Santelices, “Diver: Precise dynamic impact analysis
using dependence-based trace pruning,” in Proceedings of the 29th
ACM/IEEE International Conference on Automated Software Engineer-
ing, ser. ASE’14. ACM, 2014, pp. 343–348.
[9] H. Cai and D. Thain, “DistIA: a cost-effective dynamic impact analysis
for distributed programs,” in Proceedings of the 31st IEEE/ACM Inter-
national Conference on Automated Software Engineering , ser. ASE’16.
ACM, 2016, pp. 344–355.
[10] H. Jordan, B. Scholz, and P. Suboti ´c, “Souffl ´e: On synthesis of program
analyzers,” in Computer Aided Verification , ser. CA V’16. Springer,
2016, pp. 422–430.
[11] https://owasp.org/API-Security/editions/2023/en/0x11-t10/, 2023.
[12] https://www.sofastack.tech/en/, 2023.
[13] https://spring.io/projects/spring-boot, 2023.
[14] A. V . Aho, R. Sethi, and J. D. Ullman, Compilers: Principles, Tech-
niques, and Tools . Pearson Addison Wesley, 2007.
[15] https://en.wikipedia.org/wiki/Name mangling, 2024.
[16] G. Balatsouras, K. Ferles, G. Kastrinis, and Y . Smaragdakis, “A datalog
model of must-alias analysis,” in Proceedings of the 6th ACM SIGPLAN
International Workshop on State Of the Art in Program Analysis , ser.
SOAP’17. ACM, 2017, pp. 7–12.
[17] https://github.com/changmingxie/tcc-transaction, 2023.
[18] https://github.com/apache/incubator-seata, 2023.
[19] https://github.com/apache/shenyu, 2023.
[20] https://github.com/openspg/openspg, 2023.
[21] T. Yang, J. Shen, Y . Su, X. Ling, Y . Yang, and M. R. Lyu, “AID:
efficient prediction of aggregated intensity of dependency in large-scale
cloud systems,” in Proceedings of the 36th IEEE/ACM International
Conference on Automated Software Engineering , ser. ASE’21. IEEE,
2021, pp. 653–665.
[22] C. Lee, T. Yang, Z. Chen, Y . Su, and M. R. Lyu, “Eadro: An end-
to-end troubleshooting framework for microservices on multi-source
data,” in Proceedings of the 45th IEEE/ACM International Conference
on Software Engineering , ser. ICSE’23. IEEE, 2023, pp. 1750–1762.
[23] S. Zhang, P. Jin, Z. Lin, Y . Sun, B. Zhang, S. Xia, Z. Li, Z. Zhong,
M. Ma, W. Jin et al. , “Robust failure diagnosis of microservice systemthrough multimodal data,” IEEE Transactions on Services Computing ,
vol. 16, no. 6, pp. 3851–3864, 2023.
[24] J. Wang, Y . Wu, G. Zhou, Y . Yu, Z. Guo, and Y . Xiong, “Scaling static
taint analysis to industrial SOA applications: a case study at alibaba,”
inProceedings of the 28th ACM Joint European Software Engineering
Conference and Symposium on the Foundations of Software Engineering ,
ser. ESEC/FSE’20. ACM, 2020, pp. 1477–1486.
[25] Z. Zhong, J. Liu, D. Wu, P. Di, Y . Sui, and A. X. Liu, “Field-based static
taint analysis for industrial microservices,” in Proceedings of the 44th
IEEE/ACM International Conference on Software Engineering: Software
Engineering in Practice , ser. ICSE-SEIP’22. IEEE, 2022, pp. 149–150.
[26] M. Bravenboer and Y . Smaragdakis, “Strictly declarative specification of
sophisticated points-to analyses,” in Proceedings of the 24th ACM SIG-
PLAN conference on Object-oriented programming systems languages
and applications , ser. OOPSLA’09. ACM, 2009, pp. 243–262.
[27] P. Avgustinov, O. de Moor, M. P. Jones, and M. Sch ¨afer, “Ql: Object-
oriented queries on relational data,” in Proceedings of the 30th European
Conference on Object-Oriented Programming , ser. ECOOP’16. Schloss
Dagstuhl - Leibniz-Zentrum f ¨ur Informatik, 2016, pp. 2:1–2:25.
[28] Y . Yuan, Z. Liu, and S. Wang, “Cacheql: Quantifying and localizing
cache side-channel vulnerabilities in production software,” in Pro-
ceedings of the 32nd USENIX Security Symposium , ser. Security’23.
USENIX, 2023, pp. 2009–2026.
[29] T. Szab ´o, S. Erdweg, and G. Bergmann, “Incremental whole-program
analysis in datalog with lattices,” in Proceedings of the 42nd ACM
SIGPLAN International Conference on Programming Language Design
and Implementation , ser. PLDI’21. ACM, 2021, pp. 1–15.
[30] X. Zhang, R. Mangal, R. Grigore, M. Naik, and H. Yang, “On abstraction
refinement for program analyses in datalog,” in Proceedings of the 35th
ACM SIGPLAN Conference on Programming Language Design and
Implementation , ser. PLDI’14. ACM, 2014, pp. 239—-248.
[31] T. Szab ´o, G. Bergmann, S. Erdweg, and M. V oelter, “Incrementalizing
lattice-based program analyses in datalog,” Proceedings of ACM Pro-
graming Language , vol. 2, no. OOPSLA, pp. 139:1–139:29, 2018.
[32] B. Scholz, H. Jordan, P. Suboti ´c, and T. Westmann, “On fast large-scale
program analysis in datalog,” in Proceedings of the 25th International
Conference on Compiler Construction , ser. CC’16. ACM, 2016, pp.
196–206.
[33] F. Angerer, A. Grimmer, H. Prahofer, and P. Grunbacher, “Configuration-
Aware Change Impact Analysis (T),” in Proceedings of the 30th
IEEE/ACM International Conference on Automated Software Engineer-
ing, ser. ASE’15. IEEE, 2015, pp. 385–395.
[34] J. Ferrante, K. J. Ottenstein, and J. D. Warren, “The Program De-
pendence Graph and Its Use in Optimization,” ACM Transactions on
Programming Languages and Systems (TOPLAS) , vol. 9, no. 3, pp. 319–
349, 1987.
[35] S. Horwitz, T. Reps, and D. Binkley, “Interprocedural Slicing Using
Dependence Graphs,” ACM Transactions on Programming Languages
and Systems (TOPLAS) , vol. 12, no. 1, pp. 26–60, 1990.