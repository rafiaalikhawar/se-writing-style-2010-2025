saver scalable precise and safe memory error repair seongjoon hong korea university republic of korea seongjoon korea.ac.krjunhee lee korea university republic of korea junhee lee korea.ac.krjeongsoo lee korea university republic of korea jeongsoolee korea.ac.krhakjoo oh korea university republic of korea hakjoo oh korea.ac.kr abstract we present saver a new memory error repair technique for c programs.memoryerrorssuchasmemoryleak double free and use after free are highly prevalent and fixing them requires significanteffort.automatedprogramrepairtechniquesholdthepromise ofreducingthisburdenbutthestate of the artisstillunsatisfactory.inparticular noexistingtechniquesareabletofixthoseerrorsina scalable precise and safe way all of which are required for a truly practical tool.
saver aims to address theseshortcomings.
tothis end weproposeamethodbasedonanovelrepresentationofthe programcalledobjectflowgraph whichsummarizestheprogram s heap related behavior using static analysis.
we show that fixing memoryerrorscanbeformulatedasagraphlabelingproblemover object flow graph and present an efficient algorithm.
we evaluated saver in combination with infer an industrial strength static bug finder andshowthat74 ofthereportederrorscanbefixed automatically for a range of open source c programs.
ccs concepts software and its engineering software verification and validation software testing and debugging.
keywords program repair program analysis memory errors debugging acm reference format seongjoon hong junhee lee jeongsoo lee and hakjoo oh.
.
saver scalable precise and safe memory error repair.
in 42nd international conferenceonsoftwareengineering icse may23 seoul republicof korea.acm new york ny usa pages.
introduction recent years have seen significant progress in automated tools for static error detectionand their deployment inproduction code .yet fixingthoseerrorsinpracticeremainsmostlyamanual and unscalable process.
the longterm goal of our research is to the first and second authors contributed equally to this work.
corresponding author permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acmmustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
icse may seoul republic of korea association for computing machinery.
acm isbn ... .
this gap by automating the whole process of finding and fixing common safety errors at compile time.
inthis paper wefocus onfixingmemory errorsinc programs such as memory leak use after free and double free.
we target these errors because they are highly prevalent yet difficult to fix.for example more than memory leaks have been reported andfixedinlinuxkernel farmorefrequentlythanothererrors such as buffer overflow.
fixing memory errors manually however istime consuminganderror prone evenasingleerrormayrequire developers to spend several days or months until the error gets fixedcorrectly e.g.
.weaimtoreducethisburdenbyachieving a practical technique for automatically fixing memory errors.
existingtechniques .recently severaltechniqueswithsimilar goals have been proposed in the program repair community but they suffer from significant drawbacks.
on the one hand there are techniques that scale to large programs but may produce unsafe patches.
for example footpatch is a state ofthe art tool that can fix memory leaks in large code bases but may introducenewerrorssuchasdouble freeasaside effect e.g.see section2.
.ontheotherhandaretoolsthatguaranteetogenerate safe patches but do so at the expense of scalability or repairability.
forexample memfix cansafelyfixmemoryleaks use afterfrees and double frees but is applicable only to small programs 5kloc .
leakfix another safe fixing tool is scalable but limitedtofixingsimplememory leaks havingarelativelylowfix rate e.g.
for gnu utilities .
all of these shortcomings of existing techniques make them inappropriate for practical use.
ourapproach .inthispaper wepresentsaver ascalable precise andsafetechniqueforautomaticallyfixingmemoryerrors.to guaranteesafety saverusesasoundprogramverificationtechniqueandproducespatchesonlywhenitisconfidentthattheerrorgetsfixedwithoutviolatingothersafetyconditions.toachievehigh repairability saver supportsvariousfixingstrategies including conditional deallocation and relocation of pointer dereferences.
to thisend weproposeanewrepresentationoftheprogramcalled objectflowgraph whichisalabeledgraphsummarizingtheprogram s heap related behavior using a static heap analysis.
the key techni cal novelty is to formulate the problem of fixing memory errors as a labeling problem over object flow graph and present an efficient algorithm for finding correct labels.
for scalability saver applies theaforementionedanalysisandverificationtechniquesselectively and locally.
the analysis is selective as it uses expensive abstractions e.g.
path sensitivity only when so benefits.
also only a fraction of the input program is analyzed by effectively slicing out the program with respect to the target error.
the experimental results show that saver is a practical tool significantly outperforming existing techniques.
we implemented ieee acm 42nd international conference on software engineering icse 1intappend data node node int ndata 2if !
node n malloc sizeof node return failed to be appended 4n data ndata 5n next node next node next n 6return0 successfully appended 9node lx ... a linked list 10node ly ... a linked list 11for node node lx node !
null node node next 12int dptr malloc sizeof int 13if !dptr return dptr node data append data ly dptr potential memory leak if append data ly dptr free dptr figure a memory leak error line and the savergenerated patch line .
saver as a stand alone tool that can be combined with off the shelf memory error detectors e.g.
.
inourevaluation weusedinfer astate of the artstaticanalyzer deployed within facebook which supports memoryleak detection for c programs.
for open source programs kloc infer reported memory leak errors with falsealarms.
saver successfully fixed out of the true alarms achieving a fix rate and did not attempt to fix false alarms.
ontheotherhand footpatch theexistingstate of the art fixed out of the memory leaks leading to a fix rate.
in so footpatch generated unsafe patches introducing new double freesoruse after frees.footpatchgenerated26patches forfalsealarmsaswell ofwhich25wereunsafe.wealsoevaluated the effectiveness of saver for fixing use after frees and double frees by conducting case studies with open source projects in the wild where saver was able to correctly fix out of errors.
contributions.
this paper makes the following contributions we present a new technique for fixing memory errors.
the keyideaistoconstructanobjectflowgraphviastaticanalysis and generate a patch by finding correct labels.
we present saver a practical and publicly available tool implementing the proposed approach.
we demonstrate the effectiveness of saver in realistic settings by comparing it with existing state of the arts.
overview we illustrate key features of saver and how it works.
.
motivating examples example1 .figure1describesasimplifiedmemory leakerror intheopen sourceprogram snort whichcanbedetectedbythe infer static analyzer with the following error report cleanup list of objects to be deallocated 2structnode first null 3for ... 4structnode new xmalloc sizeof new 5make cleanup new add new to the cleanup list 6new name ... ... 8if ... first new tmp first name continue potential use after free first name if first null new name !
first name if first null new name !
tmp continue 17do cleanups deallocate all objects in cleanup figure a use after free error line and the saver generated patch lines and .
object allocated at line is unreachable at line .
globalvariables lxandlyatlines9and10arepointerstolinked lists.atline11 theloopiteratesoverthelist lx.ateachiterationof the loop a new data object is allocated line and the data of the currentnodeiscopiedtotheallocatedobject line14 .atline15 the function call append data ly dptr stores the allocated object dptr in the list lyas its first element.
the function append data returns if the data is stored successfully line .
however it returns when the data object fails to be appended to ly line .
a memory leak error occurs in the latter case when append data fails the object allocated at line becomes unreachable from the environment at the next iteration of the loop since the pointer variabledptrgets assigned a newly allocated object.
given the program snort kloc and the error report such as the one produced by infer saver automatically generates the patchatline16.itreplacesthecallto append data atline15bythe conditional statement given at line correctly deallocating the object dptr onlywhen append data failstostoretheobjectinthe listly.
saver does so by inferring the program invariant that the allocated object dptr at each loop iteration becomes unreachable whenappend data returns 1and thus deallocating the object under this condition is always safe.
bycontrast footpatch memfix andleakfix fail to correctly fix the error in figure .
in particular footpatch produces an unsafe patch by simply inserting free dptr after line without checking the return value of append data which removes the reported memory leak but introduces a more deadlyuse after free error when the elements of list lyare used later .
safefixingtools memfixandleakfix arenotscalableorrobust enoughtoanalyze320klinesofcode.still theywouldfailevenwithouttheseissuesbecausetheiruseislimitedtoproducingpatches without conditionals.
note that the error in figure is never fixed 272without introducing a new conditional statement.
for example insertingfree ndata betweenlines2and3causesuse after freein snortasappend data iscalledatmultipleplaceswheretheobject pointed to by ndatais used even when the return value is e.g.
for printing the error code which we omitted in figure .
example2 .figure2showsatrickyuse after freeerror .instead of using primitive deallocators e.g.
free the program uses themake cleanup anddo cleanups functionsasaspecialmechanismformemorymanagement.thecodemaintainsagloballist calledcleanup which holds memory objects to be deallocated.
function make cleanup isusedtoappendanobjecttothe cleanup list anddo cleanups deallocates all objects in it.
theuse after free erroroccursas follows.at thefirstiteration of the loop a newobject is allocated at line and its address is stored in the cleanup list by calling make cleanup new at line .
supposethetruebranchofthefirstconditionalatline8istaken whereanewalias first fortheallocatedobjectismade line9 .
the heap can be depicted as follows cleanup newo1 cleanup newfirsto1 the left and right diagrams show the heap right after lines and respectively.
in each diagram oirepresents the object allocated at thei thiterationoftheloop.intheseconditerationoftheloop a newobject o2isallocatedandappendedtolist cleanup andfirst still refers to o1as depicted in the left diagram below cleanup first newo1o2 cleanup first newo1o2 nowassumethatwetakethefalsebranchesofbothconditionals atlines8and14andreachthecallto do cleanups atline17.once do cleanups iscalled both o1ando2aredeallocatedasdepicted with the shaded boxes in the right diagram.
in addition the link fromcleanup too1is removed.
at the third iteration suppose we take the false branch of the conditional at line .
then we reach the second conditional line with the following heap cleanup first newo1o2o3 sincefirstholdsanon null dangling pointer theright handside ofthedisjunctionisevaluated wherethedereference first name causes the program to crash as the object o1is already deallocated.
saver fixes this error by moving the dereference expression first name from line to storing its value in a temporary variable tmp andreplaces first name atline14by tmpasshown at line .
note that this patch correctly eliminates the use afterfreeerrorbecausethepointer firstisnolongerdereferencedat line and dereferencing firstat line is safe as the object is not yet deallocated.
note also that moving first name from line 14to10doesnotchangethemeaningoftheprogram.saver ensuresthisbycheckingthatthevaluesof tmpandfirst name are always equivalent in the second disjunct at line regardless of program executions.
indeed the saver generated patch in this case is exactly the same as the developer patch.
the saver s ability to fix such an error is clearly beyond the reachoftheexistingtechniques.footpatch memfix andleakfix attempt to fix memory errors only by inserting or deleting1p malloc o1 2if c 3q p 4else 5q malloc o2 p 7free q a example codeentry exit1 true o1 c o1 c o1 c o15 c o2 c o2 c o23 c o1 c o1 c o1allocalloc use free unreach use unreach free unreach b object flow graph figure example program and object flow graph deallocators without conditionals .
however it is impossible to fix the use after free error described above with this strategy because thereisnowaytodeallocateanunboundednumberofobjectswith a finite number of primitive deallocators.
.
how saver works nowweoverviewhowsaver works.considerthememoryleak error in figure 5a the object o1allocated at line is not freed whenthefalsebranchoftheconditionalistaken.tofixtheerror saver inserts if c free p before line .
saver generates the patch with the following three steps.
step1 constructingobjectflowgraph .first saverrunsa static heap analysis to convert the input program into the objectflow graph ofg in figure 5b.
a vertex of the ofg represents aheap object at a certain program point and a path condition.
forexample vertex c o1 denotes the object o1available at line whenthetruebranch c istakenduringprogramexecutionand c o1 represents the same object o1at line when the false branch c istaken.anedgerepresentstheprogram scontrolflow labeled with events that could occur for the destination object.
for example edge c o1 free c o1 indicates that the object o1is freedwhenitflowsfromline6to7underthecondition candedge c o1 c o1 indicatesthatnoeventsoccurfor o1under thecondition c.thisway theofgsummarizesthebehaviorof all heap allocated objects both o1ando2 in the program.
step2 relabelingobjectflowgraph .next saver attempts tofixtheerrorbyrelabelingtheobjectflowgraph.notethatthe memory leak is captured by the red path in the middle of the ofg concatenating labels over the path produces the string of events alloc use unreach whichindicatesthattheobject o1isallocatedandusedalongthe path but it becomes unreachable without being freed.
to eliminate thismemory leakpattern saver replacestheemptylabel of theedge c o1 c o1 bythe freelabel producingthe following correct usage pattern of heap objects alloc use free unreach notethatitisunsafetoreplacethefirst byfree asitintroduces a use after free pattern alloc free use unreach which is 273use free unreach freeunreach a inserting free free free unreach b relocating free use free use c relocating use dereference free free d deleting free figure fixing strategies that saver supports absent in the original ofg.
saver supports four types of labeling strategies inserting frees deleting frees andrelocating usesand frees.
figure shows example applications of these strategies for eliminatingerrorpatterns.forexample saver usesthestrategy relocating use infigure6ctofixtheuse after freeerrorinfigure2.
step generating a patch .the last step is to generate the patch if c free p fromthenewlylabelededge c o1 free c o1 .
the patch location is between lines and .
the conditional expression c of the patch comes from the path condition of the destination object.
the pointer expression pcomes from the points toinformationwhichissupposedtobeassociatedwitheach vertex but omitted for simplicity in this example.
approach details the high level idea described in section .
is simple but implementing it for real programs is not straightforward.
in this section we describe our approach in detail explaining what technical issuesariseandhowweaddressthem.thefirstissueisefficiency.in reality errorsoftenspanmultiplepathsandweneedtofinda set of labeling operations from a large search space.
in section .
we explainthisissueandpresentanalgorithmbasedonspacereduction and pruning.
also section .
describes our design choices for cost effectiveheapanalysis.
thesecondissueissafety.ensuring safetyrequiresexactreasoningaboutprogramsemantics.however any static analysis results are inexact so care is needed when relabelingobjectflowgraph section3.
andtransformingtheresult into actual patches section .
.
program and error report .let us first define programs and error reports which are given as input to saver.
thefirstinputtosaverisaprogram prepresentedbyacontrol flow graph c arrowhookleft ce cx wherecdenotes the set of program points arrowhookleft c cisthesetofflowedges and ceandcxarethe entry and exit points of the program.
a program point c cis associated with a command denoted cmd c cmd x y x y x y alloc x free x assume b b x n x nequaln x y x nequaly a command is either copy x y load x y store x y heapallocation alloc x deallocation free x or assume b wherebdenotesabranchcondition.althoughweconsiderasimple pointerlanguagewithoutfunctionsforpresentation saverworks in interprocedural settings and supports the full c language.
the second is an error report r c1 ev1 c2 ev2 wherec1 andc2are program points and ev1andev2areevents.
we call c1 ev1 and c2 ev2 sourceandsink respectively.memoryerrors are specified with five types of events ev1 ev2 event alloc free use def unreach .
for example the following memory leak alarm reported by a static analyzer e.g.
infer an object allocated at line is unreachable at line is represented by alloc unreach .
note that ev1andev2determinetheerrortype memoryleak double free anduse after free are represented by c1 alloc c2 unreach c1 free c2 free and c1 free c2 use def respectively.
.
step constructing object flow graph the first step of saver is to construct an object flow graph by statically analyzing the heap related behavior of the program.
static heap analysis .asobjectflowgraphsplaykeyrolesin ourapproach wehavecarefullydesignedastaticheapanalysisthat can generate precise object flow graphs in practice.
the key design decisions are path sensitivity and heap abstraction.
when fixing anerror itisimportanttoisolatetheerrorpathfromthenormal executionpaths.tothisend wedevelopedapath sensitiveanalysis that uses relational invariants as the path information and merges them selectively for scalability.
also dynamic data structures such as linked lists are used extensively in real world c programs.
to accuratelydistinguishthememoryobjectsstoredindatastructures fromthoseoutside werepresenteachheapobjectbyapairofits allocation site and variables that must point to the object.
the abstract domain of the analysis is defined as follows a d c p state s state pc store pc p var nequal var z store loc p heap l loc var heap h heap allocsite p var a allocsite c adomainelement a disafinitetablethatmapseachprogram point to a set of reachable states.
a state s stateat program point c cconsists of a path condition pc and a store store .thepathcondition isacollectionofbranches that have been taken up to the program point c where a single branch denotes a relation between two variables or a variable and a number .
the store is a map from locations to heap objects representing the may point to information.
a location l locis either a variable or of a heap object.
we represent a heap object h heapbyitsallocationsite allocsite andasetofmust point to variables p var .
theaimofthestaticanalysisistocomputealeastfixedpoint lfpf of the semantic function f d ddefined as follows f x c.fc parenleftbig uniondisplay c prime arrowhookleft cx c prime parenrightbig wherefc p state p state is the transfer function at c fc s fpc c fstore c s .
274we update path conditions by fpcc pc pcas follows fpc c b cmd c assume b kill x cmd c x y kill x cmd c x y otherwise where kill x x prime x prime prime x x prime x x prime prime x prime n x x prime denotestherelationsthatarekilled.weupdatestores byfstorecas follows fstore c tc parenleftbig c reach c parenrightbig which first computes the effect of the command c store store projectsthestoresonthereachablelocations i.e.
reach lfp r.var l l prime l prime r and renames the locations in stores i.e.
tc unionsqtext l h where each location is updated by c loc loc .
stores are updated as follows c cmd c alloc x cmd c x y cmd c x y s x mapsto y cmd c x y otherwise where s x a x x x x is a set of strong updatable locationsandw x x sisasetofweak updatablelocations and and mean strong and weak updates to locations x respectively.
the variables in objects are updated by c a x a x x cmd c alloc x orx y a x x x y x cmd c x y a x otherwise whereweassume cdoesnotremove xfromxwhen a x wascreated by cwhencmd c allocx.
when the location is avariable we define c x x .
objectflowgraph .leta lfpfbetheresultofthestaticheap analysis.
from the program p c arrowhookleft ce cx and the analysis resulta weconstruct anobjectflowgraph.anobject flowgraph g v e m consists of four components v c pc heap e v v m v p exp e event wherevisthesetofvertices eisthesetofedges mmapsvertices to points to expressions and denotes the labels of the graph.
we generate the vertices vas follows v c h c c ce cx a c h range ce true cx true a vertex is a triple c h of a program point c a path condition andaheapobject h .ateachprogrampoint c c weconsider every reachable state and generate a vertex c h for each accessible heap object h i.e.h range .
also vincludes two specialvertices theentry ce true andexit cx true ofthe object flow graph where truemeans the empty path condition and a dummy heap object.edgesearegeneratedbasedontheabstractsemanticsoftheheap analysis.thatis eincludes c1 1 h1 c2 2 h2 if c1 1 h1 generates c2 2 h2 during the analysis c1 arrowhookleft c2 2 fpc c2 1 h2 c2 h1 .
inaddition eincludesedgesfromtheentry ce true totheverticeswithoutpredecessorsandfromtheverticeswithoutsuccessors to the exit cx true .
the map massociates each vertex i.e.
heap object with the pointer expressions that may evaluate to the object m c h e exp a c h .
whereexpis the set of finite access paths i.e.
exp x x x var forourlanguage and store p heap istheevaluation function for pointer expressions defined as follows x uniondisplay l l x .
the map labels the graph with events c1 1 h1 c2 2 h2 alloc ifcmd c alloc x h2 c2 x free ifcmd c2 free x x m c2 2 h2 def ifcmd c2 x y x m c2 2 h2 use ifcmd c2 x y y m c2 2 h2 unreach if c2 2 h2 cx true empty event otherwise theedge c1 1 h1 c2 2 h2 islabeledas allocifc2isthecommand thatallocates the heap object h2 that is cmd c2 isalloc x andh2is pointed to by the variable x .
we label the edge as freeif c2may deallocate the heap object h2.
in our implementation we distinguish may freeand must freeevents to more precisely check thesafetyofpatchesinthenextsubsectionbuthereweomitthis detail for simplicity.
labels defanduseare given when the heap h2isdefinedorread respectively.finally theedgegetsthelabel unreachwhen the heap h2is no longer accessible.
.
step relabeling object flow graph the second step of saver is to relabel the object flow graph g v e m so that the reported error r c1 ev1 c2 ev2 is eliminated with the new labeling.
errorpaths .wefirstneedtoconverttheerrorreporttoasetof errorpathsontheobjectflowgraph.let vc1ev2andvc2ev2bethevertices ingthatcorrespondtothesource c1 ev1 andsink c2 ev2 ofthe error report respectively vc1ev1 v v v c1 v prime.
v prime v e v prime v ev1 vc2ev2 v v v c2 v prime.
v prime v e v prime v ev2 letpaths g be the set of all paths in g. given a path p e1 en a sequence of edges we write p for e1 en the concatenation of labels .
the set of error paths ep g r is as follows ep g r p paths g p0 p turnstileright vc1ev1 vc2ev2 p rev1ev2 wherep0andp turnstilerightdenotethedestinationpointsofthefirstandlast edges ofp respectively and rev1ev2denotes the set of strings over 275events that represent the error specified by the source and sink events.
for each error type we define rev1ev2by regular expressions ralloc unreach alloc use def unreach rfree free free free rfree use rfree def free use def the meaning is intuitive.
ralloc unreachdescribes memory leak patterns amemoryleakerroroccursifanallocatedobjectbecomesunreachable without being deallocated.
rfree freeandrfreeuse orrfree def describe double free and use after free patterns respectively.
labeling operators .we relabel the graph with labeling operators.alabelingoperatorisafunctionthattransformsthelabelmap of the object flow graph.
labeling operators have four types free e e mapsto free if e free e e mapsto if e free free leadsto e1 e2 e1 mapsto e2 mapsto free if e1 free e2 use leadsto e1 e2 e1 mapsto e2 mapsto use if e1 use e2 thefree eoperatorreplacesthelabelofedge ebyfreeifehasthe emptylabel .the free eoperatorremovesthe freelabelofe.the free leadstoe1 e2anduse leadstoe1 e2operatorsmovethe freeanduselabelsfrom e1toe2 respectively.weassumethelabelingoperatorsactasan identity function if the conditions given on the right hand side are not met.
given a set o o1 ... on of labeling operators wewriteo forthenewlabelmapobtainedbyapplyingevery labeling operator oito i.e.
o o1 on .
finding labeling operators .our goal is to find a set oof labelingoperatorsthatcanremovetheerrorpathsintheoriginal object flow graph.
let g prime v e m o be the object flow graph whose labels are replaced by o. we need to findowith the following properties the reported error does not appear in g prime i.e.
ep g prime r .
no newerrors which areabsent in g areintroduced in g prime.
ois semantics preserving fixing an error does not cause the program to behave differently in normal execution.
algorithm.
ouralgorithmtosearchforthelabelingoperators osatisfying the three conditions is given in algorithm .
given the object flow graph gand error report r the algorithm produces a setcof all possible solutions where a solution corresponds to asetoflabelingoperatorsmeetingtheconditions.thealgorithm uses a worklist wthat is a set of pairs each pair o s consists ofa solutioncandidate oanda search space s. the search space is initialized at line where initsearchspace g r determines the setofsearchspacesthatareappropriateforfixingtheerror r.at line we pop a work item o s and remove it from the worklist.
we relabel the graph gwith the current solution o line and generate the new graph g prime.i fg primedoes not contain the error r line weincludeoininthesolutionset c line7 .atline9 wereduce thesearchspacebypruningoutlabelingoperatorsin sthatbecome unsafeunderthenewlabeling g prime .whentheresultingsearchspace s primeisempty line10 thealgorithmmovesontootherworkitems line11 .otherwise itselectsanoperator ofroms primeandbranches onobyaddingnewitems o o s prime prime and o s prime prime totheworklist.the algorithm repeats the procedure until the worklist becomes emptyorhitsapredefinedtimelimit.below wedescribethetwo key components initsearchspace andsafe.
weinitializesearchspacesbasedontheerrortype.recallthat wehavefourtypesoflabelingoperators free e free e free leadstoe1 e2 and use leadstoe1 e2.whenr c1 ev1 c2 ev2 indicatesamemory leak i.e.
ev1 alloc ev2 unreach we use free eandfree leadstoe1 e2 meaning that we attempt to fix memory leaks by inserting or relocatingdeallocation statements.
we fix double free errors by removingdeallocation statements free e .
for use after free errors we attempttorelocatestatementsthatdeallocateorusethetargetobject free leadstoe1 e2 use leadstoe1 e2 .
formally initsearchspace is defined as initsearchspace g c1 ev1 c2 ev2 s ml free sml free leadsto ifev1 alloc ev2 unreach sdf free ifev1 free ev2 free suaf free leadsto suaf use leadsto ifev1 free ev2 use ev2 def wheresml free sml free leadsto sdf free suaf free leadsto andsuaf use leadstoare search spaces for memory leak ml double free df and use after free uaf sml free free e e e e e ep g r sml free leadsto free leadsto e1 e2 e1 e2 e e1 free e2 e1 nelementep g r e2 ep g r sdf free free e e e e free e ep g r suaf free leadsto free leadsto e1 e2 e1 e2 e e1 free e2 e1 ep g r e2 nelementep g r e1 leadstoe2 suaf use leadsto use leadsto e1 e2 e1 e2 e e1 use e2 e1 ep g r e2 nelementep g r e2 leadstoe1 whendefiningthesesearchspaces wedonotconsideroperators thatareirrelevanttothecurrenterrorreport r.forexample when fixing a memory leak error c1 alloc c2 unreach by inserting a deallocationstatement free e thelocation e mustbecontained intheerrorpaths ep g r .thus weexcludeallthe free eoperators from the search space whose location e is on the outside of the error paths.
we apply similar rules for other error types too.
the safe g o predicate checks whether the new labels of g obtained by applying the labeling operator otogintroduces no newerrors safe ornot.wecheckthissafetyofalabelingoperator basedongraphreachability.let eevbetheedgesof gwhoselabels are equivalent to ev leadstobe the reachability relation for g e1 leadstoe2 iffe2isreachablefrom e1 ande1 precedesequaldomeande1 precedesequalpostdomebethe factsthatthe edgeset e1collectively dominateandpost dominate the edgee respectively.
then we define safe g o for each type of o. when inserting a deallocation statement o free e we check if so does not introduce new double free or use after free errors.
this safety condition can be expressed as follows e prime efree e .e prime negationslash leadstoe e prime efree euse edef.e negationslash leadstoe prime.
wheno free e weneedtoensurethatnomemoryleakerrorsare introduced efree precedesequaldome efree precedesequalpostdomewheno free leadstoe1 e2 we 276algorithm finding labeling operators input object flow graph gand error report r output a setc o1 ... on of sets of labeling operators c w s s initsearchspace g r repeat o s wrest pop a work item from w g prime o g relabelgwitho ifep g prime r then rdoes not appear in g prime c c o addotocas a solution end if s prime o s safe g prime o prune out unsafe operators ifs prime then w wrest else o s prime prime pop a labeling operator from s prime w wrest o o s prime prime o s prime prime end if untilw or timeout returnc check the condition efree e2 precedesequaldome1 efree e2 precedesequalpostdome1 e efree e1 e2 .e1 negationslash leadstoe2 e efree euse edef e1 .e2 negationslash leadstoe1 wherethefirstlineensurestheabsenceofmemoryleak thesecond linechecksdouble free andthethirdlineguaranteesnodouble free anduse after freeerrorsareintroduced.
intheaboveconditions ourimplementationdistinguishesmay freeandmust freeevents formoreprecisesafetyguarantees whichisomittedhereforsimplicity.
finally when o use leadstoe1 e2 weneedtoensurethatnouseafter freeerrors areintroduced e efree.e negationslash leadstoe2 and relocating usedoes not cause the program to have different semantics e edef.e2 leadstoe e leadstoe1 e2 precedesequaldome1 wecheckthesemantics preservingpropertybyensuringthatno definitions exist between e1ande2ande2dominates e1.
note that our algorithm produces a set cof solutions such that eachsolutiono cconsistsoflabelingoperatorsofthesametype.
forexample asingle odoesnotcontainboth free e1andfree e2.w e made this design choice because this single type restriction does notimpairtherepairabilityofouralgorithmtoomuchbutimproves its efficiency significantly.
without this restriction even unsafe operators may become safe as the algorithm progresses.
for example consider the path v1 v2free v3 where the operator free v1 v2 is unsafe at the moment but it becomes safe when free v2 v3 is allowedlater.thus weshouldconsiderallthepossiblecombinationsofthelabelingoperatorsineachsearchspace whichcanbe avoided with the restriction as unsafe operators never become safe.
.
step generating a patch the last step of saver is to generate a patch from the set cof labeling operator sets produced by algorithm .
when c saver failsto fixtheerrorand reportthatfailure.otherwise weconsidereachoperatorset o candtrytoconvertittoapatch.
when the conversion is successful saver returns the resulting patchasitsfinaloutcome.if oisnotconvertible wemoveonto the next candidate o prime c. if no operators in care convertible saver fails to generate a patch.
next wedescribehowtoconvertaset oofoperatorsintoapatch.
basically weconverteachlabelingoperatorin ointoaconditional deallocator using the path condition and expression obtained from the object flow graph.
we explain the detail depending on the typeofoperatorsin o.supposeo free e1 ... free en .wefirst partitionobasedonprogrampointsusingtheequivalencerelation free ei free ej dest ei dest ej wheredest c cextractsthedestinationprogrampoint from the given edge.
let qbe the set of all equivalence classes associated with corresponding program points q dest e o o o free e o whereo denotes the quotient set of oby .
now we convert each partition ci oi qinto the conditional deallocator if i free expi andputitattheprogrampoint ciofinputtheprogram.thepath condition iis collected from the object flow graph as follows i logicalordisplay j vi j whereviis the set of the destination objects i.e.
vi v free e oi e v .wechooseansafeexpression expifromthemap mof the object flow graph such that expimay point to the objects invibut never points to other objects at ci exp intersectiondisplay v vim v exp nelement uniondisplay v prime i vim v wherev prime iis the set of all objects available at ciwhose path conditions are compatible with i v prime i ci prime v i primeis satisfiable .ifnoexpressionssatisfyingtheconditionareavailable the current partition ci oi is not convertible and so is o. other cases are simpler because we do not need to synthesize theexpression expi .wheno free e1 ... free en wetakethe same steps described above to obtain ifor each partition ci oi but in this case we insert if i free expi atciafter deleting thedeallocation statementoriginallylocated at ci.here wereuse the expression expiof the original deallocator.
wheno free leadsto e1 e prime ... free leadsto en e primen we take similar steps but partitionowith the following equivalence relation free leadsto ei e prime i free leadsto ej e prime j dest ei dest ej dest e prime i dest e prime j which results in the partitions q c1 c prime o1 ... cn c primen on .
weconverteach ci c prime i oi intoapatchbyremovingtheoriginal deallocatorat ci inserting if i free expi atci andinserting if prime i free expi atc prime i. here the path conditions iand prime i are obtained with respect to ciandc prime i respectively in a similar way described above.
the expression expicomes from the original deallocatorat ci.wheno use leadsto e1 e prime ... use leadsto en e primen wesimilarly compute q c1 c prime o1 ... cn c primen on .
for each ci c prime i oi we obtain the path conditions iand prime iand generate a patch by 277replacingtheloadcommand x yatcibyif i x telse x ywith a fresh variable t and put if prime i t yatc prime i. .
improving scalability thecorealgorithmdescribedsofarisabletogenerateexpressive yetsafepatchesbutisnotapplicabletolargeprograms.inpractice we use two techniques to improve its scalability.
slicing.we slice the input program with respect to the given errorreport r c1 ev1 c2 ev2 .weusethistechniquetoreduce the cost of applying saver in interprocedural settings.
let fsrc andfsinkbethefunctionsthatcontainthesource c1 andsink c2 programpoints.wefirstfindthefunction fparentthatisthenearest common caller of fsrcandfsinkon the call graph of the program.
the function fparentbecomes the entry point of the saver s heap analysis slicing out all functions in the program that are unreachablefrom fparent.often theresultingslicedprogramisnotsmall enough to be analyzed.
thus we use a pre analysis a contextsensitive and flow insensitive points to analysis to further slice out the functions that do not have side effects on the heap objects that have dependencies on the objects specified by the error report r. we also slice out large recursive functions as well which are expensive to analyze but so provides little precision bene fit.
in place of the functions sliced out we use the result of thepre analysis to preserve the soundness of the heap analysis.
for example saver starts from fparentwith the pre analysis result.
selective path sensitivity .it is well known that applying expensive abstractions selectively is critical for obtaining cost effective static analysis .
in our case we apply path sensitivity of the static heap analysis only when sois likely to improve the final fix rates.
to support selective pathsensitivity we modify the definition of the semantic function fas follows f x c.merge parenleftbig fc parenleftbig uniondisplay c prime arrowhookleft cx c prime parenrightbig parenrightbig where merge s unionsqtexts prime s prime s mergable partitions the statessand merges each partition into a single state with the equivalence relation mergable state state.
when two states 1 1 2 2 are joined the path condition is generalized i.e.
1 2 andthepoints toinformationiscombined i.e.
1 unionsq 2 .we define two states are mergeable if they are equivalent with respect to thesetofnull pointing variables thesetofvariablespoint ingtoaliasedobjects and thesetofpairsofreturnvariablesand their values.
we designed these three criteria since they capture thekeyfeaturesofprogramexecutionsrelatedtomemoryerrors and help to analyze normal executions precisely while merging erroneous paths.
the first feature describes a set of variables only pointing to null which captures execution paths along which apointer is nullified or failed to be allocated.
the second featureindicates whether objects are appended to a data structure suchas lists or not.
the third feature is to distinguish between states withdifferentreturnvalueswhichareusuallyusedasasignalof memory errors.
evaluation inthissection weevaluatesaver.themainobjectiveistoseehoweffectivelysavercanfixmemoryerrorsinpracticeandcompareit with existing techniques sections .
.
in addition we discuss the importanceofthetechniquesforimprovingscalability section4.
.
allexperiments weredone onavirtual machinerunning ubuntu16.04with4virtualcpusand32gbmemory poweredbyintelcore i7 processor.
implementation .weimplementedsaverasastand alonetool in lines of ocaml code.
we used the front end of infer whichtranslatescprogramsintoanintermediaterepresentation called sil .
we used cfa for the pre analysis in section .
and full context sensitivity except for recursion for the heap analysis in section .
.
for common memory related standard libraries e.g.
memcpy strdup we used hand crafted models to consider their effectsduringtheheapanalysis.modelinglibraryfunctionsdidnotrequiresignificanteffort.wemodeled14standardlibraryfunctions 10ofwhichcouldbesimplymodeledintermsofthemalloc free or exit functions.
we wrote the body of the remaining library functions.otherstaticapproaches alsorequirehand crafted models.
for example footpatch uses the models provided by infer.
we set the timeout of algorithm to minutes.
the implementation of saver is safe in principle.
our implementationofthestaticheapanalysisinsection3.1andpre analysisinsection3.4supportsthefullintermediatelanguageanditsseman tics.notethatinaccurate incomplete heapanalysisorpre analysis may cause lower fix rates but they never harm safety.
similarly usingtheoptimization techniquesinsection3.4maycause lower fix ratesbutneverharmsafety.otherimplementationchoicesdo notaffectsafetytoo.context sensitivityandtimeoutonlyaffectfix rates.thelibrarymodelscaptureallrelevantheap effects.nonetheless saver might produce unsafe patches due to the following issues.
ourheapanalysisassumesthatunknownprocedurecalls e.g.
librarycallswithoutmodeling returnsarbitraryvaluewithout side effects.theanalysisalsoignoreslow levelpointerarithmeticsthatbreakthetypicalassumptionsofasimplememorymodel.also the front end of infer may fail to handle some functions due to engineeringissues.thesearepotentialsourcesofunsafepatches though we observed no such cases in experiments.
.
effectiveness for fixing errors recallthatouroriginalmotivationistocombinesaverwithstatic bug finders sothaterrorsarenotonlyfoundbutalsofixedautomatically.
to demonstrate this we used the memory leak detector of infer anopen sourcetooldeployedwithinfacebook and compare saver and footpatch in this context.
we used infer .
.
since footpatch is implemented on top of it.
setup.weused10open sourcecprogramsshowninthefirst column of table .
the three programs rappel swoole and lxc came from since they were used for evaluating footpatch regardingmemoryleaks.
inaddition wecollected7benchmarksfromgithub.wesearchedprogramssuchthat1 inferproducesnobuild errors and2 reports atleast truepositive and 100total alarms foreaseofmanualinspection .wealsotriedtocollectbenchmarks 278table1 comparisonofsaverandfootpatchonfixingmemoryleaksdetectedbyinfer.foreachprogram tand fdenote thenumbersoftrueandfalsealarms i.e.errorreports producedbyinfer respectively.
pre s reportsthetimetakenbythe pre analysis of saver pre analysis is run only once and its result is shared by every error fix .
fix s reports the total time taken by each tool in attempting to fix the reported errors.
the patch statistics are given in columns g triangleand where the subscripts t and f indicate whether the result is for true or false alarms respectively.
g of generated patches.
of successful patches that fixed errors without introducing new errors .
triangle of incomplete patches that are safe but fail to completely fix errors.
of unsafe patches that introduce new errors.
infer saver footpatch program kloc t f pre s fix s gt t trianglet tgf ffix s gt t trianglet tgf f rappel ad8efd7 .
.
.
.
flex d3de49f .
.
.
.
1wavpack 22977b2 .
.
.
.
2swoole a4256e4 .
.
.
.
1lxc 72cc48f .
.
.
.
1p11 kit ead7ara .
.
.
.
2x264 d4099dd .
.
.
.
0recutils .
.
.
.
.
inetutils .
.
.
.
.
.
0snort .
.
.
.
.
.
total .
.
.
.
from diverse domains network inetutils text processing flex recutils multimedia wavpack x264 andsecurity p11 kit snort .
running infer on those programs produced a total of alarms.
we manually classified the alarms into true and false positives.
then we automatically converted each alarm into an errorreportforsaver.weincludedfalsepositivesaswellinour evaluation becauseweassumeausecaseofrepairtoolsincombinationwithstaticbug findersinanend to endwaywithoutrequiring humans to classify static analysis alarms into true or false.
when running infer we enabled the headers option to analyzeheaderfilesaswell.withoutthisoption inferskipstranslating headers into ir which results in imprecision and increases false alarms.thisiswhythenumber ofalarmsforswooleintable1 is less than that reported in .
in table we compared saver with footpatch only since other tools memfix and leakfix were not scalable or robustenoughtoanalyzethebenchmarkprograms.memfixdidnotterminateforthebenchmarkprogramsexceptforrappel forwhich it successfully fixed the reported error.
leakfix also ran on rappel butproducednopatches.forotherprograms leakfixproduced runtime errors.
we ran footpatch in its global mode to allow it todiscover more patch candidatesfrom the entireprogram.
we obtained footpatch from its public website.
foreachpatchgeneratedbysaverandfootpatch wemanually checked whether the patch fixed the target error correctly.for true alarms we say a patch is correct t i fi tr e m o v e st h e reported memory leak alarm completely e.g.
fixing all memory leaks betweenthe source and sinkpoints specified byeach alarm and introduces no new errors.
if the generated patch introduces anewerror wecounteditasunsafe t f .theremainingcase i.e.
thepatchissafebutfailstofixtheerrorcompletely iscounted as incomplete trianglet .
shows the experimental results.
for the true positives saver generated patches.
among them were correct and fixed errors completely leading to a fix rate .
onekeycontributortothishighfixratewastheabilitytogenerate conditional patches.
for example all of the correct patches for snort .
.
involve conditional.
itisnotablethatsavergeneratednopatchesforfalsealarms.
this is mainly because saver aims to ensure the patch safety inmostcases savernaturallyfailsto fix falsealarmsbecause otherwiseitneedstofindawaytomodifyaprogramthatisalreadycorrectwithoutintroducingerrors whichismuchmorechallenging than transforming an incorrect program into correct one.
meanwhile footpatchgenerated26patchesfortruealarms ofwhichwerecorrect leadingtoa20 fixrate .theremaining7patcheswereclassifiedinto2incompleteand5unsafeones introducinguse after freesordouble frees .forthe66falsealarms footpatch generated patches where were unsafe.
note that mostofthefalsealarmpatchesareunsafe implyingthat fixing false alarms correctly is challenging in practice and a practical tool needstoensuresafetytoavoidit.intotal footpatchgenerated 52patchesforall162 trueandfalse alarmsand30 ofthem were unsafe and introduced new errors.
eachof saverandfootpatchgeneratedoneincompletepatch.
saver failed to completely fix an error in snort .
.
.
consider the following simplified situation 1intf void p 2if ... return0 memory leak 3if ... return memory leak 4return0 no memory leak 5intg void p 6x f p objects pointed by p are used saver if x free p 279table effectiveness for use after frees and double frees.
programavg.
kloctime s uaf df c c lxc .
.
0p11 kit .
.
2grub .
.
total .
.
where the function fcan return with and without memory leaks.tofixthis saverinsertedaconditionalpatch if x free p at the end of g which partially eliminates the memory leak error but some leaks still remain.
in this case it would not be possible to fix the memory leak completely without modifying the bodyoffsothatthenormalanderroneouspathsaredistinguished by the associated return values.
footpatch generated one incomplete patch for each of recutils1.8andp11 kitbecauseofitssimplefixingstrategy.forexample the buf new function in rectuils .
allocates a base object whose field is also allocated by buf new both of which cause memory leaks.
however footpatch inserted a single deallocator for the base object and thus failed to free its field object.
by contrast saver identified bothleaky objects andgenerated a correctpath by inserting multiple deallocators.
use after free anddouble free .wealsoevaluatedtheeffectivenessof saver forfixinguse after freesanddouble frees.for thisevaluation weused34errorreportsmanuallycollectedfrom open sourceprojects.wecouldnotuseautomatedbug detectors for this evaluation because infer detected no errors but only producedfalsealarmsforourbenchmarksandwecouldnotfindother alternativetoolspubliclyavailable.wecollectedtheerrorreports fromprojectsthatcontainatleastone use after free uaf and double free df keywordsintheircommitmessagesingithub.
we identified lxc and p11 kit in the memory leak benchmarks and additionally collected grub from gnu projects which had relatively many uaf df commits.
we collected allerror commits from eachprojectandmanuallygenerated34errorreportsbyinspecting commit messages or fixes by developers.
for each report we ran saver on the version of the program where the corresponding error commit was made and manually checked whether a patch fixed the target error correctly.
for some commits we could not use their exact versions because they did notalwayssucceedinbuilding.inthosecaseswetriedtoaddress the build errors by modifying the source codes or injecting the error in question into another commit version without build issues.
if this attempt failed to resolve the issues we instead identified submodules containing relevant parts to the error of each program and compiled only these submodules.
table2showstheexperimentalresult.
avg.kloc reportsaveragedlocsacrosscollectedcommitversionsinarepository.
time s reports total time taken in attempting to fix including the preanalysis of saver the errors in each project.
the number of error commitsfromeachprojectisgivenincolumn c.forthe34useafter freesanddouble frees savercorrectlyfixed15errors a44 fixrate intotalwithoutintroducingnewerrors.saverusedthreestrategiesforfixingthoseerrors.foruse after frees saverfixed11of20errorsbymovingfreeorusestatementsand4of14double free errors by deleting frees.
limitations .our evaluation also identified one major limitation of saver saver often fails to fix errors when they are involved in custom allocators or deallocators.
for example consider the following code snippet describing a double free in lxc 1voidput ctx ctx ctx ... some side effect 3free ctx freed here 5voidclone payload struct s s 6put ctx s init second call ... 9init s init 10put ctx init first call 11clone payload s double free thefunction put ctx isacustomdeallocatorthathasaside effect.
it is first used at line to deallocate the object pointed to by initand then called again at line in the body of the function clone payload .because s initandinitarealiases adoublefree occurs at the second call.
however it is not possible to safely fix this error by removing frees for example at line because thesecondcallto put ctxbecauseitchangesthemeaningofthe program because the side effect is also removed .
therefore such an error cannot be fixed safely with the current fixing strategies of saver.
this was the most frequent failure pattern accounting for more than in table .
.
effectiveness of techniques for scalability wefoundthatthetechniquesforimprovingscalability section3.
are critical components of saver.
in particular the slicing technique reduced the cost dramatically.
for example snort .
.
the largest benchmark has functions but it is sliced to a small programwith14functions .
reduction bythetechnique.also thetechniqueforselectivepath sensitivitywasessentialforachievinghigh fixrates.figure 7comparesthe fixratesof saver after slicing with and without our merge heuristic where full sel andnonrepresentsaver withfullpath sensitivity selectivepathsensitivity and path insensitivity respectively.
the results show that ours sel performs the best among the three modes striking agoodbalancebetweenprecisionandcost.overall selachieves higher fix rates than non and full since non is imprecise and fulloftenfailstogeneratepatcheswithinthetimelimit.thisisbe causeourselectivepath sensitiveanalysisworksinacost effective way it achieved about of the precision of full path sensitivity with of its cost.
.
threats to validity in our evaluation we used open source programs but they may not be representative or are not enough to objectively evaluate the performance of errorrepair tools.
our evaluation focused oncomparing saver with footpatch r egarding memory leaks.
however 280rappelswoolep11 kit lxcx264recutilsinetutils snort050100fix rates full sel non figure fix rates with different path sensitivities thesetwotoolsareincomparableingeneral asfootpatchsupports other types of errors such as null dereference and saver supports use after free and double free.
related work automatedprogramrepair .automatedprogramrepairtechniqueshavereceivedanincreasingamountofattentionfromthe software engineering community in the last decade .
we compare our work with a few major approaches below.
existingrepairtechniquescanbeclassifiedasgeneral purposeor special purpose dependingonwhethertheyaredesignedtofixany kindsor specifickinds oferrors.
saver isa special purposetechniquethatfocusesonfixingmemoryerrorssuchasmemoryleak use after free and double free.
other specialized techniques focus onsafetypolicyviolations buffer integeroverflows nulldereferences concurrencyerrors andenergybugs amongothers.inparticular weimer presenteda techniquesimilartoourstogenerateapatchfortemporalsafetyvi olations suchasresourceleaksandapimisuses.conceptually the technique is also applicable to memory errors.
however applying the technique to memory errors in practice would require nontrivialeffortstoextendthealgorithmtoconsiderpoliciesofmultiple objectssimultaneously whichisessentialforfixingmemoryerrors.
techniques for localizing mitigating and fixing memory errors have been studied extensively as well .
amongthem thedirectly relatedto oursare footpatch memfix andleakfix .footpatchisascalable technique that fixes pointer safety errors such as memory leaks and null dereferences by applying local reasoning based on separation logic.
however footpatch does not ensure safety and mayintroduce new errors as it checks the patch correctness againstthe given error report only.
memfix uses a sound static analysis toalwaysgeneratesafepatchesbutitsuffersfromlowscalability.
leakfix is also a safe fixing tool based on data flow analysis butit focuses on simple patches.
furthermore footpatch memfix and leakfix are unable to produce conditional patches inherently failingtofixdiverseerrorsinpractice.toourknowledge saveristhe first technique for memory errors that achieves high scalability and repairability without compromising on safety.
general purposerepairtechniques are in principle able to repair all types of errors.
most of thesearetest basedtechniques whichusetestcasestoverifythe correctnessofthegeneratedpatches sometechniquesuseprogram verification metamorphictesting orcontracts buta majority of approaches are based on test cases .
general repair techniques are classified into generate and validate and semantics based approaches .
generate andvalidate approaches use search algorithms such as genetic programming to explore the space of candidate patches until it finds one that passes all test cases and accelerate the search processusingmachinelearning orfixtemplates .semanticsbased approaches formulates the patch problem as a constraint satisfaction problem by executing the program symbolicallyandsolvestheproblemwithsmtsolvers.although these approaches are general they are unlikelymore effective than special purposetechniquesforspecificerrors.forexample xuet al.recentlyshowedthataspecializedtechniquecanbesignificantly moreeffectivegeneral purposetechniquesforfixingnullpointer exceptions .
furthermore general test based techniques are inappropriate for fixing memory errors because memory leaks for example cannot be fully specified by theinput output test cases.
also test basedtechniquesareinherentlyunsafeasthetestcases cannot be a complete specification .
bavishi et al.
recently presented a synthesis based technique for fixing static analysis violations which is general but does not guaranteethe patch safety.
compile timememorymanagement .compile time memory management techniques are similarto our work in thatthey automaticallyinsert memorydeallocation statementsin theprogram.forexample tofteandtalpin andaikenetal.
presented region based memory management techniques for functionallanguagestoreducethecostofgarbagecollection.shaham etal.
cheremandrugina andguyeretal.
present staticanalysistechniquesforcompile timememorymanagement for java.
dillig et al.
presented a technique for automating resourcemanagement e.g.networksocket injava.however the primarygoalofthesetechniquesistooptimizeperformance e.g.
reducing space consumption in garbage collected languages such as java and ml.
in contrast our focus in this paper is on fixing errors in programs written in unsafe languages.
conclusion fixingmemoryerrorsistrickybecausenewandmoredeadlyerrors are easily introduced.
in this paper we proposed a new technique that can safely fix such errors in a scalable and precise way.
tothis end we proposed a new repair algorithm based on object flow graphs.we implemented thetechnique as a stand alonetool saver and evaluated its effectiveness with the infer static analyzer.foropen sourceprograms saverwasproventobeeffective in combination with infer it was able to safely fix of thememory leak errors detected by infer demonstrating that this combination can be actually useful in practice.