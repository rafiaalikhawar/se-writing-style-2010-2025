where to start studying type annotation practices in python wuxia jin dinghong zhong zifan ding ming fan ting liu jinwuxia mail.xjtu.edu.cn zhongdh dingzifan19 stu.xjtu.edu.cn mingfan tingliu mail.xjtu.edu.cn school of software engineering xi an jiaotong university xi an china ministry of education key laboratory of intelligent networks and network security xi an jiaotong university abstract dynamic programming languages have been embracing gradual typing which supports optional type annotations in source code.
type annotating a complex and long lastingcodebase is indeed a gradual and expensive process where twoissues have troubled developers.
first there is few guidanceabout how to implement type annotations due to the existenceof non trivial type practices second there is few guidance aboutwhich portion of a codebase should be type annotated first.to address these issues this paper investigates the patternsof non trivial type annotation practices and features of type annotated code files.
our study detected six patterns of type annotation practices which involve recovering and expressingdesign concerns.
moreover we revealed three complementaryfeatures of type annotated files.
besides we implemented atool for studying optional typing practice.
we suggest that design concerns should be considered to improve type annotationimplementation by following at least six patterns files criticalto software architecture could be type annotated in priority.
webelieve these guidelines would promote a better type annotationpractice for dynamic languages.
index terms type annotation dynamic languages i. i ntroduction dynamic programming languages have been embracing gradual typing supporting optional type annotations in source code.
for example python community proposespep483 to support optional type hints for python .
andlater versions in .
typescript with the first releaseversion in allows static type definitions for javascript.in ruby .
claims featuring type annotations byintroducing rbs .
this trend indicates that dynamic typingcommunity increasingly acknowledges the benefits of typeannotations i.e.
facilitating early bug detection and soft ware maintenance .
notable python communities likeapache pyspark have started modern type annotation practiceson their long lasting codebases.
by long lasting codebases we mean that they were originally developed during that periodof optional typing feature unavailable.
adding type annotations requires a monumental effort .
type annotating a complex and long lasting codebase is not ting liu is the corresponding author.an overnight process indeed a gradual migration from un annotated codebase to a completely type annotated one.
dur ing this gradual and expensive process two issues havetroubled developers first there is few guidance on how to implement type annotations.
some type annotation implementations requireadditional definitions besides the types themselves.
we definethem as non trivial type annotation practices.
recent studies concluded that adding type to a single variableconsumes about two minutes on average.
however the patternsfollowed by non trivial type annotation are still unclear.
re vealing these patterns would promote an effective and efficienttype annotation practice.
second there is few guidance on which portion of a codebase should be type annotated in priority.
when type annotating a large scale codebase developers have struggledwith where to start adding types it should be decided ifannotations should cover only the public api s or internalsas well as stated by pyspark developers .
they agreethat there should be a trade off between completeness of the typing coverage and the cost of maintenance of typeannotations .
however it is unclear for type beginners about which source files can be type annotated with priority.
this paper focuses on the two issues by studying popular python projects that have experienced type annotations.
twosignificant considerations motivate our study.
first we con jecture that the inconsistency between type annotation imple mentations and the corresponding source code may imply thepatterns of non trivial type annotations due to the introductionof new code entities.
second we assume that type annotatedfiles are likely critical to maintaining a software system.
the reason is that one intention of using types is to improvecodebase maintainability which is commonly evaluated basedon code dependency structures .
as a result we willexplore three research questions rq1.
what are the patterns that non trivial type annotationpractices follow?rq2.
do type annotated files present different dependencystructure?rq3.
do type annotated files incur different maintenancecost?
to support our study we selected notable python projects with type hint experiences.
these subjects are with diverse 36th ieee acm international conference on automated software engineering ase 36th ieee acm international conference on automated software engineering ase .
ieee .
ase51524.
.
.
ieee domains sizes and type hint manners .
we designed the thprofiler to analyze projects source code and mine theirrevision history.
we have created and released the dataset .
first our study figured out six patterns followed by nontrivial type hint practices.
they are typing compatability api visibility baseclass presentation function overloading function assigned v ariable and typing extension .
these type annotation practices heavily involve recovering and expressingdesign or code decisions made by developers during codebasedevelopment.
second we revealed three features of type annotated files.
type annotated files have a bigger value ofdegree centrality in dependency structure reside at the up permost layer in the hierarchical structure and incur highermaintenance costs.
our work is the first to inspect non trivial type annotation practices and identify features of type annotated files to thebest of our knowledge.
our findings benefit type hint practicesand tools architecture concerns should be considered toimprove the effectiveness and efficiency of type implementa tions by following these patterns files critical to softwarearchitecture could be type annotated in priority for a gradualmigration from un annotated codebase to type annotated one.
overall our work makes the following contributions we define six patterns followed by non trivial practices and reveal three features of type annotated files.
we suggest following these patterns with design concerns to implement type annotations we recommend typeannotating files with the revealed features in priority.
we contribute a dataset and a tool for the continued study of type annotation practices in dynamic languages.
the organization of the rest section ii presents the key concepts and our thprofiler tool.
sections iii iv and vreport the study setup study results and potential impact ofour empirical study.
sections vi and vii discuss the threatsto validity and related work.
section viii draws conclusions.
ii.
m ethodology this section will introduce the concepts and thprofiler we designed to support our study.
a. concepts listing example a a is type annotated b c are un annotateddef func a int b c a breturn clisting example b p is a newly defined p typevar p bound int def func a p b c a breturn c optional type annotation gradual typing supports optional type annotations in source code.
the optional means that developers can add type annotations to a portion ofsource files and functions or variables inside one file.
onlytype annotated entities will be statically type checked whileothers remain type checked at run time.
listing shows asnippet of python code.
in the function func its parameter a is annotated with int while the parameter band a variable c have no type annotations.
type annotation implementation following pep484 python3.
and later versions support twomanners of type annotation implementation inline type hints.
type annotations are directly inlined in the source code.
in listing type hints of var andadd are inlined in test.py .
stub files.
type annotations are separately managed in stub files named with .pyi which only contain type hints and are only used by static type checkers i.e.
mypy pytype .in listing test.pyi is the stub file corresponding to test.py .
test.pyi only contains type associated declarations and function signature of add.
the function body of add is a single ellipsis ... .
python projects can adopt either one or both two manners above at the same time.
listing inline type hints test.py var int def add a int b int int c a b return clisting stub file test.pyv a r 0def add a b c a breturn c test.pyivar int def add a int b int int ... trivial and non trivial type practices we classify type annotation implementations into two types trivial type practices mean that type annotating a code entity simply requires assigning the type by following a syntax of type.
in this case the source code before and after type annotation implementations are consistent with each other.type annotating ain listing is trivial by only adding int.
non trivial type practices are complex implementations that require introducing additional definitions such as variables functions and classes.
this practice leads to the inconsistencybetween the code and type annotated code.
in listing pis introduced to type annotate a. b. thprofiler we designed and implemented thprofiler to support our study.
thprofiler analyzes the source code and mines revisionhistory of type annotated python codebases.
as illustrated infigure the input of thprofiler is a python codebase withtype implementations.
thprofiler consists of three parts asfollows.
typing practice identification this part detects entities annotated with types and type usages in source code.
typing coverage detection.
using python ast library this module first identifies all code entities and type annotatedentities.
then it calculates the typing coverages at variouslevels.
we define typing coverage as the proportion of entities i.e.
functions files variables with type hints.
diverse type extraction.
through traversing the ast structures of source files and stub files if available this moduledetects all types assigned to entities.
complex typing usage detection.
this module detects the usage of protocols and function overloadings.
overloaded 530fig.
the overview of thprofiler functions are declared with overload decorator which is imported from typing module.
the overload decorator allows describing functions with same names but with different combinations of argument types .
protocol classes explicitly extend from typing.p rotocol that supports structural typing.
structural typing can be considered as a static equivalent of duck typing .
protocol classes act as animplicit base class in the static type analysis.
that is if a classhas some members that are also defined by protocols this classcan be implicitly treated as a sub class of the protocols.
dependency structure characterization this part extracts and analyzes dependency structure of source code following the design rule theory .
design rule theoryassumes that design rules and modules are major designconcerns in a software system.
design rules decouple the restof a system into mutually independent modules.
in the sourcecode that follows object oriented programming pragmatics design rules are often manifested as interfaces or abstractclasses.
the removal modification and addition of a moduleshould have no influence on design rules.
dependency extraction.
this module considers both explicit and possible dependencies in source code.
as termed by jinet al.
explicit dependencies are syntactic dependencies that are explicitly referenced in source code while possibledependencies are invisible and non deterministic dependenciesdue to duck typing .
following this work this modulealso employs scitool understand and enre toextract explicit and possible dependencies respectively.
graph construction.
this module constructs the attributed dependency graph adg from the union of explicit andpossible dependencies.
in an adg each node denotes onesource file and each directed edge denotes one dependencybetween two files.
the node attribute specifies whether anode has type hints denoted as typed or not.
the attribute information is obtained from the typing practice identification of thprofiler.
design rule hierarchy drh .
based on the adg this module employs drh algorithm to identify designrules and independent modules in a software system.
fol lowing the design rule theory drh clusters sourcefiles into a layering structure where files in upper layersrepresent design rules and files in lower layers are organizedinto independent modules decoupled by those design rules.modules in lower layers depend on the modules in upperlayers but not vice versa.
modules in the same layer aremutually independent.
we use a subset of source files in django one of our subjects to explain hierarchical structures created by drh.
infigure each row or column corresponds to a file and dp in a cell i j indicates one dependency from file ito file j. dependencies can be inherit or call relations identified bydependency extraction of thprofiler.
a diagonal cell means a self dependency.
drh clusters these files into three layers i.e.
l l1 and l2.
the uppermost layer l0 rows to contains files that denote design rules of this sub system l1 contains row to l2 row to includes four mutually independent modules and they are row and .
fig.
the hierarchical structure formed by a subset of files in django maintenance measurement this part computes the maintenance cost of typed anduntyped files according to the revision history managed by vcs v ersion control system like git.
revision history preprocess.
this module exports the commit log from a code repository.
each commit record includesthe commit id the author making this commit a list ofmodified files the ids of issues fixed by this commit andthe loc lines of code of addition and deletion.
maintenance cost measurement.
based on commit records this module quantifies the effort taken on maintaining sourcefiles.
similar to the work of six measures arecomputed including commit the number of commits made to a file changeloc the total lines of changed code of modifying a file author the number of developers for maintaining a file issue the number of issues that a file gets involved issuecmt the number of commits of a file for fixing issues issueloc the total loc changed to a file 531for fixing issues.
the bigger value of these measures indicates the more maintenance cost invested on a file.
iii.
s tudy setup we collect python projects that experience type annotation practices and conduct a preliminary analysis during the setup.we will explore three research questions as follows.
rq1 what are the patterns that non trivial type annotation practices follow?
this study will figure out and categorize thepatterns that complex type hint practices will follow.
rq2 do type annotated files present different dependency structure?
this study will compare the type annotated fileswith other files based on file level dependency structure.
rq3 do type annotated files incur different maintenance cost?
the answer will advance our understanding of themaintainability of type annotated files when compared withother files.
a. collection and subjects we manually selected python projects as subjects.
the basic selection criteria include the project is partially type hinted is widely used frequently starred or downloaded hasa well managed revision history with commits and issues follows type annotation syntax supported by python .
orlater versions uses non any types since any is compatible with every type and has no semantics.
following these requirements three contributors of our work initially selected subjects from public projectsstudied by a recent work and selected frequently starredpython projects in github.
the selection process requiresmanually inspecting projects the source code and communitydiscussions to determine type related information such astype hint manners they adopted and repositories that managetype implementations.
to alleviate the bias to our study from the projects collected by three contributors we finally selected subjects withvarious diversities.
diverse type hint manners we chose the projects which only adopt inline type annotations only adopt stub type files or adopt both inline andstub together.
diverse domains projects cover different domains such as web framework scientific computing and type check.
diverse sizes projects can be small scale less than 10k loc medium scale at least 10k loc or large scale at least 100kloc .
finally we collected subjects as shown in table i. in table i v ersion is the project version we studied file counts files loc counts lines of code typemanner lists type hint manners used by projects typecodeurl is the github repositories holding type implementations of projects and star denotes the project popularity.
we can see that projects manage type implementations in stub files projects adopt inline type annotations the remaining projects adopt both inline andstub manners.
as listed in typecodeurl django drf and matplotlib manage type stubs in separaterepositories from their codebase repositories.b.
statistics of typing coverage by employing typing coverage detection of our thprofiler we detected type annotated entities then computed typingcoverage in terms of loc files functions and variables.coverage loc is the ratio of loc annotated with types to the total loc.
the total loc counts both the source codeand stub code in .pyi if have .
coverage file is the proportion of files with type hints.
coverage func is the proportion of functions or methods containing type annotateddeclaration signatures.
coverage var counts the proportion of type annotated names or variables.
the computation ofcoverage var excludes parameter variables since they are considered for coverage func .
table ii lists typing coverage results.
the values less than indicate that partial code entities are assignedwith type annotations.
the values of coverage file and coverage func are bigger than those of coverage loc andcoverage var .
for example more than files are type hinted in drf while the coverage values of variablesand functions are smaller.
besides these results reveal asubstantial development and maintenance effort invested intype implementations.
c. statistics of diverse type usage we used diverse type extraction of thprofiler to observe type usages in subjects.
we counted the types imported from typing likeunion andlist since typing module is officially designed to support optional typing.
fig.
the usage of diverse types figure depicts shows that any andoptional are most frequently used in subjects.
optional means that the type of a symbol can be a specified type or none .
the optional usage indicates code objects are prone to be declared withnone by default.
any has no type semantics meaning that objects annotated by it will escape from static type checking.
our study will focus on non any annotation practices.
if a file only has any types associated with code symbols we consider this file is un annotated.
in this case the type annotated file coverage as listed in table iii is sightly differentwith that in table ii for some projects.
532table i subjects project v ersion file loc typemanner typecodeurl star chainer 522e01 stub inline .6k django v3.
.
stub .4k drf v3.
.
stub .6k elasticsearch 25b50e stub inline .2k grpc v1.
.
inline .8k matplotlib v3.
.
stub .3kmypy v0.
inline .4k numpy v1.
.
stub inline .6k pandas v1.
.
inline .1k prefect c423a7 inline .
.k pyproj dd84df inline pyspark v3.
.
stub inline .2k pytest 940c6e inline .5k rasa a4ee09 inline .7k returns v0.
.
stub inline .6k sanic 021da3 inline .1k scipy 6caa33 stub inline .4k uvicorn 62825d inline .1k werkzeug 08624d stub inline .8k 1drf is django rest framework.
table ii typing coverage results project coverage loc coverage file coverage func coverage var project coverage loc coverage file coverage func coverage var chainer .
.
.
.
django .
.
.
.
drf .
.
.
.
elasticsearch .
.
.
.
grpc .
.
.
.
matplotlib .
.
.
.
mypy .
.
.
.
numpy .
.
.
.
pandas .
.
.
.
prefect .
.
.
.
pyproj .
.
.
.
pyspark .
.
.
.
pytest .
.
.
.
rasa .
.
.
.
returns .
.
.
.
sanic .
.
.
.
scipy .
.
.
.
uvicorn .
.
.
.
werkzeug .
.
.
.
table iii coverage file results after excluding any types project coverage project coverage project coverage chainer .
django .
drf .
elasticsearch .
grpc .
matplotlib .
mypy .
numpy .
pandas .
prefect .
pyproj .
pyspark .
pytest .
rasa .
returns .
sanic .
scipy .
uvicorn .
werkzeug .
iv .
e v alua tion a. rq1 patterns of non trivial type annotation practices this rq explores the patterns that non trivial type annotation practices follow.
we first illustrate this motivation.
after that we manually screen subjects to categorize and explainthe patterns.
we automatically detect these patterns through astatic code analysis on asts of subjects.
motivation when we employed typing coverage detection of thprofiler in section iii b we found an interesting observation in subjects with stub files besides adding a singletype to a symbol developers sometimes define new entitieswhich were absent in the source files.
table iv summarizes the stub files classes and functions in the stub code which are directly unmatched with thesource code.
the results indicate that nine projects exclud ing chainer have a substantial number of entities newlyintroduced for type implementations.
in django stub files .pyi have no corresponding source files .py classes and functions are additionally defined in stub code.
we assume that this inconsistency may capture non trivial type annotation practices.
inspired by this assumption weinspect the projects with such inconsistency.
categorization results due to the non negligible inconsistency as shown in table iv between source code andstub code we manually inspected the subjects with stub files as listed in table i. we conducted a qualitative analysis andquantitative analysis supported by complex typing usage detection of thprofiler.
finally we figured out and categorized six patterns that non trivial type hint practices follow.
category typing compatibility with the evolution of typing module typing inevitably provides fresh types that were unavailable in earlier versions.
when implementing type annotations in older versions such fresh types need to be user defined for version compatibility.
listing an example for category numpy core function base.pyi ifsys.version info from typing import supportsindex 533table iv summary of stub files classes and functions that are defined in .pyi but absent in .py project absent stub file absent class absent function chainer django drf elasticsearch matplotlib numpy pyspark returns scipy werkzeug since values in chainer are zero the study of rq1 will exclude chainer.
else from typing extensions import protocol class supportsindex protocol def index self int ... for example in numpy project listed in listing supportsindex is only supported by typing in python3.
and later versions.
supportsindex should be user defined in older versions.
as a result supportsindex is absent in function base.py while it is introduced in function base.pyi.
category api visibility one module defines an api while its corresponding type annotated api is declared in the stub file of another module that depends on this api.
in this case type annotated apis are directly visible to their dependents.
listing an example for category numpy core multiarray.py all def empty like prototype dtype none order none subok none shape none return prototype numpy core numeric.pyidef empty like a arraytype dtype none ... order orderkacf ... subok literal ... shape none ... arraytype ... in listing excerpted from numpy empty like is defined in multiarray.py module.
this function is also included in all meaning that it is visible to other modules by from multiarray import .
however type implementation of empty like appears in numeric.pyi instead of multiarray.pyi .
as a result numeric can access the semantic types of empty like .
category baseclass presentation baseclasses either extending from typing.p rotocol1or not are newly introduced into type implementations making originally invisible interfaces explicit.
listing an example for category rest framework permissions.py class and def init self op1 op2 ... def has permission self request view ... v the classes present in stub code project class all new class protocol class subclass django .
drf .
elasticsearch .
matplotlib .
numpy .
pyspark returns scipy .
werkzeug def has object permission self request view obj ... class or def init self op1 op2 ... def has permission self request view ... def has object permission self request view obj ... rest framework stubs permissions.pyiclass supportshaspermission protocol def has permission self request request view apiview bool ... def has object permission self request request view apiview obj any bool ... class and supportshaspermission ... class or supportshaspermission ... in listing classes and andor have no explicit relationship in permissions.py .
however in permissions.pyi both of them explicitly inherit a newly defined baseclass named supporthaspermission.
the baseclass acts as an interface which was implicitly implemented by and and or in permissions.py .
table v summarizes the classes defined in stub files.
considering django classes are type annotated.
.
i.e.
of them are absent in source code but defined for typehints.
among new classes classes explicitly extend fromtyping.protocol.
classes extend from these new classes.the presence of new base classes helps build an explicitrelationship between base classes and their sub classes.
category function overloading a function in source code may become overloaded in its type implementations.
overloaded functions have the same name but are declaredwith different types of parameters or returns.
in listing smart text is overloaded generating two different definitions in type stub code.
listing an example for category django utils encodings.py def smart text s encoding utf strings only false errors strict warnings.warn ... return smart str s encoding strings only errors django stubs utils encoding.pyifrom typing import typevar overload overloaddef smart text s p encoding str ... strings only bool ... errors str ... p ... overload 534table vi summary of the overloaded functions i.e.
ofunc project ofunc all ofunc ofunc max ofunc i i django drf numpy 4pyspark 28scipy 3werkzeug def smart text s pt encoding str ... strings only literal ... errors str ... pt ... table vi lists function overloading in subjects.
for instance different functions in django are overloaded in type implementations as indicated by ofunc all.
ofunc means that of functions are overloaded twice i.e.
eachfunction has two different declarations ofunc shows that functions are overloaded with times the remainingone i.e.
is overloaded with more than times.max ofunc i i shows that there exists a function overloaded with up to separate declarations.
the common usage of function overloading in table vi implies a non trivial effort for splitting hairs influenced bydifferent parameters.
category function assigned v ariable for variables assigned with function objects type implementations may explicitly declare them as functions.
this practice will generatenew function definitions in stub files.
listing an example for category numpy core internal.py class ctypes get data data.fget get shape shape.fget numpy core internal.pyiclass ctypes def get data self int ... def get shape self any ... getdata in listing is a variable in internal.py then declared as an explicit function getdata self in internal.pyi.
getshape is a similar case.
category typing extension some stub files correspond to extension files like .pxd.
.pxd works like c header files and is provided by cython supporting writing c extensions for python language.
listing an example for category numpy init .pxd ctypedef class numpy.flatiter object pyarrayiterobject check size ignore ... numpy init .pyiclass flatiter generic ... in listing class flatiter with type annotations is defined in init .pyi while its declaration appears in init .pxd instead of init .py.
pattern summary table vii summarizes the six patterns detected in projects with stub files.
first function overloadingand function assigned v ariable are common practices adopted by developers.
the numbers of baseclass presentation typingcompatibility and typing extension are smaller.
api visibil ity is the most infrequent pattern.
second projects in diversedomains present different number of patterns.
for instance scipy and numpy have the typing extension since theyintegrate with c c extensions for scientific computation.
answering rq1 we figured out and categorized six kinds of type practices that are non trivial to conduct.
theytightly require recovering and expressing design decisions inlong lasting codebase typing compatability practice introduces new dependencies into a codebase due to new definitions for compat ibility with older versions of typing module.
baseclass presentation practice recovers and explicitly expresses design rules which are manifested as base classes or protocols in type implementations.
api visibility practice makes some apis directly visible to the api dependents.
function overloading practice reconstructs type semantics for complex functions unambiguously presentingreturn types based on different parameter types.
function assigned v ariable practice makes implicit functions explicit.
typing extension practice connects code modules across different programming languages in a software system.
fig.
using degree centrality to capture type annotated files in django fig.
performance of degree centrality when capturing type annotated files 535table vii the number of patterns detected in subjects with type stubs projecttyping compatibilityapivisibility baseclass presentation functionoverloadingtypingextensionfunction assignedv ariable new baseclass new protocol django drf elasticsearch matplotlib numpy pyspark returns scipy werkzeug sum b. rq2 characterizing dependency structure this study explores whether type annotated files present different dependency structures when compared to files without type annotations.
since degree centrality and drh method have been widely used by prior work we also employed them to observe software dependencystructure.
degree centrality of a file is the fraction of files it connects to.
the higher value of the degree centrality the more centralit is in the dependency structure.
drh as aforementioned creates a hierarchical structure of a software system.
filesat the uppermost layers l are most influential since they represent design rules of software architecture.
we assume thattype annotated files would dominate the file set with higherdegree centrality and dominate l 0layers in the hierarchical structure.
measures we first employed networkx to compute degree centrality of files in the adg built by dependency structure analysis of thprofiler.
we used p recision p and recall r to measure the ability of degree centrality when capturing type annotated files.
p ftyped ftop ftop r ftyped ftop ftyped where ftyped is a set of all type annotated files in a project.
ranking all files based on degree centrality measurements ina decreasing order f topis a set of top files such as top top ... and top .
top files include all filesin a project.
we can obtain ten pairs of pandrresults from top top ... to top .
based on them we willobserve whether top ranking files with higher degree centralityare prone to be type annotated.
second we employed design rule hierarchy drh of thprofiler to construct hierarchical structure based onthe adg.
we computed the proportion of type annotatedfiles at the layer l i.e.
coverage l0 vs. other layers i.e.
coverage lothers .
if coverage l0 is bigger than coverage lothers it would indicate that files which are manifested as software design rules are prone to be type annotated.
results using django as an example figure illustrates precision p and recall r results when usingtop10 ... files ranked by degree centrality to capture type hinted files.
the red dotted line labeled with56.
is the baseline precision and the green dotted line isthe baseline recall.
now we explain the baseline performance.the baseline denotes the performance when capturing type annotated files by a random sample of project files.
consider ing a random sample of files type annotated files shouldtake .
of this sample since .
files as listed intable iii are type annotated in django.
because only files of a project are randomly sampled type annotatedfiles should be captured statistically.
we can observe that the precision and recall results at top top ... and present consistent observations the performanceof precision and recall based on degree centrality is biggerthan baseline performance.
figure shows the boxplots of precision and recall improvements when compared with baselines in all subjects.
p p p baseline and r r rbaseline .
due to the page limitation we only present performance improvementresults from top p r top p r to top p r .
the boxplots indicate that performance improvements of degree centrality arecommonly positive despite the existence of several outliers.on average precision improvements are .
.
and9.
recall improvements are .
.
and .
respectively at top top and top .
figure depicts the results of coverage l and coverage lothers .
we can observe that projects exhibit consistent results withcoverage l coverage lother .
recall that files in layer l0represent design rules of a software system.
in django .
files are type annotated at the uppermost layerl 0while .
files are type annotated at other layers.
the results indicate that files manifested as architectural designrules are more likely to be type hinted than other files.
answering rq2 our results indicate that type annotated files present different features in the software structure.
con cretely they have a higher value of degree centrality and theyreside at the uppermost layer in a hierarchical structure hencemanifesting as design rules of a software system.
c. rq3 characterizing maintenance cost this study investigates whether the maintenance cost of type annotated files differs from other files.
using 536fig.
the proportion of type annotated files at the uppermost layer l vs. other layers l others formed by the drh table viii the performance of maintenance cost measures when capturing type annotated files in django project subject top author commit changeloc issue issuecmt issueloc coverage pr pr pr pr pr pr django .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
fig.
the performance of maintenance cost measures when capturing type annotated files the maintenance measurement of thprofiler we computed author changecmt changeloc issue issuecmt issueloc for a source file.
these measures have been used by the work of to assess software maintainability.
the larger these measurements of a file theheavier maintenance effort taken on it.
measures similar to rq2 we evaluated the precision and recall when using top files ranked by maintenance costto capture type hinted files.
the precision measure recallmeasure and baseline values are same with those used insection iv b. if values of precision and recall are bigger thanthose of baseline it would indicate that type annotated filespresent a different feature in terms of maintenance cost.
results table viii lists evaluation results in django.
.
files are type annotated in total as shown in the firstcolumn.
the author p column indicates that among thetop files with higher maintenance cost .
files havetype annotations greatly larger than the baseline precision .
.
as shown in author r column type annotated files captured by top measurements take .
of alltyped files in django bigger than the baseline recall i.e.
.
figure illustrates the boxplots of precision improvements p and recall improvements r in all projects.
the six sub figures correspond to the results of six maintainabilitymeasures.
similar to section iv b we consider the top top and top files ranked by maintenance costmeasurements.
from figure we can see that performance improvements are positive when averaged on all projects.
the six sub figures present consistent observations using heavily main tained files to capture type annotated files the precision valuesand recall values outperform the baseline performance.
this 537observation indicates that files with greater maintenance costs are more likely to be type annotated in priority.
answering rq3 the results demonstrate the difference of maintenance cost between type annotated files and otherfiles.
this observation indicates that files difficult to maintaincould be promising candidates to be type annotated in priority.
v. p otential impact this section will discuss the possible impact of our findings on type annotation practices by citing developer discussionlists in notable python projects including django numpy and pyspark which are studied in our work.
theyhave experienced type annotations for about four years andtheir developers have been discussing type hint practices.
a. the consideration of design concerns python developers have noticed the non trivialness of type annotation implementations.
annotating the original code is more than just adding annotations as discussed by django contributors.
pyspark developers said that some parts of type annotations are close to trivial other s are rather .
recent academic works by ore et al.
demonstrate thatannotating a single variable consumes about two minutes onaverage.
however it is still unknown about code level patternsof non trivial type annotations which may guide beginnerssupplementing types more effectively.
our results of rq1 revealed six code patterns of nontrivial type practices.
first these patterns demonstrate thedifficulty to include automated approaches for handling typeannotations since type annotation of a code entity sometimesrequires introducing additional entities.
second these patternshighlight that such non trivial type practices deeply involveretrospecting recovering and expressing the design and cod ing decisions originally made in the codebase development.
we suggest that type practitioners should take design concerns into account.
for example when type annotating a group of classes that provide similar behaviorsbut do not explicitly extend a base class we advice thattheir common interfaces should be extracted as additionaldefinitions to manifest design rules as inspired by baseclass presentation practice listing .
learning from function overloading practice listing we recommend overloading the functions that have complex logic due to type diversity ofparameters and returns.
b. candidate module recommendation for type annotations python developers have struggled with which part of code should be type annotated first.
pyspark developers stated it should be decided if annotations should cover only thepublic api or internals as well.
django developers con sidered partial type hinting is useful and viable but not randomly.
developers agreed that they should trade off between completeness of the typing coverage and the costof maintenance of type annotations .
at the same time they complained about the lack of such guidance missing high fig.
the v enn diagram of project sets captured by three features level guidance calling for a type theory for beginners both in python and more generally .
our findings in rq2 and rq3 shed a light on which portion of modules i.e.
python files could be type annotated inpriority.
we revealed three features of the type annotated files i.e.
they present a bigger value of degree centrality theyare located at the uppermost layer in a hierarchical structure and they incur a higher maintenance cost.
these features arecomplementary to each other as visualized in figure .
among19 subjects in our study degree centrality can effectivelycapture type annotated files in 19projects the proportion is13 19for the hierarchical layer and the proportion is14 19for maintenance cost.
for a long lasting large scale project migrating from an un annotated codebase to type annotated one is a gradual andexpensive process.
our findings imply that python modulespresenting three features could be type annotated first fora trade off between the typing coverage and maintenanceefforts taken on type annotations.
we believe our findingsand tools would benefit the projects and developers that planto experience modern type hint practices.
our study is apreliminary trial at the file level which will be continued at afiner grained level like apis or functions.
vi.
t hrea ts to validity first subject collection is non trivial.
to reduce the bias to our study we followed the collection criteria to select projectswith diverse type hint manners domains and sizes as shownin section iii a. we will collect more projects for our studyin the future.
second we manually categorized six patterns in non trivial type annotation practices.
one threat is that the categories maybe insufficient to cover all non trivial practices.
to mitigatethis threat we will continue mining more usable patterns.
third different techniques may produce inconsistent observations.
to reduce this threat our study employed well accepted tools techniques and measures.
concretely we usedunderstand to extract code dependencies which is suggestedby the industry .
we applied the drh technique to cluster files hierarchically.
our research employedsix maintainability measures .
besides as shown infigure the revealed three features are complementary tocapture all subjects.
one possible reason is that developers indifferent projects may have different typing decisions.
we willanalyze them in next work.
538finally our study of rq2 and rq3 reveals the correlation between three features and type proneness of a source file but not the causality.
we neither claim how the three featurescause a file to be type annotated nor the vice versa.
exploringthe causality will be our next work.
vii.
r ela ted work a. static typing systems vs. dynamic typing systems much prior work has demonstrated that static typing systems benefit bug detection and software maintenance.
klein schmager et al.
assigned developers with a set of pro gramming tasks and found that static typing systems cancapture type related errors without program executions.
spizaet al.
supported that developers already benefit from typesemantics of apis even without static type checking.
gao etal.
manually added annotations to buggy code written injavascript and tested whether static typing systems can capturethe error on buggy code.
their experiments reported thatthe static typing systems flow and typescript cansuccessfully detect a portion of public bugs in revision history.daly et al.
compared ruby with druby an extension toruby with static typing.
their work indicated that druby failsin capturing complex errors.
besides discussing the benefits the work of concluded that developers who usedynamic languages tend to switch between different files morefrequently than developers who use static languages.
as shownin their results the frequent search for different files influencesthe efficiency of development and maintenance activities.
these studies evaluated the benefits and disadvantages of the usage of static typing feature in dynamically typed lan guages.
unlike them our work figured out patterns of non trivial type annotation implementations and features of type annotated files.
b. empirical study of type annotation practices existing work investigated the type annotation usage in development activities.
souza et al.
conducted several hypothesis tests to investigate type usage in groovy language.this work presented that test classes and script files usetypes less frequently than other files.
another interestingfinding is that programmers who often develop code in an untyped language tend to declare types less often.
groovyis an object oriented programming language for java platform.quite different from groovy python is dynamically typed innature thus perhaps leading to different observations.
ore etal.
studied programmers using code artifacts inthe cyber physical domain.
they assessed the time cost oftype annotation supplementation showing that it takes morethan two minutes to annotate a single variable accurately.the considerable time cost demonstrated the complexity anddifficulty for developers to assign types to variables.
byextending this study a recent work further pointedthat developers reason about variable types primarily basedon names and operations of identifiers which points out adirection to improve automated type annotation systems.similar to those work we also studied type annotation practices but presented an evidence that type annotated files arecritical to understanding and maintaining software architectureby revealing three complementary features.
c. static type inference in dynamic languages static type inference determines the types of program expressions statically without a need to run programs.
early type inference methods such as formalize the type infer ence problem as the type constraint resolution.
the methodin first creates a trace graph from which a set of typeconstraints are extracted.
at last it computes the least solutionof the set of type constraints by least fixed point derivation.milojkovic et al.
leveraged heuristics such as namingconvention to enhance type inference.
recent type inferencemethods employ machine learning or deep learning techniques.jsnice learns a probabilistic model to predict variablenames and variable types for javascript.
deeptyper transforms the type inference problem into a translation modelfrom a un annotated code to annotated code.
dltpy is adeep learning type inference solution.
it predicts the types infunction signatures based on identifier names comments andreturn expressions of a function.
the work of exploredhow type inference techniques designed for static languagewill perform on dynamic languages.
automated type inference approaches can assist type annotation implementation.
our work also promotes type annota tion practices but in a different view.
we recommended thatsuch practices should consider architectural concerns due tothe existence of non trivial type annotation implementations.
viii.
c onclusion our work is the first to detect non trivial type annotation practices and reveal possible features of type annotated files to the best of our knowledge.
we found six type annota tion patterns that involve recovering and expressing designconcerns made in original codebase development.
we alsoshowed that the files characterized by three complementaryfeatures i.e.
presenting higher degree centrality residing atthe uppermost layer of a hierarchical structure and incurringhigher maintenance cost are prone to be type hinted.
more projects in dynamic languages are trying to embrace optional typing practice however still lacking guidance.
dur ing a gradual and expensive process of type annotating a code base we suggest considering the revealed patterns with designconcerns and candidate type annotated file recommendations.a consideration of them would promote a better practice ofoptional typing.
a cknowledgment this work was supported by national key r d program of china 2018yfb1004500 national natural science foun dation of china u1766215 china postdoctoral sciencefoundation 2020m683507 2019tq0251 2020m673439 and y outh talent support plan of xi an association forscience and technology .
539references j. g. siek and w. taha gradual typing for functional languages in inscheme and functional programming workshop.
acm pp.
.
typescript .
ruby .
.
m. allamanis e. t. barr s. ducousso and z. gao typilus neural type hints in proceedings ofthe 41st acm sigplan conference on programming language design and implementation ser.
pldi .
new y ork ny usa association for computing machinery p. .
.
available r. chatley a. donaldson and a. mycroft the next programming languages.
computing and software science .
j. p .
ore s. elbaum c. detweiler and l. karkazis assessing the type annotation burden in proceedings ofthe33rd acm ieee international conference onautomated software engineering pp.
.
j. p .
ore c. detweiler and s. elbaum an empirical study on type annotations accuracy speed and suggestion effectiveness acm transactions on software engineering and methodology tosem vol.
no.
pp.
.
spark re revisiting pyspark type annotations .
w. jin y .
cai r. kazman g. zhang q. zheng and t. liu exploring the architectural impact of possible dependencies in python software in 35th ieee acm international conference onautomated software engineering ase .
ieee pp.
.
r. mo y .
cai r. kazman and l. xiao hotspot patterns the formal definition and automatic detection of architecture smells in 12th working ieee ifip conference onsoftware architecture.
ieee pp.
.
python .
w. jin d. zhong z. ding m. fan and t. liu typehintpractice .
python .
google .
python .
.
p .
docs .
c. y .
baldwin and k. b. clark design rules the power ofmodularity.
mit press vol.
.
s. understand .
w. jin y .
cai r. kazman q. zheng d. cui and t. liu enre a tool framework for extensible entity relation extraction in proceedings of the41st international conference onsoftware engineering companion proceedings.
ieee press pp.
.
s. wong y .
cai g. v aletto g. simeonov and k. sethi design rule hierarchies and parallelism in software development tasks inproceedings ofthe ieee acm international conference on automated software engineering.
ieee computer society pp.
.
l. xiao y .
cai and r. kazman design rule spaces a new form of architecture insight in proceedings ofthe36th international conference onsoftware engineering.
acm pp.
.
r. mo y .
cai r. kazman l. xiao and q. feng decoupling level a new metric for architectural maintenance complexity in proceedings ofthe 38th international conference onsoftware engineering.
ieee pp.
.
c. r. myers software systems as complex networks structure function and evolvability of software collaboration graphs physical review e vol.
no.
p. .
m. harman d. binkley k. gallagher n. gold and j. krinke dependence clusters in source code acm transactions onprogramming languages and systems toplas vol.
no.
pp.
.
p .
bhattacharya m. iliofotou i. neamtiu and m. faloutsos graphbased analysis and prediction for software evolution in 34th international conference onsoftware engineering icse .
ieee pp.
.
networkx .
django .
numpy .
spark .
l. bass p .
clements and r. kazman software architecture inpractice.
addison wesley professional .
j. garcia d. popescu c. mattmann n. medvidovic and y .
cai enhancing architectural recovery using concerns in 26th ieee acm international conference onautomated software engineering ase .
ieee pp.
.
j. garcia i. ivkovic and n. medvidovic a comparative analysis of software architecture recovery techniques in proceedings of 28th ieee acm international conference on automated software engineering.
ieee pp.
.
y .
cai l. xiao r. kazman r. mo and q. feng design rule spaces a new model for representing and analyzing software architecture ieee transactions onsoftware engineering .
lattix .
structure101 .
r. mo w. snipes y .
cai s. ramaswamy r. kazman and m. naedele experiences applying automated architecture analysis tool suites in proceedings ofthe 33rd acm ieee international conference on automated software engineering.
acm pp.
.
archdia .
r. mo y .
cai r. kazman l. xiao and q. feng architecture antipatterns automatically detectable violations of design principles ieee transactions onsoftware engineering pp.
.
d. cui t. liu y .
cai q. zheng q. feng w. jin j. guo and y .
qu investigating the impact of multiple dependency structures on software defects in software engineering .
icse .
proceedings.
41th international conference on.
ieee pp.
.
s. kleinschmager r. robbes a. stefik s. hanenberg and e. tanter do static type systems improve the maintainability of software systems?an empirical study in 20th ieee international conference on program comprehension icpc .
ieee pp.
.
s. spiza and s. hanenberg type names without static type checking already improve the usability of apis as long as the type names arecorrect an empirical study in proceedings ofthe 13th international conference onmodularity pp.
.
z. gao c. bird and e. t. barr to type or not to type quantifying detectable bugs in javascript in ieee acm 39th international conference onsoftware engineering icse .
ieee pp.
.
flow .
m. t. daly v .
sazawal and j. s. foster work in progress an empirical study of static typing in ruby .
a. stuchlik and s. hanenberg static vs. dynamic type systems an empirical study about the relationship between type casts and development time in proceedings ofthe 7th symposium ondynamic languages pp.
.
c. mayer s. hanenberg r. robbes e. tanter and a. stefik an empirical study of the influence of static type systems on the usabilityof undocumented software acm sigplan notices vol.
no.
pp.
.
s. hanenberg s. kleinschmager r. robbes e. tanter and a. stefik an empirical study on the impact of static typing on software maintain ability empirical software engineering vol.
no.
pp.
.
c. souza and e. figueiredo how do programmers use optional typing?
an empirical study in proceedings ofthe13th international conference onmodularity pp.
.
j. palsberg object oriented type inference in proc.
oopsla pp.
.
j. o. graver and r. e. johnson a type system for smalltalk in proceedings ofthe 17th acm sigplan sigact symposium on principles ofprogramming languages ser.
popl .
new y ork ny usa association for computing machinery p. .
.
available n. milojkovi c c. b era m. ghafari and o. nierstrasz inferring types by mining class usage frequency from inline caches in proceedings ofthe 11th edition ofthe international workshop on smalltalk technologies pp.
.
n. milojkovi c improving the precision of type inference algorithms with lightweight heuristics .
v .
raychev m. v echev and a. krause predicting program properties from big code acm sigplan notices vol.
no.
pp.
.
v .
j. hellendoorn c. bird e. t. barr and m. allamanis deep learning type inference in proceedings ofthe 26th acm joint meeting oneuropean software engineering conference and symposium onthe foundations ofsoftware engineering pp.
.
r. s. malik j. patra and m. pradel nl2type inferring javascript function types from natural language information in proceedings ofthe 41st international conference onsoftware engineering.
ieee press pp.
.
c. boone n. de bruin a. langerak and f. stelmach dltpy deep learning type inference of python function signatures using natural language context arxiv preprint arxiv .
.
c. m. khaled saifullah m. asaduzzaman and c. k. roy exploring type inference techniques of dynamically typed languages in ieee 27th international conference onsoftware analysis evolution and reengineering saner pp.
.