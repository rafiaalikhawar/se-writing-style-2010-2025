an evolutionary study of configuration design and implementation in cloud systems yuanliang zhang y haochen he owolabi legunsenz shanshan li wei dong tianyin xuy national university of defense technology changsha hunan china yuniversity of illinois at urbana champaign urbana il usa zcornell university ithaca ny usa zhangyuanliang13 hehaochen13 shanshanli wdong nudt.edu.cn legunsen cornell.edu tyxu illinois.edu abstract many techniques were proposed for detecting software misconfigurations in cloud systems and for diagnosing unintended behavior caused by such misconfigurations.
detection and diagnosis are steps in the right direction misconfigurations cause many costly failures and severe performance issues.
but we argue that continued focus on detection and diagnosis is symptomatic of a more serious problem configuration design and implementation are not yet first class software engineering endeavors in cloud systems.
little is known about how and why developers evolve configuration design and implementation and the challenges that they face in so.
this paper presents a source code level study of the evolution of configuration design and implementation in cloud systems.
our goal is to understand the rationale and developer practices for revising initial configuration design implementation decisions especially in response to consequences of misconfigurations.
to this end we studied configuration related commits from a .
year version control history of four large scale activelymaintained open source cloud systems hdfs hbase spark and cassandra .
we derive new insights into the software configuration engineering process.
our results motivate new techniques for proactively reducing misconfigurations by improving the configuration design and implementation process in cloud systems.
we highlight a number of future research directions.
i. i ntroduction software configuration design and implementation have significant impact on the functionality reliability and performance of large scale cloud systems.
the idea behind configuration is to expose configuration parameters which enable deployment time system customization.
using different parameter values system users e.g.
operators sysadmins and devops engineers can port a software system to different environments accommodate different workloads or satisfy new user requirements.
in cloud systems configuration parameters are changed constantly.
for example at facebook configuration changes are committed thousands of times a day significantly outpacing source code changes .
with the high velocity of configuration changes misconfigurations in the form of erroneous parameter values inevitably become a major cause of system failures severe service outages and downtime.
for example misconfigurations were the second largest cause of service level disruptions in one of google s main production services .
misconfigurations also contribute to of production incidents at facebook including the worst ever outage of facebook and instagram thatoccurred in march .
similar statistics and incidents were reported in other systems .
software configurations also impose significant total cost of ownership on software vendors who need to diagnose userreported failures or performance issues caused by misconfigurations.
vendors may even have to compensate users if the failures lead to outages and downtime.
software vendors also need to support and help users with configuration related questions e.g.
how to find the right parameter s and set the right value s .
note that system users are often not developers they may not understand implementation details or they may not be able to debug code .
unfortunately configuration design and implementation have been largely overlooked as first class software engineering endeavors in cloud systems except for few recent studies section viii .
the focus has been on detecting misconfigurations and diagnosing their consequences .
these efforts tremendously improve system level defenses against misconfigurations but they do not address the fundamental need for better software configuration design and implementation.
yet better configuration design can effectively reduce user difficulties reduce configuration complexity while maintaining flexibility and proactively reduce misconfigurations .
also better configuration implementation can help detect and correct misconfigurations earlier to prevent failure damage .
the understanding of what constitutes software configuration engineering in cloud systems is preliminary in the literature compared with other aspects of engineering these software systems e.g.
software architecture modeling api design and testing which are well studied.
meanwhile we observed that developers struggle to design and implement configurations.
for example we found that developers raise many configuration related concerns and questions is the configuration helpful?
spark can we reuse an existing parameter?
hdfs what is a reasonable default value?
hbase .
furthermore we found that developers frequently revise configuration design implementation decisions usually after observing severe consequences e.g.
failures and performance issues induced by the initial decisions sections iv a1 and iv a2 .
this paper presents a source code level study of the evolution of configuration design and implementation in cloud ieee acm 43rd international conference on software engineering icse .
ieee table i summary of our findings on configuration design and implementation and their implications.
findings about configuration interface implications f.1software developers often parameterize constant values into i.1configuration auto tuning techniques that consider reliability and funcconfiguration parameters.
performance and reliability tuning are common tionality are needed in addition to performance only optimization.
timing rationales for such parameterization.
parameters are an example critical to both performance and reliability .
f.2over of parameterizations were driven by severe consequences i.2techniques for identifying pathological configuration use cases through of deficiencies in constant values.
unfortunately use cases that drove the testing and analysis are desired.
tools that can identify and categorize use parameterization were often poorly discussed or documented.
cases could help proactively parameterize deficient constants.
f.3only .
of default value changes mentioned systematic testing i.3many default values in existing software systems may not be optimal.
.
of default changes chose values that work around reported issues.
research on how to better select default values is needed.
findings about configuration usage implications f.4most configuration checking code were added as afterthoughts i.4proactive parameter value checking and validation can prevent many postmortem to system failures and performance issues in production.
severe consequences but they are still not a common engineering practice .
f.5over of checks added as afterthoughts are basic non emptiness i.5automated solutions for generating basic checking code and applying and value range checks other commits invoked checking code earlier.
them in program early execution phases are useful and feasible.
f.6throwing exceptions is common for handling misconfigurations i.6automatically correcting configuration errors is feasible and should be auto correction is not missing opportunities to help users handle errors.
explored in future research.
f.7developers often enhance configuration related log exception mess i.7techniques on automated enhancement of configuration related log and ages by including related parameters and providing guidance.
exception messages to improve misconfiguration diagnosis are needed.
f.8reusing existing parameters in different program locations is a com i.8tools are needed for identifying and fixing various inconsistencies mon practice.
however parameter reuse leads to various inconsistencies.
among configuration parameters and their code implementations.
findings about configuration documentation implications f.9inadequate and outdated information are major reasons behind i.9enforcing complete up to date documentation of configuration infothe changes that enhance configuration documents.
mation is still a challenge despite a lot of research effort .
f. configuration use cases parameter constraints and dependencies i. configuration documentation should be systematically augmented between parameters are commonly added to documents.
to include critical user facing information.
systems towards filling the knowledge gap and better understanding the needs that configuration engineering must meet.
specifically we study configuration related commits spanning .
years .
.
in four large scale widely used and actively maintained open source cloud systems hdfs hbase spark and cassandra .
each commit that we study is associated with a jira github issue or a pull request link which provides more context about the change and the discussions among developers.
section iii describes our methodology for selecting configuration related commits .
our goal is to understand current configuration engineering practices identify developer pain points and highlight future research opportunities.
we focus on analyzing commits that revise or refine initial configuration design or implementation decisions instead of commits that add or remove parameters as code evolves.
these revisions or refinements were driven by consequences of misconfigurations.
our analysis helps to understand the rationale for the changes learn design lessons and engineering principles and motivate future automated solutions that can prevent such consequences.
to systematically analyze configuration related commits we propose a taxonomy of configuration design and implementation changes in cloud systems along three dimensions interface why and how developers change the configuration interface parameters default values and constraints .
usage how developers change and improve parameter value checking error handling and uses.
documentation how developers improve configuration documentation.
note that this paper focuses on cloud systems instead of desktop software or mobile apps because misconfiguring cloud systems results in more far reaching impact.
moreover we focus on runtime configurations whose values can be changed post deployment without re compiling the software.runtime configurations fundamentally differ from compiletime configurations such as ifdef based feature flags .
but runtime and compile time configurations have similar problems.
so there are opportunities to extend techniques that solve problems for one to the other.
this paper makes the following contributions ?study and insights.
we study code changes to understand the evolution of configuration design and implementation in cloud systems.
we find insights that motivate future research on reducing misconfigurations in these systems.
?taxonomy.
we develop a taxonomy of cloud system configuration design and implementation evolution.
?data.
we release our dataset and scripts at com xlab uiuc open cevo to help followup research.
a detailed replication package can be found in .
table i summarizes our findings and their implications.
ii.
t axonomy figure shows the three parts of our taxonomy of cloudsystem configuration engineering interface usage and documentation .
we focus on aspects that affect how system users interact with configurations and not on developer focused usehandlingfeedbackpasscheckfailcorrectionthrowexceptionparseusagedocumentationinterfacevalue typevalue rangedependence...namedefault valueconstraintsp1p2p3pn...user manualscode commentsstructuredentriestutorials guides ... fig.
three parts of our taxonomy of software configuration design and implementation and their components.
189table ii our taxonomy of configuration engineering evolution.
interface s ection iv addparam add new configuration parameters add newcode add new parameters when introducing new modules add codechange add new parameters due to changes in existing code add parameterization convert constant values to configuration parameters removeparam remove existing configuration parameters rmv rmvmodule remove parameters when removing existing modules rmv replace replace parameters with constants or automation modifyparam modify existing configuration parameters mod naming change the name of a configuration parameter mod defaultvalue change the default value of a configuration parameter mod constraint change the constraints of a configuration parameter usage s ection v parse change configuration parsing code check change configuration checking code handle change configuration error handling code handle action handling actions correction and exceptions handle message feedback messages log and exception messages use change how configuration values are used use change change existing code that uses parameters use add add code to reuse a configuration parameter documentation s ection vi user manual change configuration related user manual content code comment change configuration related source code comments aspects like variability and testability.
we organize our study along the categories shown in table ii.
interface.
the configuration interface that a system exposes to users consists primarily of configuration parameters parameters for short .
as shown in fig.
a parameter is identified by a name and it typically has a default value .
users can customize system configuration by changing parameter values in configuration files or by using command line interfaces clis .
each parameter places constraints correctness rules on its values e.g.
type range dependency on other parameters.
values that violate the constraints lead to misconfigurations.
in table ii changes that contribute to configuration interface evolution include adding parameters removing parameters and modifying parameters.
usage.
fig.
presents the configuration usage model.
to use a parameter the software program first reads its value from a configuration file or cli parses the value and stores it in a program variable.
the variable is then used when the program executes.
in principle the program checks the value against the parameter s constraints before using it.
if checks fail the program needs to handle the error and provide user with feedback messages .
in table ii configuration usage evolution consists of changes to all parts of the usage model.
documentation.
these are natural language descriptions related to configurations.
we consider changes to user manuals and code comments the former are written for system users while the latter are written for developers.
iii.
s tudy setup to understand how configuration design implementation evolve we identified and analyzed configuration related commits that modify configuration design and implementation.
following we refer to the design implementation andtable iii software and their commits that we study.
subject description params allc s tudied c hdfs file system hbase database spark data processing cassandra database maintenance of software configuration as configuration engineering .
we start from commits instead of bug databases e.g.
jira and github issues because configuration design and implementation evolution is not limited to bug fixing.
all cloud systems that we study record related issue or pull request id s in commit messages section iii a .
we found detailed context about changes in the configuration related commits through developer discussions.
moreover commits allow us to analyze the diffs the actual changes.
a. target software and version histories we study configuration design and implementation in four open source cloud systems shown in table iii hdfs hbase spark and cassandra.
these projects have many configuration parameters and configuration related commits are mature actively developed and widely used with well organized github repositories and bug databases link to issue ids in commit messages and are commonly used subjects in cloud and datacenter systems research.
in these subjects we studied configuration related commits from june to december a .
year time span.
in table iii params is the total number of documented parameters in the most recent version allc is the total number of commits in the .
year span and studied c is the number of configuration related commits that we studied.
we excluded configuration related commits that only added or modified test cases we expected such commits to yield less insights on design implementation evolution.
in total we studied configuration related commits.
b. data collection and analysis to find configuration related commits within our chosen time span we wrote scripts to automate the analysis of commit messages and diffs filter out irrelevant commits and select likely configuration related commits.
then we manually inspected each resulting commit and its associated issue.
overall we collected commits by analyzing commit messages and commits by analyzing the commit diffs yielding a total of configuration related commits.
analysis of commit messages keyword search on commit messages is commonly used to find related commits e.g.
.
we manually performed a formative study with hundreds of commit messages and found that three strings commonly occur in configuration related commits config parameter and option .
these strings were previously used in keyword searches and matched times in all four subjects.
we manually inspected these commits and removed commits that did not change configurations yielding configuration related commits.
analysis of commit diffs many commit messages do not match during keyword search even though the diffs show configuration related changes.
so we further analyzed diffs to find more configuration related commits and found additional configuration related commits.
our diff analysis determines whether diffs modify how parameters are defined loaded used or described.
accurate automated diff analysis requires applying precise taint tracking treating parameter values as initial taints that are propagated along control and data flow paths to each commit and its predecessor and comparing the taint results in both commits.
such pairwise analysis does not scale well to the commits in all four projects table iii .
to scale diff analysis we used a simple text based search of configuration metadata including the configuration interface including how configurations are defined and loaded default configuration file and message that contains configuration information.
metadata are expected to be stable in the mature cloud systems that we study commits that modify them may yield good insights on configuration evolution.
finding commits that change parameter definitions.
we start from commits that change default configuration files or parameter descriptions in those files.
these two locations are key user facing parts of configuration design .
thus modification of parameters introduction deprecation changes to default values etc.
likely requires changes to either.
this heuristic was effective it found additional configurationrelated commits with an average false positive rate of .
.
finding commits that change parameter loading or setting.
here we leverage knowledge of configuration apis.
as reported in prior studies and validated in our study mature software projects have unified welldefined apis for retrieving and assigning parameter values.
for instance hdfs has getter or setter methods e.g.
getint getboolean declared in a java class each of which has a corresponding setter method e.g.
setint setboolean .
the other evaluation subjects follow this pattern.1so identifying commits that changed code containing getter or setter method usage requires a few lines of code using regular expressions.
this heuristic found additional configuration related commits with a .
average false positive rate.
finding commits that change parameter value data flow.
if a commit changes code with variables that store parameter values then that commit is likely related to the data flow of parameter values.
we implemented a simple text based taint tracking to track such variables as follows.
once a configuration value is stored in a variable we add the variable name to a global taint set.
we perform the tracking for every commit in the time span that we studied.
we do not remove variables from our taint set.
we output candidate commits where a modified statement contains a variable name in the 1this is common in java and scala projects the configuration interface typically wraps around core library apis such as java.util.properties to provide configuration getter and setter methods.table iv configuration related commits by category.
some commits contain changes in multiple categories.
interface behavior document commit hdfs .
.
.
hbase .
.
.
spark .
.
.
cassandra .
.
.
total .
.
.
taint set.
taint tracking found additional configurationrelated commits with an average false positive rate of .
.
identifying other configuration related commits we applied the same keyword search on commit messages section iii b1 to messages that occur in diffs to capture commits that change related exception or log messages without modifying any other code.
we found additional configuration related commits with an average false positive rate of .
.
inspection and categorization at least two authors independently studied each configuration related commit and its corresponding issue.
they independently categorized each commit based on the taxonomy in section ii and then met to compare their categorization.
when they diverged a third author was consulted for additional discussion until consensus was reached.
further in twice weekly project meetings the inspectors met with a fourth author to review their categorization of of commits inspected during the week.
these meetings helped check that understanding of the taxonomy is consistent.
our experience shows that consistently checking a taxonomy like figure with concrete examples significantly improves inter rater reliability and categorization efficiency.
note that we categorized each commit based on how it revised the original configuration design implementation.
if a commit adds a new parameter and also a manual entry to document this new parameter we treat this commit as add param table ii the commit revises the configuration interface instead of documentation.
some commits modify multiple sub parts in our taxonomy.
data collection results table iv shows the studied configuration related commits along the three parts of our taxonomy.
there is a significant number of commits in each part.
the rest of this paper summarizes our analysis and provides insights on how configuration design and implementation evolve along these three parts.
iv.
c onfiguration interface evolution changes to the configuration interface were the most common compared with behavior or documentation changes table iv .
we focus on analyzing changes to configurability the level of user facing configuration flexibility section iv a and default values section iv b .
we omit other kinds of configuration interface changes which are often routine and cannot directly lead to misconfigurations.
a. evolution of user facing configuration table v shows our categorization of changes to configurability.
most changes add or remove parameters per project 191table v statistics on configuration interface changes.
hdfs hb ase spark cassandra total addp aram add newcode add codechange add parameterization remo veparam rmv rmvmodule rmv replace modifyp aram mod naming mod defaultvalue mod constraint removal is .
to .
less frequent than addition with an average of .
.
we find that adding or removing parameters occur naturally during software evolution parameters are added with new code and removed with code deletion.
we do not focus on co addition or co removal of parameters with code.
rather we focus on changes that revise previous configuration engineering decisions by parameterizing constants and eliminating parameters or converting them to constants.
our data corroborates a prior finding that configuration interface complexity increases rapidly over time as more parameters are added than are removed.
complexity measures the size of the configuration space number of parameters multiplied by the number of all their possible values .
approaches for dealing with the rapid growth rate are desired.
variability modeling which is extensively researched for compile time configurations can potentially be extended to understand and manage runtime configuration complexity.
parameterization developers often convert constants into parameters after discovering that one constant cannot satisfy all use cases.
we find commits that parameterize constants parameterizations .
we report on rationales for the parameterizations how developers identify constants to parameterize use cases that made constants insufficient and how developers balance increase in configuration complexity caused by adding new parameters with the need for flexibility which necessitates parameterization .
our results have ramifications for configuration interface design we provide understanding for managing the configurability versus simplicity tradeoff.
the rationales for parameterization also motivate configuration parameter auto tuning.
rationales for parameterization.
these include performance tuning reliability environment setup manageability debugging compatibility testability and security.
table vi shows for each rationale the number of commits and parameters an example parameter and a description.
we discuss the top two rationales due to space limits.
performance tuning was the top rationale for parameterizing constants involving .
of parameters in commits.
different workloads need different values so it is hard to find one size fits all constants.
resource related e.g.
buffer size and thread number feature selection turning on off features with performance impact e.g.
monitoring and timing logic mostly timeouts and intervals were the main resulting parameter types with20.
.
and .
new parameters respectively.
others .
set algorithm specific parameters e.g.
weights and sample sizes .
reliability with of of the parameterizations was the second most common rationale.
of these were caused by hardcoded timeout values that led to constant request failures in the reported deployments so developers made them configurable.
note that new timing parameters were created for both reliability and performance tuning.
for example in hdfs a new timing parameter was created to improve performance.
the previous constant was causing a delete file task to wait for... too long hbase .
but another hdfs timing parameter was created to improve reliability.
the previous constant was too small causing timeouts while creating 3tb volume hdfs .
discussion configuration auto tuning techniques that consider reliability and functionality are needed in addition to performance only optimization .
specifically timing parameters have important implications to both reliability and performance however not much work has been done on auto tuning timing parameters e.g.
timeouts and intervals .
how de velopers find constants to parameterize.
.
of parameterizations were postmortem to se vere consequences e.g.
system f ailures performance degradation resource o veruse and incorrect results.
among previous constants for these .
led to performance degradation .
caused se vere failures .
led to incorrect or unexpected results e.g.
data loss and wrong output and .
resulted in resource o veruse.
discussion despite the efforts in parameterization developers still overlook deficient constants that may lead to severe consequences e.g.
failures and performance issues .
proactive techniques for detecting deficient constants and for automating parameterization are needed the latter could assist performance testing of cloud systems.
describing use cases that pr ompt parameterization.
use cases where constants were deficient should be described fully to help users set correct v alues.
but developers described theconcrete use cases that prompt parameterization for only .
parameters.
others discussed use cases either vaguely .
or parame ters or provided no information .
or parameters .
table vii shows examples.
discussion future work should identify and document use cases and workloads including which parameters can be tuned and suggest beneficial configuration values that are designed for concrete use cases.
192table vi statistics and examples of developers rationales for parameterization excluding two commits that lacks information .
rationale commit param example newparameter limitation of previous constant performance spark.sql.codegen.cache.maxentries the cache size does not work for online stream processing spark reliability spark.sql.broadcastexchange.maxthreadthreshold out of memory if thread object garbage collection is too slow spark manageability dfs.federation.router.default.nameservice.enable enable the default name service to store files hdfs debugging spark.kubernetes.deleteexecutors disable auto deletion of pods for debugging and diagnosis spark environment dfs.cblock.iscsi.advertised.ip allows server and target addresses to be different hdfs compatibility spark.network.remotereadniobufferconversion add the parameter to fall back to an old code path spark testability spark.security.credentials.renewalratio may not need to be set in production but can make testing easier spark security spark.sql.redaction.string.regex the output of query explanation can contain sensitive information spark table vii use case description of parameterization changes.
level example concrete volume creation times out while creating 3tb volume hdfs .
vague ifmany regions on a regionserver the default will be not enough hbase .
noinfo itwould be better if the user has the option instead of a constant spark .
balancing flexibility and simplicity configuration interface design must balance flexibility i.e.
configurability with simplicity .
new parameters increase flexibility by handling additional use cases but increase interface complexity thus reducing usability .
.
of parameterization commits contained developer discussions on the flexibilitysimplicity tradeoff.
most discussed estimated prevalence of use cases for parameterization it is not worth increasing interface complexity for rare use cases and typically involve advanced users e.g.
admittedly this...is an expert level setting useful in some cases cassandra .
we also found developers debates on whether to parameterize cassandra hdfs12496 spark .
amiddle ground solution is to parameterize without documenting or exposing the parameter e.g.
although...not widely used i could see allowing control...via an undocumented parameter spark .
with this practice not all but the most advanced users know of such parameters.
we found that .
of the newly added parameters were not documented in the parameterization commit indicating that these parameters were first added as middle ground solutions.
discussion further studies are needed on if and why undocumented parameters are eventually documented and how often and why expert users modify un exposed parameters in order to understand the intent and utility of such parameters.
specifically visibility conditions from variability modeling can be extended to manage the tradeof f of fle xibility v ersus simplicity which can benefit navig ation support and user guidance .
currently visibility conditions are mainly designed for boolean feature flags based on dependenc y specifications e.g.
in cdl and kconfig complexity metrics and variability analysis for other parameter types e.g.
numeric and strings are needed.
remo ving p arameter s understanding parameter removal can yield insights on reducing configuration interf ace complexity .
we examined all configurationrelated commits that remo ved a parameter not co remo val with code .
all remov ed parameters were con verted to constants or code logic was added that obviated them.
remov ed parameters were con verted to constants to their default values and to safe v alues.
de velopers mentioned that ofthe parameters had no clear use case e.g.
hbase hbase or required users to understand implementation details e.g.
cassandra .
three parameters confused users or might lead to se vere errors e.g.
spark .
three of remo ved parameters were obviated by ne w automation logic.
for example in hbase hbase.r egionserver.handler.countwhich specified the number of concurrently updating threads to be garbage collected in a javaconcurrenthashmap was remo ved after de velopers switched to threadlocal syncfuture which automatically garbage collects terminated threads.
this example shows how implementation choices could af fect configuration complexity .
discussion future studies can evaluate the utility and impact of each parameter e.g.
by analyzing if and how often deployed values are equal or similar to the default values .
configurations with low utility can be replaced with constants e.g.
default values .
b.evolution of default v alues parameter default values are important to the usability of configurable systems they provide users with good starting points for setting parameters without needing to understand the entire configuration space.
thus de velopers usually choose default values that satisfy common use cases.
ideally adefault value applies under most common workloads without causing f ailures hbase hbase hdfs .
the mod defaultvalue row in table v sho ws commits that changed default values.
wediscuss wh y def ault v alues changed and how new default values were chosen.
reasons f or changing default v alues.
weobserve proactiv e and reacti vedefault value changes.
.
def aultvalue changes were proactiv e incl uding enabling a previously disabled feature flag .
e.g.
running 193the feature in production for a while with no issues so enabled the feature by default hdfs performance reasons .
e.g.
sets properties at values yielding optimal performance hbase and supporting new use cases .
e.g.
it may be a common use case to ...list queries on these values cassandra .
the remaining .
of default value changes were reactive to user reported issues including system failures and performance anomalies due to not supporting new workloads deployment scale hardware etc .
inconsistencies with user manual .
and working around software bugs .
e.g.
we set the parameter to false by default for spark .
and re enable it after addressing the lock congestion issue spark .
choosing new values.
it is straightforward to change new default values for boolean and enumerative parameters given their small value ranges.
so we describe how new default values of numeric parameters were chosen excluding those that fix default value inconsistency e.g.
hbase .
only .
numeric parameters had systematic performance testing and benchmarking mentioned in the jira github issues.
later commits reset these new default values despite the initial testing and benchmarking.
for example hbase developers performed write only workload evaluation...read performance in read write workloads.
we investigate several settings... hbase .
yet we found three later commits that changed the default value of the same parameter to different numbers.
for .
of numeric parameters new default values were chosen by adjusting the previous default values to resolve production failures.
in many of these cases usually without high confidence in the new default values developers simply chose values that resolve the problem s .
examples it probably makes sense to set it to something lower spark or i m thinking something like or would be safer hbase .
we found no information on the remaining .
numeric parameters.
we observe that backward compatibility and safety are common considerations in selecting new default values.
new default values that radically change system behavior are often considered inappropriate e.g.
hbase .
discussion default value changes are often reactive to the reported issues without systematic assessment.
systematic testing and evaluation of new and existing default values are needed.
dynamic workloads and heterogenous deployments necessitate continuous and incremental changes to default values.
future w ork could maintain a set of default values instead of one for typical w orkloads hardw are and scale.
c. summary there is an unmet need for practical configuration automation te chniques and tools for choosing and testing parameter values wh y do cloud system developers still change parameter v alues statically rather than using parameter automation?table viii statistics on configuration usage e volution.
hdfs hb asespark cassandra total parse check handle handle action handle message use use change use add there is also need for automatic ways of identifying workloads or use cases for which def ault v alues and even constants are ill suited.
such automatic w orkload identification approaches can help developers to better decide which constant v alues need to be parameterized understand when their current default values will lead to sys tem f ailures and come up with better tests and benchmarks for default values.
v.configurationusageevolution wepresent results on configuration usage e volution recall the configuration usage model described in fig.
and section ii .
across the four cloud systems .
.
of commits changed parameter usage table viii .
w e describe changes to checking error handing and use of parameters.
w e omit changes to parsing apis e.g.
spark .
a. evolution of parameter checking code proactiv ely checking parameter v alues is key to preventing misconfigurations .
howe ver we find that many parameters had nochecking code when the y were introduced.
checking code was added reactively .
of commits that changed checking code occurred after users reported runtime f ailures service unav ailability incorrect unexpected results startup failures etc.
t able ix shows examples .
in .
commits de velopers proactively added or impro vedthe checking code of them applied reacti velyadded checking code to other parameters with similar types e.g.
cassandra .
w e did not find sufficient information of the other commits .
adding new checking code ne w checks were added in .
of checking code related commits.
.
of these ne w checks were for specific parameters while the others were applied to groups of configuration parameters e.g.
read only parameters .
surprisingly for specific parameter checks checks in commits .
were basic checks not null v alue range and deprecation checks .
an example is in fig.
a .
majority of ne w checking code were added reacti vely corroborating that simple checks can prevent man y severe failures .
more of such checks could be automatically added and invoked at system startup.
the other checks were more complex value semantic checks e.g.
file uri properties and data alignment fig.
b checks for parameter dependencies e.g.
fig.
c and checks for e xecution context e.g.
fig.
d .
194table ix examples of consequences that can be prevented by adding configuration checking code.
consequence example parameter description runtime error hbase.bucketcache.bucket.sizes if value is not aligned with instantiating a bucket cache throws ioexception hbase early termination commitlog segment size in mb if value cassandra throws an exception when creating commit logs cassandra service unavailability spark.dynamicallocation.enabled running barrier stage with dynamic resource allocation may cause deadlocks spark unexpected results spark.sql.shuffle.partitions if the value is the result of a table join will be an empty table spark if writetables null writetables .
isempty throw new illegalargumentexception configurtion parameter output table name conf key cannot be empty a add a not null check hbase if bucketsize !
throw new illegalargumentexception illegal value bucketsize configured for bucket cache buckets key all bucket sizes to be multiples of b add a semantic check hbase require conf .
getoption authkey .
isempty !
restserverenabled s the restsubmissionserver does not support authentication via authkey .
either turn off spark .
master .
rest .
enabled or do not use authentication .
c add a check for parameters dependency spark if rdd .
isbarrier utils .
isdynamicallocationenabled sc.
getconf throw new sparkexception barrier execution mode does not support dynamic resource allocation for now .
you can disable dynamic resource allocation setting spark .
dynamicallocation .
enabled to false d add a check for execution context spark fig.
examples of configuration checking code.
improving existing checking code commits improved existing checking code eight made checks more strict e.g.
a not null check was improved to only allow table replication for sync replication hbase and three moved checking code to be invoked earlier instead of during subsequent execution e.g.
when starting task scheduler spark.task.cpus should be checked spark .
discussion checks for parameter values are often added as afterthoughts.
proactively generating checking code can help prevent failures due to misconfigurations.
two poss ible directions are automatically learning checking code we find that newly added checking code is often simple and automatically applying checking code for one parameter to other parameters both in the same software which developers are already manually and across softw are projects.
a direction is to co learning checking code and usage code.
techniques for extracting complex constraints and specifications can reduce manual effort for reasoni ng about and implementing checking code.
a fe w recent works show promise for inferring parameter constraints through analysis ofsource code and documentation .
techniques for extracting feature constraints could be extended and applied to runtime configurations .
b. evolution of err or handling code wediscuss changes to misconfiguration related exceptionhandling code and to messages that provide user feedback.
chang es to configuration error handling commits dealt with error handling added new handling code totry catch blocks or throw new exceptions commits changed handling code.
among the commits four changed misconfiguration correction code three of these added logic to handle a misconfiguration e.g.
if secr et file specified in httpfs.authentication.signature .secret.file does not exist random secret is generated hdfs and one changed b uggy misconfiguration correction code to simply log errors hdfs showing that auto correcting misconfigurations is not al ways easy three changed the e xception type as it was danger ous to throw statements whose exception class does notaccurately describe why they arethrown...since it mak es corr ectly handling them c hallenging hdfs and two replaced e xception thro wing with logging the errors and resuming the execution.
wealso studied the ne wly added handling code in the commits that added ne w checking code in section v a1.
in .
of the cases the handling code threw runtime exceptions or logged error messages.
the e xpectation is that users should handle the errors.
in the remaining .
cases de velopers attempted to correct the misconfigurations e.g.
it sdeveloper s responsibility to make sure the configuration don t break code.
spark .
developers corrected misconfigurations by changing to the closest value in the valid range re verting to the default value a nd using the v alue of another parameter with similar semantics .
discussion developers want to make code more robust in the presence of misconfigurations but their manual efforts are often ad hoc.
there is need for new techniques for generating misconfiguration correction code and improving existing handling code.
techniques for fixing compile time configuration errors such as range fix es may be applicable for generating correction strate gies for some types of runtime parameters.
a key challenge is to attribute runtime errors e.g.
e xceptions to misconfigurations and to rerun the related e xecution with the corrected configurations.
195table x four levels of message feedback quality in commits that changed exception or logging messages.
level description example l4contain parameter names and barrier execution mode does not support dynamic resource allocation... you can disable dynamic provide guidance for fixing resource allocation by setting... spark.dynamicallocation.enabled to false.
spark l3 contain parameter names failed to create ssl context using server encryption options .
cassandra l2 do not contain parameter names this is commonly a result of insufficient yarn configuration.
hbase l1 no mention of configuration could not modify concurrent moves thread count.
hdfs changes to feedback messages feedback error log or exception messages are important for users to diagnose and repair misconfigurations.
we investigated commits that modified feedback messages and categorize the level of feedback that they provided in table x where l4 messages provide the highest quality feedback and l1 messages provide the lowest quality feedback.
among commits that modified messages enhanced feedback quality by adding configuration specific information.
after enhancement messages became l3 and became l4.
changes in the other commits improved correctness half changed imprecise parameter boundary values e.g.
from no less to greater spark readability such as fixing typographic errors the log level and security i.e.
removing potentially sensitive value.
discussion future work could study the feedback level in allmessages related to misconfiguration handling code.
if most messages are not l4 then future work should automatically detect deficient messages and automatically enhance them to l4.
moreov er configuration related logging isnot as mature as logging for deb ugging .
improving configurationrelated l ogging requires logging related parameters erroneous values and where feasible possible fixes.
poor quality feedback from tools hinders developers and techniques exist for dealing with message errors in other domains .
c. evolution of parameter value usag e software developers change how existing parameters are used use change intable viii and reuse e xistin g parameters for dif ferent purposes use add in table viii .
changing how e xisting par ameters areused commits changed parameter usage for the following reasons fine grained contr ol.
in commits de velopers previously used one parameter for multiple purposes due to poor design e.g.
compactioncheck er and periodicmemstoreflusher execution period ar e bound together hbase22596 or for reuse e.g.
arrow .enabled was added... wit h pyspark... later sparkr... was added... controlled by the same parameter .
suppose users want to share some jvm between pyspark and sparkr... the y use the optimization for all or none.
spark .
developers res olved both cate gories by creating separate parameters for fine grained control.
domain scope.
commits changed the usage domain or scope of a parameter.
for example hdfs de veloperschanged a parameter which w as pre viously only used in the decommission phase to also be used in the maintenance phase so lots of code can be shar ed hdfs .
parameter overriding commits changed parameter override priority e.g.
weneed to support both table level parameter s. user s might also use session level parameter ... the precedence would be ... spark .
semantics commits changed what a parameter is used for e.g.
in spark de velopers started using spark.sql.
codegen.hugemethodlimit as the maximum compiled function size instead ofspark.sql.codegen.maxlinesperfunction .
parameter replacement commits swapped one parameter for another because the pre vious one wasoutdated or wrong e.g.
in spark a use ofparquet.enable.summary me tadatawas replaced with a use ofparquet.summary.metada ta.level because the former w as deprecated.
buggy parameter values commits changed parameter values that were buggy e.g.
the v alue of a parameter changed because user specified filters are not applied in y arn mode...we need... user provided filter s spark .
reusing existing parameter s toavoid gro wing the configuration space unnecessarily developers som etimes reuse existing parameters that are similar to their new use case instead of introducing a new parameter.
commits reused existing parameters for different purposes.
ho wever parameter reuse comes at a cost.
w e find two main problems.
first reusing a parameter and code that it controls can result in subtle inconsistencies that can lead to bugs or user confusion.
.
parameter reuses had such inconsistencies.
second de velopers often clone existing code to enable reuse.
wefocus on inconsistencies.
problems of code cloning are the subjects of other research.
wemanually check ed for inconsistencies by comparing the newly added code in a tar get commit with code that used the parameter in existing code base.
w e found inconsistencies in hdfs hbase and spark .
inconsistencies manifest in di fferent ways.
wecategorized them based on the sources of inconsistencies during reuse feedback message e.g.
spark checking code e.g.
hbase ne w uses of deprecated parameters e.g.
hdfs default values e.g.
hbase and use statements e.g.
hbase20586.
fig.
sho ws e xamples of inconsistencies in reuse of checking code and use statements where added lines start with .
in fig.
a the ne w parameter usage did not check for parameter v alue emptiness as the old usage did.
in fig.
b string principal conf .
get constants .
rest kerberos principal if principal !
null ... 5preconditions .
checkargument principalconfig !
null !
principalconfig .
isempty rest kerberos principal should be set if security is enabled a inconsistent checking hbase if peerconf .
get hbase .
security .
authentication .
equals kerberos ... 4issecurityenabled kerberos .
equalsignorecase conf .
get hbase .
security .
authentication 6if issecurityenabled ... b inconsistent parameter usage hbase fig.
examples of configuration inconsistent reuse.
the new usage of hbase.security.authentication checked case insensitive equality the old usage was case sensitive.
discussion inconsistencies in parameter usage can confuse users the same values are used in different ways or lead to bugs.
ideas for detecting bugs as deviations from similar program behavior could be starting points for addressing this problem.
d.summary weadvocate that impro ving softw are qualities resilience diagnosability and consistenc y should be first class principles in softw are configuration engineering.
w e find that e ven in mature production quality cloud systems checking error handling feedback and parameter usage are often not designed or implemented in aprincipled manner .
more research effort should be put on enhancing these essential qualities of configurable softw are to defend ag ainst misconfigurations in addition to detection and diagnosis tools that are external to the cloud system .
vi.
c onfigurationdocumentevolution wevery briefly discuss configuration document evolution comm its made changes to user manuals or code comments.
of these commits changed user manuals and the rest changed code comments.
wediscuss why configuration documents were changed and the changed content.
reasons f or changing configuration documents.
the changes to configuration documents resolved five types of problems were inadequate for users to understand parameters or to set values correctly e.g.
users wondered why spark.sql.shuffle .partitions...unchang ed when they chang ed the config...worth to explain it in guide doc spark were outdated after configuration design and implementation changed section iv and section v were incorrect e.g.
lazyper sistfilescrubber will be disabled if ... configur ed to zer o. but the document was incorr ect hdfs had readability issues e.g.
client rpc timeouts ar e not easy to understand from documentation hbase and5 improv ed content e.g.
add thrift scheduling ... config to sc heduling docs spark .
discussion document as code techniques can be applied to eliminate inconsistencies between configuration documents and configuration design implementation.
content added to enhance documents .inadequate infor mation w as the most c ommon problem resolved by configuration document changes.
w e put the changes that enhanced inadequate documents in six cate gories based on the content added changed constraints on parameter v alues e.g.
this should be positive and less than cassandra explained dependence on other parameters e.g.
this pr operty works with dfs.namenode .invalidate .work.pct.per.iter ation hdfs12079 changed parameter v alue types and units changed parameter scope e.g.
timeout... is contr olled dif ferently.
use hbase .client.scanner.timeout.period property to set this timeout hbase provided use cases and guidance e.g.
enabling this will be very helpful if dfs imag e is lar ge hdfs and warned about deprecation e.g.
this config will be remo ved i n spark .
spark .
discussion ethnographic studies could help understand the gaps between documented configuration information and configuration obstacles faced by users.
summary correctness and ef fectiv eness of technical documentation is a long lasting problem in softw are engineer ing.
configuration documentation is no e xception.
specialized techniques for maintaining and impro ving configuration documentation are needed.
f or example checking for inconsistencies between documents and source code could help detect defects in configuration related code or documents.
also techniques for auto generating documents especially using structured data can be applied to generating per parameter comments and manual entries .
vii.threatstovalidity westudied cloud systems.
some of our findings may not generalize to other kinds of softw are.
w e chose these projects because the y are widely used highly configurable with lots of parameters mature and well maintained.
they also ha ve issue tracking systems that help us unders tand the context of configuration related commits.
though we selected candidate commits from version control history we may ha vemissed some configuration related commits due to tw o limitati ons.
first our re gular e xpressions assume standard coding con ventions and will not match if developers do not follow these con ventions.
second our simple text based tainting may miss some changes to the data flow of variables that store parameter values.
howe ver aswe mentioned in section iii precise pairwise tainting does not scale 197to all the commits in the range that we studied we traded off precision for scalability.
all commits selected were manually inspected and categorized through a rigorous quality assurance process section iii b3 .
false positives came mainly from commits that touched lines containing configuration related variables but did not change the configuration.
viii.
r elated work a prior study found that software evolution necessitates resetting parameter values and built configsuggester to identify parameters whose values need to be changed after a software updates.
we study how the configuration interface and parameter usage change across a portion of version control history to draw insights for better configuration design and implementation.
sayagh et al.
studied software configuration engineering in practice using interviews user surveys and a literature review.
our work is complementary we perform a code level study of configuration evolution which yields new insights.
there have been many studies on misconfigurations in a wide variety of software systems .
our work does not focus on detecting misconfigurations or diagnosing failures caused by misconfigurations.
we focus on current configuration engineering practices with the goal to understand how to improve configuration design and implementation.
recently a few studies investigated automated techniques or engineering practices to enhance configuration checking code diagnosability interface security configuration data analysis configuration libraries and correlations or coupling in configuration and code .
our work corroborates and complements the aforementioned work from the perspective of software evolution.
specifically our work studies the practices ofsoftware developers and reveals how software configuration design and implementation are revised and evolved.
despite the differences appendix a runtime configurations share commonalities with compile time configurations or spl configurations such as ifdef based feature flags .
it is possible that techniques and methodologies designed for compile time configurations especially feature and variability modeling could be adapted for use with runtime configurations.
such adaptation needs to address unique challenges of runtime configuration parameters such as dependencies on deployment environments as well as their complex data types and misconfiguration patterns.
configuration design and implementation have significant implications on software testing and debugging .
for example introducing new parameters enlarges the configuration space and thus makes it more costly to comprehensively test software.
in this paper we focus on understanding how to improve configuration design and implementation so that fewer misconfigurations occur and not on software bugs that can occur under different parameter value combinations.
ix.
c onclusions we presented present an evolutionary study of configuration design and implementation in cloud systems.
to the bestof our knowledge ours is the first evolutionary study on code level runtime configuration design and implementation in these systems.
we analyze rationales and practices for revising configuration design and implementation decisions especially in response to consequences of misconfigurations.
our study yields several new insights into the configuration engineering process and research opportunities for reducing misconfigurations.
our hope is to inspire researchers and developers to treat configuration engineering as a first class software engineering endeavor.
appendix a r untime versus spl c onfiguration a very frequent request is to compare runtime configuration the type of configuration studied in this paper with software product lines spl configuration often referred to as feature flags or feature toggles and to position the work in the area of spl and variability modeling.
we explicitly discuss a few fundamental differences first runtime configurations are changed by software users operators sysadmins in our context spl configurations are managed by developers.
since users are unfamiliar with code the configuration specifications become the interfaces section iv .
moreover as users are prone to misconfigurations checking and providing feedback are critical section v .
second runtime configurations are implemented differently than spl configurations.
runtime configurations are mostly in the form of configuration parameters that load values from files or command lines spl configurations are typically in the form of preprocessors that determine modules to be included in the released binary.
third runtime configurations of cloud software are changed frequently hundreds to thousands of times a day spl configurations are typically changed with product release cycles.
this higher velocity of runtime configuration changes increases misconfiguration occurrences and makes checking error handling and logging critical.
fourth runtime configurations depend on the deployment environment including machine resources e.g.
cpu memory and storage operating systems e.g.
files ip addresses and ports and workloads data size and requests per seconds .
in contrast spl configurations are often determined before software release or system deployment.
lastly runtime configurations have more complex data types e.g.
string and numeric with different error patterns spl configurations are mostly boolean or enumerative types.
certainly ideas in spl and variability modeling can be extended and applied to runtime configuration.
we have discussed them in context of our analysis throughout the paper.
acknowledgement we thank xiangbing huang xudong sun sam cheng jack chen and darko marinov for discussions.
the research was mainly conducted when zhang was a visiting student at uiuc supported by china scholarship council.
zhang he li and dong were supported in part of national key r d program of china no.
2017yfb1001802 nsfc no.
and .
xu was supported in part of nsf .
198references c. tang t. kooburat p. venkatachalam a. chander z. wen a. narayanan p. dowell and r. karl holistic configuration management at facebook in sosp .
l. a. barroso u. h lzle and p. ranganathan the datacenter as a computer designing warehouse scale machines .
.
j. shieber facebook blames a server configuration change for yesterday s outage.
facebook blames a misconfigured server for yesterdays outage .
g. amvrosiadis and m. bhadkamkar getting back up understanding how enterprise data backups fail in usenix atc .
z. yin x. ma j. zheng y .
zhou l. n. bairavasundaram and s. pasupathy an empirical study on configuration errors in commercial and open source systems in sosp .
s. kendrick what takes us down?
usenix login vol.
no.
.
a. rabkin and r. katz how hadoop clusters break ieee software vol.
no.
.
h. s. gunawi m. hao r. o. suminto a. laksono a. d. satria j. adityatama and k. j. eliazar why does the cloud stop computing?
lessons from hundreds of service outages in socc .
b. maurer fail at scale reliability in the face of rapid change cacm vol.
no.
.
d. oppenheimer a. ganapathi and d. a. patterson why do internet services fail and what can be done about it?
in usits .
k. nagaraja f. oliveira r. bianchini r. martin and t. nguyen understanding and dealing with operator mistakes in internet services in osdi .
t. xu l. jin x. fan y .
zhou s. pasupathy and r. talwadker hey you have given me too many knobs!
understanding and dealing with over designed configuration in system software in fse .
t. xu j. zhang p. huang j. zheng t. sheng d. yuan y .
zhou and s. pasupathy do not blame users for misconfigurations in sosp .
t. xu h. m. naing l. lu and y .
zhou how do system administrators resolve access denied issues in the real world?
in chi .
t. xu v .
pandey and s. klemmer an hci view of configuration problems arxiv .
.
t. xu x. jin p. huang y .
zhou s. lu l. jin and s. pasupathy early detection of configuration errors to reduce failure damage in osdi .
m. attariyan and j. flinn automating configuration troubleshooting with dynamic information flow analysis in osdi .
m. attariyan m. chow and j. flinn x ray automating root cause diagnosis of performance anomalies in production software in osdi .
m. attariyan and j. flinn using causality to diagnose configuration bugs in usenix atc .
s. zhang and m. d. ernst automated diagnosis of software configuration errors in icse .
j. zhang l. renganarayana x. zhang n. ge v .
bala t. xu and y .
zhou encore exploiting system environment and correlation information for misconfiguration detection in asplos .
h. j. wang j. c. platt y .
chen r. zhang and y .
m. wang automatic misconfiguration troubleshooting with peerpressure in osdi .
y .
m. wang c. verbowski j. dunagan y .
chen h. j. wang c. yuan and z. zhang strider a black box state based approach to change and configuration management and support in lisa .
m. santolucito e. zhai and r. piskac probabilistic automated language learning for configuration files in cav .
m. santolucito e. zhai r. dhodapkar a. shim and r. piskac synthesizing configuration file specifications with association rule learning in oopsla .
z. dong a. andrzejak and k. shao practical and accurate pinpointing of configuration errors using static analysis in icsme .
p. huang w. bolosky a. sigh and y .
zhou confvalley a systematic configuration validation framework for cloud services in eurosys .
s. baset s. suneja n. bila o. tuncer and c. isci usable declarative configuration specification and validation for applications systems and cloud in middleware .
m. sayagh n. kerzazi and b. adams on cross stack configuration errors in icse .
x. sun r. cheng j. chen e. ang o. legunsen and t. xu testing configuration changes in context to prevent production failures in osdi .
d. norman design rules based on analyses of human error cacm vol.
no.
.
d. norman design principles for human computer interfaces in chi .
r. a. maxion and r. w. reeder improving user interface dependability through mitigation of human error jhcs vol.
no.
.
m. sayagh n. kerzazi b. adams and f. petrillo software configuration engineering in practice interviews survey and systematic literature review tse vol.
no.
.
j. meinicke c. p. wong b. vasilescu and c. k stner exploring differences and commonalities between feature flags and configuration options in icse seip .
y .
zhang h. he o. legunsen s. li w. dong and t. xu an evolutionary study of configuration design and implementation in cloud systems with replication package arxiv submit .
s. zhang and m. d. ernst which configuration option should i change?
in icse .
q. luo f. hariri l. eloussi and d. marinov an empirical analysis of flaky tests in fse .
j. bernardo d. da costa and u. kulesza studying the impact of adopting continuous integration on the delivery time of pull requests inmsr .
m. rigger s. marr b. adams and h. m ssenb ck understanding gcc builtins to develop better tools in fse .
l. p. hattori and m. lanza on the nature of commits in ase .
s. dutta o. legunsen z. huang and s. misailovic testing probabilistic programming systems in fse .
a. rabkin and r. katz static extraction of program configuration options in icse .
a. rabkin and r. katz precomputing possible configuration error diagnosis in ase .
m. lillack c. k stner and e. bodden tracking load time configuration options in ase .
t. xu and y .
zhou systems approaches to tackling configuration errors a survey acm surveys vol.
no.
.
f. behrang m. b. cohen and a. orso users beware preference inconsistencies ahead in fse .
r. lotufo s. she t. berger k. czarnecki and a. w asowski evolution of the linux kernel variability model in splc .
s. she r. lotufo t. berger a. wasowski and k. czarnecki the variability model of the linux kernel in vamos .
d. nesic j. kr ger s. stanciulescu and t. berger principles of feature modeling in esec fse .
t. berger s. she r. lotufo a. wasowski and k. czarnecki a study of variability models and languages in the systems software domain tse vol.
no.
.
j. liebig s. apel c. lengauer c. k stner and m. schulze an analysis of the variability in forty preprocessor based software product lines in icse .
d. v .
aken a. pavlo g. j. gordon and b. zhang automatic database management system tuning through large scale machine learning in sigmod .
s. wang c. li h. hoffmann s. lu w. sentosa and a. i. kistijantoro understanding and auto adjusting performance sensitive configurations in asplos .
w. zheng r. bianchini and t. d. nguyen automatic configuration of internet services in eurosys .
z. yu z. bei and x. qian datasize aware high dimensional configurations auto tuning of in memory cluster computing in asplos .
v .
nair t. menzies n. siegmund and s. apel using bad learners to find good configurations in fse .
n. siegmund a. grebhahn s. apel and c. k stner performanceinfluence models for highly configurable systems in fse .
v .
nair z. yu t. menzies n. siegmund and s. apel finding faster configurations using flash tse vol.
no.
.
c. j. hsu v .
nair t. menzies and v .
w. freeh scout an experienced guide to find the best cloud configuration arxiv .
.
s. duan v .
thummala and s. babu tuning database configuration parameters with ituned in vldb .
y .
zhu j. liu m. guo y .
bao k. song and z. liu bestconfig tapping the performance potential of systems via configuration adjustment in socc .
p. jamshidi n. siegmund m. velez c. k stner a. patel and y .
agarwal transfer learning for performance modeling of configurable systems an exploratory analysis in ase .
p. jamshidi m. velez c. k stner and n. siegmund learning to sample exploiting similarities across environments to learn performance models for configurable systems in fse .
b. xi z. liu m. raghavachari c. h. xia and l. zhang a smart hillclimbing algorithm for application server configuration in www .
t. ye and s. kalyanaraman a recursive random search algorithm for large scale network parameter configuration in sigmetrics .
h. herodotou f. dong and s. babu no one cluster size fits all automatic cluster sizing for data intensive analytics in socc .
t. osogami and t. itoko finding probably better system configurations quickly in sigmetrics .
r. krishna v .
nair p. jamshidi and t. menzies whence to learn?
transferring knowledge in configurable systems using beetle arxiv .
.
h. hoffmann s. sidiroglou m. carbin s. misailovic a. agarwal and m. rinard dynamic knobs for responsive power aware computing inasplos .
h. herodotou h. lim g. luo n. borisov l. dong f. b. cetin and s. babu towards automatic optimization of mapreduce programs incidr .
t. berger s. she r. lotufo a. wasowski and k. czarnecki variability modeling in the real a perspective from the operating systems domain in ase .
r. barrett e. kandogan p. p. maglio e. haber l. a. takayama and m. prabaker field studies of computer system administrators analysis of system management tools and practices in cscw .
l. takayama and e. kandogan trust as an underlying factor of system administrator interface choice in chi .
e. m. haber and j. bailey design guidelines for system administration tools developed through ethnographic field study in chi .
d. jin m. b. cohen x. qu and b. robinson preffinder getting the right preference in configurable software systems in ase .
d. yuan y .
luo x. zhuang g. rodrigues x. zhao y .
zhang p. jain and m. stumm simple testing can prevent most critical failures an analysis of production failures in distributed data intensive systems in osdi .
q. chen t. wang o. legunsen s. li and t. xu understanding and discovering software configuration dependencies in cloud and datacenter systems in fse .
c. xiang h. huang a. yoo y .
zhou and s. pasupathy pracextractor extracting configuration good practices from manuals to detect server misconfigurations in usenix atc .
c. li s. wang h. hoffmann and s. lu statically inferring performance properties of software configurations in eurosys .
s. nadi t. berger c. k stner and k. czarnecki where do configuration constraints stem from?
an extraction approach and an empirical study tse vol.
.
s. nadi t. berger c. k stner and k. czarnecki mining configuration constraints static analyses and empirical results in icse .
k. c. kang s. g. cohen j. a. hess w. e. novak and a. s. peterson feature oriented domain analysis foda feasibility study tech.
rep. cmu sei tr sei cmu .
s. she r. lotufo t. berger a. w asowski and k. czarnecki reverse engineering feature models in icse .
y .
xiong a. hubaux s. she and k. czarnecki generating range fixes for software configuration in icse .
y .
xiong h. zhang a. hubaux s. she j. wang and k. czarnecki range fixes interactive error resolution for software configuration tse vol.
no.
.
d. yuan s. park p. huang y .
liu m. m. lee x. tang y .
zhou and s. savage be conservative enhancing failure diagnosis with proactive logging in osdi .
d. yuan s. park and y .
zhou characterising logging practices in open source software in icse .
d. yuan j. zheng s. park y .
zhou and s. savage improving software diagnosability via log enhancement in asplos .
d. yuan h. mai w. xiong l. tan y .
zhou and s. pasupathy sherlog error diagnosis by connecting clues from run time logs in asplos .
r. ding h. zhou j. g. lou h. zhang q. lin q. fu d. zhang and t. xie log2 a cost aware logging mechanism for performance diagnosis in usenix atc .
q. fu j. zhu w. hu j. g. lou r. ding q. lin d. zhang and t. xie where do developers log?
an empirical study on logging practices in industry in icse .
t. barik j. witschey b. johnson and e. r. murphy hill compiler error notifications revisited an interaction first approach for helping developers more effectively comprehend and resolve error notifications in icse .
b. johnson y .
song e. murphy hill and r. bowdidge why don t software developers use static analysis tools to find bugs?
in icse .
c. sun v .
le and z. su finding and analyzing compiler warning defects in icse .
d. engler d. y .
chen s. hallem a. chou and b. chelf bugs as deviant behavior a general approach to inferring errors in systems code in sosp .
l. tan x. zhang x. ma w. xiong and y .
zhou autoises automatically inferring security specifications and detecting violations in usenix security .
l. tan d. yuan g. krishna and y .
zhou icomment bugs or bad comments?
in sosp .
s. h. tan d. marinov l. tan and g. leavens tcomment testing javadoc comments to detect comment code inconsistencies in icst .
y .
zhou c. wang x. yan t. chen s. panichella and h. gall automatic detection and repair recommendation of directive defects in java api documentation tse .
h. zhong and z. su detecting api documentation errors in oopsla .
e. wong j. yang and l. tan autocomment mining question and answer sites for automatic comment generation in ase .
j. zhai x. xu y .
shi g. tao m. pan s. ma l. xu w. zhang l. tan and x. zhang cpc automatically classifying and propagating natural language comments via program analysis in icse .
g. sridhara e. hill d. muppaneni l. pollock and k. vijay shanker towards automatically generating summary comments for java methods in ase .
s. zhang and m. d. ernst proactive detection of inadequate diagnostic messages for software configuration errors in issta .
n. meng s. nagy d. d. yao w. zhuang and g. a. argoty secure coding practices in java challenges and vulnerabilities in icse .
c. xiang y .
wu b. shen m. shen h. huang t. xu y .
zhou c. moore x. jin and t. sheng towards continuous access control validation and forensics in ccs .
t. xu and d. marinov mining container image repositories for software configurations and beyond in icse nier .
m. sayagh z. dong a. andrzejak and b. adams does the choice of configuration framework matter for developers?
empirical study on java configuration frameworks in scam .
m. raab and g. barany challenges in validating floss configuration in oss .
e. horton and c. parnin v2 fast detection of configuration drift in python in ase .
c. wen y .
zhang x. he and n. meng inferring and applying def use like configuration couplings in deployment descriptors in ase .
s. mehta r. bhagwan r. kumar b. ashok c. bansal c. maddila c. bird s. asthana and a. kumar rex preventing bugs and misconfiguration in large services using correlated change analysis in nsdi .
l. passos r. queiroz m. mukelabai t. berger s. apel k. czarnecki and j. padilla a study of feature scattering in the linux kernel tse .
c. yilmaz m. b. cohen and a. a. porter covering arrays for efficient fault characterization in complex configuration spaces ieee transactions on software engineering tse vol.
no.
.
d. jin x. qu m. b. cohen and b. robinson configurations everywhere implications for testing and debugging in practice in icse .
s. m. fouch m. b. cohen and a. porter incremental covering array failure characterization in large configuration spaces in issta .
x. qu m. b. cohen and g. rothermel configuration aware regression testing an empirical study of sampling and prioritization in issta .
e. reisner c. song k. k. ma j. s. foster and a. porter using symbolic evaluation to understand behavior in configurable software systems in icse .
c. song a. porter and j. s. foster itree efficiently discovering highcoverage configurations using interaction trees in icse .