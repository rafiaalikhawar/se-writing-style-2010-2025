automatically testing string solvers alexandra bugariu department of computer science eth zurich zurich switzerland alexandra.bugariu inf.ethz.chpeter m ller department of computer science eth zurich zurich switzerland peter.mueller inf.ethz.ch abstract smt solvers are at the basis of many applications such as program verification program synthesis and test case generation.
for all these applications to provide reliable results smt solvers must answer queries correctly.
however since they are complex highlyoptimized software systems ensuring their correctness is challenging.
in particular state of the art testing techniques do not reliably detect when an smt solver is unsound.
in this paper we present an automatic approach for generating test cases that reveal soundness errors in the implementations of string solvers as well as potential completeness and performance issues.
we synthesize input formulas that are satisfiable or unsatisfiable by construction and use this ground truth as test oracle.
we automatically apply satisfiability preserving transformations to generate increasingly complex formulas which allows us to detect many errors with simple inputs and thus facilitates debugging.
the experimental evaluation shows that our technique effectively reveals bugs in the implementation of widely used smt solvers and applies also to other types of solvers such as automatabased solvers.
we focus on strings here but our approach carries over to other theories and their combinations.
ccs concepts software and its engineering software testing and debugging.
keywords automatic testing soundness testing string solvers smt solvers acm reference format alexandra bugariu and peter m ller.
.
automatically testing string solvers.
in 42nd international conference on software engineering icse may seoul south korea.
acm new york ny usa pages.
introduction smt solvers have a large variety of applications from program verification and synthesis to symbolic execution and concolic testing.
for all these tools to be reliable and usable in practice the smt solvers have to provide correct answers.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than the author s must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may seoul republic of korea copyright held by the owner author s .
publication rights licensed to acm.
acm isbn .
.
.
.
a given formula an smt solver returns either sat together with a model that associates a value to each free variable such that the formula evaluates to true or unsat and optionally a set of clauses that lead to a contradiction the unsat core .
a solver isunsound if it yields an incorrect result that is yields sat for an unsatisfiable formula or unsat for a satisfiable one.
it is also unsound if it correctly yields sat or unsat but produces an invalid model or anincorrect unsat core i.e.
a sub formula that is satisfiable.
since smt solvers support undecidable theories they cannot always determine whether a formula is satisfiable and may sometimes return unknown.
however a solver is unnecessarily incomplete if it returns unknown for a formula from a decidable theory such as x y int x y which falls into presburger arithmetic.
it is also undesirable for a solver to timeout i.e.
not to solve a query within a given timespan .
such a result often points to performance issues.
smt solvers combine multiple communicating decision procedures for various theories e.g.
uninterpreted functions linear nonlinear arithmetic bit vectors arrays strings etc.
as a result they are complex software systems and checking that their implementations are sound is therefore challenging.
to illustrate the errors solvers can make consider for example the smt formula from list.
.
it uses two string variables tand u and checks if it is possible to obtain the constant string a by replacing the first occurrence of tbyuin an empty string.
this is the case according to the smt lib standard iftis empty and u is a .
nevertheless z3 seq and z3str3 two widely used smt solvers incorrectly report unsat for this formula.
d e c l a r e fun t s t r i n g d e c l a r e fun u s t r i n g a s s e r t s t r .
r e p l a c e t u a check s a t listing a sat formula that exposes a soundness bug in z3seq and z3str3 written in smt lib syntax with prefix notation for operators .
in the rest of the paper we show examples in mathematical notation to improve readability.
state of the art testing techniques for smt solvers do not reliably detect such errors.
fuzzing generates formulas that may crash the solvers or reveal performance issues but do not reliably detect soundness problems.
approaches based on differential testing compare the results of different solvers.
different results may indicate a soundness problem in one of them.
however determining which solver is at fault requires manual effort.
moreover differential testing requires at least one solver that provides the correct result this might not be the case in situations like the one described above where z3 seq and z3str3 are both incorrect.
in this paper we propose a novel technique for automatically generating test cases that reveal besides others soundness issues in the implementation of smt solvers.
we synthesize input formulas ieee acm 42nd international conference on software engineering icse icse may seoul south korea alexandra bugariu and peter m ller that are sat or unsat by construction and use this ground truth as test oracle.
our technique generates sequences of input formulas of increasing complexity by applying satisfiability preserving transformations.
in this way the bugs are often found with simple inputs which facilitates error localization and debugging.
we automatically construct a model for each satisfiable formula and a minimal unique unsat core for each unsatisfiable one and use them as additional oracles.
for concreteness this paper focuses on string solvers but our technique generalizes to other theories.
contributions.
our contributions are the following we present an automated approach for synthesizing smt formulas for the string theory which are satisfiable or unsatisfiable by construction.
together with the known ground truth these formulas are used to automatically test the implementations of smt solvers.
our technique generates satisfiable formulas together with models and unsatisfiable formulas together with unsat cores as they are incrementally complex these formulas facilitate debugging and faster error localization.
we implemented our technique and evaluated it on three widely used smt solvers z3 seq z3str3 and cvc4 as well as on the automata based solver mtabc .
our experimental results show that our technique effectively detects soundness problems and outperforms state of the art fuzzing techniques in so.
our approach can also reveal other types of errors such as performance completeness or precision issues.
outline .
the rest of this paper is organized as follows in sect.
we give an overview of our solution for constructing sat and unsat formulas the details follow in sect.
.
we discuss our experimental results in sect.
related work in sect.
and conclude in sect.
.
overview our approach automatically generates smt formulas that are satisfiable or unsatisfiable by construction.
these formulas are used as inputs for black box tests while the ground truth is used as test oracle.
our formula construction approach consists of two steps we generate simple formulas with known truth values.
from these formulas we derive more complex equisatisfiable formulas through automatic transformations.
to perform these steps our generator requires a set of operations supported by the theory under test together with their reference semantics.
for concreteness in this paper we use the smt lib standard as the reference semantics because it provides a rigourous description of the theories.
most widely used smt solvers adhere to smt lib to facilitate comparisons e.g.
in smt competitions and to enable the side by side usage of multiple solvers .
our technique tests whether the implementation of an smt solver complies with the provided reference semantics.
for solvers that intentionally deviate from the smt lib standard it is straightforward to parameterize our technique with an alternative reference semantics and use that to test the implementation.
for instance the cvc4 documentation does not define the result of the replace operation when the second argument is the empty string .
one can use our technique with the smt lib semantics to check for suchtable string operations grouped by their return type return a string return an integer return a boolean at s off indexof s t off contains s t concat s t length s equals s t inttostr n strtoint s prefixof s t replace s t u suffixof s t substr s off len returns a char i.e.
a string of length s t u type string n off len type int replace s t u res figure the simple sat formula for replace generated in step .
all the variables have type string.
deviations from the standard and with an alternative reference semantics to check for errors in the implementation.
tab.
gives an overview of the operations supported by the string theory these operations have according to smt lib deterministic semantics .
as some of the operations take or yield integers reasoning about them also involves linear integer arithmetic.
in the following subsections we give an overview of our construction approach for satisfiable and unsatisfiable formulas.
.
generating satisfiable formulas an smt formula is satisfiable sat with respect to some background theory if there exists at least one model i.e.
variable assignment within the theory such that the formula evaluates to true .
for example the formula x x 3is satisfiable in the theory of real numbers as it is possible to find at least one solution to this equation x .
.
nonetheless the formula is unsatisfiable i.e.
does not have a model in the integer arithmetic theory.
in the first step of our technique we construct sat formulas that test each operation in isolation this allows developers to localize and fix bugs faster.
we start with the operations supported by the theory under test and automatically derive a test case for each of them in which the parameters and the result of each operation are unconstrained.
these simple formulas are thus trivially satisfiable.
an example formula that we synthesize during the first step is shown in fig.
.
this formula is satisfiable since for all string arguments s t u there exists a string resthat is equal to the result of the replace operation because all string operations are total functions .
even though they are very simple these formulas can still reveal bugs.
for example z3 seq returns unknown for the smt formula from fig.
which tests the indexof operation.
since this initial test case is minimal and in particular does not involve any other operations it facilitates identifying the source of this incompleteness most likely a bug in handling the indexof operation in the corresponding decision procedure.
to test more complex cases as well as the interaction between different operations step of our approach derives additional test cases by automatically applying a set of transformations on the formulas synthesized before.
these transformations preserve the satisfiability of the initial formulas thus creating equisatisfiable but more complex formulas with more constrained models and more or more complex terms.
we illustrate a very simple transformation here and present more complex ones in sect.
.
.
1460automatically testing string solvers icse may seoul south korea indexof s t off res figure a simple sat formula generated in step that uncovers an incompleteness in z3 seq.
offand reshave type int sandthave type string.
for the simple formulas from fig.
and fig.
the solver can construct arbitrarily many models as all the variables are unconstrained.
we can strengthen the formulas by adding constraints on the values of these variables.
a possible transformation is to replace some of the variables by constants.
to decide what values can be assigned to which variables such that the complex formula is still satisfiable we rely on concrete execution.
that is we implement anexecutable version of the reference semantics for the operations under test and use it to determine valid parameters and results.
this technique can be applied to sat formulas because finding amodel for which the formula holds is enough for proving its satisfiability.
having the executable semantics we can evaluate each operation on concrete arguments.
in this way we obtain formulas in which all the arguments and the results are constants.
the test formulas are then synthesized by fixing some of them to the constants used in the concrete execution and leaving the others unconstrained.
let us consider the replace operation from fig.
.
if we evaluate it on the arguments s t u a the result is according to the smt lib semantics the constant string a .
we can thus transform the formula by replacing the variables sandreswith the constants and a .
this replacement yields the sat formula from list.
which has more constrained models and exposes a soundness bug in two widely used smt solvers.
this and other satisfiabilitypreserving transformations including some that combine multiple operations are described in more detail in sect.
.
.
.
generating unsatisfiable formulas to show that a formula is unsatisfiable unsat a solver has to prove that there does not exist an assignment to the free variables within the background theory that satisfies the formula i.e.
the formula evaluates to false for all possible values assigned to its variables .
since many smt theories include infinite sorts such as integers or strings it is not possible to enumerate and check all possible value assignments and thus we cannot use our executable semantics to determine the ground truth.
to synthesize formulas that are unsat by construction we start from the following observation conjoining a formula and the negation of an equivalent formula always results in an unsatisfiable formula.
that is for equivalent formulas aandb the formula fdefined as a bis unsatisfiable.
we obtain interesting formulas fby leveraging equivalences between different operations of the string theory.
out of the string operations from tab.
only concat length and equals are considered primitive operations.
all the other string operations can be expressed through these primitive operations .
tab.
presents an overview of equivalent formulas for non primitive string operations.
this table is an extended variant of the preprocessing rules from and of the string function definitions from .
in the first step of our input construction technique we automatically generate a test case from each of the equivalences by conjoining the negation of the formula from column in tab.
and the corresponding formula from column .
in this step we replace s t u res i indexof s t i s s1 s2 s3 length s1 i s2 t res s1 u s3 i res s figure an unsat formula generated in step for which cvc4 times out and z3str3 has non deterministic behavior.
ihas type int all the other variables have type string.
omit existential quantifiers in the formulas from column that is the existentially quantified becomes a fresh free variable .
this is possible because all existential quantifiers in the equivalent formulas are in positive positions and q x is un satisfiable if and only if x q x is un satisfiable.
since the resulting formulas do not use any existentially quantified variables we use the terms quantifier andquantified variable in the rest of the paper to refer to universal quantifier anduniversally quantified variable respectively.
for the quantifiers from tab.
we specified patterns also called triggers which are used by the solver to decide how to instantiate the quantifiers and thus affect the search for a model .
our technique can be parameterized with different equivalent formulas.
other equivalences can be obtained for instance by rewriting formulas on the right hand side in tab.
using equalities from the left hand side.
the inputs without quantifiers can be used also for testing smt solvers that do not support quantification yet.
an example test case that we synthesize in step and corresponds to e3 is shown in fig.
.
for this test cvc4 times out and z3str3 non deterministically returns timeout unsat unknown or segmentation fault.
in the second step of our approach we automatically transform the previously generated formulas into equisatisfiable but more complex ones.
these formulas either have larger unsat cores requiring the solver to combine more terms to derive a contradiction or contain additional terms that are not relevant for proving unsat but may complicate the proof search for the solver.
to show for example that the formula x x 0is unsatisfiable for all integers x the solver relies on the fact that no number can be at the same time zero and non zero.
if the conjunct x 0is replaced by x 2x x xthen all three conjuncts contribute to proving unsat.
by removing any of them the formula becomes satisfiable.
thus these three terms represent the minimal unsat core.
the transformations that we designed for the unsat case described in detail in sect.
.
are based on similar rewritings.
this concludes the high level overview of our approach.
given an executable version of the reference semantics and the equivalent formulas test case generation is deterministic and fully automatic.
the ground truth is always known so all the synthesized formulas can be directly used for testing without additional human effort for constructing the test oracles.
our approach produces increasingly complex test cases which often allows developers to detect errors with simple inputs such that errors are easy to reproduce and debug.
the main ingredients of our technique are not specific to the string theory.
one can construct quantifier free sat formulas from any theory that has an executable semantics such as fixed size bit vectors or integers.
moreover unsat formulas can be generated as long as operations or constants from the theory can be expressed in multiple ways.
for instance the fact that xis a positive real can be expressed as x real x 0but also as y real x y y 1461icse may seoul south korea alexandra bugariu and peter m ller table equivalent formulas for non primitive string operations id string operation equivalent formula e1 at s off res res substr s off e2 inttostr n res res ifn res ifn ... res ifn res inttostr n inttostr n ifn e3 replace s t u res i indexof s t s1 s2 s3 s s1 s2 s3 length s1 i s2 t res s1 u s3ifi res sotherwise e4 substr s off len res s1 s2 s3 s s1 s2 s3 length s1 off length s2 len res s2 ifoff off length s len res otherwise e5 indexof s t off res res offift off off length s s1 s2 s4 s s1 s2 t s4 off length s1 i substr t i i i length t contains s2 substr t i t f alse res length s1 s2 ift off off length s res 1otherwise e6 strtoint s res inttostr res sifs j at s j j j length s at s j ... at s j res 1otherwise e7 contains s t true s1 s3 s s1 t s3 e8 contains s t false s1 s2 s3 s1 s2 s3 s s1 s2 s3 s2 t e9 prefixof s t true t2 t s t2 e10 prefixof s t false t1 t2 t1 t2 t t1 t2 t1 s e11 suffixof s t true t1 t t1 s e12 suffixof s t false t1 t2 t1 t2 t t1 t2 t2 s s t u s1 s2 s3 s4 t1 t2 type string n off len i j type int denotes string concatenation.
all formulas are implicitly universally quantified over all the arguments.
patterns for universal quantifiers are shown between .
every positive number has a square root .
the constant can be also defined through operations from the theory of real numbers z z .
from these equalities one can generate the formula x y y unsatisfiable by construction.
similar rewritings and equalities do exist for other theories.
our technique is also not specific to smt solvers.
since it treats the solver under test as a black box it can be also applied to test the soundness and precision of other solvers for instance automatabased solvers like smc abc and mt abc .
these solvers encode the input constraints as finite automata and determine their satisfiability by counting the number of possible models.
satisfiability preserving transformations in this section we describe our technique for constructing complex smt formulas from the string theory through satisfiabilitypreserving transformations.
our transformations for the sat and the unsat case are presented in the following subsections.
.
transformations for satisfiable formulas in the first step of the sat input construction technique described in sect.
.
and presented in pseudo code in fig.
lines we synthesize simple formulas with unconstrained parameters and results which are trivially satisfiable.
the second step lines in fig.
strengthens the initial formulas by adding constraints on the values of the free variables and synthesizes formulas that may contain multiple operations to test their interactions.
our algorithm is deterministic always generates the same tests in the same order.
we present two satisfiability preserving transformations in the following.
constant assignment uses an executable semantics to1 s t e p 2foreach s u p p o r t e d o p e r a t i o n op i n p u t gensimplesatformula op i n p u t has t h e form op a r g s r e s res model i n v o k e s o l v e r i n p u t a s s e r t r e s s a t c o r r e c t m o d e l model i n p u t s t e p foreach formula f s y n t h e s i z e d i n s t e p c o n s t a n t a s s i g n m e n t i n p u t perform c o n s t a n t assignment on f res model i n v o k e s o l v e r i n p u t a s s e r t r e s s a t c o r r e c t m o d e l model i n p u t term s y n t h e s i s i n p u t perform term s y n t h e s i s on f res model i n v o k e s o l v e r i n p u t a s s e r t r e s s a t c o r r e c t m o d e l model i n p u t figure algorithm for synthesizing sat input formulas.
invokesolver yields the solver s result on the input formula i.e.
sat unsat unknown timeout or error a model for sat formulas and an unsat core for unsat formulas if available.
correctmodel uses the reference semantics to check the validity of the model with respect to the input formula.
we do not check partial models generated by some solvers for unknown results as their correctness is not guaranteed.
compute models for simple sat formulas and then transforms these formulas by replacing some of their free variables by values from the model.
term synthesis enumerates terms from the theory under test and evaluates them using an executable semantics.
it then 1462automatically testing string solvers icse may seoul south korea substitutes free variables from the simple input formulas with more complex terms such that the formulas remain satisfiable.
both transformations yield quantifier free sat formulas.
constant assignment transformation.
many software errors are caused by the incorrect handling of corner cases.
for this reason the first transformation is inspired by boundary testing and consists of assigning predefined constants to some of the free variables of the initial formulas.
the set of predefined constants is configurable we used typical boundary values in our experiments.
for example for the variables of type string we considered empty strings strings of length one as well as strings containing quotes escape sequences and non ascii characters in hexadecimal format.
for integers we picked a small set of valid and invalid indices and lengths such as .
the string operations cannot have other types of parameters but some of them have boolean results see column from tab.
for which we considered both true and false.
given the simple input formulas that we generated in step see sect.
.
we use concrete executions to determine their models.
for this purpose we implement an executable semantics for all string operations based on the reference semantics in our case the smtlib specification .
this implementation is straightforward since most programming languages e.g.
java already provide string libraries that offer most of the operations.
therefore the implementation effort mostly consists of ensuring that the semantics of these library operations and the smt lib standard match.
for example the java string.replace method replaces alloccurrences of tin s whereas the smt lib operation replaces just the firstoccurrence.
moreover converting any negative integer to a string in java will yield its textual representation whereas the smt lib result will be the empty string.
to handle these and other similar mismatches we implement a wrapper for the java string operations according to the smt lib semantics which represents our executable semantics.
we then exhaustively evaluate each operation on all possible combinations of constant arguments from the set of predefined values.
as all string operations are total the evaluation always succeeds producing models for the simple formulas from step .
the constant assignment transformation obtains new input formulas by replacing some of the free variables in a simple formula by constants from the computed model.
since this transformation is based on valid models it is guaranteed to produce satisfiable formulas.
consider for example the replace operation for which we already generated a simple test case during the first step see fig.
.
if the set of predefined constants includes the string a and the empty string then one of the concrete evaluations is replace a a .
we can use this computed model to derive several new inputs.
for instance we can replace the free variables sandresfrom the simple formula by the corresponding constants from the model here an empty string and a respectively to obtain a new sat formula replace t u a .
this formula presented in smt lib notation in list.
revealed soundness bugs in z3 seq and z3str3.
as shown in fig.
lines we run the solver on the transformed formula and report an error if the result is different from sat lines .
otherwise we check if the solver produces a correct model using our executable semantics line we evaluate the string operation on the parameters from the model generated by the solver and compare the result of the evaluation to the result fromat at tmp str tmp int indexof tmp str tmp str tmp int tmp str tmp str figure a sat formula generated in step through term synthesis which exposes a soundness bug in z3str3.
tmp int 1has type int tmp str 0and tmp str 2have type string.
the generated model.
if they are unequal the solver is unsound we found such cases in our evaluation see sect.
.
.
term synthesis transformation.
to test interactions between different operations we transform the simple formulas from step by replacing some free variables with more complex terms.
we use terms from the string theory which are sufficient to supply string integer and boolean parameters or results for the string operations.
starting from a set of constants we synthesize all type correct applications of string operations up to a predefined bound and evaluate them using our executable semantics this produces a pool of terms.
we transform a simple formula from step in four steps we replace the arguments of the operation under test with terms from the pool.
we evaluate the resulting term in the executable semantics.
we replace the result variable in the simple formula by another term from the pool with the same result which ensures that the equality holds.
the complex formula used to test the solvers is then obtained by replacing the constants in the resulting equality by free variables which yields a sat formula.
it is important to represent multiple occurrences of the same constant by the same free variable to connect the operations more tightly and to further constrain the set of possible models.
the transformation is applied exhaustively for all terms from the pool.
to illustrate our technique let us assume that the initial set of strings includes the constants a and and the initial set of ints contains the value .
the pool will then contain among others the terms at a with concrete value indexof a a with concrete value and concat with value .
starting from the simple formula for the atoperation the transformation proceeds as follows we substitute the arguments of atto obtain for instance at at a indexof a a .
evaluating this term yields .
we equate the term with another term with the same result and obtain for example at at a indexof a a concat .
we replace the constants a and 1with three fresh variables tmp str0 tmp str2 andtmp int1 which yields the input formula from fig.
.
this formula exposes a soundness bug in z3str3 which incorrectly returns unsat.
note that when the operations at indexof and concat were tested separately the solver returned the expected results.
it is their combination that exhibits the error.
the formula from fig.
was obtained with bound for the term pool that is the arguments and result are all single applications of an operation on constants larger bounds lead to more complex formulas.
once we have synthesized the new input executing the test and checking if the solver returned a correct model is analogous to the constant assignment transformation see lines from fig.
.
note that one can easily combine the two transformations we proposed by replacing only some of the constant occurrences in the last step of the term synthesis transformation with free variables.
1463icse may seoul south korea alexandra bugariu and peter m ller s t e p 2foreach s u p p o r t e d o p e r a t i o n op input e x p ec te dc o re gensimpleunsatformula op i n p u t has t h e form !
a x b x y where a i s t h e f o r m u l a from column i n t a b l e and b i s t h e c o r r e s p o n d i n g f o r m u l a from column res c o r e i n v o k e s o l v e r i n p u t a s s e r t r e s u n s a t c o r e e x pe ct e d co re s t e p foreach formula f s y n t h e s i z e d i n s t e p v a r i a b l e r e p l a c e m e n t foreach v a r i a b l e x t h a t i s f r e e both i n a and b foreach a p p l i c a b l e e q u a l i t y eq i n nc1 nc8 input e x p ec te dc o re r e p l a c e a l l x i n f u s i n g eq res c o r e i n v o k e s o l v e r i n p u t a s s e r t r e s u n s a t c o r e e x pe ct e d co re c o n s t a n t r e p l a c e m e n t foreach c o n s t a n t c i n b foreach a p p l i c a b l e e q u a l i t y eq i n c1 c40 input e x p ec te dc o re r e p l a c e a l l c i n f u s i n g eq res c o r e i n v o k e s o l v e r i n p u t a s s e r t r e s u n s a t c o r e e x pe ct e d co re r e du n d a nc y i n t r o d u c t i o n foreach v a r i a b l e y t h a t i s f r e e only i n b foreach a p p l i c a b l e e q u a l i t y eq i n nc1 nc8 input e x p ec te dc o re r e p l a c e a l l y i n f u s i n g eq res c o r e i n v o k e s o l v e r i n p u t a s s e r t r e s u n s a t c o r e ex p e c t ed co r e figure algorithm for synthesizing unsat input formulas.
invokesolver yields the solver s result on the input formula i.e.
sat unsat unknown timeout or error a model for sat formulas and an unsat core for unsat formulas if available.
.
transformations for unsatisfiable formulas in the first step of the unsat input construction technique described in sect.
.
and presented in pseudo code in fig.
lines we test each non primitive string operation together with its equivalent formula.
recall that if two formulas aandbare equivalent then the formula f a bis by construction unsatisfiable.
to obtain more complex unsat formulas we transform the simple ones into formulas with larger unsat cores.
therefore the solver needs to reason about more properties to prove unsatisfiability.
consider a simple input formula fthat contains one variable x that occurs in both aandb and one variable ythat is existentially bound in band thus becomes a free variable after the existential quantifier is removed see sect.
.
.
this formula can be written as f x y a x b x y to obtain an unsat formula with larger unsat core we replace all the occurrences of xinbby a fresh variable xfresh and conjointable equalities between the string operations and nonconstant and constant strings nc1 nc7 and c1 c15 integers nc8 and c16 c31 and booleans c32 c40 id equality nc1 at s siflength s nc2 concat s s nc3 concat s s nc4 replace s s s s nc5 replace s t u sifcontains s t false nc6 replace s t u sifindexof s t nc7 substr s length s s nc8 indexof s off offifoff off length s c1 at s off ifoff off length s c2 concat c3 inttostr n ifn c4 replace c5 substr s off len ifoff off length s len c6 inttostr n ifn ... ... c15 inttostr n ifn c16 indexof s t off 1ifoff off length s c17 indexof s t off 1ifcontains s t false c18 strtoint s 1ifs c19 strtoint s 1if i i i length s at s i ... at s i c20 length s 0ifs c21 strtoint s 0ifs c22 strtoint s 1ifs ... ... c31 strtoint s 9ifs c32 contains s s true c33 equals s s true c34 prefixof s true c35 prefixof s s true c36 suffixof s s true c37 contains s t false ifindexof s t c38 equals s t false iflength s length t c39 prefixof s t false ifcontains t s false c40 suffixof s t false ifcontains t s false a clause c x xfresh from the string theory that implies x xfresh.
the resulting formula is still unsat but the unsat core now also includes c x xfresh f x xfresh y a x b xfresh y c x xfresh based on this general idea we perform three transformations on the simple input formulas which are described next and implemented in lines of fig.
.
with all three transformations the unsat core of the resulting formula is unique and known by construction and thus can be used to check the correctness and minimality of the unsat core returned by the solver.
variable replacement transformation.
our first transformation chooses a variable xthat occurs freely in aandband constructs a more complex formula as described above.
the clause c x xfresh is obtained from a set of equalities that we derived from the string theory.
they are summarized in tab.
we focus on the equalities nc1 nc8 here and will discuss the others later.
for example the equality nc1 expresses that the first character of a string is equal to the string itself for any string of length .
this additional constraint about the length of the string represents a side condition under which the equality holds.
note that nc1 nc7 are equalities on strings whereas nc8 is for integers.
depending on the type of the chosen variable x we select an appropriate equality and obtain c x xfresh by substituting 1464automatically testing string solvers icse may seoul south korea replace s t u res i indexof s t i s s1 s2 s3 length s1 i s2 t res fresh s1 u s3 i res fresh s at res res fresh length res figure an unsat formula generated in step by increasing the unsat core which exposes an unsoundness in z3str3.
ihas type int all the other variables have type string.
the right hand side variable by xfresh all occurrences of the same variable on the left hand side of the equality by x and all other variables by fresh variables.
for example replacing the variable resin the formula from fig.
using nc1 yields c res res fresh at res res fresh.
with this additional clause we construct the unsat formula from fig.
.
note that the side condition length res 1of nc1 is conjoined to the formula making it stronger and preserving unsatisfiability.
to prove that this formula is unsat an smt solver can use nc1 with resfors and the last two conjuncts from fig.
to derive res res fresh which reduces the formula to the one we started from.
this shows that the prover needs to perform additional reasoning steps as the unsat core is extended by the additional conjuncts.
for the formula from fig.
z3str3 unsoundly returns sat.
the same transformation can also be applied to the other free variables s t and u. it is also possible to replace multiple variables simultaneously but we omitted such transformations in our experiments.
there we explore each combination of one variable and a corresponding equality as summarized in fig.
lines .
constant replacement transformation.
analogously to the previous transformation we can replace a constant cby a term that evaluates to c. starting from a simple formula f x y a x b c y we construct the following formula for some constant c f x zfresh y a x b c c zfresh to obtain the additional clause c c zfresh we use known equalities from the string theory.
the equalities c1 c40 from tab.
all equate a string term to a constant.
for a chosen constant c we select one of the equalities of the form t cand define c c zfresh zfresh t as shown in pseudo code in fig.
lines .
as in the previous transformation this step preserves unsatisfiability and enlarges the unsat core by the additional equality.
this information known by construction is used as the test oracle lines .
if instead of rewriting res in fig.
we replace the constant by c20 then we obtain an unsat formula that exposes a soundness bug in z3 seq.
redundancy introduction transformation.
we also experimented with a variation of the variable replacement transformation where we apply the same transformation to a variable ythat occurs freely in b but not in a see fig.
lines .
these variables were initially introduced by existential quantifiers in the equivalent formulas from tab.
.
consequently renaming them to yfreshand conjoining c y yfresh to the formula does not extend the unsat core.
nonetheless it introduces redundancy that is additional variables and terms that may obfuscate the proof of unsatisfiability.
it is also possible to apply this transformation to universallybound variables in b. in this case the additional clause from tab.
is added under the quantifier such that it implies the quantifier s body prefixof s t false t1 t2 t2 fresh t1 t2 fresh substr t2 length t2 substr t2 length t2 t2 fresh t t1 t2 fresh t1 s figure an unsat formula generated in step by introducing redundancy for universally bound variables which exposes a soundness bug and non deterministic behavior for z3str3.
all the variables have type string.
the new variables that occur in the clause are added as universallybound variables and the pattern of the quantifier is extended to mention all the quantified variables.
the new triggering terms are directly derived from the additional equality and the side condition is added as an implication.
in our experiments redundancy introduction produced test cases that did reveal errors.
fig.
shows an example where the quantified variable t2from e10 was rewritten using nc7.
this formula exposes a soundness issue and non deterministic behavior for z3str3 which returns sat or segmentation fault.
note that the three transformations can be combined and all of them can be applied multiple times to increase the complexity of the previously synthesized formulas.
in our experiments each transformation was applied independently and the second synthesis step was performed only once to facilitate error localization and to avoid generating redundant tests that fail due to the same bug.
as our algorithm is deterministic it always produces the same tests.
experimental evaluation in this section we present the results obtained by applying our test case generation technique on three widely used smt solvers z3 seq version .
.
z3str3 version .
.
and cvc4 version .
.
the two z3 string solvers use different approaches z3 seq the default string solver from z3 encodes string operations into operations over sequences while z3str3 supports strings as built in types.
our experiments show that our technique is able to synthesize formulas that reveal soundness bugs in two of the three tested solvers.
they also uncover completeness and performance issues.
the experimental results show that our approach outperforms fuzzing and is also effective in finding bugs in other types of solvers as we demonstrate on the automata based solver mt abc .
.
testing smt solvers in the first experiment we tested the compliance of z3 seq z3str3 and cvc4 string operations with the semantics defined in the smtlib standard.
in the following we also discuss the impact of each component of our formula synthesis technique in finding the bugs.
experimental setup .
all the formulas that we synthesized are encoded into smt lib .
format patterns are part of this standard.
we used the smt lib unicode strings theory as the reference semantics and our wrapper of the java string operations for the executable semantics.
we set a timeout of seconds for each test and we fixed the seed for the solvers random number generator the sat.random seed for all three solvers and the smt.random seed only for z3 seq and z3str3 to reduce non determinism.
we used the options produce models andproduce unsat cores to enable the generation of the models and of the unsat cores respectively.
1465icse may seoul south korea alexandra bugariu and peter m ller table overview of our results for z3 seq z3str3 and cvc4 of tests with actual result all random seeds expected category of tests z3 seq z3str3 cvc4 result transformation generated im ic s u k t e im ic s u k t e im ic s u k t e sat operation sat constant assignment sat term synthesis unsat equivalent formula unsat equivalent formula unsat larger unsat core unsat larger unsat core unsat redundancy introduction unsat redundancy introduction total of sat failed tests out of total of unsat failed tests out of total of unsat failed tests out of im incorrect model ic incorrect unsat core s sat u unsat k unknown t timeout e error with patterns for quantifiers n of tests that failed due to soundness issues we also used the option strings exp for cvc4 to enable nonprimitive string operations and the option full saturate quant to enable enumerative instantiation .
for the z3 based solvers we set the option smt.core.minimize to true to obtain the minimal unsat core this option was not supported by cvc4 at the time of writing.
for all other options we used the default values in particular we did not use the solvers own ability to check the validity of the generated models.
the experiments were conducted on a .
ghz intel core i7 cpu with gb memory.
results .
the results obtained for the three solvers are summarized in tab.
.
in this table we report the expected result column the test category transformation as described in sect.
and sect.
column the total number of tests generated for each of these categories column and the actual result returned by each solver in the remaining columns .
this result can be incorrect model when the solver correctly returned sat but the produced model is not valid i.e.
evaluating the original formula on the model using our executable semantics yields false incorrect unsat core when the solver returned unsat but the generated unsat core is not the minimal expected one sat unsat unknown timeout or error when the solver crashed or returned an error message .
for the unsat formulas we report the results for each category without using patterns for quantifiers and with the patterns specified in tab.
for the formulas that are quantified unsat in tab.
.
all our sat formulas are quantifier free.
note that when the patterns are not provided the solvers will try to infer them automatically.
the categories operation and equivalent formula refer to simple formulas synthesized in step for testing each operation in isolation or together with its equivalent formula from tab.
respectively.
the category larger unsat core includes the test cases obtained by applying the variable and constant replacement transformations from sect.
.
.
for term synthesis each variable was obtained by exactly one operation.
for the larger unsat core and redundancy introduction transformations each variable and constant was rewritten in one step by independently applying all the corresponding equalities from tab.
.
in each test case only one of them was rewritten with all its occurrences as shown in fig.
.
soundness issues.
the number of tests that failed due to soundness issues for each category is showed with gray background.indexof tmp str tmp str tmp int figure a sat formula generated in step through constant assignment for which z3str3 produces an incorrect model.
tmp int 2has type int tmp str 0and tmp str 1have type string.
we classify an answer as being unsound if the solver returned sat instead of unsat or vice versa or if it generated an invalid model.
an incorrect unsat core represents a soundness problem if the generated unsat core is notunsatisfiable.
we observed this kind of error only for z3str3 for the larger unsat core transformation and for the equivalent formula category.
for redundancy introduction the cores generated by all the solvers were always valid but not necessary minimal we consider that an imprecision not a soundness issue.
for cvc4 none of the test cases revealed soundness issues.
by contrast z3str3 has the highest number of tests that fail due to soundness bugs for both sat and unsat formulas.
some example inputs for which z3str3 returned an incorrect result have already been presented in the previous sections.
fig.
shows another type of unsoundness i.e.
a sat formula obtained through the constant assignment transformation for which the solver correctly answered sat but generated an invalid model tmp str 3maymaymaz tmp str maym tmp int with these inputs the result ofindexof is1 not as prescribed by the input formula in fig.
.
note that z3str3 does not support non ascii strings yet.
out of the sat formulas unsoundly solved by z3str3 contain such strings.
for a fair evaluation we replaced them with ascii strings and repeated the experiments.
the results were the same.
moreover the solvers use mathematical integers while our executable semantics uses bounded integers.
we manually inspected the few models rejected by our executable semantics that contained large numbers.
all of them were valid and are thus notreported as errors in tab.
.
other issues.
besides soundness problems our tests revealed various completeness performance and implementation errors.
for instance the unknown result points to a completeness issue.
z3 seq returned unknown for approx.
of our sat formulas blaming incompleteness in the sequence theory in all cases.
we reported several failing tests and some of them have already been fixed.
the timeout result suggests a performance problem frequently observed for unsat formulas with all three solvers.
several tests 1466automatically testing string solvers icse may seoul south korea contains inttostr tmp int at tmp str tmp int contains tmp str tmp str figure a sat formula generated in step through term synthesis for which the result of z3 seq depends on the random seeds.
tmp int 0has type int tmp str 2has type string.
table known bugs for z3 seq z3str3 and cvc4 z3 seq z3str3 cvc4 issues t ws f t ws f t ws f closed open t total number of issues ws within the scope of this paper issues caused by regular expressions user defined functions bit vectors or different configurations were excluded f issues we could find by manually inspecting the failing tests.
also failed for z3str3 and cvc4 due to implementation errors.
for cvc4 many tests hint at completeness or performance problems for unsat formulas both with and without patterns for quantifiers.
the reason confirmed by the developers is that with the given patterns many of the quantifiers are not instantiated by default through e matching .
moreover the enumerative instantiation which is used by cvc4 when e matching saturates does not work optimally for non primitive string operations.
we reported the problem and for some of our test cases it has been already fixed.
adding patterns for quantifiers did not improve the results for z3seq and z3str3.
this experimental result suggests that the patterns we specified are similar to the ones automatically inferred by the two z3 based solvers which use the same engine for instantiating quantifiers.
other reason for the unknown result is incompleteness in the sequence theory reported by z3 seq for of the failed tests.
z3str3 does not provide details on the reason of the incompleteness.
our approach can be also used for discriminating between various configurations.
for example to test the solvers robustness we set the random seeds to a value chosen arbitrarily and we repeated the experiments.
for cvc4 the results were the same.
z3seq and z3str3 were less robust.
fig.
shows a test case for which z3 seq correctly returned sat when the seeds were but answered unknown for the seeds .
note that all the other examples from this paper were obtained with the random seeds set to .
the test cases that failed in our experiments do not necessarily refer to unique bugs.
this is a general problem of any testing tool and is orthogonal to our formulas synthesis technique.
several approaches have been proposed in the literature for clustering static analysis alarms we could apply these ideas to our work to automatically group the failing tests into similarity based clusters.
note that our synthesis algorithm reduces by construction the number of redundant test cases step applies individual transformations to the simple formulas generated in step see fig.
and fig.
that is it does not chain together transformations.
however we do apply step even to those formulas that already lead to a failing test in step which may uncover additional bugs.
for example z3str3 timed out during step for the formulas based on e3 and e5 but was unsound for tests derived in step from these inputs.
known bugs.
due to the large number of failed tests and the complexity of the implementation of the smt solvers it is not feasible to manually determine how many distinct bugs we uncovered.table failed tests on the latest versions of the smt solvers total of still z3 seq z3str3 cvc4 failing tests .
.
.
.
.
sat unsat unsat with patterns for quantifiers given in tab.
to evaluate how effective our technique is in detecting distinct bugs we assessed how many of a set of known bugs are found by our test cases.
for z3 seq and z3str3 we considered the closed issues reported by the users from 23rdmay until 26thjanuary as well as all the currently open issues with the labels string or z3str3 that were confirmed by the developers and do not explicitly refer to other versions than .
.
.
similarly for cvc4 we considered the issues reported from 25thjune until 17thapril both closed and still open related to the string theory.
the known bugs are summarized in tab.
.
from the total number of issues column for each solver we removed the ones that are not in the scope of this paper that is contain regular expressions user defined functions based on string operations or formulas combining string operations with bit vectors which we do not support.
we also excluded the issues explicitly caused by additional configuration options that we do not use.
we report as found column only those bugs for which we could manually find a failing test case that exhibits it based on the description from the comments or inferred from the fix.
known bugs notreported as found might still be detected by our test suite but we were not able to clearly identify an appropriate test case.
that is the reported number of found bugs is a lower bound on the actual number.
this experiment shows that our technique effectively detects bugs that occurred in actual applications of the tested smt solvers and were reported and confirmed.
in total we found of the bugs .
sensitivity analysis.
the effectiveness of our technique depends on three ingredients the set of predefined constants the combinations of operations used in a formula needed to test their interactions and the usage of different random seeds.
the manual inspection of the tests that detected the known bugs from tab.
shows that all three ingredients are necessary.
finding some of the bugs required specific ways of constructing the inputs e.g.
the implementation errors from cvc4 are revealed only by the tests that use the equalities nc1 and nc5 from tab.
to rewrite variables from e10 and e12.
similarly a soundness bug in z3str3 is detected only by the test that replaces the result variable from e3 using the equality nc1.
other bugs are revealed by several inputs that follow a common pattern such as formulas obtained through constant assignment that test the indexof operation with negative or out of bounds offset or formulas generated through term synthesis that include inttostr orstrtoint as arguments for other operations.
the bug from fig.
can be observed only when testing thecontains operation twice with different random seeds.
our experiments do not suggest that certain equivalences from tab.
or transformations are substantially more useful than others.
recent improvements.
as we mentioned above we reported several bugs for the three solvers many of which were confirmed or fixed.
to assess the recent improvements we re ran the failed 1467icse may seoul south korea alexandra bugariu and peter m ller tests on the latest versions of the solvers at the time of writing i.e.
.
.
for z3 seq and z3str3 and .
for cvc4.
the cumulative results for all types of errors are presented in tab.
.
in the following we discuss our main observations focusing on the soundness bugs.
compared to the results from tab.
summarized between square brackets the number of failing tests decreased substantially for the z3 based solvers at least in part due to our bug reports.
for z3 seq no sat test still failed due to soundness bugs.
for unsat formulas based on inttostring z3 seq returned sat we reported new soundness bug and it was confirmed.
for z3str3 sat and unsat tests failed due to soundness problems.
some of them correspond to open bugs and we reported additional soundness errors.
for cvc4 we did not find soundness bugs the tests failed due to performance issues and because the minimization of the unsat cores was not yet supported.
this feature was added in the meantime and the developers further improved the performance in response to our bug reports but these changes are not yet part of the main branch.
all these results were obtained with respect to the smt lib semantics.
even though for some operations the semantics described in the documentation of a particular solver may be slightly different none of the bugs we reported were considered false positives by the developers.
all three solvers intend to comply to the standard.
our experiments show that soundness and completeness bugs in decision procedures are not uncommon.
they are due to various issues including mis interpretations of the expected semantics flaws in the used algorithms and coding errors.
these findings have implications for solver developers who need to systematically test for such bugs.
our work offers a technique to accomplish that.
.
comparison with fuzzing in this subsection we compare our technique with stringfuzz a state of the art test case generator for string formulas.
for this experiment we ran parts of a test suite generated by stringfuzz from the folder generated.zip on the three smt solvers using the same versions as for our main experiments i.e.
.
.
for z3 seq and z3str3 and .
for cvc4.
we discarded the tests for which the expected result was not specified as for them we could not automatically classify the actual result as correct or not.
in total we included tests in smt lib .
format from nine different categories lengths short lengths long lengths concats concats small concats big concats balanced regex small regex big and different prefix .
all of them are quantifier free and tests include regular expressions.
we used the same experimental setup as for our tool with the random seeds set to and we set the lang option to smt2 for cvc4 to avoid parsing errors.
as stringfuzz cannot check if the generated models and unsat cores are correct we considered that a test passed when the solver answered sat or unsat as expected.
z3 seq and z3str3 timed out for tests and returned correct results for all the others.
similarly tests failed for cvc4 due to timeout while all the others passed.
the experiment shows that stringfuzz could detect performance problems but no soundness or completeness bugs.
a reason may be that besides regex stringfuzz can generate only formulas with primitive string operations which are not enough for revealing these classes of errors.
in contrast our technique also uncoveredtable overview of our results for mt abc expected category of tests of tests with actual result result transformation generated s u e sat operation sat constant assignment sat term synthesis unsat equivalent formula unsat larger unsat core unsat redundancy introduction total of sat failed tests out of total of unsat failed tests out of s sat u unsat e error imprecision due to over approximation n of tests that failed due to soundness issues several soundness and completeness errors in the same versions of the smt solvers including confirmed bugs.
.
testing automata based solvers our technique is not limited to smt solvers it can also be applied for testing other types of solvers such as automata based solvers.
in this subsection we present the results for mt abc an automata based solver that performs model counting.
it supports both string and numerical constraints and classifies an input formula as satisfiable if the counted number of models is greater than .
for some constraints it may over approximate the set of solutions thus imprecisely answering sat for an unsat formula.
nonetheless asound implementation should not classify a sat formula as unsat.
as mt abc accepts as input a subset of the smt lib format we used a modified version of our tests that contains only supported features.
we also replaced the escape sequence for double quotes within a string literal with the corresponding one in mt abc.
as non ascii strings are not yet supported we discarded the sat tests that included these constants in the formulas or in the possible model.
the unsat tests based on e2 e5 e6 e8 e10 e12 from tab.
could not be handled by mt abc because it does not support quantifiers and the mod operator so we removed them as well.
we tested the code version using default options.
this commit includes a fix for e7 e9 and e11 based on a crash that we found and reported.
we used the smt lib unicode strings theory as the reference semantics because mt abc recently updated the implementation of the string operations to match this standard.
the results are summarized in tab.
.
the soundness problems are showed with gray background while the imprecise answers are marked with .
as it can be observed our technique effectively synthesized formulas that exposed various soundness and precision issues as well as implementation failures for different string operations.
for example mt abc unsoundly returned unsat for the formulas from fig.
and fig.
.
we already reported distinct soundness bugs and crashes for constant assignment and for the operation category because they are easier to debug.
the developers confirmed them and appreciated that we sent simple formulas that expose the bugs.
as a result some of them were fixed within a day.
.
threats to validity we identified four threats to the validity of our experiments 1468automatically testing string solvers icse may seoul south korea ground truth .
our technique relies on an executable semantics for the string operations on the equivalent formulas from tab.
and on the equalities from tab.
.
errors in these components could lead to incorrect tests.
to mitigate this threat we carefully reviewed all the components of our approach.
since they are simple variations of the smt lib semantics we are confident that they are correct.
non deterministic behavior .
the solvers use randomized algorithms which can lead to non deterministic behavior see sect.
.
for an example .
we mitigated this problem by fixing the random seeds and by performing the experiments from sect.
.
with two different values.
nevertheless some of the results from tab.
tab.
and sect.
.
may require multiple runs to be reproduced.
pattern selection .
the patterns chosen for the quantified formulas are independent of the way in which each solver handles quantifier instantiations.
other patterns could have been more efficient for proving that certain formulas are unsat or alternative rewritings of the formulas could have better triggered particular instantiations.
nonetheless our patterns are configurable and we ran the experiments with and without patterns to asses their impact.
known bugs .
to determine if our technique generates test cases that can detect known bugs we manually matched some of the failed tests against the confirmed bug reports.
as we reported only clear matches as found bugs we are confident that the values from tab.
are a lower bound on the number of known bugs we detected.
related work the developers of smt solvers usually create their own test suites which include manually written tests and regression tests derived from bug reports .
our approach automates parts of this timeconsuming process by automatically generating test cases of incremental complexity this facilitates debugging and error localization.
differential testing .
an effective approach used in practice is differential testing which compares the results produced by different solvers on a set of benchmarks .
different results suggest a bug in one of the solvers determining which one is at fault requires additional effort.
in our case the ground truth is known upfront so our synthesized inputs can be directly used for testing without requiring a reference implementation as test oracle.
as opposed to differential testing our technique can be also applied when there only exists one implementation of a given semantics.
fuzzing.
other test case generation techniques are based on fuzzing.
brummayer et al.
apply fuzzing for testing smt sat and qbf solvers while cyrille et al.
and niemetz et al.
target the solver s api.
note that generates only quantifier free formulas over fixed size bit vectors thus a direct comparison with our work would not be meaningful.
however all these approaches generate inputs that may cause the solver to crash or may exhibit performance issues.
as opposed to our approach they do not have a test oracle so they do not reliably detect soundness and completeness bugs.
the existing techniques require delta debugging to minimize the inputs that lead to a failure in our case the errors are usually found with formulas that are small by construction.
the closest related work to ours is stringfuzz a state of theart fuzzer and generator of smt lib instances.
stringfuzz can create input formulas with various properties e.g.
predefined number ofvariables configurable depth of expressions predefined length for string literals etc.
but it has generators only for primitive string operations and regular expressions.
we do not support regular expressions but our formulas cover complex string operations.
stringfuzz can also apply a set of transformations on already existing benchmarks but very few of them guarantee equisatisifability.
using these formulas for soundness testing requires manually written test oracles.
in contrast our synthesized formulas are sat or unsat by construction and all our transformations preserve their satisfiability therefore soundness testing is fully automatic.
formal verification .
formal verification has been used to verify sat and smt algorithms but not their implementations.
smt solvers are complex highly optimized software systems thus formally verifying their implementation is very challenging.
in contrast our black box testing technique can handle such complex implementations and can find bugs with minimal effort.
validation and proof checking .
a complementary body of work focuses on checking the proofs generated by the solvers.
zhang and malik synthesize a checker for validating the traces produced by a sat solver during refutation proofs.
b hme and weber encode the proofs generated by z3 in isabelle while stump et al.
propose a meta logic for describing and checking proofs for smt.
all these techniques require either modifications of the original solvers or translations of the proofs into other formats.
our technique treats the solvers under test as black boxes and does not depend on a specific implementation and proof format.
conclusions we have presented a novel technique for automatically generating smt formulas from the string theory that are satisfiable or unsatisfiable by construction.
these formulas are used as inputs for testing mostly the soundness of the implementation of a solver but can also reveal completeness and performance issues.
our experimental evaluation shows that our approach effectively finds errors in the implementation of widely used smt solvers and is also applicable to automata based solvers.
we synthesize sat formulas together with models and unsat formulas together with minimal unsat cores having increasing complexity our inputs facilitate error localization and debugging.
this paper focuses on strings but the approach can be directly extended to other theories and their interactions.
as future work we plan to enhance our technique to also cover other classes of solvers and other components.
for example we plan to automatically test max smt solvers and the quantifier instantiation mechanism of an smt solver.
applying our approach to testing decision procedures with machine checkable proofs is another research direction we would like to explore in the future.