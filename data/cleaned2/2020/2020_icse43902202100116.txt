automated query reformulation for efficient search based on query logs from stack overflow kaibo caoy chunyang chenz sebastian baltesx christoph treudex xiang chen ysoftware institute nanjing university china zfaculty of information technology monash university australia xschool of computer science university of adelaide australia school of information science and technology nantong university china imkbcao gmail.com chunyang.chen monash.edu sebastian.baltes christoph.treude adelaide.edu.au xchencs ntu.edu.cn abstract as a popular q a site for programming stack overflow is a treasure for developers.
however the amount of questions and answers on stack overflow make it difficult for developers to efficiently locate the information they are looking for.
there are two gaps leading to poor search results the gap between the user s intention and the textual query and the semantic gap between the query and the post content.
therefore developers have to constantly reformulate their queries by correcting misspelled words adding limitations to certain programming languages or platforms etc.
as query reformulation is tedious for developers especially for novices we propose an automated software specific query reformulation approach based on deep learning.
with query logs provided by stack overflow we construct a large scale query reformulation corpus including the original queries and corresponding reformulated ones.
our approach trains a transformer model that can automatically generate candidate reformulated queries when given the user s original query.
the evaluation results show that our approach outperforms five state of the art baselines and achieves a .
to .
boost in terms of exactmatch and a .
to .
boost in terms of gleu .
index terms stack overflow data mining query reformulation deep learning query logs i. i ntroduction stack overflow is the most popular question and answer q a site for programming related knowledge sharing and acquisition.
over the past decade stack overflow has accumulated a large amount of user generated content making it a valuable repository of software engineering knowledge.
when developers encounter a specific programming question such ashow to use this library?
what is the difference between two languages?
or how to understand this concept?
they tend to use stack overflow to find answers .
to assist developers in finding the knowledge they are looking for in such a large scale knowledge repository stack overflow provides a search engine1 which supports free text search as well as an advanced search with metadata filters.
however even using the provided search engine it is still not easy for developers to effectively find what they want .
there are two reasons for unsatisfactory search results.
first there exists a certain semantic gap between the users corresponding authors intention and input queries.
this means that it is difficult for users to accurately express their query intention with a few keywords .
for example a developer wants to search for the usage of nested lists.
however they may not know how to express this concept accurately and may use a term like list in list as the query.
this query is imprecise and this kind of semantic gap can pose a significant challenge to the search engine of stack overflow.
second a certain semantic gap exists between the users queries and the text content in the relevant posts.
it means the same meaning may be described in different ways with few overlapping words.
for example a developer may input the query sorting in linear time .
however the relevant post titled sorting with o n complexity cannot be retrieved by the search engine.
moreover abbreviations synonyms or even misspelling can also lead to this kind of semantic gap.
to alleviate the above semantic gaps developers may constantly reformulate their queries until the query reflects their real query intention and leads to relevant posts.
by analyzing users query logs provided by stack exchange inc. the company behind stack overflow we find that .
of the queries are reformulated before visiting a post and that developers reformulate their queries .
times on average before clicking on a result.
fig.
shows an illustrative example.
the user first performs the query do and while in java which yields a large number of irrelevant results.
the reason is that the search engine uses orto connect all the words in the query and the search engine cannot distinguish do and while as domain specific keywords.
then the user adds the word loop to this query to make it more explicit which leads to a potentially desired post.
the process of modifying a given query to find a satisfactory search result is called query reformulation.
understanding query reformulation has become an important issue in designing effective information retrieval systems.
to investigate how developers reformulate their queries we first perform a formative study on the users activity logs from stack overflow.
based on the logs from users between december and november we extract queries from sessions.
after analyzing these queries we find that query reformulation has certain ieee acm 43rd international conference on software engineering icse .
ieee query do and while in java search resultsadvanced search t ips results for do and while in java results newest more a thinking in angularjs if i have a jquery background?
the same thing but the angularjs version anyone looking at the template knows what s supposed to happen.
whenever a new member of the development team comes on board she can look at this ... the reason you don t that is that this is like half jquery half angularjs no good.
the problem here is that the developer is trying to jquery the context of angularjs.
that s never ...do in and do and do in answered by feb josh david millerrelevance votes reformulation do and while loop in java search resultsadvanced search t ips results for do and while loop in java results newest more answers8q how do i make a delay in java?
i am trying to something i need something to wait delay for an amount of seconds a .
true if i i ceva .setselected true ... i need to wait here ceva .setselected false i need to wait here i i want to build a step sequencer i m new to .
any suggestions?
...do injava and in whileloop while and java java wait sleep thread sleepasked by jun ardbrelevance votes327 visiting post while loop in method java answers2q while loop in method java i want to achieve this menu to keep looping to receive input when i enter the wrong input other than .
how where to put my ?
i am new .
after the user input ... other than or it should prompt the menu again.
may i know how?
thanks.
how where to put my ?
import java.util.
public class inputmenu public void ...and while loop dowhile loop injava and whileloop dowhile loop java loops while loop do whileasked by jan syamil fuadvotes 0root event idevent id event time event type url 33questions list questions tagged java search search?q do and while in java search search?q do and while loop in java post questions while loop in method javafig.
an illustrative example of query reformulation in the users activity logs common patterns in section iii b .
for example users may fix misspellings such as revising serive to service they may generalize their queries to expand the scope such as revising open calendar react native to open other app react native they may add constraints of programming languages or platforms to the query such as revising read file to java read file they may remove information that is too detailed for retrieving relevant posts such as revising unable to import module copy var task psycopg2 psycopg.so elf file s phentsize not the expected size to elf file s phentsize not the expected size .
as the query reformulation process is tedious for developers especially for novices we propose a software sp ecific que ryreformulation approach sequer based on deep learning to help automatically reformulate their queries.
based on large scale query logs from stack overflow provided under a non disclosure agreement we first extract query reformulation pairs consisting of original and reformulated queries and then adopt an attention based transformer to automatically learn the query reformulation patterns based on the extracted query reformulation pairs.
given the original query the trained model can suggest a list of candidate reformulated queries.
we evaluate the quality of the reformulated queries of our approach with large scale archival manual reformulation results.
the evaluation results show that in terms of exactmatch andgleu our approach achieves .
and .
improvement on average compared with the sequence model based baselines i.e.
seq2seq with attention and hredqs achieves .
and .
improvement comparedwith google prediction service and achieves .
and .
improvement compared with grammatical error correction tools.
in summary we make the following contributions we distill unique insight into developers query reformulation patterns based on large scale real world query logs from stack overflow.
according to the insights from our empirical study we propose a software specific query reformulation approach sequer based on an attention based transformer.
we evaluate the quality of the reformulated queries generated by our approach sequer with large scale archival manual reformulation results.
we implement a browser plugin2for supporting automated software specific query reformulation in practice.
ii.
d ata collection the dataset we used is based on a larger dataset containing all internal http requests processed by stack overflow s web servers within one year requests from december to november .
internal means that the dataset only contains requests with a referrer url from stackoverflow.com .
if a user for example reached a stack overflow post by clicking on a google search result and then triggered a search within stack overflow only the second internal search request would be included in the dataset not the request for the post having a google related referrer.
for each http request the dataset provides an anonymized user identifier that represents logged in registered users as well as users identified by a browser cookie or users identified by their ip address.
this dataset also assigns certain event types to the requests e.g.
searching post visiting or question list browsing depending on their target url.
before extracting the event sequences relevant to this study we preprocess the data as follows.
first we group all events per user identifier and then order them chronologically.
second we utilize heuristics based on the timestamps and request targets to filter out bot traffic and event sequences merely consisting of page refreshes.
third to distinguish between individual sessions we group the events into sequences of events that are not more than six minutes apart following sadowski et al.
s approach .
finally we add an additional filtering step to avoid gaps in the data caused by the focus on internal requests.
a user may for example follow external links in stack overflow posts and then navigate back to stack overflow or open multiple posts in parallel browser tabs.
for our analysis of query reformulation on stack overflow we focus on complete linear navigation sequence that is sequence where the referrer of one request matches the target url of the previous request.
after the above data preprocessing we get a dataset of complete linear navigation sequences.
as shown in the table in fig.
each event is represented by one row with five attributes rooteventid eventid eventtime eventtype 1274and url .
specifically the rooteventid refers to the eventidof the first event in the session the eventid is a unique id that can identify an event the eventtime indicates the utc time when the event occurred the eventtype shows the type of the event possible values of event type arefsearch post questionslist home tags posthistoryg the url is the web request that triggers this event which contains for example the query content or the post id depending on theeventtype .
our dataset contains events from sessions generated by users in which events are queries.
on stack overflow the post visit event and the query event are the two most common operations performed by the users accounting for .
and .
of the events respectively.
users often reach a post in three ways links in the post .
search .
and question list .
.
that is in addition to the navigation between posts search is the most common way for the users to find a post.
from the session perspective .
of the sessions contain query event s and the users perform an average of .
queries in these sessions.
fig.
shows the distribution of the number of sessions and their average session duration in terms of the number of queries contained in the session.
in this figure we can find as the number of queries in the session increases the number of such sessions decreases exponentially while the session duration increases linearly.
session dura on stnuoc noisses gol number of queries in one sessio n sessions dura on seconds fig.
the distribution of sessions number and duration in terms of the number of queries contained in the session to train our query reformulation model we obtain the query reformulation records i.e.
the user s process of transforming an original query into a better one from the user s navigation sequence.
we call these processes the query reformulation threads.
we first remove the sessions that do not contain a query event or of which the last event is not a post visit.
the latter limitation is to ensure that the users finish the query reformulation with a desired results.
this yields a dataset containing events from sessions generated by users in which events are queries.
we adopt a pattern based method to extract the query reformulation threads from each session following a greedy approach q1 q2 qi p1 optional qi qn pm in this pattern we use qito denote the i th query event and usepito denote the i th post visit event.
all the events are ordered chronologically.
we conjecture that qnis a relativelybetter query compared to the queries from q1toqn .
sometimes users may need to visit posts in the query results to determine whether a particular result is what they want and they may reformulate their queries again after visiting those posts to get better results.
therefore to make the pattern more versatile and avoid misrecognition of reformulated queries post visit event is allowed in the sequence of query events.
more details on extracting query reformulation threads can be found in section iv b. iii.
e mpirical study of query reformulation on stack overflow in this section to motivate the required tool support we perform a formative study to understand the characteristics of query reformulation by analyzing the stack overflow log data.
a. what are the characteristics of queries?
query content analysis.
we analyze the query strings to investigate what the users are searching for on stack overflow.
first we collect all query strings and apply traditional text processing steps i.e.
removing punctuation transforming to lower case excluding stop words to them.
then we identify the most popular n grams in the queries.
table i shows the top most frequent grams grams grams and gram in the users queries.
programming languages such as python andjava platforms such as android data types such as string and data structures such as array are the most frequently queried terms.
at the same time how to is the most frequently used phrase in the queries.
almost every gram starts with how to next comes what is and programming language qualifiers such as in python and in java .
it is worth noting that some java and python error logs appear in the top ten grams.
the reason is that the developers often paste these error logs directly into the search box to perform queries and logs like exception in thread main and importerror no module named are the most common error types.
table i the top most frequent n grams in the users queries rank gram gram gram gram python how to how to use how to create a java in python how to get how to make a file what is how do i how do i use string in java how to create exception in thread main android failed to how to make importerror no module named c in swift could not find how to get the error in r how to change no such file or array unable to how can i how to add a sql how do how to find how to check if list not found how to install such file or directory query length analysis.
the users may intentionally limit a query s length to avoid returning a few or even empty results when using traditional search engines .
to investigate whether this phenomenon exists when the users perform queries on stack overflow we use whitespaces as the separator to compute the query length i.e.
word count .
note that we treat words synthesized by camelcase or underscore case as 1275one word since these words often appear in code snippets and can be regarded as the identifiers of variables classes or methods.
fig.
shows the distribution of query length via a box plot.
the median mean 25thpercentile and 75thpercentile of the length are .
and respectively.
the distribution shows that users do intentionally limit the length of their queries to get better search results.
however we can also easily find that the query length span of the outliers is very large and all values from to correspond to outliers.
for these queries it is difficult for the search engine of stack overflow to return satisfactory results.
because most search engines are optimized only to handle common requests they use exact match techniques in which all query words must match a web page for web page retrieval .
a longer query means lower matching probability and leads to lower quality search results.
after manual analysis we find that most of these queries contain error messages or code snippets.
words fig.
the distribution of query length by using box plot note a few outliers with more than words are removed advanced search methods analysis.
we notice that some of the queries in the log are structured which means the users use advanced search methods3.
advanced search methods can provide users with a convenient way to filter search results.
for example the users can narrow the search results by only considering the posts with the tag python or the posts that have a minimum score of .
stack overflow provides advanced search methods to help the users filter search results.
we first apply regular expressions to the users queries to identify the used advanced search method s .
then we calculate the ratio of the queries using advanced search and the proportion of each advanced search method.
the result shows that .
of the queries use the advanced search.
the top most frequently used advanced search methods an illustrative example and their proportions can be found in table ii.
tag filtering user filtering and declaring specific phrases are the top most commonly used advanced search methods accounting for .
.
and .
respectively.
b. why are queries reformulated?
the users reformulate their queries for many reasons.
for example the queries may not specify the corresponding programming language or some words in the queries may be misspelled.
we use the provided dataset to analyze why the users reformulate their queries.
we manually classify ii the top most frequently used advanced search methods type example proportion tag job output .
user user .
declare specific phrase ios save to files .
exclude phrase accordion jquery .
wildcard does not support... .
question only is question powershell version .
answers answers firebase .
multiple tags or array vs matrix .
score safari cache score .
creation date oauth read gmail created .. .
randomly collected query reformulation threads4into four categories.
the first and second author classified these threads independently.
for the cases without an agreement the final classification result is determined through discussions.
for the threads with more than two queries if multiple query reformulation types are identified the type of reformulation from the first query to the last query is used as the final classification result.
the kappa inter rater agreement is .
which shows the high agreement of classification.
table iii shows the manual classification results.
in this table we can see that adding new information to the query is the most common query reformulation operation which accounts for .
of all threads then comes modifying the query .
and deleting information from the query .
.
in the category of adding new information we further divide it into two sub categories adding information about specific programming languages or platforms adding new requirements for the question or more detailed content.
in the category of modifying we further divide it into three subcategories spelling and syntax checking simplifying and refining the query to reformulate it into the most commonly used expression modifying to other content related to the original query.
in the category of deleting we further divide it into three sub categories deleting some unnecessary or less informative words deleting specific information in error messages or code snippets such as file path url function names etc.
deleting punctuation and some mistyped symbols.
based on the classification result we can observe many different types of query reformulation operations such as adding information deleting information and modifying their expressions .
previous studies mainly use rule based methods to perform automated query reformulation.
however each of these methods can only target query reformulation for a specific reason.
different rules need to be designed for each situation and then implemented with different methods which is inefficient and difficult to achieve.
for example for the query reformulation in the category of modifying 4the number is the minimum number to be statistically representative of a large dataset with a confidence level of and error margin of via a commonly used sampling method .
1276table iii categories of query reformulation category sub category example proportion addsoftware or platform why to use sha1 why to use sha1 in android .
detailed requirement db file open db file .
category subtotal .
modifyspelling and syntax check .net string.
emptyp .net string.
empty .
simplify and refine list inside list for sightly nested list in sightly .
turn to related information python program freezes python program hangs .
category subtotal .
deletedetailed or unnecessary words c update a keypairvalue in a dictionary c update dictionary .
specific information in error messageproperty getdata does not exist on type reactinstance does not exist on type reactinstance .
symbols or web links dbms datapump.open dbms datapump.open .
category subtotal .
others .
the user may completely change the expression of a query e.g.
from how to cut youtube embedded videos to how to make embedded videos that only play certain parts .
it is challenging to implement this type of reformulation by using rule based methods.
therefore we find it necessary to propose a general query reformulation approach which is the motivation of this study.
c. what is the scale of changes that query reformulation involves?
in section iii b we find that when reformulating a query the users may add remove or replace some words in the original query.
to understand the scale of changes that query reformulation involves we measure the similarity between the original query and the reformulated query.
for each query reformulation thread n 1pairs of reformulation samples original reformulated can be extracted that is f q1 qn q2 qn qn qn g. the first query original in the pair is the initial query performed by the user and the second query reformulated is the user s manual reformulated query which meets their requirement.
we use a text matching algorithm with improved dynamic programming to find the character level longest common subsequence lcs between original andreformulated .
then the similarity between original andreformulated can be defined as follows similarity original reformulated nmatch ntotal wherenmatch is the number of characters in the lcs and ntotal is the sum of the number of characters in original and reformulated .
the similarity score is in the range of to .
the higher the similarity score the fewer changes between original andreformulated .
as shown in fig.
among query reformulation pairs .
of the pairs are very similar i.e.
the similarity score is larger than .
with an average of .
character level modifications which corresponds to .
words according to the average length of query words.
the analysis result indicates that most of the query reformulations only involve minor changes.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
1counts thousands similaritysimilarityfig.
distribution of the similarity score of query reformulation pairs d. summary and implications our empirical study shows that on stack overflow most of the users queries are simple and short with only to words but there are also very long queries containing error logs code snippets and structured queries with advanced search patterns.
the users perform query reformulation for various reasons making it difficult to design a general query reformulation model by only using rule based methods.
most query reformulations only involve minor changes.
considering the diversity of query reformulation patterns it would require significant effort to manually develop a complete set of reformulation patterns which is both timeconsuming and error prone.
unlike enumerating all the rules the deep learning method can automatically learn the latent features from the dataset and these latent features are helpful for downstream tasks.
based on the above findings we believe it is necessary and feasible to propose an automated query reformulation approach based on deep learning.
our proposed approach would benefit the developers and the stack overflow community.
in particular the developers can use our automated query reformulation tool to refine their queries and get better search results which can alleviate the effort of manual reformulation.
the stack overflow community can also use the query reformulation model to enhance the users search experience.
1277iv.
a utomated query reformulation a. overview of sequer our formative study has shown a wide variety of query reformulation behaviors.
since not all reformulation patterns are amenable to automated tool support we focus on query reformulations that trigger minor changes to the original query to develop our automated query reformulation approach.
in this work we formulate query reformulation as a machine translation problem in which an original query is translated into a reformulated query.
we solve the problem using the transformer model .
the overall workflow of sequer is shown in fig.
.
sequer first extracts query reformulation threads for sampling original queries and corresponding reformulated ones.
then a large corpus of query reformulation pairs is gathered for training the model each of which contains the original query and the corresponding reformulated one that triggers only minor changes in section iv b .
to model the patterns of query reformulation such as spelling correction expression refinement unnecessary word deletion sequer trains a transformer based model with a large parallel corpus of query reformulation pairs from section iv c to section iv e .
given the users original queries the trained model can suggest a list of reformulated candidates for selection.
b. collection of query reformulation pairs based on the description in section ii query reformulation threads can be extracted from the users navigation sequences by pattern matching.
the most important thing for the pattern is how to ensure that qiandqi 1are issued for the same purpose rather than two independent queries.
two constraints are applied the character level similarity between qiand qi 1must be greater than .
by using equation .
the browsing time of the post p1cannot be greater than seconds.
the first constraint can limit the change scale since a large scale change is likely to introduce a new query.
the second constraint can guarantee the post p1is not what the user wants since a previous study shows for an unsatisfactory post the user would not spend more than seconds on it.
we set the minimum number of query events before the final post visiting event in the thread to .
after identifying all the query reformulation threads we perform the following data cleaning steps.
for consecutive identical queries in the thread we only keep one of these identical queries and remove the rest to avoid generating duplicate query reformulation pairs.
we also remove threads containing queries with non english words since non english words are not encouraged to be used on stack overflow5.
after the above data cleaning we pair each query between q1toqn 1withqn i.e.
q1 qn q2 qn qn qn as the training instances.
from the provided dataset we extract a total of query reformulation pairs.
some of these reformulation pairs are hard to predict due to their large scale modifications.
after randomly sampling pairs with different similarity we carry out a pilot study to determine the similarity threshold which can be used to identify large scale modifications.
the results show that reformulation pairs with a similarity score higher than .
are predictable while the remaining pairs i.e.
reformulating by large scale modifications cannot be predicted even by humans.
as analyzed in section iii c .
of the query reformulations involve minor modifications with a similarity of at least .
.
therefore we only consider these similarenough query reformulations which results in query reformulation pairs.
c. byte pair encoding traditional word segmentation methods include whitespaceseparated word level and character level segmentation.
however word level embedding cannot handle the out ofv ocabulary oov problem and the character level is too fine grained resulting in the loss of high level information.
therefore we adopt the bpe byte pair encoding which can effectively interpolate between word level inputs for frequent symbol sequences and character level inputs for infrequent symbol sequences.
the bpe algorithm contains multiple iterations.
in each iteration it calculates each consecutive byte pair s frequency and finds the most frequent one then merges the two byte pair tokens into one token.
this encoding approach can divide words into sub words like encoding the common words at the word level while encoding the rare words at the character level.
since the form of the users queries on stack overflow varies using bpe can better identify the content of the users queries.
for example misspelled words can be divided into several correctly spelled sub words to alleviate the oov problem s impact.
words with camel case style can be separated into several sub words and then each sub word can be identified.
besides using bpe to separate words with their affixes can help the model learn the relationships between them.
after applying the bpe algorithm on the corpus we get a vocabulary composed of sub words which is used as the dictionary for our model.
d. transformer with the introduction of the attention mechanism many neural machine translation approaches integrate the attention mechanism with sequence transduction models like convolution neural network cnn and recurrent neural network rnn to improve their performance.
even so the cnn based network architectures require many layers to capture longterm dependencies leading to high computational cost and operations in rnn based network structures cannot be parallelized resulting in low efficiency.
to address these issues transformer is proposed which is the first transduction model entirely relying on the attention mechanism and has shown competitive performance on various tasks such as machine translation image captioning document generation and syntactic parsing .
1278activity dataquery sequenceoriginal query reformulated query pattern based data extractionalignmentpreprocessing training data preprocessing training databyte pair encoding byte pair encodingtraining reformulation modeloriginal query reformulated querydata cleaning transformer decodertransformer encoderfig.
the overall workflow of our approach sequer the most significant difference between transformer and other sequence transduction models like cnns and rnns is that it relies entirely on self attention called scaled dotproduct attention to obtain global dependencies and the attention weights are defined by how each word of the sequence is influenced by all the other words in the sequence.
the self attention mechanism creates shortcuts between the current token and all the other context tokens to determine the current token vector for the final input representation.
as weights of these shortcuts are customizable the self attention mechanism is able to capture global dependencies without using many layers of convolution and pooling in cnn based models.
at the same time the calculation in self attention is implemented with highly optimized matrix multiplication and thus resolves the low efficiency caused by the rnn based models which sequentially encode the input tokens.
intuitively for an input sequence first a neural network is employed to map the input into three matrices query q keyk and value v. then the dot products of the queries qwith all keys kis divided bypdk dkis the dimension of the queries and a softmax function is applied to obtain the weights for the values.
finally the weighted value is used as the representation of each input.
attention q k v softmax qkt pdk v instead of performing a single self attention function the transformer employs a multi head self attention which linearly projects the queries q keyskand valuesv h times with different learned linear projections respectively where h is the number of heads.
to obtain the temporal relationship of the words the transformer adds positional embedding to the input embedding.
self attention can be regarded as a basic calculation in transformer.
the transformer model comprises an encoder and a decoder which are actually multiple identical encoder and decoder blocks stacked on top of each other with the same number of units.
each encoder block has one layer of multihead self attention followed by another layer of feed forward network ffn .
on the other hand each decoder has an extra masked multi head self attention which prevents the model from seeing the generated words during parallel training.
on the encoder side the multi head self attention layer s input is the input embedding with temporal information and the layer output is normalized and sent into an ffn which consists of two linear transformations with a relu activation.
the outputof the encoder on the top of the stack is a set of attention vectorskandv which are used by the decoder to determine the token it should pay attention to.
on the decoder side the previous output is used as the input to the masked multihead self attention layer.
after that another multi head selfattention layer with subsequent ffn generates decoder output htby getting the query matrix qfrom the masked multi head self attention layer the key kand valuevmatrices from the output of the encoder stack.
finally the output of the decoder stackhtis sent to a fully connected neural network to get the logits vectors and then a softmax layer to predict the probabilities of the next token.
p wt 1jw1 wt softmax htw b wherehtis the output of the decoder stack.
e. beam search during decoding for each time step t the transformer model will output the word with the highest conditional probabilityyt argmaxy2dp yjy1 yt via greedy search fromjdjnumber of words where drepresents all the words in the word dictionary.
since we calculate the conditional probability of generating an output sequence based on the input sequenceqt t 1p ytjy1 yt wheretis the maximum length of the output sequence the main problem with greedy search is that there is no guarantee that the optimal sequence will be obtained.
the reason is that although the greedy strategy ensures that the output candidate with the highest probability is picked up for each time step it cannot ensure that the conditional probability of the entire output sequence obtained is the highest.
beam search is an improved algorithm of greedy search and beam size kis its hyper parameter.
the decoding process using beam search is as follows at time step k words with the highest probability are selected as the first word ofkcandidate output sequences cs1.
then at time step i k output sequences with the highest conditional probability csi will be selected from kjdjpossible output sequences based on csi .
aftertiterations ksequences with the highest score will be selected from csas the beam search result where t is the maximum number of tokens of the output sequence and csis the collection from cs1tocsi.
note for each sequence portions including and after special end of sequence tokens are discarded.
the score is calculated as follows 1279fig.
a screenshot of our query reformulation plugin for the search engine of stack overflow l logp y1 yl l lx t 1logp ytjy1 yt wherelis the length of the sequence in cs and is the length normalization parameter.
f .
implementation in our implementation the maximum vocabulary size for bpe is set to .
for the transformer we use the tensor2tensor library developed by the google brain team.
the transformer model contains four attention heads with four encoder and decoder layers with hidden size .
during the model training the parameters are learned by back propagation with adam optimizer to minimize the error rate.
we train our model with batch size learning rate for epochs on nvidia v100 gpu 32g memory for about hours.
during decoding the hyper parameter kof beam search is set to to ensure the probability of finding the optimal solution.
the length normalization parameter is set to .
which is a common practice in neural machine translation .
to make our work more practical we develop a browser plugin6based on tampermonkey which is a popular userscript manager.
the browser plugin will automatically analyze the query content and recommend the top query reformulation candidates to the users for selection a screenshot can be found in fig.
.
although the plugin is designed to only work on stack overflow now it can be easily extended to other software specific q a sites.
v. q uality of recommended query reformulation a. dataset from the query reformulation pairs we randomly take of these query pairs as the training set to train the model as the validation set to tune model hyper parameters and as the testing set to evaluate the quality of recommended reformulations.
baselines as analyzed in section iii b many queries are reformulated to fix grammatical errors.
therefore we first adopt a popular grammatical error correction gec tool as the baseline.
languagetool7is an open source proof reading tool for more than languages.
this tool s style and grammar checker is rule based and has been developed for over ten years.
as our task is query reformulation and google is the most popular search engine in the world we choose google prediction service googleps as a baseline.
google uses a prediction service to help complete searches in the search box or address bar within chrome.
these suggestions are based on the real searches that happen on google.
common and trending queries relevant to the strings entered by the users are shown in the drop down bar for the users to choose8.
since google has accumulated a large scale dataset of the users queries googleps can efficiently and accurately reformulate users queries such as correcting misspelled words completing words that the users are typing and appending the next possible word.
the query reformulation task can also be regarded as a translation task i.e.
translating the original query into the reformulated query .
therefore we take the most classical neural machine translation model seq2seq as our baseline.
it contains one long short term memory lstm model as the encoder which can encode the original query to an embedding vector and another lstm model which can decode that embedding vector to the reformulated query.
we also add the seq2seq model with the attention mechanism as another baseline.
besides there are many studies in information retrieval about query suggestion.
we select hredqs as one of our baselines which is a representative hierarchical and session based query suggestion model with full source code release.
hred qs is trained with our dataset.
in particular given a query in the session hred qs first encodes the information seen up to the position by a querylevel rnn encoder and a session level rnn encoder.
then it uses the following decoder to predict the next query.
to keep the setting of all baselines consistent we only feed the last query before the reformulated one in the session to hred qs.
to make a fair comparison we employ the same data preprocessing method and byte pair encoding for seq2seq and hred qs as sequer and we perform hyper parameter optimization with grid search .
c. evaluation metrics query reformulation is similar to the grammar error correction task i.e.
revising some words in the original sentence for generating the target sentence .
therefore we evaluate the query reformulation with the metrics used in the gec task i.e.
gleu m2andexactmatch .
1280gleu general language evaluation understanding is a customized metric from bleu bilingual evaluation understudy which is a widely used metric to measure the performance of machine translation approaches.
since only part of the source sentence will be changed in the gec task which is different from the machine translation task this motivates a small change to bleu that computes n gram precision over the reference but assigns more weight ton grams that have been correctly changed from the source.
therefore compared with bleu gleu is more suitable for evaluating query reformulation in our study.
maxmatch orm2 is another widely used gec evaluation metric that computes the sequence of phrase level edits between a source sentence and a system hypothesis that achieves the highest overlap with the gold standard annotation.
these edits are scored by precision recall and f1.
specifically in the scenario of query reformulation m2 p represents the proportion of edits of the original query given by an approach that appears in the user s manual reformulation.
m2 rrepresents the proportion of edits of the original query by users that are correctly predicted by an approach.
m2 f1 is the harmonic mean of m2 pandm2 r. exactmatch em evaluates the probability of a perfect match between the query provided by a specific approach and the user s manually reformulated one.
since sequer uses beam search during decoding it can suggest multiple reformulations for an original query for the decoding results ofsequer with different beam size we can calculate em em and em where em nmeans one case will be considered positive as long as one of nreformulation results returned by beam search matches the ground truth.
d. evaluation results we report our evaluation results by answering the following two research questions.
rq1 can our approach sequer generate better reformulated queries than the baselines?
table iv shows the evaluation results of query reformulation on the testing set of sequer and baselines in terms of all the evaluation metrics.
sequer outperforms all state of theart baselines by significant margins in terms of all metrics.
compared with the best baseline seq2seq with attention sequer achieves .
and .
improvement in terms of em 10andgleu .
to better illustrate our results table v lists examples of query reformulations by different approaches and more examples can be found on our project site9.
gec tools perform well in correcting misspellings strin to string in example grammar issues playing to play in example and sentence format currentdate to current date in example .
however they only achieve a .
exact match as spelling errors only account for of the reasons for the users query reformulations in section iii b .
in addition they have difficulty in detecting spelling errors specific to the programming field.
for example they cannot iv performance of automated query reformulation approach em em em gleu m2 p m2 r m2 f1 languagetool .
.
.
.
.
googleps .
.
.
.
.
.
.
hred qs .
.
.
.
.
.
.
seq2seq .
.
.
.
.
.
.
seq2seq attn.
.
.
.
.
.
.
.
sequer .
.
.
.
.
.
.
detect any misspelled words in how to import bumpy array where the word bumpy is the wrong spelling of numpy apython library .
instead sequer can correct these software specific misspelled words by learning the domain knowledge from our software specific dataset another example is from c3 to c in example .
googleps can perform complex reformulations by learning from billions of queries google processes every day such as adding important missing keywords loop in example and suggesting language platform limitations python in examples and .
however as a general purpose search engine google does not perform well in software specific query reformulation especially for unpopular software specific queries.
for example googleps cannot reformulate the query usr bin ld skipping incompatible libpthread.so in example but sequer can remove the file directory to make it more general.
as the file directory often varies between developers coding environments it should be removed to keep the query more general for retrieving more accurate results.
by learning from massive query reformulations which are software specific from stack overflow sequer can effectively revise such queries by applying software specific reformulation strategies similar examples in examples and .
since using the same training data as sequer the hredqs seq2seq and seq2seq with attention model can capture software specific semantics during query reformulation.
this is the reason why they achieve better performance than the other baselines.
however since the goal of hred qs is basically next query prediction the context aware hierarchical encoding does not enhance the ability of the decoder to generate a reformulated query but may obscure the information of the original query causing a deviation of the decoder result.
for example comboox lost focus should be reformulated to combobox lost focus but hred qs reformulates it to iphone x lost focus .
besides the problem for both hred qs and seq2seq is that the input is encoded into one single vector representation which may not be sufficient to store all the information especially for long queries.
for example allow user to paste url with .ph and rpeturn clean url should be reformulated to allow user to paste url with .php and return clean url .
however seq2seq model can only reformulate it to allow user to paste url with php due to the query length.
on the contrary sequer does not have this problem by using an attention based transformer model.
in addition to the types of query reformulations mentioned above sequer also outperforms baselines in more complex reformulations such as revising with more commonly used 1281table v examples of query reformulation by different approaches represents no reformulation suggestions id original query googleps seq2seq attn.
sequer pandas delete last characters in strin python delete last characters in string pandas delete last characters in string python delete last characters in string 2playing sound in swift3 playing sound in swift play sound in swift swift grab currentdate swift grab current date swift get current date 4assign string to number c3 assign string to number c assign string to number c do and while in java do and while loop in java do and while loop in java 6requests negotiate requests negotiate python python requests negotiate requests negotiate usr bin ld skipping incompatible libpthread.so libskipping incompatible libpthread.so usr bin ld skipping incompatible libpthread.so 8subtracting the pandas series rf from all columns subtracting the pandas series rffrom allcolumns subtracting the pandas series rf from all columns trigger missing report definition trigger trigger missing report definition trigger trigger missing report definition trigger 10opencv scale image opencv scale image to opencv resize image a search a search example a search python a star search 12df h show disk df h show disk resteasy how to support websocket resteasy how tosupport websocket resteasy how tosupport websocket 14volume control programatically android android volume control programmatically volume control android software specific terms e.g.
swift grab currentdate to swift get current date in example opencv scale image to opencv resize image in example replace symbols with text e.g.
a search to a star search in example or enclose symbols that will accidentally trigger advanced search in quotation marks e.g.
df h show disk to df h show disk in example to prevent showing results for df show disk and not containing h and simplify or refine the query e.g.
resteasy how to support websocket to resteasy websocket in example and volume control programatically android to volume control android in example .
rq2 what types of query reformulations are challenging for sequer to deal with?
although sequer can achieve the best performance compared to state of the art baselines sequer also makes mistakes in some query reformulations.
we manually check some randomly sampled erroneous reformulations and identify two main reasons why our reformulations do not match the ground truth.
first some queries are edited to add more information which is beyond the context of the original query such as python covert variable to integer to python convert hexadecimal to integer and git commit am to git commit am vs git add .
although sequer can successfully revise the misspelling covert to convert it cannot guess the replacement of variable with hexadecimal or adding vs git add by considering only the local context of the query.
to support such complicated reformulation we need to consider the broader context of the search e.g.
previous queries in the future.
second the same meaning may be expressed in different ways.
for example given the original query remove from input sequer recommends the reformulated query as remove comma from input however the ground truth is remove from input .
similarly given the original query read mouse cursor sequer recommends the reformulated query as c read mouse cursor however the ground truth is read mouse cursor in c .
although the users reformulation results and our recommendations are not exactly matched they convey the same meaning.
some of our recommendations are of higher quality than the users reformulation and may lead to better search results.
that is also why the performance of sequer is highly underestimated.
e. discussion in section v d we evaluate the quality of reformulations from different approaches by comparing them with users manual ones with the metrics used in the gec task.
however none of these metrics consider the model effectiveness i.e.
the ability of the reformulated query to retrieve the desired post .
therefore we further evaluate the retrieval effectiveness ofsequer in this section.
for each query reformulation thread mentioned in section ii we collect pairs of users original query and finallyvisited post which is assumed to be the target post.
these query post pairs can be used to demonstrate the retrieval effectiveness of the model.
for each pair we adopt both our approach and baselines in section v b to reformulate the query and check the ranking of the target post in all candidate posts on stack overflow.
all the queries in the testing set are paired with their corresponding finally visited post as the evaluation data.
we use mrr mean reciprocal rank as the metric for retrieval effectiveness evaluation.
mrr is the average of the reciprocal ranks i.e.
the multiplicative inverse of the target post s rank in the search result of the search results for all the queries.
for example given a query if the target post ranks fifth in the search result the reciprocal rank is .
.
a higher mrr value indicates a better search result.
the comparison results between sequer and baselines in terms of mrr can be found in table vi.
sequer achieves the best performance i.e.
.
boost in terms of mrr to the original query .
even compared with the best baseline seq2seq attn.
sequer still achieves a .
boost.
this result shows that the reformulated query given by sequer is not only the closest to manual reformulation but also has the best retrieval effectiveness among all the baselines.
therefore sequer can effectively help users obtain better search results via high quality query reformulation.
table vi evaluation result of retrieval effectiveness approach mrr boost rate original query .
languagetool .
.
googleps .
.
hred qs .
.
seq2seq .
.
seq2seq attn.
.
.
sequer .
.
vi.
r elated work information retrieval ir has been widely used in software engineering se tasks such as traceability recovery 1282feature location library migration api search and gui design seeking .
in this section we summarize the related works about query reformulation in general ir and its application in se domain.
a. query reformulation in general information retrieval to help users better refine their queries there are many studies on query expansion query reformulation and query suggestion in information retrieval.
in detail jiang et al.
tried to provide query suggestions based on previous queries in the session by introducing a binary classifier and an rnn based decoder as the query discriminator and the query generator.
chen et al.
proposed an attention based hierarchical neural query suggestion model that combines a session level neural network and a user level neural network to model the users short and long term search history.
however most of these studies are session based or user profile based and apply to general text search.
different from general text search search in the software engineering domain is very specific with domain specific terms and code snippets which make general approaches not applicable in this scenario.
therefore we carry out this study based on domain specific dataset for providing a software specific automated query reformulator.
b. query reformulation for document search in se the performance of document search in software engineering relies on the domain specific query reformulation.
haiduc et al.
proposed several metrics to measure query difficulty query specificity and query quality for concept location.
based on these metrics they further developed a machine learning model to adopt one of four strategies to recommend revised queries.
rahman et al.
proposed a word embedding based method to extract semantically similar terms from questions on stack overflow hence suggesting semantically relevant queries.
li et al.
shared a similar idea by building a software specific domain lexical database based on tags on stack overflow and optimized the input queries to help search software related documents.
chen et al.
reformulated the chinese queries to english ones for searching related posts on stack overflow.
most of these previous studies generate query reformulation based on heuristic rules or lexical databases which depends greatly on the quality and size of the rules or the database.
in contrast sequer is fully data driven which is based on large scale real world developers queries on stack overflow.
we believe that sequer can automatically learn reformulation patterns and generate better reformulation result.
c. query reformulation for code search in se code search plays an important role in software engineering many previous studies focused on query reformulation for code search.
sisman et al.
proposed a query reformulation framework by enriching the users queries with certain specific terms drawn from the highest ranked retrieved artifacts.howard et al.
leveraged similar word pairs in comments and method signatures which are semantically similar in software engineering to reformulate users queries.
lu et al.
took a similar method i.e.
identifying each term in the original query and extends with synonyms generated from wordnet.
nie et al.
identified software specific expansion words from high quality pseudo relevance feedback question and answer pairs on stack overflow.
rahman et al.
identified terms from the source code using a novel term weight coderank and then suggested effective reformulation of the original query by exploiting the source document structures query quality analysis and machine learning.
they further proposed a query reformulation technique that suggests a list of relevant api classes for a natural language query by exploiting keyword api associations from the questions and answers on stack overflow .
similarly sirres et al.
augmented the original query with structural code entities by mining questions and answers from stack overflow.
different from code search our study mainly focuses on software specific document search.
moreover sequer can complement these code search approaches to reformulate the users queries better.
vii.
c onclusion constructing an efficient query to search through a large amount of programming knowledge is a challenging task for developers especially for novices.
our empirical study on a large scale real world query records on stack overflow indicates that developers always reformulate their queries to obtain the desired results.
to assist with developers efficient search we propose a deep learning based approach sequer to learn query reformulation patterns from query logs provided by stack overflow.
given the original query it can automatically recommend a list of reformulation candidates for selection.
evaluation on large scale archival query reformulations verifies the superiority of sequer compared with five state ofthe art baselines.
in the future we will further improve the performance of sequer by incorporating more contextual information such as the users profile query history and their post visiting history.
moreover we plan to take our approach one step further by directly recommending posts for the query.
based on users queries and corresponding clicked posts provided by stack overflow we could develop a domain specific model to learn the relationships between them.
acknowledgement the authors would like to thank stack exchange inc. for sharing the dataset and the anonymous reviewers for their insightful comments and suggestions.
this work is supported in part by the national natural science foundation of china grant nos.
and the open project of state key laboratory for novel software technology at nanjing university grant no.
kfkt2019b14 and the australian research council de180100153 .
1283references y .
huang c. chen z. xing t. lin and y .
liu tell them apart distilling technology differences from crowd scale comparison discussions in 33rd ieee acm international conference on automated software engineering ase .
ieee pp.
.
c. chen and z. xing mining technology landscape from stack overflow in proceedings of the 10th acm ieee international symposium on empirical software engineering and measurement pp.
.
c. chen z. xing and l. han techland assisting technology landscape inquiries with insights from stack overflow in ieee international conference on software maintenance and evolution icsme .
ieee pp.
.
r. abdalkareem e. shihab and j. rilling what do developers use the crowd for?
a study using stack overflow ieee software vol.
no.
pp.
.
x. xia l. bao d. lo p. s. kochhar a. e. hassan and z. xing what do developers search for on the web?
empirical software engineering vol.
no.
pp.
.
c. chen and z. xing towards correlating search on google and asking on stack overflow in proceedings of ieee 40th annual computer software and applications conference .
ieee pp.
.
r. datta d. joshi j. li and j. z. wang image retrieval ideas influences and trends of the new age acm computing surveys vol.
no.
pp.
.
z. j. zha l. yang t. mei m. wang z. wang t. s. chua and x. s. hua visual query suggestion towards capturing user intent in internet image search acm transactions on multimedia computing communications and applications vol.
no.
pp.
.
c. chen z. xing and x. wang unsupervised software specific morphological forms inference from informal discussions in ieee acm 39th international conference on software engineering icse .
ieee pp.
.
x. chen c. chen d. zhang and z. xing sethesaurus wordnet in software engineering ieee transactions on software engineering .
b. j. jansen d. l. booth and a. spink patterns of query reformulation during web searching journal of the american society for information science and technology vol.
no.
pp.
.
m. sloan h. yang and j. wang a term based methodology for query reformulation understanding information retrieval journal vol.
no.
pp.
.
l. bing w. lam t. l. wong and s. jameel web query reformulation via joint modeling of latent topic dependency and term context acm transactions on information systems tois vol.
no.
pp.
.
j. y .
jiang y .
y .
ke p. y .
chien and p. j. cheng learning user reformulation behavior for query auto completion in proceedings of the 37th international acm sigir conference on research development in information retrieval pp.
.
s. y .
rieh et al.
analysis of multiple query reformulations on the web the interactive information retrieval context information processing management vol.
no.
pp.
.
j. huang and e. n. efthimiadis analyzing and evaluating query reformulation strategies in web search logs in proceedings of the 18th acm conference on information and knowledge management pp.
.
i. sutskever o. vinyals and q. v .
le sequence to sequence learning with neural networks in proceedings of advances in neural information processing systems pp.
.
a. sordoni y .
bengio h. vahabi c. lioma j. grue simonsen and j. y .
nie a hierarchical recurrent encoder decoder for generative contextaware query suggestion in proceedings of the 24th acm international on conference on information and knowledge management pp.
.
r. c. cornea and n. b. weininger providing autocomplete suggestions feb. us patent .
c. sadowski k. t. stolee and s. elbaum how developers search for code a case study in proceedings of the 10th joint meeting on foundations of software engineering pp.
.
p. mahdabi m. keikha s. gerani m. landoni and f. crestani building queries for prior art search in proceedings of information retrieval facility conference .
springer pp.
.
d. downey s. dumais d. liebling and e. horvitz understanding the relationship between searchers queries and information goals in proceedings of the 17th acm conference on information and knowledge management pp.
.
r. singh and n. s. mangat elements of survey sampling .
springer science business media vol.
.
a. j. viera j. m. garrett et al.
understanding interobserver agreement the kappa statistic fam med vol.
no.
pp.
.
c. chen x. chen j. sun z. xing and g. li data driven proactive policy assurance of post quality in community q a sites proceedings of the acm on human computer interaction vol.
no.
cscw pp.
.
c. chen z. xing and y .
liu by the community for the community a deep learning approach to assist collaborative editing in q a sites proceedings of the acm on human computer interaction vol.
no.
cscw pp.
.
j. ooi x. ma h. qin and s. c. liew a survey of query expansion query suggestion and query refinement techniques in proceedings of 4th international conference on software engineering and computer systems .
ieee pp.
.
w. b. croft approaches to intelligent information retrieval.
information processing and management vol.
no.
pp.
.
x. wang and c. zhai mining term association patterns from search logs for effective query reformulation in proceedings of the 17th acm conference on information and knowledge management pp.
.
b. sisman and a. c. kak assisting code search with automatic query reformulation for bug localization in proceedings of 10th working conference on mining software repositories .
ieee pp.
.
l. bergroth h. hakonen and t. raita a survey of longest common subsequence algorithms in proceedings seventh international symposium on string processing and information retrieval.
spire .
ieee pp.
.
t. young d. hazarika s. poria and e. cambria recent trends in deep learning based natural language processing ieee computational intelligence magazine vol.
no.
pp.
.
a. vaswani n. shazeer n. parmar j. uszkoreit l. jones a. n. gomez .
kaiser and i. polosukhin attention is all you need in proceedings of advances in neural information processing systems pp.
.
c. liu r. w. white and s. dumais understanding web browsing behaviors through weibull analysis of dwell time in proceedings of the 33rd international acm sigir conference on research and development in information retrieval pp.
.
k. cao and m. rei a joint model for word embedding and word morphology arxiv preprint arxiv .
.
r. sennrich b. haddow and a. birch neural machine translation of rare words with subword units arxiv preprint arxiv .
.
d. bahdanau k. cho and y .
bengio neural machine translation by jointly learning to align and translate arxiv preprint arxiv .
.
j. chen c. chen z. xing x. xu l. zhu g. li and j. wang unblind your apps predicting natural language labels for mobile gui components by deep learning in proceedings of the acm ieee 42nd international conference on software engineering ser.
icse .
new york ny usa association for computing machinery p. 322 c .
.
available p. j. liu m. saleh e. pot b. goodrich r. sepassi l. kaiser and n. shazeer generating wikipedia by summarizing long sequences arxiv preprint arxiv .
.
n. kitaev and d. klein constituency parsing with a self attentive encoder arxiv preprint arxiv .
.
p. koehn pharaoh a beam search decoder for phrase based statistical machine translation models in proceedings of the conference of the association for machine translation in the americas .
springer pp.
.
a. vaswani s. bengio e. brevdo f. chollet a. n. gomez s. gouws l. jones l. kaiser n. kalchbrenner n. parmar r. sepassi n. shazeer and j. uszkoreit tensor2tensor for neural machine translation corr vol.
abs .
.
p. j. werbos backpropagation through time what it does and how to do it proceedings of the ieee vol.
no.
pp.
.
d. p. kingma and j. ba adam a method for stochastic optimization arxiv preprint arxiv .
.
q. wang b. li t. xiao j. zhu c. li d. f. wong and l. s. chao learning deep transformer models for machine translation arxiv preprint arxiv .
.
s. hochreiter and j. schmidhuber long short term memory neural computation vol.
no.
pp.
.
w. u. ahmad k. w. chang and h. wang context attentive document ranking and query suggestion in proceedings of the 42nd international acm sigir conference on research and development in information retrieval pp.
.
j. y .
jiang and w. wang rin reformulation inference network for context aware query suggestion in proceedings of the 27th acm international conference on information and knowledge management pp.
.
w. chen f. cai h. chen and m. de rijke attention based hierarchical neural query suggestion in the 41st international acm sigir conference on research development in information retrieval pp.
.
w. u. ahmad k. w. chang and h. wang multi task learning for document ranking and query suggestion in international conference on learning representations .
j. s. bergstra r. bardenet y .
bengio and b. k gl algorithms for hyper parameter optimization in advances in neural information processing systems pp.
.
c. napoles k. sakaguchi m. post and j. tetreault ground truth for grammatical error correction metrics in proceedings of the 53rd annual meeting of the association for computational linguistics and the 7th international joint conference on natural language processing volume short papers pp.
.
gleu without tuning arxiv preprint arxiv .
.
k. papineni s. roukos t. ward and w. j. zhu bleu a method for automatic evaluation of machine translation in proceedings of the 40th annual meeting on association for computational linguistics .
association for computational linguistics pp.
.
d. dahlmeier and h. t. ng better evaluation for grammatical error correction in proceedings of the conference of the north american chapter of the association for computational linguistics human language technologies pp.
.
r. oliveto m. gethers d. poshyvanyk and a. de lucia on the equivalence of information retrieval methods for automated traceability link recovery in proceedings of ieee 18th international conference on program comprehension .
ieee pp.
.
c. mcmillan d. poshyvanyk and m. revelle combining textual and structural analysis of software artifacts for traceability link recovery in proceedings of icse workshop on traceability in emerging forms of software engineering .
ieee pp.
.
g. gay s. haiduc a. marcus and t. menzies on the use of relevance feedback in ir based concept location in proceedings of ieee international conference on software maintenance .
ieee pp.
.
b. dit m. revelle and d. poshyvanyk integrating information retrieval execution and link analysis algorithms to improve feature location in software empirical software engineering vol.
no.
pp.
.
c. chen z. xing and y .
liu what s spain s paris?
mining analogical libraries from q a discussions empirical software engineering vol.
no.
pp.
.
c. chen and z. xing similartech automatically recommend analogical libraries across different programming languages in proceedings of the 31st ieee acm international conference on automated software engineering pp.
.
c. chen z. xing y .
liu and k. l. x. ong mining likely analogical apis across third party libraries via large scale unsupervised api semantics embedding ieee transactions on software engineering .
c. chen similarapi mining analogical apis for library migration in ieee acm 42nd international conference on software engineering companion proceedings icse companion .
ieee pp.
.
j. chen c. chen z. xing x. xia l. zhu j. grundy and j. wang wireframe based ui design search through image autoencoder acm transactions on software engineering and methodology tosem vol.
no.
pp.
.
c. chen s. feng z. xing l. liu s. zhao and j. wang gallery dc design search and knowledge discovery through auto created guicomponent gallery proceedings of the acm on human computer interaction vol.
no.
cscw pp.
.
c. chen s. feng z. liu z. xing and s. zhao from lost to found discover missing ui design semantics through recovering missing tags proceedings of the acm on human computer interaction vol.
no.
cscw2 pp.
.
l. nie h. jiang z. ren z. sun and x. li query expansion based on crowd knowledge for code search ieee transactions on services computing vol.
no.
pp.
.
m. lu x. sun s. wang d. lo and y .
duan query expansion via wordnet for effective code search in proceedings of ieee 22nd international conference on software analysis evolution and reengineering .
ieee pp.
.
m. m. rahman c. k. roy and d. lo automatic query reformulation for code search using crowdsourced knowledge empirical software engineering vol.
no.
pp.
.
m. m. rahman and c. roy effective reformulation of query for code search using crowdsourced knowledge and extra large data analytics inproceedings of ieee international conference on software maintenance and evolution .
ieee pp.
.
s. haiduc and a. marcus on the effect of the query in ir based concept location in proceedings of ieee 19th international conference on program comprehension .
ieee pp.
.
s. haiduc g. bavota r. oliveto a. marcus and a. de lucia evaluating the specificity of text retrieval queries to support software engineering tasks in proceedings of 34th international conference on software engineering .
ieee pp.
.
s. haiduc g. bavota r. oliveto a. de lucia and a. marcus automatic query performance assessment during the retrieval of software artifacts in proceedings of the 27th ieee acm international conference on automated software engineering pp.
.
s. haiduc g. bavota a. marcus r. oliveto a. de lucia and t. menzies automatic query reformulations for text retrieval in software engineering in proceedings of 35th international conference on software engineering .
ieee pp.
.
s. haiduc g. de rosa g. bavota r. oliveto a. de lucia and a. marcus query quality prediction and reformulation for source code search the refoqus tool in proceedings of 35th international conference on software engineering .
ieee pp.
.
m. m. rahman and c. k. roy quickar automatic query reformulation for concept location using crowdsourced knowledge in proceedings of 31st ieee acm international conference on automated software engineering .
ieee pp.
.
z. li t. wang y .
zhang y .
zhan and g. yin query reformulation by leveraging crowd wisdom for scenario based software search in proceedings of the 8th asia pacific symposium on internetware pp.
.
g. chen c. chen z. xing and b. xu learning a dual language vector space for domain specific cross lingual question retrieval in 31st ieee acm international conference on automated software engineering ase .
ieee pp.
.
m. j. howard s. gupta l. pollock and k. vijay shanker automatically mining software based semantically similar words from commentcode mappings in proceedings of 10th working conference on mining software repositories .
ieee pp.
.
m. m. rahman and c. k. roy improved query reformulation for concept location using coderank and document structures in proceedings of 32nd ieee acm international conference on automated software engineering .
ieee pp.
.
r. sirres t. f. bissyand d. kim d. lo j. klein k. kim and y .
le traon augmenting and structuring user queries to support efficient free form code search empirical software engineering vol.
no.
pp.
.