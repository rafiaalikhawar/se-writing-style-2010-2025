unchartit an interactive framework for program recovery from charts daniel ramos inesc id ist u. lisboa lisboa portugal daniel.r.ramos tecnico.ulisboa.ptjorge pereira inesc id ist u. lisboa lisboa portugal jorge.m.s.pereira tecnico.ulisboa.ptin s lynce inesc id ist u. lisboa lisboa portugal ines.lynce tecnico.ulisboa.pt vasco manquinho inesc id ist u. lisboa lisboa portugal vasco.manquinho tecnico.ulisboa.ptruben martins carnegie mellon university pittsburgh usa rubenm andrew.cmu.edu abstract chartsarecommonlyusedfordatavisualization.generatingachart usuallyinvolvesperformingdatatransformations includingdata pre processingandaggregation.thesetaskscanbecumbersome andtime consuming evenforexperienceddatascientists.reproducingexistingchartscanalsobeachallengingtaskwheninformation about data transformations is no longer available.
in this paper we tackle the problem of recovering data transformations from existing charts.
given an input table and a chart our goalistoautomaticallyrecoverthedatatransformationprogramunderlying the chart.
we divide our approach into four steps data extraction candidate generation candidate ranking and candidate disambiguation.
we implemented our approach in a tool called unchartit and evaluated it on a set of benchmarks from kaggle.
experimental results show that unchartit successfully ranks the correct data transformation among the top programs in of the benchmarks.
to disambiguate the top ranking programs weuseournewinteractiveprocedure whichsuccessfully disambiguates of the ambiguous benchmarks by asking on average fewer than questions to the user.
ccs concepts software and its engineering keywords recovering data transformations from charts program synthesis interactive disambiguation acm reference format danielramos jorgepereira in slynce vascomanquinho andrubenmartins.
.unchartit aninteractiveframeworkforprogramrecovery from charts.
in 35th ieee acm international conference on automated software engineering ase september virtual event australia.
acm newyork ny usa 12pages.
ase september virtual event australia copyright held by the owner author s .
acm isbn .
introduction in the last decade data analysis has become one of the most importanttoolsfororganizationstodrivetheirdecisions.thehuge demandfordomainexpertshasledmanydataanalystswithlimited programming knowledge to be recruited.
thus in the last years severaltools havebeendevelopedtoaidinexperienced analysts in automating some programming tasks.
these toolswork byexample theuser providesaset ofinput outputexamples and the tool finds a program that maps the inputs into the output.
ho wever the development of tools that work directly with visual elements has remained unexplored.
hence if a user prefers to express his intent through visual elements e.g.
providing an inputtableandabarchart thereisnotoolthatisabletoreverse engineer the necessary data manipulations in order to reproduce it.
in this paper we propose unchartit a tool for reverse engineeringthenecessarytablemanipulationstogenerateagivenchart.
note that to the best of our knowledge this is the first tool for automaticgenerationofdatamanipulationsthatdirectlyusesvisual elements.in this work we consider thatthe user canprovide the image of a bar chart and the raw data from which the chart wasgenerated.althoughweonlyconsiderbarcharts oneofthe most common chart types the proposed ideas can be easily generalizedtoothertypesofchartsorgraphicalelements.moreover wealsoaddresshowtoautomaticallyextractthenecessary information from the chart how to adapt program synthesis tools tothisnewchallengingproblem aswellashowtodisambiguate several programs while minimizing user interactions.
furthermore experimental results on real world instances from kaggle show that unchartit is able to reverse engineer how to build the chart presented by the user.
specifically the correct data transforma tionprogramisrankedamongthetoptenprogramsreturnedby unchartitin92 oftheinstances.toselecttheuser sintended programfromthetoptenrankedprograms unchartitinteracts with the user by asking either yes or no questions or multiplechoicequestions andsuccessfullyreturnsthecorrectprogramin of the ambiguous instances.
this paper makes the following main contributions the first fully automated tool called unchartit that synthesizes table manipulations from bar charts.
automated input generation methods to disambiguate a set ofprogramsthatminimizethenumberofuserinteractions.
35th ieee acm international conference on automated software engineering ase this work is licensed under a creative commons attribution international .
license.
date received product ... mortgage ... mortgage ... credit reporting ... student loan ... debt collection ... credit card ... credit card ... debt collection ... a sample of the consumer complaints table .39mb .
.
.
.
.
year complaints b bar chart with yearly number of consumer complaints.
figure consumer complaints data from to .
experimentalresultsonreal worldbenchmarksthatshow the success of the proposed approaches.
thepaperisstructuredasfollows section2definestheresearch challenge and motivates the problem with a concrete example.section addresses the problem of data extraction from visual elements and section explains the necessary changes to program synthesizers to solve this new research problem.
next section addresses how to rank the programs generated by the synthesizer.
section proposes new models on how to disambiguate the top n rankedprogramsfortwodifferentuserinteractionmodels.section7presentstheexperimentalresultsonasetofrealdatafromdifferent domains.
section briefly reviews related work.
finally the paper concludes in section .
motivation considerthesampleoftheconsumercomplaintsdatabaseshown in figure 1a.
the database contains complaints submitted to theconsumer financial protection bureau between and .
figure1bshowsabarchartwiththenumberofcomplaintsreceived in each year.
suppose that alice a data analyst with low programming skills needs to elaborate a report on an updated version of the consumer complaints database.1as a reference she received an old report written by a former employee.
this report contains a variety of charts includingfigure1b butnottheprogramsfromwhichthe chartsoriginated.therefore alice staskistorecovertheprogramsnecessarytoreproducethereport scharts.ifalicehastheprograms to generate the charts she can update them whenever new data is added to the database.
in this paper we describe unchartit a new tool that can automaticallyrecoveraprogram froma givenchartfor people like alice.
to recover a program from a chart alice needs to provide the raw data from which the chart originated and an image of the chart.figure2illustratestheunchartitarchitecture.givenapair data chart unchartitstartsbyextractingdatafromthechart thereby creating a tabular representation of the chart.
since this step involves automatically interpreting a chart the resulting table is prone to contain imprecisions.
for instance from the chart of the bar chart of figure 1b.
col0 col1 bar02345.
bar172255.
bar2108303.
bar3153090.
bar4168929.
bar550954.98table real table inherent tothebarchartoffigure1b.
year complaints figure1b unchartitgeneratestable1.incontrast table2contains the real table underlying the chart of figure 1b.
note that the numericaldataoftheextractedtableisimpreciseandthebarlabels are missing.
afterobtainingatabularrepresentationofthechart unchartit starts the candidate program generation step.
during this stage unchartitusestwomajorcomponents theprogramgenerator and theprogramdecider.theprogramgeneratorenumeratescandidate programs and provides them to the program decider.
the programdecider evaluatesthe candidateprograms decidesif they are good candidates and provides feedback to the program generator.notethattheprogramdeciderdoesnothaveaccessto the real table underlying the chart but rather to an approximation of the real table extracted from the chart image.
therefore the program decider cannot simply discard candidates because they do not map the raw input data into the imprecise table it extracted in the previous step.
instead it decides to keep or discard candidates usingaweakercriterion acandidateprogramiskeptifandonly if its output on the input data has the same number of rows andcolumnsastheextractedtable.forexample usingtheconsumercomplaintsdatafromfigure1aandtheextractedtableshownin table1 unchartitfinds7differentprogramswhoseoutputonthe inputdatahasthesamestructureastable1 6rowsand2columns .
after generating a pool of candidates unchartit assigns each candidate program a score using a cost function and ranks the programs according to their costs.
since it is possible that the bestranking program does not correspond to the program the user 176data extraction candidate generation candidate ranking ... candidatesprogram disambiguation optional q1.
consider the input table is the following chart correct?
y n q2.
consider the input table select the correct output input data top n candidatesoutput chartprogram program deciderprogram generatorcandidate feedback noisy output data figure unchartit architecture.
consider the following input table date received date sent q is the following output table chart correct?
y n yr count yrcount figure user interaction example.
desires unchartit gives the user the option to answer a series of questions in order to disambiguate the top nprograms of the rank.inparticular unchartithastwodifferentuserinteraction models to disambiguate programs.
in the first interaction model unchartitaskstheusertopickthecorrectoutput fromasetof options for a given input.
in the second interaction model unchartit asksthe userif agiventest caseis correctornot yes no question .
in both approaches unchartit automatically generates small test cases that minimize the number of user interactions.
for example after enumerating the different candidate programs for the specification given by the pair figure 1a figure 1b unchartit only needs to ask the user questions before returning the correct program using the yes no interaction model.
figure illustrates the user interaction in the yes no interaction model.
given a small intput table automatically generatedby unchartit the user just needs to confirm if the given chart correspondstothecorrectoutput.thisexamplecorrespondstothe last question of the user interaction for the problem in figure and the returned program is shown in figure .l1 df mutate date mdy date received l2 l1 mutate yr year date l3 l2 group by yr l4 l3 summarise count n l5 l4 ggplot aes x yr y count geom col figure program returned by unchartit for the instancegiven by figure after the interaction of figure .
data extraction thefirststepinourpipelinerequiresustotransformthechart s imageintoastandardtabularrepresentation e.g.
transformingthe chart of figure 1b into table .
this is a crucial step because there can be many different ways of depicting the same information.
by transformingthechartintoastandardtabularrepresentation we canbuild asimpler validationmechanism todecide thesuitability of candidate programs to the given specification.
let tedenote the tableextractedfromthechart.givenaprogram pthatoutputsa tabletpwhenpisexecutedontheinputdata thenwecancompare teagainsttpin order to evaluate the quality of program p. in this section we focus on extracting data from bar charts.
nevertheless thetechniquesdiscussedherecanbeadaptedtoworkwithother chart types.
.
webplotdigitizer webplotdigitizer is one of the most prominent tools for manual and automatic extraction of data from charts.
in particular webplotdigitizer can automatically extract numerical data from simple2dbarcharts i.e.
withoutstackedandgroupedbars .to extractdatafromabarchart webplotdigitizerrequires3sets of parameters the chart s image the pixel location of twodifferent points p1 p2 over the continuous axis along the bars and their corresponding values on that axis figure shows an example the width in pixels of the bars x and the height in pixels of the highest bar val .
webplotdigitizercombinesthesesetsofparameterstoextract thenumericaldatafromthecharts butitdoesnotextractthelabels of the bars.
177figure5 firststepof webplotdigitizer saxiscalibration.
webplotdigitizer uses p1 and p2 to find the value of any point on the axis by performing a linear interpolation.
.
neural data extraction analternativeapproachtotraditionalchartdigitizationalgorithms such as those employed by webplotdigitizer is to use machine learning.
toolssuch as revision andchartsense have previouslyusedmachinelearningalgorithmstodiscernbetween charttypes e.g.
decidingwhetheranimagecontainsabarchartor ascatterplot .however thesetoolsoftenrelyontraditionalalgorithms to extract data from the charts.
in this section we propose to leverage state of the art convolution neural networks cnns to retrieve data from bar charts.
cnns are known for their huge success in modern computer visionsystems.acomputervisionbenchmarkofparticularrelevance on which cnns shine is the imagenet challenge .
the purpose oftheimagenetchallengeistoassesstheperformanceofalgorithms on classification and object detection tasks.
the efficientnet b7 fulfills the current state of the art performance on imagenet challenge.
the efficientnets are a family of eight cnns ranging fromefficientnet b0toefficientnet b7.the x inefficientnet bx indicatesthenetwork scomplexity thehigherthe x themore complex the network is.
ourgoalistoleveragethearchitectureofoneoftheefficientnets byreplacingitsoutputlayerwithacustomlayerthatsuitsourtask.
oneimportantpieceofinformationthatouradaptedefficientnet shouldextractisthenumberofbarsofagivenchart.toretrievethisinformation weadd nnodestothenetwork soutputlayer eachone representingtheprobability thatthegiven charthas i ... n bars.toachieveaprobabilitydistribution the nnodesuseasoftmax activation function i z exp zi summationtext.1n j 1exp zj i ... n z irn where i z istheoutputofthe i thnode indicatingtheprobability that the given chart has ibars.
we extract the number of bars of a given chart by taking the argmaxof the obtained probability distribution y argmax i ... n i z besidesthenumberofbars weshouldalsoretrievethebars heights.
we can do this by adding nmore nodes to the network s outputlayer nodes n 1t o2n with the following activation functions pi x max min x i n n ... 2n wherepiis the output of the i th node and it indicates how full is thei n thbarwithrespecttothemaximumpossibleheight pi meansthatthe i n thbarisfull and pi 0meansthei n thbar is empty .
using the height of each bar we calculate its value by betweentheaxismaximumandlowest values yi braceleftbigg l pi n h l if i y otherwise where yiis the value of i th bar his the axis maximum value and lis the axis lowest value.
handlare both user provided inputs.
similarly to webplotdigitizer we do not extract the labels of eachbar.finally totrainthenetwork weminimizethesumofa categorical cross entropy loss nodes to n witha mean squared error nodes n 1t o2n .
program synthesis after extracting the table from the chart unchartit starts searchingforcandidateprogramsthatcanpotentiallytransformtheinput table into the table described by the chart.
this problem can beseen as a program synthesis problem where the goal is to find a program that satisfies a given specification.
program synthesis has beensuccessfullyusedinmanyapplications e.g.
stringmanipulations list manipulations and table transformations as well as in commercial applications e.g.
flash fill feature in microsoft excel .programming by example pbe synthesis isthemostcommonapproachforprogramsynthesis wherethesynthesizertakesasspecificationasetofinput output examplesandsearchesforaprogramthatmapseachinputtothe corresponding output.
in our case since the extracted table in the previous step is only an approximation of the real table underlyingthe chart we cannot use this criterion to accept or reject programs.
unchartit modifies the open source trinity synthesis framework totackletheproblemofrecoveringdatatransformations from charts.
the synthesis process used in unchartit is very similartotheoneproposedformorpheus .first wecreated a domain specific language dsl for the data transformationdomain.notethatadslisjustausefulintermediaterepresentationfortheprogramthatabstractsfromsomesyntacticdetailsof theprogramminglanguage.however thereisadirectcorrespondencefromthedslsymbolstotermsintheprogramminglanguage syntax.
the syntax of a dsl is described through a context freegrammar g v r s wherevis a finite set of non terminal symbols isafinitesetofterminalsymbols risafiniterelation fromvto v called the production rules and sis the start symbol.
each terminal symbol is either a function a variable a constant or a special character e.g.
parenthesis or comma .
each production rule rcorresponding to a function is represented in form a0 a1 a2 ... an where is a function anda1 a2 ... an vare its arguments.
a program is a string p v such thats p. 178example .
.
the following grammar represents a subset of the dsl used by unchartit.
tab summarize tab opt col group by tab col x0 tab count tab top n tab col bottom n tab col opt mean median sum col ... where summarize group by count top n and bottom n arefunctions of the dplyr library for r andx0represents the program s input.
summarize group by x0 mean isanexampleofaprogram in this dsl.
this program groups all the lines with the same first column representation and for each group it computes the mean of the numerical values in the second column.
ourfulldslhasextraprimitivestosupportcommontabletransformationsforbarcharts.forinstance itallowscleaningdataby removing empty cells supports ordering the values in a column normalization of values and extraction of data within a given date.
our dsl is functional thus our programs do not contain loops.
second we wrote logical specifications for each library function inourdslusingaspropertiesthenumberofrows columns and groups.
these specifications are a complement to the dsl and describe the relation on thenumber of columns rows and groups betweentheinputandoutputtableafterusingalibraryfunction.
unchartitcanthentakeadvantageofthepruningandlearning techniquesimplementedintrinityandpruneequivalentinfeasible programs that share the same logical specifications.
example .
.
consider the function summarise .
this function aggregates the data in each group which is composed by a set of rows.
let r summarise a mean be the output of running summarise ontable a.foranyexecutionof summarise weknow that the number of columns of the resulting table rwill be at most thenumberofcolumnsintable a.moreover thenumberofrows and groups in table rwill equal the number of groups in table a. hence we can write the following logical specifications that describetherelationonthenumberofcolumns rowsandgroups between table rand table a columns r columns a rows r groups a groups r groups a third since our output table has numerical imprecisions we modified the search of the program synthesizer to enumerate allprograms within a time limit that have an output table with thesame number of rows and columns as the extracted table.
even thoughtheextractedtablehasnumericalimprecisions theshape ofthetableisusuallycorrect.insteadofselectingasingleprogram unchartit maintains a list of programs that satisfies the row and columnconstraints.allprogramsarerankedusingthemetricsfrom section .
ranking candidate solutions in order to rank the generated candidates we assign a cost to each program the highest ranking program is the program with the lowest cost.
in this section we present two possible cost functions to rank the candidate programs.table re scaled extracted table.
col0col1 bar10.
bar20.
bar30.
bar40.
bar50.
bar60.2306table re scaled output table.
year complaints .
.
.
.
.
.
recall that the data extraction mechanisms described in section do not extract labels only the bar values.
thus we only consider thenumericaldataextractedfromthecharttocalculateaprogram scost.weproposetomeasurethequalityofprogramsbycomparing the extracted bar values to those of the program output.
before calculatingthecostoftheprogram were scalethebarvaluesusing theaxismaximumandminimumvaluesofthechart.thisscaling allows us to have a standardized range of costs independent of the chart sscale.were scaleeachbartoavaluebetween0and1using the following function f y y l h l wherehandlare the axis maximum and minimum values respectively.
two possible cost functions are the mean absolute error mae and the mean squared error mse .
mae nn summationdisplay.
i f yi f yi mse nn summationdisplay.
i f yi f yi wherenis the number of bars yiis thei th bar value of the program soutput and yiisthei thbarvalueobtainedfromthedata extraction mechanism.
example5.
.
considerarecoverytaskwherethedataextraction mechanismgeneratestable1onthechartoffigure1b.consider also that a candidate program outputs table when applied to the inputdata.tocalculatetheprogram scostwestartbyre scaling thebars values.inthiscase thechart smaximumandminimum values areh .
105andl respectively.
thus using there scalingfunction wegettables3and4.usingthemean absoluteerrorfrom theprogramwouldhavethefollowingcost mae parenleftbig .
.
.
.
.
.
.
.
.
.
.
.
parenrightbig .
in order to rank the candidates the cost of each program is calculatedandthecandidatesareordered.iftwodifferentprograms have the same cost the smaller program2is ranked higher.
2aprogram p1isconsideredsmallerthanaprogram p2ifp1usesfeweroperators from the dsl than p2.
int main int a read a0 int b read b0 int c c0 if a b a0 b0 c1 c0 c a0 b0 c1 c0 return c op c1 figure symbolic representation of a program in c. program disambiguation the proposed ranking functions are helpful in selecting promising candidateprograms.however insomecases thehighestranked program is not the desired solution.
therefore given the top n ranked programs we propose to interact with the user in order to select a program that corresponds to the user s intent.
this section starts by briefly reviewing satisfiability modulo theories smt and how smt can be used to formalize a symbolic executionofaprogram.next twodifferentuserinteractionmodels are presented.
for each interaction model we formalize how to automatically generate an input test case that differentiates among the candidateprograms.finally we refer how fuzzingtechniques can also be used to this end.
.
satisfiability modulo theories the satisfiability modulo theories smt problem is a generalizationofthewell knownpropositionalsatisfiability sat problem.
givenadecidablefirst ordertheory t at atomisagroundatomic formulain t.at literaliseithera t atomtoritscomplement t. at formulaissimilartoapropositionalformula buta t formula is composed of t literals instead of propositional literals.
given a t formula the smt problem consists of deciding if there exists a total assignment over the variables of such that is satisfied.
depending on the theory t the variables can be of type integer real boolean among other domains.
themaximum satisfiabilitymodulo theories maxsmt isthe optimizationversionofthesmtproblem.inmaxsmt thegoalis to find an assignment that optimizes a given objective function such that an smt formula is satisfied.
in the literature maxsmt is sometimes definedovera setof hardand softformulas .however it can also be defined as optimizing an objective function .
for ease of understanding we use the latter formalization.
.
symbolic representation of programs symbolic execution is a technique that allows executing a program withsymbolicvaluesinsteadofconcretevalues.inessence givena program p one can build an smt formula pthat represents the symbolic execution of p. hence prepresents all possible executions of program pwhen all possible input values are considered.
example6.
.
considertheprogram pinfigure6withtwoinput variables aandb .togenerateansmtformulatorepresentthe symbolic execution of p we start by converting the program to a staticsingleassignment ssa form.inssaform anewvariableiscreatedforeachassignmentintheprogram.forexample since variablecisassignedtwice lines4and7 wecreatetwoinstancesof c c0 andc1 usedtorepresentthevalueof caftereachassignment.
moreover each input is assigned a symbolic value a0 and b0 .notethatthesymbolicvalues and representallpossible values that can be assigned to aandb respectively.
finally we build the smt formula that represents the program s execution flow.
for program pthe formula is as follows p a0 b0 c0 a0 b0 c1 c0 a0 b0 c1 c0 op c1 symbolic execution is often used to check a given property of a program.let pbeaprogramand opdenotesthesymbolicrepresentation of the return value of p. it is possible to check if there is anexecution of pthatreturns 0by usingan smtsolver tocheck the satisfiability of ret0 where ret0 p op .
observe thatifthesmtsolverfinds ret0tobeunsatisfiable thenthereis no inputof psuch that preturns .otherwise ifthe smt solver provides a satisfying assignment for ret0 then the assignment to thesymbolicrepresentationoftheinputsof pcontainstheconcrete input values i.e.
the input test case for when preturns .
symbolicexecutioncanalsobeusedtodifferentiatebetweentwo programs p1andp2.let pibethesmtformulathatcorresponds tothesymbolicexecutionofprogram pi.letiirepresenttheinput an output of pi.
hence we can built a formula eqsuch as eq p1 p2 i1 i2 o1 o2 observe that if eqis satisfiable then there is an input test case for whichp1andp2providedifferentoutputs.asaresult onecanask theusertoanswerwhichisthecorrectoutputanddisambiguate betweenp1andp2.
otherwise if eqis unsatisfiable then there is no input test case that differentiates between p1andp2and the programs are deemed equivalent.
.
user interaction models unchartitisabletorankcandidateprograms butthebestranked programmightnotcorrespondtotheuser sintent.moreover itcanoccurthattherankingvalueisthesamefortwodifferentprograms.
hence our goal is to interact with the user in order to correctly select the desired program among the top ranked candidates.
in unchartit we define two different user interaction models.theoptionsmodelshowstheuseraninputtable aswellas several output options corresponding to the output of candidate programs for that input table.
in this case the user selects the correctoutputamongtheseveraloptions.iftheselectedoutputstill correspondstotheoutputofseveralcandidateprograms additional roundsofquestionsareperformedtodisambiguatesolelyamong those programs.
in the options model ideally there is a single inputtable suchthateach candidateprogramproduces adifferent output.
in this best case scenario a single question is sufficient to disambiguateamongthecandidateprograms.ontheotherhand theoptionsmodelrequirestheusertosolvetheproblemforthe given input table in order to select the correct option.
180min.n summationdisplay.
i 1n summationdisplay.
j i 1bij s.t.
p1 ... pn i j ..n i j ii ij i j ..n i j oi oj bij n logicalordisplay.
i 1n logicalordisplay.
j i bij figure input generation for the options model.
unchartit also implements the y n user interaction model.
in thiscase theuserispresentedwithaninputtableandanoutput.
next theuseranswersyesorno dependingiftheoutputiscorrect for that input table.
note that the user only needs to check the correctness of a single output option.
in the y n model the goal is to split the set of candidate programs in two such that the output ofhalfthecandidateprogramsmatchestheproposedoutput while theotherhalfproducesadifferentoutput.ifitisalwayspossible to split the set of programs in two the number of questions in the y n interaction model would be o lg n .
.
model formalization section .
presented the options and the y n user interaction modelsimplementedinunchartit.inthissection weproposetwo maxsmt formalizations that allow us to automatically generate input examples for both user models.
in the options user model in order to minimize the number of userinteractions thegoalistofindasmallinputtestcasesuchthat allthetop nrankedprogramsprovideadifferentoutput.figure7 presents a maxsmt formulation to solve the problem of finding an input that maximizes the pairwise differences between the n programstodisambiguate.inthisformula weencodethesymbolicrepresentationofall ncandidateprograms andforcetheinputof allprogramstobethesame .moreover foreachpairofprograms piandpjwecreateabooleanvariable bijthatisassignedto1if and only if the outputs of programs piandpjare the same .
note that inputs that do not differentiate any pair of programs are excluded .sincethegoalistominimizethenumberofvariables bijassignedto1 anyoptimalsolutionofthisformulationwill findanassignmenttotheinputvariables ii correspondingtoan inputtestcase thatmaximizesthepairwisedifferencebetweenthe nprograms.
ideally the solution for the formulation in figure contains all variables bijassigned value .
on the y n interaction model the goal is to identify an input testcaseisuchthatthesetof nprogramsissplitintotwosets a andbwith halfprograms in eachset.
moreover fortest case i all programs pi awould provide the same output pi i and all programs pj bwould provide a different output i.e.
pi i pj i than the programs in a. figure8containsaformulationthatsplitsagivensetof nprogramsintotwosets aandb .asinthepreviousmodel thisformulation includesthe symbolicrepresentation ofall nprograms theprograminputsareconstrainedtobethesame andbooleanmin.
barex barex barex barex barexn summationdisplay.
i 1pa i n summationdisplay.
i 1pb i barex barex barex barex barex s.t.
p1 ... pn i j ..n i j ii ij i j ..n i j oi oj bij i j ..n i j bij parenleftbig pa i pa j pb i pb j parenrightbig i j ..n i j bij pa i pa j i ..n pa i pb i n summationdisplay.
i 1pb i n figure input generation for the y n model.
variablesbijare assigned to if and only if the output of program piis equal to the output of program pj .
additionally for each program pitwo new boolean variables are created pa iandpb i denoting if program pibelongs to set aor to setb respectively.
inourformulation iftwoprograms piandpjproducethesame output then they both have to be assigned to the same set .
moreover if two programs piandpjproduce different outputs i.e.
variable bijis then at most one of them can be in set a .
therefore asaresultofconstraints and allprogramsin setamustproducethesameoutput.furthermore eachprogram must be assigned to one and only one set .
constraint is used to make sure that if there is an input that differentiates among programs then not all programs are assigned to set band a partitionisproduced.finally ourformulation sgoalistominimize the difference between the number of programs in each set .
.
input constraints inthesymbolicrepresentationofaprogram eachinputisassociated withasymbolicvaluethatrepresentsanarbitraryconcretevalue thatcanbeassignedtothatinput.sincetheinputsofourprogramsare tables each symbolic value represents a table with a number ofrowsandcolumns.however allowinginputtableswithanarbitrarystructurecanbeaproblem.forinstance itwouldnotbefeasibleto ask the user to verify or select the correctoutput for a large input table.therefore weimposerestrictionsonthestructureoftheinput tables we allow in the symbolic representation of our programs.
in our case the columns are restricted to those that are relevant inat least one of the programs to disambiguate.
for instance if we want to disambiguate programs that only use the first and the lastcolumnsoftheinputtable thentheinputtabletobegeneratedonlycontainsdataforthose2columns.moreover sincewewanttoobtainsmallinputtables thenumberofrowsmustalsobebounded.
thetable scontentmustalsoberestrictedsinceeachtableentry should be associated with a meaningful value to the user.
for instance iftheuserexpectsagivencolumntocontaincountrynames then the only concrete values we should allow on that column are country names.
in order to generate inputs that are familiar to the user we base our distinguishing inputs on the input table the user 181provided.
in unchartit the following rules are used to decide theavailablevaluesforeachcolumn a incolumnsofstringswe restricttheavailablevaluestothosepresentintherespectivecolumn of the input table b in columns of integers floats and dates we restrict the values to the interval between the minimum and maximum values of the respective column of the input table.
.
input generation the maxsmt formulations proposed in section .
give us a theoretical guarantee that the resulting distinguishing input is the best possible input for the respective interaction model.
however an issue with both approaches is that our maxsmt formulas growexponentially with the number of programs to disambiguate.
in scenarios where it is necessary to disambiguate a large number of programs one mightsacrifice optimalityin orderto haveameaningful user interaction.
thereisaplethoraofinputgenerationmethodscommonlyused for program testing .
for example in the context of unchartit onecouldapplydeltadebugging ontheexampleinputtable to try to generate a smaller input table that would differentiate the programs.
however the input tables provided in our test cases can be very large resulting in a very time consuming procedure.
anotheralternativeistousefuzzing basedmethods .instead of building a maxsmt formula we can generate random inputs guidedby theexample inputtable until wefindan optimalsolution for a given interaction model or a time limit is reached.
for example usingtheoptionsinteractionmodel wecanrandomly generateinputsuntilanexamplethatdisambiguatesallprograms is found.
otherwise if atime limit is reached the generated input thatsplitstheprogramsinalargernumberofsetsisreturned.in unchartit this technique was also implemented as a stand alone method to disambiguate programs.
moreover a hybrid method was also developed that first applies fuzzing based techniques and then applies the proposed maxsmt models when the number of programs to disambiguate is small.
experimental results in order to evaluate our approach we collected benchmarksfrom kaggle 3a popular website for data scientists with diverse open datasets.
each benchmark is comprised of a pair table barchart .
the experimental results presented in this section aim to answer the following research questions q1.howeffectivelycanunchartitrecoverprogramsfromreal data?
q2.how long do we have to explore the search space to find good candidates?
q3.how does the neural network approach compare to the webplotdigitizer s approach?
q4.how many questions do we have to ask the user in orderto distinguish the best ranking programs using the two interaction models?
the results described herein were obtained from an intel r xeon r cpu e5 v2 .60ghz with 64gb of ram running debian gnu linux .
unchartitintegratesseveraltoolsandtechnologies.
in particular our neural data extraction mechanism is implementedusingthekerasframework .furthermore ourcandidategeneratorisimplementedontopofthetrinitysynthesis framework .whilethecandidategeneratorusesthe rlanguage version .
.
the program disambiguation is performed in c. for that allofourdsloperatorshaveanequivalentimplementation incso that the symbolic representation of the programs can be generated using cbmc a bounded model checker for c. since cbmcgeneratesbooleanformulas thefinalmaxsmtformulaonlycontainsbooleanvariables.asaresult theopen linsbps solver was used instead of a generic maxsmt solver.
finally the number of rows of the generated input tables was bounded to .
benchmarks.
the average and median size of the input table filesis16.52mband1mb respectively.however therearemuch largerinstancesinourbenchmarkset.themotivationalexample in section has one of the largest input tables con taining .39mb 437rows and columns.
moreover the median number of rows and columns is 841and respectively whereas the mean number of rows and columns is .92and .
respectively.
regarding the bar charts the number of bars of eachchartvariesbetween2and15bars.everysolutioninvolvesgrouping the data by some column and then summarizing each groupusinganaggregatefunction e.g.
median minormax .some solutions require operations such as calculating the days between two dates or filtering nullvalues.
it might also be necessary to normalizethevaluesofanumericalcolumn orselectingonlythe top ranking rows.
dataextraction.
whenevaluatingadataextractionprocedure for bar charts we must consider its two outputs the number ofbars and the bars values.
thus to measure its accuracy we usetwo metrics the percentage of plots in which the procedure successfullyretrievedthenumberofbars andthemeanabsoluteerrorof the bar s values.
to test both webplotdigitizer and the neural network we used the bar charts of the benchmarks.
recall that webplotdigitizer requires a considerable amount of input.
before extracting the bars values it is necessary to mark the pixel location of two different points along the vertical axis of eachbarchartandthevaluesoftherespectivepoints.webplotdigitizer sbarextractionalgorithmalsorequirestuningparameters before extracting the bars.
it was found that the parameters that worked best with our benchmarks were x and val .
using these parameters webplotdigitizer successfully retrieved the number of bars in of the instances and achieved a mean absolute error of .
.
toevaluatetheaccuracyoftheneural baseddataextraction we trained an adapted version of the efficientnet b1.
we generateda set of 000bar charts of various forms and split it into training andvalidation sets.totrainthenetwork weused radam coupled with lookahead using the default parametersoftherespectivepapers.weusedbatchsizesof 15andamaximumnumberofepochsof100 butweperformedearlystopping oncethevalidationlossstoppeddecreasing.onthebenchmarks efficientnet b1retrievedthe correctnumberofbars in ofthe instances.
considering the mean absolute error the network has a timeout min instances solved top top top top figure success rate with different timeouts using webplotdigitizer and the mae ranking.
table success rate for a time limit of minutes.
webplotdigitizer efficientnet b1 mae mse mae mse top top top top meanabsoluteerrorof0 .
.althoughtheadaptedefficientnetb1 is not as accurate as webplotdigitizer it is important to note that it requires significantly less input from the user.
candidate generation and ranking.
since it is not feasible to explore the whole program space unchartit terminates whena given time limit is reached.
in figure we show the success rate for different timeouts.
the top top top and top lines showthenumberofbenchmarksinwhichthecorrectsolutionwas rankedfirst top amongthefirstthree top five top and ten top programs respectively.
we can see that unchartit performsbestwhenusingatimeoutof3minutes anditdoesnot improvethereafter.infact thepercentageofcorrectprogramsin top decreases with higher time limits.
this occurs due to the fact that ifwe explore the searchspace longer weare more prone to finding programs that overfit to the cost function especially programswithahighnumberoflines .moreover theremightbe other programswith more linesof codethat are equivalentto the overfitting e.g.
adding a filter operation that does nothing on the inputtable .sincethesespuriousprogramshavethesamecostof theoverfittingprogram theypushthesolutiondownwards.overall unchartit is able to find programs up to lines of code within the time limit which is the same order to magnitude as other state of the art tools for table manipulation .table shows the success rate with a timeout of minutes using the two data extraction mechanisms and the two ranking functions.wecanseethatbothrankingfunctionsperformsimilarly regardless of the data extraction mechanism.
the correct solution is the top ranked program in of the instances when using webplotdigitizer and the mae ranking function.
using the adaptedefficientnet b1neuralnetworkweobtainslightlyworse results.nonetheless wecanstillrankthecorrectsolutiononthe top in of the instances.
when using webplotdigitizer this value increases to .
recall that webplotdigitizer is moreprecisethanefficientnet b1withrespecttothenumericalextracted values and number of extracted bars.
however efficientnet b1 is a fully automated process while webplotdigitizer needs the user toindicatethepreciselocationoftwopixelsinthechartimageand tune some parameters before extracting data.
inthebestperformingapproach webplotdigitizer mae there are instances in which a correct solution was not ranked among the top .
these benchmarks correspond to instances in whichthenumberofbarswasincorrectlyextractedand2instances in which minutes is not sufficient to find a correct candidate.
program disambiguation.
to ascertain that unchartit returns a correct program the top ranking programs are to be disambiguatedbyinteractingwiththeuser.unchartitintegratestwo interaction schemes the options and the y n model.
for each model questions can be generated using the following approaches maxsmt fuzzing hybrid approach.
in the hybrid approach we combine fuzzing and maxsmt as follows if we need to disambiguatemorethan5programs thenweusefuzzing.otherwise we use maxsmt.
in our experiments we consider the top programs using webplotdigitizer generated foreach instance.
fromthe50instances weconsider48instances sinceforoneinstance we only generated one candidate and there was another instance for which we did not generate a single candidate.
figure shows the average time necessary to generate the best possible question with a timeout of minutes per question.
we canseethatwhenusingfuzzing weeitherfindthebestquestion veryquickly orwecannotfinditwithinthetimelimit.inthe optionsmodel fuzzingcanonlystopearlywhenitfindsaninputtest caseforwhichallprogramsprovideadifferentoutput.however thatinputtestcasemightnotexist.thesameoccursforthey nmodel where an input test case that splits the set of programs inhalfmightnotexist.however theproposedmaxsmtformulation is able to detect these cases.
we can also see that the hybrid approachgeneratesquestionsfasterthanthemaxsmtapproach.
thishappensbecausetheformulasgeneratedbycbmcgrowexponentially with the number of programs to disambiguate.
thus the firstmaxsmtcallusuallytakesmuchlongerthantheremaining calls.however fuzzingisparticularlyeffectivewhenthenumber ofprogramsislarger.hence byusingfuzzinginthefirstcall we reduce the time necessary to generate the first question thereby reducing the average time to generate all questions.
table6 presentsstatisticsonthenumberofquestionsaskedto theuserusingthetwointeractionmodelsandthethreedifferent implementations.observethatwecandisambiguate47outofthe48instancesusingthehybridapproach.althoughtheaveragenumber instances solvedaverage time s maxsmt y n maxsmt options fuzzing y n fuzzing options hybrid y n hybrid options figure10 averagetimenecessarytogenerateaquestionusing the different interaction models and implementations.
table median x mean x standard deviation of the numberofquestionsasked.numberofinstancessolved n .
maxsmt fuzzing hybrid options y n options y n options y n x1 x1.
.
.
.
.
0. .
.
.
.
.
n43 of questions using fuzzing is slightly smaller fuzzing can only disambiguate42instances sinceitcannotprovetheboundedprogramequivalence.thus fuzzingpresentsinconclusiveresultstotheuser in instances.
the same happens to the maxsmt approach where sometimesthegiventimelimitisnotenoughtoprovetheprogram equivalence for the bounded input.
threats to validity.
since our tool is limited to bar charts our techniques maynot generalize forother typesof charts.for other typesofcharts thedataextractionstagemustbeadapted.however ifthedataextractionprocedurefromothercharttypesresultsin imprecisions similar to those found in bar charts one can expect a similar success rate.
the other issue is the simulation of the user interaction.
in this paper we assume the user would select the correct answer in each question.however itisnotclearhowdifficultitisfortheuserto answerthegeneratedquestions sinceanempiricalstudyofuser interaction was not performed.
additionally we bound the time limit to minutes in order to generate a question.
for tighter time limits themaxsmtsolvermightproduceasolutionthatisfarfrom optimal.
as an alternative an incomplete solver might be usedinstead.
in general incomplete solvers cannot prove optimality but are able to provide a good enough solution within tighter time limits.
related work in this section we briefly discuss prior work that is closely related toourapproach inthecontextofprogramverification program synthesis and interactive program synthesis.
.
program verification the goal of program verification is to formally prove that a certain specification or property holds for all executions of the pro gram.
the last few decades have seen a significant improvementin verification tools based on sat and smt .
in this work we leverage bounded model checking tools to either prove the equivalencebetweenprogramsorfindacounterexamplethatdisambiguatestheprograms.inourcontext sincethetablesforthe disambiguation phase are small it is possible to completely unroll all loops and check if programs are equivalent to a bounded input.
even though program equivalence of c programs has been studied before tothebestofourknowledgethisisthefirstapplication of it for disambiguation of programs written in a real world programming language in the context of program synthesis.
.
program synthesis programsynthesizersfortabletransformationsworkbycombining enumerative search and pruning techniques over a space of programsdefinedbyadsl.scythe generates sqlqueriesfrom examples and prunes the search using equivalence classes.
morpheus synthesizestabletransformationsforthe rlanguageand uses logical specifications for each library function combined with smt based reasoning to prune the search space.
neo generalizesmorpheustootherdomainsandincorporateslearningfrom failed synthesis attempts which further prunes the search space.
trinity is a program synthesizer framework that makes it easiertobuildnewprogramsynthesizerswhiletakingadvantageof pruning and learning techniques based on smt reasoning .
viser is built on top of trinity for the domain of plot visualization.
it takes as input a table and a trace that partially describes the plot.
for instance in the case of a bar chart the trace describestheheightofsomebars.thespecificationusedinviserisnotasstrongasintraditionalpbesystemssinceitdoesnotinvolve aconcreteoutputtablebutasetoftableinclusionconstraints.in contrast unchartittakesasinputachartimageinsteadofatrace.
given a chart image we perform data extraction and our outputtable will have numerical imprecisions that are not part of theresult of the table transformation program.
moreover since we aretacklingtheproblemofrecoveringdatatransformationsfrom existing plots the user would not be able to provide the trace of the plot required by viser.
another application of program synthesis to visualization is theinferenceofgraphicsprogramsfromhand drawnimagesand synthesisofthecorrespondingl atexcodethatgeneratesthatimage .thisapproachcombinestechniquesfromdeeplearning and program synthesis.
they learn a convolutional neural network that proposes a set of traces in the form of primitive drawings e.g.
line circle rectangle thatexplainstheimage.theseprimitive drawings serve as specification and a program synthesizer is then usedtogenerateaprogramthatgeneralizesthesetraceswithconditionals and loops.
even though our approach can also use a neural 184network for data extraction our synthesis goal is very different since it requires a sequence of table transformation operations and not trace generalization.
.
interactive program synthesis since pbe systems have incomplete specifications it is often requiredtodoaninteractivestepwiththeuserinordertofindthe correct program.
there are different forms of user interaction but the most commonly used by program synthesizers are i the user providesadditionalexamplestotheprogramsynthesizeruntilthere is no more ambiguity ii the synthesizer returns a ranked list of programs to be selected by the user iii the synthesizer creates a distinguishing input and asks the user for feedback .
there are different ways to create a distinguishing input i.e.
an input for which at least two programs have a different output.
one approach is to randomly generate distinguishing inputs .
thisissimilartoourinputgenerationapproachdescribedinsection .
.
another approach that is closer to our work is done by ji et al.
.
they sample the space of valid programs and encode the problem into smt to determine an input that minimizes the numberofprogramsthathavethesameoutputforagiveninput.
afterward they ask the user to provide the correct output for that input.thisapproachissimilartoouroptionsmodelwherewealso minimize thenumber of differentoutputs for thesame input.
our interactive approach can be seen as a generalization of ji et al.
work.first weshowhowtoformalizetheoptimizationproblem withmaxsmt.second weshowthatdifferentuserinteractionscan be formalized in this way namely the options and y n user interactionmodels.third weusesymbolicmodelcheckingtoencode programs written in real world programming languages to smt whereas the previous approach uses programs from the syntaxguidedsynthesiscompetition sygus thatareexpressedusing the smt language and restricted to smt constructs.
conclusions and future work data visualization is crucial for data analysts.
however many data analystsarenotproficientprogrammersanditisoftenthecasethat data analysts are unable to generate a given chart from the data.
themaincontributionofthispaperisacomprehensiveapproach to handle the problem of recovering data transformations from charts.
unchartit receives the input data and an output chart generated from the input data and can automatically find the underlyingtabletransformationtobuildthechart.experimental results on real data from kaggle show that unchartit can findand rank the correct program in the top programs in ofinstances.
to reduce the ambiguity of the programs returned by unchartit wedevelopedanewinteractivesynthesisprocedure thatcandisambiguate98 oftheambiguousinstancesbyasking on average fewer than questions to the user.
unchartit is the first tool for automatic generation of data transformationsthatdirectlyusesvisualelements.anintegrated prototype of our tool will become available online soon.
forfuturework weproposetoextendunchartitwithother visual elements in the input examples besides bar charts.
ideally useanhand drawnimageofachartinstead ofadigitalchartimage.currently thechartlabelsarenotyetused.however labels provide useful information on the chart interpreta tion.hence wealsoproposetoextendthedataextractionmodeltoidentify and use the labels in the chart image to direct the program synthesis process.