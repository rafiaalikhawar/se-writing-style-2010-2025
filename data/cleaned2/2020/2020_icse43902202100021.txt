depowl detecting dependency bugs to prevent compatibility failures zhouyang jia y shanshan li z tingting yuy chen zeng erci xu xiaodong liu z ji wang xiangke liao college of computer science national university of defense technology changsha china jiazhouyang shanshanli zengchen15 xuerci liuxiaodong wj xkliao nudt.edu.cnydepartment of computer science university of kentucky lexington usa tyu cs.uky.edu abstract applications depend on libraries to avoid reinventing the wheel.
libraries may have incompatible changes during evolving.
as a result applications will suffer from compatibility failures.
there has been much research on addressing detecting incompatible changes in libraries or helping applications coevolve with the libraries.
the existing solution helps the latest application version work well against the latest library version as an afterthought.
however end users have already been suffering from the failures and have to wait for new versions.
in this paper we propose depowl a practical tool helping users prevent compatibility failures.
the key idea is to avoid using incompatible versions from the very beginning.
we evaluated depowl on known compatibility failures from stackoverflow and depowl can prevent of them.
we also evaluated depowl using the software repository shipped with ubuntu .
.
depowl detected unknown dependency bugs which may lead to compatibility failures.
index terms software dependency library incompatibility compatibility failure.
i. i ntroduction applications reuse as much existing code as possible for cost savings.
existing code is often in the form of libraries which keep evolving and may introduce incompatible changes e.g.
changing interface signatures .
misuses of library versions containing incompatible changes may lead to failures in applications.
we refer to these failures as compatibility failures orcfailures .
acfailure involves three roles library developers application developers and end users library andapplication are relative concepts as an application itself may be a library for anther application .
as shown in figure library developers release two versions containing incompatible changes.
the changes are classified into two types backward incompatible change bic e.g.
removing an interface and forward incompatible change fic e.g.
adding an interface .
the solid we thank the anonymous reviewers for their insightful comments.
we also thank xin peng bihuan chen and kaifeng huang for their suggestions.
this work was supported in part by nsfc no.
national key r d program of china no.
2018yfb0204301 nsfc no.
u19a2060 nsf grant ccf and china scholarship council.zshanshan li and xiaodong liu are the corresponding authors.
old library versionnew library versionapplication codeapplication binaryficbic library developerapplication developerend userdevelopinstallreleasefig.
incompatible changes cause cfailures .the solid and dashed lines show how bic backward incompatible changes and fic forward incompatible changes cause cfailures respectively.
dashed lines show how a bic anfic causes cfailures if application developers develop an application based on the old new library version end users may suffer from cfailures when linking the application to the new old library version.
in either case the incompatible change causes cfailures .
when incompatible changes happened the three roles can prevent cfailures with different solutions library developers can undo the changes in the latest version application developers can update the application to adapt the changes end users can avoid using the incompatible library versions.
there has been some research on detecting library changes .
these techniques focus on suggesting incompatible changes for library developers i.e.
the first solution .
there has also been some work on detecting incompatible api usages in applications or helping applications adapt library changes .
these techniques focus on helping application developers update the application i.e.
the second solution .
in either of the above solutions end users may have already suffered from cfailures and have to wait for new library application versions.
the third solution on the other hand is more light weighted end users can avoid cfailures from the very beginning without having to see the cfailures occur.
however there exists no research that can achieve this goal by helping users automatically select compatible library versions.
some industrial settings use dependency management sys862021 ieee acm 43rd international conference on software engineering icse .
ieee tems dmss that can help users select right library versions.
examples include dnf in rpm based linux distributions and apt in debian based linux distributions.
however dmss have several practical limitations more details in section ii dmss require manual inputs from either application or library developers which can be tedious and errorprone.
for example dnfrequires application developers to specify version ranges of required libraries.
aptasks library developers to maintain a symbol list provided by the library.
manual inputs provided by developers may be outdated as the libraries evolve.
for example application developers specified the version range libfoo .
after which libfoo .
is released and backward incompatible tolibfoo .
.
the version range should have been updated to2.
libfoo .
.
developers may not comply with the requirements of the dmss .
for example aptrequires libraries not to break backward compatibility in a package but library developers may unintentionally introduce incompatibilities since there is no mechanism to guarantee the requirement.
since dmss depend on version ranges specified in specification files e.g.
the control file used by apt or the .spec file used by dnf to resolve dependencies the above limitations may introduce incompatible versions being included in the version ranges.
in this case we say there are dependency bugs ordepbugs in the specification files.
to address the limitations within dmss we propose a new approach depowl to detect depbugs and prevent cfailures .
depowl works at the binary level to check compatibility between libraries and applications instead of analyzing the api usage in source code of applications e.g.
compilers .
this is advantageous for end users who prefer to install binary files without having to compile the source code.
for example end users often use the command apt install to download binary files.
the source code level compatibility can not guarantee the compatibility of the binary files installed by the users.
specifically given the binaries of a library and an application depowl automatically checks if the application is compatible to each version of the library so it can help users select the right library versions to prevent cfailures .depowl contains three major steps.
in the first step depowl collects all potentially incompatible changes e.g.
add remove change interfaces during the evolution of the library from an old version to a new version including both bics and fics .
next depowl checks if the api usage in the target application matches the api definitions in either of the old and new library versions.
if the change is a bic fic and the api usage matches the old new library version the new old library version is regarded as an incompatible version.
in the third step depowl compares the incompatible version to all other library versions.
any version that is both backward and forward compatible to the incompatible version is also identified 1the current design of depowl focuses on c c applications and libraries.as an incompatible version.
users can prevent cfailures by avoiding using the reported incompatible versions.
a common usage scenario of depowl is to serve as a plugin for dmss .
taking apt as an example in debianbased linux distributions apthelps users manage application dependencies.
each application contains a control file indicating its required libraries and version ranges.
these ranges however may contain incompatible versions.
depowl is able to detect incompatible versions so that aptcan avoid using incompatible versions when resolving dependencies and users will be free of cfailures .
we evaluated depowl s ability in preventing both known and unknown cfailures .
we first evaluated depowl on real world known cfailures from stackoverflow and depowl can prevent of them.
we also applied depowl to the software repository shipped with ubuntu .
the latest ubuntu stable version at the time of writing.
depowl detected unknown depbugs which may cause cfailures .
in summary the contributions of this paper are as follows we propose a lightweight solution to prevent cfailures when incompatible changes happened in libraries.
existing research work mainly focuses on fixing cfailures in new versions but can not prevent the cfailures .
industrial dmss can help users resolve dependencies but still have limitations.
we design and implement depowl a practical tool to detect depbugs and prevent cfailures .depowl can collect incompatible changes in libraries detect depbugs in applications and suggest incompatible versions to help users prevent cfailures .
depowl can prevent out of cfailures selected from stackoverflow.
and detect depbugs in the repository shipped with ubuntu .
.
depowl is more accurate compared with baseline methods and requires no human efforts.
ii.
e xisting dmss and their limitations manual management of software dependencies is timeconsuming and sometimes even error prone since an application may depend on many libraries which keep evolving all the time.
in this regard a common approach especially in the open source community is to use a dependency management system dms e.g.
pip for python maven for java npm for javascript apt and dnf in linux distributions.
these dmss provide interfaces for developers to specify dependencies i.e.
the required libraries and corresponding versions as well as repositories that contain all libraries.
developers manually specify dependencies then the dmss can automatically download and install the libraries from the repositories.
for a required library developers can specify a fixed version or a version range.
using a fixed version is a reliable solution because it has little to virtually zero cfailures but it lacks flexibility because critical fixes in later versions of the library cannot be automatically included .
while using a version range increases flexibility since it can cockpit .
src bridge cockpitpipechannel.c id g strdup printf internal stream ... inserted g hash table replace ... id ... g assert inserted homebank .
.
src hb transaction.c if g hash table lookup ... null retval g hash table insert ... return retval fig.
example usages of library incompatible changes.
both cockpit .
and homebank .
.
use return values of glib functions which return void in some glib versions.
automatically include critical fixes in later versions of the library but decreases its reliability because the later versions may also introduce cfailures .
there is a tradeoff between flexibility and reliability in these two approaches.
developers struggle to find the sweet spot .
most dmss leave this choice to application developers who can manually limit the version range of each required library.
taking dnf as an example dnf is the dms used in rpmbased linux distributions like fedora.
dnfrequires application developers to specify the required libraries and version ranges e.g.
ocaml .
which may be outdated the version ranges may be too large as libraries evolve.
for example developers specify libfoo .
at first after which libfoo .
is released and backward incompatible with libfoo .
.
in this case the version range should be updated to .
libfoo .
.
the version ranges may be too small as libraries evolve.
for example developers specify libfoo .
at first after which libfoo .
is released and backward compatible with libfoo .
.
in this case the version range should be updated tolibfoo .
.
to avoid these limitations another solution is to maintain a symbols file by library developers.
this solution is applied in apt the dms in debian based linux distributions like ubuntu.
according to debian policy abi application binary interface changes that are not backward compatible require changing the soname of the library a shared library must be placed in a different package whenever its soname changes .
it means that two library versions should be placed in two library packages when the versions are backward incompatible.
these two packages to some degree can be regarded as two different libraries e.g.
libssl1.
.
and libssl1.
.
library developers are required to maintain asymbols file in which each line contains a symbol provided by the library as well as the minimal version that the symbol is introduced.
then the version range of this library can be inferred automatically by extracting symbols used by an application.
the minimal version of the version range is the maximum value of introducing versions of all used symbols.
the maximum version is not necessary since all versions are backward compatible in one package.
finally the version range is used by aptto help users manage dependencies.
the above solution however is still limited since there is no mechanism to guarantee that library developers comply ver .0ver .1ver .0incomp.library changesversion rangessource codebinary filesdepbugver .0ver .1ver .0incomp.
library versionscollect incompatible changesdetect dependency bugssuggest incompatible versionsapplicationlibrarylibraryfig.
overview of depowl .depowl contains three major steps collect incompatible changes detect dependency bugs and suggest incompatible versions.
with the policy.
library developers may unintentionally introduce abi incompatibilities between two versions which have the same soname .
existing studies show of library versions violate semantic versioning meaning libraries frequently introduce incompatibilities during minor version changes.
this solution only works for binary packages since aptneeds to analyze binary files to extract symbols used by the application.
application developers have to manually specify version ranges for source packages which do not have binary files.
in this case aptwill suffer from the same limitations as dnf.
library developers need to manually update the symbols file when introducing forward incompatible changes.
for example when a struct type adds a field in a new library version the introducing version of all symbols using thestruct must be increased to the version at which the new field was introduced.
otherwise a binary built against the new version of the library may be installed with a library version that does not support the new field.
this is a common change during library evolutions failing to update the introducing version of any symbol will lead to depbugs .
we will show a real world example in section iii.
in summary the dmss supporting version ranges may introduce depbugs the ranges contain incompatible versions.
in this paper we focus on detecting and fixing depbugs in the range based dmss so that applications can achieve higher reliability without affecting flexibility.
iii.
m otivation and overview of depowl in this section we show a depbug example which motivates us to design depowl .
based on the example we introduce how depowl works at a high level.
motivating example.
from glib .
.
toglib .
.
the return types of some functions e.g.
g hash table replace g hash table insert changed from void togboolean .
these changes are backward compatible a binary complied against the old version will ignore the return value of the new version and there is no error forward incompatible a binary complied against the new version may use the return value where the old version returns void.
these changes may cause depbugs in many applications e.g.
cockpit .
homebank .
.
where the return values of the changed functions are used.
figure shows code 88table i examples of depowl results.
a collecting incompatible changes in libraries.
library change versions change content glib .
.
.
.
g hash table replace adds return values glib .
.
.
.
g hash table insert adds return values b detecting depbugs and suggesting incompatible library versions.
application library depbug incompatible versions cockpit .
glib .
.
.
.
.
.
glib .
.
homebank .
.
glib .
.
.
.
.
.
glib .
.
snippets of two applications.
the usage of return values indicates any glib version returning void will be incompatible to the applications.
however in ubuntu .
cockpit .
depends on glib .
.
and homebank .
.
depends on glib .
.
.
both the version ranges contain the incompatible version glib .
.
.
therefore we say cockpit .
and homebank .
.
contain depbugs since their version ranges contain incompatible versions.
the root cause of the depbugs is that library developers do not update the introducing versions of the changed functions in the symbols file of the library.
the depowl approach.
depowl can detect depbugs in the above example and prevent cfailures caused by the bugs.
figure shows the overview of depowl which contains three major steps.
first the root causes of cfailures are incompatible changes in libraries.
depowl collects incompatible changes from any two successive library versions including both bics andfics .
for example the above example contains two incompatible changes as shown in table ia.
second one incompatible change may or may not result in cfailures .depowl analyzes usages of the changed element e.g.
g hash table replace in each application and detects whether the old or new library version of the change is incompatible to the application.
if yes depowl reports a depbug when the incompatible version is included in the required version range of the application.
for the above example the third column of table ib shows the incompatible versions that cause depbugs .
third one incompatible change may cause multiple incompatible versions.
depowl suggests all incompatible versions caused by each incompatible change.
users can prevent cfailures by avoiding using the incompatible versions.
in this step any version that is both backward and forward compatible to the version reported by the second step e.g.
glib .
.
forcockpit .
will also be regarded as an incompatible version.
in our example the changed functions return void inglib .
.
and previous versions.
thus the incompatible version range is glib .
.
.
then depowl calculates the intersection between the incompatible version range and the required version range.
for example the intersection for cockpit .
is2.
.
glib .
.
.
there are three challenges in the design of depowl depowl collects library changes that break either backward or forward compatibility whereas existing tools mainly focus on detecting backward incompatibilities.
to int foo int foo int foo int main foo mylib.hv1.0mylib.hv2.0mylib.hv3.0myapp.c 011010011100011010011100011010011100011010011100mylib.sov1.0mylib.sov2.0mylib.sov3.0myapp source code compatibilitybinary compatibility this paperfig.
difference between depowl and existing tools.
this figure includes source code level and binary level compatibility between libraries and applications or cross different library versions .
existing tools focus on while depowl addresses .
achieve this we propose a heuristic rule to help depowl detect changes breaking forward compatibilities.
depowl detects if incompatible changes will cause depbugs .
this is challenging because the changes can involve different types e.g.
add a function remove a parameter .
to address this we categorize the changes and derive a set of rules to detect depbugs for each type.
depowl suggests all incompatible versions caused by each incompatible change.
this is non trivial because multiple changes may affect the same element.
in this regard depowl performs a global check across all versions to suggest incompatible ones for a changed element.
iv.depowl approach there have been some existing techniques e.g.
compilers on analyzing api usages in applications to check if the application is compatible with a given library version.
they work at the source code level.
however end users often prefer to install binary files directly instead of downloading source code files and compiling the applications themselves.
therefore the users often care more about the binary level compatibility.
there has also been some work e.g.
abi tracker on detecting incompatibilities cross different library versions at both source code and binary levels.
this work does not analyze the api usages in applications.
as shown in figure in this paper we focus on detecting binary level compatibility between libraries and applications.
the compatibility at the source code level cannot guarantee the compatibility at the binary level such as modification of virtual tables of classes change of type sizes of function parameters change of values of enumeration elements change of orders of struct fields change of compilation directives and so on.
figure shows two real world examples that applications and libraries are compatible at the source code level but incompatible at the binary level.
in the first example three openssl .
.1s ssl ssl.h ifndef openssl no ssl2 const ssl method sslv2 method void sslv2 const ssl method sslv2 server method void sslv2 const ssl method sslv2 client method void sslv2 endif ruby .
.
ext zlib zlib.c if !defined have type z crc t typedef unsigned long z crc t endif const z crc t crctbl crctbl get crc table fig.
examples of source code compatible but binary incompatible dependency between libraries and applications.
apis in the library openssl depend on the compilation directive openssl no ssl2.
in openssl .
.1s the directive is enabled thus the apis are not available in library binaries.
while in other versions the directive is disabled by default.
in this case the source code of openssl .
.1s is the same as the source code of other versions but applications using the apis only fail when linking to openssl .
.1s .
in the second example the application ruby .
.
depends on the library zlib which defines z crc t asunsigned int after zlib .
.
.
when compiling ruby against zlib .
.
the compilation directive ha ve type z crc t is not defined thus z crc t is unsigned long .
when compiling ruby .
.
against zlib .
.
the compilation directive is defined thus z crc t isunsigned int.
the application ruby .
.
is source code compatible with both zlib .
.
andzlib .
.
.
however when the application is compiled against one version it will be incompatible to another version at runtime.
algorithm shows how depowl suggests incompatible versions for each pair of library and application lib app in a software repository line .
depowl first collects the set of incompatible changes icfromlib line .
table ia illustrates two examples of incompatible changes.
each incompatible change icis a three tuple library name change versions change content .
the change versions contain the old and new versions involved in the change.
for each ic line depowl then detects whether iccan cause a depbug inapp and returns a two tuple vold vnew line .
if the old new version of icis incompatible to app and included in the version range required by app vold vnew returns the old new version number otherwise vold vnew returns .
if vold vnew does not return line line depowl will suggest any version which is both backward and forward compatible to vold vnew as an incompatible version line line .
a. collecting incompatible changes the first component of depowl takes the library libas input and collects its incompatible changes ic.
as shown in figure both bics and fics may result in cfailures .
depowl needs to collect both kinds of library changes.
there are existing tools of detecting compatibility problems in libraries e.g.
abi tracker a tool for checking backward compatibility of a c c library.
however the existing tools mainly focus on backward compatibility problems.
depowl transfers the forward problems into backward problems.algorithm pseudo code of the depowl approach.
require library set lib application set app ensure incompatible version sets v lib app lib2lib app2app .
foreach pair of lib app do ic collect incompatible change lib foreachic2icdo detect dependency bug ic app ifvold6 1then v lib app suggest incompatible version ic vold lib end if ifvnew6 1then v lib app suggest incompatible version ic vnew lib end if end for end for we refer to incompatible changes from version voldto version vnewasic vold vnew ic vold vnew bic vold vnew fic vold vnew where bic vold vnew andfic vold vnew stand for bics andfics fromvoldtovnew.depowl applies a heuristic rule forward incompatibility from voldtovnew is equivalent to backward incompatibility from vnewtovold formalized as fic vold vnew bic vnew vold according to equation and equation we can get ic vold vnew bic vold vnew bic vnew vold then depowl collects both bic vold vnew and bic vnew vold by using the abi tracker tool.
for a library with nversions depowl calculates all incompatible changes icoflib ic i i n 1ic vi vi during collecting library changes depowl also consider the following factors library soname .
depowl will skip the library changes between voldandvnew ifvoldand vnew have different sonames .
library versions with different sonames will be packaged into different packages thus will not lead to depbugs .
symbol versioning .
symbol versioning supports multiple symbol versions in one library version.
for example in glibc .
the symbol glob has two versions glob glibc 2. and glob glibc 2. .
means the default version .
depowl regards symbols with different versions as different symbols.
for each library version depowl requires its binaries compiled with debug symbols.
when the input is not available depowl takes source code as input and compiles the library with debug symbols itself we provide compiling scripts to achieve this .
depowl uses default compilation directives during the compiling process and accepts custom directives provided by users at the same time.
b. detecting dependency bugs the second component of depowl is to analyze usages of the changed element of each icinapp and detect whether voldorvnewis incompatible to app.
if yes depowl reports a depbug when the incompatible version i.e.
voldorvnew is 90included in the version range required by app.
when appdoes not specify any version range depowl assumes it accepts all versions.
as a common usage scenario of depowl is to detect depbugs in a software repository.
in this case depowl takes the repository as input and for each application package in the repository depowl detects whether the change can lead to a depbug .
it is time consuming to analyze all application packages since a software repository may contain tens of thousands of application packages.
in this regard depowl splits the detecting process into two phases filtering phase and detecting phase.
filtering phase .depowl first filters out the application package that does not accept the library versions where ic happened.
for example app requires libfoo .
while the ichappened from libfoo .
tolibfoo .
.
to achieve this depowl analyzes the dependencies of app e.g.
from control file in ubuntu or .spec file in fedora and extracts the libraries required by app as well as corresponding required version ranges.
depowl checks if the library where ichappens is included in the required libraries and if voldandvnew ofic are included in the corresponding version range.
when either of the above two conditions is not satisfied it means iccan never affect app.
in this case depowl reports no depbugs and stops analyzing.
then depowl filters out the application package that does not use the changed element in ic.
for example the library adds a parameter for a symbol which is not used in app.
in general iccan be classified into two types according to the changed element change a symbol e.g.
from foo to foo node a and change a data type e.g.
from struct node int i to struct node float f .depowl analyzes the binary files contained in app.
when icchanges a symbol depowl checks if any binary file requires the symbol by using thereadelf tool.
when icchanges a data type depowl collects all symbols that use the data type in the library and checks if any binary file requires any symbol.
if yes it means iccan potentially lead to cfailures and depowl starts the next phase.
otherwise depowl stops analyzing and reports nodepbugs .
detecting phase .depowl analyzes the usage of the changed element and determines whether voldorvnew is incompatible to app.
if the change is a bic fic and the usage matches vold vnew then vnew vold will be regarded as the incompatible version.
depowl takes the application binary file with debug symbols as input.
when icchanges a symbol depowl extracts the symbol signature from the binary file.
when icchanges a data type depowl extracts the data type definition from the binary file.
after that depowl compares if the signature or definition is the same as that of voldorvnew.
if the above input is not available depowl can also extracts the usage from source code.
for example when working on a software repository many applications are released without debug symbols.
in this case depowl automatically downloads the source code of each application package.
when using the application source code it is hard to extract symbol signatures or data type definitions since the headerfiles are not available.
depowl has to apply different rules to determine the incompatible version.
for example when ic adds a field in a struct depowl needs to check if the additional field is used in the source code.
when icchanges the type of a return value from void tonon void depowl needs to check if the return value is used in the source code.
in this regard we enumerate all types of incompatible changes in c c libraries and define determination rules for each type.
the classification and rules are shown in table ii.
we classify library changes into types related toenum struct variable and function .
the struct and enum types are data type changes while the variable and function types are symbol changes.
for data type changes depowl needs to confirm that the application uses the changed element in source code e.g.
member for enum or field for struct .
for symbol changes depowl has already confirmed that the application uses the changed symbol in the filtering phase.
for changes related to add or remove once the application uses the changed element depowl determines the incompatible version is voldorvnew respectively.
for changes related to change type depowl analyzes the usages of changed element and infers the type in source code.
for example from zlib .
.
.
tozlib .
.
the return type of the function get crc table changed from long to int.
in the source code of package unalz .
depowl finds long crc table get crc table i.e.
the return type matches version .
.
.
.
thus depowl determines .
.
is the incompatible version.
as for change type and it is hard to infer the member value or field order from source code.
thus depowl cannot determine the incompatible version.
we tried to build a complete table with our best effort.
we referenced online resources during the enumeration process .
for example changing an inherited class in c will generate two totally different symbols in binaries due to name mangling.
in this case depowl will report function add and function remove .
also depowl is designed to be flexible to incorporate new rules.
depowl uses srcml a source code analysis infrastructure to achieve the above analyzing.
the source code cannot be compiled since the lack of header files while srcml provides lexical analysis and syntax analysis for non compilable source code.
depowl returns a two tuple vold vnew in this step.
if the old new version in icis incompatible to appand included in the version range required by app vold vnew returns the old new version number otherwise vold vnew returns .
c. suggesting incompatible versions we refer to the incompatible version reported in the above step i.e.
voldorvnew asvbug.
a library change may lead to multiple incompatible versions beyond vbug.
in this component depowl detects all library versions that are incompatible toapp caused by ic.
to achieve this depowl cannot simply assume the versions less than or greater than vbugas incompatible versions since the changed element in icmay change 91table ii rules for determining depbugs .
id types of incompatible changes depowl rulesincomp.
version enum adds member use the member vold enum removes member use the member vnew enum changes member value use the member struct adds fieldyuse the field vold struct removes field use the field vnew struct changes field typeuse the field match the filed typevo vn struct changes field order use the field global variable adds vold global variable removes vnew global variable changes type match the var type vo vn function adds vold function removes vnew function adds para use the para vold function removes para use the para vnew function changes para type match the para type vo vn function adds return value use the function ret vold function removes return value use the function ret vnew function changes return type match the ret type vo vn ythe struct related rules also apply for union orclass .
again in another ic.
for example in zlib developers remove the function gzgetc change gzgetc to a macro for speed from zlib .
.
.
tozlib .
.
.
.
after that the developers restore gzgetc for compatibility from zlib .
.
.
tozlib .
.
.
.
in this regard depowl checks compatibilities of the changed element of icacross all versions of lib and any version that is both backward and forward compatible to vbugwill be regarded as an incompatible version.
we refer to the changed element in icasele.
suppose there are nlibrary versions.
for 8i2 depowl calculates isiv vi a boolean value indicating whether vi is an incompatible version isiv vi bbc vbug vi ele bfc vbug vi ele where bbc vbug vi ele andbfc vbug vi ele return boolean values meaning if elebreaks backward compatibility or breaks forward compatibility from vbugtovi respectively.
if yes return otherwise return .
similar to section iv a we have bfc vbug vi ele bbc vi vbug ele therefore depowl transforms the above two equations to isiv vi bbc vbug vi ele bbc vi vbug ele then depowl outputs a list of boolean values isiv each of them indicates whether a version is incompatible i.e.
or not i.e.
isiv for each element e.g.
isiv vi inisiv ifisiv vi equals to and vibelongs to the version range required by app depowl regards vias an incompatible version.
taking the application cockpit .
as an example the required version range is glib .
.
while for 8j2 glib .
.
isiv vj equals to .
depowl suggests the incompatible versions are .
.
glib .
.
.
for an application that isnot managed in a software repository depowl assumes that it accepts all library versions since there is no version ranges.
for the given app andlib depowl reports a set of incompatible versions for each ic iv lib app ic .
suppose there aremincompatible changes in lib.
finally depowl suggests all incompatible versions between app andlib v lib app i i miv lib app ic i where icistands for the ithincompatible change.
v. e valuation to evaluate depowl we consider three research questions rq1 how effective is depowl at preventing known cfailures?
this question examines the recall ofdepowl by calculating the percentage of cfailures that can be prevented by depowl among all known cfailures .
rq2 how effective is depowl at preventing unknown cfailures?
this question evaluates the precision ofdepowl by calculating the percentage of correct results among all results reported by depowl .
rq3 how does depowl compare with existing methods?
this question compares depowl with two widely used dmss i.e.
aptanddnf as well as the dependencies declared in the build systems e.g.
autoconf orcmake by developers2.
a. datasets and experiment designs for each research question we introduce the preparation of datasets and the measurements used during the evaluation.
rq1 preventing known cfailures .we collected known cfailures from stackoverflow by using keyword search.
however simple keywords e.g.
library dependency version etc may result in tens of thousands of issues and introduce massive manual efforts in the following analysis.
instead we used the error messages when users came across compatibility problems as keywords.
for example when a library removes a symbol the application will echo symbol lookup error at runtime.
when a library symbol adds or removes a parameter the complier will complain too few many parameter to function at compiling time.
in total we collected issues by using error message searching.
we then manually analyzed root causes of these issues and found issues involve incompatible changes in libraries.
these changes lead to cfailures through misuses of library versions.
while others are mainly caused by dependency problems but not related to compatibility.
among the issues of them involve c c programs.
since the current version of depowl handles c c programs we used the issues to answer rq1.
the applications of issues are code snippets provided by the original posters while other issues involved mature projects including servers e.g.
httpd mongodb and clients e.g.
eclipse qt from different domains.
2the data and source code in this paper are publicly available in 92table iii examples of reported depbugs in the software repository shipped with ubuntu .10y.
application and library information results of depowl application package library package change versions change symbol data type incompatible versions qgis providers 3. .
libsqlite3 .
.
.
.
.
.
.
struct sqlite3 module adds xsavepoint unalz 0. zlib1g .
.
.
.
.
.
.
get crc table changes return value from long to int elisa 1. libkf5i18n5 .
.
.
.
.
.
add klocalizedcontext qobject gammaray 2. .
libqt5core5a .
.
.
.
.
.
qt register signal spy callbacks changes para type geeqie 1 .
.
libglib2.
.
.
.
.
.
.
g utf8 make valid adds parameter gssize alsa utils 1. .
libasound2 .
.
.
.
.
.
remove snd tplg new alsa 0. rkward 0.
.0b .
libkf5coreaddons5 .
.
.
.
.
.
add kcoreaddons versionstring ywe illustrate one bug for each library package.
the complete depbug list is available in our supplementary materials.
since the issues were selected by searching error messages they may not cover certain types of compatibility breaking changes table ii that do not produce observable symptoms.
for example in table ii changing member values in a enum type id and changing field orders in a struct type id may result in errors in a program but will not generate error messages.
therefore the issues cannot cover the changes of id and id .
it is hard to collect incompatibilities that have no observable failures since users cannot be sure if they are actual bugs thus may not report issues.
we measured the effectiveness of preventing known cfailures in terms of whether depowl can prevent the cfailures in the c c related issues.
to achieve this depowl needs to detect depbugs in these issues.
depbugs happen when the version ranges required by applications contain incompatible versions.
fixing the depbugs helps users avoid using incompatible versions and prevent cfailures .
when an application does not specify a version range depowl assumes that the application accepts all library versions.
rq2 preventing unknown cfailures .we used the software repository shipped with ubuntu .
the latest stable version at the time of writing to evaluate depowl since ubuntu uses apt which can resolve dependencies automatically while other dmss mainly depend on application developers to manually input dependencies.
the repository includes packages each package can be either an application package or a library package.
there are library packages which are depended by at least one other package.
for each library package we count the number of application packages that depend on it.
we choose the top 1h i.e.
library packages which are from different libraries one library may generate multiple packages e.g.
theqtlibrary generates libqt5core5a libqt5gui5 etc.
.
for each chosen library we collect its versions released during about last ten years and get versions in total i.e.
.
versions for each library on average .
it is hard to directly measure the effectiveness of preventing unknown cfailures since the unknown cfailures do not happen as yet.
instead we measure the effectiveness in terms of whether depowl can detect unknown depbugs in the software repository and prevent potential cfailures caused by the depbugs .
in specific for each application package from the software repository depowl detects whether therearedepbugs with regard to the chosen library packages i.e.
the version ranges required by the application package contain incompatible versions.
if yes depowl suggests the incompatible versions that may cause cfailures .
rq3 comparing with existing methods.
we used the same dataset in rq1 to compare depowl with existing methods and calculated the percentage of issues that can be prevented if the original posters use existing methods.
we first compared depowl with two dmss used in industry dnf used in rpm based linux distributions where application developers manually specify version ranges of required libraries apt used in deb based linux distributions where library developers maintain a symbols file.
we then compared depowl with building scripts e.g.
configure.ac or cmakelist.txt shipped with application source code since developers often declare version ranges in the scripts.
b. results and analysis rq1 preventing known cfailures .two authors manually evaluated whether depowl can prevent the known cfailures by analyzing if the incompatible versions suggested by depowl contain the incompatible version used by the original poster.
the result shows depowl successfully suggests incompatible versions for of the c c related issues.
the complete list of these issues is available in our supplementary materials.
each issue in the list contains the issue id the application name the library name and the incompatible versions suggested by depowl .
taking issue as an example library libpcre adds function pcrecpp re init from libpcre .
tolibpcre .
and changes its parameter type from libpcre .
tolibpcre .
.
therefore depowl reports two library changes.
meanwhile the application mongodb .
uses pcrecpp re init and the parameter type is the same as the type from libpcre .
tolibpcre .
.
thus depowl reports 3as the incompatible versions.
on the other hand depowl reported three false negatives.
two cases were caused by compilation directives e.g.
the original poster executed and compiled an application on different os where the libraries may be compiled with different directives.
depowl cannot infer such directives and thus generates false negatives.
the last case missed version information and might have used a very old library version.
depowl can 3vinit andvlast stand for the first and the last library version that have the same soname .
93prevent cfailures in out of the issues.
this result indicates depowl can effectively prevent real world cfailures in terms of recall.
rq2 preventing unknown cfailures .depowl collected incompatible changes from the versions of the libraries.
for each change depowl detects if the change can cause a depbug for each application package.
depowl detected depbugs of which are caused by backward incompatible changes and are caused by forward incompatible changes.
these depbugs involve application packages and library packages.
table iii illustrates one bug for each library package.
the complete depbug list is available in our supplementary materials.
for example in the first bug the application qgis providers 3. .
depends on the library libsqlite3 .
.
which adds the filed xsavepoint instruct sqlite3 module from .
.
.
to .
.
.
the application used the new filed thus .
.
.
is an incompatible version.
depowl then suggests all incompatible versions .
we searched evidence from new library versions new application versions or software repositories to evaluate if the 77depbugs have been handled in different ways.
if not we further reported them to the repository maintainers.
among the depbugs library developers undo the library changes of cases in later library version.
it means applications may have cfailures when using the library versions before un the changes.
application developers update the application to adapt the changes in cases meaning the old application version may have cfailures .
besides depbugs are fixed in the latest version of ubuntu or debian.
although these bugs have been handled in different ways they had been in the system for a long period of time posing threats to the system reliability.
for example library developers fixed an incompatible version which had already been released and affected applications.
depowl is able to prevent these impacts from the very beginning.
for the other cases we report them to the ubuntu community of them have been confirmed by developers and are pending for response.
so far we only found one potential false positive case.
depowl reported that the library kcoreaddons .
is incompatible to the application rkward which depends on kcoreaddons .
.
the developer agreed that the incompatibility may exist but kcoreaddons .
is not actually used in any ubuntu release xenial uses kcoreaddons5.
bionic uses kcoreaddons .
thus has zero impact.
this result indicates depowl can effectively detect real world depbugs in terms of precision.
this experiment took about hours in a virtual machine with a dual core cpu and 4g memory.
the filtering and detection phases took about five hours excluding downloading packages .
the majority of time was spent on collecting library changes of history versions.
this process is one time effort since the latest library version can be analyzed incrementally.
the execution time of each library depends on its scale and type.
when analyzing large c libraries like qt depowl may need dozens of minutes for each pair of versions.
meanwhile some other libraries only need several seconds.
webkitgtk.spec in webkitgtk .
.
.el6 6.src.rpm buildrequires gtk2 devel buildrequires libsoup devel .
.
buildrequires libicu devel control in libwebkit .
2 1. .
squeeze2 amd64.deb libpng12 .
.
libsoup2.
.
.
libsqlite3 .
.
configure.ac in webkit .
.
.tar.gz libsoup required version .
.
cairo required version .
fig.
version ranges of different baselines.
rq3 comparing with existing methods.
we compared depowl with three existing methods i.e.
dnffor.rpm packages aptfor.deb packages and the building system.
for each stackoverflow issue used in rq1 two authors manually evaluated if the cfailure can be prevented by using existing methods when the original poster used the existing methods at first.
taking issue as an example webkit has symbol lookup error when linking to libsoup .
the incompatible version range of libsoup is .
the version ranges oflibsoup in three baselines accepted by webkit are .
.
vlast respectively.
thus all the three baselines can prevent the failure in this issue.
figure lists the files where we get these version ranges including the webkitgtk.spec file in the .rpm package the control file in the .deb package and the configure.ac file in the building system of source code.
figure shows the results regarding the comparison among depowl and the three baselines.
depowl can prevent cfailures in issues whereas the baselines can prevent cfailures in issues respectively.
besides depowl does not report any problems in issues i.e.
false negatives while the baselines do not report any problems in issues.
this is because issues were caused by code snippets provided by the original posters.
these code snippets are not managed in any dmss or build systems.
last but not the least the baselines report depbugs in issues i.e.
the version range contains incompatible versions .
depowl successfully prevents cfailures whereas the best baseline prevents cfailures .
the detailed results are available in our supplementary materials.
this result indicates depowl is more accurate than the three baselines.
in the mean time depowl requires no human efforts while the baselines require manual inputs from either library developers or application developers.
vi.
d iscussion and future works in this section we discuss limitations in the design of depowl as well as future works with regard to the limitations.
debug symbols of libraries.
to collect incompatible changes in section iv a depowl requires all versions of the library as inputs.
each version should be in the source code form or the binary form with debug symbols.
for the binary form most libraries are released without debug symbols and do not meet the requirement of depowl .
as depowlrpmdebsourcereport depbugs false positive do not report false negative prevent cfailures true positive fig.
the comparison among depowl and baselines.
for the source code form we need to compile the source code so that depowl can collect application binary interface abi changes.
depowl provides scripts to automate the compiling process.
this is still limited since depowl uses the default compilation directives thus cannot collect abi changes triggered by other directives.
as a result developers have to provide the compilation directives or depowl may cause false negatives.
future work the most convenient way to avoid this limitation is to suggest library developers to release binaries with debug symbols when releasing new versions.
this practice actually has been applied in some libraries.
for example in the software repository of ubuntu .
there are packages with the suffix dbg containing debug symbols.
code analysis in applications.
when detecting dependency bugs in section iv b depowl requires application binaries compiled with debug symbols.
this input is not available in most applications managed in existing dmss .
alternatively depowl has to use source code as input but correct usages in source code do not indicate the application is free of cfailures in the binary form.
for example the second example of figure shows the usage of get crc table inruby .
.
which works well against both zlib .
.
and zlib .
.
in source code level when ruby .
.
is compiled against zlib .
.
the return type z crc t isint when ruby .
.
is compiled against zlib .
.
the return type z crc t islong.
however ruby .
.
may have cfailures when compiled against one version and linked to another version at runtime.
this limitation will lead to false negatives.
future work depowl will provide an interface for application developers to indicate a fixed version for each library.
this manual effort is the same to most dmss like pipormaven .
thus depowl can compile the source code against the fixed library version.
limitations when using abi tracker.
depowl uses abitracker to collect incompatible changes of a target library.
abi tracker takes source code of the library history versions as inputs and compiles each version with default directives.
this process may introduce both false positives and false negatives.
for example in the first example of figure abitracker reports that openssl .
.1s removes three symbols.
however users will not encounter failures when disabling openssl no ssl2.
in this case depowl may report falsepositives although no false positives directly related to abitracker are generated in our experiment.
on the other hand when incompatible changes can only be triggered by specific directives abi tracker may generate false negatives and thus cause depowl to report false negatives.
for example two out of three false negatives in rq1 are caused by compilation directives not correctly identified by abi tracker.
impacts of compilation directives.
the compilation directives of a target library may affect the symbols and data types provided by the library and further affect the results of depowl .
since abi tracker uses default compilation directives to compile each library version it may cause depowl to report false negatives as discussed in the above paragraph .
we have mitigated this impact by directly analyzing the binaries of the target libraries without the need of providing compilation directives.
in the case where binaries are not available depowl accepts the directives from users for compiling.
in our evaluation we manually input the directives in most cases.
for the two cases that we cannot obtain the directives in rq1 depowl reports two false negatives since the directives are hard to be inferred automatically.
vii.
r elated works we briefly classify the existing works into three types library changes.
many works are targeted at library changes.
bagherzadeh et al.
studied the size type and bug fixes in changes that were made to linux system calls.
brito et al.
identified breaking changes and asked the developers to explain the reasons behind their decision to change the apis.
dig et al.
discovered that over of changes that break existing applications are refactorings.
liet al.
investigated the android framework source code and found inaccessible apis are common and neither forward nor backward compatible.
li et al.
and wang et al.
studied api deprecation in the android ecosystem and python libraries.
mcdonnell et al.
found android updates api per month and usages in client applications are outdated with a median lagging of months.
sawant et al.
investigated why api producers deprecate features whether they remove deprecated features and how they expect consumers to react.
brito et al.
identified api breaking and non breaking changes between two versions of a java library.
foo et al.
presented a static analysis to check if a library upgrade introduces an api incompatibility.
meng et al.
aggregated the revision level rules to obtain frameworkevolution rules.
mezzetti et al.
proposed type regression testing to determine whether a library update affects its public interfaces.
ponomarenko et al.
presented a new method for automatic detection of backward compatibility problems at the binary level.
wu et al.
proposed a hybrid approach to identify framework evolution rules.
these works are targeted at detecting changes refactorings and rules during library evolutions.
while depowl is targeted at preventing failures caused by the results of these works.
application failures.
some works focus on cfailures in applications.
cai et al.
studied compatibility issues in android app to understand the symptoms and causes of these issues.
cossette et al.
studied techniques to help migrate client code between library versions with incompatible apis.
dietrich et al.
studied partially upgrading systems and found some crucial verification steps are skipped in this process.
jezek et al.
studied the compatibility of api changes and the impact on programs using these libraries.
lamothe et al.
reported their experience migrating the use of android apis based on documentation and historical code changes.
linares v squez et al.
studied how the faultand change proneness of apis relates to applications lack of success.
xavier et al.
conducted a large scale study on historical and impact analysis of api breaking changes.
balaban et al.
presented an approach to support client refactoring for class library migration.
he et al.
and xia et al.
studied api compatibility in android.
henkel et al.
captured api refactoring actions and users of the api can then replay the refactorings to bring their client software components up to date.
jezek et al.
proposed an approach that analyses the byte code of java classes to find type inconsistencies cross components.
li et al.
proposed a approach for modeling the lifecycle of the android apis and analyzing app that can lead to potential compatibility issues.
perkins et al.
proposed a technique to generate client refactorings by replacing calls to deprecated methods by their bodies.
wang et al.
proposed an automated approach that generates tests and collects crashing stack traces for java projects subject to risk of dependency conflicts.
xing et al.
recognized the api changes of the reused framework and proposed plausible replacements to the obsolete api based on working examples.
these works focus on detecting incompatible api usages and helping applications co evolve with library evolutions so that the latest application version works well.
while depowl can prevent cfailures for users in use versions.
application library dependencies.
there are many works address application library dependencies.
bavota et al.
studied the evolution of dependencies between projects in the java subset of the apache ecosystem.
bogart et al.
studied three software ecosystems to understand how developers make decisions about change and change related costs.
decan et al.
compared semantic versioning compliance of four software packaging ecosystems and studied how this compliance evolves over time.
decan et al.
analyzed the similarities and differences between the evolution of package dependency networks.
derr et al.
studied library updatability in apps and found .
libraries could be upgraded by at least one version.
dietrich et al.
studied developers choices between fixed version and version range from package managers.
jezek et al.
provided evidences that four types of problems caused by resolving transitive dependencies do occur in practice.
kikas et al.
analyzed the dependency network structure and evolution of the javascript ruby and rust ecosystems.
kula et al.
studied github projects and library dependencies to understand if developers update their library.
mirhosseini etal.
studied github projects to understand if automated pull requests help to upgrade out of date dependencies.
pashchenko et al.
studied whether dependencies of oss java libraries are affected by vulnerabilities.
raemaekerset al.
investigated semantic versioning and found one third of all releases introduce at least one breaking change.
xian et al.
conducted an experience paper to evaluate existing third party library detection tools.
wang et al.
conducted an empirical study on dependency conflict issues to study their manifestation and fixing patterns.
zerouali et al.
analyzed the package update practices and technical lag for the npm distributions.
these works mainly assist people in understanding application library dependencies.
while depowl is the first research work to help users avoid incompatible applicationlibrary dependency automatically.
huang et al.
and wang et al.
designed tools to detect dependency conflicts for maven and pypi ecosystems.
these tools focused on the diamond dependency problem which detects conflicts among different dependencies.
they assume each dependency itself is correct whereas depowl detects bugs within dependencies.
viii.
c onclusion in this paper we find cfailures are caused by using incompatible library versions which are hard to be prevented by the existing research works or industrial dmss .
to fill this gap we design and implement depowl a practical tool to prevent cfailures by avoiding incompatible versions.
depowl can detect unknown depbugs in the software repository shipped with ubuntu .
and prevent cfailures in real world issues collected from stackoverflow.
however depowl still has limitations in practice.
with limited helps from library developers release binaries with debug symbols and application developers provide one required library version depowl could achieve higher accuracy.
as a result applications could be both flexible for library evolutions and reliable for cfailures .