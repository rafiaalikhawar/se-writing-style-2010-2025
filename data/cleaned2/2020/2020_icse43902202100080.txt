imgdroid detecting image loading defects in android applications wei song school of computer sci.
eng.
nanjing university of sci.
tech.
nanjing china wsong njust.edu.cnmengqi han school of computer sci.
eng.
nanjing university of sci.
tech.
nanjing china hanmengq77 .comjeff huang parasol laboratory texas a m university college station tx usa jeff cse.tamu.edu abstract images are essential for many android applications or apps.
although images play a critical role in app functionalities and user experience inefficient or improper image loading and displaying operations may severely impact the app performance and quality.
additionally since these image loading defects may not be manifested by immediate failures e.g.
app crashes existing gui testing approaches cannot detect them effectively.
in this paper we identify five anti patterns of such image loading defects including image passing by intent image decoding without resizing local image loading without permission repeated decoding without caching and image decoding in ui thread.
based on these anti patterns we propose a static analysis technique imgdroid to automatically and effectively detect such defects.
we have applied imgdroid to a benchmark of open source android apps and found that it not only successfully detects the previously known image loading defects but also finds new such defects.
our empirical study on commercial android apps demonstrates that the image loading defects are prevalent.
index terms android app image loading defect analysis i. i ntroduction android applications apps for short often use images not only to enhance user experience but also to better provide their functionalities and services to users.
android sdk and several third party libraries frameworks provide easy to use apis which allows app developers to implement image loading and displaying conveniently.
our empirical study on commercial apps shows that over apps use such sdks or libraries.
however since the high resolution images e.g.
the pictures taken by the device camera are usually very large inefficient or improper programming practices e.g.
the apis are used inappropriately can severely impact the performance and quality of apps causing memory bloat gui lagging slow responsiveness or app crashes .
these inefficient programming practices of image loading called image loading defects in this paper are regarded as non functional bugs .
since the image loading defects mainly impact the performance of apps existing testing based approaches that aim at finding app failures may find difficulties in manifesting them .
besides testing approaches although a wide variety of techniques have been proposed to help improve app performance and quality little work focuses on the defects or code smells particularly relevant to image loading and displaying in apps .in this paper we extract five image loading anti patterns from both android developers1and the reported issues of real world apps in github2 and develop an automated static analysis to detect such image loading defects based on these anti patterns.
the five anti patterns are all reported to reduce the performance or even the quality of apps which are summarized below image passing by intent refers to the situation that an app employs intents to pass images between different activities which severely degrades the app performance.
image decoding without resizing refers to the situation that an image is decoded without its shape and size reduced to fit for the component e.g.
a view in which it displays.
local image loading without permission refers to the situation that an app tries to load images from the local storage of the device with no access permission which directly makes the app crash.
repeated decoding without caching refers to the situation that an image is decoded in a component s callback function and thus the image could be repeatedly decoded each time when the callback function is invoked.
image decoding in ui thread refers to the situation that an image is decoded in the ui thread of the app which can degrade the app performance causing gui lagging and even anr application not responding .
in practice there may exist other kinds of defects relevant to image loading and displaying but in this paper we only focus on the five image loading anti patterns.
for each of the five anti patterns we develop a static analysis to automatically detect such defects concrete instances matching the antipattern in apps.
since some anti patterns can occur to different image frameworks including the android sdk our static analysis varies accordingly and is tailored to different image frameworks.
to ensure the soundness of our analysis all image loading operations in the app are covered and analyzed.
to balance accuracy and scalability our analysis is based on a context insensitive caller callee analysis and a path sensitive inter procedural control flow analysis.
ieee acm 43rd international conference on software engineering icse .
ieee we implemented our static analysis in an open source tool imgdroid based on soot .
imgdroid is written in java and is publicly available on github3.
to evaluate the effectiveness and efficiency of our approach we have applied imgdroid to open source android apps.
imgdroid finished the analysis in seconds and it not only successfully detected the previously known image loading defects but also found new such defects in these apps.
to investigate image loading defects extensively with the help ofimgdroid we further conducted an empirical study on commercial apps randomly selected from google play downloaded in dec .
the empirical results demonstrate image loading defects are pervasive in practice .
apps involve at least one kind of image loading defects and each of the apps has on average .
image loading defects.
in a nutshell our contributions are highlighted as follows according to the issue reports of real world apps we summarize five common image loading anti patterns in android apps that can degrade app performance and quality or even lead to app crashes.
we present imgdroid a static analysis approach and an open source tool to automatically detect image loading defects based on the five anti patterns.
the experiment on a benchmark of open source apps show the effectiveness and efficiency of imgdroid .
with imgdroid we conduct an empirical study on real world commercial apps.
the results indicate that image loading defects are severe in practice.
the remainder of the paper is organized as follows.
section ii introduces the background on image loading in android apps.
section iii presents our static analysis for detecting image loading defects.
section iv evaluates our approach with real world apps.
section v reviews the related work and section vi concludes the paper.
ii.
b ackground we first introduce background on image loading and displaying in android apps.
readers familiar with image apis in android may skip this section and jump to section iii directly.
a. frameworks for managing images when designing android apps the developers can employ the relevant apis from the android sdk to load and display images in apps.
in android sdk bitmapfactory drawable and imageview are the classes responsible for processing images.
developers can use the related methods in these classes to create bitmap objects from various sources including files streams and byte arrays.
besides android sdk there are also some third party libraries frameworks that are often used to manage images in apps such as universal image loader4 glide5 picasso6 fresco7 etc.
universal image loader i popular third party frameworks for image loading and displaying in android apps frameworkrelease timesize of memory requiredgif supportedcache method universalimage loader2011 150k no memory and disk cache glide 500k yes memory and disk cache picasso 10k no memory and http cache fresco 2m yesanonymous shared memory local heap memory and disk cache 0hpru fdfkh uhdg cachehit bmpmisscache lvn fdfkh uhdgmisscache img imgcachehit img bmp bmp imgimagedisplay request 5hqghu hfrgh rdg 0hpru fdfkh zulwh lvn fdfkh zulwh7udqvirup fig.
.
workflow of image displaying in android apps.
provides lots of configuration options and good control over the image loading process.
picasso allows for hassle free image loading often in one line of code.
glide is an efficient image loading library for android focused on smooth scrolling it supports fetching decoding and displaying video stills images and animated gifs.
fresco puts images in a special region of android memory which lets apps run faster and suffer the oom out of memory error much less often.
in this paper we call these third party libraries image frameworks for short.
table i summarizes the basic information of these image frameworks.
b. image loading and displaying procedure no matter which image framework also the android sdk is used the workflow of image loading and displaying in android apps is almost the same cf.
figure when receiving a request to show an image the app first tries to read the corresponding bitmap object from the memory cache before rendering i.e.
displaying the bitmap on the screen of the device .
if the bitmap is not in the memory cache the app then tries to read it from the disk cache.
if it succeeds the app will decode the image e.g.
in jpg format to obtain the bitmap which may then be cached in the memory before rendering.
otherwise it has to load the image externally from the network or the local storage.
after some processing and transformation e.g.
reducing the size of the image the image can be stored in the disk cache.
the transformed image is then decoded may be cached in the memory and finally rendered.
note that the caching mechanism may or may not be used.
if it is not used an external image is displayed in the app by the following steps loaded transformed decoded and rendered.
ss pdjh ordglqj ghihfwv 6rrw orz urlg lpsoh 0dqlihvw iloh dss fdoo judsk 3rvw grplqdwru dqdo vlv 7dlqw dqdo vlv 5hdfkdelolw dqdo vlv hshqghqfh dqdo vlv pdjh ordglqj v fig.
.
an overview of imgdroid .
although the workflow of image loading and displaying is not complex some image loading defects frequently occur in practice which are elaborated in section iii.
iii.
imgd roid in this section we present our static analysis technique imgdroid for detecting image loading defects in apps.
figure illustrates the framework of imgdroid .
it takes an app apk file as input and generates all image loading defects could be empty in the app as output.
imgdroid is based on soot and flowdroid .
to scale to large commercial apps imgdroid detects image loading defects by combining a context insensitive caller callee analysis and a path sensitive inter procedural control flow analysis.
starting from the image loading statements imgdroid utilizes different static analysis techniques for example reachability analysis dominator and post dominator cf.
definitions and analysis taint analysis and control dependence cf.
definition analysis to analyze whether the image loading defects of different kinds exist or not.
to ensure the soundness of the static analysis imgdroid covers all image loading operations statements in the app and for each image loading statement imgdroid searches all possible defects along all potential paths.
if such defects exist the relevant information which is helpful for debugging is also provided including the kind of defects the image framework and apis used the locations i.e.
in which methods of the image loading operations.
definition dominator in a control flow graph a node a statement or a block of statements nis dominated by another noden0if every path from the entry of the control flow graph tonincludesn0.n0is referred to as a dominator of n. definition post dominator in a control flow graph a node a statement or a block of statements nis postdominated by another node n00if every path from nto the exit of the control flow graph includes n00.n00is referred to as a post dominator of n. definition control dependence in a control flow graph a node a statement or a block of statements nis controldependent on another node ciff there exists a path from ctonsuch that any statement node n0in excludingc andn is post dominated by n andcis not post dominated byn.1public class imagegridactivity f public void onclick view v f intid v. getid if id r.id.btn preview f intent intent new intent imagegridactivity .
this imagepreviewactivity.
class intent .
putextra imagepicker.
extra selected image position intent .
putextra imagepicker.extra image items imagepicker.getselectedimages intent .
putextra imagepreviewactivity.isorigin isorigin intent .
putextra imagepicker.extra from items true startactivityforresult intent imagepicker.
request code preview 11g 12g 13g fig.
.
a reported defect issue report of image passing by intent in a real world app imagepicker version .
.
.
in each of the following sub sections we first describe a kind of image loading defects and then elaborate on the method how imgdroid detects such kinds of defects.
a. detecting image passing by intent android uses intent for the interaction between different components e.g.
activities .
intent can bring some data of different types e.g.
int boolean string or parcelable and serializable objects.
if an activity intends to send some data to another activity it should first prepare the data through intent.putextra key value orbundle.putparcelable key value and intent.putextra bundle before starting the new activity via startactivity intent .
however if we use intent to pass data with large size e.g.
1m or even .5m the app performance can be undermined and exceptions may occur8.
thus using intent to pass image is regarded as a kind of image loading defects cf.
anti pattern .
to avoid this one can use intent to only pass the address or id of the image.
anti pattern image passing by intent passing image via intent may degrade the app performance and even cause an exception i.e.
app crash .
with the above explanation our approach to detecting image passing by intent is straightforward in the inter procedural control flow graph of the app if thestartactivity intent statement is reachable from intent.putextra key value orbundle.putparcelable key value and the type ofvalue isbitmap drawable orbitmapdrawable then there is a defect of image passing by intent.
figure presents such a defect9 which can be effectively detected by our approach the startactivity intent statement at line is reachable from theintent.putextra statement at line and imagepicker.getselectedimages returns a bitmap.
825table ii api s for image decoding resizing and caching in different frameworks framework decoding resizing caching android native apisbitmapfactory.decodefile option .decodefiledesccriptor option .decodestream option .decodebytearray option .decoderegion option option.injustdecodebounds true option.insamplesize lrucache.put drawable.createfrompath .createfromstream imageview.setimageuri universalimage loaderimageloder.displayimage option option.imagescaletype option.cacheinmemory fresco fresco.setcontroller option option.setresizeoptions by default glide glide.with .load glide.with .load .override glide.with .load .skipmemorycache picasso picasso.with .load picasso.with .load .resize picasso.with .load .resizedimen picasso.with .load .fit picasso.with .load .memorypolicy picasso.with .load .networkpolicy b. detecting image decoding without resizing the images may come in different shapes and sizes.
their sizes often exceed the requirement of a typical application interface.
displaying an oversized image on a slim view does not bring any visual benefit and it may have a negative impact on the app performance e.g.
occupying additional much memory or even lead to oom out of memory exceptions cf.
anti pattern .
for example since the resolution of a picture e.g.
pixels taken with the camera of an android device is usually much higher than the screen density if the bitmap configuration used is argb the default for android .
and higher loading a single picture into memory takes about mb of memory bytes which may immediately use up all the memory available to the app.
therefore when displaying a picture it is expected to compress it and the size of the compressed image should be similar to the size of the control used to display it.
anti pattern image decoding without resizing a decoded image could be considerably big in size which is expected to be resized.
otherwise it may degrade the app performance or even cause the oom out of memory exception.
since the resource images are usually small and the developers have known their sizes there is no need to resize them.
thus for anti pattern we only consider external pictures that come from the network and sd card.
it is a true positive provided there is a chance that a large picture can be loaded.
different image frameworks generally use two ways to implement image decoding and resizing.
in the first way the decoding and resizing are implemented in one method i.e.
the image resizing is controlled by a parameter e.g.
options of the decoding method.
in the second way the decoding and resizing are implemented by two separate methods respectively.
android native apis from the class bitmapfactory and the image frameworks such asuniversal image loader andfresco follow the first way while the image frameworks such as glide and picasso follow the second way.
there are android native class skiaimagedecoder implements imagedecoderf public bitmap decode context context uri uri throws exception f bitmap bitmap string uristring uri .
tostring options options new options options .
inpreferredconfig config.rgb if uristring .
startswith asset prefix f bitmap bitmapfactory.decodestream context .
getassets .
open uristring .
substring asset prefix.length null options 9g if bitmap !
null f return bitmap 12g throw new runtimeexception skia image region decoder returned null bitmap image format may not be supported 14g 15g fig.
.
a reported defect issue report of image decoding without resizing in a real world app leafpic version .
beta .
apis that only implement image decoding without considering image resizing i.e.
drawable.createfrompath drawable.createfromstream and imageview.
setimageuri .
if these three methods are used the corresponding images are decoded without resizing.
the second and third columns of table ii summarize the concrete decoding and resizing apis of different image frameworks.
according to how image decoding and resizing are implemented we have the following two ways to check whether an image is decoded without being resized for android native apis and the image frameworks such asuniversal image loader andfresco if the decoding statement does not have the argument e.g.
option for image resizing the image is decoded but not resized.
otherwise we further check whether the argument has been adapted to reduce the image size before decoding if there is a statement statements that reduces the image size by changing the argument and the statement dominates the decoding statement then there is no defect otherwise the image is decoded without being resized.
8261public class imagepageradapterfromcursor extends pageradapterf protected view createviewwithcontent intposition viewgroup container string fullphotopath string debugcontext int size f finalfile imagefile new file environment.
getexternalstoragedirectory environment.
directory dcim bitmap bitmap hugeimageloader.loadimage imagefile max image dimension max image dimension 5g 6g 7public class hugeimageloader f public static bitmap loadimage file file intmaxwidth int maxheight f bitmapfactory.options options new bitmapfactory.options options .injustdecodebounds true bitmapfactory.decodefile file .
getabsolutepath options intdownscale calculateinsamplesize options maxwidth maxheight options .insamplesize downscale options .injustdecodebounds false return bitmapfactory.decodefile file .
getabsolutepath options 16g 17g fig.
.
a reported defect issue report of local image loading without permission in a real world app a photo manager version .
.
.
.
for the image frameworks such as glide andpicasso our detection is based on the post dominator analysis on the inter procedural control flow graph of the app.
for an image decoding statement in the control flow graph if it is always post dominated by a corresponding resizing statement then the image loading is correct otherwise there is a defect of decoding without resizing.
figure exhibits such a defect11 which can be effectively detected by our approach the decodestream method is invoked at line but its argument option is not adapted between line and line as suggested in table ii for image resizing.
c. detecting local image loading without permission for android .
or higher users are not notified of any app permissions when installing apps.
instead users are asked to grant the permissions at runtime.
users may also have the option to enable or disable permissions one by one in system settings.
hence the apps should always check for and request permissions at runtime to avoid runtime errors.
reading images from the local storage sd card is no exception.
otherwise the app may crash due to no access permission cf.
anti pattern .
anti pattern local image loading without permission before reading images from the local storage the app should check for and request the access permission at runtime.
otherwise the app may crash due to no access permission.
approach to detecting this category of defects for different image frameworks is similar which includes three steps we first check whether there is an image decoding statement that uses a variable returned by the invocation of the method getexternalstoragedirectory .
if no there is no such defect.
otherwise go to step .
we next query in the androidmanifest file whether the app declares to get the permission to read the external storage.
if no we find a defect of local image loading without permission.
otherwise go to step .
we finally check whether the image decoding statement is control dependent on a statement that determines whether the app has obtained the permission to read the external storage i.e.
if contextcompat.checkselfpermission android.permission.read external storage orif easypermissions.requestpermissions android.permission.read external storage .
if no we find a defect of local image loading without permission.
the first two steps can be implemented based on the data flow analysis taint analysis of flowdroid .
let the declarations of the methods getexternalstoragedirectory the declaration of the required permission is also included and decodefile or other decoding apis in table ii be the source and sink respectively.
flowdroid can return all statement pairs e.g.
from to that may lead to the defects of local image loading without permission where from is a statement that invokes getexternalstoragedirectory andtois the corresponding decoding statement.
for each pair of statement from to we finally determine whether or not the decoding statement toloads a local image without the permission checked first.
figure shows such a defect13 which can be effectively detected by our approach the statement at line line loads decodes an image from the local storage although the app s androidmanifest file declares the permission to read the external storage the app performs the decoding operation without firstly checking whether or not it has obtained the corresponding permission.
d. detecting repeated decoding without caching in many cases the loaded images are displayed in the gui components widgets such as views subviews .
to save memory android limits the memory footprint of gui components by recycling views subviews that move out of the screen and the garbage collector assumes that no longterm