b saving ethereum fees via secure and cost e ective batching of smart contract invocations yibo wang ywang349 syr .edu syracuse university syracuse ny usaqi zhang qzhang71 syr .edu syracuse university syracuse ny usakai li kli111 syr .edu syracuse university syracuse ny usayuzhe tang ytang100 syr .edu syracuse university syracuse ny usa jiaqi chen jchen217 syr .edu syracuse university syracuse ny usaxiapu luo csxluo comp .polyu .edu.hk hkpu hong kong chinating chen brokendragon uestc .edu.cn uestc chengdu sichuan china abstract this paper presents b a middleware system running on top of an operational ethereum network to enable secure batching of smart contract invocations against an untrusted relay server o chain.
b does so at a low overhead by validating the server s batched invocations in smart contracts without additional states.
the b mechanism supports a variety of policies ranging from conservative to aggressive batching and can be con gured adaptively to the current workloads.
b automatically rewrites smart contracts to integrate with legacy applications and support large scale deployment.
for cost evaluation we develop a platform with fast and costaccurate transaction replaying build real transaction benchmarks on popular ethereum applications and build a functional prototype of b on ethereum.
the evaluation results show that b saves .
.
gas cost per invocation with a moderate 2minute delay and .
.
ether cost per invocation with a delay of .
.66blocks.
ccs concepts security and privacy !security protocols software and its engineering !ultra large scale systems .
keywords blockchains smart contracts defi cost e ectiveness replay attacks acm reference format yibo wang qi zhang kai li yuzhe tang jiaqi chen xiapu luo and ting chen.
.
b saving ethereum fees via secure and cost e ective batching of smart contract invocations.
in proceedings of the th acm joint european so ware engineering conference and symposium on the foundations of so ware engineering esec fse august yuzhe tang is the corresponding author.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for pro t or commercial advantage and that copies bear this notice and the full citation on the rst page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior speci c permission and or a fee.
request permissions from permissions acm.org.
esec fse august athens greece association for computing machinery.
acm isbn .
.
.
.
.org .
.3468568athens greece.
acm new york ny usa pages.
.org .
.
introduction the recent paradigm shift to building decentralized applications dapps on blockchains has nurtured a number of fast growing domains such as decentralized nance defi decentralized online gaming et al.
that have the potential of disrupting conventional business in nance gaming et al.
the core value brought by dapps is their decentralized system architecture that is amendable to tackle the mistrust crisis in many security oriented businesses e.g.
trusted authorities are constantly caught misbehaving .
however despite the attractive trustless architecture and moderate popularity in practice an impediment to dapps broader adoption is their intensive use of underlying blockchain and the associated high costs.
ethereum the second largest blockchain after bitcoin and the most popular dapp platform charges a high unit cost for data movement via transactions and for data processing via smart contract execution .
for instance sending one megabyte application data to ethereum costs .5ether or more than usd at the exchange rate as of jan. which is much more expensive than alternative centralized solutions e.g.
cloud services and has scared away customers e.g.
binance .
towards cost e ective use of blockchains existing research mainly tackles the problem from the angle of designing new protocols at blockchain layer one i.e.
redesigning the consensus protocol and building a new blockchain system and at layer two i.e.
by o oading the workload from the blockchain to o chain clients such as in payment channel networks .
however these new protocols are designed without the legacy platform of an operational blockchain and deployed dapps in mind and result in unsatisfactory deployability for instance existing protocols either require bootstrapping a brand new blockchain network as in the layer one approach or develop from scratch the on chain and o chain components of a dapp i.e.
to support payment networks .
as a result there is a lack of adoption of these protocols among legacy dapps at scale.
this work aims at optimizing legacy dapps use of expensive ethereum blockchain and achieving cost e ectiveness.
towards the goal we focus on designing a middleware system on top of an unmodi ed ethereum network and dapp clients.
we also develop esec fse august athens greece yibo wang qi zhang kai li yuzhe tang jiaqi chen xiapu luo and ting chen software tools to facilitate integrating the middleware with legacy dapps smart contracts.
to motivate our approach consider a typical dapp architecture where a dapp client holding an ethereum account sends a transaction on the ethereum blockchain to invoke a smart contract function there.
a typical dapp s smart contract runs event driven logic and a popular dapp would receive a large number of small invocations an individual invocation is often with a small amount of data and triggers few lines of smart contract code think as an example the transfer function in an erc20 token smart contract.
a popular dapp features an intensive stream of invocations that arrive at a high rate.
this workload characteristic holds over time as we veri ed on various ethereum traces see the idex trace in .
and chainlink binance bnb tether traces in and it is also corroborated by external ethereum exploration services .
the workload with a high rate of small invocations renders the transaction fee a signi cant cost component that alone is worth optimization.
to optimize the transaction fee a natural idea is to batch multiple smart contract invocations in a single transaction so that the fee can be amortized .
for instance under ethereum s current block limit one can theoretically batch up to 20normal invocations in a transaction leading to a potential fee reduction by .
by this promise invocation batching has long been craved for among ethereum developers evidenced by a number of ethereum improvement proposals eips .
despite the strong interest it still lacks real world support of invocation batching in ethereum as these eips are not made into production after years of discussion.
we believe this unsatisfactory status is due to the design challenges raised by the tradeo among batching s security cost e ectiveness and timeliness short delay as presented next.
batcher servicedispatcherrequestsbatch transaction caller accountscallee smart contractsinternal calls on the blockchainoff the blockchain call validatoraccess controlfigure batching smart contract invocations in ethereum note that the dispatcher can be a standalone smart contract or be a function inlining the callee function in the latter case the internal call is straight line code execution.
challenges first ethereum does not have native support of batching in the sense that an ethereum transaction transfers ether from one account to another account.
this is di erent from bitcoin and other blockchains whose transaction can encode multiple coin transfers.
this di erence renders the existing architectures to batch transfers in non ethereum blockchains inapplicable to batch invocations on ethereum.
to address the challenge we introduce two intermediaries between a caller account and a callee smart contract.
as depicted in figure they are a relay service o chain called batcher and an on chain component called dispatcher .
the batcher s job is to batch multiple invocation requests sent from the caller accounts and send them in a single transaction to the dispatcher which further unmarshalls the original invocations and relays them individual to the intended callee smart contracts.second the o chain batcher service need not be trusted by the callers who in a decentralized world are reluctant to trust any third parties beyond the blockchain .
defending against the untrusted batcher incurs overhead that may o set the cost saving from batching and instead result in net cost increases.
speci cally in our threat model the adversarial batcher is nancially incentivized to mount attacks and to modify forge replay or omit the invocation requests in the batch transaction for instance replaying atransfer of an erc20 token can bene t the receiver of the transfer.
to defend against the threat a baseline design is to run the entire transaction validation logic in the trusted dispatcher smart contract on chain which bloats the contract program and incurs overhead e.g.
to maintain additional program states .
our evaluation study in technical report shows this baseline denoted by b2 increases the net cost per invocation rather than decreasing it.
for secure and cost e ective batching we propose a security protocol that allows o chain dapp callers in the same batch to jointly sign the batch transaction so that the additional program states e.g.
the per account nonces as a defense to replaying attacks can be o oaded o ine and the dispatcher smart contract can be stateless rendering low overhead and positive net cost savings.
third batching requires waiting for enough invocations and can introduce delay to when the batched invocations are included in the blockchain.
for the many dapps sensitive to invocation timing e.g.
real time trading auctions and other defi applications such delay is undesirable.
to attain delay free batching we propose to use the transaction price to the rescue.
brie y ethereum blockchain admits a limited number of transaction per block and prioritizes the processing of incoming transactions with a higher price i.e.
the so call gas price which is the amount of ether per computation unit paid to miners .
thus our idea is to generate a batch transaction with a higher price so that it can be included in the blockchain more quickly and this saved time can o set the waiting time caused by batching resulting in an overall zero delay in blockchain inclusion.
we propose an online mechanism to conservatively batch invocations originally in one block and carefully set gas price of batch transactions with several heuristics to counter the limited knowledge in online batching.
systems solutions overall this work systematically addresses the challenges above and presents a comprehensive framework named b that incorporates the proposed techniques under one roof.
b includes the middleware system of dispatcher andbatcher and a series of policies that con gure the system to adapt the batching to speci c dapps workloads.
concretely the middleware system exposes knobs to tune the batching in timing how long to wait for invocations to be batched target invocations what invocations to batch and other conditions.
through this policies that range from conservative to aggressive batching are proposed so that the system can be tailored to the di erent needs of dapps.
for instance the dapps sensitive to invocation timing can be best supported by the conservative batching policy with minimal delay.
other dapps more tolerable with delays can be supported by more aggressive batching policies which result in a higher degree of cost saving.
we demonstrate the feasibility of b s middleware design by building a functional prototype with ethereum s geth b saving ethereum fees via secure and cost e ective batching of smart contract invocations esec fse august athens greece client .
particularly we statically instrument geth to hook the batcher s code.
we further address the integration of b with legacy dapps and the operational ethereum network by automatically rewriting their smart contracts.
brie y with batching the internal calls are sent from dispatcher instead of the original caller account which makes them unauthorized access to the original callee leading to failed invocations.
in b we propose techniques to rewrite callee smart contracts particularly their access control structure to white list dispatcher .
we acknowledge the recent ethereum development eip which if made into an operational ethereum network will facilitate b s integration without rewriting smart contracts discussed in 5and full details in technical report .
systematic evaluation we systematically evaluate the invocation cost and delay in b under both real and synthetic workloads.
first we build a fast transaction replay engine that executes transactions at a much higher speed than the transactions are originally included in the blockchain.
this allows us to conduct largescale measurements say replaying a trace of transactions that last for months in real life within hours in the experiments.
second we collect the trace of transactions calls under four representative dapps that is idex representing decentralized exchanges dex bnb and tether for tokens and chainlink for data feeding.
from there we build a benchmark of traces that can be replayed in our platform.
third we conduct extensive evaluations based on the developed platform i.e.
replay engine benchmarks and prototype we built .
the target performance metrics are the system s costs in terms of ether and gas and delays between invocation submission time and block inclusion time.
the result under the bnb token idex chainlink trace shows that b con gured with a time window of 120seconds to batch all invocations can save around .
of the gas per invocation of the unbatched baseline.
for delay sensitive dapps as evaluated under the workloads of tether tokens b saves .
.
cost at the expense of a delay of .
.
blocks.
contributions this work makes the following contributions security protocol we design a lightweight security protocol for batching of smart contract invocations in ethereum without trusting third party servers i.e.
the batcher .
the security protocol defends against a variety of invocation manipulations.
new techniques are proposed to jointly sign invocations o chain and validate invocations on chain without states against replay attacks.
cost e ective systems we design a middleware system implementing the above protocol and propose batching policies from conservative to aggressive batching.
particularly we propose an online mechanism to optimize the cost without delaying invocation execution.
we further address the integration with the current ethereum client by automatically rewrite smart contracts.
systematic evaluation we built an evaluation platform for fast and cost accurate transaction replaying and constructed transaction benchmarks on popular ethereum applications.
with a functional prototype of b we conduct extensive cost evaluations which shows b saves .
.
gas cost per invocation witha moderate minute delay and .
.
ether cost per invocation with a delay of .
.66blocks.
overall this work tackles the design tradeo among security cost e ectiveness and delays in batching invocations.
while the implementation and evaluation in this work are on ethereum we believe the design tradeo s and principles are directly applicable to ethereum forks e.g.
binance smart chain and generalizable to other smart contract platforms .
roadmap section 2formulates the research.
3presents the b s security protocol.
b s batching policies are described in .
5presents the smart contract rewriters to facilitate b s integration with legacy smart contracts.
6shows the evaluation results in cost and invocation delay.
related works are described in 7and conclusion in .
research formulation .
motivating example we use a real world scenario namely idex to motivate our work.
idex is a decentralized exchange protocol that allows owners of di erent erc20 tokens to exchange their tokens at the preferred price volume.
consider that account alice sells her tokens mtoken to another account bob in return of his tokens ttoken .t o do so alice makes an order to be taken by bob and alice bob is called a maker ataker .
the idex protocol is executed among six ethereum accounts include a maker account a taker account maker s token contract mtoken taker s token contract ttoken the core idex smart contract idex1 and idex1 s o chain owner idex2 .
the protocol execution is depicted and described in figure 2a.
in particular there are four types of transactions in idex that invoke smart contracts that is maker s taker s call to approve her his token contract i.e.
1and maker s taker s call to deposit toidex1 i.e.
2and idex2 s call to trade onidex1 i.e.
and maker s taker s call to withdraw i.e.
.
among the transaction triggered external calls trade is most intensively invoked.
as we examine the ethereum history via ethereum etl service on google bigquery .
of the invocations received by the idex1 contract from its launch on sep. to feb. are on trade .1more importantly thetrade invocations are so intensively issued that many of them wind up in the same ethereum block.
we measured the number of trade calls in the same ethereum block on the call trace above.
figure 2bplots the cumulative distribution of ethereum blocks by the per block call number.
for instance about of ethereum blocks have more than one trade calls in them of blocks have more than four trade calls and .
of blocks have trade calls.
if one batches the trade invocations of these ethereum blocks into a single transaction the transaction fee can be reduced to1 although it may incur additional costs for smart contract execution.
in general 1we did not take the idex transactions after feb. when idex s tra c started to decline and was then shadowed by other more popular dex such as uniswap .
here we stress that although our idex s trace ends in feb. as of this writing in may ethereum s transaction rate steadily increases over time.
particularly recent years see drastic rate growth as ether price soars since early .
this is veri ed by the more recent traces we collected in such as chainlink and tether tokens as in the cost evaluation in and also corroborates external ethereum exploration websites .
568esec fse august athens greece yibo wang qi zhang kai li yuzhe tang jiaqi chen xiapu luo and ting chenmtokenttokenidex12 blockchaindeposit2tradetransferfromwithdraw55 2a5atransfer4approve1makertaker idex2 orderbook a the idex system model and protocol the example scenario shows running idex among six ethereum accounts three user accounts maker taker andidex2 and three contracts mtoken ttoken andidex1 .
number of calls per block010203040506070percentage b distribution of trade calls over ethereum blocks in this gure x y .4means in .
of ethereum blocks the number oftrade calls per block is between 2and5.
figure idex protocol and call distribution over blocks.
the protocol execution in figure 2ainvolves ve steps the maker deposits her tokens to idex1 which invokes three functions 1maker.approve 2maker.deposit and 2a idex1.transferfrom maker dex1 .
the taker similarly deposits his tokens by issuing taker.approve taker.deposit andidex1.transferfrom taker dex1 not shown in the gure .
the maker and taker sends their respective selling and buying orders 3and to the o chain idex2 who match make orders in an order book.
the owner idex2 calls contract idex1 s function trade taker maker to execute the trade on chain.
the maker issues withdraw which further sends transfer calls 5a tottoken contract.
similarly the taker can submit calls to withdraw her tokens .
the icons used in the gure are by www .freepik .com.
for blocks with xtrade calls one can batch the calls into one transaction leading to an x fold fee reduction.
by plugging into xthe measurement results in figure 2b we can expect the overall fee saving in the case idex to be .
.
this is the saving from trade calls only.
note that because the original trade calls are in the same block batching them in a single transaction does not introduce additional delay inconsistency.
generally there are four types of batching strategies type s1 batch invocations of the same caller and same callee such as all trade calls from the same caller idex2 and sent to the same callee smart contract idex1 s2 batch invocations of di erent callers and the same callee such as all the deposit calls s3 batch invocations of the same caller and di erent callees and s4 batch invocations of di erent callers and di erent callees such as the approve calls in idex.
we mainly consider the general case of s4 in the paper and tailor the system to other invocation types in .
.
threat model recall the system model in figure 1that introduces the batcher anddispatcher as two intermediaries between caller accounts and callee smart contracts.
for generalizability our threat model considers an untrusted third party batcher .
for instance in the case of idex the batcher can batch approve deposit andtrade and does not require the trust from their callers.
the third party batcher can mount attacks to forge replay modify and even omit the invocations from the callers.
our model assumes unmodi ed the trust relationship among callers for instance if there is a counterparty risk between a maker account and a taker account in the vanilla idex the same trust remains in b .the smart contracts including both dispatcher and application contracts are trusted in terms of program security no exploitable security bugs execution unstoppability etc.
we also make a standard assumption on blockchain security that the blockchain is immutable fork consistent and sybil secure.
the underlying security assumption is that a deployed blockchain system runs among a large number of peers with an honest majority and compromising the majority of peers is hard.
this work is built on ethereum s smart contracts cost model and transaction model.
it treats ethereum s consensus and underlying p2p networks as a blackbox.
.
design goals baselines the design goal of b is this through batching invocations there should be a signi cant portion of the transaction cost saved .
cost saving for calling generic smart contracts .
generalizability while staying secure against the newly introduced adversary of o chain batcher .
security .
speci cally the cost saving goal is to reduce a signi cant portion of the gas cost per invocation via batching calls under the constraint of maximal transaction size.
the generalizability goal is that the system should work with the general case of batch type s4.
the security goal is to detect and prevent attacks mounted by the untrusted batcher and protect the integrity of invocation information.
there is limited research on batching smart contract invocations.
in table we compare b s research goal with the two baseline designs covering the existing research e.g.
airdrop batching which we will describe next.
b saving ethereum fees via secure and cost e ective batching of smart contract invocations esec fse august athens greece table b s design choices and related works generalizable cost saving baseline b1 baseline b2 b baseline b1 this baseline design of batching considers a special case.
suppose account ais about to transfer tokens to nother accounts b1 b2 ... bn.
instead of sending ntransactions account acan set up a smart contract cand send one transaction to cthat sends the ntransfers e.g.
by calling solidity s transfer function ntimes in one shot.
this is essentially the batching scheme used in existing works for airdropping tokens a common practice to give away free tokens .
while this scheme handles the case of a single sender a it can be naturally extended to support multiple senders a1 a2... .
in this case multiple senders calls approve to delegate their account balance to a smart contract c before ccan batch transfer tokens to multiple receivers.
overall this batching scheme is limited as it depends on erc20 functions approve transfer .
also it does not necessarily lead to cost saving as each transfer still incurs at least one transaction i.e.
approve .
the ibatch security protocol this section presents the design rationale protocol description its security analysis sketch and the resultant system design.
we defer the full protocol analysis to a. .
design space security cost tradeo batching framework we start by describing the design framework to support batching of invocations to generic smart contracts.
in this framework the batcher batches a number of invocation requests and sends them in a batch translation to the dispatcher smart contract.
the dispatcher extracts the invocations and relays them to the callee smart contracts.
in our threat model the batcher mount invocationmanipulation attacks.
to prevent a forged invocation the dispatcher veri es the signatures of the original callers.
baseline b2 to prevent replaying an invocation a baseline design b2 is to elevate a blockchain s native replay protection into the smart contract level.
speci cally existing blockchain systems defend against transaction replaying attacks by maintaining certain states on blockchain and check any incoming transaction against such states to detect replay.
for instance ethereum maintains a monotonic counter per account called nonce and checks if the nonce in any incoming transaction increments the nonce state on chain a false condition implies replayed transaction.
bitcoin maintains the states of utxo to detect replayed transactions.
in b2 we implement per account nonces in the dispatcher smart contract and use them to check against incoming invocations in order to detect replayed invocations.
a cost observation in our preliminary cost evaluation on ethereum we found a sweet spot that the batching framework without replay protection can lead to positive cost saving while adding the baseline design b2 of replay protection end up with a negative cost saving .
that is the overhead of maintaining nonces in smart contracts in b2 o sets the cost saving by batching invocations.thus in b we avoid placing nonces in dispatcher and focus on an o chain defense against invocation replaying.
with an untrusted batcher we assume every caller is online for an extended period that covers the batch time window its invocation is submitted.
we propose an o chain protocol in which callers interactively sign a batch transaction.
note that there is an alternative design that callers audit batch transactions after they are acknowledged from the blockchain however the audit scheme does not prevent only detects a replayed invocation.
.
protocol description the protocol supports the general case batching that is batching type s4 invocations.
suppose in a batch time window there are n invocations submitted from di erent callers.
the b protocol follows the batching framework described above and it works in the following four steps in the batch time window a caller submits the i th invocation request denoted by call i to the batcher service.
as in equation the request call icontains the caller s address public key account i callee smart contract address cntr i function name func i and argument list args i. with i2 there are nsuch invocations in the time window.
by the end of the batch time window the batcher prepares a batch message bmsg and sends it to the callers for validation and signing.
as shown in equation message bmsg is a concatenation of the nrequests call i s their caller nonces nonce i s and batcher account s nonce nonce b. then the batcher broadcasts the batch message bmsg in parallel to all ncallers of this batch.
each of the callers checks if there is one and only one copy of its invocation call 1in the batch message speci cally this is done by checking equality between nonce 1in the batch message and the nonce maintained locally by the caller.
after a successful check of equality the caller signs the message bmsg sign that is bmsg without callers nonces as shown in equation .
the caller signs bmsg sign using the private key in her ethereum account.
she then sends her signature to the batcher .
this step nishes until all ncallers have signed the message and return their signatures to thebatcher .
batcher includes the signed batch message in a transaction s data eld and sends the transaction called batch transaction to be received by the dispatcher smart contract.this is presented in equation 4where cais the address of smart contract dispatcher .
8i call i haccount i cntr i func i args ii bmsg call 1knonce 1kcall 2knonce 2k... kcall nknonce nknonce b bmsg sign call 1kcall 2k... kcall nknonce b 8i sig i si naccount i bmsg sign bsig sig 1ksig 2k... ksig n data hdispatch func bmsg sign kbsig i tx haccount b nonce b cad sig b value data i 570esec fse august athens greece yibo wang qi zhang kai li yuzhe tang jiaqi chen xiapu luo and ting chen caller caller batcherdispatchercall1 nonce1call2 nonce2bmsgsig1tx bmsg sign sig1 sig2 sig2figure generation of batch transaction o chain among batcher and two caller accounts on the blockchain in function dispatch func smart contract dispatcher parses the transaction and extract the original invocations call ibefore forwarding them to callees namely cntr iand func i. particularly smart contract dispatcher internally veri es the signature of each extracted invocation against its caller s public key this can be done by using solidity function ecrecover call i sigi account i .
if successful the dispatcher then internal calls the callee smart contract.
at last the callee function executes the body of the function under the given arguments args i. an example figure 3shows an example of the interactive signing process which involves n 2callers respectively sending two invocations.
the process is executed in ve messages among the two callers and the batcher o chain.
.
security analysis sketch the b protocol achieves invocation integrity against malicious batcher .
speci cally it prevents the batcher from forging or replaying a caller s invocation in a batch transaction.
it also ensures thebatcher s attempt to omit a caller s invocations can be detected by the victim caller.
in addition b can be extended to prevent a denial of service caller from delaying a batch.
b assumes the availability of batcher which is reasonable on today s highly available platforms e.g.
clouds .
brie y the security proof is due to the following intuition the hardness of forging replaying invocations and the hardness of omitting invocations without detection in b can be reduced to the unforgeability of digital signatures and the hardness of double spending attacks in the underlying blockchain.
the full protocol security analysis is in appendix a. .
system overview to materialize the protocol we design a middleware system atop the underlying ethereum dapp ecosystem.
speci cally the system runs the batcher middleware on an ethereum node e.g.
a geth client that is synchronized with an ethereum network.
the dispatcher smart contract runs on the ethereum network and forwards invocations to the callee smart contracts.
the o chain batcher is a middleware running on an untrusted third party host.
in general the batcher bu ers incoming invocations submitted by callers and under certain conditions as described below triggers the batching of invocations.
once a batch of invocations is determined the batcher jointly works with original callers to generate the batch transaction as described by the joint signing process in .
.ethereum networkfull node dapp jsweb3geth node modified block tx sync.batcher dispatchercallee contracts rewritten institutional callersrpcevm geth nodesigner figure retro tting b to ethereum based dapps the right hand side of this gure illustrates the general mechanism where the two dark shades are the core system components of b and the light shade is a statically instrumented ethereum full node running geth .
implementation to transparently support unmodi ed dapp clients we statically instrument geth s handling of raw transactions and expose hooks to call back the batcher s code that makes decisions on batching as will be described next.
speci cally the instrumented geth node unmarshalls a raw transaction received extracts its arguments places it in batcher internal bu er e.g.
bpool as will be described and makes essential decisions regarding which invocations to be included in the next batch transaction before actually generating and sending it as described above .
the statically instrumented geth node retains the same sendrawtransaction sendtransaction api and thus supports unmodi ed dapp clients.
next in we propose policies for batcher s decision making that strikes a balance between costs and delay.
to integrate b with legacy smart contracts we propose schemes to automatically rewrite smart contracts at scale which is described in .
4batcher s policies in this section we propose mechanisms and policies for the batcher to properly batch invocations for design goals in cost and delay.
we rst formulate the design goal of optimizing gas cost per invocation in the presence of the workload.
we then formulate the design goal of reducing ether cost per invocation without causing delay to when the invocation is executed on ethereum.
.
optimizing gas cost the degree of amortizing the cost by b is dependent on the number and type of invocations put in a batch.
in this subsection we propose a series of policies that the batcher can use in practice.
the motivating observation is that there is no single policy that ts all workloads and under di erent workloads the most coste ective policy may di er.
note that the cost unit we consider here is gas per invocation which measures the amount of computational load an ethereum node needs to carry out to serve an invocation .
the proposed policies may cause invocation delay and the policies are suitable for dapps that are insensitive to such delay.
policy wsec batching all invocations that arrive in a time window say wseconds .
in practice the larger wit is the more invocations will end up in a batch and hence the lower gas each invocation is amortized.
however a larger wvalue means the batcher needs to wait longer potentially causing b saving ethereum fees via secure and cost e ective batching of smart contract invocations esec fse august athens greece inconsistency and delay of invocation execution.
we will systematically study the cost delay tradeo when taking into account the factor of gas price in .
.
policy top batching only the invocations that are sent from one account such as the most intensive sender .
the motivation for this is that if all invocations needed batching are from one sender account the batch transaction of multiple invocations only needs to be veri ed for once thus eliminating the needs of verifying signatures in smart contracts and lowering the overhead.
in practice top 1can be toggled on top of a wsec policy.
for instance xsecond top 1means batching only the invocations that arrive in a w second window and are from the most intensive sender in that window.
whether the presence of top 1batching policy can actually lead to positive gas saving is dependent on workloads.
if there is an institutional account sending invocations much more intensive than others applying top 1can lead to su cient invocations in a batch and positive gas saving.
otherwise if the workload does not contain enough such invocations the batch may be smaller than the one without top which limits the degree of cost amortization.
policy min x only batch when there are more than xcandidate invocations in a batch time window.
the intuition here is that if there are too few invocations the degree of cost amortization may be too low and can be o set by the batching overhead to result in negative cost saving.
in the technical report we conduct cost analysis based on ethereum s gas cost pro le on di erent transaction operations and derive the minimal value of xshould be .
that is a batch is only bene cial when it has at least 5invocations.
.
optimizing ether cost with minimal delay in this subsection we consider a class of dapps notably defi applications that are sensitive to invocation timing.
in these dapps manipulating invocation timing or introducing invocation delay may cause consequences ranging from dapp service unresponsiveness to security damage e.g.
under the front running attacks .
thus we formulate the design goal to be optimizing ether cost per invocation without introducing any invocation delay.
we call the no delay policy described in this subsection by 1block.
note that in ethereum the ether cost of a transaction is the product of the transaction s gas and its gas price.
assume an oracle who can predict what invocations are included in a block without batching at the time when the invocations are submitted.
an ideal optimal o ine algorithm is to batch the invocations in a future block and generate a batch transaction.
if the gas price of the batch transaction is set to be higher than at least one transaction in that future block it is bound the batch transaction can be included in the same block with the unbatched case.
in other words no block delay is introduced.
we call this approach by o ine optimal batching as an ideal scheme.
in practice the batcher at the invocation submission time may not accurately predict when a block will be found and which block will include the invocation.
we propose a realistic online batching mechanism to reduce or eliminate the block delay.online batching w. minimal delay 1block we propose a system design of batcher atop an ethereum client extending its memory pool or txpool functionality.
we call this design by 1block.
we rst describe the proposed system design and then decision making heuristics.
in a vanilla ethereum client a transaction is rst bu ered in memory in a data structure called txpool is then selected by comparing its gas price against other transactions in the txpool by miners and is included in the next block.
in b the ethereum client running on batcher is extended with an additional memory bu er that we call bpool and that stores submitted invocations prior to the batch transaction.
thebatcher service continuously receives the submitted invocations of registered dapps and bu ers them into the bpool .t o manage and evict invocations the service periodically runs the following process every time it receives a block the service waits fordseconds and then executes procedure bpoolevict which produces a batch transaction to send to the ethereum network.
more speci cally the bpoolevict procedure reads as input the transactions residing in the txpool and the invocations residing in the bpool .
the procedure produces a batch transaction encoding selected invocations to be sent to the ethereum network.
there are two essential decisions to make by procedure bpoolevict c1 what invocations to be evicted from bpool and to be put in the batch transaction.
it also needs to decide c2 what gas price value should be set on the batch transaction.
in addition to c1 and c2 the batching mechanism can be con gured by d that is how long it waits after a received block to run procedure bpoolevict .
in the following we describe a series of policies to con gure c1 c2 and dof the batcher .
example we show an example process illustrated in figure it shows the timeline in which bpool on the batcher operates and interacts with the remote ethereum network.
at the beginning th second the batcher receives a block b0of transactions which evicts the transactions from txpool and leaves it of 10transactions.
also assume there are 10invocations in the bpool in the beginning.
on the d th seconds the service runs bpoolevict which results in a batch transaction of 3invocations.
it sends the batch transaction to the ethereum network.
as the gas price of the batch transaction is high it will be selected by the miners in the remote ethereum network upon the next block b1being propagated say on the th second.
if the next next block b2is found on the th second the batch transaction will be included in b2.
heuristics for c1 we propose to select the invocations in the bpool that have higher gas price than hsuch that the total gas of transactions and invocations whose prices are higher than h is under the block limit.
moreover the total gas of transactions whose prices are higher than h 1is above the block limit.
for c2 a baseline is to set a xed gas price for every batch transaction which does not re ect the price distribution in the current batch block and can lead to excessive cost.
we propose dynamic gas pricing policies where the price of a batch transaction is dynamically set to ensure low ether cost yet without delaying the block it will be included.
we propose two policies policy batch x the gas price of a batch transaction is set to be above x of the invocations in the batch.
572esec fse august athens greece yibo wang qi zhang kai li yuzhe tang jiaqi chen xiapu luo and ting chen bpoolevictbtxbpool txpoolminereth.
networktxpoolevicttxpoolreadblock b0txpoolevicttxpoolreadblock b1txpoolevicttxpoolreadblock b2batcher figure an example process of running bpool and its eviction on batcher .
policy block x the gas price of a batch transaction is set to be above x of the transactions in the block also including the invocations in the batch .
for instance suppose there are regular transactions included in a block and a batch transaction which consists of invocations.
the three invocations are associated with prices 9and10 and the regular transactions gas prices are ... .
with policy batch50 the batch transaction s price is .
with policy block the batch transaction s price is .
integrating ibatch with legacy smart contracts original functions 2contract token ... 4modifier noblacklisted assert !isblacklisted 6function transfer address to unit256 value noblacklisted super .transfer to value balances safemath.safesub balances value balances safemath.safeadd balances value rewritten functions byibatch 11modifier noblacklistedbyd address from assert !isblacklisted 13function transferbyd address from address to unit256 value noblacklistedbyd from assert m s g.sender!
dispatcher super .transferbyd from to value balances safemath.safesub balances value balances safemath.safeadd balances value listing rewriting application smart contract the example of rewriting an erc20 token.
running b with unmodi ed smart contracts on today s ethereum clients as of this writing in may would fail because the unmodi ed smart contracts do not authorize the unmarshalled invocations sent from dispatcher account.
thus b s integration with a legacy ethereum platform entails either rewriting dapps smart contracts e.g.
to whitelist dispatcher or patching the ethereum virtual machine evm inside an ethereum client.
for the latter we notice a recent ethereumdevelopment eip which would allow dispatcher to send an invocation with msg.sender remaining the original caller s account.
this eip currently in progress if made into the future evm would make it possible to directly integrate b with an operation ethereum network without rewriting smart contracts.
we discuss details in technical report .
in this section we focus on the current evm platform and propose smart contract rewriters.
we describe a source code rewriter in the next paragraph while leaving the proposed bytecode rewriter to technical report .
source code rewriter we rewrite the solidity code of a smart contract to whitelist the dispatcher account as follows.
given an application smart contract bar we create a new contract say barbyd to inherent contract bar.
we rewrite each function that contains