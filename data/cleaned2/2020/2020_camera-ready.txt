see discussions st ats and author pr ofiles f or this public ation at .researchgate.ne t public ation nil large scale detection of large variance clones conf erence paper august .
.
citations 42reads author s including yoshiki hig o the univ ersity of osak a publica tions citations see profile shinji k usumot o the univ ersity of osak a publica tions citations see profile all c ontent f ollo wing this p age was uplo aded b y yoshiki hig o on june .
the user has r equest ed enhanc ement of the do wnlo aded file.nil large scale detection of large variance clones tasuku nakagawa osaka university suita osaka japan t nakagw ist.osaka u.ac.jpyoshiki higo osaka university suita osaka japan higo ist.osaka u.ac.jpshinji kusumoto osaka university suita osaka japan kusumoto ist.osaka u.ac.jp abstract a code clone in short clone is a code fragment that is identical or similar to other code fragments in source code.
clones generated by a large number of changes to copy and pasted code fragments are called large variance modifications are scattered or large gap modifications are in one place clones.
it is difficult for general clone detection techniques to detect such clones and thus specialized techniques are necessary.
in addition with the rapid growth of software development scalable clone detectors that can detect clones in large codebases are required.
however there are no existing techniques for quickly detecting large variance or large gap clones in large codebases.
in this paper we propose a scalable clone detection technique that can detect large variance clones from large codebases and describe its implementation called nil.nil is a token based clone detector that efficiently identifies clone candidates using an n gram representation of token sequences and an inverted index.
then nil verifies the clone candidates by measuring their similarity based on the longest common subsequence between their token sequences.
we evaluate nilin terms of largevariance clone detection accuracy general type type and type3 clone detection accuracy and scalability.
our experimental results show that nilhas higher accuracy in terms of large variance clone detection equivalent accuracy in terms of general clone detection and the shortest execution time for inputs of various sizes mloc compared to existing state of the art tools.
keywords clone detection large variance clone scalability acm reference format tasuku nakagawa yoshiki higo and shinji kusumoto.
.
nil largescale detection of large variance clones.
in proceedings of the 29th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse .
acm new york ny usa 11pages.
introduction a code clone in short clone is a code fragment that is identical or similar to other code fragments in source code.
clones are generated by copying pasting and modifying code fragments for reuse .
clones are a major problem in software maintenance permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse august athens greece association for computing machinery.
acm isbn x xxxx xxxx x yy mm.
.
.
.
they lead to bug propagation.
therefore clone detection techniques which automatically detect clones in the target codebase are essential.
many clone detection techniques have been proposed and applied in applications such as refactoring debugging and mining software repositories .
it is important for clone detection techniques to detect clones that have been heavily edited.
a clone generated by inserting or deleting a large number of statements in one place in a copy andpasted code fragment is called a large gap clone .
such clones are common in software development and should thus be detected along with general clones.
wang et al.
pointed out that it is difficult for existing clone detectors to detect large gap clones they proposed a technique for detecting such clones and presented its implementation called ccaligner .
wu et al.
pointed out that ccaligner targets only clones in which statement insertion or deletion is made in a single place and cannot detect clones in which modifications are scattered .
they called the latter type of clone large variance clones and proposed lvmapper a clone detector for large variance clones.
it is also important for clone detection techniques to be scalable.
highly scalable clone detectors are required for analyzing largescale projects or source files in an inter project repository.
many scalable clone detectors have been proposed .
to achieve scalable clone detection sourcerercc and cloneworks use heuristics to reduce the number of code block comparisons needed to detect clones and saga uses a gpu to parallelize its clone detection process.
however clone detectors that can detect clones with a large number of edits fail for large inputs or require a long time to detect clones .
scalable clone detectors target only identical or strongly similar clones near miss clones .
they are incapable of detecting large variance clones in which many statements have been inserted or deleted.
therefore the scalable detection of largevariance clones is challenging.
in this paper we propose a scalable technique for detecting largevariance clones and describe its implementation called nil1 which uses an n gram representation an inverted index and the longest common subsequence lcs .
nilis a token based clone detector.
one of the features of large variance clones is that the order of many tokens is preserved i.e.
the common subsequence between token sequences of large variance clones is long .
hence to detect large variance clones nilmeasures the similarity between the token sequences of two code fragments based on the lcs.
in addition large variance clones share many consecutive tokens.
hence for scalable clone detection niluses an n gram representation of token sequences and an inverted index to reduce the number of 1a clone detector using n gram i nverted index and l cs.esec fse august athens greece tasuku nakagawa yoshiki higo and shinji kusumoto protected int run commandlinecmd try execute exe new execute new logstreamhandler this project.msg info project.msg warn exe.setantrun getproject exe.setworkingdirectory getproject .getbasedir exe.setcommandline cmd.getcommandline exe.setvmlauncher false return exe.execute catch java.io.ioexceptione throw new buildexception e getlocation aaaaaaaaaa a clone a protected int run commandlinecmd try execute exe new execute new logstreamhandler this project.msg info project.msg warn if serverpath!
null string env exe.getenvironment if env null env new string string newenv new string system.arraycopy env newenv env.length newenv ssdir serverpath exe.setenvironment newenv exe.setantrun getproject exe.setworkingdirectory getproject .getbasedir exe.setcommandline cmd.getcommandline exe.setvmlauncher false return exe.execute catch java.io.ioexceptione throw new buildexception e getlocation b clone b figure example of large gap clones code block comparisons needed to detect clones.
first niltransforms code blocks extracted from source files into token sequences and creates an inverted index from the n gram representation of the token sequences.
next it identifies the clone candidates for each code block using the code block and the inverted index.
finally it verifies the clone candidates by measuring the similarity between the code block and the clone candidates.
we evaluate nil s large variance clone detection accuracy general type type and type clone detection accuracy and scalability.
we compared nilwith existing state of the art tools namely lvmapper ccaligner sourcerercc andnicad .
the experimental results show that nilhas high precision of in large variance clone detection.
it also has high recall of as determined in our evaluation of large variance clone detection using a mutation technique.
in general clone detection the accuracy of nilis equivalent to that of the existing tools.
in addition we confirmed that nilhas high scalability it can detect clones faster than the existing tools for large inputs codebases with mloc .
the main contributions of this paper are as follows.
we proposed a scalable technique for detecting large variance clones.
the proposed technique identifies clone candidates efficiently by using an n gram representation of token sequences and an inverted index and verifies clone candidates precisely by measuring the similarity between token sequences based on the lcs.
we implemented the proposed technique as a tool called nil.the executable file is available at kusumotolab nil .
we evaluated the usefulness of nilthrough three experiments.
the results show that nilhas high large variance clone detection accuracy high scalability and equivalentgeneral clone detection accuracy compared to that of existing state of the art tools.
we have published our experiment data to facilitate replication studies.
the remainder of this paper is organized as follows.
section describes the definition of general clones large gap clones and large variance clones.
section 3describes nilin detail.
section gives an overview of our evaluation and presents the results.
section 5describes threats to validity.
section 6reviews related studies.
section 7concludes this paper with a discussion and suggestions for future work.
preliminaries .
definition a code fragment is a consecutive segment of source code.
it can be represented by the tuple f ile name start line end line .
a code block is a code fragment within braces.
this study treats a function which is a code block as a clone detection unit as done in previous studies .
clones are code fragments identical or similar to other code fragments in source code.
a pair of similar code fragments is called a clone pair.
clones are classified based on the degree of the similarity between them as follows.
type is an exact copy without modifications except for white space and comments .
type is a syntactically identical copy only variable types or function identifiers are different.
type is a copy with further modifications statements have been changed added or removed.
the minimum length of clones is the minimum number of lines that a code fragment must be to be treated as a clone.
it is often set to six lines or tokens .nil large scale detection of large variance clones esec fse august athens greece protected string getprompt inputrequestrequest string prompt request.getprompt if request instanceofmultiplechoiceinputrequest stringbuffersb new stringbuffer prompt sb.append enumeration e multiplechoiceinputrequest request .getchoices .elements booleanfirst true while e.hasmoreelements if !first sb.append sb.append e.nextelement first false sb.append prompt sb.tostring return prompt a clone a protected string getprompt inputrequest request string prompt request.getprompt string def request.getdefaultvalue if request instanceof multipleinputchoicerequest stringbuilder sb new stringbuilder prompt .append boolean first true for string next multipleinputchoicerequest request .getchoices if !first sb.append if next.equals def sb.append sb.append next if next.equals def ab.append first false sb.append return sb.tostring else if def !
null return prompt else return prompt b clone b figure example of large variance clones .
large gap clone a large gap clone is a clone generated by inserting or deleting a large number of statements in one place in a copy and pasted code fragment.
figure 1shows an example of large gap clones.
in this example a line if statement is inserted into clone a lines of clone b .
wang et al.
pointed out that existing clone detectors are incapable of large gap clone detection because most target to the detection of near miss clones .
wang et al.
defined largegap clone as follows.
consider two code blocks c1andc2with loc values of l1andl2 respectively where l1 l2.
let li lj i.e.
is the ratio of the code lengths of two code blocks .
if c1andc2 are type clones and the corresponding then these clones are large gap clones.
the clone pair shown in figure 1fits the definition of large gap clones because the ratio of the code lengths of clone a and clone b is .
wang et al.
proposed ccaligner a large gap clone detector.
ccaligner detects clones using a code window a code fragment composed of kconsecutive lines in a code block .
first ccaligner transforms code blocks into code windows.
then it identifies clone candidates as pairs of code blocks that share at least one code window with considering eedit distance.
finally it verifies clone candidates based on their similarity which is calculated as follows sim1c1 c2o jwc1 wc2j min1jwc1j jwc2jo where c1andc2are two code blocks and wc1andwc2are the corresponding sets of code windows respectively.
.
large variance clone a large variance clone is a clone generated by inserting or deleting many statements in various places in a copy and pasted code large gap cloneslarge variance clonestype 3clonesccalignerlvmapper nilallclonesfigure relation among clone types and target clone types for several tools fragment.
figure 2shows an example of large variance clones.
in this example statements have been inserted into and deleted from various places in clone a to create clone b. wu et al.
pointed out thatccaligner targets the detection of large gap clones making it incapable of large variance clone detection .
wu et al.
defined large variance clones as clones whose code length ratio is less than .
this means that large gap clones are a special case of large variance clones.
they proposed lvmapper a large variance clone detector.
figure 3shows that the relation among clone types and the clone types targeted by ccaligner lvmapper and nil.
ccaligner targets large gap clones whereas lvmapper andnil target large variance clones which include large gap clones.
lvmapper detects clones using code windows just like ccaligner .
its clone detection has three phases namely the locating filtering and verifying phases.
in the locating phase lvmapper identifies pairs of code blocks that share at least one code window as cloneesec fse august athens greece tasuku nakagawa yoshiki higo and shinji kusumoto locate filterclonecandidateverifyclone pairsourcecodetokenizedcode blockextract tokenizeselect eachcode blockn gramstokenizedcode blockinvertedindexn gramsn gramsn gramsgeneraten gramspreprocessing clone detectioncreategeneraten grams figure overview of nil candidates.
then in the filtering phase it calculates the proportions of common code windows for each clone candidate and removes clone candidates whose proportions are lower than filtering threshold .
finally in the verifying phase it verifies each clone candidate based on similarity measured using a common subsequence of lines between each clone candidate s code block pair.
approach figure 4shows an overview of the proposed technique.
the input is a set of source code files and the output is the clone pairs in the source code.
in the proposed technique large variance clones are detected based on the similarity between token sequences based on the lcs taking advantage of the fact that the order of many tokens in a large variance clone pair is preserved.
in addition largevariance clones share many consecutive tokens.
hence to achieve scalable large variance clone detection the proposed technique reduces the number of code block comparisons using an n gram representation of token sequences and an inverted index.
the proposed technique transforms code blocks in source code into token sequences in the preprocessing phase and detects clones by comparing the token sequences in the clone detection phase.
in this study we implemented the proposed technique as a tool called nil.nil is written in the kotlin language and currently targets only java source code.
the following subsections describe the preprocessing and clone detection phases.
.
preprocessing in the preprocessing phase nilextracts code blocks from the target source code and transforms them into token sequences.
nildoes not perform lexical analysis but simply divide each code block s text based on symbols e.g.
or braces white spaces or newlines as done by sourcerercc .
for example when the code block shown in figure a is transformed into the token sequence protected string getprompt inputrequest request .
.
.
.
protected string getprompt inputrequest request source codeprotected string getpromptinputrequestrequesttoken sequenceprotected string getpromptprotectedstring getpromptinputrequestprotectedgetpromptinputrequestrequest3 gramsdividegenerate gramsfigure example of generating grams with this transformation lexical analyzers for other languages do not need to be implemented to extend nil.
the token sequence transformation is fast because lexical analysis is not necessary.
in addition nilhas a relatively low rate of false positives because it does not normalize identifiers such as variable and function names.
however it may not detect clones whose identifiers have been changed i.e.
type clones .
we discuss the impact of the lack of identifier normalization in section .
next nilgenerates n grams from each token sequence.
an ngram is a chunk of consecutive ntokens.
figure 5shows an example of generating grams from the code block shown in figure2 a .
in this example three grams are generated from the five tokens on the first line in the code block.
even though largevariance clones include many modifications statement insertions and deletions many tokens other than the statements match consecutively i.e.
many n grams match .
therefore using n grams is effective for scalable large variance clone detection.
then nilcreates an inverted index from the generated n grams.
an inverted index is an information retrieval technology that allows the fast retrieval of documents that contains a word given as a query .
it is often used in clone detection techniques .nilnil large scale detection of large variance clones esec fse august athens greece code block clone paircode blockinvertedindex2.
createcode blockinvertedindex4.
create 2n .
clone detection5.
clone detection3.
clone detectioncode blockinvertedindex2n.
create......first groupsecond groupn thgroup1.
divide into n groupsallcode blocks figure concept of partial inverted indexes uses a dictionary whose keys are the hash values of n grams and values are the code blocks containing the corresponding n gram as an inverted index.
all code blocks containing an n gram can be quickly obtained by looking up the hash value of the n gram in the inverted index.
therefore a pair of code blocks that share an n gram i.e.
the pair is possibly a large variance clone pair can be obtained quickly using the inverted index.
however an inverted index consumes a lot of memory.
hence creating an inverted index from all code blocks may lead to large memory consumption.
to avoid this we apply partial inverted indexes .
code blocks are divided into several groups and an inverted index is created for each group i.e.
a partial inverted index instead of creating a single inverted index for all code blocks.
figure 6shows the concept of partial inverted indexes.
first code blocks extracted from source code are divided into ngroups step where nis set to a value such that the memory consumption of a partial inverted index is manageable.
next an inverted index is created from one group of code blocks step .
based on the partial inverted index created in step and all code blocks clone pairs between the code blocks in the group and all code blocks are detected in step the clone detection process is described in the following section .
.
steps and are performed for each group of code blocks.
.
clone detection after the preprocessing phase nilperforms clone detection using the inverted index created in the preprocessing phase and all code blocks.
clone detection is divided into three phases location filtration and verification as done by lvmapper .
first nilselects a code block from all code blocks prepared in the preprocessing phase as the target code block.
then in the location and filtration phases nilidentifies the clone candidates of the target code block using an n gram and the inverted index.
next in the verification phase nilverifies that the target code block and the clone candidates are clone pairs by calculating the lcs.
these phases arealgorithm clone detection input cis a list of tokenized code blocks c1 c2 cn inverted index iofc nfor size of n gram for filtering threshold for verifying threshold output all clone pairs cp cp for all each ciincdo location phase ccrepresents clone candidates cc forj 1ci len n 1odo ci j1 4isj th token in ci s token sequence n ram concat1ci j1 ci j ci j n 4o key hash1n ramo etis a function that returns values to which a given key is mapped in a given dictionary cc cc et1i keyo end for filtration phase for all each ccjinccdo common n rams is a function that computes the number of common n grams between two given code blocks cn common n rams1ci ccjo m min1ci len ccj leno f iltration sim cn 1m n 1o iff iltration sim then cc ccnfccjg end if end for verification phase for all each ccjinccdo lcsis a function that computes the length of the lcs between token sequences of two given code blocks lcs len lcs1ci ccjo veri f ication sim lcs len min1ci len ccj leno ifveri f ication sim then cp cp 1ci ccjo end if end for end for return cp performed for each code block to detect all clone pairs in the target source code.
algorithm 1shows the clone detection algorithm.
the three phases of clone detection are described in detail below.
.
.
location phase.
in the location phase nilcollects the clone candidates of the target code block using the inverted index.
lines in algorithm 1are the location phase.
first nil generates n grams from the token sequence of the target code block.
m n 1n grams are generated from a token sequence with length m. next a hash value is calculated for each n gram.
this hash value is used as a query when looking up valuesesec fse august athens greece tasuku nakagawa yoshiki higo and shinji kusumoto in the inverted index.
finally nilapplies the hash values to the inverted index and collects code blocks that contain the n gram whose hash value is the same as the given hash value.
the obtained code blocks are referred to as the clone candidates of the target code block.
.
.
filtration phase.
in the filtration phase nilremoves code blocks that unlikely to be clones from the clone candidates collected in the location phase.
lines in algorithm 1are the filtration phase.
it is necessary to reduce the number of clone candidates for scalable and fast clone detection because nilperforms the lcs calculation which is a time consuming process in the verification phase.
nilfilters clone candidates based on a feature of large variance clones.
as described in section .
the two code blocks of a large variance clone pair share a certain number of n grams.
if two code blocks share few n grams the pair is unlikely to be a large variance clone pair.
based on this feature nilcalculates f iltration sim defined below between the target code block and each clone candidate.
f iltration sim1c1 c2o common n rams1c1 c2o min1n rams1c1o n rams1c2oo common n rams1c1 c2o jn rams1c1o n rams1c2oj where c1andc2are two code blocks with lengths jc1jandjc2j respectively.
n rams1c1oand n rams1c2oare the numbers of ngrams generated from code blocks c1andc2 respectively.
because of the large number of statement insertions and deletions in largevariance clones the two code blocks may have significantly different token sequence lengths.
we use min in the denominator so that f iltration simcan be properly calculated even in such cases.
nilremoves clone candidates whose f iltration simis less than filtration threshold .
.
.
verification phase.
in the verification phase nilchecks whether the target code block and each clone candidate are a true largevariance clone pair.
lines in algorithm 1are the verification phase.
as mentioned in section .
.
one of the features of large variance clones is that the common subsequence between token sequences of large variance clones is long even if there are a large number of insertions and deletions.
therefore nilcalculates the lcs between the target code block and each clone candidate and measures the similarity of the pair based on the length of the lcs.
the similarity function veri f ication sim1c1 c2ois expressed as following veri f ication sim1c1 c2o lcs1c1 c2o min1jc1j jc2jo where c1andc2are token sequences with lengths jc1jandjc2j respectively and lcs1c1 c2ois the length of the lcs between c1and c2.
we use minas the denominator of the similarity function to detect large variance clones as done in the studies on ccaligner andlvmapper even if the lengths of the token sequences differ greatly.
other clone detectors also use the lcs to measure similarity.
however they calculate line based lcs whereas nilcalculates token based lcs.
in general the token sequence of a code block is longer than its line sequence.
the time complexity of a method for lcs calculation based on dynamic programming iso1jaj jbjo indicating a very long computation time for a large input size.
to reduce time complexity niluses the hunt szymanski algorithm .
with this algorithm nilcan calculate the lcs in o1rlogjaj jbjlogjbjo where aandbare token sequences jaj j bj andris the number of pairs of common tokens between aandb.
evaluation we evaluated nilin terms of large variance clone detection accuracy general clone detection accuracy and scalability.
in the following subsections we first optimize the n gram size based on a balance between recall and execution time.
next we evaluate large variance clone detection accuracy in terms of precision and recall.
then we evaluate general clone detection using two commonly used benchmarks.
finally we evaluate scalability by measuring execution time for various input sizes.
additionally we compare the above results to those for four state ofthe art tools .
table 1shows these clone detectors and their settings.
these settings were taken from the prior studies .
note that the threshold for verification of lvmapperis variable and that takes the following values depending on the number of the lines of clone l. if6 l lif10 l if20 l .
summary first we summarize the results of this evaluation.
we found that nil has high precision of and high recall of in largevariance clone detection.
these values are the highest among the tested large variance clone detectors .
in general type type and type clone detection nil s accuracy is equivalent to that of the existing clone detectors including large variance clone detectors and its precision is higher than that of large variance clone detectors.
moreover we confirmed that nil is the fastest at detecting clones in large codebases mloc among the tested clone detectors.
table settings for various clone detectors tool settings min length lines window size k lvmapper filtering threshold verification threshold is variable.
ccalignermin length lines window size q edit distance e min similarity.
sourcerercc min length lines min similarity.
min length lines max length lines nicad blind renaming identifier abstraction min similarity.nil large scale detection of large variance clones esec fse august athens greece .
parameter setting nilrequires three parameters namely nfor n grams filtration threshold and verification threshold .
we set to .
which is often used in clone detectors .
we set to .
as done forlvmapper .nmust be carefully selected because it has a large impact on performance e.g.
execution time and clone detection accuracy .
if nis set to a toosmall value the recall of clone detection will increase because more code blocks will share the same ngrams.
however because more code blocks are identified as clone candidates in the location phase the number of comparison targets in the filtration and verification phases increases resulting in a longer execution time.
therefore to optimize the n we executed nil with n 9and measured the execution time and clone detection recall for each nvalue.
we used bigcloneeval to measure recall.
bigcloneeval automatically measures the recall of clone detectors using bigclonebench .
table 2shows the results for each nvalue.
for n an increase innsignificantly reduces the execution time without lowering recall by more than one point compared to when n .
for n and execution time decreases but recall also decreases.
for n execution time does not significantly decrease.
therefore considering the balance between execution time and recall n 5is the optimal value.
.
large variance clone detection we evaluated the large variance clone detection accuracy of nil in terms of precision and recall and compared the results to those for existing large variance and large gap clone detectors namely ccaligner andlvmapper .
.
.
precision.
precision is the ratio of correct clones detected to all clones detected.
a clone detector with higher precision provides more accurate results.
in general precision is measured via a manual validation of the clones detected by the target tool.
in this study we used ant and maven used in the prior studies on ccaligner and lvmapper to measure precision .jdk1.
.
and opennlp also used in the above studies were not used here because we could not find the source code for jdk1.
.
which has table target systems system files loc ant .
.
maven .
.
471been end of lifed and we considered opennlp to be unsuitable for manual validation because it is a machine learning library whose source code is difficult to read e.g.
it includes repetitive array manipulation code .
we used the following procedure to measure the precision of each tool we input the target source code into each tool we randomly selected large variance clone pairs with more than ten lines for each tool and target system and we manually confirmed whether the clone pairs were correct.
to remove bias in the manual validation the detected largevariance clone pairs of a given tool were validated without knowledge of the tool used for detection.
table 3shows the number of files and total loc for ant and maven.
table 4shows the number of large variance clone pairs detected by each tool and the precision for each tool2.
the number of largevariance clones detected by nildetected was almost the same as that of lvmapper and more than that of ccaligner .
the manual validation results indicate that nilhad high average precision of whereas lvmapper andccaligner had low average precision values of about and respectively.
we considered this difference in precision to be due to lvmapper andccaligner normalizing the identifiers in code blocks.
after checking the largevariance clones detected by lvmapper andccaligner we found that code blocks with consecutive assignment statements such as constructors and consecutive if statements were incorrectly detected as large variance clones.
in contrast nil detected largevariance clones more precisely because it does not perform identifier normalization.
table large variance clone detection results tool system large variance clones precision nilant .
maven .
lvmapperant .
maven .
ccalignerant .
maven .
2manual validation descriptions are available at table recall and execution time results for each nvalue n type .
.
.
.
.
.
.
.
.
very strongly type .
.
.
.
.
.
.
.
.
strongly type .
.
.
.
.
.
.
.
.
moderately type .
.
.
.
.
.
.
.
.
execution time 24h 2h 13m 52s 21m 42s 5m 56s 2m 58s 1m 13s 1m 4s 1m 2s 57sesec fse august athens greece tasuku nakagawa yoshiki higo and shinji kusumoto in addition nilhad higher precision than that of lvmapper and detected a similar number of large variance clone pairs indicating that it can detect many large variance clones that lvmappercannot.
after checking large variance clones that nildetected butlvmapper did not we found that the large variance clone pairs share a small number of consecutive lines .lvmapper regards three consecutive lines in code blocks as code windows see section and identifies clone candidates based on these code widows.
therefore if a pair of code blocks shares a little or no code window lvmapper cannot detect the pair as a large variance clone pair.
in contrast nilcan detect such large variance clones because it uses an n gram representation of token sequences.
.
.
recall.
recall is the ratio of clones detected by a tool to the total number of true clones in the target codebase.
a clone detector with higher recall can detect true clones more exhaustively.
to evaluate recall all true clone pairs in the codebase are required.
however it is not realistic to manually check all code block pairs in the codebase to determine the total number of true clone pairs.
therefore we generated large variance clone pairs automatically using mutation techniques to evaluate recall.
mutation techniques are frequently used for clone detector recall evaluation .
the studies on ccaligner and lvmapper used them to evaluate large variance clone detection recall.
in this study we reproduced large variance clones by randomly inserting various numbers of statements into original code blocks i.e.
the largevariance clones are mutants of the original code blocks .
we targeted jdk6 and apache commons because they were used in the study on ccaligner .we randomly selected functions with lines in these systems as the original code blocks.
a minimum length of lines is often used for recall evaluation using mutation techniques .
we used a maximum length of lines because if the number of lines of the original code blocks is too large even if a large number of statements are inserted into the code blocks the generated clones will not be large variance clones.
for example if lines of statements are inserted into an original code block if the number of lines of a code block is the ratio of lines of the clone pair is and thus the clone pair does not satisfy the large variance clone definition.
to reproduce largevariance clone pairs one line statements were inserted into each code block at random locations.
clone pairs were generated per original code block for a total of clone pairs including large variance clone pairs3.
figure 7shows the recall of nil lvmapper and ccaligner for clone pairs generated by inserting various numbers of statements.
nildetected all generated clone pairs.
this is because even though many statements are inserted into a code block the order of many tokens between the large variance clone pair is preserved and thus the clone pair shares a certain number of n grams and has a long common subsequence.
in summary using n gram based clone candidate identification and token lcs based clone validation is effective in large variance clone detection.
on the other hand as shown in figure the recall of lvmapperandccaligner decreased with increasing number of inserted lines.
lvmapper can also detect clones in which a large number 3the generated large variance clone pairs are available at inserted linesrecall ccalignerlvmappernilfigure recall results for various numbers of inserted lines of statements are inserted because it verifies clones based on linebased lcs.
however our evaluation results show that the recall oflvmapper decreased with increasing number of inserted lines .
this is because lvmapper failed to identify many large variance clones in its locating phase.
lvmapper identifies a pair of code blocks that share several code windows see section as a clone pair.
therefore with increasing number of inserted lines the number of shared code windows decreases and thus lvmapper failed to identify a pair of code blocks as a large variance clone pair.
ccaligner uses e mismatch code windows to identify clone candidates and this affects its recall.
in addition ccaligner uses code windows in verification and thus fails to detect large variance clones.
.
general clone detection we evaluated the general type type and type clone detection accuracy of nilusing two benchmarks namely mutation framework and bigcloneeval .
in addition we compared the results of nilto those of existing state of the art tools namely ccaligner lvmapper sourcerercc and nicad .
.
.
mutation framework.
mutation framework automatically generates clone pairs based on mutation techniques.
we executed mutation framework with all the default settings and input the generated clones4into each clone detector.
table 5shows the results of recall for each tool measured by mutation framework.
nildetected all clone pairs generated by mutation framework.
table recall results for mutation framework tool nil lvmapper ccaligner sourcerercc nicad type .
.
.
.
.
type .
.
.
.
.
type .
.
.
.
.
4the generated clone pairs are available at large scale detection of large variance clones esec fse august athens greece .
.
bigcloneeval.
bigcloneeval automatically measures the recall of clone detectors using bigclonebench .
we also measured precision as done in the prior studies .
for each tool we randomly selected of the detected clone pairs from bigclonebench and validated them manually.
the clones were shuffled and the validation was conducted without knowledge of the clone source.
table 6shows the results of recall5and precision6for each tool on bigclonebench.
as shown nil has high recall of .
for type clone detection even though it does not normalize identifiers in the preprocessing phase.
nilhad the second highest recall of moderately type clones which contain large variance clones behind only lvmapper .this is because the verifying threshold of lvmapper is variable and in some cases it can be low as .
.
the precision see bottom of table of both lvmapper and ccaligner which are large variance and large gap clone detectors was low.
in contrast that of nilwas very high .
.
even though sourcerercc andnicad also had high precision they had poor large variance clone detection performance.
therefore compared to theexisting tools nilhas equivalent general clone detection accuracy and higher precision than that of theexisting largevariance clone detectors.
.
scalability we evaluated the scalability of nil using codebases with various sizes and compared the execution time of nilto those of the existing tools.
we used ijadataset a large inter project java dataset as done in the prior studies .
we created datasets with and mloc7.
we used cloc to measure 5note that in our experiments bigcloneeval reported different recall of the existing clone detectors from the prior studies.
type recall of several clone detectors was .
because bigclonebench contains faulty clone pairs .
6manual validation descriptions are available at 7these datasets and an executable file of nil are available at record .
naivefilteredlocated !
clone candidates code blocks110 figure growth in the number of clone candidates with the increased number of code blocks the loc of the datasets.
a computer with a quad core cpu and gb of memory was used for the evaluation as done in the prior studies .
table 7shows the execution times for each tool for various input sizes.
as shown the execution time of nilis the shortest for all input sizes.
even though both lvmapper andsourcerercc detected clones from the mloc codebases their execution times are longer than three days indicating poor scalability.
in addition ccaligner andnicad were not able to complete detecting clones from the and mloc codebases respectively indicating their limited scalability.
therefore nilhas the highest scalability.
moreover we examined how effective the location and filtration phases are for nil s scalability.
figure 8shows growth in the number of clone candidates with the increased number of code blocks.
note that this figure is a logarithmic graph.
naive is comparing table recall and precision results for bigclonebench tool nil lvmapper ccaligner sourcerercc nicad type recall .
.
.
.
.
type recall .
.
.
.
.
very strongly type recall .
.
.
.
.
strongly type recall .
.
.
.
.
moderately type recall .
.
.
.
.
precision .
.
.
.
.
table scalability results tool nil lvmapper ccaligner sourcerercc nicad m 10s 29s 52s 3m 1s 1m 48s m 1m 38s 13m 38s 26m 3s 27m 37s m 1h 38m 29s 17h 23m 39s 19h 38m 5s m 7h 40m 7s 3d 13h 47m 39s 5d 6h 55m 1s esec fse august athens greece tasuku nakagawa yoshiki higo and shinji kusumoto all pairs of code blocks for clone detection8.
as shown both the location and filtration phases reduced the number of clone candidates drastically.
for example when there were code blocks the number of clone candidates was reduced from in naive to about one thirty in the location phase.
in the filtration phase their number was further reduced to about one thirty fifth from the location phase.
therefore the two phases reduced their number to about one thousandth from naive and very effective for scalable clone detection.
threats to validity to measure precision for each tool we manually validated clones each tool detected as done in the prior studies .
because the clone detector names were not disclosed during the manual validation there was no bias in the evaluation.
however because the criteria for whether a pair of code fragments is a clone pair can vary manual validation by other researchers may yield different values.
to ensure the validity of this study the clones used in the manual validation are made public so that a third party can conduct replication studies.
we used the widely used benchmarks bigcloneeval and mutation framework to evaluate the recall of clone detectors.
different results may be obtained using other benchmarks .
it is known that the accuracy and execution time of a clone detector is greatly influenced by its settings .
in this study we optimized the nvalue for n grams.
however the filtration threshold and the verification threshold were set based on values used by other clone detectors.
the results can be improved by optimizing these values for nil.
related work .
complicated type clone detection in addition to large variance clones because detecting complicated type clones is difficult several techniques specialized for detecting them have been proposed.
program dependence graph in short pdg is frequently used for complicated type clone detection.
krinke was the first to use pdgs for clone detection .
his technique detected isomorphic parts of pdgs as clones.
he reported that pdg based clone detection was good at recall and precision.
zou et al.
pointed out that pdg based clone detection techniques have still been quite time consuming and missed many clones due to their exact graph matching using subgraph isomorphism.
they proposed ccgraph using an approximate graph matching algorithm based on the reforming weisfeiler lehman graph kernel .
intermediate representation in short ir is also used for complicated type clone detection.
several syntactical differences e.g.
for loop and while loop in source code are transformed into the same or similar instructions in irs of the source code.
caldeira et al.
proposed a clone detection technique using irs .
they devised a c like ir based on llvm and ran nicad on it.
their experimental results suggested that irs were beneficial for improving clone detection and had a large impact on complicated type clones.
8the curve can be represented using y x1x 1o 2quadratic function where x is the number of code blocks and y is the number of clone candidates.machine learning is also useful for complicated type clone detection.
saini et al.
proposed a clone detector oreo for weakly type clones .
it combines machine learning information retrieval techniques and software metrics to detect clones.
however those three techniques based on pdg ir or machine learning do not always detect large variance clones.
for example a prior study showed that oreo has higher precision but lower recall in large variance clone detection than those of lvmapper .
moreover these techniques require a long execution time and thus are limited in scalability.
pdg based clone detection requires a long time to construct pdgs and perform subgraph isomorphism.
ir based clone detection requires a long time to transform source code into irs.
machine learning based clone detection is necessary to complete training before clone detection.
.
scalable clone detection kamiya et al.
proposed ccfinder and its successor ccfinderx .ccfinder transforms the target source code into a token sequence normalizes identifiers and then uses a suffix tree algorithm to detect matching token sequences as clones.
as shown in prior studies ccfinderx has high scalability and can detect clones even for a mloc codebase.
ishihara et al.
proposed a scalable method level clone detection technique .
the technique hashes each normalized method and detects methods whose hash values are the same as clones.
they detected clones in a large codebase mloc in .
hours.
hummel et al.
proposed conqat an index based clone detector.
conqat creates clone indexes by hashing consecutive six lines of source code and detects the clone indexes whose hash values are the same as clones.
conqat is capable of distributed processing in clone detection so that it can be applied for ultra large codebase .
gloc using cluster computing.
however those scalable clone detectors cannot detect gapped clones due to their algorithms.
though there are several tools for scalable near miss clone detection they still cannot detect complicated type clones including large variance clones.
in this study we proposed nil which achieves both large variance clone detection and scalability.
conclusion in this study we proposed a clone detection technique for the scalable detection of large variance clones from a large codebase and described its implementation called nil.nil uses n grams an inverted index and the lcs to detect large variance clones .our experimental results show that nilhas higher precision and recall in large variance clone detection than those of existing largevariance and large gap clone detectors.
in addition the general clone detection accuracy of nilis equivalent to that of existing state of the art tools.
moreover nilcan detect clones from large codebases more quickly than do existing clone detectors.
as future works we consider research on software engineering applications such as code recommendation and completion refactoring and bug propagation for large variance clones using nil.nil large scale detection of large variance clones esec fse august athens greece