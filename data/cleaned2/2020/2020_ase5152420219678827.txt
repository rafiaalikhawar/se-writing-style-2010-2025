faster mutation analysis with fewer processes and smaller overheads bo wang1 sirui lu4 yingfei xiong4 feng liu1 1school of computer and information technology beijing jiaotong university beijing china 2beijing key laboratory of traffic data analysis and mining beijing china 3caac key laboratory of intelligent passenger service of civil aviation beijing china 4key laboratory of high confidence software technologies peking university moe beijing china 5department of computer science and technology eecs peking university beijing china wangbo cs bjtu.edu.cn lsrcz xiongyf pku.edu.cn fliu bjtu.edu.cn abstract mutation analysis is a powerful dynamic approach that has many applications such as measuring the quality of test suites or automatically locating faults.
however the inherentlow scalability hampers its practical use.
to accelerate mutationanalysis researchers propose approaches to reduce redundantexecutions.
a family of fork based approaches tries to share identical executions among mutants.
fork based approachescarry all mutants in one process and decide whether to fork new child processes when reaching a mutated statement.
themutants carried by the parent process are split into groupsand distributed to different processes to finish the remainingexecutions.
however existing fork based approaches have twolimitations the limited analysis scope on a single statementto compare and cluster mutants prevents their systems fromdetecting more equivalent mutants and the interpretationof the mutants and the runtime equivalence analysis introducesignificant overhead.
in this paper we present a novel fork based mutation analysis approach winmut which groups mutants in a scope ofmutated statements and removes redundant computationsinside interpreters.
winmut not only reduces the number ofinvoked processes but also has a lower cost for executing a singleprocess.
our experiments show that our approach can furtheraccelerate mutation analysis with an average speedup of .57xon top of the state of the art fork based approach accmut.
index t erms software testing dynamic analysis mutation analysis mutation testing fork based mutation analysis i. i ntroduction mutation analysis is a dynamic program analysis approach based on fault seeding.
to perform mutation analysis we first make simple syntactic changes to create a set of faultyprograms called mutants.
then we execute these mutantsagainst the test suite and compare the results with the resultof the original program.
mutation analysis is originally designed for mutation testing i.e.
evaluating the capability of a test suite for revealingfaults .
in mutation testing the mutantsare treated as seeded faults.
the more mutants a test suitedetects the more effective it is.
besides evaluating test suites these two authors contribute equally to the work.
corresponding author.
this work is supported in part by the national key research and development program of china no.
2019yfe0198100 national natural sciencefoundation of china under grant nos.
.mutation analysis has been applied to many software engineering problems.
for example mutation analysis is used toautomatically locate faults for relieving debugging burdens .
mutants can be treated as not onlypatches in automated program repair butalso substitutions of real world bugs when they are hard tocollect .
recently some research fields such as smartcontract and deep learning adopt mutation analysisto enhance system quality.
despite the promising prospect shown both in software engineering research fields and industrial applications mutation analysis is still limited by its scalability issues.given a test suite with ntest cases and a program with m mutants for each test case the standard mutation analysis mustinvokemprocesses to execute the mutants.
this procedure results in m nexecutions.
although some trivially equivalent mutants can be filtered during compile time mcould still be very large with the program size scaling up leadingto unaffordable costs in practice.
as a result many approaches have been proposed to enhance scalability.
a basic method is to reduce run timecosts by removing redundant computations.
among them afamily of fork based mutation analysis approaches tries to reduce redundant executions among mutants.
a fork basedapproach invokes a single process to carry the executionof all mutants.
once it encounters a mutated statement itdecides whether to fork new child process es to carry subsetsof the active mutants carried by the current process.
split stream execution which is an early fork basedapproach always forks child processes to carry the mutantswhen it executes a mutated statement for the first time.
itshares the common executions of a mutant with the originalprocess before the first mutated statement is executed.
acc mut the state of the art approach of the family reducesredundancies by clustering mutants from the same mutatedstatement which are equivalent modulo the current state.
concretely accmut starts a process representing all mutants shares the same executions before mutated statements as split stream execution.
when the execution reaches a statement withmutants accmut interprets each active mutant of the statementand collects their output states.
accmut clusters the mutants 36th ieee acm international conference on automated software engineering ase 36th ieee acm international conference on automated software engineering ase .
ieee .
ase51524.
.
.
ieee that have the identical output state i.e.
equivalent modulo state and forks a set of child processes.
each process carries the mutants in a cluster.
in this way accmut can share theremaining executions among the mutants in a cluster.
the overall running time of fork based mutation analysis approach can be roughly modeled as the product of thenumber of processes and per process running time.
however the existing approaches are not optimal in the two aspects number of processes the existing approaches missed a lot of opportunities to share the executions of themutants.
per process running time accmut relies on an interpreter to handle the mutations introducing large over head.
let us consider the number of processes first.
for example in the following code snippet with mutants m m2 and m3 there are extra redundancies that are not recognized by accmut.
a b c m1 b c m2 b c d a e m3 a ereturn d in accmut these mutants will be separated into different child processes because m1andm2result in two states where the values of bare distinct and m3is located in a different statement.
this is not the optimal solution.
as only the variable daffects the execution henceforth the difference in the values of bwill not affect the remaining executions so it should not be included in state comparison.furthermore after excluding bfrom the state comparison we can find that the mutants from two different statements i.e.
m 1andm3 can be equivalent.
more generally mutants in a larger scope with different program states could ultimately beequivalent.
a better solution for this case is to use the currentprocess to carry the original program and m and fork a child process to carry m1andm3.
extending the equivalent mutation recognition scope is non trivial as we need torecognize the effective set of program variables to do the state comparison and we need to carefully design the algorithmto avoid introducing too much extra run time overhead.
for the per process running time the overhead introduced by the current approaches is dramatically significant.
to man age many mutants in a single process the existing approachesinstrument code and use an interpreter to handle the mutatedstatements and the overhead is getting more significant as thealgorithm for identifying the equivalent mutants at run timeis getting more complex.
accmut for example reports thatit executes 78x more statements for a process approximately.this constant overhead introduced by the interpreter cannotbe ignored.
we notice the sparsity of mutated statements ofa single mutant in the first order mutation analysis scenario that is a mutant only contains one mutated statement.
basedon this we find that for a child process with only a subsetof all the mutants the statements could be executed withdifferent policies interpret the statements that are affectedby some mutant i.e.
the slow way and execute other state ments directly with the compiled original version i.e.
the1uint foo int a int b int sum a b m1 a b m2 a b m3 a b int avg sum m4 sum m5 sum int c bar avg bar is side effect free return c m6 c 7void test assert foo result figure a motivating example.
there are mutants generated on the two expressions in the function foo.
fast way .
the implementation is non trivial when combinedwith extended analysis scopes.
we designed a fast algorithmto analyze the set of statements that are safe to be executedwith the compiled original version and we designed the datastructures and instrumenting methods to support the runtimeselection of execution policies.
we implemented our approach in winmut as an ll vmir based mutation analysis framework.
we have evaluatedwinmut on large scale real world c programs with morethan million mutants and tests.
the evaluation showswinmut further accelerates mutation analysis with a geometricaverage speedup of .57x on top of the state of the art ap proach accmut.
winmut is open source and is available at therepo ii.
m otiv a ting example in this section we describe the general idea of our two optimizations.
we describe how a fork based mutation analysisalgorithm operates on the program in fig.
.
the code in fig.
first calculates the average avg ofaand b line then invokes the function bar to get the result c and finally returns c. to make the example simpler we assume that there are not mutants inside of bar and it is side effectfree so that it will not change the value for sum andavg.
there are mutants generated on the code snippet.
m m2 andm3change the expression at line from a b toa b a b and a b respectively.
m4andm5change the expression at line from sum to sum and sum respectively.
m6changes the value to be returned at line from ctoc .
driven by the input we perform standard mutation analysis split stream execution accmut and our approach winmuton the program respectively.
we first demonstrate how theseapproaches execute on line and how winmut reduces thenumber of processes.
then we show how these approachesexecute on line and how winmut avoids the overhead insidethe interpreter.
a. fewer processes the execution of a program can be viewed as a sequence of state transitions.
fig.
shows the state transitions of these approaches from the very beginning to line .
we use thefunctions mapping variables to their values to represent thestates.
interpret interpretsplit splitinterpret interpretpartition sum a b partition sum avg a b split split interpretinterpret partition avg split line line line line line line line line line execute executeline line line 0 1 sum mapsto 3 sum mapsto 5 sum mapsto 2 sum mapsto avg mapsto 4 sum mapsto avg mapsto 6 sum mapsto avg mapsto 7 sum mapsto avg mapsto 9 avg mapsto 10 avg mapsto 8 prime sum mapsto ori m m m mapsto m mapsto m mapsto m mapsto prime prime sum mapsto mapsto ori m m m mapsto m1 mapsto m2 m prime sum mapsto ori m mapsto m mapsto m mapsto avg mapsto ori m mapsto m mapsto m mapsto prime prime sum avg mapsto mapsto ori m mapsto m4 mapsto m5 prime sum mapsto m1 mapsto avg mapsto m1 mapsto prime prime sum avg mapsto mapsto m1 prime sum mapsto m3 mapsto avg mapsto m3 mapsto prime prime sum avg mapsto mapsto m1 prime avg mapsto ori m mapsto m mapsto m mapsto m mapsto m mapsto m mapsto prime prime avg mapsto mapsto ori m mapsto m1 m m m m e program states the variables after interpret but before partition are illustrated as a mapping from mutants to values.
some mutants are grouped because in split stream execution or accmut they are not generated on the current statement in winmut they are handled with specialized data structures which we will elaborate later.
after partition the partitioned states are illustrated as tuples of variables and the values are illustrated as mappings from tuples of values to sets of mutants .
such as aandb some unnecessary variables omitted in the states.
figure the procedure of standard mutation analysis split stream execution accmut and winmut on the code in fig.
.
the procedure of handling a statement is decomposed into primitives.
the circles represent the states after handling each statement.
the squares represent the states after the primitives.
states with the same labels are identical.
in the figure the arrows stand for the transitions of states.
we abstract the execution of fork based mutation analysis with an execution engine.
the execution engine can be viewedas a virtual machine and is transparent to the program.the execution engine could execute the statements by justdelegating to the physical machine the fast path or interpretthe statements with the internal states stored in the engine the slow path .
for readability we use circles to representstates at the statement level i.e.
the states after the executionengine fully executed a statement and use squares to representinternal states between primitives inside an execution engine which is transparent to the program .
in the figure the stateshaving the same name are identical.
in other words havingthem in multiple processes is redundant and is a waste ofcomputing resources.
fig.
a represents the procedure of standard mutation analysis.
to collect the results of the mutants m m6 and the original program ori standard mutation analysisseparately compiles programs and runs them against thetest suite in a brute force fashion.
as we can see thereare considerable redundant state transitions.
for example 6transitions to 0before line and line transitions from 6to the end in the processes of m2 m4are redundant.
to remove redundant executions fork based approaches are proposed to execute multiple mutants in a single process andsplit the execution stream into child processes when necessary.to execute a batch of mutated statements in one process theexecution engines of fork based approaches support a morecomplex design of state.
in standard mutation analysis a statemaps a variable to a value for example sum .
while in fork based approaches a state maps a variable to a functionwhich maps a set of mutants to a value which we call a multivalue variable.
for example in the state prime 0in fig.
b sum is mapped to the function which consists of mappings i.e.
ori m m mapsto m mapsto m mapsto m mapsto and the value of sum for the mutant m3is prime sum m .
equipped with multi value variables we abstract conceptually atomic operations used by fork based mutation analysisinto the following primitives.
execute for delegating to the physical machine to execute the original statement interpret for executing a set of active carried by the current process mutated statements of the same lo cation and updates the states with multi value variables partition for partitioning the mutants into equivalence classes by the states of multi value variables split for splitting the execution stream into child processes to finish remainder executions.
fig.
b represents the procedure of split stream execution.
in split stream execution the execution engine starts a main process carrying all mutants m m6 and the original program ori .
when the main process reaches the mutatedstatement line the execution engine enters the interpreterand invokes interpret to evaluate versions of line which transforms the state to an internal state prime .
the engine performs split to fork child processes for each mutant and continues the execution of the main process.
the main processsimilarly proceeds line where more child processes areforked for m 4andm5respectively.
although split stream execution significantly removes the redundant states beforethe first mutated statement e.g.
redundant transitions to it cannot reduce redundant states after the first mutated statement.
fig.
c represents the procedure of accmut.
it extends the split stream execution s algorithm with the ability to mergemutants.
like split stream execution accmut also carriesall mutants with the main process.
when the main processreaches line the execution engine interprets the mutatedstatements.
the difference arises after interpreting whereaccmut further invokes the primitive partition with all accessible variables sum a and b .
in fig.
the variables used to perform partition are marked in green color.
the primitive partition clusters the states of these variables into equivalent classes and then each class is split into a newchild process.
in this way m 2andm3can share the executions of equivalent mutants modulo the current state in a process.similarly at line accmut performs partition against the states of sum avg a b and forks child processes form 4andm5respectively.
although accmut saves execution effort between m2and m3 it is still not good enough.
accmut is unable to merge equivalent mutants generated on different locations.
forexample m 4and m2 m are located at different statements and they would be separated into two child processes becausethey have different program states after executing line .however if we further execute the mutants we find that the3 mutants finally step into the same state 6under the given input which implies that these mutants could be carried byone process and share the remaining execution.
accmutdoes not analyze what program variables affect the final result and can only merge mutants that result in an identical state.for instance m 1and m2 m would step into 4and 6 respectively.
so they cannot be executed in one process inaccmut.
however referring to fig.
we find that the differentpart in 4and 6 the program variable sum does not affect the final result.
so it is safe to ignore this difference andexecute the mutants in a single process.
fig.
d shows the execution of our approach winmut.
referring to the executions of accmut though some mutantsare from different lines or in different states they produce theinterpretline a accmut b winmut a b c a m4m5m1m2 m3 b c a a b c a a d e f g h iline execute partition m1 m5split figure redundant primitive invocations.
the contents of the states a b are not needed so we leave them abstract.
same output after executing several statements further.
thus tomerge more mutants winmut tries to postpone the timingto perform partition andsplit and conservatively figure out the variables that may affect the test result to per form partition.
winmut continuously interprets a scope of statements e.g.
line until it reaches a statement thatchanges control flow e.g.
the function call at line whereit should perform partition andsplit.
we decide to split at control flow statements to avoid maintaining call stacks andpath conditions which may lead to more complex states andmore significant overhead.
moreover at line the remaindercode only depends on the variable avg which can be figured out by static analysis.
so winmut only clusters the activemutants against the state of the variable avg which enables it to merge more mutants with possibly different programstates.
for example m 4andm5are clustered into a group though the values of sum are different sum m 7 sum m .
based on our innovations m1 m5are all merged into one process which significantly reduces thenumber of processes.
b. faster processes we compare the state of the art approach accmut with ours to illustrate how winmut avoids redundant invocations of high cost primitives.
fig.
a shows the executions of childprocesses after line in accmut and winmut.
in the previoussub section accmut forks child processes carrying a setof mutants to continue the execution.
when these processesreach a new mutated statement at line the execution enginestill enters the interpreter performs the sequence of high costprimitives that is interpret partition andsplit.
however by the definition of the first order mutation analysisthat each mutated program can have one mutated statement these child processes definitely would not contain mutatedstatements at line .
in other words these invocations of theinterpreter primitives are unnecessary.
fig.
b shows how winmut executes after line in the child process.
winmut s execution engine figures out thatthe child process has already carried mutants and directlyperforms execute against line .
to support this winmut 384maintains a global set containing all the statements that need to be interpreted and the set is updated when it performs split.
more concretely when winmut performs split during interpreting line it dynamically analyzes the statements thatwould be affected by the active mutants m m5 and sets the global set to these statements line .
when the childprocess reaches line it finds the line does not belong to theset and executes it as is.
thus in this example winmut avoidsthe high overhead introduced by the interpreter.
this optimization is non trivial when combined with extended analysis scopes for two reasons we need to analyzethe set of statements that is safe to be delegated to the physicalmachine and we need to make sure that the delegationpreserves the semantics.
unlike the accmut in which theexecution engine does not hold any internal states beyond theboundary of a statement and is automatically transparent to theprogram our approach needs to use specialized data structuresto make the execution engine transparent and compatible withboth interpreter and the physical machine.
we will elaborate on our efficient implementation later.
iii.
m ethodology a. definition and notation in this subsection we define a set of necessary concepts and notions which enable us to describe from an abstract view.for conciseness we adopt some necessary definitions from theaccmut paper .
a program pcan be viewed as a set of locations and a mutation function pmaps each location to a set of variants.
each variant vconsists of a code block denoted as v.code which is either the original code block of the location or amutated one.
let the function ori map a location to the variant containing the original code block.
by the definition of first order mutation analysis a mutant is a program with only onemutated location.
each mutant has a unique mutation id i. let the function map a location land a mutation id ito a variantv denoted as l i v meaning that the mutant i should use the variant vat the location l. given a program p let be all the possible states and l be its location set.
let the function lmap a state to a location of pto be executed similar as the program counter.
the execution of a program can be viewed as a sequence ofstate transitions from the initial state to the terminal state which means the process is finished.
in standard mutation analysis a state is a function mapping variables i.e.
storage units to values i.e.
numbers denotedas s z. heresis the universal set of the storage units of a physical machine which includes not only the programvariables in the ram but also the files stored in the harddrive or other resources provided by the os.
they could behandled by lazily mapping to the ram.
however in fork based mutation analysis as a process may execute a set ofvariants at a location a variable may come from the results ofthe executions of different variants.
let a multi value variable demoted as mvv be a map from mutants to values denoted asmvv m z wheremis the universal set of the mutantsofp.
thus the state in fork based mutation analysis of a program pcan be defined as a function maps variables to mvvs denoted as s uniontext l p uniontext v p l uniontext z z v mapsto z .
the state of standard mutation analysis is a special case ofthe fork based state whose mvv only contains one mapping meaning that the variable only has one value and this mappingmaps a variant set of size one.
to manipulate the multi value variable equipped states we define three operations project restrict and update.
given a multi value variable equipped state and a mutant i let the operation project return the state where all multi value variables are reduced to single value variables corresponding to i denoted as i. for example given the state a mapsto b mapsto ori mapsto m mapsto w eh a v e m1 a mapsto b mapsto .
as a convention we will use to denote the projected states where all variables map to single values.
given a state and a variable set v the operation restrict denoted by vgets the partial state that only contains the mappings of the elementsinv.
the operation update denoted by vreplaces the value of the variable oin to the value v wherevcould be either a mapping from mutant to values or a single value.
given a variant v and a state the primitive execute v.code executes the code block v.code under the state and updates the state in place.
the function evaluate v.code evaluates vbased on and returns the output state without updating the state in place.
execute andevaluate requires that all the input variables for vare single value.
b. models of existing f ork based approaches based on the notations and definitions we model the existing fork based mutation analysis approaches in this section.
different from the standard mutation analysis in fork based mutation analysis we may execute more than one variant for the locations or execute a variant based on different programstates.
these locations should be interpreted by the execution engine.
to perform interpretation fork based approaches in voke a procedure called proceed which implements their core algorithms.
the main loop of fork based mutation analy sis can be modeled as algorithm .
first the execution engineinitializes the set gwhich is used to control whether a location is executed by interpretation or delegation to the physicalmachine and activates all the mutants line .
the processloops as long as there is a location to be executed line .
ateach step the execution engine first picks the location to beexecuted line then analyzes whether the location shouldbe interpreted or executed by the physical machine line .
split stream execution and accmut initialize gby calling the procedure initialize which adds all the mutated locations ofp and will not change ganymore.
so the execution engine interprets the location by the procedure proceed if the current location is mutated line otherwise delegates itto the physical machine by the primitive execute line .
385input p a program data the program state initialized by test input data g a set of locations should be interpreted by the current process data i a set of mutation ids of the current process 1g initialize p 2i all mutant ids of the program 3while negationslash do 4l ifl gthen proceed l else execute ori l .code end 10end algorithm main loop of fork based mutation analysis.
in split stream execution the procedure proceed invokes the primitive interpret andsplit in turn.
that is it filters active mutants of the location l then executes the code block for each mutant and records the affected values for each mutant and finally forks new child processes for each mutantto finish the remainder executions.
accmut optimizes the procedure proceed of splitstream execution by inserting an invocation of the primitivepartition between interpret andsplit.
the primitivepartition builds equivalent classes based on the states of active mutants and performs split for each equivalent class rather than a single mutant.
in this way accmut mergesthe mutants in the equivalent classes in a process and sharestheir remainder executions.
as aforementioned accmut suffers from two limitations unable to share the executions of mutants which are fromdifferent locations or step into different states introducingconsiderable overhead by unnecessary entering proceed too many times.
to overcome the limitations we present winmut which reduces the number of processes and cuts down theexecution overhead.
c. fewer processes input l the current location data the current state data i a set of mutation ids of the current process data g a set of locations should be interpreted by the current process data cfg the control flow graph 1interpret l 2ifneed split l then 3o output variable l cfg 4x partition o split x 6pid getpid ifis child process pid then g the forward slice of the locations of the mutants in i end 10end algorithm algorithm of proceed in winmut.the general idea of using fewer processes is to enlarge the range of analysis rather than perform partition and split at each location only cluster the mutants based on a set of necessary variables i.e.
a partial state .
the procedure proceed of winmut is shown in algorithm .
first the execution engine performs interpret against the active mutants based on the current state line .
theinterpret primitive evaluates each active mutant and maintains them as multi value variables in the program state.
if the current location is a point to perform split line the execution engine filters the variables which may affectthe test result by the global control flow graph cfg line .
note that these variables can be selected by compile timeanalysis which is a sound analysis by picking out all variablesthat may affect the result.
based on the live variable set o it performs the primitive partition on the partial state owhich only contains the mappings of the variables in o line .
then the execution engine groups the mutants intoequivalent classes by comparing their partial states.
at last it performs the primitive split for each equivalent class it forks a new child process to carry the mutants of the class andfinish the remainder executions.
the scope of continuously interpreting is controlled by the procedure need split .
in general more mutants could be merged into the same equivalent class when the execu tion engine postpones performing partition andsplit.
however we can not neglect the overhead introduced byevaluating and maintaining the multi value variables becausethe primitives interpret partition and split are operated on complex data structures.
this requires us to finda reasonable timing to perform partition andsplit.f o r example if we maintain the multi value variables in differentexecution paths the multi value should be further mapped bypath conditions which leads to unaffordable overhead.
thuswe decide to partition and split when the location is a controlflow statement such as branch statements and function calls.the results of need split l can be statically decided during compile time.
d. faster processes the second improvement intends to speed up per process execution by removing redundant interpretations.
the following facts inspire us a massive number of child processesare forked once a child process is split the mutantscarried by it only affect a limited range of locations thathave to be interpreted and execution is much faster thaninterpretation.
our basic idea is to interpret the locations that must be interpreted and execute other locations in child processes.refer to the previous section each new child process is splitbased on a partial state i.e.
a smaller mapping from variablesto values and we only need to interpret the locations whichhave active mutants and a slice of these locations.
shown as algorithm the entrance of the interpreter is controlled by the global set g which is initialized by the procedure initialize p .
in split stream execution and 386accmut gcontains all the mutated locations of pin all processes.
to selectively interpret in winmut initialize p adds the forward slice locations of all mutants of p which can be decided during compile time.
the forward slice is the set of locations that depend on multi value variables.
note thatthe primitive split converts multi value variables to singlevalue ones so the slice will not cross a split point.
furthermore split stream execution and accmut do not updategduring execution.
in contrast once the primitive split is invoked winmut filters g in child processes leaving only the locations which have the active mutantsof the current child process and the dynamic forwardslice of these locations shown in line of algorithm .because winmut performs split splits at every controlflow or pointer access statement which occurs frequently the dynamic slice of the locations will not be so large.consequently gis sharply reduced to a few locations in a child process.
e. basic primitives we abstract necessary primitives from the operations required by fork based mutation analysis approaches.
these primitives including execute interpret partition andsplit are atomic operations.
the execute primitive directly delegates a code block to the physical machine andupdates the program state in place which does not need moreexplanation.
input l the current location data i a set of mutants ids of the current process data the global program state 1 p an empty partial program state 2foreachi ido 3 evaluate l i .code i foreacho outvar l i do ifo p.variables then p p i mapsto else p i mapsto end end 11end 12foreacho p.variables do 13 p 14end algorithm the implementation of interpret.
theinterpret primitive evaluates a set of mutants and updates the program state with multi value variables shownas algorithm .
for each active mutant it first executes thevariant at the current location lwith mutant id ion the projected program state ito get the result state line .
then it updates the empty partial program state to ensurethat p i outvar l i outvar l i line where outvar means the output variables of a variant.
at last it writes the variables in the partial program state back to theglobal program state line .
algorithm shows the partition primitive which clusters the active mutants into equivalent classes based on theinput p the input partial program state data i a set of mutants ids of the current process 1x empty map from projected partial program states to mutant sets 2foreachi ido 3 p i if x.keyset then x x i else x i end 9end 10returnx algorithm the implementation of partition.
projection of the input partial state.
for each mutant i it first get the projection of the input partial state line .
then theprimitive tries to find the equivalent class that ibelongs to and adds it to that class line .
then it returns the partitionresultx line .
input x a map from projected partial program states to mutant sets data i the set of active mutation ids of the current process data the global program state 1foreach x.keyset do 2m x 3pid fork ifis child process pid then foreacho .variables do end i m return end 11i i m 12end algorithm the implementation of split.
algorithm shows the primitive split which splits executions into child process es for each equivalent class.
foreach key i.e.
a projected partial program state in x it gets the corresponding set of mutants m line and forks a new process line .
for the child processes the primitive updatesthe variables line then sets the mutants represented bythe child process to m line and returns line .
for the parent process it just removes m from the active mutants of the current process line .
note that although the algorithms conceptually iterate through a huge set i we can do some optimizations on this to iterate only through a subset of it and get the same result.we will elaborate on this later.
iv .
i mplement a tion in this section we present winmut implementation details.
same as accmut winmut is a first order mutation executionengine on ll vm ir that is each location contains an irinstruction.
ll vm ir is a high level intermediate representa tion ir which is the core concept of the ll vm compilerinfrastructure.
ir based mutation analysis approaches support 387table i mutation operators in winmut name description example aor replace arithmetic operator a b a b lor replace logic operator a b a b ror replace relational operator a b a b lv r replace literal value t t cor replace logical connector a b a b sor replace shift operator a b a b stdc delete a call f nop stds delete a store a nop uoi insert a unary operation b a a b a rov replace the operation value f a b f b a abv take absolute value f a b f abs a b multiple front end source languages without losing expressiveness.
particularly ll vm ir supports several mainstreamlanguages such as c c python objective c and cuda.recently researchers have proposed several ir based mutationapproaches including ll vm ir based and java bytecode based .
note thatour algorithm is general which can be applied on differentcode granularity e.g.
on instruction level expression level orstatement level.
a. mutation operators as each location holds an ir instruction in winmut we should employ ir based mutation operators.
we adopt the same set of mutation operators as accmut shown in table i.these mutation operators cover the mutation operators usedby the state of the art mutation analysis tools such as ma jor javalanche and srciror .
major is ajava source code level mutation analysis tool while javalancheis a java bytecode level one.
all their mutation operators areemployed except the java language specified ones.
srciroris the state of art ll vm ir based tool employing a set of4 mutation operators which is a subset of ours.
in addition these mutation operators are considered to be effective and arewidely used in existing approaches .
b. data structures and instrumentation although we have ensured that execute will not be used for an ir instruction affected by any mutation either is mutated itself or depends on any multi value variables weneed to ensure that if an ir instruction is executed by theprimitive execute the delegated physical instruction could manage the multi value variable data structure correctly and the interpretation effort should be as little as possible which can be realized by reducing the set of mutants to beinterpreted i.e.
iin algorithm .
for a mutated location we instrument the code as the following pseudo c code if l in g output vars of all mutants proceed l input vars of all mutants else output vars execute l input vars to make sure that execute works we cannot change the type declarations for the variables in the original code fromprimitive types to mappings to support multi value variables.instead we maintain the multi value variables as two parts original program variable and additional mapping.
in the instrumented code all of the variables are declared as theoriginal program and always hold a single value we call thisvariable the original program variable.
we maintain the valuesin the original program variable as if they are computed witha set of execute calls after the last split primitive call.
we associate each variable with an additional mapping inside of the execution engine.
we store those mutant valuepairs in it for those mutants with different values from theoriginal program variable.
a good property of this two partmulti value variable data structure is that we can treat single value variables and multi value variables in a unified way.
asingle value variable would have an empty mapping whilemulti value variables would have non empty ones.
if the location lholds no mutants and the input variables are all single value the output variables of proceed procedure will all be single value.
the proceed procedure does nothing but maintaining the original program variables.
so we cansafely replace that proceed toexecute and still keeps the multi value data structures valid.
this can also reduce the redundant interpretation in algorithm as what interpret does now is just computing the additional mappings for the output variables.
we do notneed to compute all the values for the mutants in the set i. those mutants that neither mutate the current location nor arepresented in any additional mapping for the input variablescan be skipped.
c. transparent i o system for f ork based mutation analysis another contribution of winmut is that we implemented a new i o system that is transparent to users.
some fork based mutation analysis tools rely on the posix system callfork to perform split executions.
although the copy onwrite mechanism of fork safely separates the virtual memory spaces between the parent process and the child process whichavoids copying the physical memory whose pages are notwritten it is unable to separate the i o handlers between theprocesses.
for example if the child process writes a file thatis inherited from the parent process not only the file contentis changed but also the file pointer of the parent processis moved.
to solve this problem accmut builds a memorymirror of all opened files that is it loads the whole file tomemory once it opens a file.
however accmut requires usersto manually modify source code to replace all i o operationswith theirs which needs considerable efforts.
it also restrictedthe available apis mostly to c standard i os.
to deal with therestrictions we implemented a memory based i o library thatcan be linked transparently to replace the i o system.
our library supports not only c standard i os to read or write a file but also many file system operations likeremoving creating the files.
however it would be infeasible forus to make the user space library conform to posix standardand work all the same as the os kernel.
there are also featuresimpossible for us to implement e.g.
we cannot support a 388program invoking execve orfork system calls.
we tried our best to make the memory based i o system robust enough to make sure it will not crash too many tests and affect ourmain result.
we have a lot of assertions in our library code trying to detect inconsistency and unsupported features.
when ourtool executes a program it would first execute the wholeprogram under the memory based i o library to detect if thereare any unsupported features.
if any unsupported feature isdetected or any assertion is violated the tool would skip themutation analysis on that program.
this makes sure that wecan successfully execute a test script if only a small portionof the programs would crash under our i o system.
in the future we may provide kernel support for the i o operations to make them identical to the existing apis butthis is beyond the scope of this paper.
v. e v alua tion we have evaluated winmut on a set of real world subjects many of which are large scale projects.
we aim to empiricallyanswer the following research questions rq1 how does winmut perform compared to the state of the art approach accmut?
rq2 how is the contribution of each optimization in winmut?
a. experimental setup we implemented winmut as a fork of accmut which is based on ll vm .
it is hard for us to manually modify thereal world projects to replace the i o operations and thereare many i o operations unhandled by accmut in the real world projects so we modified accmut and replaced the i ohandling module with our memory based i o library.
thisalso makes sure that the two tools share the same setting so we can compare the performance of the main algorithms.just as accmut we have not implemented the support forsome instructions required by c yet so we only considerc subjects to answer the research questions.
we select the subjects by the following criteria we only consider real world open source subjects that have developer written test suites the target subjects can be compiled by ll vm the application of the subjects should be diverse.
we selected projects and their properties are shown in table ii.
the column loc shows the lines of code withoutcomments and empty lines collected by the tool cloc.
the column mut bb split shows the number of mutants basic blocks split point of the subject.
a split point is a location toperform the primitive split.
the column mut per inst split is the average number of mutants for each instruction scopeof the locations corresponding to a split point.
these subjects contain in total more than .
million lines of code mutants basic blocks and 967split points.
on average each instruction holds .
mutants and each split point handles .
mutants.
moreover the subjects are from different fields.
binutilsgas is a portable assembler supplied by gnu.
coreutils is thegnu core utilities for manipulating files shell and text.
gmpis an arithmetic library supplied by gnu.
libsodium is anencryption library.
lz4 is a lossless file compression program.pcre2 is a regular expression parser that is compatible withperl.
libpng is the official png library.
lua is an interpreterfor the lua language.
grep is a utility for searching plain textdata.
ffmpeg is a tool for video and audio.
as some of the subjects are very large to complete the evaluation in a practical time budget we do not evaluate thetools on the whole test suite.
for each subject we executethe original test suite for seconds and record the coveredones as our activated tests.
we also skipped the tests requiringunhandled operations by our transparent i o systems.
thecolumn exec tests of table ii shows the number of executedtests.
note that due to the diversity of the projects theyhave very different organizations of test suites one test casereported by the build system may correspond to many smallertest cases written in the test framework.
we choose not to usethe test case number reported by the building system but countthe invoked program number for mutation analysis.
in total we collect tests in our evaluation.
note that although we only choose a subset of the tests they can bestill extremely time consuming due to the intrinsic high costof mutation analysis.
in our experiment the tests for libpngcovered within the execution of seconds would cost morethan days by accmut.
moreover in total a days run ofaccmut is large enough for evaluation.
following accmut to avoid the execution time influenced by process scheduling across multi core we serially executedtests without parallelization.
in addition we also limited thenumber of parallel processes to one for child processes.
that is each mutant in our experiment was executed serially.
weran winmut times on each subject and record the averagetime.
all experiments were evaluated on an intel core i7 7700k cpu and 64gb memory with ubuntu .
l ts.
b. results and discussion rq1 comparison with the state of the art to answer the rq1 we compared winmut with the state of the art forkbased approach accmut in the following two aspects the overall execution time and the number of invokedprocesses.
the results are shown in table iii.
the columns t wand tarespectively show the overall execution time of winmut and accmut.
the column t a twshows the speedup of winmut over accmut.
while the columns p wand p ashow the invoked process number of winmut and accmut.
the column p w pa shows the percentage of process number of winmut over accmut.
the averages are computed as geometric mean.
first we analyze the results of execution time and we have the following findings winmut is faster than accmut on all the subjects with an average speedup of .57x winmut achieves a speedup higher than 10x on subjects namely gmp libsodium and lz4.
especially it hasthe maximum speedup of .88x on gmp 389table ii subject programs name loc exec tests mut b b split mut per inst mut per split binutils gas 299k .
.
coreutils 144k .
.
gmp 115k .
.
libsodium 45k .
.
lz4 13k .
.
pcre2 80k .
.
libpng 56k .
.
lua 16k .
.
grep 83k .
.
ffmpeg 032k .
.
total 584k .
.
table iii the total run time and the number of invoked processes of winmut and accmut subject tw to1 to2 ta ta to1 ta to2 ta tw pw pa pw pa binutils gas .62h .74h .75h .80h .
.
.
.
coreutils .92m .96m .94m .97m .
.
.
.
gmp .19h .10h .30h .26h .
.
.
.
libsodium .94h .28h .54h .17h .
.
.
.
lz4 .94h .15h .16h .94h .
.
.
.
pcre2 .62h .91h .64h .99h .
.
.
.
libpng .14h .71h .61h .60h .
.
.
.
lua .08h .38h .28h .57h .
.
.
.
grep .39h .19h .41h .28h .
.
.
.
ffmpeg .25h .34h .54h .64h .
.
.
.
total .21h .85h .29h .29h .
.
.
.
in the timing representation h m means hour minute.
winmut has a more significant speedup on computeintensive programs such as arithmetic and encryption libraries.
second we evaluate the ability of winmut to cluster more mutants.
we can observe that winmut consistently employs fewer processes than accmut on all the subjects winmut further reduces the number of invoked processes by .
on average compared with accmut.
rq2 contribution of each optimization winmut consists of individual optimizations i.e.
the one for mergingmore mutants and the one for operating more efficiently.these optimizations may have different effects on the overallspeedup and this question intends to detailed evaluate theircontribution.
to answer this question we conducted a con trolled trial.
that is we only activate one optimization andcompare the overall execution time.
table iii shows the results.
the columns t w to1 to2and tashow the execution time of winmut winmut with the first optimization for merging more mutants winmut withthe second optimization for more efficient execution andaccmut respectively.
the column t x tymeans the speedup of the technique yoverx.
we can make the following findings the second optimization boosts the execution the first optimization introduces speed reduction on the subjects gmp and libsodum and improve the perfor mance slightly on the remaining subjects except on the subject ffmpeg the second optimization contributes a higher speedup than the first one on allsubjects the speedup of the second optimization is closer to the final speedup of winmut the combination of the optimizations results in a better speedup than employing just one of them.
as discussed in the previous section merging more mutants involves heavier costs that would cover the benefits.
so itis reasonable that the first optimization slightly slows downthe execution on gmp and libsodium.
moreover the firstoptimization boosts more than the second optimization onthe subject ffmpeg for it merges more mutants accordingto table iii.
finally the final speedup can not be predictedby simply multiply the speedup results of the optimizations which implies the combination of the two techniques hascomplex mutual influence.
however the time required bywinmut is only of the time required by accmut second optimization which is very close to the process numberratio.
this indicates that the second optimization minimizes theimpact of mutant merging algorithms and makes it possible touse a more powerful algorithm in the future research to mergemore mutants without introducing too much overhead.
c. the robustness and impact of the memory based i o system to verify that our memory based i o system will not affect the main results we executed all test cases from the subjects and recorded how many test cases it passes.
in our experiment we are not counting the test case number reported by the script because each reported test case couldcorrespond to many smaller test cases.
we count how manytest programs are executed with our i o system.
for the time we only count the time for executing the subject program.
wedo not count the time for executing the external test framework e.g.
dejagnu or manually written test script .
390first we execute the whole test suite without our i o system record the total test cases number.
then we execute the whole test suite with our i o system.
if the test script does not finish normally we remove the failing test cases andthose test cases depending on them and restart until the testsremaining in the test script all pass.
then we record the process number.
we subtract this process number with the number ofprocesses with detected unsupported features and we get thetotal passing test cases.
then we rerun the current test script with and without our i o system and record the time.
the results are shown in table iv.
the running time is comparable indicating that ouri o library does not introduce too much overhead.
table iv passed cases and running time with without our i o lib without i o lib with i o lib subject cases time s cases time s binutils gas .
.
coreutils .
.
gmp .
.
libsodium .
.
lz4 .
.
pcre2 .
.
libpng .
.
lua .
.
grep .
.
ffmpeg .
.
we noticed that the library breaks some test cases in coreutils lua grep and ffmpeg.
coreutils is a library whosetest cases are testing all kinds of edge cases and we expectthat it would crash our library the most and we found thatourunlink implementation fails to handle some cases.
lua failed to execute some of the tests because they used fork.
grep and ffmpeg are querying unsupported files.
e.g.
ffmpegis trying to read dev urandom which is not supported.
vi.
r ela ted work in this section we first present related work on accelerating mutation analysis then we introduce related fields.
based onthe survey papers we can roughly divide exist ing approaches into static approaches and dynamic approaches.
statically accelerating mutation analysis.
static approaches intend to reduce the cost of mutation analysis without executing mutants against test suites.
basically static approaches aimto reduce cost during mutation generation and compile time.
several approaches use static analysis of compilers to remove the useless equivalent mutants orimprove the effectiveness .
as the costs of mutationanalysis are positively associated with the number of mutantsand the size of test suites existing approaches mainly focuson reducing them.
a popular class of methods is to select a subset of the mutants such as mutation sampling mutation cluster ing and mutation operator selection .
somecomprehensive approaches combining several techniques .
some approaches utilize machine learningmodels trained by real world bugs to prioritize the high quality mutants or focus on the newly committedcode .
some other methods analyze test suites such astest selection and figure out the reusable test results inregression testing .
some ml based methods try to predictthe results of mutants and avoid execution .
theseapproaches can be pre process filters and combined with ours.
dynamically accelerating mutation analysis.
as mutation analysis is a kind of dynamic approach essentially some existing studies aim to reduce runtime costs of mutationanalysis.
besides mutant reduction techniques themajority of dynamic approaches focus on reducing redundantcertain parts of mutation analysis.
some approaches intend to reduce compile time redundancies.
mutant schemata compiles all mutants once intoa single executable file.
some incipient approaches avoidcompile time costs in an interpreting fashion but theyare usually lumbered by the low efficiency of interpreters.
the prevalent dynamic method is to reduce redundancies during executing mutants.
split stream execution reduces the redundant executions before the first mutatedstatement.
just et al.
cluster mutants are test equivalent .accmut as mentioned before tries to further merge mu tants of the same states.
as discussed before our approachescould outperform these approaches.
higher order mutation analysis replaces more than one statement once in a program which is very differentfrom standard mutation analysis and some approaches aimto share executions in higher order mutation analysis .
finally some works resort the test cases to kill mutantsfaster .
these approaches are orthogonal to ours.
sharing executions in software product line testing model checking and symbolic execution.
similar ideas of sharing executions also exist in the fields of softwareproduct line testing model checking and symbolic executionapproaches which face the same challenge of redundancy.
a product in software product line can be treated as a higher order mutant .
v ariational execution maintains aset of multi value variable across the entire test execution toshare common executions .
these approachesaim to merge products i.e.
higher order mutants via purelyinterpreting which leads to significant overhead.
multi valued model checking supports variables in the finite state machine to be multi valued .
delta symbolicexecution shadow symbolic execution and multi path symbolic execution try to share common parts ofmultiple paths.
vii.
c onclusion in this paper we propose a novel approach to accelerate mutation analysis.
we take the existing fork based mutationanalysis approaches a step further by reducing the numberof invoked processes and removing redundancies insidethe execution engine.
we implemented our approach into thetool winmut.
the evaluation results show that our approachachieves an average speedup of .57x on top of the state of the art approach accmut.
391references r. a. demillo r. j. lipton and f. g. sayward hints on test data selection help for the practicing programmer computer vol.
no.
pp.
.
r. g. hamlet testing programs with the aid of a compiler software engineering ieee transactions on vol.
se no.
pp.
.
j. h. andrews l. c. briand y .
labiche and a. s. namin using mutation analysis for assessing and comparing testing coverage criteria ieee transactions on software engineering vol.
no.
pp.
.
l. inozemtseva and r. holmes coverage is not strongly correlated with test suite effectiveness in proceedings of the 36th international conference on software engineering.
acm pp.
.
t. t. chekam m. papadakis y .
le traon and m. harman an empirical study on mutation statement and branch coverage faultrevelation that avoids the unreliable clean program assumption in ieee acm 39th international conference on software engineering icse .
ieee pp.
.
m. kintis m. papadakis a. papadopoulos e. v alvis n. malevris and y .
le traon how effective are mutation testing tools?
an empiricalanalysis of java mutation testing tools with manual analysis and realfaults empirical software engineering vol.
no.
pp.
.
m. papadakis d. shin s. y oo and d. h. bae are mutation scores correlated with real fault detection?
a large scale empirical study onthe relationship between mutants and real faults in ieee acm 40th international conference on software engineering icse .
ieee pp.
.
m. papadakis and y .
le traon using mutants to locate unknown faults in icst pp.
.
s. moon y .
kim m. kim and s. y oo ask the mutants mutating faulty programs for fault localization in icst pp.
.
m. papadakis and y .
le traon metallaxis fl mutation based fault localization software testing v erification and reliability vol.
no.
pp.
.
s. pearson j. campos r. just g. fraser r. abreu m. d. ernst d. pang and b. keller evaluating and improving fault localization inproceedings of the 39th international conference on software engineering.
ieee press pp.
.
d. zou j. liang y .
xiong m. d. ernst and l. zhang an empirical study of fault localization families and their combinations ieee transactions on software engineering .
c. le goues m. dewey v ogt s. forrest and w .
weimer a systematic study of automated program repair fixing out of bugs for 8each in icse pp.
.
w .
weimer z. fry and s. forrest leveraging program equivalence for adaptive program repair models and first results in ase pp.
.
a. ghanbari s. benton and l. zhang practical program repair via bytecode mutation in proceedings of the 28th acm sigsoft international symposium on software testing and analysis pp.
.
r. just d. jalali l. inozemtseva m. d. ernst r. holmes and g. fraser are mutants a valid substitute for real faults in software testing?
infse pp.
.
z. li h. wu j. xu x. wang l. zhang and z. chen musc a tool for mutation testing of ethereum smart contract in 34th ieee acm international conference on automated software engineering ase .ieee pp.
.
q. hu l. ma x. xie b. y u y .
liu and j. zhao deepmutation a mutation testing framework for deep learning systems in 34th ieee acm international conference on automated software engineer ing ase .
ieee pp.
.
g. petrovi c and m. ivankovi c state of mutation testing at google in proceedings of the 40th international conference on software engineer ing software engineering in practice pp.
.
g. petrovic m. ivankovic b. kurtz p .
ammann and r. just an industrial application of mutation testing lessons challenges andresearch directions in ieee international conference on software testing v erification and v alidation workshops icstw .
ieee pp.
.
m. papadakis y .
jia m. harman and y .
le traon trivial compiler equivalence a large scale empirical study of a simple fast and effectiveequivalent mutant detection technique in icse pp.
.
k. n. king and a. j. offutt a fortran language system for mutationbased software testing software practice and experience vol.
no.
pp.
.
r. gopinath c. jensen and a. groce topsy turvy a smarter and faster parallelization of mutation analysis in icse pp.
.
s. tokumoto h. y oshida k. sakamoto and s. honiden muvm higher order mutation analysis virtual machine for c in icst pp.
.
b. wang y .
xiong y .
shi l. zhang and d. hao faster mutation analysis via equivalence modulo states in proceedings of the 26th acm sigsoft international symposium on software testing and analysis .
acm pp.
.
c. lattner and v .
adve ll vm a compilation framework for lifelong program analysis transformation in cgo pp.
.
f. hariri a. shi h. converse s. khurshid and d. marinov evaluating the effects of compiler optimizations on mutation testing at the compilerir level in ieee 27th international symposium on software reliability engineering issre .
ieee pp.
.
f. hariri and a. shi srciror a toolset for mutation testing of c source code and llvm intermediate representation in proceedings of the 33rd acm ieee international conference on automated softwareengineering pp.
.
m. papadakis t. t. chekam and y .
le traon mutant quality indicators in ieee international conference on software testing v erification and v alidation workshops icstw pp.
.
f. hariri a. shi v .
fernando s. mahmood and d. marinov comparing mutation testing at the levels of source code and compilerintermediate representation in 12th ieee conference on software testing v alidation and v erification icst pp.
.
t. t. chekam m. papadakis and y .
le traon mart a mutant generation tool for llvm in proceedings of the 27th acm joint meeting on european software engineering conference and symposiumon the f oundations of software engineering pp.
.
d. schuler and a. zeller javalanche efficient mutation testing for java in esec fse pp.
.
r. just f. schweiggert and g. m. kapfhammer major an efficient and extensible tool for mutation analysis in a java compiler in ase pp.
.
y .
jia and m. harman an analysis and survey of the development of mutation testing software engineering ieee transactions on vol.
no.
pp.
.
m. papadakis m. kintis j. zhang y .
jia y .
le traon and m. harman mutation testing advances an analysis and survey in advances in computers.
elsevier vol.
pp.
.
a. v .
pizzoleto f. c. ferrari j. offutt l. fernandes and m. ribeiro a systematic literature review of techniques and metrics to reduce thecost of mutation testing journal of systems and software vol.
p. .
a. j. offutt and w .
m. craft using compiler optimization techniques to detect equivalent mutants software testing v erification and reliability vol.
no.
pp.
.
m. kintis m. papadakis y .
jia n. malevris y .
le traon and m. harman detecting trivial mutant equivalences via compiler optimisations ieee transactions on software engineering vol.
no.
pp.
.
w .
e. wong and a. p .
mathur reducing the cost of mutation testing an empirical study journal of systems and software vol.
no.
pp.
.
c. ji z. chen b. xu and z. zhao a novel method of mutation clustering based on domain analysis.
in seke pp.
.
a. j. offutt g. rothermel and c. zapf an experimental evaluation of selective mutation in proc.
icse pp.
.
l. zhang s. s. hou j. j. hu t. xie and h. mei is operator based mutant selection superior to random mutant selection?
in proc.
icse pp.
.
m. gligoric l. zhang c. pereira and g. pokam selective mutation testing for concurrent code in proc.
issta pp.
.
m. jimenez t. t. checkam m. cordy m. papadakis m. kintis y .
l. traon and m. harman are mutants really natural?
a study onhow naturalness helps mutant selection in proceedings of the 12th acm ieee international symposium on empirical software engineeringand measurement pp.
.
j. m. zhang l. zhang d. hao l. zhang and m. harman an empirical comparison of mutant selection assessment metrics in ieee international conference on software testing v erification and v alidation workshops icstw .
ieee pp.
.
l. zhang m. gligoric d. marinov and s. khurshid operator based and random mutant selection better together in proc.
ase pp.
.
t. t. chekam m. papadakis t. f. bissyand y .
le traon and k. sen selecting fault revealing mutants empirical software engineering vol.
no.
pp.
.
w .
ma t. laurent m. ojdani c t. t. chekam a. v entresque and m. papadakis commit aware mutation testing in ieee international conference on software maintenance and evolution icsme .
ieee pp.
.
l. zhang d. marinov and s. khurshid faster mutation testing inspired by test prioritization and reduction in proc.
issta pp.
.
l. zhang d. marinov l. zhang and s. khurshid regression mutation testing in proc.
issta pp.
.
j. zhang l. zhang m. harman d. hao y .
jia and l. zhang predictive mutation testing ieee transactions on software engineering vol.
no.
pp.
.
j. zhang z. wang l. zhang d. hao l. zang s. cheng and l. zhang predictive mutation testing in issta pp.
.
c. a. sun f. xue h. liu and x. zhang a path aware approach to mutant reduction in mutation testing information and software technology vol.
pp.
.
c. a. sun a. fu x. guo and t. y .
chen remusse a redundant mutant identification technique based on selective symbolic execution ieee transactions on reliability .
r. h. untch a. j. offutt and m. j. harrold mutation analysis using mutant schemata in proc.
issta pp.
.
a. offutt vi and k. n. king a fortran interpreter for mutation analysis in acm sigplan notices vol.
no.
.
acm pp.
.
r. just m. d. ernst and g. fraser efficient mutation analysis by propagating and partitioning infected execution states in issta pp.
.
y .
jia and m. harman higher order mutation testing information and software technology vol.
no.
pp.
.
m. harman y .
jia p .
reales mateo and m. polo angels and monsters an empirical investigation of potential test effectiveness and efficiencyimprovement from strongly subsuming higher order mutation in ase pp.
.
c. p .
wong j. meinicke and c. k stner beyond testing configurable systems applying variational execution to automatic program repairand higher order mutation testing in proceedings of the 26th acm joint meeting on european software engineering conference andsymposium on the f oundations of software engineering.
acm pp.
.
r. just g. m. kapfhammer and f. schweiggert using non redundant mutation operators and test suite prioritization to achieve efficient andscalable mutation analysis in issre pp.
.
c. p .
wong j. meinicke l. lazarek and c. k stner faster variational execution with transparent bytecode transformation proceedings of the acm on programming languages vol.
no.
oopsla pp.
.
c. h. p .
kim s. khurshid and d. batory shared execution for efficiently testing product lines in ieee 23rd international symposium on software reliability engineering.
ieee pp.
.
j. meinicke c. p .
wong c. k stner t. th m and g. saake on essential configuration complexity measuring interactions in highly configurable systems in proceedings of the 31st ieee acm international conference on automated software engineering pp.
.
m. chechik b. devereux s. easterbrook and a. gurfinkel multivalued symbolic model checking acm transactions on software engineering and methodology tosem vol.
no.
pp.
.
m. d amorim s. lauterburg and d. marinov delta execution for efficient state space exploration of object oriented programs ieee transactions on software engineering vol.
no.
pp.
.
t. kuchta h. palikareva and c. cadar shadow symbolic execution for testing software patches acm transactions on software engineering and methodology tosem vol.
no.
pp.
.
k. sen g. necula l. gong and w .
choi multise multi path symbolic execution using value summaries in proceedings of the 10th joint meeting on f oundations of software engineering pp.
.