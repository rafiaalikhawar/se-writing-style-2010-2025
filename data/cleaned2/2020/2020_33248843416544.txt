predicting code context models for software development tasks zhiyuan wan zhejiang university hangzhou china wanzhiyuan zju.edu.cngail c. murphy university of british columbia vancouver canada murphy cs.ubc.caxin xia monash university melbourne australia xin.xia monash.edu abstract code context models consist of source code elements and their relations relevant to a development task.
prior research showed that making code context models explicitin software tools can benefit softwaredevelopmentpractices e.g.
codenavigationandsearching.
however littlefocushasbeenputonhowtoproactivelyformcode contextmodels.inthispaper weexploretheproactiveformation ofcodecontextmodelsbasedonthetopologicalpatternsofcodeel ementsfrominteractionhistoriesforaproject.specifically wefirst learn abstract topological patterns based on the stereotype rolesofcodeelements ratherthanonspecificcodeelements wethenleverage the learned patterns to predict the code context models for a given task by graph pattern matching.
to determine the effectivenessofthisapproach weappliedtheapproachtointeraction historiesstoredfortheeclipsemylynopensourceproject.wefound that our approach achieves maximum f measures of .
.
and .
for1 step stepand3 steppredictions respectively.
the most similar approach to ours is suade which supports stepprediction only.
in comparison to this existing work our approach predicts codecontextmodelswithsignificantlyhigherf measure .57over .
on average .
the results demonstrate the value of integrating historical and structural approaches to form more accurate code context models.
ccs concepts softwareanditsengineering developmentframeworks and environments human centered computing human computer interaction hci .
keywords context models task developer interaction context prediction acm reference format zhiyuan wan gail c. murphy and xin xia.
.
predicting code context modelsforsoftwaredevelopmenttasks.in 35thieee acminternational conferenceonautomatedsoftwareengineering ase september21 theworkwasdonewhenthefirstauthorwasaffiliatedwiththeuniversityofbritish columbia.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acmmustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
ase september virtual event australia association for computing machinery.
acm isbn ... .
virtual event australia.
acm new york ny usa pages.
https introduction asasoftwaredeveloperperformsadevelopmenttask shespends substantialtimesearchingandnavigatingthroughcodetounderstand relevant parts in a software system for that task.
meanwhile she forms in her mind an implicit code context model consisting of source code elements and relations between those elements relevant to the task .
when even a portion of such a model can be madeexplicit theinformationinthemodelcanbeusedinsoftware tools to benefit software developers and the software development project.forexample approachestomakeaspectsofcodecontext models explicit have shown promise to support searching activities toimprovecoderecommendations andtoimprove the quality of changes made to a system .
despitethepromiseofimprovingsoftwaretoolsusingexplicit codecontextmodels therehasbeenlittlefocusonhowtoproactively form these models to benefit a software developer as he works.
at present there are three approaches that have been used to capture and represent code context models.
first acodecontextmodelforataskcanbeexplicitlycreatedby the developer performing the task.
for example the codebasket tool enables a developer to capture explicitly her mental model as sheworkswithcode thisrepresentationcansupportsubsequent navigation of the code .
this approach requires the developer to expendextraefforttocreatethemodel.inanexploratorystudyconductedabout thecodebaskettool participants requestedsupport to automatically create or complete the representation.
second a code context model can be formed by utilizing informationaboutthestructureofthecode.forexample robillard describes analgorithm called suade thatleverages topologicalfeatures of the code structure to suggest a fuzzy set of potential code elements of interest for a code context model given elements already identified as interesting seed code elements .
this class ofapproachesdecreasestheeffortrequiredtocreateacodecontext model but still requires either additional effort on the part of a developer oraccesstootherinformation suchasdocumentation which can be difficult to obtain.
third a code context model can be formed based on the history of the software development project.
the history may describe which files were changed as part of a task as found in a source code repository or may contain information about both viewed andchangedfilesasfoundininteractionhistories orchange historydata .techniqueslikeassociationruleminingcanbe used against historical information to suggest what other code elements have been associated with given seed code element s in 35th ieee acm international conference on automated software engineering ase thepast e.g.
.theseapproachestendtotreatcodeelements involved in past changes as isolated with no relations rather than ones that have structural or other relations to other elements that comprisethesystem.thistreatmentofelementslimitstheability to form sufficiently complete code context models for tasks.
we believe the benefits of code context models can be increased by improving the proactive automatic formation of code context models as a developer works.
in effect the proactive formation wouldrepresentacollectionofothercodeelementsandrelationships the developer is likely to need to draw on to complete the task beyondarecommendationofwhatisthenextcodeelement forthedevelopertoconsider e.g.
.theproactiveformationof codecontextmodelscanenable toolstodrawuponthecontextof the workbeingperformed toimprove theaccuracy ofrecommendations whether for navigation searching or other reasons and to better speculate on and prefetch answers to questions a developer is likely to pose e.g.
amongst other potential applications.
byautomaticallyformingcodecontextmodels toolscanprovide these benefits at lower cost to the developer.
in this paper we explore how we can improve the proactive automaticformationofcodecontextmodelsbyinvestigatingwhether we can learn abstract patterns of how developers typically investigatestructurallyconnectedcodeelementswhenperforming tasksonasystem andthen2 usethelearnedpatternstopredict codecontextmodelsbasedonadeveloper snewinteractionwith the code for a system.
specifically we use interaction histories collectedasadeveloperworkstoformcodecontextmodelsatdifferent points of time in the development of a system.
we assign stereotypes to code elements in these code context models that representthebehavioralaspectsanddesignintentsoftheelements such aswhetheramethodisa getterorasetter.thestereotypesallow us to abstract away from specific code elements.
we then mine patterns across these abstracted code context models as each code contextmodelisagraph weuseagraphpatternmatchingapproach to support prediction.
our approach enables a d step prediction where the known code context model is expanded to include likely code elements of interest up to dsteps away in the structure from known code elements.
when presented with code element seedsas a developer works on a new task on the system we can apply the learned patterns to predict the future code context model.
the approach applies equally well at the start or middle of a task.
we applied this novel approach to interaction histories created and stored as part of the eclipse mylyn open source project.
wefound that our approach achieves maximum f measures of .
.33and0.21for step stepand3 steppredictions respectively.
the most similar approach to ours is suade which supports step prediction only.
in comparison to this existing work our approach predictscodecontextmodelswithsignificantlyhigherf measure .
over .
on average .
the results demonstrate the value of integratinghistoricalandstructuralapproachestoformingmore accurate code context models.
this paper makes three contributions we introduce a novel approach to forming code context modelsthatlearnsabstractpatternsofhowdeveloperswork with code as part of performing change tasks to a system.
we demonstrate that our approach can predict code contextmodels effectively achievingmaximum f measuresof .
.
and .
for step stepand3 steppredictions respectively.
weprovideadatasetthatincludes1 887codecontextmodels to enable future investigations by others1.
webeginbydescribingexistingworkintheareaofcodecontext models section2 .next wedescribeourapproachforforminga datasetusinginteractionhistories section3 andhelpingtoform code context models from interaction histories section .
we thenevaluatetheabilityoftheapproachtopredicttheevolution of code context models section .
we discuss the implicationsof results section and limitations of the approach section before concluding section .
related work many empirical methods in a variety of settings have been used to explore how developers understand code from investigating the comprehensionapproachestakenbydevelopers e.g.
tostudyinghowtheyinteractwithcodeandtools e.g.
astheyperform changetaskstoasystem.anumberofthestudiesperformedabout these phenomena find that developers spend a substantial amount oftimesearchingandnavigatingsourcecodetounderstandandlocate the relevant parts for a task.
to help developers perform these activities researchers have investigated several ways to capture andrepresentthecodecontextmodelsdevelopersmentallyform as they perform their work.
some of these efforts focus on saving code context models after the relevant code elements have been identified or navigated forworkbeingperformed.concerngraphs helpadeveloper manually capture and represent the relevant elements and rela tionships between them.
code bubbles propose a novel ide editor interface that allows a developer to create views of codefragments relative to work being performed.
codebasket enablesdeveloperstoexternalizetheirmentalmodelsbyproviding a canvas on which developers can arrange code elements.
these approachesspecializein savingthecodecontextmodels afterthe relevant code elements have been identified or navigated for work being performed.
we are interested in this paper in proactively formingacodecontextmodelsothatthemodelisavailablefora developerandtoolsto makeuseoftheinformation.moregeneral benefits possible from increasing the capture and use of contextin software development are provided elsewhere .
other efforts focus on automating the creation or otherwise lessening themanualburdenonadevelopertocapturecodecontextmodels.mylyn automaticallycreatesataskcontext which containsinformationrelevanttoacodecontextmodel fromadeveloper sinteractionswithcode.suade analyzesthestructural dependenciesofcodeelementsthathavealreadybeennavigated andidentifiesadditionalrelevantcodeelementsasthecontextforatask.ourapproachismostsimilartosuadeintheproactivegenera tionofcodecontextinformation.incontrasttosuade ourapproach uses information learned from historical information about how a developer has worked to predict potential code context elements.
810closely related to the formation of code context models are various recommendation approaches.
these approaches build on a variety of information to try to predict code that might be relevant toadeveloper s work.forexample deline etal.useinformation abouthowdevelopersnavigateacodebasetorecommendwhere adevelopershouldnavigatenext .otherapproachesuseprogramstructuralinformation textualsimilaritybetweencode elementsandtaskdescriptions versionhistories or acombinationofmultiplesources .ourapproachdiffersintwo ways.
first instead of aiming to produce a direct recommendation to the developer we predict what code matters for a task to inform and improve other tools such as the display of code or filtering of search results.
second our approach can leverage additionalcontext when expanding what a code context model may be by basing predictions on the graph structure of previous code context models.
ourapproachreliesontheuseofstereotyperoles togeneralize from specific code context models formed as a developer works to abstract forms that facilitate pattern detection.
we use these pat ternsasabasisforcompletingcodecontextmodelsbasedondevel oper s partialworkon atask.
priorstudies haveutilized stereotype roles for other purposes including generating natural language summaries for code in java and c programming languages feature location detecting code smells categorizing source code identifiers generating commit messages categorizing methods in unit tests and serving as an indicator of system design .
we are the first to use stereotype roles to summarize the behaviors of methods and classes in past code contextsandtothenusetheabstractedcodecontextmodelstosupport prediction.
code context model dataset toexperimentwiththeproactiveformationofcodecontextmodels we need a dataset of such models.
we form such a dataset using interactionhistories capturedasdevelopersworkwiththeeclipse mylyn open source project2.
we describe the data we extract from the project section .
and how we transform this data into code context models ready for experimentation section .
.
figure provides an overview of the process used to create the dataset.
the resulting dataset formed from this process is available online3.
.
data extraction thetoppartoffigure1describestheextractionofdatafromthe mylynsystemdevelopment.theeclipsemylyntoolrecordsinterac tionhistoriesasadeveloperworksonacodebase.eachinteraction history includes a record of the code elements that are viewed and edited by the developer.
mylyn enables one or more interaction histories to be associated with each task performed by developers on a system.
for the development of the mylyn tool interaction histories are stored with the tasks recorded in the eclipse bugzilla system.wechosetousethemylynprojectasthedatasourcefor our investigations because the project has collected interaction historiesforover15years andtheseinteractionhistoriesrepresent work of over developers.
we consider the threat to validity of our work from this choice in section .
bug report filtering.
to gather interaction histories we considered the fixedandclosed bug reports of the mylyn projectfromtheeclipsebugzillabugtrackerbetweenapril2004 and december .
from this set of fixed bug reports we filtered all bug reports that did not have one or more interaction histories associated with the report leaving bug reports to consider.
the bug reports have an average of .
interaction histories attached min max median sd .
.interaction trace extraction.
we extracted and used the last interactionhistoryassociatedwitheachofthesebugreports.we onlyconsideredinteractionhistorieswitheventsdirectlyrecording interaction with code elements selection and edit events about class method andfieldcodeelements .thefinaldatasetconsistsof valid interaction traces with an average of .
interaction events min max median sd .
.
.
code context model formation the bottom part of figure describes the formation from the extracted data into code context models.breaking interaction histories.
for code context models we areinterestedinrepresentingthemodelsthatdevelopersusually keepintheir mindsastheyworkwith code foratask.asa result weneedtobreakinteractionhistoriesintounitsthatmorelikely representaperiodoftimeinwhichadeveloperisworkingwiththe code and for which they may have formed a working mental code context model.
to capture such units we define the concept of a working period consisting of the portion of the interaction history consistingofeventswithintwohourtimeperiods.wechosetwo hours because an analysis of all of the interaction histories showed twohourswasthemeantimebetweentwoconsecutiveinteraction events in the histories.
by applying this step we formed working periods.
extractingcodeelements.
weareonlyinterestedininteraction histories4recording work with code elements as opposed to documentation or xml files.
thus we filtered for interaction histories accessing or editing java code elements as mylyn is predominantly written in java.
of the working periods we identified developersconsideredjavacodeelementsin2 726workingperiods .
.
structuraldependenciesbetweencodeelementsarenotavailable in interaction histories.
to capture structural information we needtobeabletorelateeachinteractionhistorytoversion s ofthecode activewhentheinteractionhistorywascollected.thus foreach workingperiod we1 resolvedthegitrepositoryforextractedcode elements extractedeventtimestampsfromtheinteractionhistory and associated each working period with code snapshot s .
resolving git repository.
weresolvedgitrepository repositories of accessed code elements for each working period as the mylyncodeisstoredacrossseveralgitrepositories.thisstepexcluded839workingperiodsthataccessonlycoarse grainedcodeelements 4in the remaining of this section unless otherwise mentioned we use interaction history to refer to a portion of an interaction history corresponding to a working period.
811data extraction interaction histories event timestamps first event last event bug report remove commoncolors.context active fixed interaction history interactionhistory version id ... interactionevent creationcount numevents structurekind java structurehandle org.eclipse.mylyn.comm ons.ui src lt org.eclipse.mylyn.internal.provisi onal.commons.ui commonthemes.java com monthemes color task active startdate .
cet originid org.eclipse.jdt.ui.packageexplorer navigation null kind selection interest .
enddate .
cet delta null ... interactionhistory code context model git repositories mylyn.tasksmylyn.commons code elements org.eclipse.mylyn.internal.provisional.commons.ui.
commonthemes color task active org.eclipse.mylyn.internal.provisional.commons.ui.
commonthemesorg.eclipse.mylyn.tasks.ui.t askelementlabelprovider org.eclipse.mylyn.tasks.ui.t askelementlabelprovider getforeground1 4structurekind java st t ki d j extracting code elements resolving git repository extracting event timestamps associating with commit event startdate working period interactionevent ... ... breaking into working periods event interval hours repository snapshots mylyn.commons commit 3ead864c mylyn.tasks commit running doxygen structural dependencies between code elements forming code context modeldeclares declares eclipse bugzilla mylyn bug reports bug report fixed bug report fixed... ... interaction history interaction history te act o s to y interaction history filtering bug reports extracting interaction histories interaction histories mylyn bug reports bug report fixed bug report fixed... ... interaction history interaction history code context model formation bug report fixed interaction history ... final interaction history figure process of collecting dataset.
table characteristics of code context models in dataset.
in terms of node number code context models lie outside the interval whereq1 q3 iqr code context models lie above .
code context model connected component cc node edge cc node edge diameter min max median mean .
.
.
.
.
.
sd .
.
.
.
.
.
directory orfile whichlackstructuralrelations orinvolvecode elements from unavailable code repositories e.g.
dependency libraries oraccessonlycodeelementsthatwerenotcommittedto therepositorywhentheinteractionhistorywascollected.forexample for the working period in figure we resolved two related git repositories mlylyn.tasks andmylyn.commons .
after this step we are left with working periods from which to form code context models.
extracting event timestamps.
we extracted the startdate attribute of each interaction event from an interaction history as the timestampoftheevent andidentifythetimestampsofthefirstandlast events.
the timestamps help to locate the commits before and duringtheworkingperiod.intermsoftheexampleworkingperiod in figure the timestamps of first and last events are and respectively.
associatingwithcommits.
byusingthetimestampsoffirstand lasteventsintheinteractionhistory weassociatedeachinteraction history with one or multiple commits in the related git repositories.
specifically we retrieved the most recent commit in the gitrepository prior to the timestamp of the first event in the inter action history.
in addition to capture the code changes during a working period we accessed any other commits that occur before 812the timestamp of the last event.
with regard to the example workingperiodinfigure1 weassociatedtheworkingperiodwiththe commit inmlylyn.tasks andthecommit 3ead864c in mylyn.commons.
running doxygen.
we useddoxygen toidentify structural relations between code elements.
specifically we run doxygen for each code snapshot of each commit associated with the working period.
in this paper we consider four structural relations declares calls inherits and implements.
figure illustrates that using doxygen we identify two declaresrelations between the code elements.
forming code context model.
for each working period we formed one code context model.
the extracted code elements form the nodes of the code context model for a working period while theidentifiedstructuraldependenciesformtheedgesofthecode context model.
figure presents the code context model for the exampleworkingperiod withfournodesandtwodirectionaledges labeled by structural relations.
this code context model which consists of two connected components is thesole working period associated with the bug report .
ourfinaldatasetofcodecontextmodelsconsistsof1 887models.
to give a sense of these models table reports on statistics about these models.
this data shows that the size of code context models varies with an average of just over nodes.
the code context models are typically comprised of multiple connected components with an average of .
indicating that developers worked with multiple clusters of structurally connected code elements during a working period.
the right side of table reports statistics about the range of size of the connected components comprising thecodecontextmodels.thisdatashowsthattheaveragediameter ofconnectedcomponentsis0.
indicatingthatthedevelopersdid notnavigatecodeelementsbyfollowingstructuraldependencies in depth during a working period.
the maximum number of nodes in acode context modelis leading usto question thenumber of outliers.
we found that models lie outside the interval q1 3iqr q3 3iq where the upper bound is q1 q3 iqr .
code context model prediction our goal is to predict the code context model for a task initiatedby a developer.
we assume the developer has initiated the taskby identifying some code elements of interest for the task.
for example adevelopermayhavejuststartedworkonataskandcould benefit from a prediction of the code that will need to be consulted to support the remaining work to be performed on the task.
by framingtheproblemasapredictionopportunity weaimtoprovide thecodecontextmodeltotoolsthatmayhelpadevelopersearch orotherwiseworkwiththecoderatherthansimplyrecommend the next step to a developer.
specifically intermsofataskonasystem m ourapproachtakes asinputasetofseeds s foreachconnectedcomponent ccinthe completecodecontextmodel rforthetask.eachseed s scontains aportionofaconnectedcomponent.ourapproachsupportsa dstep prediction where the code elements predicted are structurally 5q1isthe25thquartile q3isthe75thquartile iqr interquartilerange isdefinedas thedifferencebetweenthe25thand75thquartileandservedasameasureofstatistical dispersion.connectedwith and dstepsaway fromthecodeelementsin s.our approachreliesonabstracttopologicalpatternsofhistoricalcode contextmodelstomakeaneffectiveprediction.thesecodecontext modelsareextractedfrompreviousinteractionhistoriescaptured and stored for tasks on the system m. the extracted topological patterns are based on stereotype roles assigned automatically to code elements in s. wedescribetheassignmentofstereotyperolestocodeelements section4.
beforeexplainingourpredictionapproach section4.
.
.
stereotype role assignment developers perform tasks on a software system to add new and fix existing functionality.
as a result developers often work on different parts of the code base.
an analysis of the code context models inourdataset whichincludejavacode indicatesthatdevelopers accessed each classelement an average of .
times min max median sd .
each methodelement1.91times min max60 median sd .
andeach fieldelement1.21times min max median sd .
.
theserelativelylow ratesofaccess to code indicate that if we wish to build on patterns of access topredict code context models we must abstract from the specificcode elements accessed.
we hypothesize that the roles the code elements play in the system are a good basis for this abstraction.
we use the method and class stereotype taxonomy proposed by morenoandmarcustoassignroles .thetaxonomyprovides17 stereotyperolesformethodelementsdividedacrossfourcategories structural accessor structural mutator creational and collaborational.
an example of a specific stereotype within these categories is a structural mutator called command that indicates a method performingacomplexchangetoanobject sstate.thetaxonomy also provides stereotype roles for class elements including data provider which encapsulates data and consists mainly of accessor methods and purecontroller thatconsistsentirelyofcontrollerand factory methods.
weusemorenoetal.
s jstereocode tool toassignstereotypes to each code element on the fly as needed during the predictionprocess.
specifically we run the tool on the snapshots of code repositories associated with the context models.
during the prediction we search for each code element in the output of jstereocode for the related snapshot to assign a stereotype.
for instance in termsoftheexamplebugfixingtaskinfigure1 wesearchedfor org.eclipse.mylyn.internal.provisional.commons.ui.com monthemes node2 inthe jstereocode outputforthesnapshotright afterthecommit 3ead864c .asa result weassigned poolclassas the stereotype of node .
theoretically it is possible that a code element could have multiple stereotypes across different snapshots in a repository due to software evolution.
.
prediction approach the prediction approach consists of two stages.
the first stage mines abstract topological patterns from historical code context models.basedontheabstracttopologicalpatterns thesecondstagepredictsthefinalcodecontextmodelofatask withasetofseeds s for each connected component in the code context model as input.
input s a seed set for a connected component cc dprediction step pa set of topological patterns output ga set of matched subgraphs sdexpanded seed s primea predicted context model for the connected componentcc foralls sdo g expand s d sd graphmerge g sd end for assignstereotyperole sd forallp pdo g g patternmatch p sd end for forallg gdo s prime graphmerge g s prime end for forallv s primedo ov forallg gdo ifv gthen ov ov end if end for confidence v ov g end for figure context model prediction algorithm.
stage topological pattern mining.
the stage takes as input a system m a threshold of pattern support minsupp and a repository of code context models r.ris formed from interaction historiesforprevioustaskscompletedon m.eachcodeelementof r r wherepossible hasbeenassignedastereotype.asetoftopological patterns pis populated by mining frequent graph patterns in r. specifically werun gspan withrasinputand minsupp asthe parameter.
gspanis an efficient algorithm for graph based substructure pattern mining.
given a dataset of graphs d g0 g1 ... g n support g denotes the number of graphs in d in which gis a subgraph.
gspanexplores depth first search to find any connected subgraph gs.t.support g minsup aminimumsupportthreshold .
we use a python implementation6ofgspanand calculate the threshold minsupforgspanbytakingintoaccountthesizeofgraph dataset i.e.
minsup minsupp d .
stage2 contextmodelprediction.
figure2illustratesthealgorithm for this stage.
the stage takes as input a set of seeds sfor each connected component ccin the code context model rfor a taskonm thepredictionstep d andasetoftopologicalpatterns that are derived at stage p. the first step expands each s stog by performing a depth first search along the structural relations.
6gspan mining v0.
.
resulting code elements are structurally connected with the nodesin stoadepthof d line10 .aftertheexpansion allofthe expanded graphs gare merged to form sd line all code elements in sdhave been assigned a stereotype line .
then for each pattern pinp we locatesimilar structures in sdby applying thepatternmatching function line .
thepatternmatching function searches for the pattern pamong particular subgraphs in sd.
note that drepresents the prediction stepandislimitedbythediameterofaconnectedcomponent.thus thepatternmatching functionextractsasubsetofsubgraphsin sd forpatternmatching.thesesubgraphscontainatleast d nodes fromsd andareoftwotypes subgraphswhosenodesexistin anys s or2 subgraphsthathave dnodesthatdonotexistinany s s.finally the patternmatching functionreturnsthesubgraphs that are matched with the pattern p. finally all matched subgraphs with p pare merged to form thepredictedcontextmodel s primeforaconnectedcomponent line18 .
theconfidence value of each node in s primeis calculated by evaluating the frequency of occurrence across matched subgraphs line .
figure3illustratestheprocessof stepcontextmodelprediction with the example bug fixing task bug id as shown in figure .
the code context model has two connected components.
wetaketheconnectedcomponent ccwithnode1andnode2asthe example.
cchasaclassnode labeled2 anda fieldnode labeled .
each node in cccan serve as a seed for stepprediction and belongs to the seed set s labeled seed and seed .
the step prediction approach then expands each seed to a depth of d and generates an expanded graph gfor each seed.
after expansion thetwoexpandedgraphsaremergedtoform s1 whereallnodes are assigned a stereotype.
after running pattern matching with eachp p wefindthatthepattern pool class declares field matches12subgraphsin s1 whichformthesetofsubgraphs g.all ofthesubgraphsin garemergedtoformapredictedcontextmodel s prime.theconfidence valueforeachnodein s primeiscalculatedbasedon its frequency of occurrence across subgraphs in g. for instance theconfidence value of node equals to because node 2occurs inevery subgraph.meanwhile node 1occurs injustone subgraph thus its confidence value equals to .
evaluation weexplaintheresultsofapplyingthepredictionapproachtothe dataset described in section .
specifically we explore three researchquestionstoinvestigatetheeffectivenessofourapproach for code context model prediction rq1.whatkindsofpatternscanbelearnedfrominteraction histories?
rq2.howdoestheperformanceofourapproachforcode context model prediction differ over various values of d the number of steps of prediction?
rq3.howdoesourapproachcomparetothestate of theart?
814 matched patterns in pool classfielddeclares 2seed seed 11131214declares12 node stereotype confidence 1org.eclipse.mylyn.internal.provisional.commons.ui.commonthemes color task active field 2org.eclipse.mylyn.internal.provisional.commons.ui.commonthemes pool class 3org.eclipse.mylyn.internal.provisional.commons.ui.commonthemes color category field 4org.eclipse.mylyn.internal.provisional.commons.ui.commonthemes color category gradient end field 5org.eclipse.mylyn.internal.provisional.commons.ui.commonthemes color category gradient start field 6org.eclipse.mylyn.internal.provisional.commons.ui.commonthemes color completed field 7org.eclipse.mylyn.internal.provisional.commons.ui.commonthemes color completed today field 8org.eclipse.mylyn.internal.provisional.commons.ui.commonthemes color incoming background field 9org.eclipse.mylyn.internal.provisional.commons.ui.commonthemes color overdue field 10org.eclipse.mylyn.internal.provisional.commons.ui.commonthemes color scheduled past field 11org.eclipse.mylyn.internal.provisional.commons.ui.commonthemes color scheduled this week field 12org.eclipse.mylyn.internal.provisional.commons.ui.commonthemes color scheduled today field 13org.eclipse.mylyn.internal.provisional.commons.ui.commonthemes font editor comment field 14org.eclipse.mylyn.internal.provisional.commons.ui.commonthemes iscommontheme collaborator method figure sample task to illustrate how our approach does stepprediction.
.
experiment design toanswertheresearchquestions theexperimentsimulatescode contextmodelpredictionandappliesourpredictionapproachto the dataset.
experimental setup.
we choose a simulation based method to experimentwithourapproachandevaluateourapproachinausage scenario where a developer starts code search and navigation from the middle of a task.
the experimental method involves a training set a testset anda simulator.the trainingset rtra in is asubset of our dataset to mine the abstract topological patterns p. the test set rtest istheremainingcodecontextmodelsfromourdataset thatarenotin rtra in.giventhesequentialnatureofourdataset weusethe1 254codecontextmodelsfromtheyear2007to2009 as the training set and the code context models from the year to as the test set.
the simulator first creates multiple seed sets from the test set rtest as illustrated in figure .
for each code context model r rtest the simulator creates a seed set sfor each connected componentcc rwith prediction step das input.
once the seed set sis created from rtest the simulator mines abstract topological patterns through rtra in.
to select topological patterns the simulator uses the minimum support minsupp as a threshold.
then the simulator iterates over each seed set s sand bootstraps a prediction approach i.e.
our approach and the state of the art withsas input.
finally the simulator aggregates prediction results ofallconnectedcomponentsforeachcodecontextmodel r rtest.
experiment for rq1.
we investigate the numbers and kinds of patterns extracted by considering the effect of minsupp on the mined topological patterns.
to make a tradeoff between the generalizabilityandspecificityofminedpatterns weexperimentwith a range of .
to .
for minsupp .
we compare the topological patterns with various minsupp values in the range of .
to .
in increments of .
.
we use the best result for minsupp in subsequent experiments.
input rtesttest set dpredition step output sseed sets forallr rtestdo forallcc rdo size nodenumber cc s extractsubgraphs cc size d s s r cc s end for end for figure seed generation algorithm.
experiment for rq2.
to understand the effect of prediction step d we evaluate the performance of our prediction approach with d tobe1 2and3 representing step step and steppredictions respectively.
note that prediction step dis limited by the diameter ofaconnectedcomponent.forinstance aconnectedcomponentof diameter2 cansupport stepand2 steppredictions.the average diameter of the connected components in the test set is .
min max median sd .
.
to consider adequate instances in the testsetforeachpredictionstep wechoose dtobe1 2and3.we further investigate the impact of confidence threshold minconf ontheperformanceofprediction.the confidence valueofacode element in prediction results varies between and .
thus we set minconf to be in the range of .
to .
in increments of .
.
experiment for rq3.
suadeis the state of the art approach for codecontextmodelcompletion .suadeleveragesheuristiccharacteristicsof thestructuraldependencies i.e.
specificityandreinforcement to rank code elements connected with the seed.
given input lrelation types wselection window sa seed set for a connected component cc output s primepredicted context model for the connected componentcc foralls sdo f suade s l w s prime graphmerge f s prime end for figure experimental setting of suade.
that the original implementation of suadeis not accessible we implement suadein python and make it available online7.
assuadesupportsonly stepprediction wecompareonlyfor this prediction step.
we have the simulator iterate over s sfor thepredictionstep d andbootstraptheexperimentalsettingof suadeasdescribedinfigure5.weusethesimulatortorun suadefor eachseed s sandmergepredictedresultstoformthepredicted context model s prime line .
we simulate suadewith and as the selection window w respectively where suademakestop wrecommendationfor each connectedcomponent.wheneverthereexistsatieforatopposition webreakthetiebyrandomlychoosingthetopelement s among the equal valued suggestions.
toensureafaircomparison weuse declares callsandinherits as the relation types lforsuade.
for each selection window w whenapplying suade wecalculatetheactualsizeof s primeaskforeach connectedcomponentinacodecontextmodel.forcomparison we choosetop kcodeelementswithgreatest confidence valuesforeach connected component from the prediction results of our approach.
we used the same tie breaker as suade.
.
measurement to measure the effectiveness of prediction we use several commonly used metrics.
for each context model r rtest w eu s e actualcodeelements vandpredictedcodeelements v primetocompute the metrics.
vare the code elements in the actual context model of r.v primearethecodeelementsinthecontextmodelpredictedbased on a portion of v. we calculate precision pand recall rmetrics as precision p v v prime v prime recallr v v prime v to capture the trade off between precision and recall we compute theharmonicmean f measure fromtheaveragedvaluesofprecision and recall across code context models f measure f p r p r .
.
.
.
.
.
.
.
.
.20pattern number minsuppnode node node node figure number of patterns with minsupp in the range of .
to .
.
.
results we describe the results for each experimental question in turn.
.
.
rq1.
abstract topological patterns.
the first research question considers the kinds of patterns that can be learned from interactionhistories.figure6summarizesthenumberofpatternsmined fromrtra inwithvariousnumbersofnodesinthe pattern.asthe value of minsupp increases the number of topological patterns decreases sharply from to .
this result indicates that topologicalpatterns evenintermsofstereotyperoles arenotfrequently occurring in the dataset.
patterns with nodes node pattern account for more than of the patterns across various minsupp values.
node patterns disappear when minsupp .
while node patterns disappear when minsupp .
.
note that our proposed prediction approach leverages node npatterns to make d stepprediction wheren d.tocaptureadequatetopologicalpatternsforprediction we use the topological patterns where minsupp .
in the experiments hereafter.
the topological patterns with minsupp .
are distributed across of the code context models in the training set.
togiveasenseofthekindsofpatternsmined table2showsthe distribution of stereotype roles of the nodes in topological patterns whereminsupp .
.the methodandclassstereotypesinvolved in the patterns account for of methodstereotypes and ofclassstereotypes that occur in the training set respectively.
the distribution of stereotype roles involved in the patterns are consistent with that in the training set.
.
.
rq2.
prediction performance.
the second research question considers the performance of our approach for code context model prediction.
table reports the numbers of code context models column and connected components column in the test set that can support step step and step predictions.
f measure.
figure presents the resulting f measure forstep step 2andstep 3predictions.
each point represents the f measure of all the predictions across code context models with minconf ranging from .
to .
.
thef measure values of step 1start from .
and end with .
achievingthe highest value0.67at minconf .
.the f measure values of step 2start from .
and end with .
achieving the highestvalue0.33at minconf .
.the f measure valuesof step 816table stereotype roles in the topological patterns with minsupp .
.
stereotype count percentage method collaborator .
command collaborator .
set collaborator .
factory collaborator .
set .
constructor .
non void command collaborator .
get .
abstract .
local controller .
command .
factory .
classboundary commander .
boundary .
other .
entity .
commander .
interface .
minimal entity .
factory .
boundary data provider .
field start from .
and end with .
achieving the highest value .
atminconf .
.
the average f measure of1 stepprediction is .
times higher than that of stepprediction .
vs. .
and .
times higher thanthatof stepprediction .48vs.
.
.the f measure valuesof steppredictionareslightlyhigherthanthoseof steppredictions.
thus stepprediction significantly outperforms stepand3 step predictions.precision and recall.
figure presents the resulting precision and recall graphs for step stepand3 steppredictions.
each pointineachcurverepresentstheaverageprecisionandrecallof predictionresultsbasedonpatternswith minconf rangingfrom .
to .
.
the label for each point indicates the corresponding minconf.
steppredictionachievesamaximum precision averageof0.
whererecall .
minconf .
.
stepprediction achieves a maximum precision average of .
where recall .
minconf .
.
steppredictionachievesamaximum precision averageof .
where recall .
minconf .
.
figure shows that the precisionaverages for step dpredictions consistentlyincreaseandachievethemaximumvaluesatthebe ginning and drops sharply as the recallaverages increase.
the recallaverages increase as minconf values increase.
overall we observedthat steppredictionsignificantlyoutperforms stepandtable3 testsetsizesfor step step 2andstep 3predictions.
code context model connected component step step step table comparison of performance with suade.
our approach suade pr fpr f k .
.
.
.
.
.
k .
.
.
.
.
.
k .
.
.
.
.
.
steppredictions minconf canbeusedtomakeatradeoffbetween precision and recall for the predictions.
.
.
rq3.comparisonwith suade.thethirdresearchquestion askshowourapproachcomparestostate of the art represented by thesuadealgorithm.
table4 compares the precision recall and f measure values of our approach and suade.
our approach shows f measure values of .
.
.
and .
when k k andk respectively significantlyoutperforming suade .
.25and0.
.
in addition the performance metrics of our approach and suade show similar tendency as the window size kincreases precision values decrease but recallvalues increase.
discussion wereflectontheperformanceofourapproach delvingintowhythe approachperformsasitdoesandopportunitiesforimprovement.
we also consider the limitations of roles as a generalization mechanismanddiscusshowourapproachdiffersfromdeveloper oriented recommendation tools.
.
analysis of approach we consider how our approach performs by delving into the types of patterns we find in the system and how those patterns affect the performance of the approach.
prediction accuracy vs. confidence.
in figure a the step prediction yields significant higher prediction accuracy when minconf .
.toexplorethereason weanalyzedthe confidence values oftrue positive andfalse positive code elements in the prediction results.
the true positive elements achieve an average confidence of .
min .
max median .
sd .
while the false positiveelementsachieveanaverage confidence of0.
min .
max median .
sd .
.
a mann whitney test showed that the distributions of confidence values aresignificantly different betweentruepositive andfalsepositive codeelementsintheprediction resultswith p .
u .
.minconf .4helpstoexclude code elements from the true positives and from the false positives in prediction results.
to achieve an acceptable level of precision the prediction approachshouldchoosea minconf valuethathelpstodiscriminate a stepprediction b stepprediction c stepprediction figure f measure for1 step stepand steppredictions.
a stepprediction b stepprediction c stepprediction figure precision and recallgraphs for step stepand steppredictions.
labels represent minconf values.
between relevant and irrelevant code elements in a code context model.
predictionaccuracyvs.predictionstep.
asfoundinourstudy step 1predictionoutperformsstep 2andstep 3predictionsinterms ofboth recallandprecision.wefurtherinvestigate theresultsfor step and step predictions.
ontheonehand theinadequacyoftopologicalpatternsinstep and step predictions leads to low recall.
the number of topologicalpatternsdecreasessharplyasthenumberofnodesintopological patterns increases.
amongst the discovered patterns we observed node patterns node patterns node patterns and four node patterns.
as prediction step dincreases the numberofapplicablepatternsdecreases step step step .the69applicablepatternsfor steppredictioncovers59 of22 stereotype roles.
the coverage of stereotype roles for applicable patterns for stepprediction is .
ontheotherhand longersteppredictioninvolvesfewercode elements in the seed as for the identical topological pattern which leads to low precision.
for instance a node pattern as shown in figure9 matchesthesubgraphswithtwocodeelementsasseedfor step prediction but matches the subgraph with one code element as a seed for step prediction.
the precision of the pattern differs significantly between step and step predictions .
vs. .
.
tosupporttheformationofcodecontextmodelswith diameter future studies could explore whether applying multiple step predictions can achieve an applicable level of accuracy.
collaborator methodboundary class command collaborator methoddeclares declares figure9 nodepatternapplicablefor1 stepand2 steppredictions.
.
roles as a generalization mechanism our approach relies on the assignment of roles to code contextmodels formed from previous tasks on the system.
a limitationof our experimentation is its application to one system which we discuss further in section .
future work needs to consider whetherthetopologicalpatternsweidentifyandtheirfrequencyare uniquetoasystemoroccurinsimilardistributionstoothersystem developments.
if the patterns frequently occur across systems it maybepossibletominepatternsononesystemthatcanthenbe used even in new developments that do not yet have a historyto learn from.
given that the stereotypes were developed for a paradigmofprogramming object orientedprogramming andthepatternsminedarerelativelysmall e.g.
with2.7nodesonaverage thereisreasontobeoptimisticthattheuseofpatternsacrosssystem developments is possible.
future experimentation is needed to test 818thishypothesis.intermsof stepprediction ourapproachcaptures associationrules betweenstructurallyconnectedstereotyperoles.
.
developer oriented recommendations researchers have considered a variety of ways to make recommendations related to navigation for developers.
these recommendation approaches suggest code often navigated to next from a given location pre fetch information related to likely developer queries from a given point in the code present other code often changed with code currently being considered amongst otheraids.therearemanychallengeswithprovidingrecommendations directly to developers including capturing the developer s attention to provide a recommendation gaining the trust of the developerbyprovidinggoodrecommendations andexplainingwhya recommendation is being made .
muslu et al.
considered some oftheseissues suggestingthatspeculativeanalysis whichprojects a recommended action could be used to help with developer ac ceptance of recommendations by explaining the consequence of recommendations .
in trying to predict forward our approach is similar to speculative analysis.
similar to speculative analysis wefocusonpredictinginformationaboutactionsyettobetakento helpinformtoolsthatmightaiddevelopment ratherthantrying toprovidearecommendationdirectlytoadeveloper.bypredictingforward wecansuggestseveralpossiblealternatives enablingtools that might help a developer fast forward across a number of steps atoncethatwouldotherwisebechosenone by oneandpotentially eliminate paths that are not useful.
in addition the background of developers e.g.
experience may affect the interaction histories and thus future work could investigate this aspect.
future work could also consider temporal information in the prediction.
threats to validity to implement our approach we used doxygen8to statically derive structural dependencies between code elements.
doxygen s static analysis may overestimate these dependencies in particular calling relationships may be overestimated because static analysisoverestimatesthenumberoftargetmethodsforeachcallsite.
the overestimation of dependencies could lead to the discovery of potentially non existent patterns in actual code contexts and further reduce the precision of prediction approach.
we also relied onjstereocode toassignstereotypestocodeelementsacross code context models.
however of the code elements we processedcouldnotbeassignedastereotypeduetocompilationerrors in the source code.
the missing stereotype roles would prevent us fromfindingpotentialpatternsandpredictingcodeelementsthat are with no stereotype roles assigned.
this would reduce the recall of prediction approach.
the use of a more precise static analysis tool and the ability to extract from git compliable code would have reduced these errors.
a significant limitation to our exploration is the reliance on one systemdevelopment mylyn.thestructureandinteractionhistories storedformylynmaynotberepresentativeofotherprojects.for instance thedistributionofstereotyperolesreliesonthesystem design of a project the topological patterns may vary across different software projects.
mylyn is unique in having a repository of however no information is directly available about the experiencelevel or other background of the developers contributing to mylyn.
to helpunderstandthegeneralizability oftheresults itwouldbe helpful to explore the interaction traces from other systems stored by other tools such as blaze .
conclusions inthiswork wehaveexploredhowdeveloperinteractionhistoriescanimprovetheproactiveformationofcodecontextmodels.specifically we first learned abstract topological patterns from the code contextmodelsininteractionhistories.basedonthepatterns we proposed an approach to predict the code context model for a new task.theaccessedcodeelementsofthetaskareusedastheseed of the prediction.
to evaluate our approach we used a simulationbasedmethodtocreateseeds bootstrappredictionswithvarious configurations and collect prediction results.
in this experiment wefoundthatourapproachcanpredictcodecontextmodeleffectively achieving maximum f measures of .
.
and .
for1 step stepand3 steppredictions respectively.
in comparison withsuade ourapproachachievessignificantlyhigherf measure .57over0.23onaverage .theresultsdemonstratethatintegrating interaction histories and structural information can benefit the proactive formation of more accurate code context models.