cross languagecodesearchusingstaticanddynamicanalyses george mathew north carolina stateuniversity usa george2 ncsu.edukathrynt.stolee north carolina stateuniversity usa ktstolee ncsu.edu abstract as code search permeates most activities in software development code to code search has emerged to support using code as a query andretrievingsimilarcodeinthesearchresults.applicationsinclude duplicate code detection for refactoring patch identification forprogramrepair andlanguagetranslation.existingcode to code searchtoolsrelyonstaticsimilarityapproachessuchasthecomparisonoftokensandabstractsyntaxtrees ast toapproximate dynamic behavior leading to low precision.
most tools do not supportcross languagecode to codesearch andthosethatdo relyon machine learningmodels that require labeledtraining data.
we present code to code search across languages cosal a cross language technique that uses both static and dynamic analysestoidentifysimilarcodeanddoesnotrequireamachinelearning model.
code snippets are ranked using non dominated sorting basedoncodetokensimilarity structuralsimilarity andbehavioral similarity.weempiricallyevaluatecosalontwodatasetsof43 java and python files and java files and find that code search based on non dominated ranking of static and dynamic similaritymeasuresismoreeffectivecomparedtosingleorweighted measures and cosal has better precision and recall compared to state of the art within language and cross language code tocode search tools.
we explore the potential for using cosal on largeopen sourcerepositoriesanddiscussscalabilitytomorelanguages and similarity metrics providing a gateway for practical multi language code to code search.
ccs concepts softwareanditsengineering softwaremaintenancetools informationsystems similaritymeasures .
keywords code to codesearch cross languagecodesearch non dominated sorting staticanalysis dynamicanalysis acmreference format george mathew and kathryn t. stolee.
.
cross language code search usingstaticanddynamicanalyses.in proceedingsofthe29thacmjointeuropean software engineering conference and symposium on the foundations ofsoftwareengineering esec fse august23 28 athens greece.
acm newyork ny usa 13pages.
permissionto make digitalor hard copies of allorpart ofthis work for personalor classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acm mustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
esec fse august 23 28 athens greece associationfor computing machinery.
acm isbn ... .
introduction code to code search describes the task of using a code query to search for similar code in a repository.
this task is particularly challenging when the query and results belong to different languages dueto syntactic andsemantic differences between the languages .
considerthecase ofcodemigration where it is common for applications in a specific language to be re written to another language .
for example while porting the video game fezfrom microsoft xbox to sony playstation the developers faced theirbiggestchallengeinconvertingtheoriginalc codetoc astheplaystationdidnotsupportthec compiler .code tocode search is also involved in identifying code clones findingtranslationsofcodeinadifferentlanguage program repair andsupportingstudentsinlearninganewprogramminglanguage .thegrowingprominenceoflargeonlinecode repositoriesandtherepetitivenatureofsourcecode leadto thepresenceoflargequantitiesofpotentiallysimilarcodeacross languages providingaviable platform for code to code search.
we propose the first cross language code to code search approachwithdynamicandstaticsimilaritymeasures.thenoveltyis intheapplicationofnon dominatedsorting tocode to code search allowing static and dynamic information without aggregation to identify search results.
cosal leverages prior art in clone detection using input output io behavior .
as dynamic clone detection requires executable code individually it cannot achieve the recall required for practical search applications.
this is wherethepriorartinstaticanalysisshines weusetoken basedand ast based measures to complement the dynamic analysis.
cosal reaps the benefits of dynamic analysis in finding code that behaves similarly whendynamicinformationisavailable andthebenefits of static information when dynamic information is infeasible.
it provides results that balance how code looks withhow it behaves in the spiritofreturningcode that looks more naturalto the user.
we evaluate cosal using java and python files from atcoder aprogrammingcontestdataset and55 499javafilesfrom bigclonebench ajavabasedclonedetectionbenchmark.we show that combiningstatic and dynamic analyses yields better precision and success rate compared to code search with individual or weighted analyses.
cosal performs better in cross language and within language contexts compared to the state of the art code search tool facoy and the industrial benchmark github.
cosal can also detect more cross language code clones compared toslaccandclcdsa thestate of the artcodeclonedetection techniques.the contributionsof this work are thefirstcode to codesearchapproachusingnon dominated sortingover staticanddynamic similaritymeasures an evaluation of cosal with state of the practice crosslanguagecode search ingithubandelasticsearch rq2 esec fse august athens greece georgemathewandkathryn t. stolee 1list integer getevens intmax list integer evens newarraylist for inti i max i if i evens.add i returnevens a java forloop to populate an array of even numbers 1defall odds n odds n range n foriinn ifi continue odds.append i returnodds b python forloop to populate an array of odd numbers 1integer func intx int n intstream.
range x .toarray list integer e newarraylist for inti i n.length i if n.get i e.add n.get i returne.toarray c java listof even numbersusingversion specificlibraries 1defeven nums max val nums xrange max val return d python listof even numbersusing list comprehension figure different functions to return a filtered array of numbersimplementedin javaandpython.thecodein a c and d arefunctionallyidentical.thecodein b isdifferent.
anevaluationofcosalwithstate of the artsingle language code searchtechniquefacoy rq3 an evaluation of cosal against cross language clone detectiontechniques clcdsaandslacc rq4 and anopen sourcetoolthatperformscross languagecodesearch onjavaandpythonandcanbeextendedtootherlanguages .
motivation effective code to code search requires code similarity measures that cover a variety of developer concerns.
code to code search shouldpreservecodebehavior andthusiosimilarityfromdynamic analysis is an important consideration.
prior work has shown that identifiers impact source code comprehension especially for beginners and as developers must understand the code returned by search tokens are an important consideration.
prior work in code to codesearchthatreliesonastshaveseenhighprecision and recall suggesting that is an important consideration as well.
individually each measure has shortcomings.
taken together however we showthe wholeisgreater thanthe sum ofits parts.
considerthecodesnippetsinfigure .threeofthefunctions are behaviorally identical taking an input integer and returning anarrayofevenintegers a isajavafunctionwhichusesafor loop c uses the stream library from java v8 d is a python function which uses a filtered list comprehension .
b is different it is a python function that takes an integer maxand returns a listfig.ast tokens j1 a getevens get evens max list integer arraylist array add p1 b allodds all odds range append j1 c func intstream stream range toarray array list integer arraylist length get add p1 d evennums even nums maxval max val xrange figure2 genericastsandtokensforjava j andpython p functions fromfigure ofoddnumbersbetween max .figure2containsastandtoken information for the code snippets discussedextensivelyin .
to identify behaviorally identical python code for figure a a code to code search engine should support both the programming languagesjavaandpython.inthiscase usingapurelytoken based approach forcross languagesearchwillnotbe veryhelpful.first the syntactic features of each language will skew the search.
for example since java is static typed variables are declared with a datatype while variables in python lack these tokens due to dynamic typing in python.
second even if the language specific keywordsareignored thereisanoverrelianceonthenamesofvariablesandlibrariestoinferbehavioralcontextwhichmaynotalways succeed.forexample a usesevenstodenoteajavalist while d usesnumstorepresentthesamepythonarray.still identifiernames canbe informative in describing thebehavior of code and are thereby useful as ametric.
using an ast based approach to identify similar code across languages is useful but not consistently viable due to the languagespecific constructs.
for example a uses a standard forloop to populate the list while d useslist comprehension which is a pythonic construct for the same task.
the nearest structural match would be b since it also uses a forloop.
however the functions1 a and1 b are behaviorally different.
in such cases a dynamicapproachbasedoniosimilaritywouldrevealthedifferences.
behavioral approaches also havetheirlimitations.for example intstream from1 c isspecifictojavav8andabove.similarly xrange from1 d is specific to python v2.x.
hence the right version of the 206cross languagecode searchusingstatic anddynamic analyses esec fse august athens greece languageandlibrariesisaprerequisiteandinmanycasesa major bottleneckfor dynamicsimilarity.
there is no single best similarity measure for cross language code to code search.
it depends on multiple varying criteria which cannot be generalized for all cases.
hence we need a code to code searchtechniquethatenablessearchbasedonmultiplesimilarity measures.
this can be handled by aggregating the multiple measures into a single measure or by using all the measures in tandem.
when aggregating into a single measure it is easier to compare but there are limitations.
search methods and evolutionaryalgorithms convertmultiplesearchobjectivestoasingleobjective search problem .
using such methods is not very optimal as ranking the results would be very subjective if the objectives are independent or weakly correlated to each other.
an aggregated approach can also lead to bias in comparison .
this motivates the use of an approach to ranking that preserves each of the similarity measures using them in tandem.
in this section we haveshownthatcodethatmatchesononemeasure e.g.
astsimilaritywouldmatch a with1 b maydifferonanothermeasure e.g.
behavioral similarity shows a and1 b are different .
when aggregating intoasinglemeasure such nuances are often lost.
non dominated ranking orders search results across multiple independent search objectives without aggregating them.
we select three similarity measures to represent the context structure andbehavioracrossprogramminglanguages.thesemeasuresare weakly and moderatelycorrelated to each other presenting nonoverlapping perspectives when used to compare code.
further non dominated ranking could provide information sufficient to explain why one result is ranked above another in a meaningful way an ability that is lacking in aggregated approaches e.g.
a and1 b have more structural similarity .
while we do not investigate the value of the explanations in this work we conjecture that such explanations may be useful when developers discern between searchresults andleave that for future exploration.
code to code searchacross languages figure3depictsthe generalworkflowofcosal offline a repository is crawled to extract code snippets e.g.
github alocal file system.
offline indices are createdfor eachofthe following a atokenindex for code names andlibraries .
.
b alanguage agnostic astindex forcodestructures .
.
c ifthecodecanbeexecuted the ioindexisrecorded .
.
duringsearch a codequery isprocessedinthesamemanner as steps2 a c to gather tokens ast andioinformation.
non dominatedsorting identifies searchresults whichare rankedandreturnedto the user .
we illustrate cosal using the code examples from figure .
.
token basedsearch fragments of code that are contextually similar often use similar variable names though the naming conventions vary by language.
for example java primarily uses camelcase conventions whilepythonuses snake case .librariesacrosslanguagestendto share similar function names or contexts for example list figure overview ofcosal classfrom java.utillibraryand listfromthepython builtin library are both commonly used to represent an array.
developerstendtodescribethecodeincommentsbasedonthefunctionality .
we infer context by extracting non language specific tokens from sourcecode andcomments as follows remove language specific keywords based on the documentation .
for example java tokens publicandstatic andpythontokens defandassert are allremoved.
remove frequently used words used in a language based on common coding conventions.
for example in python the tokenselfisoften usedto denotethe class object.
removecommonstopwordsfromtheenglishvocabulary such asdoesandfrom.
splittokenstoaddresslanguage specificnomenclature.variables typically use camelcase in java and snake case in python.thesearesplitinto camel and case and snake and case respectively.
remove tokens oflength less than min tok len .
convertallthe tokens to lower case.
a repository of code is tokenized using the above approach and storedinanelasticsearch index.forauser scodequery the tokens generated from the indexing approach are looked up in the searchindexandthebestmatchedresultsarereturnedusingthe tokensimilaritydistance dtoken .thisdistanceisthesameasthe jaccardcoefficient andisdefinedas follows dtoken tokensquery tokensresult tokensquery tokensresult dtokenwill range from .
larger values of dtokenindicate higher similaritybetween the query andresult.
for the functions in figure the generated tokens using this approachareshowninfigure 2andthetokensimilaritydistancefor each pair of functions is shown in table dtoken .
if the java function1 a isthe query the bestpython result would be d dtoken .
.
the common token maxextracted from these functions help in identifyingthissimilarity.note that none of the functions in figure 1have code comments while in our implementation the comments are analyzed.
inmanycasesthetoken basedanalysiscannotyieldidealresults.
itreliesonself describingsnippets thechoiceofvariablenames functionnames librariesused andcommentsallimpacttheresults.
1complete listsof the removed tokens areavailable .
207esec fse august athens greece georgemathewandkathryn t. stolee table1 similaritymeasuresforjava j andpython p functions from figure .
high similarity implies high values ofdtoken low values ofdast andhigh values ofdio.
snip1 snip2 dtoken dast dio s1 s2 s2 s1 j a p b .
.
.
j a j c .
.
.
j a p d .
.
.
p b j c .
.
.
p b p d .
.
.
j c p d .
.
.
notallcodesnippetsadheretointuitivenaming conventions.for example in c theprogrammerchoseverygenericnames.still we show in .1that our approach for tokenization yields more precise results comparedto full textsearch.
.
ast basedsearch a tree based representation for comparison across languages is challengingsincethereisnogenericastrepresentationthatencompasses syntactic features of different languages.
traditional ast parsers like antlr javaparser python ast modulesusedifferentgrammarstodenotesimilarfeatures.forexample a function node in javaparser is represented as methoddeclaration whilethe python ast parserrepresentsthenodeas functiondef .as aresult tocompareastsofdifferentlanguagesrequiresamapping scheme between eachpair ofprogramming languages.
for better scalabilitytoadditional programminglanguages we built a parser for a generic ast.
by mapping the asts for java and for python onto the generic ast we can compare across these languages see .
.2foradiscussiononscalability .thegeneric astisbasedonourintuitionandchosenlanguages andtheremay bemoreeffectiveorefficientrepresentations.itcontainsasuperset ofthe languagefeatures as follows commoncontrolstructures controlstructuresaresimplified and clustered.
for example the loopnode is used for the java constructs for foreach whileanddo while and pythonconstructs for while andlist comprehension .
normalizingvariable variablesaredenotedas varnodes.
normalizing literals literalsare denotedas litnodes.
normalizingoperators operatorsaredenotedas opnodes.
languagespecificfeatures ifafeatureisimplementedin onlyonelanguage acustomnodeiscreated.forexample switchis specific to java and not supported in python.
as a result acustomnode switchiscreatedfor this statement.
similarity between asts is computed using the zhang sasha algorithm dast .thealgorithmcomputestheminimumnumberofeditsrequiredtotransformanorderedlabeledtreetoanother orderedlabeledtreeinquadratic time.
dastwill rangefrom .
lower valuesof dastare associatedwithhigher similarity.
for the functions in figure the generated asts are shown in figure 2and the ast edit distance for each pair of functions is shown in table dast .
based on dast a query with pythonfunction d yields1 a as the best java result dast .
notably the syntactic constructs of the two functions are also different.
the python search query d uses alist comprehension which is a python feature and the java search result a uses a forloop.identifyingthematchingsearchresultispossible since list comprehension and theforloop are denoted as loopnodes in the grammarfor the genericast.
there are cases where a generic ast based approach is nonideal.forexample ifthejavafunction a isqueriedusing dast thebestpythonresultwouldbe b .thisisbecausebothfunctions use traditional forloops and updates the return array sequentially andyet thesearchresultisbehaviorallydifferentfromthe query.
suchscenarios can be handledusing dynamic similarity.
.
input outputbasedsearch dynamicsearchincosal isperformedbyclusteringcode based onthetheiriorelationship.todeterminetheiorelationshipbetween two pieces of code we use slacc a publicly available io based cross language code clone detection tool.
slacc segments code into executable snippets of size greater than min stmts andexecutedon args max argumentsgeneratedusingagrey box strategy.
the executed functions are then clustered using a similarity measure sim based on the inputs and outputs of the functions.
consideraquery qandapotentialsearchresult s.letqandsbe setsofsegmentsidentifiedbyslaccfrom qandsrespectively.we definethe io similarityas dio q s q summationdisplay.
qi qmaximize sk ssim qi sk the value diorange from .
higher similarity corresponds to higher valuesof dio.
the io similarity between any qandsis not commutative.
this is because it is often preferred for a search result to contain extra behavior as compared to the query .
also there may be a many to one mapping where multiple query segments matchwithasinglesegmentintheresult.consideranexample let q q1 q2 q3 q4 q5 be set of five segments and s s1 s2 s3 be set of three segments identified by slacc.
segments q1 q2and q3findsegments s1 s2ands1tobethemostsimilar respectively withsimilarityscores sim ofsim q1 s1 .
sim q2 s2 .
andsim q3 s1 .
.
notice how s1is identified as the closest match for both q1andq3.
segments q4andq5did not find segments inswith similarity greater than .
.
in this case dio q s .
.
.
.
.
.
.
as a practical example say a developer is looking for a java api forquickselect2 whichfindsthe kthsmallestnumberfromanarray of integers.
it has a method that identifies a random pivot in the array and a method that swaps values.
however these methods do notcalleachother.thus tocharacterizethebehaviorofthisfile we characterize and aggregate the behavior of segments of the file.
then when comparing to a custom python quicksort3api that has a function to recursively find a random pivot and perform a swapoperation amatchisidentifiedeventhoughthenumberof methodsandhowthey accomplishthe same taskare different.
2fromorg.apache.datasketches 3stackabuse.com quicksort in python 208cross languagecode searchusingstatic anddynamic analyses esec fse august athens greece thedynamic similaritybetweenallthefunctionsinfigure 1is shownintable .wenoticedin .2that1 a and1 b werevery similar based on dast but functionally different.
using behavioral analysis weseethattheyareindeedfunctionallydifferentas dio .5forbothmeasuresof dio.incontrast a and1 c aresimilar based on behavior dio .
even though structural similarity dast islow.
.
non dominatedranking weusenon dominatedsorting whichisacomponentofnsgaii andordersresultswithmultipleobjectiveswithoutaggregation.
cosal uses this algorithm to rank search results based on dtoken dast anddio.wenotethatthesimilaritymeasuresconsideredinthisworkareweaklycorrelated asdescribedin .
making this an appropriate algorithmic choice.
we usethe algorithmin a novelcontext thisisthefirstworkthatusesnon dominatedsorting for code to code search.
inourcontext eachsimilaritymeasureisanobjective.cosal incorporatesnon dominatedrankingas follows individual search for a query top top nsearch results are fetched using each similarity measure dtoken dastand dio independently.
merge theindividualsearchresultsaremergedsuchthat duplicateinstancesofsearchresults are removed.
sort themergedresultsaresortedbynsga ii bymeasuring the dominance ofone result over the other.
a search result sis said to dominate a search result t ifsis no worse than tin any objective and is better than tin at least one objective.
otherwise there is a tie.
in case of a tie we select the result that has the dominant objective closest to the optimal value.
forexample considerthefollowingscenariosoftherelationship betweensandtandthreehypotheticalsimilaritymeasures da db anddc where higher valuesmean higher similarity scenario dadbdcwinner 1s ts ts t s 2s t s ts t s 3s t s t s ttie 4s ts t s ttie forscenario1 sisbetterthan tonallmeasures making sthewinner.
in scenario since sisbetter than tonone measure andisnever worse than t sis thewinner.
in the third scenario sis better than tononemeasure dc andworseonanother db .therefore there is a tie.
similarly on scenario sis worse than ton two measures andbetteronone soitisalsoatie.tiesarebrokenbylookingat thesearchresultsthatarebetterforeachsimilaritymeasureand thencomparingtooptimalvalues typically1or0 dependingon whether high orlowvaluesrepresent bettersimilarity .
using the examples from consider the python functions d and1 b infigure 1asqueries.thepotentialcross languageresults are1 a and1 c .we show the relationships between the potential results using three similarity measures see table 1for specific values.the winnerfor eachcomparison isboldedfor clarity.
query dtokens dast dio winner d a c a c a c a b a c a c a c tiewhen the query is d a is better than c on two of the measures and equal on the third thus making a the winner.
whenthequeryis b a isthewinnerfor dastand1 c isthe winnerfor dio meaningwe needto breakthe tie.
to break ties we compute distances between each search result andtheoptimalvalueforeachsimilaritymeasure omittingsimilaritymeasuresonwhichtheresultsaretied .theoptimalvaluefor dastis0 asthatrepresentsisomorphicasts.theoptimalvaluefor diois1 asthatrepresentsaperfectmatchincodebehavior i.e.
the search result and query return the sameoutput for allthe provided inputs .
the optimal value for dtokenis also as this represents highly similar syntax.
we use a normalized distance because the similarity measures have different rangesof values.
thus normalizing ensures a uniform comparison scale between the different similarity measures and subsequently avoid the precedence of one similarity measure over other similarity measures.
the normalized distance of a similarity measure x on a snippet sis computed asdx s min dx max dx min dx .fordtokenanddio themaxandminvalues are .
and .
respectively.
in the case of dast theminvalue is and the max value is set to the largest value of dastfrom all the individualsearchresults.thisisbecause dast cantheoreticallybe infinitelylargesoweusethelargestobservedvalue.forexample max dast for the query d is21 from table .
continuingwiththeexample thenormalizeddistancefor a to the optimal dastis .
.
we do not need to consider the distance for1 c since1 a wasthewinnerfor dast.
thenormalizeddistance between dioof1 c is .
.
since the normalized dastof1 a is closer to the optimal value compared to the normalized dioof1 c cosal ranks a as the winnerfor the query b .
wenotethatsimilaritymeasurescharacterizingothercoderelationships suchassoftwaremetrics couldbeaddedwith relativeease.non dominationrankingpreserveseachobjective sindependenceandtherearenoweightsthatrequiretuning see .
.
.
research questions theredoesnotexistacross languagecode to codesearchtoolto compare against directly see .
thus our evaluation assesses each part of cosal the ranking algorithm within language codeto codesearchcomparedtostate of the practiceandstate of theart tools and cross language clone detection.
the first research question rq examines the similaritymeasures andranking rq doesnon dominatedrankingusingtokens astandioyield better results for cross language code to code search as compared to any subset or aggregation of those search similarity measures?
after validating the choice of using multiple code similarity measures and non domination ranking cosal is compared to the state of the practice search in github search and elasticsearch whichare basedonfull textsearch.
we ask rq howeffectiveiscosalincross languagecode to codesearch comparedto state of the practice publiccode search tools?
209esec fse august athens greece georgemathewandkathryn t. stolee table2 summaryofrqswiththeapplication code to codesearch clonedetection baselines benchmarks atcoderorbigclonebench andthelanguage s .cosal single representscosal usingasinglesimilarity measure.
rq purpose application baselines language s benchmarks merit ofusingmultiplesimilaritymeasures code to codesearch cosal single java python atcoder vsstate of the practice cross language tools code to codesearch elasticsearch github java python atcoder vsstate ofthe art within language tools code to codesearch facoy java atcoder bigclonebench using cosal to identifysimilar code clonedetection clcdsa astlearner java python atcoder facoy thestate of the artincode to codesearchiswithinlanguage but cosal is a multi language tool.
we limit our tool to within languagecode to codesearchandevaluateitagainstfacoy.
rq how effective is cosal in within language code to code searchas comparedto the state of the art?
code to codesearchisoftenusedinclonedetection .usingcosalforclonedetection wecompareagainstastlearner clcdsa andslacc rq can cosal effectivelydetectcross language code clones?
study the setup for each rq is different.
in all evaluations we make a bestefforttobefairinthecomparison.therqsaresummarizedin table2 whichliststheapplication eithercode to codesearchor clonedetection baselineapproaches language s andbenchmarks.
.
data the data usedinthis study are available online .
.
.
atcoder atc .
we require a labeled setof similar code snippets in multiple programming languages for queries and search results.hence likepriorstudies weuseatcoder tocreateadatasetofsimilarcodesnippetsacrossdifferentprogramming languages.
competitive programming contests like atcoder haveopenproblemswhereuserscansubmittheirsolutionsinmost commonprogramminglanguages.solutionswhicharesyntactically incorrectordonotpasstheextensivetestsuiteare filteredoutby atcoder.alltheacceptedsolutionsforasingleproblemimplement thesamefunctionalityandarebehavioralcodeclones.ifasearch query and a result belong to the same problem we consider the result to be valid and the query result pair as valid code clones the problem solutions are the ground truth in our experiments.
we limitourstudytothemostrecent398problemswhichhadsolutions injavaorpython.fortheseproblems wecrawled43 146filesfrom alltheacceptedjavaandpythonsolutions.table 3listsanoverview ofthedatasetusedforthestudy 307ofthe398problemshaveboth ajava andpythonsolutions.
.
.
bigclonebench bcb .
bigclonebench is one of the largestpubliclyavailablecodeclonebenchmarksforjavawithover 000sourcecodefilesharnessedfromapproximately25 000opensource repositories.
table 3lists a summary of bigclonebench.
we consider query result snippets belonging to the same functionality as a valid search result.
fragments of code with less than lines or50tokensarenotconsideredwhichisastandardminimumclone size for benchmarking .
.
baselines wecomparecosaltoeachoftheothertoolsbysearchingover thesamedatasets.forrq3andrq4 weusedthesourcecodein the githubrepositoriesof the toolsfor experimentation.
.
.
rq2 textsearch.
google searchis commonlyusedby developers for code search .
textual queries can take the form of keywords expectedcode orexceptionsraised.inourstudy google failedtoindexourcoderepositoryafterasixweekwait.asaresult we turned to a custom full text search using elasticsearch which takes in a code snippet tokenizes the code and identifies results based on lucene s practical scoring engine .
for this study each java and python file is added to an elasticsearch index andsearchedusing the elasticsearch programmatic search api.
.
.
rq2 githubsearch.
githubsearch engineisanir based search model over code repositories including issues pull request documentation and code data .
using the built in code search ongithub codecanbesearchedgloballyacrossallofgithub or searchedwithinaparticularrepositoryororganization.weaddthe javaandpythonfilesfromthedatasettoasinglegithubrepository andsearchwithintherepositoryusingthegithubsearchapi .
.
.
rq3 facoy.
facoy isajava basedcode to codesearch toolthatusesaqueryalternationapproachusingrelevantkeywords from stackoverflow q a posts.
facoy can be modified to change itssearch databasefrom q aposts tocustomdatasets.
inour experiments weredirectedthesearchtotherepositoriesofcodefrom the atcoder and bigclonebench datasets.
similar to the experimentsinthefacoyevaluationwhencomparingagainstresearch tools facoydoes not use stackoverflowinour baseline.
.
.
rq4 astlearner.
perez and chiba developed a semisupervisedcross languagesyntacticclonedetectionmethodthat wecallastlearner .itusesaskip grammodelandanlstm based encoder.
the encodings train a feed forward neural network classifierusingnegativesamplingtoidentifyclones.astlearner consideredcode as clones if the classifier score isgreater than0 .
.
.
.
rq4 clcdsa.
crosslanguagecodeclonedetection clcdsa usessyntacticfeaturesandapidocumentationtodetect cross language clones in java python and c .
nine features are extracted from the ast api call similarity is learned using api documentationandaword2vec model.thevectorizedfeatures train a reconfigured siamese architecture using a large amount 210cross languagecode searchusingstatic anddynamic analyses esec fse august athens greece table3 summariesofatcoderandbigclonebenchdatasets atcoder atc bigclonebench bcb metric java python metric java problems features files files avg.
files problem avg.
files feature methods methods avg.
lines file avg.
lines file oflabeleddata.clcdsausescosinesimilaritytodetectclones the bestf1 scores were when the similaritythreshold was0 .
.
.
.
rq4 slacc.
simion based language agnostic code clones slacc uses io behavior to identify clones.
it is alsousedincosalfordynamicsimilarity.here weuseslacc as a baseline in its original context clone detection.
we use the samevaluesforthehyper parameterssetbytheauthorsofslacc min stmts issetto args max issetto sim tissetto .
.
.
metrics .
.
code search.
for code search applications rq1 rq2 rq3 we useprecision k successrate k andmrr.
precision k orp kistheaveragepercentageofrelevantresults in the top k search results for a query .successrate k or sr kisthepercentageof queriesforwhich oneormorerelevant result exists among the top k search results .mrris the meanreciprocalrankoftherelevantresultsforaquery .
consider a query qin a set of queries q.rkqis set of all relevant resultsinthetopkresultsfor q.br q istherankofthefirstrelevant searchresultfor q. kisanindicatorfunctionwhichreturns1ifthe inputisless thanorequal to kand0otherwise.mathematically p k summationtext.
q q rkq k q sr k summationtext.
q q k br q q mrr summationtext.
q q1 br q q precision k successrate k andmrrrange .
for better readability in the rest of study we report these metrics as percentages ranging between .
fork precision k and successrate k are the same.
for higher values of k successrate k indicateswhether there is something relevant in the results precision kmeasures how relevant the kresults are on average.
we set k .
higher values of mrrimply relevant results are rankedhigher inthe results.
.
.
clone detection.
for clone detection rq4 we use precision recallandf1score.precision p is the ratio of valid clonestothenumberofretrievedclones.
recall r istheratioof the number of accurately detected clones to the number of total actualclones.
f1orf measure istheharmonicmeanofprecision and recall.we define c as thenumber ofvalid clones identified c as the number of valid clones not identified and nc as the number ofinvalidclones identified p c c nc r c c c f1 p r p r precision recallandf1rangefrom .likethecodesearch metrics we report precision recallandf1as percentages between forbetterreadability.highervaluesof precision meanthe detected clonescontain fewerfalse positives andhighervalues of recall mean more clones were identified with fewer false negatives.
.
experimentalsetup our experiments were run on a ubuntu .
lts virtual machine with cpus and 64gb memory using a dell poweredge r640 server with intel xeon silver cpu .
ghz and vmware esxi6.
.0hypervisior.theexperimentshavefourhyper parameters .
.
minimum token size.
min tok size in 3. this is set to three.
ir based techniques on source code find that tokens less thanthree characters are irrelevant.
.
.
minimum segment size.
min stmts in 3. a small value ofmin stmts results in more granular snippets.
we set it to for maximum number ofbehavioralsnippetsof code.
.
.
maximum number of arguments.
args max in 3. prior workfinds args max 256wassufficientforcross languageclones ingoogle code jam sowe use the same.
.
.
numberofindividualsearchresults.
top nin 3. this is setto100.weexperimentedoncosalwith10 oftheatcoder datasetvarying top nin .fortop ngreater than100 weseeaminimalchangeinthecodesearchmetrics.hence for eachindividualsearch we fetch the top100search results.
results we present the results ofeachrqinturn.
.
rq1 single vsmultiplesearch similarity measures in a cross language search context we compare the results of cosalwithmultiplesearchsimilaritymeasurestocosalwith subsetsofthesimilarity e.g.
cosal astiscosalwithonlythe astsimilarity .thevalidation ofthisstudywasperformedusing leave one out cross validation whereeach code fragmentis usedasaqueryagainstallotherfragmentsintherepository.we use this approach over the traditional k fold cross validation since leave one out is approximately unbiased and more thorough .
eachofthe43 146codefragmentsisusedasaquery.theresults are detailed in table .
overall cosal outperforms the other formulations that use subsets of the similarity measures.
it also outperforms an alternate ranking approach based on weighted measures kdtree .
we observe that token based search cosal tokens and astbasedsearch cosal ast arelesspreciseindividuallycompared todynamicsearch cosal slacc buthavehighersuccessratefor k .whenboththestaticsimilaritymeasuresareusedas parts of a bi similarity search cosal static we see better metrics comparedtoeachsimilarityindividually andbettermetricsthan thedynamicapproachcosal slaccinp kandsr kwhenk .
thepowerofthetechniquecomesfromusingstaticanddynamic informationwithoutconvertingthemintoasinglesearchmetric.
rather than non dominated ranking an alternate avenue would be a weighted approach.
for example kd io ast tokenusesdtoken dastanddioto build a kdtree a common approach used 211esec fse august athens greece georgemathewandkathryn t. stolee table rq1 rq2 cross language code search results on atcoder dataset comparing cosal against the state of the practice sotp github and elasticsearch.
cosal token cosal ast cosal slaccuse single search similarities single sim.
dtoken dastanddiorespectively.
cosal staticusesdtokenanddastwith non domination.
kdio ast tokenperforms code search with kdtree using dtoken dastanddio.codesearchtechniquesusingmultiple similarity measuresare represented with multi sim.
search mrr p sr sotpelasticsearch github single sim.cosal token cosal ast cosal slacc multi sim.cosal static kdio ast token39 cosal forinformationretrieval .althoughkd io ast tokenand cosalusethesamesimilaritymeasuresforcodesearch theformer under performsonallmetricscomparedtothelatter.thissuggests that aggregation of similarity measures into a single measure does not helpcode searchas thesemeasures complementeachother.
usingnon dominatedrankingwithstaticanddynamicsimilarity measures improves the quality of results for code to code search comparedto subsetsoraweightedaggregation ofmeasures.
.
rq2 state of the practice cross language code to codesearch we compare cosal against github search .
.
and a custom full text search based on elasticsearch .
.
.
we use leave oneout cross validationwitheachofthe43 146codefragmentsasa query.results are shownintable .
we observethatbetweenthetextual codesearch tools github search has better mrr precision k andsuccessrate k compared to elasticsearch except for successrate .
yet github search and elasticsearchare worse off comparedto cosal inallmetrics.
cosalobtainsbetter precision k successrate k andmrrcomparedto githubsearchandelasticsearch.
.
rq3 state of the art code to codesearch facoy isastate of the artcode to codesearchtoolforjava.
hence wecomparecosalagainstfacoyusingjavacodesnippets only.thisreducestheatcoderdatasetto351problemswith20 java files.
to ensure that the dataset is not skewed due to outlier projects with limited submissions we use java projects with or more submissions.
like rq1 and rq2 we use leave one out cross validation with each of the code fragments as a query andthe remaining problems as the searchindex.table rq3 single language java code search comparing cosal to the state of the art sota facoy on atcoder and bigclonebench.
search mrr p sr 10atcodersotafacoy single sim.cosal tokens cosal ast cosal slacc multi sim.cosal static cosal 88bigclonebenchsotafacoy single sim.cosal tokens cosal ast cosal slacc multi sim.cosal static cosal the results for mrr precision k andsuccessrate k are tabulatedintable .cosalhasbetterscoresonallmetricscomparedto facoy.
even if cosal is used with only static similarity measures cosal static itconsistently performs betterthanfacoy.
since facoy supports only java we also compare facoy to cosalusingbigclonebench.thisexperimentmovesustoward evaluating the feasibility of cosal with open source projects.
we again use leave one out cross validation where each file from bigclonebench is used as a query and the other files are used as search results.
a search result is considered valid if it has the same functionalitygroup as the search query.
compared to atcoder thebigclonebenchdatasetyields better resultsforalltechniques.thisisbecausethe43functionalitiesin bigclonebench have minimal overlap.
this can be corroborated by thebetterscoresfortoken basedsearchcomparedtotheast based search on bigclonebench dataset.
in contrast on atcoder astbasedsearchout performstoken basedsearch.liketheatcoder dataset search based on a combination of measures cosal static cosal yieldbetterresults comparedto facoy.
only4 ofthefilesfrombigclonebenchareexecutable byslacc theremainingfilesdependonexternallibraries.thus dynamic similarity cosal slacc has much lower scores in table5.
subsequently the inclusion of dynamic similarity hardly contributes to the results of cosal as highlighted by their similar valuesforcosal staticandcosal.wedivedeeperintotherole ofdynamic similarityin .
.
compared to state of the art java code to code search facoy usingdynamicinformationhelpscosalobtainsbettersearch resultswhenexecutablecodesnippetsarepresent.intheabsence of dynamic information a combination of ast and token based similaritymeasures stillyieldsbetterresults thanfacoy.
.
rq4 cross languagecodeclonedetection as there is no existing tool for cross language code to code search weinsteadcomparetocross languagecodeclonedetectiontechniques astlearner clcdsa and slacc.
while code to code 212cross languagecode searchusingstatic anddynamic analyses esec fse august athens greece table rq4 cross language performance of cosal in clone detection compared to astlearner clcdsa and slacc on atcoder.
clone detector precision recall f1 single sim.astlearner clcdsa slacc multi sim.cosal static cosal searchcanbepartofclonedetection theyaredifferent.foragiven codesnippet codeclonedetectionreturnsanidenticalcodesnippet and code to code search returns a set of potentially relevant snippets.
hence to use cosal as a clone detection tool we select the top ranked search result returned by non dominated ranking.
astlearner and clcdsa build deep learning models and require a training validation and testing set.
hence we randomly divide our dataset into these three sets using the same approach adoptedinclcdsa .weonlyconsiderprojectswithatleast java and python submissions reducing the dataset to different problems.
for each problem we select ten submissions eachfromjavaandpythonaspartofthetrainingset fiveforthe validationsetandfiveforthetestset.weusedthedefaulthyperparametersfromastlearnerandclcdsatobuildtheirmodels.
since cosal and slacc do not use machine learning models we add all the submissions from the training set to the search database and use the test set for evaluation.
we do not include the validation set in the search database to ensure a fair comparison to astlearner and clcdsa.
to account for variance we repeat this step times andreport the mean precision recallandf1scores.
results are shown in table separating the techniques that use a single similarity measure single sim.
from those that use multiplesimilaritymeasures multisim.
.slaccisthemostprecise technique onthis dataset but hasextremely low recallcomparedto othertechniques andhencethelowestf1.thelow recallonslacc is because itrequires executable codesnippets.cosalhas better precision andrecallcompared to the static similarity approaches astlearner and clcdsa.
if cosal is used only with the static similaritymeasures cosal static theprecision andrecallisstill betterthanastlearnerandcomparable to clcdsa.
forcodeclonedetection cosalobtainsbetter precision recall andf1scorescomparedtoastlearnerandclcdsa without theneedtobuild models.cosal haslower precision toslacc but muchbetter recallandf1score.
discussion we have evaluated cosal extensively against prior work in codeto code search and clone detection.
in all cases it outperforms the competitionwithouttheneedtobuild train orupdatemodels.in this section we discuss the cost benefit of dynamic analysis the potentialfor scalability andthreatsto the validity.table performance based on executable code snippets frombigclonebench.
search mrr p sr sotp github sota facoy single sim.cosal slacc multi sim.cosal static cosal table pearson s correlation r between dtoken dastand diofor cross language snippets on atcoder atc and within language java snippets on atcoder and on executable bigclonebench bcb datasets.
dataset languagecorrelations r token ast token io ast io atc java python .
.
.
atc java java .
.
.
bcb java java .
.
.
.
on thecost benefitofdynamicanalysis in 6.3and table we observe a low scores for code search using io basedsimilarity cosal slacc comparedtoothertechniques due to the small sample of files in bigclonebench with executablecode.tostudytherelativecontributionofdynamicanalysis tocosalresults werepeatthevalidationstudyonbigclonebench but restrictedto the filesthat can be executed .
resultsonthe executable dataset are slightlybetterforallthe techniquescomparedtothecompletebigclonebenchdataset .
although cosal slaccis slightly better than cosal static executing snippets takes more time and memory making code search slow and impractical if the runtime data are not cached.
sincethe gains are not veryhigh with the bigclonebenchdataset itmightbe sufficient to relyonstaticsimilarityinthis case.
however this cannot be generalized across datasets as bigclonebench is built on java code from open source projects.
for cross languagesearch usingdynamicandstaticsimilarity measuresvastlyimprovestheresults.thisisduetothesyntacticdifferences between languages which can be overcome in many cases with dynamic information .
hence the benefit of including dynamic similaritymustbe balancedagainst the costandcontext.
.
on non dominatedsorting for cross language code search combining the similarity measures using an aggregated weighted approach kd io ast token results in lower mrr p kandsr kcompared to the non dominated sortingapproach .asonepotentialexplanation thispoorer performance for the aggregation approach could be a result of bias due to the independence or weak correlation between the three similarity measures .
in this section we explore the impact of the correlations between the similaritymeasures.
213esec fse august athens greece georgemathewandkathryn t. stolee 1classhashmultiset e ... ... 3public int count object element count frequency maps.
safeget backingmap element return frequency null ?
frequency.
get ... a methodthat returnscountof a multisetfrom google guava 1classcounter dict ... count ... ... 6def getitem key returnself.get key ... b function to get countof a key froma counter from collections library.
figure open source code the query in a yields b based on cross language static anddynamic information table8showsthepearson scorrelation r betweenthethreesimilarity measures for cross language and within language snippets on20repeatsof1000randompairsofsnippets.overall forthecrosslanguage analysis we observe lower correlations compared to the within languageanalyses.thecross languagecorrelationsareweak .
r .
to moderate .
r .
.
the singlelanguagecorrelations are moderateto strong .
r .
.
connectingthistoourresults theweaktomoderatecorrelations inthecross languagecontextmayhavecontributedtorelatively betterperformanceofnon dominatedsorting.sincenon dominated sortingiseffectiveforsearchobjectiveswithlowcorrelation itseemsappropriateforcross languagecode to codesearch.
studieshavealsoshownthatnon dominatedsortingworksbestfor fewerobjectives .ascosalisextendedwithmoremetrics inthe future we willwant to revisitthis analysis.
however as correlation impacts the performance of the ranking algorithm non dominated sorting is not a panacea.
when the similaritymeasuresaremorestronglycorrelated whichouranalysis shows is true for single language code search a different approach maybe needed such as aggregation orevolutionary algorithms.
.
scalabilityexploration weexplorethreescalabilityconcerns indexingandsearchingopensourcecode addingnewlanguages andaddingsimilaritymeasures.
.
.
open source repositories.
we used the atcoder and bigclonebench datasets to benchmark our experiments similar to prior art in code search and clone detection .
yet neither dataset is particularly realistic.
atcoder is composed of programming contest submissions and is not a true representation ofopen sourcecode.bigclonebenchcontainsexamplecodeclones making clone detection and code search relatively easier.
to some extent thesedatasets setus andthe baselines upfor success.
wewanttoexplorehowcosalcouldworkwithanarbitrary open source project.
to do this we consider three popular opensource libraries for java and python guavajava library by google commons collections java library by apache software foundation andcollections python2.
systemlibrary.
considerthecodesnippetsinfigure .forthisexample cosal uses4 a as the query which counts the number of occurrencesof an object in the multiset.
across languages cosal identifies a similarcodesnippetfromthe collections libraryinpython b returns the count of an element from a counter.
acounteris a python collection like a bag that takes elements and maintains a count of their occurrences.
for this pair we can see that they sharefewcommontokens count get donothavesimilarasts butare behaviorallysimilar.hence the token basedandio based similarity in cosal influence the ranking of search results and returns4 b as avalid search result for the query a .
in our experiments we see low scores for cosal slaccsince only around of the files in bigclonebench had executable code.
in this open source exploration around of the java and all the python classes had executable code.
the presence of dependent codeinthelibrariescomparedtotheisolatedfilesinbigclonebench actually facilitatedmore widely applicable behavioralanalysis.
thus weconcludethatcosalcanbescaledtosupportopensource projects in the current implementation.
the token based and ast based similarity measures for cosal can be used on any project or file s in its current version.
since the behavioral similaritymeasureusedbycosalisheavilydependentonslacc scaling to support new projects would require the projects have all its dependencies satisfiedandexecutable.
.
.
support for new languages.
cosal currently supports java and python.
while we have not demonstrated scalability to new languages we comment onthe effortrequired.
for dynamic behavior cosal is dependent on slacc so addinganewlanguagetocosalrequiressupportinslacc.however cosal staticcanbeextendedtonewlanguagesbyadapting the token and ast analyses.
a language specific tokenizer like c tokenizer or a generic tokenizer like antlr can be used to parse code and convert it into tokens as detailed in .
.
fortheast cosalusesagenericasttorepresentsourcecode acrossdifferentlanguages.usingalanguage specificastparser likeclangforc orroslynfor.net codecouldbeparsed and converted to the generic ast based on the grammar available inthegithubcoderepositoryforcosal .ifafeaturespecific to a language is not supported by the grammar a new node should be createdbasedonthe feature ssyntactic structure.
.
.
addingnewsearchsimilaritymeasures.
cosalusesthree searchsimilaritymeasuresforcode to codesearch whichprovides a start for this line of research.
new search similarity measures can be added or existing similarity measures can be replaced in cosal.first asimilaritymeasuretocomparecodesnippetshas tobedefined.thesimilaritymeasurehastobeanumericalvalue tosupportnon dominatedrankingofthesearchresults.next an indexmustbecreatedcharacterizingthesimilaritymeasure.lastly the similaritymeasure has to be updatedinthe configurationfile.
.
threatsto validity languagebias .cosalwasimplementedforjavaandpython andmaynot generalize to otherlanguages.
baselinebias .theelasticsearchbaselineforcross languagecodeto code search in rq2 is not an exact representation of a code tocode searchtoolusedbydevelopers .
214cross languagecode searchusingstatic anddynamic analyses esec fse august athens greece databias .thedatasetsarefromaprogrammingcontestanda codeclonebenchmark whicharenotrepresentativeofindustrial or open source coding practices.
however our initial investigationintoopen sourcecode .
.
revealedthatcosalcanbe successfulinthat context but more explorationisneeded.
similarity bias .
cosal uses three similarity measures based on syntacticandsemanticfeaturesforcodesearchbasedonthecontext structure and io behavior.
other similarity measures are not explored in this study.
but cosal can be extended to support thesesimilaritymeasures as describedinsection .
.
.
related work we present work incode similarity search andclone detection.
.
codesimilarity sourcecodesimilarityisusedtocharacterizetherelationshipbetween pieces of code in software engineeringapplicationssuch as program repair code search softwaresecurity andidentifyingplagiarizedcode .code similaritycan be measuredthroughstaticordynamic analyses.
techniques that use static code attributes to compute similarityoftenparsecodeintoan intermediaterepresentationbasedon text ast orgraph based andcompute a measure for syntactic similarity.
for cross language syntactic similarity most techniques are text based .
tree and graph basedapproacheshavenotbeenexploredforcross language similarity due to language specific grammar.
we tackle this challenge by creating a language agnostic grammar by abstracting out common features acrosslanguagesto buildagenericast .
techniques that execute code to determine similarity are classified as dynamic.
for some techniques functions are adjudged to be similar if they have similar inputs outputs and side effects .
other techniques use abstract program states after executions to analyze the behaviors of the code fragments .
dynamic measures are particularly successful in detecting code clones across languages since it does not rely on syntactic properties .
limitations to this approach include the need to executethe code whichdictatesthe granularity andruntime.
.
codesearch incodesearch thegoalistofindcodethatissimilartoagivenquery.
historically developershavepreferredgeneralsearchenginessuch asgoogleandbingwhen searching for code to reuse .
somecodesearchtools usecodesnippetsasthequery aproblemcalledcode to codesearch.solutionstocode to codesearch vary in several dimensions we list three within vs. across languages static vs.dynamicanalysis andindex based vs. modelbased .
in cross language code to code search the query is a code snippetinonesourcelanguageandtheresultsarefromadifferenttarget language s .aroma supportscross languagecode to code search across java hack javascript and python using static analysis based on the parse tree.
since aroma is not publicly available it is not used as a baseline in this study.
infercode is a self supervised cross language java c c and c code representation approach using tree based convolutional neural networks basedon syntax subtrees.
since this work was performed in parallel to our study we have not benchmarked cosal against infercode and leave that for future work.
facoy is a within language code to code search tool on java that uses query alteration to find semantically similar code snippetsusing q a posts.
.
clonedetection clone detection is a special case of code to code search results are identified as clones if they meet a specified similarity threshold.
clonesareoftencategorizedintofourtypes typesi iiiarebased onsyntax andtype ivisbasedonbehavior.
mostcodeclonedetectiontools have been proposed for single language clone detection and on static typed languages like java and c .
a small numberoftoolssupportcross languagecodeclonedetection .
api2vec detects clones between two syntactically similar languages by embedding source code into a vectors and subsequently comparing the similarity between the vectors.
clcdsa identifiesninefeaturesfromthesourcecodeastand usesadeepneuralnetworktolearnthefeaturesanddetectcross language clones.
perez and chiba propose an lstm based deep learning architecture using asts to detect clones in java and pythoncode.thesethreetoolsbuildmachinelearningmodelsto detect code clones.
as a result these techniques require a large numberofannotatedtrainingdatatobuildthemodelandthehyperparametersneedto be carefullyoptimizedto avoid over fitting.
slacc is a cross language code clone detection tool that uses io profiles.
it succeeds in detecting code clones with high precisionbetweenprogramminglanguageswithdifferenttyping schemes.
however slacc requires the code snippets to be executableandas aresult has lowrecallandalarge runtime.
in a clone detection context we use clcdsa the perez and chiba approach andslacc as baselinesfor comparison .
.
conclusion we present cosal a cross language code to code search tool that uses static and dynamic analyses.
it uses two static similarity measuresbasedonextractedtokensfromsourcecodeandatreeeditdistance based on a generic ast and one dynamic similarity measure tocomputeiosimilarity.foragivencodesearchquery thesethree similarity measures find results using non dominated sorting.
our experimentalevaluationon98 645javaandpythonfilesfromatcoder and bigclonebench datasets show that cosal outperforms state of the art code search tools facoy and industrial benchmark of github code search.
we also compare cosal to state of theart clone detection techniques using the atcoderdataset and find that cosal has better recallandf1.
cross language code to code search appears to have a bright future but more work is needed to evaluate itfor more languagesandinrelevantapplications.