archer detecting on chain off chain synchronization bugs in decentralized applications wuqi zhang department of computer science and engineering the hong kong university of science and technology hong kong china wzhangcb cse.ust.hklili wei department of computer science and engineering the hong kong university of science and technology hong kong china liliwei cse.ust.hkshuqing li department of computer science and engineering southern university of science and technology shenzhen guangdong china lisq2017 mail.sustech.edu.cn yepang liu department of computer science and engineering guangdong provincial key laboratory of brain inspired intelligent computation southern university of science and technology shenzhen guangdong china liuyp1 sustech.edu.cnshing chi cheung department of computer science and engineering the hong kong university of science and technology hong kong china scc cse.ust.hk abstract since the emergence of ethereum blockchain based decentralized applications dapps have become increasingly popular and important.
to balance the security performance and costs a dapp typically consists of two layers an on chain layer to execute transactions and store crucial data on the blockchain and an off chain layer to interact with users.
a dapp needs to synchronize its offchain layer with the on chain layer proactively.
otherwise the inconsistent data in the off chain layer could mislead users and cause undesirable consequences e.g.
loss of transaction fees.
however transactions sent to the blockchain are not guaranteed to be executed and could even be reversed after execution due to chain reorganization.
such non determinism in the transaction execution is unique to blockchain.
dapp developers may fail to perform the on chain off chain synchronization accurately due to their lack of familiarity with the complex transaction lifecycle.
in this work we investigate the challenges of synchronizing on chain and off chain data in ethereum based dapps.
we present two types of bugs that could result in inconsistencies between the on chain and off chain layers.
to help detect such on chainoff chain synchronization bugs we introduce a state transition model to guide the testing of dapps and propose two effective oracles to facilitate the automatic identification of bugs.
we build the first testing framework archer to detect on chain off chain synchronization bugs in dapps.
we have evaluated archer on popular real world dapps.
archer achieves high precision .
recall .
and accuracy .
in bug detection and significantly outperforms the baseline methods.
it has found real bugs in the dapps.
so far six of the bugs have been confirmed by the developers and three have been fixed.
these promising results demonstrate the usefulness of archer .
lili wei is the corresponding author of this paper.
esec fse august athens greece .
acm isbn .
.
.
.
concepts software and its engineering software testing and debugging .
keywords software testing decentralized applications dapps blockchain acm reference format wuqi zhang lili wei shuqing li yepang liu and shing chi cheung.
.
archer detecting on chain off chain synchronization bugs in decentralized applications.
in proceedings of the 29th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse august athens greece.
acm new york ny usa pages.
introduction decentralized applications dapps are software applications running on a decentralized network like blockchain.
since the emergence of ethereum a blockchain platform that supports turingcomplete smart contracts blockchain based dapps have drawn much attention from both academia and industry.
as of april on ethereum there are over .
thousand dapps and thousand active dapp users issuing over thousand transactions per day .
as shown in fig.
dapps are typically deployed as web applications consisting of two layers on chain and off chain .
the former comprises a set of smart contracts that store and update crucial data on the blockchain.1the latter contains a user friendly front end client and an optional centralized service outside the blockchain .
take giveth a popular dapp for charitable donation on ethereum as an example.
it comprises a set of on chain smart contracts and an off chain front end backed by a centralized cache server.
to avoid frequent communication with the blockchain and facilitate users queries the off chain layer usually 1to save transaction costs blockchain typically only stores crucial data .arxiv .09440v2 sep 2021esec fse august athens greece wuqi zhang lili wei shuqing li yepang liu and shing chi cheung front end clientcentralized servicesmart contractsdappoff chainon chain figure the architecture of a typical dapp stores processed or analyzed results of certain important on chain data.
therefore a dapp s state is composed of an on chain state and anoff chain state referring to the data stored at the on chain e.g.
data in giveth s smart contracts and the off chain e.g.
database of giveth s cache server layers respectively.
the on chain and off chain states of a dapp are not necessarily the same.
dapps usually maintain a mapping between the on chain and off chain states.
since blockchain is autonomous and the on chain state may change out of the control of dapps dapps need to proactively synchronize their off chain states and keep them consistent with the on chain states.
we call such a process on chain off chain synchronization .
on chain off chain synchronization can be complicated.
changes are made to the on chain state of a dapp by sending transactions to the blockchain.
however transaction executions are nondeterministic due to the decentralized nature of blockchain .
on the one hand transactions sent to the blockchain are not necessarily executed and could be dropped silently even after being acknowledged by the miners .
on the other hand executed transactions could be reversed as a result of chain reorganization .
such non determinism is unique to blockchains and does not exist in conventional centralized services or distributed systems.
if the non determinism is not carefully considered and dealt with in the development of a dapp inconsistencies between its off chain and on chain states may arise when the dapp is running.
such inconsistencies can cause catastrophic consequences.
it is because users typically take actions e.g.
buying and selling according to the off chain state shown at the front end client of a dapp.
stale data at the off chain layer can mislead users into taking wrong actions that result in irreversible changes on the blockchain or financial losses.
for example in a dapp like giveth if a donation transaction is reversed on the blockchain while the dapp s off chain layer is unaware of the reverse and does not update the donation status subsequent transactions to withdraw the donation will fail causing the loss of transaction fees.2we refer to such bugs that stem from non deterministic transaction execution and induce inconsistencies between the on chain and off chain states as on chain off chain synchronization bugs .
it is non trivial to avoid on chain off chain synchronization bugs even if developers have considered them in the development of dapps.
giveth developers have written more than lines of code3to track the lifecycle of all transactions and keep the consistency between the on chain and the off chain states.
augur 2ethereum users need to pay fees for each transaction no matter the transaction succeeds or not .
very popular dapp implements a delicate rollback table4 to revert off chain states when the transactions are reversed on the blockchain.
in spite of the efforts that developers take we still find on chain off chain synchronization bugs in those dapps as discussed in section .
.
while several bug detection techniques have been proposed to assure the quality of dapps they are either general tools for specifying test cases and assertions or focus only on the onchain layer by finding defects in smart contracts .
in other words none of them can effectively pinpoint on chainoff chain synchronization bugs in dapps.
this motivates us to investigate the on chain off chain synchronization bugs and devise testing techniques to detect such bugs.
on chain off chain synchronization bugs could occur in dapps on all blockchain platforms.
due to the impact of the ethereum blockchain our work focuses on ethereum based dapps.
to ease presentation we may simply refer to ethereum based dapps as dapps in the following.
there are two major challenges in detecting on chain off chain synchronization bugs in dapps.
first we need to expose the nondeterminism of the transaction executions which is not considered by existing testing environments so that on chain off chain synchronization bugs can be better revealed.
second the mapping between on chain and off chain states is usually unavailable and hard to specify.
hence it is impractical to compare on chain and off chain states to check consistency directly.
we need a decidable criterion to mechanically judge the consistency thus identifying the existence of the bugs.
to address the first challenge we study the causes of the synchronization bugs and propose a state transition model for the lifecycle of transactions on the ethereum blockchain.
guided by the model we are able to trigger the scenarios where transactions are dropped or reversed to test dapps.
to address the second challenge we propose two test oracles based on the following key observation the off chain state of a dapp should stay the same if the corresponding on chain state is unchanged and a violation of this requirement would indicate the existence of bugs in the state synchronization process.
with these oracles we are able to define assertions only on the off chain states to effectively reveal on chain off chain synchronization bugs in dapps without knowing the mapping between the on chain and the off chain states.
we implement our approach as a dapp testing framework called archer and evaluate it using popular real world dapps.
these dapps vary in scale ranging from hundreds to tens of thousands of lines of code and have received at least stars on github.
our experiment results show that archer is effective.
it is able to detect on chain off chain synchronization bugs in all of the dapp subjects.
we manually check warnings reported by archer group the ones with the same root cause and submit issue reports on github.
so far bugs in six issue reports have been confirmed by developers.
these bugs can cause transaction failures continuous errors being prompted in the dapp client ui or incorrect information being displayed to users.
this paper makes three major contributions detecting on chain off chain synchronization bugs in decentralized applications esec fse august athens greece to the best of our knowledge this is the first study that examines the bugs in the on chain off chain synchronization process of dapps.
we formulate the problem with a state transition model of the transaction lifecycles.
using the model we present the challenges in on chain off chain synchronization and the causes of the synchronization bugs.
we propose two test oracles that are able to effectively identify inconsistencies between on chain and off chain states without knowing the mapping between them.
based on the transition model and the proposed oracles a testing framework archer is built to detect on chain off chain synchronization bugs in ethereum based dapps.
archer is open source on github5.
we evaluate archer on real world dapps and conclude that archer can detect bugs with high precision .
recall .
and accuracy .
.
we submit issue reports to developers and six have been confirmed.
background .
two layer architecture of dapps in section we have briefly introduced the architecture of dapps.
this section further explains several important concepts in detail.
.
.
on chain and off chain layers.
the two layer architecture of dapps is to balance security maintainability performance and costs .
blockchain e.g.
ethereum as a decentralized ledger offers a highly secure data store with programmable smart contracts in the on chain layer.
however storing data and computations on blockchain incurs a high latency and requires paying a non negligible transaction fee.
besides interacting with blockchain by sending transactions and interpreting logs in low level bytecode is also not friendly for ordinary users.
the off chain layer is meant to improve the performance and reduce costs using a user friendly front end and centralized services optional without sacrificing too much in the way of security .
.
.
on chain and off chain states.
as mentioned in section dapps execute key logics implemented in smart contracts and store crucial data on the blockchain as the on chain state.
users usually take actions in the off chain layer according to the results of some calculations involving on chain data.
it is expensive to store such intermediate results back onto the blockchain.
it is also inefficient to query the on chain state to perform the calculations repetitively.
as a result dapps usually store a simplified view of their on chain state and some relevant calculation results at the off chain layer as the off chain state.
note that the off chain layer may also store other data irrelevant to the on chain state.
in this paper we do not include such data in our definition of the off chain state.
.
.
on chain off chain synchronization.
dapp users send transactions to the blockchain via the off chain layer to make changes to the on chain state.
during the lifecycle of each transaction blockchain emits various events.
dapps can monitor such events to keep their off chain state synchronized with the corresponding on chain state.
this process is easy to implement if the transactions are executed deterministically on a centralized service or database.
this is not the case on the blockchain as will be explained in the next subsection.
.
non deterministic transaction execution transactions sent to the blockchain will be broadcast to miners throughout the network.
conceptually miners on a blockchain collectively maintain a pool of transactions awaiting execution.
a transaction is added to the transaction pool when it is received by a miner.
a transaction is executed non deterministically on the blockchain from two aspects.
first a transaction may not be executed after it has been sent by dapp users.
second an executed transaction can be reversed from the transaction history.
in the following we explain how such non determinism arises.
.
.
sent transactions may not be executed.
a miner can select which transactions to execute from the pool when a new block has been mined.
it is possible that a transaction is not selected and keeps staying in the pool.
an old transaction in the pool can be invalidated by a new one with the same nonce which is the index of a transaction sent from the user .
the invalidated transactions will be dropped and never be executed on the blockchain.
in addition miners can silently drop transactions for various reasons e.g.
due to the size limit of the transaction pool .
.
.
executed transactions may be reversed.
a newly mined block is not necessarily added to the blockchain.
when multiple miners concurrently mine a new block the blockchain will fork multiple chains of blocks.
to resolve this problem the blockchain will validate only the longest chain and invalidate the others.
the process is known as chain reorganization .
if the execution of a transaction is recorded by a block in an invalidated chain the transaction will be reversed and put back to the pool.
in practice chain reorganization can hardly affect blocks with a sufficient number of confirmations which are the succeeding blocks on the same chain .
such non determinism in transaction execution complicates the interactions and synchronization between the on chain and offchain layers of a dapp.
bugs can arise if the dapp handles the non determinism inappropriately.
in section we will give a realworld example of such bugs.
motivating example in this section we present a code snippet adapted from giveth to illustrate the on chain off chain synchronization in dapps and an on chain off chain synchronization bug .
listing shows a code snippet for the withdraw donation functionality in the front end client of giveth which allows users to withdraw the donations they receive.
the front end client of giveth uses web3.js an official ethereum javascript library to send a transaction to an underlying smart contract liquidpledging and call its withdraw function as seen in line .
the client registers a callback for handling the transactionhash event which occurs when the transaction is added to the blockchain transaction pool line .
since the transaction is to modify the on chain state concerning the donation amount the off chain state is also updated accordingly line .
after the update a corresponding withdrawesec fse august athens greece wuqi zhang lili wei shuqing li yepang liu and shing chi cheung 1function withdrawdonation withdraw donation from one crowdfunding project contract .
liquidpledging .
withdraw ... arguments send withdraw transaction to smart contract .
once transactionhash hash function called when transaction is sent let txhash hash updateexistingdonation existingdonation amount update existing donation after withdraw const withdrawrecord ... create a new withdraw record feathersclient .
service donations .
create withdrawrecord save the withdraw record in the centralized database .catch onerror listing withdraw donation functionality in the dapp giveth record is created and stored in an off chain centralized database line .
the code in listing may not work correctly because the withdraw donation transaction may remain in the transaction pool indefinitely or be dropped without execution.
the occurrence of the transactionhash event only signifies that a transaction has been added to the transaction pool rather than the execution of the transaction.
even if the transaction has been executed it can still be reversed later.
therefore it is possible that the off chain state is updated while the on chain state remains unchanged i.e.
when the withdraw transaction is dropped or reversed .
such state inconsistencies can lead to many undesirable consequences.
for example let us consider the following scenario.
a user of giveth sends a withdraw donation transaction to the smart contract but the transaction is dropped by the blockchain.
however due to the bug the giveth client incorrectly shows that the donation has been withdrawn.
the user may decide to donate the withdrawn cryptocurrency to another community.
in such a scenario the new donation transaction may fail causing unnecessary loss of transaction fees and poor user experience.
it is difficult to expose on chain off chain synchronization bugs using existing dapp testing tools.
for example ganache is one of the most commonly used blockchain environments for testing ethereum based dapps.
like testing on centralized databases transactions sent to ganache blockchain are executed immediately.
therefore when testing giveth using ganache the on chain and off chain states are always consistent.
the bug mentioned above can never be detected.
to tackle this problem we propose to model the non determinism in transaction execution using the transaction lifecycle.
our approach simulates the non deterministic transaction execution process and drives dapps to traverse each transaction s lifecycle systematically.
we also propose effective test oracles to detect inconsistencies between the on chain and off chain states automatically.
methodology this section first proposes a state transition model to capture the lifecycle of transactions on the ethereum blockchain.
we then discuss the challenges in on chain off chain synchronization and identify two types of synchronization bugs that may arise in dapps.
after that we propose our framework archer to detect on chainoff chain synchronization bugs in dapps.
.
transaction lifecycle to detect on chain off chain synchronization bugs we model the non determinism in the lifecycle of a transaction on the ethereum blockchain using a state transition model as shown in fig.
.
a createdpendingexecutedfinalizeddroppedreversed figure state transition model of the ethereum transaction lifecycle transaction starts its lifecycle at the created state by constructing the required arguments at the dapp s off chain layer.
after that the transaction is sent to the blockchain and transits to the pending state meaning that the transaction is added to the transaction pool awaiting execution on the blockchain.
a transaction may remain in the pending state indefinitely as miners are free to select more profitable transactions for execution.
apending transaction can be dropped and transit to the dropped state in two cases.
first users may send a duplicated transaction to override the previous transaction or offer a higher fee to increase the chance of execution .
second the transaction may be deleted silently by miners due to the capacity limit of miners transaction pool or malicious behaviors of miners.
in the latter case the dapp is not informed that a transaction has been dropped.
it is also hard for the dapp to proactively check whether a transaction is dropped on the blockchain or not.
apending transaction transits to the executed state when it is executed and included in a block.
as discussed in section an executed transaction can be reversed when the blockchain is reorganized.
when it happens the transaction will transit from theexecuted state to the reversed state and be put back to the archer detecting on chain off chain synchronization bugs in decentralized applications esec fse august athens greece transaction pool awaiting execution.
similar to the pending state transactions in the reversed state can also be dropped.
while in theory executed transactions can be reversed in practice a transaction whose execution has been logged by a block with a sufficient number of confirmations can be considered finalized i.e.
the transaction will transit from the executed state to the finalized state.
the number of confirmations required varies according to the security requirements of the dapp .
to avoid problems caused by reversed transactions one common practice adopted by dapp developers is to use the result of a transaction at the off chain layer only after the transaction transits to the finalized state .
to estimate the frequency of transaction state transitions we collect ethereum traffic data from etherscan and an ethereum full node maintained by us.
we find that the average number of transactions submitted to ethereum per second is .
.
the average number of transactions executed by ethereum per second tps is .
which indicates that around half of the transactions cannot be immediately executed after submission.
we also monitor the ethereum mainnet for over months and observe that chain reorganization happens every .
blocks i.e.
every .
minutes.
the average number of transactions reversed per hour due to such chain reorganizations is .
.
these statistics show that the drop and reverse rates of transactions on ethereum are non negligible and it is necessary for dapps to consider the non deterministic transaction execution to avoid on chain off chain synchronization bugs.
.
on chain off chain synchronization bugs in section we have presented an on chain off chain synchronization bug in a dapp named giveth.
on chain off chain synchronization bugs occur when dapps fail to maintain the consistency between their on chain states and off chain states.
in the giveth bug developers do not consider the situation in which a pendingtransaction is dropped by the blockchain and inconsistencies are thus induced.
such inconsistencies can result in erroneous offchain states which might mislead users.
further operations based on these erroneous states can cause unexpected changes on the blockchain or waste transaction fees.
since dapps are a new kind of software applications the lack of understanding of state transitions in the transaction lifecycle may make it difficult for developers to assure proper on chainoff chain synchronization.
we observe that developers often assume that the transactions submitted by their dapp would be executed and eventually finalized on the blockchain while ignoring the situations where a pending orreversed transaction is dropped silently by the blockchain or an executed transaction is reversed due to chain reorganization.
as a result on chain offchain synchronization bugs often arise.
in this paper we focus on studying on chain off chain synchronization bugs triggered in the two situations.
we refer to them as type i and type ii bugs respectively.
fig.
illustrates how these two types of bugs could occur 6we distinguish the pending and reversed states because they are separately handled by the ethereum official library web3.js under different javascript events transactionhash andchanged .
7the frequency of chain reorganizations is calculated by the total number of canonical blocks mined or the total time elapsed divided by the total number of invalidated blocks within the period that we monitor the ethereum mainnet.with our transaction lifecycle model.
we will introduce them in detail below.
.
.
type i bugs.
as fig.
a shows type i bugs occur because the off chain state is prematurely updated when the transaction is inpending state but in fact the transaction is later dropped.
the bug in giveth as shown in listing is a type i bug.
giveth immediately updates its off chain state lines when the donation withdrawal transaction is submitted to the blockchain.
it does not further check the state of the transaction and does not adequately deal with potential state changes.
.
.
type ii bugs.
as fig.
b shows type ii bugs occur because the off chain state is updated after the transaction transits to the executed state but the executed transaction is later reversed due to chain reorganization.
issue of augur a popular dapp for prediction markets is a type ii bug.
augur updates its off chain state when the transactions that create markets are executed but does not revert the off chain state when the executed transactions are reversed.
consequently the front end client of augur would display markets that do not exist on the blockchain.
any further operations on these markets will result in market not found errors.
these two types of bugs are not well studied in the literature.
existing techniques either focused on testing smart contracts which are only concerned with the on chain layer of dapps or do not fully consider the entire lifecycle of transactions when testing dapps .
take the popular dapp testing environment ganache as an example.
when using ganache dapp developers are encouraged to configure the testing blockchain to execute transactions immediately while the possible state transitions from pending todropped or from executed toreversed are ignored .
as a result type i and type ii bugs can easily slip into real world dapps.
this motivates us to propose archer a testing framework to effectively detect the two types of on chain off chain synchronization bugs in dapps.
.
the archer testing framework we can see from the above discussion that we need to systematically emulate transaction state transitions to trigger on chain off chain synchronization bugs.
guided by our transaction lifecycle model archer controls the execution of each transaction in its testing environment to drive the transaction to traverse possible states.
however triggering bugs alone is not sufficient.
effective testing also requires oracles to judge the existence of bugs.
in the following we present our design of test oracles in archer and then explain how to leverage the oracles to detect on chain off chain synchronization bugs during testing.
.
.
test oracles.
it is challenging to design oracles for detecting on chain off chain synchronization bugs.
although the on chain and off chain states in dapps need to be consistent they are not necessarily identical.
off chain states are often maintained as a simplified version of the corresponding on chain states to facilitate front end user actions.
for instance in our motivating example giveth s cache server processes on chain donations and stores processed data instead of making an exact copy of the on chain state.
the processed data contains additional information such as theesec fse august athens greece wuqi zhang lili wei shuqing li yepang liu and shing chi cheung createdpendingexecutedfinalizeddroppedoff chain state update a type i createdpendingexecutedfinalizeddroppedreversedoff chain state update b type ii figure transaction lifecycles for the two types of on chain off chain synchronization bugs.
the solid arrows depict the actual state transitions and the dashed arrows depict the transitions assumed by dapps.
for type i bugs the off chain state is prematurely updated when the transaction is pending .
for type ii bugs the off chain state is updated when the transaction isexecuted but the updated state is not reverted when the transaction is reversed.
index of donations to facilitate user queries.
however such information is not saved on blockchain to reduce the cost of interacting with smart contracts.
in addition updates of the off chain state depend on both the changes to the on chain state and the program logic of the off chain layer.
therefore it is hard to specify the mapping between the on chain and off chain states as well as directly check whether the off chain state is consistent with the on chain state.
to address the challenge we design oracles that check onchain off chain state consistency by only comparing the off chain states of the dapp when the concerned transaction is at different lifecycle stages.
in this way the mapping between on chain and off chain states is not required.
in the following we present the test oracles.
test oracle for type i bugs.
for type i bugs we observe that when a transaction tis added to the transaction pool i.e.
transits from the created state to the pending state the dapp should not prematurely update the off chain state as if tis executed and finalized.
since dapps are not informed when transactions transit from thepending state to the dropped state any premature updates of the off chain state are likely to remain when the transactions are dropped on the blockchain.
assertion helps detect such bugs.
assertion .
for each transaction t t created t finalized implies t pending t finalized .
in the above formulation t s denotes the off chain state of the dapp under test when the transaction tis at the transaction lifecycle state s. the clause t created t finalized means that the transaction tresults in an update to the off chain state.
the clause t pending t finalized specifies that the off chain state should not be updated as if the transaction has been finalized when the transaction has been just sent to the transaction pool.
note that this assertion allows dapps to make changes to the offchain state when the concerned transaction is pending but the changes should not indicate that the transaction has been finalized .
violations of assertion indicate the existence of type i bugs.
test oracle for type ii bugs.
when a transaction is executed i.e.
transits from the pending state to the executed state some dapps may update their off chain states.
type ii bugs occur when the executed transaction is reversed due to chain reorganization but the updated off chain state is not reverted accordingly.
archer leverages assertion to check for type ii bugs.assertion .
for each transaction t t pending t reversed .
since reversed transactions are put back to the transaction pool the off chain state of the dapp when transaction tis at the pending state should be the same as that when tis at the reversed state.
violations of assertion indicate the existence of type ii bugs.
.
.
lifecycle emulation assertion checking.
as discussed earlier in existing blockchain testing environments such as ganache transactions are directly executed and finalized once submitted to the blockchain.
these transactions are never dropped or reversed and thus type i and type ii bugs cannot be triggered.
to address the limitation archer implements a blockchain environment that can control the state of transactions.
instead of executing a transaction immediately after it is submitted to the blockchain archer drives the transaction to traverse lifecycle states in the following order created pending executed reversed executed finalized .
such a traversal allows our proposed oracles to be evaluated for each transaction to detect the two types of on chain off chain synchronization bugs.
specifically when there is a state transition archer fetches and stores the off chain state of the dapp under testing.
after the state traversal terminates the fetched off chain state is checked against the assertions and .
if there is any assertion violation archer will report a bug.
more details of bug detection will be further introduced in section .
implementation dappstate consistencyanalyzer test report sendtransactionfront end explorer controlled blockchaintraverselifecyclefetch off chain stateafter each state transitionfire ui events figure overview and workflow of archer archer detecting on chain off chain synchronization bugs in decentralized applications esec fse august athens greece fig.
shows an overview of archer .
given a dapp the frontend explorer fires ui events to exercise the dapp to explore the functionalities that involve sending transactions.
once a transaction is sent archer leverages a controlled blockchain to execute it and traverse its lifecycle states in the order mentioned in section .
.
.
during the state traversal process archer keeps fetching the offchain state of the dapp whenever there is a state change.
the state consistency analyzer then checks such collected off chain states to detect bugs.
we have open sourced archer on github8.
in the following we present more details on how archer is implemented.
.
the front end explorer as mentioned earlier the front end explorer fires ui events to exercise dapps.
in practice developers can use any applicable tool or manually write test cases for purpose.
in the current implementation of archer we choose to integrate a popular web testing tool crawljax to generate gui events to test dapps which are often web based applications.
crawljax infers a state flow graph when testing a web application.
gui events are fired at the states that can transit to unvisited states.
the state flow graph is updated whenever new states are discovered during testing.
the exploration will stop when all of the states in the graph have been visited.
such model based testing can help exercise dapps to interact with the blockchain.
.
the controlled blockchain we implement a controlled blockchain in archer based on geth a popular ethereum client.
when the dapp under test submits a transaction to our controlled blockchain archer will drive the transaction to traverse its lifecycle states according to the order mentioned in section .
.
.
.
the state consistency analyzer as mentioned in the overview during testing archer keeps collecting the off chain state data for bug detection.
different dapps may maintain the off chain states in different ways e.g.
using various databases such as mysql and mongodb or browser storage such as indexeddb and localstorage.
it is hard to design a tool to automatically identify runtime values representing the off chain states for all dapps.
as a workaround we build our off chain state fetcher for different data storage including databases browser storage and html elements.
users of our tool only need to configure a few rules to specify the variables and fields that constitute the off chain state of their dapps e.g.
specifying column names in databases or regular expressions to include or exclude table columns .
to minimize the runtime overhead archer does not instrument dapps.
since it is hard to determine when a dapp finishes updating its off chain state at runtime archer would wait for a period of time when a transaction s lifecycle state changes before fetching the off chain state.
the waiting time is configurable in archer .
after the state traversal process completes archer checks the fetched off chain states to identify the two types of on chain offchain synchronization bugs according to the two oracles proposed in section .
.
.
evaluation we evaluate archer on real world web based dapps.
specifically we investigate the following research questions rq1 bug detection capability can archer effectively detect on chain off chain synchronization bugs in real dapps?
rq2 efficacy of our oracles how effective are our proposed oracles?
can on chain off chain synchronization bugs be detected using existing oracles?
rq3 usefulness can archer detect on chain off chain synchronization bugs that are useful to developers?
.
subjects to collect subjects for evaluation we search for ethereum dapps on github using the keyword ethereum with constraints stars language javascript orlanguage typescript .
the first constraint is to ensure the popularity of the selected subjects.
the second constraint is to help find web based dapps.
the search returns projects.
we manually check each project to exclude those that are not web applications or those that are libraries blockchain clients block explorers transaction trackers frameworks operating systems and so on.
projects that are tagged as deprecated or archived are also excluded because they are not actively maintained.
furthermore we exclude those that are claimed to be examples tutorials or starters as we are interested in real dapps rather than toy examples.
after this filtering process dapps remain.
finally archer is a dynamic testing framework which requires executing transactions of smart contracts on a local controlled blockchain.
although a number of dapps provide the source code of smart contracts and web applications many of them lack instructions to deploy their smart contracts on a local blockchain.9they expect users to deploy the open source web applications on ethereum public testnets or mainnet where contracts have been well deployed.
therefore we exclude those projects that we fail to deploy on our local blockchain by following the provided instructions.
after the above filtering we collect a total of popular real world dapps for experiments.
this is in line with the finding in an empirical study made by wu et al.
that few dapps are fully open source.
table provides the information of these subjects.
the selected subjects differ in scale.
the smallest dapp has less than lines of code while the largest dapp has more than lines of code.
the purposes of the subjects are also quite diversified.
.
experiment design in this subsection we explain how we set up our experiments derive off chain states and establish the ground truth to validate bug detection results.
we also introduce the baselines against which archer will be compared.
experiment setup.
we deploy the subjects locally on our controlled blockchain.
we set the archer s waiting time for dapps to update their off chain states to be seconds which is aligned 9deploying contracts not only requires sending contract creation transactions but also involves other specific transaction to initialize contract states e.g.
linking to other existing contracts setting configurations etc.
10as an example the web interface of a famous decentralized exchange dapp uniswap only works on testnets and will not work on other blockchains as stated by developers .esec fse august athens greece wuqi zhang lili wei shuqing li yepang liu and shing chi cheung with the average block interval time on ethereum mainnet .
we run archer on each dapp for one hour.
we observe that this is sufficient for archer to reach the saturation of test coverage during experiments.
we repeat the testing process ten times for each dapp to mitigate the randomness of cralwjax.
off chain state derivation.
one challenge in the experiments is to identify the data fields that compose off chain states.
as we have discussed in section .
different dapps may maintain offchain states in different ways.
essentially archer requires developers to manually specify which data fields or variables in the dapp constitute the off chain state.
however such specification is unavailable for our evaluation.
as a workaround we manually explore each dapp and derive the off chain state by including those data fields that are updated when transactions are directly executed i.e.
going through the states created pending executed finalized .
the intuition behind is that we assume developers have tested their dapp to assure that the off chain state is properly updated when transactions undergo such normal executions.
note that archer does not integrate this off chain state derivation mechanism in that the aforementioned assumption does not necessarily hold for all dapps.
result validation.
to evaluate the precision and recall of archer for each dapp we manually reproduce all transactions generated during testing and make them go through the lifecycle to identify potential inconsistencies between the on chain and off chain states.
this process is independently performed by two authors.
the results are cross checked for consistency.
it is worth mentioning that the recall metric we used here is for evaluating archer s capability of catching type i and type ii bugs once they arise during the processing of transactions.
we do not aim to evaluate how many of all possible on chain off chain synchronization bugs can be detected by archer since it is hard to obtain the ground truth.
not only that the crawljax front end explorer may not be able to trigger all possible transactions during testing.
baselines.
since there is no prior work for detecting on chainoff chain synchronization bugs in dapps we construct two baseline methods by replacing oracles used by archer with the ones used for detecting smart contract vulnerabilities and web application faults .
specifically baseline i would report bugs if the execution of a transaction violates the assertions defined by contractfuzzer .
baseline ii would report bugs if runtime errors occur in the javascript console during the testing process .
except for the differences in oracles the two baseline methods use exactly the same tests for each dapp and traverse the lifecycle of each transaction in the same way as archer .
we do not compare archer with existing blockchain testing environments such as ganache since none of them is able to emulate the lifecycle of transactions and thus neither type i nor type ii bugs can be triggered by them.
.
rq1 bug detection capability table presents the results of archer and baselines including the overall test coverage precision recall and accuracy.
since archer aims to test the correctness of synchronization between the onchain and off chain layers in dapps during the transaction execution process we measure the test coverage in terms of how welltable the dapps used in our experiments dapp stars loc js commits purpose agrochain agricultural supply chain augur prediction markets democracyearth governance for daos eth hot wallet wallet ethereum voting dapp voting giveth charitable donation heiswap anonymous transfer metamask wallet multisender one to many transfer publicvotes voting todolist dapp todo list transaction submission api call sites are covered during testing11.
such api call sites are essentially the starting point of on chainoff chain synchronization.
their coverage could indicate the diversity of the tests generated by the front end explorer.
note that since some functionalities relying on ethereum public blockchain services e.g.
uniswap are unavailable on the controlled blockchain of archer api call sites for such functionalities are not considered in our coverage measurement.
in the following we will discuss the experiment results in detail.
coverage.
archer triggers a total of transactions and covers of the transaction submission api call sites when testing the dapps.
it achieves an overall accuracy of .
in deciding whether a transaction handling process contains bugs or not.
false positives.
altogether there are transactions violating assertion and transactions violating assertion .
there is no transaction violating both assertions.
among these transactions there are exhibiting type i bugs which are found to be false positives fps .
there are no false positives for those detected to exhibit type ii bugs.
we find that all of the fps are related to the dapp giveth.
they arise from the unexpected delays in updating the off chain states in giveth s cache server.
for instance when a transaction reaches the pending state giveth makes a partial update to the off chain state with a flag indicating that the transaction is awaiting execution.
the flag should be cleared when the transaction isfinalized .
however it is not cleared within seconds so that archer fetches the same off chain state as the one fetched when the transaction is pending .
in this case archer reports a violation of assertion but in fact it is a false positive.
if archer waits for a longer period before fetching the off chain state the violation will not be reported.
despite the fps archer still achieves an overall precision of .
in detecting on chain off chain synchronization bugs in the collected dapps.
false negatives.
there are and transactions exhibiting type i and type ii bugs respectively which are missed by archer .
after investigating the corresponding transactions we find two major reasons for the false negatives fns .
first archer may fetch the off chain state before it is inappropriately updated in the same way as mentioned in the previous giveth example.
second transactions may depend on each other.
an on chain off chain synchronization bug may occur if a transaction vis executed based on the interim result of another transaction u while uis reversed 11we are able to measure the coverage of transaction submission api call sites because dapps use designated apis provided by the official libraries e.g.
web3.js of ethereum to interact with the blockchain.
archer detecting on chain off chain synchronization bugs in decentralized applications esec fse august athens greece and dropped.
fn occurs if the dapp does not update the off chain state for transaction v neither assertion or will be violated if the off chain state is unchanged .
despite such cases the recall of archer is still quite high and reaches .
in our experiments.
answer to rq1 archer can effectively detect on chain offchain synchronization bugs in dapps with high precision .
recall .
and accuracy .
.
.
rq2 efficacy of our oracles we answer rq2 by comparing archer with the two baseline methods that employ existing oracles.
the results of baselines are also presented in table .
as we can see from the table baseline i only generates warnings for seven transactions.
after inspecting the seven transactions whose execution violates vulnerability assertions we find that the underlying smart contract contains the exception disorder vulnerability according to the bug definition by jiang et al.
.
however these seven warnings are all fps in terms of on chain off chain synchronization bugs.
smart contract vulnerability oracles cannot detect any on chain off chain synchronization bugs in the experiment.
this is because the detection of on chain off chain synchronization bugs requires the examination of both on chain and off chain layers of a dapp whereas the oracles for smart contract vulnerabilities examine only the on chain layer.
baseline ii is able to reveal some on chain off chain synchronization bugs.
for example a bug in augur results in a runtime error with message uncaught in promise error execution reverted when a transaction is reversed.
however the runtime error oracle is not effective compared to our proposed oracles.
our experiments show that the overall precision recall and accuracy of baseline ii are only .
.
and .
respectively which are significantly worse than archer .
in addition the runtime error messages generated may not provide useful information about the root causes of on chain off chain synchronization bugs.
for instance the message error pollingblocktracker encountered error fetching block generated in the testing of metamask gives little hint of the occurrence of a synchronization bug.
answer to rq2 our proposed oracles significantly outperform the existing ones in terms of detecting on chain off chain synchronization bugs.
.
rq3 usefulness we answer rq3 by reporting bugs detected by archer to the developers and communicating with them.
although archer reports warnings for thousands of transactions in the experiments lots of them are repeated explorations of the same functionalities in dapps.
to avoid overwhelming developers we group the warnings with the same root cause into a single issue to report to the developers.
table.
lists the ids of the github issues in which we report on chain off chain synchronization bugs to the dapp developers.
in total we have reported bugs of which six have been confirmed by developers and three have been fixed.
developers providepositive feedback on our reported bugs.
for example developers of giveth respond syncing two backend cache server and blockchain is a delicate and complex job and we hope it is solved soon and the bugs in giveth were fixed one and a half month after we reported them.
the comment indicates that the reported on chain off chain synchronization bugs are real and the on chain off chain synchronization is complex.
detection of the bugs is useful to developers in improving the quality of dapps.
due to the complexity of on chain off chain synchronization developers are likely to improperly handle scenarios where transactions are dropped or reversed.
for instance the developers of giveth are aware of the possibility that transactions can be reversed after execution and giveth is designed only to update the off chain state when transactions reach the finalized state.
however as discussed in section the handling of some transactions is still flawed and the off chain state is updated prematurely without waiting for the transaction to be finalized.
another example is augur which maintains a rollback table that stores the metadata used to revert the off chain state when a transaction is reversed on the blockchain.
however the rollback table is cleared unexpectedly when the page is refreshed after the transaction is executed.
in such cases the off chain state does not get reverted when a transaction is reversed causing inconsistencies between off chain and on chain states.
archer has been able to catch the above on chain off chain synchronization bugs and they have been confirmed and fixed by developers.
this demonstrates that on chain off chain synchronization bugs could still occur in those dapps whose developers have already considered the non determinism of transaction execution and archer is able to help developers catch the hidden bugs.
answer to rq3 among bugs reported to developers six have been confirmed and three have been fixed.
responses from developers show that archer is useful in detecting on chainoff chain synchronization bugs.
discussions .
synchronization strategies in the evaluation we observe that some dapps have considered the possibility that pending transactions can be silently dropped and that executed transactions can be reversed.
however on chain offchain synchronization bugs are still detected in these dapps.
this indicates that on chain off chain synchronization is non trivial and error prone highlighting the detection capability of archer .
to better understand how developers of dapps synchronize on chain and off chain states we further investigate the synchronization strategies adopted in the dapps used in our evaluation.
we observe three common strategies as follows.
periodic polling.
the most straightforward way to synchronize on chain and off chain states is to poll the on chain state periodically.
for instance democracyearth registers a daemon task that periodically checks the on chain state and updates the off chain state accordingly.
this strategy effectively keeps the off chain state consistent with the on chain state during the lifecycle of transactions.
nevertheless periodic polling is inefficient if the dapp is complicated.
if redundant synchronization work isesec fse august athens greece wuqi zhang lili wei shuqing li yepang liu and shing chi cheung table experiment results of archer and baselines dappapi call site coveragetotal txs.
archer baseline i baseline ii tp fp fnpre.
rec.
acc.contract vulnerability oracle runtime error oracle i ii i ii i ii tp fp fn pre.
rec.
acc.
tp fp fn pre.
rec.
acc.
agrochain .
.
.
.
.
.
.
.
augur .
.
.
.
.
.
.
.
.
.
democracyearth .
.
.
.
.
.
.
.
eth hot wallet .
.
.
.
.
.
.
.
.
ethereum voting dapp .
.
.
.
.
.
.
.
giveth .
.
.
.
.
.
.
.
.
heiswap .
.
.
.
.
.
.
.
.
metamask .
.
.
.
.
.
.
.
.
multisender .
.
.
.
.
.
.
.
publicvotes .
.
.
.
.
.
.
.
.
todolist dapp .
.
.
.
.
.
.
.
total overall .
.
.
.
.
.
.
.
.
.
average .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
txs.
is short for transactions.
we report the number of tps fps and fns for type i and type ii bugs separately in the detection results of archer .
we use pre.
rec.
and acc.
as abbreviations for precision recall and accuracy respectively.
precision is marked as when the tool reports no bugs.
the average results are arithmetic means of the results for all subjects.
table real bugs detected by archer dapp issues dapp issues agrochain heiswap augur 8260fmetamask 10120c democracyearth multisender 34c eth hot wallet publicvotes ethereum voting dapp todolist dapp ?
giveth 1103f 1605f 1792c fthe reported bugs have been confirmed and fixed.
cthe reported bugs have been confirmed.
?the developers have asked for pull requests.
other issues have not received responses from developers.
performed repeatedly a lot of communication and computation overheads will result.
passive waiting.
the passive waiting strategy copes with the non determinism of transaction execution by updating the off chain state only when a transaction reaches the finalized state in its lifecycle.
that is to say as long as the non determinism still exists i.e.
transactions are not yet finalized the dapp does not update its off chain state.
for instance giveth adopts this strategy by counting the number of confirmations for each transaction after it is executed.
only when a transaction has enough confirmations will giveth update its off chain state in the centralized cache server.
this strategy could save a lot of communication and computation overheads compared to the periodic polling strategy since the dapp only needs to track the transactions that are not yet finalized.
however it could induce an inevitable delay in the dapp influencing user experiences because after the transaction is executed users must wait until there are enough confirmations.
aggressive updating.
the aggressive updating strategy is another choice for dapp developers.
this strategy is intended to keep the off chain state closely synchronous with the on chain state which means the dapp updates its off chain state when transactions are executed and reverts the off chain state when transactions are reversed.
for instance augur adopts this strategy in its implementation.
when a transaction is sent to the blockchain that is in pending state the off chain state is not updated.
the update onlytakes place when the transaction is executed.
if the transaction is reversed due to blockchain reorganization augur will also revert its off chain state accordingly.
this strategy offers better user experience than the passive waiting strategy.
users can see the updates of the off chain state immediately when their transactions are executed or reversed.
however it is more error prone to revert the off chain state which might involve many data fields when transactions are reversed on the blockchain.
.
limitations and future work our work is subject to two limitations.
first precise identification of the off chain states is important to the test effectiveness of archer .
in our experiments we assume that the off chain states are appropriately updated when the transactions are completed in a straightforward manner.
this may not always hold.
second archer assumes that each update of an off chain state if it indeed happens would be completed within a fixed time period which is to be manually specified.
if the period is set to be too large the time efficiency of archer is compromised.
if the period is set to be too small archer may miss the detection of some on chainoff chain synchronization bugs.
furthermore the period can vary across dapps.
a possible solution to these two limitations is to analyze the source code of dapps to determine what comprises the off chain states and when they will be updated so that the efficiency and effectiveness of each transaction s analysis could be improved.
however the dynamic and reflective nature of javascript imposes other challenges to perform a sound and complete analysis of dapps.
as such we leave these two limitations to be addressed in our future work.
furthermore as discussed in section .
it could be the case that the consequence of on chain off chain synchronization bugs is not reflected in dapps off chain states for instance sending a transaction dependent on the interim result of another transaction which gets reversed or dropped.
future work can be made to detect the on chain off chain synchronization bugs exhibited in such scenarios.
archer detecting on chain off chain synchronization bugs in decentralized applications esec fse august athens greece .
threats to validity the limited number of dapp subjects poses an external threat to the validity of our evaluation results.
we mitigate this threat by selecting popular real world dapps of different sizes and purposes from github to improve their representativeness.
more subjects are needed to address this threat in future research fully.
leveraging crawljax to exercise dapps induces another external threat in that crawljax is a randomized tool and may not trigger all possible transactions.
we mitigate this threat by repeating the experiments ten times in order to increase the diversity of explored functionalities.
threats to internal validity may arise from the way we interpret the experiment results.
the specification of off chain states for each dapp poses a threat which we mitigate by mechanically deriving off chain states with the assumption discussed in section .
.
during the reproduction of transactions we confirm that our assumption holds for all dapp subjects.
we also report our detected bugs to the dapp developers and ask for their feedback to confirm the effectiveness and usefulness of archer .
related work this section briefly reviews the existing work related to the problem that archer aims to address.
.
dapp development and testing in porru et al.
introduced the concept of blockchainoriented software engineering and pointed out the challenges and research directions on the development and testing.
since then dapps as a kind of blockchain oriented software started to attract attention from software engineering researchers.
wessling et al.
discussed the design choices of the architecture of a software that involves blockchain showing the benefits and drawbacks of dapps.
wu et al.
conducted empirical studies on ethereumbased dapps to show the popularity growth development practice cost and the open source status quo.
they pointed out the research direction in the synchronization between the on chain and off chain layers of a dapp but no further study has been conducted.
wu et al.
proposed a framework kaya for testing dapps.
however their framework only provides tools to facilitate the manual creation and execution of test cases for dapp.
unlike our work kaya does not target any bugs specific to dapps and does not propose oracles to help automatically reveal bugs in dapps.
.
smart contract testing lots of studies have been conducted over the past several years to analyze and test smart contracts.
various approaches have been proposed to detect vulnerabilities with symbolic execution fuzzing static analysis mutation testing or machine learning techniques.
multiple empirical studies have also been conducted to review and verify the effectiveness and efficiency of smart contract vulnerability analysis tools .
however these studies only focus on testing the onchain layer of a dapp that is smart contracts.
as shown in our evaluation in which we adopt contract vulnerability oracles from contructfuzzer testing smart contracts only and neglecting the testing of the interaction between on chain and off chain layers cannot ensure the correctness of a dapp.
our work instead takesthe interaction between the on chain and off chain layers into consideration and can detect bugs during the synchronization of the two layers.
.
test case generation for web applications since archer targets web based dapps test case generation in web applications is relevant to our work.
mesbah et al.
proposed crawljax which can derive a state flow graph for web applications and generate tests to traverse the graph.
since crawljax is well maintained and capable of automatically generating test cases with good coverage to explore web applications we integrate it into archer to trigger the interaction with smart contracts for testing dapps.
other test generation tools such as subweb anddig are usually built based on crawljax with the aim to further increase the coverage of generated tests.
since these tools require web applications to have page navigational models which are not available in our dapp subjects we did not integrate them into our framework.
nevertheless the dapp front end explorer component of archer is loosely coupled with other components.
it is convenient to migrate to other web testing tools to explore functionalities of dapps and detect on chain off chain synchronization bugs based on our proposed oracles.
conclusion in this paper we study the development challenges of dapps caused by the non deterministic transaction execution on the blockchain and the on chain off chain synchronization bugs thus induced.
we propose archer an automated testing framework to detect two common types of such bugs in dapps.
our experiments on real world dapps show that archer is effective in detecting onchain off chain synchronization bugs and significantly outperforms the baseline methods in terms of precision recall and accuracy.
feedbacks from real world dapp developers also confirm the effectiveness and usefulness of archer .