corbfuzz checking browser security policies with fuzzing chaofan shou ismet burak kadron qi su and tevfik bultan university of california santa barbara shou kadron qisu bultan cs.ucsb.edu abstract browsers use security policies to block malicious behaviors.
cross origin read blocking corb is a browser security policy for preventing side channel attacks such as spectre.we propose a web browser security policy fuzzer called corbfuzzfor checking corb and similar policies.
in implementing asecurity policy the browser only has access to http requests andresponses and takes policy actions based solely on those interac tions.
in checking the browser security policies corbfuzz uses apolicy oracle that tracks the web application behavior and infersthe desired policy action based on the web application state.
bycomparing the policy oracle with the browser behavior corbfuzzdetects weaknesses in browser security policies.
corbfuzz checksthe web browser policy by fuzzing a set of web applications wherethe state related queries are symbolically evaluated for increasedcoverage and automation.
corbfuzz collects type informationfrom database queries and branch conditions in order to preventthe generation of inconsistent data values during fuzzing.
weevaluated corbfuzz on corb implementations of chromiumand webkit and opaque response blocking orb policyimplementation of firefox using web applications collected fromgithub.
we found three classes of weaknesses in chromium simplementation of corb.
i. i ntroduction web browsers allow users to various things such as streaming videos or accessing bank accounts.
a malicious website should not be able to access sensitive informationabout a web application user for example a bank accountpage.
unfortunately due to vulnerabilities like cross site scriptinclusion cross site scripting spectre and melt down malicious websites can access sensitive informa tion that they should not have access to.
because of theaforementioned threats browsers have adopted an increasingnumber of security policies like cross origin read blocking corb policy that they use to protect sensitive data.
thegoal of the corb policy is to prevent cross origin access toconfidential data.
in order to determine if a behavior is malicious or not a browser security policy has to infer properties about the webapplication that is being used.
yet given that a browser doesnot have access to web applications internal state nor itscodebase it cannot precisely determine the properties of theweb applications.
instead security policy implementations usethe information browsers have access to like http responses this material is based on research supported by nsf under grants ccf1901098 and ccf .and requests to infer properties of web applications and decideto take a policy action according to those properties.
in this paper we focus on corb as a browser security policy because it is one of the most important policies forprotecting cross origin resources.
corb aims to identify andblock all cross origin loads of confidential response content.however browsers can not determine whether a specificresponse is confidential without inspecting the state of theweb application.
since the browser cannot do that the corbpolicy implementations examine the responses instead anduse information inside responses and heuristics that reflectthe expected behavior to determine whether the content isconfidential.
these heuristic approaches need to be tested comprehensively in order to look for scenarios where they fail to protectsensitive information.
a fully automated testing approachwould enable browser security policy developers to identifyweaknesses in existing policies and to quickly evaluate policymodifications.
we developed a fuzzing technique to check browser security policies.
given a browser and a security policy we use a setof open source web applications to look for weaknesses inthe security policy implementation of that browser.
we usethe open source web applications as fuzzing targets and ourfuzzer creates requests for each of them intending to achieveas much coverage as possible.
by exploring a variety of webapplications and covering as many behaviors as possible foreach web application our fuzzer tests a large set of scenariosfor the browser security policy implementation.
in order to identify weaknesses in the browser policy implementation we define a reference implementation of thesecurity policy by tracking the web application states andutilize it as an oracle.
the oracle is more accurate than thebrowser policy implementation since during fuzzing the oraclehas access to all internal information of the web applicationand properties of each response.
our fuzzer compares the deci sions made by the oracle to the security policy implementationof the browser and reports any differences which correspondto a weakness in the browser security policy implementation.
most web applications typically access session data cookies and data store .
these web applications are called data dependent.
fuzzing a data dependent web application requiresmanually setting up these data sources e.g.
populating adatabase .
however given that we need to use a 36th ieee acm international conference on automated software engineering ase 36th ieee acm international conference on automated software engineering ase .
ieee .
ase51524.
.
.
ieee set of web applications during fuzzing it is not practical to manually set up the data store and session values foreach web application.
thus we propose a runtime for data dependent web applications that enables us to automate theprocess.
instead of manually setting up data sources for allfuzzing targets our runtime automatically synthesizes datastore sessions and cookies.
this approach not only removesthe requirement for manually setting up an environment for aweb application but also allows our fuzzer to easily mutatethe data store leading to higher coverage.
the runtime we propose generates smt constraints for database queries and sessions or cookies usage.
the smtconstraints for a database query encode the sql statement and we use an smt solver to generate data values consistentwith the query.
the smt constraints generated for sessionsand cookies are used to check the feasibility of execution pathsof the web application.
using this approach we have implemented a fuzzer focusing on the corb policy which we call corbfuzz.
whilecorbfuzz is optimized for corb analysis it can be easilyextended to support other policies by defining correspond ing oracles.
additionally for our prototype we restrict ourscope to php applications.
our approach can be extended tosupport web applications developed in different programminglanguages including python or nodejs by providing simpleinstrumentation for the target language as discussed in sec tion iv.
we evaluate the implementation of corb policy in both chromium and webkit.
corbfuzz did not find any policyviolations in webkit and shows that corb implementation inwebkit is robust.
in chromium on the other hand corbfuzzidentifies three types of code patterns that can enable attack ers to bypass corb protection.
furthermore we modifiedcorbfuzz to check a sibling policy by firefox called opaqueresponse blocking orb .
in this paper we present the following research contributions browser policy fuzzer we propose a new fuzzer corbfuzz for checking browser security policies.
corbfuzzis guided by web application code coverage and uses apolicy oracle to identify weaknesses in browser securitypolicies.
it is fully automated and can be easily appliedafter each change in policy implementation.
data synthesis to tackle fuzzing environment setup for data dependent applications we propose a runtimethat synthesizes and mutates the data when required.our data synthesis approach uses smt encoding andconstraint solving to ensure consistency of data generatedfor database queries and sessions or cookies usage.
empirical evaluation we used corbfuzz to check the corb implementation of chromium and webkit.
wealso checked a sibling policy orb for firefox.
we fuzzedthese policies using responses of php web applicationsthat we obtained from github.
using corbfuzz wediscovered three code patterns that expose weaknesses inthe corb implementation of chromium.
one of thesecode patterns has been previously documented and thechromium team patched the policy weakness caused byanother code pattern we discovered after our report.
the paper is structured as follows.
in section ii we present the background on browser precautions.
in section iii wepresent our fuzzing framework.
in section iv we discusshow we synthesize the data and bypass authentication for webapplications.
in section v we evaluate corbfuzz and describethe detected corb weaknesses by our tool.
in section vi we present the related work.
in section vii we conclude thepaper.
ii.
b ackground in this section we provide the background information on site isolation and cross origin read blocking policy.
a. site isolation and information leakage browser information leakage has gained increasing exposure in the last few years.
according to the same origin policy sop one of the fundamental rules in browsers docu ments from different origins cannot interact with each other.however many exploits have been discovered to conductcross origin content leak .
additionally the discoveryof cache related side channel vulnerabilities like spectre and meltdown worsen the information leaks.
site isolation policy has been proposed to counter cross origin content leaks.
such a policy is also known as one site per process policy.
namely a browser shouldensure that documents from different origins are rendered andexecuted in their own respective sandbox.
such an effort re duces the chance of success of cache side channel attacks andmakes most cross origin information leakage vulnerabilities inbrowsers no longer exploitable.
b. cross origin read blocking while site isolation policy removes the possibility of documents in different origins interacting with each other directly there are still ways to inject documents from different originsvia interfaces provided by browsers.
a possible approach isto include the documents from different origins as resourcesrequired by the webpage.
some examples have been providedbelow for which the first line is to load an endpoint as animage and the second line is to load it as a script.
img src a.com secret script src a.com secret script in addition other browser javascript interfaces could be used to pass partial sensitive information from one origin to another.
a famous example is cve .
thevulnerability is that by loading two cross origin documentsinto the cache it is possible to calculate the difference ofsizes between two documents by calculating the increase in thesize of the cache.
the size leakage technique could be easilyexploited to deduce the preference and the visiting history ofusers.
all these interactions make site isolation policy no longer effective.
while blocking all cross origin requests could solve 216the issue existing websites legitimately utilizing cross origin resources would similarly be affected by such an approach.thus cross origin read blocking corb policy has beenproposed.
it aims to prevent http responses from beingloaded into contexts at different origins if the informationis deemed confidential.
the authors have claimed that thiscould effectively reduce potential dubious cross origin re source fetches.
previous examples of xssi attacks or the cve vulnerability become ineffective when a browserimplements the corb policy .
a simplified version of the corb policy implementation in chromium is shown in procedure .
this code is executed assoon as a response is received by the browser.
it performs afew initial checks including whether the scheme is http s .if these checks are not violated the response is allowed to beloaded into a context in a different origin i.e.
not blocked .the procedure returns null if the response is blocked.
the corb policy authors defined a set of response mime types likely related to secrets namely protected mime types.the response having content type header value as a protectedmime type is blocked.
for instance responses with contenttype headers related to images would not be blocked yetresponses with content type headers related to json areblocked because web developers commonly use json seri alized responses to conduct communication between frontendand backend.
chromium team took a different approach to implement corb.
instead of strictly following the policy documentedat w3c the team added extra measures to confirm themime types by inspecting the response content .
thismeasure is known as confirmation sniffing .
they claimedthat this could effectively reduce false positives i.e.
re duce the cases when a legitimate response is blocked thusincreasing the compatibility of chromium with more webapplications .
for instance as seen in lines and inprocedure if the response mime type is related to json which is in the protected mime type list but the contentin the response is an image not a json then chromiumfollows the property of the content and does not block.
onthe other hand webkit strictly follows the policy and blocksthe response since it does not have such a measure .
iii.
b rowser policy fuzzing in this section we present corbfuzz which is a fuzzing technique for checking browser security policies.
a. fuzzing algorithm we present the architecture of corbfuzz in figure and its algorithm in procedure .
corbfuzz is a distributed and multithreaded fuzzer that loops over all given web applications andcalls c orbfuzztestone which conducts coverage guided fuzzing for the given web application individually.
initially c orbfuzztestonecreates multiple instances of the application runtime instrumented with data synthesisdiscussed in section iv.
we define the runtime to be afunction p url seed metrics r m where seedprocedure partial corb implementation in chromium procedure corbcheck response ifresponse.scheme http https then return response mime response.contenttype ifmime protectedmimetypes then ifmime json isjson response then return response ifmime xml isxml response then return response else return null return response php runtime php runtime php runtimephp runtime data synthesiscoverage bitmapcorpusmutatorrequestor monitor coverage guided fuzzerhttp req resp coverage stream result sink application hosting env.
oraclepolicy oraclebrowser corb impl.
fig.
.
corbfuzz architecture is an identifier mapping to a state of the web application i.e.
database cookies and sessions metrics represents thecoverage metrics r represents the resource queried by theweb application and m maps each corb implementation toits decision on whether to block the response.
analogous toa pipeline the http requests are first passed to the runtimehosting web application and http responses generated arethen served as inputs for different corb implementations.
in c orbfuzztestone a bitmap is created so as to record the coverage procedure line .
c orbfuzztestone additionally declares a result sink line for storing theinformation required by the oracle.
the details of the oracleare elaborated in the following sections.
a corpus line is also defined as a list of pairs where each pair containsthe url of the request and the seed.
additionally a listis declared line for storing the urls extracted fromthe http response e.g.
href values and api calls .
duringfuzzing in c orbfuzztestone it randomly selects an input from either corpus or unvisited links extracted line .
theinput contains a request url and potentially a seed mappingto a state.
then c orbfuzztestonemutates and sends the corresponding http request and seed to the runtime lines10 .
if the input leads to increased coverage it is addedto the corpus lines .
after the fuzzing terminates i.e.
shouldterminate returns true the oracle aggregates the information in result sink andprovides a decision for each http response.
these decisions 217procedure corbfuzz algorithm procedure corbfuzz testbench forwebapplication testbench do corbfuzztestone webapplication procedure corbfuzztestone webapplication p datasynthesis webapplication covbitmap bitmap resultsink hashtable corpus list newurl list visited set for shouldterminate do u seed corpus newurl visited .pop u seed mutate u seed visited u metrics r m p u seed newurl extractlinks ifisnewcoverage covbitmap metrics then corpus u seed covbitmap metrics ifisuniqueresponse then resultsink r m runoracle resultsink are compared with the browser decisions to identify potential weaknesses.
b. policy oracle to define a policy oracle i.e.
runoracle function in procedure line we need to categorize the response as confidential or non confidential by evaluating resource accesses.we limit the scope of resources to be only provided by thedatabase for this work.
we use a method similar to pellegrinoet al.
which deduces confidentiality of a resource byobserving resource access frequency.
after fuzzing terminatesfor each web application we aggregate and count the numberof resources accessed by each database query executed whilehandling each request.
in our implementation we use theaverage number of accesses as our threshold.
if any queryuses resources that have a frequency below the threshold theoracle infers that the query is accessing a confidential resource of which the response should be blocked and checks whetherthe corb implementation blocked it.
the granularity of the resource impacts the result of the oracle.
for example if each resource is considered as a table oracle is more likely to decide to block the response than ifeach individual resource is considered as a row in the table.hence using a coarse grain resource definition is more likelyto produce false positives.
we designed two types of oracleswith different resource granularity.
to reduce false positives one oracle considers each unique row i.e.
query constraints to be a resource and to reduce false negatives the other oracleconsiders each table to be a resource.c.
coverage metrics in c orbfuzztestone rather than focusing on test coverage for the corb function of the browser implementation fuzzing is guided by test coverage for the given web appli cation.
while the coverage information of corb functionmay enhance the fuzzing in regards to efficiency it wouldnot be useful since corb function is a small piece of codein both webkit and chromium.
thus it is easy to achievehigh test coverage for the corb function while focusing onachieving high test coverage for the given web application.additionally we are evaluating the policy for different codepatterns.
focusing on what corb is able to handle wouldnot lead to identifications of potential weaknesses in theimplementation.
iv .
d ata synthesis in this section we discuss our data synthesis techniques that enable us to handle data dependent web applicationsautomatically during fuzzing i.e.
during the execution of c orbfuzztestone without the need for manual set up of fuzzing targets.
instead of querying the database the datasynthesis approach translates the query to constraints andgenerates the respective data.
additionally the data synthesisapproach generates results for comparisons involving sessionsor cookies so as to achieve higher test coverage and bypassauthentication.
the data synthesis workflow depends on a seed that is generated and tracked by c orbfuzztestone first mentioned in procedure line .
a seed is a bit integer sampled froma uniform distribution over .
there is a bijection between the seed and the state of the database and a weakbijection between the seed and the cookies or sessions.
a. query constraint extraction we first discuss the handling of database queries.
the results generated for a specific database query are constrained by three measures row count table architecture and constraint thatdescribes the resulting rows and columns from the query.
mostopen source web applications either do not include a tableschema or require laborious work to set up the tables.
thus weassume that the table schema is not given and the generationof the database query result is run without the knowledge ofthe table architecture.
for these we respectively define threefunctions m axrow fields constraint .
the input of all these functions is a relational algebra expression translatedfrom the query.
m axrowprovides an estimation of the maximum rows of the query result.
it is implemented by considering the setoperators and limit.
to reconstruct the table schema the data synthesis approach learns from the query by observing the field names used insideit.
we define the f ields function which produces a set of pairs representing fields returned by the query.
the first partof the pair indicates the table name and the second part is thename of the field.
the function is implemented by trackingthe rename projection and select operators.
in the case that ?php conn mysqli connect ... res conn query select from awhere a.c x res fetch assoc a x 12if a echo fig.
.
example of php application database call a wildcard projection i.e.
asterisk is used the function only returns the fields used throughout the relational algebraexpression which could be a subset of fields returned if thequery is executed on the correct table schema.
the missingfields are addressed by f ield procedure in procedure .
to ensure that the response generated using data synthesis can be reproduced in the web application with real databasesettings we additionally extract the constraints from the queryand generate a consistent result that conforms to these con straints.
for this we define c onstraints function which outputs all the row based and column based constraints in therelational algebra expression for the smt solver.
we utilizea subset of translation rules proposed by veanes et al.
.note that this function also assigns types to fields if the fieldis compared with a concrete value in the select operator orreturned by set functions like count.
we provide an example for the query in line of figure as input.
the relational algebra expression for the query isselect a .
c a .
since there is no limit operation inside the query the m axrowoutputs that the maximum line is infinite.
the f ields function produces a set with one pair angbracketlefta c angbracketright .
the c onstraints function translates the condition in the select operator to the smt formula a c and assigns angbracketlefta c angbracketrightto be of integer type.
the crucial procedures for the generation workflow are presented in procedure .
before fuzzing starts in c orbfuzztestone line procedure the i nitialization procedure is executed.
this procedure initiates three global hashtables forcaching.
these are preserved throughout the runtime lifecycleand synchronized throughout all runtimes since we use multi threaded distributed fuzzing this is necessary .
when a query is sent to the database and the web application is waiting for the response a ddprocedure replaces the original code for sending the query and receiving the responsefrom the database.
a ddprocedure takes two arguments the query and the seed.
if the cache contains the previous solutionfor the query and the seed the cached result is returned.otherwise the query is parsed into relational algebra to extractconstraints fields and maximum length as mentioned before and an empty hashtable is returned.
the hashtable regardlessof whether there is a cache hit is tracked and used by the webapplication as the output of the database query.
procedure database query result generation algorithm procedure initialization concreteresults hashtable types hashtable cache hashtable procedure add query seed ifcache query null then ra parse query cache query .l maxrow ra cache query .f fields ra cache query .c constraints ra results concreteresults query seed return tracked results procedure field query seed name cache cache query r concreteresults query seed ifname cache.f then types query name .assignweight r.f cache.f name forfield r.fdo iffield.type null then types query field field.type sample len seed cache.l r solve cache.c cache.solved r.f len len ifr unsat then return abort cache.solved r.f len r return tracked r name procedure notify query name itype type query name itype itype weight if the tracked hashtable is searched in the later executions of the web application and the searched key corresponds tonull value the f ield procedure is called.
in addition to the query and the seed this procedure takes an additional argu ment the name of the field i.e.
the key of the hashtable thatthe application is searching for .
f ield procedure assumes that the web application code is correct and the queried fieldmust exist.
under the circumstance that this specific field nameis not inferred from the sql query statement e.g.
a wildcardselect f ield appends the field name to the global cache so that in the future for this query this specific field would beconsidered.
before solving the constraints generated from theevaluation of the query f ield first probabilistically selects a type from all possible data types for each field which isdiscussed in section b. the number of rows is generated usingthe seed value.
to avoid generating an identical result f ield appends constraints stating that the result to be solved shouldnot be equal to previously generated results under the samecondition i.e.
same type and same amount of row .
if thesolver concludes these constraints could derive no result i.e.
unsat the web application immediately returns an internal 219error to abort the data synthesis workflow.
however this case rarely happens in our experiments because constraints for sqlqueries are very permissive.
the returned value of f ield procedure is also tracked for type inference purposes whichis described in the following section.
we demonstrate an example for the workflow over the php application code listed in figure .
before the execution ofany code as soon as the runtime starts the i nitializa tion procedure is called.
then on line the code calls mysqli connect to establish a connection to mysql database.
inside the runtime this function is replaced witha dummy method that always acts as if there is a successfulconnection.
then the code is executed to send a query tomysql database line and wait for the response line8 .
instead of sending the query the runtime calls the a dd procedure.
suppose we are using a new seed the procedurewould evaluate the query and return a traced empty hashtable.on line the hashtable is searched with a key a. since the hashtable is empty the key points to null value.
instead ofreturning null the f ield procedure is called to solve for all the fields including the field searched by the application.
b. type inference the knowledge of field names is not enough to generate the data.
correct type of each field is also required for generating a consistent result.
note that for types here we are not referringto the actual type of a concrete value.
instead we are referringto the inherent types.
the inherent type is the same after typejuggling.
suppose an integer is cast as string in the application we do not record this as string but instead as integer.
indeed all fields in the result from the call mysqli query are cast as string regardless of what the type is attributed to each ofthem in the table schema.
yet they are directly used as theirinherent type throughout the execution in web applications which is made possible by type juggling.
hence for datasynthesis purposes we need to infer the inherent types butnot the actual types.
we consider type information crucial because an inaccurate type makes web applications prone to producing errors andunrealistic responses.
for instance deserializing an integer orinteger like object would inevitably lead to errors.
anotherexample is that using a string as an index for an integer indexed array does not lead to error but breaks the originallogic of the web application.
this situation is unwanted inthis context because it produces a spurious response that isnot reproducible in an actual run of the web application usingthe real table schema.
in the query we could gain type information for fields when the operations processing or generating the field are known andthe argument or return types are well defined.
this is becausetype juggling in sql would lead to an error or warning.for instance a comparison between a field and an integerwould help us conclude that the field type must be integer.however it is impossible to infer all types from evaluatingqueries.
thus we additionally infer the type of fields by theinformation during the execution.
specifically data synthesisruntime collects type information via two methods.
first ifthe field encounters the binary comparison operand corbfuzzrecords the type of the concrete value it is comparing to.second corbfuzz tracks the internal functions that the fieldis served as an argument.
internal functions typically have aclear definition of the types of each argument.
for simplicity corbfuzz ignores corner cases like comparison between twofields and passing to an internal function supporting all types.future work may leverage hindley milner algorithm toconstruct a more fine grained typing system.
still the runtime analysis is not enough for inferring types of all fields.
some of them may not be passed to an internalfunction or used in comparisons.
additionally comparisonbetween variables of different types is allowed and it isimpossible to deduce the inherent type of a concrete value.these factors mean there is a possibility that a different typeis used against the compared variable.
to accommodate thesecases we define a domain of types for each field and assign a weight to any type t .
at initialization each tis set with an initial weight and increased whenever it matches inference e.g.
passed to an internal function which we refer to as atype hint after the generation of the result.
if query analysishas already assigned a type then the type would have infiniteweight in .
before constraint solving is initiated corbfuzz conducts a probabilistic sampling from for each field based on weights assigned to types the probability of a type tobe chosen is proportional to the weight of the type .
due toprobabilistic selection a variety of types are explored duringfuzzing.
here we assume that if a type for a variable is notintended then this incorrect type used would lead to eithererrors or no effect on analysis.
in general corbfuzz tries toincrease the likelihood that a correct type will be used.
in procedure f ield procedure conducts a probabilistic sampling over the for each field line .
in our implementation we utilize a res algorithm .
n otify procedure is called when the tracked value returned by f ield procedure is used in internal functions or for comparison.
thetype hint is then used to increase the weight for that typein .
in our implementation we only let include integers strings and booleans.
type hints for types that are not in are ignored.
in the example provided in figure line after the f ield procedure ends ais assigned the generated value that is tracked.
on line the tracked value is compared to aninteger.
the n otify procedure is called adding weight for the integer type for the field ain global hashtable types.
c. authentication bypass workflow cookies and sessions are commonly leveraged by web applications to make http requests stateful allowingfor the implementation of authentication.
both of them couldbe represented as a hashtable.
we observed that there couldbe a significant increase in coverage for a web applicationif cookies or sessions are properly set e.g.
an authenticationtoken presents for a specific field .
it is because complex logicinside web applications tends to be reached after the request ?php 2session start 4if isset session echo session fig.
.
example of php application session usage presents to be authenticated or authorized.
usually cookies or sessions keys and values are compared to a constant or aresult from the database.
therefore using a fuzzer to explorecookies and sessions is largely ineffective since there is a hugesearch space for the keys and values.
to better explore behaviors of web applications we generate decisions for comparison operations that involve sessions orcookies.
still we conduct concolic execution and recordthe constraints for the decisions made to check whether alldecisions made are satisfiable.
corbfuzz treats each item insession or cookie as a pair of symbolic variables angbracketleft angbracketright where is the gated boolean symbolic variable that shows whether the item is defined and represents the symbolic variable for the item.
this method is inspired by hybrid fuzzing butdiffers from it.
the runtime only solves the constraint onetime when necessary.
that is if an item of cookies or sessionshas not been passed to an operation that does not have ansmt formula translation available the value would never begenerated.
the reason we do not generate the data as soon as it is used is largely due to the use cases of sessions and cookies.
theyare used in multiple or nested branches but most of the time their concrete value would not be evaluated.
additionally thereare very few internal functions that commonly use sessionsor cookies as arguments.
we have implemented only basicarithmetic and isset internal call with the translation of the smt formula.
still most requests in our experimentdo not require generating the concrete value of sessions andcookies.
we have shown the crucial components for the workflow in procedure for session which is identical for cookie.
similarto the previous workflow for database there is also an initial ization procedure that creates a global hashtable for caching.specifically gcis for storing the mapping between seed and the sessions.
additionally there is a s tart procedure which is called before each http request is handled and the variabledeclared only survives during the lifecycle of that request.
theprocedure creates a copy of the seed and declares a hashtablefor saving the constraints for each session item used duringthe request.
when an item of sessions is compared with a concrete value the d oprocedure is used before evocation of the original comparison handler.
corbfuzz first checks whether there isalready a cached item for the given seed line .
if there isa cache hit then the item is assigned a concrete value andthe internal implementation of the comparison operation is ex ecuted.
otherwise corbfuzz checks whether the comparisonprocedure session generation algorithm procedure initialization gc hashtable procedure start rcache hashtable newseed copy seed procedure do name opline ifgc seed name then session name gc seed name return next ifopline.operand implementedop then decision newseed shiftright newseed cons toconstraint opline decision if issat rcache name cons then return do name opline rcache name cons return decision else solved subset gc name cons rcache name solved if issat cons then return abort gc seed name solve cons return do name opline operation is implemented line so that it could convert thedecision of the operation to a constraint.
if so a decision isgenerated from the seed and the constraint for performingthis decision is appended to the constraints over that item lines .
an smt solver is then used to check whetherthe constraint is satisfiable line .
if it is not satisfiable then the procedure recursively consumes the seed until there isa decision that could be satisfied.
our implementation assumesthere are at most decisions since we are using a bitseed.
in our experiments the maximum consumption is only11 bits in a specific request.
the decision is then returned andthe internal implementation of the comparison is ignored.
asfor the corner case that a session item is compared to anothersession item we treat this comparison as an unimplementedoperation for one side and then apply the workflow to the otherside.
when the operation is not implemented then a concretevalue is generated by solving the constraint for that item.
toensure the uniqueness of the concrete value generated thesolver tries to avoid generating already solved values storedin the global cache for that field name.
to reduce unsatcases d oonly selects a random subset of the stored values in the cache and removes them from consideration as theresult of solving line .
note that by so we do notcreate a strict bijection here between the seed and the sessions.same sessions may map to multiple seeds.
this is because theconstraints here are not permissive.
for php code listed in figure when it executes until line corbfuzz first declares a pair of symbolic variables angbracketleft 0 angbracketrightand makes a decision for the unary comparison 221isset based on the seed.
suppose the seed indicates the decision is to return true then the constraint 0 true is added to the set of constraints for the session .
note that this session item is not used later so its concrete value is never generated.
then on line another sessionitem is used.
we have not implemented echo function and the value of session is generated with respect to its constraints i.e.
no constraint in thiscontext .
in certain cases the data stored in the cookies or sessions may be subject to decryption or deserialization in web appli cations.
before a decryption or decoding function is executedwith input from cookies or sessions the workflow mustsynthesize the concrete value.
this situation is undesirablebecause authentication cannot be bypassed.
a more generalversion of this issue which is that symbolic execution failsto model a comprehensive list of syscalls also plagues hybridfuzzing and no solution has been proposed so far.
wediscuss a potential ad hoc solution and future work to addressthis problem in section v b. d. adapting to other programming languages the aforementioned methods target php applications.
however they can be extended to other programming languages that are widely used for web application development.
specif ically the data synthesis workflows embedded with typeinference can be applied to other programming languagessupporting type juggling like perl or javascript nodejs orusing a dynamic type system like ruby and python.
forstatically typed programming languages like golang or java the type inference component would not be needed but thedata synthesis workflows can similarly be adapted.
v. i mplementation e v aluation we have implemented the coverage guided fuzzer and oracle for corbfuzz in python with lines of code loc for fuzzing web applications written in php.
unlike existingweb application fuzzers that only consider responses relatedto php corbfuzz considers all responses after a web pageis loaded including images css and rpc communications.the data synthesis workflow is implemented as an externalmodule with loc in c and loc in nodejs forphp.
php .
has been instrumented to support the workflowand provide branching information for coverage evaluation.
toallow for fair evaluation on data synthesis effectiveness weimplement two baseline workflows by removing componentsinside corbfuzz.
in the following subsections we address the following research questions rq1.
is data synthesis workflow generating consistent data?
rq2.
can data synthesis workflow increase test coverage?
rq3.
can corbfuzz detect bugs in implementation in existing browsers?loc range number of applications average loc less than 1k .
between 1k and 10k .
between 10k and 100k .
more than 100k .
table i total locs tatistics for fuzzing targets a. experimental setup environment we evaluate corbfuzz on two intel xeon phi cores nodes.
both nodes use ubuntu .
with one node running nginx for serving web application onthe instrumented php environment and other node running thecoverage guided fuzzer.
targets we evaluate corbfuzz with two popular web browsers chromium and webkit safari .
chromium hasalready added corb into its current stable release.
we im plement a test harness based on the chromium shared librarycontaining the corb implementation.
for webkit the devel opers have created a pull request for corb implementationbut it has not yet been merged into the main branch.
since itsimplementation is relatively simple and straightforward wedirectly translate it into python to implement a test harnessfor corb implementation of webkit.
web applications web applications are fuzzed to provide responses as input for browser policy test harnesses.
wecrawled repositories containing php code from githubbetween march 2nd and april 10th .
the reposi tories are filtered out if they do not contain index.php or index.html.
for simplicity we do not consider applicationsthat require downloading dependencies with composer a dependency management tool.
the number of remainingapplications is with varying locs.
we fuzz the policieswith these applications but for the sake of evaluation ofdata synthesis effectiveness we only use of them forwhich corbfuzz reports existence of branches and utilizationof databases.
the statistics of these applications are presentedin table i. b. data synthesis effectiveness to evaluate the data synthesis approach and address rq1 we ran corbfuzz with and without type inference for three minutes 1with each web application.
we compared the percentage of correct type generations by tracking whether thegenerated value matches the type of a concrete value whencompared to it the defined argument when used to callinternal function.
figures and demonstrate the percentageof correct generations for comparison statements and internalfunction calls respectively.
figure shows that for appli cations corbfuzz generates the correct type for comparisonsmore often than corbfuzz without type inference with more data generations with correct type on average.
figure 5shows that for applications corbfuzz generates the correcttype for internal function calls more often than corbfuzz 1due to the randomness feature of the fuzzer we ran each experiment five times and take maximum value e.g.
edge coverage .
222fig.
.
the percentage of correct type generation for comparison statements for corbfuzz and corbfuzz without type inference for minutes of fuzzing.x axis denotes the web application id.
fig.
.
the percentage of correct type generation for internal function callsfor corbfuzz and corbfuzz without type inference for minutes of fuzzing.x axis denotes the web application id.
without type inference with more data generations with correct type on average.
on some applications corbfuzz has little improvement on the accuracy of type generation because in the results we show we consider all type violations.
however many of these typeviolations are due to developers using type juggling and notdue to data synthesis.
therefore these violations cannot beremoved by improving type inference in data synthesis.
we also evaluated the impact of data synthesis on fuzzing effectiveness and address rq2.
figure demonstrates the edge coverage difference in terms of percentages of edgecounts between corbfuzz without any type inference andauthentication bypass and corbfuzz.
for this evaluation weonly chose applications containing more than one branch.figure shows that for almost all applications the inclusion oftype inference and authentication bypass improves coverage.the average number of edges covered is .
edges forcorbfuzz without type inference and authentication bypassfig.
.
the percentage of edges covered for corbfuzz without type inference and authentication bypass in minutes of fuzzing against edges covered bycorbfuzz.
x axis denotes the web application id.
and .
for corbfuzz.
these results demonstrate that with the inclusion of type inference and authentication bypass wecan cover on average more edges which shows theeffectiveness of our data synthesis approach.
the number of edges covered is low for some applications because these applications e.g.
wordpress save and usestructural encrypted or serialized data from the databaseor cookie.
the data synthesis workflow is unaware of thestructural property of any field.
therefore it generates a largeamount of data that can not be deserialized or decrypted bythe web application so corbfuzz fails to explore these webapplications.
however we recognize that this can be preventedby enlarging the domain of type defined.
by considering the common structural properties as types e.g.
json type andinstrumenting deserialization libraries to provide type hints future work could implement an approach that is able to furtherimprove web application coverage.
c. detected corb weaknesses in evaluation of rq3 we have discovered three common classes of code patterns which are discussed in following sections that cause the corb implementation in chromium tonot function as expected.
one of the cases has been filed in thechromium bug tracker before our discovery by a chromiumdeveloper and is still in discussion .
we have reported another case3 which has later been resolved by a patch in the corb component of chromium4.
all the weaknesses discovered are due to the novel fuzzing approach we present in this paper.
the weaknesses are notpresent in every web application but only in a few of them.fuzzing a single web application would likely not lead to thediscovery of any of the weaknesses while fuzzing multipleweb applications without the data synthesis would require 223left brace otherwisestart quotation otherwiseleft brace control characters quotationleft quote control characters escapewhitespace not json is json otherwise right quotewhitespace whitespaceotherwise colon fig.
.
finite state machine for validating json setting up the database and seeding the tables for numerous web applications which is infeasible.
data synthesis allows usto effortlessly fuzz multiple web applications by symbolicallyevaluating database queries.
additionally all the web appli cation states that lead to the aforementioned weaknesses areunder some extent of authentication or authorization.
withouta manual definition of the login method for a web application the fuzzer would not discover these weaknesses.
yet manuallydefining authentication or authorization method for a consid erable number of applications is tedious and unrealistic.
incontrast to the manual approach the data synthesis approachwe present automatically generates appropriate sessions andcookies items which allows exploration using authorizedrequests.
serialized array as json response.
in chromium if the response mime type is related to json corb would checkthe response content to learn whether it is indeed json.
afinite state machine fsm conducts such a check.
as illus trated in figure the fsm does not comprehensively parsethe response content to perform the check.
instead it onlychecks whether the content has a left brace at the beginningand has matching quotes for the first key to determine if thecontent is json.
as permissive as it is such a check would not identify a serialized array in json format which is considered a jsonobject inside the javascript runtime of chromium.
indeed the latest json specification rfc refers thisto be a different type from json object known as jsonarray.
for instance for a simple response as a json array json check in corb implementation wouldfirst look for the left brace.
yet the first character is leftbracket which makes the fsm classify the content as notjson.
however fetch xmldocument and json.parse apis in javascript runtime parse the content into a javascriptobject without warning.
sending json arrays as responses is commonly seen in web application apis.
the responses of these apis would likelycarry sensitive information.
thus we consider catching jsonarray for json mime type in corb implementation to be areasonable patch.
malformed json response.
it is not uncommon for web application developer to adopt the following code pattern where var represents any variable the attacker can control i.e.
a tainted variable which could be achieved throughmethods including url manipulation and security unrelatedcsrf .
?php 2header content type application json 3echo var secret this code pattern does not leverage the existing serialization library.
instead it produces serialized objects by direct stringconcatenation and manipulation.
if the attacker is able tocontrol at least one character in the first key of a json object they would be able to bypass the corb check by makingthat key contain a control character.
according to jsonspecification control characters u through u 001f inside key and value of json object should be escaped i.e.
append a reverse solidus before the control character .similarly the json verifier inside corb implementation inchromium follows this pattern and rejects all json objectswith unescaped control characters on the first key.
consider the php code shown above.
if we set var to be the control character u0017 the resulting response becomes u0017 .
thejson checker fsm enters the state left quote afterencountering the first and second characters.
it then comparescharacter u0017 to control character range and identifies it as an unescaped control character misclassifying the responseas not json.
we consider this weakness should be addressed as the existence of such a code pattern is not negligible.
we havereported this to the chromium team and it has been fixedby removing the check for control character inside the jsonchecker.
the discovery of this weakness is only possible if the fuzzer can mutate the database state efficiently.
in all the casesthat lead to this malformed json response the variable asthe key of the json array is retrieved from the database.corbfuzz symbolically evaluates the database queries andsynthesizes the concrete value for that variable which allowsthe efficient exploration of the domain of this variable i.e.
exploring interesting values for utf character .
in contrast a conventional fuzzing approach has to mutate the databasestate by sending requests to the web application or by resettingthe database leading to significantly larger search spaces andhigh timing overhead for mutating the content of the variablederived from the database.
confirmation sniffing.
in most web applications warnings and errors in plaintext or html are directly prepended to theresponse.
for php a warning in html is generated wheneveran undefined behavior happens.
if a malicious actor is able totrigger an undefined behavior in responses that are checkedwith confirmation sniffing then corb in chromium could 224be bypassed since the responses start with data that is not of their mime type.
this weakness including all previous weaknesses could be considered as the side effect of increase in permissivenesscaused by confirmation sniffing.
we consider that confirmationsniffing is harming the effectiveness of the corb implemen tation in chromium.
future work on the other hand couldwork on testing the contribution of confirmation sniffing oncompatibility and conclude whether confirmation sniffing isindeed redundant.
d. fuzzer flexibility we have constructed an oracle for orb and test the proposed implementation.
our fuzzer is unable to discover any weakness of orb.
it is because orb applies a whitelistapproach to block requests yet corb uses a blacklist whichmeans orb is much less permissive than corb.
future workcould apply similar approach to evaluate its compatibility.
vi.
r elated work coverage guided fuzzing.
coverage guided fuzzing has been used to find bugs in different types of programs such asvirtual machines web browsers network func tions and operating systems .
the state of the art implementations are afl and libfuzzer .in this paper we leveraged coverage guided fuzzing to exploreresponses from web applications for browser security policychecking.
yet our approach is not using the coverage of thebrowser but is instead guided by the coverage of the webapplications.
our approach also conducts a series of coverage guided fuzzing with different targets instead of fuzzing anindividual program.
browser fuzzing.
domato dharma and freedom are all specialized fuzzers used to discover memory related vulnerabilities and assertion violations in dom im plementation of browsers.
they generate structural data thatcontain valid html css and dom related javascript forbrowsers to render.
fuzzilli and jsfunfuzz are fuzzersfor discovering vulnerabilities in javascript engines whichutilize a similar approach to generating structural data.
ourwork is different from all these approaches since the oracleof corbfuzz is defined based on the property of the webapplications and corbfuzz does not generate the test casesbut instead utilizes web applications responses.
roy et al.
fuzzes web applications and supplies responses to browsers todetect visual inconsistencies between browsers.
it is similar toour work in the sense that both works treat web applicationsand browsers together as a black box.
unlike their work whichfocuses on testing web applications our work focuses ontesting security policies in browsers.
we also do not cross reference between browsers but use an oracle instead.
web application testing.
alshahswan et al.
and biagiola et al.
propose search based approaches to testing webapplications.
both works use metaheuristic approaches suchas genetic algorithms to explore and generate different inputsto extensively test web applications.
different from our work requires the input types and login information.
requirespage objects to be provided to test the web application.
ourwork instead avoids manual analysis through data synthesis.elbaum et al.
proposes that web application testing shouldmutate the sessions and provides a few mutation techniquesthat could help achieve better coverage.
data synthesis in ourwork is different than the work of elbaum et al.
since we donot mutate the sessions but instead symbolically evaluate orgenerate them.
apollo and wassermann et al.
lever age concolic testing to increase coverage of web applicationsand to discover vulnerabilities.
session generation workflowin our data synthesis approach is utilizing concolic execution but it is fundamentally different than the concept of concolictesting.
vii.
c onclusion we have created a browser policy fuzzer corbfuzz which uses web application responses to fuzz the browser securitypolicies.
to avoid setting up the web applications manually weproposed a web application runtime that synthesizes data.
theresources queried by the web application are either generatedor symbolically represented.
we have shown that the datasynthesis approach not only generates consistent data but alsoincreases test coverage for web applications.
we have evalu ated corbfuzz on corb implementations of chromium andwebkit as well as orb proposal for firefox.
by fuzzing with58 applications we discovered three classes of weaknesses incorb implementation of chromium.
r eferences v .
hailperin cross site script inclusion.
.
available j. grossman s. fogie r. hansen a. rager and p. d. petkov xss attacks cross site scripting exploits and defense.
syngress .
p. kocher j. horn a. fogh d. genkin d. gruss w. haas m. hamburg m. lipp s. mangard t. prescher et al.
spectre attacks exploiting speculative execution in ieee symposium on security and privacy sp .
ieee pp.
.
m. lipp m. schwarz d. gruss t. prescher w. haas a. fogh j. horn s. mangard p. kocher d. genkin y .
yarom and m. hamburg meltdown reading kernel memory from user space in 27th usenix security symposium usenix security baltimore md usa august .
pp.
.
.
available cross origin read blocking corb .
.
available origin read blocking explainer.md y .
f. li p. k. das and d. l. dowe two decades of web application testing a survey of recent advances information systems vol.
pp.
.
.
available n. alshahwan and m. harman automated web application testing using search based software engineering in 26th ieee acm international conference on automated software engineering ase2011 .
ieee pp.
.
m. biagiola f. ricca and p. tonella search based path and input data generation for web application testing in international symposium on search based software engineering.
springer pp.
.
j. schwenk m. niemietz and c. mainka same origin policy evaluation in modern browsers in 26th usenix security symposium usenix security .
vancouver bc usenix association aug. pp.
.
.
available b. gulmezoglu a. zankl t. eisenbarth and b. sunar perfweb how to violate web privacy with hardware performance events computer security esorics p. .
s. jana and v .
shmatikov memento learning secrets from process footprints ieee symposium on security and privacy .
h. kim s. lee and j. kim inferring browser activity and status through remote monitoring of storage usage proceedings of the 32nd annual conference on computer security applications .
s. lee y .
kim j. kim and j. kim stealing webpages rendered on your browser by exploiting gpu vulnerabilities ieee symposium on security and privacy .
r. spreitzer s. griesmayr t. korak and s. mangard exploiting data usage statistics for website fingerprinting attacks on android proceedings of the 9th acm conference on security privacy inwireless and mobile networks .
s. karami p. ilia and j. polakis awakening the web s sleeper agents misusing service workers for privacy leakage proceedings network and distributed system security symposium .
p. kocher d. genkin d. gruss w. haas m. hamburg m. lipp s. mangard t. prescher m. schwarz and y .
yarom spectre attacks exploiting speculative execution corr vol.
abs .
.
.
available c. reis a. moshchuk and n. oskov site isolation process separation for web sites within the browser in proceedings of the 28th usenix conference on security symposium ser.
sec .
usa usenixassociation p. .
site isolation the chromium projects.
.
available cve cve .
.
available cgi bin cvename .cgi?name cve issue security expose stored in cache cross site response s size.
.
available fetch standard.
.
available corb mime sniffing standard.
.
available https mimesniff.spec.whatwg.org cross origin read blocking corb .
.
available bug .cgi?id g. pellegrino m. johns s. koch m. backes and c. rossow deemon detecting csrf with dynamic analysis and property graphs .
m. veanes j. d. halleux n. tillmann and p. de halleux qex symbolic sql query explorer tech.
rep. msr tr october updated january .
.available r. milner a theory of type polymorphism in programming journal of computer and system sciences vol.
no.
pp.
dec. .
.
available j. s. vitter random sampling with a reservoir acm transactions on mathematical software vol.
no.
pp.
mar.
.
.available m. johns s. lekies b. braun and b. flesch betterauth web authentication revisited in proceedings of the 28th annual computer security applications conference ser.
acsac .
new york ny usa association for computing machinery p. .
.
available isset php manual.
.
available en function.isset.php n. stephens j. grosen c. salls a. dutcher r. wang j. corbetta y .
shoshitaishvili c. kruegel and g. vigna driller augmentingfuzzing through selective symbolic execution.
in ndss vol.
pp.
.
nginx high performance load balancer web server reverse proxy.
.
available composer.
.
available the javascript object notation json data interchange format.
.
available a. shankar d1r3wolf chaining no impact n a bugs to get high impact.
.
available chaning no impactna bugs to get high.html t. brennan s. saha and t. bultan jvm fuzzing for jit induced sidechannel detection in proceedings of the acm ieee 42nd internationalconference on software engineering ser.
icse .
new york ny usa association for computing machinery p. .
.
available .
.
w. xu s. park and t. kim freedom engineering a state ofthe art dom fuzzer in proceedings of the acm sigsac conference on computer and communications security.
virtualevent usa acm oct. pp.
.
.
available fuzzilli a javascript engine fuzzer apr.
originaldate 20t15 47z.
.
available a. shukla k. n. hudemann a. hecker and s. schmid runtime verification of p4 switches with reinforcement learning in proceedings of the workshop on network meets ai ml ser.
netai .new york ny usa association for computing machinery p. .
.
available c. shou porkfuzz testing stateful software defined network applications with property graphs in proceedings of the 29th acm joint meeting on european software engineering conferenceand symposium on the f oundations of software engineering ser.
esec fse .
new york ny usa association forcomputing machinery p. .
.
available s. kim m. xu s. kashyap j. yoon w. xu and t. kim finding semantic bugs in file systems with an extensible fuzzing framework inproceedings of the 27th acm symposium on operating systems principles.
huntsville ontario canada acm oct. pp.
.
.
available k. kim d. r. jeong c. h. kim y .
jang i. shin and b. lee hfl hybrid fuzzing on the linux kernel in proceedings network and distributed system security symposium .
san diego ca internet society .
.
available lcamtuf american fuzzy lop.
.
available http lcamtuf.coredump.cx afl k. serebryany libfuzzer a library for coverage guided fuzz testing llvm project .
domato dom fuzzer apr.
original date 21t15 59z.
.
available dharma generation based context free grammar fuzzer.
apr.
original date 25t17 23z.
.
available a collection of fuzzers in a harness for testing the spidermonkey javascript engine.
apr.
original date 08t01 26z.
.
available com mozillasecurity funfuzz s. roy choudhary m. r. prasad and a. orso x pert a web application testing tool for cross browser inconsistency detection inproceedings of the international symposium on software testingand analysis pp.
.
s. elbaum s. karre and g. rothermel improving web application testing with user session data in 25th international conference on software engineering .
proceedings.
pp.
.
s. artzi a. kiezun j. dolby f. tip d. dig a. paradkar and m. d. ernst finding bugs in dynamic web applications inproceedings of the international symposium on software testingand analysis ser.
issta .
new york ny usa associationfor computing machinery p. .
.
available g. wassermann d. yu a. chander d. dhurjati h. inamura and z. su dynamic test input generation for web applications inproceedings of the international symposium on software testingand analysis ser.
issta .
new york ny usa associationfor computing machinery p. .
.
available