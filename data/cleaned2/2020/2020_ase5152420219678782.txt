binary diffing as a network alignment problem via belief propagation elie mengin samm ea universit e paris panth eon sorbonne paris france quarkslab sa rue saint ambroise paris france elie.mengin gmail.comfabrice rossi ceremade cnrs umr universit e paris dauphine psl university paris france fabrice.rossi dauphine.psl.eu abstract in this paper we address the problem of finding a correspondence or matching between the functions of two programs in binary form which is one of the most commontask in binary diffing.
we introduce a new formulation of thisproblem as a particular instance of a graph edit problem overthe call graphs of the programs.
in this formulation the qualityof a mapping is evaluated simultaneously with respect to bothfunction content and call graph similarities.
we show that thisformulation is equivalent to a network alignment problem.
wepropose a solving strategy for this problem based on max productbelief propagation.
finally we implement a prototype of ourmethod called qbindiff and propose an extensive evaluationwhich shows that our approach outperforms state of the artdiffing tools.
index t erms binary diffing binary program analysis graph edit distance network alignment belief propagation i. i ntroduction static program analysis is the process of analyzing and predicting the possible execution behaviors and outcomes of a program without actually executing it.
it can be performedon the source code of the program or with more difficulty on the binary executable.
static program analysis has a widevariety of applications such as vulnerability detection patchanalysis malware detection software clone detection etc.
in most of the cases static analysis of binaries needs human expertise which is leveraged using specific software tools.among those tools differs are particularly useful as they allowthe analyst to focus on the differences between a previouslyanalyzed program and the one currently under investigation enabling knowledge capitalization.
finding the differencesbetween two programs in binary form only is known as thebinary diffing problem.
several different formulations of the problem have been given mostly depending on the use case or the desiredgranularity but also implicitly induced by the solving approach .
in this paper we address the problem of finding the bestpossible one to one correspondence between the respectivefunctions of two programs in binary form.
following previous authors we leverage a graph edit formulation of binary diffing we find an almost optimaltransformation of the call graph of program ainto the call graph of program b with respect to some specific edit costs.
fig.
binary diffing as an alignment of call graphs.
thislayout represents the superposition of functions dots andfunction calls lines of two binaries libz .
.
.
vs libz .
.
.
.
such mapping provides useful information to ananalyst.
in this figure green dots and lines represent functionsand calls that remained identical from a program to theother and thus correspond to duplicated code.
blue resp.red elements represent inserted resp.
deleted items andmay indicate added resp.
removed functionalities.
yellowdots correspond to matched functions which content has beenmodified substituted .
they may thus record the functions thathave been patched during the release.
the figure highlights theinterest of leveraging the function call consistency in order tofind the best possible function correspondence.
36th ieee acm international conference on automated software engineering ase 36th ieee acm international conference on automated software engineering ase .
ieee .
ase51524.
.
.
ieee we then show that this formulation is equivalent to a network alignment problem.
following we propose an efficientapproximate solver of this problem based on max product belief propagation.
in summary our contributions are a new formulation of the binary diffing problem as agraph edit distance problem an equivalent formulation as a network alignment prob lem an efficient solver qbindiff based on max product belief propagation a new diffing benchmark dataset consisting in more than60 binaries and over manually extracted ground truthcorrespondences an extensive evaluation of our approach by comparing toother common matching methods as well as other stateof the art function similarity measures our experimental results show that the proposed approachoutperforms other diffing methods in almost all probleminstances.
moreover they highlight that function similaritymeasures originally designed for near duplicate detection arenot fitted to compute diffing assignments.
finally they suggestthat our problem formulation is particularly adapted to addressthe binary diffing problem.
the rest of paper is organized as follows.
section ii introduces in more details the binary diffing problem and reviewssome existing solutions.
our proposed formalization as anoptimization problem is described in section iii while sectioniv summarizes the maximization algorithm used to solve theproblem.
section v is dedicated to the experimental evaluationof our solution.
ii.
b inary diffing a. graph representation and function matching in binary analysis in order to consider its different potential execution behaviors a binary executable can be representedas a directed attributed graph.
in this graph nodes stand foruninterrupted sequences of instructions called basic blocks and edges indicate the possible jumps from a basic blockto another conditional jumps calls or returns .
such graphtheoretically represents all possible execution paths of theprogram.
it is known as the control flow graph cfg .
another common representation of a program consists in a partition of the control flow graph according to the callprocedures.
the resulting directed attributed graph is com posed of nodes denoting the different program functions andedges registering the calls among them.
it is known as call graph cg .
this representation corresponds to a higher level of abstraction than the cfg closer to the developer point ofview.
note that retrieving both the cfg and the cg of a binary executable is a challenging problem that may not be solvedexactly in some cases .
in this paper we assume that boththe cfg and cg can be reliably obtained from the executableprograms.
in this paper we define the binary diffing problem as the problem of matching call graphs.
we want to match functionsfrom one program to the functions of another such that theyshare similar functionalities node content similarity and theycall other functions in a similar way induced edge similarity .as a result when a matching is satisfactory the remainingdifferences between the call graphs can be interpreted asmeaningful modifications from one program to the other.
as any binary diffing formulation our definition requires a measure to assess the quality of a matching between twocall graphs.
this measure should evaluate the similarity ofmatched functions as well as the relevance of the resultinggraph alignment.
therefore any binary diffing instance ischaracterized by the given function similarity and topologysimilarity measures.
once they are properly defined we mayformulate the binary diffing problem as an assignment problemwhich solution is the best one to one correspondence betweenthe functions of both program.
in the rest of this section we present a short state of the art of existing methods to measure function similarity as well ascommon proposed approaches to compute the best functionmapping.
b. binary code similarity the problem of measuring how much two pieces of binary code are similar is a fundamental problem of program analysis.
indeed two seemingly different binary executablesmay have the exact same functionality.
such programs aresaid to be semantically equivalent while syntactically different.conversely two slightly divergent pieces of code may havevery different behaviors when executed.
moreover syntacticsimilarity is relatively easy to compute but can lead to incorrectmatching while full semantic characterization is undecidable and heuristics tend to be computationally expensive .
there fore the definition of a similarity measure between two binaryfunctions generally involves an arbitrary trade off betweensyntactic or semantic comparisons .
many recent approaches propose a mixed strategy.
the idea is to use simple syntactic features and to encode partof the function semantic through its control flow graph.
forinstance gemini introduces a siamese graph neural network to learn the common features of two semantically similar functions.
the model considers a very simple rep resentation of the function instructions as well as the basicblock layout of the cfg.
it then embeds these features intoa metric space where semantically similar functions are likelyto have close coordinates.
once every function representationis projected into this metric space pairwise similarity scorescan be computed very efficiently using common vector baseddistance computation routines.
based on the same basis of gemini graphmatching proposes to enhance the model with an attention mechanism based on the structure of both function cfgs.
howeversince it actively uses the topology of both graphs during thesimilarity score computation itself graphmatching can notbenefit from fast vector based distance computation as geminidoes.
therefore the time required to compute all pairwise 968similarity scores may rise significantly with the size of the binaries.
another alternative is asm2v ec which also provides vector representations for binary functions but in an unsuper vised way that does not need matching pairs of functions.deepbindiff improves over asm2v ec by working at thelevel of basic blocks.
the embedding of a basic block is basedon its content but also the one of its closer neighbors.
it usesan adaptation of a graph embedding algorithm text attributed deep walk tadw to extract a vector representation of each basic blocks among both binaries.
to do so it first mergesthe inter procedural cfgs of both programs based on the binary symbols and then runs the tadw algorithm to computethe embedding of each basic blocks in this larger graph.
notethat this approach is designed to proceed the diffing at a basicblock granularity whereas ours seeks a mapping between thefunctions of each binaries.
c. call graph matching given a similarity measures between functions one must now define a criteria of quality of the call graph alignment.
in practice such measure is closely related to the chosen functionmatching strategy.
the simplest solution for matching two call graphs consists in disregarding the call graph structure itself and simplylooking for a one to one mapping that maximizes the sumof the similarities between the matched functions.
in order toaddress the binary diffing problem this would be the naturalmatching strategy used by methods originally designed to re trieve similar functions such as gemini or graphmatching .
finding the best match reduces to an instance of thelinear assignment problem also know as the maximum weight matching problem mwm .
this is well known problem for which optimal solutions can be found exactly in polynomialtime using e.g.
the hungarian algorithm .
the major drawback of this approach is that the resulting mapping mightbe highly inconsistent with regards to the call graph structureof the two programs.
to overcome this issue other approaches such as bindiff and deepbindiff propose instead to use matchingalgorithms designed to approximate the maximum common edge subgraph problem mcs .
therefore they implicitly define binary diffing as an instance of the mcs.
this problemconsists in finding the node correspondence which inducesthe maximum number of overlapping edges when aligningthe graphs .
the general idea of those solutions is toexpand in an iterative way the partial solution by seekingpotential matches in the neighborhood of the current mapping caller or callee of any already matched function .
though inpractice this strategy proved to provide satisfying results itsuffers from a major limitation by restricting new matchesto belong to the respective neighbors of the current partialmapping it prevents the assignment of potentially better non local correspondences.
therefore this strategy mostly consistsin finding a locally consistent mapping whereas a globallybetter assignment potentially exists.d.
graph edit distance a natural way to globally assess the quality of a matching is to consider it as a particular case of graph edition.
one defines a set of graph edit operations on both nodes and edgesof the graphs and assigns to them a cost.
the cost of a seriesof operations also called an edit path is simply the sum of the costs of said operations.
then the edit path that transformsgraphaintobat the minimum cost is called an optimal edit path and the resulting edit cost is known as the graph edit distance .
a matching can be viewed as a particular edit path in which matched nodes result from an edition whereas un matched nodes in aare considered removed and unmatched nodes in binserted.
the operation on the edges insertion deletion edition are then completely induced by those onthe nodes see section iii for details .
therefore there is aclose relationship between an optimal matching and an optimaledit path.
unfortunately the computation of the graph edit distance of two arbitrary graphs is known to be np complete and evenapx hard .
though exact algorithms exist they rapidlybecome intractable as the number of vertices rises .
inpractice the computation of the ged of graphs of more thana hundred nodes must be approximated.
note that the above mentioned mcs problem is also np complete.
several approaches previously proposed to compare programs in binary form through a ged formulation .
however in order to compute an approximated solution all of them refer to riesen and bunke s linear programmingrelaxation which reduces to a mwm formulation ofthe binary diffing problem with a function similarity measuretaking into account the number of incident edge of eachfunction.
in this paper we propose to directly address the ged problem through an equivalent network alignment problemformulation.
in this form the globally optimal edit path canbe efficiently approximated by means of a message passingframework.
iii.
f ormaliza tion the novelty of our approach lies in the reformulation of the graph edit distance calculation into a network alignment problem nap which can then be solved approximately with a dedicated message passing algorithm.
we give a formalderivation of the nap in the present section.
a. binary diffing as a graph edit distance problem let us consider two binary executables aandb.w e assume that adapted disassembly tools are used to represent them by their respective call graph g a va ea and gb vb eb .
the vertices va ... n andvb prime ... m prime represent the functions of aandb.
the edges ea i j i j v2 a i negationslash j andeb i prime j prime i prime j prime v2 b i prime negationslash j prime represent the function calls e.g.
i j ea encodes the fact that function icalls function jin program a .
without loss of generality self loops a.k.a.
recursive calls are 969table i graph edit operations and respective costs.
operation cost edit function c i i prime dii prime delete function c i epsilon1 d epsilon1 insert function c epsilon1 i prime d epsilon1 edit call c i j i prime j prime dii primejj prime delete call c i j epsilon1 d epsilon1 epsilon1 insert call c epsilon1 i prime j prime d epsilon1 epsilon1 not taken into account they can be accounted for at the level of the function similarity calculation .
we assume given two similarity measures.
vmeasures the similarity between two functions i vaandi prime vbsuch that v i i prime sii prime.
emeasures the similarity between function calls.
ificallsjinaandi primecallsj primeinb the similarity of those calls is e i j i prime j prime sii primejj prime.
we assume that the similarities give values in .
this enables us to convert similarities into costs using dii prime sii primeanddii primejj prime sii primejj prime.
finally we assume given two non negative constant valuesd epsilon1andd epsilon1 epsilon1corresponding to the cost of insertion or deletion of a function and call in a call graph.
we denote any series of graph edit operations p op1 ... op k an edit path and define p a b as the set of all possible edit paths that transform ga intogb.
formally if op1 ... op k p a b then opk opk ...op ga ... gb.
we finally denote c p summationtextk i 1c opi the cost the edit path p. table i lists the six possible graph edit operations we consider with their respective costs.
in this paper we restrict p a b to the set of restricted edit paths .
an important property of such paths is that they correspond to a uniquemapping between the functions of aand those of b see the appendix for details .
note that unlike common geddefinitions our formulation implies a constant cost for everyfunction or call insertion or deletion whatever its content.
based on these definitions our formulation of the binary diffing problem consists in finding the minimal cost edit pathp that transforms a into b. formally p a r gm i n p p a b c p a r g m i n op1 ... op k p a b k summationdisplay i 1c opi .
ged b. binary diffing as a network alignment problem we now reformulate our definition of the binary diffing problem as an equivalent instance of a network alignment problem.
we first describe the diffing correspondences via a binary vector x va v b where u denotes the cardinality of the set u for which xii prime if and only if function i inais matched with function i primeinb.
to ensure that each function from ais matched to at most one function in band vice versa xmust fulfil the following constraints i va summationdisplay j prime vbxij prime i prime vb summationdisplay j vaxji prime .
a good matching should associate similar functions that havealso similar calling patterns.
this can be captured in a cost matrixq r va vb 2defined as follows qii primejj prime wii prime ifii prime jj prime wii primejj prime if i j eaand i prime j prime eb otherwise.
with wii prime sii prime 2d epsilon1 w ii primejj prime sii primejj prime 2d epsilon1 epsilon1 .
using these definitions it can be shown that computing the optimal edit path of ged is equivalent to solving thefollowing network alignment problem x argmax xxtqx subject to i va summationdisplay j prime vbxij prime i prime vb summationdisplay j vaxji prime nap we provide a proof in the appendix.
c. graph edit operation costs local vs global similarity trade off the definition of the edit operation costs of any ged formulation usually relies on carefully chosen data based considerations see e.g.
.
costshave obviously an effect on the quality of the matching butalso on the ability of a solver to find an approximately optimalsolution.
moreover because of the difficulty of function com parisons local similarities might be inconsistent with the callpatterns and there may be no solution optimal both locally andglobally.
therefore a matching results from an inherent trade off between local node similarity and global graph topology.
in order to control the trade off one can decompose qinto two terms and weight them.
we define q 1as the diagonal matrix in r va vb 2with diagonal terms q1ii primeii prime wii primeand q2asq2 q q1.q1gathers the function node similarities whileq2contains all the potential induced overlapping edges called squares .
a potential square consists of a pair of edgesin both call graphs i j e aand i prime j prime eb.i fi is matched to i primeandjtoj prime then the call structure is preserved and in a sense forms a square with two sides coming fromthe matches and two sides coming from the calls .
given a trade off parameter the objective function of nap can thus be modified into x tq1x xtq2x.
in terms of graph edit operations this reformulation consistsin appropriately weighting the original edit operation costs.
notice that extreme cases for correspond to some interesting particular cases.
when we recover a maximum weight matching mwm strategy which disregards the callswhile corresponds to a maximum common edge subgraph instance mcs where function similarities are notused.
therefore our formulation can be seen as a balancedstrategy between the two most common binary code matchingmethods.
970table ii function features and respective weights used in our proposed similarity measure.
the final similarity score iscomputed using the canberra distance.
type weight features content 23total of instructions of instructions per classmax of block instructions topology of blocks of jumpsmax of block callersmax of block callees neighboorhood of function callers of function callees function content similarity in this paper we propose a simple function similarity metric v. it consists in a weighted canberra distance over the set of features given in table ii.
during the computation each feature is properly weightedaccording to its type.
we distinguish content based instruc tions topological based cfg layout and neighborhoodbased features cg callers and callees .
note that one of ourfeature refers to an instruction classification.
this classificationencodes each instruction using the class of its mnemonic andthe ones of its potential operands.
our taxonomy consistsin respectively and different mnemonic and operandclasses.
since most matching algorithms are sensitive to ties between function distances we introduce a small perturbation to theresulting similarity scores.
assuming that the denomination ofthe functions is consistent with their order in terms of entryaddress the similarity between function iinaandi primeinbis being increased by the value i i prime max v a v b .
function call similarity in order to measure the similarity of two function calls we simply use a indicator i.e.
e i j i prime j prime if and only if i j eaand i prime j prime eb.
therefore the matrix q2can be computed through the kronecker product of the affinity matrix of ga andgb.
finally in order to compare with other state of the art methods and because in general binary diffing favors recallover precision we set the insertion deletion operation costs tod epsilon1 d epsilon1 epsilon1 .
this forces the algorithm to produce a complete mapping even when some assignments are of poor relevance.
as pointed out in section ii b other similarity measures have been proposed some of them being much more so phisticated than the one we propose to use.
however thispaper aims at identifying the benefit of the proposed matchingapproach and as such a simple metric seems more appropriateto emphasize the effect of variations in matching.
iv .
n etwork alignment with max product belief propaga tion the network alignment problem sometimes also referred to as graph matching problem is an important optimizationproblem that has been extensively studied for decades .although it is not easier to solve the nap than the ged several efficient approximate algorithms have been proposed based on spectral methods convex or indefiniterelaxations or linearization .
in this section we introduce a novel algorithm to efficiently approximate the binary diffing problem as a network alignmentproblem.
this algorithm is inspired of a previous model of which proposes to address the integer program nap throughan equivalent graphical model mode inference.
a graphical model is a way to represent a class of probability distributions over some random variables .
there isa strong link between inference in graphical models and opti mization especially when we consider maximum a posteriori map inference.
this is the general problem of finding themost probable value of some of the random variables giventhe value of the rest of the variables.
a particular case of mapinference is to find the mode of a probability distribution i.e.
the most probable value of all its variables.
one of themost efficient algorithm for map inference is the max product algorithm.
it consists in passing messages between the verticesof the graphical model that represents the distribution see e.g.
chapter .
to leverage this algorithm we design a graphical model that encodes both the objective function and the constraints of napinto a probability distribution such that it assigns maximumprobability to the optimal assignment of the nap .
finding themode of the distribution is then equivalent to solving the nap .
formally matching vector xis associated to binary random variables x x ii prime ii prime va vb .
the constraints of nap are encoded through dirac measuresf i f i andgi prime gi prime such that i va fi x fi braceleftbigg if summationtext j prime vbxij prime otherwise.
i prime vb gi prime x gi prime braceleftbigg if summationtext j vaxji prime otherwise wherex fi xij prime x j prime vb and similarly for x gi prime.
the probability distribution of the corresponding graphical model is then px x z n productdisplay i 1fi x fi m prime productdisplay i prime primegi prime x gi prime e xtqx where the normalization constant zdenotes the partition function of the model.
it is clear that the support of the distribution is equivalent to the set of feasible solutions in nap .
furthermore the mode ofpx x corresponds to the optimal solution of nap .
in our work we introduce modifications to the original model of in order to speed up the computation and favor themessages convergence.
though the details and improvementsof these modifications are out of scope for this paper we pro vide a complete derivation of the message passing frameworkin the appendix.
a key property of this model is the local structure of the message passing scheme.
this later limits the propagation 971of updates to the connected components only and therefore reduces the overall computation cost of the problem whenworking on sparse graphs which is generally the case ofcall graphs.
moreover it enables to discard some potentialcorrespondences considered too unlikely and thus significantlyreduce the size of the problem solution set.
this property isvery useful to control the required computation cost and mem ory usage of larger problem instance as shown in e.g.
the cost of one iteration of our algorithm is in o nnz q nnz q2 wherennz x denotes the number of non zero entries in x. note that after the last iteration we need to solve a mwm problem which adds a o nnz q1 n n2logn cost to the whole procedure where n va vb .
our implementation includes a sparsity ratio parameter in order to remove a ratio of less probable correspondences and forces the algorithm to find a solutionamong the remaining ones.
v. e v alua tion this section is dedicated to a thorough evaluation of our proposed solution named qbindiff and to a comparisonof its performances with a selection of state of art diffingapproaches.
we describe first our evaluation benchmark thenthe chosen binary code similarity and finally the experiments.
a. benchmark a diffing approach can be evaluated by comparing the mapping results with true assignments known as the ground truth.
unfortunately such assignments are not readily available and may be in fact very difficult to determine in an objectiveway.
as part of this work we have built a new benchmarkthat will be released to the research community.
benchmark design to select programs to include in the proposed benchmark we have considered several require ments.
first the source of the programs should be made read ily available within several different versions.
this enables usto compile the program with symbols and thus ease the deter mination of the ground truth.
second well maintained sourcerepositories with explicit commit descriptions detailed changelogs as well as a relatively consistent function denominationover time are also very important features for the ground truthextraction.
third as this extraction is largely done manually program sizes should be reasonable .
according to these considerations we choose three well known open source project to compose our experimentaldataset namely zlib libsodium2and openssl3.
note that some of these programs are amongst the most frequently usedfor evaluation in the literature .
for each of these projects we first downloaded the official repository then we compiled the different available versionsusing gcc v7.
for x86 target architecture with o3 opti mization level and keeping the symbols.
once extracted eachbinary was stripped to remove all symbols then disassembled iii description of our binary diffing dataset.
thelast six columns respectively record the number of differentbinary versions the number of resulting diffing instances theaverage number of functions and function calls and the averageratio of conserved functions in our manually extracted andextrapolated ground truth.
program v ers.
diff.
nodes edges gt gt zlib .
.
libsodium .
.
openssl .
.
using ida pro v7.
and finally exported into a readable file with the help of binexport5.
during the problem statement only plain text functions determined during the disassembly process are considered.
this extraction protocol provided us with respectively and different binary versions.
for each project given n different versions of the program we propose to evaluate our method in diffing all then n 2possible pairs of different executables.
statistics describing our evaluation dataset are given in table iii.
notice that both the average call graph size and density of the programs varies with the different projects.
this varietywill provide insights on the scalability of the diffing methodsunder study as well as the effect of sparsity on our solver.
ground truth as recalled in section ii determining the true assignment between the functions of two given binariesis a difficult task.
in its strongest sense this problem reducesto evaluate the semantic equivalence between two pieces ofcode and is known to be undecidable .
in practice when working on different versions of the same open source and well documented binary one maysignificantly reduce the difficulty by carefully exploiting thehuman readable information available in both the source codeand the binary symbols.
moreover some project repositoriesinclude detailed commit descriptions that precisely recordthe modification from a version to another.
however theseinformation almost always refer to the changes occurringduring a release and are thus only available for contiguousversions.
therefore in order to obtain the function assignmentamong two arbitrary program versions one must extrapolatethe different mappings of the releases that happened in themeantime.
our ground truth extraction protocol has two steps.
we first manually determine what we think to be the functionmapping that best describes the modifications between twosuccessive binary versions.
this process is done with regardsto the changelogs files the source code and the unstrippedbinaries.
excepted for few major project modifications almostall the functions are mapped from a version to its successor see table iii .
once all the contiguous version ground truth mappings are extracted we deduce all the pairwise diffing correspondences 972by extrapolating the mappings from version to versions.
formally if we encode the mapping between a1anda2into a boolean matrix ma1 a2such that ma1 a2ii prime if and only if function iina1is paired with function i primeina2 then our extrapolating scheme simply consists in computingthe diffing correspondence between a kandanas follows mak an producttextn i kmai ai .
b. experimental setup all the experiments have been conducted on an identical hardware6 using the implementation provided by the authors when possible.
our method qbindiff is used with its default parameters .75and epsilon1 .
and within a maximum of iterations.
we set the sparsity ratio parameter to0for smaller projects zlib and libsodium and to .9for openssl.
we compare our method with bindiff a closed source state of the art binary diffing tool which uses a matchingalgorithm very close to mcs but based on different nonpublic function similarity heuristics.
in addition our approach is compared to differs constructed by combinations chosen among three function similarity mea sures and two matching algorithms outlined in section ii.
allcombinations are used.
the baselines are described below.
function content similarity to evaluate the impact of the function similarity measure on the diffing process threestate of the art binary code similarity approaches have beenselected gemini graphmatching graphm.
anddeepbindiff deepbd.
.
gemini and graphmatching are supervised learning models that require to be trained on multiple pairs of functions labeledas similar or different.
as the manual construction of such adataset is tedious existing methods usually use a collection offunctions extracted from slightly mutated programs such asdifferent versions of an executable.
then a pair of functionsis labeled as similar if they share the same or very similar name and dissimilar otherwise.
we applied this protocol to our dataset.
note that this should give a small competitive advantage to differs basedon gemini and graphmatching as their similarity measureswill be optimized on the specific type of functions found inthe binaries under study.
during the training process we collected samples of differently named functions from the unstripped binaries.
of them were used as training examples as avalidation set and the remaining were used to assess thefinal accuracy of the trained models.
both models were trainedusing their recommended hyper parameters.
to compute thesimilarity score of two embedded vectors gemini uses acosine similarity measure whereas graphmatching refers toa normalized euclidean metric.
after the training the modelsrespectively provided an estimated auc 7of0.
and0.
.
we also trained deepbindiff instruction embedding model on each binary of our dataset following the protocol and the 6intel xeon e5 v4 .20ghz 7area under the roc curverecommendations of the corresponding article .
as deep bindiff provides embeddings of basic blocks we representeach function by the average of all its basic block embeddings.
matching our matching algorithm is compared to the two most common methods found in the literature namelymwm and mcs the mwm matching strategy implicitly used by gemini and graphmatching consists in solving the linear assignmentproblem based on the computed pairwise similarity scores.
theexact solution of this problem can be found using conventionaloptimization solvers.
several algorithms have been proposed to approximate the mcs problem.
in order to compare with bindiff anddeepbindiff we based our implementation on the one usedin deepbindiff.
however since a cg is usually much moredense than a icfg we limited the neighbor parameter kto .
note that to output a complete mapping the algorithmterminates by applying a mwm solver to the set of unmatchedcorrespondences.
c. results the quality of a diffing result is measured using its precision and recall with respect to the ground truth.
we refer to the standard definitions of precision and recall i.e.
p m g g and r m g m wheremandgrespectively correspond to the set of matched function pairs in the computed and ground truth assignments.
note that except for bindiff all the evaluatedmethods are designed to produce a complete mapping.
in fact none of them includes a mechanism to limit the mapping of themost unlikely correspondences during computation.
therefore these matching strategies do not consider precision but onlyfocuses on recall.
in future work we will investigate the effectof rising the insertion deletion operation costs d epsilon1andd epsilon1 epsilon1in order to favor the solution s precision score.
our experiments show that qbindiff generally outperforms other matching approaches in both precision and recall seetable iv qbindiff nap combinations .
in fact our methodappears to perform clearly better at diffing more differentprograms whereas it provides comparable solutions on similarbinaries see figure .
this highlights that the local greedymatching strategy of both mwm and mcs is able to providegood solutions on simple cases but generalizes poorly on moredifficult problem instances.
this results should be view aspromising in the perspective of diffing much more differentbinaries.
our nap matching strategy can be applied with the state ofthe art function similarities chosen as reference.
as observedwith our custom metric nap provides better assignments thanother matching approaches.
moreover it appears that in almostall cases the chosen matching strategy has more influencethan the similarity metric.
more surprisingly the use of thesecomplex models does not improve the accuracy of the resultingmapping and might even worsen it in some case.
since thetopology of the graphs does not change this means that thecomputed similarity scores are not consistent with the actualground truth assignment.
in fact it appears that both gemini 973fig.
average recall scores according to the program versions distance.
every matching method provides comparable near optimal results while diffing very similar programs.
as thedistance increases the performances of local matching strate gies decline faster than our global approach.
a pairwise similarity scores b ground truth similarity scores fig.
cumulative distribution function of all non zero pair wise similarity scores a and of the ground truth pairs only b libsodium .
.
vs libsodium .
.
.
the similarity scoresin a that correspond to a ground truth correspondence aremarked by a cross.
graphmatching appears to be well fittedto retrieve a large part of the correct matches but stronglydeteriorates the score of some.
qbindiff provides a more bal anced score but keeps almost all ground truth correspondenceto a satisfying level.
and graphmatching models very accurately retrieve similar functions but strongly deteriorate the similarity scores of morediverging ones see figure .
this is consistent with theoriginal purpose of both model and with the training datasetwhich labels as completely different two similar functionswith different names.
in the case of deepbindiff it seemsthat the scores of ground truth correspondences are distributedrelatively uniformly over the cumulative distribution function which means that the model itself does not provide sufficientlydiscriminative scores and thus leads to erroneous assignments.moreover we were not able to compute deepbindiff embed dings on openssl binaries in reasonable time.
indeed theseproblem instances involve the factorization of the adjacencymatrices of graphs of over nodes which is a verycomputationally intensive task.
an interesting analysis consists in comparing the different matching method assignments to the ground truth cor respondences in terms of function similarity score and callgraph alignment see figure .
it appears that both zliband openssl ground truth assignments are near optimal inboth maximum weight matching and maximum common edgesubgraph scores.
this observation is consistent with our exper table iv average precision and recall scores for eachcombination of similarity measure similarity and matchingmethod matcher .
the three tables correspond to the resultson zlib top libsodium middle and openssl bottom programs.
the last two columns correspond to the similaritycalculation time sim.
calc.
and to the matching time time both given in second.
similarity matcher precision recall sim.
calc.
time qbindiffnap .
.
.
.
mwm .
.
.
mcs .
.
.
gemininap .
.
.
.
mwm .
.
.
mcs .
.
.
graphm.nap .
.
.
.
mwm .
.
.
mcs .
.
.
deepbd.nap .
.
.
.
mwm .
.
.
mcs .
.
.
bindiff bindiff .
.
.
.
similarity matcher precision recall sim.
calc.
matching qbindiffnap .
.
.
.
mwm .
.
.
mcs .
.
.
gemininap .
.
.
.
mwm .
.
.
mcs .
.
.
graphm.nap .
.
.
.
mwm .
.
.
mcs .
.
.
deepbd.nap .
.
.
.
mwm .
.
.
mcs .
.
.
bindiff bindiff .
.
.
.
similarity matcher precision recall sim.
calc.
matching qbindiffnap .
.
.
.
mwm .
.
.
mcs .
.
.
gemininap .
.
.
.
mwm .
.
.
mcs .
.
.
graphm.nap .
.
.
.
mwm .
.
.
mcs .
.
.
bindiff bindiff .
.
.
.
imental results that shows that a balanced network alignmentmatching strategy provide better accuracy results than otherapproaches.
more importantly it justifies our intuition thatthe proposed problem formulation as a network alignmentproblem is very well suited to address the binary diffingproblem.
however in some cases libsodium correct assign ments show to be sub optimal in both function similarity andgraph topology.
in these cases the ground truth mappings areinconsistent in both function content syntax and invoked callprocedures.
we investigated these cases and noticed that overthe versions several functions were split in two such that afirst trivial function is solely designed to access a second corefunction actually containing the whole function semantic.
aswe largely determined our ground truth based on functionnames we mapped full functions into their newly created 974fig.
relative similarity scores and square numbers of different matching methods compared to the optimal assignment.the grey lines record the normalized scores of the groundtruth.
for zlib left and openssl right binaries the groundtruth seems to be a near optimal nap assignment in almostall cases.
this result does not hold for libsodium center asin some cases assignments computed by qbindiff are betterin both function similarity and number of induced squares.
accessors.
we discuss these specific cases in the next section.
our experiments also suggest that our rather basic function similarity metric provides scores that are consistent with the actual ground truth assignment see figure .
moreover on the contrary to supervised learning models gemini andgraphmatching it produces less discriminative scores.
thoughit might be view as a less informative metric it appears thatthis keeps the ground truth correspondences similarity scoresat a satisfying level and ultimately results in better solutions see figure .
finally we recorded the computing time of each methods.
as could be expected it takes much more time to approximatethe nap of two graphs than to compute the mwm or themcs.
however this can be controlled by raising the sparsityratio parameter at the cost of limiting the problem solution set and potentially resulting in sub optimal assignments.moreover it seems that better similarity scores speed up thecomputation.
this is due to the fact that the algorithm findsmore easily a satisfying local optima.
regarding the processingtimes it appears that whereas the use of gemini model doesnot harm the required time both graphmatching and deep bindiff take very long time to compute the pairwise similarityscores which might be prohibitive for larger programs.
d. limitations while it improves the state of the art our method could be further enhanced.
a first limitation is that our approach is designed to find a one to one correspondence between the functions of both programs.
thus it can not properly handle cases where afunction in a binary is split into several ones in the otherprogram or similarly multiple functions are merged into asingle one.
in such case the information of both the functionsyntax and its call graph relations is diluted into multiplechunks and may be harder to retrieve.
note that to our knowl edge this problem is common to all other diffing methods andthat in practice many function splits result in a core functioncontaining most of the semantic information and few trivialfunctions that are immediately called before or after it as inthe libsodium programs .
such schemes could be handled bya pre processing step.
the other key property of our approach is that it is based on the assumption that the true expected mapping is the optimalsolution to the graph edit distance problem.
although it ispartially validated by our limited sized experiments there is nogeneral available result that proves that this intuition is verifiedin practice especially for more complex cross compiler orcross architecture diffing instances.
one may argue that thisonly depends on the given graph edit operation costs definition.however in practice there is no known function similaritymetric that exactly encodes the functions semantic and theinterest of our method mostly rely on programs with rathersimilar call graphs.
moreover the trade off parameter that balances the node and edge edit costs should be chosencarefully which requires human expertise and prior knowledgeabout the binaries under analysis.
finally an important drawback of our problem formulation is that it requires a quartic memory matrix q. though we proposed to significantly reduce the problem size by limitingthe solution set to the most probable correspondences thisrelaxation inevitably induces information loss especially forlarge graphs where the relaxation must rise consequently.
inpractice binaries of several thousands of functions can behandled efficiently.
for larger programs it might be better tofirst partition the call graphs into smaller consistent subgraphs and then proceed the matching among them.
although thispartition is not trivial and might result in important diffingerrors it can be quite natural in modern programs for examplefollowing its modules.
e. threats to validity internal validity our evaluation relies on a collection of diffing instances for which the ground truth assignment has been manually determined.
though we performed thisextraction with regards to multiple sources of information suchas source code commit descriptions and unstripped symbols we can not guarantee that our judgment is not biased nor thatit actually meets other experts opinion.
furthermore any erroror absence in our extracted mappings is later propagated inour extrapolation step.
this may lower the confidence in theground truth assignment between two distant versions.
thisthreat is inherent to any manually determined assignmentsand can only be mitigated by releasing the dataset for thecommunity to review.
external validity despite the relatively large number of proposed diffing instances several factors still threaten thegeneralizability of our experiments.
first our benchmark onlyincludes c programs taken from three open source projects.this is not representative of the variety of existing binaries.moreover all the executables were compiled with the samecompiler optimization level and targeted architecture.
in futureworks we will investigate the performance of our approach onprograms built under different settings.
notice that this wouldprobably require more sophisticated measures of similarity 975able to efficiently handle greater syntactic differences.
last but not least all our diffing instances compare different versionsof a same program.
though the manual determination of anunanimous ground truth assignment between two differentprograms appears to be quite challenging the evaluation ofour method on such instances could be very instructive inthe perspective of many applications such as the detection ofvulnerability or of duplicate code.
construct validity the proposed comparison of our approach with other state of the art methods could also includethreats to construct validity.
first all these methods are basedon machine learning models that require a prior training step.we trained the models on the same dataset than the onewe ran our experiments on.
this could bias the resultingsimilarity scores especially in case of overfitting.
moreover we configured all models with their default parameters recom mended by the authors though different settings could haveprovided better results.
finally we must recall that none ofthe competitor methods where originally designed to addressthe exact same problem as ours.
indeed both gemini andgraphmatching have been initially proposed to retrieve near duplicate functions whereas deepbindiff addresses the binarydiffing problem at a basic bloc granularity.
vi.
c onclusion in this paper we introduced a new approach to address the binary diffing problem.
it is based on its reformulationas a graph edit distance problem.
this problem was shownto be equivalent to the network alignment problem for whichwe derived an approximate message passing algorithm.
weproposed a new benchmark including hundreds of diffingground truths and used it to compare the proposed approachto state of the art binary diffing methods.
our experiments showed that our algorithm outperforms other existing approaches in almost every problem instances.
italso highlighted that the matching strategy is a crucial part ofthe diffing process and has more influence than the choiceof the function similarity measure.
moreover it appearedthat using similarity metrics originally designed to retrievenear duplicate functions might actually harm the quality ofthe resulting mapping.
finally our results suggest that ourproblem formulation is a very adapted way to address thebinary diffing problem.
besides our formulation is quite natural and showed to result in more accurate mappings it also provides a proper metricfor measuring program wide similarity.
indeed any diffingassignment induces the approximated graph edit distancebetween the two programs.
therefore our approach could alsobe used in a variety of metric based analysis at a programlevel such as library retrieval program lineage etc.
finally we believe that our graph matching algorithm could also be leveraged to perform diffing between matched func tions in a post processing step.
this would results in a finedgrained alignment between constitutive basic blocks of bothfunctions and could provide to an analyst precious informationabout their exact differences.a ppendix proof of equivalence of ged and nap in the following proof we first show that the solution set of ged can be reduced to the one of nap .
then we showthat both objective functions are equivalent up to a sign anda constant term which completes the proof.
letp a b be the set of all restricted edit path transformingg aintogb .
this set consists in edit paths where any node can be removed only if its incident edges have beenpreviously removed and where any edge can be inserted onlyif its terminal nodes previously existed or have been inserted.moreover no nodes or edges can be successively inserted thenedited edited then deleted inserted then deleted or editedmultiple times.
finally overlapping edge must be consideredas an edition and can not result from a deletion then aninsertion.
it can be shown that any edit path in p p a b can be fully characterized by a unique injective function of asubset v aofvatovb and reciprocally.
such a mapping can be encoded as a binary vector x va v b such that xii prime 1if and only if i i prime pand satisfying the following constraints i va summationdisplay j prime vbxij prime i prime vb summationdisplay j vaxji prime .
indeed the injection implies that any node i prime vbis the image to at most one node i va. therefore i prime vb summationtext j vaxji prime .
moreover any node i vahas a unique image in vb s o summationtext j prime vbxij prime whereas any node j va vais not part of the injection and summationtext j prime vbxjj prime .
reciprocally the constrained boolean vector defines a oneto one mapping between the subsets of nodes va vaand vb vb.
thus it implies a unique injection between vaand the whole set of functions vb.
therefore there is a bijection between the solution set of ged and the one of nap .
let us now evaluate the cost of any arbitrary edit path p p a b .
recall that this cost is completely induced by the edit operation on the nodes.
we first describe cv p the cost of the node operations in p. we distinguish the different possible operations such that cv p summationdisplay i i prime pc i i prime summationdisplay i epsilon1 pc i epsilon1 summationdisplay epsilon1 i prime pc epsilon1 i prime summationdisplay i i prime pdii prime 2d epsilon1 summationdisplay i epsilon1 pd epsilon1 summationdisplay i i prime pd epsilon1 summationdisplay epsilon1 i prime pd epsilon1 summationdisplay i i prime pd epsilon1 summationdisplay i i prime pdii prime 2d epsilon1 summationdisplay i vad epsilon1 summationdisplay i prime vbd epsilon1 summationdisplay i i prime pdii prime 2d epsilon1 va d epsilon1 vb d epsilon1.
976in order to evaluate the cost of all the edges operations we must consider the different possible configurations for pairsof nodes.
but first we must introduce the following notations a ij braceleftbigg if i j ea otherwise.
and similarly for b i primej prime.
we may now evaluate ce p such that ce p summationdisplay i i prime p summationdisplay j j prime p bracketleftbig dii primejj prime a ij b i primej prime d epsilon1 epsilon1 a ij b i primej prime d epsilon1 epsilon1 a ij b i primej prime bracketrightbig summationdisplay i i prime p summationdisplay j epsilon1 pd epsilon1 epsilon1 a ij summationdisplay i i prime p summationdisplay epsilon1 j prime pd epsilon1 epsilon1 b i primej prime summationdisplay i epsilon1 p summationdisplay j j prime pd epsilon1 epsilon1 a ij summationdisplay epsilon1 i prime p summationdisplay j j prime pd epsilon1 epsilon1 b i primej prime summationdisplay i epsilon1 p summationdisplay j epsilon1 pd epsilon1 epsilon1 a ij summationdisplay epsilon1 i prime p summationdisplay epsilon1 j prime pd epsilon1 epsilon1 b i primej prime summationdisplay i i prime p summationdisplay j j prime p dii primejj prime 2d epsilon1 epsilon1 a ij b i primej prime summationdisplay i va summationdisplay j vad epsilon1 epsilon1 a ij summationdisplay i prime vb summationdisplay j prime vbd epsilon1 epsilon1 b i primej prime summationdisplay i i prime p summationdisplay j j prime p dii primejj prime 2d epsilon1 epsilon1 a ij b i primej prime ea d epsilon1 epsilon1 eb d epsilon1 epsilon1.
putting all together and denoting c p0 va d epsilon1 vb d epsilon1 ea d epsilon1 epsilon1 eb d epsilon1 epsilon1 the cost of any edit path pis c p cv p ce p c p0 summationdisplay i i prime pdii prime 2d epsilon1 summationdisplay i i prime p summationdisplay j j prime p dii primejj prime 2d epsilon1 epsilon1 a ij b i primej prime c p0 summationdisplay ii prime va vbxii prime dii prime 2d epsilon1 summationdisplay ii prime va vb summationdisplay jj prime va vbxii prime dii primejj prime 2d epsilon1 epsilon1 a ij b i primej primexjj prime c p0 summationdisplay ii prime va vbxii primewii prime summationdisplay ii prime va vb summationdisplay jj prime va vbxii primewii primejj prime a ij b i primej primexjj prime c p0 summationdisplay ii prime va vb summationdisplay jj prime va vbxii primewii primejj primexjj prime c p0 xtqx where we simply use the fact that dii prime 2d epsilon1 wii prime and similarly for wii primejj prime.
therefore exploiting the one to one correspondence between an edit path pand its boolean representation x we may turn the minimization of ged into a maximization problem and obtain nap .
squaresolidqbindiff s message passing scheme we reproduce the messages derivation of and introduce our modifications.
for the sake of simplicity we changed themessage passing denomination of the original paper to besthighlight their vectorial structure.
the messages f f ii prime wii prime negationslash g gii prime wii prime negationslash andh hii primejj prime wii prime negationslash wjj prime negationslash are all initialized to .
at each iteration the algorithm computes the following updates f t ii prime wii prime parenleftbigg max k negationslash ig t ki prime parenrightbigg t ii prime summationdisplay jj prime bracketleftbig wjj primeii prime h t jj primeii prime bracketrightbigwjj primeii prime g t ii prime wii prime parenleftbigg max k prime negationslash i primef t ik prime parenrightbigg t ii prime summationdisplay jj prime bracketleftbig wjj primeii prime h t jj primeii prime bracketrightbigwjj primeii prime h t ii primejj prime wii prime parenleftbigg max k prime negationslash i primef t ik prime parenrightbigg t ii prime parenleftbigg max k negationslash ig t ki prime parenrightbigg t ii prime summationdisplay kk prime negationslash jj prime bracketleftbig wkk primeii prime h t kk primeii prime bracketrightbigwkk primeii prime where x max x and b a a ifx a x ifa x b b otherwise and where we introduced bertsekas epsilon1 complementary slackness mechanism t ii prime braceleftbigg epsilon1 iff t ii prime negationslash max k primef t ik prime otherwise.
t ii prime braceleftbigg epsilon1 ifg t ii prime negationslash max kg t ki prime otherwise.
at the end of iteration t the estimated mode is achieved by x t ii prime braceleftbigg if p t xii prime otherwise where p t xii primedenotes the log ratio of the estimated marginal distribution of xii prime p t xii prime wii prime parenleftbigg max k prime negationslash i primef t ik prime parenrightbigg t ii prime parenleftbigg max k negationslash ig t ki prime parenrightbigg t ii prime summationdisplay jj prime bracketleftbig wjj primeii prime h t jj primeii prime bracketrightbigwjj primeii prime 977references i. u. haq and j. caballero a survey of binary code similarity acm computing surveys vol.
no.
pp.
apr.
.
x. hu t. c. chiueh and k. g. shin large scale malware indexing using function call graphs in proceedings of the 16th acm conference on computer and communications security ser.
ccs .
chicago illinois usa association for computing machinery nov. pp.
.
o. kostakis j. kinable h. mahmoudi and k. mustonen improved call graph comparison using simulated annealing in proceedings of the acm symposium on applied computing ser.
sac .
taichung taiwan association for computing machinery mar.
pp.
.
m. bourquin a. king and e. robbins binslayer accurate comparison of binary executables in proceedings of the 2nd acm sigplan program protection and reverse engineering workshop ser.
pprew .
rome italy association for computing machinery jan. pp.
.
m. bayati m. gerritsen d. f. gleich a. saberi and y .
wang algorithms for large sparse network alignment problems in proceedings of the ninth ieee international conference on data mining ser.icdm .
usa ieee computer society dec. pp.
.
x. meng and b. p .
miller binary code is not easy in proceedings of the 25th international symposium on software testing and analysis ser.
issta .
new y ork ny usa association for computingmachinery jul.
pp.
.
l. massarelli g. a. di luna f. petroni l. querzoni and r. baldoni investigating graph embedding neural networks with unsupervisedfeatures extraction for binary analysis in proceedings workshop on binary analysis research.
san diego ca internet society .
k. redmond l. luo and q. zeng a cross architecture instruction embedding model for natural language processing inspired binarycode analysis in proceedings workshop on binary analysis research.
san diego ca internet society .
x. zhang w. sun j. pang f. liu and z. ma similarity metric method for binary basic blocks of cross instruction set architecture inproceedings workshop on binary analysis research.
san diego ca internet society .
m. cova v .
felmetsger g. banks and g. vigna static detection of vulnerabilities in x86 executables in proceedings of the 22nd annual computer security applications conference ser.
acsac .
usa ieee computer society dec. pp.
.
d. gao m. k. reiter and d. song binhunt automatically finding semantic differences in binary programs in proceedings of the 10th international conference on information and communications security ser.
icics .
berlin heidelberg springer v erlag oct. pp.
.
y .
david n. partush and e. yahav statistical similarity of binaries inproceedings of the 37th acm sigplan conference on programming language design and implementation ser.
pldi .
santa barbara ca usa association for computing machinery jun.
pp.
.
x. xu c. liu q. feng h. yin l. song and d. song neural networkbased graph embedding for cross platform binary code similaritydetection in proceedings of the acm sigsac conference on computer and communications security ser.
ccs .
dallas texas usa association for computing machinery oct. pp.
.
y .
li c. gu t. dullien o. vinyals and p .
kohli graph matching networks for learning the similarity of graph structured objects ininternational conference on machine learning.
pmlr may pp.
.
s. h. h. ding b. c. m. fung and p .
charland asm2v ec boosting static representation robustness for binary clone search against codeobfuscation and compiler optimization in ieee symposium on security and privacy sp may pp.
.
y .
duan x. li j. wang and h. yin deepbindiff learning programwide code representations for binary diffing in proceedings network and distributed system security symposium.
san diego ca internet society .
h. gao and h. huang deep attributed network embedding in proceedings of the 27th international joint conference on artificialintelligence ser.
ijcai .
stockholm sweden aaai press jul.
pp.
.
h. w. kuhn the hungarian method for the assignment problem naval research logistics quarterly vol.
no.
pp.
.
t. dullien graph based comparison of executable objects sstic symposium sur la securite des technologies de l information et descommunications rennes france june .
l. p .
cordella p .
foggia c. sansone and m. v ento a sub graph isomorphism algorithm for matching large graphs ieee transactions on pattern analysis and machine intelligence vol.
no.
pp.
oct. .
l. bahiense g. mani c b. piva and c. c. de souza the maximum common edge subgraph problem a polyhedral investigation discrete applied mathematics vol.
no.
pp.
dec. .
k. riesen structural pattern recognition with graph edit distance approximation algorithms and applications 1st ed.
springer publish ing company incorporated .
c. l. lin hardness of approximating graph transformation problem inproceedings of the 5th international symposium on algorithms and computation ser.
isaac .
berlin heidelberg springer v erlag aug. pp.
.
k. riesen and h. bunke approximate graph edit distance computation by means of bipartite graph matching image and vision computing vol.
no.
pp.
jun.
.
s. bougleux l. brun v .
carletti p .
foggia b. gazre and m. v ento graph edit distance as a quadratic assignment problem pattern recognition letters vol.
no.
c pp.
feb. .
g. n. lance and w. t. williams computer programs for hierarchical polythetic classification similarity analyses the computer journal vol.
no.
pp.
may .
r. e. burkard e. c ela p .
m. pardalos and l. s. pitsoulis the quadratic assignment problem in handbook of combinatorial optimization v olume1 d. z. du and p .
m. pardalos eds.
boston ma springer us pp.
.
r. singh j. xu and b. berger global alignment of multiple protein interaction networks with application to functional orthology detection proceedings of the national academy of sciences vol.
no.
pp.
sep. .
s. zhang and h. tong final fast attributed network alignment inproceedings of the 22nd acm sigkdd international conference on knowledge discovery and data mining ser.
kdd .
new y ork ny usa association for computing machinery aug. pp.
.
m. zaslavskiy f. bach and j. p .
v ert a path following algorithm for the graph matching problem ieee transactions on pattern analysis and machine intelligence vol.
no.
pp.
dec. .
v .
lyzinski d. e. fishkind m. fiori j. t. v ogelstein c. e. priebe and g. sapiro graph matching relax at y our own risk ieee transactions on pattern analysis and machine intelligence vol.
no.
pp.
jan. .
g. w. klau a new graph based method for pairwise global network alignment bmc bioinformatics vol.
no.
p. s59 jan. .
d. koller and n. friedman probabilistic graphical models principles and techniques adaptive computation and machine learning.
themit press .
a. m. khan d. f. gleich a. pothen and m. halappanavar a multithreaded algorithm for network alignment via approximate matching inproceedings of the international conference on high performance computing networking storage and analysis ser.
sc .
washington dc usa ieee computer society press nov. pp.
.
d. p .
bertsekas auction algorithms for network flow problems a tutorial introduction computational optimization and applications vol.
no.
pp.
oct. .