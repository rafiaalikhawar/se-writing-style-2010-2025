diffbase a differential factbase for effective software evolution management xiuheng wu nanyang technological university singapore xiuheng001 e.ntu.edu.sgchenguang zhu the university of texas at austin usa cgzhu utexas.eduyi li nanyang technological university singapore yi li ntu.edu.sg abstract numerous tools and techniques have been developed to extract and analyze information from software development artifacts.
yet there is a lack of effective method to process store and exchange information among different analyses.
in this paper we propose differential factbase a uniform exchangeable representation supporting efficient querying and manipulation based on the existing concept of program facts.
we consider program changes as firstclass objects which establish links between intra version facts of single program snapshots and provide insights on how certain artifacts evolve over time via inter version facts.
we implement a series of differential fact extractors supporting different programming languages and platforms and demonstrate with usage scenarios the benefits of adopting differential facts in supporting software evolution management.
ccs concepts software and its engineering software evolution software reverse engineering maintaining software software version control .
keywords software evolution reverse engineering program facts software maintenance.
acm reference format xiuheng wu chenguang zhu and yi li.
.
diffbase a differential factbase for effective software evolution management.
in proceedings of the 29th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse august athens greece.
acm new york ny usa pages.
.
.
introduction real software is seldom created all at once and changes are inevitable .
software developers often take advantage of the knowledge and insights they gain over time to repair enhance and optimize earlier versions of the system through incremental updates.
the software artifacts accumulated during the development permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse august athens greece association for computing machinery.
acm isbn .
.
.
.
have become crucial resources for understanding and analyzing software systems from an evolutionary point of view.
these include not only the source code written but also the by products produced such as code change histories log messages and test run results.
many tools and techniques have been developed to harvest useful information and use it to support different software evolution management tasks.
for example trends and patterns observed in the past changes can be used to estimate quality of new changes characterize architectural evolution optimize development process identify high level software functionalities and discover project specific api usage patterns as well as developer expertise .
these evolution management tasks require not only a clear understanding about each program version but also insights about the longitudinal evolution of program elements introduced by incremental changes.
such understanding and insights are now being produced by different analysis techniques and can potentially be shared and reused.
but there still does not exist an effective way to process store and exchange information among different analyses.
software configuration management systems scms such as git and svn are widely used in the development practices where incremental changes are manually grouped by developers to form commits a.k.a.
change sets .
yet the main goal of scms is to support development activities e.g.
recording examining and reverting changes rather than analysis tasks e.g.
inferring high level program properties from changes and establishing relationship among individual changes.
the information embedded in change sets goes beyond lines added and removed.
when combined with the understanding of language syntax and semantics much richer information can be obtained and analyzed about the evolution of software.
inspired by the program fact extraction techniques which generate facts about a single version of the software artifacts we propose differential facts a uniform representation of software changes consolidating relevant information across multiple versions of the same artifacts.
program facts can be any desired information about the software artifacts structural relations such as method ais contained in class c and semantic relations such as method ais called by another method b all could be considered facts.
differential facts go beyond just a single program version and consider program changes which highlight differences and linkage between multiple versions as first class objects.
fig.
is an illustration of the meta model of differential facts which demonstrate only a subset of the possible fact types.
these include the intra version facts capturing the containment calling and referencing relations between code entities at the same version there are also the inter version facts which include the code level insertion esec fse august athens greece xiuheng wu chenguang zhu and yi li callref containupdate insert delete new versionold version figure an example meta model of differential facts.
deletion and update changes between the old and new versions as well as the dependencies between commits.
the inter version facts are tightly connected to the intra version facts through common entity nodes making it possible to reason about facts across multiple versions.
for example we represent various types of differential facts in a common exchangeable format and store them in a differential factbase .
then by querying the factbase we could answer questions such as what are the functions whose bodies get changed but the signatures stay constant in an upgrade and what are the tests potentially be affected by this upgrade .
the differential factbase supports standard tarski relational algebra operations such as union intersection composition and transitive closure.
existing languages and tools such as jgrok can be used to query and manipulate facts.
to support more complex analysis tasks and ease the implementation of analysis scripts datalog is also supported so that one can also run inference on differential factbase using datalog engines such as souffl .
using differential facts to manage evolving software artifacts has several benefits.
first the factbase serves as an abstraction of the artifacts and their change histories.
it hides all the complex details of different programming languages as well as change representations and provides a unified queryable interface for downstream analyses.
second the differential facts produced during offline fact extraction can be shared and reused by many online analyses thus saving overall computation resources.
furthermore with the versioning information encoded differential facts support the lifting of analysis tasks from a single version to multiple versions and again improves analysis efficiency.
finally the fact extractors are relatively lightweight and built on top of existing tool chains.
for instance facts can be stored in any relational database for persistent storage and efficient processing.
we re implemented several software maintenance tasks with diffbase demonstrating its advantages in efficiency and interoperability.
these include a time cost reduction in semantic history slicing similar precision without safety violations compared with the state of the art static regression test selection tools and about time and space usage reduction in lifted pointer analysis.
contributions.
in this paper we make the following contributions.
we present differential facts a uniform exchangeable representation of incremental software changes supporting efficient querying manipulation and reuse.
we implement several differential fact extractors targeting different fact types programming languages and platforms.
the prototype tools are open source and additional results are available at the companion website id x n x v x v r del x v r v r x x v r upd x v x v figure types of atomic changes .
we apply differential facts in three evolution management tasks namely semantic history slicing change impact analysis andregression test selection .
we evaluate our approach on real open source software projects and demonstrate the benefits of adopting differential facts over existing techniques.
background this section introduces the necessary background and terminology.
.
program change histories a valid program pcan be parsed as an abstract syntax tree ast denoted by ast p .
formally r ast p is a rooted tree with a set of nodes v r .
the root of ris denoted by root r which represents the compilation unit i.e.
the program p. each entity node xhas an identifier and a value denoted by id x and x respectively.
in a valid ast the identifier for each node is unique e.g.
fully qualified names in java and the values are canonical textual representations of the corresponding entities.
we denote the parent of a node xbyparent x .
the children are unordered the ordering of child nodes is insignificant.
therefore each program has its unique ast representation.
let be the set of all asts.
now we define changes change sets and change histories as ast transformation operations.
definition atomic change .an atomic change operation is a partial function which transforms r producing a new astr such thatr r .
it can be either an insert delete or update see fig.
.
an insertion ins x n v y inserts a node xwith identifier nand valuevas a child of node y. a deletion del x removes node xfrom the ast.
an update upd x v replaces the value of node xwithv.
a change operation is applicable on an ast if its preconditions are met.
for example the insertion ins x n v y is applicable on rif and only ify v r .
insertion of an existing node is treated the same as an update.
definition change set .
letrandr be two asts.
a change set is a sequence of atomic changes 1 ... n such that r n 1 r r where is standard function composition.
a change set 1is applicable to rif 1is applicable torand 1is applicable to 1 r .
change sets between two asts can be computed by tree differencing algorithms .
definition change history .
a history of changes is a sequence of change sets i.e.
h 1 ... k .
.
program facts as typed graphs querying and analyzing program facts relations requires a specialized data structure and a set of operators to manipulate the facts.diffbase a differential factbase for effective software evolution management esec fse august athens greece c3attrb a g ab f b ycontain c2attrb a g ab f b y c1attrb a g ab f b y c0attrb a g ab f b ya x a xa h call refref a h ref b u a x b uinsert delete updateparentparentparent hunk figure a typed graph illustrating source code and changes between four consecutive versions.
now we define typed graph also known as edge colored graph which is a graph with a fixed number of edge types .
definition typed graph .lettbe a non empty set of types.
we say that a directed graph g v e t is a typed graph with vertex set vand edge set e v v t. we denote edges v1 v2 eby v1 v2 .
ahomogeneous typed graph gof type is a typed graph g v e whose edges are all the same type .
graphs in the classic graph theory are equivalent to homogeneous typed graphs and thus just special cases of typed graphs.
definition typed sub graph .
letg1 v1 e1 t1 be a typed graph.
g2 v2 e2 t2 is a typed sub graph of g1 denoted by g2 g1 if and only if v2 v1 e2 e1 andt2 t1.
definition type induced sub graph .
letg v e t be a typed graph and t t. we define the type induced sub graph of g denoted byg as the typed sub graph v e t ofgsuch that e v1 v2 t andv v v e or v e .
essentially each type of facts is represented using a separate edge type details discussed in sec.
.
.
example.
for instance a simple program with four versions are shown as a typed graph in fig.
.
more details including the textual differences between versions and associated facts of this same example are provided in sec.
.
.
each of the four rectangles indicates a version sub graph where solid arrows connecting code entities within rectangles are edges representing static dependencies and dashed arrows connecting code entities across different rectanglesa new a b a pointto a o1 assign a b figure example source code and its corresponding facts.
are edges representing atomic changes.
for example in the subgraph associated with c3 a h calls b f andreferences field a x .
member methods and fields are all contained within corresponding classes.
the circles positioned at the left of the rectangles are commit entities connected by commit dependency edges.
in this example the commit history is linear with c0being the oldest ancestor and c3hunk depends onc2 cf.
sec.
.
.
different sub graphs can interact by sharing common nodes.
for example a x is on edges of insert contain and ref types.
nodes and edges can have attributes too.
for instance the commit nodesciin fig.
are connected to each rectangle as attributes indicating the versions those program facts hold.
there could also be other purely informational attributes such as source code locations.
algebraic operators.
the list of operators for manipulating typed graph follow the classic tarski s relational calculus which include identity e0 inverse e basic set operations union e1 e2 intersection e1 e2 substraction e1 e2 composition e1 e2 transitive closure e and reflexive transitive closure e .
inspired by projection operator used in jgrok we use to denote this variant of composition operation which takes a set and a relation v e v2 v1 v v1 v2 e e v v1 v2 v v1 v2 e .
for producing a set vertices from a relation edges selecting columns by index is represented as e andistarts from .
.
datalog to provide inference capability on top of program facts i.e.
the ability to generate new facts based existing ones we may choose to represent typed graphs using datalog which is a declarative logic programming language with syntax similar to that of prolog.
datalog extends relational calculus with recursion and can be manipulated according to inference rules instead of low level relational algebra operations thus improving both usability and expressiveness.
two constructs in datalog are facts andrules .
rules are defined as horn clauses of predicates usually written in the following form.
r0 x1 x2 ... xk r1 y1 y2 ... ys ... rn z1 z2 ... zt .
whereriis a predicate and the arguments xi yi zi are variables or constants.
considering the existing ambiguity in datalog definitions the following concepts used in this paper are defined.
r1 a1 ... as is a fact if all of its arguments a1 ... as are constants.
as shown in fig.
a b o1on the right are constants representing the concrete source elements on the left o1is for the object allocated by new a .
predicates defined a priori by facts can only appear on the right hand side of rules which form schema of the extensional database or edb and those predicates are called edb predicates.
edb is defined as the set of facts of edb predicates.
predicates appeared on the left are defined by rules which form schema of intensional database or idb and those predicates are called idb predicates.
r0is an idb predicate.
idb is defined as the combination of a set of rules and facts of idb predicates.esec fse august athens greece xiuheng wu chenguang zhu and yi li 0scheme tuple 1upd prog prog 2del prog prog 3ins prog prog 5contain prog prog 6call prog prog 7ref prog prog 9coverage test prog 10hunk commit commit 11parent commit commit 13scheme attribute upd commit del commit ins commit a general fact schema.0scheme tuple inherit jprog prog inherit jclass jprog inherit jfunc jprog inherit jvar jprog inherit jctor jfunc inherit jmethod jfunc inherit jstaticmethod jmethod inherit jenum jclass 10contain jprog jprog 11call jfunc jfunc 12ref jprog jprog 13inherit jclass jclass b java extended schema.
figure fact schema written in ta language.
a datalog engine consumes edb and idb then produce instances of idb predicates according to the rules in idb.
program facts can be stored as datalog facts with each type induced sub graph representing facts of one predicate.
example.
in a simplified anderson style pointer analysis an assignment operation y xmarks all objects pointed to by xalso pointed to by y which is expressed by the following datalog rule pointto y z pointto x z assign x y .
here pointto andassign are idb and edb predicates respectively.
following the rule above and the two facts in fig.
a datalog engine can produce all facts of idb predicates i.e.
pointto a o1 andpointto b o1 .
differential facts in this section we first present the general schema framework for differential facts which applies to most of the languages and platforms.
we then describe the architecture of diffbase with various differential fact extractors and support for fact reusing in specific tasks.
finally we describe how analysis lifting is made possible by the application of differential facts.
.
general schema framework we construct the differential factbase as a typed graph with typed nodes.
this is to differentiate various types of entities in program facts.
let the set of all node types be tv.
then the fact schema is described by m tv tv t. similar to the relation declarations in datalog and the fact scheme in the ta language the fact schema describes the meta model of a differential factbase.
what follow are the fact instances which represent the edges of the graph following the rules described by the schema.
the rules can be explicitly written as v1 v2 e t v1 t v2 m wheret v is the type of the node v. fig.
5a shows the general schema for differential facts written in ta language.
the general schema only defines the core entities and generic entity relations which are not specific to any programming language or version control system.
the entity types prog commit andtest lines are defined to represent ast nodes commit objects and test cases respectively.
based on these entity types we define four classes of relations namely the static dependency coverage atomic changes and commit dependency .historyatomic changesstatic dependencycode coveragec c java more languagesgit reposource code multiple versions source code multiple versions static analyzer output dynamic coverage information factbase analysis scripts ... souffl grok query engine analysis results figure an overview of diffbase architecture.
letgbe the typed graph containing all differential facts.
each class of relations can be viewed as a type induced sub graph g g static dependency g g coverage g g atomic changes g g commit dependency g captures the dependency relations between prog namely call ref and contain with their standard semantics.
g captures the coverage relations between test and prog denoted by cov and the relation holds when a test run covers the given code entity.g captures three types of atomic changes namely ins upd and del.1finally g captures two types of dependencies between commits namely the hunk dependency and the history dependency denoted by hunk andparent respectively.
for instance there are history dependencies from a parent commit to all its children.
among those sub graphs commit dependencies and atomic changes lead to inter version facts while facts describing static dependencies and coverage information are intra version .
for intra version facts we designate the commit to which an atomic change belongs as an attribute of the corresponding fact.
the general schema can be extended for specific types of artifacts by adding new schema rules.
fig.
5b shows a simplified specific extension for java.
they key extension is a hierarchy of languagespecific types lines .
with those language specific types the typing information in relations can be refined lines and new relations can be added line .
for example parameters of call are now jfunc instead of the generic type prog and inherit is added to represent the inheritance relations between jclass types.
since facts we use are low level any structured data with a welldefined schema can be encoded and extended similarly.
examples include architecture diagram e r diagram and other uml models.
in this paper we focus on facts extracted from source code and commit histories.
.
extraction of differential facts the overall architecture of diffbase s fact extraction and query engine is shown in fig.
.
we implement diffbase as a general framework supporting different tasks with the help of multiple fact extractors and analysis scripts.
in practice diffbase can be integrated with ide and version control tools or services e.g.
github accumulating facts incrementally with the evolution of software.
1for readability and simplicity edge types will be used to represent edge sets of corresponding types when there is no ambiguity i.e.
insmeanse .diffbase a differential factbase for effective software evolution management esec fse august athens greece v0.
c3 c2 c1 c0 v0.1class b double u public const static int y static int f int x return x class a int x public int g return int g return b y class a int x public int h return b f x int g return b y ins b static int f int class b commit f992f4e ins b static int y class b commit f992f4e del b double u class b commit f992f4e upd a int g return b y commit 0c94630 ins a int x class a commit 0c94630 ins a int h class a commit bf574d7 figure example change history.
the rectangles at the top represent data sources including git repositories source code versions and coverage information obtained from test runs.
these are either raw inputs or easily derived by running existing tools such as compilers.
the rounded rectangles below represent basic facts extracted from corresponding data sources where the fact extraction processes are represented by incoming double arrows.
the factbase is where the basic facts are organized and stored and analysis scripts are executed to derive theanalysis results in the form of new facts.
to perform an empirical evaluation on the various applications of differential facts we implemented several fact extractors supporting different programming languages and platforms.
we developed inter version fact extractors for c c and java.
we replaced the c c back end of the ast differencing tool gumtree with our own ast emitter based on clang to ensure maximal compatibility.
the java version is implemented based on changedistiller .
we developed extractors for test coverage facts based on existing code coverage tools gcov for c c and jacoco code coverage library for java.
we used clangex and apache bcel to extract intra version static dependency facts for c c and java respectively.
we developed a languageneutral extractor for commit dependencies based on cslicer .
we built a tool for merging version annotated facts to support lifted analyses.
the implementation of these fact extractors is relatively simple thanks to the existing open source tools.
the support of new fact types and programming languages in the future is also straightforward.
facts are mainly stored in the format of tuple attribute files.
for example intra version dependency facts of each version are stored in a separate text file and each line represents a depends on relation between two program entities.
jgrok is used to query facts in ta language.
facts in the lifting experiments are represented in datalog where facts for each relation is stored in a separate file.
the datalog engine we used is souffl .
example.
to give a more detailed view on the typed graph model and inter version fact extraction from software change histories we provide a walk through of the example illustrated in the typed graph with textual differences and associated facts.
as shownin fig.
the short history includes changes on two simple classes a and b. there are four commits shown from c0toc3 among whichc0is the initial commit and its text diff is left out.
alongside the commit history represented by the line in the middle are unified diff and the corresponding differential facts.
in change set c1 a member declaration b u was removed replaced by another member b y and a member function b f was added.
according to defs.
and the changes can be described as a change set 1including three ast transformations del b u c0 ins b y c1 b static int y b ins b f c1 b static int f int return x b accordingly three facts reflecting the changes are produced as shown on the opposite sides of textual diffs in the figure.
code entities in facts are represented as a string containing entity names types other modifiers if exist and version numbers.
for simplicity c0 ... c 3are used instead of the commit hashes and attributes enclosed in brackets are written right below the relations they belong to to avoid duplication of relation texts.
each insoperation can be converted to an insert fact using the idfield as its second operand while the first operand is a special code entity denoted by null .
actual contents of the inserted entities defined as value are left out in facts.
meanwhile the parent node can be found with the help of intra version facts as shown in fig.
.
a delete fact can be deduced by using the only parameter of deloperation as its first operand while keeping the second one as null .
then inc2 a member declaration a x was inserted and the body of a g was changed.
2includes two atomic changes displayed as follows.
ins a x c2 a int x nil a upd a int g c1 return b y theupdate facts are also produced from the upd operations without the value and a string representation of the ast node names and the version information are used as the two operands.
finally inc3 a member function b h was added which calls b f and