verifying object construction martin kellogg u. of washington usa kelloggm cs.washington.edumanli ran uc riverside usa mran002 ucr.edumanu sridharan uc riverside usa manu cs.ucr.edu martin sch f amazon web services usa schaef amazon.commichael d. ernst u. of washington usa mernst cs.washington.edu abstract inobject orientedlanguages constructorsoftenhaveacombinationofrequiredandoptionalformalparameters.itistediousand inconvenientforprogrammerstowriteaconstructorbyhandfor each combination.
the multitude of constructors is error prone for clients andclientcodeisdifficulttoreadduetothelargenumberof constructorarguments.therefore programmersoftenusedesign patterns that enable more flexible object construction the builder pattern dependency injection or factory methods.
however thesedesignpatternscanbe tooflexible notallcombinations of logical parameters lead to the construction of wellformed objects.
when a client uses the builder pattern to construct anobject thecompilerdoesnotcheckthatavalidsetofvalueswas provided.
incorrect use of builders can lead to security vulnerabilities run time crashes and other problems.
this work shows how to statically verify uses of object construction such as the builder pattern.
using a simple specification language programmersspecifywhichcombinationsoflogicalarguments are permitted.
our compile time analysis detects client codethatmayconstructobjectsunsafely.ouranalysisisbasedona novelspecialcaseoftypestatechecking accumulationanalysis that modularlyreasonsaboutaccumulationsofmethodcalls.because accumulationanalysisdoesnotrequireprecisealiasinginformation for soundness our analysis scales to industrial programs.
we evaluated it on over million lines of code discovering defects which includedpreviously unknownsecurityvulnerabilitiesandpotentialnull pointerviolationsinheavily usedopen sourcecodebases.our analysis has a low false positive rate and low annotation burden.
our implementation and experimental data are publicly available.
ccs concepts software and its engineering software verification automatedstaticanalysis datatypesandstructures.keywords pluggabletypesystems amisniping builderpattern lightweight verification lombok autovalue permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation onthe firstpage.copyrights forcomponentsof thisworkowned byothersthan the author s mustbehonored.abstractingwithcreditispermitted.tocopyotherwise or republish topostonserversortoredistributetolists requirespriorspecificpermission and or a fee.
request permissions from permissions acm.org.
icse may seoul republic of korea copyright held by the owner author s .
publication rights licensed to acm.
acm isbn ... .
reference format martin kellogg manli ran manu sridharan martin sch f and michael d. ernst.
.verifyingobjectconstruction.in 42ndinternationalconference onsoftwareengineering icse may23 seoul republicofkorea.
acm newyork ny usa 12pages.
introduction this paper concerns verification of flexible object construction patterns in java like languages.
objects in such languages often have a combination of required and optional properties.
for example an api for a point might require xandyvalues with colorbeing optional.
it would be legal for a client to supply x y or x y color but not x color .
as another example a bibliographic entry for a book might require titleand either authororeditor.
ideally an object construction api should onlypermitclientstosupplypermittedsetsofvalues ensuring at compile time that only well formed objects can be created.
make code that constructs objects readable.
allowflexibilityinclientcode e.g.
re useofcommoninitialization code in different scenarios.
the standard api for java object construction contains one constructor for each combination of possible values that results in a well formedobject.thisapisatisfiesthefirstrequirement ifsome combination is nonsensical the api does not include the correspondingconstructor.forexample everyconstructorforapoint might require both an xand a yargument.
at a constructor call site invalidargumentcombinationsarerejectedbythecompiler.
however thisstrategyfailstheothertwocriteria.forreadability itisoftendifficultforclientstodeterminehowanobjectisbeing constructed from the constructor invocation particularly if multipleobjectpropertieshavethesametype.forcomplexclasses a constructorisneededforeverypossiblecombinationofoptional parameters leading to a combinatorial explosion in constructor definitions.
finally constructorsprovide littleflexibility asall parameters must be provided at once in a single call.
duetothesedrawbacksofconstructors alternatepatternsforobject construction have been devised such as the builder pattern.t o usethebuilderpattern theprogrammercreatesaseparate builder class which has two kinds of methods setters each of which provides a logical argument a value that ordinarily would be a constructor argument and afinalizer often named build which actually constructs the object and initializes its fields appropriately.
thebuilderpatterniseasyforclientstouse ataclientcallsite the name of each setter method that is invoked indicates what is being ieee acm 42nd international conference on software engineering icse set.thebuilderpatternavoidsthecombinatorialexplosionproblem of constructors since one method exists per parameter not per combination of parameters.
builders enable client code flexibility ascodethatcallsasubsetofsetterscanbeabstractedintomethods1.
popular frameworks like lombok and autovalue ease creation of builders by automatically generating a builder class from the class definition of the object to be constructed.
the builder pattern is important and widespread.
the builder pattern is one of the original design patterns in the seminal gang of four book .
it was already a common design pattern in smalltalk .open sourceprojectsthatautomaticallygenerate builder classes are popular lombok has stars on github and autovalue has .
the codebase of amazon web services has over uses of buildersin non test code and both the azure and aws sdks for java provide builder pattern like apis.
unfortunately usageofthebuilderpatternsacrificessomeofthe staticsafetyprovidedbyconstructors.aclientusingabuilderobject caninvokeanysubsetofthesettermethods.effectively thebuilder supports all 2npossible constructors.
not all such combinations are valid and a client can mistakenly use an illegal combination whichcanleadtoseriousproblems.section2.1describesasecurity concern associated with improperly configured requests submitted to a public aws api .
in other cases the builder finalizer method throws an exception if a client invokes an invalid combination of setters.
programmers and users!
find run time crashes from builders frustrating.
hence it would be highly desirable to have a tool that could statically verifybuilderusage i.e.
thatclientsonlycallvalidcombinationsof setter methods.
such a static verifier for correct usage of a builder objectbmust perform two tasks track which setter methods have been invoked on bat each program point.
whenb s finalizer is invoked ensure that all required setter methods have been invoked on b. typestate analysis may seem like a natural fit for verifying such a property as it is capable of tracking changes to object state acrossdifferentpr ogrampoints.however setterscanbeinvoked in any order and accommodating all orders causes a blowup in the finite state machine representation used by typestate analyses.
moreseriously typestateanalysiscanbedifficulttoscaletolarge programs as it relies heavily on precise alias analysis .
our key contribution is accumulation analysis a special case of typestateanalysisthatcanbeperformedmodularlywithoutanalias analysis.
verifying builder usage is an example of an accumulation analysis.anaccumulationanalysisisfreetoonlydopartialreasoning about aliasing or no reasoning at all.
ignored aliases can cause imprecision and false positive warnings but never unsoundness.
an accumulation analysis then can be expressed as a standard typesystem.weimplementedourverifier calledtheobjectconstruction checker as a pluggable type system that estimates which methods have been called on an object.
this formulation enables type based verification of the builder pattern which yields anumberof advantages includingscalability modularity andunderstandability.
as explained in section accumulation analysis is 1for example see the setcommonfields method in google gapic generator https tinyurl.com vhtyblwdescribeimagesrequest request new describeimagesrequest request.withfilters new filter name rhel .
hvm ga api.describeimages request figure vulnerable client code that does not properly construct a request to the describeimagesrequest api resulting in a potential ami sniping concern.
applicabletoproblemsbeyondthebuilderpattern suchasdependency injection and some instances of typestate.
this paper describes the design and implementation of our type systemandtheobjectconstructionchecker.flow sensitivetype refinement can usually determine which setters have been invoked on a builder object automatically without developer written annotations.
our system can express disjunctionsof required methods crucial for handling cases like the aws security vulnerability section .
.
we present a type based extension to our system that capturesaliasingcausedbythe fluentapi programmingstylefrequently used with builders where setter calls are chained e.g.
b.setx .sety ....build .forcommonframeworksthatgeneratebuilderclasses likelombokandautovalue ourtoolautomatically determines which logical arguments are required and which are optional further reducing the need for manual annotation.
our typechecker found security vulnerabilities with only false positives in over million lines of industrial and opensource code.
in open source case studies our typechecker found null pointerviolationsandpermittedthedeletionofhundredsof lines of manually written inflexible error prone builder code.
in a smalluserstudy usersfoundthetooldramaticallymoreusefuland usable than the state of the practice.
the contributions of our work are the identification of three real world problems stemming from unsafe object construction section accumulation analysis a special case of typestate analysis that can be checked soundly without precise section an accumulation analysis for reasoning about unsafe object construction section an implementation of that analysis for java section and an evaluation of the type system on the three problems presented in section section .
the paper concludes with a discussion of applications of accumulation analysis beyond the builder patterns section and a discussion of related work section .
unsafe object creation tomotivateourwork thissectionillustratesthreereal worldexamplesofunsafeobjectconstruction asecurityvulnerabilitycausedbyimproperuseofabuilderincodethatcallsanawsapi section2.
andbuggyusageoflombok generatedbuilders section2.
and autovalue generated builders section .
.
our approach soundly detects all the problems described in this section.
.
aws ami sniping aclientofacloudservicesprovidercancreatevirtualcomputers programmatically using the provider s public api.
an imageis the virtual computer s file system it includes an operating system and 1448package com.amazonaws.services.ec2.model public class describeimagesrequest public describeimagesrequest ... public describeimagesrequest withowners string... owners ... public describeimagesrequest withfilters filter... filters ... public describeimagesrequest withimageids string... imageids ... figure the describeimagesrequest api.
a client constructs a describeimagesrequest modifiesitviathe with methods thensends it to aws to obtain a machine image.
additional installedsoftware andso itdetermines whatcode runs on the virtual computer.
for example a client of amazon web services indicates what imagetouseviathe describeimagesrequest api liketheclientin fig.
.
this api requires clients to carefully create requests to avoid a potential operational security risk .
there are three safe ways to select which image to use when sending a request to the api use the withimageids method to specify a globally unique image id.
usethe withfilters methodtosetsomecriteria suchasthe name of the image its operating system etc.
anduse the withowners method to restrict the images searched to those owned by the requester or some other trusted party.
use the withfilters method to set criteria that restrict the imagetoonethatisownedbyatrustedpartyusingthe owner owner id owner alias or image id filters.
theunsafeexampleinfig.1usesthe name filterwithoutanowner filter which causes the api to return all the images that match the name.
this introduces the potential for a so called ami amazon machine image sniping attack in which a malicious third party intentionally creates a new image whose name collides with the desired image permitting the third party to surreptitiously inject their own code onto newly allocated machines.
any call that searches the public database without specifying some information thatanadversarycannotfakeispotentiallyvulnerabletoasniping attack and should be forbidden.
thevulnerabilityisanunsafeuseofthebuilderpattern.
describeimagesrequest is a builder the with methods are setters and the describeimages call is the finalizer.
because the compiler permits all combinations of method calls a client can accidentally fail to set the owner when setting the name as in fig.
.
misuse of the api must be prevented even though a client side coding concern is not ordinarily eligible for a cve .
revoking or changing the behavior of this widely used api incompatibly couldbeabreakingchangeforcustomers soaws sproposedmitigationisfor customerstofollowthebestpracticeandspecifyan owner .
an independent security researcher published instructions on how to detect if running virtual machines were impacted butagreedthatfollowingbestpracticeswasthebestavailablemitigation .
our sound static analysis is better it does not depend on programmers to remember to use the best practice.
builderpublic class useridentity private final nonnull string name private final nonnull string displayname private final nonnull bytearray id figure a class that has a builder.
the builder annotation causes lomboktogenerateabuilderatcompiletime.thisexampleissimplified code from the yubico java webauthn server project.
useridentity.builder .name username .displayname displayname .id generaterandom .build figure a client of the useridentity builder defined in fig.
from the same project.
this builder use will not cause a run time exception because all fields whose type is nonnull have been set.
.
lombok builders lombok is a widely used java code generation library that allows developers to avoid writing boilerplate code.
writing an builder annotationonclass cgeneratesabuilderclassfor c.a clientcreatesabuilderobject incrementallyaddsinformationto itbycallingsettermethodscorrespondingto c sfields andthen calls the finalizer method build to construct a cobject.
if some fieldsofchavetypesthatareannotatedas nonnull then build throws a null pointer exception if any such field has not been set.
acommoncauseoffrustrationforclientsofsuchlibrariesisthe addition of new nonnull fields.
for example consider an applicationdeveloperwhodependsonalibrarylikeyubico java webauthnserver2 which includes the class in fig.
.
figure is an example of suchcode fromjava webauthn server sincludeddemo.asdefined this code works correctly.
however suppose that a developer of java webauthn serveraddsanotherfieldto useridentity .ifthis field s type is annotated as nonnull then the code in fig.
will begintofail atruntime!
whenthelibrarydependencyisupdated.
even if this is caught during testing debugging the cause can still bepainfulbecausethebugwillmanifestasanull pointerexceptionintheunmodifiedclientcode.thesesortsofbugscouldbeavoided by checking at compile time that the setter for each field whose type is non null has been called before buildis called.
clients prefer compile time checking that mandatory fields are setonbuilders itisoneoflombok smostrequestedfeatures .
reinier zwitserloot leader of the lombok project says we get this feature request every other week a way tohave builder generatecodesuchthatthingsthataremandatory to set cause compile time errors if you forget to set them .
.
google autovalue autovalue is a java annotation processor that generates much of the boilerplate code for immutable java classes such as accessor methods for fields equals hashcode and tostring .
like lombok autovaluecanalsogeneratebuilderclasses which contain run time checks to ensure that when build is called on 1449thebuilder allrequiredpropertieshavebeenset.autovaluegeneratesbuildersasnewsubclassesofuser writtenabstractclasses whereas lombok directly adds the builder to user written code.
run time failures due to unset properties of autovalue builders lead to pain points similar to those described for lombok builders.
users desire a compile time check that required properties are set becauseincomplexcodethispropertycanbedifficulttotestfor .
further itcanbedifficulttodiscoverwhichpropertieshavedefault valuesandwhichneedtobesetbyaclient complicatingbuilder usage .
and library upgrades can lead to run time failures when properties in autovalue types become required.
modular accumulation analysis thissectiondescribeshowverifyingobjectconstructionisaninstanceofan accumulationanalysis aspecialcaseoftypestateanalysisthatcanbecomputedsoundlywithoutperformingaliasanalysis.
when a builder s finalizer is called every required logical argumentmusthavebeensuppliedtothebuilder.ouranalysismaintains acompile timeestimateofwhichargumentshavebeenprovided.
morespecifically ourimplementationestimateswhatmethodshave beencalledoneveryobject.thiscompile timeestimatecanonly increase.atacalltothefinalizer ifthereceiverobjectmightnot satisfy the finalizer s specification our tool issues an error.
a typestate system permits the type of an object to change as a result of operations in the program so it is a natural candidatefor expressing which logical arguments have been provided to abuilder.
for example in a typestate system a chess piece s typemight change from pawntoqueen or a file s type might change from unopenedfile toopenedfile toclosedfile .
fileoperations likeread are permitted only on an openedfile .
wedefineanaccumulationanalysisasaprogramanalysiswhere theanalysisabstractionisamonotonicallyincreasingset andsome operation is legal only when the set is large enough that is the estimatehasaccumulatedsufficientlymanyitems.accumulation analysisisaspecialcaseoftypestateanalysisinwhich theorder inwhichoperationsareperformeddoesnotaffectwhatissubsequentlylegal and theaccumulationdoesnotaddrestrictions thatis asmoreoperationsareperformed moreoperationsbecome legal.
forbuilders eachtypestatestandsforadifferentsetoflogical arguments that have been provided so far.
the finalizer operation ispermittedinalltypestateswhosesetisasupersetoftherequired logical arguments.
builders therefore satisfy the definition of accumulation analysis.
we have devised a modulartypestate analysis for the special caseofanaccumulationanalysis.anarbitrarytypestateanalysis requiresaliasanalysisforsoundness.supposethattwo openedfile