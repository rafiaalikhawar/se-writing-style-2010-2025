when apis are intentionally bypassed an exploratory study of api workarounds maxime lamothe and weiyi shang department of computer science and software engineering concordia university montreal canada max lam shang encs.concordia.ca abstract application programming interfaces apis have become ubiquitous in software development.
however external apis are not guaranteed to contain every desirable feature nor are they immune to software defects.
therefore api users will sometimes be faced with situations where a current api does not satisfy all of their requirements but migrating to another api is costly.
in these cases due to the lack of communication channels between api developers and users api users may intentionally bypass an existing api after inquiring into workarounds for their api problems with online communities.
this mechanism takes the api developer out of the conversation potentially leaving api defects unreported and desirable api features undiscovered.
in this paper we explore api workaround inquiries from api users on stack overflow.
we uncover general reasons why api users inquire about api workarounds and general solutions to api workaround requests.
furthermore using workaround implementations in stack overflow answers we develop three api workaround implementation patterns.
we identify instances of these patterns in real life open source projects and determine their value for api developers from their responses to feature requests based on the identified api workarounds.
acm reference format maxime lamothe and weiyi shang.
.
when apis are intentionally bypassed an exploratory study of api workarounds.
in 42nd international conference on software engineering icse may seoul republic of korea.
acm new york ny usa pages.
.
introduction as software applications increase in size and complexity application programming interfaces apis become an integral part of software development .
software is now often produced with help from a slew of apis to speed up development and reduce project overhead .
dependencies on general purpose frameworks and libraries have been shown to impact a large proportion of client project source code up to .
furthermore publicly available libraries are intricately interconnected.
for example the permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may seoul republic of korea association for computing machinery.
acm isbn .
.
.
.
repository contains over .
million reusable artifacts with over million dependency relationships .
this increased development speed comes at a price.
by relying on apis developers inevitably couple some of their functionality to apis over which they have little control .
this can be a challenge to developers as they are forced to deal with ever evolving apis .
difficulties with changing dependencies have led to terminology like dependency hell .
studies show that packages are updated within two months of their releases more than of the time while a sizable portion of api changes break backwards compatibility and have been found to impact of software that uses the apis .
for example the now infamous left pad incident broke thousands of libraries including react and babel due to the removal of lines of code from npm .
more importantly apis as software products themselves may suffer from typical software issues such as defects or missing features .
however due to the high cost associated with changing or migrating to a different api developers who use these apis api users ultimately suffer from api defects .
heavy dependence on apis has become a costly challenge for api users.
knowledge gaps exist between api developers and the api users .
often api developers only communicate about their apis through api documentation such as wikis manuals tutorials or api code examples which are only indirectly linked to the api .
on the other hand api users have limited access to api developers and few channels to communicate their feedback.
some apis even require knowledge of internal politics to reliably get patches accepted .
lacking a direct feedback channel from the api users can lead to situations where api developers must rely on repeated user complaints to become aware of an existing problem .
all too often when users have issues with an api for example needing a new feature or experiencing a run time problem users may choose to intentionally modify or bypass the api .
in this paper we define api workarounds as source code produced by api users without official support from api developers for the intentional modification or bypassing of official apis.
these workarounds allow api users to obtain their desired functionality quickly and without going through potentially arduous communication with api developers.
however the introduction of api workarounds presents a dilemma for api developers and users.
on the one hand since these workarounds are created by api users as temporary solutions many of these workarounds may become technical debt endangering code quality and increasing future maintenance cost .
on the other hand interestingly these api workarounds may become a vehicle for the api developers to gain ieee acm 42nd international conference on software engineering icse icse may seoul republic of korea maxime lamothe and weiyi shang feedbacks from api users in order to improve the apis e.g.
fixing defects in the api .
in this paper we conduct an exploratory study of api workarounds requested and implemented by api users.
to start our exploration we manually examine posts from stack overflow where we found that api users request api workarounds for a variety of reasons such as dependency issues missing functionality and runtime problems.
these reasons illustrate inherent value for api developers since gaining access to these workarounds could improve their apis.
furthermore we identified answers accepted by api users who request api workarounds.
by studying these answers we found that carrying out such api workarounds may not be a trivial task.
in particular a majority of api workaround solutions require special implementations to bypass the api.
to follow up on our exploratory study we study workaround implementations that are suggested in the stack overflow posts and we observe three generalized api workaround patterns.
the knowledge contained in the implementation of these patterns in api user projects can help api developers improve their api by adding desirable unsupported features fixing unexpected behavior and improving backwards compatibility.
since the three api workaround patterns were uncovered using forum questions and answers we seek to confirm their existence in real life api user code and confirm their usefulness with api developers.
therefore using five open source apis we detected these three patterns of api workarounds in open source github projects.
finally we submitted and observed feature requests to developers based on the api workarounds to improve the apis.
among these requests five are already closed and six more have been confirmed by api developers as defects or missing features.
our study and findings highlight the value of studying the usage of apis from api users as a means to bridge the gap between api developer and api users in order to assist in the development and maintenance of apis.
paper organization.
section provides real examples of api workarounds requested on stack overflow to motivate this study.
section contains a qualitative study on api workarounds.
section presents three generalized api workaround patterns extracted from api workaround implementations in stack overflow answers.
section presents an empirical study conducted to find and report instances of three api workaround patterns.
section provides a brief summary of related prior work.
section describes threats to the validity of this study.
finally section concludes the paper.
a motivating example in this section we present an example of api workaround inquiry on stack overflow.
figure presents a question stack overflow id in which the poster api user inquires about working around the roslyn api.
in particular the api user requires access to data that appears to exist in the roslyn api while such data cannot be externally accessed by the api users.
the api user provides a short example of their desired functionality and asks if this functionality already exists in the api.
the api user explains why they would like the feature and why they believe the feature should already exist as part of the api.
finally the api user provides a potential roslyn syntaxtree diff a sked3 years months ago active3 years months ago times viewed 2let s say i have two s and where has been produced by applying changes to .syn taxtree a b b a i would like to get the following information synta xnodes tokens that have been removed from to produce a b synta xnodes tokens that have been added to to produce a b is there an api for this?
if not how can this be efficiently computed?
this information must be available to roslyn since unchanged s are shared between the trees.
gre ennode o ne solution i can think of is to use and then lookup the intersecting tokens.
however that feels like a hack and i m not sure if it is always accurate.
a small text change might have a large impact on a e.g.
replacing with in an expression might change its order precedence syn taxtree getchangedspans syn taxtree syn taxdif fabst ract syntax tree r oslynr oslyn code analysisfea ture request proposed workaroundfigure an example of a developer requesting access to data that exists in the roslyn api but appears unaccessible 1w e that lives in the compiler layer and thus uses green nodes we just haven t exposed it as an api.
this is what we use to drive getchangedspans actually.
we didn t expose green nodes directly because that s an implementation detail.in ternally have a differ intentionally there s no specific reason that api couldn t be public.
i think when this one came around we were worried about how one actually specs what the behavior is or what s a minimal goodness you can expect from the diff.
that and we didn t have a motivating scenario to actually make sure our work was useful.c onfirmation that the feature is not available figure example of an api developer answering an api workaround request for data that exists in the roslyn api but appears unaccessible workaround solution to obtain the desired data but still expresses a desire for direct support from the api.
the accepted answer post presented in figure was provided by one of the api s developers.
therefore this post provides rare insight into a direct information exchange between an api user requesting an api workaround and an api developer.
the api developer confirms that as suspected by the api user the feature requested by the user is indeed available internally but was not exposed to the public since it can be considered an implementation detail.
the api developer claims that there is no specific reason for that api to be hidden.
the api developer also mentions that they could not think of a motivating scenario for this feature.
from this example we can see that scenarios of how apis are used by users may be unforeseen by api developers.
the effort needed and challenges encountered by api users to make api workarounds may not be trivial while the requested feature information may already exist internally in the api or require much less effort for api developers to accomplish than the api users.
api workarounds provide valuable information for api developers in order to understand the needs from the api users and to improve their apis.
this example shows that a disconnect can exist between api developers and users.
on the one hand users sometimes prefer to use public forums to request functionality rather than having direct communication with the api developers.
on the other hand not all api inquiries lead to responses from api developers who may miss these opportunities and fail to obtain outstanding sources of knowledge from their api users which they could use to improve their api.
therefore in this paper we explore api workarounds 913when apis are intentionally bypassed an exploratory study of api workarounds icse may seoul republic of korea and the knowledge that they contain starting by performing a qualitative study on stack overflow posts.
inquiries about api workarounds a qualitative study in this section we present a qualitative study on stack overflow posts where api users inquire about workarounds for apis.
more specifically we would like to uncover reasons why developers request api workarounds and their solutions.
.
collecting api workaround related posts as presented in section we know that there exist stack overflow posts that inquire about api workarounds.
example posts like the one presented in figure show that api users can request workarounds to request extra functionality.
meanwhile prior work has shown that api users can use workarounds to bypass api defects .
therefore there may exist multiple reasons for api users to seek api workarounds.
however the reasons why api users request workarounds have not been clearly established.
in this section we therefore seek to systematically determine the various reasons why api users request api workarounds.
furthermore we also seek to determine how api workaround requests are answered to determine whether all api workaround requests actually require api workarounds as answers.
to determine why api workarounds are requested and how these requests are answered we conduct a search on a stack overflow post dataset that was released on jun .
the dataset consists of over 40m stack overflow questions and answers.
there are over thousand posts in the stack overflow dataset that contain the keywords api library framework or interface .
therefore it is not feasible to manually search all stack overflow posts to discover api workaround posts some automation must be used to simplify the task.
an n gram classification approach was chosen for its comprehensibility and high classification rate .
we found that unigrams and bigrams that contained the words workaround or hack in our dataset were very rigid and produced limited results when compared to trigrams.
using unigrams and bigrams also provided too many posts unrelated to the topic at hand.
for example the word hack appears in many contexts unrelated to api workarounds this provides many false positives without the context provided by trigrams.
finally we settled on using trigrams after first attempting to use unigrams and bigrams unsuccessfully.
in order to obtain a manageable number of posts for manual examination we followed the process outlined below step preprocessing.
using the open source python natural language toolkit nltk we removed all punctuation and xml markup and made all strings lowercase.
we further preprocessed the data by removing all stop words e.g.
and or the using nltks predefined list of english stop words.
step topic filter.
we filtered out all posts that did not contain any one of the api library framework or interface keywords.
step trigram frequency.
using nltk we built a dataset of all trigrams found in our topic filtered dataset and ordered them by frequency of occurrence.step selection of relevant trigrams.
based on our list of frequent trigrams we manually selected trigrams that contained a logical leap to posts relevant to api workarounds and that had a frequency higher than one and contained the keywords workaround or hack .
step filter posts by trigram.
finally we collected all posts in the topic filtered list obtained in step that contained instances of the trigrams selected in step .
we manually selected trigrams in step for example workaround could use .
these trigrams were frequent and only accepted if they were logically sound to all of the authors1.
we obtained posts by using the filtration steps outlined above.
since the score of a stack overflow post is meant to be a marker of popularity and hence an indirect indicator of value to stack overflow users we chose to rank the posts by score.
finally we selected the top scoring posts as a subset to use for our manual study.
we chose to use top scoring posts instead of randomly selecting posts since high scoring posts are the most likely to have an impact on users and therefore give us insight on the types of api workaround questions and answers that users consider valuable.
we consider question and answer pairs as api workaround inquiries.
.
qualitative analysis of posts our goal is not to find the root causes of each of our selected stack overflow posts.
instead we aim to understand developers motivations when asking for api workarounds.
furthermore we also seek to understand what kind of answers are commonly accepted by api users.
therefore for each workaround related post we examine the title question post accepted answer or highest rated answer as well as any comments related to the question or answer.
investigating an api workaround post is a non trivial task since each post requires the investigator to understand the context considerations and concerns of the api users.
in order to reach a generalizable understanding of api workarounds we followed a systematic process to analyze each question and answer in our dataset.
we chose to use open card sorting a commonly used sorting practice that allows the sorting of posts into categories while also allowing the generation of the categories .
more specifically the authors of this paper performed the coding process defined below step deriving base coding.
a sample of posts of our final sample was selected at random and given to all of the authors to code to the best of their ability.
no particular constraints were set and codes could be added at will.
this step took a few days for the coders to finish.
step discussion after code derivation.
after the authors finished independently deriving their base codes a meeting was held to discuss coding conflicts and reach consensus on a base coding that could be used for the rest of the sample.
the meeting took one to two hours.
step refining post coding.
each author independently coded another posts after which we held another meeting to discuss disagreements and refine any coding misunderstandings.
coding 1a complete list of the trigrams used to filter posts can be found in our replication package 914icse may seoul republic of korea maxime lamothe and weiyi shang the posts took a few days for the coders to finish and the refinement meeting took about an hour.
step complete coding of posts.
using our refined coding each author independently coded the final posts and revisited their prior coding.
we measured our inter coder agreement see section .
after this step.
step resolve disagreements.
we discussed every conflict in the coding results until a consensus was reached for each disagreement.
conflicts were resolved by revisiting each issue together and discussing the reasoning behind each author s coding until a consensus could be reached.
conflicts were resolved in three one hour conflict resolution meetings.
to encourage the replication of our results and allow further studies related to api workarounds we have made our compiled stack overflow api workaround questions and answers data publicly available as part of a replication package.
.
measuring coder agreement in our qualitative study to ensure that the coding derived in section .
is reliable we must have a quantitative evaluation of reliability we chose to use intercoder agreement a metric that can be used as a measure of reliability for coding results .
coder agreement is important for trust and reproducibility.
low agreement may lead to non reproducible results.
we used krippendorff s to measure the inter coder agreement of our qualitative study since it is a general and standard reliability measure .
krippendorff s can be used to determine a quantitative agreement between coders of typically unstructured data .
krippendorff s provides a value between zero and one to indicate the observed disagreement between coders.
if coders agree perfectly then .
in the case where coders present an agreement equivalent to random chance then .
therefore reliable data is represented as an and should be far from .
krippendorff s takes the form of do de where the observed disagreement between coders and deis the disagreement expected by chance.
details related to the calculation of krippendorff s can be found in .
krippendorff s requires a single value to be assigned to each coded item .
since our coding schema allows posted answers to be simultaneously coded into multiple categories we must modify the way we calculate krippendorff s slightly.
we consider each category for each coded item as a separate coding unit.
coder agreement is then considered on a per unit basis which allows us to consider posts that have multiple coded categories.
.
qualitative study results a krippendorff s .
demonstrates reliable agreement .
as shown in table the krippendorff s for our question coding is .
and the krippendorff s for our answer coding is 2the total frequencies for categorized answers exceeds the total number of posts since posts can be placed into multiple categories e.g.
not supported use another api .table qualitative study reliability coefficient krippendorff s krippendorff s question categories coding .
answer categories coding .
.
.
therefore based on krippendorff s the results of our qualitative study are reliable.
the coding and categorization process described in section .
allowed us to determine four general api workaround question types and two general api workaround answer types used by api users on stack overflow.
.
.
why do api users ask for api workarounds?
through our manual evaluation of stack overflow posts we uncover and categorize reasons why api developers request api workarounds.
three of the four general api workaround question types contain more specific types.
all of the question categories are detailed below and examples for each category can be found in table .
help with api dependencies.
users sometimes seek help with api dependencies for example when two apis have dependency conflicts users might ask if a replacement exists or if there is a way to work around the conflict.
these inquiries can involve multiple libraries and build systems.
this category while infrequent could be used by api developers to determine potential compatibility problems.
missing desired functionality.
api users can have broad expectations for apis.
users sometimes expect apis to provide functionality that they believe should be provided by the api or that they have seen in other apis.
api users request three general types of functionality access to extra data or information missing data information new or missing features missing feature and they sometimes also request another interface to deal with more or fewer parameters missing interface .
missing desired features are the second most common question category in our dataset.
furthermore they appear to present common answer patterns when they require the implementation of a workaround.
requesting an improvement to the api.
api users do not always request new or missing functionality.
there are cases where users are aware of existing functionality but desire some improvements.
in some cases the improvement is functional like when a user requests an extension point for existing functionality.
in other cases the desired improvement is non functional like when a user requests better performance or improved security.
runtime problems while using the api.
runtime problems present the most common api workaround question category.
however most runtime problems express themselves as general unexpected behavior.
unexpected behavior is a broad category that spans from defects to ambiguous documentation.
unexpected behavior questions present themselves when a user experiences behavior that is unexpected to them and asks for a workaround to avoid the apis unexpected behavior.
any behavior that is unexpected by the api user falls into this category therefore it should be no surprise that user is confused answers are in response to unexpected behavior questions.
some runtime problems are more specific and can be narrowed down to backwards incompatibility.
api version 915when apis are intentionally bypassed an exploratory study of api workarounds icse may seoul republic of korea table categories of questions derived from stack overflow posts on api workarounds question type quote frequency help with api dependencies i m wanting to use the python amazon product api wrapper to access the amazon api unfortunately it relies on lxml which is not supported on google appengine.
missing desired functionality data information in .net framework we can use to get the system directory but that property does not exist in the current versions of .net standard or .net core.
is there a way to get that folder in a .net standard feature is there an equivalent to getlinenumber for streams in java ?
i want to search for a word in a textfile and return the line number as integer.
interface is this somehow not what the api is meant for?
anyone know a workaround or some kind of extra parameter s i could send to make it work?
requesting an improvement to the api functional is there a better way to do this?
i wish i could add my mock instances to the laravel ioc container and let it create the commands to test with everything properly set.
i m afraid my unit tests will break easily with newer laravel versions non functional but i m curious if anyone else knows of efficient way to to a bulk insert using ef code first?
runtime problems while using the api backwards incompatibility all this works great in mvc3 test again today it really works but it seems that the executecore in basecontroller is not fired any more in mvc beta.
unexpected behavior previously i have a set of google drive api code which works fine in the following scenarios few days ago i encounter scenario no longer work whereas other scenarios still work without problem.
unusable useless unrelated to api workarounds issues and the migration between api versions is a well known problem that has been studied extensively .
api workarounds contain valuable knowledge for api developers.
the workarounds indicate api users needs such as adding features accessing information and bypassing runtime problems.
.
.
how are api workaround inquiries answered?
through our manual evaluation of stack overflow posts we also uncover and categorize how api developers answer api workaround inquiries.
we observed three main categories of answers to api workaround questions.
these three main categories can be further divided into a total of eight api workaround answer categories.
the answer categories were manually determined as shown in section .
using the post selected as an answer by the original poster.
if no answer had been selected by the questions author we selected the highest scoring answer as the best answer.
furthermore the total frequency of answers is greater than since answer posts can fit into multiple answer categories.
already supported by the api.
.
of the useful answers we extracted suggested that the posted api workaround inquiry was already supported by the api in some way.
in most cases the user had to make a small adjustment to their implementation.
in cases the api could be used as is and addresses the inquiry without any modification.
finally in nine cases the inquiry could be answered by using the api but the user had to change their current implementation to fit the api requirements.
not currently supported by the api.
in most cases api user inquiries present a need that cannot currently be addressed with support from the api.
in such cases the api users will have to produce some extra code to implement a workaround.
suggestedworkarounds vary in scope but follow general patterns to add features access information and work around runtime problems.
in cases accepted answer posts suggest using another api to address the api user inquiry.
in some cases a solution to the inquiry is available or will be available soon but only in the form of an update or patch.
in cases the inquiry is simply not supported by the api by design.
finally in three cases an answer could be provided however the posted answer did not recommend using a workaround.
user is confused.
in cases we encountered answers that suggested that the user was either misusing an api or following bad practices that were hindering their progress.
as previously mentioned most of these users believed that they were experiencing unexpected behavior when in fact the behavior should have been expected given their misuse of an api.
.
.
unusable inquiries.
due to the nature of the heuristics we used to filter the stack overflow post dataset we expected some false positives to make it through.
therefore as part of our coding process we also categorized any posts we deemed to be unrelated to api workarounds as useless.
posts out of were ultimately identified as unrelated to api workarounds.
many of these posts were either asking for opinions on apis or focused on tools.
although these inquiries can be useful to the community we ultimately determined that they did not provide additional knowledge to help understand why api users seek workarounds or the kinds of workarounds they use.
furthermore since we separated the coding of questions from their answers this allowed us to consider the knowledge imparted by a question even if no answer existed at the time of our study cases .
916icse may seoul republic of korea maxime lamothe and weiyi shang table categories of answers derived from stack overflow posts on api workarounds answer type quote frequency already supported by the api change your current implementation i have found the solution.
i switched the direction of this mapping use api as is as others have said there s nothing wrong with using you will need small adjustments the simplest way is to just append to the end of your command not currently supported by the api need to implement a workaround one possible workaround is to write setter getter like methods that uses a singleton to save the variables or of course write a custom class not supported no solution the reason you can t do this is because it is specifically forbidden in the c language specification not recommended this is asserted as by design .
consider a post processing step that hacks the paths the way you want them.
use another api do you absolutely have to use java.util.date?
i would thoroughly recommend that you use joda time or the java.time package from java instead.
wait for apply new version patch i think you are experiencing a likely symptom of .
this bug exists in .
and higher and was only fixed recently .
.
user is confused don t hack something together using javascript as soon as twitter makes an update to their widget that s it you re screwed.
use a server side language and do it properly as per their documentation.
unusable no answer useless unrelated to api workarounds addressing the needs of api users often requires producing some extra code to implement a workaround.
the suggested workarounds vary in scope but follow general patterns.
patterns for implementing api workarounds section shows that a considerable number of api workarounds require extra implementation from the api users.
therefore we would like to identify workaround implementation patterns to show api developers how their apis are used in unexpected ways.
these patterns can then be used to inform the future api development decisions of api developers.
we read every post in the need to implement a workaround api answer category from table and found three generalized api workaround patterns.
the three patterns were manually determined by the authors from recurring similarities in workaround answers.
similar questions were amalgamated into the general patterns found in this section.
more patterns could likely be extracted from the data however our goal was not to extract every possible pattern but to conduct an exploratory study of likely api workarounds.
therefore we present three patterns that were manually developed based on real examples of api workaround requests by the authors of this paper.
these three patterns are not an exhaustive list of patterns that could be derived from our dataset.
for each workaround pattern we provide a description of the pattern the motivation of the api users that implement such a workaround and more importantly the benefit of knowing such patterns for api developers.
in addition we present a code example of each pattern presented in table .pattern functionality extension description this pattern presents itself when api users extends the existing behavior of an api to add functionality that does not currently exist as part of the api or to modify existing behavior to work as they desire.
example the example in table shows an extension of the hibernate orm api to support functionality for postgres databases that require an unquoted primary key column name.
standard behavior is therefore modified to unquote the identifier to work around the different behavior required by postgres.
motivation this pattern appears when users desire an unavailable functionality from an api.
this workaround pattern allows api users to circumvent existing functionality without removing or breaking any of the existing functionality.
this allows api users to keep all existing api functionality and have their desired workaround included as well.
detection strategy to detect this pattern we attempt to determine the frequency of api class extensions as well as the frequency of method overrides.
we can compare this data to a baseline of non extended api class invocations and non override api method invocations.
abstract classes should be ignored since they are designed to allow flexibility for the user to create whatever they want the intuition behind this pattern is that if a class or method is more often extended or overridden than it is invoked then the functionality of the class or method is not offered in the way most often desired by the api users.
therefore the data for this pattern should present cases of functionality improvements for api developers.
clone detection approaches can also be used to check if common functionality can be found between projects.
benefit to api developers instances of this pattern can present api developers with real scenarios for desirable features and hints to implement them without direct communication with users.
917when apis are intentionally bypassed an exploratory study of api workarounds icse may seoul republic of korea therefore api developers can use instances of this pattern to determine what desirable functionality is missing from their api.
pattern deep copy description this pattern presents itself when a user attempts to copy api data to use a copy locally rather than directly use the api functionality.
this can be done to add or modify functionality or to work around a software defect.
example the jackson api includes parsers for several data formats ex.
avro csv xml yaml .
however it does not contain a parser for bson or rison therefore users must create their own parser to support these data formats by providing a new interface that copies existing functionality but provides rison or bson compatible outputs.
the example presented in table shows a method that access existing information in the api modifies it and provides the information through the usual api.
motivation this pattern specifically looks at cases where a user wants to use the data provided by the api rather than the methods provided by the api.
in this pattern api users extract internal api information to add or modify api functionality in their application.
this allows the users to maintain complete control of the functionality in their application while relying only on the api s data.
detection strategy to detect this pattern in java applications we can look at the api fields and api getter method usage in github projects.
we believe that looking at fields and getters that are often called by api users can give insight into the usage patterns of these api users.
this insight coupled with an understanding of the api architecture can explain where new interfaces could be created.
we also look at classes that use a high number of distinct fields and getters to determine how and why users are using the api data.
benefit to api developers this pattern tells api developers that their api contains desirable data but that functionality to use this data is missing or defective.
therefore interfaces should be modified or added to provide desired functionality.
pattern multi version description this pattern manifests when api users attempt to use two or more versions of an api to work around a runtime problem e.g.
bug or introduce functionality found in separate api versions.
example the log4j and log4j2 apis allow the user to set logger context however some early versions of the log4j2 api experienced some issues with exception logging.
by using a classloader and a jar of log4j it was possible to dynamically load and use the log4j logger context to circumvent exception logging issues experienced by log4j2.
this is presented in the example in table motivation many workarounds are requested to deal with defects in apis we found a wide range of solutions for this problem in our stack overflow dataset.
however we found some cases where users are encouraged to use an older or newer version of the api to resolve an issue i.e.
bug .
detection strategy to detect this pattern we can attempt to determine when users are attempting to use two or more versions of an api in a given project.
in the case of java it is not possible 3this problem has since been resolved in log4j2 however one of the user projects we encountered still maintains a workaround for this issue for unknown reasons.to statically load two versions of the same library since the class paths would conflict.
however it is possible to dynamically load two or more jar files using class loaders at runtime and then use the functionality from any or all of the loaded jars as desired.
we can therefore attempt to determine instances of this pattern by detecting when a given class or method shows support for more than one version of an api.
by storing various versions of each library in jar format and by looking at all api method invocations for each project we can determine multiple version usage.
most apis keep functionality the same across multiple versions however some apis will change.
therefore if we detect that a method invocation maps to a specific api version but the rest of the project maps to different api versions we can flag this api method invocation as suspicious.
benefit to api developers using a different version of an api is also sometimes suggested as a solution for missing desired functionality that existed in an older version of an api.
therefore api developers can use instances of this pattern to detect potential defects and their solutions as well as desirable functionality directly from user projects.
reporting real life api workarounds to developers in this section we present a study conducted to detect the existence of api workaround patterns in real life projects that use the apis.
furthermore we discuss the results of our study and the api developer responses to the reported patterns.
.
identifying api workarounds in real life projects since our generalized api workaround patterns are based on data collected from stack overflow we do not have direct evidence that these patterns can readily be found in real life software projects.
therefore we produce an experiment to confirm the existence of these patterns in open source projects.
our detection strategies rely on parsing api source code and extracting binding information for fields methods and classes in the api with the help of the java abstract syntax tree parser and symbolic link resolver javaparser .
once an api has been parsed any number of user projects can be targeted to detect the occurrence of workaround patterns inside those projects.
if a workaround pattern is detected we manually observe the identified candidate and report the candidate as a possible improvement to api developers.
.
.
subject apis.
we selected five open source apis all of which have their source code available on github and compiled jars available in maven repositories.
we selected apis programmed in java to limit the scope of our experiments.
however it should be noted that our generalized patterns are language agnostic and were generalized from stack overflow posts without filtering by programming language.
all of the chosen apis are popular open source apis that have been used by hundreds of public github projects.
the popularity of the apis allows us to obtain varied uses of the apis.
918icse may seoul republic of korea maxime lamothe and weiyi shang table api workaround patterns and corresponding examples pattern name example functionality extension deep copy k eep interface the same but modify existing information multi version url for log4j config dy namically set load log4j config rather than use current log4j2 config the code presented in this table has been edited due to space constraints.
919when apis are intentionally bypassed an exploratory study of api workarounds icse may seoul republic of korea guava user projects google s guava api is an open source set of commonly used java libraries.
the api includes apis for concurrency primitives hashing and many other functionalities .
prior research on github projects has shown that google guava was the 8th most popular java library in .
we targeted different versions of the guava api from version .0to version .
.
hibernate user projects hibernate is a free and open source framework that provides mapping from java classes to database tables as well as abstracted data querying .
we targeted all of the minor releases of the hibernate api that were available on the maven central repository from version .
.2to version .
.
.
jackson user projects the jackson core is an open source java api that provides a json parser generator with other data encodings such as csv xml yaml and more .
we targeted all of the minor releases of the jackson api that were available on the maven central repository from version .
.6to version .
.
.
junit user projects junit is an open source unit testing framework for java .
prior research on github projects has shown that junit was the most popular java library in .
we targeted different versions of the junit api from version .
to version .
.
log4j user projects apache log4j is an open source java logging framework .
as of the writing of this paper over maven artifacts have the apache log4j core as a direct dependency .
we targeted different versions of the log4j api from version .
.1to2.
.
.
.
.
api user projects.
the api user projects chosen for this paper were all open source projects hosted on github and selected based on their use of the five java apis we selected.
we first searched all of github for readme files that mention the name of our target apis.
there is no current tagging system on github to search for apis used by github projects.
therefore we rely on heuristics to determine if a project uses one of our five target apis.
we found that if a project readme mentions an api by name it is likely that the project will in turn use this api.
furthermore we used project stars as a metric for popularity of a project.
although github stars are not an indication of quality it is an indirect measure of popularity.
if a project is more popular it is possible that it will have a larger impact and the information obtained from examining this project should therefore be more important to api developers.
the minimum project size was set at 5mb in order to reduce the number of dummy projects that might contain no code.
using these filtration criteria we either selected all of the projects that met our criteria or the top starred projects for each target api whichever came first.
the number of projects used for each of our selected apis can be found in section .
.
.
each of these projects was used to attempt to map binding information obtained from the api source code to api uses in the user projects.
furthermore we also used the jars for each api to determine version specific binding information.
we applied our pattern detection strategies to determine if one or more of our three patterns are present in a user project.
.
.
detecting patterns.
to help detect the api workaround patterns presented in section we produced research scripts and prototype tools based on the detection strategies presented in section .
the prototype tools and scripts used to aid with pattern detection are publicly available4.
since api developers are most likely to be interested in active api workarounds we concentrate on the latest releases of api user projects.
by using the latest releases of user projects we can keep our results relevant to api developers circumvent a number of build problems related to older versions and reduce the pattern detection time.
furthermore since javaparser does not require building projects to obtain an ast or to build symbolic links we can parse api user projects without the need to worry about build issues .
as a first detection step we leverage javaparser to extract api class names api method declarations api field declarations and specific api methods that contain the keyword get .
this information can later be used to map api declarations to api user invocations by further leveraging javaparser to obtain code bindings in user projects.
functionality extension to detect the functionality extension pattern we use the binding information obtained through javaparser to extract all api method overrides api method invocations api class extensions and api class invocations for all of the api user projects in our sample.
we then build a frequency map of all of these to determine which classes are more often extended rather than invoked and which methods are most often overridden rather than invoked.
based on this data we observe the items with the highest extend invoke and override invoke ratios.
deep copy to detect the deep copy pattern we use javaparser to extract api field invocations and api getter method invocations from api user projects.
we keep track of how many of these items are invoked in a given api user class and the global invocation patterns across all api user applications.
we then consider api user classes that use the most api field and api getter invocations as potential deep copy candidates.
multi version we conduct heuristic analysis on the jar releases of our target apis to determine links between target apis and api user applications.
by using these links we can heuristically determine which api versions are compatible with a given user application.
through the heuristically determined links between api jars and api user applications we can determine which user applications would require more than one version of an api to support all of their api calls.
using this information we can flag api user applications that require multiple versions of an api.
using our detection strategies we produced lists of api user code instances that were likely to contain api workaround patterns.
we manually verified the top most likely workaround candidates for each api for each pattern giving us a total of manually verified potential api workaround pattern instances.
any candidate deemed an api workaround instance after manual verification was reformulated by the authors as an api feature request and sent to api developers either through github or their forums.
we detect api workaround patterns in api user applications of varied maturity without knowing which version of the api is used a priory.
therefore we do not originally know if any of the workarounds we find in user applications have since been used as actual improvements and bug fixes in more recent versions of the api.
if 920icse may seoul republic of korea maxime lamothe and weiyi shang we detect a workaround in an old user project and later determine that the workaround has been integrated into the api we therefore consider this an indication that api developers could benefit from knowledge of api user workarounds.
.
results and discussion in this section we breakdown our manual observations of potential api workarounds that were detected using automated approaches.
we first manually examine all the instances to confirm whether they are indeed correspond to workarounds.
we find that out of the instances are true instances of workarounds.
we manually check the reasons of the instances that are detected by our patterns but not workarounds.
we find that there is a single non workaround instance of functionality extension pattern.
the pattern instance was a custom extension of a hibernate exception and therefore considered normal usage of the api.
we find nonworkaround deep copy pattern instances that were exclusively for jackson and junit.
in those instances the top fields and getters copied by api users to ease their testing code i.e.
junit.
finally all of the detected instances of multi version patterns belong to junit guava and log4j since the hibernate and jackson apis did not present any instances of the pattern.
however the majority out of of our multi version pattern instances appear to be defensive coding rather than pure workarounds.
to avoid requesting too much information from the developers of the studied subjects we strategically pick manually verified true instances to submit feature requests.
in particular we concentrate on more complex functionality addition or modification and defect workarounds that could clearly be discerned by the authors.
.
.
functionality extension during our manual observation we were able to extract nine functionality extension api workarounds from the selected user systems.
by searching through forums and patch notes we were able to find that three of the functionality extensions did not exist in the apis when the user projects created workarounds but they had already been incorporated into the apis when we searched their forums.
this confirms that our patterns are indeed detecting functionality that was missing from the apis.
in two cases we were able to find currently existing pull requests that are in the process of being integrated into the apis.
for example pull requests are in discussion for sqlite support in hibernate and users have posted that they would love to see official sqlite support in hibernate .
therefore in five cases desired functionality had been deemed valuable by api developers and was either integrated into the apis or is currently in the process of being added.
in two cases we found two existing but unfulfilled feature request posts in the api forums or on stack overflow.
in one case a stack overflow post post id details the unexpected behavior and the desire for this feature.
this shows a real user desire for this feature.
however the feature has still not been added.
in two cases we created feature requests for missing functionality.
as of the writing of this paper one feature request is in the apis feature request queue.
the other feature has been acknowledged by the api developers as desirable by users but they do not have the resources to maintain that functionality at this time.
.
.
deep copy we were able to extract two interesting deep copy api workarounds from our dataset.
we created feature requests for new functionality to improve the apis.
we received positive responses to the functionality that was proposed.
when we requested a bson format addition one api developer replied that they did not want to support the functionality but that bson backed streaming api implementation makes sense dataformat module this is what is used to support dozen other formats.
.
furthermore they pointed us in the direction of an existing third party package that could supply this functionality.
this shows that the functionality was indeed desirable enough for someone to create a third party library for it.
this therefore confirms that the detected workaround pattern contained functionality that was not provided by the api.
furthermore the third party library with this functionality shows the value of our reported workaround functionality.
.
.
multi version we were able to find cases where multiple versions of apis were used.
however only one case was providing a workaround for missing functionality.
we examined this case in detail and found that an issue did exist with the api.
however the issue had been fixed by a patch soon after the issue was introduced.
the fix shows that workarounds would potentially assist developers in identifying problems with their apis used in real life by api users.
in the other cases after careful examination of the api user code and documentation we were able to determine that api users sometimes code defensively to allow their users to use a wide range of compatible libraries.
in those cases api users will have a direct dependency on a specific version on an api which they will bundle with their project.
however they will in turn allow their users to use a range of different api versions which will be dynamically loaded and override default behavior to provide compatibility with newer api versions.
if api developers had knowledge on which api combinations users most often employ this could direct their testing efforts to maintain compatibility between api versions.
.
.
unnecessary workarounds user code can sometimes present an api workaround pattern with code that simply emulates existing functionality.
we found three instances of user code that presented as workaround patterns but could have been implemented using existing api functionality.
in these cases perhaps a lack of understanding of the apis functionality by the api users is at fault.
this could be mitigated by improving api documentation and examples.
api developers can use this information to efficiently spend time on apis that have documentation issues and generate examples specifically for those apis.
based on the responses to api workaround feature requests both already existing and those we created we can confirm that api workaround patterns detected in api user projects can provide valuable knowledge to api developers5.
furthermore we can confirm that the three patterns presented in section of this paper do exist in api user projects and that they are used to provide missing functionality and work around unexpected behavior.
5a list of detected patterns and feature requests is available in our replication package.
921when apis are intentionally bypassed an exploratory study of api workarounds icse may seoul republic of korea related work in this section we discuss related research in the field of apis.
we specifically concentrate on prior work based on api usage patterns api misuse and using stack overflow as an api resource.
api usage.
api usage patterns have been used in prior work to understand how apis evolve to detect api compatibility issues for api migration code recommendation and more.
in this paper we specifically concentrate on usage that would not typically be expected from api developers i.e.
workarounds .
api usage patterns can be extracted from source code but they can also be extracted from code examples .
in this paper we use a mixture of both approaches by extracting and generalizing the usage of three api workaround patterns from code examples taken from stack overflow to later detect instance of these patterns in source code.
api misuse.
api misuses can be characterized by their violation of an apis constraints .
misusing apis can lead to an increase in software security vulnerabilities and bugs .
prior work has concentrated on identifying and detecting api misuses .
api misuse detection tools often rely on frequent usage patterns to detect api uses that deviate from the norm but they can also rely on mutation analysis .
the api workaround inquiries and patterns deliberated in this paper are instances of unconventional api usage.
api users sometimes seek to modify or work around the current implementation of an api.
this paper concentrates on constructive workarounds that could be seen as improvements to the api.
however there exist non constructive ways to use apis.
these usage patterns are known as api misuses.
api misuses can be considered as unintentional alternate uses of apis meanwhile api workarounds are intentional alternate uses of apis.
stack overflow as an api resource.
stack overflow has been used as a source of information for several prior works on apis .
stack overflow has been used for api topics such as how api changes trigger discussions improving api documentation understanding the concerns of developers api recommendation indexing api information and api deprecation .
however stack overflow is not the only online community that has been used as a source of data for api research.
other forums have also been used to develop tools that could find negative developer sentiments and highlight search and estimate api hot topics .
online forums have also been used to develop automatic code critics that can inform api users of api usage rules and support api usage .
we similarly use online information from stack overflow to understand how developers use apis.
however our work differs in scope since we wish to understand how and why api users seek to work around missing or problematic api functionality.
we then use this information to generate api workaround patterns that can be used by api developers to search for new and desired features to add to their api.
threats to validity construct validity.
we do not claim to have found all inquiries pertaining to api workarounds.
however we believe that the sample collected is adequate to produce an exploratory study into theproblem at hand.
although we diligently attempted to confirm the detected instances of implementation patterns for api workarounds by searching application documentation and online forums and we reported issues to api developers it is still possible that the patterns detected in user applications were misidentified as api workarounds.
we do not claim to be experts for any of the user applications studied nor for any of the apis selected.
we do not claim to have found or reported all existing workarounds in the studied systems.
however investigations into the instances detected appears to confirm the existence and usefulness of the patterns.
future empirical and user studies can be done to complement our study and may bring additional insight to our results.
external validity.
since the api workaround pattern instances in this study were detected in java apis it is possible that the findings in this paper do not generalize to other programming languages.
however while the strategies presented in this paper were tested on five java apis the strategies were developed based on language agnostic stack overflow posts and should therefore apply to a range of programming languages e.g.
c .
internal validity.
the api workaround inquiry categories and patterns presented in this paper might not be fully indicative of api workarounds and instead reflect internal bias.
we attempted to mitigate these threats by having the authors of this paper independently label and reach a consensus on the categorization of stack overflow posts and the implementation patterns extracted from these posts.
our manual observation of stack overflow posts may also present internal bias future studies involving more posts can complement our results.
however we reported api workaround patterns to api developers and received feedback that suggests that the workarounds we detected are actual workarounds and should be considered valuable for future fixes or extensions to the apis.
conclusion in this paper we conduct an exploratory study on api workarounds.
by studying inquiries from stack overflow we find that api users seek api workarounds to add desired functionality improve apis and resolve unexpected api behavior.
furthermore we show that many api workarounds require extra code from api users to implement workarounds.
using workaround implementations suggested in stack overflow answers we extract three generalized api workaround patterns that are implemented by api users to deal with missing api features and unexpected api behavior.
we find real life examples of these patterns in open source projects and report instances of these patterns to api developers.
without our findings these patterns might be misidentified as general development and developers might ignore their unique characteristics.
we find that api developers consider these workaround instances as real issues and either add them to their issue tracker or encourage pull requests to remedy them.
our paper makes the following contributions to the best of our knowledge we are the first to study inquiries that concern api workarounds.
we introduce and confirm the existence of three general implementation patterns for api workarounds.
we determine the usefulness of these patterns to practitioners through their adoption into api code bases.
922icse may seoul republic of korea maxime lamothe and weiyi shang