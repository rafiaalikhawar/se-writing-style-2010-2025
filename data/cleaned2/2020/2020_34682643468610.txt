heterofuzz fuzz testing to detect platform dependent divergence for heterogeneous applications qian zhang university of california los angeles usa zhangqian cs.ucla.edujiyuan wang university of california los angeles usa wangjiyuan g.ucla.edumiryung kim university of california los angeles usa miryung cs.ucla.edu abstract as specialized hardware accelerators like fpgas become a prominent part of the current computing landscape software applications are increasingly constructed to leverage heterogeneous architectures.
such a trend is already happening in the domain of machine learning and internet of things iot systems built on edge devices.
yet debugging and testing methods for heterogeneous applications are currently lacking.
these applications may look similar to regular c c code but include hardware synthesis details in terms of preprocessor directives.
therefore their behavior under heterogeneous architectures may diverge significantly from cpu due to hardware synthesis details.
further the compilation and hardware simulation cycle takes an enormous amount of time prohibiting frequent invocations required for fuzz testing.
we propose a novel fuzz testing technique called heterofuzz designed to specifically target heterogeneous applications and to detect platform dependent divergence.
the key essence of heterofuzz is that it uses a three pronged approach to reduce the long latency of repetitively invoking a hardware simulator on a heterogeneous application.
first in addition to monitoring code coverage as a fuzzing guidance mechanism we analyze synthesis pragmas in kernel code and monitor accelerator relevant value spectra.
second we design dynamic probabilistic mutations to increase the chance of hitting divergent behavior under different platforms.
third we memorize the boundaries of seen kernel inputs and skip hls simulator invocation if it can expose only redundant divergent behavior.
we evaluate heterofuzz on seven real world heterogeneous applications with fpga kernels.
heterofuzz is 754x faster in exposing the same set of distinct divergence symptoms than naive fuzzing.
probabilistic mutations contribute to .5x speed up than the one without.
selective invocation of hls simulation contributes to .8x speed up than the one without.
ccs concepts software and its engineering software testing and debugging computer systems organization heterogeneous.
esec fse august athens greece copyright held by the owner author s .
acm isbn .
fuzz testing heterogeneous applications platform dependent divergence acm reference format qian zhang jiyuan wang and miryung kim.
.
heterofuzz fuzz testing to detect platform dependent divergence for heterogeneous applications.
inproceedings of the 29th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse august athens greece.
acm new york ny usa 13pages.
introduction there is a growing interest in computer architectures to incorporate heterogeneity and specialization to improve performance .
fpga is re programmable hardware that often exceeds the performance of general purpose cpus by several orders of magnitude and offers lower cost across a wide variety of domains .
to support heterogeneous computing hardware vendors provide cpu fpga multi chip packages such as intel xeon and cloud providers support virtual machines with fpga development frameworks such as amazon f1 .
in the context of this paper we use a term heterogeneous applications to refer to software that consists of both hostcode and kernel code and can offload its computation intensive kernel from cpu to fpga under heterogeneous architectures.
platform dependent divergence.
although fpgas are becoming commercially available to a broad user base they are associated with a high development cost .
there has been work on highlevel synthesis hls which takes c c kernel code as input and automatically synthesizes a corresponding fpga accelerator.
with hls programmers can implement their heterogeneous applications in c c however such c c programs can produce different results on heterogeneous architectures compared to cpu due to various platform dependent characteristics bitwidth available resources memory access recursion depth dataflow mode etc.
for example because an optimized fpga kernel uses a custom bitwidth for integers and floating points it could lead to overflows on fpga.
thus detecting platform dependent divergent behavior is important because even when the application runs correctly on cpu it could still crash or produce a wrong output silently when the kernel is executed on the fpga accelerator .
in fact our investigation of xilinx s forum a popular online q a forum for fpga hls development shows numerous examples of such platform dependent divergence.
table 1illustrates several such examples .
programmers ask why is there a difference between c code rtl simulation and the hardware test runs?
.
in this 242this work is licensed under a creative commons attribution noncommercial international .
license.
esec fse august athens greece qian zhang jiyuan wang and miryung kim table examples of behavior divergence between cpu and fpga id description time segmentation fault when allocating a big array int x on fpga yet no error on cpu .5h different outcome caused by hls dataflow directive .7h different outcome caused by fpga fetching incorrect struct vector training set .6h different outcome caused by bitwidth typedef ap fixed ap rnd s25f24 type .3h getting all zeros when shifting an array caused by pragma hls reset .1h undecided output when overwriting a same variable within the loop yet no error on cpu .4h emfile error when loading files with pragma hls array partition yet no error on cpu .7h the tap fir filter bypassess some input multiplications with pragma hls pipeline .2h post due to limited stack size running an image processing application with hls simulation leads to a segmentation fault but no such error happens on the cpu linux platform.
though this programmer expressed a desire to test this platform dependent divergence no tool exists to meet such needs.
current practices of testing heterogeneous applications.
in practice programmers often execute heterogeneous applications with a given input set on cpu and then compare against the results on heterogeneous architectures.
however where do such inputs come from ?
the most common sources include test inputs handcrafted by an fpga expert randomly generated tests by a data generator widely used in hardware accelerator industry and systematically enumerated inputs .
unfortunately these sources of inputs are unlikely to account for platform characteristics and thus are inefficient in revealing behavior divergence between fpga and cpu.
in recent years fuzz testing has emerged as an effective test generation technique for large software systems .
most fuzzing techniques such as afl start from a seed input generate new inputs by mutating the previous input and add new inputs to the queue if they improve a given guidance metric such as branch coverage.
they are also based on two inherent yet oversighted assumptions it takes a minuscule amount of time in the order of milliseconds to execute a target application and arbitrary mutations are likely to yield meaningful inputs.
our experience suggests that neither of the two assumptions holds for heterogeneous applications.
compilation and hardware simulation takes several minutes even hours not milliseconds and random mutations cannot account for hardware synthesis assumptions crucial for detecting platform dependent behavior.
as shown in table we estimate an afl like technique that repetitively invokes an hls simulator would require at least .
hours to generate an input to detect the same error from the post .
our three pronged approach to reduce the long latency of naive fuzzing.
heterofuzz targets testing of heterogeneous applications with the goal of generating inputs to demonstrate divergent behavior between cpu and fpga.
our key insight is three folds first different from traditional fuzzing whose guidance mechanism is driven by code coverage or performance metrics only heterofuzz directly analyzes synthesis pragmas from kernel code and monitors accelerator relevant value spectra e.g.
bitwidth memory access recursion depth loop bound and fifo queue size.
any input that achieves either new code coverage or increases accelerator value spectra feedback are saved for further mutation.
for example heterofuzz can detect platform dependent errors from the two posts in table within only six minutes by monitoring the fullness of a fifo queue and the ranges of variable values.second we design dynamic probabilistic mutations to increase the chance of exposing platform dependent behavior.
heterofuzz gradually increases the activation probability of the current mutation if a new accelerator value spectrum is achieved.
for example when a programmer uses typedef ap uint x bitx to declare a custom integer type with xbits we instrument the kernel code to monitor how many bits have been actually used.
if a particular mutation leads to a new bitwidth range we label this mutation as a favored mutation and increase its activation probability.
third we reduce the long latency involved in the repetitive invocation of a hardware simulator.
heterofuzz memorizes the boundary values of seen kernel inputs and selectively invokes a hardware simulator only if the current input goes beyond the previously seen range.
this is based on the insight that accelerator synthesis is determined and optimized by kernel input values and multiple invocations within the already seen range may only expose redundant divergence behavior of the same kind.
we evaluate heterofuzz s effectiveness on seven publicly available heterogeneous applications with fpga kernels .
we compare heterofuzz against four alternatives heterofuzz without accelerator spectra monitoring heterofuzz without probabilistic mutations heterofuzz without selective invocation and na ve fuzzing where we estimate the time based on the number of invocations to an hls simulator.
we measure speedup enabled by each of heterofuzz s three pronged optimizations while comparing the total number of errors i.e.
of unique divergence symptoms found within the same amount of time.
in summary this work makes the following contributions to our knowledge heterofuzz is the first fuzz testing technique to target heterogeneous applications and to detect platform dependent differential behavior.
to reduce the long latency of simulating heterogeneous applications we designed a three pronged approach that incorporates multi dimensional accelerator feedback dynamic probabilistic mutations and selective invocations.
heterofuzz achieves 754x speedup when finding the same number of distinct divergence symptoms.
each of the three pronged optimizations is necessary to achieve significant speed up without sacrificing fault detection potential .78x more divergence inducing inputs with accelerator spectra monitoring .5x speed up by dynamic probabilistic mutations and .8x speed up by selective invocation compared to heterofuzz without each optimization respectively.
with the same hour budget heterofuzz would find .8x more divergence inducing inputs compared to naive fuzzing.
243heterofuzz fuzz testing to detect platform dependent divergence for heterogeneous applications esec fse august athens greece figure heterofuzz s three pronged approach multi dimensional guidance probabilistic mutations and selective invocation as the current need and prevalence of developing heterogeneous applications are rising significantly in the new era of cloud based hardware accelerator microservices the software engineering community must design a new automated testing technique to improve efficiency and effectiveness for this emerging category of heterogeneous applications.
to our knowledge heterofuzz is the first end to end approach that re invents and adapts traditional fuzzing to heterogeneous applications.
it speeds up differential testing under heterogeneous hardware platforms and overcomes the limitation of long hardware simulation latency during fuzz testing while finding significantly more divergence errors.
background .
heterogeneous computing with fpga hls heterogeneous architectures with fpgas have shown the potential to improve performance under strict energy constraints .
a heterogeneous application can be decomposed into hostcode executed on cpu and kernel code executed on accelerators.
high level synthesis hls .
hls tools for fpgas such as xilinx vivado hls have raised the abstraction of hardware development by automatically generating rtl register transfer level descriptions from c c code.
during hls the frontend schedules each operation from the kernel code to certain clock cycle time slots.
next it allocates the number and type of hardware unit resources used for implementing functionality.
finally the binding stage maps all operations to the allocated hardware units.
this entire hls process can take several minutes for simulation and several hours for synthesis depending on the complexity of kernel logic.
to achieve good quality of results qors hls developers must insert synthesis directives and pragmas manually .
this requires having inter disciplinary expert knowledge and knowing obscure platform dependent details.
testing hls code is difficult because the resulting fpga may produce an outcome different from cpu due to the assumptions specified during accelerator synthesis.
below we describe a few examples of how hls directives and pragmas can produce a different execution outcome.
custom bitwidth.
on chip resource efficiency yields a higher level of parallelization.
hls supports arbitrary bitwidth for integers because reducing a variable s bitwidth could lead to resource reduction in fpga directly.
while the instruction set architecture isa for cpu defines integer arithmetics at bits by default individual bitwidths could be programmed in fpga.
for example if an integer variable agehas a maximum value of it only needs bits instead of bits.
the programmer can insert a pragma typedef ap uint bit7 to declare an arbitrary precision integer of bits.
with custom bitwidth fpga accelerators have much more frequent overflows that would not happen on cpu leading to failures or wrong outputs in the host code.
memory management.
fpga has no capability of on chip memory management.
function calls to memory allocation are replaced by pre allocating a static array with an estimated size and managing data elements manually.
similarly recursions must be converted into iterations using a stack with a finite estimated size .
when an input or recursion depth exceeds the pre estimated size the fpga kernel could crash or return a completely wrong output to the host code by accessing an unexpected address.
parallelization.
reprogrammable hardware provides an inherent potential for parallelizing computation.
such parallelization can be done through pipelining of different computation stages and by duplicating processing elements or data paths to achieve an effect similar to multi threading.
to guide such parallelization a developer must write hls pragmas such as pragma hls unroll creating multiples copies of the loop body which allows some or all loop iterations to occur in parallel or pragma hls dataflow enabling task level pipelining which allows functions to overlap their operations.
such parallel execution can produce an outcome different from sequential execution on cpu especially when a feedback path exists in two different functions or modules.
as described above testing hls code is different from c c because hls directives can cause differential behavior on accelerators.
.
fuzz testing without loss of generality the procedure of fuzzing can be described as follows.
starting with an initial set iof seed inputs the fuzzing procedure randomly selects one input from i and generates new inputs by mutating several bits or bytes of the current input.
in terms of which mutations to apply it selects an available mutation from a given set of mutation operators.
commonly used input mutations are either bit level or byte level mutations in which random bits or bytes are flipped.
it then collects the guidance feedback such as branch coverage by executing the instrumented 244esec fse august athens greece qian zhang jiyuan wang and miryung kim 1int main int argc char argv 2int data gradient argv 3int sum 4float th argv for i to data.
size sum data 8for i to data.size data sum if data th keep argv else discard argv a original application 1int main int argc char argv 2int data gradient argv 3int sum 4float th argv 5int size data.size accumulate data int size 8for i to data.size data sum if data th keep argv else discard argv b host in heterogeneous application1 include ap int.h int accumulate int data int size typedef ap uint bit8 typedef ap uint bit9 define m pragma hls interface m axi port data offset slave bundle gmem pragma hls interface s axilite port data bundle control pragma hls interface m axi port size offset slave bundle gmem bit8 data fpga bit9 i bit8 sum for i to size pragma hls unroll data fpga bit8 data sum loop for i to size pragma hls unroll factor data fpga bit8 data sum data fpga sum int sum return sum c kernel in heterogeneous application figure example program showing divergence bitwidth program with new inputs .
all inputs that enhance a guidance metric e.g.
exercising a new branch or leading to a unique crash are then saved to the working set s. then with s the fuzzing procedure moves onto the next step of selecting an input fromsand applying mutations to the input.
this fuzzing procedure is based on two inherent yet over sighted assumptions it takes a minuscule amount of time to execute the target program and arbitrary mutations are likely to yield meaningful inputs.
such assumptions do not hold for heterogeneous applications because hardware simulation takes several minutes and random mutations cannot account for hardware synthesis intricacies.
motivating scenario this section presents motivating examples for why testing platformdependent behavior is necessary.
suppose that bob writes an image denoising application shown in figure 2a.
this application filters the gradients based on their percentages with respect to the sum of all gradients.
line calculates the gradient vector of an input image by taking the absolute difference between two adjacent pixels.
line defines the filtering threshold.
lines aggregate the gradients across the entire vector.
lines filter out the gradients less than the filtering threshold.
bob runs this c application on cpu and finds that the loop at lines is a hot code path responsible for a significant execution time.
therefore bob decides to convert this original application in c to a heterogeneous application .
he refactors the loop at lines in figure 2a into an hls kernel function accumulate in figure 2c.
the original application is then converted to host code in figure 2b that still runs on cpu and communicates directly with a hardware accelerator generated from the kernel code in figure 2c.
include ap int.h 2void kernel pragma hls dataflow fifo a fifo b funx a b funy a b 7void funx typedef ap uint bit1 bit1 exist b.read nb temp b if exist and temp b a.write else a.write void funy temp a a.read b.write temp a figure example kernel program showing divergence dataflow mode as discussed in section when writing kernel code hls developers must insert directives and pragmas to expose layout regularity and parallelism for fgpa accelerator synthesis.
after analyzing the values of sample data sent to the kernel bob includes the ap intheader file at line in figure 2c to use custom bitwidths of and respectively in lines and instead of using bit integers.
he also pre defines the max array size as in line .
lines define the data transfer interface between cpu and fpga.
lines offload data from cpu to data fpga on fpga.
to exploit hardware level parallelization bob inserts pragma hls unroll in line to make two copies of the sum loop body.
after compiling this heterogeneous application using vivado hls cpu side host code in figure 2b will invoke the kernel accumulate at lines send data to the synthesized fpga and wait for the returned result.
after converting this original application to a heterogeneous application bob may want to test it by using handcrafted inputs or randomly generating data.
bob must check whether this heterogeneous application produces divergent behavior on the same input.
for example when the kernel inputs are sent to fpga bob finds a divide by zero error in the host code at line of figure 2b which does not happen when running on cpu only.
when the kernel inputs are sent to fpga the fpga accelerator will return the sum as instead of the correct sum computed by cpu leading to a completely wrong filtering output in lines of figure 2b.
finding such divergence inducing inputs is extremely challenging suppose bob uses an afl like technique in an attempt to find such divergence inducing inputs.
afl cannot distinguish the above two inputs that produce distinct divergence symptoms because no such errors happen using bit integers on cpu and these two inputs are identical in terms of their branch coverage in host code.
figure describes another kernel example.
in line read nb is aboolean type hls read function which returns false if data is unavailable.
when executing on cpu only funx is executed before funy sequentially so fifo b is always empty and line can never be executed.
as a consequence fifo a is full of and fifo b becomes empty.
however when executing on fpga pragma hls dataflow in line enables parallel execution of funx andfuny .
therefore fifo b is not empty and the ifcondition at line can evaluate to true if the current data in bis .
heterofuzz is motivated by such challenge of testing heterogeneous applications described above.
heterofuzz directly analyzes hls pragmas in kernel code monitors accelerator spectra and 245heterofuzz fuzz testing to detect platform dependent divergence for heterogeneous applications esec fse august athens greece table mapping from hls pragmas to accelerator value spectra fpga relevant category hls directive pragma description of pragma value spectra data type typedef ap uint x bitx define an unsigned integer with a custom bitwidth the actual variable values typedef ap int x bitx define a signed integer with a custom bitwidth with this type pragma hls array partition partition an array into smaller arrays or individual elements memory pragma hls array reshape combine array partitioning with vertical array mapping the set of accessed offsets define size m define the estimated array size recursion n a n a the actual used size of a stack and the number of iterations parallelization pragma hls dataflow enable task level pipelining the fifo queue size pragma hls pipeline allow concurrent execution of operations if feedback path exists pragma hls unroll create multiples copies of the loop body loop pragma hls loop tripcount specify the total number of iterations the actual number of iterations pragma hls loop flatten allow nested loops to be flattened into a single loop hierarchy pragma hls loop merge merge consecutive loops into a single loop to reduce overall latency interface pragma hls interface perform input and output operations using a specific i o protocol n a configuration etc.
in the design interface branch coverage in host code adjusts the activation probabilities of mutation operations and reduces unnecessary simulations to find divergence errors.
approach heterofuzz contains three novel components that work in concert to detect platform dependent differential behavior for heterogeneous applications.
figure describe its overall architecture multi dimensional guidance feedback based on accelerator spectra section .
b dynamic probabilistic mutations section .
and c selective invocation to reduce the latency of repetitively invoking a hardware simulator section .
.
its three pronged approach is based on two key insights platform dependent behavior can be exposed by monitoring accelerator relevant spectra and accelerator synthesis is optimized based on kernel input values therefore multiple invocations within the same value range may expose redundant divergence symptoms.
although heterofuzz is designed for fpga accelerators its key idea can be easily extended to other heterogeneous platforms by monitoring platform specific spectra.
.
accelerator spectra monitoring inputs with the same branch coverage can still have distinct impacts on hardware characteristics heterofuzz augments branch coverage feedback with hardware dependent characteristics to detect divergence symptoms when running host and accelerator together.
prior studies find that numerous severe security problems originate from such host accelerator interaction.
coverage feedback in host code.
heterofuzz instruments the host program based on its extracted control flow graph cfg using llvm .
each node in a cfg represents a basic code block and each edge a b represents a transition between two blocks aand bin the cfg.
similar to afl heterofuzz initializes an array with binary bits called trace bits with zeros in each fuzzing iteration.
iteration here means one execution of a target program with a generated test input.
each bit represents a branch in the program.
if an edge a b is exercised heterofuzz updates the corresponding entry from to in trace bits .
accelerator value spectra.
tracing branch coverage in a synthesized hardware kernel is infeasible because hls takes kernel code as input but implements branching logic using a pipeline ofmultiplexers at the hardware level.
each branch in the synthesized hardware is executed in parallel as long as prior signals are ready however the output being produced by the hardware logic for an untaken branch is never used.
thus branch coverage cannot be derived directly from the synthesized hardware .
branch coverage collected from the host code only is ineffective as a guidance feedback due to its inability to detect errors in heterogeneous applications because inputs with the same coverage in the host code may exhibit different behavior as discussed in section .
heterofuzz analyzes the inserted hls pragmas and traces their associated fpga relevant spectra as accelerator feedback .
it currently supports five kinds of value spectra shown in table .
these mappings are user extensible by modifying a configuration file.
figure 2c is an accumulation fpga kernel with ten hls directives.
it uses typedef ap uint bit8 andtypedef ap uint bit9 to customize bit integer data into and bit integers respectively.
heterofuzz monitors the actual values of variables declared with these types such as data fpga sum and iin lines of figure 2c.
heterofuzz ignores the pragmas in lines as hls data transfer interface has no impact on kernel logic.
the pre allocated array data fpga in line is declared with a maximum size of .
heterofuzz monitors the accessed offsets in case an unexpected address is accessed.
the unroll pragma in line makes two copies of the loop body.
heterofuzz records the actual iteration counts which can be used together with array access offsets to detect potential divergence when the size of offloaded data is not multiple of .
then heterofuzz instruments the kernel to record these three types of values spectra for figure 2c the value range of fpga data output variable sum and intermediate variable i the set of accessed offsets in array data fpga and the actual number of loop iterations.
similar to how afl keeps track of a single test s branch coverage and cumulative branch coverage for all tests heterofuzz keeps track of value spectra for each test execution and cumulative value spectra.
in each test execution it initializes an array acc feedback where each entry has four fields value spectra type name min value max value .
it then updates total feedback to record cumulative value spectra for all seen inputs that can safely execute on the synthesized fpga.
for example when the kernel inputs are the tracked hardware feedback is shown in column fpga accelerator spectra in table .
while coverage guided 246esec fse august athens greece qian zhang jiyuan wang and miryung kim table example execution of generated inputs act.
program kernel fpga accelerator spectra new mutation memorization id mut.
inputs inputs invoke type name min max branch overflow probability range size seed n a yes input value fpga data yes no .
.
.
variable value i .
.
.
variable value sum mem offset fpga data loop sum loop n a m6 no n a n a n a n a no n a .
.
.
.
.
.
m3 yes input value fpga data no yes .
.
.
variable value i .
.
.
variable value sum mem offset fpga data loop sum loop n a m3 yes input value fpga data no yes .
.
.
variable value i .
.
.
variable value sum mem offset fpga data loop sum loop n a m1 yes input value fpga data no no .
.
.
variable value i .
.
.
variable value sum mem offset fpga data loop sum loop n a fuzzing would discard the inputs for not achieving new branch coverage heterofuzz saves them for increasing the value spectra offpga data andsum.
based on the collected branch coverage feedback and monitored fpga accelerator spectra an input will be kept in the generated tests if it increases either kind of feedback.
.
probabilistic mutations designing mutations to detect platform dependent behavior in heterogeneous applications is challenging because mutations modify the inputs of a host program not just those host inputs related to kernel inputs and different mutations contribute to divergence inducing inputs in different degrees.
we propose dynamic probabilistic mutations to increase the chance of detecting hardware dependent behavior.
these mutations represent input modifications to explore the input space during fuzz testing as opposed to code modifications used in mutation testing.
input mutations are directly applied to inputs in host code.
we classify those inputs into kernel sensitive inputs andkernel irrelevant inputs .
kernel sensitive inputs refer to a subset of host program inputs that will be offloaded to an fpga kernel and all other inputs are kernel irrelevant inputs.
to identify kernel sensitive inputs heterofuzz uses static backward slicing of the argument names data andsize of the kernel function accumulate all the way to the original input arguments in the host code.
for example in figure 2b starting from the invocation of accumulate at lines and we use backward slicing on its arguments data andsize in turn marking line and line where data andsize are defined respectively.
starting from line it then marks argv which is an input to the host code s main function in line .
a gradient threshold argv is used in in line argv is used at keep in line and argv is used at discard in line making them irrelevant to accumulate in figure 2c.
therefore we label the input argument argv as a kernel sensitive input.
heterofuzz initializes the selection probability of individual host inputs to be mutated as follows pi 1if i is a kernel sensitive input aotherwise that is the kernel sensitive inputs are always selected and mutated.
ais the probability of selecting a non kernel input as it is still necessary to mutate all inputs in the host code to exercise diverse behavior and increase branch coverage in the host code.
in our experiments we use a .
as default.
considering that data offloaded to a hardware kernel is often an array or a matrix heterofuzz uses six basic mutations extended from afl to generate new inputs shown as follows.
scala values are treated as one element array.
the reason why we focus on arrays and matrices is that hardware accelerators are designed to batch process multiple elements in parallel.
all divergence errors that can be found by naive fuzzing should be all found by heterofuzz as well because heterofuzz s input mutations are a superset of naive input mutations.
data size mutation m1 inserts deletes one or several random elements if the input data is an array e.g.
from to or data dimension mutation m2 adds removes one or several columns if the input data has multiple dimensions e.g.
from to .
data element mutation m3 mutates the value of one element based on its type e.g.
from to .
type mutation m4 modifies the type of a selected entry while keeping the same value e.g.
from integer tofloat .
bit mutation m5 flips one or several bits.
byte mutation m6 flips one or several bytes.
while conventional fuzzing does not update the activation probabilities of mutations and generally keeps them uniform heterofuzz assigns different activation probabilities to individual mutations and updates their probabilities based on accelerator spectra feedback.
if a new child input generated by mutation mincreases the monitored accelerator spectra mwill be labeled as a favored mutation.
favored 247heterofuzz fuzz testing to detect platform dependent divergence for heterogeneous applications esec fse august athens greece table subject programs subject of symptoms of div inducing inputs id program kernel description hf withoutspectra hf withoutspectra p1 median filter bubble sort blur an image by replacing the pixel value to a median .
.
p2 median filter merge sort blur an image by replacing the pixel value to a median .
.
p3 image denoising accumulation denoise an image based on analyzing image gradients .
p4 knn l2norm finds the top k most relevant elements .
.
p5 signal transmission rgb2yuv transform rgb signals to yuv signals .
.
p6 3d rendering rendering render an image based on 3d information .
.
p7 face detection detection detect human faces in an image .
.
mutations will then have higher activation probabilities.
given the activation probabilities of lmutationsp p0 p1 ...pl they will be updated dynamically pm pm ifmis chosen and it increases spectra pm l 1otherwise lis the number of mutations.
since we have six mutations here l is .
everypmis initialized as land is the update factor that is pre defined as .
.
in column mutation probability of table the activation probability for each mutation is initialized to l .
.
in the second execution id inputs created by mutation m3 increase the spectra of input value andvariable value .heterofuzz consequently increases m3 s activation probability from pm .
topm .
and adjusts the probabilities of other mutations to pm l .
.
.
selective invocation to reduce the long latency of repetitive hardware simulation heterofuzz maintains the range of seen kernel input values that run correctly on fpga memorization range in table and their data size memorization size in table .
we use a global variable enable simto indicate whether hardware simulation should be invoked or not.
this variable is set to be true if the range or the data size of seen kernel inputs grow beyond the current records.
suppose that heterofuzz had seen a set of concrete values for an integer array x we maintain the range of xas .
it is safeto record only the range instead of considering combinations of concrete values as a set for the purpose of finding a new distinct divergence error symptom.
if an error were to happen for an unseen combination such as .
this error symptom will be identical to the error symptoms that one would get for executing a value less than or greater than .
this is due to the unique property of fpga synthesis where an integer or fixed point variable maps to a contiguous range of values.
in table for id seed column memorization range is updated to for variable fgpa data as the smallest item is and the largest item is and its execution does not lead to any error on fpga execution.
for id since the kernel input is still within the range of heterofuzz skips hardware simulation.
for id since the kernel input now includes a value that goes beyond the range of heterofuzz invokes hardware simulation and finds that an overflow signal is captured on fpga indicating unsafe accelerator execution.
though the max value of this input is heterofuzz keeps the range of safeexecution as .
asmemorization range is updated for fpga safe executions it is guaranteed to be narrower than or equal to the range of datathat the accelerator designer uses to optimize the fpga data type.
therefore fpga execution with inputs that fit the memorized range can either be fully correct or only report a redundant divergence symptom arising from trying out a new value exceeding the safe range.
thus we can safely obviate such executions to speed up the input generation process.
what we mean by safely obviate is that for the purpose of finding a new divergence symptom it does not matter because you will get the same kind of divergence error.
evaluation we evaluate following research questions rq1 how effective is heterofuzz s accelerator spectra monitoring in generating divergence inducing inputs?
rq2 how much speed up is enabled by heterofuzz s dynamic probabilistic mutations?
rq3 how much speed up is enabled by heterofuzz s selective invocation?
rq4 how effective and efficient would heterofuzz be in comparison to na ve fuzzing using an afl like technique?
rq5 can input range checking obviate the need of fuzz testing and still find platform dependent errors?
benchmarks.
our benchmarks include seven real world and publicly available heterogeneous applications written in c c with fpga kernels listed in table .
p1 p3 are from opencv examples p4 p5 are from and p6 p7 are from rosseta .
our subject selection criteria is based on whether the programs cover different synthesis optimizations and whether a diverse set of hls pragmas is used for detecting platform dependent divergence behavior.
seven programs in table cover all twenty four kinds of pragmas e.g.
custom bitwidth parallelization memory management etc.
and thus activate different kinds of synthesis optimizations.
these subject programs may look small in size but they are actually larger than kernel benchmarks the fpga community uses and real world heterogeneous applications described in xilinx posts .
building a hardware accelerator is similar to designing a new instruction type in cpu instruction set architecture isa .
most kernel code is in order of tens of lines as it maps directly to hardware circuits.
in fact in a usual fpga development workflow developers instrument software on cpu find out its hot code path corresponding to tens of lines of code and extract it as a separate kernel for fpga synthesis.
therefore our work cannot be judged under the same scalability standard used for pure software research e.g.
handling github projects with millions of lines of code .
simply put the current landscape of heterogeneous platforms cannot handle fpga synthesis of such large kernel size.
248esec fse august athens greece qian zhang jiyuan wang and miryung kim time min p1 time min p2 time min p3 time min p4 time min p5 time min p6 heterofuzz withoutspectra withoutmutation withoutselective naivefuzz050100150 time min p7 figure number of unique divergence symptoms time min p1 time min p2 time min p3 time min p4 time min p5 time min p6 heterofuzz withoutspectra withoutmutation withoutselective naivefuzz050100150 time min p7 figure cumulative branch coverage in host code to answer the research questions above we create the following four baseline versions by downgrading heterofuzz .
withoutspectra this option disables accelerator spectra monitoring from heterofuzz to measure how effectively heterofuzz can find more divergence errors by monitoring accelerator relevant feedback.
withoutmutation this option disables dynamic probabilistic mutations from heterofuzz to measure how fast heterofuzz can find the same divergence errors by increasing the probabilities of divergence inducing mutations.
withoutselective this option disables selective invocation from heterofuzz to measure how fast heterofuzz can find the same divergence errors by obviating the need to invoke an hls simulator that finds redundant errors.
naivefuzz this option enables only branch coverage as guidance and invokes an hls simulator for every input.
we estimate its running time by multiplying the number of invocations required for withoutspectra with the average hls simulation time.
experimental environment.
all experiments are done by leveraging vivado design suite .
to simulate kernel execution on xilinx virtex ultrascale xcvu9p fpga.
.
rq1 benefit of accelerator spectra to evaluate heterofuzz s guidance strategy that monitors accelerator spectra in addition to branch coverage we generate inputs for p1 p7 by running heterofuzz and withoutspectra for three hours.
with the generated inputs we execute the program on cpu versus a heterogeneous platform that runs hoston cpu and kernel on the fpga hls similuator.
we then measure the percentage of divergence inducing inputs and the number of unique divergence symptoms.
this experiment is done over ten independent runs and the rightmost two columns in table report the results heterofuzz in column hf .
on average .
of inputs generated by heterofuzz is divergence inducing while .
of inputs generated bywithoutspectra is divergence inducing.
this is because withoutspectra takes the fpga accelerator as a black box and enlarges the covered branches in host code only.
on the contrary heterofuzz monitors branches and accelerator spectra in tandem leading to .78x more divergence inducing inputs.
we then group divergence inducing inputs into a set of unique symptoms because different inputs may exhibit the same kind of a divergence error.
in figure y axis is the average cumulative number of detected symptoms.
within the same time budget withoutspectra detects unique symptoms in total while heterofuzz detects almost .7x more divergence symptoms.
it is also important to note that existing inputs shipped with the original benchmark do not find any divergence errors in other words heterofuzz has the potential to detect real world platform dependent errors proactively.
we also assess speed up enabled by heterofuzz by measuring the time taken to find the same set of divergence symptoms found bywithoutspectra .
across seven applications withoutspectra takes total hours to find unique symptoms while heterofuzz takes only .
hours demonstrating 40x speed up.
table lists five sample symptoms found in p3.
we describe why these divergent behavior appear between cpu and fpga and how heterofuzz finds them in detail below.
first as with most hardware designs the kernel in p3 uses optimized bitwidths for data offloaded from cpu to fpga and its intermediate variables.
when a large number is sent to the kernel it only keeps eight most significant bits or least significant bits in the binary representation of and cuts off the others leading to a wrong result.
when the inputs and are executed on fpga kernel runtime overflow happens with variable sumin line of figure 2c leading to a divideby zero error in host code and a wrong returned result respectively.
although integer overflow can happen in cpu as well it shows up much more frequently in accelerators and it is not easy to predict the consequent impact.
heterofuzz monitors the value ranges of 249heterofuzz fuzz testing to detect platform dependent divergence for heterogeneous applications esec fse august athens greece table example divergence symptoms for p3 input id symptom description checking s1 unexpected memory overflow happens endless when fpga attempts to write loop data fpga at an unexpected address in line of figure 2c.
s2 kernel host is offloading a large offloading number to fpga error in line of figure 2c leading to a wrong returned result.
s3 kernel the value of intermediate runtime variables in line of figure 2c overflow exceeds its bitwidth capacity leading to a wrong result.
s4 divide by fpga returned result leads to zero in host divide by zero error in line of figure .
s5 incorrect cpu and fpga produce loop different results when the input unrolling array size is not multiple of .
inputs and intermediate variables to increase the chance of showing differential behavior caused by accelerator integer overflows.
second when a program attempts to access an invalid or illegal address in cpu the memory management unit can give exception signals such as segmentation fault .
however in fpga all memory accesses are mapped to a legal physical address on bram which can result in severe security problems and unexpected accelerator behavior.
heterofuzz generates input wherein the 401st element is .
line in figure 2c then writes this over ranged data fpga to the address of a loop iterator i leading to an endless loop execution of lines .
third to further complicate the difficulty of finding divergence errors because p3 makes two copies of the loop body during fpga synthesis to enable parallelization a wrong result happens only if the size of an input array is not multiples of the unroll factor .
heterofuzz and withoutspectra achieve similar coverage as shown in figure .
the y axis indicates the percentage of covered branches in host code.
for all applications except p7 heterofuzz s coverage grows slightly slower than withoutspectra .
this is because heterofuzz increases the activation probabilities of mutations that lead to a new accelerator feedback pushing the fuzz engine to explore more platform dependent divergence rather than enlarging branch coverage in host code.
summary heterofuzz finds .78x divergence inducing inputs .7x unique divergence symptoms by monitoring accelerator spectra in addition to the branch coverage of host code.
.
rq2 benefit of probabilistic mutation to evaluate the benefit of dynamic probabilistic mutations we create a downgraded version withoutmutation that disables probabilistic mutations from heterofuzz .
we assess how fast heterofuzz andwithoutmutation detect divergence symptoms within the three hour limit.
we repeat the experiments ten times and report average results in figure .
in total heterofuzz detects unique symptoms while withoutmutation reports given the same time limit.
compared top1 p2 p3 p4 p5 p6 p7104105input trialsheterofuzz hfwithoutinvocation figure number of input trials.
withoutmutation heterofuzz finds the same divergence symptoms reported by withoutmutation .
times faster taking only .
hours as opposed to hours.
for example in p3 while heterofuzz finds five divergence errors withoutmutation finds only one divergence error by generating input that leads to an error because the max value to be offloaded to fpga is .
the other four errors are not found by withoutmutation because it wastes most fuzzing time on generating type invalid data for the fpga kernel such as when an integer array is expected.
heterofuzz leverages probabilistic mutations to increase the chance of hitting divergence behavior by isolating kernel sensitive inputs and prioritizing divergence inducing mutations such as modifying the value of a specific element in the array.
the achieved branch coverage of withoutmutation is the same with the coverage of withoutspectra as shown in figure because no accelerator spectra monitoring implies that dynamic mutations cannot be enabled.
however when turning off dynamic mutations heterofuzz can still use accelerator spectra as a guidance feedback.
summary heterofuzz achieves .5x speed up in detecting the same set of errors by dynamically adjusting the activation probability of divergence inducing mutations.
.
rq3 benefit of selective invocation to assess speed up enabled by selective invocation of a hardware simulator we compare heterofuzz with a downgraded version withoutselective .
we measure the number of inputs the tools can explore within the same hour budget.
in figure the y axis is the average number of input trials over ten independent runs.
in p2 withoutselective can invoke a simulator with inputs only while heterofuzz can attempt over 51k inputs achieving .8x speedup.
heterofuzz achieves such speedup by skipping the repetitive simulation calls when inputs hit the memorized value range of seen kernel inputs.
this selective invocation saves time but does not sacrifice fault detection capability because kernel inputs contained within already seen ranges can lead to either correct fpga executions or already discovered divergence error symptoms.
collecting kernel input values does not incur additional hardware level instrumentation as such information can be extracted from hls simulation results.
summary by reducing unnecessary hardware simulation calls heterofuzz speeds up differential testing by .8x without sacrificing fault detection capability.
250esec fse august athens greece qian zhang jiyuan wang and miryung kim .
rq4 comparison against naive fuzzing fuzz testing is often built on an implicit assumption that the program under test can be executed millions of times within a matter of hours .
however such assumption does not hold for heterogeneous applications due to the long latency of hardware simulation.
we estimate the time required for naivefuzz by multiplying the number of iterations required to find the same kind of divergence symptom using withoutspectra where one iteration means running a program on a new input with an average hardware simulation time for each program.
figure shows comparison between the running time of heterofuzz and the estimated time of naivefuzz .
please note that though we report an estimated time not an actual running time because hw simulation time does not vary much for each input the standard deviation .
this estimated should be highly similar to the actual time of using an afl like technique that directly invokes an hls simulator with a new input.
within three hours naivefuzz finds only one divergence symptom for p4 p5 and p7 but could not find any in other programs.
for p2 naivefuzz requires at least hours to detect all symptoms detected byheterofuzz within three hours leading to 754x speed up.
in addition to the results in figure we ran heterofuzz for hours and compare against what naivefuzz would find within the same time budget.
heterofuzz detects .8x more error inducing inputs with the same budget of hours compared to naivefuzz .
summary using an afl like technique to repetitively invoke a hardware simulator would be too slow and insufficient to reveal platform dependent errors in heterogeneous applications.
.
rq5 comparison against input checking one may question whether input validity checking on the side of the host code is feasible and adequate for preventing platformdependent errors in kernel code to be executed on a hardware accelerator.
unlike pure software systems where a caller function can prevent errors by checking the pre condition of its callee prior to invocation such input validity checking is not always feasible in heterogeneous applications .
the reason is that it is nearly impossible to identify the precise pre condition in advance due to the difficulties of modeling individual fpga devices because the pre condition is dependent on the resource availability on a specific platform.
for example when a merge sort kernel requires a 5mb array for dynamic block memory xilinx zynq with .3mb bram will work fine but xilinx zynq with .9mb bram will produce an incorrect sorting result silently.
to further substantiate this argument we conducted a case study on several divergent symptoms found by heterofuzz in the example application shown in figure .
table summarizes a divergence symptom a detailed error description and whether input range checking could have prevented such error.
after analyzing the hls pragmas in line line and line we manually extract the pre condition of kernel code in terms of a range check and insert it an input guard an integer array whose size is multiple of two but no larger than and each element in this array should be less than .
after inserting this guard into the original host code divergence symptoms s2 and s5 are prevented because theaccelerator is trying to process data with an invalid value or size.
however such input checking is still inadequate and does not prevent the platform dependent error s1 and kernel runtime errors s3 and s4.
for example s4 is caused by inputs that satisfy the guard condition .
in other words assertions inserted by a defensive developer in the host code may not fully prevent runtime errors coming from hardware accelerators due to varying resource availability of individual fpga devices.
to our knowledge heterofuzz is the only testing tool that can detect such platformdependent errors missed by input checking in host code.
summary our case study shows evidence that even if a developer manually constructs and inserts assertions in host code kernel errors from accelerators cannot be fully prevented.
threats to validity we discuss the threats to validity as follows.
device dependence.
we simulate all the kernel executions on a single xilinx virtex ultrascale xcvu9p fpga which is currently the widely used fpga.
this setup may restrict the generalizability of our results to other devices because the detected divergence symptoms could vary for different platforms e.g.
intel s altera.
though the absolute numbers of execution time and symptoms are dependent on a detailed configuration we believe that heterofuzz would retain the overall benefits of speedup and divergence finding capability when it is applied to different platforms.
since heterofuzz uses fpga simulation it does not find mechanical failures caused by temperatures aging of devices and radiation on fpga.
such hardware in field testing is often done by device physicists.
time limit.
we empirically set three hours as the time limit for fuzzing.
longer execution time may expose more divergence errors or more execution paths as suggested in however this time limit is reasonable as we did not see any increase in new types of divergence errors with a higher time limit for subjects p1 p7.
input mutations.
in terms of mutations heterofuzz refers to input modifications to explore the input space during fuzz testing as opposed to injecting code faults in mutation testing.
heterofuzz not only is faster than naive fuzzing but is safe i.e.
heterofuzz can find all errors that can be found by naive fuzzing as heterofuzz s input mutations are a super set of low level input mutations.
designing new kinds of input mutations could affect the efficiency of fuzz testing.
currently there are no equivalent high level input mutations in heterofuzz .
low level bit or byte mutations retained byheterofuzz could subsume other high level input mutations because combinations of low level mutations could map to high level mutations.
related work fuzz testing.
fuzzing has gained popularity in both academia and industry due to its black grey box approach with a low barrier to entry .
the key idea of fuzz testing originates from random test generation where inputs are incrementally produced with the hope to exercise previously undiscovered behavior .
for example afl mutates a seed input to discover previously unseen coverage profiles .
to carefully explore a vast space of inputs 251heterofuzz fuzz testing to detect platform dependent divergence for heterogeneous applications esec fse august athens greece and unbounded program paths lemieux et al.
create custom mutations so that the generated inputs gravitate toward exercising rare branches .
other approaches incorporate symbolic execution with fuzzing to guide selection and mutation of the inputs to invoke unique program paths .
padhye et al.
incorporate the semantic validity of input mutations in zest to reduce the search space of inputs by mapping low level bit level mutations to valid structural changes in the high level input representation.
all these fuzzing techniques are built on the assumption that the program under test can be executed millions of times within a matter of hours.
however in the domain of heterogeneous applications a single invocation of a hardware simulator may take several minutes which is the exact problem that heterofuzz addresses.
instead of using coverage as guidance several techniques have investigated how to use custom guidance mechanisms.
perffuzz uses the execution counts of exercised instructions together with branch coverage as fuzzing guidance to explore pathological performance behavior.
uafl incorporates typestate properties and information flow analysis to detect the use after free vulnerabilities.
memlock employs both coverage and memory consumption metrics to guide the fuzzing process.
aflgo extends afl to direct fuzzing towards user specified target sites.
however none explicitly monitors hardware level accelerator spectra and metrics to reveal platform dependent divergence like heterofuzz .
another angle to optimize fuzz testing is to update which mutation operations to apply.
symfuzz uses symbolic execution to determine the number of bits to be mutated in a seed input.
angora updates mutation operations to be aware of taint level observations.
sdf uses seed properties to guide mutation in web browser fuzz testing.
in grammar based fuzzing saffron repairs the given grammar based on whether the program accepts unexpected inputs outside of the provided grammar and then it adaptively refines the probabilities of every production rule.
mopt finds an optimal probability distribution for mutation operators to discover vulnerabilities more efficiently.
to our knowledge none designs probabilistic mutations by associating monitored accelerator spectra with the probability of activating specific mutation operators.
testing in hls and hardware accelerators.
hls tools automatically generate rtl descriptions from c c programs.
yann et al.
test hls by randomly generating programs and verifying the equivalence between the synthesized design and the original code.
christopher et al.
investigate many core compiler fuzzing in the context of heterogeneous computing with opencl kernels.
they report more than opencl compiler bugs.
silver proposes a single end to end correctness theorem about running a verified compiler on a verified fpga platform.
it generates machine code for silver based on a high level executable specification and the synthesized fpga hardware will have the observable behavior of the original high level specification.
different from hls compiler testing that finds bugs in compilers heterofuzz detects platform dependent behavior in heterogeneous applications.
heterofuzz focuses on testing software applications with host code and kernel code combined together.
in other words heterofuzz s problem concerns c like code testing where a sub region of code could be offloaded to fpga accelerators.
on the other hand the hardware design community targets circuit verification in the form of bitstream and or hardware description languages hdl suchas verilog vhdl etc.
using formal verification and runtime verification .
for example rfuzz is a circuit runtime verification tool for firrtl ir uc berkeley s own version of rtl language .
rfuzz invents a new notion of mux toggle cooverage for circuit testing at gate level and employs a rapid memory resetting on fpga for rtl circuit verification.
as another example qin and mishra present a scalable test generation technique for hardware kernels in verilog by interleaving concrete and symbolic execution to bridge the gap between model checking and testing.
as opposed to these techniques that find crashes on kernels only heterofuzz targets end to end application code testing and reveals differential behavior of the entire heterogeneous application i.e.
host and accelerator together under different platforms.
in other words it is not feasible to directly compare heterofuzz against these circuit testing techniques because they do not have capability to test host code together with kernel code and their input languages are verilog variants not c variants.
revealing precision errors.
fpgen uses symbolic execution to generate inputs to trigger large numerical floating point errors.
it defines inaccurate precision loss checks and injects these checks at strategic program locations to construct specialized branches to induce floating point errors.
different from fpgen that focuses on floating point overflows and errors heterofuzz has such a broad scope in generating inputs that lead to variable overflow on kernels kernel exceptions incorrect returned result etc.
mediating host accelerator interactions.
interaction and communication between accelerators and the host can pose severe security problems.crossing guard is a coherence interface between the host and accelerators.
it prevents potential bugs caused by hostaccelerator communication.
border control is a sandboxing mechanism that guarantees that the memory access permissions are respected by accelerators regardless of design errors or malicious intent.
while the above work focuses on preventing bugs caused by host accelerator interactions heterofuzz on the other hand is a test generation tool to detect bugs when running host and hardware accelerator together.
conclusion as hardware specialization energy efficiency and flexible re programmability are becoming increasingly important a new type of cloudbased hardware accelerator microservices based on fpga has emerged.
major service providers such as amazon f1 and microsoft azure have begun to support heterogeneous application development to enable acceleration with customizable hardware.
heterofuzz makes three key contributions in automated testing of heterogeneous applications by incorporating multi dimensional guidance dynamic probabilistic mutations and selective invocation.
in total the speed up achieved by heterofuzz s three pronged approach in finding the same set of errors is up to 754x compared to using an afl like technique naively.
heterofuzz is the first endend technique that significantly improves testing effectiveness and efficiency for this new breed of heterogeneous applications.