improving data scientist efficiency with provenance jingmei hu harvard university cambridge ma usajiwon joung university of michigan ann arbor mi usamaia jacobs harvard university cambridge ma usa krzysztof z. gajos harvard university cambridge ma usamargo i. seltzer university of british columbia vancouver bc canada abstract data scientists frequently analyze data by writing scripts.
we conducted a contextual inquiry with interdisciplinary researchers which revealed that parameter tuning is a highly iterative process andthatdebuggingis time consuming.asanalysisscriptsevolve andbecomemorecomplex analystshavedifficultyconceptualizing their workflow.
in particular after editing a script it becomes difficulttodeterminepreciselywhichcodeblocksdependontheedit.
consequently scientists frequently re run entire scripts instead of re running only the necessary parts.
we present provbuild atool that leverages language level provenance to streamline thedebugging process by reducing programmer cognitive load anddecreasing subsequent runtimes leading to an overall reduction in elapsed debugging time.
provbuild uses provenance to track dependencies in a script.
when an analyst debugs a script provbuild generates a simplified script that contains only the information necessarytodebugaparticularproblem.wedemonstratethatdebuggingthesimplifiedscriptlowersaprogrammer scognitiveload and permits faster re execution when testing changes.
the com bination of reduced cognitive load and shorter runtime reduces thetimenecessarytodebugascript.wequantitativelyandqualitatively show that even though provbuild introduces overhead during a script s first execution it is a more efficient way for users to debug and tune complex workflows.
provbuild demonstratesa novel use of language level provenance in which it is used to proactively improve programmer productively rather than merely providing a way to retroactively gain insight into a body of code.
ccs concepts software and its engineering software development techniques.
keywords provenance incrementalexecution dependencytracking dataanalysis permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acmmustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
icse may seoul republic of korea association for computing machinery.
acm isbn ... .
reference format jingmei hu jiwon joung maia jacobs krzysztof z. gajos and margo i. seltzer.
.
improving data scientist efficiency with provenance.
in 42nd international conference on software engineering icse may seoul republic of korea.
acm new york ny usa pages.
https introduction researchersacrossawiderangeofdisciplinesroutinelyparse transform andprocess data by writingdata analysis scripts.
scriptsare a convenient and flexible way for data scientists to decompose a data processing procedure into steps including preprocessing data input training models tuning arguments or parameters adding new analysis functions and propagating changes through to other data.bysomeestimates millionsofpeoplewritescriptstoconduct data analysis tasks.
however only a small portion are professional software engineers .
it is standard for researchers to arrange their scripts and data into a pipeline which typically consists of reading data from morethanoneinput analyzingandingestingdatawithmultiple processingstepsandproducingoneormoreoutputs.weconducted acontextualinquirywithfiveresearchscientistsatalargeresearch university to understand common data processing procedures and thepainpointsofanalysispipelinedevelopment.whileeachparticipant struggled witha unique set of challenges afew problems werecommontoall.allparticipantsusedaniterativeprocessbased on editing executing and evaluating.
in particular researchers repeatedlychangedparametersandreranscriptsuntiltheyarrivedat good parameter settings.
parameter tuning accounted for the majority of development time.
although in theory each edit required re executingonlydependentportionsoftheanalysispipeline in practice researchersdefaultedtorerunningtheentirescripts becauseitwasnotobvioushowtorerunonlythenecessaryparts.this procedure was both time consuming and cognitively demanding.
efficiently tuning model parameters is an open problem .
tuning time grows exponentially as program dimensionality increases .rerunningapipelineaftermodifyingascripttechnically requires rerunning only the dependent downstream components.
however identifying these dependencies requires reasoningabouttheentireworkflow whichiscomplexandinconvenient.consequently researchers usually rerun entire workflows after each change.
as a result each iteration takes more time than is strictly necessary.
thus tuning parameters and debugging can take hours.
a tool that optimizes this process has the potential to increase researcher efficiency.
ieee acm 42nd international conference on software engineering icse toaddressthisinefficiency wedevelopedprovbuild adataanalysis environment that uses change impact analysis to improve the iterative editing process in script based workflow pipelines by harnessing a script s provenance.
in particular we use languagelevel provenance which records information about every line of code executed by a script including variable names variable values functiondefinitions functioncallsandtheirparameters and the relationships among all these objects .
provbuild demonstratesanoveluseofsuchprovenance.traditionally provenance tools have been used for visualizing workflows e.g.
explaining the results of relational queries or recording systembehavior .incontrast provbuildusesprovenance toimproveprogrammerproductivity.provbuildobtainsprovenance usingnoworkflow apython basedprovenancecapturetool.
using the provenance information provbuild identifies dependencies between inputs program statements functions variables and outputs allowingittopreciselyidentifythesectionsofascriptthat mustbere executedtocorrectlyupdateresultsafteramodification.
provbuildthen generatesacustomized script the provscript that containsonlythosesectionsaffectedbyamodification.wehypoth esizedthatthisstreamlinedscriptwouldallowuserstoreasonmore easily and quickly about the consequences of their edits incurring lesscognitiveloadandallowinguserstocompletetheirjobmore quickly.
we evaluated this hypothesis in multiple ways.
first weevaluatedprovbuildinacontrolledlaboratoryexperiment with participants who performed a series of debuggingtasks with and without provbuild.
next we ran benchmarks to quantifyhowmuchtimeprovbuildsavedduringscriptre execution.
finally weevaluated provbuildinanotheruser study.
inthisrealworlddeploymentstudy wegave12participantsaccesstoprovbuild foraweekandusedsurveystoassessprovbuild sutility.weasked participants how and when they chose to use provbuild in their daily work.
the contributions of this paper are a novel use of language level provenance.
provenance is usedproactivelytoimproveprogrammerproductivityrather than merely providing a way to retroactively gain insight into a body of code.
provbuild is the first debugging tool to leveragelanguage levelprovenancetoreducecognitiveload and execution time.
a quantitative experiment demonstrating that provbuild shortens re execution time using stored provenance.
acontrolledlabstudydemonstratingthatuserspreferprogrammingwithprovbuildtoprogrammingwithoutit that they complete programming tasks more quickly and that provbuild reduces their cognitive load.
a real world deployment study where users explained that provbuild saved them time helped them understand their workflow and provided more immediate results.
section describes our contextual inquiry that led to the development of provbuild.
section presents provbuild s design andimplementation.
sections describe and report the results of our various evaluations.
discussion related work and conclusions follow in sections .
problem formation provbuildistheresultofacontextualinquiryintohowresearchers interactwiththeirdata.usingthecontextualinquirymethod we conducted a field study with five researchers at a large research university.
the researchers areas of expertise included appliedmathematics computerscience geography appliedphysics and clinical biology.
webeganbyinterviewingeachparticipantaboutthespecificsof theirdataanalysistaskstakenfromtheirownresearchprojectsandthestepstheytakeinperformingthesetasks.then tworesearchers observed participantswith minimal interferenceas they executed thesetakes.wetooknotesonhowtheyexecutedtheiranalysis e.g.
bytypingcommandstoaninterpreterorrunningascript what they did when they encountered a surprising or unexpected result andhowtheyevaluatedchangestheymade.wealsoaskedthem explicitly to verbally express any frustration with their process afterward we asked them what sorts of tools might reduce that frustration.
after comparing the individual researchers notes we drew two mainconclusions.first usersspentsignificanttimere executing scripts during the dataanalysis process and parameter tuning accounts for the majority of development time.
three participants mentionedthattheyhadtorunscriptsmultipletimestoidentify appropriate patterns engineer features and train models.
some alsostatedthatitrequiredagreatdealofefforttoproduceadesired output.
they reported that tuning model parameters was time consuming because the process involved manually re running whole scripts for each parameter combination.
although changes inthemiddleofananalysispipelinedonotrequireexecutingstatements prior to the change users report that it was difficult to identify which parts of a script were affected by a change so required too much effort.
the researchers tended to treat the data analysispipelineasadiscrete indivisibleunit.aftereditingascript our subjects all simply reran their entire pipeline.
second researchers placed a high premium on ease of adoptionwhenconsideringnew tools.duringinterviews participants expressed interest in a tool that would reduce inefficiencies surroundingdataprocessing.however thisinterestwasqualifiedby hesitations about the overhead of learning and adopting a new tool.
we concluded that familiarity and usability must be first class considerations in addressing the re execution inefficiency.
provbuild pipeline debugging using provenance wedesignedanddevelopedprovbuildtoaddressthechallengeswe discoveredinourcontextualinquiry.provbuildleverages languagelevel provenance collected by noworkflow which uses programslicing torecordeveryactiontakeninascriptandthe dependencies between objects such as variables values and functions.usingthesedatadependencies whenausermodifiesascript provbuildidentifiespreciselywhichscriptstatementsmustbereexecuted to produce new results.
provbuild constructs a shortened script calleda provscript thatreducesre executiontimeandmakes iteasiertoreasonabouttheeffectofauser smodification.provbuild consistsofabackendengine figure1 section3.
andauserinterface figure section .
.
!
!
!
!
!
!
!
!
!
!
!
!
figure provbuild architecture.
.
the user view when a user begins tuning or debugging a script they upload their script to provbuild.
using the frontend gui described in section .
they select the function output or variable they aredebugging tuning.
fortherestofthesection werefertothisas thetarget.
provbuildthengeneratesa provscript whichcontains only the code necessary to produce the target.
the example shown in figure illustrates this procedure.
imagine that a user wishes to debugthe bazfunction.the bazfunctionaffectslines9and14only since ccontainsthereturnvalueof baz line9 whichisthenused to compute ein line .
provbuild treats variables a b d and fas constants sincetheirvaluesdonotdependon bazanddonotneed to be recomputed.
provbuild extracts the appropriate values for themfromtheprovenanceandassignsthosevaluestothevariables in the resulting provscript.
without provbuild users typicallyrerun theentire scriptafter eachedit withprovbuild usersruntheautomaticallygeneratedprovscript after an edit.
in the example provbuild inserts four linesatthetopofthe provscript assigningtheconstantvaluesof a b d and f inserts the definition of function baz and includes the dependent lines and .
provbuild ignores the definitionof functions fooandbar because they are irrelevant and do not depend on bar.
as such the resulting provscript contains only the code necessary to test changes to baz.
the shortened script minimizes re execution time and isolates the code being debugged making it easier to reason about how modifications affect their pipeline.
users need not modify their current debugging or tuning behavior sinceprovbuildhidestheprovenance drivenoptimizationprocessbehindtheuserinterfaceandpresentsthemwithasimpler editing task.
.
provenance collection figure depicts provbuild s high level architecture.
provbuild capturesprovenanceusingnoworkflow anopensourceprovenance collectiontool for python.noworkflow usesa combination ofstaticanddynamicanalysistocapturethreetypesofprovenance .definition provenance is a record of all global variables and functiondefinitions calls andargumentsinascript.
deployment provenance includes the execution environment and library dependencies.execution provenance accumulates while a script runs and canbeeithercoarse grainorfine grain.coarse grainprovenance includesinformationabouteveryfunctioninvocation thefunction its arguments and the return value and file accesses.
noworkflow original script provscript def foo var a return var b def bar var d return var f def baz var1 var2 def baz var1 var2 return var1 var2 l5 a foo return var1 var2 b foo l6 c baz a b c baz a b l9 ifa e b c l15 d foo else d bar e b c f b for i in range f foo figure comparison between an original script and the provscript.
usesprogramslicing tocapturefine grainprovenance such as control flows and variables and their dependencies.
although provbuild currently works with provenance captured by noworkflow there is nothing in its design that precludes it fromworkingwithotherlanguage levelprovenancecapturesystems such as r s rdatatracker .
we leave development of a provenance capture agnostic version of provbuild to future work.
provbuild analyzes the fine grain provenance to construct a dependencygraph whichidentifiesthepartsofthescriptonwhicha particular edit depends.
it then produces the provscript by traversing the dependency graph assigning variables concrete values where possible and computed values otherwise.
we discuss this in more detail in the next section.
.
dependency exploration provbuild s backend consists of two main parts dependency explorationand scriptmerging.wediscussdependencyexploration here and script merging in the next section.
thekeytoprovbuildliesinitsabilitytoconstructanaccuratedependencygraph.somecomponentsofthedependencygraphappear intheprovenancewhileothersdonot.
thefollowingparagraphs whichaddressfunctiondefinitionsandcontrolflow describethe differentstrategiesemployedinconstructingaprovenancegraph in which we can explore dependencies.
.
.
function definitions.
thereare twokindsoffunctions that theprovscript might need those appearing in the script which are part of the definition provenance and those that come from imported libraries.
provbuild identifies the necessary subset of the the functions appearing in the script using the function invocation informationintheprovenance.ratherthanidentifyingprecisely which functions are needed from libraries we retain all import statements from the original script in the provscript.
.
.
control flow.
there are aspects of a script that provbuild needs to construct for the provscript that are not recorded in the provenance.forexample noworkflowprovenancedoesnotfully captureconditionalcontrolflow becauseprovenanceisanexecutionrecord andanyspecificexecutionfollowsonlyoneclauseof anif elif else statement.
ho wever provbuild needs to include allconditionalclausesina provscript toensurethatre execution is correct.
provbuild accomplishes this using static analysis of the original script.
during this static analysis it creates a pseudo function for the the entire conditional expression i.e.
including all conditions .whenprovbuildneedstoincludeaconditionalexpression in the provscript it includes the pseudo function instead of including just the single clause from the actual execution.
consider the following.
in the original script in figure ais even so fooalways executes on line and barnever does.
the execution provenance records the use of foobut not bar which appearsonlyinthedefinitionprovenance.now let ssaythatauser isinterestedintuningthevalueof a i.e.
changetheargumentto foofrom to .when they re execute noworkflow s execution provenance indicates that foois the only function that depends on x.provbuildobservesthataconditionalappearsinthe provscript andincludesthefullconditionalclauseasshown inthefollowing code sothat re executionproduces the correctresult even when a is odd during a later execution.
provscript ... variable b c e f assignments def foo var l1 return var l2 def bar var l3 return var l4 a foo l7 i fa l10 d foo l11 else l12 d bar l13 proactively including every possible function definition could lead toanoverlycomplicated provscript.instead provbuildusesiterative exception handling to identify only those function definitions needed for a particular execution.
the iterative exception handling happensonlywhenexecutingstatementsinaconditionalthateitherwerenotexecutedthefirsttimeorrequireloadingofadditionalfunctions.provbuildinitiallyreliesontheexecutionprovenance intheexample the provscript includesonly foo sdefinition.iftheuser makes the value of aodd and re executes the provscript throws anameerror exceptionwhenitencounterstheinvocationof bar.
provbuild catches the exception extracts the necessary function definitionfromtheoriginalscript andregeneratesthe provscript with the additional function.
provbuild continues catching such exceptions regenerating the provscript each time until script executioncompleteswithoutthe nameerror exception.the provscript is a superset of a program slice and our iterative dynamic trapping ensures that we are not missing necessary parts of the program.
.
.
constructing the provenance graph.
given a target we dividetheexecutionprovenanceofascriptinto upstreamprovenance everything on which the target depends and downstream provenance everything that depends on the target.
if we view executionprovenance as a graph provbuild collects upstream provenance byselectingtheancestorsofthetargetandcapturesdownstream provenancebyselectingthetarget sdescendents.whilemostprovenance systems avoid cycles in provenance graphs noworkflow allowsthem andtheyrequirespecialattention.considertheoriginal script lines15 infigure2.assumethattheuserisinterested in the derivation of the value of f. the provenance indicates that x dependsonbothlines15and17.however neithernoworkflow s static nor dynamic analysis identify that it also depends on the values of ithat occur in line .
provbuildperformsitsownloopanalysistoaddressthisomission.
it creates upstream provenance for variables dependent upon loop iterators.
so when provbuild constructs the provscript for the exampleabove itincludestheiterator iintheupstreamprovenance off.
provbuild also uses the dynamically collected upstream and downstreamprovenancetotrackimplicitdependencies.consider theoriginalscript lines7 .function baztakes foo sreturnvalues aandbasparameters.thismeansthat cdependson fooimplicitly andbazexplicitly.thus changing bazrequiresrerunningonlyline 9anditsdownstream whilechanging foorequiresrerunningall threelinesandtheirdownstream.provbuildincludesallimplicit function and variable relationship in the provscript.
validity.considering only deterministic programs let mbe the point of the first modification.
assuming that noworkflow cap tures all dependencies the provscript reproduces the state from the original execution prior to m. consider the two cases concerningprovenancethatdependson m dependenciesthatexisted in the original execution are by definition carried over into the provscript dependencies that did not appear in the original execution mustbetheresultofaconditionalexpressionintheoriginal script the provscript incorporates all clauses for every such conditionalencountered.provbuildconstructsthetransitiveclosureof the dependencies in the program ensuring that the resulting provscript is correct.
.
script merging userscan editthesimpler provscript directly and provbuildautomatically merges those changes back into the original script.
after merging future provscript s are based on the new merged version of the file.
tomergesuccessfully provbuildmaintainsarecordofthedifferences between the original script and the provscript.
we annotate eachlineinthe provscript withcommentsthatexplicitlymapthe linetoitscorrespondinglineintheoriginalfile.forexample inthefollowing provscript provbuild adds comments beginning with the special token since the definition of function bazand the assignmentsofvariable zinlines5 8and9areinheritedfrom the original script.
the assignments in lines are inserted by provbuild not the user so they are not marked.
provscript after user edits a b d f def baz var1 var2 l5 1089figure the provbuild interface features four boxes.
we assumethatalluserscriptswritetoanoutputfile.theblueboxdisplaysthecontentsofthisoutputfile.theyellowboxdisplays the original script for user reference and the blackbox displays the provscript.
the grey box displays terminal output such as errors and print statements.
the side bar on the left provides easy access to the user commands.in provbuild mode the user specifies the target either afunction or variable to change debbug.
after editing theprovscript theuserrunsit andexaminestheoutput.whenthe user is satisfied with the output the user merges thechangesintotheoriginalscript.atthispoint theyellowboxupdatestocontaintherevisedscript theusercanthenselectanother object to edit.
var1 var1 return var1 var2 l6 c baz a b l9 l15 new lines in the provscript e.g.
line contain no added markers while deleted lines e.g.
line appear as a line with the marker ofthedeletedline butnocode.theinformationprovidedbythe markers enables provbuild to correctly merge changes into the original script.
thesecommentcharactersareincidentaltoourprototype.we used them to avoid making changes to the underlying editor.
a realdeploymentwouldimplementtrackingintheeditor making it invisible to the user.
there are standard techniques for such tracking .
.
interface design our interface allows users to debug functions or variables on a simplified version of an original script and seamlessly merge those modifications back into the original script.
to facilitate evaluation the provbuild prototype interface supports both conventional editing i.e.
editingontheentirescript andtheprovbuildprovenancedriven editing of a provscript.
in either case the user begins by selectingthe modeof interaction conventional orprovbuild and identifyingthescriptwithwhichtheyareworking.inprovbuild mode the interface activates the provenance tracking backend.provbuildisdesignedtoabstracttheprovenance drivenincremental build process away from the user.
users interact with their scripts through the three main modules shown in figure .
each module is explained in more detail below.
search theuserinputsthenameofthefunctionorvariable to edit see in figure .
provbuild extracts the object s dependenciesbasedonthestoredprovenanceinformation andgenerates a provscript containingonly codepertaining to the chosen object.
execute insteadofrunningtheoriginalscript provbuild executes the shortened provscript for the user see in figure .
this reduces run time.
merge provbuild allows users to easily merge edits from theprovscript into the original file see in figure .
when used in conventional mode the interface is similar to common modern text editors.
users simply edit their scripts and re execute them in their entirety.
research questions weconductedthreestudiestoevaluateprovbuild sperformance effectiveness and usability.
our goal is to answer the following four research questions rq rq1 howwellcanprovbuildimprovedebuggingefficiency in basic programming tasks?
rq2 how much overhead does noworkflow introduce during initial script execution?
rq3 how much speedup does provbuild produce when re executing a script after a modification?
rq4 inreal worldsettings howdodatascientistsuseprovbuildin theirdaily work and whatbenefitsand challengesdo they experience?
we address rq1 using the results of a controlled experiment involving a lab setting with scripts constructed specifically for the experiment.
we address rq2 and rq3 using quantitative measures of provbuild runtime and overhead.
we conducted another user studyinvolvingdatascientistsusingprovbuildontheirownanalysis scripts in the wild to answer rq4.
study controlled laboratory experiment to answer rq1 we conducted a controlled lab study to quantify provbuild s ability to reduce the time to complete a task and to obtain empirical insights into real world challenges.
we asked participantsto performaseries ofdebuggingtasks withandwithout provbuildandevaluatedtheirbehaviorbothqualitativelyandquan titatively.thestudydesignwasdrivenbythefollowinghypotheses hypothesis1 provbuildwilldecreasetaskcompletiontime.
since the provscript is shorter than the original file and its re execution time is shorter users will complete the tasks more quickly.
hypothesis2 provbuildwilldecreaseusers cognitiveload.
cognitiveloadisthetotalamountofworkingmemory resources being used.
because provbuild removes irrelevant 1090average task completion time task difficultyeasy hardcompletion time seconds programming tool provbuild conventional figure average task completion time for easy and hard tasks sorted by tool.
code reasoningaboutcodein provscript willbelesstaxing for users.
hypothesis3 participantswillshowmorepositivesub jectiveresponseswhenprogrammingwithprovbuild.
participants will report that their experience is better when using provbuild than when using a standard code editor.
.
participants and apparatus we used snowball sampling to recruit participants from multiplefieldsincludingcomputerscience electricalengineering appliedphysics andappliedmathematics.21volunteersparticipatedinthestudy 14men 7women 28yearsold m .
2undergraduatestudents 11graduatestudents 8professionaldatascientists .
all had some experience programming in python and had worked on at least one data analysis project.
we conducted alltrials inthe same roomusing a macbookpro laptop running macos.
the provbuild interface ran in the google chrome browser.
.
procedure eachexperimentstartedwithabasicdemographicandtechnical background survey.
next participants were given instructionson howtoeditineachmode provbuildandconventionalmode .they then engaged in one practice round with each tool.
the practice tasks were similar to the tasks given during the main study and let the participants familiarize themselves with the interface.
finally each participant completed a series of four debugging tasks.thesetasksweremodeledaftercommondataanalysisprocedures.
for each task participants were asked to minimally modify ascripttoagetspecifieddesiredoutput.thetaskconditionsconsistedofprogrammingmodes provbuildandconventional and difficulty levels easy and hard .
we designed the two difficulty levels of tasks and validated their difficulties q9 in the user study section .
.
.
easy tasks about math calculation and matrix transformation contained fewer than lines of code hard tasks about model training and parameter tuning contained nearly lines of code.thetaskorderingswerecounterbalancedbothintheorder of programming mode and difficulty level.
participants were given ten minutes to complete each task with instructions to complete each task as quickly and accurately aspossible.
we timed each task from the moment the participantaverage cognitive load test accuracy task difficultyeasy hardaccuracy .
.
.5programming tool provbuild conventional figure average cognitive load test accuracy for easy and hard tasks sorted by tool.
began reading the script to the moment she verbally expressedcompletion.
most participants completed each task comfortably within the time limit.
if the participant was unable to complete the taskwithinthe10minutelimit werecordedtheresultasunfinished.
intheprovbuildprogrammingmode participantshadtheoption to identify functions or variables they wanted to modify therebygenerating a provscript as shown in figure .
after generating a provscript participants could modify and execute that provscript insteadofworkingwiththeoriginalscript.afterparticipantsobtained the desired output they triggered the merge module tointegrate changes from the provscript back into the original file.
in the conventional programming mode participants edited the original script using a text editor and checked results by executing the whole script.
to evaluate cognitive load we examined their digital memorization behaviors in each task we asked participants to memorize ten random numbers in one minute before each task.
upontaskcompletion participantswereaskedtorecallthenumbers.
if participants were able to recall more numbers this was indicativeoflightercognitiveloadduringtaskcompletion.after completing each task the participants were given a final questionnaireaskingthemtorespondona7 pointlikertscale.thefirstsix questions were the nasa tlx standard questions which evaluate perceivedworkload andprovidesubjectiveratingsalong sixsubscales mentaldemands physicaldemands temporaldemands own performance effort level and frustration level .
the remaining three questions evaluated the user s perceived selfefficacy and subjective assessment of ease of use and effectiveness.
attheendoftheexperiment participantswereaskedwhetherthey had any feedback concerning provbuild.
each participant spent approximately minutes completing the experiment.
.
data analysis thiswasawithin subjectsstudywithtwofactors taskdifficulty easy hard and programming tool conventional provbuild and the following measures completiontime.
we measured the completion time from themomenttheystartedreadingthescripttothemoment they declared that they were done.
for participants who 1091table summary of the results.
provbuild and conventional columns represent the average experiment results under both taskdifficultyinthecorrespondingeditingmodes.allninesubjectivemeasureswerereportedona7 pointlikertscale while self reported preference is reported as the sum of nine responses lower indicating higher preference.
we used the holm ssequentially rejective bonferroni procedure since we tested multiple simultaneous hypotheses.
we report both raw and ad justed p values.
statistically significant results are marked with an asterisk.
hypothesis provbuild conventional raw p values adjusted p values sig.?
h1 completion time .70s .18s .
.
h2 accuracy on cognitive load test .
.
.
.
h3 self reported preference .
.
.
.
table2 detailedsubjectiveresultsofthenasa tlxstandardquestionsandsubjectiveassessmentquestions.theanswerwere rated on a point likert scale.
means the main effect for tools is statistically significant p .
questions provbuild conventional p values sig.?
.
how much mental and perceptual activity was required?
low high .
.
.
.
how much physical activity was required?
low high .
.
.
.
how much time pressure did you feel due to the pace at which the tasks or task elements occurred?
low high .
.
.
.
how successful were you in performing the task?
how satisfied were you with your performance?
low high .
.
.
.
how hard did you have to work mentally and physically to accomplish your level of performance?
easy hard .
.
.
.
how irritated stressed and annoyed versus content relaxed and complacent did you feel during the task?
relaxed stressed .
.
.
.
how confident were you about your answer s ?
low high .
.
.
.
how hard irritating was it to use the tool?
easy hard .
.
.
.
how hard was it for you to accomplish this task?
easy hard .
.
.
were unable to complete the task within the minute time limit we recorded their time as minutes1.
accuracyoncognitiveloadtest.
weaskedparticipantsto memorizetenrandomnumbersandrecallthenumbersafter each task.
we interpreted recall accuracy as a measure of cognitiveload morenumbersrecalledcorrectlyindicating lighter cognitive load .
self reported subjective measures.
after each task we askedparticipantssixquestionsrelatingtotheirperceived workload and three subjective assessment questions.
we computed the sum of all nine subjective responses with the same response order lower indicates better as the selfreported subjective measure two items were reverse coded foranalysissuchthatlowernumberalwaysindicatedamore positive response .
to guard against type i errors due to multiple hypotheses being tested we applied the holm s sequentially rejective bonferroni procedure to the analyses which introduces fewer type ii errors than the more common simple bonferroni correction.
we report both raw and adjusted p values.
duringevaluation wefirstsummedallninesubjectiveresponses to assess whether participants had an overall preference for either 1becausemoreparticipantsfailedtofinishintimeusingconventionalmoderather than provbuild mode trimming the completion time to minutes for incomplete tasks did not unfairly advantage provbuild during analysis.mode two items were reverse coded for analysis .
we then conducted a statistical analysis of each question separately.
.
study results .
.
main analyses.
the main results are summarized in table .
everyonewhocompletedataskintheallotted10minutesdidso correctly.however 1ofthe21participantsdidnotfinishaneasy task with either programming tool.
of the participants did not finish a hard task with the conventional mode while only one did not finish with provbuild.
we validated task difficulty to ensure that the provbuild and conventionaltaskswerecomparable q9 thereisnosignificant difficultydifferencebetweenthetwoeasytasks averageddifficulty rating .
on a point likert scale f .
p .
and two hard tasks averaged difficulty rating .
on a point likert scale f .
p .
respectively.
as shown in figure participants had statistically significant shorter average completion time f .
raw p .
adjusted p .
using provbuild m .
seconds than using the conventional mode m .
seconds .
hypothesis was supported.
provbuild decreased average task completion time and significantly improved programming efficiency in both task difficulty levels.
participantshadgreaternumberrecallaccuracyafterprogramming with provbuild m .
than after using the conventional mode m .
as shown in figure .
this main effect 1092was statistically significant f .
raw p .
adjusted p .
.theseresultssupporthypothesis2andindicate thatprovbuildwasabletolightencognitiveload.inotherwords provbuild is less taxing on the user s mental resources.
participants also reported being more satisfied overall after programming with provbuild m .
lower is better than with theconventionalmode m .
.thedifferencewasstatistically significant f .
raw p .
adjusted p .
.
hypothesis3wassupportedbyoursubjectivedataanalysis participants overall preferred provbuild over conventional processing methods.
also those who preferred conventional mode commonly stated theirpreferencewasduetothefactthattheyweremorefamiliar withtheconventionalprogrammingmethodthanwithprovbuild.
ofthe21participantsindicatedthattheyfeltitwasmoreconvenient to program with provbuild in the latter tasks as they became more familiar with the interface.
.
.
additional analyses.
table presents the detailed subjective results.
these self reported results demonstrate that the participants experienced significantly less mental effort q1 f .
p .
andfeltlesstimepressure q3 f .
p .
when using provbuild.
participants also felt that the tasksweresignificantlyeasierandlessirritatingtouseprovbuild than the conventional interface q8 f .
p .
.
when using provbuild participants also experienced relatively lowerlevelsofirritationregardingthecodingtask q6 f .
p .
andhigherlevelsofperceivedsuccessintask completion q4 f .
p .
.
these differences are marginally significant p .
.
study performance evaluation toanswerourperformance relatedresearchquestions rq2and rq3 weranbenchmarksonaubuntu18.04ltscomputerwith corei53.5ghzcpus16gbofmemory runningwithpython2.7andsqlite3.
noworkflow sstorageengine .noworkflowintroduces three sources of overhead.
it s possible that a different provenance capturemechanismwouldproduceloweroverheads butanalysisofdifferentcapturemechanismsisoutsidethescopeofthisstudy.first noworkflowinitializesitsdatastoragepriortoscriptexecutioninapreprocessingstep.second duringinitialscriptexecutionforwhich we collect provenance noworkflow s dynamic analysis introduces overhead.third noworkflowwrites itsprovenance datatoasqlite database during execution sqlite is not a terribly performant database.wereporttheseoverheadsintable3.notethatweran an unmodifiedversion of noworkflow in thisstudy.
as provbuild does not depend on all the functionality of noworkflow it s likely thatastreamlinedimplementationofnoworkflowcouldreducethe overhead.
.
initialization slowdown toquantifyprovbuild soverhead rq1 wecollectedpythonscripts frompublishedworkandcomparedscriptlengthandrunningtimes with and without provbuild.
dataverse is a platform for publishing datasetsusedinresearchpublications .weuseditsprogrammaticapi toobtainreal worldpythonscripts.wequeriedharvard university s public dataverse instance for every archiveddata set containing python scripts.
we then downloaded the 92published data sets including python code.
unfortunately manyof the archived data sets were missing key files.
only of the containedboth scriptsand theaccompanyingdata.
ofthose scripts only eleven ran to completion as published.
table3showsthebreakdowninrunningtime.executiontime increasesdramatically inthebestcase byonly56 butintheworstcasebyaroundafactorof30.themajorityofthisoverheadisduetonoworkflow sdynamicprovenancetracking.writingprovenanceto the database also adds significant overhead column storage time .
otherprovenancetrackingsolutions keepprovenanceinmain memory and write it persistently after execution this approach seemsattractive.aswewillseeinsection7 usersdidvoiceconcernovertheinitialruntime butnotenoughtopreventthemfromusing provbuild.
.
debuggingspeedup to demonstrate how provbuild can ultimately increase development efficiency rq2 we measured provbuild s performance after makingthreetypesofchangestoeachoftheelevenscriptsfrom table .
a class achange directly alters script output e.g.
changingtheformatoftheoutput.a classbchangealtersaninputfile or input variable.
a class cchange modifies the parameter of a functioninthescript e.g.
changingthevalueofamodelparameter.
for those eleven scripts we randomly selected one of each type of change and measured how long it took to execute the provscript produced by provbuild.
the speedup inherently depends on the length of the code path following the edit.
as class achanges affect only the output stage of analysis provbuild often generates significantly shorter scripts and produces significant speedup.
for our eleven scripts these speedupsrangedfromafactorof1.78to39.
i.e.
the provscript ranalmost40timesfasterthanthefullscript .table3showsthat theprovscript sgeneratedfrom classachangeshad74 fewerlines of code on average.
class bandclass cchanges induce smaller speedups.theresulting provscript sretained onaverage and of the lines of the original script resp ectively while the speedups averaged .23x and .46x respectively.
provbuild explores the dependencies downstream of the edits.
speed ups are smaller becauseprovbuildmustretainallthedownstreamdependencies theearlierinthescriptamodificationismade themoreofthescript mustberetainedforre execution producinglongerre execution times.
even in the worst case class b we attain some speedup.
inallthreeclasses provbuildisabletousestoredprovenanceto shorten run time.
study deployment in the wild we conducted another user study to evaluate provbuild s usefulness rq4 andefficacyfordatascientistsfromdifferentdomains.
the study was a real world deployment of the system in which participants could choose when and how to use the tool.
we ranthis field study to see if participants would choose provbuild inreal scenarios in place of other tools available to them.
we used surveys to obtain feedback from participants.
participants received noincentivetouseprovbuild feedbackwassolicitedonlyaftertheyusedit.weapproachedthe21participantsfromthepriorstudy and 1093table3 comparisonofrunningtimesandlinesofcodeofdataanalysisscriptexecutedwithoutprovbuildandwithit averaged over runs variances negligible script locoriginal exec timeruntimes w noworkflow class a class b class c preprocessingexec timestorage timelocre exec time speedup locre exec time speedup locre exec time speedup .
.
.
.
.
.33x .
.58x .
.71x .
.
.
.
.
.48x .
.28x .
.03x .
.
.
.
.
.24x .
.10x .
.21x .
.
.
.
.
.31x .
.08x .
.72x .
.
.
.
.
.07x .
.37x .
.37x .
.
.
.
.
.78x .
.14x .
.53x .
.
.
.
.
.04x .
.15x .
.64x .
.
.
.
.
.53x .
.23x .
.36x .
.
.
.
.
.64x .
.20x .
.81x .
.
.
.
.
.28x .
.25x .
.57x .
.
.
.
.
.74x .
.19x .
.06x 12ofthem 8men 4women agreedtoparticipateinthisstudy.the detailsofthestudywererevealedonlyonceaparticipantagreedto participate.
.
procedure and data analysis wegaveparticipantsaccesstoprovbuildforoneweek.thisallowed themtoexploreandusethetoolforpythondebuggingintheirdaily work.weintentionallygaveparticipantscompletelatitudeabout when they used provbuild.
at the end of each day we asked the followingsurveyquestionstounderstandifandhowparticipants chosetouseprovbuild didyouuseprovbuildtoday?ifso what wereyoutryingtoaccomplishedbyusingit?
whenyouused provbuild whatdidyoulikeaboutit?
didyouhaveanyproblems usingprovbuild?ifso pleasedescribethem.
areyouinclinedtouseprovbuildagain?why?
wouldyourecommendprovbuildto others why?
these five questions were all free response questions withnocharacterlimitrequirement.weaskedthemdailyandonly requiredthemtoansweronthedaysthattheyhadchosentouse provbuild.
toanalyzethecollecteddata weutilizedqualitativedataanalysis methods and performed the iterative inductive analysis .
two researchers first independently clustered the data and opencodedthedatasetintothemes.themesincludedcommonly mentioned benefits and common challenges.
next the researchers collaborativelyreviewedthedata comparedcodes identifiedemergent themes and discussed discrepancies to develop a mutuallyagreed upon set of themes.
they then performed an additional roundofindependentcodingandverifiedtheemergentthemesand associated transcript segments.
.
study results in this study we collected surveys from participants.
allparticipants chose to use provbuild at least once while four par ticipants used it more than once in a one week period.
out of 12participantsindicatedthattheywoulduseprovbuildinthefuture q4 .
participants reported a large number of programmingscenarios in which they used provbuild in their daily work.
onecommonsituationwasscriptdebuggingandparametertuning.participants used provbuild to debug simple python scripts p12 and multiplescriptswith complicateddependencies p1 or finelytune parameters in code p9 .
several participants focused more on writingscriptsformodeltraining whilesomewereworkingonmath calculations in python.
.
.
provbuild benefits.
participantsmentionedtendifferentbenefits of using provbuild.
the most frequent benefits mentionedby nine participants were that provbuild saved programming timeandallowedusersto findcodedependenciesmoreeasily it helps find all the dependent code pieces when you target a specificproblem whichgreatlysavestimeandreduceserrors.
p1 it explicitly tells me the dependence of certain functions and data.
itrunsreallyfast.
p3 itspeedsupcalculationsbystoringfiledata withinthecode.
p11 anotherrespondentsreported itreallysaves programming time both execution time and thinking time p8 .
provbuild isalso consideredparticularly beneficialfor understandingprojectworkflow mentionedbysixparticipants ilike thatitcutdownontheamountofcodeihavetolearnandunderstand.
p9 it can provide the part that i want to rerun so i don t need to do thewholepreprocessingeverytime.
p2 itwouldhelpwithcomplex programming workflow.
p7 provbuild reduces the need for memorization of the details in a workflow by providing shortened scripts which makes programminganddebuggingeasier.fiveparticipantsmentionedthis benefit whichalsosupportshypothesis2fromsection5 inrealworldstudies ilovethisbecauseitcankeeptherecordsoftheold files and i don t need to remember the workflow of all my programs.
the only thing i need to decide is which part of the program needs to be changed.
p6 another common benefit mentioned by seven participants is its usefulness .it simplifies p4 thedebuggingprocessand shortens p2 programscripts it sreallyeasytomakechangesinoldscriptsin ordertomatchnewmodels.
p6 ithinkit susefultodebugprograms with complicated steps.
p4 threeparticipantsexplicitlymentionedthatprovbuild provides intermediate results to facilitate programming process when 1094i do math in python i often need to print all variables to find the problemandiforgettodothatsometimes.withprovbuild icancheck thoseconstantsineverystepanditreallyhelps p8 iliketheidea of considering the intermediate results as constants.
most of the time i only care about the follow up calculation after those values.
p4 overall participants expressed a preference for using provbuild and mentioned that provbuild improves the debugging process mainlybyreducingprogrammingtime allowinguserstofinddependenciesandunderstandtheirworkflowmoreeasily reducing theneedformemorization.participantsdonotreportanysignificant barriers to independent use.
.
.
provbuild challenges.
participantsalsoraisedseveralconcerns after their use with provbuild.
the predominant concern stated by five participants was the slow initial run time relative to running without provbuild the initial execution with provbuild takes longer than i expected especially when the training files are large.however onceifinishthefirstrun itultimatelysavestime.i would like to continue to use provbuild for future debugging.
p2 i found that the initialization of provbuild takes a bit longer.
i guess it needs to trace everything and keep the records.
p7 whileprovbuildwasabletogenerateanewsimplifiedscript two participantswereconcernedaboutits accuracy p2 andcompleteness provbuildmayhavelimitationintrackingthe provenanceof programexecution whichmayreturnanincompleterelevantcodesegment.
p12 althoughsomeparticipantsexpressedconcernabout the validity of provbuild no one in this study obtained incomplete or incorrect results.
two participants explicitly mentioned that provbuild should supportmultipletypesofsearchtargets icouldn tsearchfora variablethatwasafunctionargument.
p10 itseemslikeprovbuild can only search for global variables.
p2 further concerns about provbuild are its scalability to process a large project.
p5 and memory usage p6 .
finally since the participants have their own programming styles one of them asked is it possible to show some visualizationfromprovbuild?
p3 whileanotherwonderedthat itwould be better if it works with jupyter.
p4 overall wefoundthesecriticismsencouraginginthattheyaddressedissuesweknewabout e.g.
initialruntime orthatcouldbe easily addressed e.g.
integration with jupyter .
convincing users that provbuild produces correctresults is an interesting challenge to address in future work.
discussion provbuild allows data scientists to perform basic data analysis routinewithlowercompletiontimeandlesscognitiveload thereby increasing their programming efficiency.
although its provenance capture system increases initial runtime participants found thecost benefit trade off worthwhile demonstrating that its utility compensated for the increased initial runtime.
threats to validity.
regarding internal validity user performance on the controlled experiments might depend on a user s ability to comprehend unfamiliar code.
to mitigate this threat we didwithin subjectexperimentstestingeachparticipantunderall conditions theindependentevaluationreduceserrorsassociated with individual differences.
a remaining challenge is to design astudy that is rigorously controlled but allows users to work on code with which they are already familiar.
participants of the deployment study may have been inclined to answerfavorably since we wereasking about theirexperience using provbuild.
to reduce such bias we used impersonal surveys rather than face to face interviews.
the greatest external threat to validity is our assumption that noworkflow captures provenance correctly.
its use in reproduction studiessuggeststhatthecommunitybelievesittobeappropriateforreproducingcomputation whichiseffectivelyhowweuseit .
it is also possible that we have not identified all instances in which theprovenancedoesnotcapturealltheinformationnecessaryto produceacompleteandcorrect provscript.shouldsuchsituations arise our experience suggests that the tools we ve developed make it possible to easily collect additional information.
limitationandfuturework.
provbuild sinitialruntimeoverheadmightposeanobstacletoadoption soourimmediateplans includingchangingorimprovingtheprovenancecollectionstrategy disabling parts of the provenance capture that are unnecessary for thisapplication andtuningtheremainingpartsofit.rdatatrackerlite is an r tool similar to noworkflow which showed that capturingonlythedetailneededforprovbuildreducesoverheadbyroughly50 .integrationwithawidely usedide suchaseclipse orotherinteractivecomputationalenvironments suchasjupyter willalsofacilitateadoption.whileprovbuildiscurrentlypythonspecific it relies only on the provenance output and the abilityto parse the input source code.
it should be straight forward toadapt it to other languages that have provenance tracking support e.g.
r .wealsobelieveitispossiblefortheselanguagespecificcapturetoolstoproduceprovenanceinalanguage agnosticform whichwouldmakeitpossibletodevelopalanguage agnostic provbuild.
in the longer term we are looking for other opportunitiestoleverageprovenancetohelpprogrammersstreamlinetheir development process.
data availability.
provbuild is available on the open access repository zenodo .
related work make is a build automation tool that uses static analysis to execute only those steps of a build process that depend upon modifications.ratherthanusingprovenance makeuses makefile sto explicitlykeeptrackoffiletargets inter filedependencies andcom mandsequences.usersbuild makefile smanuallyoruseadditional tools e.g.
autoconf to produce them.
makeis similar to provbuild in its ability to reduce re execution time.
however make does not address the cognitive load issue nor does it help users identify problems more efficiently.
starflow is a make like tool that tracks data dependencies in pythonatfunction callgranularity .thedependencytracking procedure for starflow uses static analysis dynamic analysis and optionaluserannotationsforspecifyingfunctioninputsandoutputs.
provbuild extends this work by removing the need for annotations to track dependencies.
like make starflow does nothing to reduce cognitive load.
incpyisacustom open sourcepythoninterpreterthatperforms automaticmemoizationandpersistentdependencymanagement 1095atthefunctioncalllevel.incpyautomaticallysendsfunctioncalls inputs andoutputstoapersistenton diskcacheimmediatelybefore the targetprogram isabout toreturn froma functioncall .by automatically caching and reusing the results of function calls incpyenablesprogrammerstoiteratemorequicklyontheirscripts in a manner similar to provbuild.
we wanted to compare incpy re execution times with those of provbuild unfortunately incpyhas not been maintained and we were unable to get it to run on modern python scripts.
similar to incpy joblib is a dynamic analysis tool that transparently caches arbitrary python objects to avoid unnecessary computationin python .incpy andjoblibaresimilar toprovbuild in the re execution part but they do not track dependencies other than functional ones and also do not address cognitive load.
provbuild uses both static and dynamic change impact analysis cia .generally ciaidentifiesthepotentialconsequences of a change and estimates how to propagate the ramifications of that change.
static cia analyzes the syntax semantics and change histories of a program without directly executing it .
dynamicchangeimpactanalysiscapturesinformationbyexecuting programs on a real or virtual processor and utilizes dynamic informationaboutprogrambehaviortodeterminethepotentialeffects ofachange .ciahasbeenusedinlargeandevolving industrial software systems to evaluate test suites when a softwaresystemchanges comparelargeprogramswithdifferent versiontohighlightchanges andanalyzechangepropagationin largesoftwaresystemsandarchitectures .professionalsoftware engineers leverage cia to estimate large software project changes.
tothebestofourknowledge provbuildisanovelapplicationof cia using it to improve runtime and cognitive load during data analysis development tasks.
incrementalcompilationandself adjustingcomputationaretechniquesthatattempttosavetimebyrecomputingonlythoseoutputs that depend on changed data .
most of these techniques rely ondependencygraphsthatrecordacomputation sdataandcontrol dependencies so the change propagation algorithm can identify sectionsthatareaffectedbyausermodificationandrebuildonly these relevant portions.
the major result of change propagation is to incrementally build the script.
it is similar to our work while provbuildalsodirectlyimprovestheuserprogrammingexperience.
conclusion provbuild is a novel use of language level provenance that streamlines the iterative development process by allowing a developer tofocusonlyonthecodethattheprogrammerisdebugging.we use provenance to construct a dependency graph and generate a simplified script containing only those code blocks pertaining to a user specified function or variable.
this accomplishes three things.
first ithelpsusersavoidunnecessarychangestotheirscript which frequentlyintroducenewbugs .second itmakesiteasierto identify and reason about code modifications that are necessary to correctlyachieveagoal.third itreducesexecutiontimeandusers cognitiveload becauseonly aportionof theoriginal scriptisrun ateachiteration.together thesereducethetimeandeffortittakes to debug data analysis pipelines.
the results of the quantitativeevaluation and the user feedback show that provbuild can be aneasy effective and efficient tool for data scientists who use scripts toprocessandanalyzedata.tothebestofourknowledge thisis thefirsttimelanguage levelprovenancehasbeenusedtoaddress programmer efficiency.