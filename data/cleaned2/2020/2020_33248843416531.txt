cp detector using configuration related performance properties to expose performance bugs haochen he national university of defense technology china hehaochen13 nudt.edu.cnzhouyang jia national university of defense technology china jiazhouyang nudt.edu.cnshanshan li national university of defense technology china shanshanli nudt.edu.cn erci xu national university of defense technology china xuerci nudt.edu.cntingting yu university of kentucky lexington ky usa tyu cs.uky.eduyue yu national university of defense technology china yuyue nudt.edu.cn ji wang national university of defense technology china wj nudt.edu.cnxiangke liao national university of defense technology china xkliao nudt.edu.cn abstract performance bugs are often hard to detect due to their non failstop symptoms.
existing debugging techniques can only detect performance bugs with known patterns e.g.
inefficient loops .
thekeyreasonbehindthisincapabilityisthelackofageneraltestoracle.
here we argue that the performance e.g.
throughput latency execution time expectation of configuration can serve as a strong oracle candidate for performance bug detection.
first prior work shows that most performance bugs are related to configurations.
second the configuration change reflects common expectation on performance changes.
if the actual performance is contrary to the expectation the related code snippet is likely to be problematic.
in this paper we first conducted a comprehensive study on real world configuration related performance bugs cpbugs from representative software systems.
we then derived seven configuration related performance properties which can serve as the test oracle in performance testing.
guided by the study we designed and evaluated an automated performance testing framework cp detector for detecting real world configuration related performance bugs.
cp detector was evaluated on open source projects.
the results showed that it detected out of existing bugs and reported new bugs.
ccs concepts software and its engineering software performance.
co first author permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acmmustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
ase september virtual event australia association for computing machinery.
acm isbn ... .
performance bug detection software configuration performance property acm reference format haochen he zhouyang jia shanshan li erci xu tingting yu yue yu ji wang and xiangke liao.
.
cp detector using configuration related performance properties to expose performance bugs.
in 35th ieee acm international conference on automated software engineering ase september virtual event australia.
acm new york ny usa 12pages.
introduction modern software systems are increasingly configurable and thus becoming more adaptive to various scenarios.
however as configuration can in directly affect performance e.g.
altering resource allocation performance bugs occurrences are also surging.
a recent study suggests more than half of performance bugs are due to incorrect handling of configurations .
in this paper we term these performance bugs as configuration handling performance bugs cpbug .
note that a cpbug is different from a misconfiguration where the former focuses on incorrect configuration handling in source code and the latter revolves around user induced configuration errors.
figure1illustrates a real world cpbug related to the configuration option sort buffer size in mysql as well as the failure symptom rootcause andfixmethod.thisoptionisusedtoalterthe buffer size for sorted results triggered by group by z desc .
ideally a larger buffer should improve the sorting performance since mysql can cache more results.
however for the sql query in the upper right corner of figure users actually suffer from up to .
slowdown instead of benefiting from larger buffers i.e.
increasefrom 2mto8m .
the root cause is redundant memory allocation.
specifically the buffer is allocated before each sub query line and freed immediately at the end of the sub query line .
the fix method is to allocate the buffer at the first sub query line and reuse it at all subsequent sub queries line .
this bug serves as ui .
oufsobujpobm pogfsfodf po vupnbufe 4pguxbsf ohjoffsjoh !
!
select if select sort keys my malloc sort buffer size ... if !table sort.sort keys sort keys my malloc sort buffer size ... ... x free sort keys if !subselect x free sort keys !
select a b select x from t2 where y b order by z desc limit c from t1 sort buffer size !
select.
figure redundant memory allocation in mysql.
this bug happensbecause mysql allocates memory in each sub select.
a representative example of performance bugs caused by incorrect configuration handling.
this is different from a user misconfiguration where users may suffer from performance degradations when setting up a buffer size larger than the memory limitation.
there has been much research on detecting performance bugs.
someresearchhasproposedprofiling basedtechniques whichaims to detect performance bottlenecks that can cause significant slowdowns .
however such slowdowns can be self induced due to necessarily intensive computation.
the lack of test oracles makes it difficult to decide if a slowdown indicates a performance bug .
alternatively some research has proposed to use inefficient code patterns as test oracles.
for example toddler identifies loops with inefficiency memory access patterns which imply potential performance bugs.
these works are hard to detect cpbugs which may or may not contain the patterns.
there has also been some research focuses on the relationship between configuration and performance including configurationperformance modeling and configuration based performance tuning .
the former aims to predict performance for given configurations while the latter studies the tendency of performance changes when tuning configurations and finds the optimal configurations with regard to the performance.
the performance tendency can be obtained by sampling configuration values and fitting corresponding performances.
this is different from a performance bug which may be triggered by a certain value.
in this paper we propose cp detector1 an automated testing framework to detect cpbugs.
the key insight of cp detector is that when tuning a configuration option a mismatch between the expected and actual performance changes usually indicates a cpbug.forinstance userswouldexpectperformanceimprovement when allocating a larger buffer.
if however the actual performance drops the mismatch between the expected and actual performance changesmayindicateacpbug.thiskindofperformanceproperties can be used as test oracles to expose cpbugs.
for example the propertyinfigure 1canbedescribedas increasingresource related configuration options should improve the performance .
to understand cpbugs and guide the design of cp detector we first conducted an empirical study on real world cpbugs from software systems.
we found that .
cpbugs can 1the annotated bug data set and tool can be found in our publicly available repository exposed by detecting mismatches between the expected andactual performance changes when tuning configuration options.
we further studied the configuration options involved in the cpbugs and summarized seven performance properties from these options.
each property can be formalized as a three tuple type direction expectation indicating when tuning configuration options of a given type e.g.
resource according to the direction e.g.
increasing the software should have the expectation e.g.
improving performance change.
cp detector contains two major steps to automate the process ofexposingcpbugs.givenaconfigurationoption cp detector suggests the performance properties that the option should hold by learning configuration documentation.
the challenge is to understand the natural languages and build relationships between the languages and the properties.
to address this cp detector applies natural language processing nlp and association rule mining arm techniques to automatically derive the properties from the documentation.
cp detector samples value pairs of the option and test if one value pair can expose a cpbug.
this is challenging when the option is numeric since the value range may be extremely large thus it is hard to test all pairs.
in this regard we conduct an empirical study on numeric options to investigate the value ranges that can trigger cpbugs and propose a heuristic sampling strategy to reduce the sampling space.
to evaluate the effectiveness of cp detector in detecting cpbugs we reproduced known cpbugs from the cpbugs in our study and to avoid over fitting we also reproduced known cpbugs not included in our study cpbugs in total so far all we can reproduce and evaluated cp detector on all bugs.
the results show that cp detector can successfully expose bugs using the suggested performance properties.
the rest cases escape mainlybecausetheinformationprovidedbyconfigurationmanuals is limited so cp detector can not make the right suggestion on the performance properties.
on the other hand toddler one of the most effective bug detection tools among existing works detected out of the cpbugs.
in the meantime cp detector detected unknown cpbugs on the same set of software projects.
we have reported the bugs to developers and nine of them have already been confirmed or fixed at the time of writing.
in summary this paper makes the following contributions we conducted an empirical study on real world cpbugs from12softwaresystems.thefindingsareusedtoguidethe design of test inputs and test oracles.
we designed and implemented cp detector an automated framework to detect cpbugs.
cp detector can automatically suggest performance properties for configuration options and generate configuration values to expose cpbugs.
we evaluated cp detector on software systems.
the resultsshowthatcp detectordetected43outof61known cpbugs and unknown bugs.
ten of the unknown bugs have been confirmed or fixed by developers.
understanding cpbugs in this section we take an in depth look into the cpbugs through an empirical study.
we manually collected real world cpbugs from bug tracking systems mailing lists and fix commits of software table software systems and cpbugs used in the studies.
software kw cpbugs software kw cpbugs mysql httpd mariadb h2 mongodb squid postgresql tomcat rocksdb gcc derby clang kw the cpbug candidates identified using performance related keywords.
systems.
in these cpbugs we found a majority of configuration options have expected performance changes when being tuned.
we alsostudiedtheperformancepropertiesoftheconfigurationoptions involved in these cpbugs and how the option values triggered the cpbugs.ourfindingsareusedtoguidethedesignof cp detector.
studied subjects.
table1shows the software systems used in our study.
these projects cover a variety of domains including database webserver andcompiler.theseprojectsareperformancecritical highly configurable e.g.
httpd has more than configuration options and widely deployed in the field.
therefore cpbugs from these projects are likely to be rich in numbers and severe in consequences .
also these projects are open source and well maintained by the community.
this allows us to not only check the buggy code snippets but also gather related details based on the developers discussions.
cpbug collection.
we collected cpbugs from three sources bug tracking systems e.g.
jira bugzilla mailing lists and fix commits.westartedbysearchingtheabovesourcesusingheuristic keywords e.g.
slow long time performance .
this process identified2 469candidates.wemanuallyanalyzedthesecandidates eachofwhichisdeemedasacpbugiftuningaconfigurationoption would cause a performance bug.
this process yielded columns and in table cpbugs.
.
prevalence of unexpected performance changes in cpbugs each cpbug has one or multiple triggering configuration option s .
for each option we use expected performance changes of two values of the configuration option as performance properties and exposecpbugsbydetectingviolationsoftheproperties.toevaluate to what extent the property based approach can expose cpbugs we study the prevalence of unexpected performance changes when tuning configuration options of the cpbugs.
toachievethis wemanuallystudiedallthe173cpbugscollected above andfound150 .
ofthemhaveunexpectedperformance changes when tuning configuration options.
this result indicates the performance expectation can serve as an effective oracle for exposing cpbugs.
the remaining .
cpbugs cannot be exposed mainly because the configuration options have inconsistent expectations.
for example innodb fill factor defines the percentage of space that is filled during a sorted index build with the remaining space reserved for future index growth.
in production it should be carefully tuned according to the workloads and hardware.
while in mysql when setting it to indexedupdates get .
slower because page split has to be performed for every updatedue to no empty space for the changed index.
developer fixes this by preserving of the space for any of its value.
increasing or decreasing innodb fill factor does not necessarily have common expected performance change.
finding1 amajority .
ofthecpbugshaveunexpected performance changes when tuning configuration options.
this result indicates the performance expectation can serve as an effective oracle for exposing cpbugs.
.
performance properties in cpbugs we studied the cpbugs to understand the performance properties of the bug introducing configuration options.
the findings can be used to guide the design of cp detector for automatically extracting the properties to detect cpbugs for any target software.
we manually studied the semantics of the configuration options involved in the cpbugs and summarized five semantic types i.e.
optimizationon off non functionaltradeoff resourceallocation functionalityon off andnon influenceoption .
each configuration type has two tuning directions e.g.
turning on and turning off or increasing and decreasing.
then we analyzed the cpbugs and found bothnon functionaltradeoff andfunctionalityon off options triggered cpbugs in two directions while other types only triggered cpbugs in one direction.
after that we analyzed the expected and actual performance changes from the bug descriptions for each direction of each type.
the result is shown in table each performance property is associated with its configuration type column tuning direction column and expected performance change column .
thesethreepartscorrespondtothefactorsofthethree tuple type direction expectation defined in .
besides the properties column shows the actual performance change of cpbugs andcolumn shows the numbers of cpbugs that break each property.
for example the first configuration type is optimizationon off when tuning an optimization option from off to on it means turning on an optimization strategy and the performance is expected to be enhanced.
if however the actual performance drops there is a potential cpbug.
in our dataset cpbugs violate this property.
below we provide details of the properties in each type of configuration options.
optimizationon off.
in this category a configuration option is used to control an optimization strategy.
specifically when the optimizationisturnedon theapplication sperformanceisexpected tobeimproved.consideracpbugexample mysql .for sql queries like select from t where c1 and c2 or c3 mysql can speed up at least by enabling the optimization strategy index merge on which can merge the indexes of different columns.
however when the queries end with order by c1 limit the performance degrades by with the optimization turned on.
this is because the whole indexes of the columns are merged i.e.
two index range scans a merge and a join whereas only the top rows are required.
developers fix this bug by changing the triggering conditions of the optimization strategy controlled by index merge.
table performance properties in cpbugs.
pp idperformance properties pp cpbugs configuration option typetuning direction expected performance changeactual performance change cpbugs pct.
source value target value pp optimization on off off on rise drop .
pp non functional tradeoff anti performance pro performance rise drop .
pp non functional tradeoff pro performance anti performance drop more than expected drop .
pp resource allocation small large rise drop .
pp functionality on off on off rise drop pp functionality on off off on drop more than expected drop .
pp non influence option random random keep drop .
a value that implies better performance at the cost of lower security consistency integrity and etc.
opposite to pro performance.
non functionaltradeoff.
in this category a configuration option is used to achieve the balance between performance and other non functional requirements of the program.
we found two properties regarding this configuration type.
in pp tuning the configuration option value to relax a requirement is expected to achieve a performance gain.
for example a database can achieve higher performance by relaxing the acid properties a set of properties to ensurecorrectnessandconsistency .inthecpbugmysql innodb flush log at trx commit controls the acid property.
when setting to relaxed acid however the performance of the oltp update benchmark is lower than the performance when setting to full acid .
the root cause is that two logging func tions i.e.
commitandlog write both use the log sys mutex lock to write to the same buffer.
this in return causes extra lock contentions that hurt the performance.
the fix is simply to use two independent buffers and remove this lock.
in this case switching ananti perf value i.e.
to a pro perf value i.e.
leads to performance drops causing a cpbug.
as for pp tuning the configuration option value to enable a requirement is expected to have a performance loss.
if however the actual loss is more than expected it still indicates a cpbug.
forexample gcc uses o0 o1 o2 o3 options to control the balance betweencompilationtimeandbinaryexecutionefficiency.ahigher olevel indicates more compilation time.
but in gcc switching from o0too2increases the compilation time from less than second to minute.
the cost is more than expected.
we describe the thresholds to measure more than expected in .
.
this is caused by a sub optimal algorithm induced by a process called branchprediction inthe o2level.thisbugisfixedbyadding an early drop condition in the algorithm.
it makes the compilation time reduce to less than second with o2.
resourceallocation.
in this category a configuration option is used to control resource usages e.g.
ram cpu cores .
allocating more resources generally results in better performance.
take the bug in figure 1as an example increasing the memory allocation to the sort buffer is expe cted to speed up the select order by operations.
however the performance of mysql degrades by causing user s complaints2.
this is pretty much the opposite of any other case i have seen.
in fact to make the query perform faster you need to set it to the smallest value the user of mysql who reported this bug.functionality on off.
in this category a configuration option isusedtocontrolanon performancefunctionalitybutindirectlyinfluences the system s performance.
we have two properties in this category.pp 5suggeststhatwhenanoptiondisablesafunctionality the system s performance usually increases.
for example in mariadb turning on log slave updates logs the updates of a slave receivedfromamasterduringreplication.however asdescribedin mariadb disabling this functionality increases the time fortheslavetocatchupduringreplicationby50 .thishappensbe causethehandlingcodeof log slave updates on getsoptimized as the software evolves while that of log slave updates off escapes.
developers fixed this bug by applying the same optimization to both situations.
while pp suggests that when a configuration option enables a functionality the induced performance overhead is allowed but shouldbewithinalimit.forexample inwebservers virtualhost isusedtoenablemultiplevirtualhostsintheserver.itisreasonable thatsettingmorevirtualhostscauseslongerstartuptime.however asdescribedinhttpd thesingleserverstartuptimegrows super linearlyasthenumberofvirtualhostsincreases anditwould take more time with virtual hosts than with the default setting.
the root cause of this bug is httpd uses a sub optimal way to parse the virtualhost directives in the configuration file.
developers fixed the bug by optimizing the data structure which decreasesthestartuptimefromseveralminutestomerely6seconds.
non influenceoption.
in this category a configuration option is not supposed to influence the system s performance i.e.
the performanceisexpectedtoremainthesameaftertuningtheoption.
for example users can choose proxy http default or ajp set mod jk as the connector between httpd and tomcat.
the two connectors are expected to have similar file transfer speeds.
but in httpd intheaixoperating system thefile transferspeed degrades from 8mb s to only 2kb s when switching from default proxy http connector to ajp connector under the same network condition.
this is because the implementation of aix socket buffer is conflicted with the encapsulation of the socket implemented by theajp13connector.
hence simply removing the encapsulation of the socket solved the bug.
.
triggering conditions of cpbugs to test the software against a property of a configuration option we need to sample at least two values referred to as vsrcandvtar mysql 32k 48m 4g mysql 8k 2g mysql 5m 16g mysql 64k 64m mysql 1m 16g 256g mysql 4m 16g mysql 5m 16g mysql 2m 16g apache apache apache apache mariadb 5m 16g mariadb 5m 128m 16g mariadb 64k 2m 64m mariadb .
mariadb mariadb 3m 16g mariadb mongodb 256m 8g 16g mongodb 256m 12g 16g mongodb 256m 1g 16g rocksdb 256m 2g 16g postgresql postgresql squid 4k 6g 16g 4k 1g 16g this bug requires specific workload.
figure value ranges that can trigger cpbugs dark gray .
from that configuration option as shown in the column of table2.fornumericaloptions e.g.
resourceallocation options itis difficult to enumerate all value pairs since the value ranges can be extremely large.
in this regard we conducted a study to investigate the value ranges of numeric options that can trigger cpbugs.
in our study .
of the cpbugs are exposed by numerical configuration options.
we successfully obtained the value ranges of cpbugs including configuration options out of the cpbugs by exhaustively and manually reproducing the bugs with different option values.
note that some upper bounds can be which is too large and may cause the performance falls the cliff due to resource limitations.
this behavior is difficult to be distinguished from actual cpbugs.
therefore we limited the upper bounds to our experimental resource limitations e.g.
cpu cores ram .
as illustrated in figure the dark gray areas show the value ranges where cpbugs can be exposed.
among .
out of the numeric options the ranges contain the minimum or maximum value of the option.
for example the cpbug mysql can be triggered when the configuration option sort buffer size is between32kand48m.thistriggeringrangecontainstheminimum value i.e.
32k of the overall acceptable range of the option i.e.
.thereasonbehindthisisthatnumericaloptionsusually affect the program control flow much less than data flow.
as a result changing numerical options tends to exaggerate or alleviate an existing bug if any in the current program path instead of triggering a new bug in a different program path.
finding2 .
ofnumericconfigurationoptionscantrigger cpbugs when being set to the minimum or maximum values.
the sampling numbers can be significantly reduced by fixing vsrcto the min values or fixing vtarto the max values.
cp detector design figure3showstheoverviewof cp detector whichtakesconfiguration documentation and the software under test sut as inputs and outputs cpbugs.
cp detector contains two major steps.
first cp detector infers performance properties for each configuration option i.e.
type direction expectation .
specifically cp detector trains the configuration documentation into a set of rules by natural language processing nlp and association rule mining arm .
these rules are used to distinguish differentcpbugs detectionsuggesting configuration related performance properties nlp preprocessing association rule mining suggesting typetype tuning directionstuning directions analysis target option test scenarios tt sutsampling result analysisrun potential cpbugconf.
docum.
propertyperf.
figure overview of cp detector.
configuration types.
therefore given a new configuration option cp detectorcanlabelitwithaparticularconfigurationtype.next cp detector infers the tuning direction for each labeled configuration option from the property specification and the configuration documentation.
as a result given a value pair of the new configuration option cp detector can determine their tuning direction.
the expected performance change is obtained according to the configuration type and the tuning direction.
second cp detector detects cpbugs by checking whether the outputs of a pair of test executions break the performance properties of the participating configuration option.
to achieve this cp detector samples a value pair of the option serving as two test inputs of the pair of test executions.
besides the participating configurationoption cpbugsmayalsorequireothertriggeringcon ditions i.e.
workloads other configuration options or the running stage of the software e.g.
start service shutdown .
cp detector combines these conditions as test scenarios and checks the outputs of the execution pair under each scenario.
finally cp detector tests each execution pair under each scenario multiple times and determines if there is a cpbug based on hypothesis testing .
.
suggesting performance properties since the configuration documentation of an application often describes the names functions and usages of configuration options it is widely exist easy to get and a good source to derive configuration related performance properties.
we next describe how to identify the type and the tuning direction for each configuration option.
.
.
identifying configuration types.
given a configuration option cp detector can automatically label it with a configuration type.
to achieve this cp detector leverages natural language processing and association rule mining to derive a set of classification rules from existing configuration documents.
specifically we manually analyzed a total of configuration options from applications and assigned each configuration option to one of the five types .
next a set of classification rules are automatically derived from the configuration documents associated with the options following three steps pre processing the documents to normalize words with both syntactic and semanticsimilarities mining association rules between word sequences and configuration types and selecting optimal rules used for labeling new configuration options.
table domain specific synonym tags partial tag name words in base forms resource memory buffer thread worker cleaner volumn size amount number perfpositive performance speed throughput perfnegative latency cpu time responses time opposeperf integrity compression security reliability self this option this directive config name the complete tag and word lists can be found in our public repository.
normalizingwords.
in this step cp detector identifies both syntactic and semantic similarities of different words and similar words will be regarded as the same one in the following mining process.
each configuration of the dataset is in the form of s1 s2 ... type wheres1ands2stand for the first and the second sentences in the configuration description and typerefers to the configuration type.
cp detector first split the description into sentences sharing the same type s1 type s2 type etc.
after that cp detector normalizes the words in each sentence from both syntactic and semantic aspects.
in specific for each word cp detector infers the part of speech pos tag e.g.
noun verb by using spacy .
on the other hand we manually studied the descriptions of the options and defined domain specific synonym tags as shown in table traditional methods of identifying synonymsmaybehardtodealwithwordsincomputerscience .we alsoreferencedonlineresourcesaboutdomain specificterminology during the classification .
the words will be normalized according to the syntactic and semantic tags.
for example both size of buffer and number of threads describe resource related configuration options.
cp detector normalizes both phrases into the same form nn volume in nn resource where nnand inare part of speech tags meaning noun singular or mass and prepositionorsubordinatingconjunction .volumeandresource are synonym tags in the first column of table .
miningassociation rules.
the goal of this step is to find the word sequences that appear exclusively and frequently in the descriptionsofaspecificconfigurationtype.weusethedesignprincipleof featuremine atypicalarmalgorithmforclassification on sequential data and implement it by ourselves to achieve our goal.
the output of featuremine is a set of class association rules cars which are in the form of w1 w2 ... typein our case wiistheithwordinthesequence .meanwhile thealgorithm outputs the confidence for each car.
the confidence is defined as the conditional probability of occurrence of typegiven w1 w2 ... appears.
one important parameter in the algorithm is min support.
weassign min support asusedinexistingsoftwareengineering studies which means w1 w2 ... should appear at least in configurations of type type.
another important parameter is the length limitations of cars.
a short car e.g.
or will be less informative thus we restrict len car len wherelenis a predefined threshold.
we will evaluate how to choose lenin .
.
3the complete part of speech tag list and corresponding meanings are available in optimal rules.
the above mining approach may generate millions of cars with many of them are repetitive.
when a car is a sub sequence of another car and the two cars have the same support cp detector rules out the short one since these two cars always appear at the same time and the longer one is more informative.
this process still leaves tens of thousands of cars.
in this regard cp detector selects a subset of cars as optimal rules which are measured by fscore the harmonic mean of the averaged confidences of cars in the subset and the proportionofconfigurationtypesthatcanbeclassifiedbyusingthe subset of cars.
the cars are ranked by confidence.
simply choosing the top n cars may get a high averaged confidence but not necessarily have high coverage of configuration options.
instead cp detector randomly samples numcars for each configuration type.
the cars are weighed by confidences during sampling therefore cars with higher confidences are more likely to be sampled.
cp detector then calculates the fscoreof the sampled cars.
the above process will be exhaustively repeated until the current highest fscoreis the theoretical highest fscorewith above .
probability according to the cumulative distribution function cdf .
then cp detector selects the subset of cars with the highest fscore.
the exhaustive sampling process is a one time effort users can directly use the optimal rules.
numis a predefined threshold and we will evaluate how to choose numin .
.
assigningconfigurationtypes.
with the optimal rules available cp detectordefinesavotingclassifier.givenaconfiguration description all rules that match the description will vote for their corresponding type and the weights are confidences of the rules.
cp detectorsuggeststhe typewiththehighestweightastheconfigurationtype whennorulesmatchthedescription cp detector can not suggest any type .
for example in mysql the description of the option innodb sort buffer size is specifies the size of sort buffers used to sort data during creation of an innodb index .
cp detector can match the word sub sequence size of buffers to data usingtherule nn amount in nn resource in nn resource.
the complete rules can be found in our public repository.
.
.
identifying tuning directions.
the tuning direction for a configuration option involves a pair of values referred to as vsrcand vtar .
for most of the properties i.e.
pp pp pp pp and pp obtaining the value pairs is straightforward as long as the configuration type is known.
for example once a configuration option is labeled with the optimization type its tuning direction clearly becomes off on .
the exceptions are pp and pp of the tradeoff type because one needs to know tuning vsrctovtaris fromanti performance topro performance pp or vice versa pp .
to address this cpdetector infers the direction of value tuning by analyzing the configuration documentation associated with each configuration optionlabeledas tradeoff.specifically givenaconfigurationoption cp detector ranks its values according to their influences on the application s performance.
a value is ranked higher if it results in performance improvement.
therefore for an arbitrary pair of configuration option values the higher ranked one indicates properformance and the lower ranked one is anti performance.
to do this similar to .
cp detector extracts performancerelatedinformationfromdocumentation.cp detectorfirstlocates the description of each value by matching its first appearance sentence.
based on the synonym tags in table cp detector then quantifies the degrees to which a configuration option value influences the performance.
specifically a value will be scored if one ofthe followingsequences intheleft sideappears initsdescription increase perfpositive decrease perfpositive decrease perfnegative increase perfnegative decrease opposeperf increase opposeperf these sequences explicitly indicate the value can increase the performance.
on the contrary a value will be scored if one of the sequences in the right side appears.
for example in mongodb the tradeoff option compressors has three values snappy balanced computation and compression rates zlib higher compression rates at the cost of more cpu consumption compared to snappy.
zstd higher compression rates and cpu consumption when compared to zlib .
cp detector will rank the values as snappy zlib zstd since snappyhas the best performance while zstdhas the worse one.
.
exposing cpbugs cp detectorgeneratesvaluepairs vsrc vtar associatedwiththe tuning direction for the target configuration options i.e.
options labeled by the five configuration types .
the performance change after tuning the target configuration option otfromvsrctovtar i s usedtodetermineifacpbugisexposed.inadditionto ot acpbug mayneedspecificvaluesofotherconfigurationsorworkloadstobe exposed.
therefore cp detector also samples the values of other configurationoptionsandenvironmentparameters e.g.
workloads stage of program execution to test otunder different scenarios.
wenextdescribetheprocessofsampling ottogeneratevaluepairs the process sampling test scenarios to test ot and results checking.
.
.
sampling target configurations options.
once a configuration option otis assigned with one or more specific properties cp detector will generate value pairs vsrc vtar for the tuning direction of each property.
according to table the tuning directions of pp pp and pp involve binary options so the value pair contains only on and off.
the tuning direction of pp is also straightforward so a pair of random values is generated.
the tuning direction of pp and pp exhaustively samples the pairs of enumerated values in terms of their ranking positions where the higher ranked value is assigned to anti performance and the lower ranked value is assigned to pro performance.
suppose ot has three enumerated values ranked as v1 v2 v3 the value pairs for pp are v2 v1 v3 v1 v3 v2 .
the value pairs for pp are v1 v2 v1 v3 v2 v3 .
one challenge is that for numeric options it is hard to test all combinations of two values because the value ranges may be extremely large.
to address this guided by finding the sampling numberscanbesignificantlyreducedbyfixing vsrctotheminimum configuration values or fixing vtarto the maximum configuration values.
during the sampling process a small step length between vsrcandvtarmay lead to limited performance change and cannot expose cpbugs.
while a large step length may lead to one of vsrcor vtarlocated outside the value range which can trigger cpbugs.
inthis regard cp detector first assigns vsrcto the minimum value and increases vtarexponentially e.g ... until the maximum value.
then cp detector assigns vtarto the maximum value and decreases vsrcexponentially until the minimum value.
this sampling strategy helps cp detector find the proper vsrcandvtarwithin limited samples.
.
.
sampling test scenarios.
given a target configuration option ot cp detector now has two values i.e.
vsrcandvtar o fot and the expected performance change when tuning otfromvsrc tovtar.
besidesot a cpbug may need other triggering conditions including workloads other configurations or the running stages ofthesoftware e.g.
start service shutdown .inthisregard wedefine test scenarios s workload configuration stage .
cp detector will generate different scenarios then test vsrcandvtarofotunder each scenario.
workloads cp detector uses both performance benchmark tools and official performance test suite as workloads.
benchmark toolsprovideavarietyofparameterswithwideranges.togeneraterepresentativeworkloadcommands cp detectorappliesthestate of artdistance basedsamplingmethod whichsupportsflexible sample size and is more representative than traditional n wise sampling.
after that the official test suite is integrated with thosecommandstogetthecompletesetofworkloadcommands.cpdetector also provides interfaces to accept customized workloads.
configurations in there are cpbugs that show expectation mismatches.
we manually analyzed the cpbugs and found .
of them can be triggered by testing the combinations of two options.
this result indicates that cp detector can expose .
cpbugs by sampling one other option besides ot.
to do this cpdetector uses the one hot sampling strategy i.e.
changing one option at one time while other options remain default values.
as for the constraints between configurations cp detector needs to filter out combinations that violate configuration constraints.
toachieve this cp detector leverages spex which uses the data flow of program variables corresponding to the configuration options to extract constraints.
cp detector also allows users to provide customized constraints.
runningstages cpbugsmayonlybetriggeredatspecificrunning stages of software.
for example the cpbug httpd shown in .2happened at the start stage.
in this regard we predefine running stages for each software domain including start restart service shutdown for servers and binary compilation binary execution for compilers.
then cp detector tries to exposecpbugs under each stage.
for configuration options of the resource type cp detector only uses the servicestage in servers since other stages do not use the resources.
.
.
results checking.
cp detector finally checks if the actual performance change of vsrcandvtarindicates a cpbug according to column in table .
for pp pp pp pp and pp it is easy to check if the actual performance drops i.e.
p vsrc p vtar wherep vsrc andp vtar areperformancesof vsrcandvtar respectively.
for pp and pp cp detector uses the following rules to determine if the drops are more than expected p vsrc p vtar tr1 p vsrc p vtar tr2.
wheretr1andtr2arepredefinedthresholds.itmeans p vsrc isbetter thanp vsrc more than tr1times.
while the absolute drop from p vsrc top vtar is large than tr2.
we will evaluate the thresholds in .
.
since performance can be influenced by many environment factors such as network delay and system warm up an application running repeatedly on the same machine can produce performance results that differ with each execution.
cp detector employs a strategy to eliminate the performance bias.
cp detector tests each case times repeatedly and uses hypothesis testing t o eliminatetheperformancebias.specifically cp detectorassumes the performances of vsrcandvtaras two random variables then uses thet test .
to check if the relations hold in the above rules.
we set the null hypothesis that the relations do not hold.
when the null hypothesis is rejected a cpbug is alarmed.
evaluation to evaluate cp detector we consider four research questions rq1 how accurate is cp detector at suggesting performance properties?
rq2 how effective and efficient is cp detector at exposing both known and unknown cpbugs?
rq3 how does cp detector compare with the state of the art performance bug detection tool?
rq4 howdocp detectorparametersinfluenceitseffectiveness?
.
rq1 accuracy of suggesting performance properties to answer rq1 we evaluated the accuracy of cp detector in suggesting performance properties of configuration options.
given a configuration option this process contains two components predicting the type of configuration option and identifying the tuning direction.
we evaluated the accuracy for each component.
we randomly sampled configuration options from the software systems we studied.
three authors manually labeled the types of the options by analyzing the configuration documents.
each label was cross checked and discussed until there was no disagreement.
this process took working hours.
the options were split into sets to conduct a stratified fold cross validation.
we did not use the configuration options included in our empirical studies since the options involved in the cpbugs have an unbalanced distribution.
by default we set the parameters during mining cars with len andnum and introduce how to set these parameters in .
.
predicting configuration types.
we evaluated the precision and recall of predicting each configuration type.
we also calculated the weighted averages which is defined as the averaged precision recall of each type weighted by the option number of the type.
we also compared our approach with a baseline method i.e.
keyword searching.
we used the same car mining algorithm and restricted len c a r 1t ogenerate keywords for each type.
we setnum which has been tested to be able to achieve the best result.
a larger num e.g.
may improve the recall but significantly decreases the precision at the same time.table precision and recall on inferring types of configuration options average result with stratified fold cross validation .
type optionprecision recall cpd base.
cpdbase.
resource .
.
.
.
tradeoff .
.
.
.
optimization .
.
.
.
functionality .
.
.
.
non influence .
.
.
.
weighted average .
.
.
.
cp detector.
the keyword based baseline method.
table4shows the precision and recall of cp detector in predicting configuration types.
cp detector is most effective in predicting the resource type.
this is because their option descriptions often contain similar semantics e.g.
memory buffer cpu etc.
while for functionality options cp detector has a good precision but the lowest recall.
this is because the functionalities are highly diverse and only limited common features e.g.
profiling monitoring are identified by cp detector.
compared to the baseline method when considering the precision and recall together i.e.
the harmonic mean of the precision and recall cp detector outperforms the baseline method in every type.
this result suggests that cp detector is effective .
precision and .
recall in predicting configuration types.
identifying tuning directions.
the second task is to determinethetuningdirectionforeachvaluepairofagivenoption.this task is challenging for tradeoff configuration options while the tuning directions of other options are straightforward.
among tradeoff options we need to check pairs of tuning directions an option with values say a b c implies pairs ab ac bc .
cp detectorsuccessfullypredicted139 .
ofthem.meanwhile cp detector failed to identify cases.
this is because the configuration documents do not always contain the relationship among the values of a tradeoff option.
for example a common tradeoff option for database is storage engine .
different engines produce different levels of performance concurrency consistency integrity etc.
but these properties are not described in the documents.
the accuracy of other types are for both resource and non influence .
for functionality .
for optimization e.g.
somefunctionality options are not boolean thus cp detector can not handle .
thisresultindicatescp detectoriseffective .
accuracyin average in identifying tuning directions.
.
rq2 effectiveness of efficiency of detecting cpbugs to evaluate cp detector in exposing cpbugs we first applied cpdetector to a set of existing cpbugs.
we then used cp detector to find previously unknown cpbugs.
.
.
detecting existing cpbugs.
we evaluate the effectiveness and efficiency of cp detector in exposing cpbugs studied in .
we tried to reproduce all the studied cpbugs with our best effort.wesuccessfullyreproduced38bugs.toavoidover fitting we table the effectiveness of detecting existing cpbugs.
pp violated cpbugs exposed f p optimization pp tradeoff pp tradeoff pp resource pp functionality pp functionality pp non influence pp n a total cpbugsexposedbycp detector.
cpbugsexposedbycp detector given ideal properties.
followedthebugcollectionstepsin 2andsuccessfullyreproduced 23bugsthatarenotincludedin173studiedbugs.reproducingthese cpbugs took working hours.
we evaluate cp detector on these cpbugs.
by default cp detector sets tr1 andtr2 .
we evaluate how to determine these thresholds in .
.
effectiveness.
to evaluate the effectiveness we assessed both completeness how many bugs can be exposed by cp detector from the known bugs and soundness how many false positives cp detector produces.
to measure the false positive we applied cp detector to the software versions where bugs have been fixed bydevelopers andobservedif cp detectorstillreportsbugs.the results are shown in table .
cp detector successfully exposed out of the bugs.
among the exposed bugs bugs were exposed by using the default workloads of cp detector while bugs required specific workloads collected from bug reports.
cpdetector failed to expose bugs due to the following reasons the properties suggested by cp detector is not correct cases the bug is not triggered when testing cases e.g.
mongodb30643 canbeexposedwhen7differentoptionsaresettospecific values the option does not have any property cases row n a e.g.
mysql i n .
.
cp detector reported seven false positives.
three cases are caused by bad application design.
for example in the case of pp4 allocating larger caches results in worse performances in both buggy and fixed versions.
this is because the query cache feature is actually ill designed only in rare cases increasing the cache size improves the performance.
this feature is removed since mysql is upgraded to v8.
.
four cases are caused by incorrect properties.
for example in the n a case cp detector falsely regards m32 as a non influence option which can affect performances depending on cpu architectures.
this result indicates cp detector can effectively expose existing cpbugs with limited false positives at the same time.
efficiency.
to measure the efficiency we used the number of valuepairsofeachconfigurationoptionrequiredtoexposecpbugs.
we mainlyevaluatethenumbersfor numericconfigurationoptions becausethesamplingapproachforotheroptionsisstraightforward i.e.
enumerating all combinations.
we evaluated the numbers on all cpbugs from the ones with numeric options and compared cp detector with a baseline method i.e.
uniform samplingtable new cpbugs detected by cp detector bugid slowdown version s status clang .
e.t.
v7 latest confirmed clang .
e.t.
v7 latest confirmed clang .
c.t.
v3 fixing clang .
e.t.
v7 latest pending clang .
c.t.
v3 latest fixing gcc .
c.t.
v6 latest pending gcc .
c.t.
v4 confirmed gcc c.t.
v4 confirmed gcc .
e.t.
v v confirmed gcc .
e.t.
v8 latest pending gcc .
e.t.
v8 latest confirmed gcc .
e.t.
v8 latest confirmed gcc hang c.t.
v7 latest fixing c.t.
compiling time e.t.
execution time.
the sampled numbers satisfy uniform distribution .
the results showed that cp detector exposed out of the bugs.
to make a fair comparison we tuned the sampling density of the baseline method until the same number of bugs are exposed.
as a result cp detector generated value pairs .
pairs each bug in average stdev .
whereas the baseline method generated pairs pairs each bug in average stdev .
cp detector required fewer pairs since fixing one of the two values on the minimum or maximum value.
this result indicates our sampling strategy can significantly improve the efficiency i.e.
reduce the sampling numbers while remaining the same effectiveness.
.
.
detecting unknown cpbugs.
we applied cp detector on the options sampled in .1to evaluate if cp detector can detect unknown cpbugs.
cp detector reported cpbugs from clang andgcc including13truepositivesand4falsepositivesaccording to our manual analysis.
we reported true positives to developers as shown in table .
to evaluate the impact of the reported bugs we calculated their slowdowns by comparing the performances between the fixed version if any and the buggy version.
if the fixed version is not available we examined the performance on the other compiler for comparison.
the cpbugs found by cp detector have significant impacts .
.
execution times .
compilation times on user s experience and many have been existing for years.
worse still gcc hangs for hours to compile lines of c code.
meanwhile cp detector reported four false positives in gcc and clang.
when using a higher level of compile time optimization the binary execution time usually decreases.
in the two false positives however the execution time also depends on the hardware.
the higher level optimization generates machine code that is inefficient in the experimental hardware.
adding march native can solve the problem because it makes the generated code suitable for the compiling machine.
these two cases can be eliminated by adding configuration constraints.
the other two false positives are caused by incorrect properties suggested by cp detector.
this resultindicatescp detectorcanexposeunknowncpbugswithhigh impacts up to slowdowns and existing for years .
lenper irrelevant tradeoff function optimization resource time in minutetime a numberofcarsandoverheadwithdifferentlen5100 .
.
.
.
.
.
.
.
.
num each type precision rand n recall rand n precision top n recall top n b precisions and recall of two car selection strategies with different num.
.
.
.
.
.
threshold tr tr2 tr2 tr2 tr2 tr2 tr2 c f score of different tr1 tr2 figure the influence of cp detector parameters.
.
rq3 comparison with the state of the art we compare cp detector with toddler which is one of the most effective bug detection tools among existing works.
toddler usesredundantmemoryaccesspatternstodetectperformancebugs that are caused by inefficient loops.
we evaluate the effectiveness of toddler in exposing the same cpbugs.
the evaluation shows that toddler can detect of the existing cpbugs.
this is because the cpbugs are caused by a variety of reasons while toddler only focuses on the inefficient variable accesses in loops which account for a small proportion in our dataset.
thisresultindicates cp detectorcandetectmoretypesofperformancebugsthantoddler.cp detectorcanserveasacomplementarytoolwithtoddler in detecting general performance bugs.
.
rq4 the influence of model parameters the effectiveness of cp detector can be affected by the selection of four parameters the length lenand number numof cars and two thresholds i.e.
tr1andtr2 to check pp and pp .
we evaluate how these parameters impact cp detector.
the max length len of cars affects the car candidates generated by association rule mining process.
with longer len w e can get more car candidates but the time spent for mining grows exponentially.
to choose a reasonable value we use the option descriptions in .1to evaluate the car number and overhead with different len.
as shown in figure 4a when lenis larger than the numbers of car candidates for all types of options start to converge.
this is intuitive because longer sequences are less likely toappearmorethan min support timestobecomeacarcandidate.
the number num of cars selected for each type of options can affect the accuracy of the option type classifier.
to evaluate this we use the same options in .1and split it by to conduct stratified fold cross validation on precision and recall of the classifier with different num.
also we compare our sampling approach with a baseline method i.e.
using top numcars from each type.
figure 4bshows the averaged precision and recall of the option type classifier.
as numgrows the precisions and recalls of both strategies converge.
when numis small i.e.
less than our sampling strategy outperforms the top numstrategy since the recall of the top num strategy is limited.
when numis larger than the recall of our approach converges while the precision remains the same.
thus we use as the default value.to choose the best combination of tr1andtr2 we evaluated all cpbugs breaking pp and pp .
for each bug we collected the performance pairs i.e.
p vsrc andp vtar in both buggy and fixed versions.givenacombinationof tr1andtr2 atruepositivemeans thecombinationsuggeststheperformancepairinthebuggyversionisabug afalsepositivemeansthecombinationsuggeststhepairin the fixed version is a bug a false negative means the combination suggests the pair in the buggy version is not a bug.
we successfully collecteddatafrom41bugs andsplitthedataby10todothe10 fold cross validation.
then we calculate the precision recall and f score with different tr1andtr2.
as shown in figure 4c larger tr1or tr2implies stricter conditions thereby reducing false positives but increasing false negatives and vice versa .
the optimal tr1and tr2combination is and blue line with best f score .
.
the averageprecisionandrecallare94.
and87.
respectively.thus we use and as default values.
discussion impactofworkloads.
software workloads can affect the effectiveness of cp detector in exposing new cpbugs.
it is hard to automaticallypredictreal worldworkloadsthatcantriggercpbugs.
instead cp detector provides interfaces to accept customized workloads.
for example when the software end users reported a performance issue cp detector can leverage the workload contained in the report and help developers confirm if the issue is caused by a cpbug.
quality of performance properties.
we summarized seven properties from cpbugs.
these properties may be limited in twoaspects wemaymissapropertythatdoesnothappeninour studied cpbugs the properties may be affected by other factors andnotalwayshold.forexample in .
.
cp detectorreported two false positives which break our properties but are not bugs.
in this regard we will investigate more bugs in the further work toimprove the completeness of properties.
cp detector provides user interfaces to accept customized property constraints e.g.
for the false positives of .
.
the property of the optimization level option holds when setting march native.
valueboundsofnumericoptions.
whensamplingnumeric options cp detector needs to determine the lower and upperbounds.
simply using the maximum value of an integer variable e.g.
264for unsigned long as the upper bound may result in a misconfiguration .
for example when a buffer value is larger thanthememorysize thesystemwillusethe swapmemory andthe performancedrops.thisperformancelossisnotcausedbyacpbug.
directly using the memory size may still be problematic since one software project may have multiple buffers.
to avoid this problem cp detector first extracts the lower and upper bounds from user manuals ifany .otherwise weempiricallysetthelowerandupper bounds to and of the system resource respectively.
and we monitor the resource usage by topto avoid resource overloading.
reproducing bugs.
we successfully reproduced out of cpbugs.
note that reproducing performance bugs following thebug reports are not trivial .
the main reasons why we failed to reproduce many of them are missing of important steps and too complicated workload.
for instance httpd and mongodb only show the symptom but miss bug inducing workload.
mongodb requires distributed cluster and complicated workload vaguely described .
few cpbugs need specificenvironmenttotrigger e.g.
httpd requirewindows server which by construction cp detector can not expose.
in this paper only .
lowest of mongodb s cpbug are reproducible and .
highest for clang.
future work .cp detector is far from perfect.
first triggering cpbugs sometimes require specific workload environment or timing .
one of our future work will lie in designing automatic workload generation techniques to expose cpbugs for those software systems that have limited or no test suite or benchmark tools.
second cp detector can report unexpected performance drop by tuning options but can not locate them still leaving diagnose efforts of developers.
so we will explore how to locate the bug inducing code of cpbugs to help developer fix them.
related work performance bug detection.
some works focus on detecting different types of performance problems inefficient loops redundant roads redundant collection traversals reusable data false sharing in multi thread programs inefficient synchronization user interface performance problems architectural impacts among methods performance anti patterns and tradeoffs in orm applications.
these works are effective in detecting certain types of performance problems which are different to the configuration handling performance bugs detected by cp detector.
recent short position papers have proposed a proof concept that using metamorphic testing to expose performance bug.
while they did not proposedanautomaticapproachorevaluateonlargescalesoftware systems.thedifferencebetweenourworkandmetamorphictestingis that they typically use multiple test executions to infer metamorphic relations and verify those relations on follow up tests.
while we conclude performance properties from bug study and generate them from expert knowledge e.g.
user manuals .
hotspotsdetection.
someworksfocusonpinpointinghotspots in programs via profiling perf yourkit .
similarly several following works address on generating the most time consuming workloads via profilers to help expose performance bottlenecks .thelimitationofprofiling basedmethodsisthatthehotspots arenotnecessarilycausedbyperformancebugs.whilecp detector can use performance properties summarized from real world bugs to confirm if a hotspot if caused by a cpbug.
performancemodeling and tuning.
many works aim to predict performance for given configurations or study the tendency of performance changes to improve performance when tuning configurations.
these works focus on building the relationship between performance and configuration and findingthefastestconfigurationofasoftwaresystem.thisisdifferentto find performance bugs caused by incorrect configuration handling.
understandingofperformancebugs.
previousstudiesofperformance bugs have covered a wide range of characteristics including root causes fixing complexity how they are introduced and found .
recently some empirical studies emphasize the importance of configuration aware testing techniques and provide insights on reducing the searching space of configurations.
some works help comprehend performance including performance distributions generation and performance specifications extracting via in field data .
these works help understand performance issues while cp detector can expose cpbugs automatically.
conclusions performance bugs are hard to detect due to their non fail stop symptom.
in this paper we argue that the performance expectation of configuration tuning can be leveraged to expose cpbugs.
we studied173real worldcpbugsfrom12softwaresystemsandfound most .
of cpbugs can be exposed by using the expectations.
our findings also guide the inferring of performance expectations and sampling of test inputs to trigger cpbugs.
we design and implement cp detector to detect real world cpbugs.
the result shows that cp detector is effective in exposing both known and unknown cpbugs.
cp detector can be integrated into an ide as a regression test tool w.r.t.
performance or used asan assistant tool to confirm performance related bugs in bug tracking systems.