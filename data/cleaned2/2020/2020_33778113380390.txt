extracting taint specifications for javascript libraries cristian alexandru staicu tu darmstadt cris.staicu gmail.commartin toldam torp aarhus university torp cs.au.dkmax sch fer github max schaefer github.com anders m ller aarhus university amoeller cs.au.dkmichael pradel university of stuttgart michael binaervarianz.de abstract modern javascript applications extensively depend on third party libraries.
especially for the node.js platform vulnerabilities can have severe consequences to the security of applications resulting in e.g.
cross site scripting and command injection attacks.
existing static analysis tools that have been developed to automatically detect such issues are either too coarse grained looking only at package dependency structure while ignoring dataflow or rely on manually written taint specifications for the most popular libraries to ensure analysis scalability.
in this work we propose a technique for automatically extracting taint specifications for javascript libraries based on a dynamic analysis that leverages the existing test suites of the libraries and their available clients in the npm repository.
due to the dynamic nature of javascript mapping observations from dynamic analysis to taint specifications that fit into a static analysis is non trivial.
our main insight is that this challenge can be addressed by a combination of an access path mechanism that identifies entry and exit points and the use of membranes around the libraries of interest.
we show that our approach is effective at inferring useful taint specifications at scale.
our prototype tool automatically extracts 146additional taint sinks and propagation summaries spanning npm modules.
by integrating the extracted specifications into a commercial state of the art static analysis 136new alerts are produced many of which correspond to likely security vulnerabilities.
moreover many important specifications that were originally manually written are among the ones that our tool can now extract automatically.
ccs concepts software and its engineering software notations and tools.
keywords taint analysis static analysis dynamic analysis permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than the author s must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may seoul republic of korea copyright held by the owner author s .
publication rights licensed to acm.
acm isbn .
.
.
.
reference format cristian alexandru staicu martin toldam torp max sch fer anders m ller and michael pradel.
.
extracting taint specifications for javascript libraries.
in 42nd international conference on software engineering icse may seoul republic of korea.
acm new york ny usa pages.
introduction javascript is powering a wide variety of web applications both client side and server side.
many of these applications are securitycritical such as paypal netflix or uber which handle massive amounts of privacy sensitive user data and other assets.
an important characteristic of modern javascript based applications is the extensive use of third party libraries.
on the npm platform more than million packages mostly libraries are available 1and only a few of them have been screened intensively for security vulnerabilities.
a challenge when analyzing the security of npm packages is that they are often not self contained but they in turn depend on other npm packages for providing lower level functionality.
recent work shows that on average every npm package depends on other packages and on code published by maintainers .
to correctly understand an application that uses npm packages one needs to consider all these dependencies.
two main directions are being pursued for automatically securing npm packages.
first there are tools that aggregate known security vulnerabilities in specific versions of individual libraries and report them to the developer directly.
for example npm audit analyzes all the dependencies of a node.js application and warns the developer about any known vulnerabilities in the dependent upon code.
github snyk and other companies offer similar services and related work advertises such security controls.
the main limitation of this approach is the high number of false positives.
often the critical part of the library is not used by the application or it is used in a way that is completely harmless.
for example an application may use an npm module vulnerable to command injection attacks but it passes only string constants provided by the developer as input to this module.
we believe it is important to make the distinction between merely relying on a library that contains a potential known vulnerability and using that library in an insecure way.
another problem with these tools is that libraries that use insecure features of the javascript language or of the node.js framework are often not registered as having known vulnerabilities if their documentation indicates that these features are being used internally.
an example of such a library is the packagejsonfile that provides functionality for easily accessing json ieee acm 42nd international conference on software engineering icse icse may seoul republic of korea cristian alexandru staicu martin toldam torp max sch fer anders m ller and michael pradel files.
even though such a library is not considered vulnerable by itself it may be used in an insecure manner e.g.
by propagating attacker controlled data into file system paths.
a more precise approach for securing javascript applications pursued both by academia and by industry practitioners is static program analysis.
in taint analysis which is a kind of program analysis that can in principle detect most common forms of security issues security properties are expressed as direct information flows from sources tosinks either from untrusted sources to sensitive sinks integrity or conversely from sensitive sources to untrusted sinks confidentiality .
we focus on integrity because it covers the vast majority of security vulnerabilities reported by the community 2and we ignore indirect flows also called implicit flows because they have been shown to appear seldom in real world npm vulnerabilities .
modularity is the key to scalable static analysis.
for example github s lgtm3platform includes a state of the art taint analysis for javascript and other languages which achieves high scalability by analyzing modularly.
when analyzing one module of an application other modules are either ignored or treated according to manually written specifications that describe essential taint flows where available.
ignoring modules leads to inaccurate analysis results while manually constructing specifications is a demanding and error prone task so only a limited number of npm modules are considered.
an important question hence is how to obtain specifications of modules in an automated way.
inspired by modelgen for android we present a technique that dynamically infers explicit taint flow summaries for npm modules to be utilized in a static analysis such as lgtm.
besides being designed for javascript our technique is more general than modelgen allowing for complex summaries to be extracted.
for example we are the first to support summaries involving callback arguments and instantiated exported classes.
moreover our technique considers the large amount of transitive dependencies in npm and thus allows the extraction of summaries for multiple npm packages in the same execution.
another source of inspiration is the noregrets tool that leverages the vast number of open source packages available in the npm repository to obtain information about how the most important libraries are being used.
many of those packages have test suites and by running the test suite of a package we can gain information about the taint flows in all the packages it depends on both directly and transitively.
a central technical challenge for adapting the modelgen idea to our setting is that javascript is a highly dynamic language which makes it non trivial to map observations from a dynamic analysis to taint specifications that fit into a static analysis.
to this end we adopt the notion of dynamic access paths from noregrets allowing us to identify entry and exit points of taint flow in the libraries.
our dynamic analysis uses a variant of membranes for tracking the taint flow between libraries and clients.
it identifies flows between entry and exit points propagations between entry points and existing sinks additional sinks and between existing sources and exit points additional sources .
finally we propose userinput tempdir .
path to dir cachedir .
path to cache 5const require lodash 6const rimraf require rimraf 8let obj .forin userinput function value rimraf value function err if err console .log err figur e a typical example of javascript code that uses npm modules.
with dotted blue we mark exit points from the client code and with solid orange the entry points from the library code.
deploying one membrane per npm module and hence extracting summaries for multiple modules at once.
we show that our approach is highly scalable by successfully running our dynamic analysis on clients of 751packages.
the dynamic analysis is efficient spending on average only seconds per successfully analyzed client or seconds per inferred specification.
in total it extracts 146additional taint sinks and7 propagation summaries spanning modules.
of the summaries contain complex taint flows such as between an argument of an exported method and a parameter passed by the library to a callback.
the evaluation also shows that the extracted summaries can improve static analyses by enabling it to reveal otherwise missed vulnerabilities 136new alerts are produced many of which correspond to likely vulnerabilities.
in summary our contributions are we present a novel highly scalable specification extraction technique for javascript libraries that builds on a dynamic taint analysis and leverages existing test suites.
we report our results from an extensive experimental evaluation of the approach.
the results show that the dynamic analysis is able to infer non trivial and accurate taint flow models in widely used npm modules.
we demonstrate that the inferred taint specifications can be integrated into an existing static analysis tool thereby enabling discovery of previously unknown security vulnerabilities.
motivating example let us consider the example in figure .
this code fragment uses two of the most popular npm packages lodash a general purpose utility library and rimraf a simple library for recursively deleting directories on the disk.
in the presented example the forin method from lodash is used to iterate through the values of each property on the user input object.
each of these values is then passed to the rimraf module.
a human or an automated tool that aims at analyzing the code fragment in figure must first understand the essential semantics of the two modules.
for example one needs to understand that if some user input is passed to rimraf without sanitization then it exposes a directory traversal vulnerability.
however this style of code can hinder understandability both for unexperienced users 199extracting taint specifications for javascript libraries icse may seoul republic of korea and for static analysis tools.
specifically it may not be clear that by invoking the forin method with two parameters an object to be traversed and a callback function the second parameter will be invoked with the property values of the first parameter as arguments.
one way to address this problem is to analyze the library code together with the client code using a whole program dataflow analyzer.
however that approach suffers from serious scalability issues.
for example the implementation of the apparently trivial forin method spans across files.
in figure we show a subset of the code that needs to be analyzed.
statically analyzing such a large amount of highly dynamic code is extremely expensive and tends to give prohibitively imprecise results .
when trying to analyze the source code of the rimraf module one is faced with even greater challenges as illustrated by figure .
to reveal the directory traversal problem discussed earlier one needs to show that there is an unsanitized flow from the first parameter of the rimraf function to one of the file system access methods e.g.
fs.rmdir .
however as shown by the example the call to this method is dispatched using dynamically attached methods on the options object.
once again to the best of our knowledge existing static analysis tools for javascript are unable to successfully analyze such highly dynamic code at scale and with a precision that is practically useful.
modular analysis as exemplified by lgtm addresses this challenge by analyzing each package in isolation.
if a package depends on other packages those are either ignored or modeled using manually written specifications that capture the essential dataflows.
relying on simple generic specifications e.g.
saying that whenever a parameter is tainted then so is the return value would be too imprecise for this example and lead to the static analysis missing important flows.
since creating useful specifications manually is difficult and not scalable efficient automated alternatives are needed.
our approach leverages the information in the npm repository about packages and their dependencies together with the package source code available on github.
for this specific example both lodash andrimraf have numerous open source clients many with test suites.
by dynamically analyzing the executions of those test suites we can automatically learn useful specifications.
taint specifications for modules the specifications we are interested in summarize the taint relevant information for entry and exit points of javascript libraries.
for example one can specify that the information from entry point a may flow into exit point bor that values passed to an entry point eventually reach a potentially dangerous operation.
the careful reader may have observed that there is a duality between the exit points of the client code e.g.
in figure and the entry points of the library e.g.
in figure .
for example the userinput argument in line corresponds to the object parameter in line .
we will refer to both an entry point and its corresponding exit point by using the term contact point.
we also introduce an access path mechanism to uniquely identify each contact point.
the specifications described in the remainder of this section can in principle be produced in multiple ways either manually or by14 in the file forin .js var basefor require .
basefor castfunction require .
castfunction keysin require .
keysin function forin object iteratee return object null ?
object basefor object castfunction iteratee keysin module .exports forin in the file basefor .js var createbasefor require .
createbasefor var basefor createbasefor module .exports basefor in the file createbasefor .js function createbasefor fromright return function object iteratee keysfunc var index iterable object object props keysfunc object length props .length while length var key props if iteratee iterable key iterable false break return object module .exports createbasefor ... skipped the other transitive dependencies ... figur e the implementation of lodash s forin method.
for space reasons only two of the dependent files are shown.
with dotted blue we mark entry points to the library code and with solid orange the exit points from the library code.
var fs require fs function defaults options var methods unlink chmod stat lstat rmdir readdir methods .foreach function m options options fs m m sync options options fs function rmdir p options originaler cb defaults options options .rmdir p function er cb er module .exports function rimraf p options cb options .lstat p function er st return rmdir p options er cb figur e simplified source code for the rimraf module.
using a static or dynamic analysis.
section presents an automatic inference process based on dynamic analysis.
.
specifying contact points inspired by previous work to detect breaking changes in npm package updates we propose using an access path mechanism 200icse may seoul republic of korea cristian alexandru staicu martin toldam torp max sch fer anders m ller and michael pradel for specifying contact points.
an access path or short ap can be described as an s expression which is read from the innermost expression outwards.
each type of symbol corresponds to an operation in the javascript language.
ap root uri member name ap parameter i ap return ap instance ap the innermost subexpression of a path always contains a root symbol which holds an uri that refers to the module.
for space reasons we use package names instead of package uris.
for example root dotenv refers to the module that is loaded when calling require dotenv .
the other symbols are member to refer to properties of objects parameter that refers to the i th parameter of a function return that refers to the return value of a call and instance that refers to constructed values.
for example the path parameter member forin root lodash represents both the exit point in line of figure and the first entry point in line of figure .
in the remainder of this section we show how access paths can express different kinds of taint specifications.
we assume that a collection of so called known sources and sinks is provided.
for example values obtained from network communication via the node.js standard library are commonly treated as sources and arguments to exec andeval are sinks.
we are interested in three kinds of specifications additional sinks when we observe a flow from an entry point to a known sink additional sources when there is flow from a known source to an exit point and propagation summaries when there is a flow from an entry point to an exit point.
we will now proceed to describe each of them in detail.
.
propagation summaries the propagation summaries or propagations for short specify how taint may flow in and out of a library s functions.
for example a propagation summary can specify that if a tainted value enters the library as a specific argument to a function then specific exit points of the library e.g.
properties on the return value should also be considered tainted.
having such information available allows program analyses to reason about the potential taint flows without needing to reanalyze the source code of the library for every client.
the most basic form of flow is from an argument of a function to its return value either because the argument is returned directly or because the argument is used in the computation of the return value.
other more complicated forms of flow may also occur.
for example if an argument is written to some internal state of the library and this state is then returned from another function then we have a taint flow from the argument of one function to the return value of another function which can also be captured as a propagation summary.
a propagation summary consists of two access paths one that represents the point in the library api where the tainted value enters and one that represents the point where the tainted value exits.
consider example where a function fhas a parameter xand returns an object that has a property pwith a value obtained from thepproperty of x.example module m function f x return p x.a module .exports .f f taint specification member a parameter member f root m y member p return member f root m the interesting taint flow for this code is modeled by the taint specification shown next to the example which indicates that taint flows from x.ato the pproperty of f s return value.
this way of expressing taint flows is sometimes inconvenient.
for example a common javascript pattern is to iterate through all the properties of an object which means that the accessed property names differ from client to client.
an example of this reflective pattern is seen in example .
with the current notion of propagation summaries we can only express flows involving specific properties but in this case the relevant property names depend on the clients.
for this purpose we introduce a wildcard notation for referring to every property of an object member ap .
for example one may refer to all the properties of the objparameter in the program example with member parameter root sum as shown in the taint specification of example .
example module sum function f obj let sum for prop inobj sum obj return sum module .exports .f f taint specification member parameter member f root sum y return member f root sum as mentioned earlier callbacks are common contact points in npm modules.
our specifications refer to callbacks by treating a parameter as a function.
the following specification summarizes the part of the lodash library presented in figure using a callback parameter exit point member parameter member forin root lodash y parameter parameter member forin root lodash this propagation says that the value of every property of the object passed as the first argument of the forin function may flow into the first parameter of the callback passed as the second argument.
a final propagation pattern worth discussing is one that involves contact points with return values.
in example the padder module exports a single anonymous function in line .
however this function in turn creates an object with an lpad property pointing to an internal anonymous function.
this case corresponds to the factory method design pattern from object oriented literature.
after invoking the main exported method of the module a client obtains a reference to the internal object declared in line which in turn allows the client to invoke the internal anonymous function from line .
thus there are two exit points of the padder library in the presented example one that returns an object with an lpad method in line and one corresponding to that method itself in line .
the latter depends on the former because an object with thelpad method is only exposed to the client through the first exit point which in turn creates more entry and exit points for the lpad method.
201extracting taint specifications for javascript libraries icse may seoul republic of korea example module padder module .exports function let res res .lpad function s return s return res taint specification parameter member lpad return root padder y return member lpad return root padder .
additional sinks and sources if a value passed into a library reaches a known sink we say that the entry point through which the value entered is an additional sink.
intuitively passing the value to that contact point or to the sink itself has the same security implications for the client of the library hence a program analysis can treat them the same way.
revisiting the source code of the rimraf library in figure we can observe that the value passed as first argument to the main library function ends up in fs.rmdir which is a known sink for directory traversal vulnerabilities.
this method allows recursively removing any folder on the disk hence if an attacker can control the value passed into it she can cause serious harm on the system.
therefore it makes sense to specify the contact point parameter root rimraf as an additional sink.
conversely if inside the library a tainted value is created which then escapes into the client code through an exit point we say that the exit point is an additional source.
example shows a simple module that performs a tcp request and invokes a callback whenever data is received from the target server.
this data should be considered tainted since it comes from untrusted third party computers so it is reasonable to specify the contact point parameter parameter root my tcp as an additional source.
example module my tcp module .exports function host port cb const net require net const client new net.socket client .connect port host function client .on data function data cb data even though our dynamic analysis presented in section can in theory extract all the three kinds of specifications presented so far our prototype implementation introduced in section only supports the extraction of propagations and additional sinks.
the main reason for omitting extraction of additional sources is that existing security vulnerability reports for npm packages often involve additional sinks for example cve or cve but vulnerabilities caused by additional sources are less common.
inferring taint specifications via dynamic analysis we now present a technique for dynamically inferring taint specifications i.e.
propagation summaries and additional sinks of the form described in section .
the goal is to find relations between entry points and exit points between entry points and existing sinks and between existing sources and exit points.sour ce sinknpm module client figur e inferring specifications for a single module taint values at entry points and sources and then check for taints at sinks and exit points.
the arrows show information flows and the shaded gray area represents the membrane.
figure illustrates how our technique works for a single npm module.
the arrows represent information flow possibly spanning multiple methods and modules.
when the test suites are executed values are intercepted at entry points and tainted with a unique identifier per entry point.
the taint inside the module is then propagated using a dynamic taint analysis.
whenever a tainted value reaches a sink or an exit point an additional sink or a propagation summary respectively is generated.
similarly if a value that is tainted by an internal source is observed at an exit point an additional source is generated for that exit point.
all taints are removed at exit points so we only infer specifications for the library code and not for the client code.
previous work considers arguments of methods in the public api as entry points and return values as exit points but as the motivating example shows this is insufficient for many npm modules.
javascript libraries interact with their clients in complex ways e.g.
through callbacks like the ones in figure or by allowing plugins to be configured inside the library.
therefore it is non trivial to determine where the library code starts and where the client code ends.
one way to refer to this point of contact between components and thus to generalize the idea of entry and exit points is by using the concept of membranes .
.
membrane based analysis the main idea of a membrane is to interpose analysis behavior on every interaction between the client and the library.
moreover every reference that passes through the membrane becomes part of it.
existing work describes how to implement membranes and how to use them for implementing generic policies such as the library should never use the native module fs .
however to be useful in our setting we need a way to distinguish between entry and exit points of the library and to uniquely refer to every such point in the membrane.
to rigorously define membranes we first introduce a way of intercepting operations on a given value.
to this end we rely on proxies a concept introduced in ecmascript .
a proxy p v for a value vis a wrapper object that attaches traps to the wrapped value.
every operation applied to the proxy results in an invocation on the corresponding trap.
for example property reads property writes function applications and constructor applications all result in their 202icse may seoul republic of korea cristian alexandru staicu martin toldam torp max sch fer anders m ller and michael pradel table creation of contact points inside the membrane and the corresponding taint operations executed before and after the proxied operation.
the direction indicates whether the proxy corresponds to an entry or an exit point.
the taint v ap action associates a taint corresponding to the access path apto runtime value v. the checktaint v ap action recursively searches for tainted values in v where the taint has the same root package as the access path ap.
finally untaint v ap recursively declassifies all the values in vthat have a taint with the same root as the access path ap.
operation existing contact point new contact point s pre action post action access path direction access path direction require foo ap root foo entry x.prop apx entry ap member prop apx entry apx exit ap member prop apx exit taint x.prop ap res x arg apx entry appar parameter i apx exit taint arg appar checktaint res apx apret return apx entry untaint res apx apx exit appar parameter i apx entry checktaint arg apx taint res apret apret return apx exit untaint arg apx res new x arg apx entry appar parameter i apx exit taint arg appar checktaint res apx apret instance apx entry untaint res apx apx exit appar parameter i apx entry checktaint arg apx taint res apret apret instance apx exit untaint arg apx corresponding traps firing.
the traps can modify the behavior of the operation or just perform observing operations such as logging.
a proxy can therefore observe operations applied to the wrapped value and even decide to modify these operations.
our analysis uses proxies to perform taint relevant operations before and after the proxied operation is executed.
we also need a way to associate a unique address i.e.
an access path to each proxy and to specify whether the proxy corresponds to an exit or an entry point definition .
a contact point denoted v ap d is a tuple consisting of a proxy p v around a value v an access path apthat uniquely identifies the contact point and a direction flag dthat specifies whether the contact point is an entry or an exit point.
for simplicity we abuse the notation for a contact point v ap d by using v whenever the access path and the direction are not relevant for the description.
one can specify entry and exit points for a library by introducing proxies around exported api methods in the library source code.
the challenge lies in automatically identifying allthe values that need to be proxied for intercepting all the interactions between two npm modules.
membranes provide an elegant solution to this problem definition .
a membranemis a set of contact points interposed between a library land its clients.mis initialized with vl root l entry i.e.
the contact point that wraps the main value vlexported by the library.
for every value vthat is passed into or returned by an existing contact point in m a new contact point v apv d is added to the membrane i.e.
m m v apv d .
the new access point apvis derived from the existing apby picking the grammar rule from section .
that corresponds to the javascript operation vpassing through the exit point e.g.
a property access or a parameter to a function call.
similarly the direction of the new contact point d is derived from the direction of the original contact point dby using the following observation the direction changes for all the values that are passed as arguments to a method in the membrane.
let us consider a function object that is passed into an entry point of a library as an argument.
onceit reaches the other side of the membrane i.e.
in the library code it should be considered as an exit point for the library.
in table we summarize all the possible operations on a contact point and how to derive the access paths and direction flags for the new contact points.
we also show the auxiliary operations necessary for tracking tainted values in the pre and post action columns.
note that both arguments and return values can be entry or exit points depending on the direction flag.
to illustrate how contact points are created consider the membrane between lodash and its client in figure .
the first contact point of the membrane is created when the library is required in line i.e.
m .
when the forin property is accessed in line a new contact point is added to the membrane m m .forin .
when the accessed property is invoked in the same line three contact points are created i.e.
m m userinput function .
.
.
obj .
finally when the callback is invoked three more contact points are created one for each parameter.
the access paths for each of these contact points are shown in figure they correspond to a derivation tree of the grammar in section .
.
to obtain the access path of a given contact point one should traverse the tree from the root and replace all the symbols with the access path of the parent node.
for example the access path of first is parameter parameter member forin root lodash the dynamic taint analysis we use for propagating taint inside analyzed modules is fairly standard with few idiosyncrasies.
as noted earlier we implement the taint relevant operations described in the last column of table inside each module s membrane.
these operations are in fact additional sources and sinks from the taint analysis perspective since they either attach taint or check remove taint.
once a property pis accessed on a value having a taint t instead of directly propagating the taint we create a new tainted value member p t .
if the property pitself is also tainted then we propagate the taint member t .
the intuition is that the tainted property comes from outside the module or from iterating through a tainted object hence it should be considered as a generic access.
203extracting taint specifications for javascript libraries icse may seoul republic of korea .forinobj userinputfunction ...first second third root lodash member forin return parameter parameter parameter parameter parameter figur e contact points in the membrane between lodash and the client code in figure .
sinkmodule mmo dule l mo dule pclient m1m1m1 l1m1 l1 m1 l1 m1m1m2 l2 m2 m2 m4 m4 p1 p1m5m1 m2 m3 m4 m7 m5m6l1 l2 l3 p1 p2 figure inferring specifications for multiple modules at once every entry point adds a unique taint and every corresponding exit point declassifies it.
the semantics of shapes and colors are the same as in figure .
the dotted arrows depict equivalences between contact points.
.
multi module analysis since an npm module can in turn use other npm modules we propose deploying a membrane around each module to maximize the number of extracted specifications.
we present this setup in figure in which module m interacts with two other modules a direct dependency l and a plugin p. for now let us consider the relation between module m and its dependency l. every entry point attaches a taint that uniquely identifies that entry point to each value that passes through it e.g.
entry point m1sets taint m1.
when a value passes through an exit point of a module the analysis removes all the taints corresponding to that particular module.
as a result tainted values for module m can only live inside m or inside m s transitive dependencies such as l. this behavior can be observed when following the information flow between entry point m1and exit point m3.
the taint m1is carried by the value all the way through module l until the exit point m3.
our analysis infers two propagation specifications m1 m3andl1 l3.similarly the value that enters through m2inside module m gets attached the taint m2 and further enters through l2inside module l where it gets attached taint l2.
thus when the value finally reaches the sink inside module l it has two taints m2and l2.
the analysis generates two additional sinks for m2and for l2 since from the client s perspective a value may flow from one of these entry points into an existing sink.
.
handling plugins one may wonder whether or not a module s dependencies should be considered as part of the module s code as described in the previous section.
we propose distinguishing between two types of dependencies direct dependencies and plugins.
a direct dependency is one that is required verbatim by the developer in the source code of the module and a plugin is a dependency that is injected by the client code.
for registering a plugin a client needs to pass a reference to the plugin through the membrane.
an example of this pattern can be observed in example that shows the popular express framework instantiated with the plugin body parser .
the client code loads the body parser plugin and passes it to the express module through the usemethod that is part of express s membrane.
example const express require express const bodyparser require body parser const app express app.use bodyparser .json treating plugins differently when extracting specifications is extremely important because we do not want to infer specifications that only apply when a certain plugin is loaded.
instead we want the specifications to be as widely applicable as possible.
therefore direct dependencies that are loaded inside the module are considered part of the code base of the module while plugins are not.
consider the relation between module m and its plugin p in figure .
when the value carrying the taint m4reaches the membrane that separates m from p the taint is removed we say that the value is declassified.
overall for the flow between m4andm7that passes through plugin p our analysis infers three specifications m4 m6 m5 m7 and p1 p2.
204icse may seoul republic of korea cristian alexandru staicu martin toldam torp max sch fer anders m ller and michael pradel using taint specifications the main use case of the extracted taint specifications is for improving existing program analyses.
most importantly taint specifications can be consumed by static analyses.
the benefits of hybrid analyses i.e.
static plus dynamic are thoroughly explored in the literature.
typically a static analysis uses the results from a dynamic analysis either to get a more precise result or to get coverage of code that is otherwise difficult to analyze statically.
as mentioned in the introduction industrial static analyses sometimes do not even try to analyze node.js modules but instead rely on manually written taint specifications or coarse grained assumptions about taint flow in modules.
however such specifications are both error prone and hard to maintain.
in contrast our specification generation analysis is fully automatic and can therefore easily be re run whenever modules are updated.
moreover we show that there is a significant overlap between the specifications our analysis generates and existing manually written models used by the commercial lgtm taint analysis demonstrating that our analysis can infer precise module specifications that resemble and improve upon hand written specifications.
another use case for the extracted specifications is to serve as a form of documentation for the module they were extracted from.
effectively they can act as a contract between module developers and module users that specifies for example who is responsible for sanitizing end user input.
we observe that many security vulnerabilities reported by the community or by researchers are actually additional sinks.
for example a typical vulnerability occurs when a user supplied value is involved in constructing some string that is then executed by the eval function.
in some unfortunate situations attackers can compose the user supplied value in ways that enables executing malicious code.
to warn users of modules about potential vulnerabilities inferred specifications could be shown to developers.
for example an additional sink could inform the client that an argument passed to a specific method should be sanitized to prevent malicious code injection attacks.
finally we propose using the generated taint specifications for regression analysis.
when a previously unobserved taint specification is suddenly generated for a new version of a library e.g.
a new additional sink appears both the developer of the library and its clients should be alerted.
essentially a change in a taint specification should be treated as a change to the api.
automatically inferred specifications could help automate this kind of regression analysis.
evaluation implementation.
we implement our specification extraction technique in a tool called taser4.
the dynamic analysis component is built on top of nodeprof an instrumentation framework for node.js.
as a starting point for finding additional sinks we mark methods of the built in javascript apis as sinks.
these methods cover five well known security issues command injection code injection directory traversal regular expression injection and nosql injection.
we implement limited support for sanitizers by declassifying any information flow that passes through a function 4it is an abbreviation of the longer taint spec extractor.and an npm module whose name or dynamic access path contains specific strings e.g.
escape or sanitize .
benchmarks.
we apply taser to751npm packages all from the top most depended upon packages.
because some packages contain multiple modules and because taser performs a multimodule analysis we analyze a total of modules.
for each analyzed npm package we consider the highest rated clients according to npm stars and execute their test suites to analyze the execution with taser .
we stop a test suite after a timeout of minutes.
if available we also use the test suite of the npm package itself for driving the dynamic analysis.
ignoring some clients that we currently cannot analyze e.g.
due to test frameworks taser does not support or due to limitations of our implementation the evaluation covers clients out of which clients trigger at least one creation of a tainted value.
research questions.
our evaluation focuses on the following research questions rq1 how many taint specifications does taser extract?
rq2 how efficient is the analysis?
rq3 are the extracted specifications useful for statically analyzing the security of npm modules?
rq4 how do the extracted specifications compare to manually created models of npm modules?
the implementation of taser and experimental data are available at rq1 extracted taint specifications for the analyzed modules taser extracts propagation summaries and 146additional sinks.
for 457packages the tool extracts at least one propagation summary and for 118packages it extracts at least one additional sink.
the overall amount of specifications shows that manually writing taint specifications for thousands of packages is highly impractical.
instead taser enables extracting specifications automatically and updating them regularly with little effort.
we also check whether the specifications taser extracts contain advanced language constructs not supported by previous work .
to that end we count every propagation summary that involves i instantiated objects i.e.
an instance symbol in one of its access paths ii callbacks i.e.
two or more parameter symbols in one of its access paths or iii nested api calls i.e.
two or more return symbols in one of its access paths.
we find 595propagation summaries with instantiated objects with callbacks and with nested api calls.
in total at least specifications i.e.
of the total could not have been extracted by those previous approaches even if re implemented for javascript .
rq2 efficiency of the dynamic analysis generating specifications is not something that should be done often so having a relatively large one time cost is acceptable in practice.
however over time new libraries are created and existing libraries are updated so new taint specifications naturally have to be generated for those libraries.
therefore it is interesting to consider the computational cost of generating taint specifications.
on average it takes seconds to run the test suite of one client 205extracting taint specifications for javascript libraries icse may seoul republic of korea rule id new alerts js command line injection js file access to http js path injection js reflected xss js regex injection js remote property injection js user controlled bypass js xss total figure improvements to lgtm s standard analysis rule ids are hyperlinked to their documentation.
with the dynamic analysis enabled.
this number depends on many factors such as the size of the test suite and how many javascript statements are being executed.
regenerating specifications for updated libraries and generating specifications for new libraries can be done in only a few hours per library which we consider acceptable for specifications that can be reused repeatedly by a static analysis and other applications.
rq3 usefulness for static analysis we evaluate the usefulness of taser extracted taint specifications by integrating them into lgtm a state of the art industrial static analysis platform.
a free instance hosted at continuously checks more than open source projects including thousands of npm modules for security problems.
without the specifications lgtm reasons about third party npm modules based on a limited number of manually created taint specifications.
we add the extracted specifications into the static analysis and measure how many additional security alerts the analysis reports.
figure shows the improvements gained from enhancing lgtm s standard security analysis suite with the additional sinks and propagation summaries extracted by taser.
the first column lists the lgtm rule id for instance js path injection flags potential directory traversal vulnerabilities.
the second column shows the number of new alerts found by incorporating our additional sinks and propagation summaries.
in total taser enables lgtm to find 136otherwise missed potential security problems.
to better understand the quality of the added alerts we randomly sample of the new alerts five for rules with five or more results and all results for the other rules .
we find that of them are true positives in the sense that they exhibit flow from a source to a sink.5of the six false positives five are due to imprecision of the static analysis and hence unrelated to taser and one is due to a spurious additional sink extracted by taser.
figure shows a simple example of a newly identified alert for the js path injection rule which originates from the fineuploader server examples project from github.
the req argument contains an http request object so the lgtm security analysis considers req.params.uuid to be untrusted data since it might originate from a malicious attacker.
after being concatenated with another string it is passed to the rimraf function which 5how many of these new results correspond to exploitable security vulnerabilities is a different question which we do not consider here.
var rimraf require rimraf omitted function ondeletefile req res var uuid req .params .uuid dirtodelete uploadedfilespath uuid rimraf dirtodelete function error omitted figure example of a new alert found based on a taserinferred specification.
recursively deletes the file system path denoted by this string if it exists.
the value of req.params.uuid is not checked so in particular it could contain .. components allowing an attacker to delete arbitrary files on the file system.
even though the flow from source to sink is very simple lgtm does not flag this out of the box since it does not have a model of the rimraf package and its implementation is too complicated for the static analysis to model as explained above.
our additional sinks however identify the first parameter of rimraf as a taint sink forjs path injection allowing lgtm to flag this code.
as an example of the use of propagation summaries we notice that four of the five new alerts for js remote property injection we examined make use of the propagation summaries for .foreach alodash function similar in style to .forin .
these propagation summaries describe flow through a callback parameter underscoring the importance of supporting such summaries.
rq4 comparison with manually created specifications the standard lgtm security analysis suite already includes manually written models of many popular npm packages including sinks and taint propagation rules.
by examining our automatically extracted taint specifications for overlap with these manually written models we find that of our additional sinks and of our propagation summaries correspond to existing models.
on the one hand this confirms that the specifications we extract are practically relevant.
on the other hand it also shows that the vast majority of thetaser extracted specifications are not yet covered by manual models.
as one example our dynamic analysis correctly identifies the first parameter of the single function exported by the cross spawn package as a sink for js command line injection .
lgtm includes a manual model for this.
additionally taser also identifies an analogous sink for the win spawn package a by now deprecated predecessor of cross spawn .
lgtm does notinclude a model for this presumably because win spawn is less popular than cross spawn and the lgtm analysis authors focused on popular packages in writing their models.
our automated approach is not limited by such considerations and can hence provide a much broader coverage.
discussion in this section we present limitations of our work and we discuss how automatically inferred taint specification can improve the current security practices in the javascript community.
206icse may seoul republic of korea cristian alexandru staicu martin toldam torp max sch fer anders m ller and michael pradel var printer require printer var benigninput printername printer .printdirect data test printer benigninput success function jobid console .log sent to printer with id jobid error function err console .log err figure benign input for the vulnerability described in npm advisory number .
.
limitations taser is affected by the well known limitations of dynamic analysis i.e.
one can analyze only code that is executed.
therefore adequate test coverage is essential for effectively extracting taint specifications.
even though in our evaluation we do not directly measure or aim to increase coverage for the used test suites by analyzing several clients of a given library we increase the chance of observing multiple realistic use cases of the library.
our hypothesis is that these inputs are representative for most of the library usages in the wild.
related work employs similar assumptions .
in the current work we do not consider implicit flows which were shown to have limited value for detecting integrity issues in serverside javascript .
however future work should evaluate whether this assumption also holds for extracting taint specifications.
in our evaluation we judge the usefulness of the extracted summaries by showing that they improve an existing static analysis.
similarly to the work of clapp et al.
future work should perform a more extensive set of experiments in which the quality of the extracted specifications is directly evaluated e.g.
by extensively comparing with manually written specifications.
.
comparison with coarse grained warnings the current security practice in the npm community as implemented e.g.
in the npm audit tool is to warn users whenever they are relying on a module with a known vulnerability.
this approach suffers from two limitations.
first it is limited to previously known and reported vulnerabilities.
second it often causes spurious warnings as a warning is issued for every package that depends on a vulnerable module independently of whether the first module s use of the second module is affected by the vulnerability.
we show that our approach can help address both these limitations.
first one can use taser to automatically find vulnerabilities i.e.
unsanitized undocumented additional sinks.
to evaluate the effectiveness of this approach we run taser using benign inputs for vulnerable packages aggregated by related work .
our approach finds additional sinks in of the packages.
limitations of the existing policy i.e.
missing sources and insufficient modeling of arrays are the reasons why taser does not find the remaining sinks.
second taser extracted specifications can help identify the problematic entry point of a vulnerable library.
this can reduce the false positive rate of the npm audit solution by only reporting an alarmwhen user controlled values can reach that entry point.
while implementing a more precise replacement for npm audit based on taser extracted specifications is out of the scope of this work we illustrate its potential effectiveness with the vulnerability in figure .
the example shows benign inputs passed to a module that suffers from a known vulnerability.6taser infers the following additional sink for the vulnerable module member printer parameter member printdirect root printer instead of alerting all users of the printer module as npm audit would do the extracted specification could help raise an alarm only for users that call the vulnerable entry point with a non constant string value.
similarly to synode an improvement over the current npm audit tool could check whether the value passed at the entry point is statically computable and raise an alarm only if that is not the case.
as illustrated by this example taser can help reduce the false positives of the existing technique by only alerting developers when necessary.
in addition to an npm audit like tool ides could also alert developers that specific entry points should be treated as sinks.
related work specifications of libraries and frameworks.
the idea of using pregenerated specifications to aid static analysis of library and framework code has been pursued previously .
the only other work that uses a dynamic analysis to infer taint specifications is the technique by clapp et al .
which infers specifications for the android sdk.
our work differs in multiple ways.
first we introduce the idea of membrane based multi module analysis allowing taser to infer specifications for all modules used directly or indirectly by a client.
in contrast clapp et al .
infer specifications from a client s usage of a single framework.
second we use a finegrained specification mechanism that can track flows at the level of individual properties and can express flows via callbacks while their specifications are coarse grained i.e.
only tracking flows between parameters and return values.
finally our analysis accounts for the dynamic nature of javascript e.g.
using the star expression as described in section .
.
taint analysis.
taint analysis has been used for checking security properties and other analysis problems .
in particular there are both static and dynamic taint analyses for javascript.
taint specifications inferred with a taser like approach could in principle be plugged into any static taint analysis that involves third party modules.
to the best of our knowledge we are the first to present such an approach for static taint analysis for javascript.
to facilitate the use of taint analysis for checking security properties some work proposes to infer which functions to consider as sources sinks and sanitizers .
in contrast taser infers specifications that summarize flows through entire third party modules.
javascript security.
previous work has shown that there is a wide range of vulnerabilities in javascript software in general and for the node.js platform in particular e.g.
injection vulnerabilities regular expression based denial of service vulnerabilities 207extracting taint specifications for javascript libraries icse may seoul republic of korea and implementation issues in node.js .
many existing mitigation techniques rely on some form of dynamic enforcement .
since even a small runtime overhead is often unacceptable especially for server side applications our work instead aims at improving the static detection of vulnerabilities e.g.
via the lgtm analysis tool used in our evaluation.
zimmermann et al .
have shown that npm modules depend on many on average other npm modules which become part of a module s attack surface.
thetaser inferred taint specifications enable a static analysis to consider such third party modules without relying on manually created specifications or whole program analysis.
membranes.
the membrane pattern introduced by miller has been applied in several settings .
the idea is to separate two object graphs such that operations taking place on the boundary between the graphs can be captured and potentially modified.
taser uses membranes at the boundary between a module and a client and between different modules to capture taint flows between them.
coarse grained alerts.
some tools most prominently npm audit7 and snyk8 warn developers about known vulnerabilities in any of their dependencies.
as discussed by lauinger et al .
an important limitation is that such tools do not analyze how dependencies are used and will warn even about vulnerabilities in code that a client does not use or not use in a vulnerable way.
a more precise analysis e.g.
based on specifications inferred by taser avoids the inevitable false positives caused by coarse grained alerts.
javascript program analysis.
the dynamic and reflective nature of javascript makes it difficult to construct sound whole program static analyses that scale to large real world applications .
for that reason much research has been devoted to constructing more pragmatic bug detection tools .
some frameworks facilitate the implementation of dynamic javascript analyses including nodeprof thattaser builds upon.
conclusion the massive use of third party libraries in modern javascript web development calls for new techniques to discover security vulnerabilities.
modular static taint analysis is a powerful approach as demonstrated by the successful commercial tool lgtm but it critically relies on taint specifications of the libraries being used.
writing such specifications manually is demanding and error prone so automated solutions are needed.
this work presents such a solution.
it combines and adapts a number of ideas from previous work in particular the idea of inferring information flow specifications using dynamic analysis the membrane mechanism the use of test suites of open source library clients and the notion of dynamic access paths .
our implementation and experiments demonstrate that this design is able to automatically detect non trivial and accurate taint flow specifications in widely used node.js modules which enables an existing static analyzer lgtm to discover many previously unknown security vulnerabilities.
we believe this approach is a alternative to the current coarse grained security tools likenpm audit that only consider the package dependency structure but completely ignore the dataflow.
our next step is to extend the implementation with support for more testing frameworks and then apply the approach in production.
thereby we can gain experience with its use in practice and possibly refine the expressiveness of the taint specifications to further increase the ability to detect vulnerabilities in real world javascript applications.