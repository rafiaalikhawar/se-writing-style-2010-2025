unrealizable cores for reactive systems specifications shahar maoz tel aviv university tel aviv israelrafi shalom tel aviv university tel aviv israel abstract one of the main challenges of reactive synthesis an automated procedure to obtain a correct by construction reactive system is to deal with unrealizable specifications.
one means to deal with unrealizability in the context of gr an expressive assume guarantee fragment of ltl that enables efficient synthesis is the computation of an unrealizable core which can be viewed as a fault localization approach.
existing solutions however are computationally costly are limited to computing a single core and do not correctly support specifications with constructs beyond pure gr elements.
in this work we address these limitations.
first we present quickcore a novel algorithm that accelerates unrealizable core computations by relying on the monotonicity of unrealizability on an incremental computation and on additional properties of gr specifications.
second we present punch a novel algorithm to efficiently compute all unrealizable cores of a specification.
finally we present means to correctly handle specifications that include higher level constructs beyond pure gr elements.
we implemented our ideas on top of spectra an opensource language and synthesis environment.
our evaluation over benchmarks from the literature shows that quickcore is in most cases faster than previous algorithms and that its relative advantage grows with scale.
moreover we found that most specifications include more than one core and that punch finds all the cores significantly faster than a competing naive algorithm.
i. i ntroduction reactive synthesis is an automated procedure to obtain a correct by construction reactive system from its temporal logic specification .
gr is an assume guarantee fragment of linear temporal logic ltl that has an efficient symbolic synthesis algorithm .
gr specifications include assumptions and guarantees that specify what should hold in all initial states in all states and transitions safeties and infinitely often on every computation justices .
the expressive power of gr covers many well known ltl specification patterns and it has been recently applied in several domains including robotics see e.g.
.
one of the main challenges of reactive synthesis in general and of gr synthesis in particular is to deal with unrealizable specifications .
to help engineers debug unrealizable specifications several works have suggested the computation and use of an unrealizable core a locally minimal subset of guarantees that is sufficient for unrealizability.
computing the core may be viewed as a faultlocalization approach to unrealizability.
however existing solutions to computing an unrealizable core suffer from three main limitations.
first core computationin existing solutions is costly as it requires many invocations of realizability checking.
second existing solutions are limited to finding a single core and thus provide only partial information about the realizability problems in the specification at hand.
third existing solutions are limited to pure gr specifications and do not correctly handle specifications with richer language constructs.
all these limit the applicability of core computations as an effective means to dealing with unrealizability.
in this work we address these three limitations.
our first contribution is quickcore a novel algorithm that accelerates unrealizable core computations.
the effectiveness and correctness of quickcore are based on four observations.
first that unrealizability is monotonic.
second that core computations can be incremental.
third that checking the realizability of specifications with fewer justices is typically significantly faster than of those with more justices.
and fourth that minimizing initial guarantees requires only one fixed point computation.
our second contribution is punch an algorithm to efficiently compute all unrealizable cores of a specification.
moreover punch computes the intersection of all cores without having to compute all of them.
in particular punch is able to quickly check whether a core that was found is the only one that may be found.
finally our third contribution is the extension of core computations to correctly handle specifications that include beyond pure gr elements higher level constructs such as patterns past ltl operators monitors and counters as supported e.g.
in spectra .
this is important in order to correctly apply core computations to these more compact and readable specifications and to present the results not at the level of the internal representation but at the abstraction level used by the engineer who wrote the specification.
it is important to note that while quickcore is specific to gr unrealizability punch is in fact a generic algorithm for computing all cores.
indeed the definition and correctness ofpunch in alg.
is independent of realizability checking or gr .
thus punch can be used e.g.
to compute all vacuity cores all realizable cores subsets of assumptions that suffice for realizability and more generally all locally minimal subsets for any monotonic criterion e.g.
unsatisfiability .
similarly our third contribution on correctly dealing with higher level constructs beyond pure gr applies not ieee acm 43rd international conference on software engineering icse .
ieee 1env boolean b1 2env boolean b2 3env boolean b3 5sys int .. f no buttons are initially pressed 8asm !b1 and !b2 and !b3 request is removed when satisfied 11asm g b1 and f next !b1 12asm g b2 and f next !b2 13asm g b3 and f next !b3 request must remain while unsatisfied 16asm g b1 and f!
next b1 17asm g b2 and f!
next b2 18asm g b3 and f!
next b3 lift is initially at lowest floor 21gar f always stay at same floor or move to adjacent floor 24gar g f next f and f next f do not move up when there are no requests 27gar g f next f b1 or b2 or b3 eventually grant each request 30gar gf b1 f 31gar gf b2 f 32gar gf b3 f visit every floor infinitely often 35gar gff 36gar gff 37gar gff listing lift controller specification adopted from only to unrealizable cores but in principle to any similar analysis of specifications with higher level constructs that are reduced to gr .
we consider this generality a nice advantage of our work with possible future applications beyond the focus of the present paper.
we implemented our ideas on top of spectra a rich specification language and open source tool set for reactive synthesis .
all our algorithms are implemented on top of and compared to recently suggested heuristics for realizability and core computations for gr .
we validated and evaluated our work on benchmarks from the literature.
the evaluation shows that quickcore is in almost all cases faster than previous algorithms and that many specifications indeed include more than one core.
it further shows that punch is much faster than a competing naive algorithm and that it is able to compute almost all cores for the syntech benchmarks in reasonable times.
means to deal with unrealizability of temporal specifications have been studied in the literature.
beyond unrealizable cores these also include different approaches to counterstrategy generation and assumption refinement or repair .
we discuss related work in sect.
ix.
ii.
r unning example as a running example we use a lift specification see lst.
taken from which has appeared in several variants in previous gr related papers .
the specification is written in spectra format .
it is smalland simple to fit the paper presentation.
in our evaluation we have used larger and more complex specifications taken from benchmarks.
the specification models a controller for a three floors lift.
the lift has three request buttons one on each floor.
requests are represented by environment variables b1 b2 andb3 which may be independently true or false.
the current floor of the lift is represented by the system variable f. the environment is required to initially have no requests l. turn off any granted request at the next step ll.
and keep ungranted requests ll.
.
the system is required to start the lift on the first floor l. and to disallow the lift to move more than one floor at a time l. .
the system is also required not to move up when there are no requests l. to eventually grant every request ll.
and to make sure every floor is visited infinitely often ll.
.
the specification is unrealizable but it is not easy to see why and debug it.
so the engineer may want to employ a faultlocalization approach and find an unrealizable core a locally minimal subset of guarantees that is sufficient for unrealizability.
a modified specification with only these guarantees is already unrealizable removing any one guarantee from that specification will render it realizable.
by running our new algorithm quickcore the engineer finds that the set of guarantees in lines f21 36g is a core.
however an unrealizable core is not necessarily unique i.e.
the specification may induce additional unrealizable cores.
our new algorithm punch first finds the above core then finds that the guarantee in line is the intersection of all the cores and finally reports all five remaining cores namely f21 37g f27 36g f27 37g f27 37g andf24 37g.
as our evaluation shows having more than one core is indeed rather common.
note that the early detection of the intersection of all the cores indicates whether additional cores exist.
moreover the intersection is of interest since making the specification realizable by removing or weakening only one guarantee is only possible with the guarantees in the intersection.
finally the size of the intersection serves as a lower bound on the size of any of the cores induced by the specification.
iii.
p reliminaries a. ltl gr and realizability we use a standard definition of linear temporal logic ltl e.g.
as found in over present future temporal operators x next u until f finally and g globally and past temporal operator h historically for a finite set of boolean variablesv.
ltl formulas can be used as specifications of reactive systems where atomic propositions are interpreted as environment input and system output variables.
an assignment to all variables is called a state.
gr is a fragment of ltl.
a gr specification contains initial assumptions and guarantees over initial states safety assumptions and guarantees relating the current and next state and justice assumptions and guarantees requiring that an assertion holds infinitely many times during a computation.
26we use the following abstract syntax definition of a gr specification taken from .
definition abstract syntax of a specification .
a gr specification is a tuple spec hve vs d m e msi whereve andvsare sets of environment and system variables respectively d ve vs!doms assigns a finite domain to each variable1 andmeandmsare the environment and system modules.
a module is a triplet m hi t jithat contains sets of initial assertions i fingi n safety assertions t ftngt n and justice assertions j fjngj n of the module wherei jij t jtjandj jjj.
the set of elements of modulem hi t jiisbm i fgtigt i fgfjigj i .
given a setzof variables z0 fxvjv2zg contains a copy of its variables at the next state.
let me hie te jei ms his ts jsi andv ve vs. then the elements ofie te je is tsandjsare propositional logic expressions overve v v0 e v v v v0andvrespectively.
gr has efficient symbolic algorithms for realizability checking and controller synthesis presented in .
for this a game structure of a two player game g hv x y e s e s i is defined.
the gr game has a set of variablesv ve vs environment and system variables x veandy vsresp.
environment and system initial states e d2iedand s d2isdresp.
environment and system transitions e t2tetand s t2tstresp.
and a winning condition v j2jegfj!v j2jsgfj.
a gr specification is realizable i.e.
allows an implementation iff the system wins the game.
roughly this means that if the environment keeps all initial assumptions then the system should keep all initial guarantees as long as the environment keeps all safety assumptions the system should keep all safety guarantees and in all infinite plays if the environment keeps all justice assumptions the system should keep all justice guarantees.
for this the algorithm of computes a winning region which is a set of winning states from which the system has a winning strategy.
a winning strategy prescribes the outputs of a system for all possible environment choices that allows the system to win.
the winning region is computed according to a fixed point computation over transitions and justices alone.
gr realizability checks if for all initial environment choices the system can enter a winning state.
gr synthesis computes a winning strategy if one exists.
b. monotonic criteria and cores given a sete and a monotonic criterion on subsets of e a core is a local minimum that satisfies the criterion.
formally definition monotonic criterion .
a boolean criterion over subsets ofeis monotonic iff for any two sets a b such that a b e ifasatisfies the criterion then bsatisfies the criterion.
1the use of any finite domain rather than only boolean variables is straightforward and supported by many tools including spectra.definition core .
given a seteand a monotonic criterion over its subsets a set c eis a core of eiffcsatisfies the criterion and all its proper subsets c0 cdo not satisfy the criterion.
unrealizability is monotonic w.r.t.
subsets of guarantees i.e.
adding guarantees to an unrealizable specification keeps it unrealizable.
intuitively this is so because adding guarantees strengthens the constraints on the system and does not change the constraints on the environment.
formally proposition unrealizability is monotonic .
given two specifications spec hve vs d m e m1 si andspec hve vs d m e m2 si such that bm1 s bm2 s. then ifspec is unrealizable spec 2is also unrealizable.
c. existing domain agnostic minimization algorithms we recall three existing domain agnostic minimization algorithms from the literature namely delta debugging ddmin quickxplain and linear minimization which we denote by linearmin.
all three algorithms find a core of a set e given a monotonic criterion check.
algorithm the delta debugging algorithm ddmin from as a recursive method that minimizes a set of elements eby partitioning it into nparts initial value n forpart2partition e n do if check part then return ddmin part end if end for forpart2partition e n do if check enpart then return ddmin enpart max n end if end for ifn jejthen returne end if return ddmin e min jej 2n we show a pseudo code for ddmin in alg.
.
the inputs for the algorithm are a set eand the number nof parts of eto check.
the algorithm starts with n and refines e andnin recursive calls according to different cases ll.
and .
the computation starts by partitioning einton subsets and evaluating check on each subset part and its complement.
if check holds l. or l. the search is continued recursively on the subset part or on its complement respectively.
if check holds neither on any subset part nor on the complements the algorithm increases the granularity of the partitioning to 2n l. and recurs or terminates when the granularity is not smaller than the size of e l. .
ddmin has quadratic worst case complexity and logarithmic best case complexity in terms of jej.
quickxplain is a recursive divide and conquer algorithm that minimizes each half one after the other in an incremental way see sect.
iii d .
it has a worst case complexity of o k klog jej k wherekis the size of the largest core.
to the best of our knowledge quickxplain was never previously 27applied to computing unrealizable cores for reactive systems specifications.
finally linearmin was originally suggested in and compared with ddmin in .
linearmin goes over elements of the input set one by one and removes an element iff the criterion holds for the set without the element.
an example of linearmin can be found in ll.
of alg.
.
the complexity of linearmin is linear injej.
d. minimization with a base and incremental core computation we define a notion of minimization with a base as follows.
definition minimization with a base .
assume a set eof elements two disjoint subsets base a e and a minimization algorithm alg that detects cores according to a monotonic criterion check.
assume also that the set base asatisfies the criterion.
we denote byminwbase alg e base a check an algorithm that computes a locally minimal a0 as.t.base a0satisfies the criterion by applying alg toa and replacing every check x operation with check base x .
monotonicity is ensured for minimization with a base becausea1 a2impliesbase a1 base a2.
note thatbase does not have to be a subset of a core ofe and it may contain a core.
base only has to satisfy a base and thatbase asatisfies the criterion.
the following holds trivially.
proposition .
given the notations of definition i ifbase is a subset of all cores of e thenbase a0is a core ofe.
ii ifbase contains a core of e thena0 .
finally we use the idea of incremental minimization in some of our algorithms.
lemma states that incrementally minimizing two subsets that partition a set produces a core.
lemma incremental core computation .
letaandb be disjoint sets such that e a bsatisfies a monotonic criterion.
let a0be a locally minimal subset of asuch that a0 bsatisfies the criterion and b0be a locally minimal subset ofbsuch thata0 b0satisfies the criterion.
then a0 b0is a core of e. proof.
by definition a0 b0satisfies the criterion.
a0exists becauseesatisfies the criterion and b0exists because a0 b satisfies the criterion.
to prove that a0 b0 eis locally minimal let x2 a0 b0.
ifx2a0then by definition of a0 a0nfxg bdoes not satisfy the criterion thus by monotonicity a0nfxg b0 does not satisfy the criterion either.
otherwise x2b0 and by definition of b0 a0 b0nfxg does not satisfy the criterion.
iv.qu i c k co r e we are now ready to present our first contribution the quickcore algorithm which aims to accelerate unrealizable core computations.
the correctness and efficiency ofquickcore rely on the following observations.
first that unrealizability is monotonic see prop.
.
second that it is possible to compute a core incrementally see lemma .
third that checking the realizability of specifications with fewer justices is typically much faster.
fourth that removing justice assumptions from an unrealizable specification that has no justice guarantees preserves unrealizability and preserves winning regions.
and finally that minimizing the initial assertions requires only a single computation of the winning region of the system plus a small constant number of symbolic operations.
a.quickcore algorithm overview roughly quickcore begins by trying to remove as many justices as possible.
therefore if no justice guarantees are required for a core it removes all of them and all justice assumptions.
otherwise it minimizes justice guarantees alone using ddmin with a base.
later quickcore minimizes safety guarantees using ddmin with a base.
finally quickcore minimizes all initial guarantees using linearmin.
algorithm presents quickcore in pseudo code.
quickcore minimizes guarantees group by group according to their type first justices then safeties and ending with initial assertions.
it begins with a realizability check of the specification without justice guarantees in line .
if the specification without these is realizable at least one such justice guarantee is required for unrealizability and so it minimizes justice guarantees alone i.e.
keeping all initial assertions and safeties using ddmin with a base in line .
otherwise it determines that the core it computes has no justice guarantees line and removes all environment justices in line before it continues to look for system safeties and initial assertions.
with a specification that has a minimized set of justice guarantees and maybe no environment justices quickcore usesddmin with a base in order to minimize the set of safeties alone line .
it keeps initial assertions and the minimized justice guarantees unchanged.
at the last stage of quickcore it computes the winning region of the system in line for the specification with the minimized set of justices and safeties.
it now uses linear minimization in the loop in lines going over initial assertions one by one and checking if the system wins without each.
if so we keep this initial assertion because we want to maintain unrealizability.
checking this is done with syswin e s w which determines if for every possible environment choice satisfying e there is a choice for the system from sthat is inside the winning region w. this is computed with a small constant number of symbolic operations.
remark .
realizability checks in our implementation use the performance heuristics suggested in .
quickcore must disable two of these heuristics namely fixed point recycling and early detection of unrealizability before line in order to avoid an incomplete winning region computation.
for example the latter heuristics may over approximate the winning region by halting the outer greatest fixed point when the winning 28region becomes small enough to ensure that the system loses.
this is good enough for realizability checks so we use it safely before line yet using it from that line on may wrongly keep some initial guarantees.
example .
for the specification in lst.
see sect.
ii quickcore finds that at least one justice is required for a core in line and detects the justice in line of the specification with the minimization in line .
given this justice the safety in line of the specification is detected in line .
lines decide that given the above two guarantees the only initial guarantee of the specification line is required for the core.
the resulting core is thus the set of guarantees in linesf21 36g.
algorithm quickcore given an unrealizable specification find a locally minimal subset of guarantees that keeps it unrealizable require an unrealizable specification s hve vs d m e msi where me hie te jeiandms his ts jsi ensure an unrealizability core of s .begin by minimizing only justice guarantees if realizable hv e vs d m e his ts ii then jc minwbase ddmin b ms is ts js realizable s else jc me hi e te i end if .continue with minimizing only safety guarantees tc minwbase ddmin b ms is jc ts realizable s .end with minimizing only initial guarantees w computewinregion hv e vs d m e his tc jcii ic is envini d2ied fori2icdo .use linear minimization for initial guarantees ic icnfig if syswin envini d2icd w then ic ic fig end if end for return ic tc jc b. correctness of quickcore quickcore is correct in the sense that it detects an unrealizable core of the guarantees.
to prove correctness we will show that finding cores of subsets of guarantees one by one yields a valid core removing all justice assumptions from a specification with no justice guarantees impact neither the realizability of any subset of guarantees nor the winning region of the system and it is enough to compute the winning region of the system once when minimizing initial guarantees.
a core can be computed in a compositional manner by minimizing pairwise disjoint subsets one by one using an extension by induction of lemma to any number of finite pairwise disjoint sets.
specifically quickcore partitions the set of guarantees into three sets and minimizes each set with established algorithms for local minimum namely ddmin and linearmin.
removing all justice assumptions when no justice guarantees are needed for a core does not affect the overallcorrectness of quickcore because realizability checks and computation of winning regions of the system are unchanged.
intuitively in an unrealizable specification with no justice guarantees the environment can and must win with finite plays of the game.
thus even though generally removing assumptions may turn a realizable specification into an unrealizable one this does not happen when removing justice assumptions from a specification with no justice guarantees.
for such specifications when the system does not lose finitely it wins the infinite games regardless of any justice assumptions.
accordingly all environment justices in this case are unhelpful in the sense defined in i.e.
assumptions whose removal does not change the realizability induced by any subset of the guarantees.
note that having several assumptions each unhelpful alone does not mean that they are unhelpful as a set yet justice assumptions in this case are unhelpful as a set.
formally the game structure of the gr game for both specifications is the same because in gr games justices appear only in the winning conditionv j2jegfj!v j2jsgfj.
when there are no justice guarantees this condition isv j2jegfj!
which is an ltl tautology regardless of the justice assumptions.
this ensures both the equirealizability which is needed for the correctness of the minimization of safeties in line and the correctness of the winning region computation in line .
finally the correctness of the minimization of initial guarantees follows from the fact that checking realizability has two parts.
we first compute the winning region of the system in the gr game and then check if the system can reach it given all possible environment initial choices.
since the winning region depends only on safeties and justices and we keep them unchanged at this phase of quickcore it is enough to compute the winning region only once.
c. complexity of quickcore consider a specification with nguarantees.
the worst case complexity of ddmin iso n2 realizability checks .
the same holds for quickcore.
v.pu n c h we now present our second contribution the punch algorithm for computing all cores.
punch finds all cores of a set eaccording to a monotonic criterion.
the algorithm is generic in the sense that it requires acheck that evaluates the monotonic criterion and a computecore e0 b that provides a core in e0 e givene0 that satisfies the criterion and a set b e0that is a subset of all the cores in e0.
in particular punch detects all minimal size cores.
as a byproduct punch provides an efficient way to find the intersection of all the cores without having to compute all of them.
this intersection provides an early estimate of the size of the smallest cores and in particular an early verdict on the existence of additional cores.
algorithm presents punch in pseudo code as a recursive algorithm that takes two parameters as input a set ethat has at least one core and a set kthat is a subset of all the cores 29algorithm punch find all cores according to a monotonic check require a set eof elements such that check e require a set k ethat is a subset of all cores in e ensure all cores in e c0 computecore e k allcores fc 0g ci cont forx2c0nkdo if check enfxg then add xtocont else add xtoci end if end for forx2cont do allcores allcores punch enfxg k ci end for return allcores ine.
the recursive algorithm finds all the cores in e. thus punch e returns all the cores in e. the algorithm finds its first core c0 eby applying computecore in line .
later in lines it splits all the elementsx2c0nkinto two sets according to whether enfxg satisfies the criterion.
cont gets all positives and cigets all negatives.
finally in lines for all elements x2cont it considers the punched sets enfxg hence the name punch and recursively looks for all cores inside them while adding citok.
by collecting all such cores into allcores the computation ends.
example .
applying punch to the example in lst.
finds the six cores of the run described in sect.
ii.
specifically that run is of pqc b ms see sect.
v c .
two cores consist of the guarantees in lines and one of the guarantees in lines and .
indeed if the lift starts at the first floor and moves up only when there are requests it may never be able to reach the other two floors.
three other cores consist of the guarantee in line and pairs of the guarantees in lines which require the elevator to visit two different floors infinitely.
indeed the system can be forced to visit the lower of the two floors and not to go up line .
finally the guarantees in lines and allow the environment to force the lift to the first floor line the system then may or may not move up to the second floor line which allows the environment to keep the lift bellow the third floor line and thus fail the guarantee to visit that floor line .
a. correctness of punch first we prove the following lemma.
lemma .
in running punch e after the loop in lines the set cicontains the intersection of all cores in e. proof.k thusci fx2c0jcheck enfxg ?g.
moreover check enfxg iffenfxgcontains a core iffxdoes not belong to all the cores in e. we now show that the preconditions hold in all recursive calls and that punch is sound and complete.the preconditions of punch are met in all recursive calls punch requires that esatisfies the criterion and that kis a subset of all the cores in e. the two preconditions must hold for the recursive calls in line .
according to line 8x2cont check enfxg which satisfies the first precondition.
according to lines and for all x2cont k ci enfxg.
now by assumption kis a subset of all the cores in e and by similar reasoning to that of lemma ciis also a subset of all the cores ine.
in particular for all x2cont k cimust be a subset of all the cores in enfxg.
this satisfies the second precondition.
punch is sound a set is added to our list of cores when it is detected by computecore in recursive calls at line of punch.
the preconditions of computecore are met because they match the preconditions of punch.
punch is complete this follows from thm.
below.
theorem .
letcbe a core of a set e. in running punch e k such thatkis a subset of all the cores in e we will have c2allcores in line of alg.
.
proof.
by induction on n jej notice that for n there must be exactly one core of size and the algorithm is correct for both possible choices of k. assume by induction that the claim is correct for all sets strictly smaller than n and fix a setjej nwithc ea core ofe.
ifcis detected in line c c0and we are done.
otherwise c6 c0.
sincecis a core and c0satisfies the criterion we know that c06 c thus there is an x2c0such thatx 2c.
moreover x 2kbecausek c sox2c0nk.
sincecis a core of eandx 2c cis a core of enfxg.
this means that enfxgsatisfies the criterion which in turn means that x2cont and sincejenfxgj n by inductioncis found as a core by the call to punch in line when thexof the loop coincides with the xin the proof.
this completes the proof.
b. complexity of punch in general the number of cores of a set according to a monotonic criterion may be exponential in the size of the set .
thus the worst case complexity of punch and of any other algorithm that would enumerate all cores is exponential.
lemma shows that obtaining the intersection of all the cores requires only one core computation plus a number of realizability checks the size of the core that we found.
c. employing punch to unrealizable cores employing punch to compute all unrealizable cores requires an implementation of check to check for unrealizability.
we created two implementations of punch which we label pud andpqc.
in pud we implemented computecore using ddmin with a base.
specifically computecore e k in line of punch is implemented withk minwbase ddmin e k e nk check .
inpqc we implemented computecore with an extended version 30ofquickcore that supports minimization with a base.
the version of quickcore minimizes justices safeties and initial assertions that do not belong to a given base set.
prop.
i ensures the correctness of both implementations of computecore.
vi.
m emoization we implemented memoization for our algorithms which allows us to avoid checking the criterion whenever the check is redundant based on the results of prior checks of the criterion and on the criterion s monotonicity.
basically we keep a set of prior positive checks and a set of prior negative checks of the criterion.
whenever a check for a set is about to occur if we already have a positive criterion subset then we know the set is positive and we avoid actually checking it.
similarly if we already have a negative superset then we know the set is negative.
only if memoization fails we perform an actual check of the criterion and store the result as positive or negative accordingly.
two additional features accelerate the required subset checks.
first we keep each memoized set sorted which enables linear time subset checks.
second we keep the collections of positive and negative results sorted according to the size of the memoized sets and look for subsets and supersets of relevant size only this is correct because a larger set cannot be a subset of a smaller set i.e.
if jbj jajthenb6 a .
a. memoization in quickcore realizability checks are the most computationally expensive parts of quickcore.
almost all these checks occur as a part ofddmin runs within it.
we use the ddmin implementation in spectra.
in this generic implementation of ddmin sets for which the criterion failed are recorded and we avoid checking them and their subsets because monotonicity ensures that they must fail as well.
this heuristics was already mentioned in and implemented in and in for unrealizable cores.
on top of it we use the memoization mechanism we described at the beginning of this section.
b. memoization in punch we seek to avoid as many as possible calls to check and tocomputecore.
forcheck we use the memoization mechanism we described in the beginning of this section and add all cores found by computecore to the set of positive sets.
in pqc andpud see sect.
v c all check operations share the same memoization whether the ones invoked at line of punch or at their particular implementations of computecore.
forcomputecore when we look for a core of a set e see line of punch we use the first core that is a subset of ein previously found cores if one exists.
this is important because for example having two disjoint cores means that without memoization we would run a core computation to unnecessarily seek the second core for every element of the first core.
memoization ensures that the number of times we run an actual core computation in punch is equal to the number of cores in e.1sys boolean b 3monitor boolean a !a initially false ga next a once true remain true forever 8gar b 9gar gbiff a listing an unrealizable specification with a monitor vii.
b eyond pure gr s pecifications we now present our third contribution correct and efficient core computations for specifications that are reducible to gr yet include language constructs beyond pure gr such as patterns monitors and past ltl formulas.
a. reducing higher level constructs into pure gr recall that many higher level language constructs can be reduced to pure gr form by replacing them with additional auxiliary variables as well as new guarantees or assumptions.
see e.g.
.
a pattern e.g.
the response pattern g p!fq which is not in pure gr form is reduced according to a deterministic buchi automaton that represents it.
the states of the automaton are encoded using new auxiliary variables its initial state is encoded using an auxiliary assertion about the initial values of the auxiliary variables its transitions are encoded using an auxiliary safety and its acceptance condition is encoded into a justice assumption or guarantee .
monitors and counters are constructs that track a certain value.
they are reduced by adding auxiliary variables that encode that value and optional auxiliary elements that are assertions about its initial value and its current and next values safeties .
for example the monitor in lst.
adds one boolean auxiliary variable a one auxiliary initial assertion line and one auxiliary safety line .
the reduction is completed by considering auxiliary variables and elements as system variables and guarantees respectively.
this allows one to apply gr realizability checks and synthesis.
b. a simple but incorrect approach one may suggest that core computations would minimize the gr system module elements and then trace back to the elements that induced them in the original specification.
this approach however is incorrect.
as an example for the unrealizable specification in lst.
the incorrect core computed by this approach contains only lines and .
the reason is that only system elements are minimized.
the incorrect computation ignores the auxiliary monitor initial assertion at line although without this assertion the specification is realizable!
if unrealizability is a result of auxiliary elements alone we may even incorrectly get an empty core see prop.
ii .
this means that we must also consider auxiliary elements for minimization and at the same time avoid redundant ones that unnecessarily complicate the reduced specification and inflate the state space.
31c.
our approach we have implemented a framework to correctly handle specifications that include high level constructs.
the framework relies on two way traceability between the high level language construct and the gr elements it reduces to.
specifically each distinguishable specification construct as written by the engineer is assigned an id that represents all of the gr elements it reduces to.
thus all elements induced from patterns and past ltl operators are assigned the id of the high level element they belong to while each assertion inside monitors and counters has its own id.
our implementation builds system and environment modules according to subsets of ids.
core computation begins with a set of all environment ids for the assumptions and a set of auxiliary and system ids for the guarantees.
it performs realizability checks given subsets of ids.
for example quickcore may eliminate all justice assumptions line .
if any of these justice assumptions were induced by patterns the produced environment module avoids not only these justices but also their matching pattern induced initial and safety assertions as well as the pattern induced auxiliary variables that encoded the states of this pattern s automaton.
these are the exact sets of elements and variables that match the subset of high level assumptions.
in lst.
the correct core we compute in this way includes lines and .
together they are sufficient for unrealizability and each of them is necessary.
viii.
e valuation we have implemented our ideas on top of spectra with the performance heuristics from .
our implementation includes quickcore andpunch.
for the purpose of evaluation it also includes an instance of the ddmin algorithm implemented in spectra an implementation ofquickxplain and a naive top down algorithm for computing all cores we label td see below .
all the above implementations take advantage of the memoization described in sect.
vi.
means to run our implementation all specifications used in our evaluation and all data we report on below are available in supporting materials for inspection and reproduction .
we encourage the interested reader to try them out.
the following research questions guide our evaluation.
r0which existing domain agnostic minimization algorithm is the most efficient in our setup?
r1isquickcore efficient in terms of the number of realizability checks and running time in comparison to previous algorithms?
r2isquickcore effective in terms of the size of the core it finds in comparison to previous algorithms?
r3are specifications with multiple unrealizable cores common and how many such cores do most specifications have?
r4ispunch efficient in detecting all cores?
below we report on the experiments we have conducted in order to answer the above questions.table i efficiency of ddm i nvs.qu i c k xp l a i n spec set 1s .
1s 10s 100s 100s syn15u .
.
syn17u .
.
.
.
.
am gn .
.
.
.
.
a. corpus of specifications we use the benchmarks syntech15 and syntech17 which include a total of specifications of autonomous lego robots written by 3rd year undergraduate computer science students in a project class taught by the authors of .
we use all the unrealizable gr specifications from these i.e.
unrealizable specifications from syntech15 which we label syn15u and unrealizable specifications from syntech17 which we label syn17u .
in addition we used different sizes of amba and of genbuf to masters to senders resp.
from each of the variants of unrealizability described in .
we label these specifications by am gn.
note that these specifications are structurally synthetic and artificially inflated.
we therefore report on their performance in r0 r1 and r4 but not on their more qualitative aspects r2 and r3 .
still the supporting materials include all the data we collected.
b. validation we have implemented an automatic test that checks that every core that we found is indeed a locally minimal subset of the guarantees that maintains unrealizability.
we run this check over logs of cores produced by our algorithms independent of their original detection.
we also verified that the different algorithms that compute all the cores of a specification i.e.
ones that terminated before the timeout was reached found the same number of cores.
c. experiments setup we ran all experiments on an ordinary pc intel xeon w2133 cpu .6ghz 32gb ram with windows bit os java 64bit and cudd compiled for 64bit using only a single core of the cpu.
times we report are average values of runs measured by java in milliseconds.
although the algorithms we deal with are deterministic we performed runs since jvm garbage collection and bdd dynamic reordering add variance to running times.
we used a timeout of minutes for the algorithms that compute all cores and no timeout for the algorithms that find a single core.
d. results existing domain agnostic algorithms in our setup in sect.
iii c we discussed three existing domain agnostic algorithms for finding a local minimum given a monotonic criterion.
we also noted that ddmin was compared and found superior to linearmin in .
32table ii efficiency of qu i c k co r e vs.ddm i n spec set 1s .
1s 10s 100s 100s syn15u .
.
syn17u .
.
.
.
.
am gn .
.
.
.
.
table i presents the performance of ddmin versus quickxplain.
the columns show the geometric mean of the ratio of the running times namely the running time of ddmin divided by that of quickxplain dissected by the running time range obtained for ddmin.
we use to mark cases in which no specifications had ddmin running time within the corresponding range.
for example the number .
in the second row means that for syn17u specifications for which a core was found by ddmin in between .
and seconds the geometric mean indicates that ddmin was more than three times faster than quickxplain.
the results show that ddmin is more efficient than quickxplain on all our corpus although the gap lessens with scale .
this justifies our choice of ddmin as the domainagnostic minimization algorithm inside quickcore and pud.
it also justifies our choice to use ddmin as the baseline algorithm for examining the efficiency of quickcore see r1 below .
to answer r0 ddmin is the most efficient domain agnostic single core computation algorithm in our setup.
e. results efficiency of quickcore versus ddmin table ii presents the performance of quickcore versus ddmin.
we chose to compare quickcore with ddmin because ddmin is a well known and widely used algorithm for core computation over a monotonic criteria and because it was previously used in the context of unrealizable cores for gr specifications.
moreover in r0 above we showed thatddmin is the most efficient domain agnostic single core algorithm on our corpus.
the columns show the geometric mean of the ratio of the running times namely the running time of quickcore divided by that of ddmin dissected by the running time range obtained for ddmin for all specifications in each set.
we use to mark cases in which no specifications had ddmin running time within the corresponding range.
for example the number .
in the third row means that for am gn specifications for which a core was found by ddmin in between and seconds the geometric mean indicates thatquickcore was more than three times faster than ddmin.
the results show that quickcore is in most cases much faster than ddmin.
this improvement gets better with scale i.e.
almost consistently the slower ddmin the faster quickcore becomes relative to it.
the acceleration is most noticeable for syn17u specifications for which ddmin require over seconds.
for those specifications quickcore was faster thanddmin by well over an order of magnitude.table iii core sizes spec set core size qc ddmin qx global syn15u .
.
.
.
syn17u .
.
.
.
table iv number of cores spec set s m syn15u syn17u the only two categories in which the running time of quickcore is worse than that of ddmin is for syn17u andam gn specifications whose ddmin running time is at most milliseconds.
since for this range running times are very small we do not consider it to be a major weakness of quickcore.
we also computed the actual number of realizability checks i.e.
without realizability checks avoided by memoization see sect.
vi of quickcore andddmin not shown in the table .
we found that the median reduction in the number of actual realizability checks of quickcore overddmin was .
.
and .
and over quickxplain was .
.
and .
for syn15u syn17u and am gn respectively.
to answer r1 quickcore typically performs fewer realizability checks than ddmin andquickxplain it is in most cases much faster than ddmin and the running time improvement seems to become better with scale.
f .
results effectiveness of quickcore table iii presents core size results.
column core size shows the median ratio between the size of cores found byquickcore and the total number of guarantees in the specification.
columns qc ddmin qx and global show the average absolute size of the cores found by quickcore ddmin quickxplain and the size of the smallest core found until the timeout by punch respectively.
the results show that in the syntech specifications most of the cores found by quickcore are over five times smaller than the total number of guarantees in the specification.
they further show that the cores found by quickcore have a slightly different size than the cores found by the other algorithms and that all algorithms output cores that are close in size to the size of the globally minimal core.
to answer r2 quickcore ddmin and quickxplain are all effective in localizing unrealizability.
g. results number of cores in specifications table iv presents the number of cores in the syntech specifications.
columns s and m show how many specifications have a single core and multiple cores resp.
the remaining four columns show how many of these specifications have at least and cores.
for example the syn15u tdsyn15u pudsyn15u pqcsyn17u tdsyn17u pudsyn17u pqcam gn tdam gn pudam gn pqc specifications .1s1s10s100s600stofigure .
running times to compute all cores using td left columns pud center columns and pqc right columns for the syntech and the am gn sets divided by increasing ranges in seconds.
number in the first row under means that exactly one specification of syn15u has at least cores.
to answer r3 most syntech specifications have multiple cores.
specifications with over cores exist in each set of specifications.
these results motivate the need to compute more than one core per specification.
h. results running times of all cores algorithms in order to evaluate the performance of punch for computing all unrealizable cores we use pqc andpud see sect.
v c .
since punch is the first algorithm employed to compute all unrealizable cores for temporal specifications reducible to gr as a comparison we use a rather naive baseline we label td we discuss alternative algorithms in sect.
ix .
tdis a naive top down search for all cores.
for a given subset of guarantees if check fails tdknows that the subset and all its subsets are not cores.
otherwise it continues recursively to all subsets that exclude exactly one element.
it detects the set as a core iff all of these subsets fail check.
it memoizes subsets we already finished computing all cores for to avoid unnecessary recursive calls in addition to the memoization described in sect.
vi .
to detect unrealizable cores check is implemented as an unrealizability check.
figure shows the running times for syn15u syn17u andam gn specifications.
each specification set has three columns one for td one for pud and one for pqc.
each column shows a breakdown of how many specifications completed running within .
and seconds.
finally we mark the number of specifications that timed out did not complete all runs within minutes with to.
the results show that the differences between the performance of pud andpqc are minor with mostly a slight advantage to pqc.
regardless of their minor differences the two instances of punch perform significantly better than td.
the two instances of punch were able to find all cores of syn15u specifications within seconds and out of the of the syn17u specifications before the timeout wasreached.
this is much better than td which was able to find all cores within the timeout for less than half of the specifications.
on am gn specifications pud andpqc found all cores for and specifications respectively but tddid not complete the computation on any of the specifications.
to answer r4 both instances of punch are significantly faster than tdin finding all the cores of a specification.
pqc seems slightly better than pud.
i. additional results recall that punch provides early detection of the intersection of all the cores see sect.
v b .
the size of the intersection is a lower bound on the size of the global minimum.
in practice it provides a good early estimate of the size of the global minimum for syntech specifications.
the results show that the core intersection size is on average .
and .
of the smallest core found by punch within the timeout forsyn15u andsyn17u respectively.
j. threats to validity we discuss threats to the validity of our results.
first symbolic computations are not trivial and our implementation ofquickcore ddmin quickxplain and punch may contain bugs.
to mitigate we performed a thorough validation using all specifications available to us see sect.
viii b. second we have based most of our evaluation on the syntech specifications which were created by 3rd year undergraduate cs students with no prior experience in writing ltl specifications collected by the authors of in classes they have taught .
we further examined specifications from the am gn set.
we do not know if these are representative of specifications engineers would write in practice.
third although we have found that cores are typically much smaller than the complete set of guarantees see tbl.
iii roughly guarantees instead of we did not perform a user study with engineers to examine whether users will find the reported cores useful for understanding the reasons for the unrealizability of their specifications.
ix.
r elated work a. a single unrealizable core for gr previous works have considered the computation of an unrealizable core for gr specifications.
cimatti et al.
have used linearmin see sect.
iii c .
konighofer et al.
have used ddmin and implemented it in the ratsy synthesizer.
their comparison of ddmin withlinearmin shows thatddmin is almost always much faster than linearmin with a greater advantage on larger specifications.
firman et al.
have used ddmin with several performance heuristics including memoization and implemented it in the spectra synthesizer.
all these were limited to computing a single core and did not correctly handle specifications with constructs beyond pure gr .
we present quickcore to be used instead of ddmin.
we further show how to correctly handle specifications with constructs beyond pure gr .
we compare 34quickcore to spectra s implementation of ddmin i.e.
with the heuristics from and our evaluation provides evidence thatquickcore is faster and scales better than ddmin.
our choice of ddmin for both the algorithm we compare to and the algorithm used within quickcore for the incremental minimization is based both on ddmin being a well known and widely used domain agnostic minimization algorithm and on the fact that it was the choice in previous work on gr unrealizability.
there are other domain agnostic minimization algorithms over monotonic criteria for single cores e.g.
quickxplain .
compared to ddmin quickxplain has a better asymptotic complexity in terms of the number of checks see sect.
iii c .
nevertheless as we show in our evaluation sect.
viii d quickxplain performs worse on our corpus.
for temporal specifications schuppan presented ltl unsatisfiability cores by weakening ltl formulas in a way that ignores sub formulas not required for unsatisfiability.
he further presented a similar approach for gr unrealizability cores.
to the best of our knowledge these ideas have only been explored theoretically.
moreover the work neither handles all cores nor deals with extensions of gr .
b. all unrealizable cores for gr we present punch as the first efficient algorithm to compute all unrealizable cores of specifications reducible to gr .
however punch is a domain agnostic algorithm.
other domain agnostic algorithms for all cores computations over monotonic criteria appear in the literature see e.g.
.
in there is a comparison of several such algorithms which concludes that none of the known algorithms is better than the others in all domains.
recently must was proposed as an algorithm and tool that outperforms previous ones.
punch is intended as a first algorithm for the computation of all cores of unrealizable gr specifications.
we consider its comparison against domain agnostic algorithms as well as its specialization for gr as future work see sect.
x. c. other approaches to dealing with gr unrealizability beyond core computations other approaches have been suggested to dealing with unrealizability of gr specifications.
maoz and sa ar have presented the computation of counter strategies which show how the environment can prevent any system from satisfying the specification.
kuvent et al.
have presented the jvts a symbolic more succinct and simple representation of a gr counter strategy.
other works have considered means to repair unrealizable specifications by automatically suggesting additional assumptions that will make the specification realizable see e.g.
.
it may be possible to combine the computation of a core or of all cores with a repair approach.
see our discussion of future work in sect.
x. x. c onclusion and future work we presented three contributions related to the computation of unrealizable cores of gr specifications including fasteralgorithms for computing an unrealizable core and for computing all cores.
we further presented means to correctly compute the core when specifications include high level constructs.
we implemented our work validated its correctness and evaluated it on benchmarks from the literature.
the evaluation shows that quickcore is usually faster than previous algorithms with a relative advantage that improves with scale.
moreover we found that most specifications have multiple cores and that punch finds all the cores significantly faster than a competing naive algorithm.
our work has important implications to anyone using gr specifications and their extensions for synthesis and related analyses.
first core computations are now faster and computing more than one core promotes a more comprehensive view of unrealizability.
moreover we handle higher level constructs correctly and efficiently and our algorithm for finding all cores extends to cores for any monotonic criterion.
we consider the following concrete future work directions.
first as punch in its raw form is domain agnostic it is important to compare its performance with recent domainagnostic all cores minimization algorithms over monotonic criteria such as must .
we have already presented a variant of punch namely pqc which employs a domain specific algorithm a variant ofquickcore to compute a single core and compared it with another variant namely pud which uses ddmin a domain agnostic algorithm for a single core computation.
the results showed that pqc performs slightly better than pud.
it may be possible to improve the performance of detecting all unrealizable cores by taking advantage of gr specific properties in other ways.
second we consider means to combine the computation of a core or of all cores with a repair approach.
for example a repair of unrealizability that is based on weakening a small as possible subset of the guarantees could rely on the fact that it cannot succeed without weakening at least one guarantee from every core or in particular weakening one guarantee from a non empty intersection of all cores.
finally the ability to compute all cores raises questions as to their presentation to the engineer.
should all cores be computed and presented?
perhaps an on demand approach should be used?
in which order should we present the cores?
these questions call for further investigation and evaluation.