trace checking cps properties bridging the cyber physical gap claudio menghi university of luxembourg luxembourg luxembourg claudio.menghi uni.luenrico vigan university of luxembourg luxembourg luxembourg enrico.vigano uni.ludomenico bianculli university of luxembourg luxembourg luxembourg domenico.bianculli uni.lulionel c. briand university of luxembourg luxembourg luxembourg university of ottawa ottawa canada lionel.briand uni.lu abstract cyber physical systems combine software and physical components.
specification driven trace checking tools for cps usually provide users with a specification language to express the requirements of interest and an automatic procedure to check whether these requirements hold on the execution traces of a cps.
although there exist several specification languages for cps they are often not sufficiently expressive to allow the specification of complex cps properties related to the software and the physical components and their interactions.
in this paper we propose i the hybrid logic of signals hls a logic based language that allows the specification of complex cps requirements and ii theodore an efficient smt based trace checking procedure.
this procedure reduces the problem of checking a cps requirement over an execution trace to checking the satisfiability of an smt formula.
we evaluated our contributions by using a representative industrial case study in the satellite domain.
we assessed the expressiveness of hls by considering requirements of our case study.
hls could express all the requirements.
we also assessed the applicability of theodore by running the tracechecking procedure for trace requirement combinations.
theodore was able to produce a verdict in .
of the cases.
finally we compared hls and theodore with other specification languages and trace checking tools from the literature.
our results show that from a practical standpoint our approach offers a better trade off between expressiveness and performance.
index terms monitors languages specification validation formal methods semantics i. i ntroduction cyber physical systems cpss combine cyber and physical capabilities .
cyber capabilities are typically provided by software components that sense and act on the physical environment while physical capabilities are provided by the environment in which the software is deployed.
therefore cpss combine software and physical dynamics.
physical dynamics are typically modeled through formalisms that capture the continuous evolution according to physical laws of the environment over time e.g.
differential equations the corresponding behaviors are typically represented as continuous signals.
software i.e.
cyber dynamics are typically modeled with discrete event systems e.g.
finite state machines whose this work was carried out while the author was a student at politecnico di milano italy during an internship at the snt centre of the university of luxembourg.behavior is typically represented by a sequence of events.
cyber physical systems exhibit hybrid dynamics since they combine both physical and software capabilities.
engineers collect traces i.e.
logs describing the behavior of a cps both when the cps is simulated and by means of instrumentation and logging mechanisms during the actual execution of the cps.
a trace is a sequence of records that contain some information about the execution or the simulation of the cyber physical components e.g.
the state of the system variables .
trace records are usually labeled with time stamps representing the time instants at which the recorded information was obtained.
engineers analyze these traces to check whether they conform to the system s requirements specifications this activity can be automated by means of trace checking tools.
specification driven trace checking tools usually take as input a trace to be analyzed and a requirement specification they yield a boolean verdict indicating whether the trace satisfies the specification.
the algorithms implemented by trace checking tools are typically language specific.
in the context of trace checking there exist two main categories of languages used for specifying cps requirements time based andsequence based languages.
time based languages e.g.
stl stl rfol sfo tptl .
and sb tempsy dsl interpret the records of the cyber and physical components as signals over atime domain.
specifications written in a time based language express time relations over the occurrence of events.
such languages are suitable to express cps requirements related to physical quantities an example of such requirement is p1 between sand10 s measured starting from the origin of the trace the speed of the satellite is lower than m s .
however time based languages are not easily amenable to specifying requirements related to software components.
as an example let us consider the requirement p2 whenever the satellite changes its mode from safe to normal the speed of the satellite decreases .
to express the first part of this requirement marked in italics one should specify that in the trace there are two consecutive records the first record captures that the satellite is in safe mode and the second record captures that the satellite is in normal mode .
this requirement cannot be easily expressed in time8472021 ieee acm 43rd international conference on software engineering icse .
ieee based languages since they generally do not provide constructs specifically designed to specify the first condition i.e.
that a record immediately follows another one in the trace.
indeed expressing such a condition requires the specification language to provide access to the indices i.e.
positions in the trace of the different records.
on the other hand in sequence based languages such as ltl and domain specific languages based on one of its extensions like the one in the spear tool fretish and cocospec traces are sequences of consecutive records whose temporal model is represented by the sequence ofdiscrete indices of the records.
this class of languages interprets the records of the cps software and physical components as discrete time signals.
specifications in these languages constrain the indices in which events can occur such specifications are used to express properties that mostly refer to the cps software components such as the first part of the aforementioned p2 property.
however these languages cannot express time relations over the occurrence of events such as the one in property p1.
a third class of specification languages is the one of hybrid languages e.g.
stl mx hyltl hreltl differential dynamic logic htl which support the specification of both continuous and discrete behaviors.
however these languages typically extend existing languages e.g.
ltl to support the specification of hybrid behaviors in specific contexts e.g.
using signal derivatives .
therefore they provide ad hoc solutions that inherit some of the intrinsic limitations of the base language thus hindering the expressiveness of the resulting hybrid language.
for example a hybrid language based on ltl cannot support metric operators to constrain the time distance between events.
the goal of this paper is to tackle the challenge of specifying hybrid behaviors of cpss in a way amenable to practical and efficient trace checking.
to reach this goal we propose i the hybrid logic of signals hls a new specification language tailored to specifying cps requirements.
hls allows engineers to express cps requirements as properties i.e.
specifications that refer both to the time stamps and to the indices of the records of cps traces.
in this way hls specifications can easily express the behavior of both cyber and physical components as well as their interactions.
ii theodore an efficient trace checking approach for properties expressed in hls.
theodore reduces the problem of checking an hls property on a trace to a satisfiability problem which can be solved using off the shelf satisfiability modulo theories smt solvers.
the latter have efficient decision procedures for several background theories thus making it possible to check whether a formula expressed in a first order logic is satisfiable.
we evaluated our contribution using an industrial case study in the satellite domain in collaboration with the engineers who developed the satellite s on board system.
i we assessed the expressiveness of hls by checking whether it could express the requirements of our case study.
our results show that hls could express all therequirements of our case study.
we also compared hls with sb tempsy dsl and stl two specification languages proposed in the literature and for which trace checking tools are available.
the results show that hls is significantly more expressive than sb tempsy dsl and stl which could only express and requirements respectively.
ii we evaluated the trace checking support provided by theodore by assessing its applicability on large traces provided by our industrial partner and obtained by simulating the behavior of the satellite across representative different scenarios.
we ran the theodore trace checker on tracerequirement combinations.
theodore completed the verification in .
of the cases within one hour a reasonable timeout considering typical cps development contexts.
theodore yielded a verdict for .
of the trace requirement combinations containing a requirement that can not be verified by any of the other trace checkers.
we compared the applicability of theodore with sb tempsy check and breach for the trace requirement combinations containing requirements expressible in sb tempsy dsl and stl.
for these combinations sb tempsy check and breach were .
and .
more often applicable than theodore respectively.
sbtempsy check and breach were also more efficient but not to a point where it had practical implications.
our results show that theodore is broadly applicable as it allows engineers to specify a large variety of requirements while providing an efficient trace checking procedure.
since in practical applications it is generally difficult to know in advance which requirement types engineers will need to specify our findings suggest that theodore is good default choice.
however if theodore is not able to produce a verdict and the requirement are expressible in sb tempsy dsl or stl engineers should then use sb tempsy check or breach.
the paper is organized as follows.
section ii describes our case study.
section iii illustrates the syntax and semantics of hls.
section iv presents theodore.
section v evaluates our contribution based on an industrial case study.
section vi discussed related work.
section vii concludes the paper.
ii.
c ase study and motivations our industrial partner luxspace developed in collaboration with esa and exactearth a maritime satellite to collect tracking information from vessels operating on earth and to relay those data to the ground.
this is a representative cps made of complex software component interacting with many actuators and sensors and the physical environment where the satellite is to be deployed.
this system should satisfy many varied requirements regarding the behavior of the software system itself but also its interactions with hardware and the satellite physical dynamics in space.
its development relies on technologies and practices typically seen in cps contexts e.g.
model in the loop development with simulink .
software engineers check the compliance of the satellite behavior to its requirements both while the software is being developed and at run time.
this is done by i collecting 848ang rate mode timestamp index recorda3 figure a fragment of an execution trace of our case study.
execution traces of the system and ii checking whether those traces satisfy the system requirements.
figure shows a fragment of an execution trace which we will use to motivate this work.
a trace is a sequence of records that contain some information about the execution of the system.
in this example the records include data about the angular rate ang rate and the satellite mode mode .
the angular rate is a physical quantity represented by a real value measured by sensors.
the mode is an enumeration of values that represent the state of the satellite software.
there are four different modes idle mode safe spin mode normal mode coarse and normal mode fine which are represented in the trace by the values and respectively.
in addition each record is associated with a timestamp representing the time instant at which the recorded information was obtained and a progressive index value.
the requirements to be checked on the system traces refer both to the software and to the physical dynamics of the satellite.
for example let us consider requirement r1 whenever the satellite mode switches from idle mode to normal mode fine the satellite angular rate shall reach a value lower than swithin s. moreover the angular rate shall stabilize around an arbitrary value 2lower than or equal to s.r1specifies a constraint on a physical quantity i.e.
the angular rate of the satellite which shall be ensured as a reaction to a software change i.e.
the satellite switching its mode from idle to normal mode fine .
one way to express that the mode of the satellite switches from idle mode to normal mode fine is to specify that the trace contains two records with consecutive indices the first record captures that the satellite is in idle mode the second record captures that the satellite is in normal mode fine .
this requirement cannot be easily expressed in the vast majority of time based languages since they do not provide access to the indices of the different records.
to compensate for this limitation when using time based languages engineers can apply ad hoc solutions such as adding a new boolean flag to the trace records.
in our example such a flag would be true whenever the mode of the satellite switches from idle mode to normal mode fine .
in this way the aforementioned requirement fragment would be rephrased as the flag switch from idle to normal mode fine is true.
however this is impractical in real scenarios because i the number of flags to add in the trace records can quickly grow and become unmanageable.
for example giventhe four possible values for the satellite mode in our case study to consider all possible combinations for switching satellite mode engineers would need to add values in each record one for each mode switching combination .
ii the requirement is reformulated and its connection to the actual software component behavior is lost.
furthermore requirement r1cannot be expressed using sequence based languages because they do not support time relations over the occurrence of events.
more specifically expressing that the angular rate shall reach within s requires to access the timestamps associated with the trace records and compute a distance .
this feature is not provided by sequence based languages.
moreover to the best of our our knowledge among the time based and sequence based languages mentioned in the previous section sfo is the only language that allows users to use quantified variables in specifications as in there exist an arbitrary value 2lower than or equal to s around which shall stabilize .
this type of requirements is quite common in practical cps applications since engineers often want to check that the system stabilizes around a given value e.g.
the steady state value .
although engineers know some properties of the steady state value i.e.
2shall be lower than or equal to s they generally do not know its exact value which has to be indicated as a generic variable in the requirement specification.
this example extracted from our case study shows the need for an expressive language for specifying hybrid behaviors of cpss.
in the next section we will introduce a new specification language for cpss which overcomes the limitations in terms of expressiveness of state of the art languages and is supported by an effective trace checking procedure.
iii.
h ybrid logic of signals in this section we illustrate hls hybrid logic of signals our new specification language for cpss.
we first discuss the design goals of the language section iii a .
then we define the mathematical model of the traces considered in this work section iii b .
finally we present the syntax section iii c and the semantics section iii d of the language.
a. design goals we designed hls to provide a language for specifying cps properties that seamlessly combine the features of sequencebased and time based languages.
therefore hls extends existing time based languages e.g.
stl rfol and sfo and sequence based languages e.g.
ltl fretish and cocospec to allow engineers to refer both to trace indices and to timestamps in the logical specifications to arbitrarily combine them to define properties describing the expected behavior of a cps and to express properties by quantifying over the values of the variables.
more specifically hls allows engineers to use first order existential anduniversal quantifiers with timestamp variables to express properties that refer to specific time instants and to the distance among them 849such as there exists a time instant cwithin sfrom the current time instant trace index variables to express properties that refer to the indices of trace records such as for every trace index8 such that the corresponding record captures that the satellite is in idle mode and the immediately following record at trace index 1 captures that the satellite is in normal mode fine real valued variables to express properties that refer to arbitrary signal values such as there exists a value lower than or equal to saround which the signal ang rate shall stabilize .
additionally hls supports specifications that use the value of a signal at a certain timestamp or associated with a record at a certain index the timestamp associated with the record at a certain index the index of the record with a certain timestamp expressions combining time variables trace indices and real valued variables using arithmetic and relational operators.
b. traces letj f0 g with elements 92n be a set of indices.
let tbe an interval of r we call ta time domain.
let fb1 b2 b8 b gbe a set of variables hereafter called signals of the systems being monitored with b82r.
a tracecis a finite sequence of records a0 a1 a9 a with92j.
each record a9is a tupleh9 c e e2 e i where92jis the index associated with the record c2tis the timestamp at which the recorded information was obtained and e1 e2 e 2rare the values associated with signals b1 b2 b in the record.
for a trace cwe use the array notation to denote the9 th record of c and we use the dot notation to denote an element of a record we also introduce the notation c9 short forc cfor a given trace c. for example let c4 be the fragment of the trace depicted in figure it contains seven records.
record a3is denoted by c4 it is represented by the tupleh3 4i wherec4 c c3 8is the value of the timestamp c4 mode 0is the value of signal mode and c4 ang rate 4is the value of signal ang rate.
we assume that the values associated with the timestamps are monotonically increasing i.e.
c9 c9 1 since records refer to consecutive timestamps.
we say that a trace has a fixed sample rate srif for every c9 1 c9 sr where sris a constant value otherwise we say that the trace has a variable sample rate.
for example trace c4in figure has a variable sample rate.
additionally we introduce a function c t!j given a timestamp value c c1cois the value of the index 9of the record incwith the highest timestamp c9such thatc9 c we will omit the trace subscript when it is clear from thecontext.
for example for trace c4in figure c412 5o .
in this work we consider two definitions of 1co c0 c1 c c c1 c1 c c c c1 c c 1o c c1 1co jc srk definition 1coassumes that the trace has a variable sample rate.
notice that the notation where is a logical predicate is the iverson bracket it evaluates to if is true and to otherwise.
the resulting arithmetic formula checks where the timestamp cprovided in input is situated w.r.t.
the timestamps of the trace i.e.
c0 c1 c and returns the value of the index of the record that has the highest timestamp that is smaller than or equal to c. for example if the parameter cis greater than timestamp c2and lower than timestamp c3 the only expression in 1cothat does not evaluate to is c2 c1 c c therefore the index returned will be .
definition 1coassumes that the trace has a fixed sample rate.
in such as case the index associated with a timestamp can be simply retrieved by computing the floor of the ratio of the timestamp cover the sample rate sr. in this work we assume that all the variables are sampled at each timestamp.
this is a necessary requirement to enable the evaluation of the satisfaction of the system requirements at each timestamp.
for systems that do not sample all the variables at each timestamp engineers can use a pre processing step to generate values to be assigned to variables for which the value is missing at certain timestamps.
in this work we consider two complementary pre processing strategies a1 in each record an interpolation function e.g.
piecewise constant linear cubic specific to each signal is used to generate values for unassigned variables.
notice that this approach does not alter the original sample rate of the trace since it keeps the same records as the original trace and only generates in each record values for the unassigned variables.
a2 if the trace has a variable sample rate it is converted into a trace with a fixed sample rate.
this is done by generating a fresh set of records with a fixed sample rate equal to the smallest sample rate i.e.
the minimum time distance between two records of the original trace and by using the interpolation functions as in the case of strategy a1 to generate the values of allvariables.
as we will discuss in section v the strategy used to generate the values of unassigned variables determines the trace accuracy.
the latter influences the trace checking verdict and may impact on the correctness of the trace checking procedure.
c. syntax an hls formula is defined according to the grammar presented in figure whose start symbol is p. in the grammar we use the symbol 5to represent a generic binary arithmetic function the symbol jseparates alternatives.
in the following we illustrate the various language constructs in the explanations we will refer to the set tv fg0 g1 gof timestamp variables over t the set iv ff0 f1 gof index variables 850overj and the set rv fd0 d1 gof real valued variables overr.
aterm non terminal tm can be either a time term an index term or a value term.
atime term non terminal tt allows engineers to refer to timestamps in the specifications.
a time term can be a timestamp variable g2tv a literal denoting a value c2t the value returned by the operator i2t or an arithmetic expression over these entities.
the operator i2t it takes an index term as argument and returns the timestamp associated with the record at the trace index it.
an example of time term is the expression g0 5 i2t12o.
anindex term non terminal it allows engineers to refer to trace indices in the specifications.
an index term can be an index variable f2iv a literal denoting a value 92j the value returned by the operator t2i or an arithmetic expression over these entities.
the operator t2i tt takes a time term as argument and returns the index 9of the trace record with timestamp c9 wherec9is the highest timestamp value for which c9 tt.
an example of index term is the expressionf0 2 t2i13 3o.
avalue term non terminal vt allows engineers to refer to real values e.g.
signal values in the specifications.
a value term can be a real valued variable d2rv a literal denoting a valueg2r the value of a signal returned by the operators i at index and t at timestamp or an arithmetic expression over these entities.
the ioperator is an infix operator that takes two arguments a signal band an index termit it returns the value of signal bassociated with the record at the trace index it.
similarly the toperator is an infix operator that takes two arguments a signal band a time term tt it returns the value of signal bassociated with a record at timestamp c9 wherec9is the highest timestamp value in the trace for which c9 tt.
an example of value term is the expression 1b1 i2o 1b2 t3 3o d0 5 where b1andb2are signals 2is an index term 3is a time term d0is a real valued variable and 2is a numeric literal.
aformula non terminal p is a relational expression over terms a logical expression over other formulae defined using boolean connectives or an existentially quantified formula.
as anticipated in section iii a hls supports three types of quantification i over timestamp variables as in exists gin where is a time range with bounds in t ii over index variables as in exists fin where is a range of index values with bounds in j iii over real valued variables as in exists d .
for example the formula existsf0in 4such that 1b1 if0o 5specifies that there exists a record with index greater than or equal to 3and lower than or equal to in which the value of signal b1is less than .
the language is further extended with additional relational operators additional logical connectives e.g.
implication implies conjunction and and universal quantifiers forall on timestamp variables index variables and realvalued variables using the standard logical conventions.term tmfttjvtjit time term ttfgjcji2t1itoj51tt1 tt2o index term itffj9jt2i1ttoj51it1 it2o value term vtfdjgj1b iitoj1b tttoj51vt1 vt2o formula pftm1 tm2jnotpjp1orp2 jexistsgin such that p jexistsfin such that p jexistsdsuch that p c2t 92j g2r g2tv f2sv d2rv b2 figure syntax of the hybrid logic of signals.
we now present an application of hls for the specification of one of the requirements in our case study.
let us consider a fragment of requirement r1 whenever the satellite mode switches from idle mode to normal mode fine the satellite angular rate shall reach a value lower than s within s. we recall that the satellite mode is represented by the signal mode for which value corresponds to idle mode and value corresponds to normal mode fine also the angular rate is represented by the signal ang rate.
this fragment can be specified in hls as forallf0in 4such that 11mode if0o 0and1mode i1f0 1oo 3o implies exists g0in s s1 such that 1ang rate t1g0 i2t1f0oo 5oo the sub formula11mode if0o 0and1mode i1f0 1oo 3odetects when the satellite switches from idle mode to normal mode fine over two consecutive records notice the use of the at index operator to refer to the consecutive indicesf0andf0 1 .
this expression is within the scope of the outer universal quantifier which iterates over a range of values for the index variable f0.
this range depends on the length of the trace and on the use of f0in the formula.
in this case since the requirement says whenever the satellite mode switches.
.
.
in the specification we want to cover the full length of the trace fragment c4in figure where record index values span from to .
we achieve this by setting the lower bound to zero and the upper bound to five in this way the term mode i1f0 1oalways refers to a record index of the example trace.
the inner quantification over the timestamp variable g0 checks whether the angular rate of the satellite reaches a value lower than swithin s. more specifically the expression1ang rate t1g0 i2t1f0oo 5orepresents the value of signal ang rate at timestamp g0 i2t1f0o whereg0is in the interval s s1 corresponding to the distance of s and i2t1f0ois the timestamp at which the satellite switches from idle mode to normal mode fine i.e.
the timestamp associated with the record at index f0.
851d.
semantics to evaluate whether an hls formula is true or false over a tracec we must first define how time index and value terms are interpreted and evaluated.
let tv iv rvbe variable assignments respectively for timestamp index and real valued variables for example tv is a mapping from a timestamp variable in tvto a value in t. let denote collectively the family of variable assignment functions tv iv rv.
we evaluate a generic term tmon a tracec using the variable assignment functions in by means of an interpretation function tm c .
the interpretation of hls terms is defined inductively at the top of figure .
for all three term types the interpretation of a literal is the value denoted by the literal itself a variable is interpreted using the variable assignment function for the corresponding type an arithmetic expression defined using a function5is interpreted by applying the interpretation of the function symbol 5to the interpretation of the corresponding arguments.
the operators i2t t2i i and tare interpreted according to the informal semantics provided in the previous section.
the semantics of an hls formula qis defined over a trace c and a variable assignment we use the notation 1c oj qto indicate that trace csatisfies formula qunder variable assignment .
the satisfiability relation of hls formulae is defined inductively at the bottom of figure .
the formula tm1 tm2 is satisfied if and only if iff the interpretation of term tm1 is lower than the interpretation of term tm2.
the semantics of the boolean connectives orandnot is the standard one.
a formula with an existential quantifier over a timestamp variable of the form existsgin such that p is satisfied iff there exists a timestamp c92 such that when substituting timestamp c9forgin the formula p denoted by p g c91 the resulting formula is satisfied.
the semantics of the other two types of formulae with an existential quantifier is defined in a similar way.
iv.
t race checking hls formulae in this section we present theodore our trace checker for hls.
theodore reduces the problem of checking an hls property on a trace to a satisfiability problem which can be solved using off the shelf smt solvers.
theodore takes as input a property qexpressed in hls and a tracec.
the first step of theodore is to automatically translating property qand tracecformulae expressed using a target logicl.
this translation relies on two translation functions h for hls formulae see section iv b and t for traces see section iv a and guarantees that 1c o j qiffh1 qo t1cois not satisfiable where is a model for h1 qo t1co i.e.
is a variable assignment leading to the property violation consistent with the values of the variables of the trace records.
the second step of theodore is checking the satisfiability of formulak h1 qo t1co expressed in the target logic lusing an smt solver.
based on the condition stated above whenkis satisfiable it means that qdoes not hold on thetime term interpretation g c tv1go for allg2tv c c c for allc2t i2t1ito c c it c c 51tt1 tt2o c 5 c 1 tt 1 c tt 2 c o index term interpretation f c iv1fo for allf2iv 9 c for all92j t2i1tto c c1 tt c o 51it1 it2o c 5 c 1 it 1 c it 2 c o value term interpretation d c rv1do for alld2rv g c g for allg2r 1b iito c c it c b 1b ttto c c c1 tt c o1 b 51vt1 vt2o c 5 c 1 vt 1 c vt 2 c o formula satisfaction 1c oj tm1 tm2 iff tm 1 c tm 2 c 1c oj notp iff1c o6j p 1c oj p1orp2 iff1c oj p1or1c oj p2 1c oj existsgin iff1c oj p g c91 such that p for somec92 1c oj existsfin iff1c oj p f such that p for some92 1c oj existsd iff1c oj p d e1 such that p for somee2r figure semantics of the hybrid logic of signals.
tracec.
vice versa when kis not satisfiable it means that q holds on the trace c. the final verdict yielded by theodore can be satisfied violated or unknown it is based on the answer of the solver.
theodore yields the definitive verdicts satisfied or violated when the solver returns unsat or sat indicating respectively that kis unsatisfiable or satisfiable.
however the solver may return an unknown answer since the satisfiability of the underlying target logic lis generally undecidable.
in our case this indicates that no conclusion is drawn on the satisfiability of formula k resulting in an unknown verdict returned by theodore.
assessing whether this is a frequent case in practical applications is part of our evaluation section v .
the target logiclto be selected for trace checking of hls properties in theodore shall fulfill two goals g1 be sufficiently expressive to encode the logic based representation of an input trace cand the semantics of an hls formula q. this means that it should include linear real arithmetic to support real valued and timestamp terms quantifiers since hls is a first order logic and arrays since a trace can be seen as an array of records .
g2 be supported by an efficient solver so that the trace checking procedure for hls formulae can be completed within practical time limits.
we have identified the auflira closed linear formulae with free sort and function symbols over one and twodimentional arrays of integer indices and real values fragment of the smt lib satisfiability modulo theories library 852logic as a suitable target logic for theodore.
the theories used by auflira are identifiable through its name a arrays uf extension allowing free sort and function symbols lira linear integer and real arithmetics.
furthermore auflira does not restrict the formulae to be quantifier free.
based on the list of supported theories auflira satisfies g1.
it also satisfies g2 since it is included in the smt lib logic whose satisfiability can be verified using highly efficient and optimized solvers as shown in the annual smt competition .
in the following subsections we will describe functions t andh.
for simplicity we will present the translation using the syntax of the z3 python api .
a. translating a trace into the target logic function ttranslates a trace cinto a logic formula expressed using the target logic l. to represent the sequence of timestamps in c the translation creates an array variable t the type of the array indices i.e.
the domain of t isz whereas the type of the array values i.e.
the range of t isr.
then the translation defines a series of constraints on the values in t the value of array tat position denoted by t is constrained to be equal to the value of the timestamp contained in the record at index 8of tracec.
in addition the translation creates an array variable for each signal whose values are recorded in the trace the variable name is the string obtained by concatenating v with the name of the signal.
for each of these array variables representing signals the translation defines a series of constraints on the values of the array the value of the array in position 8is constrained to be equal to the value of the corresponding signal in the record at index 8of tracec.
b. translating an hls formula into the target logic function htranslates an hls formula into a logic formula expressed using the target logic l. first the translation declares a new variable for each timestamp index and real valued variable used in the hls formula the name of the new variable is the string obtained by concatenating v with the named of the original variable.
the type of the new variables is real for timestamp and real valued variables and int for index variables.
afterwards the translation recursively evaluates each node in the parse tree of the input formula starting from the root node each node is translated using the rules shown in figure .
the translation of time index and values term nodes is defined as follows.
nodes referring to hls variables are translated into the corresponding variables in the target logic formula.
literal nodes are mapped into literals in the target logic formula.
arithmetic expressions using a function are translated by converting the function symbol into the equivalent in the target language and then by applying it to the translation of its arguments.
a time term node of the form i2t1ito is translated into an expression that accesses the element of the array tin position h1ito.
an index term node of the form t2i1tto is translated into the application of the translation of function toh1tto.
a value term of thetime term h1go v g for allg2tv h1co c for allc2t h151tt1 tt2oo h15o1h1tt1o h1tt2oo h1i2t1itoo t index term h1fo v f for allf2iv h19o for all92j h151it1 it2oo h15o1h1it1o h1it2oo h1t2i1ttoo h1 o1h1ttoo value term h1fo v f for allf2rv h1go g for allg2r h151vt1 vt2oo h15o1h1vt1o h1vt2oo h11b iitoo v s h11b tttoo v s o1h1ttoo formula with c0 c11 4and h1tm1 tm2o h1tm1o h1tm2o h1p1orp2o or1h1p1o h1p2oo h1notpo not1h1poo h1existsgin such that po exists1v g and1and1c0 v g v g c1o h1pooo h1existsfin such that po exists1v f and1and10 v f v f 1o h1pooo h1existsdsuch that po exists1v d h1poo figure rules for translating hls formulae into l. form1b iito is translated into an expression that retrieves the value of variable v bat index h1ito.
similarly a value term of the form1b ttto is translated into an expression that retrieves the value of variable v bat the index obtained through the evaluation of h1 o1h1ttoo .
the translation of function supports both definitions presented in section iii b. it consists of a rewriting of the definition into the equivalent syntax of the target logic.
we remark that the size of the arithmetic expression to compute h1 oin the case of a variable sample rate is linear in the length of the trace and the number of timestamp variables.
evaluating the impact of our translation and of the selection of the definition of function on the performance of the tracechecking procedure is part of our evaluation.
the translation of hls formulae is basically their rewriting into the equivalent syntax of the target logic modulo the translation of the variables and of the sub formulae.
for example a formula of the form existsfin such that pis rewritten as exists1v f and1and10 v f v f 1o h1pooo where the target logic variable v fcorresponds to variable fin the hls formula 0and1are the lower and upper bounds of the closed interval and h1pois the translation of sub formula p. theodore ensures that 1c o j qiffh1 qo t1cois not satisfiable.
the correctness of our procedure is based on two arguments i ttranslates the trace cinto a set of array 1our translation also supports open intervals.
in this case the relational operator instead of is used in the target logic formula to constrain the values v fcan assume.
853variables whose values are set according to the values of the original trace and ii hrewrites the hls formula into the target logic without applying any change that could alter the semantics to the structure of the formula.
c. implementation we implemented theodore as an eclipse plugin using xtext and xtend and made it publicly available .
we selected z3 as smt solver since it is an awardwinning industry strength tool.
as such it is likely to satisfy goal g2discussed above.
checking whether this conjecture holds is part of our evaluation.
v. e valuation in this section we report on the evaluation of our contributions.
first we evaluate the expressiveness of hls and compare it with state of the art specification languages.
second we evaluate the applicability of the theodore trace checker and compare it to state of the art tools.
specifically we aim to answer the following research questions rq1 to which extent can hls express requirements from industrial cps applications and how does it compare with state of the art specification languages in terms of expressiveness?
section v a rq2 can theodore verify cps requirements on real world execution traces within practical time and how does it compare with state of the art tools?
section v b a. expressiveness of hls rq1 to answer rq1 we collected a set of industrial cps requirements expressed in plain english text and verified whether they could be expressed in hls and in other stateof the art specification languages.
dataset.
we considered industrial requirements from our satellite case study coming from three different sources s1 61requirements were randomly selected from requirements contained in the requirement specification document of the satellite on board software obsw .
due to the prohibitive effort more than 20hours spanned across several working days involved both on our part and that of the domain experts who helped us formalize these requirements we could only process a subset.
such requirements mostly refer to the software dynamics of the satellite as in when the satellite switches to idle mode the obsw shall checkout the gps wait ms and then checkout the sun sensors .
s2 101requirements were provided by the authors of sbtempsy dsl .
they mostly refer to the physical dynamics of the satellite as in the beta angle shall show an oscillatory behavior with a maximum period of s .
s3 50requirements were extracted from the design and architectural documents of the satellite.
these documents describe the relations and interactions among the different components of the satellite.
they contain cyber physical requirements that relate the software and the physical dynamics of the satellite as in if the satellite mode switches from idle mode to safe spin mode and the satellite is not in eclipse table i number of requirements expressible in each of the languages for each set of requirements.s1s2s3 total hls o sb tempsy dsl o stl o the magnetic field recorded by the magnetometer shall contain a spike with a maximum amplitude of t .
methodology.
we tried to express the requirements from our dataset using hls and two state of the art specification languages namely sb tempsy dsl and stl .
we selected these languages because they are both supported by trace checking tools.
we assessed the extent to which requirements were expressible in each language.
results.
table i reports2the number of requirements that we were able to express in each of the languages for each set of requirements s s2 ands3 .
hls was able to express of the requirements while sb tempsy dsl and stl were able to express and of the requirements respectively.
these results confirm that hls is highly expressive and much more so than alternatives.
we remark that all the hls constructs were useful to express at least some of the considered cps requirements though in very different proportions.the answer to rq1 is that hls could express allthe requirements of our case study many more than sb tempsydsl 67 and stl 110 .
b. applicability of theodore rq2 to answer rq2 we i assessed to which extent theodore can be applied to check the execution traces of our case study ii compared in terms of applicability theodore with sbtempsy check and breach .
sb tempsy check is the trace checker for sb tempsy dsl breach is a trace checker for stl.
we chose breach among other similar tools listed in a recent survey i.e.
amt and s taliro because amt .
in contrast to breach is not publicly available and because breach is faster than s taliro .
furthermore we excluded from our comparison tools for online trace checking e.g.
socrates and rtamt .
dataset.
our industrial partner provided traces obtained by simulating the behavior of the satellite in different scenarios the simulation time ranged from four to six hours.
their size in number of entries ranges from to entries avg sd the corresponding file size ranges from mb to mb avg mb sd mb .
the traces have a considerably large yet variable number of records and size.
2the values in table i marked with an asterisk are slightly different from those reported in .
in the latter quantification on real valued variables not supported in stl and sb tempsy dsl was handled by artificially selecting a value for the quantified variables within their quantification range.
in this work we marked such requirements as not specifiable.
854for each trace in our dataset our industrial partner indicated which requirements to check.
indeed since only a subset of the satellite signals is recorded in each simulation scenario not all the requirements have to be checked on each trace.
in total we considered trace requirement combinations obtained from requirements in s1 obtained from requirements in s2 and obtained from traces in s3.
we remark that out of these combinations involve a requirement that can be expressed neither in sb tempsy dsl nor in stl.
our industrial partner used a variable sample rate for generating the trace records hence not all the signal values were recorded at each sample index.
since our approach assumes that all the signals are assigned a value at each sample index we pre processed the traces.
first for each trace requirement combination we filtered out from the trace all the records that contained only signals that were not used in the hls specification of the requirement.
this step prevents the trace checker from handling an unnecessarily large set of records.
then we transformed the traces using both pre processing strategiesa1anda2presented in section iii b in both cases the interpolation function to use for each signal was indicated by the engineers of our industrial partner.
by applying thea1anda2strategies on the original trace requirement combinations the final dataset contains trace requirement combinations with half of them obtained using one of the two strategies .
the size of the traces obtained using a1ranges from to entries avg sd the corresponding file size ranges from b to mb avg mb sd mb .
the size of the traces obtained using a2ranges from to entries avg sd the file size ranges from b to mb avg mb sd mb .
methodology.
we ran theodore over the tracerequirements combinations in our dataset.
when translating the hls properties in the target logic we used function for the trace requirement combinations generated using strategy a1 since the pre processed traces have a variable sample rate and function for those generated using strategy a2 since the pre processed traces have a fixed sample rate .
we conducted our evaluation on a high performance computing platform using nodes equipped with dell c6320 units xeon e5 2680v4 ghz gb .3each run checking a distinct combination of a trace and a property was repeated times to account for variations in the performance of the hpc platform and of the smt solver.
in total we executed runs of theodore.
we allocated gb of memory for each run and considered a timeout of one hour.
we recorded whether the trace checking procedure ended within the timeout the trace checking result and the time required to yield a verdict.
as for the comparison with sb tempsy check and breach we only considered the requirements from s2since it has the highest number of requirements expressible in sb tempsy3we executed our experiments on the hpc facilities of the university of luxembourg .table ii output of theodore percentage and execution time when using the pre processing strategies a1anda2.output avg min max sd a1satisfied .
.
.
.
.
violated .
.
.
.
.
unknown .
.
.
.
.
timeout .
max depth exceeded .
out of memory .
a2satisfied .
.
.
.
.
violated .
.
.
.
.
unknown .
.
.
.
.
timeout .
dsl and stl and it was recently used for comparing sbtempsy dsl with stl .
more specifically we considered the trace requirement combinations with requirements from the sets2 expressible in sb tempsy dsl and the trace requirement combinations expressible in stl.
we ran the tools following the same methodology described above.
since each run was repeated ten times in total we considered runs of sb tempsy check and runs of breach.
results applicability of theodore.
table ii shows the different types of output returned by theodore for checking the trace requirement combinations generated using the variable sample rate interpolation row a1 and the fixed sample rate interpolation row a2 .
column indicates the percentage of cases in which each type of verdict was returned.
for each of the cases in which theodore finished within the timeout i.e.
it yielded a satisfied violated or unknown verdict table ii also provides the average avg minimum min maximum max and standard deviation sd of the theodore execution time s .
the results in row a1show that theodore finished within the timeout in .
of the cases.
in .
of the cases theodore produced a definitive verdict i.e.
satisfied orviolated in .
of the cases theodore timed out.
theodore returned a max depth exceeded maximum recursion depth exceeded during compilation error in of the cases and an out of memory error in of the cases both errors are generated by the z3 solver.
the root cause of these errors is the translation of function used in the case of variable sample rate traces the size of the arithmetic expression resulting from the translation is linear in the length of the trace.
as expected theodore inherits the limitations of smt solvers and its applicability is expected to improve along with the quick pace of progress in that field.
the results in row a2show that theodore finished within the timeout in .
of the cases.
in of the cases theodore produced a definitive verdict in .
of the cases theodore timed out.
when using strategy a2 the number of times theodore reached the timeout was higher than when usinga1.
indeed many trace requirement runs that generated max depth exceeded andout of memory errors in the case of a1 timed out when using a2.
as discussed for the case ofa1 the applicability of theodore when using a2is 855determined by the scalability of the underlying smt solver.
to evaluate whether theodore is applicable in cases in which neither sb tempsy check nor breach is applicable we considered the subset of runs associated with the trace requirement combinations that involve a requirement that can be expressed neither in sb tempsy dsl nor in stl.
for those combinations theodore was able to produce a verdict in .
of the cases.
to evaluate the impact of the trace accuracy as determined by the application of the pre processing strategies a1and a2 on the correctness of the trace checking procedure we considered the 449runs in which theodore returned a definitive verdict both when using a1and when usinga2 and we compared the verdicts.
in .
of the cases over the verdicts coincided.
for the 22cases in which the verdicts were different we manually inspected the generated traces and confirmed that differences in verdicts were caused by the pre processing strategies.
overall these results show that theodore when configured with the pre processing strategy based on a fixed sample rate a2 produced a definitive verdict for a considerable number of trace requirement combinations thus confirming theodore s applicability in practical scenarios.
relying on thea2strategy led to a significantly wider applicability of theodore than with the a1strategy vs while resulting in negligible differences in trace accuracy.
therefore for comparing theodore with other tools we resorted to using thea2pre processing strategy.
finally we remark that theodore detected an issue in the satellite design some of the traces exhibited an unexpected spike in a signal related to the physical dynamics of the satellite which was caused by a change in a signal related to its software dynamics.
results comparison with other tools.
table iii reports the percentage of cases in which theodore sb tempsy check and breach provided a verdict within the timeout and the minimum maximum average and standard deviation of the time required to yield the verdict.
the results show that when the requirements are expressible in sb tempsy dsl and stl sb tempsy check and breach are faster than theodore.
however given the usage scenario considered in our work offline trace checking the difference in execution times reported in table iii does not have significant practical consequences since the average trace checking time less than two minutes is significantly lower than the time required to collect the traces several hours .
note that all tools were consistent in terms of verdicts when theodore returned a definitive verdict it matched the verdict returned by sb tempsy check and breach when they did not time out .the answer to rq2 is that theodore could compute a definitive verdict within one hour for .
of the tracerequirement combinations of our industrial case study and produced a verdict for .
of the trace requirement combinations that could not be checked by the other tools.table iii comparison of theodore sb tempsy check and breach in terms of the execution time.
tool avg min max sd theodore .
.
.
.
.
sb tempsy .
.
.
.
.
theodore .
.
.
.
.
breach .
.
.
.
c. discussion and threats to validity based on results we recommend the following workflow.
developers should initially use theodore since its language hls is the most expressive and it is generally difficult to know in advance which requirement types engineers will need to specify.
if the property to be verified does not contain thet2i hls operator which causes the generation of large arithmetic expressions engineers should use theodore with the pre processing strategy based on a variable sample rate a1 .
if the property contains the t2i operator engineers should use the pre processing strategy based on a fixed sample rate a2 .
if theodore was not able to produce a definitive verdict and the requirement is expressible in sb tempsy dsl or stl engineers should use sb tempsy check or breach.
threats to validity.
the requirements and traces we used in our evaluation come from a single case study in the satellite domain.
although this could influence the generalization of our results our industrial case study is representative of what can be found in other cyber physical domains where the system requirements are complex properties related to the software system its environment and their interactions and traces are obtained by simulating or executing the behavior of the cps in many different scenarios.
vi.
r elated work our contribution is mainly related to work done in the area of hybrid specification languages.
stl mx extends stl to define properties both on discrete time and on dense time.
the language includes two layers one based on ltl to express properties of discrete time boolean signals sampled at a fixed sample rate and another one based on stl to express properties on dense time realvalued signals.
time mapping operators define the conversion between dense time and discrete time signals and formulae.
a trace checking procedure has been proposed for stl mx but its implementation is not available.
compared with hls stl mx restricts discrete time boolean signals to be sampled at a fixed sample rate and lacks first order quantifiers on realvalued variables.
hyltl hreltl and htl extend existing languages e.g.
ltl with operators to express constraints on certain behaviors of signals e.g.
derivatives or limits .
in contrast to hls they cannot express properties that refer to specific time instants and to the distance between them.
differential dynamic logic differs from hls since it is designed for specifying properties of systems expressed using 856the hybrid system modeling formalism.
as such its modal operators enable