identifying casualty changes in software patches adriana sejfia sejfia usc.edu university of southern california california usayixue zhao yixuezhao cs.umass.edu university of massachusetts amherst massachusetts usanenad medvidovi neno usc.edu university of southern california california usa abstract noise in software patches impacts their understanding analysis and use for tasks such as change prediction.
although several approaches have been developed to identify noise in patches this issue has persisted.
an analysis of a dataset of security patches for the tomcat web server which we further expanded with security patches from five additional systems uncovered several kinds of previously unreported noise which we call nonessential casualty changes .
these are changes that themselves do not alter the logic of the program but are necessitated by other changes made in the patch.
in this paper we provide a comprehensive taxonomy of casualty changes.
we then develop cascade an automated technique for automatically identifying casualty changes.
we evaluate cascade with several publicly available datasets of patches and tools that focus on them.
our results show that cascade is highly accurate that the kinds of noise it identifies occur relatively commonly in patches and that removing this noise improves upon the evaluation results of a previously published change based approach.
ccs concepts software and its engineering keywords software patches change based analysis noise in patches acm reference format adriana sejfia yixue zhao and nenad medvidovi .
.
identifying casualty changes in software patches.
in proceedings of the 29th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse august athens greece.
acm new york ny usa pages.
introduction software patches change a system to address security flaws fix an algorithm s implementation add features boost code maintenance etc.
beyond these immediate effects patches are a useful source of information for software researchers and developers.
they are particularly helpful in understanding the causes of past problems and providing insights for solving new ones.
for instance patches have been used to identify root causes of bugs to infer patterns of past bugs including for specific types such as security permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse august athens greece association for computing machinery.
acm isbn .
.
.
.
and to make recommendations to developers about what to change next during a coding session .
patches are an important source of information but may contain noise .
noise refers to changes that are nonessential or trivial in the context of the issue being addressed by a patch .
the relevant problem or feature may thus be obfuscated in noise containing patches.
noise in patches has been studied previously.
past work has attempted to identify low significance changes .
diffcat implemented an initial approach to classify and automatically detect several types of changes that are merely noise referred to as nonessential changes .
nonessential changes include renaming of variables methods or classes or trivial changes such as adding a this keyword in programs written in java.
changes like these may lead to wasted effort when manually analyzing patches.
they have also been shown to lead to less accurate learning models in systems that use patches for further analysis .
despite the availability of diffcat for nearly a decade noise and imprecision persist in patches and researchers still identify the presence of noise as a notable concern e.g.
.
this has led us to hypothesize that there are likely additional types of changes that introduce noise in patches beyond those handled by prior work .
an added motivation was a recent empirical study in which we observed frequent presence of noise in the security patches of tomcat an open source web server implementation.
to look deeper into our hypothesis we conducted an initial semiautomated analysis of the tomcat dataset from .
this analysis uncovered that a substantial number of patches contain previously unreported noise that we have termed nonessential casualty changes .
casualty changes do not themselves alter the logic of a program however they form part of the patch to accommodate other changes which in turn can refactor the program or modify its logic.
to illustrate the concept of casualty change consider the example in figure from a tomcat patch that addressed the cve security vulnerability.
note that in this paper we make use figure partial listing of files changed in the patch that addressed vulnerability cve in tomcat .
esec fse august athens greece adriana sejfia yixue zhao and nenad medvidovi a c h u n k e d i n p u t f i l t e r i n t maxtsize i n t maxesize .
.
.
intmaxs size c c h u n k e d i n p u t f i l t e r i n t maxtsize i n t maxesize intmaxs size this.maxssize maxs size i n i t f i l t e r s i n t maxtsize i n t maxesize b new c h u n k e d i n p u t f i l t e r maxtsize maxesize i n i t f i l t e r s i n t maxtsize i n t maxesize intmaxs size d new c h u n k e d i n p u t f i l t e r maxtsize maxesize maxs size figure fix of vulnerability cve in tomcat with partial pre patch a b and post patch c d revisions shown.
of the national vulnerability database nvd and its identifier for vulnerabilities cve .
the fix from figure spans java files.
however a deeper look reveals that the functionality of only one method was changed shown in figure .
the highlighted portions on the right side of figure refer to code that was added while irrelevant code has been elided.
specifically the change shown in line of figure 2c introduced a global variable maxswallowsize which is set in the constructor chunkedinputfilter lines and and subsequently used in the class not shown .
this change cascaded to the remaining ten files encompassing the patch.
we see an example in figure 2d the only updates made were to accommodate the changed signature of chunkedinputfilter s constructor.
a developer or tool analyzing the changes to the program s logic made by this patch would have to go through all files only to ultimately disregard most of the changes as nonessential or trivial.
our observation of a number of such casualty changes in tomcat motivated us to analyze five additional systems zookeeper ofbiz commons collections commons compress and commons email .
in our analysis we inspected patched methods of which contained only casualty changes.
this directly motivated us to study these changes in a more systematic way.
in particular previous work in this area has two notable gaps that we needed to address.
first while the types of noise targeted by past work at times intersected with the ones we encountered in the majority of cases the casualty changes we uncovered were not reported previously.
second prior work focused on grouping related changes in a patch e.g.
the changed constructor and the corresponding changed callsite in figure to help code reviewers with understanding a patch better but did not classify noise.
we set to fill these gaps by approaching the problem from two directions.
first we uncovered several flavors of casualty changes each with its own characteristics.
this new knowledge needed to be defined organized and put into perspective when compared to the previously known types of noise.
second we needed to develop mechanisms for automatically identifying casualty changes in patches.
our analysis indicated that the pervasiveness and at times subtle presentation of casualty changes renders their manual identification cumbersome time consuming and error prone.
the paper makes the following contributions the first taxonomy of casualty changes in software patches identified and organized for a broad range of systems with an initial focus on statically typed oo languages cascade casualty change automatic detector an approach and accompanying tool that automatically identifies casualty changes with high accuracy a manually curated dataset of security patches in which casualty changes are identified and labelled.
this set includes patches spanning six open source systems and an empirical analysis of datasets and tools used in two extensively referenced prior studies to confirm the presence and analyze the impact of casualty changes.
section summarizes prior work and our preliminary analysis of noise in open source systems.
section details our taxonomy of casualty changes.
section describes cascade our approach for detecting casualty changes.
section presents our evaluation results section the limitations of our work and section our conclusions.
background this section overviews prior work in identifying noise in software patches.
we then describe our analysis of six open source systems conducted to better understand this phenomenon.
this analysis directly motivated our taxonomy and development of cascade .
.
related work a sizable body of prior work has studied ways of improving the quality of software patches.
in some cases authors have sought to weed out noise .
in others their goal has been to better organize groups of changes to aid code reviewers .
yet others have considered the quality of patches from a broader perspective analyzing past patches and the numbers of issues that are addressed in each .
specific types of patches and their quality have also been studied .
lastly prior research has provided suggestions on how to write better patches .
our goal of detecting noise in patches is most closely aligned with diffcat .
the definition of noise in diffcat partly overlaps with our definition of casualty change.
for instance certain changes that stem from variable updates can potentially lead to casualty changes.
one such case is an update to a variable s name a scenario handled by diffcat .
however diffcat also targets a set of more trivial changes such as adding a this keyword in java programs replacing the simple name of a type with its fully qualified name e.g.
from list tojava.util.list or updating comments.
these types of noise do not stem from other changes and are thus different from casualty changes.
as such they are outside our scope.
on the flip side most casualty changes stem from system updates other than variable or method renamings and are not considered by diffcat.
fluri and gall detail a taxonomy of low significance changes .
this taxonomy does not deal with changes that cascade from others but rather stand alone changes and their impact in the code.
it thus has a different scope and complements our taxonomy.
our approach is also similar to the work of barnett et al.
.
however their end goal is different they aim to group changes via program analysis so that code reviewers can consider each change in a patch and decide whether to approve it.
we also use program analysis for the auxiliary purpose of exposing dependencies between different changes in a patch but our goal is to isolate noise.
305identifying casualty changes in software patches esec fse august athens greece grouping of related changes in patches and their improved presentation has also been the focus of the research work by huang et al.
.
they predefine five scenarios referred to as links which designate changes that should be grouped.
those scenarios are similar in nature to our casualty changes.
however our work presents a more extensive taxonomy and corresponding detection approach that essentially extends the five links.
patches and their quality have garnered the interest of researchers because numerous tools and techniques rely on patches.
they have been used for bug finding understanding and for recommender systems .
additionally patches have been employed as a learning basis for automated program repair techniques .
a number of these publications cite the quality of patches as a concern.
several have restricted to at most two line patches in their datasets in part due to the cost associated with the noise in patches .
we anticipate that our approach will help this line of work.
to illustrate that we use publicly available datasets from two of the previous studies and investigate the presence of casualty changes therein and their impact.
.
preliminary analysis to obtain a better understanding of noise in patches we conducted a preliminary analysis of several open source systems.
our initial analysis focused on noise present in security patches recall section .
we subsequently verified our findings with other types of patches as discussed in other sections.
we extended the original tomcat based dataset with data from five additional systems commons compress commons email commons collections zookeeper and ofbiz .
as with tomcat we selected these systems because their vulnerability data is publicly available and use nvd s nomenclature to specify the patches that fixed vulnerabilities cves .
we implemented crawlers to collect the necessary information from the six subject systems the ids of the cves the patches that fixed each cve and the relevant files involved in each patch.
we then had to manually analyze the changes in patches to determine whether they are noise and if so what kind of noise.
this manual analysis was conducted by one of this paper s authors who has extensive familiarity with the nvd spanning multiple large projects.
the six subject systems yielded a total of security patches which contained a total of changed methods.
for each of the methods we manually explored the rationale behind the change and labeled any instances of noise we found.
this step uncovered noise in a number of patches that was different from that reported by prior work.
these were changes that developers had to make as casualties of the changes actually required to patch a problem.
our analysis uncovered different types of casualty changes.
we formally define these changes in section .
each identified method was explored at least twice to ensure consistency in labeling.
we have made the labeled dataset publicly available to facilitate independent confirmation of our results and subsequent studies in this area.
our manual analysis uncovered that out of the patches contained casualty changes.
moreover of the methods that were updated added or deleted included only casualty changes i.e.
the changes in these methods consist entirely of noise.
taxonomy of casualty changes figure taxonomy of casualty changes.
elements handled by prior work or not found in our dataset are greyed out.as introduced above nonessentialcasualty changes are defined as changes that happen as a result of and to accommodate other changes but that themselves do not alter the logic of a program.
our analysis of the six open source systems uncovered a range of casualty changes.
we have organized these changes augmenting them with their possible although not always observed in our subject systems variations.
the transition from the individual examples observed in the subject systems to the taxonomy occurred iteratively.
we first collaboratively analyzed the collected examples.
in each instance one of the authors would propose a taxonomy category and possibly its further breakdown.
this initiated a discussion and as needed refinement of each category which was terminated only after all authors reached a consensus.
in the final stage we analyzed the taxonomy for completeness.
in this stage we added further categories inspired by related literature and our experience even if we had not observed the corresponding examples in our dataset.
this yielded the taxonomy presented in figure .
we believe that while not necessarily complete the taxonomy is reasonably comprehensive and will be useful both conceptually and in practice conceptually the types and nature of casualty changes differ across categories and so does the rationale behind classifying them as such in practice these differences influence the ways in which casualty changes can be automatically identified and thus impact an approach such as ours.
although it is inspired by findings from a dataset of statically typed oo systems our taxonomy is applicable for more broadly systems written in procedural languages.
next we first explain several concepts related to casualty changes and then use such concepts to detail our taxonomy.
.
concepts underlying casualty changes apre patch revision is the revision of a software system immediately before a given patch is applied.
conversely a post patch revision is the revision immediately after a patch is applied.
acode element is a program portion changed in a patch.
code elements can be expressions statements methods classes or packages.
306esec fse august athens greece adriana sejfia yixue zhao and nenad medvidovi we classify code elements as simple expressions statements and composite methods classes packages elements.
composite code elements contain simple elements and possibly other composite elements e.g.
a class contains both statements and methods .
achange is the application of a single change type move update delete or insert to a code element.
we associate each change with the finest grained code element involved in that change.
for example this means that a change of type update is never associated with methods classes or packages since one can always isolate a finer grained simple code element that was updated within them.
this decision is not arbitrary identifying the simple code elements helps one pinpoint the location of a change while allowing coarser grained changes to be represented at the level of a composite element if needed.
a change set is a set of changes that happen to one or more simple code elements within a composite element.
these concepts allow us to elaborate on the above definition of casualty change it is a logic preserving change of a simple code element within a program necessitated by another change made elsewhere in the program.
each casualty change is by definition contained inside a single method which we term the casualty method .
the original change to a program that causes casualty changes is the root change .
in cases when this change is contained within a method as opposed to e.g.
a change to a class variable we refer to such a method as the root method .
specifically a casualty change is introduced in the code when the changed code element has a control data or call dependency with the code element of the root change.
a casualty change can occur in three different ways to accommodate the root change directly as a result of a call to a casualty method whose api changed which renders the calling method a casualty too or by cascading through another casualty change within a single casualty method.
in the third case the code element of the cascaded casualty change has a forward control or data dependency with the code element of the initial casualty change.
we thus refer to the cascaded change as a casualty dependent .
casualty changes additionally differ based on the type of root changes from which they stem.
as reflected in figure root changes can be behavior altering orbehavior preserving .
a behavior altering root change is one that modifies the program s logic in order to patch a problem.
we have identified two types of such root changes changes in apis and in variables.
by contrast behavior preserving root changes are introduced to improve the structure readability and or maintainability of a program.
these can be code refactorings or changes that rename code elements.
we further categorize each casualty change based as appropriate on its embodiment dimension of variable based in figure proximity to the root change dimension of api based andvariable based scope of analysis dimension of api based andvariable based or purpose of the underlying activity in the root change dimensions of refactoring based .
we elaborate on three of the principal casualty change types next api variable and refactoring based.
as discussed above renaming changes are more straightforward and have been handled by prior work .
we thus do not focus on them in this paper.
.
api based casualty changes casualty changes in this category occur when at least one parameter is inserted or deleted or one or more of the existing parameters figure partial fix of cve showing an apibased casualty change.
types are updated in a method s signature.
the involved method is the root method with respect to the change.
a change to root method s api mandates changes all of its callsites by adding removing or updating the arguments that correspond to the parameter s in the root change.
we categorize such callsite changes as api based casualty changes.
moreover any casualty dependents occurring when an added removed or updated argument is declared in the casualty method and then passed to the callsite are also categorized as api based casualty changes.
for example consider a portion of the patch that fixed cve2013 in tomcat schematically depicted in figure with the code irrelevant to our discussion elided.
the constructor of the parserutils class changed in the post patch revision.
specifically the api of this constructor was altered by adding a new boolean parameter the root change in this case.
the effect of the root change cascaded to the callsites of the constructor.
one of the callsites is contained in the method processwebdotxml and the change to it is considered an api based casualty change.
in general api based casualty changes can take several different forms figure depending on proximity to the root change and scope of analysis.
we discuss these two dimensions next.
proximity considers the distance of the casualty method from the root method.
in the context of api based changes casualties can follow the root change directly or indirectly.
a direct casualty change is induced by the root change without intervening program elements i.e.
the casualty method in which they are contained calls the root method.
for instance in figure the callsite inprocesswebdotxml was changed because the parserutils constructor invoked there changed its api and is a root method.
an indirect casualty change is one in which the casualty method is separated from the root method by more than one edge in the callgraph.
this happens when the apis of the methods along the path between the casualty and root methods are changed to reflect the root change.
these intermediate methods can be thought of as root proxies.
a method is a root proxy when it contains an api based casualty change that modifies said method s own api.
this happens when the root proxy s api has a data dependency to the code element of another casualty change in the method making the api change a casualty dependent.
with the api change the callsites of the root proxy have to be changed as well those changes are indirect casualty changes with respect to the original i.e.
root change.
for example consider the partial depiction of the tomcat patch that addressed cve in figure .
the root change is the api change of the chunkedinputfilter class s constructor.
that change induced direct casualty changes in the initializefilters 307identifying casualty changes in software patches esec fse august athens greece figure partial fix of cve depicting direct and indirect api based casualty changes.
method the change in the callsite as well as in the method s api.
in this case there is a data dependency between the parameter added in the api of initializefilters and the argument in the initial casualty change the callsite to chunkedinputfilter .
hence the api change is a casualty dependent and is caused by the root change as well.
as explained above the change to initializefilters api renders it a root proxy since its callsites now have to be changed as well.
one such updated callsite is inside http11aprprocessor .
this change is an indirect casualty change the casualty method housing the change http11aprprocessor reaches the root method chunkedinputfilter in the system s callgraph through an intermediate node initializefilters that acts as a root proxy.
observe that http11aprprocessor s api was also changed.
that change is a casualty dependent with respect to the callsite s casualty change due to a data dependency.
http11aprprocessor is therefore also a root proxy and its own callsites will experience further indirect casualty changes.
the casualty methods including those callsites will be separated from the root method by two nodes in the callgraph http11aprprocessor andinitializefilter .
the prospect of indirect casualty changes with an arbitrary number of intermediate nodes induces complexity in an approach aiming to identify api based casualties of a given root change.
scope refers to the portion of a program that needs to be analyzed to identify a root change and can be singular or compound.
the singular case was illustrated above a method s api is changed via parameter addition deletion or update.
to detect the api change it is sufficient to check just that one root method and to employ call data flow and or control flow analyses to identify the root s casualties.
the examples in figures and represent singular api based casualty changes each root change involved adding a parameter and each casualty method altered its callsite with a corresponding added argument.
the cases in which parameters are deleted or updated in the root method analogously involve the deletion or update of corresponding arguments.
by contrast in the compound case the root change involves multiple methods.
such cases occur when an api is changed through overloading a method within a class or overriding a method in classes related through inheritance.
this can happen when an overloading or overriding method is inserted or when such methods are deleted.
in the former case a patch results in two or more methods figure partial fix of cve an example of a compound api based casualty change.
that share names but differ in arity parameter types or implementations.
in the latter case at least one method in the patch has the same name as the deleted method s but different parameters or implementations.
finding the root change in the compound case requires identifying all overloaded methods within a class or overriden methods across classes in the inheritance hierarchy and then analyzing their callsites for the presence of casualty changes.
to illustrate compound casualty changes consider a partial tomcat fix of cve in figure .
as part of the fix the constructor for customobjin method name abbreviated for space was overloaded.
the class has retained the original constructor but now has a second constructor with three additional parameters.
the method doload which initially called customobjin s original constructor calls the overloaded one in the post patch revision.
we consider each such new constructor aroot method of the api based change.
if a patch involves overloading or overriding a constructor with more than one method all of the added methods would together comprise thecompound root of the api based change.
uncovering the casualty changes in such cases requires locating and distinguishing the unchanged callsites of the original constructors from the casualty callsites of the new constructors.
conversely if an overloading or overriding method is deleted the remaining method s comprise the root method.
uncovering casualty changes then requires distinguishing the cases where a callsite is deleted from those in which it is updated to a remaining method.
.
variable based casualty changes this category deals with changes to local variables of a method or member variables of a class.
casualty changes can occur both when existing variables are modified i.e.
deleted or updated and when new variables are added.
when an existing variable is modified in a patch all code locations in which it is referenced need to be modified as well the former change is the root change while the latter ones are potential casualty changes.
when the root change is an added variable that change is usually accompanied by new code that implements some needed functionality referencing the variable parts of this new code may constitute a casualty change.
previous work addressed several scenarios involving variables local to a method.
with a couple of exceptions we will thus focus our discussion on more extensive changes stemming from member variables of a class the exceptions will zero in on local variable based changes omitted from .
our taxonomy includes 308esec fse august athens greece adriana sejfia yixue zhao and nenad medvidovi figure partial fix of cve showing direct and indirect variable based casualty changes.
additions deletions and updates of variables including their types variable assignment and retrieval methods setters and getters respectively as well as changes to container data structures and or methods that manipulate such structures.
as an illustration of variable based casualty changes consider the patch that fixed cve in tomcat partially depicted in the top portion of figure .
as part of this fix in the class named bytechunk a member variable named encof type string was updated to java s type charset and renamed to charset .
the variable s setter method also had to be updated its name was changed from setencoding tosetcharset the lone parameter was changed in its api and assignment to the member variable was updated in its body.
these updates represent a variable based casualty change set.
as shown in figure we categorize variable based casualty changes along three dimensions embodiment proximity and scope.
we elaborate on them next.
embodiment is concerned with the manner in which variablebased casualty changes are manifested.
in the case of individual methods changes to a variable may result in casualty changes in the variable s local