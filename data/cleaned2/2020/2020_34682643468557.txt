checkingltl oncompressed traces in polynomialtime minjian zhang minjian2 illinois.edu universityof illinoisat urbana champaign urbana illinois usaumang mathur umathur3 illinois.edu universityof illinoisat urbana champaign urbana illinois usamahesh viswanathan vmahesh illinois.edu universityof illinoisat urbana champaign urbana illinois usa abstract the problem of checking if a program execution meets a formal specification arises in many software engineering tasks includingruntimeverificationanddesigningtestoracles.whenonline analysisisnotpossible executiontracelogsarestoredforoffline postmortem analysis oftenin a compressed formatto reduce disk spaceandwarehousingrequirements.astraightforwardmethod for checking if a compressed execution satisfies a property is to first decompress it and then analyze the resulting uncompressed execution.
inthispaper weconsidertheproblemofcheckingifanexecution trace compressed using a grammar based lossless compression scheme satisfies a specification expressed in linear temporal logic without explicitly decompressing it.
in general this problem is knowntobeintractable pspace hardinthesizeofthecompressed traceandthe ltlformula .weshowthattheproblemcanbesolved inpolynomial time for the fragment ltl which comprises ofallbooleanandmodaloperatorsof ltlexceptthe untiloperator.
our algorithm for analyzing slps a grammar based compression scheme is effective in practice for a suite of large execution traces obtained from open source projects our algorithm shows significant speed ups when compared with the performance of checking ltlpropertiesovercorrespondinguncompressedtraces.
ccs concepts softwareanditsengineering softwaretestinganddebugging.
keywords lineartemporal logic compression runtimeverification acmreference format minjian zhang umang mathur and mahesh viswanathan.
.
checking ltl oncompressedtracesinpolynomialtime.in proceedingsofthe 29th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse august 23 28 athens greece.
acm newyork ny usa 13pages.
.
.
permissionto make digitalor hard copies of allorpart ofthis work for personalor classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acm mustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
esec fse august 23 28 athens greece associationfor computing machinery.
acm isbn ... .
introduction consider the membership problem that can be abstractly defined as follows given a program execution determine if is a good behavior.thiscomputationalproblemplaysakeyroleinseveral approaches whose goal is the engineering of reliable and secure software.
the first sub area where it arises is runtime verification where one dynamically monitors the behavior of a systemwithtodetermineiftheitconformstosystemrequirements.
this approach can be used to augment testing by observing system behavior along paths that were inadequately exercised during testing therebyresulting inincreasedcodecoverage.
the keycomputationaltaskinruntimeverificationistosolvethe membership problem check whether the monitored execution needs satisfies asystemrequirement.asecondsub areaofinterestisthedesign test oracles .
given executions of a system exercised by a test suite a test oracle is a program that distinguishes between correct and incorrectbehaviors of the system.thus a test oraclecan be seen as solving the membership problem for the specific system being tested.
the membership problem also plays a key role in intrusion detection .
log files that record the interaction between a network of elements need to be examined to detect patterns of intrusive behavior so that corrective measures can be takentoavoidsecuritycompromises.sincetheselogfilesarelarge and there are multiple patterns of intrusive behavior intrusion is typically detected automatically by a program that solves the membershipproblemtodetermineifthelogfilesdonotcontainan intrusivepattern.finally themembershipproblemalsoneedstobe solvedwhen statisticallymodelchecking asystem.statisticalmodel checking is an approach to verify quantitative properties of stochasticsystems.inthisapproach themodelcheckerexecutes the stochastic system a few times to draw a statistical sample of systembehaviors andthenusehypothesistestingtodeterminethe likelihoodofapropertybeingtrueofasystem.acrucialstepinthis process is building an oracle that determines for each execution whether itsatisfiesadesiredlogical property.
onepracticalchallengeineachoftheseapplicationareasthat rely on solving the membership problem is the size of the program executionthatneedstobeanalyzed.programtracesthatarisein runtime verification testing or statistical model checking are often huge containingmillionsofevents.longtracesareoftennecessary toexerciselargepartsofthecodebasetoensuregoodcodecoverage.
log files analyzed for intrusions often record interactions that take placeoverlongwindowsoftime sometimesovermultipledays.the challenge therefore is two fold how to store such long traces logs and how to effectively analyze them.
the common solution to addressthewarehousingneedsforsuchtracesistocompressthem andthen store theminacompressedformat.
esec fse august athens greece minjianzhang umangmathur andmahesh viswanathan given that program executions need to be compressed to address storage costs an important question in the context of the membership problem is to find effective solutions to the problem when the input trace is compressed.
this question is not new andhasarichhistory especiallyintheoreticalcomputerscience .theshortsummaryofresultsinthis space isasfollows.there is alwaysana vealgorithmtosolve the membershipproblemoncompressedtraces uncompressthetrace and check membership.
in many situations this is often provably the best algorithm possible .
however there are exceptions where the membership problem can be solved in time that ispolynomialinthesizeofthe compressedtrace onenotable example isdynamicracedetection oncompressedstrings .
the main question we investigate in this paper is the following given a program trace in compressed form and a formula in lineartemporallogic ltl determineif satisfies .ltlis widely used in testing and verification.
it s popularity relies on the factthat ontheonehanditisrichenoughtoexpressmanyrequirementsthattypicallyariseinsoftwareengineering andontheother hand theabsenceofexplicitquantification makesitsimpleenough for a practitioner to easily write properties.
compression schemes we consider are those where aprogram trace is representedusing astraight line program slp .
slps are special context free grammars where the language of the grammar contains exactly one string namely the trace it represents.
several lossless compression schemes.
like run length encoding and lempel ziv encodes canbeefficientlyconvertedintoslpswithsimilarsize.thereare efficient implementations of compression algorithms that produce anslprepresentationofagivenexecution .
theproblemofdeterminingifafinitetracecompressedusingan slpsatisfiesanltlproperty hasbeenstudiedbefore.theproblem isknowntobeintractable itis pspace hard .therefore we ask if there is a rich fragment of ltl for which the problem can be efficiently solved.
we consider the fragment ltl which is thecollectionofallltlformulasthatarebuiltfrompropositions using boolean operators and only the temporal operators x next f eventuallyorfinally and g alwaysorglobally inparticular u until cannotbeusedintheformulasof ltl .thefragment ltl isexpressivelyveryrich.overinfinitetraces ltl f g x can express properties in each class of the safety progress classification of temporal properties introduced by manna and pnueli .ourmainresultisthattheproblemofcheckingifa finite trace represented by an slp satisfies an ltl formula can be decided in time that is polynomial in the size of the slp compressedtrace andthe formula.
we now outline the technical challenges and our theoretical contributions in obtaining this result.
the principal idea used in verification runtime verification and automatic test oracle generationfortemporalpropertiesistoexploittheconnectionbetween ltl formulas and automata translate the formula into an automata andthen run theautomatonwiththeprogramortrace to verify or test.
for runtime verification or test oracles the automaton constructed from the formula needs to be deterministic .
thisideacanalsobeusedwhencheckingcompressedtraceswhere 1orin everyborel class that has regularproperties.you effectively run the deterministic automaton on the grammar representing the trace.
however even for ltl formulas2 the smallest nondeterministicautomatonisexponentialandthesmallestdeterministic automaton is doubly exponential in the size of the formula .
theoreticallowerboundsestablishthatthiscannotbeimproved.
our first observation is that if the finite uncompressed trace is processed right to left insteadofleft to right thenthereisan exponentialsized deterministic automatonforeachltl formula that can solve the membership question.
running an automaton left to right or right to left on an slp is very similar and so this change does not fundamentally change the algorithm for compressedtraces.however thefactthattheautomatonisexponential sizedwouldaffectthecomplexity forcompressedtraces therunning time of an algorithm using this automaton would be exponential in the formula.
to combat this we observe that the automaton wedesignforltl hasspecial monotonicity properties and has a small diameter .
these two observations can be combined to observe that there are essentially o m state changes mhere refers to the size of the ltl formula when the automatonisrunon any uncompressed trace nomatterwhatthe lengthofthetraceis.finally weexploitthespecialstructureofthe states of this automaton to design an algorithm for compressed traces.
to prove that this algorithm indeed runs in time that is polynomialinthe formulasize andthe grammar requires carefully countingthenumberofsubstringsthatariseinastringrepresented byan slp.
weevaluatetheperformanceofouralgorithmforcheckingcompressedtracesoveropensourcejavaprojectsobtainedfromgithub largelyderivedfrompriorstudy .wealsouse10 ltl properties describing specifications for the use of iterators collections file objects etc.
our evaluation suggests that large traces fromopensourceprojectscanbeeffectivelycompressed withan averagecompressionratioofmorethan600 andthatcompressed traces can be effectively checked against these specifications leadingto significant speedups averagingat34 .
the rest of the paper is organized as follows.
section 2discussesbackgroundrelevantfortheexposition.section 3presents anoverviewofouralgorithmforchecking ltl formulae on compressed traces and sections 4and5discuss the technical details of the algorithm.
we present our evaluation in section relatedwork insection 7andconcluding remarks insection .
preliminaries inthissectionwepresentpreliminarynotationsaboutexecution traces ltlmonitoringandthe slp compressionformat.
.
execution traces in many approaches whose goal is to either prove the correctness of a software or find errors a key computational problem that needs to be solved is the membership problem where one needs to determine if a given program execution is correct with respect to a systemspecification.inthissetting anexecutiontrace orsimplyan execution canbeabstractlymodeledasafinitesequenceof events belongingtoaset say .thesetofevents isdeterminedbywhat 2theseareltlformulasthatonlyhave fandg andnoxoru astemporaloperators.
132checkingltl oncompressedtracesin polynomialtime esec fse august athens greece classsettraversal hashset integer s newhashset integer publicvoidinsert intmax for inti i max i s.add i publicintsumallexcept intval iterator integer itr s.iterator intsum if !itr.hasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnext returnsum while true inti itr.nextnextnextnextnextnextnextnextnextnextnextnextnextnextnextnextnext if i val continue sum sum i if !itr.hasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnext break returnsum classsettraversaltest test voidtestinsertandsum settraversal st newsettraversal st.insert intactual st.sumallexcept intexpected assertequals expected actual figure java class settraversal with methods insertand sumallexcept .
the unit test testinsertandsum tests these twomethodsat once.
isvisibleorhasbeenmadevisiblethroughinstrumentationwhen the program is executed.
thus an execution is e0e1 ek where each ei theempty trace sequence will be denoted by .
let us fix an execution e0e1 ek .
theith event in the executionwillbedenotedby ei.wewilldenotethesubstring eiei ej 1by thesuffix eiei ek 1by and theprefix e0 ei 1by .
thelengthof execution denoted isthe number ofeventsinitwhichis k.by definition .
example1.
considerthejavaclass settraversal infigure .every instance of this class has a member variable s which is a set of integerelements.themethod insertinsertsallnon negativeintegerslessthan maxins whilethemethod sumallexcept returnsthe sum of those elementsofthe set swhich are different fromtheintegerval.weremarkthattheimplementationof sumallexcept is functionallycorrectwhenever valisnotthelastvaluewhentraversingsusingtheiterator itr.ifvalisthelastvaluein swhentraversingusing itr theloopbody canexecute nextnextnextnextnextnextnextnextnextnextnextnextnextnextnextnextnext aftertraversing the node with itr even though there are no remaining elements whichmayraiseajava exception nosuchelementexception .
the figure also shows a test class settraversaltest that implementsaunittest testinsertandsum thatfirstcalls inserton aninstance stofsettraversal withtheargument128andthen checks if the sum of elements thus inserted except the element is as expected.
the given unit test passes and in fact does not expose the bug outlined above.
the execution trace generated due tothistest canneverthelessbeusedtoinferthepossibilityofan exception.
if we instrument calls to the methods hasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnext and nextnextnextnextnextnextnextnextnextnextnextnextnextnextnextnextnext thenwewillobserveatraceoverthealphabet hhhhhhhhhhhhhhhhh nnnnnnnnnnnnnnnnn wherehhhhhhhhhhhhhhhhhrepresents a call to hasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnext andnnnnnnnnnnnnnnnnnrepresents a call to nextnextnextnextnextnextnextnextnextnextnextnextnextnextnextnextnext .fortheunittest testinsertandsum wewillobservethe execution trace hhhhhhhhhhhhhhhhhnnnnnnnnnnnnnnnnn 65nnnnnnnnnnnnnnnnn hhhhhhhhhhhhhhhhhnnnnnnnnnnnnnnnnn 62hhhhhhhhhhhhhhhhh.
this is because in this case the iterator traverses the set sin the order of insertion and for the first elements values through the method insertcorrectly calls hasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnext beforenextnextnextnextnextnextnextnextnextnextnextnextnextnextnextnextnext .
however in the next step it enters the loop and calls nextnextnextnextnextnextnextnextnextnextnextnextnextnextnextnextnextwithout checking hasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnext .
all thesubsequentloopexecutionsgeneratethesequence hhhhhhhhhhhhhhhhhnnnnnnnnnnnnnnnnn 62hhhhhhhhhhhhhhhhh.in subsequent sections we willdiscusshow analyzing infact can hint at the possibility of an exception.
observe that hhhhhhhhhhhhhhhhhnnnnnnnnnnnnnnnnn nnnnnnnnnnnnnnnnn hhhhhhhhhhhhhhhhhnnnnnnnnnnnnnnnnn 62hhhhhhhhhhhhhhhhhand hhhhhhhhhhhhhhhhhnnnnnnnnnnnnnnnnn .
.
lineartemporallogic lineartemporallogic ltl isapopularlogicforspecifyingtemporal properties of systems and is widely used to specify correctness properties.inthissection weintroducethesyntaxandsemantics of ltland some fragments thatare relevant inthis paper.since program executions encountered while testing and runtime verification are assumed to be finite our semantics for ltl will be defined for finite execution traces.
while this is not the classical semanticsforltl itisstandard .wewillalsobeusinga letter semantics for the logic models are sequences of letters as opposedtosequencesofsets ofpropositions andformulasarebuilt using lettersas opposedto propositions.
syntaxof ltl.
letusfixafinitealphabet .then aformula in ltlover isgiven bythe following grammar.
a x f g u here aisa symbolin and arebooleanconnectives and x next f eventually g always and u until aretemporal modal operators.
we will use 1 2as a shorthand for 1 2. semantics of ltl.
the semantics of ltl is given by how an ltl formula evaluates over a finite non empty trace .
we formally describe thisevaluation relation fbelow the subscript f in fstands for evaluation over finitetraces.
fa iff a f iff f 1 2iff f 1and f 2 f 1 2iff f 1or f 2 fx iff and f ff iffthere isan isuch that0 i and f fg ifffor everyisuch that0 i f f 1u 2iffthere isan isuch that0 i and f 2andfor every j such that0 j i f 1 remark.
ltl as presented here only has future time operators.
some presentations include past time operators as well y for yesterday the dual of x o for once the dual of f h for historically the dual of g ands for since the dual of u. over finite traces the following property holds.
let hatwide be the formula obtained by replacing every past time future time operator by the corresponding dual future time past time operator in .
then f ifandonlyif r f hatwide here rdenotesthereverseof .this means that over finite traces ltl with only past time operators is 133esec fse august athens greece minjianzhang umangmathur andmahesh viswanathan equivalent to ltl with only future time operators.
our results though presented only for ltl with future time operators also apply to ltlwithpurelypasttime operators.
example .
consider the program shown in figure 1and the execution producedwhencallstomethods hasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnext andnextnextnextnextnextnextnextnextnextnextnextnextnextnextnextnextnext aretracked.asshowninexample hhhhhhhhhhhhhhhhhnnnnnnnnnnnnnnnnn 65nnnnnnnnnnnnnnnnn hhhhhhhhhhhhhhhhhnnnnnnnnnnnnnnnnn 62hhhhhhhhhhhhhhhhh wherehhhhhhhhhhhhhhhhh represents a call to hasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnext andnnnnnnnnnnnnnnnnnrepresents a call to nextnextnextnextnextnextnextnextnextnextnextnextnextnextnextnextnext .
intuitively in a correct implementation the program should check theexistenceofanextelement i.e.
event hhhhhhhhhhhhhhhhh beforeaccessingthe nextelement i.e.
event nnnnnnnnnnnnnnnnn .theprograminfigure 1doesnotsatisfy this intuitive correctness requirement since an event hhhhhhhhhhhhhhhhhdoes not precedetheevent nnnnnnnnnnnnnnnnnwhenthevalue65isaccessed.wecanformalize our informal intuition by requiring that there are no successive callstonextnextnextnextnextnextnextnextnextnextnextnextnextnextnextnextnext .however thisbyitself isnotenoughbecausethe execution nnnnnnnnnnnnnnnnnhhhhhhhhhhhhhhhhhnnnnnnnnnnnnnnnnndoesnothavesuccessive nnnnnnnnnnnnnnnnnevents butthefirst nnnnnnnnnnnnnnnnnevent is not preceded by hhhhhhhhhhhhhhhhh.
so we must also require that the execution does not begin with nnnnnnnnnnnnnnnnn.
we could write this as nnnnnnnnnnnnnnnnn g nnnnnnnnnnnnnnnnn x nnnnnnnnnnnnnnnnn .onecanseethat doesnotsatisfythisproperty asdesired because nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn hhhhhhhhhhhhhhhhhnnnnnnnnnnnnnnnnn 62hhhhhhhhhhhhhhhhhdoes not satisfy nnnnnnnnnnnnnnnnn xnnnnnnnnnnnnnnnnn.
fragments of ltl.
we will consider a couple of fragments of ltl obtained by restricting the modal operators that appear in formulas.
the first fragment is ltl which consists of formulas builtfromeventsandbooleanoperatorsusingonly xoperator.the next fragment is ltl which uses the modal operators x f andg but does not use u. we skip the formal bnf grammar for thesefragments.
formulasin ltl canbeexpressedinanormalformthat isobtainedbypushing xasfarinaspossible.since x 1 2 x 1 x 2 x 1 2 x 1 x 2 andxf fx wecan pushxinside conjunctions disjunctions and foperators.however overfiniteexecutions xcannotbepushedinside or g operators.
to see this consider the execution hhhhhhhhhhhhhhhhhnnnnnnnnnnnnnnnnn.
observe that satisfies xgnnnnnnnnnnnnnnnnn butnotgxnnnnnnnnnnnnnnnnnas 1andthus fxnnnnnnnnnnnnnnnnn.similarly nnnnnnnnnnnnnnnnnsatisfies xhhhhhhhhhhhhhhhhhbutnotx hhhhhhhhhhhhhhhhh.thenormalformcanbedescribed bythe following bnf grammar.
f x x a g formulas in ltl are one of x formulas g formulas conjunctions disjunctions of ltl formulas or an f operator applied to an ltl formula in the normal form.
x formulasarethosewherethetopleveloperatoris x.axoperator can only be applied to either a g formula or an x formula.
finally g formulas are letters or negations of ltl formulas or havegas the topmost operator.
every ltl formula can beconvertedintothisnormalform withatmostquadraticblowup.
example .
consider the ltl formula x gnnnnnnnnnnnnnnnnn fhhhhhhhhhhhhhhhhh .
thenormalformforthiscanbeobtainedbypushing xasfarinside as possible.
thus xgnnnnnnnnnnnnnnnnn fxhhhhhhhhhhhhhhhhh is the equivalent formula in normal form.
remark.
the fragment ltl is expressively rich.
for example it can express properties in each class of the safety progess classification of temporal properties introduced by manna and pnueli .
among the pattern based specifications introducedin most patterns except precedence chain precedence and scopes can be expressed in ltl .
in fact among the commonly occurring specifications collected and surveyed in approximately80 ofthemcan be expressedinltl .
automataforltlandits fragments.
for ltl properties algorithms for verification runtime verification and test oracle generation all rely on the translation of logic formulas to automata.
for a specification the crucial step therefore is the construction ofanautomatona suchthatanexecution isacceptedbya if and only if satisfies .
the size ofa has big influence on thecomplexityoftheverification testingalgorithm.forruntime verification and test oracle generation the automaton a needs to be deterministic.
because of the critical role translations from ltl toautomata play in algorithms these have beenwell studied.
unfortunately thetranslationfromformulastodeterministicautomatacanresultinatleastadoubleexponentialblowup.itisworth emphasizing that the result below holds whether we interpret ltl over finiteorinfinite executions.
theorem .
alur latorre .there is a family n n nof ltl formulas such that the size of nisnand any deterministic acceptor for nisof size 22n .
.
compressed executions inthispaper wewillpresentalgorithmstosolvethemembership problem when the program execution is compressed.
the compressed execution we consider will be encoded by a straight line program slp which is a special context free grammar whose languagehasexactlyonestring namely theexecutionitrepresents.
severallosslesscompressionschemes likerun lengthencodingand lempel ziv encoding can be efficiently converted into slps of similar size.
several efficient algorithms that compress strings using slpsare known .
straight line programs slp .
recall that a context free grammar is a tuple g t n s r wheretis the set of terminals nis thesetof non terminals s nisthestartingnon terminal andris the set of rulesof the form a wherea nand n t .
astraightlineprogram slp isspecialcontext freegrammar with restrictions that ensure that the language associated with ghas exactly one string.
in particular we require that in an slp each non terminal ahasexactly one rule where aappearson the left and that there is a total ordering on non terminals such that if anon terminal bappearsontheright handsideoftherulefor a thena b. these restrictions ensure that the language associated with each non terminal has exactly one string and we denote this stringas llbracketa rrbracket.
the size of a rule a ris defined to be the size and the size of a grammar g denoted by g is defined to the be sumofthesizesofallrules.thecompressionratioofagrammar g t n s r is defined to be llbrackets rrbracket g i.e.
the ratio between the length ofthe stringthat grepresents andthe size of g. example4.
thegrammarshowninfigure 2isanslpthatencodes the execution hhhhhhhhhhhhhhhhhnnnnnnnnnnnnnnnnn 65nnnnnnnnnnnnnnnnn hhhhhhhhhhhhhhhhhnnnnnnnnnnnnnnnnn 62hhhhhhhhhhhhhhhhhof program in figure 1from example1.thegrammarhasstartsymbol s.therulesaredesigned to ensure that llbracketai rrbracket hhhhhhhhhhhhhhhhhnnnnnnnnnnnnnnnnn i llbracketb rrbracket nnnnnnnnnnnnnnnnn hhhhhhhhhhhhhhhhhnnnnnnnnnnnnnnnnn 62hhhhhhhhhhhhhhhhhandtherefore llbrackets rrbracket .
134checkingltl oncompressedtracesin polynomialtime esec fse august athens greece s a65b b nnnnnnnnnnnnnnnnnc c a62hhhhhhhhhhhhhhhhh a1 hhhhhhhhhhhhhhhhhnnnnnnnnnnnnnnnnn a2 a1a1a4 a2a2 a6 a2a4a8 a4a4a16 a8a8 a24 a8a16a30 a6a24a32 a16a16 a33 a32a1a62 a30a32a65 a32a33 figure2 astraightlineprogramencodingoftheexecution hhhhhhhhhhhhhhhhhnnnnnnnnnnnnnnnnn 65nnnnnnnnnnnnnnnnn hhhhhhhhhhhhhhhhhnnnnnnnnnnnnnnnnn 62hhhhhhhhhhhhhhhhhfromexample .
theslphas15rules.allruleshavesize2.thusthesizeofthe slp is .the compressionratioistherefore256 .
.
every slp can be transformed in linear time into chomsky normalformwherethesizeofeachruleisboundedby2.fromnowon we will assume that all the slp grammars are written in chomsky normal form.
we remark that an slp can be exponentially more succinct than theuncompressedstringitrepresents.forinstance astring hhhhhhhhhhhhhhhhh2n of size 2ncan be represented by a grammar of size o n with rules s hnhn hn hn 1hn ... h2 h1h1andh1 hhhhhhhhhhhhhhhhh.
the problem of checking if an execution represented by an slp gsatisfies an ltl formula has been studied before.
a na ve algorithmforthisprobleminvolves decompressing theslpgand checking if the uncompressed executionsatisfies .however this canbeexpensive because of thepossibleexponentialsuccinctness oftheslp asoutlinedinthepreviousparagraph.isthereabetter algorithm that doesn tinvolve uncompressing?
automata for checking slps against ltl.
one possible approach thatworkswithout decompressing the slp leverages the automata theoretic connections of ltl.
given an ltlformula we can first construct a deterministic finite automaton a q q0 f as outlined in section .
.
for every non terminal a intheslpgrammar gandforeverystate q q wecantheninductively compute the state q llbracketa rrbracket reached after running the string generatedby astartingfromthestate q.inthebasecase therule correspondingto aisa a a and q llbracketa rrbracket q a .inthe inductive case of a bc we have q llbrackets rrbracket q llbracketb rrbracket llbracketc rrbracket .
finally checking if llbracketa rrbracket f amounts to checking q0 llbrackets rrbracket f. this approach would work in time o g a d wheredis the time takento computethe transition function on an input symbol and state.
note that d in general is at least log a because the bitsencodingthestatehavetobereadandtheencodingofthenext state needs to be produced.
based on theorem .
this is double exponential in and thus intractable.
indeed the following theoreticallowerboundestablishesthat there isno algorithmthat has atractableasymptoticcomplexityfor the caseoffull ltl.
theorem2.
markeyand schnoebelen .givenanslp g t n s r andanltlformula theproblemofcheckingif llbrackets rrbracket f ispspace hard.
the main result of this paper shows that this problem can be solved efficiently in polynomial time when the formula is from the ltlfragment ltl .
technical overview recall fromsection .
thatthereisasimpleautomata theoreticalgorithmforcheckingifacompressedtrace slp g satisfiesagivenltl formula i.e.
llbracketg rrbracket f .
this simple algorithm constructs a dfaa corresponding to the given ltl formula in time o a andthen inductivelycomputes for everynon terminal aofgand for every state qofa the next state q q llbracketa rrbracket obtainedafterrunningthetracefragment llbracketa rrbracketona .aswepreviouslyobservedthetotalrunningtimeofthissimplealgorithmis o a g a d wheredisthetimetocomputethetransition function which based on the size of the smallest deterministic automaton is o g .thealgorithmweproposeforformulas inltl works on the same automata theoretic paradigm butwithmodificationsthatleadtoapolynomialrunningtime.in thissectionweoutlinesomeoftheideasthathelpusachievethis polynomialtime.
backwardsautomaton.
the first observation that our algorithm relies on is that for the fragment ltl there is a deterministicautomatonthatworksbackwardsandonlysuffersanexponential blow up instead of double exponential in the forward automaton .
that is for the input formula ltl we construct an automaton ar such that for any trace f iff ris accepted byar for an execution e0e1 ek 1its reverseis r ek 1ek e0.
the algorithm for analyzing the slpgwiththisautomatonisalsostraightforward andproceeds as if the grammar gis reversed every rule of the form a bc becomesa cb .
but this by itself is not enough if we are using theexhaustiveparadigm compute q llbracketa rrbracket forallqanda because ar o .
thankfully the backwards automaton ar enjoys a special structure that we exploit in conjunction with the next observation to getour efficient algorithm.
bounding running time with visited states.
we next observe that insteadof computing q llbracketa rrbracket for allpairs of state qand nonterminalaintheautomata theoreticalgorithm wecanaffordto onlycompute q forstatesthatareactually visited insteadof all states .
consider the production rule s uv wheresis the startingnon terminaloftheinputslpgrammar g.ourfinalgoal istocomputethestate q q0 llbrackets rrbracket .weremarkthatthiscanbe computedasthecomposition q q llbracketv rrbracket whereq q0 llbracketu rrbracket .
ifthisistheonlyrulethat voccursin weonlyneedtocompute q llbracketv rrbracket insteadofcomputing p llbracketv rrbracket foreverystate p .notice that this intermediate state q would also be visited when running aontheuncompressedtrace llbrackets rrbracket thisispreciselythestatereached after running the prefix llbracketu rrbracketof llbrackets rrbracket.
in fact this observation can be generalized so that we only compute q a for those states qthat are ever visited when analyzing the uncompressed trace.
we formalize this as follows.
for a trace and an automaton a with initial state q0 letv a q0 i be the states ofathat are visited when running ona.
then we can compute q0 s by only computing q a for every nonterminalaandstateq v a llbracketg rrbracket .this givesusanupperbound ofo g v a llbracketg rrbracket d an improvement over o g a d ddenotesthe time to evaluate the transitionfunction .
boundingnumber ofstates visited.
our third important observation is that any run of automaton ar for ltl satisfies a monotonicity property.
this property allows us to bound the number of states visited v a llbracketg rrbracket on any input to k independent of g .
here kis what we call the nesting 135esec fse august athens greece minjianzhang umangmathur andmahesh viswanathan depthofxin aprecisedefinitionwillbepresentedinsection .
this combined with some other observations gives us a running time ofo g k .
furtherimprovements.
ouralgorithmforanalyzingcompressed executionsrunsinstrictlypolynomialtime andthusdoesnothave theexponentialdependenceduetothefactor k .weachievethis byperforminganinvolvedfinegrainedanalysisoftherunningtime of the algorithm.
further we also make use of the monotonicity property outlined inthe previous paragraph to optimizethe space usage ofthe algorithm.
insection wedescribetheautomatonconstruction andthe otherobservationsaboutmonotonicityandthenumberofvisited states in greater detail.
we finally present the algorithm for analyzingcompressedexecutionsandimprovementsthereofinsection .
automaton forltl inthissection wepresenttheconstructionofa backwards deterministicautomaton ar suchthatar acceptsatrace rifandonly if f recall that ris the reverse of execution .
the main advantageofthisconstructionisthatthesizeof ar isonlyexponential in as opposed to doubly exponential .
in addition ar hasaspecialstructurethatensuresthatthenumberofstatesvisited byar onany input rispolynomialin .
before presenting the construction we will introduce some conventionsandnotationsthatwewilluseintherestofthispaper.first as outlined in section we can assume that ltl formulas areinnormalformgivenbyequation i.e.
xoperatorshavebeen pushed asfarinside aspossible.
for any formula ltl we will use sub to denote the set of sub formulas of .
when defining our automata we will consider a special subset of subformulas called fgx subformulae denoted by subfgx .
these aresub formulas of whosetopmostoperatoriseither f g or x and if the top operator of isx then has a sub formulawith topmost operator g.we formally definethis setnext.
definition1 fgx sub formulas .foraformula ltl subfgx isthesetofsub formulasdefinedinductivelyasfollows.
subfgx a subfgx subfgx subfgx 1 2 subfgx 1 subfgx 2 subfgx m m subfgx m f g subfgx x subfgx ltl subfgx x x subfgx nelementltl letuslook at examplesto illustrate thesedefinitions.
example .
consider the formula nnnnnnnnnnnnnnnnn g nnnnnnnnnnnnnnnnn xnnnnnnnnnnnnnnnnn from example2.thesetofitssub formulasis sub nnnnnnnnnnnnnnnnn nnnnnnnnnnnnnnnnn g parenleftbig nnnnnnnnnnnnnnnnn xnnnnnnnnnnnnnnnnn parenrightbig nnnnnnnnnnnnnnnnn xnnnnnnnnnnnnnnnnn xnnnnnnnnnnnnnnnnn xnnnnnnnnnnnnnnnnn .similarly subfgx g nnnnnnnnnnnnnnnnn xnnnnnnnnnnnnnnnnn .
notice that xnnnnnnnnnnnnnnnnn nelementsubfgx even though its topmost operator is x as itdoes not have a g sub formula inits scope.
asisstandardinautomataconstructionsforltl ourautomaton ar for willtrackthetruthofsub formulasof asitprocesses the input.
instead of tracking the truth of allsub formulas our automatonwillonly track thetruth of sub formulasin subfgx .
sincesubfgx issmallerthan sub asillustratedbyexample this results in smaller automata and better performance in practice.
but this is not our only reason for tracking fewer sub formulas.
as we will show towards the end of this section tracking the truth offewersub formulasrevealsthateveryrunoftheautomatonis monotonic whichcanthenbeexploitedtoarguethatthenumber ofstates visitedinthe run of ar onany stringissmall.
letusfix ltl .thestatesofourautomaton ar will keep track of which sub formulasin subfgx are trueand which onesarenot on theinputseensofar.thusastateisessentiallya valuationh subfgx over .
we use val to denote the setofallvaluations over .
while keeping track of the truth of sub formulae is necessary it is not sufficient.
in order to determine truth of formulas in ltl likexxa the automaton will additionally also keep track of the last few events seen in its control state.
how many events need to be tracked depends on the number of xoperators that appear inltl sub formulasof .recallthatweareassumingthat xs have been pushedas farinas possible in .
for ltl define xdepth to be the nesting depth of xoperators in .
and more generally for ltl we definexdepth max xdepth sub ltl .
for example ltl sub formulasof xg hhhhhhhhhhhhhhhhh xxxnnnnnnnnnnnnnnnnn arehhhhhhhhhhhhhhhhhandthe sub formulas of xxxnnnnnnnnnnnnnnnnn.
thus xdepth xg hhhhhhhhhhhhhhhhh xxxnnnnnnnnnnnnnnnnn .
on theotherhand sincetheonly ltl sub formulasof hhhhhhhhhhhhhhhhh xgnnnnnnnnnnnnnnnnn arehhhhhhhhhhhhhhhhhandnnnnnnnnnnnnnnnnn xdepth hhhhhhhhhhhhhhhhh xgnnnnnnnnnnnnnnnnn .
tocomputethenextstate h obtainedafterreadingasymbol ein stateh theautomatonneedstoupdatethetruthofallsub formulas insubfgx .
it turns out that we can in fact compute the truth ofallsub formulasin sub andthusthevaluation h solelyby lookingath e theformula andthelast keventsseeninthetrace wherek xdepth .
this definition of how truth of sub is updated is critical not only in defining the automaton but also instatingitscorrectness.wepresentthisdefinitionbeforegiving theformaldefinitionof ar .inthisdefinition wewilluse kto denotethe setofallsequencesover of length at most k. definition .
let ltl h val andbuf k. for any event e post h buf e sub is defined inductivelyas follows.
post h buf e a a e post h buf e parenleftbig post h buf e parenrightbig post h buf e 1 2 post h buf e 1 post h buf e 2 if post h buf e g h g post h buf e post h buf e f h f post h buf e post h buf e x parenleftbig buf f parenrightbig x ltl h 3otherwise havingoutlinedthebasicintuitionbehindtheconstructionof ar we are ready to present its formal definition.
in the following for a function f a band setc a we denote by f cthe restriction of fto the domain c. 3this definition assumes eis at least the second event read.
post h buf e x ifeisthe firstevent.
136checkingltl oncompressedtracesin polynomialtime esec fse august athens greece hhhhhhhhhhhhhhhhh nnnnnnnnnnnnnnnnn nnnnnnnnnnnnnnnnn hhhhhhhhhhhhhhhhh q0 q2 q1 q3 q4nnnnnnnnnnnnnnnnn hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh nnnnnnnnnnnnnnnnn nnnnnnnnnnnnnnnnnhhhhhhhhhhhhhhhhh nnnnnnnnnnnnnnnnnhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh nnnnnnnnnnnnnnnnn figure3 automatonfortheformula nnnnnnnnnnnnnnnnn g nnnnnnnnnnnnnnnnn xnnnnnnnnnnnnnnnnn .
definition automatonfor ltl .for ltl withxdepth kand event set the dfaar q q0 f isdefinedas follows.
thestatesin qaretriplesoftheform h b buf whereh val b andbuf k. intuitively htracks the truthof fgx sub formulas of whilebtracks whether is trueontheinputreadsofar.additionally bufstoresthelast ksymbolsread bythe automatonthus far.
the initial state q0is h0 where for every g f subfgx h0 f andh0 g .
thetransitionfunction isgivenasfollows h b buf e post h buf e subfgx post h buf e buf wherebuf istheprefixoflength koftheconcatenatedsequence e buf.
the final states f h buf h val andbuf k .
letusillustrate the automatonconstruction withan example.
example .
consider the formula nnnnnnnnnnnnnnnnn g nnnnnnnnnnnnnnnnn xnnnnnnnnnnnnnnnnn from example2.thebackwardsautomaton ar for isshowninfigure thealphabetisassumedtobe hhhhhhhhhhhhhhhhh nnnnnnnnnnnnnnnnn .thesetofsub formulas subfgx g nnnnnnnnnnnnnnnnn xnnnnnnnnnnnnnnnnn is singleton and thus there are valuations in val .
further xdepth and thus the buffer size isatmost1.thestatesof araretriples h b buf whereh val b andbuf hhhhhhhhhhhhhhhhh nnnnnnnnnnnnnnnnn .
in the figure we only show the first component valuation h andthethirdcomponent thebuffer of the state.
since there is only one formula in subfgx we write thevaluation hasthetruthvalueitmapsthesub formulato.the component bcan be inferred fromthe figure b in a state iff the state isan accepting state state q1 .
nowconsiderthetraces 1 hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnand 2 hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhnnnnnnnnnnnnnnnnn.observethat theautomatonrejectsthetrace r nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhbutaccepts r nnnnnnnnnnnnnnnnnhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhas 1 f but 2 f .
the correctnessproof oftheautomaton constructionin definition3relieson the following technical lemma whichsaysthat the automatoncorrectlycomputesthetruthofeverysub formula.itcan beprovedusinganeasyinductionon andstructuralinduction onthe formula.
lemma .
.
for ltl letar q q0 f be the dfaasgivenindefinition .foranyexecution e wheree forany sub f ifandonlyif post q0 r e .
wecannowstatethecorrectnessofourautomatonconstruction.
theorem .
.
let ltl andar bethedfagivenin definition .foranyexecution f ifandonlyif r l ar .
proof.let e .
observe that r l ar iff q0 r h forsomeh.fromthedefinitionofthetransitionfunction thisisequivalentto post q0 r e .fromlemma .
this isthe same as f andthereby establishing the theorem.
size ofar .observe that the number of states of the automaton ar is2 subfgx k wherek xdepth .sincesubfgx sub and sub the number of states is o k .
we next argue that though ar haso k states in any run it goes through at most o k states.
this is based on the observationthat state changes in ar aremonotonic .
consider two valuations h subfgx .
we will say that hif for every f subfgx if f then h f and for everym subfgx wherem x g if m thenh m .
lemma .
.
for ltl letar q q0 f be the dfa defined in definition .
letu and let states h1 b1 buf1 and h2 b2 buf2 be such that h1 b1 buf1 u h2 b2 buf2 .
then h1 h2.
theproofoflemma .2followsfromthedefinitionof thetransition function andinduction onthe length of u. lemma4.2establishes that once the valuation component of thestatechanges youneverrevisitthesamevaluation.sincethe assignment to any subfgx can change at most once the numberofvaluationsvisitedinanyrunisboundedby subfgx thereby giving a bound on the number of states visited in any run corollary4.
.
let ltl beaformulaover .thedfa ar visitso k distinct states onany inputtrace monitoring compressedtraces againstltl we will now present our main result an efficient algorithm to check givenanslp g t n s r and ltl if llbrackets rrbracket f .ouralgorithmfollowsthetemplatealgorithmforslpsoutlinedin section2.
.
that is we will run the automaton ar definition on the uncompressed trace llbrackets rrbracket without explicitly uncompressing the slp.
this can be accomplished by computing for every state qandnon terminal a n thestate q llbracketa rrbracketr andthenfinally checking q0 llbrackets rrbracketr f whereq0isthe initialstate and fisthe set of final states of ar .
as pointed out in section .
this runs in o g ar d time where disthetimetocomputethetransition function which given the description of ar iso g k wherek xdepth .now wecanobservethatitisnotnecessary to compute q llbracketa rrbracketr for every state q but only for the states visited during a run of ar on llbrackets rrbracketr.
this can be accomplished if weuseda on the fly algorithmforthe q llbracketa rrbracketr computations.
for such an algorithm given the monotonicity properties of ar lemma4.
andtheresultingboundonthenumberofvisitedstates corollary .
wecanimprovetherunningtimeto o g k .
the main observation in this section is that this on the fly algorithmin fact has a runningtime thatispolynomialin the size ofgand .
this requires us examine this algorithm in some detail andanalyze its running time carefully.
recallthatastateof ar isoftheform h b buf whereh val b isabooleanrecordingthetruthof andbufisthebuffer trackingthelast ksymbolsread.now consideranon terminal a 4recallthatar runsthe execution in reverse.
137esec fse august athens greece minjianzhang umangmathur andmahesh viswanathan and state h b buf .
let h b buf h b buf llbracketa rrbracketr .
based onthedefinition weknowthatthevalueoftheboolean bdoesnot influencethevaluesof h b andbuf .thisboolean bisonlyneeded to determine if the last state i.e.
q0 llbrackets rrbracketr is a final state this can alternatively be determined from the valuation h at the end andbuffer buf usingafunctionanalogousto post definition weskipgivingthisdefinition.next buf isnothingbuttheprefixof lengthkoftheconcatenatedstring llbracketa rrbracket buf whichcanbecomputed inaninductivemannerbasedontherulesinthegrammar.inthe interests of space we don t give how buf can be computed but we assume we have a function updatebuffer a buf which returns the prefix oflength kof llbracketa rrbracket buf.
algorithm1 computestateofautomaton ar afterreading the string llbracketa rrbracketr 1function poststate a h buf 2visited visited a buf 3ifa ethen if e buf visitedthen return h else e buf nelementvisited visited visited e buf h h buf e ifh nequalhthenvisited returnh 10else a bc if c buf visitedthenh h else c buf nelementvisited h poststate c h buf buf updatebuffer c buf if b buf visitedthen return h else b buf nelementvisited h poststate b h buf returnh thecriticalfunctionisreallythecomputationof h givennonterminala valuation hand buffer buf.
a pseudocode for this functionpoststate is given in algorithm .
we will call poststate witharguments a h bufonlyonce.afterthefirstcallwewillmemoize this result and if in subsequent computations there is a need tocompute poststate a h buf wewillusethestoredresult.the data structure storing these previously computed poststate results is called visitedin algorithm .
observe that monotonicity propertiesofar lemma4.
meanthatifthevaluation hinthe state changes during an execution the automaton never returns to the same valuation again.
hence visitedjust stores the previous calls for the currentvaluationh assoon asthevaluationchanges we reset the data structure visitedbecause the previous calls to poststate will never be repeated as hhas changed.
moreover this means that visitedonly stores pairs a buf when a call to poststate a h buf returns the valuation h. inline2 werecordthefactthatwehavemadeacall poststate a h buf by adding a buf tovisited.
the computation then proceeds based on the rule for the non terminal a. ifa e e h0 s b c hhhhhhhhhhhhhhhhh a62 hhhhhhhhhhhhhhhhh a32 hhhhhhhhhhhhhhhhh a16 hhhhhhhhhhhhhhhhh a8 hhhhhhhhhhhhhhhhh a4 hhhhhhhhhhhhhhhhh a2 hhhhhhhhhhhhhhhhh a1 hhhhhhhhhhhhhhhhh nnnnnnnnnnnnnnnnn hhhhhhhhhhhhhhhhh hhhhhhhhhhhhhhhhh nnnnnnnnnnnnnnnnn a30 hhhhhhhhhhhhhhhhh a24 hhhhhhhhhhhhhhhhh a6 hhhhhhhhhhhhhhhhh a65 nnnnnnnnnnnnnnnnn a33 nnnnnnnnnnnnnnnnn a1 nnnnnnnnnnnnnnnnn nnnnnnnnnnnnnnnnn nnnnnnnnnnnnnnnnn h1 hhhhhhhhhhhhhhhhh nnnnnnnnnnnnnnnnn a32 hhhhhhhhhhhhhhhhh a16 hhhhhhhhhhhhhhhhh a8 hhhhhhhhhhhhhhhhh a4 hhhhhhhhhhhhhhhhh a2 hhhhhhhhhhhhhhhhh a1 hhhhhhhhhhhhhhhhh nnnnnnnnnnnnnnnnn hhhhhhhhhhhhhhhhh hhhhhhhhhhhhhhhhh nnnnnnnnnnnnnnnnn figure executing algorithm 1on slp in figure 2with property nnnnnnnnnnnnnnnnn g nnnnnnnnnnnnnnnnn xnnnnnnnnnnnnnnnnn .
the valuation h0corresponds to g nnnnnnnnnnnnnnnnn xnnnnnnnnnnnnnnnnn mapsto andh1is g nnnnnnnnnnnnnnnnn xnnnnnnnnnnnnnnnnn mapsto .
the figure shows the setvisitedfor each valuation.
elements are added to visitedfrom lefttorightasrecursivecallsaremade.initiallythevaluationis h0 which changes to h1when h0 nnnnnnnnnnnnnnnnn nnnnnnnnnnnnnnnnn is computed.
isthe rule then we return hif we have computed it before line orfindthenewvaluationbycomputingthetransitionfunction .
note that visitedis set to if the valuation changes line .
on theotherhand iftheruleis a bc lines10through17 thenwe compute the result by running candthenb.
example .
consider the trace from example 1of the program infigure .itscompressionasanslpisgiveninfigure .letus fixthepropertytobecheckedtobe nnnnnnnnnnnnnnnnn g nnnnnnnnnnnnnnnnn xnnnnnnnnnnnnnnnnn from example .letussee howalgorithm 1evaluates onthis slp.
recall that subfgx g nnnnnnnnnnnnnnnnn xnnnnnnnnnnnnnnnnn .
thus there are two valuations h0 g nnnnnnnnnnnnnnnnn xnnnnnnnnnnnnnnnnn mapsto andh1 g nnnnnnnnnnnnnnnnn xnnnnnnnnnnnnnnnnn mapsto withh0being the initial valuation.
next recall that sincexdepth the buffer isof size at most1.
the algorithm starts with a call poststate s h0 i.e.
buffer isempty whichinitiatesasequenceofrecursivecallsto poststate with different arguments.
initially visitedis empty.
line of algorithm1adds s tovisited andgiventherulefor s makesa recursivecall poststate b h0 lines11to13 .theset visited memoizestheresultofacallto poststate toavoidre computingan answer if a buf visitedafterreturningfromacall poststate a h buf then it means that the valuation after running llbracketa rrbracketfrom valuationhwith buffer bufish.
figure4shows the set visited.
the first row shows the set visitedwhile the current valuation is h0 andthesecondrowshows visitedafterthevaluationchangesto h1.
recursivecallsto poststate addelementsto visitedintheorder shownfrom left to right.
thecallpoststate b h0 leadstoacall poststate c h0 which then results ina checkof h0 hhhhhhhhhhhhhhhhh lines 6through .
since h0 hhhhhhhhhhhhhhhhh h0 see automaton in figure visitedis not reset.
the buffer changes to hhhhhhhhhhhhhhhhh line and a call is made topoststate a62 h0 hhhhhhhhhhhhhhhhh line .
this results in a sequence of recursive calls with non terminals aifor valuesi .
to see how storing results in visitedhelps let us see what happens during the callpoststate a2 h0 hhhhhhhhhhhhhhhhh .arecursivecall poststate a1 h0 hhhhhhhhhhhhhhhhh is made line13 whichreturns h0 runningtheautomatoninfigure on llbracketa1 rrbracketfromh0leaves the valuation unchanged.
the updated buffer line14 remains hhhhhhhhhhhhhhhhh andsince a1 hhhhhhhhhhhhhhhhh visited becauseof the previous call we do not make additional recursive calls to poststate line .
such savings in calls to poststate happen in manyofthe calls involving the non terminals ai.
aftertherecursivecall poststate b h0 returnsh0 nochange tovaluation thealgorithmwillmakeacallto poststate a65 h0 nnnnnnnnnnnnnnnnn sincethebufferafterreading llbracketb rrbracketisnnnnnnnnnnnnnnnnn.thisleadstocalls poststate 138checkingltl oncompressedtracesin polynomialtime esec fse august athens greece a33 h0 nnnnnnnnnnnnnnnnn andpoststate a1 h0 nnnnnnnnnnnnnnnnn aswellasacomputationof h0 nnnnnnnnnnnnnnnnn nnnnnnnnnnnnnnnnn .thevaluationreturnedby isnowh1 whichleads tovisitedbeingresetto line8 .theevolutionoftheset visited afterthechangeofvaluationisshowninthesecondrowoffigure .
afterthecall poststate a65 h0 nnnnnnnnnnnnnnnnn returnswithvaluation h1 we need to evaluate whether holds.
it turns out that given a valuation of each formula in subfgx namelyh1 and the buffer aftera65 namelyhhhhhhhhhhhhhhhhh we can compute the truth valuation for all subformulas of including itself.
details of this process are omitted in the interests of space.
carrying this computation out we discover that is not true and hence the execution encoded by the slp infigure 2does not satisfy .
running time.
the running time for each call to poststate is dominatedbyeitherthetimetakenforline7orforline14.thisisbecauseifwemakerecursivecallsto poststate lines13and17 that timecanbeascribedtothoserecursivecalls.line7takesatmost timeo while line takes o k time recall k xdepth .
thus eachcallto poststate takeso time.thenumberofpossible calls to poststate is at most the number of triples a h buf whichis g k.thus thetotalrunningtimecanbebounded byo g k .thisboundhasanexponentialdependenceon k o andwe willshowthat this can be improved.
thekeytoimprovingtheboundistodoamorecarefulcountof thenumberof poststate calls.monotonicity lemma .
ensures that there are at most different valuations h. therefore for any fixedvaluation h wewilltrytoboundthenumberofpairs a buf thatcanariseasargumentsinacallto poststate withhasthevaluation.
our observation is that this is much less than g k. this is because if a h buf is an argument to poststate then llbracketa rrbracketbuf must be a substring of llbrackets rrbracket.
let us fix the uncompressed string i.e.
llbrackets rrbracket to be .
as a first step towards counting such pairs a buf we define the notion of when a non terminal cisresponsible for generatingthe pair a buf .
definition .
a non terminal cis said to be responsible for a substring of ifcisthelabelofthelowestinternalnode ofthe parse tree for that has as asubstring.
similarly cisresponsibleforpair a buf ifcisresponsiblefor some occurrenceof the string llbracketa rrbracket buf which isa substring of .
observe that all nodes labeled care responsible for the same set of pairs a buf .
this is because such pairs are completely determinedbytheparsetreewithrootlabeled c.moreover thereis some non terminal that is responsible for each pair a buf .
thus wecanupperboundthenumberofpairs a buf bycounting the number of pairs each non terminal cis responsible for.
lemma .
presentsonesuchbound anditsproofispresentedintheappendix.
lemma5.
.
anon terminal cisresponsibleforatmost o h c k pairs here h c is the height of the parse tree whose root is labeledc.
takingh g to denote the height of the grammar or h s we canuse lemma .1toget thefollowingbound ontherunningtime.
theorem .
.
given an slp gwith start symbol sand formula ltl the problem of determining if llbrackets rrbracket f can be solvedintime o g h g k .theorem .1follows from observing that lemma .1shows that thenumberofcallsto poststate isboundedby o g h g k andthe running time ofeachcallto poststate isat mosto .
experimentalevaluation wegaugethefeasibilityofourproposedapproachofmonitoring compressed execution traces by comparing the performance of our algorithm against that of the standard approach of monitoring traces without compressingthem.
the goals of our evaluation are compression ratios.
the asymptoticruntime ofour algorithmvaries quadratically withthesizeofthecompressed trace theorem .
.
as a result any speed up over analysis of uncompressed traces will evidently only be because of good compression ratios.
we therefore want to evaluate whetherexecutiontracesfromrealworld software projects can be compressedefficiently.
performanceofalgorithm.
ournextgoalistounderstand howtherunningtimevarieswiththesizeofthecompressed trace slp inpractice.further inordertoevaluatethepracticalfeasibilityofourapproach wewanttoevaluatewhether ouralgorithmforanalyzingcompressedtracesperformsbetter than the standard approach of analyzing uncompressed traces directly by a good margin.
finally we want to understandhowthespeedupvarieswithfactorssuchascompression ratio.
we next describe ourimplementation and experimental setup section6.
andthen discuss our evaluation results section .
.
.
implementation andsetup the broad outline of our experimental setup is as follows.
for our setofbenchmarkprograms weextractexecutiontracesusingan off the shelfloggingtool.wethencompressthesetracesasstraight line programs slps and analyze the slps thus generated using ouralgorithmdetailedinsection .wealsocomparetherunning time of our algorithm with the time it takes to analyze the original uncompressed traces using the standard approach i.e.
running against finitestate automatacorresponding to our ltlspecs .
implementation.
we implemented our algorithm in our tool zipmop primarily written in java in about loc .
we use javamop forextractingexecutiontraces.
javamop instruments a java program under test and adds monitoring code ateacheventofinterestforcheckingiftheprogram sexecutions meetsomeformalspecification.forourexperimentalevaluation weobtainedexecutiontracesbymodifying javamop sothatitlogs eventstoafile.toanalyzeuncompressedtracesagainst ltl properties weuse rabinizer .
publiclyavailableat .rabinizer .0isastate of thearttoolfortranslatingltlformulaeinto automata.foreachoftheltlpropertiesweconsider weobtain deterministic finite automata using rabinizer .
and check if this automataacceptsthe trace inconsideration.
benchmarks and traces.
our subjects are open source github repositoriesderivedfromapriorempiricalstudy ongithub projects aswellasindependentlyobtainedfrom githubbasedon theirpopularityscore measuredbygithubstars .weuse javamop to instrument these repositories so that all events of interest those 139esec fse august athens greece minjianzhang umangmathur andmahesh viswanathan .
.0m .0m .0m .0m .0b size of traces a distributionof tracesizes .
.0k .0m .5m .0m size of slps b distributionof sizes of compressedtraces .
.
.
.
.
.
.
.
.
compression ratios c distributionof compressionratios figure sizes of uncompressed andcompressed traces andcompressionratios.
that occurin any of theltl specs are logged.we then generated tracesbyrunningalltestclassesoftheserepositories.wechosethe top100tracesbasedonthetracelengths.theminimum maximum and average trace lengths in this set are .6m .03b and 209m.
the overalldistributionisgiven infigure 5a.
ltlspecifications.
ourltlpropertiesarealsoobtainedfrom .
most of these properties specify the expected usage of different datastructuresandapisusedinthesesoftwareprojects andare expressed in many different formalisms regular expressions ere ltl fsm etc.
.anexamplepropertyis nnnnnnnnnnnnnnnnn g nnnnnnnnnnnnnnnnn xnnnnnnnnnnnnnnnnn from example in section .
that specifies how an iterator of the setcollection must be used every call to nextnextnextnextnextnextnextnextnextnextnextnextnextnextnextnextnext denoted by nnnnnnnnnnnnnnnnn mustbeimmediatelyprecededbyacallto hasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnexthasnext denoted by hhhhhhhhhhhhhhhhh .
another such property is g cr f cl which statesthataresource suchasabufferedstream musteventually be closed cl every time it is created cr .
we identified that properties were expressible in the fragment ltl and selectedallofthemfor our study.
setup.we compare the running times of our algorithm over compressed traces to the time for analyzing the corresponding uncompressed traces against our ltl specifications.
after obtainingtraces from our benchmark projects using javamop we compress these traces using the sequitur algorithm available publicly which runs in linear time in the size of the uncompressedtrace.fortheuncompressedtraces weuse rabinizer .
to generate a deterministic finite state automaton for each property.
for every property rabinizer .
generates a rabin automata which is essentially a finite state machine together with an acceptance condition for deciding membership of infinitewords.
we manually transformed these automata so that they are suitable for analyzing finite traces.
our experiments were conducted over a .6ghz bitlinux machine.
.
evaluationresults size of compressed traces and compression ratios.
while the uncompressed traces have lengths varying from 50m to .03b the sizes of the compressed traces slps all lie between 54k and .8m.theaveragesizeoftheslpsisapproximately329 kandthe overall distribution ispresented in figure 5b.
the compression ratiosofeachtracewasobservedtobeatleast277.themaximumand average compression ratiosare1016and641 andthedistribution is shown in figure 5c.
the significant compression ratios hint thatmostopensourceprojectsgenerateexecutiontracesthathavealot ofrepetitionandthuscanbeeffectivelycompressed.aplausible explanationof largeamountofrepetitionsisthatmany unittests inoursubjectrepositoriesrepeatedlymanipulatecollectionobjects such as listsorsets inaloop.
runningtimes.
infigure 6a weplottherunningtime inseconds for every compressed trace.
these times are averaged over the runningtimeof zipmopacrossallthe10 ltl properties weconsider.further inordertoensurefaircomparisonwiththe analysis over uncompressed traces we exclude the time to read uncompressedorcompressed tracefilesinmemory including i o times would penalize theuncompressed analysis more heavily as they work over larger files.
observe that all the times are within .
second excluding i o time .
also observe that as expected the timesincreasewiththesize ofthecompressed trace slp .
infact we can see that the time increases linearlywith the size of the slp despitetheworstcasedependenceof g 2asintheorem .
h g can beo g inworst case .
speed upoveranalysisofuncompressedtraces.
wenowcomparehowtherunningtimeovercompressedtracescomparewith therunningtimeofanalyzinguncompressedtracelogs.figure 6b shows the speed uptime to analyze uncompressedtrace time to analyze slp where asbefore boththenumeratoranddenominatorareaveragetimes over all ltl specs.
further both the times exclude i o time.
the maximum minimum and average speed ups are and .
thehighspeedupshowsthepowerofcompressioninanalyzing trace logsas comparedto uncompressedversions.
infigure 7aweshowhowthespeedupvarieswiththecompressionratio.asexpected ouralgorithmperformsbetter asagainst the uncompressed analysis when the compression ratio is high.
this is because the time to analyze an uncompressed trace is o time to check membership in a finite automaton and the time to analyze a compressed trace gusing our algorithm section5 is proportional to o g and the speed up thus increases withthe quantity o g whichisthe compressionratio.
in figure 7b we analyze the efficiency of the algorithm defined as speedup compressionratio.theefficiencyfactorintuitivelycaptures how well can the speed up over uncompressed traces be explained using the compression ratio.
we observe that the efficiency values are in the range .
to .
and this is likely because of the constant multiplicative factors involved in the running time of our 140checkingltl oncompressedtracesin polynomialtime esec fse august athens greece .
.0k .0m .5m .0m size of slp .
.
.
.
.
.
.35average running time s a running time v ssize of compressedtrace .
.
.
.
.
.
speed up b distributionof speedup over uncompressedanalysis figure runningtimeandspeed overuncompressed analysis .
.
.
.
.
.
.
compression ratio .
.
.
.
.
.
.
.0speed up a compressionratiov sspeedup .
.0k .0m .5m .0m size of slp .
.
.
.
.14 speed up compression ratio b efficiencyfactorv ssize of slp figure speed up compressionratio andefficiency algorithmforcheckingcompressedtraces.further theefficiency factorincreases almost monotonicallywiththesizeofthecompressed format implying that higher compression ratios are more effective when the compressedtraces are themselves large.
related work fromatheoreticalstandpoint theworkthatisclosesttooursisthat of markey and schnoebelen which established the pspacehardnessforthegeneralproblemofcheckingifastring represented as an slp satisfies a formulawritten in full ltl our resultshows polynomial time tractability for the ltl sub fragment.
notably the hardness in arises from the use of arbitrarily nested until operators in ltlformulae.
lohrey comprehensively surveys algorithmic and complexity theoretic aspects of language theoretic questions involving slps.
galperin and wigderson and subsequentlyothers showedthatgraph problems that are tractable on the uncompressed input become intractable when posed over compressed succinct representations.
analysis of execution traces or event sequences has been central to the engineering of reliable and efficient software.
while in our work we propose the use of compression in runtime verification prior works have focused on the use of compression in race detection profiling or programcomprehensionusingdynamicslicing .morerecentworksonlargescaledebugging buglocalization and triaging usingtracedataobtainedfromstacktracesobtainedat the time of crashes while implicitly rely on compression provided by databases that store large columes of trace data they do not leveragecompressionintheactual analysistasks suchaspatternminingorclustering .aninterestingavenueforfutureworkwould betodeveloptechniquestospeedupsuchtechniquesbyleveraging compression.
conclusions we propose the use of compression as an algorithmic paradigm to improve the efficiency of checking if execution traces conform to specifications written in ltl linear temporal logic .
while this problem is intractable pspace hard in general we establishapolynomialtimealgorithmfortherichfragment ltl whose formulae do not include the uoperator of full ltl.
our polynomialtimealgorithmleveragesamonotonicitypropertyin the automata theoreticrepresentation of formulaein ltl .
on a comprehensive benchmark suite of open source java projects our evaluation confirms that execution traces can be effectively compressed and that the membership problem of traces can be efficientlydecidedovercompressedformats straightlineprograms withoutdecompressingthem resultingintosignificantspeedups when comparedto analysisover uncompressedtraces.