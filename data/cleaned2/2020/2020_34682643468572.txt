detecting concurrency vulnerabilities based on partial orders of memory and thread events kunpeng yu chenxu wang yukunpeng33 stu.xjtu.edu.cn cxwang mail.xjtu.edu.cn school of software engineering moe key lab of inns xi an jiaotong university xi an shaanxi chinayan cai sklcs institute of software chinese academy of sciences university of chinese academy of sciences beijing china ycai.mail gmail.com xiapu luo the hong kong polytechnic university hong kong china csxluo comp.polyu.edu.hkzijiang yang xi an jiaotong university xi an shaanxi china yang guardstrike.com abstract memory vulnerabilities are the main causes of software security problems.
however detecting vulnerabilities in multi threaded programs is challenging because many vulnerabilities occur under specific executions and it is hard to explore all possible executions of a multi threaded program.
existing approaches are either computationally intensive or likely to miss some vulnerabilities due to the complex thread interleaving.
this paper introduces a novel approach to detect concurrency memory vulnerabilities based on partial orders of events.
a partial order on a set of events represents the definite execution orders of events.
it allows constructing feasible traces exposing specific vulnerabilities by exchanging the execution orders of vulnerability potential events.
it also reduces the search space of possible executions and thus improves computational efficiency.
we propose new algorithms to extract vulnerability potential event pairs for three kinds of memory vulnerabilities.
we also design a novel algorithm to compute a potential event pair s feasible set which contains the relevant events required by a feasible trace.
our method extends existing approaches for data race detection by considering that two events are protected by the same lock.
we implement a prototype of our approach and conduct experiments to evaluate its performance.
experimental results show that our tool exhibits superiority over state of the art algorithms in both effectiveness and efficiency.
ccs concepts software and its engineering software testing and debugging .
corresponding author permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse august athens greece association for computing machinery.
acm isbn .
.
.
.
concurrency vulnerability multi threaded programs partial orders acm reference format kunpeng yu chenxu wang yan cai xiapu luo and zijiang yang.
.
detecting concurrency vulnerabilities based on partial orders of memory and thread events.
in proceedings of the 29th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse august athens greece.
acm new york ny usa pages.
introduction programs written in c c are generally memory efficient and computationally fast because they allow direct memory access without additional safety checks.
however this flexibility sometimes could cause severe vulnerabilities due to wrong memory access.
for example a dereference to a null pointer will cause undefined behaviors in c c programs which usually leads to severe security problems .
technicians have developed several tools to detect these memory related errors .
with the development of multi core processors more and more concurrency multi threaded programs are developed for computational efficiency.
when a multi threaded program runs operations in various threads are interleaved in unpredictable orders subject to the constraints imposed by explicit synchronization operations.
although operations in each thread are strictly ordered the interleaving of operations from a collection of threads is non deterministic and depends on the program s execution.
that is operations in concurrency programs have various execution orders and some vulnerabilities only occur in specific thread interleaving.
for example the execution order of two events accessing the same memory address by different threads may be exchangeable because of thread interleaving.
if a read event to a variable occurs unexpectedly before a write one an error may be caused in some situations .
however it is challenging to detect concurrency memory vulnerabilities due to non deterministic thread interleaving.
besides it is computationally intensive to explore all the possibilities of thread interleaving leading to the efficiency problem in concurrency vulnerability detection.
esec fse august athens greece kunpeng yu chenxu wang yan cai xiapu luo and zijiang yang in this paper we focus on detecting three kinds of concurrency vulnerabilities including use after free uaf double free df and null pointer dereference npd which are mostly caused by wrong memory address accesses in stochastic executions .
a uaf occurs when a dangling pointer accesses a freed memory .
when a program attempts to dereference a null pointer an npd occurs.
df means that a memory address is improperly freed twice .
it is easy to figure out these vulnerabilities in a single threaded program because all events occur in a definite sequence.
however it is non trivial to detect these vulnerabilities in multi threaded programs because only certain execution orders can trigger them.
there are two main approaches to detect concurrency vulnerabilities.
an intuitive solution is to cooperate with the fuzzing technology by running a target program many times and try to retrieve different execution orders exhaustively .muzz is a grey box fuzzer that uses thread aware instrumentation to get more various execution orders by adjusting thread priorities.
krace is a file system fuzzer aiming to detect data race among multiple threads.
it controls thread schedules by delaying a memory access for a random number of accesses in other threads.
however it is extremely expensive to get all possible execution orders due to the explosion of search spaces .
another way is to predict possible executions from observed ones.
huang s uaf finder optimal ufo is underpinned by a data race detection model based on constraint solving algorithms.
ufo relies on the constraint solver z3 which is computationally intensive for complex constraints.
exceptionull rearranges the trace to expose npd vulnerabilities.
it solves several constraints to guarantee the feasibility of the constructed traces.
the scheduling constraints are employed to represent necessary execution orders of a multi threaded program and then z3 is adopted to solve the constraints.
however this approach may cost a mass of time to solve complicated constraints.
convul uses a heuristic method based onsync edge andsync distance to determine whether two events are exchangeable.
a sync edge is an edge either from a lock event to its unlock event in the same thread or from an unlock event to a lock event on the same lock in the other thread.
the sync distance of two events is defined as the minimal number of sync edges ordering the two events .convul generates candidate traces that trigger vulnerabilities by exchanging the execution orders of events.
it assumes that two events with short sync distance are more likely to be exchangeable for computational efficiency improvement.
if the sync distance of two events is less than a predefined threshold default is convul schedules the trace and tries to exchange their execution order for vulnerability detection.
however it may miss some exchangeable events with long syncdistances.
in summary there is a lack of effective and efficient methods to detect concurrency vulnerabilities.
this paper presents convulpoe aconcurrency vulnerability detector based on partial orders of events.
similar to convul and ufo convulpoe attempts to generate execution traces exposing vulnerabilities.
however convulpoe follows constructed partial orders of memory and thread events to generate traces.
first we record the concerned thread operations and memory access events in an execution of a program through intel pin .
we represent the sequence of events as a trace.
second we develop new algorithms to extract vulnerability potential eventpairs that may cause vulnerabilities by passing through the trace.
we also design a novel algorithm to compute an event pair s feasible set which contains the relevant events required by a feasible trace exposing a vulnerability.
third we construct a partial order for a feasible event set to generate a new trace exposing a vulnerability.
the partial orders of an event set represent the deterministic execution orders between contextual events.
compared with the heuristic algorithm used in convul following a partial order of events to generate a trace allows us to detect vulnerabilities without false positive errors.
it also reduces the search spaces of possible executions which improves computational efficiency.
finally we implement a prototype of convulpoe for pthreadbased multi threaded c c programs based on intel pin.
we conduct experiments to evaluate the performance of convulpoe .
experimental results show that our tool can find more vulnerabilities than state of the art detectors in less time.
preliminaries a multi threaded program pconsists of various threads t1 t2 ... tn wherenis the number of threads.
each thread has a sequence of operations under sequential consistency semantics .
operations in different threads are interleaved randomly as the program runs.
like prior works this paper focuses on variable and lock accessing operations because most concurrency vulnerabilities are caused by improper synchronization on variables.
we refer to these operations as events .
an access to a variable is a read orwrite event.
we use r x andw x to denote a read andwrite event on variable x respectively.
operations on a lock include acquire andrelease .
similarly we employ acq l andrel l to denote an acquire andrelease event on lock l respectively.
we use a sequence of events to represent a program s execution and call it trace .
events in a trace are ordered sequentially.
given a trace we usee to denote the set of events in andw e resp.
r e la e lr e to denote the write resp.
read acquire release event set of .
given an event e we usetid e to denote the thread that executes eandloc e to denote the variable or lock that eaccesses.
if event eis an acquire release event we usematch e to denote the first release acquire event accessing the same lock following previous to ein the same thread.
given a pointer type variable x we usefree x to denote an event freeing x andderef x to denote the dereference operation ofx.
note that free x andderef x are two special cases ofread x .
given a trace we usefree e andderef e to denote the free anddereference event sets of respectively.
the following presents two critical definitions relevant to the execution of concurrency programs.
critical sections given a lock l a critical section is the set of sequential events in the same thread starting from acq l and ending withrel l match acq l includingacq l andrel l .
conflicting events two events are said to be conflicting if they belong to different threads and access the same variable and at least one of them is a write event.
we also say that two lock accessing events are conflicting if they access the same lock.
we usee1 e2to denote that e1ande2are conflicting.
281detecting concurrency vulnerabilities based on partial orders of memory and thread events esec fse august athens greece both critical sections and conflicting events can be got by passing through a trace once.
.
memory vulnerabilities c c programs adopt a series of functions or operators e.g.
malloc free new delete for dynamic memory management.
a block of heap memory must be allocated before it is accessed and freed after use.
accesses to a memory address that is not allocated yet or previously freed will lead to undefined behaviors of a program and usually cause crashes and security problems.
this paper focuses on three kinds of concurrency memory vulnerabilities including use after free uaf null pointer dereference npd and double free df .
use after free uaf a uaf occurs when a block of previously freed memory is used.
it can cause serious consequences ranging from corruptions of valid data to the execution of arbitrary codes .
null pointer dereference npd an npd occurs when a null pointer is dereferenced.
it typically causes a crash or an abnormal exit.
in rare circumstances it also leads to the execution of arbitrary codes .
double free df a df occurs if a program calls free twice with the same argument i.e.
the memory address .
it can cause programs crashes or make them vulnerable to buffer overflow attacks under specific conditions .
these vulnerabilities are caused by several flaws such as race conditions and other exceptional circumstances.
the non deterministic execution of multi threaded programs makes these vulnerabilities more frequent to occur and harder to be detected.
.
feasible traces not all reordered traces of an observed one are valid and feasible.
even a few changes to the events execution orders may cause the program to execute other branches.
hence we cannot use an arbitrarily reordered trace to represent an execution.
every read event should get the same value as it did in the original trace to ensure the validity of the reordered trace.
given a trace and a read eventr we say that robserves a write eventwin ifwis the nearest event before rthat writes the same variable.
we use obs r wto denote that robservesw.
we haveobs r w iffloc r loc w andw r and there is no other write event w thatloc w loc r andw w r. for simplicity we assume that every variable has a write event initializing it.
we first define the projection of a trace onto a thread and then define feasible traces.
projection given a trace and a thread t the projection of onto thread tis defined as the event sequence of tand is denoted by t. that is tis a sub sequence of satisfying that tonly contains the events of thread t. that is e t e and e e t tid e t. event orders in tis the same as that in .
that is e1 e2 e tid e1 tid e2 t e1 e2 e1 te2.
given an observed trace we say another trace isfeasible if the following properties hold trace only contains the events in .
that is e e .
need not contain all the events in because we just wantthe program to execute to the point where a vulnerability occurs and do not care about what happens after it.
events in the same thread must execute in the same order in and .
that is for every thread t tis a prefix of t. critical sections on the same lock cannot overlap.
that is given two acquire eventsacq1andacq2 andloc acq loc acq ifacq1 acq2 thenmatch acq1 acq2.
every read eventrshould observe the same event in as it does in .
that is r r e obs r obs r .
.
partial orders multi threaded programs usually have different execution orders due to non deterministic thread interleaving.
the execution orders of some events could be exchanged in different runs of a multi threaded program.
in this paper we are concerned about exchangeable event pairs because they are more likely to cause memory vulnerabilities.
given two events e1ande2 we say that e1 e2 is exchangeable if two valid traces and exist and the execution orders of e1ande2in the two traces are different i.e.
e1 e2 e2 e1 .
some events must execute before others to make a reordered trace feasible.
we use partial orders to represent the execution orders of events.
given an event set e a strict partial order p e is an irreflexive transitive and asymmetry relation over e. ife is clear from the context we will use pfor simplification.
there are two basic partial orders over e for a trace .
the first is the execution order we mentioned above which represents an execution of a program.
we denote the execution order by tr e which is determined by the trace .
the execution of a single thread can also be represented by a partial order.
if event e1is performed before event e2in and both events are in the same thread we say e1isthread ordered beforee2 denoted by e1 te2.
we denote the thread order by to e .
note that any two events of are ordered bytr e but only events in the same thread are ordered byto e .
given a partial order p two events e1 e2areunordered denoted bye1 pe2 if neithere1 pe2 nore2 pe1.
for example any two events in different threads are unordered by to e .
on the other hand if a trace is feasible events in the same thread must execute in the same order in .
that is given e1 e2 e and e1 e2 e ife1 te2 thene1 te2.
feasible trace construction in this section we first give an example to illustrate the motivation of our method.
then we present the algorithm to generate new feasible traces based on an observed one.
.
a motivating example figure a shows a trace containing three threads.
we use eito denote thei th event.
let e14assign null to y. note thate11is a pointer dereference event and e11 e14 is an event pair protected by the same lock l. ife14executes before e11 then an npd occurs.
to prove that we need to reorder these events and get a new trace in whiche11is not included to make e14execute first.
since the new trace is feasible and includes the event right before e11 we can appende11to the end of the new trace and keep it feasible.
282esec fse august athens greece kunpeng yu chenxu wang yan cai xiapu luo and zijiang yang the first step is to figure out what events should be included in the new trace.
for example the events in t2are not needed in the new trace because there is no write event and other events need not observe them.
therefore the event set should be e ei i ei i ei i .
events in the same thread have already been ordered.
to get a feasible trace we need to make some events in different threads reordered.
we introduce partial order to solve the problem.
figure b is a partial order graph constructed based on e. we can see that there are two additional edges from e1toe9and frome15toe10.
the first edge makes e9read the value written by e1 as it does in the origin trace.
and the second one makes the critical sections on lock lnot overlap.
then we can get a feasible trace e1 e9 e2 e3 e4 e5 e13 e14 e15 e10 e11 wheree14executes before e11.
thus we can prove that there is an npd vulnerability.
figure an example of a trace and one of its partial orders.
in the rest of this section we first define a feasible event set for an execution trace of a multi threaded program.
a feasible event set contains necessary events that build a new trace.
then we build a partial order based on the feasible event set to add some ordering between events.
finally we present the algorithm to generate new feasible traces.
.
feasible event sets as we mentioned above a feasible trace need not contain all the events in the original trace .
besides not all partial orders can produce a feasible trace.
the first problem of getting a feasible trace from a partial order is to extract a subset of e .
we say that a subset ofe isfeasible if it is prefix closed lock feasible and observation feasible for .
prefix closed for every event pair e1 e2 e we say thate is prefix closed if e2 e ande1 te2 thene1 e .
it ensures that tis a prefix of tfor every thread t. we can see that the event set in figure b is prefix closed.
lock feasible we say thate is lock feasible if i rel lr match rel e and ii acq acq opnacq e loc acq loc acq whereopnacq e acq la match acq e is an event set that contains open acquire events whose matching release events do not belong to e .
the first condition guarantees that the matching acquire event for each release event ine is also ine .
the second ensures that there is at most one open acquire event for every lock.
in figure1 b match e15 e2ande10is the only open acquire event.
so the event set is lock feasible.
observation feasible.
we calle is observation feasible if r r e obs r e .
it guarantees that there is a write event writing the value read by later events.
in figure b e1writes the variablex which is read by later events e3ande9.
so the event set is observation feasible.
.
trace closed partial orders in this paper we use partial orders to represent the execution order of events.
given two partial orders pandqover an event set e we say thatqrefinesp if e1 e2 e e1 pe2 thene1 qe2.
we denote it asq pand say that pisweaker thanq.
a weaker partial order means less constraints on the execution orders of events and we can construct more possible traces based on it.
we give the following conditions to construct a partial order required by a feasible trace.
the insight here is to first construct a basic partial order that makes some events ordered.
and then considering the newly ordered events we add new ordering between two events incrementally to meet all the constraints.
given a trace and a feasible event set e e we usepto represent a partial order over ethat makes a trace feasible.
first p to e ensures that every event pair in the same thread is ordered by p. then for every release eventrel lr e ifopnacq e then for each event acq opnacq e andloc acq loc rel we haverel pacq.
it ensures that every open acquire event is the last one that operates the lock.
otherwise the lock will not be released.
finally for every read eventr r e we haveobs r pr.
it ensures that every read event executes after the write event it observes in trace .
we say that such a partial order respects trace and users e to denote the weakest partial order respecting .
the trace respecting partial order poffers basic constraints on execution orders between event pairs required by a feasible trace.
let be a trace e e be a feasible event set and pbe a partial order over ethat respects .
to ensure that the critical sections on the same lock do not overlap for every release event pairrel1 rel lr e letacq match rel1 andacq match rel2 ifacq prel2andloc rel2 loc acq we have rel1 pacq see figure a .
we say that such a partial order islock closed .
to ensure that every read event observes the same event as it does in for every read eventr r e letw obs r and for every write eventw w e w such thatw r we have that i if w pr thenw pw see figure b and ii if w pw thenr pw see figure c .
we say that such a partial order is observation closed .
the two rules make wthe nearest event writing the same variable as rreads.
a partial order is trace closed or simply closed if it is lock closed and observation closed.
we define the closure of pas the weakest partial order p which is closed and refines p. that is p p and there is no closed partial orderqsuch thatp q. ifp does not exist phas no closure.
.
trace construction algorithm algorithm presents the pseudo code of constructing a feasible trace from a feasible event set or deducing its nonexistence.
the inputs include a trace and a feasible event set e e .
we represent a partial order pas a graphgwhere nodes are events 283detecting concurrency vulnerabilities based on partial orders of memory and thread events esec fse august athens greece figure illustrations of lock and observation closed partial orders.
solid arrows are observed execution orders and dashed ones are partial orders added to make a trace closed.
and edges represent their execution orders.
figure shows an example of a partial order graph.
the indices of events in figure represent the execution order in trace i.e.
ifi j ei ej.
the thick arrows throughout the events of each thread are threadorder edges.
initially we construct povere line by connecting every thread s events.
then we insert edges to gto makeplockclosed and observation closed line .
the solid line arrows are observation edges e1 e7 e5 e10 and the dashed ones are lock edges e4 e9 .
if a cycle is formed it means that conflicts occur among the constraints to construct a trace closed partial order.
that is phas no closure and the algorithm returns lines .
note that a closed partial order may still contain unordered conflicting events preventing us from getting a feasible trace.
if we get a closed partial order q for every conflicting event pair we insert an edge between the two events to q. note that after inserting the new edge qmay not be closed see figure .
we need to insert additional edges and get a new closure of q lines .
we make two conflicting events keep their original execution order lines .
the insight here is that it is mostly like to avoid forming a cycle although it may fail in some situations .
if no cycle is formed we build a feasible trace from q. given an event eand a thread i if e e tid e i e qeand e esuch thattid e i e qeande qe thene is a predecessor of ein threadi.
for example as shown in figure the predecessors of e8int1andt2aree1ande7 respectively and e8has no predecessor int3.
initially tis an empty trace.
if an event ehas no predecessor inqor its predecessors are already in t we addeto the new trace tand remove it from e lines .
figure an example of a partial order graph.
solid lines are observation edges and dashed lines are lock edges.algorithm constructfeasibletrace input a trace and a feasible set e output a feasible trace if it exists otherwise 1p rs e 2q getclosure t p e 3ifq then a cycle is formed return 5while e1 e2 es.t.e1 e2ande1 qe2do ife1 tre2then swap e1 e2 8q insertandgetclosure q e e2 ifq then a cycle is formed return 11lettbe an empty list 12while e es.t.ehas no predecessor in qor its predecessors have been added to tdo 13t.append e 14e e e remove e 15returnt vulnerability detection this section describes the approach to construct a feasible trace exposing a concurrency vulnerability.
we first extract vulnerabilitypotential event pairs and then compute their feasible event sets.
then we attempt to construct a feasible trace by algorithm .
.
potential event pairs given a trace and an exchangeable event pair e1 e2 e if e1 e2 tid e1 tid e2 and the exchange of their execution order may cause a vulnerability e.g.
if e1writes a memory address and thene2frees the memory the exchange of their execution may cause an uaf we call them a vulnerability potential event pair or simply potential pair .
the following describes the algorithms to get the potential pairs of uaf npd and df.
.
.
uaf.
a uaf occurs when a block of previously freed memory is used.
figure shows how thread interleaving causes a uaf.
there are two events in figure a .
pointer pis dereferenced first in threadt1and is then freed in threadt2.
if their execution order is exchanged and pis freed first in t2 then an uaf occurs when it is being dereferenced in t1.
figure b shows other cases where a uaf occurs.
there are three events in two threads.
in figure b a pointer is freed first and then a not null value qis written to it at last it is dereferenced .
in this case if p qexecutes after whenpis dereferenced after it is free then an uaf occurs.
note that p qmay also be in other threads making the problem more complex.
for example let p qin threadt1 the original trace is if there is a trace then an uaf occurs.
therefore event pairs in figure a and or in figure b are uaf vulnerability potential pairs.
algorithm shows the pseudo code to get potential event pairs in a trace that may cause uafs.
given a trace and an event e we use the function beforer e i beforew e i beforefree e i 284esec fse august athens greece kunpeng yu chenxu wang yan cai xiapu luo and zijiang yang figure illustrations of how uafs occur.
the gray events are other possible events in different thread.
orbeforederef e i to denote the first read write free ordereference evente beforeethattid e iandloc e loc e .
first for every free event efree free e on a pointer we get the first dereference ederef event before efree on the same pointer in each thread i. if the event exists and i tid efree we add ederef efree to the potential pair set s lines .
then for every dereference eventederef deref e on a pointer and every threadi we get the first write eventwbeforeederef on the same pointer in thread i lines .
if wdoes not write null then for every thread j we get the first free eventej freein the thread that frees the same pointer before wsuch that w w e tid w jandej free w w lines .
if there is no such an eventej freefor every thread j it continues line .
otherwise we add w ederef tosiftid w tid ederef lines .
for every thread jandej free if exists if j tid w we add ej free w tos lines .
.
.
npd.
an npd occurs when a null pointer is dereferenced.
as shown in figure a a pointer pis dereferenced first and then set to be null.
if the execution order of them is exchanged then an npd occurs.
like figure b figure b shows how three events cause an npd.
if the execution order of the two write events is exchanged then an npd occurs.
and if the dereference event executes before the write event that sets pa new value an npd also occurs.
the difference between figure b and b is that the first event in figure b is a free event while in figure b the first event is a write event and assigns null to p. the algorithm that gets potential npd event pairs in a trace is similar to algorithm .
we omit it for space concerns.
.
.
df.
a df occurs when a block of memory is freed twice.
as shown in figure a pointer is assigned with a new value after being freed and then be freed once again .
the exchanges of and may cause an df.
note that the assigning instruction can also be in thread t1 see in figure which make the situation more complex.
algorithm shows the pseudo code to get potential event df event pairs.
for every free eventefree free e on a pointer and every thread i we get the first write eventwon the same pointer before efree in threadi lines .
if wdoes not write null we get the free eventsej free in every thread jthat freesalgorithm getpotentialuaf input a trace output event pairs that may cause uafs 1letsbe an empty set 2foreach free eventefree free e do foreach threadido ifi tid efree then ederef beforederef efree i ifederef then s s ederef efree 8foreach dereference event ederef deref e do foreach threadido 10w beforew loc ederef ederef ifw then ifw.getwritevalue null then continue letfrees be an empty set foreach threadjdo efree beforefree w j ifefree and there is no w w e tid w j efree trw trw then frees frees efree iffrees.isempty then continue iftid w tid ederef then s s w ederef foreachefree frees do iftid efree tid w then s s efree w 24return s figure illustrations of how npds occur.
the gray events are other possible events in different thread.
the same pointer before wsuch that w w e tid w j andej free trw trw lines .
if there is no such an event ej free for every thread j we continue lines .
otherwise we add w efree to the potential pair set sif they are not in the same 285detecting concurrency vulnerabilities based on partial orders of memory and thread events esec fse august athens greece thread lines .
and for every thread jandej free if exists if j tid w then we add ej free w tos lines .
figure illustrations of how dfs occur.
the gray events are other possible events in different thread.
algorithm getpotentialdf input a trace output event pairs that may cause dfs 1letsbe an empty set 2foreach free eventefree free e do foreach threadido 4w beforew efree i ifw then ifw.getwritevalue null then continue letfrees be an empty set foreach threadjdo efree beforefree w j ifefree and there is no w w e tid w j efree trw trw then frees frees efree iffrees.isempty then continue iftid w tid efree then s s w efree foreachefree frees do iftid efree tid w then s s efree w 18return s .
computing feasible event sets given a trace and a potential pair e1 e2 e we first compute a feasible event set of an event pair in different threads.
then we construct a trace in whiche2executes before e1to prove the existence of a vulnerability.
according to previous definitions a feasible event set must be prefix closed lock feasible and observation feasible.
letebe the feasible set we want.
two cases need to be considered for computing a potential pair s feasible set.
if the two events are not protected by the same lock the reordered trace should be ended withe2 e1 i.e.
e1is right behind e2and the trace is like e ... e e1 .
in this case we can easily construct a feasible set e e e2 e1 .
if the two events are protected by the same lock s we cannot put them together at the end of a trace because of the lock semantic i.e.
e1must execute after that all common locks of the two events arereleased by the thread tid e2 .
letlbe the last released common locks rel l be the first release event onlaftere2intid e2 andacq l be the first acquire event onlbeforee1intid e1 the reordered trace is like e ... e ... rel l acq l ... e 1and e e e1 .
note thatedoes not contain e1ande2simultaneously because it may make enot observation feasible.
if we get a feasible trace frome the trace constructed by adding e2 e1ore1to the end of is also feasible.
since there may be several additional events between e2ande1in we need to check whether the vulnerability will occur in at last to avoid false positive errors.
in this paper we first find the candidate feasible event sets of e1 ande2separately and then get their union.
we employ the relative causal cones of an event relative to a thread to compute the feasible set for an event .
relative causal cones given a trace an event pair e1 e2 e lett1 tid e1 andt2 tid e2 the causal cone rcone e1 t2 ofe1relative tot2represents the smallest event set satisfying for each e e ife t1e1 thene rcone e1 t2 .
for every read eventr r e rcone e1 t2 we have obs r rcone e1 t2 .
for every lock acquire event acq la e rcone e1 t2 iftid acq t1andtid acq t2 thenmatch acq rcone e1 t2 .
for every event pair e rcone e1 t2 ande e ife tid e e thene rcone e1 t2 .
rcone e1 t2 is prefix closed and observation feasible but may not be lock feasible there may be open acquires on the same lock int1andt2 .
algorithm shows the computation of a feasible set via relative casual cones.
we first consider the case that two events are not protected by the same lock.
a candidate feasible set ofe1ande2ise rcone e1 t2 rcone e2 t1 line .
rules and ensure that eis prefix closed and observationfeasible.
rule guarantees that there are no two open acquires on the same lock.
note that this rule does not apply for the events int1andt2 becauseeshould only contain events before both e1 ande2.
these rules do not ensure that e2 rcone e1 t2 and e1 rcone e2 t1 .
moreover the union of the two causal cones is not always feasible.
hence we must perform additional checks lines .
if e1ande2are protected by the same lock s let lbe the last released one of the common locks line rel l be the first release event onlaftere2intid e2 line the candidate feasible set is e rcone e1 t2 rcone rel l t1 rel l line10 .
similarly we need to ensure that e1 eandeare feasible lines .
now the feasible event set of the motivating example in figure can be computed as follows rcone e11 t1 e9 e10 rcone e15 t3 e1 e2 e3 e4 e5 e13 e14 and the feasible set e ei i ei i ei i .
implementation figure presents an overview of convulpoe which consists of two components trace recorder and vulnerability predictor.
trace recorder generates execution traces of a program and vulnerability predictor outputs potential vulnerabilities by exploring the traces.
286esec fse august athens greece kunpeng yu chenxu wang yan cai xiapu luo and zijiang yang algorithm getfeasibleset input a trace and two conflicting events e1 e2 e output a feasible event set if exists otherwise 1t1 t2 tid e1 tid e2 2ife1ande2are not protected by the same lock then 3e rcone e1 t2 rcone e2 t1 if e1 e2 e oreis not feasible then return returne 7else letlbe the last lock that is released of the common locks ofe1ande2 letrel l be the first lock release event on laftere2int2 10e rcone e1 t2 rcone rel l t1 rel l ife1 eoreis not feasible then return returne figure an overview of convulpoe .
.
instrumentation and record to record the execution trace we need to instrument the original program.
we employ intel pin which instruments thread operations with posix threading primitives to achieve this goal.
we instrument the malloc andfree functions which is also used in newanddelete operators to record dynamic memory allocation.
the limitation of pin is that it cannot get a pointer dereference directly.
we adopt a heuristic approach which is used in prior work .
a pointer dereference usually consists of two consecutive instructions including a read instruction and a memory access instruction.
the read instruction s operand register is used as the base register of the memory access.
.
vulnerability prediction the vulnerability predictor is independent of the instrumentation.
it finds potential event pairs based on the traces generated by the trace recorder.
we construct a partial order incrementally by inserting new events in an order as the same as they executed.
in practice we also consider other thread related operations and add additional edges in the partial order graph.
for example we insert an edge from every thread create event to the first event in the created thread.
and for every thread join event and the target thread it waits for we insert an edge from the last event in the target thread to the thread join event.
experiments in this section we conduct experiments to evaluate the performance ofconvulpoe and answer the flowing questions rq1 canconvulpoe detect the three kinds of concurrency memory vulnerabilities?
rq2 what is the capability of convulpoe in detecting vulnerabilities in real programs with fuzzing tools?
rq3 how does the number of threads influence convulpoe s detection capability?
.
effectiveness validation we run convulpoe on a cve benchmark to verify its ability to detect vulnerabilities in multi threaded programs.
the dataset is used in convul and contains ten programs which have various vulnerabilities.
these programs reproduce real vulnerabilities in linux and firefox.
we run each program ten times and present the experimental results in table .
the third column presents the times that convulpoe finds a vulnerability and the fourth one shows the number of crashes in the ten runs.
the fifth column shows the causes of vulnerabilities in the programs.
it shows that some of these vulnerabilities are caused by race conditions and some are due to the exchange of critical sections cs .
the results show that convulpoe finds vulnerabilities in eight benchmarks.
convulpoe cannot always detect a vulnerability in every run of a program because it predicts vulnerabilities from a completed trace.
if a trace has no potential pairs convulpoe detects no vulnerabilities.
we can also see that some programs crashed because of the occurrence of vulnerabilities during runtime.
in such cases the predictor component does not work since the trace is not complete.
convulpoe fails to find vulnerabilities for two benchmarks including cve and cve .
an detailed investigation reveals that cve contains an npd vulnerability and cve contains a uaf vulnerability.
the vulnerabilities in both benchmarks occur with totally new execution paths andconvulpoe fails to infer new feasible traces from an observed one.
we present the analyses of the code for both benchmarks in supplemental material due to space limitations.
the results verify that our approach can detect all three kinds of concurrency memory vulnerabilities.
according to the evaluation onconvul other tools such as ufo and threadsanitizer fails to detect most vulnerabilities in the benchmarks.
table experimental results on cve benchmarks cve id cat.
of suc.
of cra.
causes cve npd exchange of cs cve npd exchange of cs cve npd race condition cve npd exchange of cs cve uaf race condition cve uaf race condition cve npd race condition cve df race condition cve uaf race condition cve uaf race condition 287detecting concurrency vulnerabilities based on partial orders of memory and thread events esec fse august athens greece .
detection on real programs in this experiment convulpoe works as a bug oracle from the perspective of fuzzing.
we evaluate the performance of convulpoe with several real multi threaded programs tested by fuzzing tools in prior works .
table shows a summary of the tested programs including four parallel compression decompression utilities lbzip2 pbzip2 pigz and xz two libraries libwebp and libvpx used in popular browsers like chrome and firefox and two video encoders x264 and x265 for h. avc and hevc h. respectively.
all these programs use the native pthread library.
the binary sizes of these programs range from 507k to .27m.
we adopt afl to fuzz these programs for hours with initial seeds provided by muzz to get the inputs for our evaluation.
we do not use muzz for fuzzing since the source code is unavailable.
before our evaluation we use afl cmin to minimize the input files generated by afl.
afl finds no vulnerability in the hours fuzzing.
the fifth column of table shows the number of inputs for these programs in our evaluation.
all inputs are generated by afl except the inputs for x264 and x265.
we use initial seeds as the two programs inputs because there is only one file left with a broken format for each program after minimizing.
the lengths of recorded traces range from hundreds to millions.
we compare with two state of the art detection tools including convul and ufo .convul is implemented as a pin tool based on intel pin.
different from convulpoe convul detects vulnerabilities during runtime.
ufo works similarly to our tool.
it instruments the program records the trace and employs a trace analyzer for vulnerability detection.
ufo s instrumentation is based on the llvm pass which inserts additional code during the compile stage.
although llvm based instrumentation is faster than pin it is more complicated.
we use pin for instrumentation because it is suitable for black box binary only instrumentation.
both convulpoe andconvul can detect uaf npd and df while ufo can only detect uaf.
all experiments are conducted on a server with an intel xeon e5 v4 cpu and 128gb ram.
the operating system is ubuntu .
installed with gcc .
.
afl .57b.
we run these programs five times and report the average.
when we run convul and ufo they cannot complete all the tests for some programs.
when convul analyzes pigz and cwebp it seems to trigger a deadlock and the program is stuck.
ufo sometimes throws an unhandled exception which makes ufo abort.
after finding a uaf ufo is expected to write the relevant information to a file.
but in our evaluation it did not work properly and threw an exception in some cases leading to the stop of the program and the test.
this is the major reason that the tests for lbzip2 and cwebp are not completed.
considering that ufo and convul did not complete some tests of inputs and the numbers of inputs used for different programs are different we use the metric vulnerabilitiesper input for fair comparisons.
table presents the average number of vulnerabilities detected in a single execution of these programs.
they all find the uaf vulnerability in lbzip2.
both convulpoe andconvul find it in every execution.
currently ufo can only find uafs.
it finds .
uaf in one execution on average for lbzip2.
convulpoe find more vulnerabilities on cwebp x264 and x265 than convul and ufo indicating that it can find vulnerabilities that cannot be found by other tools.
however convulpoe also missessome uafs detected by ufo and some dfs detected by convul in pigz.
both convulpoe and ufo miss some uafs detected by convul in vpxdec.
these results indicate that convulpoe is an important complement to existing tools.
table presents the time used by the three detectors.
for convulpoe and ufo the time includes the execution time of an instrumented program and the detection time based on the trace.
ufo consumes the least time on pbzip2 c pbzip2 d xz and vpxdec because it finds no potential uafs and needs no further computations.
although ufo finds more vulnerabilities than convulpoe on pigz it costs more time 98544s vs. 287s .
in general convulpoe can find more vulnerabilities in less time.
for programs such as lbzip2 cwebp x264 and x265 with many potential uafs ufo needs to use z3 for verification which consumes much time to solve constraints.
there usually are hundreds of potential uafs in a single test and the timeout for z3 to solve each potential uaf s constraints is minutes by default.
in most cases z3 reaches the timeout indicating that it usually takes more than one day to check all the potential uafs.
a less timeout will make ufo faster.
however it results in fewer vulnerabilities found by ufo.
that is why ufo cannot complete the whole test in a week for these programs.
compared toconvul convulpoe consumes less time on pbzip2 c pbzip2 d and vpxdec.
for pigz and cwebp convulpoe finds more vulnerabilities in less time.
we also present the average time used by the predictor of convulpoe in parentheses.
the results show that the predictor costs much less time than the recorder to record an execution trace.
detailed investigations reveal that the instrumentation of intel pin is time consuming.
for the programs that convulpoe finds vulnerabilities the time cost by the predictor accounts from to of the total time.
table presents the maximum minimum and average distances of vulnerability potential event pairs in each program s executions.
the distance of an event pair is defined as the absolute difference between the indices of two potential events.
the results show that most vulnerability potential event pairs have very large distances in the traces.
this finding indicates that even long distant event pairs can cause a vulnerability verifying the difficulty of detecting concurrency vulnerabilities.
compared with convul which limits the maximum sync distance of potential event pairs convulpoe detects vulnerabilities without limitations on potential event distances.
it is also the reason why convulpoe finds more vulnerabilities than convul as shown in table .
in summary convulpoe detects more vulnerabilities than other detectors with a competitive time.
although convul and ufo are faster than convulpoe in some cases they are also extremely slow for some programs.
however convulpoe can finish the detection in no more than two days.
therefore convulpoe is an important complement to existing detectors.
the combination of afl with concurrency vulnerabilities detectors also works well.
with the help of these detectors afl can find more vulnerabilities.
.
impacts of number of threads to answer rq3 we evaluate convulpoe on programs running with varying numbers of threads.
in this experiment we chose lbzip2 pigz x264 and x265 for evaluation.
the number of threads 288esec fse august athens greece kunpeng yu chenxu wang yan cai xiapu luo and zijiang yang table a summary of tested programs.
the file in command will be replaced by actual input file.
id program command binary size of inputs ave. length max.
length lbzip2 lbzip2 .
lbzip2 k t z f n4 file 507k pbzip2 c pbzip2 .
.
pbzip2 f k p4 s16 z file 509k pbzip2 d pbzip2 .
.
pbzip2 f k p4 s16 d file 509k pigz pigz .
pigz p c b file 592k xz xz .
.
xz k t f file .1m cwebp libwebp .
.
cwebp mt file o out.webp .5m vpxdec libvpx .
.
vpxdec t o out.y4m file .49m x264 x264 head 59c0609 x264 threads o out.
file .27m x265 x265 .
x265 input file pools f o out.
688k table average number of vulnerabilities detected per input.
the symbol means that the tests are not completed.
id convulpoe convul ufo lbzip2 uaf uaf .
uaf pbzip2 c pbzip2 d pigz .
uaf .
npds .
df .
uafs xz cwebp .
uafs .
uaf vpxdec .
uaf x264 .
npds .
npd x265 .
npds .
uaf table time consumed by different detectors.
the symbol means that the tests either are not completed due to fatal bugs or cannot complete in a week.
id convulpoe s convul s ufo s lbzip2 .
pbzip2 c pbzip2 d pigz .
xz .
cwebp .
vpxdec x264 .
x265 .
table distances of vulnerability potential event pairs.
id max min average lbzip2 .
pigz .
cwebp .
x264 .
x265 .62is set to be and .
other settings are the same as previous.
we run each program five times and report the average results.
figure shows the average number of vulnerabilities that convulpoe finds in a program s single run versus the number of threads.
the average number of uafs found in pigz per run increases from .
to .
.
and .
respectively.
however the average number of npds found in x264 and pigz per run decreases as the number of threads increases.
the number of threads has no impact on the number of vulnerabilities found in lbzip2 and x265.
the results demonstrate that the number of threads has different influences on convulpoe s capability.
on the one hand the probability of finding more potential pairs increases as the number of threads increases.
on the other hand since algorithm always makes unordered conflicting event pairs keep their original execution order it increases the probability of forming a cycle.
if a cycle is formed due to wrong orders we will miss a vulnerability.
thus convulpoe is more likely to miss some vulnerabilities as the number of threads increases.
in summary the number of threads is a double edged sword for convulpoe .
figure average number of vulnerabilities found by convulpoe per input versus the number of threads.
discussion convulpoe works on the traces generated in the executions of a program.
to detect a vulnerability from a trace we must generate a new trace exposing the vulnerability.
we use partial orders to represent the necessary execution orders of events to reduce the search space.
the trace may be very large in some large programs 289detecting concurrency vulnerabilities based on partial orders of memory and thread events esec fse august athens greece consuming a long time to generate a partial order.
in such a case we can divide the trace into multiple parts and detect each part separately.
fuzzing tools like afl also suggest using small input files and simple target binary files .
it suggests detecting on modules of a large program rather than the whole program.
there is also room for future research.
the first is trace reducing.
loop structures are widely used in programs generating many events if they contain some operations in which we are interested.
it is not extendable to record all the events.
the second one is to improve the completeness.
algorithm needs to order the unordered conflicting pairs and avoids forming a cycle.
every ordering inserts a new edge to the partial order graph.
thus a cycle may be formed by different orderings.
for example as described in section .
there may be unordered conflicting event pairs see line of algorithm .
if these conflicts are not resolved properly there may exist edges such as e e e e ande e. our algorithm cannot construct a feasible trace from the partial order graph in these cases and thus misses some vulnerabilities.
that is our algorithm is still incomplete.
it is worth noting that there are no guaranteed methods including ours to find a vulnerability in polynomial time if there is one.
how to improve the completeness of the algorithm is worth further studying.
related work partial order based predictive analysis.
in previous works partial order based prediction is used to detect data races in multithreaded programs.
a data race occurs when two threads access the same data simultaneously and at least one modifies it.
most race detectors employ lamport s happen before hb partial order .
it ensures that the partial order can always generate a feasible trace.
however it is highly incomplete.
causally precedes cp partial order and weakly causallyprecedes wcp partial order are two weaker partial orders based on hb.
they can generate more different traces than hb.
however they are still highly incomplete because they are closed under the composition with hb.
doesn t commute dc is weaker than wcp and can explore more possible execution trace and find more races.
however the constraints of dc are not sufficient to generate a feasible trace.
m2 proposes the trace closed partial order which is weaker and finds more races than dc.
data race detection uses the partial order to determine the concurrency of two events and get a valid trace exposing the data race.
our algorithm is different from existing approaches designed for data race detection .
the key to predicting a vulnerability or a data race from an observed trace is to rearrange the trace to get a new one exposing it.
the new trace must meet several constraints to be feasible.
such an approach is also widely used in prior data race detection work.
our algorithm follows the same procedure but expands it.
first we consider two additional event types including free anddereference to detect memory vulnerabilities.
since both events are read events the new setting is still compatible with the old ones.
second memory vulnerabilities are more complicated than data races and their witness traces are quite different.
a trace exposing a data race only requires that the two events causing a data race are rearranged consecutively e.g.
usually at the end ofthe trace .
however exposing a memory vulnerability is more complicated because not all data races can cause memory vulnerabilities.
for example if two events in different threads are protected by the same lock they cannot cause a data race.
however the execution orders of the critical sections containing the two events may change in some situations and thus cause a memory vulnerability.
concurrency memory vulnerability detection.
programs written in unsafe languages such as c c are prone to memory errors.
uaf npd and df are serious threats to software security.
however it is challenging to find them in multi threaded programs.
ufo is a concurrent uaf detector based on maxmodel which is used to capture a maximal set of feasible traces.
to make the trace feasible it employs a constraint solver to solve the constraints.
convul detects vulnerabilities by judging whether two events are exchangeable based on sync edge and sync distance which is defined by hb.
exceptionull detects npd in concurrent java programs which is also based on constraint solving.
exceptionull adopts a scheme that focuses on a small trace segment to make the constraints simpler.
however it reduces the number of feasible traces and may miss some vulnerabilities.
different from these methods our approach constructs new traces exposing vulnerabilities via partial orders.
it benefits the detection from the following two aspects.
first some events must execute before others to meet these constraints.
it is straightforward to use partial orders to represent such relations between two events.
second we can add new partial order relations via the rules described in section .
.
although a partial order graph meets all the constraints we may fail to get a feasible trace from it directly because there may exist unordered conflicting events.
to solve this difficulty we use a heuristic algorithm that inserts additional edges to the partial order graph to get a feasible trace.
conclusion this paper proposes a new approach for concurrency vulnerability detection based on partial orders.
we propose algorithms to extract vulnerability potential event pairs from an execution trace of a multi threaded program.
a novel algorithm is developed to generate an event pair s feasible set which considers the cases that two events are protected by the same lock.
then we construct partial orders of feasible event sets and generate a feasible trace exposing vulnerabilities.
exploiting partial orders to generate traces reduces the search space of possible executions and improves computational efficiency.
compared to other detectors our method is more theoretically sound and efficient.
we implement a prototype of our method and conduct experiments to evaluate its performance.
experimental results show that convulpoe shows superiority over state of the art tools in both effectiveness and efficiency.