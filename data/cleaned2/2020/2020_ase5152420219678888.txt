smartian enhancing smart contract fuzzing with static and dynamic data flow analyses jaeseung choi kaist jschoi17 kaist.ac.kr gustavo grieco trail of bits gustavo.grieco trailofbits.comdoyeon kim line plus corporation doyeon1017 linecorp.com alex groce northern arizona university alex.groce nau.edusoomin kim kaist soomink kaist.ac.kr sang kil cha kaist sangkilc kaist.ac.kr abstract unlike traditional software smart contracts have the unique organization in which a sequence of transactions shares persistent states.
unfortunately such a characteristic makesit difficult for existing fuzzers to find out critical transactionsequences.
to tackle this challenge we employ both static anddynamic analyses for fuzzing smart contracts.
first we staticallyanalyze smart contract bytecodes to predict which transactionsequences will lead to effective testing and figure out if there is acertain constraint that each transaction should satisfy.
such infor mation is then passed to the fuzzing phase and used to constructan initial seed corpus.
during a fuzzing campaign we perform alightweight dynamic data flow analysis to collect data flow basedfeedback to effectively guide fuzzing.
we implement our ideas ona practical open source fuzzer named s martian .s martian can discover bugs in real world smart contracts without theneed for the source code.
our experimental results show that s martian is more effective than existing state of the art tools in finding known cves from real world contracts.
s martian also outperforms other tools in terms of code coverage.
i. i ntroduction bugs in smart contracts can cause catastrophic failures because smart contracts often handle digital assets worth millions of dollars.
in the notorious dao attack in for example the attacker exploited a reentrancy bug in a smartcontract to steal .
million ether which was worth millionusd at that time.
understandably there has been surging research interest in automatically finding bugs in smart contracts butto our knowledge all the existing tools we found suffer fromone or more of the following issues.
first the tools neglect to emit test cases needed for coverage measurement.
many tools do not produce replayable test cases and output incomplete information about transactions.moreover some tools focus only on bug triggering test casesand ignore test cases that increase coverage.
this makes ithard to quantitatively compare the coverage achievement oftesting tools see ii c .
second research papers in the fielddo not always provide their implementation or publish datasets used in the evaluation.
this problem has been noted in co first authors.
this work was done when the author was at kaist.another recent study .
third many of the tools focus onlyon a small set of bug classes which significantly limits theirusability.
for instance echidna can only detect assertionfailures and check custom properties.
all these observations suggest a need for a practical testing tool that is able to produce replayable test cases publicly available and able to find a set of various bugclasses.
although fuzzing is a plausible technique to achievethese requirements none of the current smart contract fuzzerssatisfies them all.
nevertheless those are not the only requirements there is a critical technical challenge in current fuzzers in handlingstateful transactions.
smart contracts differ from traditionalapplications in that they take in a sequence of transactions asinput while maintaining a persistent state.
the main challenge in smart contract testing is to find a transaction sequence thatcan change the persistent state of the target contract in acritical way.
unfortunately traditional code coverage feedbackmay not be effective enough for identifying such importanttransaction sequences.
that is two transaction sequences mayachieve exactly the same branch coverage although only oneof them can change the persistent state in a meaningful way.
previous fuzzers partly handle this problem either by randomly varying transaction orders or by resort ing to machine learning .
however none of the approachesis deterministic and thus all of them are prone to potentialfailure in detecting crucial transaction sequences.
in this paper we address this challenge by leveraging both static and dynamic analyses on evm bytecode.
the keyintuition is that the significance of transaction sequences canbe determined by the data dependencies between functionsand persistent state variables.
therefore analyzing data flowsof persistent state variables can help in identifying criticaltransaction sequences.
in particular we use both static and dynamic analyses for generating an initial seed pool and evolving the seedpool at runtime.
first we statically analyze the target smartcontracts in the form of raw evm bytecode to figure outmeaningful transaction orders which can effectively modifythe persistent states as well as their sender constraints.
each 36th ieee acm international conference on automated software engineering ase 36th ieee acm international conference on automated software engineering ase .
ieee .
ase51524.
.
.
ieee transaction sequence obtained in this step is deemed to be a useful seed for fuzzing.
note this is a preprocessing step thatruns only once per smart contract.
next we run fuzzing with the initial seeds obtained by the preprocessing step.
however we note that our fuzzer alsoneeds to be able to discern useful transaction sequences atruntime to effectively update the seed pool.
thus we introducedata flow based feedback a novel feedback mechanism thatcarefully monitors dynamic data flows between state variablesduring a fuzzing campaign.
we design and implement s martian an open sourced smart contract fuzzer that can systematically generate criticaltransaction sequences for the smart contract under test withboth static and dynamic analyses.
we evaluated s martian on a benchmark including real world ethereum smartcontracts we collected based on their popularity and size.
s martian outperformed existing tools in terms of both code coverage and bug finding ability.
furthermore we found 211bugs in real world smart contracts.
all these results suggestthat our analyses enable s martian to find bugs in smart contracts effectively.
in summary we make the following contributions.
we propose a novel static analysis technique for generating initial seed pools which is complementary to any existing smart contract fuzzers.
we present data flow based feedback a novel and systematic feedback mechanism for fuzzing smart contracts.
we present s martian a grey box fuzzer for smart contracts which is able to generate replayable testcases open sourced able to detect a superset ofbug classes handled by existing fuzzers and ableto systematically generate critical transaction sequenceswith the help of both static and dynamic analyses.
we make our benchmark public which includes non trivial real world smart contracts.
ii.
b ackground in this section we first introduce basic terms to understand the rest of the paper.
next we summarize classes of well known smart contract bugs.
finally we present a comparativestudy on existing bug finding tools for smart contracts.
a. basic terminologies ethereum is the most popular blockchain based distributed computing platform.
a smart contract is essentially a collection of code and data that is located on the ethereumblockchain.
ethereum virtual machine evm is an executionenvironment for running smart contracts.
generally contractcode is first written in a high level language like solidity but eventually it must be compiled into bytecode to run onevm.
a smart contract maintains storage which is essentially a key value store for holding persistent state variables .
storage is different than memory orstack as its contents are nonvolatile.
to execute a function defined in the contract a userneeds to make a transaction to the contract.
a transaction contains information about a function call such as parametert able i bug classes supported by smartian .
id bug name description af assertion failurethe condition of an assert statement is not satisfied .
aw arbitrarywritean attacker can overwrite arbitrary storage data byaccessing a mismanaged array object .
bd block statedependencyblock states e.g.
timestamp number decide ethertransfer of a contract .
ch control flowhijackan attacker can arbitrarily control the destination ofajump ordelegatecall instruction .
el ether leak a contract allows an arbitrary user to freely retrieve ether from the contract .
fe freezingether a contract can receive ether but does not have anymeans to send out ether .
ib integer bug integer overflows or underflows occur and the result becomes an unexpected value.
me mishandledexceptiona contract does not check for an exception whencalling external functions or sending ether .
ms multiplesenda contract sends out ether multiple times within onetransaction.
this is a specific case of dos .
re reentrancy a function in a victim contract is re entered and leads to a race condition on state variables .
rv requirementviolation the condition of a require statement is not satisfied .
sc suicidalcontractan arbitrary user can destroy a victim contract byrunning a selfdestruct instruction .
to tranasactionorigin usea contract relies on the origin of a transaction i.e.tx.origin for user authorization .
while other bugs deal with safety properties fe concerns a liveness property.
as it is unnatural to find the absence of behavior with testing we make this oracle optional and provide a command line option to enable it.
since the official document recommends to use require for validating program inputs it is debatable whether this is a bug.
thus we make this optional.
values.
both a contract and a user are assigned a unique address and can have a certain amount of digital cash calledether.
a transaction is also used to transfer ether betweencontracts and users.
a deployer is a special user who initially publishes a smart contract on the blockchain network.
typically the address ofthe deployer is saved in the storage during the initialization phase see the example in figure .
the stored address canthen be used to discern between the deployer and regular users.although it is desirable for testing tools to be able to sendtransactions from both deployers and normal users we arenot aware of any existing fuzzer that can systematically select proper users during a fuzzing campaign.
b. smart contract bug classes previous research defines their own bug classes with different terminologies and there is no general consensus among them.
thus we study and summarize them in table i. s mar tian supports the detection of all these bugs see iv c3 .
first we investigated bug classes handled by existing stateof the art fuzzers .
weincluded all the bugs from these fuzzers.
in addition weexamined more previous work on smart contracts and selected bugs that can be detected withoutexcessive false positives.
as a result we identified types of bugs listed in table i. while some papers make finer classifications of bugs we tried 228t able ii comp arison of existing bug finding tools for smart contracts .
tool kindreplayable public available byte bug oracle test caseatool benchmark code af a w bd ch el fe ib me ms re rv sc to madmax static analyzer remix static analyzer sasc static analyzer securify static analyzer slither static analyzer smartcheck static analyzer v andal static analyzer v erismart static analyzer zeus static analyzer maian symbolic executor manticore symbolic executor mythril symbolic executor triangleb osiris symbolic executor oyente symbolic executor scompile symbolic executor ?c teether symbolic executor triangle contractfuzzer fuzzer contramaster fuzzer echidna fuzzer harvey fuzzer ?
ilf fuzzer reguard fuzzer ?
sfuzz fuzzer d smartian fuzzer adoes the tool generate test cases that contain complete information needed to reproduce the transactions enabling the measurement of coverage achievement?
bprints to the terminal only about test cases that trigger bugs and ignore test cases that increase coverage.cwe cannot identify the fact as the tool is not publicly available.
dolder version of sfuzz could generate replayable test cases but this functionality disappeared in the latest version.
to merge closely related bug classes into one.
for instance contractfuzzer distinguishes timestamp dependency and block number dependency but we merge them into block state dependency.
also we consider gasless send as a specific case of mishandled exception.
we note that existing tools implement different bug oracles.
thus in our evaluation we carefully consider this differenceto make fair comparisons see v c .
c. existing tools we studied different tools for finding smart contract bugs and summarized them in table ii.
the third column indicates whether a tool can generate test cases that contain complete information to reproduce the transactions.
while it is natural for static analyzers to notgenerate test cases we found that surprisingly many testingtools do not generate replayable test cases.
some tools such asoyente simply emit terse information about inputs and do notoutput complete data needed to reproduce transactions.
thismakes it infeasible to reproduce bugs found or to measurecoverage achievements.
as a result one can evaluate thetools only by looking at their textual reports which are oftenprone to errors.
for example states that oyente reportsinfeasible paths as feasible.
the fourth and fifth columns respectively represent whether a tool and a benchmark are publicly available.
although it iscrucial to publicize benchmarks for reproducing research only a few of those tools make their benchmarks public.
the sixth column shows whether a tool runs at a bytecode level.
as ethereum deploys smart contracts in the form ofbytecode this enables testing smart contracts in the blockchaineven if the source code is not available.
finally the rest of the columns present bug oracles employed by each tool.
while all the other tools focus on aspecific set of bug oracles s martian handles everything as shown in the table.1contract c state variables in the storage.
address owner uint private statea uint private stateb uint const function c constructor owner msg.sender function f uint x if msg.sender owner statea x function g uint y if statea const stateb y function h if stateb bug fig.
.
example smart contract.
iii.
o verview in this section we first present a motivating example to describe a unique challenge in smart contract fuzzing.
we then briefly describe how s martian addresses this challenge by employing both static and dynamic analyses.
a. motivating example smart contracts impose a unique challenge to fuzzing due to their intrinsic structure where multiple transactions are interconnected to each other with persistent state variables.
consider our motivating example in figure which has the constructor c along with the three functions f g and h. while our system operates on evm bytecode the examplecode is written in solidity for ease of explanation.
the constructor c which simply stores the address of the deployer in the storage runs once when the deployerinstantiates the contract.
this is indeed a commonly found 229pattern as it provides means to distinguish the deployer from regular users.
note that msg.sender is an expression that evaluates to the current sender s address at runtime.
the contract has a bug in h which can be triggered only if stateb is .
for example one can trigger the bug with a transaction sequence .
note that the three transactions should be made in the exact order to triggerthe bug.
moreover fshould be sent by the deployer.
at a first glance the conditions in each function may not seem so hard to satisfy.
for example one can penetratethe condition in line with the probability of by randomly mutating statea.
the condition in line is relatively harder to solve but recent advances in grey boxfuzzing provide practical solutions to it .in our implementation we adopt grey box concolic testingtechnique from eclipser .
however finding this bug is still challenging as we need to generate the transactions in the correct order.
for instance let us assume that we have a sequence as a seed where can be any value.
any mutation attempt on the function arguments will not trigger the bug becausehcannot observe any difference for stateb.
therefore our fuzzer needs to have a transaction sequence such as in the seed pool to find the bug.
one may argue that grey box fuzzers are able to discover such a critical transaction sequence by randomlymutating transaction orders.
however it is not as trivial as it seems.
even if we manage to generate a sequence by randomly trying different transaction orders we cannot realize that this is indeed a meaningful testcase because traditional code coverage is not sensitive enough.
for instance consider two transaction sequences s a and sb which achieve the same branch coverage.
if sbwas already in our test case pool our fuzzer would have no chance to adds ato the seed pool even though it is the critical one.
preliminary experiments despite the simplicity of the example contract in figure none of the existing fuzzersthat we tested was able to find the bug.
specifically we ranthree open sourced smart contract fuzzers echidna ilf andsfuzz for one hour each.
on the other hand s martian was able to find the bug within just a few seconds.
b. our approach to address the aforementioned challenges s martian leverages both static and dynamic analyses.
figure outlines the overall architecture of s martian .
at a high level our system runs in three major steps i nfo ga ther seed pool init and d ata flow fuzz .
info gat h e r first s martian takes in the evm bytecode under test as input and runs a static analysis tocollect useful data flow facts to guide both s eed pool init and d ata flow fuzz .
specifically for each function in the contract s martian figures out which state variables are 1in this paper we interchangeably use the terms transaction sequence test case and seed .evm bytecode 010110110011110101001111000010101static analysis dynamic analysisinfoga ther iv a seedpool init iv b dataflow fuzz iv c bugsfacts sender info.seeds data flo w based feedback fig.
.
s martian architecture.
defined and used by the function and whether the functioncompares the transaction sender address against the deployeraddress.
from our example contract our static analysis willgather the following facts.
statea is defined by fand used by g. stateb is defined by gand used by h. owner is defined by cto be the deployer s address.
owner is used by fto check the transaction sender.
since our analysis directly runs on the low level evm byte code gathering such information is not trivial see iv a .
s eed pool init based on the gathered information smartian predicts which transaction sequences are likely to lead to meaningful exploration and consider them as initialseeds.
specifically s martian realizes that fmust precede gto explore execution paths affected by statea.
similarly it infers that gmust be called before hto change the value ofstateb and explore more paths in h. finally it figures out that fmust be executed by the deployer in order to pass the sender check we identified in the first step.
consequently smartian creates s0 as the initial seed for fuzzing while making sure that the sender of fis the deployer.
the transaction argument is set to by default.
see iv b for the detailed algorithm for seed initialization.
d ata flow fuzz while initializing the seed pool with meaningful transaction sequences can increase the probabilityto find the bug this does not immediately solve the wholechallenge.
ideally we will first randomly mutate the givenseed s 0and obtain a new seed s1 which can reach line .
if we can identify s1as a critical test case we will add it to the test case pool and later applythe aforementioned grey box concolic testing to figure out theproper argument value of gthat triggers the bug see iv c .
unfortunately as we emphasized in iii a we may fail to discern such critical intermediate seeds if we merely employexisting code coverage feedback.
assume that we accidentallygenerated s prior to s1 and added s2 to the test case pool.
this is possible because our fuzzer canrandomly add remove or reorder transaction s from a givenseed.
once s 2is added to the test case pool s1will no longer be considered interesting because it provides no coverage gainover the existing seeds s s2 .
to mitigate this problem we employ a dynamic data flow analysis to collect data flow based feedback.
at a high level 230our approach considers the data flow coverage as fuzzing feedback along with the branch coverage used by eclipser that is we adopt dynamic instrumentation to observe dataflows that occur in the given transaction sequence at runtime and use them as feedback too.
with s there is a data flow from the definition of stateb in line to the use of stateb in line .
however neither s0nors2have this data flow.
based on this we can conclude that s1discovers an interesting program behavior that is not observed in s0nor s2.
we detail our approach in iv c. impact of data flow analyses with the help of both static and dynamic analyses s martian can find the bug from the above example within just five seconds on ourmachine.
meanwhile when we disabled our analyses see v b s martian failed to find the bug in one hour.
c. our contribution over previous work our technical contribution is twofold we are the first in systematically generating seeds for smart contract fuzzing and we use data flow based coverage to effectively guidesmart contract fuzzing.
seed generation previous fuzzers suffer from systematically generating proper transaction sequences.
for instance echidna and sfuzz generate sequences at random.
harvey partly addresses this challenge with runtime heuristics.
first harvey forcefully mutates state variables tofind which functions are affected by them.
it then randomlyprepends other transactions to those functions.
however thismethod is not scalable to complex contracts with a largenumber of functions.
moreover harvey may fail to distinguishconstants e.g.
const in our motivating example from variables and spend its fuzzing budget to change such constants.
ilf generates transaction sequences based on a machine learning model obtained by symbolically executingsmart contracts.
while ilf can potentially find meaningfultransaction sequences via learned models the result is notdeterministic as it is based on statistical reasoning.
moreover our approach is complementary to ilf as we directly analyzethe semantics of the contract to generate seeds.
data flow based feedback the use of data flow graph coverage has been previously studied in data flow testing .however none of the existing fuzzers except contramas ter had employed data flow coverage as fuzzing feedback.while data flow based feedback shares the same key intuitionwith contramaster contramaster uses data flow coverage todecide whether to perform mutation on transaction orders.meanwhile we use the feedback to evaluate the generatedseeds and decide whether to put them in the seed pool.
iv .
d esign this section presents the design details of s martian .
recall from iii s martian operates in three major steps i nfo gat h e r iv a s eed pool init iv b and d ata flow fuzz iv c .a.
information gathering info ga ther info ga ther analyzes the given evm bytecode and returns a tuple angbracketleftfuncs defs uses senderchecks angbracketright where funcs is a set of identified functions.
defs is a map from each identified function to the state variables defined by the function.
uses is a map from each identified function to the state variables used by the function.
senderchecks is a set of functions that includes a sender checking routine.
it starts by constructing a control flow graph cfg from the given evm bytecode.
it internally disassembles evminstructions and lifts them into an intermediate representation ir .
it then runs a constant propagation analysis on the ir tofigure out the destinations of control flow transfer instructions e.g.
jump and identifies functions including constructors.
we note that this step also includes resolving call edges within thecontract to enable an inter procedural analysis.
finally it runsthe main analysis based on abstract interpretation .
our main static analysis computes abstract values stored in the stack and the memory in a flow and context sensitivemanner .
tracking stack values is important because evmis a stack based machine that pushes instruction operands tothe stack .
following memory values is also criticalbecause these operands are often loaded from the memory too.our ultimate goal here is to figure out which state variablesare defined and used by each function.
to distinguish whichstate variable is used or defined we check which value isused as a key for sload orsstore instruction.
to approximate values we use a product domain that entails three different domains.
first we employ the liftedinteger domain to trace constants.
this is because smartcontracts use a hard coded unique constant as a key to accessstate variables of primitive data types e.g.
uint.
second we use a variation of the lifted integer domain to abstractthe output of hash instruction sha3.
this is because smart contracts access state variables of compound data types e.g.
mapping through a computed hash value as a key.
with bothdomains we can track which specific state variable is accessedfor every program point and thus can update both defs and uses accordingly.
the last component of the product domain is the taint domain for tracking the flow of the deployer s address recallfrom iii b .
with this domain we compute senderchecks by analyzing the following two conditions.
first we check ifthe constructor of a smart contract saves the deployer s addressinto the storage.
second we see if a sender s address whichis returned by a caller instruction flows into a conditional branch and gets compared with the deployer s address.
noteboth flows can be easily tracked with traditional static taintanalysis.
if both conditions hold then we put the functioncontaining the conditional into senderchecks.
231algorithm deriving function call orders.
1function gensequences funcs defs uses seqs works initworks f funcs defs f negationslash while works negationslash do s works.pop nogain true for finfuncs do ifdataflowgain s defs uses then works.push s nogain false ifnogain then seqs seqs s return seqs b. seed pool initialization seed pool init to generate initial seeds s martian first derives useful function call orders based on the information gathered from info gat h e r and then generates concrete transaction sequences based on the orders.
deriving useful call orders algorithm illustrates the decision of function call orders.
it takes in as input funcs defs and uses obtained from i nfo gat h e r and outputs a set of function sequences.
in line we initialize the worklist works with singleton sequences containing each function in funcs.
we ignore functions that do not define any state variable as they cannot affect the persistent state.
next we pull a sequence sout of the worklist line and creates new sequences by appendingeach function in funcs tos.
we then examine each of the generated sequences with dataflowgain to decide which sequence covers previously unseen data flows line .line pushes such sequences to the worklist and internallyremoves redundant entries for greater efficiency.
specifically dataflowgain statically approximates function level data flows by collecting triples angbracketleftf v f angbracketrightfrom a given sequence where f1and f2are functions that appear in the sequence f1defines v and f2uses that v. it returns true if a previously unseen triple is found from the sequence.
we repeatedly extend sequences in the worklist as long as a new data flow is observed.
if a sequence produces no gainby extending it we finalize the sequence by adding it to theoutput set line .
generating seeds we now turn the generated function sequences into transaction sequences by concretizing theircontents which works mainly in two steps.
first for every function in each transaction we decide whether each function belongs to senderchecks.
if so we set the sender of the transaction as the deployer.
otherwise we randomly choose the sender either deployer or a user .
second we need to initialize the function arguments of each transaction.
here we consider the amount of ether totransfer as an additional argument too.
s martian internally represents each argument as a byte stream.
when the targetcontract ships with its abi specification we leverage it toset the argument types as well as the length of the bytestreams accordingly.
when the abi specification does notexist s martian will simply set the length of each byte stream to a predefined maximum value.
correctly inferringdata types of function arguments in the absence of abi isbeyond the scope of this paper and we leave it as future work.
c. data flow based fuzzing d ata flow fuzz with the generated initial seed pool s martian iteratively selects one and mutates it to generate new test cases iv c1 .
smartian then evaluates the usefulness of the newly generated test cases by running the smart contract under test with each test case iv c2 .
during each execution our bugoracles check whether it is buggy iv c3 .
mutation methodologies s martian employs two complementary strategies for mutating seeds.
one is randommutation and the other is grey box concolic testing from .
s martian alternates between them to achieve synergy.
first our random mutation strategy runs at both the sequence level and the transaction level.
sequence level mutationconsists of the following operations inserting a newtransaction for a random function removing a randomtransaction and swapping two random transactions.
wheninserting a transaction we refer to senderchecks gathered from the static analysis and use it to decide the sender as in iv b. transaction level mutation mainly modifies argumentsof each transaction.
we leverage classic mutation operatorswidely used in grey box fuzzers such as bit flipping muta tion .
besides we randomly mutate the sender of thetransaction too.
however it is well known that random mutation can easily get stuck on conditional branches such as magic valuechecks .
eclipser addresses this challengeby introducing the grey box concolic testing technique which operates similarly to traditional concolic testing butwithout smt solving or expensive extra instrumentation.
data flow based feedback recall from iii a previous code coverage feedback is not enough to discern interest ing seeds during a fuzzing campaign.
to overcome this s martian introduces data flow based feedback in addition to the traditional code coverage feedback.
that is s martian considers a seed as interesting when it exhibits a previouslyunseen data flow or covers previously unvisited code.
to collect data flows we dynamically instrument the evm bytecode by modifying an evm emulator in order to monitorthe storage accesses during the execution.
particularly we capture a dynamic data flow with a def use chain.
let p 1v p2 be a def use chain over a state variable vdefined in a program point p1 and used in a program point p2.
we can then represent def use chains from the example in figure as follows.
sayields def use chains 12statea 15and16stateb while sbonly yields 12statea .
therefore s martian can recognize that saexhibits an interesting program behavior not presented by sb.
in the actual implementation we use an 232instruction address as a program point pi and use the key of the storage as a state variable v. recall that we also check for data flows during the seed pool initialization in iv b. note that in algorithm we statically approximated the data flows at the function level.
meanwhile in fuzzing we trace data flows that actually take place andcalculate them at instruction level granularity.
that is we firststatically analyze data flows to decide promising transactionsequences that are likely to reveal more dynamic data flowsduring the fuzzing.
then we employ concrete and more fine grained data flows as feedback at the fuzzing phase.
bug oracles here we summarize our bug oracle implementation for classes of bugs supported by s martian .
again we modify the evm emulator to implement these bugoracles.
thus our runtime instrumentation is responsible forboth collecting data flow based feedback and detecting bugsduring the execution.
af at the bytecode level an assertion failure correspondsto the execution of an invalid instruction.
therefore we can precisely detect af by checking if an invalid instruction is executed.
we note that compilers alsoautomatically insert assert statements to prevent errors such as division by zero.
we consider the failures fromthese compiler inserted assertions as af too.
bd we leverage dynamic taint analysis to check if a blockstate can affect an ether transfer.
we trace both directand indirect taint flows for this.
we first taint the returnsof instructions that acquire the state of a block e.g.timestamp number .
then we monitor if the tainted value flows into the operands of a call orjumpi.
ch first we raise an alarm if a normal user can set thedestination contract of a delegatecall into an arbitrary user contract.
second we also report an alarm ifthe destination of a jump instruction is manipulatable.
el we employ an oracle similar to that of mythril which checks if a normal user can gain ether by sendingtransactions to the contract.
however this is prone to falsepositives because some contracts allow the deployer tohand over the ownership of the contract to another user.in such contracts it is an intended behavior that a usercan withdraw the contract s balance when the deployerallows to.
to avoid such false positives we report alarmsonly when the transaction sequence does not have anypreceding transaction from the deployer.
ib we monitor add sub mul instructions to check if they cause an integer over underflow.
if so we taint theresulting value and perform a dynamic taint analysis tocheck whether the tainted value is used to determine theamount of ether to transfer or is used to update the statevariables.
this is to avoid raising alarms on benign integerover underflows.
for example without this taint analysis we will raise an alarm on a safe code snippet if x y x revert .
me we run a taint analysis to make sure that the return valueof acall instruction flows into a predicate of a jumpi instruction.
if there is a return value that is not used byajumpi we report an alarm.
ms we detect multiple ether transfers taking place in a singletransaction.
re we first monitor if there is a cyclic call chain duringan ether transfer as contractfuzzer or sfuzz does.
in addition we use taint analysis to identify statevariables that affect this ether transfer similarly to as wedid for bd.
then we report re if such variables are updated after the transfer takes place.
rv we check for the execution of a revert instruction which corresponds to a requirement violation.
sc we check if a normal user can execute selfdestruct instruction and destroy the contract.
similarly to el we reduce false positives by filtering out test cases thathave any preceding transaction from the deployer in thesequence.
to we taint the return value of origin instruction and check if it flows into the predicate of a jumpi instruction.
for the rest of the bug classes we implemented the same bug oracle as contractfuzzer fe and harvey aw .
d. implementation to implement our static analyzer we used b2r2 as a front end to parse and disassemble evm bytecode.
themain logic of static analysis iv a is written in source lines of f code.
the fuzzing component of s mar tian iv c1 is implemented by extending eclipser to operate with evm and transaction sequences and is composedof source lines of f code.
we used nethermindevm for deploying contracts and emulating transactionswith dynamic instrumentation.
specifically we added 979lines of c code to nethermind to implement data flow based feedback iv c2 as well as our bug oracles iv c3 .we make all our source code and benchmarks public at v. e v alua tion in this section we answer the following research questions.
rq1.
can our analyses improve the fuzzing effectiveness of s martian ?
v b rq2.
can s martian find known bugs more effectively compared to existing state of the art tools?
v c rq3.
how does s martian perform on a large scale benchmark?
v d a. experimental setup our environment we ran all our experiments on an ubuntu .
server machine equipped with two intel e5 v4 .
ghz cpus and gb of main memory.
we useddocker .
.
for our experiments and used one containerto run a tool on a single contract.
we spawned at most 72containers in parallel and assigned a single cpu core and 6gb of memory to each container.
to compile contracts weusedsolc .
.
.
233t able iii benchmarks used .
id source used foravg.
sd num.
of sloc sloc contracts b1 v erismart rq1 rq2 b2 smartbug rq2 b3 etherscan rq3 standard deviation.
comparison t argets we selected two fuzzers and two symbolic executors as our comparison targets.
to select fuzzers we first filtered open sourced fuzzers that are pub lished in top conferences and obtained contractfuzzer ilf and sfuzz.
we chose ilf and sfuzz over contractfuzzer since the two tools respectively outperformed contractfuzzerin their experiments .
to select symbolic executors we initially applied the same criteria and obtained oyenteand teether as a result.
however we found that oyentereports unfeasible paths as executable according to .
also teether supports only a small set of bug classes making thecomparison against sfuzz difficult.
thus we chose mythriland manticore instead as they support various bug classes.
for each of the selected tools we added functionality to emit replayable test cases if the tool does not already haveit.
also we modified their code to save all the test cases thatincrease code coverage.
we publicize the modified versions ofthe tools in github.
benchmarks we used three distinct benchmarks for our experiments.
table iii summarizes them.
we make thesebenchmarks public as well in order to support open science.
b1.
first we used the benchmark from v erismart which consists of real world contracts.
each of the contracts is assigned a cve for an integer bug ib .
note that theauthors of v erismart originally collected contracts butthey confirmed that two of the cves were not real bugs.
b2.
while b1 is a realistic benchmark with known vulnerabilities all the assigned cves are for ib.
thus we constructed b2 that contains more bug classes by extracting contracts from smartbug .
in particular we imported contracts that have block state dependency bd mishandled exception me or reentrancy re asthese bug classes are supported by all of our comparisontargets v a2 .
then we performed preprocessing suchas filtering out contracts that have any argument in theconstructor.
this is because some of the tools we selectedfor comparison did not run properly on such contracts.
asa result we obtained a total of contracts that contain13bd me and re.
note that a single contract can have multiple classes of bugs here.
b3.
this benchmark comprises popular and complex smart contracts obtained from etherscan which isan online platform that provides code and statistics ofethereum smart contracts.
we first downloaded contractsthat have more than transactions and filtered outcontracts that do not compile with the solc version01020304050 time min.
total of cves foundw static dynamic analyses w static analysis onlyw dynamic analysis onlyw o any analysis fig.
.
impact of our data flow analyses on b1.
we used.
then we filtered out contracts that have any constructor argument to make the benchmark usableby as many tools as possible.
finally we sorted theremaining contracts based on their bytecode size andselected the largest contracts in order to gather bothpopular and complex contracts.
b. impact of our analyses do our analyses help s martian find bugs more effectively?
how much overhead do they introduce?
we answerthese questions by comparing the effectiveness of s martian onb1 with and without our analyses.
we used b1 here because each contract in the benchmark contains a previously knownbug which serves as ground truth for our evaluation.
also allthe contracts in b1 are real world contracts whereas some of the contracts in b2 are artificially created toy programs.
to assess the impact of both static iv a and dynamic iv c analyses we ran s martian in four different modes with both of the analyses only with the static analysis only with the dynamic analysis and without anyanalysis.
we ran with each mode for one hour on b1 and repeated the experiment for five times.
impact on bug finding we first measured the impact of our analyses in terms of bug finding.
we say our tool found theground truth bug in each contract if it can pinpoint the exactprogram point for the assigned cve.
this is important becauseeach contract may also have integer overflows or underflowsthat are irrelevant to the assigned cve.
moreover some ofthem can be benign as we discussed in iv c3.
figure compares the number of unique bugs found over time with the four different modes.
we note that there is asignificant difference in finding deep bugs at the later stage offuzzing.
on average we were able to find about moreunique bugs with our analyses than without them p value .
from mann whitney u test .
this result confirms that there are real world smart contract bugs which can only befound by considering stateful transaction sequences and ouranalyses indeed help in finding them.
impact on code coverage we also measured the number of executed instructions with and without using ouranalyses.
as a result we found that turning on both static anddynamic analyses helped in covering more instructions 234smartian sfuzz manticore mythril time min.
total of cves found 0k20k40k60k80k100k time min instruction coverage fig.
.
comparison against state of the art tools on the subset of b1.
on average.
while the coverage gap is not significant recall that there was a significant difference in the number of bugsfound.
this observation aligns with the key motivation of ourwork while the traditional code coverage feedback can beeffective in guiding fuzzers to increase coverage it may notbe enough to trigger bugs when a stateful transaction sequenceis required.
overhead of our analyses we also evaluated how much overhead is imposed by applying our analyses.
forthe contracts in b1 the static analysis took less than two seconds on average and took five seconds in the worst case.this is indeed a negligible overhead for fuzzing.
we alsomeasured the overhead of our dynamic data flow analysis i.e.
data flow based feedback.
specifically we collected test casesgenerated from our previous experiments and replayed themwith and without the data flow based feedback computation.as a result we observed that computing data flow based feed back incurred only .
overhead in terms of execution time.thus we conclude that our analyses incur reasonably smalloverhead and despite the overhead they allow s martian to find more bugs and to achieve more coverage.
answer to rq1.
both static and dynamic analyses can effectively guide fuzzing to find more bugs.
when usedtogether the analyses enable s martian to find more bugs in our benchmark.
c. comparison against existing tools next we compare s martian against state of the art tools that we selected in v a2.
for this we measured the bug finding effectiveness as well as coverage achievement of eachtool.
to measure coverage achievement we replayed the testcases generated by each tool.
recall from v a2 that wemodified the tools to emit all the test cases that can increasecoverage in a replayable format.
comparison on b1 we first compare s martian with other testing tools on b1.
as we mentioned in v a some of our comparison targets did not properly operate on contractswith constructor arguments.
therefore we excluded suchcontracts and obtained a subset of b1 which comprises contracts.
we ran the tools for one hour on each contract andrepeated the experiment five times to compute the average.
tomeasure the bug finding effectiveness we counted the numberof ground truth bugs found by each tool.
as in v b wechecked whether the tool can report the exact program pointthat corresponds to the cve assigned for an integer bug ib .
figure shows the comparison result between s martian and other tools.
the left hand side plot presents the numberof cves found over time whereas the right hand side plotpresents the instruction coverage over time.
note that ilf isnot included in this comparison because it does not supportthe detection of ib see table ii .
as the figure indicates s martian constantly outperformed other tools in terms of bug finding effectiveness.
s martian found .
.
and .
more ground truth bugs cves than sfuzz manticore and mythril respectively.
this resultwas consistent over the five times of repeated experiments p value .
from mann whitney u test for all the tools .
moreover there was only one bug that s martian missed but one of the other tools could find.
also s martian covered more instructions than other tools throughout the whole fuzzing campaign.
s martian covered .
.
and .
more instructions than sfuzz manticore and mythril respectively.
while mythril was theclosest to s martian in terms of code coverage it still found significantly fewer bugs than s martian .
this implies that mythril failed to modify the state variables in a critical waywhile it was able to cover enough code.
difference in bug oracles.
as we discussed in ii b each tool implements its own oracle for the same bug class.this may affect the bug finding effectiveness of each tool.for instance sfuzz only monitors additions and subtractionsto detect integer overflows and ignores multiplications.
thismakes sfuzz prone to false negatives.
to tackle this problem we ran additional experiments by modifying s martian to have the same oracle logic with the comparison target.
for example we replaced our ib oracle with the oracle of sfuzz and then compared the modified smartian against sfuzz.
this way we can compare the bugfinding effectiveness of each tool without being affected bythe inconsistency of oracles.
it turned out that s martian outperforms other tools even after aligning the iboracle with them.
s martian still found .
.
and .
more cves than sfuzz manticore and mythril respectively.
we further investigated the result to compare the bug oracles.
first when we replaced our bug oracle with the oracleof sfuzz and manticore s martian found and fewer cves.
when we modified s martian s oracle to match with that of mythril s martian found more cves but it raised more alarms instead.
thus we conclude that ourib oracle in iv c3 is most appropriate for this benchmark.
comparison on b2 we now compare our system against other tools on b2 which we constructed from smartbug benchmark .
we selected contracts that were labeled withblock state dependency bd mishandled exception me or reentrancy re .
however we found that the labels wereincomplete for some of the contracts.
for instance a contract 235smartian sfuzz manticore mythril ilf time min.
total of bugs found 0k10k20k30k40k50k60k time min instruction coverage fig.
.
comparison against state of the art tools on b2.
t able iv number of tp and fp alarms raised by each tool on b2.
bug idsmartian ilf sfuzz manticore mythril tp fp tp fp tp fp tp fp tp fp bd me re that was classified to have me often contained re as well.
thus we manually investigated the contracts and labeled them again.
then we ran each tool for one hour on each of thecontracts in b2.
to measure the bug finding effectiveness we checked whether the tool can report the bugs labeled on eachcontract.
figure illustrates the result of this comparison.
we present the number of bugs found over time on the left side andinstruction coverage over time on the right side.
the resultsare averaged over five times of repeated experiments.
the figure shows that s martian is able to find more bugs than other tools.
when compared to fuzzers s martian found .
and .
more bugs than ilf and sfuzz respectively.
smartian also outperformed symbolic executors by finding .
and .
more bugs than manticore and mythril respectively.
the result was consistent over the five repetitions p value .01from mann whitney u test for all the tools .
in addition there were only two bugs that were missed by s martian but found by any other tool.
moreover s martian constantly covered more instructions than other tools too.
in particular s martian covered respectively .
and .
more instructions than ilf and sfuzz.
also it covered .
more instructions than manticore and .
more instructions than mythril.
we also count the number of false positive alarms raised by each tool and summarize them in table iv along with thenumber of found bugs i.e.
true positives .
the table showsthat s martian not only has the highest recall but it also has the highest precision for this benchmark.
especially othertools suffered from a high false positive rate for re bugs.
this is mainly because these tools do not properly considerthe storage access pattern of the target contract and simplyt able v number of bugs found by smartian on b3.
bug id description of bugs reported tp fp aw arbitrary write bd block state dependency ch control hijack el ether leak ib integer bug me mishandled exception ms multiple send re reentrancy sc suicidal contract to transaction origin use total check whether there is a call to an external contract.
difference in bug oracles.
again we reimplemented the bug oracles of s martian to match with other tools oracles to compare the bug finding effectiveness under thesame condition.
in particular we modified our bd me and re oracles to align with those of other tools.
s martian still prevailed other tools after the alignment of the oracles.
themodified s martian found .
more bugs than ilf and .
more bugs than sfuzz.
also it found .
more bugs than manticore and .
more bugs than mythril.
answer to rq2.
smartian is more effective in finding bugs compared to existing state of the art tools.
s martian finds .
.
more bugs than our comparison targets.
d. large scale study now that we have evaluated the comparative performance of smartian we now turn our attention to the scalability of our system.
specifically we ran s martian onb3 which consists of popular and large contracts we gathered from etherscan see v a3 .
we ran s martian on each contract for one hour and manually investigated the reported alarms to classify theminto true and false alarms.
we did not include other tools in thisexperiment because implementing other tools bug oracles in s martian as we did in v c requires significant engineering effort.
instead we focus on the scalability of s martian here.
table v summarizes the result.
note that we do not report fe and rv here for the reasons we discussed in table i. in addition we also omit af found by s martian .
while smartian found hundreds of true positive af it is debatable whether they can be considered as serious bugs so we do notinclude af in the table.
after excluding these bug classes s martian reported a total of bug alarms.
out of the contracts contracts were flagged to have at least one ofthese alarms.
we manually inspected the alarms and confirmedthat .
of them were true positives.
recall from iv c3 this was possible because s martian employs precise bug oracles to reduce false alarms.
we confirmed that some of the bugs found by s martian had similar patterns to the cves in b1.
some of the bugs could even cause contract users or owners to unexpectedly losetheir assets.
we also found that most of the bugs were causedby poor software engineering practices.
thus we conclude 236that s martian can indeed find meaningful bugs in real world smart contracts.
answer to rq3.
smartian is effective in finding various kinds of bugs from a large scale benchmark.
s martian could find bugs from complex real world contracts we collected.
e. threats to v alidity first we performed our experiments on a limited set of benchmarks.
we used two benchmarks b1 and b2 containing known bugs and another benchmark b3 that consists of largeand popular real world contracts.
we showed the effectivenessof our system on these benchmarks but other benchmarksmay yield different results.
we open source our code so that s martian can be further evaluated in other work.
another threat to validity is related to the manual processes included in our evaluation.
for instance we manually labeledbugs to each contract in b2 and manually classified the alarms that s martian reported from the contracts in b3.
although we tried our best to carefully inspect the contract code wemight have erroneously concluded whether the bug indeedexists or not.
we also make our dataset public to enable cross checks from other researchers.
vi.
d iscussion due to the over approximating nature of static analysis data flow facts gathered from our i nfo ga ther step iv a may contain spurious data flows that cannot actually occur inruntime.
if such false positives are prevalent in the analysisresult our static analysis may even degrade the fuzzing per formance.
however the evaluation in v b empirically showsthat our analysis is precise enough to guide fuzzing effectively.in the future we may further improve the static analysisprecision and study how it affects the fuzzing effectiveness.
s martian currently inherits the limitations of eclipser such as lack of handling non linear branch conditions.
adopt ing other grey box technologies and recent advances in thefield such as to complement s martian would be a promising direction for future research.
although s martian is specifically designed for fuzzing smart contracts we believe the idea of leveraging data flowanalyses in fuzzing can be applied to other areas as well.
forinstance generating the sequence of system calls is a criticalproblem in kernel fuzzing .
we leave it as futurework to apply our idea to other domains.
vii.
r ela ted work fuzzing has become a de facto standard technique for finding security bugs and there has beensignificant research effort on adopting fuzzing in the domainof smart contracts too.
recall from iii c our contributionis unique in that we are the first in adopting both staticand dynamic analyses to systematically deal with statefultransactions of smart contracts for fuzzing.
contractfuzzer is the first academically developed fuzzer for smart contracts.
since it is a black box fuzzer ithas difficulties achieving high code coverage.
echidna checks a set of user defined invariant rules to detect bugs.
ananalyst should embed these rules within the contract sourcecode itself.
on the other hand s martian does not require any human intervention.
harvey is a commercial closed source fuzzer.
it employs a heuristic referred to as the aggressive mode whichdirectly mutates state variables to figure out the dependenciesbetween functions.
in contrast s martian systematically addresses this by statically analyzing the semantics of code.
thesame authors recently enhanced harvey by employing a staticanalyzer called bran which can guide grey box fuzzingtowards target locations.
bran is orthogonal to our work and s martian can also benefit from it.
sfuzz incorporates afl with the idea of branch distance feedback used in search based testing in orderto explore hard to reach branches.
however sfuzz does notdirectly handle the stateful transaction problem we address inthis paper.
ilf leverages machine learning to effectively gen erate transaction sequences.
it is orthogonal to our technique and our analysis can complement ilf too.
there are several fuzzers outside the domain of smart contracts which utilize data flow analysis to figure out which input bytes need to be mutated orwhich values should be used for the mutation.
our work isorthogonal to them as we are using data flow information tofind meaningful transaction sequence orders.
viii.
c onclusion we studied the current limitation of smart contract testing tools and identified several design and technical issues.specifically we tackled the problem of effectively handlingmultiple stateful transactions of smart contracts which leads tothe introduction of combined static and dynamic analysis tech niques for generating seeds and updating the seed pool duringa fuzzing campaign.
our study showed that the proposedtechniques incur negligible overhead while enabling effectivefuzzing in terms of both code coverage and bug finding.we also compared s martian against the various state ofthe art testing tools on a carefully designed benchmark andconfirmed the effectiveness of it.
we publicize both our tooland benchmarks to boost future research.
a cknowledgement we thank the anonymous reviewers for their valuable comments and suggestions.
we also thank josselin feist andfelipe manzano for their helpful advice on smart contracttesting.
this work was supported by institute of information communications technology planning evaluation iitp grant funded by the korea government msit no.
developing next generation binary decompiler .
r eferences arbitrary jump with function type variable swc .
assertion failure authorization through tx.origin decentralized application security project dos with failed call etherscan nethermind requirement violation smart contract weakness classification registry solidity documentation solidity expressions and control structures org en v0.
.
control structures.html.
write to arbitrary storage location swc .
c. aschermann s. schumilo t. blazytko r. gawlik and t. holz redqueen fuzzing with input to state correspondence in proceedings of the network and distributed system security symposium .
m. b ohme v .
j. m. man es and s. k. cha boosting fuzzer efficiency an information theoretic perspective in proceedings of the international symposium on f oundations of software engineering pp.
.
l. brent a. jurisevic m. kong e. liu f. gauthier v .
gramoli r. holz and b. scholz v andal a scalable security analysis framework for smartcontracts .
j. chang b. gao h. xiao j. sun y .
cai and z. y ang scompile critical path identification and analysis for smart contracts in proceedings of the international conference on f ormal engineering methods pp.
.
h. chen y .
xue y .
li b. chen x. xie x. wu and y .
liu hawkeye towards a desired directed grey box fuzzer in proceedings of the acm conference on computer and communications security pp.
.
p .
chen and h. chen angora efficient fuzzing by principled search inproceedings of the ieee symposium on security and privacy pp.
.
j. choi j. jang c. han and s. k. cha eclipser softsec kaist eclipser .
grey box concolic testing on binary code in proceedings of the international conference on software engineering pp.
.
j. choi k. kim d. lee and s. k. cha ntfuzz enabling type aware kernel fuzzing on windows with static binary analysis in proceedings of the ieee symposium on security and privacy pp.
.
p .
cousot and r. cousot abstract interpretation a unified lattice model for static analysis of programs by construction or approximationof fixpoints in proceedings of the acm symposium on principles of programming languages pp.
.
p .
daian analysis of the dao exploit analysis of the dao exploit .
m. di angelo and g. salzer a survey of tools for analyzing ethereum smart contracts in proceedings of the ieee international conference on decentralized applications and infrastructures pp.
.
t. durieux j. f. ferreira r. abreu and p .
cruz empirical review of automated analysis tools on ethereum smart contracts inproceedings of the international conference on software engineering pp.
.
ethereum ethereum whitepaper j. feist g. grieco and a. groce slither a static analysis framework for smart contracts in proceedings of the international workshop on emerging trends in software engineering for blockchain pp.
.
s. gan c. zhang p .
chen b. zhao x. qin d. wu and z. chen greyone data flow sensitive fuzzing in proceedings of the usenix security symposium pp.
.
p .
godefroid n. klarlund and k. sen dart directed automated random testing in proceedings of the acm conference on programming language design and implementation pp.
.
n. grech m. kong a. jurisevic l. brent b. scholz and y .
smaragdakis madmax surviving out of gas conditions in ethereum smartcontracts in proceedings of the acm sigplan international conference on object oriented programming systems languages appli cations pp.
.
g. grieco w .
song a. cygan j. feist and a. groce echidna effective usable and fast fuzzing for smart contracts in proceedings of the international symposium on software testing and analysis pp.
.
a. groce j. feist g. grieco and m. colburn what are the actual flaws in important smart contracts and how can we find them ?
ininternational conference on financial cryptography and data security .
h. han and s. k. cha imf inferred model based fuzzer in proceedings of the acm conference on computer and communications security pp.
.
h. han d. oh and s. k. cha codealchemist semantics aware code generation to find vulnerabilities in javascript engines in proceedings of the network and distributed system security symposium .
j. he m. balunovi c n. ambroladze p .
tsankov and m. v echev learning to fuzz from symbolic execution with application to smartcontracts in proceedings of the acm conference on computer and communications security pp.
.
b. jiang y .
liu and w .
k. chan contractfuzzer fuzzing smart contracts for vulnerability detection in proceedings of the international conference on automated software engineering pp.
.
m. jung s. kim h. han j. choi and s. k. cha b2r2 building an efficient front end for binary analysis in proceedings of the ndss workshop on binary analysis research .
s. kalra s. goel m. dhawan and s. sharma zeus analyzing safety of smart contracts in proceedings of the network and distributed system security symposium .
j. krupp and c. rossow teether gnawing at ethereum to automatically exploit smart contracts in proceedings of the usenix security symposium pp.
.
c. lemieux and k. sen fairfuzz a targeted mutation strategy for increasing greybox fuzz testing coverage in proceedings of the international conference on automated software engineering pp.
.
y .
li b. chen m. chandramohan s. w .
lin y .
liu and a. tiu steelix program state based binary fuzzing in proceedings of the international symposium on f oundations of software engineering pp.
.
y .
li y .
xue h. chen x. wu c. zhang x. xie h. wang and y .
liu cerebro context aware adaptive fuzzing for effective vulnerability de tection in proceedings of the international symposium on f oundations of software engineering pp.
.
c. liu h. liu z. cao z. chen b. chen and a. w .
roscoe reguard finding reentrancy bugs in smart contracts in proceedings of the international conference on software engineering companion icse companion pp.
.
l. luu d. h. chu h. olickel p .
saxena and a. hobor making smart contracts smarter in proceedings of the acm conference on computer and communications security pp.
.
v .
j. m. man es h. han c. han s. k. cha m. egele e. j. schwartz and m. woo the art science and engineering of fuzzing a survey ieee transactions on software engineering .
v .
j. m. man es s. kim and s. k. cha ankou guiding greybox fuzzing towards combinatorial difference in proceedings of the international conference on software engineering pp.
.
b. mathis r. gopinath and a. zeller learning input tokens for effective fuzzing in proceedings of the international symposium on software testing and analysis pp.
.
p .
mcminn search based software test data generation a survey software testing v erification and reliability vol.
no.
pp.
.
a. m ller and m. i. schwartzbach static program analysis amoeller spa .
m. mossberg f. manzano e. hennenfent a. groce g. grieco j. feist t. brunson and a. dinaburg manticore a user friendly symbolicexecution framework for binaries and smart contracts in proceedings of the international conference on automated software engineering pp.
.
l. d. moura and n. bj rner satisfiability modulo theories introduction and applications communications of the acm vol.
no.
pp.
.
b. mueller smashing ethereum smart contracts for fun and actual profit in proceedings of the hitb security conference .
t. d. nguyen l. h. pham j. sun y .
lin and q. t. minh sfuzz an efficient adaptive fuzzer for solidity smart contracts in proceedings of the international conference on software engineering pp.
.
i. nikoliundefined a. kolluri i. sergey p .
saxena and a. hobor finding the greedy prodigal and suicidal contracts at scale in proceedings of the annual computer security applications conference pp.
.
s. pailoor a. aday and s. jana moonshine optimizing os fuzzer seed selection with trace distillation in proceedings of the usenix security symposium pp.
.
s. rawat v .
jain a. kumar l. cojocar c. giuffrida and h. bos vuzzer application aware evolutionary fuzzing in proceedings of the network and distributed system security symposium .
remix ethereum ide and tools for the web ethereum remix .
x. rival and k. yi introduction to static analysis an abstract interpretation perspective.
mit press .
k. sen d. marinov and g. agha cute a concolic unit testing engine for c in proceedings of the international symposium on f oundations of software engineering pp.
.
s. so m. lee j. park h. lee and h. oh v erismart a highly precise safety verifier for ethereum smart contracts in proceedings of the ieee symposium on security and privacy pp.
.
t. su k. wu w .
miao g. pu j. he y .
chen and z. su a survey on data flow testing acm computing surveys vol.
no.
pp.
.
s. tikhomirov e. v oskresenskaya i. ivanitskiy r. takhaviev e. marchenko and y .
alexandrov smartcheck static analysis ofethereum smart contracts in proceedings of the ieee acm international workshop on emerging trends in software engineering forblockchain pp.
.
c. f. torres j. sch utte and r. state osiris hunting for integer bugs in ethereum smart contracts in proceedings of the 34th annual computer security applications conference pp.
.
p .
tsankov a. dan d. drachsler cohen a. gervais f. b unzli and m. v echev securify2 securify practical security analysis of smart contracts in proceedings of the acm conference on computer and communicationssecurity pp.
.
h. wang y .
li s. w .
lin l. ma and y .
liu vultron catching vulnerable smart contracts once and for all in proceedings of the international conference on software engineering new ideas andemerging results pp.
.
h. wang y .
liu y .
li s. w .
lin c. artho l. ma and y .
liu oracle supported dynamic exploit generation for smart contracts ieee transactions on dependable and secure computing .
t. wang t. wei g. gu and w .
zou taintscope a checksum aware directed fuzzing tool for automatic software vulnerability detection inproceedings of the ieee symposium on security and privacy pp.
.
g. wood ethereum a secure decentralised generalised transaction ledger v .
w ustholz and m. christakis harvey a greybox fuzzer for smart contracts in proceedings of the international symposium on f oundations of software engineering industry papers pp.
.
targeted greybox fuzzing with static lookahead analysis in proceedings of the international conference on software engineering pp.
.
m. zalewski american fuzzy lop e. zhou s. hua b. pi j. sun y .
nomura k. y amashita and h. kurihara security assurance for smart contract in proceedings of the ifip international conference on new technologies mobility andsecurity pp.
.