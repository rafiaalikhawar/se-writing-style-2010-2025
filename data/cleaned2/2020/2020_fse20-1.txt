all your app links are belong to us understanding the threats of instant apps based attacks yutian tang shanghaitech university shanghai china csytang ieee.orgyulei sui university of technology sydney sydney australia yulei.sui uts.edu.auhaoyu wang beijing university of posts and telecommunications beijing china haoyuwang bupt.edu.cn xiapu luo the hong kong polytechnic university hong kong china csxluo comp.polyu.edu.hkhao zhou the hong kong polytechnic university hong kong china sunmoonsky0001 gmail.comzhou xu chongqing university chongqing china zhouxullx cqu.edu.cn abstract android deep link is a url that takes users to a specific page of a mobile app enabling seamless user experience from a webpage to an app.
android app link a new type of deep link introduced in android .
is claimed to offer more benefits such as supporting instant apps and providing more secure verification to protect against hijacking attacks that previous deep links can not.
however we find that the app link is not as secure as claimed because the verification process can be bypassed by exploiting instant apps.
in this paper we explore the weakness of the existing app link mechanism and propose three feasible hijacking attacks.
our findings show that even popular apps are subject to these attacks such as twitter whatsapp facebook message.
our observation is confirmed by google.
to measure the severity of these vulnerabilities we develop an automatic tool to detect vulnerable apps and perform a large scale empirical study on android apps.
experiment results suggest that app link hijacking vulnerabilities are prevalent in the ecosystem.
specifically .
apps are vulnerable to link hijacking with smart text selection sts .
apps are vulnerable to link hijacking without sts and all instant apps are vulnerable to instant app attack .
we provide an in depth understanding of the mechanisms behind these types of attacks.
furthermore we propose the corresponding detection and defense methods that can successfully prevent the proposed hijackings for all the evaluated apps thus raising the bar against the attacks on android app links.
our insights and findings demonstrate the urgency to identify and prevent app link hijacking attacks.
the corresponding authors permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse november virtual event usa association for computing machinery.
acm isbn .
.
.
.
concepts security and privacy mobile platform security .
keywords android deep link app link instant app acm reference format yutian tang yulei sui haoyu wang xiapu luo hao zhou and zhou xu.
.
all your app links are belong to us understanding the threats of instant apps based attacks.
in proceedings of the 28th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse november virtual event usa.
acm new york ny usa pages.
introduction mobile apps are pervasive.
android as the dominant mobile operating system supports a wide variety and a large number of mobile apps.
to provide integrated service to users android integrates various functionalities from different apps.
the deep link is a mechanism in android to allow such seamless web to app communications .
a deep link is a universal resource identifier uri for app content such as a specific activity .
for example clicking a deep link e.g.
yelp career home on a webpage in the mobile chrome a user is automatically redirected to the yelp app by android.
here chrome hands over the control to the yelp as the latter is more suitable for the task.
app link.
despite the convenience researchers also identified serious security issues in deep links .
a most significant hijacking example is an app can register another app s scheme with a deep link and deceive users into opening the malicious app.
to prevent this android promotes a new type of deep link called app linksince android .
.
the target of the app link is taking users directly to a link s specific content in an app.
app links are different from deep links in two aspects first app links only support links with http s e.g.
http s ... .
however deep links support customized schemes e.g.
yelp ... second the app link verification is enforced for enabling app links.
whereas such verification is not enforced for deep links.
to pass the app link verification a developer must do the followings first a user has to claim the app link in the app sesec fse november virtual event usa yutian tang yulei sui haoyu wang xiapu luo hao zhou and zhou xu manifest file androidmanifest.xml second the user has to publish a digital asset link dal on their domain.
the rules and syntax for constructing dal are presented in the official tutorial .
instant app.
despite the efforts made by the android security team and researchers app links are still not as secure as expected especially when it is under the context of instant apps .
instant apps are recently promoted by android to enable on demand use of modules in an app without the installation of the entire app.
to build an instant app developers must split an app into modules and associate urls with these modules.
these modules are named asfeatures in an instant app.
each instant app consists of one base feature module and zero or more feature modules .
the feature modules can access all public functions in the base feature module .
inside each module there is at least one activity that serves as an entrance to the module.
this activity is always associated with a uri through which users can access the activity and other services in the module.
when a user clicks the uri the module is downloaded and its activity is launched to the user.
launchinstanthomeactivity google trips app base module exploreactivity ... ... ...publish tobase module instanthomeactivity exploreactivity ... ... ...click download google play figure the workflow of android instant app.
if a user accesses a feature module an android package a.k.a.
apk the binary format of an app that contains the base feature module and the feature module is downloaded to the device.
otherwise an apk that only contains the base feature module is downloaded to the device.
fig.
shows an example of google trips instant app com.google.android.apps.travel.onthego which only contains the base module.
in google trips there are two activities that are associated with urls.
to be exact instanthomeactivity and exploreactivity are bound to links google.com tripsapp and google.com tripsapp trip em respectively.
once the link i.e.
google.com tripsapp is clicked the module base module in this case is downloaded to the device.
then instanthomeactivity is shown to users.
compared with normal apps instant apps have the following unique features first an instant app does not require any installation and second an instant app can provide on demand modules for app users.
a module is downloaded to the target device if and only if a user attempts to access certain functions inside that module.
attacks.
however we find that app link verification can be easily bypassed by exploiting instant apps detailed in section .
attackers can manipulate a malicious instant app mia to launch three types of attacks including link hijacking with sts .
link hijacking without sts .
and instant app hijacking .
.
sts is a novel feature introduced in android .
.
with sts android can recognize the text selected or tapped and recommend the next logical step.
for example if a user selectsa sequence of numbers sts recognizes them as a possible phone number and recommends the user to make a phone call.
in this attack the sts is spoofed to recommend our mia for users.
if a user select our mia they can be hijacked.
we validate these attacks on the latest android versions both android and .
the attacks can be launched successfully on a pixel device.
we already reported the weakness of the app link mechanism to google through its vulnerability reward program vrp .
google confirmed the vulnerability we reported.
our android id is .
to further measure the severity of these attacks we develop a tool called miafinder to detect apps that are vulnerable to the aforementioned three types of attacks detailed in section .
we then apply miafinder to android apps in the wild.
experiment results suggest that app link vulnerabilities are prevalent in android s ecosystem with over of apps are fragile to these attacks detailed in section .
to defense the app link attacks we propose a novel api named verifydomainpackage and generate a patch that integrates the verifydomainpackage api for the latest android .
.
the experiments show that verifydomainpackage can successfully prevent the all the three types of attacks detailed in section .
contributions.
the major contributions as follow new vulnerabilities and attacks.
we present the weakness of the app link mechanism in android and present three kinds of attacks accordingly.
these attacks are demonstrated to be practical and reproducible.
for example we demonstrate that our attacks can even hijack some popular apps such as gmail facebook message system sms and whatsapp.
to the best of our knowledge this is the first end to end study of the security issues in the app link mechanism.
our observation is acknowledged by google.
detection and defense techniques.
we develop a static analysis tool named miafinder to automatically detect apps that are vulnerable to the three types of attacks.
to defence these attacks we further propose a defense mechanism and generate a patch for the latest android .
experiment results show that our defense mechanism can successfully protect against these attacks.
large scale study.
we have conducted a large scale empirical study on apps from google play and apps from tencent myapp the largest third party app market in china.
our results demonstrate that google play apps and tencentmyapp apps are vulnerable to link hijacking with smart text selection sts attack google play apps and tencent myapp apps are vulnerable to link hijacking without smart text selection attack and all instant apps are vulnerable to instant app hijacking attack .
we hope that our efforts can raise awareness among relevant stakeholders including smartphone vendors app markets app developers and mobile users .
hence we have made our miafinder and all the experiments publicly available at com view instant app attacks.
motivating examples architecture of mia.
we illustrate a malicious instant app mia as shown in fig.
which contains two parts a phishing module and a benign module.
when users use the mia only the functionsall your app links are belong to us understanding the threats of instant apps based attacks esec fse november virtual event usa link hijacking with stslink hijacking without stsinstant app hijacking attack vector instant app instant app instant app app link verification?pass fail1pass fail pass victimsin app browsers browsers nil2 none in app browsers nil instant app nil nil assumption setupwe assume that a user installs a mia from google play.
for three different attacks the settings for the mias are shown in sec.
.
sec.
.
and sec.
.
respectively.
attack overviewwhen a user selects a text whose content is a url android suggests the mia to respond to it.
for example if a user select in an app e.g sms app the sts suggests our mia to the user.when a user clicks a link e.g.
s he is redirected to the mia.
for example if a user click the link in an app e.g sms app the sts suggests our mia to the user.when a user selects a link to launch an instant app android launches the mia.
for example if a user clicks google.com tripsapp to launch google trip instant app s he is redirect to our mia.
countermeasuresto prevent this attack developers can prevent users from selecting a text or stopping the sts.
we propose solutions for developers to prevent this attack .this attack can be prevented by implementing an in app browser.
once a user clicks a link the in app browser can respond to the link.the protection must be taken by android.
android can leverage verifydomainpackage to detect mia.
1pass app link verification passed fail app link verification failed 2nil this field is unavailable 3mia malicious instant app table overview of attack models in the benign module can be accessed.
the benign module does not contain any harmful content which makes users hard to recognize that the instant app is malicious.
thus the mia hides itself as a non mia.
however once users access the victim url the phishing module becomes active and hijacks the url.
as android hands over the control to the phishing module without notifying users the users are not aware that they are interacting with a malicious app.
as we successfully upload our mia to google play see demo videos on the project page our mia can bypass the security checking from google play and launch attacks without users consent.
link hijacking with sts.
as shown in table the attack relies on a novel feature smart text selection sts which is introduced in android .
.
once a user selects a piece of text android can recognize the text selected and then recommend the next logical step for the user.
for example when a user selects a sequence of numbers sts may suggest the user make a phone call with the numbers selected.
in sts there are five functional texts for recommendations including email address phone number physical address in a longitude and latitude format url and date time.
as shown in fig.
.
.
once a yelp url e.g.
is selected the sts recommends mia as a possible solution for the url.
if a user launches the url with the mia his her privacy data can be collected by the mia.
once the miacollects the data from a user the mia then broadcasts the intent to make the victim app yelp to respond to the url again.
link hijacking without sts.
we assume that a user intends to open the yelp app via a browser e.g.
chrome .
as shown in fig.
.
.
when a user clicks the url to launch the yelp app android ranks all possible apps that can respond to this url.
android always gives a higher priority to an instant app comparing to a none instant app to respond to a url.
therefore the mia rather than the yelp app is launched by android.
instant app hijacking.
if a user intends to launch an instant app the process can also be hijacked.
as shown in fig.
.
.
when a user clicks the url google.com tripsapp to launch the google trips instant app as both our mia and the victim instant app google trips are instant apps android ranks them based on their package names.
in this case we set a smaller package name a.example.instantappurlauto comparing to the google trips com.google.android.apps.travel.
onthego .
the mia is then ranked higher than the google trips instant app by android for responding to the url.
as a result the mia rather than the google trips is launched by android.
differences in three attacks.
we compare the differences in the three attacks from the following aspects esec fse november virtual event usa yutian tang yulei sui haoyu wang xiapu luo hao zhou and zhou xu .
select a yelp url with smart text selection in an app .
.
.
.
android recommends our mia as a candidate for processing the url .
.
mia collects privacy data from users and hides itself by re broadcasting the url with an intent link hijacking with sts .
.
.
.
click a yelp url in an app .
android always uses our mia to open the url without users consent link hijacking without sts .
google.com tripsapp .
.
android always uses mia to respond to the url without users consent instant app hijacking google trip victim instant app .
click an url to open an instant app figure illustration of three proposed attacks benign module phishing module google play .... victim apps figure the architecture of the mia.
the victim apps.
as shown in table only the instant app hijacking targets at attacking instant apps.
other attacks only work on typical apps none instant app approaches to launch the attack.
as shown in fig.
and table only link hijacking with sts relies on the sts to launch the attack.
other attacks do not rely on the sts.
remarks.
we emphasis that two extra points for these attacks.
we demonstrate that these attacks can hijack app links urls that are mapped to an app .
if a url does not map to any app it also can be hijacked by link hijacking with without sts .
the attacks proposed can be launched regardless of the correctness of app link configurations.
that is even if an app link is not correctly configured or the app link verification fails attacks also can be launched.based on the above two points we can conclude that the attacks proposed are practical with high risks.
on the one hand all urls can be hijacked by proposed attacks.
on the other hand all apps that define app links can be affected by our attacks.
background recall our motivating examples we highlight that our attacks can be launched no matter the app links are correctly configured or not.
therefore in this section we first present the background of app links then introduce how android verifies app links and finally show the cases that can fail the app link verification process.
get dal register 3return verify com.yelp.android assetlinks.json during installation after installation figure the verification process and usage sample of an app link app link configuration and release.
to use app links a developer must register them in the http s scheme in the app s manifest file.
then the developer publishes the dal on the web.
for example in order to use app links in the yelp app the yelp app developers need to register the yelp domain in the app all your app links are belong to us understanding the threats of instant apps based attacks esec fse november virtual event usa and also publish the dal on yelp s sever at verify app links.
once a user installs the yelp app the verification of app links in the yelp happens.
as shown in fig.
the app registers its app links to android.
to verify these app links android extracts the dal file assetlinks.json from the remote server i.e.
as the dal file defines the authorized app android can check whether the package name scheme and certificate fingerprint of the app match with a record on the dal.
if and only if the verification of app links passed the app links become valid.
use app links.
once users click app links they are redirected to the yelp app by the android system.
invalid app link verification.
however incorrect configuration from either app end or web end can fail the link verification process.
for the app end the incorrect configurations such as missing the autoverify true field or invalid the domain names can result in a failure.
for the web end the incorrect json format invalid fields in a dal or invalid namespaces can also be the reasons.
intent and intent filter.
once a user clicks a url in an app an intent is sent by the app.
in android an intent is a messaging object that can be used to request an action from another app component.
for example one activity can start a service e.g.
playing background music with an intent .
there are two types of intents explicit intent and implicit intent .
the explicit intent defines an app to respond to the intent by specifying the app s package name.
whereas the implicit intent only defines a general action to perform in an intent .
for example an app can use an implicit intent to request the google map app to show a location.
apps that can perform the action defined in an implicit intent get the chance to respond to the intent .
to hijack a url the mia must claim that it has the capability to process the link to android.
only the mia claims to process a link android can consider it as a candidate for the link.
attack models .
overview in this section we provide a bird s eye view of all attack models.
we demonstrate an mia can be exploited as an attack vector for three types of attacks including link hijacking with sts .
link hijacking without sts .
and instant app hijacking attack .
.
even though we launch these attacks with instant apps the settings of them can be different.
attack vector for all attacks we exploit mias as the attack vector.
the mia the mia can either be installed from google play or by clicking the the mia s launching url in an other app e.g.
android s sms app .
the reason that attacks can be launched without users consent is presented in sec.
.
.
link hijacking with smart text selection the link hijacking with sts aims at preventing users from accessing urls via sts.
when s he selects a url text e.g.
google.com with sts android suggests the mia for handling the url.
the url text can come from the app itself or input by users.the attack steps.
in the mia for simplicity we build two activities mainactivity and loginactivity .
recall the architecture of our mia see.
fig.
the mainactivity belongs to the benign module while the loginactivity belongs to the phishing module.
the intent filters associated with them are shown in fig.
.
the mainactivity is the launcher for the mia and it is bound with .
this means when the url is clicked the mia is launched automatically and android navigates to the mainactivity .
the loginactivity is designed for spoofing users.
the mainactivity is associated with my own site main which is an app link.
this is mandatory for launcher activity for instant apps.
we also set up a deep link for the malicious loginactivity .
the intent filter inside the loginactivity makes theloginactivity can handle the all urls that match the regular expression .
note that as a deep link does not require any verification the setting for loginactivity does not violate any principles for building an app.
activity android name .mainactivity ... meta data android name default url android value intent filter android autoverify true action android name android.intent.action .view category android name android.intent.category.default category android name android.intent.category.browsable data android host android pathpattern main android scheme http intent filter activity activity android name .loginactivity intent filter action android name android.intent.action .view category android name android.intent.category.default data android host android pathpttern .
android scheme http data android host android pathpattern .
android scheme https intent filter activity deep link app link for hijackingfor installing launching the instant app figure link hijacking manifest configuration the victim apps.
this attack targets at apps that access a url with sts.
this attack can work on all kinds of apps including browsers in app browsers apps that have embedded webview for opening urls e.g.
wechat and none browser apps.
this attack can be launched on browsers because when a user uses sts for processing text selected the selection is handled directly by android rather than the app itself.
the root cause.
with deep link defined in fig.
the loginactivity can respond to .
this is because the url is subject to the regular expression .
if the url is selected android looks up for all apps that can respond to the url.
then sts suggests all these apps for users to select.
therefore sts suggests our mia to users.
if users select our mia android uses our mia see fig.
to respond to the url.
the mia is thereby launched to respond to the intent .esec fse november virtual event usa yutian tang yulei sui haoyu wang xiapu luo hao zhou and zhou xu private static list labeledintent createforurl context context string text if uri .parse text .
getscheme null text text return arrays .aslist new labeledintent context .getstring com .android .internal .r.
string .browse context .getstring com .android .internal .r.
string .browse desc new intent intent .action view uri .parse text .
putextra browser .extra application id context .getpackagename labeledintent .default request code figure the smart text selection for url text .
link hijacking without smart text selection the link hijacking aims at preventing users or apps from accessing certain urls apps with the mia.
for example once users click a url e.g.
in the sms app they are redirected to our mia rather than the yelp app.
the attack steps.
the setting for the mia follows the same step in .
.
we also build two activities mainactivity and loginactivity .
the intent filters associated with them are shown in fig.
.
the only difference is the way of launching this attack.
in link hijacking without sts by clicking a url link hijacking occurs.
whereas in link hijacking with sts users have to select a piece of url then sts recommends the mia to users.
the victim apps.
this attack can be launched on apps that access a url.
for example some apps contain rate us buttons.
once the button is clicked users are redirected to the mia.
it worth mentioning that this attack cannot work on browsers or in app browser apps apps that implement browsers for opening urls for example wechat .
the reason is that browsers or in app browser apps can handle the url themselves rather than asking android to handle the url.
the root cause.
if a url is clicked android looks up all apps that can handle the url.
as our instant app can handle the intent see .
android suggests our mia to respond to the intent.
typically android asks users to select one app from all candidates to respond to the given link.
however with the instant app we can successfully escape such prompt.
to illustrate this attack we start from introducing how android processes a url click.
once a url is tapped the startactivity method is called.
android checks whether there is a locally installed app that can resolve this intent.
if multiple apps that can resolve the intent android ranks them based on their package names.
then android finds a suitable activity to respond to the intent with choosebestactivity method packagemanagerservice.java .
ranks candidates activities based on package name the top one has a higher priority start has a saved preferred app nloop to find a top ranked instant app n return a list of apps return n y choosebestactivity figure the functionality of choosebestactivity method inside packagemanagerservice.java inside method choosebestactivity the system performs the following checking check whether the first activity has a higher priority or default .
if so the first activity is used to respond tothe intent if returns false android checks whether there is a preferred app for handling the intent.
if so the preferred app a.k.a.
saved preference replies to the intent if the checking returns false android loops all activities to find whether there is an instant app that can cope with the intent.
if so the instant app responds to the intent if no instant app and no saved preferred app to cope with the intent android shows a list of candidate apps to allow users to select from.
the candidate apps are selected based on whether they can handle the intent.
for example a user can have different apps that can play audios.
all these apps are candidates for the task of playing audios presented as an intent in a program .
from to we can find that if a user does not set any preference android places the priority on instant apps.
it means in general an instant app owns a higher priority compared to a none instant app.
recall our link hijacking scenario as the loginactivity supports all urls with the pattern the mia can respond to the url.
however the attack occurs in step and .
if no app is signed to a higher priority and no app is set to be the default app android checks whether an instant app can cope with the intent.
consequently the mia responds to the intent.
android provides the mia a higher priority based on the fact that the app is an instant app.
however the defect is that android fails to check whether the url is used for launching the instant app.
this attack reveals two defects first android has to verify whether a url is the one associated with the instant app and second android should not assign a higher priority to instant apps comparing to none instant apps.
the fundamental observations for this vulnerability are android does not verify whether all links claimed in an instant app belong to the same entity e.g.
a developer a company .
for an instant app it is possible to claim both app links and deep links.
as deep links are not required to verify the mia can claim deep links that it does not own and android authorizes a higher priority to an instant app comparing to an installable app .
.
instant app hijacking the instant app hijacking aims at preventing users from accessing an instant app even if it is installed.
here we assume that both the mia and the victim instant app are installed from google play.
the attack steps.
we assume that users download both the victim instant app e.g.
google trip instant app com.google.android.apps.travel.onthego and the mia from google play.
once users intend to access the google trip instant app they are redirected to our mia.
as shown in fig.
we set the mainactivity same as link hijacking see fig.
and the malicious logactivity is set to respond the url google.com tripsapp .
this url is associated with google trip instant app com.google.android.apps.travel.onthego .
that is the logactivity is designed for hijacking the google trips instant app.
the key factor of launching this attack is setting the package name to be one smaller than google trips package name based on the dictionary order.
here we set the package name of our mia to a.example.instantappurlauto a.example.instantappurlauto com.google.android.apps.travel.onthego .all your app links are belong to us understanding the threats of instant apps based attacks esec fse november virtual event usa activity android name .mainactivity meta data android name default url android value intent filter android autoverify true action android name android.intent.action .view category android name android.intent.category.default category android name android.intent.category.browsable data android host android pathpattern main android scheme http intent filter activity activity android name .loginactivity intent filter action android name android.intent.action .view category android name android.intent.category.default data android host play.google.com android pathprefix tripsapp android scheme http data android host google.com android pat hprefix tripsapp android scheme https intent filter activity deep link app link http s google.com tripsapp for installing launching the instant app manifest ... package a.example.instantappurlauto ranks higher than google trips for android to select figure instant app hijacking manifest configuration the victim apps.
all instant apps are vulnerable to this attack.
if the malicious app is installed prior to the victim instant app the app user is blocked for downloading and using the victim instant app unless s he uninstalls the mia.
if the mia is installed after the installation of the victim instant app the app user is blocked for accessing the victim instant app even though the victim instant app is installed on the phone.
for both cases the services from the victim instant app are blocked.
the root cause.
by setting the intent filters oflogactivity as fig.
both the mia and google trip instant app can respond to the url.
if multiple instant apps and apps can resolve one url android ranks them based on package names.
then android leverages choosebestactivity method for locating the target app for the intent .
recall the functionality of choosebestactivity introduced in .
if there is no saved preferred app and no app with a higher priority for the given intent android checks whether there is an instant app can resolve the intent .
we assign a package name to the mia with a lower dictionary rank comparing to the victim instant app.
as all apps are ranked base on package names the mia is ranked higher than the victim app a.example.instantappurlauto com.google.android.apps .travel.onthego .
based on the background presented in .
and fig.
the choosebestactivity is incorrectly chosen the mia to respond to the url rather than the victim instant app.
detection in this section we present our method to detect vulnerable apps that can be attacked.
.
static analysis to detect whether an app is vulnerable to proposed attacks we construct a program dependence graph pdg of the app .
the pdg consists of the control flow dependencies and the data flow dependencies of the app.
to construct a pdg we collect possible entry points in the app.
as android apps do not specify the entry points e.g.
main method for java application for execution we collect the entry points of an app from two parts lifecyclemethods in android components e.g.
activity .
we focus on lifecycle methods of components as they are the standard entry points to the app.
through them developers can manage the app s components and their behaviors and ui callbacks.
android allows developers to register ui callbacks for monitoring certain events.
for example the method onclicklistener is invoked once a button is clicked.
in practice we leverage edgeminer to collect all possible entries for a given app.
if the app employs obfuscations or packer to protect its bytecode we will use deobfuscators e.g.
tiro and unpackers e.g.
packergrind to recover the hidden bytecode for analysis.
next we build the app s pdg by using flowdroid and further extend the pdg to a ui oriented pdg named updg which models the dependencies and transitions through ui elements e.g.
textview .
a node in updg is defined as n uid utype a c o in which the uidrepresents the ui element s id.
the ui id can be retrieved from the layout files.
utype represents the type e.g.
textview of the ui element.
arepresents the activity context which means the ui element uidis used in the activitya.crepresents the callback method with the element.
orepresents the node in pdg.
to construct the updg we first parse all layout files and the manifest file in the app.
from layout files we extract all ui elements including text content name id uid and type utype .
then we match the ui elements with the original pdg nodes.
to realize this we search the statements that are related to ui reference or initialization with findviewbyid .
for example the statement findviewbyid r.id.btn can be used to refer to the ui element with id btn.
next we analyze the ui callbacks e.g.
onclicklistener that are associated with these ui elements.
then we retrieve the activity context a and the corresponding callback c for a nodenin updg.
last we append data flows introduced by the inter component communication icc via implicit intents to the updg.
to capture them we leverage ic3 to locate the source and sink for all intents in the app.
ic3 transforms the icc problem into a multi valued composite mvc constant propagation problem i.e.
finding all possible values of objects concerned at a particular program point .
ic3 specifies the mvc constant propagating problem with the constant propagation coal language and then employs a coal solver to solve the problem.
ic3 infers the arguments in an intent and then finds the target component.
we append the data flows introduced by intents to the updg.
.
detecting link hijacking with sts in practice we leverage the workflow defined in fig.
to check whether an app is vulnerable to this attack.
to be exact if an app contains edittext s the text can be edited in an edittext we check the followings if the text is a password phone number time or date the text cannot be visible or cannot be a valid url.
for example the text in an edittext whose input type is password can not be visible all characters are presented by some approaches can be used for preventing users from using sts e.g.
usesetmovementmethod null .
these approaches are introduced in in detail.
we exclude all these cases as they prohibit users from using sts.esec fse november virtual event usa yutian tang yulei sui haoyu wang xiapu luo hao zhou and zhou xu apphas edittext?is textpassword?is textphonenumber timenumber datenumber?otherssetmovementmethod null ?override issuggestionsenabled ?setcustomselectionactionmodecallback ?other caseshas labels?
textview settextselectable true ?is text a url?
has onclicklistener tochange text to a url?
other callbacks onclicklistener tochange text to a url?
figure the workflow for checking link hijacking with sts if an app contains textviews a.k.a labels we check the followings whether the textviews can be selected by tracking the settextisselectable true .
if and only if the method settextisselectable true is invoked the text on a textview can be selected.
if the text on the textview cannot be selected the attack cannot be launched.
it is worth mentioning that by default the text on a textview cannot be selected if the content in a textview is a url it can be hijacked with sts and if the content in a textview can be changed to a url it can be hijacked with sts.
for we check all the onclicklistener s on textview s in the app to evaluate whether the content on textview s can be changed to urls.
besides we also check all callbacks and onclicklistener s in the app to evaluate whether the content on textview s can be changed to urls.
implementation.
in practice we transverse the updg to find whether any updg node that invokes the apis mentioned above.
for a node in the updg that is associated with a ui element we track the node through the updg graph to collect all operations performed and allowed on the node.
then we check whether the node satisfies the conditions in fig.
.
for example the expression writtentext edittext findviewbyid r.id.edittext1 defines a edittext object writtentext .
the writtentext is also associated with a ui element whose id is edittext1 .
we track the usage of this node i.e.
writtentext for simplicity on the updg to find other settings for this object.
all settings and operations defined on writtentext are then collected.
we leverage the workflow in fig.
to evaluate whether attacks can be launched with this node.
if so the app is considered to be vulnerable.
.
detecting link hijacking without sts to determine whether an app is fragile to link hijacking without sts we use the checking diagram in fig.
.
first we check whether the app uses any intent in the code.
second if the app launches a url with the intent we then check whether the app is a browser or contains an in app browser.
third if the app is not a browser or does not implement any in app browser the app is vulnerable to the link hijacking attack without sts.
as aforementioned if an app intends to open a url with an intent the app is fragile to this attack.
however if the app is a appstart any intent?date fieldis a url?not a browser oran in app browser?
figure the workflow for checking link hijacking browser or the app contains an in app browser the attack cannot be launched.
it is because the browser in app browser can handle urls inside itself rather than asking android to find the targets for the urls.
implementation.
we first iterate the updg to check whether the app launches any intent .
first we track and locate all intent objects in an app.
there are two types of intents explicit andimplicit intent.
for explicit intent the target of the intent is defined in the intent object by specifying the package name.
however to launch a url the type of the intent must be implicit .
to launch a url with an intent the data field is set to the target url.
therefore we first locate the intent objects in the given app.
next we leverage the taint analysis to track the setting of the data field of these intent objects.
if the data field is set to a uri by tracking the type then we can confirm the app uses an intent to open a url.
the next step is to detect whether the app is a browser or contains an in app browser.
to do this we traverse the updg to detect whether there is an instance of webview or an instance of type a whereais a subclass of webview .
if an app is a browser or implements an in app browser the attack cannot be launched.
.
detecting instant app hijacking as presented in sec.
.
the malicious instant app can hijack other instant apps that have larger package names in terms of dictionary comparison.
therefore all instant apps are vulnerable to this attack as long as the malicious instant app has a deliberately designed package name.
evaluation .
evaluation overview apps dals to evaluate whether real world apps are vulnerable to three types of attacks we crawled apps from google play and apps from tencent myapp the largest third party app market in china .
to determine whether app links are valid besides checking the correctness of app links claimed we also need to check the correctness of the dal.
if and only if both the app itself and the dal are successfully configured the app links are valid.
to obtain the app links claimed by an app we plan the following steps step exploring reachable activities.
we extract all intent filters from all activities whose categories contain browsable anddefault fields.
with these fields these activities are reachable from a browser step verifying the app link.
for the all intent filters extracted from step we extract intent filters whose action fields contain view .
it returns intent filters either with app linksall your app links are belong to us understanding the threats of instant apps based attacks esec fse november virtual event usa or with customized urls.
then we extract intent filters with http s schemes as they represent the app links after step we obtain all app links claimed by the app.
for each app link we extract the domain from the app link.
then we leverage openwpm to visit the domain.
we set the loading interval to seconds to allow page loading and url redirection.
then we download the corresponding dal files from remote servers.
for a given domain x its dal file is located at x .well known assetlinks.json.
evaluation roadmap.
in research question rq we discuss the incorrect configurations of app links.
note that incorrect configurations can make app link verification fails.
apps that fail to pass app link verification are fragile to various attacks such as link hijacking man in the middle mitm attack.
they are also vulnerable to attacks proposed in this paper.
in rq and rq we evaluate whether real world apps are robust to link hijacking attacks with and without sts .
in rq we discuss whether instant apps are robust to instant app hijacking.
last in rq we evaluate the accuracy of our miafinder tool.
.
rq1 are real world apps correctly configure app links?
motivation.
in this rq we aim at finding the incorrect configurations of app links.
the incorrectness implies that app links are not valid and it leaves room for attackers.
methodology.
the correctness of app links requires the following checking the autoverify attribute must be set to be true in the app s manifest file.
this attribute triggers the verification process of app links declared.
without this attribute android does not verify the link if the domain declared is not valid i.e.
the domain not exists or cannot be visited the verification of app links cannot be passed if the domain declared does not contain any dal the verification of app links fails as well.
for example if an app claims to associate a domain and the domain does not publish any dal the verification fails.
as the assetlinks.json must be published under a fixed path domain .well known assetlinks.json if the assetlinks.json cannot be found at the path we consider there is no dal published and if the dal file exists we check whether the dal file subjects to its syntax.
if and only if the dal is corrected built the app links are valid.
given a dal we perform the following steps for evaluating it.
step checking dal existences.
we check whether a domain hosts a dal file.
it can be achieved by checking whether the path of the dal file is reachable.
it is possible that a domain does not contain a dal and it does not support any app link.
step verifying the syntax.
as android forces the syntax of a dal file the valid dal must pass the syntax checking.
for example if a dal file adds a field that is not supported by the syntax the verification of the dal cannot pass.
step checking fields.
next we check the fields and values in the dal to explore all possible violations in the dal.
for the relation field there are two standard relations .
for the target field there are two possible targets android app andweb.
if a dal has an invalid field or sets an invalid value the verification of the dal fails.
step include statement checking.
it is also possible to claim statement indirectly by referring an existing dal with the include statement .
therefore for this type of dal we check the included file with step tostep .
results.
as a result the incorrect configurations of app end belong to the following categories missing autoverify true field to allow android verifies the app link the field autoverify true must be set.
therefore if an app link lacks such a field the verification fails.
invalid host format the host must be a correct url in format otherwise the app link cannot be verified.
inaccessible host even a given host a url in format if the url cannot be accessed the app link verification can not pass as the dal cannot be retrieved.
missing fields in intent filters the valid app link requires the intent filter to specify a action view action one or more data tags and two categories browsable anddefault .
missing any field makes the app link invalid.
in addition we find that the incorrect configurations of dals belong to the following categories incorrect json formatting errors this type of error is that the dal is not with a valid json format.
the errors can be unmatched brackets unexpected symbols unknown symbols and duplicate entities.
incorrect fields some incorrect dals have field errors including using undefined fields missing required fields e.g.
namespace typo in fields.
all these make them invalid.
incorrect namespace the syntax of the dal requires its namespace to be android app or web .
if a dal uses invalid namespaces the app link verification fails.
answer to rq1 among all google play apps apps use app links.
there are only .
of them configure the app links correctly.
among all tencent myapp apps apps use app links.
there are only .
of them configure the app links correctly.
implications.
this experiment suggests that developers must check the configurations of app links carefully.
as for app markets we suggest app markets for forcing apps to verify domains claimed by apps.
.
rq2 are real world apps robust to the general link hijacking attack with sts?
motivation.
in this research question we intend to evaluate whether real world apps robust to link hijacking with sts.
methodology.
see sec.
.
for details.
answer to rq2 as a result there are google play apps .
that are vulnerable to link hijacking with sts attack.
there are tencent myapp apps .
that are vulnerable to this attack.
implications.
for this type of attack it is the defect introduced by android.
even if the victim is a browser or contains an in app browser the attack can be launched successfully.
it is because that sts first obtains the url selected and then broadcasts an intent to find the target candidate for the url.
in sec.
we proposed fouresec fse november virtual event usa yutian tang yulei sui haoyu wang xiapu luo hao zhou and zhou xu solutions for protecting this attack by either stopping users from selecting any text or customizing the suggestions returned by sts.
.
rq3 are real world apps robust to the link hijacking attack without sts?
motivation.
in this research question we intend to evaluate whether real world apps are robust to link hijacking without sts.
this evaluation aims at finding the risks of this attack.
methodology.
see section .
for details.
answer to rq3 as a result there are google play apps .
that are vulnerable to link hijacking without sts attack.
there are tencent myapp apps .
that are vulnerable to this attack.
implications.
as the results show there is a large number of apps that vulnerable to the link hijacking attack.
to prevent from being attacked an app can implement an in app browser rather than broadcast the intent .
except for this approach an app cannot prevent this attack.
the reason is that it is android rather than the victim app to select the target app to respond to the url.
therefore the defect must be fixed from the system layer.
nothing can be done by the victim app to prevent this attack.
.
rq4 are instant apps robust to instant app hijacking?
we relax the evaluation of instant app hijacking attack base on the following concerns first in .
we illustrate the vulnerability by investigating android source code.
the vulnerability is verified by providing evidence from android source code second the subtlety of this attack is using certain settings in the mia and exploiting the platform a.k.a.
android defects.
it means that all instant apps are vulnerable to instant app hijacking.
though we find the clue that instant apps are not robust to the hijacking from the android source code we still test instant app hijacking on all real world instant apps out of apps from google play.
the instant app hijacking can attack all these instant apps.
note that instant apps can only be published with google play rather than other app stores as they require google play for installing the victim instant apps .
therefore we do not consider the apps from tencent myapp market for this attack.
answer to rq4 all instant apps are vulnerable to instant app hijacking attack.
implications.
this defect implies that android must carefully select the instant app to respond to a url if there are more than one instant apps can respond to a link.
first if a link is associated with an instant app only the instant app that passes the app link verification can respond the link in our attack our malicious instant app claims the app via a deep link rather than an app link.
therefore google does not force our malicious instant app to verify the link claimed .
second android has to ask users to select an instant app to handle if there are multiple instant apps can respond to the url.
note that if two instant apps from the same developer company it is possible that they can process the same link.
therefore asking users for their preferences is the solution for this case.
moreover allowing multiple instant apps for the same url is an anti pattern in design.
.
rq5 what is the accuracy of miafinder?
motivation.
in this paper we develop miafinder to find apps that are vulnerable to proposed attacks.
in this rq we evaluate the accuracy of the miafinder.
methodology.
to evaluate the accuracy of miafinder we randomly select apps from google play and then manually checked whether they can be attacked successfully in order to build a benchmark for evaluating our tool.
next we run the miafinder to find vulnerable apps.
note that for an app if it can be attacked by at least one attack out of three proposed attacks we consider it as vulnerable.
results.
as a result our tool reports vulnerable apps and all of them can be exploited.
therefore the precision of our tool is .
the recall of our tool is .
there are main reasons why our tool misses some vulnerable apps since the current version of our tool cannot handle native code it may miss vulnerable apps that define and handle the ui elements through native code.
for example if a vulnerable game app is based on unity the ui elements can be defined and handled through c code and thus our tool misses it since our tool currently focuses on the default android ui framework it misses vulnerable apps that use third party ui frameworks.
answer to rq5 based on the experiments of apps we find that the precision of our tool is and the recall is .
countermeasure preventing link hijacking with sts.
to prevent link hijacking with sts attack we propose solutions.
solution .
if a developer plans to use textview a.k.a label in an app s he can use the settextselecttable false to prevent users from selecting any text in a label solution .
if a developer plans to use edittext users can edit text in edittext s he can use setmovementmethod null to prevent users from selecting any text in an edittext.
solution .
developers can override the issuggestionsenabled method in default textview or edittext.
the issuggestionsenabled returns a boolean value to indicate whether or not suggestions are enabled on this textview or edittext.
solution .
another solution is using the setcustomselectionactionmodecallback api.
this api allows developers to customize the popup menu if a piece of text is selected.
all these approaches aim at preventing users from selecting any text in uis or customizing the popup menu for sts.
once users cannot select any text in uis the sts cannot work.
preventing link hijacking without sts.
to address this we propose a novel api named verifydomainpackage .
as shown in fig.
android can invoke verifydomainpackage whose arguments are the received an intent and an activity .
the intent contains the target url to open.
the activity represents a candidate component to respond to the intent .
first it retrieves the package name of the candidate app e.g.
the mia that can respondall your app links are belong to us understanding the threats of instant apps based attacks esec fse november virtual event usa to the intent fig.
.
.
second it extracts the candidate app s signature stored in android fig.
.
.
.
third it downloads the dal for the url given in the intent fig.
.
.
.
last it exams whether the candidate app can respond to the url by checking the package name signature with the dal downloaded fig.
.
.
the verifydomainpackage can be used to check whether there is an mia that intends to hijack urls.
sdverifydomainpackagewebsitepackagemanagercredential providerclicent .
checkanddomainverfiy packagename dal signature .
assetlinks.json1.
downloaddal url .
clientsignature1.
getsignature string string1.
getpackagename activity string1 startactivityforresult intent figure the workflow for verifydomainpackage api with the verifydomainpackage api android can check whether a candidate app i.e.
activity can be used to respond to a url.
it worth mentioning that using verifydomainpackage can prevent the link hijacking attack with sts.
preventing instant app hijacking attack.
to prevent the instant app hijacking attack android can scan all instant apps installed.
if android finds an instant app that claims a url that is not owned by the instant app android must inform app users about this case.
to check whether an instant app owns all urls claimed android can use the verifydomainpackage api.
if an instant app claims a url that it does not own the instant app can be a malicious one.
android can notify users of the potential risk of this mia.
to wrap up the novel api verifydomainpackage proposed can be leveraged to prevent all three attacks aforementioned.
we also build our patch and verify it with android .
.
related work deep links.
ma et al.
s work aladdin helps developers automatically release deep links for an app.
aladdin first computes the paths to reach each activity and fragment in a given app.
then it construct a proxy activity to bind all deep links to the proxy activity.
the proxy activity is also in charge of managing all deep links.
hu et al.
proposed a framework called elix which aims at extracting all valid deep links that are defined in an app.
elix extracts app links with a path selective taint analysis.
it leverages a taint analysis that starts from the activity.getintent for taint analysis and prunes infeasible paths with the symbolic execution.liu et al.
conduct an empirical measurement on various mobile deep links across apps and websites to explore the incorrect configurations for deep links.
different from all these works our work aims at revealing the defects in app links rather than leveraging or constructing app links or deep links .
instant app.
the only work that related to instant apps is proposed by aonzo et al.
.
in aonzo et al.
reported the design defects in password manager apps and mentioned the misuse of accessibility service can result in security problems.
even though work leverages instant app as an attack vector our work has different research targets and unique contributions aims at using instant apps for phishing rather than uncovering defects in the app link schemes.
whereas our work targets at exploring the defects rooted in android including link verification access control and priority ranking.
app browser security.
some works aim at attacking mobile browsers and in app browsers .
chin et al.
reveal two webview vulnerabilities including excess authorization andfile based cross zone scripting .
tuncay et al.
present that draco which enables developers to specify a set of policies to only allow desired access.
wang et al.
reveal the cross origin risk in android and ios browsers and in app browser apps.
with the cross origin attack malicious apps can obtain a mobile user s authentication credentials and record users behavior.
different from all these works our work targets at measuring the vulnerability of app links in terms of using an instant app as an attack vector.
app to app communication.
the works on the app to app communication leverage both static and dynamic analysis.
on the one hand researchers leverage static analysis to detect privacy leakage from the victim app to the malicious app using the call graph and taint analysis .
on the other hand some works explore privacy the leakage issues with dynamic analysis .
different from all these works our work highlights the deep link vulnerability introduced with instant apps.
conclusion in this paper we revisit app links defined by android and reveal three attack models that can be exploited.
our attacks showed strong evidence that existing limitations in verifying instant apps and drawbacks in launching instant apps e.g.
an instant app should not be given a higher priority comparing to a typical app .
to evaluate whether existing android apps are fragile to these attacks we conduct a large scale empirical study on android apps on google play and apps on tencent myapp.
as a result there are google play apps and tencent myapp apps that vulnerable to link hijacking with smart text selection google play apps and tencent myapp apps that vulnerable to link hijacking without smart text selection and all instant apps are vulnerable to instant app hijacking.
finally we make a series of suggestions to countermeasure the attacks we proposed.
acknowledgement we thank the anonymous reviewers for their helpful comments.
this research is partially supported by shanghaitech university start up research fund the hong kong general researchesec fse november virtual event usa yutian tang yulei sui haoyu wang xiapu luo hao zhou and zhou xu fund no.
17e 18e australian research grants no.
dp200101328 the national natural science foundation of china no.
and china postdoctoral science foundation no.2020m673137 .