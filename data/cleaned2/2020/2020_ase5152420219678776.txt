an empirical study of bugs in webassembly compilers alan romano university at buffalo suny alanroma buffalo.eduxinyue liu university at buffalo suny xliu234 buffalo.eduyonghwi kwon university of virginia yongkwon virginia.eduweihang wang university at buffalo suny weihangw buffalo.edu abstract webassembly is the newest programming language for the web.
it defines a portable bytecode format for use as a compilation target for programs developed in high level languages such as c c and rust.
as a result webassembly binaries are generally created by webassembly compilers rather than being written manually.
to port native code to the web webassembly compilers need to address the differences between the source and target languages and dissimilarities in their execution environments.
a deep understanding of the bugs in webassembly compilers can help compiler developers determine where to focus development and testing efforts.
in this paper we conduct two empirical studies to understand the characteristics of the bugs found in webassembly compilers.
first we perform a qualitative analysis of bugs in emscripten the most widelyused webassembly compiler.
we investigate bug reports in emscripten related to the unique challenges webassembly compilers encounter compared with traditional compilers.
second we provide a quantitative analysis of bugs in three opensource webassembly compilers assemblyscript emscripten and rustc wasm bindgen.
we analyze these bugs along three dimensions lifecycle impact and sizes of bug inducing inputs and bug fixes.
these studies deepen our understanding of webassembly compiler bugs.
we hope that the findings of our study will shed light on opportunities to design practical tools for testing and debugging webassembly compilers.
i. i ntroduction webassembly is the newest language for the web.
since appearing in many prominent tech companies and news websites such as ebay google norton and cnn have adopted the technology for various use cases such as barcode reading video players and tensorflow.js machine learning applications .
currently webassembly is supported by major browsers including chrome firefox safari and edge.
webassembly defines a portable bytecode format that serves as a compilation target for high level languages such as c c and rust enabling developers to port native applications to the web.
rather than being written manually webassembly bytecode is usually created by webassembly compilers such as emscripten or rustc with wasm bindgen .
as webassembly is increasingly adopted for various applications there is a growing ecosystem of compilers that support webassembly development.
as shown in table i there are currently compilers available to support compiling programs written in different programming languages to webassembly .
similar to compilers of native languages webassembly compilers also contain bugs that can miscompile binarytable i statistics of compiler projects .
compiler created source loc releases stars assemblyscript typescript emscripten c c rustc wasm bindgen rust asterius haskell binaryen asm.js bytecoder java faust faust dsp ilwasm .net cil ppci mirror python tinygo go outputs .
these bugs are difficult to locate as they may be encountered only at project s runtime.
compiler bugs can also waste development time when debugging an affected project before realizing that the bug is introduced due to miscompilation.
for these reasons it is important to understand how reliable compiler projects are in discovering understanding and resolving bugs.
in addition to handling the bugs associated with traditional compilers the developers of webassembly compilers face unique challenges that can introduce buggy behavior.
for example fully synchronous executions are not natively supported by browser engines which differs from the execution model expected by c c .
webassembly compiler developers should ensure that synchronous operations in c c code are properly ported over to the asynchronous browser environment as relying on asynchronous apis to perform synchronous behavior can lead to issues.
moreover javascript does not support all data types supported by webassembly.
webassembly compilers have to support the compilation of data types across multiple target languages as well as ensuring that during runtime types are not used in incorrect ways.
in this paper we perform an empirical analysis of bugs in webassembly compilers to investigate the following research questions rq1 what new challenges exist in developing webassembly compilers and how many bugs do they introduce?
rq2 what are the root causes of these bugs?
rq3 how do webassembly compiler developers reproduce these bugs and what information is needed?
rq4 how do webassembly compiler developers fix bugs?
rq5 how long does it take to fix bugs in different compilers?
rq6 what are the impacts of the bugs in diverse compilers?
to answer these research questions we first perform a 36th ieee acm international conference on automated software engineering ase 36th ieee acm international conference on automated software engineering ase .
ieee .
ase51524.
.
.
ieee table ii findings and implications of ourstudy .
findings implications data type incompatibility bugs account for .
of the bugs section iv b2 .interfaces e.g.
apis passing values between webassembly and javascript caused type incompatibility bugs when their data types are mishandled in one of the languages.
such interfaces e.g.
ftell fseek atoll llabs and printf require more attention.
porting synchronous c c paradigm to event loop paradigm causes a unique challenge section iv b1 .while automated tools support the synchronous to event loop conversion e.g.
asyncify bugs in them may cause concurrency issues e.g.
race condition out of order events .
programs going through this conversation require extensive testing.
supporting or emulating linear memory management models is challenging section iv b3 .webassembly emulates the linear memory model of the native execution environment .
many bugs reported in this regard require a particular condition e.g.
allocation of a large memory to trigger heap memory size growth calling for more comprehensive testing.
changes of external infrastructures used in webassembly compilers lead to unexpected bugs section iv b4 .compiler developers should stay on top of developments that occur in the existing infrastructure used within the compiler.
in particular valid changes in one context of existing infrastructure can introduce unexpected bugs in webassembly.
rigorous testing is needed.
despite webassembly being platform independent platform differences cause bugs section iv b8 .the default emscripten test suite focuses on testing v8 browser and node.js while there are bugs reported due to the platform differences e.g.
caused by other browsers and oses .
the test suite should pay attention to cover broader aspects of the platform differences.
unsupported primitives not properly documented lead to bugs being reported in the compiler section iv d9 .webassembly compiler developers should pay attention to keeping the document consistent with the implementation e.g.
mentioning sigsetjmp and function type bitcasting are not supported .
some bug reports failed to include critical information leading to a prolonged time of debugging section iv c .we observe that the current bug reporting practice can be improved.
in particular an automated tool that collects critical information e.g.
inputs compilation options and runtime environments would significantly help in the bug reproduction process.
bugs that manifest during runtime made up a significant portion of the bugs inspected section v b .many bugs in the compilers cause runtime bugs in the compiled programs which are more difficult to detect and fix.
to mitigate these bugs compiler developers should be sure to test the emitted modules in the test suites more exhaustively.
.
of bug inducing inputs were less than line and developers manually reduce the size of inputs section v d .in many cases bugs can be successfully reproduced by relatively small inputs that are less than lines.
currently developers often manually reduce large inputs.
automated bug inducing input reduction e.g.
delta debugging would be beneficial.
qualitative study on bugs in emscripten to identify unique development challenges and understand the root causes bug reproducing and bug fixing strategies of these bugs.
next we perform a quantitative study on bugs among three webassembly compilers namely assemblyscript emscripten and rustc wasm bindgen.
this study focuses on the lifecycle of the bugs their impacts and the sizes of the bug inducing inputs and bug fixes.
based on the findings obtained from the two studies we identify useful implications for webassembly compiler developers.
our findings and implications are summarized in table ii.
we hope that our findings can provide webassembly compiler developers with specific areas that introduce bugs into the compiler provide details on these bugs and previous fixes to help in designing new fixes and provide general project management suggestions to prevent the introduction of new bugs.
ii.
w ebassembly development flow webassembly defines an assembly like bytecode format that is built to be fast and compact.
the language also defines a text format meant to ease understanding.
specifically the text format provides a readable representation of the module s internal structure including type memory and function definitions.
unlike javascript webassembly cannot access the web apis directly.
any reliance on these technologies such as the dom websockets api and webworkers api requires complementary javascript code.
at the minimum webassembly requires javascript glue code to instantiate the webassembly module.
for our study we define a webassembly compiler as a tool that can generate webassembly binary modules from sourcecode written in a high level language.
webassembly compilers are composed of a frontend that parses the source code into an intermediate representation ir an optional middle end that optimizes the ir of the program and a backend that generates webassembly binary code from the ir.
in addition webassembly compilers include bindings of existing libraries in order to support using standard libraries available in the source language within a webassembly runtime.
fig.
1shows a typical workflow of generating a webassembly program from the source code in c tothe runtime usage on a website the c source program example.cpp shown in fig.
a defines a function iseven .
this c program is first compiled by a webassembly compiler such as emscripten emcc to generate the resulting webassembly binary example.wasm as shown in fig.
b .
the binary format is how a webassembly module is delivered to and compiled by browsers.
to ease debugging the webassembly binary can be translated to its text format example.wat shown in fig.
c by using a webassembly toolkit such as webassembly binary tool wabt .
the text format shows examples of webassembly instructions such as get local andi32.and as well as the webassembly function iseven .
to deploy the webassembly binary on a website a javascript glue code as shown in fig.
d that instantiates the example.wasm file is required.
the javascript code calls the function webassembly.instantiatestreaming that takes the parameter fetch example.wasm as the binary module source to instantiate.
finally the returned module invokes the exported function iseven .
webassembly modules are not typically standalone files.
instead they are combined with generated javascript wrap243bool iseven inta intb a if b return true else return false example.cpp a c source programexample.wasm b webassembly binary formatexample.wat d webassembly text format website or web application e.g.
extensions c javascript programwebassembly.
instantiatestreaming fetch example.
wasm imports .
then o o.instance.exports.
iseven compile via emscripten compiler emcc execute via javascript glue code to instantiate translate via webassembly binary tool wabt 0x00 736d .asm........... 0x10 017f 017f0382 ................ 0x20 ...p............ 0x30 6d65 ..............me 0x40 6d6f 0a5f 5a36 656e mory... z6 iseven 0x50 000a 8e80 i............... module memory1 func iseven param p0 i32 resulti32 get local p0 i32.const1 i32.and i32.eqzfig.
.
webassembly development workflow.
per glue code.
since webassembly cannot start on its own and cannot directly interact with webapis the glue code is responsible for importing the necessary functions used by the module.
additionally the glue code can set up data structures necessary to implement the runtime provided by the native language such as memory allocation file system emulation and socket emulation.
the final output of a webassembly compiler includes a webassembly module a javascript file that handles the module imports and runs the module and an html file that loads the module.
iii.
d ata collection a. selecting webassembly compilers we inspect webassembly compiler projects on github using the curated awesome wasm list that includes webassembly compilers currently available as shown in table i. we focus on popular compilers that support general purpose high level programming languages.
specifically we prune outfaust domain specific audio dsp language and binaryen asm.js low level target as these source languages are not general or high level.
we also filter out compilers with less than lines of code asterius ilwasm ppci mirror and tinygo and less than releases bytecoder to focus on mature projects.
to this end our studies focus on three webassembly compilers emscripten rustc wasm bindgen and assemblyscript .
.emscripten compiles c c to webassembly .
it originally targeted asm.js a precursor language to webassembly so it precedes the creation of webassembly.
it uses a modified clang frontend and originally used binaryen to provide the backend.
it later adopted llvm as the backend .
.rustc compiles rust programs to webassembly .
as this compiler relies on the wasm bindgen project to provide bindings necessary for webassembly compilations we include issues affecting both rustc and wasmbindgen in our count.
we use the name rustc wasmbindgen to highlight the combination of these two components.
.assemblyscript compiles a typescript like language into webassembly .
it uses its own frontend and relies on binaryen to handle the backend code generation.
in the qualitative study section iv we aim to investigate webassembly compiler bugs in depth to answer the research questions rq1 rq2 rq3 and rq4.
for this purpose we choose emscripten because it is the most mature and widelyused webassembly compiler emscripten was created earliest and has the most numbers of stars and milestone releases compared with others.
it also has the most number of reported bugs will be discussed in section v .
it dominates real world usage .
b. compiler bug collection we collect bug reports from the three selected webassembly compiler projects github repositories through two methods.
first we use the github search api to collect closed github issues related to webassembly1.
second we use the github rest api to collect all the issues and pull requests for the projects.
we also collect the commits referenced in the timeline of each issue in order to find which files the issues affected in the repositories.
after obtaining the full set of issues for each project we use the keywords bug defect error and fault to identify the issues likely to be bugs.
table iii bugreport dataset .
compiler start end bugs unique bugs commits assemblyscript emscripten rustc w asm bindgen t otals qualitative study dataset emscripten .
we extract all closed bugs from the emscripten project.
we read the bug reports of these issues to only include those that are related to the challenges unique to webassembly compilers.
specifically we check the root causes of the bugs to determine whether a typical compiler targeting a native platform e.g.
gcc targeting x86 would need to deal with a similar root cause.
if not we consider that they are unique challenges to webassembly 1issues with keywords like bug good first bug and breaking changes with webassembly wasm and wat .
344and include them in our dataset.
this brings the final number of bugs to .
this scale is on par with similar work involving manual inspection .
quantitative study dataset.
as shown in table iii we obtain a total of bug reports and related commits from the three compilers github repositories.
the second and third columns show the earliest and latest dates of the bugs considered for the dataset.
the number of bugs from each compiler i.e.
after applying the filters and the number of commits relating to the bugs are presented in the fourth and fifth columns respectively.
note that we exclude bugs earlier than june from consideration as these precede the development of webassembly .
also there are multiple bug reports for one single bug because they readdress previous issues for various reasons e.g.
incomplete previous fix .
iv.
s tudy i q ualitative study of emscripten issues in the first study we manually inspect emscripten issues that contain bug inducing code inputs to identify development challenges bug causes reproducing difficulties and fixing strategies.
fig.
2presents the architecture of emscripten.
it is built on top of existing compiler tools and infrastructures with clang being used to implement the frontend.
llvm is used to provide middle end optimizations.
binaryen and llvm provide the backend functionality.
although the three stages resemble a traditional compilation pipeline for c c compilers developers of emscripten and any webassembly compiler in general face unique challenges.
specifically emscripten provides implementations of the standard c and c that emulate the functionality available on native platforms e.g.
file systems and threading .
these emulation libraries implement the semantics of legacy system calls by leveraging functions from javascript runtime components.
for example the fs library in emscripten emulates traditional filesystem operations within the browser.
additionally emscripten provides libraries that allow c c to call javascript functions at runtime.
this is done to allow the c c code to interact with the dom and web apis which are only accessible through javascript.
it also includes several utilities supporting compilation or optimization of the input rather than parts of the source language or libraries.
at the end of the compilation a webassembly binary module is emitted along with the javascript support code to provide a full webassembly package.
a. rq1 development challenges webassembly compiler developers face a set of challenges that are unique to the new language.
we develop categories for these challenges using an inductive coding approach where we create categories based on the description of the underlying root cause.
from this description we determine whether this is a common compiler issue or an issue unique to webassembly features.
we iteratively add and refine categories to form district groups.
as shown in table iv we generalize unique webassembly compiler development challenges.table iv bugs related to development challenges .
development challenge count asyncify synchronous code incompatible data types memory model differences bugs in other infrastructures emulating native environment supporting web apis cross language optimizations runtime implementation discrepancy unsupported primitives total challenge asyncify synchronous c c code.
most basic operations in c c are executed in a synchronous and blocking manner.
however fully synchronous executions are not supported by browser engines.
execution in browsers follows an event loop that does not block execution to allow user interactions which differs from the execution model expected by c c .
in order to support compiling to this model webassembly compilers need to provide additional tools to handle converting synchronous blocking code to fit the event based asynchronous browser environment.
however we find that the implementations of these tools can be incorrect or inconsistent causing various bugs.
we observe that issues were introduced by these tools.
challenge incompatible data types.
we find issues that are caused by incompatibilities in the data types passed between the multiple languages involved in emscripten compilation.
this includes type incompatibilities during compilation between c and webassembly and type incompatibilities at runtime between webassembly and javascript.
challenge memory model differences.
webassembly has a different memory model than native environments.
these differences can lead to issues when compiling to webassembly and we find that issues can be attributed to these differences.
challenge other infrastructures bugs.
emscripten is built on top of existing compiler infrastructures and tools.
as a result bugs can be reported in the emscripten repository but may be found to be caused in the tool of another infrastructure.
these existing infrastructures include frontend parsers backend code generators and webassembly vms e.g.
such as v8 .
challenge emulating native environment.
emscripten provides libraries to seamlessly emulate native environment features that are not available on the web.
these include filesystems posix threads and sockets.
challenge supporting web apis.
in addition to emulating native environment libraries emscripten also provides apis to support calling webapis from c c code.
these webapis include webgl the fullscreen api and indexeddb and these interfaces are called by existing c c libraries such as opengl and sdl or by using the emscripten provided webapi bindings.
challenge cross language optimizations.
since emscripten emits both a webassembly binary module and the supporting javascript runtime code optimizers used on either output component must be able to collect usage information 445input source code .c .cpp .h existing frontend clangmiddle end llvm transformsir iremscripten compiler toolchainoutput module .
wasm existing backend llvm binaryen library interface webapisnative environment ne emulationutilities e.g.
optimization minification sanitizer js support code ne emulation runtime fs math webapis implementation js support code fig.
.
structure of emscripten compiler toolchain.
table v asyncify synchronous c c c ode bugs.
asyncify tool causes count emterpreter parsing errors emterpreter incorrect emterpretify stack state missing features in emterpreter asyncify missing sleep callback animation requestanimationframe misuse indexeddb flawed filesystem sync operation total from both languages.
these optimizers can contain bugs that hinder the optimization of the resulting module.
challenge runtime implementation discrepancy.
some issues can arise from differences in the running environment.
this includes differences between browsers differences in browsers and runtimes and differences in runtimes supporting es5 and or es6.
challenge unsupported primitives.
some issues arise when users attempt to perform functionality that touches on limitations in webassembly.
for example emscripten does not support the c keyword sigsetjmp because webassembly does not support signals .
b. rq2 bug causes we investigate the emscripten bugs to identify and analyze the types of root causes among the issues.
we read the conversation on the issue s github page to find what the developers reported the underlying issue to be.
after identifying the root cause description for all issues we generalize similar root causes into challenges listed in table iv.
we create root cause categories by using a deductive coding approach beginning with root cause categories from existing work .
we extend these categories to be more specific to webassembly compilers.
to categorize these bugs we read the issue reports to find what the compiler developers reported the underlying issues to be.
we decide to which category the underlying root cause most relates to.
note that some root causes may be related to more than one category.
for example if the bug root cause is an invalid type operation from another infrastructure we classify it as under incompatible data types.
asyncify synchronous code bug causes there are bugs in emscripten tools that convert synchronous execution to asynchronous execution as shown in table v. specifically bugs are caused by parsing errors in the emterpreter tool.
bugs are caused by the internal state management of theemterpreter.
bugs are caused by unimplemented features in the emterpreter.
bug is caused by the omitted sleep callback.
bug is caused by a misuse of the requestanimationframe browser function as a polling mechanism.
bug is caused by a flawed filesystem sync operation.
fig.
3gives an example of the missing sleep callback bug.
emterpreter and asyncify are two mechanisms provided by emscripten to handle porting synchronous c c code into event based code compatible with the browser event loop.
asyncify allows for asynchronous execution by modifying webassembly code to allow for pausing and resuming during the middle of execution.
emterpreter converts the input code into a bytecode format different from webassembly that is run in an interpreter that can be paused and resumed.
according to the documentation both methods should perform the same functionality.
this bug happens because the emscripten sleep api in asyncify behaves differently from theemscripten sleep with yield function in emterpreter.
in particular emscripten sleep in asyncify does not actually call a sleep callback.
this difference leads to issues in the sdl library as it relies on these tools to handle streaming audio in the main loop.
audio chunks are enqueued through the sleep callback as shown in fig.
so this lack of consistency leads to audio distortion in asyncify.
sdl audiospec as as.callback audio callback void audio callback void unused uint8 stream int len push audio stream data to stream variable while true calculate audio stream data emscripten sleep with yield emscripten sleep for asyncify !
fig.
.
emscripten issue missing sleep callback.
this issue is fixed by adding the changes shown in fig.
4to the asyncify library to call sleep callbacks making it consistent with the behavior in emterpreter.
incompatible data type bug causes we find bugs within emscripten that are a result of incompatible data types passed between the various languages involved in the compilation.
as shown in table vi incompatible data type bugs result from root causes that can be grouped into three broad categories.
the first group includes root causes involving native webassembly data types i.e.
i32 i64 f32 and f64 .
the sleepcallbacks functions to call every time we sleep ... handlesleep function startasync call all sleep callbacks now that the sleep resume is all done.
!
asyncify.sleepcallbacks.foreach function func func ... fig.
.
bug fix for emscripten issue .
table vi incompatible data types bugcauses .
data type causes count incorrect i64 legalization native unsupported floating point or precision loss missing i32 operation incorrect c atomic types custom invalid simd type operations error code type change undefined undefined cross language type function total second group involves types that are not native to webassembly including c atomic types designed for threads single instruction multiple data simd values and error code constants.
the last category undefined cross language type function involves missing utility functions that fetch type information of compiled c c values.
fig.5gives an example of the incorrect i64legalization bug.
this bug occurs when using a file pointer provided by thecstdio library and compiling the module with option s main module .
when compiling to webassembly the browser sandbox prevents accessing the host filesystem.
to get around this limitation emscripten provides a filesystem library fs implemented in javascript that emulates most of the functionality provided by libc andlibcxx .
the files are either provided as a static asset to download or embedded within the javascript wrapper.
when the code in fig.
5is compiled the calls to perform file i os are handled within this fslibrary on the javascript side.
include cstdio int main file file std fopen input.txt rb if file std fseek file 0l seek end std fclose file return fig.
.
emscripten issue incorrect i64 legalization.
since javascript does not natively support bit integers passing the bit integer values to javascript is usually handled by a method called legalization which converts the bit value into two bit integers holding low and high bits separately.
within the execution path to fseek an indirect call attempts to pass a webassembly i64value to exported webassembly function of a side module.
the issue is that this other module s export function has been wrapped in javascript code to support value legalization so although the first module knows thatthe export function s type is i64 the intermediate javascript function cannot accept the parameter.
the issue is fixed by exporting legalized and non legalized versions of webassembly functions so that function calls made through the indirect calls used here can pass i64values to the appropriate function when legalization is not required.
memory model difference bug causes we observe bugs in emscripten that are a result of the differences in memory model between webassembly and a native environment.
in a native environment memory is allocated directly from the main memory while webassembly uses the data structures available in the host vm to allocate a block of memory to function as the module s linear memory.
specifically there are bugs that do not update the memory location after the memory is relocated.
bugs are caused by unnecessarily disabling memory growth in combination with another functionality such as building standalone modules.
bug does not free unused resources after they are no longer needed resulting in increased memory usage.
another bug attempts to access memory beyond the intended range.
bug shifts the boundaries of a memory buffer incorrectly.
a bug incorrectly leaves zero filled memory regions in the initial memory file increasing the size of the file.
fig.6shows an example of the missing reference update bug.
when a webassembly program allocates a large amount of heap memory the memory might be relocated to a different location.
if a program stores a memory location and does not update the location after the heap memory is relocated it will cause a runtime exception because it refers to an invalid memory location.
this bug occurs when both webassembly memory growth and file system functionality are used e.g.
via memfs filesystem .
when the webassembly module is initialized the file content is stored in the heap section created in the module memory.
the memfs filesystem is one of the emscriptenemulated filesystems and it supports in memory file storage.
it contains a reference to this location for future file operations.
after the malloc the memory is grown and the heap is moved to a different location.
however the filesystem reference is not updated and the file contents cannot be read.
include stdio.h include stdlib.h void main int c malloc enlarge memory file fp fopen test.c r while c fgetc fp !
eof putchar c fig.
.
emscripten issue missing reference updates.
the issue is fixed by forcibly enabling the no heap copy flag which stores the file system in a separate array to allow it to grow freely without worrying about filesystem