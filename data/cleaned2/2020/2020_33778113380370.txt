approximation refinement testing of compute intensive cyber physical models an approach based on system identification claudio menghi claudio.menghi uni.lu university of luxembourg luxembourg luxembourgshiva nejati shiva.nejati uni.lu university of ottawa ottawa canada university of luxembourg luxembourg luxembourglionel briand lionel.briand uni.lu university of ottawa ottawa canada university of luxembourg luxembourg luxembourgyago isasi parache isasi luxspace.lu luxspace s rl luxembourg luxembourg abstract black box testing has been extensively applied to test models of cyber physical systems cps since these models are not often amenable to static and symbolic testing and verification.
black box testing however requires to execute the model under test for a large number of candidate test inputs.
this poses a challenge for a large and practically important category of cps models known ascompute intensive cps ci cps models where a single simulation may take hours to complete.
we propose a novel approach namely aristeo to enable effective and efficient testing of ci cps models.
our approach embeds black box testing into an iterative approximation refinement loop.
at the start some sampled inputs and outputs of the ci cps model under test are used to generate a surrogate model that is faster to execute and can be subjected to black box testing.
any failure revealing test identified for the surrogate model is checked on the original model.
if spurious the test results are used to refine the surrogate model to be tested again.
otherwise the test reveals a valid failure.
we evaluated aristeo by comparing it with s taliro an open source and industry strength tool for testing cps models.
our results obtained based on five publicly available cps models show that on average aristeo is able to find more requirements violations than s taliro and is31 faster than s taliro in finding those violations.
we further assessed the effectiveness and efficiency of aristeo on a large industrial case study from the satellite domain.
in contrast to s taliro aristeo successfully tested two different versions of this model and could identify three requirements violations requiring four hours on average for each violation.
ccs concepts software and its engineering software testing and debugging formal software verification.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may seoul republic of korea association for computing machinery.
acm isbn .
.
.
.
cyber physical systems model testing search based testing robustness falsification acm reference format claudio menghi shiva nejati lionel briand and yago isasi parache.
.
approximation refinement testing of compute intensive cyber physical models an approach based on system identification.
in 42nd international conference on software engineering icse may seoul republic of korea.
acm new york ny usa pages.
.
introduction a common practice in the development of cyber physical systems cps is to specify cps behaviors using executable and dynamic models .
these models support engineers in a number of activities most notably in automated code generation and early testing and simulation of cps.
recent technological advancements in the areas of robotics and autonomous systems have led to increasingly more complex cps whose models are often characterized as compute intensive .
compute intensive cps models ci cps require a lot of computational power to execute since they include complex computations such as dynamic nonlinear and non algebraic mathematics and further they have to be executed for long durations in order to thoroughly exercise interactions between the cps and its environment.
for example non trivial simulations of an industrial model of a satellite system capturing the satellite behavior for 24h takes on average around 84minutes .
hours .1the sheer amount of time required for just a single execution of ci cps models significantly impedes testing and verification of these models since many testing and verification strategies require to execute the model under test mut for hundreds or thousands of test inputs.
approaches to verification and testing of cps models can be largely classified into exhaustive verification and white box and black box testing.
exhaustive verification approaches often translate cps models into the input language of model checkers or satisfiability modulo theories smt solvers.
cps models however may contain constructs that cannot be easily encoded into the smt solver input languages.
for example cps models specified in the simulink language allow importing arbitrary c code via s function blocks or include other plugins e.g.
the deep learning 1machine m1 core intel core i7 .20ghz 32gb of ram.
ieee acm 42nd international conference on software engineering icse icse may seoul republic of korea claudio menghi shiva nejati lionel briand and yago isasi parache toolbox .
in addition cps models typically capture continuous dynamic and hybrid systems .
translating such modeling constructs into low level logic based languages is complex has to be handled on a case by case basis and may lead to loss of precision which may or may not be acceptable depending on the application domain.
furthermore it is well known that model checking such systems is in general undecidable .
white box testing uses the internal structure of the model under test to specifically choose inputs that exercise different paths through the model.
most white box testing techniques aim to generate a set of test cases that satisfy some structural coverage criteria e.g.
.
to achieve their intended coverage goals they may rely either on smt solvers e.g.
or on randomized search algorithms e.g.
.
but irrespective of their underlying technique coverage guided testing approaches are not meant to demonstrate that cps models satisfy their requirements.
more recently falsification based testing techniques have been proposed as a way to test cps models with respect to their requirements .
these techniques are black box and aim to find test inputs violating system requirements.
they are guided by quantitative fitness functions that can estimate how far a candidate test is from violating some system requirement.
candidate tests are sampled from the search input space using randomized or meta heuristic search strategies e.g.
.
to compute fitness functions the model under test is executed for each candidate test input.
the fitness values then determine whether the goal of testing is achieved i.e.
a requirement violation is found or further test candidates should be selected.
in the latter case the fitness values may guide selection of new test candidates.
falsificationbased testing has shown to be effective in revealing requirements violations in complex cps models that cannot be handled by alternative verification methods.
however serious scalability issues arise when testing ci cps models since simulating such models for every candidate test may take such a large amount time to the extent that testing becomes impractical.
in this paper in order to enable efficient and effective testing of ci cps models we propose a technique that combines falsificationbased testing with an approximation refinement loop.
our technique shown in figure is referred to as approximation based test generation aristeo and targets systems that exhibit both continuous and discrete dynamic behaviors e.g.
simulink and hybrid systems .
as shown in the figure provided with a cicps model under test mut we automatically create an approximation of the mut that closely mimics its behavior but is significantly cheaper to execute.
we refer to the approximation model assurrogate model and generate it using system identification si e.g.
which is a methodology for building mathematical models of dynamic systems using measurements of the system s inputs and outputs .
specifically we use some pairs of inputs and outputs from the mut to build an initial surrogate model.
we then apply falsification testing to the surrogate model instead of the mut until we find a test revealing some requirement violation for the surrogate model.
the identified failure however might be spurious.
hence we check the test on the mut.
if the test is spurious we use the output of the test to retrain using si our surrogate model into a new model that more closely mimics the behavior of the mut and continue with testing the retrained surrogate model.
initial surrogate model test refined surrogate model approximationmodel under test mut falsification refinement checkreal failurespurious failure figure aristeo approximation based test generation.
if the test is not spurious we have found a requirement violation by running the mut very few times.
aristeo is inspired at a high level by the counter example guided abstraction refinement cegar loop proposed to increase scalability of formal verification techniques.
in cegar boolean abstract models are generated and refined based on counterexamples produced by model checking while in aristeo numerical approximation of cps models are learned and retrained using test inputs and outputs generated by model testing.
our contributions are as follows we developed aristeo an approximation refinement testing technique to identify requirements violations for ci cps models.
aristeo combines falsification based testing with surrogate models built using system identification si .
we have implemented aristeo as a matlab simulink standalone application relying on the existing state of the art system identification toolbox of matlab as well as s taliro a state of the art open source falsification based framework for simulink models.
we compared aristeo and s taliro to assess the effectiveness and efficiency of our proposed approximation refinement testing loop.
our experiments performed on five publicly available simulink models from the literature show that on average aristeo finds .
more requirements violations than s taliro and finds the violations in31.
less time than the time s taliro needs to find them.
we evaluated usefulness and applicability of aristeo in revealing requirements violations in large and industrial ci cps models from the satellite domain.
we analyzed three different requirements over two different versions of a ci cps model provided by luxspace our industrial partner.
aristeo successfully detected violations in each of these versions and for all the requirements requiring four hour on average to find each violation.
in contrast s taliro was not able to find any violation on neither of the model versions and after running for four hours.
structure.
section presents our running example formulates the problem and describes our assumptions.
section describes aristeo which is then evaluated in section .
section provides an in depth discussion of threats to validity.
section presents the related work.
section concludes the paper.
cps models and falsification based testing in this section we describe how test inputs are generated for black box testing of cps models.
we then introduce the baseline 373testing compute intensive cyber physical systems icse may seoul republic of korea table input profile for the sat ex case study.
magnetometer gyro reaction wheel magnetorquer int n pchip pchip pchip pchip r falsification based testing framework we use in this paper to test cps models against their requirements.
black box testing of cps models.
we consider cps models under test mut specified in simulink since it is a prevalent language used in cps development .
our approach is not tied to the simulink language and can be applied to other executable languages requiring inputs and generating outputs that are signals over time e.g.
hybrid systems .
such languages are common for cps as engineers need to describe models capturing interactions of a system with its physical environment .
we use sat ex a model of a million satellite as a running example which is a simplification of a real model developed by luxspace a satellite system provider and partner in our research project.
lettime domain t be a non singular bounded interval of r. asignal is a function f t r. we indicate individual signals using lower case letters and setsof signals using upper case letters.
letmbe an mut.
we write y m u to indicate that the model mtakes a set of signals u u1 u2.
.
.um as input and produces a set of signals y y1 y2.
.
.yn as output.
each uicorresponds to one model input signal and each yicorresponds to one model output signal.
we use the notation ui t andyi t to respectively indicate the values of the input signal uiand the output signal yi at time t. for example the sat ex model has four input signals indicating the temperatures perceived by the magnetometer gyro reaction wheel and magnetorquer components and one output signal representing the orientation a.k.a attitude of the satellite.
to execute a simulink mut m the simulation engine receives signal inputs defined over a time domain and computes signal outputs at successive time steps over the same time domain used for the inputs.
a test input for mis therefore a set of signal functions assigned to the input signals u1 u2.
.
.um ofm.
to generate signal functions we have to generate values over the time interval t .
this however cannot be done in a purely random fashion since input signals are expected to conform to some specific shape to ensure dynamic properties pertaining to their semantic.
for example input signals may be constant piecewise constant linear piecewise linear sinusoidal etc.
to address this issue we parameterize each input signal uiby an interpolation function a value range rand a number nof control points with n .
to generate a signal function for ui we then randomly select ncontrol points ui t1 toui tn within rsuch that t1 tn bandt2to tn 1are from tsuch that t1 t2 .
.
.
tn tn.
the values of t2 t3 .
.
.
tn 1can be either randomly chosen or they can be fixed with equal differences between each subsequent pairs i.e ti ti ti ti .
the interpolation function is then used to connect the ncontrol points ui t1 toui tn .
aristeo currently supports several interpolation functions such as piecewise constant linear and piecewise cubic interpolation.
for each input uiofm we define a triple inti ri ni where intiis an interpolation function riis the range of signal values and niis the number of controlalgorithm baseline falsification based testing.
function falsification test m ip max repeat ifuis null then u generate m ip generate a candidate test input else u search m ip u generate next candidate test input end if y m u executemforu iftobj u y 0then check if ureveals a violation return u end if until the number of executions of mreaches max return and the test input u among those generated with the lowest fitness value end function points.
we refer to the set of all such triples for all inputs u1toum ofmas an input profile ofmand denote it by ip.
provided with an input profile for an mut m we can randomly generate test inputs formas sets of signal functions for every input u1toum.
for example the input profile for sat ex provided by luxspace is reported in table where are real value domains.
baseline falsification based testing.
the goal is to produce a test input uthat when executed on the mut m reveals a violation of some requirement of m. algorithm represents a high level overview of falsification based testing.
it is a black box testing process and includes three main components a test input generation component generate in algorithm a test objective determining whether or not a requirement violation is identified tobj in algorithm and a search strategy to traverse the search input space and select candidate tests search in algorithm .
we describe generate search andtobj.
the input to the algorithm is an mut mtogether with its input profile ipand the maximum number maxof executions of mut that can be performed within an allotted test budget time.
note that we choose the maximum number of executions as a loop terminating condition but an equivalent terminating condition can be defined in term of maximum execution time.
initial test generation generate .
it produces a candidate test input uformby randomly selecting control points within the ranges and applying the interpolation functions as specified in ip.
iterative search search .
it selects a new candidate test input ufrom the search input space of m. it uses the input profile ip to generate new test inputs.
the existing candidate test input u may or may not be used in the selection of the new test input.
in particular search m ip u can be implemented using different randomized or meta heuristic search algorithms .
these algorithms can be purely explorative and generate the new test input randomly without considering the existing test input u e.g.
monte carlo search or they may be purely exploitative and generate the new test input by slightly modifying u e.g.
hill climbing .
alternatively the search algorithm may combine 374icse may seoul republic of korea claudio menghi shiva nejati lionel briand and yago isasi parache both explorative and exploitative heuristics e.g.
hill climbing with random restarts .
test objective tobj .
it maps every test input uand its corresponding output y i.e.
y m u into a test objective value tobj u y in the set rof real numbers.
note that computing test objective values requires simulating mfor each candidate test input.
we assume for each requirement of m we have a test objective tobj that satisfies the following conditions tobj1 iftobj u m u the requirement is violated tobj2 iftobj u m u the requirement is satisfied tobj3 the more positive the test objective value the farther the system from violating its requirement the more negative the farther the system from satisfying its requirement.
these conditions ensure that we can infer using the value of tobj whether a test cases passes or fails and further tobj serves as a distance function estimating how far a test is from violating model requirements and hence it can be used to guide generation of test cases.
the robustness semantics of stl is an example of a semantics that satisfies those conditions .
an example requirement for sat ex is satreq the difference among the satellite attitude and the target attitude should not exceed degrees .
this requirement can be expressed in many languages including formal logics that predicate on signals such as signal temporal logics stl and restricted signals first order logic rfol .
for example this requirement can be expressed in stl as g error where error is the difference among the satellite attitude and the target attitude gis the globally stl temporal operator which is parametrized with the interval i.e.
the property error should hold for the entire simulation time h .
we define a test objective tobj for this requirement as tobj u m u min t error t this is consistent with the robustness semantics of stl .
this value ensures the conditions tobj tobj 2andtobj 3since if the property is violated i.e.
there exists a time instant tsuch that error t a negative value is returned.
in the opposite case the property is satisfied and tobj u m u returns a non negative value.
furthermore the more positive the test objective value the farther the system from violating its requirement and the more negative the farther the system from satisfying its requirement.
in our work we use the s taliro tool which implements the falsification based testing shown in algorithm .
s taliro is a welldeveloped open source research tool for falsification based testing and has been recently classified as ready for industrial deployment .
it has been applied to several realistic and industrial systems and based on a recent survey on the topic is the most mature tool for falsification of cpss.
further s taliro supports a range of standard search algorithms such as simulated annealing monte carlo and gradient descent methods .algorithm the aristeo main loop.
function aristeo m ip max ref repeat if mis null then m approximate m generate a surrogate model else m refine m u m refine the surrogate model end if u falsification test m ip max iftobj u m u 0then testufinds a real violation return u end if until the number of executions of mreaches max ref return end function test objectives can be defined manually.
alternatively assuming that the requirements are specified in logic languages test objectives satisfying the three conditions we described earlier can be generated automatically.
in particular we have identified two existing tools that generate quantitative test objectives from requirements encoded in logic based languages taliro and socrates .
in this paper we use taliro since it is integrated into s taliro.
to do so we specified our requirements into signal temporal logic stl and used taliro to automatically convert them into quantitative test objectives capturing degrees of satisfaction and refutation conforming to our conditions tobj1 tobj3 on test objectives.
aristeo algorithm shows the approximation refinement loop of aristeo.
the algorithm relies on the following inputs a ci cps model m i.e.
the model under test mut the input profile ipof mut and the maximum number of iterations max ref that can be executed by aristeo.
in the first iteration an initial surrogate model m is computed such that it approximates the mut behavior line .
note that mis built such that it has the same input profile as m i.e.
mandmhave exactly the same inputs and outputs.
at every iteration the algorithm applies falsification based testing to the surrogate model min order to find a test input uviolating the requirement captured by the test objective tobj line .
note that if the falsification based testing framework is not able to find a test input uviolating the requirement it returns the one among those generated with the lowest fitness value.
the number maxof iterations of falsification based testing for mis an internal parameter of aristeo and in general can be set to a high value since executing mis not expensive.
once uis found the algorithm checks whether uleads to a violation when it is checked on the mut line .
recall from section that test objectives tobj are defined such that a negative value indicates a requirement violation.
if so uis returned as a failure revealing test for m line .
otherwise uis spurious and in the next iteration it is used to refine the surrogate model m line .
if no failure revealing test for mis found after max ref iterations the algorithm stops and a null value is returned.
375testing compute intensive cyber physical systems icse may seoul republic of korea the falsification based testing procedure is described in section algorithm .
in section .
we describe the approximate method line and in section .
we describe the refine method line .
.
approximation given an mutm the goal of the approximation is to produce a surrogate model msuch that c1 mand mhave the same interface i.e.
the same inputs and outputs c2 provided with the same input values they generate similar output values and c3 m is less expensive to execute than m. we rely on system identification si techniques to produce surrogate models since their purpose is to automatically build mathematical models of dynamical systems from data when it is difficult to build the models analytically or when engineers want to build models from data obtained based on measurements of the actual hardware.
note that the more complex si structures i.e.
nonlinear nlarx andhw rely on machine learning and neural network algorithms .
to build musing si we need some input and output data from the mutm.
sincemis expensive to execute to build the initial surrogate model m line we runmfor one input uonly.
note that an input uofmis a set u1 .
.
.
um of signal functions over t .
so each uiis a sequence ui ui ui .
.
.ui l where b l and is the sampling rate applied to the time domain .
similarly the output y m u is a set y1 .
.
.
yn of signal functions where each yjis a sequence yj yj yj .
.
.yj l obtained based on the same sampling rate and the same time domain as those used for the input.
we refer to the data used to build m astraning data and denote it byd.
specifically d u y .
for ci cps the size lofdtends to be large since we typically execute such models for a long time duration large b and use a small sampling rate small for them.
for example we typically run sat ex forb 400s 24h and use the sampling rate .0312s.
hence a single execution of sat ex generates a training data set dwith size l .
such training data size is sufficient for si to build reasonably accurate surrogate models.
we use the system identification toolbox of matlab to generate surrogate models.
in order to effectively use si we need to anticipate the expected structure and parameters of surrogate models a.k.a configuration.
table shows some standard model structures and parameters supported by si.
specifically selecting the model structure is about deciding which mathematical equation among those shown in table is more likely to fit to our training data and is better able to capture the dynamics of the model m. as shown in table equations specifying the model structure have some parameters that need to be specified so that we can apply si techniques.
for example for arx na nb nk the values of the parameters na nbandnkare the model parameters.
table provides a short description for each model structure.
we note that some of the equations in the table are simplified and refer to the case in which the mut has a single input signal and a single output signal.
the equations however can be generalized to models with multiple input and output signals.
briefly model structures can be linear or non linear in terms of the relation between the inputs and outputs or they can be continuous and discrete in terms of their underlying training data.
specifically the training datagenerated from mut can be either discrete i.e.
sampled at a fixed rate or continuous i.e.
sampled at a variable rate .
provided with discrete training data we can select either continuous or discrete model structures while for continuous training data we can select continuous model structures only.
as discussed earlier our training datadis discrete since it is sampled at the fix sampling rate of .
hence we can choose both types of model structures to generate surrogate models.
in our work we support training data sampled at a fixed sampling rate to build and refine the surrogate models.
data sampled at a variable time rate can be then handled by exploiting the resampling procedure of matlab .
the users of aristeo need to choose upfront the configuration to be used by the si i.e.
the model structure and the values of its parameters.
this choice depends on domain specific knowledge that the engineers possess for the model under analysis.
the values of the parameters selected by the user should be chosen such that the resulting surrogate model i has the same interface as the mut to ensure c1and ii has a simpler structure than the mut to ensure c3.
the system identification toolbox provides some generic guidance for selecting the parameters ensuring these two criteria .
in this work we performed an empirical evaluation over a set of benchmark models to determine the configuration to be used in our experiments section .
.
once a configuration is selected si uses the training data to learn values for the coefficients of the equation from table that corresponds to the selected structure and paramters.
for example after selecting arx na nb nk and assigning values to na nbandnk si generates a surrogate model by learning values for the coefficients a1 .
.
.anaandb1 .
.
.bnb.
similar to standard machine learning algorithms si s objective is to compute the model coefficients by minimizing the difference error between the outputs of mand mfor the training data .
si uses different standard notions of errors depending on the model structure selected.
in our work we compute the mean squared error mse between the outputs of mand m. si learns a surrogate model mby minimizing mse over the training datadand hence ensuring c2.
the learning algorithm selected by si depends on the chosen model structure on the purpose of the identification process i.e.
whether the identified model will be used for prediction or simulation and on whether the system is continuous or discrete.
.
refinement the refinement step rebuilds the surrogate model mwhen the test input uobtained by falsification based testing of the surrogate model is spurious for mut i.e.
it does not reveal any failure according to the test objective .
note that mmay not be sufficiently accurate to predict the behavior of the mut.
hence it is likely that we need to improve its accuracy and we do so by reusing the data obtained when checking a candidate test input uon mut line of algorithm .
letu u1 .
.
.
um andy y1 .
.
.
yn be the spurious test inputs and its output respectively.
similar to the data used to build the initial mby the approximate step line of algorithm the datad u y used to rebuild mis also discretized based on the same sampling rate .
to refine the surrogate model we do not 376icse may seoul republic of korea claudio menghi shiva nejati lionel briand and yago isasi parache table model structure and parameter choices for developing surrogate models.linearmo del structure equation model type arx n a nb nk y t a1 y t .
.
.
ana y t na b1 u t nk .
.
.
bnb u t nb nk e t discrete description the output ydepends on previous input values i.e.
u t nk .
.
.
u t nb nk and on values assumed by the output yin previous steps i.e.
y t .
.
.
y t na .
naandnbare the number of past output and input values to be used in predicting the next output.
nkis the delay number of samples from the input to the output.
mo del structure equation model type armax n a nb nk nc y t a1 y t .
.
.
ana y t na b1 u t nk .
.
.
bnb u t nb nk c1 e t .
.
.
cnc e t nc e t discrete description extends thearxmodel by considering how the values e t .
.
.
e t nc of the noise eat time t t .
.
.
t ncinfluence the value y t of the output y. mo del structure equation model type bj n b nc nf nd nk y t b z f z u t c z d z e t discr ete description box jenkins models allow a more general noise description than armax models.
the output ydepends on a finite number of previous input uand output yvalues.
the values nb nc nd nf nkindicate the parameters of the matrix b c d fand the value of the input delay.
mo del structure equation model type tf n p nz y t b0 b1 s b2 s2 .
.
.
bn snz f1 s f2 s2 .
.
.
fm snp u t e t continuous description repr esents a transfer function model.
the values np nzindicate the number of poles and zeros of the transfer function.
mo del structure equation model type ss n x x0 x t f x t gu t kw t y t hx t du t w t continuous description uses state variables to describe a system by a set of first order differential or difference equations.
nis an integer indicating the size of the matrix f g k handd.non linearmo del structure equation model type nlarx f n a nb nk y t f y t ... y t na u t nk ... u t nk nb discrete description uses a non linear function fto describe the input output relation.
wavelet sigmoid networks or neural networks in the deep learning matlab toolbox can be used to compute the function f.naandnbare the number of past output and input values used to predict the next output value.
nkis the delay from the input to the output.
mo del structure equation model type hw f h n a nb nk w t f u t x t b z f z w t y t h x t continuous description hammerstein wiener models describe dynamic systems two nonlinear blocks in series with a linear block.
specifically fandhare non linear functions b z f z na nb nkare defined as for bjmodels.
different nonlinearity estimators can be used to learn fandhsimilarly to the nlarx case.
change the considered configuration but we combine the new d and existing training data d and refine musing these data.
alternative policies can be chosen to refine the surrogate model.
for example the refinement activity may also change the configuration of aristeo.
this is a rather drastic change in the surrogate model.
when engineers have a clear understanding of the underlying model they may be able to define a systematic methodology on how to move from less complex structures e.g.
linear to more complex ones e.g.
non linear .
without proper domain knowledge such modification may be too disruptive.
in this paper our refinement strategy is focused on incrementing the training data and rebuilding the surrogate model without changing the configuration.
evaluation in this section we empirically evaluate aristeo by answering the following research questions configuration rq1.
which are the optimal most effective and efficient si configurations for aristeo?
which of the optimal configurations can be used in the rest of our experiments?
we investigate the performance of aristeo for different si configurations model structures and parameters listed in table to identify the optimal ones i.e.
those that offer the best trade offs between effectiveness revealing the most requirements violations and efficiency revealing the violations in less time .
we then select one configuration among the optimal ones and use that configuration for the rest of our experiments.
377testing compute intensive cyber physical systems icse may seoul republic of korea effectiveness rq2.
how effective is aristeo in generating tests that reveal requirements violations?
we use aristeo with the optimal configuration identified in rq1 and evaluate its effectiveness i.e.
its ability in detecting requirements violations by comparing it with falsification based testing without surrogate models.
we use s taliro discussed in section for the baseline of comparison.
efficiency rq3.
how efficient is aristeo in generating tests revealing requirements violations?
we use aristeo with the optimal configuration identified in rq1 and evaluate its efficiency i.e.
the time it takes to find violations by comparing it with falsificationbased testing without surrogate models i.e.
s taliro .
a key challenge regarding the empirical evaluation of aristeo is that both aristeo and s taliro rely on randomized algorithms.
hence we have to repeat our experiments numerous times for different models and requirements so that the results can be analysed in a sound and systematic way using statistical tests .
this is necessary to answer rq1 rq3 that involve selecting an optimal configuration and comparing aristeo with the baseline staliro.
performing these experiments on ci cps models is however extremely expensive to the point that the experiments become infeasible.
a ballpark figure for the execution time of the experiments required to answer rq1 rq3 is around years if the experiments are performed on our ci cps model case study sat ex .
therefore instead of using ci cps models we use non ci cps models to address rq1 rq3.
the implications of this decision on the results are assessed and mitigated in sections .
and .
where we discuss these three research questions in detail.
in addition to be able to still assess the performance of aristeo on ci cps models we consider an additional research question described below usefulness rq4.
how applicable and useful is aristeo in generating tests revealing requirements violations for industrial ci cps models?
we apply aristeo with the optimal configuration identified in rq1 to our ci cps model case study from the satellite industry sat ex and evaluate its effectiveness and efficiency.
the focus here is to obtain representative results in terms of effectiveness and efficiency based on an industry ci cps model.
note that we still apply s taliro to sat ex to be able to compare it with aristeo for an industry ci cps model.
this comparison however is not meant to be subject to statistical analysis due to the large execution time of sat ex and is only meant to complement rq3 with a fully realistic though extremely time consuming study.
the subject models.
we used five publicly available non cicps models i.e.
rhb rhb at afc igc that have been previously used in the literature on falsification based testing of cps models .
the models represent realistic and representative models of cps systems from different domains.
rhb and rhb are from the iot and smart home domain.
afc is from the automotive domain and has been originally developed by toyota.
at is another model from the automotive domain.
igc is from the health care domain.
at and afc have also been recently considered as a part of the reference benchmarks in the arch competition an international competition among verification and testing tools for continuous and hybrid systems .
the models include both discrete e.g.
logic decisions and state machines and continuous e.g.
dynamical systems behaviors.
for example rhb and at contain state machines represented as stateflows diagrams .
stateflow specificationscan represent logical decisions such as the one produced by a planner i.e.
sequences of states and transitions labeled with movement commands .
these models have been manually developed and may violate their requirements due to human errors.
some of the violations have been identified by the existing testing tools and are reported in the literature .
regarding the ci cps model to address rq4 we use the sat ex case study that we introduced as a running example in sections and .
sat ex contains blocks and has to be simulated for 24h for each test case to sufficiently exercise the system dynamics and interactions with the environment.
the sat ex case study is a complex industrial system that includes physical dynamics and control algorithms but also complex logic and decisions.
for example the satellite includes a function that controls the hysteresis logic that regulates the switching between the course and the fine pointing laws of the satellite a kalman filter to estimate the position of the satellite logic that controls the normal and safe modes of the satellite complex functions that go beyond reading and retrieving sensors readings and pre compiled s functions provided by third parties vendors.
like the non ci cps models sat ex is manually developed by engineers and is likely to be faulty.
its inputs and input profiles are shown in table .
implementation and data availability.
we implemented aristeo as a matlab application and as an add on of s taliro.
our sanitized models data and tool are available online and are also submitted alongside the paper.
.
rq1 configuration recall that aristeo requires to be provided with a configuration to build surrogate models.
the universe of the possible configurations is infinite as the model structures in table can be parametrized in an infinite number of ways by associating different values to their parameters.
rq1 identifies the optimal configurations that yield the best tradeoff between effectiveness and efficiency for aristeo among a reasonably large set of alternative representative configurations.
it then selects one among the optimal configurations.
we do not evaluate configurations by measuring their prediction accuracy i.e.
by measuring their prediction error when applied to a set of test data as is common practice in assessing prediction models in the machine learning area because our focus is not to have the most accurate configuration but the one that is able to have the most effective impact on aristeo s approximation refinement loop by quickly finding requirements violations.
however it is likely that there exists a relationship between the two.
experiment design.
we consider five different configurations obtained by five different sets of parameter values for each model structure in table .
we denote the five configurations related to each model structure sbys1tos5.
for example the configurations related to the model structure ssare denoted by ss1toss5.
the specific parameter value sets for the configurations based on the seven model structures in table are available online .
to answer rq1 we apply aristeo to the five non ci cps models using each configuration among the possible ones.
that is we execute aristeo times.
we further rerun each application of aristeo times to account for the randomness in both falsification based testing and the approximation refinement loop 378icse may seoul republic of korea claudio menghi shiva nejati lionel briand and yago isasi parache number of iterations efficiency effectiveness percentage of successful runsbj1ss2 arx1arx2arx3arx4arx5 armax1armax2armax3armax4armax5 bj1bj2bj3bj4bj5 tf1tf2tf3tf4tf5 ss1ss2ss3ss4ss5 nlarx1nlarx2nlarx3nlarx4nlarx5 hw1hw2hw3hw4hw5 figure effectiveness and efficiency of different configurations across our non ci cps subject models.
of aristeo .
we set the value of max ref i.e the number of iterations of the aristeo s main loop to see algorithm and the value of max i.e the number times each iteration of aristeo executes falsification based t esting see a lgorithm t o for rhb rhb and afc and to for at and igc.
these values were used in the original experiments that apply falsification based testing to these models .
running all the experiments required s econds days .
due the sheer size of the experiments required to answer rq1 we used our non ci cps subject models.
while these models are smaller than typical ci cps models the complexity of their structure how simulink blocks are used and connected is similar to the one of sat ex.
sp ecifically the structural complexity index which provides an estimation of the complexity of the structure of a simulink model is .
.
.
.
.
for the rhb rhb at afc and igc benchmarks respectively and .
for the sat ex case study.
we conjecture that given these similarities the efficiency and effectiveness c omparisons o f t he c onfigurations performed on non ci cps models would likely remain the same should the comparisons be performed on ci cps models.
however due to computational time restrictions we are not able to check this conjecture.
finally we note that even if we select a sub optimal configuration it will be a disadvantage for aristeo.
so the results for rq2 rq4 are likely to improve if we find a way to identify a better configuration for aristeo using ci cps models.
results.
the scatter plot in figure shows the results of our experiments.
the x axis indicates our efficiency me tr ic wh ich is defined as the number of iterations that aristeo requires to reveal a requirement violation in a model for a given configuration.
as 2we used the high performance hpc facilities of the university of luxembourg with 100dell poweredge c6320 and a total of cores with .
tb ram.
the parallelization reduced the experiments time to approximately 15days.described in the experiment design the maximum number of iterations is .
given a configuration for aristeo the fewer iterations required to reveal a violation the more efficient that configuration is.
the y axis indicates our effectiveness metric which is defined as the number of aristeo runs out of that can reveal a violation in a model.
for effectiveness we are interested in knowing how often we are able to reveal a requirement violation.
the higher the number of runs detecting violations the more effective that configuration is.
the ideal configuration is the one that finds requirements violations in of the runs in just one iteration as indicated by the origin of the plot in figure with coordinates .
for each configuration there is one point in the plot in figure whose coordinates respectively indicate the average efficiency and effectiveness of that configuration for the non ci cps subject models.
as shown in the figure bj 1and ss 2are on the pareto frontier and dominate other configurations in terms of efficiency and effectiveness.
that is any configuration other than bj 1and ss 2is strictly dominated in terms of both efficiency and effectiveness by either bj 1or ss .
but bj 1does not dominate ss and neither does ss .
specifically bj 1is more efficient but less effective than ss and ss is less efficient but more effective than bj .
for our experiments we select bj 1as the optimal configuration since efficiency is paramount when dealing with ci cps models.
in terms of effectiveness bj 1is only slightly less effective than ss .
versus .
.
the answer to rq1 is that among all the configurations we compared the bj 1and the ss 2configurations are the optimal configurations offering the best trade off between efficiency i.e.
time required to reveal requirements violations and effectiveness i.e.
number of violations revealed for aristeo.
we select bj 1as we prioritize efficiency.
.
rq2 and rq3 effectiveness and efficiency for rq2 and rq3 we compare aristeo algorithm with s taliro algorithm .
as discussed earlier due to the large size of the experiments we use non ci cps models but we want to obtain results that are representative for the ci cps case.
for such comparisons we need to execute both tools for an equivalent amount of time and then compare their effectiveness and efficiency.
this is a non trivial problem because that equivalent amount of time cannot simply translate into identical execution times.
non ci cps models by definition are very quick to execute.
hence the benefits of performing the falsification on the surrogate model as done by aristeo would not be visible if we compared the two tools based on the execution times of non ci cps models.
therefore comparisons would be in favour of s taliro if we fix the execution times of the two tools for non ci cps models.
neither can we can run the two tools for the same number of iterations as commonly done in this domain because one iteration of aristeo takes more time than one iteration of s taliro.
recall that aristeo in addition to performing falsification builds and refines surrogate models in each iteration.
thus by fixing the number of iterations for the two tools comparisons would be in favour of aristeo.
to answer rq2 and rq3 without favouring neither of the tools we propose the following 379testing compute intensive cyber physical systems icse may seoul republic of korea table the effectiveness results.
percentages of cases in which aristeo ia ilabelled columns and s taliro ib ilabelled columns were able to detect requirements violations for different iteration pairs ia iand ib i and benchmarks.
ia1 ib1 ia2 ib2 ia3 ib3 ia4 ib4 ia5 ib5 ia6 ib6 rhb rhb at afc igc suppose that we could perform rq2 andrq3 on a ci cps model and that we execute aristeo and s taliro on this model for the same time limit tl.
let iaandibbe the number of iterations of aristeo and s taliro within tl respectively.
recall that one iteration of aristeo typically takes more time than one iteration of the baseline ia ib .
if we know the values of iaandib we can execute aristeo iatimes and s taliro ibtimes on non ci cps models and use the results to compare the tools as if they were executing on ci cps models.
to run our experiment we need to know the relation between ia andib.
we approximate this relation empirically using our sat ex ci cps model.
we execute aristeo for 10iterations and we set the number of falsification iterations in each iteration of aristeo to 100as suggested by the literature on cps falsification testing i.e.
max ref and max 100in algorithm .
we repeated these runs of aristeo five times.
the first iteration of aristeo took on average 902s and the subsequent iterations of aristeo took on average 865s.
note that the first iteration of aristeo is always more expensive than the subsequent iterations since aristeo builds surrogate models in the first iteration.
similarly we executed s taliro for iterations on sat ex and repeated this run five times.
each iteration of s taliro took on average 336s on sat ex .
this preliminary experiment took approximately days.
we then solve the two equations below to approximate the relation between iaandib tl ia tl ib the above yields ib .
ia .
.
though we obtained this relation between ia and ib based on one ci cps case study sat ex is a large and industrial system representative of the cps domain.
further for ci cps models that are more compute intensive than sat ex executing the models takes even more time compared to the approximation and refinement time and hence the relation above could be further improved in favour of aristeo.
experiment design.
to answer rq2 and rq3 we applied aristeo with the configuration identified by rq1 bj1 and staliro to the five non ci cps models in table .
we executed aristeo and s taliro for the following pairs of iterations ia1 ib1 ia2 ib2 ia3 ib3 ia4 ib4 ia5 ib5 and ia6 ib6 .
note that every pair approximately satisfies ibi .
iai .
.
we repeated each run times to account for their randomness.
for rq2 we compute the effectiveness metric as in rq1 the number of runs revealing requirements violations out of for each tool.
for rq3 we assess efficiency by computing the efficiency metric as in rq1 the number of iterations that each tool requires to reveal arequirement violation.
however as discussed above the number of iterations of aristeo and s taliro are not comparable.
hence for rq3 we report efficiency in terms of the estimated time that each tool needs to perform those iterations on ci cps models computed using equations and .
results rq2.
table shows the effectiveness values for aristeo and s taliro for the five iteration pairs discussed in the experiment design.
for the at afc and igc models the average effectiveness of aristeo is significantly higher than that of staliro .
versus .
on average across benchmarks while for rhb and rhb aristeo and s taliro reveal almost the same number of violations .
versus .
on average across benchmarks .
the former difference in proportion is statistically significant as confirmed by a two sample z test with the level of significance set to .
.
rhb and rhb have more outputs than the other benchmarks and they have shorter simulation times see table .
this is an increased challenge for building accurate surrogate models.
in practice ci cps models can have a large number of outputs but they usually involve long simulation times.
the answer to rq2 is that the selected configuration of aristeo is significantly more effective than s taliro for three benchmark models while for the other two models they reveal almost the same number of violations.
on average over the five models aristeo detects .
more requirements violations than s taliro min max .
results rq3.
the execution times computed using equations and of aristeo and s taliro for our non ci cps subject models and the iteration pairs iai ibi are shown in figure .
the box plots in the same row are related to the same benchmark model while the box plots in the same column are related to the same iteration pair.
recall that we described the iteration pairs iai ibi considered for our experiments earlier in the experiment design subsection.
as expected the average execution times of the two tools increases with their number of iterations.
to statistically compare the results we used the wilcoxon rank sum test with the level of significance set to .
.
the results show that aristeo is significantly more efficient than s taliro for the at and igc models figure rows .
the efficiency improvement that aristeo brings about over s taliro for at and igc across different iterations ranges from .
.2h to .
.2h .
note that for at and igc aristeo is significantly more effective than s taliro see table .
this shows that many runs of aristeo for at and igc can reveal a requirement violation and stop before reaching the maximum ten iterations hence yielding better efficiency results of aristeo compared to the other model.
for the rhb and rhb models figure rows aristeo and s taliro yield comparable efficiency results.
the effectiveness results in table confirm that for rhb and rhb both aristeo and s taliro have to execute for ten iterations most of the times as they cannot reveal violations low effectiveness .
hence the efficiency results are worse for rhb and rhb than for the other models.
further as we run the tools for more iterations the efficiency results slightly increases as indicated by the increase in the number of outliers.
for the afc model figure row aristeo is slightly more efficient than s taliro.
for afc s taliro 380icse may seoul republic of korea claudio menghi shiva nejati lionel briand and yago isasi parache aristeo s taliro01020rhb time h ia1 ib1 aristeo s taliro01020rhb time h aristeo s taliro01020at time h aristeo s taliro01020afc time h aristeo s taliro01020igc time h aristeo s taliro01020ia2 ib2 aristeo s taliro01020 aristeo s taliro01020 aristeo s taliro01020 aristeo s taliro01020aristeo s taliro0102030ia3 ib3 aristeo s taliro0102030 aristeo s taliro0102030 aristeo s taliro0102030 aristeo s taliro0102030aristeo s taliro020ia4 ib4 aristeo s taliro020 aristeo s taliro020 aristeo s taliro020 aristeo s taliro0102030aristeo s taliro02040ia5 ib5 aristeo s taliro02040 aristeo s taliro02040 aristeo s taliro02040 aristeo s taliro02040aristeo s taliro02040ia6 ib6 aristeo s taliro02040 aristeo s taliro02040 aristeo s taliro02040 aristeo s taliro02040 figure comparing the efficiency of aristeo and s taliro.
the box plots show the execution time computed using equations and of aristeo and s taliro in hours for our non ci cps subject models labels on the left of the figure and over different iterations labels on the top of the figure .
diamonds depict the average.
is relatively effective in finding violations and hence is efficient.
but its average execution time is slightly worse than that of aristeo.
comparing the interquartile ranges of the box plots shows that aristeo is generally more efficient that s taliro.
however a wilcoxon test does not reject the null hypothesis p value .
.
the average execution time of aristeo and s taliro across the different models is respectively approximately 19h and 25h.
though there is significant variation across the different models aristeo is on average .
more efficient than s taliro.
the answer to rq3 is that for the considered models the selected configuration of aristeo is on average .
min .
max .
more efficient than s taliro.
.
rq4 practical usefulness we assess the usefulness of aristeo in revealing requirements violations of a representative industrial ci cps model.
experiment design.
we received three different requirements from our industry partner .
one is the satreq requirement presented in section and the two others satreq1 and satreq2 are strengthened versions of satreq that if violated indicate increasingly critical violations.
we also received the input profile ip section and a more restricted input profile ip representing realistic input subranges associated with more critical violations.
for each combination of the requirement satreq satreq1 and satreq2 and the input profiles ip and ip we checked whether aristeo was able to detect any requirement violation and further we recorded the time needed by aristeo to detect a violation.
in addition for the two most critical requirements satreq1 and satreq2 and the input profiles ip and ip we checked whether s taliro is able to detect any violation within the time limit required by aristeo tosuccessfully reveal violations for satreq1 and satreq2.
running this experiment took approximately four days and both tools were run twice for each requirement and input profile combination.
results .
aristeo found a violation for every requirement and input profile combination in our study in just one iteration requiring approximately four hours of execution time.
given that simulating the model under test takes approximately an hour and a half detecting errors in four hours is highly efficient as it corresponds to roughly two model simulations.
in comparison s taliro failed to find any violations for satreq1 and satreq2 after running the tool for four hours based on the input profiles ip and ip .
the answer to rq4 is that aristeo efficiently detected requirements violations in practical time that s taliro could not find for three different requirements and two input profiles on an industrial ci cps model.
discussion and threats to validity external validity.
the selection of the models used in the evaluation because of the specific features they contain is a threat to external validity as it influences the extent to which our results can be generalized.
in the future it is therefore important to evaluate aristeo with a larger more diverse set of models which vary in terms of complexity along different dimensions such as control algorithms physical dynamics state behavior logic and decisions.
we may over time be able to determine the characteristics of models on which aristeo fares better.
however below we note some facts which tend to alleviate the threat to external validity in our results the non ci cps models see section we considered have been widely used in the literature on falsification based testing of cps as they represent 381testing compute intensive cyber physical systems icse may seoul republic of korea realistic and representative models of cps systems from different domains our ci cps model is a complex model of a satellite system and environment see section developed by our industry partner and is representative of industrial systems containing complex algorithms equations logic and decisions.
it also includes third party components with unknown features that are provided as pre compiled functions aristeo is obtained by combining system identification si with falsification and abstraction refinement.
the goal of si is not to produce a model that accurately predict the system outputs but a model that is sufficiently accurate to allow aristeo to detect faulty inputs.
thus in order for aristeo to perform well the model learned by si does not need to be perfect in predicting the behaviour of the mut.
consequently there is no straightforward relationship between si prediction accuracy and the performance of aristeo.
in other words even if the predictions of the models produced by si are not perfectly accurate they may still be sufficient for guiding the search of aristeo toward faulty inputs.
more empirical studies such as that presented in this paper are needed to precisely determine the characteristics of models on which aristeo fares better.
internal validity.
when addressing rq2 and rq3 the use of an optimal configuration is a threat to internal validity as it maximizes on average the effectiveness and efficiency of aristeo on the considered set of models.
however a number of considerations alleviate this threat.
first the configuration of aristeo is not individually optimized for each model but for all models at once.
it represents a general compromise among the many diverse models based on which it was selected.
this configuration based on our experiment therefore represents a good default configuration when engineers do not have additional information.
furthermore all the configuration parameters of aristeo which are common with s taliro have been assigned the same values s taliro is therefore in our comparisons not at a disadvantage due to sub optimal configuration values.
last because it is compute intensive the satellite model used to address rq4 was not part of the model set used for selecting the configuration of aristeo.
rq4 yields results that are consistent with previous rqs.
in fact the results for rq4 are likely to improve if we find a way to identify a better configuration for aristeo using ci cps models.
related work formal verification techniques such as model checking aim to exhaustively check correctness of behavioural functional models e.g.
but they often face scalability issues for complex cps models.
the cegar framework has been proposed to help model checking scale to such models e.g.
.
as discussed in section the approximationrefinement loop of aristeo at a general level is inspired by cegar.
two cegar based model checking approaches have been proposed for hybrid systems capturing cps models a abstracting hybrid system models into discrete finite state machines without dynamics and b abstracting hybrid systems into hybrid systems with simpler dynamics .
these two lines of work although supported by various automated tools e.g.
are difficult to use in practice due toimplicit and restrictive assumptions that they make on the structure of the hybrid systems under analysis.
further due to their limited scalability they are inadequate for testing ci cps models.
for example ratschan proposes an approach that took more than 10h to verify the rhb benchmark a non ci cps model also used in this paper .
in contrast our technique tests models instead of exhaustively verifying them.
being black box our approach is agnostic to the modeling language used for mut and hence is applicable to simulink models irrespective of their internal complexities.
further as shown in our evaluation our approach can effectively and efficiently test industrial ci cps models.
there has been earlier work to combine cegar with testing instead of model checking e.g.
.
however based on a recent survey on the topic aristeo is the first approach that combines the ideas behind cegar with the system identification framework to develop an effective and efficient testing framework for ci cps models.
non cegar based model testing approaches for cps have been presented in the literature and are supported by tools .
among these we considered s taliro as a baseline for the reasons reported in section .
zhang et al.
reduce the number of simulations of the mut by iteratively evaluating different inputs for short simulation times and by generating at each iteration the next input based on the final state of the simulation.
this approach assumes that the inputs are piecewise constants and does not support complex input profiles such as those used in our evaluation for testing our industry ci cps model.
to reduce the simulation time of ci cps models we can manually simplify the models while preserving the behaviour needed to test the requirements of interest .
however such manual simplifications are error prone and reduce maintainability .
further finding an optimal balance between accuracy and execution time is a complex task .
conclusions we presented aristeo a technique that combines testing with an approximation refinement loop to detect requirements violations in ci cps models.
we implemented aristeo as a matlab simulink application and compared its effectiveness and efficiency with the one of s taliro a state of the art testing framework for simulink models.
aristeo finds .
more violations than s taliro and finds those violations in .
less time than s taliro.
we evaluated the practical usefulness of aristeo on two versions of an industrial ci cps model to check three different requirements.
aristeo successfully triggered requirements violations in every case and required four hours on average for each violation while s taliro failed to find any violations within four hours.