finding broken linuxconfiguration specifications bystatically analyzing the kconfiglanguage jeho oh universityof texasat austin austin tx usa jeho.oh utexas.edunecip faz ly ld ran universityof centralflorida orlando fl usa yildiran knights.ucf.edu julianbraha universityof central florida orlando fl usa julianbraha knights.ucf.edupaul gazzillo universityof centralflorida orlando fl usa paul.gazzillo ucf.edu abstract highly configurablesoftwareunderpinsmuchofourcomputing infrastructure.itenablesextensivereuse butopensthedoortobrokenconfigurationspecifications.theconfigurationspecification language kconfig is designed to prevent invalid configurations of the linux kernel from being built.
however the astronomical sizeoftheconfigurationspaceforlinuxmakesfindingspecification bugs difficult by hand or with random testing.
in this paper weintroduceasoftwaremodelcheckingframeworkforbuilding kconfig static analysis tools.
we develop a formal semantics of thekconfiglanguageandimplementthesemanticsinasymbolic evaluator called kclause that models kconfig behavior as logical formulas.
we then design and implement a bug finder called kismet that takes kclause models and leverages automated theoremprovingtofindunmetdependencybugs.
kismetisevaluated for its precision performance and impacton kernel development for a recent version of linux which has over lines of kconfig across architecture specific specifications.
our evaluation finds781bugs 151whenconsideringsharingamongkconfigspecifications with100 precision spendingbetween37and90minutes for eachkconfig specification althoughit missessome bugs due to underapproximation.comparedtorandomtesting kismetfinds substantially more true positive bugsinafractionofthe time.
ccs concepts softwareanditsengineering softwareconfigurationmanagementandversioncontrolsystems automatedstaticanalysis software testinganddebugging .
keywords software configuration kconfig formal verification static analysis co firstauthors.
permissionto make digitalor hard copies of allorpart ofthis work for personalor classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation onthefirstpage.copyrights forcomponentsofthisworkownedbyothersthanthe author s mustbehonored.abstractingwithcreditispermitted.tocopyotherwise or republish topostonserversortoredistributetolists requirespriorspecificpermission and or a fee.
request permissions from permissions acm.org.
esec fse august 23 28 athens greece copyright heldby the owner author s .
publicationrightslicensed to acm.
acm isbn ... .
format jehooh necipfaz ly ld ran julianbraha andpaulgazzillo.
.finding broken linux configuration specifications by statically analyzing the kconfig language.
in proceedings of the 29th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse august 23 28 athens greece.
acm new york ny usa 13pages.
introduction highly configurablesoftware productlines underpin much ofour computing infrastructure because configurability enables reuse without having to reprogram the software for new devices or applications.
the linux kernel is one such example of highlyconfigurable software that is used in billions of computing devices.
withover15 000configurationoptionscontrollingeverythingfrom drivers architecture memory management and more there are over215 000combinations ifonlyconsideringbooleanoptions.this extremeconfigurabilitymakesitswidespreadusepossible butalso opens the door to invalid configurations which produce broken variations ofthe software.
to mitigate the chance of misconfiguration developers provide configurationspecifications whichdefinetheintendedcombinations ofconfiguration options.
thesespecificationsmay be as simpleas a text file describing configuration instructions or as sophisticated asamachine readablespecificationenforcedatbuildtime.these specifications if only implicitly define a software product line s featuremodel i.e.
thelegalconfigurationsofthesoftware.inlinux and other systems software such as busybox and coreboot developersusethekconfiglanguagetospecifyconfigurationoptions as well as theirdependencies.
while linux is effectively a software product line its specification language kconfig is unlike typical feature modeling languages .
kconfig has complex semantics and additional language features such as invisible variables automated option selection anduser interfacesupport.withover140 000linesofkconfig specifications in the linux kernel its complex behavior makes maintenance challenging.
one example is the common pitfall highlighted in kconfig s manual theunmet dependency bug .
these bugs lead to illegal configurations when developers unwittingly mixconflictingconstructsindependencyspecifications.withthousands of potentially vulnerable constructs and an ever changing esec fse august athens greece jehooh necip faz l y ld ran julian braha andpaulgazzillo specification finding such bugs by hand is a practically impossible task.
existingworkontheanalysisofkconfigisfocusedonextracting a feature model rather than checking for kconfig bugs.
having alinuxfeaturemodelhasbeenusefulforapplicationsoutsideof kconfig includingmeasuringfeaturemodelhierarchies supportingvariability awareanalysisofc anddeadcodeelimination .however thesetools makeassumptionsaboutkconfigsemanticsthat whileappropriate fortheirrespectiveapplications makethemlessamenabletobug finding.
for instance kconfigreader explicitly omits modeling the language semantics that lead to unmet dependencies leaving a checker as a separate problem .
the other tools do the sameandhavelesssupportforkconfigsemantics omittingsome partsofthelinux featuremodelaltogether .moreover by focusingonfeaturemodeling priortoolsbakeindecisionsabout theanalysisdomain i.e.
afeaturemodel whichlimitsthefeasibility of repurposing the work for kconfig bug finding and other source level tools.
inthispaper weintroduceasoftwaremodelcheckingframework for building kconfig static analysis tools.
inspired by model checkingframeworksforprogramcode webaseourstaticanalysison ournewly developedformalsemanticsofthekconfiglanguageand leverage automated theorem proving to model kconfig behavior andfindbugs.ofexistingdescriptionsofkconfigsemantics allbut one are either informal or example based which having no formalization are not amenable to automated reasoning.
the one prior formal semantics uses an idealized kconfig syntax rather thankconfig sactualgrammar ismissinglanguagebehavior including that leading to unmet dependencies and uses an abstract domaindesignedforfeaturemodeling .incontrast wedevelop a formal semantics of the concrete behavior of kconfig when it checks a configuration file s validity.
we define our semantics over the syntax derived from kconfig s actual implementation which contains a bisongrammarspecification.
this approach to kconfig semantics has three key benefits over prior efforts.
first it is formal making it possible to use automated reasoningtools.second itisconcrete whichdecouplesthedescription of kconfig semantics from any particular analysis objective.
this leaves decisions about how to abstract kconfig behavior to specific applications and should reduce future effort to design new kconfig analyses.
third it simplifies modeling kconfig since as we show we can methodically derive an abstraction of kconfig behaviorfrom this concrete semantics.
todemonstratetheutilityofourapproach wedesignandimplementananalysisthatfindstheunmetdependencybugshighlighted inkconfig s manualandis toour knowledge thefirststatic analysis for finding such bugs.
we first define the bug as a formal propertyintermsofthesemantics thenshow howacheckercan bemethodicallyderivedfromthesemantics.weunderapproximate non boolean options and use aggressive optimization to yield a bug finder that isboth fast and very precise.
moreover itcan also automatically localize and generate test cases for the unmet dependency bugs it finds.
the trade off is decreased recall due to false negatives althoughweshowthatthesearelesscommonduetothe rarity ofnon boolean options.weimplementthebug finderandevaluateitonarecentversion of the linux kernel source which contains over lines of kconfigdescribing28architecture specifickconfigspecifications.
our results show that our bug finding is both precise and fast.
the bug finder finds alarms when considering sharing amongkconfigspecifications overalllinuxkernelarchitectures kconfig specifications all of which are verified true positives for a precisionof100 .whilesuchprecisionmightbeunusuallyhigh foraprogramminglanguageanalyzer thekconfiglanguagehasno iteration or recursion that would require overapproximation.
with ouroptimizations ourbugfindertakesanaverageof40minutes for one kconfig specification checking over 000constructs.
while we are still in the process of reporting all bugs found by our tool linux maintainers have so far already confirmed ofourreportsandcommitted15ofourpatchesintothemainline linux kernel repository demonstratingthe utility ofourtooling.
committingpatchesisamanualprocess requiringdiscussionwith kernel maintainers so investigating reporting and submitting patchesfor the alarms isongoing.
since to our knowledge no other static bug finder for unmet dependencies exists we compare to kconfig s built in randconfig tool thede factostandardrandomconfiguration testingtoolused bylinuxmaintainersandtheintel0 daytestservice .giventhe sameamountoftimetofindbugs randconfig yieldsonly98alarms comparedtoourtool s781.evenlettingrandomtestingrunforover fourdaysforeachkconfigspecification 135xlongerthanourtool s totaltime the testingapproach stillonlyfinds 175bugs farfewer than our tool.
the random testing approach did find eight bugs missedbyourtool reflectingthetradeoffinperformancegained by underapproximation.
even with this limitation ourtoolfinds manymorebugswhiletakingfarlesstime ausefulcomplementto testing.
in summary this paper makes the following contributions a formal semantics of kconfig s concrete behavior section3 .
anefficientdesignofabug finderandlocalizerforunmet dependency bugs section .
an implementation of the bug finder along with reusable componentsfor creating kconfig analyzers section .
an experimental evaluation of the bug finder s precision performance andimpact section .
overview in this section we introduce the kconfig language illustrate an unmet dependency bug and summarize how our formal semantics enables the designofastaticanalysisto find such bugs.
.
introductionto thekconfiglanguage figure1isasimplifiedsnippetofkconfigfromlinuxv5.
.
.configurationoptionsaredefinedwiththe configconstruct lines and12 .insideeach configdeclarationisablockofconstructs thatdefinetheoption stype e.g.boolean constraintsonitsuse andtextusedbykconfig to populate auserinterface.
lines2 and13arethetypedeclarations.a booloption line hastwopossiblesettings yorn.ymeansthefeatureisonandcompiled into the kernel and nmeans the feature is off and omitted 894finding broken linuxconfigurationspecificationsby staticallyanalyzingthe kconfig language esec fse august athens greece 1configtouchscreen adc tristate prompt generic adc based touchscreen depends on iio input touchscreen selectiio buffer cb 7configiio buffer bool prompt enable buffer support within iio depends on iio 12configiio buffer cb tristate prompt iio callback buffer depends on iio iio buffer figure an example kconfig specification that allows an unmet dependency violation and leads to a build error.
adapted from linux source drivers input touchscreen kconfig drivers iio kconfig anddrivers iio buffer kconfig.
fromthekernel.a tristate option lines 2and13 addsanadditionalsetting m.mislikeyexceptthatthebuildsystemcompiles a loadable kernel module instead of linking to the main kernel binary .
tristate andboolarethemostcommonconfigurationoptions representingmore than95 of options inthe linux kconfigspecifications.theotherpossibletypesare stringforstrings intfor decimal integers and hexfor hexadecimal numbers.
constraints on options are defined using depends on lines4 and15 andselect line5 but the kconfig language prohibits circular dependencies.
depends on defines a direct dependency whichprovidesrequirementsthatshouldholdbeforetheoptioncan beenabled.thedependencyisexpressedwithabooleanexpression ofotheroptions.forinstance line 4meansthat touchscreen adc may not be enabled unless iio input touchscreen is true i.e.
when both iioandinput touchscreen are alsoenabled.
areversedependency givenbythe selectconstruct invertsthe dependencyrelationshipbyforcingthetargetoftheselecttobeenabled.
for instance line 5means that whenever touchscreen adc is enabled iio buffer cb is forced to be enabled.
a reverse dependencycanonlyenableanotheroption notdisableit andonly applies to boolortristate options.kconfig permits reverse dependencies to override direct dependencies which can lead to unmet dependency bugs.
optionswithapromptare visibleoptionsthatausermayenable.
thepromptconstruct defines the prompt string for use in a user interface lines and14 .non visibleoptions i.e.
thosewithno promptconstruct canonlybe set by a selectconstruct ortakea specification defineddefaultvalue notshowninthisexample .the visibility of an option affects the behavior of a configconstruct in subtle ways which we describe in the formal semantics of kconfig.anunmetdependencybuginthewild.
figure1hasanunmetdependencybugfoundbyourautomatedanalysis.allthreeoftheconfigurationoptionsdefinedinthisexample controlspecificccompilationunitsthatareonlybuiltintothekernelwhentheoptionsare enabled.iio buffer cb controlsindustrialio buffer cb.o and iio buffer controlindustrialio buffer.o .
industrialio buffer cb.o calls functions that are defined in industrialio buffer.o so the former cannot be built without thelatter otherwisetherewouldbeabuilderror.thedevelopers capture this build dependency with a direct dependency in the definitionofthe iio buffer cb option line .thisconstraint by itself would prevent a user from giving a configuration that leads to the builderror.
theselect iio buffer cb constructonline however can overridethisdirectdependencyundercertainconditions.specifically if auser oranother select enables touchscreen adc the selectautomaticallyforce enables iio buffer cb .kconfigpermitssuchaconfigurationtoproceedtobuild albeitwithawarning.
still the build will fail and the userwill have to manually correct theirconfigurationfile inorder to avoid the unmet dependency.
whilethekconfigdocumentationwarnsof select spitfallsand recommends not using it to override dependencies it is difficult tocheckbyhandwhetheranyofits17 useshaveanunmet dependency bug.
.
anunmetdependenciesbug finder we create a formal model of the unmet dependency bug according tothesemanticsofkconfig.first wemodelthespaceofvalidkconfig configurations in formal logic automatically with our symbolic evaluator kclause.
next kismetgenerates verification conditions to prove the absence of an unmet dependency for each select construct in the kconfig specification.
not all reverse dependencies can cause unmet dependencies so kismetneeds to consider constraints from all configuration options to rule out infeasible ones.
the resulting verification conditions are discharged to the z3smtsolver .
when anunmet dependencycannotbe ruled out kismetraises an alarm.
it then switches to test case generation converting any counterexamples to linux configuration files.
kismetuses these tests on kconfig and the build system to expose real bugs.
toseehow kclause modelsdependencies takefigure sdefinitionoftouchscreen adc line1 .sinceithasnoreversedependencies it can only be enabled when its direct dependencies hold i.e.
enabling touchscreen adc impliesiioandinput touchscreen are alsoboth enabled touchscreen adc iio input touchscreen when an option has reverse dependencies its direct dependencies do not have to hold if its reverse dependencies already do.
for instance enabling iio buffer cb line12 impliesthatitsdirect orreversedependencies hold iio buffer cb iio iio buffer touchscreen adc anunmetdependencyhappenswhenanoption sreversedependencies hold but its direct dependencies do not.
for instance an unmetdependencyhappenswhen touchscreen adc force enables 895esec fse august athens greece jehooh necip faz l y ld ran julian braha andpaulgazzillo kconfig statement statement config choice config configsymbol type constrnts select choice choicetype constrnts config endchoice type bool tristate constrnts prompt depends default prompt promptwordifexpr default default valifexpr depends depends on expr select selectsymbolifexpr expr expr expr expr expr !expr symbol val y n figure formalsyntaxofacore fragment ofkconfig.
iio buffer cb even though iio buffer cb s direct dependencies are infeasible.
this unmet dependency can be formalized as follows touchscreen adc iio input touchscreen iio buffer cb iio iio buffer kismettriestoprovethe negationofthiscondition sinceitverifies theabsenceofunmetdependencies.iftheprooffails kismetraises an alarm andswitchesto test casegeneration.
the semantics ofkconfig thekconfiglanguageisadeclarativeconfigurationspecification language.at its core kconfig takes aconfigurationfile which is a mapping from configuration options to their concrete values and determines whether the configuration file is valid according to the developer s specifications.
developers use kconfig language constructstodefineconfigurationoptions declaringtheirnames types and any dependencies they have on other configuration options.
kconfig also supports user interfaces and the language has additional constructs such as help to specify text elements of theinterface.thesedonotaffectthebuildabilityofconfiguration filesandactas comments.
we developed this formal semantics by studying the kconfig manual kconfig ssourcecode aswellasinformaldescriptionsand examplesfrompriorwork .tocheckthefidelityofthesemantics we used new and existing benchmarks generated randomconfigurationfilesfedtokconfigasinput andevaluated thispaper sbug finder whichrequiresacorrectsemanticsforits analysistobeprecise.giventhesizeofthesemantics havingdozens of rules and still more syntactic sugar rules we highlight a core fragment of the language here and documentthe remaining rules inan openly archivedformalsemantics .
.
configurationdeclarations figure2shows the syntax of a core fragment of the kconfig language for boolconfiguration options.
a kconfigfile contains a list ofstatement s which are either a configuration option declaration orachoiceconstruct.aconfigurationoption config hasatype constraints for direct dependencies and zero or more selectconstructs for reversedependencies.figure3adefines the semantic valuation function sfor statements.sfunctions take an immutable configuration file as input and return whether the configuration is validorinvalid i.e.
buildable or not.
s1evaluates a kconfig specification s list of statementsbycheckingwhetherallstatementsarevalidaccordingto the input.
s2is the valuation function for configstatements.
the number of cases reflects the complexities of kconfig s validity checking.
the first covers reverse dependencies using the valuation function r whichsearchestheentire kconfigfile.
inpractice thekconfig implementation memoizes reverse dependencies during parsing to avoidrepeatedlytraversingthesyntaxtree.
ifareversedependency holds that means the option must be enabled i.e.
sym y otherwisethe configurationfile does not matchthe specification.
the second case of s2handles a direct dependency when the reversedependencydoesnothold.inthiscase anoptionisvalid regardlessofitssetting becauseauserisfreetoenableordisableit.
thethirdcasecoversnon visibleconfigurationoptions whichhave noprompt so the option s valuemust match the specified default.
the fourth case covers when none of the option s dependencies hold.
lastly if none of these conditions are met the configuration file isnot valid.
dependenciesfornon booleantypes string int andhex behave similarlyto boolandtristate butthereareadditionalconstraints and expressions such as rangeand inequalities.
the full semantics describes thesedifferences .
.
reverse dependencies tofindanyreversedependenciesforanoption kconfigneedsto search the entire specification for a selectthat can enable the option.thisispartlywhytrackingdownunmetdependenciesis sodifficult.
figure3bdefines the valuation function rfor reverse dependencies.ittakesboth theconfigurationfile anda symbolname sand returns a boolean value trueif that symbol is selected by some optionor falseifnot.r1 sdisjunctionreflectstheneedforonly oneselectto force enable an option.
r2checks to see if an option is enabled and its dependencies aremet thencalls r3toevaluateanyselectconstructs.
r3checks whether there is a select for the input symbol s.r4checks whether any configurationoptionwithin a choiceblockselectssymbol s. options other than tristate andboolcannot be the selector orselectee ofareversedependency.
.
choiceconstructs achoiceconstruct defines a mutually exclusive set of configurationoptions.choicesareusefulinconfigurationspecifications becauseexpressing themwithbooleanlogic aloneis verbose.figure4isan example of a choicefrom the linux kernel that allows only one of several compression algorithms for a file system to be enabled.
a choice block starts with a choicekeyword line and ends with an endchoice line10 .
it contains a list of configurationoptionswhich besidesthemutual exclusionrule behave mostlylikeanyotheroptions exceptthattheycannothavereverse dependencies ordefaultvalues.
896finding broken linuxconfigurationspecificationsby staticallyanalyzingthe kconfig language esec fse august athens greece s1 s braceleftbigg valid if logicalandtext.
statement i kconfig s valid invalid otherwise s2 s valid if sym y r sym valid ife e r sym valid if sym y e sym n e e e r sym valid if sym n e r sym invalid otherwise s3 s valid if enabled s valid e e valid if enabled e e valid if enabled logicalandtext.
constrnts i config e invalid otherwise a directdependency rules.
r1 r s logicalordisplay.
statement i kconfigr s r2 r s braceleftbigg r s if sym y e false otherwise r3 r s true if sym s e r s ifselect false otherwise r4 r s braceleftbigg r s ife e false otherwise b reversedependency rules.
symbols y n s statements valid invalid r statements symbols true false e constraints true false c typesfor input and thevaluationfunctions.
enabled summationdisplay.
symi config symi y d counting howmany configoptions areenabled.
e1 e e e2 e logicalanddisplay.
expri depends e e3 e val y ife e ifdefault false otherwise e4 e e e e5 e e e e6 e e e7 e sym y e expressionevaluationrules.
figure formalsemanticsofacore fragment ofkconfig.
897esec fse august athens greece jehooh necip faz l y ld ran julian braha andpaulgazzillo 1choice 2prompt decompressor parallelisation options 3depends on squashfs 4configsquashfs decomp single 5bool single threaded compression 6configsquashfs decomp multi 7bool use multiple decompressors 8configsquashfs decomp multi percpu 9bool use percpu multiple decompressors 10endchoice figure anexample ofachoiceconstruct.
thes3functioninfigure 3adescribesthe choiceblock ssemantics.
the first case covers the mutual exclusion property requiring thatonlyoneoftheconfigurationoptionsisenabled.thiscondition alsorecursivelychecksthatallthenested configs dependencies are valid.
choiceconstructsalsohavetheirowndirectdependencies so kconfigpermitsnooptionstobe enabled whenthechoicedependenciesarenotmet.thesecondcaseof s3coversthissituation.the third case covers the situation when none of the nested configoptions dependenciesaremet inwhichcasekconfigalsopermitsthe choicetohavenooptionsenabled.
choiceconstructscanalsotake theoptional keywordtoallowfornooptionstobeenabledevenif itsdirectdependenciesaremet.therulesareslightlydifferentfrom aregularchoice andwe present theminthe full semantics .
thechoicestatement described above has booltype.
the only othertypeachoicecantakeis tristate inwhichcaseitsbehavior isthesameas bool exceptthatmorethanonechoicemaybeset tom.
.
constraintexpressions figure3edefinesrulesforevaluatingconstraintexpressions which return a boolean trueorfalse.e1 e2 ande3are theprompt depends on anddefaultconstructs respectively.eachisacarrier for a logical expression and it is their interaction with configand choicethat gives them distinctmeaning.
the rest of the rulesare typicalboolean operators e 4 e7 .
.
syntacticsugar kconfighasthreeadditionalstatementsthatcanbedesugaredto configandchoice if menu andmenuconfig .unlikethecontrolflow construct in programming languages kconfig s ifis just syntactic sugar for adding constraints in bulk to its nested statements.
themenustatement behaves like an ifblock but also adds text tothe userinterface.
menuconfig isacombinationof configand menu.
the full semantics contains the desugaring rules for these.
the kconfig language also has a great deal of flexibility in its syntax.mostofthebehaviorofakconfigspecificationisinsensitive totheorderingofoptionsandconstraints.therefore oursyntax defines ordering on constraints to reduce the number of syntactic sugars rulesneeded.1configx selectaifdx 3kx other constraints for x 5configa depends on da 7ka other constraints for a 8kother constraints from other configuration options figure components ofan unmet dependencycondition.
kconfighaslimitedmetaprogrammingfacilitiesviapreprocessor constructs for file inclusion and macro expansion which we do not model.
our implementation runs the preprocessor before symbolicevaluationtoensurethatallfilesareincludedandmacros are expanded.
designingthe bug finder ourbug finder called kismetworksbygeneratingaformulafor eachselectdescribing the configurations under which it triggers anunmetdependencybug.thisrequiresbothsyntaxanalysis to identifyselectconstructs as well as semantic analysis to construct a formal model of the bug automatically.
kismetdischarges the formal conditionstoan smt solvertocheck satisfiability.
the kconfig language allows developers to define constraints using symbolic boolean formulas.
since our goal is to analyze all solutionstotheseconstraintssimultaneously theanalysisproblemis atleastashardasboolean satisfiabilityingeneral.the mainchallenge to designing kismetis ensuring scalability while preserving enoughprecisiontoidentifytheexactconstructscausingtheunmet dependency alarm.
.
identifying select constructs thefirstchallengefor kismetistoidentify selectconstructsin the kconfig specifications.
walking over each configconstruct syntactically it records all pairs of options involved in a select operation.
for instance in figure kismetidentifies the pair touchscreen adc iio buffer cb which contains the selector andselectee respectively.
in order to verify whether the select isfreefromanunmetdependencybug kismetneedstoaccount for all of the dependencies that constrain both the selector and the selectee.
the schematic in figure 5highlights what conditions kismet uses from the kconfig specification to construct a verification condition.
the configuration option x line selects a line with theselectconstruct on line .
the selectconstruct itself is constrained by some ifdependency captured by a logical formula dx line2 .additionally xhasitsowndependencies kxcontrolling when it can be enabled line .
a s direct dependencies are da line while ka line represents any promptordefault constraints.
kotherrepresentstheconstraintsfromallotherconfiguration options.
898finding broken linuxconfigurationspecificationsby staticallyanalyzingthe kconfig language esec fse august athens greece .
modeling unmetdependency bugs x sselectconstructonlycausesanunmetdependencyiftheselect overrides a sdirectdependencies i.e.
when a sdependenciesare unsatisfied.ifwejustconsidertheconstraintsoftheselectorand the selectee the formula for unmet dependency isas follows unmet x dx kx a da ka unmetmeansthefollowing the selectoroptionxisenabledandits selectand other constraints dx kxare met subexpression andtheselecteeoptionaisenabledwhileitsdependencies da ka arenotmet subexpression .
unmetis an overapproximation however because it only accounts for the constraints from two configuration options the selector and selectee.
constraints from other configuration options kother can make unmetunsatisfiable.
without accounting for those wecanexpectmorefalsepositivealarms.apreciseconditionwouldcontain theseconstraintsas well unmet precise unmet kother optimizingthebug finder.
thelinuxkconfigspecificationhas thousands of configuration options so unmet precise is a substantially more expensive formula to solve it has the constraints from thousandsofconfigurationoptionsinsteadofjustthetwoin unmet.
to make solving more efficient we use two techniques.
first if a selectee option has no direct dependencies then an unmet dependency bug is not possible.
second we first check the unmet condition and only check unmet precise if the first check is satisfiable.thisoptimizationissafe becauseif unmetisunsatisfiable we knowthat unmet precise isalsounsatisfiable i.e.
unmetentails unmet precise unmet unmet tautology unmet kother unmet strengthening unmet precise unmet substitution unmet unmet precise contrapositive this simple optimization has a substantial impact on precision and performance as we showinthe evaluation section.
.
modeling kconfigsemantics until now we have described unmetwith placeholders for configuration option constraints.
but interpreting these constraints aslogicalformulasrequiresmodelingkconfig ssemantics.inthis sectionweshowhowwemethodicallyderivethesefromourformal semantics section .
recall that kconfig takes a configuration file as input and determines its validity according to the specifications.as with prior kconfigfeaturemodelingtools werepresentconfigurationoptions assymbolicbooleanoptions collapsing tristate option syandm totrue.whilethisunderapproximates tristate itgreatlyreduces thespaceofpossibleconfigurations improvingsolverperformance.
similarly weapproximatenon booleanswithafiniterangeofoptions asinpriorwork .lessthan5 ofoptionsarenon boolean inlinux kconfig specifications.
to derive the model from kconfig semantics recall that our concretesemanticsdescribeseachcaseinwhichakconfigstatementdescribesavalidconfigurationgivenaninputconfigurationfile.for eachkconfigsyntacticconstructinthespecificationunderanalysis our bug finder automatically constructs a symbolic formula icorrespondingtoitsvaluationfunctionfromthesemanticsinfigure .
theformulaisthedisjunctionofeachconditionleadingtoa valid result.for instance a configstatement definedby semantic rule s2in figure has four validcases.kclause constructs config as a disjunction of each of these case conditions where cis the symbolic valueofthe option config c reverse depends prompt reverse c default c default depends prompt reverse c depends reverse each of the four disjunctive terms corresponds to each of the four validconditionsfrom s2.accessestotheconcreteconfiguration optionvalue sym are replacedwitha symbolicbooleanvalue c. calls to other valuation functions are replaced with the symbolic formulas for that syntax e.g.
dependsfor thedepends on construct.
fortheconfigurationoption iio buffer cb infigure config isconstructedfrom the following symbolic formulas c iio buffer cb reverse touchscreen adc iio input touchscreen depends iio iio buffer prompt true default false reverseand directare the reverse and direct dependencies respectively.
the option is always visible since it has an unconditionalprompt prompt and the default value is false since it has nodefaultspecification default .
substitutingthesymbolicformulasinto configandsimplifying the disjunctive terms we getthe following iio buffer cb touchscreen adc iio input touchscreen iio iio buffer touchscreen adc iio input touchscreen false iio buffer ccb iio iio buffer touchscreen adc iio input touchscreen in summary this formula means that iio buffer cb is legal to enable if its reverse dependency holds subexpression is legal to either enable or disable if its direct dependency holds subexpression4 never takes a default value subexpression andcan otherwiseonlybedisabledwhenitsdirectandreversedependencies do not hold subexpression .
the rest of the symbolic evaluator s valuationfunctionsaresimilarlyderivedfromtheformalsemantics andcan be foundwiththe openly archivedformalsemantics .
the benefitofthis approachisthatisremoves guessworkfrom designing kconfig analysis tools.
instead tool writers can rely on a commonsemanticstomechanicallyderiveananalysisforwhatever abstraction they would like to use for analysis tailoring the choice offormalismforconfigurationoptionsbasedontheirspecificapplication.wedemonstratejustonepossiblesetofchoicesforderiving 899esec fse august athens greece jehooh necip faz l y ld ran julian braha andpaulgazzillo kextract klocalizerkclause kismetkconfig files desugared kconfig logical models bug conditions bug alarms and .config file testsz3 figure the components of the infrastructure and how they worktogetherforunmetdependencybug finding.
the kconfig analysis.
moreover future extensions to kconfig by developers can be captured by updates to the semantics easing adoption for kconfig tools that mechanically derive their analyses from the semantics.
implementation the analysis framework is implemented in about two thousand sourcelinesofpython andaboutonethousandsourcelinesofc.it consistsoffourcomponents showninfigure .thekextract tool wraps the parser from the linux implementation of kconfig withacextensiontodesugarthekconfigspecificationintoadesugared version of the kconfig language.
the kclause tool written in python readsindesugaredkconfigandconstructslogicalformulas for each configuration options constraints outputting them in the smtlib2 format.
kismet also written in python finds each selectconstruct from the kextract output and uses the logical modelsfrom kclause togeneratetheunmetdependencycondition foreachconstruct.
kismetfinallypassesthisconditioninsmtlib2 format to the klocalizer tool which uses the z3 smt solver tocheckforthesatisfiabilityofthebugcondition.forsatisfiable conditions klocalizer can also generate solutions to the condition in the linux .config file format which we use to test the solutionagainsttheactualkconfigimplementation.allsourcecode isavailableonlineasfreeandopen sourcesoftware1aswellasin an openly archivedartifact .
experimentalevaluation we evaluate our bug finding approach for precision performance andimpact onreal world code.
experimentalsetup we use kconfigspecifications from a recent version v5.
.
of the linux kernel source code2as the target of our study.
with over 000linesofspecificationsandover15 000configurationoptions linux represents to our knowledge the largestuserof kconfig.
thelinuxkernelnotonlyprovidesalargekconfigspecification but multiple ones as well due to its support for multiple hardware platforms.
each of its architecture families3has its own kconfig specification effectively providing separate kconfig specifications to use for evaluation.
because of the hardware abstraction layer however thesearchitecturesshareatleastsomeportionof thecodebaseincommon andthereforealsosharealargeportion of their kconfig specifications about lines two thirds are architecture independent.
each architecture has between and select constructs for a total of .
deduplicating these thereare17 006uniqueselectconstructs althoughtheconstraints due to architecture specific kconfig files may differ.
due to thissharing wenotonlyreportresultsforeacharchitecture skconfigspecificationsbutalsotheaggregateanddeduplicatedalarms acrossarchitectures.
all experiments were executed on a server with an amd epyc core processor with 512gb of ram running ubuntu .
wherewemeasuredperformanceusingtheunix timeutility.since thismachineallowsforhighparallelism werantheexperiments for the architectures kconfig specifications in parallel on separate copies of the linux kernel source code.
replication scripts are available withthe sourcecode repository1.
.
data availability allexperimental data are available as archivedopen data .
.
research questions our evaluation seeksto answer the following research questions rq1 precision howpreciseisouranalysiswhenfinding unmet dependencies?
to measure bug finding effectiveness we runourtoolonall28linuxkconfigspecificationsandcollectthe alarmsreported.wealsoautomaticallyvalidatewhetherthealarms aretruepositivesbygeneratingandbuildingtestcasesautomatically.
we expect that if our semantics reflect real kconfig behavior that our symbolic model of unmet dependencies and kconfig behaviorshould yieldhigh precision i.e.
fewfalse positives.
rq2 performance howfastisbug finding?
werecordthe runningtimeofourbug finderwhenappliedtoall28linuxkconfig specifications i.e.
theexperimentfromrq1.wereportthedistribution of running times per architecture the aggregate time as well as the breakdown between desugaring generating bug conditions andsolving.weexpectthatourdesignchoicesandoptimization willyieldafastenoughanalysistomakerunning kismetfeasible for developers to use regularly.
rq3 impact how useful are the resulting alarms to developers?
we evaluate the impact of our bug finding approach by manually submitting some reports and patches to the kernel 3alpha arc arm arm64 c6x csky h8300 hexagon i386 ia64 m68k microblaze mips nds32 nios2 openrisc parisc powerpc riscv s390 sh sh64 sparc sparc64 um unicore32 x86 64 and xtensa 900finding broken linuxconfigurationspecificationsby staticallyanalyzingthe kconfig language esec fse august athens greece table kismet s bug finding results across all architecture kconfigspecifications.
percentiles metric max 75th 50th 25th min constructs alarms raised .
.
.
.
.
precision maintainers.
we expect that if the resulting alarms are correct and provide value to the kernel maintainers they will confirm the reports andacceptour patches.
rq4 comparison how does our approach compare to random configuration testing?
to our knowledge no related toolforfindingunmetdependenciesinkconfigexists.toprovide a baseline time to search for bugs we use random configuration testingwithkconfig sbuilt in randconfig tool.wecomparethe bugs found given the same amount of time as kismetand also allowrandconfig generation to run for several days.
we expect that our static approach will perform better given the enormity of thesearchspaceofconfigurations butwealsoexpecttofindnew bugsmissedby kismet sunderapproximation ofnon booleans.
.
rq1 precision werunkismetoneachofthe28architectures kconfigspecifications and collect the resulting alarms.
kismetreports the pair of configurationoptionsinvolvedintheunmetdependency i.e.
the selectorandtheselectee.finally wevalidatewhetherthealarmis atruepositivebygeneratingatestcase.thisworksbyquerying the z3 smt solver for a satisfying solution to unmet precise the bug s logicalformula then convertingthesolution intothelinux .configconfigurationfile format.
table1summarizes the analysis results of our experiments.
the rows list the number of constructs analyzed the number of alarms raisedby kismet andtheprecision i.e.
thepercentofallalarms that are true positives.
the columns show the distribution of these metricsacrossthe28architectures kconfigspecificationsaspercentiles.kismetchecksbetween10 014and12 744selectconstructs foreacharchitecture findingbetween10and53alarmsperkconfig specification foratotalof781alarmsover289 202constructs.all alarmsareconfirmedtobetruepositivesbygeneratingtestcases that trigger the alarm for a precision of .
while such high precisionwouldbeunusualforstaticanalysis thecorefragmentof kconfigthatwemodelrequiresno over approximationthatcould lead to false positives.
since the ground truth number of bugs in real world linux kconfig specifications is unknown we do not compute recall but we addressfalse negatives inrq4.
although each architecture has its own kconfig specification theyallsharealargecommonsetofkconfigfiles.theconsequence isthatfixingabuginonearchitecture skconfigspecificationcanfix itforseveralothers.deduplicatingthesebugyields151totalalarms forunique selectconstructsacrossallarchitectures.insomecases the same selectconstruct was a true unmet dependency in onetable2 kismet sbug findingtimeinminutesforall28kconfig specifications brokendownby eachphase ofanalysis.
analysis time percentiles minutes phase max 75th 50th 25th min .kclause .
.
.
.
.
.
syntaxcheck .
.
.
.
.
.
unmet .
.
.
.
.
.
unmet precise .
.
.
.
.
.
confirmation .
.
.
.
.
totaltime .
.
.
.
.
architecture skconfig specificationbutnot others whichis possiblebecauseofarchitecture specificconstraints.inthesecases we countedthe constructas atrue alarm inthe deduplicatedset.
summary ourapproachisprecise yielding100 precision on linux s very large real world kconfig specification and findsmanynewbugs 781truepositivebugsor151ifwededuplicatecommon constructs acrossarchitectures.
.
rq2 performance to evaluate performance we measure kismet s running time broken down by each phase of its analysis.
table 2is the distribution ofrunningtimesacrosseachofthe28architecture specifickconfig specifications.eachrowisthephaseofanalysis withthetotaltime in the last row while each column is percentiles in the distribution ofrunning times.
kismettakesbetween37and90minutesononekconfigspecificationfile foratotalof20hoursinall includingthetimespent generating atest caseto automatically confirm true positives.
we breakdownthetimingintofivephases kclauseisthetimespent modelingkconfigconstructs whichwe performatthebeginning ofanalysistocachetheresults.
syntaxcheck includesbothidentifying each select construct and the optimization that rules out selectees with no dependencies.
as discussed in section .2on optimization unmetisthetimespentcheckingtheimprecise bug formula and unmet precise is the timespent checkingthe precise bug formula if the imprecise one does not rule out the bug.
confirmation is the time spent generating a test case for the bug and checking it against the actual kconfig implementation this is not part of the static analysis per se but it only takes a comparativelysmall amount of time.
inmostcases kismettakeslessthanhourforanarchitecture making it fast enough for use on each commit of the kconfig specification.thelargestamountoftimeisspentonthepreciseformula check whichshowstheimportanceofouroptimizationinavoiding making that check.
checking unmetis fast it takes less than an hourforhundredsofthousandsof selectconstructs albeitwith low precision less than .
of the constructs are ruled out however reducing the time neededto solve the precise condition.
summary kismetis fast taking between and minutestoanalyzebetween10 014to12 744selectconstructsina kconfigspecification enabling frequentbug finding runs.
901esec fse august athens greece jehooh necip faz l y ld ran julian braha andpaulgazzillo .
rq3 impact we evaluate the impact of our bug finder and the semantics on which it is based by reporting alarms to the kernel developers and submitting patches to the mainline linux repository specifically via the linux kernel mailing list and the kernel.org bugzilla website .developerconfirmationofbugsprovidesconfidencein theutilityofthealarms beyondprecision.moreover acceptance ofpatchesbyofficialmaintainersreflectsthebeneficialimpactof the results onthis prevalentandfrequently usedcodebase.
while our bug finder is fully automated submitting reports and patchesisamanualprocess requiringtimetocreatethemandcommunicatewithhumanlinuxmaintainers.moreover maintainers mayopttonotpatcheventruealarms maynotrespondimmediately ormayrequestdifferentchangesthanwhatweproposedin thepatch.sincethekconfigspecificationgraduallychangesover time with the rest of the codebase prior bugs may no longer occur duetomanualfixes removalofoptions etc.webelieveitisfeasible to usekismetincontinuousintegration butwe leave suchinfrastructuredevelopmentasfuturework.forthesereasons wehave not yet submitted all alarms repairing all is an ongoing process andwe report the currentstate ofthe bugrepairsinprogress.
as of writing we have submitted reports or patches have been confirmed with the remainder pending and of our patches have already been committed to the linux kernel codebase.
up todate information about the reporting and patching effort can be foundinthe sourcecode repository4.
knowing the effect of unmet dependencies on the kernel is difficulttomeasure.suchaconfigurationisnotsupposedtobefeasible and developers have been so far highly receptive to patches of unmetdependencybugs.whilewedonotknowalltheeffectsof anunmetdependency onecommonresultisabrokenbuild e.g.
figure1 whichisundesirableforanysoftwareproduct.wemeasured how often a broken build results from the bugs we found by attempting to build the generated .config fromkismetand hand checkingthereasonforthebrokenbuild.builderrorsaccount for of all tests.
of configuration files trigger build errors whose root cause is the unmet dependency bug from which the configurationfilewas generated.
faildueto bugs other than the one used to generate the test case.
since a build error halts the buildprocess wecannoteasilydeterminewhetherthebuildwould have encountered an error related to the unmet dependency so we conservativelyassumethesearenotcausedbyunmetdependencies.
summary the bug finding results have resulted in reports and committed patches to the linux kernel so far with furtherpatchsubmission and discussion ongoing.
.
rq4 comparison whilekismetis100 preciseforitsfragmentofthekconfigsemantics itsunderapproximationofnon booleanleavesitsusceptible to false negatives.
to gather a set of unmet dependency benchmarksthatincludebugsnotfindableby kismet weuseabuilt in kconfigutilityforgeneratingrandomconfigurations.generating random configurations for over four days for each architecture inparallel acombinedtimeofmorethanthreemonths wegeneratedover11 000configurationfiles whichraised2 percent of the bugs found by kismetcompared to randconfig givenboththesameamountoftimeasand135x more timethan kismet.
percentiles tool max 75th 50th 25th min kismet .
.
.
.
.
randconfig sametime .
.
.
.
.
135x time .
.
.
.
.
unmet dependency alarms yielding unique unmet dependency bugs.comparingtheseto kismet sresults kismetadds614unique unmet dependencies not foundinthis random testing.
since no other tools to our knowledge analyze unmet dependencies we compare the performance of kismetagainst a random testing approach to see whether there is a benefit in running time andbugsfoundtousing kismet.usingthecombinedsetofbugs frommonthsof randconfig andkismet sresults wecomparethe percentofbugsfoundgiventhesameamountoftime.table 3shows theresultsofthiscomparisonofthepercentageofbugsfoundfrom the benchmark set.
the columns show the distribution of these percentagesacrossallarchitectures kconfigspecifications.
kismet finds for almost all architectures reflecting the fact that even aftermonthsofcomputetime veryfewadditionalbugswerefound byrandomtestingcomparedwith kismet.randconfig row same time giventhesameamountoftimethat kismettook findson average only a small fraction of the set of bugs .
with a maximum of only .
.
even given several days to run row 135x time randconfig still only finds a fraction of the benchmark bugs.
in contrast there were only eight bugs not found by kismet leadingto aworst case of .
benchmarkcoverageby kismet.
whileourbenchmarkisnotthegroundtruthoflinux scomplete set of bugs which is not feasible to find by hand given the months of compute time to generate configuration files it provides at least anestimateoftherelativeperformanceof kismetversusrandom testing.
the results show the large performance benefit of using kismetcomparedtorandomtesting.inthesameamountoftime kismetfinds many more bugs than random testing providing a fast and precise complement to random testing that can be run regularlyagainst newcommits to the kconfig specification.
summary kismetfinds many more true positives bugs in far less time than random testing although there are also falsenegativesasexpectedbydeliberateunderapproximation.
threats to validity internalthreats.
ourformalsemanticsneedstomatchtheactual behavior of kconfig otherwise any analyses based on it may yield incorrectresults.wemitigatedthisusingthekconfigdocumentation reviewingitsactualcimplementation andcollectingakconfig testsuite.moreover the100 precisionofthebug finder validated withgeneratedtestcasesandsomedeveloperconfirmation testifies totheaccuracyofthesemantics.
kismetisdeliberatelyunderapproximate for non boolean options however so this part of the 902finding broken linuxconfigurationspecificationsby staticallyanalyzingthe kconfig language esec fse august athens greece semanticsisnotsupportedbythebug findingresults butbythe documentation implementation andtest suite only.
external threats.
while kconfig is used by several popular lowlevelsystemssoftware busybox coreboot etc ourevaluationonly applies to linux.
linux however is the largest user of kconfig that weknowof andhasmultiplekconfigspecifications.weevaluate our bug finder on one recent version of the linux source code but kconfigspecificationschangegraduallywitheachkernelversion.
different versions may yield different numbers of alarms.
we leave a long term study of kconfig bugs across versions and projects as future work.
our bug finder currently checks for one kind of bug.
the performance of the bug finder could vary for different bug types or analysis tasks.
our work is specific to the kconfig specification language so we do not show applicability to other specificationlanguages.giventhelargetimeinvestmentincreating and evaluating accurate formal semantics and a corresponding analysisinfrastructure weleavegeneralizingtheapproachtoother specification languagesas future work.
related work modelingkconfigspecifications.
thereareseveralpriorefforts that convert kconfig to logical formulas for various applications.
zengleretal.andwalchetal.modeledkconfiginthedimacssat formatwiththegoaloffindingkconfiglanguagemetrics including the number of options types and mandatory configuration options .
she et al describe a formal semantics and a tool called lvat that converts kconfig specifications to the dimacs sat solver format .
it was designed for collecting statisticsaboutthekconfiglanguagesuchasthenumberofoptions the hierarchy of dependencies and other metrics rather than for precise formal verification of configuration specifications.
tool developmentappearstohavestoppedforlvatin2013 .the undertakerprojecthasatooltoconvertkconfig s dumpconf output to the dimacs sat format for use in identifying dead code blocks in unpreprocessed c code .
thekconfigreader tool convertstheoutputofakconfigtoolcalled dumpconf whichdumps each configuration options constraint expressions into the dimacs sat solver format .
el sharkawy et al.
describes an informalsemantics of kconfig provides illustrative examples and evaluates the limitations of other tools .
fernandez et al.
described informal semantics for kconfig constructs that they identified as incorrectly supported in prior conversion tools .
they provide a set of example kconfig constructs that illustrate these limitations whichwe haveincorporated into kclause stestsuite.
fernandez et al.
also describe a new conversion tool that produces binary decision diagrams but has not been evaluated on linux kconfig specifications.
analyses of other configuration languages.
shambaugh et al.
performformalverificationofthepuppetdeploymentconfigurationlanguagetodetectnon deterministicsystemstateupdatesand other undesirable system configurations.
weiss et al.
automate puppet configuration repair using formal reasoning over a propositionalmodelofthelanguage.andersonetal.
formally verify the smartfrog infrastructure deployment language to prove properties such as termination of compilation comparing multipleimplementations of smartfrog compilers.
sotiropulous et al.
formallymodeledthesystemcalltraceofthepuppettooltofindfaults fromorderingviolationsonresourceusage .hortonandparnin infer system dependencies frompython codein order to generate docker specification files .
they also inferred dependencies from python code snippets to check if their package dependencies are out of date .
bouchet et al.
use formal verification to check for inadvertent public access to amazon s3 instances .
chenygyuanetal.minedfrequentlyuseddependenciesbetween entitiesfromdeploymentdescriptorsforjava ee platform based applications to validate if a new deployment descriptor is violating mineddependencies .hanappietal.formallymodeledconfigurationscriptsandresourceusagetotestifasystemcanrecover from failures such as network outages and reach a stable state .
studiesonvariabilitybugs.
somepriorworkextractedvariability information from makefiles and source code for finding bugs dead codeblocks orinconsistenciesbetweenvariabilityspecificationand implementation.
.priorworkalsoanalyzed bugs or warnings raised from sampled configurations to classify them and understand how they are introduced .
similar analyses were performed on the bugs or vulnerabilities reported in the bug database or source commits .
others studied configuration sampling algorithms to find more variability bugs withfewer samples .
conclusion wehaveintroducedanewformalsemanticsandmodelchecking infrastructure for analyzing kconfig specification files and methodically derived a bug finder called kismet for unmet dependencies a common pitfall for kconfig maintainers.
our results show that our bug finder is precise fast and has resulted in patches to the mainlinelinuxkernelsourcecodeconfirmedandacceptedbymaintainers.futureworkincludescontinuingtorepairallbugsfoundby kismet applying it to ongoing kernel development and other software andapplyingouranalysisframeworktoothermaintenance challenges.
wealsoplantoexploreapplyingthesemodelcheckingprinciples tootherconfigurationspecificationlanguagestofurtherimprove thestateoflanguagetoolingforsoftwareoperationsatlarge.as software operations are further automated the languages used for configuring building and deploying software become an increasingly large component of the source code.
these languages introducenewopportunitiesforlesstraditionalsoftwarevulnerabilities such as security misconfiguration.
as our work demonstrates these languages lend themselves to automated analysis suggesting thefuture benefitsof applyingrigorous designand automated reasoningto software operations languagesingeneral.