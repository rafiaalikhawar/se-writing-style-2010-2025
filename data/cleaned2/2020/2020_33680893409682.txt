understanding and automaticallydetectingconflicting interactions betweensmarthome iot applications rahmadi trimananda universityof california irvine usa rtrimana uci.eduseyed amirhosseinaqajari universityof california irvine usa amiraj.
uci.edujason chuang universityof california irvine usa chuangj6 uci.edu uci.edu briandemsky universityof california irvine usa bdemsky uci.eduguoqing harryxu ucla usa harryxu cs.ucla.edushanlu universityof chicago usa shanlu uchicago.edu abstract smarthome devicesprovidetheconvenienceofremotelycontrollingandautomatinghomeappliances.themostadvancedsmart home environments allow developers towrite apps to make smart homedevicesworktogethertoaccomplishtasks e.g.
homesecurity and energy conservation.
asmart home apptypically implements narrow functionality and thus to fully implement desired functionalityhomeownersmayneedtoinstallmultipleapps.thesedifferent appscanconflictwitheachotherandtheseconflictscanresultin undesired actions such as locking the doorduringafire.
inthispaper westudyconflictsbetweenappsonsamsungsmartthings the mostpopular platformfor developing and deploying smart home iot devices.
by collecting and studying official and third party apps we found significant app conflicts in categories close to of app pairs that access the same device more than of app pairs with physical interactions and around of app pairs that access the same global variable.
our results suggest that the problem of conflicts between smart homeappsisseriousandcancreatepotentialsafetyrisks.
wethen developed a conflict detection tool that uses model checking to automaticallydetectupto of the conflicts.
ccs concepts generalandreference empiricalstudies softwareand its engineering empirical software validation.
keywords smart homeapps concurrency program analysis model checking acmreference format rahmaditrimananda seyedamirhosseinaqajari jasonchuang brian demsky guoqing harry xu and shan lu.
.
understanding and automatically detecting conflicting interactions between smart home iot esec fse november 8 13 virtual event usa copyright held by the owner author s .
acm isbn .
in proceedings of the 28th acm joint european software engineeringconferenceandsymposiumonthefoundationsofsoftwareengineering esec fse november8 13 virtualevent usa.
acm new york ny usa 13pages.
introduction smart home devices are widely available commercially.
modern smart home platforms support developers writing apps that implementusefulfunctionalityonsmartdevices.significantefforts have been made to create integration platforms such as android thingsfromgoogle smartthingsfromsamsung andthe open source openhab platform .
all of these platforms allow users to create smart home apps that integrate multiple devices andperformmorecomplexroutines suchasimplementingahome security system.
in this work we focus on samsung s smartthings platform because it is the de facto smart home development environment andhasthemostextensivecollectionofsmarthomeapps including thoseofficiallycreatedbysmartthings andthosedeveloped by third party companies and hobbyists.
homeowners that use smartthings can install any of these smartapps and run them simultaneouslyintheirhomedeployment.manyoftheseappseach implementaspecificfunctionality e.g.
turnofflightsintheabsence ofmotion.thus homeownerswill likelyneedto install multiple apps that collectively achieve the desiredfunctionality.
.
the problem interactions and conflicts of apps.
the presence of multiple apps that can control the same device creates interactions that can potentiallybeundesirable i.e.
conflicts .forexampleahomeowner may install the fireco2alarm app which upon the detection of smoke sounds alarms and door unlocks1.
the same homeowner may also install the lock it when i leave app todoor lock automaticallywhen the homeownerleaves the house.
whileitmayappearthattheseappscanbesafelyinstalledtogether closer examination reveals that they can interact in surprising ways.
consider the following scenario.
if smoke is detected fireco2alarm will door unlock the door.
if someone leaves home withthepresencetag thiswillmakethepresencesensorchange 1we usedoor lock anddoor unlock to refer to actions on a physical door and lockand unlockto referto synchronizationsin concurrentprogramming.
1215this work is licensed under a creative commons attribution international .
license.
esec fse november8 virtualevent usa trimananda aqajari chuang demsky xu andlu its state from present to not present causing the lock itwhen i leaveapp to door lock the door.
this defeats the intended purpose ofthe fireco2alarm app.thus the twoapps conflict.
data races atomicity violations.
interactions of smart home apps may initially appear similar to those of concurrent programs includingdataraces andatomicityviolations .
data races can be resolved by acquiring locks appropriately while atomicityviolationscanberesolvedbyensuringthatlocksareheld long enough to guarantee that a thread can finish all operations in abatch withoutinterference from otherthreads.
unfortunately these techniques cannot resolve the abovementioned conflict.
suppose that we use a lock to guarantee the atomicity of the critical region of the code the fireco2alarm app needs to acquire the lock before triggering the alarm and holds the lock while the alarm is sounding.
similar actions need to be taken to door lock and door unlock for the lock it when i leave app.however thisapproachcoulddisablethedesirablefunctionality of the apps.
to illustrate consider a scenario in which the lock it when i leaveapp detects that someone leaves the house.
itthenacquiresthelockbeforeitentersthecriticalregioninwhich door lockisperformed.itholdsthelocktokeepthedoorlocked until the person returns.
in this period if the fireco2alarm app detects smoke fire and attempts to door unlock it will fail because thelock it when i leaveapp holds the lock.
we end up in the same situation thedooris locked duringafire!
feature interaction.
feature interaction considers the problem in which different software features can have negative interactions .
oursetting differs from mostof the previous work in this area in that smart home apps are developed independently and composed by end users.
for example smartthingsappsaredistributedthroughmanydifferentchannels includingpayforsource .thus theredoesnotexistameanstodetect resolve avoid conflicts during development.feature interactions have also been studied in research prototypes for home automation .
these early systems were prototype systems and presumedmuchcoarserapps e.g.
asingleappforlighting than current smart home apps implement.
hci researchers have shown thatfeatureinteractionsiniotsystemsmakeitdifficultforusersto understandthesystems behavior .inrule basedsmarthome systems researchershavedevelopedtoolsforrepairingincorrect rules .
interactionsofmobileapps.
researchers have also studied interactions between android apps .
however thesetechniquesfocusprimarilyoncross appinformationflow taint analysis via icc iac mechanisms in android e.g.
intents and thus cannot be used in our setting.
in particular our problem requires checking properties of the execution trace that such analysescannothandle see section .
.
the smart home app interaction problem.
the problem we focus on in this work is conflict of expectations .
the expected result of thelock it when i leaveapp is that the door should be locked when the homeowner leaves while the expected result for the fireco2alarm appisthatthedoorshouldbe unlocked duringafire.
these expectations conflict in certain scenarios.
hence the fundamentalquestionhereis whatshouldbetheexpectedstateofthedoor when these apps interact lockedorunlocked?
the potential conflict betweenthe fireco2alarm andlock it when i leaveappsisnotcorrectableusingstandardmechanismsfor concurrentaccessesto program variables or entities using locks to restore atomicity still violatestheintegrityofthe expected result .
state of the art and our work.
the research community has beenactivelylookingintosmarthomeapps.thereisabodyofwork that aims to find bugs and issues that could lead to serious security problems .
however none of these techniquesfocusesoninteractionsandconflicts betweenmultiple apps.
in the cyber physical systems community work has been done to identify and resolve conflicts between smart home apps at the system level viewing apps as black boxes .
while suchtechniques areuseful incertain simplescenarios they are still semantics agnostic and do not work even for the abovementioned conflict how can we automatically resolve the conflict withoutunderstandingthesemanticsoftheapps andtheirpriority andtiming requirements?
ia graph studiessmart homeappconflictsandproposes alightweightapproachtocheckforconflicts.thisworkextractsan smtformulathatdescribesthelegaltransitionsforanappandthen usesan smt solvertodetect whether a set of apps hasconflicting transitions.
as acknowledged in the ia graph paper ia graph ignores complicated computations in the app code they are in fact used either in condition statements or to updatethe device state andhencethepatternsitfindsarelimited.inaddition notall transitions in an app can be expressed in smt further limiting the kindsofconflictsia graphcandetect.
anotherimportantdrawbackisia graphdoesnotcheckwhetheraconflictingtransition is reachable in an execution and hence can produce many false positives.unfortunately withoutaccesstotheirimplementation we could not conduct an empirical evaluation of theseissues.
onthecontrary ourstudycoversa broaderrange ofinteraction patternsdiscoveredinawide scalestudy.
ourconflictdetection tool iotcheck works for arbitrarily complicated application logic since itmodel checksallapp pairs directlyusing the app code.
.
ourcontributions thegoalofthispaperistounderstandthenatureoftheinteractions between smart home apps.
we have identified the following five researchquestionsto guide our study.
rq1 what kinds of interactions are there?
we have collected and studied official smartthings apps and third party apps.
compared withrecent studiesofsmart home apps wehaveamongthelargestappsuite.tounderstandinteractions and possible conflicts we analyzed these apps in pairs see section3 and examined all pairs of apps that can potentially interact.
wediscoveredthreemaincategoriesofinteractions interactions between apps that access the same device see section interactions between apps such that the output from one app interferes with the input of the other app e.g.
via sensors see section and interactionsbetweenappsaccessingglobalvariables e.g.
whether the home isinthe homeorawaymode see section .
rq2 what types of conflicts arise between smart home apps?for an app pair we first inspected their source code and documentationtounderstandtheintendedbehaviorofeachindividual app and then reason about possible interactions between them.ifthereexistsaninteractionthatcancompromisethedesired functionality of either app we say that this pair has a conflict e.g.
1216understandingandautomatically detectingconflicting interactions ... esec fse november8 virtualevent usa smartthin s cloud smart home de i es smart hu smart thin s app third partnj snjstems e. .
ifttt router wi fi de i es zi ee z wa e de i es ...de i e handlerde i e handlerde i e handler ... eljample oi smartapps smartapp fireco2alarm de i e handler capability.lock lock.lock lock.unlock smartapp lock it when i leave zi ee door lo k glo al varia lessmartapp smartapp smartapp netd ork phnjsi al onne tion communi ation figure smartthings platform with an example of two appsrunninginparallel.
the functionality of the fireco2alarm app to door lock is compromised by the lock it when i leaveapp.
our goal is to carefully inspect apps that interact and understand whether they conflict andif they do why.
rq3 how prevalent are these conflicts?
we summarized the resultsofourstudytounderstandhowprevalenttheconflictsare.
we foundthat almost60 ofpairsin thefirst category more than of pairs in the second category and around of pairs in the thirdcategory have conflicts see sections .
.
and6.
.
rq4 are there common coding patterns that are unsafe in thepresenceofappinteractions?
duringourstudy weobserved several common programming idioms that often result in problematicinteractionsbetweenapps.discoveringandclassifyingthese idioms can help developers mitigate potential conflicts by avoiding theseidioms.
rq5 howcanweautomaticallydetectconflicts?
basedonour findings wedevelopatoolthatcanautomaticallydetectconflicts seesection .
ourtoolanddatasetareavailableunderanopen source license at .
implications.
the implications of this work are two fold.
first our study opens a new research direction in the area of testing and verification of concurrent programs where the development of different apps are done completelyindependently.
the inability of existingconcurrencycontrolmechanismstoresolvesmarthome apps dictates the need of new techniques such as iotcheck to detectand orrepairtheseconflicts.second forplatformvendors such as google and samsung new apis should be designed and appliedtotheseplatformssothatappdeveloperscanbedirected to make more informed decisions during development even if they are not aware ofpotentialruntimeconflicts.
background thissectionprovidesanoverviewofsmartthings thede facto smart home iotdevelopmentplatform.
components.
figure1shows an overview of the smartthings platform.therearethreemaincomponents asdiscussedshortly.
the network physical connections betweenthese componentsareshown in figure 1as solid lines while dashed lines represent communicationpaths.
smart home devices smartthings supports both smartthings branded and third party devices as well as a variety of communication protocols including wi fi zigbee and z wave.
while wi fi devices are connected directly to the home router zigbee z wave devices are connected to a smartthings smart hub through dedicated radios.
the smart hub is connected to the home router and relaysthe communication between the zigbee z wave devices and the smartthings cloud via the router.
classes of devices that are supported by the smartthings platform include both actuators e.g.
switches locks thermostats lights oralarms and sensors e.g.
illuminance motion water orsound sensors .
smartthings cloud the smartthings cloud hosts smart homeapps i.e.
smartapps anddevicehandlers i.e.
driversthat directly control devices developed using an event based programmingmodelingroovy amanagedlanguagerunningontop of the java virtual machine jvm .
smartapps implement desired functionalities on smart home devices by accessing global variables and device features through capabilities exposed by device handlers .
for instance a door lock can be accessed by smartapps through its device handler that declares lock related capabilities using capability.lock .
these capabilities provide access to features such as door lock anddoor unlock via apis such as lock andunlock .
third party systems e.g.
ifttt if thisthen that can also connect to the smartthings cloud and control smart home devices through smartapps that expose http endpointsas acontrolinterface.
smartthings smartphone app homeowners can use the smartthings smartphone app to install devices and smartapps.
to communicatewithhomedevices thesmartphonefirstconnectsand sendscontrolinformationtothesmartthingscloudeitheroverthe internet or via the home router illustrated by arrows and in figure1 andthenthesmartthingscloudforwardstheinformation to smart home devices viathe home router andthe smart hub.
execution model .smartthings uses an event driven execution model and allows multiple smartapps to run concurrently.
consider for example the fireco2alarm app which attempts to door unlockifitdetectssmoke firethroughasmokesensor.the appsubscribesto theevents generated by thesensor sdevicehandler when the sensor detects smoke fire it sends a message to the smart home hub.
the smart home hub relays the message to the smartthings cloud which in turn runs the sensor s device handler to process the message.
the device handler will generate an event and send it tothe app sevent handler method which in turn calls another method takeactions to door unlock.
since multiple appsrunconcurrently thetwoapps fireco2alarm andlock itwhen i leaveshare the device handler for the door lock and thus can both execute lock andunlock at any time on the same device handler.
the device handler on the cloud translates each action intodevice specificcommands.thecloud thensends these commandstothelocalsmarthub whichforwardsthecommands to the doorlock.
methodology thissectiondescribesourresearchmethodology.wefirstdefine severalterms.next wediscussourdatabaseofsmarthomeapps 1217esec fse november8 virtualevent usa trimananda aqajari chuang demsky xu andlu x execution action event update a action read d r write d r v moderead modewrite schedule t m v event devev d r v modeev schedev m u update devup d r v modeup appd deviceid devicetype r feature v value t time mode m method figure smartthings execution traces.
and the way we structure them for the study.
our study focuses on pair wiseinteractions.therationaleisthatpair wiseinteractions are fundamental for understanding multi app interactions since multi appinteractionscanbedecomposedtopair wiseinteractions for reasoning about.
upon carefully examining these apps we did not observe any code patterns that would lead to new interactions arising when three ormore apps are involved.
.
definitions executiontraces .wefirstformalizeournotionofexecutiontraces for smartthings in figure .
the traces can be generated by one ormoreappsthatrunconcurrently.anexecution x execution from asetofapps isasequenceofthe following action app performsanaction a actionbyexecutingany ofthe following setofoperations read d r and write d r v which readfromandwrite avaluevtoafeature rofadevicewithid danddevicetype respectively moderead and modewrite which read from and write a newmode to thelocation.mode variable respectively and schedule t m whichschedulesamethod mto run at time t. event an event v eventiseither devev d r v a device event is delivered to app from devicedto notifythe app ofdevice statusupdate modeev amodeeventisdeliveredtoapp tonotifyitofa mode change or schedev m a schedule event denotes when the framework processesa scheduleaction andexecutesthe method minapp .
update anupdate u updateisanexternalinputtothesmart home.itiseither devup d r v anupdatewithanewvalue vgeneratedfrom a device with id dand type for feature rand value v i.e.
a sensor readingatemperature change or modeup anupdatewithanewmode e.g.
thehomeowner manually settinganewmode.
interacts with relation.
we next define a relation interacts with over the domain of apps apps where apps is the set of all smart homeapps.apairofapps 1 2 interacts with i.e.
1interactswith 2 if they interact witheachotherinone ofthe three ways accessthesamedevicecapability apps 1and 2canaccess a shared device using the same capability 1updatesthe device state i.e.
featurerand value v and 2accesses i.e.
updates orreads the device state.
we refer to this relationship as a device interaction.
for example 1may turn on a switch based on the inputofalight illuminancesensorand 2mayturnoffthesame switchbasedonamotionsensor bothcallingmethodsonthesame device handler object.
physical interaction we say that two apps have a physicalmediuminteractioniftheoutputof 1physically becomesaninput for 2and affects the execution of 2. for example 1activates a robot vacuum cleaner at a certain time during the day and the robot s movement becomes the input to a motion sensor that is usedby 2. accessthesameglobalvariable apps 1and 2caninteract via the same global variable whose value is stored on the cloud e.g.
1updatesthevariableand 2accessesit.thisisreferredto as aglobal variable interaction.
in this study we focused on the location.mode variablebecauseitistheonlyglobalvariableinthe smartthings platform that allows for both writeandreadaccesses.
location.mode has three preconfiguredvalues home away and night.anexamplescenarioisthatoneappupdates location.mode based on the input of the presence sensor while the second app reads itto determinewhether adoorshould be locked unlocked.
conflictrelation.
apps 1and 2conflictif they interact in one of the ways discussed above and the interaction may compromise thecorrectness oftheappsorproducean unintendedoutcome .althoughthenotionofaconflictissomewhatvague wefoundthat definitions .1and3.2workedwell mostof the time inpractice.
definition .
.
device global variable conflict .two apps 1 and 2conflictiffthereexistsanexecution xof 1and 2andtwo actionsa1anda2that update the same feature ror mode inx such that a1anda2are performed by different apps 1and 2 a1anda2write different values v1andv2 or 1and 2 there is no such a3that updates the same ror and that the update is ordered between a1anda2 and a2was notinitiated byadirectuseraction.
definition3.
.
physical mediumconflict .twoapps 1and 2 conflictiffoneappperformsanactionthataffectsaphysicalmedium e.g.
motion and the other app reads from a sensor that can sense that physical medium e.g.
amotion sensor .
.
smarthome app pairs choiceofapps.
westudied198officialand69third partysmart home apps that we have collected from the smartthings official github and other third party repositories.
while the statistics of appusagesandinstallationsareproprietary allthe apps thatwe used in this study can be obtained easily from the aforementioned repositories.
today the smartthings official github has an active user community it has been forked into personal repositories more than times.
any user can get and upload any app s sourcecodetothesmartthingsmarketplaceviathesmartthings groovy ide .
thus userscan installanduse any app.
apppairing.
theseappswereinitiallydevelopedtoperformtheir specificfunctionality.therearenostandardizedguidelineseither from smartthings or from the community as to how to develop an app inawaysothat itcan safely interact withotherapps.
ourprocessformanualexaminationwastoindependentlyexamine the sourcecode of each app pair by at least two of the authors.
1218understandingandautomatically detectingconflicting interactions ... esec fse november8 virtualevent usa table groupsofappsfordevice type pairing.
group capability subgroup app apps pairs switches switch general lights ac fan heat vent camera locks lock thermostats thermostat lights colorcontrol hue non hue dimmers switchlevel alarms alarm valves valve musicplayers musicplayer relay relayswitch speech speechsynthesis synthesizers cameras imagecapture total in the event that the two examiners disagreed about whether an app pair conflicted theydiscussed theirdisagreement onthe apppair s classification and reached a consensus.
there are app pairs given the apps we collected above.
from this huge set of pairs we identify2 pairs of apps that potentiallyinteract with each other.
we next explain how we use the three interact with conditions to identify these pairs.
we will then study how manyofthese2 pairscontain conflictsinsections 4 6. device type pairing.
to identify apps that have device interactions we firstdivide the 267apps intogroupsbasedonwhat type of device an app aims to manage as shown in table .
clearly if two apps do not access a common device it is impossible for them to havedeviceinteraction.
outofthe267apps weexcluded132appsforthreereasons.
first weexcludedappsthattakeinputsfromoutsideofthesmartthings platform.
for instance the ifttt if this then that app functionsasabridgebetweenthesmartthingsplatformandifttt athird party platform.theseappstypicallywaitforathird party applicationbuiltonathird partyplatform e.g.
iftttandother similar platforms to send commands and generate events through httpendpoints.wedonothaveaccesstothesourcecodeofsuch third partyapplications thus itisnotpossibletoaccuratelyreason aboutpotentialinteractions.second weexcludedappsthatonly send messages to a smartphone about the state of sensors because theseappsdonotinteractwithotherapps.third wealsoexcluded apps that use third party specific device handlers since these apps cannot share a device with other apps.
therefore we included appsfordeviceinteraction.someofthemaccessmultipledevices and thus areincludedinmultiplegroupsofdevices hence atotal of171apps.attheend weidentifiedatotalof1 438pairsfromthe 171apps classifiedinvariousdevice type basedgroups.
for some groups we identify all pairs of apps from the group as device interactionpairs.forexample the locksgroupcontains21 apps we inspectedallthe parenleftbig21 parenrightbig pairsandconfirmedthemall to bedevice interactionpairs.
for some groups that provide genericfunctionality such as switchesandlights wefurthercreatesub groupsandonlyidentify apps that belong to the same sub group as having a deviceinteraction.
for example for the switches group out of a total of 64table groupsofappsforphysical medium pairing.
output apps sensor apps pairs lights 42illum.
movingdev.
2motion watervalves 2water sound dev.
21sound total apps 24accessgeneralswitches 276pairs 32accesslightswitches pairs access ac fan heater pairs access the ventilation system pairs and access cameras pair .
we also found 8apps notincludedintable thatcontrolspecificdevices e.g.
curling iron thatarenotsharedbyotherapps hence nopairswere constructed for theseapps.
the lights group consists of apps that use the light device handler i.e.
capability.colorcontrol to turn the lights on or off set their illuminance level or change theircolors.eachgroupwasdividedintoasubgroupofappsthat controlsphilipshuelightsandanothersubgroupthatcontrolsnonhuelights.inthelightsgroup thereare13appsforhueleading to pairsand11 apps for non hueleading to pairs.
physical medium pairing.
twoappscaninteractviaa physical medium e.g.
one app generates an output that could be a physical inputtothe otherapp.toillustrate consideranapp thatchanges thestate i.e.
toggleon off oflightbulbs.thesechangesalsoaffect the illuminance produced by the light bulbs which can become an inputto apps that read from illuminancesensors.
table2reports results for apps that interact physically.
we grouped them based on the output input relationships such as lights output and illuminance sensors input moving devices output and motion sensors input water valves output and watersensors input orsound generatingdevices output andsound sensors input .
forthelight illuminance sensor relationship for example we constructed a total of pairs for the apps that controllights andthe 5apps that read from illuminancesensors.
global variablepairing.
appscanalsointeractiftheyaccessthe sameglobalvariable.currently thereisonlyoneglobalvariable in the smartthings platform that multiple apps can read from and write into location.mode .
we grouped together all the apps that access itfor atotalof pairs.
.
threatsto validity externalvalidity.
this study focused on samsung s smartthings platformandthusmaymissinteractionpatternsspecifictoother platforms.
however we believe that most of the findings and insights revealed in this study are universal for smart home applications and frameworks.
for instance our results also apply to rule based systems e.g.
ifttt two rules if the humidity is high turn off the ac and if the temperature is low turn on the ac have a conflict by our definition if the humidity is high and the temperature is low.
even for interactions that are specifictothesmartthingsplatform e.g.
concurrentaccessesto thelocation.mode variable thepatternsdiscoveredundersuch interactionsaregeneral.forexample otherplatformswouldalso have global variables that serve similar purposes and hence our results can be generalizedto theseotherplatforms as well.
internalvalidity.
thisstudycovers allofthe198officialapps that wecouldfindinthesmartthingsofficialgithubrepositoryandthe 1219esec fse november8 virtualevent usa trimananda aqajari chuang demsky xu andlu example set for smartthings tutorials as of july .
we added third partyapps that we gatheredfrom variousothersources.
while we studied the complete set of the official apps the thirdpartyapps used in thestudy maynot be exhaustive.
nevertheless ourexperienceshowsthatthepatternsthatexistintheofficialapps are similar to those in the third party apps.
we believe adding new third party apps would not change the main findingsand insights.
inthisstudy welimitedthescopeofappinteractionstopairs and hence there could be new typesof interactions thatmanifest only whenthreeormoreappsareinvolved.however wehavealready manuallyinspectedalargenumberoftripletsandnotfoundany newinteraction patterns that donot exhibit inpairs.
we manually inspected app pairs to determine whether the two apps in each pair can conflict.
the manual determination is subjective in some cases it reflects the authors beliefs of whether the interactions between a pair of apps represent an unintended outcome.
whether this conflict represents a problem in the real world is a very complicated question and can depend on the intendeduseofthehomeownerand thehomeenvironment.for example if one app turns a light on and a second app based on the absenceofmotionfromasensorturnsthelightoff weclassifythis as a conflict.
however users may compose apps with the intention of this app interaction.
as another example certain interactions aremadeoverphysicalmediums forinstance thesoundgenerated by a speaker app could become the input of a sound sensor used by a different app.
in this case whether the sensor can pick up the sound depends on whether it is physically close to the speaker generating the sound.
in the study we assume that this interaction canactuallyhappenalthoughthespeakerandthesensormaybe farawayinareal life deployment.
conflictsthathavesafetyorsecurityaspectsarecertainlycritical andcouldbeharmful.however itissomewhatdifficulttodetermine thepotentialsafetyhazardsorimplicationsofaconflictastheycan dependonthespecificdeployment.forexample ifaconflictcauses asmartoutlettoremainon whetheritisasafetyhazarddependson what is plugged into the smart outlet e.g.
toaster versus led light.
nevertheless evenbenignconflictscanrenderappsuseless they makeasmarthomesystemunpredictableandunreliable ultimately makingthe systemless useful.
ourultimategoalistoidentifyall avoidable conflictsandtheir possiblesourcessothatactionscanbetakeninfuturedevelopment and ordeploymenttomitigatepotentialconflicts.someconflicts canbepotentiallyhandledbythedevelopmentofapiwithsupport forcommonappinteractionpatterns.onthecontrary ifphysical proximity is a concern we could develop an analysis that warns the user during installation.
this explains why we treated these twoscenarios differently.
device interaction this section presents our findings for apps that form pairs with deviceinteractions.
when we first studied this category we found that some apps monitor status changes but do not initiate any changesondevices.whensuchanappispairedwithanotherdevice monitor app both apps concurrently read the device status and neitherofthemmakesanychangestothedevicestatus.werefer to such a pair of apps as having a read read relationship.
.
pairs have this relationship andthus do not interact.
we classifiedtable statistics for deviceinteraction.
relationship pairs percentage read read .
non conflicting interactions direct direct .
composable .
different feature .
same feature .
.
conflictinginteractions featureconflicts .
invalid local state .
dropped update .
.
total deviceinteractions into non conflicting andconflicting interactions the statisticsofthe classification are reportedintable .
.
rq1 typesofnon conflicting interactions weobservedthreetypesofnon conflictinginteractions.first although two apps can access the same device their accesses can only be triggered manually by users.
consequently whether they conflictwitheachotherdependsonhowusersoperatethem.for example big turn onis such an app it turns on switches when theusertouchestheapp suserinterface .twousersmayconcurrently initiate conflicting commands to a switch through two appslike big turn on.weconsiderthistypeofconflictsoutofthe controlofapps.werefertothistypeofinteractionasa direct direct relationship.wefoundthatthisrelationshipholdsfor20 .
app pairsinthe devicecategory see table .
second certainappscanworktogethertorealizedesiredfunctionality and hence are intended to interact with each other.
we refertothistypeofinteractionasa composable relationshipandcorrespondingappsas composable apps.wefoundthatthiscomposable relationship holdsfor .
pairs inthe devicecategory.
note that many of these composable apps were developed independently.forexample the fireco2alarm appsetsoffthealarm and triggers door unlocks when smoke fire is detected while theinitial state event streamer app monitors and forwardseventsfrommanydevicesincludingthealarmdevicehandler toawebsite thatallowsuserstoremotelymonitordeviceactivities.thesetwoappswereindependentlydeveloped buttheycould interact to fulfill a desired functionality at run time notifying a userthroughthe specific website that an alarm issetoff.
third some apps simultaneously access different features of the same device or the same feature of the same device in a consistent way andhence do not conflictwitheachother.
an example of the former i.e.
accesses to different features is thekeep me cozyandthermostats pair of apps from thethermostatsgroup.oneappcallsmethodsonthethermostat to set heating orcooling points e.g.
setheatingsetpoint and setcoolingsetpoint while the other app sets the mode of the thermostat e.g.
viasetthermostatmode .
although these two apps control the same shared device they operate on different featuresofthedevice.hence althoughthefirstapp interacts with the second app there is no conflict between them.
we refer to this interaction as a different feature relationship and found this relationship holdsfor .
pairs inthe devicecategory.
1220understandingandautomatically detectingconflicting interactions ... esec fse november8 virtualevent usa anexampleofthelatter i.e.
consistentaccessestothesamefeature is the following pair of apps from the locks group the lockit at a specific timeandauto lock doorapps .
both appscall lock.lock todoor lock.weconsiderthisinteraction non conflicting since these apps actions would lead the shared devicetothe samestate andhencetheexpectedoutcomeisnotcompromised.werefertothisinteractionasa same feature relationship andfounditto holdfor .
pairsinthe devicecategory.
.
rq2 typesofconflicting interactions of the app pairs in the devicecategory pairs exhibit conflictingbehaviors.
we classifiedthese conflictingbehaviors as eitherfeatureconflicts andsaved stateconflicts .
feature conflicts.
there are many pairs where the two apps attempt to update the same device state with incompatible values .
an example is the fireco2alarm andlock it when i leavepair discussed in section .
recall that the fireco2alarm app attempts to door unlock during a fire while the lock it when i leaveapp couldpotentiallydoor lock.
werefertotheseconflictsas feature conflicts.
a majority of the app pairs .
pairs in the device category have feature conflicts.
saved stateconflicts.
manyappsusetheirlocalvariablestokeep track of device states and guide their own device updates.
these appseasilybecomebrokenwhenpairedwithotherappsthatcan updatethe same devices a concurrentupdatefrom the otherapp wouldmake this app svariable inconsistentwiththe device state.
consider auto humidity ventthat turnson off afanbased on thehumiditylevel .thisappconflictswiththe big turn offapp thatallowsausertomanuallyturnoffthefan forthefollowing reason.when auto humidity ventdetectsthattheroomhumidity isaboveathreshold itturnsonthefanandsimultaneouslyupdates its local state variable state.fanson totrue.
a user may then use thebig turn offapp to turn off the fan causing the room humidity to increase above the threshold.
unfortunately since the local variable state.fanson remainstruein theauto humidity ventapp unaware of the fan being turned off by big turn off auto humidity ventwouldstopfunctioning incorrectlyassuming that the fan is already on.
we refer to this scenario as invalid localstateconflicts and found that .
pairs in the devicecategory exhibitthis pattern.
acommonpatternweobservedisanappthatstoresandrestores thestateofadevice.forexample the thermostat auto offapp restores the state of the thermostat to a previously stored state.
consider an execution in which after the thermostat auto off app saves the current state e.g.
off of the thermostat into a local variable a second app changes the actual device state to a different value e.g.
cool whichdoesnotpropagateto thermostat autooff sinternalstate.thenexttime thermostat auto offtriesto restore the thermostat state the restoration will be based on the staleand wrongvalue savedin the local variable.
thusthe update performed by the second app is dropped.
we refer to this scenario asdropped update conflicts andfound121 .
pairsinthe device category exhibitthis pattern.
.
rq3 prevalence ofconflicts asreportedintable .
ofthepairsin devicecategoryhave actualinteractions i.e.
atleastonedeviceupdatesthedevicestate table statistics for physical medium interaction.
medium pairs percentage non conflicting interactions water .
sound .
.
conflictinginteractions water .
motion .
light state .
light color .
light brightness .
light combination .
.
total while8.
ofthepairshave read read relationshipsandhencedo not actually interact.
of the pairs that have actual interactions the majority .
have conflicts.
.
rq4 unsafe coding patterns wefoundthereareatleasttwounsafecodingpatternsfor device interactions blind update and saved state .theblind update pattern occurs in apps that blindly update the same state of the same device without checking the currentstate of the device.the saved state pattern occurs when an app that saves the state of a devicefeatureintoalocalvariableandlaterusesthesavedvalue.
thismaycauseupdatesfromotherappstobediscarded.insome cases a check of the current state before the update could help the app verify that its local state is consistent with the device state.
however with the existing apis there is no way to do the check and update in an atomicway an app could only retrieve thedevicestatebyinvokingamethod m1andthenupdatethestate by invoking another method m2 the state could be changed by anotherapp after m1returns but before m2iscompleted.
physical mediuminteraction this section presents our findings for apps that interact via the physical world.
in this category two apps are paired when the output from the first app can physically become the input of the secondapp andaffectits operation.
table 4reports our findings.
.
rq1 typesof non conflicting interactions motion.the first set of physical interactions are due to motion.
anexamplepairis neato connect andforgiving security .neato connect is a third party app that controls a neato vacuum cleaningrobot.whentheappactivatestherobot therobot starts cleaning the house.
while it is moving around the house its movementcouldtriggeramotionsensorusedbythe forgiving security appandthussetoffasecurityalarm a falsealarm .of the app pairs in the physical medium category pairs .
interact viamotion andallexhibit conflicts.
light.a similar set of app pairs are based on interactions via light.
theturn on at sunsetandlight up the nightapps are an example.
consider a deployment in which each app controls adifferentlightbulb.atsunset the turn on at sunsetappmay turn on a light bulb whose light may affect the illuminance sensor of thelight up the nightapp.
the light up the nightapp is supposedtoturnonalightbulbwhenitsilluminancesensordetects 1221esec fse november8 virtualevent usa trimananda aqajari chuang demsky xu andlu thatthesurroundingisdark.ifthelightbulbcontrolledbythe turnon at sunsetapp is sufficiently close to the illuminance sensor usedbythe light up the nightapp thesensormaypickupsome lightfromthelightbulb.thiscouldcausethe light up the night apptodeterminethatthereisnoneedtoturnonthelightbulb and hence the twoapps conflict.
someapps can control alight bulbby changingitson off state colors orbrightnesslevels.anyofthesechangescanpotentially be detectedbyan illuminancesensor .
table4summarizesourfindings 151pairs .
haveaconflict throughthechangeoflight son offstate 20pairs .
conflict throughthechangeoflight s color 5pairs .
conflict through thechangeoflight sbrightness and29pairs .
conflictthrough acombination ofthe three.
water.physical interactions can also occur via water.
an example pairthatinteractsviawaterconsistsofthe sprayer controller andclose the valveapps .the formerschedules irrigation for a certain amount of time periodically while the latter closes awatervalvewhenthewatersensordetectsmoisture.whenthe water coming from a water sprayer controlled by the sprayercontroller 2app reaches the water sensor used by the closethe valveapp the two apps interact.
this interaction potentially results in a conflict because a bad moisture sensor placement could causethe close the valveapptopreventtheirrigationthathas been scheduledbythe sprayer controller 2app.
ourresultsshowthat21pairsinteractthroughwater 11ofthem haveconflictand10donot.ineachofthese10pairs theappthat controls the water valve actually closes it when it detects moisture.
therefore no water can be produced and detected by the water sensor ofthe otherapp.
sound.apps can also interact via sound.
for example an interestingapppairis bose soundtouch controlandinfluxdb logger which reads from a sound sensor .
in fact the latter can be paired with any other sound producing apps such as those that controlspeakers alarms ormusic players.
our findings show that there are pairs .
that interact via soundbutwecouldnotfindanyconflictsamongthem.typically a pair consistsof asound producingapp andthe influxdb logger app.
since the influxdb loggerapp only logs the status of the sound sensor the two apps are actually composable similar to the composable relationship inthe deviceinteraction see section .
.
physical factors.
thephysical medium interaction depends on certainphysicalfactors.thepositionofthefirstapp sactuatorrelativetothesecondapp ssensordetermineswhethertheoutputfrom theactuatorcouldreachthesensor.iftheirproximityissufficiently close for the actuator s output to affect the sensor the two apps interact otherwise they do not.
when we performed this study we assumed that theirlocationsare sufficientlyclose.
althoughit isaconservativeapproximation thisisthebestwecoulddoand our findings can help developers and users to avoid such conflicts.
.
rq3 prevalence ofconflicts unsafe coding table4summarizes thestatistics forthe physical medium interaction pairs.
our findings suggest that typically when a pair of apps interact through aphysical medium they will most likely conflict.
in most cases the second app does not expect to receive any inputtable statistics for global variable interaction.
relationship pairs percentage read read .
non conflicting interactions direct direct write write .
appwrite read .
direct write read .
app app write write .
.
conflictinginteractions app app write write .
app direct write write .
.
total fromthefirstapp.itnormallyexpectssensorinputsfromitssurroundings.
out of the325 pairs with physical medium interaction .
294pairs ofthemhaveaconflict.wedidnotobserveany codingpatternsthatcauseconflictsinthiscategory.hence weconcludedthatthe conflictinpairswith physical medium interaction is caused mainly by the physical proximity between theactuators andsensors ofthe conflicting apps.
global variable interaction this section presents our findings for app pairs that have globalvariableinteractions.asdiscussedinsection .
sincesmartthings onlyhasoneglobalvariable location.mode thatallowsbothreads andwrites weconsidertwoappstohave global variable interactioniftheybothaccess location.mode .ourstatisticsarereported in table5.
.
of the pairs reported as pairs with readreadrelationships in table contain apps that only read from location.mode .theseapps do not actuallyinteract.
.
rq1 typesofnon conflicting interactions the first type contains apps that only write location.mode and theyarecontrolledmanuallybytheuser.werefertothisasa directdirectwrite write relationship.asdiscussedearlierinsection .
wedidnotconsidertheseappsasconflictingsincetheusercontrols them.
thisgroupcontains28pairs .
reportedaspairswith direct directwrite write relationships intable .
asecondtype consistingof302apppairs .
exhibits app write read relationships exemplifiedbythe greetings earthling andhello home phrase director apps .thegreetings earthling app changes the value of location.mode when the presence sensor detects that the homeowner arrives home.
on the other hand the hello home phrase director app sends a greeting message to the homeowner depending on the value of location.mode .
in this case the two apps have a composable relationship one app reads the variable updatedbythe other.
athirdtype consistingof221apppairs .
exhibits direct write read relationships one app requires the user to manually controltheapptowriteinto location.mode whiletheotherreads from it.
this is the intended usage scenario of location.mode namely to facilitate interactions between apps through mode changes.hence these write read interactions are not conflicts.
finally we found one pair in which both apps write into location.mode and yet do not conflict.
this pair consists of thegreetings earthling andbon voyageapps .
the greetings earthling appwritesinto location.mode whenthe user arrives at home while the bon voyageapp writes into the 1222understandingandautomatically detectingconflicting interactions ... esec fse november8 virtualevent usa same location when the user leaves.
hence they do not conflict as they have disjoint intents and never write at the same time.
this is an exception to our current formal definition that can be improved.
.
rq2 typesofconflicting interactions when two apps both write into location.mode in most cases conflicts would result.
there are two types of write write conflicts app appwrite write andapp directwrite write .forexample there exists an app app write write conflict between the smartsecurity andgood nightapps which both attempt to write into location.mode .
while the smart security app updateslocation.mode withhome thegood nightapp changes location.mode tonightoraway.
insmart security the update tolocation.mode occurswhenintrusionisdetected.thisisrather animportantupdateandtheusercertainlydoesnotwanttheresult of thesmart security app to be compromised.
there are pairs .
ofsuch conflicts.
anapp direct write write conflict occurs when in one app the updateoftheglobalvariableistriggeredbyanon userinput e.g.
a sensor whilein the other appthe user performs anoperationthat triggers the update.
for example the first app uses the motion sensor to detect if there is anyone home and updates location.mode based on the sensor input.
the second app lets the user control the light whentheuserturnsonthelight location.mode isautomaticallyupdated.this category has .
conflicting pairs.
.
rq3 prevalence ofconflicts andunsafe coding thereareatotalof124 .
conflictingapppairs.thus conflicts arenotprevalentfor this type ofinteraction.
we found that concurrent writes tolocation.mode is an unsafe pattern whichisduetothesmartthingsapisthatallowappsto directly change the value of location.mode .
for instance inthe caseofthe smart security app agoodpracticewouldbetonot allowotherappstowriteinto location.mode whenthealarmis sounding otherwise thealarmmaybestoppedabruptlybeforeit isnoticed.
in the case of modes the combination of changing the api to specify a duration for the mode change and allowing the userto specifypriorities wouldresolve manyofthe conflicts.
detectingconflicts in this section weaddress rq5 howcan we automatically detect conflicts?
wedevelopediotcheck atoolthatautomaticallyidentifiesconflicts bymodel checking pairs of apps.
a model checker checks exhaustivelyandautomatically ifasystemmeetsaspecification.
model checking is particularly useful in detecting app conflicts due to its ability to exhaustively check all potential interactions between apps.
we begin by summarizing the key insights from our manual studythat weusedfor designingiotcheck.our studyshowsthat mostdeviceconflictsoccurwhentwoappsissueconflictingupdates to the same device.
we found that when one app writes to a device featureandanotherappreadsfromthesamedevicefeature ittypically doesnot representa conflict thisscenariocommonlyoccurs when apps compose.
we also found that it is important to considerthereasonwhytwoappsperformconflictingupdates.ifbothupdates are performed in response to user requests there is typically noconflictsincetheactionsaretriggeredbytheuser.finally we foundthatconflictson global variablesoccur onlywhentwo apps bothwritetotheglobalvariable read writeinteractionstypically representnormalcooperationbetweenapps notconflicts.iotcheck model checks pairs of apps and monitors for conflicting updates to thesamedeviceorglobalvariablesfromdifferentapps.iotcheck directly executes the original app code eliminating the need to build models of the apps.
iotcheck extends the java pathfinder jpf an explicit state basedmodelchecking infrastructure .
app codeiotcheck preprocessorinstrumented groo nj code iotcheck coni i uration tool app coni i uration groo nj compiler bnjtecode fileiotcheck simulation framed ork iotcheck monitor jpf d ith groo nj iotcheck eljtensions coni lict analnjsis report figure iotcheckarchitecture.
architecture.
figure3presentsiotcheck sarchitecture.
thearrows represent the workflow of iotcheck that starts from app code as an input to the iotcheck configuration tool and iotcheck preprocessor.eachsmartthingsapphasaconfigurationmethod that asks users for configuration information while most of the configuration can be automatically generated apps can ask for arbitrary input and thus part of the configuration requires human help.
the iotcheck configuration tool runs this method automaticallyconfiguresmostoptions andaskstheuserfornon standard options.
the iotcheck configuration tool then outputs app configurationfiles which togetherwiththeoriginalapp areprocessed bytheiotcheckpreprocessor.theiotcheckpreprocessorgeneratesmodelcheckerhookstoenablejpftogeneratedeviceevents combines multiple apps into the same program and sets up the necessary configuration to run the program.
it then outputs instrumentedgroovycodewhichiscompiledintobytecodebythe groovy compiler.
we developed a smartthings simulation framework for iotcheck.
this framework contains virtualized devices i.e.
devicehandlers forallofthedevicesusedbyourbenchmarkapps.
while an actual smartthings device handler controls an actual device a virtualized device handler changes the value of a state variablethatrepresentsthevalueofadevicefeature.thus avirtual devicehandlerforadoorlockchangesthevalueofthedoorlock state variableinsteadofcontrollinganactual zigbee doorlock see figure1 .
these device handlers are under the control of the jpf modelchecker jpftriggersdeviceeventssuchasamotiondetected byamotionsensor oratemperaturevaluechangedetectedbya temperature sensor.
for devices such as temperature sensors there isalargerangeofpotentialtemperaturesthatwouldmakemodel checkinginfeasiblewithoutusingsymbolictechniques.iotcheck thus supports a set of potential temperature readings e.g.
a hot 1223esec fse november8 virtualevent usa trimananda aqajari chuang demsky xu andlu reading and a cold reading which is practical given the nature of many smart home apps.
iotcheck does not currently model physical interactions betweendevices other than toflag thatthey could potentiallyinteract this remainsfuture work.
finally iotcheckmodel checksthegeneratedbytecodeusing the jpf model checker.
we developed iotcheck conflict analysis asajpflistenerthatperformstheanalysiswhilejpfisexecuting the bytecode.
when a conflict is detected the listener halts jpf and immediately reports the conflict.
otherwise jpf finishes its executionandthe listenerreports that there isnoconflict.
challenges.
there are challenges in extending jpf for iotcheck jpfdoesnotprovideout of the boxsupportforchecking groovy code.
one challenge is that the groovy runtime system keeps its own internal state that thwarts jpf s state matching algorithm this often prevents even very simple groovy programs from model checking.iotcheckextendsjpftoconsideronlythestateof thevirtualsmarthomedevicesandtheappswhenmatchingstates it ignores state changes that are internal to the groovy runtime library and do not affect the behavior of apps.
this creates a second issue jpf generates state matching points at many execution points.aftereliminatinggroovyruntimestatefromstatematching therecanbespuriousstatematchesterminatingjpfbeforethestate space is fully explored.
to solve this problem iotcheck extends jpfto only matchstates right before generatinganewevent.
groovy is a dynamic language.
thus method calls are resolved at runtime via java reflection jpf was missing this feature and we had to extend it.
furthermore the same call stack from the perspective of the program can be implemented by many differentbytecode level call stacks due togroovy s method lookup and caching mechanisms.
since the call stack is considered by jpf s state matching algorithm this can cause the algorithm to fail to match conceptually identical states and increasethe statespace to beexplored.iotcheckextendsjpf sstatematchingalgorithmto match conceptually identical call stacks with different bytecodelevel stacks.
scalability is a challenge for jpf as an explicit state model checker.
iotcheck initially exhaustively model checks a app pair for up to minutes.
if it either a detects a conflict or completes iotcheck outputs the result and finishes.
otherwise iotcheck falls back on jpf s heuristic search and performs it for an extended minute period.
if no conflict is detected during this period or the tool runs out memory usually caused by bigger apps that have tens of events iotcheck reports that the result is inconclusive.futureworkcanemploytechniquessuchaspartialorder reduction to further improve iotcheck s performance.
detection.
conflicts cannot be directly checked on the executions jpfexploresbecausestate basedmodelcheckingisonlyguaranteed to explore all program states and transitions and not all possible pathsthroughthestatemachine.considerapps 1and 2where 1 onlyturnsthelightonand 2canturnthelightonandoff.aconflict only occurs when 1turns the light on followed by 2turning the lightoff.however allstatesandtransitionscanbereachedwithout exploring this execution path.
thus we must analyze the state machine to determinewhether itcontains aconflicting path.
iotcheck s conflict analysis is an online analysis of the state machine that jpf explores.
our analysis is similar to a standard dataflow compileranalysiswith theexception thatinour contexttable comparisonbetween manualstudyand iotcheck.
interaction iotcheck manual study conflict noconflict device conflict noconflict not terminated excluded global variable conflict noconflict not terminated excluded nodesrepresentstatesandedgesrepresenttransitions.iotcheck updates its analysis results as jpf explores new states and halts the exploration process when a conflict is detected.
we abstract state machine as a set of nodes n nthat represent the jpf states and edges e ethat represent transitions between jpf states.
wedenotesequencesofactionsusing a see execution trace definitions in section .
.
each transition ehas a corresponding sequence of actions ae.
the relevant actions are write d r v andmodewrite .
we define in n to be the set of incoming edgestonandsrc e tobethesourcenodeoftheedge e.theanalysiscomputestheset s n ofthemostrecentupdatestoeachdevice featureandmodeatnode n.wedefine app s d r tobethesetof appsthathavemostrecentlyupdated rondandvalue s d r tobe thevalueofthatupdate.wedefine modeapp s toreturnthesetof apps that have most recently updated the mode and modevalue s to return the valuesofthe mostrecent updateto the mode set.
figure4presentsequationsthatformalizeouranalysis.these equations are evaluated using a standard fixed point algorithm wheneverjpfexploresanew transitiontoeitheranexistingstate oranewstate.function appliesthesequenceofactionsintransitionto thesetsfor thepreviousnodetocomputethetransition s contributionstosetsforthedestinationnode.thefunction update applies an action to sets.
results.
we repeated the same set of evaluations but using iotchecktocheckforconflictsinsteadofmanualinspection.table6comparesiotcheck sresultswiththosefromthemanualstudy.
we did not use iotcheck to detect conflicts in physical medium interactionssince theseconflictsdepend onphysical factors.
forthedeviceinteraction weinitiallyfound829conflictingpairs through manual study pairs with feature conflict pairs with invalid local state conflicts and pairs with dropped update conflicts seetable .fromthe829pairs wehadtoexclude100conflicting pairs because of the apps that we could not run on iotcheck 5apps usethird partyfeatures and3apps have seriousbugs.because of these apps we also had to exclude non conflicting pairs.
overall iotcheck was able to find conflicts in pairs but failed to detect conflicts in pairs a thorough manual inspection confirmed that pairs are indeed non conflicting i.e.
mistakes in ourmanualstudy whileotherconflictswerenotdetecteddueto iotcheck slimitations e.g.
inourmodelingoftime .italsodidnot terminate for pairs labeled as conflicting in the manual study but4ofthemareindeednon conflicting.surprisingly iotcheck found newconflicting pairs that were overlooked in our manual studyandlabeledasnon conflicting.thus intotaliotcheckfound 717conflicting pairs.
forthe 497pairslabeledasnon conflicting inthe manualstudy iotcheckconfirms that101pairsareindeed non conflicting whereas itdidnot terminatefor 396of them.
1224understandingandautomatically detectingconflicting interactions ... esec fse november8 virtualevent usa s n uniontext.
in n ae ismanual s in s s a write d r v s braceleftbigg conflict if a app s d r .a value s d r v update a s write d r v otherwise a modewrite s braceleftbigg conflict if a modeapp s .a modevalue s update a s modewrite otherwise update s a a s a a a write d r v write d r v d d r r modewrite write d r v false modewrite modewrite true figure conflict analysis for theglobal variable interaction our manual study found pairsofconflictingapps 44pairswith app appwrite write conflicts and80pairswith app directwrite write conflicts seetable .with iotcheck we were able to find conflicts in of the pairs.
we had to exclude of the pairs with conflicts because of apps that wecouldnotrunoniotcheck 5appsusethird partyfeaturesand1 app has serious bugs.
additionally iotcheck found pairs with a conflict that was initially labeled as a non conflicting pair.
because weexcluded6apps wehadtoexclude235non conflictingpairsinitiallyobservedinthemanualstudy.
amongthe706non conflicting pairslabeledin themanualstudy iotcheckwasable tocomplete itscheckandfoundnoconflictsin318ofthem.iotcheckdidnot terminate for of them.
for the physical medium interaction iotcheckgenerates awarningif one app uses adevice that could be the physical inputofadevice usedbythe otherapp.
statistics.
theaverageruntimeforiotchecktofindconflictsis seconds for the deviceinteraction and seconds for the globalvariableinteraction.
these suggest that conflicts are found quickly the30 minutetimelimitisenoughtoperformanexhaustivemodel checkingingeneral.thus classifyingnon terminatingrunsasnonconflictgivesiotcheckaprecisionof100 andaspecificityof100 .
the recall is .
for the deviceinteraction pairs and for the global variable interaction pairs overallrecallis95.
.
falsepositives.
the false positives negatives in our manual study were typically due to subtle issues involving complex logic that had several conditions for generating commands or subtle concurrentexecutions pleaseseeourtoolanddatasetreleasesforafull accounting .
related work the research community has recently looked into smart home apps .fernandes et al.present a thorough study on the smartthings environment .
they pointed out underlying security issues and a simple program analysis to detect the overprivilege issue in the app source code.
in fernandes et al.present a solution to prevent applications from leaking confidential information.
researchershavepresentednewtechniquestomodel checkand analyze confidential information leakage in smart home applications.
thetechniques presented in requiretranslatingthe apps to perform the model checking using spin .
the limitation is that the expressiveness of app features could be lost in translation with just3 apps the authors found feature that their system could not express concisely .
other work ignores internal application state and thus admits executions that cannot happen.
several of our apps depend on internal state todecidewhethertoperformanaction andthustheywouldnotbe accuratelymodeledbytheirtechniques.whileconflictsbetween apps are discussed in they considered a much smaller corpus of apps and a number of of them are self crafted to generate theintendedconflicts.unfortunately theirsystemisnotpublicly available for comparison.
theinteractionsofsmarthomeappsalsoappearsimilartoeventbased races inmobile apps .
related work on mobile apps deals with events only in one app by introducing various newsynchronization mechanisms.however our work focuses on theinteractionsbetweenmultipleapps.theeventhandlersinthese appsaredevelopedbydifferentprogrammerswithabsolutelyno coordination.
inaddition a numberofapps alsoallowthe user to generate arbitrary events e.g.
using a touch screen.
hence even if the ordering between events in one app can be clearly defined the ordering between events across multiple apps combined with usergeneratedeventsiscomplicatedandarbitrary synchronizations inindividualapps wouldnot be useful inthis context.
there have also been efforts to resolve the conflicts between smarthomeappsfromtheperspectiveofdependenciesbetweenapplicationcomponentsatthesystemlevel .several systems provideframeworksforprogrammingnetworks of sensors and actuators.
depsys provides infrastructure with comprehensive strategies to specify detect and resolve conflicts throughtheuseofuser specifiedmetadata.kripke performs conflict detection through the use of model checking.
our work is orthogonaltothisbodyofworkthatattemptstodealwithconflicts betweenappsatthesystemlevel byviewingappsasblackboxes.
ourwork onthecontrary studieshowappsinteractandwhatcan be done at the sourcecode level to mitigate conflicts.
conclusion this paper presents a comprehensive study of interactions and conflictsbetweensmarthomeapps aswellasanautomatedtool for finding conflicts.
these results can be readily used to guide future designofsmart home systemsandapps.