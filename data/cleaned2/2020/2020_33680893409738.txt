jshrink in depth investigationinto debloating modernjava applications bobby r. bruce universityof california davis u.s.a bbruce ucdavis.edutianyizhang harvarduniversity u.s.a tianyi seas.harvard.edujaspreet arora universityof california los angeles u.s.a jasa92 g.ucla.edu guoqing harryxu universityof california losangeles u.s.a harryxu cs.ucla.edumiryungkim universityof california losangeles u.s.a miryung cs.ucla.edu abstract modern software is bloated.
demand for new functionality has leddeveloperstoincludemoreandmorefeatures manyofwhich becomeunneededorunusedassoftwareevolves.thisphenomenon known as software bloat results in software consuming more resources thanitotherwiseneedsto.
how toeffectively and automaticallydebloatsoftwareisalong standingprobleminsoftware engineering.
various debloating techniques have been proposed sincethelate1990s.however manyofthesetechniquesarebuilt uponpurestaticanalysisandhaveyettobeextendedandevaluated inthecontextofmodernjavaapplicationswheredynamiclanguage features are prevalent.
tothisend wedevelopanend to endbytecodedebloatingframework called jshrink.
it augments traditional static reachability analysis with dynamic profiling and type dependency analysis and renovates existing bytecode transformations to account for new language features inmodernjava.
we highlightseveralnuanced technicalchallengesthatmustbehandledproperlyandexamine behavior preservation of debloated software via regression testing.
we find that jshrinkis able to debloat our real world java benchmark suite by up to on average accounting for dynamic language features is indeed crucial to ensure behavior preservation reducing of test failures incurred by a purely static equivalent jax and for proguard and compared withpurelydynamicapproaches integratingstaticanalysiswith dynamicprofilingmakesthedebloatedsoftwaremorerobusttounseentestexecutions in22outof26projects thedebloatedsoftware ransuccessfully under newtests.
ccs concepts software and its engineering automatic programming objectoriented languages .
bobbyr.
bruceand tianyizhang contributed equally to thispaper.
esec fse november 8 13 virtual event usa copyright held by the owner author s .
acm isbn .
java bytecode size reduction reachabilityanalysis debloating acmreference format bobby r. bruce tianyi zhang jaspreet arora guoqing harry xu and miryung kim.
.
jshrink in depth investigation into debloating modernjavaapplications.in proceedingsofthe28thacmjointeuropean software engineering conference and symposium on the foundations of softwareengineering esec fse november8 13 virtualevent usa.
acm newyork ny usa 12pages.
introduction the size and complexity of software has grown tremendously in recentdecades.thoughlargelybeneficial thishasledtounchecked bloatissuesthatareespeciallysevereformodernobject oriented applicationsduetotheirexcessiveuseofindirection abstraction andeaseofextensibility.thisproblemofcustomizingandtailoring modern applications to only used components in an automated fashion isalongstandingproblem .
priorworkoncodesizereductionfocusesprimarilyonc c binaries motivated by the long held belief that c c programs are easier to attack and are often choices for developing embedded systems.
however with the rise of cloud computing android basedsmart phones andsmart homeinternetof the things a managed object oriented language such as java ismakingitswayintoallimportantdomains.althoughreducing thesizeofjavabytecodemaynotultimatelyleadtoasignificant improvement in a traditional stand alone machine setting itsbenefit becomes orders of magnitude more significant in many modern small andlarge scalecomputing scenarios smallerbytecode size directly translates to reduced download size and loading time in smartphones and reduced closure serialization time in big data systems suchasapache spark theseare allimportant performance metrics for which companies are willing to spend significant resourcesin optimizing.
however past work has not given much attention to java especially modern java applications.
of particular interest to us is tip et al.
s work in the late 1990s that proposes various debloatingtransformations whichhavesincebeenutilizedbyother researchers .insurveyingtheliterature wefindthattheir effectivenesshasyettobesystematicallyevaluatedonareal world benchmark of modern java applications.
all previous implementations of those bytecode transformations relied on pure static 135this work is licensed under a creative commons attribution international .
license.
esec fse november8 virtualevent usa bobbyr.
bruce tianyi zhang jaspreet arora guoqing harry xu andmiryungkim analysistoidentifyreachablecode herebyignoringcodereachable through reflection dynamic proxy callbacks from native code etc.
recent studies find that dynamic language features are prevalent and they pose direct challenges in the soundness of static analysis .
this unsoundness makes debloating unsafe removing dynamically invoked code and inducing subsequent test failures.
furthermore evaluations in prior work focus mostly on size reduction rather than behavior preservation which raises a big safety concernfor adoptingdebloating techniques inpractice.
therefore weundertaketheambitiouseffortofmodernizingand evaluating java bytecode debloating transformations and quantify the tradeoff between size reduction and debloating safety.
we augment static reachability analysis with dynamic profiling to handle newlanguagefeatures e.g.
dynamicproxy pluggable annotation lambda expression etc.
we incorporate a new type dependency analysis to account for various ways to reference types like annotationsandclassliterals toensuretypesafety.weextendfour kindsofdebloatingtransformations methodremoval fieldremoval method inlining andclass hierarchy collapsing into a fully automated end to enddebloating framework called jshrink.
to effectively evaluate those bytecode transformations we built anautomatedinfrastructuretoconstructabenchmarkofreal world popular java applications.
we applied a rigorous set of filtering criteria reputationscorebasedonthegithubstarratingsystem executabletests amavenbuildscript whichprovides a standardized interface for obtaining library dependencies and regressiontesting and compatibilitywiththeunderlyingbytecode analysis framework soot .
the availability of runnable testcasesenablesustoexaminetowhatextentthebehavioroforiginal software is preserved after debloating via regression testing.
currently theresultingbenchmarkincludes22projectswithsloc ranging from to and with up to library dependencies.
wethenapply jshrinktothisbenchmarktoquantifysizereduction the degree to which test behavior could be preserved and the impact ofjava dynamiclanguagefeatures.
rq1how much java byte code reduction is achievable when applyingdifferentkindsoftransformations?
rq2to what extent does jshrinkpreserve program correctness when debloating software?
rq3what are the trade offs in terms of debloating potential and semantic preservation?
rq4howrobustisthedebloatedsoftwaretounseentestexecutionssuch as newtest cases?
jshrinkreducesaproject ssize applicationandincludedlibrary dependencies by up to .
.
on average .
the method removalcomponent reduces the application by the most .
on average followedby methodinliner .
onaverage fieldremoval .
onaverage and classhierarchycollapser .
onaverage .
a hybrid static anddynamic reachabilityanalysis is necessary for improvingbehaviorpreservationofdebloatedsoftware.
jshrink doesnotbreakanyexistingtestsfor22outof26javaprojectsafter debloating whilethreeexistingtechniques jax jred and proguard that rely on pure static analysis preserve behavior for only and projects respectively.
while this comparisonintermsofthenumberofprojectsmaylookmarginal of test failures encountered in jax for proguard can be actuallyremoved by jshrink s enhancements.
this result implies the effort of handling new language features is absolutely necessary and worthwhileforimprovingbehaviorpreservation whichjustifies the need to address the long standing debloating problem in the modern context.
we find that size reduction potential is minimally impacted by this incorporation of dynamic reachability analysis.
weonlysacrificesizereductionby2.
onaverage whileprovidingmuchstrongerbehaviorpreservationguarantees.toachieve behavior transformation we enable checkpointing a feature ofjshrinkwhere transformations are reverted if they are found to breakthesemanticsofatargetprogram.thoughthisstrategyincursmarginallossesinsizereduction .
onaverage webelieve checkpointing to be a practical solution for balancing semantic preservationandcode size reduction benefits.
our work makesthe following contributions wepresent jshrink anend to endjavadebloatingframeworkthatmodernizesfourdistinctbytecodetransformations.
it includes significant andnovelextensions to make debloatingmuch safer inamodern context.
wefindbytecodereductionofupto46.
ispossible where reachability based method removal plays a dominant role in size reduction.
jshrinkensures that debloated software still passes98 ofexisting tests.
we demonstrate the necessity of handling dynamic features and ensuring type safety.
jshrinkremoves and of test casefailures incurredbyjax andproguard .
weputforwardanautomatedinfrastructureofconstructing real world java applications with test cases a build script andlibrary dependenciesforassessing debloating potential andchecking behaviorpreservationusing tests.
themainresearchcontributionofthispaperis onsystematizationofthecommunity sknowledgeofjavadebloating inthemodern era.
as a reference point several top conferences have alreadystartedtohavea systematizationofknowledge track with the goal to address the concern that the community seems to lose memoryofthingsthathavebeendoneinthepast.
withthispaper we hope to bring existing debloating techniques into a contemporarycontextwheredynamicfeaturesare prevalentand where behaviorpreservationmustbeensuredandcheckedusingtests.by conducting rigorousevaluation using real worldbenchmarks we provide evidence that prior debloating work indeed suffers from poor behavior preservation.
we then demonstrate that behavior can be preserved to a significantly greater extent by incorporating newcomponentstoexplicitlyaddressdynamiclanguagefeatures and type safety.
we make publicly available the jshrinksource code and additional resources necessary to replicate our results at .asacompanionpiece to this work we have prototyped jshrinkas an entirely online saas whichwecall webjshrink .webjshrink providesarich graphicaluserinterfaceforthefunctionalitydescribedinthispaper.
additionally it can offload debloating analysis and transformation tothecloudandpresentuserswithabreakdownofwherethebloat existswithin atarget project.
background scope java bytecode.
the problem of software bloat has been a center of research studies for more than a decade in the area of 136jshrink in depthinvestigation intodebloating modernjava applications esec fse november8 virtualevent usa performancetuning andoptimization.
recently there isarevived interest partlyduetotheneedofcyberdefense e.g.
usnavy s totalplatformcyberprotection tpcp program inextending traditional debloating techniques to reduce code size improve runtime performance and remove attack surfaces for a wide spectrum ofsoftwareapplications includingjavascriptprograms native applications anddocker containers .
in this paper we focus on code size reduction as opposed to runtime memory bloat that was the target of a large body of prior work .
while code bloat exists commonly in a broad rangeofapplications wefocusonobject orientedprograms specificallyjava bytecode as our scope for tworeasons.
first the culture of object orientation encourages developers to useframeworks patterns andlibrariesevenforextremelysimple tasks resultinginalargenumberofclassesandmethods which thoughnotused atallduringexecution stillneedtobeloaded by jvmduetotype induceddependencies.theseclassesandmethods consume extra space and memory thereby negatively impacting the performance of resource constrained systems such as smart phonesoriotdevices.furthermore theycanpotentiallycontain securityvulnerabilities e.g.
gadgetsinreturn orientedprogramming whichcanbe exploitedby remoteattackers to execute code segments that could not have been reachedotherwise.
second many recent techniques on code bloat target native x86 programs aiming to reduce the size of executable binaries.
native programs are significantly different from objectorientedprogramsintermsofcompilationandexecution.native programs are statically compiled and linked with most libraries statically loaded.
in many cases a compiler can already remove much of dead code.
on the contrary object oriented programs areoften dynamicallycompiledandloaded theubiquitoususeof dynamic features such as dynamic class loading and reflection dictatesthatacompilerwouldnotknowwhichclassestoloaduntil the moment they are needed.
history staticbytecodedebloating.
inthelate1990s tipetal.developed jax which included so far the most comprehensive set of transformationstoreducejavabytecode including methodremoval fieldremoval methodinlining classhierarchytransformation and namecompression .theylaterintroducedtwomoretransformations class attribute removal andconstant pool compression in their 2002journalpaper .recenttechniquesarebasedonasubset of thesetransformations to debloat new typesof applications e.g.
android and maven libraries in continuous integration .
jred and reddroid only support the method removal and classremoval transformations whilemolly supports fieldremovalaswell.theseabovementionedtechniquesare outdatedor not publicly available .
furthermore their evaluations did not quantifythedegreetowhichdebloatedsoftwarepreservessemanticsby running existing tests.
behavior preservation is crucial for these techniques to be adoptedinpractice.
motivationformodernizingsoftwaredebloatingandassessingbehaviorpreservation.
javaoffersanumberofdynamicfeatureswidely usedinreal worldprograms reflection dynamicclassloading dynamicproxy etc.
whicharehighlychallengingtomodelthrough pure static analysis.
livshits et al.
first investigated this problem in using points to analysis to statically resolve dynamic methodinvocation targets .
other attempts focused on a specific scope ofdynamicfeaturessuchasreflection dynamicproxy etc.
most static analysis tools tolerate and encourage some level of unsoundness to keep the analysis usable and scalable .
landman et al.
conduct a systematic literature review and an empirical study to assess the effectiveness of different static analysis tools inthepresenceof real worldjavareflectionusage .theyfind that staticanalysis is inherently incomplete andreflection cannot be ignored for of projects.
this finding motivates our effort to evaluate the safety of debloating techniques in the context of dynamic language features.
in section .
we quantify this benefit ofhandlingdynamicfeatures debloatedsoftwarebasedonpure staticanalysiswouldfail more tests in26 projects.
profile augmented static debloating and checking of behavior preservation.
existingdebloatingtechniquesonlyassessthecodereduction and performance improvement achieved by different kinds of bytecode transformations .
none of them assess the correctness of reduced programs by running existing test cases .
furthermore these techniques only perform static call graph analysis to approximate used code and are incomplete in the presence of various dynamic language featuresdiscussedin section .
ergo testfailuresareinevitable asdynamicallyinvokedcodecouldbe removedbydebloating.in thispaper wetakea profile augmented staticdebloating approach weaugmentstatic reachabilityanalysis with dynamic reachability analysis using existing tests we remove codethroughstaticbytecodetransformations andwecheckbehavior preservationbyrunning existing tests after debloating.
jshrink we build an end to end bytecode debloating framework called jshrink.
given the bytecode of a java program and a set of test cases jshrinktakesthreephasestodebloatbytecodeandverifyits correctness.
in phase i jshrinkperforms profile augmented static analysistodetermineusedandunusedcode.inphaseii jshrink appliesfourkindsofdebloatingtransformations.finally jshrink rerunsthegiventestcasestocheckbehaviorpreservationbetween the originalandthe debloatedversion.
.
profile augmentedstatic analysis weapplythreetypesofanalyses staticreachabilityanalysis dynamic profiling and type dependency analysis to capture method invocation field access and class reference relationships between class entities.
this is essential to determine unused code in the presenceofdynamiclanguagefeaturesandensuretypesafetyof debloatedbytecode especiallyinclass hierarchymerging.
static reachability analysis.
static call graph analysis is a standard method used by previous bytecode debloating techniques todecideunusedmethods.givenasetofmethods e.g.
mainmethods testcases etc.
as entry points it analyzes the bodyofeachmethodandidentifiescallsitesinthemethodbody.
call graph analysis then constructs a directed graph for each entry methodandaddsedgesfromtheentrymethodtoitscalleemethods.
those callee methods are then treated as new entry points and the processcontinuesuntilnonewmethodsarefound reachingafix point.
137esec fse november8 virtualevent usa bobbyr.
bruce tianyi zhang jaspreet arora guoqing harry xu andmiryungkim due to polymorphism in object oriented languages multiple call targets could be invoked from a call site via dynamic dispatching depending on the runtime type of the receiver object.
various techniques have been proposed to approximate possible targets of a dynamic dispatch e.g.
class hierarchy analysis cha cfa rapid type analysis rta points to analysis etc.specifically jshrinkleverageschatoconstruct callgraphs whichidentifiesallcorrespondingmethodimplementationsofacalleeinthesubclassesofthedeclaredreceiverobjecttype andconsidersthemaspotentialcalltargets.weperformawholeprogram analysis including application code imported third party libraries andjre tobuildcallgraphs.inaddition weuseasm toanalyzefieldaccessesineachmethodandextendthecallgraphs withfield access information.
dynamicreachabilityanalysis.
weinitiallyconsideredusinga lightweightdynamicanalysisapproachcalledtamiflex asitis awellknowntechniqueforaddressingunsoundnesscausedbyjava reflection.
tamiflex instruments java reflection call sites to capture methodcalls and fieldaccesses via reflectionat runtime.however tamiflex is designed for reflection apis only and lacks support for other dynamic features leading to many test failures section .
.
tosystematicallyaccountfordynamicfeatures wedefineacomprehensive list of dynamic features based on sui et al.
.
all the followingdynamicfeaturesexceptserializedclassloadingappear inourbenchmark of26modernjavaapplications indicatingthe necessity ofhandling themproperly to ensure debloating safety.
reflection is a dynamic feature that enables users to dynamicallyinstantiateclasses accessfields andinvokemethods.it is widely used in modern java context and is the foundation for manyframeworks such as spring andjunit .
reflectionwithambiguousresolution referstoaspecialcase wheremultiplepotentialtargetsexist e.g.
overloadingmethods with different return types for a dynamic invocation via reflection.
such bytecode is often generated by bytecode manipulationinstead ofbystandardcompilers.
dynamicclassloading involvesclassesloadedthroughcustom class loaders.
dynamic proxy refers to the proxy feature that dynamically creates invocation handlers for aclass andits methods.
invokedynamic is a new bytecode instruction introduced in java that enables dynamic method invocation via method handlers.
itisoften usedto support lambda expressions .
serialization refers to dynamically loaded classes via class deserialization.
java native interface jni is a framework that enables java tocallandbecalledbynativecode.thisbenchmarkincludes twoprograms that have callbacks from native code viajni.
sun.misc.unsafe isalow leveljavaapithatcanbeusedtodirectlymanipulatejvmmemoryatruntime e.g.
dynamically loading classes throwing exceptions swapping instances allocating newinstances etc.
wedevelopourownnativeprofilingagentcalled jmtrace which instruments method invocations using jvm ti apis to inject logging statements at the entry and exit ofeach method in aclass duringclassloading.table 1comparesthecapabilityofhandlingdifferent kinds of dynamic features between static call graph analysis table1 capabilityofhandlingdifferentdynamicfeatures static tamiflex jmtrace reflection circle circle circle reflection ambiguous circle leftcircle circle circle dynamic classloading circle circle circle dynamic proxy circle circle circle invokedynamic leftcircle circle leftcircle circle circle jni circle circle circle serialization circle circle circle unsafe circle leftcircle circle circle tamiflex and jmtrace.jshrinkrunsgiventestcasesandidentifies dynamic method calls that do not exist in static call graphs but are invoked during test execution.
then jshrinkinitiates another round of static reachability analysis using those dynamically invoked methods as entry points.
note that we only use dynamic profilingtoaugmentstaticanalysis insteadofreplacingstaticanalysiswithdynamicanalysis.incaseoflowtestcoveragefromexisting tests this augmentation lets jshrinkretain functionality statically reachablefromuser specifiedentrypoints suchaspublicmethods mainmethods andmethodentriesfromexistingtestcases.itshould be noted that while jmtraceimproves our reachability analysis its effectiveness is entirely dependent on the coverage of the tests provided.
a test suite with low code coverage will have a lower chance ofuncovering dynamic features which may utilized by an end user thanatest suite withhigher code coverage.
jvm ti apis only permit instrumentation of method bodies.
as suchjmtraceis not capable of identifying fields dynamically accessed via reflection.
therefore we customize tamiflex to instrument only reflection calls related to field accesses and use it togetherwith jmtrace.instrumentationtootherreflectioncallsis disabledto avoid redundant profiling.
typedependencyanalysis.
traditionalreachabilityanalysisonly keeps track of invoked methods and accessed fields which is sufficientformethodandfieldremoval.previousdebloatingtechniques consideraclassunusedifnoneofitsmethodsorfieldsarereachablefromentrypoints .however wefindthisdefinition of unused classes is problematic in practice.
modern java allows developers to reference classes in various ways not just limited to variableandmethoddeclaration orclassinheritance butthrough pluggableannotations classliterals throwsclauses etc.aprogram can thereby reference a class without instantiating it or directly accessanyofitsmethodsoffieldmembers.insuchacase removing reference onlyclassesthatdonothaveanymethodorfieldusage willcauseabytecodeverificationfailureduringclassloadinginthe jvmorleadtoa classnotfoundexception atruntime.itiscrucialto ensuretypesafetyduringclassremovalandclasshierarchycollapsing.therefore jshrinkbuildstypedependencygraphsbyscanning through java bytecode using asm.
if a class ais referenced by a classb we add an edge from btoainthe graph.
based on static analysis profiling of dynamic features and typedependencyanalysis jshrinkdeterminesunusedcodeatfourgranularities listedbelow.weuse class asageneraltermforconcrete classes abstract classes andinterfacesinjava.
138jshrink in depthinvestigation intodebloating modernjava applications esec fse november8 virtualevent usa unused method a method is unused if it is not reachable from any given entry pointinthe callgraphs.
unused field a field is unused if it is not accessed by a used method in a call graph or dynamically accessed via reflection.
unusedclass aclassisconsideredunusedifnoneofthe following three conditions are satisfied a method in the class is reachablefrom given entry points a field in the class is reachable from given entry points a descendant ofthis class inthe class hierarchyisused.
reference only class a class is not used but referenced by another used or reference only class based on given type dependency graphs.
this is a special category of classes not handledsafelybyexistingdebloatingtechniques .
inpriorwork unusedclassesarecompletelyremovedifnone of their class members are reachable.
however we find that this is an unsafe choice causing many classnotfounderror s at runtime.
therefore jshrinkpartiallydebloats referenceonly classes to ensure type safety as explained in class hierarchycollapsing.
.
bytecodedebloating transformations inspiredbytipetal.
jshrinkprovidesthefollowingbytecode debloating transformations.
unused method removal.
jshrink provides three method removal options completely remove the definition of an unused method onlyremovethebodyofanunusedmethodbutkeep themethodheader and replacethemethodbodywith awarning statement indicating the method is removed.
to safely wipe a method body jshrinkinjects bytecode instructions to return dummy values if the return type is not void.
the first option could achieve maximum code size reduction at the cost of safety as it may lead to nosuchmethoderror if a removed method is triggered in future usages.
with the second and the third options unused methodsarestilldefinedinbytecodeandthusprogramswillfail gracefully without catastrophic program crashes.
the third option is the most informative as it lets a user know which method is invokedatruntimebutnotcapturedbystaticanalysisorgiventest cases.
our results in section 5uses the first option as default but a usermaychoose the othertwooptionsin jshrink.
unused field removal.
given an unused field jshrink completely removes its definition.
note that this transformation should be used in pair with method removal.
if those unused methods accessing an unused field are not removed jvm will report fieldnotfounderror thatcrashesthedebloatedsoftware.enabling this transformation alone requires fine grained transformation withinamethodbody e.g.
removingallfieldaccessinstructions andsubsequent instructionswithdata dependencies to the field.
methodinlining.
jshrinkinlinesamethodifthemethodhasonly one call site in the call graph and the method is the only call target the callsite.
the former ensures that jshrinkdoes not introduce code duplication during inlining while the latter is crucial for semantic preservationincaseofpolymorphism.
typesafetyofmethodinliningiswidelydiscussedinthecompilerliterature .toensuretypesafety jshrinkappliesthreeconstraints.first jshrinkdoesnotinlineclassconstructors.second jshrinkdoes not inline native methods abstract methods andinterfacemethodsastheydonothavemethodbodies.third jshrinkdoes not inline a method if it accesses other class members that become invisible after inlining detailed in section .
.
jshrinkalsodoes not inline synchronized methods.
class hierarchycollapsing.
jshrinkperformstwobasictransformationstocollapseclasshierarchy.thefirst moresophisticated transformation is to merge a base class xand a subclass y ify is the only used subclass of x.jshrink checks if for any overridden method m iny and the corresponding original method m onlyone ofeither mandm isused.if bothare used jshrink does not collapse the classes.
if this rule was not enforced jvm wouldnotdelegateaninvocationon mtoitsoverriddenmethod m basedontherealtypeofthereceiverobjectatruntime.thesecond transformationistoremoveunusedclasses.forareference only class jshrinkremovesitsclassmembersandonlyretainstheclass header to avoid classnotfounderror .
if a reference only class is a concrete class jshrinkinjects a default constructor as enforced by jvm.
ifa reference only class isan interface jshrinkkeeps those methoddeclarationswhoseimplementationsinasubclassareused.
toimplementthefirsttransformationofmergingasubclass y intoabaseclass x jshrinktakesthreesteps.first itmovesallused methodandfieldmembersof xintoywhileremovingunusedclass members in y. secondly it updates all