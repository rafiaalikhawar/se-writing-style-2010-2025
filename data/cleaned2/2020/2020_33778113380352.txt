here we go again why is it difficult for developers to learn another programming language?
nischal shrestha nc state university raleigh north carolina nshrest ncsu.educolton botta nc state university raleigh north carolina cgbotta ncsu.edutitus barik microsoft redmond washington titus.barik microsoft.comchris parnin nc state university raleigh north carolina cjparnin ncsu.edu abstract once a programmer knows one language they can leverage concepts and knowledge already learned and easily pick up another programming language.
but is that always the case?
to understand if programmers have difficulty learning additional programming languages we conducted an empirical study of stack overflow questions across different programming languages.
we hypothesized that previous knowledge could potentially interfere with learning a new programming language.
from our inspection of stack overflow questions we found instances of interference that occurred due to faulty assumptions originating from knowledge about a different language.
to understand why these difficulties occurred we conducted semi structured interviews with professional programmers.
the interviews revealed that programmers make failed attempts to relate a new programming language with what they already know.
our findings inform design implications for technical authors toolsmiths and language designers such as designing documentation and automated tools that reduce interference anticipating uncommon language transitions during language design and welcoming programmers not just into a language but its entire ecosystem.
ccs concepts human centered computing empirical studies in hci software and its engineering programming teams.
keywords interference theory learning program comprehension programming environments programming languages acm reference format nischal shrestha colton botta titus barik and chris parnin.
.
here we go again why is it difficult for developers to learn another programming language?.
in 42nd international conference on software engineering icse may seoul republic of korea.
acm new york ny usa pages.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than the author s must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may seoul republic of korea copyright held by the owner author s .
publication rights licensed to acm.
acm isbn .
.
.
.
peter norvig wrote a guide python for lisp programmers to teach python from the perspective of lisp.
we interviewed peter regarding this transition and he described a few challenging aspects of switching to python such as how lists are not treated as a linked list and solutions where he previously used macros required rethinking.
when asked about the general problem of switching programming languages he said most research is on beginners learning languages.
for experts it s quite different and we don t know that process.
we just sort of assume if you re an expert you don t need any help.
but i think that s not true!
i ve only had a couple times when i had to deal with c and i always felt like i was lost.
it s got all these weird conventions going on.
there s no easy way to be an expert at it and i ve never found a good answer to that and never felt confident in my c .
peter believes that learning new languages is difficult even for experts despite their previous experience working with languages.
is peter right?
introduction numerous stories on language transitions suggest that even experienced programmers have difficulty learning new languages.
for example a java programmer who transitioned to kotlin reports that differences like reversed type notation and how classes in kotlin are final by default made the transition less smooth than expected if you think that you can learn kotlin quickly because you already know java you are wrong.
kotlin would throw you in the deep end.
similarly a programmer experienced in c who switched to rust found that rust s borrow checker forces a programmer to think differently.
transitions across radically different languages are especially difficult.
for example a java programmer switched to haskell and expressed that the easy things are often a bit harder to do in haskell and another programmer experienced in procedural languages warned that can be a bit confusing to understand how it works in practice especially if you re still thinking like an imperative programmer.
even languages sharing the same runtime can be problematic whenever i pick up coffeescript i feel as if most of my understanding of javascript suddenly vanishes into thin air.
from these stories one common refrain occurs previous programming knowledge is sometimes less helpful than expected and can actively interfere with learning.
this seems counterintuitive.
why can previous knowledge actually make learning harder and not easier?
ieee acm 42nd international conference on software engineering icse icse may seoul republic of korea nischal shrestha colton botta titus barik and chris parnin in psychology and neuroscience studies have shown that confusion can occur when older information interacts with newer information .
to illustrate suppose the bread aisle of your favorite store was recently moved.
you may reflexively start walking towards the old location due to interference when previous knowledge disrupts recall of newly learned information.
however if you recently saw that the impossible burger was added to the frozen section and not a separate health aisle using knowledge that frozen food can be found in the frozen section is an example offacilitation when previous knowledge helps retrieval of new information.
in the same vein when a java programmer is learning kotlin we postulate that their prior java knowledge either facilitates or interferes with learning.
the knowledge that java is objected oriented and uses static typing facilitates their learning as kotlin shares similar properties.
the knowledge that java classes are not final by default interferes with their learning because kotlin classes are final by default.
if previous programming knowledge can be framed as a source of interference with new programming language acquisition interference theory can explain why programming language learning can be difficult for experienced programmers.
and when previous programming knowledge isn t relevant learning can also be difficult because this knowledge doesn t facilitate.
to investigate our hypothesis we first looked for evidence that programmers could have difficulty learning another language due to interference from their previous knowledge.
to this end we conducted an empirical study examining questions posted on a popular question and answer site stack overflow.1we analyzed 450posts for different programming languages and qualitatively coded each post characterizing posts in terms of whether or not programmers made incorrect assumptions based on their previous programming knowledge.
then to understand what learning strategies programmers used when learning another language and why previous knowledge could interfere with this process we interviewed professional programmers who had recently switched to a new programming language.
we found that cross language interference is a problem crosslanguage posts on stack overflow contained incorrect assumptions due to interference with previous language knowledge.
based on our interviews professional programmers primarily learned new languages on their own using an opportunistic strategy that often involved relating the new language to previous language knowledge however this results in interference which harms their learning.
learning a new language involves breaking down old habits shifting one s mindset dealing with little to no mapping to previous languages searching for proper documentation and retooling in a new environment.
all together these challenges make learning another language difficult.
methodology to explore how programmers learn a new language and understand their potential sources of confusion we conducted a mixed methods through an empirical investigation of stack overflow posts across various languages and through semi structured interviews.
we do so through the following research questions .
research questions rq1 does cross language interference occur?
we examined questions programmers had about programming languages on stack overflow for evidence of interference with previous programming knowledge.
rq2 how do experienced programmers learn new languages?
to gain a better understanding of why cross language interference occurs we interviewed professional programmers on how they learn new languages.
rq3 what do experienced programmers find confusing in new languages?
to examine the ways in which programmers mix a new language with their previous knowledge we asked programmers about obstacles they faced and surprises they encountered in their new languages.
.
phase i study design for stack overflow to answer rq1 we conducted a study using stack overflow posts.
data collection .to gather stack overflow questions we used the sotorrent data source from the msr mining challenge.
we queried programming languages used previously by erik and waren in their investigation of popular language migrations based on google search keywords and github repositories.
we gathered stack overflow questions for each language a language b pair.
to keep the analysis tractable we considered only the association between the two languages and not the direction of the possible interference.
we used a stop rule criteria to cover over of total posts which resulted in out of the language pairs shown in table .
the materials for the study are available online.
query criteria .we used bigquery3to query the sotorrent database and used the following filtering criteria to capture potential posts where the programmers are asking questions about a new language target coming from a previous language source the question is tagged with both languages or the question is tagged with the source language but contains the text of the target language in the title or body vice versa.
analysis .to understand whether or not cross language interference occurs we performed a manual inspection of stack overflow posts .
we inspected a random sample of posts for each pair to keep categorization tractable as done in barik et al .
.
we manually excluded posts that did not make any explicit connection between the languages of each pair sampling another random post to replace it as necessary.
because the inclusion and exclusion criteria can have multiple interpretations the first two coauthors labelled a random sample of posts.
this labelling had agreement between the coauthors and suggests a clear understanding of how to categorize posts.
the two coauthors proceeded 692why is it difficult for developers to learn another programming language?
icse may seoul republic of korea table participants id exp1domain recent transition p1 compilers c python c p2 data science python julia p3 information sciences python php p4 neuroscience r python p5 security c typescript p6 cloud services c typescript p7 cloud services c python p8 web platform c javascript p9 data science c javascript scala p10 business applications c rust p11 web platform c ruby p12 data science python sas p13 software engineering c javascript p14 data science r python p15 software engineering c swift p16 data science r python 1years of self reported programming experience.
to label the rest of the stack overflow posts using the following classifications correct the post makes a connection to a previous programming language with correct assumptions regarding the target language as revealed by the accepted answer or incorrect the post makes a connection to a previous programming language with incorrect assumptions regarding the target language as revealed by the accepted answer.
next we calculated inter rater reliability irr between the two coauthors cohen s .
and obtained substantial agreement .
we discussed disagreements on whether a post was correct or incorrect if there was still disagreement it was reconciled by the first author.
finally we calculated the percentage of correct and incorrect posts.
we used instances of correct and incorrect assumptions as evidence of cross language interference and facilitation.
.
phase ii study design for interviews with professional programmers to answer rq2 and rq3 we conducted semi structured interviews with professional programmers.
participants .we used purposive sampling to recruit professional programmers who were learning a new programming language within the past months these participants were still early in their learning process and working through their initial stumbling blocks in the new language.
the participants male female self reported were from large software technology and data analytics companies with years of programming experience ranging from to years .
sd .
.
there were a total of 14unique language transitions.
before the interview participants completed a background questionnaire asking them about their previous languages and an obstacle they have experienced while adapting to the new language.protocol .we conducted semi structured interviews either onsite or remotely within minute time blocks.
two of the authors conducted and recorded the interviews separately.
all sessions were conducted with a single observer and a single programmer.
we used the following structure for questions participant background first steps obstacles learning process and general strategies.
the background information from the questionnaire was used to tailor the questions for the participants.
the semi structured interview format allowed the flexibility to ask questions impromptu and dig deeper into more specific obstacles.
the recordings were later transcribed by the first author for analysis.
analysis .
rq2 how do experienced programmers learn new languages?
to answer rq2 we conducted inductive thematic analysis on the interview transcripts over multiple phases transcribing interviews generating open codes by labelling notable recurring statements made by the participants identifying relationships between the codes and organizing them into meaningful themes.
rq3 what do experienced programmers find confusing in new languages?
to understand how programmers confuse language concepts we selected themes from our analysis that highlighted interference due to previous programming knowledge.
results .
rq1 does cross language interference occur?
cross language interference occurs on stack overflow across various language pairs.
we found a total of instances of incorrect assumptions which is around of the posts inspected.
there were a total of posts with correctly stated assumptions which is only around of the total posts.
it s important to note that this provides evidence of interference occurring but does not imply programmers have incorrect assumptions of the time.
the kotlin java pair had the highest number of posts with incorrect assumptions which reflects the java programmer s confusion mentioned in section .
the next two pairs c visual basic and scala java also contained a high number of incorrect assumptions.
however there were other pairs like python c java c and php java which had a more even distribution of posts with correct and incorrect assumptions this suggests easier transitions between the languages.
while reviewing the stack overflow posts we encountered instances where programming languages behaved in surprising ways for programmers.
we highlight three examples two of which involved interference between syntax and concepts and one which involved facilitation making it easier to use type inference.
interference r python4 an r programmer is now using python and its data processing library pandas.
they are unable to successfully relate their previous knowledge about subsetting in r to python i m seriously confused.
maybe i m thinking too much in r terms and can t wrap my head around what s going on in python.
693icse may seoul republic of korea nischal shrestha colton botta titus barik and chris parnin table posts by language pair correct4 language pair1posts2 accepted3n c c c visual basic objective c swift python c java c scala java php java r python kotlin java matlab python node php ruby python perl python lua c clojure java 1the pair of programming languages.
2total number of questions where the two languages are tagged or referenced in body.
3percentage of questions that have accepted answers.
4total posts out of classified as having correct assumptions formed from prior language knowledge.
they present the r expression they want to translate as well as several attempted translations in python r data python data value several concepts in r interfered but we will highlight the most significant python prevents assignment to copies of dataframes.
in this case the indexing operation data returns a copy of the dataframe and setting the value with value will not work as the r programmer expects.
the knowledge that the equivalent r expression will set the value of without any warnings interferes with python s warning.
interference php javascript5 a php programmer who has switched to programming in javascript asks how to store transient information sessions such as application state about a user.
typically php uses server side session variables session for this purpose.
while related concepts such as local storage and browserbased sessions exist the programmer is warned that sessions be safely and securely stored directly on the client the programmer s knowledge about server side sessions leads to a faulty assumption about their applicability in other programming contexts.
facilitation java kotlin6 a java developer is learning kotlin.
they ask if the following kotlin expression can be simplified val boundsbuilder latlngbounds.builder latlngbounds.builder the developer suspects their declaration is more verbose than it should be given their knowledge of local variable type inference in java.
they assume the declaration can be simplified val boundsbuilder latlngbounds.builder this is an example of facilitation the accepted answer confirms that the developer can simplify the expression because kotlin supports type inference allowing for the explicit type declaration to be removed.
these examples illustrate how previous knowledge of language syntax and concepts interact with knowledge learned in a new language.
in some cases this results in interference which harms a programmer s ability to grasp new syntax and concepts in the new language.
in other cases this results in facilitation which helps programmers make meaningful connections to previous languages and helps them learn the new language.
cross language interference occurs across various language transitions on stack overflow posts.
we found that of the posts contained incorrect assumptions about the target language and only contained correct assumptions.
.
rq2 how do experienced programmers learn new languages?
we present the themes on how experienced programmers learn new languages.
a summary of the themes is listed in table .
.
.
programmers learned languages on their own.
programmers who switched teams lacked formal training for the new language and its associated technology stack leaving learning to themselves.
for example when p1 switched from c to python for a new project there wasn t any training involved and the on boarding process was hey we want to get exposed to the python world go get started!
although some programmers were given training initially on the project realistically for learning the new language were pretty much on own p7 .
this forced programmers to watch language tutorial videos on pluralsight p5 or read online documentation.
some programmers got initial tips from some folks from the team on what s what p6 and when running into complex issues reached out to the group and said has somebody else hit this before?
p1 .
694why is it difficult for developers to learn another programming language?
icse may seoul republic of korea table learning strategies and language interference themes learning strategies theme description representative examples participants1 learning on their own section .
.
programmers lacked formal training for the new language and its associated technology stack leaving learning to themselves.
we didn t have a procedure for people getting up and running.
i just do everything ad hoc!
i got initial tips from some folks from the team on what s what.
p1 p2 p5 p6 p7 p13 p14 p15 p16 just in time learning section .
.
programmers focused on only learning features as needed.
there s probably like a content cheat sheet.
i didn t learn typescript step by step.
step one for me is always find and read other people s code.
p1 p2 p3 p5 p9 p14 p15 relating new language to previous languages section .
.
programmers tried to map features of the new language to their previous languages.
i loosely ideas from working in another language.
i would try to find the counterpart of c in react.
if you can compare them side by side and find their similarities you re more than halfway there.
p1 p2 p9 p12 p13 p14 p15 language interference theme description representative examples participants2 old habits die hard section .
.
programmers had to constantly suppress old habits from previous languages.
i m typing a thinking that it s a .
i still type the type first before the variable.
i m gonna make it an object for this no don t do that!
p2 p3 p4 p6 p9 p15 mindshifts when switching paradigms section .
.
sometimes programmers wrestled with larger differences that required fundamental shifts in mindsets or mindshifts.
all my assumptions were thrown out the window.
i had to rethink the problem and re implement it.
there are lots of events and promises all these things makes it really hard to debug.
p2 p5 p6 p9 p10 p13 p15 little to no mapping with previous languages section .
.
programmers had a harder time learning the new language when there was little to no mapping of features to previous languages.
there s a very alien concept in rust that is the borrow checker.
i ve never had a language with traits before.
i did not work with concepts like virtual dom shadow dom before.
p2 p5 p9 p10 p11 p15 searching for terms and documentation is hard section .
.
programmers found it difficult to search for information about the language and its associated technologies.
you don t even know what exists what to even look for.
scala is not that common.
some of it required a little deeper digging.
they have their own convention typescript has its own convention javascript has its own convention.
p1 p2 p4 p8 p9 p11 p12 retooling is a challenging first step section .
.
programmers faced difficulty retooling themselves in the environment of the new language.
i was using visual studio to debug c code and now it s gdb to debug c code.
in xcode build targets aren t universal in definition like .net.
the problem is intellij is aimed at the java developer and i m using sbt which is from the scala world.
p1 p2 p9 p12 p15 1participants who used a similar learning strategy.
2participants who experienced the particular language interference theme.
.
.
just in time learning is a dominant strategy.
to learn new languages every programmer we interviewed used just in time learning an opportunistic strategy focused on only learning features as needed.
given time constraints programmers made use of immediately available resources like online documentation video tutorials online searches and available experts.
traditionalresources like programming language books were only used as a reference since programmers just don t have time to do that p5 .
programmers were primarily concerned with completing tasks in a reasonable time and figuring out how to not burn tons of time on a single problem p1 .
quicker resources like cheat sheets were preferred for language transitions.
for example the first thing p2 695icse may seoul republic of korea nischal shrestha colton botta titus barik and chris parnin did was to make use of cheat sheets to help them transition from python to julia.
p15 was also a fan of cheat sheets it seems like if you were going from one framework to another from one technology stack to another even if you re not going from a to b you re just starting off on b there s probably a content cheat sheet that every dev needs to know.
p15 .
.
programmers related the new language to previous languages.
to help accelerate the learning process programmers generally tried to relate the new language to their previous languages.
programmers started by loosely taking ideas from working in another language p14 or looking at existing code because it s already probably been written and it s out there somewhere or at least something close to it p1 .
while this learning strategy was useful for bootstrapping some programmers started from scratch.
for example when moving from c to ruby p11 described trying to be very conservative and mindful and trying not to map anything over but just treating everything as something brand new.
similarly p12 explained that they did not try to map things from python when learning sas mostly because the syntax was so new that every time tried to do anything would have to go and google the syntax.
p10 expressed a similar problem when learning about managing memory in rust after years of using c there wasn t a clean way for me to just get there.
i had to go and learn that stuff from scratch.
these examples illustrate that programmers typically reuse knowledge if possible but sometimes avoid so when it s more troublesome.
programmers use an opportunistic learning strategy relating syntax and concepts of the new language with their previous language.
this offers expediency but causes interference when major differences exist between the two languages.
.
rq3 what do experienced programmers find confusing in new languages?
we present the themes explaining how programmers confuse language concepts.
a summary of these themes is listed in table .
.
.
old habits die hard.
programmers had to constantly suppress old habits acquired from previous languages.
for example p3 who was used to python had trouble adapting to block delimiters in php where it s near impossible to figure out exactly which opening brace you re closing once your html php gets to any complexity at all.
similarly p15 realized that in swift the open curly bracket needs to be on the initial line of the method declaration and if you put it on the next line the method may not execute in an expected fashion.
there were minor but frustrating difference like versus indexing for lists in languages such as python and r. p4 described their frustration in typing a thinking that it s a and then wasting minutes like a complete fool not understanding why nothing makes sense p4 .
programmers are able to resolve these small differences but it still causes interference at the onset of learning a new language.
.
.
mindshifts are required when switching paradigms.
some language transitions required fundamental shifts in mindsets or mindshifts .
for example when p2 transitioned from python to julia they were constantly trying to make an object and realizing that there s no objects there s only structs!
with julia they needed to write more functional code a shift from the object oriented programming that they were used to in python it was just needing to shift that and realize i m never gonna write something dotsomething else ever or rarely.
for p10 they had to completely rethink the problems they would have normally solved in c because of rust s unique ownership feature for memory safety a really fascinating thing about learning rust was that when i went and started to do these things things that i would reach for in c that i knew would work rust wouldn t allow it and as a result i had to rethink the problem and re implement it in a way where the ownership characteristics of that algorithm were very explicit.
p10 another big paradigm shift occurred for p5 p6 and p13 all transitioning from imperative or object oriented coding to event driven and asynchronous coding forcing them to think differently.
the programmers had to learn brand new concepts in javascript like asynchronous programming or shadow and virtual doms p13 .
p6 described how it was difficult making sense of asynchronous code because you got a whole bunch of async await mode working in your mind and you have to convert it.
to make matters worse the most confusing part is there are a couple of ways to do asynchronous programming with observables or promises p13 .
for p5 whose background was in c the front end coding in typescript was a big challenge because for the back end the code i think is more straightforward.
you have the logic and most likely you know single places you ll handle it.
it s not like the ui p5 .
here the interference issues aren t due to any particular syntax or concept but the way one solves problems in the new language.
.
.
learning a language is difficult when there is little to no mapping with previous languages.
programmers had a harder time learning the new language when there was little to no mapping of features to previous languages.
for example p12 could not make sense of some fundamental programming language features of sas that were clear in python like statements versus method parameters.
they could not understand why some things are statements that affect a procedure but aren t parameters and were still confused about the overall syntax and what is or isn t a statement even after having worked in the language for a few weeks.
a drastic example was p5 who experienced a big transition from c to typescript resulting in tech shock everything is different!
not just the programming language the ide source control everything is different.
p13 who underwent a similar language transition found that concepts were challenging in javascript because they could not equate it back to c .
due to limited mapping of features to previous languages programmers could not make full use of facilitation to learn the new language.
in the extreme case programmers were forced to learn a completely foreign syntax or concept in particular when it was an essential built in feature of the new language.
for example p9 had difficulty learning traits in scala because they never had a language 696why is it difficult for developers to learn another programming language?
icse may seoul republic of korea with traits before.
traits have a default implementation and understanding what would be performant and what wouldn t and when to use what that was the tricky part.
p7 learned that for python the major difference is the multiple inheritance thing that python inherits from the c world which supports multiple inheritance.
in c you can t do that.
in another case the difficulty was due to differences in memory management for example when p10 who previously used c was learning rust there s a very alien concept in rust that is the borrow checker which is the concept of having the compiler verify more things and the way it does it is somewhat esoteric.
that s very alien and that s something that i think is really cool but it s also very rough at the moment and so that s kind of something that s been the biggest struggle when trying to learn rust.
p10 even within the same context such as data analysis or mobile applications the lack of mapping caused a lot of confusion.
for example p14 who switched from one data analysis language r to another python pandas could not find an immediate equivalent for r s spread and gather functions pandas already had the functionality but it was more hidden using drop level and unstack.
these were really hard to understand in pandas it was some pretty weird stuff.
similarly p15 who switched from c to swift was very surprised to learn how the user interface code and its graphical layout view in xcode were connected knowing that you can t interact with a ui object straight out of the box from the code is very important.
once you draw the referencing outlet connection between view and controller you can trigger methods and get set properties as you d expect in the .net world.
.
.
searching for the right terminology and code examples is difficult.
we found that moving to a new programming language presents a selection barrier making it difficult to search for information about the language and its associated technologies.
programmers recounted trouble acquiring the vocabulary even before performing the search.
for p12 the names for the same structures in python pandas were slightly different than sas where a dataframe is data set a row is an observation a column is a variable.
when they tried to plot with sas they don t know what the name of the proc for plotting in sas is so have to start looking that up first then find documentation for a couple different ones then have to figure out how to make them work.
on the one hand it s the breadth of the libraries that usually get you you don t even know what exists what to even look for to see if something is already there p1 .
on the other hand insufficient search results provided little to no facilitation.
for example p4 had difficulty searching information for a python library called seaborn compared to the equivalent r library ggplot because it is just less documented.
for ggplot if you google anything you get like hits and the top ones are bound to be good due to google selection of results.
with seaborn you get like hits.
even when programmers found documentation and code examples they were either incomplete or lacking in detail.
for example p8 expressed a frustration regarding testing libraries in javascript because they have their own convention typescript has its own convention javascript has its own convention it is actually mixing everything!
this was especially problematic when conventionsfound online weren t always the same ones used by the specific team there s a lot of conventions around the language.
in c the styles can change a bunch from team to team p1 .
for some languages the documentation was either lacking in quality or was completely missing.
for example p2 was frustrated with the julia documentation because it was so useless for figuring out the imports.
similarly p12 expressed that the sas documentation only tells you how to copy paste and run a simple program leaving you completely mystified as to how the execution and control flow of a sas program works.
this lack of depth can lead to frustrating experiences for programmers when they had better documentation in previous languages such as p15 xcode documentation samples were pretty good enough to where they would run.
but the documentation msdn and the available samples for creating microsoft platform based applications were tenfold deeper and richer and easier for to use.
.
.
retooling is a necessary and challenging first step.
finally before programming in the new language programmers faced difficulty retooling themselves in a new environment.
this typically involved adapting to the discrepancies of the new integrated development environment ide for programming in the language.
although programmers were able to adapt to basic features of ides facilitation there was interference when some aspects of the ide differed from their previous ides.
for example p15 discovered that in xcode build targets aren t universal in definition like .net and when terminologies are shared across platforms but don t implement the same notion you re lost for days!
interestingly for p9 there was interference when they tried building their scala project in intellij because the ide attempted to support scala but continued presenting dialogs in the previous language part of the problem is intellij is aimed at the java developer and i m using sbt which is from the scala world.
and it s sort of importing the sbt into the concepts in the ide of intellij.
so i m looking at dialogs that are all about java and which jdk and that doesn t map to what i wrote in the declarative sbt language.
p9 other concerns regarded either a lack of ide features or learning new features that were distracting.
p2 had been spoiled with python and pycharm and found it very difficult to find proper ide support for julia they just wanted an ide that does syntax highlighting and intellisense like autocompletion.
p1 found that learning a new feature like debuggers effectively halts a programmer s progress on actual tasks and are distracting because you re learning and debugging at the same time as opposed to just debugging once you re fluent.
however sometimes the transition to new tools in the language also benefited programmers.
for example p5 found it a lot easier moving from msbuild c to gulp javascript which allowed fast build cycles when developing typescript applications.
in particular the devops pipeline helped them make progress much quicker i think right now the build system for us i think it s better since now we are using devops a pipeline to build the code.
it s very easy for us to even schedule the private build and also it s very easy for us to quickly 697icse may seoul republic of korea nischal shrestha colton botta titus barik and chris parnin get new things check in the code test it and even build things on top of it.
p5 programmers confuse a new language s syntax and concepts with previous languages leading to a number of issues like trying to suppress old habits wrestling with mapping issues struggling to find and use proper documentation retooling and shifting one s mindset for new paradigms.
limitations our mixed methods approach of investigating stack overflow and conducting interviews introduces certain trade offs and limitations.
the choice of sampling technique in our stack overflow analysis has several trade offs .
because the sampling approach is non probabilistic it does not allow for sample to population orstatistical generalization.
rather our approach targets diversity rather than representativeness in order to identify evidence of interference across many different programming languages.
we used correct and incorrect assumptions as a proxy construct for facilitation and interference.
while this approach provides us with a useful high level characterization of the stack overflow posts there are potentially additional insights that we could learn had we performed a more intricate qualitative coding technique such as open coding.
the trade off for so is that open coding is significantly more costly to execute.
instead we conducted semi structured interviews with experienced programmers to delve deeper into cross language interference.
the posts we examined on stack overflow as well as our interviews do not completely cover the set of all language transitions as the full permutation space of language transitions is intractable.
our approach attempts to cover language transitions that are most likely to occur in practice.
consequently there may be some interference issues that our study was not able to identify.
finally we acknowledge that qualitative research however rigorously conducted involves not only the qualitative data under investigation but also a level of subjectivity and interpretation on the part of the researcher as they frame and synthesize the results of their inquiry.
to support interpretive validity we followed the guidelines set by carlson and performed a single event member check with our results.
six participants who replied agreed with our presentation of the results and only wanted minor changes to their quotations.
additionally we emphasize that interference theory is only one of many possible lenses through which we can organize and present our findings.
other theories such as notional machines have also been used to identify and explain programming conceptions .
related work novice misconceptions.
programmers often have misconceptions while learning new programming languages but most studies have focused on novices.
swidan et al .
proposes intervention methods to counter those misconceptions as early as possible but this work is primarily targeted to novices.
similarly kaczmarczyk et al .
has examined misconceptions and how to measure them for novices.
in contrast the novelty of our work is towards experienced programmers who need to switch languages and requires methods of learning distinct from those designed for novices .
our study investigated switching languages for experienced programmers and took the first steps in examining how knowledge of previous languages interfere when learning another language.
programming language transitions.
there are a few studies on transitions between programming languages.
scholtz and wiedenbeck studied experienced pascal or c programmers writing a program in a new language icon and found that they were strongly influenced by their knowledge of what would be appropriate in previous languages.
wu and anderson conducted a similar study where programmers who had experience in lisp pascal and prolog wrote solutions to programming problems and found that solutions written in one language facilitated learning in another language.
uesbeck and stefik studied the effect of using multiple languages in a controlled study where participants implemented several variations of database queries some variants involving the same language while others mixing sql and java.
while the results were inconclusive the authors suggest that the methodology could be effective for studying the productivity costs associated with mixing languages.
we examined empirical evidence and conducted interviews to understand the transition from one language to the next for various contexts.
we also investigated how programmers confuse two different languages using the lens of interference theory .
there have been fewer studies on interventions for learning new languages.
bower and mciver explored a new teaching approach called continual and explicit comparison caec to teach java using facilitation to students who have knowledge of c .
they found that students benefited from the continual comparison of c concepts to java.
shrestha et al .
used a similar technique using a tool called transfer tutor to teach r from the perspective of python programmers who used the tool found the comparisons between the languages useful.
these intervention techniques might benefit programmers who learn new languages from the perspective of a known neighboring language but there are a number studies on larger transitions for example from procedural or imperative to object oriented languages .
these studies have shown professional programmers experience greater interference as they have to make fundamental shifts or mindshifts which might require further support.
in this study we have uncovered interference issues in the modern context and examined numerous language transitions.
we also found other issues that have not been explored like dealing with little to no mapping of language features section .
.
and retooling section .
.
which have implications for future tools and techniques.
programming knowledge.
knowledge structures have been proposed for how programmers encode semantic and domain information about a program as well as prime structures that include elements of syntax control flow and data flow of the program.
these knowledge structures have been formalized and referred to as programming plans.
programming plans act like schemas that are first instantiated and then its slots are filled with concrete values as a programmer builds an understanding of the code .
plans may help programmers fill in the gaps when trying to understand code.
698why is it difficult for developers to learn another programming language?
icse may seoul republic of korea gilmore and green suggested that programming plans may not generalize across different languages and that plans cannot represent the underlying deep structure of programs.
bellamy and gilmore examined the protocols generated from experts in different languages as they created programs.
using two different models of programming plans they found neither model was well supported by protocols further different programming language experts generated different types of representations.
we believe our results provide further insight as to why plans may not generalize across languages.
for example we found programmers tend to relate a new language to previous languages section .
.
which suggests an attempt to reuse previous programming plans as a bootstrapping strategy.
however due to interference issues the previous plans might either need significant modifications section .
.
or be replaced entirely section .
.
depending on how closely related the two languages are.
discussion and design implications our findings demonstrate that interference is not an isolated phenomenon indeed in stack overflow instances of interference are found across all of the programming languages we investigated.
furthermore in our interviews participants reported that interference arises routinely as they learn a new language for example from having to suppress old habits from previous languages section .
.
or having to rethink the program p10 due to a substantially different paradigm section .
.
and section .
.
.
as opposed to traditional classroom environments where one learns step by step p5 experienced programmers in our study used opportunistic strategies to learn essentially on own p7 or learning through work p13 for example using online resources or asking teammates section .
.
.
unfortunately these informal approaches to learning sometimes result in an incomplete lens for how the language works resulting in unintentional bugs p5 and other difficult to diagnose problems in the code when something doesn t work as expected.
in the remainder of this section we present design implications for technical authors toolsmiths and programming language designers that can help reduce some of these interference difficulties for programmers.
implication i design documentation that reduces interference and supports knowledge transfer.
programmers in our study desired more accessible resources that leveraged the programming knowledge they already have section .
.
and section .
.
.
such resources included cheat sheets which present code snippets that map their familiar language to their new language p2 and relate concepts they already know from working in another language p14 to the new language tutorials and even resorting to reading other people s code p3 p15 to understand the programming language idioms.
our findings suggest that resources that teach languages through relating a new language to a known language are more useful and accessible to programmers than resources that present the new programming language in isolation.
several books blogs language documentation and training courses embody this pedagogical strategy.however these resources while useful are essentially handcrafted through the authors intuitions about what misconceptions the programmer might have and not necessarily the ones that programmers actually have.
while misconceptions about novice programmers are readily found in the literature misconceptions experienced programmers have are comparatively understudied.
shrestha and parnin presented three possible instrument designs which can be used for discovering and validating misconceptions when switching languages for experienced programmers.
such research is needed to make learning resources more effective and relevant to experienced programmers.
implication ii build automated tools to provide on demand feedback.
although technical documentation is useful these resources are decoupled from where the programmer needs the most help in their program environment as they work section .
.
and section .
.
.
automated tools can help with this.
for example johnson et al.
propose bespoke notification tools that provide adaptive feedback to the programmer based on the programmer s prior knowledge of programming languages and concepts.
python adopts this idea of using prior programmer knowledge to assist programmers who come from a python background through hard coded error messages in python print does not require surrounding parentheses while in python print is a function and thus must be called like any other function print hello file stdin li print hello syntaxerror missing parentheses in call to print .
did you mean print hello ?
the syntaxerror message makes the assumption that this error is due to a misconception or ingrained behavior instilled from experience with python .
we can repurpose this idea generally to language transitions and help programmers more efficiently resolve error messages that they might otherwise only eventually figure out p1 after spending substantial time and effort.
implication iii be intentional about programming language syntax semantics and pragmatics.
certain programming languages anticipate that new adopters arrive through common pathways.
that is we expect most new rust users to come from systems programming languages like c and we expect most new typescript users to come directly from javascript.
for these users intentionally designing language features by considering interference effects can reduce barriers section .
.
and section .
.
to adopting the new programming language.
as an example a substantial barrier to new rust users is the borrow checker a compile time feature that helps enforce safe memory management which our own participants described as a very alien concept p10 .
even the rust manual concedes that borrow checking has a costly learning curve and that programmers fight with the borrow checker because their mental model of how ownership should work doesn t match the actual rules that rust implements .
interference theory also explains 699icse may seoul republic of korea nischal shrestha colton botta titus barik and chris parnin these difficulties for some programmers the borrow checker is so unfamiliar as a concept that they have no prior support to facilitate learning and for other programmers borrow checker concepts at a casual glance seem similar to existing models such as resource acquisition is initialization raii in c but ultimately functions differently enough that it interferes with their past knowledge.
intentionally considering these adoption pathways as part of language design can reduce these interference challenges.
for instance the primary goal of typescript is to give a statically typed experience to javascript development and the intention is that typescript provides a smooth transition for javascript programmers well established javascript programming idioms are supported without any major rewriting or annotations .
but providing this smooth transition has a costly consequence the typescript type system is not statically sound by design.
as the two examples illustrate designing for interference requires making difficult design trade offs.
but if we want to design programming languages that people actually use we need to consider how our language design decisions interfere or facilitate with our anticipated programmers prior knowledge.
implication iv support not only programming languages but programming language ecosystems.
issues with interference when learning new programming languages are exasperated when new programming languages bring with them new programming language ecosystems that is everything is different not just the programming language p5 but the environment in which the programmer builds edits debugs and tests their code for example tech shock section .
.
.
to address these challenges react developers provide tool support to welcome programmers into the new ecosystem.
specifically the create react app is an integrated toolchain that abstracts away the complexities of third party library management live editing optimization and configuration.
create react app allows the user to quickly and easily begin experimenting with the library until the programmer is comfortable enough to eject from thecreate react app toolchain.
a second method to minimize interference issues from ecosystems is to unify the underlying tooling environment or at least provide the programmers with a unified tooling experience.
from this perspective we would recommend that toolsmiths and language designers add support for programming languages to well established integrated development environments rather than providing custom tool and editing experiences.
for instance the language server protocol lsp allows programming language support to be implemented and distributed independently of any given editor or ide as long as that ide implements lsp.
in short language designers should collaborate with tool designers so that programmers can more easily adopt new programming languages through editing environments that are already familiar to them.
conclusion in this study we conducted a mixed methods study to understand what impact previous programming language experience has on programmers.
we conducted an empirical study of misconceptionsfound in stack overflow questions across different programming languages and semi structured interviews with professional programmers.
from stack overflow we found instances of interference that occur across multiple languages.
we then interviewed programmers who reported various challenges learning a new language like mixing up the syntax and concepts with their previous programming languages due to interference.
we discussed design implications for technical authors toolsmiths and language designers such as designing documentation and building automated tools that reduce interference anticipating uncommon language transitions during language design and welcoming programmers not just into a language but its entire ecosystem.
to answer the question posed in the prelude even professional programmers have difficulties with learning programming languages and we should offer tools and techniques to help them learn more efficiently and effectively.