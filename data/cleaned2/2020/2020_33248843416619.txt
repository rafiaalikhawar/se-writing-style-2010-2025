exploring the architectural impact of possible dependencies in python software wuxia jin jinwuxia mail.xjtu.edu.cn xi an jiaotong university xi an chinayuanfang cai yfcai cs.drexel.edu drexel university philadelphia usarick kazman kazman hawaii.edu university of hawaii honolulu usa gang zhang gangz emergentdesign.cn emergent design inc shanghai chinaqinghua zheng qhzheng mail.xjtu.edu.cn xi an jiaotong university xi an chinating liu tingliu mail.xjtu.edu.cn xi an jiaotong university xi an china abstract dependencies among software entities are the basis for many softwareanalyticresearchandarchitectureanalysistools.dynamically typed languages such as python javascript and ruby tolerate the lackofexplicittypereferences makingcertainsyntacticdependenciesindiscernibleinsourcecode.wecallthese possibledependencies incontrastwiththe explicitdependencies thataredirectlyreferenced insourcecode.typeinferencetechniqueshavebeenwidelystudied and applied but existing architecture analytic research and tools have not taken possible dependencies into consideration.
the fundamentalquestionis towhatextentwillthesemissingpossible dependencies impact the architecture analysis?
to answer this question we conducted an empirical study with python projects using type inference techniques to manifest possible dependencies.
our study reveale d that the architectural impact of possible dependencies is substantial higher than that of explicit dependencies file levelpossibledependenciesaccountforatleast27.
ofall file level dependencies and create different dependency structures than that of explicit dependencies only with an average difference of .
adding possible dependencies significantly improves the precision .
.
recall .
.
and f1 scores .
.
ofcapturingco changerelations onaverage afileinvolvedinpossibledependenciesinfluences28 morefiles and more dependencies within architectural sub spaces than a file involved in just explicit dependencies on average a file involved in possible dependencies consumes more maintenance effort.
consequently maintainability scores reported by existingtools make a system written in these dynamic languages appear to be better modularized than it actually is.
this evidence strongly with the ministry of education key laboratory of intelligent networks and network security moeklinns xi an jiaotong university.
with the school of software engineering xi an jiaotong university.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acmmustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
ase september virtual event australia association for computing machinery.
acm isbn ... .
thanexplicitdependenciesonarchitecturequality thatarchitecture analysisandtoolsshouldassessandevenemphasizethearchitectural impact of possible dependencies due to dynamic typing.
keywords dynamictyping possibledependency softwarearchitecture empirical study acm reference format wuxia jin yuanfang cai rick kazman gang zhang qinghua zheng and ting liu.
.
exploring the architectural impact of possible dependencies in python software.
in 35th ieee acm international conference onautomatedsoftwareengineering ase september21 virtual event australia.
acm new york ny usa pages.
.
introduction dependencies among source code entities are the foundation for many software architecture analyses including architecture recovery architecturalmetrics architecturalproblem oranti patterndetection changeimpactanalysis defectprediction etc.manylanguagefeaturesmaycause syntactic dependencies to be invisible in source code such as polymorphism casting andreflection.this problem ismoreprominent due to dynamic typing in popular dynamic languages such aspython javascript and ruby.
dynamic typing tolerates the lack of type information making certain syntactic dependenciesinvisible in source code.
we define the invisible syntactic depen dencies caused by dynamic typing as possible dependencies in contrast with explicit dependencies.
type inference techniques have been widely studied in program languageresearch tostaticallyinferthetypesofcode objectsfordynamiclanguages.thesetechniquesmakeitfeasibletomakethesepossibledependenciesexplicit.however aftercheckingmultiplepopularcommercialarchitectureanalysistools suchaslattix architect structure101 understand and dv8 wefoundthatnoneofthesetoolsconsiderpossibledependencies when analyzing systems written in dynamic languages.
to the best ofourknowledge fewofdependency basedsoftwareanalyticresearchhavetakenthesepossibledependenciesintoconsideration.
the question is to what extent will these missing possible 35th ieee acm international conference on automated software engineering ase figure explicit dependencies among files in the java version and python version dependencies impact software architecture and analysis ?i t is urgently necessary to deeply explore this question to advance theunderstandingofpossibledependency thusbetteranalyzing software architecture in dynamic languages.
hereweuseasimpleexampletoillustrateourmotivation.we implemented two versions of a small system applying a visitor pattern using javaandpythonrespectively and thenreverseengineered dependencies among the source files using understand.
we then transformed these dependencies into two matrices as shown in figure .
in these matrices rows and columns denotesource files listed in the same order.
the numbers along the di agonal indicate self dependency.
cell i j with denotes that thefileinrow isyntacticallyandexplicitlydependsonthefilein columnj.
infigure1 a carelement isthebaseclassoftheconcreteelement classes listed inrows and .since java forces explicit type declaration the visitor interface carelementvisitor has to explicitly refer to the four concrete element classes i.e.
the subclasses of carelement hence the dependencies in row .
similarly since each concrete element class has to accept a visitor object they all have to refer to carelementvisitor hence the dependenciesincolumn5 formingadependencycycleshownbythebluemarkings.
by contrast in figure b all these dependencies and cyclesare invisible carelementvisitor.py takesthesameroleas carelementvisitor.java butitdoesn texplicitlydependonanyof thecarelements andviceversa.overall basedonthedependencies extracted by understand it appears that the practice of dynamic typing decouples software entities only dependencies in python version whereas dependencies in java one making the python implementation appears to be better modularized and easier to maintain than the java one.
we suspect that the observation is misleading since the python andjavaversionimplementedexactlythesamepatternwithexactly thesamefunctionality.these invisible dependenciesinpython may still have consequences if the methods defined in carelementvisitor.py change otherprogramelementsusingthesemethods may have to change accordingly and vice versa imposing a nontrivial architectural impact.
in order to quantitatively assess the severity of this problem weconductedanempiricalstudyusing105pythonprojectswith diversesizesanddomainscollectedfromgithub.tosupportthis study we extended our previous tool called enre to extract possible dependencies from source code using existing type inferencetechniques.weextracted5 explicitandpossible dependencies and mined change related and issuerelatedrevisioncommits.basedonthisdataset1 weexploredthe following research questions rq1 what is the proportion of possible dependencies and to whatextentwilltheyimpactthedependencystructureofasoftware system?
rq2 to what extent will the ability of capturing co change relations be altered when considering possible dependencies?
rq3 to what extent will possible dependencies impact the subspace structures of a software system?
rq4 to what extent will possible dependencies impact maintainability of a software system?
the results reveal that file level possible dependencies account for at least .
of all syntactic dependencies among files and they create different dependency structures than those formed byexplicitdependenciesonly withanaveragedifferenceof30.
addingpossibledependenciessignificantlyimprovestheprecision .
.
recall .
.
andf1 .
.
of capturing co change relations on average a file involvedin possibledependenciesinfluences28 morefilesand42 moredependencies than a file involved in just explicit dependencies hence dramatically changingthe fileand dependencysets within23.
and .
of architectural sub spaces respectively on average afileinvolvedinpossibledependenciesconsumes32 more maintenance effort.
our study provides strong evidence that the level of architectural impact imposed by these possible dependencies isnontrivial and in fact surprisingly high compared with ex plicit dependencies .
but the invisible nature of possible dependenciesmakes itmoredifficult tounderstandthemand tochange them.our results benefit architecture analysis and tools indicating that they should assess and even emphasize the ar chitecturalimpactofpossibledependenciesduetodynamictyping.
in summary this work makes the following contributions we have extended the enre tool to infer possible dependencies caused by dynamic typing from python code.
we present an empirical study on the possible dependencies revealing that the architectural impact imposed by such dependencies is higher than that of explicit dependencies.
we illustrate the benefits of analyzing possible dependencies on architecture analysis and practices in dynamic languages.
1all data can be found at we provide the benchmarks collected from open source projects for continued research of possible dependencies due to dynamic typing in python software.
intherestofthispaper sections2and3presentthekeyconcepts and describe the possible dependency extraction tool.
sections and report the study setup study results and potential impact of our empirical study.
sections and discuss the threats to validity and related work.
section draws conclusions.
key concepts thekeyconceptsusedinthispaperinclude entity explicitdependency and possible dependency.
this section will illustrate them using the python example shown in figure .
figure a snippet of test.py entity.
a code entity eis an object with a given name or identifier.
an entity can be a variable function class module etc.
dependency .
according to the definition of baldwin and clark exdepends on eyifchangestoeymay cause exto change.
a dependencyisdenotedas ex ey.adependencycanbea syntactic dependency extracted from source code a semantic dependency extractedfromthetextualinformationofsourcecode ora historical dependency recorded in revision history .
we focus on syntactic dependencies and identify two types of syntactic dependencies in dynamic languages like python a. explicit dependency .wedefine explicitdependency asthe syntactic dependency relations that is explicitly manifested insource code.
an explicit dependency ex eysatisfies one of thefollowingconditions thedependedentity eyoritsparent entity is explicitly imported the type of eyor its parent entityisdeclaredexplicitlyinitsvisiblescope.forexample figure2 shows that m f1 line f2 classe line and f2 classe.m line are explicit dependencies.
b.possibledependency .wedefine possibledependencyasthe syntactic dependency relation that is not explicitly manifested due tothelackoftypeinformationindynamictyping.thedepended entitieswithin possibledependencies mayberesolvedintomorethan one type and the dependency can only be uniquely determined at run time.
we denote a possible dependency aspi ex ey where iis the number of possible types which eycan be resolved to.
in particular p1meansthatthisdependencyisdeterministic thatis entityeycanonlyberesolvedintoonetype.
pi 1meansthatthe dependencyisnon deterministic for ey thereareicandidatetypes.in figure f4 r2.m line is a p1dependency since r2 canonlybe classe.f4 r1.m1 line26 isa p2dependency becauser1 has two possible types classaandclassb.
tool implementation to support ourempirical study on the architectural impactof possible dependencies we incorporated the concept of pipossible dependenciesandthetypeinferencetechniqueofxuetal.
into an extension of enre an existing dependency extraction tool.
our extension of enre can extract possible dependencies from source code in python.
figure3showsthepossibledependencyextractionframework based on enre.
the input is source code and the output is possibledependencies dpiwherepidenotesthetypeofpossibledependency.wewillintroducetheframeworkbyusingthepython example in figure .
entity identification .
this module provided by enre resolves and outputs code entities e e and expressions xp xp .
an entity is defined using a tuple of attributes including id qualifiedname shortname etc.weuse pythonfile linenumber exp fromname toname torepresenteach expression xp insourcecode that implies possible dependencies.
for example in figure line in test.pycontains one expression xp1 test.py r1.m1 f4 m1 .
it indicates one unresolveddependencyfrom f4tom1 i.e.
f4 m1 andthetypeof r1 has not been resolved.
inferencebyattributeconstraint .
usingeandxpas the inputs thismodulefollowstheattributeconstraintsproposedby xuetal.
toinferallofthepossibledependencies.thisisbased on duck typing i.e.
the type of an object is determined by howits attributes are used by others .
this module outputs an intermediate data structure o s a ca to record possible dependencies where s eis an entitythat denotes code scope ais anatomicexpression extractedfrom xp andcadenotesthesetof candidate types of a. foranexpression xpi inascope s thismodulefirst generates ahierarchicalstructure ti bysplittingthe expofxpiintoatomic expressions and denotes their parent child relations.
for example the result of splitting xp1ist1 a1 a2 wherea1 r1 a2 r1.m1 anda1is the parent of a2 forming a layered structure.
then this module resolves each ainti.
for the above t1 the candidate types of a2 r1.m1 will be resolved as cr1.m1 ct1 classa.m classb.m classc.m .
next the candidatetypesofitsparent a1 r1 willberesolvedas cr1 ct1 classa classb classc .afterprocessingotherexpressionsinthe same way the following elements will be added to o circlecopyrt f4 r1 ct1 wherect1 classa classb classc circlecopyrt f4 r1.m1 c t1 where ct1 classa.m classb.m classc.m circlecopyrt f4 r1 ct2 wherect2 classa classb circlecopyrt f4 r1.m2 c t2 where ct2 classa.m classb.m circlecopyrt f4 r2 ct3 wherect3 classe circlecopyrt f4 r2.m c t3 wherect3 classe.m now based on o we infer the possible dependencies f4 r1 andf4 r1.m1 arep3possible dependencies as cr1 cr1.m1 f4 r1 andf4 r1.m2 arep2possible 760figure the possible dependency extraction framework table the investigated python projects subject statistic file loc commit issuecommit commiter issuecommitter pyfile pyloc avglocperpyfile min median max sum issuecommit issuecommiter appears in projects out of projects.
dependencies f4 r2 andf4 r2.m arep1possible dependencies.
inferencerefinement .thismodulerefinestheintermediate structureo using the scoping rule and thepriority rule.n e x ti t extracts a set of possible dependencies dpi from the refined o. scoping rule in the above example the elements circlecopyrtand3 circlecopyrt inoshould be grouped together since they indicate that r1i s withinthescopeof f4 andtheircandidatetypesshouldbethe same.
their candidate types are refined to be the intersection of their original ca c ct1 ct2 classa classb .
accordingly the candidates of their children are also updated ct1 classa.m classb.m andct2 classa.m classb.m .
priority rule for a candidate type set containing more than one type if one type inherits from another we remove the sub typefrom the candidate set.
this rule follows the liskov substitution principle ifanentitydependsonparent abstracttype thenany sub types can besubstituted with each other whereverthe parent typeis used.thisrule manifeststheidea thatabstractclasses and interfaces are design rules of software architecture .
inthisexample withincandidateset classa classb classb inherits from classa.
as result ct1 andct2 will be refined as ct1 ct2 classa andtheirchildrenwillalsobeupdated ct1 classa.m andct2 classa.m .
afterrefining o wecanderiveasetof p1possibledependencies dp1 f4 classa f classa.m f4 classa.m f4 classe f4 classe.m .wecanseethattheserules refine some non deterministic dependencies into p1 i.e.
deterministic dependencies.
study setup to investigate the four research questions introduced in section wesetupacomprehensiveempiricalstudywithmultiplesteps and collected data from python projects.
.
subjects to minimize the possible bias caused by project domain or size we queried and chose open source python projects sorted by their number of stars from github using the github rest api.
we manually excluded projects that are learning tutorials and repeatedprojects.
finally we collected projects with diverse domains and sizes as the subjects of our empirical study.
foreachprojectwecollecteditsrevisionhistoryfromtheversion control system git.
the revision history covers from the beginning tothelatestreleaseofaproject.weonlyconsideredthecommits inwhichasourcefileismodified commitsthatonlyaddedfilesareignoredsincewefocusontheco changeandmaintenanceactivities.
an issue related commit is a commit labeled with an issue id.
table1summarizesthedemographicinformationoftheprojects thatweanalyzed file totalnumberoffiles loc totallinesof code pyfileand pyloc python filesand python loconly avglocperpyfile averagelocperpythonfile i.e.
pyloc pyfile commit total number of commits in the revision history committer total number of contributors issuecommit and issuecommitter issuerelatedcommitsandcommittersasrecordedintherevisionhistory.
min median and maxcorrespond to the minimum median and maximum values of a column s values over all projects.
.
dependency extraction and verification we used the understand tool to extract explicit dependencies from sourcecodeforeachproject.understandcanidentifyexplicitdependencies such as method calls variable