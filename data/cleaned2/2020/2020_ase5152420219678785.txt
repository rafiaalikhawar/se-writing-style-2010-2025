ifizz deep state and efficient fault scenario generation to test iot firmware peiyu liu shouling ji xuhong zhang qinming dai kangjie lu lirong fu wenzhi chen peng cheng wenhai wang raheem beyah bardbl zhejiang university hangzhou china liupeiyu sji fulirong007 chenwz zdzzlab zju.edu.cn xuhongnever saodiseng gmail.com binjiang institute of zhejiang university hangzhou china zhejiang university ngics platform hangzhou china university of minnesota twin cities minneapolis usa kjlu umn.edu bardblgeorgia institute of technology atlanta usa rbeyah ece.gatech.edu abstract iot devices are abnormally prone to diverse errors due to harsh environments and limited computational capabilities.
as a result correct error handling is critical in iot.
implementing correct error handling is non trivial thus requiring extensive testing such as fuzzing.
however existing fuzzing cannoteffectively test iot error handling code.
first errors typicallyrepresent corner cases thus are hard to trigger.
second testingerror handling code would frequently crash the execution whichprevents fuzzing from testing following deep error paths.
in this paper we propose ifizz a new bug detection system specifically designed for testing error handling code in linux based iot firmware.
ifizz first employs an automated binarybased approach to identify realistic runtime errors by analyzingerrors and error conditions in closed source iot firmware.
then ifizz employs state aware and bounded error generation to reach deep error paths effectively.
we implement and evaluate ifizz on popular iot firmware.
the results show that ifizz can find many bugs hidden in deep error paths.
specifically ifizz finds critical bugs of which are even in widely used iot libraries.
ifizz also features high code coverage and efficiency and covers .
more error paths than normalexecution.
meanwhile the depth of error handling covered by ifizz is .
times deeper than that covered by the state of theart method.
furthermore ifizz has been practically adopted and deployed in a worldwide leading iot company.
we will open source ifizz to facilitate further research in this area.
i. i ntroduction widely adopted iot devices that interact with physical environments are safety critical making it a high priority to maintain high reliability for practical deployment.
however previous works already show that iot devices are abnormally prone to diverse errors due to constraints such as complex hardware dependence limited hardware and system resources and disruptive environmental conditions .
once an error is not handled appropriately it may cause a device to become unresponsive or enter an incorrect state and finally lead tosevere consequences such as leaving a valve open flooding a factory or leaving a window unlocked.
thus correct errorhandling code which is intended to deal with erroneous situations where security or reliability issues may potentially occur is important in iot firmware.
shouling ji and wenzhi chen are co corresponding authors.table i comparison of sta te of the art fuzzing systems .
systemtailored for iotfault injectioninput independent error identificationdeep error path test avata r p2im halucinator iotfuzzer firm afl lfi eh test fifuzz ifizz well supported partially supported unsupported.
unfortunately the error handling code itself tends to be error prone because it is hard to be tested.
therefore bugsare quite common in error handling code .
additionally although error handling code is infrequently triggered in normal executions error handling bugs can lead to severe problems e.g.
device crashes or data loss.
besides bugs in error handling code may exist for a long time because it is more difficultto detect them.
thus it is critical to comprehensively andeffectively test the error handling code of iot firmware to detect hidden bugs.
although dynamic detection methods suchas fuzzing have been shown to be promising in finding bugs iniot devices they still suffer from an important limitation with effectively testing error handling code in iot especially the ones triggered by input independent errors such as hardware failures and memory allocation failures.
to cover more error paths researchers have adopted fault or error injection which intentionally and deterministically generates runtime errors to force the execution of error paths.
however designing an effective fault injection solution to test the error handling code in iot firmwarefaces several key challenges.
automatically identifying input independent errors.
first due to complex hardware dependence and execution environments a large number of diverse input independent errors occur in different iot devices.
it is impractical to identify all these errors manually.
second 36th ieee acm international conference on automated software engineering ase work licensed under creative commons attribution noncommercial no derivatives .
license.
36th ieee acm international conference on automated software engineering ase .
ieee .
ase51524.
.
the source code of iot firmware is often not available to thirdparty researchers making the identification of potential errors even harder.
testing deep error paths.
the execution path of a tested iot firmware may contain various error sites and error handling code commonly terminates the execution if an early error stops the execution the testing will not reachdeep error paths.
as shown in table i existing tools cannotsimultaneously solve all the above challenges.
for example fifuzz can find deep bugs hidden in error handling code.
however it cannot identify and produce errors without the source code of the tested program.
thus it is not suitable for testing iot firmware.
in this paper we propose ifizz a new fuzzing framework to efficiently test deep error handling code in linux based iot firmware.
the core of ifizz is a fault scenario generation system which overcomes the aforementioned challenges by the following new techniques.
automated identification of input independent errors.
before generating errors in a tested iot firmware we haveto identify the errors caused by input independent events such as hardware failures and insufficient memory in this firmware as fault injection targets.
previous works such as usually identify error functions by a simple heuristic that finds nullptrs or negative values.
however we must identify the self defined error code in different closed source firmware.
to this end we propose an automated binary based approach to statically identify the functions that may have input independent errors.
this approach is based on two observations of errors and error handling code in iot firmware.
error code as the return value.
following the programming convention an erroneous function would return error code e.g.
torepresent potential errors which are to be further checked e.g.
line in listing in callers.
input independent error conditions.
runtime errors in iot firmware can be triggered by various input independent conditions described in ii a .
with the observations our technique infers error code by examining whether a value is often checked when used as a return value in disassembled code leverages error code to infer errors and analyzes the error conditions to infer if the error is input independent.
in this way our technique can automatically identify input independent errors in closed source iot firmware.
1file open memstream .
.
.
register oms cookie cookie if cookie b u f m a l l o c ... null goto exit cookie 6exit cookie free cookie return null listing .
an example of error check and error handling code.
testing of deep error paths.
intuitively knowing which functions may return errors the following step is to generate errors at runtime.
however this strategy is hard to reach deep error paths if we always generate an error early the execution will crash before reaching deep error paths.
thus to reach deep error paths we propose a state aware and bounded errorgeneration method to generate fault scenarios that can guide the fuzzing to test deep error paths effectively.
state aware error producing.
we observe that if an error at a specific call stack leads to a crash the error at the same call stack maytrigger the same redundant crash in other fault scenarios.based on this observation we propose to reduce redundant fault scenarios by leveraging the state defined as the runtime context of an error site i.e.
its call stack and the sequence of the previous injected errors in this fault scenario of error sites.
in particular we first examine the state of an error site todetermine whether an error should be produced.
if the historical tests indicate that an error site has led to a crash in a specific state we do not re produce errors on this error site in the same state in subsequent tests.
bounded faults.
although the state aware technique can mitigate early crashes we still face the problem of exponential fault scenario explosion when producing multiple errors.
for example if there are nerror sites in a runtime trace we can generate 2n 1fault scenarios.
it would take unaffordable time to test all the scenarios.
on the other hand our empirical study reveals that most crashes are triggered by only a small number of errors in a fault scenario.
thus we propose a bounded faults approach to seek a proper number of faults to reduce redundant fault scenarios while covering deep error paths.
we have implemented a full featured prototype of ifizz and deployed it on linux based iot devices.
ifizz successfully discovers serious bugs.
we also compare ifizz to existing fuzzing tools and find that ifizz discovers many bugs that are otherwise missed by existing tools.
furthermore we conduct evaluations to measure the error handling code coverage.
the results show that in hours ifizz can cover .
more error handling code.
meanwhile the depth of error handling code covered by ifizz is .
times deeper than that covered by existing software fault injection sfi methods on average.
by collaborating with a worldwide leading iot company we have deployed ifizz in practical adoption.
overall we make the following technical contributions new open source framework.
we propose ifizz a new framework specifically designed for testing iot errorhandling code by generating fault scenarios.
we will open source ifizz to facilitate further research in this area .
new techniques.
we propose multiple new techniques inifizz .
our automated binary based approach can identify potential errors in closed source iot firmware.
the state aware and bounded fault scenario generation approach effectively reaches deep error paths.
new findings.
we evaluate ifizz on widely used linux based iot firmware images from leading vendors.
it in total finds bugs.
these bugs can lead to critical security issues such as dos and memory leakage.
practical adoption.
ifizz has been adopted in a worldwide leading iot company to analyze a large scale of commodity iot devices.
extensive experiments on the real world platform show that ifizz can efficiently find bugs in commodity iot devices.
806ii.
p roblem sta tement and motiv a tion a. errors in iot firmware v arious reasons can trigger errors in iot devices.
typically errors in iot devices can be divided into two categories according to the source of errors.
input dependent errors are caused by invalid inputs given in the command line such as damaged files and invalid parameters.
for example as shown in listing an input dependent error line may be triggered by an invalid input file.
compared to traditional pc programs iot programs may have fewer input dependent errors since most iot is not designed to process standard inputs.
by contrast input independent errors caused by occasional runtime events such as exhausted memory hardware failure and network unreachability might be more common on iot devices than traditional pcs due to the limited resources and complex hardware dependency of iot devices.
for example as shown in listing an input independent error line mayoccur due to the lack of memory.
if standard inputs trigger an error existing fuzzing can already cover it by mutating inputs.
therefore in ifizz we focus on input independent errors.
1int main int argc const char argv int a file f fopen argv r if check header f return ... if a malloc n u l l goto err listing .
examples of input dependent and input independent errors.
however triggering input independent errors is much harder than triggering input dependent errors.
input independent errors occur only when occasional events happen such as memory exhaustion and physical hardware damage rare during normal execution.
moreover physically producing these occasional events is also inefficient.
thus we use software fault scenario generation to produce input independent errors in this paper.
b. impact of error handling bugs in iot bugs in error handling code can cause critical issues because the intended protection is void.
taking listing as an example the error handling code lines3 i nt h e firmware of a smart lock is used to handle a hardware failure.
the error handling code will check if there is any motion in front of the door.
if so it will take a photo and send it to the user to help the userdetermine whether an attacker is prying the lock .
then it willsend a message to notify the user the lock is broken.
however pointer mat line might be null when the previous function get motion fails.
in this case a null pointer dereference bug will lead to a crash.
subsequently the user cannot get any notification about the broken lock.
1int main if check hardware failure motion m g e t motion if m state take and send photo send msg the door is broken !
email listing .
a bug in the error handling code of a smart lock.table ii study result of iotfirmw are pa tches .
programopenwrt dd wrt patches error handling patches error handling busybox .
.
dnsmasq .
.
dropbear .
.
iptables .
.
total .
.
1char c null 2char d 3switch error case free a break case free b break case bug1 null pointer dereference memcpy c error break case puts d break bug2 buffer over flow 14free a bug3 double free 15b func bug4 use a fter free listing .
examples of bugs in error handling code.
worse in addition to voiding the intended protection bugs in error handling code can lead to various impacts.
for example asshown in listing common impacts of bugs in error handlingcode include dos bug1 out of bounds memory access bug2 information leakage bug3 arbitrary code execution bug4 etc.
therefore it is important to detect and patch bugs in error handling code.
c. error handling code in iot firmware to understand the reliability of error handling code in iot firmware we perform a preliminary study to identify iot firmware patches that add or modify error handling code.
we manually look into patches from open source iot programs namely busybox dnsmasq dropbear and iptables inopenwrt and dd wrt .
as shown in table ii we analyze patches published between and .
finally we find that more than of patches fix bugs in the errorhandling code confirming that error handling is buggy.
further analysis shows that common bugs in error handling code include null pointer dereference memory overflow etc.
leading to severe problems such as system crashes and information leakage.
further we believe that the patched bug is just the tip of the iceberg and there are many more hidden bugs in iot firmware for the following reasons.
first iot firmware needs to handle a large number of nested runtime errors that may occur at runtime due to the complex hardware dependencyand limited resources.
thus it is challenging to implement correct error handling code i.e.
developers may make mistakes when handling complex nested errors.
second it is difficult to find the bugs hidden in error handling code of iot firmware since such code is hard to test by nature.
for example the iot firmware is often closed source making it impractical to manually identify the runtime errors or produce errors through 807fw fault scenario generation target program determination run command extraction error function identificationdynamic analysisfirmware preparationreportsfirmware fw fwfw fig.
.
the workflow of our framework.
compile time instrumentation.
besides facing a large number of runtime errors in iot firmware covering a certain error path is hard due to the complex error context.
for example the crash caused by an early error may prevent the testing of subsequent error paths.
therefore considering that the errorhandling code in iot firmware is critical yet buggy and to thebest of our knowledge there still exist no practical approaches for iot error handling code analysis we believe that testing error handling code in iot firmware is important and necessary for securing iot applications.
iii.
d esign of i fizz a. the framework we develop ifizz as an easy to use system whose workflow is shown in figure .
at a high level there are phasesin ifizz .
firmware preparation.
ifizz conducts several preparations in this phase.
for example we enable the debug interfaces and facilities of the tested firmware.
detailed in iv .
error function identification.
ifizz automatically identifies the error functions that can result in runtime errors by analyzingtheir possible return values and the corresponding conditions for triggering the error return value.
fault scenario generation.
ifizz generates useful test cases by utilizing our stateaware and bounded fault scenario generation approach.
dynamic analysis.
ifizz produces errors according to our fault scenarios and executes the tested code.
b. preliminary definitions definition error function ef .ef is a library either standard or customized function which can result in an inputindependent error in iot firmware.
definition error stack es .es fu n l o c fu n l o c ... ef loc ef includes a sequence of function calls at the call site of an error function ef in the order from caller to callee including the locations of function calls and called functions.
definition runtime trace rt .rt es1 es2 ... esnis a sequence of ess.
a rt records all ess during a software life cycle.
definition fault value fv .fv v1 v2 ... vnis a sequence of boolean variables.
each boolean variable v t orf is used to indicate generating an error or not.
definition fault scenario fs .fs r t f v is a pair of rt andfv.
a fault scenario is used to guide an instance of runtime fault injection.b intbmain b b b x funa b b y funa b b ......b b x x 1 b b y y 1 b b struct s funa b b b rb malloc ... b b if !r b b b return null b b elseb b b return r b ef main line 11es1 es2 rt funa line malloc main line funa line malloc fs fv x y null.
null pointer dereference at line in main !
x null.
null pointer dereference at line in main !
y null.
null pointer dereference at line in main !
execute normally.
f t t f t t f f fig.
.
examples fault scenarios.
figure shows a simple example of these definitions.
in the function main the objects xandyare allocated by calling function funa .i nfuna the object ris allocated by calling malloc and is returned to main .
the malloc infuna is anef.
there are two rtso fmalloc and four fss can be generated to trigger null pointer dereferences of the objects xandyat runtime.
c. automated binary based runtime error identification to dynamically test the error handling code in iot firmware the first problem we need to solve is to identify functions that may introduce runtime errors.
due to the complexhardware dependency and execution environments various runtime errors may occur in different iot devices.
thus it is impractical to identify runtime errors in each tested firmware manually.
meanwhile since most iot firmware is closed source identifying runtime errors by source code analysis is alsoimpractical.
therefore to effectively identify runtime errorsin iot firmware we aim to identify efs automatically.
to this end we first conduct an empirical analysis on uclibc an open source c library widely used in linux based iot devices .
specifically we manually identify efsi n uclibc and then analyze these functions and their uses.
from our analysis we observe two characteristics of runtime errors in iot firmware.
error code as the return value.
following programming conventions an ef often returns error code to its caller to represent the occurrence of errors.
meanwhile thecaller often checks the return value to find out whetheran error occurs.
for example function malloc returns null to represent an error.
then its caller function open memstream in listing checks this return value.
input independent error conditions.
for an input independent error the error condition is an occasional runtime event such as lack of memory or hardware failure.
such error conditions are input independent.
for example in function open memstream of listing the error condition at line is used to check the lack of memory but not standard inputs.
based on our observations we propose an automated binarybased runtime error identification approach to identify efs effectively.
first we leverage error code to infer errors.
then 808we identify input independent errors by analyzing error conditions.
we show the approach of error function identification in algorithm .
for a function f ifizz first scans its assembly code to collect all its return values line .
for each return value ifizz examines whether or not there is a caller of f who checks it line and if so infers that the return value is an error code ec line .
from each ec ifizz searches backward in fto find its check condition cc i.e.
ecis controldependent on cc line .
then ifizz performs a backward inter procedural dataflow analysis to collect the sources on which ccis flow dependent line .
finally ifizz examines whether or not there is a source of ccthat is not a program parameter line .
if so ifizz infers that freturns ec when an input independent error occurs and thus fis an ef line .
algorithm error function identification input f set of functions in iot firmware.
output ef set of functions that can result in input independent errors in iot firmware.
1foreach finfdo r getreturnv alues f c getcallers f foreach cincdo foreach rinrdo ifischecked r c t r u ethen ec r cc getcondition ec f s getsource cc ifisinputdenp s false then append f ef break iffinef then break performing a completely accurate data flow analysis will encounter two common problems indirect call and data flow explosion.
fortunately ifizz does not rely on completely accurate data flow analysis since it aims to find an inputindependent source instead of finding all sources.
first even if indirect calls influence some data flows we can still complete the analysis through other data flows.
thus in ifizz indirect calls are ignored at present.
this is an inherent limitation of this technique.
however the evaluation in v b indicates that ifizz can still dramatically reduce the manual work of identifying realistic efs.
second once a data flow proves that a source is input independent the analysis completes instead of constantly analyzing other sources.
d. state aware and bounded fault scenario generation the fault scenario generation aims to cover as many error paths as possible and reach deep error paths within a limited time.
we first conduct a study to reveal obstacles in achieving these goals.
specifically we implement a simple prototype that injects error randomly on every error site and evaluate it on a randomly select firmware.
then we analyzethe experimental results and summarize two main obstacles in generating efficient fault scenario.
early crashes.
error testing would frequently crash the tested program which prevents us from testing the fol lowing deeper error paths.
for example suppose that rt es1 es2 es3and the tested program always crashes when an error occurs on es1.
in this case the fss that produce the error on es1are profitless and redundant since they always lead to the same crash and never test the error handling code of es2andes3.
fs explosion.
a naive approach to generate fssi st o traverse all the combinations of efs.
if there are ne f s along rt the number of generated fss can be 2n .
obviously generating all fss is infeasible if the tested program contains a large number of efs.
it can take unaffordable time if we apply all these fss.
to overcome these obstacles we propose a state aware and bounded approach to effectively generate the fault scenarioscovering different error paths in modest time and reduce redundancy.
algorithm state aware and bounded error producing input l crash log.
fs current fault scenario.
me bound of the number of errors.
mbe bound of the distance between the first and the last error.
1n geterrnum fs 2ifn m e then d geterrdist fs ifd m b e then foreach einfs do ifsiteinlog e l t r u ethen s getstate e ifstateinlog s l t r u ethen notinjecterr break injecterr state aware error producing.
we define the state of an error site as its es and the sequence of the previous injected errors in this fs.
suppose an error site in a certain state leads to a crash.
in that case we avoid producing an error on the same error site with the same state in subsequent tests since such tests are redundant and prevent testing deep error paths.
specifically we record the state of the latest error site in a crash log when a crash occurs.
meanwhile we record the state of the current error site dynamically.
thus as shown in algorithm before we produce a runtime error on an error site we first check whether this error site is in the crash logs line if so we further check whether the state of the current error site is the same as the one in crash logs line .
when the current error site and its state appear in the crash logs we skip the error producing on this error site line .
in this way we prevent redundant crashes but still cover subsequent error handling code.
809error function analyzer bug chekeremulators physical devices firmware packer bug reports runtime monitor runtime informationfault scenario fault scenario generatorfirmware fw fw f w f wfw fig.
.
overall architecture of ifizz.
bounded faults.
our state aware approach supports us in covering deep error paths by mitigating early crashes.
however we still face fs explosion when producing a large number of errors.
such a problem exists in all of the tested iot firmware making it impractical to test them effectively.
to solve this problem we propose a bounded approach to produce a suitable number of errors in a fault scenario.
the design is based on two observations obtained from the evaluation of the simple prototype.
first most crashes are caused by only a small number of errors and generating fault scenarios with a large number of errors is often unnecessary.
thus we propose the first rule the maximum number of errors me in a fault scenario should be bounded line in algorithm .
second we also observe that most crashes are caused by neighboring errors.
hence we propose the second rule the maximum distance i.e.
the number of error sites between the first and the last error mbe in a fault scenario should also be bounded line in algorithm .
iv .
i mplementa tion we implement a full featured prototype of ifizz .
figure shows its architecture consisting of the following five parts.
error function analyzer.
it unpacks firmware images and analyzes their assembly code by leveraging our automated binary based approach iii c to identify efs.
we develop a customized unpacker based on firmadyne to unpack a firmware image.
additionally we implement an ida script to perform assembly code analysis on the obtained iot pro grams.
the assembly code analysis can also be achieved by utilizing other widely used tools such as radare2 and oda .
we use ida because it has the highest precision value when disassembling binary code .
firmware packer.
it repacks the tested programs and other necessary tools e.g.
telnet to obtain the iot firmware with the necessary capabilities to perform our test.
first of all we need to enable the debug interfaces of the testedfirmware.
unlike pcs that offer complete interaction and debugging interfaces to users manufacturing best practices of iot devices dictate stripping out or disabling these interfaces.
thus researchers cannot analyze iot firmware in the same way as operating a pc such as simply connecting a keyboard and a monitor to the tested devices.
some firmware contains a connectivity tool for remote login such as ssh andtelnet .
however most vendors keep their authentication keys secret forsecurity concerns.
it is inefficient to brute force keys on all thetested firmware.
moreover vendors utilize a set of technologiesto mitigate key leakage after firmware unpacking .
thus toobtain a debug interface we insert a telnet into the extracted file system.
meanwhile we modify the auto start scripts inthe file system to make the telnet service automatically start with a customized authentication key when the firmware starts.
after that we can operate the firmware through the inserted tool and the authentication key later.
additionally we also insert a customized library loader into the extracted file system to support debugging facilities such as ld preload to support library functions hijacking.
we also put the faultscenario generator and the runtime monitor into the extracted file system.
after obtaining the new packed firmware we first run it in multiple emulators and physical devices to build the test environments.
then the tested programs are assigned to these environments for concurrent tests.
1int hijacking error function collect state if !
state in crash log return error return original error function listing .
an example of hijacking function.
fault scenario generator.
it creates test cases according to our state aware and bounded fault scenario generation approach iii d .ifizz leverages library function hijacking to record the state of error sites and produce errors.
we implement the fault scenario generator into a dynamically linked library.
for each ef a hijacking function is implemented in this library.
by utilizing the ld preload facility we add to the tested firmware our hijacking functions are executed when thecorresponding original efs are called.
the hijacking functions record the state of error sites and produce errors.
to enable a better understanding we present an example of a hijacking function in listing .
specifically we record the state of the latest error site in a crash log when a crash occurs.
meanwhile we record the state of the current error site dynamically line .
before we produce a runtime error on an error site we first check whether its state is in the crash logs line .
if so we skip the error producing on this error site and return the original ef line otherwise we produce an error i.e.
return the error code of the original ef directly at this error site line .
runtime monitor.
first it performs dynamic analysis before starting fuzz testing to obtain the target iot programs and their corresponding run commands.
an iot firmware may contain abundant software.
intuitively analysts can analyzethe whole firmware by separately testing each contained software.
however it can be extraordinarily time consuming to do so.
additionally many programs in firmware are poorly documented.
thus even though analysts can locate a program they may still miss the corresponding parameters to executethose programs accurately.
thus our runtime monitor runs the tested firmware and traces the runtime process information to obtain the target iot programs and their corresponding 810table iii basic informa tion of the tested firmw are .a p isaccess point e indica tes emula ted devices .
model vendor version device arch dir 850l dlink .00b05 router e mipseb dgs dlink .
.
switch e armel fw tv ip121wn trendnet v2 .
.
.
camera e mipseb k2 phicomm v163 router mipsel k2 openwrt .
.
router mipsel tycam110 tuya v2 camera armel w ap200 cisco .
.
.
ap e mipseb w ap4410n cisco .
.
.
ap e mipseb wnap320 netgear v3.
.
.
ap e mipseb wg103 netgear v2.
.
ap e mipseb run commands.
then the runtime monitor repeatedly runs the tested iot programs to perform bug testing.
bug checker.
it analyzes the crash log to generate crash reports.
we implement the bug checker as an ida script.
based on static analysis techniques the error function extractor and the bug checker can analyze cross platform firmware.
the fault scenario generator and the runtime monitor can easily be cross compiled to different architectures and then directly run both in emulators and devices.
therefore ifizz is suitable for testing cross platform iot firmware.
v. e v alua tion in this section we first describe the experimental setup v a .
then we evaluate the effectiveness of ef identification v b and the variation caused by bounded fault v c .
the result of error handling testing and further analysis are given in v d and v e respectively.
finally we present the comparison with existing tools v f and the practical adoption ofifizz v g .
a. experimental setup ifizz is designed and implemented to be applicable to different types of devices with different operating systems processors and runtime libraries.
this section evaluates ifizz with popular routers ip cameras access points and switches from different leading vendors dlink cisco netgear etc.
we choose these devices and vendors because they arerepresentative and they have a large market share .
as shown in table iii the iot firmware produced by vendorsare used for evaluation in which firmware images are tested on emulators and are tested on physical devices.
before testing firmware images ifizz first performs dynamic analysis of the tested firmware to obtain the target programs.
in total ifizz obtains vendor specific programs and runcommands to run these programs.
b. ef identification table iv shows the result of ef identification including the number of all the library functions and the number of efs identified by ifizz .
in total ifizz identifies efs out of functions.
to measure the accuracy of our method we further conduct manual analysis on the efs.
we finally confirm efs related to occasional errors such as memory allocation failures and peripheral access failures thattable iv results of ef identifica tion .
library function error function libuclibc .
.
.so libuclibc .
.
.so libuclibc .
.
.
.so libcrypt .
.
.so libcrypt .
.
.
.so libxtables.so.
.
.
total can indeed occur and trigger error handling code at runtime.
we also analyze the false positives in the identified efs.
the reason is that some identified functions never trigger inputindependent errors.
for example function strcpy meets all the requirements that we used to identify efs i.e.
its callers often check its return value and the condition of its return value is not related to standard inputs.
however this function never triggers runtime errors.
on the other hand intuitively our method may have false negatives.
if there exists an ef whose return value is never checked by its caller our method will miss it.
however we did not find an example in this case.
in summary the accuracy of ifizz for identifying efsi s .
which indicates that ifizz can dramatically reduce the manual work of identifying realistic efs.
c. me and mbe as described in iii d we propose two bounds i.e.
me the maximum number of errors in a fs and mbe the maximum distance between the first and the last error in a fs to improve the efficiency of generating useful test cases.
to understand the variation caused by differentbounds we evaluate ifizz with different mes and mbes on randomly sampled popular programs namely sed find restore configuration killall logger md5sum pidof syslogd lighttpd and configd from the wnap320 firmware.
for each group of me and mbe we use ifizz to conduct tests for hours and record the number of program executions crashes and unique crashes.
we count unique crashes by analyzing runtime traces.
as shown in figure when me and mbe become larger despite the throughput increases the number of crashes and unique crashes does not always increase.
for example when me and mbe the throughput is larger than that when me and mbe .
there are two main reasons for the increase of throughput.
first smaller me and mbe give up a large number of test cases due to the bound limitation.
thus it takes more time to generate another suitable test case after each finished test.
second the test cases generated in terms of large bounds contain more faults at the beginning of the testing.
thus these test cases are highly possible to triggera crash within a short time of execution and make the new test start earlier.
from figure we also find a trade off between the value of the bounds and the number of crashes.
the number of crashes and unique crashes when me and mbe are smaller than that when me and mbe .
on the one hand if 811fig.
.
v ariation of results with respect to different me and mbe.
the bounds are too small we have to give up too many test cases which leads to the miss of crashes.
on the other hand if the bounds are too large we may generate too many redundant test cases which leads to low efficiency when finding crashes.
in summary the results indicate that in a certain testing time hours in our test a set of moderate bounds me and mbe can improve the efficiency of discovering unique crashes.
based on this evaluation we set me and mbe by default in the remaining tests.
d. results of error handling testing detected bugs.
leveraging the confirmed efsi n v b we perform bug detection on the firmware listed in table iii.
we evaluate each firmware image for hours.
to uniquely count bugs we identify their root causes by manually checking the assembly code and count bugs based on rootcauses.
table v shows the unique bugs detected by ifizz .
specifically ifizz finds bugs including program bugs and library bugs in the tested firmware images.
1file open memstream ... register oms cookie cookie if c o o k i e m a l l o c ... !
n u l l if cookie b u f m a l l o c ... null goto exit cookie ... free cookie buf exit cookie free cookie return null listing .
null pointer dereference in uclibc.
for example ifizz finds a bug in uclibc which is a c library for embedded linux systems and is widely used in iotdevices .
in this library there is a null pointer dereference that exists in the open memstream function.
it is worth noting that this bug exists in nested error handling paths.
at least two failures are needed to trigger this bug.
for example inbusybox if a memory allocation fails it executes the errorhandling code that invokes vasprintf to show an alert message.
then vasprintf callsopen memstream as shown in listing .
if another memory allocation in open memstream fails i.e.
cookie in line becomes a null pointer it calls another error handling code in lines .
however the error handling code is not implemented correctly which will result in a dereference to a null pointer in linetable v detected bugs in the tested firmw are .b p represents bugs in iot program .b l represents bugs in iotlibrary .
firmware unique crash confirmed bug bp bl dir dgs fw tv ip121wn k2 openwrt tycam110 w ap200 w ap4410n wnap320 wg103 total .
this bug indicates that it is necessary to generate fault scenarios that contain more than one error for finding deep bugs in the nested error handling code even though sometimes developers have implemented error handling code they maymake mistakes in the code due to the complex contexts of nested errors and thus necessary testings are desired.
we find that this bug exists in uclibc before version v1.
.
.
before developers noticed and patched this bug in september this bug has existed in uclibc for more than years.
in these years developers modified this source file many times and even patched the error handling code that contains this error.
however this bug is ignored for an extraordinarily long time.
ifizz can find this bug in a few seconds.
thus we believe that with ifizz analysts and developers can effectively and efficiently improve the security of their code.
bug features.
reviewing the bugs found by ifizz w e find three interesting features.
firstly some bugs are triggered by more than one failure in different efs which indicates that it is necessary to generate fss with multiple errors covering multiple efs.
secondly the lack of error handling code in nested error paths causes many bugs which indicates that it isnecessary to test deep error paths.
third as shown in table v different unique crashes could be caused by the same bug.
for example ifizz discovered more than unique crashes in wnap320.
however after further analysis we find that bugs in iot libraries lead to unique crashes.
these buggy libraries are frequently used in iot programs.
thus they lead to a large number of crashes under different executionpaths.
this discovery gives us two insights.
the bugs 812fig.
.
crashes discovered by different fault scenario generation approaches.
in iot libraries are very harmful because they will affect a large number of programs.
although unique crashes i.e.
crashes under different execution paths are widely used to evaluate the effectiveness of fuzzing systems it is not always fair and objective to evaluate fuzzers only by this metric.
building up a reasonable evaluation criteria system for fuzzers is an interesting yet challenging problem by itself which is a promising future research direction.
e. ablation study in ifizz our state aware and bounded fault scenario generation are important techniques for generating effective fss.
to evaluate the benefits of them we develop other tools by modifying ifizz via removing different strategies.
we implement and compare three tools in this evaluation.
simple is implemented with none strategy.
it performs fault injection to every error site.
state is implemented with the state aware approach.
ifizz is implemented with all approaches.
we evaluate the resulting tools on the representative programs described in v c for hours.
unique crashes.
we first investigate the performance of ifizz on finding crashes and unique crashes.
we count unique crashes by identifying unique runtime traces of all crashes.
as shown in figure despite that ifizz triggers fewer crashes within a given time it can still find most unique crashes.
for example simple triggered crashes in hours.
however there are only .
uniquecrashes.
state discovers .
unique crashes.
by contrast .
out of the crashes identified by ifizz are unique.
the results indicate that the state aware and bounded fault scenario generation approach leveraged by ifizz effectively discovers unique crashes in iot firmware.
besides we also find that ifizz can discover all the unique crashes found by simple andstate which reveals that ifizz does not miss unique crashes when reducing redundant crashes.
error path coverage.
a good detection approach should generate effective fss that cover more unique error sites and error stacks intending to trigger more error handling code.
thus we then evaluate the error path coverage of ifizz .w e implement another tool base as a baseline in this experiment.
base does not produce errors.
it runs the tested program repeatedly.
as shown in figure each of our approaches improves the error path coverage and the more strategies wefig.
.
code coverage of different fault scenario generation approaches.
fig.
.
depth of runtime traces covered by different fault scenario generation approaches.
included the more error paths we cover.
for instance base covers only unique error sites and unique error stacks.
when we produce errors simple discovers unique error sites and unique error stacks.
after we add our state aware approach state can find unique error sites and unique error stacks.
finally ifizz can cover most unique error sites and error stacks .
there are several reasons for this increment.
first producing errors can improve error path coverage by forcing the execution of these paths.second the state aware and bounded approach can further improve the error path coverage by efficiently covering deep error paths.
error path depth.
besides we investigate the depth of error paths covered by different tools.
specifically we evaluate error path depth from two aspects.
the depth of runtime traces i.e.
the number of error stacks in a runtime trace.
the depth of error stacks i.e.
the number of function calls in an error stack.
figure shows the depth distribution of runtimetraces.
ifizz can trigger deeper runtime traces than other tools.
in particular when using simple the depth median of the runtime traces is .
in comparison the depth median of the runtime traces of ifizz is .
times deeper .
meanwhile each approach used by ifizz helps trigger deep runtime traces.
the reason is that they can help ifizz reach deeper error stack by automatically skipping the production of errors on duplicate error stacks.
similarly as shown in figure ifizz can also trigger deeper error stacks than other tools.
for example the depth median of error stacks tested by ifizz is .
deeper than that tested by simple .
813fig.
.
depth of error stacks covered by different fault scenario generation approaches.
table vi results of i fizz and firm afl.
program libifizz firmafl crash unique crash crash unique crash bzcat .07m cmp wc uniq total 5m f .
comparison with existing tools recently several tools have been developed to fuzz iot firmware.
among them we select the state of the art and open source fuzzing tool firmafl to make a detailed comparison with ifizz most of the other tools are closedsource .
meanwhile to validate the generality of ifizz w e further select busybox an open source program widely used in iot firmware as the tested program.
note that such a selection is mainly for conveniently comparing ifizz and firmafl.
further considering that firmafl can only testthe programs with standard inputs we turn to test fourrepresentative applets of busybox including bzcat cmp wc and uniq which have standard inputs.
as firmafl can only work on an iot emulator we conduct this evaluationon the iot emulator used in for hours per applet.
we show the results in table vi from which we have the following observations.
ifizz can find much more unique crashes than firmafl.
for instance firmafl does not find any crash on cmp anduniq .
by contrast ifizz can find unique crashes on these two applets.
ifizz can report unique crashes more efficiently.
for example on bzcat ifizz discovers unique crashes out of found crashes while firmafl only finds unique crash out of .
million crashes which indicates that firmafl wastes much timein triggering the same bug.
the reason is that compared to firmafl ifizz can cover input independent error paths using state aware and bounded fault scenario generation.
therefore ifizz can effectively find more bugs in these deep error paths missed by firmafl.
g. practical adoption to verify the availability of ifizz in the practical production environment we deploy ifizz in a large scale of commodity iot devices by collaborating with a world wide leading iot company.
our cooperative company provides types of iot products and services to users in countries and regions.
by the time of submission the company have confirmed32 previously unknown bugs detected by ifizz .ifizz is constantly discovering new bugs.
thus we are continually working with the company to confirm bugs and develop patches to fix them.
extensive evaluation in real world adoption shows that ifizz is more than a laboratory tool it can efficiently find bugs in commodity iot devices and help companies improve the security of their products.
vi.
d iscussion error function identification.
ifizz identifies errorfunctions that can actually fail and trigger error handling code by leveraging the approach proposed in iii c .h o w e v e r a s described in v b there are false positives in the identified error functions.
the main reason for false positives is that our approach treats a function as an error function as long as it returns error code and its return condition is input independent.
however some functions such as strcmp that meet these requirements are not real error functions.
thus it is interestingto develop an automated and effective method for more accurate error function identification.
on the other hand ifizz cannot identify error functions whose return values have never been checked in any iot firmware.
therefore ifizz may have false negatives.
however the possibility of this case is minimal and we have not found any such instance during our manual analysis.
we will conduct more analysis on the possible false negatives in the future.
bug detection.
similar to existing works ifizz may miss bugs in error handling code.
there are many reasonsfor these false negatives ifizz may miss bugs caused by static error functions.
even though ifizz can effectively and comprehensively identify the extern error functions in libraries the functions implemented in iot programs may alsocause occasional errors.
however ifizz cannot test the errorhandling code triggered by such functions at this moment.
ifizz relies on observable crashes to detect bugs.
however previous works have proved that the effects of memory corruption are often less visible.
as a result ifizz may miss the bugs that never cause crashes.
to solve this problem we can use advanced checkers such as the heuristicsproposed in to detect the missed bugs.
ifizz cannot cover all the code in the tested iot firmware.
for example some code only executes with specific inputs.
thus ifizz may miss the error handling code in such input related paths.
to solve this problem we plan to combine input mutation fuzzers with ifizz to cover more paths.
vii.
r ela ted work a. analysis of error handling code many static methods detect bugs in error handling code by analyzing source code .
for instance epex identifies error paths based on error specifications and explores different error paths to find bugs.
static analysis can conveniently analyze the target program without actually executing it.
however it often reports many unreal bugs due to the lack of the exact runtime information.
moreover existing approaches 814need the source code of the tested programs which is rarely the case for iot firmware.
in terms of dynamic analysis t fuzz tests deep paths by removing sanity checks.
intuitively t fuzz can cover error handling code.
however it does not inject any fault such as set a null pointer .
it thus misses many bugs in fault scenarios such as null pointer dereference bugs.
many sfi based methods can test error handling code and have shown promising performance on pc programs .
some approaches inject single or random faults in each test case to trigger error handling code.however these methods can only cover a limited numberof error handling code and report many unreal bugs .
several approaches can cover more error handling code to detect more real bugs.
for instance fifuzz can find deep error handling bugs by utilizing a context sensitive sfi approach.
however the existing sfibased approaches are mainly designed for testing pc programs.
they do not provide an efficient proper solution for testing iot firmware.
for example they fail to identify the targetfunctions in iot firmware binaries and to generate efficientfault scenarios.
ifizz solves these problems by leveraging multiple strategies described in iii c and iii d. b. vulnerable iot device analysis without the source code of iot firmware many approaches perform static analysis on the binary image .
for instance gemini utilizes a neural network based approach to detect known vulnerable functions.
however these methods suffer from high false positives due to the lack of runtimeinformation.
moreover these static methods are limited in discovering known bugs.
to mitigate these problems several approaches support dynamic analysis on iot firmware .
however running a full fuzzing operation inside the device is impractical because iot devices are typically designed to be as low cost or low power as possible.
thus previous works emulate embedded firmware based on qemu .
however the main goal of these works isto provide a suitable environment for running and testingiot firmware.
although some of them used existing tools such as afl to perform bug detection in their environment most of them are not dedicatedly designed for bug detection.
recently iotfuzzer directly performs fuzzing on physical iot devices.
however the efficiency of iotfuzzer is low due to the slow throughput.
to the best of our knowledge ifizz is the first work to perform dynamic bug analysis on not only iot emulators but also physical devices.
meanwhile ifizz is the first work that tests the error handling code in iot firmware.
viii.
c onclusion error handling code in iot devices is prevalent but highly buggy.
testing error handling code in iot devices faces extra challenges due to their complex running environments andlimited computation power.
in this paper we presented anovel framework named ifizz to effectively test the deeperror handling code of iot firmware.
ifizz can efficiently and effectively test error handling because it automatically identifies potential errors and constructs effective fault scenarios.
it can also test deep error paths since it performs state aware and bounded fault scenario generation.
we develop a fullfeatured prototype of ifizz and evaluate it on real world iot firmware images.
ifizz finally found critical bugs.
it also features high code coverage.
notably ifizz covers .
more error paths than normal execution and the depth of error handling code covered by ifizz is .
times deeper than that covered by traditional fault injection on average.
thepromising results benefit from ifizz s strengths in effectively and efficiently exploring error handling code.
finally wecompared ifizz with a state of the art tool firmafl and the results show that ifizz can find many bugs that are missed byfirmafl .
we have deployed ifizz in practical adoption and we will open source ifizz for facilitating future iot security research.
our study may shed new light on designing practical iot vulnerability detection approaches for the research community and iot industry.
ix.
a cknowledgment this work was partly supported by nsfc under no.
u1936215 the zhejiang provincial natural science foundation for distinguished young scholars under no.
lr19f020003 the fundamental research funds for the central universities zhejiang university ngics platform the national key research and development program of china under grant no.
2020aaa0140004 and alibaba zhejiang university joint research institute of frontier technologies.