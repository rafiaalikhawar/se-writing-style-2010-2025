recommending stack overflow posts for fixing runtime exceptions using failure scenario matching sonal mahajan fujitsu laboratories of america inc. sunnyvale usa smahajan fujitsu.comnegarsadat abolhassani university of southern california los angeles usa abolhass usc.edumukul r. prasad fujitsu laboratories of america inc. sunnyvale usa mukul fujitsu.com abstract using online q a forums such as stack overflow so for guidance to resolve program bugs among other development issues is commonplace in modern software development practice.
runtime exceptions re is one such important class of bugs that is actively discussed on so.
in this work we present a technique and prototype tool called maestro that can automatically recommend an sopost that is most relevant to a given java rein a developer s code.
maestro compares the exception generating program scenario in the developer s code with that discussed in an sopost and returns the post with the closest match.
to extract and compare the exception scenario effectively maestro first uses the answer code snippets in a post to implicate a subset of lines in the post s question code snippet as responsible for the exception and then compares these lines with the developer s code in terms of their respective abstract program graph apg representations.
the apg is a simplified and abstracted derivative of an abstract syntax tree proposed in this work that allows an effective comparison of the functionality embodied in the high level program structure while discarding many of the low level syntactic or semantic differences.
we evaluate maestro on a benchmark of instances of java res extracted from the top java projects on github and show that maestro can return either a highly relevant or somewhat relevant sopost corresponding to the exception instance in of the cases compared to relevant posts returned in only instances by four competitor tools based on state of the art techniques.
we also conduct a user experience study of maestro with java developers where the participants judge maestro reporting a highly relevant or somewhat relevant post in of the instances.
in some cases the post is judged to be even better than the one manually found by the participant.
ccs concepts software and its engineering software creation and management software verification and validation software defect analysis software testing and debugging this work was done when the author was an intern at fujitsu laboratories of america permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse november virtual event usa association for computing machinery.
acm isbn .
.
.
.
code search static analysis runtime exceptions crowd intelligence acm reference format sonal mahajan negarsadat abolhassani and mukul r. prasad.
.
recommending stack overflow posts for fixing runtime exceptions using failure scenario matching.
in proceedings of the 28th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse november virtual event usa.
acm new york ny usa pages.
introduction software developers regularly refer to online q a forums for a wide variety of development tasks from system design and configuration to code completion to software debugging and patching .stack overflow so the most popular such forum with over million answers to million questions sees nearly million views per month .
software debugging and patching is a resource intensive development activity consuming up to of developers time .
in particular runtime exceptions res are an important class of bugs that have been recognized as having a severe impact on system availability and crashes .
realizing their importance researchers have proposed automated debugging repair and recovery techniques specifically addressing runtime errors in general and res in particular .
in fact of the nearly .
million posts on sotagged with java and or android nearly a remarkable are related just to java res showing that developers are actively discussing java res on so presumably to resolve such errors in their own code.
in this paper we present a technique and prototype tool maestro mine and analyz e st ackoverflow to fix runtime excepti ons that can automatically find an sopost that is most relevant to a given rein a developer s java code.
we define the most relevant post or posts since there could be several as one discussing the same runtime scenario exciting the same type of reas the developer s code.
such a tool can save the time it would take the developer to understand the high level scenario producing the exception create a search query based on it search sowith the query and manually browse the search results one discussion post at a time to identify the most relevant post.
these steps may need to be repeated several times till an acceptable post is found.
once found the user could potentially use one of the suggested answers to fix their bug.
this fixing could be done manually or assisted by a tool likeexamplestack .
one solution to the above problem is to use sopost recommendation techniques like prompter which search for a post 1obtained by searching sowith the name of any of the top most common java res.arxiv .10174v1 sep 2020esec fse november virtual event usa mahajan et al.
most relevant to the user s code context i.e.
the function the user s code is trying to implement.
however as shown in section these techniques do not work for our problem.
the reason is that what we seek is nota post discussing the overall function the user s code was implementing but rather one addressing the specific sequence of program state manipulations that raised the exception.
the overall function of the method within which these manipulations occur is somewhat irrelevant.
another idea would be to use traditional code clone detection techniques such as or code to code search techniques such as to check correspondence between the user s code and the question code snippet in a given so post.
however this approach would not work either see evaluation in section in part because of the above reason it is not apparent what portions to try to match between the exception throwing developer code and the socode snippet.
further even the relevant lines of the so post snippet if identified could differ significantly from their counterparts in the developer code in terms of not only variable names which code clone detectors easily handle but also data types and program constructs e.g.
a while vs. a forloop while instantiating the same core exception causing scenario.
thus this problem seems outside the realm of traditional code clone detection or code search since the matching criterion is the cause of the exception rather than the function of the containing method.
our approach is designed around three key insights.
first in most sodiscussion posts the question includes a code snippet exemplifying the scenario being discussed.
in particular for posts addressing res the question code snippet naturally includes a structured description of the exception raising scenario.
thus our approach exclusively uses this question code snippet and compares it to the exception throwing user code to decide the relevancy of the post.
second the question code snippet may include code to make the snippet functionally or syntactically complete but otherwise irrelevant to the exception scenario.
however the answers in the post also include code snippets suggesting solutions to the discussed problems.
in our case these answer code snippets often suggest patches for the reand often more directly address the failure producing lines.
thus we use the answer code snippets to identify the lines in the question code snippet relevant to the exception scenario and discard the rest.
we term this failure scenario localization fsl .
third as mentioned above the failure producing lines in the developer code could have substantial syntactic differences from those the socode snippet.
to facilitate a meaningful comparison we develop a representation called an abstract program graph apg .
conceptually an apg is a simplified abstracted and partially canonicalized derivative of the abstract syntax tree ast for a piece of code.
thus we compare the developer code and question code snippet after performing fsl in terms of their respective apg s. we also use the apg representation when aligning answer code snippets in a post with the question code snippet for the purpose of failure scenario localization.
we develop a technique and prototype tool maestro based on the above insights and conduct an internal evaluation on a benchmark of instances of java res spanning exception types extracted from the repositories of the top java projects on github.
the evaluation shows that maestro returns either a highly relevant or somewhat relevant sopost corresponding to the exception instance for of the instances compared to relevantposts returned in only instances by four competitor tools based on state of the art techniques.
further a comparison with three different baseline variations of maestro shows that each of the key design features of maestro are essential to its overall performance.
we also conduct a user experience study of maestro with java developers where the participants judge maestro as reporting a highly relevant or somewhat relevant post in of the instances.
in some cases the post is judged to be even better than the one manually found by the participant.
this main contributions of this paper are as follows technique an automated technique maestro for recommending relevant stack overflow posts to java developers which could assist them in diagnosing and fixing res in their code.
tool a prototype implementation of the maestro technique along with four different baseline variations of it to evaluate its design features.
evaluation an evaluation of maestro its three baseline variants and four competitor tools on a benchmark of reinstances extracted from the top java projects on github.
user experience study a user study with java developers to qualitatively evaluate the performance of maestro .
illustrative example in this section we illustrate our technique using the example shown in figure .
consider the developer s buggy source code given in figure 1a extracted from the bridginghivemetastore.java file of the presto project a popular distributed sql query engine.
the buggy source code throws a concurrentmodifcationexception a common runtime exception re that may be thrown by methods detecting concurrent modification on an object when such modification is not permitted.
in this example the exception is thrown because the collection object returned by table.getsd .getcols is modified at line while being iterated over at line .
in order to resolve the encountered re the developer may refer to stack overflow so to find a post discussing the exception in the same context.
to facilitate this maestro collects soposts discussing concurrentmodificationexception and compares code snippets in the question section of each post with the developer s buggy code.
figures 1b and 1d show question code snippets extracted from two so posts discussing this re.
let us consider the snippet shown in figure 1b.
comparing the snippets from figure 1a and figure 1b directly is challenging since their function is different.
figure 1a s function is to drop a database column while figure 1b s function is to delete a user.
the code snippets also have lines that are irrelevant to the exception scenario.
in particular only lines from figure 1a and lines and from figure 1b are pertinent to the rebeing thrown.
to address this challenge our approach is to extract the failure scenario on the so side and then check if it is also instantiated in the buggy code.
maestro automatically localizes the failure scenario in the question snippet figure 1b by leveraging the answer code snippets such as the one shown in figure 1c.
the answer snippet in figure 1c suggests a way for fixing the concurrentmodificationexception by using iterator to remove the user object.
the answer snippet clearly points to lines constituting the exception scenario in therecommending stack overflow posts for fixing runtime exceptions using failure scenario matching esec fse november virtual event usa 211public void dropcolumn string databasename string tablename string columnname verifycandropcolumn this databasename tablename columnname org.apache.hadoop.hive.metastore.api.table table delegate.gettable databasename tablename .orelsethrow new tablenotfoundexception new schematablename databasename tablename for fieldschema fieldschema table.getsd .getcols exception thrown here if fieldschema.getname .equals columnname table.getsd .getcols .remove fieldschema altertable databasename tablename table a buggy source code bridginghivemetastore.java 1public static void main string args user user new user user1 user1 1l user user1 new user user2 user2 2l user user2 new user user3 user3 3l list user list new arraylist user list.add user list.add user1 list.add user2 for user user3 list system.out.println user3.getname if user3.getname .equals user1 list.remove user3 q b stack overflow post question code snippet1iterator user it list.iterator 2while it.hasnext 3user user it.next if user.getname .equals user1 it.remove a c stack overflow post answer code snippet 1collection t mycollection assume it is initialized and filled 2for iterator ?
index mycollection.iterator index.hasnext object item index.next mycollection.remove item q d stack overflow post question code snippet figure example from presto github.com prestodb presto throwing concurrentmodificationexception issue a apgb apg of buggy code shown in figure 1a b apgq apg of stack overflow post shown in figure 1b figure apgs of buggy code and stack overflow post question snippet.
however it is challenging to establish this correspondence since the question and answer snippets may include syntactic differences.
in this case the question iterates using a for loop over the list object while the answer iterates using a while loop over an iterator object.
to address this challenge maestro abstracts and canonicalizes the snippets in the abstract program graph apg and then structurally aligns the two apg s to find the corresponding lines automatically.
the color coding in figure 1b and figure 1c show the corresponding lines obtained from the apg alignment.
figure 2b shows the apg representing the matched lines extracted from the question snippet.
this apg forms the exception scenario pattern esp for concurrentmodificationexception as per this post.
let us call this pattern apg q.to find if this post matches the exception scenario in the developer s code maestro first represents the buggy code as an apg figure 2a .
let us call it apg b. now the next step is to compare apg qtoapg b. for this maestro aligns the two apg s by computing a to node mapping and computes a similarity score.
the similarity score is calculated as a weighted sum of the structural and data equivalence.
structural equivalence is comprised of analyzing the programming constructs used in a matched pair and if the constructs match then the equivalence between the involved data types is checked.
for both construct equivalence and type equivalence maestro applies some level of abstraction depending on program constructs.
for example maestro identifies user defined classes as appclass .
hence the methods remove inesec fse november virtual event usa mahajan et al.
figure overview of the approach lines and of figure 1a and figure 1b respectively are equivalent at both type and construct level since both can be abstracted ascollection.
remove appclass .
the results for apg alignment is shown in figure 2a and figure 2b.
the nodes exhibiting both construct and type similarity are shown in yellow.
the red arrows in the apg s of figure show the data edges.
data similarity is calculated as the similarity between the uses of variables appearing in the equivalent nodes of apg qand apg b. for example both variables t1andlistin the matched loop nodes from figure 2a and figure 2b respectively are used in the matched remove nodes as well.
therefore this example has five pairs of construct andtypematched nodes and a perfect match between the uses of the two variables t1andlist.
assuming the weights for construct type and data similarity to be and .
respectively the similarity score for this post figure 1b is .
figure 1d shows a code snippet from another stack overflow post.
assuming the same weights as above the similarity score for this is .
since there only two construct matches for loop and remove at lines and respectively no type matches and only one var use match t1 .
therefore maestro chooses the first post figure 1b with score as the most relevant post for the developer s buggy code over the second post figure 1d with score .
.
this result is correct since the first post very closely mimics the exception scenario of the developer than the second post.
approach the goal of our approach is to automatically find the most relevant stack overflow so post for the runtime exception re encountered by the developer.
most soposts discussing res include program artifacts such as a code snippet exemplifying the exception scenario being discussed or a failure stack trace.
these artifacts could potentially be used as a basis for establishing relevance to the developer s failure.
however stack traces appear in a relatively small fraction of posts.
therefore we decided to design our approach around matching of code snippets.
specifically our key insight in finding the most relevant post is that if the developer s code exhibits the same exception scenario as presented in the code snippet in the soquestion then it is very likely that the post will contain answers to fix the exception in the developer s code context.
finding a relevant post based on exception scenario similarity is complicated by several challenges.
the first challenge is in capturing the exception scenario in the sopost.
code snippets in thequestion section of soposts can be arbitrarily large while the statements capturing the exception scenario i.e.
the lines that are responsible for exciting the reare typically small.
for example the question code in figure 1b is of lines while the lines capturing the scenario of concurrentmodificationexception are only three lines and .
this challenge requires that our solution correctly identify the lines relevant to the reunder consideration.
the second challenge is that the developer s code and the socode may have significant syntactic and semantic differences such as in the structure of the code e.g.
interleaving of the exception scenario with added removed lines syntactic constructs e.g.
forvs.while and identifier names.
this challenge requires that our solution tolerates the various syntactic and semantic differences between the developer s code and so code while establishing similarity.
two insights into these challenges guide the design of our approach.
the first insight is that it is possible to automatically identify the potentially relevant lines contributing to the exception scenario insoquestion code snippets by referring to the answers of that question.
code snippets in soanswers tend to be more pointed in discussing the problem in the question code while suggesting ways of fixing it.
leveraging this observation we designed a failure scenario localization fsl technique that overlays answer code on question code to identify the relevant lines section .
.
the second insight is that it is possible to abstract out the syntactic and semantic differences allowing for a normalized structural code comparison between developer s code and socode.
for this we designed the abstract program graph apg that captures the structural and data relationships between program statements while abstracting out low level syntactic details section .
.
further our matching function calculates a weighted similarity score section .
.
our approach can be roughly broken down into two distinct phases offline mining and analysis ofsoposts to index them by exception scenario patterns esps and real time matching of the mined soposts and developer s buggy code to find the most relevant post.
these are shown in figure .
the first phase selects and then indexes soposts related to res.
for each indexed post it then performs fslto identify the lines of code relevant to the retype being discussed in the post by using answer pointers.
this involves representing the sopost s question and answer code snippets as apg s and then structurally aligning section .
them to find the overlapping nodes.
the apg of the question is then pruned by removing the nodes not matched to the answer apg recommending stack overflow posts for fixing runtime exceptions using failure scenario matching esec fse november virtual event usa and saved in persistent storage for use in the second phase.
we refer to the pruned apg as the esp.
the second phase takes three inputs reinformation name and failing line available from the stack trace buggy source code containing the failing line and the esps extracted from the first phase.
the second phase begins by representing the buggy code as an apg .
it then performs a code similarity matching between the apg of the buggy code and each of the esps extracted for the given retype.
the sopost mapping to the espreceiving the highest similarity score is then returned as the output.
we now explain the different parts of our approach.
.
indexing of so posts in this step we index soposts by retaining only the posts that are related to fixing res and discard the rest.
our filtering criteria is that the post has at least one answer java or android tags retype in the title and at least one parseable code snippet in the question.
we define parseable code snippets as syntactically complete and conforming to java grammar rules as verified through any off the self parser such as javaparser .
the filtered soposts are then grouped by re type.
.
abstract program graph apg theapg is a model capturing the structural and data relationships among the program statements of a given code snippet.
compared to traditional data structures such as ast and program dependence graph the apg focuses on simplifying abstracting and canonicalizing the low level syntactic details.
this is a more suitable data structure for our purpose since it allows our approach to compare code despite the frequent differences in their syntax and semantics.
.
.
apg definition.
formally we define the apg as a directed graph of the form n rs rd m .
here n nis a node in the graph that corresponds to a statement in the code.
figure gives the grammar used for defining the nodes in the apg .
a node can be of type method loop variable etc.
node type root designates the unique root nodes of the apg .
different node types further have different embodiments such as method node is defined by three components caller which can be another node type e.g.
variable or method name which is the method name and a list of arguments which can be a list of other nodes e.g.
variable or literal .
rs n nis a set of directed edges such that for each pair of nodes n1 n2 rs there exists a structural relationship between n1andn2.
similarly rdis a set of directed edges capturing the data relationship between n1andn2.mis a function m rd7 2cthat maps each edge in rdto a set of tuples of the form c v where vis a variable used in n1andn2and is the type of v. details of building the apg are discussed in section .
.
.
we define the following utility methods for a node nin the apg.
definition .
.
construct n returns the node type of n such asloop if and variable .
the only exception is for node types declare method and operation for which node type appended with the variable type method name and operator respectively are returned to make the constructs more specific.
definition .
.
types n returns the list of types for node n. for example the node method integer reverse x returns the list integer integer where xis an int variable.
node root variable method if loop cast arraccess fieldaccess constructor declare literal operation instanceof sync method method caller name arguments if if expression loop loop expression arraccess arrayaccess caller index cast cast type expression constructor constructor type arguments declare declare variable fieldaccess fieldaccess caller name literal literal type value operation operation operator operands instanceof instanceof caller type sync synchronized caller variable name type caller variable method fieldaccess arraccess this super expression variable method fieldaccess arraccess operation instanceof arguments expression operands operand operand operand literal expression root root name variable name method name field name type primitive class name missing operator assign binary unary figure grammar of nodes in the apg figure 2a shows an excerpt of the apg for the buggy code snippet in figure 1a.
the solid black arrows show the structural relationships and the dashed red arrows show the data relationships.
line numbers corresponding to the snippet are shown above the nodes.
.
.
building the apg.the process of building the apg can be broken down into three steps creation of nodes and edges attributionof missing types and abstraction of constructs and types.
creation to build the apg for a given code snippet the approach first parses the snippet into an ast.
nodes of the apg are then created by traversing over the ast and extracting groups of ast nodes that can be simplified and summarized into one node of the apg .
for example the sub tree corresponding to the method call expression is summarized into the apg node type method with information about the method s caller name and arguments.
the apg retains the structural edges between the groups of summarized nodes obtained from the ast.
data edges are then added to the apg to capture the consecutive usage context of the variables used in the apg .
for example the variable fieldschema is used in getname node followed by its use in remove .
hence a data edge is added between the two nodes as shown in figure 2a.
attribution after the apg has been created the attribution step augments the apg by adding missing information about types.
this step is necessary as the code snippets under consideration may not be complete especially the ones coming from so.
our approach is comprised of three kinds of attributions use constructs to decide missing types of variables.
for example if the construct being used is for each then the type of the variable used in its iteration can be assigned as collection since the for each loopesec fse november virtual event usa mahajan et al.
typically operates over a collection object.
similarly the type of a variable used to specify the conditions in the if while do while and forconstructs can be assigned to be boolean .
the caller of method invocations without explicit specifications can be presumed to be local methods with the caller attributed as this .
variables without explicit declaration of types but containing assignments from literals constructors or arrays are attributed with the types of the kinds of assignment.
for example type of xin the code snippet x is inferred to be integer .
abstraction this step abstracts and canonicalizes the information in the apg to allow code comparison in the later steps to focus on high level structure of the code rather than small syntactic differences.
with this goal in mind we designed the abstraction step to operate at different levels.
first canonicalize semantically equivalent constructs.
we identify for for each while and do while as semantic equivalents of each other since they perform the same function despite the syntactic differences.
for these looping constructs we canonicalize their node type as loop .
for example for each at l216 in figure 1a is translated to loop node in figure 2a.
similarly if ternary operator ?
and switch case constructs are assigned a canonicalized representation of if node.
all binary operations e.g.
and unary operations e.g.
and assignment of values to variables are generalized to an operation node with the operator field specifying the operation type such as plus minus and assign.
second the abstraction step processes the data types of variables.
our approach first converts all primitive types into their corresponding wrapper classes such as intis normalized tointeger .
then the approach identifies user defined or non java framework classes and re attributes them as appclass type of fieldschema is changed from fieldschema to appclass in figure 2a .
lastly the approach abstracts all collection class interface types such as list and hashmap into a common type collection type of list object in figure 2b is changed from arraylist to collection .
normalization of the collection classes is driven by the observation that the root cause for the reacross all different collection classes is the same.
canonicalizing all collection classes allows our approach to focus on the exception causing scenario and find a relevant sopost addressing the root cause rather than being tied up in type differences.
finally the abstraction step scans for duplicate sub trees within the apg assigns them to new variables and refactors their use to point to the new variables.
this refactoring helps reduce the overall size of the apg .
for example the method chain table.getsd .getcols appears at lines and hence it is refactored into a new variable t1 as shown in figure 2a.
.
apg structural alignment we now describe our alignment component that is used in the fsl and code similarity matching steps.
the goal of this component is to find the structural correspondence between two apg s. the apg s are first converted into structural trees by removing their data edges.
we then apply the apted tree edit distance algorithm to find the corresponding nodes.
the output is a set of tuples of the form n1 n2 m where n1andn2is a pair of matched nodes and mindicates the type of match full or partial.
given a cost model the apted algorithm produces as output an optimal minimal cost set of edit operations required for transforming structural tree t1into tree t2.
the different possible operationsare match delete insert and update .
we define the cost model as follows.
the match operation is designed to perform a leveled equivalence check between two nodes n1 t1andn2 t2.
if both the constructs definition .
and types definition .
of n1and n2are identical then it is considered as a full match and has no cost implying the most preferred operation.
if only the constructs match then it is considered to be a partial match and the cost is .
.
if nothing matches then a unit cost is returned.
the delete operation generally has a unit cost unless the node to be deleted is same as the node at the failing line then it returns an infinite cost.
the intuition behind preempting the deletion of nodes at the failing line is to prevent false positive alignment at locations in the code that are not related to the exception scenario.
insert and update operations simply return a unit cost.
.
failure scenario localization fsl given a sopost the goal of this step is to identify lines in the question code snippet that are relevant to the exception scenario.
to perform the fsl our insight is that answer code snippets often suggest patches for the rebeing discussed in the question and in so more directly reference the failure producing lines.
thus our approach is to use the answer snippets to identify the relevant lines and discard other lines.
this idea of using answer code snippets is broadly analogous to spectrum based fault localization techniques which use failing test cases to locate the faulty lines.
thefslstep takes as input a sopost.
for each question and answer code pair the approach begins by representing them as apg q andapg a respectively.
it then aligns apg qandapg ausing the algorithm discussed in section .
to obtain a set of matched nodes.
each matched node nq apg q is annotated as relevant.
after all of the answer code snippets in the post have been processed apg q is pruned by deleting any nodes not annotated through any answer.
this pruned apg q called the exception scenario pattern esp is then produced as the output of the fsl step.
.
code similarity matching the goal of this step is find the degree of similarity between the developer s buggy code snippet and a sopost s question code snippet to determine the relevancy of the post for the developer.
to determine relevance our insight is to compare the two code snippets based on the similarity between their exception scenarios.
the code similarity matching step takes three inputs the developer s buggy code exception information failing line and exception type and esps obtained from the fslofsoposts during the offline phase.
the approach first converts the buggy code into apg b. it then obtains the set p ofesps corresponding to the given exception type.
p pis aligned with apg busing the algorithm described in section .
.
the approach then computes the similarity score discussed below for pusing the set of matched nodes given by the alignment function and analyzing apg bandp.
the approach orders the soposts corresponding to the esps inpin descending order of similarity.
posts with same similarity score are ordered based on the number of user votes high to low which is an approximate indicator of the popularity of the post.
finally the topmost so post is returned as the output of the approach.
similarity score w1 c w2 t w3 v w4 s recommending stack overflow posts for fixing runtime exceptions using failure scenario matching esec fse november virtual event usa equation shows the similarity score which is a function of four weighted heuristics.
the heuristics cover different aspects of similarity structural construct and type data var use and size esp .
each of the four heuristics are normalized to report a value in the range .
we now describe the heuristics.
construct similarity c is the sum of partially matched nodes divided by the total number of matched nodes.
the partially matched nodes are obtained by scanning the set of tuples returned by the alignment algorithm where m partial .
types similarity t is the sum of fully matched nodes divided by the total number of matched nodes.
similar to above fully matched nodes are obtained by scanning the tuples for m full.
var use similarity v measures the similarity between the uses of variables appearing in the matched nodes of pandapg b. the intuition behind this heuristic is that related exception scenarios should respect the same data relationships between their nodes as well.
for a matched node pair np nb the approach extracts the variables nodes at npandnb respectively.
for each variable v it then collects the set of nodes uv where the variable is being used by traversing the data edges in the apg under consideration.
the approach then computes the jaccard similarity between the uvofpand that of apg b. for example for the matched loop ... nodes from figure 2a and figure 2b u t1 ulist loop remove .
thus their jaccard similarity score is .
.
var use similarity score is calculated as the sum of all jaccard similarities of all variables in the matched nodes divided by the total number of variables.
esp size similarity s is given by min p pideal divided by max p pideal where p is the size total number of nodes of pand pideal is the size of the ideal espfor that exception type.
this allows our approach to penalize rather small or large esps which may contain too little or superfluous information that may lead to false positive matches.
a small esp can be caused if the answer code snippets used in the fslstep do not fully capture the exception scenario while a large espcan be caused by answer snippets that contain redundant matches with the question code snippet.
since knowing the ideal espsize for each recontext is not feasible for a given exception type we use median size derived from all esps of the exception type as a proxy for the ideal size.
evaluation to assess the effectiveness of our approach we conducted an empirical evaluation to address the following research questions rq1 how effective is maestro in recommending relevant so posts for fixing res?
rq2 how effective are the key contributions localization matching and program abstraction in finding a relevant post?
rq3 how relevant are the soposts suggested by maestro compared to other state of the art techniques?
.
implementation we implemented our technique as a java prototype tool named maestro .
we used javaparser v3.
.
to parse code snippets and build their asts.
we also minimally pre processed the code snippets by adding enclosing class and or method to improvetheir parseability.
we leveraged the implementation of apted algorithm to compute the structural alignment between apg s. the four weights w1 used in equation were set to and .
respectively.
these weight values were selected by performing an empirical analysis on a subset of the dataset.
.
datasets we instantiated maestro onsoposts from the data dump released in march .
filtering by the criteria discussed in section .
gave us a pool of usable soposts.
the number of posts per exception type ranged from to with an average of posts and a median of posts.
for our evaluation we created a benchmark of instances extracted from the top java repositories on github.
each instance is comprised of the buggy java file throwing the reand the failing line number.
the top github repositories represent popular large and well maintained projects.
to select our evaluation instances we first scanned the commit messages of the top github repositories for the mention of at least one of the java retypes in a fixing context.
we established the fixing context by considering keywords such as fix resolve repair avoid and prevent.
we then filtered out duplicates commits that did not contain any java change files and commits that were consisted of simply throwing the re.
after the filtration we were left with candidate patches across unique retypes.
we then categorized these candidates by exception type into four groups high medium low and very low based on the frequency of their corresponding retypes.
high category comprised of retypes having or more candidates.
similarly medium with candidates low with and very low with only one candidate.
this resulted in the four categories including and retypes respectively.
this distribution approximates the frequency of occurrence of the different res in the real world.
finally since our evaluation metrics involve manual inspection section .
we chose to select a small but representative sample from each of the retypes.
thus to mimic the geometric progression observed across the four recategories our methodology was to randomly select and candidates from the four categories respectively for each of the corresponding retypes.
to collect the instance from each selected candidate we downloaded the buggy java file i.e.
one version before the candidate s commit id and determined the failing line by analyzing bug reports commit messages and or based on our domain knowledge.
table shows a summary of our evaluation dataset under the columns category retype and inst .
the complete benchmark is available as part of the maestro artifact at .
.
evaluation metrics the goal of our evaluation is to measure the relevancy of the so posts recommended by maestro rq1 its variants rq2 and its competitors rq3 for fixing res.
however there exists no ground truth for calculating such a relevancy.
this relevancy has to be derived through a manual inspection that is necessarily subjective.
for this we recruited two external participants to manually evaluate and provide the relevancy ratings for rq1 .
our participants were software professionals with a java experience of years.esec fse november virtual event usa mahajan et al.
to further reduce bias for each of the instances the participants were provided with eight soposts produced by the different tools by maestro by its variants and by its competitors in a randomized andanonymized fashion.
the participants independently analyzed all of the instances and then sat down together to resolve differences with one of the authors serving as a mediator to reach consensus .
before resolving the differences we measured inter rater reliability using cohen s kappa which gives a score of the degree of agreement between two raters.
across the ratings provided by each participant the value of kappa was found to be .
implying substantial agreement between the raters .
the participants were asked to rate each sopost in one of the following four categories instrumental i the participant feels confident that the sopost captures the rescenario precisely and offers a highly effective repair in the context of the instance.
helpful h the participant finds the sopost informative i.e.
offers insight into the re but does not provide a direct solution for fixing therein the context of the instance.
unavailable u nosopost was recommended by the tool.
in a real world deployment this would have required the end user to perform their own manual search for a solution.
misleading m the participant finds the so post highly irrelevant to the instance.
this rating scale broadly follows the approach of zimmermann et al.
.
we did not include a don t know category following the advice of kitchenham et al.
as our participants were wellexperienced to always make an informed decision.
to characterize the overall effectiveness in recommending a relevant sopost we used the following metrics again following prior research where they have been shown to be successful in avoiding scale violations .
i score percentage of perfect soposts i.e.
rated instrumentali score i i h u m ih score percentage of relevant so posts i.e.
rated instrumental or helpfulih score i h i h u m m score percentage of irrelevant so posts i.e.
rated misleadingm score m i h u m details of the participant ratings for the instances across all eight tools rq1 are available at .
rq1 effectiveness of maestro table shows the results grouped by retypes.
maestro reported an overall ih score of i.e.
soposts for out of instances were rated relevant instrumental or helpful .
of these posts were rated instrumental i score .
this shows that maestro was effective in recommending relevant so posts for fixing res.
a perfect ih score was reported for out of retypes.
one prominent pattern that we observed among these successful cases was that the exception scenario was typically well defined with a specific sequence of actions leading to the re.
an example of such a pattern is described in section for concurrentmodification .
it is a multi line pattern with a distinctive structural dependency table effectiveness results of maestro category re type inst i score ih score m score highclasscastexception .
.
.
concurrentmodificationexception .
.
.
illegalargumentexception .
.
.
illegalstateexception .
.
.
indexoutofboundsexception .
.
.
nullpointerexception .
.
.
mediumarithmeticexception .
.
.
nosuchelementexception .
.
.
rejectedexecutionexception .
.
.
securityexception .
.
.
unsupportedoperationexception .
.
.
low emptystackexception .
.
.
negativearraysizeexception .
.
.
very lowarraystoreexception .
.
.
bufferoverflowexception .
.
.
bufferunderflowexception .
.
.
cmmexception .
.
.
illegalmonitorstateexception .
.
.
missingresourceexception .
.
.
overall .
.
.
... 2if name null 3return uploaders.values .iterator .next re ... a buggy code from bazelbuild bazel ... 2tile visibletiles.keyset .iterator .next 3if tile !
null ... ... b so post figure relevant post for nosuchelementexception yellow shows full match andblue shows partial match remove enclosed within a loop and data dependency same collection object is used in loop iteration and remove invocation.
another example of a well defined but single line pattern is shown in figure 5a.
nosuchelementexception is thrown when the iterator has no more elements.
maestro searches through a pool of over posts for this retype to find the post shown in figure 5b.
the post is highly relevant as it poses a similar problem as the buggy code.
however finding such an accurate post manually can prove to be rather challenging as was reported by our user study participants section .
who particularly appreciated maestro s post by saying it was better than what they found and that the post can solve the problem perfectly .
the abstraction encoded in maestro sapg coupled with its matching algorithm facilitates anchoring on this post the expression iterator .next matches fully while visibletiles.keyset is found to match partially after abstracting out the details.
on the contrary retypes such as nullpointerexception showcase an overly generic pattern viz.
dereferencing a null object which can have a wide range of manifestations.
this makes it challenging for maestro to anchor upon specific program elements that can help find the best post.
figure shows an example of thisrecommending stack overflow posts for fixing runtime exceptions using failure scenario matching esec fse november virtual event usa ... 2while !isshutdown.get re ... 4if this.metricuploader !
null ... a buggy code from alibaba jstorm1... 2for square s gameboard 3for square ss s ss square.empty ... b so post figure irrelevant post for nullpointerexception blue shows partial match case.
the reis thrown at line in the buggy code because get is invoked on isshutdown which is null.
since the program elements are not specifically pertinent to the re maestro finds an arbitrary post that matches at irrelevant constructs such as loop line and field access line .
our investigations revealed two other reasons when maestro reported irrelevant posts.
first inaccuracies in the fslstep lead to under or over specific esps.
this happens when the answers do not capture the failure scenario succinctly and with a sufficient code context.
as a consequence of this maestro again anchors on irrelevant program elements resulting in arbitrary posts.
the second reason is when the exception scenario in the buggy code is very rare or application specific maestro may not report any post which happened for out of the instances or it may report irrelevant posts based on peripheral matches.
in our experiments we found that maestro takes a median .
sec average sec end to end to find the most relevant so post on a core desktop machine.
we believe this makes maestro effective for real time use.
.
rq2 key contributions of maestro .
.
design.
in this experiment we evaluate the importance of the three main contributions of our work by creating three baseline variants of maestro .
the first variant maestro noloc measures the impact of the fslstep section .
by removing it from the workflow.
the second variant maestro simplematch assesses the importance of the heuristics based weighted similarity score computation section .
by replacing it with a simple sum of the matched nodes full and partial i.e.
the post with the highest number of matches is returned as the most relevant post.
lastly the third variant maestro ast evaluates the importance of the apg representation section .
by replacing it with ast.
for this variant we implemented the cost function for structural alignment section .
as follows a strict syntactic match between method calls class names data types etc.
constitutes a fullmatch while matches between rule nodes such as ifstatement and methodcallexpr constitute a partial match.
.
.
results.
figure shows the distribution of the participant ratings for maestro and its variants.
the ih scores for the three variants show a significant almost linear drop compared to maestro and respectively.
the primary reason for this decrease is that the variants tend to match with the lines in the so snippet that are not related to the exception scenario.
concretely maestro noloc matches entire sosnippets with the instance.
this falsely causes the snippets to match peripherally to the core exception scenario leading them to be ranked higher.
conversely while maestro simplematch employs fsl it gives preference to maestrono localization simple matchast instrumental helpful unavailable misleading ih scorefigure maestro vs. its variants maestrofacoy retop rateddeckardprompter re instrumental helpful unavailable misleading ih score figure maestro vs. other techniques esps that match maximally with the instance albeit incorrectly.
maestro overcomes this problem by penalizing inflated esps by comparing them with the ideal espsize as discussed in section .
.
on the other hand while maestro ast employs both fsland the heuristics based similarity scoring it performs poorly because theast representation alignment results in very few fullmatches while a high number of false positive partial matches.
overall this experiment demonstrates the strengths of the different components inmaestro and how they contribute to its ability to meaningfully compare bug scenarios and thereby identify relevant so posts.
.
rq3 comparison with other techniques .
.
design.
maestro does not have any direct competitors since there exist no techniques targeting its exact use case.
however state of the art sorecommendation techniques code matching techniques and the native sosearch engine can serve as viable alternatives.
representing the first group is prompter the only existing technique that searches and suggests soposts for a given context albeit from a code completion perspective.
to adapt to our use case we created prompter re which prefixes prompter s default search query with the rename .
to provide sufficient code context prompter re is given the entire method from the instance containing the failing line as its input.
for the second group we used state of the art syntactic and semantic code clone detectors to match input buggy code with so code snippets.esec fse november virtual event usa mahajan et al.
for the syntactic code clone detector we selected deckard which is based on comparing asts.
we made this choice by comparing its performance with the current generation token based detector sourcerercc .
details of this experiment can be found at .
aroma s light weight search could also have served as an alternative syntactic code similarity detector.
however since principally deckard and aroma both capture and compare syntactic and structural relationships in code we selected deckard as a representative.
as our semantic code clone detector we used facoy .
we compare maestro with the first phase of facoy which produces a ranked list of soposts by matching structural code tokens.
to suit our use case we created facoy re by changing its default implementation to compare input with soquestion snippets rather than answers.
we instantiated both deckard and facoy re on the same sopool as maestro and provided as input a fragment of the instance encompassing the failing line and its immediate surrounding context lines .
lastly we compare with the native sosearch engine which for a given retype keyword returns a list of top rated posts ranked by relevance.
.
.
results.
figure shows the distribution of participant ratings for the instances across different competitors.
the ih scores of facoy re top rated deckard and prompter re are and respectively.
maestro outperforms all the techniques with a substantial margin showing improvement in ih score.
facoy re finds soposts using tf idf and cosine similarity which calculates the highest overlap between less frequent code tokens.
this does not work in cases where the code elements are commonly occurring ones such as in indexoutofboundsexception or in cases with extremely rare e.g.
app specific tokens that may not have any representation on so.
deckard demonstrated a similar problem in such instances where finding syntactic matches between buggy code and sosnippets resulted in irrelevant or no matches.
this underscores the strength of maestro sapg representation which is able to sufficiently abstract out the syntactic details to compare at a high level.
the main reason behind low quality posts reported by prompter re is that its technique is based on a bag of words algorithm that tries to find a general purpose post discussing the overall function of the buggy code rather than focusing on the exception scenario.
we also observed that although we had augmented the search query the added rename was in some cases removed by the search engine e.g.
google likely due to the close relevancy among the other words in the query.
in such situations the posts returned by prompter re did not even pertain to the re.
lastly although the sotop rated post for a given retype contains rich and informative content it is unable to provide satisfactory resolution for alldifferent exception scenarios of the re.
this experiment shows that state of the art techniques applied in a straight forward manner may not be well suited for maestro s use case of finding most relevant so posts for fixing res.
.
user experience case study we conducted a controlled study results at to understand developers experience using maestro .
we presented instances from our dataset to java developers with each instance evaluated by five different participants.
for a given instance the participants were asked to manually search and report a relevant sopost.then they were shown and asked to rate the post recommended by maestro and provide feedback about their experience.
we decided not to measure time saving as other research has shown that manual time varies greatly by experience level and has little correlation with task complexity .
maestro met with a high user approval with the ih score of i score .
comments left by the participants were very insightful in understanding their reasoning behind the qualitative assessment of the posts.
we found that broadly the specific characteristics of the post itself as well as the participants manual search influenced their judgement of maestro s post.
for the posts rated instrumental the participants provided feedback such as better post than i found from my search i found the exact one searching post can solve the problem perfectly and the concept and solution of the post is correct .
for posts rated helpful example comments were get basic understanding of the potential reason for the error it doesn t solve the problem but the discussion is relevant and provides javadoc and reasonable understanding to peruse why problem was happening .
while for posts marked misleading comments were same exception but totally different context and the post is not really addressing the real problem .
overall such quality attributions strongly resonate with our observations discussed in section .
.
we found that the participants generally had a positive attitude towards maestro as it was able to find posts of comparable or even higher quality than them for most instances.
.
limitations mining so developer forums like soonly discuss commonly occurring generic development issues.
maestro inherits this limitation in that it cannot assist with very application specific res e.g.
anrerooted in the semantics of application specific apis.
it is also not very helpful with overly generic res like nullpointerexception where there is no common yet sufficiently descriptive pattern to the exception and a specific post discussing it.
code based search maestro s current search relies exclusively on an analysis of code snippets in the q a threads.
although this provides relevant matches in a significant fraction of instances mining and incorporating information from the natural language text in the posts would be a valuable next step.
scope of analysis our fslstep uses the structure of answer snippets to pin point the failure inducing statements.
however posts with lengthy and or non specific answer snippets may lead to sub optimal localization and match results.
in future work we propose to use other sources of information including static or dynamic analysis of question and answer snippets or information in the surrounding text to improve the accuracy of localization.
another limitation is that currently maestro s analysis can only handle intra procedural failure scenarios.
this design is driven by the observation that the vast majority of rescenarios tend to be succinct and local.
however extend maestro to support to interprocedural scenarios could further expand its scope.
construct validity judging the relevance of soposts produced by any of the tools section rq1 rq3 is an inherently subjective task and hence a potential threat.
we mitigated this threat by specifying clear criteria for each of a valued rating scale consistent with previous work .
further we used two non authors torecommending stack overflow posts for fixing runtime exceptions using failure scenario matching esec fse november virtual event usa independently rank each output instance post to remove authorbias and get a plurality of opinions.
then we used a discussion process for the raters to reach consensus on instances of different opinion also following previous work .
finally we calculate and report cohen s kappa a measure of inter rater reliability showing substantial agreement between the raters original ratings.
related work mining q a sites.
the work most closely related to ours is prompter which continuously searches and recommends relevant soposts to a developer as she develops code in an ide.
prompter models the user s code as a bag of words creates a search query of rare tokens derived from it and uses this query to search so.
libra augments this approach by including relevant terms from the user s recent browsing history.
however while these techniques are a good fit for the general code completion use case that they target as shown in section they do not work well for our use case where more complete code and specific re error information is available.
hence our approach performs a more structured comparison of the user s code with the socode snippets rather than using a bag of words model.
in recent work zhang et al.
propose a tool examplestack to guide developers in adapting code snippets from relevant so posts to their own codebase.
examplestack nicely complements our contribution of finding the relevant posts.
csnippex proposes an approach to make socode snippets compilable by adding missing imports and variable method and class declarations.
such a technique can make a larger fraction of socode analyzable by approaches such as ours.
nagy et al.
mine common error patterns in sql queries for potential use by sql developers.
sofix mines sotomanually extract a set of repair schemas for use in a generate and validate automatic program repair apr tool.
in both these works the aim is offline mining of sofor subsequent use in specialized use cases.
by contrast our problem is real time recommendation of relevant soposts on an instance specific basis.
qacrashfix uses error information in an android related crash bug to gather a population of relevant soposts and then uses the posts answer code snippets in a generate and validate apr approach to fix the bug.
unlike us here the core contribution is on the use of information in soposts for repair rather than the search for relevant posts.
code clone detection and code search.
syntactic code clone detection techniques detect syntactically similar code fragments i.e.
type clones by matching tokens such as ccfinder andsourcerercc or comparing asts such as deckard or using hybrid approaches such as nicad .
however as discussed in sections and empirically evaluated in section matching the developer s code with the socode snippet is not a typical syntactic code clone detection problem because of the degree of dissimilarity between the two.
semantic code clone detection i.e.
type clones match syntactically dissimilar but semantically equivalent code fragments.
prominent representatives include the work by white et al.
based on deep learning oreo which combines information retrieval machine learning and software metrics ccaligner which specializes in large gapped clones and facoy which uses a novel query alternation strategy leveraging natural language descriptions of code.
our problem is notsuitable for these techniques either since our problem instances do in fact possess structural similarity provided a technique can localize the exception triggering segments and suitably abstract away syntactic differences.
our technique is tailored to do precisely this.
code to code search engines such as aroma and krugle form another related body of work.
however since their purpose is code recommendation for the purpose of code completion or code enhancement they seek to find extensions or modifications of the query code rather than seeking to align the error producing scenarios of the two code segments as we do.
debugging patching and recovery for runtime errors.
our work is inspired by the body of research on remediation of runtime errors.
sinha et al.
proposed one of the earliest techniques for fault localization and repair of java runtime exceptions npefix proposes a generate and validate apr approach for null pointer exceptions npe vfix uses data and control flow analysis to prune the repair space for npes and generate more accurate repairs and genesis automatically extracts repair patterns specific to various exception types to use in an apr approach.
there is also interesting research on isolating and recovering from runtime errors .
the above techniques use program analysis as the basis for their remediation.
by contrast our work facilitates the use of crowd sourced knowledge available in online q a sites for this purpose and is therefore complementary to the above.
conclusion in this work we presented a technique and prototype tool called maestro to automatically recommend an sopost most relevant to a given java rein a developer s code.
specifically maestro returns the post best matching the exception generating program scenario in the developer s code.
to extract and compare the exception scenario maestro first uses the answer code snippets in a post to implicate relevant lines in the post s question code snippet and then compares these lines with the developer s code in terms of their respective abstract program graph apg representations.
the apg is a simplified and abstracted derivative of an ast that enables an effective high level semantic comparison while discarding lowlevel syntactic or semantic differences.
an evaluation of maestro on a benchmark of instances of java res extracted from the top java github projects showed that maestro can return a relevant sopost for of the exception instances compared to relevant posts returned in only instances by four competitor tools based on state of the art techniques.
further in a user experience study of maestro with java developers the participants judged maestro as reporting a highly relevant or somewhat relevant post in of the instances and in some cases even better than the one manually found by the participant.