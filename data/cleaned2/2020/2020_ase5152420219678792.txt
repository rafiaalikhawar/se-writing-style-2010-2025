qdiff differential testing of quantum software stacks jiyuan wang qian zhang guoqing harry xu miryung kim university of california los angeles ca united states fwangjiyuan zhangqian harryxu miryungg cs.ucla.edu abstract over the past few years several quantum software stacks qss have been developed in response to rapid hardware advances in quantum computing.
a qss includes a quantum programming language an optimizing compiler that translates a quantum algorithm written in a high level language into quantum gate instructions a quantum simulator that emulates these instructions on a classical device and a software controller that sends analog signals to a very expensive quantum hardware based on quantum circuits.
in comparison to traditional compilers and architecture simulators qsses are difficult to tests due to the probabilistic nature of results the lack of clear hardware specifications and quantum programming complexity.
this work devises a novel differential testing approach for qsses named qd iff with three major innovations we generate input programs to be tested via semantics preserving source to source transformation to explore program variants.
we speed up differential testing by filtering out quantum circuits that are not worthwhile to execute on quantum hardware by analyzing static characteristics such as a circuit depth 2gate operations gate error rates and t1 relaxation time.
we design an extensible equivalence checking mechanism via distribution comparison functions such as kolmogorov smirnov test and cross entropy.
we evaluate qd iffwith three widely used open source qsses qiskit from ibm cirq from google and pyquil from rigetti.
by running qd iffon both real hardware and quantum simulators we found several critical bugs revealing potential instabilities in these platforms.
qd iff s source transformation is effective in producing semantically equivalent yet not identical circuits i.e.
of trials and its filtering mechanism can speed up differential testing by .
i. i ntroduction quantum computing is an emerging computing paradigm that promises unique advantages over classical computing.
however quantum programming is challenging.
quantum computation logic is expressed in qubits and quantum gates and the states of quantum registers are measured probabilistically.
due to the physical properties of quantum mechanics qubits and quantum gates are fundamentally different from classical bits and gate logic.
for example quantum indeterminacy dictates that the same quantum program can produce different results in different executions.
to this end many quantum software stacks such as google s cirq rigetti s pyquil and ibm s qiskit have been developed to provide user friendly high level languages for quantum programming abstracting away the underlying physical and mathematical intricacies.a quantum software track qss includes apis and language constructs to express quantum algorithms a compiler that transforms and optimizes a given input quantum algorithm at the circuit level and a backend executor that either simulates the resulting gates on classical devices or executes directly on quantum hardware.
consider qiskit which consists of four components qiskitterra that compiles and optimizes programs qiskitaer that supports highperformance noisy simulations qiskitignis for error correction noise characterization and hardware verification and qiskitaqua that helps a developer to express a quantum algorithm or an application.
other qsses such as pyquil have a similar set of components e.g.
pyquil uses quilc as a compiler and qvm as a quantum simulator.
as with any compiler framework a qss could be errorprone.
developers and users often report bugs on popular qsses and a simple search on stackoverflow with the keyword quantum error would bring up over posts on various qss components ranging from compiler settings simulation and the actual hardware .
these posts often reveal deeper confusion that developers face due to the inherent probabilistic nature of quantum measurements if a program produces a result that looks different from what is expected is it due to a bug or the non determinism inherent in quantum programs?
is there divergence beyond expected noise coming from an input program a compiler a simulator and or hardware?
challenges.
there are three technical challenges that make it difficult to test qsses.
the first challenge is how to generate semantically equivalent programs for testing quantum compilers .
though existing compiler testing techniques generate equivalent programs by manipulating code in dead regions or unexecuted branches a quantum program usually does not have many unexecuted branches.
therefore we must design a technique that can produce a large number of semantically equivalent variant circuits that may induce divergence on hardware.
the second challenge is that compilers are not the only source of bugs in a qss.
for example in a line of recent work on verified quantum compilers compilers are guaranteed to be correct with respect to their optimization and transformation rules.
however the overall correctness of 36th ieee acm international conference on automated software engineering ase 36th ieee acm international conference on automated software engineering ase .
ieee .
ase51524.
.
.
ieee qsses goes beyond compiler optimization rules.
we must reason about subsequent execution on quantum simulators and hardware which are often the major sources of instabilities.
in fact rigetti or cirq s github histories indicate that bugs may come from its various backends due to improper initialization problematic apis or inappropriate synthesis options .
the third challenge is how to interpret measurements from quantum simulators or hardware since quantum measurement operations by definition are probabilistic in nature due to quantum indeterminacy .
therefore when we execute logically equivalent program variants comparing their measurement results is not straightforward as we must take into account inherent noise e.g.
hardware gate errors readout errors and decoherence errors and must determine whether the observed divergence is significant enough to be considered as a meaningful instability.
this work.
qd iffis a novel differential testing technique for qsses.
qd ifftakes as input a seed quantum program and reports potential bugs with a pair of witness programs i.e.
logically equivalent programs that are supposed to produce identical behavior but triggers divergent behavior on the target qss i.e.
meaningful instabilities beyond expected noise .
qd iffovercomes the aforementioned challenges with three technical innovations below.
first qd iffgenerates logically equivalent quantum programs using a set of equivalent gate transformation rules.
this is based on the insight that each quantum gate can be represented mathematically as a unitary matrix a sequence of gates essentially corresponds to the multiplication of their unitary matrices which also yields a unitary matrix.
as such one sequence of gates is semantically equivalent to another if the two sequences yield the same unitary matrix.
we leverage seven gate transformation rules to generate different gate sequences that are guaranteed to yield the same unitary matrix.
these sequences essentially define logically equivalent program variants that are supposed to yield identical behavior.
such variants are then executed on a simulator or hardware and their measurements are compared.
second with multiple logically equivalent variants generated after optimization qd iffselects a subset of those circuits that are worthwhile to run on a noisy simulator or quantum hardware.
this selection and filtering process is crucial for both speedup and potential cost saving because there are only a very few quantum hardware devices in the world and they are extremely expensive resources d wave s quantum computer is reported to be million in .
ibm qiskit allows public hardware access up to qubits but a higher number of qubit usage is strictly restricted.
noisy simulators are extremely compute intensive to run on classical computers as well taking on more than minutes to do measurements on a simple four qubit circuit.
this noisy simulation cost becomes extremely unmanageable with the higher number of qubits.
to achieve speed up qd iffanalyzes the static characteristicof logically equivalent circuits such as the circuit depth i.e.
moments the number of qubit gates the known error rates of each gate kind and t1 relaxation time for quantum hardware.
qd iffobviates the need of executing certain circuits on hardware or noisy simulators if the logically equivalent circuits are incapable of revealing meaningful instabilities in qss.
third in order to compare executions of logically equivalent circuits qd ifffirst identifies how many measurements are needed for reliable comparison.
based on the literature of distribution sampling qd iffadapts closeness testing in l1 norm to estimate the required number of measurements given confidence level p .
using either a noisy simulator or directly on hardware it then performs the required number of measurements.
to compare two sets of measurements qd iffuses distribution comparison methods.
two methods based on kolmogorov smirnov k s test and cross entropy are currently supported.
this comparison method is easily extensible in qd iff as a user can define a new statistical comparison method in qd iff.
results.
we evaluated qd iffwith the latest versions of three widely used qsses qiskit cirq and pyquil.
with six seed quantum algorithms qd iffgenerates variant algorithms through semantics modifying mutations.
starting from the generated algorithms it generates a total of program variants using semantics preserving source transformations.
this generation process took qd iff14 hours.
with the filtering mechanism qd iffreduces its testing time by .
using qd iff we determined total sources of instabilities.
these include software crash bugs in pyquil and cirq simulation and potential root causes that may explain out of cases of divergence beyond expected noise on ibm hardware.
the main contributions of this work include we present the first differential testing framework for qsses.
this framework is integrated with three widely used qsses from google ibm and rigetti.
we embody three technical innovations in qd iffto make differential testing fast and to increase the chance of finding meaningful instabilities beyond the usual expected noise auto generation of logically equivalent variants auto filtering of circuits that are worthwhile to run on hardware or a noisy simulator and pluggable methods of comparing measurements in terms of statistical distribution.
qd iffobviates the need of invoking quantum back ends by .
using qd iff we determined sources of instabilities in three widely used qsses crash bugs and root causes for divergences beyond expected noise on ibm hardware.
we provide access to the artifacts of qd iff at ii.
b ackground quantum computing.
quantum computing emerges as a promising technology for many domains where quantum computers have been demonstrated to outperform classical com693table i different layers that bugs appear layers percentage example compiler optimizations settings .
mergeinteractions returns different results for the same circuit .
backend simulators hardware .
simulators change a global random state on cirq .
api and quantum gate .
phasedxpowgate raised to a symbol power fails the is parameterized protocol .
puters by a large margin.
for example grover s algorithm can find a given item in an unsorted database with ap n times speedup when running on a quantum computer compared to a classical computer.
similar to programs executed on heterogeneous devices such as fpgas a quantum application is comprised of host code that runs on cpu and quantum code that runs on quantum hardware.
generally quantum computers work as accelerators to execute the compute intensive parts of the original application.
for example the shor algorithm can achieve an exponential speedup by decomposing integer factorization into a reduction to be executed on a classical computer and an order finding problem to be executed on quantum hardware.
quantum software stack.
currently three most widely used qsses are qiskit cirq and pyquil .
qiskit is an open source framework developed by ibm.
qiskit provides a software stack that is easy to use quantum computers and facilitates quantum computing research.
qiskit consists of qiskit terra compiler qiskit aer several quantum simulators qiskit ignis which supports error correction and noise characterization and qiskit aqua apis to help developers write applications .
cirq is an open source python framework from google.
it enables a developer to create and simulate noisy intermediate scale quantum nisq circuits.
cirq consists of an optimization component to compile and transform circuits a simulator component for emulating quantum computation on classical devices and other development libraries for application development.
pyquil is an open source python framework developed by rigetti.
it builds on quil an open quantum instruction language for near term quantum computers and uses a combined classical quantum memory model.
pyquil is the main component of forest the overarching platform for rigetti s quantum software.
pyquil consists of quilc compiler qvm quantum virtual machine with several kinds of simulators and pyquil a library to help users write and run quantum applications .
all three qsses are similar to one another in that each includes a quantum programming language an optimizing compiler that outputs quantum gate instructions a quantum simulator that emulates these instructions on a classical device and a software controller that executes gate instructions on quantum hardware.
quantum bit.
aquantum bit or qubit for short is the basic unit of quantum computation.
unlike a classical bit that is either 0or1 a qubit s state is a probabilistic function of j0iandj1i represented as j i j0i j1i wherej j2 j j2 the state of a qubit is unknown until a measurement is completed resulting in j j2to be andj j2to be .
naturally the sum of the probabilities i.e.
the modulus squared of amplitudes is j j2 j j2 .
quantum gate.
classical computers use logic gates to transform signals from input wires.
for example a not gate also known as an inverter takes a single signal as input and outputs the opposite value.
the quantum gate analogous to not is an xgate which transforms a qubit j0i j1ito j0i j1i.
anxgate has the following matrix based representation x using a vector to represent the quantum state j0i j1i applying an xgate has the following effect x other commonly used quantum gates include h t cnot z cz s u1 and u3 a full explanation of these gates is elsewhere .
since all quantum gates can be represented as matrices we can transform a sequence of gates to another logically equivalent sequence without altering its outcome as long as the multiplication of the matrices for gates in each sequence produces the same result.
as an example a swap gate a twoqubit gate that swaps the two qubits states is semantically equivalent to a sequence of three cnot gates.
swap q q2 cnot q q2 cnot q q1 cnot q q2 this observation forms the foundation of qd iff s program variant generation procedure detailed in section iv.
quantum circuit.
a quantum circuit consists of a set of connected quantum gates.
since quantum gates can be represented as unitary matrices a quantum circuit is essentially the multiplication of the matrices.
figure 1a shows a program in ibm s qiskit .
it first registers two qubits and initializes them to j0i.
next an h gate sets the first qubit into state1p 2j0i 1p 2j1iand an xgate flips the second qubit from j0itoj1i.
finally a measurement is performed and stored in a classical array.
the function returns this circuit as a function type value.
figure 1b shows host code that calls this quantum circuit.
users can execute this circuit on different backends such as real quantum hardware or simulators.
the circuit is executed onqasm simulator for a thousand times shots .
since the first qubit state is1p 2j0i 1p 2j1iand the second qubit state 6941def make circuit quantumcircuit qubit quantumregister qc bit classicalregister qm prog quantumcircuit qubit bit prog.h qubit prog.x qubit for iin range prog.measure qubit bit return prog a a quantum circuit with an hgate and an xgate.
prog make circuit backend basicaer.get backend qasm simulator info execute prog backend backend shots .
result .get counts b the host code using the circuit in a .
fig.
an example qiskit program.
isj1i each run produces a result of either j01i orj11i with the equal probability of 1p .
t1 relaxation time.
in quantum computing a qubit can retain data for only a limited amount of time referred to as relaxation time because a qubit in a high energy state state j1i naturally decays to a low energy state state j0i .
the time span for this decay is referred to as t1 relaxation time.
for a physical circuit its measurement results are unreliable if its execution time is longer than t1.
iii.
m otivation to understand real world qss bugs we collected latest issues reported on github pyquil cirq and qiskit.
after excluding issues related to installation and other tools we categorized the remaining issues by the layer where each issue appears compilers backends and apis.
table i summarizes the percentage of the corresponding layer and a representative example.
most bugs appear at the compiler level compiler optimizations and settings.
for example cirq produces incorrect circuits when using mergeinteractions .
the second most common bugs appear at the backend level simulators and hardware execution e.g.
the initial state is unexpectedly modified by the cirq simulator in .
the other issues are with respect to the api implementation of high level gates.
for example in cirq when cirq.phasedxpowgate is invoked with an input argument exponent invoking is parameterized on the resulting gate should return true but returns false due to a bug in cirq.phasedxpowgate.
the aforementioned bugs are hard to find due to quantum indeterminacy.
the following excerpt illustrates a concrete example of how one google tutorial user is confused whether a problem is a bug or due to inherent non determinism.
cirq s vqe variational quantum eigensolver tutorial had a mistake the orders of mix layer and cost layer were described in a wrong order.
the tutorial user d shortened posted a question on stackexchange with the embedded code from cirq s vqe tutorial.
a cirq developer c shortened noticed that the strange thing is the example output shows the output probabilities varying with gamma the cz parameter where fig.
qd iffoverview gamma should not have any effect on the measurement results.
dactually believed the disagreement is due to quantum indeterminacy until cexplicitly labeled it as a compiler bug.
key takeway.
this study of github issues shows that qss bugs are not just traditional compiler bugs and may come from various sources at different layers api implementation of high level gates backend simulators or hardware execution.
this problem of detecting qss bugs is further complicated by the probabilistic and noisy nature of quantum indeterminacy.
iv.
qd iffapproach qd iffcontains three novel components to detect meaningful instabilities in qsses.
figure shows program variant generation using equivalent gate transformation and mutations section iv a backend exploration leveraging selective invocation of quantum simulators and hardware section iv b and equivalence checking via distribution comparison section iv c .
starting from a seed program qd iffiterates these steps until a time limit is reached.
our key insight is that we can generate semantically equivalent but syntactically different circuits and we can speed up the differential execution process by filtering out certain circuits because they will definitely lead to unreliable divergence and thus are not worthwhile to run on hardware or noisy simulators.
a. program variant generation prior work finds that testing compilers with equivalent programs is highly effective.
qd iffadapts this idea to the domain of quantum compiler testing by creating logically equivalent gate sequences.
it then checks whether the corresponding equivalent circuits produce the same results in this case a similar statistical distribution with some noise on quantum simulators or hardware.
for this purpose qd iff generates program variants by repeating the two fold process ofapplying semantics preserving gate transformation to each generated program in each iteration and applying semanticsmodifying mutations to diversify the pool of input programs in the next iteration.
equivalent gate transformation egt .
as discussed earlier 695table ii explored compiler configurations framew ork options description basicswap lookaheadswap specify how swaps should be inserted to make the circuit compatible with the stochasticswap coupling map.
qd iffchecks if basicswap has the most swap gates.
qiskit optimization level specify the optimization level the higher the level the simpler the resulting circuit.
q diffchecks if a higher level optimization generates a more complex circuit.
dropemptymoment remo ve empty moments from a circuit.
qd iffchecks empty moments in the circuit.
cirq mergeinteractions mer ge adjacent gates qd iffchecks the applicability of g6 in table iii.
pointoptimizationsummary user defined optimization.
pragma initial rewiring f naive change the optimization mapping style greedy paritial g pyquil pragma fcommuting blocks change the optimization style for certain part of the code.
perserve blocksg table iii qd iffgenerates program variants based on egt rules g1 g7.
rule id original construct equivalent construct cno t q1 q2 g1 swap q q2 cnot q q1 cnot q q2 g2 h q1 h q merged to identity matrix g3 x q1 h q1 s q s q h q g4 z q1 s q1 s q g5 cz q q2 h q2 cnot q .q2 h q g6 cz q q2 cz q q2 merged to identity matrix g7 ccnot q q2 q3 cnot gates with one qubit gates in section ii one quantum gate sequence is semantically equivalent to another sequence if they both yield the same unitary matrix representation.
in fact complex quantum gates without altering the outcome can be described as a combination of basic quantum gates.
qd iffleverages seven gate transformation rules to map complex gates into sequences of simple gates as shown in table iii.
in g7 a toffoli gate i.e.ccnot can be replaced with cnot gates and one qubit gates.
to explore the alternative representation of a given gate sequence qd ifffinds the applicable transformation rules by matching the gate names.
for an example circuit s q2 z q1 qd iffidentifies the complex gate z q1 applies rule g2 to construct gate z q1 as a sequence s q1 s q1 and generates a final variant s q2 s q1 s q1 .
as opposed to an optimizing compiler that applies transformation rules to reduce the number gates or the total gate depth qd iff aims to diversify the pool of input programs through source to source transformation.
seed diversification via mutations.
while generation of logically equivalent programs can find bugs through observing disagreements they are unlikely to exercise various programming constructs.
to diversify the seed input programs and to explore hard to reach corner cases in quantum compilers.
qd iffborrows the idea of mutation based fuzz testing and designs a set of semantics modifying mutations.
after generating multiple logically equivalent programs in each iteration qd iffcalculates the average distributions among the equivalent programs as the reference distribution then picks the variant that leads to the largest comparison distance e.g.
k s distance from the reference distribution and randomly applies one of the following four mutation operations to the variant in order to generate a new algorithm.this is based on the insight that the program with the most deviating results has a higher chance to expose unseen behavior .
please note that these mutations do not preserve semantics instead the goal of mutations is to resume the next round of differential testing with a different algorithm.
we start with four mutation operators listed below used in quantum mutant generation .
gate insertion deletion m1 inserts deletes random quantum gates e.g.
insert prog.x qubit gate change m2 changes a quantum gate to another gate e.g.
from prog.x qubit toprog.h qubit gate swap m3 swaps two quantum gates qubit change m4 changes the qubits e.g.
from prog.x qubit toprog.x qubit .
b. quantum simulation and hardware execution compiler configuration exploration.
qd iffautomatically explores different compiler configurations.
in qiskit compiler settings can be specified by the arguments passed to the backends e.g.
users can apply optimization level to collapse adjacent gates via light weight optimization while optimization level does heavy weight optimization to resynthesize two qubit blocks in the circuit.
in cirq compiler settings must be specified using api invocations e.g.
users can write their own optimization with pointoptimizationsummary .
in pyquil compiler settings are specified using inlined pragmas similar to how fpga developers specify high level synthesis options using pre processor directives e.g.
a region denoted by pragma preserve block will not be modified by a compiler.
there are in total and configuration types for qiskit cirq and pyquil respectively as shown in table ii.
when executing a variant with a specific compiler setting qd iffrecords both thrown exceptions and program timeouts.
backend exploration.
backend exploration runs the same input program on different backends shown in table v. in terms of real hardware execution qd iffuses the free version of ibm hardware only because other platforms are currently proprietary.
qd iffis extensible by specifying a different backend configuration.
noisy simulators and state vector simulators are both included in qd iff s backend exploration.
filtering and selective invocation on hardware.
qd iff is focused on isolating software defects not hardware defects.
because hardware imperfections such as decoherence 696table iv ibm quantum hardware s gate level error rates gate time and t1 relaxation decoherence time.
ibm quantum computer t1 time s gate time ns qubit gate error rate tm 2qubit ibm santiago .
.
.
ibm yorktown .
.
.
ibm 16melbourne .
.
.
ibm belem .
.
.
ibem quito .
.
.
table v explored backends simulators and hardware framew ork back ends description statevector simulator noiseless sim.
qasm simulator noiseless sim.
qiskit fakesantiago fakeyorktown noisy sim.
fakemelbourne ibmq santiago ibmq yorktown quantum hardware ibmq 16 melbourne simulator noiseless noisy sim.
cirq densitymatrixsimulator noiseless noisy sim.
aspen x yq noisy qvm noisy sim.
pyquil wavefunctionsimulator noiseless sim.
aspen x yq qvm pyqvm noiseless sim.
is present it is important to filter out circuits that would invoke errors due to the inherent hardware limitations.
with the above observations qd ifffilters out unnecessary circuits in two steps.
first qd iffexamines the final gate sequences after all compiler optimizations and logical to physical mappings filtering out exactly identical physical circuits by moment bymoment comparison.
second qd iffanalyzes the static characteristics of circuits to remove those that certainly produce unreliable executions i.e.
results dominated by hardware level noise such as gate errors and relaxation errors and hence unreliable while leaving those that may produce meaningful divergences using definition iv .
.
as discussed in section ii for a physical circuit its measurement results are unreliable if its execution time is longer than t1 implying that the number of circuit moments nm the depth of the circuit in any circuit should not exceed a threshold tm.
moreover different kinds of quantum gates have different inherent error rates.
for publicly available ibm quantum computers error rates of single qubit operations are in the order of while error rates of qubit gate operations are in the order of .
a typical quantum program contains a significant number of qubit gates whose errors contribute the most to the overall error rate because such gates are more error prone than qubit gates .
taking this into consideration d2qubit the difference in the number of qubit gates from the original circuit should not exceed an application specific threshold 2qubit to avoid unreliable results.
leveraging the above observations we define the worthiness of invoking a quantum circuit.
definition iv .
.
a circuit is worth invoking on quantum hardware or noisy simulator if it satisfies the following condition nm tmandd2qubit 2qubit .
the threshold tmis determined empirically by two factors ibm computers average t1time and the average gate execution time for all gates as listed in table iv.
qd ifftable vi cumulative probability of ks test measur ement state cumulati ve state distrib ution pr obability a1 edf a1 .
a2 edf a2 .
computestmby dividing t1by the average gate execution time.
it then filters out those whose nmis greater than tm.
take ibm 16 melbourne as an example with t1 .
s and the average gate execution time 928ns tmis .
a circuit whose total number of moments is above is filtered out for ibm 16 melbourne.
the threshold 2qubit is determined in the following way.
suppose a user is willing to tolerate an addition error rate of t for the entire quantum program s final measurements with .
as the default .
using t we compute 2qubit as the maximum number of qubit gates to be added or deleted from the number of qubit gates in the original circuit.
suppose that cnot s error rate for this ibm computer is .
.
if cnot is usedd2qubit times in a row additionally its updated error rate would be by e d2qubit whereeis the original error rate.
since both eand d2qubit are relatively small we can regard the error rate change as d2qubit .
thereforejd2qubit 2qubitjshould be less thanlog t .
2qubit is whentis .
.
the above thresholds and filtering condition in definition iv .
are customizable according to hardware s published error rates supported gate types and t1 relaxation time.
c. equivalence checking via distribution comparison nondeterministic nature of quantum programs makes it difficult for equivalence checking.
developers usually reason about the output of a quantum circuit by executing it multiple times to obtain a distribution.
while numerous distribution comparison methods are well studied in statistics one consequent yet over looked question for quantum computing is that how many measurements do we need for a reliable evaluation to ensure the relative error between two distributions is within a given threshold twith confidence p?
we design a novel equivalence checking component which consists of a particular distribution comparison method c and an estimation of the required number of measurements for c given a threshold tand confidence p.qd iffis equipped with k s test and cross entropy but is also extensible to other comparison methods by providing a new comparison specific measurement estimation.
k s test has been used to check the equality of distributions by measuring the largest vertical distance between empirical distribution functions edfs in two steps.
first 6971backend basicaer.get backend qasm simulator 2info execute prog backend backend shots .result .get counts result f 549g a quantum simulator.
1backend basicaer.get backend statevector simulator 2info execute prog backend backend .result .
get statevector result b state vector simulator.
fig.
a quantum circuit in qiskit with two backends quantum simulator and state vector simulator.
it creates the edf for a given distribution by calculating the cumulative probability of different outcome states with respect to the total number of samples.
in table vi a1and a2are two state distributions for samples.
a1has samples in state while samples in state .
thus the consequent edf a1indicates that the cumulative probability ofa1samples in state and state are .
and respectively.
next k s test calculates the largest distance dof edfs for each state and uses such distance to quantify the difference of the original distributions under comparison.
in table vi the largest distance is .
j0 500j for state .
qd iffevaluates this k s distance with a user defined thresholdt.
if the k s distance of two results is less than t qd iffregards them as similar results.
qd iffprovides a statistical guarantee on this comparison by estimating the required number of samples.
for two distributions d1andd2 overmoutcome states prior work theoretically ensures that withn m1 t samples a sample optimal tester can check if the relative error of l1distance is within a thresholdtwhen using a default confidence level of p .
qd iffestimatesnusing equation .
this estimated number is directly applicable to qd iffbecause k s distance is bounded byl1distance .
in other words equation calculates the number of measurements required parameterized with respect top.
we empirically set pas as it is a commonly used default in quantum volume measurement bioinformatics and other statistics comparison.
n a 1p1 p m1 t whereais a platform related constant and mis the number of qubit states.
in figure measurement samples are needed when we empirically set t p and a 12for qiskit.
in our evaluation we empirically measure the constantafor each platform by repeatedly running the same programs and compare the results.
cross entropy measures the difference between distributions via the total entropy.
it represents the average number of bits needed to encode data coming from an underlying distribution q1when we use an estimated target distribution q2.h q1 q2 maxx x 0q1 x logq2 x prior work ensures that with n m2 t samples the expected cross entropy of two similar distributions over moutcome states can be bounded with t .tis the difference from h q1 q1 .
similar to k s test qd iffestimates the number of required samples to reliably satisfy this bound as shown in equation .
n a 1p1 p m2 t for figure we need measurements with t p and a for qiskit.
this measurement trials are different from k s test because we are using different distance metrics.
comparison with reference distribution.
after generating a group of equivalent programs and filtering out worthless circuits qd iffexecutes the remaining circuits and calculates the average distribution from their results.
qd iffwill regard this average distribution as the reference distribution.
with the distribution comparison methods eg.
k s test cross entropy etc qd iffcompares this reference distribution with each result distribution and reports divergence when the distance is larger than the threshold t. reporting divergence explanation.
qd iffreports the potential source of the divergence in program p ifpfinds divergence when using different backends while keeping a frontend s options unchanged qd iff reports this as a potential backend source ifpfinds divergence when using a specific backend while varying a frontend s options qd iffreports this as a potential frontend source otherwise qd iffreports this as other sources such as a potential bug in the api gate implementation.
v. e valuation we evaluate following research questions rq1 how many syntactically different programs can be generated by qd iff s mutation and equivalent gate transformation?
rq2 how much speedup can we achieve via filtering and obviating the need of invoking a quantum simulator or hardware?
rq3 what has qd ifffound via differential testing of the widely used qsses?
benchmarks.
qd iffstarts differential testing with five well known quantum algorithms as seed programs deutsch jozsa berstein vazira vqe variationalquantum eigensolver grover and qaoa quantum approximate optimization algorithm and one additional program x gate listed in table vii.
we do not use the relatively large algorithms like shor s because ibm s public access can support up to qubits only.
large algorithms also require 698p1 p2 p3 p4 p5 p60100200300 variants variants created via mutations circuits total number of circuits a t otal circuits and variants originating from each seed algorithm p1 p2 p3 p4 p5 p60 circuits worthwhile to run circuits worthwhile to run t ime saving hours t ime saving hours b the percentage of circuits that are worth running fig .
statistics of qd iff generated circuits.
many moments and qubit gates often producing unreliable results on quantum hardware.
experimental environment.
we evaluate qd iffwith three widely used qsses pyquil .
.
with quilc .
.
qiksit .
.
and cirq .
.
.
we run the circuits on five different hardware versions based on their availability including ibmq santiago ibmq yorktown ibmq 16 melbourne ibmq belem.
and ibmq quito.
the details of hardware can be found on ibm s quantum computing website .
we use k s test with t as the distribution comparison method.
a. rq1 variant generation via s2s transformation as shown in figure 4a for all six seed algorithms together qd iffgenerates program variants through semanticsmodifying mutations and generates the total of circuits with equivalent gate transformation to each generated variant.
this total circuit generation process takes around hours.
take p2 deutsch jozsa algorithm as an example.
different program variants are generated through semanticsmodifying mutations.
for each variant program qd iffgenerates logically equivalent circuits.
for p2 the total generation for circuits takes around hours while the rest of differential execution via simulation or hardware execution takes around days.
this implies that the bottleneck of testing is not about input program generation but the execution of the generated programs which justifies our approach to select which circuits are worthwhile to run.
b. rq2 speed up as shown in figure 4b after filtering only of the generated circuits are retained for differential execution on quantum hardware leading to a reductions in quantum hardware or noisy simulator invocations.
qd ifffinishes the entire testing process within around days by leveraging its circuit selection process which means qd iffwould have saved additional days of testing time by filtering.
take qaoa as an example when running on ibm quantum hardware the experiment would take around minutes top1 p2 p3 p4 p5 p601 generated circuits total circuits divergences on hw circuits producing divergences fig .
circuits producing divergences on ibm hardware 1qc get qc aspen 3qa qvm 2result rm qc.
run and measure p a run and measure measures all qubits in device aspen when a simulator allocates qubits resulting in an exception.1p program x x .
controlled 2qvm pyqvm n qubits 3qvm.execute p b controlled x gate raises an error when qubits are allocated for simulation.
fig.
bugs in pyquil found by qd iff.
wait in line on average as launching a quantum job uses a shared web service for a few ibm computers in the world and seconds to execute on hardware.
if users run all circuits the total clock time would be days.
with filtering qd iffremoves circuits that are not worthwhile to run and finishes the execution in days.
c. rq3 what has qd ifffound?
from the sets of semantically equivalent circuits qd iff found differing outcomes out of .
out of are crashes in simulators.
the remaining cases are divergence beyond expected noise on ibm hardware.
by inspecting all cases carefully we determined total sources of instabilities simulator crashes and potential root causes that may explain out of cases of divergence on ibm hardware.
for the remaining divergence cases we could not easily determine their underlying root causes.
crash bugs in simulators qd iffreports four crashes during differential testing with both noiseless and noisy simulators.
all divergences involve clear failure signals.
all are due to bugs in compiler or simulator implementations summarized in table viii.
out of crashes were already reported by developers and out of crashes were confirmed by developers when we filed crash reports .
compiler option error given an arbitrary program in cirq when the compiler option clear span is set to a negative number or clear qubits is set to an unregistered qubit the execution does not terminate.
cirq does not check the boundary values of compiler options and attempts to reset nonexisting qubits.
this bug was detected during explorations of compiler settings.
when these compiler options are set to the aforementioned values qd iffnotices that the execution does not finish in a reasonable time indicating a potential infinite loop.
qd ifffound this bug on the 74thiteration with p3.
backend registers a wrong number of qubits qd ifffound that pyquil s measurement crashed on aspen xq a qvm.
699table vii seed subject programs id program of qubits moments qubit gate description iteration number measurement trial with t p1 x gate one qubitxgate p2 deutsch jozsa check if a function is balanced p3 bernstein vazira find a and b for f x ax b p4 grover find a unique input in a database p5 vqe approximate the lowest energy level p6 qaoa qaoa algorithm table viii bugs found by qd iffwhen executing generated programs with simulation only platf orm bugs description sour ce of bugs cir q program runs endlessly with some compiler settings compiler setting pyquilsimulator register wrong number of qubits simulator backends crashes on control gates on certain backends gate implementation simulator stuck into a bad state simulator backends in pyquil users can specify the quantum simulator to have the same topology as a real qubit device aspen 16q a by setting the backend to be aspen 16q a qvm 16q refers to using qubits in simulation .
however qd ifffound that when a user allocates to use qubits in simulation line in figure 6a but attempts to conduct measurements at line using run and measure pyquil simulator crashes due to a wrong number of allocated qubits.
this bug was found with qd iff s backend exploration.
another user reported the same issue on pyquil s github .
simulator is stuck into a bad state pyquil s simulator raises an exception when taking an empty circuit as input.
afterward all subsequent invocations to the simulator crash even when the input circuit is valid and not empty.
qd iffdetects this bug by mutating an input program to an empty program and executing it on both pyqvm simulator and state vector simulator.
while the state vector simulator runs this empty circuit normally pyqvm throws an exception.
then qd iff generates an arbitrary non empty program.
in the next few iterations qd ifffinds this bug because pyqvm crashes while the state vector simulator does not.
wrong type of the controlled gate figure 6b shows a scenario where pyquil crashed when a control xgate was used on pyqvm with qubit allocation.
the exception message shows valueerror cannot reshape array of size into shape .
a control xgate should be a qubit gate which is matrix but the gate was represented as bypyqvm which is a bug.
this bug was found in the 15thiteration with p1 as a seed.
divergences on real hardware figure reports the total numbers of circuits executed on quantum hardware and those that exhibit behavioral divergence.
the rate of latter is relatively low .
.
which demonstrates the robustness of the quantum software and hardware we tested this is not surprising since such software and hardware has been widely used and continuously improved for a number of years.
on the other hand these results also highlight the need of a systematic testing framework such as qd ifffor quantum developers since quantum bugs are rare and hard to detect developers should test their programs tools exhaustively with aqd iff like approach before releasing them.l0 qc0 ...r z p x x ...l1 qc1 r z 5pi l2 qc3 x x l3 qc4 a di vergent circuits l0 qc0 ...r z p x x ...l1 qc3 r z 5pi x x l2 qc1 x l3 qc4 x b good circuits fig .
divergence on ibm ibmq yorktown no operation on qc4 for a long time.
l0 qc3p xr z pi x ...l1 qc2p xr z 3pi x l2 qc1p xr z l3 qc0p xr z pi a di vergent circuits cx between physical qubits and l0 qc2p xr z 3pi ...l1 qc1p xr z pi x l2 qc0p xr z l3 qc3p xr z pi b good circuits cx between physical qubits and fig .
divergence detected on ibm hardware bad connection between qc and qc .
for divergence cases on ibm hardware we manually inspected the corresponding circuits.
we then determined root causes that may explain out of cases.
for the remaining cases we could not easily determine underlying root causes.
we discuss each root cause with examples in this subsection.
divergence due to qubit gate errors we concluded that and divergences in p1 p3 p5 and p6 respectively of all divergences detected on hardware in total can be explained by placing many qubit gates between so called couplers qubits.
ibm released the reliability of connection between each qubit pair on their hardware .
for example in hardware santiago mapping cx between physical qubits f2 3g is less reliable than mapping cx between qubitsf1 2g .
we found out of divergences could have the same underlying cause of using cx between known unreliable 700qubit connections.
these errors could be reduced through improved mapping to qubit gates or using other strategies such as randomized compilation .
consider the two equivalent circuits shown in figure generated from p6 qaoa.
these two circuits generated divergent measurements on santiago although both circuits have nearly the same moments and the same number of 2qubit gates.
this is because the cx error rate of physical qubits and is much higher than qubits and higher according to published information from ibm .
it appears that qiskit s logical to physical qubit mapping procedure does not always avoid the use of cx on qubits and in their compilation and qubit allocation steps.
thus figure 8a produces divergence from figure 8b.
divergence due to qubit dephasing decoherence of divergences and divergences in p2 p4 p5 and p6 could have the same underlying cause of qubit dephasing decoherence.
qubits that remain idle for long periods tend to dephase and decohere .
figure shows a pair of circuits with a similar depth and a similar number of 2qubit gates.
however when run on hardware ibm belem the pair produces divergences beyond expected noise.
we speculate that when no operation is applied to physical qubit for moments it may increase dephasing and decoherence possibilities.
this can by fixed by adding two successive pauli y gates on idle qubits during the compilation phase .
others for other divergence we could not easily determine underlying root causes.
because the circuit moments and the number of cx gate are roughly the same with their equivalent groups stochastic errors in hardware can mostly be ruled out.
the problem could be low level quantum control software bugs that emerge from different combinations of gates resulting in different control coherent errors introduced at the pulse level.
d. threats to validity lack of error correction the number of divergences on quantum hardware found by qd iffwould depend on the reliability of hardware and its error correction capability.
if it were to run on an error corrected quantum hardware which does not exist yet it may report fewer divergences and it would be easier to disambiguate whether divergences are caused by software level defects as opposed to hardware level defects.
similarly qubit gate errors depend on which qubit connections that the gates are applied to therefore it may be necessary to adjust the divergence threshold tbased on the empirical qubit error rates for each connection and how many times the qubit gates are used on that connection.
such impact of qubit error rates must be investigated further.
time out in fuzz testing longer experimentation periods tend to expose more errors or new program execution paths .
the total time taken for all our experiments was limited to seven days.
number of qubits the maximum number of qubits that we used for our experiment was qubits because the onlypublicly available hardware limits public access up to qubits and the waiting time tends to increase significantly as you request more qubits.
running experiments on google s sycamore processor with qubits and 2q gates may produce different results .
vi.
r elated work compiler and framework testing.
random differential testing rdt is a widely used technique that compiles the same input program with two or more compilers that implement the same specification.
equivalence modulo inputs emi is such an example that tests compilers by generating equivalent variants.
many random program generators are used for compiler testing .
csmith randomly generates c programs and checks for inconsistent behaviors via differential testing.
quest focuses on argument passing and value returning while testing with randomly generated programs.
different from csimth like tools refactoring based testing systematically modifies input programs with refactorings as opposed to random program generation.
orion adapts emi to test gcc and llvm compilers.
christopher et al.
combine random differential testing and emi based testing to test opencl compilers.
orison uses a guided mutation strategy for the same purpose.
such classical compiler testing is not directly applicable to quantum software stacks due to the three challenges how to generate variants how to test simulators and hardware together with compilers and how to interpret quantum measurements for differential testing.
quantum testing and verification.
zhao introduces a quantum software life cycle and lists the challenges and opportunities we face.
ying et al.
formally reason about quantum circuits by representing qubits and gates using matrix valued boolean expressions and verify them using a combination of classical logical reasoning and complex matrix operations.
huang et al.
introduce quantum program assertions allowing programmers to decide if a quantum state matches its expected value.
they define a logic to provides robustness to characterize the possible distance between an ideal program and an erroneous one.
proq is a runtime assertion framework for testing and debugging quantum programs.
it transforms hardware constraints to executable versions for measurement restricted quantum computers.
qpmc applies classical model checking on quantum programs based on quantum markov chain.
ali et al.
propose a new testing metric called quantum input output coverage a test generation strategy and two new test oracles for testing quantum programs.
two test oracles include wrong output oracle that checks whether a wrong output has been returned and output probability oracle that checks whether the quantum program returns an expected output with its corresponding expected probability.
however their work targets at quantum program testing and the measurement they used might not be sufficient enough.
while all these techniques find errors in quantum programs qd iffaims to find errors in quantum software stacks.
701verified quantum compilers guarantee gate transformation and circuit optimization is correct by construction.
certiq is a verified qiskit compiler by introducing a calculus of quantum circuit equivalence to check the correctness of compiler transformation.
voqc provides a verified optimizer for quantum circuits by adapting compcert to the quantum setting.
smith and thornton present a compiler with builtin translation validation via qmdd equivalence checking.
as discussed in section i these tools ensure correctness in quantum gate optimizations.
however qd iffis a complimentary technique based on testing and its scope includes both quantum backends and frontends.
differential testing.
differential testing has been used to test large software systems and to find bugs in various domains such as ssl tls machine learning applications jvm and clones etc.
mucerts applies differential testing to check the correctness of certificate validation in ssl tls.
it uses a stochastic sampling algorithm to drive its input generation while tracking the program coverage.
dlfuzz does fuzz testing of deep learning systems to expose incorrect behaviors.
chen et al.
perform differential testing of jvm with input generated from markov chain monte carlo sampling with domain specific mutations with the knowledge of java class file formats.
mutation based fuzz testing.
fuzz testing mutates the seed inputs through a fuzzer to maximize a specific guidance metric such as branch coverage.
it has been shown to be highly effective in revealing a diverse set of bugs including correctness bugs security vulnerabilities and performance bugs .
for example afl mutates a seed input to discover previously unseen coverage profiles.
memlock employs both coverage and memory consumption metrics to find abnormal memory behavior.
instead of flipping several bits or bytes in each mutation several techniques support domain specific mutations.
sdf uses seed properties to guide mutation in webbrowser fuzz testing.
bigfuzz designs mutations for dataflow based big data applications.
qd iffis similar to this line of work by adapting mutation testing to a new domain.
however different from traditional fuzzing qd iffre invents the notion of a test oracle by re designing a quantum measurement comparison method in a noisy probabilistic domain.
vii.
c onclusion quantum computing has emerged to be a promising computing paradigm with remarkable advantages over classical computing.
qd iffis the first to reinvent differential testing for quantum software stacks.
it adapts the notion of equivalence checking to the quantum domain redesigns underlying program generation and mutation methods and optimizes differential testing to reduce compute intensive simulation or expensive hardware invocation.
it is effective in generating variants reduce unnecessary quantum hardware or noisy simulator invocations and uses divergence to isolate errors in both the higher and lower levels of the quantum software stack.viii.
a cknowledgment we would like to thank the anonymous reviewers for their valuable feedback.
we thank alan ho for his kind help in selective invocation and distribution comparison and for proofreading the draft.
this work is supported in part by national science foundations via grants cns cns1763172 cns cns cns cns2106838 cns chs ccf ccf1723773 onr grant n00014 and intel capa grant.