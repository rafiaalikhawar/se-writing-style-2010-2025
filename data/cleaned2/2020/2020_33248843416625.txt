towards generating thread safe classes automatically haichi wang wanghaichi tju.edu.cn college of intelligence and computing tianjin university chinazan wang wangzan tju.edu.cn college of intelligence and computing tianjin university chinajun sun junsun smu.edu.sg school of information systems singapore management university singapore shuang liu shuang.liu tju.edu.cn college of intelligence and computing tianjin university chinaa yesha sadiq ayesha.sadiq monash.edu monash university australiay uan fang li yuanfang.li monash.edu monash university australia abstract the existing concurrency model for java or c requires programmers to design and implement thread safe classes by explicitly acquiring locks and releasing locks.
such a model is error prone and is the reason for many concurrency bugs.
while there are alternative models like transactional memory manually writing locks remains prevalent in practice.
in this work we propose autolock which aims to solve the problem by fully automatically generating threadsafe classes.
given a class which is assumed to be correct with sequential clients autolock automatically generates a thread safe class which is linearizable and does it in a way without requiring a specification of the class.
autolock takes three steps inferaccess annotations i.e.
abstract information on how variables are accessed and aliased synthesize a locking policy based on the access annotations and consistently implement the locking policy.
autolock has been evaluated on a set of benchmark programs and the results show that autolock generates thread safe classes effectively and could have prevented existing concurrency bugs.
ccs concepts software and its engineering software maintenance tools keywords concurrency thread safe class locking policy acm reference format haichi wang zan wang jun sun shuang liu a yesha sadiq and y uan fang li.
.
towards generating thread safe classes automatically.
in 35th ieee acm international conference on automated software engineering ase september virtual event australia.
acm new y ork ny usa 13pages.
shuang liu is the corresponding author.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
ase september virtual event australia association for computing machinery.
acm isbn .
.
.
.
introduction concurrent programs are prevalent these days due to the pervasive availability of multi core and many core systems.
concurrency bugs are undesirable outcomes that arise when two programs execute concurrently but do not show up if execute sequentially.
they are notoriously hard to detect and fix.
existing research mostly focuses on bug detection e.g.
for data races deadlocks and atomicity bugs .
recently there have been studies explore to automatically fix concurrency bugs .
while the studies have shown impressive performance in some cases they do not address the fundamental problem which is to develop techniques that are capable ofpreventing concurrency bugs systematically in the first place.
the existing concurrency model for java requires programmers to design and implement thread safe classes based on synchronization primitives like acquiring locks and releasing locks.
such a model is error prone and is the reason for many concurrency bugs.
in theory a programmer should know precisely what specification a thread safe class should satisfy and above all make sure the program works correctly in a sequential environment.
afterwards the programmer needs to derive a locking policy which systematically guarantees that the specification is satisfied when the program is used in a concurrent environment and finally consistently implements thelocking policy throughout the program.
this process however isoften flawed in practice.
first of all it is impractical to assumethe availability of a full specification.
there have been multipleattempts on getting programmers to write specifications and yet specifications are scarce in practice.
second systematically deriving a locking policy requires information on how variables are accessed which could be complicated due to complications like aliasing and instance escaping.
lastly consistently implementing a locking policy takes good discipline as well as systematic tracking of where and how variables are accessed.
there have been proposals on alternative concurrency models which aim to solve the problem e.g.
transactional memories and yet the java model remains very much relevant in practice.
in this work we aim to prevent concurrency bugs by fully automating the process of generating thread safe classes from sequentialprograms.
that is given a class which is assumed to be correct in a sequential environment we automatically generate a thread safe class and do it in a way without requiring a specification of the class.
our approach takes three main steps infer access annotations through static analysis synthesize a locking policy based on the 35th ieee acm international conference on automated software engineering ase ase september virtual event australia wang et al.
access annotations and consistently and automatically implement the locking policy.
furthermore we optimize the generated class safely without breaking linearizability by reducing the scope of locking.
for correctness we prove that the generated class is linearizable modulo some assumptions to the sequential class and is always deadlock free.
our approach is implemented as a self contained toolkit called autolock for java programs and empirically evaluated on a set of benchmark programs with a total of lines .
autolock is evaluated to show that it could have been applied to preventknown concurrency bugs.
furthermore autolock is efficient i.e.
on average it takes only .
seconds to generate a thread safe class.
in addition for data structures from the java development kit we compare the thread safe versions generated by our approach with the ones crafted by experts of domain to show that our generated versions are reasonably efficient and provably correct .
the rest of the paper is organized as follows.
section 2defines the research problem.
section 3presents an overview of our autolock method.
section 4describes the access annotation inference approach.
section 5and section 6present our approach on inferring and implementing a locking policy based on the inferred access annotations.
section 7discusses the evaluation of the proposed technique for realistic java programs.
section 8reviews related work.
finally we conclude the proposed technique in section .
problem definition we assume that the user provided sequential class is in the form of a tuplep var pubm prim wherevar is a finite set of mutable variables pubm is a finite set of public methods and prim is a finite set of private methods.
each method mtakes an optional sequence of input parameters possibly updates the variables in the class and produces certain output.
note that we assume that variables are only accessed through methods.
a method invocation by a thread tis written as inv x m a t wherexis the name of an object of class p mis the method name a is an optional list of parameter values and tis a thread identifier.
a response to a method invocation is written asres x m o t whereois the returned value.
a method invocation and a response match if and only if their object names agree their method signatures agree and their thread identifiers agree.
when it is clear from the context we omit xto save space.
without loss of generality we assume that pis sequentially correct with respect to a specification s i.e.
a single thread which calls any public method in the class through any object of pin arbitrary order always satisfies the specification s. ideally given a sequential program pand its specification s which is satisfied byp we aim to construct automatically a program qsuch that q is thread safe with respect to s. that is multiple threads can call any public method in qthrough an object of qconcurrently and sis always satisfied.
as discussed above it is often infeasible to obtainsin practice.
in this work we do not assume that sis known and instead aim to generate qsuch that it satisfies three desirable properties linearzability deadlock freeness and efficiency.
in the following we formalize our assumptions and then define the correctness requirements.
without loss of generality we focus on a single object obj of the class p. a history of method invocationsonobj is a finite sequence of events angbracketlefte1 e2 en angbracketrightwhereeiis either a method invocation or a response.
is sequential if it starts with an invocation and every invocation is followed immediately with the matching response or the invocation is the last event .
otherwise we say it is concurrent.
a sequential history has no real concurrency since the methods execution never overlaps.
we say that is deadlock free if every invocation in can be followed by a matching response eventually.
our assumptions are as follows.
for every sequential history ofp satisfiessand is deadlock free.
given an arbitrary sequential or otherwise history we write harpoonuprighttwheretis a thread identifier to be the projection of ont i.e.
all those invocation and response concerning thread tare removed.
the following defines a correctness criterion for concurrent programs which is widely adopted in the community .
definition .
linearizability .
given two programs pandq which share the same set of public methods we say qis linearizable with respect to pif and only if for all history angbracketlefte1 e2 en angbracketright ofq there exists a sequential history primeofpsuch that harpoonuprightt prime harpoonuprighttfor all threads t and res m o t precedesinv m prime a t prime in primeonly if res m o t precedesinv m prime a t prime in .
intuitively a history is linearizable if from each thread s point of view each method invocation behaves as if it is executed immediately.
we say that qis linearizable to piff every history of qis linearizable to some sequential history of p. intuitively since by assumption any sequential history of psatisfies the specification q always satisfies s ifsis preserved by linearizability .
deadlock freeness is another desirable property of concurrent programs i.e.
a history of qis always deadlock free.
we thus aim to generate qwhich is always deadlock free.
furthermore it is insufficient to require only thread safety or deadlock freeness which can be achieved trivially by having a universal lock which is acquired at the beginning of every public method and released only after the method completes.
thus we further require that qideally should be as efficient as possible so long as it is still thread safe.
our problem definition is thus as follows.
given a program p which satisfies the above mentioned assumptions synthesize a programqsuch that qis linearizable with respect to p qis deadlock free qis reasonably efficient.
note that the last requirement on efficiency is kept vague for now and we shall formalize it properly in section .
the primary means of synthesizing qis to refactor pwith an implementation of a consistent locking policy.
intuitively a locking policy specifies how each instance variable in var is protected.
definition .
locking policy .
a locking policy is a function var lck wherelck is a finite set of locks i.e.
objects and is a special lock denoting no locking.
intuitively assuming lpis a locking policy lp x lmeans that variablexis guarded by lock l. for efficiency we assume that when a lock is acquired we have the option of acquiring it for either reading or writing.
note that multiple threads can obtain the same lock for reading whereas writing is exclusive i.e.
a lock acquired for writing can succeed if and only if there are currently no threads which hold the lock for reading or writing.
there are existing implementations for such locks like readwritelock in java.
we write lock l r to 944t owards generating thread safe classes automatically ase september virtual event australia input programannotated programthread safe program1access annotations generation metadata extractiongraph construction data flowsimply aliasing analysiscontext information2 graph traversal3 1locking policy generation ast based traversalv p construction variable set permission set2 infer lock3 apply lock4 figure overall algorithm.
denote that lock lis acquired for reading and lock l w to denote that locklis acquired for writing.
high level overview the high level idea of autolock is to automatically synthesize a locking policy based on static analysis of p and then consistently implement the locking policy to produce qas the result.
the overall workflow is shown in figure .
first we perform static analysis of the source code i.e.
based on data flow and alias flow analysis to obtain the permission based access annotations for methods in a class.
intuitively speaking a permission based access annotation abstracts how variables are accessed and how methods manipulate them.
next we synthesize a locking policy based on the access annotations.
afterwards the locking policy is systematically implemented through program re factoring.
note that the implementation is optimized for efficiency and deadlock freeness.
in the following we walk through each step using an illustrative example.
figure 2shows partly a java class named ratepath which is from the grande benchmark .
the class contains multiple instance variables and it is meant to be thread safe.
note that the comments and statements are introduced automatically by autolock.
this example is interesting for the following reasons.
first it has lines of code excluding those in the super classes orinterfaces instance variables and methods all of which are public .
note that only a minimum part of the class is shown due to the space constraint.
second there are file io operations e.g.
at the beginning of the method in lines which are time consuming in multiple methods which means that simply synchronizing every method would not be efficient.
step generate access annotations.
in this step static analysis is performed to systematically identify the access annotations for each variable and each method.
access annotations are associated with each variable in vand each method in pubm andprim .f o r instance variable pathv alue is associated with an annotation shared which means that the object can be potentially updated by multiple threads at the same time.
for another instance method readratesfile is associated with the annotations shown at line which intuitively means that the method writes variable pathvalue pathdate and nacceptedpathvalue.
the annotation at line states that the three variables pathv alue pathdate and nacceptedpathv alue are related which intuitively means their values are constrained to satisfy certain conditions according to the specification s. note that access annotations characterize the way a shared resource can be accessed by multiple threads and thus can be used to infer a safe parallel execution order of different program parts.
for instance a variable annotated immutable is thread safe and thus allows maximum parallelism and two methods can be executed in parallel if the variables they access do not overlap.step generate locking policy.
in this step we synthesize a locking policy based on the access annotations.
in the illustrative exam ple 3mutable instance variables are shown i.e.
pathvalue pathdate and nacceptedpathvalue.
a locking policy assigns a lock for each and every mutable variable in the class.
by default differ ent mutable variables are guarded by different locks for better ef ficiency unless multiple variables are annotated related and thus must be guarded by the same lock.
for instance because pathv alue pathdate and nacceptedpathvalue are related they are assigned with the same lock.
the resultant locking policy is documented in the form of annotations at lines and where nacceptedpathv alue pathdate pathv aluelock is a freshly declared lock.
step implement locking policy.
in this step we implement the locking policy consistently throughout the class by automatic program re factoring.
for each method we examine the access annotations and acquire the respective locks according to the locking policy.
we decide where exactly to acquire the locks based on two considerations.
first the scope of the locks should be minimized to improve efficiency.
second there should be no lock ordering deadlocks.
for the latter the locks are always acquired in a fixed globalordering throughout the class in an ascending order alphabetically based on the names .
for the former a lock is acquired as late aspossible except that it must be before the variable to guarded is accessed while not breaking the global ordering for acquiring locks.
for instance the first access to the three variables is a write access topathv alue at line 25and thus the corresponding lock nacceptedpathv alue pathdate pathv aluelock is acquired immediately.
note that this excludes the expensive file io operations from the synchronized block and thus improves efficiency.
the last access to the three variables is at line and thus the lock is released as soon as possibleat line .
note that we sometimes use finally e.g.
line to to make sure all locks are always released before the method ends in the presence of potential exceptions.
we similarly implement the same locking in method getpathvalue where the lock is acquired for reading since this is a getter method.
the resultant ratepath class is guaranteed to be thread safe.
for instance variable pathv alue is systematically protected by lock nacceptedpathv alue pathdate pathv aluelock in the class.
in particular as shown in figure the lock is acquired for writing at line and released only at line in function add and acquired for reading at line .
we remark that multiple threads may execute methodgetpathvalue at the same time whilst only one thread can execute line to line at any time.
inferring access annotations in this section we show what access annotations are used in our approach and how they are generated automatically.
945ase september virtual event australia wang et al.
1class ratepath extends pathid related pathvalue pathdate nacceptedpathvalue shared guardedby nacceptedpathvalue pathdate pathvaluelock private double pathvalue shared guardedby nacceptedpathvalue pathdate pathvaluelock private int pathdate shared guardedby nacceptedpathvalue pathdate pathvaluelock private int nacceptedpathvalue write pathvalue write pathdate write nacceptedpathvalue private void readratesfile string dirname string filename throws demoexception file ratesfile new file dirname filename bufferedreader in if !ratesfile.canread throw new demoexception cannot read the file ratesfile.tostring try in new bufferedreader new filereader ratesfile catch filenotfoundexception fnfex throw new demoexception fnfex.tostring int iline initnlines nlines string aline vector alllines new vector initnlines try while aline in.readline !
null iline alllines.addelement aline catch ioexception ioex throw new demoexception problem from file ioex.tostring nlines iline nacceptedpathvalue pathdate pathvaluelock.writelock .lock this.pathvalue new double this.pathdate new int nacceptedpathvalue iline nacceptedpathvalue iline setname ratesfile.getname setstartdate pathdate setenddate pathdate nacceptedpathvalue pathdate pathvaluelock.writelock .unlock setdtime double .
.
read pathvalue public double getpathvalue int index try nacceptedpathvalue pathdate pathvaluelock.readlock .lock return pathvalue finally nacceptedpathvalue pathdate pathvaluelock.readlock .unlock figure an illustrative example .
access annotations our annotations are inspired by existing research on access permissions .
access permissions are abstract capabilities that model the mutability and aliasing of a referenced object at one place.
there are five kinds of permissions i.e.
unique full share pure and immutable that encode whether or not an object is being aliased whether a given reference can modify the referenced object and whether there are other