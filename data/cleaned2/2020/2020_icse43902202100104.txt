fast and precise on the fly patch validation for all lingchao chen department of computer science the university of texas at dallas lxc170330 utdallas.eduyicheng ouyang department of computer science the university of texas at dallas yicheng.ouyang utdallas.edulingming zhang department of computer science university of illinois at urbana champaign lingming illinois.edu abstract generate and validate g v automated program repair apr techniques have been extensively studied during the past decade.
meanwhile such techniques can be extremely time consuming due to the manipulation of program code to fabricate a large number of patches and also the repeated test executions on patches to identify potential fixes.
prapr a recent g v apr technique reduces such costs by modifying program code directly at the level of compiled jvm bytecode with onthe fly patch validation which directly allows multiple bytecode patches to be tested within the same jvm process.
however prapr is limited due to its unique bytecode repair design and is basically unsound imprecise as it assumes that patch executions do not change global jvm state and affect later patch executions on the same jvm process.
in this paper we propose a unified patch validation framework named uniapr to perform the first empirical study of on the fly patch validation for state ofthe art source code level apr techniques widely studied in the literature furthermore uniapr addresses the imprecise patch validation issue by resetting the jvm global state via runtime bytecode transformation.
we have implemented uniapr as a publicly available fully automated maven plugin.
our study demonstrates for the first time that on the fly patch validation can often speed up state of the art source code level apr by over an order of magnitude enabling all existing apr techniques to explore a larger search space to fix more bugs in the near future.
furthermore our study shows the first empirical evidence that vanilla on the fly patch validation can be imprecise unsound while uniapr with jvm reset is able to mitigate such issues with negligible overhead.
i. i ntroduction software bugs are inevitable in modern software systems costing trillions of dollars in financial loss and affecting billions of people .
meanwhile software debugging can be extremely challenging and costly consuming over half of the software development time and resources .
therefore a large body of research efforts have been dedicated to automated debugging techniques .
among the existing debugging techniques automated program repair apr techniques hold the promise of reducing debugging effort by suggesting likely patches for buggy programs with minimal human intervention and have been extensively studied in the recent decade.
please refer to the recent surveys on apr for more details .
generate and validate g v apr refers to a practical category of apr techniques that attempt to fix the bugs by first generating a pool of patches and then validating the patches via certain rules and or checks .
a patch is said to be plausible if it passes all the checks.
ideally we would apply formal verification techniques to guarantee correctness ofgenerated patches.
however in practice formal specifications are often unavailable for real world projects thus making formal verification infeasible.
in contrast testing is the prevalent economic methodology of getting more confidence about the quality of software .
therefore the vast majority of recent g v apr techniques leverage developer tests as the criteria for checking correctness of the generated patches i.e.
test based g v apr.
two main costs are associated with such test based g v apr techniques the cost of manipulating program code to fabricate generate patches based on certain transformation rules repeated executions of all the developer tests to identify plausible patches for the bugs under fixing.
since the search space for apr is infinite and it is impossible to triage the elements of this search space due to theoretical limits testbased g v apr techniques usually lack clear guidance and often act in a rather brute force fashion they usually generate a huge pool of patches to be validated and the larger the program the larger the set of patches to be generated and validated.
this suggests that the speed of patch generation and validation plays a key role in scalability of the apr techniques which is one of the most important challenges in designing practical apr techniques .
therefore apart from introducing new and or more effective transformation rules some apr techniques have been proposed to mitigate the aforementioned costs.
for example jaid uses mutation schema to fabricate meta programs that bundle multiple patches in a single source file while sketchfix uses sketches to achieve a similar effect.
however such techniques mainly aim to speed up the patch generation time while patch validation time has been shown to be dominant during apr .
most recently prapr aims to reduce both patch generation and validation time by modifying program code directly at the bytecode level with on the fly patch validation which directly allows multiple bytecode level patches to be tested within the same jvm process.
however bytecode level apr is not flexible e.g.
large scope changes can be extremely hard to implement at the bytecode level and fails to fix many bugs that can be fixed at the source code level furthermore prapr requires decompilation which may be imprecise or even fail to decompile the bytecode level patches for manual inspection.
in fact all other popular general purpose g v apr techniques fix at the source code level.
in this paper we propose a unified test based patch validation framework named uniapr to empirically study the ieee acm 43rd international conference on software engineering icse .
ieee impact of on the fly patch validation for state of the art sourcecode level apr techniques.
while existing source code level apr usually restarts a new jvm process for each patch our on the fly patch validation aims to use a single jvm process for patch validation as much as possible and leverages jvm s dynamic class redefinition feature a.k.a.
the hotswap mechanism and java agent technology to only reload the patched bytecode classes on the fly for each patch.
in this way uniapr not only avoids reloading also including linking and initializing all used classes for each patch i.e.
only reloading the patched bytecode files but also can avoid the unnecessary jvm warm up time e.g.
the accumulated jvm profiling information across patches enables more and more code to be jit optimized and the already jit optimized code can also be shared across patches .
uniapr has been implemented as a fully automated maven plugin available at to which almost all existing state of the art java apr tools can be attached in the form of patch generation add ons .
we have constructed addons for representative apr tools from different apr families.
specifically we have constructed add ons for capgen simfix and acs that are modern representatives of template pattern based heuristic based and constraint based techniques.
our empirical study shows for the first time that on the fly patch validation can often speed up state of the art apr systems by over an order of magnitude enabling all existing apr techniques to explore a larger search space to fix more bugs in the near future.
furthermore our study section v a2 shows the first empirical evidence that when sharing jvm across multiple patches the global jvm state may be polluted by earlier patch executions making later patch execution results unreliable.
for example some patches may modify some static fields which are used by some later patches sharing the same jvm.
therefore we further propose the first solution to address such imprecision problem by isolating patch executions via resetting jvm states after each patch execution using runtime bytecode transformation.
our experimental results show that our uniapr with jvm reset is able to the avoid imprecision unsoundness of vanilla on the fly patch validation with negligible overhead.
we envision a future wherein all existing apr tools like simfix capgen and acs and major apr frameworks like astor and repairnator are leveraging this framework for patch validation.
in this way researchers will only need to focus on devising more effective algorithms for better exploring the patch search space rather than spending time on developing their own components for patch validation as we can have a unified generic and much faster framework for all.
in summary this paper makes the following contributions framework.
we introduce the first unified on the fly patch validation framework uniapr to empirically study the impact of on the fly patch validation for stateof the art source code level apr techniques.
technique.
we show the first empirical evidence that onthe fly patch validation can be imprecise unsound and introduce a new technique to reset the jvm state right after each patch execution to address such issue.
implementation.
we have implemented on the fly patch validation based on the jvm hotswap mechanism and java agent technology and implemented the jvmreset technique based on the asm bytecode manipulation framework the overall uniapr tool has been implemented as a practical maven plugin and can accept different apr techniques as patch generation add ons.
empirical study.
we conduct a large scale study of the effectiveness of uniapr on its interaction with state ofthe art apr systems from three different apr families demonstrating that uniapr can often speed up state ofthe art apr by over an order of magnitude without validation imprecision unsoundness .
furthermore the study results also indicate that uniapr can serve as a unified platform to naturally support hybrid apr to directly combine the strengths of different apr tools.
ii.
b ackground and related work in this section we first discuss the current status of automated program repair section ii a then we introduce java agent and hotswap on which uniapr is built section ii b .
a. automatic program repair automatic program repair apr aims to suggest likely patches for buggy programs to reduce the manual effort during debugging.
the widely studied generate and validate g v techniques attempt to fix bugs by first generating a pool of patches and then validating the patches via certain rules and or checks .
generated patches that can pass all the tests checks are called plausible patches.
however not all plausible patches are the patches that the developers want.
therefore these plausible patches are further manually checked by the developers to find the final correct patches i.e.
the patches semantically equivalent to developer patches .
g v apr techniques have been extensively studied in recent years since it can substantially reduce developer efforts in bug fixing.
according to a recent work researchers have designed various apr techniques based on heuristics constraint solving and pre defined templates .
besides automated bug fixing researchers have also proposed unified debugging to leverage various off the shelf apr techniques to help with manual bug fixing.
in this way the application scope of apr techniques has been extended to all possible bugs not only the bugs that can be automatically fixed.
meanwhile despite the spectacular progress in designing and applying new apr techniques very few techniques have attempted to reduce the time cost for apr especially the patch validation time which dominates repair process.
for example jaid uses patch schema to fabricate meta programs that bundle several patches in a single source file while sketchfix uses sketches to achieve a similar effect.
although they can potentially help with patch generation and compilation they still require validating each patch in a separte jvm and have been shown to be rather costly during patch validation .
more recently prapr uses direct bytecode level mutation and hotswap to generate and validate patches onthe fly thereby bypassing expensive operations such as ast manipulation compilation on the patch generation side as well as process creation and jvm warm up on the patch validation side.
this makes prapr substantially faster than state of theart apr including jaid and sketchfix .
however prapr is limited to only the bugs that can be fixed via bytecode manipulation and can also return imprecise patch validation results due to potential jvm pollution.
b. java agent and hotswap a java agent is a compiled java program in the form of a jar file that runs alongside of the jvm in order to intercept applications running on the jvm and modify their bytecode.
java agent utilizes the instrumentation api provided by java development kit jdk to modify existing bytecode that is loaded in the jvm.
in general developers can both statically load a java agent using javaagent parameter at jvm startup and dynamically load a java agent into an existing running jvm using the java attach api.
for example to load it statically the manifest of the jar file containing java agent must contain a field premain class to specify the name of the class defining premain method.
such a class is usually referred to as an agent class.
the agent class is loaded before any class in the application class is loaded and the premain method is called before the main method of the application class is invoked.
the premain method usually has the following signature public static void premain string agentargs instrumentation inst .
the second parameter is an object of type instrumentation created by the jvm that allows the java agent to analyze or modify the classes loaded by the jvm or those that are already loaded before executing them.
specifically the redefineclasses method of instrumentation given a class definition which is essentially a class name paired with its new bytecode content even enables dynamically updating the definition of the specified class i.e.
directly replacing certain bytecode file s with the new one s during jvm runtime.
this is typically denoted as the jvm hotswap mechanism.
it is worth mentioning that almost all modern implementations of jvm especially so called hotspot jvms have these features implemented in them.
by obtaining instrumentation object we have a powerful tool using which we can implement a hotswap agent.
as the name suggests hotswap agent is a java agent and is intended to be executed alongside the patch validation process to dynamically reload patched bytecode file s for each patch.
in order to test a generated patch during apr we can pass the patched bytecode file s of the patch to the agent which swaps it with the original bytecode file s of the corresponding ... incrementalcompilation sourceretrieval bytecodepatches originalbytecodefiles... buggyproject classloadershotswapagentjvm patchdb socketaprtoolsaprtoolsaprtools...source codepatches bytecode levelapr compilation source levelapr loading patchexecutionsfig.
uniapr workflow class es .
then we can continue to run tests which result in executing the patched class es i.e.
validating the corresponding patch.
note that subsequent requests to hotswap agent for later patch executions on the same jvm are always preceded by replacing previously patched class es with its original version.
in this way we can validate all patches no matter generated by source code bytecode apr on the fly sharing the same jvm for much faster patch validation.
iii.
a pproach figure depicts an the overall flow of our uniapr framework.
according to the figure given a buggy project uniapr first leverages any of the existing apr tools integrated as uniapr add ons to generate source code level patches marked with .
then uniapr performs incremental compilation to compile the patched source file s by each patch into bytecode file s marked with .
note that uniapr is a unified framework and can also directly take the bytecode patches generated by the prapr and future bytecode apr technique marked with the dashed line directly connecting apr tools into bytecode patches .
in this way uniapr has a pool of bytecode patches for patch validation.
also note that besides constructed before patch validation the patch pool can also be continuously generated during the patchvalidation process1 in either way uniapr s reduction on patch validation time is also not affected.
during the actual patch validation uniapr first compiles the entire buggy project into bytecode files i.e.
.class files and then loads all the bytecode files into the jvm through jvm class loaders marked with and1in the figure .
note that these two steps are exactly the same as executing the original tests for the buggy project.
since all the bytecode files for the original project are loaded within the jvm when validating each patch uniapr only reloads the patched bytecode file s by that particular patch via the java agent technology and hotspot mechanism marked with o as the other unpatched bytecode files are already within 1if patches are continuously generated the patch validation component needs to obtain the live stream of patch information from the running patchgeneration component e.g.
via lightweight socket connections .
1125the jvm .
then the test driver can be triggered to execute the tests to validate against the patch without restarting a new jvm.
after all tests are done for this patch execution uniapr will replace the patched bytecode file s with the original one s to revert to the original version.
furthermore uniapr also resets the global jvm states to prepare a clean jvm environment for the next patch execution marked with the short dashed lines .
the same process is repeated for each patch.
finally the patch validation results will be stored into the patch execution database via socket connections marked with .
note that for any plausible patch that can pass all the tests uniapr will directly retrieve the original source level patch for manual inspection marked with in case the patch was generated by source level apr.
we have already constructed add ons for three different apr tools representing three different families of apr techniques.
these add ons include capgen representing pattern template based apr techniques simfix representing heuristic based techniques and acs representing constraint based techniques .
of course users of uniapr can also easily build new patch generation add ons for other apr tools.
for existing apr tools this can be easily done by modifying their source code so that the tools abandon validation of patches after generating compiling them.
next we will talk about our detailed design for fastpatch validation via on the fly patching section iii a as well as precise patch validation via jvm reset section iii b .
a. fast patch validation via on the fly patching algorithm is a simplified description of the steps that vanilla uniapr without jvm reset takes in order to validate candidate patches on the fly.
the algorithm takes as inputs the original buggy program p its test suite t and the set of candidate patches pgenerated by any apr technique2.
the output is a map r that maps each patch into its corresponding execution result.
the overall uniapr algorithm is rather simple.
uniapr first initializes all patch execution results as unknown line .
then uniapr gets into the loop body and obtains the set of patches still with unknown execution results line .
if there is no such patches the algorithm simply returns since all the patches have been validated.
otherwise it means this is the first iteration or the earlier jvm process gets terminated abnormally e.g.
due to timeout or jvm crash .
in either case uniapr will create a new jvm process line to evaluate the remaining patches line .
we next talk about the detailed validate function which takes the remaining patches the original test suite and a new jvm as input.
for each remaining patch p0 the function first obtains the patched class name s cpatched and patched bytecode file s fpatched within p0 lines and .
then the function leverages our hotswap agent to replace the bytecode file s under the same class name s as cpatched with the patched bytecode file s fpatched it also stores the 2note that here we assume that pis available before patch validation for the ease of presentation but our overall approach is general and can also easily handle the case where pis continuously constructed during patch validation.algorithm vanilla on the fly patch validation input original buggy program p test suitet and set of candidate patches p output validation status r p!f plausible non plausible errorg 1begin 2r p funknowng initialize result function while true do pleft fp0jp02p r p0 unknowng get all the left patches not yet validated ifpleft then returnr return if no left patches 7jvm createjvmprocess create a new jvm validate pleft t jvm validate the left patches on the new jvm 9function validate pleft t jvm forp0inpleft do 11cpatched patchedclassnames p0 12fpatched patchedbytecodefiles p0 swap in the patched bytecode files 13forig hotswapagent swap jvm cpatched fpatched fortintdo try ifrun jvm t failing then status non plausible else status plausible catch timeoutexception memoryerror status error 22r r fp0!statusg ifstatus non plausible then break continue with the next patch when current one is falsified ifstatus error then return restart a new jvm when this current one timed out or crashed swap back the original bytecode files hotswapagent swap jvm cpatched forig replaced bytecode file s as forigto recover it later line .
note that our implementation will explicitly load the corresponding class es to patch e.g.
via class.forname if they are not yet available before swapping.
in this way the function can now execute the tests within this jvm to validate the current patch since the patched bytecode file s has already been loaded lines .
if the execution for a test finishes normally its status will be marked as plausible or non plausible lines otherwise the status will be marked as error e.g.
due to timeout or jvm crash lines .
then p0 s status will be updated in r line .
if the current status is non plausible the function will abort the remaining test executions for the current patch since it has been falsified and move on to the next patch line if the current status is error the function will return to the main algorithm line which will restart the jvm.
when the validation for the current patch finishes without theerror status the function will also recover the patched bytecode file s into the original one s to facilitate the next patch validation line .
b. precise patch validation via jvm reset limitations for vanilla on the fly patch validation the vanilla on the fly patch validation presented in section iii a works for most patches of most buggy projects.
the basic process can be illustrated via figure .
in the figure each 1126examplechallenge monitor resetjvm p1p2p3p4...write c.f objswritereadobjswritereadread assertequals c.f public classc static int f staticobject o clinit f o newobject fig.
imprecision under vanilla uniapr org.joda.time.testyearmonthday constructors.java public class testyearmonthday constructors extends testcase private static final datetimezone paris datetimezone.
forid europe paris private static final datetimezone london datetimezone.
forid europe london private static final chronology gregorian paris gregorianchronology.getinstance paris ... fig.
static field dependency patch e.g.
from p1top4 gets executed sequentially on the same jvm.
it would be okay if every patch accesses and modifies the objects created by itself e.g.
p1andp2will not affect each other and the vanilla on the fly patch validation results for p1andp2will be the same as the ground truth patch validation results.
however it will be problematic if one patch writes to some global space e.g.
static fields and later on some other patch es reads from that global space.
in this way earlier patch executions will affect later patch executions and we call such global space pollution sites .
to illustrate in figure p3write to some static field c.f which is later on accessed by p4.
due to the existence of such pollution site the execution results for p4will no longer be precise e.g.
its assertion will now fail since c.f is no longer although it may be a correct patch.
technical challenges we observe that accesses to static class fields are the main reason leading to imprecise on the fly patch validation.
ideally we only need to reset the values for the static fields that may serve as pollution sites right after each patch execution.
in this way we can always have a clean jvm state to perform patch execution without restarting the jvm for each patch.
however it turns out to be rather challenging first we cannot simply reset the static fields that can serve as pollution sites.
the reason is that some static fields arefinal and cannot be reset directly.
furthermore static fields may also be data dependent on each other thus we have to carefully maintain their original ordering since otherwise the program semantics may be changed.
for example shown in figure final fieldgregorian paris is datadependent on another final field paris under the same class within project joda time from the widely studied defects4j dataset .
the easiest way to keep such ordering and reset final fields is to simply re invoke the original class initializer.
however according to the jvm specification only org.joda.time.testdatetime basics.java public class testdatetime basics extends testcase private static final isochronology iso utc isochronology.getinstanceutc ... org.joda.time.chrono.isochronology.java public final class isochronology extends assembledchronology private static final isochronology cfastcache static cfastcache new isochronology instance utc new isochronology gregorianchronology.
getinstanceutc ccache.put datetimezone.utc instance utc ... fig.
static initializer dependency jvm can invoke such static class initializers.
second simply invoking the class initializers for all classes with pollution sites may not work.
for example a naive way to reset the pollution sites is to simply trace the classes with pollution sites executed during each patch execution then we can simply force jvm to invoke all their class initializers after each patch execution.
however it can bring side effects because the class initializers may also depend on each other.
for example shown in figure within joda time the static initializer of class testdatetime basics depends on the static initializer of isochronology .
iftestdatetime basics is reinitialized earlier than isochronology then field iso utc will no longer be matched with the newest isochronology state.
therefore we have to reinitialize all such classes following their original ordering as if they had been executed on a new jvm.
based on the above analysis we basically have two choices to implement such system customizing the underlying jvm implementation and simulating the jvm customizations at the application level.
although it would be easier to directly customize the underlying jvm implementation the system implementation will not be applicable for other stock jvm implementations.
therefore we choose to simulate the jvm customizations at the application level.
jvm reset via bytecode transformation we now present our detailed approach for resetting jvm at the the application level.
inspired by prior work on speeding up traditional regression testing we perform runtime bytecode transformation to simulate jvm class initializations for patch execution isolation for the first time.
the overall approach is illustrated in figure .
we next present the detailed three phases as follows.
static pollution analysis.
before all the patch executions our approach performs lightweight static analysis to identify all the pollution sites within the bytecode files of all classes for the project under repair including all the application code and 3rd party library code.
note that we do not have to analyze the jdk library code since jdk usually provides public apis to reset the pollution sites within the jdk e.g.
system.setproperties null can be used to reset any prior system properties and system.setsecuritymanager null can be leveraged to reset prior security manager.
the analysis basically 1127p1p2p3p4...public classc static int f staticobject o clinit f o newobject runtimebytecodetransformationstaticpollutionanalysispublic voidresetjvm for class c statusmap.keyset statusmap.put c false resetjdksystemproperties ... dynamicstateresetpublicstaticbooleancheck classc if !statusmap.get c statusmap.put c true returnfalse returntrue public classc static int f staticobject o clinit uniapr clinit public static void uniapr clinit synchronized c.class if !uniapr.check c.class f o newobject fig.
on the fly patch validation via jvm reset returns all classes with non final static fields or final static fields with non primitive types their actual object states in the heap can be changed although their actual