co evolving code with evolving metamodels djamel eddine khelladi cnrs irisa univ.
rennes rennes france djamel eddine.khelladi irisa.frbenoit combemale universit toulouse inria rennes rennes france benoit.combemale irisa.frmathieu acher univ.
rennes inria irisa rennes france mathieu.acher irisa.fr olivier barais univ.
rennes inria irisa rennes france olivier.barais irisa.frjean marc j z quel univ.
rennes inria irisa rennes france jean marc.jezequel irisa.fr abstract metamodels play a significant role to describe and analyze the relations between domain concepts.
they are also cornerstone to build a software language sl for a domain and its associated tooling.
metamodel definition generally drives code generation of a core api.
the latter is further enriched by developers with additional code implementing advanced functionalities e.g.
checkers recommenders etc.
when a sl is evolved to the next version the metamodels are evolved as well before to re generate the core api code.
as a result the developers added code both in the core api and the sl toolings may be impacted and thus may need to be co evolved accordingly.
many approaches support the co evolution of various artifacts when metamodels evolve.
however not the co evolution of code.
this paper fills this gap.
we propose a semi automatic co evolution approach based on change propagation.
the premise is that knowledge of the metamodel evolution changes can be propagated by means of resolutions to drive the code co evolution.
our approach leverages on the abstraction level of metamodels where a given metamodel element has often different usages in the code.
it supports alternative co evaluations to meet different developers needs.
our work is evaluated on three eclipse sl implementations namely ocl modisco and papyrus over several evolved versions of metamodels and code.
in response to five different evolved metamodels we co evolved impacts over projects.a comparison of our co evolved code with the versioned ones shows the usefulness of our approach.
our approach was able to reach a weighted average of .
and .
respectively of precision and recall while supporting useful alternative co evolution that developers have manually performed.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may seoul republic of korea association for computing machinery.
acm isbn ... .
reference format djamel eddine khelladi benoit combemale mathieu acher olivier barais and jean marc j z quel.
.
co evolving code with evolving metamodels.
in 42nd international conference on software engineering icse may seoul republic of korea.
acm new york ny usa pages.
https introduction model driven engineering mde has proven to be effective in the development and maintenance of large scales systems .
notably by easing the task of building software languages sls and their tooling that can play a significant role in all phases of development processes .
when comes the time to specify a sl the metamodel is pivotal and a central artifact .
it introduces the domain concepts which are later used as a cornerstone to build the expected tooling e.g.
editor checker compiler data access layers etc.
.
regular expressions css graphviz are examples of sls that use an explicit initial specification to later drive the development of the corresponding tooling .
however it is often overlooked that metamodels are inputs for complex code generators that leverage on the abstractions used in metamodels e.g.
bidirectional