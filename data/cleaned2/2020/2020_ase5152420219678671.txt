instruguard find and fix instrumentation errors for coverage based greybox fuzzing y uwei liu1 y anhao wang3 purui su1 y uanping y u1 2and xiangkun jia1 1tca sklcs institute of software chinese academy of sciences 2school of cyber security university of chinese academy of sciences 3qianxin technology research institute yuwei2018 purui yuanping2017 xiangkun iscas.ac.cn wangyanhao qianxin.com abstract as one of the most successful methods at vulnerability discovery coverage based greybox fuzzing relies on the lightweight compile time instrumentation to achieve the fine grained coverage feedback of the target program.
researchersimprove it by optimizing the coverage metrics without ques tioning the correctness of the instrumentation.
however instru mentation errors including missed instrumentation locationsand redundant instrumentation locations harm the ability offuzzers.
according to our experiments it is a common andsevere problem in various coverage based greybox fuzzers andat different compiler optimization levels.
in this paper we design and implement instruguard an open source and pragmatic platform to find and fix instrumen tation errors.
it detects instrumentation errors by static analysison target binaries and fixes them with a general solution basedon binary rewriting.
to study the impact of instrumentationerrors and test our solutions we built a dataset of real worldprograms and selected representative fuzzers as targets.
weused instruguard to check and repair the instrumented bina ries with different fuzzers and different compiler optimizationoptions.
to evaluate the effectiveness of the repair we ran thefuzzers with original instrumented programs and the repairedones and compared the fuzzing results from aspects of executionpaths line coverage and real bug findings.
the results showedthat instruguard had corrected the instrumentation errors ofdifferent fuzzers and helped to find more bugs in the dataset.moreover we discovered one new zero day vulnerability missedby other fuzzers with fixed instrumentation but without anychanges to the fuzzers.
index t erms software security fuzzing instrumentation i. i ntroduction coverage based greybox fuzzing has become one of the most popular techniques for software vulnerability discovery due to its ease of use and efficiency .
taking the state of the art fuzzer afl american fuzzy lop and itspopular family tools as examples the workflow of thesegreybox fuzzers can roughly be divided into two main stages instrumentation and fuzzing loop as shown in figure .
theinstrumentation codes injected into compiled programs areused to capture branch edge coverage or other featureswhile fuzzing.
it provides a simple way for fuzzer to auto matically mutate input files towards more coverage based onthe captured feedback.
in this way coverage based greybox co leading authors.
corresponding author.initial seed trim case mutate case execute and monitor next case crash reportfeedbackqueuequeuefuzzing loop instrumentation instrumented programprogram cur location compile time random shared mem prev location cur location basic blockbasic block basic blockcur location compile time random shared mem prev location cur location basic blockbasic block basic block figure the workflow of coverage based greybox fuzzing.
fuzzing could learn the input format and test the deeper program logic without prior knowledge.
as instrumentation feedback is crucial to greybox fuzzer researchers propose lots of approaches to improve it.
partsof them enhance the function of the injected code to recordmore behavior information of the program for detectingspecific vulnerabilities such as concurrency and memorycorruption bugs .
the other of them improve the sensitivity of the instrumentation feedback forall branches to perceive subtle changes of different programstates.
all of the current work strongly relies on an assump tion that the instrumentation for getting coverage feedback iscomplete and accurate.
however according to our analysis the assumption is not always correct.
the current greybox fuzzers provide two methods to inserts instrumentation into each basic block to get accurateedge coverage feedback.
one is the assembly level rewritingapproach.
the other is compiler level instrumentation whichleverages the plugin of compilers such as ll vm .however some factors such as compiler optimizations resultin basic block merging and other impacts that bring a sideeffect of missing instrumentation locations and redundantinstrumentation locations and affect the completeness and 36th ieee acm international conference on automated software engineering ase 36th ieee acm international conference on automated software engineering ase .
ieee .
ase51524.
.
.
ieee accuracy of the instrumentation feedback for both methods.
in the worst case scenario of missing instrumentation lo cations of some basic blocks the fuzzers cannot perceivewhether the missing parts are executed and lose the chanceto find the potential vulnerabilities in the lost code fragments.
in this work we try to find and fix errors of instrumentation and set a series of experiments to figure out the impacts onfuzzing.
for explicitness of our research we name the incor rect instrumentation locations in the instrumented binaries as instrumentation errors and break the problem into threeresearch questions as follows rq1 how serious are instrumentation errors?
rq2 can we fix instrumentation errors of fuzzers?
rq3 does the fixed instrumentation benefit to fuzzing?
to answer the research questions we built a dataset of real world programs collected from recent fuzzing papers asour targets and selected 6representative greybox and whitebox fuzzers i.e.
afl fairfuzz mopt memlock afl andangora to study the impacts.
we instrumented the targetprograms following the fuzzers instructions with their instru mentation methods including assembly level instrumentationand compiler level instrumentation then checked instrumen tation errors in the binaries.
we also studied the impactsof different compiler optimization options.
concretely wetraversed each basic block in the program based on idapro and compared it with the specific patterns to judgewhether it was instrumented or not heuristically.
the resultsshowed that the problem is common in the real world as itexists in both types of instrumentation methods of differentfuzzers and at all compiler optimization levels.
a straightforward solution to fix instrumentation errors is controlling the compiler options.
however according to ourexperiments the compiler level instrumentation errors couldnot be eliminated effectively.
this paper presents a generalmethod based on binary rewriting and we implement a pro totype tool called instruguard to find and fix instrumentationerrors of coverage based greybox fuzzers.
for evaluating our solutions we ran a series of fuzzing experiments on the dataset we built.
more specifically weused code coverage path number and real bugs 1as the metrics to compare the results of original instrumented programsand the fixed ones with different fuzzers.
the results of 72hours times running showed that our fix could ensure the correctness of the instrumentation implementation.
althoughwe are not improving coverage feedback greybox fuzzingdirectly our solutions are beneficial for fuzzing.
we foundone new vulnerability missed by other fuzzers just with thefixed instrumentation but without any changes to the originalfuzzer.
overall the paper makes the following contributions we point out that instrumentation errors includingmissed instrumentation locations and redundant instru1real bugs represent the vulnerabilities found by fuzzers and are manually verified.
we associate each real bug with the corresponding cve id or bug issue number.mentation locations are common for different fuzzers and different compiler optimization options and impactcoverage based greybox fuzzing seriously.
we propose a general solution for instrumentation errorsbased on binary rewriting.
based on the solution wedesign and implement an open source and pragmaticplatform to find and fix instrumentation errors.
we built a dataset of real world programs and eval uated the effectiveness of instruguard by fuzzing thefixed programs and the original instrumented programswithout any modification of the fuzzers.
the resultsshowed that we had corrected the instrumentation ofcoverage based greybox fuzzing and helped to find morevulnerabilities.
to foster future research we will release the source code of instruguard and the dataset at ii.
b ackground a. coverage based greybox fuzzing fuzzing was proposed in the 1990s and developed for decades.
among kinds of fuzzers coverage based grey box fuzzers e.g.
afl attract more attention recentlybecause of their high efficiency and ease of use.
based on amodified form of edge coverage to effortlessly pick up subtle local scale changes to program control flow coverage basedgreybox fuzzing could mutate towards more program pathsand find more vulnerabilities.
to get the coverage feedback coverage based greybox fuzzers implement instrumentation while compiling.
thecode for collecting coverage information is inserted into thetarget program by two methods when the source code isavailable i.e.
assembly level instrumentation and compiler level instrumentation.
we will use afl as the representationof coverage based greybox fuzzers to introduce the details ofinstrumentation in the following paragraphs.
assembly level instrumentation.
afl uses wrappers i.e.
afl gcc andafl clang for two normal compilers i.e.
gcc andclang to conduct assembly level instrumentation and produce binaries.
they parse the assembly file line byline and modify it during the compilation stage accordingto the following rules.
rule1 if the line is a function label branch destination label or conditional jump instruction theywill add instrumentation.
it is mainly because these labels andinstructions mark the boundaries of the basic blocks.
rule2 i f the line is in the section other than text2or after .p2align3 they will leave this basic block un instrumented even thoughthe line satisfies the rule1.
compiler level instrumentation.
the ll vm mode of afl leverages afl clang fast to do compiler level instrumentation via loading ll vm pass while compiling.
it walks 2thetext section is used for keeping the actual assembly code of a program.
hence afl only inserts instrumentation into this section.
3afl does not intend to instrument the basic blocks after .p2align to reduce unnecessary instrumentation while compiling the program under openbsd.
fread hdr sizeof file header f if hdr magic !
magic exit entry ent entry malloc sizeof entry fread ent sizeof entry f if ent type typea if ent 0x6c if ent 0x61 if ent 0x75 if ent 0xde printf fdata f n unsigned int ent ent data.fdata crash if ent 0x6c if ent 0x61 if ent 0x75 if ent 0xde printf fdata f n unsigned int ent ent data.fdata crash if ent 0x61 if ent 0x75 if ent 0xde a source code of the simplified sample.
cmp31 icmp eq i8 0x61 cmp35 icmp eq i8 0x75 or.cond71 and i1 cmp31 cmp35 cmp39 icmp eq i8 0xde or.cond72 and i1 cmp39 or.cond71 br i1 or.cond72 label if.then41 label if.end58 cmp31 icmp eq i8 0x61 cmp35 icmp eq i8 0x75 or.cond71 and i1 cmp31 cmp35 cmp39 icmp eq i8 0xde or.cond72 and i1 cmp39 or.cond71 br i1 or.cond72 label if.then41 label if.end58 b ll vm ir code of the nested if statements.falseloc 400bb9 instrumentation cmp al 6ch jz loc 400cfatrueloc 400bec instrumentation cmp dl 61h jz loc 400cfa true loc 400c13 cmp cl 75h jz loc 400cfa false loc 400cfa instrumentation retntrue loc 400c1c cmp sil 0deh jz loc 400cfa true loc 400c26 instrumentation lea rdi fdata addr call printffalse false eh c control flow graph of the assembly code.
figure motivation example.
including the source code the control flow graph of lines of the source code compiled with o3 and the ir code of lines of the source code.
through all basic blocks at the ll vm ir intermediaterepresentation level and inserts instrumentation codes at thebeginning of each basic block.
b. motivating example the coverage feedback greybox fuzzers assume that the compilers or wrappers they use could carry out correct instrumentation during compilation helping them to obtainaccurate feedback from running states.
however it remainsunexplored whether the compiler could guarantee the accu racy of the instrumentation.
we will illustrate the problemthrough the simplified code snippet in figure 2a.
the sample program 4is simplified from a real world code snippet of the libxml2 library which is a softwarelibrary for parsing xml documents.
it first parses the fileheader and compares the checksum with the magic number.after that it copies the content of the file to ent.
then the program verifies the first four bytes in ent by a nested ifstructure one by one.
only if all the checks are passed through it will trigger the crash at line .
based on the intuition of coverage based greybox fuzzing every branch of the sample program should be instrumentedso that afl could find the crash easily.
but it was sur prising that for binary compiled with o3 i.e.
the default compiler optimization level that afl uses afl could notfind any crashes after hours and failed to cover line8 .
according to our analysis this is because of the incomplete instrumentation.
figure 2c illustrates the controlflow graph of the sample binary.
as the graph shows thenested ifstructure in figure 2a i.e.
line contains four basic blocks i.e.
loc 400bb9 loc 400bec loc 400c13 and loc 400c1c .
to achieve complete instrumentation and sensitive for all branches the greybox fuzzer shouldinstrument all four assembly level basic blocks.
however aninstrumentation error occurs while compiling the programin the ll vm mode of afl.
as figure 2b shows threecompare statements i.e.
line in figure 2a are merged into one ll vm ir level basic block because of the opti mization that the compiler applies.
hence afl clang fast only inserts one instrumentation at the beginning of thebasic block.
in the corresponding binary produced by thecompiler two assembly level basic blocks i.e.
loc 400c13 and loc 400c1c miss instrumentation because of the error.
as a result it loses the ability to perceive two missedbranches and triggers the vulnerability after these basicblocks with a low probability.
c. instrumentation errors of greybox fuzzers according to our observation there are mainly two types of errors in the instrumentation of coverage based greybox fuzzers we named them as instrumentation errors in thispaper .
mil missed instrumentation location means one basic block is missed by instrumentation.
if the basic block is notinstrumented it will not give back some key informationwhen it is executed such as the coverage feedback memory usage behavior and so on.
as a result thefuzzer will not get useful feedback on this basic block andmight discard some newly generated interesting samples which could help the fuzzer explore more program states.
ril redundant instrumentation location means that there is more than one instrumentation inserted in the same basicblock.
ril increases the path depth which misleads thefuzzers depend on the execution depth.
in addition becausegreybox fuzzers use fixed size e.g.
64kb hash tables i.e.
bitmap to store feedback information ril which expands 570algorithm the detection workflow.
input instrumented program output data about instrumentation errors of program p disassemble program for bb p .startbb p .endbb do scan each basic block instruset used to record all instrumentation in a bb offset used to record the offset of instruction in the pattern sequence instsequence empty list used to record successive instructions for inst bb.startinst bb.endinst do scan each instruction ifinstru pa ttern ma tch inst offset then instsequence.
append inst ifoffset s ize intrupattern 1then instruset instruset instsequence offset instsequence else offset offset end if end if end for ifsize instruset 0then milnum else if size instruset 1then rilnum size instruset end if sav e instru info bb instruset milnum rilnum end for the number of instrumentation locations could exacerbate bitmap collision.
some researchers notice that instrumentation could affect fuzzing but few of them analyze and evaluatethe impacts.
as it is an underlying problem for almost allcoverage feedback greybox fuzzers it motivates us to designan automatic tool to find and fix them to ensure fuzzing withcorrect instrumentation.
d. f ocus of this paper in this paper we focus on studying the instrumentation errors of coverage feedback greybox fuzzers with compiletime instrumentation.
we try to develop a tool to find and fixthese errors in the instrumented target binaries.
although weare not improving coverage feedback greybox fuzzing fromthe fuzzing framework or strategies our findings and toolcan cooperate with existing fuzzers and benefit them as theinstrumentation is accurate and complete.
iii.
m ethod according to our analysis instrumentation errors could cause incorrect coverage feedback and further harm fuzzing.to find and fix these errors we firstly design a methodto detect them in target binaries based on static analysis.then we design two methods to fix instrumentation errors firstly we try a straightforward method by changing compileroptions then we propose a general approach based on binaryrewriting named instruguard.
it should be noted that in thissection the basic block represents the assembly level basic block.
a. detect instrumentation errors to detect instrumentation errors we disassemble the instrumented program and examine each basic block heuristically.
as shown in algorithm for a basic block bbof the target program we traverse all the instructions in italgorithm the repair workflow.
input instrumented program output fixed program p disassemble program for bb p .startbb p .endbb do instruset milnum rilnum load instru info bb ifmilnum then insert instru bb else if rilnum then for i rilnum do delete instru bb instruset end for end if end for fixedprogram assemble p line leverage function instrupatternmatch to check each instruction with the specific pattern of the instrumentation which is implemented by the target fuzzer and judge whetherit belongs to the instrumentation line .
if so we add theinstruction inst to the instruction sequence instsequence line .
if the instrumentation pattern is matched exactly line we add instsequence toinstruset line and reset the correlation variables line .
when finishing the traversal we check the number of instruction sequencesin instruset .
if there is no sequence in instruset which means that bbhas a mil error we set the milnum to line .
if there is more than one sequence this bbhas one or more ril errors and we set the rilnum to the number of ril errors line .
after that we save the information of the instrumentation set instruset the number of mil errormilnum and the number of ril errors rilnum line .
1mov reg1 cs afl area ptr shared mem 2xor reg2 cur loc edge id 3add byte ptr shared mem 4mov reg2 cur loc reg2 stores the prev loc listing the template code of the instructions instrumented by afl clang fast .cur loc is a constant and is generated during the compilation.
the patterns we used for matching are extracted from the instrumentation codes of fuzzers.
taking afl as an example the patterns are as following for programs compiled with afl gcc we mark the call instruction to the record function aflmaybe log5as the feature of instrumentation for programs compiled with afl clang fast we highlight the instruction sequence of xor add inc and mov which represents the logic of the inserted instructions of instru mentation as shown in listing .
specifically afl obtainstheedge idby applying xor operation to the cur loc and prev loc adds one to shared mem and stores the left shifted cur loc toprev loc.
if instruguard finds the sequence and the second argument of instructions xor x2 and mov m2 satisfy the equation m2 x2 i t marks the instruction sequence as the instrumentation.
for 5afl inserts a function call to aflmaybe log in each basic block and the parameter to that call is a different value in each basic block.
therefore when this instrumented code is executed afl can log which branch istriggered.
571figure distribution of the number of affected instrumentation location in different optimization flags of clang.
other fuzzers we also manually analyze the features and use them as the prior knowledge for detection.
b. fix instrumentation errors straightforward solution based on compiler options as both of the instrumentation methods are implemented while compiling and the process are affected by compileroptions a straightforward solution is to control compileroptimization options.
intuitively there should be no instru mentation errors if the basic blocks are not optimized duringthe compilation.
we analyzed the impacts of the options oninstrumentation locations by passing different optimizationflags to the compiler.
there are flags of clang and flagsof gcc which could change the number of instrumentationlocations when used alone figure displays the effect andmarks the top flags .
we disabled all these flags to fix theinstrumentation errors and checked the compiled binaries.
however according to our experiments it is not the proper way to fix instrumentation errors.
besides losing theperformance advantage of compiler optimization the instru mentation errors are not mitigated effectively by changingcompiler options.
as shown in table iii the repair rate isonly .
on average.
general solution based on binary rewriting we propose an intuitive but more general repair method that directlyfixes the instrumentation errors on the instrumented binariesbased on binary rewriting.
after identifying whether thereare instrumentation errors and locating the position of theerrors we fix the mil and ril errors following the workingprocedure shown in algorithm .
firstly we disassemble the given program to the assembly code p line .
then we traverse the basic blocks in pto fix the instrumentation errors line .
for a specific basic block bb we load the result of algorithm to get instrumentation setinstruset the number of mil errors milnum and the number of ril errors rilnum line .
if this bbhas a mil error we insert an instruction sequence i.e.
instrumentation to the bb line .
if this bbhas one or more ril errors we remove all instrumentations except the last one in this bb line .
finally we recompile the program pand get the repaired program line .
some instrumentation methods of greybox fuzzers such as the compiler level instrumentation of afl make thepre processing basic blockscontrol flow graphs instrumentation error detectioninstrumentation error correctioncompiler recompileerror logassembly filesinstrumented executable filesgreybox fuzzers instrumentation error logsinstrumented executable filesinstrumentation pattern analysis figure architecture of instruguard.
instrumented code efficient via applying optimizations toinstrumentations during the compilation e.g.
more efficientassign of registers .
hence we rewrite the target programbased on the instrumented binary instead of the vanilla binaryand expect to retain the original correct instrumentations tokeep the performance.
c. implementation we implement a framework named instruguard to find and repair instrumentation errors based on the above design.
the architecture is shown in figure .
instruguard consists ofthree major components the instrumentation error detectioncomponent the error correction component and the compi lation component.
before being processed by instruguard the instrumented executable files are pre processed to getthe information of basic blocks and control flow graphs.the instrumentation patterns are also prepared as our priorknowledge.
the detection component detects instrumentation errors which is developed based on idapython .
it identifiesinstrumentation by matching the instruction sequence withparticular patterns and we adjust the matching patterns todetect instrumentation for different fuzzers as described insection iii a. it is worth noting that ida pro sometimesidentifies a basic block incorrectly due to a false branch labelwith no corresponding jump instruction.
instruguard fixes itby checking the reference of each label with idapython api coderefsto .
the error correction component is implemented based on retrowrite which is a precise and efficient binary rewriting instrumentation tool.
firstly we use it to disas semble the input binary file to the assembly code.
theninstruguard modifies the assembly code to repair the instru mentation errors.
for mil errors it inserts an instructionsequence such as a function call to the record function e.g.
aflmaybe log or a pattern sequence e.g.
as listing shows to conduct instrumentation.
for ril errors it comments out the redundant instructions.
the compilation component produces binary executables based on the modified assembly code.
in detail we write 572a wrapper for the compiler i.e.
gcc to recompile the program.
according to our analysis in section iv b gcc itself will not introduce new instrumentation errors except for several side effects in afl gcc .
for example afl may miss the instrumentation after .p2align due to rule2 if it uses afl gcc to compile programs under a unix like operating system except for openbsd.
iv .
e v alua tion in this section we set experiments to answer the research questions raised in section i. to answer rq1 we instru mented real world programs with the specific implementa tion of different coverage based greybox fuzzers and trieddifferent optimization levels of the compilers they use.
thenwe checked the instrumented programs with instruguard andanalysed the root cause of the instrumentation errors.
forrq2 and rq3 we repaired the instrumented programs witherrors and calculated the fixed rate.
then we ran fuzzers withthe original programs and the fixed ones and compared thefuzzing results.
a. setup experiments program dataset we built a dataset of real world programs by gathering open source linux applications from recent papers published during the last two years withthe corresponding version.
the applications are shownin table i including image parsing and processing libraries text parsing tools multimedia file processing libraries anddeveloping tools.
in addition to version information wealso represent the default optimization option set by theirdevelopers and in which paper the application is selected asthe test bench.
instrumentation methods the instrumentation is related to fuzzers implementation and compiler optimization.in our experiments we selected state of the art fuzzersthat get coverage feedback through instrumentation i.e.
afl fairfuzz mopt memlock angora and afl .
as afl is the most pop ular coverage based greybox fuzzer we chose both theassembly level mode afl gcc and the compiler level mode afl clang fast of it.
fairfuzz mopt and memlock are three tools based on afl but towards different goals.
wechose them to study the afl s family.
chen et al.
rewritethe algorithms of afl in angora so we chose it as thecomparison to avoid simple implementation bugs of greyboxfuzzers.
afl is a union of several improvements of afland contains two different instrumentation methods i.e.
pcguard mode and lto mode.
we tested the above fuzzersand their instrumentation implementation to check whetherinstrumentation errors were common.
fuzzing setting to study the impacts of instrumentation errors on fuzzing and test our solutions we set fuzzingexperiments with the instrumented program and the corre sponding fuzzers.
all the experiments were performed onfive servers running ubuntu .
.
lts and equipping withintel r xeon r cpu e5 v3 .40ghz cores andtable i real world applications used in the experiment.
paper means where the application is selected as the test bench.
package program versiondefault optionpaper libwav wav gain 5cc8746 o2 enfuzz mp3gain mp3gain .
.
o2 mopt libjpeg cjpeg 9a o2 enfuzz lupng lupng 877a76f o0 enfuzz nm .
o2 collafl objdump .
o2 ptrix size .
o2 angora binutils strip .
o2 neuzz libming listswf .
.
o2 profuzzer ngiflib gif2tga c8488d5 o tortoisefuzz catdoc catdoc .
o2 collafl libpng pngfix .
.
o2 angora tiff2pdf .
.
o2 tortoisefuzzlibtifftiff2ps .
.
o2 collafl mpg321 mpg321 .
.
o2 mopt 32gb ram.
the compilers were gcc .
.
and clang .
as gcc .
.
was the default gcc version of ubuntu .
and clang .
was widely used by related works.
for onetarget program we ran experiments on the same server andconfigured it with the same seeds and command.
we used thetest cases of afl as seeds that could be processed by thetarget application.
otherwise we randomly selected files.
theprogram arguments used in the evaluation were the same asthe corresponding papers or issues.
each experiment timeoutwas set to hours.
furthermore we repeated all experiments5 times and took the average value.
we collected paths coverage and real bugs as the fuzzing results.
b. detect instrumentation errors rq1 we compiled the programs in our dataset following the instructions of different fuzzers and with different compiler optimization levels i.e.
o0too3 o3is the default option of afl .
then we checked them with instruguard.
the resultsare shown in table ii.
since fairfuzz and mopt change theseed selection and mutation strategy without modifying theinstrumentation method of the vanilla afl we got the sameinstrumentation results as afl and did not put them in thetable.
we also did not list the data of the programs compiledby afl gcc witho0ando1in the table since they almost had no instrumentation errors.
as table ii shows instrumentation errors are common for different programs and different fuzzers.
programs compiledby different fuzzers all have instrumentation errors.
evensmall packages like libwav whose total number of instrumentation locations is around suffer from instrumen tation errors.
about one fifth of libwav s basic blocks areincorrectly instrumented.
instrumentation locations and the error rate vary a lot among different fuzzers.
programs produced by afl witheither the assembly level or compiler level instrumentationhave the lowest instrumentation error rate.
a deeper analysisshows that the majority of instrumentation errors causedby afl are mil errors.
as for memlock it modifies the 573table ii number of instrumentation locations ils and the percentage of the instrumentation errors err of packages compiled by different fuzzers and different optimization options.
the symbol means the corresponding fuzzer could not compile the package.
afl asm column shows the results of binaries compiled by afl gcc .afl column shows the results of binaries compiled by afl clang fast .i fn o t specified we use o3 as the default option.
programafl asm afl o0 afl o1 afl o2 afl memlock angora afl afl lto ils err ils err ils err ils err ils err ils err ils err ils err ils err catdoc libjpeg ngiflib libming lupng mp3gain binutils libwav mpg321 libpng libtiff average table iii the number of the instrumentation errors before and after applying three fixing methods and the fixing rate.
ori err stands for the instrumentation errors that we found in the program compiled with vanilla fuzzer and after err is the remaining errors after our fixes.
the symbol means the corresponding fuzzer could not compile the binary.
programstraightforward way afl asm afl memlock ori err after err fix rate ori err after err fix rate ori err after err fix rate ori err after err fix rate catdoc .
.
.
cjpeg .
.
.
.
gif2tga .
.
listswf .
.
lupng .
.
.
mp3gain .
.
nm .
.
.
.
objdump .
.
.
.
size .
.
.
.
strip .
.
.
wav gain .
.
mpg321 pngfix .
.
.
tiff2pdf .
.
tiff2ps .
.
average .
.
.
.
instrumentation method of the afl to get more information about the memory and causes more instrumentation errors.on average there exist instrumentation errors in more thanone fourth of basic blocks.
with further analysis the pro grams compiled by memlock have more ril errors thanprograms compiled by other fuzzers.
instrumentation errorsare particularly common for programs compiled by angoraand afl s pcguard mode.
for almost every programcompiled by angora and afl there are instrumentationerrors in more than half of the basic blocks.
the results also show that instrumentation errors introduced by compiler level instrumentation exist in all opti mization options.
in general no matter what optimizationoption is set more than of the basic blocks of a programexist instrumentation errors.
there are fewer instrumentationerrors in the programs compiled by afl clang fast witho0.
but for a specific program compiling with o0could increase the instrumentation errors such as libwav whose error rate reaches .we analyzed these instrumentation errors of different fuzzers to explore the root cause and found out that theroot causes are different for instrumentation errors introducedby assembly level and compiler level instrumentation.
forassembly level instrumentation the errors are caused by side effects of the implementation of afl gcc .
in detail afl misses the instrumentation after .p2align due to the rule2.
besides afl adds redundant instrumentation code afterlabels that do not have the corresponding jump instruction rule1 .
for compiler level instrumentation the errors arecaused by the transformation process from ir code to assem bly code.
as the example in figure shows there is no milor ril in the ir code which is confirmed for other programscompiled with compiler level instrumentation by checkingtheir ir code.
the errors happen during the transformationprocess from ir code to assembly code the ir basic blockswill be split or merged due to the optimization which causesthe mil or ril.
afl memlock angora and afl use compiler level 574table iv code coverage the number of real bugs and the number of paths of the fuzzing result of the repaired program and the original program.
the last line is average for coverage and paths and sum for real bugs.
re stands for the result of the repaired program.
afl asm column shows the results of binaries compiled by afl gcc .afl column shows the results of binaries compiled by afl clang fast .
programafl asm o0 afl asm o1 afl asm afl asm re afl afl re bugs coverage paths bugs coverage paths bugs coverage paths bugs coverage paths bugs coverage paths bugs coverage paths catdoc .
.
.
.
.
.
cjpeg .
.
.
.
.
.
gif2tga .
.
.
.
.
.
listswf .
.
.
.
.
.
lupng .
.
.
.
.
.
mp3gain .
.
.
.
.
.
nm .
.
.
.
.
.
objdump .
.
.
.
.
.
size .
.
.
.
.
.
strip .
.
.
.
.
.
wav gain .
.
.
.
.
.
mpg321 .
.
.
.
.
pngfix .
.
.
.
.
.
tiff2pdf .
.
.
.
.
.
tiff2ps .
.
.
.
.
.
sum a ver .
.
.
.
.
.
programfairfuzz fairfuzz re mopt mopt re memlock memlock re bugs coverage paths bugs coverage paths bugs coverage paths bugs coverage paths bugs coverage paths bugs coverage paths catdoc .
.
.
.
.
.
cjpeg .
.
.
.
.
.
gif2tga .
.
.
.
.
.
listswf .
.
.
.
.
.
lupng .
.
.
.
.
.
mp3gain .
.
.
.
.
.
nm .
.
.
.
.
.
objdump .
.
.
.
.
.
size .
.
.
.
.
.
strip .
.
.
.
.
.
wav gain .
.
.
.
.
.
mpg321 .
.
.
.
pngfix .
.
.
.
.
.
tiff2pdf .
.
.
.
.
.
tiff2ps .
.
.
.
.
.
sum a ver .
.
.
.
.
.
instrumentation however our experiments show that programs compiled by angora and afl have far moreinstrumentation errors.
we did further research and foundthat besides the instrumentation they do more modificationsto the program during the compilation.
angora would splitthe basic block containing condition statements such as cmp andswitch statement and generate two new branches.
the two branches are the same in program logic and the branchtarget but one of the branches will collect the informationof the condition statement.
this strategy is proposed to cutdown the overhead of the constraint solving process.
similarto angora afl employs pc guard strategy to speed upthe fuzzing which adds new basic blocks into the programduring the compilation process.
these new basic blocks onlycontain a mov and a jmp instruction which are used to load the edge id from the global memory.
as most of the coverage based greybox fuzzers are based on afl and we have found great quantities of instrumenta tion errors caused by these state of the art fuzzers we cansee that instrumentation errors are common in real worldcoverage based greybox fuzzers.c.
repair instrumentation errors rq2 we have demonstrated that there are vast numbers of mils and rils in programs compiled by fuzzers like afl andmemlock.
to repair the instrumentation errors we appliedtwo methods proposed in section iii b to them.
table iiishows the effect of our repairs.
since retrowrite now couldnot handle binaries compiled by angora and afl we onlylisted fuzzers in the table more discussions in section v .
as we mentioned in section iii b1 we could not completely repair errors with the straightforward solution bycontrolling compiler optimization options.
however withinstruguard we almost eliminated all instrumentation errorswith a rate of .
for programs compiled by the compiler level mode of afl.
for the programs compiled by theassembly level mode of afl and memlock instruguardachieved the similar effect with a repair rate of over .
.
we manually verified each unfixed instrumentation error in ida pro by checking the assembly code of the fixedprograms and did further research on them.
we found theyare detection errors instead of unfixed errors.
most of theerrors are because of the missing branch label in the code 575loc 1600 instrumentation cmp eax 20746d66h jnz loc 16f9 loc 16ab instrumentation call malloc call read content loc 16f9 instrumentation retnfalse true falsetrue true false instrumentation call read headercmp eax 46464952hjnz loc 16f9 952hloc 1626 cmp eax 61746164h jz loc 16ab figure the simplified control flow graph of the code around the memory allocation point in wavgain .
structures like switch .
the argument of the jump instruction in the switch is a register like rax rather than a branch label.
the original programs have jump table information soida pro could identify the basic blocks accurately.
however after the re compilation process of retrowrite the jump tableinformation is lost which makes ida pro miss the label inthe destination basic block of the jump instruction.
d. fuzz with repaired instrumentation rq3 to evaluate the effectiveness of our repairs we ran a series of fuzzing experiments with the programs generated by fuzzers instrumentation toolchains and the repair method.the results are shown in table iv and we use the number ofreal bugs the line coverage of source code and the numberof paths as the metrics.
we can find that the fuzzing results of the repaired binaries are better at bugs and paths than the fuzzing results ofthe original ones with instrumentation errors.
afl finds 1more real bugs in total and covers .
more lines of codeon average for the assembly level mode.
for compiler levelmode afl can trigger almost more paths find morereal bugs one of which is not reported before and triggersimilar coverage on average with the repaired programs.fairfuzz and memlock are better at all three aspects withour binary rewrite solution while mopt seems not to benefitmuch.
for specific programs although afl covers the sameamount of code .
when fuzzing gif2tga compiled with afl clang fast it finds more paths from to with the repaired instrumentation which results infinding more bugs from to .
memlock cannot find anybug in the origin cjpeg but it finds bugs in the repaired cjpeg .
new vulnerability.
with repaired instrumentation we fortunately found a new vulnerability of memory leak in wavgain the original afl could not find this bug in the program because of its inaccurate instrumentation.
weanalyzed the vulnerability based on the bug report and foundthere were several mil errors which are shown in figure .table v fuzzing speed and the overview of p values from mann whitney u test.
the instru column is the fuzzing speed of binaries compiled by afl clang fast witho3and fixed by instruguard.
afl asm column shows the results of binaries compiled byafl gcc .afl column shows the results of binaries compiled by afl clang fast .mpg321 can not be compiled with o0.
programinstru afl asm o0 afl asm o3 afl means means p value means p value means p value catdoc .
.
.
cjpeg .
.
.
gif2tga .
.
.
listswf .
.
.
lupng .
.
.
mp3gain .
.
.
nm .
.
.
objdump .
.
.
size .
.
.
strip .
.
.
wav gain .
.
.
mpg321 .
.
libpng .
.
.
tiff2pdf .
.
.
tiff2ps .
.
.
av g .
.
.
just as the example in the section ii b the switch code is optimized to a series of comparisons and some basic blocksare not instrumented so they cannot be perceived by afl.we repaired the instrumentation errors along the vulnerablepaths giving us the ability to explore the vulnerable pathsand discover the vulnerability.
on the contrary even thoughafl might trigger the vulnerable path but would abandon theseed based on the wrong feedback caused by instrumentationerrors.
the new vulnerability is assigned with cve which shows our repair is a benefit to fuzzing.
e. performance overhead to evaluate the performance of instruguard we compared the execution speed of programs before and after being repaired while fuzzing process besides compared with severalcompilation optimization levels.
we took the execution speedof programs which are compiled by afl clang fast with o3and fixed by instruguard to represent the performance of instruguard since afl clang fast is recommended by the fuzzing community and o3is the default optimization level.
firstly we compared the performance of binaries fixed byinstruguard with binaries compiled by afl gcc .
it is worth noting that binaries compiled by afl gcc witho0ando1are free of instrumentation errors.
as the performance resultsof binaries compiled with o1and with o3are similar we did not show the result of o1 in the table.
as table v shows the average fuzzing speed i.e.
execution times eachsecond of binaries fixed by instruguard is .
faster thanbinaries compiled by afl gcc with o0 and .
faster thano3.
compared to binaries compiled by afl gcc with o0 .
of of binaries fixed by instruguard are significantly faster based on the p values and of15 of binaries are faster compared to o3.
although binaries a afl gcc.
b afl clang fast.
figure the distribution of mil and ril errors.
compiled by afl gcc witho0are free from the instrumentation errors our method could achieve better performance.
for other optimization levels binaries fixed by instruguard arealso comparable in performance.
combining with table iv except instruguard o1 ando0 might be good choices if one compiles binaries with afl gcc and does not care about the execution speed while using afl to test them.
theirperformance in finding bugs is comparable with o3 and they cause no instrumentation errors.
we also compared the performance of binaries fixed by instruguard with the unfixed binaries compiled by afl clang fast with o3.
we found that binaries fixed by our tool are similar to them regardless of the mean valuesor significant analysis.
surprisingly the fuzzing speed of thefixed mpg321 is even faster than the unfixed one which might be due to the shrinking size of the binary after the rewriting.the shrunken parts comes from the relocation table the ehframe hdr section and the ehframe section which are discarded by retrowrite after rewriting.
as for the overhead the processing time of instruguard is seconds on average for the tested programs and themaximum time is seconds for mp3gain .
compared with our entire fuzzing cycle hours the average overhead isminimum .
.
f .
case study we took a further step based on the extended dataset to analyze the real world instrumentation errors and shared some interesting observations.
figure shows the distributionof the mil and ril errors.
since the programs compiled by afl gcc witho0oro1are free from instrumentation errors we did not present them in the figure.
mil whether the program is compiled by afl gcc orafl clang fast mil accounts for the majority of instrumentation errors.
after preliminary manual analysis wefound that mil occurs mostly in multiple continuous com parison logic in ir code.
to verify this discovery we wrotean ll vm pass to identify the corresponding logic and foundthat more than of the mils happen around the multiplecontinuous comparison logic.
the pass also matched themultiple continuous comparison logic in ir code with thesource code.
the corresponding source code can be roughlyloc 400b70 instrumentation cmp eax ja default case false true default case instrumentation jmp loc 400c85 loc 400c85 instrumentation retncase 0 instrumentation jmp loc 400c80case 19 instrumentation jmp loc 400c80case 3 instrumentation jmp loc 400c80switch jump jmp ds off 401178 switch jump jmp ds off 401178 loc 400c80 call puts s figure the simplified control flow graph of switch code structure in optimization option o3inafl clang fast .
categorized into code patterns 1switch statement nested condition statements such as if if continuous ifreturn statement loop nested conditional statement such asfor if and condition statement with multiple logical operators such as or .
figure is an example of objdump which contained two mils.
the switch jump basic block and the other in loc 400c80 were missed with instrumentation by afl clang fast with o3.
without feedback from switch jump basic block afl will treat two different paths i.e.
path with basic blocks of loc 400b70 switch jump default case and the path of loc 400b70 default case as the same and record only one of them.
if afl records pathof loc 400b70 default case it will generate fewer paths in which eax does not exceed .
under this situation afl will leave some numerically sensitive crashes undiscovered and vice versa.
1std map std string std string longs 2longs a 3longs b ... 5longs y listing the code fragment of params getopt .
ril most rils exist in c programs for afl.
listing displays the function params getopt inexiv2 which has the max number of rils with the optimizationoption o1.
each assignment operation results in adding three more rils during the compilation and it has rilsin total.
similar ril errors happen in bento4 which contains instrumentations in one basic block of function ap4hvccatom updaterawbytes .
this basic block contains call instructions which call the same function withdifferent arguments and after each call instruction there is aredundant instrumentation location.
v. t hrea t to validity internal validity.
fuzzing is a random process that may have an impact on the results of our evaluation.
to mitigate 577the effect of randomness we extended the timeout to hours and repeated our experiments times according to theevaluation suggestions .
besides the process of binaryrewriting could change the program behavior and introducenew vulnerabilities.
in order to eliminate these possibleeffects we double checked each bug with original programscompiled with address sanitizer while fuzzing as wellas gathered the line coverage of source code with the originalprograms.
external validity.
due to the limitation of the retrowrite the binary rewriting tool we use instruguard now could onlyfind instrumentation errors for c programs and binariescompiled by angora and afl but could not fix them.
it ismainly because that retrowrite has trouble handling binariesthat contain c exceptions fails to disassemble binariescompiled by angora and generates non compilable assemblycode for binaries compiled by afl .
however since ourrepair method has been proven effective once retrowriteis updated or more powerful binary rewrite tools come out instruguard will be able to fix instrumentation errors for allfuzzers.
in this paper we also did not fix the program instrumented by fuzzers that use selective instrumentation.
we selected 6fuzzers as the research targets since they are representativeand differ in instrumentation methods.
they all try to exploreas many paths as possible.
however other types of fuzzersalso exist.
for example some fuzzers are designed forspecific types of vulnerability they could only instrumentthe interesting basic blocks or paths without triggering un related paths.
for these fuzzers we could extend instruguardwith additional configurations to detect instrumentation errorsalong a specific path to ensure they act as expected.
vi.
r ela ted work the most related researches and techniques are presented in the following two parts including greybox fuzzing andinstrumentation.
greybox fuzzing.
researchers improve fuzzing from various aspects.
some of them are applied after the instrumen tation process.
vuzzer skyfire neuzz andfaster fuzzing learn the important bytes or the grammarsof the input files for more effective mutations.
mopt optimizes the seed mutation scheduling strategies with theparticle swarm optimization pso algorithm.
aflfast allocates more energy to test the low frequency paths tooptimize the path exploration.
driller qsym andt fuzz integrate static and dynamic analysis to prioritizehard to reach deeper paths.
others modify the instrumented code to record more program behaviors or improve the sensitivity of the feedback.to guide the testing towards specific locations aflgo modifies the instrumentation to calculate the distancebetween the current path and the target location.
memlock and uafl collect the memory behavior of theprograms to find more memory related bugs.
angora uses call stack while afl sensitive uses n gram toidentify the different paths more specifically.
instrumentation.
instrumentation approaches can be divided to binary instrumentation and source instrumentation.usually binary instrumentation is applied when the sourcecode of the tested program is unavailable and could slowdown the program significantly.
some fuzzers obtain feedback with dynamic binary instrumentationtools such as qemu dynamorio and hardware accelerated intel processor trace.
fuzzers like afl dyninst use static instrumentation tools to obtain feedback.specifically they use code patching techniques to injectcallback events to gather coverage or other information.
afl family fuzzers mainly get feedback through source instrumentation which inserts a piece ofspecific code to each basic block while the target programis compiled with gcc or ll vm.
only a little research isconducted about the instrumentation problem.
afl cc leverages controlled optimization to minimize the differ ence such as basic block layout between the ll vm ircode and the binary and tries to get accurate feedbackfor fuzzers.
unifuzz notices that the instrumentationmethod might affect the program behavior such as whetherthe certain bug could be triggered and thus the fuzzingevaluation.
however they do not systemically analyze theimpact of instrumentation errors and fix the problem.
vii.
c onclusion in this paper we point out two types of instrumentation errors in coverage based greybox fuzzers and propose aframework named instruguard to find and fix instrumentationerrors.
we assessed the impacts of instrumentation errors ongreybox fuzzers with a dataset of real world programs and evaluated the effectiveness of our repairs through fuzzingfrom the aspect of the number of paths line coverage ofsource code and the number of real bugs.
the resultsshowed that instrumentation errors are common for mostcompilation optimization levels and coverage based greyboxfuzzers and impact the fuzzing results.
our method fixedinstrumentation errors effectively and benefited coverage based greybox fuzzers.
a cknowledgement we thank the anonymous reviewers of this work for their helpful feedback.
this research is supported in part by national natural science foundation of china grantno.
u1936211 u1836117 u1836113 and thestrategic priority research program of the chinese academyof sciences grant no.
xdc02020300.
all opinions ex pressed in this paper are solely those of the authors.
r eferences cve .
ida pro idapython hon docs .
f. bellard qemu a fast and portable dynamic translator in proceedings of the annual conference on usenix annual technical conference pp.
.
m. b ohme v .
pham and a. roychoudhury coverage based greybox fuzzing as markov chain ieee transactions on software engineering vol.
no.
pp.
.
m. b ohme v .
t. pham m. d. nguyen and a. roychoudhury directed greybox fuzzing in proceedings of the acm sigsac conference on computer and communications security pp.
.
d. bruening e. duesterwald and s. amarasinghe design and implementation of a dynamic optimization framework for windows in4th acm workshop on feedback directed and dynamic optimization fddo .
b. buck and j. k. hollingsworth an api for runtime code patching int.
j. high perform.
comput.
appl.
vol.
no.
pp.
.
h. chen y .
xue y .
li b. chen x. xie x. wu and y .
liu hawkeye towards a desired directed grey box fuzzer in acm conference on computer and communications security .
p .
chen and h. chen angora efficient fuzzing by principled search inproceedings of the ieee symposium on security and privacy.
ieee computer society .
y .
chen p .
li j. xu s. guo r. zhou y .
zhang t. wei and l. lu savior towards bug driven hybrid testing in ieee symposium on security and privacy sp .
ieee pp.
.
y .
chen d. mu j. xu z. sun w. shen x. xing l. lu and b. mao ptrix efficient hardware assisted fuzzing for cots binary inproceedings of the acm asia conference on computer and communications security ser.
asia ccs .
y .
chen y .
jiang f. ma j. liang m. wang c. zhou x. jiao and z. su enfuzz ensemble fuzzing with seed synchronizationamong diverse fuzzers in proceedings of the 28th usenix security symposium .
m. cho s. kim and t. kwon intriguer field level constraint solving for hybrid fuzzing in proceedings of the acm sigsac conference on computer and communications security pp.
.
s. dinesh n. burow d. xu and m. payer retrowrite statically instrumenting cots binaries for fuzzing and sanitization in ieee symposium on security and privacy sp .
ieee pp.
.
a. fioraldi d. maier h. ei feldt and m. heuse afl combining incremental steps of fuzzing research in 14th usenix workshop on offensive technologies woot .
usenix association aug. .
s. gan c. zhang p .
chen b. zhao x. qin d. wu and z. chen greyone data flow sensitive fuzzing in 29th usenix security symposium .
s. gan c. zhang x. qin x. tu k. li z. pei and z. chen collafl path sensitive fuzzing in proceedings of the ieee symposium on security and privacy.
ieee .
w. junjie c. bihuan w. lei and l. y ang skyfire data driven seed generation for fuzzing in ieee symposium on security and privacy pp.
.
g. klees a. ruef b. cooper s. wei and m. hicks evaluating fuzz testing in proceedings of the acm sigsac conference on computer and communications security .
laf intel circumventing fuzzing roadblocks with compiler transformations .
c. lattner and v .
adve ll vm a compilation framework for lifelong program analysis transformation in proceedings of the international symposium on code generation and optimization feedback directed and runtime optimization.
ieee computer society .
c. lemieux r. padhye k. sen and d. song perffuzz automatically generating pathological inputs in proceedings of the 27th acm sigsoft international symposium on software testing and analysis .
c. lemieux and k. sen fairfuzz a targeted mutation strategyfor increasing greybox fuzz testing coverage in proceedings of the 33rd acm ieee international conference on automated softwareengineering .
y .
li b. chen m. chandramohan s. w. lin y .
liu and a. tiu steelix program state based binary fuzzing in proceedings of the 11th joint meeting on f oundations of software engineering.acm .
y .
li s. ji y .
chen s. liang w. h. lee y .
chen c. lyu c. wu r. beyah p .
cheng et al.
unifuzz a holistic and pragmatic metrics driven platform for evaluating fuzzers in 30th usenix security symposium usenix security .
c. lyu s. ji c. zhang y .
li w. h. lee y .
song and r. beyah mopt optimized mutation scheduling for fuzzers in proceedings of the 28th usenix security symposium .
b. p .
miller l. fredriksen and b. so an empirical study of the reliability of unix utilities commun.
acm .
s. nagy and m. hicks full speed fuzzing reducing fuzzing overhead through coverage guided tracing in ieee symposium on security and privacy sp .
ieee pp.
.
n. nichols m. raugas r. jasper and n. hilliard faster fuzzing reinitialization with deep neural models corr vol.
abs .
.
h. peng y .
shoshitaishvili and m. payer t fuzz fuzzing by program transformation in ieee symposium on security and privacy pp.
.
s. rawat v .
jain a. kumar l. cojocar c. giuffrida and h. bos vuzzer application aware evolutionary fuzzing in proceedings of the 24th network and distributed system security symposium .
k. serebryany d. bruening a. potapenko and d. vyukov addresssanitizer a fast address sanity checker in usenix conference on technical conference .
k. serebryany continuous fuzzing with libfuzzer and addresssanitizer ieee .
oss fuzz google s continuous fuzzing service for open source software .
d. she k. pei d. epstein j. y ang b. ray and s. jana neuzz efficient fuzzing with neural program smoothing in ieee symposium on security and privacy sp .
ieee .
l. simon and a. v erma improving fuzzing through controlled compilation in 5th ieee european symposium on security and privacy euros p .
n. stephens j. grosen c. salls a. dutcher r. wang j. corbetta y .
shoshitaishvili c. kruegel and g. vigna driller augmentingfuzzing through selective symbolic execution in proceedings of the 23rd network and distributed systems security symposium .
r. swiecki honggfuzz .
talos vulndev afl dyninst ninst .
d. v eillard libxml2 the xml c parser and toolkit of gnome .
h. wang x. xie y .
li c. wen y .
li y .
liu s. qin h. chen and y .
sui typestate guided fuzzer for discovering use after freevulnerabilities in ieee acm 42nd international conference on software engineering icse pp.
.
j. wang y .
duan w. song h. yin and c. song be sensitive and collaborative analyzing impact of coverage metrics in greyboxfuzzing in 22nd international symposium on research in attacks intrusions and defenses .
j. wang b. chen l. wei and y .
liu superion grammar aware greybox fuzzing in ieee acm 41st international conference on software engineering.
ieee pp.
.
y .
wang c. zhang x. xiang z. zhao w. li x. gong b. liu k. chen and w. zou revery from proof of concept to exploitable inproceedings of the acm sigsac conference on computer and communications security .
y .
wang x. jia y .
liu k. zeng t. bao d. wu and p .
su not all coverage measurements are equal fuzzing by coverage accounting forinput prioritization in ndss .
c. wen h. wang y .
li s. qin y .
liu z. xu h. chen x. xie g. pu and t. liu memlock memory usage guided fuzzing inproceedings of the acm ieee 42nd international conference onsoftware engineering.
icse .
m. xu s. kashyap h. zhao and t. kim krace data race fuzzing for kernel file systems in ieee symposium on security and privacy sp .
ieee pp.
.
s. y an c. wu h. li w. shao and c. jia pathafl path coverage assisted fuzzing proceedings of the 15th acm asia conference on computer and communications security .
w. y ou x. wang s. ma j. huang x. zhang x. wang and b. liang profuzzer on the fly input type probing for better zero day vulnerability discovery in ieee symposium on security 579and privacy.
ieee pp.
.
i. y un s. lee m. xu y .
jang and t. kim qsym a practical concolic execution engine tailored for hybrid fuzzing in proceedings of the 27th usenix security symposium.
usenix association .
m. zalewski american fuzzy lop afl fuzzer dump.cx afl .
l. zhao y .
duan h. yin and j. xuan send hardest problems my way probabilistic path prioritization for hybrid fuzzing in ndss .
y .
zheng a. davanian h. yin c. song h. zhu and l. sun firmafl high throughput greybox fuzzing of iot firmware via augmentedprocess emulation in 28th usenix security symposium pp.
.